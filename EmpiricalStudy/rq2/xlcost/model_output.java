boolean sumOfTwoCubes ( int n ) { long lo = 1 , hi = ( long ) Math . cbrt ( n ) ; while ( lo <= hi ) { long curr = ( lo * lo * lo + hi * hi * hi ) ; if ( curr == n ) return true ; if ( curr < n ) lo ++ ; else hi -- ; } return false ; }
int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] != 0 && a [ i ] % a [ j ] == 0 ) { if ( ( a [ i ] + a [ j ] ) == ( a [ i ] / a [ j ] ) ) count ++ ; } } } return count ; }
int check ( int A , int B ) { if ( A == B ) { return 1 ; } int dig1 = ( int ) Math . floor ( Math . log10 ( A ) + 1 ) ; int dig2 = ( int ) Math . floor ( Math . log10 ( B ) + 1 ) ; if ( dig1 != dig2 ) { return 0 ; } int temp = A ; while ( true ) { int power = ( int ) Math . pow ( 10 , dig1 - 1 ) ; int firstdigit = A / power ; A = A - firstdigit * power ; A = A * 10 + firstdigit ; if ( A == B ) { return 1 ; } if ( A == temp ) { return 0 ; } } }
boolean checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( Math . sqrt ( x ) ) ; i ++ ) { if ( x == i * ( i + 1 ) ) { return true ; } } return false ; }
void oddDivisors ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int powerOfTwo = 2 ; int count = 0 ; while ( powerOfTwo <= arr [ i ] ) { count ++ ; powerOfTwo = 2 * powerOfTwo ; } System . out . print ( count + " " ) ; } return ; }
int calcScr ( int arr [ ] ) { int ans = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) ans += ( i ^ arr [ i ] ) ; return ans ; }
void maxAdjacent ( int [ ] arr , int N ) { List < Integer > res = new ArrayList < > ( ) ; int arr_max = Integer . MIN_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { arr_max = Math . max ( arr_max , Math . abs ( arr [ i - 1 ] - arr [ i ] ) ) ; } for ( int i = 1 ; i < N - 1 ; i ++ ) { int curr_max = Math . abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; int ans = Math . max ( curr_max , arr_max ) ; res . add ( ans ) ; } for ( int x : res ) System . out . print ( x + " " ) ; System . out . println ( ) ; }
void flippingBits ( long N , long K ) { long X = ( 1 << ( K - 1 ) ) - 1 ; N = X - N ; System . out . print ( N ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
void minMoves ( int arr [ ] , int N ) { int odd_element_cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } int moves = ( odd_element_cnt ) / 2 ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; System . out . println ( moves ) ; }
int findSum ( int arr [ ] , int N ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int sum_odd = 0 , sum_even = 0 ; for ( Map . Entry < Integer , Integer > itr : mp . entrySet ( ) ) { if ( itr . getValue ( ) % 2 != 0 ) sum_odd += ( itr . getKey ( ) ) * ( itr . getValue ( ) ) ; if ( itr . getValue ( ) % 2 == 0 ) sum_even += ( itr . getKey ( ) ) * ( itr . getValue ( ) ) ; } int diff = sum_even - sum_odd ; return diff ; }
int findNumber ( int arr [ ] , int n ) { int res = 0 ; int maxElement = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res = res ^ arr [ i ] ; if ( maxElement < arr [ i ] ) maxElement = arr [ i ] ; } res = onesComplement ( res , maxElement ) ; return ( res ) ; }
int findValOfNWithOperat ( int N , int K ) { if ( N % 2 == 0 ) { N += K * 2 ; } else { N += smallestDivisorGr1 ( N ) + ( K - 1 ) * 2 ; } return N ; }
int CntOfSubsetsByPartitioning ( int arr [ ] , int N ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } } int freqGCD = 0 ; for ( Map . Entry < Integer , Integer > i : freq . entrySet ( ) ) { freqGCD = gcd ( freqGCD , i . getValue ( ) ) ; } return ( N ) / freqGCD ; }
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { alternateSum += - i ; } else { alternateSum += i ; } } return alternateSum ; }
int countOperations ( int arr [ ] , int N ) { int count_zeros = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) count_zeros ++ ; } int sum = array_sum ( arr , N ) ; if ( count_zeros != 0 ) return count_zeros ; if ( sum == 0 ) return 1 ; return 0 ; }
int power ( int x , int N ) { int res = 1 ; while ( N > 0 ) { if ( N % 2 == 1 ) { res = ( res * x ) ; } x = ( x * x ) ; N = N >> 1 ; } return res ; }
long F_1 ( long N , long F_N ) { long P_2 = power ( 2 , N - 1 ) ; long modInv = moduloInverse ( P_2 ) ; long res ; res = ( ( modInv % M ) * ( F_N % M ) ) % M ; return res ; }
void findNumbers ( int n ) { int i = 0 ; while ( i <= n ) { System . out . print ( 2 * i * i + 4 * i + 1 + i % 2 + " " ) ; i ++ ; } }
boolean isPower ( int x , int y ) { int res1 = ( int ) Math . log ( y ) / ( int ) Math . log ( x ) ; double res2 = ( int ) Math . log ( y ) / ( int ) Math . log ( x ) ; return ( res1 == res2 ) ; }
int countPairs ( int A [ ] , int B [ ] , int N , int M , int List [ ] [ ] ) { int count = 0 ; int par [ ] = new int [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) par [ i ] = i ; for ( int i = 0 ; i < M ; i ++ ) { int index1 = find ( par , List [ i ] [ 0 ] - 1 ) ; int index2 = find ( par , List [ i ] [ 1 ] - 1 ) ; if ( index1 != index2 ) { unionn ( par , index1 , index2 ) ; } } HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { mp . put ( A [ i ] , i ) ; } for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { if ( mp . containsKey ( B [ i ] ) ) { count ++ ; continue ; } int j = mp . get ( B [ i ] ) ; if ( find ( par , i ) != find ( par , j ) ) count ++ ; } } return count ; }
void minDivisior ( int n ) { if ( prime ( n ) ) { System . out . print ( 1 + " " + ( n - 1 ) ) ; } else { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { System . out . print ( n / i + " " + ( n / i * ( i - 1 ) ) ; break ; } } } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int Find_min ( HashSet < Integer > diff_mod , HashMap < Integer , Integer > count_mod , int k ) { int min_oprn = Integer . MAX_VALUE ; int oprn = 0 ; for ( int x = 0 ; x < k ; x ++ ) { oprn = 0 ; for ( int w : diff_mod ) { if ( w != x ) { if ( w == 0 ) { oprn += Math . min ( x , k - x ) * count_mod . get ( w ) ; } else { oprn += Math . min ( Math . abs ( x - w ) , k + x - w ) * count_mod . get ( w ) ; } } } if ( oprn < min_oprn ) min_oprn = oprn ; } return min_oprn ; }
double maxSubarrayRatio ( double arr [ ] , int n ) { double maxRatio = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { double ratio = arr [ i ] ; for ( int k = i + 1 ; k <= j ; k ++ ) { ratio = ratio / arr [ k ] ; } maxRatio = Math . max ( maxRatio , ratio ) ; } } return maxRatio ; }
boolean is_possible ( int x , int y ) { if ( x < 2 && y != 0 ) return false ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return true ; else return false ; }
int sum_of_differences ( int arr [ ] , int N ) { int sum = 0 ; int i , j , flag ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) { flag = 0 ; for ( j = i + 1 ; j < N - 1 ; j ++ ) { if ( arr [ j ] >= arr [ j + 1 ] ) { sum += ( arr [ j ] - arr [ i ] ) ; i = j ; flag = 1 ; break ; } } if ( flag == 0 && arr [ i ] < arr [ N - 1 ] ) { sum += ( arr [ N - 1 ] - arr [ i ] ) ; break ; } } } return sum ; }
void getLastTwoPerson ( int n ) { int total = n ; Node head = new Node ( 1 ) ; Node temp = head ; for ( int i = 2 ; i <= n ; i ++ ) { temp . next = new Node ( i ) ; temp = temp . next ; } temp . next = head ; temp = head ; Node del ; while ( total != 2 ) { del = temp . next . next ; temp . next . next = temp . next . next . next ; temp = temp . next ; del = temp . next ; } System . out . print ( temp . val + " " + temp . next . val ) ; }
int gcd ( int x , int y ) { if ( x == 0 ) return y ; return gcd ( y % x , x ) ; }
boolean check ( int n ) { int temp = n ; while ( temp > 0 ) { int last_digit = temp % 10 ; if ( last_digit == 0 last_digit == 1 ) return false ; if ( n % last_digit == 0 ) return false ; temp = temp / 10 ; } return true ; }
void costOfSubsequence ( int N , int arr [ ] , int costArray [ ] ) { int i , temp ; int cost = 0 ; HashSet < Integer > removedElements = new HashSet < Integer > ( ) ; int ans = 0 ; for ( i = 1 ; i < ( N - 1 ) ; i ++ ) { temp = arr [ i ] ; if ( ( ( arr [ i - 1 ] < temp ) && ( temp < arr [ i + 1 ] ) ) || ( ( arr [ i - 1 ] > temp ) && ( temp > arr [ i + 1 ] ) ) ) { removedElements . add ( temp ) ; } } for ( i = 0 ; i < ( N ) ; i ++ ) { temp = arr [ i ] ; if ( ! ( removedElements . contains ( temp ) ) ) { ans += arr [ i ] ; } else { cost += costArray [ i ] ; } } System . out . print ( ans + ", " ) ; System . out . print ( cost ) ; }
void findRatio ( int arr [ ] , int n ) { int gcd = findGCD ( arr , n ) ; int lcm = findLCM ( arr , n ) ; System . out . println ( lcm / gcd + ":" + 1 ) ; }
int PentacontahenagonNum ( int N ) { return ( 49 * N * N - 47 * N ) / 2 ; }
boolean isRepdigit ( int num , int b ) { int prev = - 1 ; while ( num > 0 ) { int digit = num % b ; num /= b ; if ( prev != - 1 && digit != prev ) return false ; prev = digit ; } return true ; }
boolean isHonakerPrime ( int n ) { int pos = position [ n ] ; if ( pos == - 1 ) return false ; return getSum ( n ) == getSum ( pos ) ; }
boolean checkDivisibility ( int n , int digit ) { return ( digit != 0 && n % digit == 0 ) ; }
int lastDigit ( int n ) { return ( n % 10 ) ; }
int count ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( check ( arr [ i ] & arr [ j ] ) ) cnt ++ ; } } return cnt ; }
void calculate_SPF ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i <= MAX ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i <= MAX ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j <= MAX ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
boolean isBrilliant ( int n ) { int flag = 0 ; boolean isPrime [ ] = new boolean [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 2 ; i < n ; i ++ ) { int x = n / i ; if ( isPrime [ i ] && isPrime [ x ] && x * i == n ) { if ( countDigit ( i ) == countDigit ( x ) ) return true ; } } return false ; }
int icosikaienneagonalNum ( int n ) { return ( 27 * n * n - 25 * n ) / 2 ; }
boolean isPerfectTotientNum ( int n ) { int temp = n ; int sum = 0 ; while ( n > 1 ) { sum = sum + phi ( n ) ; n = phi ( n ) ; } if ( sum == temp ) return true ; return false ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
void solve ( long N ) { long ans = 0 ; while ( N != 0 ) { ans += N ; N /= 2 ; } System . out . println ( ans ) ; }
void smallestNumber ( int N ) { int L = ( int ) Math . pow ( 10 , N ) - 1 ; int S = ( int ) Math . pow ( 10 , N - 1 ) ; for ( int i = S ; i <= L ; i ++ ) { if ( i % N == 0 ) { System . out . print ( i ) ; return ; } } }
int maxAdjacentDifference ( int N , int K ) { if ( N == 1 ) { return 0 ; } if ( N == 2 ) { return K ; } return 2 * K ; }
int CountPairs ( int arr [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return ( even * ( even - 1 ) ) / 2 + ( even * odd ) ; }
int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
void smallestNumber ( int N ) { int i = 1 ; while ( true ) { if ( getSum ( i ) == N ) { System . out . print ( i ) ; break ; } i ++ ; } }
boolean isZuckerman ( int n ) { return n % getProduct ( n ) == 0 ; }
boolean isGiugaNum ( int n ) { if ( ! ( isComposite ( n ) ) ) return false ; int N = n ; while ( n % 2 == 0 ) { if ( ( N / 2 - 1 ) % 2 != 0 ) return false ; n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( ( N / i - 1 ) % i != 0 ) return false ; n = n / i ; } } if ( n > 2 ) if ( ( N / n - 1 ) % n != 0 ) return false ; return true ; }
void updateFreq ( int n , int [ ] freq ) { while ( n > 0 ) { int digit = n % TEN ; freq [ digit ] ++ ; n /= TEN ; } }
boolean OrmistonPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && areAnagrams ( n1 , n2 ) ) ; }
int calculateKummer ( int n ) { int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result = result * primes . get ( i ) ; return - 1 + result ; }
void SieveOfEratosthenes ( int maxm ) { prime [ 0 ] = prime [ 1 ] = true ; for ( int i = 2 ; i * i <= maxm ; i ++ ) { if ( ! prime [ i ] ) { for ( int j = i * i ; j <= maxm ; j += i ) { prime [ j ] = true ; } } } }
long func ( int arr [ ] , int n ) { double ans = 0 ; int maxx = 0 ; double freq [ ] = new double [ 100005 ] ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = Math . max ( maxx , temp ) ; } for ( int i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( int i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] > 0 ) { i = ( double ) i ; double j ; long value = 0 ; double cur = Math . ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { int val = Math . min ( maxx , ( int ) ( Math . ceil ( i * j ) - 1.0 ) ) ; int times = ( freq [ i ] - freq [ i - 1 ] ) , con = j - 0.5 ; ans += times * con * ( freq [ ( int ) val ] - freq [ ( int ) cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ( long ) ans ; }
double findAverageOfCube ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * i * i ; } return sum / n ; }
int find ( int x ) { if ( x == 0 ) return 0 ; int p = ( int ) ( Math . log ( x ) / Math . log ( 2 ) ) ; return binpow ( 2 , p + 1 ) - 1 ; }
int totalCountDifference ( int n ) { String ans = getBinary ( n ) ; int req = 0 ; for ( int i = 0 ; i < ans . length ( ) ; i ++ ) { if ( ans . charAt ( i ) == '1' ) { req += find ( ( int ) Math . pow ( 2 , i ) ) ; } } return req ; }
int findIndex ( int n ) { float x = ( float ) Math . sqrt ( 2 * Math . pow ( 10 , ( n - 1 ) ) ) ; return ( int ) Math . round ( x ) ; }
void getParity ( int n , int [ ] A ) { for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] & 1 == 1 ) { System . out . println ( "Even" ) ; return ; } } System . out . println ( "Odd" ) ; }
void lastTwoDigits ( long N ) { if ( N >= 10 ) { System . out . print ( "00" ) ; return ; } long fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fac = ( fac * i ) % 100 ; System . out . print ( fac ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }
int findArrangement ( int N ) { if ( N < 3 ) return 0 ; return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) / 3 ; }
int sumOfProductOfDigits ( int n1 , int n2 ) { int sum = 0 ; while ( n1 > 0 && n2 > 0 ) { sum += ( ( n1 % 10 ) * ( n2 % 10 ) ) ; n1 /= 10 ; n2 /= 10 ; } return sum ; }
boolean divisorsSame ( int n ) { return ( n - 2 ) % 4 == 0 ; }
int countSubsequences ( int arr [ ] , int n ) { int totalSubsequence = ( int ) Math . pow ( 2 , n ) - 1 ; int countPrime = 0 , countOnes = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) countOnes ++ ; else if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } int compositeSubsequence ; int onesSequence = ( int ) Math . pow ( 2 , countOnes ) - 1 ; compositeSubsequence = totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ; return compositeSubsequence ; }
int Centered_Hexadecagonal_num ( int n ) { return ( 8 * n * n - 8 * n + 1 ) ; }
boolean isdecagonal ( int N ) { double n = ( 3 + Math . sqrt ( 16 * N + 9 ) ) / 8 ; return ( n - ( int ) n ) == 0 ; }
boolean ishendecagonal ( int N ) { double n = ( 7 + Math . sqrt ( 72 * N + 49 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; }
boolean isenneadecagonal ( int N ) { double n = ( 15 + Math . sqrt ( 136 * N + 225 ) ) / 34 ; return ( n - ( int ) n ) == 0 ; }
boolean isPowerOfTwo ( int n ) { return ( Math . ceil ( Math . log ( n ) / Math . log ( 2 ) ) == Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; }
void cntArray ( int A [ ] , int N ) { int result = 0 ; int frequency [ ] = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { frequency [ A [ i ] ] ++ ; } for ( int i = 1 ; i <= N ; i ++ ) { int frequency_of_i = frequency [ i ] ; result += + ( ( frequency_of_i ) * ( frequency_of_i + 1 ) ) / 2 ; } System . out . println ( result ) ; }
String solve ( int [ ] A ) { int i , ctr = 0 ; for ( i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] % 2 != 0 ) { ctr ++ ; } } if ( ctr % 2 != 0 ) { return "No" ; } else { return "Yes" ; } }
void findNumbers ( int N ) { for ( int i = 1 ; i <= N / 2 ; i ++ ) { System . out . print ( i + ", " + ( - i ) + ", " ) ; } if ( N % 2 == 1 ) System . out . print ( 0 ) ; }
int previousPerfectSquare ( int N ) { int prevN = ( int ) Math . floor ( Math . sqrt ( N ) ) ; if ( prevN * prevN == N ) prevN -= 1 ; return prevN * prevN ; }
int digit_sum ( int n ) { int sum = 0 , m ; while ( n > 0 ) { m = n % 10 ; sum = sum + m ; n = n / 10 ; } return ( sum ) ; }
void dfs ( int node , int parent ) { if ( isPerfect ( weight [ node ] ) ) ans += 1 ; for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } }
int MinimumGCD ( int arr [ ] , int n ) { int g = 0 ; for ( int i = 0 ; i < n ; i ++ ) { g = __gcd ( g , arr [ i ] ) ; } return g ; }
void fibonacciSubarrays ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int sum = 0 ; for ( int j = i ; j < n ; ++ j ) { sum += arr [ j ] ; if ( isFibonacci ( sum ) ) { ++ count ; } } } System . out . println ( count ) ; }
double Gill ( double x0 , double y0 , double x , double h ) { int n = ( int ) ( ( x - x0 ) / h ) ; double k1 , k2 , k3 , k4 ; double y = y0 ; for ( int i = 1 ; i <= n ; i ++ ) { k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; k3 = h * dydx ( x0 + 0.5 * h , y + 0.5 * ( - 1 + Math . sqrt ( 2 ) ) * k1 + k2 * ( 1 - 0.5 * Math . sqrt ( 2 ) ) ) ; k4 = h * dydx ( x0 + h , y - ( 0.5 * Math . sqrt ( 2 ) ) * k2 + k3 * ( 1 + 0.5 * Math . sqrt ( 2 ) ) ) ; y = y + ( 1.0 / 6 ) * ( k1 + ( 2 - Math . sqrt ( 2 ) ) * k2 + ( 2 + Math . sqrt ( 2 ) ) * k3 + k4 ) ; x0 = x0 + h ; } return y ; }
void PythagoreanTriplet ( int n ) { int flag = 0 ; for ( int a = 1 ; a < n ; a ++ ) { int b = ( n * n - 2 * n * a ) / ( 2 * n - 2 * a ) ; int c = n - a - b ; if ( a * a + b * b == c * c && b > 0 && c > 0 ) { System . out . print ( a + " " + b + " " + c ) ; flag = 1 ; break ; } } if ( flag == 0 ) { System . out . print ( "-1" ) ; } return ; }
void Display ( int arr [ ] , boolean Expo_Prime [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( Expo_Prime [ arr [ i ] ] ) System . out . print ( arr [ i ] + " " ) ; }
float operations ( int N ) { int x = probability ( N ) ; int y = ( int ) Math . pow ( 2 , N ) ; return ( float ) Math . round ( ( float ) x / ( float ) y , 2 ) ; }
long pairs ( int n ) { long [ ] [ ] c = new long [ 10 ] [ 10 ] ; int tmp = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ i / tmp ] [ i % 10 ] ++ ; } long ans = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) for ( int j = 1 ; j < 10 ; j ++ ) ans += ( long ) c [ i ] [ j ] * c [ j ] [ i ] ; return ans ; }
int gcdFibonacciFreq ( int arr [ ] , int n ) { Set < Integer > hash = new HashSet < Integer > ( ) ; createHash ( hash , Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ) ; int i , j ; HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } int gcd = 0 ; for ( Map . Entry < Integer , Integer > it : m . entrySet ( ) ) { if ( hash . contains ( it . getValue ( ) ) ) { gcd = gcd ( gcd , it . getKey ( ) ) ; } } return gcd ; }
String sumBaseB ( String a , String b , int base ) { int len_a , len_b ; len_a = a . length ( ) ; len_b = b . length ( ) ; String sum , s ; s = "" ; sum = "" ; int diff ; diff = Math . abs ( len_a - len_b ) ; for ( int i = 1 ; i <= diff ; i ++ ) s += "0" ; if ( len_a < len_b ) a = s + a ; else b = s + b ; int curr , carry = 0 ; for ( int i = Math . max ( len_a , len_b ) - 1 ; i > - 1 ; i -- ) { curr = carry + ( a . charAt ( i ) - '0' ) + ( b . charAt ( i ) - '0' ) ; carry = curr / base ; curr = curr % base ; sum = ( char ) ( curr + '0' ) + sum ; } if ( carry > 0 ) sum = ( char ) ( carry + '0' ) + sum ; return sum ; }
boolean isPerfectCube ( int x ) { double cr = Math . round ( Math . cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; }
int countPairsWithProdK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == k ) count ++ ; } return count ; }
void genArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( search ( arr , i , arr [ i ] ) == - 1 ) arr [ i + 1 ] = 0 ; else arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) ; } }
Vector < Integer > getPerfectcubes ( int n ) { Vector < Integer > perfectcubes = new Vector < > ( ) ; int current = 1 ; int i = 1 ; while ( current <= n ) { perfectcubes . add ( current ) ; i += 1 ; current = ( int ) ( Math . pow ( i , 3 ) ) ; } return perfectcubes ; }
HashMap < Integer , Integer > insertPF ( HashMap < Integer , Integer > primeFact , int fact ) { if ( primeFact . containsKey ( fact ) ) { primeFact . put ( fact , primeFact . get ( fact ) + 1 ) ; } else { primeFact . put ( fact , 1 ) ; } return primeFact ; }
void isPerfectSquare ( int x ) { double sr = Math . round ( Math . sqrt ( x ) ) ; if ( sr * sr == x ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
void canBePerfectCube ( int N , int K ) { if ( isPerfectCube ( N + K ) || isPerfectCube ( N - K ) ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
int summation ( int n ) { int abs_sum = n * ( n + 1 ) / 2 ; int sign = n + 1 % 2 == 0 ? 1 : - 1 ; int result_sum = sign * abs_sum ; return result_sum ; }
Vector < Integer > findArray ( int xorr [ ] , int n ) { Vector < Integer > arr = new Vector < Integer > ( ) ; int xor_all = xor_all_elements ( n ) ; int xor_adjacent = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { xor_adjacent = xor_adjacent ^ xorr [ i ] ; } int last_element = xor_all ^ xor_adjacent ; arr . add ( last_element ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { last_element = xorr [ i ] ^ last_element ; arr . add ( last_element ) ; } return arr ; }
void compute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i ) ; } }
int calNum ( int year ) { return ( year / 4 ) - ( year / 100 ) + ( year / 400 ) ; }
int maxValue ( int n ) { return n ; }
void findSum ( int arr [ ] , int n ) { sieve ( MAX ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = min_prime [ arr [ i ] ] + max_prime [ arr [ i ] ] ; System . out . print ( sum + " " ) ; } }
double squareRoot ( double n , float l ) { double x = n ; double root ; int count = 0 ; while ( true ) { count ++ ; root = 0.5 * ( x + ( n / x ) ) ; if ( Math . abs ( root - x ) < l ) break ; x = root ; } return root ; }
int countNumber ( int N , int S ) { int countElements = 0 ; int currSum = 0 ; while ( currSum <= S ) { currSum += N ; N -- ; countElements ++ ; } return countElements ; }
int countDistinct ( int n ) { int arr [ ] = new int [ 10 ] ; int count = 0 ; while ( n > 0 ) { int r = n % 10 ; arr [ r ] = 1 ; n /= 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( arr [ i ] != 0 ) count ++ ; } return count ; }
int lcm ( int a , int b ) { return ( a / __gcd ( a , b ) * b ) ; }
boolean checkZeroArray ( int arr [ ] , int n ) { int sum = 0 , maximum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + arr [ i ] ; maximum = Math . max ( maximum , arr [ i ] ) ; } if ( sum % 2 == 0 && maximum <= sum / 2 ) return true ; return false ; }
long getSum ( int n ) { int start = ( int ) Math . pow ( 10 , n - 1 ) ; int end = ( int ) Math . pow ( 10 , n ) - 1 ; long sum = 0 ; for ( int i = start ; i <= end ; i ++ ) { String s = String . valueOf ( i ) ; if ( isPalindrome ( s ) ) { sum += i ; } } return sum ; }
int findMinDel ( int [ ] arr , int n ) { int min_num = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) min_num = Math . min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; }
boolean isPossible ( int x , int y ) { if ( ( x - y ) == 1 ) return false ; return true ; }
int numSeq ( int n ) { return ( ( int ) Math . pow ( 3 , n ) + 3 * ( int ) Math . pow ( - 1 , n ) ) / 4 ; }
boolean digitDividesK ( int num , int k ) { while ( num > 0 ) { int d = num % 10 ; if ( d != 0 && k % d == 0 ) return true ; num = num / 10 ; } return false ; }
int xorK ( int n , int k ) { int res = n ; for ( int i = 1 ; i < k ; i ++ ) res = ( res ^ n ) ; return res ; }
boolean distinctDigits ( int x ) { boolean [ ] present = new boolean [ MAX ] ; while ( x > 0 ) { int digit = x % 10 ; if ( present [ digit ] ) return false ; present [ digit ] = true ; x /= 10 ; } return true ; }
boolean isPossible ( int arr [ ] , int n , int p ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( gcd , arr [ i ] ) ; if ( p % gcd == 0 ) return true ; return false ; }
int cntCakes ( int n , int m ) { int sum = ( n * ( n + 1 ) ) / 2 ; int quo = m / sum ; int rem = m % sum ; double ans = m - quo * sum ; double x = ( - 1 + Math . pow ( ( 8 * rem ) + 1 , 0.5 ) ) / 2 ; ans = ans - x * ( x + 1 ) / 2 ; return ( int ) ans ; }
long factMod ( int n ) { long fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact *= ( i % MOD ) ; fact %= MOD ; } return fact ; }
boolean isEulerPseudoprime ( int N , int A ) { if ( A <= 0 ) return false ; if ( N % 2 == 0 || ! isComposite ( N ) ) return false ; if ( __gcd ( A , N ) != 1 ) return false ; int mod = Power ( A , ( N - 1 ) / 2 , N ) ; if ( mod != 1 && mod != N - 1 ) return false ; return true ; }
int minDifference ( int L , int R ) { int fst = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( isPrime [ i ] ) { fst = i ; break ; } } int snd = 0 ; for ( int i = fst + 1 ; i <= R ; i ++ ) { if ( isPrime [ i ] ) { snd = i ; break ; } } if ( snd == 0 ) return - 1 ; int diff = snd - fst ; int left = snd + 1 ; int right = R ; for ( int i = left ; i <= right ; i ++ ) { if ( isPrime [ i ] ) { if ( i - snd <= diff ) { fst = snd ; snd = i ; diff = snd - fst ; } } } return diff ; }
int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
int no_of_ways ( int a [ ] , int n ) { int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; } if ( count_1 % 2 == 0 ) return count_0 ; else return count_1 ; }
int longest_gap ( int N ) { int distance = 0 , count = 0 , first_1 = - 1 , last_1 = - 1 ; while ( N > 0 ) { count ++ ; int r = N & 1 ; if ( r == 1 ) { first_1 = first_1 == - 1 ? count : first_1 ; last_1 = count ; } N = N / 2 ; } if ( last_1 <= first_1 ) { return - 1 ; } else { distance = ( last_1 - first_1 - 1 ) ; return distance ; } }
boolean isPossible ( int n ) { int cnt = Integer . bitCount ( n ) ; if ( cnt == TOTAL_BITS / 2 ) return true ; return false ; }
int total_ways ( int N , int X ) { return ( nCr ( N - 1 , X - 1 ) + nCr ( N - 1 , X ) ) ; }
long getSum ( int n ) { long sum = 0 ; int k = ( int ) Math . sqrt ( n ) ; for ( int i = 1 ; i <= k ; i ++ ) { sum += Math . floor ( n / i ) ; } sum *= 2 ; sum -= Math . pow ( k , 2 ) ; return sum ; }
int getCount ( int l , int r , int p ) { int cnt = 0 ; int val = p ; while ( true ) { int a = r / val ; int b = ( l - 1 ) / val ; val *= p ; if ( a - b > 0 ) { cnt += ( a - b ) ; } else break ; } return cnt ; }
void heapify ( int arr [ ] , int n , int i ) { int smallest = i ; int l = 2 * i + 1 ; int r = 2 * i + 2 ; if ( l < n && arr [ l ] < arr [ smallest ] ) smallest = l ; if ( r < n && arr [ r ] < arr [ smallest ] ) smallest = r ; if ( smallest != i ) { int temp = arr [ i ] ; arr [ i ] = arr [ smallest ] ; arr [ smallest ] = temp ; heapify ( arr , n , smallest ) ; } }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int nextPrime ( int N ) { if ( N <= 1 ) return 2 ; int prime = N ; boolean found = false ; while ( ! found ) { prime ++ ; if ( isPrime ( prime ) ) found = true ; } return prime ; }
void find_Solution ( double x , int n ) { double sum = x , e = 2 , o = 1 , p = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { p += 2 ; sum += ( double ) ( o / e ) * ( double ) ( Math . pow ( x , p ) / p ) ; o = o * ( o + 2 ) ; e = e * ( e + 2 ) ; } System . out . println ( sum ) ; }
void solveOdd ( int n , int arr [ ] , int b [ ] ) { int left = n - 1 ; for ( int i = 0 ; i < ( n / 2 ) + 1 ; ++ i ) { b [ i ] = arr [ left ] ; left = left - 2 ; if ( left < 0 ) break ; } int right = 1 ; for ( int i = ( n / 2 ) + 1 ; i <= n - 1 ; ++ i ) { b [ i ] = arr [ right ] ; right = right + 2 ; if ( right > n - 2 ) break ; } }
int countSetBits ( int n ) { n ++ ; int powerOf2 = 2 ; int cnt = n / 2 ; while ( powerOf2 <= n ) { int totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs & 1 ) != 0 ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; }
int nCr ( int n ) { if ( n < 4 ) return 0 ; int answer = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; answer /= 24 ; return answer ; }
int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
int findReachable ( int arr [ ] , int D , int A , int B , int n ) { int gcd_AB = GCD ( A , B ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - D ) % gcd_AB == 0 ) count ++ ; } return count ; }
int getSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 && arr [ i ] == sumOfFactors ( arr [ i ] ) ) { sum += arr [ i ] ; } } return sum ; }
boolean isPossible ( int k ) { if ( exists_zero ) { if ( k >= cnt_neg && ( k - cnt_neg ) % 2 == 0 ) return true ; else return false ; } else { if ( k >= cnt_neg ) return true ; else return false ; } }
int power ( int x , int y ) { int res = 1 ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) ; y = y >> 1 ; x = ( x * x ) ; } return res ; }
int solve ( int L ) { int n = L / 2 + 1 ; int ans = power ( n , n - 2 ) ; return ans ; }
long total_permutations ( HashMap < Character , Integer > freq ) { long cnt = 0 ; long denom = 1 ; for ( Map . Entry < Character , Integer > itr : freq . entrySet ( ) ) { denom *= fact ( itr . getValue ( ) ) ; cnt += itr . getValue ( ) ; } return fact ( cnt ) / denom ; }
int solveQuery ( int L , int X ) { int res ; int a [ ] = new int [ MAXN ] ; int b [ ] = new int [ L ] ; int ref = X , size_a = 0 ; while ( ref > 0 ) { a [ size_a ] = ref % 2 ; ref /= 2 ; size_a ++ ; } for ( int i = 0 ; i < Math . min ( size_a , L ) ; i ++ ) { if ( a [ i ] == 1 ) b [ i ] = 0 ; else b [ i ] = 1 ; } for ( int i = Math . min ( size_a , L ) ; i < L ; i ++ ) b [ i ] = 1 ; b [ L - 1 ] = 1 ; int temp = 0 , p = 1 ; for ( int i = 0 ; i < L ; i ++ ) { temp += b [ i ] * p ; p *= 2 ; } res = temp ^ X ; return res ; }
int closetAND ( int arr [ ] , int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; if ( X <= k ) break ; } } return ans ; }
int countQuadruplets ( int l , int r , int k ) { int frequency [ ] = new int [ r + 1 ] ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = l ; j <= r ; j ++ ) { frequency [ gcd ( i , j ) ] ++ ; } } int answer = 0 ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= r ; j ++ ) { if ( gcd ( i , j ) == k ) { answer += ( frequency [ i ] * frequency [ j ] ) ; } } } return answer ; }
int maxBitElement ( int arr [ ] , int n ) { int num = 0 , max = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = countSetBits ( arr [ i ] ) ; if ( cnt > max ) { max = cnt ; num = arr [ i ] ; } } return num ; }
void Add_Edge ( int u , int v ) { gr [ u ] . add ( v ) ; gr [ v ] . add ( u ) ; }
long factorial ( long n , long p ) { for ( int i = 2 ; i <= n ; i ++ ) res = ( res * i ) % p ; return res ; }
int getValueOfF ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; int cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n /= 2 ; } return 2 * cnt ; }
void printNumbers ( int a [ ] , int n , int x ) { boolean flag = false ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; int g = __gcd ( num , x ) ; while ( g != 1 ) { num /= g ; g = __gcd ( num , x ) ; } if ( num == 1 ) { flag = true ; System . out . print ( a [ i ] + " " ) ; } } if ( ! flag ) System . out . println ( "There are no such numbers" ) ; }
void line ( double x0 , double y0 ) { double c = 2 * y0 * x0 ; System . out . print ( y0 + "x" + " + " + x0 + "y = " + c ) ; }
boolean isDudeney ( int n ) { int cube_rt = ( int ) Math . round ( ( Math . pow ( n , 1.0 / 3.0 ) ) ) ; if ( cube_rt * cube_rt * cube_rt != n ) return false ; int dig_sum = 0 ; int temp = n ; while ( temp > 0 ) { int rem = temp % 10 ; dig_sum += rem ; temp /= 10 ; } if ( cube_rt != dig_sum ) return false ; return true ; }
void Positive_Divisors ( ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) d [ i ] ++ ; else d [ i ] += 2 ; } } } int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( d [ i ] == d [ i - 1 ] ) ans ++ ; pre [ i ] = ans ; } }
int oddDays ( int N ) { int hund1 = N / 100 ; int hund4 = N / 400 ; int leap = N >> 2 ; int ord = N - leap ; if ( hund1 != 0 ) { ord += hund1 ; leap -= hund1 ; } if ( hund4 != 0 ) { ord -= hund4 ; leap += hund4 ; } int days = ord + leap * 2 ; int odd = days % 7 ; return odd ; }
float ellipsearea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 3.14f * r * r ) / 4 ; return a ; }
void recamanGenerator ( int arr [ ] , int n ) { arr [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == temp ) temp < 0 ) { temp = arr [ i - 1 ] + i ; break ; } } arr [ i ] = temp ; } }
long power ( long a , long n ) { if ( n == 0 ) return 1 ; long p = power ( a , n / 2 ) ; p = p * p ; if ( ( n & 1 ) == 1 ) p = p * a ; return p ; }
int findPairCount ( int N , int K ) { int count = 0 ; int rem [ ] = new int [ K ] ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ; if ( K % 2 == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }
boolean doesContainB ( int a , int b , int c ) { if ( a == b ) return true ; if ( ( b - a ) * c > 0 && ( b - a ) % c == 0 ) return true ; return false ; }
void sieve ( ) { for ( int i = 0 ; i < N ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int i = 2 ; i < N ; i ++ ) if ( prime [ i ] ) for ( int j = i * 2 ; j < N ; j += i ) prime [ j ] = false ; }
void lastDigit ( String a , String b ) { int lastDig = ( a . charAt ( a . length ( ) - 1 ) - '0' ) * ( b . charAt ( b . length ( ) - 1 ) - '0' ) ; System . out . print ( lastDig % 10 ) ; }
void printPalindrome ( int n ) { if ( n == 1 ) { System . out . println ( "Smallest Palindrome: 0" ) ; System . out . println ( "Largest Palindrome: 9" ) ; } else { System . out . println ( "Smallest Palindrome: " + ( int ) Math . pow ( 10 , n - 1 ) + 1 ) ; System . out . println ( "LargestPalindrome:" ) ; } }
int countDigits ( int a , int b ) { int count = 0 ; int p = Math . abs ( a / b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
void nDigitPerfectCubes ( int n ) { int smallest = ( int ) Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n - 1 ) ) ) ) , 3 ) ; System . out . print ( smallest + " " ) ; int largest = ( int ) Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ; System . out . print ( largest ) ; }
long sumOfSeries ( int n ) { long ans = ( long ) Math . pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; }
int countNumbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * ( int ) Math . pow ( 10 , n / 2 - 1 ) ) ; }
int KthMinValAfterMconcatenate ( int A [ ] , int N , int M , int K ) { Arrays . sort ( A ) ; return ( A [ ( ( K - 1 ) / M ) ] ) ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : factorial ( n - 1 ) * n ; }
int gcdOfFactorial ( int arr [ ] , int n ) { int minm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minm = minm > arr [ i ] ? arr [ i ] : minm ; return factorial ( minm ) ; }
int findMinimum ( int n , int m ) { int mini = m ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int sec = n / i ; if ( __gcd ( m , i ) > 1 ) { return i ; } else if ( __gcd ( sec , m ) > 1 ) { mini = Math . min ( sec , mini ) ; } } } if ( mini == m ) return - 1 ; else return mini ; }
double getProbability ( int a , int b , int c , int d ) { double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ; double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; }
int findMinSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; }
int getPosition ( int n , int m ) { if ( m > ( n / 2 ) ) return ( m - ( n / 2 ) ) ; return ( m + ( n / 2 ) ) ; }
int matrixOrValueOne ( boolean arr [ ] [ ] ) { int p_arr [ ] [ ] = new int [ n ] [ n ] ; findPrefixCount ( p_arr , arr ) ; int count_zero_submatrices = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int i = n - 1 ; Stack < pair > q = new Stack < pair > ( ) ; int to_sum = 0 ; while ( i >= 0 ) { int c = 0 ; while ( q . size ( ) != 0 && q . peek ( ) . first > p_arr [ i ] [ j ] ) { to_sum -= ( q . peek ( ) . second + 1 ) * ( q . peek ( ) . first - p_arr [ i ] [ j ] ) ; c += q . peek ( ) . second + 1 ; q . pop ( ) ; } to_sum += p_arr [ i ] [ j ] ; count_zero_submatrices += to_sum ; q . push ( new pair ( p_arr [ i ] [ j ] , c ) ) ; i -- ; } } return ( n * ( n + 1 ) * n * ( n + 1 ) ) / 4 - count_zero_submatrices ; }
long count ( int N , int K , int R ) { long sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; }
boolean isSpiltPossible ( int n , int a [ ] ) { int sum = 0 , c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }
boolean isSunnyNum ( int n ) { if ( isPerfectSquare ( n + 1 ) ) return true ; return false ; }
int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; }
int getMaxNum ( int a , int b , int c ) { if ( b % c == 0 ) return b ; int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; }
int findAndSum ( int arr [ ] , int n ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { boolean count_on = false ; int l = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) if ( count_on ) l ++ ; else { count_on = true ; l ++ ; } else if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = false ; l = 0 ; } } if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = false ; l = 0 ; } mul *= 2 ; } return sum ; }
int calcNodes ( int N , int I ) { int result = 0 ; result = I * ( N - 1 ) + 1 ; return result ; }
void findPrimeFactors ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ j / i ] + 1 ; for ( int i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; }
double mixtureConcentration ( int n , int p [ ] ) { double res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return res ; }
int check ( int num , int a , int b ) { while ( num > 0 ) { int rem = num % 10 ; num /= 10 ; if ( rem != a && rem != b ) return 0 ; } return 1 ; }
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
long max_gcd ( long n , long p ) { int count = 0 ; long gcd = 1 ; while ( p % 2 == 0 ) { p >>= 1 ; count ++ ; } if ( count > 0 ) gcd *= ( long ) Math . pow ( 2 , count / n ) ; for ( long i = 3 ; i <= Math . sqrt ( p ) ; i += 2 ) { count = 0 ; while ( p % i == 0 ) { count ++ ; p = p / i ; } if ( count > 0 ) { gcd *= ( long ) Math . pow ( i , count / n ) ; } } if ( p > 2 ) gcd *= ( long ) Math . pow ( p , 1 / n ) ; return gcd ; }
int fib ( int n ) { if ( n == 0 ) { return 0 ; } if ( n == 1 n == 2 ) { return ( f [ n ] = 1 ) ; } if ( f [ n ] == 1 ) { return f [ n ] ; } int k = ( n % 2 == 1 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( n % 2 == 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
void printSequence ( int n ) { Sieve ( ) ; Vector < Integer > v = new Vector < > ( ) ; Vector < Integer > u = new Vector < > ( ) ; for ( int i = 13 ; i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { v . add ( i ) ; } } if ( n == 3 ) { System . out . print ( 6 + " " + 10 + " " + 15 ) ; return ; } int k ; for ( k = 0 ; k < n - 2 ; k ++ ) { if ( k % 3 == 0 ) { u . add ( v . get ( k ) * 6 ) ; } else if ( k % 3 == 1 ) { u . add ( v . get ( k ) * 15 ) ; } else { u . add ( v . get ( k ) * 10 ) ; } } k -- ; u . add ( v . get ( k ) * 7 ) ; u . add ( 7 * 11 ) ; u . set ( 0 , u . get ( 0 ) * 11 ) ; for ( int i = 0 ; i < u . size ( ) ; i ++ ) { System . out . print ( u . get ( i ) + " " ) ; } }
boolean checkSub ( String sub , String s ) { int j = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( sub . charAt ( j ) == s . charAt ( i ) ) j ++ ; return j == sub . length ( ) ; }
long minPerfectCube ( int arr [ ] , int n ) { long minPerfectCube ; long lcm = lcmOfArray ( arr , n ) ; minPerfectCube = ( long ) lcm ; int cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm /= 2 ; } if ( cnt % 3 == 2 ) minPerfectCube *= 2 ; else if ( cnt % 3 == 1 ) minPerfectCube *= 4 ; int i = 3 ; while ( lcm > 1 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm /= i ; } if ( cnt % 3 == 1 ) minPerfectCube *= i * i ; else if ( cnt % 3 == 2 ) minPerfectCube *= i ; i += 2 ; } return minPerfectCube ; }
void powerfulIntegers ( int x , int y , int bound ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; Vector < Integer > powersOfY = new Vector < Integer > ( ) ; int i ; powersOfY . add ( 1 ) ; for ( i = y ; i < bound && y != 1 ; i = i * y ) powersOfY . add ( i ) ; i = 0 ; while ( true ) { int xPowI = pow ( x , i ) ; for ( int j : powersOfY ) { int num = xPowI + j ; if ( num <= bound ) s . add ( num ) ; else break ; } if ( xPowI >= bound x == 1 ) break ; i ++ ; } Iterator itr = s . iterator ( ) ; while ( itr . hasNext ( ) ) { System . out . print ( itr . next ( ) + " " ) ; } }
double find_probability ( double p , double q , double r , double s ) { double t = ( 1 - p / q ) * ( 1 - r / s ) ; double ans = ( p / q ) / ( 1 - t ) ; return ans ; }
int distinctDigitSum ( int n ) { boolean [ ] used = new boolean [ 10 ] ; int sum = 0 ; while ( n > 0 ) { int digit = n % 10 ; if ( ! used [ digit ] ) { used [ digit ] = true ; sum += digit ; } n = ( int ) n / 10 ; } return sum ; }
int getDifference ( int N ) { if ( N == 0 ) return 2 ; else if ( N == 1 ) return 1 ; else if ( isPrime ( N ) ) return 0 ; int aboveN = - 1 , belowN = - 1 ; int n1 ; n1 = N + 1 ; while ( true ) { if ( isPrime ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; } n1 = N - 1 ; while ( true ) { if ( isPrime ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; } int diff1 = aboveN - N ; int diff2 = N - belowN ; return Math . min ( diff1 , diff2 ) ; }
int maxPrimeFactors ( int n ) { int num = n ; int maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n /= 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } } if ( n > 2 ) maxPrime = n ; int sum = maxPrime + num ; return sum ; }
int sumOfDigits ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; }
int countIntervals ( int arr [ ] [ ] , int V , int N ) { int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; int li , ri ; int [ ] freq = new int [ MAX_VAL ] ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] [ 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( int i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }
int sumEven ( int l , int r ) { return sumNatural ( r / 2 ) - sumNatural ( ( l - 1 ) / 2 ) ; }
boolean isPalindrome ( int num ) { int reverse_num = 0 , remainder , temp ; temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_num = reverse_num * 10 + remainder ; temp /= 10 ; } if ( reverse_num == num ) { return true ; } return false ; }
int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; }
int getResult ( int n ) { if ( ( n & 1 ) != 0 ) return 1 ; return - 1 ; }
long sumAP ( long n , long d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; }
long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
long minimum ( long n ) { long product = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; product = product * i ; } } if ( n >= 2 ) product = product * n ; return product ; }
boolean productDivisible ( int n , int k ) { int product = 1 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 0 ) product *= n % 10 ; n = n / 10 ; position ++ ; } if ( product % k == 0 ) return true ; return false ; }
long sumAP ( long n , long d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; }
int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
String isTriangleExists ( int a , int b , int c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return "YES" ; else return "NO" ; else return "NO" ; }
int fact ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact *= i ; return fact ; }
int ways ( int m , int w , int n , int k ) { int ans = 0 ; while ( m >= k ) { ans += ncr ( m , k ) * ncr ( w , n - k ) ; k += 1 ; } return ans ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
int square ( int n ) { return n * n ; }
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 2 ) ) * ( 2 * 2 + ( N / 2 - 1 ) * 2 ) / 2 ; S2 = ( ( N / 7 ) ) * ( 2 * 7 + ( N / 7 - 1 ) * 7 ) / 2 ; S3 = ( ( N / 14 ) ) * ( 2 * 14 + ( N / 14 - 1 ) * 14 ) / 2 ; return S1 + S2 - S3 ; }
int largestPrimeFactor ( int n ) { int max = - 1 ; while ( n % 2 == 0 ) { max = 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { max = i ; n = n / i ; } } if ( n > 2 ) max = n ; return max ; }
boolean isStrongNumber ( int n ) { HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; while ( n % 2 == 0 ) { n = n / 2 ; if ( count . containsKey ( 2 ) ) count . put ( 2 , count . get ( 2 ) + 1 ) ; else count . put ( 2 , 1 ) ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { n = n / i ; if ( count . containsKey ( i ) ) count . put ( i , count . get ( i ) + 1 ) ; else count . put ( i , 1 ) ; } } if ( n > 2 ) count . put ( n , count . get ( n ) + 1 ) ; int flag = 0 ; for ( Map . Entry < Integer , Integer > b : count . entrySet ( ) ) { if ( b . getValue ( ) == 1 ) { flag = 1 ; break ; } } if ( flag == 1 ) return false ; else return true ; }
boolean isChenPrime ( int n ) { if ( isPrime ( n ) && ( isSemiprime ( n + 2 ) || isPrime ( n + 2 ) ) ) return true ; else return false ; }
boolean isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
boolean Divisible ( String str , int n ) { if ( SumOfDigits ( str , n ) % 3 == 0 && str . charAt ( n - 1 ) == '0' ) return true ; return false ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
int NumberOfRectangles ( int n , int m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; }
boolean isPrime ( int p ) { if ( p == 4 ) return false ; return true ; }
long findNumUtil ( long res , int a , int aCount , int b , int bCount , int n ) { if ( res > 1e11 ) return 1e11 ; if ( aCount == bCount && res >= n ) return res ; return Math . min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) ) ; }
int isSumDivides ( int N ) { int temp = N ; int sum = 0 ; while ( temp > 0 ) { sum += temp % 10 ; temp /= 10 ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }
int GoodNumber ( int n ) { Vector < Integer > v = PrimeFactors ( n ) ; int ans = 1 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) ans *= v . get ( i ) ; return ans ; }
boolean checkSpecialPrime ( boolean [ ] sieve , int num ) { while ( num > 0 ) { if ( ! sieve [ num ] ) { return false ; } num /= 10 ; } return true ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
double nthHarmonic ( int N ) { float harmonic = ( float ) 1.00 ; for ( int i = 2 ; i <= N ; i ++ ) { harmonic += ( float ) 1 / i ; } return harmonic ; }
int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) + n - 2 ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + 4 * n - 2 ; }
void printAngles ( int a , int b , int c ) { double x = ( double ) a ; double y = ( double ) b ; double z = ( double ) c ; double A = findAnglesA ( x , y , z ) ; double B = findAnglesB ( x , y , z ) ; System . out . println ( "Angles are A = " + A + ", B = " + B + ", C = " + 90 ) ; }
long Bits ( int kilobytes ) { long Bits = 0 ; Bits = kilobytes * 8192 ; return Bits ; }
void binomial ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int closest ( int x ) { int ans = 0 ; while ( ans * 10 + 9 <= x ) ans = ans * 10 + 9 ; return ans ; }
int nthTerm ( int N ) { return ( N * ( ( N / 2 ) + ( ( N % 2 ) * 2 ) + N ) ) ; }
int calculateSum ( int n ) { return ( int ) Math . pow ( n * ( n + 1 ) / 2 , 2 ) ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int totEdge ( int n ) { int result = 0 ; result = ( n * ( n - 1 ) ) / 2 ; return result ; }
void findFactors ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( ( n / i ) == i ) factors . add ( i ) ; else { factors . add ( n / i ) ; factors . add ( i ) ; } } } }
boolean checkPairs ( int l , int r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }
float calTime ( float arr [ ] , int n ) { float work = 0 ; for ( int i = 0 ; i < n ; i ++ ) work += 1 / arr [ i ] ; return 1 / work ; }
int calculate_ways ( int m , int n ) { if ( m < n ) return 0 ; int ways = binomial_coefficient ( n + m - 1 , n - 1 ) ; return ways ; }
long powerLL ( long x , long n ) { long result = 1 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) result = result * x % MOD ; n = n / 2 ; x = x * x % MOD ; } return result ; }
long powerStrings ( String sa , String sb ) { long a = 0 , b = 0 ; for ( int i = 0 ; i < sa . length ( ) ; i ++ ) a = ( a * 10 + ( sa . charAt ( i ) - '0' ) ) % MOD ; for ( int i = 0 ; i < sb . length ( ) ; i ++ ) b = ( b * 10 + ( sb . charAt ( i ) - '0' ) ) % ( MOD - 1 ) ; return powerLL ( a , b ) ; }
int findNumbers ( int n , int w ) { int x = 0 , sum = 0 ; if ( w >= 0 && w <= 8 ) { x = 9 - w ; } else if ( w >= - 9 && w <= - 1 ) { x = 10 + w ; } sum = ( int ) Math . pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; }
int check ( int n ) { n -- ; int ans = n * n ; if ( ans >= mod ) ans %= mod ; ans += n + 2 ; if ( ans >= mod ) ans %= mod ; ans = ( power ( 2 , n , mod ) % mod * ans % mod ) % mod ; ans = ( ans - 1 + mod ) % mod ; return ans ; }
int findOddPair ( int A [ ] , int N ) { int i , j ; int oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
int numberOfDigits ( int x ) { int i = 0 ; while ( x > 0 ) { x /= 10 ; i ++ ; } return i ; }
double twoEggDrop ( int k ) { return Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8 * k ) ) / 2.0 ) ; }
void findArea ( float a , float b ) { float Area ; Area = ( float ) ( 3.142 * a * b ) ; System . out . println ( "Area: " + Area ) ; }
int calculate ( int x , int k , int m ) { int result = x ; k -- ; while ( k -- > 0 ) { result = ( int ) Math . pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; }
int largestNum ( int a , int b ) { return a * ( int ) ( a / b ) + b * ( int ) ( b / a ) ; }
int minimumSquareFreeDivisors ( int N ) { Vector < Integer > primes = new Vector < > ( ) ; SieveOfEratosthenes ( primes ) ; int max_count = 0 ; for ( int i = 0 ; i < primes . size ( ) && primes . get ( i ) * primes . get ( i ) <= N ; i ++ ) { if ( N % primes . get ( i ) == 0 ) { int tmp = 0 ; while ( N % primes . get ( i ) == 0 ) { tmp ++ ; N /= primes . get ( i ) ; } max_count = Math . max ( max_count , tmp ) ; } } if ( max_count == 0 ) max_count = 1 ; return max_count ; }
void smar_wln ( int n ) { primes ( n ) ; }
int sumOfSeries ( int n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; }
long mulmod ( long a , long b , long mod ) { a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) { res = ( res + a ) % mod ; } a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; }
long findProduct ( long N ) { long product = 1 , fact = 1 ; long MOD = ( long ) 1e9 + 7 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = mulmod ( fact , i , MOD ) ; product = mulmod ( product , fact , MOD ) ; if ( product == 0 ) return 0 ; } return product ; }
void endPointOfDiameterofCircle ( int x1 , int y1 , int c1 , int c2 ) { System . out . print ( "x2 = " + ( float ) ( 2 * c1 - x1 ) + " " ) ; System . out . print ( "y2 = " + ( float ) ( 2 * c2 - y1 ) ) ; }
int divSum ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) sum = sum + i + n / i ; return sum ; }
int centeredTetrahedralNumber ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 3 ) / 3 ; }
int bit ( int x ) { int ans = 0 ; while ( x != 0 ) { x /= 2 ; ans ++ ; } return ans ; }
int bs ( int n ) { int l = 1 , r = ( int ) Math . sqrt ( n ) ; while ( l < r ) { int m = ( l + r ) / 2 ; if ( check ( m , n ) ) r = m ; else l = m + 1 ; } if ( ! check ( l , n ) ) return l + 1 ; else return l ; }
String find_Square_369 ( String num ) { char a , b , c , d ; if ( num . charAt ( 0 ) == '3' ) a = '1' ; b = '0' ; c = '8' ; d = '9' ; else if ( num . charAt ( 0 ) == '6' ) a = '4' ; b = '3' ; c = '5' ; d = '6' ; else a = '9' ; b = '8' ; c = '0' ; d = '1' ; String result = "" ; int size = num . length ( ) ; for ( int i = 1 ; i < num . length ( ) ; i ++ ) result += a ; result += b ; for ( int i = 1 ; i < num . length ( ) ; i ++ ) result += c ; result += d ; return result ; }
boolean everMeet ( int x1 , int x2 , int v1 , int v2 ) { if ( x1 < x2 && v1 <= v2 ) return false ; if ( x1 > x2 && v1 >= v2 ) return false ; if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; } while ( x1 >= x2 ) { if ( x1 == x2 ) return true ; x1 = x1 + v1 ; x2 = x2 + v2 ; } return false ; }
int findpos ( String n ) { int pos = 0 ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { switch ( n . charAt ( i ) ) { case '2' : pos = pos * 4 + 1 ; break ; case '3' : pos = pos * 4 + 2 ; break ; case '5' : pos = pos * 4 + 3 ; break ; case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; }
boolean isPossibleToZero ( int a [ ] , int n ) { int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }
int fact ( int n ) { if ( n == 0 n == 1 ) return 1 ; int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ans ; }
int solve ( int n , int base ) { int result = 0 ; while ( n > 0 ) { int remainder = n % base ; result = result + remainder ; n = n / base ; } return result ; }
boolean checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; }
void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA , possibleB , possibleC ; int numbersInRange = ( R - L + 1 ) ; if ( numbersInRange < 3 ) { flag = false ; } else if ( numbersInRange > 3 ) { flag = true ; if ( L % 2 != 0 ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ( L % 2 ) != 0 ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( flag == true ) { System . out . println ( "(" + possibleA + ", " + possibleB + ", " + possibleC + ")" + " is one such possible triplet between " + L + " and " + R + "\n" ) ; } else { System . out . println ( "No Such Triplet exists between " + L + " and " + R + "\n" ) ; } }
boolean isFullTree ( Node root ) { if ( root == null ) return true ; if ( root . left == null && root . right == null ) return true ; if ( ( root . left ) != null && ( root . right ) != null ) return ( isFullTree ( root . left ) && isFullTree ( root . right ) ) ; return false ; }
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }
long findKthGoodNo ( long n ) { int lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }
int findGreatest ( int arr [ ] , int n ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } Arrays . sort ( arr ) ; for ( int i = n - 1 ; i > 1 ; i -- ) { for ( int j = 0 ; j < i && arr [ j ] <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) { int result = arr [ i ] / arr [ j ] ; if ( result != arr [ j ] && m . get ( result ) > 0 ) { return arr [ i ] ; } else if ( result == arr [ j ] && m . get ( result ) > 1 ) { return arr [ i ] ; } } } return - 1 ; }
int LCMOfNeighbourFact ( int n ) { return factorial ( n + 1 ) ; }
int fortunateNumber ( int n ) { int p = primorial ( n ) ; return findNextPrime ( p ) - p ; }
long findSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
int factorial ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; }
int findNthNumber ( int n , int k ) { for ( int i = k + 1 , count = 1 ; count < n ; i ++ ) { if ( checkdigit ( i , k ) || ( i % k == 0 ) ) count ++ ; if ( count == n ) return i ; } return - 1 ; }
boolean isPrime ( int p ) { long checkNumber = ( long ) Math . pow ( 2 , p ) - 1 ; long nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }
int multiply ( int x , int res [ ] , int res_size ) { int carry = 0 ; for ( int i = 0 ; i < res_size ; i ++ ) { int prod = res [ i ] * x + carry ; res [ i ] = prod % 10 ; carry = prod / 10 ; } while ( carry > 0 ) { res [ res_size ] = carry % 10 ; carry = carry / 10 ; res_size ++ ; } return res_size ; }
void power ( int x , int n ) { if ( n == 0 ) { System . out . print ( "1" ) ; return ; } int res [ ] = new int [ MAX ] ; int res_size = 0 ; int temp = x ; while ( temp != 0 ) { res [ res_size ++ ] = temp % 10 ; temp = temp / 10 ; } for ( int i = 2 ; i <= n ; i ++ ) res_size = multiply ( x , res , res_size ) ; System . out . print ( x + "^" + n + " = " ) ; for ( int i = res_size - 1 ; i >= 0 ; i -- ) System . out . print ( res [ i ] ) ; }
double sumOfSeries ( int n ) { return 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ; }
int seriesFunc ( int n ) { int sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; }
int day_of_the_week ( int y , int m , int d ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; if ( m < 3 ) y -= 1 ; return ( ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ) ; }
int subsetCount ( int arr [ ] , int n ) { return 1 << n ; }
boolean isSquareFree ( int n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; }
int avg_of_even_num ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return sum / n ; }
int reachTarget ( int target ) { target = Math . abs ( target ) ; int sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; }
long fourthPowerSum ( int n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; }
int aliquotSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
float focal_length_concave ( float R ) { return R / 2 ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) us . add ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( us . contains ( x - arr2 [ j ] ) ) count ++ ; return count ; }
int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
boolean isEmirp ( int n ) { if ( isPrime ( n ) == false ) return false ; int rev = 0 ; while ( n != 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n /= 10 ; } return isPrime ( rev ) ; }
int squaresum ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
boolean isPrime ( int n ) { int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) return false ; i ++ ; } return true ; }
int oddSum ( int n ) { int sum = 0 , curr = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }
int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; }
float distance ( int x1 , int y1 , int x2 , int y2 ) { return ( float ) Math . sqrt ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) * 1.0 ) ; }
void count0s ( int mat [ ] [ ] , int Q [ ] [ ] , int sizeQ ) { int prefixCnt [ ] [ ] = new int [ M ] [ N ] ; preCompute ( mat , prefixCnt ) ; for ( int i = 0 ; i < sizeQ ; i ++ ) { System . out . print ( countQuery ( prefixCnt , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , Q [ i ] [ 3 ] ) + " " ) ; } }
void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) System . out . println ( "Not possible" ) ; else { int result ; if ( k < Math . max ( m , n ) - 1 ) { result = Math . max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } System . out . println ( result ) ; } }
int totalNumber ( int n ) { return 8 * ( int ) Math . pow ( 9 , n - 1 ) ; }
int recDigSum ( int n ) { if ( n == 0 ) return 0 ; else { if ( n % 9 == 0 ) return 9 ; else return n % 9 ; } }
void check ( int n ) { n = recDigSum ( n ) ; if ( n == 2 n == 3 n == 5 n == 7 ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
boolean isDivisible ( String s ) { int n = s . length ( ) ; if ( s . charAt ( n - 1 ) != '5' && s . charAt ( n - 1 ) != '0' ) return false ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += s . charAt ( i ) - '0' * n ; } return ( sum % 3 == 0 ) ; }
void findArmstrong ( int low , int high ) { for ( int i = low + 1 ; i < high ; ++ i ) { int x = i ; int n = 0 ; while ( x != 0 ) { x /= 10 ; ++ n ; } int pow_sum = 0 ; x = i ; while ( x != 0 ) { int digit = x % 10 ; pow_sum += Math . pow ( digit , n ) ; x /= 10 ; } if ( pow_sum == i ) System . out . print ( i + " " ) ; } }
void complement ( String number ) { for ( int i = 0 ; i < number . length ( ) ; i ++ ) if ( number . charAt ( i ) != '.' ) number . replace ( number . charAt ( i ) , '9' - number . charAt ( i ) + '0' ) ; System . out . println ( "9's complement is : " + number ) ; }
int countWays ( int n ) { int count = 0 ; for ( int i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }
int sumDigitSquare ( int n ) { int sq = 0 ; while ( n != 0 ) { int digit = n % 10 ; sq += digit * digit ; n = n / 10 ; } return sq ; }
boolean isHappy ( int n ) { while ( true ) { if ( n == 1 ) return true ; n = sumDigitSquare ( n ) ; if ( n == 4 ) return false ; } }
double sumOfSeries ( double a , double num ) { double res = 0 , prev = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { prev *= ( a / i ) ; res = res + prev ; } return ( res ) ; }
void convert ( int arr [ ] , int n ) { int [ ] temp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ i ] ; } Arrays . sort ( temp ) ; Map < Integer , Integer > mp = new HashMap < > ( ) ; int val = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( temp [ i ] ) ) { mp . put ( temp [ i ] , mp . get ( temp [ i ] ) + 1 ) ; } else { mp . put ( temp [ i ] , 1 ) ; } } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = mp . get ( arr [ i ] ) ; } }
void printTrib ( int n ) { if ( n < 1 ) return ; int first = 0 , second = 0 ; int third = 1 ; System . out . print ( first + " " ) ; if ( n > 1 ) System . out . print ( second + " " ) ; if ( n > 2 ) System . out . print ( second + " " ) ; for ( int i = 3 ; i < n ; i ++ ) { int curr = first + second + third ; first = second ; second = third ; third = curr ; System . out . print ( curr + " " ) ; } }
void multiply ( int T [ ] [ ] , int M [ ] [ ] ) { int a , b , c , d , e , f , g , h , i ; a = T [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 0 ] ; b = T [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 1 ] ; c = T [ 0 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 2 ] ; d = T [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 0 ] ; e = T [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 1 ] ; f = T [ 1 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 0 ] ; h = T [ 2 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 2 ] [ 1 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 1 ] ; i = T [ 2 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 2 ] ; T [ 0 ] [ 0 ] = a ; T [ 0 ] [ 1 ] = b ; T [ 0 ] [ 1 ] = c ; T [ 0 ] [ 0 ] = b ; T [ 0 ] [ 1 ] = b ; T [ 0 ] [ 0 ] = a ; T [ 0 ] [ 1 ] = b ; T [ 0 ] [ 1 ] = b ; T
boolean sackRace ( int p1 , int s1 , int p2 , int s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; }
int xorCalc ( int k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return k / 2 ; return - 1 ; }
void multiple ( int a , int b , int x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) System . out . print ( "1" ) ; else System . out . print ( "0" ) ; } int mul = ( int ) Math . pow ( a , b ) ; int ans = mul / x ; int ans1 = x * ans ; int ans2 = x * ( ans + 1 ) ; System . out . print ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }
boolean checkJumbled ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( Math . abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; }
float binomialProbability ( int n , int k , float p ) { return nCr ( n , k ) * ( float ) Math . pow ( p , k ) * ( float ) Math . pow ( 1 - p , n - k ) ; }
int flipSign ( int a ) { int neg = 0 ; int tmp = a < 0 ? 1 : - 1 ; while ( a != 0 ) { neg += tmp ; a += tmp ; } return neg ; }
boolean areDifferentSign ( int a , int b ) { return ( ( a < 0 && b > 0 ) || ( a > 0 && b < 0 ) ) ; }
int FirstDigit ( int arr [ ] , int n ) { double S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S = S + Math . log10 ( arr [ i ] * 1.0 ) ; double fract_S = S - Math . floor ( S ) ; int ans = ( int ) Math . pow ( 10 , fract_S ) ; return ans ; }
void cal_cos ( double n ) { double accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = Math . cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . abs ( cosval - cosx ) ) ; System . out . print ( cosx ) ; }
int sumFactDiv ( int n ) { return div ( fact ( n ) ) ; }
int printNthElement ( int n ) { int [ ] arr = new int [ n + 1 ] ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
int maxSumLCM ( int n ) { int max_sum = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; }
boolean check ( String str ) { int n = str . length ( ) ; if ( n == 0 && n == 1 ) return false ; if ( n == 2 ) return ( ( ( str . charAt ( n - 2 ) - '0' ) * 10 + ( str . charAt ( n - 1 ) - '0' ) ) % 16 == 0 ) ; if ( n == 3 ) return ( ( ( str . charAt ( n - 3 ) - '0' ) * 100 + ( str . charAt ( n - 2 ) - '0' ) * 10 + ( str . charAt ( n - 1 ) - '0' ) ) % 16 == 0 ) ; int last = str . charAt ( n - 1 ) - '0' ; int second_last = str . charAt ( n - 2 ) - '0' ; int third_last = str . charAt ( n - 3 ) - '0' ; int fourth_last = str . charAt ( n - 4 ) - '0' ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; }
boolean checkPandigital ( int b , String n ) { if ( n . length ( ) < b ) return false ; boolean [ ] hash = new boolean [ b ] ; Arrays . fill ( hash , false ) ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { if ( n . charAt ( i ) >= '0' && n . charAt ( i ) <= '9' ) hash [ n . charAt ( i ) - '0' ] = true ; else if ( n . charAt ( i ) - 'A' <= b - 11 ) hash [ n . charAt ( i ) - 'A' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; }
int findStarNum ( int n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
int squareFree ( int n ) { int cnt = 0 ; for ( int i = 1 ; ; i ++ ) { boolean isSqFree = true ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % ( j * j ) == 0 ) { isSqFree = false ; break ; } } if ( isSqFree == true ) { cnt ++ ; if ( cnt == n ) return i ; } } return 0 ; }
boolean check ( String str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str . charAt ( 0 ) - '0' ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str . charAt ( n - 2 ) - '0' ) * 10 + ( str . charAt ( n - 1 ) - '0' ) ) % 8 == 0 ) ; int last = str . charAt ( n - 1 ) - '0' ; int second_last = str . charAt ( n - 2 ) - '0' ; int third_last = str . charAt ( n - 3 ) - '0' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; }
boolean isRefactorableNumber ( int n ) { int divCount = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) { if ( n / i == i ) ++ divCount ; else divCount += 2 ; } } return n % divCount == 0 ; }
void nearestGcd ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) { int closest = - 1 ; for ( int j = i - 1 , k = i + 1 ; j > 0 k <= n ; -- j , ++ k ) { if ( j >= 0 && __gcd ( arr [ i ] , arr [ j ] ) > 1 ) { closest = j + 1 ; break ; } if ( k < n && __gcd ( arr [ i ] , arr [ k ] ) > 1 ) { closest = k + 1 ; break ; } } System . out . print ( closest + " " ) ; } }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; }
int Special_Factorial_Number ( int k ) { for ( int i = 1 ; i <= k ; i ++ ) { if ( ( fact ( i ) % k ) == 0 ) { return i ; } } return 0 ; }
int findnum ( String str ) { int n = str . length ( ) ; int count_after_dot = 0 ; boolean dot_seen = false ; int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) != '.' ) { num = num * 10 + ( str . charAt ( i ) - '0' ) ; if ( dot_seen == true ) count_after_dot ++ ; } else dot_seen = true ; } if ( dot_seen == false ) return 1 ; int dem = ( int ) Math . pow ( 10 , count_after_dot ) ; return ( dem / gcd ( num , dem ) ) ; }
boolean iskaprekar ( int n ) { if ( n == 1 ) return true ; int sq_n = n * n ; int count_digits = 0 ; while ( sq_n > 0 ) { count_digits ++ ; sq_n /= 10 ; } for ( int r_digits = 1 ; r_digits < count_digits ; r_digits ++ ) { int eq_parts = ( int ) Math . pow ( 10 , r_digits ) ; if ( eq_parts == n ) continue ; int sum = sq_n / eq_parts + sq_n % eq_parts ; if ( sum == n ) return true ; } return false ; }
int kDivisors ( int a , int b , int k ) { int count = 0 ; for ( int i = a ; i <= b ; i ++ ) { if ( isPerfect ( i ) ) if ( divisors ( i ) == k ) count ++ ; } return count ; }
void buildDivisorsArray ( ) { for ( int i = 1 ; i < maxn ; i ++ ) { divisors [ i ] = 1 ; int n = i , p = smallest_prime [ i ] , k = 0 ; while ( n > 1 ) { n = n / p ; k ++ ; if ( smallest_prime [ n ] != p ) { divisors [ i ] = divisors [ i ] * ( k + 1 ) ; k = 0 ; } p = smallest_prime [ n ] ; } } }
int commDiv ( int a , int b ) { int n = gcd ( a , b ) ; int result = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) result += 1 ; else result += 2 ; } } return result ; }
int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( float ) ( ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ) ; float root2 = ( float ) ( ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ; return false ; }
char flip ( char c ) { return ( c == '0' ) ? '1' : '0' ; }
boolean areElementsContiguous ( int arr [ ] , int n ) { int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int min = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int m = max - min + 1 ; if ( m > n ) return false ; boolean visited [ ] = new boolean [ m ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }
void SieveOfAtkin ( int limit ) { if ( limit > 2 ) System . out . print ( 2 + " " ) ; if ( limit > 3 ) System . out . print ( 3 + " " ) ; boolean [ ] sieve = new boolean [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) System . out . print ( a + " " ) ; }
void SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; boolean [ ] marked = new boolean [ nNew + 1 ] ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) System . out . print ( 2 + " " ) ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) System . out . print ( 2 * i + 1 + " " ) ; }
boolean squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
int modFact ( int n , int p ) { if ( p <= n ) return 0 ; int res = ( p - 1 ) ; for ( int i = n + 1 ; i < p ; i ++ ) res = ( res * modInverse ( i , p ) ) % p ; return res ; }
int countWays ( int n ) { for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) for ( int k = j ; k < n ; k ++ ) for ( int l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
boolean isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; }
boolean checkUtil ( int num , int dig , int base ) { if ( dig == 1 && num < base ) return true ; if ( dig > 1 && num >= base ) return checkUtil ( num / base , -- dig , base ) ; return false ; }
int countLeapYears ( Date d ) { int years = d . y ; if ( d . m <= 2 ) years -- ; return years / 4 - years / 100 + years / 400 ; }
long binomialCoeff ( long n , long k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
long findWays ( int n ) { if ( ( n & 1 ) == 1 ) return 0 ; return catalan ( n / 2 ) ; }
int XorSum ( int A [ ] , int B [ ] , int N , int M ) { int ans1 = 0 , ans2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) ans1 = ans1 ^ A [ i ] ; for ( int i = 0 ; i < M ; i ++ ) ans2 = ans2 ^ B [ i ] ; return ( ans1 & ans2 ) ; }
int check ( int x ) { if ( ( ( x ) & ( x - 1 ) ) == 0 ) return 1 ; return 0 ; }
int maxAndXor ( int arr [ ] , int n ) { int ans = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = Math . min ( ans , arr [ i ] ^ arr [ i + 1 ] ) ; } return ans ; }
void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( ( n >> bit ) & 1 ) > 0 ) { n = n ^ ( 1 << bit ) ; break ; } } System . out . println ( "The number after unsetting the" ) ; System . out . println ( " rightmost set bit " + n ) ; }
void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; for ( int i = 0 ; i < n ; i ++ ) { HashSet < Integer > s = new HashSet < > ( ) ; int j ; for ( j = i ; j < n ; j ++ ) { s . add ( arr [ j ] ) ; if ( s . size ( ) == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) break ; } if ( l == 0 && r == n ) System . out . println ( "Invalid k" ) ; else System . out . println ( l + " " + r ) ; }
void construct_Xor_Tree ( int [ ] arr , int n ) { construct_Xor_Tree_Util ( arr , 0 , n - 1 , 0 ) ; }
int maximizeExpression ( int a , int b ) { int result = a ; for ( int bit = MAX - 1 ; bit >= 0 ; bit -- ) { int bitOfD = 1 << bit ; int x = b & bitOfD ; if ( x == bitOfD ) { int y = result & bitOfD ; if ( y == 0 ) { result = result ^ bitOfD ; } } } return result ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
void hasEqualBlockFrequency ( int N ) { String S = Integer . toBinaryString ( N ) ; HashSet < Integer > p = new HashSet < Integer > ( ) ; int c = 1 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) == S . charAt ( i + 1 ) ) c += 1 ; else { p . add ( c ) ; c = 1 ; } p . add ( c ) ; } if ( p . size ( ) == 1 ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
boolean isEqualBlock ( int n ) { int first_bit = n % 2 ; int first_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit && n > 0 ) { n = n / 2 ; first_count ++ ; } if ( n == 0 ) return false ; while ( n > 0 ) { int first_bit = n % 2 ; int curr_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit ) { n = n / 2 ; curr_count ++ ; } if ( curr_count != first_count ) return false ; } return true ; }
void printMaxAfterRemoval ( String s ) { boolean flag = false ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' && flag == false ) { flag = true ; continue ; } else System . out . print ( s . charAt ( i ) ) ; } }
int bitPos ( int n1 , int n2 ) { if ( n1 == n2 ) return 0 ; int bitCount1 = ( int ) Math . floor ( ( Math . log ( n1 ) / Math . log ( 2 ) ) ) + 1 ; int bitCount2 = ( int ) Math . floor ( ( Math . log ( n2 ) / Math . log ( 2 ) ) ) + 1 ; int bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; int maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * ( int ) Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * ( int ) Math . pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue = ( int ) Math . floor ( ( Math . log ( xorValue ) / Math . log ( 2 ) ) ) + 1 ; int disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }
int findevenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; int oddCount = count * ( count - 1 ) / 2 ; return ( N * ( N - 1 ) / 2 ) - oddCount ; }
void ReplaceElements ( int arr [ ] , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }
int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
void maxTriplet ( int a [ ] , int n ) { boolean f [ ] = new boolean [ n ] ; int [ ] [ ] bits = new int [ n ] [ 33 ] ; for ( int i = 0 ; i < n ; ++ i ) { int num = a [ i ] ; int j = 32 ; while ( num > 0 ) { if ( ( num & 1 ) != 0 ) { bits [ i ] [ j ] = 1 ; } j -- ; num >>= 1 ; } } long ans = 0 ; for ( int i = 0 ; i <= 32 ; ++ i ) { int cnt = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( bits [ j ] [ i ] && f [ j ] ) { cnt ++ ; } } if ( cnt >= 3 ) { ans += Math . pow ( 2 , 32 - i ) ; for ( int j = 0 ; j < n ; ++ j ) { if ( bits [ j ] [ i ] == 0 ) { f [ j ] = false ; } } } } int cnt = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( f [ i ] ) { cnt ++ ; } } long NumberOfTriplets = ( cnt * ( cnt - 1 ) * ( cnt - 2 ) ) / 6 ; System . out . println ( NumberOfTriplets + " " + ans ) ; }
int AND ( int a [ ] , int n ) { int ans = a [ 0 ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { ans &= a [ i ] ; } return ans ; }
int findEvenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 != 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
void printOdds ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; int set_bit = res & ( ~ ( res - 1 ) ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit ) != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . print ( x + " " + y ) ; }
void printKthBit ( int n , int k ) { System . out . print ( ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ) ; }
void decimalToBinaryNumber ( int x , int n ) { int [ ] binaryNumber = new int [ n ] ; int i = 0 ; while ( x > 0 ) { binaryNumber [ i ] = x % 2 ; x = x / 2 ; i ++ ; } for ( int j = 0 ; j < n - i ; j ++ ) System . out . print ( '0' ) ; for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( binaryNumber [ j ] ) ; }
int XOR ( int a , int b ) { int c = Math . min ( a , b ) ; int d = Math . max ( a , b ) ; if ( count ( c ) < count ( d ) ) c = c << ( count ( d ) - count ( c ) ) ; return ( c ^ d ) ; }
int toggleBits ( int n1 , int n2 ) { return n1 ^ n2 ; }
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
int maxXorSum ( int n , int k ) { if ( k == 1 ) return n ; int res = 1 ; while ( res <= n ) res <<= 1 ; return res - 1 ; }
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
int maxAND ( int arr [ ] , int n ) { int res = 0 , count ; for ( int bit = 31 ; bit >= 0 ; bit -- ) { count = checkBit ( res | ( 1 << bit ) , arr , n ) ; if ( count >= 2 ) res |= ( 1 << bit ) ; } return res ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int countUnsetBits ( int n ) { int x = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return Integer . bitCount ( x ^ n ) ; }
int setBitNumber ( int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return 1 << k ; }
int toggle ( int n ) { int temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } return n ; }
int getFirstSetBitPos ( int n ) { return ( int ) ( ( Math . log10 ( n & - n ) ) / Math . log10 ( 2 ) ) + 1 ; }
int countNum ( int arr [ ] , int n ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
long CountZeroBit ( long x ) { long count = 0 ; while ( x > 0 ) { if ( ( x & 1 ) == 0 ) count ++ ; x >>= 1 ; } return count ; }
int bitCount ( int n ) { int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) ++ count ; n >>= 1 ; } return count ; }
int sumoflength ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . contains ( arr [ j ] ) ) { s . add ( arr [ j ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . remove ( arr [ i ] ) ; } return ans ; }
boolean areSetBitsIncreasing ( int n ) { int prev_count = Integer . MAX_VALUE ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = n / 2 ; int curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; }
boolean findPattern ( int n ) { int prev = n % 2 ; n = n / 2 ; while ( n > 0 ) { int curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = n / 2 ; } return true ; }
boolean isMultipleOf4 ( int n ) { if ( n == 1 ) return false ; int XOR = 0 ; for ( int i = 1 ; i <= n ; i ++ ) XOR = XOR ^ i ; return ( XOR == n ) ; }
char findProffesion ( int level , int pos ) { if ( level == 1 ) return 'e' ; if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == 'd' ) return ( pos % 2 == 1 ) ? 'd' : 'e' ; return ( pos % 2 == 1 ) ? 'e' : 'd' ; }
int swapBits ( int n , int p1 , int p2 ) { int bit1 = ( n >> p1 ) & 1 ; int bit2 = ( n >> p2 ) & 1 ; int x = ( bit1 ^ bit2 ) ; x = ( x << p1 ) | ( x << p2 ) ; int result = n ^ x ; return result ; }
int getElements ( Node node ) { if ( node == null ) return 0 ; return getElements ( node . left ) + getElements ( node . right ) + 1 ; }
int sumOfDiv ( int x ) { int sum = 1 ; for ( int i = 2 ; i <= Math . sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { sum += i ; if ( x / i != i ) sum += x / i ; } } return sum ; }
void leftRotate ( int arr [ ] , int d , int n ) { for ( int i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; }
void merge ( int arr [ ] , int l , int m , int r ) { int i = l ; int j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ; while ( j <= r && arr [ j ] < 0 ) j ++ ; reverse ( arr , i , m ) ; reverse ( arr , m + 1 , j - 1 ) ; reverse ( arr , i , j - 1 ) ; }
void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = - 1 , j = 0 ; int t ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; t = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = t ; } j ++ ; } for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 , int k ) { if ( k > n1 * n2 ) { System . out . println ( "k pairs don't exist" ) ; return ; } int [ ] index2 = new int [ n1 ] ; Arrays . fill ( index2 , 0 ) ; while ( k > 0 ) { int min_sum = Integer . MAX_VALUE ; int min_index = 0 ; for ( int i1 = 0 ; i1 < n1 ; i1 ++ ) { if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) { min_index = i1 ; min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ; } } System . out . print ( "(" + arr1 [ min_index ] + ", " + arr2 [ index2 [ min_index ] ] + ") " ) ; index2 [ min_index ] ++ ; k -- ; } }
int Solve ( int L , int R ) { int l = L , r = R ; int tot_bits = r - l + 1 ; int X = MAX ; for ( int i = 0 ; i < 31 ; i ++ ) { int x = one [ r ] [ i ] - one [ l - 1 ] [ i ] ; if ( x >= tot_bits - x ) { int ith_bit = ( int ) Math . pow ( 2 , i ) ; X = X ^ ith_bit ; } } return X ; }
void swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; }
int findNumberOfTriangles ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] > arr [ k ] && arr [ i ] + arr [ k ] > arr [ j ] && arr [ k ] + arr [ j ] > arr [ i ] ) count ++ ; } } } return count ; }
void CountTriangles ( int [ ] A ) { int n = A . length ; Arrays . sort ( A ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else l ++ ; } } System . out . println ( count ) ; }
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; Arrays . sort ( arr ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
int getSumAlternate ( Node node ) { if ( node == null ) return 0 ; int sum = node . data ; if ( node . left != null ) { sum += getSum ( node . left . left ) ; sum += getSum ( node . left . right ) ; } if ( node . right != null ) { sum += getSum ( node . right . left ) ; sum += getSum ( node . right . right ) ; } return sum ; }
int getSum ( Node node ) { if ( node == null ) return 0 ; return Math . max ( getSumAlternate ( node ) , ( getSumAlternate ( node . left ) + getSumAlternate ( node . right ) ) ) ; }
int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }
int getHeight ( Node node ) { if ( node == null ) return 0 ; else { int lHeight = getHeight ( node . left ) ; int rHeight = getHeight ( node . right ) ; if ( lHeight > rHeight ) return ( lHeight + 1 ) ; else return ( rHeight + 1 ) ; } }
void printLeaders ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) System . out . print ( arr [ i ] + " " ) ; } }
int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }
int getMin ( int arr [ ] , int n ) { int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] < min ) min = arr [ i ] ; return min ; }
int interpolationSearch ( int arr [ ] , int lo , int hi , int x ) { int pos ; if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { pos = lo + ( ( ( double ) ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; if ( arr [ pos ] < x ) return interpolationSearch ( arr , pos + 1 , hi , x ) ; if ( arr [ pos ] > x ) return interpolationSearch ( arr , lo , pos - 1 , x ) ; } return - 1 ; }
void sort ( int arr [ ] , int n ) { countSort ( arr , n , 1 ) ; countSort ( arr , n , n ) ; }
int countOnes ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
int isUgly ( int no ) { no = maxDivide ( no , 2 ) ; no = maxDivide ( no , 3 ) ; no = maxDivide ( no , 5 ) ; return ( no == 1 ) ? 1 : 0 ; }
int countRec ( int n , int sum ) { if ( n == 0 ) return sum == 0 ? 1 : 0 ; if ( sum == 0 ) return 1 ; int ans = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; }
int countRec ( int n , int sum ) { if ( n == 0 ) return sum == 0 ? 1 : 0 ; if ( lookup [ n ] [ sum ] != - 1 ) return lookup [ n ] [ sum ] ; int ans = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return lookup [ n ] [ sum ] = ans ; }
int sumOfDigitsFrom1ToNUtil ( int n , int a [ ] ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . log10 ( n ) ) ; int p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToNUtil ( n % p , a ) ) ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ ] = new int [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }
void printCombination ( int arr [ ] , int n , int r ) { int data [ ] = new int [ r ] ; combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; }
int findCeil ( int arr [ ] , int r , int l , int h ) { int mid ; while ( l < h ) { mid = l + ( ( h - l ) >> 1 ) ; if ( r > arr [ mid ] ) { l = mid + 1 ; } else { h = mid ; } } return ( arr [ l ] >= r ) ? l : - 1 ; }
int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
boolean isPowerOfFour ( int n ) { if ( n == 0 ) return false ; return Math . floor ( Math . log ( n , 4 ) ) == Math . ceil ( Math . log ( n , 4 ) ) ; }
int countSetBits ( int n ) { return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) ; }
int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }
int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }
int swapBits ( int x ) { int even_bits = x & 0xAAAAAAAA ; int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; }
boolean isPowerOfTwo ( int n ) { return n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ; }
void segregate0and1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }
int maxSum ( int arr [ ] , int n ) { int sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }
void updateindex ( int index [ ] , int a , int ai , int b , int bi ) { index [ a ] = ai ; index [ b ] = bi ; }
int minSwapsUtil ( int arr [ ] , int pairs [ ] , int index [ ] , int i , int n ) { if ( i > n ) return 0 ; if ( pairs [ arr [ i ] ] == arr [ i + 1 ] ) return minSwapsUtil ( arr , pairs , index , i + 2 , n ) ; int one = arr [ i + 1 ] ; int indextwo = i + 1 ; int indexone = index [ pairs [ arr [ i ] ] ] ; int two = arr [ index [ pairs [ arr [ i ] ] ] ] ; int a = minSwapsUtil ( arr , pairs , index , i + 2 , n ) ; swap ( arr , i + 1 , indexone ) ; updateindex ( index , one , indextwo , two , indexone ) ; one = arr [ i ] , indexone = index [ pairs [ arr [ i + 1 ] ] ] ; two = arr [ index [ pairs [ arr [ i + 1 ] ] ] ] ; indextwo = i ; swap ( arr , i , indexone ) ; updateindex ( index , one , indexone , two , indextwo ) ; int b = minSwapsUtil ( arr , pairs , index , i + 2 , n ) ; swap ( arr , i , indexone ) ; updateindex ( index , one , indextwo , two , indexone ) ; return 1 + Math . min ( a , b ) ; }
void process ( boolean arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) arr [ k ] ^= arr [ k - 1 ] ; }
void prefixXOR ( int arr [ ] , int preXOR [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( arr [ i ] % 2 != 1 ) arr [ i ] /= 2 ; preXOR [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] ; }
int query ( int preXOR [ ] , int l , int r ) { if ( l == 0 ) return preXOR [ r ] ; else return preXOR [ r ] ^ preXOR [ l - 1 ] ; }
int maxPartitions ( int arr [ ] , int n ) { int ans = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; ++ i ) { max_so_far = Math . max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; }
int countPairs ( int a [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; }
int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }
int countPairs ( int A [ ] , int n , int k ) { int ans = 0 ; Arrays . sort ( A ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int x = 0 ; while ( ( A [ i ] * Math . pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * Math . pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; }
void printMax ( int arr [ ] , int k , int n ) { int brr [ ] = Arrays . copyOf ( arr , n ) ; Arrays . sort ( brr ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( Arrays . binarySearch ( brr , k , arr [ i ] , greater < Integer > ( ) ) > - 1 ) System . out . print ( arr [ i ] + " " ) ; } }
int find_consecutive_steps ( int arr [ ] , int len ) { int count = 0 ; int maximum = 0 ; for ( int index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = Math . max ( maximum , count ) ; count = 0 ; } } return Math . max ( maximum , count ) ; }
long findSum ( int arr [ ] , int n ) { long sum = 0 ; Arrays . sort ( arr ) ; int i = 0 ; while ( i < n && arr [ i ] < 0 ) { if ( i != n - 1 && arr [ i + 1 ] <= 0 ) { sum = ( sum + ( arr [ i ] * arr [ i + 1 ] ) % Mod ) % Mod ; i += 2 ; } else break ; } int j = n - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { if ( j != 0 && arr [ j - 1 ] > 0 ) { sum = ( sum + ( arr [ j ] * arr [ j - 1 ] ) % Mod ) % Mod ; j -= 2 ; } else break ; } if ( j > i ) sum = ( sum + ( arr [ i ] * arr [ j ] ) % Mod ) % Mod ; else if ( i == j ) sum = ( sum + arr [ i ] ) % Mod ; return sum ; }
void printList ( Node head ) { Node temp = head ; while ( temp != null ) { System . out . printf ( "%d " , temp . data ) ; temp = temp . next ; } }
void insertAfterNthNode ( Node head , int n , int x ) { if ( head == null ) return ; Node newNode = getNode ( x ) ; Node ptr = head ; int len = 0 , i ; while ( ptr != null ) { len ++ ; ptr = ptr . next ; } ptr = head ; for ( i = 1 ; i <= ( len - n ) ; i ++ ) ptr = ptr . next ; newNode . next = ptr . next ; ptr . next = newNode ; }
void findLargestRotation ( int num ) { int ans = num ; int len = ( int ) Math . floor ( Math . log10 ( num ) + 1 ) ; int x = ( int ) Math . pow ( 10 , len - 1 ) ; for ( int i = 1 ; i < len ; i ++ ) { int lastDigit = num % 10 ; num = num / 10 ; num += ( lastDigit * x ) ; if ( num > ans ) { ans = num ; } } System . out . println ( ans ) ; }
void reverse ( int arr [ ] , int s , int e ) { while ( s < e ) { int tem = arr [ s ] ; arr [ s ] = arr [ e ] ; arr [ e ] = tem ; s = s + 1 ; e = e - 1 ; } }
int countRotation ( int arr [ ] , int low , int high ) { if ( low > high ) { return 0 ; } int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) { return mid ; } if ( arr [ mid ] > arr [ low ] ) { return countRotation ( arr , mid + 1 , high ) ; } if ( arr [ mid ] < arr [ high ] ) { return countRotation ( arr , low , mid - 1 ) ; } else { int rightIndex = countRotation ( arr , mid + 1 , high ) ; int leftIndex = countRotation ( arr , low , mid - 1 ) ; if ( rightIndex == 0 ) { return leftIndex ; } return rightIndex ; } }
void build ( int node , int l , int r , int a [ ] ) { if ( l == r ) seg [ node ] = a [ l ] ; else { int mid = ( l + r ) / 2 ; build ( 2 * node , l , mid , a ) ; build ( 2 * node + 1 , mid + 1 , r , a ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } }
boolean rightRotationDivisor ( int N ) { int lastDigit = N % 10 ; int rightRotation = ( lastDigit * ( int ) Math . pow ( 10 , ( Math . log10 ( N ) ) ) ) + ( int ) Math . floor ( N / 10 ) ; return ( rightRotation % N == 0 ) ; }
int digitSum ( int num ) { int sum = 0 ; while ( num > 0 ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; }
void printList ( Node start ) { Node temp ; if ( start != null ) { temp = start ; do { System . out . print ( temp . data + " " ) ; temp = temp . next ; } while ( temp != start ) ; } }
void displayList ( Node start ) { Node temp = start ; while ( temp . next != start ) { System . out . print ( temp . data + " " ) ; temp = temp . next ; } System . out . print ( temp . data + " " ) ; }
int alivesol ( int Num ) { if ( Num == 1 ) return 1 ; Node last = newNode ( 1 ) ; last . next = last ; for ( int i = 2 ; i <= Num ; i ++ ) { Node temp = newNode ( i ) ; temp . next = last . next ; last . next = temp ; last = temp ; } Node curr = last . next ; Node temp ; while ( curr . next != curr ) { temp = curr ; curr = curr . next ; temp . next = curr . next ; delete curr ; temp = temp . next ; curr = temp ; } int res = temp . data ; delete temp ; return res ; }
void addEdge ( int u , int v , int cost ) { graph [ u ] . add ( new int [ ] { v , cost } ) ; graph [ v ] . add ( new int [ ] { u , cost } ) ; }
void dfs ( int node , int parent , int h ) { lca [ node ] [ 0 ] = parent ; level [ node ] = h ; if ( parent != - 1 ) { minWeight [ node ] [ 0 ] = Math . min ( weight [ node ] , weight [ parent ] ) ; maxWeight [ node ] [ 0 ] = Math . max ( weight [ node ] , weight [ parent ] ) ; } for ( int i = 1 ; i < log ; i ++ ) { if ( lca [ node ] [ i - 1 ] != - 1 ) { lca [ node ] [ i ] = lca [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ; minWeight [ node ] [ i ] = Math . min ( minWeight [ node ] [ i - 1 ] , minWeight [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; maxWeight [ node ] [ i ] = Math . max ( maxWeight [ node ] [ i - 1 ] , maxWeight [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; } } for ( int i : graph . get ( node ) ) { if ( i == parent ) continue ; dfs ( i , node , h + 1 ) ; } }
int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) { swap ( u , v ) ; v = parent [ v ] ; return LCANaive ( u , v ) ; }
int solve ( int A [ ] , int n ) { int i , cnt = 0 , j ; int parent [ ] = new int [ n ] ; int vis [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) parent [ i ] = - 1 ; for ( i = 0 ; i < n ; i ++ ) vis [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == - 1 ) { while ( parent [ j ] == - 1 ) { parent [ j ] = i ; j = __gcd ( j , A [ j ] ) % n ; } if ( parent [ j ] == i ) { while ( ! vis [ j ] ) { vis [ j ] = 1 ; cnt ++ ; j = __gcd ( j , A [ j ] ) % n ; } } } } return cnt ; }
void clear ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) { lvl [ i ] = 0 ; } maxi = 0 ; dist1 [ 0 ] = dist2 [ 0 ] = - 1 ; }
long possiblePositions ( long n ) { long term1 = ( long ) Math . pow ( n , 4 ) ; long term2 = ( long ) Math . pow ( n , 3 ) ; long term3 = ( long ) Math . pow ( n , 2 ) ; long term4 = n / 3 ; long ans = ( long ) ( term1 ) / 2 - ( long ) ( 5 * term2 ) / 3 + ( long ) ( 3 * term3 ) / 2 - term4 ; return ans ; }
boolean countSingleRec ( Node node , int count ) { if ( node == null ) return true ; boolean left = countSingleRec ( node . left , count ) ; boolean right = countSingleRec ( node . right , count ) ; if ( left == false right == false ) return false ; if ( node . left != null && node . data != node . left . data ) return false ; if ( node . right != null && node . data != node . right . data ) return false ; count ++ ; return true ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
long modInverse ( long n , long p ) { return power ( n , p - 2 , p ) ; }
long CountEvenSumSequences ( long n ) { long count = 0 ; for ( long i = 0 ; i <= n ; i ++ ) { long even = i , odd = n - i ; if ( odd % 2 == 1 ) continue ; long tot = ( power ( countOdd ( n ) , odd , M ) * nCrModPFermat ( n , odd , M ) ) % M ; tot = ( tot * power ( counteEven ( n ) , i , M ) ) % M ; count += tot ; count %= M ; } return count ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * p ; i < MAX ; i += p ) prime [ i ] = false ; } } }
int nextOccurrence ( String str , int n , int start , char ch ) { for ( int i = start ; i < n ; i ++ ) { if ( str . charAt ( i ) == ch ) return i ; } return - 1 ; }
int changeToOnes ( String str ) { int i , l , ctr = 0 ; l = str . length ( ) ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == '1' ) ctr ++ ; else break ; } return l - ctr ; }
int getCount ( int a [ ] , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( gcd , a [ i ] ) ; int cnt = 0 ; for ( int i = 1 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { if ( i * i == gcd ) cnt ++ ; else cnt += 2 ; } } return cnt ; }
int findMissingPositive ( int arr [ ] , int n ) { int m = 1 ; HashSet < Integer > x = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m < arr [ i ] ) { x . add ( arr [ i ] ) ; } else if ( m == arr [ i ] ) { m = m + 1 ; while ( x . contains ( m ) ) { x . remove ( m ) ; m = m + 1 ; } } } return m ; }
boolean isPalindrome ( String str , int i , int j ) { while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; }
void revereseArray ( int arr [ ] , int n ) { int rev [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) rev [ n - i - 1 ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = rev [ i ] ; }
int _log ( double x , double base ) { return ( int ) ( Math . log ( x ) / Math . log ( base ) ) ; }
int maximumCut ( int [ ] arr , int K ) { int low = 0 ; int high = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int chocolate = cal ( arr , mid ) ; if ( chocolate == K ) return mid ; else if ( chocolate < K ) high = mid - 1 ; else { low = mid + 1 ; if ( mid > high ) high = mid ; } } return high ; }
void findMissingBinaryString ( String [ ] nums , int N ) { HashSet < String > s = new HashSet < String > ( ) ; int counter = 0 ; for ( String str : nums ) { s . add ( str ) ; } int total = ( int ) Math . pow ( 2 , N ) ; String ans = "" ; for ( int i = 0 ; i < total ; i ++ ) { String num = "" ; for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( ( i & ( 1 << j ) ) > 0 ) { num += '1' ; } else { num += '0' ; } } if ( s . contains ( num ) ) { continue ; counter ++ ; } else { System . out . print ( num + ", " ) ; } } if ( counter == total ) { System . out . print ( "-1" ) ; } }
int Minimum ( int N , int K ) { int sum = N * ( N + 1 ) / 2 ; if ( K > sum ) return - 1 ; if ( K <= N ) return 1 ; sum = 0 ; int count = 0 ; while ( N >= 1 && sum < K ) { count += 1 ; sum += N ; N -= 1 ; } return count ; }
int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int sum = 0 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += i ; if ( sum <= K ) res ++ ; else break ; } return res ; }
void mostFrequent ( int arr [ ] , int N ) { int ans [ ] = new int [ N ] ; Arrays . fill ( ans , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { int count [ ] = new int [ N ] ; Arrays . fill ( count , 0 ) ; int best = 0 ; for ( int j = i ; j < N ; j ++ ) { count [ arr [ j ] - 1 ] ++ ; if ( count [ arr [ j ] - 1 ] > count [ best - 1 ] || ( count [ arr [ j ] - 1 ] == count [ best - 1 ] && arr [ j ] < best ) ) { best = arr [ j ] ; } ans [ best - 1 ] ++ ; } } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( ans [ i ] + " " ) ; }
void Add_edge ( int u , int v ) { edges [ u ] . add ( v ) ; edges [ v ] . add ( u ) ; }
void minCost ( char [ ] [ ] arr , int A , int B ) { int n = arr . length ; int m = arr [ 0 ] . length ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == '*' ) continue ; if ( j == m - 1 ) ans += A ; else { if ( arr [ i ] [ j + 1 ] == '.' ) { ans += Math . min ( 2 * A , B ) ; j ++ ; } else ans += A ; } } } System . out . println ( ans ) ; }
int binarySeach ( int P [ ] , int N ) { int i = 0 ; int j = P . length - 1 ; int index = - 1 ; while ( i <= j ) { int mid = i + ( j - i ) / 2 ; if ( P [ mid ] >= N ) { index = mid ; j = mid - 1 ; } else { i = mid + 1 ; } } return index ; }
int countPairs ( int [ ] arr , int N ) { int count = 0 ; HashSet < Integer > S = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) S . add ( arr [ i ] ) ; for ( int ele : S ) { int sum = 2 * ele ; count += getCountPairs ( arr , N , sum ) ; } return count ; }
void SieveOfEratosthenes ( boolean prime [ ] ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < MAX ; i += p ) prime [ i ] = false ; } } }
void printReverse ( String sentence ) { var newlist = new ArrayList < > ( ) ; var lis = new ArrayList < > ( ) ; var temp = "" ; for ( int i = 0 ; i < sentence . length ( ) ; i ++ ) { if ( sentence . charAt ( i ) == ' ' ) { lis . add ( temp ) ; temp = "" ; } else temp += sentence . charAt ( i ) ; } lis . add ( temp ) ; for ( int i = 0 ; i < lis . length ; i ++ ) { if ( palindrome ( lis . charAt ( i ) ) ) newlist . add ( lis . charAt ( i ) ) ; } newlist . reverse ( ) ; var j = 0 ; for ( int i = 0 ; i < lis . length ; i ++ ) { if ( palindrome ( lis . charAt ( i ) ) ) { lis . set ( i , newlist . get ( j ) ) ; j = j + 1 ; } } for ( int i = 0 ; i < lis . length ; i ++ ) { document . print ( lis . charAt ( i ) + " " ) ; } }
void maximumNumber ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int minimum = arr [ 0 ] ; int ans = minimum + K ; for ( int i = 0 ; i < N ; i ++ ) { if ( Math . abs ( arr [ i ] - ans ) > K ) { ans = - 1 ; break ; } } System . out . println ( ans ) ; }
int CountPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( i * j ) == ( arr [ i ] * arr [ j ] ) ) count ++ ; } } return count ; }
boolean checkGroup ( Vector < Integer > arr ) { if ( arr . size ( ) <= 2 ) return true ; int corner = arr . get ( 0 ) + arr . get ( ( int ) arr . size ( ) - 1 ) ; int xorSum = 0 ; for ( int i = 0 ; i < arr . size ( ) - 1 ; i ++ ) xorSum += ( arr . get ( i ) ^ arr . get ( i + 1 ) ) ; if ( corner == 0 ) if ( xorSum > 2 ) return false ; else if ( corner == 1 ) if ( xorSum > 1 ) return false ; else if ( xorSum > 0 ) return false ; return true ; }
boolean isPalindrome ( String S , int i , int j ) { while ( i < j ) { if ( S . charAt ( i ) != S . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; }
void printLongestPalindrome ( String S , int N ) { int [ ] palLength = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int maxlength = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( S . charAt ( j ) == S . charAt ( i ) ) { if ( isPalindrome ( S , j , i ) ) { maxlength = i - j + 1 ; break ; } } } for ( int j = N - 1 ; j > i ; j -- ) { if ( S . charAt ( j ) == S . charAt ( i ) ) { if ( isPalindrome ( S , i , j ) ) { maxlength = Math . max ( j - i + 1 , maxlength ) ; break ; } } } palLength [ i ] = maxlength ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( palLength [ i ] + " " ) ; } }
void findMaxIntervals ( int [ ] [ ] v , int n ) { int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int c = n ; for ( int j = 0 ; j < n ; j ++ ) { if ( v [ i ] [ 1 ] < v [ j ] [ 0 ] v [ i ] [ 1 ] > v [ j ] [ 0 ] ) { c -- ; } } maxi = Math . max ( c , maxi ) ; } System . out . print ( maxi ) ; }
void update ( int ss , int se , int si , int X , int V , int tree [ ] , int arr [ ] ) { if ( ss == se ) { if ( ss == X ) { arr [ X ] = V ; tree [ si ] = check ( V ) ; } return ; } int mid = ( ss + se ) / 2 ; if ( X <= mid ) update ( ss , mid , 2 * si + 1 , X , V , tree , arr ) ; else update ( mid + 1 , se , 2 * si + 2 , X , V , tree , arr ) ; tree [ si ] = tree [ 2 * si + 1 ] + tree [ 2 * si + 2 ] ; }
int atleast_x ( int index , int s , int e , int ql , int qr , int x ) { if ( ql > e qr < s ) return - 1 ; if ( s <= ql && e <= qr ) { if ( Tree [ index ] < x ) return - 1 ; while ( s != e ) { int m = ( s + e ) / 2 ; if ( Tree [ 2 * index ] >= x ) { e = m ; index = 2 * index ; } else { s = m + 1 ; index = 2 * index + 1 ; } } return s ; } int m = ( s + e ) / 2 ; int val = atleast_x ( 2 * index , s , m , ql , qr , x ) ; if ( val != - 1 ) return val ; return atleast_x ( 2 * index + 1 , m + 1 , e , ql , qr , x ) ; }
void rearrange ( int [ ] a , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; Arrays . sort ( a ) ; x = n - x ; int z = count ( a , 0 ) ; if ( x > n - z ) { System . out . println ( "-1" ) ; return ; } for ( int i = 0 ; i < n && x > 0 ; i += 2 ) { a [ i ] = - a [ i ] ; x -- ; } for ( int i = n - 1 ; i >= 0 && x > 0 ; i -- ) { if ( a [ i ] > 0 ) { a [ i ] = - a [ i ] ; x -- ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] + " " ) ; } }
void countTriplets ( int [ ] arr , int N ) { Vector < Integer > zero_i = new Vector < Integer > ( ) ; Vector < Integer > one_i = new Vector < Integer > ( ) ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero_i . add ( i + 1 ) ; else if ( arr [ i ] == 1 ) one_i . add ( i + 1 ) ; else mp . put ( i + 1 , 1 ) ; } int total = zero_i . size ( ) * one_i . size ( ) * mp . size ( ) ; for ( int i = 0 ; i < zero_i . size ( ) ; i ++ ) { for ( int j = 0 ; j < one_i . size ( ) ; j ++ ) { int p = zero_i . get ( i ) ; int q = one_i . get ( j ) ; int r = 2 * p - q ; if ( mp . get ( r ) > 0 ) total -- ; r = 2 * q - p ; if ( mp . get ( r ) > 0 ) total -- ; r = ( p + q ) / 2 ; if ( mp . get ( r ) > 0 && Math . abs ( r - p ) == Math . abs ( r - q ) ) total -- ; } } System . out . print ( total ) ; }
void Pairs ( long N , long A , long B ) { int powerA , powerB ; powerA = power ( A , N ) ; powerB = power ( B , N ) ; long intialB = B , intialA = A ; A = 1 ; for ( int i = 0 ; i <= powerA ; i ++ ) { B = 1 ; for ( int j = 0 ; j <= powerB ; j ++ ) { if ( B == N - A ) { System . out . println ( i + " " + j ) ; return ; } B *= intialB ; } A *= intialA ; } System . out . println ( - 1 ) ; return ; }
int CountSubarray ( int arr [ ] , int n , int k ) { int temp = k , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; }
void findElement ( int arr [ ] , int N , int K ) { int ele = findElementUtil ( arr , N , K ) ; if ( ele == - 1 ) System . out . println ( "-1" ) ; else System . out . println ( ele ) ; }
int findCntTriplet ( int N ) { int cntTriplet = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( N % i != 0 ) { cntTriplet += N / i ; } else { cntTriplet += ( N / i ) - 1 ; } } return cntTriplet ; }
void splitString ( String S , int N ) { char c = S . charAt ( N - 1 ) ; int f = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S . charAt ( i ) == c ) { f = 1 ; break ; } } if ( f == 1 ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
void minOperations ( int arr [ ] , int n ) { int flips = 0 ; for ( int i = 0 ; i < n ; i += 2 ) { if ( arr [ i ] % 2 == 1 ) { continue ; } while ( i < n && arr [ i ] % 2 == 0 ) { i += 2 ; } flips ++ ; } for ( int i = 1 ; i < n ; i += 2 ) { if ( arr [ i ] % 2 == 1 ) { continue ; } while ( i < n && arr [ i ] % 2 == 0 ) { i += 2 ; } flips ++ ; } System . out . println ( flips ) ; }
void checkAnswer ( HashMap < Integer , Integer > map , int N , int K ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( map . get ( i ) == ( N - K + 1 ) ) { System . out . print ( i + " " ) ; return ; } } System . out . print ( - 1 + " " ) ; }
void updateAnswerArray ( int answer [ ] , int N ) { int i = 0 ; while ( answer [ i ] == - 1 ) i ++ ; int minimum = answer [ i ] ; while ( i <= N ) { if ( answer [ i ] == - 1 ) answer [ i ] = minimum ; else answer [ i ] = Math . min ( minimum , answer [ i ] ) ; minimum = Math . min ( minimum , answer [ i ] ) ; i ++ ; } }
void checkString ( String X , String Y ) { int L = - 1 ; int R = - 1 ; for ( int i = 0 ; i < X . length ( ) ; ++ i ) { if ( X . charAt ( i ) != Y . charAt ( i ) ) { L = i ; break ; } } for ( int i = X . length ( ) - 1 ; i > 0 ; -- i ) { if ( X . charAt ( i ) != Y . charAt ( i ) ) { R = i ; break ; } } X = reverse ( X ) ; if ( X == Y ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
char longestLastingBulb ( Vector < Integer > onTime , String s ) { char ans ; int n = onTime . size ( ) ; int maxDur = Integer . MIN_VALUE ; int maxPos = Integer . MIN_VALUE ; int currentDiff = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { currentDiff = onTime . get ( i ) ; maxDur = currentDiff ; maxPos = i ; } else { currentDiff = onTime . get ( i ) - onTime . get ( i - 1 ) ; if ( maxDur < currentDiff ) { maxDur = currentDiff ; maxPos = i ; } else { if ( maxDur == currentDiff ) { char one = s . charAt ( i ) ; char two = s . charAt ( maxPos ) ; if ( one > two ) { maxDur = currentDiff ; maxPos = i ; } } } } } ans = s . charAt ( maxPos ) ; return ans ; }
void max_freq ( int arr [ ] , int N ) { int Max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int Min = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int freq [ ] = new int [ Max - Min + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] - Min ] ++ ; } int maxSum = 0 ; for ( int i = 0 ; i < ( Max - Min - 1 ) ; i ++ ) { int val = freq [ i ] + freq [ i + 1 ] + freq [ i + 2 ] ; maxSum = Math . max ( maxSum , val ) ; } System . out . println ( maxSum ) ; }
int find_longest_subarray ( int A [ ] , int N , int K ) { int MaxLen = 0 ; int Len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( K % A [ i ] == 0 ) { Len ++ ; MaxLen = Math . max ( MaxLen , Len ) ; } else { Len = 0 ; } } return MaxLen ; }
void SieveOfEratosthenes ( boolean prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
String kReducingStringUtil ( int n , int k , String str , int no_of_zeroes ) { int zeroes_in_2k = ( ( no_of_zeroes ) * ( 2 * k ) ) / n ; int ones_in_2k = 2 * k - zeroes_in_2k ; String temp_str = "" ; for ( int i = 0 ; i < ( zeroes_in_2k ) / 2 ; i ++ ) { temp_str += ( '0' ) ; } for ( int i = 0 ; i < ones_in_2k ; i ++ ) { temp_str += ( '1' ) ; } for ( int i = 0 ; i < ( zeroes_in_2k ) / 2 ; i ++ ) { temp_str += ( '0' ) ; } String final_str = "" ; for ( int i = 0 ; i < n / ( 2 * k ) ; i ++ ) { final_str += ( temp_str ) ; } for ( int i = 0 ; i < n % ( 2 * k ) ; i ++ ) { final_str += ( temp_str . charAt ( i ) ) ; } return final_str ; }
long power ( long x , long N ) { long res = 1 ; while ( N > 0 ) { if ( N % 2 == 1 ) { res = ( res * x ) ; } x = ( x * x ) ; N = N >> 1 ; } return res ; }
void countRemovableElem ( int arr [ ] , int N ) { int hash [ ] = new int [ N + 1 ] ; int mex = N + 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= N ) hash [ arr [ i ] ] = 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( hash [ i ] == 0 ) { mex = i ; break ; } } System . out . println ( N - ( mex - 1 ) ) ; }
void findMaxPoints ( int arr [ ] [ ] , int n ) { int ans [ ] = new int [ 2 ] ; Arrays . fill ( ans , findMaxPoint ( arr , 0 , n ) , 2 * sizeof ( int ) ) ; if ( ans [ 0 ] == INF ) { System . out . println ( - 1 ) ; } else { System . out . println ( "(" + ans [ 0 ] + " " + ans [ 1 ] + ")" ) ; } }
int numberOfGP ( int L [ ] , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
boolean palindrome ( int [ ] a , int i , int j ) { while ( i < j ) { if ( a [ i ] != a [ j ] ) return false ; i ++ ; j -- ; } return true ; }
void countGreater ( int arr [ ] , int N ) { Set < Integer > St = new HashSet < Integer > ( ) ; int countLeftGreater [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { St . add ( arr [ i ] ) ; int it = St . last ( ) ; countLeftGreater [ i ] = distance ( it , St . last ( ) ) ; } display ( countLeftGreater , N ) ; }
int key ( int N ) { String num = "" + Integer . toString ( N ) ; int ans = 0 ; int j = 0 ; for ( j = 0 ; j < num . length ( ) ; j ++ ) { if ( ( num . charAt ( j ) - 48 ) % 2 == 0 ) { int add = 0 ; int i ; for ( i = j ; j < num . length ( ) ; j ++ ) { add += num . charAt ( j ) - 48 ; if ( add % 2 == 1 ) break ; } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) Math . floor ( Math . log10 ( add ) + 1 ) ; ans *= ( Math . pow ( 10 , digit ) ) ; ans += add ; } i = j ; } else { int add = 0 ; int i ; for ( i = j ; j < num . length ( ) ; j ++ ) { add += num . charAt ( j ) - 48 ; if ( add % 2 == 0 ) { break ; } } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) Math . floor ( Math . log10 ( add ) + 1 ) ; ans *= ( Math . pow ( 10 , digit ) ) ; ans += add ; } i = j ; } } if ( j + 1 >= num . length ( ) ) { return ans ; } else { return ans += num . charAt ( num . length ( ) - 1 ) - 48 ; } }
int longDelSub ( String str1 , String str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; int prev_pos = 0 ; int [ ] pos = new int [ M ] ; for ( int i = 0 ; i < M ; i ++ ) { int index = prev_pos ; while ( index < N && str1 . charAt ( index ) != str2 . charAt ( i ) ) { index ++ ; } pos [ i ] = index ; prev_pos = index + 1 ; } int res = N - prev_pos ; prev_pos = N - 1 ; for ( int i = M - 1 ; i >= 0 ; i -- ) { int index = prev_pos ; while ( index >= 0 && str1 . charAt ( index ) != str2 . charAt ( i ) ) { index -- ; } if ( i != 0 ) { res = Math . max ( res , index - pos [ i - 1 ] - 1 ) ; } prev_pos = index - 1 ; } res = Math . max ( res , prev_pos + 1 ) ; return res ; }
int countSubArray ( int arr [ ] , int n ) { if ( n < 2 ) return n ; int i = max_element ( arr , n ) ; int j = min_element ( arr , n ) ; if ( i > j ) { int temp = i ; i = j ; j = temp ; } return ( i + 1 ) * ( n - j ) ; }
boolean isPerfectSquare ( int n ) { double sr = Math . sqrt ( n ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
void updateFreq ( int n , int [ ] freq ) { while ( n > 0 ) { int digit = n % TEN ; freq [ digit ] ++ ; n /= TEN ; } }
int count_numbers ( int L , int R ) { int ans = 0 ; int LogR = ( int ) ( Math . log ( R ) / Math . log ( 2 ) ) + 1 ; for ( int zero_bit = 0 ; zero_bit < LogR ; zero_bit ++ ) { int cur = 0 ; for ( int j = 0 ; j < zero_bit ; j ++ ) { cur |= ( 1 << j ) ; } for ( int j = zero_bit + 1 ; j < LogR ; j ++ ) { cur |= ( 1 << j ) ; if ( cur >= L && cur <= R ) { ans ++ ; } } } return ans ; }
int maxGCD ( int n ) { return ( n / 2 ) ; }
void updateTree ( char [ ] str , int pos , char s ) { int index = pos ; update_BITree ( index , str [ index ] , - 1 ) ; str [ index ] = s ; update_BITree ( index , s , 1 ) ; }
int minServerLoads ( int n , int [ ] servers ) { int totalLoad = 0 ; for ( int i : servers ) totalLoad += i ; int requiredLoad = totalLoad / 2 ; int [ ] [ ] dp = new int [ n + 1 ] [ requiredLoad + 1 ] ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < requiredLoad + 1 ; j ++ ) { if ( servers [ i - 1 ] > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , servers [ i - 1 ] + dp [ i - 1 ] [ j - servers [ i - 1 ] ] ) ; } } return totalLoad - 2 * dp [ n ] [ requiredLoad ] ; }
int maxLength ( String [ ] arr ) { int len = Integer . MIN_VALUE ; int N = arr . length ; for ( int i = 0 ; i < N ; i ++ ) { int l = arr [ i ] . length ( ) ; if ( len < l ) { len = l ; } } return len ; }
void dfs ( int node ) { vis [ node ] = true ; for ( int x : vec [ node ] ) { if ( ! vis [ x ] ) { cc ++ ; dfs ( x ) ; } } }
int solve ( int D [ ] [ ] , int N , int X , int Y ) { ArrayList < Double > T = new ArrayList < Double > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int x = D [ i ] [ 0 ] ; int y = D [ i ] [ 1 ] ; double speed = D [ i ] [ 2 ] ; double time = ( ( x * x - X * X ) + ( y * y - Y * Y ) ) / ( speed * speed ) ; T . add ( time ) ; } Collections . sort ( T ) ; int i = 0 ; int total = 0 ; while ( i < T . size ( ) - 1 ) { int count = 1 ; while ( i < T . size ( ) - 1 && T . get ( i ) == T . get ( i + 1 ) ) { count += 1 ; i += 1 ; } total += ( count * ( count - 1 ) ) / 2 ; i += 1 ; } return total ; }
int [ ] findSubarrays ( int [ ] a ) { int n = a . length ; int [ ] freq = new int [ n + 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { if ( count == 0 ) continue ; else { int value = count ; for ( int j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } count = 0 ; } } else count ++ ; } if ( count > 0 ) { int value = count ; for ( int j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } } return freq ; }
void sumOfIndices ( String s ) { int N = s . length ( ) ; int x = ( int ) ( Math . ceil ( Math . log ( N ) / Math . log ( 2 ) ) ) ; int seg_size = 2 * ( int ) Math . pow ( 2 , x ) - 1 ; int [ ] segment = new int [ seg_size ] ; int count = 0 ; HashMap < Integer , Queue < Integer > > fre = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( fre . containsKey ( s . charAt ( i ) ) ) { fre . remove ( s . charAt ( i ) ) ; } else { int original_index = it . getValue ( ) ; int curr_index = deleted ( segment , 0 , original_index - 1 , 0 , N - 1 , 0 ) ; int new_index = original_index - curr_index ; count += new_index + 1 ; add_seg ( segment , 0 , N - 1 , 0 , original_index ) ; it . getValue ( ) . remove ( ) ; } } System . out . println ( count ) ; }
int maxLength ( int n , int m ) { sieve ( ) ; smallestPrimeFactors ( ) ; int ans = Integer . MIN_VALUE ; for ( int i = n ; i <= m ; i ++ ) { if ( i == 4 ) { continue ; } ans = Math . max ( ans , findLength ( i ) ) ; } return ans ; }
int getMax ( int [ ] st , int n , int l , int r ) { if ( l < 0 r > n - 1 l > r ) { System . out . println ( "Invalid Input" ) ; return - 1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; }
int subArraylen ( int arr [ ] , int n , int K ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; mp . put ( arr [ 0 ] , 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; mp . put ( arr [ i ] , i ) ; } int len = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < K ) continue ; else { int x = arr [ i ] - K ; if ( x == 0 ) len = Math . min ( len , i ) ; if ( ! mp . containsKey ( x ) ) continue ; else { len = Math . min ( len , i - mp . get ( x ) ) ; } } } return len ; }
boolean check ( int arr [ ] , int n ) { int i , g ; g = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 0 && g == 1 ) return false ; if ( arr [ i ] - arr [ i - 1 ] < 0 ) g = 1 ; } return true ; }
void addedge ( int node1 , int node2 ) { G [ node1 ] . add ( node2 ) ; G [ node2 ] . add ( node1 ) ; }
int countElements ( int arr [ ] , int n , int k ) { Stack < Integer > s = new Stack < > ( ) ; int [ ] next_greater = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . empty ( ) ) { s . push ( i ) ; continue ; } while ( ! s . empty ( ) && arr [ s . peek ( ) ] < arr [ i ] ) { next_greater [ s . peek ( ) ] = i ; s . pop ( ) ; } s . push ( i ) ; } int count = 0 ; int maxi = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( next_greater [ i ] - i > k && maxi < arr [ i ] ) { maxi = Math . max ( maxi , arr [ i ] ) ; count ++ ; } } return count ; }
void addEdge ( int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; }
Vector < Vector < Integer > > constructTree ( int n , Vector < Vector < Integer > > edges ) { Vector < Vector < Integer > > adjl = new Vector < Vector < Integer > > ( n ) ; for ( Vector < Integer > e : edges ) { int u = e . get ( 0 ) ; int v = e . get ( 1 ) ; adjl . get ( u ) . add ( v ) ; adjl . get ( v ) . add ( u ) ; } return adjl ; }
int min_remove ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] - arr [ i ] <= k ) { ans = Math . min ( ans , n - j + i - 1 ) ; } } } return ans ; }
int lcm ( int a , int b ) { return ( a * b ) / __gcd ( a , b ) ; }
int countPair ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( __gcd ( i , j ) + lcm ( i , j ) == N ) { count ++ ; } } } return count ; }
boolean isVowel ( char c ) { if ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) return true ; return false ; }
void countSubstrings ( String s , int n ) { int temp [ ] = { 1 , 0 } ; int result = 0 , sum = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { sum += ( isVowel ( s . charAt ( i ) ) ? 1 : 0 ) ; sum %= 2 ; temp [ sum ] ++ ; } result += ( ( temp [ 0 ] * ( temp [ 0 ] - 1 ) ) / 2 ) ; result += ( ( temp [ 1 ] * ( temp [ 1 ] - 1 ) ) / 2 ) ; System . out . println ( result ) ; }
int minOperations ( String s ) { int n = s . length ( ) ; int pos = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' ) { pos = i ; break ; } } if ( pos == - 1 ) { return 0 ; } int last = 1 ; int ans = 1 ; for ( int i = pos + 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) { if ( last == 1 ) { ans ++ ; last = 0 ; } } else { if ( last == 0 ) { ans ++ ; last = 1 ; } } } return ans ; }
boolean checkBitonic ( int arr [ ] , int n ) { int i , j , f = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { f = 1 ; break ; } } if ( i == n ) return true ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < arr [ j - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { if ( f == 1 ) return false ; } } return true ; }
boolean isNudeNum ( int n ) { int copy , length , flag = 0 ; copy = n ; String temp ; temp = Integer . toString ( copy ) ; length = temp . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { int num = temp . charAt ( i ) - '0' ; if ( num == 0 || n % num != 0 ) { flag = 1 ; } } if ( flag == 1 ) return false ; else return true ; }
Vector < Integer > get_subminarr ( int [ ] arr , int n , int y ) { int j = 0 ; Stack < Integer > stk = new Stack < Integer > ( ) ; int [ ] minarr = new int [ n ] ; Arrays . fill ( minarr , 0 ) ; stk . push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( stk . size ( ) != 0 && arr [ i ] < arr [ stk . peek ( ) ] ) { minarr [ stk . peek ( ) ] = i ; stk . pop ( ) ; } stk . push ( i ) ; } while ( stk . size ( ) != 0 ) { minarr [ stk . size ( ) ] = n ; stk . pop ( ) ; } Vector < Integer > submin = new Vector < Integer > ( ) ; for ( int i = 0 ; i <= n - y ; i ++ ) { while ( minarr [ j ] <= i + y - 1 j < i ) { j ++ ; } submin . add ( arr [ j ] ) ; } return submin ; }
void PrintSequence ( int freq [ ] , int n ) { Vector < Integer > sequence = generateSequence ( freq , n ) ; if ( sequence . size ( ) == 0 ) { System . out . print ( "-1" ) ; } else { for ( int i = 0 ; i < sequence . size ( ) ; i ++ ) { System . out . print ( sequence . get ( i ) + " " ) ; } } }
void checkArray ( int A [ ] , int B [ ] , int N ) { int start = 0 ; int end = N - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { start = i ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( A [ i ] != B [ i ] ) { end = i ; break ; } } Collections . reverse ( A ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { System . out . println ( "No" ) ; return ; } } System . out . println ( "Yes" ) ; }
int longestSubarray ( int a [ ] , int n ) { int l [ ] = new int [ n ] ; int r [ ] = new int [ n ] ; for ( int i = 0 , count = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; else { l [ i ] = count ; count = 0 ; } } for ( int i = n - 1 , count = 0 ; i >= 0 ; i -- ) { if ( a [ i ] == 1 ) count ++ ; else { r [ i ] = count ; count = 0 ; } } int ans = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] == 0 ) ans = Math . max ( ans , l [ i ] + r [ i ] ) ; } return ans < 0 ? n : ans ; }
int solve ( int n , int k ) { int ans = 0 ; for ( int j = 1 ; j * j <= n ; j ++ ) { if ( n % j == 0 ) { if ( j <= k ) { ans = Math . max ( ans , j ) ; } if ( n / j <= k ) { ans = Math . max ( ans , n / j ) ; } } } return ans ; }
int splitArray ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int result = Integer . MAX_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { result = Math . min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
int countTriplets ( int a [ ] , int n , int x ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { Vector < Integer > temp = new Vector < Integer > ( ) ; temp . add ( a [ i ] ) ; temp . add ( a [ j ] ) ; temp . add ( a [ k ] ) ; Collections . sort ( temp ) ; if ( temp . get ( 0 ) < temp . get ( 1 ) && temp . get ( 1 ) < temp . get ( 2 ) && temp . get ( 0 ) * temp . get ( 1 ) * temp . get ( 2 ) <= x ) answer ++ ; } } } return answer ; }
void fibonacci ( ) { int prev = 0 , curr = 1 , len = 2 ; fib . add ( prev ) ; fib . add ( curr ) ; while ( len <= MAX ) { int temp = curr + prev ; fib . add ( temp ) ; prev = curr ; curr = temp ; len ++ ; } }
int xorOfSum ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; }
void createHash ( HashSet < Integer > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr < maxElement ) { int temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } }
void state8 ( char c ) { if ( c == 'c' ) nfa = 9 ; else if ( c == 'b' c == 'a' ) nfa = 8 ; else flag = 1 ; }
int maxSum ( int arr [ ] , int n , int k ) { if ( n < k ) { return - 1 ; } int res = 0 ; for ( int i = 0 ; i < k ; i ++ ) res += arr [ i ] ; int curr_sum = res ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; res = Math . max ( res , curr_sum ) ; } return res ; }
boolean isDigit ( char ch ) { if ( ch >= '0' && ch <= '9' ) return true ; return false ; }
int nextPosition ( int tempGCD , int startPointer , int prevEndPointer , int n ) { int high = n - 1 ; int low = prevEndPointer ; int mid = prevEndPointer ; int nextPos = prevEndPointer ; while ( high >= low ) { mid = ( ( high + low ) >> 1 ) ; if ( queryForGCD ( startPointer , mid ) == tempGCD ) { nextPos = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return nextPos + 1 ; }
int gcd ( int A , int B ) { if ( B == 0 ) return A ; return gcd ( B , A % B ) ; }
void farthest_min ( int a [ ] , int n ) { int [ ] suffix_min = new int [ n ] ; suffix_min [ n - 1 ] = a [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffix_min [ i ] = Math . min ( suffix_min [ i + 1 ] , a [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { int low = i + 1 , high = n - 1 , ans = - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( suffix_min [ mid ] < a [ i ] ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } System . out . print ( ans + " " ) ; } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int solve ( int array [ ] , int n , int K ) { Arrays . sort ( array ) ; int end = 0 ; for ( int i = 0 ; i < n ; i ++ ) { } int start = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( check ( mid , array , n , K ) ) { answer = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } return answer ; }
boolean isPossible ( int box [ ] , int truck [ ] , int n , int m , int min_time ) { int temp = 0 ; int count = 0 ; while ( count < m ) { for ( int j = 0 ; j < min_time && temp < n && truck [ count ] >= box [ temp ] ; j += 2 ) temp ++ ; count ++ ; } if ( temp == n ) return true ; return false ; }
void solve ( int interval [ ] [ ] , int N , int Q ) { int Mark [ ] = new int [ Q ] ; for ( int i = 0 ; i < N ; i ++ ) { int l = interval [ i ] [ 0 ] - 1 ; int r = interval [ i ] [ 1 ] - 1 ; for ( int j = l ; j <= r ; j ++ ) Mark [ j ] ++ ; } int count = 0 ; for ( int i = 0 ; i < Q ; i ++ ) { if ( Mark [ i ] != 0 ) count ++ ; } int count1 [ ] = new int [ Q ] ; if ( Mark [ 0 ] == 1 ) count1 [ 0 ] = 1 ; for ( int i = 1 ; i < Q ; i ++ ) { if ( Mark [ i ] == 1 ) count1 [ i ] = count1 [ i - 1 ] + 1 ; else count1 [ i ] = count1 [ i - 1 ] ; } int maxindex ; int maxcoverage = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int l = interval [ i ] [ 0 ] - 1 ; int r = interval [ i ] [ 1 ] - 1 ; int elem1 ; if ( l != 0 ) elem1 = count1 [ r ] - count1 [ l - 1 ] ; else elem1 = count1 [ r ] ; if ( count - elem1 >= maxcoverage ) { maxcoverage = count - elem1 ; maxindex = i ; } } System . out . println ( "Maximum Coverage is " + maxcoverage + " after removing interval at index " + maxindex ) ; }
int maxSum ( int arr [ ] , int n , int K ) { int maximum = Integer . MIN_VALUE ; int sum [ ] = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i + K < n ) sum [ i ] = sum [ i + K ] + arr [ i ] ; else sum [ i ] = arr [ i ] ; maximum = Math . max ( maximum , sum [ i ] ) ; } return maximum ; }
int countGreater ( int arr [ ] , int n , int k ) { int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; }
int countFactor ( int P , int X ) { if ( X < P ) return 0 ; return ( X / P + countFactor ( P , X / P ) ) ; }
long squareSum ( long N ) { long sum = ( long ) ( N * ( N + 1 ) * ( 2 * N + 1 ) ) / 6 ; return sum ; }
int countPattern ( int n , String pat ) { int pattern_int = 0 ; int power_two = 1 ; int all_ones = 0 ; for ( int i = pat . length ( ) - 1 ; i >= 0 ; i -- ) { int current_bit = pat . charAt ( i ) - '0' ; pattern_int += ( power_two * current_bit ) ; all_ones = all_ones + power_two ; power_two = power_two * 2 ; } int count = 0 ; while ( n > 0 && n >= pattern_int ) { if ( ( n & all_ones ) == pattern_int ) { count ++ ; } n = n >> 1 ; } return count ; }
int getMax ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = Math . max ( res , arr [ i ] ) ; return res ; }
void printDuplicates ( int arr [ ] , int n ) { int i ; int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { System . out . print ( arr [ i ] % n + " " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( fl == 0 ) { System . out . print ( "-1" ) ; } }
int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return - 1 ; Arrays . sort ( arr ) ; int x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; int y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; int z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return Math . max ( x , Math . max ( y , z ) ) ; }
int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return - 1 ; int maxA = Integer . MIN_VALUE , maxB = Integer . MIN_VALUE , maxC = Integer . MIN_VALUE , maxD = Integer . MIN_VALUE ; int minA = Integer . MAX_VALUE , minB = Integer . MAX_VALUE , minC = Integer . MAX_VALUE , minD = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxD = maxC ; maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxD = maxC ; maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) { maxD = maxC ; maxC = arr [ i ] ; } else if ( arr [ i ] > maxD ) maxD = arr [ i ] ; if ( arr [ i ] < minA ) { minD = minC ; minC = minB ; minB = minA ; minA = arr [ i ] ; } else if ( arr [ i ] < minB ) { minD = minC ; minC = minB ; minB = arr [ i ] ; } else if ( arr [ i ] < minC ) { minD = minC ; minC = arr [ i ] ; } else if ( arr [ i ] < minD ) minD = arr [ i ] ; } int x = maxA * maxB * maxC * maxD ; int y = minA * minB * minC * minD ; int z = minA * minB * maxA * maxB ; return Math . max ( x , Math . max ( y , z ) ) ; }
void push ( Node head_ref , char new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; start = head_ref ; }
boolean isPossible ( int arr [ ] , int n , int m , int curr_min ) { int studentsRequired = 1 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > curr_min ) return false ; if ( curr_sum + arr [ i ] > curr_min ) { studentsRequired ++ ; curr_sum = arr [ i ] ; if ( studentsRequired > m ) return false ; } else curr_sum += arr [ i ] ; } return true ; }
void sortArray ( int arr [ ] , int N ) { int i = 0 , j = N - 1 , mid = 0 ; while ( mid <= j ) { if ( arr [ mid ] == 0 ) { int temp = arr [ i ] ; arr [ i ] = arr [ mid ] ; arr [ mid ] = temp ; i ++ ; mid ++ ; } else if ( arr [ mid ] == 3 ) { int temp = arr [ mid ] ; arr [ mid ] = arr [ j ] ; arr [ j ] = temp ; j -- ; } else if ( arr [ mid ] == 1 arr [ mid ] == 2 ) { mid ++ ; } } while ( i <= j ) { if ( arr [ i ] == 2 ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; j -- ; } else { i ++ ; } } for ( i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
boolean isSorted ( pair arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] . first > arr [ i - 1 ] . first ) { return false ; } } return true ; }
boolean isSortedArray ( int arr [ ] , int n ) { int l = 0 , r = ( n - 1 ) ; while ( ( l + 1 ) < r ) { if ( arr [ l ] >= Math . max ( arr [ l + 1 ] , arr [ r - 1 ] ) && arr [ r ] >= Math . max ( arr [ r - 1 ] , arr [ l + 1 ] ) ) { l ++ ; r -- ; } else { return false ; } } return true ; }
void findMaxNumbers ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int opr = ( int ) Math . ceil ( ( Math . log ( arr [ i ] ) / Math . log ( 2 ) ) ) ; k -= opr ; if ( k < 0 ) { break ; } cnt ++ ; } System . out . print ( cnt ) ; }
void rearrange ( Integer [ ] A , Integer [ ] B , int N , int X ) { boolean flag = true ; Arrays . sort ( A ) ; Arrays . sort ( B , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ i ] > X ) { flag = false ; break ; } } if ( flag ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
int getMinCost ( Integer [ ] arr , int n , int k ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int min_cost = 0 ; int X = 0 ; for ( int i = 0 ; i < n ; i += k ) { for ( int j = i ; j < i + k && j < n ; j ++ ) { min_cost += arr [ j ] * ( X + 1 ) ; } X ++ ; } return min_cost ; }
int mergeSortUtil ( int arr [ ] , int temp [ ] , int l , int r , int K ) { int cnt = 0 ; if ( l < r ) { int m = ( l + r ) / 2 ; cnt += mergeSortUtil ( arr , temp , l , m , K ) ; cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) ; cnt += merge ( arr , temp , l , m , r , K ) ; } return cnt ; }
void Bubble_Sort ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; } } } }
void mostvisitedsector ( int N , int [ ] A ) { int maxVisited = 0 ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < A . length - 1 ; i ++ ) { int start = A [ i ] % N ; int end = A [ i + 1 ] % N ; while ( start != end ) { if ( start == 0 ) { mp . put ( N , mp . getOrDefault ( N , 0 ) + 1 ) ; if ( mp . get ( N ) > maxVisited ) { maxVisited = mp . get ( N ) ; } } else { mp . put ( start , mp . getOrDefault ( start , 0 ) + 1 ) ; if ( mp . get ( start ) > maxVisited ) { maxVisited = mp . get ( start ) ; } } start = ( start + 1 ) % N ; } } mp . put ( A [ A . length - 1 ] , mp . getOrDefault ( A . length - 1 , 0 ) + 1 ) ; if ( mp . get ( A . length - 1 ) > maxVisited ) { maxVisited = mp . get ( A . length - 1 ) ; } for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) { if ( x . getValue ( ) == maxVisited ) { System . out . print ( x . getKey ( ) + " " ) ; } } }
int maxRectangle ( int sequence [ ] [ ] , int size ) { int [ ] X_Cord = new int [ size ] ; int [ ] Y_Cord = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { X_Cord [ i ] = sequence [ i ] [ 0 ] ; Y_Cord [ i ] = sequence [ i ] [ 1 ] ; } Arrays . sort ( X_Cord ) ; Arrays . sort ( Y_Cord ) ; int X_Max = 0 , Y_Max = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { X_Max = Math . max ( X_Max , X_Cord [ i + 1 ] - X_Cord [ i ] ) ; Y_Max = Math . max ( Y_Max , Y_Cord [ i + 1 ] - Y_Cord [ i ] ) ; } return X_Max * Y_Max ; }
int evenSumK ( int arr [ ] , int N , int K ) { if ( K > N ) { return - 1 ; } int maxSum = 0 ; ArrayList < Integer > Even = new ArrayList < Integer > ( ) ; ArrayList < Integer > Odd = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { Odd . add ( arr [ i ] ) ; } else { Even . add ( arr [ i ] ) ; } } Collections . sort ( Odd ) ; Collections . sort ( Even ) ; int i = Even . size ( ) - 1 ; int j = Odd . size ( ) - 1 ; while ( K > 0 ) { if ( K % 2 == 1 ) { if ( i >= 0 ) { maxSum += Even . get ( i ) ; i -- ; } else { return - 1 ; } K -- ; } else if ( i >= 1 && j >= 1 ) { if ( Even . get ( i ) + Even . get ( i - 1 ) <= Odd . get ( j ) + Odd . get ( j - 1 ) ) { maxSum += Odd . get ( j ) + Odd . get ( j - 1 ) ; j -= 2 ; } else { maxSum += Even . get ( i ) + Even . get ( i - 1 ) ; i -= 2 ; } K -= 2 ; } else if ( i >= 1 ) { maxSum += Even . get ( i ) + Even . get ( i - 1 ) ; i -= 2 ; K -= 2 ; } else if ( j >= 1 ) { maxSum += Odd . get ( j ) + Odd . get ( j - 1 ) ; j -= 2 ; K -= 2 ; } } return maxSum ; }
void find_mth_bitUtil ( int n , int m ) { int fib [ ] = new int [ maxN ] ; calculateFib ( fib , maxN ) ; int ans = find_mth_bit ( n , m , fib ) ; System . out . print ( ans + " " ) ; }
int range_sum ( int [ ] arr , int a , int b ) { int sum = 0 ; if ( a - 2 < 0 ) sum = arr [ b - 1 ] ; else sum = arr [ b - 1 ] - arr [ a - 2 ] ; return sum ; }
int XorSum ( int A [ ] , int B [ ] , int N ) { const int maxBit = 29 ; int ans = 0 ; for ( int k = 0 ; k < maxBit ; k ++ ) { int C [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { C [ i ] = B [ i ] % ( 1 << ( k + 1 ) ) ; } Arrays . sort ( C ) ; long count = 0 ; long l , r ; for ( int i = 0 ; i < N ; i ++ ) { int x = A [ i ] % ( 1 << ( k + 1 ) ) ; l = lowerBound ( C , 0 , ( 1 << k ) - x ) - C ; r = lowerBound ( C , 0 , ( 1 << k ) * 2 - x ) - C ; count += ( r - l ) ; l = lowerBound ( C , 0 , ( 1 << k ) * 3 - x ) - C ; r = lowerBound ( C , 0 , ( 1 << k ) * 4 - x ) - C ; count += ( r - l ) ; } if ( ( count & 1 ) != 0 ) ans += ( 1 << k ) ; } return ans ; }
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( arr [ i ] ) && count . get ( arr [ i ] ) != 0 ) ans += count . get ( arr [ i ] ) ; if ( count . containsKey ( arr [ i ] ) ) count . put ( arr [ i ] , count . get ( arr [ i ] ) + 1 ) ; else count . put ( arr [ i ] , 1 ) ; } return ans ; }
long getAlphaScore ( Node node ) { if ( node . left != null ) getAlphaScore ( node . left ) ; sum = ( sum + node . data ) % mod ; total_sum = ( total_sum + sum ) % mod ; if ( node . right != null ) getAlphaScore ( node . right ) ; return total_sum ; }
void sortArr ( int a [ ] , int n ) { int i , k ; k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; k = ( int ) Math . pow ( 2 , k ) ; while ( k > 0 ) { for ( i = 0 ; i + k < n ; i ++ ) if ( a [ i ] > a [ i + k ] ) { int temp = a [ i ] ; a [ i ] = a [ i + k ] ; a [ i + k ] = temp ; } k = k / 2 ; } for ( i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] + " " ) ; } }
void maximizeval10 ( int a [ ] , int n , int k ) { int increments = 0 ; int ans = 0 ; Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( a [ i ] / 10 ) ; if ( a [ i ] == 1000 ) continue ; else { v . add ( 10 - a [ i ] % 10 ) ; increments += ( 100 - ( ( a [ i ] ) / 10 ) - 1 ) ; } } Collections . sort ( v ) ; int sum = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { sum += v . get ( i ) ; if ( sum <= k ) { ans ++ ; } else break ; } if ( sum < k ) { int remaining = k - sum ; ans += Math . min ( increments , remaining / 10 ) ; } System . out . print ( ans ) ; }
int number ( int a [ ] , int n , int p , int k ) { Arrays . sort ( a ) ; int pre [ ] = new int [ n ] ; int val , i , j , ans = 0 ; pre [ 0 ] = a [ 0 ] ; if ( pre [ 0 ] <= p ) ans = 1 ; for ( i = 1 ; i < k - 1 ; i ++ ) { pre [ i ] = pre [ i - 1 ] + a [ i ] ; if ( pre [ i ] <= p ) ans = i + 1 ; } pre [ k - 1 ] = a [ k - 1 ] ; for ( i = k - 1 ; i < n ; i ++ ) { if ( i >= k ) { pre [ i ] += pre [ i - k ] + a [ i ] ; } if ( pre [ i ] <= p ) ans = i + 1 ; } return ans ; }
boolean checkIsAP ( double arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; double d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != d ) { return false ; } } return true ; }
int findK ( int arr [ ] , int size , int N ) { Arrays . sort ( arr ) ; int temp_sum = 0 ; for ( int i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return - 1 ; }
int findSum ( int [ ] arr , int n , int k , int l , int r ) { if ( ( l ) + ( n - 1 - r ) == k ) return arr [ r ] - arr [ l ] ; if ( vis [ l ] [ r ] ) return dp [ l ] [ r ] ; vis [ l ] [ r ] = true ; return dp [ l ] [ r ] = Math . min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; }
void printList ( Node node ) { Node last = null ; while ( node != null ) { System . out . print ( node . data + " " ) ; last = node ; node = node . next ; } }
int Removal ( Vector < Integer > v , int n ) { Collections . sort ( v ) ; int ans = Integer . MAX_VALUE ; for ( int i : v ) { int j = upper_bound ( v , ( 2 * ( i ) ) ) ; ans = Math . min ( ans , n - ( int ) ( j - i ) ) ; } return ans ; }
void printArrangement ( int a [ ] , int n ) { Arrays . sort ( a ) ; int [ ] b = new int [ n ] ; int low = 0 , high = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) b [ low ++ ] = a [ i ] ; else b [ high -- ] = a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { if ( b [ n - 1 ] + b [ 1 ] <= b [ i ] ) { System . out . print ( - 1 ) ; return ; } } else if ( i == ( n - 1 ) ) { if ( b [ n - 2 ] + b [ 0 ] <= b [ i ] ) { System . out . print ( - 1 ) ; return ; } } else { if ( b [ i - 1 ] + b [ i + 1 ] <= b [ i ] ) { System . out . print ( - 1 ) ; return ; } } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( b [ i ] + " " ) ; }
void K_multiple ( int a [ ] , int n , int k ) { Arrays . sort ( a ) ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] % k == 0 && s . contains ( a [ i ] / k ) ) a [ i ] % k != 0 ) s . add ( a [ i ] ) ; } for ( Integer i : s ) { System . out . print ( i + " " ) ; } }
long powmod ( long a , long n ) { if ( n == 0 ) { return 1 ; } long pt = powmod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 == 1 ) { return ( pt * a ) % mod ; } else { return pt ; } }
long product ( long a [ ] , int n , int k ) { long ans = 1 ; Arrays . sort ( a ) ; long powa = C [ n - 1 ] [ k - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { long powla = C [ i ] [ k - 1 ] ; long powfa = C [ n - i - 1 ] [ k - 1 ] ; long powe = ( ( powa % MOD ) - ( powla + powfa ) % MOD + MOD ) % MOD ; long mul = power ( a [ i ] , powe ) % MOD ; ans = ( ( ans % MOD ) * ( mul % MOD ) ) % MOD ; } return ans % MOD ; }
boolean check ( String s ) { int l = s . length ( ) ; Arrays . sort ( s ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( s . charAt ( i ) - s . charAt ( i - 1 ) != 1 ) return false ; } return true ; }
void printNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int A = arr [ n - 1 ] , B = - 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( A % arr [ i ] != 0 ) { B = arr [ i ] ; break ; } if ( i - 1 >= 0 && arr [ i ] == arr [ i - 1 ] ) { B = arr [ i ] ; break ; } } System . out . print ( "A = " + A + ", B = " + B ) ; }
void findNonPalinString ( String s ) { int [ ] freq = new int [ 26 ] ; boolean flag = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( 0 ) ) flag = true ; freq [ s . charAt ( i ) - 'a' ] ++ ; } if ( ! flag ) System . out . print ( "-1" ) ; else { for ( int i = 0 ; i < 26 ; i ++ ) for ( int j = 0 ; j < freq [ i ] ; j ++ ) System . out . print ( ( char ) ( 'a' + i ) ) ; } }
int countDistinct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; res ++ ; } return res ; }
int minSubarray ( int A [ ] , int n ) { int minValue = Arrays . stream ( A ) . min ( ) . getAsInt ( ) ; int maxValue = Arrays . stream ( A ) . max ( ) . getAsInt ( ) ; int pos_min = - 1 , pos_max = - 1 , ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] == minValue ) pos_min = i ; if ( A [ i ] == maxValue ) pos_max = i ; if ( pos_max != - 1 && pos_min != - 1 ) ans = Math . min ( ans , Math . abs ( pos_min - pos_max ) + 1 ) ; } return ans ; }
int countTriplets ( Node head , int x ) { Node ptr , ptr1 , ptr2 ; int count = 0 ; HashMap < Integer , Node > um = new HashMap < > ( ) ; for ( ptr = head ; ptr != null ; ptr = ptr . next ) um . put ( ptr . data , ptr ) ; for ( ptr1 = head ; ptr1 != null ; ptr1 = ptr1 . next ) for ( ptr2 = ptr1 . next ; ptr2 != null ; ptr2 = ptr2 . next ) { int p_product = ( ptr1 . data * ptr2 . data ) ; if ( um . containsKey ( x / p_product ) && um . get ( x / p_product ) != ptr1 && um . get ( x / p_product ) != ptr2 ) count ++ ; } return ( count / 3 ) ; }
int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; Arrays . sort ( arr ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { int start = 0 , mid = end - 1 ; while ( start < mid ) { int prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
int countTripletsLessThan ( int arr [ ] , int n , int val ) { Arrays . sort ( arr ) ; int ans = 0 ; int j , k ; int sum ; for ( int i = 0 ; i < n - 2 ; i ++ ) { j = i + 1 ; k = n - 1 ; while ( j != k ) { sum = arr [ i ] + arr [ j ] + arr [ k ] ; if ( sum > val ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; }
int MaxSumDifference ( int a [ ] , int n ) { Vector < Integer > finalSequence = new Vector < Integer > ( ) ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { finalSequence . add ( a [ i ] ) ; finalSequence . add ( a [ n - i - 1 ] ) ; } if ( n % 2 != 0 ) finalSequence . add ( a [ n / 2 ] ) ; int MaximumSum = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( i ) - finalSequence . get ( i + 1 ) ) ; } MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( n - 1 ) - finalSequence . get ( 0 ) ) ; return MaximumSum ; }
int findMinimum ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += arr [ i ] ; n = n - k ; } return res ; }
int minSwapToReachArr ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] - 1 ) - i > 2 ) return - 1 ; } int numOfInversion = mergeSort ( arr , N ) ; return numOfInversion ; }
int getIndexInSortedArray ( int arr [ ] , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void gnomeSort ( int arr [ ] , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { int temp = arr [ index ] ; arr [ index ] = arr [ index - 1 ] ; arr [ index - 1 ] = temp ; index -- ; } } return ; }
void flip ( int arr [ ] , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } }
boolean possible ( int x , int S , int N ) { int minSum = ( x * ( x + 1 ) ) / 2 ; int maxSum = ( x * ( ( 2 * N ) - x + 1 ) ) / 2 ; if ( S < minSum S > maxSum ) { return false ; } return true ; }
int TotalPerfectPowerSum ( long L , long R ) { Vector < Long > pows = new Vector < Long > ( ) ; pows . add ( 0L ) ; pows . add ( 1L ) ; for ( int p = 2 ; p < 25 ; p ++ ) { long num = 2 ; while ( ( long ) ( Math . pow ( num , p ) + 0.5 ) <= R ) { pows . add ( ( long ) ( Math . pow ( num , p ) + 0.5 ) ) ; num ++ ; } } int [ ] ok = new int [ R + 1 ] ; Arrays . fill ( ok , 0 ) ; for ( int i = 0 ; i < pows . size ( ) ; i ++ ) { for ( int j = 0 ; j < pows . size ( ) ; j ++ ) { if ( pows . get ( i ) + pows . get ( j ) <= R && pows . get ( i ) + pows . get ( j ) >= L ) { ok [ pows . get ( i ) + pows . get ( j ) ] = 1 ; } } } for ( int i = 0 ; i <= R ; i ++ ) { ok [ i ] += ok [ i - 1 ] ; } return ok [ R ] - ok [ L - 1 ] ; }
long KthSolution ( long X , long K ) { long ans = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( X & ( 1 << i ) ) == 0 ) { if ( ( K & 1 ) > 0 ) { ans |= ( 1 << i ) ; } K >>= 1 ; if ( K == 0 ) { break ; } } } return ans ; }
int countNoOfsuchX ( int N ) { int k = ( int ) Math . ceil ( Math . log10 ( N ) ) ; int count = 1 ; for ( int x = ( N - ( k * ( k + 1 ) * 5 ) ) ; x < N ; x ++ ) { if ( check ( x , N ) ) { count += 1 ; } } return count ; }
int countArrays ( int n , int k ) { Vector < Integer > [ ] divisors = new Vector [ k + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 2 * i ; j <= k ; j += i ) { divisors [ j ] . add ( i ) ; } } Vector < Integer > [ ] dp = new Vector [ n + 1 ] [ k + 1 ] ; for ( int j = 1 ; j <= k ; j ++ ) { dp [ 1 ] [ j ] = 1 ; } for ( int x = 2 ; x <= n ; x ++ ) { int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum += dp [ x - 1 ] [ j ] ; } for ( int y = 1 ; y <= k ; y ++ ) { dp [ x ] [ y ] = sum ; for ( int d : divisors [ y ] ) { dp [ x ] [ y ] = ( dp [ x ] [ y ] - dp [ x - 1 ] [ d ] ) ; } } } int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum += dp [ n ] [ j ] ; } return sum ; }
boolean checkStar ( int mat [ ] [ ] ) { int vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] == 1 ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void convertXintoY ( int X , int Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y /= 2 ; else if ( Y % 10 == 1 ) Y /= 10 ; else break ; } if ( X == Y ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
int MaxXOR ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; }
int countCandies ( int arr [ ] , int n ) { int sum = 0 ; int ans [ ] = new int [ n ] ; if ( n == 1 ) { return 1 ; } for ( int i = 0 ; i < n ; i ++ ) ans [ i ] = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i + 1 ] > arr [ i ] && ans [ i + 1 ] <= ans [ i ] ) { ans [ i + 1 ] = ans [ i ] + 1 ; } } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > arr [ i + 1 ] && ans [ i ] <= ans [ i + 1 ] ) { ans [ i ] = ans [ i + 1 ] + 1 ; } else if ( arr [ i ] == arr [ i + 1 ] && ans [ i ] < ans [ i + 1 ] ) { ans [ i ] = ans [ i + 1 ] + 1 ; } sum += ans [ i ] ; } sum += ans [ n - 1 ] ; return sum ; }
void findMinOperations ( int arr [ ] , int N , int K ) { int operations = 0 ; for ( int i = 0 ; i < K ; i ++ ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int j = i ; j < N ; j += K ) { if ( freq . containsKey ( arr [ j ] ) ) { freq . put ( arr [ j ] , freq . get ( arr [ j ] ) + 1 ) ; } else { freq . put ( arr [ j ] , 1 ) ; } } int max1 = 0 , num = 0 ; for ( Map . Entry < Integer , Integer > x : freq . entrySet ( ) ) { if ( x . getValue ( ) > max1 ) { max1 = x . getValue ( ) ; num = x . getKey ( ) ; } } for ( Map . Entry < Integer , Integer > x : freq . entrySet ( ) ) { if ( x . getKey ( ) != num ) operations += x . getValue ( ) ; } } System . out . println ( operations ) ; }
void minSizeArr ( int A [ ] , int N , int K ) { int leftTaken = N , rightTaken = N ; int leftSum = 0 , rightSum = 0 ; for ( int left = - 1 ; left < N ; left ++ ) { if ( left != - 1 ) leftSum += A [ left ] ; rightSum = 0 ; for ( int right = N - 1 ; right > left ; right -- ) { rightSum += A [ right ] ; if ( leftSum + rightSum == K ) { if ( leftTaken + rightTaken > ( left + 1 ) + ( N - right ) ) { leftTaken = left + 1 ; rightTaken = N - right ; } break ; } if ( leftSum + rightSum > K ) break ; } } if ( leftTaken + rightTaken <= N ) { for ( int i = 0 ; i < leftTaken ; i ++ ) System . out . print ( A [ i ] + " " ) ; for ( int i = 0 ; i < rightTaken ; i ++ ) System . out . print ( A [ N - i - 1 ] + " " ) ; } else System . out . print ( - 1 ) ; }
boolean is_prime ( long n ) { if ( n == 1 ) { return false ; } for ( long i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
void consecutive_primes ( int n ) { long first = - 1 , second = - 1 ; for ( long i = ( long ) Math . sqrt ( n ) ; i >= 2 ; i -- ) { if ( is_prime ( i ) ) { first = i ; break ; } } for ( long i = ( long ) Math . sqrt ( n ) + 1 ; i <= n / 2 ; i ++ ) { if ( is_prime ( i ) ) { second = i ; break ; } } if ( first * second >= n ) { System . out . println ( first + " " + second ) ; } else { for ( long i = second + 1 ; i <= n ; i ++ ) { if ( is_prime ( i ) ) { System . out . println ( second + " " + i ) ; return ; } } } }
void arrayBitwiseAND ( int size ) { int result = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int temp = prefixCount [ i ] [ size - 1 ] ; if ( temp == size ) result = ( result | ( 1 << i ) ) ; } System . out . print ( result + " " ) ; }
void findbitwiseAND ( int [ ] [ ] queries , int [ ] arr , int N , int M ) { findPrefixCount ( arr , N ) ; for ( int i = 0 ; i < M ; i ++ ) { int id = queries [ i ] [ 0 ] ; int newVal = queries [ i ] [ 1 ] ; int currentVal = arr [ id ] ; arr [ id ] = newVal ; applyQuery ( currentVal , newVal , N ) ; arrayBitwiseAND ( N ) ; } }
int stepscount ( int a , int b ) { int chanceA = 2 * a - 1 ; int chanceB = 2 * b ; if ( chanceA < chanceB ) { System . out . print ( "B" ) ; } else if ( chanceB < chanceA ) { System . out . print ( "A" ) ; } return 0 ; }
void checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( int ) ( Math . pow ( ( x - h ) , 2 ) / Math . pow ( a , 2 ) ) - ( ( int ) Math . pow ( ( y - k ) , 2 ) / Math . pow ( b , 2 ) ) ; if ( p > 1 ) { System . out . println ( "Outside" ) ; } else if ( p == 1 ) { System . out . println ( "On the Hyperbola" ) ; } else { System . out . println ( "Inside" ) ; } }
void rotateString ( int n , int m , String s ) { Vector < Integer > v = new Vector < Integer > ( ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) { v . add ( i ) ; } } for ( int i = 1 ; i < ( int ) v . size ( ) ; i ++ ) { if ( ( v . get ( i ) - v . get ( i - 1 ) - 1 ) > m ) { cnt ++ ; } } if ( v . size ( ) >= 2 && ( n - ( v . get ( v . size ( ) - v . get ( 0 ) ) - 1 ) > m ) { cnt ++ ; } if ( cnt <= 1 ) { System . out . print ( "Yes" ) ; } else { System . out . print ( "No" ) ; } }
int findNumber ( int N ) { int [ ] ans = { 1 , 2 , 4 , 8 , 7 , 5 } ; return ans [ N % 6 ] ; }
void countDecrements ( long arr [ ] [ ] ) { int count_1 = 0 ; int count_2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_1 ++ ; if ( 1 - ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_2 ++ ; } } System . out . print ( Math . min ( count_1 , count_2 ) ) ; }
void maximumIndex ( int N , int B ) { int i = 0 , j = 1 ; int cnt = 0 ; int sum = N * ( N + 1 ) / 2 ; boolean flag = false ; while ( cnt < N ) { i += j ; j ++ ; cnt ++ ; if ( i == B ) { flag = true ; break ; } } if ( ! flag ) { System . out . println ( sum ) ; } else System . out . println ( sum - 1 ) ; }
int sumOfDigits ( int N ) { int sum = 0 ; while ( N != 0 ) { sum += N % 10 ; N /= 10 ; } return sum ; }
int distIntegers ( int L , int R ) { return 2 * R - 2 * L + 1 ; }
long maximumNum ( long X , long Y , long N ) { long num = 0 ; if ( N - N % X + Y <= N ) { num = N - N % X + Y ; } else { num = N - N % X - ( X - Y ) ; } return num ; }
void findKthElement ( int N , int K ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { v . add ( i ) ; } } for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 != 0 ) { v . add ( i ) ; } } System . out . print ( v . get ( K - 1 ) ) ; }
void printLargestDivisible ( int arr [ ] , int N ) { int i , count0 = 0 , count7 = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) count0 ++ ; else count7 ++ ; } if ( count7 % 50 == 0 ) { while ( count7 -- > 0 ) System . out . print ( 7 ) ; while ( count0 -- > 0 ) System . out . print ( 0 ) ; } else if ( count7 < 5 ) { if ( count0 == 0 ) System . out . print ( "No" ) ; else System . out . print ( "0" ) ; } else { count7 = count7 - count7 % 5 ; while ( count7 -- > 0 ) System . out . print ( 7 ) ; while ( count0 -- > 0 ) System . out . print ( 0 ) ; } }
int minimumStepReqArr ( int arr [ ] , int N ) { int cntStep = 0 ; N += 1 ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( ( N & ( 1 << i ) ) != 0 ) { cntStep += 1 ; } } return cntStep ; }
void minOpsToEmptyString ( String S , int N ) { int one = 0 , zero = 0 ; int x0 = 0 , x1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == '0' ) { x0 ++ ; x1 = 0 ; } else { x1 ++ ; x0 = 0 ; } zero = Math . max ( x0 , zero ) ; one = Math . max ( x1 , one ) ; } System . out . println ( Math . max ( one , zero ) ) ; }
int findMaxValByRearrArr ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int res = 0 ; do { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += __gcd ( i + 1 , arr [ i ] ) ; } res = Math . max ( res , sum ) ; } while ( next_permutation ( arr ) ) ; return res ; }
int cntKnightsAttackPawn ( int knights [ ] [ ] , int pawn [ ] , int M ) { int cntKnights = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int X = Math . abs ( knights [ i ] [ 0 ] - pawn [ 0 ] ) ; int Y = Math . abs ( knights [ i ] [ 1 ] - pawn [ 1 ] ) ; if ( ( X == 1 && Y == 2 ) || ( X == 2 && Y == 1 ) ) { cntKnights ++ ; } } return cntKnights ; }
int findXOR ( int n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; } return 0 ; }
void findMinimumTime ( int [ ] p , int n , int target ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( um . containsKey ( p [ i ] ) ) um . put ( p [ i ] , um . get ( p [ i ] ) + 1 ) ; else um . put ( p [ i ] , 1 ) ; } int time = 0 ; int sum = 0 ; while ( sum < target ) { sum = 0 ; time ++ ; for ( Map . Entry < Integer , Integer > it : um . entrySet ( ) ) { sum += it . getValue ( ) * ( time / it . getKey ( ) ) ; } } System . out . println ( time ) ; }
void isSequenceValid ( int [ ] B , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( ( i + 1 ) % B [ i ] != 0 ) { System . out . println ( "No" ) ; return ; } } System . out . println ( "Yes" ) ; }
void Remove_one_element ( int arr [ ] , int n ) { int post_odd = 0 , post_even = 0 ; int curr_odd = 0 , curr_even = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 1 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; int X = curr_odd ^ post_even ; int Y = curr_even ^ post_odd ; if ( X == Y ) res ++ ; if ( i % 2 == 1 ) curr_odd ^= arr [ i ] ; else curr_even ^= arr [ i ] ; } System . out . println ( res ) ; }
int findLongestNonDecreasing ( int A [ ] , int N ) { int res = 0 ; int start = 0 ; int end = N - 1 ; int prev = - 1 ; while ( start <= end ) { if ( A [ start ] <= A [ end ] ) { if ( prev == - 1 ) { prev = A [ start ] ; res ++ ; start ++ ; } else { if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else { break ; } } } else { if ( prev == - 1 ) { prev = A [ end ] ; res ++ ; end -- ; } else { if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else { break ; } } } } return res ; }
int countPairs ( int arr [ ] , int N ) { int cntPairs = 0 ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } for ( Map . Entry < Integer , Integer > freq : mp . entrySet ( ) ) { cntPairs += ( freq . getValue ( ) * ( freq . getValue ( ) - 1 ) ) / 2 ; } return cntPairs ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int minAbsDiff ( int N ) { int sumSet1 = 0 ; int sumSet2 = 0 ; for ( int i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return Math . abs ( sumSet1 - sumSet2 ) ; }
int countPairs ( int arr [ ] , int n ) { int oneCount = 0 ; int desiredPair = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) { oneCount ++ ; } if ( arr [ i ] == 0 ) { desiredPair += oneCount ; } } return desiredPair ; }
int TotalNumber ( int N ) { int ans = ( power ( 10 , N ) - 2 * power ( 9 , N ) + power ( 8 , N ) + 2 * mod ) % mod ; return ans ; }
int minLength ( int A [ ] , int N ) { int elem = A [ 0 ] , count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( A [ i ] == elem ) { count ++ ; } else { break ; } } if ( count == N ) return N ; else return 1 ; }
boolean NegEqu ( int N , int X , int Y ) { while ( X -- > 0 && N > N / 2 + 10 ) { N = N / 2 + 10 ; } while ( Y -- > 0 ) { N = N - 10 ; } if ( N <= 0 ) return true ; return false ; }
int minSubarrays ( int arr [ ] , int n ) { int right = n - 1 ; int left = 0 ; int subarrays = 0 ; while ( right >= 0 ) { for ( left = 0 ; left <= right ; left += 1 ) { if ( gcd ( arr [ left ] , arr [ right ] ) > 1 ) { subarrays += 1 ; right = left - 1 ; break ; } if ( left == right && gcd ( arr [ left ] , arr [ right ] ) == 1 ) { return 0 ; } } } return subarrays ; }
boolean check ( int arr [ ] , int N ) { boolean f = false ; for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { count ++ ; } } if ( count >= 2 ) { f = true ; break ; } } if ( f == true ) return true ; else return false ; }
int no_of_flips ( int n ) { int len = check_length ( n ) ; int ans = 0 ; int right = 1 ; int left = len ; while ( right < left ) { if ( check_ith_bit ( n , right ) != check_ith_bit ( n , left ) ) ans ++ ; left -- ; right ++ ; } return ans ; }
int find_max ( pair v [ ] , int n ) { int count = 0 ; if ( n >= 2 ) count = 2 ; else count = 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( v [ i - 1 ] . first < ( v [ i ] . first - v [ i ] . second ) ) count ++ ; else if ( v [ i + 1 ] . first > ( v [ i ] . first + v [ i ] . second ) ) { count ++ ; v [ i ] . first = v [ i ] . first + v [ i ] . second ; } else continue ; } return count ; }
void createString ( int N ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( 'a' ) ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( 'b' ) ; } }
int maxSubsequences ( int arr [ ] , int n ) { Map < Integer , Integer > m = new HashMap < > ( ) ; int maxCount = 0 ; int count ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { count = m . get ( arr [ i ] ) ; if ( count > 1 ) { m . put ( arr [ i ] , count - 1 ) ; } else m . remove ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) m . put ( arr [ i ] - 1 , m . get ( arr [ i ] - 1 ) + 1 ) ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) m . put ( arr [ i ] - 1 , m . get ( arr [ i ] - 1 ) + 1 ) ; } } return maxCount ; }
long sumOfFactors ( int N ) { long ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { long first = i ; long last = ( N / i ) * i ; long factors = ( last - first ) / i + 1 ; long totalContribution = ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += totalContribution ; } return ans ; }
void findShifts ( int A [ ] , int N ) { int shift [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( shift [ i ] + " " ) ; }
boolean possible ( int N , int a , int b , int n ) { int sum_of_angle = 180 * ( N - 2 ) ; int Total_angle = ( N * ( ( 2 * a ) + ( N - 1 ) * b ) ) / 2 ; if ( sum_of_angle != Total_angle ) return false ; else return true ; }
boolean splitIntoFibonacciHelper ( int pos , String S , ArrayList < Integer > seq ) { if ( pos == S . length ( ) && ( seq . size ( ) >= 3 ) ) { return true ; } int num = 0 ; for ( int i = pos ; i < S . length ( ) ; i ++ ) { num = num * 10 + ( S . charAt ( i ) - '0' ) ; if ( num > Integer . MAX_VALUE ) break ; if ( S . charAt ( pos ) == '0' && i > pos ) break ; if ( seq . size ( ) > 2 && ( num > ( ( int ) seq . get ( seq . size ( ) - 2 ) ) ) ) break ; if ( seq . size ( ) < 2 || ( num == ( ( int ) seq . get ( seq . size ( ) - 2 ) ) ) ) { seq . add ( num ) ; if ( splitIntoFibonacciHelper ( i + 1 , S , seq ) ) return true ; seq . remove ( seq . size ( ) - 1 ) ; } } return false ; }
int good_pairs ( String str [ ] , int N ) { int [ ] arr = new int [ 32 ] ; int strCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int Weight = 0 ; for ( int j = 0 ; j < str [ i ] . length ( ) ; j ++ ) { switch ( str [ i ] . charAt ( j ) ) { case 'a' : Weight = Weight | 1 ; break ; case 'e' : Weight = Weight | 2 ; break ; case 'i' : Weight = Weight | 4 ; break ; case 'o' : Weight = Weight | 8 ; break ; case 'u' : Weight = Weight | 16 ; break ; } } arr [ Weight ] ++ ; } for ( int i = 0 ; i < 32 ; i ++ ) { for ( int j = i + 1 ; j < 32 ; j ++ ) { if ( ( i j ) == 31 ) strCount += arr [ i ] * arr [ j ] ; } } strCount += ( arr [ 31 ] * ( arr [ 31 ] - 1 ) ) / 2 ; return strCount ; }
int countUniqueDigits ( int N ) { int res = 0 ; int cnt [ ] = new int [ 10 ] ; while ( N > 0 ) { int rem = N % 10 ; cnt [ rem ] ++ ; N = N / 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( cnt [ i ] == 1 ) { res ++ ; } } return res ; }
void DFS ( int node , int parent ) { answer [ node ] = val [ node ] ; for ( Integer child : v . get ( node ) ) { if ( child == parent ) continue ; DFS ( child , node ) ; answer [ node ] = gcd ( answer [ node ] , answer [ child ] ) ; } }
int count_triangles ( int a , int b , int c , int d ) { int ans = 0 ; for ( int x = a ; x <= b ; ++ x ) { int num_greater_than_d = Math . max ( d , c + x ) - Math . max ( d , b + x - 1 ) ; ans += num_greater_than_d * ( d - c + 1 ) ; int r = Math . min ( Math . max ( c , c + x ) , d ) - c ; int l = Math . min ( Math . max ( c , b + x - 1 ) , d ) - c ; int x1 = ( r * ( r + 1 ) ) / 2 ; int x2 = ( l * ( l + 1 ) ) / 2 ; ans += x1 - x2 ; } return ans ; }
int maxRemainingSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int i = 0 ; int j = n - 1 ; int result = 0 ; while ( i < j ) { if ( arr [ i ] < arr [ j ] ) { sum -= arr [ i ] ; i ++ ; } else { sum -= arr [ j ] ; j -- ; } result += sum ; } return result ; }
boolean check ( int arr [ ] , int n ) { boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < n - i ) { flag = false ; } } if ( flag ) { return true ; } else { return false ; } }
int minOperations ( int a [ ] , int b [ ] , int n ) { int minA = Arrays . stream ( a ) . min ( ) . getAsInt ( ) ; for ( int x = minA ; x >= 0 ; x -- ) { boolean check = true ; int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = false ; break ; } } if ( check ) return operations ; } return - 1 ; }
int largestNum ( int n ) { int num = 0 ; for ( int i = 0 ; i <= 32 ; i ++ ) { int x = ( 1 << i ) ; if ( ( x - 1 ) <= n ) num = ( 1 << i ) - 1 ; else break ; } return num ; }
int digit_xor ( int x ) { int xorr = 0 ; while ( x != 0 ) { xorr ^= x % 10 ; x = x / 10 ; } return xorr ; }
int maxSum ( int a [ ] , int n ) { int S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S += a [ i ] ; int X = maxSubArraySum ( a , n ) ; return 2 * X - S ; }
void Transform ( int n , int d , int steps ) { if ( n < min_val ) { min_val = n ; min_steps = steps ; } else if ( n == min_val ) { min_steps = Math . min ( min_steps , steps ) ; } if ( steps < 15 ) { Transform ( sumOfDigits ( n ) , d , steps + 1 ) ; Transform ( n + d , d , steps + 1 ) ; } }
void addEdge ( ArrayList < ArrayList < Integer > > adj , int u , int v ) { adj . get ( u ) . add ( v ) ; adj . get ( v ) . add ( u ) ; }
int minCost ( int cost [ ] , int n ) { int totalCost = 0 ; int boardingBus = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; }
int findK ( int n , int k ) { int pos ; if ( ( n % 2 ) == 0 ) { pos = n / 2 ; } else { pos = ( n / 2 ) + 1 ; } if ( k <= pos ) { return ( k * 2 - 1 ) ; } else return ( ( k - pos ) * 2 ) ; }
int max_bitwise_or ( int L , int R ) { Vector < Integer > v1 = new Vector < Integer > ( ) ; Vector < Integer > v2 = new Vector < Integer > ( ) ; Vector < Integer > v3 = new Vector < Integer > ( ) ; int z = 0 , i , ans = 0 , cnt = 1 ; while ( L > 0 ) { v1 . add ( L % 2 ) ; L = L / 2 ; } while ( R > 0 ) { v2 . add ( R % 2 ) ; R = R / 2 ; } while ( v1 . size ( ) != v2 . size ( ) ) { v1 . add ( 0 ) ; } for ( i = v2 . size ( ) - 1 ; i >= 0 ; i -- ) { if ( v2 . get ( i ) == 1 && v1 . get ( i ) == 0 && z == 0 ) { z = 1 ; continue ; } if ( z == 1 ) { v1 . set ( i , 1 ) ; } } for ( i = 0 ; i < v2 . size ( ) ; i ++ ) { v3 . add ( v2 . get ( i ) v1 . get ( i ) ) ; } for ( i = 0 ; i < v2 . size ( ) ; i ++ ) { if ( v3 . get ( i ) == 1 ) { ans += cnt ; } cnt *= 2 ; } return ans ; }
int ncr ( int n , int r , int mod ) { long res = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { res = ( res * ( n - i + 1 ) ) % mod ; int inv = power ( i , mod - 2 , mod ) ; res = ( res * inv ) % mod ; } return ( int ) ( res % mod ) ; }
int solve ( int Array [ ] , int N ) { Vector < Integer > [ ] pos = new Vector [ 5 ] ; int [ ] pref = new int [ 5 ] ; if ( Array [ 0 ] == 0 ) { pref [ 0 ] = 1 ; pos [ 0 ] . add ( 0 ) ; } int ans = MAX_INT ; for ( int i = 1 ; i < N ; i ++ ) { if ( Array [ i ] == 0 ) { pref [ 0 ] ++ ; pos [ 0 ] . add ( i ) ; } else { if ( pref [ Array [ i ] - 1 ] > 0 ) { pref [ Array [ i ] ] ++ ; pos [ Array [ i ] ] . add ( i ) ; if ( Array [ i ] == 4 ) { int end = i ; int start = i ; for ( int j = 3 ; j >= 0 ; j -- ) { int s = 0 ; int e = pos [ j ] . size ( ) - 1 ; int temp = - 1 ; while ( s <= e ) { int m = ( s + e ) / 2 ; if ( pos [ j ] . get ( m ) <= start ) { temp = pos [ j ] . get ( m ) ; s = m + 1 ; } else { e = m - 1 ; } } start = temp ; } ans = Math . min ( ans , end - start + 1 ) ; } } } } return ans ; }
Vector < Integer > solve ( int X , int [ ] A ) { int min = Integer . MAX_VALUE ; int ind = - 1 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] < min ) { min = A [ i ] ; ind = i ; } } int maxIndChosen = X / min ; Vector < Integer > ans = new Vector < Integer > ( ) ; if ( maxIndChosen == 0 ) { return ans ; } for ( int i = 0 ; i < maxIndChosen ; i ++ ) { ans . add ( ind ) ; } int temp = maxIndChosen ; int sum = maxIndChosen * A [ ind ] ; for ( int i = 0 ; i < ind ; i ++ ) { if ( sum - X == 0 temp == 0 ) break ; while ( ( sum - A [ ind ] + A [ i ] ) <= X && temp != 0 ) { ans . remove ( ans . size ( ) - 1 ) ; ans . add ( i ) ; temp -- ; sum += ( A [ i ] - A [ ind ] ) ; } } Collections . sort ( ans ) ; return ans ; }
boolean CheckForSequence ( int arr [ ] , int n , int k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( k >= arr [ i ] ) k -= arr [ i ] ; } if ( k != 0 ) return false ; else return true ; }
int reverse ( int n ) { int rev = 0 ; while ( n != 0 ) { rev = ( rev * 10 ) + ( n % 10 ) ; n /= 10 ; } return rev ; }
int countJumps ( int n ) { n = Math . abs ( n ) ; int ans = 0 ; while ( getsum ( ans ) < n || ( getsum ( ans ) - n ) & 1 ) ans ++ ; return ans ; }
int steps ( int cur , int x , int n ) { if ( x == 0 ) return Integer . MAX_VALUE ; if ( x > 0 ) return Math . abs ( ( n - cur ) / x ) ; else return Math . abs ( ( cur - 1 ) / x ) ; }
void find_rectangle ( int area ) { int l = 0 , b = 0 ; int M = ( int ) Math . sqrt ( area ) , ans ; for ( int i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = ( area / i ) ; b = i ; break ; } } System . out . println ( "l = " + l + ", b = " + b ) ; }
int countMinSwaps ( String st ) { int min_swaps = 0 ; int odd_0 = 0 , even_0 = 0 ; int odd_1 = 0 , even_1 = 0 ; int n = st . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( st . charAt ( i ) == '1' ) even_1 ++ ; else even_0 ++ ; } else { if ( st . charAt ( i ) == '1' ) odd_1 ++ ; else odd_0 ++ ; } } int cnt_swaps_1 = Math . min ( even_0 , odd_1 ) ; int cnt_swaps_2 = Math . min ( even_1 , odd_0 ) ; return Math . min ( cnt_swaps_1 , cnt_swaps_2 ) ; }
int problemsLeft ( int K , int P , int N ) { if ( K <= P ) return 0 ; else return ( K - P ) * N ; }
boolean isCorrectOrder ( int n ) { boolean flag = true ; int prev = - 1 ; int type = - 1 ; while ( n != 0 ) { if ( type == - 1 ) { if ( prev == - 1 ) { prev = n % 10 ; n = n / 10 ; continue ; } if ( prev == n % 10 ) { flag = false ; break ; } if ( prev > n % 10 ) { type = 1 ; prev = n % 10 ; n = n / 10 ; continue ; } prev = n % 10 ; n = n / 10 ; } else { if ( prev == n % 10 ) { flag = false ; break ; } if ( prev < n % 10 ) { flag = false ; break ; } prev = n % 10 ; n = n / 10 ; } } return flag ; }
int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; Arrays . sort ( arr ) ; M = Math . max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
int MinimumRemovals ( int a [ ] , int N , int K ) { int [ ] b = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { b [ i + 1 ] = a [ i ] ; } int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { dp [ i + 1 ] [ j ] = Math . max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] ) ; dp [ i + 1 ] [ j + 1 ] = Math . max ( dp [ i + 1 ] [ j + 1 ] , dp [ i ] [ j ] + ( ( b [ i + 1 ] == j + 1 ) ? 1 : 0 ) ) ; } } for ( int j = N ; j >= 0 ; j -- ) { if ( dp [ N ] [ j ] >= K ) { return ( N - j ) ; } } return - 1 ; }
int countOfNumbers ( int digit , int mask , boolean repeated , int n ) { if ( digit == n + 1 ) { if ( repeated == true ) { return 1 ; } return 0 ; } if ( repeated == true ) { return ( int ) Math . pow ( 10 , n - digit + 1 ) ; } int val = dp [ digit ] [ mask ] [ repeated ] ; if ( val != - 1 ) { return val ; } val = 0 ; if ( digit == 1 ) { for ( int i = ( n == 1 ? 0 : 1 ) ; i <= 9 ; ++ i ) { if ( ( mask & ( 1 << i ) ) != 0 ) { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 1 , n ) ; } else { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 0 , n ) ; } } } else { for ( int i = 0 ; i <= 9 ; ++ i ) { if ( ( mask & ( 1 << i ) ) != 0 ) { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 1 , n ) ; } else { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 0 , n ) ; } } } return val ; }
long power ( long x , long y , long p ) { long res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
void maxBoundary ( int N , int [ ] [ ] V ) { int [ ] [ ] dp = new int [ N ] [ 2 ] ; dp [ 0 ] [ 0 ] = V [ 0 ] [ 0 ] ; dp [ 0 ] [ 1 ] = V [ 0 ] [ 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = V [ i ] [ 0 ] ; int height1 = Math . abs ( V [ i - 1 ] . second - V [ i ] . second ) ; int height2 = Math . abs ( V [ i - 1 ] . first - V [ i ] . second ) ; dp [ i ] [ 0 ] += Math . max ( height1 + dp [ i - 1 ] [ 0 ] , height2 + dp [ i - 1 ] [ 1 ] ) ; dp [ i ] [ 1 ] = V [ i ] [ second ; int vertical1 = Math . abs ( V [ i ] . first - V [ i - 1 ] . second ) ; int vertical2 = Math . abs ( V [ i ] . first - V [ i - 1 ] . first ) ; dp [ i ] [ 1 ] += Math . max ( vertical1 + dp [ i - 1 ] [ 0 ] , vertical2 + dp [ i - 1 ] [ 1 ] ) ; } System . out . print ( Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ) ; }
int findMinOperations ( int n ) { int i , dp [ ] = new int [ n + 1 ] ; for ( i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = 999999 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i < n + 1 ; i ++ ) { if ( i * 5 <= n ) { dp [ i * 5 ] = Math . min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= n ) { dp [ i + 3 ] = Math . min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } return dp [ n ] ; }
int solve ( int A [ ] , int N , int K ) { int sum = 0 ; int c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( A [ i ] == 0 ) c ++ ; } if ( K > sum || ( sum + K ) % 2 != 0 ) return 0 ; sum = ( sum + K ) / 2 ; int dp [ ] [ ] = new int [ N + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= sum ; i ++ ) dp [ 0 ] [ i ] = 0 ; for ( int i = 0 ; i <= N ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( A [ i - 1 ] <= j && A [ i - 1 ] != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - A [ i - 1 ] ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ N ] [ sum ] + ( int ) Math . pow ( 2 , c ) ; }
int countSortedArrays ( int start , int m , int size , int n ) { if ( size == m ) return 1 ; if ( start > n ) return 0 ; int notTaken = 0 , taken = 0 ; taken = countSortedArrays ( start , m , size + 1 , n ) ; notTaken = countSortedArrays ( start + 1 , m , size , n ) ; return taken + notTaken ; }
int getValue ( int arr [ ] , int N ) { int dp [ ] = new int [ N ] ; Arrays . fill ( dp , 0 ) ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { int minn = arr [ i ] ; int maxx = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { minn = Math . min ( arr [ j ] , minn ) ; maxx = Math . max ( arr [ j ] , maxx ) ; dp [ i ] = Math . max ( dp [ i ] , maxx - minn + ( ( j >= 1 ) ? dp [ j - 1 ] : 0 ) ) ; } } return dp [ N - 1 ] ; }
int maxScore ( String s , int [ ] a ) { if ( dp . containsKey ( s ) ) return dp . get ( s ) ; int n = s . length ( ) ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; int head = 0 ; int mx = - 1 ; while ( head < n ) { int tail = head ; while ( tail < n ) { if ( s . charAt ( tail ) != s . charAt ( head ) ) { head = tail ; break ; } String sub = s . substring ( head , tail + 1 ) ; mx = Math . max ( mx , a [ sub . length ( ) - 1 ] + maxScore ( s . substring ( 0 , head ) + s . substring ( tail + 1 , s . length ( ) ) , a ) ) ; tail += 1 ; } if ( tail == n ) break ; } dp . put ( s , mx ) ; return mx ; }
int minSumDifference ( int [ ] arr , int n , int k1 , int k2 , int sum1 , int sum2 ) { if ( n < 0 ) { if ( k1 == 0 && k2 == 0 ) { return Math . abs ( sum1 - sum2 ) ; } else { return Integer . MAX_VALUE ; } } if ( dp [ n ] [ sum1 ] [ sum2 ] != - 1 ) { return dp [ n ] [ sum1 ] [ sum2 ] ; } int op1 = Integer . MAX_VALUE ; int op2 = Integer . MAX_VALUE ; int op3 = Integer . MAX_VALUE ; if ( k1 > 0 ) { op1 = minSumDifference ( arr , n - 1 , k1 - 1 , k2 , sum1 + arr [ n ] , sum2 ) ; } if ( k2 > 0 ) { op2 = minSumDifference ( arr , n - 1 , k1 , k2 - 1 , sum1 , sum2 + arr [ n ] ) ; } op3 = minSumDifference ( arr , n - 1 , k1 , k2 , sum1 , sum2 ) ; dp [ n ] [ sum1 ] [ sum2 ] = Math . min ( op1 , Math . min ( op2 , op3 ) ) ; return dp [ n ] [ sum1 ] [ sum2 ] ; }
void insertVector ( int mask ) { for ( int i = 0 ; i < 20 ; i ++ ) { if ( ( mask & 1 << i ) == 0 ) continue ; if ( dp [ i ] == 0 ) { dp [ i ] = mask ; ++ ans ; return ; } mask ^= dp [ i ] ; } }
int cntNumRange ( int L , int R , int K ) { int cnt = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( prodOfDigit ( i ) == K ) { cnt ++ ; } } return cnt ; }
void findSubtreeORUtil ( int N , int Edges [ ] [ ] , int Val [ ] , int Queries [ ] , int Q ) { addEdgesToGraph ( Edges , N ) ; findSubtreeOR ( Queries , Q , Val ) ; }
int findMinimum ( int a [ ] , int n , int pos , int myturn ) { if ( m . containsKey ( new Point ( pos , myturn ) ) ) { return m . get ( new Point ( pos , myturn ) ) ; } if ( pos >= n ) { return 0 ; } if ( myturn == 0 ) { int ans = Math . min ( findMinimum ( a , n , pos + 1 , ! myturn ) + a [ pos ] , findMinimum ( a , n , pos + 2 , ! myturn ) + a [ pos ] + a [ pos + 1 ] ) ; m . put ( new Point ( pos , myturn ) , ans ) ; return ans ; } if ( myturn == 1 ) { int ans = Math . min ( findMinimum ( a , n , pos + 1 , ! myturn ) , findMinimum ( a , n , pos + 2 , ! myturn ) ) ; m . put ( new Point ( pos , myturn ) , ans ) ; return ans ; } return 0 ; }
int countVowelStrings ( int n ) { return countstrings ( n , 0 ) ; }
void maxSum ( int [ ] [ ] arr , int n , int m ) { int [ ] [ ] dp = new int [ n ] ; for ( int i = 0 ; i < 2 ; i ++ ) { dp [ i ] = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ m - 1 ] = arr [ 0 ] [ m - 1 ] ; dp [ 1 ] [ m - 1 ] = arr [ 1 ] [ m - 1 ] ; for ( int j = m - 2 ; j >= 0 ; j -- ) { for ( int i = 0 ; i < 2 ; i ++ ) { if ( i == 1 ) { dp [ i ] [ j ] = Math . max ( arr [ i ] [ j ] + dp [ 0 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 0 ] [ j + 2 ] ) ; } else { dp [ i ] [ j ] = Math . max ( arr [ i ] [ j ] + dp [ 1 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 1 ] [ j + 2 ] ) ; } } } System . out . print ( Math . max ( dp [ 0 ] [ 0 ] , dp [ 1 ] [ 0 ] ) ) ; }
int findMaxGCD ( int arr [ ] , int N ) { int high = 0 ; for ( int i = 0 ; i < N ; i ++ ) { high = Math . max ( high , arr [ i ] ) ; } int count [ ] = new int [ high + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { count [ arr [ i ] ] += 1 ; } int counter = 0 ; for ( int i = high ; i > 0 ; i -- ) { int j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } return - 1 ; }
int findLCS ( int [ ] nums , int N ) { int k = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int pos = lowerBound ( nums , k , nums [ i ] ) ; nums [ pos ] = nums [ i ] ; if ( k == pos ) { k = pos + 1 ; } } return k ; }
boolean check ( int mask , int i ) { int c = ( mask & ( 1 << i ) ) ; return c != 0 ; }
int minSteps ( int m , int n ) { if ( n == m ) return 0 ; if ( m > n ) return inf ; int min_cost = inf ; for ( int i = 2 ; i < m ; i += 2 ) { if ( m % i == 0 ) { min_cost = Math . min ( min_cost , m / i + minSteps ( m + i , n ) ) ; } } return min_cost ; }
void checkEqualSum ( int arr [ ] , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
void queries_fxn ( long [ ] [ ] matrix , long [ ] [ ] queries ) { for ( long q : queries ) manipulation ( matrix , q ) ; }
void countNums ( int N ) { int dp [ ] [ ] = new int [ N ] [ 16 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { for ( int k = 0 ; k < 16 ; k ++ ) { int xo = j ^ k ; dp [ i ] [ xo ] += dp [ i - 1 ] [ k ] ; } } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ N - 1 ] [ i ] ; System . out . println ( count ) ; }
int constructSTUtil ( int arr [ ] , int ss , int se , int [ ] st , int si ) { if ( ss == se ) { if ( prime [ arr [ ss ] ] ) st [ si ] = arr [ ss ] ; else st [ si ] = 0 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ; return st [ si ] ; }
void dfs ( int a , int par ) { boolean leaf = true ; for ( pair i : v . get ( a ) ) { if ( i . first == par ) continue ; leaf = false ; dfs ( i . first , a ) ; } if ( leaf == true ) { leaves [ a ] += 1 ; } else { for ( pair i : v . get ( a ) ) { if ( i . first == par ) continue ; leaves [ a ] += leaves [ i . first ] ; dp [ a ] = dp [ a ] + dp [ i . first ] + leaves [ i . first ] * i . second ; } } }
int getCount ( int n , int k ) { if ( n == 1 ) return 10 ; int dp [ ] = new int [ 11 ] ; int next [ ] = new int [ 11 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { int l = Math . max ( 0 , ( j - k ) ) ; int r = Math . min ( 9 , ( j + k ) ) ; next [ l ] += dp [ j ] ; next [ r + 1 ] -= dp [ j ] ; } for ( int j = 1 ; j <= 9 ; j ++ ) next [ j ] += next [ j - 1 ] ; for ( int j = 0 ; j < 10 ; j ++ ) { dp [ j ] = next [ j ] ; next [ j ] = 0 ; } } int count = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) count += dp [ i ] ; return count ; }
int nCrModp ( int n , int r ) { if ( n % 2 == 1 ) { return - 1 ; } int C [ ] = new int [ r + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % MOD ; } return C [ r ] ; }
void findResult ( int arr [ ] , int n , Query q [ ] , int m ) { for ( int i = 0 ; i < m ; i ++ ) { System . out . print ( findResultUtil ( arr , q [ i ] . L , q [ i ] . R ) + " " ) ; } }
void insert ( int idx , String s , TrieNode root ) { TrieNode temp = root ; for ( int i = idx ; i < s . length ( ) ; i ++ ) { if ( temp . child [ s . charAt ( i ) - 'a' ] == null ) temp . child [ s . charAt ( i ) - 'a' ] = new TrieNode ; temp = temp . child [ s . charAt ( i ) - 'a' ] ; } }
int minCuts ( String S1 , String S2 ) { int n1 = S1 . length ( ) ; int n2 = S2 . length ( ) ; TrieNode root = new TrieNode ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) { insert ( i , S2 , root ) ; } int [ ] dp = new int [ n1 + 1 ] ; Arrays . fill ( dp , INF ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { TrieNode temp = root ; for ( int j = i + 1 ; j <= n1 ; j ++ ) { if ( temp . child [ S1 . charAt ( j - 1 ) - 'a' ] == null ) break ; dp [ j ] = Math . min ( dp [ j ] , dp [ i ] + 1 ) ; temp = temp . child [ S1 . charAt ( j - 1 ) - 'a' ] ; } } if ( dp [ n1 ] >= INF ) return - 1 ; else return dp [ n1 ] ; }
int maximum ( int A , int B , int C , int D ) { return Math . max ( Math . max ( A , B ) , Math . max ( C , D ) ) ; }
void maxSubarraySum ( Vector < Integer > graph [ ] , int vertices , int [ ] values ) { boolean [ ] visited = new boolean [ 1001 ] ; int maxSum = Integer . MIN_VALUE ; for ( int i = 1 ; i <= vertices ; i ++ ) { if ( visited [ i ] == false ) { int sizeChain ; int tempSum ; Vector < Integer > storeChain = new Vector < Integer > ( ) ; depthFirst ( i , graph , visited , storeChain ) ; sizeChain = storeChain . size ( ) ; int [ ] chainValues = new int [ sizeChain + 1 ] ; for ( int i = 0 ; i < sizeChain ; i ++ ) { int temp = values [ storeChain . get ( i ) - 1 ] ; chainValues [ i ] = temp ; } tempSum = subarraySum ( chainValues , sizeChain ) ; if ( tempSum > maxSum ) { maxSum = tempSum ; } } } System . out . print ( "Maximum subarray sum among all " ) ; System . out . print ( "connected components = " ) ; System . out . print ( maxSum ) ; }
int countDecodingDP ( String digits , int n ) { if ( digits . charAt ( 0 ) == '0' ) return 0 ; int count0 = 1 , count1 = 1 , count2 ; for ( int i = 2 ; i <= n ; i ++ ) { count2 = ( ( int ) ( digits . charAt ( i - 1 ) != '0' ) * count1 ) + ( int ) ( ( digits . charAt ( i - 2 ) == '1' ) || ( digits . charAt ( i - 2 ) == '2' && digits . charAt ( i - 1 ) < '7' ) ) * count0 ; count0 = count1 ; count1 = count2 ; } return count1 ; }
int countSubMatrix ( int mtrx [ ] [ ] , int k , int p ) { int dp [ ] [ ] = new int [ dim ] [ dim ] ; for ( int i = 0 ; i < dim ; i ++ ) { for ( int j = 0 ; j < dim ; j ++ ) { dp [ i ] [ j ] = 0 ; } } createTable ( mtrx , k , p , dp ) ; return countSubMatrixUtil ( dp , k , p ) ; }
int f ( int n , int k ) { if ( n < k ) return 0 ; if ( n == k ) return 1 ; if ( k == 1 ) return 1 ; if ( dp [ n ] [ k ] != - 1 ) return dp [ n ] [ k ] ; return dp [ n ] [ k ] = ( ( k * f ( n - 1 , k ) ) % mod + ( f ( n - 1 , k - 1 ) ) % mod ) % mod ; }
boolean checkPrime ( String number ) { int num = Integer . valueOf ( number ) ; for ( int i = 2 ; i * i <= num ; i ++ ) if ( ( num % i ) == 0 ) return false ; return true ; }
int countNumbers ( int n , int k ) { int st = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { powers [ i ] = st ; st *= 10 ; st %= mod ; } st = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { powersModk [ i ] = st ; st *= 10 ; st %= mod ; } for ( int i = 0 ; i < 1000 ; i ++ ) { for ( int j = 0 ; j < 1000 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return calculate ( 0 , 0 , 0 , k , n ) ; }
int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = Math . max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = Math . max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; }
int maxSum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int limit = 2 * sum + 1 ; int [ ] [ ] dp = new int [ n + 1 ] [ limit ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) dp [ i ] [ j ] = Integer . MIN_VALUE ; } dp [ 0 ] [ sum ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) { if ( ( j - a [ i - 1 ] ) >= 0 && dp [ i - 1 ] [ j - a [ i - 1 ] ] != Integer . MIN_VALUE ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ; if ( ( j + a [ i - 1 ] ) < limit && dp [ i - 1 ] [ j + a [ i - 1 ] ] != Integer . MIN_VALUE ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ; if ( dp [ i - 1 ] [ j ] != Integer . MIN_VALUE ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ sum ] ; }
int minSteps ( String str , int n , int k ) { if ( str . charAt ( n - 1 ) == '0' ) return - 1 ; if ( n == 1 ) return 0 ; if ( n < 4 ) return 1 ; int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 0 ; dp [ n - 2 ] = 1 ; dp [ n - 3 ] = 1 ; for ( int i = n - 4 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == '0' ) continue ; int steps = Integer . MAX_VALUE ; if ( i + k < n && str . charAt ( i + k ) == '1' ) steps = Math . min ( steps , dp [ i + k ] ) ; if ( str . charAt ( i + 1 ) == '1' ) steps = Math . min ( steps , dp [ i + 1 ] ) ; if ( str . charAt ( i + 2 ) == '1' ) steps = Math . min ( steps , dp [ i + 2 ] ) ; dp [ i ] = ( steps == Integer . MAX_VALUE ) ? steps : 1 + steps ; } if ( dp [ 0 ] == Integer . MAX_VALUE ) return - 1 ; return dp [ 0 ] ; }
int eggDrop ( int n , int k ) { int [ ] [ ] dp = new int [ k + 1 ] [ n + 1 ] ; int x = 0 ; while ( dp [ x ] [ n ] < k ) { x ++ ; for ( int i = 1 ; i <= n ; i ++ ) dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; } return x ; }
void findMax ( int a [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ 2 ] ; dp [ 0 ] [ 0 ] = a [ 0 ] + a [ 1 ] ; dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 1 ] ; for ( int i = 1 ; i <= n - 2 ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i + 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] ; } System . out . print ( Math . max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] ) ) ; }
double expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] ) return dp [ x ] ; v [ x ] = true ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; }
int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; return dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; }
int ways ( int arr [ ] , int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; }
double Probability ( double p [ ] , int n ) { double dp [ ] [ ] = new double [ n + 1 ] [ n + 1 ] ; dp [ 0 ] [ 0 ] = 1.0 ; for ( int i = 1 ; i <= n ; i += 1 ) { for ( int j = 0 ; j <= i ; j += 1 ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 ] [ j - 1 ] * p [ i ] ; } } double ans = 0.0 ; for ( int i = ( n + 1 ) / 2 ; i <= n ; i += 1 ) ans += dp [ n ] [ i ] ; return ans ; }
int count_required_sequence ( int n , int arr [ ] ) { int total_required_subsequence = 0 ; int total_n_required_subsequence = 0 ; int dp [ ] [ ] = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { int turn_required = 0 ; for ( int j = - 1 ; j <= 1 ; j ++ ) turn_required += dp [ arr [ i ] + j ] [ 0 ] ; int required_end_i = ( total_required_subsequence + turn_required ) ; int n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) ; total_required_subsequence += required_end_i ; total_n_required_subsequence += n_required_end_i ; dp [ arr [ i ] ] [ 1 ] += required_end_i ; dp [ arr [ i ] ] [ 0 ] += n_required_end_i ; } return total_required_subsequence ; }
int recur ( int u , int array [ ] , int n ) { if ( u == 0 ) return 0 ; if ( dp [ u ] != - 1 ) return dp [ u ] ; int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int mask = get_binary ( array [ i ] ) ; if ( ( mask u ) == u ) { dp [ u ] = Math . max ( Math . max ( 0 , dp [ u ^ mask ] ) + array [ i ] , dp [ u ] ) ; } } return dp [ u ] ; }
int solve ( int array [ ] , int n ) { for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { dp [ i ] = - 1 ; } int ans = 0 ; for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { ans = Math . max ( ans , recur ( i , array , n ) ) ; } return ans ; }
int MinDiff ( int i , int sum , int arr [ ] , int n ) { if ( i == n ) return 0 ; if ( visit [ i ] [ sum + MAX ] ) return dp [ i ] [ sum + MAX ] ; visit [ i ] [ sum + MAX ] = true ; dp [ i ] [ sum + MAX ] = RetClose ( arr [ i ] + MinDiff ( i + 1 , sum + arr [ i ] , arr , n ) , MinDiff ( i + 1 , sum , arr , n ) , - 1 * sum ) ; return dp [ i ] [ sum + MAX ] ; }
int minSteps ( int arr [ ] , int i , int mask , int n ) { if ( i == n - 1 ) return 0 ; if ( i > n - 1 i < 0 ) return 9999999 ; if ( ( mask >> i ) & 1 ) return 9999999 ; if ( v [ i ] [ mask ] == 1 ) return dp [ i ] [ mask ] ; v [ i ] [ mask ] = 1 ; dp [ i ] [ mask ] = 1 + Math . min ( minSteps ( arr , i - arr [ i ] , ( mask | ( 1 << i ) ) , n ) , minSteps ( arr , i + arr [ i ] , ( mask | ( 1 << i ) ) , n ) ) ; return dp [ i ] [ mask ] ; }
int maxSumPath ( int i1 , int j1 , int i2 ) { int j2 = i1 + j1 - i2 ; if ( i1 >= n i2 >= n j1 >= m j2 >= m ) { return 0 ; } if ( cache [ i1 ] [ j1 ] [ i2 ] != - 1 ) { return cache [ i1 ] [ j1 ] [ i2 ] ; } int ans = Integer . MIN_VALUE ; ans = Math . max ( ans , maxSumPath ( i1 + 1 , j1 , i2 + 1 ) + sum ( i1 , j1 , i2 , j2 ) ) ; ans = Math . max ( ans , maxSumPath ( i1 , j1 + 1 , i2 ) + sum ( i1 , j1 , i2 , j2 ) ) ; ans = Math . max ( ans , maxSumPath ( i1 , j1 + 1 , i2 + 1 ) + sum ( i1 , j1 , i2 , j2 ) ) ; ans = Math . max ( ans , maxSumPath ( i1 + 1 , j1 , i2 ) + sum ( i1 , j1 , i2 , j2 ) ) ; cache [ i1 ] [ j1 ] [ i2 ] = ans ; return ans ; }
void pre_process ( boolean dp [ ] [ ] , char [ ] s ) { int n = s . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = false ; } for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) dp [ i ] [ i + j - 1 ] = true ; } else if ( s [ i ] == s [ i + j - 1 ] ) dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] ; } } }
int maxSum ( int a [ ] , int n ) { int ans = 0 ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; int [ ] [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = new int [ 3 ] ; for ( int i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = Math . max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 3 ) dp [ i ] [ 2 ] = Math . max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = Math . max ( ans , dp [ i ] [ 0 ] ) ; ans = Math . max ( ans , dp [ i ] [ 1 ] ) ; ans = Math . max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; }
int sumEvenFactors ( int L , int R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; }
int numberOfWays ( int x , int y , int z ) { binomialCoeff ( Math . max ( x , Math . max ( y , z ) ) ) ; int sum = 0 ; for ( int i = 1 ; i <= z ; i ++ ) { sum = ( sum + C [ z ] [ i ] ) ; } int sum1 = 0 ; for ( int i = 1 ; i <= y ; i ++ ) { for ( int j = i + 1 ; j <= x ; j ++ ) { sum1 = ( sum1 + ( C [ y ] [ i ] * C [ x ] [ j ] ) ) ; } } sum1 = ( sum * sum1 ) ; return sum1 ; }
int findMaxSubarraySum ( int a [ ] , int n , int k ) { for ( int i = 0 ; i < 5000 ; i ++ ) Arrays . fill ( dp [ i ] , - 1 ) ; int ans = ( int ) - 1e9 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ; if ( ans == 0 && k == 0 ) return Math . max ( a , a [ 0 ] ) ; return ans ; }
int count ( int pos , int even , int odd , int tight , Vector < Integer > num ) { if ( pos == num . size ( ) ) { if ( ( num . size ( ) & 1 ) != 0 ) { int t = odd ; odd = even ; even = t ; } int d = even - odd ; for ( int i = 0 ; i < 24 ; i ++ ) if ( d == prime [ i ] ) return 1 ; return 0 ; } if ( dp [ pos ] [ even ] [ odd ] [ tight ] != - 1 ) return dp [ pos ] [ even ] [ odd ] [ tight ] ; int ans = 0 ; int limit = ( tight != 0 ? 9 : num . get ( pos ) ) ; for ( int d = 0 ; d <= limit ; d ++ ) { int currF = tight , currEven = even ; int currOdd = odd ; if ( d < num . get ( pos ) ) currF = 1 ; if ( ( pos & 1 ) != 0 ) currOdd += d ; else currEven += d ; ans += count ( pos + 1 , currEven , currOdd , currF , num ) ; } return dp [ pos ] [ even ] [ odd ] [ tight ] = ans ; }
int maxWeight ( int [ ] arr , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != - 1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = Math . max ( fill_none , Math . max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; }
int solve ( int x ) { num = new Vector < Integer > ( ) ; while ( x != 0 ) { num . add ( x % 10 ) ; x /= 10 ; } Collections . reverse ( num ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) dp [ i ] [ j ] [ k ] = - 1 ; return count ( 0 , 0 , 0 , 0 , 0 , num ) ; }
void factorial ( int k ) { fac [ 0 ] = 1 ; for ( int i = 1 ; i <= k + 1 ; i ++ ) { fac [ i ] = ( i * fac [ i - 1 ] ) ; } }
int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != - 1 ) return dp [ k ] [ col ] ; int sum = 0 ; sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k ] [ col ] = sum ; }
int maxCost ( int a [ ] , int n , int l , int r ) { int mx = 0 , k ; for ( int i = 0 ; i < n ; ++ i ) mx = Math . max ( mx , a [ i ] ) ; int count [ ] = new int [ mx + 1 ] ; Arrays . fill ( count , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int res [ ] = new int [ mx + 1 ] ; res [ 0 ] = 0 ; l = Math . min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { k = Math . max ( num - l - 1 , 0 ) ; res [ num ] = Math . max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; }
void alternateFib ( int n ) { if ( n < 0 ) return ; int f1 = 0 ; int f2 = 1 ; System . out . print ( f1 + " " ) ; for ( int i = 2 ; i <= n ; i ++ ) { int f3 = f2 + f1 ; if ( i % 2 == 0 ) System . out . print ( f3 + " " ) ; f1 = f2 ; f2 = f3 ; } }
int findSDSFunc ( int n ) { int [ ] DP = new int [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }
int findInd ( int key , int i , int n , int k , int arr [ ] ) { int start , end , mid , ind = - 1 ; start = i + 1 ; end = n - 1 ; while ( start < end ) { mid = start + ( end - start ) / 2 ; if ( arr [ mid ] - key <= k ) { ind = mid ; start = mid + 1 ; } else { end = mid ; } } return ind ; }
void Combination ( int a [ ] , int combi [ ] , int n , int r , int depth , int index ) { if ( index == r ) { int product = 1 ; for ( int i = 0 ; i < r ; i ++ ) product = product * combi [ i ] ; sum += product ; return ; } for ( int i = depth ; i < n ; i ++ ) { combi [ index ] = a [ i ] ; Combination ( a , combi , n , r , i + 1 , index + 1 ) ; } }
int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
int lobb ( int n , int m ) { return ( ( 2 * m + 1 ) * binomialCoeff ( 2 * n , m + n ) ) / ( m + n + 1 ) ; }
int numberofways ( String A , String B , int N , int M ) { Vector < Integer > [ ] pos = new Vector [ MAX ] ; for ( int i = 0 ; i < M ; i ++ ) { pos [ B . charAt ( i ) ] . add ( i + 1 ) ; } int [ ] [ ] dpl = new int [ N + 2 ] [ M + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ; else dpl [ i ] [ j ] = Math . max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ; } } int LCS = dpl [ N ] [ M ] ; int [ ] [ ] dpr = new int [ N + 2 ] [ M + 2 ] ; for ( int i = N ; i >= 1 ; i -- ) { for ( int j = M ; j >= 1 ; j -- ) { if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ; else dpr [ i ] [ j ] = Math . max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ; } } int ans = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { for ( int x : pos . get ( j ) ) { if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) { ans ++ ; break ; } } } } return ans ; }
void precompute ( String s , int n , int l [ ] [ ] , int r [ ] [ ] ) { l [ s . charAt ( 0 ) - 'a' ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < MAX_CHAR ; j ++ ) l [ j ] [ i ] += l [ j ] [ i - 1 ] ; l [ s . charAt ( i ) - 'a' ] [ i ] ++ ; } r [ s . charAt ( n - 1 ) - 'a' ] [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < MAX_CHAR ; j ++ ) r [ j ] [ i ] += r [ j ] [ i + 1 ] ; r [ s . charAt ( i ) - 'a' ] [ i ] ++ ; } }
int maxSum ( int mat [ ] [ ] , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ ] [ ] = new int [ n ] [ n ] ; int maxSum = Integer . MIN_VALUE , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = Integer . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
int minJump ( int height [ ] [ ] , int x , int y ) { if ( x == R - 1 && y == C - 1 ) return 0 ; int diag = Integer . MAX_VALUE ; if ( isSafe ( x + 1 , y + 1 ) ) diag = minJump ( height , x + 1 , y + 1 ) + Math . abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ; int down = Integer . MAX_VALUE ; if ( isSafe ( x + 1 , y ) ) down = minJump ( height , x + 1 , y ) + Math . abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ; int right = Integer . MAX_VALUE ; if ( isSafe ( x , y + 1 ) ) right = minJump ( height , x , y + 1 ) + Math . abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ; return Math . min ( { down , right , diag } ) ; }
int numberOfWays ( int x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
int minRemove ( int arr [ ] , int n ) { int LIS [ ] = new int [ n ] , len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) { LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; }
int smallestSumSubarr ( int arr [ ] , int n ) { int min_ending_here = Integer . MAX_VALUE ; int min_so_far = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . min ( min_so_far , min_ending_here ) ; } return min_so_far ; }
int baseconversion ( int arr [ ] , int num , int base ) { int i = 0 , rem , j ; if ( num == 0 ) { return 0 ; } while ( num > 0 ) { rem = num % base ; arr [ i ++ ] = rem ; num /= base ; } return i ; }
int ans ( int n ) { if ( n < 6 ) { return n ; } return n % 6 + 10 * ( ans ( n / 6 ) ) ; }
int nonDecNums ( int n ) { int a [ ] [ ] = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
int LAS ( int arr [ ] , int n ) { int inc = 1 ; int dec = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) { inc = dec + 1 ; } else if ( arr [ i ] < arr [ i - 1 ] ) { dec = inc + 1 ; } } return Math . max ( inc , dec ) ; }
int lps ( String str ) { int n = str . length ( ) ; int L [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( str . charAt ( i ) == str . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; }
int largestZigZagSumRec ( int mat [ ] [ ] , int i , int j , int n ) { if ( i == n - 1 ) return mat [ i ] [ j ] ; int zzs = 0 ; for ( int k = 0 ; k < n ; k ++ ) if ( k != j ) zzs = Math . max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) ; return zzs + mat [ i ] [ j ] ; }
int largestZigZag ( int mat [ ] [ ] , int n ) { int res = 0 ; for ( int j = 0 ; j < n ; j ++ ) res = Math . max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) ; return res ; }
int MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; }
int unboundedKnapsack ( int W , int n , int val [ ] , int wt [ ] ) { int [ ] dp = new int [ W + 1 ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i <= W ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( wt [ j ] <= i ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ; return dp [ W ] ; }
int countSubarray ( int arr [ ] , int n , int k ) { int s = 0 ; int i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } int count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } s += ( ( count * ( count + 1 ) ) / 2 ) ; } return ( n * ( n + 1 ) / 2 - s ) ; }
int CountPS ( String str , int n ) { int [ ] [ ] dp = new int [ n ] [ n ] ; boolean [ ] [ ] P = new boolean [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) P [ i ] [ i ] = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) { P [ i ] [ i + 1 ] = true ; dp [ i ] [ i + 1 ] = 1 ; } } for ( int gap = 2 ; gap < n ; gap ++ ) { for ( int i = 0 ; i < n - gap ; i ++ ) { int j = gap + i ; if ( str . charAt ( i ) == str . charAt ( j ) && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ; if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } } return dp [ 0 ] [ n - 1 ] ; }
int breakSum ( int n ) { if ( n == 0 n == 1 ) return n ; return Math . max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; }
int findMinSum ( int arr [ ] , int n ) { int sum [ ] = new int [ n ] ; sum [ 0 ] = arr [ 0 ] ; sum [ 1 ] = arr [ 1 ] ; sum [ 2 ] = arr [ 2 ] ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = arr [ i ] + minimum ( sum [ i - 3 ] , sum [ i - 2 ] , sum [ i - 1 ] ) ; return minimum ( sum [ n - 1 ] , sum [ n - 2 ] , sum [ n - 3 ] ) ; }
int minAdjustmentCost ( int A [ ] , int n , int target ) { int dp [ ] [ ] = new int [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; for ( int k = Math . max ( j - target , 0 ) ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } int res = Integer . MAX_VALUE ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }
int countWays ( int p , int q , int r , int last ) { if ( p < 0 q < 0 r < 0 ) return 0 ; if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ; if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ; if ( last == 0 ) return countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ; if ( last == 1 ) return countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; if ( last == 2 ) return countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; }
int countP ( int n , int k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ; }
int countP ( int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }
boolean has4 ( int x ) { while ( x != 0 ) { if ( x % 10 == 4 ) return true ; x = x / 10 ; } return false ; }
int findMaxforN ( Node root , int N ) { if ( root == null ) return - 1 ; if ( root . key == N ) return N ; else if ( root . key < N ) { int k = findMaxforN ( root . right , N ) ; if ( k == - 1 ) return root . key ; else return k ; } else if ( root . key > N ) return findMaxforN ( root . left , N ) ; return Integer . MIN_VALUE ; }
int findMinInsertionsDP ( String str , int n ) { int table [ ] [ ] = new int [ n ] [ n ] , l , h , gap ; for ( gap = 1 ; gap < n ; ++ gap ) for ( l = 0 , h = gap ; h < n ; ++ l , ++ h ) table [ l ] [ h ] = ( str . charAt ( l ) == str . charAt ( h ) ) ? table [ l + 1 ] [ h - 1 ] : ( Math . min ( table [ l ] [ h - 1 ] , table [ l + 1 ] [ h ] ) + 1 ) ; return table [ 0 ] [ n - 1 ] ; }
int distanceBetween2 ( Node root , int a , int b ) { if ( root == null ) return 0 ; if ( root . key > a && root . key > b ) return distanceBetween2 ( root . left , a , b ) ; if ( root . key < a && root . key < b ) return distanceBetween2 ( root . right , a , b ) ; if ( root . key >= a && root . key <= b ) return distanceFromRoot ( root , a ) + distanceFromRoot ( root , b ) ; return 0 ; }
int eggDrop ( int n , int k ) { int [ ] [ ] eggFloor = new int [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = Integer . MAX_VALUE ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + Math . max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; }
boolean getCountUtil ( node root , int low , int high , int [ ] count ) { if ( root == null ) return true ; boolean l = getCountUtil ( root . left , low , high , count ) ; boolean r = getCountUtil ( root . right , low , high , count ) ; if ( l && r && inRange ( root , low , high ) ) { ++ count ; return true ; } return false ; }
int ksmallestElementSum ( Node node , int k ) { int count = 0 ; ksmallestElementSumRec ( node , k ) ; return count ; }
void findOccurrences ( String S , String T ) { int n1 = S . length ( ) ; int n2 = T . length ( ) ; int ans = 0 ; int last = 0 ; for ( int i = 0 ; i <= n1 - n2 ; i ++ ) { boolean chk = true ; for ( int j = 0 ; j < n2 ; j ++ ) { if ( T . charAt ( j ) != S . charAt ( i + j ) ) { chk = false ; break ; } } if ( chk ) { ans += ( i + 1 - last ) * ( n1 - ( i + n2 - 1 ) ) ; last = i + 1 ; } } System . out . println ( ans ) ; }
int countTimes ( int [ ] arr , int K ) { int N = ( int ) arr . length ; if ( N == 1 ) return 1 ; if ( N < 3 ) return 0 ; if ( N == 3 ) { int cnt = 0 ; cnt += ( Math . abs ( arr [ 0 ] - arr [ 1 ] ) == K ? 1 : 0 ) + ( Math . abs ( arr [ 2 ] - arr [ 1 ] ) == K ? 1 : 0 ) + ( Math . abs ( arr [ 0 ] - arr [ 2 ] ) == K ? 1 : 0 ) ; return cnt ; } int [ ] prefix = new int [ N + 2 ] ; int [ ] suffix = new int [ N + 2 ] ; prefix [ 0 ] = arr [ 0 ] ; prefix [ 1 ] = arr [ 1 ] ; suffix [ N - 1 ] = arr [ N - 1 ] ; suffix [ N - 2 ] = arr [ N - 2 ] ; for ( int i = 2 ; i < N ; i += 2 ) { prefix [ i ] = arr [ i ] + prefix [ i - 2 ] ; } for ( int i = 3 ; i < N ; i += 2 ) { prefix [ i ] = arr [ i ] + prefix [ i - 2 ] ; } for ( int i = N - 3 ; i >= 0 ; i -= 2 ) { suffix [ i ] = arr [ i ] + suffix [ i + 2 ] ; } for ( int i = N - 4 ; i >= 0 ; i -= 2 ) { suffix [ i ] = arr [ i ] + suffix [ i + 2 ] ; } int count = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( Math . abs ( prefix [ i - 1 ] + suffix [ i + 2 ] - prefix [ i - 2 ] - suffix [ i + 1 ] ) == K ) { count ++ ; } } count += findCount0th ( arr , N , K ) ; count += findCount1st ( arr , N , K ) ; return count ; }
void LargestArray ( int N , int low , int high ) { int high_index = N - ( high - low + 1 ) ; if ( high_index > ( N - 1 ) / 2 ) { System . out . println ( "Not Possible" ) ; return ; } if ( high_index <= 0 ) high_index = 1 ; int [ ] A = new int [ N ] ; int temp = high ; for ( int i = high_index ; i >= 0 ; i -- ) { A [ i ] = temp -- ; } high -= 1 ; for ( int i = high_index + 1 ; i < N ; i ++ ) A [ i ] = high -- ; for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( A [ i ] + " " ) ; } }
int OddLengthSum ( int [ ] arr ) { int sum = 0 ; int l = arr . length ; for ( int i = 0 ; i < l ; i ++ ) { sum += ( ( ( i + 1 ) * ( l - i ) + 1 ) / 2 ) * arr [ i ] ; } return sum ; }
int SpiralElement ( int x , int y ) { int r ; if ( x < y ) { if ( y % 2 == 1 ) { r = y * y ; return ( r - x + 1 ) ; } else { r = ( y - 1 ) * ( y - 1 ) ; return ( r + x ) ; } } else { if ( x % 2 == 0 ) { r = x * x ; return ( r - y + 1 ) ; } else { r = ( x - 1 ) * ( x - 1 ) ; return ( r + y ) ; } } }
boolean checkprefix ( int A , int B ) { String s1 = String . valueOf ( A ) ; String s2 = String . valueOf ( B ) ; int n1 = s1 . length ( ) ; int n2 = s2 . length ( ) ; if ( n1 < n2 ) { return false ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( s1 . charAt ( i ) != s2 . charAt ( i ) ) { return false ; } } return true ; }
long Count ( int i ) { if ( i == 0 ) return 1 ; else if ( i < 0 ) return 0 ; if ( a [ i ] == 0 ) { a [ i ] = ( i + 1 ) + 2 * Count ( i - 1 ) ; return a [ i ] ; } else return a [ i ] ; }
void printOddFactorNumber ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) { if ( ( i > 0 ) && ( ( i & ( i - 1 ) ) != 0 ) ) System . out . print ( i + " " ) ; } }
void stateC ( String n ) { System . out . println ( "String accepted" ) ; }
int findDistinctSums ( int n ) { Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { s . add ( i + j ) ; } } return s . size ( ) ; }
void check_string_exist ( String S ) { int size = S . length ( ) ; boolean check = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( ( i + 2 ) % size ) ) { check = false ; break ; } } if ( check ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
int nthTerm ( int N ) { int nth = 0 , first_term = 12 ; nth = ( first_term * ( int ) ( Math . pow ( 2 , N - 1 ) ) ) + 11 * ( ( int ) ( Math . pow ( 2 , N - 1 ) ) - 1 ) ; return nth ; }
boolean isVowel ( char ch ) { switch ( ch ) { case 'a' : case 'e' : case 'i' : case 'o' : case 'u' : return true ; } return false ; }
int KMPSearch ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int [ ] lps = new int [ M ] ; computeLPSArray ( pat , M , lps ) ; int i = 0 ; int j = 0 ; while ( i < N ) { if ( pat . charAt ( j ) == txt . charAt ( i ) ) { j ++ ; i ++ ; } if ( j == M ) { return i - j ; j = lps [ j - 1 ] ; } else if ( i < N && pat . charAt ( j ) != txt . charAt ( i ) ) { if ( j != 0 ) j = lps [ j - 1 ] ; else i = i + 1 ; } } return 0 ; }
boolean checkSequence ( String a , String b ) { if ( b . length ( ) == 0 ) return true ; if ( a . length ( ) == 0 ) return false ; if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) return checkSequence ( a . substring ( 1 ) , b . substring ( 1 ) ) ; else return checkSequence ( a . substring ( 1 ) , b ) ; }
int getCount ( String a , String b ) { if ( b . length ( ) % a . length ( ) != 0 ) return - 1 ; int count = b . length ( ) / a . length ( ) ; String str = "" ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str . equals ( b ) ) return count ; return - 1 ; }
boolean isVowel ( char c ) { String vowel = "aeiou" ; for ( int i = 0 ; i < vowel . length ( ) ; ++ i ) if ( vowel . charAt ( i ) == c ) return true ; return false ; }
int calc ( int l , int r , char [ ] s ) { if ( Math . abs ( r - l ) % 2 == 0 ) { return 0 ; } if ( l > r ) { return dp [ l ] [ r ] = 1 ; } if ( dp [ l ] [ r ] != - 1 ) { return dp [ l ] [ r ] ; } if ( ( r - l ) == 1 ) { if ( s [ l ] == s [ r ] ) { dp [ l ] [ r ] = 1 ; } else { dp [ l ] [ r ] = 0 ; } return dp [ l ] [ r ] ; } int ans = 0 ; for ( int k = l + 1 ; k <= r ; k += 2 ) { int temp = 1 ; if ( s [ l ] == s [ k ] ) { temp = calc ( l + 1 , k - 1 , s ) * calc ( k + 1 , r , s ) * choose [ ( r - l + 1 ) / 2 ] [ ( r - k ) / 2 ] ; ans += temp ; } } return dp [ l ] [ r ] = ans ; }
int number_of_tower ( int house [ ] , int range , int n ) { Arrays . sort ( house ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
int minimumFlips ( String s ) { int n = s . length ( ) ; int cnt0 = 0 , cnt1 = 0 ; int res = n - cnt0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) { cnt0 -= 1 ; } else if ( s . charAt ( i ) == '1' ) { res = Math . min ( res , cnt1 + cnt0 ) ; cnt1 ++ ; } } return res ; }
char KthCharacter ( String s , String t , long k ) { long f = 1 ; long ss = 2 ; String tmp = "" ; int len = tmp . length ( ) ; while ( len < k ) { long tf = f ; long ts = ss ; while ( tf -- != 0 ) { tmp += s ; } while ( ts -- != 0 ) { tmp += t ; } f += 2 ; ss += 2 ; len = tmp . length ( ) ; } char output = tmp . charAt ( k - 1 ) ; return output ; }
int fact ( int n ) { int ans = 1 ; for ( int i = 2 ; i <= n ; i ++ ) ans = ans * i ; return ans ; }
String checkIfPossible ( int N , String arr [ ] , String T ) { int [ ] freqS = new int [ 256 ] ; int [ ] freqT = new int [ 256 ] ; for ( char ch : T . toCharArray ( ) ) { freqT [ ch - 'a' ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { for ( char ch : arr [ i ] . toCharArray ( ) ) { freqS [ ch - 'a' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freqT [ i ] == 0 && freqS [ i ] != 0 ) { return "No" ; } else if ( freqS [ i ] == 0 && freqT [ i ] != 0 ) { return "No" ; } else if ( freqT [ i ] != 0 && freqS [ i ] != ( freqT [ i ] * N ) ) { return "No" ; } } return "Yes" ; }
void findSubstringInWraproundString ( String p ) { int ans = 0 ; int curLen = 0 ; int [ ] arr = new int [ 26 ] ; for ( int i = 0 ; i < ( int ) p . length ( ) ; i ++ ) { int curr = p . charAt ( i ) - 'a' ; if ( i > 0 && ( p . charAt ( i - 1 ) != ( ( curr + 26 - 1 ) % 26 + 'a' ) ) ) { curLen = 0 ; } curLen ++ ; if ( curLen > arr [ curr ] ) { ans += ( curLen - arr [ curr ] ) ; arr [ curr ] = curLen ; } } System . out . println ( ans ) ; }
void update ( int BIT [ ] [ ] , int idx , int i , int val ) { while ( i < 10005 ) { BIT [ idx ] [ i ] += val ; i = i + ( i & ( - i ) ) ; } }
int fact ( int a ) { int i , f = 1 ; for ( i = 2 ; i <= a ; i ++ ) f = f * i ; return f ; }
int maxLength ( String [ ] arr ) { String [ ] tmp = helper ( arr , 0 ) ; int len = 0 ; for ( String i : tmp ) { len = len > i . length ( ) ? len : i . length ( ) ; } return len ; }
long polynomialRollingHash ( String str ) { int p = 31 ; int m = ( int ) 1e9 + 9 ; long power_of_p = 1 ; long hash_val = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { hash_val = ( hash_val + ( str . charAt ( i ) - 'a' + 1 ) * power_of_p ) % m ; power_of_p = ( power_of_p * p ) % m ; } return ( hash_val % m + m ) % m ; }
boolean isPalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) { if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) { return false ; } } return true ; }
boolean checkPalindrome ( ) { int oddCnt = 0 ; for ( int i = 0 ; i < freq . length ; i ++ ) { if ( freq [ i ] % 2 == 1 ) oddCnt ++ ; } return oddCnt <= 1 ; }
int countSubstrings ( String str , int K ) { int N = str . length ( ) ; int answer = 0 ; HashMap < Character , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < K ; i ++ ) { map . put ( str . charAt ( i ) , map . getOrDefault ( str . charAt ( i ) , 0 ) + 1 ) ; } if ( map . size ( ) == K ) answer ++ ; for ( int i = K ; i < N ; i ++ ) { map . put ( str . charAt ( i ) , map . getOrDefault ( str . charAt ( i ) , 0 ) + 1 ) ; map . put ( str . charAt ( i - K ) , map . get ( str . charAt ( i - K ) ) - 1 ) ; if ( map . get ( str . charAt ( i - K ) ) == 0 ) { map . remove ( str . charAt ( i - K ) ) ; } if ( map . size ( ) == K ) { answer ++ ; } } return answer ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
void moveAtEnd ( String s , int i , int l ) { if ( i >= l ) return ; char curr = s . charAt ( i ) ; if ( curr != 'x' ) System . out . print ( curr ) ; moveAtEnd ( s , i + 1 , l ) ; if ( curr == 'x' ) System . out . print ( curr ) ; return ; }
void kthString ( int n , int k ) { int total = 0 ; int i = 1 ; while ( total < k ) { total = total + n - i ; i ++ ; } int first_y_position = i - 1 ; int second_y_position = k - ( total - n + first_y_position ) ; for ( int j = 1 ; j < first_y_position ; j ++ ) System . out . print ( "x" ) ; System . out . print ( "y" ) ; int j = first_y_position + 1 ; while ( second_y_position > 1 ) { System . out . print ( "x" ) ; second_y_position -- ; j ++ ; } System . out . print ( "y" ) ; while ( j < n ) { System . out . print ( "x" ) ; j ++ ; } }
void check ( String str ) { if ( checkIfStartsWithCapital ( str ) ) System . out . println ( "Accepted" ) ; else System . out . println ( "Not Accepted" ) ; }
void compressString ( String s , int n ) { int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ s . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == 0 ) continue ; System . out . print ( ( char ) ( i + 'a' ) + freq [ i ] ) ; } }
int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }
int findLength ( String s , int k ) { int ans = Integer . MAX_VALUE ; int l = 0 ; int r = 0 ; int cnt_zero = 0 , cnt_one = 0 ; while ( l < s . length ( ) && r <= s . length ( ) ) { if ( cnt_zero >= k && cnt_one >= 1 ) { ans = Math . min ( ans , r - l ) ; l ++ ; if ( s . charAt ( l - 1 ) == '0' ) cnt_zero -- ; else cnt_one -- ; } else { if ( r == s . length ( ) ) break ; if ( s . charAt ( r ) == '0' ) cnt_zero ++ ; else cnt_one ++ ; r ++ ; } } if ( ans == Integer . MAX_VALUE ) return - 1 ; return ans ; }
int cntSplits ( String s ) { if ( s . charAt ( s . length ( ) - 1 ) == '1' ) return - 1 ; int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) ans += ( s . charAt ( i ) == '0' ) ? 1 : 0 ; return ans ; }
void findMinSubStr ( String arr [ ] , int n , String str ) { for ( int i = 0 ; i < n ; i ++ ) { uSet . add ( arr [ i ] ) ; } findSubStr ( str , 0 , 0 ) ; }
void printChar ( String str , int n ) { int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - 'a' ] % 2 == 0 ) { System . out . print ( str . charAt ( i ) ) ; } } }
int find_digit ( String s , int n ) { int first_digit = - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) < '0' || s . charAt ( i ) > '9' ) { first_digit = i ; break ; } } first_digit ++ ; int s_len = first_digit ; int num = 0 , pw = 1 ; int i = n - 1 ; while ( i >= 0 ) { if ( s . charAt ( i ) >= '0' && s . charAt ( i ) <= '9' ) { int digit = s . charAt ( i ) - '0' ; num = num + ( pw * digit ) ; if ( num >= s_len ) return - 1 ; pw = pw * 10 ; } i -- ; } num = num * 10 ; int req = s_len - num ; if ( req > 9 req < 0 ) return - 1 ; return req ; }
int countSubString ( char [ ] s , char c , int k ) { int leftCount = 0 , rightCount = 0 ; int left = 0 , right = 0 ; int freq = 0 ; int result = 0 , len = s . length ; while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } right = left + 1 ; while ( freq != ( k - 1 ) && ( right - 1 ) < len ) { if ( s [ right ] == c ) freq ++ ; right ++ ; } while ( left < len && ( right - 1 ) < len ) { while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } while ( right < len && s [ right ] != c ) { if ( s [ right ] == c ) freq ++ ; right ++ ; rightCount ++ ; } result = result + ( leftCount + 1 ) * ( rightCount + 1 ) ; freq = k - 1 ; leftCount = 0 ; rightCount = 0 ; left ++ ; right ++ ; } return result ; }
int minOperations ( int n , String a , String b , String c ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char x = a . charAt ( i ) ; char y = b . charAt ( i ) ; char z = c . charAt ( i ) ; if ( x == y && y == z ) ans ++ ; else if ( x == y y == z x == z ) { ans ++ ; } else { ans += 2 ; } } return ans ; }
void preCalculate ( String s , int prefix [ ] [ ] ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ i ] [ s . charAt ( i ) - 'a' ] ++ ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) prefix [ i ] [ j ] += prefix [ i - 1 ] [ j ] ; } }
boolean check ( String s , int l ) { Vector < Integer > pos = new Vector < Integer > ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '1' ) pos . add ( i ) ; } int t = pos . size ( ) ; for ( int i = 1 ; i < t ; i ++ ) { if ( ( pos . get ( i ) - pos . get ( i - 1 ) ) != ( pos . get ( 1 ) - pos . get ( 0 ) ) ) return false ; } return true ; }
int [ ] compute_lps ( String s ) { int n = s . length ( ) ; int [ ] lps = new int [ n ] ; int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = lps [ len - 1 ] ; else { lps [ i ] = 0 ; i ++ ; } } } return lps ; }
void printLastChar ( String str ) { str = str + " " ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ' ) System . out . print ( str . charAt ( i - 1 ) + " " ) ; } }
int getMinimizedSum ( String str , int len ) { int i , maxVal = Integer . MIN_VALUE , sum = 0 ; int occurrences [ ] = new int [ 26 ] ; for ( i = 0 ; i < len ; i ++ ) { occurrences [ str . charAt ( i ) - 'a' ] ++ ; sum += ( int ) str . charAt ( i ) ; } for ( i = 0 ; i < 26 ; i ++ ) maxVal = Math . max ( maxVal , occurrences [ i ] * ( i + 'a' ) ) ; return ( sum - maxVal ) ; }
int substrDeletion ( String str , int len ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) count0 ++ ; else count1 ++ ; } return Math . min ( count0 , count1 ) ; }
void printString ( String str , int n ) { int ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( str . charAt ( i ) == '1' ) ones ++ ; boolean used = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '2' && ! used ) { used = true ; for ( int j = 0 ; j < ones ; j ++ ) System . out . print ( "1" ) ; } if ( str . charAt ( i ) != '1' ) System . out . print ( str . charAt ( i ) ) ; } if ( ! used ) for ( int j = 0 ; j < ones ; j ++ ) System . out . print ( "1" ) ; }
char Colour_Combination ( String s ) { char temp = s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( temp != s . charAt ( i ) ) { if ( ( temp == 'B' temp == 'G' ) && ( s . charAt ( i ) == 'G' s . charAt ( i ) == 'B' ) ) temp = 'Y' ; else if ( ( temp == 'B' temp == 'Y' ) && ( s . charAt ( i ) == 'Y' s . charAt ( i ) == 'B' ) ) temp = 'G' ; else temp = 'B' ; } } return temp ; }
void reverse ( String str , int x ) { int n = ( str . length ( ) - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( str . charAt ( i ) ) ; for ( int i = n + x - 1 ; i >= n ; i -- ) System . out . print ( str . charAt ( i ) ) ; for ( int i = n + x ; i < str . length ( ) ; i ++ ) System . out . print ( str . charAt ( i ) ) ; }
int countSubStrings ( String str , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( 0 ) ) count += subStringsStartingHere ( str , n , i ) ; } return count ; }
int maxFreq ( String s , int a , int b ) { int fre [ ] = new int [ 10 ] ; int n = s . length ( ) ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } for ( int i = 0 ; i < n ; i ++ ) fre [ s . charAt ( i ) - '0' ] ++ ; if ( fre [ a ] == 0 && fre [ b ] == 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; }
void sumProdOfPrimeFreq ( char [ ] s ) { boolean [ ] prime = new boolean [ s . length + 1 ] ; for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , s . length + 1 ) ; int i , j ; HashMap < Character , Integer > m = new HashMap < > ( ) ; for ( i = 0 ; i < s . length ; i ++ ) if ( m . containsKey ( s [ i ] ) ) { m . put ( s [ i ] , m . get ( s [ i ] ) + 1 ) ; } else { m . put ( s [ i ] , 1 ) ; } } int sum = 0 , product = 1 ; for ( Map . Entry < Character , Integer > it : m . entrySet ( ) ) { if ( prime [ it . getValue ( ) ] ) { sum += it . getValue ( ) ; product *= it . getValue ( ) ; } } System . out . print ( "Sum = " + sum ) ; System . out . print ( "Product=" + product ) ; }
void StringMatch ( String s ) { int lo = 0 , hi = s . length ( ) , len = s . length ( ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int x = 0 ; x < len ; x ++ ) { if ( s . charAt ( x ) == 'I' ) { ans . add ( lo ) ; lo += 1 ; } else { ans . add ( hi ) ; hi -= 1 ; } } ans . add ( lo ) ; System . out . print ( "[" ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) ) ; if ( i != ans . size ( ) - 1 ) System . out . print ( "," ) ; } System . out . print ( "]" ) ; }
int CountCharacters ( String str , int l , int r ) { int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( l <= str . charAt ( i ) && str . charAt ( i ) <= r ) { cnt ++ ; System . out . print ( str . charAt ( i ) + " " ) ; } } return cnt ; }
int countPermutations ( String str ) { int even = ( int ) Math . floor ( str . length ( ) / 2 ) ; int odd = str . length ( ) - even ; int ways = 0 ; int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { ++ freq [ str . charAt ( i ) - 'a' ] ; } int nvowels = freq [ 0 ] + freq [ 4 ] + freq [ 8 ] + freq [ 14 ] + freq [ 20 ] ; int nconsonants = str . length ( ) - nvowels ; ways = npr ( odd , nvowels ) * npr ( nconsonants , nconsonants ) ; return ways ; }
boolean isVowel ( char ch ) { if ( ch != 'a' && ch != 'e' && ch != 'i' && ch != 'o' && ch != 'u' ) return false ; return true ; }
int maxLength ( String s , int n ) { int right = 0 , left = 0 ; int coun = 0 , max_length = Integer . MIN_VALUE ; s = s + '1' ; for ( int i = 0 ; i <= n ; i ++ ) { if ( s . charAt ( i ) == 'o' ) coun ++ ; else { if ( coun > max_length ) { right = 0 ; left = 0 ; if ( s . charAt ( i ) == 'x' ) right = 1 ; if ( ( ( i - coun ) > 0 ) && ( s . charAt ( i - coun - 1 ) == 'x' ) ) left = 1 ; coun = ( int ) Math . ceil ( ( double ) coun / ( right + left ) ) ; max_length = Math . max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; }
boolean is_possible ( String s ) { int l = s . length ( ) ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '0' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( Math . abs ( one - zero ) == 1 ) ; }
int oddEquivalent ( String s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) count ++ ; } return count ; }
boolean isPalindrome ( String str ) { int firstChar = 0 , lastChar = str . length ( ) - 1 ; boolean ch = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { firstChar = firstPos ( str , firstChar , lastChar ) ; lastChar = lastPos ( str , lastChar , firstChar ) ; if ( lastChar < 0 firstChar < 0 ) break ; if ( str . charAt ( firstChar ) == str . charAt ( lastChar ) ) { firstChar ++ ; lastChar -- ; continue ; } ch = false ; break ; } return ( ch ) ; }
int find ( String s ) { int max = 0 , i , j = 0 , countk = 0 , countr = 0 ; int table [ ] [ ] = new int [ s . length ( ) ] [ 2 ] ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == 'R' ) countr ++ ; else table [ j ++ ] [ 0 ] = countr ; } j -- ; for ( i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == 'K' ) { countk ++ ; table [ j -- ] [ 1 ] = countk ; } if ( Math . min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) > max ) max = Math . min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) ; } return max ; }
void LongestSequence ( int fre [ ] [ ] , int n ) { for ( int i = MAX_CHAR - 1 ; i >= 0 ; i -- ) { int mi = fre [ 0 ] [ i ] ; for ( int j = 1 ; j < n ; j ++ ) mi = Math . min ( fre [ j ] [ i ] , mi ) ; while ( mi -- > 0 ) System . out . print ( ( char ) ( 'a' + i ) ) ; } }
int firstNonRepeating ( String str ) { int arr [ ] = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) arr [ i ] = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( arr [ str . charAt ( i ) ] == - 1 ) arr [ str . charAt ( i ) ] = i ; else arr [ str . charAt ( i ) ] = - 2 ; } int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( arr [ i ] >= 0 ) res = Math . min ( res , arr [ i ] ) ; return res ; }
void preComputeCoeff ( ) { for ( int i = 0 ; i < max ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = ( nCr [ i - 1 ] [ j - 1 ] + nCr [ i - 1 ] [ j ] ) % mod ; } } }
int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }
int countWays ( String s ) { int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) count [ s . charAt ( i ) - 'a' ] ++ ; count [ s . charAt ( 0 ) - 'a' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
boolean isPerfectSquareString ( String str ) { int sum = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) sum += ( int ) str . charAt ( i ) ; double squareRoot = Math . sqrt ( sum ) ; return ( ( squareRoot - Math . floor ( squareRoot ) ) == 0 ) ; }
int findSubstrings ( String s , int k ) { int ans = 0 ; int [ ] cnt = new int [ 26 ] ; int i , j , n = s . length ( ) ; for ( i = 0 ; i < n ; i ++ ) { Arrays . fill ( cnt , 0 ) ; for ( j = i ; j < n ; j ++ ) { cnt [ s . charAt ( j ) - 'a' ] ++ ; if ( cnt [ s . charAt ( j ) - 'a' ] <= k ) ans ++ ; else break ; } } return ans ; }
boolean isPanDigital ( String s ) { boolean [ ] digits = new boolean [ 10 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) digits [ s . charAt ( i ) - '0' ] = true ; for ( int i = 0 ; i <= 9 ; i ++ ) if ( digits [ i ] == false ) return false ; return true ; }
int combinedSum ( String s ) { int n = s . length ( ) ; int c_sum = 0 ; int range = ( 1 << n ) - 1 ; for ( int i = 0 ; i <= range ; i ++ ) c_sum += findSubSequence ( s , i ) ; return c_sum ; }
int numberOfPossiblePallindrome ( String str , int n ) { HashMap < Character , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( str . charAt ( i ) ) ) { mp . put ( str . charAt ( i ) , mp . get ( str . charAt ( i ) ) + 1 ) ; } else { mp . put ( str . charAt ( i ) , 1 ) ; } } int fi ; for ( Map . Entry < Character , Integer > it : mp . entrySet ( ) ) { if ( it . getValue ( ) % 2 == 0 ) fi = it . getValue ( ) / 2 ; else { fi = ( it . getValue ( ) - 1 ) / 2 ; k ++ ; } num = num + fi ; den = den * fact ( fi ) ; } if ( num != 0 ) num = fact ( num ) ; int ans = num / den ; if ( k != 0 ) { ans = ans * k ; } return ( ans ) ; }
int totalConsonants ( String str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( isConsonant ( str . charAt ( i ) ) ) ++ count ; return count ; }
void convert ( String str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' ' ) str . replace ( i , '_' ) ; else str . replace ( i , Character . toLowerCase ( str . charAt ( i ) ) ) ; } System . out . print ( str ) ; }
boolean isEven ( String s ) { int l = s . length ( ) ; boolean dotSeen = false ; for ( int i = l - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '0' && dotSeen == false ) continue ; if ( s . charAt ( i ) == '.' ) { dotSeen = true ; continue ; } if ( ( s . charAt ( i ) - '0' ) % 2 == 0 ) return true ; return false ; } return false ; }
boolean isVowel ( char c ) { return ( c == 'A' c == 'E' c == 'I' c == 'O' c == 'U' c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) ; }
int countReduce ( String str ) { int n = str . length ( ) ; int res = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) res += Math . abs ( str . charAt ( i ) - str . charAt ( n - i - 1 ) ) ; return res ; }
void reverse ( char num [ ] , int i , int j ) { while ( i < j ) { char temp = num [ i ] ; num [ i ] = num [ j ] ; num [ j ] = temp ; i ++ ; j -- ; } }
void findWinner ( String [ ] votes ) { HashMap < String , Integer > mapObj = new HashMap < > ( ) ; for ( String str : votes ) { if ( mapObj . containsKey ( str ) ) { mapObj . put ( str , mapObj . get ( str ) + 1 ) ; } else { mapObj . put ( str , 1 ) ; } } int maxValueInMap = 0 ; String winner = "" ; for ( Map . Entry < String , Integer > entry : mapObj . entrySet ( ) ) { String key = entry . getKey ( ) ; int val = entry . getValue ( ) ; if ( val > maxValueInMap ) { maxValueInMap = val ; winner = key ; } else if ( val == maxValueInMap && winner > key ) winner = key ; } System . out . println ( winner ) ; }
boolean distributingBalls ( int k , int n , String str ) { int a [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ str . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; }
boolean check ( int freq [ ] , int k ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( freq [ i ] != k ) return false ; return true ; }
long countSets ( int a [ ] [ ] ) { long res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i ] [ j ] == 1 ) { u ++ ; } else { v ++ ; } } res += Math . pow ( 2 , u ) - 1 + Math . pow ( 2 , v ) - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] [ i ] == 1 ) { u ++ ; } else { v ++ ; } } res += Math . pow ( 2 , u ) - 1 + Math . pow ( 2 , v ) - 1 ; } return res - ( n * m ) ; }
void traverseTree ( Node root ) { if ( root == null ) return ; while ( root != null ) { System . out . print ( root . data + " " ) ; if ( root . child != null ) traverseTree ( root . child ) ; root = root . next ; } }
int calculateEnergy ( int mat [ ] [ ] , int n ) { int i_des , j_des , q ; int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { q = mat [ i ] [ j ] / n ; i_des = q ; j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ; } } return tot_energy ; }
int countUnique ( int mat [ ] [ ] , int n , int m ) { int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 && isUnique ( mat , i , j , n , m ) ) uniquecount ++ ; return uniquecount ; }
boolean uniqueCharacters ( String str ) { for ( int i = 0 ; i < str . length ( ) - 1 ; i ++ ) { for ( int j = i + 1 ; j < str . length ( ) ; j ++ ) { if ( str . charAt ( i ) == str . charAt ( j ) ) { return false ; } } } return true ; }
char largest_alphabet ( String a , int n ) { char max = 'A' ; for ( int i = 0 ; i < n ; i ++ ) if ( a . charAt ( i ) > max ) max = a . charAt ( i ) ; return max ; }
boolean isPalRec ( char [ ] str , int s , int e ) { if ( s == e ) return true ; if ( str [ s ] != str [ e ] ) return false ; if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; }
int evenNumSubstring ( String str ) { int len = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str . charAt ( i ) - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) if ( checkEquality ( s . substring ( i , i + len ) ) ) result ++ ; return result ; }
boolean unique ( String s ) { Arrays . sort ( s ) ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { return false ; break ; } } return true ; }
void qType1 ( int tree [ ] [ ] , int l , int x , char str [ ] ) { update ( tree , l , - 1 , str [ l - 1 ] - 97 + 1 ) ; str [ l - 1 ] = x ; update ( tree , l , 1 , str [ l - 1 ] - 97 + 1 ) ; }
int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str . charAt ( i ) - str . charAt ( j ) ) == Math . abs ( i - j ) ) result ++ ; return result ; }
int findMinLength ( String arr [ ] , int n ) { int min = arr [ 0 ] . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] . length ( ) < min ) min = arr [ i ] . length ( ) ; return ( min ) ; }
boolean areDistinct ( String str , int i , int j ) { boolean [ ] visited = new boolean [ 26 ] ; for ( int k = i ; k <= j ; k ++ ) { if ( visited [ str . charAt ( k ) - 'a' ] == true ) return false ; visited [ str . charAt ( k ) - 'a' ] = true ; } return true ; }
void printRLE ( String str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) { count ++ ; i ++ ; } System . out . print ( str . charAt ( i ) + count ) ; } }
void antiSpiralTraversal ( int m , int n , int a [ ] [ ] ) { int i , k = 0 , l = 0 ; Stack < Integer > stk = new Stack < > ( ) ; while ( k <= m && l <= n ) { for ( i = l ; i <= n ; ++ i ) stk . push ( a [ k ] [ i ] ) ; k ++ ; for ( i = k ; i <= m ; ++ i ) stk . push ( a [ i ] [ n ] ) ; n -- ; if ( k <= m ) { for ( i = n ; i >= l ; -- i ) stk . push ( a [ m ] [ i ] ) ; m -- ; } if ( l <= n ) { for ( i = m ; i >= k ; -- i ) stk . push ( a [ i ] [ l ] ) ; l ++ ; } } while ( ! stk . isEmpty ( ) ) { System . out . print ( stk . peek ( ) + " " ) ; stk . pop ( ) ; } }
int findNormal ( int mat [ ] [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] * mat [ i ] [ j ] ; return ( int ) Math . sqrt ( sum ) ; }
int countExpPaths ( Node node , int x ) { return evenPaths ( node , 0 , x ) ; }
int evenPaths ( Node node , int count ) { if ( node == null || ( node . key % 2 != 0 ) ) { return count ; } if ( node . left == null && node . right == null ) { count ++ ; } count = evenPaths ( node . left , count ) ; return evenPaths ( node . right , count ) ; }
int countEvenPaths ( Node node ) { return evenPaths ( node , 0 ) ; }
void dfs ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent . get ( u ) . size ( ) ; i ++ ) { if ( ! visited [ adjacent . get ( u ) . get ( i ) ] ) { temp ++ ; dfs ( adjacent . get ( u ) . get ( i ) , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; startnode = u ; } } }
void insertEdge ( int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; }
int canPaint ( node [ ] nodes , int n , int m ) { int [ ] visited = new int [ n + 1 ] ; int maxColors = 1 ; for ( int sv = 1 ; sv <= n ; sv ++ ) { if ( visited [ sv ] != 0 ) continue ; visited [ sv ] = 1 ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( sv ) ; while ( ! q . isEmpty ( ) ) { int top = q . peek ( ) ; q . remove ( ) ; for ( int it : nodes [ top ] . edges ) { if ( nodes [ top ] . color == nodes [ it ] . color ) nodes [ it ] . color += 1 ; maxColors = Math . max ( maxColors , Math . max ( nodes [ top ] . color , nodes [ it ] . color ) ) ; if ( maxColors > m ) return 0 ; if ( ! visited [ it ] ) { visited [ it ] = 1 ; q . add ( it ) ; } } } } return 1 ; }
void FastDoubling ( int n , int res [ ] ) { if ( n == 0 ) { res [ 0 ] = 0 ; res [ 1 ] = 1 ; return ; } FastDoubling ( ( n / 2 ) , res ) ; a = res [ 0 ] ; b = res [ 1 ] ; c = 2 * b - a ; if ( c < 0 ) c += MOD ; c = ( a * c ) % MOD ; d = ( a * a + b * b ) % MOD ; if ( n % 2 == 0 ) { res [ 0 ] = c ; res [ 1 ] = d ; } else { res [ 0 ] = d ; res [ 1 ] = c + d ; } }
boolean canPlace ( int a [ ] , int n , int p , int sep ) { int prisoners_placed = 1 ; int last_prisoner_placed = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int current_cell = a [ i ] ; if ( current_cell - last_prisoner_placed >= sep ) { prisoners_placed ++ ; last_prisoner_placed = current_cell ; if ( prisoners_placed == p ) { return true ; } } } return false ; }
int _mergeSort ( int arr [ ] , int temp [ ] , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; }
int minSteps ( int height [ ] , int N ) { return minStepsRecur ( height , 0 , N , 0 ) ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; y = y / 2 x = ( x * x ) % p ; } return res ; }
int minimumRectangleArea ( int A [ ] , int N ) { int ans ; Arrays . sort ( A ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( int i = 1 ; i < N ; i ++ ) ans = Math . min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; }
double areaOftriangle ( int side ) { double a = Math . sqrt ( Math . pow ( side / 2 , 2 ) + Math . pow ( side / 2 , 2 ) ) ; double b = Math . sqrt ( Math . pow ( side , 2 ) + Math . pow ( side / 2 , 2 ) ) ; double c = Math . sqrt ( Math . pow ( side , 2 ) + Math . pow ( side / 2 , 2 ) ) ; double s = ( a + b + c ) / 2 ; double area = Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; return area ; }
void interceptLength ( int a , int b , int c , int i , int j , int k ) { double rad = radius ( a , b , c ) ; double dist = centerDistanceFromLine ( a , b , i , j , k ) ; if ( rad < 0 dist < 0 ) { System . out . println ( "circle not possible" ) ; return ; } if ( dist > rad ) { System . out . println ( "Line not cutting circle" ) ; } else System . out . println ( 2 * Math . sqrt ( rad * rad - dist * dist ) ) ; }
int centralPoints ( int arr [ ] [ ] , int N ) { int count = 0 ; int c1 , c2 , c3 , c4 ; for ( int i = 0 ; i < N ; i ++ ) { c1 = 0 ; c2 = 0 ; c3 = 0 ; c4 = 0 ; int x = arr [ i ] [ 0 ] ; int y = arr [ i ] [ 1 ] ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ j ] [ 0 ] > x && arr [ j ] [ 1 ] == y ) { c1 = 1 ; } if ( arr [ j ] [ 1 ] > y && arr [ j ] [ 0 ] == x ) { c2 = 1 ; } if ( arr [ j ] [ 0 ] < x && arr [ j ] [ 1 ] == y ) { c3 = 1 ; } if ( arr [ j ] [ 1 ] < y && arr [ j ] [ 0 ] == x ) { c4 = 1 ; } } if ( c1 + c2 + c3 + c4 == 4 ) { count ++ ; } } return count ; }
void printMatrixDiagonal ( int mat [ ] [ ] , int n ) { int i = 0 , j = 0 ; boolean isUp = true ; for ( int k = 0 ; k < n * n ; ) { if ( isUp ) { for ( ; i >= 0 && j < n ; j ++ , i -- ) { System . out . print ( mat [ i ] [ j ] + " " ) ; k ++ ; } if ( i < 0 && j <= n - 1 ) i = 0 ; if ( j == n ) i = i + 2 ; j -- ; } else { for ( ; j >= 0 && i < n ; i ++ , j -- ) { System . out . print ( mat [ i ] [ j ] + " " ) ; k ++ ; } if ( j < 0 && i <= n - 1 ) j = 0 ; if ( i == n ) j = j + 2 ; i -- ; } isUp = ! isUp ; } }
double calculateSideLength ( double L , int N , int K ) { double angle = findInteriorAngle ( N ) ; double length = L * Math . pow ( Math . sin ( angle / 2 ) , ( K - 1 ) ) ; return length ; }
void minimumTriangleArea ( int a , int b ) { int area = a * b ; System . out . println ( area ) ; }
void finalPosition ( char a [ ] , int b [ ] , int M ) { int n = 0 , s = 0 , e = 0 , w = 0 ; char p = 'N' ; for ( int i = 0 ; i < M ; i ++ ) { if ( p == 'N' ) { if ( a [ i ] == 'U' ) { p = 'N' ; n = n + b [ i ] ; } else if ( a [ i ] == 'D' ) { p = 'S' ; s = s + b [ i ] ; } else if ( a [ i ] == 'R' ) { p = 'E' ; e = e + b [ i ] ; } else if ( a [ i ] == 'L' ) { p = 'W' ; w = w + b [ i ] ; } } else if ( p == 'S' ) { if ( a [ i ] == 'U' ) { p = 'S' ; s = s + b [ i ] ; } else if ( a [ i ] == 'D' ) { p = 'N' ; n = n + b [ i ] ; } else if ( a [ i ] == 'R' ) { p = 'W' ; w = w + b [ i ] ; } else if ( a [ i ] == 'D' ) { p = 'W' ; w = w + b [ i ] ; } else if ( a [ i ] == 'R' ) { p = 'S' ; s = s + b [ i ] ; } else if ( a [ i ] == 'L' ) { p = 'N' ; n = n + b [ i ] ; } } else if ( p == 'W' ) { if ( a [ i ] == 'U' ) { p = 'W' ; w = w + b [ i ] ; } else if ( a [ i ] == 'D' ) { p = 'E' ; e = e + b [ i ] ; } else if ( a [ i ] == 'L' ) { p = 'N' ; n = n + b [ i ] ; } } else if ( p == 'E' ) { if ( a [ i ]
void findPairs ( int [ ] x , int [ ] y , int K ) { int n = x . length ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { if ( K * Math . abs ( x [ i ] - x [ j ] ) >= Math . abs ( y [ i ] - y [ j ] ) ) { ++ ans ; } } } System . out . println ( ans ) ; }
void pyramidSlantHeight ( double pyramid_h , double pyramid_s ) { double slant_height_pyramid = Math . sqrt ( Math . pow ( pyramid_s / 2 , 2 ) + Math . pow ( pyramid_h , 2 ) ) ; System . out . println ( "Slant height of pyramid is: " + slant_height_pyramid ) ; }
double Area_Parallelogram2 ( int a , int b , int gamma ) { double area = ( Math . abs ( Math . sin ( Math . toRadians ( gamma ) ) ) ) * Math . abs ( a * b ) ; return area ; }
int No_of_rectangles ( int L , int B , int l , int b ) { if ( ( l > L ) || ( b > B ) ) { return - 1 ; } else { return ( L - l + 1 ) * ( B - b + 1 ) ; } }
float Area_of_Rhombus ( int a , int theta ) { float area = ( float ) ( ( a * a ) * Math . sin ( ( RADIAN * theta ) ) ) ; return area ; }
int nCr ( int n , int r ) { return ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) ; }
float distanceEndpoints ( int a , int b , float c ) { float angle = cal_cos ( c ) ; return ( float ) Math . sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; }
void perpenBisectorFromLine ( point P , point Q , double a , double b , double c ) { point mid_point = new point ( ) ; mid_point . x = ( P . x + Q . x ) / 2 ; mid_point . y = ( P . y + Q . y ) / 2 ; c = - b * ( mid_point . x ) + a * ( mid_point . y ) ; double temp = a ; a = - b ; b = temp ; }
float circlearea ( float R ) { if ( R < 0 ) return - 1 ; float a = ( float ) ( 3.14 * R * R / 4 ) ; return a ; }
int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; }
double area ( double d1 , double a ) { double d2 = Math . sqrt ( 4 * ( a * a ) - d1 * d1 ) ; double area = 0.5 * d1 * d2 ; return area ; }
float areaOfKite ( int d1 , int d2 ) { float area = ( d1 * d2 ) / 2 ; return area ; }
void findTriangles ( int n ) { int num ; num = n * ( n - 4 ) ; System . out . println ( num ) ; }
int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }
float normal ( float m , float n ) { float N = ( float ) ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ) ; return N ; }
boolean isPossible ( int a [ ] , int n ) { int sum = 0 , maxS = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; maxS = Math . max ( a [ i ] , maxS ) ; } if ( ( sum - maxS ) > maxS ) return true ; return false ; }
boolean pointIsOnLine ( int m , int c , int x , int y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
double polyarea ( double n , double a ) { if ( a < 0 && n < 0 ) return - 1 ; double A = ( a * a * n ) / ( 4 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; }
double heptdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.802 * a ; return d ; }
float trianglearea ( float a ) { if ( a < 0 ) return - 1 ; float area = ( 3 * ( float ) Math . sqrt ( 3 ) * ( float ) Math . pow ( a , 2 ) ) / 4 ; return area ; }
void circle_equation ( double x1 , double y1 , double r ) { double a = - 2 * x1 ; double b = - 2 * y1 ; double c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; System . out . print ( "x^2 + (" + a + " x) + " ) ; System . out . print ( "y^2 + (" + b + " y) = " ) ; System . out . print ( c + "." ) ; }
float Perimeter ( float s , int n ) { float perimeter = 1 ; perimeter = n * s ; return perimeter ; }
long dis ( long x1 , long y1 , long x2 , long y2 ) { return Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; }
float area ( float b , float h ) { return ( 1 * b * h ) / 2 ; }
float findRadiusOfIncircle ( float a , float b , float c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; float p = ( a + b + c ) / 2 ; float area = ( float ) Math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; float radius = area / p ; return radius ; }
void findVolume ( db u , db v , db w , db U , db V , db W , db b ) { db uPow = ( int ) Math . pow ( u , 2 ) ; db vPow = ( int ) Math . pow ( v , 2 ) ; db wPow = ( int ) Math . pow ( w , 2 ) ; db UPow = ( int ) Math . pow ( U , 2 ) ; db VPow = ( int ) Math . pow ( V , 2 ) ; db WPow = ( int ) Math . pow ( W , 2 ) ; db a = 4 * ( uPow * vPow * wPow ) - uPow * ( int ) Math . pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * ( int ) Math . pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * ( int ) Math . pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ; db vol = ( int ) Math . sqrt ( a ) ; vol /= b ; System . out . println ( vol ) ; }
float rectanglearea ( float r ) { if ( r < 0 ) return - 1 ; float a = r * r ; return a ; }
int findMaximumPieces ( int n ) { int x = n / 2 ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; }
int solve ( double M , double N , double s ) { int ans = ( ( int ) ( Math . ceil ( M / s ) ) * ( int ) ( Math . ceil ( N / s ) ) ) ; return ans ; }
int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
void center ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( x1 + x2 ) / 2 + ", " + ( y1 + y2 ) / 2 ) ; }
double vol_of_octahedron ( double side ) { return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) ) ; }
double circumference ( double r ) { double cir = 2 * PI * r ; return cir ; }
void floodFillUtil ( char mat [ ] [ ] , int x , int y , char prevV , char newV ) { if ( x < 0 x >= M y < 0 y >= N ) return ; if ( mat [ x ] [ y ] != prevV ) return ; mat [ x ] [ y ] = newV ; floodFillUtil ( mat , x + 1 , y , prevV , newV ) ; floodFillUtil ( mat , x - 1 , y , prevV , newV ) ; floodFillUtil ( mat , x , y + 1 , prevV , newV ) ; floodFillUtil ( mat , x , y - 1 , prevV , newV ) ; }
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
double area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return Math . abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; }
int numberOfDiagonals ( int n ) { return n * ( n - 3 ) / 2 ; }
int orientation ( pair a , pair b , pair c ) { int res = ( b . second - a . second ) * ( c . first - b . first ) - ( c . second - b . second ) * ( b . first - a . first ) ; if ( res == 0 ) return 0 ; if ( res > 0 ) return 1 ; return - 1 ; }
int countLattice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int ySquare = r * r - x * x ; int y = ( int ) Math . sqrt ( ySquare ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }
int minimumCost ( int arr [ ] , int N , int X , int Y ) { int even_count = 0 , odd_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] % 1 ) != 0 && ( i % 2 == 0 ) ) { odd_count ++ ; } if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) != 0 ) { even_count ++ ; } } int cost1 = X * Math . min ( odd_count , even_count ) ; int cost2 = Y * ( Math . max ( odd_count , even_count ) - Math . min ( odd_count , even_count ) ) ; int cost3 = ( odd_count + even_count ) * Y ; return Math . min ( cost1 + cost2 , cost3 ) ; }
double root ( double num , int p ) { double left = - num ; double right = num ; double x ; while ( true ) { x = ( left + right ) / 2.0 ; double value = f ( x , p , num ) ; double prime = f_prime ( x , p ) ; if ( value * prime <= 0 ) left = x ; else right = x ; if ( value < 0.000001 && value >= 0 ) { return x ; } } }
int countTriplets ( int N ) { int cnt = 0 ; for ( int A = 1 ; A <= N ; ++ A ) { for ( int B = 1 ; B <= N / A ; ++ B ) { cnt += N / ( A * B ) ; } } return cnt ; }
void nearestRight ( int arr [ ] , int N , int [ ] steps ) { int R = 2 * N ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { R = N + i ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { R = i ; } steps [ i ] = Math . min ( steps [ i ] , R - i ) ; } }
void updateArray ( int [ ] arr , int K ) { int sum = 0 ; Vector < Integer > res = new Vector < Integer > ( ) ; for ( int i = 0 ; i < ( int ) arr . length ; i ++ ) { if ( arr [ i ] < K ) { sum += arr [ i ] ; } else { if ( sum != 0 ) { res . add ( sum ) ; } sum = 0 ; res . add ( arr [ i ] ) ; } } if ( sum != 0 ) res . add ( sum ) ; for ( int it : res ) System . out . print ( it + " " ) ; }
String checkSameDigits ( int N ) { int digit = N % 10 ; while ( N != 0 ) { int current_digit = N % 10 ; N = N / 10 ; if ( current_digit != digit ) { return "No" ; } } return "Yes" ; }
int maxPossibleMoves ( int X , int Y , int A , int B ) { int ans = 0 ; int L = 1 , R = MAXN ; while ( L <= R ) { int Mid = ( L + R ) / 2 ; if ( can ( Mid , X , Y , A , B ) ) { L = Mid + 1 ; ans = Math . max ( ans , Mid ) ; } else { R = Mid - 1 ; } } return ans ; }
int possiblePair ( int X , int Y ) { int Z = Y - X ; if ( Z < 0 ) { System . out . print ( "-1" ) ; return 0 ; } for ( int k = 0 ; k < MaxBit ; k ++ ) { int bit1 = ( Z >> k ) & 1 ; int bit2 = ( Z >> k ) & 1 ; if ( bit1 != 0 && bit2 != 0 ) { System . out . print ( "-1" ) ; return 0 ; } } System . out . print ( Z + " " + X ) ; return 0 ; }
int minSumDifference ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ar [ i ] ; int rem = sum % n ; return rem * ( n - rem ) ; }
int minSteps ( int N ) { int res = ( int ) ( Math . sqrt ( 1 + 8 * N ) - 1 ) / 2 ; return res ; }
void oppositeFaceOfDice ( int N ) { int ans = 7 - N ; System . out . println ( ans ) ; }
void IsEvenPath ( int Source [ ] , int Destination [ ] ) { int x_dif = Math . abs ( Source [ 0 ] - Destination [ 0 ] ) ; int y_dif = Math . abs ( Source [ 1 ] - Destination [ 1 ] ) ; int minsteps = x_dif + y_dif ; if ( minsteps % 2 == 0 ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
void findFraction ( long x , long y , long n ) { long A = - 1 , B = - 1 ; for ( long i = 1 ; i <= n ; i ++ ) { long d = ( i * x ) / y ; if ( d >= 0 && ( A == - 1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d ; B = i ; d ++ ; if ( d >= 0 && ( A == - 1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d ; B = i ; } System . out . println ( A + "/" + B ) ; }
int countKAverageSubarrays ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int L = 0 ; L < n ; L ++ ) { int sum = 0 ; for ( int R = L ; R < n ; R ++ ) { sum += arr [ R ] ; int len = ( R - L + 1 ) ; if ( sum % len == 0 ) { int avg = sum / len ; if ( avg == k ) res ++ ; } } } return res ; }
int power ( int x , int y ) { int res = 1 ; while ( y > 0 ) { if ( y % 2 == 1 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }
void numberOfPairs ( int N , int [ ] [ ] arr ) { ArrayList < ArrayList < Integer > > adj = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i : arr ) { adj . add ( new ArrayList < Integer > ( ) ) ; } for ( int i : adj ) { adj . get ( i [ 0 ] ) . add ( i [ 1 ] ) ; adj . get ( i [ 1 ] ) . add ( i [ 0 ] ) ; } boolean [ ] visited = new boolean [ N ] ; ArrayList < Integer > v = new ArrayList < Integer > ( ) ; int num = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! visited [ i ] ) { dfs ( i , adj , visited , num ) ; v . add ( num ) ; num = 0 ; } } int ans = N * ( N - 1 ) / 2 ; for ( int i : v ) { ans -= ( i * ( i - 1 ) / 2 ) ; } System . out . println ( ans ) ; }
void isPossible ( int W , int B , int D ) { if ( W > B ) { int temp = W ; W = B ; B = temp ; } if ( B > W * ( D + 1 ) ) System . out . println ( "NO" ) ; else System . out . println ( "YES" ) ; }
int tripletAndSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & ( 1 << bit ) ) != 0 ) cnt ++ ; } ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) / 6 ; } return ans ; }
int largestK ( int A [ ] , int N ) { int l = 0 , r = N - 1 , flag = 0 ; while ( l < r ) { if ( A [ l ] != A [ r ] ) { flag = 1 ; break ; } l ++ ; r -- ; } if ( flag == 0 ) return - 1 ; int K = Math . abs ( A [ 0 ] - A [ N - 1 ] ) ; for ( int i = 1 ; i < N / 2 ; i ++ ) K = gcd ( K , Math . abs ( A [ i ] - A [ N - i - 1 ] ) ) ; return K ; }
void NumberofSets ( int N ) { SieveOfEratosthenes ( N ) ; if ( N == 2 ) { System . out . println ( 1 ) ; } else if ( N == 3 ) { System . out . println ( 2 ) ; } else { int ans = 1 ; for ( int i = N / 2 + 1 ; i <= N ; i ++ ) { if ( prime [ i ] ) { ans += 1 ; } } System . out . println ( ans ) ; } }
int sumOfDivisors ( int N ) { return N ; }
boolean findDigit ( int N , int D ) { while ( N > 0 ) { int a = N % 10 ; if ( a == D ) { return true ; } N /= 10 ; } return false ; }
int findXORS ( int arr1 [ ] , int arr2 [ ] , int N , int M ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int temp = arr1 [ i ] & arr2 [ j ] ; res ^= temp ; } } return res ; }
float findMedian ( Node root , int node1 , int node2 ) { ArrayList < Integer > interNodes = new ArrayList < > ( ) ; getIntermediateNodes ( root , interNodes , node1 , node2 ) ; int nSize = interNodes . size ( ) ; return ( nSize % 2 == 1 ) ? ( float ) interNodes . get ( nSize / 2 ) : ( float ) ( interNodes . get ( ( nSize - 1 ) / 2 ) + interNodes . get ( nSize / 2 ) ) / 2 ; }
void findDifference ( int N ) { int [ ] s = new int [ N + 1 ] ; sieveOfEratosthenes ( N , s ) ; int total = 1 , odd = 1 , even = 0 ; int curr = s [ N ] ; int cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } if ( curr == 2 ) { total = total * ( cnt + 1 ) ; } else { total = total * ( cnt + 1 ) ; odd = odd * ( cnt + 1 ) ; } curr = s [ N ] ; cnt = 1 ; } even = total - odd ; System . out . println ( Math . abs ( even - odd ) ) ; }
void countPrime ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; SieveOfEratosthenes ( n , prime ) ; int [ ] dp = new int [ n + 1 ] ; Arrays . fill ( dp , 0 ) ; dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] += dp [ i - 1 ] ; if ( prime [ i ] == 1 && prime [ i - 2 ] == 1 ) { dp [ i ] ++ ; } } System . out . print ( dp [ n ] ) ; }
int findGCD ( int a , int b ) { if ( b == 0 ) return a ; return findGCD ( b , a % b ) ; }
int findLCM ( int a , int b ) { return ( a * b ) / findGCD ( a , b ) ; }
int convert ( ArrayList < Integer > p ) { int ans = 0 ; for ( int i : p ) { ans = ( ans << 1 ) | i ; } return ans ; }
boolean check ( ArrayList < ArrayList < Integer > > Adj , int Src , int N , boolean visited [ ] ) { int [ ] color = new int [ N ] ; visited [ Src ] = true ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( Src ) ; while ( ! q . isEmpty ( ) ) { int u = q . peek ( ) ; q . poll ( ) ; int Col = color [ u ] ; for ( int x : Adj . get ( u ) ) { if ( visited [ x ] == true && color [ x ] == Col ) { return false ; } else if ( visited [ x ] == false ) { visited [ x ] = true ; q . add ( x ) ; color [ x ] = 1 - Col ; } } } return true ; }
double average ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; return ( double ) sum / N ; }
void checkWinner ( int arr [ ] , int N ) { int diff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { diff -= arr [ i ] ; } if ( diff % 2 == 0 ) { System . out . print ( "A" ) ; } else { System . out . print ( "B" ) ; } }
int countAPs ( int S , int D ) { S = S * 2 ; int answer = 0 ; for ( int i = 1 ; i <= Math . sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { if ( ( ( S / i ) - D * i + D ) % 2 == 0 ) answer ++ ; if ( ( D * i - ( S / i ) + D ) % 2 == 0 ) answer ++ ; } } return answer ; }
void buildSieve ( ) { for ( int i = 2 ; i < 100 ; i ++ ) sieve [ i ] = 1 ; for ( int i = 2 ; i < 100 ; i ++ ) { if ( sieve [ i ] == 1 ) { for ( int j = i * i ; j < 100 ; j += i ) sieve [ j ] = 0 ; } } }
int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; }
int numOfPairs ( String [ ] arr , int N ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( coprime ( Integer . parseInt ( arr [ i ] ) , Integer . parseInt ( arr [ j ] ) ) ) { count = count + 1 ; } } } return count ; }
int countPairs ( int arr [ ] , int N ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . containsKey ( ( int ) ( Math . log ( arr [ i ] ) ) ) freq . put ( ( int ) ( Math . log ( arr [ i ] ) , freq . get ( ( int ) ( Math . log ( arr [ i ] ) ) + 1 ) ; else freq . put ( ( int ) ( Math . log ( arr [ i ] ) ) , 1 ) ; } int pairs = 0 ; for ( Map . Entry < Integer , Integer > i : freq . entrySet ( ) ) { pairs += i . getValue ( ) - 1 ; } return pairs ; }
int sumOfDigits ( int N ) { int sum = 0 ; while ( N != 0 ) { sum += N % 10 ; N /= 10 ; } return sum ; }
