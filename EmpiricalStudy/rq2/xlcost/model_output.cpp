bool sumOfTwoCubes ( int n ) { int lo = 1 , hi = cbrt ( n ) ; while ( lo <= hi ) { int curr = ( lo * lo * lo + hi * hi * hi ) ; if ( curr == n ) return true ; if ( curr < n ) lo ++ ; else hi -- ; } return false ; }
int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] != 0 && a [ i ] % a [ j ] == 0 ) { if ( ( a [ i ] + a [ j ] ) == ( a [ i ] / a [ j ] ) ) count ++ ; } } } return count ; }
int check ( int A , int B ) { if ( A == B ) { return 1 ; } int dig1 = floor ( log10 ( A ) + 1 ) ; int dig2 = floor ( log10 ( B ) + 1 ) ; if ( dig1 != dig2 ) { return 0 ; } int temp = A ; while ( true ) { int power = pow ( 10 , dig1 - 1 ) ; int firstdigit = A / power ; A = A - firstdigit * power ; A = A * 10 + firstdigit ; if ( A == B ) { return 1 ; } if ( A == temp ) { return 0 ; } } }
bool checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( sqrt ( x ) ) ; i ++ ) { if ( ( x == i * ( i + 1 ) ) != false ) { return true ; } } return false ; }
void oddDivisors ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int powerOfTwo = 2 ; int count = 0 ; while ( powerOfTwo <= arr [ i ] ) { count ++ ; powerOfTwo = 2 * powerOfTwo ; } cout << count << " " ; } return ; }
int calcScr ( vector < int > arr ) { int ans = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) ans += ( i ^ arr [ i ] ) ; return ans ; }
void maxAdjacent ( int arr [ ] , int N ) { vector < int > res ; int arr_max = INT_MIN ; for ( int i = 1 ; i < N ; i ++ ) { arr_max = max ( arr_max , abs ( arr [ i - 1 ] - arr [ i ] ) ) ; } for ( int i = 1 ; i < N - 1 ; i ++ ) { int curr_max = abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; int ans = max ( curr_max , arr_max ) ; res . push_back ( ans ) ; } for ( auto x : res ) cout << x << " " ; cout << endl ; }
void flippingBits ( unsigned int N , unsigned int K ) { unsigned int X = ( 1 << ( K - 1 ) ) - 1 ; N = X - N ; cout << N ; }
unsigned int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
void minMoves ( int arr [ ] , int N ) { int odd_element_cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } int moves = ( odd_element_cnt ) / 2 ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; cout << moves ; }
int findSum ( int arr [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } int sum_odd = 0 , sum_even = 0 ; for ( auto m : mp ) { int key = m . first ; int val = m . second ; if ( val % 2 != 0 ) sum_odd += ( key ) * ( val ) ; if ( val % 2 == 0 ) sum_even += ( key ) * ( val ) ; } int diff = sum_even - sum_odd ; return diff ; }
int findNumber ( int arr [ ] , int n ) { int res = 0 ; int maxElement = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res = res ^ arr [ i ] ; if ( maxElement < arr [ i ] ) maxElement = arr [ i ] ; } res = onesComplement ( res , maxElement ) ; return ( res ) ; }
int findValOfNWithOperat ( int N , int K ) { if ( N % 2 == 0 ) { N += K * 2 ; } else { N += smallestDivisorGr1 ( N ) + ( K - 1 ) * 2 ; } return N ; }
int CntOfSubsetsByPartitioning ( int arr [ ] , int N ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } int freqGCD = 0 ; for ( auto i : freq ) { freqGCD = __gcd ( freqGCD , i . second ) ; } return ( N ) / freqGCD ; }
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { alternateSum += - i ; } else { alternateSum += i ; } } return alternateSum ; }
int countOperations ( int arr [ ] , int N ) { int count_zeros = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) count_zeros ++ ; } int sum = array_sum ( arr , N ) ; if ( count_zeros != 0 ) return count_zeros ; if ( sum == 0 ) return 1 ; return 0 ; }
int power ( int x , int N ) { int res = 1 ; while ( N > 0 ) { if ( N & 1 ) { res = ( res * x ) ; } x = ( x * x ) ; N = N >> 1 ; } return res ; }
ll F_1 ( ll N , ll F_N ) { ll P_2 = power ( 2 , N - 1 ) ; ll modInv = moduloInverse ( P_2 ) ; ll res ; res = ( ( modInv % M ) * ( F_N % M ) ) % M ; return res ; }
void findNumbers ( int n ) { int i = 0 ; while ( i <= n ) { cout << 2 * i * i + 4 * i + 1 + i % 2 << " " ; i ++ ; } }
bool isPower ( int x , int y ) { double res1 = log ( y ) / log ( x ) ; double res2 = log ( y ) / log ( x ) ; return ( res1 == res2 ) ; }
int countPairs ( int A [ ] , int B [ ] , int N , int M , vector < pair < int , int > > List ) { int count = 0 ; int par [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) par [ i ] = i ; for ( int i = 0 ; i < M ; i ++ ) { int index1 = find ( par , List [ i ] . first - 1 ) ; int index2 = find ( par , List [ i ] . second - 1 ) ; if ( index1 != index2 ) { union ( par , index1 , index2 ) ; } } map < int , int > map ; for ( int i = 0 ; i < N ; i ++ ) { map [ A [ i ] ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { if ( map . find ( B [ i ] ) == map . end ( ) ) { count ++ ; continue ; } int j = map [ B [ i ] ] ; if ( find ( par , i ) != find ( par , j ) ) count ++ ; } } return count ; }
void minDivisior ( int n ) { if ( prime ( n ) ) { cout << 1 << " " << n - 1 ; } else { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { cout << n / i << " " << ( n / i * ( i - 1 ) ) ; break ; } } } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int Find_min ( set < int > diff_mod , map < int , int > count_mod , int k ) { int min_oprn = INT_MAX ; int oprn = 0 ; for ( int x = 0 ; x < k ; x ++ ) { oprn = 0 ; for ( auto w : diff_mod ) { if ( w != x ) { if ( w == 0 ) { oprn += min ( x , k - x ) * count_mod [ w ] ; } else { oprn += min ( abs ( x - w ) , k + x - w ) * count_mod [ w ] ; } } } if ( oprn < min_oprn ) min_oprn = oprn ; } return min_oprn ; }
double maxSubarrayRatio ( double arr [ ] , int n ) { double maxRatio = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { double ratio = arr [ i ] ; for ( int k = i + 1 ; k <= j ; k ++ ) { ratio = ratio / arr [ k ] ; } maxRatio = maximum ( maxRatio , ratio ) ; } } return maxRatio ; }
bool is_possible ( int x , int y ) { if ( x < 2 && y != 0 ) return 0 ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return 1 ; else return 0 ; }
int sum_of_differences ( int arr [ ] , int N ) { int sum = 0 ; int i , j , flag ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) { flag = 0 ; for ( j = i + 1 ; j < N ; j ++ ) { if ( arr [ j ] >= arr [ j + 1 ] ) { sum += ( arr [ j ] - arr [ i ] ) ; i = j ; flag = 1 ; break ; } } if ( flag == 0 && arr [ i ] < arr [ N - 1 ] ) { sum += ( arr [ N - 1 ] - arr [ i ] ) ; break ; } } } return sum ; }
void getLastTwoPerson ( int n ) { int total = n ; struct Node * head = { 1 } ; struct Node * temp = head ; for ( int i = 2 ; i <= n ; i ++ ) { temp -> next = { i } ; temp = temp -> next ; } temp -> next = head ; temp = head ; struct Node * del ; while ( total != 2 ) { del = temp -> next -> next ; temp -> next -> next = temp -> next -> next -> next ; temp = temp -> next ; free ( del ) ; total -= 1 ; } cout << temp -> val << " " << temp -> next -> val ; }
int gcd ( int x , int y ) { if ( x == 0 ) return y ; return gcd ( y % x , x ) ; }
bool check ( int n ) { int temp = n ; while ( temp > 0 ) { int last_digit = temp % 10 ; if ( last_digit == 0 last_digit == 1 ) return false ; if ( n % last_digit == 0 ) return false ; temp = temp / 10 ; } return true ; }
void costOfSubsequence ( int N , int arr [ ] , int costArray [ ] ) { int i , temp ; int cost = 0 ; unordered_set < int > removedElements ; int ans = 0 ; for ( i = 1 ; i < ( N - 1 ) ; i ++ ) { temp = arr [ i ] ; if ( ( ( arr [ i - 1 ] < temp ) && ( temp < arr [ i + 1 ] ) ) || ( ( arr [ i - 1 ] > temp ) && ( temp > arr [ i + 1 ] ) ) ) { removedElements . insert ( temp ) ; } } for ( i = 0 ; i < ( N ) ; i ++ ) { temp = arr [ i ] ; if ( removedElements . find ( temp ) == removedElements . end ( ) ) { ans += arr [ i ] ; } else { cost += costArray [ i ] ; } } cout << ans << ", " ; cout << cost ; }
void findRatio ( int arr [ ] , int n ) { int gcd = __gcd ( arr , n ) ; int lcm = __lcm ( arr , n ) ; cout << ( lcm / gcd ) ; cout << ":1" ; }
int PentacontahenagonNum ( int N ) { return ( 49 * N * N - 47 * N ) / 2 ; }
bool isRepdigit ( int num , int b ) { int prev = -1 ; while ( num ) { int digit = num % b ; num /= b ; if ( prev != -1 && digit != prev ) return false ; prev = digit ; } return true ; }
bool isHonakerPrime ( int n ) { int pos = position [ n ] ; if ( pos == -1 ) return false ; return getSum ( n ) == getSum ( pos ) ; }
bool checkDivisibility ( int n , int digit ) { return ( digit && n % digit == 0 ) ; }
int lastDigit ( int n ) { return ( n % 10 ) ; }
int count ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( check ( arr [ i ] & arr [ j ] ) ) cnt ++ ; } } return cnt ; }
void calculate_SPF ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i <= MAX ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i <= MAX ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j <= MAX ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
bool isBrilliant ( int n ) { int flag = 0 ; bool isPrime [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 2 ; i < n ; i ++ ) { int x = n / i ; if ( isPrime [ i ] && isPrime [ x ] && ( x * i ) == n ) { if ( countDigit ( i ) == countDigit ( x ) ) return true ; } } return false ; }
int icosikaienneagonalNum ( int n ) { return ( 27 * n * n - 25 * n ) / 2 ; }
bool isPerfectTotientNum ( int n ) { int temp = n ; int sum = 0 ; while ( n > 1 ) { sum = sum + phi ( n ) ; n = phi ( n ) ; } if ( sum == temp ) return true ; return false ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
void solve ( int N ) { int ans = 0 ; while ( N ) { ans += N ; N /= 2 ; } cout << ans << endl ; }
void smallestNumber ( int N ) { int L = pow ( 10 , N ) - 1 ; int S = pow ( 10 , N - 1 ) ; for ( int i = S ; i <= L ; i ++ ) { if ( i % N == 0 ) { cout << i ; return ; } } }
int maxAdjacentDifference ( int N , int K ) { if ( N == 1 ) { return 0 ; } if ( N == 2 ) { return K ; } return 2 * K ; }
int CountPairs ( int arr [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return ( even * ( even - 1 ) ) / 2 + ( even * odd ) ; }
int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
void smallestNumber ( int N ) { int i = 1 ; while ( 1 ) { if ( getSum ( i ) == N ) { cout << i ; break ; } i ++ ; } }
bool isZuckerman ( int n ) { return n % getProduct ( n ) == 0 ; }
bool isGiugaNum ( int n ) { if ( ! ( isComposite ( n ) ) ) return false ; int N = n ; while ( n % 2 == 0 ) { if ( ( N / 2 - 1 ) % 2 != 0 ) return false ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( ( N / i - 1 ) % i != 0 ) return false ; n = n / i ; } } if ( n > 2 ) if ( ( N / n - 1 ) % n != 0 ) return false ; return true ; }
void updateFreq ( int n , int freq [ ] ) { while ( n ) { int digit = n % TEN ; freq [ digit ] ++ ; n /= TEN ; } }
bool OrmistonPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && areAnagrams ( n1 , n2 ) ) ; }
int calculateKummer ( int n ) { int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result = result * primes [ i ] ; return -1 + result ; }
void SieveOfEratosthenes ( int maxm ) { prime [ 0 ] = prime [ 1 ] = true ; for ( int i = 2 ; i * i <= maxm ; i ++ ) { if ( ! prime [ i ] ) { for ( int j = i * i ; j <= maxm ; j += i ) { prime [ j ] = true ; } } } }
ll func ( int arr [ ] , int n ) { ll ans = 0 ; int maxx = 0 ; double freq [ 100005 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = max ( maxx , temp ) ; } for ( int i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( int i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] != 0 ) { double j ; double cur = ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { int val = min ( maxx , ( ceil ( i * j ) - 1.0 ) ) ; int times = ( freq [ i ] - freq [ i - 1 ] ) , con = ( j - 0.5 ) ; ans += times * con * ( freq [ val ] - freq [ cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ( ll ) ans ; }
double findAverageOfCube ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * i * i ; } return sum / n ; }
int find ( int x ) { if ( x == 0 ) return 0 ; int p = log2 ( x ) ; return binpow ( 2 , p + 1 ) - 1 ; }
int totalCountDifference ( int n ) { string ans = getBinary ( n ) ; int req = 0 ; for ( int i = 0 ; i < ans . length ( ) ; i ++ ) { if ( ans [ i ] == '1' ) { req += find ( binpow ( 2 , i ) ) ; } } return req ; }
int findIndex ( int n ) { double x = sqrt ( 2 * pow ( 10 , ( n - 1 ) ) ) ; return round ( x ) ; }
void getParity ( int n , vector < int > A ) { for ( auto x : A ) { if ( x & 1 ) { cout << "Even" << endl ; return ; } } cout << "Odd" << endl ; }
void lastTwoDigits ( int N ) { if ( N >= 10 ) { cout << "00" ; return ; } int fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fac = ( fac * i ) % 100 ; cout << fac ; }
int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }
int findArrangement ( int N ) { if ( N < 3 ) return 0 ; return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) / 3 ; }
int sumOfProductOfDigits ( int n1 , int n2 ) { int sum = 0 ; while ( n1 > 0 && n2 > 0 ) { sum += ( ( n1 % 10 ) * ( n2 % 10 ) ) ; n1 /= 10 ; n2 /= 10 ; } return sum ; }
bool divisorsSame ( int n ) { return ( n - 2 ) % 4 == 0 ; }
int countSubsequences ( int arr [ ] , int n ) { int totalSubsequence = pow ( 2 , n ) - 1 ; int countPrime = 0 , countOnes = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) countOnes ++ ; else if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } int compositeSubsequence ; int onesSequence = pow ( 2 , countOnes ) - 1 ; compositeSubsequence = totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ; return compositeSubsequence ; }
int Centered_Hexadecagonal_num ( int n ) { return ( 8 * n * n - 8 * n + 1 ) ; }
bool isdecagonal ( int N ) { float n = ( 3 + sqrt ( 16 * N + 9 ) ) / 8 ; return ( n - ( int ) n ) == 0 ; }
bool ishendecagonal ( int N ) { float n = ( 7 + sqrt ( 72 * N + 49 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; }
bool isenneadecagonal ( int N ) { float n = ( 15 + sqrt ( 136 * N + 225 ) ) / 34 ; return ( n - ( int ) n ) == 0 ; }
bool isPowerOfTwo ( unsigned int n ) { return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; }
void cntArray ( int A [ ] , int N ) { int result = 0 ; int frequency [ N + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { frequency [ A [ i ] ] ++ ; } for ( int i = 1 ; i <= N ; i ++ ) { int frequency_of_i = frequency [ i ] ; result += ( ( frequency_of_i ) * ( frequency_of_i + 1 ) ) / 2 ; } cout << result ; }
string solve ( vector < int > A ) { int i , ctr = 0 ; for ( i = 0 ; i < A . size ( ) ; i ++ ) { if ( A [ i ] & 1 ) { ctr ++ ; } } if ( ctr % 2 == 1 ) { return "No" ; } else { return "Yes" ; } }
void findNumbers ( int N ) { for ( int i = 1 ; i <= N / 2 ; i ++ ) { cout << i << ", " << - i << ", " ; } if ( N % 2 == 1 ) cout << 0 ; }
int previousPerfectSquare ( int N ) { int prevN = floor ( sqrt ( N ) ) ; if ( prevN * prevN == N ) prevN -= 1 ; return prevN * prevN ; }
int digit_sum ( int n ) { int sum = 0 , m ; while ( n > 0 ) { m = n % 10 ; sum = sum + m ; n = n / 10 ; } return ( sum ) ; }
void dfs ( int node , int parent ) { if ( isPerfect ( weight [ node ] ) ) ans += 1 ; for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } }
int MinimumGCD ( int arr [ ] , int n ) { int g = 0 ; for ( int i = 0 ; i < n ; i ++ ) { g = __gcd ( g , arr [ i ] ) ; } return g ; }
void fibonacciSubarrays ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int sum = 0 ; for ( int j = i ; j < n ; ++ j ) { sum += arr [ j ] ; if ( isFibonacci ( sum ) ) { ++ count ; } } } cout << count ; }
float Gill ( float x0 , float y0 , float x , float h ) { int n = ( int ) ( ( x - x0 ) / h ) ; float k1 , k2 , k3 , k4 ; float y = y0 ; for ( int i = 1 ; i <= n ; i ++ ) { k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; k3 = h * dydx ( x0 + 0.5 * h , y + 0.5 * ( -1 + sqrt ( 2 ) ) * k1 + k2 * ( 1 - 0.5 * sqrt ( 2 ) ) ) ; k4 = h * dydx ( x0 + h , y - ( 0.5 * sqrt ( 2 ) ) * k2 + k3 * ( 1 + 0.5 * sqrt ( 2 ) ) ) ; y = y + ( 1.0 / 6 ) * ( k1 + ( 2 - sqrt ( 2 ) ) * k2 + ( 2 + sqrt ( 2 ) ) * k3 + k4 ) ; x0 = x0 + h ; } return y ; }
void PythagoreanTriplet ( int n ) { int flag = 0 ; for ( int a = 1 ; a < n ; a ++ ) { int b = ( n * n - 2 * n * a ) / ( 2 * n - 2 * a ) ; int c = n - a - b ; if ( a * a + b * b == c * c && b > 0 && c > 0 ) { cout << a << " " << b << " " << c ; flag = 1 ; break ; } } if ( flag == 0 ) { cout << "-1" ; } return ; }
void Display ( int arr [ ] , bool Expo_Prime [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( Expo_Prime [ arr [ i ] ] ) cout << arr [ i ] << " " ; }
float operations ( int N ) { int x = probability ( N ) ; int y = pow ( 2 , N ) ; return round ( x / y , 2 ) ; }
int pairs ( int n ) { int c [ 10 ] [ 10 ] ; int tmp = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ i / tmp ] [ i % 10 ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) for ( int j = 1 ; j < 10 ; j ++ ) ans += c [ i ] [ j ] * c [ j ] [ i ] ; return ans ; }
int gcdFibonacciFreq ( int arr [ ] , int n ) { set < int > hash ; createHash ( hash , * max_element ( arr , arr + n ) ) ; int i ; unordered_map < int , int > m ; for ( i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; int gcd = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( hash . count ( it -> second ) ) { gcd = __gcd ( gcd , it -> first ) ; } } return gcd ; }
string sumBaseB ( string a , string b , int base ) { int len_a , len_b ; len_a = a . size ( ) ; len_b = b . size ( ) ; string sum , s ; sum = "" ; int diff ; diff = abs ( len_a - len_b ) ; for ( int i = 1 ; i <= diff ; i ++ ) s += "0" ; if ( len_a < len_b ) a = s + a ; else b = s + b ; int curr , carry = 0 ; for ( int i = max ( len_a , len_b ) - 1 ; i > -1 ; i -- ) { curr = carry + ( a [ i ] - '0' ) + ( b [ i ] - '0' ) ; carry = curr / base ; curr = curr % base ; sum = ( char ) ( curr + '0' ) + sum ; } if ( carry > 0 ) sum = ( char ) ( carry + '0' ) + sum ; return sum ; }
bool isPerfectCube ( int x ) { long long cr = round ( cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; }
int countPairsWithProdK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == k ) count ++ ; } return count ; }
void genArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( search ( arr , i , arr [ i ] ) == -1 ) arr [ i + 1 ] = 0 ; else arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) ; } }
vector < int > getPerfectcubes ( int n ) { vector < int > perfectcubes ; int current = 1 ; int i = 1 ; while ( current <= n ) { perfectcubes . push_back ( current ) ; i += 1 ; current = pow ( i , 3 ) ; } return perfectcubes ; }
map < int , int > insertPF ( map < int , int > & primeFact , int fact ) { if ( primeFact . find ( fact ) != primeFact . end ( ) ) { int freq ; freq = primeFact [ fact ] ; primeFact [ fact ] = ++ freq ; } else { primeFact [ fact ] = 1 ; } return primeFact ; }
void isPerfectSquare ( int x ) { int sr = sqrt ( x ) ; if ( sr * sr == x ) cout << "Yes" ; else cout << "No" ; }
void canBePerfectCube ( int N , int K ) { if ( isPerfectCube ( N + K ) || isPerfectCube ( N - K ) == true ) cout << "Yes" << endl ; else cout << "No" << endl ; }
int summation ( int n ) { int abs_sum = n * ( n + 1 ) / 2 ; int sign = n + 1 % 2 == 0 ? 1 : -1 ; int result_sum = sign * abs_sum ; return result_sum ; }
vector < int > findArray ( int xorr [ ] , int n ) { vector < int > arr ; int xor_all = xor_all_elements ( n ) ; int xor_adjacent = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { xor_adjacent = xor_adjacent ^ xorr [ i ] ; } int last_element = xor_all ^ xor_adjacent ; arr . push_back ( last_element ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { last_element = xorr [ i ] ^ last_element ; arr . push_back ( last_element ) ; } return arr ; }
void compute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i ) ; } }
int calNum ( int year ) { return ( year / 4 ) - ( year / 100 ) + ( year / 400 ) ; }
int maxValue ( int n ) { return n ; }
void findSum ( int arr [ ] , int n ) { sieve ( MAX ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = min_prime [ arr [ i ] ] + max_prime [ arr [ i ] ] ; cout << sum << " " ; } }
double squareRoot ( double n , double l ) { double x = n ; double root ; int count = 0 ; while ( true ) { count ++ ; root = 0.5 * ( x + ( n / x ) ) ; if ( abs ( root - x ) < l ) break ; x = root ; } return root ; }
int countNumber ( int N , int S ) { int countElements = 0 ; int currSum = 0 ; while ( currSum <= S ) { currSum += N ; N -- ; countElements ++ ; } return countElements ; }
int countDistinct ( int n ) { int arr [ 10 ] ; int count = 0 ; while ( n ) { int r = n % 10 ; arr [ r ] = 1 ; n /= 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( arr [ i ] ) count ++ ; } return count ; }
int lcm ( int a , int b ) { return ( a / __gcd ( a , b ) * b ) ; }
bool checkZeroArray ( int arr [ ] , int n ) { int sum = 0 , maximum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + arr [ i ] ; maximum = max ( maximum , arr [ i ] ) ; } if ( sum % 2 == 0 && maximum <= sum / 2 ) return true ; return false ; }
long long getSum ( int n ) { int start = pow ( 10 , n - 1 ) ; int end = pow ( 10 , n ) - 1 ; long long sum = 0 ; for ( int i = start ; i <= end ; i ++ ) { string s = to_string ( i ) ; if ( isPalindrome ( s ) ) { sum += i ; } } return sum ; }
int findMinDel ( int arr [ ] , int n ) { int min_num = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) min_num = min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; }
bool isPossible ( int x , int y ) { if ( ( x - y ) == 1 ) return false ; return true ; }
int numSeq ( int n ) { return int ( ( pow ( 3 , n ) + 3 * pow ( -1 , n ) ) / 4 ) ; }
bool digitDividesK ( int num , int k ) { while ( num ) { int d = num % 10 ; if ( d != 0 && k % d == 0 ) return true ; num = num / 10 ; } return false ; }
int xorK ( int n , int k ) { int res = n ; for ( int i = 1 ; i < k ; i ++ ) res = ( res ^ n ) ; return n ; }
bool distinctDigits ( int x ) { bool present [ MAX ] = { false } ; while ( x > 0 ) { int digit = x % 10 ; if ( present [ digit ] ) return false ; present [ digit ] = true ; x /= 10 ; } return true ; }
bool isPossible ( int arr [ ] , int n , int p ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( gcd , arr [ i ] ) ; if ( p % gcd == 0 ) return true ; return false ; }
int cntCakes ( int n , int m ) { int sum = ( n * ( n + 1 ) ) / 2 ; int quo = m / sum ; int rem = m % sum ; double ans = m - quo * sum ; double x = ( -1 + pow ( ( 8 * rem ) + 1 , 0.5 ) ) / 2 ; ans = ans - x * ( x + 1 ) / 2 ; return ans ; }
int factMod ( int n ) { long long int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact *= ( i % MOD ) ; fact %= MOD ; } return fact ; }
bool isEulerPseudoprime ( int N , int A ) { if ( A <= 0 ) return false ; if ( N % 2 == 0 || ! isComposite ( N ) ) return false ; if ( __gcd ( A , N ) != 1 ) return false ; int mod = Power ( A , ( N - 1 ) / 2 , N ) ; if ( mod != 1 && mod != N - 1 ) return false ; return true ; }
int minDifference ( int L , int R ) { int fst = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( isPrime [ i ] ) { fst = i ; break ; } } int snd = 0 ; for ( int i = fst + 1 ; i <= R ; i ++ ) { if ( isPrime [ i ] ) { snd = i ; break ; } } if ( snd == 0 ) return -1 ; int diff = snd - fst ; int left = snd + 1 ; int right = R ; for ( int i = left ; i <= right ; i ++ ) { if ( isPrime [ i ] ) { if ( i - snd <= diff ) { fst = snd ; snd = i ; diff = snd - fst ; } } } return diff ; }
int binomialCoeff ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
int no_of_ways ( int a [ ] , int n ) { int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; } if ( count_1 % 2 == 0 ) return count_0 ; else return count_1 ; }
int longest_gap ( int N ) { int distance = 0 , count = 0 , first_1 = -1 , last_1 = -1 ; while ( N != 0 ) { count ++ ; if ( N & 1 ) { first_1 = first_1 == -1 ? count : first_1 ; last_1 = count ; } N = N / 2 ; } if ( last_1 <= first_1 ) { return -1 ; } else { distance = ( last_1 - first_1 - 1 ) ; return distance ; } }
bool isPossible ( unsigned int n ) { int cnt = __builtin_popcount ( n ) ; if ( cnt == TOTAL_BITS / 2 ) return true ; return false ; }
int total_ways ( int N , int X ) { return ( nCr ( N - 1 , X - 1 ) + nCr ( N - 1 , X ) ) ; }
ll getSum ( int n ) { ll sum = 0 ; int k = sqrt ( n ) ; for ( int i = 1 ; i <= k ; i ++ ) { sum += floor ( n / i ) ; } sum *= 2 ; sum -= pow ( k , 2 ) ; return sum ; }
int getCount ( int l , int r , int p ) { int cnt = 0 ; int val = p ; while ( true ) { int a = r / val ; int b = ( l - 1 ) / val ; val *= p ; if ( ( a - b ) > 0 ) { cnt += ( a - b ) ; } else break ; } return cnt ; }
void heapify ( int arr [ ] , int n , int i ) { int smallest = i ; int l = 2 * i + 1 ; int r = 2 * i + 2 ; if ( l < n && arr [ l ] < arr [ smallest ] ) smallest = l ; if ( r < n && arr [ r ] < arr [ smallest ] ) smallest = r ; if ( smallest != i ) { swap ( arr [ i ] , arr [ smallest ] ) ; heapify ( arr , n , smallest ) ; } }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int nextPrime ( int N ) { if ( N <= 1 ) return 2 ; int prime = N ; bool found = false ; while ( ! found ) { prime ++ ; if ( isPrime ( prime ) ) found = true ; } return prime ; }
void find_Solution ( double x , int n ) { double sum = x , e = 2 , o = 1 , p = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { p += 2 ; sum += ( double ) ( o / e ) * ( double ) ( pow ( x , p ) / p ) ; o = o * ( o + 2 ) ; e = e * ( e + 2 ) ; } cout << sum ; }
void solveOdd ( int n , int * arr , int * b ) { int left = n - 1 ; for ( int i = 0 ; i < ( n / 2 ) + 1 ; ++ i ) { b [ i ] = arr [ left ] ; left = left - 2 ; if ( left < 0 ) break ; } int right = 1 ; for ( int i = ( n / 2 ) + 1 ; i <= n - 1 ; ++ i ) { b [ i ] = arr [ right ] ; right = right + 2 ; if ( right > n - 2 ) break ; } }
int countSetBits ( int n ) { n ++ ; int powerOf2 = 2 ; int cnt = n / 2 ; while ( powerOf2 <= n ) { int totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs % 2 == 1 ) ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; }
int nCr ( int n ) { if ( n < 4 ) return 0 ; int answer = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; answer /= 24 ; return answer ; }
int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
int findReachable ( int arr [ ] , int D , int A , int B , int n ) { int gcd_AB = GCD ( A , B ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - D ) % gcd_AB == 0 ) count ++ ; } return count ; }
int getSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 && arr [ i ] == sumOfFactors ( arr [ i ] ) ) { sum += arr [ i ] ; } } return sum ; }
bool isPossible ( int k ) { if ( ! exists_zero ) { if ( k >= cnt_neg && ( k - cnt_neg ) % 2 == 0 ) return true ; else return false ; } else { if ( k >= cnt_neg ) return true ; else return false ; } }
long long int power ( int x , long long int y ) { long long int res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) ; y = y >> 1 ; x = ( x * x ) ; } return res ; }
long long solve ( int L ) { int n = L / 2 + 1 ; long long ans = power ( n , n - 2 ) ; return ans ; }
ll total_permutations ( map < char , int > & freq ) { ll cnt = 0 ; ll denom = 1 ; for ( auto itr = freq . begin ( ) ; itr != freq . end ( ) ; itr ++ ) { denom *= fact ( itr -> second ) ; cnt += itr -> second ; } return fact ( cnt ) / denom ; }
int solveQuery ( int L , int X ) { int res ; int a [ MAXN ] , b [ L ] ; int refer = X , size_a = 0 ; while ( refer > 0 ) { a [ size_a ] = refer % 2 ; refer /= 2 ; size_a ++ ; } for ( int i = 0 ; i < min ( size_a , L ) ; i ++ ) { if ( a [ i ] == 1 ) b [ i ] = 0 ; else b [ i ] = 1 ; } for ( int i = min ( size_a , L ) ; i < L ; i ++ ) b [ i ] = 1 ; b [ L - 1 ] = 1 ; int temp = 0 , p = 1 ; for ( int i = 0 ; i < L ; i ++ ) { temp += b [ i ] * p ; p *= 2 ; } res = temp ^ X ; return res ; }
int closetAND ( int arr [ ] , int n , int k ) { int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = min ( ans , abs ( k - X ) ) ; if ( X <= k ) break ; } } return ans ; }
int countQuadruplets ( int l , int r , int k ) { int frequency [ r + 1 ] = { 0 } ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = l ; j <= r ; j ++ ) { frequency [ gcd ( i , j ) ] ++ ; } } long long answer = 0 ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= r ; j ++ ) { if ( gcd ( i , j ) == k ) { answer += ( frequency [ i ] * frequency [ j ] ) ; } } } return answer ; }
int maxBitElement ( int arr [ ] , int n ) { int num = 0 , max = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = __builtin_popcount ( arr [ i ] ) ; if ( cnt > max ) { max = cnt ; num = arr [ i ] ; } } return num ; }
void Add_Edge ( int u , int v ) { gr [ u ] . push_back ( v ) ; gr [ v ] . push_back ( u ) ; }
ll factorial ( ll n , ll p ) { for ( int i = 2 ; i <= n ; i ++ ) res = ( res * i ) % p ; return res ; }
int getValueOfF ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; int cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n /= 2 ; } return 2 * cnt ; }
void printNumbers ( int a [ ] , int n , int x ) { bool flag = false ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; int g = __gcd ( num , x ) ; while ( g != 1 ) { num /= g ; g = __gcd ( num , x ) ; } if ( num == 1 ) { flag = true ; cout << a [ i ] << " " ; } } if ( ! flag ) cout << "There are no such numbers" ; }
void line ( double x0 , double y0 ) { double c = 2 * y0 * x0 ; cout << y0 << "x" << " + " << x0 << "y = " << c ; }
bool isDudeney ( int n ) { int cube_rt = round ( ( pow ( n , 1.0 / 3.0 ) ) ) ; if ( cube_rt * cube_rt * cube_rt != n ) return false ; int dig_sum = 0 ; int temp = n ; while ( temp > 0 ) { int rem = temp % 10 ; dig_sum += rem ; temp /= 10 ; } if ( cube_rt != dig_sum ) return false ; return true ; }
void Positive_Divisors ( ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) d [ i ] ++ ; else d [ i ] += 2 ; } } } int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( d [ i ] == d [ i - 1 ] ) ans ++ ; pre [ i ] = ans ; } }
int oddDays ( int N ) { int hund1 = N / 100 ; int hund4 = N / 400 ; int leap = N >> 2 ; int ord = N - leap ; if ( hund1 > 0 ) { ord += hund1 ; leap -= hund1 ; } if ( hund4 > 0 ) { ord -= hund4 ; leap += hund4 ; } int days = ord + leap * 2 ; int odd = days % 7 ; return odd ; }
float ellipsearea ( float r ) { if ( r < 0 ) return -1 ; float a = ( 3.14 * r * r ) / 4 ; return a ; }
int recamanGenerator ( int arr [ ] , int n ) { arr [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == temp ) temp < 0 ) { temp = arr [ i - 1 ] + i ; break ; } } arr [ i ] = temp ; } return 0 ; }
ll power ( ll a , ll n ) { if ( n == 0 ) return 1 ; ll p = power ( a , n / 2 ) ; p = p * p ; if ( n % 2 == 1 ) p = p * a ; return p ; }
int findPairCount ( int N , int K ) { int count = 0 ; int rem [ K ] ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ; if ( K % 2 == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }
bool doesContainB ( int a , int b , int c ) { if ( a == b ) return true ; if ( ( b - a ) * c > 0 && ( b - a ) % c == 0 ) return true ; return false ; }
void sieve ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int i = 2 ; i < N ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * 2 ; j < N ; j += i ) { prime [ j ] = false ; } } } }
void lastDigit ( string a , string b ) { int lastDig = ( a [ a . size ( ) - 1 ] - '0' ) * ( b [ b . size ( ) - 1 ] - '0' ) ; cout << lastDig % 10 << endl ; }
void printPalindrome ( int n ) { if ( n == 1 ) { cout << "Smallest Palindrome: 0" ; cout << "Largest Palindrome: 9" ; } else { cout << "Smallest Palindrome: " << pow ( 10 , n - 1 ) + 1 ; cout << "Largest Palindrome: " << pow ( 10 , n ) - 1 ; } }
int countDigits ( int a , int b ) { int count = 0 ; int p = abs ( a / b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
void nDigitPerfectCubes ( int n ) { cout << pow ( ceil ( cbrt ( pow ( 10 , ( n - 1 ) ) ) ) , 3 ) << " " ; cout << pow ( ceil ( cbrt ( pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ; }
int sumOfSeries ( int n ) { int ans = pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; }
int countNumbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * pow ( 10 , n / 2 - 1 ) ) ; }
int KthMinValAfterMconcatenate ( int A [ ] , int N , int M , int K ) { sort ( A , A + N ) ; return ( A [ ( ( K - 1 ) / M ) ] ) ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : factorial ( n - 1 ) * n ; }
int gcdOfFactorial ( int * arr , int n ) { int minm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minm = max ( minm , arr [ i ] ) ; return factorial ( minm ) ; }
int findMinimum ( int n , int m ) { int mini = m ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int sec = n / i ; if ( __gcd ( m , i ) > 1 ) { return i ; } else if ( __gcd ( sec , m ) > 1 ) { mini = min ( sec , mini ) ; } } } if ( mini == m ) return -1 ; else return mini ; }
double getProbability ( int a , int b , int c , int d ) { double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ; double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; }
int findMinSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; }
int getPosition ( int n , int m ) { if ( m > ( n / 2 ) ) return ( m - ( n / 2 ) ) ; return ( m + ( n / 2 ) ) ; }
int matrixOrValueOne ( bool arr [ N ] [ N ] ) { int p_arr [ n ] [ n ] ; findPrefixCount ( p_arr , arr ) ; int count_zero_submatrices = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int i = n - 1 ; stack < pair < int , int > > q ; int to_sum = 0 ; while ( i >= 0 ) { int c = 0 ; while ( q . size ( ) != 0 && q . top ( ) . first > p_arr [ i ] [ j ] ) { to_sum -= ( q . top ( ) . second + 1 ) * ( q . top ( ) . first - p_arr [ i ] [ j ] ) ; c += q . top ( ) . second + 1 ; q . pop ( ) ; } to_sum += p_arr [ i ] [ j ] ; count_zero_submatrices += to_sum ; q . push ( { p_arr [ i ] [ j ] , c } ) ; i -- ; } } return ( n * ( n + 1 ) * n * ( n + 1 ) ) / 4 - count_zero_submatrices ; }
long count ( int N , int K , int R ) { long sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; }
bool isSpiltPossible ( int n , int a [ ] ) { int sum = 0 , c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }
bool isSunnyNum ( int n ) { if ( isPerfectSquare ( n + 1 ) ) return true ; return false ; }
int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; }
int getMaxNum ( int a , int b , int c ) { if ( b % c == 0 ) return b ; int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return -1 ; }
int findAndSum ( int * arr , int n ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { bool count_on = false ; int l = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & ( 1 << i ) ) if ( count_on ) l ++ ; else { count_on = true ; l ++ ; } else if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = false ; l = 0 ; } } if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = false ; l = 0 ; } mul *= 2 ; } return sum ; }
int calcNodes ( int N , int I ) { int result = 0 ; result = I * ( N - 1 ) + 1 ; return result ; }
void findPrimeFactors ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ j / i ] + 1 ; for ( int i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; }
double mixtureConcentration ( int n , int p [ ] ) { double res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return res ; }
bool check ( long long int num , long long int a , long long int b ) { while ( num ) { long long int rem = num % 10 ; num /= 10 ; if ( rem != a && rem != b ) return false ; } return true ; }
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
long long max_gcd ( long long n , long long p ) { int count = 0 ; long long gcd = 1 ; while ( p % 2 == 0 ) { p >>= 1 ; count ++ ; } if ( count > 0 ) gcd *= pow ( 2 , count / n ) ; for ( long long i = 3 ; i <= sqrt ( p ) ; i += 2 ) { count = 0 ; while ( p % i == 0 ) { count ++ ; p = p / i ; } if ( count > 0 ) { gcd *= pow ( i , count / n ) ; } } if ( p > 2 ) gcd *= pow ( p , 1 / n ) ; return gcd ; }
int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] ) return f [ n ] ; int k ; if ( n & 1 ) k = ( n + 1 ) / 2 ; else k = n / 2 ; if ( n & 1 ) f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; else f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
void printSequence ( int n ) { Sieve ( ) ; vector < int > v , u ; for ( int i = 13 ; i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { v . push_back ( i ) ; } } if ( n == 3 ) { cout << 6 << " " << 10 << " " << 15 ; return ; } int k ; for ( k = 0 ; k < n - 2 ; k ++ ) { if ( k % 3 == 0 ) { u . push_back ( v [ k ] * 6 ) ; } else if ( k % 3 == 1 ) { u . push_back ( v [ k ] * 15 ) ; } else { u . push_back ( v [ k ] * 10 ) ; } } k -- ; u . push_back ( v [ k ] * 7 ) ; u . push_back ( 7 * 11 ) ; u [ 0 ] = u [ 0 ] * 11 ; for ( int i = 0 ; i < u . size ( ) ; i ++ ) { cout << u [ i ] << " " ; } }
int checkSub ( string & sub , string & s ) { int j = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( sub [ j ] == s [ i ] ) j ++ ; return j == sub . length ( ) ; }
int minPerfectCube ( int arr [ ] , int n ) { int minPerfectCube ; int lcm = lcmOfArray ( arr , n ) ; minPerfectCube = lcm ; int cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm /= 2 ; } if ( cnt % 3 == 2 ) minPerfectCube *= 2 ; else if ( cnt % 3 == 1 ) minPerfectCube *= 4 ; int i = 3 ; while ( lcm > 1 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm /= i ; } if ( cnt % 3 == 1 ) minPerfectCube *= i * i ; else if ( cnt % 3 == 2 ) minPerfectCube *= i ; i += 2 ; } return minPerfectCube ; }
void powerfulIntegers ( int x , int y , int bound ) { set < int > s ; vector < int > powersOfY ; int i ; powersOfY . push_back ( 1 ) ; for ( i = y ; i < bound && y != 1 ; i = i * y ) powersOfY . push_back ( i ) ; i = 0 ; while ( true ) { int xPowI = pow ( ( double ) x , ( double ) i ) ; for ( int j = 0 ; j < powersOfY . size ( ) ; ++ j ) { int num = xPowI + powersOfY [ j ] ; if ( num <= bound ) s . insert ( num ) ; else break ; } if ( xPowI >= bound x == 1 ) break ; i ++ ; } for ( auto itr = s . begin ( ) ; itr != s . end ( ) ; itr ++ ) { cout << itr -> first << " " ; } }
double find_probability ( double p , double q , double r , double s ) { double t = ( 1 - p / q ) * ( 1 - r / s ) ; double ans = ( p / q ) / ( 1 - t ) ; return ans ; }
int distinctDigitSum ( int n ) { bool used [ 10 ] = { false } ; int sum = 0 ; while ( n > 0 ) { int digit = n % 10 ; if ( ! used [ digit ] ) { used [ digit ] = true ; sum += digit ; } n = n / 10 ; } return sum ; }
int getDifference ( int N ) { if ( N == 0 ) return 2 ; else if ( N == 1 ) return 1 ; else if ( isPrime ( N ) ) return 0 ; int aboveN = -1 , belowN = -1 ; int n1 ; n1 = N + 1 ; while ( true ) { if ( isPrime ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; } n1 = N - 1 ; while ( true ) { if ( isPrime ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; } int diff1 = aboveN - N ; int diff2 = N - belowN ; return min ( diff1 , diff2 ) ; }
int maxPrimeFactors ( int n ) { int num = n ; int maxPrime = -1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n /= 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } } if ( n > 2 ) { maxPrime = n ; } int sum = maxPrime + num ; return sum ; }
int sumOfDigits ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; }
int countIntervals ( vector < pair < int , int > > arr , int V , int N ) { int min = INT_MAX , max = INT_MIN ; int li , ri ; int freq [ MAX_VAL ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i ] . first ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] . second ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( int i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }
int sumEven ( int l , int r ) { return sumNatural ( r / 2 ) - sumNatural ( ( l - 1 ) / 2 ) ; }
bool isPalindrome ( int num ) { int reverse_num = 0 , remainder , temp ; temp = num ; while ( temp ) { remainder = temp % 10 ; reverse_num = reverse_num * 10 + remainder ; temp /= 10 ; } if ( reverse_num == num ) return true ; return false ; }
int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; }
int getResult ( int n ) { if ( n & 1 ) return 1 ; return -1 ; }
ll sumAP ( ll n , ll d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; }
ll gcd ( ll a , ll b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int minimum ( int n ) { int product = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; product = product * i ; } } if ( n >= 2 ) product = product * n ; return product ; }
bool productDivisible ( int n , int k ) { int product = 1 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 0 ) { product *= n % 10 ; } n = n / 10 ; position ++ ; } if ( product % k == 0 ) return true ; return false ; }
ll sumAP ( ll n , ll d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; }
int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
string isTriangleExists ( int a , int b , int c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return "YES" ; else return "NO" ; else return "NO" ; }
int fact ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact *= i ; return fact ; }
int ways ( int m , int w , int n , int k ) { int ans = 0 ; while ( m >= k ) { ans += ncr ( m , k ) * ncr ( w , n - k ) ; k += 1 ; } return ans ; }
void SieveOfEratosthenes ( ) { prime [ 1 ] = true ; prime [ 0 ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } } }
int square ( int n ) { return n * n ; }
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 2 ) ) * ( 2 * 2 + ( N / 2 - 1 ) * 2 ) / 2 ; S2 = ( ( N / 7 ) ) * ( 2 * 7 + ( N / 7 - 1 ) * 7 ) / 2 ; S3 = ( ( N / 14 ) ) * ( 2 * 14 + ( N / 14 - 1 ) * 14 ) / 2 ; return S1 + S2 - S3 ; }
int largestPrimeFactor ( int n ) { int max = -1 ; while ( n % 2 == 0 ) { max = 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { max = i ; n = n / i ; } } if ( n > 2 ) max = n ; return max ; }
bool isStrongNumber ( int n ) { map < int , int > count ; while ( n % 2 == 0 ) { n = n / 2 ; count [ 2 ] ++ ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { n = n / i ; count [ i ] ++ ; } } if ( n > 2 ) { count [ n ] ++ ; } int flag = 0 ; for ( auto b : count ) { if ( b . second == 1 ) { flag = 1 ; break ; } } if ( flag == 1 ) { return false ; } else { return true ; } }
bool isChenPrime ( int n ) { if ( isPrime ( n ) && ( isSemiPrime ( n + 2 ) || isPrime ( n + 2 ) ) ) return true ; else return false ; }
bool isPowerOfTwo ( int n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
bool Divisible ( string str , int n ) { if ( SumOfDigits ( str , n ) % 3 == 0 && str [ n - 1 ] == '0' ) return true ; return false ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
int NumberOfRectangles ( int n , int m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; }
long long isPrime ( int p ) { if ( p == 4 ) return 0 ; return ( fact ( p >> 1 ) % p ) ; }
ll findNumUtil ( ll res , int a , int aCount , int b , int bCount , int n ) { if ( res > 1e11 ) return 1e11 ; if ( aCount == bCount && res >= n ) return res ; return min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) ) ; }
int isSumDivides ( int N ) { int temp = N ; int sum = 0 ; while ( temp ) { sum += temp % 10 ; temp /= 10 ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }
int GoodNumber ( int n ) { vector < int > v ; for ( int i = 0 ; i < PrimeFactors ( n ) ; i ++ ) v . push_back ( PrimeFactors [ i ] ) ; int ans = 1 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) ans *= v [ i ] ; return ans ; }
bool checkSpecialPrime ( vector < bool > sieve , int num ) { while ( num ) { if ( ! sieve [ num ] ) { return false ; } num /= 10 ; } return true ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
double nthHarmonic ( int N ) { float harmonic = 1.0f ; for ( int i = 2 ; i <= N ; i ++ ) { harmonic += ( float ) 1 / i ; } return harmonic ; }
int nthTerm ( int n ) { return 3 * pow ( n , 2 ) + n - 2 ; }
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + 4 * n - 2 ; }
void printAngles ( int a , int b , int c ) { double x = ( double ) a ; double y = ( double ) b ; double z = ( double ) c ; double A = findAnglesA ( x , y , z ) ; double B = findAnglesB ( x , y , z ) ; cout << "Angles are A = " << A << ", B = " << B << ", C = " << 90 << endl ; }
long Bits ( int kilobytes ) { long Bits = 0 ; Bits = kilobytes * 8192 ; return Bits ; }
void binomial ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int closest ( int x ) { int ans = 0 ; while ( ans * 10 + 9 <= x ) ans = ans * 10 + 9 ; return ans ; }
int nthTerm ( int N ) { return ( N * ( ( N / 2 ) + ( ( N % 2 ) * 2 ) + N ) ) ; }
int calculateSum ( int n ) { return pow ( n * ( n + 1 ) / 2 , 2 ) ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int totEdge ( int n ) { int result = 0 ; result = ( n * ( n - 1 ) ) / 2 ; return result ; }
void findFactors ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( ( n / i ) == i ) { factors . push_back ( i ) ; } else { factors . push_back ( n / i ) ; factors . push_back ( i ) ; } } } }
bool checkPairs ( int l , int r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }
double calTime ( double arr [ ] , int n ) { double work = 0 ; for ( int i = 0 ; i < n ; i ++ ) work += 1 / arr [ i ] ; return 1 / work ; }
int calculate_ways ( int m , int n ) { if ( m < n ) { return 0 ; } int ways = binomial_coefficient ( n + m - 1 , n - 1 ) ; return ways ; }
ll powerLL ( ll x , ll n ) { ll result = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) { result = result * x % MOD ; } n = n / 2 ; x = x * x % MOD ; } return result ; }
long long powerStrings ( string sa , string sb ) { long long a = 0 , b = 0 ; for ( int i = 0 ; i < sa . length ( ) ; i ++ ) { a = ( a * 10 + ( sa [ i ] - '0' ) ) % MOD ; } for ( int i = 0 ; i < sb . length ( ) ; i ++ ) { b = ( b * 10 + ( sb [ i ] - '0' ) ) % ( MOD - 1 ) ; } return powerLL ( a , b ) ; }
int findNumbers ( int n , int w ) { int x = 0 , sum = 0 ; if ( w >= 0 && w <= 8 ) { x = 9 - w ; } else if ( w >= -9 && w <= -1 ) { x = 10 + w ; } sum = pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; }
int check ( int n ) { int mod = 1e9 + 7 ; n -- ; int ans = n * n ; if ( ans >= mod ) ans %= mod ; ans += n + 2 ; if ( ans >= mod ) ans %= mod ; ans = ( power ( 2 , n , mod ) % mod * ans % mod ) % mod ; ans = ( ans - 1 + mod ) % mod ; return ans ; }
int findOddPair ( int A [ ] , int N ) { int i , j ; int oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
int numberOfDigits ( int x ) { int i = 0 ; while ( x != 0 ) { x /= 10 ; i ++ ; } return i ; }
int twoEggDrop ( int k ) { return ceil ( ( -1.0 + sqrt ( 1 + 8 * k ) ) / 2.0 ) ; }
void findArea ( float a , float b ) { float Area ; Area = 3.142 * a * b ; cout << "Area: " << Area ; }
int calculate ( int x , int k , int m ) { int result = x ; k -- ; while ( k -- ) { result = pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; }
int largestNum ( int a , int b ) { return a * ( ( a / b ) ? 1 : 0 ) + b * ( ( b / a ) ? 1 : 0 ) ; }
int minimumSquareFreeDivisors ( int N ) { vector < int > primes ; SieveOfEratosthenes ( primes ) ; int max_count = 0 ; for ( int i = 0 ; i < primes . size ( ) && primes [ i ] * primes [ i ] <= N ; i ++ ) { if ( N % primes [ i ] == 0 ) { int tmp = 0 ; while ( N % primes [ i ] == 0 ) tmp ++ ; N /= primes [ i ] ; max_count = max ( max_count , tmp ) ; } } if ( max_count == 0 ) max_count = 1 ; return max_count ; }
void smar_wln ( int n ) { primes ( n ) ; }
int sumOfSeries ( int n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; }
long double mulmod ( long double a , long double b , long double mod ) { a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; }
long long findProduct ( long long N ) { long long product = 1 , fact = 1 ; long long MOD = 1e9 + 7 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = mulmod ( fact , i , MOD ) ; product = mulmod ( product , fact , MOD ) ; if ( product == 0 ) return 0 ; } return product ; }
void endPointOfDiameterofCircle ( int x1 , int y1 , int c1 , int c2 ) { cout << "x2 = " << ( 2 * c1 - x1 ) << " " ; cout << "y2 = " << ( 2 * c2 - y1 ) ; }
int divSum ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) sum = sum + i + n / i ; return sum ; }
int centeredTetrahedralNumber ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 3 ) / 3 ; }
int bit ( int x ) { int ans = 0 ; while ( x ) { x /= 2 ; ans ++ ; } return ans ; }
int bs ( int n ) { int l = 1 , r = sqrt ( n ) ; while ( l < r ) { int m = ( l + r ) / 2 ; if ( check ( m , n ) ) r = m ; else l = m + 1 ; } if ( ! check ( l , n ) ) return l + 1 ; else return l ; }
string find_Square_369 ( string num ) { char a , b , c , d ; if ( num [ 0 ] == '3' ) { a = '1' ; b = '0' ; c = '8' ; d = '9' ; } else if ( num [ 0 ] == '6' ) { a = '4' ; b = '3' ; c = '5' ; d = '6' ; } else { a = '9' ; b = '8' ; c = '0' ; d = '1' ; } string result = "" ; int size = num . size ( ) ; for ( int i = 1 ; i < size ; i ++ ) result += a ; result += b ; for ( int i = 1 ; i < size ; i ++ ) result += c ; result += d ; return result ; }
bool everMeet ( int x1 , int x2 , int v1 , int v2 ) { if ( x1 < x2 && v1 <= v2 ) return false ; if ( x1 > x2 && v1 >= v2 ) return false ; if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; } while ( x1 >= x2 ) { if ( x1 == x2 ) return true ; x1 = x1 + v1 ; x2 = x2 + v2 ; } return false ; }
int findpos ( string n ) { int pos = 0 ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { switch ( n [ i ] ) { case '2' : pos = pos * 4 + 1 ; break ; case '3' : pos = pos * 4 + 2 ; break ; case '5' : pos = pos * 4 + 3 ; break ; case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; }
bool isPossibleToZero ( int a [ ] , int n ) { int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }
int fact ( int n ) { if ( n == 0 n == 1 ) return 1 ; int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ans ; }
int solve ( int n , int base ) { int result = 0 ; while ( n > 0 ) { int remainder = n % base ; result = result + remainder ; n = n / base ; } return result ; }
bool checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i , ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; }
void possibleTripletInRange ( int L , int R ) { bool flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ; int numbersInRange = ( R - L + 1 ) ; if ( numbersInRange < 3 ) { flag = false ; } else if ( numbersInRange > 3 ) { flag = true ; if ( L % 2 > 0 ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ! ( L % 2 > 0 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( flag == true ) { cout << "(" << possibleA << ", " << possibleB << ", " << possibleC << ")" << " is one such possible" << " triplet between " << L << " and " << R ; } else { cout << "No Such Triplet" << " exists between " << L << " and " << R ; } }
bool isFullTree ( Node * node ) { if ( node == NULL ) return true ; if ( node -> left == NULL && node -> right == NULL ) return true ; if ( ( node -> left != NULL ) && ( node -> right != NULL ) ) return ( isFullTree ( node -> left ) && isFullTree ( node -> right ) ) ; return false ; }
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return -1 ; }
int findKthGoodNo ( int n ) { int lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }
int findGreatest ( int arr [ ] , int n ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; sort ( arr , arr + n ) ; for ( int i = n - 1 ; i > 1 ; i -- ) { for ( int j = 0 ; j < i && arr [ j ] <= sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) { int result = arr [ i ] / arr [ j ] ; if ( result != arr [ j ] && m [ result ] == 0 || m [ result ] > 1 ) return arr [ i ] ; else if ( result == arr [ j ] && m [ result ] > 1 ) return arr [ i ] ; } } } return -1 ; }
int LCMOfNeighbourFact ( int n ) { return factorial ( n + 1 ) ; }
int fortunateNumber ( int n ) { int p = primorial ( n ) ; return findNextPrime ( p ) - p ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
int factorial ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; }
int findNthNumber ( int n , int k ) { for ( int i = k + 1 , count = 1 ; count < n ; i ++ ) { if ( checkdigit ( i , k ) || ( i % k == 0 ) ) count ++ ; if ( count == n ) return i ; } return -1 ; }
bool isPrime ( int p ) { int checkNumber = pow ( 2 , p ) - 1 ; int nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }
int multiply ( int x , int res [ ] , int res_size ) { int carry = 0 ; for ( int i = 0 ; i < res_size ; i ++ ) { int prod = res [ i ] * x + carry ; res [ i ] = prod % 10 ; carry = prod / 10 ; } while ( carry > 0 ) { res [ res_size ] = carry % 10 ; carry = carry / 10 ; res_size ++ ; } return res_size ; }
void power ( int x , int n ) { if ( n == 0 ) { cout << "1" ; return ; } int res [ MAX ] = { 0 } ; int res_size = 0 ; int temp = x ; while ( temp != 0 ) { res [ res_size ++ ] = temp % 10 ; temp = temp / 10 ; } for ( int i = 2 ; i <= n ; i ++ ) res_size = multiply ( x , res , res_size ) ; cout << x << "^" << n << " = " ; for ( int i = res_size - 1 ; i >= 0 ; i -- ) cout << res [ i ] ; }
int sumOfSeries ( int n ) { return 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ; }
int seriesFunc ( int n ) { int sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; }
int day_of_the_week ( int y , int m , int d ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; if ( m < 3 ) y -= 1 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
int subsetCount ( int arr [ ] , int n ) { return ( 1 << n ) ; }
bool isSquareFree ( int n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; }
int avg_of_even_num ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return ( sum / n ) ; }
int reachTarget ( int target ) { target = abs ( target ) ; int sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; }
long long int fourthPowerSum ( int n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; }
int aliquotSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
float focal_length_concave ( float R ) { return R / 2 ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; unordered_set < int > us ; for ( int i = 0 ; i < m ; i ++ ) us . insert ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( us . find ( x - arr2 [ j ] ) != us . end ( ) ) count ++ ; return count ; }
int binomialCoeff ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
bool isEmirp ( int n ) { if ( isPrime ( n ) == false ) return false ; int rev = 0 ; while ( n ) { int d = n % 10 ; rev = rev * 10 + d ; n /= 10 ; } return isPrime ( rev ) ; }
int squaresum ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
bool isPrime ( int n ) { int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) return false ; i ++ ; } return true ; }
int oddSum ( int n ) { int sum = 0 , curr = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }
int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; }
double distance ( int x1 , int y1 , int x2 , int y2 ) { return sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) * 1.0 ) ; }
void count0s ( int mat [ M ] [ N ] , int Q [ M ] [ N ] , int sizeQ ) { int prefixCnt [ M ] [ N ] ; preCompute ( mat , prefixCnt ) ; for ( int i = 0 ; i < sizeQ ; i ++ ) { cout << countQuery ( prefixCnt , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , Q [ i ] [ 3 ] ) << " " ; } }
void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) cout << "Not possiblen" ; else { int result ; if ( k < max ( m , n ) - 1 ) { result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } cout << result ; } }
int totalNumber ( int n ) { return 8 * pow ( 9 , n - 1 ) ; }
int recDigSum ( int n ) { if ( n == 0 ) return 0 ; else { if ( n % 9 == 0 ) return 9 ; else return n % 9 ; } }
void check ( int n ) { n = recDigSum ( n ) ; if ( n == 2 n == 3 n == 5 n == 7 ) cout << "Yes" ; else cout << "No" ; }
bool isDivisible ( string S ) { int n = S . length ( ) ; if ( S [ n - 1 ] != '5' && S [ n - 1 ] != '0' ) return false ; int sum = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) sum += ( int ) S [ i ] ; if ( sum % 3 == 0 ) return true ; else return false ; }
void findArmstrong ( int low , int high ) { for ( int i = low + 1 ; i < high ; ++ i ) { int x = i ; int n = 0 ; while ( x != 0 ) { x /= 10 ; ++ n ; } int pow_sum = 0 ; x = i ; while ( x != 0 ) { int digit = x % 10 ; pow_sum += pow ( digit , n ) ; x /= 10 ; } if ( pow_sum == i ) cout << i << " " ; } }
void complement ( string number ) { string number = number . trim ( ) ; for ( int i = 0 ; i < number . length ( ) ; i ++ ) if ( number [ i ] != '.' ) number [ i ] = ( char ) ( '9' - number [ i ] ) + ( char ) ( '0' ) ; cout << "9's complement is : " << number ; }
int countWays ( int n ) { int count = 0 ; for ( int i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }
int sumDigitSquare ( int n ) { int sq = 0 ; while ( n != 0 ) { int digit = n % 10 ; sq += digit * digit ; n = n / 10 ; } return sq ; }
bool isHappy ( int n ) { while ( true ) { if ( n == 1 ) return true ; n = sumDigitSquare ( n ) ; if ( n == 4 ) return false ; } }
double sumOfSeries ( double a , double n ) { double res = 0 , prev = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { prev *= ( a / i ) ; res = res + prev ; } return ( res ) ; }
void convert ( int arr [ ] , int n ) { int temp [ n ] ; sort ( temp , temp + n ) ; unordered_map < int , int > umap ; int val = 0 ; for ( int i = 0 ; i < n ; i ++ ) umap [ temp [ i ] ] = val ++ ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = umap [ arr [ i ] ] ; }
void printTrib ( int n ) { if ( n < 1 ) return ; int first = 0 , second = 0 ; int third = 1 ; cout << first << " " ; if ( n > 1 ) cout << second << " " ; if ( n > 2 ) cout << second << " " ; for ( int i = 3 ; i < n ; i ++ ) { int curr = first + second + third ; first = second ; second = third ; third = curr ; cout << curr << " " ; } }
void multiply ( int T [ 3 ] [ 3 ] , int M [ 3 ] [ 3 ] ) { int a , b , c , d , e , f , g , h , i ; a = T [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 0 ] ; b = T [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 1 ] ; c = T [ 0 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 2 ] ; d = T [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 0 ] ; e = T [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 1 ] ; f = T [ 1 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 0 ] ; h = T [ 2 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 1 ] ; i = T [ 2 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 2 ] ; T [ 0 ] [ 0 ] [ 0 ] = a ; T [ 0 ] [ 1 ] = b ; T [ 0 ] [ 2 ] = i ; }
bool sackRace ( int p1 , int s1 , int p2 , int s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; }
int xorCalc ( int k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return k / 2 ; return 1 ; }
void multiple ( int a , int b , int x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) cout << "1" ; else cout << "0" ; } int mul = pow ( a , b ) ; int ans = mul / x ; int ans1 = x * ans ; int ans2 = x * ( ans + 1 ) ; cout << ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ; }
bool checkJumbled ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; }
float binomialProbability ( int n , int k , float p ) { return nCr ( n , k ) * pow ( p , k ) * pow ( 1 - p , n - k ) ; }
int flipSign ( int a ) { int neg = 0 ; int tmp = a < 0 ? 1 : -1 ; while ( a ) { neg += tmp ; a += tmp ; } return neg ; }
bool areDifferentSign ( int a , int b ) { return ( ( a < 0 && b > 0 ) || ( a > 0 && b < 0 ) ) ; }
int FirstDigit ( int arr [ ] , int n ) { double S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S = S + log10 ( arr [ i ] * 1.0 ) ; double fract_S = S - floor ( S ) ; int ans = pow ( 10 , fract_S ) ; return ans ; }
void cal_cos ( float n ) { float accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= cosval - cosx ) ; cout << cosx ; }
int sumFactDiv ( int n ) { return div ( fact ( n ) ) ; }
int printNthElement ( int n ) { int arr [ n + 1 ] ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
int maxSumLCM ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; }
bool check ( string str ) { int n = str . length ( ) ; if ( n == 0 && n == 1 ) return false ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ; if ( n == 3 ) return ( ( ( str [ n - 3 ] - '0' ) * 100 + ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ; int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; int fourth_last = str [ n - 4 ] - '0' ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; }
bool checkPandigital ( int b , string n ) { if ( n . length ( ) < b ) return false ; bool hash [ b ] ; memset ( hash , false , sizeof ( hash ) ) ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { if ( n [ i ] >= '0' && n [ i ] <= '9' ) hash [ n [ i ] - '0' ] = true ; else if ( n [ i ] - 'A' <= b - 11 ) hash [ n [ i ] - 'A' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; }
int findStarNum ( int n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
int squareFree ( int n ) { int cnt = 0 ; for ( int i = 1 ; ; i ++ ) { bool isSqFree = true ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % ( j * j ) == 0 ) { isSqFree = false ; break ; } } if ( isSqFree == true ) { cnt ++ ; if ( cnt == n ) return i ; } } }
bool check ( string str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str [ 0 ] - '0' ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 8 == 0 ) ; int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; }
bool isRefactorableNumber ( int n ) { int divCount = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) { if ( n / i == i ) ++ divCount ; else divCount += 2 ; } } return n % divCount == 0 ; }
void nearestGcd ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) { int closest = -1 ; for ( int j = i - 1 , k = i + 1 ; j > 0 k <= n ; -- j , ++ k ) { if ( j >= 0 && __gcd ( arr [ i ] , arr [ j ] ) > 1 ) { closest = j + 1 ; break ; } if ( k < n && __gcd ( arr [ i ] , arr [ k ] ) > 1 ) { closest = k + 1 ; break ; } } cout << closest << " " ; } }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; }
int Special_Factorial_Number ( int k ) { for ( int i = 1 ; i <= k ; i ++ ) { if ( fact ( i ) % k == 0 ) { return i ; } } }
int findnum ( string str ) { int n = str . length ( ) ; int count_after_dot = 0 ; bool dot_seen = false ; int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != '.' ) { num = num * 10 + ( str [ i ] - '0' ) ; if ( dot_seen == true ) count_after_dot ++ ; } else dot_seen = true ; } if ( dot_seen == false ) return 1 ; int dem = pow ( 10 , count_after_dot ) ; return ( dem / gcd ( num , dem ) ) ; }
bool iskaprekar ( int n ) { if ( n == 1 ) return true ; int sq_n = n * n ; int count_digits = 0 ; while ( sq_n ) { count_digits ++ ; sq_n /= 10 ; } for ( int r_digits = 1 ; r_digits < count_digits ; r_digits ++ ) { int eq_parts = pow ( 10 , r_digits ) ; if ( eq_parts == n ) continue ; int sum = sq_n / eq_parts + sq_n % eq_parts ; if ( sum == n ) return true ; } return false ; }
int kDivisors ( int a , int b , int k ) { int count = 0 ; for ( int i = a ; i <= b ; i ++ ) { if ( isPerfect ( i ) ) if ( divisorsCount ( i ) == k ) count ++ ; } return count ; }
void buildDivisorsArray ( ) { for ( int i = 1 ; i < maxn ; i ++ ) { divisors [ i ] = 1 ; int n = i , p = smallest_prime [ i ] , k = 0 ; while ( n > 1 ) { n = n / p ; k ++ ; if ( smallest_prime [ n ] != p ) { divisors [ i ] = divisors [ i ] * ( k + 1 ) ; k = 0 ; } p = smallest_prime [ n ] ; } } }
int commDiv ( int a , int b ) { int n = gcd ( a , b ) ; int result = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) result += 1 ; else result += 2 ; } } return result ; }
int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
bool isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( -2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( - b + sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && floor ( root2 ) == root2 ) return true ; return false ; }
char flip ( char c ) { return ( c == '0' ) ? '1' : '0' ; }
bool areElementsContiguous ( int arr [ ] , int n ) { int max = INT_MIN ; int min = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { max = max ( max , arr [ i ] ) ; min = min ( min , arr [ i ] ) ; } int m = max - min + 1 ; if ( m > n ) return false ; bool visited [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }
int SieveOfAtkin ( int limit ) { if ( limit > 2 ) cout << 2 << " " ; if ( limit > 3 ) cout << 3 << " " ; bool sieve [ limit ] ; memset ( sieve , false , sizeof sieve ) ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) cout << a << " " ; return 0 ; }
int SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; bool marked [ nNew + 1 ] = { false } ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) cout << 2 << " " ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) cout << 2 * i + 1 << " " ; return -1 ; }
bool squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
int power ( int x , unsigned int y , int p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int modFact ( int n , int p ) { if ( p <= n ) return 0 ; int res = ( p - 1 ) ; for ( int i = n + 1 ; i < p ; i ++ ) res = ( res * modInverse ( i , p ) ) % p ; return res ; }
int countWays ( int n ) { for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) for ( int k = j ; k < n ; k ++ ) for ( int l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
bool isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; }
bool checkUtil ( int num , int dig , int base ) { if ( dig == 1 && num < base ) return true ; if ( dig > 1 && num >= base ) return checkUtil ( num / base , -- dig , base ) ; return false ; }
int countLeapYears ( Date d ) { int years = d . y ; if ( d . m <= 2 ) { years -- ; } return years / 4 - years / 100 + years / 400 ; }
unsigned long int binomialCoeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
unsigned long int findWays ( unsigned n ) { if ( n & 1 ) return 0 ; return catalan ( n / 2 ) ; }
int XorSum ( int A [ ] , int B [ ] , int N , int M ) { int ans1 = 0 , ans2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) ans1 = ans1 ^ A [ i ] ; for ( int i = 0 ; i < M ; i ++ ) ans2 = ans2 ^ B [ i ] ; return ( ans1 & ans2 ) ; }
bool check ( int x ) { if ( ( ( x ) & ( x - 1 ) ) == 0 ) return 1 ; return 0 ; }
int maxAndXor ( int arr [ ] , int n ) { int ans = INT_MAX ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = min ( ans , arr [ i ] ^ arr [ i + 1 ] ) ; } return ans ; }
void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( n >> bit ) & 1 ) { n = n ^ ( 1 << bit ) ; break ; } } cout << "The number after unsetting the" ; cout << " rightmost set bit " << n ; }
void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; for ( int i = 0 ; i < n ; i ++ ) { set < int > s ; int j ; for ( j = i ; j < n ; j ++ ) { s . insert ( arr [ j ] ) ; if ( s . size ( ) == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) break ; } if ( l == 0 && r == n ) cout << "Invalid k" ; else cout << l << " " << r ; }
void construct_Xor_Tree ( int arr [ ] , int n ) { construct_Xor_Tree_Util ( arr , 0 , n - 1 , 0 ) ; }
int maximizeExpression ( int a , int b ) { int result = a ; for ( int bit = MAX - 1 ; bit >= 0 ; bit -- ) { int bitOfD = 1 << bit ; int x = b & bitOfD ; if ( x == bitOfD ) { int y = result & bitOfD ; if ( y == 0 ) { result = result ^ bitOfD ; } } } return result ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
void hasEqualBlockFrequency ( int N ) { string S = to_string ( N , 2 ) ; set < int > p ; int c = 1 ; for ( int i = 0 ; i < S . size ( ) - 1 ; i ++ ) { if ( S [ i ] == S [ i + 1 ] ) c += 1 ; else { p . insert ( c ) ; c = 1 ; } p . insert ( c ) ; } if ( p . size ( ) == 1 ) cout << "Yes" ; else cout << "No" ; }
bool isEqualBlock ( int n ) { int first_bit = n % 2 ; int first_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit && n > 0 ) { n = n / 2 ; first_count ++ ; } if ( n == 0 ) return false ; while ( n > 0 ) { first_bit = n % 2 ; int curr_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit ) { n = n / 2 ; curr_count ++ ; } if ( curr_count != first_count ) return false ; } return true ; }
int printMaxAfterRemoval ( string s ) { bool flag = false ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' && flag == false ) { flag = true ; continue ; } else cout << s [ i ] ; } return 0 ; }
int bitPos ( int n1 , int n2 ) { if ( n1 == n2 ) return 0 ; int bitCount1 = floor ( log2 ( n1 ) ) + 1 ; int bitCount2 = floor ( log2 ( n2 ) ) + 1 ; int bitDiff = abs ( bitCount1 - bitCount2 ) ; int maxBitCount = max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * pow ( 2 , bitDiff ) ; } else { n1 = n1 * pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue = floor ( log2 ( xorValue ) ) + 1 ; int disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }
int findevenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; int oddCount = count * ( count - 1 ) / 2 ; return ( N * ( N - 1 ) / 2 ) - oddCount ; }
void ReplaceElements ( int arr [ ] , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }
int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
void maxTriplet ( int a [ ] , int n ) { bool f [ n ] ; memset ( f , true , sizeof ( f ) ) ; int bits [ n ] [ 33 ] = { 0 } ; for ( int i = 0 ; i < n ; ++ i ) { int num = a [ i ] ; int j = 32 ; while ( num ) { if ( num & 1 ) { bits [ i ] [ j ] = 1 ; } j -- ; num >>= 1 ; } } long long ans = 0 ; for ( int i = 0 ; i <= 32 ; ++ i ) { int cnt = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( bits [ j ] [ i ] == 1 & f [ j ] ) { cnt ++ ; } } if ( cnt >= 3 ) { ans += pow ( 2 , 32 - i ) ; for ( int j = 0 ; j < n ; ++ j ) { if ( bits [ j ] [ i ] != 1 ) { f [ j ] = false ; } } } } int cnt = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( f [ i ] ) { cnt ++ ; } } long long NumberOfTriplets = ( cnt * ( cnt - 1 ) * ( cnt - 2 ) ) / 6 ; cout << NumberOfTriplets << " " << ans ; }
int AND ( int a [ ] , int n ) { int ans = a [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; }
int findEvenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( ! ( A [ i ] & 1 ) ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
void printOdds ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; int set_bit = res & ( ~ ( res - 1 ) ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } cout << x << " " << y ; }
void printKthBit ( long n , long k ) { cout << ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ; }
void decimalToBinaryNumber ( int x , int n ) { int binaryNumber [ x ] ; int i = 0 ; while ( x > 0 ) { binaryNumber [ i ] = x % 2 ; x = x / 2 ; i ++ ; } for ( int j = 0 ; j < n - i ; j ++ ) cout << '0' ; for ( int j = i - 1 ; j >= 0 ; j -- ) cout << binaryNumber [ j ] ; }
int XOR ( int a , int b ) { int c = min ( a , b ) ; int d = max ( a , b ) ; if ( count ( c ) < count ( d ) ) c = c << ( count ( d ) - count ( c ) ) ; return ( c ^ d ) ; }
unsigned int toggleBits ( unsigned int n1 , unsigned int n2 ) { return ( n1 ^ n2 ) ; }
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
int maxXorSum ( int n , int k ) { if ( k == 1 ) return n ; int res = 1 ; while ( res <= n ) res <<= 1 ; return res - 1 ; }
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
int maxAND ( int arr [ ] , int n ) { int res = 0 , count ; for ( int bit = 31 ; bit >= 0 ; bit -- ) { count = checkBit ( res | ( 1 << bit ) , arr , n ) ; if ( count >= 2 ) res |= ( 1 << bit ) ; } return res ; }
unsigned int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int countUnsetBits ( int n ) { int x = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return __builtin_popcount ( x ^ n ) ; }
int setBitNumber ( int n ) { int k = log2 ( n ) ; return 1 << k ; }
int toggle ( int n ) { int temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } return n ; }
int getFirstSetBitPos ( int n ) { return log2 ( n & - n ) + 1 ; }
int countNum ( int arr [ ] , int n ) { int count = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
int CountZeroBit ( long x ) { int count = 0 ; while ( x ) { if ( ( x & 1 ) == 0 ) count ++ ; x >>= 1L ; } return count ; }
int bitCount ( int n ) { int count = 0 ; while ( n ) { if ( n & 1 ) ++ count ; n >>= 1 ; } return count ; }
int sumoflength ( int * arr , int n ) { unordered_set < int > s ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n and s . find ( arr [ j ] ) == s . end ( ) ) { s . insert ( arr [ i ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . erase ( arr [ i ] ) ; } return ans ; }
bool areSetBitsIncreasing ( int n ) { int prev_count = INT_MAX ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = n / 2 ; int curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; }
bool findPattern ( int n ) { int prev = n % 2 ; n = n / 2 ; while ( n > 0 ) { int curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = n / 2 ; } return true ; }
bool isMultipleOf4 ( int n ) { if ( n == 1 ) return false ; int XOR = 0 ; for ( int i = 1 ; i <= n ; i ++ ) XOR = XOR ^ i ; return ( XOR == n ) ; }
char findProffesion ( int level , int pos ) { if ( level == 1 ) return 'e' ; if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == 'd' ) return ( pos % 2 ) ? 'd' : 'e' ; return ( pos % 2 ) ? 'e' : 'd' ; }
int swapBits ( int n , int p1 , int p2 ) { int bit1 = ( n >> p1 ) & 1 ; int bit2 = ( n >> p2 ) & 1 ; int x = ( bit1 ^ bit2 ) ; x = ( x << p1 ) | ( x << p2 ) ; int result = n ^ x ; return result ; }
int getElements ( Node * root ) { if ( root == NULL ) return 0 ; return getElements ( root -> left ) + getElements ( root -> right ) + 1 ; }
int sumOfDiv ( int x ) { int sum = 1 ; for ( int i = 2 ; i <= sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { sum += i ; if ( x / i != i ) sum += x / i ; } } return sum ; }
void leftRotate ( int arr [ ] , int d , int n ) { for ( int i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; }
void merge ( int arr [ ] , int l , int m , int r ) { int i = l ; int j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ; while ( j <= r && arr [ j ] < 0 ) j ++ ; reverse ( arr , i , m ) ; reverse ( arr , m + 1 , j - 1 ) ; reverse ( arr , i , j - 1 ) ; }
void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = -1 , j = 0 ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; swap ( arr [ i ] , arr [ j ] ) ; } j ++ ; } for ( int k = 0 ; k < n ; k ++ ) cout << arr [ k ] << " " ; }
void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 , int k ) { if ( k > n1 * n2 ) { cout << "k pairs don't exist" ; return ; } int index2 [ n1 ] = { 0 } ; while ( k > 0 ) { int min_sum = INT_MAX ; int min_index ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) { min_index = i1 ; min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ; } } cout << "(" << arr1 [ min_index ] << ", " << arr2 [ index2 [ min_index ] ] << ") " ; index2 [ min_index ] ++ ; k -- ; } }
int Solve ( int L , int R ) { int l = L , r = R ; int tot_bits = r - l + 1 ; int X = MAX ; for ( int i = 0 ; i < 31 ; i ++ ) { int x = one [ r ] [ i ] - one [ l - 1 ] [ i ] ; if ( x >= tot_bits - x ) { int ith_bit = pow ( 2 , i ) ; X = X ^ ith_bit ; } } return X ; }
void swap ( int arr [ ] , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; }
int findNumberOfTriangles ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] > arr [ k ] && arr [ i ] + arr [ k ] > arr [ j ] && arr [ k ] + arr [ j ] > arr [ i ] ) count ++ ; } } return count ; }
void CountTriangles ( vector < int > & A ) { int n = A . size ( ) ; sort ( A . begin ( ) , A . end ( ) ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else { l ++ ; } } } cout << "No of possible solutions: " << count ; }
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; sort ( arr , arr + n ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
int getSumAlternate ( Node * root ) { if ( root == NULL ) return 0 ; int sum = 0 ; if ( root -> left ) { sum += getSum ( root -> left -> left ) ; sum += getSum ( root -> left -> right ) ; } if ( root -> right ) { sum += getSum ( root -> right -> left ) ; sum += getSum ( root -> right -> right ) ; } return sum ; }
int getSum ( Node * root ) { if ( root == NULL ) return 0 ; return max ( getSumAlternate ( root ) , ( getSumAlternate ( root -> left ) + getSumAlternate ( root -> right ) ) ) ; }
int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return -1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }
int getHeight ( Node * Node ) { if ( Node == NULL ) return 0 ; else { int lHeight = getHeight ( Node -> left ) ; int rHeight = getHeight ( Node -> right ) ; if ( lHeight > rHeight ) return ( lHeight + 1 ) ; else return ( rHeight + 1 ) ; } }
void printLeaders ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) cout << arr [ i ] << " " ; } }
int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return -1 ; }
int getMin ( int arr [ ] , int n ) { int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } return min ; }
int interpolationSearch ( int arr [ ] , int lo , int hi , int x ) { int pos ; if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; if ( arr [ pos ] < x ) return interpolationSearch ( arr , pos + 1 , hi , x ) ; if ( arr [ pos ] > x ) return interpolationSearch ( arr , lo , pos - 1 , x ) ; } return -1 ; }
void sort ( int arr [ ] , int n ) { countSort ( arr , n , 1 ) ; countSort ( arr , n , n ) ; }
int countOnes ( bool arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
bool isUgly ( int no ) { no = maxDivide ( no , 2 ) ; no = maxDivide ( no , 3 ) ; no = maxDivide ( no , 5 ) ; return ( no == 1 ) ; }
unsigned long long int countRec ( int n , int sum ) { if ( n == 0 ) return sum == 0 ? 1 : 0 ; if ( sum == 0 ) return 1 ; unsigned long long int ans = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; }
unsigned long long int countRec ( int n , int sum ) { if ( n == 0 ) return sum == 0 ? 1 : 0 ; if ( lookup [ n ] [ sum ] != -1 ) return lookup [ n ] [ sum ] ; unsigned long long int ans = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return lookup [ n ] [ sum ] = ans ; }
int sumOfDigitsFrom1ToNUtil ( int n , int a [ ] ) { if ( n < 10 ) return n * ( n + 1 ) / 2 ; int d = log10 ( n ) ; int p = ceil ( pow ( 10 , d ) ) ; int msd = n / p ; return msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToNUtil ( n % p , a ) ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b , n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }
void printCombination ( int arr [ ] , int n , int r ) { int data [ r ] ; combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; }
int findCeil ( int arr [ ] , int r , int l , int h ) { int mid ; while ( l < h ) { mid = l + ( ( h - l ) >> 1 ) ; if ( r > arr [ mid ] ) l = mid + 1 ; else h = mid ; } return ( arr [ l ] >= r ) ? l : -1 ; }
int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
bool isPowerOfFour ( unsigned int n ) { if ( n == 0 ) return 0 ; return floor ( logn ( n , 4 ) ) == ceil ( logn ( n , 4 ) ) ; }
int countSetBits ( int n ) { return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) ; }
unsigned int countSetBitsRec ( unsigned int num ) { unsigned int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }
int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ! ( n & m ) ) { m = m << 1 ; position ++ ; } return position ; }
int swapBits ( int x ) { int even_bits = x & 0xAAAAAAAA ; int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; }
bool isPowerOfTwo ( int n ) { return ( n && ( ! ( n & ( n - 1 ) ) ) ) ? true : false ; }
void segregate0and1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }
int maxSum ( int arr [ ] , int n ) { int sum = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }
void updateindex ( int index [ ] , int a , int ai , int b , int bi ) { index [ a ] = ai ; index [ b ] = bi ; }
int minSwapsUtil ( int arr [ ] , int pairs [ ] , int index [ ] , int i , int n ) { if ( i > n ) return 0 ; if ( pairs [ arr [ i ] ] == arr [ i + 1 ] ) return minSwapsUtil ( arr , pairs , index , i + 2 , n ) ; int one = arr [ i + 1 ] ; int indextwo = i + 1 ; int indexone = index [ pairs [ arr [ i ] ] ] ; int two = arr [ index [ pairs [ arr [ i ] ] ] ] ; arr [ i + 1 ] = arr [ i + 1 ] ^ arr [ indexone ] ^ ( arr [ indexone ] = arr [ i + 1 ] ) ; updateindex ( index , one , indexone , two , indextwo ) ; int a = minSwapsUtil ( arr , pairs , index , i + 2 , n ) ; arr [ i + 1 ] = arr [ i + 1 ] ^ arr [ indexone ] ^ ( arr [ indexone ] = arr [ i + 1 ] ) ; updateindex ( index , one , indextwo , two , indexone ) ; one = arr [ i ] ; indexone = index [ pairs [ arr [ i + 1 ] ] ] ; two = arr [ index [ pairs [ arr [ i + 1 ] ] ] ] ; indextwo = i ; arr [ i ] = arr [ i ] ^ arr [ indexone ] ^ ( arr [ indexone ] = arr [ i ] ) ; updateindex ( index , one , indexone , two , indextwo ) ; int b = minSwapsUtil ( arr , pairs , index , i + 2 , n ) ; arr [ i ] = arr [ i ] ^ arr [ indexone ] ^ ( arr [ indexone ] = arr [ i ] ) ; updateindex ( index , one , indextwo , two , indexone ) ; return 1 + min ( a , b ) ; }
void process ( bool arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { arr [ k ] ^= arr [ k - 1 ] ; } }
void prefixXOR ( int arr [ ] , int preXOR [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( arr [ i ] % 2 != 1 ) arr [ i ] /= 2 ; preXOR [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] ; }
int query ( int preXOR [ ] , int l , int r ) { if ( l == 0 ) return preXOR [ r ] ; else return preXOR [ r ] ^ preXOR [ l - 1 ] ; }
int maxPartitions ( int arr [ ] , int n ) { int ans = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; ++ i ) { max_so_far = max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; }
int countPairs ( int a [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; }
int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }
int countPairs ( int A [ ] , int n , int k ) { int ans = 0 ; sort ( A , A + n ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int x = 0 ; while ( ( A [ i ] * pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; }
void printMax ( int arr [ ] , int k , int n ) { int brr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; sort ( brr , brr + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; ++ i ) if ( binary_search ( brr , arr [ i ] , brr + n , greater < int > ( ) ) < k ) cout << arr [ i ] << " " ; }
int find_consecutive_steps ( int arr [ ] , int len ) { int count = 0 ; int maximum = 0 ; for ( int index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = max ( maximum , count ) ; count = 0 ; } } return max ( maximum , count ) ; }
long long findSum ( int arr [ ] , int n ) { long long sum = 0 ; sort ( arr , arr + n ) ; int i = 0 ; while ( i < n && arr [ i ] < 0 ) { if ( i != n - 1 && arr [ i + 1 ] <= 0 ) { sum = ( sum + ( arr [ i ] * arr [ i + 1 ] ) % Mod ) % Mod ; i += 2 ; } else break ; } int j = n - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { if ( j != 0 && arr [ j - 1 ] > 0 ) { sum = ( sum + ( arr [ j ] * arr [ j - 1 ] ) % Mod ) % Mod ; j -= 2 ; } else break ; } if ( j > i ) sum = ( sum + ( arr [ i ] * arr [ j ] ) % Mod ) % Mod ; else if ( i == j ) sum = ( sum + arr [ i ] ) % Mod ; return sum ; }
void printList ( struct Node * head ) { struct Node * temp = head ; while ( temp != NULL ) { cout << temp -> data << " " ; temp = temp -> next ; } }
void insertAfterNthNode ( Node * head , int n , int x ) { if ( head == NULL ) return ; Node * newNode = getNode ( x ) ; Node * ptr = head ; int len = 0 , i ; while ( ptr != NULL ) { len ++ ; ptr = ptr -> next ; } ptr = head ; for ( i = 1 ; i <= ( len - n ) ; i ++ ) ptr = ptr -> next ; newNode -> next = ptr -> next ; ptr -> next = newNode ; }
void findLargestRotation ( int num ) { int ans = num ; int len = floor ( log10 ( num ) + 1 ) ; int x = pow ( 10 , len - 1 ) ; for ( int i = 1 ; i < len ; i ++ ) { int lastDigit = num % 10 ; num = num / 10 ; num += ( lastDigit * x ) ; if ( num > ans ) { ans = num ; } } cout << ans ; }
void reverse ( int arr [ ] , int s , int e ) { while ( s < e ) { int temp = arr [ s ] ; arr [ s ] = arr [ e ] ; arr [ e ] = tem ; s = s + 1 ; e = e - 1 ; } }
int countRotation ( int arr [ ] , int low , int high ) { if ( low > high ) return 0 ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid ] > arr [ mid + 1 ] ) return mid + 1 ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ mid ] > arr [ low ] ) return countRotation ( arr , mid + 1 , high ) ; if ( arr [ mid ] < arr [ high ] ) return countRotation ( arr , low , mid - 1 ) ; else { int rightIndex = countRotation ( arr , mid + 1 , high ) ; int leftIndex = countRotation ( arr , low , mid - 1 ) ; if ( rightIndex == 0 ) return leftIndex ; return rightIndex ; } }
void build ( int node , int l , int r , int a [ ] ) { if ( l == r ) seg [ node ] = a [ l ] ; else { int mid = ( l + r ) / 2 ; build ( 2 * node , l , mid , a ) ; build ( 2 * node + 1 , mid + 1 , r , a ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } }
bool rightRotationDivisor ( int N ) { int lastDigit = N % 10 ; int rightRotation = ( lastDigit * pow ( 10 , floor ( N / 10 ) ) + floor ( N / 10 ) ; return ( rightRotation % N == 0 ) ; }
int digitSum ( int num ) { int sum = 0 ; while ( num ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; }
void printList ( struct Node * start ) { struct Node * temp ; if ( start != NULL ) { temp = start ; do { cout << temp -> data << " " ; temp = temp -> next ; } while ( temp != start ) ; } }
void displayList ( struct Node * start ) { struct Node * temp = start ; while ( temp -> next != start ) { printf ( "%d " , temp -> data ) ; temp = temp -> next ; } printf ( "%d " , temp -> data ) ; }
int alivesol ( int Num ) { if ( Num == 1 ) return 1 ; Node * last = newNode ( 1 ) ; last -> next = last ; for ( int i = 2 ; i <= Num ; i ++ ) { Node * temp = newNode ( i ) ; temp -> next = last -> next ; last -> next = temp ; last = temp ; } Node * curr = last -> next ; Node * temp ; while ( curr -> next != curr ) { temp = curr ; curr = curr -> next ; temp -> next = curr -> next ; temp = temp -> next ; curr = temp ; } int res = temp -> data ; return res ; }
void addEdge ( int u , int v , int cost ) { graph [ u ] . push_back ( { v , cost } ) ; graph [ v ] . push_back ( { u , cost } ) ; }
void dfs ( int node , int parent , int h ) { lca [ node ] [ 0 ] = parent ; level [ node ] = h ; if ( parent != -1 ) { minWeight [ node ] [ 0 ] = min ( weight [ node ] , weight [ parent ] ) ; maxWeight [ node ] [ 0 ] = max ( weight [ node ] , weight [ parent ] ) ; } for ( int i = 1 ; i < log ; i ++ ) { if ( lca [ node ] [ i - 1 ] != -1 ) { lca [ node ] [ i ] = lca [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ; minWeight [ node ] [ i ] = min ( minWeight [ node ] [ i - 1 ] , minWeight [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; maxWeight [ node ] [ i ] = max ( maxWeight [ node ] [ i - 1 ] , maxWeight [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; } } for ( auto i : graph [ node ] ) { if ( i == parent ) continue ; dfs ( i , node , h + 1 ) ; } }
int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) swap ( u , v ) ; v = parent [ v ] ; return LCANaive ( u , v ) ; }
int solve ( int A [ ] , int n ) { int i , cnt = 0 , j ; int parent [ n ] , vis [ n ] ; memset ( parent , -1 , sizeof ( parent ) ) ; memset ( vis , 0 , sizeof ( vis ) ) ; for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == -1 ) { while ( parent [ j ] == -1 ) { parent [ j ] = i ; j = __gcd ( j , A [ j ] ) % n ; } if ( parent [ j ] == i ) { while ( vis [ j ] == 0 ) { vis [ j ] = 1 ; cnt ++ ; j = __gcd ( j , A [ j ] ) % n ; } } } } return cnt ; }
void clear ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) { lvl [ i ] = 0 ; } maxi = 0 ; dist1 [ 0 ] = dist2 [ 0 ] = -1 ; }
long long int possiblePositions ( int n ) { int term1 = pow ( n , 4 ) ; int term2 = pow ( n , 3 ) ; int term3 = pow ( n , 2 ) ; int term4 = n / 3 ; int ans = ceil ( term1 / 2 ) - ( ceil ( 5 * term2 ) / 3 ) + ceil ( 3 * term3 ) / 2 ) - term4 ; return ans ; }
bool countSingleRec ( Node * root , Count * c ) { if ( root == NULL ) return true ; bool left = countSingleRec ( root -> left , c ) ; bool right = countSingleRec ( root -> right , c ) ; if ( left == false right == false ) return false ; if ( root -> left != NULL && root -> data != root -> left -> data ) return false ; if ( root -> right != NULL && root -> data != root -> right -> data ) return false ; c . count ++ ; return true ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
ll modInverse ( ll n , ll p ) { return power ( n , p - 2 , p ) ; }
ll CountEvenSumSequences ( ll n ) { ll count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { int even = i , odd = n - i ; if ( odd % 2 == 1 ) continue ; ll tot = ( power ( countOdd ( n ) , odd , M ) * nCrModPFermat ( n , odd , M ) ) % M ; tot = ( tot * power ( counteEven ( n ) , i , M ) ) % M ; count += tot ; count %= M ; } return count ; }
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
int nextOccurrence ( string str , int n , int start , char ch ) { for ( int i = start ; i < n ; i ++ ) { if ( str [ i ] == ch ) return i ; } return -1 ; }
int changeToOnes ( string str ) { int i , l , ctr = 0 ; l = str . length ( ) ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '1' ) ctr ++ ; else break ; } return l - ctr ; }
int getCount ( int a [ ] , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = calgcd ( gcd , a [ i ] ) ; int cnt = 0 ; for ( int i = 1 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { if ( i * i == gcd ) cnt ++ ; else cnt += 2 ; } } return cnt ; }
int findMissingPositive ( int arr [ ] , int n ) { int m = 1 ; unordered_set < int > x ; for ( int i = 0 ; i < n ; i ++ ) { if ( m < arr [ i ] ) x . insert ( arr [ i ] ) ; else if ( m == arr [ i ] ) { m = m + 1 ; while ( x . find ( m ) != x . end ( ) ) { x . erase ( m ) ; m = m + 1 ; } } } return m ; }
bool isPalindrome ( string str , int i , int j ) { while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
void revereseArray ( int arr [ ] , int n ) { int rev [ n ] ; for ( int i = 0 ; i < n ; i ++ ) rev [ n - i - 1 ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = rev [ i ] ; }
int _log ( double x , double base ) { return log ( x ) / log ( base ) ; }
int maximumCut ( int arr [ ] , int K ) { int low = 0 ; int high = * max_element ( arr , arr + N ) ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int chocolate = cal ( arr , mid ) ; if ( chocolate == K ) return mid ; else if ( chocolate < K ) high = mid - 1 ; else { low = mid + 1 ; if ( mid > high ) high = mid ; } } return high ; }
void findMissingBinaryString ( vector < string > nums , int N ) { unordered_set < string > s ; int counter = 0 ; for ( string str : nums ) { s . insert ( str ) ; } int total = pow ( 2 , N ) ; string ans = "" ; for ( int i = 0 ; i < total ; i ++ ) { string num = "" ; for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( i & ( 1 << j ) ) { num += '1' ; } else { num += '0' ; } } if ( s . find ( num ) != s . end ( ) ) { counter ++ ; continue ; } else { cout << num << ", " ; } } if ( counter == total ) { cout << "-1" ; } }
int Minimum ( int N , int K ) { int sum = N * ( N + 1 ) / 2 ; if ( K > sum ) return -1 ; if ( K <= N ) return 1 ; sum = 0 ; int count = 0 ; while ( N >= 1 && sum < K ) { count += 1 ; sum += N ; N -= 1 ; } return count ; }
int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int sum = 0 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += i ; if ( sum <= K ) res ++ ; else break ; } return res ; }
void mostFrequent ( int arr [ ] , int N ) { vector < int > ans ( N , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { vector < int > count ( N , 0 ) ; int best = 1 ; for ( int j = i ; j < N ; j ++ ) { count [ arr [ j ] - 1 ] ++ ; if ( best > 0 ) { if ( ( count [ arr [ j ] - 1 ] > count [ best - 1 ] ) || ( count [ arr [ j ] - 1 ] == count [ best - 1 ] && arr [ j ] < best ) ) { best = arr [ j ] ; } ans [ best - 1 ] ++ ; } } } for ( int i = 0 ; i < N ; i ++ ) cout << ans [ i ] << " " ; }
void Add_edge ( int u , int v ) { edges [ u ] . push_back ( v ) ; edges [ v ] . push_back ( u ) ; }
void minCost ( vector < vector < char > > & arr , int A , int B ) { int n = arr . size ( ) ; int m = arr [ 0 ] . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == '*' ) continue ; if ( j == m - 1 ) ans += A ; else { if ( arr [ i ] [ j + 1 ] == '.' ) { ans += min ( 2 * A , B ) ; j ++ ; } else ans += A ; } } } cout << ans ; }
int binarySeach ( vector < int > P , int N ) { int i = 0 ; int j = P . size ( ) - 1 ; int index = -1 ; while ( i <= j ) { int mid = i + ( j - i ) / 2 ; if ( P [ mid ] >= N ) { index = mid ; j = mid - 1 ; } else { i = mid + 1 ; } } return index ; }
int countPairs ( int arr [ ] , int N ) { int count = 0 ; set < int > S ; for ( int i = 0 ; i < N ; i ++ ) S . insert ( arr [ i ] ) ; for ( auto ele : S ) { int sum = 2 * ele ; count += getCountPairs ( arr , N , sum ) ; } return count ; }
void SieveOfEratosthenes ( bool prime [ ] ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < MAX ; i += p ) prime [ i ] = false ; } } }
void printReverse ( string sentence ) { vector < string > newlist ; vector < string > lis ; string temp = "" ; for ( char x : sentence ) { if ( x == ' ' ) { lis . push_back ( temp ) ; temp = "" ; } else temp += x ; } lis . push_back ( temp ) ; for ( string x : lis ) { if ( palindrome ( x ) ) newlist . push_back ( x ) ; } reverse ( newlist . begin ( ) , newlist . end ( ) ) ; int j = 0 ; for ( int i = 0 ; i < lis . size ( ) ; i ++ ) { if ( palindrome ( lis [ i ] ) ) { lis [ i ] = newlist [ j ] ; j = j + 1 ; } } for ( string x : lis ) cout << x << " " ; }
int maximumNumber ( int arr [ ] , int N , int K ) { int minimum = * min_element ( arr , arr + N ) ; int ans = minimum + K ; for ( int i = 0 ; i < N ; i ++ ) { if ( abs ( arr [ i ] - ans ) > K ) { ans = -1 ; break ; } } cout << ans ; }
int CountPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( i * j ) == ( arr [ i ] * arr [ j ] ) ) count ++ ; } } return count ; }
bool checkGroup ( vector < int > arr ) { if ( arr . size ( ) <= 2 ) return true ; int corner = arr [ 0 ] + arr [ arr . size ( ) - 1 ] ; int xorSum = 0 ; for ( int i = 0 ; i < arr . size ( ) - 1 ; i ++ ) xorSum += ( arr [ i ] ^ arr [ i + 1 ] ) ; if ( corner == 0 ) if ( xorSum > 2 ) return false ; else if ( corner == 1 ) if ( xorSum > 1 ) return false ; else if ( xorSum > 0 ) return false ; return true ; }
bool isPalindrome ( string & S , int i , int j ) { while ( i < j ) { if ( S [ i ] != S [ j ] ) return false ; i ++ ; j -- ; } return true ; }
void printLongestPalindrome ( string & S , int N ) { int palLength [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int maxlength = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( S [ j ] == S [ i ] ) { if ( isPalindrome ( S , j , i ) ) { maxlength = i - j + 1 ; break ; } } } for ( int j = N - 1 ; j > i ; j -- ) { if ( S [ j ] == S [ i ] ) { if ( isPalindrome ( S , i , j ) ) { maxlength = max ( j - i + 1 , maxlength ) ; break ; } } } palLength [ i ] = maxlength ; } for ( int i = 0 ; i < N ; i ++ ) { cout << palLength [ i ] << " " ; } }
void findMaxIntervals ( vector < pair < int , int > > v , int n ) { int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int c = n ; for ( int j = 0 ; j < n ; j ++ ) { if ( v [ i ] . second < v [ j ] . first || v [ i ] . first > v [ j ] . second ) { c -- ; } } maxi = max ( c , maxi ) ; } cout << maxi ; }
void update ( int ss , int se , int si , int X , int V , int tree [ ] , int arr [ ] ) { if ( ss == se ) { if ( ss == X ) { arr [ X ] = V ; tree [ si ] = check ( V ) ; } return ; } int mid = ( ss + se ) / 2 ; if ( X <= mid ) update ( ss , mid , 2 * si + 1 , X , V , tree , arr ) ; else update ( mid + 1 , se , 2 * si + 2 , X , V , tree , arr ) ; tree [ si ] = tree [ 2 * si + 1 ] + tree [ 2 * si + 2 ] ; }
int atleast_x ( int index , int s , int e , int ql , int qr , int x ) { if ( ql > e qr < s ) return -1 ; if ( s <= ql && e <= qr ) { if ( Tree [ index ] < x ) return -1 ; while ( s != e ) { int m = ( s + e ) / 2 ; if ( Tree [ 2 * index ] >= x ) { e = m ; index = 2 * index ; } else { s = m + 1 ; index = 2 * index + 1 ; } } return s ; } int m = ( s + e ) / 2 ; int val = atleast_x ( 2 * index , s , m , ql , qr , x ) ; if ( val != -1 ) return val ; return atleast_x ( 2 * index + 1 , m + 1 , e , ql , qr , x ) ; }
void rearrange ( int a [ ] , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) a [ i ] = abs ( a [ i ] ) ; sort ( a , a + n ) ; x = n - x ; int z = count ( a ) ; if ( x > n - z ) { cout << "-1" << endl ; return ; } for ( int i = 0 ; i < n && x > 0 ; i += 2 ) { a [ i ] = - a [ i ] ; x -- ; } for ( int i = n - 1 ; i >= 0 && x > 0 ; i -- ) { if ( a [ i ] > 0 ) { a [ i ] = - a [ i ] ; x -- ; } } for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << " " ; } }
void countTriplets ( int arr [ ] , int N ) { vector < int > zero_i ; vector < int > one_i ; map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero_i . push_back ( i + 1 ) ; else if ( arr [ i ] == 1 ) one_i . push_back ( i + 1 ) ; else mp [ i + 1 ] = 1 ; } int total = zero_i . size ( ) * one_i . size ( ) * mp . size ( ) ; for ( int i = 0 ; i < zero_i . size ( ) ; i ++ ) { for ( int j = 0 ; j < one_i . size ( ) ; j ++ ) { int p = zero_i [ i ] ; int q = one_i [ j ] ; int r = 2 * p - q ; if ( mp . find ( r ) != mp . end ( ) && mp [ r ] > 0 ) total -- ; r = 2 * q - p ; if ( mp . find ( r ) != mp . end ( ) && mp [ r ] > 0 ) total -- ; r = ( p + q ) / 2 ; if ( mp . find ( r ) != mp . end ( ) && mp [ r ] > 0 && abs ( r - p ) == abs ( r - q ) ) total -- ; } } cout << total ; }
void Pairs ( int N , int A , int B ) { int powerA , powerB ; powerA = power ( A , N ) ; powerB = power ( B , N ) ; int intialB = B , intialA = A ; A = 1 ; for ( int i = 0 ; i <= powerA ; i ++ ) { B = 1 ; for ( int j = 0 ; j <= powerB ; j ++ ) { if ( B == N - A ) { cout << i << " " << j ; return ; } B *= intialB ; } A *= intialA ; } cout << "-1" ; return ; }
int CountSubarray ( int arr [ ] , int n , int k ) { int temp = k , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; }
void findElement ( int arr [ ] , int N , int K ) { int ele = findElementUtil ( arr , N , K ) ; if ( ele == -1 ) cout << "-1" ; else cout << ele ; }
int findCntTriplet ( int N ) { int cntTriplet = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( N % i != 0 ) { cntTriplet += N / i ; } else { cntTriplet += ( N / i ) - 1 ; } } return cntTriplet ; }
void splitString ( string S , int N ) { char c = S [ N - 1 ] ; int f = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] == c ) { f = 1 ; break ; } } if ( f ) cout << "Yes" ; else cout << "No" ; }
void minOperations ( int arr [ ] , int n ) { int flips = 0 ; for ( int i = 0 ; i < n ; i += 2 ) { if ( arr [ i ] % 2 == 1 ) { continue ; } while ( i < n && arr [ i ] % 2 == 0 ) { i += 2 ; } flips ++ ; } for ( int i = 1 ; i < n ; i += 2 ) { if ( arr [ i ] % 2 == 1 ) { continue ; } while ( i < n && arr [ i ] % 2 == 0 ) { i += 2 ; } flips ++ ; } cout << flips << endl ; }
void checkAnswer ( map < int , int > mp , int N , int K ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( mp [ i ] == ( N - K + 1 ) ) { cout << i << " " ; return ; } } cout << -1 << " " ; }
void updateAnswerArray ( int answer [ ] , int N ) { int i = 0 ; while ( answer [ i ] == -1 ) i ++ ; int minimum = answer [ i ] ; while ( i <= N ) { if ( answer [ i ] == -1 ) answer [ i ] = minimum ; else answer [ i ] = min ( minimum , answer [ i ] ) ; minimum = min ( minimum , answer [ i ] ) ; i ++ ; } }
void checkString ( string X , string Y ) { int L = -1 ; int R = -1 ; for ( int i = 0 ; i < X . length ( ) ; ++ i ) { if ( X [ i ] != Y [ i ] ) { L = i ; break ; } } for ( int i = X . length ( ) - 1 ; i > 0 ; -- i ) { if ( X [ i ] != Y [ i ] ) { R = i ; break ; } } X = X . substr ( 0 , L ) + reverse ( X . substr ( L , R + 1 ) ) + X . substr ( R + 1 ) ; if ( X == Y ) { cout << "Yes" ; } else { cout << "No" ; } }
char longestLastingBulb ( vector < int > onTime , vector < char > s ) { char ans ; int n = onTime . size ( ) ; int maxDur = INT_MIN ; int maxPos = INT_MIN ; int currentDiff ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { currentDiff = onTime [ i ] ; maxDur = currentDiff ; maxPos = i ; } else { currentDiff = onTime [ i ] - onTime [ i - 1 ] ; if ( maxDur < currentDiff ) { maxDur = currentDiff ; maxPos = i ; } else { if ( maxDur == currentDiff ) { char one = s [ i ] ; char two = s [ maxPos ] ; if ( one > two ) { maxDur = currentDiff ; maxPos = i ; } } } } } ans = s [ maxPos ] ; return ans ; }
void max_freq ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int Max = arr [ N - 1 ] ; int Min = arr [ 0 ] ; int freq [ Max - Min + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] - Min ] ++ ; } int maxSum = 0 ; for ( int i = 0 ; i < ( Max - Min - 1 ) ; i ++ ) { int val = freq [ i ] + freq [ i + 1 ] + freq [ i + 2 ] ; maxSum = max ( maxSum , val ) ; } cout << maxSum ; }
int find_longest_subarray ( vector < int > A , int N , int K ) { int MaxLen = 0 ; int Len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( K % A [ i ] == 0 ) { Len ++ ; MaxLen = max ( MaxLen , Len ) ; } else { Len = 0 ; } } return MaxLen ; }
void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
string kReducingStringUtil ( int n , int k , string str , int no_of_zeroes ) { int zeroes_in_2k = ( ( no_of_zeroes ) * ( 2 * k ) ) / n ; int ones_in_2k = 2 * k - zeroes_in_2k ; string temp_str = "" ; for ( int i = 0 ; i < ( zeroes_in_2k ) / 2 ; i ++ ) temp_str += '0' ; for ( int i = 0 ; i < ones_in_2k ; i ++ ) temp_str += '1' ; for ( int i = 0 ; i < ( zeroes_in_2k ) / 2 ; i ++ ) temp_str += '0' ; string final_str = "" ; for ( int i = 0 ; i < n / ( 2 * k ) ; i ++ ) final_str += ( temp_str ) ; for ( int i = 0 ; i < n % ( 2 * k ) ; i ++ ) final_str += temp_str [ i ] ; return final_str ; }
int power ( int x , unsigned int N ) { int res = 1 ; while ( N > 0 ) { if ( N & 1 ) { res = ( res * x ) ; } x = ( x * x ) ; N = N >> 1 ; } return res ; }
void countRemovableElem ( int arr [ ] , int N ) { int hash [ N + 1 ] = { 0 } ; int mex = N + 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= N ) hash [ arr [ i ] ] = 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( hash [ i ] == 0 ) { mex = i ; break ; } } cout << N - ( mex - 1 ) << endl ; }
void findMaxPoints ( int arr [ ] [ 2 ] , int n ) { int ans [ ] = findMaxPoint ( arr , 0 , n ) ; if ( ans [ 0 ] == INF ) { cout << -1 ; } else { cout << "(" << ans [ 0 ] << " " << ans [ 1 ] << ")" ; } }
int numberOfGP ( int L [ ] , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
bool palindrome ( int a [ ] , int i , int j ) { while ( i < j ) { if ( a [ i ] != a [ j ] ) return false ; i ++ ; j -- ; } return true ; }
void countGreater ( int arr [ ] , int N ) { set < int > St ; int countLeftGreater [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { St . insert ( arr [ i ] ) ; int it = 0 ; for ( auto it = St . begin ( ) ; it != St . end ( ) ; it ++ ) { if ( arr [ i ] < it ) { break ; } it ++ ; } countLeftGreater [ i ] = abs ( it - St . size ( ) ) ; } display ( countLeftGreater , N ) ; }
int key ( int N ) { string num = "" + N ; int ans = 0 ; int j = 0 ; for ( j = 0 ; j < num . length ( ) ; j ++ ) { if ( ( num [ j ] - 48 ) % 2 == 0 ) { int add = 0 ; int i ; for ( i = j ; j < num . length ( ) ; j ++ ) { add += num [ j ] - 48 ; if ( add % 2 ) break ; } if ( add == 0 ) { ans *= 10 ; } else { int digit = floor ( log10 ( add ) + 1 ) ; ans *= ( pow ( 10 , digit ) ) ; ans += add ; } i = j ; } else { int add = 0 ; int i ; for ( i = j ; j < num . length ( ) ; j ++ ) { add += num [ j ] - 48 ; if ( add % 2 == 0 ) { break ; } } if ( add == 0 ) { ans *= 10 ; } else { int digit = floor ( log10 ( add ) + 1 ) ; ans *= ( pow ( 10 , digit ) ) ; ans += add ; } i = j ; } } if ( j + 1 >= num . length ( ) ) { return ans ; } else { return ans += num [ num . length ( ) - 1 ] - 48 ; } }
int longDelSub ( string str1 , string str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; int prev_pos = 0 ; int pos [ M ] ; for ( int i = 0 ; i < M ; i ++ ) { int index = prev_pos ; while ( index < N && str1 [ index ] != str2 [ i ] ) { index ++ ; } pos [ i ] = index ; prev_pos = index + 1 ; } int res = N - prev_pos ; prev_pos = N - 1 ; for ( int i = M - 1 ; i >= 0 ; i -- ) { int index = prev_pos ; while ( index >= 0 && str1 [ index ] != str2 [ i ] ) { index -- ; } if ( i != 0 ) { res = max ( res , index - pos [ i - 1 ] - 1 ) ; } prev_pos = index - 1 ; } res = max ( res , prev_pos + 1 ) ; return res ; }
int countSubArray ( int arr [ ] , int n ) { if ( n < 2 ) return n ; int i = * max_element ( arr , arr + n ) ; int j = * min_element ( arr , arr + n ) ; if ( i > j ) swap ( arr [ i ] , arr [ j ] ) ; return ( i + 1 ) * ( n - j ) ; }
bool isPerfectSquare ( int n ) { long double sr = sqrt ( n ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; }
void updateFreq ( int n , int freq [ ] ) { while ( n ) { int digit = n % TEN ; freq [ digit ] ++ ; n /= TEN ; } }
int count_numbers ( int L , int R ) { int ans = 0 ; int LogR = ( int ) ( log ( R ) + 1 ) ; for ( int zero_bit = 0 ; zero_bit < LogR ; zero_bit ++ ) { int cur = 0 ; for ( int j = 0 ; j < zero_bit ; j ++ ) { cur |= ( 1LL << j ) ; } for ( int j = zero_bit + 1 ; j < LogR ; j ++ ) { cur |= ( 1LL << j ) ; if ( cur >= L && cur <= R ) { ans ++ ; } } } return ans ; }
int maxGCD ( int n ) { return ( n / 2 ) ; }
void updateTree ( string str , int pos , char s ) { int index = pos ; update_BITree ( index , str [ index ] , -1 ) ; str . erase ( index , 1 ) ; update_BITree ( index , s , 1 ) ; }
int minServerLoads ( int n , vector < int > & servers ) { int totalLoad = 0 ; for ( int i = 0 ; i < servers . size ( ) ; i ++ ) totalLoad += servers [ i ] ; int requiredLoad = totalLoad / 2 ; int dp [ n + 1 ] [ requiredLoad + 1 ] ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < requiredLoad + 1 ; j ++ ) { if ( servers [ i - 1 ] > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , servers [ i - 1 ] + dp [ i - 1 ] [ j - servers [ i - 1 ] ] ) ; } } return totalLoad - 2 * dp [ n ] [ requiredLoad ] ; }
int maxLength ( vector < string > & arr ) { int len = INT_MIN ; int N = arr . size ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int l = arr [ i ] . length ( ) ; if ( len < l ) { len = l ; } } return len ; }
void dfs ( int node ) { vis [ node ] = true ; for ( auto x : vec [ node ] ) { if ( ! vis [ x ] ) { cc ++ ; dfs ( x ) ; } } }
double solve ( vector < vector < int > > & D , int N , int X , int Y ) { vector < double > T ; for ( int i = 0 ; i < N ; i ++ ) { int x = D [ i ] [ 0 ] ; int y = D [ i ] [ 1 ] ; double speed = D [ i ] [ 2 ] ; double time = ( ( x * x - X * X ) + ( y * y - Y * Y ) ) / ( speed * speed ) ; T . push_back ( time ) ; } sort ( T . begin ( ) , T . end ( ) ) ; int i = 0 ; int total = 0 ; while ( i < ( T . size ( ) - 1 ) ) { int count = 1 ; while ( ( i < ( T . size ( ) - 1 ) ) && ( compare ( T [ i ] , T [ i + 1 ] ) == 0 ) ) { count += 1 ; i += 1 ; } total += ( count * ( count - 1 ) ) / 2 ; i += 1 ; } return total ; }
vector < int > findSubarrays ( vector < int > & a ) { int n = a . size ( ) ; vector < int > freq ( n + 1 , 0 ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { if ( count == 0 ) continue ; else { int value = count ; for ( int j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } count = 0 ; } } else count ++ ; } if ( count > 0 ) { vector < int > value = count ; for ( int j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } } return freq ; }
void sumOfIndices ( string s ) { int N = s . size ( ) ; int x = ceil ( log2 ( N ) ) ; int seg_size = 2 * pow ( 2 , x ) - 1 ; int segment [ seg_size ] = { 0 } ; int count = 0 ; map < int , vector < int > > fre ; for ( int i = 0 ; i < N ; i ++ ) { int key = int ( s [ i ] ) ; vector < int > que ; que . push_back ( i ) ; fre [ key ] . push_back ( que ) ; } while ( ! fre . empty ( ) ) { auto it = fre . begin ( ) ; if ( fre [ it ] . size ( ) == 0 ) fre . erase ( it ) ; else { vector < int > que = fre [ it ] ; int original_index = que . front ( ) ; int curr_index = deleted ( segment , 0 , original_index - 1 , 0 , N - 1 , 0 ) ; int new_index = original_index - curr_index ; count += new_index + 1 ; add_seg ( segment , 0 , N - 1 , 0 , original_index ) ; que . pop_front ( ) ; fre [ it ] = que ; } } cout << count ; }
int maxLength ( int n , int m ) { sieve ( ) ; smallestPrimeFactors ( ) ; int ans = INT_MIN ; for ( int i = n ; i <= m ; i ++ ) { if ( i == 4 ) { continue ; } ans = max ( ans , findLength ( i ) ) ; } return ans ; }
int getMax ( int * st , int n , int l , int r ) { if ( l < 0 r > n  - 1 l > r ) { printf ( "Invalid Input" ) ; return -1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; }
int subArraylen ( int arr [ ] , int n , int K ) { unordered_map < int , int > mp ; mp [ arr [ 0 ] ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; mp [ arr [ i ] ] = i ; } int len = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < K ) continue ; else { int x = K - arr [ i ] ; if ( x == 0 ) len = min ( len , i ) ; if ( mp . find ( x ) != mp . end ( ) ) continue ; else { len = min ( len , i ) ; } } } return len ; }
bool check ( int arr [ ] , int n ) { int i , g ; g = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 0 && g == 1 ) return false ; if ( arr [ i ] - arr [ i - 1 ] < 0 ) g = 1 ; } return true ; }
void addedge ( int node1 , int node2 ) { G [ node1 ] . push_back ( node2 ) ; G [ node2 ] . push_back ( node1 ) ; }
int countElements ( int arr [ ] , int n , int k ) { stack < int > s ; vector < int > next_greater ( n + 1 , n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . empty ( ) ) { s . push ( i ) ; continue ; } while ( ! s . empty ( ) && arr [ s . top ( ) ] < arr [ i ] ) { next_greater [ s . top ( ) ] = i ; s . pop ( ) ; } s . push ( i ) ; } int count = 0 ; int maxi = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( next_greater [ i ] - i > k && maxi < arr [ i ] ) { maxi = max ( maxi , arr [ i ] ) ; count ++ ; } } return count ; }
void addEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; }
vector < vector < int > > constructTree ( int n , vector < pair < int , int > > edges ) { vector < vector < int > > adjl ( n ) ; for ( auto e : edges ) { int u = e . first ; int v = e . second ; adjl [ u ] . push_back ( v ) ; adjl [ v ] . push_back ( u ) ; } return adjl ; }
int min_remove ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] - arr [ i ] <= k ) { ans = min ( ans , n - j + i - 1 ) ; } } } return ans ; }
int lcm ( int a , int b ) { return ( a * b ) / __gcd ( a , b ) ; }
int countPair ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( __gcd ( i , j ) + lcm ( i , j ) == N ) { count ++ ; } } } return count ; }
bool isVowel ( char c ) { if ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) return true ; return false ; }
void countSubstrings ( string s , int n ) { int temp [ 2 ] = { 1 , 0 } ; int result = 0 , sum = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { sum += ( isVowel ( s [ i ] ) ? 1 : 0 ) ; sum %= 2 ; temp [ sum ] ++ ; } result += ( ( temp [ 0 ] * ( temp [ 0 ] - 1 ) ) / 2 ) ; result += ( ( temp [ 1 ] * ( temp [ 1 ] - 1 ) ) / 2 ) ; cout << result ; }
int minOperations ( string s ) { int n = s . length ( ) ; int pos = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) { pos = i ; break ; } } if ( pos == -1 ) { return 0 ; } int last = 1 ; int ans = 1 ; for ( int i = pos + 1 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) { if ( last == 1 ) { ans ++ ; last = 0 ; } } else { if ( last == 0 ) { ans ++ ; last = 1 ; } } } return ans ; }
bool checkBitonic ( int arr [ ] , int n ) { int i , j , f = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { f = 1 ; break ; } } if ( i == n ) return true ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < arr [ j - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { if ( f == 1 ) return false ; } } return true ; }
bool isNudeNum ( int n ) { int copy , length , flag = 0 ; copy = n ; string temp ; temp = to_string ( copy ) ; length = temp . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { int num = temp [ i ] - '0' ; if ( num == 0 n % num != 0 ) { flag = 1 ; } } if ( flag == 1 ) return false ; else return true ; }
vector < int > get_subminarr ( int * arr , int n , int y ) { int j = 0 ; stack < int > stk ; vector < int > minarr ( n ) ; stk . push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( stk . empty ( ) == false and arr [ i ] < arr [ stk . top ( ) ] ) { minarr [ stk . top ( ) ] = i ; stk . pop ( ) ; } stk . push ( i ) ; } while ( ! stk . empty ( ) ) { minarr [ stk . top ( ) ] = n ; stk . pop ( ) ; } vector < int > submin ; for ( int i = 0 ; i <= n - y ; i ++ ) { while ( minarr [ j ] <= i + y - 1 or j < i ) { j ++ ; } submin . push_back ( arr [ j ] ) ; } return submin ; }
void PrintSequence ( int freq [ ] , int n ) { vector < int > sequence = generateSequence ( freq , n ) ; if ( sequence . size ( ) == 0 ) { cout << "-1" ; } else { for ( auto i : sequence ) { cout << i << " " ; } } }
void checkArray ( int A [ ] , int B [ ] , int N ) { int start = 0 ; int end = N - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { start = i ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( A [ i ] != B [ i ] ) { end = i ; break ; } } reverse ( A , A + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { cout << "No" ; return ; } } cout << "Yes" ; }
int longestSubarray ( int a [ ] , int n ) { int l [ n ] , r [ n ] ; for ( int i = 0 , count = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; else { l [ i ] = count ; count = 0 ; } } for ( int i = n - 1 , count = 0 ; i >= 0 ; i -- ) { if ( a [ i ] == 1 ) count ++ ; else { r [ i ] = count ; count = 0 ; } } int ans = -1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] == 0 ) ans = max ( ans , l [ i ] + r [ i ] ) ; } return ans < 0 ? n : ans ; }
int solve ( int n , int k ) { int ans = 0 ; for ( int j = 1 ; j * j <= n ; j ++ ) { if ( n % j == 0 ) { if ( j <= k ) { ans = max ( ans , j ) ; } if ( n / j <= k ) { ans = max ( ans , n / j ) ; } } } return ans ; }
int splitArray ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int result = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { result = min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
int countTriplets ( int a [ ] , int n , int x ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { vector < int > temp ; temp . push_back ( a [ i ] ) ; temp . push_back ( a [ j ] ) ; temp . push_back ( a [ k ] ) ; sort ( temp . begin ( ) , temp . end ( ) ) ; if ( temp [ 0 ] < temp [ 1 ] && temp [ 1 ] < temp [ 2 ] && temp [ 0 ] * temp [ 1 ] * temp [ 2 ] <= x ) answer ++ ; } } } return answer ; }
void fibonacci ( ) { int prev = 0 , curr = 1 , len = 2 ; fib . insert ( prev ) ; fib . insert ( curr ) ; while ( len <= MAX ) { int temp = curr + prev ; fib . insert ( temp ) ; prev = curr ; curr = temp ; len ++ ; } }
int xorOfSum ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; }
void createHash ( set < int > & hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr < maxElement ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } }
void state8 ( char c ) { if ( c == 'c' ) nfa = 9 ; else if ( c == 'b' c == 'a' ) nfa = 8 ; else flag = 1 ; }
int maxSum ( int arr [ ] , int n , int k ) { if ( n < k ) return -1 ; int res = 0 ; for ( int i = 0 ; i < k ; i ++ ) res += arr [ i ] ; int curr_sum = res ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; res = max ( res , curr_sum ) ; } return res ; }
bool isDigit ( char ch ) { if ( ch >= '0' && ch <= '9' ) return true ; return false ; }
int nextPosition ( int tempGCD , int startPointer , int prevEndPointer , int n ) { int high = n - 1 ; int low = prevEndPointer ; int mid = prevEndPointer ; int nextPos = prevEndPointer ; while ( high >= low ) { mid = ( ( high + low ) >> 1 ) ; if ( queryForGCD ( startPointer , mid ) == tempGCD ) { nextPos = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return nextPos + 1 ; }
int gcd ( int A , int B ) { if ( B == 0 ) return A ; return gcd ( B , A % B ) ; }
void farthest_min ( int a [ ] , int n ) { int suffix_min [ n ] ; suffix_min [ n - 1 ] = a [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffix_min [ i ] = min ( suffix_min [ i + 1 ] , a [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { int low = i + 1 , high = n - 1 , ans = -1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( suffix_min [ mid ] < a [ i ] ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } cout << ans << " " ; } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int solve ( vector < int > & array , int n , int K ) { int start = 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( array [ i ] > start ) } int end = 0 ; for ( int i = 0 ; i < n ; i ++ ) { } int answer = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( check ( mid , array , n , K ) ) { answer = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } return answer ; }
bool isPossible ( int box [ ] , int truck [ ] , int n , int m , int min_time ) { int temp = 0 ; int count = 0 ; while ( count < m ) { for ( int j = 0 ; j < min_time && temp < n && truck [ count ] >= box [ temp ] ; j += 2 ) temp ++ ; count ++ ; } if ( temp == n ) return true ; return false ; }
void solve ( int interval [ ] [ 2 ] , int N , int Q ) { int Mark [ Q ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int l = interval [ i ] [ 0 ] - 1 ; int r = interval [ i ] [ 1 ] - 1 ; for ( int j = l ; j <= r ; j ++ ) Mark [ j ] ++ ; } int count = 0 ; for ( int i = 0 ; i < Q ; i ++ ) { if ( Mark [ i ] != 0 ) count ++ ; } int count1 [ Q ] = { 0 } ; if ( Mark [ 0 ] == 1 ) count1 [ 0 ] = 1 ; for ( int i = 1 ; i < Q ; i ++ ) { if ( Mark [ i ] == 1 ) count1 [ i ] = count1 [ i - 1 ] + 1 ; else count1 [ i ] = count1 [ i - 1 ] ; } int maxindex = 0 ; int maxcoverage = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int l = interval [ i ] [ 0 ] - 1 ; int r = interval [ i ] [ 1 ] - 1 ; int elem1 ; if ( l != 0 ) elem1 = count1 [ r ] - count1 [ l - 1 ] ; else elem1 = count1 [ r ] ; if ( count - elem1 >= maxcoverage ) { maxcoverage = count - elem1 ; maxindex = i ; } } cout << "Maximum Coverage is " << maxcoverage << " after removing interval at index " << maxindex ; }
int maxSum ( int arr [ ] , int n , int K ) { int maximum = INT_MIN ; int sum [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i + K < n ) sum [ i ] = sum [ i + K ] + arr [ i ] ; else sum [ i ] = arr [ i ] ; maximum = max ( maximum , sum [ i ] ) ; } return maximum ; }
int countGreater ( int arr [ ] , int n , int k ) { int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; }
int countFactor ( int P , int X ) { if ( X < P ) return 0 ; return ( X / P + countFactor ( P , X / P ) ) ; }
int squareSum ( int N ) { int sum = ( int ) ( N * ( N + 1 ) * ( 2 * N + 1 ) ) / 6 ; return sum ; }
int countPattern ( int n , string pat ) { int pattern_int = 0 ; int power_two = 1 ; int all_ones = 0 ; for ( int i = pat . length ( ) - 1 ; i >= 0 ; i -- ) { int current_bit = pat [ i ] - '0' ; pattern_int += ( power_two * current_bit ) ; all_ones = all_ones + power_two ; power_two = power_two * 2 ; } int count = 0 ; while ( n != 0 && n >= pattern_int ) { if ( ( n & all_ones ) == pattern_int ) count ++ ; n = n >> 1 ; } return count ; }
int getMax ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = max ( res , arr [ i ] ) ; return res ; }
void printDuplicates ( int arr [ ] , int n ) { int i ; int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { cout << arr [ i ] % n << " " ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! ( fl ) ) cout << "-1" ; }
int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return -1 ; sort ( arr , arr + n ) ; int x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; int y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; int z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return max ( x , max ( y , z ) ) ; }
int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) { return -1 ; } int maxA = INT_MIN , maxB = INT_MIN , maxC = INT_MIN , maxD = INT_MIN ; int minA = INT_MAX , minB = INT_MAX , minC = INT_MAX , minD = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxD = maxC ; maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxD = maxC ; maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) { maxD = maxC ; maxC = arr [ i ] ; } else if ( arr [ i ] > maxD ) { maxD = arr [ i ] ; } if ( arr [ i ] < minA ) { minD = minC ; minC = minB ; minB = minA ; minA = arr [ i ] ; } else if ( arr [ i ] < minB ) { minD = minC ; minC = minB ; minB = arr [ i ] ; } else if ( arr [ i ] < minC ) { minD = minC ; minC = arr [ i ] ; } else if ( arr [ i ] < minD ) { minD = arr [ i ] ; } } int x = maxA * maxB * maxC * maxD ; int y = minA * minB * minC * minD ; int z = minA * minB * maxA * maxB ; return max ( x , max ( y , z ) ) ; }
void push ( struct Node * * head_ref , char new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; }
bool isPossible ( int arr [ ] , int n , int m , int curr_min ) { int studentsRequired = 1 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > curr_min ) return false ; if ( curr_sum + arr [ i ] > curr_min ) { studentsRequired ++ ; curr_sum = arr [ i ] ; if ( studentsRequired > m ) return false ; } else curr_sum += arr [ i ] ; } return true ; }
void sortArray ( int arr [ ] , int N ) { int i = 0 , j = N - 1 , mid = 0 ; while ( mid <= j ) { if ( arr [ mid ] == 0 ) { swap ( arr [ i ] , arr [ mid ] ) ; i ++ ; mid ++ ; } else if ( arr [ mid ] == 3 ) { swap ( arr [ mid ] , arr [ j ] ) ; j -- ; } else if ( arr [ mid ] == 1 arr [ mid ] == 2 ) { mid ++ ; } } while ( i <= j ) { if ( arr [ i ] == 2 ) { swap ( arr [ i ] , arr [ j ] ) ; j -- ; } else { i ++ ; } } for ( int k = 0 ; k < N ; k ++ ) { cout << arr [ k ] << " " ; } }
bool isSorted ( int arr [ ] [ MAX ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] [ 0 ] > arr [ i - 1 ] [ 0 ] ) { return false ; } } return true ; }
bool isSortedArray ( int arr [ ] , int n ) { int l = 0 , r = ( n - 1 ) ; while ( ( l + 1 ) < r ) { if ( arr [ l ] >= max ( arr [ l + 1 ] , arr [ r - 1 ] ) && arr [ r ] >= max ( arr [ r - 1 ] , arr [ l + 1 ] ) ) { l ++ ; r -- ; } else { return false ; } } return true ; }
void findMaxNumbers ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int opr = ceil ( log2 ( arr [ i ] ) ) ; k -= opr ; if ( k < 0 ) { break ; } cnt ++ ; } cout << cnt ; }
void rearrange ( int A [ ] , int B [ ] , int N , int X ) { bool flag = true ; sort ( A , A + N ) ; sort ( B , B + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ N - 1 - i ] > X ) { flag = false ; break ; } } if ( flag == true ) cout << "Yes" ; else cout << "No" ; }
int getMinCost ( int * arr , int n , int k ) { sort ( arr , arr + n , greater < int > ( ) ) ; int min_cost = 0 ; int X = 0 ; for ( int i = 0 ; i < n ; i += k ) { for ( int j = i ; j < i + k && j < n ; j ++ ) { min_cost += arr [ j ] * ( X + 1 ) ; } X ++ ; } return min_cost ; }
int mergeSortUtil ( int arr [ ] , int temp [ ] , int l , int r , int K ) { int cnt = 0 ; if ( l < r ) { int m = ( l + r ) / 2 ; cnt += mergeSortUtil ( arr , temp , l , m , K ) ; cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) ; cnt += merge ( arr , temp , l , m , r , K ) ; } return cnt ; }
void Bubble_Sort ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) swap ( arr [ j ] , arr [ j + 1 ] ) ; } } }
void mostvisitedsector ( int N , vector < int > A ) { int maxVisited = 0 ; unordered_map < int , int > mp ; for ( int i = 0 ; i < A . size ( ) - 1 ; i ++ ) { int start = A [ i ] % N ; int end = A [ i + 1 ] % N ; while ( start != end ) { if ( start == 0 ) { mp [ N ] ++ ; if ( mp [ N ] > maxVisited ) { maxVisited = mp [ N ] ; } } else { mp [ start ] ++ ; if ( mp [ start ] > maxVisited ) { maxVisited = mp [ start ] ; } } start = ( start + 1 ) % N ; } } int last = A [ A . size ( ) - 1 ] ; mp [ last ] ++ ; if ( mp [ last ] > maxVisited ) { maxVisited = mp [ last ] ; } for ( auto x : mp ) { if ( x . second == maxVisited ) { cout << x . first << " " ; } } }
int maxRectangle ( vector < vector < int > > sequence , int size ) { vector < int > X_Cord ( size ) ; vector < int > Y_Cord ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { X_Cord [ i ] = sequence [ i ] [ 0 ] ; Y_Cord [ i ] = sequence [ i ] [ 1 ] ; } sort ( X_Cord . begin ( ) , X_Cord . end ( ) ) ; sort ( Y_Cord . begin ( ) , Y_Cord . end ( ) ) ; int X_Max = 0 , Y_Max = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { X_Max = max ( X_Max , X_Cord [ i + 1 ] - X_Cord [ i ] ) ; Y_Max = max ( Y_Max , Y_Cord [ i + 1 ] - Y_Cord [ i ] ) ; } return X_Max * Y_Max ; }
int evenSumK ( int arr [ ] , int N , int K ) { if ( K > N ) { return -1 ; } int maxSum = 0 ; vector < int > Even ; vector < int > Odd ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { Odd . push_back ( arr [ i ] ) ; } else { Even . push_back ( arr [ i ] ) ; } } sort ( Odd . begin ( ) , Odd . end ( ) ) ; sort ( Even . begin ( ) , Even . end ( ) ) ; int i = Even . size ( ) - 1 ; int j = Odd . size ( ) - 1 ; while ( K > 0 ) { if ( K % 2 == 1 ) { if ( i >= 0 ) { maxSum += Even [ i ] ; i -- ; } else { return -1 ; } K -- ; } else if ( i >= 1 && j >= 1 ) { if ( Even [ i ] + Even [ i - 1 ] <= Odd [ j ] + Odd [ j - 1 ] ) { maxSum += Odd [ j ] + Odd [ j - 1 ] ; j -= 2 ; } else { maxSum += Even [ i ] + Even [ i - 1 ] ; i -= 2 ; K -= 2 ; } else if ( j >= 1 ) { maxSum += Odd [ j ] + Odd [ j - 1 ] ; j -= 2 ; K -= 2 ; } } return maxSum ; }
void find_mth_bitUtil ( int n , int m ) { int fib [ maxN ] ; calculateFib ( fib , maxN ) ; int ans = find_mth_bit ( n , m , fib ) ; cout << ans << " " ; }
int range_sum ( int arr [ ] , int a , int b ) { int sum = 0 ; if ( a - 2 < 0 ) sum = arr [ b - 1 ] ; else sum = arr [ b - 1 ] - arr [ a - 2 ] ; return sum ; }
int XorSum ( int A [ ] , int B [ ] , int N ) { int maxBit = 29 ; int ans = 0 ; for ( int k = 0 ; k < maxBit ; k ++ ) { int C [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { C [ i ] = B [ i ] % ( 1 << ( k + 1 ) ) ; } sort ( C , C + N ) ; long count = 0 ; long l , r ; for ( int i = 0 ; i < N ; i ++ ) { int x = A [ i ] % ( 1 << ( k + 1 ) ) ; l = lower_bound ( C , 0 , N , ( 1 << k ) - x ) ; r = lower_bound ( C , 0 , N , ( 1 << k ) * 2 - x ) ; count += ( r - l ) ; l = lower_bound ( C , 0 , N , ( 1 << k ) * 3 - x ) ; r = lower_bound ( C , 0 , N , ( 1 << k ) * 4 - x ) ; count += ( r - l ) ; } if ( count & 1 ) ans += ( 1 << k ) ; } return ans ; }
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; unordered_map < int , int > count ; for ( int i = 0 ; i < n ; i ++ ) { count [ arr [ i ] ] ++ ; } return ans ; }
long long getAlphaScore ( Node * root ) { if ( root != NULL ) getAlphaScore ( root -> left ) ; sum = ( sum + root -> key ) % mod ; total_sum = ( total_sum + sum ) % mod ; if ( root -> right != NULL ) getAlphaScore ( root -> right ) ; return total_sum ; }
void sortArr ( int a [ ] , int n ) { int i , k ; k = log2 ( n ) ; k = pow ( 2 , k ) ; while ( k > 0 ) { for ( i = 0 ; i + k < n ; i ++ ) if ( a [ i ] > a [ i + k ] ) swap ( a [ i ] , a [ i + k ] ) ; k = k / 2 ; } for ( i = 0 ; i < n ; i ++ ) { cout << a [ i ] << " " ; } }
void maximizeval10 ( int a [ ] , int n , int k ) { int increments = 0 ; int ans = 0 ; vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( a [ i ] / 10 ) ; if ( a [ i ] == 1000 ) continue ; else { v . push_back ( 10 - a [ i ] % 10 ) ; increments += ( 100 - ( ( a [ i ] ) / 10 ) - 1 ) ; } } sort ( v . begin ( ) , v . end ( ) ) ; int sum = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { sum += v [ i ] ; if ( sum <= k ) { ans ++ ; } else break ; } if ( sum < k ) { int remaining = k - sum ; ans += min ( increments , remaining / 10 ) ; } cout << ans ; }
int number ( int a [ ] , int n , int p , int k ) { sort ( a , a + n ) ; int pre [ n ] = { 0 } ; int val , i , j , ans = 0 ; pre [ 0 ] = a [ 0 ] ; if ( pre [ 0 ] <= p ) ans = 1 ; for ( i = 1 ; i < k - 1 ; i ++ ) { pre [ i ] = pre [ i - 1 ] + a [ i ] ; if ( pre [ i ] <= p ) ans = i + 1 ; } pre [ k - 1 ] = a [ k - 1 ] ; for ( i = k - 1 ; i < n ; i ++ ) { if ( i >= k ) { pre [ i ] += pre [ i - k ] + a [ i ] ; } if ( pre [ i ] <= p ) ans = i + 1 ; } return ans ; }
bool checkIsAP ( double arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; double d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
int findK ( int arr [ ] , int size , int N ) { sort ( arr , arr + size ) ; int temp_sum = 0 ; for ( int i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return -1 ; }
int findSum ( int * arr , int n , int k , int l , int r ) { if ( ( l ) + ( n - 1 - r ) == k ) return arr [ r ] - arr [ l ] ; if ( vis [ l ] [ r ] ) return dp [ l ] [ r ] ; vis [ l ] [ r ] = 1 ; dp [ l ] [ r ] = min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; return dp [ l ] [ r ] ; }
void printList ( Node * node ) { Node * last ; while ( node != NULL ) { cout << node -> data << " " ; last = node ; node = node -> next ; } }
int Removal ( vector < int > v , int n ) { sort ( ( v ) . begin ( ) , ( v ) . end ( ) ) ; int ans = INT_MAX ; int k = 0 ; for ( auto i : v ) { int j = upper_bound ( ( v ) . begin ( ) , ( v ) . end ( ) , ( 2 * i ) ) - ( v ) ; ans = min ( ans , n - ( j - k ) ) ; k ++ ; } return ans ; }
void printArrangement ( int a [ ] , int n ) { sort ( a , a + n ) ; int b [ n ] ; int low = 0 , high = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) b [ low ++ ] = a [ i ] ; else b [ high -- ] = a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { if ( b [ n - 1 ] + b [ 1 ] <= b [ i ] ) { cout << -1 ; return ; } } else if ( i == ( n - 1 ) ) { if ( b [ n - 2 ] + b [ 0 ] <= b [ i ] ) { cout << -1 ; return ; } } else { if ( b [ i - 1 ] + b [ i + 1 ] <= b [ i ] ) { cout << -1 ; return ; } } } for ( int i = 0 ; i < n ; i ++ ) cout << b [ i ] << " " ; }
void K_multiple ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] % k == 0 && s . find ( a [ i ] / k ) == s . end ( ) ) a [ i ] % k != 0 ) s . insert ( a [ i ] ) ; } for ( auto i : s ) cout << i << " " ; }
long long powmod ( long long a , long long n ) { if ( ! n ) return 1 ; long long pt = powmod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 == 1 ) return ( pt * a ) % mod ; else return pt ; }
long long product ( long long a [ ] , int n , int k ) { long long ans = 1 ; sort ( a , a + n ) ; long long powa = C [ n - 1 ] [ k - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { long long powla = C [ i ] [ k - 1 ] ; long long powfa = C [ n - i - 1 ] [ k - 1 ] ; long long powe = ( ( powa % MOD ) - ( powla + powfa ) % MOD + MOD ) % MOD ; long long mul = power ( a [ i ] , powe ) % MOD ; ans = ( ( ans % MOD ) * ( mul % MOD ) ) % MOD ; } return ans % MOD ; }
bool check ( string s ) { int l = s . length ( ) ; sort ( s . begin ( ) , s . end ( ) ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( s [ i ] - s [ i - 1 ] != 1 ) return false ; } return true ; }
void printNumbers ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int A = arr [ n - 1 ] , B = -1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( A % arr [ i ] != 0 ) { B = arr [ i ] ; break ; } if ( i - 1 >= 0 && arr [ i ] == arr [ i - 1 ] ) { B = arr [ i ] ; break ; } } cout << "A = " << A << ", B = " << B ; }
void findNonPalinString ( char s [ ] ) { int freq [ 26 ] = { 0 } ; int flag = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != s [ 0 ] ) flag = 1 ; freq [ s [ i ] - 'a' ] ++ ; } if ( flag == 0 ) cout << "-1" ; else { for ( int i = 0 ; i < 26 ; i ++ ) for ( int j = 0 ; j < freq [ i ] ; j ++ ) cout << ( char ) ( 'a' + i ) ; } }
int countDistinct ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } res ++ ; } return res ; }
int minSubarray ( int A [ ] , int n ) { int minValue = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] < minValue ) minValue = A [ i ] ; } int maxValue = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] > maxValue ) maxValue = A [ i ] ; } int pos_min = -1 , pos_max = -1 , ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] == minValue ) pos_min = i ; if ( A [ i ] == maxValue ) pos_max = i ; if ( pos_max != -1 && pos_min != -1 ) ans = min ( ans , abs ( pos_min - pos_max ) + 1 ) ; } return ans ; }
int countTriplets ( Node * head , int x ) { Node * ptr , * ptr1 , * ptr2 ; int count = 0 ; unordered_map < int , Node * > um ; for ( ptr = head ; ptr != NULL ; ptr = ptr -> next ) um [ ptr -> data ] = ptr ; for ( ptr1 = head ; ptr1 != NULL ; ptr1 = ptr1 -> next ) { for ( ptr2 = ptr1 -> next ; ptr2 != NULL ; ptr2 = ptr2 -> next ) { int p_product = ( ptr1 -> data * ptr2 -> data ) ; if ( um . find ( x / p_product ) != um . end ( ) && um [ x / p_product ] != ptr1 && um [ x / p_product ] != ptr2 ) count ++ ; } } return ( count / 3 ) ; }
int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; sort ( arr , arr + n ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { ll prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
int countTripletsLessThan ( int * arr , int n , int val ) { sort ( arr , arr + n ) ; int ans = 0 ; int j , k ; int sum ; for ( int i = 0 ; i < n - 2 ; i ++ ) { j = i + 1 ; k = n - 1 ; while ( j != k ) { sum = arr [ i ] + arr [ j ] + arr [ k ] ; if ( sum > val ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; }
int MaxSumDifference ( int a [ ] , int n ) { vector < int > finalSequence ; sort ( a , a + n ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { finalSequence . push_back ( a [ i ] ) ; finalSequence . push_back ( a [ n - i - 1 ] ) ; } if ( n % 2 != 0 ) finalSequence . push_back ( a [ n / 2 ] ) ; int MaximumSum = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { MaximumSum = MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ; } MaximumSum = MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ; return MaximumSum ; }
int findMinimum ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += arr [ i ] ; n = n - k ; } return res ; }
int minSwapToReachArr ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] - 1 ) - i > 2 ) { return -1 ; } } int numOfInversion = mergeSort ( arr , N ) ; return numOfInversion ; }
int getIndexInSortedArray ( int arr [ ] , int n , int idx ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void gnomeSort ( int arr [ ] , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { swap ( arr [ index ] , arr [ index - 1 ] ) ; index -- ; } } return ; }
void flip ( int arr [ ] , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } }
bool possible ( int x , int S , int N ) { int minSum = ( x * ( x + 1 ) ) / 2 ; int maxSum = ( x * ( ( 2 * N ) - x + 1 ) ) / 2 ; if ( S < minSum S > maxSum ) { return false ; } return true ; }
int TotalPerfectPowerSum ( int L , int R ) { vector < int > pows ; pows . push_back ( 0 ) ; pows . push_back ( 1 ) ; for ( int p = 2 ; p < 25 ; p ++ ) { int num = 2 ; while ( pow ( num , p ) + 0.5 ) <= R ) { pows . push_back ( pow ( num , p ) + 0.5 ) ; num ++ ; } } int ok [ R + 2 ] ; for ( int i = 0 ; i < pows . size ( ) ; i ++ ) { for ( int j = 0 ; j < pows . size ( ) ; j ++ ) { if ( pows [ i ] + pows [ j ] <= R && pows [ i ] + pows [ j ] >= L ) { ok [ pows [ i ] + pows [ j ] ] = 1 ; } } } for ( int i = 1 ; i <= R ; i ++ ) { ok [ i ] += ok [ i - 1 ] ; } return ok [ R ] - ok [ L - 1 ] ; }
long long KthSolution ( long long X , long long K ) { long long ans = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ! ( X & ( 1LL << i ) ) ) { if ( K & 1 ) { ans |= ( 1LL << i ) ; } K >>= 1 ; if ( ! K ) { break ; } } } return ans ; }
int countNoOfsuchX ( int N ) { int k = log10 ( N ) + 1 ; int count = 1 ; for ( int x = ( N - ( k * ( k + 1 ) * 5 ) ) ; x <= N ; x ++ ) { if ( check ( x , N ) ) { count += 1 ; } } return count ; }
int countArrays ( int n , int k ) { vector < int > divisors [ k + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 2 * i ; j <= k ; j += i ) { divisors [ j ] . push_back ( i ) ; } } int dp [ n + 1 ] [ k + 1 ] ; for ( int j = 1 ; j <= k ; j ++ ) { dp [ 1 ] [ j ] = 1 ; } for ( int x = 2 ; x <= n ; x ++ ) { int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum += dp [ x - 1 ] [ j ] ; } for ( int y = 1 ; y <= k ; y ++ ) { dp [ x ] [ y ] = sum ; for ( auto d : divisors [ y ] ) { dp [ x ] [ y ] = ( dp [ x ] [ y ] - dp [ x - 1 ] [ d ] ) ; } } } int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum += dp [ n ] [ j ] ; } return sum ; }
bool checkStar ( int mat [ ] [ size ] ) { int vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] == 1 ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void convertXintoY ( int X , int Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y /= 2 ; else if ( Y % 10 == 1 ) Y /= 10 ; else break ; } if ( X == Y ) cout << "Yes" ; else cout << "No" ; }
int MaxXOR ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; }
int countCandies ( int arr [ ] , int n ) { int sum = 0 ; int ans [ n ] ; if ( n == 1 ) { return 1 ; } for ( int i = 0 ; i < n ; i ++ ) ans [ i ] = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i + 1 ] > arr [ i ] && ans [ i + 1 ] <= ans [ i ] ) { ans [ i + 1 ] = ans [ i ] + 1 ; } } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > arr [ i + 1 ] && ans [ i ] <= ans [ i + 1 ] ) { ans [ i ] = ans [ i + 1 ] + 1 ; } else if ( arr [ i ] == arr [ i + 1 ] && ans [ i ] < ans [ i + 1 ] ) { ans [ i ] = ans [ i + 1 ] + 1 ; } sum += ans [ i ] ; } sum += ans [ n - 1 ] ; return sum ; }
int findMinOperations ( int arr [ ] , int N , int K ) { int operations = 0 ; for ( int i = 0 ; i < K ; i ++ ) { unordered_map < int , int > freq ; for ( int j = i ; j < N ; j += K ) freq [ arr [ j ] ] ++ ; int max1 = 0 , num ; for ( auto x : freq ) { if ( x . second > max1 ) { max1 = x . second ; num = x . first ; } } for ( auto x : freq ) { if ( x . first != num ) operations += x . second ; } } cout << operations ; }
void minSizeArr ( int A [ ] , int N , int K ) { int leftTaken = N , rightTaken = N ; int leftSum = 0 , rightSum = 0 ; for ( int left = -1 ; left < N ; left ++ ) { if ( left != -1 ) leftSum += A [ left ] ; rightSum = 0 ; for ( int right = N - 1 ; right > left ; right -- ) { rightSum += A [ right ] ; if ( leftSum + rightSum == K ) { if ( leftTaken + rightTaken > ( left + 1 ) + ( N - right ) ) { leftTaken = left + 1 ; rightTaken = N - right ; } break ; } if ( leftSum + rightSum > K ) break ; } } if ( leftTaken + rightTaken <= N ) { for ( int i = 0 ; i < leftTaken ; i ++ ) cout << A [ i ] << " " ; for ( int i = 0 ; i < rightTaken ; i ++ ) cout << A [ N - i - 1 ] << " " ; } else cout << -1 ; }
bool is_prime ( long n ) { if ( n == 1 ) return 0 ; for ( long i = 2 ; i <= ( long ) sqrt ( n ) ; i ++ ) if ( n % i == 0 ) return 0 ; return 1 ; }
void consecutive_primes ( long n ) { long first = -1 , second = -1 ; for ( long i = sqrt ( n ) ; i >= 2 ; i -- ) { if ( is_prime ( i ) ) { first = i ; break ; } } for ( long i = sqrt ( n ) + 1 ; i <= n / 2 ; i ++ ) { if ( is_prime ( i ) ) { second = i ; break ; } } if ( first * second >= n ) { cout << first << " " << second << endl ; } else { for ( long i = second + 1 ; i <= n ; i ++ ) { if ( is_prime ( i ) ) { cout << second << " " << i ; return ; } } } }
void arrayBitwiseAND ( int size ) { int result = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int temp = prefixCount [ i ] [ size - 1 ] ; if ( temp == size ) result = ( result | ( 1 << i ) ) ; } cout << result << " " ; }
void findbitwiseAND ( int queries [ ] [ 2 ] , int arr [ ] , int N , int M ) { prefixCount . resize ( 10000 ) ; findPrefixCount ( arr , N ) ; for ( int i = 0 ; i < M ; i ++ ) { int id = queries [ i ] [ 0 ] ; int newVal = queries [ i ] [ 1 ] ; int currentVal = arr [ id ] ; arr [ id ] = newVal ; applyQuery ( currentVal , newVal , N ) ; arrayBitwiseAND ( N ) ; } }
void stepscount ( int a , int b ) { int chanceA = 2 * a - 1 ; int chanceB = 2 * b ; if ( chanceA < chanceB ) { cout << "B" ; } else if ( chanceB < chanceA ) { cout << "A" ; } }
void checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = pow ( ( x - h ) , 2 ) / pow ( a , 2 ) - pow ( ( y - k ) , 2 ) / pow ( b , 2 ) ; if ( p > 1 ) { cout << "Outside" << endl ; } else if ( p == 1 ) { cout << "On the Hyperbola" << endl ; } else { cout << "Inside" << endl ; } }
void rotateString ( int n , int m , string s ) { vector < int > v ( n ) ; int cnt = 0 ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) { v [ j ] = i ; j += 1 ; } } for ( int i = 1 ; i < j ; i ++ ) { if ( ( v [ i ] - v [ i - 1 ] - 1 ) > m ) { cnt ++ ; } } if ( j >= 2 && ( n - ( v [ j - 1 ] - v [ 0 ] ) - 1 ) > m ) { cnt ++ ; } if ( cnt <= 1 ) { cout << "Yes" ; } else { cout << "No" ; } }
int findNumber ( int N ) { int ans [ ] = { 1 , 2 , 4 , 8 , 7 , 5 } ; return ans [ N % 6 ] ; }
void countDecrements ( vector < vector < int > > & arr ) { int n = arr . size ( ) ; int m = arr [ 0 ] . size ( ) ; int count_1 = 0 ; int count_2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_1 ++ ; if ( 1 - ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_2 ++ ; } } cout << min ( count_1 , count_2 ) ; }
void maximumIndex ( int N , int B ) { int i = 0 , j = 1 ; int cnt = 0 ; int sum = N * ( N + 1 ) / 2 ; bool flag = false ; while ( cnt < N ) { i += j ; j ++ ; cnt ++ ; if ( i == B ) { flag = true ; break ; } } if ( ! flag ) { cout << sum ; } else { cout << sum - 1 ; } }
int sumOfDigits ( int N ) { int sum = 0 ; while ( N ) { sum += N % 10 ; N /= 10 ; } return sum ; }
int distIntegers ( int L , int R ) { return 2 * R - 2 * L + 1 ; }
long long maximumNum ( long long X , long long Y , long long N ) { long long num = 0 ; if ( N - N % X + Y <= N ) { num = N - N % X + Y ; } else { num = N - N % X - ( X - Y ) ; } return num ; }
void findKthElement ( int N , int K ) { vector < int > v ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { v . push_back ( i ) ; } } for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 != 0 ) { v . push_back ( i ) ; } } cout << v [ K - 1 ] ; }
void printLargestDivisible ( int arr [ ] , int N ) { int i , count0 = 0 , count7 = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) count0 ++ ; else count7 ++ ; } if ( count7 % 50 == 0 ) { while ( count7 != 0 ) { cout << 7 ; count7 -= 1 ; } while ( count0 != 0 ) { cout << 0 ; count0 -= 1 ; } } else if ( count7 < 5 ) { if ( count0 == 0 ) cout << "No" ; else cout << "0" ; } else { count7 = count7 - count7 % 5 ; while ( count7 != 0 ) { cout << 7 ; count7 -= 1 ; } while ( count0 != 0 ) { cout << 0 ; count0 -= 1 ; } } }
int minimumStepReqArr ( int arr [ ] , int N ) { int cntStep = 0 ; N += 1 ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( N & ( 1 << i ) ) { cntStep += 1 ; } } return cntStep ; }
void minOpsToEmptyString ( string S , int N ) { int one = 0 , zero = 0 ; int x0 = 0 , x1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '0' ) { x0 ++ ; x1 = 0 ; } else { x1 ++ ; x0 = 0 ; } zero = max ( x0 , zero ) ; one = max ( x1 , one ) ; } cout << max ( one , zero ) << endl ; }
int findMaxValByRearrArr ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int res = 0 ; do { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += __gcd ( i + 1 , arr [ i ] ) ; } res = max ( res , sum ) ; } while ( next_permutation ( arr ) ) ; return res ; }
int cntKnightsAttackPawn ( int knights [ ] [ 2 ] , int pawn [ ] , int M ) { int cntKnights = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int X = abs ( knights [ i ] [ 0 ] - pawn [ 0 ] ) ; int Y = abs ( knights [ i ] [ 1 ] - pawn [ 1 ] ) ; if ( ( X == 1 && Y == 2 ) || ( X == 2 && Y == 1 ) ) { cntKnights ++ ; } } return cntKnights ; }
int findXOR ( unsigned int n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } }
void findMinimumTime ( vector < int > p , int n , int target ) { unordered_map < int , int > um ; for ( int i = 0 ; i < n ; i ++ ) um [ p [ i ] ] ++ ; int time = 0 ; int sum = 0 ; while ( sum < target ) { sum = 0 ; time ++ ; for ( auto it = um . begin ( ) ; it != um . end ( ) ; it ++ ) { sum += it -> second * ( time / it -> first ) ; } } cout << time ; }
void isSequenceValid ( int B [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( ( i + 1 ) % B [ i ] != 0 ) { cout << "No" ; return ; } } cout << "Yes" ; }
void Remove_one_element ( int arr [ ] , int n ) { int post_odd = 0 , post_even = 0 ; int curr_odd = 0 , curr_even = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i & 1 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i & 1 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; int X = curr_odd ^ post_even ; int Y = curr_even ^ post_odd ; if ( X == Y ) res ++ ; if ( i & 1 ) curr_odd ^= arr [ i ] ; else curr_even ^= arr [ i ] ; } cout << res ; }
int findLongestNonDecreasing ( int A [ ] , int N ) { int res = 0 ; int start = 0 ; int end = N - 1 ; int prev = -1 ; while ( start <= end ) { if ( A [ start ] <= A [ end ] ) { if ( prev == -1 ) { prev = A [ start ] ; res ++ ; start ++ ; } else { if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else { break ; } } } else { if ( prev == -1 ) { prev = A [ end ] ; res ++ ; end -- ; } else { if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else { break ; } } } } return res ; }
int countPairs ( int arr [ ] , int N ) { int cntPairs = 0 ; unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } for ( auto freq : mp ) { cntPairs += ( freq . second * ( freq . second - 1 ) ) / 2 ; } return cntPairs ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int minAbsDiff ( int N ) { int sumSet1 = 0 ; int sumSet2 = 0 ; for ( int i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return abs ( sumSet1 - sumSet2 ) ; }
int countPairs ( int arr [ ] , int n ) { int oneCount = 0 ; int desiredPair = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) { oneCount ++ ; } if ( arr [ i ] == 0 ) { desiredPair += oneCount ; } } return desiredPair ; }
int TotalNumber ( int N ) { int ans = ( power ( 10 , N ) - 2 * power ( 9 , N ) + power ( 8 , N ) + 2 * mod ) % mod ; return ans ; }
int minLength ( int A [ ] , int N ) { int elem = A [ 0 ] , count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( A [ i ] == elem ) { count ++ ; } else { break ; } } if ( count == N ) return N ; else return 1 ; }
bool NegEqu ( int N , int X , int Y ) { while ( X > 0 && ( N > N / 2 + 10 ) ) { N = N / 2 + 10 ; X -= 1 ; } while ( Y > 0 ) { N = N - 10 ; Y -= 1 ; } if ( N <= 0 ) return true ; return false ; }
int minSubarrays ( int arr [ ] , int n ) { int right = n - 1 ; int left = 0 ; int subarrays = 0 ; while ( right >= 0 ) { for ( left = 0 ; left <= right ; left += 1 ) { if ( __gcd ( arr [ left ] , arr [ right ] ) > 1 ) { subarrays += 1 ; right = left - 1 ; break ; } if ( left == right && __gcd ( arr [ left ] , arr [ right ] ) == 1 ) { return 0 ; } } } return subarrays ; }
bool check ( int arr [ ] , int N ) { int f = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { count ++ ; } } if ( count >= 2 ) { f = 1 ; break ; } } if ( f == 1 ) return true ; else return false ; }
int no_of_flips ( int n ) { int len = check_length ( n ) ; int ans = 0 ; int right = 1 ; int left = len ; while ( right < left ) { if ( check_ith_bit ( n , right ) != check_ith_bit ( n , left ) ) ans ++ ; left -- ; right ++ ; } return ans ; }
int find_max ( vector < pair < int , int > > & v , int n ) { int count = 0 ; if ( n >= 2 ) count = 2 ; else count = 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( v [ i - 1 ] . first < ( v [ i ] . first - v [ i ] . second ) ) count ++ ; else if ( v [ i + 1 ] . first > ( v [ i ] . first + v [ i ] . second ) ) { count ++ ; v [ i ] . first = v [ i ] . first + v [ i ] . second ; } else continue ; } return count ; }
void createString ( int N ) { for ( int i = 0 ; i < N ; i ++ ) { cout << 'a' ; } for ( int i = 0 ; i < N ; i ++ ) { cout << 'b' ; } }
int maxSubsequences ( int arr [ ] , int n ) { unordered_map < int , int > mp ; int maxCount = 0 ; int count ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . find ( arr [ i ] ) != mp . end ( ) ) { count = mp [ arr [ i ] ] ; if ( count > 1 ) { mp [ arr [ i ] ] = count - 1 ; } else mp . erase ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) mp [ arr [ i ] - 1 ] ++ ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) mp [ arr [ i ] - 1 ] ++ ; } } return maxCount ; }
int sumOfFactors ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int first = i ; int last = ( N / i ) * i ; int factors = ( last - first ) / i + 1 ; int totalContribution = ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += totalContribution ; } return ans ; }
void findShifts ( vector < int > A , int N ) { vector < int > shift ( N , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( int i = 0 ; i < N ; i ++ ) cout << shift [ i ] << " " ; }
bool possible ( int N , int a , int b , int n ) { int sum_of_angle = 180 * ( N - 2 ) ; int Total_angle = ( N * ( ( 2 * a ) + ( N - 1 ) * b ) ) / 2 ; if ( sum_of_angle != Total_angle ) return false ; else return true ; }
bool splitIntoFibonacciHelper ( int pos , string & S , vector < ll > & seq ) { if ( pos == S . length ( ) && ( seq . size ( ) >= 3 ) ) { return true ; } ll num = 0 ; for ( int i = pos ; i < S . length ( ) ; i ++ ) { num = num * 10 + ( S [ i ] - '0' ) ; if ( num > INT_MAX ) break ; if ( S [ pos ] == '0' && i > pos ) break ; if ( seq . size ( ) > 2 && ( num > ( ( long ) seq [ seq . size ( ) - 1 ] + ( long ) seq [ seq . size ( ) - 2 ] ) ) ) break ; if ( seq . size ( ) < 2 || ( num == ( ( long ) seq [ seq . size ( ) - 1 ] + ( long ) seq [ seq . size ( ) - 2 ] ) ) ) { seq . push_back ( num ) ; if ( splitIntoFibonacciHelper ( i + 1 , S , seq ) ) return true ; seq . pop_back ( ) ; } } return false ; }
int good_pairs ( string str [ ] , int N ) { int arr [ 32 ] = { 0 } ; int strCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int Weight = 0 ; for ( int j = 0 ; j < str [ i ] . length ( ) ; j ++ ) { switch ( str [ i ] [ j ] ) { case 'a' : Weight = Weight | 1 ; break ; case 'e' : Weight = Weight | 2 ; break ; case 'i' : Weight = Weight | 4 ; break ; case 'o' : Weight = Weight | 8 ; break ; case 'u' : Weight = Weight | 16 ; break ; } } arr [ Weight ] ++ ; } for ( int i = 0 ; i < 32 ; i ++ ) { for ( int j = i + 1 ; j < 32 ; j ++ ) { if ( ( i j ) == 31 ) strCount += arr [ i ] * arr [ j ] ; } } strCount += ( arr [ 31 ] * ( arr [ 31 ] - 1 ) ) / 2 ; return strCount ; }
void countUniqueDigits ( int N ) { int res = 0 ; int cnt [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; while ( N > 0 ) { int rem = N % 10 ; cnt [ rem ] ++ ; N = N / 10 ; } for ( int i = 0 ; i < cnt . size ( ) ; i ++ ) { if ( cnt [ i ] == 1 ) { res ++ ; } } cout << res ; }
void DFS ( int node , int parent ) { answer [ node ] = val [ node ] ; for ( int child : v [ node ] ) { if ( child == parent ) continue ; DFS ( child , node ) ; answer [ node ] = gcd ( answer [ node ] , answer [ child ] ) ; } }
int count_triangles ( int a , int b , int c , int d ) { int ans = 0 ; for ( int x = a ; x <= b ; ++ x ) { int num_greater_than_d = max ( d , c + x ) - max ( d , b + x - 1 ) ; ans += num_greater_than_d * ( d - c + 1 ) ; int r = min ( max ( c , c + x ) , d ) - c ; int l = min ( max ( c , b + x - 1 ) , d ) - c ; int x1 = ( r * ( r + 1 ) ) / 2 ; int x2 = ( l * ( l + 1 ) ) / 2 ; ans += x1 - x2 ; } return ans ; }
int maxRemainingSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int i = 0 ; int j = n - 1 ; int result = 0 ; while ( i < j ) { if ( arr [ i ] < arr [ j ] ) sum -= arr [ i ] ; i ++ ; else sum -= arr [ j ] ; j -- ; result += sum ; } return result ; }
bool check ( int arr [ ] , int n ) { bool flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < n - i ) { flag = false ; } } if ( flag ) { return true ; } else { return false ; } }
int minOperations ( int a [ ] , int b [ ] , int n ) { int minA = * min_element ( a , a + n ) ; for ( int x = minA ; x >= 0 ; x -- ) { bool check = true ; int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = false ; break ; } } if ( check ) return operations ; } return -1 ; }
int largestNum ( int n ) { for ( int i = 0 ; i <= 32 ; i ++ ) { int x = ( 1 << i ) ; if ( ( x - 1 ) <= n ) num = ( 1 << i ) - 1 ; else break ; } return num ; }
int digit_xor ( int x ) { int xorr = 0 ; while ( x > 0 ) { xorr ^= x % 10 ; x = x / 10 ; } return xorr ; }
int maxSum ( int a [ ] , int n ) { int S = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) S += a [ i ] ; int X = maxSubArraySum ( a , n ) ; return 2 * X - S ; }
void Transform ( int n , int d , int steps ) { if ( n < min_val ) { min_val = n ; min_steps = steps ; } else if ( n == min_val ) { min_steps = min ( min_steps , steps ) ; } if ( steps < 15 ) { Transform ( sumOfDigits ( n ) , d , steps + 1 ) ; Transform ( n + d , d , steps + 1 ) ; } }
void addEdge ( vector < int > adj [ ] , int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; }
int minCost ( int * cost , int n ) { int totalCost = 0 ; int boardingBus = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; }
int findK ( int n , int k ) { int pos ; if ( n % 2 == 0 ) { pos = n / 2 ; } else { pos = ( n / 2 ) + 1 ; } if ( k <= pos ) { return ( k * 2 - 1 ) ; } else return ( ( k - pos ) * 2 ) ; }
int max_bitwise_or ( int L , int R ) { vector < int > v1 , v2 , v3 ; int z = 0 , i , ans = 0 , cnt = 1 ; while ( L > 0 ) { v1 . push_back ( L % 2 ) ; L = L / 2 ; } while ( R > 0 ) { v2 . push_back ( R % 2 ) ; R = R / 2 ; } while ( v1 . size ( ) != v2 . size ( ) ) { v1 . push_back ( 0 ) ; } for ( i = v2 . size ( ) - 1 ; i >= 0 ; i -- ) { if ( v2 [ i ] == 1 && v1 [ i ] == 0 && z == 0 ) { z = 1 ; continue ; } if ( z == 1 ) { v1 . erase ( i ) ; v1 . push_back ( 1 ) ; } } for ( i = 0 ; i < v2 . size ( ) ; i ++ ) { v3 . push_back ( v2 [ i ] | v1 [ i ] ) ; } for ( i = 0 ; i < v2 . size ( ) ; i ++ ) { if ( v3 [ i ] == 1 ) { ans += cnt ; } cnt *= 2 ; } return ans ; }
int ncr ( int n , int r , int mod ) { long long res = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { res = ( res * ( n - i + 1 ) ) % mod ; int inv = power ( i , mod - 2 , mod ) ; res = ( res * inv ) % mod ; } return ( int ) ( res % mod ) ; }
int solve ( int array [ ] , int N ) { int pos [ 5 ] [ 10000 ] ; int pref [ 5 ] ; if ( array [ 0 ] == 0 ) { pref [ 0 ] = 1 ; pos [ 0 ] [ pos [ 0 ] . size ( ) - 1 ] = 0 ; } int ans = MAX_INT ; for ( int i = 1 ; i < N ; i ++ ) { if ( array [ i ] == 0 ) { pref [ 0 ] ++ ; pos [ 0 ] [ pos [ 0 ] . size ( ) - 1 ] = i ; } else { if ( pref [ array [ i ] - 1 ] > 0 ) { pref [ array [ i ] ] ++ ; pos [ array [ i ] ] [ pos [ array [ i ] ] . size ( ) - 1 ] = i ; if ( array [ i ] == 4 ) { int end = i ; int start = i ; for ( int j = 3 ; j >= 0 ; j -- ) { int s = 0 ; int e = pos [ j ] . size ( ) - 1 ; int temp = -1 ; while ( s <= e ) { int m = ( s + e ) / 2 ; if ( pos [ j ] [ m ] <= start ) { temp = pos [ j ] [ m ] ; s = m + 1 ; } else e = m - 1 ; } start = temp ; } ans = min ( ans , end - start + 1 ) ; } } } } return ans ; }
vector < int > solve ( int X , vector < int > A ) { int min = INT_MAX ; int ind = -1 ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) { if ( A [ i ] < min ) { min = A [ i ] ; ind = i ; } } int maxIndChosen = X / min ; vector < int > ans ; if ( maxIndChosen == 0 ) { return ans ; } for ( int i = 0 ; i < maxIndChosen ; i ++ ) { ans . push_back ( ind ) ; } int temp = maxIndChosen ; int sum = maxIndChosen * A [ ind ] ; for ( int i = 0 ; i < ind ; i ++ ) { if ( sum - X == 0 temp == 0 ) break ; while ( ( sum - A [ ind ] + A [ i ] ) <= X && temp != 0 ) { ans . erase ( ans . begin ( ) ) ; ans . push_back ( i ) ; temp -- ; sum += ( A [ i ] - A [ ind ] ) ; } } sort ( ans . begin ( ) , ans . end ( ) ) ; return ans ; }
bool CheckForSequence ( int arr [ ] , int n , int k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( k >= arr [ i ] ) k -= arr [ i ] ; } if ( k != 0 ) return false ; else return true ; }
int reverse ( int n ) { int rev = 0 ; while ( n ) { rev = ( rev * 10 ) + ( n % 10 ) ; n /= 10 ; } return rev ; }
int countJumps ( int n ) { n = abs ( n ) ; int ans = 0 ; while ( getsum ( ans ) < n || ( ( getsum ( ans ) - n ) & 1 ) ) ans ++ ; return ans ; }
int steps ( int cur , int x , int n ) { if ( x == 0 ) return INT_MAX ; if ( x > 0 ) return abs ( ( n - cur ) / x ) ; else return abs ( ( cur - 1 ) / x ) ; }
void find_rectangle ( int area ) { int l = 0 , b = 0 ; int M = sqrt ( area ) , ans ; for ( int i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = ( area / i ) ; b = i ; break ; } } cout << "l = " << l << ", b = " << b ; }
int countMinSwaps ( string st ) { int min_swaps = 0 ; int odd_0 = 0 , even_0 = 0 ; int odd_1 = 0 , even_1 = 0 ; int n = st . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( st [ i ] == '1' ) even_1 ++ ; else even_0 ++ ; } else { if ( st [ i ] == '1' ) odd_1 ++ ; else odd_0 ++ ; } } int cnt_swaps_1 = min ( even_0 , odd_1 ) ; int cnt_swaps_2 = min ( even_1 , odd_0 ) ; return min ( cnt_swaps_1 , cnt_swaps_2 ) ; }
int problemsLeft ( int K , int P , int N ) { if ( K <= P ) return 0 ; else return ( ( K - P ) * N ) ; }
bool isCorrectOrder ( int n ) { bool flag = true ; int prev = -1 ; int type = -1 ; while ( n != 0 ) { if ( type == -1 ) { if ( prev == -1 ) { prev = n % 10 ; n = n / 10 ; continue ; } if ( prev == n % 10 ) { flag = false ; break ; } if ( prev > n % 10 ) { type = 1 ; prev = n % 10 ; n = n / 10 ; continue ; } prev = n % 10 ; n = n / 10 ; } else { if ( prev == n % 10 ) { flag = false ; break ; } if ( prev < n % 10 ) { flag = false ; break ; } prev = n % 10 ; n = n / 10 ; } } return flag ; }
int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { swap ( arr [ i ] , arr [ j ] ) ; } } } M = max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
int MinimumRemovals ( int a [ ] , int N , int K ) { int b [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { b [ i + 1 ] = a [ i ] ; } int dp [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] ) ; dp [ i + 1 ] [ j + 1 ] = max ( dp [ i + 1 ] [ j + 1 ] , dp [ i ] [ j ] + ( ( b [ i + 1 ] == j + 1 ) ? 1 : 0 ) ) ; } } for ( int j = N ; j >= 0 ; j -- ) { if ( dp [ N ] [ j ] >= K ) { return ( N - j ) ; } } return -1 ; }
int countOfNumbers ( int digit , int mask , int repeated , int n ) { if ( digit == n + 1 ) { if ( repeated ) { return 1 ; } return 0 ; } if ( repeated ) { return pow ( 10 , n - digit + 1 ) ; } int & val = dp [ digit ] [ mask ] [ repeated ] ; if ( val != -1 ) { return val ; } val = 0 ; if ( digit == 1 ) { for ( int i = ( n == 1 ? 0 : 1 ) ; i <= 9 ; ++ i ) { if ( mask & ( 1 << i ) ) { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 1 , n ) ; } else { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 0 , n ) ; } } } else { for ( int i = 0 ; i <= 9 ; ++ i ) { if ( mask & ( 1 << i ) ) { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 1 , n ) ; } else { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 0 , n ) ; } } } return val ; }
int power ( int x , unsigned int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
void maxBoundary ( int N , vector < pair < int , int > > V ) { int dp [ N ] [ 2 ] ; dp [ 0 ] [ 0 ] = V [ 0 ] . first ; dp [ 0 ] [ 1 ] = V [ 0 ] . second ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = V [ i ] . first ; int height1 = abs ( V [ i - 1 ] . second - V [ i ] . second ) ; int height2 = abs ( V [ i - 1 ] . first - V [ i ] . second ) ; dp [ i ] [ 0 ] += max ( height1 + dp [ i - 1 ] [ 0 ] , height2 + dp [ i - 1 ] [ 1 ] ) ; dp [ i ] [ 1 ] = V [ i ] . second ; int vertical1 = abs ( V [ i ] . first - V [ i - 1 ] . second ) ; int vertical2 = abs ( V [ i ] . first - V [ i - 1 ] . first ) ; dp [ i ] [ 1 ] += max ( vertical1 + dp [ i - 1 ] [ 0 ] , vertical2 + dp [ i - 1 ] [ 1 ] ) ; } cout << max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
int findMinOperations ( int n ) { int i = 0 ; int * dp = new int [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = 999999 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i < n + 1 ; i ++ ) { if ( i * 5 <= n ) { dp [ i * 5 ] = min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= n ) { dp [ i + 3 ] = min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } return dp [ n ] ; }
int solve ( int A [ ] , int N , int K ) { int sum = 0 ; int c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( A [ i ] == 0 ) c ++ ; } if ( ( K > sum ) || ( ( ( sum + K ) % 2 ) != 0 ) ) return 0 ; sum = ( sum + K ) / 2 ; int dp [ N + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= sum ; i ++ ) dp [ 0 ] [ i ] = 0 ; for ( int i = 0 ; i <= N ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( ( A [ i - 1 ] <= j ) && ( A [ i - 1 ] != 0 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - A [ i - 1 ] ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ N ] [ sum ] + pow ( 2 , c ) ; }
int countSortedArrays ( int start , int m , int size , int n ) { if ( size == m ) return 1 ; if ( start > n ) return 0 ; int notTaken = 0 , taken = 0 ; taken = countSortedArrays ( start , m , size + 1 , n ) ; notTaken = countSortedArrays ( start + 1 , m , size , n ) ; return taken + notTaken ; }
int getValue ( int arr [ ] , int N ) { int dp [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { int min = arr [ i ] ; int max = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { min = min ( arr [ j ] , min ) ; max = max ( arr [ j ] , max ) ; dp [ i ] = max ( dp [ i ] , max - min + ( ( j >= 1 ) ? dp [ j - 1 ] : 0 ) ) ; } } return dp [ N - 1 ] ; }
int maxScore ( string s , int a [ ] ) { if ( dp . find ( s ) != dp . end ( ) ) return dp [ s ] ; int n = s . length ( ) ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; int head = 0 ; int mx = -1 ; while ( head < n ) { int tail = head ; while ( tail < n ) { if ( s [ tail ] != s [ head ] ) { head = tail ; break ; } string sub = s . substr ( head , tail + 1 ) ; mx = max ( mx , a [ sub . length ( ) - 1 ] + maxScore ( s . substr ( 0 , head ) + s . substr ( tail + 1 , s . length ( ) ) , a ) ) ; tail += 1 ; } if ( tail == n ) break ; } dp [ s ] = mx ; return mx ; }
int minSumDifference ( int * arr , int n , int k1 , int k2 , int sum1 , int sum2 ) { if ( n < 0 ) { if ( k1 == 0 && k2 == 0 ) { return abs ( sum1 - sum2 ) ; } else { return INT_MAX ; } } if ( dp [ n ] [ sum1 ] [ sum2 ] != -1 ) { return dp [ n ] [ sum1 ] [ sum2 ] ; } int op1 = INT_MAX ; int op2 = INT_MAX ; int op3 = INT_MAX ; if ( k1 > 0 ) { op1 = minSumDifference ( arr , n - 1 , k1 - 1 , k2 , sum1 + arr [ n ] , sum2 ) ; } if ( k2 > 0 ) { op2 = minSumDifference ( arr , n - 1 , k1 , k2 - 1 , sum1 , sum2 + arr [ n ] ) ; } op3 = minSumDifference ( arr , n - 1 , k1 , k2 , sum1 , sum2 ) ; dp [ n ] [ sum1 ] [ sum2 ] = min ( op1 , min ( op2 , op3 ) ) ; return dp [ n ] [ sum1 ] [ sum2 ] ; }
void insertVector ( int mask ) { for ( int i = 0 ; i < 20 ; i ++ ) { if ( ! ( mask & 1 << i ) ) continue ; if ( ! dp [ i ] ) { dp [ i ] = mask ; ++ ans ; return ; } mask ^= dp [ i ] ; } }
int cntNumRange ( int L , int R , int K ) { int cnt = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( prodOfDigit ( i ) == K ) { cnt ++ ; } } return cnt ; }
void findSubtreeORUtil ( int N , int Edges [ ] [ MAX ] , int Val [ ] , int Queries [ ] , int Q ) { addEdgesToGraph ( Edges , N ) ; findSubtreeOR ( Queries , Q , Val ) ; }
int findMinimum ( int arr [ ] , int N , int pos , int turn ) { auto x = new R ( pos , turn ) ; if ( m . find ( x ) != m . end ( ) ) { return m [ x ] ; } if ( pos >= N - 1 ) { return 0 ; } if ( turn == 0 ) { int ans = min ( findMinimum ( arr , N , pos + 1 , 1 ) + arr [ pos ] , findMinimum ( arr , N , pos + 2 , 1 ) + arr [ pos ] + arr [ pos + 1 ] ) ; V v = new R ( pos , turn ) ; m [ v ] = ans ; return ans ; } if ( turn != 0 ) { int ans = min ( findMinimum ( arr , N , pos + 1 , 0 ) , findMinimum ( arr , N , pos + 2 , 0 ) ) ; V v = new R ( pos , turn ) ; m [ v ] = ans ; return ans ; } }
int countVowelStrings ( int n ) { return countstrings ( n , 0 ) ; }
void maxSum ( int * arr , int n , int m ) { int dp [ n ] [ m + 1 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ m - 1 ] = arr [ 0 ] [ m - 1 ] ; dp [ 1 ] [ m - 1 ] = arr [ 1 ] [ m - 1 ] ; for ( int j = m - 2 ; j >= 0 ; j -- ) { for ( int i = 0 ; i < 2 ; i ++ ) { if ( i == 1 ) { dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 0 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 0 ] [ j + 2 ] ) ; } else { dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 1 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 1 ] [ j + 2 ] ) ; } } } cout << max ( dp [ 0 ] [ 0 ] , dp [ 1 ] [ 0 ] ) ; }
int findMaxGCD ( int arr [ ] , int N ) { int high = 0 ; for ( int i = 0 ; i < N ; i ++ ) { high = max ( high , arr [ i ] ) ; } int count [ high + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { count [ arr [ i ] ] += 1 ; } int counter = 0 ; for ( int i = high ; i > 0 ; i -- ) { int j = i ; counter = 0 ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } }
int findLCS ( int nums [ ] , int N ) { int k = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int pos = LowerBound ( nums , k , nums [ i ] ) ; nums [ pos ] = nums [ i ] ; if ( k == pos ) { k = pos + 1 ; } } return k ; }
int check ( int mask , int i ) { return ( mask & ( 1 << i ) ) ; }
int minSteps ( int m , int n ) { if ( n == m ) return 0 ; if ( m > n ) return inf ; int min_cost = inf ; for ( int i = 2 ; i < m ; i += 2 ) { if ( m % i == 0 ) { min_cost = min ( min_cost , m / i + minSteps ( m + i , n ) ) ; } } return min_cost ; }
void checkEqualSum ( int arr [ ] , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { cout << "Yes" ; } else { cout << "No" ; } }
void queries_fxn ( vector < vector < int > > matrix , vector < vector < int > > queries ) { for ( vector < int > q : queries ) manipulation ( matrix , q ) ; }
void countNums ( int N ) { int dp [ N ] [ 16 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { for ( int k = 0 ; k < 16 ; k ++ ) { int xorr = j ^ k ; dp [ i ] [ xorr ] += dp [ i - 1 ] [ k ] ; } } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ N - 1 ] [ i ] ; cout << count ; }
int constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si ) { if ( ss == se ) { if ( prime [ arr [ ss ] ] ) st [ si ] = arr [ ss ] ; else st [ si ] = 0 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ; return st [ si ] ; }
void dfs ( int a , int par ) { int leaf = 1 ; for ( auto i : v [ a ] ) { if ( i . first == par ) continue ; leaf = 0 ; dfs ( i . first , a ) ; } if ( leaf == 1 ) { leaves [ a ] += 1 ; } else { for ( auto i : v [ a ] ) { if ( i . first == par ) continue ; leaves [ a ] += leaves [ i . first ] ; dp [ a ] = dp [ a ] + dp [ i . first ] + leaves [ i . first ] * i . second ; } } }
long long getCount ( int n , int k ) { if ( n == 1 ) return 10 ; long long dp [ 11 ] = { 0 } , next [ 11 ] = { 0 } ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { int l = max ( 0 , j - k ) ; int r = min ( 9 , j + k ) ; next [ l ] += dp [ j ] ; next [ r + 1 ] -= dp [ j ] ; } for ( int j = 1 ; j <= 9 ; j ++ ) next [ j ] += next [ j - 1 ] ; for ( int j = 0 ; j < 10 ; j ++ ) { dp [ j ] = next [ j ] ; next [ j ] = 0 ; } } long long count = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) count += dp [ i ] ; return count ; }
int nCrModp ( int n , int r ) { if ( n % 2 == 1 ) { return -1 ; } int C [ r + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % MOD ; } return C [ r ] ; }
void findResult ( int arr [ ] , int n , Query q [ ] , int m ) { for ( int i = 0 ; i < m ; i ++ ) cout << findResultUtil ( arr , q [ i ] . L , q [ i ] . R ) << " " ; }
void insert ( int idx , string s , TrieNode * root ) { TrieNode * temp = root ; for ( int i = idx ; i < s . size ( ) ; i ++ ) { if ( temp -> child [ s [ i ] - 'a' ] == NULL ) temp -> child [ s [ i ] - 'a' ] = new TrieNode ( ) ; temp = temp -> child [ s [ i ] - 'a' ] ; } }
int minCuts ( string S1 , string S2 ) { int n1 = S1 . length ( ) ; int n2 = S2 . length ( ) ; TrieNode * root = new TrieNode ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) { insert ( i , S2 , root ) ; } int dp [ n1 + 1 ] ; memset ( dp , INF , sizeof ( dp ) ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { TrieNode * temp = root ; for ( int j = i + 1 ; j <= n1 ; j ++ ) { if ( temp -> child [ S1 [ j - 1 ] - 'a' ] == NULL ) break ; dp [ j ] = min ( dp [ j ] , dp [ i ] + 1 ) ; temp = temp -> child [ S1 [ j - 1 ] - 'a' ] ; } } if ( dp [ n1 ] >= INF ) return -1 ; else return dp [ n1 ] ; }
int maximum ( int A , int B , int C , int D ) { return max ( max ( A , B ) , max ( C , D ) ) ; }
void maxSubarraySum ( vector < int > graph [ ] , int vertices , vector < int > values ) { vector < bool > visited ( 1001 , false ) ; int maxSum = INT_MIN ; for ( int i = 1 ; i <= vertices ; i ++ ) { if ( visited [ i ] == false ) { int sizeChain ; int tempSum ; vector < int > storeChain ; depthFirst ( i , graph , visited , storeChain ) ; sizeChain = storeChain . size ( ) ; int chainValues [ sizeChain + 1 ] ; for ( int j = 0 ; j < sizeChain ; j ++ ) { int temp = values [ storeChain [ j ] - 1 ] ; chainValues [ j ] = temp ; } tempSum = subarraySum ( chainValues , sizeChain ) ; if ( tempSum > maxSum ) { maxSum = tempSum ; } } } cout << "Maximum subarray sum among all " ; cout << "connected components = " ; cout << maxSum ; }
int countDecodingDP ( string digits , int n ) { if ( digits [ 0 ] == '0' ) { return 0 ; } int count0 = 1 , count1 = 1 , count2 ; for ( int i = 2 ; i <= n ; i ++ ) { int dig1 = 0 , dig2 , dig3 = 0 ; if ( digits [ i - 1 ] != '0' ) { dig1 = 1 ; } if ( digits [ i - 2 ] == '1' ) { dig2 = 1 ; } else dig2 = 0 ; if ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) { dig3 = 1 ; } count2 = dig1 * count1 + dig2 + dig3 * count0 ; count0 = count1 ; count1 = count2 ; } return count1 ; }
int countSubMatrix ( int mtrx [ ] [ dim ] , int k , int p ) { int dp [ dim ] [ dim ] ; memset ( dp , 0 , sizeof ( dp ) ) ; createTable ( mtrx , k , p , dp ) ; return countSubMatrixUtil ( dp , k , p ) ; }
int f ( int n , int k ) { if ( n < k ) return 0 ; if ( n == k ) return 1 ; if ( k == 1 ) return 1 ; if ( dp [ n ] [ k ] != -1 ) return dp [ n ] [ k ] ; return dp [ n ] [ k ] = ( ( k * f ( n - 1 , k ) ) % mod + ( f ( n - 1 , k - 1 ) ) % mod ) % mod ; }
bool checkPrime ( string number ) { int num = stoi ( number ) ; for ( int i = 2 ; i * i <= num ; i ++ ) if ( ( num % i ) == 0 ) return false ; return true ; }
int countNumbers ( int n , int k ) { int st = 1 ; int i ; for ( i = 0 ; i <= n ; i ++ ) { powers [ i ] = st ; st *= 10 ; st %= mod ; } st = 1 ; for ( i = 0 ; i <= n ; i ++ ) { powersModk [ i ] = st ; st *= 10 ; st %= mod ; } memset ( dp , -1 , sizeof ( dp ) ) ; return calculate ( 0 , 0 , 0 , k , n ) ; }
int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; }
int maxSum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int limit = 2 * sum + 1 ; int dp [ n + 1 ] [ limit ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) dp [ i ] [ j ] = INT_MIN ; } dp [ 0 ] [ sum ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) { if ( ( j - a [ i - 1 ] ) >= 0 && dp [ i - 1 ] [ j - a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ; if ( ( j + a [ i - 1 ] ) < limit && dp [ i - 1 ] [ j + a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ; if ( dp [ i - 1 ] [ j ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ sum ] ; }
int minSteps ( string str , int n , int k ) { if ( str [ n - 1 ] == '0' ) return -1 ; if ( n == 1 ) return 0 ; if ( n < 4 ) return 1 ; int * dp = new int [ n ] ; dp [ n - 1 ] = 0 ; dp [ n - 2 ] = 1 ; dp [ n - 3 ] = 1 ; for ( int i = n - 4 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) continue ; int steps = INT_MAX ; if ( i + k < n && str [ i + k ] == '1' ) steps = min ( steps , dp [ i + k ] ) ; if ( str [ i + 1 ] == '1' ) steps = min ( steps , dp [ i + 1 ] ) ; if ( str [ i + 2 ] == '1' ) steps = min ( steps , dp [ i + 2 ] ) ; dp [ i ] = ( steps == INT_MAX ) ? steps : 1 + steps ; } if ( dp [ 0 ] == INT_MAX ) return -1 ; return dp [ 0 ] ; }
int eggDrop ( int n , int k ) { int dp [ k + 1 ] [ n + 1 ] ; int x = 0 ; while ( dp [ x ] [ n ] < k ) { x ++ ; for ( int i = 1 ; i <= n ; i ++ ) dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; } return x ; }
void findMax ( int a [ ] , int n ) { int dp [ n ] [ 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = a [ 0 ] + a [ 1 ] ; dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 1 ] ; for ( int i = 1 ; i <= n - 2 ; i ++ ) { dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i + 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] ; } cout << max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] ) ; }
double expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] ) return dp [ x ] ; v [ x ] = 1 ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; }
int findCnt ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; return dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; }
int ways ( int arr [ ] , int n ) { int dp [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; }
double Probability ( double p [ ] , int n ) { double dp [ n + 1 ] [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 1.0 ; for ( int i = 1 ; i <= n ; i += 1 ) { for ( int j = 0 ; j <= i ; j += 1 ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 ] [ j - 1 ] * p [ i ] ; } } double ans = 0.0 ; for ( int i = ( n + 1 ) / 2 ; i <= n ; i += 1 ) ans += dp [ n ] [ i ] ; return ans ; }
int count_required_sequence ( int n , int arr [ ] ) { int total_required_subsequence = 0 ; int total_n_required_subsequence = 0 ; int dp [ N ] [ 2 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int turn_required = 0 ; for ( int j = -1 ; j <= 1 ; j ++ ) turn_required += dp [ arr [ i ] + j ] [ 0 ] ; int required_end_i = ( total_required_subsequence + turn_required ) ; int n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) ; total_required_subsequence += required_end_i ; total_n_required_subsequence += n_required_end_i ; dp [ arr [ i ] ] [ 1 ] += required_end_i ; dp [ arr [ i ] ] [ 0 ] += n_required_end_i ; } return total_required_subsequence ; }
int recur ( int u , int array [ ] , int n ) { if ( u == 0 ) return 0 ; if ( dp [ u ] != -1 ) return dp [ u ] ; for ( int i = 0 ; i < n ; i ++ ) { int mask = get_binary ( array [ i ] ) ; if ( ( mask u ) == u ) { dp [ u ] = max ( max ( 0 , dp [ u ^ mask ] ) + array [ i ] , dp [ u ] ) ; } } return dp [ u ] ; }
int solve ( int * array , int n ) { memset ( dp , -1 , sizeof ( dp ) ) ; int ans = 0 ; for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { ans = max ( ans , recur ( i , array , n ) ) ; } return ans ; }
int MinDiff ( int i , int sum , int arr [ ] , int n ) { if ( i == n ) return 0 ; if ( visit [ i ] [ sum + MAX ] > 0 ) return dp [ i ] [ sum + MAX ] ; visit [ i ] [ sum + MAX ] = 1 ; dp [ i ] [ sum + MAX ] = RetClose ( arr [ i ] + MinDiff ( i + 1 , sum + arr [ i ] , arr , n ) , MinDiff ( i + 1 , sum , arr , n ) , -1 * sum ) ; return dp [ i ] [ sum + MAX ] ; }
int minSteps ( int arr [ ] , int i , int mask , int n ) { if ( i == n - 1 ) return 0 ; if ( i > n - 1 i < 0 ) return 9999999 ; if ( ( mask >> i ) & 1 ) return 9999999 ; if ( v [ i ] [ mask ] ) return dp [ i ] [ mask ] ; v [ i ] [ mask ] = 1 ; dp [ i ] [ mask ] = 1 + min ( minSteps ( arr , i - arr [ i ] , ( mask | ( 1 << i ) ) , n ) , minSteps ( arr , i + arr [ i ] , ( mask | ( 1 << i ) ) , n ) ) ; return dp [ i ] [ mask ] ; }
int maxSumPath ( int i1 , int j1 , int i2 ) { int j2 = i1 + j1 - i2 ; if ( i1 >= n i2 >= n j1 >= m j2 >= m ) return 0 ; if ( cache [ i1 ] [ j1 ] [ i2 ] != -1 ) return cache [ i1 ] [ j1 ] [ i2 ] ; int ans = INT_MIN ; ans = max ( ans , maxSumPath ( i1 + 1 , j1 , i2 + 1 ) + sum ( i1 , j1 , i2 , j2 ) ) ; ans = max ( ans , maxSumPath ( i1 , j1 + 1 , i2 ) + sum ( i1 , j1 , i2 , j2 ) ) ; ans = max ( ans , maxSumPath ( i1 , j1 + 1 , i2 + 1 ) + sum ( i1 , j1 , i2 , j2 ) ) ; ans = max ( ans , maxSumPath ( i1 + 1 , j1 , i2 ) + sum ( i1 , j1 , i2 , j2 ) ) ; cache [ i1 ] [ j1 ] [ i2 ] = ans ; return ans ; }
void pre_process ( bool dp [ N ] [ N ] , string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = false ; } for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) dp [ i ] [ i + j - 1 ] = true ; } else if ( s [ i ] == s [ i + j - 1 ] ) dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] ; } } }
int maxSum ( int a [ ] , int n ) { int ans = 0 ; int arr [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; int dp [ n + 1 ] [ 3 ] ; for ( int i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 3 ) dp [ i ] [ 2 ] = max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = max ( ans , dp [ i ] [ 0 ] ) ; ans = max ( ans , dp [ i ] [ 1 ] ) ; ans = max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; }
long sumEvenFactors ( int L , int R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; }
int numberOfWays ( int x , int y , int z ) { binomialCoeff ( max ( x , max ( y , z ) ) ) ; int sum = 0 ; for ( int i = 1 ; i <= z ; i ++ ) { sum = ( sum + C [ z ] [ i ] ) ; } int sum1 = 0 ; for ( int i = 1 ; i <= y ; i ++ ) { for ( int j = i + 1 ; j <= x ; j ++ ) { sum1 = ( sum1 + ( C [ y ] [ i ] * C [ x ] [ j ] ) ) ; } } sum1 = ( sum * sum1 ) ; return sum1 ; }
int findMaxSubarraySum ( int a [ ] , int n , int k ) { memset ( dp , -1 , sizeof ( dp ) ) ; int ans = -1e9 ; for ( int i = 0 ; i < n ; i ++ ) ans = max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ; if ( ans == 0 && k == 0 ) return * max_element ( a , a + n ) ; return ans ; }
int count ( int pos , int even , int odd , int tight , vector < int > num ) { if ( pos == num . size ( ) ) { if ( num . size ( ) & 1 ) swap ( odd , even ) ; int d = even - odd ; for ( int i = 0 ; i < 24 ; i ++ ) if ( d == prime [ i ] ) return 1 ; return 0 ; } if ( dp [ pos ] [ even ] [ odd ] [ tight ] != -1 ) return dp [ pos ] [ even ] [ odd ] [ tight ] ; int ans = 0 ; int limit = ( tight ? 9 : num [ pos ] ) ; for ( int d = 0 ; d <= limit ; d ++ ) { int currF = tight , currEven = even ; int currOdd = odd ; if ( d < num [ pos ] ) currF = 1 ; if ( pos & 1 ) currOdd += d ; else currEven += d ; ans += count ( pos + 1 , currEven , currOdd , currF , num ) ; } return dp [ pos ] [ even ] [ odd ] [ tight ] = ans ; }
int maxWeight ( int arr [ ] , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != -1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; }
int solve ( int x ) { vector < int > num ; while ( x ) { num . push_back ( x % 10 ) ; x /= 10 ; } reverse ( num . begin ( ) , num . end ( ) ) ; memset ( dp , -1 , sizeof ( dp ) ) ; return count ( 0 , 0 , 0 , 0 , 0 , num ) ; }
void factorial ( int k ) { fac [ 0 ] = 1 ; for ( int i = 1 ; i <= k + 1 ; i ++ ) { fac [ i ] = ( i * fac [ i - 1 ] ) ; } }
int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != -1 ) return dp [ k ] [ col ] ; int sum = 0 ; if ( col == color [ k ] ) sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k ] [ col ] = sum ; }
int maxCost ( int a [ ] , int n , int l , int r ) { int mx = 0 , k ; for ( int i = 0 ; i < n ; ++ i ) mx = max ( mx , a [ i ] ) ; int count [ mx + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int res [ mx + 1 ] = { 0 } ; res [ 0 ] = 0 ; l = min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { k = max ( num - l - 1 , 0 ) ; res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; }
void alternateFib ( int n ) { if ( n < 0 ) return ; int f1 = 0 ; int f2 = 1 ; cout << f1 << " " ; for ( int i = 2 ; i <= n ; i ++ ) { int f3 = f2 + f1 ; if ( i % 2 == 0 ) cout << f3 << " " ; f1 = f2 ; f2 = f3 ; } }
int findSDSFunc ( int n ) { int DP [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }
int findInd ( int key , int i , int n , int k , int arr [ ] ) { int start , end , mid , ind = -1 ; start = i + 1 ; end = n - 1 ; while ( start < end ) { mid = start + ( end - start ) / 2 ; if ( arr [ mid ] - key <= k ) { ind = mid ; start = mid + 1 ; } else { end = mid ; } } return ind ; }
void Combination ( int * a , int * combi , int n , int r , int depth , int index ) { if ( index == r ) { int product = 1 ; for ( int i = 0 ; i < r ; i ++ ) product = product * combi [ i ] ; sum += product ; return ; } for ( int i = depth ; i < n ; i ++ ) { combi [ index ] = a [ i ] ; Combination ( a , combi , n , r , i + 1 , index + 1 ) ; } }
int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
int lobb ( int n , int m ) { return ( ( 2 * m + 1 ) * binomialCoeff ( 2 * n , m + n ) ) / ( m + n + 1 ) ; }
int numberofways ( string A , string B , int N , int M ) { vector < int > pos [ MAX ] ; for ( int i = 0 ; i < M ; i ++ ) pos [ B [ i ] ] . push_back ( i + 1 ) ; int dpl [ N + 1 ] [ M + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ; else dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ; } } int LCS = dpl [ N ] [ M ] ; int dpr [ N + 1 ] [ M + 1 ] ; for ( int i = N ; i >= 1 ; i -- ) { for ( int j = M ; j >= 1 ; j -- ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ; else dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ; } } int ans = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { for ( int x : pos [ j ] ) { if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) { ans ++ ; break ; } } } } return ans ; }
void precompute ( string s , int n , int l [ ] [ MAX ] , int r [ ] [ MAX ] ) { l [ s [ 0 ] - 'a' ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < MAX_CHAR ; j ++ ) l [ j ] [ i ] += l [ j ] [ i - 1 ] ; l [ s [ i ] - 'a' ] [ i ] ++ ; } r [ s [ n - 1 ] - 'a' ] [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < MAX_CHAR ; j ++ ) r [ j ] [ i ] += r [ j ] [ i + 1 ] ; r [ s [ i ] - 'a' ] [ i ] ++ ; } }
int maxSum ( vector < vector < int > > mat , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ n ] [ n ] ; memset ( dp , INT_MIN , sizeof ( dp ) ) ; int maxSum = INT_MIN , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = INT_MIN ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
int minJump ( int height [ ] [ MAX ] , int x , int y ) { if ( x == 4 - 1 && y == 3 - 1 ) return 0 ; int diag = INT_MAX ; if ( isSafe ( x + 1 , y + 1 ) ) diag = minJump ( height , x + 1 , y + 1 ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ; int down = INT_MAX ; if ( isSafe ( x + 1 , y ) ) down = minJump ( height , x + 1 , y ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ; int right = INT_MAX ; if ( isSafe ( x , y + 1 ) ) right = minJump ( height , x , y + 1 ) + abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ; return min ( down , min ( right , diag ) ) ; }
int numberOfWays ( int x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
int minRemove ( int arr [ ] , int n ) { int LIS [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = max ( len , LIS [ i ] ) ; } return n - len ; }
int smallestSumSubarr ( int arr [ ] , int n ) { int min_ending_here = INT_MAX ; int min_so_far = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = min ( min_so_far , min_ending_here ) ; } return min_so_far ; }
int baseconversion ( int arr [ ] , int num , int base ) { int i = 0 , rem , j ; if ( num == 0 ) { return 0 ; } while ( num > 0 ) { rem = num % base ; arr [ i ++ ] = rem ; num /= base ; } return i ; }
int ans ( int n ) { if ( n < 6 ) { return n ; } return n % 6 + 10 * ( ans ( n / 6 ) ) ; }
int nonDecNums ( int n ) { int a [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
int LAS ( int arr [ ] , int n ) { int inc = 1 ; int dec = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) { inc = dec + 1 ; } else if ( arr [ i ] < arr [ i - 1 ] ) { dec = inc + 1 ; } } return max ( inc , dec ) ; }
int lps ( string str ) { int n = str . length ( ) ; int L [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; }
int largestZigZagSumRec ( int mat [ ] [ MAX ] , int i , int j , int n ) { if ( i == n - 1 ) return mat [ i ] [ j ] ; int zzs = 0 ; for ( int k = 0 ; k < n ; k ++ ) if ( k != j ) zzs = max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) ; return zzs + mat [ i ] [ j ] ; }
int largestZigZag ( int mat [ ] [ MAX ] , int n ) { int res = 0 ; for ( int j = 0 ; j < n ; j ++ ) res = max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) ; return res ; }
int MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) { int dp [ n + 1 ] [ m + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; }
int unboundedKnapsack ( int W , int n , int * val , int * wt ) { int dp [ W + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i <= W ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( wt [ j ] <= i ) { dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ; } } } return dp [ W ] ; }
int countSubarray ( int arr [ ] , int n , int k ) { int s = 0 ; int i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } int count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } s += ( ( count * ( count + 1 ) ) / 2 ) ; } return ( n * ( n + 1 ) / 2 - s ) ; }
int CountPS ( char str [ ] , int n ) { int dp [ n ] [ n ] ; bool P [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) P [ i ] [ i ] = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { P [ i ] [ i + 1 ] = true ; dp [ i ] [ i + 1 ] = 1 ; } } for ( int gap = 2 ; gap < n ; gap ++ ) { for ( int i = 0 ; i < n - gap ; i ++ ) { int j = gap + i ; if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ; if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } } return dp [ 0 ] [ n - 1 ] ; }
int breakSum ( int n ) { if ( n == 0 n == 1 ) return n ; return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; }
int findMinSum ( int arr [ ] , int n ) { int sum [ n ] ; sum [ 0 ] = arr [ 0 ] ; sum [ 1 ] = arr [ 1 ] ; sum [ 2 ] = arr [ 2 ] ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = arr [ i ] + minimum ( sum [ i - 3 ] , sum [ i - 2 ] , sum [ i - 1 ] ) ; return minimum ( sum [ n - 1 ] , sum [ n - 2 ] , sum [ n - 3 ] ) ; }
int minAdjustmentCost ( int A [ ] , int n , int target ) { int dp [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; int k = max ( j - target , 0 ) ; for ( ; k <= min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) ; } } int res = INT_MAX ; for ( int j = 0 ; j <= M ; j ++ ) res = min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }
int countWays ( int p , int q , int r , int last ) { if ( p < 0 q < 0 r < 0  ) return 0 ; if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ; if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ; if ( last == 0 ) return countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ; if ( last == 1 ) return countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; if ( last == 2 ) return countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; }
int countP ( int n , int k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }
int countP ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }
bool has4 ( int x ) { while ( x != 0 ) { if ( x % 10 == 4 ) return true ; x = x / 10 ; } return false ; }
int findMaxforN ( Node * root , int N ) { if ( root == NULL ) return -1 ; if ( root -> key == N ) return N ; else if ( root -> key < N ) { int k = findMaxforN ( root -> right , N ) ; if ( k == -1 ) return root -> key ; else return k ; } else if ( root -> key > N ) return findMaxforN ( root -> left , N ) ; }
int findMinInsertionsDP ( char str [ ] , int n ) { int table [ n ] [ n ] ; int l , h , gap ; for ( gap = 1 ; gap < n ; ++ gap ) for ( l = 0 , h = gap ; h < n ; ++ l , ++ h ) table [ l ] [ h ] = ( str [ l ] == str [ h ] ) ? table [ l + 1 ] [ h - 1 ] : ( min ( table [ l ] [ h - 1 ] , table [ l + 1 ] [ h ] ) + 1 ) ; return table [ 0 ] [ n - 1 ] ; }
int distanceBetween2 ( Node * root , int a , int b ) { if ( root == NULL ) return 0 ; if ( root -> key > a && root -> key > b ) return distanceBetween2 ( root -> left , a , b ) ; if ( root -> key < a && root -> key < b ) return distanceBetween2 ( root -> right , a , b ) ; if ( root -> key >= a && root -> key <= b ) return distanceFromRoot ( root , a ) + distanceFromRoot ( root , b ) ; return 0 ; }
int eggDrop ( int n , int k ) { int eggFloor [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = INT_MAX ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; }
bool getCountUtil ( node * root , int low , int high , int & count ) { if ( root == NULL ) return true ; bool l = getCountUtil ( root -> left , low , high , count ) ; bool r = getCountUtil ( root -> right , low , high , count ) ; if ( l && r && inRange ( root , low , high ) ) { ++ count . a ; return true ; } return false ; }
int ksmallestElementSum ( Node * root , int k ) { int res = ksmallestElementSumRec ( root , k ) ; return res ; }
void findOccurrences ( string S , string T ) { int n1 = S . size ( ) ; int n2 = T . size ( ) ; int ans = 0 ; int last = 0 ; for ( int i = 0 ; i <= n1 - n2 ; i ++ ) { bool chk = true ; for ( int j = 0 ; j < n2 ; j ++ ) { if ( T [ j ] != S [ i + j ] ) { chk = false ; break ; } } if ( chk ) { ans += ( i + 1 - last ) * ( n1 - ( i + n2 - 1 ) ) ; last = i + 1 ; } } cout << ans ; }
int countTimes ( vector < int > arr , int K ) { int N = ( int ) arr . size ( ) ; if ( N == 1 ) return 1 ; if ( N < 3 ) return 0 ; if ( N == 3 ) { int cnt = 0 ; cnt += ( abs ( arr [ 0 ] - arr [ 1 ] ) == K ? 1 : 0 ) + ( abs ( arr [ 2 ] - arr [ 1 ] ) == K ? 1 : 0 ) + ( abs ( arr [ 0 ] - arr [ 2 ] ) == K ? 1 : 0 ) ; return cnt ; } vector < int > prefix ( N + 2 , 0 ) ; vector < int > suffix ( N + 2 , 0 ) ; prefix [ 0 ] = arr [ 0 ] ; prefix [ 1 ] = arr [ 1 ] ; suffix [ N - 1 ] = arr [ N - 1 ] ; suffix [ N - 2 ] = arr [ N - 2 ] ; for ( int i = 2 ; i < N ; i += 2 ) { prefix [ i ] = arr [ i ] + prefix [ i - 2 ] ; } for ( int i = 3 ; i < N ; i += 2 ) { prefix [ i ] = arr [ i ] + prefix [ i - 2 ] ; } for ( int i = N - 3 ; i >= 0 ; i -= 2 ) { suffix [ i ] = arr [ i ] + suffix [ i + 2 ] ; } for ( int i = N - 4 ; i >= 0 ; i -= 2 ) { suffix [ i ] = arr [ i ] + suffix [ i + 2 ] ; } int count = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( abs ( prefix [ i - 1 ] + suffix [ i + 2 ] - prefix [ i - 2 ] - suffix [ i + 1 ] ) == K ) { count ++ ; } } count += findCount0th ( arr , N , K ) ; count += findCount1st ( arr , N , K ) ; return count ; }
void LargestArray ( int N , int low , int high ) { int high_index = N - ( high - low + 1 ) ; if ( high_index > ( N - 1 ) / 2 ) { cout << "Not Possible" ; return ; } if ( high_index <= 0 ) high_index = 1 ; int A [ N ] ; int temp = high ; for ( int i = high_index ; i >= 0 ; i -- ) { A [ i ] = temp -- ; } high -= 1 ; for ( int i = high_index + 1 ; i < N ; i ++ ) A [ i ] = high -- ; for ( int i = 0 ; i < N ; i ++ ) { cout << A [ i ] << " " ; } }
int OddLengthSum ( vector < int > & arr ) { int sum = 0 ; int l = arr . size ( ) ; for ( int i = 0 ; i < l ; i ++ ) { sum += ( ( ( i + 1 ) * ( l - i ) + 1 ) / 2 ) * arr [ i ] ; } return sum ; }
int SpiralElement ( int x , int y ) { int r ; if ( x < y ) { if ( y & 1 ) { r = y * y ; return ( r - x + 1 ) ; } else { r = ( y - 1 ) * ( y - 1 ) ; return ( r + x ) ; } } else { if ( x & 1 ) { r = x * x ; return ( r - y + 1 ) ; } else { r = ( x - 1 ) * ( x - 1 ) ; return ( r + y ) ; } } }
bool checkprefix ( int A , int B ) { string s1 = to_string ( A ) ; string s2 = to_string ( B ) ; int n1 = s1 . length ( ) ; int n2 = s2 . length ( ) ; if ( n1 < n2 ) { return false ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( s1 [ i ] != s2 [ 1 ] ) { return false ; } } return true ; }
int Count ( int i ) { if ( i == 0 ) return 1 ; else if ( i < 0 ) return 0 ; if ( a [ i ] == 0 ) { a [ i ] = ( i + 1 ) + 2 * Count ( i - 1 ) ; return a [ i ] ; } else return a [ i ] ; }
int printOddFactorNumber ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) { if ( ( i > 0 ) && ( i & ( i - 1 ) ) ) cout << i << " " ; } return 0 ; }
void stateC ( string n ) { cout << "String accepted" ; }
int findDistinctSums ( int n ) { set < int > s ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { s . insert ( i + j ) ; } } return s . size ( ) ; }
void check_string_exist ( string S ) { int size = S . size ( ) ; bool check = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( S [ i ] != S [ ( i + 2 ) % size ] ) { check = false ; break ; } } if ( check ) cout << "Yes" << endl ; else cout << "No" << endl ; }
int nthTerm ( int N ) { int nth = 0 , first_term = 12 ; nth = ( first_term * ( pow ( 2 , N - 1 ) ) ) + 11 * ( ( pow ( 2 , N - 1 ) ) - 1 ) ; return nth ; }
bool isVowel ( char ch ) { switch ( ch ) { case 'a' : case 'e' : case 'i' : case 'o' : case 'u' : return true ; } return false ; }
int KMPSearch ( string pat , string txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int lps [ M ] ; computeLPSArray ( pat , M , lps ) ; int i = 0 ; int j = 0 ; while ( i < N ) { if ( pat [ j ] == txt [ i ] ) { j ++ ; i ++ ; } if ( j == M ) { return i - j + 1 ; } else if ( i < N && pat [ j ] != txt [ i ] ) { if ( j != 0 ) j = lps [ j - 1 ] ; else i = i + 1 ; } } return 0 ; }
bool checkSequence ( string a , string b ) { if ( b . length ( ) == 0 ) return true ; if ( a . length ( ) == 0 ) return false ; if ( a [ 0 ] == b [ 0 ] ) return checkSequence ( a . substr ( 1 ) , b . substr ( 1 ) ) ; else return checkSequence ( a . substr ( 1 ) , b ) ; }
int getCount ( string a , string b ) { if ( b . length ( ) % a . length ( ) != 0 ) return -1 ; int count = b . length ( ) / a . length ( ) ; string str = "" ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str == b ) return count ; return -1 ; }
bool isVowel ( char c ) { string vowel = "aeiou" ; for ( int i = 0 ; i < vowel . length ( ) ; ++ i ) if ( vowel [ i ] == c ) return true ; return false ; }
int calc ( int l , int r , string & s ) { if ( abs ( r - l ) % 2 == 0 ) return 0 ; if ( l > r ) return dp [ l ] [ r ] = 1 ; if ( dp [ l ] [ r ] != -1 ) return dp [ l ] [ r ] ; if ( ( r - l ) == 1 ) { if ( s [ l ] == s [ r ] ) dp [ l ] [ r ] = 1 ; else dp [ l ] [ r ] = 0 ; return dp [ l ] [ r ] ; } int ans = 0 ; for ( int k = l + 1 ; k <= r ; k += 2 ) { int temp = 1 ; if ( s [ l ] == s [ k ] ) { temp = calc ( l + 1 , k - 1 , s ) * calc ( k + 1 , r , s ) * choose [ ( ( r - l + 1 ) / 2 ) ] [ ( ( r - k ) / 2 ) ] ; ans += temp ; } } return dp [ l ] [ r ] = ans ; }
int number_of_tower ( int house [ ] , int range , int n ) { sort ( house , house + n ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
int minimumFlips ( string s ) { int n = s . length ( ) ; int cnt0 = count ( s , '0' ) ; int cnt1 = 0 ; int res = n - cnt0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) { cnt0 -= 1 ; } else if ( s [ i ] == '1' ) { res = min ( res , cnt1 + cnt0 ) ; cnt1 ++ ; } } return res ; }
char KthCharacter ( string s , string t , long long k ) { long long f = 1 ; long long ss = 2 ; string tmp = "" ; int len = tmp . length ( ) ; while ( len < k ) { long long tf = f ; long long ts = ss ; while ( tf -- ) tmp += s ; while ( ts -- ) tmp += t ; f += 2 ; ss += 2 ; len = tmp . length ( ) ; } char output = tmp [ k - 1 ] ; return output ; }
int fact ( int n ) { int ans = 1 ; for ( int i = 2 ; i <= n ; i ++ ) ans = ans * i ; return ans ; }
string checkIfPossible ( int N , string arr [ ] , string T ) { int freqS [ 256 ] = { 0 } ; int freqT [ 256 ] = { 0 } ; for ( char ch : T ) { freqT [ ch - 'a' ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { for ( char ch : arr [ i ] ) { freqS [ ch - 'a' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freqT [ i ] == 0 && freqS [ i ] != 0 ) { return "No" ; } else if ( freqS [ i ] == 0 && freqT [ i ] != 0 ) { return "No" ; } else if ( freqT [ i ] != 0 && freqS [ i ] != ( freqT [ i ] * N ) ) { return "No" ; } } return "Yes" ; }
void findSubstringInWraproundString ( string p ) { int ans = 0 ; int curLen = 0 ; int arr [ 26 ] ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) { int curr = p [ i ] - 'a' ; if ( i > 0 && ( p [ i - 1 ] != ( ( curr + 26 - 1 ) % 26 + 'a' ) ) ) { curLen = 0 ; } curLen ++ ; if ( curLen > arr [ curr ] ) { ans += ( curLen - arr [ curr ] ) ; arr [ curr ] = curLen ; } } cout << ans ; }
void update ( int BIT [ 26 ] [ 10005 ] , int idx , int i , int val ) { while ( i < 10005 ) { BIT [ idx ] [ i ] += val ; i = i + ( i & ( - i ) ) ; } }
int fact ( int a ) { int i , f = 1 ; for ( i = 2 ; i <= a ; i ++ ) f = f * i ; return f ; }
int maxLength ( vector < string > & arr ) { vector < string > tmp = helper ( arr , 0 ) ; int len = 0 ; for ( int i = 0 ; i < tmp . size ( ) ; i ++ ) { len = len > tmp [ i ] . length ( ) ? len : tmp [ i ] . length ( ) ; } return len ; }
long long polynomialRollingHash ( string str ) { int p = 31 ; int m = 1e9 + 9 ; long long power_of_p = 1 ; long long hash_val = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { hash_val = ( hash_val + ( str [ i ] - 'a' + 1 ) * power_of_p ) % m ; power_of_p = ( power_of_p * p ) % m ; } return hash_val ; }
bool isPalindrome ( string str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) { if ( str [ l ] != str [ h ] ) { return false ; } l ++ ; h -- ; } return true ; }
bool checkPalindrome ( ) { int oddCnt = 0 ; for ( auto x : freq ) { if ( x % 2 == 1 ) oddCnt ++ ; } return oddCnt <= 1 ; }
int countSubstrings ( string str , int K ) { int N = str . size ( ) ; int answer = 0 ; unordered_map < char , int > map ; for ( int i = 0 ; i < K ; i ++ ) { map [ str [ i ] ] ++ ; } if ( map . size ( ) == K ) answer ++ ; for ( int i = K ; i < N ; i ++ ) { map [ str [ i ] ] ++ ; map [ str [ i - K ] ] -- ; if ( map [ str [ i - K ] ] == 0 ) { map . erase ( str [ i - K ] ) ; } if ( map . size ( ) == K ) { answer ++ ; } } return answer ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
void moveAtEnd ( string s , int i , int l ) { if ( i >= l ) return ; char curr = s [ i ] ; if ( curr != 'x' ) cout << curr ; moveAtEnd ( s , i + 1 , l ) ; if ( curr == 'x' ) cout << curr ; return ; }
void kthString ( int n , int k ) { int total = 0 ; int i = 1 ; while ( total < k ) { total = total + n - i ; i ++ ; } int first_y_position = i - 1 ; int second_y_position = k - ( total - n + first_y_position ) ; for ( int j = 1 ; j < first_y_position ; j ++ ) cout << "x" ; cout << "y" ; int j = first_y_position + 1 ; while ( second_y_position > 1 ) { cout << "x" ; second_y_position -- ; j ++ ; } cout << "y" ; while ( j < n ) { cout << "x" ; j ++ ; } }
void check ( string str ) { if ( checkIfStartsWithCapital ( str ) == 1 ) cout << "Accepted" ; else cout << "Not Accepted" ; }
void compressString ( string s , int n ) { int freq [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ s [ i ] - 'a' ] ++ ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == 0 ) continue ; cout << char ( i + 'a' ) << "" << freq [ i ] ; } }
int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }
int findLength ( string s , int k ) { int ans = INT_MAX ; int l = 0 ; int r = 0 ; int cnt_zero = 0 , cnt_one = 0 ; while ( l < s . size ( ) && r <= s . size ( ) ) { if ( cnt_zero >= k && cnt_one >= 1 ) { ans = min ( ans , r - l ) ; l ++ ; if ( s [ l - 1 ] == '0' ) cnt_zero -- ; else cnt_one -- ; } else { if ( r == s . size ( ) ) break ; if ( s [ r ] == '0' ) cnt_zero ++ ; else cnt_one ++ ; r ++ ; } } if ( ans == INT_MAX ) return -1 ; return ans ; }
int cntSplits ( string s ) { if ( s [ s . size ( ) - 1 ] == '1' ) return -1 ; int ans = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) ans += ( s [ i ] == '0' ) ; return ans ; }
void findMinSubStr ( string arr [ ] , int n , string str ) { for ( int i = 0 ; i < n ; i ++ ) uSet . insert ( arr [ i ] ) ; findSubStr ( str , 0 , 0 ) ; }
void printChar ( string str , int n ) { int freq [ SIZE ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - 'a' ] % 2 == 0 ) { cout << str [ i ] ; } } }
int find_digit ( string s , int n ) { int first_digit = -1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] < '0' s [ i ] > '9' ) { first_digit = i ; break ; } } first_digit ++ ; int s_len = first_digit ; int num = 0 , pw = 1 ; int i = n - 1 ; while ( i >= 0 ) { if ( s [ i ] >= '0' && s [ i ] <= '9' ) { int digit = s [ i ] - '0' ; num = num + ( pw * digit ) ; if ( num >= s_len ) return -1 ; pw = pw * 10 ; } i -- ; } num = num * 10 ; int req = s_len - num ; if ( req > 9 req < 0 ) return -1 ; return req ; }
int countSubString ( string s , char c , int k ) { int leftCount = 0 , rightCount = 0 ; int left = 0 , right = 0 ; int freq = 0 ; int result = 0 , len = s . length ( ) ; while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } right = left + 1 ; while ( freq != ( k - 1 ) && ( right - 1 ) < len ) { if ( s [ right ] == c ) { freq ++ ; } right ++ ; } while ( left < len && ( right - 1 ) < len ) { while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } while ( right < len && s [ right ] != c ) { if ( s [ right ] == c ) { freq ++ ; } right ++ ; rightCount ++ ; } result = result + ( leftCount + 1 ) * ( rightCount + 1 ) ; freq = k - 1 ; leftCount = 0 ; rightCount = 0 ; left ++ ; right ++ ; } return result ; }
int minOperations ( int n , string a , string b , string c ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char x = a [ i ] ; char y = b [ i ] ; char z = c [ i ] ; if ( x == y && y == z ) else if ( x == y y == z x == z ) { ans ++ ; } else { ans += 2 ; } } return ans ; }
void preCalculate ( string s , int prefix [ N ] [ 26 ] ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ i ] [ s [ i ] - 'a' ] ++ ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) prefix [ i ] [ j ] += prefix [ i - 1 ] [ j ] ; } }
bool check ( string s , int l ) { vector < int > pos ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '1' ) pos . push_back ( i ) ; } int t = pos . size ( ) ; for ( int i = 1 ; i < t ; i ++ ) { if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) return false ; } return true ; }
vector < int > compute_lps ( string s ) { int n = s . size ( ) ; vector < int > lps ( n ) ; int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = lps [ len - 1 ] ; else { lps [ i ] = 0 ; i ++ ; } } } return lps ; }
void printLastChar ( string str ) { str = str + " " ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' ' ) cout << str [ i - 1 ] << " " ; } }
int getMinimizedSum ( string str , int len ) { int i , maxVal = INT_MIN , sum = 0 ; int occurrences [ 26 ] = { 0 } ; for ( i = 0 ; i < len ; i ++ ) { occurrences [ str [ i ] - 'a' ] ++ ; sum += ( int ) str [ i ] ; } for ( i = 0 ; i < 26 ; i ++ ) maxVal = max ( maxVal , occurrences [ i ] * ( i + 'a' ) ) ; return ( sum - maxVal ) ; }
int substrDeletion ( string str , int len ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) count0 ++ ; else count1 ++ ; } return min ( count0 , count1 ) ; }
void printString ( string str , int n ) { int ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) ones ++ ; bool used = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '2' && ! used ) { used = true ; for ( int j = 0 ; j < ones ; j ++ ) cout << "1" ; } if ( str [ i ] != '1' ) cout << str [ i ] ; } if ( ! used ) for ( int j = 0 ; j < ones ; j ++ ) cout << "1" ; }
char Colour_Combination ( string s ) { char temp = s [ 0 ] ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == 'B' temp == 'G' ) && ( s [ i ] == 'G' || s [ i ] == 'B' ) ) temp = 'Y' ; else if ( ( temp == 'B' temp == 'Y' ) && ( s [ i ] == 'Y' || s [ i ] == 'B' ) ) temp = 'G' ; else temp = 'B' ; } } return temp ; }
void reverse ( string str , int x ) { int n = ( str . length ( ) - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) cout << str [ i ] ; for ( int i = n + x - 1 ; i >= n ; i -- ) cout << str [ i ] ; for ( int i = n + x ; i < str . length ( ) ; i ++ ) cout << str [ i ] ; }
int countSubStrings ( string str , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) count += subStringsStartingHere ( str , n , i ) ; } return count ; }
int maxFreq ( string s , int a , int b ) { int fre [ 10 ] = { 0 } ; int n = s . length ( ) ; if ( a > b ) swap ( a , b ) ; for ( int i = 0 ; i < n ; i ++ ) fre [ s [ i ] - '0' ] ++ ; if ( fre [ a ] == 0 && fre [ b ] == 0 ) return -1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; }
void sumProdOfPrimeFreq ( string s ) { bool prime [ s . size ( ) + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , s . size ( ) + 1 ) ; int i , j ; map < char , int > mp ; for ( i = 0 ; i < s . size ( ) ; i ++ ) { mp [ s [ i ] ] ++ ; } int sum = 0 , product = 1 ; for ( auto it : mp ) { if ( prime [ it . second ] ) { sum += it . second ; product *= it . second ; } } cout << "Sum = " << sum ; cout << "Product="  }
void StringMatch ( string s ) { int lo = 0 , hi = s . length ( ) , len = s . length ( ) ; vector < int > ans ; for ( int x = 0 ; x < len ; x ++ ) { if ( s [ x ] == 'I' ) { ans . push_back ( lo ) ; lo += 1 ; } else { ans . push_back ( hi ) ; hi -= 1 ; } } ans . push_back ( lo ) ; cout << "[" ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { cout << ans [ i ] ; if ( i != ans . size ( ) - 1 ) cout << "," ; } cout << "]" ; }
int CountCharacters ( string str , int l , int r ) { int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( l <= str [ i ] && str [ i ] <= r ) { cnt ++ ; cout << str [ i ] << " " ; } } return cnt ; }
int countPermutations ( string str ) { int even = floor ( ( double ) ( str . size ( ) / 2 ) ) ; int odd = str . size ( ) - even ; int ways = 0 ; int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { freq [ str [ i ] - 'a' ] ++ ; } int nvowels = freq [ 0 ] + freq [ 4 ] + freq [ 8 ] + freq [ 14 ] + freq [ 20 ] ; int nconsonants = str . size ( ) - nvowels ; ways = npr ( odd , nvowels ) * npr ( nconsonants , nconsonants ) ; return ways ; }
bool isVowel ( char ch ) { if ( ch != 'a' && ch != 'e' && ch != 'i' && ch != 'o' && ch != 'u' ) { return false ; } return true ; }
int maxLength ( string s , int n ) { int right = 0 , left = 0 ; int coun = 0 , max_length = INT_MIN ; s = s + '1' ; for ( int i = 0 ; i <= n ; i ++ ) { if ( s [ i ] == 'o' ) coun ++ ; else { if ( coun > max_length ) { right = 0 , left = 0 ; if ( s [ i ] == 'x' ) right = 1 ; if ( ( i - coun ) > 0 ) && ( s [ i - coun - 1 ] == 'x' ) ) left = 1 ; coun = ceil ( ( double ) coun / ( right + left ) ) ; max_length = max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; }
bool is_possible ( string s ) { int l = s . length ( ) ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( abs ( one - zero ) == 1 ) ; }
int oddEquivalent ( string s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) count ++ ; } return count ; }
bool isPalindrome ( string str ) { int firstChar = 0 , lastChar = str . length ( ) - 1 ; bool ch = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { firstChar = firstPos ( str , firstChar , lastChar ) ; lastChar = lastPos ( str , lastChar , firstChar ) ; if ( lastChar < 0 firstChar < 0 ) break ; if ( str [ firstChar ] == str [ lastChar ] ) { firstChar ++ ; lastChar -- ; continue ; } ch = false ; break ; } return ch ; }
int find ( string s ) { int max = 0 , i , j = 0 , countk = 0 , countr = 0 ; int table [ s . length ( ) ] [ 2 ] ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == 'R' ) countr ++ ; else table [ j ++ ] [ 0 ] = countr ; } j -- ; for ( i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == 'K' ) { countk ++ ; table [ j -- ] [ 1 ] = countk ; } if ( min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) > max ) max = min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) ; } return max ; }
void LongestSequence ( int fre [ ] [ MAX ] , int n ) { for ( int i = 24 ; i >= 0 ; i -- ) { int mi = fre [ 0 ] [ i ] ; for ( int j = 1 ; j < n ; j ++ ) mi = min ( fre [ j ] [ i ] , mi ) ; while ( mi -- ) cout << ( char ) ( 'a' + i ) ; } }
int firstNonRepeating ( string str ) { const int NO_OF_CHARS = 256 ; int arr [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) arr [ i ] = -1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( arr [ str [ i ] ] == -1 ) arr [ str [ i ] ] = i ; else arr [ str [ i ] ] = -2 ; } int res = INT_MAX ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( arr [ i ] >= 0 ) res = min ( res , arr [ i ] ) ; return res ; }
void preComputeCoeff ( ) { for ( int i = 0 ; i < max ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = ( nCr [ i - 1 ] [ j - 1 ] + nCr [ i - 1 ] [ j ] ) % mod ; } } }
int countNonEmptySubstr ( string str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }
int countWays ( string s ) { int count [ 26 ] = { 0 } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) count [ s [ i ] - 'a' ] ++ ; count [ s [ 0 ] - 'a' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
bool isPerfectSquareString ( string str ) { int sum = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) sum += ( int ) str [ i ] ; long squareRoot = sqrt ( sum ) ; return ( ( squareRoot - floor ( squareRoot ) ) == 0 ) ; }
int findSubstrings ( string s , int k ) { int ans = 0 ; int cnt [ 26 ] = { 0 } ; int i , j , n = s . size ( ) ; for ( i = 0 ; i < n ; i ++ ) { memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( j = i ; j < n ; j ++ ) { cnt [ s [ j ] - 'a' ] ++ ; if ( cnt [ s [ j ] - 'a' ] <= k ) { ans ++ ; else { break ; } } } return ans ; }
bool isPanDigital ( string s ) { int digits [ 10 ] = { 0 } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) digits [ s [ i ] - '0' ] = 1 ; for ( int i = 0 ; i <= 9 ; i ++ ) if ( digits [ i ] == 0 ) return false ; return true ; }
int combinedSum ( string s ) { int n = s . length ( ) ; int c_sum = 0 ; int range = ( 1 << n ) - 1 ; for ( int i = 0 ; i <= range ; i ++ ) c_sum += findSubSequence ( s , i ) ; return c_sum ; }
int numberOfPossiblePallindrome ( string str , int n ) { unordered_map < char , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ str [ i ] ] ++ ; int fi ; for ( auto it : mp ) { if ( it . second % 2 == 0 ) fi = it . second / 2 ; else { fi = ( it . second - 1 ) / 2 ; k ++ ; } num = num + fi ; den = den * fact ( fi ) ; } if ( num != 0 ) num = fact ( num ) ; int ans = num / den ; if ( k != 0 ) { ans = ans * k ; } return ( ans ) ; }
int totalConsonants ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( isConsonant ( str [ i ] ) ) ++ count ; return count ; }
void convert ( string str ) { int n = str . length ( ) ; string str1 = "" ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) str1 = str1 + '_' ; else str1 = str1 + tolower ( str [ i ] ) ; } cout << str1 ; }
bool isEven ( string s ) { int l = s . length ( ) ; char s [ ] ; bool dotSeen = false ; for ( int i = l - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '0' && dotSeen == false ) continue ; if ( s [ i ] == '.' ) { dotSeen = true ; continue ; } if ( ( s [ i ] - '0' ) % 2 == 0 ) return true ; return false ; } }
bool isVowel ( char c ) { return ( c == 'A' c == 'E' c == 'I' c == 'O' c == 'U' c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) ; }
int countReduce ( string str ) { int n = str . length ( ) ; int res = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) res += abs ( str [ i ] - str [ n - i - 1 ] ) ; return res ; }
void reverse ( char num [ ] , int i , int j ) { while ( i < j ) { swap ( num [ i ] , num [ j ] ) ; i ++ ; j -- ; } }
void findWinner ( vector < string > & votes ) { unordered_map < string , int > map ; for ( string str : votes ) { map [ str ] ++ ; } int maxValueInMap = 0 ; string winner ; for ( auto it : map ) { string key = it . first ; int val = it . second ; if ( val > maxValueInMap ) { maxValueInMap = val ; winner = key ; } else if ( val == maxValueInMap && winner . compare ( key ) > 0 ) winner = key ; } cout << winner ; }
bool distributingBalls ( long k , long n , string str ) { long a [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { a [ str [ i ] - 'a' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; }
bool check ( int freq [ ] , int k ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( freq [ i ] != 0 && freq [ i ] != k ) return false ; return true ; }
long countSets ( int a [ n ] [ m ] ) { long res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i ] [ j ] == 1 ) u ++ ; else v ++ ; } res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] [ i ] == 1 ) u ++ ; else v ++ ; } res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 ; } return res - ( n * m ) ; }
void traverseTree ( NodeTemp * root ) { if ( ! root ) return ; while ( root ) { cout << root -> data << " " ; if ( root -> child ) traverseTree ( root -> child ) ; root = root -> next ; } }
int calculateEnergy ( int mat [ ] [ MAX ] , int n ) { int i_des , j_des , q ; int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { q = mat [ i ] [ j ] / n ; i_des = q ; j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += abs ( i_des - i ) + abs ( j_des - j ) ; } } return tot_energy ; }
int countUnique ( int mat [ ] [ MAX ] , int n , int m ) { int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] && isUnique ( mat , i , j , n , m ) ) uniquecount ++ ; return uniquecount ; }
bool uniqueCharacters ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) for ( int j = i + 1 ; j < str . length ( ) ; j ++ ) if ( str [ i ] == str [ j ] ) return false ; return true ; }
char largest_alphabet ( char a [ ] , int n ) { char max = 'A' ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] > max ) max = a [ i ] ; return max ; }
bool isPalRec ( string str , int s , int e ) { if ( s == e ) return true ; if ( ( str [ s ] ) != ( str [ e ] ) ) return false ; if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; }
int evenNumSubstring ( char str [ ] ) { int len = strlen ( str ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) if ( checkEquality ( s . substr ( i , len ) ) ) result ++ ; return result ; }
bool unique ( string s ) { sort ( s . begin ( ) , s . end ( ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return false ; return true ; }
void qType1 ( int tree [ ] [ 27 ] , int l , int x , char str [ ] ) { update ( tree , l , -1 , str [ l - 1 ] - 97 + 1 ) ; str [ l - 1 ] = x ; update ( tree , l , 1 , str [ l - 1 ] - 97 + 1 ) ; }
int countPairs ( string str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j ) ) result ++ ; return result ; }
int findMinLength ( string arr [ ] , int n ) { int min = arr [ 0 ] . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] . length ( ) < min ) min = arr [ i ] . length ( ) ; return ( min ) ; }
bool areDistinct ( string str , int i , int j ) { bool visited [ 26 ] ; for ( int k = i ; k <= j ; k ++ ) { if ( visited [ str [ k ] - 'a' ] == true ) return false ; visited [ str [ k ] - 'a' ] = true ; } return true ; }
void printRLE ( string str ) { int n = str . length ( ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) { count ++ } else { cout << str [ i ] ; cout << count ; count = 1  ; } cout << str [ i ] ; cout << count ; } }
void antiSpiralTraversal ( int m , int n , int a [ ] [ MAX ] ) { int i , k = 0 , l = 0 ; stack < int > stk ; while ( k <= m && l <= n ) { for ( i = l ; i <= n ; ++ i ) stk . push ( a [ k ] [ i ] ) ; k ++ ; for ( i = k ; i <= m ; ++ i ) stk . push ( a [ i ] [ n ] ) ; n -- ; if ( k <= m ) { for ( i = n ; i >= l ; -- i ) stk . push ( a [ m ] [ i ] ) ; m -- ; } if ( l <= n ) { for ( i = m ; i >= k ; -- i ) stk . push ( a [ i ] [ l ] ) ; l ++ ; } } while ( ! stk . empty ( ) ) { cout << stk . top ( ) << " " ; stk . pop ( ) ; } }
int findNormal ( int mat [ ] [ 3 ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] * mat [ i ] [ j ] ; return sqrt ( sum ) ; }
int countExpPaths ( Node * root , int x ) { return evenPaths ( root , 0 , x ) ; }
int evenPaths ( Node * root , int count ) { if ( root == NULL || ( root -> key % 2 != 0 ) ) { return count ; } if ( ! root -> left && ! root -> right ) { count ++ ; } count = evenPaths ( root -> left , count ) ; return evenPaths ( root -> right , count ) ; }
int countEvenPaths ( Node * root ) { return evenPaths ( root , 0 ) ; }
void dfs ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent [ u ] . size ( ) ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] ) { temp ++ ; dfs ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; startnode = u ; } } }
void insertEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; }
int canPaint ( vector < Node * > nodes , int n , int m ) { vector < int > visited ( n + 1 , 0 ) ; int maxColors = 1 ; for ( int sv = 1 ; sv <= n ; sv ++ ) { if ( visited [ sv ] ) { continue ; } visited [ sv ] = 1 ; queue < int > q ; q . push ( sv ) ; while ( q . size ( ) != 0 ) { int top = q . front ( ) ; q . pop ( ) ; for ( auto it : nodes [ top ] -> edges ) { if ( nodes [ top ] . color == nodes [ it ] . color ) { nodes [ it ] . color += 1 ; } maxColors = max ( maxColors , max ( nodes [ top ] . color , nodes [ it ] . color ) ) ; if ( maxColors > m ) return 0 ; if ( visited [ it ] == 0 ) { visited [ it ] = 1 ; q . pop ( it ) ; } } } } return 1 ; }
void FastDoubling ( int n , int * res ) { int a , b , c , d ; int MOD = 1000000007 ; if ( n == 0 ) { res [ 0 ] = 0 ; res [ 1 ] = 1 ; return ; } FastDoubling ( ( n / 2 ) , res ) ; a = res [ 0 ] ; b = res [ 1 ] ; c = 2 * b - a ; if ( c < 0 ) c += MOD ; c = ( a * c ) % MOD ; d = ( a * a + b * b ) % MOD ; if ( n % 2 == 0 ) { res [ 0 ] = c ; res [ 1 ] = d ; } else { res [ 0 ] = d ; res [ 1 ] = c + d ; } }
bool canPlace ( int a [ ] , int n , int p , int sep ) { int prisoners_placed = 1 ; int last_prisoner_placed = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int current_cell = a [ i ] ; if ( current_cell - last_prisoner_placed >= sep ) { prisoners_placed ++ ; last_prisoner_placed = current_cell ; if ( prisoners_placed == p ) { return true ; } } } return false ; }
int _mergeSort ( int arr [ ] , int temp [ ] , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; }
int minSteps ( int height [ ] , int N ) { return minStepsRecur ( height , 0 , N , 0 ) ; }
int power ( int x , unsigned int y , int p ) { int res = 1 x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; y = y / 2 x = ( x * x ) % p ; } return res ; }
int minimumRectangleArea ( int A [ ] , int N ) { int ans ; sort ( A , A + N ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( int i = 1 ; i < N ; i ++ ) ans = min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; }
double areaOftriangle ( int side ) { double a = sqrt ( pow ( side / 2 , 2 ) + pow ( side / 2 , 2 ) ) ; double b = sqrt ( pow ( side , 2 ) + pow ( side / 2 , 2 ) ) ; double c = sqrt ( pow ( side , 2 ) + pow ( side / 2 , 2 ) ) ; double s = ( a + b + c ) / 2 ; double area = sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; return area ; }
void interceptLength ( int a , int b , int c , int i , int j , int k ) { double rad = radius ( a , b , c ) ; double dist = centerDistanceFromLine ( a , b , i , j , k ) ; if ( rad < 0 dist < 0  ) { cout << "circle not possible" ; return ; } if ( dist > rad ) { cout << "Line not cutting circle" ; } else cout << 2 * sqrt ( rad * rad - dist * dist ) ; }
int centralPoints ( int arr [ ] [ 2 ] , int N ) { int count = 0 ; int c1 , c2 , c3 , c4 ; for ( int i = 0 ; i < N ; i ++ ) { c1 = 0 ; c2 = 0 ; c3 = 0 ; c4 = 0 ; int x = arr [ i ] [ 0 ] ; int y = arr [ i ] [ 1 ] ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ j ] [ 0 ] > x && arr [ j ] [ 1 ] == y ) { c1 = 1 ; } if ( arr [ j ] [ 1 ] > y && arr [ j ] [ 0 ] == x ) { c2 = 1 ; } if ( arr [ j ] [ 0 ] < x && arr [ j ] [ 1 ] == y ) { c3 = 1 ; } if ( arr [ j ] [ 1 ] < y && arr [ j ] [ 0 ] == x ) { c4 = 1 ; } } if ( c1 + c2 + c3 + c4 == 4 ) { count ++ ; } } return count ; }
void printMatrixDiagonal ( int mat [ ] [ MAX ] , int n ) { int i = 0 , j = 0 ; bool isUp = true ; for ( int k = 0 ; k < n * n ; ) { if ( isUp ) { for ( ; i >= 0 && j < n ; j ++ , i -- ) { cout << mat [ i ] [ j ] << " " ; k ++ ; } if ( i < 0 && j <= n - 1 ) i = 0 ; if ( j == n ) { i = i + 2 ; j -- ; } } else { for ( ; j >= 0 && i < n ; i ++ , j -- ) { cout << mat [ i ] [ j ] << " " ; k ++ ; } if ( j < 0 && i <= n - 1 ) j = 0 ; if ( i == n ) { j = j + 2 ; i -- ; } } isUp = ! isUp ; } }
double calculateSideLength ( double L , int N , int K ) { double angle = findInteriorAngle ( N ) ; double length = L * pow ( sin ( angle / 2 ) , ( K - 1 ) ) ; return length ; }
void minimumTriangleArea ( int a , int b ) { int area = a * b ; cout << area ; }
void finalPosition ( char a [ ] , int b [ ] , int M ) { int n = 0 , s = 0 , e = 0 , w = 0 ; char p = 'N' ; for ( int i = 0 ; i < M ; i ++ ) { if ( p == 'N' ) { if ( a [ i ] == 'U' ) { p = 'N' ; n = n + b [ i ] ; } else if ( a [ i ] == 'D' ) { p = 'S' ; s = s + b [ i ] ; } else if ( a [ i ] == 'R' ) { p = 'E' ; e = e + b [ i ] ; } else if ( a [ i ] == 'L' ) { p = 'W' ; w = w + b [ i ] ; } } else if ( p == 'S' ) { if ( a [ i ] == 'U' ) { p = 'S' ; s = s + b [ i ] ; } else if ( a [ i ] == 'D' ) { p = 'N' ; n = n + b [ i ] ; } else if ( a [ i ] == 'L' ) { p = 'E' ; e = e + b [ i ] ; } } else if ( p == 'E' ) { if ( a [ i ] == 'U' ) { p = 'E' ; e = e + b [ i ] ; } else if ( a [ i ] == 'D' ) { p = 'W' ; w = w + b [ i ] ; } else if ( a [ i ] == 'R' ) { p = 'S' ; s = s + b [ i ] ; } else if ( a [ i ] == 'L' ) { p = 'N' ; n = n + b [ i ] ; } } else if ( p == 'W' ) { if ( a [ i ] == 'U' ) { p = 'W' ; w = w + b [ i ] ; } else if ( a [ i ] == 'D' ) { p = 'E' ; e = e + b [ i ] ; } else if ( a [ i ] == 'D' ) { p = 'E' ; e = e + b [ i ] ; } } else if ( a [ i ] ==
void findPairs ( vector < int > x , vector < int > y , int K ) { int n = x . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { if ( K * abs ( x [ i ] - x [ j ] ) >= abs ( y [ i ] - y [ j ] ) ) { ++ ans ; } } } cout << ans ; }
void pyramidSlantHeight ( double pyramid_h , double pyramid_s ) { double slant_height_pyramid = sqrt ( pow ( pyramid_s / 2 , 2 ) + pow ( pyramid_h , 2 ) ) ; cout << "Slant height of pyramid is: " << slant_height_pyramid << endl ; }
double Area_Parallelogram2 ( int a , int b , int gamma ) { double area = ( abs ( sin ( toRadians ( gamma ) ) ) ) * abs ( a * b ) ; return area ; }
int No_of_rectangles ( int L , int B , int l , int b ) { if ( ( l > L ) || ( b > B ) ) { return -1 ; } else { return ( L - l + 1 ) * ( B - b + 1 ) ; } }
double Area_of_Rhombus ( int a , int theta ) { double area = ( a * a ) * sin ( ( RADIAN * theta ) ) ; return area ; }
int nCr ( int n , int r ) { return ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) ; }
float distanceEndpoints ( int a , int b , float c ) { float angle = cal_cos ( c ) ; return sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; }
void perpenBisectorFromLine ( point P , point Q , double a , double b , double c ) { point mid_point ; mid_point . x = ( P . x + Q . x ) / 2 ; mid_point . y = ( P . y + Q . y ) / 2 ; c = - b * ( mid_point . x ) + a * ( mid_point . y ) ; double temp = a ; a = - b ; b = temp ; }
float circlearea ( float R ) { if ( R < 0 ) return -1 ; float a = ( 3.14 * R * R ) / 4 ; return a ; }
int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; }
double area ( double d1 , double a ) { double d2 = sqrt ( 4 * ( a * a ) - d1 * d1 ) ; double area = 0.5 * d1 * d2 ; return area ; }
float areaOfKite ( int d1 , int d2 ) { float area = ( d1 * d2 ) / 2 ; return area ; }
void findTriangles ( int n ) { int num ; num = n * ( n - 4 ) ; cout << num ; }
int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }
float normal ( float m , float n ) { float N = ( abs ( m ) * abs ( n ) ) / sqrt ( ( abs ( m ) * abs ( m ) ) + ( abs ( n ) * abs ( n ) ) ) ; return N ; }
bool isPossible ( int a [ ] , int n ) { int sum = 0 , maxS = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; maxS = max ( a [ i ] , maxS ) ; } if ( ( sum - maxS ) > maxS ) return true ; return false ; }
bool pointIsOnLine ( int m , int c , int x , int y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; float A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ; return A ; }
float heptdiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.802 * a ; return d ; }
float trianglearea ( float a ) { if ( a < 0 ) return -1 ; float area = ( 3 * sqrt ( 3 ) * pow ( a , 2 ) ) / 4 ; return area ; }
void circle_equation ( double x1 , double y1 , double r ) { double a = -2 * x1 ; double b = -2 * y1 ; double c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; cout << "x^2 + (" << a << " x) + " ; cout << "y^2 + (" << b << " y) = " ; cout << c << "." ; }
double Perimeter ( double s , int n ) { double perimeter = 1 ; perimeter = n * s ; return perimeter ; }
long long dis ( long long x1 , long long y1 , long long x2 , long long y2 ) { return sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; }
float area ( float b , float h ) { return ( 1LL * b * h ) / 2 ; }
float findRadiusOfIncircle ( float a , float b , float c ) { if ( a < 0 b < 0 c < 0  ) return -1 ; float p = ( a + b + c ) / 2 ; float area = sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; float radius = area / p ; return radius ; }
void findVolume ( double u , double v , double w , double U , double V , double W , double b ) { double uPow = pow ( u , 2 ) ; double vPow = pow ( v , 2 ) ; double wPow = pow ( w , 2 ) ; double UPow = pow ( U , 2 ) ; double VPow = pow ( V , 2 ) ; double WPow = pow ( W , 2 ) ; double a = 4 * ( uPow * vPow * wPow ) - uPow * pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ; double vol = sqrt ( a ) ; vol /= b ; cout << "%.4f" , vol ) ; }
float rectanglearea ( float r ) { if ( r < 0 ) return -1 ; float a = r * r ; return a ; }
int findMaximumPieces ( int n ) { int x = n / 2 ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; }
int solve ( double M , double N , double s ) { int ans = ( ceil ( M / s ) * ceil ( N / s ) ) ; return ans ; }
int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
void center ( int x1 , int x2 , int y1 , int y2 ) { cout << float ( x1 + x2 ) / 2 << ", " << float ( y1 + y2 ) / 2 ; }
double vol_of_octahedron ( double side ) { return ( ( side * side * side ) * ( sqrt ( 2 ) / 3 ) ) ; }
double circumference ( double r ) { double PI = 3.1415 ; double cir = 2 * PI * r ; return cir ; }
void floodFillUtil ( char mat [ M ] [ N ] , int x , int y , char prevV , char newV ) { if ( x < 0 x > = M y < 0 y > = N ) return ; if ( mat [ x ] [ y ] != prevV ) return ; mat [ x ] [ y ] = newV ; floodFillUtil ( mat , x + 1 , y , prevV , newV ) ; floodFillUtil ( mat , x - 1 , y , prevV , newV ) ; floodFillUtil ( mat , x , y + 1 , prevV , newV ) ; floodFillUtil ( mat , x , y - 1 , prevV , newV ) ; }
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return -1 ; else return 0 ; }
float area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; }
int numberOfDiagonals ( int n ) { return n * ( n - 3 ) / 2 ; }
int orientation ( vector < int > a , vector < int > b , vector < int > c ) { int res = ( b [ 1 ] - a [ 1 ] ) * ( c [ 0 ] - b [ 0 ] ) - ( c [ 1 ] - b [ 1 ] ) * ( b [ 0 ] - a [ 0 ] ) ; if ( res == 0 ) return 0 ; if ( res > 0 ) return 1 ; return -1 ; }
int countLattice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int ySquare = r * r - x * x ; int y = sqrt ( ySquare ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }
int minimumCost ( int arr [ ] , int N , int X , int Y ) { int even_count = 0 , odd_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) && ( i % 2 == 0 ) ) { odd_count ++ ; } if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) ) { even_count ++ ; } } int cost1 = X * min ( odd_count , even_count ) ; int cost2 = Y * ( max ( odd_count , even_count ) - min ( odd_count , even_count ) ) ; int cost3 = ( odd_count + even_count ) * Y ; return min ( cost1 + cost2 , cost3 ) ; }
double root ( double num , int p ) { double left = - num ; double right = num ; double x ; while ( true ) { x = ( left + right ) / 2.0 ; double value = f ( x , p , num ) ; double prime = f_prime ( x , p ) ; if ( value * prime <= 0 ) left = x ; else right = x ; if ( value < 0.000001 && value >= 0 ) { return x ; } } }
int countTriplets ( int N ) { int cnt = 0 ; for ( int A = 1 ; A <= N ; ++ A ) { for ( int B = 1 ; B <= N / A ; ++ B ) { cnt += N / ( A * B ) ; } } return cnt ; }
void nearestRight ( int arr [ ] , int N , vector < int > & steps ) { int R = 2 * N ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { R = N + i ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { R = i ; } steps [ i ] = min ( steps [ i ] , R - i ) ; } }
void updateArray ( vector < int > arr , int K ) { int sum = 0 ; vector < int > res ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( arr [ i ] < K ) { sum += arr [ i ] ; } else { if ( sum != 0 ) { res . push_back ( sum ) ; } sum = 0 ; res . push_back ( arr [ i ] ) ; } } if ( sum != 0 ) res . push_back ( sum ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " " ; }
string checkSameDigits ( int N ) { int digit = N % 10 ; while ( N != 0 ) { int current_digit = N % 10 ; N = N / 10 ; if ( current_digit != digit ) { return "No" ; } } return "Yes" ; }
int maxPossibleMoves ( int X , int Y , int A , int B ) { int ans = 0 ; int L = 1 , R = MAXN ; while ( L <= R ) { int Mid = ( L + R ) / 2 ; if ( can ( Mid , X , Y , A , B ) ) { L = Mid + 1 ; ans = max ( ans , Mid ) ; } else { R = Mid - 1 ; } } return ans ; }
void possiblePair ( int X , int Y ) { int Z = Y - X ; if ( Z < 0 ) { cout << "-1" ; } for ( int k = 0 ; k < MaxBit ; k ++ ) { int bit1 = ( Z >> k ) & 1 ; int bit2 = ( Z >> k ) & 1 ; if ( bit1 && bit2 == 0 ) { cout << "-1" ; } } cout << Z << " " << X ; }
int minSumDifference ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ar [ i ] ; int rem = sum % n ; return rem * ( n - rem ) ; }
int minSteps ( int N ) { int res = ( ( int ) sqrt ( 1 + 8 * N ) - 1 ) / 2 ; return res ; }
void oppositeFaceOfDice ( int N ) { int ans = 7 - N ; cout << ans << endl ; }
void IsEvenPath ( int Source [ ] , int Destination [ ] ) { int x_dif = abs ( Source [ 0 ] - Destination [ 0 ] ) ; int y_dif = abs ( Source [ 1 ] - Destination [ 1 ] ) ; int minsteps = x_dif + y_dif ; if ( minsteps % 2 == 0 ) cout << "Yes" ; else cout << "No" ; }
void findFraction ( long long x , long long y , long long n ) { long long A = -1 , B = -1 ; for ( long long i = 1 ; i <= n ; i ++ ) { long long d = ( i * x ) / y ; if ( d >= 0 && ( A == -1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d ; B = i ; d ++ ; if ( d >= 0 && ( A == -1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d ; B = i ; } A -- ; B -- ; cout << A << "/" << B << endl ; }
int countKAverageSubarrays ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int L = 0 ; L < n ; L ++ ) { int sum = 0 ; for ( int R = L ; R < n ; R ++ ) { sum += arr [ R ] ; int len = ( R - L + 1 ) ; if ( sum % len == 0 ) { int avg = sum / len ; if ( avg == k ) res ++ ; } } } return res ; }
int power ( int x , unsigned int y ) { int res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }
void numberOfPairs ( int N , vector < vector < int > > arr ) { adj . resize ( N ) ; for ( int i = 0 ; i < 2 ; i ++ ) { adj [ arr [ i ] [ 0 ] ] . push_back ( arr [ i ] [ 1 ] ) ; adj [ arr [ i ] [ 1 ] ] . push_back ( arr [ i ] [ 0 ] ) ; } vector < bool > visited ( N , false ) ; vector < int > v ; int num = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! visited [ i ] ) { dfs ( i ) ; v . push_back ( num ) ; num = 0 ; } } int ans = N * ( N - 1 ) / 2 + 1 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { ans -= ( v [ i ] * ( v [ i ] - 1 ) / 2 ) + 1 ; } cout << ans ; }
void isPossible ( int W , int B , int D ) { if ( W > B ) { int temp = W ; W = B ; B = temp ; } if ( B > W * ( D + 1 ) ) cout << "NO" << endl ; else cout << "YES" << endl ; }
int tripletAndSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & ( 1 << bit ) ) cnt ++ ; } ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) / 6 ; } return ans ; }
int largestK ( int A [ ] , int N ) { int l = 0 , r = N - 1 , flag = 0 ; while ( l < r ) { if ( A [ l ] != A [ r ] ) { flag = 1 ; break ; } l ++ ; r -- ; } if ( flag == 0 ) return -1 ; int K = abs ( A [ 0 ] - A [ N - 1 ] ) ; for ( int i = 1 ; i < N / 2 ; i ++ ) K = gcd ( K , abs ( A [ i ] - A [ N - i - 1 ] ) ) ; return K ; }
void NumberofSets ( int N ) { SieveOfEratosthenes ( N ) ; if ( N == 2 ) { cout << 1 ; } else if ( N == 3 ) { cout << 2 ; } else { int ans = 1 ; for ( int i = N / 2 + 1 ; i <= N ; i ++ ) { if ( prime [ i ] ) { ans += 1 ; } } cout << ans ; } }
int sumOfDivisors ( int N ) { return N ; }
bool findDigit ( int N , int D ) { while ( N > 0 ) { int a = N % 10 ; if ( a == D ) { return true ; } N /= 10 ; } return false ; }
int findXORS ( int arr1 [ ] , int arr2 [ ] , int N , int M ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int temp = arr1 [ i ] & arr2 [ j ] ; res ^= temp ; } } return res ; }
float findMedian ( Node * root , int node1 , int node2 ) { getIntermediateNodes ( root , node1 , node2 ) ; int nSize = interNodes . size ( ) ; return ( nSize % 2 == 1 ) ? interNodes [ nSize / 2 ] : ( float ) ( interNodes [ ( nSize - 1 ) / 2 ] + interNodes [ nSize / 2 ] ) / 2 ; }
void findDifference ( int N ) { int s [ N + 1 ] ; sieveOfEratosthenes ( N , s ) ; int total = 1 , odd = 1 , even = 0 ; int curr = s [ N ] ; int cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } if ( curr == 2 ) { total = total * ( cnt + 1 ) ; } else { total = total * ( cnt + 1 ) ; odd = odd * ( cnt + 1 ) ; } curr = s [ N ] ; cnt = 1 ; } even = total - odd ; cout << abs ( even - odd ) ; }
void countPrime ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( n , prime ) ; int dp [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] += dp [ i - 1 ] ; if ( prime [ i ] == true && prime [ i - 2 ] == true ) { dp [ i ] ++ ; } } cout << dp [ n ] ; }
int findGCD ( int a , int b ) { if ( b == 0 ) return a ; return findGCD ( b , a % b ) ; }
int findLCM ( int a , int b ) { return ( a * b ) / findGCD ( a , b ) ; }
int convert ( vector < int > p ) { int ans = 0 ; for ( auto i : p ) { ans = ( ans << 1 ) | i ; } return ans ; }
bool check ( vector < int > Adj [ ] , int Src , int N , bool visited [ ] ) { int color [ N ] = { 0 } ; visited [ Src ] = true ; queue < int > q ; q . push ( Src ) ; while ( ! q . empty ( ) ) { int u = q . front ( ) ; int Col = color [ u ] ; for ( auto x : Adj [ u ] ) { if ( visited [ x ] == true && color [ x ] == Col ) { return false ; } else if ( visited [ x ] == false ) { visited [ x ] = true ; q . push ( x ) ; color [ x ] = 1 - Col ; } } } return true ; }
double average ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; return stoi ( sum / N ) ; }
void checkWinner ( int arr [ ] , int N ) { int diff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { diff -= arr [ i ] ; } if ( diff % 2 == 0 ) { cout << "A" ; } else { cout << "B" ; } }
int countAPs ( int S , int D ) { S = S * 2 ; int answer = 0 ; for ( int i = 1 ; i <= sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { if ( ( ( S / i ) - D * i + D ) % 2 == 0 ) answer ++ ; if ( ( D * i - ( S / i ) + D ) % 2 == 0 ) answer ++ ; } } return answer ; }
void buildSieve ( ) { for ( int i = 2 ; i < 100 ; i ++ ) sieve [ i ] = 1 ; for ( int i = 2 ; i < 100 ; i ++ ) { if ( sieve [ i ] == 1 ) { for ( int j = i * i ; j < 100 ; j += i ) sieve [ j ] = 0 ; } } }
int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; }
int numOfPairs ( vector < string > & arr , int N ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( coprime ( stoi ( arr [ i ] ) , stoi ( arr [ j ] ) ) ) { count = count + 1 ; } } } return count ; }
int countPairs ( int arr [ ] , int N ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { freq [ log ( arr [ i ] ) ] ++ ; } int pairs = 0 ; for ( auto i : freq ) { pairs += i . second - 1 ; } return pairs ; }
int sumOfDigits ( int N ) { int sum = 0 ; while ( N ) { sum += N % 10 ; N /= 10 ; } return sum ; }
