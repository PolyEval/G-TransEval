void sumOfTwoPerfectCubes ( int N ) { HashMap < Integer , Integer > cubes = new HashMap < > ( ) ; for ( int i = 1 ; i * i * i <= N ; i ++ ) cubes . put ( ( i * i * i ) , i ) ; Iterator < Map . Entry < Integer , Integer > > itr = cubes . entrySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { Map . Entry < Integer , Integer > entry = itr . next ( ) ; int firstNumber = entry . getKey ( ) ; int secondNumber = N - entry . getKey ( ) ; if ( cubes . containsKey ( secondNumber ) ) { System . out . println ( "True" ) ; return ; } } System . out . println ( "False" ) ; }
void SieveOfEratosthenes ( int N ) { Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= N ; i += p ) prime [ i ] = false ; } } }
void checksubarrayExist1_N ( int arr [ ] , int N ) { Map < Integer , Integer > pos = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { pos . put ( arr [ i ] , i ) ; } Set < Integer > st = new HashSet < > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { st . add ( pos . get ( i ) ) ; int Min = Collections . min ( st ) ; int Max = Collections . max ( st ) ; if ( Max - Min + 1 == i ) { System . out . print ( "True " ) ; } else { System . out . print ( "False " ) ; } } }
void reverseCircularArray ( int arr [ ] , int N , int K ) { int start = K , end = K - 1 ; int count = N / 2 ; while ( count != 0 ) { int temp = arr [ start % N ] ; arr [ start % N ] = arr [ end % N ] ; arr [ end % N ] = temp ; start ++ ; end -- ; if ( end == - 1 ) { end = N - 1 ; } count -= 1 ; } printArray ( arr , N ) ; }
void XOR_for_every_i ( int A [ ] , int N ) { int frequency_of_bits [ ] = new int [ 32 ] ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int M = A [ i ] ; while ( M != 0 ) { if ( ( M & 1 ) != 0 ) { frequency_of_bits [ bit_position ] += 1 ; } bit_position += 1 ; M >>= 1 ; } } for ( int i = 0 ; i < N ; i ++ ) { int M = A [ i ] ; int value_at_that_bit = 1 ; int XOR_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( ( M & 1 ) != 0 ) { XOR_sum += ( N - frequency_of_bits [ bit_position ] ) * value_at_that_bit ; } else { XOR_sum += ( frequency_of_bits [ bit_position ] ) * value_at_that_bit ; } M >>= 1 ; value_at_that_bit <<= 1 ; } System . out . print ( XOR_sum + " " ) ; } return ; }
void findSum ( int a , int b , int n ) { if ( n == 1 ) { System . out . println ( a ) ; return ; } int s = a + b ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int x = a ^ b ; s += x ; a = b ; b = x ; } System . out . println ( s ) ; }
int countNumbersUtil ( int N ) { int count = 0 ; Vector < Integer > digits = new Vector < Integer > ( ) ; while ( N > 0 ) { digits . add ( N % 10 ) ; N /= 10 ; } Collections . reverse ( digits ) ; int D = digits . size ( ) ; for ( int i = 1 ; i <= D ; i ++ ) { int res = getPower ( i ) ; if ( i == D ) { for ( int p = 1 ; p <= D ; p ++ ) { int x = digits . get ( p - 1 ) ; int tmp = 0 ; if ( p % 2 == 0 ) { tmp = ( 5 - ( x / 2 + 1 ) ) * getPower ( D - p ) ; } else { tmp = ( 5 - ( x + 1 ) / 2 ) * getPower ( D - p ) ; } res -= tmp ; if ( p % 2 != x % 2 ) { break ; } } } count += res ; } return count ; }
int array_sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
boolean check ( int n ) { return 2 * rev ( n ) == n + 1 ; }
int highestPower ( int n ) { return ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; }
boolean isPrimePossible ( int N ) { String s = String . valueOf ( N ) ; int l = s . length ( ) ; if ( l < 2 ) return false ; for ( int i = 0 ; i < l ; i ++ ) { String str = deleteIth ( s , i ) ; int num = Integer . valueOf ( str ) ; if ( isPrime ( num ) ) return true ; } return false ; }
boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int findlcm ( int arr [ ] , int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; return ans ; }
void findAandB ( int n , int k ) { int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( freqCount ( Integer . toString ( i ) , ( char ) ( k + 48 ) ) == 0 && freqCount ( Integer . toString ( n - i ) , ( char ) ( k + 48 ) ) == 0 ) { System . out . print ( "(" + i + ", " + ( n - i ) + ")" ) ; flag = 1 ; break ; } } if ( flag == 0 ) System . out . print ( - 1 ) ; }
int SquareRoot ( int num ) { int count = 0 ; for ( int n = 1 ; n <= num ; n += 2 ) { num = num - n ; count += 1 ; if ( num == 0 ) break ; } return count ; }
void IncrementFactors ( int count [ ] , int val ) { for ( int i = 1 ; i * i <= val ; i ++ ) { if ( val % i == 0 ) { if ( i == val / i ) { count [ i ] ++ ; } else { count [ i ] ++ ; count [ val / i ] ++ ; } } } }
int calcSum ( int k , int n ) { int value = ( k * n * ( n + 1 ) ) / 2 ; return value ; }
void storeDivisors ( int n , Vector < Integer > div ) { for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) div . add ( i ) ; else { div . add ( i ) ; div . add ( n / i ) ; } } } }
void sieveSundaram ( ) { boolean marked [ ] = new boolean [ MAX / 2 + 1 ] ; for ( int i = 1 ; i <= ( Math . sqrt ( MAX ) - 1 ) / 2 ; i ++ ) { for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) { marked [ j ] = true ; } } primes . add ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . add ( 2 * i + 1 ) ; }
int firstDigit ( int n ) { int digits = ( int ) ( Math . log ( n ) / Math . log ( 10 ) ) ; n = ( int ) ( n / Math . pow ( 10 , digits ) ) ; return n ; }
long sumOfSumSeries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
boolean isTetradic ( int n ) { if ( ispalindrome ( n ) && isContaindigit ( n ) ) return true ; return false ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
ArrayList < Integer > getRow ( int rowIndex ) { ArrayList < Integer > currow = new ArrayList < Integer > ( ) ; currow . add ( 1 ) ; if ( rowIndex == 0 ) { return currow ; } ArrayList < Integer > prev = getRow ( rowIndex - 1 ) ; for ( int i = 1 ; i < prev . size ( ) ; i ++ ) { int curr = prev . get ( i - 1 ) + prev . get ( i ) ; currow . add ( curr ) ; } currow . add ( 1 ) ; return currow ; }
int gonNum360 ( int n ) { return ( 358 * n * n - 356 * n ) / 2 ; }
int gonNum257 ( int n ) { return ( 255 * n * n - 253 * n ) / 2 ; }
void solve ( int n ) { for ( int x = 1 ; x <= Math . sqrt ( n ) ; x ++ ) { if ( n % x == 0 ) { int small = x ; int big = n / x ; if ( small % 2 == big % 2 ) { int a = ( small + big ) / 2 ; int b = ( big - small ) / 2 ; System . out . print ( a + " " + b ) ; return ; } } } System . out . print ( - 1 ) ; }
boolean Is_Practical ( int A ) { ArrayList < Integer > divisors ; divisors = get_divisors ( A ) ; for ( int i = 2 ; i < A ; i ++ ) { if ( Sum_Possible ( divisors , i ) == false ) return false ; } return true ; }
long operation ( int arr [ ] , int N ) { int right = 0 ; int num = 0 ; long ans = 0 ; for ( int left = 0 ; left < N ; left ++ ) { while ( right < N && num + arr [ right ] == ( num ^ arr [ right ] ) ) { num += arr [ right ] ; right ++ ; } ans += right - left ; if ( left == right ) right ++ ; else num -= arr [ left ] ; } return ans ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int findMaxSize ( int a [ ] , int n ) { ArrayList < Integer > frq = new ArrayList < Integer > ( n + 1 ) ; for ( int i = 0 ; i <= n ; i ++ ) frq . add ( 0 ) ; for ( int i = 0 ; i < n ; ++ i ) frq . set ( a [ i ] , frq . get ( a [ i ] ) + 1 ) ; int maxfrq = Collections . max ( frq ) ; int dist = n + 1 - Collections . frequency ( frq , 0 ) ; int ans1 = Math . min ( maxfrq - 1 , dist ) ; int ans2 = Math . min ( maxfrq , dist - 1 ) ; int ans = Math . max ( ans1 , ans2 ) ; return ans ; }
int minCount ( int n ) { int [ ] hasharr = { 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ; if ( n > 69 ) return hasharr [ n % 10 ] ; else { if ( n >= hasharr [ n % 10 ] * 7 ) return ( hasharr [ n % 10 ] ) ; else return - 1 ; } }
long power ( long x , long y , long p ) { long res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
int findMaxSum ( int A [ ] , int B [ ] , int n ) { int maxArr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { int X = joinNumbers ( A [ i ] , B [ i ] ) ; int Y = joinNumbers ( B [ i ] , A [ i ] ) ; int mx = Math . max ( X , Y ) ; maxArr [ i ] = mx ; } int maxAns = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxAns += maxArr [ i ] ; } return maxAns ; }
long SmallestPerfectSquare ( long N ) { long X = ( long ) 1e9 ; long ans ; for ( int i = 1 ; i < Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { long a = i ; long b = N / i ; if ( ( b - a != 0 ) && ( ( b - a ) % 2 == 0 ) ) { X = Math . min ( X , ( b - a ) / 2 ) ; } } } if ( X != 1e9 ) ans = X * X ; else ans = - 1 ; return ans ; }
void PrintReverseOrder ( int N ) { for ( int i = N ; i > 0 ; i -- ) System . out . print ( + i + " " ) ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int dfs ( int u , Vector < Integer > [ ] adj , int vis [ ] ) { vis [ u ] = 1 ; int componentSize = 1 ; for ( int it : adj [ u ] ) { if ( vis [ it ] == 0 ) { componentSize += dfs ( it , adj , vis ) ; } } return componentSize ; }
void prefix ( ) { for ( int i = 1 ; i < N ; i ++ ) pref [ i ] = pref [ i - 1 ] + phi [ i ] ; }
void findCo_PrimePaths ( Node root , Vector < Integer > path ) { if ( root == null ) return ; path . add ( root . key ) ; findCo_PrimePaths ( root . left , path ) ; findCo_PrimePaths ( root . right , path ) ; if ( root . left == null && root . right == null ) { if ( isPathCo_Prime ( path ) ) { printCo_PrimePaths ( path ) ; } } path . remove ( path . size ( ) - 1 ) ; }
void sieve ( ) { position [ 0 ] = - 1 ; position [ 1 ] = - 1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = - 1 ; } } }
String permutation ( int arr [ ] , int N ) { int [ ] hash = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( hash [ i ] != 1 ) return "No" ; } return "Yes" ; }
boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; }
int countDigit ( int n ) { boolean prime [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) prime [ i ] = false ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 && prime [ d ] == true ) count ++ ; } return count ; }
void maxValue ( int a ) { String c = Integer . toBinaryString ( a ) ; String b = "" ; for ( int i = 0 ; i < c . length ( ) ; i ++ ) { if ( ( c . charAt ( i ) - '0' ) == 1 ) b += '0' ; else b += '1' ; } System . out . print ( Integer . parseInt ( b , 2 ) ) ; }
int nextFibonacci ( int n ) { double a = n * ( 1 + ( int ) Math . sqrt ( 5 ) ) / 2.0 ; return ( int ) Math . round ( a ) ; }
void preCompute ( ) { for ( int i = 1 ; i < 100001 ; i ++ ) { pref [ i ] = pref [ i - 1 ] + checkArmstrong ( i ) ; } }
void isPrime ( int N ) { boolean isPrime = true ; int [ ] arr = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ; if ( N < 2 ) { isPrime = false ; } if ( N % 2 == 0 N % 3 == 0 N % 5 == 0 ) { isPrime = false ; } for ( int i = 0 ; i < Math . sqrt ( N ) ; i += 30 ) { for ( int c : arr ) { if ( c > Math . sqrt ( N ) ) { break ; } else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } } if ( ! isPrime ) break ; } } if ( isPrime ) System . out . println ( "Prime Number" ) ; else System . out . println ( "Not a Prime Number" ) ; }
void perfectCube ( int N ) { int cube ; for ( int i = 0 ; i <= N ; i ++ ) { cube = i * i * i ; if ( cube == N ) { System . out . println ( "Yes" ) ; return ; } else if ( cube > N ) { System . out . println ( "NO" ) ; return ; } } }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
int count ( int n , int k ) { int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum = sum + binomialCoeff ( n , j ) ; } return sum ; }
int prevPowerofK ( int n , int k ) { int p = ( int ) ( Math . log ( n ) / Math . log ( k ) ) ; return ( int ) Math . pow ( k , p ) ; }
int kth_element ( int a [ ] , int n , int k ) { Vector pos = new Vector ( ) ; Vector neg = new Vector ( ) ; ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) pos . add ( a [ i ] ) ; else neg . add ( a [ i ] ) ; } sort ( pos . begin ( ) , pos . end ( ) ) ; sort ( neg . begin ( ) , neg . end ( ) ) ; Collections . sort ( pos ) ; Collections . sort ( neg ) ; int l = ( int ) - 1e8 , ans = 0 , r = ( int ) 1e8 ; while ( l <= r ) { int mid = ( l + r ) >> 1 ; if ( check ( mid , pos , neg , k ) ) { ans = mid ; r = mid - 1 ; } else l = mid + 1 ; } return ans ; }
int nextNumberDistinctDigit ( int n ) { while ( n < INT_MAX ) { int distinct_digits = countDistinct ( n + 1 ) ; int total_digits = countDigit ( n + 1 ) ; if ( distinct_digits == total_digits ) { return n + 1 ; } else n ++ ; } return - 1 ; }
int Count_subarray ( int arr [ ] , int n ) { int total_sum = 0 , subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { subarray_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ; if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; }
double getSum ( int n ) { double sum = 0 ; if ( n == 1 ) { sum = 45.0 ; } else { sum = ( 99.0 / 2.0 ) * Math . pow ( 10 , n - 1 ) * Math . pow ( 10 , ( n - 1 ) / 2 ) ; } return sum ; }
int getSize ( Node a ) { int sz = 0 ; while ( a != null ) { a = a . next ; sz ++ ; } return sz ; }
int diameter ( int n ) { int L , H , templen ; L = 1 ; H = 0 ; if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; } while ( L * 2 <= n ) { L *= 2 ; H ++ ; } if ( n >= L * 2 - 1 ) return 2 * H + 1 ; else if ( n >= L + ( L / 2 ) - 1 ) return 2 * H ; return 2 * H - 1 ; }
int countSquares ( int n ) { return ( int ) ( Math . pow ( n , 2 ) - ( 2 * n ) + 2 ) ; }
void max_element ( int a [ ] , int n ) { int [ ] pre = new int [ n ] ; pre [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = Math . max ( pre [ i - 1 ] , a [ i ] ) ; int [ ] suf = new int [ n ] ; suf [ n - 1 ] = a [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = Math . max ( suf [ i + 1 ] , a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) System . out . print ( suf [ i + 1 ] + " " ) ; else if ( i == n - 1 ) System . out . print ( pre [ i - 1 ] + " " ) ; else System . out . print ( Math . max ( pre [ i - 1 ] , suf [ i + 1 ] ) + " " ) ; } }
int cntCells ( int n ) { int cells = ( int ) Math . pow ( n , 2 ) + ( int ) Math . pow ( n - 1 , 2 ) ; return cells ; }
void findNums ( int n ) { if ( n <= 11 ) { if ( n == 8 ) System . out . print ( "4 4" ) ; if ( n == 10 ) System . out . print ( "4 6" ) ; else System . out . print ( "-1" ) ; return ; } if ( n % 2 == 0 ) System . out . print ( "4 " + ( n - 4 ) ) ; else System . out . print ( "9 " + ( n - 9 ) ) ; }
int oddFib ( int n ) { n = ( 3 * n + 1 ) / 2 ; int a = - 1 , b = 1 , c = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n == 2 n == 3 ) return true ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int difference ( int n ) { int S , res ; S = ( n * ( n + 1 ) ) / 2 ; res = S * ( S - 1 ) ; return res ; }
long findSmallestNonZeroY ( long A_num ) { String A_binary = Long . toBinaryString ( A_num ) ; long B = 1 ; int len = A_binary . length ( ) ; int no_ones = Long . bitCount ( A_num ) ; if ( len == no_ones ) { return A_num + 1 ; } for ( int i = 0 ; i < len ; i ++ ) { char ch = A_binary . charAt ( len - i - 1 ) ; if ( ch == '0' ) { B = ( long ) Math . pow ( 2.0 , ( double ) i ) ; break ; } } return B ; }
int minimum_elements ( int n , int arr [ ] ) { if ( n < 3 ) return 0 ; int g , ans = 0 , diff , cnt ; diff = arr [ 1 ] - arr [ 0 ] ; g = diff ; for ( int i = 2 ; i < n ; i ++ ) { diff = arr [ i ] - arr [ i - 1 ] ; g = gcd ( g , diff ) ; } for ( int i = 1 ; i < n ; i ++ ) { diff = arr [ i ] - arr [ i - 1 ] ; cnt = diff / g ; ans += ( cnt - 1 ) ; } return ans ; }
void Digits ( int n ) { int largest = 0 ; int smallest = 9 ; while ( n != 0 ) { int r = n % 10 ; largest = Math . max ( r , largest ) ; smallest = Math . min ( r , smallest ) ; n = n / 10 ; } System . out . println ( largest + " " + smallest ) ; }
int countWords ( int N , int M ) { return ( int ) Math . pow ( N , M ) - nPr ( N , M ) ; }
int countBits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n >>= 1 ; } return count ; }
int sum_of_4_squares ( int n ) { int i , odd = 0 , even = 0 ; for ( i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i % 2 == 0 ) even += i ; else odd += i ; if ( ( n / i ) != i ) { if ( ( n / i ) % 2 == 0 ) even += ( n / i ) ; else odd += ( n / i ) ; } } } if ( n % 2 == 1 ) return 8 * ( odd + even ) ; else return 24 * ( odd ) ; }
int Maximum_Length ( Vector < Integer > a ) { int [ ] counts = new int [ 11 ] ; int ans = 0 ; for ( int index = 0 ; index < a . size ( ) ; index ++ ) { counts [ a . get ( index ) ] += 1 ; Vector < Integer > k = new Vector < Integer > ( ) ; for ( int i : counts ) if ( i != 0 ) k . add ( i ) ; Collections . sort ( k ) ; if ( k . size ( ) == 1 || ( k . get ( 0 ) == k . get ( k . size ( ) - 2 ) && k . get ( k . size ( ) - 1 ) - k . get ( k . size ( ) - 2 ) == 1 ) || ( k . get ( 0 ) == 1 && k . get ( 1 ) == k . get ( k . size ( ) - 1 ) ) ) ans = index ; } return ans + 1 ; }
int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; }
int countX ( int a , int b ) { if ( b > a ) return 0 ; else if ( a == b ) return - 1 ; else { int x = a - b , ans = 0 ; for ( int i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { int d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = x / i ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } }
boolean isSafe ( int N , int M , char [ ] str ) { int coll = 0 , colr = 0 , rowu = 0 , rowd = 0 ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == 'L' ) { coll ++ ; if ( colr > 0 ) { colr -- ; } if ( coll == M ) { break ; } } else if ( str [ i ] == 'R' ) { colr ++ ; if ( coll > 0 ) { coll -- ; } if ( colr == M ) { break ; } } else if ( str [ i ] == 'U' ) { rowu ++ ; if ( rowd > 0 ) { rowd -- ; } if ( rowu == N ) { break ; } } else if ( str [ i ] == 'D' ) { rowd ++ ; if ( rowu > 0 ) { rowu -- ; } if ( rowd == N ) { break ; } } } if ( Math . abs ( rowd ) < N && Math . abs ( rowu ) < N && Math . abs ( coll ) < M && Math . abs ( colr ) < M ) { return true ; } return false ; }
int countOnes ( int arr [ ] , int N ) { for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i ; j <= N ; j ++ ) { if ( j % i == 0 ) { if ( arr [ j - 1 ] == 0 ) { } else { } } } } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) { } } return count ; }
long power ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int findSum ( int num ) { int sumo = 0 ; int sume = 0 ; int x = 1 ; int cur = 0 ; int ans = 0 ; while ( num > 0 ) { int inc = Math . min ( x , num ) ; num -= inc ; if ( cur == 0 ) { ans = ans + sumodd ( sumo + inc ) - sumodd ( sumo ) ; sumo += inc ; } else { ans = ans + sumeven ( sume + inc ) - sumeven ( sume ) ; sume += inc ; } x *= 2 ; cur ^= 1 ; } return ans ; }
float noOfYears ( int t1 , int n1 , int t2 ) { float years = ( ( t2 - 1 ) * n1 / ( float ) ( t1 - 1 ) ) ; return years ; }
boolean isPossible ( int n ) { int fac [ ] = new int [ 10 ] ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( int i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; int sum = 0 ; int x = n ; while ( x != 0 ) { sum += fac [ x % 10 ] ; x /= 10 ; } if ( sum % n == 0 ) return true ; return false ; }
int countSquares ( int r , int c , int m ) { int squares = 0 ; for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) { if ( Math . max ( Math . abs ( i - r ) , Math . abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; }
int minOperations ( int n , int m ) { if ( m % n != 0 ) return - 1 ; int minOperations = 0 ; int q = m / n ; while ( q % 2 == 0 ) { q = q / 2 ; minOperations ++ ; } while ( q % 3 == 0 ) { q = q / 3 ; minOperations ++ ; } if ( q == 1 ) return minOperations ; return - 1 ; }
int getCount ( int a , int b , int c ) { int count = 0 ; for ( int i = 1 ; i <= 81 ; i ++ ) { int cr = b * ( int ) Math . pow ( i , a ) + c ; int tmp = cr ; int sm = 0 ; while ( tmp != 0 ) { sm += tmp % 10 ; tmp /= 10 ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; }
boolean checkSpecialPrime ( boolean [ ] sieve , int num ) { while ( num > 0 ) { if ( sieve [ num ] ) { return false ; } num /= 10 ; } return true ; }
boolean canTakeDown ( int bishopX , int bishopY , int pawnX , int pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }
boolean isPossible ( int n , int k , int arr [ ] ) { int sum = arr [ 0 ] ; int maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = Math . max ( maxVal , arr [ i ] ) ; } if ( ( float ) maxVal > ( float ) ( sum + k ) / n ) return false ; return true ; }
boolean checkTriangularSumRepresentation ( int n ) { HashSet < Integer > tri = new HashSet < > ( ) ; int i = 1 ; while ( true ) { int x = i * ( i + 1 ) / 2 ; if ( x >= n ) { break ; } tri . add ( x ) ; i ++ ; } for ( Integer tm : tri ) { if ( tri . contains ( n - tm ) && ( n - tm ) != ( int ) tri . toArray ( ) [ tri . size ( ) - 1 ] ) { return true ; } } return false ; }
void secondary_polygon ( int Angle ) { int edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { int edges_max_secondary = edges_primary / 2 ; System . out . println ( edges_max_secondary + 3 ) ; } else System . out . println ( "Not Possible" ) ; }
float CPwithProfit ( int sellingPrice , int profit ) { float costPrice ; costPrice = ( sellingPrice * 100 ) / ( 100 + profit ) ; return costPrice ; }
int removeZero ( int n ) { int res = 0 ; int d = 1 ; while ( n > 0 ) { if ( n % 10 != 0 ) { res += ( n % 10 ) * d ; d *= 10 ; } n /= 10 ; } return res ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void ETF ( ) { for ( int i = 1 ; i <= n ; i ++ ) { phi [ i ] = i ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( phi [ i ] == i ) { phi [ i ] = i - 1 ; for ( int j = 2 * i ; j <= n ; j += i ) { phi [ j ] = ( phi [ j ] * ( i - 1 ) ) / i ; } } } }
boolean checkIsHP ( double [ ] arr ) { int n = arr . length ; if ( n == 1 ) return true ; ArrayList < Integer > rec = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) rec . add ( ( int ) ( 1 / arr [ i ] ) ) ; Collections . sort ( rec ) ; int d = ( int ) rec . get ( 1 ) - ( int ) rec . get ( 0 ) ; for ( int i = 2 ; i < n ; i ++ ) if ( rec . get ( i ) - rec . get ( i - 1 ) != d ) return false ; return true ; }
int Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; }
int solve ( int n , int base ) { int sum = 0 ; while ( n > 0 ) { int remainder = n % base ; sum += remainder ; n = n / base ; } return sum ; }
void SieveOfEratosthenes ( boolean prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
int findEle ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return - 1 ; }
boolean divisibleBy3 ( String number ) { int sumOfDigit = 0 ; for ( int i = 0 ; i < number . length ( ) ; i ++ ) sumOfDigit += number . charAt ( i ) - '0' ; if ( sumOfDigit % 3 == 0 ) return true ; return false ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
int largestNumber ( int n ) { String s = "" ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( ( int ) ( s . charAt ( i ) - '0' ) % 2 & 1 ) == 0 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; int num = 0 ; for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( int ) ( s . charAt ( i ) - '0' ) ; num = num * 10 + ( ( int ) s . charAt ( index ) - ( int ) ( '0' ) - 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 + 9 ; return num ; }
void Sum_upto_nth_Term ( int n ) { int r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; System . out . println ( r ) ; }
int get_unit_digit ( int N ) { if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ; return 3 ; }
void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ MAX ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { product = product * p ; s . add ( product + 1 ) ; } } }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
long findF_N ( long n ) { long ans = 0 ; for ( long i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * ( n - i - 1 ) ; return ans ; }
Vector < Integer > PrimeFactors ( int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; int x = n ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( x % i == 0 ) { v . add ( i ) ; while ( x % i == 0 ) x /= i ; } } if ( x > 1 ) v . add ( x ) ; return v ; }
void computeSemiPrime ( ) { for ( int i = 0 ; i < MAX ; i ++ ) sprime [ i ] = false ; for ( int i = 2 ; i < MAX ; i ++ ) { int cnt = 0 ; int num = i ; for ( int j = 2 ; cnt < 2 && j * j <= num ; ++ j ) { while ( num % j == 0 ) { num /= j ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; if ( cnt == 2 ) { sprime [ i ] = true ; arr . add ( i ) ; } } }
double sumProductDifference ( int a , int b , int c , int d , int e ) { double rootSum = ( double ) ( - 1 * b ) / a ; double rootProduct = ( double ) e / a ; return Math . abs ( rootSum - rootProduct ) ; }
double findAnglesA ( double a , double b , double c ) { double A = Math . acos ( ( b * b + c * c - a * a ) / ( 2 * b * c ) ) ; return A * 180 / PI ; }
double findAnglesB ( double a , double b , double c ) { double B = Math . acos ( ( a * a + c * c - b * b ) / ( 2 * a * c ) ) ; return B * 180 / PI ; }
boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
int findSum ( int N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }
boolean isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = Math . log ( a ) / Math . log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; }
int mostFrequent ( int arr [ ] , int n ) { Map < Integer , Integer > hp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int key = arr [ i ] ; if ( hp . containsKey ( key ) ) { int freq = hp . get ( key ) ; freq ++ ; hp . put ( key , freq ) ; } else { hp . put ( key , 1 ) ; } } int max_count = 0 , res = - 1 ; for ( Entry < Integer , Integer > val : hp . entrySet ( ) ) { if ( max_count < val . getValue ( ) ) { res = val . getKey ( ) ; max_count = val . getValue ( ) ; } } return res ; }
int Profit ( int costPrice , int sellingPrice ) { int profit = ( sellingPrice - costPrice ) ; return profit ; }
int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; }
boolean isPrime ( int num ) { if ( num < 2 num % 2 == 0 ) return num == 2 ; for ( int i = 3 ; i * i <= num ; i += 2 ) if ( num % i == 0 ) return false ; return true ; }
void value ( int a , int b , int c ) { int co = 0 , p = 0 ; int no , r = 0 , x = 0 , q = 0 , w = 0 ; Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 1 ; i < 82 ; i ++ ) { no = ( int ) Math . pow ( i , a ) ; no = b * no + c ; if ( no > 0 && no < 1000000000 ) { x = getsum ( no ) ; if ( x == i ) { q ++ ; v . add ( no ) ; w ++ ; } } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { System . out . print ( v . get ( i ) + " " ) ; } }
int countOddSum ( int ar [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int val = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }
void printSeries ( int n ) { long prev = 0 ; long curr ; for ( int i = 1 ; i <= n ; i ++ ) { curr = findTriangularNumber ( i ) ; curr = curr + prev ; System . out . print ( curr + " " ) ; prev = curr ; } }
int rev ( int n , int temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( n / 10 , temp ) ; }
double determinantOfMatrix ( double mat [ ] [ ] ) { double ans ; ans = mat [ 0 ] [ 0 ] * ( mat [ 1 ] [ 1 ] * mat [ 2 ] [ 2 ] - mat [ 2 ] [ 1 ] * mat [ 1 ] [ 2 ] ) - mat [ 0 ] [ 1 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 2 ] - mat [ 1 ] [ 2 ] * mat [ 2 ] [ 0 ] ) + mat [ 0 ] [ 2 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 1 ] - mat [ 1 ] [ 1 ] * mat [ 2 ] [ 0 ] ) ; return ans ; }
int calculateSeries ( int n ) { return 2 + ( n * n + n - 2 ) * factorial ( n + 1 ) ; }
boolean isEmirpimes ( int n ) { if ( checkSemiprime ( n ) == false ) return false ; int r = 0 ; for ( int t = n ; t != 0 ; t = t / n ) r = r * 10 + t % 10 ; if ( r == n ) return false ; return ( checkSemiprime ( r ) ) ; }
int isTriangular ( int num ) { if ( num < 0 ) return 0 ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return - 1 ; double root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; double root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( ( int ) ( root1 ) > 0 && ( int ) ( Math . floor ( root1 ) ) == ( int ) ( root1 ) ) return ( int ) ( root1 ) ; if ( ( int ) ( root2 ) > 0 && ( int ) ( Math . floor ( root2 ) ) == ( int ) ( root2 ) ) return ( int ) ( root2 ) ; return - 1 ; }
double calculateProbability ( int N ) { double probability = ( double ) N / ( N + 1 ) ; return probability ; }
int fnMod ( int n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; }
int findHcf ( int [ ] [ ] arr , int size ) { int ans = arr [ 0 ] [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) ans = gcd ( ans , arr [ i ] [ 0 ] ) ; return ( ans ) ; }
int nthTrimorphic ( int n ) { int count = 0 ; for ( int i = 0 ; i < INT_MAX ; i ++ ) { if ( checkTrimorphic ( i ) ) count ++ ; if ( count == n ) return i ; } return - 1 ; }
boolean check ( int n ) { int m = n ; while ( n != 0 ) { int r = n % 10 ; if ( r > 0 ) if ( ( m % r ) != 0 ) return false ; n /= 10 ; } return true ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; }
void generatePrimeFactors ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } }
void quadrant ( int x , int y ) { if ( x > 0 && y > 0 ) System . out . println ( "lies in First quadrant" ) ; else if ( x < 0 && y > 0 ) System . out . println ( "lies in Second quadrant" ) ; else if ( x < 0 && y < 0 ) System . out . println ( "lies in Third quadrant" ) ; else if ( x > 0 && y < 0 ) System . out . println ( "lies in Fourth quadrant" ) ; else if ( x == 0 && y > 0 ) System . out . println ( "lies at positive y axis" ) ; else if ( x == 0 && y < 0 ) System . out . println ( "lies at negative y axis" ) ; else if ( y == 0 && x < 0 ) System . out . println ( "lies at negative x axis" ) ; else if ( y == 0 && x > 0 ) System . out . println ( "lies at positive x axis" ) ; else System . out . println ( "lies at origin" ) ; }
int kthgroupsum ( int k ) { return k * k * k ; }
double kmphTOmph ( double kmph ) { return 0.6214 * kmph ; }
void point ( int a , int b , int c , int d , int n ) { int x , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x = b + i * a ; if ( ( x - d ) % c == 0 && x - d >= 0 ) { System . out . println ( x ) ; flag = 1 ; break ; } } if ( flag == 0 ) { System . out . println ( "No collision point" ) ; } }
int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; }
int isPalindrome ( int n ) { int divide = ( isOctal ( n ) == 0 ) ? 8 : 10 ; int octal [ ] = new int [ MAX_DIGITS ] ; int i = 0 ; while ( n != 0 ) { octal [ i ++ ] = n % divide ; n = n / divide ; } for ( int j = i - 1 , k = 0 ; k <= j ; j -- , k ++ ) if ( octal [ j ] != octal [ k ] ) return 0 ; return 1 ; }
boolean isThreeDisctFactors ( long n ) { int sq = ( int ) Math . sqrt ( n ) ; if ( 1L * sq * sq != n ) return false ; return isPrime ( sq ) ? true : false ; }
void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( hexaDeciNum [ j ] ) ; }
int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; }
long firstkdigits ( int n , int k ) { long product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product *= n ; while ( ( int ) ( product / Math . pow ( 10 , k ) ) != 0 ) product = product / 10 ; return product ; }
int countDigits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n / 10 ; } return count ; }
void printGenerators ( int n ) { System . out . println ( "1 " ) ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) System . out . println ( i + " " ) ; }
long SubArraySum ( int arr [ ] , int n ) { long result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; }
void generateNumbers ( int factor [ ] , int n , int k ) { int next [ ] = new int [ k ] ; for ( int i = 0 ; i < n ; ) { int toincrement = 0 ; for ( int j = 0 ; j < k ; j ++ ) if ( next [ j ] < next [ toincrement ] ) toincrement = j ; if ( output != next [ toincrement ] ) { output = next [ toincrement ] ; System . out . print ( next [ toincrement ] + " " ) ; i ++ ; } next [ toincrement ] += factor [ toincrement ] ; } }
int sumofproduct ( int n ) { int ans = 0 ; for ( int x = 1 ; x <= n ; x ++ ) { int y = n / x ; ans += ( y * x ) ; } return ans ; }
void findPrimePair ( int n ) { boolean isPrime [ ] = new boolean [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime [ i ] && isPrime [ n - i ] ) { System . out . print ( i + " " + ( n - i ) ) ; return ; } } }
long lcm ( long n ) { long ans = 1 ; for ( long i = 1 ; i <= n ; i ++ ) ans = ( ans * i ) / ( gcd ( ans , i ) ) ; return ans ; }
void findSmallestPrimeFactors ( ) { for ( int i = 0 ; i < maxn ; i ++ ) smallest_prime [ i ] = INF ; for ( int i = 2 ; i < maxn ; i ++ ) { if ( smallest_prime [ i ] == INF ) { smallest_prime [ i ] = i ; for ( int j = i * i ; j < maxn ; j += i ) if ( smallest_prime [ j ] > i ) smallest_prime [ j ] = i ; } } }
void prepareSum ( String s ) { sum [ 0 ] = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum [ i + 1 ] = sum [ i ] + toInt ( s . charAt ( i ) ) ; } }
boolean oneDigit ( int num ) { return ( num >= 0 && num < 10 ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
void updateBIT ( int BITree [ ] , int n , int index , int val ) { while ( index <= n ) { BITree [ index ] += val ; index += index & ( - index ) ; } }
int nearestSmallerEqFib ( int n ) { if ( n == 0 n == 1 ) return n ; int f1 = 0 , f2 = 1 , f3 = 1 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; }
int mod ( String num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num . charAt ( i ) - '0' ) % a ; return res ; }
int replace0with5 ( int number ) { return number += calculateAddedValue ( number ) ; }
int findXOR ( int X ) { int ans = 0 ; while ( X != 0 ) { ans ^= ( X % 10 ) ; X /= 10 ; } return ans ; }
int findLen ( int arr [ ] , int n , int m ) { Vector < Integer > filter = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] m ) == m ) filter . add ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_or = filter . get ( 0 ) ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_or |= filter . get ( i ) ; if ( c_or == m ) return filter . size ( ) ; return 0 ; }
void Add_Edge ( int x , int y ) { al [ x ] . add ( y ) ; root_node [ y ] = false ; }
long multiplyByFifteen ( long n ) { long prod = ( n << 4 ) ; prod = prod - n ; return prod ; }
int ternary ( int number ) { int ans = 0 , rem = 1 , base = 1 ; while ( number > 0 ) { rem = number % 3 ; ans = ans + rem * base ; number = ( int ) ( number / 3 ) ; base = base * 10 ; } return ans ; }
void ReplaceElements ( int arr [ ] , int n ) { int X = 0 ; for ( int i = 0 ; i < n ; ++ i ) { X ^= arr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = X ^ arr [ i ] ; } }
int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , startindex = 0 ; int endindex = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) System . out . println ( "No such subarray" ) ; else System . out . println ( startindex + " to " + endindex ) ; return maxsize ; }
int BinaryLifting ( int [ ] presum , int n , int x ) { int pos = 0 ; int LOGN = ( int ) Math . log ( n ) ; if ( x <= presum [ 0 ] ) return 0 ; for ( int i = LOGN ; i >= 0 ; i -- ) { if ( pos + ( 1 << i ) < n && presum [ pos + ( 1 << i ) ] < x ) { pos += ( 1 << i ) ; } } return pos + 1 ; }
int setbitsfromLtoR ( int L , int R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; }
boolean isFibbinaryNum ( int n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; }
int oddbitsetnumber ( int n ) { int count = 0 ; int res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
int posOfRightmostSetBit ( int n ) { return ( int ) ( Math . log ( n & - n ) / Math . log ( 2 ) ) + 1 ; }
int modifyBit ( int n , int p , int b ) { int mask = 1 << p ; return ( n & ~ mask ) | ( ( b << p ) & mask ) ; }
boolean isOnesComplementOfOther ( long a , long b ) { return areAllBitsSet ( a ^ b ) ; }
int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; }
int posOfRightMostSameBit ( int m , int n ) { int loopCounter = 1 ; while ( m > 0 n > 0 ) { boolean a = m % 2 == 1 ; boolean b = n % 2 == 1 ; if ( ! ( a ^ b ) ) { return loopCounter ; } m = m >> 1 ; n = n >> 1 ; loopCounter ++ ; } return - 1 ; }
int CountZeroBit ( int n ) { int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) != 0 ) count ++ ; n >>= 1 ; } return count ; }
long countPairsWithKDiff ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int xoredNum = arr [ i ] ^ arr [ j ] ; if ( k == bitCount ( xoredNum ) ) ++ ans ; } } return ans ; }
int countTrailingZero ( int x ) { int lookup [ ] = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; }
int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }
int findXOR ( int Set [ ] , int n ) { if ( n == 1 ) return Set [ 0 ] ; else return 0 ; }
int findFourElements ( int [ ] arr , int n ) { HashMap < Integer , Indexes > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { map . put ( arr [ i ] + arr [ j ] , new Indexes ( i , j ) ) ; } } int d = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ; if ( map . containsKey ( abs_diff ) ) { Indexes indexes = map . get ( abs_diff ) ; if ( indexes . getI ( ) != i && indexes . getI ( ) != j && indexes . getJ ( ) != i && indexes . getJ ( ) != j ) { d = Math . max ( d , Math . max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; }
void recaman ( int n ) { if ( n <= 0 ) return ; System . out . printf ( "%d, " , 0 ) ; HashSet < Integer > s = new HashSet < Integer > ( ) ; s . add ( 0 ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || s . contains ( curr ) ) curr = prev + i ; s . add ( curr ) ; System . out . printf ( "%d, " , curr ) ; prev = curr ; } }
int findMin ( int arr [ ] , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; }
void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
void printSmall ( int arr [ ] , int n , int k ) { for ( int i = k ; i < n ; ++ i ) { int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } } if ( max_var > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }
int upperIndex ( int arr [ ] , int n , int y ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] <= y ) l = mid + 1 ; else h = mid - 1 ; } return h ; }
void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " " ) ; System . out . println ( "" ) ; }
int findPeakUtil ( int arr [ ] , int low , int high , int n ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ; else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return findPeakUtil ( arr , low , ( mid - 1 ) , n ) ; else return findPeakUtil ( arr , ( mid + 1 ) , high , n ) ; }
int maximum ( int a , int b , int c ) { return Math . max ( Math . max ( a , b ) , c ) ; }
void printClosest ( int arr [ ] , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } System . out . println ( " The closest pair is " + arr [ res_l ] + " and " + arr [ res_r ] ) ; }
boolean findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; boolean [ ] part = new boolean [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = false ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ sum / 2 ] ; }
void solveWordWrap ( int l [ ] , int n , int M ) { int extras [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; int lc [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; int c [ ] = new int [ n + 1 ] ; int p [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { extras [ i ] [ i ] = M - l [ i - 1 ] ; for ( int j = i + 1 ; j <= n ; j ++ ) extras [ i ] [ j ] = extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( extras [ i ] [ j ] < 0 ) lc [ i ] [ j ] = MAX ; else if ( j == n && extras [ i ] [ j ] >= 0 ) lc [ i ] [ j ] = 0 ; else lc [ i ] [ j ] = extras [ i ] [ j ] * extras [ i ] [ j ] ; } } c [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { c [ j ] = MAX ; for ( int i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != MAX && lc [ i ] [ j ] != MAX && ( c [ i - 1 ] + lc [ i ] [ j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; }
int optCost ( int freq [ ] , int i , int j ) { if ( j < i ) return 0 ; if ( j == i ) return freq [ i ] ; int fsum = sum ( freq , i , j ) ; int min = Integer . MAX_VALUE ; for ( int r = i ; r <= j ; ++ r ) { int cost = optCost ( freq , i , r - 1 ) + optCost ( freq , r + 1 , j ) ; if ( cost < min ) min = cost ; } return min + fsum ; }
int minCoins ( int coins [ ] , int m , int V ) { if ( V == 0 ) return 0 ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }
int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; }
int maximumNumberDistinctPrimeRange ( int m , int n ) { long factorCount [ ] = new long [ n + 1 ] ; boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( int j = i * 2 ; j <= n ; j += i ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } } int max = ( int ) factorCount [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = ( int ) factorCount [ i ] ; num = i ; } } return num ; }
int getSingle ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & x ) == 0 ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; }
int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { boolean k = false ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { if ( k == true ) ans += 1 ; else ans += 0 ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
int swapBits ( int x , int p1 , int p2 , int n ) { int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; int result = x ^ xor ; return result ; }
int minSwaps ( int n , int pairs [ ] , int arr [ ] ) { int index [ ] = new int [ 2 * n + 1 ] ; for ( int i = 1 ; i <= 2 * n ; i ++ ) index [ arr [ i ] ] = i ; return minSwapsUtil ( arr , pairs , index , 1 , 2 * n ) ; }
int maxOfSegmentMins ( int [ ] a , int n , int k ) { if ( k == 1 ) { Arrays . sort ( a ) ; return a [ 0 ] ; } if ( k == 2 ) return Math . max ( a [ 0 ] , a [ n - 1 ] ) ; return a [ n - 1 ] ; }
int MinOperation ( int a [ ] , int b [ ] , int n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; }
void findMissing ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { if ( M != N - 1 && N != M - 1 ) { System . out . println ( "Invalid Input" ) ; return ; } int res = 0 ; for ( int i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( int i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; System . out . println ( "Missing element is " + res ) ; }
long calculate ( long a [ ] , int n ) { Arrays . sort ( a ) ; int i , j ; Vector < Long > s = new Vector < > ( ) ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . add ( ( a [ i ] + a [ j ] ) ) ; long mini = Collections . min ( s ) ; long maxi = Collections . max ( s ) ; return Math . abs ( maxi - mini ) ; }
long findMinSum ( long a [ ] , long b [ ] , long n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; }
void push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; head = head_ref ; }
void fun ( int arr [ ] , int k ) { int n = 4 - 1 ; int v = n - k ; if ( v >= 0 ) { reverse ( arr , 0 , v ) ; reverse ( arr , v + 1 , n ) ; reverse ( arr , 0 , n ) ; } }
void rotateSubList ( ListNode A , int m , int n , int k ) { int size = n - m + 1 ; if ( k > size ) { k = k % size ; } if ( k == 0 k == size ) { ListNode head = A ; while ( head != null ) { System . out . print ( head . data ) ; head = head . next ; } return ; } ListNode link = null ; if ( m == 1 ) { link = A ; } ListNode c = A ; int count = 0 ; ListNode end = null ; ListNode pre = null ; while ( c != null ) { count ++ ; if ( count == m - 1 ) { pre = c ; link = c . next ; } if ( count == n - k ) { if ( m == 1 ) { end = c ; A = c . next ; } else { end = c ; pre . next = c . next ; } } if ( count == n ) { ListNode d = c . next ; c . next = link ; end . next = d ; ListNode head = A ; while ( head != null ) { System . out . print ( head . data + " " ) ; head = head . next ; } return ; } c = c . next ; } }
void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void createHash ( HashSet < Integer > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } }
int solve ( int n , int m ) { int ans = n * ( m / 2 ) ; if ( m % 2 == 1 ) { ans += ( n + 1 ) / 2 ; } return ans ; }
int rangeXor ( int BITree [ ] , int l , int r ) { return getXOR ( BITree , r ) ^ getXOR ( BITree , l - 1 ) ; }
int query ( int L , int R ) { if ( L == 0 ) return prefix [ R ] ; return prefix [ R ] - prefix [ L - 1 ] ; }
void game ( int [ ] v , int n ) { HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m . containsKey ( v [ i ] ) ) m . put ( v [ i ] , 1 ) ; else m . replace ( v [ i ] , m . get ( v [ i ] ) + 1 ) ; } int count = 0 ; int check = 0 ; for ( Map . Entry < Integer , Integer > i : m . entrySet ( ) ) { if ( i . getValue ( ) > 1 ) { if ( i . getValue ( ) >= 4 && i . getValue ( ) % 2 == 0 ) check ++ ; count ++ ; } } boolean flag ; if ( check % 2 != 0 ) flag = false ; if ( check % 2 != 0 ) System . out . println ( "Yes" ) ; else if ( n % 2 == 0 && count % 2 == 0 ) System . out . println ( "No" ) ; else System . out . println ( "Yes" ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < N ; i ++ ) prime [ i ] = 1 ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * p ; i < N ; i += p ) prime [ i ] = 0 ; } } }
int fact ( int n ) { return factTR ( n , 1 ) ; }
int maximumMedian ( int arr [ ] [ ] , int N , int K ) { int low = 0 , high = ( int ) 1e9 ; while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( isMaximumMedian ( arr , N , K , mid ) ) { low = mid + 1 ; } else { high = mid ; } } return low ; }
void findMinDays ( int arr [ ] , int R [ ] , int N , int X , int K ) { int low = 0 , high = X ; int minDays = - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int temp = arr [ i ] + R [ i ] * mid ; if ( temp >= K ) { sum += temp ; } } if ( sum >= X ) { minDays = mid ; high = mid - 1 ; } else { low = mid + 1 ; } } System . out . println ( minDays ) ; }
void maximumIndices ( int arr [ ] , int N ) { int [ ] temp = new int [ N ] ; int maxIndices = ( N - 1 ) / 2 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < maxIndices ; i ++ ) { temp [ 2 * i + 1 ] = arr [ i ] ; } int j = 0 ; for ( int i = maxIndices ; i < N ; ) { if ( temp [ j ] == 0 ) { temp [ j ] = arr [ i ] ; i ++ ; } j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( temp [ i ] + " " ) ; } }
boolean check ( int n , int m , int x , int y , int vl ) { int temp = m ; if ( vl > n ) return false ; int ex = n - vl ; ex *= y ; temp += ex ; int cr = temp / x ; if ( cr >= vl ) return true ; return false ; }
void findPoint ( int arr [ ] , int N , int K ) { int left ; if ( N % 2 != 0 ) { left = arr [ N / 2 ] ; } else { left = arr [ N / 2 - 1 ] + 1 ; } int right = arr [ N - 1 ] ; while ( left <= right ) { int mid = ( left + right ) / 2 ; int temp = findSum ( arr , N , mid ) ; if ( temp == K ) { System . out . println ( mid ) ; return ; } else if ( K < temp ) { right = mid - 1 ; } else { left = mid + 1 ; } } left = arr [ 0 ] ; right = arr [ N / 2 ] - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; int temp = findSum ( arr , N , mid ) ; if ( temp == K ) { System . out . println ( mid ) ; return ; } else if ( K > temp ) { right = mid - 1 ; } else { left = mid + 1 ; } } System . out . println ( "-1" ) ; }
int NthComposite ( int N ) { int MAX_SIZE = 1000005 ; boolean [ ] IsPrime = new boolean [ MAX_SIZE ] ; Arrays . fill ( IsPrime , true ) ; for ( int p = 2 ; p * p < MAX_SIZE ; p ++ ) { if ( IsPrime [ p ] == true ) { for ( int i = p * p ; i < MAX_SIZE ; i += p ) IsPrime [ i ] = false ; } } Vector < Integer > Composites = new Vector < Integer > ( ) ; for ( int p = 4 ; p < MAX_SIZE ; p ++ ) if ( ! IsPrime [ p ] ) Composites . add ( p ) ; return Composites . get ( N - 1 ) ; }
void printArray ( ArrayList < String > res ) { Collections . sort ( res ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) { System . out . print ( res . get ( i ) + " " ) ; } }
int minCount ( int A [ ] , int B [ ] , int N ) { int i = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] == B [ j ] ) { i ++ ; } } return N - i ; }
void minimumNumber ( int K , int X ) { if ( K > X ) { System . out . println ( "-1" ) ; return ; } int low = K , high = X , res = - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( isGreaterEqual ( mid , K , X ) ) { res = mid ; high = mid - 1 ; } else low = mid + 1 ; } System . out . println ( res ) ; }
int right_search ( ArrayList < Integer > A , int num ) { int low = 0 , high = A . size ( ) - 1 ; int ans = high ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( A . get ( mid ) <= num ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; }
int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
void prefixArr ( int arr [ ] , int prefix [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 ) { prefix [ i ] [ 0 ] = arr [ i ] ; prefix [ i ] [ 1 ] = arr [ i ] ; } else { prefix [ i ] [ 0 ] = Math . max ( prefix [ i - 1 ] [ 0 ] , arr [ i ] ) ; prefix [ i ] [ 1 ] = Math . min ( prefix [ i - 1 ] [ 1 ] , arr [ i ] ) ; } } }
void Query ( int arr [ ] , int N , int [ ] [ ] Q ) { int tree [ ] = new int [ 4 * N ] ; build_seg_tree ( 0 , N - 1 , 0 , tree , arr ) ; for ( int i = 0 ; i < Q . length ; i ++ ) { if ( Q [ i ] [ 0 ] == 1 ) System . out . print ( query ( Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , 0 , N - 1 , 0 , tree ) + " " ) ; else update ( 0 , N - 1 , 0 , Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , tree , arr ) ; } }
void Sieve ( ) { index = 0 ; int p [ ] = new int [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) { p [ i ] = 1 ; } p [ 0 ] = p [ 1 ] = 0 ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( p [ i ] == 1 ) { for ( int j = i * i ; j <= N ; j += i ) { p [ j ] = 0 ; } } } for ( int i = 1 ; i < N ; i ++ ) { if ( p [ i ] == 1 ) { prime [ index ++ ] = ( int ) ( Math . pow ( i , 4 ) ) ; } } }
boolean isValidDigit ( int digit , int K ) { while ( K != 0 ) { if ( K % 10 == digit ) { return true ; } K = K / 10 ; } return false ; }
void update ( int index , int s , int e , int new_val , int pos ) { if ( s == e ) Tree [ index ] = new_val ; else { int m = ( s + e ) / 2 ; if ( pos <= m ) { update ( 2 * index , s , m , new_val , pos ) ; } else { update ( 2 * index + 1 , m + 1 , e , new_val , pos ) ; } Tree [ index ] = Math . max ( Tree [ 2 * index ] , Tree [ 2 * index + 1 ] ) ; } }
void printAnswer ( int N , int [ ] [ ] edges ) { for ( int i = 0 ; i <= N ; i ++ ) { parent [ i ] = i ; } for ( int i = 0 ; i < edges . length ; i ++ ) { connect ( edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; } connectedComponents ( N ) ; }
void countNumbers ( int n , int d ) { int total = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int x = i ; while ( x > 0 ) { if ( x % 8 == d ) { total ++ ; break ; } x = x / 8 ; } } System . out . println ( total ) ; }
int smallestLeft ( int arr [ ] , int total , int sum , int i , int [ ] [ ] dp ) { if ( i == 0 ) { return Math . abs ( total - 2 * sum ) ; } if ( dp [ i ] [ sum ] != - 1 ) return dp [ i ] [ sum ] ; int X = smallestLeft ( arr , total , sum + arr [ i - 1 ] , i - 1 , dp ) ; int Y = smallestLeft ( arr , total , sum , i - 1 , dp ) ; return dp [ i ] [ sum ] = Math . min ( X , Y ) ; }
void findWordsSameRow ( List < String > arr ) { Map < Character , Integer > mp = new HashMap < Character , Integer > ( ) ; mp . put ( 'q' , 1 ) ; mp . put ( 'w' , 1 ) ; mp . put ( 'e' , 1 ) ; mp . put ( 'r' , 1 ) ; mp . put ( 't' , 1 ) ; mp . put ( 'y' , 1 ) ; mp . put ( 'u' , 1 ) ; mp . put ( 'i' , 1 ) ; mp . put ( 'o' , 1 ) ; mp . put ( 'p' , 1 ) ; mp . put ( 'a' , 2 ) ; mp . put ( 's' , 2 ) ; mp . put ( 'd' , 2 ) ; mp . put ( 'f' , 2 ) ; mp . put ( 'g' , 2 ) ; mp . put ( 'h' , 2 ) ; mp . put ( 'j' , 2 ) ; mp . put ( 'k' , 2 ) ; mp . put ( 'l' , 2 ) ; mp . put ( 'z' , 3 ) ; mp . put ( 'x' , 3 ) ; mp . put ( 'c' , 3 ) ; mp . put ( 'v' , 3 ) ; mp . put ( 'b' , 3 ) ; mp . put ( 'n' , 3 ) ; mp . put ( 'm' , 3 ) ; for ( String word : arr ) { if ( word . length ( ) != 0 ) { boolean flag = true ; int rowNum = mp . get ( Character . toLowerCase ( word . charAt ( 0 ) ) ) ; int M = word . length ( ) ; for ( int i = 1 ; i < M ; i ++ ) { if ( mp . get ( Character . toLowerCase ( word . charAt ( i ) ) ) != rowNum ) { flag = false ; break ; } } if ( flag ) { System . out . print ( word + " " ) ; } } } }
int countSubsequece ( int a [ ] , int n ) { int i , j , k , l ; int answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; }
int countSubsequence ( int a [ ] , int n ) { int i , j ; fill_counts ( a , n ) ; int answer = 0 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n - 1 ; j ++ ) { answer += lcount [ a [ j ] ] [ i - 1 ] * rcount [ a [ i ] ] [ j + 1 ] ; } } return answer ; }
int MincntBothPalin ( char [ ] str1 , char [ ] str2 , int N ) { int i = 0 ; int j = N - 1 ; int cntOp = 0 ; while ( i < j ) { if ( str1 [ i ] == str1 [ j ] && str2 [ i ] != str2 [ j ] ) { cntOp += 1 ; } else if ( str1 [ i ] != str1 [ j ] && str2 [ i ] == str2 [ j ] ) { cntOp += 1 ; } else if ( str1 [ i ] != str1 [ j ] && str2 [ i ] != str2 [ j ] ) { if ( str1 [ i ] == str2 [ j ] && str2 [ i ] == str1 [ j ] ) { cntOp += 1 ; } else { cntOp += 2 ; } } i += 1 ; j -= 1 ; } return cntOp ; }
boolean isValid ( int wood [ ] , int N , int len , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { count += wood [ i ] / len ; } return count >= K ; }
boolean isMorannumber ( int n ) { int dup = n ; int sum = digiSum ( dup ) ; if ( n % sum == 0 ) { int c = n / sum ; if ( isPrime ( c ) ) { return true ; } } return false ; }
int maxEqualIdx ( int [ ] arr , int k ) { Arrays . sort ( arr ) ; int [ ] prefixSum = new int [ arr . length + 1 ] ; prefixSum [ 1 ] = arr [ 0 ] ; for ( int i = 1 ; i < prefixSum . length - 1 ; ++ i ) { prefixSum [ i + 1 ] = prefixSum [ i ] + arr [ i ] ; } int max = arr . length ; int min = 1 ; int ans = 1 ; while ( min <= max ) { int mid = ( max + min ) / 2 ; if ( check ( prefixSum , mid , k , arr ) ) { ans = mid ; min = mid + 1 ; } else { max = mid - 1 ; } } return ans ; }
boolean sfpa ( int V , int src , int Edges [ ] [ ] , int M ) { Vector < pair > [ ] g = new Vector [ V ] ; for ( int i = 0 ; i < V ; i ++ ) { g [ i ] = new Vector < pair > ( ) ; } for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i ] [ 0 ] ; int v = Edges [ i ] [ 1 ] ; int w = Edges [ i ] [ 2 ] ; g [ u ] . add ( new pair ( v , w ) ) ; } int [ ] dist = new int [ V ] ; Arrays . fill ( dist , Integer . MAX_VALUE ) ; boolean [ ] inQueue = new boolean [ V ] ; int [ ] cnt = new int [ V ] ; dist [ src ] = 0 ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( src ) ; inQueue [ src ] = true ; while ( ! q . isEmpty ( ) ) { int u = q . peek ( ) ; q . remove ( ) ; inQueue [ u ] = false ; for ( pair x : g [ u ] ) { int v = x . first ; int cost = x . second ; if ( dist [ v ] > dist [ u ] + cost ) { dist [ v ] = dist [ u ] + cost ; if ( ! inQueue [ v ] ) { q . add ( v ) ; inQueue [ v ] = true ; cnt [ v ] ++ ; if ( cnt [ v ] >= V ) return true ; } } } } return false ; }
int countNum ( int N , int sum , int K , int st , int dp [ ] [ ] [ ] ) { if ( N == 0 && sum == 0 ) { return 1 ; } if ( N < 0 ) { return 0 ; } if ( dp [ N ] [ sum ] [ st ] != - 1 ) { return dp [ N ] [ sum ] [ st ] ; } int res = 0 ; int start = st == 1 ? 0 : 1 ; for ( int i = start ; i <= 9 ; i ++ ) { res += countNum ( N - 1 , ( sum + i ) % K , K , ( ( st i ) > 0 ) ? 1 : 0 , dp ) ; } return dp [ N ] [ sum ] [ st ] = res ; }
int hIndex ( int [ ] citations , int n ) { int hindex = 0 ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( citations [ mid ] >= ( mid + 1 ) ) { low = mid + 1 ; hindex = mid + 1 ; } else { high = mid - 1 ; } } System . out . println ( hindex ) ; return hindex ; }
int countNodes ( int V , int E , int src , int dest , int edges [ ] [ ] ) { Vector < Integer > [ ] adj = new Vector [ V + 1 ] ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < E ; i ++ ) { adj [ edges [ i ] [ 0 ] ] . add ( edges [ i ] [ 1 ] ) ; adj [ edges [ i ] [ 1 ] ] . add ( edges [ i ] [ 0 ] ) ; } int vis [ ] = new int [ V + 1 ] ; int count = dfs ( src , dest , vis , adj ) ; return count - 2 ; }
int longestGP ( int A [ ] , int N ) { if ( N < 2 ) return N ; int length = 1 , common_ratio = 1 ; int maxlength = 1 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i + 1 ] % A [ i ] == 0 ) { if ( A [ i + 1 ] / A [ i ] == common_ratio ) { length = length + 1 ; maxlength = Math . max ( maxlength , length ) ; } else { common_ratio = A [ i + 1 ] / A [ i ] ; length = 2 ; } } else { maxlength = Math . max ( maxlength , length ) ; length = 1 ; } } maxlength = Math . max ( maxlength , length ) ; return maxlength ; }
void add_seg ( int seg [ ] , int start , int end , int current , int index ) { if ( index > end index < start ) return ; if ( start == end ) { seg [ current ] = 1 ; return ; } int mid = ( start + end ) / 2 ; add_seg ( seg , start , mid , 2 * current + 1 , index ) ; add_seg ( seg , mid + 1 , end , 2 * current + 2 , index ) ; seg [ current ] = seg [ 2 * current + 1 ] + seg [ 2 * current + 2 ] ; }
int getPrefixLength ( String srcStr , String targetStr ) { if ( targetStr . length ( ) == 0 ) return 0 ; srcStr = srcStr . toLowerCase ( ) ; targetStr = targetStr . toLowerCase ( ) ; HashMap < Character , Integer > dictCount = new HashMap < > ( ) ; int nUnique = 0 ; for ( char ch : targetStr . toCharArray ( ) ) { if ( dictCount . containsKey ( ch ) != true ) { nUnique += 1 ; dictCount . put ( ch , 0 ) ; } dictCount . replace ( ch , dictCount . get ( ch ) + 1 ) ; } for ( int i = 0 ; i < srcStr . length ( ) ; i ++ ) { char ch = srcStr . charAt ( i ) ; if ( dictCount . containsKey ( ch ) != true ) continue ; dictCount . replace ( ch , dictCount . get ( ch ) - 1 ) ; if ( dictCount . get ( ch ) == 0 ) nUnique -= 1 ; if ( nUnique == 0 ) return ( i + 1 ) ; } return - 1 ; }
int minOperations ( String S , int K ) { int ans = 0 ; for ( int i = 0 ; i < K ; i ++ ) { int zero = 0 , one = 0 ; for ( int j = i ; j < S . length ( ) ; j += K ) { if ( S . charAt ( j ) == '0' ) zero ++ ; else one ++ ; } ans += Math . min ( zero , one ) ; } return ans ; }
int func ( int A , int B , int C , int x ) { return ( A * x * x + B * x + C ) ; }
int minDays ( int [ ] arr , int n , int k ) { int l = arr . length , left = 1 , right = ( int ) 1e9 ; if ( n * k > l ) return - 1 ; while ( left < right ) { int mid = ( left + right ) / 2 , cnt = 0 , product = 0 ; for ( int j = 0 ; j < l ; ++ j ) { if ( arr [ j ] > mid ) { cnt = 0 ; } else if ( ++ cnt >= k ) { product ++ ; cnt = 0 ; } } if ( product < n ) { left = mid + 1 ; } else { right = mid ; } } return left ; }
int minimumMoves ( String s , int K ) { StringBuilder S = new StringBuilder ( s ) ; int N = S . length ( ) ; int ops = 0 ; int last_idx = - 1 ; for ( int i = 0 ; i < K ; i ++ ) { if ( S . charAt ( i ) == '1' ) last_idx = i ; } if ( last_idx == - 1 ) { ++ ops ; S . setCharAt ( K - 1 , '1' ) ; last_idx = K - 1 ; } for ( int i = 1 ; i < N - K + 1 ; i ++ ) { if ( last_idx < i ) last_idx = - 1 ; if ( S . charAt ( i + K - 1 ) == '1' ) last_idx = i + K - 1 ; if ( last_idx == - 1 ) { ++ ops ; S . setCharAt ( i + K - 1 , '1' ) ; last_idx = i + K - 1 ; } } return ops ; }
int missingElement ( int arr [ ] , int n ) { int max_ele = arr [ 0 ] ; int min_ele = arr [ 0 ] ; int x = 0 ; int d ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; if ( arr [ i ] < min_ele ) min_ele = arr [ i ] ; } d = ( max_ele - min_ele ) / n ; for ( int i = 0 ; i < n ; i ++ ) { x = x ^ arr [ i ] ; } for ( int i = 0 ; i <= n ; i ++ ) { x = x ^ ( min_ele + ( i * d ) ) ; } return x ; }
int longestPermutation ( int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } } int len = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! freq . containsKey ( i ) ) { break ; } len ++ ; } return len ; }
int findColor ( HashMap < Integer , Integer > mapWithColor , int query ) { int maximum = 0 ; while ( query >= 1 ) { if ( mapWithColor . containsKey ( query ) ) { maximum = Math . max ( maximum , mapWithColor . get ( query ) ) ; } if ( query % 2 == 1 ) query = ( query - 1 ) / 2 ; else query = query / 2 ; } return maximum ; }
int findlength ( String str , int n , int k ) { int maxLen = 0 ; int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { setZero ( freq ) ; for ( int j = i ; j < n ; j ++ ) { freq [ str . charAt ( j ) - 'a' ] ++ ; if ( atLeastK ( freq , k ) ) { maxLen = Math . max ( maxLen , j - i + 1 ) ; } } } return maxLen ; }
int maxSumArray ( int arr [ ] , int n ) { int sum = 0 ; Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } int minimum = Integer . MAX_VALUE ; for ( Map . Entry < Integer , Integer > x : m . entrySet ( ) ) minimum = Math . min ( minimum , x . getValue ( ) * x . getKey ( ) ) ; return ( sum - minimum ) ; }
void create_table ( int n ) { int pow = 1 ; int co = 0 ; do { pow <<= 1 ; lookup_table [ co ] = ( n + ( pow >> 1 ) ) / pow ; } while ( lookup_table [ co ++ ] != 0 ) ; }
int costToPanagram ( String str , int cost [ ] ) { int i , n = str . length ( ) ; int occurrences [ ] = new int [ 26 ] ; for ( i = 0 ; i < n ; i ++ ) occurrences [ str . charAt ( i ) - 'a' ] ++ ; int gain = 0 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( occurrences [ i ] == 0 ) gain -= ( 2 * cost [ i ] ) ; else if ( occurrences [ i ] > 1 ) gain += ( cost [ i ] * ( occurrences [ i ] - 1 ) ) ; } if ( gain >= 0 ) return 0 ; return ( gain * - 1 ) ; }
int strScore ( String str [ ] , String s , int n ) { HashMap < String , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) m . put ( str [ i ] , i + 1 ) ; if ( ! m . containsKey ( s ) ) return 0 ; int score = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) score += s . charAt ( i ) - 'a' + 1 ; score = score * m . get ( s ) ; return score ; }
String replacePi ( String input ) { String output = "" ; int size = input . length ( ) ; for ( int i = 0 ; i < size ; ++ i ) { if ( i + 1 < size && input . charAt ( i ) == 'p' && input . charAt ( i + 1 ) == 'i' ) { output += "3.14" ; i ++ ; } else { output += input . charAt ( i ) ; } } return output ; }
boolean check_pair_product ( Node head , int prod ) { Vector < Integer > s = new Vector < Integer > ( ) ; Node p = head ; while ( p != null ) { int curr = p . data ; if ( ( prod % curr == 0 ) && ( s . contains ( prod / curr ) ) ) { System . out . print ( curr + " " + ( prod / curr ) ) ; return true ; } s . add ( p . data ) ; p = p . next ; } return false ; }
int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { int j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; }
int totalNumbersWithSpecificDifference ( int N , int diff ) { int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( mid - sumOfDigit ( mid ) < diff ) low = mid + 1 ; else high = mid - 1 ; } return ( N - high ) ; }
int computeCost ( int arr [ ] , int N , int X ) { int cost = 0 ; for ( int i = 0 ; i < N ; i ++ ) cost += Math . abs ( arr [ i ] - X ) ; return cost ; }
void insertionSort ( int arr [ ] , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } }
void minimumRange ( int arr [ ] , int N , int K ) { if ( K >= N ) { System . out . print ( 0 ) ; return ; } Arrays . sort ( arr ) ; int left = 0 , right = N - 1 , i ; for ( i = 0 ; i < K ; i ++ ) { if ( arr [ right - 1 ] - arr [ left ] < arr [ right ] - arr [ left + 1 ] ) right -- ; else left ++ ; } System . out . print ( arr [ right ] - arr [ left ] ) ; }
int minimum_possible_sum ( int arr [ ] , int n , int k ) { if ( n == 0 ) { return 0 ; } if ( n == 1 ) { return arr [ 0 ] ; } for ( int i = 0 ; i < k ; i ++ ) { int smallest_element = arr [ 0 ] ; int smallest_pos = 0 ; int largest_element = arr [ 0 ] ; int largest_pos = 0 ; for ( int j = 1 ; j < n ; j ++ ) { if ( arr [ j ] >= largest_element ) { largest_element = arr [ j ] ; largest_pos = j ; } if ( arr [ j ] < smallest_element ) { smallest_element = arr [ j ] ; smallest_pos = j ; } } int a = smallest_element * 2 ; int b = largest_element / 2 ; if ( a + b < smallest_element + largest_element ) { arr [ smallest_pos ] = a ; arr [ largest_pos ] = b ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += arr [ i ] ; } return ans ; }
int XorSum ( int A [ ] , int B [ ] , int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { ans = ans ^ ( A [ i ] + B [ j ] ) ; } } return ans ; }
int findCount ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int result = 1 ; int cur_max = arr [ 0 ] ; int cur_min = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { cur_max = arr [ i ] ; if ( cur_max - cur_min > K ) { result ++ ; cur_max = arr [ i ] ; cur_min = arr [ i ] ; } } return result ; }
void checkToMakeEqual ( String S1 , String S2 ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < S1 . length ( ) ; i ++ ) { freq [ S1 . charAt ( i ) - 'a' ] ++ ; } boolean flag = false ; for ( int i = 0 ; i < S2 . length ( ) ; i ++ ) { if ( freq [ S2 . charAt ( i ) - 'a' ] == 0 ) { flag = true ; break ; } freq [ S2 . charAt ( i ) - 'a' ] -- ; } if ( flag == true ) { System . out . println ( "No" ) ; return ; } int invCount1 = inversionCount ( S1 ) ; int invCount2 = inversionCount ( S2 ) ; if ( invCount1 == invCount2 || ( invCount1 & 1 ) == ( invCount2 & 1 ) || haveRepeated ( S1 , S2 ) ) { System . out . println ( "Yes" ) ; } else System . out . println ( "No" ) ; }
int findKthSmallest ( int [ ] arr , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } int [ ] counter = new int [ max + 1 ] ; int smallest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; } for ( int num = 1 ; num <= max ; num ++ ) { if ( counter [ num ] > 0 ) { smallest += counter [ num ] ; } if ( smallest >= k ) { return num ; } } return - 1 ; }
void printArr ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; if ( arr [ 0 ] == arr [ n - 1 ] ) { System . out . println ( "No" ) ; } else { System . out . println ( "Yes" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } } }
int countVowels ( String str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( isVowel ( str . charAt ( i ) ) ) ++ count ; return count ; }
int findSum ( int [ ] arr , int n , int k ) { int ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) { ans = Math . min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }
int cntElements ( int arr [ ] , int n ) { int copy_arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; int count = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; }
void UpdateArr ( int arr [ ] , int n ) { int i = 0 , j = n - 1 ; while ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i += 2 ; j -= 2 ; } printArr ( arr , n ) ; }
void pre ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; } }
void sieve ( long n ) { for ( int i = 2 ; i <= n ; i += 1 ) { prime [ i ] = true ; } for ( int p = 2 ; ( int ) p * ( int ) p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = ( int ) p * ( int ) p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) pr . add ( ( long ) p ) ; }
long SemiPrimeSum ( long N ) { long ans = 0 ; for ( int i = 0 ; i < pr . size ( ) ; i += 1 ) { for ( int j = i ; j < pr . size ( ) ; j += 1 ) { if ( ( long ) pr . get ( i ) * ( long ) pr . get ( j ) > N ) break ; ans += ( long ) pr . get ( i ) * ( long ) pr . get ( j ) ; } } return ans ; }
void quickSort ( char arr [ ] , int low , int high , int mod ) { if ( low < high ) { int pi = partition ( arr , low , high , mod ) ; quickSort ( arr , low , pi - 1 , mod ) ; quickSort ( arr , pi + 1 , high , mod ) ; } }
int maxWater ( int height [ ] , int n ) { int max = 0 ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( height [ i ] < height [ j ] ) { max = Math . max ( max , ( j - i - 1 ) * height [ i ] ) ; i ++ ; } else if ( height [ j ] < height [ i ] ) { max = Math . max ( max , ( j - i - 1 ) * height [ j ] ) ; j -- ; } else { max = Math . max ( max , ( j - i - 1 ) * height [ i ] ) ; i ++ ; j -- ; } } return max ; }
boolean check ( String str ) { int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int ascii = ( int ) str . charAt ( i ) ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; int eSum = ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; }
void findNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; reverse ( arr ) ; int freq [ ] = new int [ arr [ 0 ] + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int size = ( int ) Math . sqrt ( n ) ; int brr [ ] = new int [ size ] , x , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ arr [ i ] ] > 0 && l < size ) { brr [ l ] = arr [ i ] ; freq [ brr [ l ] ] -- ; l ++ ; for ( int j = 0 ; j < l ; j ++ ) { if ( i != j ) { x = __gcd ( arr [ i ] , brr [ j ] ) ; freq [ x ] -= 2 ; } } } } printArr ( brr , size ) ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void merge_and_sort ( int output [ ] , int arr [ ] [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { output [ i * n + j ] = arr [ i ] [ j ] ; } } Arrays . sort ( output ) ; }
void AlternateRearrange ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) v1 . add ( arr [ i ] ) ; else v2 . add ( arr [ i ] ) ; int index = 0 , i = 0 , j = 0 ; boolean flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ] = ( int ) v1 . get ( i ) ; i += 1 ; index += 1 ; flag = ! flag ; } else { arr [ index ] = ( int ) v2 . get ( j ) ; j += 1 ; index += 1 ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
int getNumToAdd ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; int numToAdd = - 1 ; boolean numAdded = false ; for ( int i = 2 ; i < n ; i ++ ) { int diff = arr [ i ] - arr [ i - 1 ] ; if ( diff != d ) { if ( numAdded ) return - 1 ; if ( diff == 2 * d ) { numToAdd = arr [ i ] - d ; numAdded = true ; } else return - 1 ; } } if ( numToAdd == - 1 ) return ( arr [ n - 1 ] + d ) ; return numToAdd ; }
int PointInKSquares ( int n , int a [ ] , int k ) { Arrays . sort ( a ) ; return a [ n - k ] ; }
int maxArrayCover ( int [ ] a , int n , int x ) { Arrays . sort ( a ) ; int cc = 0 ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += a [ i ] ; if ( s > x ) { break ; } cc += 1 ; } if ( Arrays . stream ( a ) . sum ( ) == x ) { return n ; } else { if ( cc == n ) { return n - 1 ; } else { return cc ; } } }
int findMaxNum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int num = arr [ 0 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { num = num * 10 + arr [ i ] ; } return num ; }
void sort ( int arr [ ] , int n ) { int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 999 ) { index = i ; break ; } } if ( index == - 1 ) return ; sortRec ( arr , index , n , n ) ; }
void merge ( int [ ] arr1 , int [ ] arr2 , int n , int m ) { int i , j , gap = n + m ; for ( gap = nextGap ( gap ) ; gap > 0 ; gap = nextGap ( gap ) ) { for ( i = 0 ; i + gap < n ; i ++ ) if ( arr1 [ i ] > arr1 [ i + gap ] ) { int temp = arr1 [ i ] ; arr1 [ i ] = arr1 [ i + gap ] ; arr1 [ i + gap ] = temp ; } for ( j = gap > n ? gap - n : 0 ; i < n && j < m ; i ++ , j ++ ) if ( arr1 [ i ] > arr2 [ j ] ) { int temp = arr1 [ i ] ; arr1 [ i ] = arr2 [ j ] ; arr2 [ j ] = temp ; } if ( j < m ) { for ( j = 0 ; j + gap < m ; j ++ ) if ( arr2 [ j ] > arr2 [ j + gap ] ) { int temp = arr2 [ j ] ; arr2 [ j ] = arr2 [ j + gap ] ; arr2 [ j + gap ] = temp ; } } } }
int _mergeSort ( int arr [ ] , int temp [ ] , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; }
void printSorted ( int a , int b , int c ) { int get_max = Math . max ( a , Math . max ( b , c ) ) ; int get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; System . out . print ( get_min + " " + get_mid + " " + get_max ) ; }
int countSwaps ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; return _mergeSort ( arr , temp , 0 , n - 1 ) ; }
int pancakeSort ( int arr [ ] , int n ) { for ( int curr_size = n ; curr_size > 1 ; -- curr_size ) { int mi = findMax ( arr , curr_size ) ; if ( mi != curr_size - 1 ) { flip ( arr , mi ) ; flip ( arr , curr_size - 1 ) ; } } return 0 ; }
String largestMerge ( String word1 , String word2 ) { String merge = "" ; while ( word1 . length ( ) != 0 || word2 . length ( ) != 0 ) { if ( word1 . compareTo ( word2 ) == 0 || ( word1 . compareTo ( word2 ) > 0 ) ) { merge = merge + word1 . charAt ( 0 ) ; word1 = word1 . substring ( 1 ) ; } else { merge = merge + word2 . charAt ( 0 ) ; word2 = word2 . substring ( 1 ) ; } } return merge ; }
int find ( ArrayList < Integer > arr , int N ) { int Sum = 0 ; for ( int item : arr ) Sum += item ; if ( Sum % N == 1 ) return - 1 ; int k = Sum / N ; int ans = 0 ; int i = 0 ; while ( i < N ) { ans = ans + Math . abs ( k - arr . get ( i ) ) ; i += 1 ; } return ans / 2 ; }
int maxXORUtil ( int arr [ ] , int N , int xrr , int orr ) { if ( N == 0 ) return xrr ^ orr ; int x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) ; int y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) ; return Math . max ( x , y ) ; }
int maximumXOR ( int arr [ ] , int N ) { return maxXORUtil ( arr , N , 0 , 0 ) ; }
void findEquation ( int S , int M ) { System . out . println ( "1 " + ( ( - 1 ) * S ) + " " + M ) ; }
boolean isPalindrome ( int N ) { int temp = N ; int res = 0 ; while ( temp != 0 ) { int rem = temp % 10 ; res = res * 10 + rem ; temp /= 10 ; } if ( res == N ) { return true ; } else { return false ; } }
int minSteps ( ArrayList < Integer > a , int n ) { int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = a . get ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] + a . get ( i ) ; int mx = - 1 ; for ( int subgroupsum : prefix_sum ) { int sum = 0 ; int i = 0 ; int grp_count = 0 ; while ( i < n ) { sum += a . get ( i ) ; if ( sum == subgroupsum ) { grp_count += 1 ; sum = 0 ; } else if ( sum > subgroupsum ) { grp_count = - 1 ; break ; } i += 1 ; } if ( grp_count > mx ) mx = grp_count ; } return n - mx ; }
void findSubseq ( ArrayList < Integer > A , ArrayList < Integer > B , int K , int i ) { ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; findSubseqUtil ( A , B , ans , K , i ) ; if ( ans . size ( ) < 1 ) System . out . println ( - 1 ) ; }
int MinimumCost ( int A [ ] , int B [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int mod_A = B [ i ] % A [ i ] ; int totalCost_A = Math . min ( mod_A , A [ i ] - mod_A ) ; int mod_B = A [ i ] % B [ i ] ; int totalCost_B = Math . min ( mod_B , B [ i ] - mod_B ) ; totalCost += Math . min ( totalCost_A , totalCost_B ) ; } return totalCost ; }
int longestSubarray ( int [ ] arr , int N , int K ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( sum == K ) maxLen = i + 1 ; if ( ! um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - K ) ) { if ( maxLen < ( i - um . get ( sum - K ) ) ) maxLen = i - um . get ( sum - K ) ; } } return maxLen ; }
void findArrayWithMaxProduct ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) if ( arr [ i ] >= 0 ) { arr [ i ] = - arr [ i ] - 1 ; } if ( N % 2 == 1 ) { int max_element = - 1 ; int index = - 1 ; for ( int i = 0 ; i < N ; i ++ ) if ( Math . abs ( arr [ i ] ) > max_element ) { max_element = Math . abs ( arr [ i ] ) ; index = i ; } arr [ index ] = - arr [ index ] - 1 ; } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
int maximumCandy ( int [ ] candies , int [ ] safety , int N , int M ) { int total = 0 ; int ans = Integer . MAX_VALUE ; boolean all_safe = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = Math . min ( ans , safety [ i ] ) ; } else { ans = Math . min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; }
void canArrayBeReduced ( int [ ] arr , int N ) { if ( N == 1 ) { System . out . print ( arr [ 0 ] ) ; return ; } if ( arr [ 0 ] < arr [ N - 1 ] ) { System . out . print ( arr [ N - 1 ] ) ; } else System . out . print ( "Not Possible" ) ; }
void maxValueAtIndexK ( int N , int K , int M ) { int S1 = 0 , S2 = 0 ; S1 = K * ( K + 1 ) / 2 ; S2 = ( N - K - 1 ) * ( N - K ) / 2 ; int X = ( M + S1 + S2 ) / N ; System . out . println ( X ) ; }
int countEvenPairs ( int N , int M ) { int count = 0 ; int nEven = ( int ) Math . floor ( ( double ) N / 2 ) ; int nOdd = ( int ) Math . ceil ( ( double ) N / 2 ) ; int mEven = ( int ) Math . floor ( ( double ) M / 2 ) ; int mOdd = ( int ) Math . ceil ( ( double ) M / 2 ) ; count = nEven * mEven + nOdd * mOdd ; return count ; }
void findNums ( int X , int Y ) { int A , B ; if ( X < Y ) { A = - 1 ; B = - 1 ; } else if ( ( ( Math . abs ( X - Y ) ) & 1 ) != 0 ) { A = - 1 ; B = - 1 ; } else if ( X == Y ) { A = 0 ; B = Y ; } else { A = ( X - Y ) / 2 ; if ( ( A & Y ) == 0 ) { B = ( A + Y ) ; } else { A = - 1 ; B = - 1 ; } } System . out . print ( A + " " + B ) ; }
int findPartition ( int nums [ ] , int N ) { int [ ] prefix = new int [ N ] ; int [ ] suffix = new int [ N ] ; int i , k ; prefix [ 0 ] = nums [ 0 ] ; for ( i = 1 ; i < N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] * nums [ i ] ; } suffix [ N - 1 ] = nums [ N - 1 ] ; for ( i = N - 2 ; i >= 0 ; i -- ) { suffix [ i ] = suffix [ i + 1 ] * nums [ i ] ; } for ( k = 0 ; k < N - 1 ; k ++ ) { if ( GCD ( prefix [ k ] , suffix [ k + 1 ] ) == 1 ) { return k ; } } return - 1 ; }
void palindromeMatrix ( int N , int M , int [ ] [ ] arr ) { int ans = 0 ; for ( int i = 0 ; i < ( N + 1 ) / 2 ; i ++ ) { for ( int j = 0 ; j < ( M + 1 ) / 2 ; j ++ ) { HashSet < pair > s = new HashSet < > ( ) ; s . add ( new pair ( i , j ) ) ; s . add ( new pair ( i , M - j - 1 ) ) ; s . add ( new pair ( N - i - 1 , j ) ) ; s . add ( new pair ( N - i - 1 , M - j - 1 ) ) ; Vector < Integer > values = new Vector < > ( ) ; for ( pair p : s ) { values . add ( arr [ p . first ] [ p . second ] ) ; } int max = Collections . max ( values ) ; for ( int k = 1 ; k < values . size ( ) ; k ++ ) { ans += max - values . get ( k ) ; } } } System . out . print ( ans ) ; }
int MinOperation ( int arr [ ] , int N , int K ) { int cntOpe = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( K > arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cntOpe += 2 ; } else { cntOpe += 1 ; } } else if ( K < arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cntOpe += 1 ; } else { cntOpe += 2 ; } } } return cntOpe ; }
void printSmallSub ( int [ ] arr , int N ) { int gcdArr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { gcdArr = gcd ( gcdArr , arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == gcdArr ) { System . out . print ( arr [ i ] + " " ) ; return ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( gcd ( arr [ i ] , arr [ j ] ) == gcdArr ) { System . out . print ( arr [ i ] + " " + arr [ j ] ) ; return ; } } } }
void smlstNonNeg ( int arr [ ] , int N ) { int smNonNeg = 0 ; Boolean [ ] hash = new Boolean [ N + 1 ] ; Arrays . fill ( hash , false ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 0 && arr [ i ] < N ) { hash [ arr [ i ] ] = true ; } while ( hash [ smNonNeg ] ) { smNonNeg ++ ; } System . out . print ( smNonNeg + " " ) ; } }
void numberOfWays ( int N ) { long count = count_of_primes [ N ] - 1 ; long mod = 1000000007 ; long answer = power ( 2 , count , mod ) ; if ( N == 1 ) answer = 0 ; long ans = answer ; System . out . println ( ans ) ; }
int cntPairs ( int arr [ ] , int N ) { boolean isPrime [ ] = getPrimeNum ( ) ; int cntOne = 0 ; int cntPrime = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) { cntOne += 1 ; } else if ( isPrime [ i ] ) { cntPrime += 1 ; } } int cntNonComp = 0 ; cntNonComp = cntPrime * cntOne + cntOne * ( cntOne - 1 ) / 2 ; int res = 0 ; res = N * ( N - 1 ) / 2 - cntNonComp ; return res ; }
void printArray ( Vector < Integer > brr ) { for ( int it : brr ) { System . out . print ( it + " " ) ; } }
int MinimumFlips ( String s , int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( s . charAt ( i ) == '1' ? 1 : 0 ) ; } int [ ] oddone = new int [ n + 1 ] ; int [ ] evenone = new int [ n + 1 ] ; oddone [ 0 ] = 0 ; evenone [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) { oddone [ i + 1 ] = oddone [ i ] + ( a [ i ] == 1 ? 1 : 0 ) ; evenone [ i + 1 ] = evenone [ i ] + ( a [ i ] == 0 ? 1 : 0 ) ; } else { oddone [ i + 1 ] = oddone [ i ] + ( a [ i ] == 0 ? 1 : 0 ) ; evenone [ i + 1 ] = evenone [ i ] + ( a [ i ] == 1 ? 1 : 0 ) ; } } int minimum = Math . min ( oddone [ n ] , evenone [ n ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( n % 2 != 0 ) { minimum = Math . min ( minimum , oddone [ n ] - oddone [ i + 1 ] + evenone [ i + 1 ] ) ; minimum = Math . min ( minimum , evenone [ n ] - evenone [ i + 1 ] + oddone [ i + 1 ] ) ; } } return minimum ; }
void shortestpath ( int m , int n ) { Vector < Integer > mfactor = new Vector < > ( ) ; Vector < Integer > nfactor = new Vector < > ( ) ; HashMap < Integer , Integer > fre = new HashMap < > ( ) ; mfactor . add ( m ) ; fre . put ( m , 1 ) ; while ( m != 1 ) { if ( isprm ( m ) != 0 ) { mfactor . add ( 1 ) ; fre . put ( 1 , 1 ) ; m = 1 ; } else { for ( int i = 2 ; i <= Math . sqrt ( m ) ; i ++ ) { if ( m % i == 0 ) { mfactor . add ( m / i ) ; fre . put ( m / i , 1 ) ; m = ( m / i ) ; break ; } } } } nfactor . add ( n ) ; while ( fre . containsKey ( n ) && fre . get ( n ) != 1 ) { if ( isprm ( n ) != 0 ) { nfactor . add ( 1 ) ; n = 1 ; } else { for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { nfactor . add ( n / i ) ; n = ( n / i ) ; break ; } } } } for ( int i = 0 ; i < mfactor . size ( ) ; i ++ ) { if ( mfactor . get ( i ) == n ) break ; System . out . print ( mfactor . get ( i ) + " <--> " ) ; } for ( int i = nfactor . size ( ) - 1 ; i >= 0 ; i -- ) { if ( i == 0 ) System . out . print ( nfactor . get ( i ) ) ; else System . out . print ( nfactor . get ( i ) + " <--> " ) ; } }
int factorial ( int N ) { if ( N <= 0 ) return 1 ; int fact = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = ( fact * i ) % Mod ; } return fact ; }
int noOfFactors ( int N ) { if ( N == 1 ) return 1 ; int count = 0 ; int ans = 1 ; while ( N % 2 == 0 ) { count ++ ; N = N / 2 ; } ans *= ( count / 2 + 1 ) ; for ( int i = 3 ; i * i <= N ; i = i + 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } ans *= ( count / 2 + 1 ) ; } return ans ; }
void minCost ( int N , int M , int vCost , int eCost , int sorc [ ] , ArrayList < Integer > colored , int destination [ ] ) { ArrayList < ArrayList < Integer > > adj = new ArrayList < > ( ) ; for ( int i = 0 ; i < N + 1 ; i ++ ) adj . add ( new ArrayList < Integer > ( ) ) ; for ( int i = 0 ; i < M ; i ++ ) { adj . get ( sorc [ i ] ) . add ( destination [ i ] ) ; adj . get ( destination [ i ] ) . add ( sorc [ i ] ) ; } int [ ] vis = new int [ N + 1 ] ; for ( int i = 0 ; i < colored . size ( ) ; i ++ ) { DFS ( colored . get ( i ) , vis , adj ) ; } int X = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] == 0 ) { X ++ ; DFS ( i , vis , adj ) ; } } int mincost = X * Math . min ( vCost , eCost ) ; System . out . println ( mincost ) ; }
double power ( int N , int P ) { return Math . pow ( N , P ) ; }
void Solve ( int N , int M ) { int temp = ( N - 1 ) * ( M - 1 ) ; int ans = ( int ) ( Math . pow ( 2 , temp ) ) ; if ( ( N + M ) % 2 != 0 ) System . out . print ( ans ) ; else System . out . print ( 2 * ans ) ; }
void findMaximumLength ( int lis [ ] [ ] ) { id ++ ; length = 0 ; diameter = 0 ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < col ; j ++ ) { if ( lis [ i ] [ j ] != 0 ) { dfs ( i , j , lis ) ; i = row ; break ; } } } id ++ ; length = 0 ; diameter = 0 ; dfs ( x , y , lis ) ; System . out . print ( diameter ) ; }
int maxModulosum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return sum - n ; }
int noOfPermutations ( int [ ] a , int n ) { if ( n == 1 ) { return 1 ; } Arrays . sort ( a ) ; if ( a [ n - 1 ] == a [ n - 2 ] ) { return 0 ; } int x = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( a [ i ] == a [ i + 1 ] ) { if ( a [ i ] == a [ i + 2 ] ) { return 0 ; } x ++ ; i ++ ; } } return pow ( 2 , n - 2 * x - 1 ) ; }
int maxValue ( int arr [ ] , int n , int moves ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { int distance = n - 1 - i ; if ( moves < distance ) break ; int can_take = moves / distance ; int take = Math . min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; }
boolean hasCrest ( int arr [ ] , int n , int L , int R ) { int [ ] present = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { present [ i ] = 0 ; } for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( ( arr [ i ] <= arr [ i + 1 ] ) && ( arr [ i ] <= arr [ i - 1 ] ) ) { present [ i ] = 1 ; } } for ( int i = 1 ; i < n ; i ++ ) { present [ i ] += present [ i - 1 ] ; } if ( present [ L ] == present [ R - 1 ] ) return true ; return false ; }
int getMin ( int arr [ ] , int n ) { int minVal = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; return minVal ; }
int Substring ( String s ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; }
int countOp ( int x ) { int arr [ ] = new int [ MAX ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ; int temp = x ; boolean flag = true ; int ans = 0 ; int operations = 0 ; boolean flag2 = false ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag2 = true ; if ( arr [ i ] > x ) { ans = i ; break ; } } if ( flag2 ) return 0 ; while ( flag ) { if ( arr [ ans ] < x ) ans ++ ; operations ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { int take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) { if ( take > temp ) temp = take ; } } if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; } return operations ; }
int getMinSum ( int arr [ ] , int n ) { int bits_count [ ] = new int [ MAX ] , max_bit = 0 , sum = 0 , ans = 0 ; for ( int d = 0 ; d < n ; d ++ ) { int e = arr [ d ] , f = 0 ; while ( e > 0 ) { int rem = e % 2 ; e = e / 2 ; if ( rem == 1 ) { bits_count [ f ] += rem ; } f ++ ; } max_bit = Math . max ( max_bit , f ) ; } for ( int d = 0 ; d < max_bit ; d ++ ) { int temp = ( int ) Math . pow ( 2 , d ) ; if ( bits_count [ d ] > n / 2 ) ans = ans + temp ; } for ( int d = 0 ; d < n ; d ++ ) { arr [ d ] = arr [ d ] ^ ans ; sum = sum + arr [ d ] ; } return sum ; }
void replacedArray ( int N , int arr [ ] ) { int pos_sum , neg_sum , i , j , diff ; pos_sum = 0 ; neg_sum = 0 ; for ( i = N - 1 ; i >= 0 ; i -- ) { diff = Math . abs ( pos_sum ) - Math . abs ( neg_sum ) ; if ( arr [ i ] > 0 ) pos_sum += arr [ i ] ; else neg_sum += arr [ i ] ; arr [ i ] = Math . abs ( diff ) ; } }
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * ( a / n ) * ( b / n ) ; ans += ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( b / n ) ; ans += ( ( a % n ) + ( b % n ) ) / n ; return ans ; }
int minChanges ( int [ ] A , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; }
int solve ( int [ ] [ ] v , int n ) { int ans , ul , ll ; int first = 0 ; int second = 1 ; ll = v [ 0 ] [ first ] ; ul = v [ 0 ] [ second ] ; ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( v [ i ] [ first ] <= ul && v [ i ] [ first ] >= ll ) || ( v [ i ] [ second ] >= ll && v [ i ] [ second ] <= ul ) ) { if ( v [ i ] [ first ] > ll ) { ll = v [ i ] [ first ] ; } if ( v [ i ] [ second ] < ul ) { ul = v [ i ] [ second ] ; } } else if ( v [ i ] [ first ] > ul ) { ans += Math . abs ( ul - v [ i ] [ first ] ) ; ul = v [ i ] [ first ] ; ll = v [ i ] [ first ] ; } else if ( v [ i ] [ second ] < ll ) { ans += Math . abs ( ll - v [ i ] [ second ] ) ; ul = v [ i ] [ second ] ; ll = v [ i ] [ second ] ; } } return ans ; }
int steps ( int N , int M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; }
int dfs ( int w ) { if ( cd [ w ] == 0 ) return w ; if ( wt [ w ] < ans ) ans = wt [ w ] ; return dfs ( cd [ w ] ) ; }
void digitsNum ( int N ) { if ( N == 0 ) System . out . println ( "0" ) ; if ( N % 9 != 0 ) System . out . print ( ( N % 9 ) ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) System . out . print ( "9" ) ; for ( int i = 1 ; i <= N ; ++ i ) System . out . print ( "0" ) ; System . out . print ( "" ) ; }
void bestpermutation ( ArrayList < Integer > arr , int k , int n ) { HashMap < Integer , Integer > h = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { h . put ( arr . get ( i ) , i ) ; } if ( n <= k ) { Collections . sort ( arr , Collections . reverseOrder ( ) ) ; } else { for ( int j = n ; j >= 1 ; j -- ) { if ( k > 0 ) { int initial_index = h . get ( j ) ; int best_index = n - j ; if ( initial_index != best_index ) { h . put ( j , best_index ) ; int element = arr . get ( best_index ) ; h . put ( element , initial_index ) ; int temp = arr . get ( best_index ) ; arr . set ( best_index , arr . get ( initial_index ) ) ; arr . set ( initial_index , temp ) ; k -- ; } } } } }
int sumArray ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } return sum ; }
int firstFit ( int weight [ ] , int n , int c ) { int res = 0 ; int [ ] bin_rem = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < res ; j ++ ) { if ( bin_rem [ j ] >= weight [ i ] ) { bin_rem [ j ] = bin_rem [ j ] - weight [ i ] ; break ; } } if ( j == res ) { bin_rem [ res ] = c - weight [ i ] ; res ++ ; } } return res ; }
int find ( int A , int B , int C , int N ) { int [ ] arr = new int [ N ] ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; for ( int i = 3 ; i < N ; i ++ ) { arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] + arr [ i - 3 ] ; } return arr [ N - 1 ] ; }
void maxSum ( int [ ] [ ] arr , int n ) { int r1 = 0 , r2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = r1 ; r1 = Math . max ( r1 , r2 + arr [ 0 ] [ i ] ) ; r2 = Math . max ( r2 , temp + arr [ 1 ] [ i ] ) ; } System . out . println ( Math . max ( r1 , r2 ) ) ; }
int countMinCoins ( int n , int C [ ] , int m ) { if ( n == 0 ) { dp [ 0 ] = 0 ; return 0 ; } if ( dp [ n ] != - 1 ) return dp [ n ] ; int ret = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( C [ i ] <= n ) { int x = countMinCoins ( n - C [ i ] , C , m ) ; if ( x != Integer . MAX_VALUE ) ret = Math . min ( ret , 1 + x ) ; } } dp [ n ] = ret ; return ret ; }
void findSolution ( int n , int C [ ] , int m ) { if ( n == 0 ) { for ( int it : denomination ) { System . out . print ( it + " " ) ; } return ; } for ( int i = 0 ; i < m ; i ++ ) { if ( n - C [ i ] >= 0 && dp [ n - C [ i ] ] + 1 == dp [ n ] ) { denomination . add ( C [ i ] ) ; findSolution ( n - C [ i ] , C , m ) ; break ; } } }
int count_unique_sum ( int n ) { int i ; int ar [ ] = new int [ n + 1 ] ; int fsum [ ] = new int [ n + 1 ] ; int rsum [ ] = new int [ n + 1 ] ; int ans = 1 ; Arrays . fill ( fsum , 0 ) ; Arrays . fill ( rsum , 0 ) ; for ( i = 0 ; i <= n ; i ++ ) { ar [ i ] = i ; } fsum [ 0 ] = ar [ 0 ] ; rsum [ n ] = ar [ n ] ; for ( i = 1 ; i <= n ; i ++ ) { fsum [ i ] = ar [ i ] + fsum [ i - 1 ] ; } for ( i = n - 1 ; i >= 0 ; i -- ) { rsum [ i ] = ar [ i ] + rsum [ i + 1 ] ; } for ( int k = 2 ; k <= n ; k ++ ) { ans += 1 + rsum [ n + 1 - k ] - fsum [ k - 1 ] ; } return ans ; }
void precompute ( int nextpos [ ] , int arr [ ] , int N ) { nextpos [ N - 1 ] = N ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) nextpos [ i ] = nextpos [ i + 1 ] ; else nextpos [ i ] = i + 1 ; } }
int fun ( int pos , int sum , int st , int check , int f ) { if ( pos == N ) { return ( sum == 0 && check == 1 ) ? 1 : 0 ; } if ( dp [ pos ] [ sum ] [ st ] [ check ] [ f ] != - 1 ) return dp [ pos ] [ sum ] [ st ] [ check ] [ f ] ; int lmt = 9 ; if ( f == 0 ) lmt = v . get ( pos ) ; int ans = 0 ; for ( int digit = 0 ; digit <= lmt ; digit ++ ) { int nf = f ; int new_sum = ( sum + digit ) % K ; int new_check = check ; int new_st = st ; if ( f == 0 && digit < lmt ) nf = 1 ; if ( check == 0 && digit != 0 ) { new_st = digit ; new_check = 1 ; } if ( pos == N - 1 && new_st == digit ) continue ; ans += fun ( pos + 1 , new_sum , new_st , new_check , nf ) ; } return dp [ pos ] [ sum ] [ st ] [ check ] [ f ] = ans ; }
int minSumProd ( String S , int K ) { int len = S . length ( ) ; if ( K > len ) return - 1 ; if ( K == len ) return 0 ; int [ ] dp = new int [ len ] ; int count_zero = 0 , count_one = 0 ; for ( int j = 0 ; j < len ; j ++ ) { if ( S . charAt ( j ) == '0' ) count_zero ++ ; else count_one ++ ; dp [ j ] = count_zero * count_one ; } for ( int i = 1 ; i < K ; i ++ ) { for ( int j = len - 1 ; j >= i ; j -- ) { count_zero = 0 ; count_one = 0 ; dp [ j ] = Integer . MAX_VALUE ; for ( int k = j ; k >= i ; k -- ) { if ( S . charAt ( k ) == '0' ) count_zero ++ ; else count_one ++ ; dp [ j ] = Math . min ( dp [ j ] , count_zero * count_one + dp [ k - 1 ] ) ; } } } return dp [ len - 1 ] ; }
int countPairs ( int [ ] arr , int N ) { int maxm = arr [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) { if ( maxm < arr [ j ] ) { maxm = arr [ j ] ; } } int i , k = 0 ; int [ ] bitscount = new int [ maxm + 1 ] ; Arrays . fill ( bitscount , 0 ) ; for ( i = 1 ; i <= maxm ; i *= 2 ) bitscount [ i ] = 1 ; for ( i = 1 ; i <= maxm ; i ++ ) { if ( bitscount [ i ] == 1 ) k = i ; if ( bitscount [ i ] == 0 ) { bitscount [ i ] = bitscount [ k ] + bitscount [ i - k ] ; } } Map < Integer , Integer > setbits = new HashMap < > ( ) ; for ( int j = 0 ; j < N ; j ++ ) { setbits . put ( bitscount [ arr [ j ] ] , setbits . getOrDefault ( bitscount [ arr [ j ] ] , 0 ) + 1 ) ; } int ans = 0 ; for ( int it : setbits . values ( ) ) { ans += it * ( it - 1 ) / 2 ; } return ans ; }
int solve ( int n , int k , int m ) { if ( n == 0 && k == 0 ) return 1 ; if ( n == 0 && k != 0 ) return 0 ; if ( n != 0 && k == 0 ) return 0 ; if ( n < 0 k < 0 ) return 0 ; if ( dp [ n ] [ k ] > 0 ) return dp [ n ] [ k ] ; int ans = 0 ; for ( int j = 1 ; j <= m ; j ++ ) { ans += solve ( n - j , k - 1 , m ) ; } return dp [ n ] [ k ] = ans ; }
boolean isprime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
int productDigitSum ( int x , int y ) { int sumx = 0 ; while ( x > 0 ) { sumx += ( x % 10 ) ; x /= 10 ; } int sumy = 0 ; while ( y > 0 ) { sumy += ( y % 10 ) ; y /= 10 ; } return ( sumx * sumy ) ; }
int CountSets ( int x , int pos ) { if ( x <= 0 ) { if ( pos == 0 ) return 1 ; else return 0 ; } if ( pos == 0 ) return 1 ; if ( dp [ x ] [ pos ] != - 1 ) return dp [ x ] [ pos ] ; int answer = CountSets ( x - 1 , pos ) + CountSets ( x - 2 , pos - 1 ) ; return dp [ x ] [ pos ] = answer ; }
int splitIntoPrimes ( String number ) { if ( number . length ( ) == 0 ) return 0 ; if ( number . length ( ) <= 6 && checkPrime ( number ) ) return 1 ; else { int numLen = number . length ( ) ; int ans = 1000000 ; for ( int i = 1 ; i <= 6 && i <= numLen ; i ++ ) { if ( checkPrime ( number . substring ( 0 , i ) ) ) { int val = splitIntoPrimes ( number . substring ( i ) ) ; if ( val != - 1 ) { ans = Math . min ( ans , 1 + val ) ; } } } if ( ans == 1000000 ) return - 1 ; return ans ; } }
int dp ( int pos , int fl , int pr , String bin ) { if ( pos == bin . length ( ) ) return 1 ; if ( memo [ pos ] [ fl ] [ pr ] != - 1 ) return memo [ pos ] [ fl ] [ pr ] ; int val = 0 ; if ( bin . charAt ( pos ) == '0' ) val = val + dp ( pos + 1 , fl , 0 , bin ) ; else if ( bin . charAt ( pos ) == '1' ) val = val + dp ( pos + 1 , 1 , 0 , bin ) ; if ( pr == 0 ) { if ( fl == 1 ) { val += dp ( pos + 1 , fl , 1 , bin ) ; } else if ( bin . charAt ( pos ) == '1' ) { val += dp ( pos + 1 , fl , 1 , bin ) ; } } return memo [ pos ] [ fl ] [ pr ] = val ; }
int TotalWays ( int n , int s , int k ) { int [ ] dp = new int [ n ] ; dp [ s - 1 ] = 1 ; for ( int i = s ; i < n ; i ++ ) { int idx = Math . max ( s - 1 , i - k ) ; for ( int j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; }
int solve ( int arr [ ] , int n , int i , int pos ) { if ( i == n ) return 0 ; if ( LAS [ i ] [ pos ] == 1 ) return LAS [ i ] [ pos ] ; int inc = 0 , exc = 0 ; if ( arr [ i ] > 0 && pos == 1 ) { pos = 0 ; inc = 1 + solve ( arr , n , i + 1 , pos ) ; } else if ( arr [ i ] < 0 && pos == 0 ) { pos = 1 ; inc = 1 + solve ( arr , n , i + 1 , pos ) ; } exc = solve ( arr , n , i + 1 , pos ) ; LAS [ i ] [ pos ] = Math . max ( inc , exc ) ; return LAS [ i ] [ pos ] ; }
int query ( int in , int l , int r , int l1 , int r1 ) { if ( l > r ) return 0 ; if ( r < l1 l > r1 ) return 0 ; if ( l1 <= l && r <= r1 ) return seg [ in ] ; int m = ( l + r ) / 2 ; return query ( 2 * in + 1 , l , m , l1 , r1 ) + query ( 2 * in + 2 , m + 1 , r , l1 , r1 ) ; }
int minMergeCost ( int i , int j , int [ ] arr ) { if ( i == j ) return 0 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = true ; int x = dp [ i ] [ j ] ; x = Integer . MAX_VALUE ; int tot = 0 ; for ( int k = i ; k <= j ; k ++ ) tot += arr [ k ] ; for ( int k = i + 1 ; k <= j ; k ++ ) { x = Math . min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) ; } return x ; }
int numberOfCells ( int mat [ ] [ ] ) { boolean [ ] [ ] row = new boolean [ N ] [ N ] ; boolean [ ] [ ] col = new boolean [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat [ i ] [ j ] == 1 ) { row [ i ] [ j ] = ( j + 1 < N ) ? row [ i ] [ j + 1 ] : true ; } else { row [ i ] [ j ] = false ; } } } for ( int j = 0 ; j < N ; j ++ ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( mat [ i ] [ j ] == 1 ) { col [ i ] [ j ] = ( i + 1 < N ) ? col [ i + 1 ] [ j ] : true ; } else { col [ i ] [ j ] = false ; } } } int cnt = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( row [ i ] [ j ] && col [ i ] [ j ] ) { cnt ++ ; } } } for ( int i = 0 ; i < N ; i ++ ) { if ( col [ i ] [ N - 1 ] ) cnt ++ ; } for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( row [ N - 1 ] [ j ] ) cnt ++ ; } return cnt ; }
int subsequence ( int [ ] S , int [ ] T , int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; int mod = 1000000007 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j <= m ; j ++ ) dp [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; if ( S [ i - 1 ] == T [ j - 1 ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] ; dp [ i ] [ j ] += mod ; dp [ i ] [ j ] %= mod ; } } return dp [ n ] [ m ] ; }
int findCount ( int n ) { return ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; }
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
int countWays ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; }
boolean findPath ( ArrayList < ArrayList < Integer > > maze , int xpos , int ypos , boolean key ) { if ( xpos < 0 || xpos >= maze . size ( ) || ypos < 0 || ypos >= maze . size ( ) ) return false ; if ( maze . get ( xpos ) . get ( ypos ) == '1' ) { if ( key == true ) if ( xpos == maze . size ( ) - 1 && ypos == maze . size ( ) - 1 ) return true ; return findPath ( maze , xpos + 1 , ypos , false ) || findPath ( maze , xpos , ypos + 1 , false ) ; } if ( xpos == maze . size ( ) - 1 && ypos == maze . size ( ) - 1 ) return true ; return findPath ( maze , xpos + 1 , ypos , key ) || findPath ( maze , xpos , ypos + 1 , key ) ; }
void findPrefixCount ( int arr [ ] , int n ) { for ( int i = 0 ; i < bitscount ; i ++ ) { prefix_count [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( int j = 1 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] += prefix_count [ i ] [ j - 1 ] ; } } }
int countWays ( int n , int l , int r ) { int tL = l , tR = r ; int [ ] L = new int [ 3 ] ; int [ ] R = new int [ 3 ] ; L [ l % 2 ] = l ; R [ r % 2 ] = r ; l ++ ; r -- ; if ( l <= tR && r >= tL ) { L [ l % 2 ] = l ; R [ r % 2 ] = r ; } int cnt0 = 0 , cnt1 = 0 ; if ( R [ 0 ] > 0 && L [ 0 ] > 0 ) cnt0 = ( R [ 0 ] - L [ 0 ] ) / 2 + 1 ; if ( R [ 1 ] > 0 && L [ 1 ] > 0 ) cnt1 = ( R [ 1 ] - L [ 1 ] ) / 2 + 1 ; int [ ] [ ] dp = new int [ n + 1 ] [ 3 ] ; dp [ 1 ] [ 0 ] = cnt0 ; dp [ 1 ] [ 1 ] = cnt1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = ( cnt0 * dp [ i - 1 ] [ 0 ] + cnt1 * dp [ i - 1 ] [ 1 ] ) ; dp [ i ] [ 1 ] = ( cnt0 * dp [ i - 1 ] [ 1 ] + cnt1 * dp [ i - 1 ] [ 0 ] ) ; } return dp [ n ] [ 0 ] ; }
int dfs ( int node , int parent , int [ ] dp1 , int [ ] dp2 , Vector < Vector < Integer > > adj ) { int firstmax = - 1 ; int secondmax = - 1 ; for ( int i = 0 ; i < adj . get ( node ) . size ( ) ; ++ i ) { if ( adj . get ( node ) . get ( i ) == parent ) continue ; dfs ( adj . get ( node ) . get ( i ) , node , dp1 , dp2 , adj ) ; if ( firstmax == - 1 ) { firstmax = dp1 [ adj . get ( node ) . get ( i ) ] ; } else if ( dp1 [ adj . get ( node ) . get ( i ) ] >= firstmax ) { secondmax = firstmax ; firstmax = dp1 [ adj . get ( node ) . get ( i ) ] ; } else if ( dp1 [ adj . get ( node ) . get ( i ) ] > secondmax ) { secondmax = dp1 [ adj . get ( node ) . get ( i ) ] ; } } dp1 [ node ] = 1 ; dp1 [ node ] += firstmax ; if ( secondmax != - 1 ) dp2 [ node ] = 1 + firstmax + secondmax ; return Math . max ( dp1 [ node ] , dp2 [ node ] ) ; }
int countRec ( int start , int end , int dp [ ] [ ] , String st ) { int sum = 0 ; if ( start > end ) return 1 ; if ( dp [ start ] [ end ] != - 1 ) return dp [ start ] [ end ] ; int i , r = 0 ; for ( i = start + 1 ; i <= end ; i += 2 ) { if ( checkFunc ( start , i , st ) == 1 ) { sum = sum + countRec ( start + 1 , i - 1 , dp , st ) * countRec ( i + 1 , end , dp , st ) ; } else if ( st . charAt ( start ) == '?' && st . charAt ( i ) == '?' ) { sum = sum + countRec ( start + 1 , i - 1 , dp , st ) * countRec ( i + 1 , end , dp , st ) * 3 ; } } return dp [ start ] [ end ] = sum ; }
int countWays ( String st ) { int n = st . length ( ) ; if ( n % 2 == 1 ) return 0 ; int dp [ ] [ ] = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) dp [ i ] [ j ] = - 1 ; return countRec ( 0 , n - 1 , dp , st ) ; }
void pre_compute ( char a [ ] [ ] ) { if ( a [ 0 ] [ 0 ] == 'a' ) dp [ 0 ] [ 0 ] = 0 ; else dp [ 0 ] [ 0 ] = 1 ; for ( int row = 0 ; row < n ; row ++ ) { for ( int col = 0 ; col < n ; col ++ ) { if ( row != 0 col != 0 ) dp [ row ] [ col ] = Integer . MAX_VALUE ; if ( row != 0 ) { dp [ row ] [ col ] = Math . min ( dp [ row ] [ col ] , dp [ row - 1 ] [ col ] ) ; } if ( col != 0 ) { dp [ row ] [ col ] = Math . min ( dp [ row ] [ col ] , dp [ row ] [ col - 1 ] ) ; } if ( a [ row ] [ col ] != 'a' && ( row != 0 col != 0 ) ) dp [ row ] [ col ] += 1 ; } } }
int CommomSubsequencesCount ( String s , String t ) { int n1 = s . length ( ) ; int n2 = t . length ( ) ; int dp [ ] [ ] = new int [ n1 + 1 ] [ n2 + 1 ] ; char ch1 , ch2 ; for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i <= n1 ; i ++ ) { for ( int j = 1 ; j <= n2 ; j ++ ) { ch1 = s . charAt ( i - 1 ) ; ch2 = t . charAt ( j - 1 ) ; if ( ch1 == ch2 ) dp [ i ] [ j ] = 1 + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] - dp [ i - 1 ] [ j - 1 ] ; } } return dp [ n1 ] [ n2 ] ; }
int lcs ( int dp [ ] [ ] , String a , String b , int m , int n ) { for ( int i = 0 ; i < 100 ; i ++ ) for ( int j = 0 ; j < 100 ; j ++ ) dp [ i ] [ j ] = - 1 ; if ( m < 0 n < 0 ) { return 0 ; } if ( dp [ m ] [ n ] != - 1 ) return dp [ m ] [ n ] ; int ans = 0 ; if ( a . charAt ( m ) == b . charAt ( n ) ) { ans = ( a . charAt ( m ) - 48 ) + lcs ( dp , a , b , m - 1 , n - 1 ) ; } else ans = Math . max ( lcs ( dp , a , b , m - 1 , n ) , lcs ( dp , a , b , m , n - 1 ) ) ; dp [ m ] [ n ] = ans ; return ans ; }
double largestSumOfAverages ( Vector < Integer > A , int K ) { int n = A . size ( ) ; double sum = 0 ; for ( int i = 0 ; i < memo . length ; i ++ ) { for ( int j = 0 ; j < memo [ i ] . length ; j ++ ) memo [ i ] [ j ] = 0.0 ; } for ( int i = 0 ; i < n ; i ++ ) { sum += A . elementAt ( i ) ; memo [ i + 1 ] [ 1 ] = sum / ( i + 1 ) ; } return score ( n , A , K ) ; }
double largestSumOfAverages ( int [ ] A , int K ) { int n = A . length ; double [ ] pre_sum = new double [ n + 1 ] ; pre_sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; double [ ] dp = new double [ n ] ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; for ( int k = 0 ; k < K - 1 ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) dp [ i ] = Math . max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }
int findMaxVal ( int [ ] arr , int n , int num , int maxLimit ) { int ind = 0 ; findMaxValUtil ( arr , n , num , maxLimit , ind ) ; return ans ; }
int findMaxVal ( int [ ] arr , int n , int num , int maxLimit ) { int ind ; int val ; int [ ] [ ] dp = new int [ n ] [ maxLimit + 1 ] ; for ( ind = 0 ; ind < n ; ind ++ ) { for ( val = 0 ; val <= maxLimit ; val ++ ) { if ( ind == 0 ) { if ( num - arr [ ind ] == val num + arr [ ind ] == val ) { dp [ ind ] [ val ] = 1 ; } else { dp [ ind ] [ val ] = 0 ; } } else { if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) { if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) dp [ ind ] [ val ] = 1 ; } else if ( val - arr [ ind ] >= 0 ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ; } else if ( val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else { dp [ ind ] [ val ] = 0 ; } } } } for ( val = maxLimit ; val >= 0 ; val -- ) { if ( dp [ n - 1 ] [ val ] == 1 ) { return val ; } } return - 1 ; }
int gen ( int n ) { if ( n == 0 ) return 0 ; else if ( n == 1 ) return 1 ; else if ( n % 2 == 0 ) return 4 * gen ( n / 2 ) ; else if ( n % 2 == 1 ) return 4 * gen ( n / 2 ) + 1 ; return 0 ; }
int solve ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] = - 1 ; } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { nck [ i ] [ j ] = - 1 ; } } int currLog2 = - 1 ; int currPower2 = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( currPower2 == i ) { currLog2 ++ ; currPower2 *= 2 ; } log2 [ i ] = currLog2 ; } return numberOfHeaps ( n ) ; }
int largestSubset ( int [ ] a , int n ) { int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) { mxm = Math . max ( mxm , dp [ j ] ) ; } } dp [ i ] = 1 + mxm ; } return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ; }
int maxLenSub ( int arr [ ] , int n ) { int mls [ ] = new int [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
int minimumNumberOfDeletions ( int arr [ ] , int n ) { int len = lis ( arr , n ) ; return ( n - len ) ; }
int countGroups ( int position , int previous_sum , int length , String num ) { if ( position == length ) return 1 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num . charAt ( i ) - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; }
int lenOfLongestGP ( int set [ ] , int n ) { if ( n < 2 ) { return n ; } if ( n == 2 ) { return ( set [ 1 ] % set [ 0 ] == 0 ? 2 : 1 ) ; } Arrays . sort ( set ) ; int L [ ] [ ] = new int [ n ] [ n ] ; int llgp = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( set [ n - 1 ] % set [ i ] == 0 ) { L [ i ] [ n - 1 ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i ] [ n - 1 ] = 1 ; } } L [ n - 1 ] [ n - 1 ] = 1 ; for ( int j = n - 2 ; j >= 1 ; -- j ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) { ++ k ; } else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i ] [ j ] = 1 ; } -- i ; } else { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; if ( L [ i ] [ j ] > llgp ) { llgp = L [ i ] [ j ] ; } } else { L [ i ] [ j ] = 1 ; } -- i ; ++ k ; } } while ( i >= 0 ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i ] [ j ] = 1 ; } -- i ; } } return llgp ; }
int findMinRec ( int arr [ ] , int i , int sumCalculated , int sumTotal ) { if ( i == 0 ) return Math . abs ( ( sumTotal - sumCalculated ) - sumCalculated ) ; return Math . min ( findMinRec ( arr , i - 1 , sumCalculated + arr [ i - 1 ] , sumTotal ) , findMinRec ( arr , i - 1 , sumCalculated , sumTotal ) ) ; }
int findMin ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; boolean dp [ ] [ ] = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) dp [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( arr [ i - 1 ] <= j ) dp [ i ] [ j ] |= dp [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } int diff = Integer . MAX_VALUE ; for ( int j = sum / 2 ; j >= 0 ; j -- ) { if ( dp [ n ] [ j ] == true ) { diff = sum - 2 * j ; break ; } } return diff ; }
int minSize ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return minSizeRec ( arr , 0 , n - 1 , k ) ; }
int minRemovals ( int arr [ ] , int l , int h ) { if ( l >= h ) return 0 ; int mn = min ( arr , l , h ) ; int mx = max ( arr , l , h ) ; if ( 2 * mn > mx ) return 0 ; return min ( minRemovals ( arr , l + 1 , h ) , minRemovals ( arr , l , h - 1 ) ) + 1 ; }
int optimalStrategyOfGame ( int arr [ ] , int n ) { int table [ ] [ ] = new int [ n ] [ n ] ; int gap , i , j , x , y , z ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x , y ) , arr [ j ] + Math . min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
int lps ( char seq [ ] , int i , int j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return lps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; }
int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int min = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
void solve ( int arr [ ] , int N ) { HashMap < Integer , Integer > M = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { M . put ( i , arr [ i ] ) ; } Arrays . sort ( arr ) ; HashMap < Integer , Integer > Count = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Count . put ( arr [ i ] , ( int ) Math . pow ( 2 , N - i - 1 ) ) ; } for ( Map . Entry < Integer , Integer > m : M . entrySet ( ) ) { System . out . print ( Count . get ( m . getValue ( ) ) + " " ) ; } }
int min_time_to_cut ( int N ) { if ( N == 0 ) return 0 ; return ( int ) Math . ceil ( Math . log ( N ) / Math . log ( 2 ) ) ; }
void q3 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( "Yes" ) ; return ; } if ( s . charAt ( i ) == 'a' ) q4 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
int nthTerm ( int N ) { int nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
void start ( char c ) { if ( c == 't' c == 'T' ) dfa = 1 ; }
void isEqualSubstring ( String str , int x ) { int n = str . length ( ) ; int i = 0 ; while ( i < n && i < x ) { if ( str . charAt ( i ) != str . charAt ( n - i - 1 ) ) { System . out . println ( "false" ) ; return ; } i ++ ; } System . out . println ( "true" ) ; }
void canMakeEqual ( String S ) { int N = S . length ( ) ; int weightOfString = 0 ; for ( int i = 0 ; i < N ; i ++ ) { weightOfString += S . charAt ( i ) - 'a' + 1 ; } if ( weightOfString % N == 0 ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
void updateTree ( char s [ ] , treeNode tree [ ] , int start , int end , int treenode , int idx , char X ) { if ( ( start == end ) && ( idx == start ) ) { s [ idx ] = X ; tree [ treenode ] . square_sum = ( int ) Math . pow ( X - 'a' + 1 , 2 ) ; return ; } int mid = start + ( ( end - start ) / 2 ) ; if ( idx <= mid ) { updateTree ( s , tree , start , mid , ( 2 * treenode ) , idx , X ) ; } else { updateTree ( s , tree , mid + 1 , end , ( 2 * treenode ) + 1 , idx , X ) ; } tree [ treenode ] . square_sum = tree [ ( 2 * treenode ) ] . square_sum + tree [ ( 2 * treenode ) + 1 ] . square_sum ; }
void getPalindromePath ( Node root ) { finalAns = "$" ; lexicographicallySmall ( root , "" ) ; if ( finalAns == "$" ) System . out . print ( "No Palindromic Path exists" ) ; else System . out . print ( finalAns ) ; }
int permute ( int n , int r ) { int ans = 0 ; ans = ( fact ( n ) / fact ( n - r ) ) ; return ans ; }
boolean isValid ( char a1 , char a2 , String str , int flag ) { char v1 , v2 ; if ( flag == 0 ) { v1 = str . charAt ( 4 ) ; v2 = str . charAt ( 3 ) ; } else { v1 = str . charAt ( 1 ) ; v2 = str . charAt ( 0 ) ; } if ( v1 != a1 && v1 != '?' ) return false ; if ( v2 != a2 && v2 != '?' ) return false ; return true ; }
int minDel ( String s1 , String s2 ) { int i = s1 . length ( ) ; int j = s2 . length ( ) ; while ( i > 0 && j > 0 ) { if ( s1 . charAt ( i - 1 ) != s2 . charAt ( j - 1 ) ) { break ; } i -- ; j -- ; } return i + j ; }
boolean can_Construct ( String S , int K ) { Map < Character , Integer > m = new HashMap < > ( ) ; int p = 0 ; if ( S . length ( ) == K ) return true ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) m . put ( S . charAt ( i ) , m . getOrDefault ( S . charAt ( i ) , 0 ) + 1 ) ; if ( K > S . length ( ) ) return false ; else { for ( Integer h : m . values ( ) ) { if ( h % 2 != 0 ) p = p + 1 ; } } if ( K < p ) return false ; return true ; }
int bcdToDecimal ( String s ) { int len = s . length ( ) ; int check = 0 , check0 = 0 ; int num = 0 , sum = 0 ; int mul = 1 , rev = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { sum += ( s . charAt ( i ) - '0' ) * mul ; mul *= 2 ; check ++ ; if ( check == 4 i == 0 ) { if ( sum == 0 && check0 == 0 ) { num = 1 ; check0 = 1 ; } else { num = num * 10 + sum ; } check = 0 ; sum = 0 ; mul = 1 ; } } while ( num > 0 ) { rev = rev * 10 + ( num % 10 ) ; num /= 10 ; } if ( check0 == 1 ) return rev - 1 ; return rev ; }
boolean isPossibleSum ( int N ) { if ( isPrime ( N ) && isPrime ( N - 2 ) ) { return true ; } else { return false ; } }
void findMaxFrequency ( String s ) { int arr [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) arr [ s . charAt ( i ) - 'a' ] ++ ; HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] != 0 ) { if ( hash . containsKey ( arr [ i ] ) ) { hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; } else { hash . put ( arr [ i ] , 1 ) ; } } int max_count = 0 , res = - 1 ; for ( Map . Entry < Integer , Integer > i : hash . entrySet ( ) ) { if ( max_count < i . getValue ( ) ) { res = i . getKey ( ) ; max_count = i . getValue ( ) ; } } System . out . println ( "Frequency " + res + " is repeated " + max_count + " times" ) ; }
int checkIfStartsWithVowels ( char [ ] str ) { if ( ! ( str [ 0 ] == 'A' str [ 0 ] == 'a' str [ 0 ] == 'E' str [ 0 ] == 'e' str [ 0 ] == 'I' str [ 0 ] == 'i' str [ 0 ] == 'O' str [ 0 ] == 'o' str [ 0 ] == 'U' str [ 0 ] == 'u' ) ) return 1 ; else return 0 ; }
boolean xExistsInY ( String x , String y ) { if ( x . length ( ) > y . length ( ) ) return false ; int [ ] cnt_x = new int [ MAX ] ; int [ ] cnt = new int [ MAX ] ; for ( int i = 0 ; i < x . length ( ) ; i ++ ) cnt_x [ x . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < x . length ( ) ; i ++ ) cnt [ y . charAt ( i ) - 'a' ] ++ ; if ( areEqual ( cnt_x , cnt ) ) return true ; for ( int i = 1 ; i < y . length ( ) - x . length ( ) + 1 ; i ++ ) { cnt [ y . charAt ( i - 1 ) - 'a' ] -- ; cnt [ y . charAt ( i + x . length ( ) - 1 ) - 'a' ] ++ ; if ( areEqual ( cnt , cnt_x ) ) return true ; } return false ; }
void updateFreq ( String str , int freq [ ] ) { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { freq [ str . charAt ( i ) - 'a' ] ++ ; } }
int cntWays ( String str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; }
int countSticks ( String str , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ str . charAt ( i ) - '0' ] ) ; } return cnt ; }
int countTotalDistinct ( String str ) { int cnt = 0 ; HashSet < String > items = new HashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { String temp = "" ; HashSet < Character > ans = new HashSet < > ( ) ; for ( int j = i ; j < str . length ( ) ; ++ j ) { temp = temp + str . charAt ( j ) ; ans . add ( str . charAt ( j ) ) ; if ( ! items . contains ( temp ) ) { items . add ( temp ) ; cnt += ans . size ( ) ; } } } return cnt ; }
void getOrgString ( String s ) { System . out . print ( s . charAt ( 0 ) ) ; int i = 1 ; while ( i < s . length ( ) ) { if ( s . charAt ( i ) >= 'A' && s . charAt ( i ) <= 'Z' ) System . out . print ( " " + Character . toLowerCase ( s . charAt ( i ) ) ) ; else System . out . print ( s . charAt ( i ) ) ; i ++ ; } }
int getIndex ( String s1 , String s2 , int len ) { int i = 0 , j = len - 1 ; while ( i < j ) { if ( s1 . charAt ( i ) != s2 . charAt ( j ) ) { break ; } i ++ ; j -- ; } if ( i == j ) { return i - 1 ; } else if ( isPalindrome ( s2 , i , j ) ) return i - 1 ; else if ( isPalindrome ( s1 , i , j ) ) return j ; return - 1 ; }
int countSubStrings ( String s , String anotherStr , int k ) { boolean illegal [ ] = new boolean [ MAX_CHAR ] ; for ( int i = 0 ; i < anotherStr . length ( ) ; i ++ ) { illegal [ anotherStr . charAt ( i ) ] = true ; } HashSet < String > us = new HashSet < String > ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { String ss = "" ; int count = 0 ; for ( int j = i ; j < s . length ( ) ; ++ j ) { if ( illegal [ s . charAt ( j ) ] ) { ++ count ; } ss = ss + s . charAt ( j ) ; if ( count <= k ) { us . add ( ss ) ; } else { break ; } } } return us . size ( ) ; }
int PrimeCharacters ( String s ) { boolean prime [ ] = new boolean [ max_val + 1 ] ; for ( int i = 0 ; i <= max_val ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( prime [ ( int ) ( s . charAt ( i ) ) ] ) count ++ ; } return count ; }
boolean matchPattern ( String s ) { int count = 0 ; int n = s . length ( ) ; int i = 0 ; while ( i < n ) { while ( i < n && s . charAt ( i ) == 'a' ) { count ++ ; i ++ ; } while ( i < n && s . charAt ( i ) == 'b' ) { count -- ; i ++ ; } if ( count != 0 ) return false ; } return true ; }
boolean compare ( char [ ] arr1 , char [ ] arr2 ) { for ( int i = 0 ; i < ALL_CHARS ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }
int maximum_one ( String s , int n ) { int cnt_one = 0 ; int max_cnt = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) { cnt_one ++ ; temp ++ ; } else { max_cnt = Math . max ( max_cnt , temp ) ; temp = 0 ; } } max_cnt = Math . max ( max_cnt , temp ) ; int [ ] left = new int [ n ] ; int right [ ] = new int [ n ] ; if ( s . charAt ( 0 ) == '1' ) left [ 0 ] = 1 ; else left [ 0 ] = 0 ; if ( s . charAt ( n - 1 ) == '1' ) right [ n - 1 ] = 1 ; else right [ n - 1 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) left [ i ] = left [ i - 1 ] + 1 ; else left [ i ] = 0 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '1' ) right [ i ] = right [ i + 1 ] + 1 ; else right [ i ] = 0 ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( s . charAt ( i ) == '0' ) { int sum = left [ i - 1 ] + right [ i + 1 ] ; if ( sum < cnt_one ) max_cnt = Math . max ( max_cnt , sum + 1 ) ; else max_cnt = Math . max ( max_cnt , sum ) ; } } return max_cnt ; }
char bitToBeFlipped ( String s ) { char last = s . charAt ( s . length ( ) - 1 ) ; char first = s . charAt ( 0 ) ; if ( last == first ) { if ( last == '0' ) { return '1' ; } else { return '0' ; } } else if ( last != first ) { return last ; } return last ; }
int countPalindrome ( String str ) { int n = str . length ( ) ; int sum = 0 ; int hashTable [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { hashTable [ str . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( hashTable [ i ] != 0 ) { sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) / 2 ) ; } } return sum ; }
int smallestNumber ( int n ) { int num = 0 ; String s = "" ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int digit = s . charAt ( i ) - '0' ; if ( ( digit & 1 ) == 0 ) { index = i ; break ; } } if ( index == - 1 ) { return duplicate ; } for ( int i = 0 ; i < index ; i ++ ) { num = num * 10 + ( s . charAt ( i ) - '0' ) ; } num = num * 10 + ( s . charAt ( index ) - '0' + 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) { num = num * 10 + 1 ; } return num ; }
int count_carry ( String a , String b ) { int carry = 0 ; int count = 0 ; int len_a = a . length ( ) , len_b = b . length ( ) ; while ( len_a != 0 len_b != 0 ) { int x = 0 , y = 0 ; if ( len_a > 0 ) { x = a . charAt ( len_a - 1 ) - '0' ; len_a -- ; } if ( len_b > 0 ) { y = b . charAt ( len_b - 1 ) - '0' ; len_b -- ; } int sum = x + y + carry ; if ( sum >= 10 ) { carry = 1 ; count ++ ; } else carry = 0 ; } return count ; }
int leastCount ( String s1 , String s2 , int n ) { int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { count1 [ s1 . charAt ( i ) - 'a' ] += 1 ; count2 [ s2 . charAt ( i ) - 'a' ] += 1 ; } int res = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( count1 [ i ] != 0 ) { res += Math . abs ( count1 [ i ] - count2 [ i ] ) ; } } return res ; }
void allCharactersSame ( String s ) { Set < Character > s1 = new HashSet < Character > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) s1 . add ( s . charAt ( i ) ) ; if ( s1 . size ( ) == 1 ) System . out . println ( "YES" ) ; else System . out . println ( "NO" ) ; }
boolean check_isogram ( String str ) { int length = str . length ( ) ; int mapHash [ ] = new int [ 26 ] ; for ( int i = 0 ; i < length ; i ++ ) { mapHash [ str . charAt ( i ) - 'a' ] ++ ; if ( mapHash [ str [ i ] - 'a' ] > 1 ) { return false ; } } return true ; }
int maxLengthNonPalinSubstring ( String str ) { int n = str . length ( ) ; char ch = str . charAt ( 0 ) ; int i = 1 ; for ( i = 1 ; i < n ; i ++ ) if ( str . charAt ( i ) != ch ) break ; if ( i == n ) return 0 ; if ( isPalindrome ( str ) ) return n - 1 ; return n ; }
void traverseTree ( Node root ) { if ( root == null ) return ; System . out . print ( root . data + " " ) ; if ( root . child == null ) return ; Queue < Node > q = new LinkedList < > ( ) ; Node curr = root . child ; q . add ( curr ) ; while ( ! q . isEmpty ( ) ) { curr = q . peek ( ) ; q . remove ( ) ; while ( curr != null ) { System . out . print ( curr . data + " " ) ; if ( curr . child != null ) { q . add ( curr . child ) ; } curr = curr . next ; } } }
void transpose ( int mat [ ] [ ] , int tr [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) tr [ i ] [ j ] = mat [ j ] [ i ] ; }
void qType1 ( int l , int x , char str [ ] ) { str [ l - 1 ] = ( char ) x ; }
int getFrequency ( int tree [ ] [ ] , int idx , int i ) { int sum = 0 ; while ( idx > 0 ) { sum += tree [ idx ] [ i ] ; idx -= ( idx & - idx ) ; } return sum ; }
void qType2 ( int tree [ ] [ ] , int l , int r , char str [ ] ) { int count = 0 ; for ( int i = 1 ; i <= 26 ; i ++ ) { if ( l == 1 ) { if ( getFrequency ( tree , r , i ) % 2 == 1 ) count ++ ; } else { if ( ( getFrequency ( tree , r , i ) - getFrequency ( tree , l - 1 , i ) ) % 2 == 1 ) count ++ ; } } if ( count <= 1 ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return Math . abs ( d1 - d2 ) ; }
boolean isValid ( int row , int col ) { return ( row >= 0 ) && ( col >= 0 ) && ( row < ROW ) && ( col < COL ) ; }
long comb ( int n , int r ) { long res = fact [ n ] / fact [ r ] ; res /= fact [ n - r ] ; return res ; }
void getMinPathSum ( Map < Integer , ArrayList < pair > > graph , boolean [ ] visited , ArrayList < Integer > necessary , int source , int dest , int currSum ) { if ( src == dest ) { boolean flag = true ; for ( int i : necessary ) { if ( ! visited [ i ] ) { flag = false ; break ; } } if ( flag ) minSum = Math . min ( minSum , currSum ) ; return ; } else { visited [ src ] = true ; for ( pair node : graph . get ( src ) ) { if ( ! visited [ node . first ] ) { visited [ node . first ] = true ; getMinPathSum ( graph , visited , necessary , node . first , dest , currSum + node . second ) ; visited [ node . first ] = false ; } } visited [ src ] = false ; } }
boolean is_clique ( int b ) { for ( int i = 1 ; i < b ; i ++ ) { for ( int j = i + 1 ; j < b ; j ++ ) if ( graph [ store [ i ] ] [ store [ j ] ] == 0 ) return false ; } return true ; }
void generateAllBinaryStrings ( int n , int arr [ ] , int i ) { if ( i == n ) { printTheArray ( arr , n ) ; return ; } arr [ i ] = 0 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; arr [ i ] = 1 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; }
int uniquePaths ( int [ ] [ ] grid ) { int n = grid . length , m = grid [ 0 ] . length ; boolean [ ] [ ] vis = new boolean [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { Arrays . fill ( vis [ i ] , false ) ; } int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { if ( grid [ i ] [ j ] == 0 ) z_count ++ ; else if ( grid [ i ] [ j ] == 1 ) { x = i ; y = j ; } } } dfs ( x , y , grid , vis , 0 , z_count ) ; return ans ; }
boolean isPrime ( int x ) { int sqroot = ( int ) Math . sqrt ( x ) ; if ( x == 1 ) return false ; for ( int i = 2 ; i <= sqroot ; i ++ ) if ( x % i == 0 ) return false ; return true ; }
int minStepsRecur ( int height [ ] , int l , int r , int h ) { if ( l >= r ) return 0 ; int m = l ; for ( int i = l ; i < r ; i ++ ) if ( height [ i ] < height [ m ] ) m = i ; return Math . min ( r - l , minStepsRecur ( height , l , m , height [ m ] ) + minStepsRecur ( height , m + 1 , r , height [ m ] ) + height [ m ] - h ) ; }
void findFrequency ( int [ ] arr , int n ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! mp . containsKey ( arr [ i ] ) ) mp . put ( arr [ i ] , 0 ) ; mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } for ( Map . Entry < Integer , Integer > kvp : mp . entrySet ( ) ) { System . out . println ( "Element " + kvp . getKey ( ) + " occurs " + kvp . getValue ( ) + " times" ) ; } }
void secondary_polygon ( int Angle ) { int edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { int edges_max_secondary = edges_primary / 2 ; System . out . println ( edges_max_secondary + 3 ) ; } else System . out . println ( "Not Possible" ) ; }
void parallel ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { if ( ( - ( a1 / b1 ) ) == ( - ( a2 / b2 ) ) ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
int No_of_cubes ( int N , int K ) { int No = 0 ; No = ( N - K + 1 ) ; No = ( int ) Math . pow ( No , 3 ) ; return No ; }
void updateArray ( int x1 , int y1 , int x2 , int y2 ) { for ( int i = x1 ; i < x2 ; i ++ ) { for ( int j = y1 ; j < y2 ; j ++ ) { arr [ i ] [ j ] = true ; } } }
int calcAngle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) System . out . printf ( "Wrong input" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ; int minute_angle = ( int ) ( 6 * m ) ; int angle = Math . abs ( hour_angle - minute_angle ) ; angle = Math . min ( 360 - angle , angle ) ; return angle ; }
int heptacontagonNum ( int n ) { return ( 68 * n * n - 66 * n ) / 2 ; }
int octacontagonNum ( int n ) { return ( 78 * n * n - 76 * n ) / 2 ; }
int Pentadecagonal_num ( int n ) { return ( 13 * n * n - 11 * n ) / 2 ; }
int check ( int n , int m ) { if ( m % n == 0 ) { System . out . print ( "YES" ) ; } else { System . out . print ( "NO" ) ; } return 0 ; }
void dist ( double x1 , double y1 , double x2 , double y2 , double r ) { System . out . println ( "The shortest distance " + "between a point and a circle is " + ( Math . sqrt ( ( Math . pow ( ( x2 - x1 ) , 2 ) ) + ( Math . pow ( ( y2 - y1 ) , 2 ) ) ) - r ) ) ; }
float ellipse ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float x = ( float ) ( 3.14 * l * b ) / 4 ; return x ; }
float squareSide ( float a ) { if ( a < 0 ) return - 1 ; float x = ( 0.423f * a ) ; return x ; }
float CubeVolume ( float d ) { float Volume ; Volume = ( float ) ( Math . sqrt ( 3 ) * Math . pow ( d , 3 ) ) / 9 ; return Volume ; }
double cyl ( double r , double h ) { if ( r < 0 && h < 0 ) return - 1 ; double R = ( 2 * r ) / 3 ; double H = ( 2 * h ) / 3 ; double V = 3.14 * Math . pow ( R , 2 ) * H ; return V ; }
float perimeter ( float r ) { return ( float ) ( ( 3.14 ) * ( r ) ) ; }
long hexadecagonalNum ( long n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
int intersection ( int n ) { return n * ( n - 1 ) ; }
int numberOfWays ( int x ) { int dp [ ] = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
void check_and_print ( double required_time , double given_time ) { if ( required_time < given_time ) System . out . print ( "Overflow" ) ; else if ( required_time > given_time ) System . out . print ( "Underflow" ) ; else System . out . print ( "Filled" ) ; }
double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
int directionOfPoint ( point A , point B , point P ) { B . x -= A . x ; B . y -= A . y ; P . x -= A . x ; P . y -= A . y ; int cross_product = B . x * P . y - B . y * P . x ; if ( cross_product > 0 ) return RIGHT ; if ( cross_product < 0 ) return LEFT ; return ZERO ; }
double areaCube ( double a ) { return ( a * a * a ) ; }
int sqDist ( ArrayList < Integer > p1 , ArrayList < Integer > p2 ) { return ( p1 . get ( 0 ) - p2 . get ( 0 ) ) * ( p1 . get ( 0 ) - p2 . get ( 0 ) ) + ( p1 . get ( 1 ) - p2 . get ( 1 ) ) * ( p1 . get ( 1 ) - p2 . get ( 1 ) ) ; }
boolean isSquare ( Point p1 , Point p2 , Point p3 , Point p4 ) { if ( d2 == 0 d3 == 0 d4 == 0 ) return false ; if ( d2 == d3 && 2 * d2 == d4 && 2 * distSq ( p2 , p4 ) == distSq ( p2 , p3 ) ) { return true ; } if ( d3 == d4 && 2 * d3 == d2 && 2 * distSq ( p3 , p2 ) == distSq ( p3 , p4 ) ) { return true ; } if ( d2 == d4 && 2 * d2 == d3 && 2 * distSq ( p2 , p3 ) == distSq ( p2 , p4 ) ) { return true ; } return false ; }
int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
int lastPositiveElement ( int [ ] arr ) { int N = arr . length ; if ( N == 1 ) return arr [ 0 ] ; int greatest = - 1 , secondGreatest = - 1 ; for ( int x : arr ) { if ( x >= greatest ) { secondGreatest = greatest ; greatest = x ; } else if ( x >= secondGreatest ) { secondGreatest = x ; } } return greatest - secondGreatest ; }
int countQuadruples ( int A [ ] , int N ) { int ans = 0 ; HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . containsKey ( A [ i ] ) ) ans += freq . get ( A [ i ] ) ; for ( int j = 0 ; j < i ; j ++ ) { for ( int k = 0 ; k < j ; k ++ ) { if ( freq . containsKey ( A [ i ] * A [ j ] * A [ k ] ) ) { freq . put ( A [ i ] * A [ j ] * A [ k ] , freq . get ( A [ i ] * A [ j ] * A [ k ] ) + 1 ) ; } else { freq . put ( A [ i ] * A [ j ] * A [ k ] , 1 ) ; } } } } return ans ; }
int countArrays ( int n , int k ) { int mod = 1000000007 ; int ans = power ( n , k , mod ) ; return ans ; }
void printInorder ( Node root ) { if ( root == null ) return ; printInorder ( root . left ) ; System . out . print ( root . data + " " ) ; printInorder ( root . right ) ; }
void countWays ( String s , String t ) { int n = s . length ( ) ; int sum1 = 0 , sum2 = 0 , K = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) { sum1 ++ ; } else sum1 -- ; } int m = t . length ( ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( t . charAt ( i ) == '1' ) { sum2 ++ ; } else if ( t . charAt ( i ) == '0' ) { sum2 -- ; } else K ++ ; } int P = Math . abs ( sum1 - sum2 ) ; if ( ( P > K ) || ( K - P ) % 2 == 1 ) { System . out . println ( 0 ) ; return ; } System . out . println ( nCr ( K , ( P + K ) / 2 ) ) ; }
int pathCountDP ( int [ ] [ ] mat , int k ) { for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) for ( int l = 0 ; l < MAX_K ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) ; }
boolean isadjacent ( char prev , char curr ) { return ( ( curr - prev ) == 1 ) ; }
int getLen ( char mat [ ] [ ] , char s ) { for ( int i = 0 ; i < R ; ++ i ) for ( int j = 0 ; j < C ; ++ j ) dp [ i ] [ j ] = - 1 ; int ans = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == s ) { for ( int k = 0 ; k < 8 ; k ++ ) ans = Math . max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , s ) ) ; } } } return ans ; }
Boolean isSmith ( int n ) { int original_no = n ; int pDigitSum = 0 ; for ( int i = 0 ; primes . get ( i ) <= n / 2 ; i ++ ) { while ( n % primes . get ( i ) == 0 ) { int p = primes . get ( i ) ; n = n / p ; while ( p > 0 ) { pDigitSum += ( p % 10 ) ; p = p / 10 ; } } } if ( n != 1 && n != original_no ) { while ( n > 0 ) { pDigitSum = pDigitSum + n % 10 ; n = n / 10 ; } } int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits = sumDigits + original_no % 10 ; original_no = original_no / 10 ; } return ( pDigitSum == sumDigits ) ; }
void smallestPermutation ( int [ ] arr , int N ) { boolean [ ] w = new boolean [ 2 * N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { w [ arr [ i ] ] = true ; } Set < Integer > S = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= 2 * N ; i ++ ) { if ( ! w [ i ] ) S . add ( i ) ; } boolean found = true ; Vector < Integer > P = new Vector < Integer > ( ) ; int [ ] p = { 4 , 5 , 1 , 2 , 3 , 6 } ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . contains ( arr [ i ] ) ) { found = false ; break ; } P . add ( arr [ i ] ) ; P . add ( arr [ i ] ) ; S . remove ( arr [ i ] ) ; } if ( ! found ) { System . out . print ( "-1" ) ; } else { for ( int i = 0 ; i < 2 * N ; i ++ ) System . out . print ( p [ i ] + " " ) ; } }
int findlcm ( int arr [ ] , int n ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; } return ans ; }
void findLast ( int mat [ ] [ ] ) { int m = 3 ; int n = 3 ; Set < Integer > rows = new HashSet < Integer > ( ) ; Set < Integer > cols = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( mat [ i ] [ j ] > 0 ) ) { rows . add ( i ) ; cols . add ( j ) ; } } } int avRows = m - rows . size ( ) ; int avCols = n - cols . size ( ) ; int choices = Math . min ( avRows , avCols ) ; if ( ( choices & 1 ) != 0 ) System . out . println ( "P1" ) ; else System . out . println ( "P2" ) ; }
void nearestPowerDiff ( int [ ] arr , int N , int a , int b ) { for ( int i = 0 ; i < N ; i ++ ) { int log_a = ( int ) ( Math . log ( arr [ i ] ) / Math . log ( a ) ) ; int A = ( int ) ( Math . pow ( a , log_a ) ) ; int B = ( int ) ( Math . pow ( a , log_a + 1 ) ) ; if ( ( arr [ i ] - A ) < ( B - arr [ i ] ) ) log_a = A ; else log_a = B ; int log_b = ( int ) ( Math . log ( arr [ i ] ) / Math . log ( b ) ) ; A = ( int ) ( Math . pow ( b , log_b ) ) ; B = ( int ) ( Math . pow ( b , log_b + 1 ) ) ; if ( ( arr [ i ] - A ) < ( B - arr [ i ] ) ) log_b = A ; else log_b = B ; arr [ i ] = Math . abs ( log_a - log_b ) ; } printArray ( arr , N ) ; }
boolean checkEvenPower ( long N ) { if ( ( N & ( N - 1 ) ) != 0 ) return false ; N = N & 0x55555555 ; return ( N > 0 ) ; }
int distinct ( int arr [ ] , int n ) { Set < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { set . add ( arr [ i ] ) ; } return set . size ( ) ; }
int power ( int x , int y ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
boolean isNonDeficient ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { sum = sum + i ; } else { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum >= 2 * n ; }
int lastElement ( int arr [ ] , int n ) { int sum = 0 ; int multiplier = n % 2 == 0 ? - 1 : 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * multiplier ; multiplier = multiplier * ( n - 1 - i ) / ( i + 1 ) * ( - 1 ) ; } return sum ; }
