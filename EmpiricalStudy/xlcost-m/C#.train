bool isPerfect ( int N ) { int sumOfDivisors = 1 ; for ( int i = 2 ; i <= N / 2 ; ++ i ) { if ( N % i == 0 ) { sumOfDivisors += i ; } } if ( sumOfDivisors == N ) { return true ; } else return false ; }
void countPerfectNumbers ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; ++ i ) { if ( isPerfect ( arr [ i ] ) ) { int sum = sumOfDigits ( arr [ i ] ) ; if ( isPerfect ( sum ) ) { Console . Write ( arr [ i ] + " " ) ; } } } }
bool issafe ( int m , int n , int i , int j ) { if ( i < 0 ) return false ; if ( j < 0 ) return false ; if ( i >= m ) return false ; if ( j >= n ) return false ; return true ; }
int [ ] endpoints ( int [ , ] arr , int m , int n ) { int i = 0 ; int j = 0 ; int current_i = 0 ; int current_j = 0 ; char current_d = 'r' ; Dictionary < char , char > rcd = new Dictionary < char , char > ( ) ; rcd [ 'l' ] = 'u' ; rcd [ 'u' ] = 'r' ; rcd [ 'r' ] = 'd' ; rcd [ 'd' ] = 'l' ; while ( issafe ( m , n , i , j ) ) { current_i = i ; current_j = j ; if ( arr [ i , j ] == 1 ) { char move_in = rcd [ current_d ] ; arr [ i , j ] = 0 ; if ( move_in == 'u' ) i -= 1 ; else if ( move_in == 'd' ) i += 1 ; else if ( move_in == 'l' ) j -= 1 ; else if ( move_in == 'r' ) j += 1 ; current_d = move_in ; } else { if ( current_d == 'u' ) i -= 1 ; else if ( current_d == 'd' ) i += 1 ; else if ( current_d == 'l' ) j -= 1 ; else if ( current_d == 'r' ) j += 1 ; } } return new int [ ] { current_i , current_j } ; }
int maxPresum ( List < int > a , List < int > b ) { int X = Math . Max ( a [ 0 ] , 0 ) ; for ( int i = 1 ; i < a . Count ; i ++ ) { a [ i ] += a [ i - 1 ] ; X = Math . Max ( X , a [ i ] ) ; } int Y = Math . Max ( b [ 0 ] , 0 ) ; for ( int i = 1 ; i < b . Count ; i ++ ) { b [ i ] += b [ i - 1 ] ; Y = Math . Max ( Y , b [ i ] ) ; } return X + Y ; }
int findSum ( TreeNode root ) { Queue < TreeNode > que = new Queue < TreeNode > ( ) ; que . Enqueue ( root ) ; int ans = 0 ; while ( que . Count > 0 ) { int leaf = 0 ; int nonleaf = 0 ; int length = que . Count ; while ( length > 0 ) { TreeNode temp = que . Peek ( ) ; que . Dequeue ( ) ; if ( temp . left == null && temp . right == null ) leaf += temp . val ; else nonleaf += temp . val ; if ( temp . left != null ) que . Enqueue ( temp . left ) ; if ( temp . right != null ) que . Enqueue ( temp . right ) ; length -= 1 ; } ans += ( leaf & nonleaf ) ; } return ans ; }
void fizzBuzz ( int N ) { int count3 = 0 ; int count5 = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count3 ++ ; count5 ++ ; bool flag = false ; if ( count3 == 3 ) { Console . Write ( "Fizz" ) ; count3 = 0 ; flag = true ; } if ( count5 == 5 ) { Console . Write ( "Buzz" ) ; count5 = 0 ; flag = true ; } if ( ! flag ) { Console . Write ( i ) ; } Console . Write ( " " ) ; } }
void checkElementsOnDiagonal ( int [ , ] M , int N ) { int flag = 1 ; SieveOfEratosthenes ( 1000000 ) ; for ( int i = 0 ; i < N ; i ++ ) { bool flg = ( bool ) ( prime [ M [ i , i ] ] && prime [ M [ i , N - 1 - i ] ] ) ; int val = ( flg ) ? 1 : 0 ; flag &= val ; } if ( flag != 0 ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
List < int > circularPermutation ( int n , int start ) { List < int > res = new List < int > ( ) { 0 } ; List < int > ret = new List < int > ( ) ; int index = - 1 ; for ( int k = 0 , add = 1 << k ; k < n ; k ++ , add = 1 << k ) { for ( int i = res . Count - 1 ; i >= 0 ; i -- ) { if ( res [ i ] + add == start ) index = res . Count ; res . Add ( res [ i ] + add ) ; } } if ( start == 0 ) return res ; while ( ret . Count < res . Count ) { ret . Add ( res [ index ] ) ; index = ( index + 1 ) % res . Count ; } return ret ; }
int countPairs ( int [ ] a , int n ) { int count = 0 ; Dictionary < double , int > mp = new Dictionary < double , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int y = a [ i ] ; if ( y != 0 && y != 1 ) { double x = ( ( y * 1.0 ) / ( 1 - y ) ) * y ; if ( ! mp . ContainsKey ( x ) ) mp [ x ] = 0 ; count += mp [ x ] ; } if ( ! mp . ContainsKey ( y ) ) mp [ y ] = 0 ; mp [ y ] ++ ; } return count ; }
void sieveOfPrimes ( ) { for ( int i = 0 ; i < 10000000 ; i ++ ) { sieve [ i ] = 1 ; } int N = 1000000 ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( sieve [ i ] == 0 ) continue ; for ( int j = i * i ; j <= N ; j += i ) sieve [ j ] = 0 ; } }
void getArray ( int [ ] arr , int N ) { int [ ] A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = 0 ; } List < int > v = new List < int > ( ) ; sieveOfPrimes ( ) ; for ( int i = 2 ; i <= 1000000 ; i ++ ) if ( sieve [ i ] != 0 ) v . Add ( i ) ; int j = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int ind = arr [ i ] ; if ( A [ i ] != 0 ) continue ; else if ( A [ ind ] != 0 ) A [ i ] = A [ ind ] ; else { int prime = v [ j ++ ] ; A [ i ] = prime ; A [ ind ] = A [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( A [ i ] + " " ) ; } }
bool contains ( int num , int K , int Base ) { bool isThere = false ; while ( num > 0 ) { int remainder = num % Base ; if ( remainder == K ) { isThere = true ; } num /= Base ; } return isThere ; }
int numberOfTiles ( int n , int m ) { if ( n % 2 == 1 ) { return - 1 ; } return ( m * n ) / 2 ; }
void canMakeEqual ( int [ ] arr1 , int [ ] arr2 , int N ) { int count = 0 ; int arr1_one = 0 , arr1_zero = 0 ; int arr2_one = 0 , arr2_zero = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] == 1 ) { arr1_one ++ ; } else if ( arr1 [ i ] == 0 ) { arr1_zero ++ ; } if ( arr2 [ i ] == 1 ) { arr2_one ++ ; } else if ( arr2 [ i ] == 0 ) { arr2_zero ++ ; } } if ( arr1_one != arr2_one arr1_zero != arr2_zero ) { Console . WriteLine ( "No" ) ; return ; } for ( int i = 0 ; i < N ; i ++ ) { count = count + ( arr1 [ i ] - arr2 [ i ] ) ; if ( count < 0 ) { Console . WriteLine ( "No" ) ; return ; } } Console . WriteLine ( "Yes" ) ; }
long findNthNumber ( long N ) { long result = 0 ; long p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = N / 9 ; p = p * 10 ; } return result ; }
int cntMaxOperationToMakeN_1_0 ( int [ ] arr , int N ) { int cntOp = 0 ; List < int > PQ = new List < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { PQ . Add ( arr [ i ] ) ; } PQ . Sort ( ) ; PQ . Reverse ( ) ; while ( PQ . Count > 1 ) { int X = PQ [ 0 ] ; PQ . RemoveAt ( 0 ) ; int Y = PQ [ 0 ] ; PQ . RemoveAt ( 0 ) ; X -- ; Y -- ; if ( X != 0 ) { PQ . Add ( X ) ; PQ . Sort ( ) ; PQ . Reverse ( ) ; } if ( Y != 0 ) { PQ . Add ( Y ) ; PQ . Sort ( ) ; PQ . Reverse ( ) ; } cntOp += 1 ; } return cntOp ; }
void checkSamePosition ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int temp = ( ( i + arr [ i ] ) % n + n ) % n ; if ( mp . ContainsKey ( temp ) ) { Console . Write ( "Yes" ) ; return ; } mp [ temp ] = 1 ; } Console . Write ( "No" ) ; }
void sumFib ( int N ) { long num = ( long ) Math . Round ( Math . Pow ( ( Math . Sqrt ( 5 ) + 1 ) / 2.0 , N + 2 ) / Math . Sqrt ( 5 ) ) ; Console . WriteLine ( num - 1 ) ; }
void sumFib ( int N ) { double num = ( 1 - Math . Sqrt ( 5 ) ) / 2 ; double val = Math . Round ( Math . Abs ( 1 / ( Math . Pow ( num , N + 2 ) + Math . Pow ( num , N + 1 ) + Math . Pow ( num , N ) + Math . Pow ( num , N - 1 ) ) ) - 1 ) ; Console . WriteLine ( val ) ; }
void poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { Console . WriteLine ( ( int ) Math . Ceiling ( Math . Log ( buckets ) / Math . Log ( ( minutesToTest / minutesToDie ) + 1 ) ) ) ; }
int countTrailingZeroes ( int N ) { int res = ( int ) Math . Log ( N ^ ( N - 1 ) , 2.0 ) ; if ( res >= 0 ) return res ; else return 0 ; }
void maxProduct ( int [ ] arr , int N ) { int max_product = Int32 . MinValue ; int prefix_sum = 0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { prefix_sum += arr [ i ] ; int X = prefix_sum ; int Y = sum - prefix_sum ; max_product = Math . Max ( max_product , X * Y ) ; } Console . WriteLine ( max_product ) ; }
int findMask ( int K ) { int mask = 1 ; while ( ( K & mask ) == 0 ) { mask = mask << 1 ; } return mask ; }
void sameRightSetBitPos ( int [ ] arr , int N , int K ) { int mask = findMask ( K ) ; int pos = ( K & mask ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & mask ) == pos ) Console . Write ( arr [ i ] + " " ) ; } }
void countPronic ( int A , int B ) { int count = 0 ; for ( int i = A ; i <= B ; i ++ ) { if ( checkPronic ( i ) != false ) { count ++ ; } } Console . Write ( count ) ; }
int pronic ( int num ) { int N = ( int ) Math . Sqrt ( num ) ; if ( N * ( N + 1 ) <= num ) { return N ; } return N - 1 ; }
int countPronic ( int A , int B ) { return pronic ( B ) - pronic ( A - 1 ) ; }
void sameProductQuadruples ( int [ ] nums , int N ) { int [ ] umap = new int [ 10000 ] ; int res = 0 ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = i + 1 ; j < N ; ++ j ) { int prod = nums [ i ] * nums [ j ] ; res += 8 * umap [ prod ] ; ++ umap [ prod ] ; } } Console . Write ( res ) ; }
void productExceptSelf ( int [ ] arr , int N ) { int product = 1 ; int z = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != 0 ) product *= arr [ i ] ; if ( arr [ i ] == 0 ) z += 1 ; } int a = Math . Abs ( product ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( z == 1 ) { if ( arr [ i ] != 0 ) arr [ i ] = 0 ; else arr [ i ] = product ; continue ; } else if ( z > 1 ) { arr [ i ] = 0 ; continue ; } int b = Math . Abs ( arr [ i ] ) ; int curr = ( int ) Math . Round ( Math . Exp ( Math . Log ( a ) - Math . Log ( b ) ) ) ; if ( arr [ i ] < 0 && product < 0 ) arr [ i ] = curr ; else if ( arr [ i ] > 0 && product > 0 ) arr [ i ] = curr ; else arr [ i ] = - 1 * curr ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
int getMax ( List < int > arr , int ans , List < Boolean > chosen , int N ) { if ( arr . Count == N ) { ans = Math . Max ( ans , calcScr ( arr ) ) ; return ans ; } for ( int i = 0 ; i < N ; i ++ ) { if ( chosen [ i ] ) continue ; chosen [ i ] = true ; arr . Add ( i ) ; ans = getMax ( arr , ans , chosen , N ) ; chosen [ i ] = false ; arr . Remove ( arr . Count - 1 ) ; } return ans ; }
void singleDigitSubarrayCount ( int [ ] arr , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } Console . Write ( res ) ; }
void maxSumAfterKReverse ( int [ ] arr , int K , int N ) { int sum = Int32 . MinValue ; if ( K % 2 != 0 ) Array . Reverse ( arr ) ; int currsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { currsum += arr [ i ] ; sum = Math . Max ( sum , currsum ) ; } Console . Write ( sum ) ; }
int isPossible ( int N ) { return ( ( ( N & ( N - 1 ) ) & N ) ) ; }
void countElements ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isPossible ( i ) != 0 ) count ++ ; } Console . Write ( count ) ; }
void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } Console . Write ( N - Count ) ; }
void SubMasks ( int N ) { for ( int S = N ; S > 0 ; S = ( S - 1 ) & N ) { Console . Write ( S + " " ) ; } }
int power ( int x , int y ) { int res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % MOD ; y = y >> 1 ; x = ( x * x ) % MOD ; } return res ; }
void countPairs ( int N ) { int high = power ( 2 , N ) ; int count = 0 ; for ( int i = 0 ; i < high ; i ++ ) { for ( int j = 0 ; j < high ; j ++ ) { int X = ( i ^ j ) ; int Y = ( i j ) ; if ( X == Y ) { count ++ ; } } } Console . WriteLine ( count % MOD ) ; }
int power ( int x , int y ) { int res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % MOD ; y = y >> 1 ; x = ( x * x ) % MOD ; } return res ; }
void countPairs ( int N ) { Console . Write ( power ( 3 , N ) ) ; }
int minSum ( int [ ] A , int N ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( mp . ContainsKey ( A [ i ] ) ) { mp [ A [ i ] ] = mp [ A [ i ] ] + 1 ; } else { mp . Add ( A [ i ] , 1 ) ; } } int minSum = int . MaxValue ; foreach ( KeyValuePair < int , int > it in mp ) { minSum = Math . Min ( minSum , sum - ( it . Key * it . Value ) ) ; } return minSum ; }
int minimumMoves ( int [ ] a , int n ) { int min_element = int . MaxValue ; int max_element = int . MinValue ; int min_ind = - 1 ; int max_ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] <= min_element ) { min_element = a [ i ] ; min_ind = i ; } if ( a [ i ] > max_element ) { max_element = a [ i ] ; max_ind = i ; } } if ( max_ind == min_ind ) { return 0 ; } else if ( max_ind > min_ind ) { return max_ind + ( n - min_ind - 2 ) ; } else { return max_ind + n - min_ind - 1 ; } }
void isCycleExists ( int [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { Console . WriteLine ( "Yes" ) ; return ; } } Console . WriteLine ( "No" ) ; }
int findIndex ( int [ ] arr , int n , int K ) { int sum = 0 ; int res = - 1 ; int mini = ( int ) 1e9 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { int temp = sum - arr [ i ] ; if ( temp % K == 0 ) { if ( res == - 1 mini > arr [ i ] ) { res = i + 1 ; mini = arr [ i ] ; } } } return res ; }
int minimumIncrement ( int [ ] arr , int N ) { if ( N % 2 != 0 ) { Console . WriteLine ( "-1" ) ; Environment . Exit ( 0 ) ; } int cntEven = 0 ; int cntOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { cntEven += 1 ; } } cntOdd = N - cntEven ; return Math . Abs ( cntEven - cntOdd ) / 2 ; }
void divisionalArrays ( int [ ] arr , int N ) { int sum = N ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } foreach ( KeyValuePair < int , int > x in mp ) { if ( ( int ) x . Value > 1 ) { sum += ( int ) x . Value - 1 ; } } Console . WriteLine ( sum ) ; }
void totalInversions ( int [ ] arr , int K , int N ) { int inv = 0 ; int X = 0 ; int i , j ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { if ( arr [ i ] > arr [ j ] && i < j ) inv ++ ; if ( arr [ i ] > arr [ j ] ) X ++ ; } } int totalInv = X * K * ( K - 1 ) / 2 + inv * K ; Console . WriteLine ( totalInv ) ; }
int findSize ( int N ) { if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; int Size = 2 * findSize ( N / 2 ) + 1 ; return Size ; }
int CountOnes ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N <= 1 ) { return N ; } int ret = 0 ; int M = N / 2 ; int Siz_M = findSize ( M ) ; if ( L <= Siz_M ) { ret += CountOnes ( N / 2 , L , Math . Min ( Siz_M , R ) ) ; } if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; } if ( Siz_M + 1 < R ) { ret += CountOnes ( N / 2 , Math . Max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; }
int Fact ( int N ) { int result = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { result = ( result * i ) ; } return result ; }
void numberOfWays ( int M , int [ ] arr , int N ) { int [ ] B = new int [ M ] ; int [ ] counter = new int [ M + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != 0 ) { if ( B [ i % M ] == 0 ) { B [ i % M ] = arr [ i ] ; counter [ arr [ i ] ] ++ ; if ( counter [ arr [ i ] ] > 1 ) { Console . WriteLine ( 0 ) ; return ; } } else if ( B [ i % M ] != arr [ i ] ) { Console . WriteLine ( 0 ) ; return ; } } } int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( B [ i ] == 0 ) { cnt ++ ; } } Console . WriteLine ( Fact ( cnt ) ) ; }
void getMax ( int [ ] arr , int N , int K ) { for ( int i = 1 ; i < N ; i ++ ) { int cur_val = arr [ i ] ; while ( K >= i ) { if ( cur_val > 0 ) { arr [ 0 ] = arr [ 0 ] + 1 ; cur_val = cur_val - 1 ; K = K - i ; } else break ; } } Console . Write ( arr [ 0 ] ) ; }
int MaximumSum ( int [ , ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = 0 , y = i , sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ x ++ , y ++ ] ; } if ( sum > ans ) ans = sum ; } for ( int i = 1 ; i < n ; i ++ ) { int x = i , y = 0 , sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ x ++ , y ++ ] ; } if ( sum > ans ) ans = sum ; } return ans ; }
void numberOfIntegers ( int [ ] arr , int N ) { int cur_max = 0 , count = 0 ; if ( N == 1 ) { count = 1 ; } else { for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] > cur_max ) { cur_max = arr [ i ] ; if ( arr [ i ] > arr [ i + 1 ] ) { count ++ ; } } } if ( arr [ N - 1 ] > cur_max ) count ++ ; } Console . WriteLine ( count ) ; }
int numberOfWays ( int n , int k ) { if ( n == 0 ) return 1 ; if ( k == 0 ) return 1 ; if ( n >= ( int ) Math . Pow ( 2 , k ) ) { int curr_val = ( int ) Math . Pow ( 2 , k ) ; return numberOfWays ( n - curr_val , k ) + numberOfWays ( n , k - 1 ) ; } else return numberOfWays ( n , k - 1 ) ; }
int possibleTriplets ( int [ ] arr , int N ) { int freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { freq ++ ; } } return ( int ) ( ( freq * 1L * ( freq - 1 ) * ( freq - 2 ) ) / 6 ) ; }
void build ( int [ ] tree , int [ ] arr , int start , int end , int index ) { if ( start == end ) { if ( start % 2 == 0 ) { tree [ index ] = arr [ start ] ; } else { tree [ index ] = - arr [ start ] ; } return ; } int mid = start + ( end - start ) / 2 ; build ( tree , arr , start , mid , 2 * index + 1 ) ; build ( tree , arr , mid + 1 , end , 2 * index + 2 ) ; tree [ index ] = tree [ 2 * index + 1 ] + tree [ 2 * index + 2 ] ; }
void update ( int [ ] tree , int index , int start , int end , int pos , int val ) { if ( start == end ) { if ( start % 2 == 0 ) { tree [ index ] = val ; } else { tree [ index ] = - val ; } return ; } int mid = start + ( end - start ) / 2 ; if ( mid >= pos ) { update ( tree , 2 * index + 1 , start , mid , pos , val ) ; } else { update ( tree , 2 * index + 2 , mid + 1 , end , pos , val ) ; } tree [ index ] = tree [ 2 * index + 1 ] + tree [ 2 * index + 2 ] ; }
int FindSum ( int [ ] tree , int start , int end , int L , int R , int index ) { if ( L > end R < start ) { return 0 ; } if ( L <= start && R >= end ) { return tree [ index ] ; } int mid = start + ( end - start ) / 2 ; int X = FindSum ( tree , start , mid , L , R , 2 * index + 1 ) ; int Y = FindSum ( tree , mid + 1 , end , L , R , 2 * index + 2 ) ; return X + Y ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int DistinctValues ( int [ ] arr , int N ) { int max_value = Int32 . MinValue ; for ( int i = 0 ; i < N ; ++ i ) { max_value = Math . Max ( max_value , arr [ i ] ) ; } int GCDArr = arr [ 0 ] ; for ( int i = 1 ; i < N ; ++ i ) { GCDArr = gcd ( GCDArr , arr [ i ] ) ; } int answer = ( max_value / GCDArr ) + 1 ; return answer ; }
void findDay ( int Y , int B ) { int lyear , rest , totaldays , day ; Y = ( Y - 1 ) - B ; lyear = Y / 4 ; rest = Y - lyear ; totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; day = ( totaldays % 7 ) ; if ( day == 0 ) Console . WriteLine ( "Monday" ) ; else if ( day == 1 ) Console . WriteLine ( "Tuesday" ) ; else if ( day == 2 ) Console . WriteLine ( "Wednesday" ) ; else if ( day == 3 ) Console . WriteLine ( "Thursday" ) ; else if ( day == 4 ) Console . WriteLine ( "Friday" ) ; else if ( day == 5 ) Console . WriteLine ( "Saturday" ) ; else if ( day == 6 ) Console . WriteLine ( "Sunday" ) ; else Console . WriteLine ( "INPUT YEAR IS WRONG!" ) ; }
void maxPossibleDiff ( List < int > arr , int N ) { arr . Add ( - 1 ) ; arr . Reverse ( ) ; arr . Add ( - 1 ) ; arr . Reverse ( ) ; int maxDiff = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { maxDiff += arr [ i ] ; } if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { maxDiff -= arr [ i ] ; } } Console . Write ( maxDiff ) ; }
void printArray ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
void modifyArray ( int [ ] arr , int N , int [ , ] Q , int cntQuery ) { int [ ] arr1 = new int [ N + 2 ] ; int [ ] arr2 = new int [ N + 2 ] ; for ( int i = 0 ; i < cntQuery ; i ++ ) { int L = Q [ i , 0 ] + 1 , R = Q [ i , 1 ] + 1 ; arr1 [ L ] ++ ; arr1 [ R + 1 ] -- ; arr2 [ R + 1 ] -= R - L + 1 ; } for ( int i = 1 ; i <= N ; i ++ ) arr1 [ i ] += arr1 [ i - 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) arr2 [ i ] += arr2 [ i - 1 ] + arr1 [ i ] ; for ( int i = 1 ; i <= N ; i ++ ) arr [ i - 1 ] = arr2 [ i ] ; printArray ( arr , N ) ; }
int gcd ( int x , int y ) { if ( y == 0 ) return x ; return gcd ( y , x % y ) ; }
int lcm ( int x , int y ) { return ( x * y ) / gcd ( x , y ) ; }
int minimumCost ( int x , int y ) { int lcm_ = lcm ( x , y ) ; int costx = ( lcm_ - x ) / x ; int costy = ( lcm_ - y ) / y ; return costx + costy ; }
int findProduct ( int number_1 , int number_2 ) { if ( number_1 == Int32 . MinValue number_2 == Int32 . MinValue ) { return 0 ; } else return number_1 * number_2 ; }
List < int > calculateProduct ( List < List < int > > List , int index ) { int highest = List [ index ] . Max ( ) ; int lowest = List [ index ] . Min ( ) ; if ( index + 1 == List . Count ) { if ( lowest < 0 && highest >= 0 ) { return ( new List < int > ( ) { highest , lowest } ) ; } else if ( lowest <= 0 && highest <= 0 ) { return ( new List < int > ( ) { Int32 . MinValue , lowest } ) ; } else if ( lowest >= 0 && highest >= 0 ) { return ( new List < int > ( ) { highest , Int32 . MinValue } ) ; } } List < int > temp = calculateProduct ( List , index + 1 ) ; int positive = temp [ 0 ] ; int negative = temp [ 1 ] ; int highPos = findProduct ( highest , positive ) ; int highNeg = findProduct ( highest , negative ) ; int lowPos = findProduct ( lowest , positive ) ; int lowNeg = findProduct ( lowest , negative ) ; if ( lowest < 0 && highest >= 0 ) { return ( new List < int > ( ) { Math . Max ( highPos , lowNeg ) , Math . Min ( highNeg , lowPos ) } ) ; } else if ( lowest <= 0 && highest <= 0 ) { return ( new List < int > ( ) { lowNeg , lowPos } ) ; } else if ( lowest >= 0 && highest >= 0 ) { return ( new List < int > ( ) { Math . Max ( lowPos , highPos ) , Math . Min ( lowNeg , highNeg ) } ) ; } return ( new List < int > ( ) { 0 , 0 } ) ; }
void calculateSpan ( int [ ] price , int n , int [ ] S ) { S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } }
int power ( int a , int n , int d ) { int res = 1 ; while ( n != 0 ) { if ( ( n % 2 ) != 0 ) { res = ( ( res % d ) * ( a % d ) ) % d ; } a = ( ( a % d ) * ( a % d ) ) % d ; n /= 2 ; } return res ; }
int gcd ( int p , int q , int n ) { if ( p == q ) { return ( power ( p , n , mod ) + power ( q , n , mod ) ) % mod ; } int candidate = 1 ; int num = p - q ; int sq = ( int ) Math . Sqrt ( num ) ; for ( int i = 1 ; i <= sq ; ++ i ) { if ( num % i == 0 ) { int X = power ( p , n , i ) ; int Y = power ( q , n , i ) ; int temp = ( X + Y ) % i ; if ( temp == 0 ) { candidate = Math . Max ( candidate , i ) ; } temp = ( power ( p , n , num / i ) + power ( q , n , num / i ) ) % ( num / i ) ; if ( temp == 0 ) { candidate = Math . Max ( candidate , num / i ) ; } } } return candidate % mod ; }
void minimumSubarrays ( int [ ] arr , int n ) { char current = 'N' ; int answer = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( current == 'N' ) { if ( arr [ i ] < arr [ i - 1 ] ) { current = 'D' ; } else if ( arr [ i ] == arr [ i - 1 ] ) { current = 'N' ; } else { current = 'I' ; } } else if ( current == 'I' ) { if ( arr [ i ] >= arr [ i - 1 ] ) { current = 'I' ; } else { current = 'N' ; answer += 1 ; } } else { if ( arr [ i ] <= arr [ i - 1 ] ) { current = 'D' ; } else { current = 'N' ; answer += 1 ; } } } Console . Write ( answer ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int calculateK ( int x , int y ) { int g = gcd ( x , y ) ; int n = y / g ; int res = n ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { res -= ( res / i ) ; while ( n % i == 0 ) n /= i ; } } if ( n != 1 ) res -= ( res / n ) ; return res ; }
void nearestPowerOfTwo ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int lg = ( int ) ( Math . Log ( arr [ i ] ) / Math . Log ( 2 ) ) ; int a = ( int ) ( Math . Pow ( 2 , lg ) ) ; int b = ( int ) ( Math . Pow ( 2 , lg + 1 ) ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) Console . Write ( a + " " ) ; else Console . Write ( b + " " ) ; } }
double Conversion ( double centi ) { double pixels = ( 96 * centi ) / 2.54 ; Console . WriteLine ( pixels ) ; return 0 ; }
int minSwaps ( int [ , ] b ) { int n = b . GetLength ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( b [ 0 , 0 ] ^ b [ 0 , j ] ^ b [ i , 0 ] ^ b [ i , j ] ) == 1 ) { return - 1 ; } } } int rowSum = 0 ; int colSum = 0 ; int rowSwap = 0 ; int colSwap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { rowSum += b [ i , 0 ] ; colSum += b [ 0 , i ] ; int cond1 = 0 ; int cond2 = 0 ; if ( b [ i , 0 ] == i % 2 ) cond1 = 1 ; if ( b [ 0 , i ] == i % 2 ) cond2 = 1 ; rowSwap += cond1 ; colSwap += cond2 ; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return - 1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return - 1 ; if ( n % 2 == 1 ) { if ( ( colSwap % 2 ) == 1 ) colSwap = n - colSwap ; if ( ( rowSwap % 2 ) == 1 ) rowSwap = n - rowSwap ; } else { colSwap = Math . Min ( colSwap , n - colSwap ) ; rowSwap = Math . Min ( rowSwap , n - rowSwap ) ; } return ( rowSwap + colSwap ) / 2 ; }
void maxNumTrailNine ( int n , int d ) { int res = n ; int cntDigits = ( int ) Math . Log10 ( n ) + 1 ; int p10 = 10 ; for ( int i = 1 ; i <= cntDigits ; i ++ ) { if ( n % p10 >= d ) { break ; } else { res = n - n % p10 - 1 ; } p10 = p10 * 10 ; } Console . WriteLine ( res ) ; }
int MinimumNoOfWays ( int [ ] arr , int n ) { int mini_no_of_ways ; if ( n % 2 == 0 ) { mini_no_of_ways = n / 2 ; } else { mini_no_of_ways = n / 2 + 1 ; } return mini_no_of_ways ; }
void count_setbit ( int N ) { int result = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( 1 << i ) & N ) > 0 ) { result ++ ; } } Console . WriteLine ( result ) ; }
void cntWaysConsArray ( int [ ] A , int N ) { int total = 1 ; int oddArray = 1 ; for ( int i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } Console . WriteLine ( total - oddArray ) ; }
int invertBits ( int n ) { int x = ( int ) Math . Log ( n , 2 ) ; int m = 1 << x ; m = m | m - 1 ; n = n ^ m ; return n ; }
void invertSum ( int A , int B ) { int temp = countSetBits ( A ) + countSetBits ( B ) ; Console . WriteLine ( invertBits ( temp ) ) ; }
int ValOfTheExpression ( int n ) { int [ ] factorial = new int [ n + 1 ] ; factorial [ 0 ] = factorial [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { factorial [ i ] = ( ( factorial [ i - 1 ] % mod ) * ( i % mod ) ) % mod ; } int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = ( ( dp [ i - 1 ] % mod ) * ( factorial [ i ] % mod ) ) % mod ; } return dp [ n ] ; }
int minChocolates ( int [ ] a , int n ) { int i = 0 , j = 0 ; int res = 0 , val = 1 ; while ( j < n - 1 ) { if ( a [ j ] > a [ j + 1 ] ) { j += 1 ; continue ; } if ( i == j ) res += val ; else { res += get_sum ( val , i , j ) ; } if ( a [ j ] < a [ j + 1 ] ) val += 1 ; else val = 1 ; j += 1 ; i = j ; } if ( i == j ) res += val ; else res += get_sum ( val , i , j ) ; return res ; }
int get_sum ( int peak , int start , int end ) { int count = end - start + 1 ; peak = ( peak > count ) ? peak : count ; int s = peak + ( ( ( count - 1 ) * count ) >> 1 ) ; return s ; }
int [ ] RemoveElemArr ( int [ ] arr , int n , int k ) { if ( n == 0 n == 1 ) return arr ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < k arr [ i ] > arr [ j - k ] ) { arr [ j ++ ] = arr [ i ] ; } } while ( arr . Length > j ) { arr = arr . Take ( arr . Length - 1 ) . ToArray ( ) ; } return arr ; }
void printArray ( int [ ] arr ) { for ( int i = 0 ; i < arr . Length ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
void UtilRemov ( int [ ] arr , int n , int k ) { arr = RemoveElemArr ( arr , n , k ) ; printArray ( arr ) ; }
void countNumberHavingKthBitSet ( int N , int K ) { int numbers_rightmost_setbit_K = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { int numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } Console . WriteLine ( numbers_rightmost_setbit_K ) ; }
void pairs_after_removing ( int [ ] arr , int N ) { int cntPairs = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] ++ ; } else { mp [ arr [ i ] ] = 1 ; } } foreach ( KeyValuePair < int , int > element in mp ) { int i = element . Key ; cntPairs += mp [ i ] * ( mp [ i ] - 1 ) / 2 ; } for ( int i = 0 ; i < N ; i ++ ) { int pairs_after_arr_i_removed = cntPairs + 1 - mp [ arr [ i ] ] ; Console . Write ( pairs_after_arr_i_removed + " " ) ; } return ; }
int minimumMaxDiff ( int [ ] nums ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < nums . Length ; i ++ ) { if ( nums [ i ] % 2 == 0 ) s . Add ( nums [ i ] ) ; else s . Add ( nums [ i ] * 2 ) ; } int res = s . Last ( ) - s . First ( ) ; while ( s . Last ( ) % 2 == 0 ) { int x = s . Last ( ) ; s . Remove ( x ) ; s . Add ( x / 2 ) ; res = Math . Min ( res , s . Last ( ) - s . First ( ) ) ; } return res ; }
int bitwiseXorRange ( int n ) { if ( n % 4 == 0 ) return n ; if ( n % 4 == 1 ) return 1 ; if ( n % 4 == 2 ) return n + 1 ; return 0 ; }
int evenXorRange ( int l , int r ) { int xor_l ; int xor_r ; xor_r = 2 * bitwiseXorRange ( r / 2 ) ; xor_l = 2 * bitwiseXorRange ( ( l - 1 ) / 2 ) ; return xor_l ^ xor_r ; }
double find_Variance ( int n ) { long numerator = n * n - 1 ; double ans = ( numerator * 1.0 ) / 12 ; return ans ; }
void noOfArraysPossible ( int N , int M ) { int ans = 1 ; for ( int i = 0 ; i < N ; ++ i ) { ans = ans * ( M - i ) ; } Console . Write ( ans ) ; }
void findSum ( int a , int b , int n ) { int sum = 0 ; int x = a ^ b ; if ( n % 3 == 0 ) { sum = ( n / 3 ) * ( a + b + x ) ; } else if ( n % 3 == 1 ) { sum = ( n / 3 ) * ( a + b + x ) + a ; } else { sum = ( n / 3 ) * ( a + b + x ) + a + b ; } Console . Write ( sum ) ; }
void constructArrayWithGivenLCM ( int N ) { int [ ] newArr = new int [ N ] ; int j = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { newArr [ j ] = i ; j ++ ; if ( N / i != i ) { newArr [ j ] = N / i ; j ++ ; } } } Array . Sort ( newArr ) ; for ( int i = j ; i < N ; i ++ ) { Console . Write ( newArr [ i ] + " " ) ; } }
int onesComplement ( int n , int maxElement ) { int bits = ( int ) Math . Floor ( ( Math . Log ( maxElement ) / Math . Log ( 2 ) ) ) + 1 ; return ( ( 1 << bits ) - 1 ) ^ n ; }
int [ ] calculateFactorial ( int N ) { int [ ] fact = new int [ ( N + 1 ) ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fact [ i ] = fact [ i - 1 ] * i ; } return fact ; }
int cntWaysSelection ( int [ ] arr , int N , int K , int L , int R ) { int cntWays = 0 ; int cntNum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= L && arr [ i ] <= R ) { cntNum ++ ; } } int [ ] fact = calculateFactorial ( cntNum ) ; for ( int i = K ; i <= cntNum ; i ++ ) { cntWays += fact [ cntNum ] / ( fact [ i ] * fact [ cntNum - i ] ) ; } return cntWays ; }
int TotalAndPair ( int [ ] arr , int N ) { int totalAND = ( 1 << 30 ) - 1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalAND &= arr [ i ] & arr [ j ] ; } } return totalAND ; }
int getPower ( int p ) { int res = 1 ; while ( p > 0 ) { res *= 5 ; p -- ; } return res ; }
void printFinalPrices ( int [ ] arr ) { Stack < int > minStk = new Stack < int > ( ) ; int n = arr . Length ; int [ ] reduce = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( minStk . Count != 0 ) { if ( minStk . Peek ( ) <= arr [ i ] ) { reduce [ i ] = minStk . Peek ( ) ; } else { while ( minStk . Count != 0 && ( minStk . Peek ( ) > arr [ i ] ) ) { minStk . Pop ( ) ; } if ( minStk . Count != 0 ) { reduce [ i ] = minStk . Peek ( ) ; } } } minStk . Push ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] - reduce [ i ] + " " ) ; }
int smallestDivisorGr1 ( int N ) { for ( int i = 2 ; i <= Math . Sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { return i ; } } return N ; }
int findValOfNWithOperat ( int N , int K ) { for ( int i = 1 ; i <= K ; i ++ ) { N += smallestDivisorGr1 ( N ) ; } return N ; }
int smallestDivisorGr1 ( int N ) { for ( int i = 2 ; i <= Math . Sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { return i ; } } return N ; }
int findTripleSum ( int A , int B , int C ) { int sum = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { int prod = ( ( ( i % M ) * ( j % M ) ) % M * ( k % M ) ) % M ; sum = ( sum + prod ) % M ; } } } return sum ; }
int getMaximum ( int N , int M , int [ , ] mat ) { int global_max = int . MinValue ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int row_min = int . MaxValue ; for ( int k = 0 ; k < M ; k ++ ) { int m = Math . Max ( mat [ i , k ] , mat [ j , k ] ) ; row_min = Math . Min ( row_min , m ) ; } global_max = Math . Max ( global_max , row_min ) ; } } return global_max ; }
void makeTree ( List < int > [ ] tree , pair [ ] edges , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { int u = edges [ i ] . first ; int v = edges [ i ] . second ; tree [ u ] . Add ( v ) ; } }
void findTheGreatestX ( int P , int Q ) { Dictionary < int , int > divisers = new Dictionary < int , int > ( ) ; for ( int i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 && Q > 1 ) { Q /= i ; if ( divisers . ContainsKey ( i ) ) divisers [ i ] ++ ; else divisers [ i ] = 1 ; } } if ( Q > 1 ) { if ( divisers . ContainsKey ( Q ) ) divisers [ Q ] ++ ; else divisers [ Q ] = 1 ; } int ans = 0 ; var val = divisers . Keys . ToList ( ) ; foreach ( var key in val ) { int frequency = divisers [ key ] ; int temp = P ; int cur = 0 ; while ( temp % key == 0 ) { temp /= key ; cur ++ ; } if ( cur < frequency ) { ans = P ; break ; } temp = P ; for ( int j = cur ; j >= frequency ; j -- ) { temp /= key ; } ans = Math . Max ( temp , ans ) ; } Console . WriteLine ( ans ) ; }
int divisorCount ( int n ) { int x = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == n / i ) x ++ ; else x += 2 ; } } return x ; }
int minvalue_y ( int x ) { int a = divisorCount ( x ) ; int y = x + 1 ; while ( ( a & 1 ) == ( divisorCount ( y ) & 1 ) ) y ++ ; return y ; }
int minvalue_y ( int x ) { int n = ( int ) Math . Sqrt ( x ) ; if ( n * n == x ) return x + 1 ; return ( int ) Math . Pow ( n + 1 , 2 ) ; }
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; if ( N % 2 == 0 ) { alternateSum = ( - N ) / 2 ; } else { alternateSum = ( N + 1 ) / 2 ; } return alternateSum ; }
int minStartValue ( int [ ] nums ) { int minValue = 0 ; int sum = 0 ; foreach ( int n in nums ) { sum += n ; minValue = Math . Min ( minValue , sum ) ; } int startValue = 1 - minValue ; return startValue ; }
int countSubArrayRemove ( int [ ] arr , int N ) { Dictionary < int , int > prefix_element_count = new Dictionary < int , int > ( ) ; Dictionary < int , int > suffix_element_count = new Dictionary < int , int > ( ) ; int total_sum_of_elements = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { total_sum_of_elements += arr [ i ] ; if ( ! suffix_element_count . ContainsKey ( arr [ i ] ) ) suffix_element_count [ arr [ i ] ] = 1 ; else suffix_element_count [ arr [ i ] ] ++ ; } int prefix_sum = 0 ; int suffix_sum = 0 ; int count_subarray_equal_sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { prefix_sum += arr [ i ] ; if ( ! prefix_element_count . ContainsKey ( arr [ i ] ) ) prefix_element_count [ arr [ i ] ] = 1 ; else prefix_element_count [ arr [ i ] ] ++ ; suffix_sum = total_sum_of_elements - prefix_sum ; if ( ! suffix_element_count . ContainsKey ( arr [ i ] ) ) suffix_element_count [ arr [ i ] ] = 0 ; else suffix_element_count [ arr [ i ] ] -= 1 ; int difference = prefix_sum - suffix_sum ; int number_of_subarray_at_i_split = 0 ; if ( prefix_element_count . ContainsKey ( difference ) ) number_of_subarray_at_i_split = prefix_element_count [ difference ] ; if ( suffix_element_count . ContainsKey ( - difference ) ) number_of_subarray_at_i_split += suffix_element_count [ - difference ] ; count_subarray_equal_sum += number_of_subarray_at_i_split ; } return count_subarray_equal_sum ; }
int countXORSetBitsAdjElemRange1_N ( int N ) { int total_set_bits = 0 ; int bit_Position = 1 ; while ( N != 0 ) { total_set_bits += ( ( N + 1 ) / 2 * bit_Position ) ; N -= ( N + 1 ) / 2 ; bit_Position ++ ; } return total_set_bits ; }
int checkPerfectSquare ( int N ) { if ( N <= 0 ) { return 0 ; } double sq = Math . Sqrt ( N ) ; if ( Math . Floor ( sq ) == Math . Ceiling ( sq ) ) { return 1 ; } return 0 ; }
bool checktwoSidesareRighTriangle ( int A , int B ) { bool checkTriangle = false ; if ( checkPerfectSquare ( A * A + B * B ) != 0 ) { checkTriangle = true ; } if ( checkPerfectSquare ( A * A - B * B ) != 0 ) { checkTriangle = true ; } if ( checkPerfectSquare ( B * B - A * A ) != 0 ) { checkTriangle = true ; } return checkTriangle ; }
bool valid ( int i , int j ) { if ( i >= 0 && j >= 0 && i < r && j < c ) return true ; return false ; }
int find ( int i , int j , int [ , ] v ) { int s = 0 ; for ( int k = 0 ; k < 8 ; k ++ ) { int ni = i + dir [ k , 0 ] , nj = j + dir [ k , 1 ] ; if ( valid ( ni , nj ) ) s += v [ ni , nj ] ; } return s ; }
void findsumofneighbors ( int [ , ] M ) { int [ , ] v = new int [ r , c ] ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { v [ i , j ] = find ( i , j , M ) ; Console . Write ( v [ i , j ] + " " ) ; } Console . WriteLine ( "" ) ; } }
int TotalBitwiseORPair ( int [ ] arr , int N ) { int totalOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalOR |= arr [ i ] ; } return totalOR ; }
void checkSolveable ( int n , int m ) { if ( n == 1 m == 1 ) Console . WriteLine ( "YES" ) ; else if ( m == 2 && n == 2 ) Console . WriteLine ( "YES" ) ; else Console . WriteLine ( "NO" ) ; }
void printFinalArray ( int [ ] a , int n , int [ ] operations , int p , int capacity ) { int i , curr = 0 ; bool picked = false ; for ( i = 0 ; i < p ; i ++ ) { int s = operations [ i ] ; bool flag = false ; switch ( s ) { case 1 : if ( curr != 0 ) curr -- ; break ; case 2 : if ( curr != n - 1 ) curr ++ ; break ; case 3 : if ( picked == false && a [ curr ] != 0 ) { picked = true ; a [ curr ] -- ; } break ; case 4 : if ( picked == true && a [ curr ] != capacity ) { picked = false ; a [ curr ] ++ ; } break ; default : flag = true ; break ; } if ( flag == true ) break ; } for ( i = 0 ; i < n ; i ++ ) { Console . Write ( a [ i ] + " " ) ; } }
void constructArray ( int [ ] A , int N ) { int [ ] left = new int [ N + 1 ] ; int [ ] right = new int [ N + 1 ] ; int [ ] X = new int [ N + 1 ] ; int [ ] Y = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { X [ i ] = left [ A [ i ] ] ; left [ A [ i ] ] ++ ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { Y [ i ] = right [ A [ i ] ] ; right [ A [ i ] ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( Y [ i ] - X [ i ] + " " ) ; } }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int largestElement ( Node head_ref ) { int Max = int . MinValue ; Node head = head_ref ; while ( head != null ) { if ( Max < head . data ) { Max = head . data ; } head = head . next ; } return Max ; }
void probablityPrimeprod ( int N ) { int N_E = 3 * N ; int N_S = power ( 6 , N ) ; Console . Write ( N_E + " / " + N_S ) ; }
bool checkPalindrome ( int N ) { int rev = 0 ; int temp = N ; while ( N != 0 ) { rev = rev * 10 + N % 10 ; N = N / 10 ; } N = temp ; if ( N == rev ) { return true ; } return false ; }
int closestSmallerPalindrome ( int N ) { do { N -- ; } while ( N >= 0 && ! checkPalindrome ( N ) ) ; return N ; }
int MinimumOperationReq ( int N ) { int cntDecr = 0 ; int temp = N ; while ( temp > 0 ) { int X = ( int ) Math . Sqrt ( temp ) ; if ( X * X == temp ) { break ; } temp = temp - 2 ; cntDecr += 1 ; } int cntIncr = 0 ; while ( true ) { int X = ( int ) Math . Sqrt ( N ) ; if ( X * X == N ) { break ; } N = N + 2 ; cntIncr += 1 ; } return Math . Min ( cntIncr , cntDecr ) ; }
long power ( long x , long N ) { long res = 1 ; while ( N > 0 ) { if ( N % 2 == 1 ) { res = ( res * x ) % M ; } x = ( x * x ) % M ; N = N >> 1 ; } return res ; }
long moduloInverse ( long X ) { return power ( X , M - 2 ) ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; else return GCD ( b , a % b ) ; }
void check ( int x , int y ) { if ( GCD ( x , y ) == 1 ) { Console . WriteLine ( "Yes" ) ; } else { Console . WriteLine ( "No" ) ; } }
void findSubArray ( List < int > arr , int k ) { Point ans = new Point ( 0 , 0 ) ; int i , sum = 0 ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } int found = 0 ; if ( sum % 3 == 0 ) { ans = new Point ( 0 , i - 1 ) ; found = 1 ; } for ( int j = i ; j < arr . Count ; j ++ ) { if ( found == 1 ) break ; sum = sum + arr [ j ] - arr [ j - k ] ; if ( sum % 3 == 0 ) { ans = new Point ( j - k + 1 , j ) ; found = 1 ; } } if ( found == 0 ) ans = new Point ( - 1 , 0 ) ; if ( ans . x == - 1 ) { Console . Write ( - 1 ) ; } else { for ( i = ans . x ; i <= ans . y ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } } }
int sumOfProd ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } return sum * sum ; }
int rev ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
bool check ( int n ) { int x = ( n + 7 ) / 8 ; if ( ( n + 7 ) % 8 == 0 && isPower ( 10 , x ) ) return true ; else return false ; }
void mul_2 ( int K ) { int [ , ] temp = new int [ K + 1 , K + 1 ] ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 1 ; j <= K ; j ++ ) { for ( int k = 1 ; k <= K ; k ++ ) { temp [ i , j ] = ( temp [ i , j ] + ( T [ i , k ] * T [ k , j ] ) % mod ) % mod ; } } } for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 1 ; j <= K ; j ++ ) { T [ i , j ] = temp [ i , j ] ; } } }
void mul_1 ( int K ) { int [ , ] temp = new int [ K + 1 , K + 1 ] ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 1 ; j <= K ; j ++ ) { for ( int k = 1 ; k <= K ; k ++ ) { temp [ i , j ] = ( temp [ i , j ] + ( result [ i , k ] * T [ k , j ] ) % mod ) % mod ; } } } for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 1 ; j <= K ; j ++ ) { result [ i , j ] = temp [ i , j ] ; } } }
void matrix_pow ( int K , int n ) { for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 1 ; j <= K ; j ++ ) { if ( i == j ) result [ i , j ] = 1 ; } } while ( n > 0 ) { if ( n % 2 == 1 ) mul_1 ( K ) ; mul_2 ( K ) ; n /= 2 ; } }
int countFreq ( int [ ] arr , int n ) { Dictionary < int , int > mp1 = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp1 . ContainsKey ( arr [ i ] ) ) { mp1 [ arr [ i ] ] = mp1 [ arr [ i ] ] + 1 ; } else { mp1 . Add ( arr [ i ] , 1 ) ; } } Dictionary < int , int > mp2 = new Dictionary < int , int > ( ) ; foreach ( KeyValuePair < int , int > it in mp1 ) { if ( mp2 . ContainsKey ( it . Value ) ) { mp2 [ it . Value ] = mp2 [ it . Value ] + 1 ; } else { mp2 . Add ( it . Value , 1 ) ; } } int M = int . MinValue ; foreach ( KeyValuePair < int , int > it in mp2 ) { M = Math . Max ( M , it . Value ) ; } foreach ( KeyValuePair < int , int > it in mp2 ) { if ( M == it . Value ) { return it . Key ; } } return 0 ; }
int computeSalary ( int basic , char grade ) { double allowance ; double hra , da , pf ; hra = 0.2 * basic ; da = 0.5 * basic ; pf = 0.11 * basic ; if ( grade == 'A' ) { allowance = 1700.0 ; } else if ( grade == 'B' ) { allowance = 1500.0 ; } else { allowance = 1300.0 ; } double gross ; gross = Math . Round ( basic + hra + da + allowance - pf ) ; return ( int ) gross ; }
int maxDisconnected ( int N , int E ) { int curr = 1 ; int rem = E ; while ( rem > 0 ) { rem = rem - Math . Min ( curr , rem ) ; curr ++ ; } if ( curr > 1 ) { return N - curr ; } else { return N ; } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findSum ( int N ) { int sum = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( gcd ( i , N ) == 1 ) { sum += i ; } } return sum ; }
void solve ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } int cnt = 0 ; foreach ( KeyValuePair < int , int > x in mp ) { cnt += ( ( x . Value ) * ( x . Value - 1 ) / 2 ) ; } int [ ] ans = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ans [ i ] = cnt - ( mp [ arr [ i ] ] - 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( ans [ i ] + " " ) ; } }
double nthRoot ( int A , int N ) { Random rand = new Random ( ) ; double xPre = ( rand . Next ( ) * 10 ) % 10 ; double eps = 1e-3 ; double delX = Int32 . MaxValue ; double xK = 0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . Pow ( xPre , N - 1 ) ) / ( double ) N ; delX = Math . Abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
float RMNValue ( int [ ] arr , int n , int k ) { int Nth = 0 ; float mean = 0 , root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Nth += ( int ) Math . Pow ( arr [ i ] , k ) ; } mean = ( Nth / ( float ) ( n ) ) ; root = ( float ) nthRoot ( ( int ) mean , k ) ; return root ; }
int xor_operations ( int N , int [ ] arr , int M , int K ) { if ( M < 0 M >= N ) return - 1 ; if ( K < 0 K >= N - M ) return - 1 ; for ( int p = 0 ; p < M ; p ++ ) { List < int > temp = new List < int > ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int value = arr [ i ] ^ arr [ i + 1 ] ; temp . Add ( value ) ; arr [ i ] = temp [ i ] ; } } int ans = arr [ K ] ; return ans ; }
bool checkPalindromeB ( int N , int B ) { int rev = 0 ; int N1 = N ; while ( N1 > 0 ) { rev = rev * B + N1 % B ; N1 = N1 / B ; } return N == rev ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findProduct ( int N ) { int result = 1 ; for ( int i = 2 ; i < N ; i ++ ) { if ( gcd ( i , N ) == 1 ) { result *= i ; } } return result ; }
int countEqual ( int n ) { return ( n + 1 ) / 2 ; }
int smallSubarray ( int [ ] arr , int n , int total_sum ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; int length = int . MaxValue ; int prefixSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { prefixSum += arr [ i ] ; if ( prefixSum == total_sum ) { length = Math . Min ( length , i + 1 ) ; } if ( m . ContainsKey ( prefixSum ) ) m [ prefixSum ] = i ; else m . Add ( prefixSum , i ) ; if ( m . ContainsKey ( prefixSum - total_sum ) ) { length = Math . Min ( length , i - m [ prefixSum - total_sum ] ) ; } } return length ; }
int smallestSubarrayremoved ( int [ ] arr , int n , int k ) { int total_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > k ) { arr [ i ] = 1 ; } else if ( arr [ i ] < k ) { arr [ i ] = - 1 ; } else { arr [ i ] = 0 ; } total_sum += arr [ i ] ; } if ( total_sum == 0 ) { return 0 ; } else { return smallSubarray ( arr , n , total_sum ) ; } }
int find ( int [ ] par , int x ) { if ( par [ x ] == x ) return x ; else return par [ x ] = find ( par , par [ x ] ) ; }
int functionMax ( int [ ] arr , int n ) { List < int > [ ] setBit = new List < int > [ 32 + 1 ] ; for ( int i = 0 ; i < setBit . Length ; i ++ ) setBit [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < size_int ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) setBit [ j ] . Add ( i ) ; } } for ( int i = size_int ; i >= 0 ; i -- ) { if ( setBit [ i ] . Count == 1 ) { swap ( arr , 0 , setBit [ i ] [ 0 ] ) ; break ; } } int maxAnd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxAnd = maxAnd & ( ~ arr [ i ] ) ; } return maxAnd ; }
long modexp ( long x , long n , long m ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , n / 2 , m ) ; } else { return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 , m ) % m ) ; } }
long modInverse ( long x , long m ) { return modexp ( x , m - 2 , m ) ; }
void countNumbers ( string N ) { long m = 1000000007 ; long [ ] factorial = new long [ 100001 ] ; factorial [ 0 ] = 1 ; for ( int i = 1 ; i < 100001 ; i ++ ) { factorial [ i ] = ( factorial [ i - 1 ] * i ) % m ; } long [ ] count = new long [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { count [ i ] = 0 ; } long length = N . Length ; for ( int i = 0 ; i < length ; i ++ ) count [ N [ i ] - '0' ] ++ ; long result = factorial [ ( int ) length ] ; for ( int i = 0 ; i < 10 ; i ++ ) { result = ( result * modInverse ( factorial [ ( int ) count [ i ] ] , m ) ) % m ; } Console . WriteLine ( result ) ; }
void max_valid_triplet ( int [ ] A , int n ) { int ans = - 1 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( A [ i ] < A [ j ] && A [ j ] < A [ k ] ) { int value = A [ i ] + A [ j ] * A [ k ] ; if ( value > ans ) { ans = value ; } } } } } Console . WriteLine ( ans ) ; }
long productOfProperDivi ( int num ) { return ans [ num ] ; }
int findlcm ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ( ( ( i * ans ) ) / ( __gcd ( i , ans ) ) ) ; return ans ; }
int highestPower ( int n ) { int lcm = findlcm ( n ) ; int ans = 0 ; for ( int i = 1 ; ; i ++ ) { int x = ( int ) Math . Pow ( 2 , i ) ; if ( lcm % x == 0 ) { ans = i ; } if ( x > n ) break ; } return ans ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int countofPermutations ( int N ) { return ( int ) ( 3 * Math . Pow ( 2 , N - 1 ) ) ; }
void answer ( int L , int R ) { if ( 2 * L <= R ) Console . WriteLine ( L + ", " + ( 2 * L ) ) ; else Console . WriteLine ( "-1" ) ; }
void spf_array ( int [ ] spf ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < 1000 ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < 1000 ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < 1000 ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < 1000 ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
void frequent_prime ( int [ ] arr , int N , int K ) { spf_array ( spf ) ; SortedDictionary < int , int > Hmap = new SortedDictionary < int , int > ( ) ; List < int > result = new List < int > ( ) ; int i = 0 ; for ( i = 0 ; i < N ; i ++ ) { int x = arr [ i ] ; while ( x != 1 ) { if ( Hmap . ContainsKey ( spf [ x ] ) ) Hmap [ spf [ x ] ] = spf [ x ] + 1 ; else Hmap . Add ( spf [ x ] , 1 ) ; x = x / spf [ x ] ; } } Hmap . Remove ( 1 ) ; foreach ( KeyValuePair < int , int > x in Hmap ) { int primeNum = x . Key ; int frequency = x . Value ; if ( frequency % K == 0 ) { result . Add ( primeNum ) ; } } if ( result . Count > 0 ) { foreach ( int it in result ) { Console . Write ( it + " " ) ; } } else { Console . Write ( "{}" ) ; } }
void initialize_xor ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { total_xor = total_xor ^ arr [ i ] ; } }
int gcd ( int x , int y ) { if ( x % y == 0 ) return y ; else return gcd ( y , x % y ) ; }
int countPairwiseCoprime ( int N , int M ) { int answer = 1 ; int g = gcd ( N , M ) ; int temp = g ; for ( int i = 2 ; i * i <= g ; i ++ ) { if ( temp % i == 0 ) { answer ++ ; while ( temp % i == 0 ) temp /= i ; } } if ( temp != 1 ) answer ++ ; return answer ; }
void countCoprimePair ( int [ , ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( countPairwiseCoprime ( arr [ i , 0 ] , arr [ i , 1 ] ) + " " ) ; } }
bool prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
int getProduct ( int [ ] a , int n ) { int p = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { p *= Math . Abs ( a [ i ] - a [ j ] ) ; } } return p ; }
bool isPerfectSquare ( double x ) { double sr = Math . Sqrt ( x ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ; }
bool diffCube ( int N ) { return isPerfectSquare ( 12 * N - 3 ) ; }
int totalCountDifference ( int n ) { if ( n == 1 ) return 1 ; return n + totalCountDifference ( n / 2 ) ; }
int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; }
void findLCM ( List < int > arr ) { int nth_lcm = arr [ 0 ] ; for ( int i = 1 ; i < arr . Count ; i ++ ) nth_lcm = lcm ( nth_lcm , arr [ i ] ) ; Landau = Math . Max ( Landau , nth_lcm ) ; }
void findWays ( List < int > arr , int i , int n ) { if ( n == 0 ) findLCM ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . Add ( j ) ; findWays ( arr , j , n - j ) ; arr . RemoveAt ( arr . Count - 1 ) ; } }
void Landau_function ( int n ) { List < int > arr = new List < int > ( ) ; findWays ( arr , 1 , n ) ; Console . Write ( Landau ) ; }
int findSum ( int [ ] arr , int n , int left , int right ) { int k = right - left + 1 ; int d = arr [ 1 ] / arr [ 0 ] ; int ans = arr [ left - 1 ] ; if ( d == 1 ) ans = ans * d * k ; else ans = ans * ( ( int ) Math . Pow ( d , k ) - 1 / ( d - 1 ) ) ; return ans ; }
int countRepeatingDigits ( int N ) { int res = 0 ; int [ ] cnt = new int [ 10 ] ; while ( N > 0 ) { int rem = N % 10 ; cnt [ rem ] ++ ; N = N / 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( cnt [ i ] > 1 ) { res ++ ; } } return res ; }
int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
int solve ( int n , int m , int k ) { int sum = 0 ; for ( int i = 0 ; i <= k ; i ++ ) sum += nCr ( n , i ) * nCr ( m , k - i ) ; return sum ; }
int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
long modPower ( long a , long b , long M ) { long res = 1 ; while ( b > 0 ) { if ( b % 2 == 1 ) res = res * a % M ; a = a * a % M ; b >>= 1 ; } return res ; }
int Cal_min ( int [ ] arr , int n , int k ) { HashSet < int > diff_mod = new HashSet < int > ( ) ; Dictionary < int , int > count_mod = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { diff_mod . Add ( arr [ i ] % k ) ; if ( count_mod . ContainsKey ( ( arr [ i ] % k ) ) ) count_mod [ arr [ i ] % k ] = count_mod [ ( arr [ i ] % k ) ] + 1 ; else count_mod . Add ( arr [ i ] % k , 1 ) ; } return Find_min ( diff_mod , count_mod , k ) ; }
void canBreakN ( long n ) { for ( long i = 2 ; ; i ++ ) { long m = i * ( i + 1 ) / 2 ; if ( m > n ) break ; long k = n - m ; if ( k % i != 0 ) continue ; Console . Write ( i ) ; return ; } Console . Write ( "-1" ) ; }
void minimumSteps ( int [ ] arr , int n ) { int i ; int [ ] dat = new int [ n + 1 ] ; for ( i = 1 ; i <= n ; i ++ ) dat [ arr [ i - 1 ] ] = i ; int [ ] b = new int [ n + 1 ] ; int j = 0 , c ; for ( i = 1 ; i <= n ; i ++ ) { c = 1 ; j = dat [ i ] ; while ( j != i ) { c ++ ; j = dat [ j ] ; } b [ i ] = c ; } Console . WriteLine ( findlcm ( b , n ) ) ; }
double maximum ( double a , double b ) { if ( a > b ) return a ; return b ; }
void check ( long num ) { long root = ( long ) Math . Sqrt ( num ) ; long pow = ( long ) ( Math . Log ( root ) / Math . Log ( 2 ) ) ; if ( num == ( long ) ( Math . Pow ( 2 , pow ) * ( Math . Pow ( 2 , pow + 1 ) - 1 ) ) ) { if ( isPrime ( pow + 1 ) ) { if ( isPrime ( ( long ) Math . Pow ( 2 , pow + 1 ) - 1 ) ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; } else Console . WriteLine ( "No" ) ; } else Console . WriteLine ( "No" ) ; }
bool isPrime ( long n ) { if ( n <= 1 ) return false ; else if ( n == 2 n == 3 ) return true ; else { if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( long i = 5 ; i <= Math . Sqrt ( n ) ; i += 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; } return true ; } }
bool isTriplet ( int [ ] ar , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( Math . Abs ( ar [ i ] - ar [ j ] ) == 1 || Math . Abs ( ar [ j ] - ar [ k ] ) == 1 || Math . Abs ( ar [ i ] - ar [ k ] ) == 1 ) { int x = ar [ i ] * ar [ i ] , y = ar [ j ] * ar [ j ] , z = ar [ k ] * ar [ k ] ; if ( x == y + z y == + == + y ) return true ; } } } } return false ; }
void closestDivisors ( int n ) { for ( int i = ( int ) Math . Sqrt ( n + 2 ) ; i > 0 ; i -- ) { if ( ( n + 1 ) % i == 0 ) { Console . Write ( i + ", " + ( n + 1 ) / i ) ; break ; } if ( ( n + 2 ) % i == 0 ) { Console . Write ( i + ", " + ( n + 2 ) / i ) ; break ; } } }
int count ( int n ) { int [ ] phi = new int [ n + 1 ] ; int [ ] divs = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { phi [ i ] += i ; for ( int j = i * 2 ; j <= n ; j += i ) phi [ j ] -= phi [ i ] ; for ( int j = i ; j <= n ; j += i ) divs [ j ] ++ ; } return ( n - phi [ n ] - divs [ n ] + 1 ) ; }
void inorder ( Node node ) { if ( node == null ) return ; inorder ( node . left ) ; Console . Write ( "{0} " , node . data ) ; inorder ( node . right ) ; }
int MinimumString ( int x ) { int b = 1 ; double left_lim = Math . Sqrt ( x ) + 1.0 ; double right_lim = Math . Sqrt ( x ) + 2.0 ; int r = 0 ; for ( int i = ( int ) left_lim ; i <= right_lim ; i ++ ) { if ( i > left_lim && i < right_lim ) { r = i ; break ; } } return b + r ; }
bool isPerfectSquare ( int N ) { int floorSqrt = ( int ) Math . Sqrt ( N ) ; return ( N == floorSqrt * floorSqrt ) ; }
bool legendreFunction ( int N ) { while ( N % 4 == 0 ) N /= 4 ; if ( N % 8 != 7 ) return true ; else return false ; }
int minSquares ( int N ) { if ( isPerfectSquare ( N ) ) return 1 ; for ( int i = 1 ; i * i < N ; i ++ ) { if ( isPerfectSquare ( N - i * i ) ) return 2 ; } if ( legendreFunction ( N ) ) return 3 ; return 4 ; }
bool is_distinct ( long n , long k ) { HashSet < long > s = new HashSet < long > ( ) ; for ( int i = 1 ; i <= k ; i ++ ) { long tmp = n % i ; if ( s . Contains ( tmp ) ) { return false ; } s . Add ( tmp ) ; } return true ; }
int getDivisors ( int min , int n ) { int total = 0 ; for ( int i = min ; i < n ; ++ i ) if ( n % i == 0 && n / i >= i ) { ++ total ; if ( n / i > i ) total += getDivisors ( i , n / i ) ; } return total ; }
void findWays ( List < int > arr , int i , int n ) { if ( n == 0 ) printList ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . Add ( j ) ; findWays ( arr , j , n - j ) ; arr . RemoveAt ( arr . Count - 1 ) ; } }
void spt_function ( int n ) { List < int > arr = new List < int > ( ) ; findWays ( arr , 1 , n ) ; Console . Write ( spt ) ; }
int isUgly ( int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; if ( n % 2 == 0 ) { return ( isUgly ( n / 2 ) ) ; } if ( n % 3 == 0 ) { return ( isUgly ( n / 3 ) ) ; } if ( n % 5 == 0 ) { return ( isUgly ( n / 5 ) ) ; } return 0 ; }
int findMinDenomin ( int n ) { return ( ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ) ; }
long calculate ( long p , long q ) { long mod = 998244353 , expo ; expo = mod - 2 ; while ( expo != 0 ) { if ( ( expo & 1 ) == 1 ) { p = ( p * q ) % mod ; } q = ( q * q ) % mod ; expo >>= 1 ; } return p ; }
int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ; if ( last_bit > 0 ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; }
int maxGCD ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return N / i ; } } return 1 ; }
int findMaximumGcd ( int n ) { int max_gcd = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; }
int findContent ( int [ ] arr , int n ) { int content = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { content = __gcd ( content , arr [ i ] ) ; } return content ; }
void inverseEqual ( int [ ] arr , int n ) { int [ ] brr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int present_index = arr [ i ] - 1 ; brr [ present_index ] = i + 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != brr [ i ] ) { Console . WriteLine ( "No" ) ; return ; } } Console . WriteLine ( "Yes" ) ; }
void linearCongruentialMethod ( int Xo , int m , int a , int c , int [ ] randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m ; } }
void multiplicativeCongruentialMethod ( int Xo , int m , int a , int [ ] randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m ; } }
void additiveCongruentialMethod ( int Xo , int m , int c , int [ ] randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] + c ) % m ; } }
int power ( int a , int b , int m ) { a %= m ; int res = 1 ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( ( res % m ) * ( a % m ) ) % m ; a = ( ( a % m ) * ( a % m ) ) % m ; b >>= 1 ; } return res % m ; }
int productOfDivisors ( int [ ] p , int n ) { Dictionary < int , int > prime = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime . ContainsKey ( p [ i ] ) ) prime [ p [ i ] ] = prime [ p [ i ] ] + 1 ; else prime . Add ( p [ i ] , 1 ) ; } int product = 1 , d = 1 ; foreach ( KeyValuePair < int , int > itr in prime ) { int val = power ( itr . Key , ( itr . Value ) * ( itr . Value + 1 ) / 2 , MOD ) ; product = ( power ( product , itr . Value + 1 , MOD ) * power ( val , d , MOD ) ) % MOD ; d = ( d * ( itr . Value + 1 ) ) % ( MOD - 1 ) ; } return product ; }
int numberOfObjects ( int N , int M ) { int initial = Math . Min ( N , M ) ; int last = ( N + M ) / 3 ; return Math . Min ( initial , last ) ; }
int MaxSubarrayLength ( int [ ] arr , int n , int k ) { int left = - 1 ; int right = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % k ) != 0 ) { if ( left == - 1 ) { left = i ; } right = i ; } sum += arr [ i ] ; } if ( ( sum % k ) != 0 ) { return n ; } else if ( left == - 1 ) { return - 1 ; } else { int prefix_length = left + 1 ; int suffix_length = n - right ; return n - Math . Min ( prefix_length , suffix_length ) ; } }
int findDistinct ( int [ ] arr , int n ) { int maximum = arr . Max ( ) ; if ( n == 1 ) return 1 ; if ( n == 2 ) { return ( maximum / gcd ( arr [ 0 ] , arr [ 1 ] ) ) ; } int k = gcd ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { k = gcd ( k , arr [ i ] ) ; } return ( maximum / k ) ; }
int power ( int a , int b ) { if ( b == 0 ) return 1 ; if ( b == 1 ) return a ; int tmp = power ( a , b / 2 ) ; int result = tmp * tmp ; if ( b % 2 == 1 ) result *= a ; return result ; }
int solve ( int X , int Y ) { if ( X > Y ) { int temp = X ; X = Y ; Y = temp ; } if ( X == Y ) Console . WriteLine ( 0 ) ; else if ( Y % X == 0 ) Console . WriteLine ( 1 ) ; else Console . WriteLine ( 2 ) ; return 0 ; }
void findWinner ( int n , int k ) { int cnt = 0 ; if ( n == 1 ) Console . Write ( "No" ) ; else if ( ( n & 1 ) != 0 n == 2 ) Console . Write ( "Yes" ) ; else { int tmp = n ; int val = 1 ; while ( tmp > k && tmp % 2 == 0 ) { tmp /= 2 ; val *= 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp /= i ; } } if ( tmp > 1 ) cnt ++ ; if ( val == n ) Console . Write ( "No" ) ; else if ( n / tmp == 2 && cnt == 1 ) Console . Write ( "No" ) ; else Console . Write ( "Yes" ) ; } }
long countQuadraples ( long N ) { long cnt = 0 ; Dictionary < long , long > m = new Dictionary < long , long > ( ) ; for ( long a = 1 ; a <= N ; a ++ ) { for ( long b = 1 ; b <= N ; b ++ ) { long x = a * a + b * b ; if ( m . ContainsKey ( x ) ) m [ x ] = m [ x ] + 1 ; else m . Add ( x , 1 ) ; } } for ( long c = 1 ; c <= N ; c ++ ) { for ( long d = 1 ; d <= N ; d ++ ) { long x = c * c + d * d ; if ( m . ContainsKey ( x ) ) cnt += m [ x ] ; } } return cnt ; }
int numberOfPairs ( int [ ] a , int [ ] b , int n ) { int [ ] c = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = a [ i ] - b [ i ] ; } Array . Sort ( c ) ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( c [ i ] <= 0 ) continue ; int pos = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( c [ i ] + c [ j ] > 0 ) { pos = j ; break ; } } answer += ( i - pos ) ; } return answer ; }
void isEqualFactors ( int N ) { if ( ( N % 2 == 0 ) && ( N % 4 != 0 ) ) Console . WriteLine ( "YES" ) ; else Console . WriteLine ( "NO" ) ; }
int count_crazy_primes ( int L , int R ) { int [ ] prime = new int [ R + 1 ] ; int [ ] countPrime = new int [ R + 1 ] ; int [ ] freqPrime = new int [ R + 1 ] ; prime [ 0 ] = 1 ; prime [ 1 ] = 1 ; for ( int p = 2 ; p * p <= R ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * p ; i <= R ; i += p ) prime [ i ] = 1 ; } } for ( int i = 1 ; i <= R ; i ++ ) { countPrime [ i ] = countPrime [ i - 1 ] ; if ( prime [ i ] != 0 ) { countPrime [ i ] ++ ; } } for ( int i = 1 ; i <= R ; i ++ ) { freqPrime [ i ] = freqPrime [ i - 1 ] ; if ( prime [ countPrime [ i ] ] != 0 ) { freqPrime [ i ] ++ ; } } return ( freqPrime [ R ] - freqPrime [ L - 1 ] ) ; }
void findNumbers ( int n , int b ) { double largest = Math . Pow ( b , n ) - 1 ; Console . Write ( largest ) ; }
void maximizedArray ( int [ ] arr , int N ) { int num , i = 0 ; for ( int l = N ; l > 0 ; l -- ) { num = arr [ i ] ; int one = 0 ; int zero = 0 ; while ( num != 0 ) { if ( num % 2 == 0 ) { zero ++ ; } else { one ++ ; } num = num >> 1 ; } for ( int j = zero ; j < ( one + zero ) ; j ++ ) { num += ( 1 << j ) ; } Console . Write ( num ) ; i ++ ; if ( N > 0 ) Console . Write ( ", " ) ; } }
void sieve ( ) { v [ 1 ] = 1 ; for ( int i = 2 ; i < x ; i ++ ) v [ i ] = i ; for ( int i = 4 ; i < x ; i += 2 ) v [ i ] = 2 ; for ( int i = 3 ; i * i < x ; i ++ ) { if ( v [ i ] == i ) { for ( int j = i * i ; j < x ; j += i ) { if ( v [ j ] == j ) { v [ j ] = i ; } } } } }
int prime_factors ( int n ) { HashSet < int > s = new HashSet < int > ( ) ; while ( n != 1 ) { s . Add ( v [ n ] ) ; n = n / v [ n ] ; } return s . Count ; }
void distinctPrimes ( int m , int k ) { List < int > result = new List < int > ( ) ; for ( int i = 14 ; i < m + k ; i ++ ) { long count = prime_factors ( i ) ; if ( count == k ) { result . Add ( i ) ; } } int p = result . Count ; for ( int index = 0 ; index < p - 1 ; index ++ ) { long element = result [ index ] ; int count = 1 , z = index ; while ( z < p - 1 && count <= k && result [ z ] + 1 == result [ z + 1 ] ) { count ++ ; z ++ ; } if ( count >= k ) Console . Write ( element + " " ) ; } }
int findGCD ( int [ ] arr , int n ) { int gcd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { gcd = __gcd ( arr [ i ] , gcd ) ; if ( gcd == 1 ) { return 1 ; } } return gcd ; }
int findLCM ( int [ ] arr , int n ) { int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { lcm = ( ( ( arr [ i ] * lcm ) ) / ( __gcd ( arr [ i ] , lcm ) ) ) ; } return lcm ; }
void compute ( int [ ] a , int N , int K ) { Dictionary < long , long > eqVal = new Dictionary < long , long > ( ) ; long maxX = 0 ; for ( int i = 0 ; i < N ; i ++ ) { long val = a [ i ] % K ; val = ( val == 0 ? 0 : K - val ) ; if ( val == 0 ) continue ; if ( eqVal . ContainsKey ( val ) ) { long numVal = eqVal [ val ] ; maxX = Math . Max ( maxX , val + ( K * numVal ) ) ; eqVal [ val ] = 1 + eqVal . GetValueOrDefault ( val , 0 ) ; } else { eqVal . Add ( val , 1 ) ; maxX = Math . Max ( maxX , val ) ; } } Console . Write ( maxX == 0 ? 0 : maxX + 1 ) ; }
void print_h_index ( int [ ] arr , int N ) { ArrayList ms = new ArrayList ( ) ; for ( int i = 0 ; i < N ; i ++ ) { ms . Add ( arr [ i ] ) ; int t = int . MaxValue ; foreach ( int x in ms ) { if ( x < t ) { t = x ; } } if ( t < ms . Count ) { ms . Remove ( t ) ; } Console . Write ( ms . Count + " " ) ; } }
void pen_hex ( long n ) { long pn = 1 ; for ( long i = 1 ; ; i ++ ) { pn = i * ( 3 * i - 1 ) / 2 ; if ( pn > n ) break ; double seqNum = ( 1 + Math . Sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == ( long ) ( seqNum ) ) { Console . Write ( pn + ", " ) ; } } }
int min_value ( int [ ] arr , int N ) { int X , K ; HashSet < int > S = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { S . Add ( arr [ i ] ) ; } int count = 0 ; for ( int i = 1 ; i <= 1024 ; i ++ ) { count = 0 ; foreach ( int it in S ) { X = ( ( i it ) - ( i & it ) ) ; if ( S . Contains ( X ) ) { count ++ ; } } if ( count == S . Count ) { K = i ; return K ; } } return - 1 ; }
int prefixProduct ( int [ ] a , int n ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i ] * a [ i - 1 ] ; } for ( int j = 0 ; j < n ; j ++ ) { Console . Write ( a [ j ] + ", " ) ; } return 0 ; }
void sumOfTheArrayForQuery ( int [ ] A , int N , int [ ] X , int [ ] Y , int Q ) { int sum = 0 ; Dictionary < int , int > count = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( count . ContainsKey ( A [ i ] ) ) { count [ A [ i ] ] = count [ A [ i ] ] + 1 ; } else { count . Add ( A [ i ] , 1 ) ; } } for ( int i = 0 ; i < Q ; i ++ ) { int x = X [ i ] , y = Y [ i ] ; if ( count . ContainsKey ( X [ i ] ) ) { sum -= count [ X [ i ] ] * X [ i ] ; sum += count [ X [ i ] ] * Y [ i ] ; } if ( count . ContainsKey ( Y [ i ] ) && count . ContainsKey ( X [ i ] ) ) { count [ Y [ i ] ] = count [ Y [ i ] ] + count [ X [ i ] ] ; } if ( count . ContainsKey ( X [ i ] ) ) { count [ X [ i ] ] = 0 ; } Console . Write ( sum + " " ) ; } }
int maxOR ( int [ ] arr , int n ) { int max_value = arr . Max ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . Max ( ans , ( max_value arr [ i ] ) ) ; } return ans ; }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void generateArr ( int [ ] A , int n ) { int [ ] B = new int [ n ] ; int maxi = A . Max ( ) ; int [ ] count = new int [ maxi + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { B [ i ] = count [ A [ i ] ] ; IncrementFactors ( count , A [ i ] ) ; } printArr ( B , n ) ; }
List < int > SieveOfEratosthenes ( int n ) { bool [ ] prime = new bool [ 2 * n + 1 ] ; Array . Fill ( prime , true ) ; for ( int p = 2 ; p * p <= 2 * n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 2 * n ; i += p ) prime [ i ] = false ; } } List < int > primes = new List < int > ( ) ; for ( int p = 2 ; p <= 2 * n ; p ++ ) if ( prime [ p ] ) primes . Add ( p ) ; return primes ; }
int minChanges ( int [ ] arr ) { int n = arr . Length ; int ans = 0 ; int maxi = arr [ 0 ] ; for ( int i = 1 ; i < arr . Length ; i ++ ) maxi = Math . Max ( maxi , arr [ i ] ) ; List < int > primes = SieveOfEratosthenes ( maxi ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = - 1 ; for ( int j = 0 ; j < primes . Count ; j ++ ) { if ( arr [ i ] == primes [ j ] ) { x = j ; break ; } else if ( arr [ i ] < primes [ j ] ) { x = j ; break ; } } int minm = Math . Abs ( primes [ x ] - arr [ i ] ) ; if ( x > 1 ) { minm = Math . Min ( minm , Math . Abs ( primes [ x - 1 ] - arr [ i ] ) ) ; } ans += minm ; } return ans ; }
int findSum ( int [ ] a , int n , int L , int R ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( L % a [ i ] == 0 && L != 0 ) { sum += calcSum ( a [ i ] , R / a [ i ] ) - calcSum ( a [ i ] , ( L - 1 ) / a [ i ] ) ; } else { sum += calcSum ( a [ i ] , R / a [ i ] ) - calcSum ( a [ i ] , L / a [ i ] ) ; } } return sum ; }
void findPrimes ( ) { for ( int i = 1 ; i <= maxN ; i ++ ) arr [ i ] = 1 ; arr [ 0 ] = 0 ; arr [ 1 ] = 0 ; for ( int i = 2 ; i * i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) { for ( int j = i * i ; j <= maxN ; j += i ) { arr [ j ] = 0 ; } } } int sum = 0 ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) { int temp = i ; sum = 0 ; while ( temp > 0 ) { int x = temp % 10 ; sum += x ; temp = temp / 10 ; if ( arr [ sum ] == 1 ) { prefix [ i ] = 1 ; } else { prefix [ i ] = 0 ; } } } } for ( int i = 1 ; i <= maxN ; i ++ ) { prefix [ i ] += prefix [ i - 1 ] ; } }
void print_product ( int a , int b , int c , int d ) { int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ; int real = prod1 - prod2 ; int imag = prod3 - ( prod1 + prod2 ) ; Console . Write ( real + " + " + imag + "i" ) ; }
int countWays ( int N ) { if ( N < 4 ) return 0 ; int ans = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; int s = 0 ; for ( int i = 2 ; i <= N - 3 ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) { if ( N == 2 * i + j ) s ++ ; } } if ( N % 3 == 0 ) s = 3 * s + 1 ; else s = 3 * s ; return ans - s ; }
double get_concentration ( double mass , double volume ) { if ( volume == 0 ) return - 1 ; else return ( mass / volume ) * 1000 ; }
bool isSubsetSum ( List < int > set , int n , int sum ) { bool [ , ] subset = new bool [ n + 1 , sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i , 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 , i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i , j ] = subset [ i - 1 , j ] ; if ( j >= set [ i - 1 ] ) subset [ i , j ] = subset [ i - 1 , j ] || subset [ i - 1 , j - set [ i - 1 ] ] ; } } return subset [ n , sum ] ; }
bool isPractical ( int N ) { List < int > div = new List < int > ( ) ; storeDivisors ( N , div ) ; for ( int i = 1 ; i < N ; i ++ ) { if ( ! isSubsetSum ( div , div . Count , i ) ) return false ; } return true ; }
bool isJunction ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i + sum ( i ) == n ) count ++ ; } return count >= 2 ; }
bool isDivBySubsetSums ( List < int > arr , int num ) { int n = arr . Count ; long total = 1 << n ; for ( long i = 0 ; i < total ; i ++ ) { long sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( i & ( 1 << j ) ) > 0 ) sum += arr [ j ] ; if ( sum != 0 && num % sum != 0 ) return false ; } return true ; }
bool isSuperNivenNum ( int n ) { int temp = n ; List < int > digits = new List < int > ( ) ; while ( n != 0 ) { int digit = n % 10 ; digits . Add ( digit ) ; n = n / 10 ; } return isDivBySubsetSums ( digits , temp ) ; }
int divCount ( int n ) { bool [ ] hash = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) hash [ i ] = true ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
bool isHighlyCompositeNumber ( int N ) { int NdivCount = divCount ( N ) ; for ( int i = 1 ; i < N ; i ++ ) { int idivCount = divCount ( i ) ; if ( idivCount >= NdivCount ) return false ; } return true ; }
bool isInsolite ( int n ) { int N = n ; int sum = 0 ; int product = 1 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = n / 10 ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; }
bool isSaintExuperyNum ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n / i / j ; if ( i * i + j * j == k * k ) { if ( i * j * k == n ) return true ; } } } return false ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool isMagnanimous ( int N ) { String s = N . ToString ( ) ; int l = s . Length ; if ( l < 2 ) return false ; for ( int i = 0 ; i < l - 1 ; i ++ ) { String left = s . Substring ( 0 , i + 1 ) ; String right = s . Substring ( i + 1 ) ; int x = int . Parse ( left ) ; int y = int . Parse ( right ) ; if ( ! isPrime ( x + y ) ) return false ; } return true ; }
int digProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int nextPrime ( int N ) { if ( N <= 1 ) return 2 ; int prime = N ; bool found = false ; while ( ! found ) { prime ++ ; if ( isPrime ( prime ) ) found = true ; } return prime ; }
bool isPointerPrime ( int n ) { if ( isPrime ( n ) && ( n + digProduct ( n ) == nextPrime ( n ) ) ) return true ; else return false ; }
void sieve ( ) { position [ 0 ] = - 1 ; position [ 1 ] = - 1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = - 1 ; } } }
int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
int power ( int x , int y ) { if ( y == 0 ) { return 1 ; } if ( y % 2 == 0 ) { return ( power ( x , y / 2 ) * power ( x , y / 2 ) ) ; } return ( x * power ( x , y / 2 ) * power ( x , y / 2 ) ) ; }
bool isPerfectDigitalInvariant ( int x ) { for ( int fixed_power = 1 ; ; fixed_power ++ ) { int temp = x , sum = 0 ; while ( temp > 0 ) { int r = temp % 10 ; sum += power ( r , fixed_power ) ; temp = temp / 10 ; } if ( sum == x ) { return true ; } if ( sum > x ) { return false ; } } }
bool isWasteful ( int n ) { if ( n == 1 ) return false ; int original_no = n ; int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits ++ ; original_no = original_no / 10 ; } int pDigit = 0 , count_exp = 0 , p = 0 ; for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { while ( n % primes [ i ] == 0 ) { p = primes [ i ] ; n = n / p ; count_exp ++ ; } while ( p > 0 ) { pDigit ++ ; p = p / 10 ; } while ( count_exp > 1 ) { pDigit ++ ; count_exp = count_exp / 10 ; } } if ( n != 1 ) { while ( n > 0 ) { pDigit ++ ; n = n / 10 ; } } return ( pDigit > sumDigits ) ; }
void Solve ( int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( isWasteful ( i ) ) { Console . Write ( i + " " ) ; } } }
bool isDNum ( int n ) { if ( n < 4 ) return false ; int numerator = 0 , hcf = 0 ; for ( int k = 2 ; k <= n ; k ++ ) { numerator = ( int ) ( Math . Pow ( k , n - 2 ) - k ) ; hcf = __gcd ( n , k ) ; } if ( hcf == 1 && ( numerator % n ) != 0 ) return false ; return true ; }
bool isComposite ( int n ) { if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
bool isEnlightened ( int N ) { if ( ! isComposite ( N ) ) return false ; String num = String . Join ( "" , N ) ; String prefixConc = concatenatePrimeFactors ( N ) ; return num . StartsWith ( prefixConc ) ; }
bool isIdoneal ( int n ) { for ( int a = 1 ; a <= n ; a ++ ) { for ( int b = a + 1 ; b <= n ; b ++ ) { for ( int c = b + 1 ; c <= n ; c ++ ) { if ( a * b + b * c + c * a == n ) return false ; } } } return true ; }
bool isAllDigitsDivide ( int n ) { int temp = n ; while ( temp > 0 ) { int digit = temp % 10 ; if ( ! ( checkDivisibility ( n , digit ) ) ) return false ; temp /= 10 ; } return true ; }
bool isAllDigitsDistinct ( int n ) { bool [ ] arr = new bool [ 10 ] ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }
bool isLynchBell ( int n ) { return isAllDigitsDivide ( n ) && isAllDigitsDistinct ( n ) ; }
int printhexaRec ( int n ) { if ( n == 0 n == 1 n == 2 n == 3 n == 4 n == 5 ) return 0 ; else if ( n == 6 ) return 1 ; else return ( printhexaRec ( n - 1 ) + printhexaRec ( n - 2 ) + printhexaRec ( n - 3 ) + printhexaRec ( n - 4 ) + printhexaRec ( n - 5 ) + printhexaRec ( n - 6 ) ) ; }
void printhexa ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 0 ; int sixth = 1 ; int curr = 0 ; if ( n < 6 ) Console . WriteLine ( first ) ; else if ( n == 6 ) Console . WriteLine ( sixth ) ; else { for ( int i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } Console . WriteLine ( curr ) ; }
bool isGapful ( int n ) { int first_dig = firstDigit ( n ) ; int last_dig = lastDigit ( n ) ; int concatenation = first_dig * 10 + last_dig ; return ( n % concatenation == 0 ) ; }
bool check ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
bool isPossible ( int A , int B , int N , int K , int L ) { int needa , needb ; if ( A % K == 0 ) needa = A / K ; else needa = A / K + 1 ; if ( B % L == 0 ) needb = B / L ; else needb = B / L + 1 ; int total = needa + needb ; if ( total > N ) return false ; else return true ; }
void CountTotalfactors ( ) { tfactor [ 1 ] = pre [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { int mspf = spf [ i ] ; int prim = mspf ; int temp = i ; int cnt = 0 ; while ( temp % mspf == 0 ) { temp /= mspf ; cnt += 1 ; prim = prim * mspf ; } tfactor [ i ] = ( cnt + 1 ) * tfactor [ temp ] ; pre [ i ] = pre [ i - 1 ] + tfactor [ i ] ; } }
int BinarySearch ( int X ) { int start = 1 ; int end = MAX - 1 ; while ( start < end ) { int mid = ( start + end ) / 2 ; if ( pre [ mid ] == X ) return mid ; else if ( pre [ mid ] < X ) start = mid + 1 ; else end = mid ; } return start ; }
void buildSieve ( int sum ) { prime = new bool [ sum + 1 ] ; for ( int i = 0 ; i < prime . Length ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < ( sum + 1 ) ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < ( sum + 1 ) ; i += p ) prime [ i ] = false ; } } }
int getSum ( int [ , ] a ) { int s = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 5 ; j ++ ) s += a [ i , j ] ; return s ; }
bool checkIndex ( int n , int m , int [ , ] a ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( prime [ i + j ] && ! prime [ a [ i , j ] ] ) { return false ; } } } return true ; }
int takeSum ( int [ ] [ ] a ) { int s = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) s += a [ i ] [ j ] ; return s ; }
long sumOfSumSeries ( int N ) { long sum = 0L ; for ( int i = 1 ; i <= N ; i ++ ) { sum = sum + ( i * ( i + 1 ) ) / 2 ; } return sum ; }
bool isPrime ( int n ) { if ( n == 1 ) return true ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void checkExpression ( int n ) { if ( isPrime ( n ) ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
int placeValue ( int N , int num ) { int total = 1 , value = 0 , rem = 0 ; while ( true ) { rem = N % 10 ; N = N / 10 ; if ( rem == num ) { value = total * rem ; break ; } total = total * 10 ; } return value ; }
bool isContaindigit ( int n ) { while ( n > 0 ) { if ( ! ( n % 10 == 0 n % 10 == 1 n % 10 == 8 ) ) return false ; n = n / 10 ; } return true ; }
bool ispalindrome ( int n ) { string temp = n . ToString ( ) ; int l = temp . Length ; for ( int i = 0 ; i < l / 2 ; i ++ ) { if ( temp [ i ] != temp [ l - i - 1 ] ) return false ; } return true ; }
void printTetradicPrimesLessThanN ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; Array . Fill ( prime , true ) ; int p = 2 ; while ( p * p <= n ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < n + 1 ; i += p ) prime [ i ] = false ; } p += 1 ; } for ( p = 2 ; p < n + 1 ; p ++ ) { if ( prime [ p ] && isTetradic ( p ) ) Console . Write ( p + " " ) ; } }
void BeattySequence ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { double ans = Math . Floor ( i * Math . Sqrt ( 2 ) ) ; Console . Write ( ans + ", " ) ; } }
int concat ( int a , int b ) { String s1 = a . ToString ( ) ; String s2 = b . ToString ( ) ; String s = s1 + s2 ; int c = Int32 . Parse ( s ) ; return c ; }
bool isAstonishing ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += j ; if ( sum == n ) { int concatenation = concat ( i , j ) ; if ( concatenation == n ) { return true ; } } } } return false ; }
int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
bool isSelfNum ( int n ) { for ( int m = 1 ; m <= n ; m ++ ) { if ( m + getSum ( m ) == n ) return false ; } return true ; }
int Sum ( int N ) { int [ ] SumOfPrimeDivisors = new int [ N + 1 ] ; for ( int i = 2 ; i <= N ; ++ i ) { if ( SumOfPrimeDivisors [ i ] == 1 ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; }
bool RuthAaronNumber ( int n ) { if ( Sum ( n ) == Sum ( n + 1 ) ) return true ; else return false ; }
int binomialCoeff ( int n , int k ) { int [ , ] C = new int [ n + 1 , k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } return C [ n , k ] ; }
void SieveOfEratosthenes ( int n , bool [ ] isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
int countDigit ( int n ) { int count = 0 ; while ( n != 0 ) { n = n / 10 ; ++ count ; } return count ; }
Stack < int > sortStack ( Stack < int > input ) { Stack < int > tmpStack = new Stack < int > ( ) ; while ( input . Count != 0 ) { int tmp = input . Peek ( ) ; input . Pop ( ) ; while ( tmpStack . Count != 0 && tmpStack . Peek ( ) < tmp ) { input . Push ( tmpStack . Peek ( ) ) ; tmpStack . Pop ( ) ; } tmpStack . Push ( tmp ) ; } return tmpStack ; }
void sortArrayUsingStacks ( int [ ] arr , int n ) { Stack < int > input = new Stack < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) input . Push ( arr [ i ] ) ; Stack < int > tmpStack = sortStack ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = tmpStack . Peek ( ) ; tmpStack . Pop ( ) ; } }
int getSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; }
bool MultiplyPerfectNumber ( int n ) { if ( getSum ( n ) % n == 0 ) return true ; else return false ; }
int phi ( int n ) { int result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) { n /= p ; } result -= result / p ; } } if ( n > 1 ) result -= result / n ; return result ; }
bool isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = Math . Log ( a ) / Math . Log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; }
bool isCunningham ( int n ) { return isPower ( n - 1 ) || isPower ( n + 1 ) ; }
bool checkSame ( int n , int b ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; while ( n != 0 ) { int r = n % b ; n = n / b ; if ( m . ContainsKey ( r ) ) { m [ r ] = m [ r ] + 1 ; } else { m . Add ( r , 1 ) ; } } int last = - 1 ; foreach ( KeyValuePair < int , int > i in m ) { if ( last != - 1 && i . Value != last ) { return false ; } else { last = i . Value ; } } return true ; }
int SubArrayProdct ( int [ ] arr , int n ) { int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result *= ( int ) ( Math . Pow ( arr [ i ] , ( i + 1 ) * ( n - i ) ) ) ; return result ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int countWays ( int m , int n , int x , int y ) { return nCr ( m + n , m ) - nCr ( x + y , x ) * nCr ( m + n - x - y , m - x ) ; }
int averageRuns ( int runs , int matches , int notout ) { int out1 ; out1 = matches - notout ; if ( out1 == 0 ) return - 1 ; int avg = ( runs ) / out1 ; return avg ; }
int seriesSum ( int n ) { int sum = 0 ; int currProd = 1 ; int currSum = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { currProd *= i ; currSum += i ; sum += currProd - currSum ; } return sum ; }
int seriesSumUtil ( int k , int n , int prevSum , int multi , int add ) { if ( k == n + 1 ) { return prevSum ; } multi = multi * k ; add = add + k ; prevSum = prevSum + multi - add ; return seriesSumUtil ( k + 1 , n , prevSum , multi , add ) ; }
int seriesSum ( int n ) { if ( n == 1 ) return 0 ; int prevSum = 0 ; int multi = 1 ; int add = 1 ; return seriesSumUtil ( 2 , n , prevSum , multi , add ) ; }
void Is_possible ( long N ) { long C = 0 ; long D = 0 ; while ( N % 10 == 0 ) { N = N / 10 ; C += 1 ; } if ( Math . Pow ( 2 , ( long ) ( Math . Log ( N ) / ( Math . Log ( 2 ) ) ) ) == N ) { D = ( long ) ( Math . Log ( N ) / ( Math . Log ( 2 ) ) ) ; if ( C >= D ) Console . WriteLine ( "YES" ) ; else Console . WriteLine ( "NO" ) ; } else Console . WriteLine ( "NO" ) ; }
int maximumAND ( int L , int R ) { return R ; }
int count ( int [ ] a , int n ) { int countElements = 0 ; for ( int i = 0 ; i < n ; i ++ ) { bool flag = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( a [ i ] % a [ j ] == 0 ) { flag = false ; break ; } } if ( flag == true ) ++ countElements ; } return countElements ; }
int countEle ( int [ ] a , int n ) { int len = 0 ; Dictionary < int , int > hmap = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { len = Math . Max ( len , a [ i ] ) ; if ( hmap . ContainsKey ( a [ i ] ) ) { hmap [ a [ i ] ] ++ ; } else { hmap . Add ( a [ i ] , 1 ) ; } } bool [ ] v = new bool [ len + 1 ] ; for ( int i = 0 ; i <= len ; i ++ ) { v [ i ] = true ; } for ( int i = 0 ; i < n ; i ++ ) { if ( v [ a [ i ] ] == false ) continue ; for ( int j = 2 * a [ i ] ; j <= len ; j += a [ i ] ) { v [ j ] = false ; } } int count = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { if ( v [ i ] == true && hmap . ContainsKey ( i ) && hmap [ i ] == 1 && hmap [ i ] == 1 ) { count += 1 ; } } return count ; }
int find_min_sum ( int a , int b , int c ) { int x = 0 , y = 0 , g = 0 ; if ( possible_solution ( a , b , c ) == 0 ) return - 1 ; if ( g != 0 ) { a /= g ; b /= g ; } int sign_a = a > 0 ? + 1 : - 1 ; int sign_b = b > 0 ? + 1 : - 1 ; shift_solution ( a , b , - x / b ) ; if ( x < 0 ) shift_solution ( a , b , sign_b ) ; int minx1 = x ; shift_solution ( a , b , y / a ) ; if ( y < 0 ) shift_solution ( a , b , - sign_a ) ; int minx2 = x ; if ( minx2 > x ) { int temp = minx2 ; minx2 = x ; x = temp ; } int minx = Math . Max ( minx1 , minx2 ) ; if ( minx > x ) return - 1 ; int miny = ( c - a * x ) / b ; return ( miny + minx ) ; }
int countPairs ( int [ ] A , int n ) { int count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( A [ i ] % 2 == 0 && A [ j ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ j ] % 2 != 0 ) ) count ++ ; } } return count ; }
int smallestNumber ( int N ) { return ( int ) ( N * Math . Ceiling ( Math . Pow ( 10 , ( N - 1 ) ) / N ) ) ; }
int maxPrimefactorNum ( int N ) { int [ ] arr = new int [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) arr [ i ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( arr [ i ] == 1 ) { for ( int j = i ; j <= N ; j += i ) { arr [ j ] *= i ; } } } int maxValue = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( arr [ i ] > maxValue ) { maxValue = i ; } } return maxValue ; }
int linearSum ( int n ) { return ( n * ( n + 1 ) / 2 ) % mod ; }
int rangeSum ( int b , int a ) { return ( linearSum ( b ) - linearSum ( a ) ) % mod ; }
int totalSum ( int n ) { int result = 0 ; int i = 1 ; while ( true ) { result += rangeSum ( n / i , n / ( i + 1 ) ) * ( i % mod ) % mod ; result %= mod ; if ( i == n ) break ; i = n / ( n / ( i + 1 ) ) ; } return result ; }
int CountPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; }
bool isPal ( int [ , ] a , int n , int m ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i , j ] != a [ n - 1 - i , m - 1 - j ] ) return false ; } } return true ; }
int smallestNum ( int n ) { return ( int ) ( ( n * n % 9 + 1 ) * Math . Pow ( 10 , n * n / 9 ) - 1 ) ; }
void smallestNumber ( int N ) { Console . WriteLine ( ( N % 9 + 1 ) * Math . Pow ( 10 , ( N / 9 ) ) - 1 ) ; }
void findNthTerm ( int n ) { Console . Write ( n * ( 5 * n + 3 ) / 2 ) ; }
void findNthTerm ( int n ) { Console . Write ( n * ( 2 * n + 1 ) ) ; }
int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
bool isPerfectSquare ( double x ) { double sr = Math . Sqrt ( x ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ; }
bool isRare ( int N ) { int reverseN = reversDigits ( N ) ; if ( reverseN == N ) return false ; return isPerfectSquare ( N + reverseN ) && isPerfectSquare ( N - reverseN ) ; }
int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
bool isDouble ( int num ) { String s = num . ToString ( ) ; int l = s . Length ; if ( s [ 0 ] == s [ 1 ] ) return false ; if ( l % 2 == 1 ) { s = s + s [ 1 ] ; l ++ ; } String s1 = s . Substring ( 0 , l / 2 ) ; String s2 = s . Substring ( l / 2 ) ; return s1 . Equals ( s2 ) ; }
bool isNontrivialUndulant ( int N ) { return N > 100 && isDouble ( N ) ; }
void findNthTerm ( int n ) { Console . WriteLine ( n * ( 4 * n + 3 ) ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
bool isAdditivePrime ( int n ) { if ( ! isPrime ( n ) ) return false ; return isPrime ( getSum ( n ) ) ; }
bool isStraighLineNum ( int N ) { if ( N <= 99 ) return false ; string s = N . ToString ( ) ; int d = s [ 1 ] - s [ 0 ] ; for ( int i = 2 ; i < s . Length ; i ++ ) if ( s [ i ] - s [ i - 1 ] != d ) return false ; return true ; }
void findNthTerm ( int n ) { Console . Write ( Math . Pow ( 2 , n ) - 2 * n ) ; }
bool isEvenOddForm ( String s ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 && s [ i ] % 2 != 0 ) return false ; if ( i % 2 == 1 && s [ i ] % 2 != 1 ) return false ; } return true ; }
bool isOddEvenForm ( String s ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 && s [ i ] % 2 != 1 ) return false ; if ( i % 2 == 1 && s [ i ] % 2 != 0 ) return false ; } return true ; }
bool isAlternating ( int n ) { String str = n . ToString ( ) ; return ( isEvenOddForm ( str ) || isOddEvenForm ( str ) ) ; }
void findNthTerm ( int n ) { Console . Write ( n * n - n + 1 ) ; }
bool isDroll ( int n ) { if ( n == 1 ) return false ; int sum_even = 0 ; int sum_odd = 0 ; while ( n % 2 == 0 ) { sum_even += 2 ; n = n / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { sum_odd += i ; n = n / i ; } } if ( n > 2 ) sum_odd += n ; return sum_even == sum_odd ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool areAnagrams ( int a , int b ) { int [ ] freqA = new int [ TEN ] ; int [ ] freqB = new int [ TEN ] ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( int i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; }
int DecakismyriagonNum ( int N ) { return ( 99998 * N * N - 99996 * N ) / 2 ; }
bool iszygodromeNum ( int N ) { String s = N . ToString ( ) ; s = ' ' + s + ' ' ; for ( int i = 1 ; i < s . Length - 1 ; i ++ ) { if ( s [ i ] != s [ i - 1 ] && s [ i ] != s [ i + 1 ] ) { return false ; } } return true ; }
bool isLoeschian ( int n ) { for ( int x = 1 ; x <= Math . Sqrt ( n ) ; x ++ ) { for ( int y = 1 ; y <= Math . Sqrt ( n ) ; y ++ ) { if ( x * x + x * y + y * y == n ) return true ; } } return false ; }
void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = ( 13 * i * ( i - 1 ) ) / 2 + 2 ; Console . Write ( ith_term + ", " ) ; } }
void printSeries ( int n , int a , int b , int c ) { int d ; if ( n == 1 ) { Console . Write ( a + " " ) ; return ; } if ( n == 2 ) { Console . Write ( a + " " + b + " " ) ; return ; } Console . Write ( a + " " + b + " " + c + " " ) ; for ( int i = 4 ; i <= n ; i ++ ) { d = a + b + c ; Console . Write ( d + " " ) ; a = b ; b = c ; c = d ; } }
void sieveSundaram ( ) { bool [ ] marked = new bool [ MAX / 2 + 1 ] ; for ( int i = 1 ; i <= ( Math . Sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j += 2 * i + 1 ) marked [ j ] = true ; primes . Add ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . Add ( 2 * i + 1 ) ; }
List < pair > Pairs ( int C ) { List < pair > ans = new List < pair > ( ) ; for ( int i = 1 ; i < C ; i ++ ) { for ( int j = i + 1 ; j < C ; j ++ ) { if ( ( i * i ) + ( j * j ) == ( C * C ) ) { ans . Add ( new pair ( i , j ) ) ; } } } return ans ; }
float strikerate ( float bowls , float runs ) { float z ; z = ( runs / bowls ) * 100 ; return z ; }
int factorize ( int N ) { int count = 0 ; int cnt = 0 ; while ( ( N % 2 ) == 0 ) { N = N / 2 ; count ++ ; } cnt = cnt + count ; for ( int i = 3 ; i <= Math . Sqrt ( N ) ; i += 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } cnt = cnt + count ; } if ( N > 2 ) cnt = cnt + 1 ; return cnt ; }
void ifNumberExists ( int X , int Y ) { int C , dsum ; C = X - Y - 1 ; dsum = factorize ( X ) ; if ( dsum >= C ) Console . WriteLine ( "YES" ) ; else Console . WriteLine ( "NO" ) ; }
bool checkArray ( int n , int k , int [ ] arr ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; }
void print_nearest_prime ( int [ ] arr , int N ) { int maxm = arr . Max ( ) ; SieveOfEratosthenes ( maxm ) ; List < int > primes = new List < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! prime [ arr [ i ] ] ) primes . Add ( i ) ; } if ( primes . Count == 0 ) { for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( - 1 + " " ) ; } return ; } int curr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( curr == primes . Count - 1 || i <= primes [ curr ] ) { Console . Write ( arr [ primes [ curr ] ] + " " ) ; continue ; } if ( Math . Abs ( primes [ curr ] - i ) < Math . Abs ( primes [ curr + 1 ] - i ) ) { Console . Write ( arr [ primes [ curr ] ] + " " ) ; } else { curr ++ ; Console . Write ( arr [ primes [ curr ] ] + " " ) ; } } }
int CountPairs ( int n ) { int cnt = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int div1 = i ; int div2 = n / i ; int sum = div1 + div2 ; if ( gcd ( sum , n ) == 1 ) cnt += 1 ; } } return cnt ; }
void allQuotients ( int N ) { SortedSet < int > s = new SortedSet < int > ( ) ; for ( int k = 1 ; k <= N + 1 ; k ++ ) { s . Add ( N / k ) ; } foreach ( int it in s ) { Console . Write ( it + " " ) ; } }
void findPosition ( int n ) { int i = 0 ; int pos = 0 ; while ( n > 0 ) { if ( n % 10 == 7 ) { pos = pos + ( int ) Math . Pow ( 2 , i + 1 ) ; } else { pos = pos + ( int ) Math . Pow ( 2 , i ) ; } i ++ ; n = n / 10 ; } Console . Write ( pos ) ; }
int greatestOddFactor ( int n ) { int pow_2 = ( int ) ( Math . Log ( n ) ) ; int i = 1 ; while ( i <= pow_2 ) { int fac_2 = ( 2 * i ) ; if ( n % fac_2 == 0 ) { if ( ( n / fac_2 ) % 2 == 1 ) { return ( n / fac_2 ) ; } } i += 1 ; } return 0 ; }
void countSmaller ( String str ) { int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] < str [ i ] ) { cnt += 1 ; } } Console . Write ( cnt + " " ) ; } }
int sum_star_num ( int n ) { int summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n ; return summ ; }
void solve ( int n , ArrayList vec ) { ArrayList a = new ArrayList ( ) ; ArrayList b = new ArrayList ( ) ; foreach ( Point pr in vec ) { a . Add ( pr . x ) ; b . Add ( pr . y ) ; } a . Sort ( ) ; b . Sort ( ) ; int left , right , ans ; if ( ( n & 1 ) != 0 ) { left = ( int ) a [ n / 2 ] ; right = ( int ) b [ n / 2 ] ; ans = right - left + 1 ; } else { left = ( ( int ) a [ n / 2 ] + ( int ) a [ n / 2 - 1 ] ) ; right = ( ( int ) b [ n / 2 ] + ( int ) b [ n / 2 - 1 ] ) ; ans = right - left + 1 ; } Console . WriteLine ( ans ) ; }
int find_pairs ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } foreach ( KeyValuePair < int , int > i in mp ) { int count = i . Value ; if ( count > 1 ) { ans += ( ( count * ( count - 1 ) ) / 2 ) ; } } return ans ; }
string Majority_in_linklist ( node head ) { string s = "" ; string t = "" ; int p = 0 , q = 0 ; node ptr = null ; while ( head != null ) { if ( s . Equals ( head . i ) ) { p = p + 1 ; } else { if ( t . Equals ( head . i ) ) { q = q + 1 ; } else { if ( p == 0 ) { s = head . i ; p = 1 ; } else { if ( q == 0 ) { t = head . i ; q = 1 ; } else { p = p - 1 ; q = q - 1 ; } } } } head = head . next ; } head = ptr ; p = 0 ; q = 0 ; while ( head != null ) { if ( s . Equals ( head . i ) ) { p = 1 ; } else { if ( t . Equals ( head . i ) ) { q = 1 ; } } head = head . next ; } if ( p > q ) { return s ; } else { return t ; } }
int gonNum65537 ( int n ) { return ( 65535 * n * n - 65533 * n ) / 2 ; }
int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; }
int gonNum120 ( int n ) { return ( 118 * n * n - 116 * n ) / 2 ; }
int TetracontaoctagonalNum ( int n ) { return ( 46 * n * n - 44 * n ) / 2 ; }
int TetracontadigonalNum ( int n ) { return ( 40 * n * n - 38 * n ) / 2 ; }
int HexacontatetragonNum ( int n ) { return ( 62 * n * n - 60 * n ) / 2 ; }
int binpow ( int a , int b ) { int res = 1 ; while ( b > 0 ) { if ( b % 2 == 1 ) res = res * a ; a = a * a ; b /= 2 ; } return res ; }
bool checkOverlapping ( List < int > a , List < int > b ) { if ( a [ 0 ] < b [ 0 ] ) { int temp = a [ 0 ] ; a [ 0 ] = b [ 0 ] ; b [ 0 ] = temp ; temp = a [ 1 ] ; a [ 1 ] = b [ 1 ] ; b [ 1 ] = temp ; } if ( b [ 0 ] <= a [ 0 ] && a [ 0 ] <= b [ 1 ] ) return true ; return false ; }
int find ( List < int > a , int i ) { if ( a [ i ] == i ) { return i ; } a [ i ] = find ( a , a [ i ] ) ; return a [ i ] ; }
bool checkNonOverlapping ( List < List < int > > arr , int n ) { List < int > dsu = new List < int > ( ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dsu . Add ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( checkOverlapping ( arr [ i ] , arr [ j ] ) ) { if ( union ( dsu , i , j ) ) { return false ; } } } } return true ; }
bool isPossible ( int A , int B ) { return ( A - B > 1 ) ; }
int minDivisorDifference ( int n ) { int num1 = 0 ; int num2 = 0 ; for ( int i = ( int ) Math . Sqrt ( n ) ; i <= n ; i ++ ) { if ( n % i == 0 ) { num1 = i ; num2 = n / i ; break ; } } return Math . Abs ( num1 - num2 ) ; }
int dfs ( List < int > [ ] g , int u , int par ) { sub [ u ] = minDivisorDifference ( u ) ; int mx = 0 ; foreach ( int c in g [ u ] ) { if ( c != par ) { int ans = dfs ( g , c , u ) ; mx = Math . Max ( mx , ans ) ; } } sub [ u ] += mx ; return sub [ u ] ; }
int findLCMPrime ( int a , int b ) { if ( a == b ) { return a ; } return a * b ; }
void smallestNumber ( int N ) { Console . Write ( N * Math . Ceiling ( Math . Pow ( 2 , ( N - 1 ) ) / N ) ) ; }
void smallestNumber ( int N ) { Console . Write ( N * Math . Floor ( ( Math . Pow ( 10 , N ) - 1 ) / N ) ) ; }
bool istriacontagonal ( int N ) { float n = ( float ) ( ( 26 + Math . Sqrt ( 224 * N + 676 ) ) / 56 ) ; return ( n - ( int ) n ) == 0 ; }
void checkSolution ( int a , int b , int c ) { if ( a == c ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
bool isComposite ( int n ) { if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; int i = 5 ; while ( i * i <= n ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; i = i + 6 ; } return false ; }
void Compositorial_list ( int n ) { int l = 0 ; for ( int i = 4 ; i < 1000000 ; i ++ ) { if ( l < n ) { if ( isComposite ( i ) ) { compo . Add ( i ) ; l += 1 ; } } } }
int calculateCompositorial ( int n ) { int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result = result * compo [ i ] ; return result ; }
void numberOfDigits ( int N ) { int nod = ( int ) Math . Floor ( Math . Log10 ( N ) + 1 ) ; int toDecrease = ( int ) ( Math . Pow ( 10 , nod ) - 1 ) / 9 ; Console . Write ( ( N + 1 ) * nod - toDecrease ) ; }
void Maxlength ( int [ ] arr , int N ) { int [ ] zeroindex = new int [ 20000 ] ; int maxlen ; int size = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zeroindex [ size ++ ] = i ; } if ( size == 0 ) { maxlen = N ; } else { maxlen = zeroindex [ 0 ] ; for ( int i = 0 ; i < size ; i ++ ) { if ( zeroindex [ i + 1 ] - zeroindex [ i ] - 1 > maxlen ) { maxlen = zeroindex [ i + 1 ] - zeroindex [ i ] - 1 ; } } if ( N - zeroindex [ size - 1 ] - 1 > maxlen ) { maxlen = N - zeroindex [ size - 1 ] - 1 ; } } Console . WriteLine ( maxlen ) ; }
bool isPossible ( int [ ] arr , int N , int K ) { int oddCount = 0 , evenCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCount ++ ; } else { oddCount ++ ; } } if ( evenCount == N || ( oddCount == N && K % 2 == 0 ) || ( K == N && oddCount % 2 == 0 ) ) { return false ; } else { return true ; } }
float productOfGP ( float a , float r , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; }
float productOfGP ( float a , float r , int n ) { return ( float ) Math . Pow ( a , n ) * ( float ) Math . Pow ( r , n * ( n - 1 ) / 2 ) ; }
float productOfGP ( float a , float r , int n ) { int an = ( int ) ( a * ( int ) ( Math . Pow ( r , n - 1 ) ) ) ; return ( int ) Math . Sqrt ( ( int ) Math . Pow ( a * an , n ) ) ; }
bool is_Chiliagon ( int N ) { float n = ( float ) ( 996 + Math . Sqrt ( 7984 * N + 992016 ) ) / 1996 ; return ( n - ( int ) n ) == 0 ; }
int commonSubarrays ( int [ ] A , int [ ] B , int N ) { int [ ] Map = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) Map [ A [ i ] ] = i ; for ( int i = 0 ; i < N ; i ++ ) { B [ i ] = Map [ B [ i ] ] ; } int count = 0 ; int a = 0 , K ; while ( a < N ) { K = 1 ; a += 1 ; while ( a < N && B [ a ] == B [ a - 1 ] + 1 ) { a += 1 ; K += 1 ; } count = count + ( ( K ) * ( K + 1 ) ) / 2 ; } return count ; }
void getArrayOfSizeK ( int n , int k ) { List < int > ans = new List < int > ( ) ; int odd = n - ( ( k - 1 ) * 1 ) ; if ( odd > 0 && odd % 2 != 0 ) { for ( int i = 0 ; i < k - 1 ; i ++ ) { ans . Add ( 1 ) ; } ans . Add ( odd ) ; } int even = n - ( ( k - 1 ) * 2 ) ; if ( even > 0 && even % 2 == 0 && ans . Count == 0 ) { for ( int i = 0 ; i < k - 1 ; i ++ ) { ans . Add ( 2 ) ; } ans . Add ( even ) ; } if ( ans . Count > 0 ) { for ( int i = 0 ; i < k ; i ++ ) { Console . Write ( ans [ i ] + " " ) ; } } else { Console . WriteLine ( "NO" ) ; } }
bool checkDivisbility ( int num ) { int digit ; int N = num ; while ( num != 0 ) { digit = num % 10 ; num = num / 10 ; if ( digit == 0 N % digit != 0 ) return false ; } return true ; }
int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
int derivative ( int x ) { return 3 * x * x ; }
int Image ( int x , int k ) { return x * x * x - k ; }
int next_power ( int a_t , int t , int a1 , int prime , int k ) { int power_p = ( int ) Math . Pow ( prime , t + 1 ) ; int next_a = ( a_t - Image ( a_t , k ) * inv ( derivative ( a1 ) , prime ) ) % power_p ; if ( next_a < 0 ) return next_a += power_p ; return next_a ; }
int powerOfPrime ( int prime , int power , int k , int a1 ) { if ( derivative ( a1 ) != 0 ) { int a_t = a1 ; for ( int p = 1 ; p < power ; p ++ ) { a_t = next_power ( a_t , p , a1 , prime , k ) ; } return a_t ; } return - 1 ; }
int findlcm ( int [ ] arr , int n ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; } return ans ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int minLCM ( int [ ] arr , int n ) { int ans = Int32 . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int g = gcd ( arr [ i ] , arr [ j ] ) ; int lcm = arr [ i ] / g * arr [ j ] ; ans = Math . Min ( ans , lcm ) ; } } return ans ; }
int minLCM ( int [ ] arr , int n ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mx = Math . Max ( mx , arr [ i ] ) ; } List < int > [ ] mul = new List < int > [ mx + 1 ] ; for ( int i = 0 ; i < mul . Length ; i ++ ) mul [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mul [ arr [ i ] ] . Count > 1 ) { continue ; } mul [ arr [ i ] ] . Add ( arr [ i ] ) ; } for ( int i = 1 ; i <= mx ; i ++ ) { for ( int j = i + i ; j <= mx ; j += i ) { if ( mul [ i ] . Count > 1 ) { break ; } foreach ( int k in mul [ j ] ) { if ( mul [ i ] . Count > 1 ) break ; mul [ i ] . Add ( k ) ; } } } int ans = int . MaxValue ; for ( int i = 1 ; i <= mx ; i ++ ) { if ( mul [ i ] . Count <= 1 ) continue ; int a = mul [ i ] [ 0 ] , b = mul [ i ] [ 1 ] ; int lcm = ( a * b ) / i ; ans = Math . Min ( ans , lcm ) ; } return ans ; }
bool isSuffix ( string s1 , string s2 ) { int n1 = s1 . Length ; int n2 = s2 . Length ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
bool CheckBinaryEquivalent ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; int c = ( int ) Math . Pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } string bin = B_Number . ToString ( ) ; return isSuffix ( "001" , bin ) ; }
bool CheckBinaryEquivalent ( int N ) { return ( N - 1 ) % 8 == 0 ; }
void print_practica_No ( int A , int B ) { for ( int i = A ; i <= B ; i ++ ) { if ( Is_Practical ( i ) == true ) { Console . Write ( i + " " ) ; } } }
float maxDivision ( int [ ] arr , int n ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; float mxdiv = arr [ 1 ] ; for ( int i = 2 ; i < n ; ++ i ) mxdiv = mxdiv / arr [ i ] ; return arr [ 0 ] / mxdiv ; }
void solve ( int n ) { int upper_limit = ( int ) ( Math . Ceiling ( Math . Pow ( n , 1.0 / 4 ) ) ) ; for ( int x = 0 ; x <= upper_limit ; x ++ ) { for ( int y = 0 ; y <= upper_limit ; y ++ ) { int num1 = x * x * x * x ; int num2 = y * y * y * y ; if ( num1 - num2 == n ) { Console . Write ( "x = " + x + ", y = " + y ) ; return ; } } } Console . Write ( - 1 ) ; }
int productPairs ( int [ ] arr , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; }
int power ( int x , int y ) { int p = 1000000007 ; int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
int productPairs ( int [ ] arr , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = ( product % mod * ( int ) power ( arr [ i ] , ( 2 * n ) ) % mod ) % mod ; } return product % mod ; }
int numPairsWithPrimeSum ( int [ ] arr , int n ) { int N = 2 * 1000000 ; bool [ ] isPrime = sieveOfEratosthenes ( N ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( isPrime [ sum ] ) { count ++ ; } } } return count ; }
void constructArray ( int N ) { int [ ] arr = new int [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + ", " ) ; } }
void digitsPresent ( int n ) { int lastDigit ; while ( n != 0 ) { lastDigit = n % 10 ; digit [ lastDigit ] = 1 ; n /= 10 ; } }
int checkLastDigit ( int num ) { int count = 0 ; int lastDigit ; lastDigit = num % 10 ; if ( digit [ lastDigit ] == 1 ) count ++ ; return count ; }
bool divisorsSame ( int n ) { int even_div = 0 , odd_div = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } } else { if ( i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } if ( n / i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } } } } return ( even_div == odd_div ) ; }
void sieveoferanthones ( ) { bool [ ] prime = new bool [ n + 1 ] ; Array . Fill ( prime , true ) ; for ( int i = 2 ; i <= ( int ) Math . Sqrt ( n ) ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * i ; j <= n ; j += i ) { prime [ j ] = false ; } } } for ( int i = 2 ; i < n ; i ++ ) { if ( prime [ i ] ) v . Add ( i ) ; } }
int find ( int K , int N ) { N -- ; while ( N -- != 0 ) { int curr_term = K ; int min_d = 9 ; int max_d = 0 ; while ( curr_term > 0 ) { int r = curr_term % 10 ; min_d = Math . Min ( min_d , r ) ; max_d = Math . Max ( max_d , r ) ; curr_term = ( int ) ( curr_term / 10 ) ; } if ( min_d == 0 ) { break ; } K = K + min_d * max_d ; } return K ; }
double Convert ( double degree ) { double pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; }
long countSubarrays ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int [ ] prefixSum = new int [ n ] ; int prefixMin = 0 ; prefixSum [ 0 ] = arr [ 0 ] ; prefixMin = Math . Min ( prefixMin , prefixSum [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ; prefixMin = Math . Min ( prefixMin , prefixSum [ i ] ) ; } long countSubs = 0 ; mp . Add ( 0 , 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; prefixSum [ i ] - j * j >= prefixMin ; j ++ ) { if ( mp . ContainsKey ( prefixSum [ i ] - j * j ) ) countSubs += mp [ prefixSum [ i ] - j * j ] ; } if ( mp . ContainsKey ( prefixSum [ i ] ) ) { mp [ prefixSum [ i ] ] ++ ; } else { mp . Add ( prefixSum [ i ] , 1 ) ; } } return countSubs ; }
bool checkSolution ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { return ( ( a1 / a2 ) == ( b1 / b2 ) && ( b1 / b2 ) == ( c1 / c2 ) ) ; }
int chiliagonNum ( int n ) { return ( 998 * n * n - 996 * n ) / 2 ; }
void checkSolution ( int a , int b , int c ) { if ( b == 0 ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool isBalancedPrime ( int n ) { if ( ! isPrime ( n ) n == 2 ) return false ; int previous_prime = n - 1 ; int next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; int mean = ( previous_prime + next_prime ) / 2 ; if ( n == mean ) return true ; else return false ; }
int pentacontagonNum ( int n ) { return ( 48 * n * n - 46 * n ) / 2 ; }
void positiveProduct ( int [ ] arr , int n ) { int even_count = 0 ; int odd_count = 0 ; int total_count = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( total_count % 2 == 0 ) { even_count ++ ; } else { odd_count ++ ; } if ( arr [ i ] < 0 ) { total_count ++ ; } if ( total_count % 2 == 0 ) ans += even_count ; else ans += odd_count ; } Console . WriteLine ( ans ) ; }
int sumOfGCDofPairs ( int n ) { int res = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int d1 = i ; int d2 = n / i ; res += d1 * getCount ( d1 , n ) ; if ( d1 != d2 ) res += d2 * getCount ( d2 , n ) ; } } return res ; }
bool checkIsFibonacci ( int [ ] arr , int n ) { if ( n == 1 n == 2 ) return true ; Array . Sort ( arr ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( ( arr [ i - 1 ] + arr [ i - 2 ] ) != arr [ i ] ) return false ; } return true ; }
int lastDigitFactorial ( int n ) { if ( n == 0 ) return 1 ; else if ( n <= 2 ) return n ; else if ( n == 3 ) return 6 ; else if ( n == 4 ) return 4 ; else return 0 ; }
int lastDigit2PowerN ( int n ) { if ( n == 0 ) return 1 ; else if ( n % 4 == 1 ) return 2 ; else if ( n % 4 == 2 ) return 4 ; else if ( n % 4 == 3 ) return 8 ; else }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int sumSubsequences ( int [ ] arr , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int kLengthSubSequence ; kLengthSubSequence = nCr ( n , k ) ; int ans = sum * ( ( k * kLengthSubSequence ) / n ) ; return ans ; }
bool hasOddNumberOfDivisors ( int n ) { if ( ( double ) Math . Sqrt ( n ) == ( int ) Math . Sqrt ( n ) ) return true ; return false ; }
int dfs ( int node , int parent ) { int count = 0 ; foreach ( int i in adj [ node ] ) { if ( i != parent ) { count += dfs ( i , node ) ; } } if ( hasOddNumberOfDivisors ( a [ node ] ) ) ++ count ; ans [ node ] = count ; return count ; }
int costCalculation ( int current , int [ ] arr , int n , int [ ] pref , int a , int r , int minimum ) { int index = lowerBound ( arr , arr . Length , current ) ; int left = index * current - pref [ index ] ; int right = pref [ n ] - pref [ index ] - ( n - index ) * current ; int res = Math . Min ( left , right ) ; left -= res ; right -= res ; int total = res * minimum ; total += left * a ; total += right * r ; return total ; }
void solve ( int [ ] arr , int n , int a , int r , int m ) { Array . Sort ( arr ) ; int minimum = Math . Min ( a + r , m ) ; int [ ] pref = new int [ n + 1 ] ; Array . Fill ( pref , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref [ i + 1 ] = pref [ i ] + arr [ i ] ; int ans = 10000 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . Min ( ans , costCalculation ( arr [ i ] , arr , n , pref , a , r , minimum ) ) ; ans = Math . Min ( ans , costCalculation ( pref [ n ] / n , arr , n , pref , a , r , minimum ) ) ; ans = Math . Min ( ans , costCalculation ( pref [ n ] / n + 1 , arr , n , pref , a , r , minimum ) ) ; Console . WriteLine ( ans ) ; }
int findSum ( int n , int k ) { int val = ( k / ( n - 1 ) ) * n ; int rem = k % ( n - 1 ) ; if ( rem == 0 ) { val = val - 1 ; } else { val = val + rem ; } int sum = ( val * ( val + 1 ) ) / 2 ; int x = k / ( n - 1 ) ; int sum_of_multiples = ( x * ( x + 1 ) * n ) / 2 ; sum -= sum_of_multiples ; return sum ; }
List < int > getFactorization ( int x ) { int count = 0 ; List < int > v = new List < int > ( ) ; while ( x % 2 == 0 ) { count ++ ; x = x / 2 ; } if ( count != 0 ) v . Add ( count ) ; for ( int i = 3 ; i <= Math . Sqrt ( x ) ; i += 2 ) { count = 0 ; while ( x % i == 0 ) { count ++ ; x /= i ; } if ( count != 0 ) v . Add ( count ) ; } if ( x > 1 ) { v . Add ( 1 ) ; } return v ; }
int nonPrimeDivisors ( int N ) { List < int > v = getFactorization ( N ) ; int ret = 1 ; for ( int i = 0 ; i < v . Count ; i ++ ) ret = ret * ( v [ i ] + 1 ) ; ret = ret - v . Count ; return ret ; }
bool isPerfectSquare ( int x ) { int s = ( int ) Math . Sqrt ( x ) ; return ( s * s == x ) ; }
bool isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
bool checkDigits ( int n ) { while ( n != 0 ) { int dig = n % 10 ; if ( dig == 4 && dig == 6 && dig == 7 && dig == 9 ) return false ; n /= 10 ; } return true ; }
bool isFullfibonacci ( int n ) { return ( checkDigits ( n ) && isFibonacci ( n ) ) ; }
bool checksilverRatio ( double a , double b ) { if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } double ratio1 = ( ( a / b ) * 1000 ) / 1000 ; double ratio2 = ( int ) ( ( ( 2 * a + b ) / a ) * 1000 ) ; ratio2 = ratio2 / 1000 ; if ( ratio1 == ratio2 && ( int ) ( ratio1 - 2.414 ) == 0 ) { Console . WriteLine ( "Yes" ) ; return true ; } else { Console . WriteLine ( "No" ) ; return false ; } }
int MIN ( int n ) { int ans = 11 ; while ( n > 0 ) { ans = Math . Min ( ans , n % 10 ) ; n /= 10 ; } return ans ; }
int MAX ( int n ) { int ans = - 1 ; while ( n > 0 ) { ans = Math . Max ( ans , n % 10 ) ; n /= 10 ; } return ans ; }
void Find_value ( int n , int k ) { k -- ; int x = 0 ; int y = 0 ; while ( k -- > 0 ) { x = MIN ( n ) ; y = MAX ( n ) ; if ( y - x == 0 ) break ; n *= ( y - x ) ; } Console . Write ( n ) ; }
int countBinaries ( int N ) { int ctr = 1 ; int ans = 0 ; while ( N > 0 ) { if ( N % 10 == 1 ) { ans += ( int ) Math . Pow ( 2 , ctr - 1 ) ; } else if ( N % 10 > 1 ) { ans = ( int ) ( Math . Pow ( 2 , ctr ) - 1 ) ; } ctr ++ ; N /= 10 ; } return ans ; }
int countBinaries ( int N ) { List < int > powersOfTwo = new List < int > ( ) ; powersOfTwo . Add ( 1 ) ; for ( int i = 1 ; i < 11 ; i ++ ) { powersOfTwo . Add ( powersOfTwo [ i - 1 ] * 2 ) ; } int ctr = 1 ; int ans = 0 ; while ( N > 0 ) { if ( N % 10 == 1 ) { ans += powersOfTwo [ ctr - 1 ] ; } else if ( N % 10 > 1 ) { ans = powersOfTwo [ ctr ] - 1 ; } ctr ++ ; N /= 10 ; } return ans ; }
int sum_Centered_Hexadecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Hexadecagonal_num ( i ) ; } return summ ; }
int heptadecagonal_num ( int n ) { return ( ( 15 * n * n ) - 13 * n ) / 2 ; }
int sum_heptadecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += heptadecagonal_num ( i ) ; } return summ ; }
int center_heptagonal_num ( int n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
int sum_center_heptagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += center_heptagonal_num ( i ) ; } return summ ; }
int Centered_Dodecagonal_num ( int n ) { return 6 * n * ( n - 1 ) + 1 ; }
int sum_Centered_Dodecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Dodecagonal_num ( i ) ; } return summ ; }
int center_Octagonal_num ( int n ) { return ( 4 * n * n - 4 * n + 1 ) ; }
int sum_center_Octagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += center_Octagonal_num ( i ) ; } return summ ; }
int Centered_decagonal_num ( int n ) { return ( 5 * n * n - 5 * n + 1 ) ; }
int sum_Centered_decagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_decagonal_num ( i ) ; } return summ ; }
int center_octadecagon_num ( int n ) { return ( 9 * n * n - 9 * n + 1 ) ; }
int sum_center_octadecagon_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += center_octadecagon_num ( i ) ; } return summ ; }
int Centered_Pentadecagonal_num ( int n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
int sum_Centered_Pentadecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Pentadecagonal_num ( i ) ; } return summ ; }
bool isMyriagon ( int N ) { double n = ( 9996 + Math . Sqrt ( 79984 * N + 99920016 ) ) / 19996 ; return ( n - ( int ) n ) == 0 ; }
bool isOctadecagon ( int N ) { double n = ( 14 + Math . Sqrt ( 128 * N + 196 ) ) / 32 ; return ( n - ( int ) n ) == 0 ; }
bool isoctagonal ( int N ) { double n = ( 2 + Math . Sqrt ( 12 * N + 4 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; }
bool isheptagonal ( int N ) { double n = ( 3 + Math . Sqrt ( 40 * N + 9 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
bool isPentadecagon ( int N ) { double n = ( 11 + Math . Sqrt ( 104 * N + 121 ) ) / 26 ; return ( n - ( int ) n ) == 0 ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int countSubsequences ( int [ ] arr , int n , int k ) { int countPrime = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } if ( countPrime < k ) return 0 ; return nCr ( countPrime , k ) * ( int ) Math . Pow ( 2 , ( n - countPrime ) ) ; }
int longestEvenOddSubarray ( int [ ] a , int n ) { int longest = 1 ; int cnt = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] + a [ i + 1 ] ) % 2 == 1 ) { cnt ++ ; } else { longest = Math . Max ( longest , cnt ) ; cnt = 1 ; } } if ( longest == 1 ) return 0 ; return Math . Max ( cnt , longest ) ; }
int digSum ( int a ) { int sum = 0 ; while ( a != 0 ) { sum += a % 10 ; a = a / 10 ; } return sum ; }
bool isPrime ( int r ) { bool s = true ; for ( int i = 2 ; i * i <= r ; i ++ ) { if ( r % i == 0 ) { s = false ; break ; } } return s ; }
bool istetradecagonal ( int N ) { double n = ( 10 + Math . Sqrt ( 96 * N + 100 ) ) / 24 ; return ( n - ( int ) n ) == 0 ; }
bool ishexadecagonal ( int N ) { double n = ( 12 + Math . Sqrt ( 112 * N + 144 ) ) / 28 ; return ( n - ( int ) n ) == 0 ; }
bool isnonagonal ( int N ) { double n = ( 5 + Math . Sqrt ( 56 * N + 25 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; }
int nCr ( int n , int r ) { if ( r > n ) return 0 ; return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int countSubsequences ( int [ ] arr , int n , int k ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) countOdd ++ ; } int ans = nCr ( n , k ) - nCr ( countOdd , k ) ; return ans ; }
void divParts ( int N ) { if ( N % 2 == 0 ) Console . WriteLine ( ( N / 2 ) - 1 ) ; else Console . WriteLine ( ( N / 2 ) ) ; }
int solve ( String s , int n ) { int left = 0 , right = 0 ; int maxlength = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '(' ) left ++ ; else right ++ ; if ( left == right ) maxlength = Math . Max ( maxlength , 2 * right ) ; else if ( right > left ) left = right = 0 ; } left = right = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '(' ) left ++ ; else right ++ ; if ( left == right ) maxlength = Math . Max ( maxlength , 2 * left ) ; else if ( left > right ) left = right = 0 ; } return maxlength ; }
int Icosagonal_num ( int n ) { return ( 18 * n * n - 16 * n ) / 2 ; }
int sum_Icosagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { summ += Icosagonal_num ( i ) ; } return summ ; }
int Centered_Pentagonal_num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
int sum_Centered_Pentagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Pentagonal_num ( i ) ; } return summ ; }
int Centered_tridecagonal_num ( int n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; }
int sum_Centered_tridecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { summ += Centered_tridecagonal_num ( i ) ; } return summ ; }
int getMinSteps ( int n , int jump ) { int quotient = n / jump ; int remainder = n % jump ; int steps = quotient + remainder ; return steps ; }
int Betrothed_Sum ( int n ) { ArrayList set = new ArrayList ( ) ; for ( int number_1 = 1 ; number_1 < n ; number_1 ++ ) { int sum_divisor_1 = 1 ; int i = 2 ; while ( i * i <= number_1 ) { if ( number_1 % i == 0 ) { sum_divisor_1 = sum_divisor_1 + i ; if ( i * i != number_1 ) sum_divisor_1 += number_1 / i ; } i ++ ; } if ( sum_divisor_1 > number_1 ) { int number_2 = sum_divisor_1 - 1 ; int sum_divisor_2 = 1 ; int j = 2 ; while ( j * j <= number_2 ) { if ( number_2 % j == 0 ) { sum_divisor_2 += j ; if ( j * j != number_2 ) sum_divisor_2 += number_2 / j ; } j = j + 1 ; } if ( sum_divisor_2 == number_1 + 1 && number_1 <= n && number_2 <= n ) { set . Add ( number_1 ) ; set . Add ( number_2 ) ; } } } int Summ = 0 ; for ( int i = 0 ; i < set . Count ; i ++ ) { if ( ( int ) set [ i ] <= n ) Summ += ( int ) set [ i ] ; } return Summ ; }
void constructArray ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { Console . Write ( i + " " ) ; } }
int prod_of_max_min ( int n ) { int largest = 0 ; int smallest = 10 ; while ( n != 0 ) { int r = n % 10 ; largest = Math . Max ( r , largest ) ; smallest = Math . Min ( r , smallest ) ; n = n / 10 ; } return largest * smallest ; }
int formed_no ( int N , int K ) { if ( K == 1 ) { return N ; } int answer = N ; while ( K != 0 ) { int a_current = prod_of_max_min ( answer ) ; if ( a_current == 0 ) break ; answer += a_current ; } return answer ; }
bool isCenteredtridecagonal ( int N ) { float n = ( float ) ( ( 13 + Math . Sqrt ( 104 * N + 65 ) ) / 26 ) ; return ( n - ( int ) n ) == 0 ; }
bool isCenteredpentagonal ( int N ) { float n = ( float ) ( ( 5 + Math . Sqrt ( 40 * N - 15 ) ) / 10 ) ; return ( n - ( int ) n ) == 0 ; }
bool isCentereddecagonal ( int N ) { double n = ( 5 + Math . Sqrt ( 20 * N + 5 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
bool isdodecagonal ( int N ) { float n = ( float ) ( ( 4 + Math . Sqrt ( 20 * N + 16 ) ) / 10 ) ; return ( n - ( int ) n ) == 0 ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i += 6 ) { if ( n % i == 0 || n % ( i + 6 ) == 0 ) { return false ; } } return true ; }
bool SexyPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && Math . Abs ( n1 - n2 ) == 6 ) ; }
int countSexyPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( SexyPrime ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
void computePrime ( int N ) { Prime = new bool [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) { Prime [ i ] = true ; } Prime [ 0 ] = Prime [ 1 ] = false ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( Prime [ i ] ) { for ( int j = i * i ; j < N ; j += i ) { Prime [ j ] = false ; } } } }
int countSexyPairs ( int [ ] arr , int n ) { int maxE = arr . Max ( ) ; computePrime ( maxE ) ; int count = 0 ; int [ ] freq = new int [ maxE + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( Prime [ arr [ i ] ] ) { if ( arr [ i ] + 6 < freq . Length && freq [ arr [ i ] + 6 ] > 0 && Prime [ arr [ i ] + 6 ] ) { count ++ ; } } } return count ; }
double nDigitPerfectSquares ( int n , int b ) { double largest = Math . Pow ( Math . Ceiling ( Math . Sqrt ( Math . Pow ( b , n ) ) ) - 1 , 2 ) ; return largest ; }
void findNum ( int n , int k ) { int q = k / ( n - 1 ) ; int r = k % ( n - 1 ) ; int a = 0 ; if ( r != 0 ) a = ( n * q ) + r ; else a = ( n * q ) - 1 ; Console . WriteLine ( a ) ; }
double cubeRoot ( double n ) { double ans = Math . Pow ( 3 , ( ( 1.0 / 3 ) * ( Math . Log ( n ) / Math . Log ( 3 ) ) ) ) ; return ans ; }
int floorMax ( int A , int B , int N ) { int x = Math . Min ( B - 1 , N ) ; return ( A * x ) / B ; }
int calculateMoves ( int n ) { int count = 0 ; int layers = n / 2 ; for ( int k = 1 ; k < layers + 1 ; k ++ ) { count += 8 * k * k ; } return count ; }
void countWays ( int n ) { if ( n <= 2 ) { Console . WriteLine ( "-1" ) ; } else { int ans = ( n - 1 ) * ( n - 2 ) / 2 ; Console . WriteLine ( ans ) ; } }
bool isSumSquare ( int N ) { double n = ( 2 + Math . Sqrt ( 8 * N - 4 ) ) / 2 ; return ( n - ( int ) n ) == 0 ; }
bool isCenteredheptagonal ( int N ) { double n = ( 7 + Math . Sqrt ( 56 * N - 7 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; }
bool isCenterednonadecagonal ( int N ) { float n = ( float ) ( ( 19 + Math . Sqrt ( 152 * N + 209 ) ) / 38 ) ; return ( n - ( int ) n ) == 0 ; }
bool isCenteredOctadecagonal ( int N ) { double n = ( 9 + Math . Sqrt ( 36 * N + 45 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; }
int countDigit ( double n ) { return ( ( int ) Math . Floor ( Math . Log10 ( n ) + 1 ) ) ; }
bool isPower ( int N , int K ) { int res1 = ( int ) ( Math . Log ( N ) / Math . Log ( K ) ) ; double res2 = Math . Log ( N ) / Math . Log ( K ) ; return ( res1 == res2 ) ; }
int prevPowerofK ( int n , int k ) { int p = ( int ) ( Math . Log ( n ) / Math . Log ( k ) ) ; return ( int ) Math . Pow ( k , p ) ; }
int nextPowerOfK ( int n , int k ) { return prevPowerofK ( n , k ) * k ; }
int subarray ( int [ ] arr , int n ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { ++ temp ; } else { ans = Math . Max ( ans , temp ) ; temp = 1 ; } } ans = Math . Max ( ans , temp ) ; return ans ; }
void findMaxMinSubArray ( int [ ] arr , int K , int n ) { int min = n ; int max = 0 ; int left ; int right ; int tmp ; for ( int i = 0 ; i < n ; i ++ ) { tmp = 1 ; left = i ; while ( left - 1 >= 0 && Math . Abs ( arr [ left ] - arr [ left - 1 ] ) <= K ) { left -- ; tmp ++ ; } right = i ; while ( right + 1 <= n - 1 && Math . Abs ( arr [ right ] - arr [ right + 1 ] ) <= K ) { right ++ ; tmp ++ ; } if ( min > tmp ) min = tmp ; if ( max < tmp ) max = tmp ; } Console . Write ( min ) ; Console . Write ( ", " ) ; Console . Write ( max ) ; }
int countElement ( int [ ] arr , int n ) { int [ ] freq = new int [ n + 1 ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { int tmpsum = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { tmpsum += arr [ j ] ; if ( tmpsum <= n ) { ans += freq [ tmpsum ] ; freq [ tmpsum ] = 0 ; } } } return ans ; }
void first_digit ( int x , int y ) { int length = ( int ) ( Math . Log ( x ) / Math . Log ( y ) + 1 ) ; int first_digit = ( int ) ( x / Math . Pow ( y , length - 1 ) ) ; Console . Write ( first_digit ) ; }
double kthRoot ( double n , int k ) { return Math . Pow ( k , ( ( 1.0 / k ) * ( Math . Log ( n ) / Math . Log ( k ) ) ) ) ; }
void checksum ( int n , int k ) { float first_term = ( float ) ( ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ) ; if ( first_term - ( int ) ( first_term ) == 0 ) { for ( int i = ( int ) first_term ; i <= first_term + k - 1 ; i ++ ) { Console . Write ( i + " " ) ; } } else Console . Write ( "-1" ) ; }
void distributeN ( int A , int B , int C , int n ) { int max1 = Math . Max ( A , B ) ; int max2 = Math . Max ( B , C ) ; int maximum = Math . Max ( max1 , max2 ) ; int sum = A + B + C ; int p = ( 3 * maximum ) - sum ; int diff = n - p ; if ( diff < 0 diff % 3 == 0 ) Console . Write ( "No" ) ; else Console . Write ( "Yes" ) ; }
int minimumSteps ( int a , int b , int c ) { if ( a < 1 b < 1 ) return - 1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimumSteps ( a - b , b , c + 1 ) ; }
int count_pairs ( int x ) { int ans = 1 ; while ( x > 0 ) { if ( x % 2 == 1 ) ans = ans * 3 ; x = x / 2 ; } return ans ; }
bool isPerfectSquare ( double x ) { double sr = Math . Sqrt ( x ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ; }
int countSquares ( int n ) { int cnt = 0 ; for ( int i = ( int ) Math . Pow ( 10 , ( n - 1 ) ) ; i < Math . Pow ( 10 , n ) ; i ++ ) { if ( i != 0 && isPerfectSquare ( i ) ) cnt ++ ; } return cnt ; }
int countSquares ( int n ) { int r = ( int ) Math . Ceiling ( Math . Sqrt ( Math . Pow ( 10 , n ) ) ) ; int l = ( int ) Math . Ceiling ( Math . Sqrt ( Math . Pow ( 10 , n - 1 ) ) ) ; return r - l ; }
int summation ( int N ) { int co = ( N + 1 ) / 2 ; int ce = ( N ) / 2 ; int se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) ; int so = ( co * co ) * ( 2 * ( ( co * co ) ) - 1 ) ; return so - se ; }
bool isStar ( int N ) { double n = ( 6 + Math . Sqrt ( 24 * N + 12 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; }
void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { Console . Write ( "2 " ) ; } Console . WriteLine ( check ) ; } else { Console . WriteLine ( "-1" ) ; } }
int findMinDivisor ( int [ ] arr , int n , int limit ) { int low = 0 , high = 1000000000 ; while ( low < high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ( int ) Math . Ceiling ( ( double ) arr [ i ] / ( double ) mid ) ; } if ( sum <= limit ) { high = mid ; } else { low = mid + 1 ; } } return low ; }
int getCount ( int [ ] arr , int n ) { int count = 0 ; for ( int j = 1 ; j < n - 1 ; j ++ ) { int p = 0 , q = 0 ; for ( int i = 0 ; i < j ; i ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) p ++ ; } for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ k ] % arr [ j ] == 0 ) q ++ ; } count += p * q ; } return count ; }
float computeMaxValue ( float [ ] arr , int n ) { float ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { float val = Math . Max ( arr [ i ] / arr [ j ] , arr [ j ] / arr [ i ] ) ; ans = Math . Max ( ans , val ) ; } } return ans ; }
void kthNonDivisible ( int N , int K ) { int L = 1 ; int H = Int32 . MaxValue ; int ans = 0 ; while ( L <= H ) { int mid = ( L + H ) / 2 ; int sol = mid - mid / N ; if ( sol > K ) { H = mid - 1 ; } else if ( sol < K ) { L = mid + 1 ; } else { ans = mid ; H = mid - 1 ; } } Console . Write ( ans ) ; }
int kthNonDivisible ( int N , int K ) { return ( int ) ( K + Math . Floor ( ( double ) ( K - 1 ) / ( N - 1 ) ) ) ; }
bool isPerfectSquare ( double x ) { double sr = Math . Sqrt ( x ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ; }
void checkSunnyNumber ( int N ) { if ( isPerfectSquare ( N + 1 ) ) { Console . WriteLine ( "Yes" ) ; } else { Console . WriteLine ( "No" ) ; } }
void findPairEvenParity ( int [ ] arr , int len ) { int firstMaximum = Int32 . MinValue ; int secondMaximum = Int32 . MinValue ; for ( int i = 0 ; i < len ; i ++ ) { if ( isEvenParity ( arr [ i ] ) ) { if ( arr [ i ] >= firstMaximum ) { secondMaximum = firstMaximum ; firstMaximum = arr [ i ] ; } else if ( arr [ i ] >= secondMaximum ) { secondMaximum = arr [ i ] ; } } } Console . Write ( firstMaximum + " " + secondMaximum ) ; }
bool isHexagonal ( int N ) { float val = 8 * N + 1 ; float x = 1 + ( float ) Math . Sqrt ( val ) ; float n = ( x ) / 4 ; if ( ( n - ( int ) n ) == 0 ) { return true ; } else { return false ; } }
void NumbertoCharacter ( int n ) { int rev = 0 , r = 0 ; while ( n > 0 ) { r = n % 10 ; rev = rev * 10 + r ; n = n / 10 ; } while ( rev > 0 ) { r = rev % 10 ; switch ( r ) { case 1 : Console . Write ( "one " ) ; break ; case 2 : Console . Write ( "two " ) ; break ; case 3 : Console . Write ( "three " ) ; break ; case 4 : Console . Write ( "four " ) ; break ; case 5 : Console . Write ( "five " ) ; break ; case 6 : Console . Write ( "six " ) ; break ; case 7 : Console . Write ( "seven " ) ; break ; case 8 : Console . Write ( "eight " ) ; break ; case 9 : Console . Write ( "nine " ) ; break ; case 0 : Console . Write ( "zero " ) ; break ; default : Console . Write ( "UnValid " ) ; break ; } rev = rev / 10 ; } }
int Solve ( int [ ] arr , int n ) { int temp = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; if ( ( temp + 2 ) % 4 != 0 ) count ++ ; } } return count ; }
void nCr ( int n , long p , int [ , ] f ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( j > i ) f [ i , j ] = 0 ; else if ( j == 0 j == i ) f [ i , j ] = 1 ; else f [ i , j ] = ( f [ i - 1 , j ] + f [ i - 1 , j - 1 ] ) % ( int ) p ; } } }
bool prodSquare ( int n ) { for ( long i = 2 ; i * i <= n ; i ++ ) for ( long j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; }
bool prodSquare ( int n ) { Dictionary < float , float > s = new Dictionary < float , float > ( ) ; for ( int i = 2 ; i * i <= n ; ++ i ) { s . Add ( ( float ) ( i * i ) , ( float ) 1 ) ; if ( s . ContainsKey ( ( float ) n / ( i * i ) ) ) return true ; } return false ; }
void printPair ( int n ) { Console . Write ( 1 + " " + ( n - 1 ) ) ; }
bool isAutoBiographyNum ( int number ) { int count = 0 , position , size , digit ; string NUM ; NUM = number . ToString ( ) ; size = NUM . Length ; for ( int i = 0 ; i < size ; i ++ ) { position = NUM [ i ] - '0' ; count = 0 ; for ( int j = 0 ; j < size ; j ++ ) { digit = NUM [ j ] - '0' ; if ( digit == i ) count ++ ; } if ( position != count ) return false ; } return true ; }
int checkArray ( int [ ] arr , int n ) { int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isAutoBiographyNum ( arr [ i ] ) == true ) { current_length ++ ; } else { current_length = 0 ; } max_length = Math . Max ( max_length , current_length ) ; } return max_length ; }
int GetSum ( int n ) { List < int > divisors = new List < int > ( ) ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { divisors . Add ( i ) ; if ( i != n / i ) { divisors . Add ( n / i ) ; } } } int ans = 1 ; foreach ( int i in divisors ) { ans *= ( i + 1 ) ; } ans = ans - 1 ; return ans ; }
int [ ] calculateWays ( int N ) { int x = 0 ; int [ ] v = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) v [ i ] = 0 ; for ( int i = 0 ; i < N / 2 ; i ++ ) { if ( N % 2 == 0 && i == N / 2 ) break ; x = N * ( i + 1 ) - ( i + 1 ) * i ; v [ i ] = x ; v [ N - i - 1 ] = x ; } return v ; }
bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= Math . Sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
int longestPowerfulSubsequence ( int [ ] arr , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerful ( arr [ i ] ) ) answer ++ ; } return answer ; }
int maxOR ( int [ ] arr , int n ) { int max_value = arr . Max ( ) ; int number_of_bits = ( int ) ( Math . Log ( max_value ) ) + 2 ; int complement = ( ( 1 << number_of_bits ) - 1 ) ^ max_value ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != max_value ) { c = Math . Max ( c , ( complement & arr [ i ] ) ) ; } } return ( max_value + c ) ; }
void update ( int [ ] res , int L , int R , int K ) { L -= 1 ; R -= 1 ; res [ L ] ^= K ; res [ R + 1 ] ^= K ; }
bool check ( int [ ] a , int n , int k ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; int extra = 0 ; for ( int i = k ; i < n ; i ++ ) if ( m . ContainsKey ( a [ i ] ) ) m [ a [ i ] ] = m [ a [ i ] ] + 1 ; else m . Add ( a [ i ] , 1 ) ; foreach ( int x in m . Keys ) extra += m [ x ] - 1 ; if ( extra == 0 ) return true ; for ( int i = 1 ; i + k - 1 < n ; i ++ ) { if ( m [ a [ i + k - 1 ] ] > 1 ) extra -- ; m [ a [ i + k - 1 ] ] = m [ a [ i + k - 1 ] ] - 1 ; m [ a [ i - 1 ] ] = m [ a [ i - 1 ] ] + 1 ; if ( m [ a [ i - 1 ] ] > 1 ) extra ++ ; if ( extra == 0 ) return true ; } return false ; }
int minlength ( int [ ] a , int n ) { int lo = 0 , hi = n + 1 ; int ans = 0 ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( check ( a , n , mid ) ) { ans = mid ; hi = mid ; } else lo = mid + 1 ; } return ans ; }
void SieveOfEratosthenes ( ) { int i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= MAX ; i ++ ) { if ( Prime [ i ] ) { for ( j = 2 * i ; j < MAX ; j += i ) { Prime [ j ] = false ; } } } }
void dfs ( int node , int parent , int h ) { height [ node ] = h ; foreach ( int to in graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node , h + 1 ) ; } }
void primeHeightNode ( int N ) { SieveOfEratosthenes ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( Prime [ height [ i ] ] ) { Console . Write ( i + " " ) ; } } }
int sumOfDigits ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n /= 10 ; } return sum ; }
int smallestNum ( int X , int Y ) { int res = - 1 ; for ( int i = X ; i < MAXN ; i ++ ) { int sum_of_digit = sumOfDigits ( i ) ; if ( sum_of_digit % Y == 0 ) { res = i ; break ; } } return res ; }
int calculateBill ( int units ) { if ( units <= 100 ) { return units * 10 ; } else if ( units <= 200 ) { return ( 100 * 10 ) + ( units - 100 ) * 15 ; } else if ( units <= 300 ) { return ( 100 * 10 ) + ( 100 * 15 ) + ( units - 200 ) * 20 ; } else if ( units > 300 ) { return ( 100 * 10 ) + ( 100 * 15 ) + ( 100 * 20 ) + ( units - 300 ) * 25 ; } return 0 ; }
int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; }
int countValues ( int N ) { List < int > div = new List < int > ( ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { div . Add ( i ) ; if ( N != i * i ) { div . Add ( N / i ) ; } } } int answer = 0 ; for ( int i = 1 ; i * i <= N - 1 ; i ++ ) { if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } } foreach ( int d in div ) { int K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } return answer ; }
int reverse ( int a ) { int rev = 0 ; while ( a != 0 ) { int r = a % 10 ; rev = rev * 10 + r ; a = a / 10 ; } return ( rev ) ; }
int prime ( int a ) { int k = 0 ; for ( int i = 2 ; i < a ; i ++ ) { if ( a % i == 0 ) { k = 1 ; break ; } } if ( k == 1 ) { return ( 0 ) ; } else { return ( 1 ) ; } }
int adam ( int a ) { int r1 = reverse ( a ) ; int s1 = a * a ; int s2 = r1 * r1 ; int r2 = reverse ( s2 ) ; if ( s1 == r2 ) { return ( 1 ) ; } else { return ( 0 ) ; } }
void sieve ( ) { for ( int i = 1 ; i <= MAX ; ++ i ) { for ( int j = i ; j <= MAX ; j += i ) divisor [ j ] . Add ( i ) ; } }
int countPrimeFactors ( int n ) { if ( n == 1 ) return 0 ; int cnt = 0 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { cnt ++ ; n = n / i ; } } if ( n > 2 ) cnt ++ ; return cnt ; }
int isComposite ( int n ) { if ( n <= 1 ) return 0 ; if ( n <= 3 ) return 0 ; if ( n % 2 == 0 n % 3 == 0 ) return n ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return n ; return 0 ; }
void preCompute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isComposite ( i ) ; } }
int countPalindromic ( int n ) { int count ; if ( n % 2 == 1 ) { count = ( int ) Math . Pow ( 9 , ( n - 1 ) / 2 ) ; } else { count = ( int ) Math . Pow ( 9 , ( n - 2 ) / 2 ) ; } return count ; }
int countSubArrayWithOddProduct ( int [ ] A , int N ) { int count = 0 ; int last = - 1 ; int K = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { K = ( i - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; last = i ; } } K = ( N - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; return count ; }
double CgpaCalc ( double [ ] marks , int n ) { double [ ] grade = new double [ n ] ; double cgpa , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { grade [ i ] = ( marks [ i ] / 10 ) ; } for ( int i = 0 ; i < n ; i ++ ) { sum += grade [ i ] ; } cgpa = sum / n ; return cgpa ; }
void printMaxPair ( int [ ] arr , int n ) { int largest = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int number = Int32 . Parse ( getNumber ( arr [ i ] , arr [ j ] ) ) ; largest = Math . Max ( largest , number ) ; } Console . WriteLine ( largest ) ; }
void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) Console . Write ( 1 + " " ) ; Console . Write ( N - K + 1 ) ; }
int minNum ( int n , int k ) { int x = ( int ) ( Math . Log ( n ) / Math . Log ( k ) ) + 1 ; int mn = ( int ) ( Math . Pow ( k , x ) - n ) ; return mn ; }
int previousPerfectCube ( int N ) { int prevN = ( int ) Math . Floor ( Math . Cbrt ( N ) ) ; if ( prevN * prevN * prevN == N ) prevN -= 1 ; return prevN * prevN * prevN ; }
int findCount ( int [ ] arr , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] % 2 == 0 ) && ( arr [ j ] % 2 == 1 ) ) { res ++ ; } return res ; }
int findCount ( int [ ] arr , int n ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { count ++ ; } else { ans = ans + count ; } } return ans ; }
int sumDig ( int n ) { int s = 0 ; while ( n != 0 ) { s = s + ( n % 10 ) ; n = n / 10 ; } return s ; }
bool Pec ( int n ) { int dup = n ; int dig = sumDig ( n ) ; if ( dig * 3 == dup ) return true ; else return false ; }
int power ( int a , int b ) { if ( b == 0 ) return 1 ; int temp = power ( a , b / 2 ) ; temp = ( temp * temp ) % MOD ; if ( b % 2 != 0 ) { temp = ( temp * a ) % MOD ; } return temp ; }
int joinNumbers ( int numA , int numB ) { int revB = 0 ; while ( numB > 0 ) { revB = revB * 10 + ( numB % 10 ) ; numB = numB / 10 ; } while ( revB > 0 ) { numA = numA * 10 + ( revB % 10 ) ; revB = revB / 10 ; } return numA ; }
int reverse ( int n ) { int r = 0 ; while ( n != 0 ) { r = r * 10 ; r = r + n % 10 ; n = n / 10 ; } return ( r ) ; }
void operation ( int n ) { int i = 1 , a , count = 0 , r ; while ( count < n ) { a = digit_sum ( i ) ; r = reverse ( i ) ; if ( i % a == 0 && r % a == 0 ) { Console . Write ( i + " " ) ; count ++ ; i ++ ; } else i ++ ; } }
int calcCount ( int [ ] arr , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( k % arr [ i ] == 0 ) count ++ ; } return count ; }
bool isPerfect ( int n ) { int sum = 1 ; int i ; for ( i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) { return true ; } return false ; }
int contiguousPerfectNumber ( int [ ] arr , int n ) { int current_length = 0 ; int max_length = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( isPerfect ( arr [ i ] ) ) { current_length ++ ; } else { current_length = 0 ; } max_length = Math . Max ( max_length , current_length ) ; } return max_length ; }
bool isPerfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= Math . Sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
void dfs ( int node , int parent ) { if ( isPowerful ( weight [ node ] ) ) ans += 1 ; foreach ( int to in graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } }
bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= Math . Sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
int contiguousPowerfulNumber ( int [ ] arr , int n ) { int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerful ( arr [ i ] ) ) current_length ++ ; else current_length = 0 ; max_length = Math . Max ( max_length , current_length ) ; } return max_length ; }
int maxSum ( int [ ] arr , int K , int start , int end , int max_sum ) { if ( K == 0 ) return max_sum ; int max_sum_start = max_sum + arr [ start ] ; int max_sum_end = max_sum + arr [ end ] ; int ans = Math . Max ( maxSum ( arr , K - 1 , start + 1 , end , max_sum_start ) , maxSum ( arr , K - 1 , start , end - 1 , max_sum_end ) ) ; return ans ; }
void maximizeSum ( int [ ] arr , int K , int n ) { int max_sum = 0 ; int start = 0 ; int end = n - 1 ; Console . Write ( maxSum ( arr , K , start , end , max_sum ) ) ; }
int maxPointCount ( int [ ] arr , int K , int size ) { int curr_points = 0 ; int max_points = 0 ; for ( int i = 0 ; i < K ; i ++ ) curr_points += arr [ i ] ; max_points = curr_points ; int j = size - 1 ; for ( int i = K - 1 ; i >= 0 ; i -- ) { curr_points = curr_points + arr [ j ] - arr [ i ] ; max_points = Math . Max ( curr_points , max_points ) ; j -- ; } return max_points ; }
int count ( int N , int B ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( int ) ( ( B - 1 ) * Math . Pow ( B , i - 1 ) ) ; } return sum ; }
int GetMinCost ( int N ) { List < int > pq = new List < int > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { pq . Add ( i ) ; } int cost = 0 ; pq . Sort ( ) ; while ( pq . Count > 1 ) { int mini = pq [ 0 ] ; pq . RemoveAt ( 0 ) ; int secondmini = pq [ 0 ] ; pq . RemoveAt ( 0 ) ; int current = mini * secondmini ; cost += current ; pq . Add ( current ) ; pq . Sort ( ) ; } return cost ; }
int CountWays ( int N , int M ) { int count = 1 ; count = ( int ) Math . Pow ( 3 , M + N ) ; count *= ( int ) Math . Pow ( 2 , M * N ) ; return count ; }
int minCost ( int [ ] arr , int n , int circumference ) { Array . Sort ( arr ) ; int [ ] arr2 = new int [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr2 [ i ] = arr [ i ] ; arr2 [ i + n ] = arr [ i ] + circumference ; } int res = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) res = Math . Min ( res , arr2 [ i + ( n - 1 ) ] - arr2 [ i ] ) ; return res ; }
int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; }
void findUniqueElements ( int [ ] arr , int N , int K ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) s . Add ( arr [ i ] ) ; int arr_sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) arr_sum += arr [ i ] ; int set_sum = 0 ; foreach ( int i in s ) set_sum += i ; Console . WriteLine ( ( K * set_sum - arr_sum ) / ( K - 1 ) ) ; }
int findunique ( int [ ] a , int k ) { int res = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int p = 0 ; for ( int j = 0 ; j < a . Length ; j ++ ) { p += ( Math . Abs ( a [ j ] ) & ( 1 << i ) ) != 0 ? 1 : 0 ; } p %= k ; res += ( int ) Math . Pow ( 2 , i ) * p ; } int c = 0 ; for ( int x = 0 ; x < a . Length ; x ++ ) if ( a [ x ] == res ) { c = 1 ; break ; } return c == 1 ? res : - res ; }
int stepRequired ( int N ) { int cnt = 0 ; while ( N > 0 ) { N = N & ( N - 1 ) ; cnt ++ ; } return cnt ; }
bool isPerfectSquare ( int x ) { int s = ( int ) Math . Sqrt ( x ) ; return ( s * s == x ) ; }
bool isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
void findEquation ( int a , int b , int c ) { int X = ( a + b + c ) ; int Y = ( a * b ) + ( b * c ) + ( c * a ) ; int Z = a * b * c ; Console . Write ( "x^3 - " + X + "x^2 + " + Y + "x - " + Z + " = 0" ) ; }
double dydx ( double x , double y ) { return ( x - y ) / 2 ; }
int numPrimeArrangements ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < prime . Length ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( prime [ i ] ) { for ( int factor = 2 ; factor * i <= n ; factor ++ ) prime [ factor * i ] = false ; } } int primeIndices = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( prime [ i ] ) primeIndices ++ ; int mod = ( int ) ( 1e9 + 7 ) , res = 1 ; for ( int i = 1 ; i <= primeIndices ; i ++ ) res = ( int ) ( ( 1L * res * i ) % mod ) ; for ( int i = 1 ; i <= ( n - primeIndices ) ; i ++ ) res = ( int ) ( ( 1L * res * i ) % mod ) ; return res ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
double count_heads ( int n , int r ) { double output ; output = fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; output = output / ( Math . Pow ( 2 , n ) ) ; return output ; }
void PrintReverseOrder ( int N ) { if ( N <= 0 ) { return ; } else { Console . Write ( N + " " ) ; PrintReverseOrder ( N - 1 ) ; } }
int findAns ( int a , int b , int n ) { int lcm = ( a * b ) / __gcd ( a , b ) ; int multiples = ( n / lcm ) + 1 ; int answer = Math . Max ( a , b ) * multiples ; int lastvalue = lcm * ( n / lcm ) + Math . Max ( a , b ) ; if ( lastvalue > n ) { answer = answer - ( lastvalue - n - 1 ) ; } return answer ; }
int modInverse ( int n , int p ) { return power ( n , p - 2 , p ) ; }
int nCrModPFermat ( int n , int r , int p ) { if ( r == 0 ) return 1 ; if ( n < r ) return 0 ; int [ ] fac = new int [ n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; }
int SumOfXor ( int [ ] a , int n ) { int mod = 10037 ; int answer = 0 ; for ( int k = 0 ; k < 32 ; k ++ ) { int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & ( 1 << k ) ) != 0 ) x ++ ; else y ++ ; } answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod ; } return answer ; }
void movesRequired ( int a , int b ) { int total_moves = a % b ; Console . Write ( total_moves ) ; }
double Volume_of_cone ( double R ) { double V = ( double ) ( ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ) ; return V ; }
int maximumComponentSize ( int [ ] a , int n ) { List < int > [ ] adj = new List < int > [ n ] ; for ( int i = 0 ; i < adj . Length ; i ++ ) adj [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( __gcd ( a [ i ] , a [ j ] ) > 1 ) adj [ i ] . Add ( j ) ; adj [ j ] . Add ( i ) ; } } int answer = 0 ; int [ ] vis = new int [ n ] ; for ( int k = 0 ; k < n ; k ++ ) { vis [ k ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] == 0 ) { answer = Math . Max ( answer , dfs ( i , adj , vis ) ) ; } } return answer ; }
void sieve ( ) { for ( int i = 2 ; i < 100005 ; i ++ ) { if ( spf [ i ] == 0 ) { spf [ i ] = i ; for ( int j = 2 * i ; j < 100005 ; j += i ) { if ( spf [ j ] == 0 ) spf [ j ] = i ; } } } }
void factorize ( int n , HashSet < int > s ) { while ( n > 1 ) { int z = spf [ n ] ; s . Add ( z ) ; while ( n % z == 0 ) n /= z ; } }
int root ( int i ) { if ( par [ i ] == i ) return i ; else return par [ i ] = root ( par [ i ] ) ; }
void merge ( int a , int b ) { int p = root ( a ) ; int q = root ( b ) ; if ( p == q ) return ; if ( sizeContainer [ p ] > sizeContainer [ q ] ) { p = p + q ; q = p - q ; p = p - q ; } par [ p ] = q ; sizeContainer [ q ] += sizeContainer [ p ] ; }
int maximumComponentsizeContainer ( int [ ] a , int n ) { for ( int i = 0 ; i < 100005 ; i ++ ) { par [ i ] = i ; sizeContainer [ i ] = 1 ; } sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) { HashSet < int > s = new HashSet < int > ( ) ; factorize ( a [ i ] , s ) ; foreach ( int it in s ) { if ( id [ it ] == 0 ) id [ it ] = i + 1 ; else merge ( i + 1 , id [ it ] ) ; } } int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) answer = Math . Max ( answer , sizeContainer [ i ] ) ; return answer ; }
bool check ( int X , int K ) { int prime , temp , sqr , i ; prime = 0 ; temp = X ; sqr = Convert . ToInt32 ( Math . Sqrt ( X ) ) ; for ( i = 2 ; i <= sqr ; i ++ ) { while ( temp % i == 0 ) { temp = temp / i ; prime ++ ; } } if ( temp > 2 ) prime ++ ; if ( X == 1 ) return false ; if ( prime == 1 && K == 1 ) return true ; else if ( prime >= K ) return true ; else return false ; }
void precompute ( ) { phi [ 1 ] = 0 ; for ( int i = 2 ; i < N ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p < N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i < N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int maxAlternatingSum ( int [ ] arr , int n ) { int max_sum = 0 ; int i = 0 ; while ( i < n ) { int current_max = arr [ i ] ; int k = i ; while ( k < n && ( ( arr [ i ] > 0 && arr [ k ] > 0 ) || ( arr [ i ] < 0 && arr [ k ] < 0 ) ) ) { current_max = Math . Max ( current_max , arr [ k ] ) ; k += 1 ; } max_sum += current_max ; i = k ; } return max_sum ; }
int subarrayLength ( int [ ] A , int [ , ] R , int N , int M ) { for ( int i = 0 ; i < M ; ++ i ) { int l = R [ i , 0 ] , r = R [ i , 1 ] + 1 ; l -- ; r -- ; A [ l ] ++ ; if ( r < N ) A [ r ] -- ; } for ( int i = 1 ; i < N ; ++ i ) { A [ i ] += A [ i - 1 ] ; } int count = 0 ; HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { if ( ! s . Contains ( A [ i ] ) ) count ++ ; s . Add ( A [ i ] ) ; } int [ ] repeat = new int [ count + 1 ] ; int ans = N ; int counter = 0 , left = 0 , right = 0 ; while ( right < N ) { int cur_element = A [ right ] ; repeat [ cur_element ] += 1 ; if ( repeat [ cur_element ] == 1 ) ++ counter ; while ( counter == count ) { ans = Math . Min ( ans , right - left + 1 ) ; cur_element = A [ left ] ; repeat [ cur_element ] -= 1 ; ++ left ; if ( repeat [ cur_element ] == 0 ) -- counter ; } ++ right ; } return ans ; }
void ModifiedSieveOfEratosthenes ( int N , bool [ ] Expo_Prime ) { bool [ ] primes = new bool [ N ] ; for ( int i = 0 ; i < N ; i ++ ) primes [ i ] = true ; for ( int i = 2 ; i < N ; i ++ ) { if ( primes [ i ] ) { int no = i ; while ( no <= N ) { Expo_Prime [ no ] = true ; no *= i ; } for ( int j = i * i ; j < N ; j += i ) primes [ j ] = false ; } } }
void FindExpoPrime ( int [ ] arr , int n ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) max = arr [ i ] ; } bool [ ] Expo_Prime = new bool [ max + 1 ] ; ModifiedSieveOfEratosthenes ( max + 1 , Expo_Prime ) ; Display ( arr , Expo_Prime , n ) ; }
double nthRoot ( long A , long N ) { double xPre = 7 ; double eps = 1e-3 ; double delX = int . MaxValue ; double xK = 0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . Pow ( xPre , N - 1 ) ) / ( double ) N ; delX = Math . Abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
bool check ( long no , int k ) { double kth_root = nthRoot ( no , k ) ; long num = ( long ) kth_root ; if ( Math . Abs ( num - kth_root ) < 1e-4 ) return true ; return false ; }
void printExpo ( long [ ] arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( check ( arr [ i ] , k ) ) Console . Write ( arr [ i ] + " " ) ; } }
void SieveOfEratosthenes ( ) { bool [ ] check = new bool [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) check [ i ] = true ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( check [ p ] == true ) { prime . Add ( p ) ; for ( int i = p * p ; i <= N ; i += p ) check [ i ] = false ; } } }
bool isPathCo_Prime ( List < int > path ) { int max = 0 ; foreach ( int x in path ) { if ( max < x ) max = x ; } for ( int i = 0 ; i * prime [ i ] <= max / 2 ; i ++ ) { int ct = 0 ; foreach ( int x in path ) { if ( x % prime [ i ] == 0 ) ct ++ ; } if ( ct > 1 ) { return false ; } } return true ; }
int CntcontSubs ( int [ ] a , int n ) { int c = 0 , d = 0 , i , sum = 1 , j ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 a [ i ] % 4 == 0 ) d ++ ; sum = a [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { sum = sum * a [ j ] ; if ( sum % 2 != 0 sum % 4 == 0 ) c ++ ; } sum = 1 ; } return c + d ; }
int CntcontSubs ( int [ ] a , int n ) { List < pair > vect = new List < pair > ( ) ; vect . Add ( new pair ( 0 , 2 ) ) ; List < int > two = new List < int > ( ) ; List < int > zero = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i ] % 4 ; if ( a [ i ] < 0 ) a [ i ] = a [ i ] + 4 ; if ( a [ i ] == 2 ) two . Add ( i + 1 ) ; if ( a [ i ] == 0 ) zero . Add ( i + 1 ) ; if ( a [ i ] == 0 a [ i ] == 2 ) vect . Add ( new pair ( i + 1 , a [ i ] ) ) ; } vect . Add ( new pair ( n + 1 , 2 ) ) ; int total = ( n * ( n + 1 ) ) / 2 ; if ( two . Count == 0 ) return total ; else { int sum = 0 ; int sz = vect . Count ; for ( int i = 1 ; i + 1 < sz ; i ++ ) { if ( vect [ i ] . second == 2 ) { sum += ( vect [ i ] . first - vect [ i - 1 ] . first ) * ( vect [ i + 1 ] . first - vect [ i ] . first ) - 1 ; } } return total - sum - two . Count ; } }
int countSubarray ( int n ) { return ( ( n ) * ( n + 1 ) ) / 2 ; }
int countSubsequence ( int n ) { return ( int ) Math . Pow ( 2 , n ) ; }
float y ( float x ) { return ( 1 / ( 1 + x ) ) ; }
float BooleRule ( float a , float b ) { int n = 4 ; int h ; h = ( int ) ( ( b - a ) / n ) ; float sum = 0 ; float bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 ; sum = sum + bl ; return sum ; }
int countSubsets ( int [ ] a , int n ) { int answer = 0 ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int bitwiseAND = - 1 ; int bitwiseOR = 0 ; int bitwiseXOR = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) == 0 ) { if ( bitwiseAND == - 1 ) bitwiseAND = a [ j ] ; else bitwiseAND &= a [ j ] ; bitwiseOR |= a [ j ] ; bitwiseXOR ^= a [ j ] ; } } if ( bitwiseAND == bitwiseOR && bitwiseOR == bitwiseXOR ) answer = ( answer + 1 ) % mod ; } return answer ; }
int countSubsets ( int [ ] a , int n ) { int answer = 0 ; int [ ] powerOfTwo = new int [ 100005 ] ; powerOfTwo [ 0 ] = 1 ; for ( int i = 1 ; i < 100005 ; i ++ ) powerOfTwo [ i ] = ( powerOfTwo [ i - 1 ] * 2 ) % mod ; Dictionary < int , int > frequency = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( frequency . ContainsKey ( a [ i ] ) ) { frequency [ a [ i ] ] = frequency [ a [ i ] ] + 1 ; } else { frequency . Add ( a [ i ] , 1 ) ; } foreach ( KeyValuePair < int , int > el in frequency ) { if ( el . Key != 0 ) answer = ( answer % mod + powerOfTwo [ el . Value - 1 ] ) % mod ; else answer = ( answer % mod + powerOfTwo [ el . Value ] - 1 + mod ) % mod ; } return answer ; }
int count ( int [ ] arr , int N , int K ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) { count = count + 1 ; } else { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } ans = ans + ( count * ( count + 1 ) ) / 2 ; return ans ; }
void precomputation ( ) { for ( int i = 1 ; i < 10000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfect ( i ) ; } }
void convertToTernary ( int N ) { if ( N == 0 ) return ; int x = N % 3 ; N /= 3 ; if ( x < 0 ) N += 1 ; convertToTernary ( N ) ; if ( x < 0 ) Console . Write ( x + ( 3 * - 1 ) ) ; else Console . Write ( x ) ; }
bool isPerfectSquare ( int N ) { double sr = Math . Sqrt ( N ) ; return ( sr - Math . Floor ( sr ) ) == 0 ; }
int EulerTotientFunction ( int limit ) { int copy = limit ; List < int > primes = new List < int > ( ) ; for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( limit % i == 0 ) { while ( limit % i == 0 ) { limit /= i ; } primes . Add ( i ) ; } } if ( limit >= 2 ) { primes . Add ( limit ) ; } int ans = copy ; foreach ( int it in primes ) { ans = ( ans / it ) * ( it - 1 ) ; } return ans ; }
long product ( int [ , ] mat , int n ) { long d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += mat [ i , i ] ; d2 += mat [ i , n - i - 1 ] ; } return 1L * d1 * d2 ; }
float getPercentile ( int rank , int students ) { float result = ( float ) ( students - rank ) / students * 100 ; return result ; }
int fib ( int n ) { double phi = ( 1 + Math . Sqrt ( 5 ) ) / 2 ; return ( int ) Math . Round ( Math . Pow ( phi , n ) / Math . Sqrt ( 5 ) ) ; }
int calculateSum ( int l , int r ) { int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; }
int sumFibonacci ( int k ) { int l = ( k * ( k - 1 ) ) / 2 ; int r = l + k ; int sum = calculateSum ( l , r - 1 ) ; return sum ; }
int NthSmallest ( int K ) { List < int > Q = new List < int > ( ) ; int x = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) Q . Add ( i ) ; for ( int i = 1 ; i <= K ; i ++ ) { x = Q [ 0 ] ; Q . RemoveAt ( 0 ) ; if ( x % 10 != 0 ) { Q . Add ( x * 10 + x % 10 - 1 ) ; } Q . Add ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . Add ( x * 10 + x % 10 + 1 ) ; } } return x ; }
void sumOfPrevK ( int N , int K ) { int [ ] arr = new int [ N ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { int j = i - 1 , count = 0 , sum = 0 ; while ( j >= 0 && count < K ) { sum += arr [ j ] ; j -- ; count ++ ; } arr [ i ] = sum ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }
int findSum ( int [ ] arr , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; }
int get ( int x , int y , int z ) { if ( x > z ) return - 1 ; int val = z - x ; int div = ( z - x ) / y ; int ans = div * y + x ; return ans ; }
bool subarrayPossible ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum <= 0 ) return true ; } sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; if ( sum <= 0 ) return true ; } return false ; }
int probability ( int N ) { int a = 2 ; int b = 3 ; if ( N == 1 ) { return a ; } else if ( N == 2 ) { return b ; } else { for ( int i = 3 ; i <= N ; i ++ ) { int c = a + b ; a = b ; b = c ; } return b ; } }
float y ( float x ) { float num = 1 ; float denom = ( float ) 1.0 + x * x ; return num / denom ; }
float WeedleRule ( float a , float b ) { float h = ( b - a ) / 6 ; float sum = 0 ; sum = sum + ( ( ( 3 * h ) / 10 ) * ( y ( a ) + y ( a + 2 * h ) + 5 * y ( a + h ) + 6 * y ( a + 3 * h ) + y ( a + 4 * h ) + 5 * y ( a + 5 * h ) + y ( a + 6 * h ) ) ) ; return sum ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int findSmallest ( int N ) { if ( N == 0 ) return 2 ; if ( N == 1 ) return 1 ; int prime = N , counter = 0 ; bool found = false ; while ( ! found ) { if ( isPrime ( prime ) ) found = true ; else { prime ++ ; counter ++ ; } } return counter ; }
double maxSubArraySum ( double [ ] a , int size ) { double max_so_far = Int32 . MinValue , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int findRemainder ( int n ) { int x = n & 3 ; return x ; }
int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
int countReverse ( int [ ] arr , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( reverse ( arr [ i ] ) == arr [ j ] ) { res ++ ; } return res ; }
int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
int countReverse ( int [ ] arr , int n ) { Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( freq . ContainsKey ( arr [ i ] ) ) { freq [ arr [ i ] ] ++ ; } else { freq . Add ( arr [ i ] , 1 ) ; } } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . ContainsKey ( arr [ i ] ) ) { freq [ arr [ i ] ] -- ; } else { freq . Add ( arr [ i ] , - 1 ) ; } if ( freq . ContainsKey ( reverse ( arr [ i ] ) ) ) { res += freq [ reverse ( arr [ i ] ) ] ; } } return res ; }
int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = Math . Max ( l , a ) ; int R = Math . Min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( int ) Math . Pow ( i , i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
int TrialDivision ( int N ) { int i = 2 ; int k = ( int ) Math . Ceiling ( Math . Sqrt ( N ) ) ; while ( i <= k ) { if ( N % i == 0 ) return 0 ; i += 1 ; } return 1 ; }
void isPossible ( int [ ] A , int n , int k ) { int countOfTwo = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] % 2 == 0 ) { countOfTwo ++ ; } } if ( k == 0 && countOfTwo == n ) Console . Write ( "NO" ) ; else if ( countOfTwo >= k ) { Console . Write ( "Yes" ) ; } else Console . Write ( "No" ) ; }
int countWays ( int A , int B , int C ) { int minAddA = Math . Max ( 0 , ( C + B - A + 2 ) / 2 ) ; int count_ways = Math . Max ( C - minAddA + 1 , 0 ) ; return count_ways ; }
void createHash ( HashSet < int > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . Add ( prev ) ; hash . Add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . Add ( temp ) ; prev = curr ; curr = temp ; } }
void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = i % 2 == 0 ? 2 * i * i + 1 : 2 * i * i - 1 ; Console . Write ( ith_term + ", " ) ; } }
void sieve ( int a , int b ) { prime [ 1 ] = 1 ; for ( int i = 2 ; i * i < size ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * 2 ; j < size ; j += i ) prime [ j ] = 1 ; } } for ( int p = 1 ; p < size ; p ++ ) { for ( int q = 1 ; q < size ; q ++ ) { if ( prime [ p ] == 0 && prime [ q ] == 0 && a * p + b * q < size ) { freq [ a * p + b * q ] ++ ; } } } }
void SieveOfEratosthenes ( ) { bool [ ] check = new bool [ N + 1 ] ; for ( int i = 0 ; i <= N ; i += 1 ) check [ i ] = true ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( check [ p ] == true ) { prime . Add ( p ) ; for ( int i = p * p ; i <= N ; i += p ) check [ i ] = false ; } } }
void printSumSeries ( int N ) { float sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( float ) 1.0 / ( 2 * i - 1 ) ; } Console . WriteLine ( sum ) ; }
void printSeriesSum ( int N ) { double sum = 0 ; int a = 1 ; int cnt = 0 ; bool flag = true ; sum += a ; while ( cnt < N ) { int nextElement ; if ( flag == true ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * 3 / 2 ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } Console . WriteLine ( sum ) ; }
void MinimumSwapOperations ( string s ) { bool zero_exist = false ; bool multiple_of_2 = false ; int sum = 0 ; int index_of_zero = 0 ; bool more_zero = false ; for ( int i = 0 ; i < s . Length ; i ++ ) { int val = s [ i ] - '0' ; if ( zero_exist == true ) more_zero = true ; if ( val == 0 ) { zero_exist = true ; index_of_zero = i ; } sum += val ; } if ( zero_exist == false sum % 3 != 0 ) { Console . WriteLine ( "-1" ) ; return ; } for ( int i = 0 ; i < s . Length ; i ++ ) { int val = s [ i ] - '0' ; if ( val % 2 == 0 && i != index_of_zero ) multiple_of_2 = true ; } if ( multiple_of_2 == false ) { Console . WriteLine ( "-1" ) ; return ; } int last_val = s [ ( s . Length - 1 ) - '0' ] ; int second_last_val = s [ ( s . Length - 2 ) - '0' ] ; if ( last_val == 0 && second_last_val % 2 == 0 ) Console . WriteLine ( 0 ) ; else if ( ( last_val == 0 && second_last_val % 2 != 0 ) || ( last_val % 2 == 0 && second_last_val == 0 ) ) Console . WriteLine ( 1 ) ; else if ( more_zero == true && ( last_val == 0 && second_last_val % 2 != 0 ) ) Console . WriteLine ( 1 ) ; else Console . WriteLine ( 2 ) ; }
void sieve ( int n ) { for ( int i = 2 ; i < n ; ++ i ) { if ( min_prime [ i ] > 0 ) { continue ; } min_prime [ i ] = i ; max_prime [ i ] = i ; int j = i + i ; while ( j < n ) { if ( min_prime [ j ] == 0 ) { min_prime [ j ] = i ; } max_prime [ j ] = i ; j += i ; } } }
int findCost ( int A , int B , int C , int X ) { sieve ( MAX ) ; int N , M ; if ( X == 1 ) { return - 1 ; } int min_cost = C + X ; int cost_for_prime = A ; N = max_prime [ X ] ; if ( N != X ) { M = X / N ; cost_for_prime += M ; min_cost = Math . Min ( min_cost , cost_for_prime ) ; } M = min_prime [ X ] ; N = X / M ; if ( N != min_prime [ N ] ) { int cost_for_comp = B + M ; min_cost = Math . Min ( min_cost , cost_for_comp ) ; } return min_cost ; }
int minOperations ( int A , int B ) { if ( A > B ) { A = A + B ; B = A - B ; A = A - B ; } B = B / __gcd ( A , B ) ; return B - 1 ; }
void quadrant ( String s ) { int l = s . Length ; int i ; if ( s . Contains ( "+" ) ) { i = s . IndexOf ( '+' ) ; } else { i = s . IndexOf ( '-' ) ; } String real = s . Substring ( 0 , i ) ; String imaginary = s . Substring ( i + 1 , l - 2 - i ) ; int x = Int32 . Parse ( real ) ; int y = Int32 . Parse ( imaginary ) ; if ( x > 0 && y > 0 ) Console . Write ( "Quadrant 1" ) ; else if ( x < 0 && y > 0 ) Console . Write ( "Quadrant 2" ) ; else if ( x < 0 && y < 0 ) Console . Write ( "Quadrant 3" ) ; else if ( x > 0 && y < 0 ) Console . Write ( "Quadrant 4" ) ; else if ( x == 0 && y > 0 ) Console . Write ( "Lies on positive" + " Imaginary axis" ) ; else if ( x == 0 && y < 0 ) Console . Write ( "Lies on negative" + " Imaginary axis" ) ; else if ( y == 0 && x < 0 ) Console . Write ( "Lies on negative" + " X-axis" ) ; else if ( y == 0 && x > 0 ) Console . Write ( "Lies on positive" + " X-axis" ) ; else Console . Write ( "Lies on the Origin" ) ; }
int highestPower ( int n , int k ) { int i = 0 ; int a = ( int ) Math . Pow ( n , i ) ; while ( a <= k ) { i += 1 ; a = ( int ) Math . Pow ( n , i ) ; } return i - 1 ; }
int PowerArray ( int n , int k ) { while ( k > 0 ) { int t = highestPower ( n , k ) ; if ( b [ t ] > 0 ) { Console . Write ( - 1 ) ; return 0 ; } else b [ t ] = 1 ; k -= ( int ) Math . Pow ( n , t ) ; } for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] > 0 ) { Console . Write ( i + ", " ) ; } } return 0 ; }
int PowerArray ( int n , int k ) { int count = 0 ; while ( k > 0 ) { if ( k % n == 0 ) { k /= n ; count ++ ; } else if ( k % n == 1 ) { k -= 1 ; b [ count ] ++ ; if ( b [ count ] > 1 ) { Console . Write ( - 1 ) ; return 0 ; } } else { Console . Write ( - 1 ) ; return 0 ; } } for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] != 0 ) { Console . Write ( i + ", " ) ; } } return int . MinValue ; }
double countdigits ( int n , int k ) { if ( n == 0 ) return 0 ; int digit = n % 10 ; if ( digit == k ) return 1 + countdigits ( n / 10 , k ) ; return countdigits ( n / 10 , k ) ; }
int largestElement ( Node head_ref ) { int max = int . MinValue ; Node head = head_ref ; while ( head != null ) { if ( max < head . data ) max = head . data ; head = head . next ; } return max ; }
void createHash ( HashSet < int > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . Add ( prev ) ; hash . Add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . Add ( temp ) ; prev = curr ; curr = temp ; } }
void printModulus ( int X , int Y ) { int n = Math . Max ( X , Y ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) Console . Write ( i + " " ) ; } }
void printModulus ( int X , int Y ) { int d = Math . Abs ( X - Y ) ; int i = 1 ; while ( i * i <= d ) { if ( d % i == 0 ) { Console . Write ( i + " " ) ; if ( d / i != i ) Console . Write ( d / i + " " ) ; } i ++ ; } }
bool difSquare ( int n ) { if ( n % 4 != 2 ) { return true ; } return false ; }
int countFibonacciDivisors ( int n ) { HashSet < int > hash = new HashSet < int > ( ) ; createHash ( hash , n ) ; int cnt = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( ( n / i == i ) && ( hash . Contains ( n / i ) ) ) cnt ++ ; else { if ( hash . Contains ( n / i ) ) cnt ++ ; if ( hash . Contains ( n / ( n / i ) ) ) cnt ++ ; } } } return cnt ; }
int findCount ( Node root , int K ) { res = 0 ; k = K ; rec ( root ) ; return res ; }
void makearrayequal ( int [ ] arr , int n ) { int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x += ( arr [ i ] & 1 ) ; } Console . WriteLine ( Math . Min ( x , n - x ) ) ; }
void SieveOfEratosthenes ( List < Boolean > composite ) { for ( int i = 0 ; i < N ; i ++ ) { composite . Insert ( i , false ) ; } for ( int p = 2 ; p * p < N ; p ++ ) { if ( ! composite [ p ] ) { for ( int i = p * 2 ; i < N ; i += p ) { composite . Insert ( i , true ) ; } } } }
int sumOfElements ( int [ ] arr , int n ) { List < Boolean > composite = new List < Boolean > ( ) ; for ( int i = 0 ; i < N ; i ++ ) composite . Add ( false ) ; SieveOfEratosthenes ( composite ) ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } int sum = 0 ; foreach ( KeyValuePair < int , int > it in mp ) { if ( composite [ it . Value ] ) { sum += ( it . Key ) ; } } return sum ; }
int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - 'A' + 10 ; }
int toDeci ( string str , int base_var ) { int len = str . Length ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= base_var ) { Console . WriteLine ( "Invalid Number" ) ; return - 1 ; } num += val ( str [ i ] ) * power ; power = power * base_var ; } return num ; }
bool isEven ( string num , int N ) { int deci = toDeci ( num , N ) ; return ( deci % 2 == 0 ) ; }
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d == 2 d == 3 d == 5 d == 7 ) count ++ ; } return count ; }
void remove ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( mp . ContainsKey ( arr [ i ] ) && mp [ arr [ i ] ] % 2 == 1 ) ) continue ; Console . Write ( arr [ i ] + ", " ) ; } }
void SieveOfEratosthenes ( bool [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
int longestPrimeSubsequence ( int [ ] arr , int n ) { bool [ ] prime = new bool [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , N ) ; int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { answer ++ ; } } return answer ; }
void checkPalindrome ( int num ) { String str = num . ToString ( ) ; int l = 0 , r = str . Length - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { Console . Write ( "No" ) ; return ; } l ++ ; r -- ; } Console . Write ( "Yes" ) ; return ; }
double dydx ( double x , double y ) { return ( x + y - 2 ) ; }
double rungeKutta ( double x0 , double y0 , double x , double h ) { int n = ( int ) ( ( x - x0 ) / h ) ; double k1 , k2 ; double y = y0 ; for ( int i = 1 ; i <= n ; i ++ ) { k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; y = y + ( 1.0 / 6.0 ) * ( k1 + 2 * k2 ) ; x0 = x0 + h ; } return y ; }
bool isPerfectSquare ( int x ) { int s = ( int ) Math . Sqrt ( x ) ; return ( s * s == x ) ; }
int isFibonacci ( int n ) { if ( isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ) return 1 ; return 0 ; }
void compute ( int a , int b ) { for ( int i = 1 ; i < 100010 ; i ++ ) { fib [ i ] = isFibonacci ( i ) ; } for ( int x = 1 ; x < 100010 ; x ++ ) { for ( int y = 1 ; y < size ; y ++ ) { if ( fib [ x ] == 1 && fib [ y ] == 1 && a * x + b * y < 100010 ) { freq [ a * x + b * y ] ++ ; } } } }
void findMaxSum ( int n1 , int n2 ) { int [ ] arr1 = new int [ MAX ] ; int [ ] arr2 = new int [ MAX ] ; int l1 = 0 , l2 = 0 ; int max1 = Math . Max ( n1 , n2 ) ; int min1 = Math . Min ( n1 , n2 ) ; for ( int i = max1 ; i > 0 ; i /= 10 ) arr1 [ l1 ++ ] = ( i % 10 ) ; for ( int i = min1 ; i > 0 ; i /= 10 ) arr2 [ l2 ++ ] = ( i % 10 ) ; int f = 0 ; if ( l1 != l2 ) { int index = ( max_element ( arr2 , l2 ) ) ; for ( int i = l1 - 1 ; i > ( l2 - 1 ) ; i -- ) { if ( arr1 [ i ] < arr2 [ index ] ) { int tmp = arr1 [ i ] ; arr1 [ i ] = arr2 [ index ] ; arr2 [ index ] = tmp ; f = 1 ; break ; } } } if ( f != 1 ) { int index1 = 0 , index2 = 0 ; int diff1 = 0 , diff2 = 0 ; for ( int i = l2 - 1 ; i >= 0 ; i -- ) { index1 = ( max_element ( arr1 , i ) ) ; index2 = ( max_element ( arr2 , i ) ) ; diff1 = ( arr2 [ index2 ] - arr1 [ i ] ) ; diff2 = ( arr1 [ index1 ] - arr2 [ i ] ) ; if ( diff1 > 0 diff2 > 0 ) { if ( diff1 > diff2 ) { int tmp = arr1 [ i ] ; arr1 [ i ] = arr2 [ index2 ] ; arr2 [ index2 ] = tmp ; break ; } else if ( diff2 > diff1 ) { int tmp = arr1 [ index1 ] ; arr1 [ index1 ] = arr2 [ i ] ; arr2 [ i ] = tmp ; break ; } else if ( diff1 == diff2 ) { if ( index1 <= index2 ) { int tmp = arr1 [ index1 ] ; arr1 [ index1 ] = arr2 [ i ] ; arr2 [ i ] = tmp ; break ; } else if ( index2 <= index1 ) { int tmp = arr1 [ i ] ; arr1 [ i ] = arr2 [ index2 ] ; arr2 [ index2 ] = tmp ; break ; } } } } } int f_n1 = 0 , f_n2 = 0 ; for ( int i = l1 - 1 ; i >= 0 ; i -- ) { f_n1 = ( f_n1 * 10 ) + arr1 [ i ] ; f_n2 = ( f_n2 * 10 ) + arr2 [ i ] ; } Console . Write ( f_n1 + f_n2 ) ; }
void checkCube ( int a , int b ) { string s1 = Convert . ToString ( a ) ; string s2 = Convert . ToString ( b ) ; int c = Convert . ToInt32 ( s1 + s2 ) ; if ( isPerfectCube ( c ) ) { Console . WriteLine ( "Yes" ) ; } else { Console . WriteLine ( "No" ) ; } }
bool isDivisible ( int n ) { int d ; while ( n / 100 > 0 ) { d = n % 10 ; n /= 10 ; n = Math . Abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; }
string even_or_odd ( string N ) { int len = N . Length ; if ( N [ len - 1 ] == '0' N [ len - 1 ] == '2' N [ len - 1 ] == '4' N [ len - 1 ] == '6' N [ len - 1 ] == '8' N [ len - 1 ] == 'A' N [ len - 1 ] == 'C' N [ len - 1 ] == 'E' ) return ( "Even" ) ; else return ( "Odd" ) ; }
bool isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . Abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; }
bool isPerfectSquare ( int x ) { int s = ( int ) Math . Sqrt ( x ) ; return ( s * s == x ) ; }
bool isFibonacci ( int N ) { return isPerfectSquare ( 5 * N * N + 4 ) || isPerfectSquare ( 5 * N * N - 4 ) ; }
int nextNonFibonacci ( int N ) { if ( N <= 3 ) return 4 ; if ( isFibonacci ( N + 1 ) ) return N + 2 ; else return N + 1 ; }
bool isDivisible ( int n ) { int d ; while ( n / 100 > 0 ) { d = n % 10 ; n /= 10 ; n = Math . Abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; }
int findDigits ( int n ) { int count = 0 ; while ( n != 0 ) { digit [ count ] = n % 10 ; n = n / 10 ; ++ count ; } return count ; }
int OR_of_Digits ( int n , int count ) { int ans = 0 ; for ( int i = 0 ; i < count ; i ++ ) { ans = ans | digit [ i ] ; } return ans ; }
int AND_of_Digits ( int n , int count ) { int ans = 0 ; for ( int i = 0 ; i < count ; i ++ ) { ans = ans & digit [ i ] ; } return ans ; }
int XOR_of_Digits ( int n , int count ) { int ans = 0 ; for ( int i = 0 ; i < count ; i ++ ) { ans = ans ^ digit [ i ] ; } return ans ; }
void preCompute ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i < 18 ; i ++ ) fact [ i ] = ( fact [ i - 1 ] * i ) ; }
void nextFactorial ( int N ) { for ( int i = 0 ; i < 21 ; i ++ ) { if ( N < fact [ i ] ) { Console . WriteLine ( fact [ i ] ) ; break ; } } }
int largest_sum ( int [ ] arr , int n ) { int maximum = - 1 ; Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . ContainsKey ( arr [ i ] ) ) { m [ arr [ i ] ] ++ ; } else { m . Add ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( m [ arr [ i ] ] > 1 ) { if ( m . ContainsKey ( 2 * arr [ i ] ) ) { m [ 2 * arr [ i ] ] = m [ 2 * arr [ i ] ] + m [ arr [ i ] ] / 2 ; } else { m . Add ( 2 * arr [ i ] , m [ arr [ i ] ] / 2 ) ; } if ( 2 * arr [ i ] > maximum ) maximum = 2 * arr [ i ] ; } } return maximum ; }
int maxLength ( int [ ] arr , int N ) { int product = 1 , len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { product *= arr [ i ] ; } if ( product >= 0 ) { return N ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { len = Math . Max ( len , Math . Max ( N - i - 1 , i ) ) ; } } return len ; }
void findNumbers ( int N ) { int i = 1 ; while ( i <= N ) { Console . Write ( ( i * i * i ) + " " ) ; i ++ ; } }
int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; }
int properDivisorSum ( int n ) { int sum = 0 ; int i ; for ( i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum - n * ( n + 1 ) / 2 ; }
void findMinimumOperation ( int n , int d , int [ , ] arrays ) { int cnt = 0 ; int first = int . MinValue , end = int . MaxValue ; while ( n > 0 ) { int [ ] arr = { arrays [ cnt , 0 ] , arrays [ cnt , 1 ] } ; Array . Sort ( arr ) ; first = Math . Max ( first , arr [ 0 ] ) ; end = Math . Min ( end , arr [ 1 ] ) ; cnt ++ ; n -- ; } if ( first > end ) Console . Write ( "-1" ) ; else { if ( d >= first && d <= end ) { Console . Write ( "0" ) ; } else Console . Write ( Math . Min ( Math . Abs ( first - d ) , Math . Abs ( d - end ) ) ) ; } }
long mult ( long a , long b ) { return ( ( a % mod ) * ( b % mod ) ) % mod ; }
long calculate_factors ( long n ) { long ans , cnt ; cnt = 0 ; ans = 1 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } if ( cnt % 2 == 1 ) { ans = mult ( ans , ( cnt + 1 ) ) ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } if ( cnt % 2 == 1 ) { ans = mult ( ans , ( cnt + 1 ) ) ; } } if ( n > 2 ) { ans = mult ( ans , ( 2 ) ) ; } return ans % mod ; }
void getmax ( int [ ] arr , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } Console . WriteLine ( Math . Min ( s , x ) ) ; }
void generatePrime ( ) { int i , j ; for ( i = 2 ; i <= sz ; i ++ ) isPrime [ i ] = true ; for ( i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
void Pair_of_PrimeXor ( int [ ] A , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isPrime [ ( A [ i ] ^ A [ j ] ) ] ) { Console . Write ( "(" + A [ i ] + ", " + A [ j ] + ") " ) ; } } } }
List < int > primeFactors ( int n ) { int i ; List < int > Prime = new List < int > ( ) ; if ( n % 2 == 0 ) { Prime . Add ( 2 ) ; } while ( n % 2 == 0 ) { n = n / 2 ; } for ( i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { Prime . Add ( i ) ; } while ( n % i == 0 ) { n = n / i ; } } if ( n > 2 ) { Prime . Add ( n ) ; } return Prime ; }
void checkDistinctPrime ( int n ) { List < int > Prime = primeFactors ( n ) ; int product = 1 ; foreach ( int i in Prime ) { product *= i ; } if ( product == n ) Console . Write ( "YES" ) ; else Console . Write ( "NO" ) ; }
double nthRoot ( int A , int N ) { Random r = new Random ( ) ; double xPre = r . Next ( 0 , 9 ) ; double eps = 1e-3 ; double delX = int . MaxValue ; double xK = 0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . Pow ( xPre , N - 1 ) ) / ( double ) N ; delX = Math . Abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
int countPowers ( int a , int b , int k ) { return ( int ) ( Math . Floor ( nthRoot ( b , k ) ) - Math . Ceiling ( nthRoot ( a , k ) ) + 1 ) ; }
long findDigits ( int n , int b ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double M_PI = 3.141592 ; double M_E = 2.7182 ; double x = ( ( n * Math . Log10 ( n / M_E ) + Math . Log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( Math . Log10 ( b ) ) ; return ( long ) ( Math . Floor ( x ) + 1 ) ; }
bool isPrime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
int findSum ( int N , int k ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( int ) Math . Pow ( i , k ) ; } return sum ; }
bool isPerfectSquare ( int x ) { int s = ( int ) Math . Sqrt ( x ) ; return ( s * s == x ) ; }
int isNonFibonacci ( int n ) { if ( isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ) return 0 ; else return n ; }
void compute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isNonFibonacci ( i ) ; } }
void printSum ( int L , int R ) { int sum = ( int ) ( pref [ R ] - pref [ L - 1 ] ) ; Console . Write ( sum + " " ) ; }
void checkArray ( int [ ] a , int [ ] b , int n ) { int operations = 0 ; int i = 0 ; while ( i < n ) { if ( a [ i ] - b [ i ] == 0 ) { i ++ ; continue ; } int diff = a [ i ] - b [ i ] ; i ++ ; while ( i < n && a [ i ] - b [ i ] == diff ) { i ++ ; } operations ++ ; } Console . WriteLine ( operations ) ; }
bool isPerfectSquare ( int x ) { int s = ( int ) Math . Sqrt ( x ) ; return ( s * s == x ) ; }
bool isFibonacci ( int n ) { return ( isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ) ; }
int countFibonacciPairs ( int [ ] arr , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( isFibonacci ( arr [ i ] ) && isFibonacci ( arr [ j ] ) ) { int prevFib = previousFibonacci ( arr [ i ] ) ; int nextFib = nextFibonacci ( arr [ i ] ) ; if ( prevFib == arr [ j ] nextFib == arr [ j ] ) { res ++ ; } } return res ; }
int countPairsWithProductK ( int [ ] arr , int n , int k ) { int count = 0 ; int i ; bool [ ] hashmap = new bool [ MAX ] ; for ( i = 0 ; i < n ; i ++ ) hashmap [ arr [ i ] ] = true ; for ( i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; double index = 1.0 * k / arr [ i ] ; if ( index >= 0 && ( ( index - ( int ) ( index ) ) == 0 ) && hashmap [ k / x ] ) count ++ ; hashmap [ x ] = false ; } return count ; }
void simpleSieve ( int limit , ref ArrayList prime ) { bool [ ] mark = new bool [ limit + 1 ] ; Array . Fill ( mark , false ) ; for ( int i = 2 ; i <= limit ; ++ i ) { if ( mark [ i ] == false ) { prime . Add ( i ) ; for ( int j = i ; j <= limit ; j += i ) { mark [ j ] = true ; } } } }
void primesInRange ( int low , int high ) { int limit = ( int ) Math . Floor ( Math . Sqrt ( high ) ) + 1 ; ArrayList prime = new ArrayList ( ) ; simpleSieve ( limit , ref prime ) ; int n = high - low + 1 ; bool [ ] mark = new bool [ n + 1 ] ; Array . Fill ( mark , false ) ; for ( int i = 0 ; i < prime . Count ; i ++ ) { int loLim = ( int ) Math . Floor ( ( double ) low / ( int ) prime [ i ] ) ; loLim *= ( int ) prime [ i ] ; if ( loLim < low ) { loLim += ( int ) prime [ i ] ; } if ( loLim == ( int ) prime [ i ] ) { loLim += ( int ) prime [ i ] ; } for ( int j = loLim ; j <= high ; j += ( int ) prime [ i ] ) mark [ j - low ] = true ; } for ( int i = low ; i <= high ; i ++ ) { if ( ! mark [ i - low ] ) { allPrimes . Add ( i ) ; } } }
int maxPrimeSubarray ( int [ ] arr , int n ) { int current_max = 0 ; int max_so_far = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! allPrimes . Contains ( arr [ i ] ) ) current_max = 0 ; else { current_max ++ ; max_so_far = Math . Max ( current_max , max_so_far ) ; } } return max_so_far ; }
int search ( int [ ] a , int k , int x ) { int j ; for ( j = k - 1 ; j > - 1 ; j -- ) { if ( a [ j ] == x ) return j ; } return - 1 ; }
int countPairsWith ( int n , List < int > perfectcubes , List < int > nums ) { int count = 0 ; for ( int i = 0 ; i < perfectcubes . Count ; i ++ ) { int temp = perfectcubes [ i ] - n ; if ( temp > n && ( nums . Contains ( temp ) ) ) count += 1 ; } return count ; }
int countCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) for ( int j = 1 ; j * j * j <= i ; j ++ ) if ( j * j * j == i ) cnt ++ ; return cnt ; }
int countCubes ( int a , int b ) { return ( int ) ( Math . Floor ( Math . Cbrt ( b ) ) - Math . Ceiling ( Math . Cbrt ( a ) ) + 1 ) ; }
int checkArmstrong ( int x ) { int n = x . ToString ( ) . Length ; int sum1 = 0 ; int temp = x ; while ( temp > 0 ) { int digit = temp % 10 ; sum1 += ( int ) Math . Pow ( digit , n ) ; temp /= 10 ; } if ( sum1 == x ) return x ; return 0 ; }
void printSumarmstrong ( int [ , ] arr , int Q ) { preCompute ( ) ; for ( int i = 0 ; i < Q ; i ++ ) { printSum ( arr [ i , 0 ] , arr [ i , 1 ] ) ; } }
bool isArmstrong ( int x , int n ) { int sum1 = 0 ; int temp = x ; while ( temp > 0 ) { int digit = temp % 10 ; sum1 += ( int ) Math . Pow ( digit , n ) ; temp /= 10 ; } return sum1 == x ; }
void perfectCube ( int N ) { int cube_root ; cube_root = ( int ) Math . Round ( Math . Cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { Console . WriteLine ( "Yes" ) ; return ; } else { Console . WriteLine ( "NO" ) ; return ; } }
Dictionary < int , int > primeFactors ( int n ) { Dictionary < int , int > primeFact = new Dictionary < int , int > ( ) ; while ( n % 2 == 0 ) { primeFact = insertPF ( primeFact , 2 ) ; n /= 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { primeFact = insertPF ( primeFact , i ) ; n /= i ; } } if ( n > 2 ) primeFact = insertPF ( primeFact , n ) ; return primeFact ; }
void check ( int [ ] arr , int N ) { int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N odd == N ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
void findSum ( int N ) { int sum = ( N ) * ( N + 1 ) / 2 ; int r = ( int ) ( Math . Log ( N ) / Math . Log ( 2 ) ) + 1 ; int expSum = ( int ) ( Math . Pow ( 2 , r ) ) - 1 ; Console . Write ( sum - expSum ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i += 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
bool twinPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && Math . Abs ( n1 - n2 ) == 2 ) ; }
int countTwinPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( twinPrime ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 3 != 0 ) ans *= ( int ) Math . Pow ( 2 , ( count % 3 ) ) ; for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 3 != 0 ) ans *= ( int ) Math . Pow ( i , ( count % 3 ) ) ; } if ( n > 2 ) ans *= n ; return ans ; }
void printPairs ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { Console . Write ( "(" + arr [ i ] + ", " + arr [ j ] + ")" + ", " ) ; } } }
int countSteps ( int n ) { int steps = 0 ; while ( n > 0 ) { int largest = ( int ) Math . Pow ( n , ( double ) 1 / 3 ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; }
int product ( int N ) { int ans = 1 ; int val = ( int ) Math . Pow ( 2 , N - 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { ans *= ( int ) Math . Pow ( i , val ) ; } return ans ; }
int nearest ( int n ) { int prevSquare = ( int ) Math . Sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; }
int ways ( int n ) { if ( n < 3 ) { return 0 ; } int c2 = 0 ; int c1 = n - 3 ; int l = c1 + 1 ; int s = 0 ; int exp_c2 = c1 / 2 ; while ( exp_c2 >= c2 ) { int f1 = factorial ( l ) ; int f2 = factorial ( c1 ) ; int f3 = factorial ( c2 ) ; int f4 = ( f2 * f3 ) ; s += f1 / f4 ; c2 += 1 ; c1 -= 2 ; l -= 1 ; } return s ; }
bool isPerfectCube ( int x ) { int cr = ( int ) Math . Cbrt ( x ) ; return ( cr * cr * cr == x ) ; }
int sqrtSearch ( int low , int high , int N ) { if ( low <= high ) { int mid = ( int ) ( low + high ) / 2 ; if ( ( mid * mid <= N ) && ( ( mid + 1 ) * ( mid + 1 ) > N ) ) { return mid ; } else if ( mid * mid < N ) { return sqrtSearch ( mid + 1 , high , N ) ; } else { return sqrtSearch ( low , mid - 1 , N ) ; } } return low ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void printAllDivisors ( int [ ] arr , int N ) { int g = arr [ 0 ] ; HashSet < int > divisors = new HashSet < int > ( ) ; for ( int i = 1 ; i < N ; i ++ ) { g = gcd ( arr [ i ] , g ) ; } for ( int i = 1 ; i * i <= g ; i ++ ) { if ( g % i == 0 ) { divisors . Add ( i ) ; if ( g / i != i ) divisors . Add ( g / i ) ; } } foreach ( int it in divisors ) Console . Write ( it + " " ) ; }
int getSmallestPrimefactor ( int n ) { for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return i ; } return - 1 ; }
bool ispalin ( int num ) { string s = num . ToString ( ) ; int st = 0 ; int ed = s . Length - 1 ; while ( st <= ed ) { if ( s [ st ] != s [ ed ] ) return false ; st ++ ; ed -- ; } return true ; }
void CalculateXORandOR ( int n ) { int CalculateXOR = 0 ; int CalculateOR = 0 ; int start = ( int ) Math . Pow ( 10 , n - 1 ) ; int end = ( int ) Math . Pow ( 10 , n ) - 1 ; for ( int i = start ; i <= end ; i ++ ) { if ( ispalin ( i ) ) { CalculateXOR = CalculateXOR ^ i ; CalculateOR = CalculateOR | i ; } } Console . Write ( "XOR = " + CalculateXOR ) ; Console . WriteLine ( " OR = " + CalculateOR ) ; }
int checkPalindrome ( int num ) { String str = String . Join ( "" , num ) ; int l = 0 , r = str . Length - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { return 0 ; } l ++ ; r -- ; } return num ; }
void preCompute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + checkPalindrome ( i ) ; } }
void Sieve ( ) { for ( int i = 1 ; i < 100001 ; i ++ ) k [ i ] = i ; for ( int i = 2 ; i < 100001 ; i ++ ) { if ( prime [ i ] == 0 ) for ( int j = i ; j < 100001 ; j += i ) { prime [ j ] = 1 ; while ( k [ j ] % ( i * i ) == 0 ) k [ j ] /= ( i * i ) ; } } }
int countPairs ( int [ ] arr , int n ) { Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . ContainsKey ( k [ arr [ i ] ] ) ) { freq [ k [ arr [ i ] ] ] = freq [ k [ arr [ i ] ] ] + 1 ; } else freq . Add ( k [ arr [ i ] ] , 1 ) ; } int sum = 0 ; foreach ( KeyValuePair < int , int > i in freq ) { sum += ( ( i . Value - 1 ) * i . Value ) / 2 ; } return sum ; }
int powOfPositive ( int n ) { int pos = ( int ) Math . Floor ( ( Math . Log ( n ) / Math . Log ( 2 ) ) ) ; return ( int ) Math . Pow ( 2 , pos ) ; }
int powOfNegative ( int n ) { int pos = ( int ) Math . Ceiling ( ( Math . Log ( n ) / Math . Log ( 2 ) ) ) ; return ( int ) ( - 1 * Math . Pow ( 2 , pos ) ) ; }
void highestPowerOf2 ( int n ) { if ( n > 0 ) { Console . WriteLine ( powOfPositive ( n ) ) ; } else { n = - n ; Console . WriteLine ( powOfNegative ( n ) ) ; } }
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) sum += ( i * i ) ; else sum -= ( i * i ) ; } return sum ; }
int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; }
bool isPower ( int x , int y ) { int res1 = ( int ) ( Math . Log ( y ) / Math . Log ( x ) ) ; double res2 = Math . Log ( y ) / Math . Log ( x ) ; return ( res1 == res2 ) ; }
int countPower ( int [ ] arr , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( isPower ( arr [ i ] , arr [ j ] ) || isPower ( arr [ j ] , arr [ i ] ) ) res ++ ; return res ; }
int xor_all_elements ( int n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; } return 0 ; }
void precompute ( ) { int fact = 1 ; for ( int i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m . Add ( fact , i ) ; } }
int sumOfParts ( int [ , ] arr , int N ) { int sum_part1 = 0 , sum_part2 = 0 , sum_part3 = 0 , sum_part4 = 0 ; int totalsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i + j < N - 1 ) { if ( i < j && i != j && i + j > 0 ) sum_part1 += arr [ i , j ] ; else if ( i != j ) sum_part2 += arr [ i , j ] ; } else { if ( i > j && i + j != N - 1 ) sum_part3 += arr [ i , j ] ; else { if ( i + j != N - 1 && i != j ) sum_part4 += arr [ i , j ] ; } } } } totalsum = sum_part1 + sum_part2 + sum_part3 + sum_part4 ; return totalsum ; }
int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; }
int subsetSum ( int [ ] arr , int n , int i , int sum , int count ) { if ( i == n ) { if ( sum == 0 ) { count ++ ; } return count ; } count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) ; count = subsetSum ( arr , n , i + 1 , sum , count ) ; return count ; }
void ifPossible ( int X , int Y ) { if ( X > Y ) swap ( X , Y ) ; if ( ( X + Y ) % 5 == 0 && 3 * X >= 2 * Y ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
long isPerfectCube ( long x ) { double cr = Math . Round ( MathF . Cbrt ( x ) ) ; if ( cr * cr * cr == ( double ) x ) return x ; return 0 ; }
void printSum ( int L , int R ) { long sum = pref [ R ] - pref [ L - 1 ] ; Console . Write ( sum + " " ) ; }
int binomialCoeff ( int n , int k ) { int [ , ] C = new int [ n + 1 , k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } return C [ n , k ] ; }
List < int > sieve ( int n ) { List < int > prime = new List < int > ( ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime . Add ( 0 ) ; int p = 2 ; while ( p * p <= n ) { if ( prime [ p ] == 0 ) { for ( int i = 2 * p ; i < n + 1 ; i += p ) prime [ i ] = 1 ; } p += 1 ; } List < int > allPrimes = new List < int > ( ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( prime [ i ] == 0 ) allPrimes . Add ( i ) ; } return allPrimes ; }
int log_a_to_base_b ( int a , int b ) { return ( int ) ( Math . Log ( a ) / Math . Log ( b ) ) ; }
string findSmallest ( int N ) { string smallest = "1" ; for ( int i = 0 ; i < N - 1 ; i ++ ) smallest += '0' ; return smallest ; }
void heapify ( int [ ] arr , int n , int i ) { int largest = i ; int l = 2 * i + 1 ; int r = 2 * i + 2 ; if ( l < n && arr [ l ] > arr [ largest ] ) largest = l ; if ( r < n && arr [ r ] > arr [ largest ] ) largest = r ; if ( largest != i ) { int swap = arr [ i ] ; arr [ i ] = arr [ largest ] ; arr [ largest ] = swap ; heapify ( arr , n , largest ) ; } }
int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( int ) ( 7 * Math . Pow ( 8 , i - 1 ) ) ; } return sum ; }
int nextPowerOfK ( int n , int k ) { return prevPowerofK ( n , k ) * k ; }
bool isPalindrome ( int n ) { String str = String . Join ( "" , n ) ; int s = 0 , e = str . Length - 1 ; while ( s < e ) { if ( str [ s ] != str [ e ] ) { return false ; } s ++ ; e -- ; } return true ; }
void palindromicDivisors ( int n ) { List < int > PalindromDivisors = new List < int > ( ) ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( isPalindrome ( i ) ) { PalindromDivisors . Add ( i ) ; } } else { if ( isPalindrome ( i ) ) { PalindromDivisors . Add ( i ) ; } if ( isPalindrome ( n / i ) ) { PalindromDivisors . Add ( n / i ) ; } } } } PalindromDivisors . Sort ( ) ; for ( int i = 0 ; i < PalindromDivisors . Count ; i ++ ) { Console . Write ( PalindromDivisors [ i ] + " " ) ; } }
int isPerfectSquare ( int x ) { double sr = Math . Sqrt ( x ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ? x : 0 ; }
void compute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfectSquare ( i ) ; } }
void printSum ( int L , int R ) { int sum = pref [ R ] - pref [ L - 1 ] ; Console . Write ( sum + " " ) ; }
void factors ( int n , int i ) { if ( i <= n ) { if ( n % i == 0 ) { Console . WriteLine ( i + " " ) ; } factors ( n , i + 1 ) ; } }
int solve ( int n ) { int ans = ( n * n / 4 ) ; return ans ; }
void solve ( int [ ] arr , int n ) { HashSet < int > unfilled_indices = new HashSet < int > ( ) ; HashSet < int > missing = new HashSet < int > ( ) ; for ( int i = 1 ; i < n ; i ++ ) { missing . Add ( i ) ; } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { unfilled_indices . Add ( i ) ; } else { missing . Remove ( arr [ i ] ) ; } } int [ ] mi = new int [ missing . Count ] ; int l = 0 ; foreach ( int x in missing ) { mi [ l ++ ] = x ; } int m = missing . Count ; foreach ( int it in unfilled_indices ) { arr [ it ] = mi [ m - 1 ] ; m -- ; } int pos = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { pos = i ; } } if ( pos != 0 ) { for ( int i = 1 ; i < n ; i ++ ) { if ( pos != i ) { if ( unfilled_indices . Contains ( i ) ) { int x = arr [ i ] ; arr [ i ] = pos ; arr [ pos ] = x ; break ; } } } } printArray ( arr , n ) ; }
void printArray ( int [ ] arr , int n ) { for ( int i = 1 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
int maximum ( int x , int y ) { return ( ( x + y + Math . Abs ( x - y ) ) / 2 ) ; }
int minimum ( int x , int y ) { return ( ( x + y - Math . Abs ( x - y ) ) / 2 ) ; }
void SubarraysWithSumS ( int n , int k , int s ) { for ( int i = 0 ; i < k ; i ++ ) Console . Write ( s + " " ) ; for ( int i = k ; i < n ; i ++ ) Console . Write ( s + 1 + " " ) ; }
bool check ( int x , List < int > pos , List < int > neg , int k ) { int pairs = 0 ; int p = neg . Count - 1 ; int nn = neg . Count - 1 ; int pp = pos . Count - 1 ; for ( int i = 0 ; i < neg . Count ; i ++ ) { while ( ( p >= 0 ) && ( ( int ) neg [ i ] * ( int ) neg [ p ] <= x ) ) p -- ; pairs += Math . Min ( nn - p , nn - i ) ; } p = 0 ; for ( int i = pos . Count - 1 ; i >= 0 ; i -- ) { while ( ( p < pos . Count ) && ( ( int ) pos [ i ] * ( int ) pos [ p ] <= x ) ) p ++ ; pairs += Math . Min ( p , i ) ; } p = pos . Count - 1 ; for ( int i = neg . Count - 1 ; i >= 0 ; i -- ) { while ( ( p >= 0 ) && ( ( int ) neg [ i ] * ( int ) pos [ p ] <= x ) ) p -- ; pairs += pp - p ; } return ( pairs >= k ) ; }
int pay ( int n ) { int cuts = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; return cuts ; }
void sieve ( int n ) { for ( int i = 2 ; i <= n ; ++ i ) { if ( min_prime [ i ] > 0 ) { continue ; } min_prime [ i ] = i ; max_prime [ i ] = i ; int j = i + i ; while ( j <= n ) { if ( min_prime [ j ] == 0 ) { min_prime [ j ] = i ; } max_prime [ j ] = i ; j += i ; } } }
int pairCount ( int n , int m ) { int cnt = 0 , b , a ; for ( b = 0 ; b <= Math . Sqrt ( m ) ; b ++ ) { a = m - b * b ; if ( a * a + b == n ) { cnt ++ ; } } return cnt ; }
void Calc_Max_Div ( int [ ] arr , int n ) { int [ ] vis = new int [ maxin + 1 ] ; for ( int i = 0 ; i < maxin + 1 ; i ++ ) vis [ i ] = 1 ; vis [ 0 ] = vis [ 1 ] = 0 ; for ( int i = 1 ; i <= maxin ; i ++ ) divisors [ i ] = i ; for ( int i = 4 ; i <= maxin ; i += 2 ) { vis [ i ] = 0 ; divisors [ i ] = i / 2 ; } for ( int i = 3 ; i <= maxin ; i += 2 ) { if ( divisors [ i ] != i ) { divisors [ i ] = i / divisors [ i ] ; } if ( vis [ i ] == 1 ) { for ( int j = i * i ; j < maxin ; j += i ) { vis [ j ] = 0 ; if ( divisors [ j ] == j ) divisors [ j ] = i ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( divisors [ arr [ i ] ] == arr [ i ] ) Console . Write ( "-1 " ) ; else Console . Write ( divisors [ arr [ i ] ] + " " ) ; } }
int sumOfDigit ( int n , int b ) { int unitDigit , sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = n / b ; } return sum ; }
int nthDigit ( int a , int n , int b ) { for ( int i = 1 ; i < n ; i ++ ) a = a / b ; return a % b ; }
int countSum ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N == 1 ) { return R - L + 1 ; } if ( N > 1 ) { return ( N - 2 ) * ( R - L ) + 1 ; } return 0 ; }
int solve ( int [ ] arr , int n , int k ) { int minx = INT_MAX ; int i ; for ( i = 0 ; i < n ; i ++ ) { minx = Math . Min ( minx , arr [ i ] ) ; } int decrements = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - minx ) % k != 0 ) { return - 1 ; } else { decrements += ( ( arr [ i ] - minx ) / k ) ; } } return decrements ; }
int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int count_of_subarrays ( int N ) { int count = binomialCoeff ( 2 * N - 1 , N ) ; return count ; }
void distribution ( int n , int k , int l , int r , int S , int Sk ) { int [ ] a = new int [ n ] ; int len = k , temp , rem ; int diff = S - Sk ; for ( int i = 0 ; i < len ; i ++ ) { temp = Sk / k ; rem = Sk % k ; if ( temp + rem >= l && temp + rem <= r ) { a [ i ] = temp ; } else if ( temp + rem > r ) { a [ i ] = r ; } else if ( temp + rem < r ) { Console . Write ( "-1" ) ; return ; } Sk = Sk - a [ i ] ; k = k - 1 ; } if ( Sk > 0 ) { Console . Write ( "-1" ) ; return ; } if ( len != 0 ) { k = n - len ; for ( int i = len ; i < n ; i ++ ) { temp = diff / k ; rem = diff % k ; if ( temp + rem >= l && temp + rem <= r ) { a [ i ] = temp ; } else if ( temp + rem > r ) { a [ i ] = r ; } else if ( temp + rem < r ) { Console . Write ( "-1" ) ; return ; } diff = diff - a [ i ] ; k = k - 1 ; } if ( diff != 0 ) { Console . Write ( "-1" ) ; return ; } } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( a [ i ] + " " ) ; } }
int countDigit ( int n ) { int c = 0 ; while ( n != 0 ) { int r = n % 10 ; c ++ ; n /= 10 ; } return c ; }
int min_index ( int [ ] p , int n ) { int ans = 0 ; int mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] <= mini ) mini = p [ i ] ; if ( mini == p [ i ] ) ans ++ ; } return ans ; }
void equal_xor_sum ( int [ ] arr , int n ) { int Sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum == Xor ) Console . WriteLine ( "YES" ) ; else Console . WriteLine ( "NO" ) ; }
int Count_subarray ( int [ ] arr , int n ) { int subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { subarray_sum = 0 ; remaining_sum = 0 ; for ( int k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; } for ( int l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( int l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; } if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; }
int set_bits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n % 2 ; n /= 2 ; } return count ; }
int minSteps ( int n ) { int ans = 0 ; while ( n != 1 ) { if ( n % 2 == 0 ) n /= 2 ; else if ( n == 3 || set_bits ( n - 1 ) < set_bits ( n + 1 ) ) n -- ; else n ++ ; ans ++ ; } return ans ; }
int minimumNo ( int n ) { int ans = 0 ; Stack < int > stack1 = new Stack < int > ( ) ; Stack < int > stack2 = new Stack < int > ( ) ; while ( n != 0 ) { int r = n % 10 ; if ( r % 2 == 0 ) { stack1 . Push ( r ) ; } else { stack2 . Push ( r ) ; } n = n / 10 ; } while ( stack1 . Count != 0 && stack2 . Count != 0 ) { if ( stack1 . Peek ( ) < stack2 . Peek ( ) ) { ans = ans * 10 + stack1 . Peek ( ) ; stack1 . Pop ( ) ; } else { ans = ans * 10 + stack2 . Peek ( ) ; stack2 . Pop ( ) ; } } while ( stack1 . Count != 0 ) { ans = ans * 10 + stack1 . Peek ( ) ; stack1 . Pop ( ) ; } while ( stack2 . Count != 0 ) { ans = ans * 10 + stack2 . Peek ( ) ; stack2 . Pop ( ) ; } return ans ; }
void findNums ( int x ) { int ans = - 1 ; for ( int i = 1 ; i <= Math . Sqrt ( x ) ; i ++ ) { if ( x % i == 0 && lcm ( i , x / i ) == x ) { ans = i ; } } Console . Write ( ans + " " + ( x / ans ) ) ; }
int maxCommonElement ( int [ ] A , int [ ] D , int N ) { int [ ] cnt = new int [ MAXN ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = A [ i ] ; j < MAXN ; j += D [ i ] ) cnt [ j ] ++ ; } int ans = 0 ; int com = 0 ; for ( int i = 0 ; i < MAXN ; i ++ ) { if ( cnt [ i ] > ans ) { ans = cnt [ i ] ; com = i ; } } return com ; }
int findTrailingZeros ( int n ) { if ( ( n & 1 ) == 1 ) return 0 ; else { int ans = 0 ; n /= 2 ; while ( n != 0 ) { ans += n / 5 ; n /= 5 ; } return ans ; } }
int maxGCD ( int N , int K ) { int minSum = ( K * ( K + 1 ) ) / 2 ; if ( N < minSum ) return - 1 ; int i = ( int ) Math . Sqrt ( N ) ; int res = 1 ; while ( i >= 1 ) { if ( N % i == 0 ) { if ( i >= minSum ) res = Math . Max ( res , N / i ) ; if ( N / i >= minSum ) res = Math . Max ( res , i ) ; } i -- ; } return res ; }
int findNumberOfEvenCells ( int n , int [ , ] q , int size ) { int [ ] row = new int [ n ] ; int [ ] col = new int [ n ] ; for ( int i = 0 ; i < size ; i ++ ) { int x = q [ i , 0 ] ; int y = q [ i , 1 ] ; row [ x - 1 ] ++ ; col [ y - 1 ] ++ ; } int r1 = 0 , r2 = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( row [ i ] % 2 == 0 ) { r1 ++ ; } if ( row [ i ] % 2 == 1 ) { r2 ++ ; } if ( col [ i ] % 2 == 0 ) { c1 ++ ; } if ( col [ i ] % 2 == 1 ) { c2 ++ ; } } int count = r1 * c1 + r2 * c2 ; return count ; }
int fastmod ( int baseval , int exp , int mod ) { if ( exp == 0 ) return 1 ; else if ( exp % 2 == 0 ) { int ans = fastmod ( baseval , exp / 2 , mod ) ; return ( ans % mod * ans % mod ) % mod ; } else return ( fastmod ( baseval , exp - 1 , mod ) % mod * baseval % mod ) % mod ; }
int findPowerSum ( int n , int [ ] ar ) { int mod = ( int ) 1e9 + 7 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int baseval = countSetBits ( ar [ i ] ) ; int exp = ar [ i ] ; sum += fastmod ( baseval , exp , mod ) ; sum %= mod ; } return sum ; }
int maxHeight ( int h1 , int h2 ) { return ( ( h1 * h2 ) - h1 - h2 ) ; }
double area ( double a , double b , double c ) { double p = ( a + b + c ) / 2 ; return Math . Sqrt ( p ) * Math . Sqrt ( p - a ) * Math . Sqrt ( p - b ) * Math . Sqrt ( p - c ) ; }
double binary_search ( ) { double s = area ( r1 + r2 , r2 + r3 , r3 + r1 ) ; double l = 0 , h = s / ( r1 + r2 + r3 ) ; while ( h - l > 0.00000001 ) { double mid = ( l + h ) / 2 ; double s1 = area ( mid + r1 , mid + r2 , r1 + r2 ) ; double s2 = area ( mid + r1 , mid + r3 , r1 + r3 ) ; double s3 = area ( mid + r2 , mid + r3 , r2 + r3 ) ; if ( s1 + s2 + s3 < s ) { l = mid ; } else { h = mid ; } } return ( l + h ) / 2 ; }
bool subArray ( int [ ] arr , int n , int m ) { int i ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( i = 0 ; i < n ; i ++ ) { mp . Add ( arr [ i ] , i + 1 ) ; } int sumcur = 0 ; int p = int . MaxValue ; List < int > ans = new List < int > ( ) ; for ( i = 1 ; i <= m ; i ++ ) { sumcur += mp [ i ] ; p = Math . Min ( p , mp [ i ] ) ; int val = p * i - i + ( i * ( i + 1 ) ) / 2 ; if ( i == m ) { if ( val == sumcur ) { return true ; } else return false ; } } return false ; }
bool isPalindrome ( string s ) { int left = 0 , right = s . Length - 1 ; while ( left <= right ) { if ( s [ left ] != s [ right ] ) { return false ; } left ++ ; right -- ; } return true ; }
int cntSubSeq ( int [ ] arr , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = ( int ) Math . Pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= ( int ) Math . Pow ( 2 , neg_count - 1 ) ; result -= 1 ; return result ; }
void FermatFactors ( int n ) { if ( n <= 0 ) { Console . Write ( "[" + n + "]" ) ; return ; } if ( ( n & 1 ) == 0 ) { Console . Write ( "[" + n / 2.0 + "," + 2 + "]" ) ; return ; } int a = ( int ) Math . Ceiling ( Math . Sqrt ( n ) ) ; if ( a * a == n ) { Console . Write ( "[" + a + "," + a + "]" ) ; return ; } int b ; while ( true ) { int b1 = a * a - n ; b = ( int ) ( Math . Sqrt ( b1 ) ) ; if ( b * b == b1 ) break ; else a += 1 ; } Console . Write ( "[" + ( a - b ) + "," + ( a + b ) + "]" ) ; return ; }
void findNums ( int [ ] arr , int n ) { int S = 0 , X = 0 ; for ( int i = 0 ; i < n ; i ++ ) { S += arr [ i ] ; X ^= arr [ i ] ; } Console . WriteLine ( X + " " + ( X + S ) ) ; }
void decBinary ( int [ ] arr , int n ) { int k = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } }
int binaryDec ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }
int getNum ( int n , int k ) { int l = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; int [ ] a = new int [ l ] ; decBinary ( a , n ) ; if ( k > l ) return n ; a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ; return binaryDec ( a , l ) ; }
void solve ( int A , int B ) { double p = B / 2.0 ; double M = Math . Ceiling ( 4 * p ) ; int N = 1 ; int O = - 2 * A ; double Q = Math . Ceiling ( A * A + 4 * p * p ) ; Console . Write ( M + " " + N + " " + O + " " + Q ) ; }
int findMin ( int [ ] arr , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) m = Math . Max ( m , arr [ i ] ) ; int [ ] freq = new int [ m + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( int i = 1 ; i <= m + 1 ; i ++ ) { int j = i ; int cnt = 0 ; while ( j <= m ) { cnt += freq [ j ] ; j += i ; } if ( cnt == 0 ) return i ; } return m + 1 ; }
int findMin ( int [ ] arr , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) m = Math . Max ( m , arr [ i ] ) ; int [ ] cnt = new int [ m + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j * j <= arr [ i ] ; j ++ ) { if ( arr [ i ] % j == 0 ) { if ( j * j == arr [ i ] ) cnt [ j ] ++ ; else { cnt [ j ] ++ ; cnt [ arr [ i ] / j ] ++ ; } } } } for ( int i = 1 ; i <= m + 1 ; i ++ ) if ( cnt [ i ] == 0 ) { return i ; } return - 1 ; }
void find_composite_nos ( int n ) { Console . WriteLine ( 9 * n + " " + 8 * n ) ; }
int maxXOR ( int [ ] arr , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . Max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; }
int findLargest ( int [ ] arr , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( arr [ i ] , gcd ) ; return gcd ; }
void sieve ( ) { for ( int i = 0 ; i < sz + 1 ; i ++ ) isPrime [ i ] = true ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
void removePrimes ( int [ ] arr , int len ) { sieve ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( isPrime [ arr [ i ] ] ) { for ( int j = i ; j < len - 1 ; j ++ ) { arr [ j ] = arr [ j + 1 ] ; } i -- ; len -- ; } } printArray ( arr , len ) ; }
int minOR ( int [ ] arr , int n ) { if ( n == 1 ) return 0 ; int [ ] pre = new int [ n ] ; int [ ] suf = new int [ n ] ; pre [ 0 ] = arr [ 0 ] ; suf [ n - 1 ] = arr [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; int ans = Math . Min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) ans = Math . Min ( ans , ( pre [ i - 1 ] suf [ + 1 ] ) ) ; return ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; int n = . ; . ( minOR ( arr , n ) ) ; }
int subgrids ( int N , int Z , int [ ] row , int [ ] col , int r , int d ) { List < int > conrow = new List < int > ( ) ; List < int > concol = new List < int > ( ) ; int K = ( int ) Math . Sqrt ( Z ) ; conrow . Add ( row [ 0 ] - 0 - 1 ) ; conrow . Add ( N + 1 - row [ r - 1 ] - 1 ) ; for ( int i = 1 ; i < r ; i ++ ) { conrow . Add ( row [ i ] - row [ i - 1 ] - 1 ) ; } concol . Add ( col [ 0 ] - 0 - 1 ) ; concol . Add ( N + 1 - col [ d - 1 ] - 1 ) ; for ( int i = 1 ; i < d ; i ++ ) { concol . Add ( col [ i ] - col [ i - 1 ] - 1 ) ; } int row_size = conrow . Count ; int col_size = concol . Count ; int answer = 0 ; for ( int i = 0 ; i < row_size ; i ++ ) { for ( int j = 0 ; j < col_size ; j ++ ) { int total = ( concol [ j ] / K ) * ( conrow [ i ] / K ) ; answer += ( total ) ; } } return answer ; }
int sub_arrays ( int [ ] a , int n , int k ) { int [ ] sum = new int [ n + 2 ] ; for ( int i = 0 ; i < n + 2 ; i ++ ) { sum [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { a [ i ] -- ; a [ i ] %= k ; sum [ i + 1 ] += sum [ i ] + a [ i ] ; sum [ i + 1 ] %= k ; } int ans = 0 , l = 0 , r = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { if ( ! mp . ContainsKey ( sum [ i ] ) ) mp . Add ( sum [ i ] , 0 ) ; } int temp ; for ( int i = 0 ; i < n + 1 ; i ++ ) { ans += ( int ) mp [ sum [ i ] ] ; temp = ( int ) mp [ sum [ i ] ] + 1 ; mp [ sum [ i ] ] = temp ; r ++ ; if ( r - l >= k ) { temp = ( int ) mp [ sum [ l ] ] - 1 ; mp [ sum [ i ] ] = temp ; l ++ ; } } return ans ; }
int findCount ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( digitDividesK ( i , k ) ) count ++ ; } return count ; }
int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } return sum ; }
bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
bool isDigitSumPalindrome ( int n ) { int sum = digitSum ( n ) ; if ( isPalindrome ( sum ) ) return true ; return false ; }
int countDigits ( int n ) { int cnt = 0 ; while ( n > 0 ) { cnt ++ ; n /= 10 ; } return cnt ; }
int digitPowSum ( int n ) { int sum = 0 ; int pw = countDigits ( n ) ; while ( n > 0 ) { int d = n % 10 ; sum += ( int ) Math . Pow ( d , pw ) ; pw -- ; n /= 10 ; } return sum ; }
int countNum ( int n ) { int count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == digitPowSum ( i ) ) count ++ ; } return count ; }
void perfectSquares ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { if ( Math . Sqrt ( i ) == ( int ) Math . Sqrt ( i ) ) Console . Write ( i + " " ) ; } }
void perfectSquares ( float l , float r ) { int number = ( int ) Math . Ceiling ( Math . Sqrt ( l ) ) ; int n2 = number * number ; number = ( number * 2 ) + 1 ; while ( ( n2 >= l && n2 <= r ) ) { Console . Write ( n2 + " " ) ; n2 = n2 + number ; number += 2 ; } }
int xorK ( int n , int k ) { if ( k % 2 == 1 ) return n ; return 0 ; }
void findRemainders ( long n ) { List < long > vc = new List < long > ( ) ; for ( long i = 1 ; i <= Math . Ceiling ( Math . Sqrt ( n ) ) ; i ++ ) vc . Add ( n / i ) ; for ( long i = ( long ) ( n / Math . Ceiling ( Math . Sqrt ( n ) ) - 1 ) ; i >= 0 ; i -- ) vc . Add ( i ) ; vc . Reverse ( ) ; foreach ( long it in vc ) Console . Write ( it + " " ) ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } }
int countPrimes ( int n ) { SieveOfEratosthenes ( ) ; int cnt = 0 ; for ( int i = 2 ; i < n ; i ++ ) { if ( prime [ i ] && prime [ i - 2 ] ) cnt ++ ; } return cnt ; }
int power ( int a , int m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( a * a ) % mod ; else if ( ( m1 & 1 ) != 0 ) return ( a * power ( power ( a , m1 / 2 ) , 2 ) ) % mod ; else return power ( power ( a , m1 / 2 ) , 2 ) % mod ; }
void factorialfun ( ) { factorial [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) factorial [ i ] = ( factorial [ i - 1 ] * i ) % mod ; }
void modinversefun ( ) { modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod ; for ( int i = N - 2 ; i >= 0 ; i -- ) modinverse [ i ] = ( modinverse [ i + 1 ] * ( i + 1 ) ) % mod ; }
int binomial ( int n , int r ) { if ( r > n ) return 0 ; int a = ( factorial [ n ] * modinverse [ n - r ] ) % mod ; a = ( a * modinverse [ r ] ) % mod ; return a ; }
int arrange ( int n , int m , int k ) { factorialfun ( ) ; modinversefun ( ) ; int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) ans += ( i * ( n - i ) * m * m ) % mod ; ans = 8 ; for ( int i = 1 ; i < m ; i ++ ) ans += ( i * ( m - i ) * n * n ) % mod ; ans = ( ans * binomial ( n * m - 2 , k - 2 ) ) % mod + 8 ; return ans ; }
int findK ( int l , int r ) { int maxExp = int . MinValue ; int k = - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( distinctDigits ( i ) ) { int exp = ( l - i ) * ( i - r ) ; if ( exp >= maxExp ) { k = i ; maxExp = exp ; } } } return k ; }
void findWinner ( int n ) { if ( ( n - 1 ) % 6 == 0 ) { Console . WriteLine ( "Second Player wins the game" ) ; } else { Console . WriteLine ( "First Player wins the game" ) ; } }
int countIndices ( int [ ] arr , int n ) { int cnt = 0 ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; }
int min_changes ( int [ ] a , int n ) { int ans_a = 0 , ans_b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( a [ i ] == 0 ) ans_a ++ ; else ans_b ++ ; } else { if ( a [ i ] == 0 ) ans_b ++ ; else ans_a ++ ; } } return Math . Min ( ans_a , ans_b ) ; }
void ans ( int n ) { if ( n == 1 ) Console . WriteLine ( "1" ) ; else Console . WriteLine ( "0" ) ; }
void sieve ( Boolean [ ] prime , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } }
int sumPrime ( int d ) { int maxVal = ( int ) ( Math . Pow ( 2 , d ) - 1 ) ; Boolean [ ] prime = new Boolean [ maxVal + 1 ] ; for ( int i = 0 ; i <= maxVal ; i ++ ) prime . SetValue ( true , i ) ; sieve ( prime , maxVal ) ; int sum = 0 ; for ( int i = 2 ; i <= maxVal ; i ++ ) { if ( prime [ i ] ) { sum += i ; } } return sum ; }
bool isPossible ( int w , int h , int x , int y ) { if ( x * 2 == w && y * 2 == h ) return true ; return false ; }
int findNthDigit ( int p , int q , int N ) { int res = 0 ; while ( N > 0 ) { N -- ; p *= 10 ; res = p / q ; p %= q ; } return res ; }
int minsteps ( int n , int m ) { if ( m > n ) { return - 1 ; } else { return ( ( n + 1 ) / 2 + m - 1 ) / m * m ; } }
int compare ( Node a , Node b ) { a = removeLeadingZeros ( a ) ; b = removeLeadingZeros ( b ) ; int lenA = getSize ( a ) ; int lenB = getSize ( b ) ; if ( lenA > lenB ) { return 1 ; } else if ( lenB > lenA ) { return - 1 ; } while ( a != null && b != null ) { if ( a . data > b . data ) return 1 ; else if ( a . data < b . data ) return - 1 ; a = a . next ; b = b . next ; } return 0 ; }
long power ( long a , long m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( a * a ) % mod ; else if ( ( m1 & 1 ) != 0 ) return ( a * power ( power ( a , m1 / 2 ) , 2 ) ) % mod ; else return power ( power ( a , m1 / 2 ) , 2 ) % mod ; }
void factorialfun ( ) { factorial [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) factorial [ i ] = ( factorial [ i - 1 ] * i ) % mod ; }
void modinversefun ( ) { modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod ; for ( int i = N - 2 ; i >= 0 ; i -- ) modinverse [ i ] = ( modinverse [ i + 1 ] * ( i + 1 ) ) % mod ; }
long binomial ( int n , int r ) { if ( r > n ) return 0 ; long a = ( factorial [ n ] * modinverse [ n - r ] ) % mod ; a = ( a * modinverse [ r ] ) % mod ; return a ; }
int maxFreq ( String s ) { String binary = "" ; for ( int K = 0 ; K < s . Length ; K ++ ) { binary += bin [ s [ K ] - '0' ] ; } binary = binary . Substring ( 0 , binary . Length - 1 ) ; int count = 1 , prev = - 1 , i , j = 0 ; for ( i = binary . Length - 1 ; i >= 0 ; i -- , j ++ ) if ( binary [ i ] == '1' ) { count = Math . Max ( count , j - prev ) ; prev = j ; } return count ; }
int sumArr ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
int sumModArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { int subSum = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { subSum += arr [ j ] ; } arr [ i ] -= subSum ; } return sumArr ( arr , n ) ; }
int sumArr ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
int sumModArr ( int [ ] arr , int n ) { int subSum = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int curr = arr [ i ] ; arr [ i ] -= subSum ; subSum += curr ; } return sumArr ( arr , n ) ; }
int lcm ( int a , int b ) { int GCD = __gcd ( a , b ) ; return ( a * b ) / GCD ; }
int MinLCM ( int [ ] a , int n ) { int [ ] Prefix = new int [ n + 2 ] ; int [ ] Suffix = new int [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = Math . Min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . Min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; }
long findNum ( long x ) { for ( int i = 0 ; i < NumUnsignBits - 1 ; i ++ ) { if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) { x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) ; return x ; } } return long . MinValue ; }
int minHealth ( int [ ] health , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { gcd = __gcd ( gcd , health [ i ] ) ; } return gcd ; }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void constructArr ( int [ ] pair , int n ) { int size = ( 1 + ( int ) Math . Sqrt ( 1 + 8 * n ) ) / 2 ; int [ ] arr = new int [ size ] ; arr [ 0 ] = ( int ) Math . Sqrt ( ( pair [ 0 ] * pair [ 1 ] ) / pair [ size - 1 ] ) ; for ( int i = 1 ; i < size ; i ++ ) arr [ i ] = pair [ i - 1 ] / arr [ 0 ] ; printArr ( arr , size ) ; }
int countWays ( int n , int m ) { return factMod ( m ) ; }
int Fuss_catalan ( int n ) { int c = binomialCoeff ( 3 * n , n ) ; return c / ( 2 * n + 1 ) ; }
bool isComposite ( int n ) { for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return true ; } return false ; }
int Power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
void sieve ( ) { for ( int i = 2 ; i < sz + 1 ; i ++ ) isPrime [ i ] = true ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
int findCnt ( int [ ] arr , int n , int k ) { int ret = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; int x = Math . Max ( 0 , j - i - k + 1 ) ; ret += ( x * ( x + 1 ) ) / 2 ; i = j ; } return ret ; }
bool isHeap ( int [ ] arr , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) { return false ; } if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) { return false ; } } return true ; }
int reverse ( int num ) { int rev = 0 ; while ( num > 0 ) { rev = rev * 10 + num % 10 ; num = num / 10 ; } return rev ; }
bool isPalindrome ( int num ) { if ( num == reverse ( num ) ) return true ; return false ; }
void printPalindromes ( int d ) { if ( d <= 0 ) return ; int smallest = ( int ) Math . Pow ( 10 , d - 1 ) ; int largest = ( int ) Math . Pow ( 10 , d ) - 1 ; for ( int i = smallest ; i <= largest ; i ++ ) { if ( isPalindrome ( i ) ) Console . Write ( i + " " ) ; } }
int countElements ( int [ ] p , int n ) { int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( p [ i - 1 ] > p [ i ] && p [ i ] > p [ i + 1 ] ) ans ++ ; else if ( p [ i - 1 ] < p [ i ] && p [ i ] < p [ i + 1 ] ) ans ++ ; } return ans ; }
int countNums ( int a , int b , int c , int d ) { int x = b / c - ( a - 1 ) / c ; int y = b / d - ( a - 1 ) / d ; int k = ( c * d ) / __gcd ( c , d ) ; int z = b / k - ( a - 1 ) / k ; return b - a + 1 - x - y + z ; }
int cntSubArrays ( int [ ] arr , int n , int k ) { int res = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; res += Math . Max ( j - i - k + 1 , 0 ) ; i = j ; } return res ; }
int maxLen ( int [ ] arr , int n ) { int min_val = arr . Min ( ) ; int freq = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == min_val ) freq ++ ; } return freq ; }
void print_primes_till_N ( int N ) { int i , j , flag ; Console . Write ( "Prime numbers between 1 and " + N + " are:\n" ) ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) Console . Write ( i + " " ) ; } }
void last_digit ( int X , int Y ) { Console . Write ( X % Y ) ; }
void sieve ( ) { for ( int i = 0 ; i <= sz ; i ++ ) isPrime [ i ] = true ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
void findPrimesD ( int d ) { int left = ( int ) Math . Pow ( 10 , d - 1 ) ; int right = ( int ) Math . Pow ( 10 , d ) - 1 ; for ( int i = left ; i <= right ; i ++ ) { if ( isPrime [ i ] ) { Console . Write ( i + " " ) ; } } }
int geometricMean ( int n ) { return ( int ) Math . Sqrt ( n ) ; }
int two_sets ( int [ ] a , int n ) { Array . Sort ( a ) ; return a [ n / 2 ] - a [ ( n / 2 ) - 1 ] ; }
int min_moves ( int n ) { int ans = int . MaxValue ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { ans = Math . Min ( ans , i + n / i - 2 ) ; } } return ans ; }
int findX ( int A , int B ) { int X = 0 ; for ( int bit = 0 ; bit < MAX ; bit ++ ) { int tempBit = 1 << bit ; int bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; }
int cntPairs ( int [ ] a , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } int ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
int min_modulo ( int l , int r ) { if ( r - l >= MOD ) return 0 ; else { int ans = MOD - 1 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { ans = Math . Min ( ans , ( i * j ) % MOD ) ; } } return ans ; } }
int kthNum ( int n , int k ) { int a = ( n + 1 ) / 2 ; if ( k > a ) return ( 2 * ( k - a ) ) ; return ( 2 * k - 1 ) ; }
void find_numbers ( int N ) { if ( N == 1 ) { Console . Write ( - 1 ) ; } else { Console . Write ( N + " " + ( N + 1 ) + " " + ( N * ( N + 1 ) ) ) ; } }
void findNum ( int [ ] a , int n , int [ ] b , int m ) { int x = max_element ( a , n ) ; int y = max_element ( b , m ) ; Console . Write ( x + " " + y ) ; }
int find_k ( int a , int b ) { if ( ( a + b ) % 2 == 0 ) return ( ( a + b ) / 2 ) ; return - 1 ; }
int odd_digits ( int n ) { if ( n < 10 ) return n ; else if ( n / 10 < 10 ) return 9 ; else if ( n / 100 < 10 ) return 9 + n - 99 ; else if ( n / 1000 < 10 ) return 9 + 900 ; else if ( n / 10000 < 10 ) return 909 + n - 9999 ; else return 90909 ; }
int nDigitPalindromes ( int n ) { return ( 9 * ( int ) Math . Pow ( 10 , ( n - 1 ) / 2 ) ) ; }
int maxLCM ( int n ) { return ( n * ( n - 1 ) ) ; }
int cntSubSets ( int [ ] arr , int n ) { int maxVal = arr . Max ( ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( int ) ( Math . Pow ( 2 , cnt ) - 1 ) ; }
int getSum ( int n ) { return ( ( n - 1 ) + ( int ) Math . Pow ( n , 2 ) ) ; }
int cntEdges ( int n ) { int edges = ( int ) Math . Pow ( 2 , n ) - 2 ; return edges ; }
int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; }
int findSum ( int n ) { return ( int ) Math . Pow ( n , 3 ) ; }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void generateArr ( int [ ] arr , int n ) { bool flip = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) { if ( flip ^= true ) Console . Write ( ( int ) ( Math . Ceiling ( arr [ i ] / 2.0 ) ) + " " ) ; else Console . Write ( ( int ) ( Math . Floor ( arr [ i ] / 2.0 ) ) + " " ) ; } else { Console . Write ( arr [ i ] / 2 + " " ) ; } } }
int count ( int n ) { return ( int ) ( 15 * Math . Pow ( 16 , n - 1 ) ) ; }
int nth_term ( int a , int b , int n ) { int z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; }
int cntSubSeq ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int num = arr [ k - 1 ] ; int Y = 0 ; for ( int i = k - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == num ) Y ++ ; } int cntX = Y ; for ( int i = k ; i < n ; i ++ ) { if ( arr [ i ] == num ) cntX ++ ; } return binomialCoeff ( cntX , Y ) ; }
bool inProportion ( int [ ] arr ) { int n = 4 ; Array . Sort ( arr ) ; long extremes = ( long ) arr [ 0 ] * ( long ) arr [ 3 ] ; long means = ( long ) arr [ 1 ] * ( long ) arr [ 2 ] ; if ( extremes == means ) return true ; return false ; }
float findProb ( int [ ] arr , int n ) { long maxSum = int . MinValue , maxCount = 0 , totalPairs = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( sum == maxSum ) { maxCount ++ ; } else if ( sum > maxSum ) { maxSum = sum ; maxCount = 1 ; } totalPairs ++ ; } } float prob = ( float ) maxCount / ( float ) totalPairs ; return prob ; }
int findMissing ( int [ ] arr , int n , int k , int avg ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int num = ( avg * ( n + k ) ) - sum ; int den = k ; if ( num % den != 0 ) return - 1 ; return ( int ) ( num / den ) ; }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
int countNum ( int n ) { if ( n > 10 ) return 0 ; return ( 9 * factorial ( 9 ) / factorial ( 10 - n ) ) ; }
int binomialCoeff ( int n , int k ) { int [ , ] C = new int [ n + 1 , k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } return C [ n , k ] ; }
int findMax ( int n ) { return binomialCoeff ( n , n / 2 ) ; }
int count ( int n ) { return ( - 1 + ( int ) Math . Sqrt ( 1 + 8 * n ) ) / 2 ; }
void findEquation ( int a , int b ) { int sum = ( a + b ) ; int product = ( a * b ) ; Console . WriteLine ( "x^2 - (" + sum + "x) + (" + product + ") = 0" ) ; }
int cal ( int n ) { double res = Math . Pow ( Math . Ceiling ( ( Math . Pow ( Math . Pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 ) ; return ( int ) res ; }
int count ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
long binomialCoeff ( long n , long k ) { if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
long fact ( long n ) { if ( n >= 1 ) return n * fact ( n - 1 ) ; else return 1 ; }
bool isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) { return true ; } return false ; }
long countWords ( String s , int p , int q ) { long countc = 0 , countv = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( isVowel ( s [ i ] ) ) countv ++ ; else countc ++ ; } long a = binomialCoeff ( countc , p ) ; long b = binomialCoeff ( countv , q ) ; long c = fact ( p + q ) ; long ans = ( a * b ) * c ; return ans ; }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void generateArr ( int [ ] A , int n ) { int [ ] B = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j ] % A [ i ] == 0 ) cnt ++ ; } B [ i ] = cnt ; } printArr ( B , n ) ; }
int count ( int n ) { return ( int ) Math . Pow ( 2 , n - 1 ) ; }
long nextFibonacci ( int n ) { double a = n * ( 1 + Math . Sqrt ( 5 ) ) / 2.0 ; return ( long ) Math . Round ( a ) ; }
int product ( int [ ] a , int n ) { int ans = 1 ; int val = ( int ) Math . Pow ( 2 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { ans *= ( int ) Math . Pow ( a [ i ] , val ) ; } return ans ; }
int max_distinct_char ( String str , int n ) { int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ str [ i ] ] ++ ; } int max_distinct = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] != 0 ) { max_distinct ++ ; } } return max_distinct ; }
int smallesteSubstr_maxDistictChar ( String str ) { int n = str . Length ; int max_distinct = max_distinct_char ( str , n ) ; int minl = n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { String subs = null ; if ( i < j ) subs = str . Substring ( i , str . Length - j ) ; else subs = str . Substring ( j , str . Length - i ) ; int subs_lenght = subs . Length ; int sub_distinct_char = max_distinct_char ( subs , subs_lenght ) ; if ( subs_lenght < minl && max_distinct == sub_distinct_char ) { minl = subs_lenght ; } } } return minl ; }
void findPair ( int [ ] arr , int n ) { if ( n < 2 ) { Console . Write ( "-1" ) ; return ; } int i , first , second ; first = second = - 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { second = arr [ i ] ; } } Console . WriteLine ( "n = " + first + " and r = " + second ) ; }
int sum ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * ( int ) Math . Pow ( 2 , n - 1 ) ; return sum ; }
int maxHeight ( int n ) { return ( ( ( int ) Math . Sqrt ( 1 + 8.0 * n ) ) - 1 ) / 2 ; }
int ways ( int n ) { return n / 2 ; }
int prevPowerof2 ( int n ) { int p = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; return ( int ) Math . Pow ( 2 , p ) ; }
int nextPowerOf2 ( int n ) { int p = 1 ; if ( ( n == 0 ) && ! ( ( n & ( n - 1 ) ) == 0 ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
int minDiff ( int n ) { int low = prevPowerof2 ( n ) ; int high = nextPowerOf2 ( n ) ; return Math . Min ( n - low , high - n ) ; }
bool isPossible ( int x , int y , int k ) { int minMoves = Math . Abs ( x ) + Math . Abs ( y ) ; if ( k >= minMoves && ( k - minMoves ) % 2 == 0 ) return true ; return false ; }
int countPairs ( int [ ] arr , int n ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] ++ ; int res = 0 ; foreach ( KeyValuePair < int , int > x in map ) { int cnt = x . Value ; res += ( ( cnt * ( cnt - 1 ) ) / 2 ) ; } return res ; }
int findMinValue ( int [ ] arr , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( int ) ( sum / n ) + 1 ) ; }
bool isFactorion ( int n ) { int [ ] fact = new int [ MAX ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int org = n ; int sum = 0 ; while ( n > 0 ) { int d = n % 10 ; sum += fact [ d ] ; n /= 10 ; } if ( sum == org ) return true ; return false ; }
int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; }
long minOperations ( long n ) { long count = 0 ; long d = 0 ; if ( n == 1 ) return 0 ; while ( n > 9 ) { d = Math . Max ( n % 10 , d ) ; n /= 10 ; count += 10 ; } d = Math . Max ( d , n - 1 ) ; count += Math . Abs ( d ) ; return count - 1 ; }
int maxCommonFactors ( int a , int b ) { int __gcd = gcd ( a , b ) ; int ans = 1 ; for ( int i = 2 ; i * i <= __gcd ; i ++ ) { if ( __gcd % i == 0 ) { ans ++ ; while ( __gcd % i == 0 ) __gcd /= i ; } } if ( __gcd != 1 ) ans ++ ; return ans ; }
void updateFreq ( int n , int [ ] freq ) { while ( n > 0 ) { int digit = n % TEN ; freq [ digit ] ++ ; n /= TEN ; } }
bool areAnagrams ( int a , int b ) { int [ ] freqA = new int [ TEN ] ; int [ ] freqB = new int [ TEN ] ; ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( int i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; }
int dayOfYear ( string date ) { int year = Int32 . Parse ( date . Substring ( 0 , 4 ) ) ; int month = Int32 . Parse ( date . Substring ( 5 , 2 ) ) ; int day = Int32 . Parse ( date . Substring ( 8 ) ) ; if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 year % 400 == 0 ) ) { ++ day ; } while ( -- month > 0 ) { day = day + days [ month - 1 ] ; } return day ; }
int Max_Sum ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
void convertToBinary ( int num , int [ ] a , int n ) { int pointer = n - 1 ; while ( num > 0 ) { a [ pointer ] = num % 2 ; num = num / 2 ; pointer -- ; } }
void print_seq ( int m ) { int n = ( 2 * m ) ; int [ ] a = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { a [ j ] = 0 ; } for ( int i = 0 ; i < ( int ) Math . Pow ( 2 , n ) ; i ++ ) { convertToBinary ( i , a , n ) ; checkforsum ( a , n ) ; } }
bool isDivisible ( int [ ] arr , int n ) { int lastDigit = arr [ n - 1 ] % 10 ; if ( lastDigit == 0 ) return true ; return false ; }
int solve ( int ang , int n ) { if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) { return 0 ; } else if ( ( ang * n ) % 180 != 0 ) { return 0 ; } int ans = 1 ; int freq = ( ang * n ) / 180 ; ans = ans * ( n - 1 - freq ) ; ans = ans * n ; return ans ; }
void preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } }
bool prime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
void thirdNumber ( int a , int b ) { int sum = 0 , temp = 0 ; sum = a + b ; temp = 1 ; if ( sum == 0 ) { temp = 2 ; } while ( ! prime ( sum + temp ) ) { temp += 2 ; } Console . Write ( temp ) ; }
long gcd ( long a , long b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; }
long divTermCount ( long a , long b , long c , long num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; }
long findNthTerm ( int a , int b , int c , long n ) { long low = 1 , high = long . MaxValue , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , c , mid ) < n ) { low = mid + 1 ; } else { high = mid ; } } return low ; }
int nCr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
long divTermCount ( long a , long b , long c , long num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; }
double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; }
void getIndex ( int n , int [ , ] shuffle ) { for ( int i = 0 ; i < 3 ; i ++ ) { if ( shuffle [ i , 0 ] == n ) n = shuffle [ i , 1 ] ; else if ( shuffle [ i , 1 ] == n ) n = shuffle [ i , 0 ] ; } Console . WriteLine ( n ) ; }
int calculate ( int n , int k , int m , int power ) { if ( n > m ) { if ( power == 0 ) return 0 ; else return power - 1 ; } else if ( n == m ) return power ; else return calculate ( n * k , k , m , power + 1 ) ; }
void printNumber ( int holes ) { if ( holes == 0 ) Console . Write ( "1" ) ; else if ( holes == 1 ) Console . Write ( "0" ) ; else { int rem = 0 , quo = 0 ; rem = holes % 2 ; quo = holes / 2 ; if ( rem == 1 ) Console . Write ( "4" ) ; for ( int i = 0 ; i < quo ; i ++ ) Console . Write ( "8" ) ; } }
long power ( int p ) { long res = 1 ; for ( int i = 1 ; i <= p ; ++ i ) { res *= 2 ; res %= mod ; } return res % mod ; }
long subset_square_sum ( int [ ] A ) { int n = A . Length ; long ans = 0 ; foreach ( int i in A ) { ans += ( 1 * i * i ) % mod ; ans %= mod ; } return ( 1 * ans * power ( n - 1 ) ) % mod ; }
long fact ( int n ) { long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
long nCr ( int n , int r ) { return fact ( n ) / ( 1 * fact ( r ) * fact ( n - r ) ) ; }
long number_of_subsequences ( int [ ] arr , int k , int n ) { long s = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { var val = mp [ arr [ i ] ] ; mp . Remove ( arr [ i ] ) ; mp . Add ( arr [ i ] , val + 1 ) ; } else { mp . Add ( arr [ i ] , 1 ) ; } } foreach ( KeyValuePair < int , int > j in mp ) { s = s + 1 * nCr ( j . Value , k ) ; } return s ; }
int minCost ( int [ ] arr , int n ) { int count_even = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return Math . Min ( count_even , count_odd ) ; }
bool coprime ( int a , int b ) { if ( __gcd ( a , b ) == 1 ) return true ; else return false ; }
void findNumbers ( int a , int b , int n ) { bool possible = true ; if ( ! coprime ( a , b ) ) possible = false ; int c1 = 1 ; int c2 = 1 ; int num1 , num2 ; HashSet < int > st = new HashSet < int > ( ) ; if ( possible ) { while ( st . Count != n ) { num1 = a + ( c1 * b ) ; if ( isPrime ( num1 ) ) { st . Add ( num1 ) ; } c1 ++ ; num2 = b + ( c2 * a ) ; if ( isPrime ( num2 ) ) { st . Add ( num2 ) ; } c2 ++ ; } foreach ( int i in st ) Console . Write ( i + " " ) ; } else Console . Write ( "-1" ) ; }
int sumPairs ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; }
int minSum ( int [ ] arr , int n ) { int sum = 0 ; Array . Sort ( arr ) ; Array . Reverse ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; }
long getCount ( int A , int B2 , int C ) { long count = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { long j = ( B2 / i ) + 1 ; if ( C >= j ) count = ( count + C - j + 1 ) ; if ( A >= j && C >= i ) count = ( count + ( C - i + 1 ) * ( A - j + 1 ) ) ; if ( A >= j ) A = ( int ) ( j - 1 ) ; } return count ; }
int negProdSubArr ( int [ ] arr , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
int posProdSubArr ( int [ ] arr , int n ) { int total = ( n * ( n + 1 ) ) / 2 ; int cntNeg = negProdSubArr ( arr , n ) ; return ( total - cntNeg ) ; }
int distinctRemainders ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) ; return ( 1 + ( n / 2 ) ) ; }
int countUnsetBits ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = i ; while ( temp > 0 ) { if ( temp % 2 == 0 ) cnt = cnt + 1 ; temp = temp / 2 ; } } return cnt ; }
void least_prime_factor ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( lpf [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) if ( lpf [ j ] == 0 ) lpf [ j ] = i ; }
void Mobius ( ) { for ( int i = 1 ; i < N ; i ++ ) { if ( i == 1 ) mobius [ i ] = 1 ; else { if ( lpf [ i / lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ; else mobius [ i ] = - 1 * mobius [ i / lpf [ i ] ] ; } } }
int gcd_pairs ( int [ ] a , int n ) { int maxi = 0 ; int [ ] fre = new int [ N ] ; for ( int i = 0 ; i < n ; i ++ ) { fre [ a [ i ] ] ++ ; maxi = Math . Max ( a [ i ] , maxi ) ; } least_prime_factor ( ) ; Mobius ( ) ; int ans = 0 ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( mobius [ i ] == 0 ) continue ; int temp = 0 ; for ( int j = i ; j <= maxi ; j += i ) temp += fre [ j ] ; ans += temp * ( temp - 1 ) / 2 * mobius [ i ] ; } return ans ; }
void SieveOfEratosthenes ( ) { int i ; for ( i = 0 ; i < MAX + 1 ; i ++ ) { prime [ i ] = true ; } prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
int xorFirstNPrime ( int n ) { int count = 0 , num = 1 ; int xorVal = 0 ; while ( count < n ) { if ( prime [ num ] ) { xorVal ^= num ; count ++ ; } num ++ ; } return xorVal ; }
int negProdSubArr ( int [ ] arr , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
int sum ( int n ) { int sum = ( n * ( n + 1 ) ) / 2 ; return sum ; }
int repeatedSum ( int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { n = sum ( n ) ; } return n ; }
bool isDivisible ( long n ) { long temp = n ; int sum = 0 ; while ( n != 0 ) { int digit = ( int ) n % 10 ; sum += digit ; n /= 10 ; } n = temp ; while ( n != 0 ) { int digit = ( int ) n % 10 ; if ( sum % digit != 0 ) return false ; n /= 10 ; } return true ; }
void least_prime_factor ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( lpf [ i ] % 2 != 1 ) for ( int j = i ; j < N ; j += i ) if ( lpf [ j ] % 2 != 0 ) lpf [ j ] = i ; }
void Mobius ( int n ) { int [ ] mobius = new int [ N ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( i == 1 ) mobius [ i ] = 1 ; else { if ( lpf [ i / lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ; else mobius [ i ] = - 1 * mobius [ i / lpf [ i ] ] ; } } for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( mobius [ i ] + " " ) ; }
int getBest ( int prev , int cur ) { int maximum = Math . Max ( MIN , prev ) ; for ( int i = maximum ; i <= MAX ; i ++ ) { int cnt = 0 ; int a = i ; int b = cur ; for ( int k = 0 ; k < DIGITS ; k ++ ) { if ( a % 10 != b % 10 ) cnt += 1 ; a /= 10 ; b /= 10 ; } if ( cnt <= 1 ) return i ; } return - 1 ; }
void getList ( int [ ] arr , int n ) { List < int > myList = new List < int > ( ) ; int i , cur ; bool possible = true ; myList . Add ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { cur = arr [ i ] ; myList . Add ( getBest ( myList [ myList . Count - 1 ] , cur ) ) ; if ( myList [ myList . Count - 1 ] == - 1 ) { possible = false ; break ; } } if ( possible ) { for ( i = 1 ; i < myList . Count ; i ++ ) Console . Write ( myList [ i ] + " " ) ; } else Console . Write ( "-1" ) ; }
int maxItems ( int x , int y , int z ) { int type1 = x / COST ; x %= COST ; int type2 = y / COST ; y %= COST ; int type3 = z / COST ; z %= COST ; int type4 = Math . Min ( x , Math . Min ( y , z ) ) ; int maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }
int countFactors ( int n , int p ) { int pwr = 0 ; while ( n > 0 && n % p == 0 ) { n /= p ; pwr ++ ; } return pwr ; }
int getCount ( int l , int r , int p ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { cnt += countFactors ( i , p ) ; } return cnt ; }
bool topsyTurvy ( char [ ] str ) { for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == '2' str [ i ] == '4' str [ i ] == '5' str [ i ] == '6' str [ i ] == '7' str [ i ] == '9' ) { return false ; } } return true ; }
int countSubSeq ( int [ ] arr , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { count ++ ; } } return ( int ) ( Math . Pow ( 2 , count ) - 1 ) ; }
int countNum ( int N , int K ) { int [ ] sumPF = new int [ MAX ] ; for ( int i = 2 ; i < N ; i ++ ) { if ( sumPF [ i ] == 0 ) { for ( int j = i ; j < N ; j += i ) { sumPF [ j ] += i ; } } } int count = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( sumPF [ i ] == K ) count ++ ; } return count ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX + 1 ; i ++ ) { prime [ i ] = true ; } for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
int smallestPrime ( int d ) { int l = ( int ) Math . Pow ( 10 , d - 1 ) ; int r = ( int ) Math . Pow ( 10 , d ) - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( prime [ i ] ) { return i ; } } return - 1 ; }
int largestPrime ( int d ) { int l = ( int ) Math . Pow ( 10 , d - 1 ) ; int r = ( int ) Math . Pow ( 10 , d ) - 1 ; for ( int i = r ; i >= l ; i -- ) { if ( prime [ i ] ) { return i ; } } return - 1 ; }
void findNumbers ( int a , int b ) { int gcd = findGCD ( a , b ) ; Console . Write ( ( a / gcd ) + " " + ( b / gcd ) ) ; }
bool possible ( int n ) { if ( n > 3 ) { int sum = ( n * ( n + 1 ) ) / 2 ; if ( sum % 3 == 0 ) { return true ; } } return false ; }
int findNthNumber ( int A , int B , int N ) { int sum = 0 ; for ( int i = 2 ; i < N ; i ++ ) { sum = A + B ; A = B ; B = sum ; } return sum ; }
long modulo ( String num ) { long res = 0 ; for ( int i = 0 ; i < num . Length ; i ++ ) res = ( res * 10 + ( long ) num [ i ] - '0' ) % mod ; return res ; }
long findSum ( String L , String R ) { long a , b , l , r , ret ; a = modulo ( L ) ; b = modulo ( R ) ; l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod ; r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod ; ret = ( r % mod - l % mod ) ; if ( ret < 0 ) ret = ret + mod ; else ret = ret % mod ; return ret ; }
void heapSort ( int [ ] arr , int n ) { for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int temp = arr [ 0 ] ; arr [ 0 ] = arr [ i ] ; arr [ i ] = temp ; heapify ( arr , i , 0 ) ; } }
void checkType ( int [ ] arr , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) Console . Write ( "Increasing" ) ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) Console . Write ( "Decreasing" ) ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) Console . Write ( "Increasing then decreasing" ) ; else Console . Write ( "Decreasing then increasing" ) ; }
void cal_IST ( int h , double r ) { double IST = ( h * r * 1.0 ) / 360 ; int int_IST = ( int ) IST ; int float_IST = ( int ) Math . Floor ( ( double ) ( IST - int_IST ) * 60 ) ; Console . WriteLine ( int_IST + ":" + float_IST ) ; }
bool isPossible ( int [ ] arr , int p , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < p ; i ++ ) sum += arr [ i ] ; if ( sum == ( n * m ) ) return true ; return false ; }
int maxSubArraySum ( int [ ] a , int n , int k , int i ) { int max_so_far = int . MinValue , max_ending_here = 0 ; while ( i < n ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; i += k ; } return max_so_far ; }
int find ( int [ ] arr , int n , int k ) { int maxSum = 0 ; for ( int i = 0 ; i <= Math . Min ( n , k ) ; i ++ ) { maxSum = Math . Max ( maxSum , maxSubArraySum ( arr , n , k , i ) ) ; } return maxSum ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
void solve ( int n ) { int count = 0 ; for ( int i = 3 ; count < n ; i ++ ) { if ( prime [ i ] ) { Console . Write ( i + " " ) ; count ++ ; } } }
int sum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
void firstN ( int n ) { int num = 19 , cnt = 1 ; while ( cnt != n ) { if ( sum ( num ) == 10 ) { Console . Write ( num + " " ) ; cnt ++ ; } num += 9 ; } }
void compareVal ( double x , double y ) { double a = y * Math . Log ( x ) ; double b = x * Math . Log ( y ) ; if ( a > b ) Console . Write ( x + "^" + y + " > " + y + "^" + x ) ; else if ( a < b ) Console . Write ( x + "^" + y + " < " + y + "^" + x ) ; else if ( a == b ) Console . Write ( x + "^" + y + " = " + y + "^" + x ) ; }
int countWays ( int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans *= 2 ; ans %= MOD ; } return ( ( ans - 1 + MOD ) % MOD ) ; }
void findIntegers ( int n , int [ ] a , int x , int t1 , int t2 ) { bool flag = true ; for ( int i = 0 ; i < n ; i ++ ) { int temp = ( int ) Math . Pow ( a [ i ] , 2 ) + x ; if ( temp % 10 != t1 && temp % 10 != t2 ) { Console . Write ( temp + " " ) ; flag = false ; } } if ( flag ) { Console . WriteLine ( ) ; Console . Write ( "-1" ) ; } }
void findMin ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; Array . Sort ( arr ) ; int min = arr [ 0 ] ; int max = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int num = arr [ i ] ; int total = num + min ; int j ; for ( j = 2 ; j <= num ; j ++ ) { if ( num % j == 0 ) { int d = j ; int now = ( num / d ) + ( min * d ) ; int reduce = total - now ; if ( reduce > max ) max = reduce ; } } } Console . WriteLine ( sum - max ) ; }
bool Survives ( int n ) { for ( int i = 2 ; ; i ++ ) { if ( i > n ) return true ; if ( n % i == 0 ) return false ; n -= n / i ; } }
int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % TEN ; n /= TEN ; } return sum ; }
int getNthTerm ( int n ) { int sum = digitSum ( n ) ; if ( sum % TEN == 0 ) return ( n * TEN ) ; int extra = TEN - ( sum % TEN ) ; return ( ( n * TEN ) + extra ) ; }
void firstNTerms ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( getNthTerm ( i ) + " " ) ; }
int nthXorFib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return ( a ^ b ) ; return nthXorFib ( n % 3 , a , b ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void flip ( int a , int b ) { int lcm = ( a * b ) / gcd ( a , b ) ; a = lcm / a ; b = lcm / b ; Console . WriteLine ( ( a - 1 ) + " " + ( b - 1 ) ) ; }
void findRemainder ( int n ) { int l = n % 10 ; while ( n >= 10 ) n /= 10 ; int f = n ; int remainder = f % l ; Console . WriteLine ( remainder ) ; }
double increaseInVol ( double l , double b , double h ) { double percentInc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ; percentInc -= 1 ; percentInc *= 100 ; return percentInc ; }
int countOccurrances ( int n , int d ) { int count = 0 ; while ( n > 0 ) { count = ( n % 10 == d ) ? count + 1 : count ; n = n / 10 ; } return count ; }
void findFactors ( int a , int b ) { int c ; c = a + b - 1 ; Console . Write ( c ) ; }
int countKdivPairs ( int [ ] A , int n , int K ) { int [ ] freq = new int [ K ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int rem = A [ i ] % K ; ans += freq [ ( K - rem ) % K ] ; freq [ rem ] ++ ; } return ans ; }
void expressDigit ( int [ ] arr , int n ) { int min = 9 , index = 0 , temp = 0 ; temp = arr [ 0 ] ; for ( int i = 1 ; i < 10 ; i ++ ) { if ( arr [ i ] < min ) { min = arr [ i ] ; index = i ; } } if ( temp < min ) { Console . Write ( 1 ) ; for ( int i = 1 ; i <= temp + 1 ; i ++ ) Console . Write ( 0 ) ; } else { for ( int i = 0 ; i < min ; i ++ ) Console . Write ( index ) ; Console . Write ( index ) ; } }
int countDigits ( int num ) { int cnt = 0 ; while ( num > 0 ) { cnt ++ ; num /= 10 ; } return cnt ; }
int sumFromStart ( int num , int n , int rem ) { num /= ( ( int ) Math . Pow ( 10 , rem ) ) ; int sum = 0 ; while ( num > 0 ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; }
int sumFromEnd ( int num , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; }
float getAverage ( int n , int k , int l ) { int totalDigits = countDigits ( n ) ; if ( totalDigits < ( k + l ) ) return - 1 ; int sum1 = sumFromEnd ( n , l ) ; int sum2 = sumFromStart ( n , k , totalDigits - k ) ; return ( ( float ) ( sum1 + sum2 ) / ( float ) ( k + l ) ) ; }
int totalways ( int [ ] arr , int n ) { Dictionary < int , int > cnt = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( cnt . ContainsKey ( arr [ i ] ) ) { cnt [ arr [ i ] ] = cnt [ arr [ i ] ] + 1 ; } else { cnt . Add ( arr [ i ] , 1 ) ; } } if ( n % 2 == 1 ) { int start = 0 , endd = n - 1 ; for ( int i = start ; i <= endd ; i = i + 2 ) { if ( i == 0 ) { if ( cnt [ i ] != 1 ) { return 0 ; } } else { if ( cnt [ i ] != 2 ) { return 0 ; } } } int ways = 1 ; start = 2 ; endd = n - 1 ; for ( int i = start ; i <= endd ; i = i + 2 ) { ways = ways * 2 ; } return ways ; } else if ( n % 2 == 0 ) { int start = 1 , endd = n - 1 ; for ( int i = 1 ; i <= endd ; i = i + 2 ) { if ( cnt [ i ] != 2 ) return 0 ; } int ways = 1 ; for ( int i = start ; i <= endd ; i = i + 2 ) { ways = ways * 2 ; } return ways ; } return int . MinValue ; }
int proizvolov ( int [ ] a , int [ ] b , int n ) { return n * n ; }
void compareValues ( int a , int b , int c , int d ) { double log1 = Math . Log10 ( a ) ; double num1 = log1 * b ; double log2 = Math . Log10 ( c ) ; double num2 = log2 * d ; if ( num1 > num2 ) Console . WriteLine ( a + "^" + b ) ; else Console . WriteLine ( c + "^" + d ) ; }
double sum ( double a , double b , double c , double d , double x ) { double ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; }
double calculateLnx ( double n ) { double num , mul , cal , sum = 0 ; num = ( n - 1 ) / ( n + 1 ) ; for ( int i = 1 ; i <= 1000 ; i ++ ) { mul = ( 2 * i ) - 1 ; cal = Math . Pow ( num , mul ) ; cal = cal / mul ; sum = sum + cal ; } sum = 2 * sum ; return sum ; }
double calculateLogx ( double lnx ) { return ( lnx / 2.303 ) ; }
void printRoots ( long a , long b , long c ) { Console . WriteLine ( "1, " + c / ( a * 1.0 ) ) ; }
int permutation ( String str1 , int i , int n , int p ) { if ( i == n ) { int q = int . Parse ( str1 ) ; if ( q - p > 0 && q < min1 ) { min1 = q ; count = 1 ; } } else { for ( int j = i ; j <= n ; j ++ ) { str1 = swap ( str1 , i , j ) ; permutation ( str1 , i + 1 , n , p ) ; str1 = swap ( str1 , i , j ) ; } } return min1 ; }
int longestAlternativeSequence ( int [ ] a , int n ) { int maxi1 = 0 ; int f1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( f1 != 0 ) { if ( a [ i ] % 2 == 0 ) { f1 = 1 ; maxi1 ++ ; } } else { if ( a [ i ] % 2 == 0 ) { maxi1 ++ ; f1 = 0 ; } } } int maxi2 = 0 ; int f2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( f2 == 0 ) { if ( a [ i ] % 2 == 0 ) { f2 = 1 ; maxi2 ++ ; } } else { if ( a [ i ] % 2 == 0 ) { maxi2 ++ ; f2 = 0 ; } } } return Math . Max ( maxi1 , maxi2 ) ; }
int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x / i <= n ) ans ++ ; return ans ; }
int Cells ( int n , int x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; int i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; }
void ZigZag ( int n ) { long [ ] fact = new long [ n + 1 ] ; long [ ] zig = new long [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) zig [ i ] = 0 ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; zig [ 0 ] = 1 ; zig [ 1 ] = 1 ; Console . Write ( "zig zag numbers: " ) ; Console . Write ( zig [ 0 ] + " " + zig [ 1 ] + " " ) ; for ( int i = 2 ; i < n ; i ++ ) { long sum = 0 ; for ( int k = 0 ; k <= i - 1 ; k ++ ) { sum += ( fact [ i - 1 ] / ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ; } zig [ i ] = sum / 2 ; Console . Write ( sum / 2 + " " ) ; } }
int evenNumSubstring ( string str ) { int len = str . Length ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
float Depreciation ( float v , float r , float t ) { float D = ( float ) ( v * Math . Pow ( ( 1 - r / 100 ) , t ) ) ; return D ; }
int nextPowerOfFour ( int n ) { int x = ( int ) Math . Floor ( Math . Sqrt ( Math . Sqrt ( n ) ) ) ; if ( Math . Pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return ( int ) Math . Pow ( x , 4 ) ; } }
int Alcuin ( int n ) { double _n = n , ans ; ans = Math . Round ( ( _n * _n ) / 12 ) - Math . Floor ( _n / 4 ) * Math . Floor ( ( _n + 2 ) / 4 ) ; return ( int ) ans ; }
void solve ( int n ) { int i = 0 ; for ( i = 1 ; i <= n ; i ++ ) { Console . Write ( Alcuin ( i ) + ", " ) ; } }
int find_count ( List < int > ele ) { int count = 0 ; for ( int i = 0 ; i < ele . Count ; i ++ ) { List < int > p = new List < int > ( ) ; int c = 0 , j ; for ( j = ele . Count - 1 ; j >= ( ele . Count - 1 - i ) && j >= 0 ; j -- ) { p . Add ( ele [ j ] ) ; } j = ele . Count - 1 ; int k = 0 ; while ( j >= 0 ) { if ( ele [ j ] != p [ k ] ) { break ; } j -- ; k ++ ; if ( k == p . Count ) { c ++ ; k = 0 ; } } count = Math . Max ( count , c ) ; } return count ; }
void solve ( int n ) { int count = 1 ; List < int > ele = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( count + ", " ) ; ele . Add ( count ) ; count = find_count ( ele ) ; } }
int speedOfTrain ( float X , float Y ) { float Speed ; Speed = 1188 * ( ( X - Y ) / Y ) ; return ( int ) Speed ; }
int Division ( int [ ] a , int n ) { int maxi = int . MinValue , mini = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { maxi = Math . Max ( a [ i ] , maxi ) ; mini = Math . Min ( a [ i ] , mini ) ; } return maxi / mini ; }
List < int > addPrimes ( ) { int n = MAX ; Boolean [ ] prime = new Boolean [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } List < int > ans = new List < int > ( ) ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . Add ( p ) ; return ans ; }
int find_Sum ( int n ) { int sum = 0 ; List < int > v = addPrimes ( ) ; for ( int i = 0 ; i < v . Count && n > 0 ; i ++ ) { int flag = 1 ; int a = v [ i ] ; while ( a != 0 ) { int d = a % 10 ; a = a / 10 ; if ( is_prime ( d ) ) { flag = 0 ; break ; } } if ( flag == 1 ) { n -- ; sum = sum + v [ i ] ; } } return sum ; }
List < int > addPrimes ( ) { int n = MAX ; Boolean [ ] prime = new Boolean [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } List < int > ans = new List < int > ( ) ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . Add ( p ) ; return ans ; }
int pi ( int x , List < int > v ) { int l = 0 , r = v . Count - 1 , m , i = - 1 ; while ( l <= r ) { m = ( l + r ) / 2 ; if ( v [ m ] <= x ) { i = m ; l = m + 1 ; } else { r = m - 1 ; } } return i + 1 ; }
int Ramanujan ( int n , List < int > v ) { int upperbound = ( int ) ( 4 * n * ( Math . Log ( 4 * n ) / Math . Log ( 2 ) ) ) ; for ( int i = upperbound ; ; i -- ) { if ( pi ( i , v ) - pi ( i / 2 , v ) < n ) return 1 + i ; } }
void Ramanujan_Numbers ( int n ) { int c = 1 ; List < int > v = addPrimes ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( Ramanujan ( i , v ) ) ; if ( i != n ) Console . Write ( ", " ) ; } }
void solveEven ( int n , int [ ] arr , int [ ] b ) { int left = n - 1 ; for ( int i = 0 ; i < ( n / 2 ) ; ++ i ) { b [ i ] = arr [ left ] ; left = left - 2 ; if ( left < 0 ) break ; } int right = 0 ; for ( int i = n / 2 ; i <= n - 1 ; ++ i ) { b [ i ] = arr [ right ] ; right = right + 2 ; if ( right > n - 2 ) break ; } }
void solve ( int n , int [ ] arr ) { int [ ] b = new int [ n ] ; if ( n % 2 == 0 ) solveEven ( n , arr , b ) ; else solveOdd ( n , arr , b ) ; for ( int i = 0 ; i <= n - 1 ; ++ i ) { Console . Write ( b [ i ] + " " ) ; } }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int NumberOfWays ( int X , int Y , int M , int N ) { return fact ( X + Y ) * nCr ( M , X ) * nCr ( N , Y ) ; }
int Wedderburn ( int n ) { if ( n <= 2 ) return store [ n ] ; else if ( n % 2 == 0 ) { int x = n / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } ans += ( store [ x ] * ( store [ x ] + 1 ) ) / 2 ; if ( store . ContainsKey ( n ) ) { store . Remove ( n ) ; store . Add ( n , ans ) ; } else store . Add ( n , ans ) ; return ans ; } else { int x = ( n + 1 ) / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } if ( store . ContainsKey ( n ) ) { store . Remove ( n ) ; store . Add ( n , ans ) ; } else store . Add ( n , ans ) ; return ans ; } }
void Wedderburn_Etherington ( int n ) { store . Add ( 0 , 0 ) ; store . Add ( 1 , 1 ) ; store . Add ( 2 , 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( Wedderburn ( i ) ) ; if ( i != n - 1 ) Console . Write ( " " ) ; } }
int factorial ( int n ) { if ( n <= 1 ) return 1 ; return n * factorial ( n - 1 ) ; }
int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( n - r ) * factorial ( r ) ) ; }
int NumberOfWays ( int n , int x , int y ) { return nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) ; }
int fact ( int n ) { int i = 1 , fac = 1 ; for ( i = 1 ; i <= n ; i ++ ) fac = fac * i ; return fac ; }
double log_Expansion ( double x , int n ) { double sum = 0 ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum = sum + Math . Pow ( x , 2 * i ) / fact ( 2 * i ) ; } return sum ; }
void prime_range ( int start , int end , int [ ] a ) { for ( int i = start ; i < end ; i ++ ) { if ( prime ( a [ i ] ) ) Console . Write ( a [ i ] + " " ) ; } }
int countElements ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; float mean = ( float ) sum / n ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { float newMean = ( float ) ( sum - arr [ i ] ) / ( n - 1 ) ; if ( newMean == mean ) cnt ++ ; } return cnt ; }
bool Prime ( int n ) { for ( int j = 2 ; j <= Math . Sqrt ( n ) ; j ++ ) if ( n % j == 0 ) return false ; return true ; }
int find_prime ( int x , int xsqmodp , int y , int ysqmodp ) { int n = x * x - xsqmodp ; int n1 = y * y - ysqmodp ; for ( int j = 2 ; j <= Math . Max ( Math . Sqrt ( n ) , Math . Sqrt ( n1 ) ) ; j ++ ) { if ( n % j == 0 && ( x * x ) % j == xsqmodp && n1 % j == 0 && ( y * y ) % j == ysqmodp ) if ( Prime ( j ) ) return j ; int j1 = n / j ; if ( n % j1 == 0 && ( x * x ) % j1 == xsqmodp && n1 % j1 == 0 && ( y * y ) % j1 == ysqmodp ) if ( Prime ( j1 ) ) return j1 ; j1 = n1 / j ; if ( n % j1 == 0 && ( x * x ) % j1 == xsqmodp && n1 % j1 == 0 && ( y * y ) % j1 == ysqmodp ) if ( Prime ( j1 ) ) return j1 ; } if ( n == n1 ) return n ; return int . MinValue ; }
int numberOfMinutes ( int S , int S1 ) { int Min = 0 ; Min = ( int ) ( ( ( S - S1 ) / Math . Floor ( ( double ) S ) ) * 60 ) ; return Min ; }
int FindElement ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + a [ i ] ; if ( sum % n == 0 ) { int m = sum / n ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == m ) return m ; } return - 1 ; }
int fac ( int num ) { if ( num == 0 ) return 1 ; int fact = 1 ; for ( int i = 1 ; i <= num ; i ++ ) fact = fact * i ; return fact ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int Max_sum ( int [ ] a , int n ) { int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) pos = 1 ; else if ( a [ i ] < 0 ) neg = 1 ; if ( ( pos == 1 ) && ( neg == 1 ) ) break ; } int sum = 0 ; if ( ( pos == 1 ) && ( neg == 1 ) ) { for ( int i = 0 ; i < n ; i ++ ) sum += Math . Abs ( a [ i ] ) ; } else if ( pos == 1 ) { int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . Min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } else if ( neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Math . Abs ( a [ i ] ) ; int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . Min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } return sum ; }
bool checkcomposite ( int n ) { for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return true ; } return false ; }
int power ( int x , int y , int mod ) { int res = 1 ; while ( y != 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
int Check ( int n , int a ) { if ( a > 1 && checkcomposite ( n ) && power ( a , n - 1 , n ) == 1 ) return 1 ; return 0 ; }
int count ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int cnt = 0 ; int i = 0 , j = 1 ; while ( i < n && j < n ) { j = ( j <= i ) ? ( i + 1 ) : j ; while ( j < n && ( arr [ j ] - arr [ i ] ) < k ) j ++ ; cnt += ( n - j ) ; i ++ ; } return cnt ; }
int factorial ( int n ) { if ( n <= 1 ) return 1 ; return n * factorial ( n - 1 ) ; }
int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
float Probability ( int M , int N , int X ) { return ( float ) ( nCr ( M - N - 1 , X - 2 ) / ( nCr ( M - 1 , X - 1 ) * 1.0 ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int Count_number ( int N ) { return ( N * fact ( N ) ) ; }
int fact ( int n ) { if ( n <= 1 ) return 1 ; return n * fact ( n - 1 ) ; }
int nPr ( int n , int r ) { return fact ( n ) / fact ( n - r ) ; }
void decimalToBinary ( int n ) { if ( n == 0 ) { Console . Write ( "0" ) ; return ; } decimalToBinary ( n / 2 ) ; Console . Write ( n % 2 ) ; }
void MinimumValue ( int x , int y ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int a = 1 ; int b = x - 1 ; int c = y - b ; Console . WriteLine ( a + " " + b + " " + c ) ; }
int getHeight ( int X ) { return ( 2 * X ) ; }
double volumeRec ( double a , double b , double e , double h ) { return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; }
int firstSetBit ( int n ) { int x = n & ( n - 1 ) ; return ( n ^ x ) ; }
int NoofSequences ( int N , int M ) { Dictionary < int , int > prime = new Dictionary < int , int > ( ) ; for ( int i = 2 ; i <= Math . Sqrt ( M ) ; i ++ ) { while ( M % i == 0 ) { if ( ! prime . ContainsKey ( i ) ) prime . Add ( i , 1 ) ; else { int x = prime [ i ] ; prime . Remove ( i ) ; prime . Add ( i , ++ x ) ; } M /= i ; } } if ( M > 1 ) { if ( prime . ContainsKey ( M ) ) { int x = prime [ M ] ; prime . Remove ( M ) ; prime . Add ( M , ++ x ) ; } else prime . Add ( M , 1 ) ; } int ans = 1 ; foreach ( KeyValuePair < int , int > entry in prime ) { ans *= ( nCr ( N + entry . Value - 1 , N - 1 ) ) ; } return ans ; }
int findHours ( int a , int b , int k ) { if ( a >= b ) return - 1 ; int time = k / ( b - a ) ; time = time + 1 ; return time ; }
int countQuadruples ( int N , int K ) { int M = N / K ; int answer = nCr ( M ) ; for ( int i = 2 ; i < M ; i ++ ) { int j = i ; int temp2 = M / i ; int count = 0 ; int check = 0 ; int temp = j ; while ( j % 2 == 0 ) { count ++ ; j /= 2 ; if ( count >= 2 ) break ; } if ( count >= 2 ) { check = 1 ; } for ( int k = 3 ; k <= Math . Sqrt ( temp ) ; k += 2 ) { int cnt = 0 ; while ( j % k == 0 ) { cnt ++ ; j /= k ; if ( cnt >= 2 ) break ; } if ( cnt >= 2 ) { check = 1 ; break ; } else if ( cnt == 1 ) count ++ ; } if ( j > 2 ) { count ++ ; } if ( check == 1 ) continue ; else { if ( count % 2 == 1 ) { answer -= nCr ( temp2 ) ; } else { answer += nCr ( temp2 ) ; } } } return answer ; }
int minimum_sum ( int n , int k ) { if ( k % n == 0 ) return 0 ; return 1 ; }
int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
int NoOfDistributions ( int N , int R ) { return ncr ( N - 1 , R - 1 ) ; }
int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
int NoOfDistributions ( int N , int R ) { return ncr ( N + R - 1 , R - 1 ) ; }
int maxElement ( int [ ] a , int n ) { if ( n < 3 ) return - 1 ; int maxElement = a [ 0 ] ; int maxProd = a [ n - 1 ] * a [ 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { int currProd = a [ i - 1 ] * a [ ( i + 1 ) % n ] ; if ( currProd > maxProd ) { maxProd = currProd ; maxElement = a [ i ] ; } else if ( currProd == maxProd ) { maxElement = Math . Max ( maxElement , a [ i ] ) ; } } return maxElement ; }
int totalWays ( int X , int Y , int M , int W ) { return ( ncr ( M , X ) * ncr ( W , Y ) ) ; }
bool checkPerfectcube ( int n ) { int d = ( int ) Math . Sqrt ( n ) ; if ( d * d * d == n ) return true ; return false ; }
int smallestPerfectCube ( int [ ] a , int n ) { int mini = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkPerfectcube ( a [ i ] ) ) { mini = Math . Min ( a [ i ] , mini ) ; } } return mini ; }
void Vertices ( int x , int y ) { int val = Math . Abs ( x ) + Math . Abs ( y ) ; Console . Write ( val * ( x < 0 ? - 1 : 1 ) + " 0 " ) ; Console . Write ( "0 " + val * ( y < 0 ? - 1 : 1 ) ) ; }
double SumofInverseDivisors ( int N , int Sum ) { double ans = ( double ) ( Sum ) * 1.0 / ( double ) ( N ) ; return ans ; }
void CheckSubarray ( int [ ] arr , int N ) { int [ ] presum = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 1 ) { presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] ; } for ( int i = 1 ; i <= N ; i += 1 ) { for ( int j = i ; j <= N ; j += 1 ) { if ( ( presum [ j ] - presum [ i - 1 ] ) % N == 0 ) { Console . Write ( ( i - 1 ) + " " + ( j - 1 ) ) ; return ; } } } Console . Write ( - 1 ) ; }
void CheckSubarray ( int [ ] arr , int N ) { int [ ] presum = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 1 ) { presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] ; } List < int > [ ] moduloclass = new List < int > [ N ] ; for ( int i = 0 ; i < N ; i += 1 ) { moduloclass [ i ] = new List < int > ( ) ; } for ( int i = 1 ; i <= N ; i += 1 ) { moduloclass [ presum [ i ] % N ] . Add ( i - 1 ) ; } if ( moduloclass [ 0 ] . Count > 0 ) { Console . Write ( 0 + " " + moduloclass [ 0 ] [ 0 ] ) ; return ; } for ( int i = 1 ; i < N ; i += 1 ) { if ( moduloclass [ i ] . Count >= 2 ) { Console . Write ( moduloclass [ i ] [ 0 ] + 1 + " " + moduloclass [ i ] [ 1 ] ) ; return ; } } }
int findNearestNumber ( int n ) { int cnt = countBits ( n ) ; cnt -= 1 ; if ( cnt % 2 == 1 ) { return 1 << ( cnt + 1 ) ; } else { int tempnum = 0 ; for ( int i = 0 ; i <= cnt ; i += 2 ) { tempnum += 1 << i ; } if ( tempnum < n ) { return ( 1 << ( cnt + 2 ) ) ; } else if ( tempnum == n ) { return n ; } for ( int i = 0 ; i <= cnt ; i += 2 ) { tempnum -= ( 1 << i ) ; if ( tempnum < n ) { return tempnum += ( 1 << i ) ; } } } return int . MinValue ; }
int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) / ( d - c ) ; return X ; }
int NoofTriplets ( int N , int K ) { int [ ] cnt = new int [ K ] ; Array . Fill ( cnt , 0 , cnt . Length , 0 ) ; for ( int i = 1 ; i <= N ; i += 1 ) { cnt [ i % K ] += 1 ; } if ( ( K & 1 ) != 0 ) { return cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; } else { return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K / 2 ] * cnt [ K / 2 ] * cnt [ K / 2 ] ) ; } }
int countNum ( int n ) { if ( n == 1 ) return 1 ; int count = ( int ) Math . Pow ( 2 , n - 2 ) ; return count ; }
int binaryToDecimal ( String n ) { String num = n ; int dec_value = 0 ; int base_t = 1 ; int len = num . Length ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num [ i ] == '1' ) dec_value = dec_value + base_t ; base_t = base_t * 2 ; } return dec_value ; }
int findNumber ( int n ) { String s = constructString ( n - 1 ) ; int num = binaryToDecimal ( s ) ; return num ; }
int findNumber ( int n ) { int num = n - 1 ; num = 2 * ( int ) Math . Pow ( 4 , num ) ; num = ( int ) Math . Floor ( num / 3.0 ) ; return num ; }
int bitonic_point ( Node node ) { if ( node == null ) return - 1 ; if ( node . next == null ) return - 1 ; if ( node . data > node . next . data ) return - 1 ; while ( node . next != null ) { if ( node . data > node . next . data ) break ; node = node . next ; } int bitonicPoint = node . data ; while ( node . next != null ) { if ( node . data < node . next . data ) return - 1 ; node = node . next ; } return bitonicPoint ; }
int minSum ( int [ ] a , int n ) { Array . Sort ( a ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
bool canConvert ( int a , int b ) { while ( b > a ) { if ( b % 10 == 1 ) { b /= 10 ; continue ; } if ( b % 2 == 0 ) { b /= 2 ; continue ; } return false ; } if ( b == a ) return true ; return false ; }
int MinRemove ( int [ ] a , int n , int k ) { int [ ] cnt = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) cnt [ 0 ] ++ ; else if ( cnt [ a [ i ] - 1 ] > 0 ) { cnt [ a [ i ] - 1 ] -- ; cnt [ a [ i ] ] ++ ; } } return n - ( k * cnt [ k - 1 ] ) ; }
int mosaic ( int n ) { int i , ans = 1 ; for ( i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 && n > 0 ) { int count = 0 ; while ( n % i == 0 ) { n /= i ; count ++ ; } ans *= count * i ; } } return ans ; }
void nMosaicNumbers ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( mosaic ( i ) + " " ) ; }
int mosaic ( int n ) { int i , ans = 1 ; for ( i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 && n > 0 ) { int count = 0 ; while ( n % i == 0 ) { n /= i ; count ++ ; } ans *= count * i ; } } return ans ; }
void lowerWythoff ( int n ) { double phi = ( 1 + Math . Sqrt ( 5 ) ) / 2.0 ; for ( int i = 1 ; i <= n ; i ++ ) { double ans = Math . Floor ( i * phi ) ; Console . Write ( ( int ) ans ) ; if ( i != n ) Console . Write ( " , " ) ; } }
int Total_Ways ( int n ) { int fac = 1 ; for ( int i = 2 ; i <= n - 1 ; i ++ ) { fac = fac * i ; } return ( fac * 2 ) ; }
int MaxNumbers ( int [ ] a , int n ) { int [ ] fre = { 0 , 0 , 0 } ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] %= 3 ; fre [ a [ i ] ] ++ ; } int ans = fre [ 0 ] ; int k = Math . Min ( fre [ 1 ] , fre [ 2 ] ) ; ans += k ; fre [ 1 ] -= k ; fre [ 2 ] -= k ; ans += fre [ 1 ] / 3 + fre [ 2 ] / 3 ; return ans ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int pairs ( int [ ] arr , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = countSetBits ( arr [ i ] ) + countSetBits ( arr [ j ] ) ; if ( sum == k ) count ++ ; } } return count ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int pairs ( int [ ] arr , int n , int k ) { int count = 0 ; int [ ] f = new int [ MAX + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) f [ countSetBits ( arr [ i ] ) ] ++ ; for ( int i = 0 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j ++ ) { if ( i + j == k ) { if ( i == j ) count += ( ( f [ i ] * ( f [ i ] - 1 ) ) / 2 ) ; else count += ( f [ i ] * f [ j ] ) ; } } } return count ; }
int composite_factors ( int n ) { int count = 0 ; int i , j ; int [ ] a = new int [ n + 1 ] ; for ( i = 0 ; i < n ; i ++ ) { a [ i ] = 0 ; } for ( i = 1 ; i <= n ; ++ i ) { if ( n % i == 0 ) { a [ i ] = i ; } } for ( i = 2 ; i <= n ; i ++ ) { j = 2 ; int p = 1 ; while ( j < a [ i ] ) { if ( a [ i ] % j == 0 ) { p = 0 ; break ; } j += 1 ; } if ( p == 0 && a [ i ] != 0 ) { count += 1 ; } } return count ; }
int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; }
void specialSieve ( int n ) { int cnt = 0 ; int [ ] prime = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! ( prime [ i ] > 0 ) ) { cnt ++ ; for ( int j = i ; j <= n ; j += i ) prime [ j ] = cnt ; } } for ( int i = 2 ; i <= n ; i ++ ) Console . Write ( prime [ i ] + " " ) ; }
int sumOfMersenne ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 && isMersenne ( arr [ i ] ) ) { sum += arr [ i ] ; } } return sum ; }
int sumOfFactors ( int n ) { int sum = 0 ; for ( int f = 1 ; f <= n / 2 ; f ++ ) { if ( n % f == 0 ) { sum += f ; } } return sum ; }
bool sameLength ( int A , int B ) { while ( ( A > 0 ) && ( B > 0 ) ) { A = A / 10 ; B = B / 10 ; } if ( ( A == 0 ) && ( B == 0 ) ) return true ; return false ; }
void preProcess ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) cnt_neg ++ ; if ( arr [ i ] == 0 ) exists_zero = true ; } }
int FindXorSum ( int [ ] arr , int k , int n ) { if ( n < k ) return 0 ; int [ ] x = new int [ n ] ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) x [ i ] = x [ i - 1 ] ^ arr [ i ] ; else x [ i ] = arr [ i ] ; if ( i >= k - 1 ) { int sum = 0 ; sum = x [ i ] ; if ( i - k > - 1 ) sum ^= x [ i - k ] ; result += sum ; } } return result ; }
int reverse ( int n ) { int rev = 0 ; while ( n > 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n = n / 10 ; } return rev ; }
bool isPalin ( int n ) { return ( n == reverse ( n ) ) ; }
int countDigits ( int n ) { int c = 0 ; while ( n > 0 ) { n = n / 10 ; c ++ ; } return c ; }
int countPalinDigits ( int [ ] arr , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 10 || isPalin ( arr [ i ] ) ) { s += countDigits ( arr [ i ] ) ; } } return s ; }
int reverse ( int n ) { int d = 0 , s = 0 ; while ( n > 0 ) { d = n % 10 ; s = s * 10 + d ; n = n / 10 ; } return s ; }
bool isPalin ( int n ) { return n == reverse ( n ) ; }
int sumOfArray ( int [ ] arr , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] > 10 ) && isPalin ( arr [ i ] ) ) { s += arr [ i ] ; } } return s ; }
bool isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) return true ; else return false ; }
long fact ( long n ) { if ( n < 2 ) { return 1 ; } return n * fact ( n - 1 ) ; }
long only_vowels ( Dictionary < char , int > freq ) { long denom = 1 ; long cnt_vwl = 0 ; foreach ( KeyValuePair < char , int > itr in freq ) { if ( isVowel ( itr . Key ) ) { denom *= fact ( itr . Value ) ; cnt_vwl += itr . Value ; } } return fact ( cnt_vwl ) / denom ; }
long all_vowels_together ( Dictionary < char , int > freq ) { long vow = only_vowels ( freq ) ; long denom = 1 ; long cnt_cnst = 0 ; foreach ( KeyValuePair < char , int > itr in freq ) { if ( ! isVowel ( itr . Key ) ) { denom *= fact ( itr . Value ) ; cnt_cnst += itr . Value ; } } long ans = fact ( cnt_cnst + 1 ) / denom ; return ( ans * vow ) ; }
long no_vowels_together ( string word ) { Dictionary < char , int > freq = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < word . Length ; i ++ ) { char ch = Char . ToLower ( word [ i ] ) ; if ( freq . ContainsKey ( ch ) ) { freq [ ch ] ++ ; } else { freq [ ch ] = 1 ; } } long total = total_permutations ( freq ) ; long vwl_tgthr = all_vowels_together ( freq ) ; long res = total - vwl_tgthr ; return res ; }
void updatePrimes ( ) { for ( int i = 2 ; i <= MAX ; i ++ ) { prime [ i ] = 1 ; } prime [ 0 ] = prime [ 1 ] = 0 ; for ( int i = 2 ; i * i <= MAX ; i ++ ) { if ( prime [ i ] == 1 ) { for ( int j = i * i ; j <= MAX ; j += i ) { prime [ j ] = 0 ; } } } for ( int i = 1 ; i <= MAX ; i ++ ) { prime [ i ] += prime [ i - 1 ] ; } }
int getDifference ( int l , int r ) { int total = r - l + 1 ; int primes = prime [ r ] - prime [ l - 1 ] ; int composites = total - primes ; return ( Math . Abs ( primes - composites ) ) ; }
double e ( int x , int n ) { double r ; if ( n == 0 ) return 1 ; r = e ( x , n - 1 ) ; p = p * x ; f = f * n ; return ( r + p / f ) ; }
void constructSieve ( ) { for ( int i = 2 ; i <= MAX ; i ++ ) { if ( Sieve [ i ] == 0 ) { for ( int j = 2 * i ; j <= MAX ; j += i ) { int temp = j ; while ( temp > 1 && temp % i == 0 ) { Sieve [ j ] ++ ; temp = temp / i ; } } } } }
void checkElements ( int [ ] A , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( Sieve [ A [ i ] ] == k ) { Console . WriteLine ( "YES" ) ; } else { Console . WriteLine ( "No" ) ; } } }
long modularexpo ( long x , long y , long p ) { long res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
void multiply ( long [ , ] F , long [ , ] M , long m ) { long x = ( ( F [ 0 , 0 ] * M [ 0 , 0 ] ) % m + ( F [ 0 , 1 ] * M [ 1 , 0 ] ) % m ) % m ; long y = ( ( F [ 0 , 0 ] * M [ 0 , 1 ] ) % m + ( F [ 0 , 1 ] * M [ 1 , 1 ] ) % m ) % m ; long z = ( ( F [ 1 , 0 ] * M [ 0 , 0 ] ) % m + ( F [ 1 , 1 ] * M [ 1 , 0 ] ) % m ) % m ; long w = ( ( F [ 1 , 0 ] * M [ 0 , 1 ] ) % m + ( F [ 1 , 1 ] * M [ 1 , 1 ] ) % m ) % m ; F [ 0 , 0 ] = x ; F [ 0 , 1 ] = y ; F [ 1 , 0 ] = z ; F [ 1 , 1 ] = w ; }
void power ( long [ , ] F , long n , long m ) { if ( n == 0 n == 1 ) return ; long [ , ] M = { { 1 , 1 } , { 1 , 0 } } ; power ( F , n / 2 , m ) ; multiply ( F , F , m ) ; if ( n % 2 != 0 ) multiply ( F , M , m ) ; }
long fib ( long n , long m ) { long [ , ] F = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) return 0 ; power ( F , n - 1 , m ) ; return F [ 0 , 0 ] ; }
int cntWays ( int [ ] arr , int n ) { if ( n == 1 ) { return 0 ; } int tot_sum = 0 , sum = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { tot_sum += arr [ i ] ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { sum += arr [ i ] ; if ( sum == tot_sum / 2 ) { ans ++ ; } } return ans ; }
void power_2 ( ) { long ans = 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { pow2 [ i ] = ans ; ans *= 2 ; } }
int countSetBits ( long x ) { int setBits = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; setBits ++ ; } return setBits ; }
void add ( long num ) { long value = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( visited [ i ] ) continue ; else { if ( num % 2 == 1 ) { value += ( 1 << i ) ; } num /= 2 ; } } ans . Add ( value ) ; }
void solve ( long n , long k ) { ans . Add ( k ) ; int countk = countSetBits ( k ) ; if ( pow2 [ countk ] < n ) { Console . WriteLine ( - 1 ) ; return ; } int count = 0 ; for ( long i = 0 ; i < pow2 [ countk ] - 1 ; i ++ ) { add ( i ) ; count ++ ; if ( count == n ) break ; } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( ans [ i ] + " " ) ; } }
int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; }
long sumPowersK ( long n , long k ) { long sum = 0 , num = 1 ; while ( num <= n ) { sum += num ; num *= k ; } return sum ; }
long getSum ( long n , long k ) { long pwrK = sumPowersK ( n , k ) ; long sumAll = ( n * ( n + 1 ) ) / 2 ; return ( sumAll - pwrK ) ; }
int maxPeople ( int p ) { int tmp = 0 , count = 0 ; for ( int i = 1 ; i * i <= p ; i ++ ) { tmp = tmp + ( i * i ) ; if ( tmp <= p ) count ++ ; else break ; } return count ; }
int maxPeople ( int p ) { long [ ] sums = new long [ kN ] ; sums [ 0 ] = 0 ; for ( int i = 1 ; i < kN ; i ++ ) sums [ i ] = ( long ) ( i * i ) + sums [ i - 1 ] ; int it = lower_bound ( sums , 0 , kN , p ) ; if ( it > p ) { -- it ; } return it ; }
long squareSeries ( long n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
long maxPeople ( long n ) { long low = 0 ; long high = 1000000L ; long ans = 0L ; while ( low <= high ) { long mid = low + ( ( high - low ) / 2 ) ; long value = squareSeries ( mid ) ; if ( value <= n ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; }
int getAverage ( int x , int y ) { int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }
int getfactor ( int n , int p ) { int pw = 0 ; while ( n != 0 ) { n /= p ; pw += n ; } return pw ; }
int isDivisible ( int n , int r , int p ) { int x1 = getfactor ( n , p ) ; int x2 = getfactor ( r , p ) ; int x3 = getfactor ( n - r , p ) ; if ( x1 > x2 + x3 ) return 1 ; return 0 ; }
int findIndex ( int [ ] a , int n , int k ) { int index = - 1 , max_ceil = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] + k - 1 ) / k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= max_ceil ) { max_ceil = a [ i ] ; index = i ; } } return index ; }
int Count_Segment ( int [ ] p , int n ) { int count = 0 ; int [ ] upto = new int [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) upto [ i ] = 0 ; int j = 0 , curr = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( p [ i ] > p [ i - 1 ] && p [ i ] > p [ i + 1 ] ) { curr = p [ i ] ; j = i - 1 ; while ( j >= 0 && p [ j ] < curr ) { upto [ p [ j ] ] = curr ; j = j - 1 ; } j = i + 1 ; while ( j < n && p [ j ] < curr ) { if ( upto [ curr - p [ j ] ] == curr ) count += 1 ; j = j + 1 ; } } } return count ; }
void dfs ( int node , int parent ) { int a = __builtin_popcount ( weight [ node ] + x ) ; if ( maximum < a ) { maximum = a ; ans = node ; } else if ( maximum == a ) ans = Math . Min ( ans , node ) ; for ( int i = 0 ; i < graph [ node ] . Count ; i ++ ) { if ( graph [ node ] [ i ] == parent ) continue ; dfs ( graph [ node ] [ i ] , node ) ; } }
bool solve ( int n , int k ) { if ( n >= ( k * ( k + 1 ) ) / 2 ) { return true ; } return false ; }
void solve ( long a , long b ) { if ( a > 0 && b > 0 ) { Console . WriteLine ( "Positive" ) ; } else if ( a <= 0 && b >= 0 ) { Console . WriteLine ( "Zero" ) ; } else { long n = Math . Abs ( a - b ) + 1 ; if ( n % 2 == 0 ) { Console . WriteLine ( "Positive" ) ; } else { Console . WriteLine ( "Negative" ) ; } } }
bool isEven ( int [ ] arr , int n , int r ) { if ( r % 2 == 0 ) { if ( arr [ n - 1 ] % 2 == 0 ) return true ; } else { int oddCount = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount % 2 == 0 ) return true ; } return false ; }
int closetAND ( int [ ] arr , int n , int k ) { int ans = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . Min ( ans , Math . Abs ( k - X ) ) ; } } return ans ; }
int countQuadruplets ( int l , int r , int k ) { int count = 0 ; for ( int u = l ; u <= r ; u ++ ) { for ( int v = l ; v <= r ; v ++ ) { for ( int w = l ; w <= r ; w ++ ) { for ( int x = l ; x <= r ; x ++ ) { if ( gcd ( gcd ( u , v ) , gcd ( w , x ) ) == k ) count ++ ; } } } } return count ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int count_square ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { int k = n - i + 1 ; count += ( k * k ) ; } return count ; }
int Rate ( int N1 , int N2 ) { float rate = ( N2 - N1 ) * 100 / N1 ; return ( int ) rate ; }
void solve ( int [ ] a , int n ) { int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } int ind = 0 ; if ( twos > 0 ) a [ ind ++ ] = 2 ; bool evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( int i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( a [ i ] + " " ) ; }
int count_pairs ( int [ ] a , int [ ] b , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd1 ++ ; else even1 ++ ; } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) odd2 ++ ; else even2 ++ ; } int pairs = Math . Min ( odd1 , odd2 ) + Math . Min ( even1 , even2 ) ; return pairs ; }
int primeCount ( int [ ] arr , int n ) { int max_val = max_element ( arr ) ; bool [ ] prime = new bool [ max_val + 1 ] ; for ( int p = 0 ; p <= max_val ; p ++ ) prime [ p ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; }
int [ ] getPrefixArray ( int [ ] arr , int n , int [ ] pre ) { pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } return pre ; }
int getPrime ( int [ ] arr , int n ) { int max_val = arr . Max ( ) ; List < Boolean > prime = new List < Boolean > ( max_val + 1 ) ; for ( int i = 0 ; i < max_val + 1 ; i ++ ) prime . Insert ( i , true ) ; prime . Insert ( 1 , false ) ; prime . Insert ( 2 , false ) ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime . Insert ( i , false ) ; } } int maximum = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { maximum = Math . Max ( maximum , arr [ i ] ) ; } } return maximum ; }
void CreateArray ( int N , int even , int odd ) { int EvenPreSums = 1 ; int temp = - 1 ; int OddPreSums = 0 ; for ( int i = 0 ; i <= N + 1 ; i ++ ) { if ( i * ( ( N + 1 ) - i ) == odd ) { temp = 0 ; OddPreSums = i ; break ; } } if ( temp == - 1 ) { Console . WriteLine ( temp ) ; } else { EvenPreSums = ( ( N + 1 ) - OddPreSums ) ; int e = 1 ; int o = 0 ; int CurrSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( CurrSum % 2 == 0 ) { if ( e < EvenPreSums ) { e ++ ; Console . Write ( "0 " ) ; } else { o ++ ; Console . Write ( "1 " ) ; CurrSum ++ ; } } else { if ( e < EvenPreSums ) { e ++ ; Console . Write ( "1 " ) ; CurrSum ++ ; } else { o ++ ; Console . Write ( "0 " ) ; } } } Console . WriteLine ( ) ; } }
int changeTheArray ( int [ ] arr , int n ) { int minEle = arr . Min ( ) ; int maxEle = arr . Max ( ) ; int minOperations = int . MaxValue ; for ( int num = minEle ; num <= maxEle ; num ++ ) { int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( Math . Abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = Math . Min ( minOperations , operations ) ; } return minOperations ; }
long getMinNum ( int N ) { int lcm = 1 ; for ( int i = 2 ; i <= N ; i ++ ) lcm = ( ( i * lcm ) / ( __gcd ( i , lcm ) ) ) ; return ( lcm + 1 ) ; }
double maxEdges ( double N ) { double edges = 0 ; edges = Math . Floor ( ( N * N ) / 4 ) ; return edges ; }
int findX ( int A , int B ) { int j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; }
int findX ( int A , int B ) { return A & B ; }
int findSum ( int A , int B ) { return A ^ B ; }
bool isSumEqual ( int [ ] ar , int n ) { int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; }
int findIndex ( int [ ] a , int n ) { int res = 0 ; long min_diff = Int64 . MaxValue ; long [ ] prod = new long [ n ] ; prod [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long curr_diff = Math . Abs ( ( prod [ n - 1 ] / prod [ i ] ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; }
void Permutation ( int n , int k ) { int [ ] p = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( int i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( p [ i ] + " " ) ; }
double perfectSquares ( int a , int b ) { return ( Math . Floor ( Math . Sqrt ( b ) ) - Math . Ceiling ( Math . Sqrt ( a ) ) + 1 ) ; }
double countOnes ( int [ ] arr , int n ) { return perfectSquares ( 1 , n ) ; }
int validPosition ( int [ ] arr , int N , int K ) { int count = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) count ++ ; } return count ; }
void count_unique ( HashSet < int > s , int n ) { if ( s . Contains ( n ) ) return ; s . Add ( n ) ; n += 1 ; while ( n % 10 == 0 ) { n = n / 10 ; } count_unique ( s , n ) ; }
int countPairs ( int [ ] arr , int n ) { int size = ( 2 * N ) + 1 ; int [ ] freq = new int [ size ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x + N ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( freq [ i ] > 0 ) { ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ; for ( int j = i + 2 ; j < 2001 ; j += 2 ) { if ( freq [ j ] > 0 && ( freq [ ( i + j ) / 2 ] > 0 ) ) { ans += ( freq [ i ] * freq [ j ] ) ; } } } } return ans ; }
int smallestSum ( int n ) { if ( n == 1 ) return 0 ; return ( 2 * ( int ) Math . Pow ( 10 , n - 1 ) ) ; }
int largestSum ( int n ) { return ( 2 * ( ( int ) Math . Pow ( 10 , n ) - 1 ) ) ; }
int count_pairs ( int [ ] a , int [ ] b , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { odd1 ++ ; } else { even1 ++ ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) { odd2 ++ ; } else { even2 ++ ; } } int pairs = Math . Min ( odd1 , even2 ) + Math . Min ( odd2 , even1 ) ; return pairs ; }
int find_leftmost_unsetbit ( int n ) { int ind = - 1 ; int i = 1 ; while ( n > 0 ) { if ( ( n % 2 ) != 1 ) { ind = i ; } i ++ ; n >>= 1 ; } return ind ; }
int vertices ( int N , int A , int B ) { int position = 0 ; int minisum = int . MaxValue ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i == A i == B ) continue ; else { int x = Math . Abs ( i - A ) ; int y = Math . Abs ( i - B ) ; sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; }
int factorial ( int n ) { int f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { f *= i ; } return f ; }
int sumFactorial ( int [ ] arr , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += factorial ( arr [ i ] ) ; } return s ; }
void dfs ( int child , int par , int [ ] color ) { if ( color [ child ] != color [ par ] ) ans ++ ; for ( int i = 0 ; i < gr [ child ] . Count ; i ++ ) { if ( gr [ child ] [ i ] == par ) continue ; dfs ( gr [ child ] [ i ] , child , color ) ; } }
int highestPower ( String str , int len ) { int ans = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) ans ++ ; else break ; } return ans ; }
long modInverse ( long n , long p ) { return power ( n , p - 2 , p ) ; }
long nCrModP ( long n , long r , long p ) { if ( r == 0 ) return 1 ; long [ ] fac = new long [ ( int ) n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ ( int ) n ] * modInverse ( fac [ ( int ) r ] , p ) % p * modInverse ( fac [ ( int ) n - ( int ) r ] , p ) % p ) % p ; }
long countArrangements ( long n , long k , long p ) { return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p ; }
int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . Max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; }
void primeFactors ( int n , int [ ] freq ) { int cnt = 0 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } freq [ 2 ] = cnt ; for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } freq [ i ] = cnt ; } if ( n > 2 ) freq [ n ] = 1 ; }
int getMaximumPower ( int n , int m ) { int [ ] freq1 = new int [ n + 1 ] ; int [ ] freq2 = new int [ m + 1 ] ; primeFactors ( n , freq1 ) ; primeFactors ( m , freq2 ) ; int maxi = 0 ; for ( int i = 2 ; i <= m ; i ++ ) { if ( freq1 [ i ] == 0 && freq2 [ i ] == 0 ) continue ; if ( freq2 [ i ] > freq1 [ i ] ) return 0 ; if ( freq2 [ i ] != 0 ) { maxi = Math . Max ( maxi , freq1 [ i ] / freq2 [ i ] ) ; } } return maxi ; }
bool check ( int [ , ] mat ) { int xorr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xorr ^= mat [ i , 0 ] ; } if ( xorr != 0 ) return true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( mat [ i , j ] != mat [ i , 0 ] ) return true ; } } return false ; }
int sumodd ( int n ) { return ( n * n ) ; }
int sumeven ( int n ) { return ( n * ( n + 1 ) ) ; }
void radiated_Station ( int [ ] station , int n ) { int [ ] rStation = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { int li = i - 1 , ri = i + 1 ; int lRad = station [ i ] - 1 , rRad = station [ i ] - 1 ; rStation [ i ] += station [ i ] ; while ( li >= 1 && lRad >= 1 ) { rStation [ li -- ] += lRad -- ; } while ( ri <= n && rRad >= 1 ) { rStation [ ri ++ ] += rRad -- ; } } print ( rStation , n ) ; }
int oddTriangularNumber ( int N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; }
void idstrt ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) Console . WriteLine ( "The given straight" + " lines are identical" ) ; else Console . WriteLine ( "The given straight" + " lines are not identical" ) ; }
double area ( double a , double b , double c ) { double d = Math . Abs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; }
float percent ( int n , int x ) { float p = n * x ; p /= 100 ; return p ; }
float getLoss ( int [ ] price , int [ ] quantity , int [ ] X , int n ) { float loss = 0 ; for ( int i = 0 ; i < n ; i ++ ) { float originalPrice = price [ i ] ; float sellingPrice = originalPrice + percent ( ( int ) originalPrice , X [ i ] ) ; float afterDiscount = sellingPrice - percent ( ( int ) sellingPrice , X [ i ] ) ; loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) ; } return loss ; }
int maxAbsDiff ( int [ ] arr , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = Math . Min ( minEle , arr [ i ] ) ; maxEle = Math . Max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }
int maxSubArraySum ( int [ ] a , int size ) { int max_so_far = int . MinValue , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int maximizeSum ( int [ ] a , int n ) { int cnt = 0 ; int mini = int . MaxValue ; int minSubarray = int . MaxValue ; int sum = maxSubArraySum ( a , n ) ; int max_so_far = int . MinValue , max_ending_here = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; cnt ++ ; minSubarray = Math . Min ( a [ i ] , minSubarray ) ; if ( sum == max_ending_here ) { if ( cnt == 1 ) mini = Math . Min ( mini , 0 ) ; else mini = Math . Min ( mini , minSubarray ) ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; cnt = 0 ; minSubarray = int . MaxValue ; } } return sum - mini ; }
bool isOsiris ( int n ) { int a = n % 10 ; int b = ( n / 10 ) % 10 ; int c = n / 100 ; int digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
int countTriangles ( int [ ] a , int n ) { int cnt = 0 ; int pairs = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += ( 2 * pairs ) / 3 ; return cnt ; }
int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return ( int ) ( Math . Pow ( 10 , n - 1 ) ) ; }
int countAnomalies ( int [ ] arr , int n , int k ) { int cnt = 0 ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( Math . Abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; }
void Divisors ( ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j * i < N ; j ++ ) { cnt [ i * j ] ++ ; } } }
int Sumofdivisors ( int A , int B , int C ) { int sum = 0 ; Divisors ( ) ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { int x = i * j * k ; sum += cnt [ x ] ; if ( sum >= mod ) { sum -= mod ; } } } } return sum ; }
int getHCF ( int x , int y ) { int minimum = Math . Min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( int i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool isDivisible ( int n ) { if ( isPrime ( n + 1 ) ) return false ; return true ; }
void findDivisors ( int n ) { int [ ] div = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( div [ i ] + " " ) ; }
int findMaxCock ( int [ , ] ar ) { if ( R < 3 C < 3 ) return - 1 ; int max_sum = int . MinValue ; for ( int i = 0 ; i < R - 2 ; i ++ ) { for ( int j = 0 ; j < C - 2 ; j ++ ) { int sum = ( ar [ i , j ] + ar [ i , j + 2 ] ) + ( ar [ i + 1 , j + 1 ] ) + ( ar [ i + 2 , j ] + ar [ i + 2 , j + 1 ] + ar [ i + 2 , j + 2 ] ) ; max_sum = Math . Max ( max_sum , sum ) ; } } return max_sum ; }
int segments ( int n , int [ ] p , int m ) { Dictionary < int , int > c = new Dictionary < int , int > ( ) ; c . Add ( 0 , 1 ) ; bool has = false ; int sum = 0 ; int ans = 0 ; for ( int r = 0 ; r < n ; r ++ ) { if ( p [ r ] < m ) sum -- ; else if ( p [ r ] > m ) sum ++ ; if ( p [ r ] == m ) has = true ; if ( has ) ans += ( ! c . ContainsKey ( sum ) ? 0 : c [ sum ] ) + ( ! c . ContainsKey ( sum - 1 ) ? 0 : c [ sum - 1 ] ) ; else c . Add ( sum , ! c . ContainsKey ( sum ) ? 1 : c [ sum ] + 1 ) ; } return ans ; }
int findMaximumDiff ( int [ ] a , int n ) { int ind1 = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( a [ 0 ] != a [ i ] ) { ind1 = i ; break ; } } int ind2 = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ n - 1 ] != a [ i ] ) { ind2 = ( n - 1 - i ) ; break ; } } return Math . Max ( ind1 , ind2 ) ; }
int decideWinner ( int [ ] a , int n ) { int count0 = 0 ; int count1 = 0 ; int count2 = 0 ; int count3 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }
int minOperations ( int [ ] arr , int n ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . ContainsKey ( arr [ i ] ) ) { var val = m [ arr [ i ] ] ; m . Remove ( arr [ i ] ) ; m . Add ( arr [ i ] , val + 1 ) ; } else { m . Add ( arr [ i ] , 1 ) ; } } int maxFreq = int . MinValue ; maxFreq = m . Values . Max ( ) ; return ( n - maxFreq ) ; }
void Add_edge ( int u , int v ) { ( ( ArrayList ) tree [ u ] ) . Add ( v ) ; ( ( ArrayList ) tree [ v ] ) . Add ( u ) ; }
void intisalise ( ) { startIdx = new int [ n + 1 ] ; endIdx = new int [ n + 1 ] ; p = new int [ n + 1 ] ; }
void Dfs ( int ch , int par ) { p [ currentIdx ] = ch ; startIdx [ ch ] = currentIdx ++ ; foreach ( int c in ( ArrayList ) tree [ ch ] ) { if ( c != par ) Dfs ( c , ch ) ; } endIdx [ ch ] = currentIdx - 1 ; }
int findNode ( int v , int k ) { k += startIdx [ v ] - 1 ; if ( k <= endIdx [ v ] ) return p [ k ] ; return - 1 ; }
int CntDivbyX ( int [ ] arr , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count += 1 ; } return count ; }
int CntDivbyX ( int [ ] arr , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; }
int smallestIndex ( int [ ] a , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return Math . Min ( right1 , right0 ) ; }
int A_mod_B ( string N , int a ) { int len = N . Length ; int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) ans = ( ans * 10 + ( int ) N [ i ] - '0' ) % a ; return ans % a ; }
int findMod ( string N ) { int mod = A_mod_B ( N , 4 ) ; int ans = ( 1 + ( int ) Math . Pow ( 2 , mod ) + ( int ) Math . Pow ( 3 , mod ) + ( int ) Math . Pow ( 4 , mod ) ) ; return ( ans % 5 ) ; }
int countCon ( int [ ] ar , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
void printElements ( int [ ] arr , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { Console . Write ( arr [ i ] + " " ) ; } } }
void reduceFraction ( int x , int y ) { int d ; d = __gcd ( x , y ) ; x = x / d ; y = y / d ; Console . WriteLine ( "x = " + x + ", y = " + y ) ; }
void generateSubStrings ( String s , Dictionary < String , int > mpp ) { int l = s . Length ; for ( int i = 0 ; i < l ; i ++ ) { String temp = "" ; for ( int j = i ; j < l ; j ++ ) { temp += s [ j ] ; if ( mpp . ContainsKey ( temp ) ) { mpp [ temp ] = ++ mpp [ temp ] ; } else mpp . Add ( temp , 1 ) ; } } }
void binomialCoeff ( int [ , ] C ) { int i , j ; for ( i = 1 ; i < 100 ; i ++ ) { for ( j = 0 ; j < 100 ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } }
int answerQuery ( Dictionary < String , int > mpp , int [ , ] C , int k ) { int ans = 0 ; foreach ( KeyValuePair < String , int > entry in mpp ) { if ( entry . Value >= k ) ans += C [ entry . Value , k ] ; } return ans ; }
int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = number * 10 + 1 ; if ( ( number % K == 0 ) ) return len ; } return - 1 ; }
int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; }
void precomputation ( int [ ] arr , int n ) { for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum1 [ j ] += i ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum2 [ j ] += ( sum1 [ j ] - i ) * i ; for ( int i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ; for ( int i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( sum3 [ arr [ i ] ] + " " ) ; }
int sum ( int k , int n ) { int sum = ( int ) ( Math . Pow ( k , n + 1 ) - Math . Pow ( k - 1 , n + 1 ) ) ; return sum ; }
int exponent ( int A , int B ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; int y ; if ( B % 2 == 0 ) { y = exponent ( A , B / 2 ) ; y = ( y * y ) ; } else { y = A ; y = ( y * exponent ( A , B - 1 ) ) ; } return y ; }
int sum ( int k , int n ) { int sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; return sum ; }
int freqPairs ( int [ ] arr , int n ) { int max = arr . Max ( ) ; int [ ] freq = new int [ max + 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 * arr [ i ] ; j <= max ; j += arr [ i ] ) { if ( freq [ j ] >= 1 ) { count += freq [ j ] ; } } if ( freq [ arr [ i ] ] > 1 ) { count += freq [ arr [ i ] ] - 1 ; freq [ arr [ i ] ] -- ; } } return count ; }
bool is_prime ( int num ) { int count = 0 ; for ( int i = 1 ; i * i <= ( num ) ; i ++ ) { if ( ( num ) % i == 0 ) { if ( i * i != ( num ) ) count += 2 ; else count ++ ; } } if ( count == 2 ) return true ; else return false ; }
string is_divisible ( int n ) { if ( n == 1 ) { return "YES" ; } else { if ( is_prime ( n + 1 ) ) return "NO" ; else return "YES" ; } }
int power ( int x , int y , int p ) { while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int findCount ( int N ) { int count = power ( 2 , N , mod ) ; return count ; }
int msb ( int x ) { int ret = 0 ; while ( ( x >> ( ret + 1 ) ) != 0 ) ret ++ ; return ret ; }
int xorRange ( int l , int r ) { int max_bit = msb ( r ) ; int mul = 2 ; int ans = 0 ; for ( int i = 1 ; i <= max_bit ; i ++ ) { if ( ( l / mul ) * mul == ( r / mul ) * mul ) { if ( ( ( l & ( 1 << i ) ) != 0 ) && ( r - l + 1 ) % 2 == 1 ) ans += mul ; mul *= 2 ; continue ; } int odd_c = 0 ; if ( ( ( l & ( 1 << i ) ) != 0 ) && l % 2 == 1 ) odd_c = ( odd_c ^ 1 ) ; if ( ( ( r & ( 1 << i ) ) != 0 ) && r % 2 == 0 ) odd_c = ( odd_c ^ 1 ) ; if ( odd_c != 0 ) ans += mul ; mul *= 2 ; } int zero_bit_cnt = zero_bit_cnt = ( r - l + 1 ) / 2 ; if ( l % 2 == 1 && r % 2 == 1 ) zero_bit_cnt ++ ; if ( zero_bit_cnt % 2 == 1 ) ans ++ ; return ans ; }
long computeXOR ( int n ) { int x = n & 3 ; switch ( x ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } return 0 ; }
int countNumbers ( int x , int n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; }
bool checkfact ( int N , int countprime , int prime ) { int countfact = 0 ; if ( prime == 2 prime == 3 ) countfact ++ ; int divide = prime ; while ( N / divide != 0 ) { countfact += N / divide ; divide = divide * divide ; } if ( countfact >= countprime ) return true ; else return false ; }
bool check ( int N ) { int sumsquares = ( N + 1 ) * ( 2 * N + 1 ) ; int countprime = 0 ; for ( int i = 2 ; i <= Math . Sqrt ( sumsquares ) ; i ++ ) { int flag = 0 ; while ( sumsquares % i == 0 ) { flag = 1 ; countprime ++ ; sumsquares /= i ; } if ( flag == 1 ) { if ( ! checkfact ( N - 1 , countprime , i ) ) return false ; countprime = 0 ; } } if ( sumsquares != 1 ) if ( ! checkfact ( N - 1 , 1 , sumsquares ) ) return false ; return true ; }
int countNonIncreasing ( int [ ] arr , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; }
int recamanArray ( int [ ] arr , int n ) { HashSet < int > s = new HashSet < int > ( ) ; int [ ] recaman = new int [ n + 1 ] ; recamanGenerator ( recaman , n ) ; for ( int i = 0 ; i < n ; i ++ ) s . Add ( recaman [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . Contains ( arr [ i ] ) ) s . Remove ( arr [ i ] ) ; } return s . Count ; }
int countSubarrays ( int [ ] arr , int n , int k ) { long [ ] prefix_sum = new long [ MAX ] ; prefix_sum [ 0 ] = 0 ; prefix_sum = partial_sum ( prefix_sum , arr , n ) ; int sum ; if ( k == 1 ) { sum = 0 ; Dictionary < long , int > mp = new Dictionary < long , int > ( ) ; for ( int i = n ; i >= 0 ; i -- ) { if ( mp . ContainsKey ( prefix_sum [ i ] + 1 ) ) sum += mp [ prefix_sum [ i ] + 1 ] ; if ( mp . ContainsKey ( prefix_sum [ i ] ) ) mp . Add ( prefix_sum [ i ] , mp [ prefix_sum [ i ] ] + 1 ) ; else mp . Add ( prefix_sum [ i ] , 1 ) ; } return sum ; } if ( k == - 1 ) { sum = 0 ; Dictionary < long , int > map = new Dictionary < long , int > ( ) ; for ( int i = n ; i >= 0 ; i -- ) { if ( map . ContainsKey ( prefix_sum [ i ] + 1 ) ) sum += map [ prefix_sum [ i ] + 1 ] ; if ( map . ContainsKey ( prefix_sum [ i ] - 1 ) ) sum += map [ prefix_sum [ i ] - 1 ] ; if ( map . ContainsKey ( prefix_sum [ i ] ) ) map . Add ( prefix_sum [ i ] , map [ prefix_sum [ i ] ] + 1 ) ; else map . Add ( prefix_sum [ i ] , 1 ) ; } return sum ; } sum = 0 ; long b , l = 100000000000000L ; Dictionary < long , int > m = new Dictionary < long , int > ( ) ; for ( int i = n ; i >= 0 ; i -- ) { b = 1 ; while ( true ) { if ( b > l ) break ; if ( m . ContainsKey ( prefix_sum [ i ] + b ) ) sum += m [ prefix_sum [ i ] + b ] ; b *= k ; } if ( m . ContainsKey ( prefix_sum [ i ] ) ) m . Add ( ( prefix_sum [ i ] ) , m [ prefix_sum [ i ] ] + 1 ) ; else m . Add ( ( prefix_sum [ i ] ) , 1 ) ; } return sum ; }
int kadaneAlgorithm ( int [ ] ar , int n ) { int sum = 0 , maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ar [ i ] ; if ( sum < 0 ) sum = 0 ; maxSum = Math . Max ( maxSum , sum ) ; } return maxSum ; }
int maxFunction ( int [ ] arr , int n ) { int [ ] b = new int [ MAX ] ; int [ ] c = new int [ MAX ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 1 ) { b [ i ] = Math . Abs ( arr [ i + 1 ] - arr [ i ] ) ; c [ i ] = - b [ i ] ; } else { c [ i ] = Math . Abs ( arr [ i + 1 ] - arr [ i ] ) ; b [ i ] = - c [ i ] ; } } int ans = kadaneAlgorithm ( b , n - 1 ) ; ans = Math . Max ( ans , kadaneAlgorithm ( c , n - 1 ) ) ; return ans ; }
bool isPerfectSquare ( int [ ] arr , int n ) { Dictionary < int , int > umap = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( umap . ContainsKey ( arr [ i ] ) ) umap [ arr [ i ] ] ++ ; else umap [ arr [ i ] ] = 1 ; } Dictionary < int , int > . ValueCollection valueColl = umap . Values ; foreach ( int val in valueColl ) { if ( val % 2 == 1 ) return false ; } return true ; }
int minimumSteps ( int n , int m , int a , int b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return Math . Min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; }
bool isPrime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) return false ; } return true ; }
int minimumCost ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 1 && isPrime ( n - 2 ) ) return 2 ; if ( n % 2 == 0 ) return 2 ; return 3 ; }
int fib ( int n ) { double phi = ( 1 + Math . Sqrt ( 5 ) ) / 2 ; return ( int ) Math . Round ( Math . Pow ( phi , n ) / Math . Sqrt ( 5 ) ) ; }
int calculateSum ( int l , int r ) { int sum = 0 ; for ( int i = l ; i <= r ; i ++ ) sum += fib ( i ) ; return sum ; }
int fib ( int n ) { double phi = ( 1 + Math . Sqrt ( 5 ) ) / 2 ; return ( int ) Math . Round ( Math . Pow ( phi , n ) / Math . Sqrt ( 5 ) ) ; }
int calculateSum ( int l , int r ) { int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; }
double wastedWater ( double V , double M , double N ) { double wasted_amt , amt_per_min , time_to_fill ; amt_per_min = M - N ; time_to_fill = V / amt_per_min ; wasted_amt = N * time_to_fill ; return wasted_amt ; }
float sphereSide ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float R = ( float ) ( ( h * r * Math . Sqrt ( 2 ) ) / ( h + Math . Sqrt ( 2 ) * r ) ) / 2 ; return R ; }
void Loss ( int SP , int P ) { double loss = 0 ; loss = ( double ) ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; System . Console . WriteLine ( "Loss = " + System . Math . Round ( loss , 3 ) ) ; }
int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }
int countSubarrays ( int [ ] arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { long product = 1 ; for ( int x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }
void build ( int node , int start , int end , int [ ] arr , int k ) { if ( start == end ) { tree [ node ] = ( 1L * arr [ start ] ) % k ; return ; } int mid = ( start + end ) >> 1 ; build ( 2 * node , start , mid , arr , k ) ; build ( 2 * node + 1 , mid + 1 , end , arr , k ) ; tree [ node ] = ( tree [ 2 * node ] * tree [ 2 * node + 1 ] ) % k ; }
long query ( int node , int start , int end , int l , int r , int k ) { if ( start > end start > r < l ) { return 1 ; } if ( start >= l && end <= r ) { return tree [ node ] % k ; } int mid = ( start + end ) >> 1 ; long q1 = query ( 2 * node , start , mid , l , r , k ) ; long q2 = query ( 2 * node + 1 , mid + 1 , end , l , r , k ) ; return ( q1 * q2 ) % k ; }
long countSubarrays ( int [ ] arr , int n , int k ) { long count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { long product_mod_k = query ( 1 , 0 , n - 1 , i , j , k ) ; if ( product_mod_k == 0 ) { count ++ ; } } } return count ; }
void printMaxValPair ( List < long > v , int n ) { v . Sort ( ) ; long N = v [ ( int ) n - 1 ] ; if ( N % 2 == 1 ) { long first_maxima = N / 2 ; long second_maxima = first_maxima + 1 ; long ans1 = ( long ) 3e18 , ans2 = ( long ) 3e18 ; long from_left = - 1 , from_right = - 1 ; long from = - 1 ; for ( long i = 0 ; i < n ; ++ i ) { if ( v [ ( int ) i ] > first_maxima ) { from = i ; break ; } else { long diff = first_maxima - v [ ( int ) i ] ; if ( diff < ans1 ) { ans1 = diff ; from_left = v [ ( int ) i ] ; } } } from_right = v [ ( int ) from ] ; long diff1 = first_maxima - from_left ; long diff2 = from_right - second_maxima ; if ( diff1 < diff2 ) Console . WriteLine ( N + " " + from_left ) ; else Console . WriteLine ( N + " " + from_right ) ; } else { long maxima = N / 2 ; long ans1 = ( long ) 3e18 ; long R = - 1 ; for ( long i = 0 ; i < n - 1 ; ++ i ) { long diff = Math . Abs ( v [ ( int ) i ] - maxima ) ; if ( diff < ans1 ) { ans1 = diff ; R = v [ ( int ) i ] ; } } Console . WriteLine ( N + " " + R ) ; } }
int Permutations ( int n , int k ) { int ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; }
int countIntegers ( long l , long r ) { long ans = 0 , i = 1 ; long v = power ( 2 , i ) ; while ( v <= r ) { while ( v <= r ) { if ( v >= l ) ans ++ ; v = v * 3 ; } i ++ ; v = power ( 2 , i ) ; } if ( l == 1 ) ans ++ ; return ( int ) ans ; }
int sumTruncatablePrimes ( int n ) { int sum = 0 ; for ( int i = 2 ; i < n ; i ++ ) { int num = i ; Boolean flag = true ; while ( num > 0 ) { if ( ! prime [ num ] ) { flag = false ; break ; } num /= 10 ; } num = i ; int power = 10 ; while ( num / power > 0 ) { if ( ! prime [ num % power ] ) { flag = false ; break ; } power *= 10 ; } if ( flag ) { sum += i ; } } return sum ; }
void nDigitPerfectSquares ( int n ) { int smallest = ( int ) Math . Pow ( Math . Ceiling ( Math . Sqrt ( Math . Pow ( 10 , n - 1 ) ) ) , 2 ) ; Console . Write ( smallest + " " ) ; int largest = ( int ) Math . Pow ( Math . Ceiling ( Math . Sqrt ( Math . Pow ( 10 , n ) ) ) - 1 , 2 ) ; Console . Write ( largest ) ; }
int MaxTraceSub ( int [ ] [ ] mat ) { int max_trace = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = i , s = j , trace = 0 ; while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; max_trace = Math . Max ( trace , max_trace ) ; } } } return max_trace ; }
int printSum ( int a , int b ) { int res = 0 ; int temp1 = 0 , temp2 = 0 ; while ( a != 0 ) { temp1 = temp1 * 10 + ( a % 10 ) ; a /= 10 ; } a = temp1 ; while ( b != 0 ) { temp2 = temp2 * 10 + ( b % 10 ) ; b /= 10 ; } b = temp2 ; while ( a != 0 ) { int sum = ( a % 10 + b % 10 ) ; if ( sum / 10 == 0 ) res = res * 10 + sum ; else { temp1 = 0 ; while ( sum != 0 ) { temp1 = temp1 * 10 + ( sum % 10 ) ; sum /= 10 ; } sum = temp1 ; while ( sum != 0 ) { res = res * 10 + ( sum % 10 ) ; sum /= 10 ; } } a /= 10 ; b /= 10 ; } return res ; }
int countDigits ( int a , int b ) { double digits = Math . Log10 ( Math . Abs ( a ) ) - Math . Log10 ( Math . Abs ( b ) ) + 1 ; return ( int ) Math . Floor ( digits ) ; }
int smallestOdd ( int n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) + 1 ; }
int longestSubArray ( int [ ] arr , int n ) { bool isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
int smallestEven ( int n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) ; }
void printBalancedExpression ( int a , int b , int c , int d ) { if ( ( ( a == d ) && ( a != 0 ) ) || ( ( a == 0 ) && ( c == 0 ) && ( d == 0 ) ) ) { for ( int i = 1 ; i <= a ; i ++ ) Console . Write ( "((" ) ; for ( int i = 1 ; i <= c ; i ++ ) Console . Write ( ")(" ) ; for ( int i = 1 ; i <= d ; i ++ ) Console . Write ( "))" ) ; for ( int i = 1 ; i <= b ; i ++ ) Console . Write ( "()" ) ; } else Console . Write ( - 1 ) ; }
int maxProfit ( int n , int a , int b , int x , int y ) { int res = x * ( n / a ) ; res += y * ( n / b ) ; res -= Math . Min ( x , y ) * ( n / ( ( a * b ) / __gcd ( a , b ) ) ) ; return res ; }
int factorial ( int f ) { int fact = 1 ; for ( int i = 2 ; i <= f ; i ++ ) fact *= ( int ) i ; return fact ; }
int kthOdd ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) k -- ; if ( k == 0 ) return arr [ i ] ; } return - 1 ; }
void lastFiveDigits ( int n ) { n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 ; int ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } Console . WriteLine ( ans ) ; }
long power ( long a , long n ) { if ( n == 0 ) { return 1 ; } long p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( n == 1 ) { p = ( p * a ) % mod ; } return p ; }
long computeSum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { long maxs = ( power ( 2 , i ) - 1 + mod ) % mod ; maxs = ( maxs * arr [ i ] ) % mod ; long mins = ( power ( 2 , n - 1 - i ) - 1 + mod ) % mod ; mins = ( mins * arr [ i ] ) % mod ; long V = ( maxs - mins + mod ) % mod ; sum = ( sum + V ) % mod ; } return sum ; }
int maxValue ( int n ) { if ( n == 1 ) return 0 ; return ( ( n * n / 2 ) - 1 ) ; }
int count ( int n ) { int cnt = 0 ; int p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
int countNumbers ( int n ) { return n - n / 2 - n / 3 - n / 5 - n / 7 + n / 6 + n / 10 + n / 14 + n / 15 + n / 21 + n / 35 - n / 30 - n / 42 - n / 70 - n / 105 + n / 210 ; }
long sum ( int n ) { if ( n == 1 ) return 1 ; else return ( ( long ) Math . Pow ( n , n ) + sum ( n - 1 ) ) ; }
long power ( long a , long n ) { if ( n == 0 ) return 1 ; long p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( ( n & 1 ) == 1 ) p = ( p * a ) % mod ; return p ; }
int countPermutations ( int n ) { if ( n == 1 ) { return 0 ; } return ( ( int ) power ( 2 , n - 1 ) - 2 ) % mod ; }
long numbers ( int n ) { return ( long ) ( Math . Pow ( 2 , n + 1 ) ) - 2 ; }
int countNumbers ( int n ) { return ( n / 2520 ) ; }
int nthTerm ( int N ) { int nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += ( int ) Math . Pow ( i , i ) ; } return nth ; }
int nthTerm ( int N ) { int nth = 0 ; nth = ( N * N * ( N + 1 ) ) / 2 ; return nth ; }
int kthSmallest ( int n , int k ) { return ( 2 * k ) ; }
bool isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) return false ; else return true ; }
void sieve_modified ( ) { for ( int i = 1 ; i < MAX ; i += 2 ) { for ( int j = i ; j < MAX ; j += i ) { prefix [ j ] += i ; } } for ( int i = 1 ; i < MAX ; i ++ ) { prefix [ i ] += prefix [ i - 1 ] ; } }
int sumOddFactors ( int L , int R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; }
void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
void getFactorization ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) { hash1 [ spf [ x ] ] ++ ; x = x / spf [ x ] ; } while ( x % temp == 0 ) x = x / temp ; } }
bool check ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x / temp ; } return true ; }
bool hasValidNum ( int [ ] arr , int n ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; }
int findMinRemoval ( int [ ] arr , int n ) { int temp , value = 0 ; int maximum = 0 ; if ( n == 1 ) return 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 && i != n - 1 ) { value = value + Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . Abs ( arr [ i ] - arr [ i + 1 ] ) + Math . Abs ( arr [ i ] - arr [ i - 1 ] ) - Math . Abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; } else if ( i == 0 ) { value = value + Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ; } else temp = Math . Abs ( arr [ i ] - arr [ i - 1 ] ) ; maximum = Math . Max ( maximum , temp ) ; } return ( value - maximum ) ; }
int countQuadruples ( int [ ] a , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . ContainsKey ( a [ i ] ) ) { mp [ a [ i ] ] = mp [ a [ i ] ] + 1 ; } else { mp . Add ( a [ i ] , 1 ) ; } int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; mp [ a [ j ] ] = mp [ a [ j ] ] - 1 ; mp [ a [ k ] ] = mp [ a [ k ] ] - 1 ; int first = a [ j ] - ( a [ k ] - a [ j ] ) ; int fourth = ( a [ k ] * a [ k ] ) / a [ j ] ; if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) { if ( a [ j ] != a [ k ] ) { if ( mp . ContainsKey ( first ) && mp . ContainsKey ( fourth ) ) count += mp [ first ] * mp [ fourth ] ; } else if ( mp . ContainsKey ( first ) && mp . ContainsKey ( fourth ) ) count += mp [ first ] * ( mp [ fourth ] - 1 ) ; } if ( mp . ContainsKey ( a [ j ] ) ) { mp [ a [ j ] ] = mp [ a [ j ] ] + 1 ; } else { mp . Add ( a [ j ] , 1 ) ; } if ( mp . ContainsKey ( a [ k ] ) ) { mp [ a [ k ] ] = mp [ a [ k ] ] + 1 ; } else { mp . Add ( a [ k ] , 1 ) ; } } } return count ; }
double getTime ( int u , int v , int x ) { double speed = u + v ; double time = x / speed ; return time ; }
int number_of_teams ( int M ) { int N1 , N2 , sqr ; sqr = ( int ) Math . Sqrt ( 1 + ( 8 * M ) ) ; N1 = ( 1 + sqr ) / 2 ; N2 = ( 1 - sqr ) / 2 ; if ( N1 > 0 ) return N1 ; return N2 ; }
int power ( int x , int y ) { int p = mod ; int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
int solve ( int n , int k ) { if ( n == 1 ) return 0 ; return ( power ( ( k - 1 ) , n - 1 ) % mod - solve ( n - 1 , k ) + mod ) % mod ; }
int findMinimum ( int x , int y ) { int low = 0 , high = y ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }
int LucasSum ( int N ) { int sum = 0 ; int a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; c = a + b ; a = b ; b = c ; } return sum ; }
int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; }
int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % 2 == 0 && sumOfDigits ( i ) % 3 == 0 ) count ++ ; } return count ; }
int countNumbers ( int l , int r ) { return ( ( r / 6 ) - ( l - 1 ) / 6 ) ; }
int countNumbers ( int L , int R , int K ) { if ( K == 9 ) { K = 0 ; } int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i > R - rem ; i -- ) { int rem1 = i % 9 ; if ( rem1 == K ) { ans ++ ; } } return ans ; }
int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return ( int ) Math . Pow ( 2 , E - 1 ) ; }
void BalanceArray ( int [ ] A , int [ , ] Q ) { int [ ] ANS = new int [ A . Length ] ; int i , sum = 0 ; for ( i = 0 ; i < A . Length ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . GetLength ( 0 ) ; i ++ ) { int index = Q [ i , 0 ] ; int value = Q [ i , 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS [ i ] = sum ; } for ( i = 0 ; i < ANS . Length ; i ++ ) Console . Write ( ANS [ i ] + " " ) ; }
int findMinSum ( int [ ] arr , int n ) { int occ = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * ( int ) Math . Pow ( 2 , occ ) ; occ -- ; } return sum ; }
int findPowerOfP ( int N , int p ) { int count = 0 ; int r = p ; while ( r <= N ) { count += ( N / r ) ; r = r * p ; } return count ; }
List < pair > primeFactorsofB ( int B ) { List < pair > ans = new List < pair > ( ) ; for ( int i = 2 ; B != 1 ; i ++ ) { if ( B % i == 0 ) { int count = 0 ; while ( B % i == 0 ) { B = B / i ; count ++ ; } ans . Add ( new pair ( i , count ) ) ; } } return ans ; }
int largestPowerOfB ( int N , int B ) { List < pair > vec = new List < pair > ( ) ; vec = primeFactorsofB ( B ) ; int ans = int . MaxValue ; for ( int i = 0 ; i < vec . Count ; i ++ ) ans = Math . Min ( ans , findPowerOfP ( N , vec [ i ] . first ) / vec [ i ] . second ) ; return ans ; }
int maxLenSubArr ( int [ ] a , int n ) { int count , j ; int cm = 1 , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; } for ( int i = 0 ; i < n - 1 ; ) { count = 1 ; if ( a [ i ] == a [ i + 1 ] && a [ i ] == max ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] == max ) { count ++ ; i ++ ; } else break ; } if ( count > cm ) cm = count ; } else i ++ ; } return cm ; }
int minSum ( int [ ] arr , int n , int x ) { int sum = 0 ; int largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; int sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . Min ( sum , sumAfterOperation ) ; }
int parity ( int a ) { return a % 3 ; }
int solve ( int [ ] array , int size ) { int operations = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { if ( parity ( array [ i ] ) == parity ( array [ i + 1 ] ) ) { operations ++ ; if ( i + 2 < size ) { int pari1 = parity ( array [ i ] ) ; int pari2 = parity ( array [ i + 2 ] ) ; if ( pari1 == pari2 ) { if ( pari1 == 0 ) array [ i + 1 ] = 1 ; else if ( pari1 == 1 ) array [ i + 1 ] = 0 ; else array [ i + 1 ] = 1 ; } else { if ( ( pari1 == 0 && pari2 == 1 ) || ( pari1 == 1 && pari2 == 0 ) ) array [ i + 1 ] = 2 ; if ( ( pari1 == 1 && pari2 == 2 ) || ( pari1 == 2 && pari2 == 1 ) ) array [ i + 1 ] = 0 ; if ( ( pari1 == 2 && pari2 == 0 ) || ( pari1 == 0 && pari2 == 2 ) ) array [ i + 1 ] = 1 ; } } } } return operations ; }
int findDigitalRoot ( int num ) { int sum = int . MaxValue , tempNum = num ; while ( sum >= 10 ) { sum = 0 ; while ( tempNum > 0 ) { sum += tempNum % 10 ; tempNum /= 10 ; } tempNum = sum ; } return sum ; }
void findAnswer ( int X , int N ) { int counter = 0 ; for ( int i = 1 ; counter < N ; ++ i ) { int digitalRoot = findDigitalRoot ( i ) ; if ( digitalRoot == X ) { ++ counter ; } if ( counter == N ) { Console . Write ( i ) ; break ; } } }
int findAnswer ( int X , int N ) { return ( N - 1 ) * 9 + X ; }
void preComputeXor ( int [ , ] arr , int [ , ] prefix_xor ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 ) prefix_xor [ i , j ] = arr [ i , j ] ; else prefix_xor [ i , j ] = ( prefix_xor [ i , j - 1 ] ^ arr [ i , j ] ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) prefix_xor [ j , i ] = ( prefix_xor [ j - 1 , i ] ^ prefix_xor [ j , i ] ) ; }
int ansQuerie ( int [ , ] prefix_xor , int x1 , int y1 , int x2 , int y2 ) { int xor_1 = 0 , xor_2 = 0 , xor_3 = 0 ; if ( x1 != 0 ) xor_1 = prefix_xor [ x1 - 1 , y2 ] ; if ( y1 != 0 ) xor_2 = prefix_xor [ x2 , y1 - 1 ] ; if ( x1 != 0 && y1 != 0 ) xor_3 = prefix_xor [ x1 - 1 , y1 - 1 ] ; return ( ( prefix_xor [ x2 , y2 ] ^ xor_1 ) ^ ( xor_2 ^ xor_3 ) ) ; }
int LucasSequence ( int [ ] arr , int n ) { int max = arr . Max ( ) ; int counter = 0 ; HashSet < int > s = new HashSet < int > ( ) ; int a = 2 , b = 1 ; s . Add ( a ) ; s . Add ( b ) ; while ( b < max ) { int c = a + b ; a = b ; b = c ; s . Add ( b ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( s . Contains ( arr [ i ] ) ) counter ++ ; } return counter ; }
int matrixSum ( int [ , ] arr ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i , j ] ) ; } } return sum ; }
int maxAND ( int L , int R ) { int maximum = L & R ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ ) maximum = Math . Max ( maximum , ( i & j ) ) ; return maximum ; }
int maxAND ( int L , int R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }
int checkArray ( int [ ] arr , int n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; }
int findCount ( int [ ] arr , int n ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }
bool isPerfectSquare ( double x ) { double sr = Math . Sqrt ( x ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ; }
int Prime_Numbers ( int n ) { ArrayList primes = SieveOfEratosthenes ( ) ; for ( int i = 0 ; i < primes . Count - 1 ; i ++ ) if ( ( int ) primes [ i ] + ( int ) primes [ i + 1 ] + 1 < N ) can [ ( int ) primes [ i ] + ( int ) primes [ i + 1 ] + 1 ] = true ; int ans = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( can [ i ] && isprime [ i ] == true ) { ans ++ ; } } return ans ; }
void printPermutation ( int n , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { int x = 2 * i - 1 ; int y = 2 * i ; if ( i <= k ) Console . Write ( y + " " + x + " " ) ; else Console . Write ( x + " " + y + " " ) ; } }
bool isPossible ( int Sx , int Sy , int Dx , int Dy , int x , int y ) { if ( Math . Abs ( Sx - Dx ) % x == 0 && Math . Abs ( Sy - Dy ) % y == 0 && ( Math . Abs ( Sx - Dx ) / x ) % 2 == ( Math . Abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; }
int getPairs ( int [ ] a ) { int n = a . Length ; int count = ( n * ( n - 1 ) ) / 2 ; return count ; }
bool isDigitSumOne ( int nm ) { if ( nm % 9 == 1 ) return true ; else return false ; }
void printValidNums ( int n ) { int cbrt_n = ( int ) Math . Ceiling ( Math . Pow ( n , ( double ) 1 / 3 ) ) ; for ( int i = 1 ; i <= cbrt_n ; i ++ ) { int cube = ( int ) Math . Pow ( i , 3 ) ; if ( cube >= 1 && cube <= n && isDigitSumOne ( cube ) ) Console . Write ( cube + " " ) ; } }
bool isDigitSumOne ( int nm ) { while ( nm > 9 ) { int sum_digit = 0 ; while ( nm > 0 ) { int digit = nm % 10 ; sum_digit = sum_digit + digit ; nm = nm / 10 ; } nm = sum_digit ; } if ( nm == 1 ) return true ; else return false ; }
void printValidNums ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { if ( isComposite ( i ) && isDigitSumOne ( i ) ) Console . Write ( i + " " ) ; } }
void initialize ( ) { l [ 0 , 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) { l [ i , 0 ] = 1 ; for ( int j = 1 ; j < i + 1 ; j ++ ) { l [ i , j ] = ( l [ i - 1 , j - 1 ] + l [ i - 1 , j ] ) ; } } }
int nCr ( int n , int r ) { return l [ n , r ] ; }
int countRhombi ( int h , int w ) { int ct = 0 ; for ( int i = 2 ; i <= h ; i += 2 ) for ( int j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; }
int maxSum ( int N ) { int ans = 0 ; for ( int u = 1 ; u <= N ; u ++ ) { for ( int v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; int degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; int degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; }
int countSquares ( int row , int column ) { int topLeft = Math . Min ( row , column ) - 1 ; int bottomRight = 8 - Math . Max ( row , column ) ; int topRight = Math . Min ( row , 9 - column ) - 1 ; int bottomLeft = 8 - Math . Max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; }
void cal_factorial ( ) { arr [ 0 ] = 1 ; for ( long i = 1 ; i <= 1000000 ; i ++ ) { arr [ i ] = ( arr [ i - 1 ] * i ) % mod ; } }
long mod_exponent ( long num , long p ) { if ( p == 0 ) return 1 ; if ( ( p & 1 ) != 0 ) { return ( ( num % mod ) * ( mod_exponent ( ( num * num ) % mod , p / 2 ) ) % mod ) % mod ; } else return ( mod_exponent ( ( num * num ) % mod , p / 2 ) ) % mod ; }
long getCount ( long x , long y ) { long ans = arr [ x + y - 1 ] ; ans *= mod_exponent ( arr [ x ] , mod - 2 ) ; ans %= mod ; ans *= mod_exponent ( arr [ y ] , mod - 2 ) ; ans %= mod ; ans *= ( x - y ) ; ans %= mod ; return ans ; }
double calculateArea ( int x , int y ) { double pi = 3.1415926536 ; double arx = pi * x * x ; double ary = pi * y * y ; return arx - ary ; }
void findValues ( int a , int b ) { if ( ( a - b ) % 2 == 1 ) { Console . Write ( "-1" ) ; return ; } Console . WriteLine ( ( ( a - b ) / 2 ) + " " + ( ( a + b ) / 2 ) ) ; }
int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( int ) ( Math . Ceiling ( val ) - x ) ; }
int countTriplets ( int n , List < pair > points ) { HashSet < pair > pts = new HashSet < pair > ( ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) pts . Add ( points [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int x = points [ i ] . first + points [ j ] . first ; int y = points [ i ] . second + points [ j ] . second ; if ( x % 2 == 0 && y % 2 == 0 ) if ( ! pts . Contains ( new pair ( x / 2 , y / 2 ) ) ) ct ++ ; } return ct ; }
char getWinner ( int [ ] arr , int n ) { int gcd = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { gcd = __gcd ( gcd , arr [ i ] ) ; maxEle = Math . Max ( maxEle , arr [ i ] ) ; } int totalMoves = ( maxEle / gcd ) - n ; if ( totalMoves % 2 == 1 ) return 'A' ; return 'B' ; }
void maximumFactor ( int [ ] arr ) { int [ ] rank = new int [ arr . Max ( ) + 1 ] ; int [ ] factors = new int [ arr . Max ( ) + 1 ] ; int g = 0 ; for ( int i = 2 ; i <= arr . Max ( ) ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr . Length ; j ++ ) if ( arr [ j ] % i == 0 ) count += 1 ; rank [ g ] = count ; factors [ g ] = i ; g ++ ; } int m = rank . Max ( ) ; for ( int i = 0 ; i < rank . Length ; i ++ ) { if ( ( int ) rank [ i ] == m ) Console . Write ( factors [ i ] + " " ) ; } }
int digitSum ( int n ) { int ans = 0 ; while ( n != 0 ) { ans += n % 10 ; n /= 10 ; } return ans ; }
int findInt ( int n , int m ) { int minDigit = ( int ) Math . Floor ( ( double ) ( m / 9 ) ) ; int start = ( int ) Math . Pow ( 10 , minDigit ) - ( int ) Math . Pow ( 10 , minDigit ) % n ; while ( start < int . MaxValue ) { if ( digitSum ( start ) == m ) return start ; else start += n ; } return - 1 ; }
double smallestDivisor ( int n ) { double mx = Math . Sqrt ( n ) ; for ( int i = 2 ; i <= mx ; i ++ ) if ( n % i == 0 ) return i ; return n ; }
double maxSum ( int n ) { long res = n ; while ( n > 1 ) { double divi = smallestDivisor ( n ) ; n /= ( int ) divi ; res += n ; } return res ; }
long power ( long x , long y ) { long ans = 1 ; while ( y > 0 ) { if ( ( y & 1 ) > 0 ) ans = ( ans * x ) % MOD ; y >>= 1 ; x = ( x * x ) % MOD ; } return ans % MOD ; }
long modInverse ( long x ) { return power ( x , MOD - 2 ) ; }
long countNumbers ( long n , long a , long b ) { long [ ] fact = new long [ MAX ] ; long [ ] inv = new long [ MAX ] ; long ans = 0 ; fact [ 0 ] = 1 ; for ( long i = 1 ; i < MAX ; i ++ ) { fact [ i ] = ( 1 * fact [ i - 1 ] * i ) ; fact [ i ] %= MOD ; } inv [ MAX - 1 ] = modInverse ( fact [ MAX - 1 ] ) ; for ( long i = MAX - 2 ; i >= 0 ; i -- ) { inv [ i ] = ( inv [ i + 1 ] * ( i + 1 ) ) ; inv [ i ] %= MOD ; } if ( a < b ) { long x = a ; a = b ; b = x ; } for ( long s = n ; s <= 9 * n ; s ++ ) { if ( ! check ( s , a , b ) ) continue ; if ( s < n * b || ( s - n * b ) % ( a - b ) != 0 ) continue ; long numDig = ( s - n * b ) / ( a - b ) ; if ( numDig > n ) continue ; long curr = fact [ n ] ; curr = ( curr * inv [ numDig ] ) % MOD ; curr = ( curr * inv [ n - numDig ] ) % MOD ; ans = ( ans + curr ) % MOD ; } return ans ; }
int countOddSquares ( int n , int m ) { return ( int ) Math . Pow ( m , 0.5 ) - ( int ) Math . Pow ( n - 1 , 0.5 ) ; }
int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }
int findNumber ( int n , int m ) { int num = ( m - 1 ) * 9 + n ; return num ; }
virtual int count ( Node node ) { if ( node == null ) { return 0 ; } return count ( node . left ) + count ( node . right ) + 1 ; }
virtual bool checkRec ( Node node , int n ) { if ( node == null ) { return false ; } if ( count ( node ) == n - count ( node ) ) { return true ; } return checkRec ( node . left , n ) || checkRec ( node . right , n ) ; }
virtual bool check ( Node node ) { int n = count ( node ) ; return checkRec ( node , n ) ; }
int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) for ( int j = 0 ; j <= n - i ; j += b ) { float z = ( float ) ( n - ( i + j ) ) / ( float ) c ; if ( Math . Floor ( z ) == Math . Ceiling ( z ) ) { int x = i / a ; int y = j / b ; maxVal = Math . Max ( maxVal , x + y + ( int ) z ) ; } } return maxVal ; }
int digitsCount ( int n ) { int len = 0 ; while ( n > 0 ) { len ++ ; n /= 10 ; } return len ; }
int absoluteFirstLast ( int n , int x ) { int i = 0 , mod = 1 ; while ( i < x ) { mod *= 10 ; i ++ ; } int last = n % mod ; int len = digitsCount ( n ) ; while ( len != x ) { n /= 10 ; len -- ; } int first = n ; return Math . Abs ( first - last ) ; }
bool EqualNumbers ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] /= 2 ; } while ( a [ i ] % 3 == 0 ) { a [ i ] /= 3 ; } if ( a [ i ] != a [ 0 ] ) { return false ; } } return true ; }
void make_sequence ( int N ) { int [ ] arr = new int [ N + 1 ] ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) arr [ i ] = 1 ; else arr [ i ] = 2 ; sum += arr [ i ] ; } if ( sum % 2 == 1 ) arr [ 2 ] = 3 ; for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
int countOdd ( int L , int R ) { int N = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) N ++ ; return N ; }
int getMinCost ( int n , int m ) { int cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; }
void minOperation ( int n , int k , int [ ] a ) { for ( int i = k ; i < n ; i ++ ) { if ( a [ i ] != a [ k - 1 ] ) Console . WriteLine ( - 1 ) ; } for ( int i = k - 2 ; i > - 1 ; i -- ) { if ( a [ i ] != a [ k - 1 ] ) Console . WriteLine ( i + 1 ) ; } }
bool digitWell ( int n , int m , int k ) { int cnt = 0 ; while ( n > 0 ) { if ( n % 10 == m ) ++ cnt ; n /= 10 ; } return cnt == k ; }
int findInt ( int n , int m , int k ) { int i = n + 1 ; while ( true ) { if ( digitWell ( i , m , k ) ) return i ; i ++ ; } }
int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; }
void generateSequence ( int n , int g ) { for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( i * g + " " ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findLCMFibonacci ( int a , int b ) { return ( fib ( a ) * fib ( b ) ) / fib ( gcd ( a , b ) ) ; }
int getMinNum ( int a , int b , int c ) { if ( c < a c > b ) { return c ; } int x = ( ( b / c ) * c ) + c ; return x ; }
string isEvenOrOdd ( int L , int R ) { int oddCount = ( R - L ) / 2 ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return "Even" ; else return "Odd" ; }
int trailing_zeros ( int N ) { int count_of_two = 0 , count_of_five = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int val = i ; while ( val % 2 == 0 && val > 0 ) { val /= 2 ; count_of_two += i ; } while ( val % 5 == 0 && val > 0 ) { val /= 5 ; count_of_five += i ; } } int ans = Math . Min ( count_of_two , count_of_five ) ; return ans ; }
void SieveOfEratosthenes ( int n ) { for ( int i = 0 ; i < MAX_PRIME + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { b [ j ++ ] = p ; } } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void Sieve ( ) { for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = 2 * i ; j < MAX ; j += i ) { prime [ j ] = 1 ; } } } }
int countPairs ( int n ) { int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; }
int countPairs ( int n ) { if ( n == 2 ) return 4 ; int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = n - max ; return count ; }
int countOdd ( int [ ] arr , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; } return odd ; }
int countValidPairs ( int [ ] arr , int n ) { int odd = countOdd ( arr , n ) ; return ( odd * ( odd - 1 ) ) / 2 ; }
int getMultiple ( string s ) { for ( int i = 0 ; i < 1e3 ; i += 8 ) { if ( checkSub ( i . ToString ( ) , s ) ) return i ; } return - 1 ; }
void alter ( long x , long y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } Console . WriteLine ( "X = " + x + ", " + "Y = " + y ) ; }
int digitProduct ( int n ) { int prod = 1 ; while ( n > 0 ) { prod = prod * ( n % 10 ) ; n = n / 10 ; } return prod ; }
void printMultiplicativePrimes ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] && prime [ digitProduct ( i ) ] ) System . Console . Write ( i + " " ) ; } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
bool coPrime ( int n1 , int n2 ) { if ( gcd ( n1 , n2 ) == 1 ) return true ; else return false ; }
int largestCoprime ( int N ) { int half = ( int ) ( N / 2 ) ; while ( coPrime ( N , half ) == false ) half -- ; return half ; }
int largestCoprime ( int N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
void sieve ( int maxEle , int [ ] prime ) { prime [ 0 ] = prime [ 1 ] = 1 ; for ( int i = 2 ; i * i <= maxEle ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = 2 * i ; j <= maxEle ; j += i ) prime [ j ] = 1 ; } } }
int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n = n / 10 ; } return sum ; }
void printAdditivePrime ( int [ ] arr , int n ) { int maxEle = arr . Max ( ) ; int [ ] prime = new int [ maxEle + 1 ] ; sieve ( maxEle , prime ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == 0 ) { int sum = digitSum ( arr [ i ] ) ; if ( prime [ sum ] == 0 ) Console . Write ( arr [ i ] + " " ) ; } } }
void printSafePrimes ( int n ) { int [ ] prime = new int [ n + 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) prime [ i ] = 1 ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = 0 ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] != 0 ) { int temp = ( 2 * i ) + 1 ; if ( temp <= n && prime [ temp ] != 0 ) prime [ temp ] = 2 ; } } for ( int i = 5 ; i <= n ; i ++ ) if ( prime [ i ] == 2 ) Console . Write ( i + " " ) ; }
float sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return ( float ) s ; }
float sum ( float n ) { if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; }
int findSum ( int m , int n , int mth , int nth , int p ) { ArrayList ad = findingValues ( m , n , mth , nth ) ; int a = ( int ) ad [ 0 ] ; int d = ( int ) ad [ 1 ] ; int sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) / 2 ; return sum ; }
HashSet < int > ABUNDANT ( ) { HashSet < int > v = new HashSet < int > ( ) ; for ( int i = 1 ; i < N ; i ++ ) { int sum = 1 ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { sum += j ; if ( i / j != j ) { sum += i / j ; } } } if ( sum > i ) { v . Add ( i ) ; } } return v ; }
void SumOfAbundant ( int n ) { HashSet < int > v = ABUNDANT ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( v . Contains ( i ) & v . Contains ( n - i ) ) { Console . Write ( i + " " + ( n - i ) ) ; return ; } } Console . Write ( - 1 ) ; }
long nthTermOfTheSeries ( int n ) { long nthTerm ; if ( n % 2 == 0 ) nthTerm = ( long ) Math . Pow ( n - 1 , 2 ) + n ; else nthTerm = ( long ) Math . Pow ( n + 1 , 2 ) + n ; return nthTerm ; }
List < int > Divisors ( int x ) { int c = 0 ; List < int > v = new List < int > ( ) ; while ( x % 2 == 0 ) { c ++ ; x /= 2 ; } v . Add ( c ) ; c = 0 ; while ( x % 3 == 0 ) { c ++ ; x /= 3 ; } v . Add ( c ) ; c = 0 ; while ( x % 7 == 0 ) { c ++ ; x /= 7 ; } v . Add ( c ) ; v . Add ( x ) ; return v ; }
int MinOperations ( int a , int b ) { List < int > va = Divisors ( a ) ; List < int > vb = Divisors ( b ) ; if ( va [ 3 ] != vb [ 3 ] ) { return - 1 ; } int minOperations = Math . Abs ( va [ 0 ] - vb [ 0 ] ) + Math . Abs ( va [ 1 ] - vb [ 1 ] ) + Math . Abs ( va [ 2 ] - vb [ 2 ] ) ; return minOperations ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
int lcmOfArray ( int [ ] arr , int n ) { if ( n < 1 ) return 0 ; int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ; return lcm ; }
void candies ( int n , int k ) { int count = 0 ; int ind = 1 ; int [ ] arr = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) arr [ i ] = 0 ; int low = 0 , high = n ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; int sum = ( mid * ( mid + 1 ) ) >> 1 ; if ( sum <= n ) { count = mid / k ; low = mid + 1 ; } else { high = mid - 1 ; } } int last = ( count * k ) ; n -= ( last * ( last + 1 ) ) / 2 ; int j = 0 ; int term = ( count * k ) + 1 ; while ( n > 0 ) { if ( term <= n ) { arr [ j ++ ] = term ; n -= term ; term ++ ; } else { arr [ j ] += n ; n = 0 ; } } for ( int i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( int i = 0 ; i < k ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
float CPwithLoss ( int sellingPrice , int loss ) { float costPrice ; costPrice = ( sellingPrice * 100 ) / ( 100 - loss ) ; return costPrice ; }
void printArr ( float [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void replaceMax ( float [ ] arr , int n ) { float max = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } float min = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } float range = max - min ; float coeffOfRange = range / ( max + min ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max ) { arr [ i ] = coeffOfRange ; break ; } } printArr ( arr , n ) ; }
int largestOddDigit ( int n ) { int maxOdd = - 1 ; while ( n > 0 ) { int digit = n % 10 ; if ( digit % 2 == 1 && digit > maxOdd ) maxOdd = digit ; n = n / 10 ; } return maxOdd ; }
int getProduct ( int n ) { int maxOdd = largestOddDigit ( n ) ; if ( maxOdd == - 1 ) return - 1 ; return ( n * maxOdd ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void commDiv ( int a , int b ) { int n = gcd ( a , b ) ; a = a / n ; b = b / n ; Console . WriteLine ( "A = " + a + ", B = " + b ) ; }
int minAbsDiff ( int n ) { int left = 1 << ( ( int ) Math . Floor ( Math . Log ( n ) / Math . Log ( 2 ) ) ) ; int right = left * 2 ; return Math . Min ( ( n - left ) , ( right - n ) ) ; }
void FindAllElements ( int n , int k ) { int sum = k ; int [ ] A = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) A [ i ] = 1 ; for ( int i = k - 1 ; i >= 0 ; -- i ) { while ( sum + A [ i ] <= n ) { sum += A [ i ] ; A [ i ] *= 2 ; } } if ( sum != n ) { Console . Write ( "Impossible" ) ; } else { for ( int i = 0 ; i < k ; ++ i ) Console . Write ( A [ i ] + " " ) ; } }
bool isEqual ( int a , int b ) { if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) return true ; return false ; }
bool isPerfectSquare ( int x ) { long left = 1 , right = x ; while ( left <= right ) { long mid = ( left + right ) / 2 ; if ( mid * mid == x ) { return true ; } if ( mid * mid < x ) { left = mid + 1 ; } else { right = mid - 1 ; } } return false ; }
bool isStrongPrime ( int n ) { if ( ! isPrime ( n ) n == 2 ) return false ; int previous_prime = n - 1 ; int next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; int mean = ( previous_prime + next_prime ) / 2 ; if ( n > mean ) return true ; else return false ; }
bool isPrime ( long n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool isFactorialPrime ( long n ) { if ( ! isPrime ( n ) ) return false ; long fact = 1 ; int i = 1 ; while ( fact <= n + 1 ) { fact = fact * i ; if ( n + 1 == fact n - 1 == fact ) return true ; i ++ ; } return false ; }
void sumArray ( int [ ] arr , int n ) { int [ ] leftSum = new int [ n ] ; int [ ] rightSum = new int [ n ] ; int [ ] Sum = new int [ n ] ; int i = 0 , j = 0 ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( Sum [ i ] + " " ) ; }
int LcmSum ( int m ) { ETF ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j += i ) { ans [ j ] += ( i * phi [ i ] ) ; } } int answer = ans [ m ] ; answer = ( answer + 1 ) * m ; answer = answer / 2 ; return answer ; }
int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
int countWays ( String str ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { freq [ i ] = 0 ; } int nvowels = 0 , nconsonants = 0 ; int vplaces , cways , vways ; for ( int i = 0 ; i < str . Length ; i ++ ) ++ freq [ str [ i ] - 'a' ] ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) nvowels += freq [ i ] ; else nconsonants += freq [ i ] ; } vplaces = nconsonants + 1 ; cways = factorial ( nconsonants ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 && freq [ i ] > 1 ) { cways = cways / factorial ( freq [ i ] ) ; } } vways = ncr ( vplaces , nvowels ) * factorial ( nvowels ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 && freq [ i ] > 1 ) { vways = vways / factorial ( freq [ i ] ) ; } } return cways * vways ; }
int setBits ( int n ) { int count = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; }
int countPairs ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int setbits_x = setBits ( a [ i ] ) ; for ( int j = i + 1 ; j < n ; j ++ ) { int setbits_y = setBits ( a [ j ] ) ; int setbits_xor_xy = setBits ( a [ i ] ^ a [ j ] ) ; if ( setbits_x + setbits_y == setbits_xor_xy ) count ++ ; } } return count ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findPossibleDerivables ( int [ ] arr , int n , int D , int A , int B ) { int gcdAB = gcd ( A , B ) ; int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( Math . Abs ( arr [ i ] - D ) % gcdAB ) == 0 ) { counter ++ ; } } return counter ; }
int calSum ( int n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; }
int maxOfMin ( int [ ] a , int n , int S ) { int mi = int . MaxValue ; int s1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s1 += a [ i ] ; mi = Math . Min ( a [ i ] , mi ) ; } if ( s1 < S ) return - 1 ; if ( s1 == S ) return 0 ; int low = 0 ; int high = mi ; int ans = 0 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( s1 - ( mid * n ) >= S ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
void getElements ( int a , int [ ] arr , int n ) { int [ ] elements = new int [ n + 1 ] ; elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( int i = 0 ; i < n + 1 ; i ++ ) Console . Write ( elements [ i ] + " " ) ; }
int minimumX ( int n , int k ) { int mini = int . MaxValue ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = Math . Min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = Math . Min ( num2 , mini ) ; } } return mini ; }
int minimumX ( int n , int k ) { int ans = int . MaxValue ; for ( int rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . Min ( ans , rem + ( n / rem ) * k ) ; } return ans ; }
int maxGCD ( int N , int P ) { int ans = 1 ; Dictionary < int , int > prime_factors = new Dictionary < int , int > ( ) ; for ( int i = 2 ; i * i <= P ; i ++ ) { while ( P % i == 0 ) { if ( ! prime_factors . ContainsKey ( i ) ) prime_factors . Add ( i , 1 ) ; else prime_factors [ i ] = prime_factors [ i ] + 1 ; P /= i ; } } if ( P != 1 ) if ( ! prime_factors . ContainsKey ( P ) ) prime_factors . Add ( P , 1 ) ; else prime_factors [ P ] = prime_factors [ P ] + 1 ; foreach ( KeyValuePair < int , int > me in prime_factors ) { ans *= ( int ) Math . Pow ( me . Key , me . Value / N ) ; } return ans ; }
int getSum ( int [ ] arr , int p ) { return arr . Length ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int countPairs ( int [ ] a , int n ) { int count = 0 ; Hashtable m = new Hashtable ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isPrime ( a [ i ] ^ a [ j ] ) && m [ a [ i ] ^ a [ j ] ] == null ) { m . Add ( ( a [ i ] ^ a [ j ] ) , 1 ) ; count ++ ; } } } return count ; }
virtual int count ( Node node ) { if ( node == null ) { return 0 ; } return count ( node . left ) + count ( node . right ) + 1 ; }
virtual bool check ( Node root ) { int n = count ( root ) ; Res res = new Res ( ) ; checkRec ( root , n , res ) ; return res . res ; }
int countDivisors ( int n ) { int x = 0 , ans = 1 ; while ( n % 2 == 0 ) { x ++ ; n = n / 2 ; } ans = ans * ( x + 1 ) ; for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { x = 0 ; while ( n % i == 0 ) { x ++ ; n = n / i ; } ans = ans * ( x + 1 ) ; } if ( n > 2 ) ans = ans * 2 ; return ans ; }
int getTotalCount ( int n , int k ) { int k_count = countDivisors ( k ) ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( k_count == countDivisors ( i ) ) count ++ ; if ( k < n ) count = count - 1 ; return count ; }
int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
int doubleFactorial ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { fact = fact * i ; } return fact ; }
int hermiteNumber ( int n ) { if ( n % 2 == 1 ) return 0 ; else { int number = ( int ) ( Math . Pow ( 2 , n / 2 ) ) * doubleFactorial ( n - 1 ) ; if ( ( n / 2 ) % 2 == 1 ) number = number * - 1 ; return number ; } }
void find ( int n ) { int b = n ; int a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { Console . Write ( "a = " + a + ", b = " + b ) ; } else Console . WriteLine ( - 1 ) ; }
int SquareCube ( long N ) { int cnt = 0 , i = 1 ; while ( ( int ) ( Math . Pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }
long getSum ( int n , int d ) { long sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; }
bool isPerfect ( int N ) { if ( ( Math . Sqrt ( N ) - Math . Floor ( Math . Sqrt ( N ) ) ) != 0 ) return false ; return true ; }
void printThreeParts ( int N ) { if ( N % 3 == 0 ) Console . WriteLine ( " x = 1, y = 1, z = " + ( N - 2 ) ) ; else Console . WriteLine ( " x = 1, y = 2, z = " + ( N - 3 ) ) ; }
int sumX ( int N , int M , int K ) { for ( int i = 0 ; i < M ; i ++ ) { N = ( int ) sum ( K + N ) ; } N = N % MOD ; return N ; }
int countDigitsToBeRemoved ( int N , int K ) { string s = Convert . ToString ( N ) ; int res = 0 ; int f_zero = 0 ; for ( int i = s . Length - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s [ i ] == '0' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( K == 0 ) return res ; else if ( f_zero == 1 ) return s . Length - 1 ; return - 1 ; }
bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
int largestPalindrome ( int [ ] A , int n ) { Array . Sort ( A ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( isPalindrome ( A [ i ] ) ) return A [ i ] ; } return - 1 ; }
bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
int largestPalindrome ( int [ ] A , int n ) { int currentMax = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > currentMax && isPalindrome ( A [ i ] ) ) currentMax = A [ i ] ; } return currentMax ; }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
bool isPrime ( int N ) { for ( int i = 2 ; i <= Math . Sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; }
int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void printMode ( int [ ] a , int n ) { int max = a . Max ( ) ; int t = max + 1 ; int [ ] count = new int [ t ] ; for ( int i = 0 ; i < t ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int mode = 0 ; int k = count [ 0 ] ; for ( int i = 1 ; i < t ; i ++ ) { if ( count [ i ] > k ) { k = count [ i ] ; mode = i ; } } Console . WriteLine ( "mode = " + mode ) ; }
void checkTypeOfTriangle ( int a , int b , int c ) { int sqa = ( int ) Math . Pow ( a , 2 ) ; int sqb = ( int ) Math . Pow ( b , 2 ) ; int sqc = ( int ) Math . Pow ( c , 2 ) ; if ( sqa == sqa + sqb sqb == + == + sqb ) { Console . Write ( "Right-angled Triangle" ) ; } else if ( sqa > sqc + sqb sqb > + > + sqb ) { Console . Write ( "Obtuse-angled Triangle" ) ; } else { Console . Write ( "Acute-angled Triangle" ) ; } }
int findLargestDivisor ( int n ) { int m = n ; HashSet < int > s = new HashSet < int > ( ) ; s . Add ( 1 ) ; s . Add ( n ) ; for ( int i = 2 ; i < ( int ) Math . Sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) { s . Add ( n / i ) ; s . Add ( i ) ; while ( m % i == 0 ) m /= i ; } } if ( m > 1 ) s . Add ( m ) ; List < int > l = new List < int > ( s ) ; l . Sort ( ) ; l . Reverse ( ) ; List < int > vec = new List < int > ( ) ; for ( int i = 2 ; i <= MAX ; i ++ ) vec . Add ( i * i ) ; foreach ( int d in l ) { int divi = 0 ; for ( int j = 0 ; j < vec . Count && vec [ j ] <= d ; j ++ ) { if ( d % vec [ j ] == 0 ) { divi = 1 ; break ; } } if ( divi == 0 ) return d ; } return 0 ; }
int findLargestDivisor ( int n ) { for ( int i = 2 ; i < Math . Sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; }
double findMedian ( int [ ] a , int n ) { Array . Sort ( a ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
void printAMeans ( int A , int B , int N ) { float d = ( float ) ( B - A ) / ( N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( ( A + i * d ) + " " ) ; }
long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }
bool checkIsAP ( int [ ] arr , int n ) { if ( n == 1 ) return true ; Array . Sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
bool isTriPerfect ( int n ) { int sum = 1 + n ; int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else sum = sum + i + n / i ; } i += 1 ; } if ( sum == 3 * n & n != 1 ) return true ; else return false ; }
void findGreater ( int a , int b ) { double x = ( double ) a * ( double ) ( Math . Log ( ( double ) ( b ) ) ) ; double y = ( double ) b * ( double ) ( Math . Log ( ( double ) ( a ) ) ) ; if ( y > x ) { Console . Write ( "a^b is greater\n" ) ; } else if ( y < x ) { Console . Write ( "b^a is greater" + "\n" ) ; } else { Console . Write ( "Both are equal" ) ; } }
int sum ( int N , int X , int Y ) { int S1 , S2 , S3 ; S1 = ( ( N / X ) ) * ( 2 * X + ( N / X - 1 ) * X ) / 2 ; S2 = ( ( N / Y ) ) * ( 2 * Y + ( N / Y - 1 ) * Y ) / 2 ; S3 = ( ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }
long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
long modexp ( long x , long n ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , n / 2 ) ; } else { return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 ) % m ) ; } }
long getFractionModulo ( long a , long b ) { long c = gcd ( a , b ) ; a = a / c ; b = b / c ; long d = modexp ( b , m - 2 ) ; long ans = ( ( a % m ) * ( d % m ) ) % m ; return ans ; }
int startingPoint ( int Length , int Speed1 , int Speed2 ) { int result1 = 0 , result2 = 0 ; int time1 = Length / Speed1 ; int time2 = Length / Speed2 ; result1 = __gcd ( time1 , time2 ) ; result2 = time1 * time2 / ( result1 ) ; return result2 ; }
float firstTime ( int Length , int Speed1 , int Speed2 ) { float result = 0 ; int relativeSpeed = Math . Abs ( Speed1 - Speed2 ) ; result = ( ( float ) Length / relativeSpeed ) ; return result ; }
int findNumber ( int n ) { int i = n - 1 ; while ( i > 0 ) { if ( sumOfDigits ( i ) > sumOfDigits ( n ) ) return i ; i -- ; } return - 1 ; }
int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; }
int findNth ( int N ) { int b = 14 ; int i ; for ( i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; }
void icanobifNumbers ( int N ) { int first = 0 , second = 1 ; if ( N == 1 ) Console . Write ( first ) ; else if ( N == 2 ) Console . Write ( first + " " + second ) ; else { Console . Write ( first + " " + second + " " ) ; for ( int i = 3 ; i <= N ; i ++ ) { int x = reversDigits ( first ) ; int y = reversDigits ( second ) ; Console . Write ( x + y + " " ) ; int temp = second ; second = x + y ; first = temp ; } } }
int addNDigits ( int a , int b , int n ) { int num = a ; for ( int i = 0 ; i <= 9 ; i ++ ) { int tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return - 1 ; for ( int j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; }
void predictMatrix ( int [ , ] arr , int range1a , int range1b , int range0a , int range0b , int K , int [ , ] b ) { int c = 0 ; while ( K != 0 ) { K -- ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { c = 0 ; if ( i > 0 && arr [ i - 1 , j ] == 1 ) c ++ ; if ( j > 0 && arr [ i , j - 1 ] == 1 ) c ++ ; if ( i > 0 && j > 0 && arr [ i - 1 , j - 1 ] == 1 ) c ++ ; if ( i < N - 1 && arr [ i + 1 , j ] == 1 ) c ++ ; if ( j < N - 1 && arr [ i , j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j < N - 1 && arr [ i + 1 , j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j > 0 && arr [ i + 1 , j - 1 ] == 1 ) c ++ ; if ( i > 0 && j < N - 1 && arr [ i - 1 , j + 1 ] == 1 ) c ++ ; if ( arr [ i , j ] == 1 ) { if ( c >= range1a && c <= range1b ) b [ i , j ] = 1 ; else b [ i , j ] = 0 ; } if ( arr [ i , j ] == 0 ) { if ( c >= range0a && c <= range0b ) b [ i , j ] = 1 ; else b [ i , j ] = 0 ; } } } for ( int k = 0 ; k < N ; k ++ ) for ( int m = 0 ; m < N ; m ++ ) arr [ k , m ] = b [ k , m ] ; } }
int countMoves ( int n ) { int ct = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; }
int Triplets ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i ; j <= n ; ++ j ) { int x = i * i + j * j ; int y = ( int ) Math . Sqrt ( x ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; }
int countTriplets ( int n ) { ArrayList perfectSquares = getPerfectSquares ( ( int ) Math . Pow ( n , 2 ) ) ; int count = 0 ; for ( int a = 1 ; a <= n ; a ++ ) { int aSquare = ( int ) Math . Pow ( a , 2 ) ; for ( int i = 0 ; i < perfectSquares . Count ; i ++ ) { int cSquare = ( int ) perfectSquares [ i ] ; int bSquare = cSquare - aSquare ; int b = ( int ) Math . Sqrt ( bSquare ) ; int c = ( int ) Math . Sqrt ( cSquare ) ; if ( c < a || ! perfectSquares . Contains ( bSquare ) ) continue ; if ( ( b >= a ) && ( b <= c ) && ( aSquare + bSquare == cSquare ) ) count ++ ; } } return count ; }
void SumsOfDigits ( int n ) { int sum = 0 ; for ( int base1 = 2 ; base1 <= n / 2 ; ++ base1 ) sum += solve ( n , base1 ) ; Console . WriteLine ( sum ) ; }
int minimumMoves ( int k , int l , int r ) { int count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; }
bool checkPerfectcube ( int n ) { int d = ( int ) Math . Ceiling ( Math . Pow ( n , ( double ) 1 / 3 ) ) ; if ( d * d * d == n ) return true ; return false ; }
int largestNonPerfectcubeNumber ( int [ ] a , int n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkPerfectcube ( a [ i ] ) == false ) maxi = Math . Max ( a [ i ] , maxi ) ; } return maxi ; }
int sumNatural ( int n ) { int sum = ( n * ( n + 1 ) ) ; return sum ; }
void checkIfPossibleRec ( int x , int a , int b , bool [ ] isPossible , int n ) { if ( x > n ) return ; if ( isPossible [ x ] ) return ; isPossible [ x ] = true ; checkIfPossibleRec ( x + a , a , b , isPossible , n ) ; checkIfPossibleRec ( x + b , a , b , isPossible , n ) ; }
bool checkPossible ( int n , int a , int b ) { bool [ ] isPossible = new bool [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) isPossible [ i ] = false ; checkIfPossibleRec ( 0 , a , b , isPossible , n ) ; return isPossible [ n ] ; }
bool isDivisibleRec ( int x , int a , int b , int n ) { if ( x > n ) return false ; if ( n % x == 0 ) return true ; return ( isDivisibleRec ( x * 10 + a , a , b , n ) || isDivisibleRec ( x * 10 + b , a , b , n ) ) ; }
bool isDivisible ( int a , int b , int n ) { return isDivisibleRec ( a , a , b , n ) || isDivisibleRec ( b , a , b , n ) ; }
int sumOdd ( int n ) { int terms = ( n + 1 ) / 2 ; int sum = terms * terms ; return sum ; }
int suminRange ( int l , int r ) { return sumOdd ( r ) - sumOdd ( l - 1 ) ; }
int sumNatural ( int n ) { int sum = ( n * ( n + 1 ) ) / 2 ; return sum ; }
int suminRange ( int l , int r ) { return sumNatural ( r ) - sumNatural ( l - 1 ) ; }
bool CheckArray ( int [ ] arr , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; }
bool CheckArray ( int [ ] arr , int n ) { int prod = 1 ; ArrayList freq = new ArrayList ( ) ; for ( int i = 0 ; i < n ; ++ i ) { freq . Add ( arr [ i ] ) ; prod *= arr [ i ] ; } int root = ( int ) Math . Sqrt ( prod ) ; if ( root * root == prod ) { if ( freq . Contains ( root ) & freq . LastIndexOf ( root ) != ( freq . Count ) ) { return true ; } } return false ; }
long sumOfAllPalindrome ( int L , int R ) { long sum = 0 ; if ( L <= R ) for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) && isOddLength ( i ) ) { sum += i ; } } return sum ; }
bool divisibleBy25 ( string number ) { if ( number . Length < 2 ) return false ; int length = number . Length ; int lastTwo = ( number [ length - 2 ] - '0' ) * 10 + ( number [ length - 1 ] - '0' ) ; if ( lastTwo % 25 == 0 ) return true ; return false ; }
bool divisibleBy75 ( string number ) { if ( divisibleBy3 ( number ) && divisibleBy25 ( number ) ) return true ; return false ; }
int breakEvenPoint ( int exp1 , int S , int M ) { double earn = S - M ; double exp = exp1 ; double res = Math . Ceiling ( exp / earn ) ; int res1 = ( int ) res ; return res1 ; }
int otherNumber ( int A , int Lcm , int Hcf ) { return ( Lcm * Hcf ) / A ; }
int sum ( int a , int b ) { int sum = 0 ; for ( int i = 1 ; i <= Math . Min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; }
int sumcommDiv ( int a , int b ) { int n = gcd ( a , b ) ; int sum = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum += i ; else sum += ( n / i ) + i ; } } return sum ; }
int minimumNumbers ( int n , int s ) { if ( ( s % n ) > 0 ) return s / n + 1 ; else return s / n ; }
int search ( int [ ] arr , int strt , int end , int value ) { for ( int i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) return i ; } return - 1 ; }
int checkPostorder ( Node node , int [ ] postOrder , int index ) { if ( node == null ) return index ; index = checkPostorder ( node . left , postOrder , index ) ; index = checkPostorder ( node . right , postOrder , index ) ; if ( node . data == postOrder [ index ] ) index ++ ; else return - 1 ; return index ; }
int sumAP ( int n , int d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; }
int sumMultiples ( int A , int B , int n ) { n -- ; int common = ( A * B ) / __gcd ( A , B ) ; return sumAP ( n , A ) + sumAP ( n , B ) - sumAP ( n , common ) ; }
bool isPossible ( int N ) { if ( isPrime ( N ) && isPrime ( N - 2 ) ) return true ; else return false ; }
int totalPairs ( int [ ] arr1 , int [ ] arr2 , int K , int n , int m ) { HashSet < pair > s = new HashSet < pair > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] > arr2 [ j ] ) { if ( arr1 [ i ] % arr2 [ j ] == K ) s . Add ( new pair ( arr1 [ i ] , arr2 [ j ] ) ) ; } else { if ( arr2 [ j ] % arr1 [ i ] == K ) s . Add ( new pair ( arr2 [ j ] , arr1 [ i ] ) ) ; } } } return s . Count ; }
int contiguousPerfectSquare ( int [ ] arr , int n ) { int a ; float b ; int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b = ( float ) Math . Sqrt ( arr [ i ] ) ; a = ( int ) b ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = Math . Max ( max_length , current_length ) ; } return max_length ; }
double getSum ( int a , int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / Math . Pow ( a , i ) ) ; } return sum ; }
int getIndex ( int [ ] a , int n ) { if ( n == 1 ) return 0 ; int ptrL = 0 , ptrR = n - 1 , sumL = a [ 0 ] , sumR = a [ n - 1 ] ; while ( ptrR - ptrL > 1 ) { if ( sumL < sumR ) { ptrL ++ ; sumL += a [ ptrL ] ; } else if ( sumL > sumR ) { ptrR -- ; sumR += a [ ptrR ] ; } else { break ; } } return ptrL ; }
int getPosition ( int [ ] a , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] / m + ( a [ i ] % m ) ) ; } int ans = - 1 , max = - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( max < a [ i ] ) { max = a [ i ] ; ans = i ; } } return ans + 1 ; }
int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = Math . Max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) Math . Pow ( i , i ) ; int numerator = ( int ) Math . Pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
void generateNumbers ( int n , int num , int a , int b ) { if ( num > 0 && num < n ) st . Add ( num ) ; if ( num >= n ) return ; if ( num * 10 + a > num ) generateNumbers ( n , num * 10 + a , a , b ) ; generateNumbers ( n , num * 10 + b , a , b ) ; }
int findSmallest ( int [ ] arr , int n ) { int MAX = max_element ( arr ) ; ArrayList prime = findPrime ( MAX ) ; HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) s . Add ( arr [ i ] ) ; int ans = - 1 ; for ( int i = 0 ; i < prime . Count ; i ++ ) { if ( ! s . Contains ( ( int ) prime [ i ] ) ) { ans = ( int ) ( prime [ i ] ) ; break ; } } return ( int ) ans ; }
int minOperations ( int [ ] A , int n ) { if ( ( n & 1 ) > 0 ) return - 1 ; int zeros = 0 , consZeros = 0 , ones = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; }
int minimumCuts ( int [ ] a , int n ) { Array . Sort ( a ) ; int gcd = a [ 1 ] - a [ 0 ] ; int s = gcd ; for ( int i = 2 ; i < n ; i ++ ) { gcd = findgcd ( gcd , a [ i ] - a [ i - 1 ] ) ; s += a [ i ] - a [ i - 1 ] ; } if ( 360 - s > 0 ) gcd = findgcd ( gcd , 360 - s ) ; return ( 360 / gcd ) - n ; }
int countdig ( int m ) { if ( m == 0 ) return 0 ; else return 1 + countdig ( m / 10 ) ; }
int countSteps ( int x ) { int c = 0 ; int last = x ; while ( last > 0 ) { int digits = countdig ( last ) ; digits -= 1 ; int divisor = ( int ) Math . Pow ( 10 , digits ) ; int first = last / divisor ; int lastnumber = first * divisor ; int skipped = ( last - lastnumber ) / first ; skipped += 1 ; c += skipped ; last = last - ( first * skipped ) ; } return c ; }
int findNum ( int [ ] div , int [ ] rem , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }
void profitLoss ( int N , int M ) { if ( N == M ) Console . Write ( "No Profit nor Loss" ) ; else { float result = 0 ; result = ( float ) ( Math . Abs ( N - M ) ) / M ; if ( N - M < 0 ) Console . Write ( "Loss = -" + result * 100 + "%" ) ; else Console . Write ( "Profit = " + result * 100 + "%" ) ; } }
void niceIndices ( int [ ] A , int n ) { int sum = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( A [ i ] ) ) { var val = mp [ A [ i ] ] ; mp . Remove ( A [ i ] ) ; mp . Add ( A [ i ] , val + 1 ) ; sum += A [ i ] ; } else { mp . Add ( A [ i ] , 0 ) ; sum += A [ i ] ; } } for ( int i = 0 ; i < n ; ++ i ) { int k = sum - A [ i ] ; if ( k % 2 == 0 ) { k = k >> 1 ; if ( mp . ContainsKey ( k ) ) { if ( ( A [ i ] == k && mp [ k ] > 1 ) || ( A [ i ] != k ) ) Console . Write ( ( i + 1 ) + " " ) ; } } } }
void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
List < int > getFactorization ( int x ) { List < int > ret = new List < int > ( ) ; while ( x != 1 ) { int temp = spf [ x ] ; ret . Add ( temp ) ; while ( x % temp == 0 ) x = x / temp ; } return ret ; }
int maxElement ( int [ ] A , int n ) { sieve ( ) ; Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int j = 0 ; j < n ; ++ j ) { List < int > p = getFactorization ( A [ j ] ) ; for ( int i = 0 ; i < p . Count ; i ++ ) if ( m . ContainsKey ( p [ i ] ) ) m [ p [ i ] ] = m [ p [ i ] ] + 1 ; else m . Add ( p [ i ] , 1 ) ; } int cnt = 0 , ans = 10000000 ; foreach ( KeyValuePair < int , int > me in m ) { if ( me . Value >= cnt ) { cnt = me . Value ; if ( ans > me . Key ) ans = me . Key ; else ans = ans ; } } return ans ; }
int countPieces ( int N ) { return 2 * N ; }
float SellingPrice ( float CP , float PP ) { float P_decimal = 1 + ( PP / 100 ) ; float res = P_decimal * CP ; return res ; }
long sumMultiples ( long n ) { n -- ; return sumAP ( n , 3 ) + sumAP ( n , 7 ) - sumAP ( n , 21 ) ; }
bool productSumDivisible ( int n , int size ) { int sum = 0 , product = 1 ; while ( n > 0 ) { if ( size % 2 == 0 ) { product *= n % 10 ; } else { sum += n % 10 ; } n = n / 10 ; size -- ; } if ( product % sum == 0 ) { return true ; } return false ; }
long gcd ( long a , long b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; }
long powGCD ( long a , long n , long b ) { for ( int i = 0 ; i < n ; i ++ ) { a = a * a ; } return gcd ( a , b ) ; }
long power ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
long powerGCD ( long a , long b , long n ) { long e = power ( a , n , b ) ; return gcd ( e , b ) ; }
int lastCoordinate ( int n , int a , int b ) { return ( ( n + 1 ) / 2 ) * a - ( n / 2 ) * b ; }
bool allOddDigits ( int n ) { while ( n != 0 ) { if ( ( n % 10 ) % 2 == 0 ) return false ; n /= 10 ; } return true ; }
int largestNumber ( int n ) { if ( n % 2 == 0 ) n -- ; for ( int i = n ; ; i -= 2 ) if ( allOddDigits ( i ) ) return i ; }
int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } Console . Write ( "Sum = " + sum ) ; Console . Write ( "Product=" }
int findNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
bool isDivisiblePalindrome ( int n ) { int [ ] hash = new int [ 10 ] ; int digitSum = 0 ; while ( n != 0 ) { digitSum += n % 10 ; hash [ n % 10 ] ++ ; n /= 10 ; } if ( digitSum % 3 != 0 ) return false ; int oddCount = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( hash [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount > 1 ) return false ; else return true ; }
int countNumbers ( int N ) { return ( int ) ( Math . Sqrt ( N ) ) - 1 ; }
int countOrderedPairs ( int N ) { int count_pairs = 0 ; for ( int i = 1 ; i <= ( int ) Math . Sqrt ( N - 1 ) ; ++ i ) { for ( int j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= ( int ) ( Math . Sqrt ( N - 1 ) ) ; return count_pairs ; }
int toK ( int N , int K ) { int w = 1 ; int s = 0 ; while ( N != 0 ) { int r = N % K ; N = N / K ; s = r * w + s ; w *= 10 ; } return s ; }
void hasConsecutiveZeroes ( int N , int K ) { int z = toK ( N , K ) ; if ( check ( z ) ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
bool check ( int s ) { int [ ] freq = new int [ 10 ] ; int r , i ; for ( i = 0 ; i < 10 ; i ++ ) { freq [ i ] = 0 ; } while ( s != 0 ) { r = s % 10 ; s = ( int ) ( s / 10 ) ; freq [ r ] += 1 ; } int xor__ = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } return true ; }
int lcm ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; }
int dfs ( int src , List < int > [ ] adj , bool [ ] visited ) { visited [ src ] = true ; int count = 1 ; for ( int i = 0 ; i < adj [ src ] . Count ; i ++ ) if ( ! visited [ adj [ src ] [ i ] ] ) count += dfs ( adj [ src ] [ i ] , adj , visited ) ; return count ; }
int findMinTime ( int [ ] arr , int [ ] P , int n ) { List < int > [ ] adj = new List < int > [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) adj [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { adj [ arr [ i ] ] . Add ( P [ i ] ) ; } bool [ ] visited = new bool [ n + 1 ] ; int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { ans = lcm ( ans , dfs ( i , adj , visited ) ) ; } } return ans ; }
void SieveOfEratosthenes ( ) { prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } } }
void SieveOfEratosthenes ( ) { for ( int p = 2 ; p * p <= MAX ; p ++ ) if ( prime [ p ] == false ) for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; }
int superpower ( int n ) { SieveOfEratosthenes ( ) ; int superPower = 0 , factor = 0 ; int i = 2 ; while ( n > 1 && i <= MAX ) { if ( ! prime [ i ] ) { factor = 0 ; while ( n % i == 0 && n > 1 ) { factor ++ ; n = n / i ; } if ( superPower < factor ) superPower = factor ; } i ++ ; } return superPower ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int countPrime ( Node head_ref ) { int count = 0 ; Node ptr = head_ref ; while ( ptr != null ) { if ( isPrime ( ptr . data ) ) { count ++ ; } ptr = ptr . next ; } return count ; }
void pairwiseDifference ( int [ ] arr , int n ) { int diff ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff = Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ; Console . WriteLine ( diff + " " ) ; } }
int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
int npr ( int n , int r ) { int pnr = factorial ( n ) / factorial ( n - r ) ; return pnr ; }
int countPermutations ( int n , int r , int k ) { return factorial ( k ) * ( r - k + 1 ) * npr ( n - k , r - k ) ; }
long sumMultiples ( long n ) { n -- ; return sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ; }
int GIF ( double n ) { return ( int ) Math . Floor ( n ) ; }
int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
int smallestDivisor ( int n ) { if ( n % 2 == 0 ) return 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }
int countRabbits ( int Heads , int Legs ) { int count = 0 ; count = ( Legs ) - 2 * ( Heads ) ; count = count / 2 ; return count ; }
int compositeProduct ( int [ ] arr , int n ) { int max_val = arr . Max ( ) ; bool [ ] prime = new bool [ max_val + 1 ] ; for ( int i = 0 ; i < max_val + 1 ; i ++ ) prime [ i ] = true ; prime [ 0 ] = true ; prime [ 1 ] = true ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) { prime [ i ] = false ; } } } int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! prime [ arr [ i ] ] ) { product *= arr [ i ] ; } } return product ; }
int markingScheme ( int N , int [ ] answerKey , int [ ] studentAnswer ) { int positive = 0 , negative = 0 , notattempt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( studentAnswer [ i ] == 0 ) notattempt ++ ; else if ( answerKey [ i ] == studentAnswer [ i ] ) positive ++ ; else if ( answerKey [ i ] != studentAnswer [ i ] ) negative ++ ; } return ( positive * 3 ) + ( negative * - 1 ) ; }
bool SumDivisible ( int n , int k ) { int sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = n / 10 ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; }
int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f = f * i ; return f ; }
int waysOfConsonants ( int size1 , int [ ] freq ) { int ans = fact ( size1 ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) continue ; else ans = ans / fact ( freq [ i ] ) ; } return ans ; }
int waysOfVowels ( int size2 , int [ ] freq ) { return fact ( size2 ) / ( fact ( freq [ 0 ] ) * fact ( freq [ 4 ] ) * fact ( freq [ 8 ] ) * fact ( freq [ 14 ] ) * fact ( freq [ 20 ] ) ) ; }
int countWays ( string str ) { int [ ] freq = new int [ 200 ] ; for ( int i = 0 ; i < 200 ; i ++ ) freq [ i ] = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) freq [ str [ i ] - 'a' ] ++ ; int vowel = 0 , consonant = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] != 'a' && str [ i ] != 'e' && str [ i ] != 'i' && str [ i ] != 'o' && str [ i ] != 'u' ) consonant ++ ; else vowel ++ ; } return waysOfConsonants ( consonant + 1 , freq ) * waysOfVowels ( vowel , freq ) ; }
int findX ( int n , int k ) { int r = n , v , u ; int m = ( int ) Math . Sqrt ( k ) + 1 ; for ( int i = 2 ; i <= m && k > 1 ; i ++ ) { if ( i == m ) { i = k ; } for ( u = v = 0 ; k % i == 0 ; v ++ ) { k /= i ; } if ( v > 0 ) { int t = n ; while ( t > 0 ) { t /= i ; u += t ; } r = Math . Min ( r , u / v ) ; } } return r ; }
int ncr ( int n , int r ) { int ncr = fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; return ncr ; }
void maxSum ( int [ ] a , int n ) { int maxAnd = a . Max ( ) ; int maxOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxOR |= a [ i ] ; } Console . Write ( ( maxAnd + maxOR ) ) ; }
int sum_odd ( int n ) { int sum = 0 , pos = 1 ; while ( n > 0 ) { if ( pos % 2 == 1 ) sum += n % 10 ; n = n / 10 ; pos ++ ; } return sum ; }
bool check_prime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
double calculateSum ( double n ) { return 2 * ( Math . Pow ( n , 6 ) + 15 * Math . Pow ( n , 4 ) + 15 * Math . Pow ( n , 2 ) + 1 ) ; }
int solve ( int n ) { int count = 0 , num = 1 ; int prod = 1 ; while ( count < n ) { if ( ! prime [ num ] ) { prod *= num ; count ++ ; } num ++ ; } return prod ; }
void ReplaceElements ( int [ ] arr , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) { prod *= arr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = prod / arr [ i ] ; } }
int sum ( int n ) { if ( n == 0 ) return 0 ; if ( n % 2 == 1 ) { return square ( ( n + 1 ) / 2 ) + sum ( n / 2 ) ; } else { return square ( n / 2 ) + sum ( n / 2 ) ; } }
int oddDivSum ( int a , int b ) { return sum ( b ) - sum ( a - 1 ) ; }
int countBits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n >>= 1 ; } return count ; }
bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= Math . Sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
bool isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = Math . Log ( a ) / Math . Log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; }
bool isAchillesNumber ( int n ) { if ( isPowerful ( n ) && ! isPower ( n ) ) return true ; else return false ; }
int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; ++ i ) { int divCount = 0 ; for ( int j = 1 ; j <= i ; ++ j ) { if ( i % j == 0 ) { ++ divCount ; } } if ( ( divCount % 2 ) != 0 ) { ++ res ; } } return res ; }
int divisor ( int a ) { int div = 1 , count = 0 ; for ( int i = 2 ; i <= Math . Sqrt ( a ) ; i ++ ) { while ( a % i == 0 ) { count ++ ; a = a / i ; } div = div * ( count + 1 ) ; count = 0 ; } if ( a > 1 ) { div = div * ( 2 ) ; } return div ; }
int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; ++ i ) { int divCount = divisor ( i ) ; if ( divCount % 2 == 1 ) { ++ res ; } } return res ; }
bool Check_is_possible ( int l , int r , int k ) { int div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; }
bool isValid ( long N , int K ) { HashSet < long > m1 = new HashSet < long > ( ) ; HashSet < int > m2 = new HashSet < int > ( ) ; while ( N > 0 ) { m1 . Add ( N % 10 ) ; N /= 10 ; } while ( K > 0 ) { m2 . Add ( K % 10 ) ; K /= 10 ; } if ( m1 . Equals ( m2 ) ) { return true ; } return false ; }
double largestSquareFactor ( double num ) { double answer = 1 ; for ( int i = 2 ; i < Math . Sqrt ( num ) ; ++ i ) { int cnt = 0 ; int j = i ; while ( num % j == 0 ) { cnt ++ ; j *= i ; } if ( ( cnt & 1 ) != 0 ) { cnt -- ; answer *= Math . Pow ( i , cnt ) ; } else { answer *= Math . Pow ( i , cnt ) ; } } return answer ; }
double nth_group ( int n ) { return n * ( 2 * Math . Pow ( n , 2 ) + 1 ) ; }
bool checkUnusual ( int n ) { int factor = largestPrimeFactor ( n ) ; if ( factor > Math . Sqrt ( n ) ) { return true ; } else { return false ; } }
void printPossible ( int a , int b , int c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) Console . Write ( "NO" ) ; else Console . Write ( "YES" ) ; }
int isChangeable ( int [ ] notes , int n ) { int fiveCount = 0 ; int tenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) fiveCount ++ ; else if ( notes [ i ] == 10 ) { if ( fiveCount > 0 ) { fiveCount -- ; tenCount ++ ; } else return 0 ; } else { if ( fiveCount > 0 && tenCount > 0 ) { fiveCount -- ; tenCount -- ; } else if ( fiveCount >= 3 ) { fiveCount -= 3 ; } else return 0 ; } } return 1 ; }
int sumSubarrayMins ( int [ ] A , int n ) { int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; Stack < pair > s1 = new Stack < pair > ( ) ; Stack < pair > s2 = new Stack < pair > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { int cnt = 1 ; while ( s1 . Count != 0 && ( s1 . Peek ( ) . first ) > A [ i ] ) { cnt += s1 . Peek ( ) . second ; s1 . Pop ( ) ; } s1 . Push ( new pair ( A [ i ] , cnt ) ) ; left [ i ] = cnt ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { int cnt = 1 ; while ( s2 . Count != 0 && ( s2 . Peek ( ) . first ) >= A [ i ] ) { cnt += s2 . Peek ( ) . second ; s2 . Pop ( ) ; } s2 . Push ( new pair ( A [ i ] , cnt ) ) ; right [ i ] = cnt ; } int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) result = ( result + A [ i ] * left [ i ] * right [ i ] ) ; return result ; }
bool isPerfectPower ( int n ) { if ( n == 1 ) { return true ; } for ( int x = 2 ; x <= Math . Sqrt ( n ) ; x ++ ) { int y = 2 ; int p = ( int ) Math . Pow ( x , y ) ; while ( p <= n && p > 0 ) { if ( p == n ) { return true ; } y ++ ; p = ( int ) Math . Pow ( x , y ) ; } } return false ; }
bool isTrojan ( int n ) { if ( ! isPerfectPower ( n ) && isStrongNumber ( n ) ) { return true ; } else { return false ; } }
double Nth_Term ( int n ) { return ( 2 * Math . Pow ( n , 3 ) - 3 * Math . Pow ( n , 2 ) + n + 6 ) / 6 ; }
int Sum_upto_nth_Term ( int n ) { return ( 1 - ( int ) System . Math . Pow ( - 2 , n ) ) ; }
int Nth_Term ( int n ) { return ( int ) ( 3 * System . Math . Pow ( n , 2 ) - n + 2 ) / ( 2 ) ; }
void countPermutations ( int N , int B ) { int x = ( int ) Math . Pow ( B , N ) ; int y = ( int ) Math . Pow ( B , N - 1 ) ; Console . WriteLine ( x - y ) ; }
int calculateDifference ( int [ ] arr , int n ) { int max_val = arr . Max ( ) ; var prime = Enumerable . Repeat ( true , max_val + 1 ) . ToArray ( ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int P1 = 1 , P2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { P1 *= arr [ i ] ; } else if ( arr [ i ] != 1 ) { P2 *= arr [ i ] ; } } return Math . Abs ( P2 - P1 ) ; }
int CalculateDifference ( int [ ] arr , int n ) { int max_val = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_val ) max_val = arr [ i ] ; } bool [ ] prime = new bool [ max_val + 1 ] ; for ( int i = 0 ; i <= max_val ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int S1 = 0 , S2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { S1 += arr [ i ] ; } else if ( arr [ i ] != 1 ) { S2 += arr [ i ] ; } } return Math . Abs ( S2 - S1 ) ; }
int EqualNumbers ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n != 0 ) return n - 1 ; return n ; }
int getMin ( int [ ] arr , int n , int k ) { int res = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { res = Math . Min ( res , arr [ i ] ) ; } } return res ; }
int getMax ( int [ ] arr , int n , int k ) { int res = int . MinValue ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { res = Math . Max ( res , arr [ i ] ) ; } } return res ; }
void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) Console . Write ( "-1" ) ; else { Console . Write ( d ) ; k -- ; while ( k -- > 0 ) Console . Write ( "0" ) ; } }
int count_odd_pair ( int n , int [ ] a ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } int ans = odd * even * 2 ; return ans ; }
int count_even_pair ( int odd_sum_pairs , int n ) { int total_pairs = ( n * ( n - 1 ) ) ; int ans = total_pairs - odd_sum_pairs ; return ans ; }
int findSteps ( int n , int m , int [ ] a ) { int cur = 1 ; int steps = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; }
int xorEqualsOrCount ( int N ) { int count = 0 ; int bit ; while ( N > 0 ) { bit = N % 2 ; if ( bit == 0 ) count ++ ; N = N / 2 ; } return ( int ) Math . Pow ( 2 , count ) ; }
int fact ( int n ) { if ( n == 1 ) return 1 ; return n * fact ( n - 1 ) ; }
double sum ( int x , int n ) { double total = 1.0 ; for ( int i = 1 ; i <= n ; i ++ ) { total = total + ( Math . Pow ( x , i ) / fact ( i + 1 ) ) ; } return total ; }
double sum ( int x , int n ) { double total = 1.0 ; double previous = 1.0 ; for ( int i = 1 ; i <= n ; i ++ ) { previous = ( ( previous * x ) / ( i + 1 ) ) ; total = total + previous ; } return total ; }
bool isPowerOfTwo ( int x ) { return ( x > 0 && ( ! ( ( x & ( x - 1 ) ) > 0 ) ) ) ; }
void Count_pairs ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) ) count ++ ; } int ans = ( count * ( count - 1 ) ) / 2 ; Console . WriteLine ( ans ) ; }
int numberOfDivisors ( int num ) { int c = 0 ; for ( int i = 1 ; i <= num ; i ++ ) { if ( num % i == 0 ) { c += 1 ; } } return c ; }
int countNumbers ( int n ) { int c = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( numberOfDivisors ( i ) == 9 ) c += 1 ; } return c ; }
int countNumbers ( int n ) { int c = 0 ; int limit = ( int ) Math . Sqrt ( n ) ; int [ ] prime = new int [ limit + 1 ] ; for ( int i = 1 ; i <= limit ; i ++ ) { prime [ i ] = i ; } for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( prime [ i ] == i ) { for ( int j = i * i ; j <= limit ; j += i ) { if ( prime [ j ] == j ) { prime [ j ] = i ; } } } } for ( int i = 2 ; i <= limit ; i ++ ) { int p = prime [ i ] ; int q = prime [ i / prime [ i ] ] ; if ( p * q == i && q != 1 && p != q ) { c += 1 ; } else if ( prime [ i ] == i ) { if ( Math . Pow ( i , 8 ) <= n ) { c += 1 ; } } } return c ; }
int sumNth ( int [ ] A , int [ ] B , int m , int n ) { int res = 0 ; if ( n == 1 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + A [ i ] ; } else if ( n == 2 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + B [ i ] * m ; } else { int [ ] f = new int [ n ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; for ( int i = 0 ; i < m ; i ++ ) { res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ; } } return res ; }
int factorial ( int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = result * i ; return result ; }
int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
int calculate_result ( int n ) { int result = 2 * nCr ( ( n - 2 ) , ( n / 2 - 1 ) ) ; return result ; }
void isHalfReducible ( int [ ] arr , int n , int m ) { int [ ] frequencyHash = new int [ m + 1 ] ; int i ; for ( i = 0 ; i < frequencyHash . Length ; i ++ ) frequencyHash [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { frequencyHash [ arr [ i ] % ( m + 1 ) ] ++ ; } for ( i = 0 ; i <= m ; i ++ ) { if ( frequencyHash [ i ] >= n / 2 ) break ; } if ( i <= m ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
void generateDivisors ( int n ) { for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) arr . Add ( i ) ; { arr . Add ( i ) ; arr . Add ( n / i ) ; } } } }
double harmonicMean ( int n ) { generateDivisors ( n ) ; double sum = 0.0 ; int len = arr . Count ; for ( int i = 0 ; i < len ; i ++ ) sum = sum + n / ( int ) arr [ i ] ; sum = sum / n ; return arr . Count / sum ; }
bool isOreNumber ( int n ) { double mean = harmonicMean ( n ) ; if ( mean - Math . Floor ( mean ) == 0 ) return true ; else return false ; }
int sum_of_series ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - ( int ) Math . Pow ( i , 2 ) ; else result = result + ( int ) Math . Pow ( i , 2 ) ; } return result ; }
int sum_of_series ( int n ) { int result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }
int digitProduct ( int [ ] digits , int start , int end ) { int pro = 1 ; for ( int i = start ; i <= end ; i ++ ) { pro *= digits [ i ] ; } return pro ; }
int numberOfDistinct ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) prime [ i ] = true ; for ( int i = 0 ; i <= MAX ; i ++ ) sum [ i ] = 0 ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( int i = 1 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) sum [ i ] = 1 ; sum [ i ] += sum [ i - 1 ] ; } }
double calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int [ ] fibo = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; double sum = Math . Pow ( fibo [ 0 ] , 2 ) + Math . Pow ( fibo [ 1 ] , 2 ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; }
int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
void ulam ( ) { arr . Add ( 1 ) ; arr . Add ( 2 ) ; for ( int i = 3 ; i < MAX ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr . Count - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr . Count ; k ++ ) { if ( arr [ j ] + arr [ k ] == i ) { count ++ ; } if ( count > 1 ) break ; } if ( count > 1 ) break ; } if ( count == 1 ) { arr . Add ( i ) ; } } }
long nthKyneaNumber ( int n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; }
long nthKyneaNumber ( int n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; }
bool isProthNumber ( int n ) { int k = 1 ; while ( k < ( n / k ) ) { if ( n % k == 0 ) { if ( isPowerOfTwo ( n / k ) ) return true ; } k = k + 2 ; } return false ; }
bool isInterprime ( int n ) { if ( n < 4 ) return false ; int prev_prime = n ; int next_prime = n ; while ( ! isPrime ( prev_prime ) ) { prev_prime -- ; } while ( ! isPrime ( next_prime ) ) { next_prime ++ ; } if ( ( prev_prime + next_prime ) == 2 * n ) return true ; else return false ; }
bool isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; }
bool isThabitNumber ( int n ) { n = n + 1 ; if ( n % 3 == 0 ) n = n / 3 ; else return false ; if ( isPowerOfTwo ( n ) ) return true ; else return false ; }
int get_last_two_digit ( long N ) { if ( N <= 10 ) { long ans = 0 , fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ( int ) ans % 100 ; } return 13 ; }
bool isProductEven ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; }
int calculateSquareSum ( int n ) { if ( n <= 0 ) return 0 ; int [ ] fibo = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; }
int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] > 0 ) return f [ n ] ; int k = ( ( n & 1 ) > 0 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( ( n & 1 ) > 0 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
int calculateSumOfSquares ( int n ) { return fib ( n ) * fib ( n + 1 ) ; }
void sieve ( ) { int [ ] arr = new int [ N + 1 ] ; arr [ 0 ] = 1 ; arr [ 1 ] = 1 ; for ( int i = 2 ; i <= Math . Sqrt ( N ) ; i ++ ) if ( arr [ i ] == 0 ) for ( int j = i * i ; j <= N ; j += i ) arr [ j ] = 1 ; long runningPrimeSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] == 0 ) runningPrimeSum += i ; dp [ i ] = runningPrimeSum ; } }
int fnMod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; }
int MinimumMoves ( int [ ] a , int n , int x ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { int p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ; ans += p ; a [ i ] += p * x ; } } return ans ; }
int SumOfDigits ( String str , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( str [ i ] - '0' ) ; return sum ; }
bool isPrime ( int k ) { if ( k <= 1 ) return false ; for ( int i = 2 ; i < k ; i ++ ) if ( k % i == 0 ) return false ; return true ; }
int check ( int num , int k ) { int flag = 1 ; for ( int i = 2 ; i < k ; i ++ ) { if ( num % i == 0 ) flag = 0 ; } if ( flag == 1 ) { if ( num % k == 0 ) return 1 ; else return 0 ; } else return 0 ; }
int findCount ( int a , int b , int k ) { int count = 0 ; if ( ! isPrime ( k ) ) return 0 ; else { int ans ; for ( int i = a ; i <= b ; i ++ ) { ans = check ( i , k ) ; if ( ans == 1 ) count ++ ; else continue ; } } return count ; }
int findMinEqualSums ( int [ ] a , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; } int sum1 = 0 , sum2 = 0 ; int min = int . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { sum1 += a [ i ] ; sum2 = sum - sum1 ; if ( Math . Abs ( sum1 - sum2 ) < min ) { min = Math . Abs ( sum1 - sum2 ) ; } if ( min == 0 ) { break ; } } return min ; }
void SieveOfEratosthenes ( ) { bool [ ] prime = new bool [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . Add ( p ) ; }
bool isEuclid ( long n ) { long product = 1 ; int i = 0 ; while ( product < n ) { product = product * arr [ i ] ; if ( product + 1 == n ) return true ; i ++ ; } return false ; }
bool isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; }
int NumberOfSolutions ( int x , int y , int z , int n ) { int ans = 0 ; for ( int i = 0 ; i <= x ; i ++ ) { for ( int j = 0 ; j <= y ; j ++ ) { int temp = n - i - j ; if ( temp >= 0 ) { temp = Math . Min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; }
int solve ( int n ) { int count = 0 , num = 1 ; long sum = 0 ; while ( count < n ) { if ( prime [ num ] ) { sum += num ; count ++ ; } num ++ ; } return ( int ) sum ; }
long fact ( int p ) { if ( p <= 1 ) return 1 ; return p * fact ( p - 1 ) ; }
int findNum ( int n , int a , int b ) { int result = 0 ; int aCount = 0 ; int bCount = 0 ; return ( int ) findNumUtil ( result , a , aCount , b , bCount , n ) ; }
void findkth ( int n , int k ) { List < int > v1 = new List < int > ( ) ; List < int > v2 = new List < int > ( ) ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v1 . Add ( i ) ; if ( i != Math . Sqrt ( n ) ) v2 . Add ( n / i ) ; } } v2 . Reverse ( ) ; if ( k > ( v1 . Count + v2 . Count ) ) Console . Write ( "Doesn't Exist" ) ; else { if ( k <= v1 . Count ) Console . Write ( v1 [ k - 1 ] ) ; else Console . Write ( v2 [ k - v1 . Count - 1 ] ) ; } }
int NumberOfSolutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= Math . Max ( c , i + 1 ) ) ans += d - Math . Max ( c , i + 1 ) + 1 ; return ans ; }
double CountDigits ( int n ) { if ( n == 1 ) return 1 ; double sum = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { sum += ( ( double ) Math . Log ( i ) / ( double ) Math . Log ( 10 ) ) ; } sum *= n ; return Math . Ceiling ( sum ) ; }
string findNumber ( int n , int d ) { string ans = "" ; if ( d != 10 ) { ans += d . ToString ( ) ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } else { if ( n == 1 ) ans += "Impossible" ; else { ans += '1' ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } } return ans ; }
void countDigits ( double val , long [ ] arr ) { while ( ( long ) val > 0 ) { long digit = ( long ) val % 10 ; arr [ ( int ) digit ] ++ ; val = ( long ) val / 10 ; } return ; }
void countFrequency ( int x , int n ) { long [ ] freq_count = new long [ 10 ] ; for ( int i = 1 ; i <= n ; i ++ ) { double val = Math . Pow ( ( double ) x , ( double ) i ) ; countDigits ( val , freq_count ) ; } for ( int i = 0 ; i <= 9 ; i ++ ) { Console . Write ( freq_count [ i ] + " " ) ; } }
void form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }
int nthTerm ( int n ) { return ( int ) Math . Pow ( n , 2 ) + 4 * n ; }
long NthTerm ( long n ) { long x = ( 3 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; }
void PowerOfTwo ( ) { int x = 1 ; for ( int i = 0 ; i < 31 ; i ++ ) { power [ i ] = x ; x *= 2 ; } pre [ 0 ] = 1 ; for ( int i = 1 ; i < 31 ; i ++ ) pre [ i ] = pre [ i - 1 ] + power [ i ] ; }
int Sum ( int n ) { int ans = n * ( n + 1 ) / 2 ; for ( int i = 0 ; i < 31 ; i ++ ) { if ( power [ i ] > n ) { ans -= 2 * pre [ i - 1 ] ; break ; } } return ans ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
bool checkSemiPrime ( int n ) { int i = 0 ; while ( arr [ i ] <= n / 2 ) { if ( sprime [ n - arr [ i ] ] ) { return true ; } i ++ ; } return false ; }
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; }
int nextGreater ( int N ) { int power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; }
float area ( float r ) { if ( r < 0 ) return - 1 ; float area = ( float ) ( 3.14 * Math . Pow ( r / ( 2 * Math . Sqrt ( 2 ) ) , 2 ) ) ; return area ; }
float area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) Math . Pow ( ( a * Math . Sqrt ( 3 ) ) / ( Math . Sqrt ( 2 ) ) , 2 ) ; return area ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < N ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < N ; i += p ) prime [ i ] = false ; } } }
int almostPrimes ( int n ) { int ans = 0 ; for ( int i = 6 ; i <= n ; i ++ ) { int c = 0 ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) { if ( prime [ j ] ) c ++ ; } else { if ( prime [ j ] ) c ++ ; if ( prime [ i / j ] ) c ++ ; } } } if ( c == 2 ) ans ++ ; } return ans ; }
float heightCalculate ( int H , int n , int m ) { float N = ( float ) ( n * 1.0 ) ; float M = ( float ) ( m * 1.0 ) ; float h = H * ( float ) Math . Sqrt ( N / ( N + M ) ) ; return h ; }
int numberOfSolutions ( int n ) { int c = 0 ; for ( int x = 0 ; x <= n ; ++ x ) if ( n == x + ( n ^ x ) ) ++ c ; return c ; }
int findNumber ( int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int [ ] count = new int [ 10 ] ; / * int x = ; int count1 = 0 , count2 = 0 ; while ( x > 0 ) { count [ x % 10 ] ++ ; x /= 10 ; count1 ++ ; } for ( int j = 0 ; j < 10 ; j ++ ) { if ( count [ j ] == 1 ) count2 ++ ; } if ( count1 == count2 ) return i ; } return - 1 ; }
bool isprime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; }
bool isNSqMinusnMSqPrime ( int m , int n ) { if ( n - m == 1 && isprime ( m + n ) ) return true ; else return false ; }
int countNumbers ( int N ) { return ( int ) ( Math . Pow ( 10 , N ) - Math . Pow ( 8 , N ) ) / 2 ; }
void buildPrefix ( ) { bool [ ] prime = new bool [ MAX + 1 ] ; for ( int i = 0 ; i < MAX + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( int p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] == true ) prefix [ p ] += p ; } }
int sumPrimeRange ( int L , int R ) { buildPrefix ( ) ; return prefix [ R ] - prefix [ L - 1 ] ; }
int findPosition ( int n , int f , int b ) { return n - Math . Max ( f + 1 , n - b ) + 1 ; }
int nthOdd ( int n ) { return ( 2 * n - 1 ) ; }
int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
int countSolutions ( int a ) { int count = bitCount ( a ) ; count = ( int ) System . Math . Pow ( 2 , count ) ; return count ; }
bool isPermutation ( Node first , Node second ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; Node temp1 = first ; while ( temp1 != null ) { sum1 += temp1 . data ; mul1 *= temp1 . data ; temp1 = temp1 . next ; } Node temp2 = second ; while ( temp2 != null ) { sum2 += temp2 . data ; mul2 *= temp2 . data ; temp2 = temp2 . next ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; }
void SieveOfEratosthenes ( int n , bool [ ] isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
void findPrimePair ( int n ) { int flag = 0 ; bool [ ] isPrime = new bool [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 2 ; i < n ; i ++ ) { int x = n / i ; if ( isPrime [ i ] && isPrime [ x ] && x != i && x * i == n ) { Console . Write ( i + " " + x ) ; flag = 1 ; return ; } } if ( flag == 0 ) Console . Write ( "No such pair found" ) ; }
void solveProportion ( int a , int b1 , int b2 , int c ) { int A = a * b2 ; int B = b1 * b2 ; int C = b1 * c ; int gcd = __gcd ( __gcd ( A , B ) , C ) ; Console . Write ( A / gcd + ":" + B / gcd + ":" + C / gcd ) ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 2 ) + n - 3 ; }
int nthTerm ( int n ) { return 5 * ( int ) Math . Pow ( n , 2 ) - 5 * n ; }
int nthTerm ( int n ) { return 3 * ( int ) Math . Pow ( n , 2 ) + 2 * n - 5 ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 2 ) + 3 * n - 5 ; }
int nthTerm ( int n ) { return 3 * ( int ) Math . Pow ( n , 2 ) - 4 * n + 2 ; }
int nthTerm ( int n ) { return 4 * ( int ) Math . Pow ( n , 2 ) - 3 * n + 2 ; }
bool isProduct ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; }
void findNumbers ( int N ) { List < int > vec = new List < int > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isProduct ( i ) && ! isPerfectSquare ( i ) ) { vec . Add ( i ) ; } } foreach ( var a in vec ) Console . Write ( a + " " ) ; }
int countDivisors ( int n , int k ) { int count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 3 ) + ( int ) Math . Pow ( n , 2 ) ; }
void calculateSum ( int n ) { double r = ( n * ( n + 1 ) / 2 + Math . Pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ) ; Console . WriteLine ( "Sum = " + r ) ; }
float volume ( float r , float h ) { return ( float ) 1 / 3 * pi * h * r * r ; }
int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
int maxDistance ( int [ ] arr , int n ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! map . ContainsKey ( arr [ i ] ) ) map . Add ( arr [ i ] , i ) ; else max_dist = Math . Max ( max_dist , i - map [ arr [ i ] ] ) ; } return max_dist ; }
int calculateSum ( int n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 2 ) - n - 1 ; }
int nthTerm ( int n ) { return 6 * ( int ) Math . Pow ( n , 2 ) - 4 * n - 2 ; }
int nthTerm ( int n ) { return 4 * ( int ) Math . Pow ( n , 2 ) - 7 * n + 3 ; }
int nthTerm ( int n ) { return ( int ) Math . Pow ( n , 2 ) + 2 * n + 2 ; }
void checkSolution ( int a , int b , int c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) Console . WriteLine ( "2 solutions" ) ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) Console . WriteLine ( "1 solution" ) ; else Console . WriteLine ( "No solutions" ) ; }
long Bytes ( int kilobytes ) { long Bytes = 0 ; Bytes = kilobytes * 1024 ; return Bytes ; }
long NthTerm ( long n ) { long x = ( 2 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; }
int sum ( int n ) { int ans = ( n * ( n - 1 ) ) / 2 ; return ans ; }
long getNthTerm ( long N ) { return ( ( int ) Math . Pow ( N , 2 ) + N + 1 ) ; }
int findSum ( int N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; }
long getNthTerm ( long N ) { return 4 * ( long ) Math . Pow ( N , 2 ) - 3 * N + 2 ; }
double findCosNTheta ( double sinTheta , int n ) { double cosTheta = Math . Sqrt ( 1 - sinTheta * sinTheta ) ; double ans = 0 ; long toggle = 1 ; for ( int i = 1 ; i <= n ; i += 2 ) { ans = ans + nCr [ n , i ] * Math . Pow ( cosTheta , n - i ) * Math . Pow ( sinTheta , i ) * toggle ; toggle = toggle * - 1 ; } return ans ; }
long findSum ( int n ) { long sum2 , sum5 , sum10 ; sum2 = ( ( n / 2 ) * ( 4 + ( n / 2 - 1 ) * 2 ) ) / 2 ; sum5 = ( ( n / 5 ) * ( 10 + ( n / 5 - 1 ) * 5 ) ) / 2 ; sum10 = ( ( n / 10 ) * ( 20 + ( n / 10 - 1 ) * 10 ) ) / 2 ; return sum2 + sum5 - sum10 ; }
int nthTerm ( int N ) { return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; }
int nthTerm ( int N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; }
void binomial ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i , j ] = 1 ; else nCr [ i , j ] = nCr [ i - 1 , j ] + nCr [ i - 1 , j - 1 ] ; } } }
double findTanNTheta ( double tanTheta , int n ) { double ans = 0 , numerator = 0 , denominator = 0 ; long toggle = 1 ; for ( int i = 1 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n , i ] * Math . Pow ( tanTheta , i ) * toggle ; toggle = toggle * - 1 ; } denominator = 1 ; toggle = - 1 ; for ( int i = 2 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n , i ] * Math . Pow ( tanTheta , i ) * toggle ; toggle = toggle * - 1 ; } ans = numerator / denominator ; return ans ; }
int product ( int n ) { v . Clear ( ) ; for ( int i = 0 ; i < n + 100 ; i ++ ) v . Add ( new List < int > ( ) ) ; factors ( n + 100 ) ; if ( n % 4 == 0 ) { int x = n / 4 ; x *= x ; return x * x ; } else { if ( isPrime ( n ) ) return - 1 ; else { int ans = - 1 ; if ( v [ n ] . Count > 2 ) { int fac = v [ n ] [ v [ n ] . Count - 3 ] ; for ( int i = v [ n ] . Count - 1 ; i >= 0 ; i -- ) { for ( int j = v [ n ] . Count - 1 ; j >= 0 ; j -- ) { if ( ( fac * 2 ) + ( v [ n ] [ j ] + v [ n ] [ i ] ) == n ) ans = Math . Max ( ans , fac * fac * v [ n ] [ j ] * v [ n ] [ i ] ) ; } } return ans ; } } } return 0 ; }
bool arePermutations ( int [ ] a , int [ ] b , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; }
void binomial ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i , j ] = 1 ; else nCr [ i , j ] = nCr [ i - 1 , j ] + nCr [ i - 1 , j - 1 ] ; } } }
double findCosnTheta ( double cosTheta , int n ) { double sinTheta = Math . Sqrt ( 1 - cosTheta * cosTheta ) ; double ans = 0 ; int toggle = 1 ; for ( int i = 0 ; i <= n ; i += 2 ) { ans = ans + nCr [ n , i ] * Math . Pow ( cosTheta , n - i ) * Math . Pow ( sinTheta , i ) * toggle ; toggle = toggle * - 1 ; } return ans ; }
float CalculateRatio ( float m , float n ) { return ( 2 * m - 1 ) / ( 2 * n - 1 ) ; }
long power ( long x , long y , long p ) { long res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
long sumProd ( long n , long t ) { long dino = power ( t + 1 , MOD - 2 , MOD ) ; long ans = 1 ; for ( long i = n + t + 1 ; i > n ; -- i ) ans = ( ans % MOD * i % MOD ) % MOD ; long tfact = 1 ; for ( int i = 1 ; i <= t ; ++ i ) tfact = ( tfact * i ) % MOD ; ans = ans * dino - tfact + MOD ; return ans % MOD ; }
int sumOfDigitsSingle ( int x ) { int ans = 0 ; while ( x != 0 ) { ans += x % 10 ; x /= 10 ; } return ans ; }
int sumOfDigitsTwoParts ( int N ) { int A = closest ( N ) ; return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) ; }
int nextPerfectCube ( int N ) { int nextN = ( int ) Math . Floor ( Math . Pow ( N , ( double ) 1 / 3 ) ) + 1 ; return nextN * nextN * nextN ; }
double findSum ( long n ) { return Math . Sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }
int sum ( int x , int y , int n ) { int sum1 = ( int ) ( ( Math . Pow ( x , 2 ) * ( Math . Pow ( x , 2 * n ) - 1 ) ) / ( Math . Pow ( x , 2 ) - 1 ) ) ; int sum2 = ( int ) ( ( x * y * ( Math . Pow ( x , n ) * Math . Pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) ; return sum1 + sum2 ; }
int powerDigitSum ( int a , int n ) { int res = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) { res = res * digSum ( a ) ; res = digSum ( res ) ; } a = digSum ( digSum ( a ) * digSum ( a ) ) ; n /= 2 ; } return res ; }
void printPair ( int g , int l ) { Console . Write ( g + " " + l ) ; }
int mostFrequent ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int max_count = 1 , res = arr [ 0 ] ; int curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
long power ( long a , long b ) { long res = 1 ; while ( b != 0 ) { if ( ( b & 1 ) != 0 ) { res *= a ; res %= mod ; } b /= 2 ; a *= a ; a %= mod ; } return res ; }
long minPlayer ( long n , long k ) { long num = ( ( power ( k , n ) - 1 ) + mod ) % mod ; long den = ( power ( k - 1 , mod - 2 ) + mod ) % mod ; long ans = ( ( ( num * den ) % mod ) * k ) % mod ; return ans ; }
void sieve ( int N ) { prime . Insert ( 0 , false ) ; prime . Insert ( 1 , false ) ; for ( int i = 2 ; i <= N ; i ++ ) { if ( prime [ i ] ) { for ( int j = 2 ; i * j <= N ; j ++ ) { prime . Insert ( i * j , false ) ; } } } }
int countLogNeeded ( int N ) { int count = 0 ; sieve ( N ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( prime [ i ] ) { count ++ ; } } return count ; }
float rmsValue ( int [ ] arr , int n ) { int square = 0 ; float mean = 0 ; float root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { square += ( int ) Math . Pow ( arr [ i ] , 2 ) ; } mean = ( square / ( float ) ( n ) ) ; root = ( float ) Math . Sqrt ( mean ) ; return root ; }
double Mixture ( int X , int Y , int Z ) { double result1 = 0.0 , result = 0.0 ; result1 = ( ( X - Y ) / ( float ) X ) ; result = Math . Pow ( result1 , Z ) ; result = result * X ; return result ; }
int coin ( int totalRupees , int X , int Y , int Z ) { float one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2 ) ; twentyfive = ( ( Z * 1 ) / 4 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return ( int ) result ; }
float sumOfSeries ( int x , int k ) { float y = ( float ) ( ( ( float ) ( x ) / 81 ) * ( 9 * k - 1 + Math . Pow ( 10 , ( - 1 ) * k ) ) ) ; return y ; }
int calculateSum ( int n ) { int a1 = 1 , a2 = 2 ; int r = 2 ; int d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( int ) ( Math . Pow ( r , n ) - 1 ) / ( r - 1 ) ; }
int findProduct ( int n ) { int product = - 1 ; int si = factors . Count ; for ( int i = 0 ; i < si ; i ++ ) { for ( int j = 0 ; j < si ; j ++ ) { for ( int k = 0 ; k < si ; k ++ ) { for ( int l = 0 ; l < si ; l ++ ) { int s = factors [ i ] + factors [ j ] + factors [ k ] + factors [ l ] ; if ( s == n ) { int p = factors [ i ] * factors [ j ] * factors [ k ] * factors [ l ] ; if ( p > product ) { product = p ; } } } } } } return product ; }
int modExp ( int a , int b ) { int result = 1 ; while ( b > 0 ) { if ( b == 1 ) result = result * a ; a = a * a ; b /= 2 ; } return result ; }
int check ( int num ) { if ( num == 1 num < 3 ) return - 1 ; else if ( num % 4 == 0 ) return modExp ( num / 4 , 4 ) ; else if ( num % 6 == 0 ) return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 ) ; else if ( num % 10 == 0 ) return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) ; else return - 1 ; }
void sieveOfEratosthenes ( int N , int [ ] s ) { bool [ ] prime = new bool [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) prime [ i ] = false ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
int findSum ( int N ) { int [ ] s = new int [ N + 1 ] ; int ans = 1 ; sieveOfEratosthenes ( N , s ) ; int currFactor = s [ N ] ; int power = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( currFactor == s [ N ] ) { power ++ ; continue ; } int sum = 0 ; for ( int i = 0 ; i <= power ; i ++ ) sum += ( int ) Math . Pow ( currFactor , i ) ; ans *= sum ; currFactor = s [ N ] ; power = 1 ; } return ans ; }
int countMultiples ( int n ) { int [ ] multiple = { 2 , 3 , 5 } ; int count = 0 , mask = ( int ) Math . Pow ( 2 , 3 ) ; for ( int i = 1 ; i < mask ; i ++ ) { int prod = 1 ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( ( i & 1 << j ) > 0 ) prod = prod * multiple [ j ] ; } if ( count_setbits ( i ) % 2 == 1 ) count = count + n / prod ; else count = count - n / prod ; } return count ; }
int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }
bool isDivisible ( long n ) { while ( n / 100 > 0 ) { long d = n % 10 ; n /= 10 ; n -= d * 5 ; } return ( n % 17 == 0 ) ; }
int calculateSum ( int n ) { return ( ( int ) Math . Pow ( 2 , n + 1 ) + n - 2 ) ; }
int nextPowerOf2 ( int n ) { int count = 0 ; if ( n != 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
int removeElement ( int n ) { if ( n == 1 n == 2 ) return 0 ; int a = nextPowerOf2 ( n ) ; if ( n == a n == a - 1 ) return 1 ; else if ( n == a - 2 ) return 0 ; else if ( n % 2 == 0 ) return 1 ; else return 2 ; }
int calculateSum ( int n ) { return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; }
int bridge_length ( int trainLength , int Speed , int Time ) { return ( ( Time * Speed ) - trainLength ) ; }
int findN ( int k ) { int ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; }
long repeatedSum ( long n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
long repeatedProduct ( long n ) { long prod = 1 ; while ( n > 0 prod > 9 ) { if ( n == 0 ) { n = prod ; prod = 1 ; } prod *= n % 10 ; n /= 10 ; } return prod ; }
long maxSumProduct ( long N ) { if ( N < 10 ) return N ; return Math . Max ( repeatedSum ( N ) , repeatedProduct ( N ) ) ; }
int Circular ( int n ) { int Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; }
float Time ( float [ ] arr , int n , float Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; }
void smallestSubsegment ( int [ ] a , int n ) { Dictionary < int , int > left = new Dictionary < int , int > ( ) ; Dictionary < int , int > count = new Dictionary < int , int > ( ) ; int mx = 0 ; int mn = - 1 , strindex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( ! count . ContainsKey ( x ) ) { left . Add ( x , i ) ; count . Add ( x , 1 ) ; } else count [ x ] = count [ x ] + 1 ; if ( count [ x ] > mx ) { mx = count [ x ] ; mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } else if ( ( count [ x ] == mx ) && ( i - left [ x ] + 1 < mn ) ) { mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } } for ( int i = strindex ; i < strindex + mn ; i ++ ) Console . Write ( a [ i ] + " " ) ; }
long modInv ( long x ) { long n = MOD - 2 ; long result = 1 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) result = result * x % MOD ; x = x * x % MOD ; n = n / 2 ; } return result ; }
long getSum ( long n , long k ) { long ans = 1 ; for ( long i = n + 1 ; i > n - k ; i -- ) ans = ans * i % MOD ; ans = ans * modInv ( k + 1 ) % MOD ; return ans ; }
int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = Math . Min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; }
void printCombination ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( int j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( int k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { System . Console . WriteLine ( i + " " + j + " " + k ) ; return ; } } } } } } }
void printCombination ( int n ) { System . Console . Write ( 1 + " " ) ; if ( ( n - 2 ) % 3 == 0 ) System . Console . Write ( 2 + " " + ( n - 3 ) ) ; else System . Console . Write ( 1 + " " + ( n - 2 ) ) ; }
int Loss ( int costPrice , int sellingPrice ) { int Loss = ( costPrice - sellingPrice ) ; return Loss ; }
bool isPalindrome ( int n ) { if ( n % 11 == 0 ) { return true ; } return false ; }
int percent ( int a , int b ) { float result = 0 ; result = ( ( b - a ) * 100 ) / a ; return ( int ) result ; }
int nextPerfectSquare ( int N ) { int nextN = ( int ) Math . Floor ( Math . Sqrt ( N ) ) + 1 ; return nextN * nextN ; }
void Smallest_prime_factor ( ) { for ( int i = 1 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i <= MAXN ; i += 2 ) if ( spf [ i ] == i ) for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; }
int Digit_Sum ( int copy ) { int d = 0 ; while ( copy > 0 ) { d += copy % 10 ; copy /= 10 ; } return d ; }
void Sum_Of_All_Digits ( ) { for ( int n = 2 ; n < MAXN ; n ++ ) { sum_digits [ n ] = sum_digits [ n / spf [ n ] ] + Digit_Sum ( spf [ n ] ) ; if ( Digit_Sum ( n ) == sum_digits [ n ] ) isValid [ n ] = true ; } for ( int n = 2 ; n < MAXN ; n ++ ) { if ( isValid [ n ] ) ans [ n ] = 1 ; ans [ n ] += ans [ n - 1 ] ; } }
long binomialCoeff ( long n , long k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
long catalan ( long n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
bool isPrime ( int n ) { int i , c = 0 ; for ( i = 1 ; i < n / 2 ; i ++ ) { if ( n % i == 0 ) { c ++ ; } } if ( c == 1 ) { return true ; } else { return false ; } }
int prevComplement ( int n , int b ) { int maxDigit , maxNum = 0 , digits = 0 , num = n ; while ( n != 0 ) { digits ++ ; n = n / 10 ; } maxDigit = b - 1 ; while ( ( digits -- ) > 0 ) { maxNum = maxNum * 10 + maxDigit ; } return maxNum - num ; }
int complement ( int n , int b ) { return prevComplement ( n , b ) + 1 ; }
bool isFascinating ( int num ) { int [ ] freq = new int [ 10 ] ; String val = "" + num . ToString ( ) + ( num * 2 ) . ToString ( ) + ( num * 3 ) . ToString ( ) ; for ( int i = 0 ; i < val . Length ; i ++ ) { int digit = val [ i ] - '0' ; if ( freq [ digit ] && digit != 0 > 0 ) return false ; else freq [ digit ] ++ ; } for ( int i = 1 ; i < freq . Length ; i ++ ) { if ( freq [ i ] == 0 ) return false ; } return true ; }
int binomial_coefficient ( int n , int m ) { int res = 1 ; if ( m > n - m ) m = n - m ; for ( int i = 0 ; i < m ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
void computeTotient ( ) { for ( int i = 1 ; i < N ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p < N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i < N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
void CoPrimes ( ) { computeTotient ( ) ; for ( int i = 1 ; i < N ; i ++ ) S [ i ] = S [ i - 1 ] + phi [ i ] ; }
bool isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; }
int previousPowerOfTwo ( int n ) { while ( ( n & n - 1 ) > 1 ) { n = n & n - 1 ; } return n ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int MaximumDivisors ( int X , int Y ) { int [ ] arr = new int [ Y - X + 1 ] ; for ( int i = 0 ; i < arr . Length ; i ++ ) arr [ i ] = 0 ; int mx = 0 ; int cnt = 0 ; for ( int i = 1 ; i * i <= Y ; i ++ ) { int sq = i * i ; int first_divisible ; if ( ( X / i ) * i >= X ) first_divisible = ( X / i ) * i ; else first_divisible = ( X / i + 1 ) * i ; for ( int j = first_divisible ; j <= Y ; j += i ) { if ( j < sq ) continue ; else if ( j == sq ) arr [ j - X ] ++ ; else arr [ j - X ] += 2 ; } } for ( int i = X ; i <= Y ; i ++ ) { if ( arr [ i - X ] > mx ) { cnt = 1 ; mx = arr [ i - X ] ; } else if ( arr [ i - X ] == mx ) cnt ++ ; } return cnt ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int NearestElement ( int A , int D , int P ) { if ( A == 0 ) return 0 ; else if ( D == 0 ) return - 1 ; else { int X = power ( D , P - 2 , P ) ; return ( X * ( P - A ) ) % P ; } }
int binaryToDecimal ( String n ) { String num = n ; int dec_value = 0 ; int base_ = 1 ; int len = num . Length ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num [ i ] == '1' ) dec_value += base_ ; base_ = base_ * 2 ; } return dec_value ; }
int numberSequence ( int n ) { if ( n == 1 ) return 1 ; String s = "" ; for ( int i = 1 ; i < n ; i ++ ) s += '1' ; s += '0' ; for ( int i = 1 ; i <= n ; i ++ ) s += '1' ; int num = binaryToDecimal ( s ) ; return num ; }
int numberSequence ( int n ) { int num = ( int ) ( Math . Pow ( 4 , n ) - Math . Pow ( 2 , n ) ) - 1 ; return num ; }
int complement ( int num ) { int len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = num / 10 ; if ( Math . Abs ( num ) == 0 ) break ; } num = temp ; comp = ( int ) Math . Pow ( 10 , len ) - num ; return comp ; }
int calculate ( int [ ] ar , int size ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( ar [ i ] % 2 == 0 && ar [ i ] != 0 && ar [ i ] != 2 ) count ++ ; return count ; }
int prime ( int num ) { int i , flag = 0 ; for ( i = 2 ; i <= num / 2 ; i ++ ) { if ( num % i == 0 ) { flag = 1 ; break ; } } if ( flag == 0 ) return 1 ; else return 0 ; }
void print_alternate_prime ( int n ) { int counter = 0 ; for ( int num = 2 ; num < n ; num ++ ) { if ( prime ( num ) == 1 ) { if ( counter % 2 == 0 ) Console . Write ( num + " " ) ; counter ++ ; } } }
void SieveOfEratosthenes ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < prime . Length ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } bool flag = true ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { if ( flag ) { Console . Write ( p + " " ) ; flag = false ; } else { flag = true ; } } } }
bool findGreater ( int x , int y ) { if ( x > y ) { return false ; } else { return true ; } }
int max_profit ( int [ ] a , int [ ] b , int n , int fee ) { int i , j , profit ; int l , r , diff_day = 1 , sum = 0 ; b [ 0 ] = 0 ; b [ 1 ] = diff_day ; for ( i = 1 ; i < n ; i ++ ) { l = 0 ; r = diff_day ; sum = 0 ; for ( j = n - 1 ; j >= i ; j -- ) { profit = ( a [ r ] - a [ l ] ) - fee ; if ( profit > 0 ) { sum = sum + profit ; } l ++ ; r ++ ; } if ( b [ 0 ] < sum ) { b [ 0 ] = sum ; b [ 1 ] = diff_day ; } diff_day ++ ; } return 0 ; }
int binomialCoeff ( int x , int n , int k ) { int sum = 0 , term = 1 ; for ( int i = 1 ; i <= n && sum < k ; ++ i ) { term *= x - i + 1 ; term /= i ; sum += term ; } return sum ; }
int minTrials ( int n , int k ) { int low = 1 , high = k ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( binomialCoeff ( mid , n , k ) < k ) low = mid + 1 ; else high = mid ; } return low ; }
void preprocess ( ) { for ( int i = 1 ; i < N ; i ++ ) { int num = i ; for ( int j = 2 ; j <= Math . Sqrt ( num ) ; j ++ ) { if ( num % j == 0 ) { v [ i ] . Add ( j ) ; while ( num % j == 0 ) { num = num / j ; } } } if ( num > 2 ) v [ i ] . Add ( num ) ; } }
int query ( int number , int n ) { return v [ number ] [ n - 1 ] ; }
int getsum ( int a ) { int r = 0 , sum = 0 ; while ( a > 0 ) { r = a % 10 ; sum = sum + r ; a = a / 10 ; } return sum ; }
long boost_hyperfactorial ( long num ) { long val = 1 ; for ( long i = 1 ; i <= num ; i ++ ) { val = val * ( long ) Math . Pow ( i , i ) ; } return val ; }
int boost_hyperfactorial ( int num ) { int val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y != 0 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
int findOddPair ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 1 ) ) { count ++ ; } } return count * ( count - 1 ) / 2 ; }
int summ ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
void printDigitalRoot ( int n ) { int maxi = 1 ; int dig = 1 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { int d1 = summ ( n / i ) ; int d2 = summ ( i ) ; if ( d1 > maxi ) { dig = n / i ; maxi = d1 ; } if ( d2 > maxi ) { dig = i ; maxi = d2 ; } if ( d1 == maxi ) { if ( dig < ( n / i ) ) { dig = n / i ; maxi = d1 ; } } if ( d2 == maxi ) { if ( dig < i ) { dig = i ; maxi = d2 ; } } } } Console . WriteLine ( dig + " " + maxi ) ; }
int gcd ( int a , int b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
bool isSurd ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; }
long LastTwoDigit ( long num ) { long one = num % 10 ; num /= 10 ; long tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; }
int power ( long x , long y , long p ) { while ( y > 0 ) { long r = y & 1 ; if ( r == 1 ) res = ( res * ( int ) x ) % ( int ) p ; x = ( x * x ) % p ; } return res ; }
long modPower ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
long gcd ( long a , long b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
long gcdPow ( long a , long n , long c ) { if ( a % c == 0 ) return c ; long modexpo = modPower ( a , n , c ) ; return gcd ( modexpo , c ) ; }
int countOddSum ( int [ ] ar , int n ) { int [ ] temp = { 1 , 0 } ; int result = 0 , val = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { val = ( ( val + ar [ i ] ) % 2 + 2 ) % 2 ; temp [ val ] ++ ; } result = temp [ 0 ] * temp [ 1 ] ; return ( result ) ; }
int countOddSum ( int [ ] a , int n ) { int c_odd = 0 , result = 0 ; bool odd = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { odd = ! odd ; } if ( odd ) { c_odd ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { result += c_odd ; if ( a [ i ] % 2 == 1 ) { c_odd = ( n - i - c_odd ) ; } } return result ; }
void findNthRoot ( double x , int n ) { double low , high ; if ( x >= 0 && x <= 1 ) { low = x ; high = 1 ; } else { low = 1 ; high = x ; } double epsilon = 0.00000001 ; double guess = ( low + high ) / 2 ; while ( Math . Abs ( ( Math . Pow ( guess , n ) ) - x ) >= epsilon ) { if ( Math . Pow ( guess , n ) > x ) { high = guess ; } else { low = guess ; } guess = ( low + high ) / 2 ; } Console . WriteLine ( guess ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int SumOfPrimeDivisors ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) { if ( isPrime ( i ) ) sum += i ; } } return sum ; }
int Sum ( int N ) { int [ ] SumOfPrimeDivisors = new int [ N + 1 ] ; for ( int i = 2 ; i <= N ; ++ i ) { if ( SumOfPrimeDivisors [ i ] == 0 ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int SumOfPrimeDivisors ( int n ) { int sum = 0 ; int root_n = ( int ) Math . Sqrt ( n ) ; for ( int i = 1 ; i <= root_n ; i ++ ) { if ( n % i == 0 ) { if ( i == n / i && isPrime ( i ) ) { sum += i ; } else { if ( isPrime ( i ) ) { sum += i ; } if ( isPrime ( n / i ) ) { sum += ( n / i ) ; } } } } return sum ; }
int rangesum ( int n , int l , int r ) { int [ ] arr = new int [ n ] ; int c = 1 , i = 0 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } c = 2 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } int sum = 0 ; for ( i = l - 1 ; i < r ; i ++ ) { sum += arr [ i ] ; } return sum ; }
int sumeven ( int n , int l , int r ) { int sum = 0 ; int mid = n / 2 ; if ( r <= mid ) { int first = ( 2 * l - 1 ) ; int last = ( 2 * r - 1 ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else if ( l >= mid ) { int first = ( 2 * ( l - n / 2 ) ) ; int last = ( 2 * ( r - n / 2 ) ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else { int sumleft = 0 , sumright = 0 ; int first_term1 = ( 2 * l - 1 ) ; int last_term1 = ( 2 * ( n / 2 ) - 1 ) ; int no_of_terms1 = n / 2 - l + 1 ; sumleft = ( ( no_of_terms1 ) * ( ( first_term1 + last_term1 ) ) ) / 2 ; int first_term2 = 2 ; int last_term2 = ( 2 * ( r - n / 2 ) ) ; int no_of_terms2 = r - mid ; sumright = ( ( no_of_terms2 ) * ( ( first_term2 + last_term2 ) ) ) / 2 ; sum = ( sumleft + sumright ) ; } return sum ; }
int sumodd ( int n , int l , int r ) { int mid = n / 2 + 1 ; int sum = 0 ; if ( r <= mid ) { int first = ( 2 * l - 1 ) ; int last = ( 2 * r - 1 ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else if ( l > mid ) { int first = ( 2 * ( l - mid ) ) ; int last = ( 2 * ( r - mid ) ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else { int sumleft = 0 , sumright = 0 ; int first_term1 = ( 2 * l - 1 ) ; int last_term1 = ( 2 * mid - 1 ) ; int no_of_terms1 = mid - l + 1 ; sumleft = ( ( no_of_terms1 ) * ( ( first_term1 + last_term1 ) ) ) / 2 ; int first_term2 = 2 ; int last_term2 = ( 2 * ( r - mid ) ) ; int no_of_terms2 = r - mid ; sumright = ( ( no_of_terms2 ) * ( ( first_term2 + last_term2 ) ) ) / 2 ; sum = ( sumleft + sumright ) ; } return sum ; }
int rangesum ( int n , int l , int r ) { if ( n % 2 == 0 ) return sumeven ( n , l , r ) ; else return sumodd ( n , l , r ) ; }
void groupElements ( int [ ] arr , int n ) { bool [ ] visited = new bool [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { visited [ i ] = false ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { Console . Write ( arr [ i ] + " " ) ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { Console . Write ( arr [ i ] + " " ) ; visited [ j ] = true ; } } } } }
float rainDayProbability ( int [ ] a , int n ) { float count = 0 , m ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; }
void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { double d = Math . Pow ( ( Math . Pow ( x2 - x1 , 2 ) + Math . Pow ( y2 - y1 , 2 ) + Math . Pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; Console . WriteLine ( "Distance is \n" + d ) ; return ; }
bool DivisibleBy41 ( int first , int second , int c , int n ) { int [ ] digit = new int [ n ] ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( int i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; int ans = digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; }
int findTetrahedralNumber ( int n ) { return ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) ; }
void printSeries ( int n ) { int prev = 0 ; int curr ; for ( int i = 1 ; i <= n ; i ++ ) { curr = findTetrahedralNumber ( i ) ; curr = curr + prev ; Console . Write ( curr + " " ) ; prev = curr ; } }
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; Console . Write ( num + " " ) ; } }
long findTriangularNumber ( int n ) { return ( n * ( n + 1 ) ) / 2 ; }
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; Console . Write ( num + " " ) ; } }
long calculateSum ( int n ) { long sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
long calculateSum ( int n ) { long sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
float findArea ( float a ) { float area ; area = ( float ) ( 5 * Math . Sqrt ( 3 ) * a * a ) ; return area ; }
float findVolume ( float a ) { float volume ; volume = ( float ) ( ( ( float ) 5 / 12 ) * ( 3 + Math . Sqrt ( 5 ) ) * a * a * a ) ; return volume ; }
int findNthNonSquare ( int n ) { double x = ( double ) n ; double ans = x + Math . Floor ( 0.5 + Math . Sqrt ( x ) ) ; return ( int ) ans ; }
void count_even_odd ( int min , int max , int [ , ] steps ) { int a , b , even , odd ; bool beven = true , aeven = false ; int n = 2 ; for ( int i = 0 ; i < n ; i ++ ) { a = steps [ i , 0 ] ; b = steps [ i , 1 ] ; if ( ! ( aeven || ( a & 1 ) > 0 ) ) aeven = true ; if ( beven ) { if ( ( b & 1 ) > 0 ) beven = false ; } else if ( ! ( ( a & 1 ) > 0 ) ) { if ( ! ( ( b & 1 ) > 0 ) ) beven = true ; } else { if ( ( b & 1 ) > 0 ) beven = true ; } } if ( beven ) { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } else { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } if ( ! ( beven ^ aeven ) ) even += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; else odd += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; Console . Write ( "even = " + even + ", odd = " + odd ) ; }
int getMaxOnes ( int n , int x ) { int zeroes = ( n / x ) ; zeroes = zeroes * zeroes ; int total = n * n ; int ans = total - zeroes ; return ans ; }
int ways ( int n ) { int first = 2 ; int second = 3 ; int res = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
int minimumOperations ( int [ ] a , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( a [ i ] ) ) { var val = mp [ a [ i ] ] ; mp . Remove ( a [ i ] ) ; mp . Add ( a [ i ] , val + 1 ) ; } else { mp . Add ( a [ i ] , 1 ) ; } } int count = 0 ; foreach ( KeyValuePair < int , int > entry in mp ) { if ( entry . Value > 1 ) { count += ( entry . Value - 1 ) ; } } return count ; }
void findVolume ( float a , float h ) { float Volume ; Volume = 3 * ( float ) ( Math . Sqrt ( 3 ) ) * a * a * h / 2 ; Console . WriteLine ( "Volume: " + Volume ) ; }
double MinimumMail ( int n , int k , int x ) { double m = ( n - 1 ) + Math . Ceiling ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . Ceiling ( n * 1.0 / x ) * ( k - n ) ; return m ; }
int findAllSequence ( int N ) { if ( N % 2 == 0 ) { return ( int ) ( Math . Pow ( 2 , N / 2 + 1 ) + Math . Pow ( 2 , N / 2 ) - 2 ) ; } else { return ( int ) ( Math . Pow ( 2 , ( N + 1 ) / 2 ) + Math . Pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } }
void computeTotient ( ) { for ( int i = 1 ; i <= N ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p <= N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
long power ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
long calculate ( long x , long k , long mod ) { long [ ] arr = new long [ N ] ; long count = 0 ; while ( mod > 1 ) { arr [ ( int ) count ++ ] = mod ; mod = phi [ ( int ) mod ] ; } long result = 1 ; long loop = count + 1 ; arr [ ( int ) count ] = 1 ; for ( int i = ( int ) Math . Min ( k , loop ) - 1 ; i >= 0 ; i -- ) result = power ( x , result , arr [ i ] ) ; return result ; }
int countOnes ( int n ) { int count = 1 ; int rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; }
void fibonacci ( double n ) { double fib ; for ( double i = 0 ; i < n ; i ++ ) { fib = ( Math . Pow ( ( 1 + Math . Sqrt ( 5 ) ) , i ) - Math . Pow ( ( 1 - Math . Sqrt ( 5 ) ) , i ) ) / ( Math . Pow ( 2 , i ) * Math . Sqrt ( 5 ) ) ; Console . Write ( ( int ) fib + " " ) ; } }
int findLCM ( int a , int b ) { int lar = Math . Max ( a , b ) ; int small = Math . Min ( a , b ) ; for ( int i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }
int center_hexadecagonal_num ( int n ) { return 8 * n * n - 8 * n + 1 ; }
int findNature ( int a , int b , int n ) { int [ ] seq = new int [ 100 ] ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( int i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; if ( ( seq [ n ] & 1 ) != 0 ) return 1 ; else return 0 ; }
bool findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }
void check ( ulong m , ulong n ) { double RHS = m * ( double ) Math . Log ( n ) ; double LHS = n * ( double ) Math . Log ( m ) ; if ( LHS > RHS ) Console . Write ( "m^n > n^m" ) ; else if ( LHS < RHS ) Console . Write ( "m^n < n^m" ) ; else Console . Write ( "m^n = n^m" ) ; }
int numberOfmeet ( int a , int b ) { int ans ; if ( a > b ) ans = a - b ; else ans = b - a ; if ( a < 0 ) a = a * ( - 1 ) ; if ( b < 0 ) b = b * ( - 1 ) ; return ans / gcd ( a , b ) ; }
void SieveOfEratosthenes ( List < int > primes ) { bool [ ] prime = new bool [ MAX ] ; for ( int i = 0 ; i < prime . Length ; i ++ ) { prime [ i ] = true ; } for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { primes . Add ( p ) ; } } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int maxDivisorRange ( int a , int b , int l , int h ) { int g = gcd ( a , b ) ; int res = - 1 ; for ( int i = l ; i * i <= g && i <= h ; i ++ ) if ( g % i == 0 ) res = Math . Max ( res , Math . Max ( i , g / i ) ) ; return res ; }
int findMaxGCD ( int [ ] arr , int n , int k ) { int high = arr . Max ( ) ; int [ ] divisors = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= Math . Sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] >= k ) return i ; return 0 ; }
void primes ( int n ) { int i = 2 ; int j = 0 ; int [ ] result = new int [ n ] ; int z = 0 ; while ( j < n ) { bool flag = true ; for ( int item = 2 ; item <= ( int ) ( i * 1 / 2 ) ; item ++ ) if ( i % item == 0 && i != item ) { flag = false ; break ; } if ( flag ) { result [ z ++ ] = i ; j += 1 ; } i += 1 ; } for ( i = 0 ; i < result . Length ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) System . Console . Write ( result [ j ] ) ; System . Console . Write ( " " ) ; } }
int subtractOne ( int x ) { int m = 1 ; while ( ! ( ( x & m ) > 0 ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; }
int Log2n ( int n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; }
bool isPowerOfd ( int n , int d ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % ( Log2n ( d ) ) == 0 ) ; } return false ; }
void meanVector ( int [ , ] mat ) { Console . Write ( "[ " ) ; for ( int i = 0 ; i < rows ; i ++ ) { double mean = 0.00 ; int sum = 0 ; for ( int j = 0 ; j < cols ; j ++ ) sum += mat [ j , i ] ; mean = sum / rows ; Console . Write ( ( int ) mean + " " ) ; } Console . Write ( "]" ) ; }
void findMissing ( int [ ] a , int [ ] b , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) Console . Write ( a [ i ] + " " ) ; } }
int countDigits ( int n ) { double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += Math . Log10 ( i ) ; ans = ans * n ; return 1 + ( int ) Math . Floor ( ans ) ; }
void checksum ( int n ) { if ( n == 0 ) { Console . Write ( "-2 -1 0 1 2" ) ; return ; } int inc ; if ( n > 0 ) inc = 1 ; else inc = - 1 ; for ( int i = 0 ; i <= n - 4 ; i += inc ) { if ( i + i + 1 + i + 2 + i + 3 + i + 4 == n ) { Console . Write ( ( i ) + " " + ( i + 1 ) + " " + ( i + 2 ) + " " + ( i + 3 ) + " " + ( i + 4 ) ) ; return ; } } Console . WriteLine ( "-1" ) ; }
void checksum ( int n ) { if ( n % 5 == 0 ) Console . WriteLine ( ( n / 5 - 2 ) + " " + ( n / 5 - 1 ) + " " + ( n / 5 ) + " " + ( n / 5 + 1 ) + " " + ( n / 5 + 2 ) ) ; else Console . WriteLine ( "-1" ) ; }
void printGreater ( int x , int y ) { double X = y * Math . Log ( x ) ; double Y = x * Math . Log ( y ) ; if ( Math . Abs ( X - Y ) < 1e-9 ) { Console . WriteLine ( "Equal" ) ; } else if ( X > Y ) { Console . WriteLine ( x + "^" + y ) ; } else { Console . WriteLine ( y + "^" + x ) ; } }
int dfs ( int i ) { if ( visited [ i ] == 1 ) return 0 ; visited [ i ] = 1 ; int x = dfs ( goesTo [ i ] ) ; return ( x + 1 ) ; }
int noOfTranspositions ( int [ ] P , int n ) { for ( int i = 1 ; i <= n ; i ++ ) visited [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) goesTo [ P [ i ] ] = i + 1 ; int transpositions = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( visited [ i ] == 0 ) { int ans = dfs ( i ) ; transpositions += ans - 1 ; } } return transpositions ; }
int sumOfSeries ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }
void findMissing ( int [ ] a , int [ ] b , int n , int m ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < m ; i ++ ) s . Add ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ! s . Contains ( a [ i ] ) ) Console . Write ( a [ i ] + " " ) ; }
int countUnmarked ( int N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; }
int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int calculateSeries ( int n ) { return factorial ( n + 1 ) - 1 ; }
int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int Pentatope_number ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 24 ; }
int minimumLength ( int x , int y , int z ) { return 1 + Math . Abs ( x - y ) + Math . Abs ( y - z ) ; }
bool areEquivalent ( int num1 , int num2 ) { return divSum ( num1 ) == divSum ( num2 ) ; }
int dodecahedral_num ( int n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }
long centered_heptagonal_num ( long n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
int centeredIcosahedralNum ( int n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; }
bool checkHankelMatrix ( int n , int [ , ] m ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i , j ] != m [ i + j , 0 ] ) return false ; } else { if ( m [ i , j ] != m [ i + j - n + 1 , n - 1 ] ) return false ; } } } return true ; }
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
int Centered_Triangular_num ( int n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; }
int Dodecagonal_number ( int n ) { return 5 * n * n - 4 * n ; }
bool check ( int d , int x ) { if ( bit ( x / d ) <= bit ( d ) ) return true ; return false ; }
int countDivisor ( int n ) { return n - bs ( n ) + 1 ; }
bool isPower ( int n ) { for ( int x = 2 ; x <= ( int ) Math . Sqrt ( n ) ; x ++ ) { float f = ( float ) Math . Log ( n ) / ( float ) Math . Log ( x ) ; if ( ( f - ( int ) f ) == 0.0 ) return true ; } return false ; }
void wrapper ( int q , int [ ] n ) { int [ ] digitSum = new int [ N ] ; int [ ] factorDigitSum = new int [ N ] ; sumOddDigit ( digitSum ) ; sumFactor ( digitSum , factorDigitSum ) ; for ( int i = 0 ; i < q ; i ++ ) Console . Write ( factorDigitSum [ n [ i ] ] + " " ) ; }
bool everMeet ( int x1 , int x2 , int v1 , int v2 ) { if ( x1 < x2 && v1 <= v2 ) { return false ; } if ( x1 > x2 && v1 >= v2 ) { return false ; } if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; } return ( ( x1 - x2 ) % ( v1 - v2 ) == 0 ) ; }
int find_maximum ( int [ ] a , int n , int k ) { Dictionary < int , int > b = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; int d = Math . Min ( 1 + i , n - i ) ; if ( ! b . ContainsKey ( x ) ) b . Add ( x , d ) ; else { b [ x ] = Math . Min ( d , b [ x ] ) ; } } int ans = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( x != k - x && b . ContainsKey ( k - x ) ) ans = Math . Min ( Math . Max ( b [ x ] , b [ k - x ] ) , ans ) ; } return ans ; }
int number_of_digits ( int n ) { int i ; int res ; int sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }
int MaximumHeight ( int [ ] a , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }
int distinctGCDs ( int [ ] arr , int N ) { int M = - 1 , ans = 0 ; Dictionary < int , int > Mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { M = Math . Max ( M , arr [ i ] ) ; if ( Mp . ContainsKey ( arr [ i ] ) ) Mp [ arr [ i ] ] = 1 ; else Mp . Add ( arr [ i ] , 1 ) ; } for ( int i = 1 ; i <= M ; i ++ ) { int currGcd = 0 ; for ( int j = i ; j <= M ; j += i ) { if ( Mp . ContainsKey ( j ) ) { currGcd = gcd ( currGcd , j ) ; if ( currGcd == i ) { ans ++ ; break ; } } } } return ans ; }
void printCollatz ( int n ) { while ( n != 1 ) { Console . Write ( n + " " ) ; if ( ( n & 1 ) == 1 ) n = 3 * n + 1 ; else n = n / 2 ; } Console . Write ( n ) ; }
bool isProduct ( int [ ] arr , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
void SieveOfEratosthenes ( int n , bool [ ] prime , bool [ ] primesquare , int [ ] a ) { for ( int i = 2 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int i = 0 ; i <= ( n * n ) ; i ++ ) primesquare [ i ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } int j = 0 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { a [ j ] = p ; primesquare [ p * p ] = true ; j ++ ; } } }
int countDivisors ( int n ) { if ( n == 1 ) return 1 ; bool [ ] prime = new bool [ n + 1 ] ; bool [ ] primesquare = new bool [ n * n + 1 ] ; SieveOfEratosthenes ( n , prime , primesquare , a ) ; int ans = 1 ; for ( int i = 0 ; ; i ++ ) { if ( a [ i ] * a [ i ] * a [ i ] > n ) break ; int cnt = 1 ; while ( n % a [ i ] == 0 ) { n = n / a [ i ] ; } ans = ans * cnt ; } if ( prime [ n ] ) ans = ans * 2 ; else if ( primesquare [ n ] ) ans = ans * 3 ; else if ( n != 1 ) ans = ans * 4 ; }
int sumofFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
bool checkArithmetic ( int n ) { int count = countDivisors ( n ) ; int sum = sumofFactors ( n ) ; return ( sum % count == 0 ) ; }
int findGCD ( List < int > arr , int n ) { int result = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = gcd ( arr [ i ] , result ) ; return result ; }
int binomialCoeff ( int n , int k ) { int [ , ] C = new int [ n + 1 , k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } return C [ n , k ] ; }
double sumTillX ( double x , double n ) { double odd = Math . Ceiling ( n / 2.0 ) ; if ( x <= odd ) return x * x ; double even = x - odd ; return ( ( odd * odd ) + ( even * even ) + even ) ; }
double rangeSum ( double N , double L , double R ) { return sumTillX ( R , N ) - sumTillX ( L - 1 , N ) ; }
int magicOfSequence ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) sum += ( i * i * i + i * 2 ) ; return sum ; }
int magicOfSequence ( int N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }
bool isProduct ( int [ ] arr , int n , int x ) { HashSet < int > hset = new HashSet < int > ( ) ; if ( n < 2 ) { return false ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { if ( x == 0 ) { return true ; } else { continue ; } } if ( x % arr [ i ] == 0 ) { if ( hset . Contains ( x / arr [ i ] ) ) { return true ; } hset . Add ( arr [ i ] ) ; } } return false ; }
int repUnitValue ( int n ) { if ( n % 2 == 0 n % 5 == 0 ) return 0 ; int rem = 1 ; int power = 1 ; int k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; }
bool isSplittable ( int n , int m ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int sum_s1 = ( total_sum + m ) / 2 ; int sum_s2 = total_sum - sum_s1 ; if ( total_sum < m ) return false ; if ( sum_s1 + sum_s2 == total_sum && sum_s1 - sum_s2 == m ) return ( GCD ( sum_s1 , sum_s2 ) == 1 ) ; return false ; }
bool isPossibleToZero ( int [ ] a , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) == 0 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }
double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
bool isBlumInteger ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] ) { if ( ( n % i == 0 ) && ( ( i - 3 ) % 4 ) == 0 ) { int q = n / i ; return ( q != i && prime [ q ] && ( q - 3 ) % 4 == 0 ) ; } } } return false ; }
List < int > primeFactors ( int n ) { List < int > res = new List < int > ( ) ; if ( n % 2 == 0 ) { while ( n % 2 == 0 ) n = n / 2 ; res . Add ( 2 ) ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; res . Add ( i ) ; } } if ( n > 2 ) res . Add ( n ) ; return res ; }
bool isHoax ( int n ) { List < int > pf = primeFactors ( n ) ; if ( pf [ 0 ] == n ) return false ; int all_pf_sum = 0 ; for ( int i = 0 ; i < pf . Count ; i ++ ) { int pf_sum ; for ( pf_sum = 0 ; pf [ i ] > 0 ; pf_sum += pf [ i ] % 10 , pf [ i ] /= 10 ) ; all_pf_sum += pf_sum ; } int sum_n ; for ( sum_n = 0 ; n > 0 ; sum_n += n % 10 , n /= 10 ) ; return sum_n == all_pf_sum ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int summingSeries ( long n ) { return ( int ) Math . Pow ( n , 2 ) ; }
int nCr ( int n , int r ) { int Nr = n , Dr = 1 , ans = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { ans = ( ans * Nr ) / ( Dr ) ; Nr -- ; Dr ++ ; } return ans ; }
int solve ( int n ) { int N = 2 * n - 2 ; int R = n - 1 ; return nCr ( N , R ) * fact ( n - 1 ) ; }
void printSumsOfDigits ( int n ) { for ( int base1 = 2 ; base1 < n ; ++ base1 ) Console . Write ( solve ( n , base1 ) + " " ) ; }
bool check ( int N , int D ) { int temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; }
bool isValidNesbitt ( double a , double b , double c ) { double A = a / ( b + c ) ; double B = b / ( a + c ) ; double C = c / ( a + b ) ; double inequality = A + B + C ; return ( inequality >= 1.5 ) ; }
int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) { count ++ ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { count ++ ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) count ++ ; return count ; }
int no_of_digit ( int a , int b ) { return ( ( int ) ( b * Math . Log10 ( a ) ) + 1 ) ; }
List < long > gen ( long n , List < long > r ) { long a = r [ r . Count - 1 ] ; a ++ ; for ( int i = 1 ; i <= n ; a += 2 , i ++ ) r . Add ( a ) ; return r ; }
List < long > conell ( long n ) { List < long > res = new List < long > ( ) ; long k = 1 ; res . Add ( 0 ) ; while ( true ) { res = gen ( k , res ) ; k ++ ; int j = res . Count - 1 ; while ( j != n && j + k > n ) k -- ; if ( j >= n ) break ; } res . RemoveAt ( 0 ) ; return res ; }
long factorial ( int n ) { long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { res *= i ; } return res ; }
void printNComposite ( int n ) { long fact = factorial ( n + 1 ) ; for ( int i = 2 ; i <= n + 1 ; ++ i ) { Console . Write ( fact + i + " " ) ; } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
bool coprime ( int a , int b ) { return ( gcd ( a , b ) == 1 ) ; }
bool isCubeFree ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i * i <= n ; i ++ ) if ( n % ( i * i * i ) == 0 ) return false ; return true ; }
void printCubeFree ( int n ) { bool [ ] cubFree = new bool [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) cubFree [ i ] = true ; for ( int i = 2 ; i * i * i <= n ; i ++ ) { if ( cubFree [ i ] ) { for ( int multiple = 1 ; i * i * i * multiple <= n ; multiple ++ ) { cubFree [ i * i * i * multiple ] = false ; } } } for ( int i = 2 ; i <= n ; i ++ ) { if ( cubFree [ i ] == true ) Console . Write ( i + " " ) ; } }
int inversegrayCode ( int n ) { int inv = 0 ; for ( ; n != 0 ; n = n >> 1 ) inv ^= n ; return inv ; }
int calculateDivisors ( int A , int B ) { int N = ( A - B ) ; int noOfDivisors = 0 ; double a = Math . Sqrt ( N ) ; for ( int i = 1 ; i <= ( int ) ( a ) ; i ++ ) { if ( ( N % i ) == 0 ) { if ( i > B ) noOfDivisors ++ ; if ( ( N / i ) != i && ( N / i ) > B ) noOfDivisors ++ ; } } return noOfDivisors ; }
int numberOfPossibleWaysUtil ( int A , int B ) { if ( A == B ) return - 1 ; if ( A < B ) return 0 ; int noOfDivisors = 0 ; noOfDivisors = calculateDivisors ( A , B ) ; return noOfDivisors ; }
void printPowerNumber ( int X , int N ) { List < int > power = new List < int > ( ) ; power . Add ( 1 ) ; List < int > res = new List < int > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { nextPower ( N , ref power ) ; res . Add ( power . Last ( ) ) ; res . Add ( power . First ( ) ) ; } for ( int i = 0 ; i < res . Count ; i ++ ) Console . Write ( res [ i ] ) ; }
int firstDigit ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return fact ; }
bool possibleToReach ( int a , int b ) { int c = ( int ) Math . Pow ( a * b , ( double ) 1 / 3 ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; }
List < long > primes ( long n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } List < long > arr = new List < long > ( ) ; for ( int i = 2 ; i < n ; i ++ ) if ( prime [ i ] ) arr . Add ( i ) ; return arr ; }
int countDigits ( long n ) { long temp = n ; int c = 0 ; while ( temp != 0 ) { temp = temp / 10 ; c ++ ; } return c ; }
bool frugal ( long n ) { List < long > r = primes ( n ) ; long t = n ; long s = 0 ; for ( int i = 0 ; i < r . Count ; i ++ ) { if ( t % r [ i ] == 0 ) { long k = 0 ; while ( t % r [ i ] == 0 ) { t = t / r [ i ] ; k ++ ; } if ( k == 1 ) s = s + countDigits ( r [ i ] ) ; else if ( k != 1 ) s = s + countDigits ( r [ i ] ) + countDigits ( k ) ; } } return ( countDigits ( n ) > s && s != 0 ) ; }
int nthSquareCube ( int n ) { return n * n * n * n * n * n ; }
int findGreatest ( int [ ] arr , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . Max ( result , arr [ i ] ) ; return result ; }
int isPerfectSquare ( double x ) { double sr = Math . Sqrt ( x ) ; if ( ( sr - Math . Floor ( sr ) ) == 0 ) return ( int ) ( Math . Floor ( sr ) ) ; else return - 1 ; }
int findS ( int s ) { int sr = isPerfectSquare ( s ) ; if ( sr == - 1 ) return - 1 ; return isTriangular ( sr ) ; }
long powerNumbers ( int n ) { HashSet < long > v = new HashSet < long > ( ) ; for ( long i = 2 ; i * i * i <= n ; i ++ ) { long j = i * i ; while ( j * i <= n ) { j *= i ; long s = ( long ) Math . Sqrt ( j ) ; if ( s * s != j ) v . Add ( j ) ; } } return v . Count + ( long ) Math . Sqrt ( n ) ; }
void NicomachuTheorum_sum ( int n ) { int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ; int triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
int checkDigits ( int n ) { while ( n > 0 ) { if ( ( ( n % 10 ) % 2 ) > 0 ) return 0 ; n /= 10 ; } return 1 ; }
int largestNumber ( int n ) { for ( int i = n ; ; i -- ) if ( checkDigits ( i ) > 0 ) return i ; }
int largestNumber ( int n ) { string s = "" ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ( ( ( int ) ( s [ i ] - '0' ) % 2 ) & 1 ) > 0 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; int num = 0 ; for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( int ) ( s [ i ] - '0' ) ; num = num * 10 + ( ( int ) s [ index ] - ( int ) ( '0' ) - 1 ) ; for ( int i = index + 1 ; i < s . Length ; i ++ ) num = num * 10 + 8 ; return num ; }
int countDigits ( int n ) { return ( int ) ( n * Math . Log10 ( 2 ) + 1 ) ; }
int check_digits ( int n ) { while ( n != 0 ) { if ( ( n % 10 ) % 2 != 0 ) return 0 ; n /= 10 ; } return 1 ; }
int smallest_number ( int n ) { for ( int i = n ; ; i ++ ) if ( check_digits ( i ) != 0 ) return i ; }
int trickyCase ( string s , int index ) { int index1 = - 1 ; for ( int i = index - 1 ; i >= 0 ; i -- ) { int digit = s [ i ] - '0' ; if ( digit != 8 ) { index1 = i ; break ; } } if ( index1 == - 1 ) return 2 * ( int ) Math . Pow ( 10 , s . Length ) ; int num = 0 ; for ( int i = 0 ; i < index1 ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; if ( s [ index1 ] % 2 == 0 ) num = num * 10 + ( s [ index1 ] - '0' + 2 ) ; else num = num * 10 + ( s [ index1 ] - '0' + 1 ) ; for ( int i = index1 + 1 ; i < s . Length ; i ++ ) num = num * 10 ; return num ; }
int smallestNumber ( int n ) { int num = 0 ; string s = "" ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { int digit = s [ i ] - '0' ; int val = digit & 1 ; if ( val == 1 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; if ( s [ index ] == '9' ) { num = trickyCase ( s , index ) ; return num ; } for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; num = num * 10 + ( s [ index ] - '0' + 1 ) ; for ( int i = index + 1 ; i < s . Length ; i ++ ) num = num * 10 ; return num ; }
int findBucketNo ( int p ) { return ( int ) Math . Ceiling ( ( Math . Sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }
int mean ( int [ , ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += a [ i , j ] ; return sum / ( n * n ) ; }
int variance ( int [ , ] a , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { a [ i , j ] -= m ; a [ i , j ] *= a [ i , j ] ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += a [ i , j ] ; return sum / ( n * n ) ; }
long productPrimeFactors ( int n ) { long product = 1 ; if ( n % 2 == 0 ) { product *= 2 ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { product = product * i ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) product = product * n ; return product ; }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
void sieve ( ) { bool [ ] isPrime = new bool [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( isPrime [ p ] == true ) primes . Add ( p ) ; }
int modMult ( int a , int b , int mod ) { int res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; }
int countWays ( int n , int m ) { int ans = 1 ; for ( int i = 1 ; i < primes . Count ; i ++ ) { int powers = power_prime ( n , Convert . ToInt32 ( primes [ i ] ) ) ; if ( powers == 0 ) break ; ans = modMult ( ans , powers + 1 , m ) % m ; } if ( ( ( ans - 1 ) % m ) < 0 ) return ( ans - 1 + m ) % m ; else return ( ans - 1 ) % m ; }
int subset ( int [ ] ar , int n ) { int res = 0 ; Array . Sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . Max ( res , count ) ; } return res ; }
int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } }
void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { Console . Write ( i + ", " + j + ", " + k ) ; return ; } } } Console . Write ( "No Triplet" ) ; }
int sumofFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
bool checkFriendly ( int n , int m ) { int sumFactors_n = sumofFactors ( n ) ; int sumFactors_m = sumofFactors ( m ) ; int gcd_n = gcd ( n , sumFactors_n ) ; int gcd_m = gcd ( m , sumFactors_m ) ; if ( n / gcd_n == m / gcd_m && sumFactors_n / gcd_n == sumFactors_m / gcd_m ) return true ; else return false ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int primorial ( int n ) { int p = 2 ; n -- ; for ( int i = 3 ; n != 0 ; i ++ ) { if ( isPrime ( i ) == true ) { p = p * i ; n -- ; } i ++ ; } return p ; }
int findNextPrime ( int n ) { int nextPrime = n + 2 ; while ( true ) { if ( isPrime ( nextPrime ) == true ) break ; nextPrime ++ ; } return nextPrime ; }
int findSum ( int n ) { int multiTerms = n * ( n + 1 ) / 2 ; int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }
double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
void testSomeNumbers ( int limit , int n ) { if ( n < 3 ) return ; for ( int a = 1 ; a <= limit ; a ++ ) for ( int b = a ; b <= limit ; b ++ ) { int pow_sum = ( int ) ( Math . Pow ( a , n ) + Math . Pow ( b , n ) ) ; double c = Math . Pow ( pow_sum , 1.0 / n ) ; int c_pow = ( int ) Math . Pow ( ( int ) c , n ) ; if ( c_pow == pow_sum ) { Console . WriteLine ( "Count example found" ) ; return ; } } Console . WriteLine ( "No counter example within" + " given range and data" ) ; }
void series ( int A , int X , int n ) { int nFact = factorial ( n ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { int niFact = factorial ( n - i ) ; int iFact = factorial ( i ) ; int aPow = ( int ) Math . Pow ( A , n - i ) ; int xPow = ( int ) Math . Pow ( X , i ) ; Console . Write ( ( nFact * aPow * xPow ) / ( niFact * iFact ) + " " ) ; } }
void series ( int A , int X , int n ) { int term = ( int ) Math . Pow ( A , n ) ; Console . Write ( term + " " ) ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; Console . Write ( term + " " ) ; } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void productReduce ( int n , int [ ] num , int [ ] den ) { int new_num = 1 , new_den = 1 ; for ( int i = 0 ; i < n ; i ++ ) { new_num *= num [ i ] ; new_den *= den [ i ] ; } int GCD = gcd ( new_num , new_den ) ; new_num /= GCD ; new_den /= GCD ; Console . WriteLine ( new_num + "/" + new_den ) ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int repeatedNumberSum ( int n , int x ) { int sum = x * digSum ( n ) ; return digSum ( sum ) ; }
int totalSumDivisibleByNum ( int n , int number ) { int firstnum = ( int ) Math . Pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . Pow ( 10 , n ) ; int sum = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }
int minRemove ( int [ ] a , int [ ] b , int n , int m ) { Dictionary < int , int > countA = new Dictionary < int , int > ( ) ; Dictionary < int , int > countB = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( countA . ContainsKey ( a [ i ] ) ) { var v = countA [ a [ i ] ] ; countA . Remove ( countA [ a [ i ] ] ) ; countA . Add ( a [ i ] , v + 1 ) ; } else countA . Add ( a [ i ] , 1 ) ; } for ( int i = 0 ; i < m ; i ++ ) { if ( countB . ContainsKey ( b [ i ] ) ) { var v = countB [ b [ i ] ] ; countB . Remove ( countB [ b [ i ] ] ) ; countB . Add ( b [ i ] , v + 1 ) ; } else countB . Add ( b [ i ] , 1 ) ; } int res = 0 ; foreach ( int x in countA . Keys ) if ( countB . ContainsKey ( x ) ) res += Math . Min ( countB [ x ] , countA [ x ] ) ; return res ; }
int totalSumDivisibleByNum ( int digit , int number ) { int firstnum = ( int ) Math . Pow ( 10 , digit - 1 ) ; int lastnum = ( int ) Math . Pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; int count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; }
int numberofterm ( int n , int number ) { int firstnum = ( int ) Math . Pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . Pow ( 10 , n ) ; int count = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
int sumofseries ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }
int sumofseries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; }
int seiresSum ( int n , int [ ] a ) { int res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }
int seiresSum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
void printGMeans ( int A , int B , int N ) { float R = ( float ) Math . Pow ( ( float ) ( B / A ) , 1.0 / ( float ) ( N + 1 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( A * Math . Pow ( R , i ) + " " ) ; }
bool checkdigit ( int n , int k ) { while ( n != 0 ) { int rem = n % 10 ; if ( rem == k ) return true ; n = n / 10 ; } return false ; }
bool isValid ( long i , long m ) { long sq_i = ( long ) Math . Sqrt ( i ) ; long sq = Math . Min ( m , sq_i ) ; for ( long j = 2 ; j <= sq ; j ++ ) if ( i % j == 0 ) return false ; return true ; }
void findLargestNum ( long n , long m ) { for ( long i = n ; i > m ; i -- ) { if ( isValid ( i , m ) ) { Console . WriteLine ( i ) ; return ; } } Console . WriteLine ( "Number Doesn't Exists" ) ; }
void georgeCantor ( int n ) { int i = 1 ; int j = 1 ; int k = 1 ; while ( k < n ) { j ++ ; k ++ ; if ( k == n ) break ; while ( j > 1 && k < n ) { i ++ ; j -- ; k ++ ; } if ( k == n ) break ; i ++ ; k ++ ; if ( k == n ) break ; while ( i > 1 && k < n ) { i -- ; j ++ ; k ++ ; } } Console . WriteLine ( "N-th term : " + i + "/" + j ) ; }
bool isDivisible ( long n ) { while ( n / 100 > 0 ) { int last_digit = ( int ) n % 10 ; n /= 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }
long digitSum ( long n ) { long digSum = 0 ; while ( n > 0 ) { digSum += n % 10 ; n /= 10 ; } return digSum ; }
long countInteger ( long n , long s ) { if ( n < s ) return 0 ; for ( long i = s ; i <= Math . Min ( n , s + 163 ) ; i ++ ) if ( ( i - digitSum ( i ) ) > s ) return ( n - i + 1 ) ; return 0 ; }
int division ( int num1 , int num2 ) { if ( num1 == 0 ) return 0 ; if ( num2 == 0 ) return int . MaxValue ; bool negResult = false ; if ( num1 < 0 ) { num1 = - num1 ; if ( num2 < 0 ) num2 = - num2 ; else negResult = true ; } else if ( num2 < 0 ) { num2 = - num2 ; negResult = true ; } int quotient = 0 ; while ( num1 >= num2 ) { num1 = num1 - num2 ; quotient ++ ; } if ( negResult ) quotient = - quotient ; return quotient ; }
bool pronic_check ( int n ) { int x = ( int ) ( Math . Sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; }
int power ( int n , int r ) { int count = 0 ; for ( int i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; }
bool isOrthogonal ( int [ , ] a , int m , int n ) { if ( m != n ) return false ; int [ , ] trans = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) trans [ i , j ] = a [ j , i ] ; int [ , ] prod = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int k = 0 ; k < n ; k ++ ) { sum = sum + ( a [ i , k ] * a [ j , k ] ) ; } prod [ i , j ] = sum ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && prod [ i , j ] != 0 ) return false ; if ( i == j && prod [ i , j ] != 1 ) return false ; } } return true ; }
int digitNumber ( long n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 9 ; if ( n % 2 != 0 ) { int temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { int temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } }
int countExcluding ( int n , int d ) { if ( d == 0 ) return ( 9 * digitNumber ( n - 1 ) ) % mod ; else return ( 8 * digitNumber ( n - 1 ) ) % mod ; }
bool isPerfectSquare ( double x ) { if ( x >= 0 ) { double sr = Math . Sqrt ( x ) ; return ( sr * sr == x ) ; } return false ; }
void checkperfectsquare ( int n ) { if ( Math . Ceiling ( ( double ) Math . Sqrt ( n ) ) == Math . Floor ( ( double ) Math . Sqrt ( n ) ) ) { Console . Write ( "perfect square" ) ; } else { Console . Write ( "not a perfect square" ) ; } }
void printGP ( int a , int r , int n ) { int curr_term ; for ( int i = 0 ; i < n ; i ++ ) { curr_term = a * ( int ) Math . Pow ( r , i ) ; Console . Write ( curr_term + " " ) ; } }
int Nth_of_AP ( int a , int d , int N ) { return ( a + ( N - 1 ) * d ) ; }
bool checkFibinnary ( int n ) { int prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }
bool check ( int n , int p ) { int maximum = - 1 ; while ( ( n % 2 ) == 0 ) { maximum = Math . Max ( maximum , 2 ) ; n = n / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maximum = Math . Max ( maximum , i ) ; n = n / i ; } } if ( n > 2 ) maximum = Math . Max ( maximum , n ) ; return ( maximum <= p ) ; }
int Nonagonal ( int n ) { return n * ( 7 * n - 5 ) / 2 ; }
void Nonagonal ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( i * ( 7 * i - 5 ) / 2 ) ; Console . Write ( " " ) ; } }
int findLcm ( int [ , ] arr , int size ) { int ans = arr [ 0 , 1 ] ; for ( int i = 1 ; i < size ; i ++ ) ans = ( ( ( arr [ i , 1 ] * ans ) ) / ( gcd ( arr [ i , 1 ] , ans ) ) ) ; return ( ans ) ; }
bool checkplusperfect ( int x ) { int temp = x ; int n = 0 ; while ( x != 0 ) { x /= 10 ; n ++ ; } x = temp ; int sum = 0 ; while ( x != 0 ) { sum += ( int ) Math . Pow ( x % 10 , n ) ; x /= 10 ; } return ( sum == temp ) ; }
int sum_series ( int n ) { int nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; }
bool isPrime ( int n ) { if ( n == 0 n == 1 ) return false ; int root = ( int ) Math . Sqrt ( n ) ; for ( int i = 2 ; i <= root ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
bool isSandwitched ( int n ) { return ( isPrime ( n - 1 ) && isPrime ( n + 1 ) ) ; }
bool Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; }
float mean ( float [ ] mid , int [ ] freq , int n ) { float sum = 0 , freqSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + mid [ i ] * freq [ i ] ; freqSum = freqSum + freq [ i ] ; } return sum / freqSum ; }
float groupedSD ( float [ ] lower_limit , float [ ] upper_limit , int [ ] freq , int n ) { float [ ] mid = new float [ n ] ; float sum = 0 , freqSum = 0 , sd ; for ( int i = 0 ; i < n ; i ++ ) { mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 ; sum = sum + freq [ i ] * mid [ i ] * mid [ i ] ; freqSum = freqSum + freq [ i ] ; } sd = ( float ) Math . Sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) ; return sd ; }
bool divisibleBy20 ( String num ) { int lastTwoDigits = Int32 . Parse ( num . Substring ( 2 ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; }
double findArea ( double d ) { return ( d * d ) / 2 ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
int getMSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( ( n + 1 ) >> 2 ) ; }
void multiply ( int [ , ] F , int [ , ] M ) { int x = F [ 0 , 0 ] * M [ 0 , 0 ] + F [ 0 , 1 ] * M [ 1 , 0 ] ; int y = F [ 0 , 0 ] * M [ 0 , 1 ] + F [ 0 , 1 ] * M [ 1 , 1 ] ; int z = F [ 1 , 0 ] * M [ 0 , 0 ] + F [ 1 , 1 ] * M [ 1 , 0 ] ; int w = F [ 1 , 0 ] * M [ 0 , 1 ] + F [ 1 , 1 ] * M [ 1 , 1 ] ; F [ 0 , 0 ] = x ; F [ 0 , 1 ] = y ; F [ 1 , 0 ] = z ; F [ 1 , 1 ] = w ; }
void power ( int [ , ] F , int n ) { if ( n == 0 n == 1 ) return ; int [ , ] M = { { 1 , 1 } , { 1 , 0 } } ; for ( int m = getMSB ( n ) ; m > 0 ; m = m >> 1 ) { multiply ( F , F ) ; if ( ( n & m ) > 0 ) { multiply ( F , M ) ; } } }
int fib ( int n ) { int [ , ] F = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) return 0 ; power ( F , n - 1 ) ; return F [ 0 , 0 ] ; }
bool isDvisibleBy12 ( string num ) { if ( num . Length >= 3 ) { int d1 = ( int ) num [ num . Length - 1 ] ; if ( d1 % 2 != 0 ) return false ; int d2 = ( int ) num [ num . Length - 2 ] ; int sum = 0 ; for ( int i = 0 ; i < num . Length ; i ++ ) sum += num [ i ] ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = int . Parse ( num ) ; return ( number % 12 == 0 ) ; } }
int StepstoReachTarget ( int target ) { target = Math . Abs ( target ) ; int n = ( int ) Math . Ceiling ( ( - 1.0 + ( int ) Math . Sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; }
float Calculate_GST ( float org_cost , float N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }
int avg_of_even_num ( int n ) { return n + 1 ; }
int avg_of_odd_num ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; }
int avg_of_odd_num ( int n ) { return n ; }
double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; bool sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; }
bool check ( int n ) { int d = ( int ) Math . Sqrt ( n ) ; if ( d * d == n ) return true ; return false ; }
int largestNonPerfectSquareNumber ( int [ ] a , int n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! check ( a [ i ] ) ) maxi = Math . Max ( a [ i ] , maxi ) ; } return maxi ; }
int modInverse ( int a , int prime ) { a = a % prime ; for ( int x = 1 ; x < prime ; x ++ ) if ( ( a * x ) % prime == 1 ) return x ; return - 1 ; }
void printModIverses ( int n , int prime ) { for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( modInverse ( i , prime ) + " " ) ; }
int countSymmetric ( int n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; }
void SternSequenceFunc ( List < int > BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . Count < n ; i ++ ) { int considered_element = BrocotSequence [ i ] ; int precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . Add ( considered_element + precedent ) ; BrocotSequence . Add ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) Console . Write ( BrocotSequence [ i ] + " " ) ; }
int centeredNonagonal ( int n ) { return ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ; }
void sieve ( int n , bool [ ] prime ) { for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < n ; i += p ) prime [ i ] = false ; } } }
void printSophieGermanNumber ( int n ) { bool [ ] prime = new bool [ 2 * n + 1 ] ; for ( int i = 0 ; i < prime . Length ; i ++ ) { prime [ i ] = true ; } sieve ( 2 * n + 1 , prime ) ; for ( int i = 2 ; i < n ; ++ i ) { if ( prime [ i ] && prime [ 2 * i + 1 ] ) Console . Write ( i + " " ) ; } }
void fib ( int [ ] f , int N ) { f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( int i = 3 ; i <= N ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; }
void printAP ( int a , int d , int n ) { int curr_term ; curr_term = a ; for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( curr_term + " " ) ; curr_term += d ; } }
float Mean ( float [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum / n ; }
bool isRevDiffDivisible ( int x , int k ) { int n = x ; int m = 0 ; while ( x > 0 ) { m = m * 10 + x % 10 ; x /= 10 ; } return ( Math . Abs ( n - m ) % k == 0 ) ; }
int countNumbers ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) if ( isRevDiffDivisible ( i , k ) ) ++ count ; return count ; }
bool isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }
int centeredHexagonalNumber ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
long oddNumSum ( int n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }
bool isPerfectSquare ( int n ) { if ( n < 0 ) return false ; double root = Math . Round ( ( double ) ( Math . Sqrt ( n ) ) ) ; return n == root * root ; }
void printnonsquare ( int n ) { int count = 0 ; for ( int i = 1 ; count < n ; ++ i ) { if ( ! isPerfectSquare ( i ) ) { Console . Write ( i + " " ) ; count ++ ; } } }
int nonsquare ( int n ) { return n + ( int ) ( 0.5 + ( Math . Sqrt ( n ) ) ) ; }
void printNonSquare ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( nonsquare ( i ) + " " ) ; }
int trailingZero ( int x ) { int i = 5 , count = 0 ; while ( x > i ) { count = count + x / i ; i = i * 5 ; } return count ; }
int countProductTrailing ( int M , int N ) { return trailingZero ( N ) + trailingZero ( M ) ; }
bool isTrimorphic ( int N ) { int cube = N * N * N ; while ( N > 0 ) { if ( N % 10 != cube % 10 ) return false ; N /= 10 ; cube /= 10 ; } return true ; }
bool checkTrimorphic ( int num ) { int cube = num * num * num ; while ( num > 0 ) { if ( num % 10 != cube % 10 ) return false ; num /= 10 ; cube /= 10 ; } return true ; }
int averageEven ( int n ) { if ( n % 2 != 0 ) { Console . Write ( "Invalid Input" ) ; return - 1 ; } int sum = 0 , count = 0 ; while ( n >= 2 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; }
int averageEven ( int n ) { if ( n % 2 != 0 ) { Console . Write ( "Invalid Input" ) ; return - 1 ; } return ( n + 2 ) / 2 ; }
int averageOdd ( int n ) { if ( n % 2 == 0 ) { Console . Write ( "Invalid Input" ) ; return - 1 ; } int sum = 0 , count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; }
long fifthPowerSum ( int n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; }
int find_distance ( int n ) { return n * ( ( 3 * n ) + 7 ) ; }
void nearestPerfectSquare ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int sr = ( int ) Math . Sqrt ( arr [ i ] ) ; if ( ( sr & 1 ) == ( arr [ i ] & 1 ) ) Console . Write ( ( sr * sr ) + " " ) ; else { sr ++ ; Console . Write ( ( sr * sr ) + " " ) ; } } }
int squareSum ( int n ) { return n * ( 4 * n * n - 1 ) / 3 ; }
int squareSum ( int n ) { return 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ; }
bool isMunchhausen ( int n ) { long sum = 0 ; int temp = n ; while ( temp > 0 ) { int index = temp % 10 ; sum = sum + pwr [ index ] ; temp /= 10 ; } return ( sum == n ) ; }
int kthdigit ( int a , int b , int k ) { int p = ( int ) Math . Pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
bool isPentagonal ( int N ) { int i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
long fourthPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; }
int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
int unitnumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( int ) ( Math . Pow ( x , y ) ) ) % 10 ) ; }
bool isPrime ( int n ) { if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i * i <= n ; i += 2 ) if ( n % i == 0 ) return false ; return true ; }
int nextPrime ( int start ) { int next = start + 1 ; while ( ! isPrime ( next ) ) next ++ ; return next ; }
bool areAdjacentPrimes ( int a , int b , int c ) { if ( ! isPrime ( a ) || ! isPrime ( b ) || ! isPrime ( c ) ) return false ; int next = nextPrime ( a ) ; if ( next != b ) return false ; if ( nextPrime ( b ) != c ) return false ; return true ; }
int findDivisor ( int x , int y ) { if ( x == y ) return y ; return 2 ; }
long digSum ( long n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
long PowDigSum ( long n , long x ) { long sum = digSum ( n ) ; long rem = x % 6 ; if ( ( sum == 3 sum == 6 ) && x > 1 ) return 9 ; else if ( x == 1 ) return sum ; else if ( x == 0 ) return 1 ; else if ( rem == 0 ) return digSum ( ( long ) Math . Pow ( sum , 6 ) ) ; else return digSum ( ( long ) Math . Pow ( sum , rem ) ) ; }
float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }
float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
float func ( float x ) { return ( 1 / ( 1 + x * x ) ) ; }
float calculate ( float lower_limit , float upper_limit , int interval_limit ) { float interval_size = ( upper_limit - lower_limit ) / interval_limit ; float sum = func ( lower_limit ) + func ( upper_limit ) ; for ( int i = 1 ; i < interval_limit ; i ++ ) { if ( i % 3 == 0 ) sum = sum + 2 * func ( lower_limit + i * interval_size ) ; else sum = sum + 3 * func ( lower_limit + i * interval_size ) ; } return ( 3 * interval_size / 8 ) * sum ; }
int LCM ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; }
int lcmOfNumerator ( List < pair > vect ) { int lcm = vect [ 0 ] . first ; for ( int i = 1 ; i < vect . Count ; i ++ ) lcm = LCM ( vect [ i ] . first , lcm ) ; return lcm ; }
int gcdOfDemoninators ( List < pair > vect ) { int gcd = vect [ 0 ] . second ; for ( int i = 1 ; i < vect . Count ; i ++ ) gcd = __gcd ( vect [ i ] . second , gcd ) ; return gcd ; }
void lcmOfRationals ( List < pair > vect ) { Console . Write ( lcmOfNumerator ( vect ) + "/" + gcdOfDemoninators ( vect ) ) ; }
void makePermutation ( int [ ] a , int n ) { Dictionary < int , int > count = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . ContainsKey ( a [ i ] ) ) { count [ a [ i ] ] = count [ a [ i ] ] + 1 ; } else { count . Add ( a [ i ] , 1 ) ; } } int next_missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . ContainsKey ( a [ i ] ) && count [ a [ i ] ] != 1 a [ i ] > n a [ i ] < 1 ) { count [ a [ i ] ] = count [ a [ i ] ] - 1 ; while ( count . ContainsKey ( next_missing ) ) next_missing ++ ; a [ i ] = next_missing ; count . Add ( next_missing , 1 ) ; } } }
float focal_length_convex ( float R ) { return - ( R / 2 ) ; }
float focal_length ( float image_distance , float object_distance ) { return 1 / ( ( 1 / image_distance ) + ( 1 / object_distance ) ) ; }
int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
int countSolutions ( int n , int val ) { int total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( int i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; }
int lcm ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool twinPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && Math . Abs ( n1 - n2 ) == 2 ) ; }
int mobius ( int n ) { int p = 0 ; if ( n % 2 == 0 ) { n = n / 2 ; p ++ ; if ( n % 2 == 0 ) return 0 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; p ++ ; if ( n % i == 0 ) return 0 ; } } return ( p % 2 == 0 ) ? - 1 : 1 ; }
void fib ( int [ ] f , int n ) { int i ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( i = 2 ; i <= n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; }
void fibcoef ( int [ , ] fc , int [ ] f , int n ) { for ( int i = 0 ; i <= n ; i ++ ) fc [ i , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { int k = j ; while ( k > 0 ) { k -- ; fc [ i , j ] *= f [ k ] ; } k = 1 ; while ( ( j + 1 ) != k ) fc [ i , j ] /= f [ k ++ ] ; } } }
double sumOfSeries ( int n ) { return 0.0246 * ( Math . Pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
int sumofNterm ( int a , int d , int b , int r , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( int ) ( ( a + ( i - 1 ) * d ) * ( b * Math . Pow ( r , i - 1 ) ) ) ; return sum ; }
double sumOfTheSeries ( int n ) { double sum = 0.0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; }
long sum ( long n ) { long root = ( long ) Math . Sqrt ( n ) ; long ans = 0 ; for ( int i = 1 ; i <= root ; i ++ ) ans += n / i ; ans = 2 * ans - ( root * root ) ; return ans ; }
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 2 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
int sumOfTheSeries ( int n ) { int sum_n = ( n * ( n + 1 ) / 2 ) ; int sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; }
int sumofsquare ( int n ) { int [ , ] C = new int [ n + 1 , n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n , i ] * C [ n , i ] ) ; return sum ; }
int factorial ( int start , int end ) { int res = 1 ; for ( int i = start ; i <= end ; i ++ ) res *= i ; return res ; }
int sumofsquare ( int n ) { return factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * i ; return sum ; }
int sumOfSeries ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
int evenSum ( int n ) { int [ , ] C = new int [ n + 1 , n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i += 2 ) sum += C [ n , i ] ; return sum ; }
int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 / Math . Pow ( i , i ) ; sums += ser ; } return sums ; }
int TrinomialValue ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k < - n k > n ) return 0 ; return TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 ) ; }
int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; }
float Series ( double x , int n ) { double sum = 1 , term = 1 , fct = 1 ; double p = 1 , multi = 1 ; for ( int i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( - 1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return ( float ) sum ; }
bool isPresent ( int [ ] arr , int low , int high , int value ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == value ) return true ; else if ( arr [ mid ] > value ) high = mid - 1 ; else low = mid + 1 ; } return false ; }
int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int value = x - arr1 [ i ] ; if ( isPresent ( arr2 , 0 , n - 1 , value ) ) count ++ ; } return count ; }
int two_factor ( int n ) { int twocount = 0 ; while ( n % 2 == 0 ) { twocount ++ ; n = n / 2 ; } return twocount ; }
int five_factor ( int n ) { int fivecount = 0 ; while ( n % 5 == 0 ) { fivecount ++ ; n = n / 5 ; } return fivecount ; }
int find_con_zero ( int [ ] arr , int n ) { int twocount = 0 ; int fivecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twocount += two_factor ( arr [ i ] ) ; fivecount += five_factor ( arr [ i ] ) ; } if ( twocount < fivecount ) return twocount ; else return fivecount ; }
int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 ; int fn = 5 ; while ( t < n ) { fn = ( int ) Math . Round ( fn * PHI ) ; t ++ ; } return fn ; }
int first ( int a , int b , int c ) { a %= b ; for ( int i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return - 1 ; }
void subsetDifference ( int n ) { int s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { Console . WriteLine ( "First " + "subset sum = " + s / 2 ) ; Console . WriteLine ( "Second " + "subset sum = " + s / 2 ) ; Console . WriteLine ( "Difference" + " = " + 0 ) ; } else { if ( n % 4 == 1 n % 4 == 2 ) { Console . WriteLine ( "First " + "subset sum = " + s / 2 ) ; Console . WriteLine ( "Second " + "subset sum = " + ( ( s / 2 ) + 1 ) ) ; Console . WriteLine ( "Difference" + " = " + 1 ) ; } else { Console . WriteLine ( "First " + "subset sum = " + s / 2 ) ; Console . WriteLine ( "Second " + "subset sum = " + s / 2 ) ; Console . WriteLine ( "Difference" + " = " + 0 ) ; } } }
float func ( float x , float y ) { return ( x + y + x * y ) ; }
void euler ( float x0 , float y , float h , float x ) { while ( x0 < x ) { y = y + h * func ( x0 , y ) ; x0 = x0 + h ; } Console . WriteLine ( "Approximate solution at x = " + x + " is " + y ) ; }
void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; Console . WriteLine ( ( float ) time ) ; }
int maxcoefficientvalue ( int n ) { if ( n % 2 == 0 ) return binomialCoeff ( n , n / 2 ) ; else return binomialCoeff ( n , ( n + 1 ) / 2 ) ; }
int LCM ( int x , int y , int z ) { int ans = ( ( x * y ) / ( __gcd ( x , y ) ) ) ; return ( ( z * ans ) / ( __gcd ( ans , z ) ) ) ; }
int findDivisible ( int n , int x , int y , int z ) { int lcm = LCM ( x , y , z ) ; int ndigitnumber = ( int ) Math . Pow ( 10 , n - 1 ) ; int reminder = ndigitnumber % lcm ; if ( reminder == 0 ) return ndigitnumber ; ndigitnumber += lcm - reminder ; if ( ndigitnumber < Math . Pow ( 10 , n ) ) return ndigitnumber ; else return 0 ; }
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
int sumOfTheSeries ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
void checksum ( int n ) { if ( n == 0 ) { Console . WriteLine ( "-1 0 1" ) ; return ; } int inc ; if ( n > 0 ) inc = 1 ; else inc = - 1 ; for ( int i = 0 ; i <= n - 2 ; i += inc ) { if ( i + i + 1 + i + 2 == n ) { Console . WriteLine ( i + " " + ( i + 1 ) + " " + ( i + 2 ) ) ; return ; } } Console . WriteLine ( "-1" ) ; }
void checksum ( int n ) { if ( n % 3 == 0 ) Console . WriteLine ( n / 3 - 1 + " " + n / 3 + " " + ( n / 3 + 1 ) ) ; else Console . WriteLine ( "-1" ) ; }
void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { Console . Write ( "x = " + i + ", y = " + ( n - ( i * a ) ) / b ) ; return ; } } Console . Write ( "No solution" ) ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }
int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
int sum_all_divisors ( int num ) { int sum = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( num ) ; i ++ ) { sum += t1 + t2 ; } return sum ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int sumOfLargePrimeFactor ( int n ) { int [ ] prime = new int [ n + 1 ] ; int sum = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) prime [ i ] = 0 ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] != 0 ) sum += prime [ p ] ; else sum += p ; } return sum ; }
int gcd ( int a , int b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int cpFact ( int x , int y ) { while ( gcd ( x , y ) != 1 ) { x = x / gcd ( x , y ) ; } return x ; }
int binomialCoeffSum ( int n ) { return ( 1 << n ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int countUnsetBitsInGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return ( r - l + 1 ) - countSetBits ( n & num ) ; }
long evenPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; }
long evenPowerSum ( int n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; }
int balancedprime ( int n ) { bool [ ] prime = new bool [ MAX + 1 ] ; for ( int k = 0 ; k < MAX + 1 ; k ++ ) prime [ k ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } List < int > v = new List < int > ( ) ; for ( int p = 3 ; p <= MAX ; p += 2 ) if ( prime [ p ] ) v . Add ( p ) ; int c = 0 ; for ( int i = 1 ; i < v . Count - 1 ; i ++ ) { if ( ( int ) v [ i ] == ( int ) ( v [ i + 1 ] + v [ i - 1 ] ) / 2 ) c ++ ; if ( c == n ) return ( int ) v [ i ] ; } return 1 ; }
int calculateNoOFactors ( int n ) { if ( n == 1 ) return 1 ; int ans = 1 ; int dup = factor [ n ] ; int c = 1 ; int j = n / factor [ n ] ; while ( j != 1 ) { if ( factor [ j ] == dup ) c += 1 ; else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; } j = j / factor [ j ] ; } ans = ans * ( c + 1 ) ; return ans ; }
int smallest ( int n ) { for ( int i = 1 ; ; i ++ ) if ( calculateNoOFactors ( i ) >= n ) return i ; }
int squaresum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }
int minimumSum ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; if ( isPrime ( n - 2 ) ) return 2 ; return 3 ; }
int lastDigit ( int n ) { return ( n % 10 ) ; }
double numberOfTriangles ( int n ) { double ans = 2 * ( Math . Pow ( 3 , n ) ) - 1 ; return ans ; }
bool isPrime ( int x ) { if ( x == 0 x == 1 ) return false ; for ( int i = 2 ; i * i <= x ; ++ i ) if ( x % i == 0 ) return false ; return true ; }
void findPrimes ( int n ) { Console . WriteLine ( n ) ; Console . Write ( 2 + " " + ( n - 2 ) ) ; { Console . Write ( 3 + " " ) ; n = n - 3 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( i ) && isPrime ( n - i ) ) { Console . WriteLine ( i + " " + ( n - i ) ) ; break ; } } } }
bool checkDigits ( int n ) { while ( n > 0 ) { int dig = n % 10 ; if ( dig != 2 && dig != 3 && dig != 5 && dig != 7 ) return false ; n /= 10 ; } return true ; }
bool prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
bool isFullPrime ( int n ) { return ( checkDigits ( n ) && prime ( n ) ) ; }
void coef ( int n ) { c [ 0 ] = 1 ; for ( int i = 0 ; i < n ; c [ 0 ] = - c [ 0 ] , i ++ ) { c [ 1 + i ] = 1 ; for ( int j = i ; j > 0 ; j -- ) c [ j ] = c [ j - 1 ] - c [ j ] ; } }
bool isPrime ( int n ) { coef ( n ) ; c [ 0 ] ++ ; c [ n ] -- ; int i = n ; while ( ( i -- ) > 0 && c [ i ] % n == 0 ) ; return i < 0 ; }
int motzkin ( int n ) { if ( n == 0 n == 1 ) return 1 ; return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) ; }
double sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / Math . Pow ( 10 , n ) ) ; }
bool check ( int n ) { int l = countDigit ( n ) ; int dup = n ; int sum = 0 ; while ( dup > 0 ) { sum += ( int ) Math . Pow ( dup % 10 , l ) ; dup /= 10 ; } return ( n == sum ) ; }
string getResult ( string st ) { int sum = 0 ; int length = st . Length ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + ( int ) Math . Pow ( st [ i ] - '0' , length ) ; } int number = int . Parse ( st ) ; if ( number == sum ) return "yes" ; else return "no" ; }
int solve ( int low , int high , int T ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }
int nthSHN ( int n , int [ ] dp ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
void leyland ( int n ) { ArrayList ans = new ArrayList ( ) ; for ( int x = 2 ; x <= n ; x ++ ) { for ( int y = 2 ; y <= x ; y ++ ) { int temp = ( int ) Math . Pow ( x , y ) + ( int ) Math . Pow ( y , x ) ; ans . Add ( temp ) ; } } ans . Sort ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( ans [ i ] + " " ) ; } }
bool isOverflow ( long a , long b ) { if ( a == 0 b == 0 ) return false ; long result = a * b ; if ( a == result / b ) return false ; else return true ; }
int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- > 0 ) { sum += cur ; cur += 2 ; } return sum ; }
int oddSum ( int n ) { return ( n * n ) ; }
double mphTOkmph ( double mph ) { return mph * 1.60934 ; }
int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }
int trace ( int n , int m ) { int an = 1 + ( n - 1 ) * ( m + 1 ) ; int rowmajorSum = sn ( n , an ) ; an = 1 + ( n - 1 ) * ( n + 1 ) ; int colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; }
void precompute ( int [ ] prefix , int [ ] suffix ) { bool [ ] prime = new bool [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { prime [ i ] = true ; } for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * i ; j < MAX ; j += i ) { prime [ j ] = false ; } } } prefix [ 1 ] = 1 ; suffix [ MAX - 1 ] = ( int ) 1e9 + 7 ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) { prefix [ i ] = i ; } else { prefix [ i ] = prefix [ i - 1 ] ; } } for ( int i = MAX - 2 ; i > 1 ; i -- ) { if ( prime [ i ] ) { suffix [ i ] = i ; } else { suffix [ i ] = suffix [ i + 1 ] ; } } }
int query ( int [ ] prefix , int [ ] suffix , int L , int R ) { if ( prefix [ R ] < L suffix [ L ] > R ) { return 0 ; } else { return prefix [ R ] - suffix [ L ] ; } }
void printXYZ ( int n ) { if ( n == 1 ) Console . WriteLine ( - 1 ) ; else { Console . WriteLine ( "x is " + n ) ; Console . WriteLine ( "y is " + ( n + 1 ) ) ; Console . WriteLine ( "z is " + ( n * ( n + 1 ) ) ) ; } }
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
int term ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; }
int term ( int n ) { return n * ( n + 1 ) / 2 ; }
float avgOfFirstN ( int n ) { return ( float ) ( 1 + n ) / 2 ; }
int summation ( int n ) { int sum ; sum = ( int ) ( Math . Pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }
float sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return ( float ) total ; }
int term ( int n ) { int x = ( ( ( 1 ) + ( int ) Math . Sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
bool isMember ( int a , int d , int x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = Math . Sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; }
int countDigits ( int n ) { int c = 0 ; do { c ++ ; n = n / 10 ; } while ( n != 0 ) ; return c ; }
bool isDeserium ( int x ) { int temp = x ; int p = countDigits ( x ) ; int sum = 0 ; while ( x != 0 ) { int digit = x % 10 ; sum += ( int ) Math . Pow ( digit , p ) ; p -- ; x = x / 10 ; } return ( sum == temp ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int sameRemainder ( int a , int b , int c ) { int a1 = ( b - a ) , b1 = ( c - b ) , c1 = ( c - a ) ; return gcd ( a1 , gcd ( b1 , c1 ) ) ; }
float mean ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; float mean = ( float ) sum / n ; return mean ; }
float sd ( int [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ; float sdd = sum / n ; return sdd ; }
bool checkDivisibility ( string num ) { int length = num . Length ; if ( length == 1 && num [ 0 ] == '0' ) return true ; if ( length % 3 == 1 ) { num += "00" ; length += 2 ; } else if ( length % 3 == 2 ) { num += "0" ; length += 1 ; } int sum = 0 , p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num [ i -- ] - '0' ; group += ( num [ i -- ] - '0' ) * 10 ; group += ( num [ i ] - '0' ) * 100 ; sum = sum + group * p ; p *= ( - 1 ) ; } sum = Math . Abs ( sum ) ; return ( sum % 13 == 0 ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findNumber ( int [ ] arr , int n ) { int ans = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) ans = gcd ( ans , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == ans ) return ans ; return - 1 ; }
void modularEquation ( int a , int b ) { if ( a < b ) { Console . WriteLine ( "No solution possible " ) ; return ; } if ( a == b ) { Console . WriteLine ( "Infinite Solution possible " ) ; return ; } int count = 0 ; int n = a - b ; int y = ( int ) Math . Sqrt ( a - b ) ; for ( int i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; Console . WriteLine ( count ) ; }
void SieveofEratosthenes ( int n ) { bool [ ] visited = new bool [ n * n + 2 ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) if ( ! visited [ i ] ) { for ( int j = i * i ; j <= n + 1 ; j += i ) visited [ j ] = true ; primes . Add ( i ) ; } }
bool specialPrimeNumbers ( int n , int k ) { SieveofEratosthenes ( n ) ; int count = 0 ; for ( int i = 0 ; i < primes . Count ; i ++ ) { for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( ( int ) primes [ j ] + ( int ) primes [ j + 1 ] + 1 == ( int ) primes [ i ] ) { count ++ ; break ; } } if ( count == k ) return true ; } return false ; }
int minOp ( int num ) { int rem ; int count = 0 ; while ( num > 0 ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num /= 10 ; } return count ; }
int findSubarraySum ( int [ ] arr , int n , int sum ) { Dictionary < int , int > prevSum = new Dictionary < int , int > ( ) ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == sum ) res ++ ; if ( prevSum . ContainsKey ( currsum - sum ) ) res += prevSum [ currsum - sum ] ; if ( ! prevSum . ContainsKey ( currsum ) ) prevSum . Add ( currsum , 1 ) ; else { int count = prevSum [ currsum ] ; prevSum [ currsum ] = count + 1 ; } } return res ; }
int minimumMoves ( int [ ] A , int N ) { int one = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] == 1 ) one ++ ; if ( one != 0 ) return N - one ; int minimum = int . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { int g = A [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { g = __gcd ( A [ j ] , g ) ; if ( g == 1 ) { minimum = Math . Min ( minimum , j - i ) ; break ; } } } if ( minimum == int . MaxValue ) return - 1 ; else return N + minimum - 1 ; }
bool sumSquare ( int n ) { Dictionary < int , int > s = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i * i <= n ; ++ i ) { s . Add ( i * i , 1 ) ; if ( s . ContainsKey ( n - i * i ) ) { Console . WriteLine ( ( int ) Math . Sqrt ( n - i * i ) + "^2 + " + i + "^2" ) ; return true ; } } return false ; }
int countPairs ( int [ ] arr , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }
bool judgeSquareSum ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n /= i ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; }
void preCompute ( int [ , ] mat , int [ , ] prefixCnt ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i , j ] == 0 ) { prefixCnt [ i , j ] = 1 ; } else { prefixCnt [ i , j ] = 0 ; } } } for ( int i = 0 ; i < M ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) prefixCnt [ i , j ] += prefixCnt [ i , j - 1 ] ; for ( int i = 1 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) prefixCnt [ i , j ] += prefixCnt [ i - 1 , j ] ; }
int countQuery ( int [ , ] prefixCnt , int pi , int pj , int qi , int qj ) { int cnt = prefixCnt [ qi , qj ] ; if ( pi > 0 ) cnt -= prefixCnt [ pi - 1 , qj ] ; if ( pj > 0 ) cnt -= prefixCnt [ qi , pj - 1 ] ; if ( pi > 0 && pj > 0 ) cnt += prefixCnt [ pi - 1 , pj - 1 ] ; return cnt ; }
void series ( int n , int d ) { if ( d == 0 ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( "0" ) ; Console . WriteLine ( ) ; return ; } if ( n % 2 == 0 ) { for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( Math . Pow ( - 1 , i ) * d + " " ) ; } Console . WriteLine ( ) ; } else { float m = n ; float r = ( m / ( m - 1 ) ) ; float g = ( float ) ( d * ( float ) ( Math . Sqrt ( r ) ) ) ; Console . Write ( "0 " ) ; for ( int i = 1 ; i < n ; i ++ ) { Console . Write ( Math . Pow ( - 1 , i ) * g + " " ) ; } Console . WriteLine ( ) ; } }
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { string str = i . ToString ( ) ; countr += str . Split ( "1" ) . Length - 1 ; } return countr ; }
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int divider = i * 10 ; countr += ( n / divider ) * i + Math . Min ( Math . Max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }
int countPairs ( int [ ] arr , int n ) { int result = 0 ; HashSet < int > Hash = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Hash . Add ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; if ( Hash . Contains ( product ) ) { result ++ ; } } } return result ; }
bool check ( long a , long b ) { long c = 0 ; while ( a != 0 ) { c = c + a % 10 ; a = a / 10 ; } return ( c == b ) ; }
long root ( long n ) { bool found = false ; long mx = ( long ) 1E18 ; for ( long i = 0 ; i <= 90 ; i ++ ) { long s = i * i + 4 * n ; long sq = ( long ) Math . Sqrt ( s ) ; if ( sq * sq == s && check ( ( sq - i ) / 2 , i ) ) { found = true ; mx = Math . Min ( mx , ( sq - i ) / 2 ) ; } } if ( found ) return mx ; else return - 1 ; }
int factors ( int n ) { Dictionary < int , int > prime = new Dictionary < int , int > ( ) ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; ++ i ) { while ( n % i == 0 ) { if ( prime . ContainsKey ( i ) ) { prime [ i ] = prime [ i ] + 1 ; } else { prime . Add ( i , 1 ) ; } n = n / i ; } } if ( n > 2 ) { if ( prime . ContainsKey ( n ) ) { prime [ n ] = prime [ n ] + 1 ; } else { prime . Add ( n , 1 ) ; } } int ans1 = 1 , ans2 = 1 ; foreach ( KeyValuePair < int , int > it in prime ) { ans1 *= 2 * it . Value + 1 ; ans2 *= it . Value + 1 ; } return ans1 - ans2 ; }
int gcdOfFactorial ( int m , int n ) { int min = m < n ? m : n ; return factorial ( min ) ; }
bool asPowerSum ( int w , int m ) { while ( m > 0 ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; }
int dotProduct ( int [ ] vect_A , int [ ] vect_B ) { int product = 0 ; for ( int i = 0 ; i < n ; i ++ ) product = product + vect_A [ i ] * vect_B [ i ] ; return product ; }
void crossProduct ( int [ ] vect_A , int [ ] vect_B , int [ ] cross_P ) { cross_P [ 0 ] = vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ; cross_P [ 1 ] = vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ; cross_P [ 2 ] = vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ; }
int calculate ( int n , int power ) { int sum = 0 ; int bp = ( int ) Math . Pow ( n , power ) ; while ( bp != 0 ) { int d = bp % 10 ; sum += d ; bp /= 10 ; } return sum ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( 1 * res * x ) % p ; x = ( 1 * x * x ) % p ; } return res ; }
int countEvenWays ( int n ) { return power ( 2 , n / 2 - 1 , MOD ) ; }
void cal_factor ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } }
int no_of_representations ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = a [ i ] ; int flag = 0 ; while ( factor [ temp ] != 1 ) { flag = - 1 ; count ++ ; temp = temp / factor [ temp ] ; } count += flag ; } return count ; }
bool coprime ( int a , int b ) { return ( __gcd ( a , b ) == 1 ) ; }
void pairSum ( int n ) { int mid = n / 2 ; for ( int i = mid ; i >= 1 ; i -- ) { if ( coprime ( i , n - i ) == true ) { Console . Write ( i + " " + ( n - i ) ) ; break ; } } }
int coutSubSeq ( int [ ] A , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
int countSubSeq ( int [ ] A , int N , int M ) { int ans = 0 ; int [ ] h = new int [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = A [ i ] % M ; h [ A [ i ] ] ++ ; } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = i ; j < M ; j ++ ) { int rem = ( M - ( i + j ) % M ) % M ; if ( rem < j ) continue ; if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ; else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ; else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ; else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ; else ans = ans + h [ i ] * h [ j ] * h [ rem ] ; } } return ans ; }
int findTerm ( int n ) { if ( n == 1 ) return n ; else { int term = 7 ; for ( int i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } }
int findNumber ( int n ) { n -- ; int i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
int findNumber ( int n ) { int x = ( int ) Math . Floor ( ( - 1 + Math . Sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; int Base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - Base + 1 ; }
float correlationCoefficient ( int [ ] X , int [ ] Y , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( float ) ( Math . Sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; }
void result ( long n , long k , long t ) { if ( t <= k ) Console . WriteLine ( t ) ; else if ( t <= n ) Console . WriteLine ( k ) ; else { long temp = t - n ; temp = k - temp ; Console . WriteLine ( temp ) ; } }
float weightedMean ( int [ ] X , int [ ] W , int n ) { int sum = 0 , numWeight = 0 ; for ( int i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( float ) ( numWeight ) / sum ; }
int weightedMean ( int n ) { return ( 2 * n + 1 ) / 3 ; }
int sumOfDigits ( int a ) { int sum = 0 ; while ( a != 0 ) { sum += a % 10 ; a /= 10 ; } return sum ; }
int findMax ( int x ) { int b = 1 , ans = x ; while ( x != 0 ) { int cur = ( x - 1 ) * b + ( b - 1 ) ; if ( sumOfDigits ( cur ) > sumOfDigits ( ans ) || ( sumOfDigits ( cur ) == sumOfDigits ( ans ) && cur > ans ) ) ans = cur ; x /= 10 ; b *= 10 ; } return ans ; }
int series ( int n ) { return ( 8 * n * n ) + 1 ; }
float gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . Abs ( b ) < 0.001 ) return ( float ) a ; else return ( float ) ( gcd ( b , a - Math . Floor ( a / b ) * b ) ) ; }
float harmonicMean ( float [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) 1 / arr [ i ] ; return ( float ) n / sum ; }
float harmonicMean ( int [ ] arr , int [ ] freq , int n ) { float sum = 0 , frequency_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( float ) freq [ i ] / arr [ i ] ; frequency_sum = frequency_sum + freq [ i ] ; } return ( frequency_sum / sum ) ; }
void calculate ( int [ ] a , int [ ] b , int n , int m ) { int mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) Math . Floor ( ( double ) ( a [ i ] / mul ) ) ; Console . Write ( x + " " ) ; } }
void modBigNumber ( string num , long m ) { List < int > vec = new List < int > ( ) ; long mod = 0 ; for ( int i = 0 ; i < num . Length ; i ++ ) { int digit = num [ i ] - '0' ; mod = mod * 10 + digit ; int quo = ( int ) ( mod / m ) ; vec . Add ( quo ) ; mod = mod % m ; } Console . Write ( "Remainder : " + mod + "\n" ) ; Console . Write ( "Quotient : " ) ; bool zeroflag = false ; for ( int i = 0 ; i < vec . Count ; i ++ ) { if ( vec [ i ] == 0 && zeroflag == false ) { continue ; } zeroflag = true ; Console . Write ( vec [ i ] ) ; } return ; }
int findPowerOfP ( int n , int p ) { int count = 0 ; int r = p ; while ( r <= n ) { count += ( n / r ) ; r = r * p ; } return count ; }
List < pair > primeFactorsofK ( int k ) { List < pair > ans = new List < pair > ( ) ; for ( int i = 2 ; k != 1 ; i ++ ) { if ( k % i == 0 ) { int count = 0 ; while ( k % i == 0 ) { k = k / i ; count ++ ; } ans . Add ( new pair ( i , count ) ) ; } } return ans ; }
int largestPowerOfK ( int n , int k ) { List < pair > vec = new List < pair > ( ) ; vec = primeFactorsofK ( k ) ; int ans = int . MaxValue ; for ( int i = 0 ; i < vec . Count ; i ++ ) ans = Math . Min ( ans , findPowerOfP ( n , vec [ i ] . first ) / vec [ i ] . second ) ; return ans ; }
int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; }
void fourDistinctFactors ( ) { bool [ ] primeAll = new bool [ N + 1 ] ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( primeAll [ p ] == false ) { for ( int i = p * 2 ; i <= N ; i += p ) primeAll [ i ] = true ; } } ArrayList prime = new ArrayList ( ) ; for ( int p = 2 ; p <= N ; p ++ ) if ( ! primeAll [ p ] ) prime . Add ( p ) ; for ( int i = 0 ; i < prime . Count ; ++ i ) { int p = ( int ) prime [ i ] ; if ( 1L * p * p * p <= N ) fourDiv [ p * p * p ] = true ; for ( int j = i + 1 ; j < prime . Count ; ++ j ) { int q = ( int ) prime [ j ] ; if ( 1L * p * q > N ) break ; fourDiv [ p * q ] = true ; } } }
int horner ( int [ ] poly , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; }
int findSign ( int [ ] poly , int n , int x ) { int result = horner ( poly , n , x ) ; if ( result > 0 ) return 1 ; else if ( result < 0 ) return - 1 ; return 0 ; }
double ucal ( double u , int n ) { if ( n == 0 ) return 1 ; double temp = u ; for ( int i = 1 ; i <= n / 2 ; i ++ ) temp = temp * ( u - i ) ; for ( int i = 1 ; i < n / 2 ; i ++ ) temp = temp * ( u + i ) ; return temp ; }
int digitLCM ( int n ) { int lcm = 1 ; while ( n > 0 ) { lcm = ( n % 10 * lcm ) / lcm_fun ( n % 10 , lcm ) ; if ( lcm == 0 ) return 0 ; n = n / 10 ; } return lcm ; }
void gcdMax ( int [ ] a , int [ ] b , int n , int N ) { int [ ] cnt = new int [ N ] ; int [ ] first = new int [ N ] ; int [ ] second = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . Max ( first [ i ] , j ) ; cnt = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . Max ( second [ i ] , j ) ; int x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; Console . WriteLine ( first [ x ] + " " + second [ x ] ) ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
long ispowerof2 ( long num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; }
int median ( int [ ] a , int l , int r ) { int n = r - l + 1 ; n = ( n + 1 ) / 2 - 1 ; return n + l ; }
int IQR ( int [ ] a , int n ) { Array . Sort ( a ) ; int mid_index = median ( a , 0 , n ) ; int Q1 = a [ median ( a , 0 , mid_index ) ] ; int Q3 = a [ mid_index + median ( a , mid_index + 1 , n ) ] ; return ( Q3 - Q1 ) ; }
void printPierpont ( int n ) { bool [ ] arr = new bool [ n + 1 ] ; int two = 1 , three = 1 ; while ( two + 1 < n ) { arr [ two ] = true ; while ( two * three + 1 < n ) { arr [ three ] = true ; arr [ two * three ] = true ; three *= 3 ; } three = 1 ; two *= 2 ; } ArrayList v = new ArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] ) v . Add ( i + 1 ) ; arr = new bool [ n + 1 ] ; for ( int p = 2 ; p * p < n ; p ++ ) { if ( arr [ p ] == false ) for ( int i = p * 2 ; i < n ; i += p ) arr [ i ] = true ; } for ( int i = 0 ; i < v . Count ; i ++ ) if ( ! arr [ ( int ) v [ i ] ] ) Console . Write ( v [ i ] + " " ) ; }
bool isWoodall ( int x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; int p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; }
void print_result ( int [ ] a , int n , int k , int m ) { List < List < int > > v = new List < List < int > > ( m ) ; for ( int i = 0 ; i < m ; i ++ ) v . Add ( new List < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int rem = a [ i ] % m ; v [ rem ] . Add ( a [ i ] ) ; if ( v [ rem ] . Count == k ) { for ( int j = 0 ; j < k ; j ++ ) Console . Write ( v [ rem ] [ j ] + " " ) ; return ; } } Console . Write ( "-1" ) ; }
int smallestX ( int n ) { int [ ] temp = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) temp [ i ] = 0 ; if ( n == 0 ) return - 1 ; int count = 0 , x = 0 ; for ( x = 1 ; count < 10 ; x ++ ) { int y = x * n ; while ( y > 0 ) { if ( temp [ y % 10 ] == 0 ) { count ++ ; temp [ y % 10 ] = 1 ; } y /= 10 ; } } return x - 1 ; }
int digSum ( int n ) { int sum = 0 , rem = 0 ; while ( n > 0 ) { rem = n % 10 ; sum += rem ; n /= 10 ; } return sum ; }
int findX ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( i + digSum ( i ) == n ) return i ; return - 1 ; }
bool isDivisible ( int x , int y ) { if ( y == 1 ) return true ; int z = gcd ( x , y ) ; if ( z == 1 ) return false ; return isDivisible ( x , y / z ) ; }
bool isDigitPresent ( int m , bool [ ] hash ) { while ( m > 0 ) { if ( hash [ m % 10 ] ) return true ; m = m / 10 ; } return false ; }
int countDivisibles ( int n ) { bool [ ] hash = new bool [ 10 ] ; int m = n ; while ( m > 0 ) { hash [ m % 10 ] = true ; m = m / 10 ; } int ans = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( isDigitPresent ( i , hash ) ) ans ++ ; if ( n / i != i ) { if ( isDigitPresent ( n / i , hash ) ) ans ++ ; } } } return ans ; }
void printTwoDivisibleParts ( String num , int f , int s ) { int N = num . Length ; int [ ] prefixReminder = new int [ N + 1 ] ; int [ ] suffixReminder = new int [ N + 1 ] ; suffixReminder [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) suffixReminder [ i ] = ( suffixReminder [ i - 1 ] * 10 + ( num [ i - 1 ] - '0' ) ) % f ; prefixReminder [ N ] = 0 ; int base1 = 1 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { prefixReminder [ i ] = ( prefixReminder [ i + 1 ] + ( num [ i ] - '0' ) * base1 ) % s ; base1 = ( base1 * 10 ) % s ; } for ( int i = 0 ; i < N ; i ++ ) { if ( prefixReminder [ i ] == 0 && suffixReminder [ i ] == 0 && num [ i ] != '0' ) { Console . WriteLine ( num . Substring ( 0 , i ) + " " + num . Substring ( i ) ) ; return ; } } Console . WriteLine ( "Not Possible" ) ; }
int sum ( int n ) { int rem = 0 ; int sum_of_digits = 0 ; while ( n > 0 ) { rem = n % 10 ; sum_of_digits += rem ; n = n / 10 ; } return sum_of_digits ; }
int count ( int n ) { int c = 0 ; for ( int i = n - 97 ; i <= n ; i ++ ) { int a = sum ( i ) ; int b = sum ( a ) ; if ( ( i + a + b ) == n ) { c += 1 ; } } return c ; }
bool isPowerOfK ( int n , int k ) { bool oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }
long isOctal ( long n ) { while ( n > 0 ) { if ( ( n % 10 ) >= 8 ) return 0 ; else n = n / 10 ; } return 1 ; }
void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { Console . Write ( fact + " " ) ; fact = fact * x ; x ++ ; } }
float Cel_To_Fah ( float n ) { return ( ( n * 9.0f / 5.0f ) + 32.0f ) ; }
bool printPairs ( int [ ] arr , int n , int k ) { bool isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { Console . Write ( "(" + arr [ i ] + ", " + arr [ j ] + ")" + " " ) ; isPairFound = true ; } } } return isPairFound ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { Console . Write ( "-1" ) ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) Console . Write ( r * i + " " ) ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; Console . WriteLine ( res ) ; } }
int countCompositions ( int n ) { return 1 << ( n - 1 ) ; }
int computeLastDigit ( long A , long B ) { int variable = 1 ; if ( A == B ) return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( long i = A + 1 ; i <= B ; i ++ ) variable = ( int ) ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }
long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
int findMin ( int [ ] a , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . Log ( a [ i ] ) ; int x = ( int ) Math . Exp ( sum / n ) ; return x + 1 ; }
int countdigits ( int N ) { int count = 0 ; while ( N > 0 ) { count ++ ; N = N / 10 ; } return count ; }
float sumOfAP ( float a , float d , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; }
float sumOfAP ( float a , float d , float n ) { float sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
bool printPairs ( int [ ] arr , int n , int k ) { Dictionary < int , bool > occ = new Dictionary < int , bool > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { occ [ arr [ i ] ] = true ; } bool isPairFound = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( occ [ k ] && k < arr [ i ] ) { Console . Write ( "(" + k + ", " + arr [ i ] + ") " ) ; isPairFound = true ; } if ( arr [ i ] >= k ) { List < int > v = findDivisors ( arr [ i ] - k ) ; for ( int j = 0 ; j < v . Count ; j ++ ) { if ( arr [ i ] % v [ j ] == k && arr [ i ] != v [ j ] && occ [ v [ j ] ] ) { Console . Write ( "(" + arr [ i ] + ", " + v [ j ] + ") " ) ; isPairFound = true ; } } v . Clear ( ) ; } } return isPairFound ; }
int sumOfSeries ( int n ) { int x ; if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) ; else x = ( ( n + 1 ) / 2 ) * n ; return x * x ; }
int findValue ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) ans = Math . Max ( ans , Math . Abs ( arr [ i ] - arr [ j ] ) + Math . Abs ( i - j ) ) ; return ans ; }
int findValue ( int [ ] arr , int n ) { int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( arr [ i ] + i ) ; b [ i ] = ( arr [ i ] - i ) ; } int x = a [ 0 ] , y = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) x = a [ i ] ; if ( a [ i ] < y ) y = a [ i ] ; } int ans1 = ( x - y ) ; x = b [ 0 ] ; y = b [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] > x ) x = b [ i ] ; if ( b [ i ] < y ) y = b [ i ] ; } int ans2 = ( x - y ) ; return Math . Max ( ans1 , ans2 ) ; }
int countsubarray ( int [ ] array , int n , int k ) { int count = 0 ; int i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul < k ) count ++ ; else break ; } } return count ; }
long multiplyFactors ( int n ) { long prod = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
long power ( long x , long y ) { long res = 1 ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % M ; y = ( y >> 1 ) % M ; x = ( x * x ) % M ; } return res ; }
int countFactors ( int n ) { int count = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count ++ ; else count += 2 ; } } return count ; }
long multiplyFactors ( int n ) { int numFactor = countFactors ( n ) ; long product = power ( n , numFactor / 2 ) ; if ( numFactor % 2 == 1 ) product = ( product * ( int ) Math . Sqrt ( n ) ) % M ; return product ; }
void printTrib ( int n ) { int [ ] dp = new int [ n ] ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( dp [ i ] + " " ) ; }
void power ( int [ , ] T , int n ) { if ( n == 0 n == 1 ) return ; int [ , ] M = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; power ( T , n / 2 ) ; multiply ( T , T ) ; if ( n % 2 != 0 ) multiply ( T , M ) ; }
int tribonacci ( int n ) { int [ , ] T = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; if ( n == 0 n == 1 ) return 0 ; else power ( T , n - 2 ) ; return T [ 0 , 0 ] ; }
char getMaxOccuringChar ( String str ) { int [ ] count = new int [ ASCII_SIZE ] ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) count [ str [ i ] ] ++ ; int max = - 1 ; char result = ' ' ; for ( int i = 0 ; i < len ; i ++ ) { if ( max < count [ str [ i ] ] ) { max = count [ str [ i ] ] ; result = str [ i ] ; } } return result ; }
int counDivisors ( int X ) { int count = 0 ; for ( int i = 1 ; i <= X ; ++ i ) { if ( X % i == 0 ) { count ++ ; } } return count ; }
int countDivisorsMult ( int [ ] arr , int n ) { int mul = 1 ; for ( int i = 0 ; i < n ; ++ i ) mul *= arr [ i ] ; return counDivisors ( mul ) ; }
void SieveOfEratosthenes ( int largest , List < int > prime ) { bool [ ] isPrime = new bool [ largest + 1 ] ; Array . Fill ( isPrime , true ) ; for ( int p = 2 ; p * p <= largest ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= largest ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= largest ; p ++ ) if ( isPrime [ p ] ) prime . Add ( p ) ; }
long countDivisorsMult ( int [ ] arr , int n ) { int largest = 0 ; foreach ( int a in arr ) { largest = Math . Max ( largest , a ) ; } List < int > prime = new List < int > ( ) ; SieveOfEratosthenes ( largest , prime ) ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < prime . Count ; j ++ ) { while ( arr [ i ] > 1 && arr [ i ] % prime [ j ] == 0 ) { arr [ i ] /= prime [ j ] ; if ( mp . ContainsKey ( prime [ j ] ) ) { mp [ prime [ j ] ] ++ ; } else { mp . Add ( prime [ j ] , 1 ) ; } } } if ( arr [ i ] != 1 ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] ++ ; } else { mp . Add ( arr [ i ] , 1 ) ; } } } long res = 1 ; foreach ( KeyValuePair < int , int > it in mp ) res *= ( it . Value + 1L ) ; return res ; }
void generatePrimeFactors ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } }
int calculateNoOFactors ( int n ) { if ( n == 1 ) return 1 ; int ans = 1 ; int dup = factor [ n ] ; int c = 1 ; int j = n / factor [ n ] ; while ( j != 1 ) { if ( factor [ j ] == dup ) c += 1 ; else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; } j = j / factor [ j ] ; } ans = ans * ( c + 1 ) ; return ans ; }
void digit_product_Sum ( int N ) { int [ ] a = new int [ N + 1 ] ; int product = 1 ; a [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { product = a [ i - 1 ] / 10 ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; int val = a [ i - 1 ] / 10 ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + ( val * product ) ; } for ( int i = 0 ; i < N ; i ++ ) Console . Write ( a [ i ] + " " ) ; }
float geometricMean ( int [ ] arr , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; float gm = ( float ) Math . Pow ( product , ( float ) 1 / n ) ; return gm ; }
float geometricMean ( int [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) Math . Log ( arr [ i ] ) ; sum = sum / n ; return ( float ) Math . Exp ( sum ) ; }
long smallestNumber ( int n ) { if ( n >= 0 && n <= 9 ) { return n ; } Stack < int > digits = new Stack < int > ( ) ; for ( int i = 9 ; i >= 2 && n > 1 ; i -- ) { while ( n % i == 0 ) { digits . Push ( i ) ; n = n / i ; } } if ( n != 1 ) { return - 1 ; } long k = 0 ; while ( digits . Count != 0 ) { k = k * 10 + digits . Peek ( ) ; digits . Pop ( ) ; } return k ; }
bool isMagic ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum == 1 ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool checkCircular ( int N ) { int count = 0 , temp = N ; while ( temp > 0 ) { count ++ ; temp /= 10 ; } int num = N ; while ( isPrime ( num ) ) { int rem = num % 10 ; int div = num / 10 ; num = ( int ) ( ( Math . Pow ( 10 , count - 1 ) ) * rem ) + div ; if ( num == N ) return true ; } return false ; }
bool productOfSingelDgt ( int n ) { if ( n >= 0 && n <= 9 ) return true ; int [ ] prime = { 2 , 3 , 5 , 7 } ; for ( int i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; }
void printSequence ( int n ) { int a = 1 ; int ans = 2 ; int N = 1000000007 ; for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( ans + " " ) ; ans = ( ( a % N ) * ( ans % N ) ) % N ; a = ans ; ans = ( ans + 1 ) % N ; } }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
int findSum ( int n ) { return n * ( n + 1 ) / 2 ; }
int findSum ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) ; else return ( ( n + 1 ) / 2 ) * n ; }
int count ( int x , int y ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; while ( x % y != 0 ) { x = x % y ; ans ++ ; if ( m . ContainsKey ( x ) ) return - 1 ; m . Add ( x , 1 ) ; x = x * 10 ; } return ans ; }
void solve ( int n ) { double a = n / 2 ; if ( n % 2 != 0 ) { Console . WriteLine ( ( Math . Ceiling ( a ) - 1 ) + " " + ( Math . Floor ( a ) + 1 ) ) ; } else { if ( ( int ) ( a ) % 2 == 0 ) { Console . WriteLine ( ( Math . Ceiling ( a ) - 1 ) + " " + ( Math . Floor ( a ) + 1 ) ) ; } else { Console . WriteLine ( ( Math . Ceiling ( a ) - 2 ) + " " + ( Math . Floor ( a ) + 2 ) ) ; } } }
int divCount ( int n ) { bool [ ] hash = new bool [ n + 1 ] ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == false ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = true ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] == false ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
int maxPrimefactorNum ( int N ) { int [ ] arr = new int [ N + 1 ] ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) for ( int j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } return getMax ( arr ) ; }
int maxPrimefactorNum ( int N ) { if ( N < 2 ) return 0 ; bool [ ] arr = new bool [ N + 1 ] ; int prod = 1 , res = 0 ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }
int arraySum ( int [ ] arr , int n ) { int x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }
int countDigits ( int a , int b ) { int count = 0 ; int p = Math . Abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
int countDigits ( int a , int b ) { if ( a == 0 b == 0 ) return 1 ; return ( int ) Math . Floor ( Math . Log10 ( Math . Abs ( a ) ) + Math . Log10 ( Math . Abs ( b ) ) ) + 1 ; }
int area_fun ( int side ) { int area = side * side ; return area ; }
bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }
int maxSum ( int n ) { if ( n == 1 ) return 1 ; else return ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; }
bool check ( int n ) { if ( n <= 0 ) return false ; return 1162261467 % n == 0 ; }
void productPuzzle ( int [ ] a , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . Log10 ( a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( ( int ) ( EPS + Math . Pow ( 10.00 , sum - Math . Log10 ( a [ i ] ) ) ) + " " ) ; }
int changeEvenBits ( int n ) { int to_subtract = 0 ; int m = 0 ; for ( int x = n ; x > 0 ; x >>= 2 ) { if ( ( x & 1 ) > 0 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; }
int closestNumber ( int n , int m ) { int q = n / m ; int n1 = m * q ; int n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . Abs ( n - n1 ) < Math . Abs ( n - n2 ) ) return n1 ; return n2 ; }
bool checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( Math . Sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; }
int countConsecutive ( int N ) { int count = 0 ; for ( int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( double ) ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; }
int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
int compute_average ( int a , int b ) { return ( a + b ) / 2 ; }
int minNum ( int [ ] arr , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; }
int minNum ( int [ ] arr , int n ) { bool odd = false ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int findPrime ( int n ) { int num = n + 1 ; while ( num > 0 ) { if ( isPrime ( num ) ) return num ; num = num + 1 ; } return 0 ; }
void sieveOfEratostheneses ( ) { isPrime [ 1 ] = true ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( ! isPrime [ i ] ) { for ( int j = 2 * i ; j < MAX ; j += i ) isPrime [ j ] = true ; } } }
int findPrime ( int n ) { int num = n + 1 ; while ( num > 0 ) { if ( ! isPrime [ num ] ) return num ; num = num + 1 ; } return 0 ; }
int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }
int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c ; for ( int i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }
int nCr ( int n , int r ) { if ( r > n / 2 ) r = n - r ; int answer = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { answer *= ( n - r + i ) ; answer /= i ; } return answer ; }
int findMaxGCD ( int [ ] arr , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . Max ( high , arr [ i ] ) ; int [ ] divisors = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= Math . Sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] > 1 ) return i ; return 1 ; }
int findMaxGCD ( int [ ] arr , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . Max ( high , arr [ i ] ) ; int [ ] count = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; int counter = 0 ; for ( int i = high ; i >= 1 ; i -- ) { int j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } return 1 ; }
int count_one ( int n ) { int c_one = 0 ; while ( n != 0 ) { int rem = n % 10 ; if ( rem == 1 ) c_one = c_one + 1 ; n = n / 10 ; } return c_one ; }
int checkEvil ( int n ) { int i = 0 , bin = 0 , n_one = 0 ; while ( n != 0 ) { int r = n % 2 ; bin = bin + r * ( int ) ( Math . Pow ( 10 , i ) ) ; n = n / 2 ; } n_one = count_one ( bin ) ; if ( n_one % 2 == 0 ) return 1 ; else return 0 ; }
int calculateLeaps ( int n ) { if ( n == 0 n == 1 ) { return 1 ; } else { int leaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
int power ( long x , long y , long p ) { long res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return ( int ) res ; }
void printLastKDigits ( int a , int b , int k ) { Console . Write ( "Last " + k + " digits of " + a + "^" + b + " = " ) ; int temp = 1 ; for ( int i = 1 ; i <= k ; i ++ ) temp *= 10 ; temp = power ( a , b , temp ) ; for ( int i = 0 ; i < k - temp . ToString ( ) . Length ; i ++ ) Console . WriteLine ( 0 ) ; if ( temp != 0 ) Console . Write ( temp ) ; }
int msbPos ( int n ) { int pos = 0 ; while ( n != 0 ) { pos ++ ; n = n >> 1 ; } return pos ; }
int josephify ( int n ) { int position = msbPos ( n ) ; int j = 1 << ( position - 1 ) ; n = n ^ j ; n = n << 1 ; n = n | 1 ; return n ; }
int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }
int reverseDigits ( int num ) { int rev = 0 ; while ( num > 0 ) { rev = rev * 10 + num % 10 ; num /= 10 ; } return rev ; }
int square ( int num ) { return ( num * num ) ; }
bool checkAdamNumber ( int num ) { int a = square ( num ) ; int b = square ( reverseDigits ( num ) ) ; if ( a == reverseDigits ( b ) ) return true ; return false ; }
int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
int totalDigits ( int n ) { int number_of_digits = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; }
int findSum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int sum = arr [ 0 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { sum = sum + arr [ i + 1 ] ; } } return sum ; }
void decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) Console . Write ( binaryNum [ j ] ) ; }
int decimalToBinary ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; int c = ( int ) Math . Pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; }
int stirlingFactorial ( double n ) { if ( n == 1 ) return 1 ; double z ; z = System . Math . Sqrt ( 2 * 3.14 * n ) * System . Math . Pow ( ( n / e ) , n ) ; return ( int ) ( z ) ; }
int countXorPair ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; }
int countXorPair ( int [ ] arr , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }
long count_of_ways ( long n ) { long count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
bool isPalindrome ( long number ) { return number == reverse ( number ) ; }
long reverse ( long number ) { long reverse = 0 ; while ( number > 0 ) { long remainder = number % 10 ; reverse = ( reverse * 10 ) + remainder ; number = number / 10 ; } return reverse ; }
int sub ( int a , int b ) { return a + flipSign ( b ) ; }
int mul ( int a , int b ) { if ( a < b ) return mul ( b , a ) ; int sum = 0 ; for ( int i = Math . Abs ( b ) ; i > 0 ; i -- ) sum += a ; if ( b < 0 ) sum = flipSign ( sum ) ; return sum ; }
int division ( int a , int b ) { if ( b == 0 ) throw new ArithmeticException ( ) ; int quotient = 0 , dividend ; int divisor = flipSign ( Math . Abs ( b ) ) ; for ( dividend = Math . Abs ( a ) ; dividend >= Math . Abs ( divisor ) ; dividend += divisor ) quotient ++ ; if ( areDifferentSign ( a , b ) ) quotient = flipSign ( quotient ) ; return quotient ; }
int numOfCombinations ( int [ ] arr , int N ) { int [ ] C = { 0 , 0 , 0 } ; for ( int i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ; return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; }
int powmod ( int x , int y , int p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . Sqrt ( m ) + 1 ) ; int [ ] value = new int [ m ] ; for ( int i = n ; i >= 1 ; -- i ) value [ powmod ( a , i * n , m ) ] = i ; for ( int j = 0 ; j < n ; ++ j ) { int cur = ( powmod ( a , j , m ) * b ) % m ; if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - j ; if ( ans < m ) return ans ; } } return - 1 ; }
int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . Sqrt ( m ) + 1 ) ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; int [ ] value = new int [ m ] ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; }
int findRectNum ( int n ) { return n * ( n + 1 ) ; }
double f ( double x ) { return 1 * Math . Pow ( x , 3 ) + 2 * x * x + 10 * x - 20 ; }
void Muller ( double a , double b , double c ) { int i ; double res ; for ( i = 0 ; ; ++ i ) { double f1 = f ( a ) ; double f2 = f ( b ) ; double f3 = f ( c ) ; double d1 = f1 - f3 ; double d2 = f2 - f3 ; double h1 = a - c ; double h2 = b - c ; double a0 = f3 ; double a1 = ( ( ( d2 * Math . Pow ( h1 , 2 ) ) - ( d1 * Math . Pow ( h2 , 2 ) ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; double a2 = ( ( ( d1 * h2 ) - ( d2 * h1 ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; double x = ( ( - 2 * a0 ) / ( a1 + Math . Abs ( Math . Sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; double y = ( ( - 2 * a0 ) / ( a1 - Math . Abs ( Math . Sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; if ( x >= y ) res = x + c ; else res = y + c ; double m = res * 100 ; double n = c * 100 ; m = Math . Floor ( m ) ; n = Math . Floor ( n ) ; if ( m == n ) break ; a = b ; b = c ; c = res ; if ( i > MAX_ITERATIONS ) { Console . WriteLine ( "Root cannot be found using" + " Muller's method" ) ; break ; } } if ( i <= MAX_ITERATIONS ) Console . WriteLine ( "The value of the root is " + Math . Round ( res , 4 ) ) ; }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
int countPairs ( int N ) { int count = 0 ; for ( int i = 1 ; i <= Math . Pow ( N , ( 1.0 / 3.0 ) ) ; i ++ ) { int cb = i * i * i ; int diff = N - cb ; int cbrtDiff = ( int ) Math . Pow ( diff , ( 1.0 / 3.0 ) ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; }
long findMinValue ( long [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { val += ( double ) ( Math . Log ( ( double ) ( arr [ i ] ) ) ) ; } long left = arr [ 0 ] , right = arr [ n - 1 ] ; long ans = 0 ; while ( left <= right ) { long mid = ( left + right ) / 2 ; double temp = ( double ) n * ( double ) ( Math . Log ( ( double ) ( mid ) ) ) ; if ( val < temp ) { ans = mid ; right = mid - 1 ; } else { left = mid + 1 ; } } return ans ; }
bool isprime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; }
bool isSumOfKprimes ( int N , int K ) { if ( N < 2 * K ) return false ; if ( K == 1 ) return isprime ( N ) ; if ( K == 2 ) { if ( N % 2 == 0 ) return true ; return isprime ( N - 2 ) ; } return true ; }
int sumOfTermsInNthRow ( int n ) { int sum = ( int ) ( n * ( 2 * Math . Pow ( n , 2 ) + 1 ) ) ; return sum ; }
void printEqualModNumbers ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; if ( d == 0 ) { Console . write ( "Infinite solution" ) ; return ; } ArrayList v = new ArrayList ( ) ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . Add ( i ) ; if ( i != d / i ) v . Add ( d / i ) ; } } for ( int i = 0 ; i < v . Count ; i ++ ) { int temp = arr [ 0 ] % ( int ) v [ i ] ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % ( int ) v [ i ] != temp ) break ; if ( j == n ) Console . Write ( v [ i ] + " " ) ; } }
int firstDigit ( int x ) { while ( x >= 10 ) x = x / 10 ; return x ; }
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }
int FindLCM ( int a , int b ) { return ( a * b ) / GCD ( a , b ) ; }
int rangeDivisor ( int m , int n , int a , int b ) { int lcm = FindLCM ( a , b ) ; int a_divisor = n / a - ( m - 1 ) / a ; int b_divisor = n / b - ( m - 1 ) / b ; int common_divisor = n / lcm - ( m - 1 ) / lcm ; int ans = a_divisor + b_divisor - common_divisor ; return ans ; }
int getOccurence ( int n , int d ) { int result = 0 ; int itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && itr / 10 == d ) { result ++ ; itr ++ ; } else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }
void printUnique ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { int num = i ; bool [ ] visited = new bool [ 10 ] ; while ( num != 0 ) { if ( visited [ num % 10 ] ) break ; visited [ num % 10 ] = true ; num = num / 10 ; } if ( num == 0 ) Console . Write ( i + " " ) ; } }
int findSumOfDigits ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) multiply ( i ) ; int sum = 0 ; int size = v . Count ; for ( int i = 0 ; i < size ; i ++ ) sum += ( int ) v [ i ] ; return sum ; }
int findMinZero ( int p ) { int first = 1 , second = 1 ; int number = 2 , next = 1 ; while ( next > 0 ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int i ; for ( i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) break ; return i ; }
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int ans = 1 ; while ( n % 2 == 0 ) { n /= 2 ; ans *= 2 ; } return ans ; }
int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; }
int printKDistinct ( int [ ] arr , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }
int div ( int x ) { int ans = 0 ; for ( int i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; }
void sieve ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] == false ) allPrimes . Add ( p ) ; }
int factorialDivisors ( int n ) { int result = 1 ; for ( int i = 0 ; i < allPrimes . Count ; i ++ ) { int p = ( int ) allPrimes [ i ] ; int exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * ( int ) allPrimes [ i ] ; } result = result * ( ( int ) Math . Pow ( ( int ) allPrimes [ i ] , exp + 1 ) - 1 ) / ( ( int ) allPrimes [ i ] - 1 ) ; } return result ; }
int countIterations ( int [ ] arr , int n ) { bool oneFound = false ; int res = 0 ; for ( int i = 0 ; i < n ; ) { if ( arr [ i ] == 1 ) oneFound = true ; while ( i < n && arr [ i ] == 1 ) i ++ ; int count_zero = 0 ; while ( i < n && arr [ i ] == 0 ) { count_zero ++ ; i ++ ; } if ( oneFound == false && i == n ) return - 1 ; int curr_count ; if ( i < n && oneFound == true ) { if ( ( count_zero & 1 ) == 0 ) curr_count = count_zero / 2 ; else curr_count = ( count_zero + 1 ) / 2 ; count_zero = 0 ; } else { curr_count = count_zero ; count_zero = 0 ; } res = Math . Max ( res , curr_count ) ; } return res ; }
bool isAutomorphic ( int N ) { int sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return false ; N /= 10 ; sq /= 10 ; } return true ; }
void printConsecutive ( int last , int first ) { Console . Write ( first ++ ) ; for ( int x = first ; x <= last ; x ++ ) Console . Write ( " + " + x ) ; }
void findConsecutive ( int N ) { for ( int last = 1 ; last < N ; last ++ ) { for ( int first = 0 ; first < last ; first ++ ) { if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) { Console . Write ( N + " = " ) ; printConsecutive ( last , first + 1 ) ; return ; } } } Console . Write ( "-1" ) ; }
void printCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { for ( int j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { Console . Write ( j * j * j + " " ) ; break ; } } } }
void printCubes ( int a , int b ) { int acrt = ( int ) Math . Pow ( a , ( double ) 1 / 3 ) ; int bcrt = ( int ) Math . Pow ( b , ( double ) 1 / 3 ) ; for ( int i = acrt ; i <= bcrt ; i ++ ) if ( i * i * i >= a && i * i * i <= b ) Console . Write ( i * i * i + " " ) ; }
int findCount ( int m , int n ) { int num1 = 0 ; for ( int i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; int num2 = 0 ; for ( int i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; }
int findNthEvenDigitNumber ( int n ) { int count = 0 ; for ( int i = 0 ; ; i ++ ) { int curr = i ; bool isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = curr / 10 ; } if ( isCurrEvenDigit == true ) count ++ ; if ( count == n ) return i ; } }
int findNthEvenDigitNumber ( int n ) { if ( n == 1 ) { return 0 ; } ArrayList v = new ArrayList ( ) ; n = n - 1 ; while ( n > 0 ) { v . Add ( n % 5 ) ; n = n / 5 ; } int result = 0 ; for ( int i = v . Count - 1 ; i >= 0 ; i -- ) { result = result * 10 ; result = result + ( int ) v [ i ] ; } return 2 * result ; }
int fibonacci ( int n ) { int a = 0 ; int b = 1 ; int c = 0 ; if ( n <= 1 ) return n ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }
bool isMultipleOf10 ( int n ) { int f = fibonacci ( 30 ) ; return ( f % 10 == 0 ) ; }
bool isMultipleOf10 ( int n ) { if ( n % 15 == 0 ) return true ; return false ; }
bool isDivisibleBy25 ( String str ) { int n = str . Length ; if ( n == 1 ) return false ; return ( ( str [ n - 1 ] - '0' == 0 && str [ n - 2 ] - '0' == 0 ) || ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 25 == 0 ) ; }
int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
bool isLeap ( int y ) { if ( y % 100 != 0 && y % 4 == 0 y % 400 == 0 ) return true ; return false ; }
int offsetDays ( int d , int m , int y ) { int offset = d ; if ( m - 1 == 11 ) offset += 335 ; if ( m - 1 == 10 ) offset += 304 ; if ( m - 1 == 9 ) offset += 273 ; if ( m - 1 == 8 ) offset += 243 ; if ( m - 1 == 7 ) offset += 212 ; if ( m - 1 == 6 ) offset += 181 ; if ( m - 1 == 5 ) offset += 151 ; if ( m - 1 == 4 ) offset += 120 ; if ( m - 1 == 3 ) offset += 90 ; if ( m - 1 == 2 ) offset += 59 ; if ( m - 1 == 1 ) offset += 31 ; if ( isLeap ( y ) && m > 2 ) offset += 1 ; return offset ; }
void addDays ( int d1 , int m1 , int y1 , int x ) { int offset1 = offsetDays ( d1 , m1 , y1 ) ; int remDays = isLeap ( y1 ) ? ( 366 - offset1 ) : ( 365 - offset1 ) ; int y2 , offset2 = 0 ; if ( x <= remDays ) { y2 = y1 ; offset2 = offset1 + x ; } else { x -= remDays ; y2 = y1 + 1 ; int y2days = isLeap ( y2 ) ? 366 : 365 ; while ( x >= y2days ) { x -= y2days ; y2 ++ ; y2days = isLeap ( y2 ) ? 366 : 365 ; } offset2 = x ; } revoffsetDays ( offset2 , y2 ) ; Console . WriteLine ( "d2 = " + d2 + ", m2 = " + m2 + ", y2 = " + y2 ) ; }
int divisorSum ( int N , int K ) { int sum = 0 ; for ( int i = 2 ; i <= Math . Ceiling ( Math . Sqrt ( N ) ) ; i ++ ) if ( N % i == 0 ) sum += ( i + N / i ) ; return sum ; }
bool isPrime ( int n ) { if ( n == 1 n == 0 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool isHyperPerfect ( int N , int K ) { int sum = divisorSum ( N , K ) ; if ( ( 1 + K * ( sum ) ) == N ) return true ; else return false ; }
void printWellOrdered ( int number , int x , int k ) { if ( k == 0 ) { Console . Write ( number + " " ) ; return ; } for ( int i = ( x + 1 ) ; i < 10 ; i ++ ) printWellOrdered ( number * 10 + i , i , k - 1 ) ; }
void generateWellOrdered ( int k ) { printWellOrdered ( 0 , 0 , k ) ; }
long moduloMultiplication ( long a , long b , long mod ) { a %= mod ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; } return res ; }
int number0f2s ( int n ) { int count = 0 ; while ( n > 0 ) { if ( n % 10 == 2 ) count ++ ; n = n / 10 ; } return count ; }
int numberOf2sinRange ( int n ) { int count = 0 ; for ( int i = 2 ; i <= n ; i ++ ) count += number0f2s ( i ) ; return count ; }
int numberOf2sinRange ( int n ) { string s = "" ; for ( int i = 0 ; i < n + 1 ; i ++ ) s += i + "" ; int count = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '2' ) { count ++ ; } } return count ; }
int count2sinRangeAtDigit ( int number , int d ) { int powerOf10 = ( int ) Math . Pow ( 10 , d ) ; int nextPowerOf10 = powerOf10 * 10 ; int right = number % powerOf10 ; int roundDown = number - number % nextPowerOf10 ; int roundup = roundDown + nextPowerOf10 ; int digit = ( number / powerOf10 ) % 10 ; if ( digit < 2 ) { return roundDown / 10 ; } if ( digit == 2 ) { return roundDown / 10 + right + 1 ; } return roundup / 10 ; }
int numberOf2sinRange ( int number ) { string convert ; convert = number . ToString ( ) ; string s = convert ; int len = s . Length ; int count = 0 ; for ( int digit = 0 ; digit < len ; digit ++ ) { count += count2sinRangeAtDigit ( number , digit ) ; } return count ; }
bool isDivisibleBy5 ( String str ) { int n = str . Length ; return ( ( ( str [ n - 1 ] - '0' ) == 0 ) || ( ( str [ n - 1 ] - '0' ) == 5 ) ) ; }
bool isTidy ( int num ) { int prev = 10 ; while ( num != 0 ) { int rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
virtual bool areMirror ( Node a , Node b ) { if ( a == null && b == null ) { return true ; } if ( a == null b == null ) { return false ; } return a . data == b . data && areMirror ( a . left , b . right ) && areMirror ( a . right , b . left ) ; }
void printPairs ( int [ ] arr , int n ) { List < int > v = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . Abs ( arr [ i ] ) == Math . Abs ( arr [ j ] ) ) v . Add ( Math . Abs ( arr [ i ] ) ) ; if ( v . Count == 0 ) return ; v . Sort ( ) ; for ( int i = 0 ; i < v . Count ; i ++ ) Console . Write ( - v [ i ] + " " + v [ i ] ) ; }
int minToggle ( int [ ] arr , int n ) { int [ ] zero = new int [ n + 1 ] ; zero [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = Math . Min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }
long LCM ( int [ ] arr , int n ) { int max_num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_num < arr [ i ] ) { max_num = arr [ i ] ; } } long res = 1 ; while ( x <= max_num ) { ArrayList indexes = new ArrayList ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % x == 0 ) { indexes . Add ( j ) ; } } if ( indexes . Count >= 2 ) { for ( int j = 0 ; j < indexes . Count ; j ++ ) { arr [ ( int ) indexes [ j ] ] = arr [ ( int ) indexes [ j ] ] / x ; } res = res * x ; } else { x ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { res = res * arr [ i ] ; } return res ; }
void kFactors ( int n , int k ) { ArrayList P = new ArrayList ( ) ; while ( n % 2 == 0 ) { P . Add ( 2 ) ; n /= 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; P . Add ( i ) ; } } if ( n > 2 ) P . Add ( n ) ; if ( P . Count < k ) { Console . WriteLine ( "-1" ) ; return ; } for ( int i = 0 ; i < k - 1 ; i ++ ) Console . Write ( P [ i ] + ", " ) ; int product = 1 ; for ( int i = k - 1 ; i < P . Count ; i ++ ) product = product * ( int ) P [ i ] ; Console . WriteLine ( product ) ; }
int nondecdigits ( int n ) { int x = 0 ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ; bool flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; } if ( flag == true ) break ; } return x ; }
void nondecdigits ( string s ) { int m = s . Length ; int [ ] a = new int [ m + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) a [ i ] = ( int ) s [ i ] - ( int ) '0' ; int level = m - 1 ; for ( int i = m - 1 ; i > 0 ; i -- ) { if ( a [ i ] < a [ i - 1 ] ) { a [ i - 1 ] -- ; level = i - 1 ; } } if ( a [ 0 ] != 0 ) { for ( int i = 0 ; i <= level ; i ++ ) Console . Write ( a [ i ] ) ; for ( int i = level + 1 ; i < m ; i ++ ) Console . Write ( "9" ) ; } else { for ( int i = 1 ; i < level ; i ++ ) Console . Write ( a [ i ] ) ; for ( int i = level + 1 ; i < m ; i ++ ) Console . Write ( "9" ) ; } }
int countDivisors ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; else cnt = cnt + 2 ; } } return cnt ; }
bool hasEvenNumberOfFactors ( int n ) { double root_n = Math . Sqrt ( n ) ; if ( ( root_n * root_n ) == n ) return false ; return true ; }
void printStatusOfDoors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( hasEvenNumberOfFactors ( i ) ) Console . Write ( "closed" + " " ) ; else Console . Write ( "open" + " " ) ; } }
bool validate ( long n ) { for ( int i = 0 ; i < 10 ; i ++ ) { long temp = n ; int count = 0 ; while ( temp > 0 ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; }
bool check ( String str ) { int n = str . Length ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 9 == 0 ) ; }
int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i ; j < N ; j ++ ) for ( int k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; }
int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }
bool check ( String str ) { int n = str . Length ; if ( ( str [ n - 1 ] - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; }
int checkPrime ( int n ) { if ( n <= 1 ) return - 1 ; if ( n <= 3 ) return 0 ; if ( n % 2 == 0 n % 3 == 0 ) return - 1 ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return - 1 ; return 0 ; }
void printPrimePoints ( int n ) { int count = countDigits ( n ) ; if ( count == 1 count == 2 ) { Console . Write ( "-1" ) ; return ; } bool found = false ; for ( int i = 1 ; i < ( count - 1 ) ; i ++ ) { int left = n / ( ( int ) Math . Pow ( 10 , count - i ) ) ; int right = n % ( ( int ) Math . Pow ( 10 , count - i - 1 ) ) ; if ( checkPrime ( left ) == 0 && checkPrime ( right ) == 0 ) { Console . Write ( i + " " ) ; found = true ; } } if ( found == false ) Console . Write ( "-1" ) ; }
int countOddPrimeFactors ( int n ) { int result = 1 ; while ( n % 2 == 0 ) n /= 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { int divCount = 0 ; while ( n % i == 0 ) { n /= i ; ++ divCount ; } result *= divCount + 1 ; } if ( n > 2 ) result *= 2 ; return result ; }
int politness ( int n ) { return countOddPrimeFactors ( n ) - 1 ; }
int politness ( int n ) { int count = 0 ; for ( int i = 2 ; i <= Math . Sqrt ( 2 * n ) ; i ++ ) { int a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a /= i ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a /= 2 ; if ( a > 0 ) { count ++ ; } } return count ; }
int power ( int num , int n ) { if ( n == 0 ) return 1 ; else if ( n % 2 == 0 ) return power ( num , n / 2 ) * power ( num , n / 2 ) ; else return num * power ( num , n / 2 ) * power ( num , n / 2 ) ; }
int checkRecursive ( int num , int x , int k , int n ) { if ( x == 0 ) res ++ ; int r = ( int ) Math . Floor ( Math . Pow ( num , 1.0 / n ) ) ; for ( int i = k + 1 ; i <= r ; i ++ ) { int a = x - ( int ) Math . Pow ( i , n ) ; if ( a >= 0 ) checkRecursive ( num , x - ( int ) Math . Pow ( i , n ) , i , n ) ; } return res ; }
int check ( int x , int n ) { return checkRecursive ( x , x , 0 , n ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
bool check ( string str ) { int n = str . Length ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; }
int reverseNum ( int n ) { int rem , rev = 0 ; while ( n > 0 ) { rem = n % 10 ; rev = rev * 10 + rem ; n /= 10 ; } return rev ; }
bool isPalindrom ( int num ) { return num == reverseNum ( num ) ; }
int nthPalindrome ( int n , int k ) { int num = ( int ) Math . Pow ( 10 , k - 1 ) ; while ( true ) { if ( isPalindrom ( num ) ) -- n ; if ( n == 0 ) break ; ++ num ; } return num ; }
int findMax ( int n , int [ ] a , int [ ] b , int [ ] k , int m ) { int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { int lowerbound = a [ i ] ; int upperbound = b [ i ] ; for ( int j = lowerbound ; j <= upperbound ; j ++ ) arr [ j ] += k [ i ] ; } int res = Int32 . MinValue ; for ( int i = 0 ; i < n ; i ++ ) res = Math . Max ( res , arr [ i ] ) ; return res ; }
bool isPerfectSquare ( int n ) { int sq = ( int ) Math . Sqrt ( n ) ; return ( n == sq * sq ) ; }
int countPerfectDivisors ( int n ) { int count = 0 ; for ( int i = 1 ; i * i <= n ; ++ i ) { if ( n % i == 0 ) { if ( isPerfectSquare ( i ) ) ++ count ; if ( n / i != i && isPerfectSquare ( n / i ) ) ++ count ; } } return count ; }
void precomputeCounts ( ) { for ( int i = 1 ; i * i < MAX ; ++ i ) { for ( int j = i * i ; j < MAX ; j += i * i ) ++ perfectDiv [ j ] ; } }
int countPerfectDivisors ( int n ) { return perfectDiv [ n ] ; }
void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
int getDigitProduct ( int x ) { if ( x < 10 ) return x ; if ( prodDig [ x ] != 0 ) return prodDig [ x ] ; int prod = ( x % 10 ) * getDigitProduct ( x / 10 ) ; return ( prodDig [ x ] = prod ) ; }
void findSeed ( int n ) { ArrayList res = new ArrayList ( ) ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( i * getDigitProduct ( i ) == n ) res . Add ( i ) ; if ( res . Count == 0 ) { Console . WriteLine ( "NO seed exists" ) ; return ; } for ( int i = 0 ; i < res . Count ; i ++ ) Console . WriteLine ( res [ i ] + " " ) ; }
void sieveOfEratosthenes ( ) { for ( int i = 2 ; i * i < MAX ; ++ i ) { if ( primedivisor [ i ] == 0 ) { for ( int j = i * i ; j < MAX ; j += i ) { primedivisor [ j ] = i ; } } } for ( int i = 1 ; i < MAX ; ++ i ) { if ( primedivisor [ i ] == 0 ) { primedivisor [ i ] = i ; } } }
void findDivisors ( int [ ] arr , int n ) { for ( int i = 0 ; i < MAX ; ++ i ) { pos [ i ] = divInd [ i ] = - 1 ; dist [ i ] = INF ; } for ( int i = 0 ; i < n ; ++ i ) { int num = arr [ i ] ; while ( num > 1 ) { int div = primedivisor [ num ] ; divisors [ i ] . Add ( div ) ; while ( num % div == 0 ) { num /= div ; } } } }
void nearestGCD ( int [ ] arr , int n ) { findDivisors ( arr , n ) ; for ( int i = 0 ; i < n ; ++ i ) { foreach ( int div in divisors [ i ] ) { if ( divInd [ div ] == - 1 ) { divInd [ div ] = i ; } else { int ind = divInd [ div ] ; divInd [ div ] = i ; if ( dist [ i ] > Math . Abs ( ind - i ) ) { dist [ i ] = Math . Abs ( ind - i ) ; pos [ i ] = ind + 1 ; } if ( dist [ ind ] > Math . Abs ( ind - i ) ) { dist [ ind ] = Math . Abs ( ind - i ) ; pos [ ind ] = i + 1 ; } } } } }
int maxPrimefactorNum ( int N ) { int [ ] arr = new int [ N + 5 ] ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) { for ( int j = 2 * i ; j <= N ; j += i ) { arr [ j ] ++ ; } } arr [ i ] = 1 ; } int maxval = 0 , maxint = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > maxval ) { maxval = arr [ i ] ; maxint = i ; } } return maxint ; }
int maxPrimefactorNum ( int N ) { bool [ ] arr = new bool [ N + 5 ] ; int i ; for ( i = 3 ; i * i <= N ; i += 2 ) { if ( ! arr [ i ] ) { for ( int j = i * i ; j <= N ; j += i ) { arr [ j ] = true ; } } } ArrayList prime = new ArrayList ( ) ; prime . Add ( 2 ) ; for ( i = 3 ; i <= N ; i += 2 ) { if ( ! arr [ i ] ) { prime . Add ( i ) ; } } int ans = 1 ; i = 0 ; while ( ans * ( int ) prime [ i ] <= N && i < prime . Count ) { ans *= ( int ) prime [ i ] ; i ++ ; } return ans ; }
void sieveSundaram ( ) { Boolean [ ] marked = new Boolean [ MAX / 2 + 100 ] ; for ( int i = 1 ; i <= ( Math . Sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . Add ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . Add ( 2 * i + 1 ) ; }
int largestGCDSubsequence ( int [ ] arr , int n ) { int ans = 0 ; int maxele = arr . Max ( ) ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . Max ( ans , count ) ; } return ans ; }
void SieveOfEratosthenes ( ) { for ( int i = 2 ; i * i <= MAX ; ++ i ) { if ( prime [ i ] == 0 ) for ( int j = i * 2 ; j <= MAX ; j += i ) prime [ j ] = i ; } for ( int i = 1 ; i < MAX ; ++ i ) if ( prime [ i ] == 0 ) prime [ i ] = i ; }
int largestGCDSubsequence ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int element = arr [ i ] ; while ( element > 1 ) { int div = prime [ element ] ; ++ countdiv [ div ] ; ans = Math . Max ( ans , countdiv [ div ] ) ; while ( element % div == 0 ) element /= div ; } } return ans ; }
int countOfBinaryNumberLessThanN ( int N ) { Queue < int > q = new Queue < int > ( ) ; q . Enqueue ( 1 ) ; int cnt = 0 ; int t ; while ( q . Count > 0 ) { t = q . Peek ( ) ; q . Dequeue ( ) ; if ( t <= N ) { cnt ++ ; q . Enqueue ( t * 10 ) ; q . Enqueue ( t * 10 + 1 ) ; } } return cnt ; }
long SubArraySum ( int [ ] arr , int n ) { long result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; }
int nthElement ( int a , int b , int n ) { ArrayList seq = new ArrayList ( ) ; for ( int i = 1 ; i <= n ; i ++ ) seq . Add ( a * i ) ; seq . Sort ( ) ; for ( int i = 1 , k = n ; i <= n && k > 0 ; i ++ ) { if ( ! seq . Contains ( b * i ) ) { seq . Add ( b * i ) ; seq . Sort ( ) ; k -- ; } } return ( int ) seq [ n - 1 ] ; }
bool findTriplet ( int [ ] a1 , int [ ] a2 , int [ ] a3 , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
int multiplicativeOrder ( int A , int N ) { if ( GCD ( A , N ) != 1 ) return - 1 ; int result = 1 ; int K = 1 ; while ( K < N ) { result = ( result * A ) % N ; if ( result == 1 ) return K ; K ++ ; } return - 1 ; }
int sumOfRange ( int a , int b ) { int i = ( a * ( a + 1 ) ) >> 1 ; int j = ( b * ( b + 1 ) ) >> 1 ; return ( i - j ) ; }
int sumofproduct ( int n ) { int sum = 0 ; int root = ( int ) Math . Sqrt ( n ) ; for ( int i = 1 ; i <= root ; i ++ ) { int up = n / i ; int low = Math . Max ( n / ( i + 1 ) , root ) ; sum += ( i * sumOfRange ( up , low ) ) ; sum += ( i * ( n / i ) ) ; } return sum ; }
bool isPrime ( int n ) { if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return true ; } if ( n % 2 == 0 n % 3 == 0 ) { return false ; } for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
int power ( int x , int y , int p ) { while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
void findPrimefactors ( HashSet < int > s , int n ) { while ( n % 2 == 0 ) { s . Add ( 2 ) ; n = n / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { s . Add ( i ) ; n = n / i ; } } if ( n > 2 ) { s . Add ( n ) ; } }
int findPrimitive ( int n ) { HashSet < int > s = new HashSet < int > ( ) ; if ( isPrime ( n ) == false ) { return - 1 ; } int phi = n - 1 ; findPrimefactors ( s , phi ) ; for ( int r = 2 ; r <= phi ; r ++ ) { bool flag = false ; foreach ( int a in s ) { if ( power ( r , phi / ( a ) , n ) == 1 ) { flag = true ; break ; } } if ( flag == false ) { return r ; } } return - 1 ; }
int kPrimeFactor ( int n , int k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return - 1 ; }
void sieveOfEratosthenes ( int [ ] s ) { bool [ ] prime = new bool [ MAX + 1 ] ; for ( int i = 2 ; i <= MAX ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= MAX ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= MAX ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
int kPrimeFactor ( int n , int k , int [ ] s ) { while ( n > 1 ) { if ( k == 1 ) return s [ n ] ; k -- ; n /= s [ n ] ; } return - 1 ; }
int gcd ( int a , int b ) { return b > 0 ? gcd ( b , a % b ) : a ; }
int countGCD ( int L , int R , int g ) { L = ( L + g - 1 ) / g ; R = R / g ; int ans = 0 ; for ( int i = L ; i <= R ; i ++ ) for ( int j = L ; j <= R ; j ++ ) if ( gcd ( i , j ) == 1 ) ans ++ ; return ans ; }
int minPower ( int n , int x ) { if ( x == 1 ) return n ; int ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n /= x ; } return ans ; }
int calSum ( int n ) { int a = 3 , b = 0 , c = 2 ; return 3 ; return 3 ; return 5 ; int sum = 5 ; while ( n > 2 ) { int d = a + b ; sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; }
int sumDivisorsOfDivisors ( int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int j = 2 ; j <= Math . Sqrt ( n ) ; j ++ ) { int count = 0 ; while ( n % j == 0 ) { n /= j ; count ++ ; } if ( count != 0 ) mp . Add ( j , count ) ; } if ( n != 1 ) mp . Add ( n , 1 ) ; int ans = 1 ; foreach ( KeyValuePair < int , int > entry in mp ) { int pw = 1 ; int sum = 0 ; for ( int i = entry . Value + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw = entry . Key ; } ans *= sum ; } return ans ; }
int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 == 1 ) ans *= 2 ; for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 == 1 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void findgcd ( int n , int x , int y ) { int g = gcd ( x , y ) ; for ( int i = 0 ; i < g ; i ++ ) Console . Write ( n ) ; }
int gcd ( int a , int b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; }
int firstFactorialDivisibleNumber ( int x ) { int new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x /= gcd ( i , new_x ) ; if ( new_x == 1 ) break ; } return i ; }
int countFactorialXNotY ( int x , int y ) { return ( firstFactorialDivisibleNumber ( y ) - firstFactorialDivisibleNumber ( x ) ) ; }
int firstFactorialDivisibleNumber ( int x ) { int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
int gcd ( int a , int b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; }
int firstFactorialDivisibleNumber ( int x ) { int new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x /= gcd ( i , new_x ) ; if ( new_x == 1 ) break ; } return i ; }
int fact ( int n ) { int num = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { num = num * i ; } return num ; }
bool SieveOfEratosthenes ( int n , bool [ ] isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) isPrime [ i ] = false ; } } return false ; }
int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }
int highestPowerof2 ( int n ) { int p = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; return ( int ) Math . Pow ( 2 , p ) ; }
int getFirstDigit ( int x ) { while ( x >= 10 ) x /= 10 ; return x ; }
int getCountWithSameStartAndEndFrom1 ( int x ) { if ( x < 10 ) return x ; int tens = x / 10 ; int res = tens + 9 ; int firstDigit = getFirstDigit ( x ) ; int lastDigit = x % 10 ; if ( lastDigit < firstDigit ) res -- ; return res ; }
int getCountWithSameStartAndEnd ( int start , int end ) { return getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ; }
void sieveOfEratosthenes ( int n , bool [ ] isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
bool rightTruPrime ( int n ) { bool [ ] isPrime = new bool [ n + 1 ] ; sieveOfEratosthenes ( n , isPrime ) ; while ( n != 0 ) { if ( isPrime [ n ] ) n = n / 10 ; else return false ; } return true ; }
int countMaxChoco ( int money , int price , int wrap ) { if ( money < price ) return 0 ; int choc = money / price ; choc = choc + ( choc - 1 ) / ( wrap - 1 ) ; return choc ; }
void SieveOfEratosthenes ( int n , bool [ ] prime ) { for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } }
void mersennePrimes ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; SieveOfEratosthenes ( n , prime ) ; for ( int k = 2 ; ( ( 1 << k ) - 1 ) <= n ; k ++ ) { long num = ( 1 << k ) - 1 ; if ( prime [ ( int ) ( num ) ] ) Console . Write ( num + " " ) ; } }
int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
void sieve ( bool [ ] prime , int n ) { for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } }
int maxDigitInPrimes ( int L , int R ) { bool [ ] prime = new bool [ R + 1 ] ; for ( int i = 0 ; i < R + 1 ; i ++ ) prime [ i ] = false ; sieve ( prime , R ) ; int [ ] freq = new int [ 10 ] ; for ( int i = L ; i <= R ; i ++ ) { if ( ! prime [ i ] ) { while ( p > 0 ) { freq [ p % 10 ] ++ ; p /= 10 ; } } } int max = freq [ 0 ] , ans = 0 ; for ( int j = 1 ; j < 10 ; j ++ ) { if ( max <= freq [ j ] ) { max = freq [ j ] ; ans = j ; } } return ( max != 0 ) ? ans : - 1 ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void simpleSieve ( ) { for ( int i = 0 ; i < 1001 ; i ++ ) arr [ i ] = true ; for ( int p = 2 ; p * p < 1001 ; p ++ ) { if ( arr [ p ] ) { for ( int i = p * 2 ; i < 1001 ; i = i + p ) arr [ i ] = false ; } } }
int find_sphene ( int N ) { int [ ] arr1 = new int [ 8 ] ; int count = 0 ; int j = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( N % i == 0 && count < 8 ) { count ++ ; arr1 [ j ++ ] = i ; } } if ( count == 8 && ( arr [ arr1 [ 1 ] ] && arr [ arr1 [ 2 ] ] && arr [ arr1 [ 3 ] ] ) ) return 1 ; return 0 ; }
int maxHandshake ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
int gcd ( int i , int j ) { if ( i == j ) return i ; if ( i > j ) return gcd ( i - j , j ) ; return gcd ( i , j - i ) ; }
bool ispossible ( int x , int y , int a , int b ) { x = Math . Abs ( x ) ; y = Math . Abs ( y ) ; a = Math . Abs ( a ) ; b = Math . Abs ( b ) ; return ( gcd ( x , y ) == gcd ( a , b ) ) ; }
int ApowBmodM ( string a , int b , int m ) { int ans = aModM ( a , m ) ; int mul = ans ; for ( int i = 1 ; i < b ; i ++ ) ans = ( ans * mul ) % m ; return ans ; }
bool divisible ( string N , int digit ) { int ans = 0 ; for ( int i = 0 ; i < N . Length ; i ++ ) { ans = ( ans * 10 + ( N [ i ] - '0' ) ) ; ans %= digit ; } return ( ans == 0 ) ; }
int allDigits ( string N ) { bool [ ] divide = new bool [ 10 ] ; for ( int i = 0 ; i < divide . Length ; i ++ ) { divide [ i ] = false ; } divide [ 1 ] = true ; for ( int digit = 2 ; digit <= 9 ; digit ++ ) { if ( divisible ( N , digit ) ) divide [ digit ] = true ; } int result = 0 ; for ( int i = 0 ; i < N . Length ; i ++ ) { if ( divide [ N [ i ] - '0' ] == true ) result ++ ; } return result ; }
int countNums ( int n , int x , int y ) { bool [ ] arr = new bool [ n + 1 ] ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = Math . Min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
int reverse ( int x ) { int rev = 0 ; while ( x > 0 ) { rev = ( rev * 10 ) + x % 10 ; x = x / 10 ; } return rev ; }
void printEmirp ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { int rev = reverse ( p ) ; if ( p != rev && rev <= n && prime [ rev ] ) { Console . Write ( p + " " + rev + " " ) ; prime [ rev ] = false ; } } } }
int getSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= ( Math . Sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; { sum = sum + i ; sum = sum + ( n / i ) ; } } } sum = sum - n ; return sum ; }
bool checkAbundant ( int n ) { return ( getSum ( n ) > n ) ; }
int longLenSub ( int [ ] arr , int n ) { Dictionary < int , int > um = new Dictionary < int , int > ( ) ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . ContainsKey ( arr [ i ] - 1 ) && len < um [ arr [ i ] - 1 ] ) len = um [ arr [ i ] - 1 ] ; if ( um . ContainsKey ( arr [ i ] + 1 ) && len < um [ arr [ i ] + 1 ] ) len = um [ arr [ i ] + 1 ] ; um [ arr [ i ] ] = len + 1 ; if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i ] ] ; } return longLen ; }
bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= Math . Sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
int divisorsSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= ( Math . Sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { sum = sum + i ; } { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; }
bool isDeficient ( int n ) { return ( divisorsSum ( n ) < ( 2 * n ) ) ; }
bool isKeith ( int x ) { ArrayList terms = new ArrayList ( ) ; while ( temp > 0 ) { terms . Add ( temp % 10 ) ; temp = temp / 10 ; n ++ ; } terms . Reverse ( ) ; int next_term = 0 , i = n ; while ( next_term < x ) { next_term = 0 ; for ( int j = 1 ; j <= n ; j ++ ) next_term += ( int ) terms [ i - j ] ; terms . Add ( next_term ) ; i ++ ; } return ( next_term == x ) ; }
int hcf ( int a , int b ) { if ( b == 0 ) return a ; return hcf ( b , a % b ) ; }
int findlcm ( int a , int b ) { if ( b == 1 ) return a ; a = ( a * b ) / hcf ( a , b ) ; b -= 1 ; return findlcm ( a , b ) ; }
bool canBeSumofConsec ( int n ) { return ( ( ( n & ( n - 1 ) ) != 0 ) && n != 0 ) ; }
void Sieve ( ) { int n = MAX ; int nNew = ( int ) Math . Sqrt ( n ) ; int [ ] marked = new int [ n / 2 + 500 ] ; for ( int i = 1 ; i <= ( nNew - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= n / 2 ; j = j + 2 * i + 1 ) marked [ j ] = 1 ; primes . Add ( 2 ) ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( marked [ i ] == 0 ) primes . Add ( 2 * i + 1 ) ; }
int binarySearch ( int left , int right , int n ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( mid == 0 mid == primes . Count - 1 ) return ( int ) primes [ mid ] ; if ( ( int ) primes [ mid ] == n ) return ( int ) primes [ mid - 1 ] ; if ( ( int ) primes [ mid ] < n && ( int ) primes [ mid + 1 ] > n ) return ( int ) primes [ mid ] ; if ( n < ( int ) primes [ mid ] ) return binarySearch ( left , mid - 1 , n ) ; else return binarySearch ( mid + 1 , right , n ) ; } return 0 ; }
int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long ef1 = 0 , ef2 = 2 ; long sum = ef1 + ef2 ; while ( ef2 <= limit ) { long ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return ( int ) sum ; }
bool isPerfect ( int n ) { int s = ( int ) ( Math . Sqrt ( n ) ) ; return ( s * s == n ) ; }
int divisorsCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count += 1 ; else count += 2 ; } } return count ; }
long evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
void buildSegtmentTree ( int node , int a , int b ) { if ( a == b ) { segmentTree [ node ] = divisors [ a ] ; return ; } buildSegtmentTree ( 2 * node , a , ( a + b ) / 2 ) ; buildSegtmentTree ( 2 * node + 1 , ( ( a + b ) / 2 ) + 1 , b ) ; segmentTree [ node ] = Math . Max ( segmentTree [ 2 * node ] , segmentTree [ 2 * node + 1 ] ) ; }
int query ( int node , int a , int b , int l , int r ) { if ( l > b a > r ) return - 1 ; if ( a >= l && b <= r ) return segmentTree [ node ] ; return Math . Max ( query ( 2 * node , a , ( a + b ) / 2 , l , r ) , query ( 2 * node + 1 , ( ( a + b ) / 2 ) + 1 , b , l , r ) ) ; }
int countSteps ( int x , int y ) { if ( x % y == 0 ) return x / y ; return x / y + countSteps ( y , x % y ) ; }
void primeFactorize ( int a ) { for ( int i = 2 ; i * i <= a ; i += 2 ) { int cnt = 0 ; while ( a % i == 0 ) { cnt ++ ; a /= i ; } ma . Add ( i , cnt ) ; } if ( a > 1 ) ma . Add ( a , 1 ) ; }
int commDiv ( int a , int b ) { primeFactorize ( a ) ; int res = 1 ; foreach ( KeyValuePair < int , int > m in ma ) { int cnt = 0 ; int key = m . Key ; int value = m . Value ; while ( b % key == 0 ) { b /= key ; cnt ++ ; } res *= ( Math . Min ( cnt , value ) + 1 ) ; } return res ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
float y ( float x ) { return 1 / ( 1 + x * x ) ; }
float trapezoidal ( float a , float b , float n ) { float h = ( b - a ) / n ; float s = y ( a ) + y ( b ) ; for ( int i = 1 ; i < n ; i ++ ) s += 2 * y ( a + i * h ) ; return ( h / 2 ) * s ; }
long spellsCount ( String num ) { int n = num . Length ; long result = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * ( long ) Math . Pow ( 2 , count - 1 ) ; } return result ; }
int numSquareSum ( int n ) { int squareSum = 0 ; while ( n != 0 ) { squareSum += ( n % 10 ) * ( n % 10 ) ; n /= 10 ; } return squareSum ; }
bool isHappynumber ( int n ) { int slow , fast ; slow = fast = n ; do { slow = numSquareSum ( slow ) ; fast = numSquareSum ( numSquareSum ( fast ) ) ; } while ( slow != fast ) ; return ( slow == 1 ) ; }
int kaprekar ( int n ) { int prev = 0 ; return kaprekarRec ( n , prev ) ; }
float sqroot ( float s ) { int pSq = 0 ; int N = 0 ; for ( int i = ( int ) ( s ) ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } float d = s - pSq ; float P = d / ( 2.0f * N ) ; float A = N + P ; float sqrt_of_s = A - ( ( P * P ) / ( 2.0f * A ) ) ; return sqrt_of_s ; }
int power ( int x , int a ) { int res = 1 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) res = res * x ; x = x * x ; a >>= 1 ; } return res ; }
int breakInteger ( int N ) { if ( N == 2 ) return 1 ; if ( N == 3 ) return 2 ; int maxProduct = - 1 ; switch ( N % 3 ) { case 0 : maxProduct = power ( 3 , N / 3 ) ; break ; case 1 : maxProduct = 2 * 2 * power ( 3 , ( N / 3 ) - 1 ) ; break ; case 2 : maxProduct = 2 * power ( 3 , N / 3 ) ; break ; } return maxProduct ; }
int maxProd ( int n ) { if ( n == 2 n == 3 ) return ( n - 1 ) ; int res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; }
void sieve ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . Add ( p ) ; }
int factorialDivisors ( int n ) { int result = 1 ; for ( int i = 0 ; i < allPrimes . Count ; i ++ ) { int p = ( int ) allPrimes [ i ] ; int exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * ( int ) allPrimes [ i ] ; } result = result * ( exp + 1 ) ; } return result ; }
int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }
long reversDigits ( long num ) { long rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
bool isPalindrome ( long num ) { return ( reversDigits ( num ) == num ) ; }
int countOddSquares ( int n , int m ) { return ( int ) Math . Pow ( ( double ) m , 0.5 ) - ( int ) Math . Pow ( ( double ) n - 1 , 0.5 ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k ; for ( k = 0 ; ( ( a b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a & 1 ) == 0 ) a >>= 1 ; do { while ( ( b & 1 ) == 0 ) b >>= 1 ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; }
int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( ( ~ a & 1 ) == 1 ) { if ( ( b & 1 ) == 1 ) return gcd ( a >> 1 , b ) ; else return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
int countWindowDistinct ( int [ ] win , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int j ; for ( j = 0 ; j < i ; j ++ ) if ( win [ i ] == win [ j ] ) break ; if ( j == i ) dist_count ++ ; } return dist_count ; }
int toInt ( char x ) { return x - '0' ; }
void findNDigitNums ( int n ) { char [ ] ou = new char [ n + 1 ] ; int index = 0 ; int evenSum = 0 , oddSum = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { ou [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , ou , index + 1 , evenSum + i , oddSum ) ; } }
void findNDigitNumsUtil ( int n , int sum , char [ ] ou , int index ) { if ( index > n sum < 0 ) return ; if ( index == n ) { if ( sum == 0 ) { ou [ index ] = '\0' ; Console . Write ( ou ) ; Console . Write ( " " ) ; } return ; } for ( int i = 0 ; i <= 9 ; i ++ ) { ou [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , sum - i , ou , index + 1 ) ; } }
void findNDigitNums ( int n , int sum ) { char [ ] ou = new char [ n + 1 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) { ou [ 0 ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , sum - i , ou , 1 ) ; } }
void operation ( int n , int k ) { bool answered = false ; if ( n < k ) { answered = true ; Console . WriteLine ( "No" ) ; } bool ok = factors ( n , k ) ; if ( ! ok && ! answered ) { answered = true ; Console . WriteLine ( "No" ) ; } if ( ok && ! answered ) Console . WriteLine ( "Yes" ) ; }
bool isPalUtil ( int num , int dupNum ) { if ( oneDigit ( num ) ) return ( num == ( dupNum ) % 10 ) ; if ( ! isPalUtil ( num / 10 , dupNum ) ) return false ; dupNum /= 10 ; return ( num % 10 == ( dupNum ) % 10 ) ; }
bool isPal ( int num ) { if ( num < 0 ) num = - num ; return isPalUtil ( num , dupNum ) ; }
void printPalPrimesLessThanN ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) { prime [ i ] = false ; } } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] && isPal ( p ) ) { Console . Write ( p + " " ) ; } } }
int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; }
void printKAlmostPrimes ( int k , int n ) { for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == k ) { Console . Write ( num + " " ) ; i ++ ; } } return ; }
int findPieces ( int n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; }
string numToWords ( int n , string s ) { string str = "" ; if ( n > 19 ) { str += ten [ n / 10 ] + one [ n % 10 ] ; } else { str += one [ n ] ; } if ( n != 0 ) { str += s ; } return str ; }
string convertToWords ( long n ) { string out1 = "" ; out1 += numToWords ( ( int ) ( n / 10000000 ) , "crore " ) ; out1 += numToWords ( ( int ) ( ( n / 100000 ) % 100 ) , "lakh " ) ; out1 += numToWords ( ( int ) ( ( n / 1000 ) % 100 ) , "thousand " ) ; out1 += numToWords ( ( int ) ( ( n / 100 ) % 10 ) , "hundred " ) ; if ( n > 100 && n % 100 > 0 ) { out1 += "and " ; } out1 += numToWords ( ( int ) ( n % 100 ) , "" ) ; return out1 ; }
long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( n * Math . Log10 ( n / M_E ) + Math . Log10 ( 2 * M_PI * n ) / 2.0 ) ; return ( long ) Math . Floor ( x ) + 1 ; }
int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += Math . Log10 ( i ) ; return ( int ) Math . Floor ( digits ) + 1 ; }
void findPairs ( int n ) { int cubeRoot = ( int ) Math . Pow ( n , 1.0 / 3.0 ) ; int [ ] cube = new int [ cubeRoot + 1 ] ; for ( int i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; int l = 1 ; int r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { Console . WriteLine ( "(" + l + ", " + r + ")" ) ; l ++ ; r -- ; } } }
int countEvenSum ( int [ ] arr , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int sum = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; }
int countEvenSum ( int [ ] arr , int n ) { int [ ] temp = { 1 , 0 } ; int result = 0 , sum = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { sum = ( ( sum + arr [ i ] ) % 2 + 2 ) % 2 ; temp [ sum ] ++ ; } result = result + ( temp [ 0 ] * ( temp [ 0 ] - 1 ) / 2 ) ; result = result + ( temp [ 1 ] * ( temp [ 1 ] - 1 ) / 2 ) ; return ( result ) ; }
long countEvenSum ( int [ ] a , int n ) { long res = 0 ; int s = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] % 2 == 1 ) { s = n - i - 1 - s ; } else { s = s + 1 ; } res = res + s ; } return res ; }
bool isPossible ( int a , int b , int c ) { return ( c % gcd ( a , b ) == 0 ) ; }
int gcd ( int a , int b ) { while ( b != 0 ) { int t = b ; b = a % b ; a = t ; } return a ; }
int findMinDiff ( int a , int b , int x , int y ) { int g = gcd ( a , b ) ; int diff = Math . Abs ( x - y ) % g ; return Math . Min ( diff , g - diff ) ; }
int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int [ ] fibo = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; }
void findCombinations ( int n ) { int [ ] arr = new int [ n ] ; findCombinationsUtil ( arr , 0 , n , n ) ; }
bool isPower ( int x , int y ) { int res1 = ( int ) Math . Log ( y ) / ( int ) Math . Log ( x ) ; double res2 = Math . Log ( y ) / Math . Log ( x ) ; return ( res1 == res2 ) ; }
bool isPerfectSquare ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
int findCount ( int d ) { return 9 * ( ( int ) ( Math . Pow ( 10 , d - 1 ) ) - ( int ) ( Math . Pow ( 9 , d - 1 ) ) ) ; }
int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
void printDivisors ( int n ) { int [ ] v = new int [ n ] ; int t = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) Console . Write ( i + " " ) ; else { Console . Write ( i + " " ) ; v [ t ++ ] = n / i ; } } } for ( int i = t - 1 ; i >= 0 ; i -- ) Console . Write ( v [ i ] + " " ) ; }
void printDivisors ( int n ) { for ( int i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) Console . Write ( i + " " ) ; } for ( int i = ( int ) Math . Sqrt ( n ) ; i >= 1 ; i -- ) { if ( n % i == 0 ) Console . Write ( n / i + " " ) ; } }
void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) Console . Write ( i + " " ) ; }
bool isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }
int has0 ( int x ) { while ( x != 0 ) { if ( x % 10 == 0 ) return 1 ; x /= 10 ; } return 0 ; }
int getCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) count += has0 ( i ) ; return count ; }
char xor_c ( char a , char b ) { return ( a == b ) ? '0' : '1' ; }
int greyConverter ( int n ) { return n ^ ( n >> 1 ) ; }
int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return ( gcd ( b , a % b ) ) ; }
void findSmallest ( int a , int b ) { int lcm = ( a * b ) / gcd ( a , b ) ; Console . Write ( "x = " + lcm / a + "y=" }
int power ( int x , int y , int p ) { while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
void squareRoot ( int n , int p ) { if ( p % 4 != 3 ) { Console . Write ( "Invalid Input" ) ; return ; } n = n % p ; int x = power ( n , ( p + 1 ) / 4 , p ) ; if ( ( x * x ) % p == n ) { Console . Write ( "Square root is " + x ) ; return ; } x = p - x ; if ( ( x * x ) % p == n ) { Console . Write ( "Square root is " + x ) ; return ; } Console . Write ( "Square root doesn't exist " ) ; }
int getSum ( int [ ] BITree , int index ) { int sum = 0 ; while ( index > 0 ) { sum += BITree [ index ] ; index -= index & ( - index ) ; } return sum ; }
void convert ( int [ ] arr , int n ) { int [ ] temp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = arr [ i ] ; Array . Sort ( temp ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = lower_bound ( temp , 0 , n , arr [ i ] ) + 1 ; } }
int getInvCount ( int [ ] arr , int n ) { int invcount = 0 ; convert ( arr , n ) ; int [ ] BIT = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) BIT [ i ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { invcount += getSum ( BIT , arr [ i ] - 1 ) ; updateBIT ( BIT , n , arr [ i ] , 1 ) ; } return invcount ; }
int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; }
int largestPower ( int n , int p ) { int x = 0 ; while ( n > 0 ) { n /= p ; x += n ; } return x ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
int modFact ( int n , int p ) { if ( n >= p ) { return 0 ; } int res = 1 ; bool [ ] isPrime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) isPrime [ i ] = true ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = 2 * i ; j <= n ; j += i ) { isPrime [ j ] = false ; } } } for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime [ i ] ) { int k = largestPower ( n , i ) ; res = ( res * power ( i , k , p ) ) % p ; } } return res ; }
int modInverse ( int a , int p ) { return power ( a , p - 2 , p ) ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
bool miillerTest ( int d , int n ) { Random r = new Random ( ) ; int a = 2 + ( int ) ( r . Next ( ) % ( n - 4 ) ) ; int x = power ( a , d , n ) ; if ( x == 1 x == n - 1 ) return true ; while ( d != n - 1 ) { x = ( x * x ) % n ; d *= 2 ; if ( x == 1 ) return false ; if ( x == n - 1 ) return true ; } return false ; }
bool isPrime ( int n , int k ) { if ( n <= 1 n == 4 ) return false ; if ( n <= 3 ) return true ; int d = n - 1 ; while ( d % 2 == 0 ) d /= 2 ; for ( int i = 0 ; i < k ; i ++ ) if ( miillerTest ( d , n ) == false ) return false ; return true ; }
int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
int findMinX ( int [ ] num , int [ ] rem , int k ) { int prod = 1 ; for ( int i = 0 ; i < k ; i ++ ) prod *= num [ i ] ; int result = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int pp = prod / num [ i ] ; result += rem [ i ] * inv ( pp , num [ i ] ) * pp ; } return result % prod ; }
int findMinX ( int [ ] num , int [ ] rem , int k ) { int x = 1 ; while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }
int largestFiboLessOrEqual ( int n ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; int i ; for ( i = 2 ; fib [ i - 1 ] <= n ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } return ( i - 2 ) ; }
bool isValid ( int n , int d ) { int digit = n % 10 ; int sum = digit ; if ( digit == d ) return false ; n /= 10 ; while ( n > 0 ) { digit = n % 10 ; if ( digit == d digit <= sum ) return false ; else { sum += digit ; n /= 10 ; } } return true ; }
int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }
int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }
void printFibRepresntation ( int n ) { while ( n > 0 ) { int f = nearestSmallerEqFib ( n ) ; Console . Write ( f + " " ) ; n = n - f ; } }
int countWaysUtil ( int n , int parts , int nextPart ) { if ( parts == 0 && n == 0 ) return 1 ; if ( n <= 0 parts <= 0 ) return 0 ; if ( dp [ n , nextPart , parts ] != - 1 ) return dp [ n , nextPart , parts ] ; for ( int i = nextPart ; i <= n ; i ++ ) ans += countWaysUtil ( n - i , parts - 1 , i ) ; return ( dp [ n , nextPart , parts ] = ans ) ; }
int countWays ( int n ) { for ( int i = 0 ; i < 5001 ; i ++ ) { for ( int j = 0 ; j < 5001 ; j ++ ) { for ( int l = 0 ; l < 5 ; l ++ ) dp [ i , j , l ] = - 1 ; } } return countWaysUtil ( n , 4 , 1 ) ; }
int pairAndSum ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }
long Euler_totient_function ( long n ) { long result = 1 ; for ( long i = 2 ; i * i <= n ; i ++ ) { long c = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { c ++ ; n /= i ; } } if ( c > 0 ) { long sm = ( long ) Math . Pow ( i , c - 1 ) * ( i - 1 ) ; result *= sm ; } } if ( n > 1 ) { result *= ( n - 1 ) ; } return result ; }
int nextSparse ( int x ) { ArrayList bin = new ArrayList ( ) ; while ( x != 0 ) { bin . Add ( x & 1 ) ; x >>= 1 ; } bin . Add ( 0 ) ; int last_final = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( int ) bin [ i ] == 1 && ( int ) bin [ i - 1 ] == 1 && ( int ) bin [ i + 1 ] != 1 ) { bin [ i + 1 ] = 1 ; for ( int j = i ; j >= last_final ; j -- ) bin [ j ] = 0 ; last_final = i + 1 ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += ( int ) bin [ i ] * ( 1 << i ) ; return ans ; }
bool isPower ( int n ) { double p ; if ( n <= 1 ) { return true ; } for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { p = Math . Log ( n ) / Math . Log ( i ) ; if ( ( Math . Ceiling ( p ) == Math . Floor ( p ) ) && p > 1 ) { return true ; } } return false ; }
int sumBitDifferences ( int [ ] arr , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) == 0 ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; }
void generateUtil ( int x , int [ ] arr , int curr_sum , int curr_idx ) { if ( curr_sum == x ) { printArr ( arr , curr_idx ) ; return ; } int num = 1 ; while ( num <= x - curr_sum && ( curr_idx == 0 num <= arr [ curr_idx - 1 ] ) ) { arr [ curr_idx ] = num ; generateUtil ( x , arr , curr_sum + num , curr_idx + 1 ) ; num ++ ; } }
void generate ( int x ) { int [ ] arr = new int [ x ] ; generateUtil ( x , arr , 0 , 0 ) ; }
bool isPerfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
bool check ( int num , int dig ) { for ( int i = 2 ; i <= 32 ; i ++ ) if ( checkUtil ( num , dig , i ) ) return true ; return false ; }
bool isLucky ( int n ) { bool [ ] arr = new bool [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }
int countFact ( int low , int high ) { int fact = 1 , x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; } int res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; } return res ; }
int nthMagicNo ( int n ) { int pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( int ) ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; }
int modInverse ( int a , int m ) { for ( int x = 1 ; x < m ; x ++ ) if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) return x ; return 1 ; }
int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int phi ( int n ) { int result = 1 ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; }
int phi ( int n ) { float result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( float ) ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( float ) ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; }
int getDifference ( Date dt1 , Date dt2 ) { int n1 = dt1 . y * 365 + dt1 . d ; for ( int i = 0 ; i < dt1 . m - 1 ; i ++ ) { n1 += monthDays [ i ] ; } n1 += countLeapYears ( dt1 ) ; int n2 = dt2 . y * 365 + dt2 . d ; for ( int i = 0 ; i < dt2 . m - 1 ; i ++ ) { n2 += monthDays [ i ] ; } n2 += countLeapYears ( dt2 ) ; return ( n2 - n1 ) ; }
uint countOfMultiples ( uint n ) { return ( n / 3 + n / 5 - n / 15 ) ; }
int getPeriod ( int n ) { int rem = 1 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; int d = rem ; int count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
int calculateAddedValue ( int number ) { int result = 0 ; int decimalPlace = 1 ; if ( number == 0 ) { result += ( 5 * decimalPlace ) ; } while ( number > 0 ) { if ( number % 10 == 0 ) result += ( 5 * decimalPlace ) ; number /= 10 ; decimalPlace *= 10 ; } return result ; }
int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
int getRemainder ( int num , int divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }
int minInsertion ( String str ) { int n = str . Length ; int res = 0 ; int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; }
int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
double sum ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / factorial ( i ) ; return sum ; }
double sum ( int n ) { double sum = 0 ; int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum ; }
long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { Console . Write ( square + " " ) ; square = square + odd ; odd = odd + 2 ; } }
bool isOperand ( char c ) { return ( c >= '0' && c <= '9' ) ; }
int value ( char c ) { return ( int ) ( c - '0' ) ; }
int evaluate ( string exp ) { if ( exp . Length == 0 ) return - 1 ; int res = value ( exp [ 0 ] ) ; for ( int i = 1 ; i < exp . Length ; i += 2 ) { char opr = exp [ i ] , opd = exp [ i + 1 ] ; if ( isOperand ( opd ) == false ) return - 1 ; if ( opr == '+' ) res += value ( opd ) ; else if ( opr == '-' ) res -= value ( opd ) ; else if ( opr == '*' ) res *= value ( opd ) ; else if ( opr == '/' ) res /= value ( opd ) ; else return - 1 ; } return res ; }
float sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return ( float ) s ; }
void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; Console . Write ( f1 + " " ) ; for ( i = 1 ; i < n ; i ++ ) { Console . Write ( f2 + " " ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void rearrange ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] += ( arr [ arr [ i ] ] % n ) * n ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] /= n ; }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; Console . WriteLine ( "" ) ; }
int maxdiff ( int [ ] arr , int n ) { Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . ContainsKey ( arr [ i ] ) ) freq [ arr [ i ] ] ++ ; else freq . Add ( arr [ i ] , 1 ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i ] > arr [ j ] ) ans = Math . Max ( ans , freq [ arr [ i ] ] - freq [ arr [ i ] ] ) ; else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && arr [ i ] < arr [ j ] ) ans = Math . Max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) ; } } return ans ; }
void printSequencesRecur ( int [ ] arr , int n , int k , int index ) { int i ; if ( k == 0 ) { printArray ( arr , index ) ; } if ( k > 0 ) { for ( i = 1 ; i <= n ; ++ i ) { arr [ index ] = i ; printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; } } }
void printSequences ( int n , int k ) { int [ ] arr = new int [ k ] ; printSequencesRecur ( arr , n , k , 0 ) ; return ; }
bool isMultipleof5 ( int n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }
bool isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
bool isPowerofTwo ( int n ) { if ( n == 0 ) return false ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return true ; return false ; }
int reversDigits ( int num ) { if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }
int countSubsequences ( int [ ] arr ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; else even ++ ; } return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; }
int findDiff ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . Max ( max_count , count ) ; min_count = Math . Min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
int XorSum ( int [ ] A , int [ ] B , int N , int M ) { int ans = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( ans == - 1 ) ans = ( A [ i ] & B [ j ] ) ; else ans ^= ( A [ i ] & B [ j ] ) ; } } return ans ; }
int countbitdiff ( int xo ) { int count = 0 ; while ( xo != 0 ) { if ( xo % 2 == 1 ) { count ++ ; } xo = xo / 2 ; } return count ; }
void convertXOR ( int [ , ] arr ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int X = arr [ i , j ] ; int temp = findXOR ( X ) ; arr [ i , j ] = temp ; } } printXORmatrix ( arr ) ; }
int countSet ( int N ) { int ans = 0 ; while ( N > 0 ) { ans += N & 1 ; N >>= 1 ; } return ans ; }
int countSub ( int [ ] arr , int k ) { int ans = 0 ; int setK = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { if ( countSet ( arr [ i ] ) == k ) setK += 1 ; else setK = 0 ; ans += setK ; } return ans ; }
void oddXorSubarray ( int [ ] a , int n ) { int odd = 0 ; int c_odd = 0 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 ) { odd = ( odd == 0 ) ? 1 : 0 ; } if ( odd != 0 ) { c_odd ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { result += c_odd ; if ( a [ i ] % 2 != 0 ) { c_odd = ( n - i - c_odd ) ; } } Console . WriteLine ( result ) ; }
void countPairs ( int [ ] arr , int N , int K ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( K - arr [ i ] ) ) cnt += mp [ K - arr [ i ] ] ; if ( mp . ContainsKey ( arr [ i ] ) ) { var val = mp [ arr [ i ] ] ; mp . Remove ( arr [ i ] ) ; mp . Add ( arr [ i ] , val + 1 ) ; } else { mp . Add ( arr [ i ] , 1 ) ; } } Console . WriteLine ( cnt ) ; }
void uniqueLevels ( TreeNode root ) { int uniqueLevels = 0 ; Queue < TreeNode > que = new Queue < TreeNode > ( ) ; que . Enqueue ( root ) ; while ( que . Count > 0 ) { int length = que . Count ; int prefix_XOR = 0 ; int prefix_OR = 0 ; bool flag = true ; for ( int i = 0 ; i < length ; i ++ ) { TreeNode temp = que . Peek ( ) ; que . Dequeue ( ) ; prefix_OR |= temp . val ; prefix_XOR ^= temp . val ; if ( prefix_XOR != prefix_OR ) flag = false ; if ( temp . left != null ) que . Enqueue ( temp . left ) ; if ( temp . right != null ) que . Enqueue ( temp . right ) ; } if ( flag ) uniqueLevels += 1 ; } Console . Write ( uniqueLevels ) ; }
int query ( int l , int r , int [ ] pre ) { if ( l == 0 ) return pre [ r ] ; else return pre [ r ] - pre [ l - 1 ] ; }
void countInRange ( int [ ] arr , int N , List < Tuple < int , int > > queries , int Q ) { int [ ] pre = new int [ N ] ; pre [ 0 ] = check ( arr [ 0 ] ) ; for ( int i = 1 ; i < N ; i ++ ) { pre [ i ] = pre [ i - 1 ] + check ( arr [ i ] ) ; } int c = 0 ; int q = 0 ; while ( q < Q ) { int l = queries [ q ] . Item1 ; int r = queries [ q ] . Item2 ; c ++ ; q ++ ; Console . Write ( query ( l , r , pre ) + " " ) ; } }
void Bitwise_AND_sum_i ( int [ ] arr1 , int [ ] arr2 , int M , int N ) { int [ ] frequency = new int [ 32 ] ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int num = arr1 [ i ] ; while ( num != 0 ) { if ( ( num & 1 ) != 0 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( int i = 0 ; i < M ; i ++ ) { int num = arr2 [ i ] ; int value_at_that_bit = 1 ; int bitwise_AND_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( ( num & 1 ) != 0 ) { bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } Console . Write ( bitwise_AND_sum + " " ) ; } }
void Bitwise_OR_sum_i ( int [ ] arr1 , int [ ] arr2 , int M , int N ) { int [ ] frequency = new int [ 32 ] ; for ( int i = 0 ; i < 32 ; i ++ ) { frequency [ i ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int num = arr1 [ i ] ; while ( num != 0 ) { if ( ( num & 1 ) != 0 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( int i = 0 ; i < M ; i ++ ) { int num = arr2 [ i ] ; int value_at_that_bit = 1 ; int bitwise_OR_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( ( num & 1 ) != 0 ) { bitwise_OR_sum += N * value_at_that_bit ; } else { bitwise_OR_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } Console . Write ( bitwise_OR_sum + " " ) ; } return ; }
void constructArray ( int [ ] A , int N , int K ) { int [ ] B = new int [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( B [ i ] + " " ) ; } }
void countPairs ( int [ ] arr , int k , int size ) { int count = 0 , x ; for ( int i = 0 ; i < size - 1 ; i ++ ) { for ( int j = i + 1 ; j < size ; j ++ ) { x = arr [ i ] | arr [ j ] ; if ( x == k ) count ++ ; } } Console . WriteLine ( count ) ; }
void dfs ( int node , int xorr , int k ) { visited [ node ] = 1 ; if ( node != 1 && xorr == k ) ans ++ ; foreach ( pair x in adj [ node ] ) { if ( visited [ x . first ] != 1 ) { int xorr1 = xorr ^ x . second ; dfs ( x . first , xorr1 , k ) ; } } }
int maxDiff ( int [ ] arr , int n ) { int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { bool isSingleOccurance = true ; for ( int j = i + 1 ; j <= n - 1 ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return Math . Abs ( SubsetSum_1 - SubsetSum_2 ) ; }
int build_num ( int [ ] bit ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) if ( bit [ i ] > 0 ) ans += ( 1 << i ) ; return ans ; }
int maximumOR ( int [ ] arr , int n , int k ) { int [ ] bit = new int [ 32 ] ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) bit [ j ] ++ ; } } int max_or = build_num ( bit ) ; for ( int i = k ; i < n ; i ++ ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i - k ] & ( 1 << j ) ) > 0 ) bit [ j ] -- ; } for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) bit [ j ] ++ ; } max_or = Math . Max ( build_num ( bit ) , max_or ) ; } return max_or ; }
int build_num ( int [ ] bit , int k ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) if ( bit [ i ] == k ) ans += ( 1 << i ) ; return ans ; }
int minimumAND ( int [ ] arr , int n , int k ) { int [ ] bit = new int [ 32 ] ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) bit [ j ] ++ ; } } int min_and = build_num ( bit , k ) ; for ( int i = k ; i < n ; i ++ ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i - k ] & ( 1 << j ) ) > 0 ) bit [ j ] -- ; } for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) bit [ j ] ++ ; } min_and = Math . Min ( build_num ( bit , k ) , min_and ) ; } return min_and ; }
void findMinXORSubarray ( int [ ] arr , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_xor = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; int min_xor = curr_xor ; for ( int i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } Console . WriteLine ( min_xor ) ; }
int findmax ( int [ ] arr , int n , int k ) { int trav , i ; int c = 0 , maximum = 0 ; for ( i = 0 ; i < n - k + 1 ; i ++ ) { trav = i - 1 ; c = 0 ; while ( trav >= 0 && arr [ trav ] == 1 ) { trav -- ; c ++ ; } trav = i + k ; while ( trav < n && arr [ trav ] == 1 ) { trav ++ ; c ++ ; } c += k ; if ( c > maximum ) maximum = c ; } return maximum ; }
int powerOfTwo ( int [ ] a , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( a [ i ] ) ) { mp [ a [ i ] ] = mp [ a [ i ] ] + 1 ; } else { mp . Add ( a [ i ] , 1 ) ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { bool f = false ; for ( int j = 0 ; j < 31 ; j ++ ) { int s = ( 1 << j ) - a [ i ] ; if ( mp . ContainsKey ( s ) && ( mp [ s ] > 1 || mp [ s ] == 1 && s != a [ i ] ) ) f = true ; } if ( f == false ) count ++ ; } return count ; }
int maxDiff ( int [ ] arr , int n ) { int result = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . Abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . Abs ( arr [ n - 1 ] ) ; return result ; }
void findArray ( int n , int a , int b , int c ) { int [ ] arr = new int [ n + 1 ] ; for ( int bit = 30 ; bit >= 0 ; bit -- ) { int set = a & ( 1 << bit ) ; if ( set != 0 ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] |= set ; } else { if ( ( b & ( 1 << bit ) ) != 0 ) { arr [ 0 ] |= ( 1 << bit ) ; if ( ( c & ( 1 << bit ) ) == 0 ) { arr [ 1 ] |= ( 1 << bit ) ; } } } } int aa = int . MaxValue , bb = 0 , cc = 0 ; for ( int i = 0 ; i < n ; i ++ ) { aa &= arr [ i ] ; bb |= arr [ i ] ; cc ^= arr [ i ] ; } if ( a == aa && b == bb && c == cc ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; } else Console . WriteLine ( "-1" ) ; }
int countSubarray ( int [ ] arr , int K , int N ) { if ( K % 2 != 0 ) return 0 ; if ( N < K ) return 0 ; int start = 0 ; int i = 0 ; int count = 0 ; int currXor = arr [ i ++ ] ; while ( i < K ) { currXor ^= arr [ i ] ; i ++ ; } if ( currXor == 0 ) count ++ ; currXor ^= arr [ start ++ ] ; while ( i < N ) { currXor ^= arr [ i ] ; i ++ ; if ( currXor == 0 ) count ++ ; currXor ^= arr [ start ++ ] ; } return count ; }
int findLargestNumber ( int [ ] arr ) { int k = arr . Max ( ) ; int [ ] m = new int [ k + 1 ] ; foreach ( int n in arr ) ++ m [ n ] ; for ( int n = arr . Length - 1 ; n > 0 ; -- n ) { if ( n == m [ n ] ) return n ; } return - 1 ; }
int maxDiff ( int [ ] arr , int n ) { Dictionary < int , int > hashPositive = new Dictionary < int , int > ( ) ; Dictionary < int , int > hashNegative = new Dictionary < int , int > ( ) ; int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( arr [ i ] > 0 ) { if ( hashPositive . ContainsKey ( arr [ i ] ) ) { hashPositive [ arr [ i ] ] += 1 ; } else { hashPositive . Add ( arr [ i ] , 1 ) ; } } } for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( arr [ i ] > 0 && hashPositive . ContainsKey ( arr [ i ] ) ) { if ( hashPositive [ arr [ i ] ] == 1 ) { SubsetSum_1 += arr [ i ] ; } } } for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( arr [ i ] < 0 ) { if ( hashNegative . ContainsKey ( Math . Abs ( arr [ i ] ) ) ) { hashNegative [ Math . Abs ( arr [ i ] ) ] += 1 ; } else { hashNegative . Add ( Math . Abs ( arr [ i ] ) , 1 ) ; } } } for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( arr [ i ] < 0 && hashNegative . ContainsKey ( Math . Abs ( arr [ i ] ) ) ) { if ( hashNegative [ Math . Abs ( arr [ i ] ) ] == 1 ) { SubsetSum_2 += arr [ i ] ; } } } return Math . Abs ( SubsetSum_1 - SubsetSum_2 ) ; }
int NoCarrySum ( int N , int M ) { return N ^ M ; }
bool CheckBits ( int N , int K ) { int check = 0 ; int count = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( ( ( 1 << i ) & N ) > 0 ) { if ( check == 0 ) { check = 1 ; } else { if ( count < K ) { return false ; } } count = 0 ; } else { count ++ ; } } return true ; }
int RecursiveFunction ( List < int > re , int bit ) { if ( re . Count == 0 bit < 0 ) return 0 ; List < int > curr_on = new List < int > ( ) ; List < int > curr_off = new List < int > ( ) ; for ( int i = 0 ; i < re . Count ; i ++ ) { if ( ( ( re [ i ] >> bit ) & 1 ) == 0 ) curr_off . Add ( re [ i ] ) ; else curr_on . Add ( re [ i ] ) ; } if ( curr_off . Count == 0 ) return RecursiveFunction ( curr_on , bit - 1 ) ; if ( curr_on . Count == 0 ) return RecursiveFunction ( curr_off , bit - 1 ) ; return Math . Min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ; }
int minimumFlips ( int X , int Y , int Z ) { int res = 0 ; while ( X > 0 Y > 0 Z > 0 ) { if ( ( ( X % 2 == 1 ) || ( Y % 2 == 1 ) ) && ( Z % 2 == 1 ) ) { X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; continue ; } else if ( ! ( X % 2 == 1 ) && ! ( Y % 2 == 1 ) && ( Z % 2 == 1 ) ) { res ++ ; } else if ( ( X % 2 == 1 ) || ( Y % 2 == 1 ) ) { if ( ( X % 2 == 1 ) && ( Y % 2 == 1 ) && ! ( Z % 2 == 1 ) ) { res += 2 ; } else if ( ( ( X % 2 == 1 ) || ( Y % 2 == 1 ) ) && ! ( Z % 2 == 1 ) ) { res ++ ; } } X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; } return res ; }
int FlipBits ( int n ) { return n -= ( n & ( - n ) ) ; }
int calculate ( List < int > section , int pos ) { if ( pos < 0 ) return 0 ; List < int > on_section = new List < int > ( ) , off_section = new List < int > ( ) ; foreach ( int el in section ) { if ( ( ( el >> pos ) & 1 ) == 0 ) off_section . Add ( el ) ; else on_section . Add ( el ) ; } if ( off_section . Count == 0 ) return calculate ( on_section , pos - 1 ) ; if ( on_section . Count == 0 ) return calculate ( off_section , pos - 1 ) ; return Math . Min ( calculate ( off_section , pos - 1 ) , calculate ( on_section , pos - 1 ) ) + ( 1 << pos ) ; }
int minXorValue ( int [ ] a , int n ) { List < int > section = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) section . Add ( a [ i ] ) ; return calculate ( section , 30 ) ; }
void SieveOfEratosthenes ( bool [ ] prime ) { prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } }
void prime_xor ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { if ( ( i + 1 ) % k == 0 ) { ans ^= arr [ i ] ; } } } Console . WriteLine ( ans ) ; }
int xorOfArray ( int [ ] arr , int n ) { int xor_arr = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xor_arr = xor_arr ^ arr [ i ] ; } return xor_arr ; }
void countEvenBit ( int [ ] A , int [ ] B , int n , int m ) { int i , cntOdd = 0 , cntEven = 0 ; for ( i = 0 ; i < n ; i ++ ) { int x = bitCount ( A [ i ] ) ; if ( x % 2 == 1 ) { cntEven ++ ; } else { cntOdd ++ ; } } int [ ] CountB = new int [ m ] ; for ( i = 0 ; i < m ; i ++ ) { int x = bitCount ( B [ i ] ) ; if ( x % 2 == 1 ) { CountB [ i ] = cntEven ; } else { CountB [ i ] = cntOdd ; } } for ( i = 0 ; i < m ; i ++ ) { Console . Write ( CountB [ i ] + " " ) ; } }
bool isEven ( int n ) { if ( ( n ^ 1 ) == n + 1 ) return true ; else return false ; }
int bitwiseOrTillN ( int n ) { int result = 2 ; for ( int i = 4 ; i <= n ; i = i + 2 ) { result = result | i ; } return result ; }
void minRange ( int [ ] arr , int n , int k ) { int l = 0 , r = n ; int j = - 1 ; Dictionary < int , int > hm = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n ) { j ++ ; if ( j < n && hm . Count < k ) if ( hm . ContainsKey ( arr [ j ] ) ) hm [ arr [ j ] ] = hm [ arr [ j ] ] + 1 ; else hm . Add ( arr [ j ] , 1 ) ; if ( hm . Count == k && ( ( r - l ) >= ( j - i ) ) ) { l = i ; r = j ; break ; } } if ( hm . Count < k ) break ; while ( hm . Count == k ) { if ( hm . ContainsKey ( arr [ i ] ) && hm [ arr [ i ] ] == 1 ) hm . Remove ( arr [ i ] ) ; else { if ( hm . ContainsKey ( arr [ i ] ) ) hm [ arr [ i ] ] = hm [ arr [ i ] ] - 1 ; } i ++ ; if ( hm . Count == k && ( r - l ) >= ( j - i ) ) { l = i ; r = j ; } } if ( hm . ContainsKey ( arr [ i ] ) && hm [ arr [ i ] ] == 1 ) hm . Remove ( arr [ i ] ) ; else if ( hm . ContainsKey ( arr [ i ] ) ) hm [ arr [ i ] ] = hm [ arr [ i ] ] - 1 ; } if ( l == 0 && r == n ) Console . WriteLine ( "Invalid k" ) ; else Console . WriteLine ( l + " " + r ) ; }
int bitwiseOrTillN ( int n ) { if ( n < 2 ) return 0 ; int bitCount = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; return ( int ) Math . Pow ( 2 , bitCount ) - 2 ; }
int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }
int bitwiseAndOdd ( int n ) { return 1 ; }
void construct_Xor_Tree_Util ( int [ ] current , int start , int end , int x ) { if ( start == end ) { xor_tree [ x ] = current [ start ] ; return ; } int left = x * 2 + 1 ; int right = x * 2 + 2 ; int mid = start + ( end - start ) / 2 ; construct_Xor_Tree_Util ( current , start , mid , left ) ; construct_Xor_Tree_Util ( current , mid + 1 , end , right ) ; xor_tree [ x ] = ( xor_tree [ left ] ^ xor_tree [ right ] ) ; }
void genSequence ( int n , int val ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int x = i ^ ( i >> 1 ) ^ val ; Console . Write ( x + " " ) ; } }
bool check ( int [ ] arr , int n , int m , int d ) { int i = 0 ; while ( i < n && m > 0 ) { m -- ; i += d ; } return m == 0 ? true : false ; }
int maximumDistance ( int [ ] arr , int n , int m ) { int low = 1 , high = n - 1 ; int ans = 0 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; bool flag = check ( arr , n , m , mid ) ; if ( flag ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; }
int minTrees ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
void longest ( int [ ] a , int n , int k ) { int [ ] freq = new int [ 7 ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( int i = start ; i <= end ; i ++ ) Console . Write ( a [ i ] + " " ) ; }
int extraElement ( int [ ] A , int [ ] B , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; }
int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }
int maxOnes ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int currMax = maxConsecutiveOnes ( arr [ i ] ) ; ans = Math . Max ( ans , currMax ) ; } return ans ; }
int maxOR ( int L , int R ) { if ( L == R ) { return L ; } int ans = 0 ; for ( int i = MAX - 1 ; i >= 0 ; i -- ) { int p , lbit , rbit ; p = 1 << i ; if ( ( rbit == 1 ) && ( lbit == 0 ) ) { ans += ( p << 1 ) - 1 ; break ; } if ( rbit == 1 ) { ans += p ; } } return ans ; }
int findLen ( int [ ] arr , int n , int m ) { List < int > filter = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & m ) == m ) filter . Add ( arr [ i ] ) ; if ( filter . Count == 0 ) return 0 ; int c_and = filter [ 0 ] ; for ( int i = 1 ; i < filter . Count ; i ++ ) c_and &= filter [ i ] ; if ( c_and == m ) return filter . Count ; return 0 ; }
int toggleBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
int clearBit ( int n , int k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; }
int getMinSteps ( int K ) { return countSetBits ( K ) ; }
int sum ( int [ ] a , int n ) { IDictionary < int , int > cnt = new Dictionary < int , int > ( ) ; int ans = 0 , pre_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i * a [ i ] ) - pre_sum ; pre_sum += a [ i ] ; if ( cnt . ContainsKey ( a [ i ] - 1 ) ) { ans -= cnt [ a [ i ] - 1 ] ; } if ( cnt . ContainsKey ( a [ i ] + 1 ) ) { ans += cnt [ a [ i ] + 1 ] ; } if ( cnt . ContainsKey ( a [ i ] ) ) { cnt [ a [ i ] ] = cnt [ a [ i ] ] + 1 ; } else { cnt [ a [ i ] ] = 1 ; } } return ans ; }
int cntElements ( int [ ] arr , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; }
int xor_triplet ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j ; k < n ; k ++ ) { int xor1 = 0 , xor2 = 0 ; for ( int x = i ; x < j ; x ++ ) { xor1 ^= arr [ x ] ; } for ( int x = j ; x <= k ; x ++ ) { xor2 ^= arr [ x ] ; } if ( xor1 == xor2 ) { ans ++ ; } } } } return ans ; }
int findSubarray ( int [ ] array , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; mp . Add ( 0 , 1 ) ; int answer = 0 ; int preXor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int value = 1 ; preXor ^= array [ i ] ; for ( int j = 1 ; j <= MAX ; j ++ ) { int Y = value ^ preXor ; if ( mp . ContainsKey ( Y ) ) { answer += mp [ Y ] ; } value *= 2 ; } if ( mp . ContainsKey ( preXor ) ) { mp [ preXor ] = mp [ preXor ] + 1 ; } else { mp . Add ( preXor , 1 ) ; } } return answer ; }
int max_xor ( int [ ] arr , int n ) { int maxXor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { maxXor = Math . Max ( maxXor , arr [ i ] ^ arr [ j ] ) ; } } return maxXor ; }
int CountTriplets ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int first = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { first ^= arr [ j ] ; if ( first == 0 ) ans += ( j - i ) ; } } return ans ; }
void findMajority ( int [ ] arr , int n ) { int len = 32 ; int number = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int countt = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countt ++ ; } if ( countt > ( n / 2 ) ) number += ( 1 << i ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == number ) count ++ ; if ( count > ( n / 2 ) ) Console . Write ( number ) ; else Console . Write ( "Majority Element Not Present" ) ; }
int countBits ( int a , int b ) { int count = 0 ; while ( a > 0 b > 0 ) { int last_bit_a = a & 1 ; int last_bit_b = b & 1 ; if ( last_bit_a != last_bit_b ) count ++ ; a = a >> 1 ; b = b >> 1 ; } return count ; }
int CountSetBits ( int n ) { if ( n == 0 ) return 0 ; if ( ( n & 1 ) == 1 ) return 1 + CountSetBits ( n >> 1 ) ; else return CountSetBits ( n >> 1 ) ; }
long calculate ( int bit_cnt ) { long res = 1 ; while ( bit_cnt -- > 0 ) { res = res * 3 ; } return res ; }
int unset_bit_count ( long n ) { int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count ++ ; n = n >> 1 ; } return count ; }
long bit_q ( int i , int j ) { long sum = 0 ; while ( j > 0 ) { sum += bit [ j ] ; j -= ( j & ( j * - 1 ) ) ; } i -- ; while ( i > 0 ) { sum -= bit [ i ] ; i -= ( i & ( i * - 1 ) ) ; } return sum ; }
void bit_up ( int i , long diff ) { while ( i <= n ) { bit [ i ] += diff ; i += i & - i ; } }
void initialise ( ) { Ideal_pair = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { root_node [ i ] = true ; bit [ i ] = 0 ; } }
long Idealpairs ( ) { int r = - 1 ; for ( int i = 1 ; i <= n ; i ++ ) if ( root_node [ i ] ) { r = i ; break ; } dfs ( r ) ; return Ideal_pair ; }
int pairORSum ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }
int solve ( int [ ] A , int [ ] B , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( countSetBits ( A [ i ] & A [ j ] ) == B [ j ] ) { cnt ++ ; } } } return cnt ; }
long multiplyByFifteen ( long n ) { long prod = ( n << 3 ) ; prod += ( n << 2 ) ; prod += ( n << 1 ) ; prod += n ; return prod ; }
void balTernary ( int ter ) { int carry = 0 , b = 10 ; int i = 32 ; while ( ter > 0 ) { int rem = ter % b ; rem = rem + carry ; if ( rem == 0 ) { arr [ i -- ] = 0 ; carry = 0 ; } else if ( rem == 1 ) { arr [ i -- ] = 1 ; carry = 0 ; } else if ( rem == 2 ) { arr [ i -- ] = - 1 ; carry = 1 ; } else if ( rem == 3 ) { arr [ i -- ] = 0 ; carry = 1 ; } ter = ( int ) ( ter / b ) ; } if ( carry == 1 ) arr [ i ] = 1 ; }
bool isDefeat ( string s1 , string s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == '0' && s2 [ i ] == '1' ) || ( s1 [ i ] == '1' && s2 [ i ] == '0' ) ) continue ; else if ( ( s1 [ i ] == '0' && s2 [ i ] == 'Z' ) || ( s1 [ i ] == 'Z' && s2 [ i ] == '0' ) ) continue ; else { return true ; } } return false ; }
bool check ( int [ , ] a , int [ , ] b ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( a [ i , j ] != b [ i , j ] ) { a [ i , j ] ^= 1 ; a [ 0 , 0 ] ^= 1 ; a [ 0 , j ] ^= 1 ; a [ i , 0 ] ^= 1 ; } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( a [ i , j ] != b [ i , j ] ) return false ; } } return true ; }
int FindIndexKthBit ( int n , int k ) { int cnt = 0 ; int ind = 0 ; while ( n > 0 ) { if ( ( n & 1 ) != 0 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return - 1 ; }
bool check ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 1 ) return true ; return false ; }
void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void findArray ( int [ ] q , int n ) { int ans ; int [ ] arr = new int [ n ] ; for ( int k = 0 , j = 0 ; j < n / 4 ; j ++ ) { ans = q [ k ] ^ q [ k + 3 ] ; arr [ k + 1 ] = q [ k + 1 ] ^ ans ; arr [ k + 2 ] = q [ k + 2 ] ^ ans ; arr [ k ] = q [ k ] ^ ( ( arr [ k + 1 ] ) ^ ( arr [ k + 2 ] ) ) ; arr [ k + 3 ] = q [ k + 3 ] ^ ( arr [ k + 1 ] ^ arr [ k + 2 ] ) ; k += 4 ; } printArray ( arr , n ) ; }
int countX ( int n ) { string binary = Convert . ToString ( n , 2 ) ; int count = 0 ; for ( int i = 0 ; i < binary . Length ; i ++ ) { if ( binary [ i ] == '1' ) count ++ ; } int answer = ( int ) Math . Pow ( 2 , count ) ; return answer ; }
void binToDecimal3 ( int n ) { int [ ] a = new int [ 64 ] ; int x = 0 , i ; for ( i = 0 ; n > 0 ; i ++ ) { a [ i ] = n % 2 ; n /= 2 ; } x = ( i < 3 ) ? 3 : i ; int d = 0 , p = 0 ; for ( int j = x - 3 ; j < x ; j ++ ) d += a [ j ] * ( int ) Math . Pow ( 2 , p ++ ) ; int d1 = d ; d = 0 ; p = 0 ; for ( int k = 0 ; k < 3 ; k ++ ) d += a [ k ] * ( int ) Math . Pow ( 2 , p ++ ) ; Console . WriteLine ( d1 + " " + d ) ; }
void binToDecimal3 ( int n ) { int last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; int first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; Console . WriteLine ( first_3 + " " + last_3 ) ; }
int nextPowerOf2 ( int n ) { int p = 1 ; if ( n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
int memoryUsed ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int nearest = nextPowerOf2 ( sum ) ; return nearest ; }
bool isPowerOfTwo ( int x ) { if ( x == 0 ) return false ; if ( ( x & ( x - 1 ) ) == 0 ) return true ; else return false ; }
int countNum ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) || isPowerOfTwo ( a [ i ] + 1 ) ) count ++ ; } return count ; }
bool checkEvenParity ( int x ) { int parity = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; parity ++ ; } if ( parity % 2 == 0 ) return true ; else return false ; }
long sumlist ( int [ ] a , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkEvenParity ( a [ i ] ) ) sum += a [ i ] ; } return sum ; }
int minDistance ( int n1 , int n2 ) { int bitCount1 = ( int ) Math . Floor ( ( Math . Log ( n1 ) / Math . Log ( 2 ) ) ) + 1 ; int bitCount2 = ( int ) Math . Floor ( ( Math . Log ( n2 ) / Math . Log ( 2 ) ) ) + 1 ; int bitDiff = Math . Abs ( bitCount1 - bitCount2 ) ; int maxBitCount = Math . Max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * ( int ) Math . Pow ( 2 , bitDiff ) ; } else { n1 = n1 * ( int ) Math . Pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = ( int ) Math . Floor ( ( Math . Log ( xorValue ) / Math . Log ( 2 ) ) ) + 1 ; } int disSimilarBitPosition = maxBitCount - bitCountXorValue ; int result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; }
int findOddPair ( int [ ] A , int N ) { int oddPair = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
int countOddPair ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 != 1 ) ) { count ++ ; } } int evenPairCount = count * ( count - 1 ) / 2 ; int totPairs = N * ( N - 1 ) / 2 ; return totPairs - evenPairCount ; }
int findevenPair ( int [ ] A , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] ^ A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }
int findEvenPair ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 != 0 ) count ++ ; } int totalPairs = ( N * ( N - 1 ) / 2 ) ; int oddEvenPairs = count * ( N - count ) ; return totalPairs - oddEvenPairs ; }
int findevenPair ( int [ ] A , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }
int calculate ( int X ) { int number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }
int alternate ( int a , int b , int x ) { return x = a ^ b ^ x ; }
int countZeros ( int x ) { int total_bits = sizeofInt * 8 ; int res = 0 ; while ( ( x & ( 1 << ( total_bits - 1 ) ) ) == 0 ) { x = ( x << 1 ) ; res ++ ; } return res ; }
int countZeros ( int x ) { int y ; int n = 32 ; y = x >> 16 ; if ( y != 0 ) { n = n - 16 ; x = y ; } y = x >> 8 ; if ( y != 0 ) { n = n - 8 ; x = y ; } y = x >> 4 ; if ( y != 0 ) { n = n - 4 ; x = y ; } y = x >> 2 ; if ( y != 0 ) { n = n - 2 ; x = y ; } y = x >> 1 ; if ( y != 0 ) return n - 2 ; return n - x ; }
void LeadingZeros ( int x , int y ) { if ( ( x ^ y ) <= ( x & y ) ) Console . WriteLine ( "\nEqual" ) ; else if ( ( x & ( ~ y ) ) > y ) Console . WriteLine ( y ) ; else Console . WriteLine ( x ) ; }
void subset ( int nthBit , int num , int numOfBits ) { if ( nthBit >= 0 ) { if ( ( num & ( 1 << nthBit ) ) != 0 ) { Console . Write ( numOfBits - nthBit + " " ) ; } subset ( nthBit - 1 , num , numOfBits ) ; } else return ; }
void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } Console . WriteLine ( "Number of different bits : " + count ) ; }
int countSubarrWithEqualZeroAndOne ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ] ; if ( mp . ContainsKey ( curr_sum ) ) { var v = mp [ curr_sum ] ; mp . Remove ( curr_sum ) ; mp . Add ( curr_sum , ++ v ) ; } else mp . Add ( curr_sum , 1 ) ; } int count = 0 ; foreach ( KeyValuePair < int , int > itr in mp ) { if ( itr . Value > 1 ) count += ( ( itr . Value * ( itr . Value - 1 ) ) / 2 ) ; } if ( mp . ContainsKey ( 0 ) ) count += mp [ 0 ] ; return count ; }
int setRightmostUnsetBit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; }
int OR ( int [ ] a , int n ) { int ans = a [ 0 ] ; int i ; for ( i = 1 ; i < n ; i ++ ) { ans |= a [ i ] ; } return ans ; }
int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; }
bool isKthBitSet ( int n , int k ) { if ( ( n >> ( k - 1 ) ) == 1 ) return true ; return false ; }
int setKthBit ( int n , int k ) { return ( ( 1 << ( k - 1 ) ) n ) ; }
bool allBitsAreSet ( int n ) { if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; }
bool bitsAreInAltOrder ( int n ) { int num = n ^ ( n >> 1 ) ; return allBitsAreSet ( num ) ; }
bool bitsAreInAltPatrnInGivenRange ( int n , int l , int r ) { int num , left_shift ; if ( isKthBitSet ( n , r ) ) { num = n ; left_shift = r ; } else { num = setKthBit ( n , ( r + 1 ) ) ; left_shift = r + 1 ; } num = num & ( ( 1 << left_shift ) - 1 ) ; num = num >> ( l - 1 ) ; return bitsAreInAltOrder ( num ) ; }
bool findParity ( int x ) { int y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( ( y & 1 ) > 0 ) return true ; return false ; }
int bit ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n & ( n - 1 ) ; } return count ; }
int maxSumOfBits ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = bit ( arr [ i ] ) ; } int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; }
long increment ( long i ) { i = - ( ~ i ) ; return i ; }
char increment ( char i ) { int i1 = - ( ~ ( int ) ( i ) ) ; return ( char ) ( i1 ) ; }
void MakePreSum ( int [ ] arr , int [ ] presum , int n ) { presum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) presum [ i ] = presum [ i - 1 ] + arr [ i ] ; }
int lenOfLongSubarr ( int [ ] arr , int n ) { Dictionary < int , int > um = new Dictionary < int , int > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . ContainsKey ( sum ) ) um . Add ( sum , i ) ; if ( um . ContainsKey ( sum - 1 ) ) { if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um [ sum - 1 ] ; } } return maxLen ; }
int bit_count ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n & ( n - 1 ) ; } return count ; }
int maxsum ( int [ ] arr , int n ) { int [ ] bits = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { bits [ i ] = bit_count ( arr [ i ] ) ; } int [ ] sum = new int [ 32 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum [ bits [ i ] ] += arr [ i ] ; } int maximum = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { maximum = Math . Max ( sum [ i ] , maximum ) ; } return maximum ; }
int findOddPair ( int [ ] A , int N ) { int i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }
bool allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( num == new_num ) return true ; return false ; }
bool bitsAreComplement ( int a , int b , int l , int r ) { int xor_value = a ^ b ; return allBitsSetInTheGivenRange ( xor_value , l , r ) ; }
bool allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
bool checkSame ( int n ) { int set = 0 ; int unset = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 1 ) set ++ ; else unset ++ ; n = n >> 1 ; } if ( set == unset ) return true ; else return false ; }
bool isBalanced ( String s ) { Stack < char > st = new Stack < char > ( ) ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '(' ) { st . Push ( s [ i ] ) ; } else if ( st . Count == 0 ) { return false ; } else { st . Pop ( ) ; } } if ( st . Count != 0 ) { return false ; } return true ; }
bool isBalancedSeq ( String s1 , String s2 ) { if ( isBalanced ( s1 + s2 ) ) { return true ; } return isBalanced ( s2 + s1 ) ; }
void KthCharacter ( int m , int n , int k ) { int distance = ( int ) Math . Pow ( 2 , n ) ; int Block_number = k / distance ; int remaining = k % distance ; int [ ] s = new int [ 32 ] ; int x = 0 ; for ( ; m > 0 ; x ++ ) { s [ x ] = m % 2 ; m = m / 2 ; } int root = s [ x - 1 - Block_number ] ; if ( remaining == 0 ) { Console . WriteLine ( root ) ; return ; } Boolean flip = true ; while ( remaining > 1 ) { if ( ( remaining & 1 ) > 0 ) { flip = ! flip ; } remaining = remaining >> 1 ; } if ( flip ) { Console . WriteLine ( ! ( root > 0 ) ) ; } else { Console . WriteLine ( root ) ; } }
int MSBPosition ( long N ) { int msb_p = - 1 ; while ( N > 0 ) { N = N >> 1 ; msb_p ++ ; } return msb_p ; }
long findBitwiseOR ( long L , long R ) { long res = 0 ; int msb_p1 = MSBPosition ( L ) ; int msb_p2 = MSBPosition ( R ) ; while ( msb_p1 == msb_p2 ) { long res_val = ( 1 << msb_p1 ) ; res += res_val ; L -= res_val ; R -= res_val ; msb_p1 = MSBPosition ( L ) ; msb_p2 = MSBPosition ( R ) ; } msb_p1 = Math . Max ( msb_p1 , msb_p2 ) ; for ( int i = msb_p1 ; i >= 0 ; i -- ) { long res_val = ( 1 << i ) ; res += res_val ; } return res ; }
int getInteger ( int L , int R ) { int number = 0 ; for ( int i = L ; i <= R ; i ++ ) number += ( int ) Math . Pow ( 2 , i ) ; return number ; }
long maxOR ( long [ ] arr , int n , int k , int x ) { long [ ] preSum = new long [ n + 1 ] ; long [ ] suffSum = new long [ n + 1 ] ; long res = 0 , pow = 1 ; for ( int i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = Math . Max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; }
int findXor ( int [ ] arr , int n ) { int xoR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; } return xoR * 2 ; }
int turnOnK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
void setBitwiseORk ( int n ) { List < int > v = new List < int > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( i n ) == n ) { v . Add ( i ) ; } } for ( int i = 0 ; i < v . Count ; i ++ ) { Console . Write ( v [ i ] + " " ) ; } }
int smallerNumsWithSameSetBits ( int n ) { int temp = __builtin_popcount ( n ) ; int count = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( temp == __builtin_popcount ( i ) ) count ++ ; } return count ; }
int findEletobeInserted ( int [ ] A , int n , int k ) { int ans = k ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; return ans ; }
int andSum ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < BITS ; i ++ ) { int countSetBits = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countSetBits ++ ; } int subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; }
int Root ( int idx ) { int i = idx ; while ( i != id [ i ] ) { id [ i ] = id [ id [ i ] ] ; i = id [ i ] ; } return i ; }
void Union ( int a , int b ) { int i = Root ( a ) , j = Root ( b ) ; if ( i != j ) { if ( sz [ i ] >= sz [ j ] ) { id [ j ] = i ; sz [ i ] += sz [ j ] ; sz [ j ] = 0 ; } else { id [ i ] = j ; sz [ j ] += sz [ i ] ; sz [ i ] = 0 ; } } }
void UnionUtil ( Edge [ ] e , int [ ] W , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int u , v ; u = e [ i ] . u ; v = e [ i ] . v ; u -- ; v -- ; if ( W [ u ] % 2 == 0 && W [ v ] % 2 == 0 ) Union ( u , v ) ; } }
int findMax ( int n , int [ ] W ) { int maxi = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( W [ i ] % 2 == 0 ) maxi = Math . Max ( maxi , sz [ i ] ) ; return maxi ; }
int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
int multiplyWith4 ( int n ) { return ( n << 2 ) ; }
bool isEven ( int n ) { bool isEven = true ; for ( int i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; }
bool isEven ( int n ) { return ( ( n / 2 ) * 2 == n ) ; }
bool checkValidPair ( int num1 , int num2 ) { string s1 = num1 . ToString ( ) ; string s2 = num2 . ToString ( ) ; for ( int i = 0 ; i < s1 . Length ; i ++ ) for ( int j = 0 ; j < s2 . Length ; j ++ ) if ( s1 [ i ] == s2 [ j ] ) return true ; return false ; }
int countPairs ( int [ ] arr , int n ) { int numberOfPairs = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( checkValidPair ( arr [ i ] , arr [ j ] ) ) numberOfPairs ++ ; return numberOfPairs ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
bool isPowerOf2 ( int num ) { if ( num != 0 && ( num & ( num - 1 ) ) == 0 ) return true ; return false ; }
bool checkSubsequence ( int [ ] arr , int n ) { if ( n == 1 ) return isPowerOf2 ( arr [ 0 ] ) ; int total = 0 ; for ( int i = 0 ; i < NUM_BITS ; i ++ ) total = total | ( 1 << i ) ; for ( int i = 0 ; i < NUM_BITS ; i ++ ) { int ans = total ; for ( int j = 0 ; j < n ; j ++ ) { int p = arr [ j ] & ( 1 << i ) ; if ( p == 0 ) ans = ans & arr [ j ] ; } if ( isPowerOf2 ( ans ) ) return true ; } return false ; }
int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; }
void constructSTUtil ( int [ ] arr , int ss , int se , int [ ] st , int si , bool operation ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return ; } int mid = getMid ( ss , se ) ; constructSTUtil ( arr , ss , mid , st , si * 2 + 1 , ! operation ) ; constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 , ! operation ) ; if ( operation ) { st [ si ] = ( st [ 2 * si + 1 ] st [ 2 * si + 2 ] ) ; } else { st [ si ] = ( st [ 2 * si + 1 ] ^ st [ 2 * si + 2 ] ) ; } }
void constructTree ( int low , int high , int pos , int [ ] a ) { if ( low == high ) { level [ pos ] = 0 ; tree [ pos ] = a [ high ] ; return ; } int mid = ( low + high ) / 2 ; constructTree ( low , mid , 2 * pos + 1 , a ) ; constructTree ( mid + 1 , high , 2 * pos + 2 , a ) ; level [ pos ] = level [ 2 * pos + 1 ] + 1 ; if ( ( level [ pos ] & 1 ) > 0 ) tree [ pos ] = tree [ 2 * pos + 1 ] | tree [ 2 * pos + 2 ] ; else tree [ pos ] = tree [ 2 * pos + 1 ] ^ tree [ 2 * pos + 2 ] ; }
void update ( int low , int high , int pos , int index , int [ ] a ) { if ( low == high && low == index ) { tree [ pos ] = a [ low ] ; return ; } if ( index < low index > high ) return ; if ( low != high ) { int mid = ( low + high ) / 2 ; update ( low , mid , 2 * pos + 1 , index , a ) ; update ( mid + 1 , high , 2 * pos + 2 , index , a ) ; if ( ( level [ pos ] & 1 ) > 0 ) tree [ pos ] = tree [ 2 * pos + 1 ] | tree [ 2 * pos + 2 ] ; else tree [ pos ] = tree [ 2 * pos + 1 ] ^ tree [ 2 * pos + 2 ] ; } }
void updateValue ( int index , int value , int [ ] a , int n ) { a [ index ] = value ; update ( 0 , n - 1 , 0 , index , a ) ; }
int maxXOR ( int n , int k ) { int c = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; return ( ( 1 << c ) - 1 ) ; }
long divide ( long dividend , long divisor ) { long sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 ; dividend = Math . Abs ( dividend ) ; divisor = Math . Abs ( divisor ) ; long quotient = 0 , temp = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1L L << i ; } } if ( sign == - 1 ) quotient = - quotient ; return quotient ; }
int count ( int n ) { int c = 0 ; while ( n != 0 ) { c ++ ; n = n >> 1 ; } return c ; }
uint swapBitsInPair ( uint x ) { return ( ( x & 010101010 ) >> 1 ) | ( ( x & 001010101 ) << 1 ) ; }
int evenbitsetnumber ( int n ) { int count = 0 , res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
int getmsb ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( n + 1 ) >> 1 ; }
int getevenbits ( int n ) { n = getmsb ( n ) ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; if ( ( n & 1 ) == 1 ) n = n >> 1 ; return n ; }
int setallevenbits ( int n ) { return n | getevenbits ( n ) ; }
int getmsb ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( n + 1 ) >> 1 ; }
int getevenbits ( int n ) { n = getmsb ( n ) ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; if ( ( n & 1 ) == 0 ) n = n >> 1 ; return n ; }
int setalloddbits ( int n ) { return n | getevenbits ( n ) ; }
int setevenbits ( int n ) { int temp = n ; int count = 0 ; int res = 0 ; for ( temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n & res ) ; }
int setoddbits ( int m ) { int count = 0 ; int res = 0 ; for ( int temp = m ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( m & res ) ; }
int getAlternateBits ( int n , int m ) { int tempn = setevenbits ( n ) ; int tempm = setoddbits ( m ) ; return ( tempn tempm ) ; }
int takeLandFsetbits ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( ( n + 1 ) >> 1 ) + 1 ; }
int toggleFandLbits ( int n ) { if ( n == 1 ) return 0 ; return n ^ takeLandFsetbits ( n ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
bool checkOdious ( int n ) { return ( countSetBits ( n ) % 2 == 1 ) ; }
int setleftmostunsetbit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; int pos = 0 ; for ( int temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; }
int getPosOfRightmostSetBit ( int n ) { return ( int ) ( Math . Log ( n & - n ) / Math . Log ( 2 ) ) ; }
int toggleLastKBits ( int n , int k ) { int num = ( 1 << k ) - 1 ; return ( n ^ num ) ; }
int incrementByOne ( int n ) { int k = getPosOfRightmostSetBit ( ~ n ) ; n = ( ( 1 << k ) n ) ; if ( k != 0 ) n = toggleLastKBits ( n , k ) ; return n ; }
void printNumHavingAltBitPatrn ( int n ) { int curr_num = 1 , i = 1 ; Console . Write ( curr_num + " " ) ; while ( i != 0 ) { curr_num <<= 1 ; if ( n < curr_num ) break ; Console . Write ( curr_num + " " ) ; curr_num = ( ( curr_num ) << 1 ) ^ 1 ; if ( n < curr_num ) break ; Console . Write ( curr_num + " " ) ; } }
int xnor ( int a , int b ) { if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a == 0 && b == 0 ) return 1 ; int a_rem = 0 ; int b_rem = 0 ; int count = 0 ; int xnornum = 0 ; while ( true ) { a_rem = a & 1 ; b_rem = b & 1 ; if ( a_rem == b_rem ) xnornum |= ( 1 << count ) ; count ++ ; a = a >> 1 ; b = b >> 1 ; if ( a < 1 ) break ; } return xnornum ; }
int togglebit ( int n ) { if ( n == 0 ) return 1 ; int i = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return i ^ n ; }
void MaximumSum ( int [ ] a , int [ ] b , int n ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } Console . WriteLine ( sum1 + sum2 ) ; }
int posOfCarryBit ( int a , int b ) { return posOfRightmostSetBit ( a & b ) ; }
bool isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
bool differAtOneBitPos ( int a , int b ) { return isPowerOfTwo ( a ^ b ) ; }
long power2 ( long n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 2 ; return power2 ( n / 2 ) * power2 ( n / 2 ) ; }
long multiply ( long x , long n ) { return x * power2 ( n ) ; }
int multiply ( int x , int n ) { return x << n ; }
bool isDivBy2PowerM ( int n , int m ) { if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ; return false ; }
int findWinner ( int N ) { return N & 1 ; }
void wrapper ( int [ ] arr , int n , int [ ] l , int [ ] r , int q ) { int [ ] prefodd = new int [ 100 ] ; int [ ] prefeven = new int [ 100 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( i ) % 2 == 0 ) { prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ; } else { prefeven [ i ] = prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] ; } } int j = 0 ; while ( j != q ) { ansQueries ( prefeven , prefodd , l [ j ] , r [ j ] ) ; j ++ ; } }
int countgroup ( int [ ] a , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; }
int perfectPowerOf2 ( int n ) { int per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; }
int solve ( int [ ] p , int n ) { int G = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] % 2 != 0 ) G ^= ( p [ i ] + 1 ) ; G ^= ( p [ i ] - 1 ) ; } return G ; }
bool isDivisibleby17 ( int n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; }
long answer ( long n ) { long m = 2 ; long ans = 1 ; long r = 1 ; while ( r < n ) { r = ( ( long ) Math . Pow ( 2 , m ) - 1 ) * ( ( long ) Math . Pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }
int maxAND ( int [ ] arr , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) res = res > ( arr [ i ] & arr [ j ] ) ? res : ( arr [ i ] & arr [ j ] ) ; return res ; }
int checkBit ( int pattern , int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; }
int index ( int i ) { return 1 + ( i >> 31 ) - ( - i >> 31 ) ; }
int countPairs ( int [ ] arr , int n ) { Dictionary < int , int > hm = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hm . ContainsKey ( arr [ i ] ) ) { int a = hm [ arr [ i ] ] ; hm . Remove ( arr [ i ] ) ; hm . Add ( arr [ i ] , a + 1 ) ; } else hm . Add ( arr [ i ] , 1 ) ; } int ans = 0 ; foreach ( var it in hm ) { int count = it . Value ; ans += ( count * ( count - 1 ) ) / 2 ; } return ans ; }
int countones ( long n ) { int c = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; c ++ ; } return c ; }
bool checking ( string s ) { int c = 0 ; int n = s . Length ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '0' ) c ++ ; if ( c >= 6 && s [ i ] == '1' ) return true ; } return false ; }
int countSetBitsInGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return countSetBits ( n & num ) ; }
bool areAllBitsSet ( long n ) { if ( n == 0 ) return false ; if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; }
int findUnique ( int [ ] a , int n , int k ) { byte sizeof_int = 4 ; int INT_SIZE = 8 * sizeof_int ; int [ ] count = new int [ INT_SIZE ] ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; int res = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
bool powerOfTwo ( uint n ) { return ( ( n & n - 1 ) == 0 ) ; }
bool onlyFirstAndLastAreSet ( uint n ) { if ( n == 1 ) return true ; return powerOfTwo ( n - 1 ) ; }
bool allBitsAreSet ( int n ) { if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; }
bool bitsAreInAltOrder ( int n ) { int num = n ^ ( n >> 1 ) ; return allBitsAreSet ( num ) ; }
int setBit ( int xorValue ) { int count = 0 ; while ( xorValue >= 1 ) { if ( xorValue % 2 == 1 ) count ++ ; xorValue /= 2 ; } return count ; }
int minFlip ( int n , int k ) { int size = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; int max = ( int ) Math . Pow ( 2 , k ) - 1 ; max = max << ( size - k ) ; int xorValue = ( n ^ max ) ; return ( setBit ( xorValue ) ) ; }
int setallbitgivenrange ( int n , int l , int r ) { int range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; }
uint countBits ( uint number ) { return ( uint ) Math . Log ( number , 2.0 ) + 1 ; }
int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
int setAllBitsAfterMSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; }
int toggle ( int n ) { n = n ^ setAllBitsAfterMSB ( n ) ; return n ; }
bool checkPowerof8 ( int n ) { double i = Math . Log ( n ) / Math . Log ( 8 ) ; return ( i - Math . Floor ( i ) < 0.000001 ) ; }
bool adjacentSet ( int n ) { int x = ( n & ( n >> 1 ) ) ; if ( x > 0 ) return true ; else return false ; }
int getRightMostSetBit ( int n ) { return ( int ) ( ( Math . Log ( n & - n ) ) / ( Math . Log ( 2 ) ) ) + 1 ; }
int posOfRightMostSameBit ( int m , int n ) { return getRightMostSetBit ( ~ ( m ^ n ) ) ; }
void printNonConsecutive ( int n ) { int p = ( 1 << n ) ; for ( int i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) Console . Write ( i + " " ) ; }
int isKthBitSet ( int x , int k ) { return ( ( x & ( 1 << ( k - 1 ) ) ) > 0 ) ? 1 : 0 ; }
int leftmostSetBit ( int x ) { int count = 0 ; while ( x > 0 ) { count ++ ; x = x >> 1 ; } return count ; }
int isBinPalindrome ( int x ) { int l = leftmostSetBit ( x ) ; int r = 1 ; while ( l > r ) { if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) return 0 ; l -- ; r ++ ; } return 1 ; }
int findNthPalindrome ( int n ) { int pal_count = 0 ; int i = 0 ; for ( i = 1 ; i <= INT_MAX ; i ++ ) { if ( isBinPalindrome ( i ) > 0 ) { pal_count ++ ; } if ( pal_count == n ) break ; } return i ; }
int convertStringToInt ( String s ) { int ans = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '1' ) ans += 1 << i ; } return ans ; }
int getNthNumber ( int n ) { Queue < String > q = new Queue < String > ( ) ; if ( n == 1 ) return 1 ; n = n - 1 ; q . Enqueue ( "11" ) ; while ( n -- > 0 ) { String curr = q . Dequeue ( ) ; if ( n == 0 ) return convertStringToInt ( curr ) ; int len = curr . Length ; if ( len % 2 == 0 ) { q . Enqueue ( curr . Substring ( 0 , len / 2 ) + "0" + curr . Substring ( len / 2 ) ) ; q . Enqueue ( curr . Substring ( 0 , len / 2 ) + "1" + curr . Substring ( len / 2 ) ) ; } else { char midChar = curr [ len / 2 ] ; q . Enqueue ( curr . Substring ( 0 , len / 2 ) + midChar + curr . Substring ( len / 2 ) ) ; } } return - 1 ; }
int constructNthNumber ( int group_no , int aux_num , int op ) { int [ ] a = new int [ INT_SIZE ] ; int num = 0 , len_f ; int i = 0 ; if ( op == 2 ) { len_f = 2 * group_no ; a [ len_f - 1 ] = a [ 0 ] = 1 ; while ( aux_num > 0 ) { a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else if ( op == 0 ) { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 0 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 1 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } for ( i = 0 ; i < len_f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; }
int getNthNumber ( int n ) { int group_no = 0 , group_offset ; int count_upto_group = 0 , count_temp = 1 ; int op , aux_num ; while ( count_temp < n ) { group_no ++ ; count_upto_group = count_temp ; count_temp += 3 * ( 1 << ( group_no - 1 ) ) ; } group_offset = n - count_upto_group - 1 ; if ( ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) ) { aux_num = group_offset ; } else { if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 == 1 ) else aux_num = ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) / 2 ; } return constructNthNumber ( group_no , aux_num , op ) ; }
void shuffle ( int N , int key ) { int NO_OF_BITS = N ; int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( key & ( 1 << i ) ) ; if ( temp > 0 ) reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) ; } Console . Write ( reverse_num ) ; }
int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }
void areSame ( int a , int b ) { if ( ( a - b ) == 0 ) Console . Write ( "Same" ) ; else Console . Write ( "Not Same" ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( countSetBits ( i ) == 2 ) sum += i ; return sum ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; 1 << i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { int num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; }
int findMax ( int num ) { byte size_of_int = 4 ; int num_copy = num ; int j = size_of_int * 8 - 1 ; int i = 0 ; while ( i < j ) { int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ; if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; }
int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; }
int getPosOfRightmostSetBit ( int n ) { return ( int ) ( ( Math . Log10 ( n & - n ) ) / ( Math . Log10 ( 2 ) ) ) + 1 ; }
int setRightmostUnsetBit ( int n ) { if ( n == 0 ) return 1 ; if ( ( n & ( n + 1 ) ) == 0 ) return n ; int pos = getPosOfRightmostSetBit ( ~ n ) ; return ( ( 1 << ( pos - 1 ) ) n ) ; }
int previousSmallerInteger ( int n ) { int pos = getFirstSetBitPos ( n ) ; return ( n & ~ ( 1 << ( pos - 1 ) ) ) ; }
int getRightMostSetBit ( int n ) { if ( n == 0 ) return 0 ; return ( int ) ( ( Math . Log10 ( n & - n ) ) / Math . Log10 ( 2 ) ) + 1 ; }
int posOfRightMostDiffBit ( int m , int n ) { return getRightMostSetBit ( m ^ n ) ; }
int posOfRightMostDiffBit ( int m , int n ) { return ( int ) Math . Floor ( Math . Log10 ( Math . Pow ( m ^ n , 2 ) ) ) + 2 ; }
int getFirstSetBitPos ( int n ) { return ( ( int ) ( Math . Log ( n & - n ) / Math . Log ( 2 ) ) + 1 ) - 1 ; }
int nextGreaterWithOneMoreSetBit ( int n ) { int pos = getFirstSetBitPos ( ~ n ) ; if ( pos > - 1 ) return ( 1 << pos ) | n ; return ( ( n << 1 ) + 1 ) ; }
int setKthBit ( int n , int k ) { return ( ( 1 << k ) n ) ; }
int getNext ( int n ) { int c = n ; int c0 = 0 ; int c1 = 0 ; while ( ( ( c & 1 ) == 0 ) && ( c != 0 ) ) { c0 ++ ; c >>= 1 ; } while ( ( c & 1 ) == 1 ) { c1 ++ ; c >>= 1 ; } if ( c0 + c1 == 31 c0 + c1 == 0 ) return - 1 ; return n + ( 1 << c0 ) + ( 1 << ( c1 - 1 ) ) - 1 ; }
void reverseArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { swap ( arr , i , ( n + ~ i + 1 ) + ~ 1 + 1 ) ; } }
int countNum ( int [ ] arr , int n ) { HashSet < int > s = new HashSet < int > ( ) ; int count = 0 , maxm = int . MinValue , minm = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { s . Add ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) if ( ! s . Contains ( i ) ) count ++ ; return count ; }
int CountXORandSumEqual ( int x ) { int count = CountZeroBit ( x ) ; return ( 1 << count ) ; }
int maxXORInRange ( int L , int R ) { int LXR = L ^ R ; int msbPos = 0 ; while ( LXR > 0 ) { msbPos ++ ; LXR >>= 1 ; } int maxXOR = 0 ; int two = 1 ; while ( msbPos -- > 0 ) { maxXOR += two ; two <<= 1 ; } return maxXOR ; }
int missingNumber ( int [ ] arr1 , int [ ] arr2 , int n ) { int mnum = 0 ; for ( int i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }
int CountORandSumEqual ( int N ) { int count = CountZeroBit ( N ) ; return ( 1 << count ) ; }
int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
int countValues ( int x ) { int count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x /= 2 ; } return count ; }
void constructXOR ( int [ ] A , int n ) { int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }
long kBitDifferencePairs ( int [ ] arr , int n , int k ) { int MAX = arr . Max ( ) ; long [ ] count = new long [ MAX + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ; long ans = 0 ; if ( k == 0 ) { for ( int i = 0 ; i <= MAX ; ++ i ) ans += ( count [ i ] * ( count [ i ] - 1 ) ) / 2 ; return ans ; } for ( int i = 0 ; i <= MAX ; ++ i ) { if ( count [ i ] == 0 ) continue ; for ( int j = i + 1 ; j <= MAX ; ++ j ) { if ( BitCount ( i ^ j ) == k ) ans += count [ i ] * count [ j ] ; } } return ans ; }
void multiply ( int [ , ] F , int [ , ] M ) { int x = F [ 0 , 0 ] * M [ 0 , 0 ] + F [ 0 , 1 ] * M [ 1 , 0 ] ; int y = F [ 0 , 0 ] * M [ 0 , 1 ] + F [ 0 , 1 ] * M [ 1 , 1 ] ; int z = F [ 1 , 0 ] * M [ 0 , 0 ] + F [ 1 , 1 ] * M [ 1 , 0 ] ; int w = F [ 1 , 0 ] * M [ 0 , 1 ] + F [ 1 , 1 ] * M [ 1 , 1 ] ; F [ 0 , 0 ] = x ; F [ 0 , 1 ] = y ; F [ 1 , 0 ] = z ; F [ 1 , 1 ] = w ; }
void power ( int [ , ] F , int n ) { if ( n == 0 n == 1 ) { return ; } int [ , ] M = { { 1 , 1 } , { 1 , 0 } } ; power ( F , n / 2 ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) { multiply ( F , M ) ; } }
int countWays ( int n ) { int [ , ] F = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) { return 0 ; } power ( F , n ) ; return F [ 0 , 0 ] ; }
int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; }
int totalFlips ( string A , string B , string C , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( A [ i ] == B [ i ] && C [ i ] == '1' ) ++ count ; else if ( A [ i ] != B [ i ] && C [ i ] == '0' ) ++ count ; } return count ; }
int countNumbers ( int n ) { int k = 0 ; int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( int ) ( Math . Pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; }
int multiply ( int n , int m ) { int ans = 0 , count = 0 ; while ( m > 0 ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m /= 2 ; } return ans ; }
bool EqualNumber ( int A , int B ) { if ( ( A ^ B ) > 0 ) return true ; else return false ; }
int countXOR ( int n ) { int count0 = 0 , count1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count0 ++ ; else count1 ++ ; n /= 2 ; } return ( count0 ^ count1 ) ; }
int xorPairCount ( int [ ] arr , int n , int x ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . Contains ( x ^ arr [ i ] ) ) { result ++ ; } s . Add ( arr [ i ] ) ; } return result ; }
int xorPairCount ( int [ ] arr , int n , int x ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = x ^ arr [ i ] ; if ( m . ContainsKey ( curr_xor ) ) result += m [ curr_xor ] ; if ( m . ContainsKey ( arr [ i ] ) ) { var val = m [ arr [ i ] ] ; m . Remove ( arr [ i ] ) ; m . Add ( arr [ i ] , val + 1 ) ; } else { m . Add ( arr [ i ] , 1 ) ; } } return result ; }
int msbPos ( long n ) { int msb_p = - 1 ; while ( n > 0 ) { n = n >> 1 ; msb_p ++ ; } return msb_p ; }
long andOperator ( long x , long y ) { long res = 0 ; while ( x > 0 && y > 0 ) { int msb_p1 = msbPos ( x ) ; int msb_p2 = msbPos ( y ) ; if ( msb_p1 != msb_p2 ) break ; long msb_val = ( 1 << msb_p1 ) ; res = res + msb_val ; x = x - msb_val ; y = y - msb_val ; } return res ; }
int multiplyTen ( int n ) { return ( n << 1 ) + ( n << 3 ) ; }
int countValues ( int n ) { int countV = 0 ; for ( int i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; }
int countValues ( int n ) { int unset_bits = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; }
int countSubarrays ( int [ ] arr , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hash_positive = new int [ n + 1 ] ; int [ ] hash_negative = new int [ n + 1 ] ; Array . Clear ( hash_positive , 0 , n + 1 ) ; Array . Clear ( hash_negative , 0 , n + 1 ) ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) difference ++ ; else difference -- ; if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; }
void printTwoSetBitNums ( int n ) { int x = 1 ; while ( n > 0 ) { int y = 0 ; while ( y < x ) { Console . Write ( ( ( 1 << x ) + ( 1 << y ) ) + " " ) ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } }
void printRepeatingEven ( int [ ] arr , int n ) { long _xor = 0L ; long pos ; for ( int i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; _xor ^= pos ; } for ( int i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; if ( ! ( ( pos & _xor ) != 0 ) ) { Console . Write ( arr [ i ] + " " ) ; _xor ^= pos ; } } }
int countSetBits ( int x ) { int count = 0 ; while ( x != 0 ) { x &= ( x - 1 ) ; count ++ ; } return count ; }
bool isBleak ( int n ) { for ( int x = 1 ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; }
void diameter ( Node root ) { if ( root == null ) return ; ans = Int32 . MinValue ; lh = 0 ; rh = 0 ; f = 0 ; int height_of_tree = height ( root ) ; int [ ] lPath = new int [ 100 ] ; int pathlen = 0 * height_of_tree ; printPathsRecur ( k . left , lPath , pathlen , lh ) ; Console . Write ( k . data + " " ) ; int [ ] rPath = new int [ 100 ] ; f = 1 ; printPathsRecur ( k . right , rPath , pathlen , rh ) ; }
int countSetBits ( int x ) { int count = 0 ; while ( x != 0 ) { x &= ( x - 1 ) ; count ++ ; } return count ; }
int ceilLog2 ( int x ) { int count = 0 ; x -- ; while ( x > 0 ) { x = x >> 1 ; count ++ ; } return count ; }
bool isBleak ( int n ) { for ( int x = n - ceilLog2 ( n ) ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; }
int countStrings ( int n ) { int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
int myXOR ( int x , int y ) { int res = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { int b1 = ( ( x & ( 1 << i ) ) == 0 ) ? 0 : 1 ; int b2 = ( ( y & ( 1 << i ) ) == 0 ) ? 0 : 1 ; int xoredBit = ( ( b1 & b2 ) != 0 ) ? 0 : ( b1 b2 ) ; res <<= 1 ; res |= xoredBit ; } return res ; }
int myXOR ( int x , int y ) { return ( x y ) & ( ~ x ~ y ) ; }
int myXOR ( int x , int y ) { return ( x & ( ~ y ) ) | ( ( ~ x ) & y ) ; }
int swapBits ( int n , int p1 , int p2 ) { n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; }
int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; }
int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; }
int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }
int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; }
double temp_convert ( int F1 , int B1 , int F2 , int B2 , int T ) { float t2 ; t2 = F2 + ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; }
int Divisible ( int [ ] arr , int n ) { int count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) count_even ++ ; return count_even + ( n - count_even ) / 2 ; }
int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
int maxLength ( int [ ] arr , int n ) { int maxLen = 0 ; int i = 0 ; int j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = Math . Max ( maxLen , 2 ) ; int l = i - 1 ; int r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = Math . Max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; }
int maxLength ( int [ ] a , int n ) { int maxLen = 0 ; int prev_cnt = 0 , curr_cnt = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) curr_cnt ++ ; else { prev_cnt = curr_cnt ; curr_cnt = 1 ; } maxLen = Math . Max ( maxLen , Math . Min ( prev_cnt , curr_cnt ) ) ; } return ( 2 * maxLen ) ; }
bool freivald ( int [ , ] a , int [ , ] b , int [ , ] c ) { Random rand = new Random ( ) ; int [ ] r = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) r [ i ] = ( int ) ( rand . Next ( ) ) % 2 ; int [ ] br = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) br [ i ] = br [ i ] + b [ i , j ] * r [ j ] ; int [ ] cr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) cr [ i ] = cr [ i ] + c [ i , j ] * r [ j ] ; int [ ] axbr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) axbr [ i ] = axbr [ i ] + a [ i , j ] * br [ j ] ; for ( int i = 0 ; i < N ; i ++ ) if ( axbr [ i ] - cr [ i ] != 0 ) return false ; return true ; }
bool isProduct ( int [ , ] a , int [ , ] b , int [ , ] c , int k ) { for ( int i = 0 ; i < k ; i ++ ) if ( freivald ( a , b , c ) == false ) return false ; return true ; }
int children ( Node root ) { if ( root == null ) return 0 ; return root . children + 1 ; }
int randomNodeUtil ( Node root , int count ) { if ( root == null ) return 0 ; if ( count == children ( root . left ) ) return root . data ; if ( count < children ( root . left ) ) return randomNodeUtil ( root . left , count ) ; return randomNodeUtil ( root . right , count - children ( root . left ) - 1 ) ; }
int randomNode ( Node root ) { int count = ( int ) new Random ( ) . Next ( 0 , root . children + 1 ) ; return randomNodeUtil ( root , count ) ; }
float calc_Expectation ( float [ ] a , float n ) { float prb = ( 1 / n ) ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] * prb ; return sum ; }
int findLargestd ( int [ ] S , int n ) { bool found = false ; Array . Sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return int . MaxValue ; return - 1 ; }
void recaman ( int n ) { int [ ] arr = new int [ n ] ; arr [ 0 ] = 0 ; Console . Write ( arr [ 0 ] + " ," ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; Console . Write ( arr [ i ] + ", " ) ; } }
int countPairs ( int [ ] arr , int n ) { HashSet < int > s = new HashSet < int > ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) s . Add ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . Contains ( sumOfDiv ( arr [ i ] ) ) ) { int sum = sumOfDiv ( arr [ i ] ) ; if ( isAmicable ( arr [ i ] , sum ) ) count ++ ; } } return count / 2 ; }
int findArea ( int [ ] arr , int n ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; int [ ] dimension = { 0 , 0 } ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
int findArea ( int [ ] arr , int n ) { ISet < int > s = new HashSet < int > ( ) ; int first = 0 , second = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . Contains ( arr [ i ] ) ) { s . Add ( arr [ i ] ) ; continue ; } if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { second = arr [ i ] ; } } return ( first * second ) ; }
void printAllPaths ( Node root ) { if ( root == null ) return ; List < PATH > Allpaths = new List < PATH > ( ) ; for ( int i = 0 ; i < MAX_PATH_SIZE ; i ++ ) { Allpaths . Add ( new PATH ( ) ) ; } printAllPathsUtil ( root , Allpaths , 0 , 0 ) ; }
int longLenStrictBitonicSub ( int [ ] arr , int n ) { Dictionary < int , int > inc = new Dictionary < int , int > ( ) ; Dictionary < int , int > dcr = new Dictionary < int , int > ( ) ; int [ ] len_inc = new int [ n ] ; int [ ] len_dcr = new int [ n ] ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( inc . ContainsKey ( arr [ i ] - 1 ) ) len = inc [ arr [ i ] - 1 ] ; len_inc [ i ] = len + 1 ; if ( inc . ContainsKey ( arr [ i ] ) ) { inc . Remove ( arr [ i ] ) ; inc . Add ( arr [ i ] , len_inc [ i ] ) ; } else inc . Add ( arr [ i ] , len_inc [ i ] ) ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { int len = 0 ; if ( dcr . ContainsKey ( arr [ i ] - 1 ) ) len = dcr [ arr [ i ] - 1 ] ; len_dcr [ i ] = len + 1 ; if ( dcr . ContainsKey ( arr [ i ] ) ) { dcr . Remove ( arr [ i ] ) ; dcr . Add ( arr [ i ] , len_dcr [ i ] ) ; } else dcr . Add ( arr [ i ] , len_dcr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1 ; return longLen ; }
void leftRotatebyOne ( int [ ] arr , int n ) { int i , temp = arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; }
void printArray ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
int search ( int [ ] arr , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
bool pairInSortedRotated ( int [ ] arr , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }
int pairsInSortedRotated ( int [ ] arr , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
int maxSum ( int [ ] arr , int n ) { int res = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . Max ( res , curr_sum ) ; } return res ; }
int maxSum ( int [ ] arr , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = Math . Max ( res , next_val ) ; } return res ; }
int countRotations ( int [ ] arr , int n ) { int min = arr [ 0 ] , min_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }
int countRotations ( int [ ] arr , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
void leftRotate ( int [ ] arr , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) Console . Write ( arr [ i % n ] + " " ) ; }
int findMin ( int [ ] arr , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
void reverseArray ( int [ ] arr , int start , int end ) { while ( start < end ) { int temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } }
void rightRotate ( int [ ] arr , int d , int n ) { reverseArray ( arr , 0 , n - 1 ) ; reverseArray ( arr , 0 , d - 1 ) ; reverseArray ( arr , d , n - 1 ) ; }
int maxHamming ( int [ ] arr , int n ) { int [ ] brr = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = Math . Max ( maxHam , currHam ) ; } return maxHam ; }
void rearrangeArr ( int [ ] arr , int n ) { int evenPos = n / 2 ; int oddPos = n - evenPos ; int [ ] tempArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) tempArr [ i ] = arr [ i ] ; Array . Sort ( tempArr ) ; int j = oddPos - 1 ; for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j -- ; } j = oddPos ; for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void pushZerosToEnd ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
void moveZerosToEnd ( int [ ] arr , int n ) { int count = 0 ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] != 0 ) ) { temp = arr [ count ] ; arr [ count ] = arr [ i ] ; arr [ i ] = temp ; count = count + 1 ; } } }
void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void pushZerosToEnd ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
void modifyAndRearrangeArr ( int [ ] arr , int n ) { if ( n == 1 ) return ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( arr [ i ] != 0 ) && ( arr [ i ] == arr [ i + 1 ] ) ) { arr [ i ] = 2 * arr [ i ] ; arr [ i + 1 ] = 0 ; i ++ ; } } pushZerosToEnd ( arr , n ) ; }
void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; Console . WriteLine ( ) ; }
void RearrangePosNeg ( int [ ] arr , int n ) { int key , j ; for ( int i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; if ( key > 0 ) continue ; j = i - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } }
virtual bool isLeaf ( Node node ) { if ( node == null ) { return false ; } if ( node . left == null && node . right == null ) { return true ; } return false ; }
virtual int leftLeavesSum ( Node node ) { int res = 0 ; if ( node != null ) { if ( isLeaf ( node . left ) ) { res += node . left . data ; } else { res += leftLeavesSum ( node . left ) ; } res += leftLeavesSum ( node . right ) ; } return res ; }
void reverse ( int [ ] arr , int l , int r ) { if ( l < r ) { arr = swap ( arr , l , r ) ; reverse ( arr , ++ l , -- r ) ; } }
void RearrangePosNeg ( int [ ] arr , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; RearrangePosNeg ( arr , l , m ) ; RearrangePosNeg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } }
void rearrangeNaive ( int [ ] arr , int n ) { int [ ] temp = new int [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) temp [ arr [ i ] ] = i ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
void printArray ( int [ ] arr , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } Console . WriteLine ( "" ) ; }
void rearrange ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ arr [ i ] % n ] += i * n ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] /= n ; } }
void rearrange ( int [ ] arr , int n ) { int max_idx = n - 1 , min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; }
void rearrange ( int [ ] arr , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }
virtual void leftLeavesSumRec ( Node node , bool isleft , Sum summ ) { if ( node == null ) { return ; } if ( node . left == null && node . right == null && isleft ) { summ . sum = summ . sum + node . data ; } leftLeavesSumRec ( node . left , true , summ ) ; leftLeavesSumRec ( node . right , false , summ ) ; }
virtual int leftLeavesSum ( Node node ) { Sum suum = new Sum ( ) ; leftLeavesSumRec ( node , false , suum ) ; return suum . sum ; }
void rearrange ( int [ ] arr , int n ) { int j = 0 , temp ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; j ++ ; } } }
void segregateElements ( int [ ] arr , int n ) { int [ ] temp = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
void rearrange ( int [ ] a , int size ) { int positive = 0 , negative = 1 , temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }
void printPostorder ( Node node ) { if ( node == null ) return ; printPostorder ( node . left ) ; printPostorder ( node . right ) ; Console . Write ( node . key + " " ) ; }
void printInorder ( Node node ) { if ( node == null ) return ; printInorder ( node . left ) ; Console . Write ( node . key + " " ) ; printInorder ( node . right ) ; }
void printPreorder ( Node node ) { if ( node == null ) return ; Console . Write ( node . key + " " ) ; printPreorder ( node . left ) ; printPreorder ( node . right ) ; }
int largest ( int [ ] arr , int n ) { return arr . Max ( ) ; }
void findElements ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) Console . Write ( arr [ i ] + " " ) ; } }
void findElements ( int [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void findElements ( int [ ] arr , int n ) { int first = int . MinValue ; int second = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) Console . Write ( arr [ i ] + " " ) ; }
double findMean ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return ( double ) sum / ( double ) n ; }
double findMedian ( int [ ] a , int n ) { Array . Sort ( a ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
int findSmallestMissinginSortedArray ( int [ ] arr ) { if ( arr [ 0 ] != 0 ) return 0 ; if ( arr [ arr . Length - 1 ] == arr . Length - 1 ) return arr . Length ; int first = arr [ 0 ] ; return findFirstMissing ( arr , 0 , arr . Length - 1 , first ) ; }
int findFirstMissing ( int [ ] arr , int start , int end , int first ) { if ( start < end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] != mid + first ) return findFirstMissing ( arr , start , mid , first ) ; else return findFirstMissing ( arr , mid + 1 , end , first ) ; } return start + first ; }
double sumNodes ( int l ) { double leafNodeCount = Math . Pow ( 2 , l - 1 ) ; double sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; double sum = sumLastLevel * l ; return sum ; }
void buildSparseTable ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) lookup [ i , 0 ] = arr [ i ] ; for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) { if ( lookup [ i , j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) , j - 1 ] ) lookup [ i , j ] = lookup [ i , j - 1 ] ; else lookup [ i , j ] = lookup [ i + ( 1 << ( j - 1 ) ) , j - 1 ] ; } } }
int query ( int L , int R ) { int j = ( int ) Math . Log ( R - L + 1 ) ; if ( lookup [ L , j ] <= lookup [ R - ( 1 << j ) + 1 , j ] ) return lookup [ L , j ] ; else return lookup [ R - ( 1 << j ) + 1 , j ] ; }
void add ( int [ ] arr , int N , int lo , int hi , int val ) { arr [ lo ] += val ; if ( hi != N - 1 ) arr [ hi + 1 ] -= val ; }
void updateArray ( int [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) arr [ i ] += arr [ i - 1 ] ; }
void FillPrefixSuffix ( int [ ] prefix , int [ ] arr , int [ ] suffix , int n ) { prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = GCD ( prefix [ i - 1 ] , arr [ i ] ) ; suffix [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix [ i ] = GCD ( suffix [ i + 1 ] , arr [ i ] ) ; }
int GCDoutsideRange ( int l , int r , int [ ] prefix , int [ ] suffix , int n ) { if ( l == 0 ) return suffix [ r + 1 ] ; if ( r == n - 1 ) return prefix [ l - 1 ] ; return GCD ( prefix [ l - 1 ] , suffix [ r + 1 ] ) ; }
int lowerIndex ( int [ ] arr , int n , int x ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] >= x ) h = mid - 1 ; else l = mid + 1 ; } return l ; }
int countInRange ( int [ ] arr , int n , int x , int y ) { int count = 0 ; count = upperIndex ( arr , n , y ) - lowerIndex ( arr , n , x ) + 1 ; return count ; }
void precompute ( int [ ] arr , int n , int [ ] pre ) { for ( int i = 0 ; i < n ; i ++ ) pre [ i ] = 0 ; pre [ n - 1 ] = arr [ n - 1 ] * ( int ) ( Math . Pow ( 2 , 0 ) ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) pre [ i ] = pre [ i + 1 ] + arr [ i ] * ( 1 << ( n - 1 - i ) ) ; }
int decimalOfSubarr ( int [ ] arr , int l , int r , int n , int [ ] pre ) { if ( r != n - 1 ) return ( pre [ l ] - pre [ r + 1 ] ) / ( 1 << ( n - 1 - r ) ) ; return pre [ l ] / ( 1 << ( n - 1 - r ) ) ; }
int answerQuery ( int [ ] a , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }
void addConsideringGrid ( Node root , int level , int index ) { if ( root == null ) return ; if ( grid . ContainsKey ( level - index ) ) grid [ level - index ] = grid [ level - index ] + ( root . data ) ; else grid . Add ( level - index , root . data ) ; addConsideringGrid ( root . left , level + 1 , index - 1 ) ; addConsideringGrid ( root . right , level + 1 , index + 1 ) ; }
List < int > diagonalSum ( Node root ) { grid . Clear ( ) ; addConsideringGrid ( root , 0 , 0 ) ; List < int > ans = new List < int > ( ) ; foreach ( KeyValuePair < int , int > x in grid ) { ans . Add ( x . Value ) ; } return ans ; }
void make_prefix ( int [ ] A , int n ) { for ( int j = 0 ; j < 32 ; j ++ ) one [ 0 , j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int a = A [ i - 1 ] ; for ( int j = 0 ; j < 32 ; j ++ ) { int x = ( int ) Math . Pow ( 2 , j ) ; if ( ( a & x ) != 0 ) one [ i , j ] = 1 + one [ i - 1 , j ] ; else one [ i , j ] = one [ i - 1 , j ] ; } } }
void type1 ( int [ ] arr , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) arr [ i ] ++ ; }
void type2 ( int [ ] arr , int [ , ] query , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) { if ( query [ i , 0 ] == 1 ) type1 ( arr , query [ i , 1 ] , query [ i , 2 ] ) ; else if ( query [ i , 0 ] == 2 ) type2 ( arr , query , query [ i , 1 ] , query [ i , 2 ] ) ; } }
void record_sum ( int [ ] record , int l , int r , int n , int adder ) { for ( int i = l ; i <= r ; i ++ ) { record [ i ] += adder ; } }
int solveQuery ( int start , int end , int [ ] arr ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = start ; i <= end ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) mp [ arr [ i ] ] ++ ; else mp . Add ( arr [ i ] , 1 ) ; } int count = 0 ; foreach ( KeyValuePair < int , int > entry in mp ) { if ( entry . Key == entry . Value ) count ++ ; } return count ; }
int answer_query ( int [ ] a , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }
void countIndex ( int [ ] a , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] == a [ i + 1 ] ) prefixans [ i ] = 1 ; if ( i != 0 ) prefixans [ i ] += prefixans [ i - 1 ] ; } }
int answer_query ( int l , int r ) { if ( l == 0 ) return prefixans [ r - 1 ] ; else return prefixans [ r - 1 ] - prefixans [ l - 1 ] ; }
void update ( int [ ] D , int l , int r , int x ) { D [ l ] += x ; D [ r + 1 ] -= x ; }
int maxSubArraySum ( int [ ] a , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . Max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . Max ( max_so_far , curr_max ) ; } return max_so_far ; }
int minJumps ( int [ ] arr , int n ) { int [ ] jumps = new int [ n ] ; int min ; jumps [ n - 1 ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) { jumps [ i ] = int . MaxValue ; } else if ( arr [ i ] >= n - i - 1 ) { jumps [ i ] = 1 ; } else { min = int . MaxValue ; for ( int j = i + 1 ; j < n && j <= arr [ i ] + i ; j ++ ) { if ( min > jumps [ j ] ) { min = jumps [ j ] ; } } if ( min != int . MaxValue ) { jumps [ i ] = min + 1 ; } else { jumps [ i ] = min ; } } } return jumps [ 0 ] ; }
int smallestSubWithSum ( int [ ] arr , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }
int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }
int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum ; int max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
int findMinOps ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 , j = n - 1 ; i <= j ; ) { if ( arr [ i ] == arr [ j ] ) { i ++ ; j -- ; } else if ( arr [ i ] > arr [ j ] ) { j -- ; arr [ j ] += arr [ j + 1 ] ; ans ++ ; } else { i ++ ; arr [ i ] += arr [ i - 1 ] ; ans ++ ; } } return ans ; }
int findSmallest ( int [ ] arr , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }
int maxSubArraySum ( int [ ] a , int size ) { int max_so_far = int . MinValue , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } return ( end - start + 1 ) ; }
int findMinDiff ( int [ ] arr , int n ) { int diff = int . MaxValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . Abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . Abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }
int findMinDiff ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int diff = int . MaxValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
bool checkbit ( int [ ] array , int index ) { int val = array [ index >> 5 ] & ( 1 << ( index & 31 ) ) ; if ( val == 0 ) return false ; return true ; }
void setbit ( int [ ] array , int index ) { array [ index >> 5 ] |= ( 1 << ( index & 31 ) ) ; }
void sortInWave ( int [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i += 2 ) swap ( arr , i , i + 1 ) ; }
void sortInWave ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i += 2 ) { if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( arr , i - 1 , i ) ; if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( arr , i , i + 1 ) ; } }
virtual void moveToEnd ( int [ ] mPlusN , int size ) { int i , j = size - 1 ; for ( i = size - 1 ; i >= 0 ; i -- ) { if ( mPlusN [ i ] != - 1 ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } } }
virtual void merge ( int [ ] mPlusN , int [ ] N , int m , int n ) { int i = n ; int j = 0 ; int k = 0 ; while ( k < ( m + n ) ) { if ( ( j == n ) ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; } else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } }
bool sortedAfterSwap ( int [ ] A , bool [ ] B , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) { j ++ ; } Array . Sort ( A , i , 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } } return true ; }
int sortedAfterSwap ( int [ ] A , int [ ] B , int n ) { int t = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] != 0 ) { if ( A [ i ] != i + 1 ) t = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = t ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return 0 ; } return 1 ; }
void segregate0and1 ( int [ ] arr , int n ) { int type0 = 0 ; int type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type0 ] = arr [ type0 ] + arr [ type1 ] ; arr [ type1 ] = arr [ type0 ] - arr [ type1 ] ; arr [ type0 ] = arr [ type0 ] - arr [ type1 ] ; type1 -- ; } else { type0 ++ ; } } }
bool increasing ( int [ ] a , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] >= a [ i + 1 ] ) return false ; return true ; }
bool decreasing ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] < arr [ i + 1 ] ) return false ; return true ; }
int shortestUnsorted ( int [ ] a , int n ) { if ( increasing ( a , n ) == true || decreasing ( a , n ) == true ) return 0 ; else return 3 ; }
int indexOf ( int [ ] arr , int ele ) { for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( arr [ i ] == ele ) { return i ; } } return - 1 ; }
int minSwaps ( int [ ] arr , int N ) { int ans = 0 ; int [ ] temp = new int [ N ] ; Array . Copy ( arr , temp , N ) ; Array . Sort ( temp ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != temp [ i ] ) { ans ++ ; swap ( arr , i , indexOf ( arr , temp [ i ] ) ) ; } } return ans ; }
void printUnion ( int [ ] arr1 , int [ ] arr2 , int m , int n ) { if ( m > n ) { int [ ] tempp = arr1 ; arr1 = arr2 ; arr2 = tempp ; int temp = m ; m = n ; n = temp ; } Array . Sort ( arr1 ) ; for ( int i = 0 ; i < m ; i ++ ) Console . Write ( arr1 [ i ] + " " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) == - 1 ) Console . Write ( arr2 [ i ] + " " ) ; } }
void printIntersection ( int [ ] arr1 , int [ ] arr2 , int m , int n ) { if ( m > n ) { int [ ] tempp = arr1 ; arr1 = arr2 ; arr2 = tempp ; int temp = m ; m = n ; n = temp ; } Array . Sort ( arr1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) != - 1 ) Console . Write ( arr2 [ i ] + " " ) ; } }
int binarySearch ( int [ ] arr , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
void intersection ( int [ ] a , int [ ] b , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( a [ i ] > b [ j ] ) { j ++ ; } else if ( b [ j ] > a [ i ] ) { i ++ ; } else { Console . Write ( a [ i ] + " " ) ; i ++ ; j ++ ; } } }
void sort012 ( int [ ] a , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 , temp = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : { temp = a [ lo ] ; a [ lo ] = a [ mid ] ; a [ mid ] = temp ; lo ++ ; mid ++ ; break ; } case 1 : mid ++ ; break ; case 2 : { temp = a [ mid ] ; a [ mid ] = a [ hi ] ; a [ hi ] = temp ; hi -- ; break ; } } } }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void sortArr ( int [ ] arr , int n ) { int i , cnt0 = 0 , cnt1 = 0 , cnt2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { switch ( arr [ i ] ) { case 0 : cnt0 ++ ; break ; case 1 : cnt1 ++ ; break ; case 2 : cnt2 ++ ; break ; } } i = 0 ; while ( cnt0 > 0 ) { arr [ i ++ ] = 0 ; cnt0 -- ; } while ( cnt1 > 0 ) { arr [ i ++ ] = 1 ; cnt1 -- ; } while ( cnt2 > 0 ) { arr [ i ++ ] = 2 ; cnt2 -- ; } printArr ( arr , n ) ; }
int countPairsWithDiffK ( int [ ] arr , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
int binarySearch ( int [ ] arr , int low , int high , int x ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( x == arr [ mid ] ) return mid ; if ( x > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; }
int countPairsWithDiffK ( int [ ] arr , int n , int k ) { int count = 0 , i ; Array . Sort ( arr ) ; / * remove duplicates from [ ] for ( i = 0 ; i < n - 1 ; i ++ ) if ( binarySearch ( arr , i + 1 , n - 1 , arr [ i ] + k ) != - 1 ) count ++ ; return count ; }
void constructArr ( int [ ] arr , int [ ] pair , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
int minMaxProduct ( int [ ] arr1 , int [ ] arr2 , int n1 , int n2 ) { int max = arr1 [ 0 ] ; int min = arr2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; if ( arr2 [ i ] < min ) min = arr2 [ i ] ; } while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) min = arr2 [ i ] ; i ++ ; } return max * min ; }
int findElement ( int [ ] arr , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }
int findPos ( int [ ] arr , int key ) { int l = 0 , h = 1 ; int val = arr [ 0 ] ; while ( val < key ) { l = h ; h = 2 * h ; val = arr [ h ] ; } return binarySearch ( arr , l , h , key ) ; }
int findSingle ( int [ ] ar , int ar_size ) { int res = ar [ 0 ] ; for ( int i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; }
bool isPresent ( int [ ] B , int m , int x ) { for ( int i = 0 ; i < m ; i ++ ) if ( B [ i ] == x ) return true ; return false ; }
int findMaxSubarraySumUtil ( int [ ] A , int [ ] B , int n , int m ) { int max_so_far = - 2147483648 , curr_max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPresent ( B , m , A [ i ] ) ) { curr_max = 0 ; continue ; } curr_max = Math . Max ( A [ i ] , curr_max + A [ i ] ) ; max_so_far = Math . Max ( max_so_far , curr_max ) ; } return max_so_far ; }
int findMaxSum ( int [ ] arr , int n ) { int res = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . Max ( res , prefix_sum ) ; } return res ; }
int getTotalHeight ( Node root ) { if ( root == null ) return 0 ; return getTotalHeight ( root . left ) + getHeight ( root ) + getTotalHeight ( root . right ) ; }
int findMaxSum ( int [ ] arr , int n ) { int [ ] preSum = new int [ n ] ; int [ ] suffSum = new int [ n ] ; int ans = int . MinValue ; preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . Max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . Max ( ans , preSum [ i ] ) ; } return ans ; }
int ceilSearch ( int [ ] arr , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
int ceilSearch ( int [ ] arr , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }
void findMajority ( int [ ] arr , int n ) { int maxCount = 0 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) Console . WriteLine ( arr [ index ] ) ; else Console . WriteLine ( "No Majority Element" ) ; }
int getTotalHeight ( Node root ) { sum = 0 ; getTotalHeightUtil ( root ) ; return sum ; }
int majorityElement ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int count = 1 , max_ele = - 1 , temp = arr [ 0 ] , ele = 0 , f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; } if ( max_ele < count ) { max_ele = count ; ele = arr [ i ] ; if ( max_ele > ( n / 2 ) ) { f = 1 ; break ; } } } return ( f == 1 ? ele : - 1 ) ; }
bool isMajority ( int [ ] arr , int n , int x ) { int i , last_index = 0 ; last_index = ( n % 2 == 0 ) ? n / 2 : n / 2 + 1 ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return true ; } return false ; }
int _binarySearch ( int [ ] arr , int low , int high , int x ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; }
bool isMajority ( int [ ] arr , int n , int x ) { int i = _binarySearch ( arr , 0 , n - 1 , x ) ; if ( i == - 1 ) return false ; if ( ( ( i + n / 2 ) <= ( n - 1 ) ) && arr [ i + n / 2 ] == x ) return true ; else return false ; }
bool isMajorityElement ( int [ ] arr , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; }
int findPeak ( int [ ] arr , int n ) { if ( n == 1 ) return 0 ; if ( arr [ 0 ] >= arr [ 1 ] ) return 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) return n - 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] && arr [ i ] >= arr [ i + 1 ] ) return i ; } return 0 ; }
int findPeak ( int [ ] arr , int n ) { return findPeakUtil ( arr , 0 , n - 1 , n ) ; }
void printRepeating ( int [ ] arr , int size ) { int i , j ; Console . Write ( "Repeated Elements are :" ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) Console . Write ( arr [ i ] + " " ) ; } } }
void printRepeating ( int [ ] arr , int size ) { int [ ] count = new int [ size ] ; int i ; Console . Write ( "Repeated elements are: " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) Console . Write ( arr [ i ] + " " ) ; else count [ arr [ i ] ] ++ ; } }
void printRepeating ( int [ ] arr , int size ) { int S = 0 ; int P = 1 ; int x , y ; int D ; int n = size - 2 , i ; for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; D = ( int ) Math . Sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; Console . WriteLine ( "The two" + " repeating elements are :" ) ; Console . Write ( x + " " + y ) ; }
int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; }
void printRepeating ( int [ ] arr , int size ) { int xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ; set_bit_no = ( xor & ~ ( xor - 1 ) ) ; for ( i = 0 ; i < size ; i ++ ) { int a = arr [ i ] & set_bit_no ; if ( a != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { int a = i & set_bit_no ; if ( a != 0 ) x = x ^ i ; else y = y ^ i ; } Console . WriteLine ( "The two" + " reppeated elements are :" ) ; Console . Write ( x + " " + y ) ; }
int linearSearch ( int [ ] arr , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
int subArraySum ( int [ ] arr , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { int p = j - 1 ; Console . Write ( "Sum found between " + "indexes " + i + " and " + p ) ; return 1 ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } Console . Write ( "No subarray found" ) ; return 0 ; }
int maxTripletSum ( int [ ] arr , int n ) { int sum = - 1000000 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
int maxTripletSum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }
int maxTripletSum ( int [ ] arr , int n ) { int maxA = - 100000000 , maxB = - 100000000 ; int maxC = - 100000000 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; }
int minimum ( int a , int b , int c ) { return Math . Min ( Math . Min ( a , b ) , c ) ; }
void smallestDifferenceTriplet ( int [ ] arr1 , int [ ] arr2 , int [ ] arr3 , int n ) { Array . Sort ( arr1 ) ; Array . Sort ( arr2 ) ; Array . Sort ( arr3 ) ; int res_min = 0 , res_max = 0 , res_mid = 0 ; int i = 0 , j = 0 , k = 0 ; int diff = 2147483647 ; while ( i < n && j < n && k < n ) { int sum = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] ; int max = maximum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; int min = minimum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; if ( min == arr1 [ i ] ) i ++ ; else if ( min == arr2 [ j ] ) j ++ ; else k ++ ; if ( diff > ( max - min ) ) { diff = max - min ; res_max = max ; res_mid = sum - ( max + min ) ; res_min = min ; } } Console . WriteLine ( res_max + ", " + res_mid + ", " + res_min ) ; }
bool find3Numbers ( int [ ] A , int arr_size , int sum ) { for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { Console . WriteLine ( "Triplet is " + A [ i ] + ", " + A [ j ] + ", " + A [ k ] ) ; return true ; } } } } return false ; }
bool find3Numbers ( int [ ] A , int arr_size , int sum ) { int l , r ; quickSort ( A , 0 , arr_size - 1 ) ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { l = i + 1 ; r = arr_size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { Console . Write ( "Triplet is " + A [ i ] + ", " + A [ l ] + ", " + A [ r ] ) ; return true ; } else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ; else r -- ; } } return false ; }
bool areConsecutive ( int [ ] arr , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { bool [ ] visited = new bool [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; }
bool areConsecutive ( int [ ] arr , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { int j ; if ( arr [ i ] < 0 ) j = - arr [ i ] - min ; else j = arr [ i ] - min ; if ( arr [ j ] > 0 ) arr [ j ] = - arr [ j ] ; else return false ; } return true ; } return false ; }
int getMax ( int [ ] arr , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }
void relativeComplement ( int [ ] arr1 , int [ ] arr2 , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) { Console . Write ( arr1 [ i ] + " " ) ; i ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) { j ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; j ++ ; } } while ( i < n ) Console . Write ( arr1 [ i ] + " " ) ; }
int minOps ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int max = arr [ arr . Length - 1 ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
void search ( int [ ] arr , int search_Element ) { int left = 0 ; int length = arr . Length ; int right = length - 1 ; int position = - 1 ; for ( left = 0 ; left <= right ; ) { if ( arr [ left ] == search_Element ) { position = left ; Console . WriteLine ( "Element found in Array at " + ( position + 1 ) + " Position with " + ( left + 1 ) + " Attempt" ) ; break ; } if ( arr [ right ] == search_Element ) { position = right ; Console . WriteLine ( "Element found in Array at " + ( position + 1 ) + " Position with " + ( length - right ) + " Attempt" ) ; break ; } left ++ ; right -- ; } if ( position == - 1 ) Console . WriteLine ( "Not found in Array with " + left + " Attempt" ) ; }
int binarySearch ( int [ ] arr , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
int exponentialSearch ( int [ ] arr , int n , int x ) { if ( arr [ 0 ] == x ) return 0 ; int i = 1 ; while ( i < n && arr [ i ] <= x ) i = i * 2 ; return binarySearch ( arr , i / 2 , Math . Min ( i , n - 1 ) , x ) ; }
int findCrossOver ( int [ ] arr , int low , int high , int x ) { if ( arr [ high ] <= x ) return high ; if ( arr [ low ] > x ) return low ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] <= x && arr [ mid + 1 ] > x ) return mid ; if ( arr [ mid ] < x ) return findCrossOver ( arr , mid + 1 , high , x ) ; return findCrossOver ( arr , low , mid - 1 , x ) ; }
void countSort ( int [ ] arr , int n , int exp ) { int [ ] output = new int [ n ] ; int [ ] count = new int [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) count [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) count [ ( arr [ i ] / exp ) % n ] ++ ; for ( i = 1 ; i < n ; i ++ ) count [ i ] += count [ i - 1 ] ; for ( i = n - 1 ; i >= 0 ; i -- ) { output [ count [ ( arr [ i ] / exp ) % n ] - 1 ] = arr [ i ] ; count [ ( arr [ i ] / exp ) % n ] -- ; } for ( i = 0 ; i < n ; i ++ ) arr [ i ] = output [ i ] ; }
void printClosest ( int [ ] ar1 , int [ ] ar2 , int m , int n , int x ) { int diff = int . MaxValue ; int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . Abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . Abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } Console . Write ( "The closest pair is [" + ar1 [ res_l ] + ", " + ar2 [ res_r ] + "]" ) ; }
int min ( int x , int y , int z ) { if ( x < y ) return ( ( x < z ) ? x : z ) ; else return ( ( y < z ) ? y : z ) ; }
int minCost ( int [ , ] cost , int m , int n ) { if ( n < 0 m < 0 ) return int . MaxValue ; else if ( m == 0 && n == 0 ) return cost [ m , n ] ; else return cost [ m , n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; }
int minCost ( int [ , ] cost , int m , int n ) { int i , j ; int [ , ] tc = new int [ m + 1 , n + 1 ] ; tc [ 0 , 0 ] = cost [ 0 , 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i , 0 ] = tc [ i - 1 , 0 ] + cost [ i , 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 , j ] = tc [ 0 , j - 1 ] + cost [ 0 , j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i , j ] = min ( tc [ i - 1 , j - 1 ] , tc [ i - 1 , j ] , tc [ i , j - 1 ] ) + cost [ i , j ] ; return tc [ m , n ] ; }
int matrixChainMemoised ( int [ ] p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i , j ] != - 1 ) { return dp [ i , j ] ; } dp [ i , j ] = Int32 . MaxValue ; for ( int k = i ; k < j ; k ++ ) { dp [ i , j ] = Math . Min ( dp [ i , j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i , j ] ; }
int MatrixChainOrder ( int [ ] p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; }
int MatrixChainOrder ( int [ ] p , int n ) { int [ , ] m = new int [ n , n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i , i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i , j ] = int . MaxValue ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i , k ] + m [ k + 1 , j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i , j ] ) m [ i , j ] = q ; } } } return m [ 1 , n - 1 ] ; }
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int knapSack ( int W , int [ ] wt , int [ ] val , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
int knapSack ( int W , int [ ] wt , int [ ] val , int n ) { int i , w ; int [ , ] K = new int [ n + 1 , W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i , w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i , w ] = Math . Max ( val [ i - 1 ] + K [ i - 1 , w - wt [ i - 1 ] ] , K [ i - 1 , w ] ) ; else K [ i , w ] = K [ i - 1 , w ] ; } } return K [ n , W ] ; }
int max ( int x , int y ) { return ( x > y ) ? x : y ; }
int lps ( char [ ] seq , int i , int j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return lps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; }
int cutRod ( int [ ] price , int n ) { if ( n <= 0 ) return 0 ; int max_val = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) max_val = Math . Max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) ; return max_val ; }
int cutRod ( int [ ] price , int n ) { int [ ] val = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = int . MinValue ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . Max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }
int minPalPartion ( string String , int i , int j ) { if ( i >= j || isPalindrome ( String , i , j ) ) return 0 ; int ans = Int32 . MaxValue , count ; for ( int k = i ; k < j ; k ++ ) { count = minPalPartion ( String , i , k ) + minPalPartion ( String , k + 1 , j ) + 1 ; ans = Math . Min ( ans , count ) ; } return ans ; }
int maxDivide ( int a , int b ) { while ( a % b == 0 ) a = a / b ; return a ; }
int getNthUglyNo ( int n ) { int i = 1 ; int count = 1 ; while ( n > count ) { i ++ ; if ( isUgly ( i ) == 1 ) count ++ ; } return i ; }
int optimalSearchTree ( int [ ] keys , int [ ] freq , int n ) { return optCost ( freq , 0 , n - 1 ) ; }
int sum ( int [ ] freq , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) { if ( k >= freq . Length ) continue ; s += freq [ k ] ; } return s ; }
int optimalSearchTree ( int [ ] keys , int [ ] freq , int n ) { int [ , ] cost = new int [ n + 1 , n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) cost [ i , i ] = freq [ i ] ; for ( int L = 2 ; L <= n ; L ++ ) { for ( int i = 0 ; i <= n - L + 1 ; i ++ ) { int j = i + L - 1 ; cost [ i , j ] = int . MaxValue ; for ( int r = i ; r <= j ; r ++ ) { int c = ( ( r > i ) ? cost [ i , r - 1 ] : 0 ) + ( ( r < j ) ? cost [ r + 1 , j ] : 0 ) + sum ( freq , i , j ) ; if ( c < cost [ i , j ] ) cost [ i , j ] = c ; } } } return cost [ 0 , n - 1 ] ; }
bool isSubsetSum ( int [ ] set , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
int countParenth ( char [ ] symb , char [ ] oper , int n ) { int [ , ] F = new int [ n , n ] ; int [ , ] T = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) { F [ i , i ] = ( symb [ i ] == 'F' ) ? 1 : 0 ; T [ i , i ] = ( symb [ i ] == 'T' ) ? 1 : 0 ; } for ( int gap = 1 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { T [ i , j ] = F [ i , j ] = 0 ; for ( int g = 0 ; g < gap ; g ++ ) { int k = i + g ; int tik = T [ i , k ] + F [ i , k ] ; int tkj = T [ k + 1 , j ] + F [ k + 1 , j ] ; if ( oper [ k ] == '&' ) { T [ i , j ] += T [ i , k ] * T [ k + 1 , j ] ; F [ i , j ] += ( tik * tkj - T [ i , k ] * T [ k + 1 , j ] ) ; } if ( oper [ k ] == ' ' ) { F [ i , j ] += F [ i , k ] * F [ k + 1 , j ] ; T [ i , j ] += ( tik * tkj - F [ i , k ] * F [ k + 1 , j ] ) ; } if ( oper [ k ] == '^' ) { T [ i , j ] += F [ i , k ] * T [ k + 1 , j ] + T [ i , k ] * F [ k + 1 , j ] ; F [ i , j ] += T [ i , k ] * T [ k + 1 , j ] + F [ i , k ] * F [ k + 1 , j ] ; } } } } return T [ 0 , n - 1 ] ; }
int getCount ( char [ , ] keypad , int n ) { if ( keypad == null n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int [ ] row = { 0 , 0 , - 1 , 0 , 1 } ; int [ ] col = { 0 , - 1 , 0 , 1 , 0 } ; int [ , ] count = new int [ 10 , n + 1 ] ; int i = 0 , j = 0 , k = 0 , move = 0 , ro = 0 , co = 0 , num = 0 ; int nextNum = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) { count [ i , 0 ] = 0 ; count [ i , 1 ] = 1 ; } for ( k = 2 ; k <= n ; k ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { if ( keypad [ i , j ] != '*' && keypad [ i , j ] != '#' ) { num = keypad [ i , j ] - '0' ; count [ num , k ] = 0 ; for ( move = 0 ; move < 5 ; move ++ ) { ro = i + row [ move ] ; co = j + col [ move ] ; if ( ro >= 0 && ro <= 3 && co >= 0 && co <= 2 && keypad [ ro , co ] != '*' && keypad [ ro , co ] != '#' ) { nextNum = keypad [ ro , co ] - '0' ; count [ num , k ] += count [ nextNum , k - 1 ] ; } } } } } } totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) totalCount += count [ i , n ] ; return totalCount ; }
int getCount ( char [ , ] keypad , int n ) { if ( keypad == null n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int [ ] odd = new int [ 10 ] ; int [ ] even = new int [ 10 ] ; int i = 0 , j = 0 , useOdd = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) odd [ i ] = 1 ; for ( j = 2 ; j <= n ; j ++ ) { useOdd = 1 - useOdd ; if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } totalCount = 0 ; if ( useOdd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += odd [ i ] ; } return totalCount ; }
int finalCount ( int n , int sum ) { int ans = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; }
int finalCount ( int n , int sum ) { for ( int i = 0 ; i <= 100 ; ++ i ) { for ( int j = 0 ; j <= 500 ; ++ j ) { lookup [ i , j ] = - 1 ; } } int ans = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; }
void findCount ( int n , int sum ) { int start = ( int ) Math . Pow ( 10 , n - 1 ) ; int end = ( int ) Math . Pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i < end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } Console . WriteLine ( count ) ; }
int countNonDecreasing ( int n ) { int [ , ] dp = new int [ 10 , n + 1 ] ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i , 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit , len ] += dp [ x , len - 1 ] ; } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i , n ] ; return count ; }
long countNonDecreasing ( int n ) { int N = 10 ; long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; }
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . Min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= Math . Ceiling ( Math . Sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . Min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; return res ; }
int minCoins ( int [ ] coins , int m , int V ) { int [ ] table = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = int . MaxValue ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != int . MaxValue && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } return table [ V ] ; }
int superSeq ( String X , String Y , int m , int n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . Min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
int superSeq ( String X , String Y , int m , int n ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i , j ] = j ; else if ( j == 0 ) dp [ i , j ] = i ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i , j ] = 1 + dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = 1 + Math . Min ( dp [ i - 1 , j ] , dp [ i , j - 1 ] ) ; } } return dp [ m , n ] ; }
int sumOfDigitsFrom1ToN ( int n ) { int result = 0 ; for ( int x = 1 ; x <= n ; x ++ ) result += sumOfDigits ( x ) ; return result ; }
int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; }
int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . Log ( n ) / Math . Log ( 10 ) ) ; int [ ] a = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . Ceiling ( Math . Pow ( 10 , i - 1 ) ) ) ; int p = ( int ) ( Math . Ceiling ( Math . Pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; }
int sumOfDigitsFrom1ToN ( int n ) { int d = ( int ) ( Math . Log10 ( n ) ) ; int [ ] a = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . Ceiling ( Math . Pow ( 10 , i - 1 ) ) ) ; return sumOfDigitsFrom1ToNUtil ( n , a ) ; }
int countWays ( int N ) { if ( N == 1 ) return 4 ; int countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } int result = countS + countB ; return ( result * result ) ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int [ ] screen = new int [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }
int count ( int n ) { int [ ] table = new int [ n + 1 ] ; for ( int j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( int i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( int i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
int getMedian ( int [ ] ar1 , int [ ] ar2 , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = - 1 , m2 = - 1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] <= ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; }
double area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return Math . Abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; }
bool isInside ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x , int y ) { double A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) ; double A1 = area ( x , y , x2 , y2 , x3 , y3 ) ; double A2 = area ( x1 , y1 , x , y , x3 , y3 ) ; double A3 = area ( x1 , y1 , x2 , y2 , x , y ) ; return ( A == A1 + A2 + A3 ) ; }
bool isLucky ( int n ) { int next_position = n ; if ( counter > n ) return true ; if ( n % counter == 0 ) return false ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; }
float squareRoot ( float n ) { float x = n ; float y = 1 ; double e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
virtual int maxDiffUtil ( Node t , Res res ) { if ( t == null ) { return int . MaxValue ; } if ( t . left == null && t . right == null ) { return t . key ; } int val = Math . Min ( maxDiffUtil ( t . left , res ) , maxDiffUtil ( t . right , res ) ) ; res . r = Math . Max ( res . r , t . key - val ) ; return Math . Min ( val , t . key ) ; }
virtual int maxDiff ( Node root ) { Res res = new Res ( ) ; maxDiffUtil ( root , res ) ; return res . r ; }
virtual void inorder ( Node root ) { if ( root != null ) { inorder ( root . left ) ; Console . Write ( root . key + "" ) ; inorder ( root . right ) ; } }
int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
int multiply ( int x , int y ) { if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; }
int pow ( int a , int b ) { if ( b > 0 ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; }
float getAvg ( float prev_avg , float x , int n ) { return ( prev_avg * n + x ) / ( n + 1 ) ; }
int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; }
int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; }
int findSmallerInRight ( string str , int low , int high ) { int countRight = 0 , i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str [ i ] < str [ low ] ) ++ countRight ; return countRight ; }
int findRank ( string str ) { int len = str . Length ; int mul = fact ( len ) ; int rank = 1 ; int countRight ; for ( int i = 0 ; i < len ; ++ i ) { mul /= len - i ; countRight = findSmallerInRight ( str , i , len - 1 ) ; rank += countRight * mul ; } return rank ; }
void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { Console . Write ( C + " " ) ; C = C * ( line - i ) / i ; } Console . Write ( "\n" ) ; } }
float exponential ( int n , float x ) { float sum = 1 ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
void printCombination ( int [ ] arr , int n , int r ) { int [ ] data = new int [ r ] ; combinationUtil ( arr , n , r , 0 , data , 0 ) ; }
int myRand ( int [ ] arr , int [ ] freq , int n ) { int [ ] prefix = new int [ n ] ; int i ; prefix [ 0 ] = freq [ 0 ] ; for ( i = 1 ; i < n ; ++ i ) prefix [ i ] = prefix [ i - 1 ] + freq [ i ] ; Random rand = new Random ( ) ; int r = ( ( int ) ( rand . Next ( ) * ( 323567 ) ) % prefix [ n - 1 ] ) + 1 ; int indexc = findCeil ( prefix , r , 0 , n - 1 ) ; return arr [ indexc ] ; }
bool isPerfectSquare ( int x ) { int s = ( int ) Math . Sqrt ( x ) ; return ( s * s == x ) ; }
bool isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
int findgroups ( int [ ] arr , int n ) { int [ ] c = new int [ ] { 0 , 0 , 0 } ; int i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; }
int catalan ( int n ) { if ( n <= 1 ) { return 1 ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += catalan ( i ) * catalan ( n - i - 1 ) ; } return res ; }
long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
void catalan ( int n ) { int cat_ = 1 ; Console . Write ( cat_ + " " ) ; for ( int i = 1 ; i < n ; i ++ ) { cat_ *= ( 4 * i - 2 ) ; cat_ /= ( i + 1 ) ; Console . Write ( cat_ + " " ) ; } }
int calcAngle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) Console . Write ( "Wrong input" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; } int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ; int minute_angle = ( int ) ( 6 * m ) ; int angle = Math . Abs ( hour_angle - minute_angle ) ; angle = Math . Min ( 360 - angle , angle ) ; return angle ; }
int getInvCount ( int [ , ] arr ) { int inv_count = 0 ; for ( int i = 0 ; i < 3 - 1 ; i ++ ) for ( int j = i + 1 ; j < 3 ; j ++ ) if ( arr [ j , i ] > 0 && arr [ j , i ] > arr [ i , j ] ) inv_count ++ ; return inv_count ; }
bool isSolvable ( int [ , ] puzzle ) { int invCount = getInvCount ( puzzle ) ; return ( invCount % 2 == 0 ) ; }
double find ( double p ) { return Math . Ceiling ( Math . Sqrt ( 2 * 365 * Math . Log ( 1 / ( 1 - p ) ) ) ) ; }
int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; }
int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }
double func ( double x ) { return ( x * x * x - x * x + 2 ) ; }
void regulaFalsi ( double a , double b ) { if ( func ( a ) * func ( b ) >= 0 ) { Console . WriteLine ( "You have not assumed right a and b" ) ; } double c = a ; for ( int i = 0 ; i < MAX_ITER ; i ++ ) { c = ( a * func ( b ) - b * func ( a ) ) / ( func ( b ) - func ( a ) ) ; if ( func ( c ) == 0 ) break ; else if ( func ( c ) * func ( a ) < 0 ) b = c ; else a = c ; } Console . WriteLine ( "The value of root is : " + ( int ) c ) ; }
double func ( double x ) { return x * x * x - x * x + 2 ; }
double derivFunc ( double x ) { return 3 * x * x - 2 * x ; }
void newtonRaphson ( double x ) { double h = func ( x ) / derivFunc ( x ) ; while ( Math . Abs ( h ) >= EPSILON ) { h = func ( x ) / derivFunc ( x ) ; x = x - h ; } Console . Write ( "The value of the" + " root is : " + Math . Round ( x * 100.0 ) / 100.0 ) ; }
int getSingle ( int [ ] arr , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
bool oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }
int countSetBits ( int n ) { int bitCount = 0 ; for ( int i = 1 ; i <= n ; i ++ ) bitCount += countSetBitsUtil ( i ) ; return bitCount ; }
int countSetBitsUtil ( int x ) { if ( x <= 0 ) return 0 ; return ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( x / 2 ) ; }
int swapBits ( int num , int p1 , int p2 , int n ) { int shift1 , shift2 , value1 , value2 ; while ( n -- > 0 ) { shift1 = 1 << p1 ; shift2 = 1 << p2 ; value1 = ( ( num & shift1 ) ) ; value2 = ( ( num & shift2 ) ) ; if ( ( value1 == 0 && value2 != 0 ) || ( value2 == 0 && value1 != 0 ) ) { if ( value1 != 0 ) { num = num & ( ~ shift1 ) ; num = num | shift2 ; } else { num = num & ( ~ shift2 ) ; num = num | shift1 ; } } p1 ++ ; p2 ++ ; } return num ; }
int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
int smallest ( int x , int y , int z ) { int c = 0 ; while ( x != 0 && y != 0 && z != 0 ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }
int min ( int x , int y ) { return y + ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHAR_BIT - 1 ) ) ) ; }
int smallest ( int x , int y , int z ) { return Math . Min ( x , Math . Min ( y , z ) ) ; }
int snoob ( int x ) { int rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ; if ( x > 0 ) { rightOne = x & - x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) == 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
int addOne ( int x ) { return ( - ( ~ x ) ) ; }
int fun ( int n ) { return n & ( n - 1 ) ; }
int isPowerOfFour ( int n ) { int count = 0 ; int x = n & ( n - 1 ) ; if ( n > 0 && x == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
bool isPowerOfFour ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ( n & 0xAAAAAAAA ) == 0 ; }
double logn ( int n , int r ) { return Math . Log ( n ) / Math . Log ( r ) ; }
void findPostOrderUtil ( int [ ] pre , int n , int minval , int maxval , INT preIndex ) { if ( preIndex . data == n ) { return ; } if ( pre [ preIndex . data ] < minval pre [ preIndex . data ] > maxval ) { return ; } int val = pre [ preIndex . data ] ; preIndex . data ++ ; findPostOrderUtil ( pre , n , minval , val , preIndex ) ; findPostOrderUtil ( pre , n , val , maxval , preIndex ) ; Console . Write ( val + " " ) ; }
void findPostOrder ( int [ ] pre , int n ) { INT preIndex = new INT ( 0 ) ; findPostOrderUtil ( pre , n , int . MinValue , int . MaxValue , preIndex ) ; }
uint getModulo ( uint n , uint d ) { return ( n & ( d - 1 ) ) ; }
int min ( int x , int y ) { return y ^ ( ( x ^ y ) & - ( x << y ) ) ; }
int max ( int x , int y ) { return x ^ ( ( x ^ y ) & - ( x << y ) ) ; }
int absbit32 ( int x , int y ) { int sub = x - y ; int mask = ( sub >> 31 ) ; return ( sub ^ mask ) - mask ; }
int max ( int x , int y ) { int abs = absbit32 ( x , y ) ; return ( x + y + abs ) / 2 ; }
int min ( int x , int y ) { int abs = absbit32 ( x , y ) ; return ( x + y - abs ) / 2 ; }
int getOddOccurrence ( int [ ] arr , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
int getOddOccurrence ( int [ ] arr , int n ) { Dictionary < int , int > hmap = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hmap . ContainsKey ( arr [ i ] ) ) { int val = hmap [ arr [ i ] ] ; hmap . Remove ( arr [ i ] ) ; hmap . Add ( arr [ i ] , val + 1 ) ; } else hmap . Add ( arr [ i ] , 1 ) ; } foreach ( KeyValuePair < int , int > entry in hmap ) { if ( entry . Value % 2 != 0 ) { return entry . Key ; } } return - 1 ; }
int countWays ( int N , int K ) { return K * fastPow ( K - 1 , N - 1 ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
void initialize ( ) { BitsSetTable256 [ 0 ] = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i / 2 ] ; } }
int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < 4 * 8 ; i ++ ) { if ( ( N & ( 1 << i ) ) != 0 ) count ++ ; } return count ; }
int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { count ++ ; n &= ( n - 1 ) ; } return count ; }
int FlippedCount ( int a , int b ) { return countSetBits ( a ^ b ) ; }
int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }
int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }
bool getParity ( int n ) { bool parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
bool isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; }
bool isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
int getFirstSetBitPos ( int n ) { return ( int ) ( ( Math . Log10 ( n & - n ) ) / Math . Log10 ( 2 ) ) + 1 ; }
int Right_most_setbit ( int num ) { int pos = 1 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { if ( ( num & ( 1 << i ) ) == 0 ) pos ++ ; else break ; } return pos ; }
void bin ( long n ) { long i ; Console . Write ( "0" ) ; for ( i = 1 << 30 ; i > 0 ; i = i / 2 ) { if ( ( n & i ) != 0 ) { Console . Write ( "1" ) ; } else { Console . Write ( "0" ) ; } } }
int findPosition ( int n ) { if ( ! isPowerOfTwo ( n ) ) return - 1 ; int i = 1 , pos = 1 ; while ( ( i & n ) == 0 ) { i = i << 1 ; ++ pos ; } return pos ; }
bool isPowerOfTwo ( int n ) { return n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ; }
int findPosition ( int n ) { if ( ! isPowerOfTwo ( n ) ) return - 1 ; int count = 0 ; while ( n > 0 ) { n = n >> 1 ; ++ count ; } return count ; }
void swap ( int [ ] xp , int [ ] yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }
void swap ( int a , int b ) { a = ( a & b ) + ( a b ) ; b = a + ( ~ b ) + 1 ; a = a + ( ~ b ) + 1 ; Console . Write ( "After swapping: a = " + a + ", b = " + b ) ; }
bool checkSentence ( char [ ] str ) { int len = str . Length ; if ( str [ 0 ] < 'A' str [ 0 ] > 'Z' ) return false ; if ( str [ len - 1 ] != '.' ) return false ; int prev_state = 0 , curr_state = 0 ; int index = 1 ; while ( index <= str . Length ) { if ( str [ index ] >= 'A' && str [ index ] <= 'Z' ) curr_state = 0 ; else if ( str [ index ] == ' ' ) curr_state = 1 ; else if ( str [ index ] >= 'a' && str [ index ] <= 'z' ) curr_state = 2 ; else if ( str [ index ] == '.' ) curr_state = 3 ; if ( prev_state == curr_state && curr_state != 2 ) return false ; if ( prev_state == 2 && curr_state == 0 ) return false ; if ( curr_state == 3 && prev_state != 1 ) return ( index + 1 == str . Length ) ; index ++ ; prev_state = curr_state ; } return false ; }
int maxOnesIndex ( int [ ] arr , int n ) { int max_count = 0 ; int max_index = 0 ; int prev_zero = - 1 ; int prev_prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }
int findLength ( int [ ] arr , int n ) { int max_len = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int mn = arr [ i ] , mx = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { mn = Math . Min ( mn , arr [ j ] ) ; mx = Math . Max ( mx , arr [ j ] ) ; if ( ( mx - mn ) == j - i ) max_len = Math . Max ( max_len , mx - mn + 1 ) ; } } return max_len ; }
bool isSubSequence ( string str1 , string str2 , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
void segregate0and1 ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count ++ ; } for ( int i = 0 ; i < count ; i ++ ) arr [ i ] = 0 ; for ( int i = count ; i < n ; i ++ ) arr [ i ] = 1 ; }
void find3Numbers ( int [ ] nums ) { if ( nums . Length < 3 ) { Console . Write ( "No such triplet found" ) ; return ; } int seq = 1 ; int min_num = nums [ 0 ] ; int max_seq = Int32 . MinValue ; int store_min = min_num ; for ( int i = 1 ; i < nums . Length ; i ++ ) { if ( nums [ i ] == min_num ) continue ; else if ( nums [ i ] < min_num ) { min_num = nums [ i ] ; continue ; } else if ( nums [ i ] < max_seq ) { max_seq = nums [ i ] ; store_min = min_num ; } else if ( nums [ i ] > max_seq ) { seq ++ ; if ( seq == 3 ) { Console . WriteLine ( "Triplet: " + store_min + ", " + max_seq + ", " + nums [ i ] ) ; return ; } max_seq = nums [ i ] ; } } Console . Write ( "No such triplet found" ) ; }
int maxCircularSum ( int [ ] a , int n ) { if ( n == 1 ) return a [ 0 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int curr_max = a [ 0 ] , max_so_far = a [ 0 ] , curr_min = a [ 0 ] , min_so_far = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { curr_max = Math . Max ( curr_max + a [ i ] , a [ i ] ) ; max_so_far = Math . Max ( max_so_far , curr_max ) ; curr_min = Math . Min ( curr_min + a [ i ] , a [ i ] ) ; min_so_far = Math . Min ( min_so_far , curr_min ) ; } if ( min_so_far == sum ) { return max_so_far ; } return Math . Max ( max_so_far , sum - min_so_far ) ; }
int GetCeilIndex ( int [ ] arr , int [ ] T , int l , int r , int key ) { while ( r - l > 1 ) { int m = l + ( r - l ) / 2 ; if ( arr [ T [ m ] ] >= key ) r = m ; else l = m ; } return r ; }
virtual void generateUtil ( int [ ] A , int [ ] B , int [ ] C , int i , int j , int m , int n , int len , bool flag ) { if ( flag ) { if ( len != 0 ) { printArr ( C , len + 1 ) ; } for ( int k = i ; k < m ; k ++ ) { if ( len == 0 ) { C [ len ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len , ! flag ) ; } else if ( A [ k ] > C [ len ] ) { C [ len + 1 ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len + 1 , ! flag ) ; } } } else { for ( int l = j ; l < n ; l ++ ) { if ( B [ l ] > C [ len ] ) { C [ len + 1 ] = B [ l ] ; generateUtil ( A , B , C , i , l + 1 , m , n , len + 1 , ! flag ) ; } } } }
virtual void generate ( int [ ] A , int [ ] B , int m , int n ) { int [ ] C = new int [ m + n ] ; generateUtil ( A , B , C , 0 , 0 , m , n , 0 , true ) ; }
virtual void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } Console . WriteLine ( "" ) ; }
void replace_elements ( int [ ] arr , int n ) { int pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( int i = 0 ; i < pos ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void arrangeString ( string str , int x , int y ) { int count_0 = 0 ; int count_1 = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 count_1 > 0 ) { for ( int j = 0 ; j < x && count_0 > 0 ; j ++ ) { if ( count_0 > 0 ) { Console . Write ( "0" ) ; count_0 -- ; } } for ( int j = 0 ; j < y && count_1 > 0 ; j ++ ) { if ( count_1 > 0 ) { Console . Write ( "1" ) ; count_1 -- ; } } } }
int maxDiff ( int [ ] arr , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; int i , j ; for ( i = 0 ; i < arr_size ; i ++ ) { for ( j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; }
int maxDiff ( int [ ] arr , int n ) { int maxDiff = - 1 ; int maxRight = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { int diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; }
int maxDiff ( int [ ] arr , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }
int maxIndexDiff ( int [ ] arr , int n ) { int maxDiff = - 1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; }
int findMaximum ( int [ ] arr , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }
int findMaximum ( int [ ] arr , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; }
void constructLowerArray ( int [ ] arr , int [ ] countSmaller , int n ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) countSmaller [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < arr [ i ] ) countSmaller [ i ] ++ ; } } }
void printArray ( int [ ] arr , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) Console . Write ( arr [ i ] + " " ) ; Console . WriteLine ( "" ) ; }
int findMissingPositive ( int [ ] arr , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { if ( Math . Abs ( arr [ i ] ) - 1 < size && arr [ Math . Abs ( arr [ i ] ) - 1 ] > 0 ) arr [ Math . Abs ( arr [ i ] ) - 1 ] = - arr [ Math . Abs ( arr [ i ] ) - 1 ] ; } for ( i = 0 ; i < size ; i ++ ) if ( arr [ i ] > 0 ) return i + 1 ; return size + 1 ; }
int findMissing ( int [ ] arr , int size ) { int shift = segregate ( arr , size ) ; int [ ] arr2 = new int [ size - shift ] ; int j = 0 ; for ( int i = shift ; i < size ; i ++ ) { arr2 [ j ] = arr [ i ] ; j ++ ; } return findMissingPositive ( arr2 , j ) ; }
virtual void fillDepth ( int [ ] parent , int i , int [ ] depth ) { if ( depth [ i ] != 0 ) { return ; } if ( parent [ i ] == - 1 ) { depth [ i ] = 1 ; return ; } if ( depth [ parent [ i ] ] == 0 ) { fillDepth ( parent , parent [ i ] , depth ) ; } depth [ i ] = depth [ parent [ i ] ] + 1 ; }
int maxRepeating ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ ( arr [ i ] % k ) ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }
int maxPathSum ( int [ ] ar1 , int [ ] ar2 , int m , int n ) { int i = 0 , j = 0 ; int result = 0 , sum1 = 0 , sum2 = 0 ; while ( i < m && j < n ) { if ( ar1 [ i ] < ar2 [ j ] ) sum1 += ar1 [ i ++ ] ; else if ( ar1 [ i ] > ar2 [ j ] ) sum2 += ar2 [ j ++ ] ; else { result += max ( sum1 , sum2 ) + ar1 [ i ] ; sum1 = 0 ; sum2 = 0 ; i ++ ; j ++ ; } } while ( i < m ) sum1 += ar1 [ i ++ ] ; while ( j < n ) sum2 += ar2 [ j ++ ] ; result += max ( sum1 , sum2 ) ; return result ; }
void smallestGreater ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int diff = int . MaxValue ; int closest = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } if ( closest == - 1 ) Console . Write ( "_ " ) ; else Console . Write ( arr [ closest ] + " " ) ; } }
void smallestGreater ( int [ ] arr , int n ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . Add ( arr [ i ] ) ; } int [ ] newAr = new int [ s . Count ] ; int j = 0 ; foreach ( int p in s ) { newAr [ j ] = p ; j ++ ; } Array . Sort ( newAr ) ; for ( int i = 0 ; i < n ; i ++ ) { int temp = lowerBound ( newAr , 0 , newAr . GetLength ( 0 ) , arr [ i ] ) ; if ( temp < n ) Console . Write ( newAr [ temp ] + " " ) ; else Console . Write ( "_ " ) ; } }
long arraySum ( int [ ] arr , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum ; }
long maxDiff ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; long arraysum = arraySum ( arr , n ) ; long diff1 = Math . Abs ( arraysum - 2 * arraySum ( arr , k ) ) ; Array . Reverse ( arr ) ; long diff2 = Math . Abs ( arraysum - 2 * arraySum ( arr , k ) ) ; return ( Math . Max ( diff1 , diff2 ) ) ; }
int minNumber ( int [ ] a , int n , int x ) { Array . Sort ( a ) ; int k ; for ( k = 0 ; a [ ( n ) / 2 ] != x ; k ++ ) { a [ n ++ ] = x ; Array . Sort ( a ) ; } return k ; }
int minNumber ( int [ ] a , int n , int x ) { int l = 0 , h = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } int ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; }
int fun ( int x ) { int y = ( x / 4 ) * 4 ; int ans = 0 ; for ( int i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; }
int query ( int x ) { if ( x == 0 ) return 0 ; int k = ( x + 1 ) / 2 ; return ( ( x %= 2 ) != 0 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; }
void preprocess ( int [ ] arr , int N , int [ ] left , int [ ] right ) { left [ 0 ] = 0 ; int lastIncr = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) lastIncr = i ; left [ i ] = lastIncr ; } right [ N - 1 ] = N - 1 ; int firstDecr = N - 1 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > arr [ i + 1 ] ) firstDecr = i ; right [ i ] = firstDecr ; } }
bool isSubarrayMountainForm ( int [ ] arr , int [ ] left , int [ ] right , int L , int R ) { return ( right [ L ] >= left [ R ] ) ; }
void sieveOfEratosthenes ( bool [ ] isPrime ) { isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } }
int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; }
int queryPrimesUtil ( int [ ] st , int ss , int se , int qs , int qe , int index ) { if ( qs <= ss && qe >= se ) return st [ index ] ; if ( se < qs ss > qe ) return 0 ; int mid = getMid ( ss , se ) ; return queryPrimesUtil ( st , ss , mid , qs , qe , 2 * index + 1 ) + queryPrimesUtil ( st , mid + 1 , se , qs , qe , 2 * index + 2 ) ; }
void updateValueUtil ( int [ ] st , int ss , int se , int i , int diff , int si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } }
void updateValue ( int [ ] arr , int [ ] st , int n , int i , int new_val , bool [ ] isPrime ) { if ( i < 0 i > n - 1 ) { Console . WriteLine ( "Invalid Input" ) ; return ; } int diff = 0 ; int oldValue ; oldValue = arr [ i ] ; arr [ i ] = new_val ; if ( isPrime [ oldValue ] && isPrime [ new_val ] ) return ; if ( ( ! isPrime [ oldValue ] ) && ( ! isPrime [ new_val ] ) ) return ; if ( isPrime [ oldValue ] && ! isPrime [ new_val ] ) { diff = - 1 ; } if ( ! isPrime [ oldValue ] && isPrime [ new_val ] ) { diff = 1 ; } updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; }
int constructSTUtil ( int [ ] arr , int ss , int se , int [ ] st , int si , bool [ ] isPrime ) { if ( ss == se ) { if ( isPrime [ arr [ ss ] ] ) st [ si ] = 1 ; else st [ si ] = 0 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 , isPrime ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 , isPrime ) ; return st [ si ] ; }
void checkEVENodd ( int [ ] arr , int n , int l , int r ) { if ( arr [ r ] == 1 ) Console . WriteLine ( "odd" ) ; else Console . WriteLine ( "even" ) ; }
int findMean ( int [ ] arr , int l , int r ) { int sum = 0 , count = 0 ; for ( int i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } int mean = ( int ) Math . Floor ( ( double ) sum / count ) ; return mean ; }
void calculatePrefixSum ( int [ ] arr , int n ) { prefixSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ; }
int findMean ( int l , int r ) { if ( l == 0 ) return ( int ) Math . Floor ( ( double ) ( prefixSum [ r ] / ( r + 1 ) ) ) ; return ( int ) Math . Floor ( ( double ) ( prefixSum [ r ] - prefixSum [ l - 1 ] ) / ( r - l + 1 ) ) ; }
void updateQuery ( int [ ] arr , int n , int q , int l , int r , int k ) { if ( q == 0 ) { arr [ l - 1 ] += k ; arr [ r ] += - k ; } else { arr [ l - 1 ] += - k ; arr [ r ] += k ; } return ; }
void generateArray ( int [ ] arr , int n ) { for ( int i = 1 ; i < n ; ++ i ) arr [ i ] += arr [ i - 1 ] ; }
int calculateProduct ( int [ ] A , int L , int R , int P ) { L = L - 1 ; R = R - 1 ; int ans = 1 ; for ( int i = L ; i <= R ; i ++ ) { ans = ans * A [ i ] ; ans = ans % P ; } return ans ; }
int modInverse ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
void calculate_Pre_Product ( int [ ] A , int N , int P ) { pre_product [ 0 ] = A [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { pre_product [ i ] = pre_product [ i - 1 ] * A [ i ] ; pre_product [ i ] = pre_product [ i ] % P ; } }
void calculate_inverse_product ( int [ ] A , int N , int P ) { inverse_product [ 0 ] = modInverse ( pre_product [ 0 ] , P ) ; for ( int i = 1 ; i < N ; i ++ ) inverse_product [ i ] = modInverse ( pre_product [ i ] , P ) ; }
int calculateProduct ( int [ ] A , int L , int R , int P ) { L = L - 1 ; R = R - 1 ; int ans ; if ( L == 0 ) ans = pre_product [ R ] ; else ans = pre_product [ R ] * inverse_product [ L - 1 ] ; return ans ; }
void buildPrefix ( ) { bool [ ] prime = new bool [ MAX + 1 ] ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } } prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( int p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] == false ) prefix [ p ] ++ ; } }
int query ( int L , int R ) { return prefix [ R ] - prefix [ L - 1 ] ; }
void command ( bool [ ] arr , int a , int b ) { arr [ a ] ^= true ; arr [ b + 1 ] ^= true ; }
void incrementByD ( int [ ] arr , query [ ] q_arr , int n , int m , int d ) { int [ ] sum = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { sum [ q_arr [ i ] . start ] += d ; if ( ( q_arr [ i ] . end + 1 ) < n ) sum [ q_arr [ i ] . end + 1 ] -= d ; } arr [ 0 ] += sum [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum [ i ] += sum [ i - 1 ] ; arr [ i ] += sum [ i ] ; } }
void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
float probability ( int [ ] a , int [ ] b , int size1 , int size2 ) { int max1 = int . MinValue , count1 = 0 ; for ( int i = 0 ; i < size1 ; i ++ ) { if ( a [ i ] > max1 ) { max1 = a [ i ] ; count1 = 1 ; } else if ( a [ i ] == max1 ) { count1 ++ ; } } int max2 = int . MinValue , count2 = 0 ; for ( int i = 0 ; i < size2 ; i ++ ) { if ( b [ i ] > max2 ) { max2 = b [ i ] ; count2 = 1 ; } else if ( b [ i ] == max2 ) { count2 ++ ; } } return ( float ) ( count1 * count2 ) / ( size1 * size2 ) ; }
int countDe ( int [ ] arr , int n ) { int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = arr [ i ] ; Array . Sort ( arr ) ; int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; Array . Reverse ( arr ) ; int count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( Math . Min ( count1 , count2 ) ) ; }
int printMinimumProduct ( int [ ] arr , int n ) { int first_min = Math . Min ( arr [ 0 ] , arr [ 1 ] ) ; int second_min = Math . Max ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; }
long noOfTriples ( long [ ] arr , int n ) { Array . Sort ( arr ) ; long count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; }
bool checkReverse ( int [ ] arr , int n ) { int [ ] temp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ i ] ; } Array . Sort ( temp ) ; int front ; for ( front = 0 ; front < n ; front ++ ) { if ( temp [ front ] != arr [ front ] ) { break ; } } int back ; for ( back = n - 1 ; back >= 0 ; back -- ) { if ( temp [ back ] != arr [ back ] ) { break ; } } if ( front >= back ) { return true ; } do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) { return false ; } } while ( front != back ) ; return true ; }
bool checkReverse ( int [ ] arr , int n ) { if ( n == 1 ) { return true ; } int i ; for ( i = 1 ; arr [ i - 1 ] < arr [ i ] && i < n ; i ++ ) ; if ( i == n ) { return true ; } int j = i ; while ( j < n && arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) { return false ; } j ++ ; } if ( j == n ) { return true ; } int k = j ; if ( arr [ k ] < arr [ i - 1 ] ) { return false ; } while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) { return false ; } k ++ ; } return true ; }
void sortExceptUandL ( int [ ] a , int l , int u , int n ) { int [ ] b = new int [ n - ( u - l + 1 ) ] ; for ( int i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; Array . Sort < int > ( b , 0 , n - ( u - l + 1 ) ) ; for ( int i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
int findMinSwaps ( int [ ] arr , int n ) { int [ ] noOfZeroes = new int [ n ] ; int i , count = 0 ; noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; }
void printList ( Node head ) { while ( head != null ) { Console . Write ( head . data + "->" ) ; head = head . next ; } }
void sortlist ( int [ ] arr , int N , Node head ) { Dictionary < int , int > hash = new Dictionary < int , int > ( ) ; Node temp = head ; while ( temp != null ) { if ( hash . ContainsKey ( temp . data ) ) hash [ temp . data ] = hash [ temp . data ] + 1 ; else hash . Add ( temp . data , 1 ) ; temp = temp . next ; } temp = head ; for ( int i = 0 ; i < N ; i ++ ) { int frequency = hash [ arr [ i ] ] ; while ( frequency -- > 0 ) { temp . data = arr [ i ] ; temp = temp . next ; } } }
void printRepeating ( int [ ] arr , int size ) { SortedSet < int > s = new SortedSet < int > ( arr ) ; foreach ( var n in s ) { Console . Write ( n + " " ) ; } }
int min_noOf_operation ( int [ ] arr , int n , int k ) { int noOfSubtraction ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }
int maxSum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }
int countPairs ( int [ ] a , int n , int k ) { Array . Sort ( a ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; }
void sortedMerge ( int [ ] a , int [ ] b , int [ ] res , int n , int m ) { Array . Sort ( a ) ; Array . Sort ( b ) ; int i = 0 , j = 0 , k = 0 ; while ( i < n && j < m ) { if ( a [ i ] <= b [ j ] ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } else { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } } while ( i < n ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } while ( j < m ) { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } }
int findMaxPairs ( int [ ] a , int [ ] b , int n , int k ) { Array . Sort ( a ) ; Array . Sort ( b ) ; bool [ ] flag = new bool [ n ] ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Math . Abs ( a [ i ] - b [ j ] ) <= k && flag [ j ] == false ) { result ++ ; flag [ j ] = true ; break ; } } } return result ; }
int findMaxPairs ( int [ ] a , int [ ] b , int n , int k ) { Array . Sort ( a ) ; Array . Sort ( b ) ; int result = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { if ( Math . Abs ( a [ i ] - b [ j ] ) <= k ) { result ++ ; i ++ ; j ++ ; } else if ( a [ i ] > b [ j ] ) j ++ ; else i ++ ; } return result ; }
int sumOfMinAbsDifferences ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int sum = 0 ; sum += Math . Abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += Math . Abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) sum += Math . Min ( Math . Abs ( arr [ i ] - arr [ i - 1 ] ) , Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; }
int findSmallestDifference ( int [ ] A , int [ ] B , int m , int n ) { Array . Sort ( A ) ; Array . Sort ( B ) ; int a = 0 , b = 0 ; int result = int . MaxValue ; while ( a < m && b < n ) { if ( Math . Abs ( A [ a ] - B [ b ] ) < result ) result = Math . Abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
bool arraySortedOrNot ( int [ ] arr , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
void findLarger ( int [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) Console . Write ( arr [ i ] + " " ) ; }
int minSwapsToSort ( int [ ] arr , int n ) { List < List < int > > arrPos = new List < List < int > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arrPos . Add ( new List < int > ( ) { arr [ i ] , i } ) ; } arrPos = arrPos . OrderBy ( x => x [ 0 ] ) . ToList ( ) ; bool [ ] vis = new bool [ n ] ; Array . Fill ( vis , false ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] arrPos [ i ] [ 1 ] == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arrPos [ j ] [ 1 ] ; cycle_size ++ ; } ans += ( cycle_size - 1 ) ; } return ans ; }
int minSwapToMakeArraySame ( int [ ] a , int [ ] b , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . Add ( b [ i ] , i ) ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = mp [ a [ i ] ] ; } return minSwapsToSort ( b , n ) ; }
int singleelement ( int [ ] arr , int n ) { int low = 0 , high = n - 2 ; int mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == arr [ mid ^ 1 ] ) { low = mid + 1 ; } else { high = mid - 1 ; } } return arr [ low ] ; }
int getMissingNo ( int [ ] a , int n ) { int n_elements_sum = ( n * ( n + 1 ) / 2 ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum = sum + a [ i ] ; return ( n_elements_sum - sum ) ; }
int countOccurrences ( int [ ] arr , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }
int binarySearch ( int [ ] arr , int l , int r , int x ) { if ( r < l ) return - 1 ; int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; }
int countOccurrences ( int [ ] arr , int n , int x ) { int ind = binarySearch ( arr , 0 , n - 1 , x ) ; if ( ind == - 1 ) return 0 ; int count = 1 ; int left = ind - 1 ; while ( left >= 0 && arr [ left ] == x ) { count ++ ; left -- ; } int right = ind + 1 ; while ( right < n && arr [ right ] == x ) { count ++ ; right ++ ; } return count ; }
void printClosest ( int [ ] arr , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = int . MaxValue ; while ( r > l ) { if ( Math . Abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . Abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } Console . Write ( " The closest pair is " + arr [ res_l ] + " and " + arr [ res_r ] ) ; }
int countOnes ( int [ ] arr , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
int findMissingUtil ( int [ ] arr1 , int [ ] arr2 , int N ) { if ( N == 1 ) return arr1 [ 0 ] ; if ( arr1 [ 0 ] != arr2 [ 0 ] ) return arr1 [ 0 ] ; int lo = 0 , hi = N - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( arr1 [ mid ] == arr2 [ mid ] ) lo = mid ; else hi = mid ; if ( lo == hi - 1 ) break ; } return arr1 [ hi ] ; }
void printTwoElements ( int [ ] arr , int size ) { int i ; Console . Write ( "The repeating element is " ) ; for ( i = 0 ; i < size ; i ++ ) { int abs_val = Math . Abs ( arr [ i ] ) ; if ( arr [ abs_val - 1 ] > 0 ) arr [ abs_val - 1 ] = - arr [ abs_val - 1 ] ; else Console . WriteLine ( abs_val ) ; } Console . Write ( "And the missing element is " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) Console . WriteLine ( i + 1 ) ; } }
void findFourElements ( int [ ] A , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) { if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) Console . Write ( A [ i ] + " " + A [ j ] + " " + A [ k ] + " " + A [ l ] ) ; } } } } }
void findFourElements ( int [ ] arr , int n , int X ) { Dictionary < int , pair > mp = new Dictionary < int , pair > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( mp . ContainsKey ( arr [ i ] + arr [ j ] ) ) mp [ arr [ i ] + arr [ j ] ] = new pair ( i , j ) ; else mp . Add ( arr [ i ] + arr [ j ] , new pair ( i , j ) ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( mp . ContainsKey ( X - sum ) ) { pair p = mp [ X - sum ] ; if ( p . first != i && p . first != j && p . second != i && p . second != j ) { Console . Write ( arr [ i ] + ", " + arr [ j ] + ", " + arr [ p . first ] + ", " + arr [ p . second ] ) ; return ; } } } } }
int findMajority ( int [ ] arr , int n ) { return arr [ n / 2 ] ; }
void minAdjDifference ( int [ ] arr , int n ) { if ( n < 2 ) return ; int res = Math . Abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) res = Math . Min ( res , Math . Abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = Math . Min ( res , Math . Abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; Console . Write ( "Min Difference = " + res ) ; }
int getMin ( int [ ] arr , int n ) { return arr . Min ( ) ; }
int getMax ( int [ ] arr , int n ) { return arr . Max ( ) ; }
int deleteElement ( int [ ] arr , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( int j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; }
int deleteElement ( int [ ] arr , int n , int x ) { if ( arr [ n - 1 ] == x ) return ( n - 1 ) ; int prev = arr [ n - 1 ] , i ; for ( i = n - 2 ; i >= 0 && arr [ i ] != x ; i -- ) { int curr = arr [ i ] ; arr [ i ] = prev ; prev = curr ; } if ( i < 0 ) return 0 ; arr [ i ] = prev ; return ( n - 1 ) ; }
int maxWater ( int [ ] arr , int n ) { int res = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int left = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) { left = Math . Max ( left , arr [ j ] ) ; } int right = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { right = Math . Max ( right , arr [ j ] ) ; } res += Math . Min ( left , right ) - arr [ i ] ; } return res ; }
int findWater ( int [ ] arr , int n ) { int result = 0 ; int left_max = 0 , right_max = 0 ; int lo = 0 , hi = n - 1 ; while ( lo <= hi ) { if ( arr [ lo ] < arr [ hi ] ) { if ( arr [ lo ] > left_max ) left_max = arr [ lo ] ; else result += left_max - arr [ lo ] ; lo ++ ; } else { if ( arr [ hi ] > right_max ) right_max = arr [ hi ] ; else result += right_max - arr [ hi ] ; hi -- ; } } return result ; }
int maxWater ( int [ ] arr , int n ) { int size = n - 1 ; int prev = arr [ 0 ] ; int prev_index = 0 ; int water = 0 ; int temp = 0 ; for ( int i = 1 ; i <= size ; i ++ ) { if ( arr [ i ] >= prev ) { prev = arr [ i ] ; prev_index = i ; temp = 0 ; } else { water += prev - arr [ i ] ; temp += prev - arr [ i ] ; } } if ( prev_index < size ) { water -= temp ; prev = arr [ size ] ; for ( int i = size ; i >= prev_index ; i -- ) { if ( arr [ i ] >= prev ) { prev = arr [ i ] ; } else { water += prev - arr [ i ] ; } } } return water ; }
int maxWater ( int [ ] arr , int n ) { int left = 0 ; int right = n - 1 ; int l_max = 0 ; int r_max = 0 ; int result = 0 ; while ( left <= right ) { if ( r_max <= l_max ) { result += Math . Max ( 0 , r_max - arr [ right ] ) ; r_max = Math . Max ( r_max , arr [ right ] ) ; right -= 1 ; } else { result += Math . Max ( 0 , l_max - arr [ left ] ) ; l_max = Math . Max ( l_max , arr [ left ] ) ; left += 1 ; } } return result ; }
int missingK ( int [ ] a , int k , int n ) { int difference = 0 , ans = 0 , count = k ; bool flag = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return - 1 ; }
int leastFrequent ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int min_count = n + 1 , res = - 1 ; int curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ n - 1 ] ; } return res ; }
int leastFrequent ( int [ ] arr , int n ) { Dictionary < int , int > count = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int key = arr [ i ] ; if ( count . ContainsKey ( key ) ) { int freq = count [ key ] ; freq ++ ; count [ key ] = freq ; } else count . Add ( key , 1 ) ; } int min_count = n + 1 , res = - 1 ; foreach ( KeyValuePair < int , int > pair in count ) { if ( min_count >= pair . Value ) { res = pair . Key ; min_count = pair . Value ; } } return res ; }
int maximumSum ( int [ , ] a , int n ) { int i = 0 , j = 0 ; for ( i = 0 ; i < n ; i ++ ) sort ( ref a , i , n ) ; int sum = a [ n - 1 , M - 1 ] ; int prev = a [ n - 1 , M - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i , j ] < prev ) { prev = a [ i , j ] ; sum += prev ; break ; } } if ( j == - 1 ) return 0 ; } return sum ; }
int maximumSum ( int [ , ] a , int n ) { int prev = Math . Max ( a [ n - 1 , 0 ] , a [ n - 1 , M - 1 ] + 1 ) ; int sum = prev ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int max_smaller = Int32 . MinValue ; for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i , j ] < prev && a [ i , j ] > max_smaller ) { max_smaller = a [ i , j ] ; } } if ( max_smaller == Int32 . MinValue ) { return 0 ; } prev = max_smaller ; sum += max_smaller ; } return sum ; }
int findValue ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == k ) k *= 2 ; return k ; }
int findSmallest ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] >= 1 ) break ; if ( j == n ) return a [ i ] ; } return - 1 ; }
int findSmallest ( int [ ] a , int n ) { int smallest = min_element ( a ) ; for ( int i = 1 ; i < n ; i ++ ) if ( a [ i ] % smallest >= 1 ) return - 1 ; return smallest ; }
int CalculateMax ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int min_sum = arr [ 0 ] + arr [ 1 ] ; int max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return ( Math . Abs ( max_sum - min_sum ) ) ; }
void printMinDiffPairs ( int [ ] arr , int n ) { if ( n <= 1 ) return ; Array . Sort ( arr ) ; int minDiff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) minDiff = Math . Min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) { Console . Write ( " (" + arr [ i - 1 ] + ", " + arr [ i ] + "), " ) ; } } }
int calculateDiff ( int i , int j , int [ ] array ) { return Math . Abs ( array [ i ] - array [ j ] ) + Math . Abs ( i - j ) ; }
int extrema ( int [ ] a , int n ) { int count = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) count += 1 ; if ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) count += 1 ; } return count ; }
int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; }
int sum ( int [ ] a , int n ) { int maxVal = a [ 0 ] , maxCount = 1 ; int secondMax = int . MinValue ; int secondMaxCount = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == maxVal ) maxCount ++ ; else if ( a [ i ] > maxVal ) { secondMax = maxVal ; secondMaxCount = maxCount ; maxVal = a [ i ] ; maxCount = 1 ; } else if ( a [ i ] == secondMax ) { secondMax = a [ i ] ; secondMaxCount ++ ; } else if ( a [ i ] > secondMax ) { secondMax = a [ i ] ; secondMaxCount = 1 ; } } if ( maxCount > 1 ) return maxCount * ( maxCount - 1 ) / 2 ; return secondMaxCount ; }
void printSmall ( int [ ] arr , int asize , int n ) { int [ ] copy_arr = new int [ asize ] ; Array . Copy ( arr , copy_arr , asize ) ; Array . Sort ( copy_arr ) ; for ( int i = 0 ; i < asize ; ++ i ) { if ( Array . BinarySearch ( copy_arr , 0 , n , arr [ i ] ) > - 1 ) Console . Write ( arr [ i ] + " " ) ; } }
void printKMissing ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int i = 0 ; while ( i < n && arr [ i ] <= 0 ) i ++ ; int count = 0 , curr = 1 ; while ( count < k && i < n ) { if ( arr [ i ] != curr ) { Console . Write ( curr + " " ) ; count ++ ; } else i ++ ; curr ++ ; } while ( count < k ) { Console . Write ( curr + " " ) ; curr ++ ; count ++ ; } }
void printmissingk ( int [ ] arr , int n , int k ) { Dictionary < int , int > d = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { d . Add ( arr [ i ] , arr [ i ] ) ; } int cnt = 1 ; int fl = 0 ; for ( int i = 0 ; i < ( n + k ) ; i ++ ) { if ( ! d . ContainsKey ( cnt ) ) { fl += 1 ; Console . Write ( cnt + " " ) ; if ( fl == k ) break ; } cnt += 1 ; } }
bool checkIsAP ( int [ ] arr , int n ) { if ( n == 1 ) return true ; Array . Sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
int minProductSubset ( int [ ] a , int n ) { if ( n == 1 ) return a [ 0 ] ; int negmax = int . MinValue ; int posmin = int . MinValue ; int count_neg = 0 , count_zero = 0 ; int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; negmax = Math . Max ( negmax , a [ i ] ) ; } if ( a [ i ] > 0 && a [ i ] < posmin ) { posmin = a [ i ] ; } product *= a [ i ] ; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return posmin ; if ( count_neg % 2 == 0 && count_neg != 0 ) { product = product / negmax ; } return product ; }
int countPairs ( int [ ] a , int n ) { int mn = int . MaxValue ; int mx = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . Min ( mn , a [ i ] ) ; mx = Math . Max ( mx , a [ i ] ) ; } int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; } if ( mn == mx ) return n * ( n - 1 ) / 2 ; else return c1 * c2 ; }
int findElement ( int [ ] a , int n , int b ) { Array . Sort ( a ) ; int max = a [ n - 1 ] ; while ( b < max ) { if ( Array . BinarySearch ( a , b ) > - 1 ) b *= 2 ; else return b ; } return b ; }
void printList ( Node node ) { while ( node != null ) { Console . Write ( node . data + " " ) ; node = node . next ; } Console . WriteLine ( ) ; }
void rearrangeOddEven ( Node head ) { Stack < Node > odd = new Stack < Node > ( ) ; Stack < Node > even = new Stack < Node > ( ) ; int i = 1 ; while ( head != null ) { if ( head . data % 2 != 0 && i % 2 == 0 ) { odd . Push ( head ) ; } else if ( head . data % 2 == 0 && i % 2 != 0 ) { even . Push ( head ) ; } head = head . next ; i ++ ; } while ( odd . Count > 0 && even . Count > 0 ) { int k = odd . Peek ( ) . data ; odd . Peek ( ) . data = even . Peek ( ) . data ; even . Peek ( ) . data = k ; odd . Pop ( ) ; even . Pop ( ) ; } }
void printList ( Node node ) { while ( node != null ) { Console . Write ( node . data + " " ) ; node = node . next ; } }
void display ( Node head ) { Node curr = head ; while ( curr != null ) { Console . Write ( curr . data + " " ) ; curr = curr . next ; } }
int addWithCarry ( Node head ) { if ( head == null ) return 1 ; int res = head . data + addWithCarry ( head . next ) ; head . data = ( res ) % 10 ; return ( res ) / 10 ; }
void populateArbit ( Node head ) { if ( head == null ) return ; if ( head . next == null ) { maxNode = head ; return ; } populateArbit ( head . next ) ; head . arbit = maxNode ; if ( head . data > maxNode . data ) maxNode = head ; return ; }
void deleteLast ( Node head , int x ) { Node temp = head , ptr = null ; while ( temp != null ) { if ( temp . data == x ) ptr = temp ; temp = temp . next ; } if ( ptr != null && ptr . next == null ) { temp = head ; while ( temp . next != ptr ) temp = temp . next ; temp . next = null ; } if ( ptr != null && ptr . next != null ) { ptr . data = ptr . next . data ; temp = ptr . next ; ptr . next = ptr . next . next ; } }
int getLength ( Node node ) { int size = 0 ; while ( node != null ) { node = node . next ; size ++ ; } return size ; }
bool isPalindromeUtil ( Node head , Node loop_start ) { Node ptr = head ; Stack < int > s = new Stack < int > ( ) ; int count = 0 ; while ( ptr != loop_start count != 1 ) { s . Push ( ptr . data ) ; if ( ptr == loop_start ) count = 1 ; ptr = ptr . next ; } ptr = head ; count = 0 ; while ( ptr != loop_start count != 1 ) { if ( ptr . data == s . Peek ( ) ) s . Pop ( ) ; else return false ; if ( ptr == loop_start ) count = 1 ; ptr = ptr . next ; } return true ; }
bool isPalindrome ( Node head ) { Node loop_start = detectAndgetLoopstarting ( head ) ; return isPalindromeUtil ( head , loop_start ) ; }
int countCommon ( Node a , Node b ) { int count = 0 ; for ( ; a != null && b != null ; a = a . next , b = b . next ) if ( a . data == b . data ) ++ count ; else break ; return count ; }
int maxPalindrome ( Node head ) { int result = 0 ; Node prev = null , curr = head ; while ( curr != null ) { Node next = curr . next ; curr . next = prev ; result = Math . Max ( result , 2 * countCommon ( prev , next ) + 1 ) ; result = Math . Max ( result , 2 * countCommon ( curr , next ) ) ; prev = curr ; curr = next ; } return result ; }
void displayList ( Node head ) { Node temp = head ; while ( temp != null ) { Console . Write ( temp . data + " " ) ; temp = temp . next ; } }
int LinkedListLength ( Node head ) { while ( head != null && head . next != null ) { head = head . next . next ; } if ( head == null ) return 0 ; return 1 ; }
void push ( Node head , int info ) { Node node = new Node ( ) ; node . data = info ; node . next = ( head ) ; ( head ) = node ; }
int sumOfLastN_NodesUtil ( Node head , int n ) { if ( n <= 0 ) return 0 ; Stack < int > st = new Stack < int > ( ) ; int sum = 0 ; while ( head != null ) { st . Push ( head . data ) ; head = head . next ; } while ( n -- > 0 ) { sum += st . Peek ( ) ; st . Pop ( ) ; } return sum ; }
void push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; head = head_ref ; }
int sumOfLastN_NodesUtil ( Node head , int n ) { if ( n <= 0 ) return 0 ; int sum = 0 , len = 0 ; Node temp = head ; while ( temp != null ) { len ++ ; temp = temp . next ; } int c = len - n ; temp = head ; while ( temp != null && c -- > 0 ) { temp = temp . next ; } while ( temp != null ) { sum += temp . data ; temp = temp . next ; } return sum ; }
void printList ( Node node ) { while ( node != null ) { Console . Write ( "{0} " , node . data ) ; node = node . next ; } }
void printList ( Node node ) { while ( node != null ) { Console . Write ( node . data + " " ) ; node = node . next ; } }
void printList ( Node head ) { while ( head != null ) { Console . Write ( head . data + " " ) ; head = head . next ; } }
void printList ( Node head ) { while ( head != null ) { Console . Write ( head . data + " " ) ; head = head . next ; } }
void insertAfterNthNode ( Node head , int n , int x ) { if ( head == null ) return ; Node newNode = getNode ( x ) ; Node slow_ptr = head ; Node fast_ptr = head ; for ( int i = 1 ; i <= n - 1 ; i ++ ) fast_ptr = fast_ptr . next ; while ( fast_ptr . next != null ) { slow_ptr = slow_ptr . next ; fast_ptr = fast_ptr . next ; } newNode . next = slow_ptr . next ; slow_ptr . next = newNode ; }
void printList ( Node head ) { while ( head != null ) { Console . Write ( head . data + " " ) ; head = head . next ; } }
void printList ( Node head ) { Node temp = head ; while ( temp . next != head ) { Console . Write ( temp . data + " " ) ; temp = temp . next ; } Console . Write ( temp . data + " " ) ; }
void printList ( Node head ) { while ( head . next != null ) { Console . Write ( head . data + " <-> " ) ; head = head . next ; } Console . WriteLine ( head . data ) ; }
void printList ( Node head ) { while ( head != null ) { Console . Write ( head . data + " " ) ; head = head . next ; } }
bool isPalindrome ( Node left ) { if ( left == null ) return true ; Node right = left ; while ( right . next != null ) right = right . next ; while ( left != right ) { if ( left . data != right . data ) return false ; left = left . next ; right = right . prev ; } return true ; }
virtual void printKDistant ( Node node , int k ) { if ( node == null k < 0 ) { return ; } if ( k == 0 ) { Console . Write ( node . data + " " ) ; return ; } printKDistant ( node . left , k - 1 ) ; printKDistant ( node . right , k - 1 ) ; }
virtual void kDistantFromLeafUtil ( Node node , int [ ] path , bool [ ] visited , int pathLen , int k ) { if ( node == null ) { return ; } path [ pathLen ] = node . data ; visited [ pathLen ] = false ; pathLen ++ ; if ( node . left == null && node . right == null && pathLen - k - 1 >= 0 && visited [ pathLen - k - 1 ] == false ) { Console . Write ( path [ pathLen - k - 1 ] + " " ) ; visited [ pathLen - k - 1 ] = true ; return ; } kDistantFromLeafUtil ( node . left , path , visited , pathLen , k ) ; kDistantFromLeafUtil ( node . right , path , visited , pathLen , k ) ; }
virtual void printKDistantfromLeaf ( Node node , int k ) { int [ ] path = new int [ 1000 ] ; bool [ ] visited = new bool [ 1000 ] ; kDistantFromLeafUtil ( node , path , visited , 0 , k ) ; }
int rotate ( int [ ] arr , int N , int X ) { int nextPower = 1 ; while ( nextPower <= N ) nextPower *= 2 ; if ( X == 1 ) return nextPower - N ; int prevPower = nextPower / 2 ; return 2 * ( N - prevPower ) + 1 ; }
void performSwap ( int [ , ] mat , int i , int j ) { int N = mat . GetLength ( 0 ) ; int ei = N - 1 - i ; int ej = N - 1 - j ; int temp = mat [ i , j ] ; mat [ i , j ] = mat [ ej , i ] ; mat [ ej , i ] = mat [ ei , ej ] ; mat [ ei , ej ] = mat [ j , ei ] ; mat [ j , ei ] = temp ; }
void rotate ( int [ , ] mat , int N , int K ) { K = K % 4 ; while ( K -- > 0 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { for ( int j = i ; j < N - i - 1 ; j ++ ) { if ( i != j && ( i + j ) != N - 1 ) { performSwap ( mat , i , j ) ; } } } } print ( mat ) ; }
void findMaximumZeros ( string str , int n ) { int c0 = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str [ i ] == '0' ) c0 ++ ; } if ( c0 == n ) { Console . Write ( n ) ; return ; } string s = str + str ; int mx = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int cs = 0 ; int ce = 0 ; for ( int j = i ; j < i + n ; ++ j ) { if ( s [ j ] == '0' ) cs ++ ; else break ; } for ( int j = i + n - 1 ; j >= i ; -- j ) { if ( s [ j ] == '0' ) ce ++ ; else break ; } int val = cs + ce ; mx = Math . Max ( val , mx ) ; } Console . Write ( mx ) ; }
void findMaximumZeros ( string str , int n ) { int c0 = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str [ i ] == '0' ) c0 ++ ; } if ( c0 == n ) { Console . Write ( n ) ; return ; } int mx = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) cnt ++ ; else { mx = Math . Max ( mx , cnt ) ; cnt = 0 ; } } mx = Math . Max ( mx , cnt ) ; int start = 0 , end = n - 1 ; cnt = 0 ; while ( str [ start ] != '1' && start < n ) { cnt ++ ; start ++ ; } while ( str [ end ] != '1' && end >= 0 ) { cnt ++ ; end -- ; } mx = Math . Max ( mx , cnt ) ; Console . Write ( mx ) ; }
int getLeafCount ( Node node ) { if ( node == null ) { return 0 ; } Queue < Node > q = new Queue < Node > ( ) ; int count = 0 ; q . Enqueue ( node ) ; while ( q . Count != 0 ) { Node temp = q . Peek ( ) ; q . Dequeue ( ) ; if ( temp . left != null ) { q . Enqueue ( temp . left ) ; } if ( temp . right != null ) { q . Enqueue ( temp . right ) ; } if ( temp . left == null && temp . right == null ) { count ++ ; } } return count ; }
void rotateArray ( int [ ] arr , int N ) { int [ ] v = arr ; Array . Sort ( v ) ; for ( int i = 1 ; i <= N ; ++ i ) { int x = arr [ N - 1 ] ; i = N - 1 ; while ( i > 0 ) { arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = x ; i -= 1 ; } if ( arr == v ) { Console . Write ( "YES" ) ; return ; } } Console . Write ( "NO" ) ; }
int numberOfDigit ( int N ) { int digit = 0 ; while ( N > 0 ) { digit ++ ; N /= 10 ; } return digit ; }
void rotateNumberByK ( int N , int K ) { int X = numberOfDigit ( N ) ; K = ( ( K % X ) + X ) % X ; int left_no = N / ( int ) ( Math . Pow ( 10 , X - K ) ) ; N = N % ( int ) ( Math . Pow ( 10 , X - K ) ) ; int left_digit = numberOfDigit ( left_no ) ; N = ( N * ( int ) ( Math . Pow ( 10 , left_digit ) ) ) + left_no ; Console . WriteLine ( N ) ; }
void minMovesToSort ( int [ ] arr , int N ) { int count = 0 ; int index = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) { count ++ ; index = i ; } } if ( count == 0 ) { Console . Write ( "0" ) ; } else if ( count == N - 1 ) { Console . Write ( N - 1 ) ; } else if ( count == 1 && arr [ 0 ] <= arr [ N - 1 ] ) { Console . Write ( index + 1 ) ; } else { Console . Write ( "-1" ) ; } }
int findMaximumDiagonalSumOMatrixf ( int [ , ] A ) { int maxDiagonalSum = Int32 . MinValue ; for ( int i = 0 ; i < N ; i ++ ) { int curr = 0 ; for ( int j = 0 ; j < N ; j ++ ) { curr += A [ j , ( i + j ) % N ] ; } maxDiagonalSum = Math . Max ( maxDiagonalSum , curr ) ; } for ( int i = 0 ; i < N ; i ++ ) { int curr = 0 ; for ( int j = 0 ; j < N ; j ++ ) { curr += A [ ( i + j ) % N , j ] ; } maxDiagonalSum = Math . Max ( maxDiagonalSum , curr ) ; } return maxDiagonalSum ; }
int countLeaves ( Node node ) { if ( node == null ) { return 0 ; } if ( node . left == null && node . right == null ) { return 1 ; } return countLeaves ( node . left ) + countLeaves ( node . right ) ; }
int MaxSum ( int [ ] arr , int n , int k ) { int i , max_sum = 0 , sum = 0 ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } max_sum = sum ; while ( i < n ) { sum = sum - arr [ i - k ] + arr [ i ] ; if ( max_sum < sum ) { max_sum = sum ; } i ++ ; } return max_sum ; }
int gcd ( int n1 , int n2 ) { if ( n2 == 0 ) { return n1 ; } else { return gcd ( n2 , n1 % n2 ) ; } }
int [ ] RotateArr ( int [ ] arr , int n , int d ) { int i = 0 , j = 0 ; d = d % n ; int no_of_sets = gcd ( d , n ) ; for ( i = 0 ; i < no_of_sets ; i ++ ) { int temp = arr [ i ] ; j = i ; while ( true ) { int k = j + d ; if ( k >= n ) k = k - n ; if ( k == i ) break ; arr [ j ] = arr [ k ] ; j = k ; } arr [ j ] = temp ; } return arr ; }
int getMinimumRemoval ( String str ) { int n = str . Length ; int ans = n ; if ( n % 2 == 0 ) { int [ ] freqEven = new int [ 128 ] ; int [ ] freqOdd = new int [ 128 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { freqEven [ str [ i ] ] ++ ; } else { freqOdd [ str [ i ] ] ++ ; } } int evenMax = 0 , oddMax = 0 ; for ( char chr = 'a' ; chr <= 'z' ; chr ++ ) { evenMax = Math . Max ( evenMax , freqEven [ chr ] ) ; oddMax = Math . Max ( oddMax , freqOdd [ chr ] ) ; } ans = ans - evenMax - oddMax ; } else { int [ ] freq = new int [ 128 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str [ i ] ] ++ ; } int strMax = 0 ; for ( char chr = 'a' ; chr <= 'z' ; chr ++ ) { strMax = Math . Max ( strMax , freq [ chr ] ) ; } ans = ans - strMax ; } return ans ; }
int findAltSubSeq ( String s ) { int n = s . Length , ans = int . MinValue ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { int cur = 0 , f = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( f == 0 && s [ k ] - '0' == i ) { f = 1 ; cur ++ ; } else if ( f == 1 && s [ k ] - '0' == j ) { f = 0 ; cur ++ ; } } if ( i != j && cur % 2 == 1 ) cur -- ; ans = Math . Max ( cur , ans ) ; } } return ans ; }
int getFirstElement ( int [ ] a , int N , int K , int M ) { K %= N ; int index ; if ( K >= M ) index = ( N - K ) + ( M - 1 ) ; else index = ( M - K - 1 ) ; int result = a [ index ] ; return result ; }
int getFirstElement ( int [ ] a , int N , int K , int M ) { K %= N ; int index = ( K + M - 1 ) % N ; int result = a [ index ] ; return result ; }
void left_rotate ( int [ ] arr ) { int last = arr [ 1 ] ; for ( int i = 3 ; i < arr . Length ; i = i + 2 ) { arr [ i - 2 ] = arr [ i ] ; } arr [ arr . Length - 1 ] = last ; }
void right_rotate ( int [ ] arr ) { int start = arr [ arr . Length - 2 ] ; for ( int i = arr . Length - 4 ; i >= 0 ; i = i - 2 ) { arr [ i + 2 ] = arr [ i ] ; } arr [ 0 ] = start ; }
void rotate ( int [ ] arr ) { left_rotate ( arr ) ; right_rotate ( arr ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
int maximumMatchingPairs ( int [ ] perm1 , int [ ] perm2 , int n ) { int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; Dictionary < int , int > mp1 = new Dictionary < int , int > ( ) ; Dictionary < int , int > mp2 = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp1 [ perm1 [ i ] ] = i ; } for ( int j = 0 ; j < n ; j ++ ) { mp2 [ perm2 [ j ] ] = j ; } for ( int i = 0 ; i < n ; i ++ ) { int idx2 = mp2 [ perm1 [ i ] ] ; int idx1 = i ; if ( idx1 == idx2 ) { left [ i ] = 0 ; right [ i ] = 0 ; } else if ( idx1 < idx2 ) { left [ i ] = ( n - ( idx2 - idx1 ) ) ; right [ i ] = ( idx2 - idx1 ) ; } else { left [ i ] = ( idx1 - idx2 ) ; right [ i ] = ( n - ( idx1 - idx2 ) ) ; } } Dictionary < int , int > freq1 = new Dictionary < int , int > ( ) ; Dictionary < int , int > freq2 = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq1 . ContainsKey ( left [ i ] ) ) freq1 [ left [ i ] ] ++ ; else freq1 [ left [ i ] ] = 1 ; if ( freq2 . ContainsKey ( right [ i ] ) ) freq2 [ right [ i ] ] ++ ; else freq2 [ right [ i ] ] = 1 ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . Max ( ans , Math . Max ( freq1 [ left [ i ] ] , freq2 [ right [ i ] ] ) ) ; } return ans ; }
int countRotation ( int [ ] arr , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { return i ; } } return 0 ; }
int query ( int node , int l , int r , int start , int end , int [ ] a ) { if ( l > end r < start ) return 0 ; if ( start <= l && r <= end ) return seg [ node ] ; int mid = ( l + r ) / 2 ; return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) ; }
void isConversionPossible ( String s1 , String s2 , int x ) { int diff = 0 , n ; n = s1 . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; diff = ( ( int ) ( s2 [ i ] - s1 [ i ] ) + 26 ) % 26 ; if ( diff > x ) { Console . Write ( "NO" ) ; return ; } } Console . Write ( "YES" ) ; }
int countRotation ( int n ) { int count = 0 ; do { int digit = n % 10 ; if ( digit % 2 == 0 ) count ++ ; n = n / 10 ; } while ( n != 0 ) ; return count ; }
void printList ( Node node ) { while ( node != null ) { Console . Write ( node . data + " -> " ) ; node = node . next ; } Console . Write ( "null" ) ; }
bool isPossible ( int [ ] a , int n ) { if ( n <= 2 ) return true ; int flag = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] > a [ i + 1 ] && a [ i + 1 ] > a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; flag = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] < a [ i + 1 ] && a [ i + 1 ] < a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; int val1 = int . MaxValue , mini = - 1 , val2 = int . MinValue , maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < val1 ) { mini = i ; val1 = a [ i ] ; } if ( a [ i ] > val2 ) { maxi = i ; val2 = a [ i ] ; } } flag = 1 ; for ( int i = 0 ; i < maxi ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 && maxi + 1 == mini ) { flag = 1 ; for ( int i = mini ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } flag = 1 ; for ( int i = 0 ; i < mini ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 && maxi - 1 == mini ) { flag = 1 ; for ( int i = maxi ; i < n - 1 ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } return false ; }
int cntRotations ( string s , int n ) { string str = s + s ; int [ ] pre = new int [ 2 * n ] ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i != 0 ) pre [ i ] += pre [ i - 1 ] ; if ( str [ i ] == 'a' str [ i ] == 'e' str [ i ] == 'i' str [ i ] == 'o' str [ i ] == 'u' ) { pre [ i ] ++ ; } } int ans = 0 ; for ( int i = n - 1 ; i < 2 * n - 1 ; i ++ ) { int r = i , l = i - n ; int x1 = pre [ r ] ; if ( l >= 0 ) x1 -= pre [ l ] ; r = i - n / 2 ; int left = pre [ r ] ; if ( l >= 0 ) left -= pre [ l ] ; int right = x1 - left ; if ( left > right ) { ans ++ ; } } return ans ; }
int cntRotations ( char [ ] s , int n ) { int lh = 0 , rh = 0 , i , ans = 0 ; for ( i = 0 ; i < n / 2 ; ++ i ) if ( s [ i ] == 'a' s [ i ] == 'e' s [ i ] == 'i' s [ i ] == 'o' s [ i ] == 'u' ) { lh ++ ; } for ( i = n / 2 ; i < n ; ++ i ) if ( s [ i ] == 'a' s [ i ] == 'e' s [ i ] == 'i' s [ i ] == 'o' s [ i ] == 'u' ) { rh ++ ; } if ( lh > rh ) ans ++ ; for ( i = 1 ; i < n ; ++ i ) { if ( s [ i - 1 ] == 'a' s [ i - 1 ] == 'e' s [ i - 1 ] == 'i' s [ i - 1 ] == 'o' s [ i - 1 ] == 'u' ) { rh ++ ; lh -- ; } if ( s [ ( i - 1 + n / 2 ) % n ] == 'a' || s [ ( i - 1 + n / 2 ) % n ] == 'e' || s [ ( i - 1 + n / 2 ) % n ] == 'i' || s [ ( i - 1 + n / 2 ) % n ] == 'o' || s [ ( i - 1 + n / 2 ) % n ] == 'u' ) { rh -- ; lh ++ ; } if ( lh > rh ) ans ++ ; } return ans ; }
void cal ( int num ) { int digits = numberOfDigits ( num ) ; int powTen = ( int ) Math . Pow ( 10 , digits - 1 ) ; for ( int i = 0 ; i < digits - 1 ; i ++ ) { int firstDigit = num / powTen ; int left = ( ( num * 10 ) + firstDigit ) - ( firstDigit * powTen * 10 ) ; Console . Write ( left + " " ) ; num = left ; } }
void CheckKCycles ( int n , String s ) { bool ff = true ; int x = 0 ; for ( int i = 1 ; i < n ; i ++ ) { x = ( s . Substring ( i ) + s . Substring ( 0 , i ) ) . Length ; if ( x >= s . Length ) { continue ; } ff = false ; break ; } if ( ff ) { Console . WriteLine ( "Yes" ) ; } else { Console . WriteLine ( "No" ) ; } }
void populateNext ( Node node ) { if ( node != null ) { populateNext ( node . right ) ; node . next = next ; next = node ; populateNext ( node . left ) ; } }
void occurredOnce ( int [ ] arr , int n ) { Array . Sort ( arr ) ; if ( arr [ 0 ] != arr [ 1 ] ) Console . Write ( arr [ 0 ] + " " ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) Console . Write ( arr [ i ] + " " ) ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) Console . Write ( arr [ n - 1 ] + " " ) ; }
void occurredOnce ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) mp [ arr [ i ] ] = 1 + mp [ arr [ i ] ] ; else mp . Add ( arr [ i ] , 1 ) ; } foreach ( KeyValuePair < int , int > entry in mp ) { if ( Int32 . Parse ( String . Join ( "" , entry . Value ) ) == 1 ) Console . Write ( entry . Key + " " ) ; } }
void occurredOnce ( int [ ] arr , int n ) { int i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else Console . Write ( arr [ i - 1 ] + " " ) ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) Console . Write ( arr [ n - 1 ] ) ; }
void rvereseArray ( int [ ] arr , int start , int end ) { while ( start < end ) { int temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } }
void printArray ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void splitArr ( int [ ] arr , int k , int n ) { rvereseArray ( arr , 0 , n - 1 ) ; rvereseArray ( arr , 0 , n - k - 1 ) ; rvereseArray ( arr , n - k , n - 1 ) ; }
int countRotationsDivBy8 ( String n ) { int len = n . Length ; int count = 0 ; if ( len == 1 ) { int oneDigit = n [ 0 ] - '0' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { int first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ; int second = ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } int threeDigit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n [ i ] - '0' ) * 100 + ( n [ i + 1 ] - '0' ) * 10 + ( n [ i + 2 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n [ len - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; threeDigit = ( n [ len - 2 ] - '0' ) * 100 + ( n [ len - 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; }
void restoreSortedArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { reverse ( arr , 0 , i ) ; reverse ( arr , i + 1 , n ) ; reverse ( arr , 0 , n ) ; } } }
int findStartIndexOfArray ( int [ ] arr , int low , int high ) { if ( low > high ) { return - 1 ; } if ( low == high ) { return low ; } int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( arr [ mid - 1 ] > arr [ mid ] ) { return mid ; } if ( arr [ low ] > arr [ mid ] ) { return findStartIndexOfArray ( arr , low , mid - 1 ) ; } else { return findStartIndexOfArray ( arr , mid + 1 , high ) ; } }
void restoreSortedArray ( int [ ] arr , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) { return ; } int start = findStartIndexOfArray ( arr , 0 , n - 1 ) ; Array . Sort ( arr , 0 , start ) ; Array . Sort ( arr , start , n ) ; Array . Sort ( arr ) ; }
void printArray ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
void printList ( Node node ) { while ( node != null ) { Console . Write ( node . data + " " ) ; node = node . next ; } }
bool isRotation ( long x , long y ) { long x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; }
int countRotations ( String n ) { int len = n . Length ; if ( len == 1 ) { int oneDigit = n [ 0 ] - '0' ; if ( oneDigit % 4 == 0 ) return 1 ; return 0 ; } int twoDigit , count = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { twoDigit = ( n [ i ] - '0' ) * 10 + ( n [ i + 1 ] - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; } twoDigit = ( n [ len - 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; return count ; }
bool isRotated ( string str1 , string str2 ) { if ( str1 . Length != str2 . Length ) { return false ; } if ( str1 . Length < 2 ) { return str1 . Equals ( str2 ) ; } string clock_rot = "" ; string anticlock_rot = "" ; int len = str2 . Length ; anticlock_rot = anticlock_rot + str2 . Substring ( len - 2 , len - ( len - 2 ) ) + str2 . Substring ( 0 , len - 2 ) ; clock_rot = clock_rot + str2 . Substring ( 2 ) + str2 . Substring ( 0 , 2 ) ; return ( str1 . Equals ( clock_rot ) || str1 . Equals ( anticlock_rot ) ) ; }
void printList ( Node head ) { Node temp = head ; if ( head != null ) { do { Console . Write ( "{0} " , temp . data ) ; temp = temp . next ; } while ( temp != head ) ; } }
void deleteNode ( Node head_ref , Node del ) { Node temp = head_ref ; if ( head_ref == del ) head_ref = del . next ; while ( temp . next != del ) { temp = temp . next ; } temp . next = del . next ; del = null ; return ; }
int largestElement ( Node head_ref ) { Node current ; current = head_ref ; int maxEle = int . MinValue ; do { if ( current . data > maxEle ) { maxEle = current . data ; } current = current . next ; } while ( current != head_ref ) ; return maxEle ; }
void deleteFibonacciNodes ( Node head ) { int maxEle = largestElement ( head ) ; HashSet < int > hash = new HashSet < int > ( ) ; createHash ( hash , maxEle ) ; Node ptr = head ; Node next ; do { if ( hash . Contains ( ptr . data ) ) deleteNode ( head , ptr ) ; next = ptr . next ; ptr = next ; } while ( ptr != head ) ; }
void printList ( Node head ) { Node temp = head ; if ( head != null ) { do { Console . Write ( "{0} " , temp . data ) ; temp = temp . next ; } while ( temp != head ) ; } }
int sumOfList ( Node head ) { Node temp = head ; int sum = 0 ; if ( head != null ) { do { temp = temp . next ; sum += temp . data ; } while ( temp != head ) ; } return sum ; }
int searchList ( Node start , int search ) { Node temp = start ; int count = 0 , flag = 0 , value ; if ( temp == null ) return - 1 ; else { while ( temp . next != start ) { count ++ ; if ( temp . data == search ) { flag = 1 ; count -- ; break ; } temp = temp . next ; } if ( temp . data == search ) { count ++ ; flag = 1 ; } if ( flag == 1 ) Console . WriteLine ( "\n" + search + " found at location " + count ) ; else Console . WriteLine ( "\n" + search + " not found" ) ; } return - 1 ; }
int countList ( node start ) { node temp = start ; int count = 0 ; while ( temp . next != start ) { temp = temp . next ; count ++ ; } count ++ ; return count ; }
void display ( Node head ) { if ( head == null ) return ; Node temp = head ; Console . Write ( "Forward direction: " ) ; while ( temp . next != head ) { Console . Write ( temp . data + " " ) ; temp = temp . next ; } Console . Write ( temp . data + " " ) ; Node last = head . prev ; temp = last ; Console . Write ( "\nBackward direction: " ) ; while ( temp . prev != last ) { Console . Write ( temp . data + " " ) ; temp = temp . prev ; } Console . Write ( temp . data + " " ) ; }
int displayList ( node temp ) { node t = temp ; if ( temp == null ) return 0 ; else { Console . Write ( "The list is: " ) ; while ( temp . next != t ) { Console . Write ( temp . data + " " ) ; temp = temp . next ; } Console . Write ( temp . data ) ; return 1 ; } }
int filter ( int x , int y , int z ) { if ( x != - 1 && y != - 1 ) { return z ; } return x == - 1 ? y : x ; }
int samePathUtil ( int [ , ] mtrx , int vrtx , int v1 , int v2 , int i ) { int ans = - 1 ; if ( i == v1 i == v2 ) return i ; for ( int j = 0 ; j < vrtx ; j ++ ) { if ( mtrx [ i , j ] == 1 ) { ans = filter ( ans , samePathUtil ( mtrx , vrtx , v1 , v2 , j ) , i ) ; } } return ans ; }
bool isVertexAtSamePath ( int [ , ] mtrx , int vrtx , int v1 , int v2 , int i ) { int lca = samePathUtil ( mtrx , vrtx , v1 - 1 , v2 - 1 , i ) ; if ( lca == v1 - 1 lca == v2 - 1 ) return true ; return false ; }
void dfs ( int node , int parent , int h , int cost ) { lca [ node , 0 ] = parent ; level [ node ] = h ; if ( parent != - 1 ) { dist [ node , 0 ] = cost ; } for ( int i = 1 ; i < log ; i ++ ) { if ( lca [ node , i - 1 ] != - 1 ) { lca [ node , i ] = lca [ lca [ node , i - 1 ] , i - 1 ] ; dist [ node , i ] = dist [ node , i - 1 ] + dist [ lca [ node , i - 1 ] , i - 1 ] ; } } foreach ( int [ ] i in graph [ node ] ) { if ( i [ 0 ] == parent ) continue ; dfs ( i [ 0 ] , node , h + 1 , i [ 1 ] ) ; } }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < prime . Length ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
void dfs ( int node , int parent , int h ) { par [ node ] = parent ; level [ node ] = h ; foreach ( int child in graph [ node ] ) { if ( child == parent ) continue ; dfs ( child , node , h + 1 ) ; } }
int findPrimeOnPath ( int u , int v ) { int count = 0 ; if ( level [ u ] > level [ v ] ) { int temp = v ; v = u ; u = temp ; } int d = level [ v ] - level [ u ] ; while ( d -- > 0 ) { if ( prime [ weight [ v ] ] ) count ++ ; v = par [ v ] ; } if ( v == u ) { if ( prime [ weight [ v ] ] ) count ++ ; return count ; } while ( v != u ) { if ( prime [ weight [ v ] ] ) count ++ ; if ( prime [ weight [ u ] ] ) count ++ ; u = par [ u ] ; v = par [ v ] ; } if ( prime [ weight [ v ] ] ) count ++ ; return count ; }
void addEdge ( int u , int v ) { graph [ u ] . Add ( v ) ; graph [ v ] . Add ( u ) ; }
int sumOddNodes ( Node root , int n1 , int n2 ) { List < int > path1 = new List < int > ( ) ; List < int > path2 = new List < int > ( ) ; getPath ( root , path1 , n1 ) ; getPath ( root , path2 , n2 ) ; int intersection = - 1 ; int i = 0 , j = 0 ; while ( i < path1 . Count < path2 . Count ) { if ( i == j && path1 [ i ] == path2 [ j ] ) { i ++ ; j ++ ; } else { intersection = j - 1 ; break ; } } int sum = 0 ; for ( i = path1 . Count - 1 ; i > intersection ; i -- ) if ( path1 [ i ] % 2 != 0 ) sum += path1 [ i ] ; for ( i = intersection ; i < path2 . Count ; i ++ ) if ( path2 [ i ] % 2 != 0 ) sum += path2 [ i ] ; return sum ; }
int findLCA ( int n1 , int n2 , int [ ] parent ) { Boolean [ ] visited = new Boolean [ MAX ] ; visited [ n1 ] = true ; while ( parent [ n1 ] != - 1 ) { visited [ n1 ] = true ; n1 = parent [ n1 ] ; } visited [ n1 ] = true ; while ( ! visited [ n2 ] ) n2 = parent [ n2 ] ; return n2 ; }
void insertAdj ( int [ ] parent , int i , int j ) { parent [ i ] = j ; }
void addEdge ( int u , int v ) { adj [ u ] . Add ( v ) ; adj [ v ] . Add ( u ) ; }
void dfs ( int cur , int prev ) { parent [ cur ] = prev ; depth [ cur ] = depth [ prev ] + 1 ; for ( int i = 0 ; i < adj [ cur ] . Count ; i ++ ) if ( ( int ) adj [ cur ] [ i ] != prev ) dfs ( ( int ) adj [ cur ] [ i ] , cur ) ; }
void preprocess ( ) { depth [ 0 ] = - 1 ; dfs ( 1 , 0 ) ; }
void makeSet ( subset [ ] subsets , int i ) { if ( i < 1 i > V ) return ; subsets [ i ] . color = WHITE ; subsets [ i ] . parent = i ; subsets [ i ] . rank = 0 ; return ; }
int findSet ( subset [ ] subsets , int i ) { if ( subsets [ i ] . parent != i ) subsets [ i ] . parent = findSet ( subsets , subsets [ i ] . parent ) ; return subsets [ i ] . parent ; }
void unionSet ( subset [ ] subsets , int x , int y ) { int xroot = findSet ( subsets , x ) ; int yroot = findSet ( subsets , y ) ; if ( subsets [ xroot ] . rank < subsets [ yroot ] . rank ) subsets [ xroot ] . parent = yroot ; else if ( subsets [ xroot ] . rank > subsets [ yroot ] . rank ) subsets [ yroot ] . parent = xroot ; else { subsets [ yroot ] . parent = xroot ; ( subsets [ xroot ] . rank ) ++ ; } }
bool findPair ( int [ ] a , int n , int z ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; }
bool linearSearch ( int [ ] a , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == key ) return true ; } return false ; }
int maximumSum ( int [ ] arr , int N ) { int Sum = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) Sum += ( arr [ i ] - arr [ i - 1 ] ) ; } return Sum ; }
void stoogesort ( int [ ] arr , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) { int temp = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = temp ; } if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3 ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } }
void findWinner ( int n , int m ) { int X = 0 ; int Y = 0 ; if ( n >= m ) { X = n - 1 ; Y = m ; } else { X = m - 1 ; Y = n ; } if ( X > Y ) Console . Write ( "X" ) ; else if ( Y > X ) Console . Write ( "Y" ) ; else Console . Write ( "-1" ) ; }
void checkPascaltriangle ( int N ) { double x = ( Math . Sqrt ( 8 * N + 1 ) - 1 ) / 2 ; if ( Math . Ceiling ( x ) - x == 0 ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
void countSubarrays ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( ( j - i ) % 2 == 0 ) sum += arr [ j ] ; else sum -= arr [ j ] ; if ( sum == 0 ) count ++ ; } } Console . WriteLine ( count ) ; }
void findCountRooks ( int [ ] row , int [ ] col , int n , int k ) { int res = n - k ; Console . WriteLine ( res + " " ) ; int ri = 0 , ci = 0 ; while ( res -- > 0 ) { while ( ri < k && row [ ri ] == 1 ) { ri ++ ; } while ( ci < k && col [ ci ] == 1 ) { ci ++ ; } Console . WriteLine ( ( ri + 1 ) + " " + ( ci + 1 ) + " " ) ; ri ++ ; ci ++ ; } }
bool checkIfDivisible ( String str , long num ) { long powerOf2 = ( int ) ( Math . Log ( num ) / Math . Log ( 2 ) ) ; if ( str . Length < powerOf2 ) return false ; if ( powerOf2 == 0 ) return true ; long i , number = 0 ; int len = str . Length ; for ( i = len - powerOf2 ; i < len ; i ++ ) { number += ( long ) ( ( str [ ( int ) i ] - '0' ) * Math . Pow ( 10 , powerOf2 - 1 ) ) ; powerOf2 -- ; } if ( number % num != 0 ) return false ; else return true ; }
void countNo ( int A , int N , int L , int R ) { int ans = L - 1 + N + ( ( N - 1 ) / ( A - 1 ) ) ; if ( ans % A == 0 ) { ans = ans + 1 ; } Console . WriteLine ( ans ) ; }
bool check_order ( int [ ] arr ) { int cnt = 0 ; for ( int i = 0 ; i < arr . Length - 1 ; i ++ ) { if ( Math . Abs ( arr [ i + 1 ] - arr [ i ] ) > 1 ) cnt ++ ; } if ( Math . Abs ( arr [ 0 ] - arr [ arr . Length - 1 ] ) > 1 ) cnt ++ ; if ( cnt > 1 ) return false ; return true ; }
int getM ( int n ) { if ( n == 1 ) return - 1 ; else return n - 2 ; }
int maxProfit ( int [ ] prices , int n ) { if ( n <= 1 ) return 0 ; int [ ] rest = new int [ n ] ; int [ ] hold = new int [ 9 ] ; int [ ] sold = new int [ 9 ] ; rest [ 0 ] = 0 ; hold [ 0 ] = - prices [ 0 ] ; sold [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { rest [ i ] = Math . Max ( rest [ i - 1 ] , sold [ i - 1 ] ) ; hold [ i ] = Math . Max ( hold [ i - 1 ] , rest [ i - 1 ] - prices [ i ] ) ; sold [ i ] = hold [ i - 1 ] + prices [ i ] ; } return Math . Max ( rest [ n - 1 ] , sold [ n - 1 ] ) ; }
int findSubarrays ( int [ ] arr , int N , int K ) { return N - K + 1 ; }
int findCount ( String s ) { int [ ] freq = new int [ 26 ] ; int [ , ] dp = new int [ 26 , 26 ] ; for ( int i = 0 ; i < s . Length ; ++ i ) { for ( int j = 0 ; j < 26 ; j ++ ) { dp [ j , s [ i ] - 'a' ] += freq [ j ] ; } freq [ s [ i ] - 'a' ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) ans = Math . Max ( freq [ i ] , ans ) ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { ans = Math . Max ( dp [ i , j ] , ans ) ; } } return ans ; }
int findCycles ( int N ) { int res = 0 ; int finalResult = 0 ; int val = 2 * N - 1 ; int s = val ; res = ( N - 1 ) * ( N - 2 ) ; finalResult = res + s ; return finalResult ; }
int longest_subarray ( int [ ] arr , int d ) { int i = 0 , j = 1 , e = 0 ; for ( i = 0 ; i < d - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { j = j + 1 ; } else { j = 1 ; } if ( e < j ) { e = j ; } } return e ; }
int find ( int [ ] a , int n , int k ) { List < int > v = new List < int > ( ) ; for ( int i = 1 ; i < n ; ++ i ) { v . Add ( a [ i - 1 ] - a [ i ] ) ; } v . Sort ( ) ; int res = a [ n - 1 ] - a [ 0 ] ; for ( int i = 0 ; i < k - 1 ; ++ i ) { res += v [ i ] ; } return res ; }
bool isStrong ( int N ) { String num = N . ToString ( ) ; int sum = 0 ; for ( int i = 0 ; i < num . Length ; i ++ ) { sum += factorial [ int . Parse ( num [ i ] + "" ) ] ; } return sum == N ; }
void printStrongNumbers ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( isStrong ( i ) ) { Console . Write ( i + " " ) ; } } }
int countPairs ( int A , int B ) { int countY = 0 , countX = ( B - A ) + 1 , next_val = 9 ; while ( next_val <= B ) { if ( next_val >= A ) { countY += 1 ; } next_val = next_val * 10 + 9 ; } return ( countX * countY ) ; }
long power ( long a , long b , long c ) { long result = 1 ; while ( b > 0 ) { if ( ( b & 1 ) == 1 ) { result = ( result * a ) % c ; } b /= 2 ; a = ( a * a ) % c ; } return result ; }
long calculate ( long X , long N ) { int [ ] a = new int [ 10 ] ; int [ ] cyclicity = new int [ 11 ] ; cyclicity [ 1 ] = 1 ; cyclicity [ 2 ] = 4 ; cyclicity [ 3 ] = 4 ; cyclicity [ 4 ] = 2 ; cyclicity [ 5 ] = 1 ; cyclicity [ 6 ] = 1 ; cyclicity [ 7 ] = 4 ; cyclicity [ 8 ] = 4 ; cyclicity [ 9 ] = 2 ; cyclicity [ 10 ] = 1 ; if ( N == 0 N == 1 ) { return ( X % 10 ) ; } else if ( N == 2 N == 3 N == 4 ) { long temp = ( long ) 1e18 ; a [ 2 ] = 2 ; a [ 3 ] = 6 ; a [ 4 ] = 4 ; long v = X % 10 ; if ( v != 0 ) { int u = cyclicity [ ( int ) v ] ; int r = a [ ( int ) N ] % u ; if ( r == 0 ) { if ( v == 2 v == 4 v == 6 v == 8 ) { return 6 ; } else if ( v == 5 ) { return 5 ; } else if ( v == 1 v == 3 v == 7 v == 9 ) { return 1 ; } } else { return ( power ( v , r , temp ) % 10 ) ; } } else { return 0 ; } } return 1 ; }
void precompute ( string s , string K ) { int n = s . Length ; for ( int i = 0 ; i < n - 2 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] ; if ( s . Substring ( i , K . Length ) . Equals ( K ) ) { cnt [ i + 1 ] += 1 ; } } cnt [ n - 2 + 1 ] = cnt [ n - 2 ] ; }
int getXOR ( int [ ] BITree , int index ) { int ans = 0 ; index += 1 ; while ( index > 0 ) { ans ^= BITree [ index ] ; index -= index & ( - index ) ; } return ans ; }
void updateBIT ( int [ ] BITree , int n , int index , int val ) { index = index + 1 ; while ( index <= n ) { BITree [ index ] ^= val ; index += index & ( - index ) ; } }
bool isPowerOfTwo ( int x ) { if ( x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ) return true ; return false ; }
void computePrefix ( int n , int [ ] a ) { if ( isPowerOfTwo ( a [ 0 ] ) ) prefix [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] ; if ( isPowerOfTwo ( a [ i ] ) ) prefix [ i ] ++ ; } }
int formQuadruplets ( int [ ] arr , int n ) { int ans = 0 , pairs = 0 ; pairs = n / 4 ; Array . Sort ( arr ) ; Array . Reverse ( arr ) ; for ( int i = 0 ; i < n - pairs ; i += 3 ) { ans += arr [ i + 2 ] ; } return ans ; }
void count ( ) { int maxN = 1000000 , i , j ; for ( i = 0 ; i < maxN ; i ++ ) arr [ i ] = 1 ; arr [ 0 ] = 0 ; arr [ 1 ] = 0 ; for ( i = 2 ; i * i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) { for ( j = 2 * i ; j <= maxN ; j += i ) { arr [ j ] = 0 ; } } } int cnt = 0 ; for ( i = 0 ; i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) cnt ++ ; if ( arr [ cnt ] == 1 ) dp [ i ] = 1 ; else dp [ i ] = 0 ; } for ( i = 1 ; i <= maxN ; i ++ ) dp [ i ] += dp [ i - 1 ] ; }
void findUngroupedElement ( String s , int k ) { int n = s . Length ; int [ ] b = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) b [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char p = s [ i ] ; b [ p - 'a' ] += 1 ; } int sum = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( b [ i ] > k ) sum += b [ i ] - k ; } Console . WriteLine ( sum ) ; }
void AddEdge ( int u , int v ) { adj [ u ] . Add ( v ) ; adj [ v ] . Add ( u ) ; }
void findFirstEnd ( int u , int p ) { lvl [ u ] = 1 + lvl [ p ] ; if ( lvl [ u ] > maxi ) { maxi = lvl [ u ] ; end1 = u ; } for ( int i = 0 ; i < adj [ u ] . Count ; i ++ ) { if ( adj [ u ] [ i ] != p ) { findFirstEnd ( adj [ u ] [ i ] , u ) ; } } }
void findSecondEnd ( int u , int p ) { lvl [ u ] = 1 + lvl [ p ] ; if ( lvl [ u ] > maxi ) { maxi = lvl [ u ] ; end2 = u ; } for ( int i = 0 ; i < adj [ u ] . Count ; i ++ ) { if ( adj [ u ] [ i ] != p ) { findSecondEnd ( adj [ u ] [ i ] , u ) ; } } }
void findDistancefromFirst ( int u , int p ) { dist1 [ u ] = 1 + dist1 [ p ] ; for ( int i = 0 ; i < adj [ u ] . Count ; i ++ ) { if ( adj [ u ] [ i ] != p ) { findDistancefromFirst ( adj [ u ] [ i ] , u ) ; } } }
void findDistancefromSecond ( int u , int p ) { dist2 [ u ] = 1 + dist2 [ p ] ; for ( int i = 0 ; i < adj [ u ] . Count ; i ++ ) { if ( adj [ u ] [ i ] != p ) { findDistancefromSecond ( adj [ u ] [ i ] , u ) ; } } }
void findNodes ( ) { int n = 5 ; AddEdge ( 1 , 2 ) ; AddEdge ( 1 , 3 ) ; AddEdge ( 3 , 4 ) ; AddEdge ( 3 , 5 ) ; findFirstEnd ( 1 , 0 ) ; clear ( n ) ; findSecondEnd ( end1 , 0 ) ; findDistancefromFirst ( end1 , 0 ) ; findDistancefromSecond ( end2 , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) { int x = dist1 [ i ] ; int y = dist2 [ i ] ; if ( x >= y ) { Console . Write ( end1 + " " ) ; } else { Console . Write ( end2 + " " ) ; } } }
int findMaxSum ( int [ ] arr , int n ) { List < int > a = new List < int > ( ) ; List < int > b = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { a . Add ( arr [ i ] ) ; } else if ( arr [ i ] < 0 ) { b . Add ( arr [ i ] ) ; } } a . Sort ( ) ; b . Sort ( ) ; int p = a . Count - 1 ; int q = b . Count - 1 ; int s = 0 ; while ( p >= 0 && q >= 0 ) { if ( a [ p ] + b [ q ] > 0 ) { s = s + a [ p ] + b [ q ] ; } else { break ; } p = p - 1 ; q = q - 1 ; } return s ; }
void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { Console . WriteLine ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) ; }
void SieveOfEratosthenes ( bool [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
void PrimeDegreeNodes ( int [ ] prufer , int n ) { int nodes = n + 2 ; bool [ ] prime = new bool [ nodes + 1 ] ; for ( int i = 0 ; i < prime . Length ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , nodes + 1 ) ; int [ ] degree = new int [ n + 2 + 1 ] ; for ( int i = 1 ; i <= nodes ; i ++ ) degree [ i ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) degree [ prufer [ i ] ] ++ ; for ( int i = 1 ; i <= nodes ; i ++ ) { if ( prime [ degree [ i ] ] ) { Console . Write ( i + " " ) ; } } }
virtual int countSingle ( Node node ) { countSingleRec ( node , ct ) ; return ct . count ; }
void SieveOfEratosthenes ( ) { int i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= 10005 ; i ++ ) { if ( Prime [ i ] ) { for ( j = 2 * i ; j < 10005 ; j += i ) { Prime [ j ] = false ; } } } }
void primeDegreeNodes ( int N , int M , int [ , ] edges ) { List < int > [ ] Adj = new List < int > [ N + 1 ] ; for ( int i = 0 ; i < Adj . Length ; i ++ ) Adj [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < M ; i ++ ) { int x = edges [ i , 0 ] ; int y = edges [ i , 1 ] ; Adj [ x ] . Add ( y ) ; Adj [ y ] . Add ( x ) ; } SieveOfEratosthenes ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { int x = Adj [ i ] . Count ; if ( Prime [ x ] ) Console . Write ( i + " " ) ; } }
int digitSum ( int num ) { int sum = 0 ; while ( num > 0 ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; }
int countWays ( int [ ] colored , int count , int n ) { if ( count == n ) { return 1 ; } int answer = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { if ( colored [ i ] == 0 ) { if ( colored [ i - 1 ] == 1 colored [ i + 1 ] == 1 ) { colored [ i ] = 1 ; answer = ( answer + countWays ( colored , count + 1 , n ) ) % mod ; colored [ i ] = 0 ; } } } return answer ; }
int waysToColor ( int [ ] arr , int n , int k ) { int [ ] colored = new int [ n + 2 ] ; for ( int i = 0 ; i < k ; i ++ ) { colored [ arr [ i ] ] = 1 ; } return countWays ( colored , k , n ) ; }
int waysToColor ( int [ ] arr , int n , int k ) { int [ ] powOf2 = new int [ 500 ] ; int [ , ] c = new int [ 500 , 500 ] ; for ( int i = 0 ; i <= n ; i ++ ) { c [ i , 0 ] = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { c [ i , j ] = ( c [ i - 1 , j ] + c [ i - 1 , j - 1 ] ) % mod ; } } powOf2 [ 0 ] = powOf2 [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { powOf2 [ i ] = powOf2 [ i - 1 ] * 2 % mod ; } int rem = n - k ; arr [ k ++ ] = n + 1 ; Array . Sort ( arr ) ; int answer = 1 ; for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ i ] - ( i - 1 >= 0 ? arr [ i - 1 ] : 0 ) - 1 ; answer *= c [ rem , x ] % mod * ( i != 0 && i != k - 1 ? powOf2 [ x ] : 1 ) % mod ; rem -= x ; } return answer ; }
char ShortestPalindrome ( String s ) { int n = s . Length ; char ans = s [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = ( char ) Math . Min ( ans , s [ i ] ) ; } return ans ; }
long SumGPUtil ( long r , long n , long m ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return ( 1 + r ) % m ; long ans ; if ( n % 2 == 1 ) { ans = ( 1 + r ) * SumGPUtil ( ( r * r ) % m , ( n - 1 ) / 2 , m ) ; } else { ans = 1 + ( r * ( 1 + r ) * SumGPUtil ( ( r * r ) % m , ( n / 2 ) - 1 , m ) ) ; } return ( ans % m ) ; }
void SumGP ( long a , long r , long N , long M ) { long answer ; answer = a * SumGPUtil ( r , N , M ) ; answer = answer % M ; Console . WriteLine ( answer ) ; }
virtual void findLeafDown ( Node root , int lev , Distance minDist ) { if ( root == null ) { return ; } if ( root . left == null && root . right == null ) { if ( lev < ( minDist . minDis ) ) { minDist . minDis = lev ; } return ; } findLeafDown ( root . left , lev + 1 , minDist ) ; findLeafDown ( root . right , lev + 1 , minDist ) ; }
virtual int findThroughParent ( Node root , Node x , Distance minDist ) { if ( root == null ) { return - 1 ; } if ( root == x ) { return 0 ; } int l = findThroughParent ( root . left , x , minDist ) ; if ( l != - 1 ) { findLeafDown ( root . right , l + 2 , minDist ) ; return l + 1 ; } int r = findThroughParent ( root . right , x , minDist ) ; if ( r != - 1 ) { findLeafDown ( root . left , r + 2 , minDist ) ; return r + 1 ; } return - 1 ; }
virtual int minimumDistance ( Node root , Node x ) { Distance d = new Distance ( ) ; findLeafDown ( x , 0 , d ) ; findThroughParent ( root , x , d ) ; return d . minDis ; }
int SmallestDiv ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return i ; } } return n ; }
int countOfNum ( int n , int a , int b ) { int cnt_of_a , cnt_of_b , cnt_of_ab , sum ; cnt_of_a = n / a ; cnt_of_b = n / b ; sum = cnt_of_b + cnt_of_a ; cnt_of_ab = n / ( a * b ) ; sum = sum - cnt_of_ab ; return sum ; }
int sumOfNum ( int n , int a , int b ) { int i ; int sum = 0 ; HashSet < int > ans = new HashSet < int > ( ) ; for ( i = a ; i <= n ; i = i + a ) { ans . Add ( i ) ; } for ( i = b ; i <= n ; i = i + b ) { ans . Add ( i ) ; } foreach ( int it in ans ) { sum = sum + it ; } return sum ; }
bool isPalindrome ( String r ) { String p = r ; p = reverse ( p ) ; return ( r . Equals ( p ) ) ; }
int minimumAdjacentDifference ( int [ ] a , int n , int k ) { int minDiff = int . MaxValue ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int cnt = countSetBits ( i ) ; if ( cnt == n - k ) { List < int > temp = new List < int > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) temp . Add ( a [ j ] ) ; } int maxDiff = int . MinValue ; for ( int j = 0 ; j < temp . Count - 1 ; j ++ ) { maxDiff = Math . Max ( maxDiff , temp [ j + 1 ] - temp [ j ] ) ; } minDiff = Math . Min ( minDiff , maxDiff ) ; } } return minDiff ; }
int gcdFunc ( int a , int b ) { if ( b == 0 ) return a ; return gcdFunc ( b , a % b ) ; }
int findMinimumElements ( int [ ] a , int n ) { int [ ] b = new int [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { b [ i - 1 ] = a [ i ] - a [ i - 1 ] ; } int gcd = b [ 0 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { gcd = gcdFunc ( gcd , b [ i ] ) ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans += ( b [ i ] / gcd ) - 1 ; } return ans ; }
bool checkPermutation ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int [ ] prefix = new int [ n + 1 ] ; prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int lsum = prefix [ i ] ; int rsum = sum - prefix [ i ] ; int l_len = i + 1 , r_len = n - i - 1 ; if ( ( ( 2 * lsum ) == ( l_len * ( l_len + 1 ) ) ) && ( ( 2 * rsum ) == ( r_len * ( r_len + 1 ) ) ) ) return true ; } return false ; }
void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; Console . Write ( Math . Max ( Math . Max ( left , right ) , Math . Max ( above , below ) ) ) ; }
void precompute ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd [ i ] = 1 ; if ( arr [ i ] % 2 == 0 ) even [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { even [ i ] = even [ i ] + even [ i - 1 ] ; odd [ i ] = odd [ i ] + odd [ i - 1 ] ; } }
bool isOdd ( int L , int R ) { int cnt = odd [ R ] ; if ( L > 0 ) cnt -= odd [ L - 1 ] ; if ( cnt == R - L + 1 ) return true ; return false ; }
void findTriplets ( int x ) { List < int > fact = new List < int > ( ) ; HashSet < int > factors = new HashSet < int > ( ) ; for ( int i = 2 ; i <= Math . Sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { fact . Add ( i ) ; if ( x / i != i ) fact . Add ( x / i ) ; factors . Add ( i ) ; factors . Add ( x / i ) ; } } bool found = false ; int k = fact . Count ; for ( int i = 0 ; i < k ; i ++ ) { int a = fact [ i ] ; for ( int j = 0 ; j < k ; j ++ ) { int b = fact [ j ] ; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) { Console . Write ( a + " " + b + " " + ( x / ( a * b ) ) ) ; found = true ; break ; } } if ( found ) break ; } if ( ! found ) Console . Write ( "-1" ) ; }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void findArray ( int n , int k , int s ) { int [ ] vis = new int [ n ] ; int cnt = 0 ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n && cnt < k ; i += 2 ) { arr [ i ] = s ; vis [ i ] = 1 ; cnt ++ ; } int val = s ; if ( s % 2 == 0 ) val ++ ; else val = val + 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] == 0 ) { arr [ i ] = val ; } } printArr ( arr , n ) ; }
int countPair ( int a , int b ) { String s = String . Join ( "" , b ) ; int i ; for ( i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] != '9' ) break ; } int result ; if ( i == s . Length ) result = a * s . Length ; else result = a * ( s . Length - 1 ) ; return result ; }
float getArea ( int a ) { float area = ( float ) ( Math . PI * a * a ) / 4 ; return area ; }
bool flipsPossible ( int [ ] a , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return false ; else return true ; }
int sumEqualProduct ( int [ ] a , int n ) { int zero = 0 , two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } if ( a [ i ] == 2 ) { two ++ ; } } int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ; return cnt ; }
int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; }
void initialize ( int [ ] mul , int [ ] div , int size ) { for ( int i = 1 ; i < size ; i ++ ) { mul [ i ] = ( mul [ i ] * mul [ i - 1 ] ) / div [ i ] ; } }
void update ( int l , int r , int x , int [ ] mul , int [ ] div ) { mul [ l ] *= x ; div [ r + 1 ] *= x ; }
void printArray ( int [ ] ar , int [ ] mul , int [ ] div , int n ) { for ( int i = 0 ; i < n ; i ++ ) { ar [ i ] = ar [ i ] * mul [ i ] ; Console . Write ( ar [ i ] + " " ) ; } }
void findTriangle ( long S ) { long X1 = 0 , Y1 = 0 ; long X2 = MAX , Y2 = 1 ; long X3 = ( MAX - S % MAX ) % MAX ; long Y3 = ( S + X3 ) / MAX ; Console . WriteLine ( "(" + X1 + ", " + Y1 + ")" ) ; Console . WriteLine ( "(" + X2 + ", " + Y2 + ")" ) ; Console . WriteLine ( "(" + X3 + ", " + Y3 + ")" ) ; }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void findArrangement ( int [ ] arr , int n ) { if ( n < 2 ) { Console . Write ( "-1" ) ; return ; } int minVal = arr . Min ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == minVal ) { swap ( arr , i , n - 1 ) ; break ; } } int andVal = arr [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { andVal &= arr [ i ] ; } if ( andVal == arr [ n - 1 ] ) printArr ( arr , n ) ; else Console . Write ( "-1" ) ; }
int maxOperations ( int X , int Y ) { if ( X > Y ) return - 1 ; int diff = Y - X ; if ( diff == 1 ) return - 1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; }
void precompute ( ) { for ( int i = 0 ; i < DIGITS ; i ++ ) { dp [ 1 , i ] = i ; cnt [ 1 , i ] = 1 ; } for ( int i = 2 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < DIGITS ; j ++ ) { for ( int k = 0 ; k < DIGITS ; k ++ ) { if ( j != k ) { dp [ i , j ] = dp [ i , j ] + ( dp [ i - 1 , k ] + ( cnt [ i - 1 , k ] * j ) % MOD ) % MOD ; dp [ i , j ] %= MOD ; cnt [ i , j ] += cnt [ i - 1 , k ] ; cnt [ i , j ] %= MOD ; } } } } }
void precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( int i = 4 ; i < N ; i ++ ) F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; }
double minimizedSum ( int [ ] a , int n , int K ) { int sum = maxSubArraySum ( a , n ) ; double totalSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) totalSum += a [ i ] ; if ( sum < 0 ) return totalSum ; totalSum = totalSum - sum + ( double ) sum / ( double ) K ; return totalSum ; }
double get ( double L , double R ) { double x = 1.0 / L ; double y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; }
void DivisorCount ( ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j += i ) { divi [ j ] ++ ; } } }
void pre ( ) { for ( int i = 1 ; i < N ; i ++ ) { if ( prime [ divi [ i ] ] == 1 ) { sum [ i ] = i ; } } for ( int i = 1 ; i < N ; i ++ ) sum [ i ] += sum [ i - 1 ] ; }
int consecutiveOnes ( int x ) { int p = 0 ; while ( x > 0 ) { if ( x % 2 == 1 && p == 1 ) { return 1 ; } p = x % 2 ; x /= 2 ; } return 0 ; }
void preCompute ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) { if ( consecutiveOnes ( i ) == 0 ) { v . Add ( i ) ; } } }
int nextValid ( int n ) { int it = upper_bound ( v , n ) ; int val = v [ it ] ; return val ; }
void randomList ( int m , int n ) { int [ ] arr = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { Random rnd = new Random ( ) ; arr [ rnd . Next ( 0 , n ) % m ] ++ ; } printArr ( arr , m ) ; }
long power ( long x , int y , int p ) { long res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
long nCrModPFermat ( long n , int r , int p ) { if ( r == 0 ) return 1 ; long [ ] fac = new long [ ( int ) n + 1 ] ; fac [ 0 ] = 1 ; int i ; for ( i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ ( int ) n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ ( int ) n - r ] , p ) % p ) % p ; }
long countOdd ( long n ) { long x = n / 2 ; if ( n % 2 == 1 ) x ++ ; return x ; }
long counteEven ( long n ) { long x = n / 2 ; return x ; }
int sumPrime ( int k ) { SieveOfEratosthenes ( ) ; List < int > v = new List < int > ( ) ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) v . Add ( i ) ; } int sum = 0 ; int skip = ( k * ( k - 1 ) ) / 2 ; while ( k > 0 ) { sum += v [ skip ] ; skip ++ ; k -- ; } return sum ; }
int lcm ( int x , int y ) { int temp = ( x * y ) / __gcd ( x , y ) ; return temp ; }
void findNumbers ( int [ ] a , int n , int [ ] b , int m ) { int lcmA = 1 , gcdB = 0 ; for ( int i = 0 ; i < n ; i ++ ) lcmA = lcm ( lcmA , a [ i ] ) ; for ( int i = 0 ; i < m ; i ++ ) gcdB = __gcd ( gcdB , b [ i ] ) ; if ( gcdB % lcmA != 0 ) { Console . Write ( "-1" ) ; return ; } int num = lcmA ; while ( num <= gcdB ) { if ( gcdB % num == 0 ) Console . Write ( num + " " ) ; num += lcmA ; } }
int countSubStr ( String str , int n , char ch ) { int cnt = 0 ; int j = nextOccurrence ( str , n , 0 , ch ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j != - 1 && j < i ) { j = nextOccurrence ( str , n , j + 1 , ch ) ; } if ( j == - 1 ) break ; cnt += ( n - j ) ; } return cnt ; }
void checkEvenOdd ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { Console . Write ( "Even" ) ; return ; } } Console . Write ( "Odd" ) ; }
int power ( int x , int y ) { int res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }
int maxPartition ( string s ) { int n = s . Length , P = 0 ; string current = "" , previous = "" ; for ( int i = 0 ; i < n ; i ++ ) { current += s [ i ] ; if ( ! current . Equals ( previous ) ) { previous = current ; current = "" ; P ++ ; } } return P ; }
int LongestSubarray ( int [ ] a , int n , int k ) { int [ ] pre = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > k ) pre [ i ] = 1 ; else pre [ i ] = - 1 ; } for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = pre [ i - 1 ] + pre [ i ] ; int len = 0 ; int lo = 1 , hi = n ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; bool ok = false ; for ( int i = mid - 1 ; i < n ; i ++ ) { int x = pre [ i ] ; if ( i - mid >= 0 ) x -= pre [ i - mid ] ; if ( x > 0 ) { ok = true ; break ; } } if ( ok == true ) { len = mid ; lo = mid + 1 ; } else hi = mid - 1 ; } return len ; }
bool prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; ++ i ) if ( n % i == 0 ) return false ; return true ; }
int Min_Sum ( int n ) { if ( prime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; else { if ( prime ( n - 2 ) ) return 2 ; else return 3 ; } }
int MinDeletion ( int [ ] a , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( a [ i ] ) ) { var val = mp [ a [ i ] ] ; mp . Remove ( a [ i ] ) ; mp . Add ( a [ i ] , val + 1 ) ; } else { mp . Add ( a [ i ] , 1 ) ; } } int ans = 0 ; foreach ( KeyValuePair < int , int > i in mp ) { int x = i . Key ; int frequency = i . Value ; if ( x <= frequency ) { ans += ( frequency - x ) ; } else ans += frequency ; } return ans ; }
int find_maximum_value ( int [ ] a , int n ) { int sum = 0 ; int minimum = int . MaxValue ; int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { minimum = Math . Min ( minimum , Math . Abs ( a [ i ] ) ) ; sum += Math . Abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) pos += 1 ; else neg += 1 ; } if ( pos > 0 && neg > 0 ) return sum ; return ( sum - 2 * minimum ) ; }
int maxCountAB ( string [ ] s , int n ) { int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string S = s [ i ] ; int L = S . Length ; for ( int j = 0 ; j < L - 1 ; j ++ ) { if ( S [ j ] == 'A' && S [ j + 1 ] == 'B' ) { ans ++ ; } } if ( S [ 0 ] == 'B' && S [ L - 1 ] == 'A' ) BA ++ ; else if ( S [ 0 ] == 'B' ) B ++ ; else if ( S [ L - 1 ] == 'A' ) A ++ ; } if ( BA == 0 ) ans += Math . Min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + Math . Min ( B , A ) ; return ans ; }
int MinOperations ( int n , int x , int [ ] arr ) { int total = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] > x ) { int difference = arr [ i ] - x ; total = total + difference ; arr [ i ] = x ; } } for ( int i = 1 ; i < n ; ++ i ) { int LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] ; if ( LeftNeigbouringSum > x ) { int current_diff = LeftNeigbouringSum - x ; arr [ i ] = Math . Max ( 0 , arr [ i ] - current_diff ) ; total = total + current_diff ; } } return total ; }
int countPairs ( String s ) { HashSet < char > st = new HashSet < char > ( ) ; st . Add ( 'a' ) ; st . Add ( 'e' ) ; st . Add ( 'i' ) ; st . Add ( 'o' ) ; st . Add ( 'u' ) ; int count = 0 ; int n = s . Length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( st . Contains ( s [ i ] ) && ! st . Contains ( s [ i + 1 ] ) ) count ++ ; } return count ; }
int maxSize ( List < int > v , int n ) { v . Add ( 0 ) ; v . Add ( 100001 ) ; n += 2 ; v . Sort ( ) ; int mx = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int L = v [ i - 1 ] + 1 ; int R = v [ i + 1 ] - 1 ; int cnt = R - L + 1 ; mx = Math . Max ( mx , cnt ) ; } return mx ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
int maxLength ( int [ ] a , int n ) { int sum = 0 , len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } { return n ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { len = Math . Max ( len , Math . Max ( n - i - 1 , i ) ) ; } } return len ; }
int countMaxLength ( int N ) { int res ; int [ ] pre = new int [ MAXN ] ; int p = 1 ; pre [ 0 ] = 0 ; for ( int i = 1 ; i < MAXN ; i ++ ) { p *= 2 ; pre [ i ] = pre [ i - 1 ] + i * p ; } int ind = 0 ; for ( int i = 1 ; i < MAXN ; i ++ ) { if ( pre [ i ] >= N ) { ind = i ; break ; } } int x = N - pre [ ind - 1 ] ; int y = 2 * ind - 1 ; if ( x >= y ) res = Math . Min ( x , y ) ; else res = Math . Max ( x , 2 * ( ind - 2 ) + 1 ) ; return res ; }
int getMinVal ( int p , int q ) { if ( q % p == 0 ) return p ; return - 1 ; }
void findPoints ( int l1 , int r1 , int l2 , int r2 ) { int x = ( l1 != l2 ) ? Math . Min ( l1 , l2 ) : - 1 ; int y = ( r1 != r2 ) ? Math . Max ( r1 , r2 ) : - 1 ; Console . WriteLine ( x + " " + y ) ; }
int countPrimePalindrome ( string str , int len ) { bool [ ] prime = new bool [ len + 1 ] ; Array . Fill ( prime , true ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= len ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * p ; i <= len ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int j = 2 ; j <= len ; j ++ ) { if ( prime [ j ] ) { for ( int i = 0 ; i + j - 1 < len ; i ++ ) { if ( isPalindrome ( str , i , i + j - 1 ) ) count ++ ; } } } return count ; }
int minOperations ( int N ) { double x = Math . Log ( N , 2 ) ; int ans = ( int ) ( Math . Ceiling ( x ) ) ; return ans ; }
int find_greatest_divisor ( int l , int r ) { if ( l == r ) { return l ; } return 1 ; }
void findNumbers ( int [ ] arr , int n ) { int sumN = ( n * ( n + 1 ) ) / 2 ; int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq += ( int ) Math . Pow ( arr [ i ] , 2 ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; Console . WriteLine ( "A = " + A + "B=" }
int factorialUsingRecursion ( int n ) { if ( n == 0 ) return 1 ; return n * factorialUsingRecursion ( n - 1 ) ; }
int factorialUsingIteration ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
bool checkPerfectSquare ( double n ) { double d = Math . Sqrt ( n ) ; if ( d * d == n ) return true ; return false ; }
int largestPerfectSquareNumber ( int [ ] a , double n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkPerfectSquare ( a [ i ] ) ) maxi = Math . Max ( a [ i ] , maxi ) ; } return maxi ; }
void convert ( int n , int [ ] a ) { int z = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > z ) z = a [ i ] ; } z = z + 1 ; int [ ] ff = new int [ z ] ; for ( int i = 0 ; i < n ; i ++ ) { ff [ a [ i ] ] += 1 ; } int cc = 0 ; for ( int i = 0 ; i < z ; i ++ ) { cc += ( ff [ i ] / 4 ) ; ff [ i ] = ff [ i ] % 4 ; } int vv = 0 ; for ( int i = 0 ; i < z ; i ++ ) { if ( ff [ i ] >= 2 ) vv += 1 ; } cc += ( vv / 2 ) ; Console . WriteLine ( cc ) ; }
double getProbability ( double p , double q ) { p /= 100 ; q /= 100 ; double probability = ( p * p + q * q ) / ( p + q ) ; return probability ; }
bool check ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { return true ; } } return false ; }
int find_LCM ( int x , int y ) { return ( x * y ) / gcd ( x , y ) ; }
int CountPairs ( int n , int m , int A , int B ) { int cnt = 0 ; int lcm = find_LCM ( A , B ) ; for ( int i = 1 ; i <= n ; i ++ ) cnt += ( m + ( i % lcm ) ) / lcm ; return cnt ; }
void sortArr ( int [ ] arr , int n , int min , int max ) { int m = max - min + 1 ; int [ ] c = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ arr [ i ] - min ] ++ ; } for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < c [ i ] ; j ++ ) { Console . Write ( ( i + min ) + " " ) ; } } }
void revereseArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n / 2 ; i ++ ) arr [ i ] = __ ( arr [ n - i - 1 ] , arr [ n - i - 1 ] = arr [ i ] ) ; }
double recursiveLogStar ( double n , double b ) { if ( n > 1.0 ) return 1.0 + recursiveLogStar ( _log ( n , b ) , b ) ; else return 0 ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
double maxKth ( int [ ] arr , int N , int C , int K ) { if ( N + C < K ) { return - 1 ; } int iter = 300 ; double l = 0 , r = 1000000000.0 ; while ( iter -- > 0 ) { double mid = ( l + r ) * 0.5 ; double a = 0 ; double b = 0 ; for ( int i = 0 ; i < N ; i ++ ) { a += ( int ) ( ( double ) arr [ i ] / mid ) ; if ( ( double ) arr [ i ] >= mid ) { b ++ ; } } if ( a >= K && b + C >= K ) { l = mid ; } else { r = mid ; } } return l ; }
bool isPossibleToSelect ( int [ ] arr , int N , int dif , int K ) { int count = 1 ; int prev = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= ( prev + dif ) ) { count ++ ; if ( count == K ) return true ; prev = arr [ i ] ; } } return false ; }
int binarySearch ( int [ ] arr , int left , int right , int K , int N ) { int ans = 1 ; while ( left <= right ) { int dif = left + ( right - left ) / 2 ; if ( isPossibleToSelect ( arr , N , dif , K ) ) { ans = Math . Max ( ans , dif ) ; left = dif + 1 ; } else right = dif - 1 ; } return ans ; }
int cal ( List < int > arr , int mid ) { int chocolate = 0 ; foreach ( int i in arr ) { if ( i >= mid ) chocolate += i - mid ; } return chocolate ; }
bool check ( int [ ] bananas , int mid_val , int H ) { int time = 0 ; for ( int i = 0 ; i < bananas . Length ; i ++ ) { if ( bananas [ i ] % mid_val != 0 ) { time += ( ( bananas [ i ] / mid_val ) + 1 ) ; } else { time += ( bananas [ i ] / mid_val ) ; } } if ( time <= H ) { return true ; } else { return false ; } }
int minEatingSpeed ( int [ ] piles , int H ) { int start = 1 ; int end = piles . Max ( ) ; while ( start < end ) { int mid = start + ( end - start ) / 2 ; if ( ( check ( piles , mid , H ) ) == true ) { end = mid ; } else { start = mid + 1 ; } } return end ; }
bool is_prefix ( string temp , string str ) { if ( temp . Length < str . Length ) return false ; else { for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] != temp [ i ] ) return false ; } return true ; } }
string lexicographicallyString ( string [ ] input , int n , string str ) { Array . Sort ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { string temp = input [ i ] ; if ( is_prefix ( temp , str ) ) { return temp ; } } return "-1" ; }
int minSumPair ( int [ ] arr , int N ) { if ( N < 5 ) { return - 1 ; } int [ ] prefixMin = new int [ N ] ; prefixMin [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N - 1 ; i ++ ) { prefixMin [ i ] = Math . Min ( arr [ i ] , prefixMin [ i - 1 ] ) ; } int ans = int . MaxValue ; for ( int i = 3 ; i < N - 1 ; i ++ ) { ans = Math . Min ( ans , arr [ i ] + prefixMin [ i - 2 ] ) ; } return ans ; }
long check ( long [ ] H , long [ ] A , long mid , long N , long M , long L ) { long sum = 0 ; for ( long i = 0 ; i < N ; i ++ ) { long speed = mid * A [ ( int ) i ] + H [ ( int ) i ] ; if ( speed >= L ) { sum += speed ; } } return sum ; }
long buzzTime ( long N , long M , long L , long [ ] H , long [ ] A ) { long low = 0 , high = 100000000 ; long ans = 0 ; while ( high >= low ) { long mid = low + ( high - low ) / 2 ; if ( check ( H , A , mid , N , M , L ) >= M ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; }
void findCount ( string number ) { int sum = 0 ; for ( int i = 0 ; i < number . Length ; ++ i ) { sum += ( int ) number [ i ] - 48 ; } int count = 0 ; for ( int i = 0 ; i < number . Length ; ++ i ) { int remaining_sum = sum - ( ( int ) number [ i ] - 48 ) ; for ( int j = 0 ; j <= 9 ; ++ j ) { if ( ( remaining_sum + j ) % 3 == 0 && j != number [ i ] - 48 ) { ++ count ; } } } Console . Write ( count ) ; }
bool is_possible ( int [ ] teams , int T , int k ) { int sum = 0 ; for ( int i = 0 ; i < teams . Length ; i ++ ) { sum += Math . Min ( T , teams [ i ] ) ; } return ( sum >= ( T * k ) ) ; }
int countOfTeams ( int [ ] teams_list , int N , int K ) { int lb = 0 ; double ub = 1e9 ; while ( lb <= ub ) { int mid = lb + ( int ) ( ub - lb ) / 2 ; if ( is_possible ( teams_list , mid , K ) ) { if ( ! is_possible ( teams_list , mid + 1 , K ) ) { return mid ; } else { lb = mid + 1 ; } } else { ub = mid - 1 ; } } return 0 ; }
void balBracketSequence ( string str ) { int n = str . Length ; if ( str [ 0 ] == str [ n - 1 ] ) { Console . Write ( "No" ) ; } else { int cntForOpen = 0 , cntForClose = 0 ; int check = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) cntForOpen ++ ; else if ( str [ i ] == str [ n - 1 ] ) cntForOpen -- ; else cntForOpen ++ ; if ( cntForOpen < 0 ) { check = 0 ; break ; } } if ( check != 0 && cntForOpen == 0 ) { Console . Write ( "Yes, " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ n - 1 ] ) Console . Write ( ')' ) ; else Console . Write ( '(' ) ; } return ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) cntForClose ++ ; else cntForClose -- ; if ( cntForClose < 0 ) { check = 0 ; break ; } } if ( check != 0 && cntForClose == 0 ) { Console . Write ( "Yes, " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) Console . Write ( '(' ) ; else Console . Write ( ')' ) ; } return ; } } Console . Write ( "No" ) ; } }
void minimumOperations ( int [ ] arr , int N ) { int mx = 0 , pos = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= mx ) { mx = arr [ i ] ; pos = i ; } } Console . Write ( ( mx - 1 ) * N + pos + 1 ) ; }
bool check ( long v , long [ ] a ) { long tec = 0 , ans = 0 ; long [ ] b = new long [ ( int ) ( n + k + 1 ) ] ; for ( int i = 0 ; i < n ; i ++ ) { tec -= b [ i ] ; if ( a [ i ] + tec < v ) { long mov = v - a [ i ] - tec ; ans = ans + mov ; tec += mov ; b [ i + ( int ) k ] = mov ; } } return ans <= m ; }
long FindLargest ( long [ ] a ) { l = 1 ; r = ( long ) Math . Pow ( 10 , 10 ) ; while ( r - l > 0 ) { long tm = ( l + r + 1 ) / 2 ; if ( check ( tm , a ) ) l = tm ; else r = tm - 1 ; } return l ; }
int largestAltitude ( int L , int B ) { if ( L > B ) { int t = L ; L = B ; B = t ; } int low = 0 , high = L ; int res = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( mid <= ( B / 2 ) ) { res = mid ; low = mid + 1 ; } else high = mid - 1 ; } return res ; }
void findLargestIndex ( int [ ] arr , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == i ) { Console . Write ( i ) ; return ; } } Console . Write ( - 1 ) ; }
bool isMaximumMedian ( int [ , ] arr , int N , int K , int mid ) { int [ , ] Pre = new int [ N + 5 , N + 5 ] ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { Pre [ i + 1 , j + 1 ] = Pre [ i + 1 , j ] + Pre [ i , j + 1 ] - Pre [ i , j ] ; if ( arr [ i , j ] <= mid ) Pre [ i + 1 , j + 1 ] ++ ; } } int required = ( K * K + 1 ) / 2 ; bool flag = false ; for ( int i = K ; i <= N ; ++ i ) { for ( int j = K ; j <= N ; ++ j ) { int X = Pre [ i , j ] - Pre [ i - K , j ] - Pre [ i , j - K ] + Pre [ i - K , j - K ] ; if ( X < required ) flag = true ; } } return flag ; }
int getPairsCount ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] * a [ j ] ) == Math . Abs ( i - j ) ) count ++ ; } } return count ; }
int getPairsCount ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && ( arr [ i ] * arr [ j ] ) == Math . Abs ( i - j ) ) { count ++ ; } } } return count ; }
int numberofSubsequences ( int [ ] a , int L , int R , int X , int n ) { int ans = 0 ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int cnt = 0 , sum = 0 ; int minVal = Int32 . MaxValue , maxVal = Int32 . MinValue ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) == 0 ) { cnt += 1 ; sum += a [ j ] ; maxVal = Math . Max ( maxVal , a [ j ] ) ; minVal = Math . Min ( minVal , a [ j ] ) ; } } if ( cnt >= 2 && sum >= L && sum <= R && ( maxVal - minVal >= X ) ) { ans += 1 ; } } return ans ; }
void numberofBoxes ( int W , int B , int O ) { int low = 0 , high = Math . Min ( W , B ) ; int ans = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( ( ( W >= mid ) && ( B >= mid ) ) && ( ( W - mid ) + ( B - mid ) + O ) >= mid ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } Console . Write ( ans ) ; }
int minSwaps ( int N , int M , int [ , ] A , int [ , ] B ) { int count01 = 0 ; int count10 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( A [ i , j ] != B [ i , j ] ) { if ( A [ i , j ] == 1 ) count10 ++ ; else count01 ++ ; } } } if ( count01 == count10 ) return count01 ; else return - 1 ; }
int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int res = 0 ; int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * mid + mid ) / 2 ; if ( sum <= K ) { res = Math . Max ( res , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return res ; }
void createLoops ( Node root ) { preorderTraversal ( root ) ; int i ; for ( i = 1 ; i < even_ptrs . Count ; i ++ ) even_ptrs [ i - 1 ] . abtr = even_ptrs [ i ] ; even_ptrs [ i - 1 ] . abtr = even_ptrs [ 0 ] ; for ( i = 1 ; i < odd_ptrs . Count ; i ++ ) odd_ptrs [ i - 1 ] . abtr = odd_ptrs [ i ] ; odd_ptrs [ i - 1 ] . abtr = odd_ptrs [ 0 ] ; }
void traverseLoop ( Node start ) { Node curr = start ; do { Console . Write ( curr . data + " " ) ; curr = curr . abtr ; } while ( curr != start ) ; }
int repeatingElement ( int [ ] arr , int N ) { int M = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; M = Math . Max ( M , arr [ i ] ) ; } int sum1 = M * ( M + 1 ) / 2 ; int ans = ( sum - sum1 ) / ( N - M ) ; return ans ; }
string lexicographicallyMaximum ( string S , int N ) { Dictionary < char , int > M = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { if ( M . ContainsKey ( S [ i ] ) ) M [ S [ i ] ] ++ ; else M . Add ( S [ i ] , 1 ) ; } List < char > V = new List < char > ( ) ; for ( char i = 'a' ; i < ( char ) ( 'a' + Math . Min ( N , 25 ) ) ; ++ i ) { if ( M . ContainsKey ( i ) == false ) { V . Add ( i ) ; } } int j = V . Count - 1 ; for ( int i = 0 ; i < N ; ++ i ) { if ( S [ i ] >= ( 'a' + Math . Min ( N , 25 ) ) || ( M . ContainsKey ( S [ i ] ) && M [ S [ i ] ] > 1 ) ) { if ( V [ j ] < S [ i ] ) continue ; M [ S [ i ] ] -- ; S = S . Substring ( 0 , i ) + V [ j ] + S . Substring ( i + 1 ) ; j -- ; } if ( j < 0 ) break ; } int l = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( l > j ) break ; if ( S [ i ] >= ( 'a' + Math . Min ( N , 25 ) ) || M . ContainsKey ( S [ i ] ) && M [ S [ i ] ] > 1 ) { M [ S [ i ] ] -- ; S = S . Substring ( 0 , i ) + V [ l ] + S . Substring ( i + 1 ) ; l ++ ; } } return S ; }
void minimumK ( List < int > arr , int M , int N ) { int good = ( int ) ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) + 1 ; for ( int i = 1 ; i <= N ; i ++ ) { int K = i ; int candies = N ; int taken = 0 ; while ( candies > 0 ) { taken += Math . Min ( K , candies ) ; candies -= Math . Min ( K , candies ) ; for ( int j = 0 ; j < M ; j ++ ) { int consume = ( arr [ j ] * candies ) / 100 ; candies -= consume ; } } if ( taken >= good ) { Console . Write ( i ) ; return ; } } }
void minTimeToColor ( int node , int parent , int arrival_time ) { int current_time = 0 ; for ( int x = 0 ; x < edges [ node ] . Count ; x ++ ) { if ( edges [ node ] [ x ] != parent ) { ++ current_time ; if ( current_time == arrival_time ) ++ current_time ; ans = Math . Max ( ans , current_time ) ; minTimeToColor ( edges [ node ] [ x ] , node , current_time ) ; } } }
int countElement ( int [ ] arr , int N ) { int count = 1 ; Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( m . ContainsKey ( arr [ i ] ) ) m [ arr [ i ] ] ++ ; else m . Add ( arr [ i ] , 1 ) ; } for ( int i = 0 ; i < N ; i ++ ) { int lg = ( int ) Math . Log ( arr [ i ] ) ; int p = ( int ) Math . Pow ( 2 , lg ) ; if ( m . ContainsKey ( p ) ) { count ++ ; } } return count ; }
void findLarger ( int [ ] arr , int n ) { int mid = ( n + 1 ) / 2 ; int mx = Int32 . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > mx ) mx = arr [ i ] ; } int [ ] count = new int [ mx + 1 ] ; Array . Clear ( count , 0 , mx + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { count [ arr [ i ] ] ++ ; } for ( int i = mx ; i >= 0 ; i -- ) { while ( count [ i ] > 0 ) { count [ i ] -- ; mid -- ; Console . Write ( i + " " ) ; if ( mid == 0 ) break ; } if ( mid == 0 ) break ; } }
int maximizeMangoes ( int n , int m , int x , int y ) { int l = 0 , r = n ; int ans = 0 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( check ( n , m , x , y , mid ) ) { ans = mid ; l = mid + 1 ; } else r = mid - 1 ; } return ans ; }
double probability ( int [ ] arr1 , int [ ] arr2 ) { int N = arr1 . Length ; int M = arr2 . Length ; double res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int y = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr2 [ j ] > arr1 [ i ] ) y ++ ; } res += y ; } res = ( double ) res / ( double ) ( N * M ) ; return res ; }
double probability ( int [ ] arr1 , int [ ] arr2 ) { int N = arr1 . Length ; int M = arr2 . Length ; double res = 0 ; Array . Sort ( arr2 ) ; for ( int i = 0 ; i < N ; i ++ ) { int y = countGreater ( arr2 , arr1 [ i ] ) ; res += y ; } res = ( double ) res / ( double ) ( N * M ) ; return res ; }
int countGreater ( int [ ] arr , int k ) { int n = arr . Length ; int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; }
int findkthElement ( int [ ] arr , int n , int K ) { int l = 0 ; int h = n - 1 , r ; while ( l + 1 < h ) { int mid = ( l + h ) / 2 ; if ( arr [ l ] >= arr [ mid ] ) l = mid ; else h = mid ; } if ( arr [ l ] < arr [ h ] ) r = l ; else r = h ; if ( K <= r + 1 ) return arr [ r + 1 - K ] ; else return arr [ n - ( K - ( r + 1 ) ) ] ; }
int find ( List < int > arr , int N , int key ) { int l = 0 ; int h = N - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] >= arr [ mid ] ) { if ( arr [ l ] >= key && key >= arr [ mid ] ) h = mid - 1 ; else l = mid + 1 ; } else { if ( arr [ mid ] >= key && key >= arr [ h ] ) l = mid + 1 ; else h = mid - 1 ; } } return - 1 ; }
void countInversions ( int [ ] arr , int n ) { List < int > v = new List < int > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { v . Add ( i ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int itr = v . IndexOf ( arr [ i ] ) ; ans += itr ; v . RemoveAt ( itr ) ; } Console . WriteLine ( ans ) ; }
void countDistinct ( List < int > arr , int L , int R ) { int count = 0 ; int [ ] pref = new int [ arr . Count + 1 ] ; for ( int i = 1 ; i <= arr . Count ; ++ i ) { count += arr [ i - 1 ] ; pref [ i ] = count ; } int left = binarysearch ( pref , arr . Count + 1 , L ) ; int right = binarysearch ( pref , arr . Count + 1 , R ) ; Console . Write ( right - left + 1 ) ; }
bool ischar ( char x ) { if ( ( x >= 'A' && x <= 'Z' ) || ( x >= 'a' && x <= 'z' ) ) { return true ; } return false ; }
bool isnum ( char x ) { if ( x >= '0' && x <= '9' ) return true ; return false ; }
void maxItems ( int n , int m , int [ ] a , int [ ] b , int K ) { int count = 0 ; int [ ] A = new int [ n + 1 ] ; int [ ] B = new int [ m + 1 ] ; A [ 0 ] = 0 ; B [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { A [ i ] = a [ i - 1 ] + A [ i - 1 ] ; } for ( int i = 1 ; i <= m ; i ++ ) { B [ i ] = b [ i - 1 ] + B [ i - 1 ] ; } for ( int i = 0 ; i <= n ; i ++ ) { if ( A [ i ] > K ) break ; int rem = K - A [ i ] ; int j = 0 ; int lo = 0 , hi = m ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; if ( B [ mid ] <= rem ) { j = mid ; lo = mid + 1 ; } else { hi = mid - 1 ; } } count = Math . Max ( j + i , count ) ; } Console . Write ( count ) ; }
bool isValid ( int [ ] weight , int n , int D , int mx ) { int st = 1 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += weight [ i ] ; if ( sum > mx ) { st ++ ; sum = weight [ i ] ; } if ( st > D ) return false ; } return true ; }
void shipWithinDays ( int [ ] weight , int D , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += weight [ i ] ; int s = weight [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s = Math . Max ( s , weight [ i ] ) ; } int e = sum ; int res = - 1 ; while ( s <= e ) { int mid = s + ( e - s ) / 2 ; if ( isValid ( weight , n , D , mid ) ) { res = mid ; e = mid - 1 ; } else s = mid + 1 ; } Console . WriteLine ( res ) ; }
int countWays ( int index , int target ) { if ( target == 0 ) return 1 ; if ( index < 0 target < 0 ) return 0 ; int inc = countWays ( index , target - ( int ) psquare [ index ] ) ; int exc = countWays ( index - 1 , target ) ; return inc + exc ; }
int findSum ( int [ ] arr , int N , int pt ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += Math . Abs ( arr [ i ] - pt ) ; } return sum ; }
void findArray ( int [ ] arr , int n ) { List < int > v = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int ans = - 1 , old_c = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { int curr_c = 0 ; for ( int k = j ; k < n ; k ++ ) { if ( arr [ k ] == arr [ j ] ) { curr_c ++ ; } } ; if ( curr_c == old_c ) { if ( arr [ j ] < ans ) ans = arr [ j ] ; } if ( curr_c > old_c ) { ans = arr [ j ] ; old_c = curr_c ; } } } v . Add ( ans ) ; } for ( int i = 0 ; i < v . Count ; i ++ ) Console . Write ( v [ i ] + " " ) ; }
void minDays ( int [ ] P , int [ ] arr ) { for ( int i = 1 ; i < P . Length ; i ++ ) { P [ i ] += P [ i ] + P [ i - 1 ] ; } for ( int i = 0 ; i < arr . Length ; i ++ ) { int index = binarySeach ( P , arr [ i ] ) ; if ( index != - 1 ) { Console . Write ( index + 1 + " " ) ; } else { Console . Write ( - 1 + " " ) ; } } }
int countTriplets ( int D , int [ ] arr ) { Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; int ans = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( freq . ContainsKey ( arr [ i ] - D ) && freq . ContainsKey ( arr [ i ] - 2 * D ) ) { ans += freq [ arr [ i ] - D ] * freq [ arr [ i ] - 2 * D ] ; } if ( ! freq . ContainsKey ( arr [ i ] ) ) freq [ arr [ i ] ] = 0 ; freq [ arr [ i ] ] ++ ; } return ans ; }
int find_index ( int [ ] arr , int N ) { int max_value = Int32 . MinValue ; for ( int i = 0 ; i < N ; i ++ ) { max_value = Math . Max ( max_value , arr [ i ] ) ; } Dictionary < int , int > store = new Dictionary < int , int > ( ) ; for ( int i = 1 ; i <= max_value ; i ++ ) { if ( ! store . ContainsKey ( i ) ) store [ i ] = 0 ; store [ i ] ++ ; } if ( store . ContainsKey ( 1 ) ) { store . Remove ( 1 ) ; } for ( int i = 2 ; i <= Math . Sqrt ( max_value ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= max_value ) { if ( store . ContainsKey ( i * multiple ) ) { store . Remove ( i * multiple ) ; } multiple ++ ; } } int prime_sum_from_left = 0 ; int [ ] first_array = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { first_array [ i ] = prime_sum_from_left ; if ( store . ContainsKey ( arr [ i ] ) ) { prime_sum_from_left += arr [ i ] ; } } int prime_sum_from_right = 0 ; int [ ] second_array = new int [ N ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) { second_array [ i ] = prime_sum_from_right ; if ( store . ContainsKey ( arr [ i ] ) ) { prime_sum_from_right += arr [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( first_array [ i ] == second_array [ i ] ) { return i ; } } return - 1 ; }
void convert ( int [ ] arr , int n ) { int [ ] brr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; Array . Sort ( brr ) ; for ( int i = 0 ; i < n ; i ++ ) { int l = 0 , r = n - 1 , mid ; while ( l <= r ) { mid = ( l + r ) / 2 ; if ( brr [ mid ] == arr [ i ] ) { Console . Write ( mid + " " ) ; break ; } else if ( brr [ mid ] < arr [ i ] ) { l = mid + 1 ; } else { r = mid - 1 ; } } } }
int findIndex ( int [ ] arr , int N ) { int maxValue = Int32 . MinValue ; for ( int i = 0 ; i < N ; i ++ ) { maxValue = Math . Max ( maxValue , arr [ i ] ) ; } Dictionary < int , int > St = new Dictionary < int , int > ( ) ; for ( int i = 1 ; i <= maxValue ; i ++ ) { St . Add ( i , 1 ) ; } if ( St . ContainsKey ( 1 ) ) { St . Remove ( 1 ) ; } for ( int i = 2 ; i <= Math . Sqrt ( maxValue ) ; i ++ ) { int j = 2 ; while ( ( i * j ) <= maxValue ) { if ( St . ContainsKey ( i * j ) ) { St . Remove ( i * j ) ; } j ++ ; } } int LeftCount = 0 ; int [ ] Prefix = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { Prefix [ i ] = LeftCount ; if ( St . ContainsKey ( arr [ i ] ) ) { LeftCount ++ ; } } int RightCount = 0 ; int [ ] Suffix = new int [ N ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) { Suffix [ i ] = RightCount ; if ( St . ContainsKey ( arr [ i ] ) ) { RightCount ++ ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( Prefix [ i ] == Suffix [ i ] ) { return i ; } } return - 1 ; }
int getCountPairs ( int [ ] arr , int N , int S ) { int count = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { for ( int j = i + 1 ; j < arr . Length ; j ++ ) { if ( ( arr [ i ] + arr [ j ] ) == S ) count ++ ; } } return count ; }
bool isPrime ( int N ) { if ( N == 1 ) return false ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; }
int findCoPrime ( int L , int R ) { int coPrime ; for ( int i = R + 1 ; ; i ++ ) { if ( isPrime ( i ) ) { coPrime = i ; break ; } } return coPrime ; }
void replaceCharacters ( string s , char [ , ] p ) { int n = s . Length , k = p . GetLength ( 0 ) ; char [ ] arr = new char [ 26 ] ; char [ ] brr = new char [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ s [ i ] - 'a' ] = s [ i ] ; brr [ s [ i ] - 'a' ] = s [ i ] ; } for ( int j = 0 ; j < k ; j ++ ) { char a = p [ j , 0 ] , b = p [ j , 1 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( arr [ i ] == a ) { brr [ i ] = b ; } } } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( brr [ s [ i ] - 'a' ] ) ; } }
void maximumValue ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { ans = Math . Max ( ans , arr [ i ] + arr [ j ] + i - j ) ; } } Console . Write ( ans ) ; }
void maximumValue ( int [ ] arr , int n ) { int maxvalue = arr [ 0 ] ; int result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { result = Math . Max ( result , maxvalue + arr [ i ] - i ) ; maxvalue = Math . Max ( maxvalue , arr [ i ] + i ) ; } Console . Write ( result ) ; }
void smallestSemiPrime ( int n ) { bool [ ] prime = new bool [ MAX ] ; for ( int i = 0 ; i < prime . Length ; i ++ ) { prime [ i ] = true ; } SieveOfEratosthenes ( prime ) ; int num1 = n + 1 ; while ( prime [ num1 ] != true ) { num1 ++ ; } int num2 = num1 + n ; while ( prime [ num2 ] != true ) { num2 ++ ; } Console . Write ( num1 * num2 ) ; }
void productOfTwoPerfectCubes ( int N ) { Dictionary < int , int > cubes = new Dictionary < int , int > ( ) ; for ( int i = 1 ; i * i * i <= N ; i ++ ) { cubes . Add ( i * i * i , i ) ; } foreach ( KeyValuePair < int , int > kvp in cubes ) { int firstNumber = kvp . Key ; if ( N % kvp . Key == 0 ) { int secondNumber = N / kvp . Key ; if ( cubes . ContainsKey ( secondNumber ) ) { Console . Write ( "Yes" ) ; return ; } } } Console . Write ( "No" ) ; }
void productOfTwoPerfectCubes ( double N ) { double cube_root ; cube_root = Math . Round ( Math . Cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { Console . Write ( "Yes" ) ; return ; } else { Console . Write ( "No" ) ; return ; } }
bool bound ( int w , int h , int N , int x ) { int val = ( x / w ) * ( x / h ) ; if ( val >= N ) return true ; else return false ; }
int FindSquare ( int N , int W , int H ) { int i = 1 ; int j = W * H * N ; while ( i < j ) { int mid = i + ( j - i ) / 2 ; if ( bound ( W , H , N , mid ) ) j = mid ; else i = mid + 1 ; } return j ; }
void printNumberOfPairs ( int N ) { HashSet < int > st = new HashSet < int > ( ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { int x = i ; while ( x <= N ) { x *= i ; if ( x <= N ) { st . Add ( x ) ; } } } Console . WriteLine ( st . Count ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
void maximumProduct ( string [ ] words ) { int [ ] bits = new int [ words . Length ] ; for ( int i = 0 ; i < words . Length ; i ++ ) { for ( int j = 0 ; j < words [ i ] . Length ; j ++ ) { bits [ i ] = bits [ i ] | 1 << ( words [ i ] [ j ] - 'a' ) ; } } int result = 0 ; for ( int i = 0 ; i < bits . Length ; i ++ ) { for ( int j = i + 1 ; j < bits . Length ; j ++ ) { if ( ( bits [ i ] & bits [ j ] ) == 0 ) { int L = countSetBits ( bits [ i ] ) ; int R = countSetBits ( bits [ j ] ) ; result = Math . Max ( L * R , result ) ; } } } Console . WriteLine ( result ) ; }
int closestValue ( int [ ] A , int k ) { int close = A [ A . Length - 1 ] ; int it = lower_bound ( A , k ) ; if ( it != A . Length ) { close = A [ it ] ; if ( it != 0 ) { if ( ( k - A [ it - 1 ] ) < ( close - k ) ) { close = A [ it - 1 ] ; } } } return close ; }
void minPossible ( int [ ] arr , int [ ] brr , int [ ] crr ) { Array . Sort ( arr ) ; Array . Sort ( crr ) ; int minimum = Int32 . MaxValue ; foreach ( int val in brr ) { int arr_close = closestValue ( arr , val ) ; int crr_close = closestValue ( crr , val ) ; if ( Math . Abs ( val - arr_close ) + Math . Abs ( val - crr_close ) < minimum ) minimum = Math . Abs ( val - arr_close ) + Math . Abs ( val - crr_close ) ; } Console . WriteLine ( minimum ) ; }
int findCost ( int [ ] A , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; }
bool palindrome ( string str ) { int st = 0 ; int ed = str . Length - 1 ; while ( st < ed ) { if ( str [ st ] == str [ ed ] ) { st ++ ; ed -- ; } else return false ; } return true ; }
bool possible ( int [ ] A , int N , int mid , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { count += ( A [ i ] - 1 ) / mid ; } return count <= K ; }
int minimumMaximum ( int [ ] A , int N , int K ) { int lo = 1 ; Array . Sort ( A ) ; int hi = A [ N - 1 ] ; int mid ; while ( lo < hi ) { mid = ( lo + hi ) / 2 ; if ( possible ( A , N , mid , K ) ) { hi = mid ; } else { lo = mid + 1 ; } } return hi ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
void sumOfPrimeSquare ( int n ) { int i = 0 ; List < int > squares = new List < int > ( ) ; while ( i * i < n ) { squares . Add ( i * i ) ; i ++ ; } bool flag = false ; for ( i = 0 ; i < squares . Count ; i ++ ) { int difference = n - squares [ i ] ; if ( isPrime ( difference ) ) { flag = true ; break ; } } if ( flag ) { Console . Write ( "Yes" ) ; } else Console . Write ( "No" ) ; }
void SieveOfEratosthenes ( bool [ ] prime , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } }
void sumOfPrimeSquare ( int n ) { bool flag = false ; bool [ ] prime = new bool [ n + 1 ] ; Array . Fill ( prime , true ) ; SieveOfEratosthenes ( prime , n ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ! prime [ i ] ) continue ; int dif = n - i ; if ( Math . Ceiling ( ( double ) Math . Sqrt ( dif ) ) == Math . Floor ( ( double ) Math . Sqrt ( dif ) ) ) { flag = true ; break ; } } if ( flag ) { Console . WriteLine ( "Yes" ) ; } else Console . WriteLine ( "No" ) ; }
int minimum_swaps ( int [ ] arr , int n ) { int count = 0 ; int max_el = arr . Max ( ) ; int min_el = arr . Min ( ) ; if ( min_el == max_el ) return 0 ; int index_max = - 1 ; int index_min = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max_el && index_max == - 1 ) { index_max = i ; } if ( arr [ i ] == min_el ) { index_min = i ; } } count += index_max ; count += ( n - 1 - index_min ) ; if ( index_min < index_max ) count -= 1 ; return count ; }
bool check ( int [ ] arr , int M , int K , int ind ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 1 ; j < K ; j ++ ) { if ( arr [ ind + i ] != arr [ ind + i + j * M ] ) { return false ; } } } return true ; }
bool SubarrayRepeatsKorMore ( int [ ] arr , int N , int M , int K ) { for ( int ind = 0 ; ind <= N - M * K ; ind ++ ) { if ( check ( arr , M , K , ind ) ) { return true ; } } return false ; }
bool checkExists ( int [ ] arr , int N , int M , int K ) { int count = 0 ; for ( int i = 0 ; i < N - M ; i ++ ) { if ( arr [ i ] == arr [ i + M ] ) count ++ ; else count = 0 ; if ( count == M * ( K - 1 ) ) return true ; } return false ; }
int CommonDigits ( int N , int M ) { int count = 0 ; int [ ] freq1 = new int [ 10 ] ; int [ ] freq2 = new int [ 10 ] ; while ( N > 0 ) { freq1 [ N % 10 ] ++ ; N = N / 10 ; } while ( M > 0 ) { freq2 [ M % 10 ] ++ ; M = M / 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( freq1 [ i ] > 0 & freq2 [ i ] > 0 ) { count ++ ; } } return count ; }
void minimumNumber ( int K , int X ) { if ( K > X ) { Console . Write ( "-1" ) ; return ; } int ans = 0 ; int sum = 0 ; for ( int i = K ; i <= X ; i ++ ) { sum += i ; if ( sum >= X ) { ans = i ; break ; } } Console . Write ( ans ) ; }
bool isGreaterEqual ( int N , int K , int X ) { return ( ( N * 1L * ( N + 1 ) / 2 ) - ( ( K - 1 ) * 1L * K / 2 ) ) >= X ; }
int left_search ( List < int > A , int num ) { int low = 0 , high = A . Count - 1 ; int ans = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( A [ mid ] >= num ) { ans = mid ; high = mid - 1 ; } else { low = mid + 1 ; } } return ans ; }
void totalCount ( int [ , ] A , int N , int M , int [ , ] queries , int Q ) { int [ ] row_sum = new int [ N ] ; int [ ] col_sum = new int [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { row_sum [ i ] += A [ i , j ] ; col_sum [ j ] += A [ i , j ] ; } } List < int > sum_list = new List < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) sum_list . Add ( row_sum [ i ] ) ; for ( int i = 0 ; i < M ; i ++ ) sum_list . Add ( col_sum [ i ] ) ; sum_list . Sort ( ) ; for ( int i = 0 ; i < Q ; i ++ ) { int L = queries [ i , 0 ] ; int R = queries [ i , 1 ] ; int l = left_search ( sum_list , L ) ; int r = right_search ( sum_list , R ) ; Console . Write ( r - l + 1 + " " ) ; } }
int search ( List < int > list , int num ) { int low = 0 , high = list . Count - 1 ; int ans = - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( list [ mid ] <= num ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
bool isPalindrome ( int n ) { int rev = 0 ; int temp = n ; while ( n > 0 ) { rev = rev * 10 + n % 10 ; n /= 10 ; } return rev == temp ; }
int countNumbers ( int L , int R , int K ) { List < int > list = new List < int > ( ) ; for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) ) { list . Add ( i ) ; } } int count = 0 ; for ( int i = 0 ; i < list . Count ; i ++ ) { int right_index = search ( list , list [ i ] + K - 1 ) ; if ( right_index != - 1 ) count = Math . Max ( count , right_index - i + 1 ) ; } return count ; }
int maximumLength ( int [ , ] mat , int v ) { distance = 0 ; int N = mat . GetLength ( 0 ) ; List < bool > visited = new List < bool > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { visited . Add ( false ) ; } List < List < int > > Adj = new List < List < int > > ( N ) ; for ( int i = 0 ; i < N ; i ++ ) { Adj . Add ( new List < int > ( ) ) ; } for ( int i = 0 ; i < mat . GetLength ( 0 ) ; i ++ ) { for ( int j = 0 ; j < mat . GetLength ( 0 ) ; j ++ ) { if ( mat [ i , j ] == 1 ) { Adj [ i ] . Add ( j ) ; } } } dfs ( v , Adj , visited , 0 ) ; return distance ; }
void getMaximumDifference ( int [ , ] Edges , int [ ] arr , int N , int M ) { ans = 0 ; List < List < int > > Adj = new List < List < int > > ( ) ; for ( int i = 0 ; i < N + 1 ; i ++ ) Adj . Add ( new List < int > ( ) ) ; for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i , 0 ] ; int v = Edges [ i , 1 ] ; Adj [ u ] . Add ( v ) ; } DFS ( 1 , Adj , arr , arr [ 0 ] , arr [ 0 ] ) ; Console . WriteLine ( ans ) ; }
int minimumDeletions ( string S ) { int len = 0 ; int n = S . Length ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = i + 1 ; j < 26 ; j ++ ) { int newLen = findLength ( S , ( char ) ( i + 97 ) , ( char ) ( j + 97 ) ) ; len = Math . Max ( len , newLen ) ; } } return n - len ; }
int findMinX ( int [ ] A , int [ ] B , int N ) { int prod = 1 ; for ( int i = 0 ; i < N ; i ++ ) prod *= A [ i ] ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int pp = prod / A [ i ] ; result += B [ i ] * inv ( pp , A [ i ] ) * pp ; } return result % prod ; }
void findPairs ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = Math . Abs ( arr [ i ] ) ; Array . Sort ( arr ) ; int left = 0 ; int ans = 0 ; for ( int right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } Console . Write ( ans ) ; }
int GetDiff ( int [ ] A , int N ) { int [ ] SuffMaxArr = new int [ N ] ; SuffMaxArr [ N - 1 ] = A [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; -- i ) { SuffMaxArr [ i ] = Math . Max ( SuffMaxArr [ i + 1 ] , A [ i + 1 ] ) ; } int MaximumSum = Int32 . MinValue ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < SuffMaxArr [ i ] ) MaximumSum = Math . Max ( MaximumSum , A [ i ] + SuffMaxArr [ i ] ) ; } int MinimumSum = Int32 . MaxValue ; int [ ] SuffMinArr = new int [ N ] ; SuffMinArr [ N - 1 ] = Int32 . MaxValue ; for ( int i = N - 2 ; i >= 0 ; -- i ) { SuffMinArr [ i ] = Math . Min ( SuffMinArr [ i + 1 ] , A [ i + 1 ] ) ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < SuffMinArr [ i ] ) { MinimumSum = Math . Min ( MinimumSum , A [ i ] + SuffMinArr [ i ] ) ; } } return Math . Abs ( MaximumSum - MinimumSum ) ; }
void minimumSwaps ( int [ ] arr , int N ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != i % 2 ) { if ( i % 2 == 0 ) { even ++ ; } else { odd ++ ; } } } if ( even != odd ) { Console . WriteLine ( - 1 ) ; } else { Console . WriteLine ( even ) ; } }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void primeFactorSum ( int [ ] arr , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( k % arr [ i ] == 0 && isPrime ( arr [ i ] ) ) { sum = sum + arr [ i ] ; } } Console . Write ( sum ) ; }
void CalculateValues ( int N ) { int A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { Console . Write ( "A = " + A / 3 + ", B = " + B + ", C = " + C ) ; return ; } } } Console . WriteLine ( - 1 ) ; }
int mininsert ( int [ ] arr , int K , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = Math . Min ( arr [ i ] , arr [ i + 1 ] ) ; int b = Math . Max ( arr [ i ] , arr [ i + 1 ] ) ; while ( K * a < b ) { a *= K ; ans ++ ; } } return ans ; }
void makeLexicographically ( int [ ] arr , int length ) { int index = 0 ; int temp = 0 ; int check = 0 ; int condition = 0 ; int element = 0 ; for ( int i = 0 ; i < length ; ++ i ) { if ( element == arr [ i ] ) { check = i ; break ; } else if ( arr [ i ] != i + 1 && check == 0 ) { index = i ; check = 1 ; condition = - 1 ; element = i + 1 ; } } if ( condition == - 1 ) { temp = arr [ index ] ; arr [ index ] = arr [ check ] ; arr [ check ] = temp ; } print ( arr ) ; }
void print_triplet ( int [ ] arr , int n ) { for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { Console . Write ( i - 1 + " " + i + " " + ( i + 1 ) ) ; return ; } } Console . Write ( - 1 ) ; }
void findConcatenatedNumbers ( int [ ] a , int [ ] b ) { bool ans = true ; int n1 = a . Length ; int n2 = b . Length ; int [ ] cnt = new int [ 100000 ] ; for ( int i = 0 ; i < n1 ; i ++ ) { cnt [ a [ i ] ] = 1 ; } for ( int i = 0 ; i < n2 ; i ++ ) { int left = b [ i ] ; int right = 0 ; int mul = 1 ; while ( left > 9 ) { right += ( left % 10 ) * mul ; left /= 10 ; mul *= 10 ; if ( cnt [ left ] == 1 && cnt [ right ] == 1 ) { ans = false ; Console . Write ( b [ i ] + " " ) ; } } } if ( ans ) Console . Write ( "-1" ) ; }
void evenproduct ( int [ ] arr , int length ) { int count = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { int product = 1 ; for ( int j = i ; j < arr . Length ; j ++ ) { product *= arr [ j ] ; if ( product % 2 == 0 ) ++ count ; } } Console . WriteLine ( count ) ; }
void evenproduct ( int [ ] arr , int length ) { int total_subarray = length * ( length + 1 ) / 2 ; int total_odd = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < arr . Length ; ++ i ) { if ( arr [ i ] % 2 == 0 ) { count_odd = 0 ; } else { ++ count_odd ; total_odd += count_odd ; } } Console . WriteLine ( total_subarray - total_odd ) ; }
void dfsUtil ( int u , int par , int depth ) { foreach ( int it in adj [ u ] ) { if ( it != par ) { dfsUtil ( it , u , depth + 1 ) ; } } ans += depth ; }
bool isInGroupUtil ( int [ , ] mat ) { for ( int i = 0 ; i < mat . GetLength ( 1 ) ; i ++ ) { List < int > arr = new List < int > ( ) ; for ( int j = 0 ; j < mat . GetLength ( 0 ) ; j ++ ) { arr . Add ( mat [ i , j ] ) ; } if ( ! checkGroup ( arr ) ) return false ; } return true ; }
void isInGroup ( int [ , ] mat ) { bool ans = isInGroupUtil ( mat ) ; if ( ans ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
int convertBinaryToDecimal ( List < int > arr ) { int ans = 0 ; foreach ( int i in arr ) ans = ( ans << 1 ) | i ; return ans ; }
void decimalEquilvalentAtEachLevel ( TreeNode root ) { int ans = 0 ; Queue < TreeNode > que = new Queue < TreeNode > ( ) ; que . Enqueue ( root ) ; while ( true ) { int length = que . Count ; if ( length == 0 ) break ; List < int > eachLvl = new List < int > ( ) ; while ( length > 0 ) { TreeNode temp = que . Peek ( ) ; que . Dequeue ( ) ; eachLvl . Add ( temp . val ) ; if ( temp . left != null ) que . Enqueue ( temp . left ) ; if ( temp . right != null ) que . Enqueue ( temp . right ) ; length -= 1 ; } ans += convertBinaryToDecimal ( eachLvl ) ; } Console . WriteLine ( ans ) ; }
void countSubstrings ( string s ) { int ans = 0 ; int subs = 1 ; char pre = '0' ; foreach ( char i in s ) { if ( pre == i ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = i ; } Console . WriteLine ( ans ) ; }
void longestSequence ( int [ ] arr , int N ) { if ( N == 0 ) { Console . WriteLine ( 0 ) ; return ; } Array . Sort ( arr ) ; int maxLen = 1 ; int len = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] arr [ i ] == arr [ i - 1 ] + 1 ) { len ++ ; maxLen = Math . Max ( maxLen , len ) ; } else { len = 1 ; } } Console . WriteLine ( maxLen ) ; }
void minimumOperations ( int [ ] arr , int N ) { int oddCnt = 0 , evenCnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCnt ++ ; } else { oddCnt ++ ; } } Console . Write ( Math . Min ( oddCnt , evenCnt ) ) ; }
int productOfDigits ( int N ) { int product = 1 ; while ( N != 0 ) { product = product * ( N % 10 ) ; N = N / 10 ; } return product ; }
void hasArrayTwoPairs ( int [ ] nums , int n , int target ) { Array . Sort ( nums ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = target - nums [ i ] ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = low + ( ( high - low ) / 2 ) ; if ( nums [ mid ] > x ) { high = mid - 1 ; } else if ( nums [ mid ] < x ) { low = mid + 1 ; } else { if ( mid == i ) { if ( ( mid - 1 >= 0 ) && nums [ mid - 1 ] == x ) { Console . Write ( nums [ i ] + ", " ) ; Console . Write ( nums [ mid - 1 ] ) ; return ; } if ( ( mid + 1 < n ) && nums [ mid + 1 ] == x ) { Console . Write ( nums [ i ] + ", " ) ; Console . Write ( nums [ mid + 1 ] ) ; return ; } break ; } else { Console . Write ( nums [ i ] + ", " ) ; Console . Write ( nums [ mid ] ) ; return ; } } } } Console . Write ( - 1 ) ; }
void minSum ( int [ ] arr , int N , int [ ] Q , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int val = Q [ i ] ; int front = 0 , rear = 0 ; for ( int j = 0 ; j < N ; j ++ ) { front += arr [ j ] ; if ( arr [ j ] == val ) { break ; } } for ( int j = N - 1 ; j >= 0 ; j -- ) { rear += arr [ j ] ; if ( arr [ j ] == val ) { break ; } } Console . Write ( Math . Min ( front , rear ) + " " ) ; } }
void minOperations ( int [ ] arr , int N , int [ ] Q , int M ) { Dictionary < int , int > m1 = new Dictionary < int , int > ( ) ; Dictionary < int , int > m2 = new Dictionary < int , int > ( ) ; int front = 0 , rear = 0 ; for ( int i = 0 ; i < N ; i ++ ) { front += arr [ i ] ; m1 [ arr [ i ] ] = front ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { rear += arr [ i ] ; m2 [ arr [ i ] ] = rear ; } for ( int i = 0 ; i < M ; i ++ ) { Console . Write ( Math . Min ( m1 [ Q [ i ] ] , m2 [ Q [ i ] ] ) + " " ) ; } }
bool checkAnagram ( string s1 , string s2 ) { List < int > s2hash = new List < int > ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) s2hash . Add ( 0 ) ; List < int > s1hash = new List < int > ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) s1hash . Add ( 0 ) ; int s1len = s1 . Length ; int s2len = s2 . Length ; if ( s1len > s2len ) return false ; int left = 0 , right = 0 ; while ( right < s1len ) { s1hash [ s1 [ right ] - 'a' ] += 1 ; s2hash [ s2 [ right ] - 'a' ] += 1 ; right ++ ; } right -= 1 ; while ( right < s2len ) { if ( s1hash == s2hash ) return true ; right ++ ; if ( right != s2len ) s2hash [ s2 [ right ] - 'a' ] += 1 ; s2hash [ s2 [ left ] - 'a' ] -= 1 ; left ++ ; } return false ; }
void findSubstring ( string S ) { string T = "" ; string ans = "" ; int l = 0 ; T += S [ 0 ] ; for ( int i = 1 ; i < S . Length ; i ++ ) { if ( Math . Abs ( S [ i ] - S [ i - 1 ] ) == 1 ) { l = T . Length ; if ( l > ans . Length ) { ans = T ; } T = "" ; T += S [ i ] ; } else { T += S [ i ] ; } } l = T . Length ; if ( l > ans . Length ) { ans = T ; } Console . Write ( ans ) ; }
void DFS ( int row , int col , int [ , ] grid , int M , int N ) { bool [ , ] vis = new bool [ M + 1 , N + 1 ] ; for ( int i = 0 ; i < M + 1 ; i ++ ) { for ( int j = 0 ; j < N + 1 ; j ++ ) { vis [ i , j ] = false ; } } DFSUtil ( 0 , 0 , grid , vis , M , N ) ; }
void DFS_iterative ( int [ , ] grid , int M , int N ) { vis = new List < List < bool > > ( ) ; for ( int i = 0 ; i < M + 5 ; i ++ ) { vis . Add ( new List < bool > ( ) ) ; for ( int j = 0 ; j < N + 5 ; j ++ ) { vis [ i ] . Add ( false ) ; } } List < Tuple < int , int > > st = new List < Tuple < int , int > > ( ) ; st . Add ( new Tuple < int , int > ( 0 , 0 ) ) ; vis [ 0 ] [ 0 ] = true ; while ( st . Count > 0 ) { Tuple < int , int > p = st [ st . Count - 1 ] ; st . RemoveAt ( st . Count - 1 ) ; int row = p . Item1 ; int col = p . Item2 ; Console . Write ( grid [ row , col ] + " " ) ; for ( int i = 0 ; i < 4 ; i ++ ) { int x = row + dRow [ i ] ; int y = col + dCol [ i ] ; if ( isValid ( x , y , M , N ) ) { st . Add ( new Tuple < int , int > ( x , y ) ) ; vis [ x ] [ y ] = true ; } } } }
void suffixArr ( int [ ] arr , int [ , ] suffix , int N ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 ) { suffix [ i , 0 ] = arr [ i ] ; suffix [ i , 1 ] = arr [ i ] ; } else { suffix [ i , 0 ] = Math . Max ( suffix [ i + 1 , 0 ] , arr [ i ] ) ; suffix [ i , 1 ] = Math . Min ( suffix [ i + 1 , 1 ] , arr [ i ] ) ; } } }
void MinMaxQueries ( int [ ] a , int [ , ] Q ) { int N = a . GetLength ( 0 ) ; int q = Q . GetLength ( 0 ) ; int [ , ] prefix = new int [ N , 2 ] ; int [ , ] suffix = new int [ N , 2 ] ; prefixArr ( a , prefix , N ) ; suffixArr ( a , suffix , N ) ; for ( int i = 0 ; i < q ; i ++ ) { int L = Q [ i , 0 ] ; int R = Q [ i , 1 ] ; maxAndmin ( prefix , suffix , N , L , R ) ; } }
bool check ( int [ ] a , int n ) { bool flag = false ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i + 1 ] > a [ i ] && a [ i ] < a [ i - 1 ] ) flag = true ; } if ( flag ) return false ; else return true ; }
void smallestNumber ( int [ ] arr , int len ) { int maxi = 0 ; for ( int i = 0 ; i < len ; i ++ ) { maxi = Math . Max ( maxi , arr [ i ] ) ; } int ans = - 1 ; for ( int i = 2 ; i < maxi + 2 ; i ++ ) { bool flag = true ; for ( int j = 0 ; j < len ; j ++ ) { if ( arr [ j ] % i == 0 ) { flag = false ; break ; } } if ( flag ) { ans = i ; break ; } } Console . WriteLine ( ans ) ; }
void findDuplicate ( string str , int N ) { int first = 0 ; int second = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( first & ( 1 << ( str [ i ] - 'a' ) ) ) != 0 ) { second = second | ( 1 << ( str [ i ] - 'a' ) ) ; } else { first = first | ( 1 << ( str [ i ] - 'a' ) ) ; } } for ( int i = 0 ; i < 26 ; i ++ ) { if ( ( ( first & ( 1 << i ) ) & ( second & ( 1 << i ) ) ) != 0 ) { Console . Write ( ( char ) ( i + 'a' ) + " " ) ; } } }
void minOperations ( string S ) { int count = 0 ; for ( int i = 1 ; i < S . Length ; i ++ ) { if ( S [ i ] != S [ i - 1 ] ) { count += 1 ; } } Console . Write ( count ) ; }
int check ( int N ) { if ( N == 0 || ( N & ( N - 1 ) ) != 0 ) return 0 ; return 1 ; }
void build_seg_tree ( int ss , int se , int si , int [ ] tree , int [ ] arr ) { if ( ss == se ) { tree [ si ] = check ( arr [ ss ] ) ; return ; } int mid = ( ss + se ) / 2 ; build_seg_tree ( ss , mid , 2 * si + 1 , tree , arr ) ; build_seg_tree ( mid + 1 , se , 2 * si + 2 , tree , arr ) ; tree [ si ] = tree [ 2 * si + 1 ] + tree [ 2 * si + 2 ] ; }
int query ( int l , int r , int ss , int se , int si , int [ ] tree ) { if ( r < ss l > se ) return 0 ; if ( l <= ss && r >= se ) return tree [ si ] ; int mid = ( ss + se ) / 2 ; return query ( l , r , ss , mid , 2 * si + 1 , tree ) + query ( l , r , mid + 1 , se , 2 * si + 2 , tree ) ; }
void numberOfPairs ( int [ ] arr , int N ) { int [ ] set_bits = new int [ 31 ] ; for ( int i = 0 ; i < N ; i ++ ) { set_bits [ i ] = 0 ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int x = arr [ i ] ; int bitpos = - 1 ; while ( x > 0 ) { bitpos ++ ; x /= 2 ; } for ( int j = 0 ; j <= bitpos ; j ++ ) { count += set_bits [ j ] ; } set_bits [ bitpos ] ++ ; } Console . Write ( count ) ; }
void calculateQuery ( int [ ] arr , int N , int [ ] query , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int X = query [ i ] ; int sum_start = 0 , sum_end = 0 ; for ( int j = 0 ; j < N ; j ++ ) { sum_start += arr [ j ] ; if ( arr [ j ] == X ) break ; } for ( int j = N - 1 ; j >= 0 ; j -- ) { sum_end += arr [ j ] ; if ( arr [ j ] == X ) break ; } Console . Write ( Math . Min ( sum_end , sum_start ) + " " ) ; } }
void calculateQuery ( int [ ] arr , int N , int [ ] query , int M ) { int prefix = 0 , suffix = 0 ; Dictionary < int , Tuple < int , int > > mp = new Dictionary < int , Tuple < int , int > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { prefix += arr [ i ] ; mp [ arr [ i ] ] = new Tuple < int , int > ( prefix , 0 ) ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { suffix += arr [ i ] ; mp [ arr [ i ] ] = new Tuple < int , int > ( mp [ arr [ i ] ] . Item1 , suffix ) ; } for ( int i = 0 ; i < M ; i ++ ) { int X = query [ i ] ; Console . Write ( Math . Min ( mp [ X ] . Item1 , mp [ X ] . Item2 ) + " " ) ; } }
void minOps ( String s , int N ) { int ans = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( s [ i ] != s [ i - 1 ] ) { ans ++ ; } } if ( ans % 2 == 1 ) { Console . Write ( ( ans - 1 ) / 2 ) ; return ; } Console . Write ( ans / 2 ) ; }
void oddOneOut ( int [ ] arr , int N ) { int odd = 0 , even = 0 ; int lastOdd = 0 , lastEven = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { even ++ ; lastEven = i ; } else { odd ++ ; lastOdd = i ; } } if ( odd == 1 ) { Console . WriteLine ( lastOdd ) ; } else { Console . WriteLine ( lastEven ) ; } }
void mulsum ( int [ ] arr , int n , int N ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % N == 0 ) { sum = sum + arr [ i ] ; } } Console . Write ( sum ) ; }
bool isGreaterEqual ( int N , int X ) { return ( N * ( N + 1 ) / 2 ) >= X ; }
int minimumPossible ( int X ) { for ( int i = 1 ; i <= X ; i ++ ) { if ( isGreaterEqual ( i , X ) ) return i ; } return 0 ; }
bool isGreaterEqual ( int N , int X ) { return ( N * ( N + 1 ) / 2 ) >= X ; }
int minimumPossible ( int X ) { int low = 1 , high = X , res = - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( isGreaterEqual ( mid , X ) ) { res = mid ; high = mid - 1 ; } else low = mid + 1 ; } return res ; }
bool CheckDivByAllDigits ( int number ) { int n = number ; while ( n > 0 ) { if ( n % 10 != 0 ) if ( number % ( n % 10 ) != 0 ) { return false ; } n /= 10 ; } return true ; }
void cntNumInRang ( int [ , ] arr , int N ) { int [ ] prefCntDiv = new int [ Max + 1 ] ; for ( int i = 1 ; i <= Max ; i ++ ) { int ans = 0 ; if ( CheckDivByAllDigits ( i ) ) ans = 1 ; prefCntDiv [ i ] = prefCntDiv [ i - 1 ] + ans ; } for ( int i = 0 ; i < N ; i ++ ) Console . Write ( ( prefCntDiv [ arr [ i , 1 ] ] - prefCntDiv [ arr [ i , 0 ] - 1 ] ) + " " ) ; }
int arrayNesting ( int [ ] arr ) { int res = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( arr [ i ] == i ) { res = Math . Max ( res , 1 ) ; } else { int count = 0 ; int curr_index = i ; while ( arr [ curr_index ] != curr_index ) { int next_index = arr [ curr_index ] ; arr [ curr_index ] = curr_index ; curr_index = next_index ; count ++ ; } res = Math . Max ( res , count ) ; } } return res ; }
void count ( int [ ] a , int n ) { if ( n == 1 ) { Console . Write ( 0 ) ; return ; } int [ ] pre = new int [ n - 1 ] ; int [ ] suf = new int [ n - 1 ] ; int max = a [ 0 ] ; int ans = 0 , i ; pre [ 0 ] = a [ 0 ] ; for ( i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; pre [ i ] = max ; } max = a [ n - 1 ] ; suf [ n - 2 ] = a [ n - 1 ] ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( a [ i ] > max ) max = a [ i ] ; suf [ i - 1 ] = max ; } for ( i = 0 ; i < n - 1 ; i ++ ) { if ( pre [ i ] < suf [ i ] ) ans ++ ; } Console . Write ( ans ) ; }
void countNumbers ( int L , int R ) { int Count = 0 ; for ( int i = 0 ; i < index ; i ++ ) { int p = prime [ i ] ; if ( p >= L && p <= R ) { Count ++ ; } } Console . WriteLine ( Count ) ; }
int xorSubsequence ( int [ ] a , int n , int k ) { int ans = 0 ; Dictionary < int , int > map = new Dictionary < int , int > ( ) ; int [ ] dp = new int [ n ] ; map . Add ( a [ 0 ] , 1 ) ; dp [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int dpj = map . ContainsKey ( a [ i ] ^ k ) ? map [ a [ i ] ^ k ] : - 1 ; if ( dpj != 0 ) dp [ i ] = Math . Max ( dp [ i ] , dpj + 1 ) ; ans = Math . Max ( ans , dp [ i ] ) ; if ( map . ContainsKey ( a [ i ] ) ) { map [ a [ i ] ] = Math . Max ( map [ a [ i ] ] + 1 , dp [ i ] ) ; ; } else { map . Add ( a [ i ] , Math . Max ( 1 , dp [ i ] ) ) ; } } return ans >= 2 ? ans : 0 ; }
void distance ( TreeNode root , int target , int distancesum , int n ) { if ( root . data == target ) { sum = distancesum ; } if ( root . left != null ) { int tempsum = distancesum - root . left . size + ( n - root . left . size ) ; distance ( root . left , target , tempsum , n ) ; } if ( root . right != null ) { int tempsum = distancesum - root . right . size + ( n - root . right . size ) ; distance ( root . right , target , tempsum , n ) ; } }
void countRemainingElements ( int [ ] L1 , int [ ] L2 , int n ) { int one = 0 ; int zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( L1 [ i ] == 1 ) one ++ ; else zero ++ ; } int ans = n ; for ( int i = 0 ; i < n ; i ++ ) { if ( L2 [ i ] == 1 ) { one -- ; if ( one < 0 ) { ans = i ; break ; } } else { zero -- ; if ( zero < 0 ) { ans = i ; break ; } } } Console . WriteLine ( n - ans ) ; }
void minTime ( List < int > arr , int N , int K ) { Queue < int > q = new Queue < int > ( ) ; int [ ] vis = new int [ N + 1 ] ; Array . Clear ( vis , 0 , vis . Length ) ; int time = 0 ; for ( int i = 0 ; i < K ; i ++ ) { q . Enqueue ( arr [ i ] ) ; vis [ arr [ i ] ] = 1 ; } while ( q . Count > 0 ) { for ( int i = 0 ; i < q . Count ; i ++ ) { int curr = q . Peek ( ) ; q . Dequeue ( ) ; if ( curr - 1 >= 1 && vis [ curr - 1 ] == 0 ) { vis [ curr - 1 ] = 1 ; q . Enqueue ( curr - 1 ) ; } if ( curr + 1 <= N && vis [ curr + 1 ] == 0 ) { vis [ curr + 1 ] = 1 ; q . Enqueue ( curr + 1 ) ; } } time ++ ; } Console . WriteLine ( time - 1 ) ; }
int getCount ( int rows , int columns , int [ , ] A ) { int res = 0 ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = i + 1 ; j < rows ; j ++ ) { if ( A [ i , 0 ] * A [ j , 1 ] == A [ i , 1 ] * A [ j , 0 ] ) { res ++ ; } } } return res ; }
void Min_Score_Index ( int N , int [ ] A ) { int [ ] Score = new int [ N ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( A [ i ] + i < N ) Score [ i ] = A [ i ] * Score [ A [ i ] + i ] ; else Score [ i ] = A [ i ] ; } int min_value = Int32 . MaxValue ; foreach ( int i in Score ) { min_value = Math . Min ( i , min_value ) ; } int ind = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( Score [ i ] == min_value ) ind = i ; } Console . WriteLine ( ind ) ; }
void minLength ( String S , String T , int N , int M ) { String temp = "" ; int subtract = 0 ; for ( int i = 0 ; i < N ; ++ i ) { temp += S [ i ] ; if ( temp . Length >= M ) { if ( T . Equals ( temp . Substring ( temp . Length - M , M ) ) ) { subtract += M ; int cnt = 0 ; while ( cnt != M ) { temp = temp . Substring ( 0 , temp . Length - 1 ) ; ++ cnt ; } } } } Console . WriteLine ( ( N - subtract ) ) ; }
int maximumCount ( int [ ] arr1 , int [ ] arr2 , int s1 , int s2 ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < s1 ; i ++ ) { sum1 += arr1 [ i ] ; } for ( int a = 0 ; a < s2 ; a ++ ) { sum2 += arr2 [ a ] ; } int len = 0 ; if ( s1 >= s2 ) { len = s2 ; } else { len = s1 ; } Array . Sort ( arr1 ) ; Array . Sort ( arr2 ) ; int j = 0 , k = s2 - 1 , count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( sum1 <= sum2 ) { if ( arr2 [ k ] >= arr1 [ i ] ) { int dif1 = arr1 [ j ] , dif2 = arr2 [ k ] ; sum1 -= dif1 ; sum1 += dif2 ; sum2 -= dif2 ; sum2 += dif1 ; j ++ ; k -- ; count ++ ; } else { break ; } } else { break ; } } return count ; }
int noOfValidKbers ( int K , int [ ] arr ) { HashSet < int > set = new HashSet < int > ( ) ; while ( K != 0 ) { set . Add ( K % 10 ) ; K = K / 10 ; } int count = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { int no = arr [ i ] ; bool flag = true ; while ( no != 0 ) { int digit = no % 10 ; if ( ! set . Contains ( digit ) ) { flag = false ; break ; } no = no / 10 ; } if ( flag == true ) { count ++ ; } } return count ; }
void build ( int [ ] arr , int index , int s , int e ) { if ( s == e ) Tree [ index ] = arr [ s ] ; else { int m = ( s + e ) / 2 ; build ( arr , 2 * index , s , m ) ; build ( arr , 2 * index + 1 , m + 1 , e ) ; Tree [ index ] = Math . Max ( Tree [ 2 * index ] , Tree [ 2 * index + 1 ] ) ; } }
bool isSubarrayExistUtil ( int [ ] arr , int K , int N ) { int totalXOR = 0 ; int SubarrayXOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) totalXOR ^= arr [ i ] ; for ( int i = 0 ; i < K ; i ++ ) SubarrayXOR ^= arr [ i ] ; if ( SubarrayXOR == ( totalXOR ^ SubarrayXOR ) ) return true ; for ( int i = K ; i < N ; i ++ ) { SubarrayXOR ^= arr [ i ] ; SubarrayXOR ^= arr [ i - 1 ] ; if ( SubarrayXOR == ( totalXOR ^ SubarrayXOR ) ) return true ; } return false ; }
void countPairs ( int L , int R ) { int count_even ; if ( L % 2 == 0 ) { count_even = ( R / 2 ) - ( L / 2 ) + 1 ; } else { count_even = ( R / 2 ) - ( L / 2 ) ; } int count_odd ; if ( L % 2 == 0 ) { count_odd = ( ( R + 1 ) / 2 ) - ( ( L + 1 ) / 2 ) ; } else { count_odd = ( ( R + 1 ) / 2 ) - ( ( L + 1 ) / 2 ) + 1 ; } count_even *= count_even ; count_odd *= count_odd ; Console . WriteLine ( count_even + count_odd ) ; }
int delCost ( string s , int [ ] cost ) { int ans = 0 ; Dictionary < int , int > forMax = new Dictionary < int , int > ( ) ; Dictionary < int , int > forTot = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ! forMax . ContainsKey ( s [ i ] ) ) { forMax [ s [ i ] ] = cost [ i ] ; } else { forMax [ s [ i ] ] = Math . Max ( cost [ i ] , forMax [ s [ i ] ] ) ; } if ( ! forTot . ContainsKey ( s [ i ] ) ) { forTot [ s [ i ] ] = cost [ i ] ; } else { forTot [ s [ i ] ] += cost [ i ] ; } } foreach ( KeyValuePair < int , int > i in forMax ) { ans += forTot [ i . Key ] - i . Value ; } return ans ; }
int findPeak ( List < int > arr ) { int left = 0 ; int right = arr . Count - 1 ; while ( left < right ) { int mid = left + ( right - left ) / 2 ; if ( arr [ mid ] < arr [ ( mid + 1 ) ] ) { left = mid + 1 ; } else { right = mid ; } } return left ; }
int BS ( int X , int left , int right , List < int > arr ) { while ( left <= right ) { int mid = left + ( right - left ) / 2 ; if ( arr [ ( mid ) ] == X ) { return mid ; } else if ( X > arr [ mid ] ) { left = mid + 1 ; } else { right = mid - 1 ; } } return - 1 ; }
int reverseBS ( int X , int left , int right , List < int > arr ) { while ( left <= right ) { int mid = left + ( right - left ) / 2 ; if ( arr [ mid ] == X ) { return mid ; } else if ( X > arr [ mid ] ) { right = mid - 1 ; } else { left = mid + 1 ; } } return - 1 ; }
int getDefiniteFinds ( int [ ] arr ) { int n = arr . Length ; int [ ] smallestRight = new int [ n + 1 ] ; smallestRight [ n ] = Int32 . MaxValue ; for ( int i = n - 1 ; i >= 0 ; i -- ) { smallestRight [ i ] = Math . Min ( smallestRight [ i + 1 ] , arr [ i ] ) ; } int mn = Int32 . MinValue ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mn < arr [ i ] && arr [ i ] < smallestRight [ i + 1 ] ) { ans ++ ; } mn = Math . Max ( arr [ i ] , mn ) ; } return ans ; }
void Count_numbers ( int L , int R ) { int count = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) count += 1 ; Console . Write ( count ) ; }
int findIndex ( int [ ] arr , int N ) { int rightSum = 0 ; int leftSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { rightSum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { rightSum -= arr [ i ] ; if ( checkReverse ( leftSum , rightSum ) ) { return i ; } leftSum += arr [ i ] ; } return - 1 ; }
void minimumTime ( int [ ] arr , int n ) { int sum = 0 ; int T = arr . Min ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } Console . WriteLine ( Math . Max ( 2 * T , sum ) ) ; }
void findClosest ( int N , int target ) { int closest = - 1 ; int diff = Int32 . MaxValue ; for ( int i = 1 ; i <= Math . Sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( N / i == i ) { if ( Math . Abs ( target - i ) < diff ) { diff = Math . Abs ( target - i ) ; closest = i ; } } else { if ( Math . Abs ( target - i ) < diff ) { diff = Math . Abs ( target - i ) ; closest = i ; } if ( Math . Abs ( target - N / i ) < diff ) { diff = Math . Abs ( target - N / i ) ; closest = N / i ; } } } } Console . Write ( closest ) ; }
void computeDivisors ( ) { for ( int i = 1 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j += i ) { divisors [ j ] . Add ( i ) ; } } }
int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; }
int findClosest ( List < int > array , int n , int target ) { int [ ] arr = array . ToArray ( ) ; if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; }
void printClosest ( int N , int X ) { computeDivisors ( ) ; int ans = findClosest ( divisors [ N ] , divisors [ N ] . Count , X ) ; Console . Write ( ans ) ; }
int LCS ( int [ ] firstArr , int [ ] secondArr ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < firstArr . Length ; i ++ ) { mp . Add ( firstArr [ i ] , i + 1 ) ; } List < int > tempArr = new List < int > ( ) ; for ( int i = 0 ; i < secondArr . Length ; i ++ ) { if ( mp . ContainsKey ( secondArr [ i ] ) ) { tempArr . Add ( mp [ secondArr [ i ] ] ) ; } } List < int > tail = new List < int > ( ) ; tail . Add ( tempArr [ 0 ] ) ; for ( int i = 1 ; i < tempArr . Count ; i ++ ) { if ( tempArr [ i ] > tail [ tail . Count - 1 ] ) tail . Add ( tempArr [ i ] ) ; else if ( tempArr [ i ] < tail [ 0 ] ) tail . Insert ( 0 , tempArr [ i ] ) ; } return ( int ) tail . Count ; }
int maxSubarrayProduct ( List < int > arr , int n ) { int max_ending_here = 1 ; int min_ending_here = 1 ; int max_so_far = 0 ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { max_ending_here = max_ending_here * arr [ i ] ; min_ending_here = Math . Min ( min_ending_here * arr [ i ] , 1 ) ; flag = 1 ; } else if ( arr [ i ] == 0 ) { max_ending_here = 1 ; min_ending_here = 1 ; } else { int temp = max_ending_here ; max_ending_here = Math . Max ( min_ending_here * arr [ i ] , 1 ) ; min_ending_here = temp * arr [ i ] ; } if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } if ( flag == 0 && max_so_far == 0 ) return 0 ; return max_so_far ; }
int findMaxProduct ( int [ ] a , int n ) { int i = 0 ; int maxProd = 1 ; while ( i < n ) { List < int > v = new List < int > ( ) ; v . Add ( a [ i ] ) ; if ( i < n - 1 && a [ i ] < a [ i + 1 ] ) { while ( i < n - 1 && a [ i ] < a [ i + 1 ] ) { v . Add ( a [ i + 1 ] ) ; i += 1 ; } } else if ( i < n - 1 && a [ i ] > a [ i + 1 ] ) { while ( i < n - 1 && a [ i ] > a [ i + 1 ] ) { v . Add ( a [ i + 1 ] ) ; i += 1 ; } } int prod = maxSubarrayProduct ( v , v . Count ) ; maxProd = Math . Max ( maxProd , prod ) ; i ++ ; } return maxProd ; }
void PrimeFactors ( int N ) { Stack < int > st = new Stack < int > ( ) ; int i = 2 ; while ( N != 1 ) { if ( N % i == 0 ) { st . Push ( i ) ; while ( N % i == 0 ) { N = N / i ; } } i ++ ; } while ( st . Count != 0 ) { Console . Write ( st . Peek ( ) ) ; st . Pop ( ) ; } }
int power ( int A , int N ) { int count = 0 ; if ( A == 1 ) return 0 ; while ( N > 0 ) { count ++ ; N /= A ; } return count ; }
int LCM ( int A , int B ) { return ( A * B / __gcd ( A , B ) ) ; }
void findSmallestNumber ( int X ) { int lcm = 1 ; int temp = X ; while ( temp > 0 ) { int last = temp % 10 ; temp /= 10 ; if ( last == 0 ) continue ; lcm = LCM ( lcm , last ) ; } int answer = ( ( X + lcm - 1 ) / lcm ) * lcm ; Console . Write ( answer ) ; }
int findNonMultiples ( int [ ] arr , int n , int k ) { HashSet < int > multiples = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! multiples . Contains ( arr [ i ] ) ) { for ( int j = 1 ; j <= k / arr [ i ] ; j ++ ) { multiples . Add ( arr [ i ] * j ) ; } } } return k - multiples . Count ; }
int countValues ( int [ ] arr , int N , int L , int R ) { return findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ; }
void minSum ( int N ) { long low = 0 , high = 1000000000 ; while ( low + 1 < high ) { long mid = low + ( high - low ) / 2 ; if ( mid * mid >= N ) { high = mid ; } else { low = mid ; } } long first = high ; low = 0 ; high = 1000000000 ; while ( low + 1 < high ) { long mid = low + ( high - low ) / 2 ; if ( first * mid > N ) { high = mid ; } else { low = mid ; } } long second = high ; Console . WriteLine ( first + second ) ; }
void minSum ( int N ) { int ans = ( int ) Math . Ceiling ( 2 * Math . Sqrt ( N + 1 ) ) ; Console . WriteLine ( ans ) ; }
int root ( int a ) { if ( a == parent [ a ] ) { return a ; } return parent [ a ] = root ( parent [ a ] ) ; }
void connect ( int a , int b ) { a = root ( a ) ; b = root ( b ) ; if ( a != b ) { parent [ b ] = a ; } }
int find_ht ( TreeNode root ) { if ( root == null ) return 0 ; if ( root . left == null && root . right == null ) return 1 ; return Math . Max ( find_ht ( root . left ) , find_ht ( root . right ) ) + 1 ; }
int countFreq ( int N , int K ) { int count = 0 ; while ( N > 0 ) { if ( N % 10 == K ) { count ++ ; } N = N / 10 ; } return count ; }
int findElementUtil ( int [ ] arr , int N , int K ) { int c ; int max ; int ele = 0 ; max = 0 ; for ( int i = 0 ; i < N ; i ++ ) { c = countFreq ( arr [ i ] , K ) ; if ( c > max ) { max = c ; ele = arr [ i ] ; } } if ( max == 0 ) return - 1 ; else return ele ; }
void findOverlapSegement ( int N , int [ ] a , int [ ] b ) { List < Tuple < Tuple < int , int > , int > > tup = new List < Tuple < Tuple < int , int > , int > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int x , y ; x = a [ i ] ; y = b [ i ] ; tup . Add ( new Tuple < Tuple < int , int > , int > ( new Tuple < int , int > ( x , y ) , i ) ) ; } tup . Sort ( ) ; int curr = tup [ 0 ] . Item1 . Item2 ; int currPos = tup [ 0 ] . Item2 ; for ( int i = 1 ; i < N ; i ++ ) { int Q = tup [ i - 1 ] . Item1 . Item1 ; int R = tup [ i ] . Item1 . Item1 ; if ( Q == R ) { if ( tup [ i - 1 ] . Item1 . Item2 < tup [ i ] . Item1 . Item2 ) Console . Write ( tup [ i - 1 ] . Item2 + " " + tup [ i ] . Item2 ) ; else Console . Write ( tup [ i ] . Item2 + " " + tup [ i - 1 ] . Item2 ) ; return ; } int T = tup [ i ] . Item1 . Item2 ; if ( T <= curr ) { Console . Write ( tup [ i ] . Item2 + " " + currPos ) ; return ; } else { curr = T ; currPos = tup [ i ] . Item2 ; } } Console . Write ( "-1 -1" ) ; }
bool isSpiralSorted ( int [ ] arr , int n ) { int start = 0 ; int end = n - 1 ; while ( start < end ) { if ( arr [ start ] > arr [ end ] ) { return false ; } start ++ ; if ( arr [ end ] > arr [ start ] ) { return false ; } end -- ; } return true ; }
int findMinDeletions ( int [ , ] v , int n ) { int minDel = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { int L = v [ i , 0 ] ; int R = v [ i , 1 ] ; int Count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( v [ j , 0 ] >= L && v [ j , 1 ] <= R ) { Count += 1 ; } } minDel = Math . Min ( minDel , n - Count ) ; } return minDel ; }
int maxEvenIntegers ( int [ ] arr , int N , int M ) { int ans = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = Math . Max ( ans , cnt ) ; } return ans ; }
int MaxNonEmpSubSeq ( int [ ] a , int n ) { int sum = 0 ; int max = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < a [ i ] ) { max = a [ i ] ; } } if ( max <= 0 ) { return max ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) { sum += a [ i ] ; } } return sum ; }
void findMaxLengthSequence ( int N , int [ ] arr ) { int rightmost_element = - 1 ; int i = 0 ; int j = N - 1 ; List < int > sequence = new List < int > ( ) ; while ( i <= j ) { if ( arr [ i ] > arr [ j ] ) { if ( arr [ j ] > rightmost_element ) { sequence . Add ( arr [ j ] ) ; rightmost_element = arr [ j ] ; j -- ; } else if ( arr [ i ] > rightmost_element ) { sequence . Add ( arr [ i ] ) ; rightmost_element = arr [ i ] ; i ++ ; } else break ; } else if ( arr [ i ] < arr [ j ] ) { if ( arr [ i ] > rightmost_element ) { sequence . Add ( arr [ i ] ) ; rightmost_element = arr [ i ] ; i ++ ; } else if ( arr [ j ] > rightmost_element ) { sequence . Add ( arr [ j ] ) ; rightmost_element = arr [ j ] ; j -- ; } else break ; } else if ( arr [ i ] == arr [ j ] ) { if ( i == j ) { if ( arr [ i ] > rightmost_element ) { sequence . Add ( arr [ i ] ) ; rightmost_element = arr [ i ] ; i ++ ; } break ; } else { sequence . Add ( arr [ i ] ) ; int k = i + 1 ; List < int > max_left = new List < int > ( ) ; while ( k < j && arr [ k ] > arr [ k - 1 ] ) { max_left . Add ( arr [ k ] ) ; k ++ ; } int l = j - 1 ; List < int > max_right = new List < int > ( ) ; while ( l > i && arr [ l ] > arr [ l + 1 ] ) { max_right . Add ( arr [ l ] ) ; l -- ; } if ( max_left . Count > max_right . Count ) foreach ( int element in max_left ) sequence . Add ( element ) ; else foreach ( int element in max_right ) sequence . Add ( element ) ; break ; } } } foreach ( int element in sequence ) Console . Write ( element + " " ) ; }
long getcount ( long n , int k ) { long res = ( n >> ( k + 1 ) ) << k ; if ( ( ( n >> k ) & 1 ) != 0 ) res += n & ( ( 1 << k ) - 1 ) ; return res ; }
void countDivisors ( int n ) { int count = 0 ; int j = 0 ; int [ ] divisor = new int [ n ] ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisor [ j ] = i ; j += 1 ; } else { divisor [ j ] = i ; divisor [ j + 1 ] = n / i ; j += 2 ; } } } divisor [ j ] = n ; for ( int i = 0 ; i <= j ; i ++ ) { int x = divisor [ i ] ; x -= 1 ; if ( ( n / x ) == ( n % x ) ) count ++ ; } Console . Write ( count ) ; }
int smallestIndexArrayElementsFlip ( int [ ] arr , int N ) { int pos = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] *= - 1 ; int sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) { sum += arr [ j ] ; } if ( sum == 0 ) { pos = i ; break ; } else { arr [ i ] *= - 1 ; } } return pos ; }
int smallestIndexArrayElementsFlip ( int [ ] arr , int N ) { int pos = - 1 ; int ArrSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { ArrSum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( 2 * arr [ i ] == ArrSum ) { pos = i ; break ; } } return pos ; }
double [ ] MaxAverage ( TreeNode root ) { if ( root . children != null && root . children . Count == 0 ) { ans = Math . Max ( ans , root . val ) ; return new double [ ] { root . val , 1 } ; } double [ ] childResult = new double [ 2 ] ; foreach ( TreeNode child in root . children ) { double [ ] childTotal = MaxAverage ( child ) ; childResult [ 0 ] = childResult [ 0 ] + childTotal [ 0 ] ; childResult [ 1 ] = childResult [ 1 ] + childTotal [ 1 ] ; } double sum = childResult [ 0 ] + root . val ; double count = childResult [ 1 ] + 1 ; ans = Math . Max ( ans , sum / count ) ; return new double [ ] { sum , count } ; }
int make_array_element_even ( int [ ] arr , int N ) { int res = 0 ; int odd_cont_seg = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd_cont_seg ++ ; } else { if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += ( odd_cont_seg / 2 ) + 2 ; } odd_cont_seg = 0 ; } } } if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += odd_cont_seg / 2 + 2 ; } } return res ; }
void findSum ( int [ ] a ) { int ans = 0 ; for ( int low = 0 ; low < a . Length ; low ++ ) { for ( int high = low ; high < a . Length ; high ++ ) { int count = 0 ; int maxNumber = 0 ; for ( int i = low ; i <= high ; i ++ ) { if ( a [ i ] == maxNumber ) count ++ ; else if ( a [ i ] > maxNumber ) { maxNumber = a [ i ] ; count = 1 ; } } ans += maxNumber * ( ( count % 2 == 0 ) ? 2 : 1 ) ; } } Console . WriteLine ( ans ) ; }
void countPairs ( int [ ] arr , int n ) { Dictionary < int , int > mp1 = new Dictionary < int , int > ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( mp1 . ContainsKey ( sum ) ) { mp1 . Add ( sum , mp1 [ sum ] + 1 ) ; } else { mp1 . Add ( sum , 1 ) ; } } sum = 0 ; int ans = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; if ( mp1 . ContainsKey ( sum ) ) { ans += mp1 [ sum ] ; } } Console . Write ( ans ) ; }
void minCollectingSpeed ( int [ ] piles , int H ) { int ans = - 1 ; int low = 1 , high ; Array . Sort ( piles ) ; high = piles [ piles . Length - 1 ] ; while ( low <= high ) { int K = low + ( high - low ) / 2 ; int time = 0 ; foreach ( int ai in piles ) { time += ( ai + K - 1 ) / K ; } if ( time <= H ) { ans = K ; high = K - 1 ; } else { low = K + 1 ; } } Console . Write ( ans ) ; }
bool isMagic ( int num ) { return ( num % 9 == 1 ) ; }
int findSmallestInteger ( int [ ] arr , int N , int K ) { int left = 1 ; int right = arr . Max ( ) ; while ( left < right ) { int mid = ( left + right ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += ( arr [ i ] + mid - 1 ) / mid ; } if ( sum > K ) { left = mid + 1 ; } else { right = mid ; } } return left ; }
int minimum_deci_binary_number ( string s ) { int m = int . MinValue ; for ( int i = 0 ; i < s . Length ; i ++ ) { int temp = s [ i ] - '0' ; if ( temp > m ) { m = temp ; } } return m ; }
int minimumReverse ( String s , int n ) { int k = 0 , l = 0 ; int sum1 = 0 , sum0 = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) sum1 ++ ; else sum0 ++ ; if ( s [ i ] == s [ i - 1 ] && s [ i ] == '0' ) k ++ ; else if ( s [ i ] == s [ i - 1 ] && s [ i ] == '1' ) l ++ ; } if ( s [ 0 ] == '1' ) sum1 ++ ; sum0 ++ ; if ( Math . Abs ( sum1 - sum0 ) > 1 ) return - 1 ; return Math . Max ( k , l ) ; }
void canTransformStrings ( string A , string B ) { int n1 = A . Length ; int n2 = B . Length ; int count1A = 0 , count1B = 0 ; int odd1A = 0 , odd1B = 0 ; int even1A = 0 , even1B = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( A [ i ] == '1' ) count1A ++ ; else { if ( ( count1A & 1 ) == 1 ) odd1A ++ ; else even1A ++ ; } } for ( int i = 0 ; i < n2 ; i ++ ) { if ( B [ i ] == '1' ) count1B ++ ; else { if ( ( count1B & 1 ) == 1 ) odd1B ++ ; else even1B ++ ; } } if ( count1A == count1B && odd1A == odd1B && even1A == even1B ) { Console . Write ( "Yes" ) ; } else Console . Write ( "No" ) ; }
void maxPairs ( int [ ] nums , int k ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; int result = 0 ; foreach ( int i in nums ) { if ( map . ContainsKey ( i ) && map [ i ] > 0 ) { map [ i ] = map [ i ] - 1 ; result ++ ; } else { if ( ! map . ContainsKey ( k - i ) ) map . Add ( k - i , 1 ) ; else map [ i ] = map [ i ] + 1 ; } } Console . WriteLine ( result ) ; }
void uniqueElements ( int [ ] arr , int start , int K , Dictionary < int , int > mp ) { HashSet < int > st = new HashSet < int > ( ) ; for ( int i = 0 ; i < K ; i ++ ) st . Add ( arr [ start + i ] ) ; foreach ( int itr in st ) { if ( mp . ContainsKey ( itr ) ) { mp [ itr ] ++ ; } else { mp [ itr ] = 1 ; } } }
void smallestPresentNumber ( int [ ] arr , int N , int K ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i <= N - K ; i ++ ) { uniqueElements ( arr , i , K , mp ) ; } checkAnswer ( mp , N , K ) ; }
void generateK ( int [ ] arr , int N ) { for ( int k = 1 ; k <= N ; k ++ ) smallestPresentNumber ( arr , N , k ) ; }
void printAnswer ( int [ ] answer , int N ) { for ( int i = 1 ; i <= N ; i ++ ) { Console . Write ( answer [ i ] + " " ) ; } }
void lengthOfSubarray ( List < List < int > > indices , HashSet < int > st , int N ) { int [ ] answer = new int [ N + 1 ] ; Array . Fill ( answer , - 1 ) ; foreach ( int itr in st ) { int start = - 1 ; int gap = - 1 ; int t = itr ; indices [ t ] . Add ( N ) ; for ( int i = 0 ; i < indices [ t ] . Count ; i ++ ) { gap = Math . Max ( gap , indices [ t ] [ i ] - start ) ; start = indices [ t ] [ i ] ; } if ( answer [ gap ] == - 1 ) answer [ gap ] = t ; } updateAnswerArray ( answer , N ) ; printAnswer ( answer , N ) ; }
void smallestPresentNumber ( int [ ] arr , int N ) { List < List < int > > indices = new List < List < int > > ( ) ; for ( int i = 0 ; i <= N ; i ++ ) indices . Add ( new List < int > ( ) ) ; HashSet < int > elements = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { indices [ arr [ i ] ] . Add ( i ) ; elements . Add ( arr [ i ] ) ; } lengthOfSubarray ( indices , elements , N ) ; }
void removeIndicesToMakeSumEqual ( int [ ] arr ) { int N = arr . Length ; int [ ] odd = new int [ N ] ; int [ ] even = new int [ N ] ; even [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { odd [ i ] = odd [ i - 1 ] ; even [ i ] = even [ i - 1 ] ; if ( i % 2 == 0 ) { even [ i ] += arr [ i ] ; } else { odd [ i ] += arr [ i ] ; } } bool find = false ; int p = odd [ N - 1 ] ; int q = even [ N - 1 ] - arr [ 0 ] ; if ( p == q ) { Console . Write ( "0 " ) ; find = true ; } for ( int i = 1 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ; q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; } else { q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ; p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; } if ( p == q ) { find = true ; Console . Write ( i + " " ) ; } } if ( ! find ) { Console . Write ( - 1 ) ; } }
int cntDisPairs ( int [ ] arr , int N , int K ) { int cntPairs = 0 ; Array . Sort ( arr ) ; int i = 0 ; int j = N - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] == K ) { while ( i < j && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } while ( i < j && arr [ j ] == arr [ j - 1 ] ) { j -- ; } cntPairs += 1 ; i ++ ; j -- ; } else if ( arr [ i ] + arr [ j ] < K ) { i ++ ; } else { j -- ; } } return cntPairs ; }
int maxLength ( int [ ] a , int [ ] b , int n , int c ) { if ( n == 0 ) return 0 ; int max_length = 0 ; int low = 0 , high = n ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( possible ( a , b , n , c , mid ) ) { max_length = mid ; low = mid + 1 ; } else high = mid - 1 ; } return max_length ; }
bool possible ( int [ ] a , int [ ] b , int n , int c , int k ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { sum += a [ i ] ; } int total_cost = sum * k + getMax ( b , 0 , n - 1 , 0 , k - 1 , 0 ) ; if ( total_cost <= c ) return true ; for ( int i = k ; i < n ; i ++ ) { sum += a [ i ] ; sum -= a [ i - k ] ; total_cost = sum * k + getMax ( b , 0 , n - 1 , i - k + 1 , i , 0 ) ; if ( total_cost <= c ) return true ; } return false ; }
void build ( int [ ] b , int index , int s , int e ) { if ( s == e ) { seg [ index ] = b [ s ] ; return ; } int mid = s + ( e - s ) / 2 ; build ( b , 2 * index + 1 , s , mid ) ; build ( b , 2 * index + 2 , mid + 1 , e ) ; seg [ index ] = Math . Max ( seg [ 2 * index + 1 ] , seg [ 2 * index + 2 ] ) ; }
int getMax ( int [ ] b , int ss , int se , int qs , int qe , int index ) { if ( se < qs ss > qe ) return Int32 . MinValue / 2 ; if ( ss >= qs && se <= qe ) return seg [ index ] ; int mid = ss + ( se - ss ) / 2 ; return Math . Max ( getMax ( b , ss , mid , qs , qe , 2 * index + 1 ) , getMax ( b , mid + 1 , se , qs , qe , 2 * index + 2 ) ) ; }
int maxLength ( int [ ] a , int [ ] b , int n , int c ) { if ( n == 0 ) return 0 ; int max_length = 0 ; int low = 0 , high = n ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( possible ( a , b , n , c , mid ) ) { max_length = mid ; low = mid + 1 ; } else high = mid - 1 ; } return max_length ; }
bool possible ( int [ ] a , int [ ] b , int n , int c , int k ) { List < int > dq = new List < int > ( ) ; int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { sum += a [ i ] ; while ( dq . Count > 0 && b [ i ] > b [ dq [ dq . Count - 1 ] ] ) dq . RemoveAt ( dq . Count - 1 ) ; dq . Add ( i ) ; } int total_cost = sum * k + b [ dq [ 0 ] ] ; if ( total_cost <= c ) return true ; for ( int i = k ; i < n ; i ++ ) { sum += a [ i ] ; sum -= a [ i - k ] ; while ( dq . Count > 0 && dq [ 0 ] <= i - k ) dq . RemoveAt ( 0 ) ; while ( dq . Count > 0 && b [ i ] > b [ dq [ dq . Count - 1 ] ] ) dq . RemoveAt ( dq . Count - 1 ) ; dq . Add ( i ) ; total_cost = sum * k + b [ dq [ 0 ] ] ; if ( total_cost <= c ) return true ; } return false ; }
int findMaxLength ( int N , int [ ] arr ) { int [ ] dp = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 2 * i ; j <= N ; j += i ) { if ( arr [ i - 1 ] < arr [ j - 1 ] ) { dp [ j ] = Math . Max ( dp [ j ] , dp [ i ] + 1 ) ; } } } return dp . Max ( ) ; ; }
void UtilSmallestElement ( int [ ] arr , int N ) { int total = 0 ; for ( int i = 0 ; i < N ; i ++ ) { total += arr [ i ] ; } int [ , ] dp = new int [ N + 1 , total ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) { for ( int j = 0 ; j < total ; j ++ ) { dp [ i , j ] = - 1 ; } } Console . WriteLine ( smallestLeft ( arr , total , 0 , N , dp ) ) ; }
int SmallestElementLeft ( int [ ] arr , int N ) { int totalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += arr [ i ] ; } int req = totalSum / 2 ; bool [ ] dp = new bool [ req + 1 ] ; for ( int i = 0 ; i < req + 1 ; i ++ ) { dp [ i ] = false ; } dp [ 0 ] = true ; int reach = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = req ; j - arr [ i ] >= 0 ; j -- ) { dp [ j ] = dp [ j ] || dp [ j - arr [ i ] ] ; if ( dp [ j ] ) { reach = Math . Max ( reach , j ) ; } } } return totalSum - ( 2 * reach ) ; }
int countSubArraySignChange ( int [ ] arr , int N ) { Dictionary < int , int > prefixCount = new Dictionary < int , int > ( ) ; Dictionary < int , int > suffixCount = new Dictionary < int , int > ( ) ; int total = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { total += arr [ i ] ; if ( suffixCount . ContainsKey ( arr [ i ] ) ) { suffixCount [ arr [ i ] ] = suffixCount [ arr [ i ] ] + 1 ; } else { suffixCount . Add ( arr [ i ] , 1 ) ; } } int prefixSum = 0 ; int suffixSum = 0 ; int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { prefixSum += arr [ i ] ; if ( prefixCount . ContainsKey ( arr [ i ] ) ) { prefixCount [ arr [ i ] ] = prefixCount [ arr [ i ] ] + 1 ; } else { prefixCount . Add ( arr [ i ] , 1 ) ; } suffixSum = total - prefixSum ; if ( suffixCount . ContainsKey ( arr [ i ] ) ) { suffixCount [ arr [ i ] ] = suffixCount [ arr [ i ] ] - 1 ; } int diff = prefixSum - suffixSum ; if ( diff % 2 == 0 ) { int x = ( prefixCount . ContainsKey ( diff / 2 ) ? prefixCount : 0 ) + ( suffixCount . ContainsKey ( - diff / 2 ) ? suffixCount [ - diff / 2 ] : 0 ) ; count = count + x ; } } return count ; }
int countCommonChar ( int ind , String S ) { int cnt = 0 ; HashSet < char > ls = new HashSet < char > ( ) ; HashSet < char > rs = new HashSet < char > ( ) ; for ( int i = 0 ; i < ind ; ++ i ) { ls . Add ( S [ i ] ) ; } for ( int i = ind ; i < S . Length ; ++ i ) { rs . Add ( S [ i ] ) ; } foreach ( char v in ls ) { if ( rs . Contains ( v ) ) { ++ cnt ; } } return cnt ; }
int longestSubarray ( String s ) { s += '0' ; int i ; int res = 0 ; int prev_one = 0 ; int curr_one = 0 ; int numberOfZeros = 0 ; for ( i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '1' ) { curr_one += 1 ; } else { numberOfZeros += 1 ; prev_one += curr_one ; res = Math . Max ( res , prev_one ) ; prev_one = curr_one ; curr_one = 0 ; } } if ( numberOfZeros == 1 ) { res -= 1 ; } return res ; }
void LarUnEl ( int [ ] arr , int N ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( map . ContainsKey ( arr [ i ] ) == true ) map [ arr [ i ] ] += 1 ; else map [ arr [ i ] ] = 1 ; } int LNRElem = Int32 . MinValue ; int ind = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( map [ arr [ i ] ] == 1 && arr [ i ] > LNRElem ) { ind = i ; LNRElem = arr [ i ] ; } } if ( ind == - 1 ) { Console . WriteLine ( ind ) ; return ; } Console . WriteLine ( arr [ ind ] ) ; }
bool isConsistingSubarrayUtil ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . ContainsKey ( arr [ i ] ) == true ) mp [ arr [ i ] ] += 1 ; else mp [ arr [ i ] ] = 1 ; } var val = mp . Keys . ToList ( ) ; foreach ( var key in val ) { if ( mp [ key ] > 1 ) { return true ; } } return false ; }
void isConsistingSubarray ( int [ ] arr , int N ) { if ( isConsistingSubarrayUtil ( arr , N ) ) { Console . Write ( "Yes" ) ; } else { Console . Write ( "No" ) ; } }
void countShifts ( string str ) { int firstOne = - 1 ; int lastOne = - 1 ; int count = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == '1' ) { if ( firstOne == - 1 ) firstOne = i ; lastOne = i ; } } if ( ( firstOne == - 1 ) || ( firstOne == lastOne ) ) { Console . Write ( 0 ) ; return ; } for ( int i = firstOne ; i <= lastOne ; i ++ ) { if ( str [ i ] == '0' ) { count ++ ; } } Console . WriteLine ( count ) ; }
bool checkSubsequenceUtil ( int [ ] arr , int L , int R , int N ) { for ( int i = 0 ; i < L ; i ++ ) if ( arr [ i ] == arr [ L ] ) return true ; for ( int i = R + 1 ; i < N ; i ++ ) if ( arr [ i ] == arr [ R ] ) return true ; return false ; }
void largestSubarray ( int [ ] arr , int N , int K ) { int count = 0 ; int len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < K ) { count += 1 ; } else { len = Math . Max ( len , count ) ; count = 0 ; } } if ( count != 0 ) { len = Math . Max ( len , count ) ; } Console . WriteLine ( len ) ; }
void findNthNum ( int N ) { left = 1 ; right = N ; while ( left <= right ) { mid = left + ( right - left ) / 2 ; t = ( mid * ( mid + 1 ) ) / 2 ; if ( t < N ) { left = mid + 1 ; } else if ( t == N ) { a = mid ; break ; } else { a = mid ; right = mid - 1 ; } } t = a - 1 ; b = N - ( t * ( t + 1 ) ) / 2 - 1 ; Console . Write ( ( 1 << a ) + ( 1 << b ) ) ; }
void longestSubsequence ( int N , int Q , int [ ] arr , int [ , ] Queries ) { for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i , 0 ] ; int y = Queries [ i , 1 ] ; arr [ x - 1 ] = y ; int count = 1 ; for ( int j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } Console . Write ( count + " " ) ; } }
void longestSubsequence ( int N , int Q , int [ ] arr , int [ , ] Queries ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count += 1 ; } } for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i , 0 ] ; int y = Queries [ i , 1 ] ; if ( x > 1 ) { if ( arr [ x - 1 ] != arr [ x - 2 ] ) { count -= 1 ; } if ( arr [ x - 2 ] != y ) { count += 1 ; } } if ( x < N ) { if ( arr [ x ] != arr [ x - 1 ] ) { count -= 1 ; } if ( y != arr [ x ] ) { count += 1 ; } } Console . Write ( count + " " ) ; arr [ x - 1 ] = y ; } }
void longestSubWithMaxSum ( int [ ] arr , int N ) { int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( Max < arr [ i ] ) Max = arr [ i ] ; } if ( Max < 0 ) { Console . Write ( Max ) ; return ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 0 ) { Console . Write ( arr [ i ] + " " ) ; } } }
void printNGE ( int [ ] arr , int n ) { Stack < int > s = new Stack < int > ( ) ; int [ ] nge = new int [ n ] ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) { nge [ i ] = - 1 ; } i = 0 ; while ( i < 2 * n ) { while ( s . Count != 0 && arr [ i % n ] > arr [ s . Peek ( ) ] ) { nge [ s . Peek ( ) ] = arr [ i % n ] ; s . Pop ( ) ; } s . Push ( i % n ) ; i ++ ; } for ( i = 0 ; i < n ; i ++ ) { Console . Write ( nge [ i ] + " " ) ; } }
bool isPerfectSquare ( int x ) { int s = ( int ) Math . Sqrt ( x ) ; return ( s * s == x ) ; }
bool isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
void ifgcdFibonacci ( int [ ] a , int n , int k ) { List < int > compositeset = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( isComposite ( a [ i ] ) && a [ i ] % k == 0 ) { compositeset . Add ( a [ i ] ) ; } } int gcd = compositeset [ 0 ] ; for ( int i = 1 ; i < compositeset . Count ; i ++ ) { gcd = __gcd ( gcd , compositeset [ i ] ) ; if ( gcd == 1 ) { break ; } } if ( isFibonacci ( gcd ) ) { Console . Write ( "Yes" ) ; return ; } Console . Write ( "No" ) ; return ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void findPair ( int [ ] A , int N ) { int [ ] right_prod = new int [ N ] ; int flag = 0 ; right_prod [ N - 1 ] = A [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) right_prod [ i ] = right_prod [ i + 1 ] * A [ i ] ; int total_prod = right_prod [ 0 ] ; int product ; for ( int i = 1 ; i < N - 1 ; i ++ ) { product = 1 ; for ( int j = i ; j < N - 1 ; j ++ ) { product *= A [ j ] ; if ( gcd ( product , right_prod [ j + 1 ] ) == 1 || gcd ( product , total_prod / right_prod [ i ] ) == 1 ) { flag = 1 ; Console . WriteLine ( "(" + ( i - 1 ) + ", " + ( j + 1 ) + ")" ) ; break ; } } if ( flag == 1 ) break ; } if ( flag == 0 ) Console . Write ( - 1 ) ; }
void countString ( string S ) { int count = 0 ; foreach ( char it in S ) { if ( it == '0' && count > 0 ) { count -- ; } else { count ++ ; } } Console . Write ( ( 1 << count ) - 1 ) ; }
void replaceDuplicates ( string [ ] names ) { Dictionary < string , int > hash = new Dictionary < string , int > ( ) ; for ( int i = 0 ; i < names . Length ; i ++ ) { if ( ! hash . ContainsKey ( names [ i ] ) ) hash [ names [ i ] ] = 1 ; else { int count = hash [ names [ i ] ] ; hash [ names [ i ] ] += 1 ; names [ i ] += count . ToString ( ) ; } } for ( int i = 0 ; i < names . Length ; i ++ ) { Console . Write ( names [ i ] + ' ' ) ; } }
int digitProduct ( int number ) { int res = 1 ; while ( number > 0 ) { res *= ( number % 10 ) ; number /= 10 ; } return res ; }
void DistinctCompositeDigitProduct ( int [ ] arr , int n ) { SortedSet < int > output = new SortedSet < int > ( ) ; bool [ ] prime = new bool [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) { prime [ i ] = true ; } SieveOfEratosthenes ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) { int ans = digitProduct ( arr [ i ] ) ; if ( ans <= 1 ) { continue ; } if ( ! prime [ ans ] ) { output . Add ( ans ) ; } } Console . WriteLine ( output . Count ) ; }
bool [ ] SegmentedSieveFn ( int low , int high ) { int lmt = ( int ) ( Math . Sqrt ( high ) ) + 1 ; ArrayList prime = new ArrayList ( ) ; prime = simpleSieve ( lmt , prime ) ; int n = high - low + 1 ; bool [ ] segmentedSieve = new bool [ n + 1 ] ; Array . Fill ( segmentedSieve , true ) ; for ( int i = 0 ; i < prime . Count ; i ++ ) { int lowLim = ( int ) ( low / ( int ) prime [ i ] ) * ( int ) prime [ i ] ; if ( lowLim < low ) { lowLim += ( int ) prime [ i ] ; } for ( int j = lowLim ; j <= high ; j += ( int ) prime [ i ] ) { if ( j != ( int ) prime [ i ] ) { segmentedSieve [ j - low ] = false ; } } } return segmentedSieve ; }
int countPairsWhoseSumPrimeL_R ( int L , int R ) { bool [ ] segmentedSieve = SegmentedSieveFn ( L , R ) ; int cntPairs = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( segmentedSieve [ i - L ] ) { cntPairs += i / 2 ; } } return cntPairs ; }
int count_zeroes ( int n , string str ) { int cnt = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == '0' ) cnt ++ ; } return cnt ; }
string kReducingString ( int n , int k , string str ) { int no_of_zeroes = count_zeroes ( n , str ) ; int no_of_ones = n - no_of_zeroes ; if ( no_of_zeroes == 0 no_of_zeroes == n ) { return str ; } if ( k == 1 ) { if ( no_of_zeroes == 0 no_of_zeroes == n ) { return str ; } else { return "Not Possible" ; } } bool check = false ; for ( int i = ( n / k ) ; i < n ; i += ( n / k ) ) { if ( no_of_zeroes == i no_of_ones == i ) { check = true ; break ; } } if ( check == false ) { return "Not Possible" ; } return kReducingStringUtil ( n , k , str , no_of_zeroes ) ; }
void convert_to_allzeroes ( string str , int a , int b ) { int len = str . Length ; int left_1 , i = 0 ; while ( i < len && str [ i ] == '0' ) i ++ ; left_1 = i ; int right_1 ; i = len - 1 ; while ( i >= 0 && str [ i ] == '0' ) i -- ; right_1 = i ; if ( left_1 == len && right_1 == - 1 ) { Console . Write ( 0 ) ; return ; } int cost = a , zeroes ; for ( i = left_1 ; i <= right_1 ; i ++ ) { zeroes = 0 ; while ( i < len && str [ i ] == '0' ) { zeroes ++ ; i ++ ; } if ( zeroes != 0 ) cost += Math . Min ( zeroes * b , a ) ; } Console . Write ( cost ) ; }
int MinDistK ( int [ ] arr , int N , int K ) { int res = Int32 . MaxValue ; int dist = 0 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { if ( arr [ i ] >= 0 && arr [ i + K - 1 ] >= 0 ) { dist = Math . Max ( arr [ i ] , arr [ i + K - 1 ] ) ; } else { dist = Math . Abs ( arr [ i ] ) + Math . Abs ( arr [ i + K - 1 ] ) + Math . Min ( Math . Abs ( arr [ i ] ) , Math . Abs ( arr [ i + K - 1 ] ) ) ; } res = Math . Min ( res , dist ) ; } return res ; }
int maximizeMin ( int [ ] A , int N , int S , int M ) { int minIndex , left , right , i , j ; for ( i = 0 ; i < M ; i ++ ) { minIndex = min1 ( A , N ) ; A [ minIndex ] ++ ; left = minIndex - 1 ; right = minIndex + 1 ; for ( j = 0 ; j < S - 1 ; j ++ ) { if ( left == - 1 ) A [ right ++ ] ++ ; else if ( right == N ) A [ left -- ] ++ ; else { if ( A [ left ] < A [ right ] ) A [ left -- ] ++ ; else A [ right ++ ] ++ ; } } } minIndex = min1 ( A , N ) ; return A [ minIndex ] ; }
int sumOfPathNodes ( int N ) { if ( N == 1 ) { return 1 ; } else if ( N == 2 N == 3 ) { return N + 1 ; } List < int > arr = new List < int > ( ) ; arr . Add ( 1 ) ; int k = 1 ; bool flag = true ; while ( k < N ) { if ( flag == true ) { k *= 2 ; flag = false ; } else { k *= 4 ; flag = true ; } if ( k > N ) { break ; } arr . Add ( k ) ; } int len = arr . Count ; int [ ] prefix = new int [ len ] ; prefix [ 0 ] = 1 ; for ( int i = 1 ; i < len ; ++ i ) { prefix [ i ] = arr [ i ] + prefix [ i - 1 ] ; } int it = lowerBound ( prefix , 0 , len , N ) + 1 ; int ind = it - prefix [ 0 ] ; int final_ans = 0 ; int temp = N ; while ( ind > 1 ) { int val = temp - prefix [ ind - 1 ] ; if ( ind % 2 != 0 ) { temp = prefix [ ind - 2 ] + ( val + 1 ) / 2 ; } else { temp = prefix [ ind - 2 ] + ( val + 3 ) / 4 ; } -- ind ; final_ans += temp ; } final_ans += ( N + 1 ) ; return final_ans ; }
void fill_counts ( int [ ] a , int n ) { int i , j ; int maxA = a [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxA ) { maxA = a [ i ] ; } } for ( i = 0 ; i < n ; i ++ ) { lcount [ a [ i ] , i ] = 1 ; rcount [ a [ i ] , i ] = 1 ; } for ( i = 0 ; i <= maxA ; i ++ ) { for ( j = 1 ; j < n ; j ++ ) { lcount [ i , j ] = lcount [ i , j - 1 ] + lcount [ i , j ] ; } for ( j = n - 2 ; j >= 0 ; j -- ) { rcount [ i , j ] = rcount [ i , j + 1 ] + rcount [ i , j ] ; } } }
bool checkPointRange ( int [ , ] arr , int X , int Y , int N ) { for ( int i = 0 ; i < N ; i ++ ) { double dist = Math . Sqrt ( ( arr [ i , 0 ] - X ) * ( arr [ i , 0 ] - X ) + ( arr [ i , 1 ] - Y ) * ( arr [ i , 1 ] - Y ) ) ; if ( dist <= arr [ i , 2 ] ) { return true ; } } return false ; }
void findWinner ( int [ ] arr , int N ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd ++ ; } else { even ++ ; } } if ( even == 0 ) { if ( odd % 2 == 0 ) { Console . WriteLine ( "Player 2" ) ; } else if ( odd % 2 == 1 ) { Console . WriteLine ( "Player 1" ) ; } } else if ( even == 1 && odd % 2 == 1 ) { Console . WriteLine ( "Player 1" ) ; } else { Console . WriteLine ( - 1 ) ; } }
HashSet < int > createhashmap ( int Max ) { HashSet < int > hashmap = new HashSet < int > ( ) ; int curr = 1 ; int prev = 0 ; hashmap . Add ( prev ) ; while ( curr < Max ) { hashmap . Add ( curr ) ; int temp = curr ; curr = curr + prev ; prev = temp ; } return hashmap ; }
void SieveOfEratosthenes ( int Max ) { isPrime = new bool [ Max ] ; for ( int i = 0 ; i < Max ; i ++ ) isPrime [ i ] = true ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= Max ; p ++ ) { if ( isPrime [ p ] ) { for ( int i = p * p ; i <= Max ; i += p ) { isPrime [ i ] = false ; } } } }
void cntFibonacciPrime ( int [ ] arr , int N ) { int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { Max = Math . Max ( Max , arr [ i ] ) ; } SieveOfEratosthenes ( Max ) ; HashSet < int > hashmap = createhashmap ( Max ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) continue ; if ( ( hashmap . Contains ( arr [ i ] ) ) && ! isPrime [ arr [ i ] ] ) { Console . Write ( arr [ i ] + " " ) ; } } }
int minJumps ( String seats ) { List < int > position = new List < int > ( ) ; int count = 0 ; int len = seats . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( seats [ i ] == 'x' ) { position . Add ( i - count ) ; count ++ ; } } if ( count == len count == 0 ) return 0 ; int med_index = ( count - 1 ) / 2 ; int med_val = position [ med_index ] ; int ans = 0 ; for ( int i = 0 ; i < position . Count ; i ++ ) { ans = ( ans % MOD + Math . Abs ( position [ i ] - med_val ) % MOD ) % MOD ; } return ans % MOD ; }
int singlePrimeFactor ( int N ) { HashSet < int > disPrimeFact = new HashSet < int > ( ) ; for ( int i = 2 ; i * i <= N ; ++ i ) { while ( N % i == 0 ) { disPrimeFact . Add ( i ) ; N /= i ; } } if ( N != 1 ) { disPrimeFact . Add ( N ) ; } if ( disPrimeFact . Count == 1 ) { foreach ( int i in disPrimeFact ) return i ; } return - 1 ; }
int cntsingleFactorPair ( int [ ] arr , int N ) { int countOf1 = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) { countOf1 ++ ; continue ; } int factorValue = singlePrimeFactor ( arr [ i ] ) ; if ( factorValue == - 1 ) { continue ; } else { if ( mp . ContainsKey ( factorValue ) ) mp [ factorValue ] = mp [ factorValue ] + 1 ; else mp . Add ( factorValue , 1 ) ; } } int res = 0 ; foreach ( KeyValuePair < int , int > ele1 in mp ) { int X = ele1 . Value ; res += countOf1 * X + ( X * ( X - 1 ) ) / 2 ; } return res ; }
int countPairs ( int [ ] v1 , int [ ] v2 , int n , int m , int k ) { int count = 0 ; if ( n <= m ) { Array . Sort ( v1 ) ; for ( int j = 0 ; j < m ; j ++ ) { int index = lowerBound ( v1 , 0 , n , v2 [ j ] - k ) ; count += index ; } } else { Array . Sort ( v2 ) ; for ( int i = 0 ; i < n ; i ++ ) { int index = upperBound ( v2 , 0 , m , v1 [ i ] + k ) ; count += m - index ; } } return count ; }
void maxSumSubarr ( int [ ] A , int N , int K , int X ) { int sum_K = 0 ; for ( int i = 0 ; i < K ; i ++ ) { sum_K += A [ i ] ; } int Max_Sum = 0 ; if ( sum_K < X ) { Max_Sum = sum_K ; } for ( int i = K ; i < N ; i ++ ) { sum_K -= ( A [ i - K ] - A [ i ] ) ; if ( sum_K < X ) { Max_Sum = Math . Max ( Max_Sum , sum_K ) ; } } Console . WriteLine ( Max_Sum ) ; }
void removeSmallestSubarray ( int [ ] arr , int n , int k ) { int [ ] mod_arr = new int [ n ] ; int total_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mod_arr [ i ] = ( arr [ i ] + k ) % k ; total_sum += arr [ i ] ; } int target_remainder = total_sum % k ; if ( target_remainder == 0 ) { Console . Write ( "0" ) ; return ; } Dictionary < int , int > map1 = new Dictionary < int , int > ( ) ; map1 . Add ( 0 , - 1 ) ; int curr_remainder = 0 ; int res = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { curr_remainder = ( curr_remainder + arr [ i ] + k ) % k ; map1 [ curr_remainder ] = i ; int mod = ( curr_remainder - target_remainder + k ) % k ; if ( map1 . ContainsKey ( mod ) ) res = Math . Min ( res , i - map1 [ mod ] ) ; } if ( res == int . MaxValue res == n ) { res = - 1 ; } Console . Write ( res ) ; }
int findMaxLen ( int [ ] wood , int N , int K ) { int left = 1 ; int right = wood . Max ( ) ; while ( left <= right ) { int mid = left + ( right - left ) / 2 ; if ( isValid ( wood , N , mid , K ) ) { left = mid + 1 ; } else { right = mid - 1 ; } } return right ; }
int countFactors ( int [ ] spf , int num ) { int count = 0 ; while ( num > 1 ) { count ++ ; num = num / spf [ num ] ; } return count ; }
int [ ] precalculateSum ( int [ ] spf ) { int [ ] sum = new int [ MAX ] ; sum [ 0 ] = 0 ; for ( int i = 1 ; i < MAX ; i ++ ) { int prime_factor = countFactors ( spf , i ) ; if ( spf [ prime_factor ] == prime_factor ) { sum [ i ] = sum [ i - 1 ] + 1 ; } else { sum [ i ] = sum [ i - 1 ] ; } } return sum ; }
int countSum ( int [ ] a , int n , int sum ) { int i , j , k , l ; int count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { for ( k = j + 1 ; k < n - 1 ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) count ++ ; } } } } return count ; }
int countSum ( int [ ] a , int n , int sum ) { int i , j , k ; int l ; int count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { int req = sum - a [ i ] - a [ j ] ; Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( k = j + 1 ; k < n ; k ++ ) if ( m . ContainsKey ( a [ k ] ) ) { m [ a [ k ] ] ++ ; } else { m . Add ( a [ k ] , 1 ) ; } int twice_count = 0 ; for ( k = j + 1 ; k < n ; k ++ ) { if ( m . ContainsKey ( req - a [ k ] ) ) twice_count += m [ req - a [ k ] ] ; if ( req - a [ k ] == a [ k ] ) twice_count -- ; } count += twice_count / 2 ; } } return count ; }
int countSum ( int [ ] a , int n , int sum ) { int i , j ; int count = 0 ; Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { int temp = a [ i ] + a [ j ] ; if ( temp < sum && m . ContainsKey ( sum - temp ) ) count += m [ sum - temp ] ; } for ( j = 0 ; j < i ; j ++ ) { int temp = a [ i ] + a [ j ] ; if ( temp < sum ) if ( m . ContainsKey ( temp ) ) m [ temp ] ++ ; else m . Add ( temp , 1 ) ; } } return count ; }
int minSwaps ( String S , int n ) { int swaps = 0 ; List < int > [ ] arr = new List < int > [ 26 ] ; for ( int i = 0 ; i < arr . Length ; i ++ ) arr [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int pos = S [ i ] - 'a' ; arr [ pos ] . Add ( i ) ; } for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { int pos = ch - 'a' ; for ( int i = 1 ; i < arr [ pos ] . Count ; ++ i ) { swaps += Math . Abs ( arr [ pos ] [ i ] - arr [ pos ] [ i - 1 ] - 1 ) ; } } return swaps ; }
int isValid ( int [ ] arr , int n , int m , int d ) { for ( int i = 0 ; i < m ; i ++ ) { if ( Math . Abs ( arr [ n - m + i ] - arr [ i ] ) < d ) { return 0 ; } } return 1 ; }
void max_distance ( int [ ] a , int [ ] temp , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { temp [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ! mp . ContainsKey ( a [ i ] ) ) temp [ a [ i ] ] = i + 1 ; else temp [ a [ i ] ] = Math . Max ( temp [ a [ i ] ] , i - mp [ a [ i ] ] ) ; if ( mp . ContainsKey ( a [ i ] ) ) { mp [ a [ i ] ] = i ; } else { mp . Add ( a [ i ] , i ) ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( temp [ i ] != - 1 ) { if ( mp . ContainsKey ( i ) ) { temp [ i ] = Math . Max ( temp [ i ] , n - mp [ i ] ) ; } else { temp [ i ] = Math . Max ( temp [ i ] , n ) ; } } } }
void min_comm_ele ( int [ ] a , int [ ] ans , int [ ] temp , int n ) { max_distance ( a , temp , n ) ; for ( int i = 1 ; i <= n ; i ++ ) { ans [ i ] = - 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( temp [ i ] >= 0 && ans [ temp [ i ] ] == - 1 ) ans [ temp [ i ] ] = i ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( i > 1 && ans [ i - 1 ] != - 1 ) { if ( ans [ i ] == - 1 ) ans [ i ] = ans [ i - 1 ] ; else ans [ i ] = Math . Min ( ans [ i ] , ans [ i - 1 ] ) ; } Console . Write ( ans [ i ] + " " ) ; } }
int maxiConsecutiveSubarray ( int [ ] arr , int N ) { int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N - 1 ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = Math . Max ( maxi , cnt ) ; i = j ; } return maxi ; }
void FindTrip ( int [ ] arr , int N ) { for ( int i = 1 ; i < N - 1 ; i ++ ) { int p = arr [ i - 1 ] ; int q = arr [ i ] ; int r = arr [ i + 1 ] ; if ( p < q && q > r ) { Console . WriteLine ( ( i - 1 ) + " " + ( i ) + " " + ( i + 1 ) ) ; return ; } } Console . WriteLine ( - 1 ) ; }
int cntSubarrays ( int [ ] arr , int N ) { int cntSub = 0 ; int cntUnique = 0 ; Dictionary < int , int > cntFreq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j ++ ) { if ( cntFreq . ContainsKey ( arr [ j ] ) ) { var val = cntFreq [ arr [ j ] ] ; cntFreq . Remove ( arr [ j ] ) ; cntFreq . Add ( arr [ j ] , val + 1 ) ; } else { cntFreq . Add ( arr [ j ] , 1 ) ; } if ( cntFreq [ arr [ j ] ] == 1 ) { cntUnique ++ ; } else if ( cntFreq [ arr [ j ] ] == 2 ) { cntUnique -- ; } if ( cntUnique == 0 ) { cntSub ++ ; } } cntFreq . Clear ( ) ; cntUnique = 0 ; } return cntSub ; }
bool checkPalinK ( String str , int K ) { int N = str . Length ; int [ ] cntFreq = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { cntFreq [ str [ i ] ] ++ ; } int cntOddFreq = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( cntFreq [ i ] % 2 == 1 ) { cntOddFreq ++ ; } } if ( cntOddFreq <= ( K + 1 ) ) { return true ; } return false ; }
void printIndexes ( char [ ] str ) { int N = str . Length ; int [ ] cntFreq = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { cntFreq [ str [ i ] ] ++ ; } int [ ] cntLeftFreq = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { int cntLeft = 0 ; int cntRight = 0 ; for ( int j = str [ i ] - 1 ; j >= 0 ; j -- ) { cntLeft += cntLeftFreq [ j ] ; cntRight += cntFreq [ j ] - cntLeftFreq [ j ] ; } cntLeftFreq [ str [ i ] ] ++ ; if ( cntLeft == cntRight && cntLeft != 0 ) { Console . Write ( i + " " ) ; } } }
int digiSum ( int a ) { int sum = 0 ; while ( a != 0 ) { sum += a % 10 ; a = a / 10 ; } return sum ; }
bool isPrime ( int r ) { bool s = true ; for ( int i = 2 ; i * i <= r ; i ++ ) { if ( r % i == 0 ) { s = false ; break ; } } return s ; }
int Count_Number ( int x ) { int ans = 0 ; if ( x % 99 != 0 ) { ans = - 1 ; } else { int diff = x / 99 ; for ( int i = 1 ; i < 10 ; i ++ ) { for ( int j = 1 ; j < 10 ; j ++ ) { if ( ( i - j ) == diff ) { ans += 10 ; } } } } return ans ; }
int find_index ( int [ ] arr , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == K ) return i ; else if ( arr [ i ] > K ) return i ; return n ; }
int find_index ( int [ ] arr , int n , int K ) { int start = 0 ; int end = n - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] == K ) return mid ; else if ( arr [ mid ] < K ) start = mid + 1 ; else end = mid - 1 ; } return end + 1 ; }
bool isinRange ( int [ , ] board ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( board [ i , j ] <= 0 board [ i , j ] > 9 ) { return false ; } } } return true ; }
bool isValidSudoku ( int [ , ] board ) { if ( isinRange ( board ) == false ) { return false ; } bool [ ] unique = new bool [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { Array . Fill ( unique , false ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ i , j ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N ; i ++ ) { Array . Fill ( unique , false ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ j , i ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N - 2 ; i += 3 ) { for ( int j = 0 ; j < N - 2 ; j += 3 ) { Array . Fill ( unique , false ) ; for ( int k = 0 ; k < 3 ; k ++ ) { for ( int l = 0 ; l < 3 ; l ++ ) { int X = i + k ; int Y = j + l ; int Z = board [ X , Y ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } } } return true ; }
void minSubarray ( int [ ] arr , int N ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int mini = int . MaxValue ; for ( int j = i ; j < N ; j ++ ) { mini = Math . Min ( mini , arr [ j ] ) ; if ( mp . ContainsKey ( mini ) ) { mp [ mini ] = mp [ mini ] + 1 ; } else { mp . Add ( mini , 1 ) ; } } } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( mp [ arr [ i ] ] + " " ) ; } }
void minSubarray ( int [ ] arr , int N ) { int [ ] result = new int [ N ] ; Stack < pair > l = new Stack < pair > ( ) ; Stack < pair > r = new Stack < pair > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int count = 1 ; while ( l . Count != 0 && l . Peek ( ) . first > arr [ i ] ) { count += l . Peek ( ) . second ; l . Pop ( ) ; } l . Push ( new pair ( arr [ i ] , count ) ) ; result [ i ] = count ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { int count = 1 ; while ( r . Count != 0 && r . Peek ( ) . first >= arr [ i ] ) { count += r . Peek ( ) . second ; r . Pop ( ) ; } r . Push ( new pair ( arr [ i ] , count ) ) ; result [ i ] *= count ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( result [ i ] + " " ) ; } }
bool isPrime ( int num ) { if ( num <= 1 ) return false ; for ( int i = 2 ; i * i <= num ; i ++ ) if ( num % i == 0 ) return false ; return true ; }
bool isFulPrime ( int n ) { if ( ! isPrime ( n ) ) return false ; else { while ( n > 0 ) { int rem = n % 10 ; if ( ! ( rem == 2 rem == 3 rem == 5 rem == 7 ) ) return false ; n = n / 10 ; } } return true ; }
int countFulPrime ( int L , int R ) { int cnt = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( ( i % 2 ) != 0 && isFulPrime ( i ) ) { cnt ++ ; } } return cnt ; }
int computePos ( int [ ] arr , int n , int value ) { if ( value < arr [ 0 ] ) return 0 ; if ( value > arr [ n - 1 ] ) return n - 1 ; int start = 0 ; int end = n - 1 ; while ( start < end ) { int mid = ( start + end + 1 ) / 2 ; if ( arr [ mid ] >= value ) end = mid - 1 ; else start = mid ; } return start ; }
void countShift ( int [ ] arr , int n , List < List < int > > queries ) { foreach ( List < int > q in queries ) { int index = q [ 0 ] ; int update = q [ 1 ] ; int newElement = arr [ index ] + update ; int newIndex = computePos ( arr , n , newElement ) ; Console . Write ( Math . Abs ( newIndex - index ) + " " ) ; } }
void printAlter ( int [ ] arr , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex ++ ) { if ( currIndex % 2 == 0 ) { Console . Write ( arr [ currIndex ] + " " ) ; } } }
void printAlter ( int [ ] arr , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex += 2 ) { Console . Write ( arr [ currIndex ] + " " ) ; } }
int findmin ( string s ) { int n = s . Length ; int i , j , maximum = 0 ; int [ ] incr = new int [ n + 1 ] ; for ( i = 0 ; i < n ; i ++ ) { incr [ i + 1 ] = incr [ i ] ; if ( s [ i ] == '0' ) { incr [ i + 1 ] ++ ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { maximum = Math . Max ( maximum , incr [ i ] + j - i + 1 - ( incr [ j + 1 ] - incr [ i ] ) + incr [ n ] - incr [ j + 1 ] ) ; } } return n - maximum ; }
void SieveOfEratosthenes ( bool [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
int digitSum ( int number ) { int sum = 0 ; while ( number > 0 ) { sum += ( number % 10 ) ; number /= 10 ; } return sum ; }
void longestCompositeDigitSumSubsequence ( int [ ] arr , int n ) { int count = 0 ; bool [ ] prime = new bool [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) { int res = digitSum ( arr [ i ] ) ; if ( res == 1 ) { continue ; } if ( prime [ res ] == false ) { count ++ ; } } Console . WriteLine ( count ) ; }
bool isPower ( int x ) { if ( x != 0 && ( x & ( x - 1 ) ) == 0 ) return true ; return false ; }
void maximumlength ( int [ ] arr , int N ) { int max_length = 0 ; int max_len_subarray = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( isPower ( arr [ i ] ) ) { max_length ++ ; max_len_subarray = Math . Max ( max_length , max_len_subarray ) ; } else { max_length = 0 ; } } Console . WriteLine ( max_len_subarray ) ; }
void minSub ( int N ) { int count = 0 ; while ( N >= 0 ) { int num = N ; int rev = 0 ; while ( num != 0 ) { int digit = num % 10 ; rev = ( rev * 10 ) + digit ; num = num / 10 ; } if ( N == rev ) { break ; } count ++ ; N -- ; } Console . Write ( count ) ; }
bool isPalindrome ( String str ) { int i = 0 , j = str . Length - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
int isPerfect ( int N ) { int sum = 1 ; for ( int i = 2 ; i < Math . Sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { sum += i ; } else { sum += i + N / i ; } } } if ( sum == N && N != 1 ) return 1 ; return 0 ; }
int maxSum ( int [ ] arr , int N , int K ) { if ( N < K ) { Console . Write ( "Invalid" ) ; return - 1 ; } int res = 0 ; for ( int i = 0 ; i < K ; i ++ ) { res += arr [ i ] ; } int curr_sum = res ; for ( int i = K ; i < N ; i ++ ) { curr_sum += arr [ i ] - arr [ i - K ] ; res = Math . Max ( res , curr_sum ) ; } return res ; }
int max_PerfectNumbers ( int [ ] arr , int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = isPerfect ( arr [ i ] ) == 1 ? 1 : 0 ; } return maxSum ( arr , N , K ) ; }
int minElements ( int [ ] A , int [ ] B , int N , int M ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < A . Length ; i ++ ) { map . Add ( A [ i ] , i ) ; } List < int > subseq = new List < int > ( ) ; int l = 0 , r = - 1 ; for ( int i = 0 ; i < M ; i ++ ) { if ( map . ContainsKey ( B [ i ] ) ) { int e = map [ B [ i ] ] ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( subseq [ m ] < e ) l = m + 1 ; else r = m - 1 ; } if ( r + 1 < subseq . Count ) { subseq [ r + 1 ] = e ; } else { subseq . Add ( e ) ; } l = 0 ; r = subseq . Count - 1 ; } } return N - subseq . Count ; }
int cntSubarr ( int [ ] arr , int N ) { int res = 0 ; int prefixXor = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { prefixXor = arr [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { prefixXor ^= arr [ j ] ; if ( prefixXor == 0 && ( j - i + 1 ) % 2 == 0 ) { res ++ ; } } } return res ; }
int cntSubXor ( int [ ] arr , int N ) { int prefixXor = 0 ; int [ ] Even = new int [ M ] ; int [ ] Odd = new int [ M ] ; int cntSub = 0 ; Odd [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { prefixXor ^= arr [ i ] ; if ( i % 2 == 1 ) { cntSub += Odd [ prefixXor ] ; Odd [ prefixXor ] ++ ; } else { cntSub += Even [ prefixXor ] ; Even [ prefixXor ] ++ ; } } return cntSub ; }
int zvalue ( int [ ] nums ) { int m = max_element ( nums ) ; int cnt = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { cnt = 0 ; for ( int j = 0 ; j < nums . Length ; j ++ ) { if ( nums [ j ] >= i ) cnt ++ ; } if ( cnt == i ) return i ; } return - 1 ; }
bool isEvenOddBinaryTree ( Node root ) { if ( root == null ) return true ; Queue < Node > q = new Queue < Node > ( ) ; q . Enqueue ( root ) ; int level = 0 ; while ( q . Count != 0 ) { int size = q . Count ; for ( int i = 0 ; i < size ; i ++ ) { Node node = q . Dequeue ( ) ; if ( level % 2 == 0 ) { if ( node . val % 2 == 1 ) return false ; } else if ( level % 2 == 1 ) { if ( node . val % 2 == 0 ) return false ; } if ( node . left != null ) { q . Enqueue ( node . left ) ; } if ( node . right != null ) { q . Enqueue ( node . right ) ; } } level ++ ; } return true ; }
bool is_prime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
void countSmallerPrimes ( int [ ] ar , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = i + 1 ; j < N ; j ++ ) { if ( ar [ j ] <= ar [ i ] && is_prime ( ar [ j ] ) ) { count ++ ; } } Console . Write ( count + " " ) ; } }
bool is_prime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
bool checkConcat ( String str1 , String str2 ) { int N = str1 . Length ; int M = str2 . Length ; if ( N % M != 0 ) { return false ; } for ( int i = 0 ; i < N ; i ++ ) { if ( str1 [ i ] != str2 [ i % M ] ) { return false ; } } return true ; }
int MinLen ( String str , int K ) { int N = str . Length ; int i = 0 ; while ( i < N - 1 ) { if ( str [ i ] != str [ i + 1 ] ) { break ; } i ++ ; } if ( i == N - 1 ) { return N ; } return Math . Max ( 1 , N - K ) ; }
int findSubArray ( int [ ] arr , int k ) { int n = arr . Length ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( palindrome ( arr , i , i + k - 1 ) ) return i ; } return - 1 ; }
bool helper ( int mid ) { int cnt = 0 ; foreach ( KeyValuePair < int , int > i in mp ) { int temp = i . Value ; while ( temp >= mid ) { temp -= mid ; cnt ++ ; } } return cnt >= N ; }
int findMaximumDays ( int [ ] arr ) { for ( int i = 0 ; i < P ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } int start = 0 , end = P , ans = 0 ; while ( start <= end ) { int mid = start + ( ( end - start ) / 2 ) ; if ( mid != 0 && helper ( mid ) ) { ans = mid ; start = mid + 1 ; } else if ( mid == 0 ) { start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; }
double temp ( int n , int x ) { return Math . Pow ( x * 1.0 / n , n ) ; }
bool check ( int n , int y , int x ) { double v = temp ( n , x ) ; return ( v >= y ) ; }
void speciallyBalancedNodes ( int R , int N , String [ ] str , int [ ] values ) { Node root = build_tree ( R , N , str , values ) ; sum = 0 ; SBTUtil ( root ) ; Console . Write ( sum + " " ) ; }
void display ( int [ ] countLeftGreater , int N ) { for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( countLeftGreater [ i ] + " " ) ; } }
int minLength ( int [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return 1 ; } } return N ; }
void PrintIndexes ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int currSubSum = 0 ; for ( int j = i ; j < N ; j ++ ) { currSubSum += arr [ j ] ; int sq = ( int ) Math . Sqrt ( currSubSum ) ; if ( sq * sq == currSubSum ) { Console . Write ( "(" + i + "," + j + ")" + " " ) ; } } } }
bool check ( int [ ] pSum , int len , int k , int [ ] a ) { int i = 0 ; int j = len ; while ( j <= a . Length ) { int maxSize = a [ j - 1 ] ; int totalNumbers = maxSize * len ; int currNumbers = pSum [ j ] - pSum [ i ] ; if ( currNumbers + k >= totalNumbers ) { return true ; } else { i ++ ; j ++ ; } } return false ; }
int countPosition ( int [ , ] mat ) { int n = mat . GetLength ( 0 ) ; int m = mat . GetLength ( 1 ) ; int [ ] row = new int [ n ] ; int [ ] col = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i , j ] == 1 ) { col [ j ] ++ ; row [ i ] ++ ; } } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( row [ i ] == col [ j ] ) { count ++ ; } } } return count ; }
void position ( int [ , ] arr , int N ) { int pos = - 1 ; int count ; for ( int i = 0 ; i < N ; i ++ ) { count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i , 0 ] <= arr [ j , 0 ] && arr [ i , 1 ] >= arr [ j , 1 ] ) { count ++ ; } } if ( count == N ) { pos = i ; } } if ( pos == - 1 ) { Console . Write ( pos ) ; } else { Console . Write ( pos + 1 ) ; } }
void maxAtLevel ( int N , int M , int [ ] Value , int [ , ] Edges ) { List < int > [ ] adj = new List < int > [ N ] ; for ( int i = 0 ; i < adj . Length ; i ++ ) adj [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i , 0 ] ; int v = Edges [ i , 1 ] ; adj [ u ] . Add ( v ) ; } Queue < int > q = new Queue < int > ( ) ; q . Enqueue ( 0 ) ; while ( q . Count != 0 ) { int count = q . Count ; int maxVal = 0 ; while ( count -- > 0 ) { int temp = q . Peek ( ) ; q . Dequeue ( ) ; maxVal = Math . Max ( maxVal , Value [ temp ] ) ; for ( int i = 0 ; i < adj [ temp ] . Count ; i ++ ) { q . Enqueue ( adj [ temp ] [ i ] ) ; } } Console . Write ( maxVal + " " ) ; } }
int floyd_warshall ( int [ , ] graph , int V ) { int [ , ] dist = new int [ V , V ] ; int i , j , k ; for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { dist [ i , j ] = graph [ i , j ] ; } } for ( k = 0 ; k < V ; k ++ ) { for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { if ( dist [ i , k ] + dist [ k , j ] < dist [ i , j ] ) { dist [ i , j ] = dist [ i , k ] + dist [ k , j ] ; } } } } int sum = 0 ; for ( i = 0 ; i < V ; i ++ ) { for ( j = i + 1 ; j < V ; j ++ ) { sum += dist [ i , j ] ; } } return sum ; }
int sumOfshortestPath ( int N , int E , int [ , ] edges ) { int [ , ] g = new int [ N , N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { g [ i , j ] = INF ; } } for ( int i = 0 ; i < E ; i ++ ) { int u = edges [ i , 0 ] ; int v = edges [ i , 1 ] ; int w = edges [ i , 2 ] ; g [ u , v ] = w ; g [ v , u ] = w ; } return floyd_warshall ( g , N ) ; }
int minCost ( string A , string B ) { int n = A . Length ; int i = 0 ; int maxlen = 0 ; while ( i < n ) { int length = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ] == B [ j ] ) { ++ i ; ++ length ; if ( i == n ) break ; } } maxlen = Math . Max ( maxlen , length ) ; } return n - maxlen ; }
int binarySearch ( int [ ] arr , int N , int X ) { int start = 0 ; int end = N ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( X == arr [ mid ] ) { return mid ; } else if ( X < arr [ mid ] ) { start = mid + 1 ; } else { end = mid - 1 ; } } return - 1 ; }
bool check ( int [ ] a , int n ) { int [ ] b = new int [ n ] ; int minElement = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = a [ i ] ; minElement = Math . Min ( minElement , a [ i ] ) ; } Array . Sort ( b ) ; int k = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] && a [ i ] % minElement != 0 ) { k = 0 ; break ; } } return k == 1 ? true : false ; }
bool check_both_present ( int [ ] arr , int N , int a , int b ) { bool f1 = false , f2 = false ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == a ) { f1 = true ; } if ( arr [ i ] == b ) { f2 = true ; } } if ( f1 && f2 ) { return true ; } else { return false ; } }
void print_array ( int [ ] ans , int N ) { for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( ans [ i ] + " " ) ; } }
void build_AP ( int N , int a , int b ) { int [ ] arr = new int [ N ] ; int [ ] ans = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) ans [ i ] = int . MaxValue ; if ( a > b ) { a += ( b - ( b = a ) ) ; } int diff = b - a ; for ( int start = 1 ; start <= a ; start ++ ) { for ( int d = 1 ; d <= diff ; d ++ ) { arr [ 0 ] = start ; for ( int i = 1 ; i < N ; i ++ ) { arr [ i ] = arr [ i - 1 ] + d ; } if ( check_both_present ( arr , N , a , b ) && arr [ N - 1 ] < ans [ N - 1 ] ) { for ( int i = 0 ; i < N ; i ++ ) { ans [ i ] = arr [ i ] ; } } } } print_array ( ans , N ) ; }
int numSpecial ( int [ , ] mat ) { int m = mat . GetLength ( 0 ) ; int n = mat . GetLength ( 1 ) ; int [ ] rows = new int [ m ] ; int [ ] cols = new int [ n ] ; int i , j ; for ( i = 0 ; i < m ; i ++ ) { rows [ i ] = 0 ; for ( j = 0 ; j < n ; j ++ ) rows [ i ] += mat [ i , j ] ; } for ( i = 0 ; i < n ; i ++ ) { cols [ i ] = 0 ; for ( j = 0 ; j < m ; j ++ ) cols [ i ] += mat [ j , i ] ; } int cnt = 0 ; for ( i = 0 ; i < m ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( mat [ i , j ] == 1 && rows [ i ] == 1 && cols [ j ] == 1 ) cnt ++ ; } } return cnt ; }
int ctMinEdits ( string str1 , string str2 ) { int N1 = str1 . Length ; int N2 = str2 . Length ; int [ ] freq1 = new int [ 256 ] ; freq1 [ 0 ] = str1 [ 0 ] ; for ( int i = 0 ; i < N1 ; i ++ ) { freq1 [ str1 [ i ] ] ++ ; } int [ ] freq2 = new int [ 256 ] ; freq2 [ 0 ] = str2 [ 0 ] ; for ( int i = 0 ; i < N2 ; i ++ ) { freq2 [ str2 [ i ] ] ++ ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freq1 [ i ] > freq2 [ i ] ) { freq1 [ i ] = freq1 [ i ] - freq2 [ i ] ; freq2 [ i ] = 0 ; } else { freq2 [ i ] = freq2 [ i ] - freq1 [ i ] ; freq1 [ i ] = 0 ; } } int sum1 = 0 ; int sum2 = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { sum1 += freq1 [ i ] ; sum2 += freq2 [ i ] ; } return Math . Max ( sum1 , sum2 ) ; }
void create_graph ( ) { g [ 1 ] . Add ( 2 ) ; g [ 2 ] . Add ( 1 ) ; g [ 1 ] . Add ( 3 ) ; g [ 3 ] . Add ( 1 ) ; g [ 1 ] . Add ( 4 ) ; g [ 4 ] . Add ( 1 ) ; g [ 2 ] . Add ( 5 ) ; g [ 5 ] . Add ( 2 ) ; g [ 2 ] . Add ( 6 ) ; g [ 6 ] . Add ( 2 ) ; }
void dfs ( int node , int parent ) { size [ node ] = 1 ; int mx = 0 ; foreach ( int y in g [ node ] ) { if ( y == parent ) continue ; dfs ( y , node ) ; size [ node ] += size [ y ] ; mx = Math . Max ( mx , size [ y ] ) ; } mx = Math . Max ( mx , n - size [ node ] ) ; if ( mx < mini ) { mini = mx ; ans = node ; } }
int countPrecedingK ( int [ ] a , int n , int K ) { int [ ] prefix = new int [ n ] ; prefix [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + a [ i ] ; } int ctr = 0 ; if ( prefix [ K - 1 ] < a [ K ] ) ctr ++ ; for ( int i = K + 1 ; i < n ; i ++ ) { if ( prefix [ i - 1 ] - prefix [ i - K - 1 ] < a [ i ] ) ctr ++ ; } return ctr ; }
int minDigits ( int N , int K ) { int digits_num = ( int ) Math . Floor ( Math . Log ( N ) + 1 ) ; int temp_sum = 0 ; int temp = digits_num ; int result = 0 ; int X , var ; int sum = 0 ; int num2 = N ; while ( num2 != 0 ) { sum += num2 % 10 ; num2 /= 10 ; } if ( sum <= K ) { X = 0 ; } else { while ( temp > 0 ) { var = ( N / ( ( int ) Math . Pow ( 10 , temp - 1 ) ) ) ; . temp_sum += var % 10 ; if ( temp_sum >= K ) { var /= 10 ; var ++ ; result = var * ( int ) Math . Pow ( 10 , temp ) ; break ; } temp -- ; } X = result - N ; return X ; } return - 1 ; }
void CountPairs ( int [ ] a , int [ ] b , int n ) { int [ ] C = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { C [ i ] = a [ i ] + b [ i ] ; } Dictionary < int , int > freqCount = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! freqCount . ContainsKey ( C [ i ] ) ) freqCount . Add ( C [ i ] , 1 ) ; else freqCount [ C [ i ] ] = freqCount [ C [ i ] ] + 1 ; } int NoOfPairs = 0 ; foreach ( KeyValuePair < int , int > x in freqCount ) { int y = x . Value ; NoOfPairs = NoOfPairs + y * ( y - 1 ) / 2 ; } Console . WriteLine ( NoOfPairs ) ; }
void convertBfromA ( int a , int b ) { int moves = 0 ; int x = Math . Abs ( a - b ) ; for ( int i = 10 ; i > 0 ; i -- ) { moves += x / i ; x = x % i ; } Console . Write ( moves + " " ) ; }
int smallestNth ( int A , int B , int N ) { int res = Int32 . MaxValue ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = N ; j > i ; j -- ) { if ( ( B - A ) % ( j - i ) == 0 ) { int D = ( B - A ) / ( j - i ) ; int FirstTerm = A - ( i - 1 ) * D ; int NthTerm = FirstTerm + ( N - 1 ) * D ; if ( FirstTerm > 0 ) res = Math . Min ( res , NthTerm ) ; } } } return res ; }
void sieve ( bool [ ] prime ) { for ( int i = 0 ; i < 1000000 ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i * i <= 1000000 ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * i ; j < 1000000 ; j += i ) { prime [ j ] = false ; } } } }
void subPrimeSum ( int N , int K , int [ ] arr , bool [ ] prime ) { int currSum = 0 ; for ( int i = 0 ; i < K ; i ++ ) { currSum += arr [ i ] ; } if ( prime [ currSum ] ) { for ( int i = 0 ; i < K ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } return ; } int st = 1 , en = K ; while ( en < N ) { currSum += arr [ en ] - arr [ st - 1 ] ; if ( prime [ currSum ] ) { for ( int i = st ; i <= en ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } return ; } en ++ ; st ++ ; } }
int minDeletion ( string str ) { int n = str . Length ; int firstIdx1 = - 1 ; int lastIdx0 = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { firstIdx1 = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) { lastIdx0 = i ; break ; } } if ( firstIdx1 == - 1 lastIdx0 == - 1 ) return 0 ; int count1 = 0 , count0 = 0 ; for ( int i = 0 ; i < lastIdx0 ; i ++ ) { if ( str [ i ] == '1' ) { count1 ++ ; } } for ( int i = firstIdx1 + 1 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { count0 ++ ; } } return Math . Min ( count0 , count1 ) ; }
int maximumSum ( int [ ] a , int [ ] b , int n , int index , int lastpicked ) { if ( index == n ) return 0 ; int option1 = 0 , option2 = 0 ; if ( lastpicked == - 1 a [ lastpicked ] != a [ index ] ) option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) ; option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) ; return Math . Max ( option1 , option2 ) ; }
int maximumSum ( int [ ] a , int [ ] b , int n , int index , int lastpicked , int [ , ] dp ) { if ( index == n ) return 0 ; if ( dp [ index , lastpicked + 1 ] != - 1 ) return dp [ index , lastpicked + 1 ] ; int option1 = 0 , option2 = 0 ; if ( lastpicked == - 1 a [ lastpicked ] != a [ index ] ) { option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index , dp ) ; } option2 = maximumSum ( a , b , n , index + 1 , lastpicked , dp ) ; return dp [ index , lastpicked + 1 ] = Math . Max ( option1 , option2 ) ; }
void sumOfKElements ( int [ ] arr , int n , int k ) { bool rev = false ; if ( k < 0 ) { rev = true ; k *= - 1 ; int l = 0 , r = n - 1 ; while ( l < r ) { int tmp = arr [ l ] ; arr [ l ] = arr [ r ] ; arr [ r ] = tmp ; l ++ ; r -- ; } } int [ ] dp = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] += dp [ i - 1 ] + arr [ i ] ; } int [ ] ans = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i + k < n ) ans [ i ] = dp [ i + k ] - dp [ i ] ; else { int x = k - ( n - 1 - i ) ; int y = x / n ; int rem = x % n ; ans [ i ] = dp [ n - 1 ] - dp [ i ] + y * dp [ n - 1 ] + ( rem - 1 >= 0 ? dp [ rem - 1 ] : 0 ) ; } } if ( rev ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { Console . Write ( ans [ i ] + " " ) ; } } else { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( ans [ i ] + " " ) ; } } }
int [ ] countingSubarray ( int [ ] arr , int n ) { int [ ] a = new int [ n ] ; int [ ] nsml = new int [ n ] ; Array . Fill ( nsml , - 1 ) ; int [ ] nsmr = new int [ n ] ; Array . Fill ( nsmr , n ) ; Stack st = new Stack ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( st . Count > 0 && arr [ ( int ) st . Peek ( ) ] >= arr [ i ] ) st . Pop ( ) ; nsmr [ i ] = ( st . Count > 0 ) ? ( int ) st . Peek ( ) : n ; st . Push ( i ) ; } while ( st . Count > 0 ) st . Pop ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( st . Count > 0 && arr [ ( int ) st . Peek ( ) ] >= arr [ i ] ) st . Pop ( ) ; nsml [ i ] = ( st . Count > 0 ) ? ( int ) st . Peek ( ) : - 1 ; st . Push ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { nsml [ i ] ++ ; nsmr [ i ] -- ; int r = nsmr [ i ] - i + 1 ; int l = i - nsml [ i ] + 1 ; a [ i ] = r * l ; } return a ; }
int countTuples ( int [ ] arr , int N ) { int ans = 0 , val = 0 ; Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int j = 0 ; j < N - 2 ; j ++ ) { val = 0 ; for ( int l = j + 1 ; l < N ; l ++ ) { if ( arr [ j ] == arr [ l ] ) { ans += val ; } if ( freq . ContainsKey ( arr [ l ] ) ) val += freq [ arr [ l ] ] ; } if ( freq . ContainsKey ( arr [ j ] ) ) { freq [ arr [ j ] ] = freq [ arr [ j ] ] + 1 ; } else { freq . Add ( arr [ j ] , 1 ) ; } } return ans ; }
void isCrossed ( String path ) { if ( path . Length == 0 ) return ; bool ans = false ; HashSet < KeyValuePair < int , int > > mySet = new HashSet < KeyValuePair < int , int > > ( ) ; int x = 0 , y = 0 ; mySet . Add ( new KeyValuePair < int , int > ( x , y ) ) ; for ( int i = 0 ; i < path . Length ; i ++ ) { if ( path [ i ] == 'N' ) mySet . Add ( new KeyValuePair < int , int > ( x , y ++ ) ) ; if ( path [ i ] == 'S' ) mySet . Add ( new KeyValuePair < int , int > ( x , y -- ) ) ; if ( path [ i ] == 'E' ) mySet . Add ( new KeyValuePair < int , int > ( x ++ , y ) ) ; if ( path [ i ] == 'W' ) mySet . Add ( new KeyValuePair < int , int > ( x -- , y ) ) ; if ( mySet . Contains ( new KeyValuePair < int , int > ( x , y ) ) ) { ans = true ; break ; } } if ( ans ) Console . Write ( "Crossed" ) ; else Console . Write ( "Not Crossed" ) ; }
int GCD ( int a , int b ) { if ( b == 0 ) { return a ; } return GCD ( b , a % b ) ; }
void GcdPair ( int [ , ] arr , int k ) { int lo = 0 , hi = arr . Length - 1 , mid ; int [ ] ans = { - 1 , 0 } ; while ( lo <= hi ) { mid = lo + ( hi - lo ) / 2 ; if ( GCD ( arr [ mid , 0 ] , arr [ mid , 1 ] ) > k ) { ans = GetRow ( arr , mid ) ; hi = mid - 1 ; } else lo = mid + 1 ; } if ( ans [ 0 ] == - 1 ) Console . Write ( "-1" ) ; else Console . Write ( "( " + ans [ 0 ] + ", " + ans [ 1 ] + " )" ) ; return ; }
void isPossible ( int [ ] arr , int N ) { int mn = int . MaxValue ; int [ ] B = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { mn = Math . Min ( mn , arr [ i ] ) ; B [ i ] = arr [ i ] ; } Array . Sort ( arr ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != B [ i ] ) { if ( B [ i ] % mn != 0 ) { Console . Write ( "No" ) ; return ; } } } Console . Write ( "Yes" ) ; return ; }
int func ( int n ) { int count = 0 ; if ( n == 2 n == 1 ) return 1 ; if ( n % 2 == 0 ) count = 1 + func ( n / 2 ) ; if ( n % 2 != 0 ) count = 1 + func ( n * 3 + 1 ) ; return count ; }
void findKthElement ( int l , int r , int k ) { List < int > arr = new List < int > ( ) ; for ( int i = l ; i <= r ; i ++ ) arr . Add ( i ) ; Dictionary < int , int > result = new Dictionary < int , int > ( ) ; foreach ( int i in arr ) { result . Add ( i , func ( i ) ) ; } var myList = result . ToList ( ) ; myList . Sort ( ( pair1 , pair2 ) => pair1 . Value . CompareTo ( pair2 . Value ) ) ; Console . WriteLine ( myList [ 1 ] . Key ) ; }
void checkHex ( String s ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { char ch = s [ i ] ; if ( ( ch < '0' ch > '9' ) && ( ch < 'A' ch > 'F' ) ) { Console . WriteLine ( "No" ) ; return ; } } Console . WriteLine ( "Yes" ) ; }
int maxWidth ( int N , int M , List < int > cost , List < List < int > > s ) { List < List < int > > adj = new List < List < int > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { adj . Add ( new List < int > ( ) ) ; } for ( int i = 0 ; i < M ; i ++ ) { adj [ s [ i ] [ 0 ] ] . Add ( s [ i ] [ 1 ] ) ; } int result = 0 ; Queue < int > q = new Queue < int > ( ) ; q . Enqueue ( 0 ) ; while ( q . Count != 0 ) { int count = q . Count ; result = Math . Max ( count , result ) ; while ( count -- > 0 ) { int temp = q . Dequeue ( ) ; for ( int i = 0 ; i < adj [ temp ] . Count ; i ++ ) { q . Enqueue ( adj [ temp ] [ i ] ) ; } } } return result ; }
void addEdge ( ArrayList adj , int u , int v ) { ( ( ArrayList ) adj [ u ] ) . Add ( v ) ; ( ( ArrayList ) adj [ v ] ) . Add ( u ) ; }
void DFSUtil ( int u , ArrayList adj , bool [ ] visited , int componentMin , int componentMax ) { visited [ u ] = true ; componentMax = Math . Max ( componentMax , u ) ; componentMin = Math . Min ( componentMin , u ) ; for ( int i = 0 ; i < ( ( ArrayList ) adj [ u ] ) . Count ; i ++ ) if ( visited [ ( int ) ( ( ArrayList ) adj [ u ] ) [ i ] ] == false ) DFSUtil ( ( int ) ( ( ArrayList ) adj [ u ] ) [ i ] , adj , visited , componentMin , componentMax ) ; }
bool isValid ( ArrayList v ) { int MAX = - 1 ; bool ans = false ; foreach ( pair i in v ) { if ( i . first <= MAX ) { ans = true ; } MAX = Math . Max ( MAX , i . second ) ; } return ( ans == false ? true : false ) ; }
void DFS ( ArrayList adj , int V ) { ArrayList v = new ArrayList ( ) ; bool [ ] visited = new bool [ V + 1 ] ; for ( int u = 1 ; u <= V ; u ++ ) { if ( visited [ u ] == false ) { int componentMax = u ; int componentMin = u ; DFSUtil ( u , adj , visited , componentMin , componentMax ) ; v . Add ( new pair ( componentMin , componentMax ) ) ; } } bool check = isValid ( v ) ; if ( check ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; return ; }
bool checkEqual ( String [ ] arr , int N ) { int [ ] hash = new int [ 256 ] ; int M = arr [ 0 ] . Length ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { hash [ arr [ i ] [ j ] ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( hash [ i ] % N != 0 ) { return false ; } } return true ; }
void print_substring ( String s ) { int n = s . Length ; String str = "" ; if ( n == 0 ) { Console . Write ( "-1" ) ; return ; } int [ ] last_pos = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) last_pos [ i ] = - 1 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( last_pos [ s [ i ] - 'a' ] == - 1 ) { last_pos [ s [ i ] - 'a' ] = i ; } } int minp = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { int lp = last_pos [ s [ i ] - 'a' ] ; minp = Math . Max ( minp , lp ) ; if ( i == minp ) { str += s [ i ] ; Console . Write ( str + ' ' ) ; minp = - 1 ; str = "" ; } else { str += s [ i ] ; } } }
void partitionString ( String s ) { int n = s . Length ; List < int > ans = new List < int > ( ) ; if ( n == 0 ) { Console . Write ( "-1" ) ; return ; } int [ ] last_pos = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; ++ i ) { last_pos [ i ] = - 1 ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( last_pos [ s [ i ] - 'a' ] == - 1 ) { last_pos [ s [ i ] - 'a' ] = i ; } } int minp = - 1 , plen = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int lp = last_pos [ s [ i ] - 'a' ] ; minp = Math . Max ( minp , lp ) ; ++ plen ; if ( i == minp ) { ans . Add ( plen ) ; minp = - 1 ; plen = 0 ; } } for ( int i = 0 ; i < ( int ) ans . Count ; i ++ ) { Console . Write ( ans [ i ] + " " ) ; } }
int lenghtOfLongestAP ( int [ ] A , int n ) { Dictionary < int , Dictionary < int , int > > dp = new Dictionary < int , Dictionary < int , int > > ( ) ; int res = 2 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int d = A [ j ] - A [ i ] ; if ( dp . ContainsKey ( d ) ) { if ( dp [ d ] . ContainsKey ( i ) ) { dp [ d ] [ j ] = dp [ d ] [ i ] + 1 ; } else { dp [ d ] [ j ] = 2 ; } } else { dp [ d ] = new Dictionary < int , int > ( ) ; dp [ d ] [ j ] = 2 ; } res = Math . Max ( res , dp [ d ] [ j ] ) ; } } return res ; }
void numDifferenceUtil ( int N , int K ) { ArrayList res = new ArrayList ( ) ; res = numDifference ( N , K ) ; for ( int i = 0 ; i < res . Count ; i ++ ) { Console . Write ( res [ i ] + " " ) ; } }
int minFirstTerm ( int X , int diff , int N ) { int first_term = int . MaxValue ; int low = 0 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( X - mid * diff > 0 ) { first_term = X - mid * diff ; low = mid + 1 ; } else high = mid - 1 ; } return first_term ; }
bool isCubeSum ( int n ) { for ( int i = 1 ; i * i * i <= n ; i ++ ) { if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) return true ; } return false ; }
bool isSumCube ( int N ) { int a = ( int ) Math . Pow ( N , ( double ) 1 / 3 ) ; int b = a - 1 ; return ( ( a * a * a + b * b * b ) == N ) ; }
int maxweight ( int s , int e , Dictionary < int , int > pre ) { if ( s == e ) return 0 ; int ans = 0 ; for ( int i = s ; i < e ; i ++ ) { int left = pre [ i ] - pre [ s - 1 ] ; int right = pre [ e ] - pre [ i ] ; if ( left < right ) ans = Math . Max ( ans , left + maxweight ( s , i , pre ) ) ; if ( left == right ) { ans = Math . Max ( ans , Math . Max ( left + maxweight ( s , i , pre ) , right + maxweight ( i + 1 , e , pre ) ) ) ; } if ( left > right ) ans = Math . Max ( ans , right + maxweight ( i + 1 , e , pre ) ) ; } return ans ; }
void maxSum ( List < int > arr ) { Dictionary < int , int > pre = new Dictionary < int , int > ( ) ; pre . Add ( - 1 , 0 ) ; pre . Add ( 0 , arr [ 0 ] ) ; for ( int i = 1 ; i < arr . Count ; i ++ ) { if ( pre [ i - 1 ] != 0 ) pre . Add ( i , pre [ i - 1 ] + arr [ i ] ) ; else pre . Add ( i , arr [ i ] ) ; } Console . WriteLine ( maxweight ( 0 , arr . Count - 1 , pre ) ) ; }
void SieveOfEratosthenes ( bool [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
int LISPrime ( int [ ] arr , int n ) { int [ ] lisp = new int [ n ] ; bool [ ] prime = new bool [ N + 1 ] ; for ( int i = 0 ; i < prime . Length ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , N ) ; lisp [ 0 ] = prime [ arr [ 0 ] ] ? 1 : 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ! prime [ arr [ i ] ] ) { lisp [ i ] = 0 ; continue ; } lisp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( prime [ arr [ j ] ] && arr [ i ] > arr [ j ] && lisp [ i ] < lisp [ j ] + 1 ) { lisp [ i ] = lisp [ j ] + 1 ; } } } return lisp . Max ( ) ; }
void checkSumOfNatural ( int n ) { int i = 1 ; bool flag = false ; while ( i * ( i + 1 ) < n * 2 ) { int X = i * ( i + 1 ) ; int t = n * 2 - X ; int k = ( int ) Math . Sqrt ( t ) ; if ( k * ( k + 1 ) == t ) { flag = true ; break ; } i += 1 ; } if ( flag ) Console . WriteLine ( "YES" ) ; else Console . WriteLine ( "NO" ) ; }
void countNumEnds ( int A , int L , int R ) { int temp , count = 0 , digits ; int cycle ; digits = ( int ) ( Math . Log10 ( A ) + 1 ) ; temp = ( int ) Math . Pow ( 10 , digits ) ; cycle = temp ; while ( temp <= R ) { if ( temp >= L ) count ++ ; temp += cycle ; } Console . Write ( count ) ; }
int minOperations ( String s ) { int len = s . Length ; int result = 0 ; for ( int i = 0 ; i < len / 2 ; i ++ ) { int D1 = Math . Max ( s [ i ] , s [ len - 1 - i ] ) - Math . Min ( s [ i ] , s [ len - 1 - i ] ) ; int D2 = 26 - D1 ; result += Math . Min ( D1 , D2 ) ; } return result ; }
void countMaximum ( int [ ] a , int n ) { a . OrderByDescending ( c => c ) . ToArray ( ) ; int count = 0 ; int mark = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( a [ i ] + n >= mark ) ) { count += 1 ; } mark = Math . Max ( mark , a [ i ] + i + 1 ) ; } Console . Write ( count ) ; }
bool allCoprime ( int [ ] A , int n ) { bool all_coprime = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( gcd ( A [ i ] , A [ j ] ) != 1 ) { all_coprime = false ; break ; } } } return all_coprime ; }
long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
long findWays ( int n ) { if ( ( n & 1 ) == 1 ) return 0 ; return catalan ( n / 2 ) ; }
void countNonNPeriodic ( int N ) { Console . Write ( findWays ( 2 * N ) - findWays ( N ) ) ; }
int isValid ( int n , int m , int k ) { int step2 = n - m ; int cnt = ( step2 * ( step2 + 1 ) ) / 2 ; if ( cnt - m == k ) return 0 ; if ( cnt - m > k ) return 1 ; return - 1 ; }
void countOfOperations ( int n , int k ) { int start = 0 , end = n ; bool ok = true ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int temp = isValid ( n , mid , k ) ; if ( temp == 0 ) { ok = false ; Console . Write ( mid ) ; break ; } else if ( temp == 1 ) { start = mid + 1 ; } else { end = mid - 1 ; } } if ( ok ) Console . Write ( "-1" ) ; }
bool nonLower ( String s ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ! char . IsLower ( s [ i ] ) ) { return true ; } } return false ; }
char getChar ( int n ) { return ( char ) ( n + 96 ) ; }
String [ ] getCode ( String str ) { if ( str . Length == 0 ) { String [ ] ans = { "" } ; return ans ; } String [ ] output1 = getCode ( str . Substring ( 1 ) ) ; String [ ] output2 = new String [ 0 ] ; int firstDigit = ( str [ 0 ] - '0' ) ; int firstTwoDigit = 0 ; if ( str . Length >= 2 ) { firstTwoDigit = ( str [ 0 ] - '0' ) * 10 + ( str [ 1 ] - '0' ) ; if ( firstTwoDigit >= 10 && firstTwoDigit <= 26 ) { output2 = getCode ( str . Substring ( 2 ) ) ; } } String [ ] output = new String [ output1 . Length + output2 . Length ] ; int k = 0 ; for ( int i = 0 ; i < output1 . Length ; i ++ ) { char ch = getChar ( firstDigit ) ; output [ i ] = ch + output1 [ i ] ; k ++ ; } for ( int i = 0 ; i < output2 . Length ; i ++ ) { char ch = getChar ( firstTwoDigit ) ; output [ k ] = ch + output2 [ i ] ; k ++ ; } return output ; }
int smallestNum ( int n ) { double power = log2 ( 10 ) ; return ( int ) Math . Ceiling ( ( n - 1 ) * power ) ; }
double countSubSequence ( int [ ] arr , int n ) { int maximum = arr . Max ( ) ; int minimum = arr . Min ( ) ; if ( maximum == minimum ) return Math . Pow ( 2 , n ) - 1 ; int i = count ( arr , maximum ) ; int j = count ( arr , minimum ) ; double res = ( Math . Pow ( 2 , i ) - 1 ) * ( Math . Pow ( 2 , j ) - 1 ) * Math . Pow ( 2 , n - i - j ) ; return res ; }
int transformSubsequence ( int n , int m , int [ ] A , int [ ] B ) { if ( B . Length == 0 ) return n ; int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { if ( i == 0 j == 0 ) dp [ i , j ] = 0 ; else if ( A [ i - 1 ] == B [ j - 1 ] ) dp [ i , j ] = 1 + dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] , dp [ i , j - 1 ] ) ; } } return n - dp [ n , m ] ; }
void SieveOfEratosthenes ( ) { Array . Fill ( isPrime , true ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= MAX ; p ++ ) if ( isPrime [ p ] ) primes . Add ( p ) ; }
int prime_search ( ArrayList primes , int diff ) { int low = 0 ; int high = primes . Count - 1 ; int res = - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( int ) primes [ mid ] == diff ) { return ( int ) primes [ mid ] ; } else if ( ( int ) primes [ mid ] < diff ) { low = mid + 1 ; } else { res = ( int ) primes [ mid ] ; high = mid - 1 ; } } return res ; }
int minCost ( int [ ] arr , int n ) { SieveOfEratosthenes ( ) ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { int diff = arr [ i - 1 ] - arr [ i ] ; int closest_prime = prime_search ( primes , diff ) ; res += closest_prime ; arr [ i ] += closest_prime ; } } return res ; }
int isprm ( int n ) { if ( n <= 1 ) return 0 ; if ( n <= 3 ) return 1 ; if ( n % 2 == 0 n % 3 == 0 ) return 0 ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return 0 ; } return 1 ; }
int countprime ( int n ) { int count = 0 ; List < int > primevector = new List < int > ( ) ; for ( int i = 2 ; i <= n ; i ++ ) { if ( isprm ( i ) == 1 ) { primevector . Add ( i ) ; } } int sum = primevector [ 0 ] ; for ( int i = 1 ; i < primevector . Count ; i ++ ) { sum += primevector [ i ] ; if ( sum > n ) break ; if ( isprm ( sum ) == 1 ) { count ++ ; } } return count ; }
void addEdge ( List < int > [ ] v , int x , int y ) { v [ x ] . Add ( y ) ; v [ y ] . Add ( x ) ; }
void dfs ( List < int > [ ] tree , List < int > temp , int [ ] ancestor , int u , int parent , int k ) { temp . Add ( u ) ; foreach ( int i in tree [ u ] ) { if ( i == parent ) continue ; dfs ( tree , temp , ancestor , i , u , k ) ; } temp . RemoveAt ( temp . Count - 1 ) ; if ( temp . Count < k ) { ancestor [ u ] = - 1 ; } else { ancestor [ u ] = temp [ temp . Count - k ] ; } }
void KthAncestor ( int N , int K , int E , int [ , ] edges ) { List < int > [ ] tree = new List < int > [ N + 1 ] ; for ( int i = 0 ; i < tree . Length ; i ++ ) tree [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < E ; i ++ ) { addEdge ( tree , edges [ i , 0 ] , edges [ i , 1 ] ) ; } List < int > temp = new List < int > ( ) ; int [ ] ancestor = new int [ N + 1 ] ; dfs ( tree , temp , ancestor , 1 , 0 , K ) ; for ( int i = 1 ; i <= N ; i ++ ) { Console . Write ( ancestor [ i ] + " " ) ; } }
int [ ] dfs ( Node root , int distance ) { int [ ] res ; if ( root == null ) return new int [ distance + 1 ] ; if ( root . left == null && root . right == null ) { res = new int [ distance + 1 ] ; res [ 1 ] ++ ; return res ; } int [ ] left = dfs ( root . left , distance ) ; int [ ] right = dfs ( root . right , distance ) ; res = new int [ distance + 1 ] ; for ( int i = res . Length - 2 ; i >= 1 ; i -- ) { res [ i + 1 ] = left [ i ] + right [ i ] ; } for ( int l = 1 ; l < left . Length ; l ++ ) { for ( int r = 0 ; r < right . Length ; r ++ ) { if ( l + r <= distance ) { result += left [ l ] * right [ r ] ; } } } return res ; }
void build ( ArrayList sum , ArrayList a , int l , int r , int rt ) { if ( l == r ) { sum [ rt ] = a [ l - 1 ] ; return ; } int m = ( l + r ) >> 1 ; build ( sum , a , l , m , rt << 1 ) ; build ( sum , a , m + 1 , r , rt << 1 1 ) ; }
void pushDown ( ArrayList sum , ArrayList add , int rt , int ln , int rn ) { if ( ( int ) add [ rt ] != 0 ) { add [ rt << 1 ] = ( int ) add [ rt << 1 ] + ( int ) add [ rt ] ; add [ rt << 1 1 ] = ( int ) add [ rt << 1 1 ] + ( int ) add [ rt ] ; sum [ rt << 1 ] = ( int ) sum [ rt << 1 ] + ( int ) add [ rt ] * ln ; sum [ rt << 1 1 ] = ( int ) sum [ rt << 1 1 ] + ( int ) add [ rt ] * rn ; add [ rt ] = 0 ; } }
void update ( ArrayList sum , ArrayList add , int L , int R , int C , int l , int r , int rt ) { if ( L <= l && r <= R ) { sum [ rt ] = ( int ) sum [ rt ] + C * ( r - l + 1 ) ; add [ rt ] = ( int ) add [ rt ] + C ; return ; } int m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; if ( L <= m ) update ( sum , add , L , R , C , l , m , rt << 1 ) ; if ( R > m ) update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) ; }
void sequenceMaintenance ( int n , int q , ArrayList a , ArrayList b , int m ) { a . Sort ( ) ; ArrayList sum = new ArrayList ( ) ; ArrayList add = new ArrayList ( ) ; ArrayList ans = new ArrayList ( ) ; for ( int i = 0 ; i < ( n << 2 ) ; i ++ ) { sum . Add ( 0 ) ; add . Add ( 0 ) ; } build ( sum , a , 1 , n , 1 ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = 1 , r = n , pos = - 1 ; while ( l <= r ) { m = ( l + r ) >> 1 ; if ( query ( sum , add , m , m , 1 , n , 1 ) >= ( int ) b [ i ] ) { r = m - 1 ; pos = m ; } else { l = m + 1 ; } } if ( pos == - 1 ) ans . Add ( 0 ) ; else { ans . Add ( n - pos + 1 ) ; update ( sum , add , pos , n , - m , 1 , n , 1 ) ; } } for ( int i = 0 ; i < ans . Count ; i ++ ) { Console . Write ( ans [ i ] + " " ) ; } }
int MaximumPath ( int [ , ] grid ) { int N = grid . GetLength ( 0 ) ; int M = grid . GetLength ( 1 ) ; int [ , ] sum = new int [ N + 1 , M + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { sum [ i , j ] = Math . Max ( sum [ i - 1 , j ] , sum [ i , j - 1 ] ) + grid [ i - 1 , j - 1 ] ; } } return sum [ N , M ] ; }
void SubarrayHavingPerfectSquare ( int [ ] arr , int k ) { pair ans = new pair ( ) ; int sum = 0 , i ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } bool found = false ; if ( isPerfectSquare ( sum ) ) { ans . first = 0 ; ans . second = i - 1 ; } else { for ( int j = i ; j < arr . Length ; j ++ ) { sum = sum + arr [ j ] - arr [ j - k ] ; if ( isPerfectSquare ( sum ) ) { found = true ; ans . first = j - k + 1 ; ans . second = j ; } } for ( int k1 = ans . first ; k1 <= ans . second ; k1 ++ ) { Console . Write ( arr [ k1 ] + " " ) ; } } if ( found == false ) { Console . Write ( "-1" ) ; } }
int calcSubarray ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { bool flag = true ; int comm_diff = A [ i + 1 ] - A [ i ] ; for ( int k = i ; k < j ; k ++ ) { if ( A [ k + 1 ] - A [ k ] == comm_diff ) { continue ; } else { flag = false ; break ; } } if ( flag ) { count ++ ; } } } return count ; }
char findKthChar ( int n , int k ) { String prev = "A" ; String cur = "" ; if ( n == 1 ) { return 'A' ; } for ( int j = 2 ; j <= n ; j ++ ) { cur = prev + "B" ; for ( int i = 0 ; i < prev . Length ; i ++ ) { if ( prev [ i ] == 'A' ) { prev . Replace ( prev [ i ] , 'B' ) ; } else { prev . Replace ( prev [ i ] , 'A' ) ; } } prev = reverse ( prev ) ; cur += prev ; prev = cur ; } return cur [ k ] ; }
bool areAnagrams ( int a , int b ) { int [ ] freqA = new int [ TEN ] ; int [ ] freqB = new int [ TEN ] ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( int i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; }
bool isPowerOf2 ( int N ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( areAnagrams ( 1 << i , N ) ) { Console . Write ( ( 1 << i ) ) ; return true ; } } return false ; }
int right_angled ( int n ) { int count = 0 ; for ( int z = 1 ; z <= n ; z ++ ) { for ( int y = 1 ; y <= z ; y ++ ) { for ( int x = 1 ; x <= y ; x ++ ) { if ( ( x * x ) + ( y * y ) == ( z * z ) ) { count ++ ; } } } } return count ; }
void mirrorMatrix ( int [ , ] mat1 , int [ , ] mat2 , int N ) { int row = 0 ; int col = 0 ; bool isMirrorImage = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat2 [ row , col ] != mat1 [ i , j ] ) { isMirrorImage = false ; } col ++ ; } col = 0 ; row ++ ; } if ( isMirrorImage ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
void maxAbsDiffLevelSum ( int N , int M , int [ ] cost , int [ , ] Edges ) { List < int > [ ] adj = new List < int > [ N ] ; for ( int i = 0 ; i < adj . Length ; i ++ ) adj [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i , 0 ] ; int v = Edges [ i , 1 ] ; adj [ u ] . Add ( v ) ; } int maxSum = cost [ 0 ] , minSum = cost [ 0 ] ; Queue < int > q = new Queue < int > ( ) ; q . Enqueue ( 0 ) ; while ( q . Count != 0 ) { int count = q . Count ; int sum = 0 ; while ( count -- > 0 ) { int temp = q . Peek ( ) ; q . Dequeue ( ) ; sum = sum + cost [ temp ] ; for ( int i = 0 ; i < adj [ temp ] . Count ; i ++ ) { q . Enqueue ( adj [ temp ] [ i ] ) ; } } maxSum = Math . Max ( sum , maxSum ) ; minSum = Math . Min ( sum , minSum ) ; } Console . Write ( Math . Abs ( maxSum - minSum ) ) ; }
int dfs ( int src , int dest , int [ ] vis , List < int > [ ] adj ) { vis [ src ] = 1 ; if ( src == dest ) { return 1 ; } foreach ( int u in adj [ src ] ) { if ( vis [ u ] == 0 ) { int temp = dfs ( u , dest , vis , adj ) ; if ( temp != 0 ) { return temp + 1 ; } } } return 0 ; }
int countMagicNumbers ( int idx , int sum , int [ ] a , int n , int m , int l , int r ) { if ( idx == n ) { int Temp = sum % m ; if ( Temp == l || Temp == r || ( Temp > l && Temp < r ) ) return dp [ new Tuple < int , int > ( idx , sum ) ] = 1 ; else return dp [ new Tuple < int , int > ( idx , sum ) ] = 0 ; } Tuple < int , int > curr = new Tuple < int , int > ( idx , sum ) ; if ( dp . ContainsKey ( curr ) ) return dp [ curr ] ; int ls = countMagicNumbers ( idx + 1 , sum + a [ idx ] , a , n , m , l , r ) ; int rs = countMagicNumbers ( idx + 1 , sum + ( a [ idx ] - 1 ) , a , n , m , l , r ) ; int temp1 = Math . Max ( ls , rs ) ; int temp = sum % m ; if ( ( temp == l || temp == r || ( temp > l && temp < r ) ) && idx != 0 ) { temp1 += 1 ; } return dp [ new Tuple < int , int > ( idx , sum ) ] = temp1 ; }
int count_numbers ( int L , int R ) { int ans = 0 ; for ( int n = L ; n <= R ; n ++ ) { int no_of_bits = ( int ) ( Math . Log ( n ) + 1 ) ; int no_of_set_bits = bitCount ( n ) ; if ( no_of_bits - no_of_set_bits == 1 ) { ans ++ ; } } return ans ; }
bool check ( String s , int k ) { int n = s . Length ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { if ( s [ i ] != s [ j ] ) return false ; } } int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s [ i ] == '0' ) c ++ ; else c -- ; } if ( c == 0 ) return true ; else return false ; }
int findSum ( String s ) { int sum = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { for ( int j = i + 1 ; j < s . Length ; j ++ ) { if ( s [ i ] == s [ j ] ) { sum += ( j - i ) ; } } } return sum ; }
int countElements ( int [ ] a , int n ) { int [ ] cnt = new int [ n + 1 ] ; int ans = 0 ; foreach ( int k in a ) { ++ cnt [ k ] ; } for ( int l = 0 ; l < n ; ++ l ) { int sum = 0 ; for ( int r = l ; r < n ; ++ r ) { sum += a [ r ] ; if ( l == r ) continue ; if ( sum <= n ) { ans += cnt [ sum ] ; cnt [ sum ] = 0 ; } } } return ans ; }
int maxGCD ( int n ) { int maxHcf = int . MinValue ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { maxHcf = Math . Max ( maxHcf , __gcd ( i , j ) ) ; } } return maxHcf ; }
void addEdge ( int a , int b ) { tree [ a ] . Add ( b ) ; tree [ b ] . Add ( a ) ; }
void dfs ( int x ) { vis [ x ] = true ; subtreeSize [ x ] = 1 ; foreach ( int i in tree [ x ] ) { if ( ! vis [ i ] ) { dfs ( i ) ; subtreeSize [ x ] += subtreeSize [ i ] ; } } }
int [ , ] matrixMinimum ( int [ , ] nums , int K ) { int N = nums . GetLength ( 0 ) ; int M = nums . GetLength ( 1 ) ; int [ , ] res = new int [ N - K + 1 , M - K + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M - K + 1 ; j ++ ) { int min = int . MaxValue ; for ( int k = j ; k < j + K ; k ++ ) { min = Math . Min ( min , nums [ i , k ] ) ; } nums [ i , j ] = min ; } } for ( int j = 0 ; j < M ; j ++ ) { for ( int i = 0 ; i < N - K + 1 ; i ++ ) { int min = int . MaxValue ; for ( int k = i ; k < i + K ; k ++ ) { min = Math . Min ( min , nums [ k , j ] ) ; } nums [ i , j ] = min ; } } for ( int i = 0 ; i < N - K + 1 ; i ++ ) for ( int j = 0 ; j < M - K + 1 ; j ++ ) res [ i , j ] = nums [ i , j ] ; return res ; }
int uncrossedLines ( int [ ] a , int [ ] b , int n , int m ) { int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i == 0 j == 0 ) dp [ i , j ] = 0 ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i , j ] = 1 + dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] , dp [ i , j - 1 ] ) ; } } return dp [ n , m ] ; }
char find_kth_largest ( char [ ] str , int k ) { Array . Sort ( str ) ; reverse ( str ) ; return str [ k - 1 ] ; }
void updateString ( char [ ] str , int pos , char s ) { int index = pos - 1 ; char c = s ; str [ index ] = c ; }
void update_BITree ( int index , char C , int val ) { while ( index <= N ) { BITree [ C - 'a' , index ] += val ; index += ( index & - index ) ; } }
int sum_BITree ( int index , char C ) { int s = 0 ; while ( index > 0 ) { s += BITree [ C - 'a' , index ] ; index -= ( index & - index ) ; } return s ; }
int revNum ( int N ) { int x = 0 ; while ( N != 0 ) { x = x * 10 + N % 10 ; N = N / 10 ; } return x ; }
int ctNonPalin ( int [ ] arr , int N ) { int Res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int x = revNum ( arr [ i ] ) ; if ( x == arr [ i ] ) { continue ; } else { if ( arr [ i ] % 10 == x % 10 ) Res += 1 ; } } return Res ; }
int smallSumSubset ( List < int > data , int target , int maxVal ) { int sum = 0 ; foreach ( int i in data ) sum += i ; if ( target <= 0 ) return 0 ; else if ( sum < target ) return maxVal ; else if ( sum == target ) return data . Count ; else if ( data [ 0 ] >= target ) return 1 ; else if ( data [ 0 ] < target ) { List < int > temp = new List < int > ( ) ; for ( int i = 1 ; i < data . Count ; i ++ ) temp . Add ( data [ i ] ) ; return Math . Min ( smallSumSubset ( temp , target , maxVal ) , 1 + smallSumSubset ( temp , target - data [ 0 ] , maxVal ) ) ; } return 0 ; }
int minlt ( int [ ] arr , int target , int n ) { int [ , ] dp = new int [ arr . Length + 1 , target + 1 ] ; for ( int i = 0 ; i < arr . Length + 1 ; i ++ ) { for ( int j = 0 ; j < target + 1 ; j ++ ) { dp [ i , j ] = - 1 ; } } for ( int i = 0 ; i < arr . Length + 1 ; i ++ ) dp [ i , 0 ] = 0 ; for ( int j = 0 ; j < target + 1 ; j ++ ) dp [ 0 , j ] = int . MaxValue ; for ( int i = 1 ; i <= arr . Length ; i ++ ) { for ( int j = 1 ; j <= target ; j ++ ) { if ( arr [ i - 1 ] > j ) { dp [ i , j ] = dp [ i - 1 , j ] ; } else { dp [ i , j ] = Math . Min ( dp [ i - 1 , j ] , ( dp [ i , j - arr [ i - 1 ] ] ) != int . MaxValue ? ( dp [ i , j - arr [ i - 1 ] ] + 1 ) : int . MaxValue ) ; } } } if ( dp [ arr . Length , target ] == int . MaxValue ) { return - 1 ; } else { return dp [ arr . Length , target ] ; } }
long GCD ( long a , long b ) { if ( a == 0 ) return b ; return GCD ( b % a , a ) ; }
long LCM ( long a , long b ) { return ( a * b ) / GCD ( a , b ) ; }
void checkPairwiseCoPrime ( int [ ] A , int n ) { long prod = 1 ; long lcm = 1 ; for ( int i = 0 ; i < n ; i ++ ) { prod *= A [ i ] ; lcm = LCM ( A [ i ] , lcm ) ; } if ( prod == lcm ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
int minDiffSubArray ( int [ ] arr , int n ) { int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; int [ ] suffix_sum = new int [ n ] ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; int minDiff = int . MaxValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = Math . Abs ( prefix_sum [ i ] - suffix_sum [ i + 1 ] ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
int minDiffSubArray ( int [ ] arr , int n ) { int total_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) total_sum += arr [ i ] ; int prefix_sum = 0 ; int minDiff = int . MaxValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) { prefix_sum += arr [ i ] ; int diff = Math . Abs ( ( total_sum - prefix_sum ) - prefix_sum ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
int maxLenSub ( int [ ] arr , int N ) { int Pos = 0 ; int Neg = 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { Pos = Neg = 0 ; } else if ( arr [ i ] > 0 ) { Pos += 1 ; if ( Neg != 0 ) { Neg += 1 ; } res = Math . Max ( res , Pos ) ; } else { Pos = Pos + Neg ; Neg = Pos - Neg ; Neg = Pos - Neg ; Neg += 1 ; if ( Pos != 0 ) { Pos += 1 ; } res = Math . Max ( res , Pos ) ; } } return res ; }
void maxStrings ( String [ ] arr , int len ) { int N = arr . Length ; List < String > ans = new List < String > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( len == arr [ i ] . Length ) { ans . Add ( arr [ i ] ) ; } } for ( int i = 0 ; i < ans . Count ; i ++ ) { Console . Write ( ans [ i ] + " " ) ; } }
void printStrings ( String [ ] arr ) { int max = maxLength ( arr ) ; maxStrings ( arr , max ) ; }
void addEdge ( int u , int v ) { vec [ u ] . Add ( v ) ; vec [ v ] . Add ( u ) ; }
bool swapXandY ( char [ ] str , int X , int Y ) { int N = str . Length ; X = X + Y ; Y = X - Y ; X = X - Y ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == 'p' ) { str [ i ] = 'r' ; } else if ( str [ i ] == 'r' ) { str [ i ] = 'p' ; } } return true ; }
bool canTransform ( string str1 , string str2 ) { string s1 = "" ; string s2 = "" ; foreach ( char c in str1 . ToCharArray ( ) ) { if ( c != 'C' ) { s1 += c ; } } foreach ( char c in str2 . ToCharArray ( ) ) { if ( c != 'C' ) { s2 += c ; } } if ( s1 != s2 ) return false ; int i = 0 ; int j = 0 ; int n = str1 . Length ; while ( i < n && j < n ) { if ( str1 [ i ] == 'C' ) { i ++ ; } else if ( str2 [ j ] == 'C' ) { j ++ ; } else { if ( ( str1 [ i ] == 'A' && i < j ) || ( str1 [ i ] == 'B' && i > j ) ) { return false ; } i ++ ; j ++ ; } } return true ; }
void dailyTemperatures ( int [ ] T ) { int n = T . Length ; int [ ] daysOfWait = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) daysOfWait [ i ] = - 1 ; Stack < int > s = new Stack < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( s . Count != 0 && T [ s . Peek ( ) ] < T [ i ] ) { daysOfWait [ s . Peek ( ) ] = i - s . Peek ( ) ; s . Pop ( ) ; } s . Push ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( daysOfWait [ i ] + " " ) ; } }
int CtSubarr ( int [ ] arr , int N , int K ) { HashSet < int > st = new HashSet < int > ( ) ; int prefixSum = 0 ; st . Add ( prefixSum ) ; int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { prefixSum += arr [ i ] ; if ( st . Contains ( prefixSum - K ) ) { res += 1 ; prefixSum = 0 ; st . Clear ( ) ; st . Add ( 0 ) ; } st . Add ( prefixSum ) ; } return res ; }
int getMaxLength ( int [ ] arr , int N ) { int res = 2 ; int dist = 2 ; int curradj = ( arr [ 1 ] - arr [ 0 ] ) ; int prevadj = ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < N ; i ++ ) { curradj = arr [ i ] - arr [ i - 1 ] ; if ( curradj == prevadj ) { dist ++ ; } else { prevadj = curradj ; res = Math . Max ( res , dist ) ; dist = 2 ; } } res = Math . Max ( res , dist ) ; return res ; }
double func ( double a , double b , double c , double x ) { return a * x * x + b * x + c ; }
double findRoot ( double a , double b , double c , double low , double high ) { double x = - 1 ; while ( Math . Abs ( high - low ) > eps ) { x = ( low + high ) / 2 ; if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) { high = x ; } else { low = x ; } } return x ; }
int minSteps ( string str , int N ) { int smaller , cost = 0 ; int [ ] f = new int [ 26 ] ; for ( int i = 0 ; i < N ; i ++ ) { int curr_ele = str [ i ] - 'a' ; smaller = 0 ; for ( int j = 0 ; j <= curr_ele ; j ++ ) { if ( f [ j ] != 0 ) smaller += f [ j ] ; } if ( smaller == 0 ) cost += ( i + 1 ) ; else cost += ( i - smaller + 1 ) ; f [ str [ i ] - 'a' ] ++ ; } return cost ; }
void dfs ( int u , int p , int dis , int [ ] vis , int [ ] distance , int [ ] parent , int [ ] preTime , int [ ] postTime , List < List < int > > Adj ) { distance [ u ] = dis ; parent [ u ] = p ; vis [ u ] = 1 ; timeT ++ ; preTime [ u ] = timeT ; for ( int i = 0 ; i < Adj [ u ] . Count ; i ++ ) { if ( vis [ Adj [ u ] [ i ] ] == 0 ) { dfs ( Adj [ u ] [ i ] , u , dis + 1 , vis , distance , parent , preTime , postTime , Adj ) ; } } timeT ++ ; postTime [ u ] = timeT ; }
void addEdge ( List < List < int > > Adj , int u , int v ) { Adj [ u ] . Add ( v ) ; Adj [ v ] . Add ( u ) ; }
void findNodeU ( int N , int V , int [ ] Vertices , int [ , ] Edges ) { int [ ] vis = new int [ N + 1 ] ; int [ ] distance = new int [ N + 1 ] ; int [ ] parent = new int [ N + 1 ] ; int [ ] preTime = new int [ N + 1 ] ; int [ ] postTime = new int [ N + 1 ] ; List < List < int > > Adj = new List < List < int > > ( ) ; for ( int i = 0 ; i < N + 1 ; i ++ ) Adj . Add ( new List < int > ( ) ) ; int u = 0 , v ; for ( int i = 0 ; i < N - 1 ; i ++ ) { addEdge ( Adj , Edges [ i , 0 ] , Edges [ i , 1 ] ) ; } dfs ( 1 , 0 , 0 , vis , distance , parent , preTime , postTime , Adj ) ; int maximumDistance = 0 ; maximumDistance = 0 ; for ( int k = 0 ; k < V ; k ++ ) { if ( maximumDistance < distance [ Vertices [ k ] ] ) { maximumDistance = distance [ Vertices [ k ] ] ; u = Vertices [ k ] ; } if ( parent [ Vertices [ k ] ] != 0 ) { Vertices [ k ] = parent [ Vertices [ k ] ] ; } } bool ans = true ; bool flag ; for ( int k = 0 ; k < V ; k ++ ) { if ( preTime [ Vertices [ k ] ] <= preTime [ u ] && postTime [ Vertices [ k ] ] >= postTime [ u ] ) flag = true ; else flag = false ; ans = ans & flag ; } if ( ans ) Console . WriteLine ( u ) ; else Console . WriteLine ( "NO" ) ; }
void countRectangles ( int [ ] a , int [ ] b , int K ) { int n = a . Length ; int m = b . Length ; int [ ] subA = findSubarrays ( a ) ; int [ ] subB = findSubarrays ( b ) ; int total = 0 ; for ( int i = 1 ; i < subA . Length ; i ++ ) { if ( K % i == 0 && ( K / i ) <= m ) { total = total + subA [ i ] * subB [ K / i ] ; } } Console . Write ( total ) ; }
void addedge ( int a , int b ) { edges [ a ] . Add ( b ) ; edges [ b ] . Add ( a ) ; }
void findCost ( int r , int p , int [ ] arr ) { int i , cur ; for ( i = 0 ; i < edges [ r ] . Count ; i ++ ) { cur = edges [ r ] [ i ] ; if ( cur == p ) continue ; findCost ( cur , r , arr ) ; arr [ r ] += arr [ cur ] ; } int t1 = arr [ r ] ; int t2 = allsum - t1 ; if ( t1 * t2 > ans ) { ans = t1 * t2 ; } }
void maximumCost ( int r , int p , int N , int M , int [ ] arr , int [ , ] Edges ) { for ( int i = 0 ; i < N ; i ++ ) { allsum += arr [ i ] ; } for ( int i = 0 ; i < M ; i ++ ) { addedge ( Edges [ i , 0 ] , Edges [ i , 1 ] ) ; } findCost ( r , p , arr ) ; }
void printRes ( List < int > res ) { foreach ( int enu in res ) { Console . Write ( enu + " " ) ; } }
void printLBS ( int [ ] arr , int N ) { int [ ] lis = new int [ N ] ; int [ ] lds = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { lis [ i ] = lds [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { if ( lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } } for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j > i ; j -- ) { if ( arr [ j ] < arr [ i ] ) { if ( lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; } } } int MaxVal = arr [ 0 ] , inx = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( MaxVal < lis [ i ] + lds [ i ] - 1 ) { MaxVal = lis [ i ] + lds [ i ] - 1 ; inx = i ; } } int ct1 = lis [ inx ] ; List < int > res = new List < int > ( ) ; for ( int i = inx ; i >= 0 && ct1 > 0 ; i -- ) { if ( lis [ i ] == ct1 ) { res . Add ( arr [ i ] ) ; ct1 -- ; } } res . Reverse ( ) ; int ct2 = lds [ inx ] - 1 ; for ( int i = inx ; i < N && ct2 > 0 ; i ++ ) { if ( lds [ i ] == ct2 ) { res . Add ( arr [ i ] ) ; ct2 -- ; } } printRes ( res ) ; }
void dfs ( int current_node , int prev_node , int len , bool add_to_map , List < int > [ ] adj ) { if ( len > diameter ) { diameter = len ; X = current_node ; } if ( add_to_map && len == diameter ) { mp . Add ( current_node , true ) ; } foreach ( int it in adj [ current_node ] ) { if ( it != prev_node ) dfs ( it , current_node , len + 1 , add_to_map , adj ) ; } }
void dfsUtility ( List < int > [ ] adj ) { dfs ( 1 , - 1 , 0 , false , adj ) ; int farthest_node = X ; dfs ( farthest_node , - 1 , 0 , false , adj ) ; dfs ( farthest_node , - 1 , 0 , true , adj ) ; dfs ( X , - 1 , 0 , true , adj ) ; }
void printDiameters ( List < int > [ ] adj ) { dfsUtility ( adj ) ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( mp . ContainsKey ( i ) && mp [ i ] == true ) Console . Write ( diameter + 1 + ", " ) ; else Console . Write ( diameter + ", " ) ; } }
bool is_prime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
int count_prime_subarrays ( int [ ] ar , int n ) { int ans = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( is_prime ( ar [ i ] ) ) count ++ ; else { if ( count != 0 ) { ans += count * ( count + 1 ) / 2 ; count = 0 ; } } } if ( count != 0 ) ans += count * ( count + 1 ) / 2 ; return ans ; }
bool hasCoprimePair ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( __gcd ( arr [ i ] , arr [ j ] ) ) == 1 ) { return true ; } } } return false ; }
bool check ( String ans , String [ ] s , int n , int m ) { for ( int i = 1 ; i < n ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < m ; ++ j ) { if ( ans [ j ] != s [ i ] [ j ] ) count ++ ; } if ( count > 1 ) return false ; } return true ; }
bool possible ( int T , int [ ] arr , int n , int d ) { int partition = 1 ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total = total + arr [ i ] ; if ( total > T ) { partition = partition + 1 ; total = arr [ i ] ; if ( partition > d ) { return false ; } } } return true ; }
void calcT ( int n , int d , int [ ] arr ) { int mx = - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mx = Math . Max ( mx , arr [ i ] ) ; sum = sum + arr [ i ] ; } int lb = mx ; int ub = sum ; while ( lb < ub ) { int T_mid = lb + ( ub - lb ) / 2 ; if ( possible ( T_mid , arr , n , d ) == true ) { ub = T_mid ; } else { lb = T_mid + 1 ; } } Console . WriteLine ( lb ) ; }
int minReqSubstring ( String s , int n ) { char ongoing = 'N' ; int count = 0 , l = s . Length ; for ( int i = 1 ; i < l ; i ++ ) { if ( ongoing == 'N' ) { if ( s [ i ] < s [ i - 1 ] ) { ongoing = 'D' ; } else if ( s [ i ] == s [ i - 1 ] ) { ongoing = 'N' ; } else { ongoing = 'I' ; } } else if ( ongoing == 'I' ) { if ( s [ i ] > s [ i - 1 ] ) { ongoing = 'I' ; } else if ( s [ i ] == s [ i - 1 ] ) { ongoing = 'I' ; } else { ongoing = 'N' ; count += 1 ; } } else { if ( s [ i ] < s [ i - 1 ] ) { ongoing = 'D' ; } else if ( s [ i ] == s [ i - 1 ] ) { ongoing = 'D' ; } else { ongoing = 'N' ; count += 1 ; } } } return count + 1 ; }
int findPermutation ( HashSet < int > arr , int N ) { int pos = arr . Count + 1 ; if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ! arr . Contains ( i ) ) { if ( i % pos == 0 pos % i == 0 ) { arr . Add ( i ) ; res += findPermutation ( arr , N ) ; arr . Remove ( i ) ; } } } return res ; }
int minimum_required_operations ( int [ ] arr , int n , int k ) { int answer = 0 ; long mod = 1000000007 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer = ( int ) ( answer % mod ) ; } } return answer ; }
int minSteps ( int [ ] arr , int n , int k ) { int i , cnt = 0 ; int flag ; if ( k == 1 ) flag = 0 ; else flag = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == flag ) { cnt ++ ; flag = ( flag + 1 ) % 2 ; } } return cnt ; }
void solve ( int [ ] arr , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
int minSum ( int [ ] a , int n , int k ) { List < int > q = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { q . Add ( a [ i ] ) ; } q . Sort ( ) ; while ( q . Count != 0 && k > 0 ) { int top = q [ q . Count - 1 ] / 2 ; q [ q . Count - 1 ] = top ; k -- ; q . Sort ( ) ; } int sum = 0 ; while ( q . Count != 0 ) { sum += q [ 0 ] ; q . RemoveAt ( 0 ) ; } return sum ; }
void determineWinner ( String str ) { int [ ] A = new int [ 10 ] ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { A [ ( int ) str [ i ] - 48 ] ++ ; } for ( int i = 0 ; i <= 9 ; i ++ ) { if ( i % 2 != 0 ) { sum1 = sum1 + A [ i ] ; } else { sum2 = sum2 + A [ i ] ; } } if ( sum1 == sum2 ) { Console . Write ( "-1" ) ; } else if ( sum1 > sum2 ) { Console . Write ( "Player 1" ) ; } else { Console . Write ( "Player 2" ) ; } }
void manipulateStrings ( String P , String Q ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < P . Length ; i ++ ) { freq [ P [ i ] - 'a' ] ++ ; } for ( int i = 0 ; i < Q . Length ; i ++ ) { freq [ Q [ i ] - 'a' ] -- ; } String sb = "" ; int pos = Q [ 0 ] - 'a' ; for ( int i = 0 ; i <= pos ; i ++ ) { while ( freq [ i ] > 0 ) { char c = ( char ) ( 'a' + i ) ; sb += c ; freq [ i ] -- ; } } sb += Q ; for ( int i = pos + 1 ; i < 26 ; i ++ ) { while ( freq [ i ] > 0 ) { char c = ( char ) ( 'a' + i ) ; sb += c ; freq [ i ] -- ; } } Console . WriteLine ( sb ) ; }
int deleted ( int [ ] seg , int l , int r , int start , int end , int current ) { if ( end < l start > r ) return 0 ; if ( start >= l && end <= r ) return seg [ current ] ; int mid = ( start + end ) / 2 ; return deleted ( seg , l , r , start , mid , 2 * current + 1 ) + deleted ( seg , l , r , mid + 1 , end , 2 * current + 2 ) ; }
bool deleteNode ( int nodeVal ) { return mp . ContainsKey ( nodeVal ) ; }
void printInorderTree ( Node root ) { if ( root == null ) return ; printInorderTree ( root . left ) ; Console . Write ( root . key + " " ) ; printInorderTree ( root . right ) ; }
void sieve ( ) { prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i < 100005 ; i ++ ) prime [ i ] = true ; for ( int i = 2 ; i * i < 100005 ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * i ; j < 100005 ; j += i ) { prime [ j ] = false ; } } } }
void smallestPrimeFactors ( ) { for ( int i = 0 ; i < 100005 ; i ++ ) spf [ i ] = - 1 ; for ( int i = 2 ; i * i < 100005 ; i ++ ) { for ( int j = i ; j < 100005 ; j += i ) { if ( spf [ j ] == - 1 ) { spf [ j ] = i ; } } } }
int sumOfPrimeFactors ( int n ) { int ans = 0 ; while ( n > 1 ) { ans += spf [ n ] ; n /= spf [ n ] ; } return ans ; }
int findLength ( int n ) { if ( prime [ n ] ) { return 1 ; } if ( dp [ n ] != 0 ) { return dp [ n ] ; } int sum = sumOfPrimeFactors ( n ) ; return dp [ n ] = 1 + findLength ( sum ) ; }
void solve ( int n , int [ ] arr ) { int i , ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { int left = Math . Max ( i - 1 , 0 ) ; int right = Math . Min ( n - 1 , i + 1 ) ; while ( left >= 0 ) { if ( arr [ left ] > arr [ i ] ) { left ++ ; break ; } left -- ; } if ( left < 0 ) left ++ ; while ( right < n ) { if ( arr [ right ] > arr [ i ] ) { right -- ; break ; } right ++ ; } if ( right >= n ) right -- ; ans = 1 + right - left ; Console . Write ( ans + " " ) ; } }
int countofPairs ( int [ ] a ) { int n = a . Length ; int [ ] freq = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) freq [ a [ i ] ] ++ ; return maxCount ( freq ) ; }
int largest_subarray ( int [ ] a , int n ) { Dictionary < int , int > index = new Dictionary < int , int > ( ) ; int ans = 0 ; for ( int i = 0 , j = 0 ; i < n ; i ++ ) { j = Math . Max ( index . ContainsKey ( a [ i ] ) ? index [ a [ i ] ] : 0 , j ) ; ans = Math . Max ( ans , i - j + 1 ) ; if ( index . ContainsKey ( a [ i ] ) ) index [ a [ i ] ] = i + 1 ; else index . Add ( a [ i ] , i + 1 ) ; } return ans ; }
int getMaxSum ( int [ ] a , int n ) { int [ , ] dp = new int [ n , 2 ] ; dp [ 0 , 0 ] = a [ 0 ] ; dp [ 0 , 1 ] = a [ 0 ] * a [ 0 ] ; int max_sum = Math . Max ( dp [ 0 , 0 ] , dp [ 0 , 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i , 0 ] = Math . Max ( a [ i ] , dp [ i - 1 , 0 ] + a [ i ] ) ; dp [ i , 1 ] = Math . Max ( dp [ i - 1 , 1 ] + a [ i ] , a [ i ] * a [ i ] ) ; dp [ i , 1 ] = Math . Max ( dp [ i , 1 ] , dp [ i - 1 , 0 ] + a [ i ] * a [ i ] ) ; max_sum = Math . Max ( max_sum , dp [ i , 1 ] ) ; max_sum = Math . Max ( max_sum , dp [ i , 0 ] ) ; } return max_sum ; }
int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; }
int MaxUtil ( int [ ] st , int ss , int se , int l , int r , int node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return - 1 ; int mid = getMid ( ss , se ) ; return Math . Max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; }
int constructSTUtil ( int [ ] arr , int ss , int se , int [ ] st , int si ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return arr [ ss ] ; } int mid = getMid ( ss , se ) ; st [ si ] = Math . Max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) ; return st [ si ] ; }
int [ ] findPrevious ( int [ ] a , int n ) { int [ ] ps = new int [ n ] ; ps [ 0 ] = - 1 ; Stack < int > stack = new Stack < int > ( ) ; stack . Push ( 0 ) ; for ( int i = 1 ; i < a . Length ; i ++ ) { while ( stack . Count > 0 && a [ stack . Peek ( ) ] >= a [ i ] ) stack . Pop ( ) ; ps [ i ] = stack . Count > 0 ? stack . Peek ( ) : - 1 ; stack . Push ( i ) ; } return ps ; }
int [ ] findNext ( int [ ] a , int n ) { int [ ] ns = new int [ n ] ; ns [ n - 1 ] = n ; Stack < int > stack = new Stack < int > ( ) ; stack . Push ( n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { while ( stack . Count > 0 && a [ stack . Peek ( ) ] >= a [ i ] ) stack . Pop ( ) ; ns [ i ] = stack . Count > 0 ? stack . Peek ( ) : a . Length ; stack . Push ( i ) ; } return ns ; }
int findMaximumSum ( int [ ] a , int n ) { int [ ] prev_smaller = findPrevious ( a , n ) ; int [ ] next_smaller = findNext ( a , n ) ; int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_value = Math . Max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) ; } return max_value ; }
int findCount ( int [ ] arr , int n ) { int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; int [ ] suffix_sum = new int [ n ] ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; int s = 1 , e = 1 ; int curr_subarray_sum = 0 , count = 0 ; while ( s < n - 1 && e < n - 1 ) { while ( e < n - 1 && curr_subarray_sum < prefix_sum [ s - 1 ] ) { curr_subarray_sum += arr [ e ++ ] ; } if ( curr_subarray_sum <= suffix_sum [ e ] ) { count ++ ; } curr_subarray_sum -= arr [ s ++ ] ; } return count ; }
int minOperation ( String s , int n ) { int ans = 0 ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( s [ i ] == '0' && s [ j ] == '1' ) { ans ++ ; i ++ ; j -- ; continue ; } if ( s [ i ] == '1' ) { i ++ ; } if ( s [ j ] == '0' ) { j -- ; } } return ans ; }
void solve ( int n ) { int ans = 0 ; for ( int y = n + 1 ; y <= n * n + n ; y ++ ) { if ( ( n * n ) % ( y - n ) == 0 ) { ans += 1 ; } } Console . Write ( ans ) ; }
int power ( int x , int y , int mod ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
void count ( int N ) { if ( N == 1 ) { Console . WriteLine ( 10 ) ; return ; } Console . WriteLine ( power ( 9 , N , 1000000007 ) ) ; }
bool possible ( long mid , int [ ] a ) { long n = a . Length ; long total = ( n * ( n - 1 ) ) / 2 ; long need = ( total + 1 ) / 2 ; long count = 0 ; long start = 0 , end = 1 ; while ( end < n ) { if ( a [ ( int ) end ] - a [ ( int ) start ] <= mid ) { end ++ ; } else { count += ( end - start - 1 ) ; start ++ ; } } if ( end == n && start < end && a [ ( int ) end - 1 ] - a [ ( int ) start ] <= mid ) { long t = end - start - 1 ; count += ( t * ( t + 1 ) / 2 ) ; } if ( count >= need ) return true ; else return false ; }
long findMedian ( int [ ] a ) { long n = a . Length ; long low = 0 , high = a [ ( int ) n - 1 ] - a [ 0 ] ; while ( low <= high ) { long mid = ( low + high ) / 2 ; if ( possible ( mid , a ) ) high = mid - 1 ; else low = mid + 1 ; } return high + 1 ; }
int computeDistance ( Node root , int value ) { if ( root == null ) { return - 1 ; } int left = computeDistance ( root . left , value ) ; int right = computeDistance ( root . right , value ) ; if ( left == - 1 && right == - 1 ) { if ( root . key == value ) { return 1 ; } else return - 1 ; } if ( left == - 1 ) { return right + 1 ; } if ( right == - 1 ) { return left + 1 ; } else { return 1 + Math . Max ( left , right ) ; } }
void dfs ( int node , int count , int m , int [ ] arr , int k ) { visited [ node ] = 1 ; if ( arr [ node - 1 ] == k ) { count ++ ; } else { count = 0 ; } if ( count > m ) { return ; } if ( adj [ node ] . Count == 1 && node != 1 ) { ans ++ ; } foreach ( int x in adj [ node ] ) { if ( visited [ x ] == 0 ) { dfs ( x , count , m , arr , k ) ; } } }
int find ( int [ ] parent , int x ) { if ( parent [ x ] == x ) return x ; parent [ x ] = find ( parent , parent [ x ] ) ; return parent [ x ] ; }
void setUnion ( int [ ] parent , int [ ] rank , int x , int y ) { int parentx = find ( parent , x ) ; int parenty = find ( parent , y ) ; if ( parenty == parentx ) return ; ctr -- ; if ( rank [ parentx ] < rank [ parenty ] ) { parent [ parentx ] = parenty ; } else if ( rank [ parentx ] > rank [ parenty ] ) { parent [ parenty ] = parentx ; } else { parent [ parentx ] = parenty ; rank [ parenty ] ++ ; } }
int [ ] solve ( int n , int m , int [ , ] query ) { int [ ] result = new int [ query . Length ] ; int [ ] parent = new int [ n * m ] ; for ( int i = 0 ; i < n * m ; i ++ ) parent [ i ] = i ; int [ ] rank = new int [ n * m ] ; for ( int i = 0 ; i < rank . Length ; i ++ ) rank [ i ] = 1 ; bool [ ] grid = new bool [ n * m ] ; for ( int i = 0 ; i < query . GetLength ( 0 ) ; i ++ ) { int x = query [ i , 0 ] ; int y = query [ i , 1 ] ; if ( grid [ m * x + y ] == true ) { result [ i ] = ctr ; continue ; } grid [ m * x + y ] = true ; ctr ++ ; if ( x > 0 && grid [ m * ( x - 1 ) + y ] == true ) setUnion ( parent , rank , m * x + y , m * ( x - 1 ) + y ) ; if ( y > 0 && grid [ m * ( x ) + y - 1 ] == true ) setUnion ( parent , rank , m * x + y , m * ( x ) + y - 1 ) ; if ( x < n - 1 && grid [ m * ( x + 1 ) + y ] == true ) setUnion ( parent , rank , m * x + y , m * ( x + 1 ) + y ) ; if ( y < m - 1 && grid [ m * ( x ) + y + 1 ] == true ) setUnion ( parent , rank , m * x + y , m * ( x ) + y + 1 ) ; result [ i ] = ctr ; } return result ; }
void FindMinimumDistance ( ) { Queue < pair > q = new Queue < pair > ( ) ; q . Enqueue ( new pair ( x , y ) ) ; mat [ x , y ] = 0 ; while ( q . Count != 0 ) { x = q . Peek ( ) . first ; y = q . Peek ( ) . second ; q . Dequeue ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { int a = x + dx [ i ] ; int b = y + dy [ i ] ; if ( a < 0 >= r b >= c b < 0 ) continue ; if ( mat [ a , b ] == 0 ) { mat [ a , b ] = mat [ x , y ] + 1 ; q . Enqueue ( new pair ( a , b ) ) ; } } } }
void make_set ( int v ) { parent [ v ] = v ; size_set [ v ] = 1 ; }
int find_set ( int v ) { if ( v == parent [ v ] ) return v ; return parent [ v ] = find_set ( parent [ v ] ) ; }
void union_set ( int a , int b ) { a = find_set ( a ) ; b = find_set ( b ) ; if ( a != b ) { if ( size_set [ a ] < size_set [ b ] ) { a = a + b ; b = a - b ; a = a - b ; } parent [ b ] = a ; size_set [ a ] += size_set [ b ] ; } }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < 100001 ; i ++ ) prime [ i ] = 1 ; int p = 2 ; while ( p * p <= 100000 ) { if ( prime [ p ] == 1 ) { for ( int i = p * p ; i < 100001 ; i += p ) prime [ i ] = 0 ; } p += 1 ; } }
void fibonacciOfPrime ( int n1 , int n2 ) { SieveOfEratosthenes ( ) ; List < int > initial = new List < int > ( ) ; for ( int i = n1 ; i <= n2 ; i ++ ) if ( prime [ i ] == 1 ) initial . Add ( i ) ; List < int > now = new List < int > ( ) ; for ( int i = 0 ; i < initial . Count ; i ++ ) { for ( int j = 0 ; j < initial . Count ; j ++ ) { int a = initial [ i ] ; int b = initial [ j ] ; if ( a != b ) { int C = join ( a , b ) ; now . Add ( C ) ; } } } List < int > current = new List < int > ( ) ; for ( int i = 0 ; i < now . Count ; i ++ ) if ( prime [ now [ i ] ] == 1 ) current . Add ( now [ i ] ) ; int [ ] cnt = new int [ 1000009 ] ; for ( int i = 0 ; i < 1000001 ; i ++ ) cnt [ i ] = 0 ; List < int > current_set = new List < int > ( ) ; for ( int i = 0 ; i < current . Count ; i ++ ) { cnt [ current [ i ] ] ++ ; if ( cnt [ current [ i ] ] == 1 ) current_set . Add ( current [ i ] ) ; } long first = 1000000000 ; for ( int i = 0 ; i < current_set . Count ; i ++ ) first = Math . Min ( first , current_set [ i ] ) ; long second = 0 ; for ( int i = 0 ; i < current_set . Count ; i ++ ) second = Math . Max ( second , current_set [ i ] ) ; int count = current_set . Count - 1 ; long curr = 1 ; long c = 0 ; while ( curr < count ) { c = first + second ; first = second ; second = c ; curr += 1 ; } Console . WriteLine ( c ) ; }
long reverse ( long num ) { long rev = 0 ; while ( num > 0 ) { int r = ( int ) ( num % 10 ) ; rev = rev * 10 + r ; num /= 10 ; } return rev ; }
long count ( int N , int A , int B ) { long l = ( long ) Math . Pow ( 10 , N - 1 ) , r = ( long ) Math . Pow ( 10 , N ) - 1 ; if ( l == 1 ) l = 0 ; long ans = 0 ; for ( long i = l ; i <= r ; i ++ ) { int even_sum = 0 , odd_sum = 0 ; long itr = 0 , num = reverse ( i ) ; while ( num > 0 ) { if ( itr % 2 == 0 ) odd_sum += ( int ) num % 10 ; else even_sum += ( int ) num % 10 ; num /= 10 ; itr ++ ; } if ( even_sum % A == 0 && odd_sum % B == 0 ) ans ++ ; } return ans ; }
long count ( int N , int A , int B ) { if ( N == 1 ) { return 9 / B + 1 ; } int max_sum = 9 * N ; int odd_count = N / 2 + N % 2 ; int even_count = N - odd_count ; long [ , ] dp = new long [ even_count , max_sum + 1 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) dp [ 0 , i % A ] ++ ; for ( int i = 1 ; i < even_count ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { for ( int k = 0 ; k <= max_sum ; k ++ ) { if ( dp [ i - 1 , k ] > 0 ) dp [ i , ( j + k ) % A ] += dp [ i - 1 , k ] ; } } } long [ , ] dp1 = new long [ odd_count , max_sum + 1 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) dp1 [ 0 , i % B ] ++ ; for ( int i = 1 ; i < odd_count ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { for ( int k = 0 ; k <= max_sum ; k ++ ) { if ( dp1 [ i - 1 , k ] > 0 ) dp1 [ i , ( j + k ) % B ] += dp1 [ i - 1 , k ] ; } } } return dp [ even_count - 1 , 0 ] * dp1 [ odd_count - 1 , 0 ] ; }
int calc_distance ( int [ ] A , int [ ] B , int n ) { int distance_traveled_A = 0 ; int distance_traveled_B = 0 ; int answer = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { distance_traveled_A += A [ i ] ; distance_traveled_B += B [ i ] ; if ( ( distance_traveled_A == distance_traveled_B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; }
int dfs ( int node , int A , int [ ] subtree_size , int [ ] visited , int [ ] check_subtree ) { visited [ node ] = 1 ; subtree_size [ node ] = 1 ; if ( node == A ) { check_subtree [ node ] = 1 ; } else check_subtree [ node ] = 0 ; foreach ( int v in G [ node ] ) { if ( visited [ v ] == 0 ) { subtree_size [ node ] += dfs ( v , A , subtree_size , visited , check_subtree ) ; check_subtree [ node ] = check_subtree [ node ] | check_subtree [ v ] ; } } return subtree_size [ node ] ; }
int numberOfPairs ( int N , int B , int A ) { int [ ] subtree_size = new int [ N + 1 ] ; int [ ] visited = new int [ N + 1 ] ; int [ ] check_subtree = new int [ N + 1 ] ; dfs ( B , A , subtree_size , visited , check_subtree ) ; int difference = 0 ; foreach ( int v in G [ B ] ) { if ( check_subtree [ v ] > 0 ) { difference = N - subtree_size [ v ] ; break ; } } return ( N * ( N - 1 ) ) - difference * ( subtree_size [ A ] ) ; }
int equalXORandOR ( int n ) { int m = 0 ; int MSB = ( int ) Math . Log ( n ) ; for ( int i = 0 ; i <= MSB ; i ++ ) { if ( ( n & ( 1 << i ) ) <= 0 ) { m += ( 1 << i ) ; } } return m ; }
int findMinSoln ( int n , int k ) { int minSoln = int . MaxValue ; for ( int i = 1 ; i < k ; i ++ ) { if ( n % i == 0 ) minSoln = Math . Min ( minSoln , ( n / i ) * k + i ) ; } return minSoln ; }
int getSum ( int [ ] BITree , int index ) { int ans = 0 ; index += 1 ; while ( index > 0 ) { ans += BITree [ index ] ; index -= index & ( - index ) ; } return ans ; }
void updateBIT ( int [ ] BITree , int n , int index , int val ) { index = index + 1 ; while ( index <= n ) { BITree [ index ] += val ; index += index & ( - index ) ; } }
int getLowerBound ( int [ ] BITree , int [ ] arr , int n , int k ) { int lb = - 1 ; int l = 0 , r = n - 1 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( getSum ( BITree , mid ) >= k ) { r = mid - 1 ; lb = mid ; } else l = mid + 1 ; } return lb ; }
void dfs ( int [ ] val , int [ ] cost , List < int > [ ] tr , int u , int s ) { s = s + cost [ u ] ; if ( s < 0 ) s = 0 ; if ( s > val [ u ] ) return ; cnt ++ ; for ( int i = 0 ; i < tr [ u ] . Count ; i ++ ) { dfs ( val , cost , tr , tr [ u ] [ i ] , s ) ; } }
void dfs1 ( int cur , int par ) { foreach ( int u in adj [ cur ] ) { if ( u != par ) { dfs1 ( u , cur ) ; height [ cur ] = Math . Max ( height [ cur ] , height [ u ] ) ; } } height [ cur ] += 1 ; }
void dfs2 ( int cur , int par ) { int max1 = 0 ; int max2 = 0 ; foreach ( int u in adj [ cur ] ) { if ( u != par ) { if ( height [ u ] >= max1 ) { max2 = max1 ; max1 = height [ u ] ; } else if ( height [ u ] > max2 ) { max2 = height [ u ] ; } } } int sum = 0 ; foreach ( int u in adj [ cur ] ) { if ( u != par ) { sum = ( ( max1 == height [ u ] ) ? max2 : max1 ) ; if ( max1 == height [ u ] ) dist [ u ] = 1 + Math . Max ( 1 + max2 , dist [ cur ] ) ; else dist [ u ] = 1 + Math . Max ( 1 + max1 , dist [ cur ] ) ; dfs2 ( u , cur ) ; } } }
void displaySteppingNumbers ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) if ( isStepNum ( i ) ) Console . Write ( i + " " ) ; }
int BFS ( int [ , ] mat , int row , int col ) { int area = 0 ; Queue < pair > Q = new Queue < pair > ( ) ; Q . Enqueue ( new pair ( row , col ) ) ; while ( Q . Count != 0 ) { pair it = Q . Peek ( ) ; Q . Dequeue ( ) ; int r = it . first , c = it . second ; if ( r < 0 c < 0 r > 4 c > 4 ) continue ; if ( mat [ r , c ] == 0 ) continue ; if ( mat [ r , c ] == 1 ) { mat [ r , c ] = 0 ; area ++ ; } Q . Enqueue ( new pair ( r + 1 , c ) ) ; Q . Enqueue ( new pair ( r - 1 , c ) ) ; Q . Enqueue ( new pair ( r , c + 1 ) ) ; Q . Enqueue ( new pair ( r , c - 1 ) ) ; } return area ; }
void sizeOfConnections ( int [ , ] mat ) { ArrayList result = new ArrayList ( ) ; for ( int row = 0 ; row < 5 ; ++ row ) { for ( int col = 0 ; col < 5 ; ++ col ) { if ( mat [ row , col ] == 1 ) { int area = BFS ( mat , row , col ) ; result . Add ( area ) ; } } } foreach ( int val in result ) Console . Write ( val + " " ) ; }
void DFS ( List < List < int > > adjl , int [ ] parent , int u , int p ) { parent [ u ] = p ; foreach ( int v in adjl [ u ] ) { if ( v != p ) { DFS ( adjl , parent , v , u ) ; } } }
int [ ] valuesFromChildren ( int [ ] parent , int [ ] values ) { int [ ] valuesChildren = new int [ parent . Length ] ; for ( int i = 0 ; i < parent . Length ; i ++ ) { if ( parent [ i ] == - 1 ) continue ; else { int p = parent [ i ] ; valuesChildren [ p ] += values [ i ] ; } } return valuesChildren ; }
void maxProduct ( int [ ] arr , int N ) { if ( N < 3 ) { return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; int c = 0 , d = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N - 1 ; j ++ ) { if ( arr [ i ] * arr [ j ] > a * b ) { c = a ; d = b ; a = arr [ i ] ; b = arr [ j ] ; } if ( arr [ i ] * arr [ j ] < a * b && arr [ i ] * arr [ j ] > c * d ) c = arr [ i ] ; d = arr [ j ] ; } Console . WriteLine ( c + " " + d ) ; }
void maxProduct ( int [ ] arr , int N ) { if ( N < 3 ) { return ; } Array . Sort ( arr ) ; int smallest1 = arr [ 0 ] ; int smallest3 = arr [ 2 ] ; int largest1 = arr [ N - 1 ] ; int largest3 = arr [ N - 3 ] ; if ( smallest1 * smallest3 >= largest1 * largest3 ) { Console . Write ( smallest1 + " " + smallest3 ) ; } else { Console . Write ( largest1 + " " + largest3 ) ; } }
int maxLen ( int [ ] A , int N ) { List < List < int > > v = new List < List < int > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 1 ) { int s = i , len ; while ( i < N && A [ i ] == 1 ) { i ++ ; } len = i - s ; List < int > l = new List < int > { len , s , i - 1 } ; v . Add ( l ) ; } } if ( v . Count == 0 ) { return - 1 ; } int ans = 0 ; for ( int i = 0 ; i < v . Count - 1 ; i ++ ) { ans = Math . Max ( ans , v [ i ] [ 0 ] ) ; if ( v [ i + 1 ] [ 1 ] - v [ i ] [ 2 ] - 1 == 2 ) { ans = Math . Max ( ans , v [ i ] [ 0 ] + v [ i + 1 ] [ 0 ] ) ; } if ( v [ i + 1 ] [ 1 ] - v [ i ] [ 2 ] - 1 == 1 ) { ans = Math . Max ( ans , v [ i ] [ 0 ] + v [ i + 1 ] [ 0 ] - 1 ) ; } } ans = Math . Max ( v [ v . Count - 1 ] [ 0 ] , ans ) ; return ans ; }
void maxLengthOf1s ( int [ ] arr , int n ) { int [ ] prefix = new int [ n ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i - 2 ] == 1 ) prefix [ i ] = prefix [ i - 1 ] + 1 ; else prefix [ i ] = 0 ; } int [ ] suffix = new int [ n ] ; for ( int i = n - 3 ; i >= 0 ; i -- ) { if ( arr [ i + 2 ] == 1 ) suffix [ i ] = suffix [ i + 1 ] + 1 ; else suffix [ i ] = 0 ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = Math . Max ( ans , prefix [ i + 1 ] + suffix [ i ] ) ; } Console . WriteLine ( ans ) ; }
void dfs ( int u ) { visited [ u ] = 1 ; foreach ( int it in ( ArrayList ) adj [ u ] ) { if ( visited [ it ] == 0 ) dfs ( it ) ; } s . Push ( u ) ; }
bool check_cycle ( ) { Dictionary < int , int > pos = new Dictionary < int , int > ( ) ; int ind = 0 ; while ( s . Count != 0 ) { pos . Add ( s . Peek ( ) , ind ) ; tsort . Add ( s . Peek ( ) ) ; ind += 1 ; s . Pop ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { foreach ( int it in ( ArrayList ) adj [ i ] ) { if ( pos [ i ] > pos [ it ] ) { return true ; } } } return false ; }
void addEdge ( int u , int v ) { ( ( ArrayList ) adj [ u ] ) . Add ( v ) ; }
void printNewArray ( List < int > a , int n ) { List < Tuple < int , int > > v = new List < Tuple < int , int > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { v . Add ( new Tuple < int , int > ( a [ i ] , i ) ) ; } v . Sort ( ) ; int [ ] ans = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ans [ v [ ( i + 1 ) % n ] . Item2 ] = v [ i ] . Item1 ; } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( ans [ i ] + " " ) ; } }
void bfs ( int n , int m , int num ) { Queue < int > q = new Queue < int > ( ) ; q . Enqueue ( num ) ; while ( q . Count != 0 ) { int stepNum = q . Dequeue ( ) ; if ( stepNum <= m && stepNum >= n ) { Console . Write ( stepNum + " " ) ; } if ( stepNum == 0 stepNum > m ) continue ; int lastDigit = stepNum % 10 ; int stepNumA = stepNum * 10 + ( lastDigit - 1 ) ; int stepNumB = stepNum * 10 + ( lastDigit + 1 ) ; if ( lastDigit == 0 ) q . Enqueue ( stepNumB ) ; else if ( lastDigit == 9 ) q . Enqueue ( stepNumA ) ; else { q . Enqueue ( stepNumA ) ; q . Enqueue ( stepNumB ) ; } } }
void displaySteppingNumbers ( int n , int m ) { for ( int i = 0 ; i <= 9 ; i ++ ) bfs ( n , m , i ) ; }
void solve ( int [ ] arr , int n ) { int countzeroes = 0 ; int countones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countzeroes ++ ; else countones ++ ; } if ( Math . Abs ( countzeroes - countones ) == 1 ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
char bs ( char [ ] ar , int n , int ele ) { int start = 0 ; int end = n - 1 ; char ch = '@' ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( ar [ mid ] == ele ) end = mid - 1 ; else if ( ar [ mid ] < ele ) { ch = ar [ mid ] ; start = mid + 1 ; } else end = mid - 1 ; } return ch ; }
void countPairs ( int N , int [ ] arr ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } Console . Write ( count / 2 ) ; }
int findMaxLen ( int [ ] a , int k ) { int n = a . Length ; Array . Sort ( a ) ; bool [ ] vis = new bool [ n ] ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . Add ( a [ i ] , i ) ; } int c = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( vis [ i ] == false ) { int check = a [ i ] * k ; if ( mp . ContainsKey ( check ) ) { c ++ ; vis [ mp [ check ] ] = true ; } } } return n - c ; }
bool isVowel ( char c ) { if ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) return true ; return false ; }
void countSubstrings ( String s , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( isVowel ( s [ j ] ) ) { count ++ ; } if ( count % 2 == 0 ) result ++ ; } } Console . WriteLine ( result ) ; }
void addEdge ( int u , int v ) { adj [ u ] . Add ( v ) ; adj [ v ] . Add ( u ) ; }
int minimumCost ( int V , int [ ] cost ) { bool [ ] vis = new bool [ V + 1 ] ; int min_cost = 0 ; for ( int i = 1 ; i <= V ; i ++ ) { if ( ! vis [ i ] ) { min_cost_node = int . MaxValue ; dfs ( i , cost , vis ) ; min_cost += min_cost_node ; } } return min_cost ; }
bool check ( char [ ] str , int mid , char a ) { int n = str . Length ; int previous = - 1 , i ; for ( i = 0 ; i < n ; ++ i ) { if ( str [ i ] == a ) { if ( i - previous > mid ) { return false ; } previous = i ; } } if ( i - previous > mid ) return false ; else return true ; }
bool possible ( char [ ] str , int mid ) { for ( int i = 0 ; i < 26 ; ++ i ) { if ( check ( str , mid , ( char ) ( i + 'a' ) ) ) return true ; } return false ; }
int findMinLength ( char [ ] str ) { int low = 1 , high = str . Length ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( possible ( str , mid ) ) high = mid - 1 ; else low = mid + 1 ; } return high + 1 ; }
int solve ( int [ ] A , int N ) { int i = 0 ; int k = 0 ; for ( int j = 1 ; j < N ; j ++ ) { int tempK = Math . Min ( A [ i ] , A [ j ] ) / ( j - i ) ; if ( tempK > k ) { k = tempK ; } if ( A [ j ] >= A [ i ] / ( j - i ) ) i = j ; } return k ; }
bool possible ( int [ ] arr , int N , int mid , int K ) { int add = 0 ; for ( int i = N / 2 - ( N + 1 ) % 2 ; i < N ; ++ i ) { if ( mid - arr [ i ] > 0 ) { add += ( mid - arr [ i ] ) ; if ( add > K ) return false ; } } if ( add <= K ) return true ; else return false ; }
int findMaxMedian ( int [ ] arr , int N , int K ) { int low = 1 ; int mx = 0 ; for ( int i = 0 ; i < N ; ++ i ) { mx = Math . Max ( mx , arr [ i ] ) ; } int high = K + mx ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( possible ( arr , N , mid , K ) ) { low = mid + 1 ; } else { high = mid - 1 ; } } if ( N % 2 == 0 ) { if ( low - 1 < arr [ N / 2 ] ) { return ( arr [ N / 2 ] + low - 1 ) / 2 ; } } return low - 1 ; }
void split ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] == 1 ) { count = 2 ; break ; } } Console . Write ( count ) ; }
bool check ( String str1 , String str2 ) { bool [ ] mark = new bool [ 26 ] ; int n = str1 . Length , m = str2 . Length ; for ( int i = 0 ; i < n ; i ++ ) { mark [ str1 [ i ] - 'a' ] = true ; } for ( int i = 0 ; i < m ; i ++ ) { if ( mark [ str2 [ i ] - 'a' ] ) return true ; } return false ; }
bool countLessThanMid ( int mid , int N , int M , int K ) { int count = 0 ; for ( int i = 1 ; i <= Math . Min ( N , mid ) ; ++ i ) { count = count + Math . Min ( mid / i , M ) ; } if ( count >= K ) return false ; else return true ; }
int findKthElement ( int N , int M , int K ) { int low = 1 , high = N * M ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( countLessThanMid ( mid , N , M , K ) ) low = mid + 1 ; else high = mid - 1 ; } return high + 1 ; }
int PermuteTheArray ( int [ ] A , int n ) { int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ A [ i ] - 1 ] = i ; } int mini = n , maxi = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mini = Math . Min ( mini , arr [ i ] ) ; maxi = Math . Max ( maxi , arr [ i ] ) ; if ( maxi - mini == i ) count ++ ; } return count ; }
int [ ] findLargest ( int beg , int end , int [ ] arr , int n ) { if ( beg == end ) { int [ ] compared = new int [ n ] ; compared [ 0 ] = 1 ; compared [ 1 ] = arr [ beg ] ; return compared ; } int [ ] compared1 = findLargest ( beg , ( beg + end ) / 2 , arr , n ) ; int [ ] compared2 = findLargest ( ( beg + end ) / 2 + 1 , end , arr , n ) ; if ( compared1 [ 1 ] > compared2 [ 1 ] ) { int k = compared1 [ 0 ] + 1 ; compared1 [ 0 ] = k ; compared1 [ k ] = compared2 [ 1 ] ; return compared1 ; } else { int k = compared2 [ 0 ] + 1 ; compared2 [ 0 ] = k ; compared2 [ k ] = compared1 [ 1 ] ; return compared2 ; } }
void findSecondLargest ( int end , int [ ] arr ) { int [ ] compared1 = findLargest ( 0 , end - 1 , arr , end ) ; int [ ] compared2 = findLargest ( 2 , compared1 [ 0 ] + 2 , compared1 , compared1 [ 0 ] ) ; Console . WriteLine ( compared2 [ 1 ] ) ; }
int CountsubString ( char [ ] str , int n ) { int c = 0 ; for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; char temp = str [ i ] , f = '0' ; if ( j == i ) { c ++ ; continue ; } int k = i + 1 ; while ( temp > str [ k ] && k <= j ) { temp = str [ k ] ; k ++ ; } if ( k > j ) { c ++ ; f = '2' ; } while ( k <= j && temp < str [ k ] && f != '2' ) { temp = str [ k ] ; k ++ ; } if ( k > j && f != 2 ) { c ++ ; f = '0' ; } } } return c ; }
void countSubString ( String S , char C ) { int count = 0 ; int conCount = 0 ; for ( int i = 0 ; i < S . Length ; i ++ ) { char ch = S [ i ] ; if ( ch == C ) conCount ++ ; else { count += ( conCount * ( conCount + 1 ) ) / 2 ; conCount = 0 ; } } count += ( conCount * ( conCount + 1 ) ) / 2 ; Console . Write ( count ) ; }
void checkPalindrome ( String S ) { int N = S . Length ; bool first_half = true ; bool second_half = true ; int cnt = ( N / 2 ) - 1 ; for ( int i = 0 ; i < ( N / 2 ) ; i ++ ) { if ( S [ i ] != S [ cnt ] ) { first_half = false ; break ; } if ( S [ N / 2 + i ] != S [ N / 2 + cnt ] ) { second_half = false ; break ; } cnt -- ; } if ( first_half && second_half ) { Console . Write ( "Yes" ) ; } else { Console . Write ( "No" ) ; } }
bool isSubsetSum ( int [ ] arr , int n , int sum ) { bool [ , ] subset = new bool [ n + 1 , sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i , 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 , i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < arr [ i - 1 ] ) subset [ i , j ] = subset [ i - 1 , j ] ; if ( j >= arr [ i - 1 ] ) subset [ i , j ] = subset [ i - 1 , j ] || subset [ i - 1 , j - arr [ i - 1 ] ] ; } } return subset [ n , sum ] ; }
int findSum ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int val = ( int ) Math . Sqrt ( sum ) ; for ( int i = val ; i >= 0 ; i -- ) { if ( isSubsetSum ( arr , n , i * i ) ) { return i * i ; } } return 0 ; }
int findsubArray ( int [ ] arr , int N , int K ) { int res = N + 1 ; for ( int i = 0 ; i < N ; i ++ ) { int curr_prod = 1 ; for ( int j = i ; j < N ; j ++ ) { curr_prod = curr_prod * arr [ j ] ; if ( curr_prod % N == K && res > ( j - i + 1 ) ) { res = Math . Min ( res , j - i + 1 ) ; break ; } } } return ( res == N + 1 ) ? 0 : res ; }
void check ( int [ , ] arr ) { int f = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! checkBitonic ( GetRow ( arr , i ) , M ) ) { Console . WriteLine ( "NO" ) ; return ; } } for ( int i = 0 ; i < N ; i ++ ) { int [ ] temp = new int [ N ] ; for ( int j = 0 ; j < N ; j ++ ) { temp [ j ] = arr [ j , i ] ; } if ( ! checkBitonic ( temp , N ) ) { Console . WriteLine ( "NO" ) ; return ; } } Console . WriteLine ( "YES" ) ; }
int getMaxGcd ( int N ) { int maxGcd = int . MinValue , A , B ; for ( int i = 1 ; i <= Math . Sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { A = i ; B = N / i ; maxGcd = Math . Max ( maxGcd , gcd ( A , B ) ) ; } } return maxGcd ; }
bool can_place ( int [ ] A , int n , int B , int mid ) { int count = 1 ; int last_position = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] - last_position >= mid ) { last_position = A [ i ] ; count ++ ; if ( count == B ) { return true ; } } } return false ; }
int find_min_difference ( int [ ] A , int n , int B ) { Array . Sort ( A ) ; int s = 0 ; int e = A [ n - 1 ] - A [ 0 ] ; int ans = 0 ; while ( s <= e ) { int mid = ( s + e ) / 2 ; if ( can_place ( A , n , B , mid ) ) { ans = mid ; s = mid + 1 ; } else { e = mid - 1 ; } } return ans ; }
void UniversalSubset ( List < String > A , List < String > B ) { int n1 = A . Count ; int n2 = B . Count ; List < String > res = new List < String > ( ) ; int [ , ] A_fre = new int [ n1 , 26 ] ; for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) A_fre [ i , j ] = 0 ; } for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < A [ i ] . Length ; j ++ ) { A_fre [ i , A [ i ] [ j ] - 'a' ] ++ ; } } int [ ] B_fre = new int [ 26 ] ; for ( int i = 0 ; i < n2 ; i ++ ) { int [ ] arr = new int [ 26 ] ; for ( int j = 0 ; j < B [ i ] . Length ; j ++ ) { arr [ B [ i ] [ j ] - 'a' ] ++ ; B_fre [ B [ i ] [ j ] - 'a' ] = Math . Max ( B_fre [ B [ i ] [ j ] - 'a' ] , arr [ B [ i ] [ j ] - 'a' ] ) ; } } for ( int i = 0 ; i < n1 ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( A_fre [ i , j ] < B_fre [ j ] ) { flag = 1 ; break ; } } if ( flag == 0 ) res . Add ( A [ i ] ) ; } if ( res . Count != 0 ) { for ( int i = 0 ; i < res . Count ; i ++ ) { for ( int j = 0 ; j < res [ i ] . Length ; j ++ ) Console . Write ( res [ i ] [ j ] ) ; } Console . Write ( " " ) ; } else Console . Write ( "-1" ) ; }
int countTriplets ( int [ ] A , int N ) { int ans = 0 ; Dictionary < int , int > map = new Dictionary < int , int > ( ) ; for ( int j = N - 2 ; j >= 1 ; j -- ) { if ( map . ContainsKey ( A [ j + 1 ] ) ) map [ A [ j + 1 ] ] = map [ A [ j + 1 ] ] + 1 ; else map . Add ( A [ j + 1 ] , 1 ) ; for ( int i = 0 ; i < j ; i ++ ) { int target = A [ i ] * A [ j ] ; if ( map . ContainsKey ( target ) ) ans += map [ target ] ; } } return ans ; }
int minDistance ( int [ ] a , int n ) { int max = - 1 , min = Int32 . MaxValue ; int min_index = - 1 , max_index = - 1 ; int min_dist = n + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; if ( a [ i ] < min ) min = a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == min ) min_index = i ; if ( a [ i ] == max ) max_index = i ; if ( min_index != - 1 && max_index != - 1 ) min_dist = Math . Min ( min_dist , Math . Abs ( min_index - max_index ) ) ; } return min_dist ; }
int sign ( int x ) { if ( x > 0 ) return 1 ; else return - 1 ; }
int findMaxSum ( int [ ] arr , int size ) { int max_sum = 0 , pres , i , j ; for ( i = 0 ; i < size ; i ++ ) { pres = arr [ i ] ; j = i ; while ( j < size && sign ( arr [ i ] ) == sign ( arr [ j ] ) ) { pres = Math . Max ( pres , arr [ j ] ) ; j ++ ; } max_sum = max_sum + pres ; i = j - 1 ; } return max_sum ; }
bool groupInKConsecutive ( int [ ] arr , int K ) { Dictionary < int , int > count = new Dictionary < int , int > ( ) ; foreach ( int h in arr ) { if ( count . ContainsKey ( h ) ) count [ h ] ++ ; else count [ h ] = 1 ; } foreach ( int c in count . Keys . ToList ( ) ) { int cur = c ; int n = count ; if ( n > 0 ) { for ( int i = 1 ; i < K ; ++ i ) { if ( ! count . ContainsKey ( cur + i ) ) { return false ; } count [ cur + i ] -= n ; if ( count [ cur + i ] < 0 ) return false ; } } } return true ; }
bool checkrules ( String s ) { if ( s . Length == 0 ) return true ; if ( s [ 0 ] != '1' ) return false ; if ( s . Length > 2 ) { if ( s [ 1 ] == '0' && s [ 2 ] == '0' ) return checkrules ( s . Substring ( 3 ) ) ; } return checkrules ( s . Substring ( 1 ) ) ; }
int countSubAllOnes ( String s ) { int l = 0 , r = 0 , ans = 0 ; while ( l <= r ) { if ( r == s . Length ) { ans += ( ( r - l ) * ( r - l + 1 ) ) / 2 ; break ; } if ( s [ r ] == '1' ) r ++ ; else { ans += ( ( r - l ) * ( r - l + 1 ) ) / 2 ; l = r + 1 ; r ++ ; } } return ans ; }
int countOfPrimes ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( isPrime ( i ) ) { if ( sumSquare ( i ) ) count ++ ; } } return count ; }
int Maxlen ( int [ ] arr , int n ) { int ans = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count = 0 ; else count ++ ; ans = Math . Max ( ans , count ) ; } return ans ; }
void findPair ( int [ ] a , int n ) { int min_dist = int . MaxValue ; int index_a = - 1 , index_b = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( j - i < min_dist ) { if ( a [ i ] % a [ j ] == 0 a [ j ] % a [ i ] == 0 ) { min_dist = j - i ; index_a = i ; index_b = j ; } } } } if ( index_a == - 1 ) { Console . WriteLine ( "-1" ) ; } else { Console . Write ( "(" + a [ index_a ] + ", " + a [ index_b ] + ")" ) ; } }
int findNumberDivByPowerofTwo ( int [ ] ar , int k , int n ) { int found = - 1 , m = k ; while ( m > 0 ) { int l = 0 ; int r = n - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( ar [ mid ] == m ) { found = m ; break ; } else if ( ar [ mid ] > m ) { r = mid - 1 ; } else if ( ar [ mid ] < m ) { l = mid + 1 ; } } if ( found != - 1 ) { break ; } m = m / 2 ; } return found ; }
int longestNudeSubseq ( int [ ] arr , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isNudeNum ( arr [ i ] ) ) answer ++ ; } return answer ; }
int findSubset ( int [ ] a , int n ) { int sum = 0 ; int cnt = 0 ; List < int > v = new List < int > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i - 1 ] - i <= 0 ) { sum += a [ i - 1 ] - i ; cnt += 1 ; } else { v . Add ( a [ i - 1 ] - i ) ; } } v . Sort ( ) ; int ptr = 0 ; while ( ptr < v . Count && sum + v [ ptr ] <= 0 ) { cnt += 1 ; ptr += 1 ; sum += v [ ptr ] ; } return cnt ; }
List < int > get_submaxarr ( int [ ] arr , int n , int y ) { int j = 0 ; Stack < int > stk = new Stack < int > ( ) ; int [ ] maxarr = new int [ n ] ; Array . Fill ( maxarr , 0 ) ; stk . Push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( stk . Count != 0 && arr [ i ] > arr [ stk . Peek ( ) ] ) { maxarr [ stk . Peek ( ) ] = i - 1 ; stk . Pop ( ) ; } stk . Push ( i ) ; } while ( stk . Count != 0 ) { maxarr [ stk . Count ] = n - 1 ; stk . Pop ( ) ; } List < int > submax = new List < int > ( ) ; for ( int i = 0 ; i <= n - y ; i ++ ) { while ( maxarr [ j ] < i + y - 1 j < i ) { j ++ ; } submax . Add ( arr [ j ] ) ; } return submax ; }
int findMinx ( int A , int B , int C , int K ) { int start = 1 ; int end = ( int ) Math . Ceiling ( Math . Sqrt ( K ) ) ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; int x = func ( A , B , C , mid ) ; int Y = func ( A , B , C , mid - 1 ) ; if ( x >= K && Y < K ) { return mid ; } else if ( x < K ) { start = mid + 1 ; } else { end = mid - 1 ; } } return - 1 ; }
int longestSubarray ( int [ ] arr , int n , int k ) { int i , j , Max = 1 ; HashSet < int > s = new HashSet < int > ( ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { s . Add ( arr [ i ] ) ; for ( j = i + 1 ; j < n ; j ++ ) { if ( Math . Abs ( arr [ i ] - arr [ j ] ) == 0 || Math . Abs ( arr [ i ] - arr [ j ] ) == k ) { if ( ! s . Contains ( arr [ j ] ) ) { if ( s . Count == 2 ) break ; else s . Add ( arr [ j ] ) ; } } else break ; } if ( s . Count == 2 ) { Max = Math . Max ( Max , j - i ) ; s . Clear ( ) ; } else s . Clear ( ) ; } return Max ; }
void printDiagonal ( int K , int N , int [ , ] M ) { int startrow , startcol ; if ( K - 1 < N ) { startrow = K - 1 ; startcol = 0 ; } else { startrow = N - 1 ; startcol = K - N ; } for ( ; startrow >= 0 && startcol < N ; startrow -- , startcol ++ ) { Console . Write ( M [ startrow , startcol ] + " " ) ; } }
List < int > generateSequence ( int [ ] freq , int n ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { m . Add ( i , freq [ i ] ) ; total += freq [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( m . ContainsKey ( i ) ) { List < int > sequence = new List < int > ( ) ; Dictionary < int , int > mcopy = new Dictionary < int , int > ( m ) ; if ( mcopy . ContainsKey ( i ) && mcopy [ i ] > 0 ) mcopy [ i ] = mcopy [ i ] - 1 ; sequence . Add ( i ) ; int last = i ; for ( int i1 = 0 ; i1 < total - 1 ; i1 ++ ) { if ( mcopy . ContainsKey ( last - 1 ) && mcopy [ last - 1 ] > 0 ) { mcopy [ last - 1 ] = mcopy [ last - 1 ] - 1 ; sequence . Add ( last - 1 ) ; last -- ; } else if ( mcopy . ContainsKey ( last + 1 ) ) { mcopy [ last + 1 ] = mcopy [ last + 1 ] - 1 ; sequence . Add ( last + 1 ) ; last ++ ; } else break ; } if ( sequence . Count == total ) { return sequence ; } } } List < int > empty = new List < int > ( ) ; return empty ; }
void getMinimumDistance ( int [ ] a , int n ) { HashSet < int > min_set = new HashSet < int > ( ) ; HashSet < int > max_set = new HashSet < int > ( ) ; int max = 0 , min = Int32 . MaxValue ; Dictionary < int , int > frequency = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! frequency . ContainsKey ( a [ i ] ) ) frequency . Add ( a [ i ] , 0 ) ; frequency [ a [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { int count = frequency [ a [ i ] ] ; if ( count == max ) { max_set . Add ( a [ i ] ) ; } else if ( count > max ) { max_set . Clear ( ) ; max = count ; max_set . Add ( a [ i ] ) ; } if ( count == min ) { min_set . Add ( a [ i ] ) ; } else if ( count < min ) { min_set . Clear ( ) ; min = count ; min_set . Add ( a [ i ] ) ; } } int min_dist = Int32 . MaxValue ; int last_min_found = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_set . Contains ( a [ i ] ) ) last_min_found = i ; if ( max_set . Contains ( a [ i ] ) && last_min_found != - 1 ) { min_dist = Math . Min ( min_dist , i - last_min_found ) ; } } last_min_found = - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( min_set . Contains ( a [ i ] ) ) last_min_found = i ; if ( max_set . Contains ( a [ i ] ) && last_min_found != - 1 ) { min_dist = Math . Min ( min_dist , last_min_found - i ) ; } } Console . WriteLine ( min_dist ) ; }
void printNum ( int L , int R ) { for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) Console . Write ( i + " " ) ; } }
void findPair ( int [ ] arr , int n ) { int i , j ; if ( n < 2 ) { Console . Write ( "-1" ) ; } HashSet < int > hashMap = new HashSet < int > ( ) ; foreach ( int k in arr ) { hashMap . Add ( k ) ; } for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( ! hashMap . Contains ( sum ) ) { Console . Write ( "(" + arr [ i ] + ", " + arr [ j ] + ")\n" ) ; } } } }
int findLengthOfMaxSubset ( int [ ] arr , int n , int m ) { HashSet < int > s = new HashSet < int > ( ) ; int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int tmp = arr [ i ] ; if ( tmp != m ) { s . Add ( tmp ) ; answer ++ ; } } int min = 1 ; while ( s . Contains ( min ) ) { min ++ ; } if ( min != m ) { answer = - 1 ; } return answer ; }
bool getDiameterPath ( int vertex , int targetVertex , int parent , List < int > path ) { if ( vertex == targetVertex ) { path . Add ( vertex ) ; return true ; } foreach ( int i in tree [ vertex ] ) { if ( i == parent ) continue ; if ( getDiameterPath ( i , targetVertex , vertex , path ) ) { path . Add ( vertex ) ; return true ; } } return false ; }
void addedge ( int a , int b ) { if ( ! tree . ContainsKey ( a ) ) tree [ a ] = new List < int > ( ) ; tree [ a ] . Add ( b ) ; if ( ! tree . ContainsKey ( b ) ) tree [ b ] = new List < int > ( ) ; tree [ b ] . Add ( a ) ; }
void FindCenter ( int n ) { maxHeight = - 1 ; maxHeightNode = - 1 ; farthestNode ( 0 , - 1 , 0 ) ; int leaf1 = maxHeightNode ; maxHeight = - 1 ; farthestNode ( maxHeightNode , - 1 , 0 ) ; int leaf2 = maxHeightNode ; path = new List < int > ( ) ; getDiameterPath ( leaf1 , leaf2 , - 1 , path ) ; int pathSize = path . Count ; if ( pathSize % 2 == 1 ) { Console . WriteLine ( path [ pathSize / 2 ] ) ; } else { Console . WriteLine ( path [ pathSize / 2 ] + ", " + path [ ( pathSize - 1 ) / 2 ] ) ; } }
int countSubsquare ( int [ , ] arr , int n , int X ) { int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { dp [ i + 1 , j + 1 ] = arr [ i , j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i , j ] += dp [ i - 1 , j ] + dp [ i , j - 1 ] - dp [ i - 1 , j - 1 ] ; } } int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int lo = 1 ; int hi = Math . Min ( n - i , m - j ) + 1 ; bool found = false ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; int ni = i + mid - 1 ; int nj = j + mid - 1 ; int sum = dp [ ni , nj ] - dp [ ni , j - 1 ] - dp [ i - 1 , nj ] + dp [ i - 1 , j - 1 ] ; if ( sum >= X ) { if ( sum == X ) { found = true ; } hi = mid - 1 ; } else { lo = mid + 1 ; } } if ( found == true ) { cnt ++ ; } } } return cnt ; }
int countSub ( String str ) { int n = ( int ) str . Length ; int ans = 0 ; int [ ] cnt = new int [ 26 ] ; int i = 0 , j = 0 ; while ( i < n ) { if ( j < n && ( cnt [ str [ j ] - 'a' ] == 0 ) ) { cnt [ str [ j ] - 'a' ] ++ ; ans += ( j - i + 1 ) ; j ++ ; } else { cnt [ str [ i ] - 'a' ] -- ; i ++ ; } } return ans ; }
void findMaxValue ( int N , int K ) { int packages ; int maxi = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( N % i == 0 ) maxi = Math . Max ( maxi , i ) ; } packages = N / maxi ; Console . WriteLine ( packages ) ; }
void max_sum_subarray ( List < int > arr , int L , int R ) { int n = arr . Count ; int [ ] pre = new int [ n ] ; pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } List < int > s1 = new List < int > ( ) ; s1 . Add ( 0 ) ; int ans = Int32 . MinValue ; ans = Math . Max ( ans , pre [ L - 1 ] ) ; int flag = 0 ; for ( int i = L ; i < n ; i ++ ) { if ( i - R >= 0 ) { if ( flag == 0 ) { int it = s1 . IndexOf ( 0 ) ; s1 . RemoveAt ( it ) ; flag = 1 ; } } if ( i - L >= 0 ) s1 . Add ( pre [ i - L ] ) ; ans = Math . Max ( ans , pre [ i ] - s1 [ 0 ] ) ; if ( i - R >= 0 ) { int it = s1 . IndexOf ( pre [ i - R ] ) ; s1 . RemoveAt ( it ) ; } } Console . WriteLine ( ans ) ; }
int rowWise ( char [ , ] v , int n , int m , int k ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int countcons = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( v [ i , j ] == '1' ) { countcons = 0 ; } else { countcons ++ ; } if ( countcons >= k ) { ans ++ ; } } } return ans ; }
int colWise ( char [ , ] v , int n , int m , int k ) { int ans = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int countcons = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( v [ j , i ] == '1' ) { countcons = 0 ; } else { countcons ++ ; } if ( countcons >= k ) { ans ++ ; } } } return ans ; }
bool solve ( int [ ] a , int n ) { int mx = Int32 . MinValue ; for ( int j = 1 ; j < n ; j ++ ) { if ( mx > a [ j ] ) return false ; mx = Math . Max ( mx , a [ j - 1 ] ) ; } return true ; }
int count ( int [ ] v , int n ) { int i , odd = 0 , even = 0 ; int j , d , count ; int t = ( int ) 1 << v . Length ; int size = v . Length ; for ( i = 1 ; i < t ; i ++ ) { d = 1 ; count = 0 ; for ( j = 0 ; j < size ; j ++ ) { if ( ( i & ( 1 << j ) ) > 0 ) { d *= v [ j ] ; count ++ ; } } if ( count % 2 == 1 ) odd += n / d ; else even += n / d ; } return ( odd - even ) ; }
int BinarySearch ( int l , int r , int [ ] v , int key ) { int mid ; while ( r - l > 1 ) { mid = ( l + r ) / 2 ; if ( key <= count ( v , mid ) ) { r = mid ; } else { l = mid ; } } if ( key == count ( v , l ) ) return l ; else return r ; }
void sieve ( ) { for ( int i = 0 ; i < 100005 ; i ++ ) spf [ i ] = - 1 ; for ( int i = 2 ; i * i <= 100005 ; i ++ ) { for ( int j = i ; j <= 100005 ; j += i ) { if ( spf [ j ] == - 1 ) { spf [ j ] = i ; } } } }
HashSet < int > findPrimeFactors ( HashSet < int > s , int n ) { while ( n > 1 ) { s . Add ( spf [ n ] ) ; n /= spf [ n ] ; } return s ; }
int MinimumSteps ( int n , int m ) { Queue < pair > q = new Queue < pair > ( ) ; HashSet < int > s = new HashSet < int > ( ) ; q . Enqueue ( new pair ( n , 0 ) ) ; while ( q . Count != 0 ) { int newNum = q . Peek ( ) . first ; int distance = q . Peek ( ) . second ; q . Dequeue ( ) ; HashSet < int > k = findPrimeFactors ( s , newNum ) ; foreach ( int i in k ) { if ( newNum == m ) { return distance ; } else if ( newNum > m ) { break ; } else { q . Enqueue ( new pair ( newNum + i , distance + 1 ) ) ; } } } return - 1 ; }
void maxSide ( int [ ] a , int n ) { int sideLength = 0 ; Array . Sort ( a ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] > sideLength ) { sideLength ++ ; } else { break ; } } Console . Write ( sideLength ) ; }
void medianChange ( List < int > arr1 , List < int > arr2 ) { int N = arr1 . Count ; List < double > median = new List < double > ( ) ; if ( ( N & 1 ) != 0 ) { median . Add ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . Add ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } foreach ( int x in arr2 ) { int it = arr1 . IndexOf ( x ) ; arr1 . RemoveAt ( it ) ; N -- ; if ( ( N & 1 ) != 0 ) { median . Add ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . Add ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } } for ( int i = 0 ; i < median . Count - 1 ; i ++ ) { Console . Write ( median [ i + 1 ] - median [ i ] + " " ) ; } }
int countPairs ( int [ ] X , int [ ] Y , int m , int n ) { int [ ] suffix = new int [ 1005 ] ; long total_pairs = 0 ; for ( int i = 0 ; i < n ; i ++ ) suffix [ Y [ i ] ] ++ ; for ( int i = ( int ) 1e3 ; i >= 3 ; i -- ) suffix [ i ] += suffix [ i + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( X [ i ] == 0 ) continue ; else if ( X [ i ] == 1 ) { total_pairs += suffix [ 0 ] ; continue ; } else if ( X [ i ] == 2 ) total_pairs += suffix [ 5 ] ; else if ( X [ i ] == 3 ) total_pairs += suffix [ 2 ] + suffix [ 4 ] ; else total_pairs += suffix [ X [ i ] + 1 ] ; total_pairs += suffix [ 0 ] + suffix [ 1 ] ; } return ( int ) total_pairs ; }
int solve ( int [ , ] A , int N , int M ) { int [ , ] B = new int [ N , M ] ; int c = 1 ; HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) B [ i , j ] = c ++ ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i != 0 ) { if ( A [ i - 1 , j ] == A [ i , j ] ) B [ i - 1 , j ] = B [ i , j ] ; } if ( i != N - 1 ) { if ( A [ i + 1 , j ] == A [ i , j ] ) B [ i + 1 , j ] = B [ i , j ] ; } if ( j != 0 ) { if ( A [ i , j - 1 ] == A [ i , j ] ) B [ i , j - 1 ] = B [ i , j ] ; } if ( j != M - 1 ) { if ( A [ i , j + 1 ] == A [ i , j ] ) B [ i , j + 1 ] = B [ i , j ] ; } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) s . Add ( B [ i , j ] ) ; } return s . Count ; }
int splitArray ( int start , int end , int [ ] arr , int [ ] prefix_sum ) { if ( start >= end ) return 0 ; for ( int k = start ; k < end ; ++ k ) { if ( ( prefix_sum [ k ] - prefix_sum [ start - 1 ] ) == ( prefix_sum [ end ] - prefix_sum [ k ] ) ) { return 1 + splitArray ( start , k , arr , prefix_sum ) + splitArray ( k + 1 , end , arr , prefix_sum ) ; } } return 0 ; }
void solve ( int [ ] arr , int n ) { int [ ] prefix_sum = new int [ n + 1 ] ; prefix_sum [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i - 1 ] ; } Console . Write ( splitArray ( 1 , n , arr , prefix_sum ) ) ; }
void minDiff ( long [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) a [ i ] *= 2 ; } Array . Sort ( a ) ; long mindifference = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i < a . Length ; i ++ ) { mindifference = Math . Min ( mindifference , a [ i ] - a [ i - 1 ] ) ; } Console . Write ( mindifference ) ; }
int countFac ( int n ) { int m = n ; int count = 0 ; for ( int i = 2 ; ( i * i ) <= m ; ++ i ) { int total = 0 ; while ( n % i == 0 ) { n /= i ; ++ total ; } int temp = 0 ; for ( int j = 1 ; ( temp + j ) <= total ; ++ j ) { temp += j ; ++ count ; } } if ( n != 1 ) ++ count ; return count ; }
int findMissing ( int [ ] arr , int left , int right , int diff ) { if ( right <= left ) return 0 ; int mid = left + ( right - left ) / 2 ; if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ; if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ; if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return findMissing ( arr , mid + 1 , right , diff ) ; return findMissing ( arr , left , mid - 1 , diff ) ; }
int missingElement ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int diff = ( arr [ n - 1 ] - arr [ 0 ] ) / n ; return findMissing ( arr , 0 , n - 1 , diff ) ; }
long check ( int A , int B , int C , int D , long x ) { long ans ; ans = ( A * x * x * x + B * x * x + C * x + D ) ; return ans ; }
void findSolution ( int A , int B , int C , int D , int E ) { long start = 0 , end = 100000 ; long mid , ans ; while ( start <= end ) { mid = start + ( end - start ) / 2 ; ans = check ( A , B , C , D , mid ) ; if ( ans == E ) { Console . WriteLine ( mid ) ; return ; } if ( ans < E ) start = mid + 1 ; else end = mid - 1 ; } Console . Write ( "NA" ) ; }
int findParent ( int height , int node ) { int start = 1 ; int end = ( int ) Math . Pow ( 2 , height ) - 1 ; if ( end == node ) return - 1 ; while ( node >= 1 ) { end = end - 1 ; int mid = start + ( end - start ) / 2 ; if ( mid == node end == node ) { return ( end + 1 ) ; } else if ( node < mid ) { end = mid ; } else { start = mid ; } } return - 1 ; }
int findValue ( int R , int C ) { int k = ( R * ( R - 1 ) ) / 2 + 1 ; int diff = R + 1 ; for ( int i = 1 ; i < C ; i ++ ) { k = ( k + diff ) ; diff ++ ; } return k ; }
int power ( int x , int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
int nthRootSearch ( int low , int high , int N , int K ) { if ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( power ( mid , K ) <= N ) && ( power ( mid + 1 , K ) > N ) ) { return mid ; } else if ( power ( mid , K ) < N ) { return nthRootSearch ( mid + 1 , high , N , K ) ; } else { return nthRootSearch ( low , mid - 1 , N , K ) ; } } return low ; }
int get_subset_count ( int [ ] arr , int K , int N ) { Array . Sort ( arr ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; }
int naive_find_x ( int N ) { int c = 0 , i ; for ( i = 1 ; i < N ; i ++ ) { c += i * i * i ; if ( c >= N ) break ; } return i ; }
int binary_searched_find_x ( int k ) { int l = 0 ; int r = k ; int ans = 0 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( Math . Pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; }
int checkPerfectSquare ( int N , int start , int last ) { int mid = ( start + last ) / 2 ; if ( start > last ) { return - 1 ; } if ( mid * mid == N ) { return mid ; } else if ( mid * mid > N ) { return checkPerfectSquare ( N , start , mid - 1 ) ; } else { return checkPerfectSquare ( N , mid + 1 , last ) ; } }
void minDistancePoints ( int [ ] A , int K , int n ) { Dictionary < int , Boolean > m = new Dictionary < int , Boolean > ( ) ; Queue < int > q = new Queue < int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { m . Add ( A [ i ] , true ) ; q . Enqueue ( A [ i ] ) ; } List < int > ans = new List < int > ( ) ; while ( K > 0 ) { int x = q . Dequeue ( ) ; if ( ! m . ContainsKey ( x - 1 ) && K > 0 ) { m . Add ( x - 1 , true ) ; q . Enqueue ( x - 1 ) ; ans . Add ( x - 1 ) ; K -- ; } if ( ! m . ContainsKey ( x + 1 ) && K > 0 ) { m . Add ( x + 1 , true ) ; q . Enqueue ( x + 1 ) ; ans . Add ( x + 1 ) ; K -- ; } } foreach ( int i in ans ) Console . Write ( i + " " ) ; }
int search ( int [ , ] mat , int n , int m ) { int i , a = int . MaxValue ; for ( i = 0 ; i < n ; i ++ ) { int low = 0 ; int high = m - 1 ; int mid ; int ans = int . MaxValue ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( mat [ i , mid ] == 1 ) { if ( mid == 0 ) { ans = 0 ; break ; } else if ( mat [ i , mid - 1 ] == 0 ) { ans = mid ; break ; } } if ( mat [ i , mid ] == 1 ) high = mid - 1 ; else low = mid + 1 ; } if ( ans < a ) a = ans ; } if ( a == int . MaxValue ) return - 1 ; return a + 1 ; }
void findNumbers ( int N , int M ) { int m = M ; Dictionary < int , int > remLen = new Dictionary < int , int > ( ) ; int len , remainder = 0 ; for ( len = 1 ; len <= N + 1 ; ++ len ) { remainder = M % N ; if ( ! remLen . ContainsKey ( remainder ) ) { remLen . Add ( remainder , len ) ; } else { break ; } M = M * 10 + m ; M = M % N ; } int LenA = len ; int LenB = remLen [ remainder ] ; for ( int i = 0 ; i < LenB ; ++ i ) Console . Write ( m ) ; Console . Write ( " " ) ; for ( int i = 0 ; i < LenA ; ++ i ) Console . Write ( m ) ; }
int subMatrixSum ( int i , int j , int len ) { return prefix_2D [ i , j ] - prefix_2D [ i , j - len ] - prefix_2D [ i - len , j ] + prefix_2D [ i - len , j - len ] ; }
int numberOfWays ( int [ ] a , int [ ] b , int n , int m , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) prefix_2D [ i , j ] = 1 ; else prefix_2D [ i , j ] = 0 ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { prefix_2D [ i , j ] += prefix_2D [ i , j - 1 ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { prefix_2D [ i , j ] += prefix_2D [ i - 1 , j ] ; } } int answer = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int low = 1 ; int high = Math . Min ( i , j ) ; while ( low < high ) { int mid = ( low + high ) >> 1 ; if ( subMatrixSum ( i , j , mid ) >= k ) { high = mid ; } else { low = mid + 1 ; } } if ( subMatrixSum ( i , j , low ) >= k ) { answer += ( Math . Min ( i , j ) - low + 1 ) ; } } } return answer ; }
void minpoint ( int [ ] arr , int n , int k ) { int min_point = 0 ; for ( int i = 1 ; i < k - 1 ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) min_point += 1 ; } int final_point = min_point ; for ( int i = k ; i < n ; i ++ ) { if ( arr [ i - ( k - 1 ) ] < arr [ i - ( k - 1 ) + 1 ] && arr [ i - ( k - 1 ) ] < arr [ i - ( k - 1 ) - 1 ] ) min_point -= 1 ; if ( arr [ i - 1 ] < arr [ i ] && arr [ i - 1 ] < arr [ i - 2 ] ) min_point += 1 ; if ( min_point > final_point ) final_point = min_point ; } Console . WriteLine ( final_point ) ; }
void checkMin ( int [ ] arr , int len ) { int smallest = int . MaxValue ; int secondSmallest = int . MaxValue ; for ( int i = 0 ; i < len ; i ++ ) { if ( arr [ i ] < smallest ) { secondSmallest = smallest ; smallest = arr [ i ] ; } else if ( arr [ i ] < secondSmallest ) { secondSmallest = arr [ i ] ; } } if ( 2 * smallest <= secondSmallest ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
int [ ] find ( int dividend , int divisor , int start , int end ) { if ( start > end ) return new int [ ] { 0 , dividend } ; int mid = start + ( end - start ) / 2 ; int n = dividend - divisor * mid ; if ( n > divisor ) start = mid + 1 ; else if ( n < 0 ) end = mid - 1 ; else { if ( n == divisor ) { ++ mid ; n = 0 ; } return new int [ ] { mid , n } ; } return find ( dividend , divisor , start , end ) ; }
int [ ] divide ( int dividend , int divisor ) { return find ( dividend , divisor , 1 , dividend ) ; }
int get ( int a , int b , int n ) { int lo = 0 , hi = ( int ) 1e6 ; int ans = 0 ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; int dig = ( int ) Math . Ceiling ( ( double ) ( mid * log ( mid , b ) + log ( a , b ) ) ) ; if ( dig > n ) { hi = mid - 1 ; } else { ans = mid ; lo = mid + 1 ; } } return ans ; }
void FindRank ( int [ ] arr , int length ) { Console . Write ( "1" + " " ) ; for ( int i = 1 ; i < arr . Length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } Console . Write ( rank + " " ) ; } }
void findFibonacci ( int N ) { for ( int i = N / 2 ; i > 1 ; i -- ) { if ( fib . Contains ( i ) && fib . Contains ( N - i ) ) { Console . WriteLine ( i + " " + ( N - i ) ) ; return ; } } Console . WriteLine ( "-1" ) ; }
void createHash ( ) { int prev = 0 , curr = 1 ; fibonacci . Add ( prev ) ; fibonacci . Add ( curr ) ; while ( curr <= MAX ) { int temp = curr + prev ; fibonacci . Add ( temp ) ; prev = curr ; curr = temp ; } }
bool checkArray ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( fibonacci . Contains ( arr [ i ] ) ) sum += arr [ i ] ; if ( fibonacci . Contains ( sum ) ) return true ; return false ; }
void compute ( int sz ) { bool [ ] isFib = new bool [ sz + 1 ] ; int prev = 0 , curr = 1 ; isFib [ prev ] = isFib [ curr ] = true ; while ( curr <= sz ) { int temp = curr + prev ; if ( temp <= sz ) isFib [ temp ] = true ; prev = curr ; curr = temp ; } fibUpto [ 0 ] = 1 ; for ( int i = 1 ; i <= sz ; i ++ ) { fibUpto [ i ] = fibUpto [ i - 1 ] ; if ( isFib [ i ] ) fibUpto [ i ] ++ ; } }
int countOfNumbers ( int N , int K ) { compute ( N ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - fibUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ( ans > 0 ? N - ans + 1 : 0 ) ; }
void precompute ( String s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { f [ s [ i ] - 'a' , i ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { f [ i , j ] += f [ i , j - 1 ] ; } } }
int palindromicSubsequencesUtil ( int L , int R ) { int c = 0 , ok = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int cnt = f [ i , R ] ; if ( L > 0 ) cnt -= f [ i , L - 1 ] ; if ( cnt > 1 ) { ok = 1 ; c = i ; break ; } } if ( ok == 0 ) { return - 1 ; } return c ; }
void createHash ( HashSet < int > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . Add ( prev ) ; hash . Add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . Add ( temp ) ; prev = curr ; curr = temp ; } }
int longestFibSubarray ( int [ ] arr , int n ) { int max_val = arr . Max ( ) ; HashSet < int > hash = new HashSet < int > ( ) ; createHash ( hash , max_val ) ; int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; int fibcount = 0 , res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = fibcount ; if ( hash . Contains ( arr [ i ] ) ) { fibcount ++ ; } else fibcount = 0 ; } fibcount = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { right [ i ] = fibcount ; if ( hash . Contains ( arr [ i ] ) ) { fibcount ++ ; } else fibcount = 0 ; } for ( int i = 0 ; i < n ; i ++ ) res = Math . Max ( res , left [ i ] + right [ i ] ) ; return res ; }
bool isPrime ( int N ) { if ( N < 2 ) return false ; if ( N < 4 ) return true ; if ( ( N & 1 ) == 0 ) return false ; if ( N % 3 == 0 ) return false ; int curr = 5 , s = ( int ) Math . Sqrt ( N ) ; while ( curr <= s ) { if ( N % curr == 0 ) return false ; curr += 2 ; if ( N % curr == 0 ) return false ; curr += 4 ; } return true ; }
bool check ( int s , int p , int [ ] prefix_sum , int n ) { bool satisfies = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( i + s - 1 >= n ) break ; if ( prefix_sum [ i + s - 1 ] - ( i - 1 >= 0 ? prefix_sum [ i - 1 ] : 0 ) < p ) satisfies = false ; } return satisfies ; }
int minimumWindowSize ( int x , int y , int p ) { int [ ] prefix_sum = new int [ y - x + 1 ] ; for ( int i = x ; i <= y ; i ++ ) { if ( isPrime ( i ) ) prefix_sum [ i - x ] = 1 ; } for ( int i = 1 ; i < y - x + 1 ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] ; int low = 1 , high = y - x + 1 ; int mid ; while ( high - low > 1 ) { mid = ( low + high ) / 2 ; if ( check ( mid , p , prefix_sum , y - x + 1 ) ) { high = mid ; } else low = mid ; } if ( check ( low , p , prefix_sum , y - x + 1 ) ) return low ; return high ; }
void preProcess ( int [ , ] mat , int [ , ] aux ) { for ( int i = 0 ; i < M ; i ++ ) aux [ 0 , i ] = mat [ 0 , i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) aux [ i , j ] = mat [ i , j ] + aux [ i - 1 , j ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 1 ; j < M ; j ++ ) aux [ i , j ] += aux [ i , j - 1 ] ; }
int sumQuery ( int [ , ] aux , int tli , int tlj , int rbi , int rbj ) { int res = aux [ rbi , rbj ] ; if ( tli > 0 ) res = res - aux [ tli - 1 , rbj ] ; if ( tlj > 0 ) res = res - aux [ rbi , tlj - 1 ] ; if ( tli > 0 && tlj > 0 ) res = res + aux [ tli - 1 , tlj - 1 ] ; return res ; }
int maximumSquareSize ( int [ , ] mat , int K ) { int [ , ] aux = new int [ N , M ] ; preProcess ( mat , aux ) ; for ( int i = Math . Min ( N , M ) ; i >= 1 ; i -- ) { bool satisfies = true ; for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < M ; y ++ ) { if ( x + i - 1 <= N - 1 && y + i - 1 <= M - 1 ) { if ( sumQuery ( aux , x , y , x + i - 1 , y + i - 1 ) > K ) satisfies = false ; } } } if ( satisfies == true ) return ( i ) ; } return 0 ; }
void preProcess ( int [ , ] mat , int [ , ] aux ) { for ( int i = 0 ; i < M ; i ++ ) aux [ 0 , i ] = mat [ 0 , i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) aux [ i , j ] = mat [ i , j ] + aux [ i - 1 , j ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 1 ; j < M ; j ++ ) aux [ i , j ] += aux [ i , j - 1 ] ; }
int sumQuery ( int [ , ] aux , int tli , int tlj , int rbi , int rbj ) { int res = aux [ rbi , rbj ] ; if ( tli > 0 ) res = res - aux [ tli - 1 , rbj ] ; if ( tlj > 0 ) res = res - aux [ rbi , tlj - 1 ] ; if ( tli > 0 && tlj > 0 ) res = res + aux [ tli - 1 , tlj - 1 ] ; return res ; }
bool check ( int mid , int [ , ] aux , int K ) { bool satisfies = true ; for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < M ; y ++ ) { if ( x + mid - 1 <= N - 1 && y + mid - 1 <= M - 1 ) { if ( sumQuery ( aux , x , y , x + mid - 1 , y + mid - 1 ) > K ) satisfies = false ; } } } return ( satisfies == true ) ; }
int maximumSquareSize ( int [ , ] mat , int K ) { int [ , ] aux = new int [ N , M ] ; preProcess ( mat , aux ) ; int low = 1 , high = Math . Min ( N , M ) ; int mid ; while ( high - low > 1 ) { mid = ( low + high ) / 2 ; if ( check ( mid , aux , K ) ) { low = mid ; } else high = mid ; } if ( check ( high , aux , K ) ) return high ; return low ; }
void createHash ( HashSet < int > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . Add ( prev ) ; hash . Add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . Add ( temp ) ; prev = curr ; curr = temp ; } }
void add_factors ( int n , Dictionary < int , int > mp ) { for ( int i = 1 ; i <= ( Math . Sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( mp . ContainsKey ( i ) ) mp [ i ] = mp [ i ] + 1 ; else mp . Add ( i , 1 ) ; } else { if ( mp . ContainsKey ( i ) ) mp [ i ] = mp [ i ] + 1 ; else mp . Add ( i , 1 ) ; if ( mp . ContainsKey ( n / i ) ) mp [ n / i ] = mp [ n / i ] + 1 ; else mp . Add ( n / i , 1 ) ; } } } }
void removeDuplicates ( int [ ] arr , int n ) { int st = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 2 && arr [ i ] == arr [ i + 1 ] && arr [ i ] == arr [ i + 2 ] ) continue ; else { arr [ st ] = arr [ i ] ; st ++ ; } } Console . Write ( "{" ) ; for ( int i = 0 ; i < st ; i ++ ) { Console . Write ( arr [ i ] ) ; if ( i != st - 1 ) Console . Write ( ", " ) ; } Console . Write ( "}" ) ; }
bool permutation ( int [ ] arr , int n ) { HashSet < int > hash = new HashSet < int > ( ) ; int maxEle = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hash . Add ( arr [ i ] ) ; maxEle = Math . Max ( maxEle , arr [ i ] ) ; } if ( maxEle != n ) return false ; if ( hash . Count == n ) return true ; return false ; }
int findPivot ( int [ ] arr , int low , int high ) { if ( high < low ) return - 1 ; if ( high == low ) return low ; int mid = ( low + high ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) { return mid ; } if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) { return mid - 1 ; } if ( arr [ low ] > arr [ mid ] ) { return findPivot ( arr , low , mid - 1 ) ; } else { return findPivot ( arr , mid + 1 , high ) ; } }
bool isRotated ( int [ ] arr , int n ) { int l = 0 ; int r = n - 1 ; int pivot = - 1 ; if ( arr [ l ] > arr [ r ] ) { pivot = findPivot ( arr , l , r ) ; int temp = pivot ; if ( l < pivot ) { while ( pivot > l ) { if ( arr [ pivot ] < arr [ pivot - 1 ] ) { return false ; } pivot -- ; } } pivot = temp ; else { pivot ++ ; while ( pivot < r ) { if ( arr [ pivot ] > arr [ pivot + 1 ] ) { return false ; } pivot ++ ; } } return true ; } else { return false ; } }
void state1 ( char c ) { if ( c == 'a' ) nfa = 2 ; else if ( c == 'b' c == 'c' ) nfa = 1 ; else flag = 1 ; }
void state2 ( char c ) { if ( c == 'a' ) nfa = 3 ; else if ( c == 'b' c == 'c' ) nfa = 2 ; else flag = 1 ; }
void state3 ( char c ) { if ( c == 'a' ) nfa = 1 ; else if ( c == 'b' c == 'c' ) nfa = 3 ; else flag = 1 ; }
void state4 ( char c ) { if ( c == 'b' ) nfa = 5 ; else if ( c == 'a' c == 'c' ) nfa = 4 ; else flag = 1 ; }
void state5 ( char c ) { if ( c == 'b' ) nfa = 6 ; else if ( c == 'a' c == 'c' ) nfa = 5 ; else flag = 1 ; }
void state6 ( char c ) { if ( c == 'b' ) nfa = 4 ; else if ( c == 'a' c == 'c' ) nfa = 6 ; else flag = 1 ; }
void state7 ( char c ) { if ( c == 'c' ) nfa = 8 ; else if ( c == 'b' c == 'a' ) nfa = 7 ; else flag = 1 ; }
void state9 ( char c ) { if ( c == 'c' ) nfa = 7 ; else if ( c == 'b' c == 'a' ) nfa = 9 ; else flag = 1 ; }
bool checkA ( String s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 1 ) state1 ( s [ i ] ) ; else if ( nfa == 2 ) state2 ( s [ i ] ) ; else if ( nfa == 3 ) state3 ( s [ i ] ) ; } if ( nfa == 1 ) { return true ; } else { nfa = 4 ; } return false ; }
bool checkB ( String s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 4 ) state4 ( s [ i ] ) ; else if ( nfa == 5 ) state5 ( s [ i ] ) ; else if ( nfa == 6 ) state6 ( s [ i ] ) ; } if ( nfa == 4 ) { return true ; } else { nfa = 7 ; } return false ; }
bool checkC ( String s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 7 ) state7 ( s [ i ] ) ; else if ( nfa == 8 ) state8 ( s [ i ] ) ; else if ( nfa == 9 ) state9 ( s [ i ] ) ; } if ( nfa == 7 ) { return true ; } return false ; }
int getPositionCount ( int [ ] a , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; }
int CountSubSet ( int [ ] arr , int n , int X ) { int N = ( int ) Math . Pow ( 2 , n ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) if ( arr [ j ] == X ) count += 1 ; } } return count ; }
int calculatePower ( int b , int e ) { int ans = 1 ; while ( e > 0 ) { if ( e % 2 == 1 ) ans = ans * b ; e = e / 2 ; b = b * b ; } return ans ; }
int CountSubSet ( int [ ] arr , int n , int X ) { int count = 0 , checkX = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == X ) { checkX = 1 ; break ; } } if ( checkX == 1 ) count = calculatePower ( 2 , n - 1 ) ; else count = 0 ; return count ; }
int build ( int [ ] A , int start , int end , int node ) { if ( start == end ) segment_tree [ node ] = A [ start ] ; else { int mid = ( start + end ) / 2 ; segment_tree [ node ] = Math . Max ( build ( A , start , mid , 2 * node + 1 ) , build ( A , mid + 1 , end , 2 * node + 2 ) ) ; } return segment_tree [ node ] ; }
int query ( int start , int end , int l , int r , int node ) { if ( start > r end < l ) return - 1 ; if ( start >= l && end <= r ) return segment_tree [ node ] ; int mid = ( start + end ) / 2 ; return Math . Max ( query ( start , mid , l , r , 2 * node + 1 ) , query ( mid + 1 , end , l , r , 2 * node + 2 ) ) ; }
int longestSubArray ( int [ ] A , int N , int K ) { int res = 1 ; int [ ] preSum = new int [ N + 1 ] ; preSum [ 0 ] = A [ 0 ] ; for ( int i = 0 ; i < N ; i ++ ) preSum [ i + 1 ] = preSum [ i ] + A [ i ] ; build ( A , 0 , N - 1 , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { int start = i , end = N - 1 , mid , max_index = i ; while ( start <= end ) { mid = ( start + end ) / 2 ; int max_element = query ( 0 , N - 1 , i , mid , 0 ) ; int expected_sum = ( mid - i + 1 ) * max_element ; int actual_sum = preSum [ mid + 1 ] - preSum [ i ] ; if ( expected_sum - actual_sum <= K ) { start = mid + 1 ; max_index = Math . Max ( max_index , mid ) ; } else { end = mid - 1 ; } } res = Math . Max ( res , max_index - i + 1 ) ; } return res ; }
int solve ( int [ ] arr , int n , int k ) { int max_len = 0 , l = 0 , r = n , m ; while ( l <= r ) { m = ( l + r ) / 2 ; if ( maxSum ( arr , n , m ) > k ) r = m - 1 ; else { l = m + 1 ; max_len = m ; } } return max_len ; }
int countNums ( int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { int lastDigit = ( i % 10 ) ; if ( ( lastDigit % 10 ) == 2 || ( lastDigit % 10 ) == 3 || ( lastDigit % 10 ) == 9 ) { cnt ++ ; } } return cnt ; }
int findMinimumK ( int [ ] a , int n , int s ) { int maximum = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { maximum = Math . Max ( maximum , a [ i ] ) ; } int low = 1 , high = maximum + 1 ; int ans = high ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ( int ) ( a [ i ] / mid ) ; } if ( sum > s ) low = mid + 1 ; else { ans = Math . Min ( ans , mid ) ; high = mid - 1 ; } } return ans ; }
bool allDigits ( String str , int len ) { bool [ ] present = new bool [ MAX ] ; for ( int i = 0 ; i < len ; i ++ ) { if ( isDigit ( str [ i ] ) ) { int digit = str [ i ] - '0' ; present [ digit ] = true ; } } for ( int i = 0 ; i < MAX ; i ++ ) { if ( ! present [ i ] ) return false ; } return true ; }
bool isPlusPossible ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } bool foundModOne = false ; foreach ( KeyValuePair < int , int > x in mp ) { int element = x . Key ; int frequency = x . Value ; if ( frequency % 4 == 0 ) continue ; if ( frequency % 4 == 1 ) { if ( foundModOne ) return false ; foundModOne = true ; } else return false ; } return true ; }
List < int > merge ( List < int > v1 , List < int > v2 ) { int i = 0 , j = 0 ; List < int > v = new List < int > ( ) ; while ( i < v1 . Count && j < v2 . Count ) { if ( v1 [ i ] <= v2 [ j ] ) { v . Add ( v1 [ i ] ) ; i ++ ; } else { v . Add ( v2 [ j ] ) ; j ++ ; } } for ( int k = i ; k < v1 . Count ; k ++ ) v . Add ( v1 [ k ] ) ; for ( int k = j ; k < v2 . Count ; k ++ ) v . Add ( v2 [ k ] ) ; return v ; }
void buildTree ( List < int > [ ] tree , int [ ] arr , int index , int s , int e ) { if ( s == e ) { tree [ index ] . Add ( arr [ s ] ) ; return ; } int mid = ( s + e ) / 2 ; buildTree ( tree , arr , 2 * index , s , mid ) ; buildTree ( tree , arr , 2 * index + 1 , mid + 1 , e ) ; tree [ index ] = merge ( tree [ 2 * index ] , tree [ 2 * index + 1 ] ) ; }
int query ( List < int > [ ] tree , int index , int s , int e , int l , int r , int k ) { if ( r < s l > e ) return 0 ; if ( s >= l && e <= r ) { return ( tree [ index ] . Count - lowerBound ( tree [ index ] , tree [ index ] . Count , k ) ) ; } int mid = ( s + e ) / 2 ; return ( query ( tree , 2 * index , s , mid , l , r , k ) + query ( tree , 2 * index + 1 , mid + 1 , e , l , r , k ) ) ; }
int findGCDSum ( int n , int [ ] a ) { int GCDSum = 0 ; int tempGCD = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { tempGCD = 0 ; for ( int k = i ; k <= j ; k ++ ) { tempGCD = __gcd ( tempGCD , a [ k ] ) ; } GCDSum += tempGCD ; } } return GCDSum ; }
void buildSparseTable ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) { SparseTable [ i , 0 ] = a [ i ] ; } for ( int j = 1 ; j <= 19 ; j ++ ) { for ( int i = 0 ; i <= n - ( 1 << j ) ; i ++ ) { SparseTable [ i , j ] = __gcd ( SparseTable [ i , j - 1 ] , SparseTable [ i + ( 1 << ( j - 1 ) ) , j - 1 ] ) ; } } }
int queryForGCD ( int L , int R ) { int returnValue ; int j = ( int ) ( Math . Log ( R - L + 1 ) ) ; returnValue = __gcd ( SparseTable [ L , j ] , SparseTable [ R - ( 1 << j ) + 1 , j ] ) ; return returnValue ; }
int calculateSum ( int [ ] a , int n ) { buildSparseTable ( a , n ) ; int endPointer , startPointer , prevEndPointer , tempGCD ; int tempAns = 0 ; for ( int i = 0 ; i < n ; i ++ ) { endPointer = i ; startPointer = i ; prevEndPointer = i ; tempGCD = a [ i ] ; while ( endPointer < n ) { endPointer = nextPosition ( tempGCD , startPointer , prevEndPointer , n ) ; tempAns += ( ( endPointer - prevEndPointer ) * tempGCD ) ; prevEndPointer = endPointer ; if ( endPointer < n ) { tempGCD = __gcd ( tempGCD , a [ endPointer ] ) ; } } } return tempAns ; }
bool isSquarePossible ( int [ ] arr , int n , int l ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= l ) cnt ++ ; if ( cnt >= l ) return true ; } return false ; }
int maxArea ( int [ ] arr , int n ) { int l = 0 , r = n ; int len = 0 ; while ( l <= r ) { int m = l + ( ( r - l ) / 2 ) ; if ( isSquarePossible ( arr , n , m ) ) { len = m ; l = m + 1 ; } else r = m - 1 ; } return ( len * len ) ; }
int find_triplet ( int [ ] array , int n ) { int answer = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { indices [ i ] = new List < int > ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { indices [ array [ i ] ] . Add ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { int y = array [ i ] ; for ( int j = 0 ; j < ROW ; j ++ ) { int s = test [ j , 1 ] * y ; if ( s % test [ j , 0 ] != 0 ) continue ; if ( s % test [ j , 2 ] != 0 ) continue ; int x = s / test [ j , 0 ] ; int z = s / test [ j , 2 ] ; if ( x > MAX z > MAX ) continue ; int l = 0 ; int r = indices [ x ] . Count - 1 ; int first = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ x ] [ m ] < i ) { first = m ; l = m + 1 ; } else { r = m - 1 ; } } l = 0 ; r = indices [ z ] . Count - 1 ; int third = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ z ] [ m ] > i ) { third = m ; r = m - 1 ; } else { l = m + 1 ; } } if ( first != - 1 && third != - 1 ) { answer += ( first + 1 ) * ( indices [ z ] . Count - third ) ; } } } return answer ; }
int lcm ( int A , int B ) { return ( A * B ) / gcd ( A , B ) ; }
int checkA ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = A * mid ; int divA = mid - 1 ; int divB = ( value % B == 0 ) ? value / B - 1 : value / B ; int divC = ( value % C == 0 ) ? value / C - 1 : value / C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; }
int checkB ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = B * mid ; int divB = mid - 1 ; int divA = ( value % A == 0 ) ? value / A - 1 : value / A ; int divC = ( value % C == 0 ) ? value / C - 1 : value / C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; }
int checkC ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = C * mid ; int divC = mid - 1 ; int divB = ( value % B == 0 ) ? value / B - 1 : value / B ; int divA = ( value % A == 0 ) ? value / A - 1 : value / A ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; }
int findKthMultiple ( int A , int B , int C , int K ) { int res = checkA ( A , B , C , K ) ; if ( res == - 1 ) res = checkB ( A , B , C , K ) ; if ( res == - 1 ) res = checkC ( A , B , C , K ) ; return res ; }
int kthSmallest ( int [ ] a , int left , int right , int k ) { while ( left <= right ) { int pivotIndex = partition ( a , left , right ) ; if ( pivotIndex == k - 1 ) return a [ pivotIndex ] ; else if ( pivotIndex > k - 1 ) right = pivotIndex - 1 ; else left = pivotIndex + 1 ; } return - 1 ; }
int calculateDifference ( int [ ] arr , int n ) { int max_val = max_element ( arr ) ; bool [ ] prime = new bool [ max_val + 1 ] ; for ( int index = 0 ; index < max_val + 1 ; index ++ ) prime [ index ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int x1 = 1 , x2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) x1 ^= arr [ i ] ; else if ( arr [ i ] != 1 ) x2 ^= arr [ i ] ; } return Math . Abs ( x1 - x2 ) ; }
bool containsElement ( int [ ] arr , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; ++ i ) xorArr ^= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { int x = xorArr ^ arr [ i ] ; if ( arr [ i ] == x ) return true ; } return false ; }
double Square ( double n , double i , double j ) { double mid = ( i + j ) / 2 ; double mul = mid * mid ; if ( ( mul == n ) || ( Math . Abs ( mul - n ) < 0.00001 ) ) return mid ; else if ( mul < n ) return Square ( n , mid , j ) ; else return Square ( n , i , mid ) ; }
int length_substring ( string S , char K ) { int curr_cnt = 0 , prev_cnt = 0 , max_len ; for ( int i = 0 ; i < S . Length ; i ++ ) { if ( S [ i ] == K ) { curr_cnt += 1 ; } else { prev_cnt = Math . Max ( prev_cnt , curr_cnt ) ; curr_cnt = 0 ; } } prev_cnt = Math . Max ( prev_cnt , curr_cnt ) ; max_len = prev_cnt ; return max_len ; }
int Xor_Sum ( int [ ] arr , int n ) { int sum = 0 , index = - 1 ; int left_xor = 0 , right_xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { left_xor = left_xor ^ arr [ i ] ; right_xor = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { right_xor = right_xor ^ arr [ j ] ; } if ( left_xor + right_xor > sum ) { sum = left_xor + right_xor ; index = i ; } } return index + 1 ; }
void ComputePrefixXor ( int [ ] arr , int [ ] PrefixXor , int n ) { PrefixXor [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) PrefixXor [ i ] = PrefixXor [ i - 1 ] ^ arr [ i ] ; }
int Xor_Sum ( int [ ] arr , int n ) { int [ ] PrefixXor = new int [ n ] ; ComputePrefixXor ( arr , PrefixXor , n ) ; int sum = 0 , index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( PrefixXor [ i ] + ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) > sum ) { sum = PrefixXor [ i ] + ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) ; index = i ; } } return index + 1 ; }
Dictionary < int , int > buildMapWithColor ( int [ ] arr , int n ) { Dictionary < int , int > mapWithColor = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mapWithColor . ContainsKey ( arr [ i ] ) ) mapWithColor [ arr [ i ] ] = i + 1 ; else mapWithColor . Add ( arr [ i ] , i + 1 ) ; } return mapWithColor ; }
bool isPalindrome ( string str , int i , int j ) { while ( i < j ) { if ( str [ i ] != str [ j ] ) { return false ; } i ++ ; j -- ; } return true ; }
int maxLenPalindrome ( string str , int n , char ch ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ch ) { for ( int j = n - 1 ; j >= i ; j -- ) { if ( str [ j ] == ch ) { if ( isPalindrome ( str , i , j ) ) { maxLen = Math . Max ( maxLen , j - i + 1 ) ; break ; } } } } } return maxLen ; }
List < int > findCount ( String [ ] a , String [ ] b , int n , int m ) { int [ ] freq = new int [ MAX ] ; List < int > smallestFreq = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = a [ i ] ; for ( int l = 0 ; l < freq . Length ; l ++ ) freq [ l ] = 0 ; for ( int j = 0 ; j < s . Length ; j ++ ) { freq [ s [ j ] - 'a' ] ++ ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] > 0 ) { smallestFreq . Add ( freq [ j ] ) ; break ; } } } smallestFreq . Sort ( ) ; List < int > ans = new List < int > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { String s = b [ i ] ; for ( int l = 0 ; l < freq . Length ; l ++ ) freq [ l ] = 0 ; for ( int j = 0 ; j < s . Length ; j ++ ) { freq [ s [ j ] - 'a' ] ++ ; } int frequency = 0 ; for ( int j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] > 0 ) { frequency = freq [ j ] ; break ; } } int [ ] array = new int [ smallestFreq . Count ] ; int k = 0 ; foreach ( int val in smallestFreq ) { array [ k ] = val ; k ++ ; } int ind = lower_bound ( array , 0 , smallestFreq . Count , frequency ) ; ans . Add ( ind ) ; } return ans ; }
void printAnswer ( String [ ] a , String [ ] b , int n , int m ) { List < int > ans = findCount ( a , b , n , m ) ; foreach ( int it in ans ) { Console . Write ( it + " " ) ; } }
int linearCheck ( int [ , ] ar , int [ ] arr ) { for ( int i = 0 ; i < m ; i ++ ) { bool matched = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( ar [ i , j ] != arr [ j ] ) { matched = false ; break ; } } if ( matched ) return i + 1 ; } return - 1 ; }
int compareRow ( int [ ] a1 , int [ ] a2 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a1 [ i ] < a2 [ i ] ) return 1 ; else if ( a1 [ i ] > a2 [ i ] ) return - 1 ; } return 0 ; }
int binaryCheck ( int [ , ] ar , int [ ] arr ) { int l = 0 , r = m - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int temp = compareRow ( GetRow ( ar , mid ) , arr ) ; if ( temp == 0 ) return mid + 1 ; else if ( temp == 1 ) l = mid + 1 ; else r = mid - 1 ; } return - 1 ; }
int findCnt ( int [ ] arr , int n , int k ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; if ( arr [ i ] > k arr [ i ] < - 1 * k ) ans ++ ; } if ( arr [ 0 ] > k arr [ 0 ] < - 1 * k ) ans ++ ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) ans += n - upper_bound ( arr , 0 , n , arr [ i ] + k ) ; return ans ; }
int FindIntersection ( List < List < int > > type1 , int n , List < List < int > > type2 , int m ) { int ans = n * m ; List < int > start = new List < int > ( ) ; List < int > end = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { start . Add ( type1 [ i ] [ 0 ] ) ; end . Add ( type1 [ i ] [ 1 ] ) ; } start . Sort ( ) ; end . Sort ( ) ; for ( int i = 0 ; i < m ; i ++ ) { int L = type2 [ i ] [ 0 ] ; int R = type2 [ i ] [ 1 ] ; ans -= start . Count - upperBound ( start , 0 , start . Count , R ) ; ans -= upperBound ( end , 0 , end . Count , L - 1 ) ; } return ans ; }
int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; }
int divTermCount ( int a , int b , int c , int num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / lcm ( a , b ) ) - ( num / lcm ( b , c ) ) - ( num / lcm ( a , c ) ) + ( num / lcm ( a , lcm ( b , c ) ) ) ) ; }
int findNthTerm ( int a , int b , int c , int n ) { int low = 1 , high = int . MaxValue , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , c , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; }
void setZero ( int [ ] freq ) { for ( int i = 0 ; i < MAX ; i ++ ) freq [ i ] = 0 ; }
void preCalculate ( string str , int n ) { freq [ ( int ) str [ 0 ] , 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { char ch = str [ i ] ; for ( int j = 0 ; j < MAX ; j ++ ) { char charToUpdate = ( char ) j ; if ( charToUpdate == ch ) freq [ j , i ] = freq [ j , i - 1 ] + 1 ; else freq [ j , i ] = freq [ j , i - 1 ] ; } } }
int getFrequency ( char ch , int l , int r ) { if ( l == 0 ) return freq [ ( int ) ch , r ] ; else return ( freq [ ( int ) ch , r ] - freq [ ( int ) ch , l - 1 ] ) ; }
string firstNonRepeating ( string str , int n , int l , int r ) { for ( int i = l ; i < r ; i ++ ) { char ch = str [ i ] ; if ( getFrequency ( ch , l , r ) == 1 ) return ( "" + ch ) ; } return "-1" ; }
int maxLength ( String s , int n ) { int ans = int . MinValue ; List < int > A = new List < int > ( ) ; List < int > L = new List < int > ( ) ; List < int > R = new List < int > ( ) ; int [ ] freq = new int [ n + 5 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( s [ j ] - 'a' == i ) count ++ ; freq [ j ] = count ; } for ( int j = 1 ; j < n ; j ++ ) { L . Add ( ( 2 * freq [ j - 1 ] ) - j ) ; R . Add ( ( 2 * freq [ j ] ) - j ) ; } int max_len = int . MinValue ; int min_val = int . MaxValue ; for ( int j = 0 ; j < L . Count ; j ++ ) { min_val = Math . Min ( min_val , L [ j ] ) ; A . Add ( min_val ) ; int l = 0 , r = j ; while ( l <= r ) { int mid = ( l + r ) >> 1 ; if ( A [ mid ] <= R [ j ] ) { max_len = Math . Max ( max_len , j - mid + 1 ) ; r = mid - 1 ; } else { l = mid + 1 ; } } } ans = Math . Max ( ans , max_len ) ; A . Clear ( ) ; R . Clear ( ) ; L . Clear ( ) ; } return ans ; }
int minOperations ( int [ ] arr , int n ) { int start = ( int ) arr [ n - 1 ] ; int end = arr . Max ( ) + n ; int max_arr = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( check ( mid , n , arr ) ) { max_arr = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } int [ ] desired = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { desired [ i ] = max_arr ; max_arr -- ; } int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { operations += ( desired [ i ] - arr [ i ] ) ; } return operations ; }
int countNode ( Node head ) { int count = 0 ; while ( head . next != null ) { Node ptr = head . next ; while ( ptr != null ) { if ( head . data == ptr . data ) { count ++ ; break ; } ptr = ptr . next ; } head = head . next ; } return count ; }
void insert ( Node ref_head , int item ) { Node temp = new Node ( ) ; temp . data = item ; temp . next = ref_head ; head = temp ; }
int countNode ( Node head ) { if ( head == null ) return 0 ; ; HashSet < int > s = new HashSet < int > ( ) ; s . Add ( head . data ) ; int count = 0 ; for ( Node curr = head . next ; curr != null ; curr = curr . next ) { if ( s . Contains ( curr . data ) ) count ++ ; s . Add ( curr . data ) ; } return count ; }
int countLessThan ( int [ ] arr , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < key ) { l = m + 1 ; index = m ; } else { r = m - 1 ; } } return ( index + 1 ) ; }
int countGreaterThan ( int [ ] arr , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] <= key ) { l = m + 1 ; } else { r = m - 1 ; index = m ; } } if ( index == - 1 ) return 0 ; return ( n - index ) ; }
int countTriplets ( int n , int [ ] a , int [ ] b , int [ ] c ) { Array . Sort ( a ) ; Array . Sort ( b ) ; Array . Sort ( c ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int current = b [ i ] ; int low = countLessThan ( a , n , current ) ; int high = countGreaterThan ( c , n , current ) ; count += ( low * high ) ; } return count ; }
int maximum_middle_value ( int n , int k , int [ ] arr ) { int ans = - 1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = Math . Max ( ans , arr [ i - 1 ] ) ; } return ans ; }
int firstRepeating ( String str ) { Boolean [ ] visited = new Boolean [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) visited [ i ] = false ; int res = - 1 ; for ( int i = str . Length - 1 ; i >= 0 ; i -- ) { if ( visited [ str [ i ] ] == false ) visited [ str [ i ] ] = true ; else res = i ; } return res ; }
int minSteps ( int [ , ] arr ) { Boolean [ , ] v = new Boolean [ n , n ] ; Queue < Pair > q = new Queue < Pair > ( ) ; q . Enqueue ( new Pair ( 0 , 0 ) ) ; int depth = 0 ; while ( q . Count != 0 ) { int x = q . Count ; while ( x -- > 0 ) { Pair y = q . Peek ( ) ; int i = y . first , j = y . second ; q . Dequeue ( ) ; if ( v [ i , j ] ) continue ; if ( i == n - 1 && j == n - 1 ) return depth ; v [ i , j ] = true ; if ( i + arr [ i , j ] < n ) q . Enqueue ( new Pair ( i + arr [ i , j ] , j ) ) ; if ( j + arr [ i , j ] < n ) q . Enqueue ( new Pair ( i , j + arr [ i , j ] ) ) ; } depth ++ ; } return - 1 ; }
int minSteps ( int [ ] arr , int n ) { Boolean [ ] v = new Boolean [ n ] ; Queue < int > q = new Queue < int > ( ) ; q . Enqueue ( 0 ) ; int depth = 0 ; while ( q . Count > 0 ) { int x = q . Count ; while ( x -- > 0 ) { int i = q . Peek ( ) ; q . Dequeue ( ) ; if ( v [ i ] ) continue ; if ( i == n - 1 ) return depth ; v [ i ] = true ; if ( i + arr [ i ] < n ) q . Enqueue ( i + arr [ i ] ) ; if ( i - arr [ i ] >= 0 ) q . Enqueue ( i - arr [ i ] ) ; } depth ++ ; } return - 1 ; }
int divisorcount ( int elem ) { int ans = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( elem ) ; i ++ ) { if ( elem % i == 0 ) { if ( i * i == elem ) ans ++ ; else ans += 2 ; } } return ans ; }
string findwinner ( int [ ] A , int [ ] B , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = divisorcount ( A [ i ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { B [ i ] = divisorcount ( B [ i ] ) ; } Array . Sort ( A ) ; Array . Sort ( B ) ; int winA = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int val = A [ i ] ; int start = 0 ; int end = M - 1 ; int index = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( B [ mid ] <= val ) { index = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } winA += ( index + 1 ) ; } int winB = N * M - winA ; if ( winA > winB ) { return "A" ; } else if ( winB > winA ) { return "B" ; } return "Draw" ; }
int minTime ( int [ ] box , int [ ] truck , int n , int m ) { Array . Sort ( box ) ; Array . Sort ( truck ) ; int l = 0 ; int h = 2 * n ; int min_time = 0 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( isPossible ( box , truck , n , m , mid ) ) { min_time = mid ; h = mid - 1 ; } else l = mid + 1 ; } return min_time ; }
bool isPossible ( int [ ] arr , int n , int dist , int k ) { int req = 0 ; int curr = 0 ; int prev = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( curr != n && arr [ curr ] - arr [ prev ] <= dist ) { curr ++ ; } req ++ ; if ( curr == n ) { break ; } prev = curr - 1 ; } if ( curr != n ) { return false ; } if ( req <= k ) { return true ; } return false ; }
int minDistance ( int [ ] arr , int n , int k ) { int l = 0 ; int h = arr [ n - 1 ] ; int ans = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( isPossible ( arr , n , m , k ) ) { ans = m ; h = m - 1 ; } else { l = m + 1 ; } } return ans ; }
int getKthElement ( int n , int k , int [ ] L , int [ ] R ) { int l = 1 ; int h = n ; int [ ] total = new int [ n + 1 ] ; total [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total [ i + 1 ] = total [ i ] + ( R [ i ] - L [ i ] ) + 1 ; } int index = - 1 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( total [ m ] > k ) { index = m ; h = m - 1 ; } else if ( total [ m ] < k ) l = m + 1 ; else { index = m ; break ; } } l = L [ index - 1 ] ; h = R [ index - 1 ] ; int x = k - total [ index - 1 ] ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( m - L [ index - 1 ] ) + 1 == x ) { return m ; } else if ( ( m - L [ index - 1 ] ) + 1 > x ) h = m - 1 ; else l = m + 1 ; } return k ; }
int MinimumX ( int a , int b , int c , int k ) { int x = int . MaxValue ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . Min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }
void preCalculate ( int [ ] binary , int n , pair [ ] left ) { int count1 = 0 , count0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] . first = count1 ; left [ i ] . second = count0 ; if ( binary [ i ] != 0 ) count1 ++ ; else count0 ++ ; } }
int findMissing ( int [ ] arr , int n ) { int l = 0 , h = n - 1 ; int mid ; while ( h > l ) { mid = l + ( h - l ) / 2 ; if ( arr [ mid ] - mid == arr [ 0 ] ) { if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) return arr [ mid ] + 1 ; else { l = mid + 1 ; } } else { if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) return arr [ mid ] - 1 ; else { h = mid - 1 ; } } } return - 1 ; }
int maxSum ( int [ ] arr , int n , int K ) { int maximum = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { int sumk = 0 ; for ( int j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = Math . Max ( maximum , sumk ) ; } return maximum ; }
int operations ( int [ ] op , int n , int k ) { int i , count = 0 ; int nVal = 0 ; int min = int . MaxValue ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; min = Math . Min ( min , nVal ) ; if ( ( k + nVal ) <= 0 ) return ( i + 1 ) ; } if ( nVal >= 0 ) return - 1 ; int times = ( k - Math . Abs ( min ) ) / Math . Abs ( nVal ) ; k = ( k - ( times * Math . Abs ( nVal ) ) ) ; count = ( times * n ) ; while ( k > 0 ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( k <= 0 ) break ; } } return count ; }
int findMax ( int [ ] arr , int low , int high ) { if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid == 0 && arr [ mid ] > arr [ mid + 1 ] ) return arr [ mid ] ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] && mid > 0 && arr [ mid ] > arr [ mid - 1 ] ) { return arr [ mid ] ; } if ( arr [ low ] > arr [ mid ] ) { return findMax ( arr , low , mid - 1 ) ; } else { return findMax ( arr , mid + 1 , high ) ; } }
void cal_prefix ( int n , int [ ] arr ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) ar [ i + 1 ] = arr [ i ] ; for ( i = 1 ; i <= 1000 ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) prefix [ i , j ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { prefix [ i , j ] = prefix [ i , j - 1 ] + ( int ) ( ar [ j ] <= i ? 1 : 0 ) ; } } }
int ksub ( int l , int r , int n , int k ) { int lo , hi , mid ; lo = 1 ; hi = 1000 ; while ( lo + 1 < hi ) { mid = ( lo + hi ) / 2 ; if ( prefix [ mid , r ] - prefix [ mid , l - 1 ] >= k ) hi = mid ; else lo = mid + 1 ; } if ( prefix [ lo , r ] - prefix [ lo , l - 1 ] >= k ) hi = lo ; return hi ; }
int binary ( int [ ] arr , int v ) { int index = lookup_table [ 0 ] - 1 ; int co = 0 ; while ( lookup_table [ co ] != 0 ) { if ( v == arr [ index ] ) return index ; else if ( v < arr [ index ] ) { index -= lookup_table [ ++ co ] ; return index ; } else { index += lookup_table [ ++ co ] ; return index ; } } return index ; }
int countPairs ( string s1 , int n1 , string s2 , int n2 ) { int [ ] freq1 = new int [ 26 ] ; int [ ] freq2 = new int [ 26 ] ; Array . Fill ( freq1 , 0 ) ; Array . Fill ( freq2 , 0 ) ; int i , count = 0 ; for ( i = 0 ; i < n1 ; i ++ ) freq1 [ s1 [ i ] - 'a' ] ++ ; for ( i = 0 ; i < n2 ; i ++ ) freq2 [ s2 [ i ] - 'a' ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) count += ( Math . Min ( freq1 [ i ] , freq2 [ i ] ) ) ; return count ; }
int findSmallestX ( int Y ) { int low = 0 , high = 5 * Y ; int N = 0 ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( countFactor ( 5 , mid ) < Y ) { low = mid + 1 ; } else { N = mid ; high = mid - 1 ; } } return N ; }
void findpair ( int l , int r ) { int ans1 = l ; int ans2 = 2 * l ; Console . WriteLine ( ans1 + ", " + ans2 ) ; }
bool check ( int [ ] arr , int N , int K ) { HashSet < int > unique = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { unique . Add ( arr [ i ] ) ; } if ( unique . Count == K ) { return true ; } return false ; }
long squareSum ( long N ) { long sum = ( long ) ( N * ( N + 1 ) * ( 2 * N + 1 ) ) / 6 ; return sum ; }
long findMaxN ( long X ) { long N = ( long ) Math . Sqrt ( X ) ; for ( long i = 1 ; i <= N ; i ++ ) { if ( squareSum ( i ) > X ) return i - 1 ; } return - 1 ; }
long findMaxN ( long X ) { long low = 1 , high = 100000 ; int N = 0 ; while ( low <= high ) { long mid = ( high + low ) / 2 ; if ( squareSum ( mid ) <= X ) { N = ( int ) mid ; low = mid + 1 ; } else high = mid - 1 ; } return N ; }
int findNumber ( pair [ ] a , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) { if ( K >= a [ i ] . first && K <= a [ i ] . second ) return i ; } return - 1 ; }
int findNumber ( pair [ ] a , int n , int K ) { int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( K >= a [ mid ] . first && K <= a [ mid ] . second ) return mid ; else if ( K < a [ mid ] . first ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }
void prefixSum ( int [ ] p_arr , int [ ] arr , int n ) { p_arr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) p_arr [ i ] = arr [ i ] + p_arr [ i - 1 ] ; }
void canDivide ( int [ ] p_arr , int n , HashSet < int > q , int l , int r ) { int sum ; if ( l == 0 ) sum = p_arr [ r ] ; else sum = p_arr [ r ] - p_arr [ l - 1 ] ; if ( sum % 2 == 1 ) { Console . WriteLine ( "No" ) ; return ; } int beg = 0 ; if ( l != 0 ) beg = p_arr [ l - 1 ] ; if ( q . Contains ( beg + sum / 2 ) ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
int findRing ( int [ , ] arr , int x ) { if ( arr [ 0 , 0 ] > x ) return - 1 ; int l = 0 , r = ( n + 1 ) / 2 - 1 ; if ( n % 2 == 1 && arr [ r , r ] < x ) return - 1 ; if ( n % 2 == 0 && arr [ r + 1 , r ] < x ) return - 1 ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( arr [ mid , mid ] <= x ) if ( mid == ( n + 1 ) / 2 - 1 arr [ mid + 1 , mid + 1 ] > x ) return mid ; else l = mid + 1 ; else r = mid - 1 ; } return r ; }
int binarySearchRowInc ( int [ , ] arr , int row , int l , int r , int x ) { while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( arr [ row , mid ] == x ) return mid ; if ( arr [ row , mid ] < x ) l = mid + 1 ; else r = mid - 1 ; } return - 1 ; }
int binarySearchColumnInc ( int [ , ] arr , int col , int t , int b , int x ) { while ( t <= b ) { int mid = ( t + b ) / 2 ; if ( arr [ mid , col ] == x ) return mid ; if ( arr [ mid , col ] < x ) t = mid + 1 ; else b = mid - 1 ; } return - 1 ; }
int binarySearchRowDec ( int [ , ] arr , int row , int l , int r , int x ) { while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( arr [ row , mid ] == x ) return mid ; if ( arr [ row , mid ] < x ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; }
int binarySearchColumnDec ( int [ , ] arr , int col , int t , int b , int x ) { while ( t <= b ) { int mid = ( t + b ) / 2 ; if ( arr [ mid , col ] == x ) return mid ; if ( arr [ mid , col ] < x ) b = mid - 1 ; else t = mid + 1 ; } return - 1 ; }
int minIndex ( int [ ] arr , int n , int pos ) { int num = arr [ pos ] ; int i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; } return i + 1 ; }
int minIndex ( int [ ] arr , int pos ) { int low = 0 ; int high = pos ; int i = pos ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] != arr [ pos ] ) { low = mid + 1 ; } else { high = mid - 1 ; i = mid ; if ( mid > 0 && arr [ mid - 1 ] != arr [ pos ] ) { break ; } } } return arr [ low ] == arr [ pos ] ? low : i ; }
int findAnswer ( string str1 , string str2 , int n ) { int l = 0 , r = 0 ; int ans = 2 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str1 [ i ] != str2 [ i ] ) { l = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str1 [ i ] != str2 [ i ] ) { r = i ; break ; } } if ( r < l ) return 26 * ( n + 1 ) ; else if ( l == r ) return ans ; else { for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 [ i ] != str2 [ i - 1 ] ) { ans -- ; break ; } } for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 [ i - 1 ] != str2 [ i ] ) { ans -- ; break ; } } return ans ; } }
int ternarySearch ( int l , int r , int key , int [ ] ar ) { if ( r >= l ) { int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { return ternarySearch ( l , mid1 - 1 , key , ar ) ; } else if ( key > ar [ mid2 ] ) { return ternarySearch ( mid2 + 1 , r , key , ar ) ; } else { return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) ; } } return - 1 ; }
int ternarySearch ( int l , int r , int key , int [ ] ar ) { while ( r >= l ) { int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { r = mid1 - 1 ; } else if ( key > ar [ mid2 ] ) { l = mid2 + 1 ; } else { l = mid1 + 1 ; r = mid2 - 1 ; } } return - 1 ; }
int countSubArrays ( int [ ] arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }
void build ( int [ ] arr , int node , int start , int end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) >> 1 ; build ( arr , 2 * node , start , mid ) ; build ( arr , 2 * node + 1 , mid + 1 , end ) ; tree [ node ] = tree [ 2 * node ] | tree [ 2 * node + 1 ] ; }
int query ( int node , int start , int end , int l , int r ) { if ( start > end start > r < l ) { return 0 ; } if ( start >= l && end <= r ) { return tree [ node ] ; } int mid = ( start + end ) >> 1 ; int q1 = query ( 2 * node , start , mid , l , r ) ; int q2 = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return q1 | q2 ; }
int countSubArrays ( int [ ] arr , int n , int K ) { build ( arr , 1 , 0 , n - 1 ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = query ( 1 , 0 , n - 1 , i , j ) ; if ( bitwise_or >= K ) count ++ ; } } return count ; }
void build ( int [ ] arr , int node , int start , int end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) >> 1 ; build ( arr , 2 * node , start , mid ) ; build ( arr , 2 * node + 1 , mid + 1 , end ) ; tree [ node ] = tree [ 2 * node ] | tree [ 2 * node + 1 ] ; }
int query ( int node , int start , int end , int l , int r ) { if ( start > end start > r < l ) { return 0 ; } if ( start >= l && end <= r ) { return tree [ node ] ; } int mid = ( start + end ) >> 1 ; int q1 = query ( 2 * node , start , mid , l , r ) ; int q2 = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return q1 | q2 ; }
int countSubArrays ( int [ ] arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int low = i , high = n - 1 , index = int . MaxValue ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( query ( 1 , 0 , n - 1 , i , mid ) >= K ) { index = Math . Min ( index , mid ) ; high = mid - 1 ; } else { low = mid + 1 ; } } if ( index != int . MaxValue ) { count += n - index ; } } return count ; }
int max_min ( int [ ] a , int n ) { Array . Sort ( a ) ; return Math . Min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
int max_min ( int [ ] a , int n ) { if ( n <= 1 ) return Int32 . MaxValue ; int f_min = a [ 0 ] , s_min = Int32 . MaxValue ; int f_max = a [ 0 ] , s_max = Int32 . MinValue ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= f_min ) { s_min = f_min ; f_min = a [ i ] ; } else if ( a [ i ] < s_min ) { s_min = a [ i ] ; } if ( a [ i ] >= f_max ) { s_max = f_max ; f_max = a [ i ] ; } else if ( a [ i ] > s_max ) { s_max = a [ i ] ; } } return Math . Min ( ( f_max - s_min ) , ( s_max - f_min ) ) ; }
int findMinDifference ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int diff1 = arr [ n - 1 ] - arr [ 1 ] ; int diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . Min ( diff1 , diff2 ) ; }
int findMinDifference ( int [ ] arr , int n ) { int min , secondMin , max , secondMax ; min = secondMax = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 0 ] : arr [ 1 ] ; max = secondMin = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 1 ] : arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { secondMax = max ; max = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } else if ( arr [ i ] < min ) { secondMin = min ; min = arr [ i ] ; } else if ( arr [ i ] < secondMin ) { secondMin = arr [ i ] ; } } int diff = Math . Min ( max - secondMin , secondMax - min ) ; return diff ; }
int minimal ( int [ ] a , int n ) { int lo = 0 , hi = n - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }
int findCount ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( checkDistinct ( i ) ) count += 1 ; } return count ; }
int countDigits ( int n ) { int count = 0 ; while ( n > 0 ) { count += 1 ; n /= 10 ; } return count ; }
int findCount ( int L , int R ) { int count = 0 ; int countDigitsL = countDigits ( L ) ; int countDigitsR = countDigits ( R ) ; int firstDigitL = ( L / ( int ) Math . Pow ( 10 , countDigitsL - 1 ) ) ; int firstDigitR = ( R / ( int ) Math . Pow ( 10 , countDigitsR - 1 ) ) ; if ( countDigitsL < countDigitsR ) { count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) ; if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count += firstDigitR ; else count += ( firstDigitR - 1 ) ; } else { if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count -= ( 9 - firstDigitR ) ; else count -= ( 9 - firstDigitR + 1 ) ; } return count ; }
int LowerInsertionPoint ( int [ ] arr , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }
int getRightMin ( int [ ] arr , int n ) { int min = arr [ 0 ] ; int rightMin = 0 ; int i = 1 ; while ( i < n ) { if ( arr [ i ] == min ) rightMin = i ; i *= 2 ; } i = rightMin + 1 ; while ( i < n && arr [ i ] == min ) { rightMin = i ; i ++ ; } return rightMin ; }
int getLeftMax ( int [ ] arr , int n ) { int max = arr [ n - 1 ] ; int leftMax = n - 1 ; int i = n - 2 ; while ( i > 0 ) { if ( arr [ i ] == max ) leftMax = i ; i /= 2 ; } i = leftMax - 1 ; while ( i >= 0 && arr [ i ] == max ) { leftMax = i ; i -- ; } return leftMax ; }
void SieveOfEratosthenes ( ) { int [ ] isPrime = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) isPrime [ i ] = 1 ; isPrime [ 0 ] = isPrime [ 1 ] = 0 ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( isPrime [ i ] == 1 ) { for ( int j = i * 2 ; j < MAX ; j += i ) isPrime [ j ] = 0 ; } } for ( int i = 1 ; i < MAX ; i ++ ) { primeUpto [ i ] = primeUpto [ i - 1 ] ; if ( isPrime [ i ] == 1 ) primeUpto [ i ] ++ ; } }
int countOfNumbers ( int N , int K ) { SieveOfEratosthenes ( ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - primeUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } ans = ans != 0 ? N - ans + 1 : 0 ; return ans ; }
int minIndex ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return - 1 ; }
int smallest_pair ( int [ ] a , int n ) { int min = int . MaxValue , secondMin = int . MaxValue ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; }
bool checkSorted ( int n , int [ ] arr ) { int first = 0 , second = 0 ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { count ++ ; if ( first == 0 ) first = i ; else second = i ; } } if ( count > 2 ) return false ; if ( count == 0 ) return true ; if ( count == 2 ) swap ( arr , first - 1 , second ) ; else if ( count == 1 ) swap ( arr , first - 1 , first ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] < arr [ i - 1 ] ) return false ; return true ; }
int countWays ( int [ ] arr , int n ) { int max_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) max_val = Math . Max ( max_val , arr [ i ] ) ; int [ ] freq = new int [ max_val + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; ans += freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) / 6 ; for ( int i = 1 ; i <= max_val ; i ++ ) ans += freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) / 2 ; for ( int i = 1 ; 2 * i <= max_val ; i ++ ) ans += freq [ i ] * ( freq [ i ] - 1 ) / 2 * freq [ 2 * i ] ; for ( int i = 1 ; i <= max_val ; i ++ ) { for ( int j = i + 1 ; i + j <= max_val ; j ++ ) ans += freq [ i ] * freq [ j ] * freq [ i + j ] ; } return ans ; }
bool checkIndices ( int [ ] Arr , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }
int LongestSubarray ( int [ ] arr , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ; for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . Max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return Math . Max ( max_length , count ) ; }
int getCount ( int [ ] v , int n ) { Array . Sort ( v ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int tmp = n - 1 - upperBound ( v , n , v [ i ] - 1 ) ; if ( tmp == v [ i ] ) cnt ++ ; } return cnt ; }
bool binarySearch1D ( int [ ] arr , int K ) { int low = 0 ; int high = N - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == K ) { return true ; } if ( arr [ mid ] < K ) { low = mid + 1 ; } else { high = mid - 1 ; } } return false ; }
bool searchMatrix ( int [ , ] matrix , int K ) { int low = 0 ; int high = M - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( K >= matrix [ mid , 0 ] && K <= matrix [ mid , N - 1 ] ) { return binarySearch1D ( GetRow ( matrix , mid ) , K ) ; } if ( K < matrix [ mid , 0 ] ) { high = mid - 1 ; } else { low = mid + 1 ; } } return false ; }
int longestsubarray ( int [ ] arr , int n , int k ) { int current_count = 0 ; int max_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) current_count ++ ; else current_count = 0 ; max_count = Math . Max ( current_count , max_count ) ; } return max_count ; }
int countSegments ( int [ ] a , int n , int x ) { bool flag = false ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }
void findElements ( int [ ] arr , int n , int l , int r ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { int a = 0 ; if ( ! mp . ContainsKey ( arr [ i ] ) ) { a = 1 ; } else { a = mp [ arr [ i ] ] + 1 ; } if ( ! mp . ContainsKey ( arr [ i ] ) ) { mp . Add ( arr [ i ] , a ) ; } else { mp . Remove ( arr [ i ] ) ; mp . Add ( arr [ i ] , a ) ; } } for ( int i = 0 ; i < n ; ++ i ) { if ( mp . ContainsKey ( arr [ i ] ) && l <= mp [ arr [ i ] ] && ( mp [ arr [ i ] ] <= r ) ) { Console . Write ( arr [ i ] + " " ) ; } } }
void findElementsAfterDel ( int [ ] arr , int m , int [ ] del , int n , int k ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . ContainsKey ( del [ i ] ) ) { mp [ del [ i ] ] ++ ; } else { mp [ del [ i ] ] = 1 ; } } List < int > heap = new List < int > ( ) ; for ( int i = 0 ; i < m ; ++ i ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] -- ; if ( mp [ arr [ i ] ] == 0 ) mp . Remove ( arr [ i ] ) ; } else heap . Add ( arr [ i ] ) ; } heap . Sort ( ) ; for ( int i = 0 ; i < k ; ++ i ) { Console . Write ( heap [ 0 ] + " " ) ; heap . RemoveAt ( 0 ) ; } }
void removeElements ( int [ ] arr , int n , int k ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! mp . ContainsKey ( arr [ i ] ) ) mp . Add ( arr [ i ] , 1 ) ; else { int x = mp [ arr [ i ] ] ; mp [ arr [ i ] ] = mp [ arr [ i ] ] + ++ x ; } } for ( int i = 0 ; i < n ; ++ i ) { if ( mp [ arr [ i ] ] >= k ) Console . Write ( arr [ i ] + " " ) ; } }
bool check ( String s ) { for ( int i = 0 ; i < s . Length - 1 ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return true ; return false ; }
void RemoveElements ( int [ ] arr , int n , int k ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . ContainsKey ( arr [ i ] ) ) mp [ arr [ i ] ] ++ ; else mp [ arr [ i ] ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) { if ( mp . ContainsKey ( arr [ i ] ) && mp [ arr [ i ] ] <= k ) { Console . Write ( arr [ i ] + " " ) ; } } }
int findSmallestAfterDel ( int [ ] arr , int m , int [ ] del , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . ContainsKey ( del [ i ] ) ) { mp [ del [ i ] ] = mp [ del [ i ] ] + 1 ; } else { mp . Add ( del [ i ] , 1 ) ; } } int smallestElement = int . MaxValue ; for ( int i = 0 ; i < m ; ++ i ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] - 1 ; if ( mp [ arr [ i ] ] == 0 ) mp . Remove ( arr [ i ] ) ; } else smallestElement = Math . Min ( smallestElement , arr [ i ] ) ; } return smallestElement ; }
int findlargestAfterDel ( int [ ] arr , int m , int [ ] del , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . ContainsKey ( del [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( del [ i ] , 1 ) ; } } int largestElement = int . MinValue ; for ( int i = 0 ; i < m ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] - 1 ; if ( mp [ arr [ i ] ] == 0 ) mp . Remove ( arr [ i ] ) ; } else largestElement = Math . Max ( largestElement , arr [ i ] ) ; } return largestElement ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int divTermCount ( int a , int b , int lcm , int num ) { return num / a + num / b - num / lcm ; }
int findNthTerm ( int a , int b , int n ) { int low = 1 , high = int . MaxValue , mid ; int lcm = ( a * b ) / gcd ( a , b ) ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , lcm , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; }
int LongestFibSubseq ( int [ ] A , int n ) { SortedSet < int > S = new SortedSet < int > ( ) ; foreach ( int t in A ) { S . Add ( t ) ; } int maxLen = 0 , x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; int length = 3 ; while ( S . Contains ( y ) && y != last ( S ) ) { int z = x + y ; x = y ; y = z ; maxLen = Math . Max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; }
int numberOfElements ( int [ ] height , int n ) { int max_so_far = 0 ; int coun = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; }
bool isPossible ( int [ ] A , int n , int H , int K ) { int time = 0 ; for ( int i = 0 ; i < n ; ++ i ) time += ( A [ i ] - 1 ) / K + 1 ; return time <= H ; }
int minJobSpeed ( int [ ] A , int n , int H ) { if ( H < n ) return - 1 ; int max = A . Max ( ) ; int lo = 1 , hi = max ; while ( lo < hi ) { int mi = lo + ( hi - lo ) / 2 ; if ( ! isPossible ( A , n , H , mi ) ) lo = mi + 1 ; else hi = mi ; } return lo ; }
int kthSmallestLargest ( int [ ] arr , int n , int k ) { int max_val = arr . Max ( ) ; int [ ] hash = new int [ max_val + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } int count = 0 ; for ( int i = 0 ; i <= max_val ; i ++ ) { while ( hash [ i ] > 0 ) { count ++ ; if ( count == k ) { return i ; } hash [ i ] -- ; } } return - 1 ; }
int countAnomalies ( int [ ] arr , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && Math . Abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; }
int countAnomalies ( int [ ] a , int n , int k ) { Array . Sort ( a ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int u = upper_bound ( a , 0 , n , a [ i ] ) ; if ( u < n && a [ u ] - a [ i ] <= k ) continue ; int s = lower_bound ( a , 0 , n , a [ i ] ) ; if ( u - s > 1 ) continue ; if ( s > 0 && a [ s - 1 ] - a [ i ] <= k ) continue ; res ++ ; } return res ; }
void solve ( int [ ] arr , int n , int k ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . ContainsKey ( arr [ i ] ) ) { var val = m [ arr [ i ] ] ; m . Remove ( arr [ i ] ) ; m . Add ( arr [ i ] , val + 1 ) ; } else { m . Add ( arr [ i ] , 1 ) ; } } int max = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( m [ arr [ i ] ] == k && max == int . MinValue ) { max = arr [ i ] ; } else if ( m [ arr [ i ] ] == k && max < arr [ i ] ) { max = arr [ i ] ; } } if ( max == int . MinValue ) Console . WriteLine ( "No such element" ) ; else Console . WriteLine ( max ) ; }
int majorityInMatrix ( int [ , ] arr ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mp . ContainsKey ( arr [ i , j ] ) ) mp [ arr [ i , j ] ] ++ ; else mp [ arr [ i , j ] ] = 1 ; } } int countMajority = 0 ; Dictionary < int , int > . KeyCollection keyColl = mp . Keys ; foreach ( int i in keyColl ) { if ( mp [ i ] >= ( ( N * M ) / 2 ) ) { countMajority ++ ; } } return countMajority ; }
int getMin ( int [ ] arr , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = Math . Min ( res , arr [ i ] ) ; return res ; }
int findSum ( int [ ] arr , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min + max ; }
int findProduct ( int [ ] arr , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min * max ; }
void countEle ( Stack < int > s , int [ ] a , int N ) { Dictionary < int , bool > mp = new Dictionary < int , bool > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { int num = a [ i ] ; if ( mp . ContainsKey ( num ) ) Console . Write ( "0 " ) ; else { int cnt = 0 ; while ( s . Peek ( ) != num ) { mp . Add ( s . Peek ( ) , true ) ; s . Pop ( ) ; cnt ++ ; } s . Pop ( ) ; cnt ++ ; Console . Write ( cnt + " " ) ; } } }
int bsearch ( List < int > A , int key_to_search ) { int n = ( int ) A . Count ; int lg = ( int ) Math . Log ( n - 1 , 2.0 ) + 1 ; int pos = 0 ; for ( int i = lg - 1 ; i >= 0 ; i -- ) { if ( A [ pos ] == key_to_search ) { return pos ; } int new_pos = pos | ( 1 << i ) ; if ( ( new_pos < n ) && ( A [ new_pos ] <= key_to_search ) ) { pos = new_pos ; } } return ( ( A [ pos ] == key_to_search ) ? pos : - 1 ) ; }
int colMaxDiff ( int [ , ] mat ) { int max_diff = int . MinValue ; for ( int i = 0 ; i < N ; i ++ ) { int max_val = mat [ 0 , i ] , min_val = mat [ 0 , i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_val = Math . Max ( max_val , mat [ j , i ] ) ; min_val = Math . Min ( min_val , mat [ j , i ] ) ; } max_diff = Math . Max ( max_diff , max_val - min_val ) ; } return max_diff ; }
int countChar ( String str ) { int n = str . Length ; if ( n <= 2 ) return n ; int count = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; }
float findmedian ( int [ ] a , int n1 , int [ ] b , int n2 ) { int i = 0 ; int j = 0 ; int k ; int m1 = - 1 , m2 = - 1 ; for ( k = 0 ; k <= ( n1 + n2 ) / 2 ; k ++ ) { if ( i < n1 && j < n2 ) { if ( a [ i ] < b [ j ] ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } else { m2 = m1 ; m1 = b [ j ] ; j ++ ; } } else if ( i == n1 ) { m2 = m1 ; m1 = b [ j ] ; j ++ ; } else if ( j == n2 ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } } if ( ( n1 + n2 ) % 2 == 0 ) { return ( m1 + m2 ) * ( float ) 1.0 / 2 ; } return m1 ; }
int search ( int [ ] ar , int size ) { int a = 0 , b = size - 1 ; int mid = 0 ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 1 ) ; }
int deleteElement ( int [ ] A , int L , int R , int N ) { int i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; }
bool search ( int [ ] arr , int n , int x ) { int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == - 1 ) return false ; int temp = arr [ res ] ; for ( int i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; }
float kPresentProbability ( int [ ] a , int n , int k ) { float count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count ++ ; return count / n ; }
int binarySearch ( int [ ] searchSpace , int s , int e , int num ) { int ans = 0 ; while ( s <= e ) { int mid = ( s + e ) / 2 ; if ( searchSpace [ mid ] >= num ) { ans = mid ; e = mid - 1 ; } else s = mid + 1 ; } return ans ; }
int longestSubArr ( int [ ] arr , int n ) { int [ ] searchSpace = new int [ n ] ; int [ ] index = new int [ n ] ; int j = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( j == 0 searchSpace [ j - 1 ] < arr [ i ] ) { searchSpace [ j ] = arr [ i ] ; index [ j ] = i ; j ++ ; } int idx = binarySearch ( searchSpace , 0 , j - 1 , arr [ i ] ) ; ans = Math . Max ( ans , i - index [ idx ] + 1 ) ; } return ans ; }
int findmissing ( int [ ] ar , int N ) { int l = 0 , r = N - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( ar [ mid ] != mid + 1 && ar [ mid - 1 ] == mid ) return ( mid + 1 ) ; if ( ar [ mid ] != mid + 1 ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; }
int findFirst ( int [ ] arr , int n , int x ) { Array . Sort ( arr ) ; int ptr = lowerBound ( arr , 0 , n , x ) ; return ( arr [ ptr ] != x ) ? - 1 : ( ptr ) ; }
int findFirst ( int [ ] arr , int n , int x ) { int count = 0 ; bool isX = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) { isX = true ; } else if ( arr [ i ] < x ) { count ++ ; } } return ( isX == false ) ? - 1 : count ; }
int findDuplicate ( int [ ] arr ) { int slow = arr [ 0 ] ; int fast = arr [ 0 ] ; do { slow = arr [ slow ] ; fast = arr [ arr [ fast ] ] ; } while ( slow != fast ) ; int ptr1 = arr [ 0 ] ; int ptr2 = slow ; while ( ptr1 != ptr2 ) { ptr1 = arr [ ptr1 ] ; ptr2 = arr [ ptr2 ] ; } return ptr1 ; }
bool isSafe ( int x , int y , int [ , ] sol ) { return ( x >= 0 && x < N && y >= 0 && y < N && sol [ x , y ] == - 1 ) ; }
void prevGreater ( int [ ] arr , int n ) { Console . Write ( "-1, " ) ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { Console . Write ( arr [ j ] + ", " ) ; break ; } } if ( j == - 1 ) Console . Write ( "-1, " ) ; } }
void prevGreater ( int [ ] arr , int n ) { Stack < int > s = new Stack < int > ( ) ; s . Push ( arr [ 0 ] ) ; Console . Write ( "-1, " ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( s . Count != 0 && s . Peek ( ) < arr [ i ] ) s . Pop ( ) ; if ( s . Count == 0 ) Console . Write ( "-1, " ) ; else Console . Write ( s . Peek ( ) + ", " ) ; s . Push ( arr [ i ] ) ; } }
void printGreaterCount ( String str ) { int len = str . Length ; int [ ] right = new int [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = i + 1 ; j < len ; j ++ ) { if ( str [ i ] < str [ j ] ) { right [ i ] ++ ; } } } for ( int i = 0 ; i < len ; i ++ ) { Console . Write ( right [ i ] + " " ) ; } }
void printGreaterCount ( string str ) { int len = str . Length ; int [ ] ans = new int [ len ] ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = len - 1 ; i >= 0 ; i -- ) { count [ str [ i ] - 'a' ] ++ ; for ( int j = str [ i ] - 'a' + 1 ; j < MAX_CHAR ; j ++ ) { ans [ i ] += count [ j ] ; } } for ( int i = 0 ; i < len ; i ++ ) { Console . Write ( ans [ i ] + " " ) ; } }
int findMissingNo ( int [ ] arr , int n ) { int val ; int nextval ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= 0 arr [ i ] > n ) continue ; val = arr [ i ] ; while ( arr [ val - 1 ] != val ) { nextval = arr [ val - 1 ] ; arr [ val - 1 ] = val ; val = nextval ; if ( val <= 0 val > n ) break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != i + 1 ) { return i + 1 ; } } return n + 1 ; }
int solve ( int [ ] a , int n ) { int max1 = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Math . Abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = Math . Abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; }
int solve ( int [ ] a , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return Math . Abs ( min1 - max1 ) ; }
int maxProduct ( int [ ] arr , int n ) { if ( n < 4 ) return - 1 ; int max_product = int . MinValue ; for ( int i = 0 ; i < n - 3 ; i ++ ) for ( int j = i + 1 ; j < n - 2 ; j ++ ) for ( int k = j + 1 ; k < n - 1 ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) max_product = Math . Max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; }
int maxSum ( int [ ] arr , int n ) { if ( n < 2 ) return - 1 ; int ans = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i + 1 < n ; i ++ ) ans = Math . Min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; }
int getCount ( int M , int N ) { int count = 0 ; if ( M == 1 ) return N ; if ( N == 1 ) return M ; if ( N > M ) { for ( int i = 1 ; i <= M ; i ++ ) { int numerator = N * i - N + M - i ; int denominator = M - 1 ; if ( numerator % denominator == 0 ) { int j = numerator / denominator ; if ( j >= 1 && j <= N ) count ++ ; } } } else { for ( int j = 1 ; j <= N ; j ++ ) { int numerator = M * j - M + N - j ; int denominator = N - 1 ; if ( numerator % denominator == 0 ) { int i = numerator / denominator ; if ( i >= 1 && i <= M ) count ++ ; } } } return count ; }
int countTripletsLessThanL ( int n , int L , int [ ] arr ) { Array . Sort ( arr ) ; int ways = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { int mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; }
int appearsNBy3 ( int [ ] arr , int n ) { int count1 = 0 , count2 = 0 ; int first = int . MaxValue ; int second = int . MaxValue ; for ( int i = 1 ; i < n ; i ++ ) { if ( first == arr [ i ] ) count1 ++ ; else if ( second == arr [ i ] ) count2 ++ ; else if ( count1 == 0 ) { count1 ++ ; first = arr [ i ] ; } else if ( count2 == 0 ) { count2 ++ ; second = arr [ i ] ; } else { count1 -- ; count2 -- ; } } count1 = 0 ; count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == first ) count1 ++ ; else if ( arr [ i ] == second ) count2 ++ ; } if ( count1 > n / 3 ) return first ; if ( count2 > n / 3 ) return second ; return - 1 ; }
int binary_lower ( int value , int [ ] arr , int n ) { int start = 0 ; int end = n - 1 ; int ans = - 1 ; int mid ; while ( start <= end ) { mid = ( start + end ) / 2 ; if ( arr [ mid ] >= value ) { end = mid - 1 ; ans = mid ; } else { start = mid + 1 ; } } return ans ; }
int countTriplet ( int [ ] arr , int n , int k ) { int count = 0 ; Array . Sort ( arr ) ; for ( int i = 2 ; i < n ; i ++ ) { int cur = binary_lower ( arr [ i ] - k , arr , n ) ; if ( cur <= i - 2 ) { count += ( ( i - cur ) * ( i - cur - 1 ) ) / 2 ; } } return count ; }
bool isSuffix ( string s1 , string s2 ) { int n1 = s1 . Length , n2 = s2 . Length ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
void replaceOriginal ( String s , int n ) { char [ ] r = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s [ n - 1 - i ] ; if ( s [ i ] != 'a' && s [ i ] != 'e' && s [ i ] != 'i' && s [ i ] != 'o' && s [ i ] != 'u' ) { Console . Write ( r [ i ] ) ; } } Console . WriteLine ( "" ) ; }
bool swapElement ( int [ ] arr1 , int [ ] arr2 , int n ) { int wrongIdx = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr1 [ i ] < arr1 [ i - 1 ] ) { wrongIdx = i ; } } int maximum = int . MinValue ; int maxIdx = - 1 ; bool res = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr2 [ i ] > maximum && arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) { if ( wrongIdx + 1 <= n - 1 && arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) { maximum = arr2 [ i ] ; maxIdx = i ; res = true ; } } } if ( res ) { swap ( arr1 , wrongIdx , arr2 , maxIdx ) ; } return res ; }
bool ElementsCalculationFunc ( int [ ] pre , int [ ] maxx , int x , int k , int n ) { for ( int i = 0 , j = x ; j <= n ; j ++ , i ++ ) { if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; }
int costToBalance ( string s ) { if ( s . Length == 0 ) Console . WriteLine ( 0 ) ; int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '(' ) o ++ ; if ( s [ i ] == ')' ) c ++ ; } if ( o != c ) return - 1 ; int [ ] a = new int [ s . Length ] ; if ( s [ 0 ] == '(' ) a [ 0 ] = 1 ; else a [ 0 ] = - 1 ; if ( a [ 0 ] < 0 ) ans += Math . Abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( s [ i ] == '(' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += Math . Abs ( a [ i ] ) ; } return ans ; }
bool checkIfAllTogether ( string s , char c ) { static bool checkIfAllTogether ( string s , char c ) { bool oneSeen = false ; int i = 0 , n = s . Length ; while ( i < n ) { if ( s [ i ] == c ) { if ( oneSeen == true ) return false ; while ( i < n && s [ i ] == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; } public static void Main ( ) { string s = "110029" ; if ( checkIfAllTogether ( s , '1' ) ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; } }
int f ( int n ) { return n * ( 2 * n * n - 1 ) ; }
bool binarySearch ( int low , int high , int x ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( f ( mid ) < x ) low = mid + 1 ; else if ( f ( mid ) > x ) high = mid - 1 ; else return true ; } return false ; }
bool isStellaOctangula ( int x ) { if ( x == 0 ) return true ; int i = 1 ; while ( f ( i ) < x ) i = i * 2 ; if ( f ( i ) == x ) return true ; return binarySearch ( i / 2 , i , x ) ; }
bool search ( int [ ] arr , int n , int x ) { int front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; }
bool isSafe ( bool [ , ] graph , int [ ] color ) { for ( int i = 0 ; i < V ; i ++ ) for ( int j = i + 1 ; j < V ; j ++ ) if ( graph [ i , j ] && color [ j ] == color [ i ] ) return false ; return true ; }
bool graphColoring ( bool [ , ] graph , int m , int i , int [ ] color ) { if ( i == V ) { if ( isSafe ( graph , color ) ) { printSolution ( color ) ; return true ; } return false ; } for ( int j = 1 ; j <= m ; j ++ ) { color [ i ] = j ; if ( graphColoring ( graph , m , i + 1 , color ) ) return true ; color [ i ] = 0 ; } return false ; }
int getGreatestSum ( int [ , ] a ) { int prev_max = 0 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max < a [ N - 1 , j ] ) prev_max = a [ N - 1 , j ] ; int sum = prev_max ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int curr_max = - 2147483648 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max > a [ i , j ] && a [ i , j ] > curr_max ) curr_max = a [ i , j ] ; if ( curr_max == - 2147483648 ) return - 1 ; prev_max = curr_max ; sum += prev_max ; } return sum ; }
int minSum ( int [ ] arr , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
int missingNum ( int [ ] arr , int n ) { List < int > list = new List < int > ( arr . Length ) ; foreach ( int i in arr ) { list . Add ( i ) ; } int minvalue = list . Min ( ) ; int xornum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue ++ ; } return xornum ^ minvalue ; }
void findElement ( int n , int k ) { int ans = n ; int left = 1 ; int right = ( int ) ( Math . Pow ( 2 , n ) - 1 ) ; while ( true ) { int mid = ( left + right ) / 2 ; if ( k == mid ) { Console . WriteLine ( ans ) ; break ; } ans -- ; if ( k < mid ) { right = mid - 1 ; } else { left = mid + 1 ; } } }
int firstCommon ( Node head1 , Node head2 ) { for ( ; head1 != null ; head1 = head1 . next ) for ( Node p = head2 ; p != null ; p = p . next ) if ( p . data == head1 . data ) return head1 . data ; return 0 ; }
int findmin ( Point [ ] p , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] . x <= 0 ) a ++ ; else if ( p [ i ] . x >= 0 ) b ++ ; if ( p [ i ] . y >= 0 ) c ++ ; else if ( p [ i ] . y <= 0 ) d ++ ; } return Math . Min ( Math . Min ( a , b ) , Math . Min ( c , d ) ) ; }
int findLastIndex ( string str , char x ) { int index = - 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; }
int findLastIndex ( string str , char x ) { for ( int i = str . Length - 1 ; i >= 0 ; i -- ) if ( str [ i ] == x ) return i ; return - 1 ; }
int checkBit ( int pattern , int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; }
int countMaxSumPairs ( int [ ] a , int n ) { int first = int . MinValue , second = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } int cnt1 = 0 , cnt2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == first ) cnt1 ++ ; if ( a [ i ] == second ) cnt2 ++ ; } if ( cnt1 == 1 ) return cnt2 ; if ( cnt1 > 1 ) return cnt1 * ( cnt1 - 1 ) / 2 ; return 0 ; }
int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }
int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }
int findValue ( int X , int Y , int P ) { if ( P % 2 == 0 ) return ( Math . Max ( X , Y ) / Math . Min ( X , Y ) ) ; else return ( Math . Max ( 2 * X , Y ) / Math . Min ( 2 * X , Y ) ) ; }
int countMaxSetBits ( int left , int right ) { int max_count = - 1 , num = 0 ; for ( int i = left ; i <= right ; ++ i ) { int temp = i , cnt = 0 ; while ( temp > 0 ) { if ( temp % 2 == 1 ) ++ cnt ; temp >>= 1 ; } if ( cnt > max_count ) { max_count = cnt ; num = i ; } } return num ; }
int sum ( int [ ] arr , int from , int to ) { int total = 0 ; for ( int i = from ; i <= to ; i ++ ) total += arr [ i ] ; return total ; }
int findMax ( int [ ] arr , int n , int k ) { int [ , ] dp = new int [ k + 1 , n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) dp [ 1 , i ] = sum ( arr , 0 , i - 1 ) ; for ( int i = 1 ; i <= k ; i ++ ) dp [ i , 1 ] = arr [ 0 ] ; for ( int j = 2 ; j <= n ; j ++ ) { int best = int . MaxValue ; for ( int p = 1 ; p <= j ; p ++ ) best = Math . Min ( best , Math . Max ( dp [ i - 1 , p ] , sum ( arr , p , j - 1 ) ) ) ; dp [ i , j ] = best ; } }
int findFloor ( Node root , int key ) { Node curr = root , ans = null ; while ( curr != null ) { if ( curr . key <= key ) { ans = curr ; curr = curr . right ; } else curr = curr . left ; } if ( ans != null ) return ans . key ; return - 1 ; }
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return - 1 ; }
int isvalid ( int s ) { double k = ( - 1.0 + Math . Sqrt ( 1 + 8 * s ) ) / 2 ; if ( Math . Ceiling ( k ) == Math . Floor ( k ) ) return ( int ) k ; else return - 1 ; }
int calcSafe ( int pos ) { int j = pos % 10 ; int i = pos / 10 ; int dis_11 = Math . Min ( Math . Abs ( 1 - i ) , Math . Abs ( 1 - j ) ) ; int dis_18 = Math . Min ( Math . Abs ( 1 - i ) , Math . Abs ( 8 - j ) ) ; int dis_81 = Math . Min ( Math . Abs ( 8 - i ) , Math . Abs ( 1 - j ) ) ; int dis_88 = Math . Min ( Math . Abs ( 8 - i ) , Math . Abs ( 8 - j ) ) ; int sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; }
int countCrossLine ( int [ ] arr , int n ) { int count_crossline = 0 ; int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; count_crossline ++ ; } arr [ j + 1 ] = key ; } return count_crossline ; }
int getCount ( int [ ] arr , int n , int num1 , int num2 ) { int i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; int j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }
bool check_elements ( int [ ] arr , int n , int A , int B ) { int range = B - A ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . Abs ( arr [ i ] ) >= A && Math . Abs ( arr [ i ] ) <= B ) { int z = Math . Abs ( arr [ i ] ) - A ; if ( arr [ z ] > 0 ) { arr [ z ] = arr [ z ] * - 1 ; } } } int count = 0 ; for ( int i = 0 ; i <= range && i < n ; i ++ ) { if ( arr [ i ] > 0 ) return false ; else count ++ ; } if ( count != ( range + 1 ) ) return false ; return true ; }
int sumOfDigit ( int K ) { int sod = 0 ; while ( K != 0 ) { sod += K % 10 ; K /= 10 ; } return sod ; }
int findMinRec ( int [ ] A , int n ) { if ( n == 1 ) return A [ 0 ] ; return Math . Min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; }
int findMaxRec ( int [ ] A , int n ) { if ( n == 1 ) return A [ 0 ] ; return Math . Max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) ; }
int getRandom ( int x , int y ) { return ( int ) ( x + new Random ( 10 ) . Next ( 1 ) * 10 % ( y - x + 1 ) ) ; }
int randomizedBinarySearch ( int [ ] arr , int l , int r , int x ) { while ( l <= r ) { int m = getRandom ( l , r ) ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }
int countBuildings ( int [ ] arr , int n ) { int count = 1 ; int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; }
int findExtra ( int [ ] arr1 , int [ ] arr2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }
int findExtra ( int [ ] arr1 , int [ ] arr2 , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
int findPages ( int [ ] arr , int n , int m ) { long sum = 0 ; if ( n < m ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int start = 0 , end = ( int ) sum ; int result = int . MaxValue ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( isPossible ( arr , n , m , mid ) ) { result = mid ; end = mid - 1 ; } else start = mid + 1 ; } return result ; }
int minCostToMakeElementEqual ( int [ ] arr , int N ) { int low , high ; low = high = arr [ 0 ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( low > arr [ i ] ) low = arr [ i ] ; if ( high < arr [ i ] ) high = arr [ i ] ; } while ( ( high - low ) > 2 ) { int mid1 = low + ( high - low ) / 3 ; int mid2 = high - ( high - low ) / 3 ; int cost1 = computeCost ( arr , N , mid1 ) ; int cost2 = computeCost ( arr , N , mid2 ) ; if ( cost1 < cost2 ) high = mid2 ; else low = mid1 ; } return computeCost ( arr , N , ( low + high ) / 2 ) ; }
void minJumps ( int [ ] w , int [ ] l , int n ) { if ( n == 1 ) { Console . Write ( 0 ) ; return ; } int ans = 0 ; Dictionary < int , int > pos = new Dictionary < int , int > ( ) ; Dictionary < int , int > jump = new Dictionary < int , int > ( ) ; Dictionary < int , bool > filled = new Dictionary < int , bool > ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( pos . ContainsKey ( w [ i ] ) ) pos [ w [ i ] ] = i ; else pos . Add ( w [ i ] , i ) ; if ( filled . ContainsKey ( w [ i ] ) ) filled [ i ] = true ; else filled . Add ( i , true ) ; if ( jump . ContainsKey ( w [ i ] ) ) jump [ w [ i ] ] = l [ i ] ; else jump . Add ( w [ i ] , l [ i ] ) ; a [ i ] = w [ i ] ; } Array . Sort ( a ) ; for ( int curr = 1 ; curr < n ; curr ++ ) { int currElementPos = pos [ a [ curr ] ] ; int prevElementPos = pos [ a [ curr - 1 ] ] ; if ( currElementPos > prevElementPos ) continue ; while ( currElementPos <= prevElementPos || filled . ContainsKey ( currElementPos ) && filled [ currElementPos ] ) { currElementPos += jump [ a [ curr ] ] ; ans ++ ; } if ( pos . ContainsKey ( a [ curr ] ) ) pos [ a [ curr ] ] = currElementPos ; else pos . Add ( a [ curr ] , currElementPos ) ; if ( filled . ContainsKey ( currElementPos ) ) filled [ currElementPos ] = true ; else filled . Add ( currElementPos , true ) ; } Console . Write ( ans ) ; }
void check ( int [ ] arr , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] >= ( i - 1 ) ) { int p = arr [ i - 1 ] - ( i - 1 ) ; arr [ i ] += p ; arr [ i - 1 ] -= p ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= arr [ i - 1 ] ) { Console . Write ( "No" ) ; return ; } } Console . Write ( "Yes" ) ; }
void minimumSize ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; if ( count ( arr , 0 ) == N ) Console . WriteLine ( 0 ) ; else if ( K >= N ) Console . WriteLine ( 1 ) ; else Console . WriteLine ( arr [ K ] ) ; }
void isPossibleToSort ( int [ ] arr , int N ) { int idx = - 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 1 && arr [ i - 1 ] == 1 ) { idx = i ; break ; } } if ( idx == - 1 ) { Console . WriteLine ( "YES" ) ; return ; } for ( int i = idx + 1 ; i < N ; i ++ ) { if ( arr [ i ] == 0 && arr [ i - 1 ] == 0 ) { Console . WriteLine ( "NO" ) ; return ; } } Console . WriteLine ( "YES" ) ; }
bool check ( int [ ] arr , int n ) { int count = 0 ; int index = - 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] ) { count ++ ; index = i ; } } if ( count > 1 ) return false ; if ( count == 0 ) return true ; if ( index == n - 1 index == 1 ) return true ; if ( arr [ index - 1 ] < arr [ index + 1 ] ) return true ; if ( arr [ index - 2 ] < arr [ index ] ) return true ; return false ; }
string isPossibleToSort ( int [ , ] arr , int N ) { int group = arr [ 0 , 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i , 1 ] != group ) { return "Yes" ; } } if ( isSorted ( arr , N ) ) { return "Yes" ; } else { return "No" ; } }
int maximumSum ( int [ ] arr , int [ ] S , int N , int K ) { int ans = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < N / 2 ; i ++ ) { int temp = arr [ i ] ; arr [ i ] = arr [ N - 1 - i ] ; arr [ N - 1 - i ] = temp ; } for ( int i = 0 ; i < K ; i ++ ) ans += arr [ i ] ; Array . Sort ( S ) ; for ( int i = 0 ; i < K ; i ++ ) { if ( S [ i ] == 1 ) ans += arr [ i ] ; S [ i ] -- ; } int counter = K - 1 ; for ( int i = 0 ; i < K ; i ++ ) { counter = counter + S [ i ] ; if ( S [ i ] != 0 ) ans += arr [ counter ] ; } return ans ; }
int minimumDeletion ( string s , int n ) { Dictionary < char , int > countMap = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( countMap . ContainsKey ( s [ i ] ) == true ) { countMap [ s [ i ] ] += 1 ; } else { countMap [ s [ i ] ] = 1 ; } } List < int > countMultiset = new List < int > ( ) ; foreach ( var values in countMap . Values ) { countMultiset . Add ( values ) ; } countMultiset . Sort ( ) ; int ans = 100000000 ; int index = 0 ; int m = countMultiset . Count ; foreach ( var j in countMultiset ) { ans = Math . Min ( ans , n - ( m - index ) * j ) ; index ++ ; } return ans ; }
void maxLenSubset ( int [ ] a , int n ) { Array . Sort ( a ) ; int index = 0 , maxlen = - 1 ; int i = 0 ; while ( i < n ) { int j = i ; int len = 1 ; while ( j < n - 1 ) { if ( 2 * a [ j ] >= a [ j + 1 ] ) { len ++ ; } else break ; j ++ ; } if ( maxlen < len ) { maxlen = len ; index = i ; } j ++ ; i = j ; } i = index ; while ( maxlen > 0 ) { Console . Write ( a [ i ] + " " ) ; maxlen -- ; i ++ ; } }
void maximumMex ( int [ ] arr , int N ) { int [ ] ans = new int [ 2 * N ] ; Array . Sort ( ans ) ; int j = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 arr [ i ] != arr [ i - 1 ] ) { j += 1 ; ans [ j ] = arr [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( i > 0 && arr [ i ] == arr [ i - 1 ] ) { j += 1 ; ans [ j ] = arr [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) Console . Write ( ans [ i ] + " " ) ; }
void canReduceArray ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; int [ ] b = new int [ N ] ; int j = N ; for ( int i = 0 ; i < N ; i ++ ) { b [ j - 1 ] = arr [ i ] ; j = j - 1 ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] - arr [ i + 1 ] > K ) { Console . WriteLine ( "No" ) ; return ; } } Console . WriteLine ( "Yes" ) ; }
void mergeStrings ( string s1 , string s2 ) { int len1 = s1 . Length ; int len2 = s2 . Length ; int pntr1 = 0 ; int pntr2 = 0 ; string ans = "" ; while ( pntr1 < len1 && pntr2 < len2 ) { if ( s1 [ pntr1 ] < s2 [ pntr2 ] ) { ans += s1 [ pntr1 ] ; pntr1 ++ ; } else { ans += s2 [ pntr2 ] ; pntr2 ++ ; } } if ( pntr1 < len1 ) { ans += s1 . Substring ( pntr1 , len1 - pntr1 ) ; } if ( pntr2 < len2 ) { ans += s2 . Substring ( pntr2 , len2 - pntr2 ) ; } Console . WriteLine ( ans ) ; }
List < int > bubble_sort ( List < int > ar ) { List < int > temp = new List < int > ( ) ; if ( ar . Count <= 1 ) return ar ; if ( ar . Count == 2 ) { if ( ar [ 0 ] < ar [ 1 ] ) return ar ; else { temp . Add ( ar [ 1 ] ) ; temp . Add ( ar [ 0 ] ) ; return temp ; } } int a = ar [ 0 ] ; int b = ar [ 1 ] ; List < int > bs = new List < int > ( ) ; for ( int i = 2 ; i < ar . Count ; i ++ ) bs . Add ( ar [ i ] ) ; List < int > res = new List < int > ( ) ; if ( a < b ) { List < int > temp1 = new List < int > ( ) ; temp1 . Add ( b ) ; for ( int i = 0 ; i < bs . Count ; i ++ ) temp1 . Add ( bs [ i ] ) ; List < int > v = bubble_sort ( temp1 ) ; v . Insert ( 0 , a ) ; res = v ; } else { List < int > temp1 = new List < int > ( ) ; temp1 . Add ( a ) ; for ( int i = 0 ; i < bs . Count ; i ++ ) temp1 . Add ( bs [ i ] ) ; List < int > v = bubble_sort ( temp1 ) ; v . Insert ( 0 , b ) ; res = v ; } List < int > pass = new List < int > ( ) ; for ( int i = 0 ; i < res . Count - 1 ; i ++ ) pass . Add ( res [ i ] ) ; List < int > ans = bubble_sort ( pass ) ; ans . Add ( res [ res . Count - 1 ] ) ; return ans ; }
void sortBoundaryWise ( List < List < int > > a ) { int i , k = 0 , l = 0 ; int m = a . Count , n = a [ 0 ] . Count ; int n_k = 0 , n_l = 0 , n_m = m , n_n = n ; while ( k < m && l < n ) { List < int > boundary = new List < int > ( ) ; for ( i = l ; i < n ; ++ i ) { boundary . Add ( a [ k ] [ i ] ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { boundary . Add ( a [ i ] [ n - 1 ] ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { boundary . Add ( a [ m - 1 ] [ i ] ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { boundary . Add ( a [ i ] [ l ] ) ; } l ++ ; } boundary . Sort ( ) ; int ind = 0 ; for ( i = n_l ; i < n_n ; ++ i ) { a [ n_k ] [ i ] = boundary [ ind ++ ] ; } n_k ++ ; for ( i = n_k ; i < n_m ; ++ i ) { a [ i ] [ n_n - 1 ] = boundary [ ind ++ ] ; } n_n -- ; if ( n_k < n_m ) { for ( i = n_n - 1 ; i >= n_l ; -- i ) { a [ n_m - 1 ] [ i ] = boundary [ ind ++ ] ; } n_m -- ; } if ( n_l < n_n ) { for ( i = n_m - 1 ; i >= n_k ; -- i ) { a [ i ] [ n_l ] = boundary [ ind ++ ] ; } n_l ++ ; } } printMatrix ( a ) ; }
void countPairs ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int high = upper_bound ( arr , k * arr [ i ] ) ; ans += high - i - 1 ; } Console . WriteLine ( ans ) ; }
void findXOR ( int [ , ] mat , int K ) { int N = mat . GetLength ( 0 ) ; int M = mat . GetLength ( 1 ) ; List < int > digXOR = new List < int > ( ) ; for ( int l = 1 ; l <= ( N + M - 1 ) ; l ++ ) { int s_col = Math . Max ( 0 , l - N ) ; int count = Math . Min ( l , Math . Min ( ( M - s_col ) , N ) ) ; int currXOR = 0 ; for ( int j = 0 ; j < count ; j ++ ) { currXOR = ( currXOR ^ mat [ Math . Min ( N , l ) - j - 1 , s_col + j ] ) ; } digXOR . Add ( currXOR ) ; } digXOR . Sort ( ) ; Console . Write ( digXOR [ N + M - 1 - K ] ) ; }
void countArraysUtil ( List < int > arr , int X , int K , int xorVal ) { if ( X == 0 ) { int cnt = 0 ; for ( int i = 0 ; i < arr . Count ; i ++ ) { if ( arr [ i ] > xorVal ) cnt ++ ; } if ( cnt >= K ) ans ++ ; return ; } int temp = arr [ 0 ] ; arr . RemoveAt ( 0 ) ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr . Insert ( 0 , temp ) ; temp = arr [ arr . Count - 1 ] ; arr . RemoveAt ( arr . Count - 1 ) ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr . Add ( temp ) ; arr [ 0 ] ++ ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr [ 0 ] -- ; arr [ arr . Count - 1 ] ++ ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr [ arr . Count - 1 ] -- ; }
void countArrays ( List < int > arr , int X , int K ) { int xorVal = 0 ; for ( int i = 0 ; i < arr . Count ; i ++ ) xorVal = xorVal ^ arr [ i ] ; countArraysUtil ( arr , X , K , xorVal ) ; Console . Write ( ans ) ; }
void maximumSum ( int [ ] arr , int N ) { int sum ; Array . Sort ( arr ) ; sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; Console . Write ( sum ) ; }
void getBuckets ( int [ ] arr , int N ) { int availableWater = N * ( N - 1 ) / 2 ; Array . Sort ( arr ) ; int i = 0 , sum = 0 ; while ( sum <= availableWater ) { sum += arr [ i ] ; i ++ ; } Console . Write ( i - 1 ) ; }
int minimum_sum ( int [ ] A , int N ) { Array . Sort ( A ) ; int sum = 2147483647 ; for ( int i = 0 ; i <= N - 3 ; i ++ ) { sum = Math . Min ( sum , Math . Abs ( A [ i ] - A [ i + 1 ] ) + Math . Abs ( A [ i + 1 ] - A [ i + 2 ] ) ) ; } return sum ; }
void minimumIncreasingSubsequences ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int count = 0 ; int i = 0 ; while ( i < N ) { int x = arr [ i ] ; int freqX = 0 ; while ( i < N && arr [ i ] == x ) { freqX ++ ; i ++ ; } count = Math . Max ( count , freqX ) ; } Console . Write ( count ) ; }
void maxOps ( int a , int b , int c ) { int [ ] arr = { a , b , c } ; int count = 0 ; while ( 1 != 0 ) { Array . Sort ( arr ) ; if ( arr [ 0 ] == 0 && arr [ 1 ] == 0 ) break ; arr [ 1 ] -= 1 ; arr [ 2 ] -= 1 ; count += 1 ; } Console . WriteLine ( count ) ; }
int hashFunction ( int N ) { int [ ] prime = { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 } ; int value = 1 , r ; while ( N != 0 ) { r = N % 10 ; value = value * prime [ r ] ; N = N / 10 ; } return value ; }
void findDiff ( int [ ] arr , int n ) { Dictionary < int , List < int > > m = new Dictionary < int , List < int > > ( ) ; int h , min , max ; for ( int i = 0 ; i < n ; i ++ ) { h = hashFunction ( arr [ i ] ) ; if ( ! m . ContainsKey ( h ) ) { m [ h ] = new List < int > ( ) ; } m [ h ] . Add ( arr [ i ] ) ; } foreach ( KeyValuePair < int , List < int > > i in m ) { if ( i . Value . Count > 1 ) { min = Int32 . MaxValue ; max = Int32 . MinValue ; for ( int j = 0 ; j < i . Value . Count ; j ++ ) { if ( m [ i . Key ] [ j ] < min ) { min = m [ i . Key ] [ j ] ; } if ( m [ i . Key ] [ j ] > max ) { max = m [ i . Key ] [ j ] ; } } Console . Write ( max - min ) ; break ; } else if ( m [ i . Key ] . Equals ( m . Last ( ) . Value ) ) Console . Write ( - 1 ) ; } }
int maxScore ( int i , int [ ] A , int K , int N , int [ ] dp ) { if ( i >= N - 1 ) return A [ N - 1 ] ; if ( dp [ i ] != - 1 ) return dp [ i ] ; int score = int . MinValue ; for ( int j = 1 ; j <= K ; j ++ ) { score = Math . Max ( score , maxScore ( i + j , A , K , N , dp ) ) ; } return dp [ i ] = score + A [ i ] ; }
void getScore ( int [ ] A , int N , int K ) { int [ ] dp = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] = - 1 ; Console . WriteLine ( maxScore ( 0 , A , K , N , dp ) ) ; }
bool checkifSorted ( int [ ] A , int [ ] B , int N ) { bool flag = false ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = true ; break ; } } if ( ! flag ) { return true ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 0 ) { count ++ ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 1 ) { count ++ ; break ; } } if ( count == 2 ) { return true ; } return false ; }
void minOperation ( int [ ] a , int N ) { int totOps = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { totOps += Math . Abs ( a [ i ] - a [ i + 1 ] ) ; } int maxOps = Math . Max ( Math . Abs ( a [ 0 ] - a [ 1 ] ) , Math . Abs ( a [ N - 1 ] - a [ N - 2 ] ) ) ; for ( int i = 1 ; i < N - 1 ; i ++ ) { maxOps = Math . Max ( maxOps , Math . Abs ( a [ i ] - a [ i - 1 ] ) + Math . Abs ( a [ i ] - a [ i + 1 ] ) - Math . Abs ( a [ i - 1 ] - a [ i + 1 ] ) ) ; } Console . WriteLine ( totOps - maxOps ) ; }
void maxPossibleSum ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } Console . WriteLine ( sum ) ; }
void findMaxDifference ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int Leftsum = 0 ; int Totalsum = 0 ; int Minn = Int32 . MaxValue , Maxx = Int32 . MinValue ; for ( int i = 0 ; i < n ; i ++ ) Totalsum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int leftNumbers = i ; int rightNumbers = n - i - 1 ; Totalsum = Totalsum - arr [ i ] ; int sum = ( leftNumbers * arr [ i ] ) - Leftsum + Totalsum - ( rightNumbers * arr [ i ] ) ; Minn = Math . Min ( Minn , sum ) ; Maxx = Math . Max ( Maxx , sum ) ; Leftsum += arr [ i ] ; } Console . WriteLine ( Maxx - Minn ) ; }
bool sameStrings ( string str1 , string str2 ) { int N = str1 . Length ; int M = str2 . Length ; if ( N != M ) { return false ; } int [ ] a = new int [ 256 ] ; int [ ] b = new int [ 256 ] ; for ( int j = 0 ; j < N ; j ++ ) { a [ str1 [ j ] - 'a' ] ++ ; b [ str2 [ j ] - 'a' ] ++ ; } int i = 0 ; while ( i < 256 ) { if ( ( a [ i ] == 0 && b [ i ] == 0 ) || ( a [ i ] != 0 && b [ i ] != 0 ) ) { i ++ ; } else { return false ; } } Array . Sort ( a ) ; Array . Sort ( b ) ; for ( int j = 0 ; j < 256 ; j ++ ) { if ( a [ j ] != b [ j ] ) return false ; } return true ; }
int minSteps ( StringBuilder A , StringBuilder B , int M , int N ) { if ( A [ 0 ] > B [ 0 ] ) return 0 ; if ( B [ 0 ] > A [ 0 ] ) { return 1 ; } if ( M <= N && A [ 0 ] == B [ 0 ] && count ( A , A [ 0 ] ) == M && count ( B , B [ 0 ] ) == N ) return - 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] > B [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] < A [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] > A [ 0 ] ) { swap ( A , i , B , 0 ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } } for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] < B [ 0 ] ) { swap ( A , 0 , B , i ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } } return 0 ; }
int merge ( int [ ] A , int left , int mid , int right ) { int swaps = 0 ; int i = left , j = mid , k = left ; while ( i < mid && j <= right ) { if ( A [ i ] <= A [ j ] ) { temp [ k ] = A [ i ] ; k ++ ; i ++ ; } else { temp [ k ] = A [ j ] ; k ++ ; j ++ ; swaps += mid - i ; } } while ( i < mid ) { temp [ k ] = A [ i ] ; k ++ ; i ++ ; } while ( j <= right ) { temp [ k ] = A [ j ] ; k ++ ; j ++ ; } while ( left <= right ) { A [ left ] = temp [ left ] ; left ++ ; } return swaps ; }
int mergeInsertionSwap ( int [ ] A , int left , int right ) { int swaps = 0 ; if ( left < right ) { int mid = left + ( right - left ) / 2 ; swaps += mergeInsertionSwap ( A , left , mid ) ; swaps += mergeInsertionSwap ( A , mid + 1 , right ) ; swaps += merge ( A , left , mid + 1 , right ) ; } return swaps ; }
bool findAns ( int [ ] A , int N , int X ) { if ( check ( A , X ) ) { return true ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int gcd = gcdFoo ( A [ i ] , A [ j ] ) ; if ( gcd != 1 ) { if ( gcd <= X ) { return true ; } } } } return false ; }
string check ( int [ ] a , int [ ] b , int Na , int Nb , int k , int m ) { if ( Na < k < m ) return "No" ; Array . Sort ( a ) ; Array . Sort ( b ) ; if ( a [ k - 1 ] < b [ Nb - m ] ) { return "Yes" ; } return "No" ; }
int splitArray ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int result = Int32 . MaxValue ; for ( int i = 1 ; i < N ; i ++ ) { result = Math . Min ( result , arr [ i ] ^ arr [ i - 1 ] ) ; } return result ; }
int maxCntRemovedfromArray ( int [ ] arr , int N , int [ ] brr , int M ) { Array . Sort ( arr ) ; int i = 0 ; int sumArr = 0 ; for ( i = 0 ; i < N ; i ++ ) { sumArr += arr [ i ] ; } int sumBrr = 0 ; for ( i = 0 ; i < M ; i ++ ) { sumBrr += brr [ i ] ; } int cntRemElem = 0 ; while ( i < N && sumArr >= sumBrr ) { sumArr -= arr [ i ] ; i += 1 ; if ( sumArr >= sumBrr ) { cntRemElem += 1 ; } } return cntRemElem ; }
void findPair ( pair [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int a = arr [ i ] . first , b = arr [ i ] . second ; for ( int j = i + 1 ; j < N ; j ++ ) { int c = arr [ j ] . first , d = arr [ j ] . second ; if ( a < c && b > d ) { Console . WriteLine ( "(" + a + " " + b + "), (" + c + " " + d + ")" ) ; return ; } } } Console . WriteLine ( "NO SUCH PAIR EXIST" ) ; }
void printOrder ( int [ ] order , int N , int X ) { List < Tuple < int , int > > vect = new List < Tuple < int , int > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( order [ i ] % X == 0 ) { vect . Add ( new Tuple < int , int > ( ( order [ i ] / X ) , i + 1 ) ) ; } else { vect . Add ( new Tuple < int , int > ( ( order [ i ] / X + 1 ) , i + 1 ) ) ; } } vect . Sort ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( vect [ i ] . Item2 + " " ) ; } Console . WriteLine ( ) ; }
int CountMaximum ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
int CountMaximum ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
void numOperation ( int [ ] arr , int N , int D ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ( arr [ i + 1 ] - arr [ i ] ) % D != 0 ) { Console . WriteLine ( "-1" ) ; return ; } } int count = 0 ; int mid = arr [ N / 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { count += Math . Abs ( mid - arr [ i ] ) / D ; } Console . WriteLine ( count ) ; }
void findSum ( int [ ] A , int N , int K ) { Array . Sort ( A ) ; int sum = 0 ; for ( int i = N / K ; i < N ; i += K - 1 ) { sum += A [ i ] ; } Console . Write ( sum ) ; }
int maxcntPairsSumKRemoved ( int [ ] arr , int k ) { int cntPairs = 0 ; if ( arr . Length <= 1 ) return cntPairs ; Array . Sort ( arr ) ; int left = 0 ; int right = arr . Length - 1 ; while ( left < right ) { int s = arr [ left ] + arr [ right ] ; if ( s == k ) { cntPairs += 1 ; left += 1 ; right -= 1 ; } else if ( s > k ) right -= 1 ; else left += 1 ; } return cntPairs ; }
void selectionSort ( int [ ] arr , int n ) { int i , j , min_idx ; for ( i = 0 ; i < n - 1 ; i ++ ) { min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; int temp = arr [ min_idx ] ; arr [ min_idx ] = arr [ i ] ; arr [ i ] = temp ; } }
int findSmallestNumLeft ( int [ ] arr , int N ) { List < int > PQ = new List < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { PQ . Add ( arr [ i ] ) ; } PQ . Sort ( ) ; PQ . Reverse ( ) ; while ( PQ . Count > 1 ) { int top1 = PQ [ 0 ] ; PQ . RemoveAt ( 0 ) ; int top2 = PQ [ 0 ] ; PQ . RemoveAt ( 0 ) ; PQ . Add ( ( top1 + top2 + 1 ) / 2 ) ; PQ . Sort ( ) ; PQ . Reverse ( ) ; } return PQ [ 0 ] ; }
int digitProduct ( int number ) { int product = 1 ; while ( number > 0 ) { product *= ( number % 10 ) ; number /= 10 ; } return product ; }
bool compositedigitProduct ( int num ) { int res = digitProduct ( num ) ; if ( res == 1 ) { return false ; } if ( isComposite ( res ) ) { return true ; } return false ; }
int largestCompositeDigitProduct ( int [ ] a , int n , int k ) { List < pair > pq = new List < pair > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i % k ) == 0 ) { continue ; } if ( compositedigitProduct ( a [ i ] ) ) { int b = digitProduct ( a [ i ] ) ; pq . Add ( new pair ( b , a [ i ] ) ) ; } } pq . Sort ( ) ; return pq [ pq . Count - 1 ] . second ; }
void maxSum ( int [ ] arr , int [ ] brr , int N , int K ) { List < int > crr = new List < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { crr . Add ( arr [ i ] ) ; } for ( int i = 0 ; i < K ; i ++ ) { crr . Add ( brr [ i ] ) ; } crr . Sort ( ) ; crr . Reverse ( ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( crr [ i ] > 0 ) { sum += crr [ i ] ; } else { break ; } } Console . WriteLine ( sum ) ; }
void findMinimum ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; int ans = 0 ; for ( int i = 1 ; i < 2 * ( N / K ) ; i += 2 ) { ans += arr [ i ] ; } Console . WriteLine ( ans ) ; }
void findSubarrays ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int i = 0 ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { Console . WriteLine ( "YES" ) ; return ; } } Console . WriteLine ( "NO" ) ; }
void maxFreqElements ( int [ ] arr , int N , int K ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] ++ ; } else { mp [ arr [ i ] ] = 1 ; } } while ( K > 0 ) { int max = 0 ; int element = 0 ; foreach ( KeyValuePair < int , int > i in mp ) { if ( i . Value > max ) { max = i . Value ; element = i . Key ; } } Console . Write ( element + " " ) ; if ( mp . ContainsKey ( element ) ) { mp [ element ] -- ; } else { mp [ element ] = - 1 ; } K -- ; } }
void getPairs ( int [ ] arr , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } Console . Write ( count ) ; }
int merge ( int [ ] arr , int [ ] temp , int l , int m , int r , int K ) { int i = l ; int j = m + 1 ; int cnt = 0 ; for ( i = l ; i <= m ; i ++ ) { bool found = false ; while ( j <= r ) { if ( arr [ i ] >= K * arr [ j ] ) { found = true ; } else break ; j ++ ; } if ( found == true ) { cnt += j - ( m + 1 ) ; j -- ; } } int k = l ; i = l ; j = m + 1 ; while ( i <= m && j <= r ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else temp [ k ++ ] = arr [ j ++ ] ; } while ( i <= m ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= r ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = l ; i <= r ; i ++ ) arr [ i ] = temp [ i ] ; return cnt ; }
void mergeSort ( int [ ] arr , int N , int K ) { int [ ] temp = new int [ N ] ; Console . WriteLine ( mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ) ; }
void Selection_Sort ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { int min_index = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( arr [ j ] < arr [ min_index ] ) min_index = j ; } int temp = arr [ i ] ; arr [ i ] = arr [ min_index ] ; arr [ min_index ] = temp ; } }
void Bubble_Sort ( int [ ] arr , int n ) { bool flag ; for ( int i = 1 ; i < n ; ++ i ) { flag = false ; for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; flag = true ; } } if ( flag == false ) break ; } }
void NDivKWithFreq ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < N ; ) { int cnt = 1 ; while ( ( i + 1 ) < N && arr [ i ] == arr [ i + 1 ] ) { cnt ++ ; i ++ ; } if ( cnt > ( N / K ) ) { Console . Write ( arr [ i ] + " " ) ; } i ++ ; } }
int upperBound ( int [ ] arr , int N , int K ) { int l = 0 ; int r = N ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( arr [ mid ] <= K ) { l = mid + 1 ; } else { r = mid ; } } return l ; }
void NDivKWithFreq ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; int i = 0 ; while ( i < N ) { int X = upperBound ( arr , N , arr [ i ] ) ; if ( ( X - i ) > N / 4 ) { Console . Write ( arr [ i ] + " " ) ; } i = X ; } }
bool checkSubsetSum ( int [ ] A , int [ ] B , int N , int K ) { Array . Sort ( A ) ; Array . Sort ( B ) ; reverse ( B ) ; int sum1 = 0 ; int sum2 = 0 ; for ( int i = 0 ; i < K ; i ++ ) { sum1 += A [ i ] ; sum2 += B [ i ] ; } if ( sum1 > sum2 ) { return true ; } return false ; }
void printCircularArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
void sortCircularArray ( int [ ] arr , int n , int k , int m ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int j = k ; j < k + m - 1 ; j ++ ) { if ( arr [ j % n ] > arr [ ( j + 1 ) % n ] ) { int t = arr [ j % n ] ; arr [ j % n ] = arr [ ( j + 1 ) % n ] ; arr [ ( j + 1 ) % n ] = t ; } } } printCircularArray ( arr , n ) ; }
void rearrangeArray ( int [ ] a , int n ) { Array . Sort ( a ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] == i + 1 ) { int temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; } } if ( a [ n - 1 ] == n ) { int temp = a [ n - 1 ] ; a [ n - 1 ] = a [ n - 2 ] ; a [ n - 2 ] = temp ; } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( a [ i ] + " " ) ; } }
int maximumKthLargestsumPart ( int [ ] arr , int N , int M , int K ) { int maxSum = 0 ; if ( N % M != 0 ) return - 1 ; int sz = ( N / M ) ; if ( K > sz ) return - 1 ; Array . Sort ( arr ) ; Array . Reverse ( arr ) ; for ( int i = 1 ; i <= M ; i ++ ) { maxSum += arr [ i * K - 1 ] ; } return maxSum ; }
void splitArray ( int [ ] arr , int n , int K ) { Array . Sort ( arr ) ; int i = n - 1 ; int result = 0 ; while ( K -- != 0 ) { result += arr [ i - 1 ] ; i -= 2 ; } Console . Write ( result ) ; }
void merge ( int [ ] indices , int [ ] a , int l , int mid , int r ) { int [ ] temp_ind = new int [ r - l + 1 ] ; int j = mid + 1 ; int i = 0 , temp_l = l , k ; while ( l <= mid && j <= r ) { if ( a [ indices [ l ] ] < a [ indices [ j ] ] ) temp_ind [ i ++ ] = indices [ l ++ ] ; else temp_ind [ i ++ ] = indices [ j ++ ] ; } while ( l <= mid ) temp_ind [ i ++ ] = indices [ l ++ ] ; while ( j <= r ) temp_ind [ i ++ ] = indices [ j ++ ] ; for ( k = 0 ; k < i ; k ++ ) indices [ temp_l ++ ] = temp_ind [ k ] ; }
void divide ( int [ ] indices , int [ ] a , int l , int r ) { if ( l >= r ) return ; int mid = l / 2 + r / 2 ; divide ( indices , a , l , mid ) ; divide ( indices , a , mid + 1 , r ) ; merge ( indices , a , l , mid , r ) ; }
void noOfSubsequences ( int [ ] arr , int N ) { int [ ] indices = new int [ N ] ; int i ; for ( i = 0 ; i < N ; i ++ ) indices [ i ] = i ; divide ( indices , arr , 0 , N - 1 ) ; int [ ] B = new int [ N ] ; int subseq = 1 ; for ( i = 0 ; i < N ; i ++ ) { B [ indices [ i ] ] = subseq ; subseq *= 2 ; } for ( i = 0 ; i < N ; i ++ ) Console . Write ( B [ i ] + " " ) ; }
bool checkStr1CanConStr2 ( String str1 , String str2 ) { int N = str1 . Length ; int M = str2 . Length ; HashSet < int > st1 = new HashSet < int > ( ) ; HashSet < int > st2 = new HashSet < int > ( ) ; int [ ] hash1 = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { hash1 [ str1 [ i ] ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { st1 . Add ( str1 [ i ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { st2 . Add ( str2 [ i ] ) ; } if ( st1 . Equals ( st2 ) ) { return false ; } int [ ] hash2 = new int [ 256 ] ; for ( int i = 0 ; i < M ; i ++ ) { hash2 [ str2 [ i ] ] ++ ; } Array . Sort ( hash1 ) ; Array . Sort ( hash2 ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( hash1 [ i ] != hash2 [ i ] ) { return false ; } } return true ; }
void sortArrayInDescAsc ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; int temp = 0 ; for ( int i = K ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
int maxCostToRemove ( int [ ] arr , int N , int K ) { int maxCost = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < N ; i += K ) { maxCost += arr [ i + 1 ] ; } return maxCost ; }
void lexNumbers ( int n ) { List < String > s = new List < String > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { s . Add ( convert_to_words ( i ) ) ; } s . Sort ( ) ; List < String > ans = new List < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ans . Add ( s [ i ] ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) Console . Write ( ans [ i ] + ", " ) ; Console . Write ( ans [ n - 1 ] ) ; }
void minimumCost ( int [ ] binary , int n , int a , int b ) { List < int > groupOfZeros = new List < int > ( ) ; int len = 0 , i = 0 ; bool increment_need = true ; while ( i < n ) { increment_need = true ; while ( i < n && binary [ i ] == 0 ) { len ++ ; i ++ ; increment_need = false ; } if ( increment_need == true ) { i ++ ; } if ( len != 0 ) { groupOfZeros . Add ( len ) ; } len = 0 ; } groupOfZeros . Sort ( ) ; i = 0 ; bool found_ones = false ; int NumOfOnes = 0 ; while ( i < n ) { found_ones = false ; while ( i < n && binary [ i ] == 1 ) { i ++ ; found_ones = true ; } if ( found_ones == false ) i ++ ; else NumOfOnes ++ ; } int ans = int . MaxValue ; for ( int i1 = 0 ; i1 < n ; i1 ++ ) { int curr = 0 , totalOnes = NumOfOnes ; if ( i1 == 0 ) { curr = totalOnes * a ; } else { int mark = i1 , num_of_changes = 0 ; foreach ( int x in groupOfZeros ) { if ( mark >= x ) { totalOnes -- ; mark -= x ; num_of_changes += x ; } else { break ; } } curr = ( num_of_changes * b ) + ( totalOnes * a ) ; } ans = Math . Min ( ans , curr ) ; } Console . WriteLine ( ans ) ; }
int isSortedparitions ( int [ ] arr , int i , int j ) { for ( int k = i + 1 ; k <= j ; k ++ ) { if ( arr [ k ] < arr [ k - 1 ] ) { return 0 ; } } return 1 ; }
int partitionsArr ( int [ ] arr , int i , int j ) { if ( i >= j ) return 1 ; int flag = ( int ) isSortedparitions ( arr , i , j ) ; if ( flag != 0 ) { return ( j - i + 1 ) ; } int mid = ( i + j ) / 2 ; int X = partitionsArr ( arr , i , mid ) ; int Y = partitionsArr ( arr , mid + 1 , j ) ; return Math . Max ( X , Y ) ; }
bool checkIfPossibleMerge ( int [ ] A , int [ ] B , int N ) { int i = 0 ; int j = 0 ; int prev = - 1 ; bool flag = true ; while ( i < N && j < N ) { if ( A [ i ] < B [ j ] && prev != 0 ) { prev = 0 ; i ++ ; } else if ( B [ j ] < A [ i ] && prev != 1 ) { prev = 1 ; j ++ ; } else if ( A [ i ] == B [ j ] ) { if ( prev != 1 ) { prev = 1 ; j ++ ; } else { prev = 0 ; i ++ ; } } else { flag = false ; break ; } } return flag ; }
int maxSum ( int n , int [ ] a , int [ , ] l , int q ) { List < int > v = new List < int > ( ) ; int [ ] d = new int [ n ] ; for ( int i = 0 ; i < q ; i ++ ) { for ( int x = l [ i , 0 ] ; x <= l [ i , 1 ] ; x ++ ) { if ( d [ x ] == 0 ) { d [ x ] = 1 ; } } } HashSet < int > st = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] == 0 ) { v . Add ( a [ i ] ) ; st . Add ( i ) ; } } v . Sort ( ) ; v . Reverse ( ) ; int c = 0 ; foreach ( int it in st ) { a [ it ] = v ; c ++ ; } int pref_sum = 0 ; int temp_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp_sum += a [ i ] ; pref_sum += temp_sum ; } return pref_sum ; }
void countPairs ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int xo = ( A [ i ] ^ A [ j ] ) ; int mx = Math . Max ( A [ i ] , A [ j ] ) ; if ( xo > mx ) { count ++ ; } } } Console . WriteLine ( count ) ; }
int findMedianOfsubSum ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } Array . Sort ( arr ) ; int [ , ] dp = new int [ N , sum + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < sum + 1 ; j ++ ) dp [ i , j ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { dp [ i , 0 ] = 1 ; } dp [ 0 , arr [ 0 ] ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j >= arr [ i ] ) { dp [ i , j ] = dp [ i - 1 , j ] + dp [ i - 1 , j - arr [ i ] ] ; } else { dp [ i , j ] = dp [ i - 1 , j ] ; } } } List < int > sumSub = new List < int > ( ) ; for ( int j = 1 ; j <= sum ; j ++ ) { int M = dp [ N - 1 , j ] ; for ( int i = 1 ; i <= M ; i ++ ) { sumSub . Add ( j ) ; } } int mid = sumSub [ sumSub . Count / 2 ] ; return mid ; }
int maxDiffLargSmallOper ( int [ ] arr , int N , int K ) { int maxDiff = 0 ; Array . Sort ( arr ) ; Array . Reverse ( arr ) ; for ( int i = 0 ; i <= Math . Min ( K , N - 1 ) ; i ++ ) { maxDiff += arr [ i ] ; } return maxDiff ; }
void findTheOrder ( int [ ] arr , string s , int N ) { List < int > ans = new List < int > ( ) ; Tuple < int , int > [ ] A = new Tuple < int , int > [ N ] ; for ( int i = 0 ; i < N ; i ++ ) A [ i ] = new Tuple < int , int > ( arr [ i ] , i + 1 ) ; Array . Sort ( A ) ; List < Tuple < int , int > > q = new List < Tuple < int , int > > ( ) ; int index = 0 ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( s [ i ] == '0' ) { ans . Add ( A [ index ] . Item2 ) ; q . Add ( A [ index ] ) ; q . Sort ( ) ; q . Reverse ( ) ; index ++ ; } else { ans . Add ( q [ 0 ] . Item2 ) ; q . RemoveAt ( 0 ) ; } } foreach ( int i in ans ) { Console . Write ( i + " " ) ; } }
void checkArrangement ( int [ ] A1 , int [ ] A2 , int n , int k ) { Array . Sort ( A1 ) ; Array . Sort ( A2 ) ; Array . Reverse ( A2 ) ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) Console . WriteLine ( "No" ) ; else Console . WriteLine ( "Yes" ) ; }
int MaxRearrngeSum ( int [ ] A , int [ ] B , int N ) { Array . Sort ( A ) ; Array . Sort ( B ) ; Array . Reverse ( B ) ; int maxSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { maxSum += Math . Abs ( A [ i ] - B [ i ] ) ; } return maxSum ; }
int largestArea ( int [ ] arr1 , int n , int [ ] arr2 , int m ) { int end = 0 , start = 0 , i = 0 , j = 0 ; Array . Sort ( arr1 ) ; Array . Sort ( arr2 ) ; while ( i < n && j < m ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( start == 0 ) start = arr1 [ i ] ; else end = arr1 [ i ] ; i ++ ; j ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) j ++ ; else i ++ ; } if ( end == 0 start == 0 ) return 0 ; else return ( end - start ) ; }
int count_pairs ( int [ ] arr , int [ ] brr , int N , int M , int K ) { int i = 0 ; int j = 0 ; int cntPairs = 0 ; Array . Sort ( arr ) ; Array . Sort ( brr ) ; while ( i < N && j < M ) { if ( brr [ j ] - arr [ i ] > K ) { cntPairs += ( M - j ) ; i ++ ; } else { j ++ ; } } return cntPairs ; }
void firstSubsequence ( string s ) { List < string > allsubseq = new List < string > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { string k = "" ; for ( int j = 0 ; j < s . Length ; j ++ ) { if ( i != j ) { k += s [ j ] ; } } allsubseq . Add ( k ) ; } allsubseq . Sort ( ) ; Console . WriteLine ( allsubseq [ 0 ] ) ; }
void firstSubsequence ( String s ) { int isMax = - 1 ; for ( int i = 0 ; i < s . Length - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) { isMax = i ; break ; } } if ( isMax >= 0 ) { s = s . Substring ( 0 , isMax ) + s . Substring ( isMax + 1 ) ; s . rerase ( isMax , 1 ) ; } else { s . erase ( s . Length - 1 , 1 ) ; s = s . Substring ( 0 , s . Length - 1 ) ; } Console . Write ( s ) ; }
void minHeapify ( int [ ] brr , int i , int M ) { int left = 2 * i + 1 ; int right = 2 * i + 2 ; int smallest = i ; if ( left < M && brr [ left ] < brr [ smallest ] ) { smallest = left ; } if ( right < M && brr [ right ] < brr [ smallest ] ) { smallest = right ; } if ( smallest != i ) { int temp = brr [ i ] ; brr [ i ] = brr [ smallest ] ; brr [ smallest ] = temp ; minHeapify ( brr , smallest , M ) ; } }
void merge ( int [ ] arr , int [ ] brr , int N , int M ) { for ( int i = 0 ; i < N ; ++ i ) { if ( arr [ i ] > brr [ 0 ] ) { int temp = arr [ i ] ; arr [ i ] = brr [ 0 ] ; brr [ 0 ] = temp ; minHeapify ( brr , 0 , M ) ; } } Array . Sort ( brr ) ; }
void printArray ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
int rankLessThanK ( int [ ] arr , int k , int n ) { int rank = 1 ; int position = 1 ; Array . Sort ( arr ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i == n - 1 arr [ i ] != arr [ i + 1 ] ) { rank = position ; if ( rank > k ) return position - 1 ; } position ++ ; } return n ; }
void calculateFib ( int [ ] fib , int n ) { fib [ 0 ] = fib [ 1 ] = 1 ; for ( int x = 2 ; x < n ; x ++ ) { fib [ x ] = fib [ x - 1 ] + fib [ x - 2 ] ; } }
int find_mth_bit ( int n , int m , int [ ] fib ) { if ( n <= 1 ) { return n ; } int len_left = fib [ n - 2 ] ; int len_right = fib [ n - 1 ] ; if ( m <= len_left ) { return find_mth_bit ( n - 2 , len_left + 1 - m , fib ) ; } else { return find_mth_bit ( n - 1 , len_right + 1 - ( m - len_left ) , fib ) ; } }
int KthSmallestNum ( int [ , ] arr , int n , int k ) { ArrayList pq = new ArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { pq . Add ( new Tuple < int , int > ( arr [ i , 0 ] , arr [ i , 1 ] ) ) ; } int cnt = 1 ; while ( cnt < k ) { pq . Sort ( ) ; pq . Reverse ( ) ; Tuple < int , int > interval = ( Tuple < int , int > ) pq [ 0 ] ; pq . RemoveAt ( 0 ) ; if ( interval . Item1 < interval . Item2 ) { pq . Add ( new Tuple < int , int > ( interval . Item1 + 1 , interval . Item2 ) ) ; } cnt += 1 ; } pq . Sort ( ) ; pq . Reverse ( ) ; return ( ( Tuple < int , int > ) pq [ 0 ] ) . Item1 + 1 ; }
void maxArea ( int [ ] point_x , int [ ] point_y , int n , int length , int width ) { Array . Sort ( point_x ) ; Array . Sort ( point_y ) ; int dx = point_x [ 0 ] ; int dy = point_y [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dx = Math . Max ( dx , point_x [ i ] - point_x [ i - 1 ] ) ; dy = Math . Max ( dy , point_y [ i ] - point_y [ i - 1 ] ) ; } dx = Math . Max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) ; dy = Math . Max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) ; Console . WriteLine ( ( dx - 1 ) * ( dy - 1 ) ) ; }
int LongestSequence ( int [ ] a , int n ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; int [ ] ar = new int [ n + 1 ] ; int i = 0 ; int j = 0 ; for ( i = 1 ; i <= n ; i ++ ) { ar [ i ] = a [ i - 1 ] ; } Array . Sort ( a ) ; int c = 1 ; m [ a [ 0 ] ] = c ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) { c ++ ; m [ a [ i ] ] = c ; } } Dictionary < int , int > cnt = new Dictionary < int , int > ( ) ; int [ , ] dp = new int [ n + 1 , 3 ] ; cnt [ 0 ] = 0 ; for ( i = 1 ; i <= n ; i ++ ) { ar [ i ] = m [ ar [ i ] ] ; if ( cnt . ContainsKey ( ar [ i ] ) ) cnt [ ar [ i ] ] = cnt [ ar [ i ] ] + 1 ; else cnt [ ar [ i ] ] = 1 ; } int ans = 0 , x ; for ( i = 1 ; i <= n ; i ++ ) { x = ar [ i ] ; if ( dp [ x , 0 ] == 0 ) { if ( dp [ x - 1 , 0 ] == cnt [ x - 1 ] ) { dp [ x , 1 ] = dp [ x - 1 , 1 ] ; dp [ x , 2 ] = dp [ x - 1 , 1 ] ; } else { dp [ x , 1 ] = dp [ x - 1 , 0 ] ; } } dp [ x , 2 ] = Math . Max ( dp [ x - 1 , 0 ] , dp [ x , 2 ] ) ; if ( dp [ x - 1 , 0 ] == cnt [ x - 1 ] ) { dp [ x , 2 ] = Math . Max ( dp [ x , 2 ] , dp [ x - 1 , 1 ] ) ; } for ( j = 0 ; j < 3 ; j ++ ) { dp [ x , j ] ++ ; ans = Math . Max ( ans , dp [ x , j ] ) ; } } return ans ; }
int solve ( ArrayList values , ArrayList salary ) { int ret = 1 ; int amt = 0 ; values . Sort ( ) ; salary . Sort ( ) ; while ( salary . Count > 0 ) { while ( values . Count > 0 && ( int ) values [ values . Count - 1 ] >= ( int ) salary [ salary . Count - 1 ] ) { amt ++ ; values . RemoveAt ( values . Count - 1 ) ; } if ( amt == 0 ) return 0 ; ret *= amt -- ; ret %= MOD ; salary . RemoveAt ( salary . Count - 1 ) ; } return ret ; }
void precompute_sum ( int [ ] arr , int [ ] brr ) { int N = ( int ) arr . Length ; for ( int i = 1 ; i < N ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; brr [ i ] = brr [ i ] + brr [ i - 1 ] ; } }
void find_sum ( int [ ] arr , int q , int [ , ] Queries ) { int [ ] brr = new int [ arr . Length ] ; arr . CopyTo ( brr , 0 ) ; int N = ( int ) arr . Length ; Array . Sort ( brr ) ; precompute_sum ( arr , brr ) ; for ( int i = 0 ; i < q ; i ++ ) { int m = Queries [ i , 0 ] ; int a = Queries [ i , 1 ] ; int b = Queries [ i , 2 ] ; if ( m == 1 ) { Console . Write ( range_sum ( arr , a , b ) + " " ) ; } else if ( m == 2 ) { Console . Write ( range_sum ( brr , a , b ) + " " ) ; } } }
int minsteps ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += Math . Abs ( arr [ i ] - ( int ) ( Math . Pow ( 2 , i ) ) ) ; } return ans ; }
int findCost ( int [ ] a , int n ) { Array . Sort ( a ) ; Array . Reverse ( a ) ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int p = a [ j ] - j ; a [ j ] = 0 ; if ( p < 0 ) { p = 0 ; continue ; } count += p ; } return count ; }
int make_cuts ( int [ ] arr , int n , int K ) { int ans = 0 ; List < int > poss = new List < int > ( ) ; int ce = 0 ; int co = 0 ; for ( int x = 0 ; x < n - 1 ; x ++ ) { if ( arr [ x ] % 2 == 0 ) ce ++ ; else co ++ ; if ( ce == co && co > 0 && ce > 0 ) { poss . Add ( Math . Abs ( arr [ x ] - arr [ x + 1 ] ) ) ; } } poss . Sort ( ) ; foreach ( int x in poss ) { if ( K >= x ) { ans ++ ; K -= x ; } else break ; } return ans ; }
void Arrange ( int [ ] arr , int n ) { int cost = 0 ; Dictionary < int , int > index = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { index . Add ( arr [ i ] , i ) ; } Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] > arr [ i + 1 ] + arr [ n - 1 ] ) { Console . Write ( "-1" ) ; return ; } else { cost += Math . Abs ( index [ arr [ i ] ] - i ) ; } } else if ( i == n - 1 ) { if ( arr [ i ] > arr [ i - 1 ] + arr [ 0 ] ) { Console . Write ( "-1" ) ; return ; } else { cost += Math . Abs ( index [ arr [ i ] ] - i ) ; } } else { if ( arr [ i ] > arr [ i - 1 ] + arr [ i + 1 ] ) { Console . Write ( "-1" ) ; return ; } else { cost += Math . Abs ( index [ arr [ i ] ] - i ) ; } } } Console . Write ( cost ) ; return ; }
int maxDistinctChar ( char [ ] s , int n , int k ) { Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . ContainsKey ( ( int ) s [ i ] ) ) { freq [ ( int ) s [ i ] ] = freq [ ( int ) s [ i ] ] + 1 ; } else { freq . Add ( ( int ) s [ i ] , 1 ) ; } } List < int > v = new List < int > ( ) ; foreach ( KeyValuePair < int , int > it in freq ) { v . Add ( it . Value ) ; } v . Sort ( ) ; for ( int i = 0 ; i < v . Count ; i ++ ) { int mn = Math . Min ( v [ i ] - 1 , k ) ; v [ i ] = v [ i ] - mn ; k -= mn ; } if ( k > 0 ) { for ( int i = 0 ; i < v . Count ; i ++ ) { int mn = Math . Min ( v [ i ] , k ) ; v [ i ] = v [ i ] - mn ; k -= mn ; } } int res = 0 ; for ( int i = 0 ; i < v . Count ; i ++ ) if ( v [ i ] == 1 ) res ++ ; return res ; }
int getMaxSum ( int i , int j , int k , int [ ] arr1 , int [ ] arr2 , int [ ] arr3 ) { int cnt = 0 ; if ( i >= n1 ) cnt ++ ; if ( j >= n2 ) cnt ++ ; if ( k >= n3 ) cnt ++ ; if ( cnt >= 2 ) return 0 ; if ( dp [ i , j , k ] != - 1 ) return dp [ i , j , k ] ; int ans = 0 ; if ( i < n1 && j < n2 ) ans = Math . Max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) ; if ( i < n1 && k < n3 ) ans = Math . Max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) ; if ( j < n2 && k < n3 ) ans = Math . Max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) ; dp [ i , j , k ] = ans ; return dp [ i , j , k ] ; }
int maxProductSum ( int [ ] arr1 , int [ ] arr2 , int [ ] arr3 ) { for ( int i = 0 ; i < maxN ; i ++ ) for ( int j = 0 ; j < maxN ; j ++ ) for ( int k = 0 ; k < maxN ; k ++ ) dp [ i , j , k ] = - 1 ; Array . Sort ( arr1 ) ; reverse ( arr1 ) ; Array . Sort ( arr2 ) ; reverse ( arr2 ) ; Array . Sort ( arr3 ) ; reverse ( arr3 ) ; return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) ; }
void SieveOfEratosthenes ( ) { bool [ ] prime = new bool [ 10005 ] ; for ( int i = 0 ; i < 10005 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= 1000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 1000 ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= 1000 ; p ++ ) if ( prime [ p ] ) primes . Add ( p ) ; }
int findMaxValue ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int ans = arr [ n - 1 ] ; int maxPossible = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( maxPossible > 0 ) { if ( arr [ i ] >= maxPossible ) { ans += ( maxPossible - 1 ) ; maxPossible = maxPossible - 1 ; } else { maxPossible = arr [ i ] ; ans += maxPossible ; } } } return ans ; }
int countPairs ( int [ ] arr , int n ) { int ans = 0 ; Array . Sort ( arr ) ; int left = 0 , right = 1 ; while ( right < n ) { if ( arr [ left ] == arr [ right ] ) ans += right - left ; else left = right ; right ++ ; } return ans ; }
int maximizeFinalElement ( int [ ] arr , int n ) { Array . Sort ( arr ) ; if ( arr [ 0 ] != 1 ) arr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 1 ) { arr [ i ] = arr [ i - 1 ] + 1 ; } } return arr [ n - 1 ] ; }
int findLeastDist ( int [ ] A , int N ) { Array . Sort ( A ) ; if ( N % 2 == 0 ) { return A [ ( N - 1 ) / 2 ] ; } else { return A [ N / 2 ] ; } }
int maxSubMatSum ( int [ , ] mat ) { int n = mat . GetLength ( 0 ) ; int m = mat . GetLength ( 1 ) ; int i , j ; int [ , ] dp = new int [ n , m ] ; dp [ n - 1 , m - 1 ] = mat [ n - 1 , m - 1 ] ; int res = dp [ n - 1 , m - 1 ] ; for ( i = m - 2 ; i >= 0 ; i -- ) { dp [ n - 1 , i ] = mat [ n - 1 , i ] + dp [ n - 1 , i + 1 ] ; res = Math . Max ( res , dp [ n - 1 , i ] ) ; } for ( i = n - 2 ; i >= 0 ; i -- ) { dp [ i , m - 1 ] = mat [ i , m - 1 ] + dp [ i + 1 , m - 1 ] ; res = Math . Max ( res , dp [ i , m - 1 ] ) ; } for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = m - 2 ; j >= 0 ; j -- ) { dp [ i , j ] = mat [ i , j ] + dp [ i , j + 1 ] + dp [ i + 1 , j ] - dp [ i + 1 , j + 1 ] ; res = Math . Max ( res , dp [ i , j ] ) ; } } return res ; }
int solution ( int A , int B , int C ) { int [ ] arr = new int [ 3 ] ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; Array . Sort ( arr ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; }
long removeElements ( long [ ] arr , int n ) { Array . Sort ( arr ) ; arr = reverse ( arr ) ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( long ) ( arr [ i ] * Math . Pow ( 2 , i ) ) ; } return ans ; }
bool canMadeEqual ( int [ ] A , int [ ] B , int n ) { Array . Sort ( A ) ; Array . Sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != B [ i ] ) { return false ; } } return true ; }
int maxMinDifference ( int [ ] arr , int n , int k ) { if ( k >= n - 1 ) return 0 ; Array . Sort ( arr ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; for ( int i = k , j = n - 1 ; i >= 0 ; -- i , -- j ) { ans = Math . Min ( arr [ j ] - arr [ i ] , ans ) ; } return ans ; }
int inversionCount ( String s ) { int [ ] freq = new int [ 26 ] ; int inv = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < ( int ) ( s [ i ] - 'a' ) ; j ++ ) temp += freq [ j ] ; inv += ( i - temp ) ; freq [ s [ i ] - 'a' ] ++ ; } return inv ; }
int numberofpairs ( int [ ] arr , int N ) { int answer = 0 ; Array . Sort ( arr ) ; int minDiff = 10000000 ; for ( int i = 0 ; i < N - 1 ; i ++ ) minDiff = Math . Min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; }
long dist ( Tuple < int , int > p1 , Tuple < int , int > p2 ) { long x0 = p1 . Item1 - p2 . Item1 ; long y0 = p1 . Item2 - p2 . Item2 ; return x0 * x0 + y0 * y0 ; }
void maximumSum ( int [ ] arr , int n , int k ) { int elt = n / k ; int sum = 0 ; Array . Sort ( arr ) ; int count = 0 ; int i = n - 1 ; while ( count < k ) { sum += arr [ i ] ; i -- ; count ++ ; } count = 0 ; i = 0 ; while ( count < k ) { sum += arr [ i ] ; i += elt - 1 ; count ++ ; } Console . WriteLine ( sum ) ; }
int countMinSteps ( int [ ] arr , int target , int n ) { Array . Sort ( arr ) ; int minimumSteps = 0 ; int i = 0 ; int j = n - 1 ; while ( i <= j ) { if ( arr [ i ] + arr [ j ] <= target ) { i += 1 ; j -= 1 ; } else { j -= 1 ; } minimumSteps += 1 ; } return minimumSteps ; }
int build_num ( int [ ] bit ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) if ( bit [ i ] == 1 ) ans += ( 1 << i ) ; ans += 32 ; return ans ; }
int maximumOR ( int [ ] arr , int n , int k ) { int [ ] bit = new int [ 32 ] ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( bit [ i ] == 0 && k > 0 ) { int temp = build_num ( bit ) ; int temp1 = temp ; int val = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( temp1 < ( temp arr [ ] ) ) { = | [ ] ; = [ ] ; } } if ( != - 1 ) { k -- ; for ( int j = 0 ; j < 32 ; j ++ ) { bit [ j ] ++ ; } } } } return build_num ( bit ) ; } public static void Main ( ) { int [ ] arr = { 5 , 9 , 7 , 19 } ; int k = 3 ; int n = arr . Length ; Console . Write ( maximumOR ( arr , n , k ) ) ; } }
int findMinSum ( int [ ] arr , int K , int L , int size ) { if ( K * L > size ) return - 1 ; int minsum = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; }
void find_max_length ( int [ ] arr , int index , int sum , int k ) { sum = sum + arr [ index ] ; store . Add ( arr [ index ] ) ; if ( sum == k ) { if ( max_length < store . Count ) { max_length = store . Count ; ans = store ; } } for ( int i = index + 1 ; i < arr . Length ; i ++ ) { if ( sum + arr [ i ] <= k ) { find_max_length ( arr , i , sum , k ) ; store . RemoveAt ( store . Count - 1 ) ; } else return ; } return ; }
int longestSubsequence ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_length >= n - i ) break ; store . Clear ( ) ; find_max_length ( arr , i , 0 , k ) ; } return max_length ; }
void minBox ( int [ ] arr , int n ) { int box = n ; Array . Sort ( arr ) ; int curr_box = 0 , next_box = 1 ; while ( curr_box < n && next_box < n ) { if ( arr [ curr_box ] < arr [ next_box ] ) { box -- ; curr_box ++ ; next_box ++ ; } else if ( arr [ curr_box ] == arr [ next_box ] ) next_box ++ ; } Console . WriteLine ( box ) ; }
void setData ( node head ) { node tmp ; tmp = head ; while ( tmp != null ) { Console . Write ( tmp . data + " -> " ) ; tmp = tmp . next ; } }
double findMedian ( int [ ] a , int n ) { if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
void kStrongest ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int i = 0 ; double median = findMedian ( arr , n ) ; int [ ] diff = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) { diff [ i ] = ( int ) Math . Abs ( median - arr [ i ] ) ; } int j = n - 1 ; i = 0 ; while ( k > 0 ) { if ( diff [ i ] > diff [ j ] ) { Console . Write ( arr [ i ] + " " ) ; i ++ ; } else { Console . Write ( arr [ j ] + " " ) ; j -- ; } k -- ; } }
bool sorting_possible ( int [ ] a , int [ ] b , int n ) { bool sorted = true ; int type1 = 0 , type0 = 0 , i ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { sorted = false ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( b [ i ] == 0 ) type0 ++ ; else type1 ++ ; } if ( sorted ) return true ; else if ( type1 == n type0 == n ) return false ; else return true ; }
void lexNumbers ( int n ) { List < String > s = new List < String > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { s . Add ( String . Join ( "" , i ) ) ; } s . Sort ( ) ; List < int > ans = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ans . Add ( Int32 . Parse ( s [ i ] ) ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( ans [ i ] + " " ) ; }
void dfs ( int temp , int n , List < int > sol ) { if ( temp > n ) return ; sol . Add ( temp ) ; dfs ( temp * 10 , n , sol ) ; if ( temp % 10 != 9 ) dfs ( temp + 1 , n , sol ) ; }
int findMinDif ( int [ ] arr , int N ) { Array . Sort ( arr ) ; return ( arr [ N - 1 ] - arr [ N - 2 ] ) ; }
int partition ( int [ ] arr , int l , int h ) { int pivot = arr [ l ] ; int i = l + 1 ; int j = h ; while ( i <= j ) { while ( i <= h && arr [ i ] < pivot ) { i ++ ; } while ( j > l && arr [ j ] > pivot ) { j -- ; } if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i ++ ; j -- ; } else i ++ ; } arr [ l ] = arr [ j ] ; arr [ j ] = pivot ; return j ; }
void sortArray ( int [ ] arr , int l , int h ) { if ( l >= h ) return ; int pivot = partition ( arr , l , h ) ; sortArray ( arr , l , pivot - 1 ) ; sortArray ( arr , pivot + 1 , h ) ; }
int findMaxIntervals ( int [ ] start , int [ ] end , int n , int R ) { int ans = 0 ; int prev = 0 ; int currActive = 0 ; int i = 0 ; int j = 0 ; if ( start [ 0 ] > 0 ) ans ++ ; while ( i < n && j < n ) { if ( start [ i ] < end [ j ] ) { i ++ ; currActive ++ ; } else if ( start [ i ] > end [ j ] ) { j ++ ; currActive -- ; } else { i ++ ; j ++ ; } if ( currActive == 0 ) { ans ++ ; } } if ( end [ n - 1 ] < R ) ans ++ ; return ans ; }
void sortArray ( int [ ] A , int N ) { int x = 0 , y = 0 , z = 0 ; if ( N % 4 == 0 N % 4 == 1 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } Console . Write ( "Sorted Array: " ) ; for ( int i = 0 ; i < N ; i ++ ) Console . Write ( A [ i ] + " " ) ; } else { Console . Write ( "-1" ) ; } }
void check_vector ( int [ ] A , int n , int [ ] p ) { int [ ] pos = new int [ A . Length ] ; for ( int i = 0 ; i < p . Length ; i ++ ) { pos [ p [ i ] - 1 ] = 1 ; } int flag = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( pos [ i ] == 0 ) continue ; int j = i ; while ( j < n && pos [ j ] != 0 ) ++ j ; Array . Sort ( A , i , j + 1 ) ; i = j ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
void dfs ( int x ) { ArrayList v = new ArrayList ( ) ; ns . Clear ( ) ; foreach ( int it in s ) { if ( g [ x ] . ContainsKey ( it ) ) { v . Add ( it ) ; } else { ns . Add ( it ) ; } } s = ns ; foreach ( int i in v ) { dfs ( i ) ; } }
void weightOfMST ( int N ) { int cnt = 0 ; for ( int i = 1 ; i <= N ; ++ i ) { s . Add ( i ) ; } ArrayList qt = new ArrayList ( ) ; foreach ( int t in s ) qt . Add ( t ) ; while ( qt . Count != 0 ) { ++ cnt ; int t = ( int ) qt [ 0 ] ; qt . RemoveAt ( 0 ) ; dfs ( t ) ; } Console . Write ( cnt - 4 ) ; }
void sortDiff ( List < int > arr , int n ) { arr . Sort ( ) ; List < int > Out = new List < int > ( ) ; while ( n > 0 ) { Out . Add ( arr [ n / 2 ] ) ; arr . RemoveAt ( n / 2 ) ; n = n - 1 ; } foreach ( int i in Out ) Console . Write ( i + " " ) ; }
void minimumCost ( int [ ] arr , int N , int M ) { Array . Sort ( arr ) ; int [ ] pref = new int [ N ] ; pref [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { pref [ i ] = arr [ i ] + pref [ i - 1 ] ; } for ( int i = M ; i < N ; i ++ ) { pref [ i ] += pref [ i - M ] ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( pref [ i ] + " " ) ; } }
int countPairs ( int [ ] A , int [ ] B ) { int n = A . Length ; int ans = 0 ; Array . Sort ( A ) ; Array . Sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; }
int uniqueSum ( int [ ] A , int [ , ] R , int N , int M ) { for ( int i = 0 ; i < M ; ++ i ) { int l = R [ i , 0 ] , r = R [ i , 1 ] + 1 ; l -- ; r -- ; A [ l ] ++ ; if ( r < N ) A [ r ] -- ; } for ( int i = 1 ; i < N ; ++ i ) { A [ i ] += A [ i - 1 ] ; } int ans = 0 ; HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { if ( ! s . Contains ( A [ i ] ) ) ans += A [ i ] ; s . Add ( A [ i ] ) ; } return ans ; }
void kthpair ( int n , int k , int [ ] arr ) { int i , t = 0 ; Array . Sort ( arr ) ; -- k ; for ( i = 0 ; i < n ; i += t ) { for ( t = 1 ; arr [ i ] == arr [ i + t ] ; ++ t ) ; if ( t * n > k ) break ; k = k - t * n ; } Console . Write ( arr [ i ] + " " + arr [ k / t ] ) ; }
int minOperations ( String s ) { int [ ] freq = new int [ 26 ] ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { freq [ s [ i ] - 'A' ] ++ ; } Array . Sort ( freq ) ; Array . Reverse ( freq ) ; int answer = n ; for ( int i = 1 ; i <= 26 ; i ++ ) { if ( n % i == 0 ) { int x = n / i ; int y = 0 ; for ( int j = 0 ; j < i ; j ++ ) { y += Math . Min ( freq [ j ] , x ) ; } answer = Math . Min ( answer , n - y ) ; } } return answer ; }
void printArray ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
void sortArray ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; ) { if ( arr [ i ] == i + 1 ) { i ++ ; } else { int temp1 = arr [ i ] ; int temp2 = arr [ arr [ i ] - 1 ] ; arr [ i ] = temp2 ; arr [ temp1 - 1 ] = temp1 ; } } }
bool fun ( int [ ] arr , int n , int k ) { List < int > v = new List < int > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { v . Add ( arr [ j ] ) ; } v . Sort ( ) ; int x = 0 ; for ( int j = i ; j < n ; j += k ) { arr [ j ] = v [ x ] ; x ++ ; } v . Clear ( ) ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { return false ; } } return true ; }
void CheckSort ( ArrayList arr , int k , int n ) { ArrayList sortarr = new ArrayList ( arr ) ; sortarr . Sort ( ) ; if ( k == 1 ) Console . Write ( "yes" ) ; else { int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { flag = 0 ; for ( int j = i ; j < n ; j += k ) { if ( ( int ) sortarr [ i ] == ( int ) arr [ j ] ) { int tmp = ( int ) arr [ i ] ; arr [ i ] = ( int ) arr [ j ] ; arr [ j ] = tmp ; flag = 1 ; break ; } if ( j + k >= n ) { break ; } } if ( flag == 0 ) { break ; } } if ( flag == 0 ) Console . Write ( "Not possible to sort" ) ; else Console . Write ( "Possible to sort" ) ; } }
void sortedAdjacentDifferences ( int [ ] arr , int n ) { int [ ] ans = new int [ n ] ; Array . Sort ( arr ) ; int l = 0 , r = n - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 != 0 ) { ans [ i ] = arr [ l ] ; l ++ ; } else { ans [ i ] = arr [ r ] ; r -- ; } } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( ans [ i ] + " " ) ; } }
int get_permutation ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result += Math . Abs ( arr [ i ] - ( i + 1 ) ) ; } return result ; }
int minimumIncDec ( int [ ] arr , int N , int maxE , int minE ) { if ( N == 0 ) { return 0 ; } if ( dp [ N , maxE ] != 0 ) return dp [ N , maxE ] ; int ans = int . MaxValue ; for ( int k = minE ; k <= maxE ; k ++ ) { int x = minimumIncDec ( arr , N - 1 , k , minE ) ; ans = Math . Min ( ans , x + Math . Abs ( arr [ N - 1 ] - k ) ) ; } dp [ N , maxE ] = ans ; return dp [ N , maxE ] ; }
int maxSumArrangement ( int [ ] A , int [ , ] R , int N , int M ) { int [ ] count = new int [ N ] ; int i ; for ( i = 0 ; i < M ; ++ i ) { int l = R [ i , 0 ] , r = R [ i , 1 ] + 1 ; l -- ; r -- ; count [ l ] ++ ; if ( r < N ) count [ r ] -- ; } for ( i = 1 ; i < N ; ++ i ) { count [ i ] += count [ i - 1 ] ; } int ans = 0 ; Array . Sort ( count ) ; Array . Sort ( A ) ; for ( i = N - 1 ; i >= 0 ; -- i ) { ans += A [ i ] * count [ i ] ; } return ans ; }
int make_permutation ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += Math . Abs ( i + 1 - arr [ i ] ) ; return ans ; }
int maxSum ( int [ , ] V , int n , int m ) { int ans = 0 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { List < Tuple < int , int > > aux = new List < Tuple < int , int > > ( ) ; for ( int j = 0 ; j < m ; ++ j ) { aux . Add ( new Tuple < int , int > ( V [ i + 1 , j ] , j ) ) ; } aux . Sort ( ) ; aux . Reverse ( ) ; for ( int j = 0 ; j < m ; ++ j ) { for ( int k = 0 ; k < m ; ++ k ) { if ( aux [ k ] . Item2 - j == 0 || Math . Abs ( aux [ k ] . Item2 - j ) > 1 ) { V [ i , j ] += aux [ k ] . Item1 ; break ; } } } } for ( int i = 0 ; i < m ; ++ i ) { ans = Math . Max ( ans , V [ 0 , i ] ) ; } return ans ; }
int minimumProduct ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int product = 1 ; for ( int i = 0 ; i < n ; i += 2 ) { product *= ( arr [ i ] + arr [ i + 1 ] ) ; } return product ; }
bool isVowel ( char ch ) { ch = char . ToUpper ( ch ) ; return ( ch == 'A' ch == 'E' ch == 'I' ch == 'O' ch == 'U' ) ; }
void sortArr ( string [ ] arr , int n ) { List < Tuple < int , string > > vp = new List < Tuple < int , string > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { vp . Add ( new Tuple < int , string > ( countVowels ( arr [ i ] ) , arr [ i ] ) ) ; } vp . Sort ( ) ; for ( int i = 0 ; i < vp . Count ; i ++ ) Console . Write ( vp [ i ] . Item2 + " " ) ; }
bool checkIsGP ( double [ ] arr , int n ) { if ( n == 1 ) return true ; Array . Sort ( arr ) ; double r = arr [ 1 ] / arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] / arr [ i - 1 ] != r ) return false ; } return true ; }
bool checkIsHP ( double [ ] arr , int n ) { if ( n == 1 ) { return true ; } double [ ] rec = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { rec [ i ] = ( ( 1 / arr [ i ] ) ) ; } if ( checkIsAP ( rec , n ) ) return true ; else return false ; }
int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
void sortArr ( int [ ] arr , int n ) { List < Tuple < int , int > > vp = new List < Tuple < int , int > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { vp . Add ( new Tuple < int , int > ( reversDigits ( arr [ i ] ) , arr [ i ] ) ) ; } vp . Sort ( ) ; for ( int i = 0 ; i < vp . Count ; i ++ ) Console . Write ( vp [ i ] . Item2 + " " ) ; }
void sortMat ( int [ , ] data , int row , int col ) { int size = row * col ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size - 1 ; j ++ ) { if ( data [ j / col , j % col ] > data [ ( j + 1 ) / col , ( j + 1 ) % col ] ) { int temp = data [ j / col , j % col ] ; data [ j / col , j % col ] = data [ ( j + 1 ) / col , ( j + 1 ) % col ] ; data [ ( j + 1 ) / col , ( j + 1 ) % col ] = temp ; } } } }
int minimiseMedian ( int [ ] arr , int n ) { Array . Sort ( arr ) ; return Math . Abs ( arr [ n / 2 ] - arr [ ( n / 2 ) - 1 ] ) ; }
int sortByFreq ( int [ ] arr , int n ) { int maxE = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { maxE = Math . Max ( maxE , arr [ i ] ) ; } int [ ] freq = new int [ maxE + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i <= maxE ; i ++ ) { if ( freq [ i ] > 0 ) { int value = 100000 - i ; arr [ cnt ] = 100000 * freq [ i ] + value ; cnt ++ ; } } return cnt ; }
void printSortedArray ( int [ ] arr , int cnt ) { for ( int i = 0 ; i < cnt ; i ++ ) { int frequency = arr [ i ] / 100000 ; int value = 100000 - ( arr [ i ] % 100000 ) ; for ( int j = 0 ; j < frequency ; j ++ ) { Console . Write ( value + " " ) ; } } }
bool canBeEqual ( int a , int b , int c , int k ) { int [ ] arr = new int [ 3 ] ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; Array . Sort ( arr ) ; int diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 k % 3 != 0 ) return false ; return true ; }
int search ( int [ ] arr , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( ( arr [ l ] == arr [ mid ] ) && ( arr [ h ] == arr [ mid ] ) ) { ++ l ; -- h ; return search ( arr , l , h , key )  } if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
int [ ] orgazineInOrder ( int [ ] vec , int [ ] op , int n ) { int [ ] result = new int [ n ] ; Array . Sort ( vec ) ; int i = 0 , j = n - 1 , k = 0 ; while ( i <= j && k <= n - 2 ) { if ( op [ k ] == '<' ) { result [ k ] = vec [ i ++ ] ; } else { result [ k ] = vec [ j -- ] ; } k ++ ; } result [ n - 1 ] = vec [ i ] ; return result ; }
long minimumCost ( long [ ] price , int n ) { Array . Sort ( price ) ; long totalCost = 0 ; for ( int i = n - 1 ; i > 1 ; i -= 2 ) { if ( i == 2 ) { totalCost += price [ 2 ] + price [ 0 ] ; } else { long price_first = price [ i ] + price [ 0 ] + 2 * price [ 1 ] ; long price_second = price [ i ] + price [ i - 1 ] + 2 * price [ 0 ] ; totalCost += Math . Min ( price_first , price_second ) ; } } if ( n == 1 ) { totalCost += price [ 0 ] ; } else { totalCost += price [ 1 ] ; } return totalCost ; }
bool checkRectangles ( int [ ] arr , int n ) { bool ans = true ; Array . Sort ( arr ) ; int area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; }
int findMin ( int [ ] arr , int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; ans = Math . Max ( ans , j - i ) ; i = j - 1 ; } return n - ans ; }
int countSubSeq ( int [ ] a , int n , int k ) { Array . Sort ( a ) ; List < int > arr = new List < int > ( ) ; int count , x ; for ( int i = 0 ; i < n ; ) { count = 1 ; x = a [ i ] ; i ++ ; while ( i < n && a [ i ] == x ) { count ++ ; i ++ ; } arr . Add ( count ) ; } int m = arr . Count ; n = Math . Min ( m , k ) ; count = 1 ; int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 , i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = m ; j >= 0 ; j -- ) { if ( j > m - i ) dp [ i , j ] = 0 ; else { dp [ i , j ] = dp [ i , j + 1 ] + arr [ j ] * dp [ i - 1 , j + 1 ] ; } } count = count + dp [ i , 0 ] ; } return count ; }
int maxMod ( int [ ] arr , int n ) { int maxVal = max_element ( arr , n ) ; int secondMax = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return secondMax ; }
string partOdd ( string s ) { string st = "" ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( i % 2 != 0 ) st += s [ i ] ; } return st ; }
string partEven ( string str ) { string s = "" ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( i % 2 == 0 ) s += str [ i ] ; } return s ; }
void sortStack ( Stack input , int k ) { Stack tmpStack = new Stack ( ) ; while ( input . Count != 0 ) { int tmp = ( int ) input . Peek ( ) ; input . Pop ( ) ; while ( tmpStack . Count != 0 ) { int tmpStackMod = ( int ) tmpStack . Peek ( ) % k ; int tmpMod = tmp % k ; if ( ( tmpStackMod > tmpMod ) || ( tmpStackMod == tmpMod && ( int ) tmpStack . Peek ( ) > tmp ) ) { input . Push ( ( int ) tmpStack . Peek ( ) ) ; tmpStack . Pop ( ) ; } else break ; } tmpStack . Push ( tmp ) ; } while ( tmpStack . Count != 0 ) { input . Push ( ( int ) tmpStack . Peek ( ) ) ; tmpStack . Pop ( ) ; } while ( input . Count != 0 ) { Console . Write ( ( int ) input . Peek ( ) + " " ) ; input . Pop ( ) ; } }
int maxLen ( int [ ] arr , int n ) { int c_sum = 0 ; Array . Sort ( arr ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { c_sum += arr [ i ] ; if ( c_sum < 0 ) return i ; } return n ; }
bool isPossible ( int [ , ] range , int N ) { interval [ ] test = new interval [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { test [ i ] = new interval ( ) ; test [ i ] . l = range [ i , 0 ] ; test [ i ] . r = range [ i , 1 ] ; test [ i ] . v = range [ i , 2 ] ; } Array . Sort ( test , new sortHelper ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { int [ ] count = new int [ MAX ] ; int current_velocity = test [ i ] . v ; int j = i ; while ( j < N && test [ j ] . v == current_velocity ) { for ( int k = test [ j ] . l ; k <= test [ j ] . r ; k ++ ) { count [ k ] ++ ; if ( count [ k ] >= 3 ) return false ; } j ++ ; } i = j - 1 ; } return true ; }
int maxSum ( int [ ] a , int n ) { Array . Sort ( a ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { sum += a [ i ] ; } return sum ; }
int minSteps ( int [ ] arr , int n ) { int maxVal = getMax ( arr ) ; return maxVal ; }
bool isPossible ( int [ ] A , int [ ] B , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; Array . Sort ( A ) ; Array . Sort ( B ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
void sortWithRemainder ( int [ ] arr , int n , int k ) { ArrayList [ ] v = new ArrayList [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { v [ i ] = new ArrayList ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { v [ arr [ i ] % k ] . Add ( arr [ i ] ) ; } for ( int i = 0 ; i < k ; i ++ ) { v [ i ] . Sort ( ) ; } int j = 0 ; for ( int i = 0 ; i < k ; i ++ ) { foreach ( int x in v [ i ] ) { arr [ j ] = x ; j ++ ; } } printArr ( arr , n ) ; }
int minOperations ( int [ ] ar , int k ) { Array . Sort ( ar ) ; int opsNeeded = 0 ; for ( int i = 0 ; i < k ; i ++ ) { opsNeeded += ar [ k - 1 ] - ar [ i ] ; } int ans = opsNeeded ; for ( int i = k ; i < ar . Length ; i ++ ) { opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) ; opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) ; ans = Math . Min ( ans , opsNeeded ) ; } return ans ; }
int getNumber ( int n , int k ) { int [ ] arr = new int [ n ] ; int i = 0 ; int odd = 1 ; while ( odd <= n ) { arr [ i ++ ] = odd ; odd += 2 ; } int even = 2 ; while ( even <= n ) { arr [ i ++ ] = even ; even += 2 ; } return arr [ k - 1 ] ; }
int getNumber ( int n , int k ) { int pos ; if ( ( n % 2 ) == 0 ) { pos = n / 2 ; } else { pos = ( n / 2 ) + 1 ; } if ( k <= pos ) { return ( k * 2 - 1 ) ; } else return ( ( k - pos ) * 2 ) ; }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
int CountPermutation ( int [ ] a , int n ) { int ways = 1 ; Array . Sort ( a ) ; int size = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { size ++ ; } else { ways *= fact [ size ] ; size = 1 ; } } ways *= fact [ size ] ; return ways ; }
void dfs ( int num , int left , int ct ) { if ( ct >= 15 ) return ; if ( left == 0 ) ans . Add ( num ) ; for ( int i = 0 ; i <= Math . Min ( left , 9 ) ; i ++ ) dfs ( num * 10 + i , left - i , ct + 1 ) ; }
int getKthNum ( int m , int k ) { dfs ( 0 , m , 0 ) ; int ct = 0 ; foreach ( int it in ans ) { ct ++ ; if ( ct == k ) { return it ; } } return - 1 ; }
int Min_Replace ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int [ ] freq = new int [ MAX ] ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } Array . Sort ( freq ) ; Array . Reverse ( freq ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; }
int minCost ( int [ , ] cost ) { int [ ] dist = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i , j ] ) dist [ j ] = dist [ i ] + cost [ i , j ] ; return dist [ N - 1 ] ; }
int Segment ( int [ ] x , int [ ] l , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; }
int Next_greater ( int [ ] a , int n , int x ) { Array . Sort ( a ) ; int low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
void Combination ( List < int > A , int K ) { A . Sort ( ) ; List < int > local = new List < int > ( ) ; unique_combination ( 0 , 0 , K , local , A ) ; }
void xorOnSortedArray ( int [ ] arr , int n , int k , int x ) { int [ ] arr1 = new int [ MAX + 1 ] ; int [ ] arr2 = new int [ MAX + 1 ] ; int [ ] xor_val = new int [ MAX + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) arr1 [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= MAX ; i ++ ) xor_val [ i ] = i ^ x ; while ( k -- > 0 ) { int count = 0 ; for ( int i = 0 ; i <= MAX ; i ++ ) { int store = arr1 [ i ] ; if ( arr1 [ i ] > 0 ) { if ( count % 2 == 0 ) { int div = ( int ) Math . Ceiling ( ( double ) ( arr1 [ i ] / 2 ) ) ; arr1 [ i ] = arr1 [ i ] - div ; arr2 [ xor_val [ i ] ] += div ; } else if ( count % 2 != 0 ) { int div = arr1 [ i ] / 2 ; arr1 [ i ] = arr1 [ i ] - div ; arr2 [ xor_val [ i ] ] += div ; } } count = count + store ; } for ( int i = 0 ; i <= MAX ; i ++ ) { arr1 [ i ] = arr1 [ i ] + arr2 [ i ] ; arr2 [ i ] = 0 ; } } int min = int . MaxValue ; int max = int . MinValue ; for ( int i = 0 ; i <= MAX ; i ++ ) { if ( arr1 [ i ] > 0 ) { if ( min > i ) min = i ; if ( max < i ) max = i ; } } Console . WriteLine ( min + " " + max ) ; }
int pairs_count ( int [ ] arr , int n , int sum ) { int ans = 0 ; Array . Sort ( arr ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { int x = arr [ i ] , xx = i ; while ( ( i < j ) && ( arr [ i ] == x ) ) i ++ ; int y = arr [ j ] , yy = j ; while ( ( j >= i ) && ( arr [ j ] == y ) ) j -- ; if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; }
List < int > findSubarray ( int [ ] a , int k , int n ) { List < List < int > > vec = new List < List < int > > ( ) ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { List < int > temp = new List < int > ( ) ; for ( int j = i ; j < i + k ; j ++ ) { temp . Add ( a [ j ] ) ; } vec . Add ( temp ) ; } vec . OrderBy ( l => l [ 0 ] ) ; return vec [ vec . Count - 1 ] ; }
float knapSack ( int W , float [ ] wt , float [ ] val , int n ) { float maxratio = int . MinValue ; int maxindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( val [ i ] / wt [ i ] ) > maxratio ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; }
void sortArray ( int [ ] a , int n ) { List < int > ans = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) ans . Add ( a [ i ] ) ; } ans . Sort ( ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) { a [ i ] = ans [ j ] ; j ++ ; } } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( a [ i ] + " " ) ; }
int solution ( ArrayList arr , int x ) { int closestSum = int . MaxValue ; for ( int i = 0 ; i < arr . Count ; i ++ ) { for ( int j = i + 1 ; j < arr . Count ; j ++ ) { for ( int k = j + 1 ; k < arr . Count ; k ++ ) { if ( Math . Abs ( x - closestSum ) > Math . Abs ( x - ( ( int ) arr [ i ] + ( int ) arr [ j ] + ( int ) arr [ k ] ) ) ) { closestSum = ( ( int ) arr [ i ] + ( int ) arr [ j ] + ( int ) arr [ k ] ) ; } } } } return closestSum ; }
int solution ( List < int > arr , int x ) { arr . Sort ( ) ; int closestSum = int . MaxValue ; for ( int i = 0 ; i < arr . Count - 2 ; i ++ ) { int ptr1 = i + 1 , ptr2 = arr . Count - 1 ; while ( ptr1 < ptr2 ) { int sum = arr [ i ] + arr [ ptr1 ] + arr [ ptr2 ] ; if ( Math . Abs ( x - sum ) < Math . Abs ( x - closestSum ) ) { closestSum = sum ; } if ( sum > x ) { ptr2 -- ; } else { ptr1 ++ ; } } } return closestSum ; }
List < int > makearray ( List < List < int > > v , int V ) { List < List < int > > adj = new List < List < int > > ( ) ; for ( int i = 0 ; i < V ; i ++ ) { adj . Add ( new List < int > ( ) ) ; } for ( int i = 0 ; i < v . Count ; i ++ ) { for ( int j = 0 ; j < v [ i ] . Count - 1 ; j ++ ) { addEdge ( adj , v [ i ] [ j ] , v [ i ] [ j + 1 ] ) ; } } List < int > indeg = new List < int > ( ) ; for ( int i = 0 ; i < V ; i ++ ) { indeg . Add ( 0 ) ; } getindeg ( adj , V , indeg ) ; List < int > res = topo ( adj , V , indeg ) ; return res ; }
bool existsTriplet ( int [ ] a , int [ ] b , int [ ] c , int x , int l1 , int l2 , int l3 ) { if ( l2 <= l1 && l2 <= l3 ) { swap ( l2 , l1 ) ; swap ( a , b ) ; } else if ( l3 <= l1 && l3 <= l2 ) { swap ( l3 , l1 ) ; swap ( a , c ) ; } for ( int i = 0 ; i < l1 ; i ++ ) { int j = 0 , k = l3 - 1 ; while ( j < l2 && k >= 0 ) { if ( a [ i ] + b [ j ] + c [ k ] == x ) return true ; if ( a [ i ] + b [ j ] + c [ k ] < x ) j ++ ; else k -- ; } } return false ; }
void compressArr ( int [ ] arr , int n ) { int i = 0 , j = 0 ; Array . Sort ( arr ) ; while ( i < n ) { j = i ; while ( ( j + 1 < n ) && ( arr [ j + 1 ] == arr [ j ] + 1 ) ) { j ++ ; } if ( i == j ) { Console . Write ( arr [ i ] + " " ) ; i ++ ; } else { Console . Write ( arr [ i ] + "-" + arr [ j ] + " " ) ; i = j + 1 ; } } }
int partition ( char [ ] arr , int low , int high , int mod ) { char pivot = arr [ high ] ; int i = ( low - 1 ) ; char t ; int piv = pivot % mod ; for ( int j = low ; j <= high - 1 ; j ++ ) { int a = arr [ j ] % mod ; if ( a <= piv ) { i ++ ; t = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = t ; } } t = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ high ] ; arr [ high ] = t ; return ( i + 1 ) ; }
void printArray ( char [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
bool check ( int [ ] arr , int n ) { int modify = 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) { arr [ n - 1 ] = arr [ n - 2 ] - 1 ; modify ++ ; } if ( arr [ 0 ] <= arr [ 1 ] ) { arr [ 0 ] = arr [ 1 ] + 1 ; modify ++ ; } for ( int i = n - 2 ; i > 0 ; i -- ) { if ( ( arr [ i - 1 ] <= arr [ i ] && arr [ i + 1 ] <= arr [ i ] ) || ( arr [ i - 1 ] >= arr [ i ] && arr [ i + 1 ] >= arr [ i ] ) ) { arr [ i ] = ( arr [ i - 1 ] + arr [ i + 1 ] ) / 2 ; modify ++ ; if ( arr [ i ] == arr [ i - 1 ] arr [ i ] == arr [ i + 1 ] ) return false ; } } if ( modify > 1 ) return false ; return true ; }
void inorder ( Node root ) { if ( root != null ) { inorder ( root . left ) ; Console . WriteLine ( root . data + " " ) ; inorder ( root . right ) ; } }
void merge ( Node root1 , Node root2 ) { if ( root1 == null && root2 == null ) { return ; } if ( root1 == null ) { inorder ( root2 ) ; return ; } if ( root2 == null ) { inorder ( root1 ) ; return ; } Node temp1 = root1 ; Node prev1 = null ; while ( temp1 . left != null ) { prev1 = temp1 ; temp1 = temp1 . left ; } Node temp2 = root2 ; Node prev2 = null ; while ( temp2 . left != null ) { prev2 = temp2 ; temp2 = temp2 . left ; } if ( temp1 . data <= temp2 . data ) { Console . Write ( temp1 . data + " " ) ; if ( prev1 == null ) { merge ( root1 . right , root2 ) ; } else { prev1 . left = temp1 . right ; merge ( root1 , root2 ) ; } } else { Console . Write ( temp2 . data + " " ) ; if ( prev2 == null ) { merge ( root1 , root2 . right ) ; } else { prev2 . left = temp2 . right ; merge ( root1 , root2 ) ; } } }
bool IsSorted ( int [ ] A , int [ ] B , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int x , y ; x = Math . Max ( A [ i ] , B [ i ] ) ; y = Math . Min ( A [ i ] , B [ i ] ) ; A [ i ] = x ; B [ i ] = y ; } for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] <= A [ i - 1 ] B [ i ] <= B [ i - 1 ] ) return false ; } return true ; }
void removeElements ( int [ ] arr , int n ) { int [ ] brr = new int [ n ] ; int l = 1 ; brr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( brr [ l - 1 ] <= arr [ i ] ) { brr [ l ] = arr [ i ] ; l ++ ; } } for ( int i = 0 ; i < l ; i ++ ) Console . Write ( brr [ i ] + " " ) ; }
int maxWater ( int [ ] height , int n ) { int max = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int current = ( Math . Min ( height [ i ] , height [ j ] ) * ( j - i - 1 ) ) ; max = Math . Max ( max , current ) ; } } return max ; }
int maxSelectionCount ( int [ ] a , int n ) { int res = 0 ; Array . Sort ( a ) ; int select = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= select ) { res ++ ; select ++ ; } } return res ; }
void findCombinations ( int n ) { int [ ] a = new int [ n ] ; findCombinationsUtil ( a , 0 , n , n ) ; }
bool check ( int [ ] arr , int n ) { int modify = 0 ; if ( arr [ 0 ] > arr [ 1 ] ) { arr [ 0 ] = arr [ 1 ] / 2 ; modify ++ ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( arr [ i - 1 ] < arr [ i ] && arr [ i + 1 ] < arr [ i ] ) || ( arr [ i - 1 ] > arr [ i ] && arr [ i + 1 ] > arr [ i ] ) ) { arr [ i ] = ( arr [ i - 1 ] + arr [ i + 1 ] ) / 2 ; if ( arr [ i ] == arr [ i - 1 ] arr [ i ] == arr [ i + 1 ] ) return false ; modify ++ ; } } if ( arr [ n - 1 ] < arr [ n - 2 ] ) modify ++ ; if ( modify > 1 ) return false ; return true ; }
bool checkDivisors ( int [ ] a , int n ) { int X = max_element ( a ) ; List < int > b = new List < int > ( ) ; for ( int i = 1 ; i * i <= X ; i ++ ) { if ( X % i == 0 ) { b . Add ( i ) ; if ( X / i != i ) b . Add ( X / i ) ; } } if ( b . Count != n ) return false ; Array . Sort ( a ) ; b . Sort ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] != a [ i ] ) return false ; } return true ; }
int findX ( int [ ] a , int n ) { Array . Sort ( a ) ; int x = a [ 0 ] * a [ n - 1 ] ; List < int > vec = new List < int > ( ) ; for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { vec . Add ( i ) ; if ( ( x / i ) != i ) vec . Add ( x / i ) ; } } vec . Sort ( ) ; if ( vec . Count != n ) { return - 1 ; } else { int i = 0 ; foreach ( int it in vec ) { if ( a [ i ++ ] != it ) return - 1 ; } } return x ; }
void seive ( ) { for ( int i = 2 ; i < N ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i + i ; j < N ; j += i ) { prime [ j ] = 1 ; } } } prime [ 1 ] = 1 ; }
int maxSizeArr ( int [ ] arr , int n , int k ) { List < int > v = new List < int > ( ) ; List < int > diff = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == 1 ) { v . Add ( i ) ; } } for ( int i = 1 ; i < v . Count ; i ++ ) { diff . Add ( v [ i ] - v [ i - 1 ] - 1 ) ; } diff . Sort ( ) ; for ( int i = 1 ; i < diff . Count ; i ++ ) { diff [ i ] = diff [ i ] + diff [ i - 1 ] ; } if ( k > n || ( k == 0 && v . Count > 0 ) ) { return - 1 ; } else if ( v . Count <= k ) { return ( n - k ) ; } else if ( v . Count > k ) { int tt = v . Count - k ; int sum = 0 ; sum += diff [ tt - 1 ] ; int res = n - ( v . Count + sum ) ; return res ; } return 1 ; }
void pendulumArrangement ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int odd , temp , p , pos ; pos = n - 1 ; if ( n % 2 == 0 ) odd = n - 1 ; else odd = n - 2 ; while ( odd > 0 ) { temp = arr [ odd ] ; p = odd ; while ( p != pos ) { arr [ p ] = arr [ p + 1 ] ; p ++ ; } arr [ p ] = temp ; odd = odd - 2 ; pos = pos - 1 ; } int start = 0 , end = ( n - 1 ) / 2 ; for ( ; start < end ; start ++ , end -- ) { temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
long CountSubset ( int [ ] arr , int n ) { long ans = powmod ( 2 , n - 1 ) ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; ++ i ) { int j = i + 1 ; while ( j < n && arr [ j ] == arr [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + nCr ( l + r , l ) ) % mod ; j ++ ; } } return ans ; }
void Preprocess ( ) { arr [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= 1000 ; ++ i ) { arr [ i , 0 ] = 1 ; for ( int j = 1 ; j < i ; ++ j ) { arr [ i , j ] = ( arr [ i - 1 , j - 1 ] + arr [ i - 1 , j ] ) % mod ; } arr [ i , i ] = 1 ; } }
long powmod ( long a , long n ) { if ( n == 0 ) { return 1 ; } long pt = powmod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 == 1 ) { return ( pt * a ) % mod ; } else { return pt ; } }
long CountSubset ( int [ ] val , int n ) { long ans = powmod ( 2 , n - 1 ) ; Array . Sort ( val ) ; for ( int i = 0 ; i < n ; ++ i ) { int j = i + 1 ; while ( j < n && val [ j ] == val [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + arr [ l + r , l ] ) % mod ; j ++ ; } } return ans ; }
void reArrange ( String [ ] words , int n ) { Dictionary < String , int > freq = new Dictionary < String , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq . Add ( words [ i ] , ( i + 1 ) ) ; } Array . Sort ( words ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( freq [ words [ i ] ] + " " ) ; }
int findNumber ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int max = arr [ n - 1 ] ; int [ ] table = new int [ ( 2 * max ) + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) table [ i ] = int . MaxValue ; int ans = - 1 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] <= i ) { int res = table [ i - arr [ j ] ] ; if ( res != int . MaxValue && res + 1 < table [ i ] ) table [ i ] = res + 1 ; } } if ( i > arr [ n - 1 ] && table [ i ] == int . MaxValue ) { ans = i ; break ; } } return ans ; }
long power ( long x , long y ) { long res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % MOD ; } y = y >> 1 ; x = ( x * x ) % MOD ; } return res % MOD ; }
void combi ( int n , int k ) { int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = ( C [ i - 1 , j - 1 ] % MOD + C [ i - 1 , j ] % MOD ) % MOD ; } } }
int findSumofEle ( int [ ] arr1 , int m , int [ ] arr2 , int n ) { int [ ] hash = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr2 [ i ] ] ++ ; } for ( int i = 1 ; i < MAX ; i ++ ) { hash [ i ] = hash [ i ] + hash [ i - 1 ] ; } int maximumFreq = 0 ; for ( int i = 0 ; i < m ; i ++ ) { maximumFreq = Math . Max ( maximumFreq , hash [ arr1 [ i ] ] ) ; } int sumOfElements = 0 ; for ( int i = 0 ; i < m ; i ++ ) { sumOfElements += ( maximumFreq == hash [ arr1 [ i ] ] ) ? arr1 [ i ] : 0 ; } return sumOfElements ; }
int MinimizeleftOverSum ( int [ ] a , int n ) { List < int > v1 = new List < int > ( ) , v2 = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) v1 . Add ( a [ i ] ) ; else v2 . Add ( a [ i ] ) ; } if ( v1 . Count > v2 . Count ) { v1 . Sort ( ) ; v2 . Sort ( ) ; int x = v1 . Count - v2 . Count - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v1 [ i ++ ] ; } return sum ; } else if ( v2 . Count > v1 . Count ) { v1 . Sort ( ) ; v2 . Sort ( ) ; int x = v2 . Count - v1 . Count - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v2 [ i ++ ] ; } return sum ; } else return 0 ; }
void printList ( Node head ) { while ( head != null ) { Console . Write ( head . data + " " ) ; head = head . next ; } }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] ) ; }
int compare ( int num1 , int num2 ) { String A = num1 . ToString ( ) ; String B = num2 . ToString ( ) ; return ( A + B ) . CompareTo ( B + A ) ; }
void printSmallest ( int N , int [ ] arr ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( compare ( arr [ i ] , arr [ j ] ) > 0 ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } printArr ( arr , N ) ; }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
bool isUgly ( int n ) { while ( n % 2 == 0 ) n = n / 2 ; while ( n % 3 == 0 ) n = n / 3 ; while ( n % 5 == 0 ) n = n / 5 ; if ( n == 1 ) return true ; return false ; }
void sortUglyNumbers ( int [ ] arr , int n ) { List < int > list = new List < int > ( ) ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( isUgly ( arr [ i ] ) ) { list . Add ( arr [ i ] ) ; arr [ i ] = - 1 ; } } list . Sort ( ) ; int j = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == - 1 ) Console . Write ( list [ j ++ ] + " " ) ; else Console . Write ( arr [ i ] + " " ) ; } }
double getMaxMedian ( int [ ] arr , int n , int k ) { int size = n + k ; Array . Sort ( arr ) ; if ( size % 2 == 0 ) { double median = ( double ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } double median1 = arr [ size / 2 ] ; return median1 ; }
void sortArr ( int [ ] arr , int n , int k ) { int prev = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { if ( prev != - 1 ) Array . Sort ( arr , prev + 1 , i - ( prev + 1 ) ) ; prev = i ; } } printArr ( arr , n ) ; }
void findSquare ( int n ) { int [ , ] points = new int [ 4 , 2 ] { { 1 , 2 } , { - 3 , 4 } , { 1 , 78 } , { - 3 , - 7 } } ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int x , y ; x = points [ i , 0 ] ; y = points [ i , 1 ] ; a [ i ] = Math . Max ( mod ( x ) , mod ( y ) ) ; } Array . Sort ( a ) ; int index = ( int ) ( n / 2 - 1 ) ; Console . WriteLine ( "Minimum M required is: " + a [ index ] ) ; }
void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void removeMin ( int [ ] arr , int n ) { int i , minVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) minVal = Math . Min ( minVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] - minVal ; }
void removeFromMax ( int [ ] arr , int n ) { int i , maxVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) maxVal = Math . Max ( maxVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = maxVal - arr [ i ] ; }
void modifyArray ( int [ ] arr , int n , int k ) { if ( k % 2 == 0 ) removeMin ( arr , n ) ; else removeFromMax ( arr , n ) ; printArray ( arr , n ) ; }
int findKth ( int [ ] arr , int n , int k ) { HashSet < int > missing = new HashSet < int > ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { missing . Add ( arr [ i ] ) ; } int maxm = arr . Max ( ) ; int minm = arr . Min ( ) ; for ( int i = minm + 1 ; i < maxm ; i ++ ) { if ( ! missing . Contains ( i ) ) { count ++ ; } if ( count == k ) { return i ; } } return - 1 ; }
void minOperation ( string S , int N , int K ) { if ( N % K != 0 ) { Console . WriteLine ( "Not Possible" ) ; } else { int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < N ; i ++ ) { count [ ( S [ i ] - 97 ) ] ++ ; } int E = N / K ; List < int > greaterE = new List < int > ( ) ; List < int > lessE = new List < int > ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] < E ) lessE . Add ( E - count [ i ] ) ; else greaterE . Add ( count [ i ] - E ) ; } greaterE . Sort ( ) ; lessE . Sort ( ) ; int mi = Int32 . MaxValue ; for ( int i = 0 ; i <= K ; i ++ ) { int set1 = i ; int set2 = K - i ; if ( greaterE . Count >= set1 && lessE . Count >= set2 ) { int step1 = 0 ; int step2 = 0 ; for ( int j = 0 ; j < set1 ; j ++ ) step1 += greaterE [ j ] ; for ( int j = 0 ; j < set2 ; j ++ ) step2 += lessE [ j ] ; mi = Math . Min ( mi , Math . Max ( step1 , step2 ) ) ; } } Console . WriteLine ( mi ) ; } }
void printPermutations ( int n , int [ ] a , int k ) { pair [ ] arr = new pair [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = new pair ( ) ; arr [ i ] . first = a [ i ] ; arr [ i ] . second = i ; } Array . Sort ( arr , new sortHelper ( ) ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] . first == arr [ i - 1 ] . first ) count ++ ; if ( count < k ) { Console . Write ( "-1" ) ; return ; } for ( int i = 0 ; i < k - 1 ; i ++ ) { printIndices ( n , arr ) ; for ( int j = next_pos ; j < n ; j ++ ) { if ( arr [ j ] . first == arr [ j - 1 ] . first ) { pair t = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = t ; next_pos = j + 1 ; break ; } } } printIndices ( n , arr ) ; }
int findAnswer ( int n , int [ ] arr ) { Array . Sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; }
void merge ( int l , int r , int [ ] output ) { int l_in = l * n , r_in = ( ( l + r ) / 2 + 1 ) * n ; int l_c = ( ( l + r ) / 2 - l + 1 ) * n ; int r_c = ( r - ( l + r ) / 2 ) * n ; int [ ] l_arr = new int [ l_c ] ; int [ ] r_arr = new int [ r_c ] ; for ( int i = 0 ; i < l_c ; i ++ ) l_arr [ i ] = output [ l_in + i ] ; for ( int i = 0 ; i < r_c ; i ++ ) r_arr [ i ] = output [ r_in + i ] ; int l_curr = 0 , r_curr = 0 ; int index = l_in ; while ( l_curr + r_curr < l_c + r_c ) { if ( r_curr == r_c || ( l_curr != l_c && l_arr [ l_curr ] < r_arr [ r_curr ] ) ) { output [ index ] = l_arr [ l_curr ] ; l_curr ++ ; index ++ ; } else { output [ index ] = r_arr [ r_curr ] ; r_curr ++ ; index ++ ; } } }
void divide ( int l , int r , int [ ] output , int [ , ] arr ) { if ( l == r ) { for ( int i = 0 ; i < n ; i ++ ) output [ l * n + i ] = arr [ l , i ] ; return ; } divide ( l , ( l + r ) / 2 , output , arr ) ; divide ( ( l + r ) / 2 + 1 , r , output , arr ) ; merge ( l , r , output ) ; }
int minSum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int x = arr [ ( int ) ( n / 2 ) ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . Abs ( arr [ i ] - x ) ; return sum ; }
int minOperations ( int n , int m , int k , int [ , ] matrix ) { int [ ] arr = new int [ n * m ] ; int mod = matrix [ 0 , 0 ] % k ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { arr [ i * m + j ] = matrix [ i , j ] ; if ( matrix [ i , j ] % k != mod ) { return - 1 ; } } } Array . Sort ( arr ) ; int median = arr [ ( n * m ) / 2 ] ; int minOperations = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations += Math . Abs ( arr [ i ] - median ) / k ; if ( ( n * m ) % 2 == 0 ) { int median2 = arr [ ( ( n * m ) / 2 ) - 1 ] ; int minOperations2 = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations2 += Math . Abs ( arr [ i ] - median2 ) / k ; minOperations = Math . Min ( minOperations , minOperations2 ) ; } return minOperations ; }
int minOperations ( int n , int m , int k , List < List < int > > matrix ) { List < int > arr = new List < int > ( ) ; int mod ; if ( matrix [ 0 ] [ 0 ] < 0 ) { mod = k - ( Math . Abs ( matrix [ 0 ] [ 0 ] ) % k ) ; } else { mod = matrix [ 0 ] [ 0 ] % k ; } for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { arr . Add ( matrix [ i ] [ j ] ) ; int val = matrix [ i ] [ j ] ; if ( val < 0 ) { int res = k - ( Math . Abs ( val ) % k ) ; if ( res != mod ) { return - 1 ; } } else { int foo = matrix [ i ] [ j ] ; if ( foo % k != mod ) { return - 1 ; } } } } arr . Sort ( ) ; int median = arr [ ( n * m ) / 2 ] ; int minOperations = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations += Math . Abs ( arr [ i ] - median ) / k ; if ( ( n * m ) % 2 == 0 ) { int median2 = arr [ ( ( n * m ) / 2 ) - 1 ] ; int minOperations2 = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations2 += Math . Abs ( arr [ i ] - median2 ) / k ; minOperations = Math . Min ( minOperations , minOperations2 ) ; } return minOperations ; }
int countDistinct ( int [ ] arr , int n ) { int res = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) res ++ ; } return res ; }
int countDistinct ( int [ ] arr , int n ) { HashSet < int > hs = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hs . Add ( arr [ i ] ) ; } return hs . Count ; }
void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void printMaxMean ( int [ ] arr , int n ) { int [ ] newArr = new int [ n ] ; Array . Sort ( arr , 0 , 2 * n ) ; for ( int i = 0 ; i < n ; i ++ ) newArr [ i ] = arr [ i + n ] ; printArray ( newArr , n ) ; }
int Minimum_Cells ( List < Tuple < int , int > > v ) { int [ ] col = new int [ 3 ] ; int i , j ; for ( i = 0 ; i < 3 ; i ++ ) { int column_number = v [ i ] . Item2 ; col [ i ] = column_number ; } Array . Sort ( col ) ; v . Sort ( ) ; int MidRow = v [ 1 ] . Item1 ; HashSet < Tuple < int , int > > s = new HashSet < Tuple < int , int > > ( ) ; int Maxcol = col [ 2 ] , MinCol = col [ 0 ] ; for ( i = MinCol ; i <= Maxcol ; i ++ ) { s . Add ( new Tuple < int , int > ( MidRow , i ) ) ; } for ( i = 0 ; i < 3 ; i ++ ) { if ( v [ i ] . Item1 == MidRow ) continue ; for ( j = Math . Min ( v [ i ] . Item1 , MidRow ) ; j <= Math . Max ( v [ i ] . Item1 , MidRow ) ; j ++ ) { s . Add ( new Tuple < int , int > ( j , v [ i ] . Item1 ) ) ; } } return s . Count ; }
int countPairs ( int [ ] a , int n ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! map . ContainsKey ( a [ i ] ) ) map . Add ( a [ i ] , 1 ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( map [ a [ i ] ] < 1 ) continue ; int cur = 1 ; while ( cur <= a [ i ] ) cur <<= 1 ; if ( map . ContainsKey ( cur - a [ i ] ) ) { if ( cur - a [ i ] == a [ i ] && map [ a [ i ] ] == 1 ) continue ; count ++ ; map [ cur - a [ i ] ] = map [ cur - a [ i ] ] - 1 ; map [ a [ i ] ] = map [ a [ i ] ] - 1 ; } } return count ; }
int countSequences ( int [ ] arr , int n ) { int count = 1 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
double average ( int [ ] arr , int n , int k ) { double total = 0 ; if ( 2 * k >= n ) return 0 ; Array . Sort ( arr ) ; int start = k , end = n - k - 1 ; for ( int i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; }
void partSort ( int [ ] arr , int N , int a , int b ) { int l = Math . Min ( a , b ) ; int r = Math . Max ( a , b ) ; int [ ] temp = new int [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } Array . Sort ( temp ) ; j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
void partSort ( int [ ] arr , int N , int a , int b ) { int l = Math . Min ( a , b ) ; int r = Math . Max ( a , b ) ; Array . Sort ( arr , l , r ) ; for ( int i = 0 ; i < N ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
int minMovesToSort ( int [ ] arr , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; } return moves ; }
void transpose ( int [ , ] mat , int n ) { int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { temp = mat [ i , j ] ; mat [ i , j ] = mat [ j , i ] ; mat [ j , i ] = temp ; } } }
void sortMatRowAndColWise ( int [ , ] mat , int n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; }
long minimumMoves ( int [ ] a , int n ) { long operations = 0 ; Array . Sort ( a ) ; for ( int i = 0 ; i < n ; i ++ ) operations += ( long ) Math . Abs ( a [ i ] - ( i + 1 ) ) ; return operations ; }
int min_sum ( int n , int k , int [ ] a ) { Array . Sort ( a ) ; if ( a [ 0 ] < 0 ) return - 1 ; if ( k == 0 ) { if ( a [ 0 ] == a [ n - 1 ] ) return ( n * a [ 0 ] ) ; else return - 1 ; } else { int f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int p = a [ i ] - a [ 0 ] ; if ( p % k == 0 ) continue ; else { f = 1 ; break ; } } if ( f > 0 ) return - 1 ; else { if ( k == 1 ) return n ; else return ( n * ( a [ 0 ] % k ) ) ; } } }
void printCase ( int n ) { if ( n <= 2 ) { Console . Write ( - 1 ) ; return ; } for ( int i = n ; i >= 1 ; i -- ) Console . Write ( i + " " ) ; }
void merge ( int [ ] arr , int start , int mid , int end ) { int start2 = mid + 1 ; if ( arr [ mid ] <= arr [ start2 ] ) { return ; } while ( start <= mid && start2 <= end ) { if ( arr [ start ] <= arr [ start2 ] ) { start ++ ; } else { int value = arr [ start2 ] ; int index = start2 ; while ( index != start ) { arr [ index ] = arr [ index - 1 ] ; index -- ; } arr [ start ] = value ; start ++ ; mid ++ ; start2 ++ ; } } }
void mergeSort ( int [ ] arr , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; mergeSort ( arr , l , m ) ; mergeSort ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } }
int minCost ( int [ ] A , int n ) { int cost = 0 ; Array . Sort ( A ) ; int K = A [ n / 2 ] ; for ( int i = 0 ; i < n ; ++ i ) cost += Math . Abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { int tempCost = 0 ; K = A [ ( n / 2 ) - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) tempCost += Math . Abs ( A [ i ] - K ) ; cost = Math . Min ( cost , tempCost ) ; } return cost ; }
bool check ( int n , int k , int [ ] a , int [ ] b ) { Array . Sort ( a ) ; Array . Sort ( b ) ; bool fl = false ; int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) { if ( fl == true ) { return false ; } fl = true ; ind = i ; } } if ( ind == - 1 | Math . Abs ( a [ ind ] - b [ ind ] ) <= k ) { return true ; } return false ; }
int items ( int n , int [ ] a ) { Array . Sort ( a ) ; int z = a [ n - 1 ] ; int x = 1 ; int s = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { s += a [ i ] ; if ( s <= z ) x += 1 ; else break ; } return x ; }
void sortWithSetbits ( int [ ] arr , int n , int k ) { List < int > v1 = new List < int > ( ) ; List < int > v2 = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( bitCount ( arr [ i ] ) == k ) { v1 . Add ( i ) ; v2 . Add ( arr [ i ] ) ; } } v2 . Sort ( ) ; for ( int i = 0 ; i < v1 . Count ; i ++ ) { arr [ v1 [ i ] ] = v2 [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
int findOptimalSolution ( int [ ] a , int N ) { Array . Sort ( a ) ; int points = 0 ; for ( int i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; }
void printArray ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int l = 0 , r = n - 1 , flag = 0 , i ; int k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) Console . Write ( arr [ i ] + " " ) ; flag = 1 ; l = i ; } else { for ( i = r ; i > r - k && i >= l ; i -- ) Console . Write ( arr [ i ] + " " ) ; flag = 0 ; r = i ; } k ++ ; } }
void sortMultiples ( int [ ] arr , int n , int x ) { List < int > v = new List < int > ( ) ; int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] % x == 0 ) v . Add ( arr [ i ] ) ; v . Sort ( ) ; int j = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % x == 0 ) arr [ i ] = v [ j ++ ] ; } }
void kThLexString ( string st , int k , int n ) { HashSet < string > z = new HashSet < string > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { string pp = "" ; for ( int j = i ; j < i + k ; j ++ ) { if ( j >= n ) break ; pp += st [ j ] ; z . Add ( pp ) ; } } ArrayList fin = new ArrayList ( ) ; foreach ( string s in z ) { fin . Add ( s ) ; } fin . Sort ( ) ; Console . Write ( fin [ k - 1 ] ) ; }
void SieveOfEratosthenes ( int n ) { for ( int i = 0 ; i < 100005 ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < n ; i += p ) { prime [ i ] = false ; } } } }
void sortPrimes ( int [ ] arr , int n ) { SieveOfEratosthenes ( 100005 ) ; List < int > v = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { v . Add ( arr [ i ] ) ; } } v . Sort ( ) ; v . Reverse ( ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { arr [ i ] = v [ j ++ ] ; } } }
int number_of_tower ( int [ ] house , int range , int n ) { Array . Sort ( house ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
int countPairs ( Node first , Node second , int value ) { int count = 0 ; while ( first != null && second != null && first != second && second . next != first ) { if ( ( first . data * second . data ) == value ) { count ++ ; first = first . next ; second = second . prev ; } else if ( ( first . data * second . data ) > value ) second = second . prev ; else first = first . next ; } return count ; }
int countTriplets ( Node head , int x ) { if ( head == null ) return 0 ; Node current , first , last ; int count = 0 ; last = head ; while ( last . next != null ) last = last . next ; for ( current = head ; current != null ; current = current . next ) { first = current . next ; count += countPairs ( first , last , x / current . data ) ; } return count ; }
bool isAlphabaticOrder ( String s ) { int n = s . Length ; char [ ] c = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = s [ i ] ; } Array . Sort ( c ) ; for ( int i = 0 ; i < n ; i ++ ) if ( c [ i ] != s [ i ] ) return false ; return true ; }
bool isAlphabaticOrder ( string s ) { int n = s . Length ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] < s [ i - 1 ] ) return false ; } return true ; }
void SieveOfEratosthenes ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } }
void sortedArray ( int [ ] arr , int n ) { SieveOfEratosthenes ( 100005 ) ; List < int > v = new List < int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( prime [ arr [ i ] ] == false ) v . Add ( arr [ i ] ) ; } v . Sort ( ) ; int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( prime [ arr [ i ] ] == true ) Console . Write ( arr [ i ] + " " ) ; else { Console . Write ( v [ j ] + " " ) ; j ++ ; } } }
int findProduct ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int prod = 1 * arr [ 0 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { prod = prod * arr [ i + 1 ] ; } } return prod ; }
int rotateRec ( int n , int [ ] L , int [ ] B ) { int m = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . Max ( L [ i ] , B [ i ] ) <= m ) m = Math . Max ( L [ i ] , B [ i ] ) ; else if ( Math . Min ( L [ i ] , B [ i ] ) <= m ) m = Math . Min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }
int minimumIncrease ( int a , int b , int c ) { int [ ] arr = { a , b , c } ; Array . Sort ( arr ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }
void sortList ( Node head ) { int startVal = 1 ; while ( head != null ) { head . data = startVal ; startVal ++ ; head = head . next ; } }
void push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; start = head_ref ; }
void push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; start = head_ref ; }
void minDistance ( int n , int k , int [ ] [ ] point ) { for ( int i = 0 ; i < k ; i ++ ) Array . Sort ( point [ i ] ) ; for ( int i = 0 ; i < k ; i ++ ) System . Console . Write ( point [ i ] [ ( int ) Math . Ceiling ( ( double ) ( n / 2 ) - 1 ) ] + " " ) ; }
int solve ( int N , int M , int [ ] cp , int [ ] sp ) { int [ ] profit = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ; Array . Sort ( profit ) ; Array . Reverse ( profit ) ; int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; }
void printOrder ( int [ ] arr , int n , int k ) { int len2 = n - k ; int [ ] arr1 = new int [ k ] ; int [ ] arr2 = new int [ n - k ] ; for ( int i = 0 ; i < k ; i ++ ) arr1 [ i ] = arr [ i ] ; for ( int i = k ; i < n ; i ++ ) arr2 [ i - k ] = arr [ i ] ; Array . Sort ( arr1 , 0 , k ) ; Array . Sort ( arr2 , 0 , n - k ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) arr [ i ] = arr1 [ i ] ; else { arr [ i ] = arr2 [ len2 - 1 ] ; len2 -- ; } } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
void findMaxNum ( int [ ] arr , int n ) { int [ ] hash = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( int i = 9 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) Console . Write ( i ) ; } }
void sortK ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; }
int minimumSets ( int [ ] arr , int n , int key ) { int i , j ; Array . Sort ( arr ) ; for ( i = 0 , j = n - 1 ; i <= j ; ++ i ) if ( arr [ i ] + arr [ j ] <= key ) j -- ; return i ; }
int distribution ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return Math . Min ( count , n / 2 ) ; }
int distribution ( int [ ] arr , int n ) { HashSet < int > resources = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) resources . Add ( arr [ i ] ) ; return Math . Min ( resources . Count , n / 2 ) ; }
void merge ( int [ ] arr , int beg , int mid , int end , int maxele ) { int i = beg ; int j = mid + 1 ; int k = beg ; while ( i <= mid && j <= end ) { if ( arr [ i ] % maxele <= arr [ j ] % maxele ) { arr [ k ] = arr [ k ] + ( arr [ i ] % maxele ) * maxele ; k ++ ; i ++ ; } else { arr [ k ] = arr [ k ] + ( arr [ j ] % maxele ) * maxele ; k ++ ; j ++ ; } } while ( i <= mid ) { arr [ k ] = arr [ k ] + ( arr [ i ] % maxele ) * maxele ; k ++ ; i ++ ; } while ( j <= end ) { arr [ k ] = arr [ k ] + ( arr [ j ] % maxele ) * maxele ; k ++ ; j ++ ; } for ( i = beg ; i <= end ; i ++ ) arr [ i ] = arr [ i ] / maxele ; }
void mergeSortRec ( int [ ] arr , int beg , int end , int maxele ) { if ( beg < end ) { int mid = ( beg + end ) / 2 ; mergeSortRec ( arr , beg , mid , maxele ) ; mergeSortRec ( arr , mid + 1 , end , maxele ) ; merge ( arr , beg , mid , end , maxele ) ; } }
void mergeSort ( int [ ] arr , int n ) { int maxele = arr . Max ( ) + 1 ; mergeSortRec ( arr , 0 , n - 1 , maxele ) ; }
void printSorted ( string s , int l ) { Stack stack = new Stack ( ) ; Stack tempstack = new Stack ( ) ; stack . Push ( s [ 0 ] ) ; for ( int i = 1 ; i < l ; i ++ ) { int a = s [ i ] ; int b = ( int ) ( ( char ) stack . Peek ( ) ) ; if ( ( a - b ) >= 1 || ( a == b ) ) stack . Push ( s [ i ] ) ; else if ( ( b - a ) >= 1 ) { while ( ( b - a ) >= 1 ) { tempstack . Push ( stack . Peek ( ) ) ; stack . Pop ( ) ; if ( stack . Count > 0 ) b = ( int ) ( ( char ) stack . Peek ( ) ) ; else break ; } stack . Push ( s [ i ] ) ; while ( tempstack . Count > 0 ) { stack . Push ( tempstack . Peek ( ) ) ; tempstack . Pop ( ) ; } } } string answer = "" ; while ( stack . Count > 0 ) { answer = stack . Peek ( ) + answer ; stack . Pop ( ) ; } Console . WriteLine ( answer ) ; }
int countTriplets ( int [ ] arr , int n , int a , int b ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) { ans ++ ; } } } } return ans ; }
int countTriplets ( int [ ] arr , int n , int a , int b ) { int res ; res = countTripletsLessThan ( arr , n , b ) - countTripletsLessThan ( arr , n , a - 1 ) ; return res ; }
bool checkFittingArrays ( int [ ] A , int [ ] B , int N ) { Array . Sort ( A ) ; Array . Sort ( B ) ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; }
int maximum_toys ( int [ ] cost , int N , int K ) { int count = 0 , sum = 0 ; Array . Sort ( cost ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; }
int findMinimumSwaps ( int [ ] arr , int n , int k ) { int pos = 0 , num_min , num_max , need_minimum , need_maximum , swaps ; num_min = num_max = need_minimum = 0 ; need_maximum = swaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < k ) { num_min ++ ; } else if ( arr [ i ] > k ) { num_max ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == k ) { pos = i ; break ; } } int left , right , mid ; left = 0 ; right = n - 1 ; while ( left <= right ) { mid = ( left + right ) / 2 ; if ( arr [ mid ] == k ) { break ; } else if ( arr [ mid ] > k ) { if ( pos > mid ) { need_minimum ++ ; } else { num_min -- ; } left = mid + 1 ; } else { if ( pos < mid ) { need_maximum ++ ; } else { num_max -- ; } right = mid - 1 ; } } if ( need_minimum > need_maximum ) { swaps = swaps + need_maximum ; num_min = num_min - need_maximum ; need_minimum = need_minimum - need_maximum ; need_maximum = 0 ; } else { swaps = swaps + need_minimum ; num_max = num_max - need_minimum ; need_maximum = need_maximum - need_minimum ; need_minimum = 0 ; } if ( need_maximum > num_max need_minimum > num_min ) { return - 1 ; } else { return ( swaps + need_maximum + need_minimum ) ; } }
void findOptimalPairs ( int [ ] arr , int N ) { Array . Sort ( arr ) ; for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) Console . Write ( "(" + arr [ i ] + ", " + arr [ j ] + ")" + " " ) ; }
Stack < int > sortStack ( ref Stack < int > input ) { Stack < int > tmpStack = new Stack < int > ( ) ; while ( input . Count != 0 ) { int tmp = input . Peek ( ) ; input . Pop ( ) ; while ( tmpStack . Count != 0 && tmpStack . Peek ( ) > tmp ) { input . Push ( tmpStack . Peek ( ) ) ; tmpStack . Pop ( ) ; } tmpStack . Push ( tmp ) ; } return tmpStack ; }
Stack < int > sortedMerge ( ref Stack < int > s1 , ref Stack < int > s2 ) { Stack < int > res = new Stack < int > ( ) ; while ( s1 . Count != 0 ) { res . Push ( s1 . Peek ( ) ) ; s1 . Pop ( ) ; } while ( s2 . Count != 0 ) { res . Push ( s2 . Peek ( ) ) ; s2 . Pop ( ) ; } return sortStack ( ref res ) ; }
int MaxTotalRectangleArea ( int [ ] a , int n ) { Array . Sort ( a ) ; Array . Reverse ( a ) ; int sum = 0 ; bool flag = false ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( ! flag ) ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; }
bool isSortedDesc ( Node head ) { if ( head == null ) return true ; if ( head == null ) return true ; for ( Node t = head ; t . next != null ; t = t . next ) if ( t . data <= t . next . data ) return false ; return true ; }
void evenOddInsertionSort ( int [ ] arr , int n ) { for ( int i = 2 ; i < n ; i ++ ) { int j = i - 2 ; int temp = arr [ i ] ; if ( ( ( i + 1 ) & 1 ) == 1 ) { while ( j >= 0 && temp >= arr [ j ] ) { arr [ j + 2 ] = arr [ j ] ; j -= 2 ; } arr [ j + 2 ] = temp ; } else { while ( j >= 0 && temp <= arr [ j ] ) { arr [ j + 2 ] = arr [ j ] ; j -= 2 ; } arr [ j + 2 ] = temp ; } } }
void sort ( List < int > a , int n ) { for ( int i = n ; i >= 0 ; i -- ) for ( int j = n ; j > n - i ; j -- ) if ( a [ j ] > a [ j - 1 ] ) { int tempswap = a [ j ] ; a [ j ] = a [ j - 1 ] ; a [ j - 1 ] = tempswap ; } print ( a , n ) ; }
void insertionSort ( List < int > V ) { int N = V . Count ; int i , j ; for ( i = 1 ; i < N ; i ++ ) { j = i ; while ( j > 0 && V [ j ] < V [ j - 1 ] ) { int temp = V [ j ] ; V [ j ] = V [ j - 1 ] ; V [ j - 1 ] = temp ; j -= 1 ; } } }
void insertionSortRecursive ( List < int > V , int N ) { if ( N <= 1 ) return ; insertionSortRecursive ( V , N - 1 ) ; int j = N - 1 ; while ( j > 0 && V [ j ] < V [ j - 1 ] ) { int temp = V [ j ] ; V [ j ] = V [ j - 1 ] ; V [ j - 1 ] = temp ; j -= 1 ; } }
void sort012 ( int [ ] arr , int n ) { int count0 = 0 , count1 = 0 ; int count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count0 ++ ; if ( arr [ i ] == 1 ) count1 ++ ; if ( arr [ i ] == 2 ) count2 ++ ; } for ( int i = 0 ; i < count0 ; i ++ ) arr [ i ] = 0 ; for ( int i = count0 ; i < ( count0 + count1 ) ; i ++ ) arr [ i ] = 1 ; for ( int i = ( count0 + count1 ) ; i < n ; i ++ ) arr [ i ] = 2 ; printArray ( arr , n ) ; }
void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; Console . WriteLine ( ) ; }
int minElements ( int [ ] arr , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; Array . Sort ( arr ) ; int res = 0 , curr_sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
int distancesum ( int [ ] x , int [ ] y , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( Math . Abs ( x [ i ] - x [ j ] ) + Math . Abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
int distancesum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int res = 0 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += ( arr [ i ] * i - sum ) ; sum += arr [ i ] ; } return res ; }
int totaldistancesum ( int [ ] x , int [ ] y , int n ) { return distancesum ( x , n ) + distancesum ( y , n ) ; }
int minimumBox ( int [ ] arr , int n ) { Queue < int > q = new Queue < int > ( ) ; Array . Sort ( arr ) ; q . Enqueue ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . Peek ( ) ; if ( arr [ i ] >= 2 * now ) q . Dequeue ( ) ; q . Enqueue ( arr [ i ] ) ; } return q . Count ; }
void sortRec ( int [ ] arr , int index , int k , int n ) { if ( k == 0 ) { for ( int i = 1 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; Console . WriteLine ( 999 ) ; return ; } else if ( k > 0 && index == 0 ) { index = n - 2 ; for ( int i = 1 ; i <= index ; i ++ ) { arr [ i - 1 ] = arr [ i ] ; } arr [ index ] = 999 ; } if ( index - 1 >= 0 && index + 1 < n && arr [ index - 1 ] > arr [ index + 1 ] ) { swap ( arr , index , index + 1 ) ; swap ( arr , index - 1 , index + 1 ) ; } else swap ( arr , index , index - 1 ) ; sortRec ( arr , index - 1 , k - 1 , n ) ; }
void sortString ( String str ) { int [ ] charCount = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . Length ; i ++ ) { charCount [ str [ i ] - 'a' ] ++ ; } for ( int i = MAX_CHAR - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < charCount [ i ] ; j ++ ) { Console . Write ( ( char ) ( 'a' + i ) ) ; } } }
void printMedian ( int [ ] arr , int n , int K ) { Array . Sort ( arr ) ; Console . Write ( arr [ ( n + K ) / 2 ] ) ; }
void stableSelectionSort ( int [ ] a , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ min ] > a [ j ] ) min = j ; int key = a [ min ] ; while ( min > i ) { a [ min ] = a [ min - 1 ] ; min -- ; } a [ i ] = key ; } }
void sortBinaryArray ( int [ ] a , int n ) { int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 ) { j ++ ; int temp = a [ j ] ; a [ j ] = a [ i ] ; a [ i ] = temp ; } } }
bool almostSort ( int [ ] A , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { int temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; i ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; }
void minMaxSelectionSort ( int [ ] arr , int n ) { for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { int min = arr [ i ] , max = arr [ i ] ; int min_i = i , max_i = i ; for ( int k = i ; k <= j ; k ++ ) { if ( arr [ k ] > max ) { max = arr [ k ] ; max_i = k ; } else if ( arr [ k ] < min ) { min = arr [ k ] ; min_i = k ; } } swap ( arr , i , min_i ) ; if ( arr [ min_i ] == max ) swap ( arr , j , min_i ) ; else swap ( arr , j , max_i ) ; } }
int nextGap ( int gap ) { if ( gap <= 1 ) return 0 ; return ( gap / 2 ) + ( gap % 2 ) ; }
void arrange ( int [ ] arr , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { int diff = Math . Abs ( arr [ i ] - x ) ; int j = i - 1 ; if ( Math . Abs ( arr [ j ] - x ) > diff ) { int temp = arr [ i ] ; while ( j >= 0 && Math . Abs ( arr [ j ] - x ) > diff ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = temp ; } } }
void printOrder ( int [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) Console . Write ( arr [ i ] + " " ) ; for ( int j = n - 1 ; j >= n / 2 ; j -- ) Console . Write ( arr [ j ] + " " ) ; }
int findDuplicate ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int i = 0 ; while ( i < n ) { int j , count = 1 ; for ( j = i + 1 ; j < n && arr [ j ] == arr [ i ] ; j ++ ) count ++ ; if ( count == k ) return arr [ i ] ; i = j ; } return - 1 ; }
int findDuplicate ( int [ ] arr , int n , int k ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { Console . WriteLine ( "Out of range" ) ; return - 1 ; } freq [ arr [ i ] ] += 1 ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == k ) return i ; } return - 1 ; }
int maxProductSubarrayOfSizeK ( int [ ] A , int n , int k ) { Array . Sort ( A ) ; int product = 1 ; int i ; if ( A [ n - 1 ] == 0 && k % 2 != 0 ) return 0 ; if ( A [ n - 1 ] <= 0 && k % 2 != 0 ) { for ( i = n - 1 ; i >= n - k ; i -- ) product *= A [ i ] ; return product ; } i = 0 ; int j = n - 1 ; if ( k % 2 != 0 ) { product *= A [ j ] ; j -- ; k -- ; } k >>= 1 ; for ( int itr = 0 ; itr < k ; itr ++ ) { int left_product = A [ i ] * A [ i + 1 ] ; int right_product = A [ j ] * A [ j - 1 ] ; if ( left_product > right_product ) { product *= left_product ; i += 2 ; } else { product *= right_product ; j -= 2 ; } } return product ; }
int findMaximum ( int [ ] arr , int n , int k ) { int res = 0 , index = 0 ; for ( int i = n - 1 ; i >= index ; i -- ) { res += arr [ i ] ; index += k ; } return res ; }
void insertionSort ( int [ ] arr , int left , int right ) { for ( int i = left + 1 ; i <= right ; i ++ ) { int temp = arr [ i ] ; int j = i - 1 ; while ( j >= left && arr [ j ] > temp ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = temp ; } }
void merge ( int [ ] arr , int l , int m , int r ) { int len1 = m - l + 1 , len2 = r - m ; int [ ] left = new int [ len1 ] ; int [ ] right = new int [ len2 ] ; for ( int x = 0 ; x < len1 ; x ++ ) left [ x ] = arr [ l + x ] ; for ( int x = 0 ; x < len2 ; x ++ ) right [ x ] = arr [ m + 1 + x ] ; int i = 0 ; int j = 0 ; int k = l ; while ( i < len1 && j < len2 ) { if ( left [ i ] <= right [ j ] ) { arr [ k ] = left [ i ] ; i ++ ; } else { arr [ k ] = right [ j ] ; j ++ ; } k ++ ; } while ( i < len1 ) { arr [ k ] = left [ i ] ; k ++ ; i ++ ; } while ( j < len2 ) { arr [ k ] = right [ j ] ; k ++ ; j ++ ; } }
bool checkForSorting ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { else return false ; } } return true ; } public static void Main ( ) { int [ ] arr = { 1 , 0 , 3 , 2 } ; int n = arr . Length ; if ( checkForSorting ( arr , n ) ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; } }
void sort ( String [ ] s , int n ) { for ( int i = 1 ; i < n ; i ++ ) { String temp = s [ i ] ; int j = i - 1 ; while ( j >= 0 && temp . Length < s [ j ] . Length ) { s [ j + 1 ] = s [ j ] ; j -- ; } s [ j + 1 ] = temp ; } }
void printArraystring ( String [ ] str , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( str [ i ] + " " ) ; }
int maxLevel ( int [ ] boxes , int n ) { Array . Sort ( boxes ) ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }
void stoogesort ( int [ ] arr , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) { int t = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = t ; } if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3 ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } }
int merge ( int [ ] arr , int [ ] temp , int left , int mid , int right ) { int inv_count = 0 ; int i = left ; int j = mid ; int k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) { temp [ k ++ ] = arr [ i ++ ] ; } else { temp [ k ++ ] = arr [ j ++ ] ; inv_count = inv_count + ( mid - i ) ; } } while ( i <= mid - 1 ) { temp [ k ++ ] = arr [ i ++ ] ; } while ( j <= right ) { temp [ k ++ ] = arr [ j ++ ] ; } for ( i = left ; i <= right ; i ++ ) { arr [ i ] = temp [ i ] ; } return inv_count ; }
int mergeSort ( int [ ] arr , int array_size ) { int [ ] temp = new int [ array_size ] ; return _mergeSort ( arr , temp , 0 , array_size - 1 ) ; }
int minDifferenceAmongMaxMin ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; int res = 2147483647 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . Min ( res , curSeqDiff ) ; } return res ; }
void insertionSortRecursive ( int [ ] arr , int n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; int last = arr [ n - 1 ] ; int j = n - 2 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; }
void twoWaySort ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; }
int partition ( int [ ] arr , int low , int high ) { int pivot = arr [ low ] ; int i = low - 1 , j = high + 1 ; while ( true ) { do { i ++ ; } while ( arr [ i ] < pivot ) ; do { j -- ; } while ( arr [ j ] > pivot ) ; if ( i >= j ) return j ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } }
void quickSort ( int [ ] arr , int low , int high ) { if ( low < high ) { int pi = partition ( arr , low , high ) ; quickSort ( arr , low , pi ) ; quickSort ( arr , pi + 1 , high ) ; } }
int ksmallest ( int [ ] arr , int n , int k ) { int [ ] b = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) { k -- ; } if ( k != 1 ) { return j ; } } return int . MaxValue ; }
int ksmallest ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { int c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; }
void multiply ( int [ , ] A , int [ , ] B , int [ , ] C ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { C [ i , j ] = 0 ; for ( int k = 0 ; k < V ; k ++ ) { C [ i , j ] += A [ i , k ] * B [ k , j ] ; } } } }
int getTrace ( int [ , ] graph ) { int trace = 0 ; for ( int i = 0 ; i < V ; i ++ ) { trace += graph [ i , i ] ; } return trace ; }
int triangleInGraph ( int [ , ] graph ) { int [ , ] aux2 = new int [ V , V ] ; int [ , ] aux3 = new int [ V , V ] ; for ( int i = 0 ; i < V ; ++ i ) { for ( int j = 0 ; j < V ; ++ j ) { aux2 [ i , j ] = aux3 [ i , j ] = 0 ; } } multiply ( graph , graph , aux2 ) ; multiply ( graph , aux2 , aux3 ) ; int trace = getTrace ( aux3 ) ; return trace / 6 ; }
int minSum ( int [ ] arr , int n ) { List < int > evenArr = new List < int > ( ) ; List < int > oddArr = new List < int > ( ) ; int i ; Array . Sort ( arr ) ; for ( i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) { oddArr . Add ( arr [ i ] ) ; } else { evenArr . Add ( arr [ i ] ) ; } } evenArr . Sort ( ) ; evenArr . Reverse ( ) ; int k = 0 , sum = 0 ; for ( int j = 0 ; j < evenArr . Count ; j ++ ) { arr [ k ++ ] = evenArr [ j ] ; arr [ k ++ ] = oddArr [ j ] ; sum += evenArr [ j ] * oddArr [ j ] ; } return sum ; }
void mergeTwoHalf ( int [ ] A , int n ) { Array . Sort ( A ) ; }
int minDiff ( int [ ] arr , int n , int k ) { int result = int . MaxValue ; Array . Sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . Min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
bool isPossible ( int [ ] a , int [ ] b , int n , int k ) { Array . Sort ( a ) ; Array . Reverse ( b ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }
void bitonicGenerator ( int [ ] arr , int n ) { List < int > evenArr = new List < int > ( ) ; List < int > oddArr = new List < int > ( ) ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( i % 2 != 1 ) { evenArr . Add ( arr [ i ] ) ; } else { oddArr . Add ( arr [ i ] ) ; } } evenArr . Sort ( ) ; oddArr . Sort ( ) ; oddArr . Reverse ( ) ; i = 0 ; for ( int j = 0 ; j < evenArr . Count ; j ++ ) { arr [ i ++ ] = evenArr [ j ] ; } for ( int j = 0 ; j < oddArr . Count ; j ++ ) { arr [ i ++ ] = oddArr [ j ] ; } }
int findMinDiff ( int [ ] arr , int n , int m ) { if ( m == 0 n == 0 ) return 0 ; Array . Sort ( arr ) ; if ( n < m ) return - 1 ; int min_diff = int . MaxValue ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; }
long minValue ( int [ ] a , int [ ] b , int n ) { Array . Sort ( a ) ; Array . Sort ( b ) ; long result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( a [ i ] * b [ n - i - 1 ] ) ; return result ; }
int merge ( int [ ] arr , int [ ] temp , int left , int mid , int right ) { int inv_count = 0 ; int i = left ; int j = mid ; int k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else { temp [ k ++ ] = arr [ j ++ ] ; inv_count = inv_count + ( mid - i ) ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; }
int _mergeSort ( int [ ] arr , int [ ] temp , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; }
bool isEven ( int n ) { return ( n % 2 == 0 ) ; }
bool isEven ( int n ) { if ( ( n & 1 ) == 0 ) return true ; else return false ; }
int findSubsequenceCount ( string S , string T ) { int m = T . Length ; int n = S . Length ; if ( m > n ) return 0 ; int [ , ] mat = new int [ m + 1 , n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i , 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 , j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i , j ] = mat [ i , j - 1 ] ; else mat [ i , j ] = mat [ i , j - 1 ] + mat [ i - 1 , j - 1 ] ; } } return mat [ m , n ] ; }
int countBits ( int a ) { int count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; }
void insertionSort ( int [ ] arr , int [ ] aux , int n ) { for ( int i = 1 ; i < n ; i ++ ) { int key1 = aux [ i ] ; int key2 = arr [ i ] ; int j = i - 1 ; while ( j >= 0 && aux [ j ] < key1 ) { aux [ j + 1 ] = aux [ j ] ; arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } aux [ j + 1 ] = key1 ; arr [ j + 1 ] = key2 ; } }
void sortBySetBitCount ( int [ ] arr , int n ) { int [ ] aux = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) aux [ i ] = countBits ( arr [ i ] ) ; insertionSort ( arr , aux , n ) ; }
int countBits ( int a ) { int count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; }
void sortBySetBitCount ( int [ ] arr , int n ) { List < int > [ ] count = new List < int > [ 32 ] ; for ( int i = 0 ; i < count . Length ; i ++ ) count [ i ] = new List < int > ( ) ; int setbitcount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { setbitcount = countBits ( arr [ i ] ) ; count [ setbitcount ] . Add ( arr [ i ] ) ; } int j = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { List < int > v1 = count [ i ] ; for ( int p = 0 ; p < v1 . Count ; p ++ ) arr [ j ++ ] = v1 [ p ] ; } }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void findSurpasser ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; Console . Write ( count + " " ) ; } }
void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; Console . WriteLine ( ) ; }
int solve ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int max_product = int . MinValue ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = Math . Max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int [ ] leftMin = new int [ n ] ; int [ ] rightMin = new int [ n ] ; int [ ] leftMax = new int [ n ] ; int [ ] rightMax = new int [ n ] ; Array . Fill ( leftMin , - 1 ) ; Array . Fill ( leftMax , - 1 ) ; Array . Fill ( rightMax , - 1 ) ; Array . Fill ( rightMin , - 1 ) ; int max_product = int . MinValue ; int max_sum = arr [ 0 ] ; int min_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { leftMax [ i ] = max_sum ; if ( arr [ i ] > max_sum ) max_sum = arr [ i ] ; leftMin [ i ] = min_sum ; if ( arr [ i ] < min_sum ) min_sum = arr [ i ] ; } max_sum = arr [ n - 1 ] ; min_sum = arr [ n - 1 ] ; for ( int j = n - 2 ; j >= 0 ; j -- ) { rightMax [ j ] = max_sum ; if ( arr [ j ] > max_sum ) max_sum = arr [ j ] ; rightMin [ j ] = min_sum ; if ( arr [ j ] < min_sum ) min_sum = arr [ j ] ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { int max1 = Math . Max ( arr [ i ] * leftMax [ i ] * rightMax [ i ] , arr [ i ] * leftMin [ i ] * rightMin [ i ] ) ; int max2 = Math . Max ( arr [ i ] * leftMax [ i ] * rightMin [ i ] , arr [ i ] * leftMin [ i ] * rightMax [ i ] ) ; max_product = Math . Max ( max_product , Math . Max ( max1 , max2 ) ) ; } return max_product ; }
int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) { return - 1 ; } Array . Sort ( arr ) ; return Math . Max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }
int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int maxA = Int32 . MinValue , maxB = Int32 . MinValue , maxC = Int32 . MinValue ; int minA = Int32 . MaxValue , minB = Int32 . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; if ( arr [ i ] < minA ) { minB = minA ; minA = arr [ i ] ; } else if ( arr [ i ] < minB ) minB = arr [ i ] ; } return Math . Max ( minA * minB * maxA , maxA * maxB * maxC ) ; }
int distinctCount ( int [ ] arr , int n ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . Add ( Math . Abs ( arr [ i ] ) ) ; return s . Count ; }
int distinctCount ( int [ ] arr , int n ) { int count = n ; int i = 0 , j = n - 1 , sum = 0 ; while ( i < j ) { while ( i != j && arr [ i ] == arr [ i + 1 ] ) { count -- ; i ++ ; } while ( i != j && arr [ j ] == arr [ j - 1 ] ) { count -- ; j -- ; } if ( i == j ) break ; sum = arr [ i ] + arr [ j ] ; if ( sum == 0 ) { count -- ; i ++ ; j -- ; } else if ( sum < 0 ) i ++ ; else j -- ; } return count ; }
void findMaxGuests ( int [ ] arrl , int [ ] exit , int n ) { Array . Sort ( arrl ) ; Array . Sort ( exit ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } Console . Write ( "Maximum Number of Guests = " + max_guests + " at time " + time ) ; }
int binarySearch ( int [ ] a , int item , int low , int high ) { while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( item == a [ mid ] ) return mid + 1 ; else if ( item > a [ mid ] ) low = mid + 1 ; else high = mid - 1 ; } return low ; }
void insertionSort ( int [ ] a , int n ) { int i , loc , j , selected ; for ( i = 1 ; i < n ; ++ i ) { j = i - 1 ; selected = a [ i ] ; loc = binarySearch ( a , selected , 0 , j ) ; while ( j >= loc ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = selected ; } }
int findMax ( int [ ] arr , int n ) { int mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; }
void printArray ( int [ ] arr , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) Console . Write ( arr [ i ] + " " ) ; Console . Write ( "" ) ; }
int minMoves ( char [ , ] a , char [ , ] b , int K ) { int n = a . Length ; int m = a . GetLength ( 0 ) ; int cntOperations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i , j ] != b [ i , j ] ) { cntOperations ++ ; if ( i + K - 1 >= n j + K - 1 >= m ) { return - 1 ; } for ( int p = 0 ; p <= K - 1 ; p ++ ) { for ( int q = 0 ; q <= K - 1 ; q ++ ) { if ( a [ i + p , j + q ] == '0' ) { a [ i + p , j + q ] = '1' ; } else { a [ i + p , j + q ] = '0' ; } } } } } } return cntOperations ; }
int maxConsecutiveCnt ( int [ ] arr ) { int X = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( arr [ i ] <= ( X + 1 ) ) { X = X + arr [ i ] ; } else { break ; } } return X + 1 ; }
void findPermutation ( int N , int L , int R , int S ) { int x = R - L + 1 ; if ( ! possible ( x , S , N ) ) { Console . WriteLine ( - 1 ) ; return ; } else { List < int > v = new List < int > ( ) ; for ( int i = N ; i >= 1 ; -- i ) { if ( ( S - i ) >= 0 && possible ( x - 1 , S - i , i - 1 ) ) { S = S - i ; x -- ; v . Add ( i ) ; } if ( S == 0 ) { break ; } } if ( S != 0 ) { Console . WriteLine ( - 1 ) ; return ; } List < int > v1 = new List < int > ( ) ; for ( int i = 1 ; i <= N ; ++ i ) { bool it = v . Contains ( i ) ; if ( ! it ) { v1 . Add ( i ) ; } } int j = 0 , f = 0 ; for ( int i = 1 ; i < L ; ++ i ) { Console . Write ( v1 [ j ] + " " ) ; j ++ ; } for ( int i = L ; i <= R ; ++ i ) { Console . Write ( v [ f ] + " " ) ; f ++ ; } for ( int i = R + 1 ; i <= N ; ++ i ) { Console . Write ( v1 [ j ] + " " ) ; j ++ ; } } return ; }
int maxShiftArrayValue ( int [ ] arr , int [ ] cap , int N ) { int sumVals = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumVals += arr [ i ] ; } int maxCapacity = 0 ; for ( int i = 0 ; i < N ; i ++ ) { maxCapacity = Math . Max ( cap [ i ] , maxCapacity ) ; } return Math . Min ( maxCapacity , sumVals ) ; }
int minimumSizeArray ( int S , int P ) { if ( S == P ) { return 1 ; } for ( int i = 2 ; i <= S ; i ++ ) { double d = i ; if ( ( S / d ) >= Math . Pow ( P , 1.0 / d ) ) { return i ; } } return - 1 ; }
int countPoints ( int D ) { int count = 0 ; for ( int x = 1 ; x * x < D * D ; x ++ ) { int y = ( int ) Math . Sqrt ( ( D * D - x * x ) ) ; if ( x * x + y * y == D * D ) { count += 4 ; } } count += 4 ; return count ; }
int minimizeCost ( int A , int B , int C ) { int ans = A + B + C ; for ( int i = 1 ; i <= 2 * C ; i ++ ) { int j = 0 ; while ( i * j <= 2 * C ) { ans = Math . Min ( ans , Math . Abs ( A - i ) + Math . Abs ( B - j ) + Math . Abs ( i * j - C ) ) ; j ++ ; } } return ans ; }
double averageSetBits ( int N , int K , int [ ] arr ) { double p = N ; double q = 0 ; for ( int i = 0 ; i < K ; i ++ ) { double _p = p , _q = q ; p = _p - _p * arr [ i ] / N + _q * arr [ i ] / N ; q = _q - _q * arr [ i ] / N + _p * arr [ i ] / N ; } return p ; }
long KthSolution ( long X , long K ) { long ans = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( X & ( 1L L << i ) ) == 0 ) { if ( ( K & 1 ) > 0 ) { ans |= ( 1L L << i ) ; } K >>= 1 ; if ( K == 0 ) { break ; } } } return ans ; }
int minimumcoins ( int [ ] arr , int N ) { int coins = 0 ; int j = 0 ; if ( arr [ 0 ] == 1 ) coins ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 2 ) continue ; j = i ; while ( j < N && arr [ j ] == 1 ) { j ++ ; } int x = ( j - i ) ; coins += x / 3 ; i = j - 1 ; } return coins ; }
int maximumUniqueSquares ( int N ) { int ans = 0 ; if ( N < 4 ) { return 0 ; } int len = ( int ) ( Math . Sqrt ( N ) ) ; N -= len * len ; for ( int i = 1 ; i < len ; i ++ ) { ans += i * i ; } if ( N >= len ) { N -= len ; for ( int i = 1 ; i < len ; i ++ ) { ans += i ; } } for ( int i = 1 ; i < N ; i ++ ) { ans += i ; } return ans ; }
void rearrange ( int [ ] arr , int N ) { if ( ( N & 1 ) != 0 ) N -- ; int odd_idx = 1 , even_idx = 0 ; int i , max_elem = arr [ N - 1 ] + 1 ; for ( i = 0 ; i < N / 2 ; i ++ ) { arr [ i ] += ( arr [ odd_idx ] % max_elem ) * max_elem ; odd_idx += 2 ; } for ( ; i < N ; i ++ ) { arr [ i ] += ( arr [ even_idx ] % max_elem ) * max_elem ; even_idx += 2 ; } for ( i = 0 ; i < N ; i ++ ) { arr [ i ] = arr [ i ] / max_elem ; } }
void generateString ( int k1 , int k2 , char [ ] s ) { int C1s = 0 , C0s = 0 ; int flag = 0 ; List < int > pos = new List < int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '0' ) { C0s ++ ; if ( ( i + 1 ) % k1 != 0 && ( i + 1 ) % k2 != 0 ) { pos . Add ( i ) ; } } else { C1s ++ ; } if ( C0s >= C1s ) { if ( pos . Count == 0 ) { Console . WriteLine ( - 1 ) ; flag = 1 ; break ; } else { int k = pos [ ( pos . Count - 1 ) ] ; s [ k ] = '1' ; C0s -- ; C1s ++ ; pos . Remove ( pos . Count - 1 ) ; } } } if ( flag == 0 ) { Console . WriteLine ( s ) ; } }
void findRange ( int [ ] arr , int N , int K ) { int L = Int32 . MinValue ; int R = Int32 . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { int l = ( int ) Math . Ceiling ( 1.0 * arr [ i ] * K / ( i + 1 ) ) ; int r = ( int ) Math . Ceiling ( ( 1.0 + arr [ i ] ) * K / ( i + 1 ) ) - 1 ; L = Math . Max ( L , l ) ; R = Math . Min ( R , r ) ; } Console . WriteLine ( L + " " + R ) ; }
void findAnagram ( string s ) { string check = s ; int i = 0 , j = s . Length - 1 ; while ( i < s . Length && j >= 0 ) { if ( s [ i ] != s [ j ] && check [ i ] != s [ j ] && check [ j ] != s [ i ] ) { char temp = s [ i ] ; s = s . Substring ( 0 , i ) + s [ j ] + s . Substring ( i + 1 ) ; s = s . Substring ( 0 , j ) + temp + s . Substring ( j + 1 ) ; i ++ ; j = s . Length - 1 ; } else { j -- ; } } if ( s . Length % 2 != 0 ) { int mid = s . Length / 2 ; if ( check [ mid ] == s [ mid ] ) { for ( i = 0 ; i < s . Length ; i ++ ) { if ( check [ i ] != s [ mid ] && s [ i ] != s [ mid ] ) { char temp = s [ i ] ; s = s . Substring ( 0 , i ) + s [ mid ] + s . Substring ( i + 1 ) ; s = s . Substring ( 0 , mid ) + temp + s . Substring ( mid + 1 ) ; break ; } } } } bool ok = true ; for ( i = 0 ; i < s . Length ; i ++ ) { if ( check [ i ] == s [ i ] ) { ok = false ; break ; } } if ( ok ) Console . Write ( s ) ; else Console . Write ( - 1 ) ; }
void maximizeProduct ( int N ) { int MSB = ( int ) ( Math . Log ( N ) / Math . Log ( 2 ) ) ; int X = 1 << MSB ; int Y = N - ( 1 << MSB ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) { X += 1 << i ; Y += 1 << i ; } } Console . Write ( X + " " + Y ) ; }
void constructPermutation ( string S , int N ) { int [ ] ans = new int [ N ] ; ans [ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) { if ( S [ i - 1 ] == '0' ) { ans [ i ] = i + 1 ; } else { ans [ i ] = ans [ i - 1 ] ; } for ( int j = 0 ; j < i ; ++ j ) { if ( ans [ j ] >= ans [ i ] ) { ans [ j ] ++ ; } } } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( ans [ i ] ) ; if ( i != N - 1 ) { Console . Write ( " " ) ; } } }
int findRemainingIndex ( int N ) { int ans = N ; while ( N > 1 ) { int discard = ( int ) ( Math . Sqrt ( N ) ) ; if ( discard * discard == N ) { ans -- ; } N -= discard ; } return ans ; }
void findRemainingElement ( int [ ] arr , int N ) { int remainingIndex = findRemainingIndex ( N ) ; Console . Write ( arr [ remainingIndex - 1 ] ) ; }
bool check ( int num ) { int sm = 0 ; int num2 = num * num ; while ( num > 0 ) { sm += num % 10 ; num /= 10 ; } int sm2 = 0 ; while ( num2 > 0 ) { sm2 += num2 % 10 ; num2 /= 10 ; } return ( ( sm * sm ) == sm2 ) ; }
void generate ( string s , int len , HashSet < int > uniq ) { if ( s . Length == len ) { if ( check ( convert ( s ) ) ) { uniq . Add ( convert ( s ) ) ; } return ; } for ( int i = 0 ; i <= 3 ; i ++ ) { generate ( s + Convert . ToChar ( i + ( int ) '0' ) , len , uniq ) ; } }
int totalNumbers ( int L , int R ) { int ans = 0 ; int max_len = ( int ) Math . Log10 ( R ) + 1 ; HashSet < int > uniq = new HashSet < int > ( ) ; for ( int i = 1 ; i <= max_len ; i ++ ) { generate ( "" , i , uniq ) ; } foreach ( int x in uniq ) { if ( x >= L && x <= R ) { ans ++ ; } } return ans ; }
void findMaximumSumWithMflips ( int [ ] arr , int N , int M ) { List < int > minHeap = new List < int > ( ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { minHeap . Add ( arr [ i ] ) ; sum += arr [ i ] ; } minHeap . Sort ( ) ; while ( M -- > 0 ) { sum -= minHeap [ 0 ] ; int temp = - 1 * minHeap [ 0 ] ; minHeap . RemoveAt ( 0 ) ; sum += temp ; minHeap . Add ( temp ) ; minHeap . Sort ( ) ; } Console . WriteLine ( sum ) ; }
bool check ( int x , int N ) { while ( true ) { N -= x ; if ( x < 10 ) break ; int temp2 = 0 ; while ( x > 0 ) { temp2 += ( x % 10 ) ; x = ( int ) x / 10 ; } x = temp2 ; } if ( ( x < 10 ) && ( N == 0 ) ) { return true ; } return false ; }
int minimumMoves ( int [ ] A , int [ ] B , int N ) { int ans = 0 ; int sum_A = 0 , sum_B = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum_A += A [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { sum_B += B [ i ] ; } if ( sum_A != sum_B ) { return - 1 ; } int k = 0 ; while ( k < N ) { if ( A [ k ] > B [ k ] ) { int temp = A [ k ] - B [ k ] ; int j = k - 1 ; while ( j >= 0 && temp > 0 ) { if ( B [ j ] > A [ j ] ) { int cnt = Math . Min ( temp , ( B [ j ] - A [ j ] ) ) ; A [ j ] += cnt ; temp -= cnt ; ans += ( cnt * Math . Abs ( j - k ) ) ; } j -- ; } if ( temp > 0 ) { j = k + 1 ; while ( j < N && temp > 0 ) { if ( B [ j ] > A [ j ] ) { int cnt = Math . Min ( temp , ( B [ j ] - A [ j ] ) ) ; A [ j ] += cnt ; temp -= cnt ; ans += ( cnt * Math . Abs ( j - k ) ) ; } j ++ ; } } } k ++ ; } return ans ; }
int possibleReachingSequence ( int X , int D , int T ) { if ( X < T ) { Console . WriteLine ( "NO" ) ; return 0 ; } if ( T * D < X ) { Console . WriteLine ( "NO" ) ; return 0 ; } if ( ( X - T ) % ( D - 1 ) == 0 ) { Console . WriteLine ( "YES" ) ; } else { Console . WriteLine ( "NO" ) ; } return 0 ; }
int maxSumAfterPartition ( int [ ] arr , int n ) { List < int > pos = new List < int > ( ) ; List < int > neg = new List < int > ( ) ; int zero = 0 ; int pos_sum = 0 ; int neg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { pos . Add ( arr [ i ] ) ; pos_sum += arr [ i ] ; } else if ( arr [ i ] < 0 ) { neg . Add ( arr [ i ] ) ; neg_sum += arr [ i ] ; } else { zero ++ ; } } int ans = 0 ; pos . Sort ( ) ; neg . Sort ( ) ; neg . Reverse ( ) ; if ( pos . Count > 0 && neg . Count > 0 ) { ans = ( pos_sum - neg_sum ) ; } else if ( pos . Count > 0 ) { if ( zero > 0 ) { ans = ( pos_sum ) ; } else { ans = ( pos_sum - 2 * pos [ 0 ] ) ; } } else { if ( zero > 0 ) { ans = ( - 1 * neg_sum ) ; } else { ans = ( neg [ 0 ] - ( neg_sum - neg [ 0 ] ) ) ; } } return ans ; }
int arrayDivisionByTwo ( int [ ] arr , int n ) { int cnt = 0 ; int ans = Int32 . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { cnt = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = arr [ i ] / 2 ; cnt ++ ; } ans = Math . Min ( ans , cnt ) ; } return ans ; }
int minPushes ( int N , int K , int [ ] arr ) { int [ ] dp = new int [ 100000 ] ; for ( int i = 0 ; i < dp . Length ; i ++ ) dp [ i ] = - 1 ; dp [ N ] = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { for ( int xx = 0 ; xx < 100000 ; xx ++ ) { int x = xx ; if ( dp [ x ] == - 1 ) continue ; int next = ( x + arr [ i ] ) % 100000 ; while ( dp [ next ] == - 1 dp [ next ] > dp [ x ] + 1 ) { dp [ next ] = dp [ x ] + 1 ; x = next ; next = ( next + arr [ i ] ) % 100000 ; } } } return dp [ K ] ; }
int minimumOperations ( int [ ] A , int N ) { int cur_prefix_1 = 0 ; int parity = - 1 ; int minOperationsCase1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cur_prefix_1 += A [ i ] ; if ( cur_prefix_1 == 0 parity * cur_prefix_1 < 0 ) { minOperationsCase1 += Math . Abs ( parity - cur_prefix_1 ) ; cur_prefix_1 = parity ; } parity *= - 1 ; } int cur_prefix_2 = 0 ; parity = 1 ; int minOperationsCase2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cur_prefix_2 += A [ i ] ; if ( cur_prefix_2 == 0 parity * cur_prefix_2 < 0 ) { minOperationsCase2 += Math . Abs ( parity - cur_prefix_2 ) ; cur_prefix_2 = parity ; } parity *= - 1 ; } return Math . Min ( minOperationsCase1 , minOperationsCase2 ) ; }
void maximumSumArray ( int [ ] arr , int N ) { int [ ] arrA = new int [ N ] ; int [ ] ans = new int [ N ] ; int maxSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) arrA [ i ] = arr [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { int [ ] arrB = new int [ N ] ; int maximum = arrA [ i ] ; arrB [ i ] = maximum ; for ( int j = i - 1 ; j >= 0 ; j -- ) { arrB [ j ] = Math . Min ( maximum , arrA [ j ] ) ; maximum = arrB [ j ] ; } maximum = arrA [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { arrB [ j ] = Math . Min ( maximum , arrA [ j ] ) ; maximum = arrB [ j ] ; } int sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) sum += arrB [ j ] ; if ( sum > maxSum ) { maxSum = sum ; ans = arrB ; } } foreach ( int val in ans ) { Console . Write ( val + " " ) ; } }
int minProductUtil ( int R1 , int B1 , int R2 , int B2 , int M ) { int x = Math . Min ( R1 - B1 , M ) ; M -= x ; R1 -= x ; if ( M > 0 ) { int y = Math . Min ( R2 - B2 , M ) ; M -= y ; R2 -= y ; } return R1 * R2 ; }
int minProduct ( int R1 , int B1 , int R2 , int B2 , int M ) { int res1 = minProductUtil ( R1 , B1 , R2 , B2 , M ) ; int res2 = minProductUtil ( R2 , B2 , R1 , B1 , M ) ; return Math . Min ( res1 , res2 ) ; }
int maxAmount ( int n , int k , int [ ] arr ) { int i ; int [ ] A = new int [ 1000001 ] ; Array . Clear ( A , 0 , 1000001 ) ; for ( i = 0 ; i < n ; i ++ ) { A [ arr [ i ] ] ++ ; } int j = 0 ; for ( i = 0 ; i < 1000001 ; i ++ ) { while ( A [ i ] != 0 ) { arr [ j ++ ] = i ; A [ i ] -- ; } } int ans = 0 ; int mod = 1000000007 ; i = n - 1 ; j = n - 2 ; while ( k > 0 && j >= 0 ) { if ( arr [ i ] > arr [ j ] ) { ans = ans + Math . Min ( k , ( i - j ) ) * arr [ i ] ; k = k - ( i - j ) ; arr [ i ] -- ; } else { while ( j >= 0 && arr [ j ] == arr [ i ] ) j -- ; if ( j < 0 ) break ; ans = ans + Math . Min ( k , ( i - j ) ) * arr [ i ] ; k = k - ( i - j ) ; arr [ i ] -- ; } } while ( k > 0 && arr [ i ] != 0 ) { ans = ans + Math . Min ( n , k ) * arr [ i ] ; k -= n ; arr [ i ] -- ; } ans = ans % mod ; int x = ans ; return x ; }
int validPermutations ( String str ) { Dictionary < char , int > m = new Dictionary < char , int > ( ) ; int count = str . Length , ans = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( m . ContainsKey ( str [ i ] ) ) m [ str [ i ] ] = m [ str [ i ] ] + 1 ; else m . Add ( str [ i ] , 1 ) ; } for ( int i = 0 ; i < str . Length ; i ++ ) { ans += count - m [ str [ i ] ] ; if ( m . ContainsKey ( str [ i ] ) ) m [ str [ i ] ] = m [ str [ i ] ] - 1 ; count -- ; } return ans + 1 ; }
void maxAverage ( int [ ] A , int N , int X , int Y ) { Array . Sort ( A ) ; int sum = 0 ; double res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; count ++ ; if ( count == X ) { if ( N - i - 1 < X ) { i ++ ; int cnt = 0 ; while ( i < N ) { cnt ++ ; sum += A [ i ] ; i ++ ; } X = X + cnt ; res += ( double ) sum / ( double ) ( X ) ; break ; } res += ( double ) sum / ( double ) ( X ) ; sum = 0 ; count = 0 ; } } Console . WriteLine ( res ) ; }
int maxSum ( int [ , ] arr ) { int m = ( int ) arr . GetLength ( 0 ) ; int n = ( int ) arr . GetLength ( 1 ) - 1 ; int [ , ] dp = new int [ m + 1 , n + 2 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n + 1 ; j ++ ) { dp [ i , j ] = 0 ; } } for ( int i = 1 ; i < m ; ++ i ) dp [ i , 1 ] = arr [ i , 1 ] ; for ( int i = 1 ; i < n + 1 ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) { int mx = 0 ; for ( int k = 1 ; k < m ; ++ k ) { if ( k != j ) { if ( dp [ k , i - 1 ] > mx ) { mx = dp [ k , i - 1 ] ; } } } if ( mx != 0 && arr [ j , i ] != 0 ) { dp [ j , i ] = arr [ j , i ] + mx ; } } } int ans = - 1 ; for ( int i = 1 ; i <= m ; ++ i ) { if ( ( dp [ i , n ] ) != 0 ) ans = Math . Max ( ans , dp [ i , n ] ) ; } return ans ; }
int findMaximumPoints ( int N , int [ ] X , int [ ] H ) { int ans = 0 ; int prev = Int32 . MinValue ; for ( int i = 0 ; i < N ; ++ i ) { if ( prev < ( X [ i ] - H [ i ] ) ) { ++ ans ; prev = X [ i ] ; } else if ( i == N - 1 || ( X [ i ] + H [ i ] ) < X [ i + 1 ] ) { ++ ans ; prev = X [ i ] + H [ i ] ; } else { prev = X [ i ] ; } } return ans ; }
void maxGcd ( int a , int b ) { Console . Write ( Math . Abs ( a - b ) ) ; }
void sumOfCombinationOf4OR5 ( int [ ] arr , int N ) { int [ ] ans = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) ans [ i ] = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 4 ) { continue ; } int sum = Int32 . MaxValue , cnt = 0 ; for ( int j = 0 ; j <= arr [ i ] ; j += 4 ) { if ( ( arr [ i ] - j ) % 5 == 0 ) { sum = Math . Min ( sum , cnt + ( int ) ( arr [ i ] - j ) / 5 ) ; } cnt ++ ; } if ( sum != Int32 . MaxValue ) ans [ i ] = sum ; } foreach ( int num in ans ) Console . Write ( num + " " ) ; }
int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
void printBinaryString ( int [ , ] arr , int N ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) { Console . Write ( 0 ) ; } else { Console . Write ( 1 ) ; } } }
int MinCost ( int [ ] days , int [ ] cost , int N ) { int size = days [ N - 1 ] + 1 ; int [ ] dp = new int [ size ] ; dp [ size - 1 ] = Math . Min ( cost [ 0 ] , Math . Min ( cost [ 1 ] , cost [ 2 ] ) ) ; int ptr = N - 2 ; for ( int i = size - 2 ; i > 0 ; i -- ) { if ( ptr >= 0 && days [ ptr ] == i ) { int val1 = dp [ i + 1 ] + cost [ 0 ] ; int val2 = cost [ 1 ] + ( ( i + 7 >= size ) ? 0 : dp [ i + 7 ] ) ; int val3 = cost [ 2 ] + ( ( i + 30 >= size ) ? 0 : dp [ i + 30 ] ) ; dp [ i ] = Math . Min ( val1 , Math . Min ( val2 , val3 ) ) ; ptr -- ; } else { dp [ i ] = dp [ i + 1 ] ; } } return dp [ 1 ] ; }
int minElements ( int [ ] arr , int N , int K ) { int count = 0 ; long requiredNum = 1 ; int i = 0 ; while ( requiredNum <= K ) { if ( i < N && requiredNum >= arr [ i ] ) { requiredNum += arr [ i ] ; i ++ ; } else { count ++ ; requiredNum += requiredNum ; } } return count ; }
int minimumSteps ( int a , int b ) { int cnt = 0 ; a = Math . Abs ( a - b ) ; cnt = ( a / 5 ) + ( a % 5 ) / 2 + ( a % 5 ) % 2 ; return cnt ; }
int maximumCount ( int [ ] arr , int N ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) odd ++ ; else even ++ ; } if ( odd != 0 && even != 0 ) return N - 2 ; else return N - 1 ; }
void miniOperToMakeAllEleEqual ( int [ ] arr , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % n != 0 ) { Console . WriteLine ( - 1 ) ; return ; } int valueAfterDivision = sum / n ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . Abs ( valueAfterDivision - arr [ i ] ) % k != 0 ) { Console . WriteLine ( - 1 ) ; return ; } count += Math . Abs ( valueAfterDivision - arr [ i ] ) / k ; } Console . WriteLine ( ( int ) count / 2 ) ; }
int countOpenDoors ( int N ) { int doorsOpen = ( int ) Math . Sqrt ( N ) ; return doorsOpen ; }
int minPossibleValue ( int N , int K , int X ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( X <= K ) { X = X * 2 ; } else { X = X + K ; } } return X ; }
void findMissingValue ( int [ ] arr , int N ) { int minE = Int32 . MaxValue , maxE = Int32 . MinValue ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == - 1 && arr [ i + 1 ] != - 1 ) { minE = Math . Min ( minE , arr [ i + 1 ] ) ; maxE = Math . Max ( maxE , arr [ i + 1 ] ) ; } if ( arr [ i ] != - 1 && arr [ i + 1 ] == - 1 ) { minE = Math . Min ( minE , arr [ i ] ) ; maxE = Math . Max ( maxE , arr [ i ] ) ; } } if ( minE == Int32 . MaxValue && maxE == Int32 . MinValue ) { Console . WriteLine ( "0" ) ; } else { Console . WriteLine ( ( minE + maxE ) / 2 ) ; } }
void findLastElement ( int N , int [ ] A ) { int l = A . Length ; int j = 0 ; while ( N > l * ( int ) ( Math . Pow ( 2 , j ) ) ) { N = N - l * ( int ) Math . Pow ( 2 , j ) ; j += 1 ; } int k = 1 ; int r = ( int ) Math . Pow ( 2 , j ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( N > r * i ) k += 1 ; } for ( int i = 0 ; i < l ; i ++ ) { if ( i + 1 == k ) { Console . WriteLine ( A [ i ] ) ; return ; } } }
int findMaxD ( int [ ] arr , int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = Math . Abs ( arr [ i ] - K ) ; } int D = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { D = gcd ( D , arr [ i ] ) ; } return D ; }
void minOperations ( List < int > a ) { int res = Int32 . MaxValue ; int N = a . Count ; for ( int r = 0 ; r < 2 ; r ++ ) { int sum = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( ( i + r ) % 2 == 1 ) { if ( sum <= 0 ) { ans += - sum + 1 ; sum = 1 ; } } else { if ( sum >= 0 ) { ans += sum + 1 ; sum = - 1 ; } } } res = Math . Min ( res , ans ) ; } Console . Write ( res ) ; }
int maxOperations ( String S , int N ) { int X = 0 ; int Y = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '0' ) break ; Y ++ ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == '1' ) break ; X ++ ; } if ( N == X + Y ) return 0 ; return N - ( X + Y ) - 1 ; }
int maximumSum ( string S , int N , int K ) { int sum = 0 ; int [ ] freq = new int [ 256 ] ; Array . Clear ( freq , 0 , 256 ) ; for ( int i = 0 ; i < N ; i ++ ) { freq [ ( int ) S [ i ] ] ++ ; } Array . Sort ( freq ) ; Array . Reverse ( freq ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( K > freq [ i ] ) { sum += freq [ i ] * freq [ i ] ; K -= freq [ i ] ; } else { sum += freq [ i ] * K ; break ; } } return sum ; }
void possibleNumbers ( HashSet < int > numbers , int N , int M , int A , int B ) { if ( M == 0 ) { numbers . Add ( N ) ; return ; } possibleNumbers ( numbers , N + A , M - 1 , A , B ) ; possibleNumbers ( numbers , N + B , M - 1 , A , B ) ; }
void possibleNumbers ( int N , int M , int A , int B ) { if ( A > B ) { int temp = A ; A = B ; B = temp ; } int number = N + M * A ; Console . Write ( number + " " ) ; if ( A != B ) { for ( int i = 0 ; i < M ; i ++ ) { number = number - A + B ; Console . Write ( number + " " ) ; } } }
void maxSum ( int [ ] arr , int n ) { int sum = 0 ; int max_neg = Int32 . MaxValue ; int tempsum = 0 ; int small = Int32 . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; small = Math . Min ( small , arr [ i ] ) ; if ( arr [ i ] > 0 ) { tempsum = 0 ; } else { tempsum += arr [ i ] ; } max_neg = Math . Min ( max_neg , tempsum ) ; } if ( max_neg == 0 ) { max_neg = small ; } Console . Write ( sum - max_neg ) ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
int findVertices ( int n ) { return fib ( n + 2 ) ; }
int MaxBuildingsCovered ( int [ ] arr , int N , int L ) { double curr_sum = 0 ; int start = 0 , curr_count = 0 , max_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum = curr_sum + ( ( double ) arr [ i ] * Pi ) ; if ( i != 0 ) curr_sum += 1 ; if ( curr_sum <= L ) { curr_count ++ ; } else if ( curr_sum > L ) { curr_sum = curr_sum - ( ( double ) arr [ start ] * Pi ) ; curr_sum -= 1 ; start ++ ; curr_count -- ; } max_count = Math . Max ( curr_count , max_count ) ; } return max_count ; }
int num_candyTypes ( int [ ] candies ) { Dictionary < int , int > s = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < candies . Length ; i ++ ) { if ( ! s . ContainsKey ( candies [ i ] ) ) s . Add ( candies [ i ] , 1 ) ; } return s . Count ; }
void distribute_candies ( int [ ] candies ) { int allowed = candies . Length / 2 ; int types = num_candyTypes ( candies ) ; if ( types < allowed ) Console . WriteLine ( types ) ; else Console . WriteLine ( allowed ) ; }
int countUnsetBits ( int N ) { int c = 0 ; while ( N != 0 ) { if ( N % 2 == 0 ) { c += 1 ; } N = N >> 1 ; } return c ; }
void countBitwiseZero ( int N ) { int unsetBits = countUnsetBits ( N ) ; Console . Write ( 1 << unsetBits ) ; }
bool isPossible ( String s ) { int n = s . Length ; int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) ++ count_0 ; else ++ count_1 ; if ( count_1 > count_0 ) return false ; } if ( count_0 != ( 2 * count_1 ) ) return false ; count_0 = 0 ; count_1 = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == '0' ) ++ count_0 ; else ++ count_1 ; if ( count_1 > count_0 ) return false ; } return true ; }
void minimumOperation ( string a , string b ) { int n = a . Length ; int i = 0 ; int minoperation = 0 ; while ( i < n ) { if ( a [ i ] == b [ i ] ) { i = i + 1 ; continue ; } else if ( a [ i ] == b [ i + 1 ] && a [ i + 1 ] == b [ i ] && i < n - 1 ) { minoperation ++ ; i = i + 2 ; } else if ( a [ i ] != b [ i ] ) { minoperation ++ ; i = i + 1 ; } else { ++ i ; } } Console . WriteLine ( minoperation ) ; }
void leastBricks ( List < List < int > > wall ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; int res = 0 ; foreach ( List < int > subList in wall ) { int width = 0 ; for ( int i = 0 ; i < subList . Count - 1 ; i ++ ) { width += subList [ i ] ; if ( map . ContainsKey ( width ) ) map [ width ] ++ ; else map . Add ( width , 1 ) ; res = Math . Max ( res , map [ width ] ) ; } } Console . Write ( wall . Count - res ) ; }
void minimumProdArray ( long [ ] a , long [ ] b , int l ) { long total = 0 ; for ( int i = 0 ; i < a . Length ; ++ i ) { total += a [ i ] * b [ i ] ; } long min = Int32 . MaxValue ; int first = 0 ; int second = 0 ; for ( int i = 0 ; i < a . Length ; ++ i ) { int left = i - 1 ; int right = i + 1 ; long total1 = total ; while ( left >= 0 && right < a . Length ) { total1 -= a [ left ] * b [ left ] + a [ right ] * b [ right ] ; total1 += a [ left ] * b [ right ] + a [ right ] * b [ left ] ; if ( min >= total1 ) { min = total1 ; first = left ; second = right ; } -- left ; ++ right ; } } for ( int i = 0 ; i < a . Length ; ++ i ) { int left = i ; int right = i + 1 ; long total1 = total ; while ( left >= 0 && right < a . Length ) { total1 -= a [ left ] * b [ left ] + a [ right ] * b [ right ] ; total1 += a [ left ] * b [ right ] + a [ right ] * b [ left ] ; if ( min >= total1 ) { min = total1 ; first = left ; second = right ; } -- left ; ++ right ; } } if ( min < total ) { reverse ( first , second , a ) ; print ( a , b ) ; } else { print ( a , b ) ; } }
int numberOfWays ( int N , int X , int Y ) { int S1 = ( N - 1 ) * X + Y ; int S2 = ( N - 1 ) * Y + X ; return ( S2 - S1 + 1 ) ; }
int countPermutations ( int N ) { List < List < int > > adj = new List < List < int > > ( 105 ) ; for ( int i = 0 ; i < 105 ; i ++ ) adj . Add ( new List < int > ( ) ) ; int indeg = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i == j ) continue ; int sum = i + j ; if ( Math . Ceiling ( Math . Sqrt ( sum ) ) == Math . Floor ( Math . Sqrt ( sum ) ) ) { adj [ i ] . Add ( j ) ; } } if ( adj [ i ] . Count == 1 ) indeg ++ ; } if ( indeg == 0 ) return N ; else if ( indeg <= 2 ) return 2 ; else return 0 ; }
int reduceToOne ( long N ) { int cnt = 0 ; while ( N != 1 ) { if ( N == 2 || ( N % 2 == 1 ) ) { N = N - 1 ; cnt ++ ; } else if ( N % 2 == 0 ) { N = N / ( N / 2 ) ; cnt ++ ; } } return cnt ; }
void getDate ( int d , string m ) { int [ ] days = { 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; string [ ] month = { "January" , "February" , "March" , "April" , "May" , "June" , "July" , "August" , "September" , "October" , "November" , "December" } ; int cnt = 183 ; int cur_month = 0 ; for ( int i = 0 ; i < 12 ; i ++ ) if ( m == month [ i ] ) cur_month = i ; int cur_date = d ; while ( true ) { while ( cnt > 0 && cur_date <= days [ cur_month ] ) { cnt -= 1 ; cur_date += 1 ; } if ( cnt == 0 ) break ; cur_month = ( cur_month + 1 ) % 12 ; cur_date = 1 ; } Console . WriteLine ( cur_date + " " + month [ cur_month ] ) ; }
void maxDiamonds ( int [ ] A , int N , int K ) { var pq = new List < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { pq . Add ( A [ i ] ) ; } int ans = 0 ; while ( pq . Count != 0 && K -- > 0 ) { pq . Sort ( ) ; int top = pq [ pq . Count - 1 ] ; pq . RemoveAt ( pq . Count - 1 ) ; ans += top ; top = top / 2 ; pq . Add ( top ) ; } Console . WriteLine ( ans ) ; }
void findMaximumProfit ( int [ ] arr , int M , int N ) { List < int > max_heap = new List < int > ( ) ; int maxProfit = 0 ; for ( int i = 0 ; i < N ; i ++ ) max_heap . Add ( arr [ i ] ) ; max_heap . Sort ( ) ; max_heap . Reverse ( ) ; while ( M > 0 ) { M -- ; int X = max_heap [ 0 ] ; max_heap . RemoveAt ( 0 ) ; maxProfit += X ; max_heap . Add ( X - 1 ) ; max_heap . Sort ( ) ; max_heap . Reverse ( ) ; } Console . Write ( maxProfit ) ; }
long largestNumber ( int N ) { if ( N > 45 ) return - 1 ; int num = 0 , digit = 9 ; while ( N > 0 && digit > 0 ) { if ( digit <= N ) { num *= 10 ; num += digit ; N -= digit ; } digit -= 1 ; } return num * 10 ; }
int minimumSum ( int [ ] A , int N , String S ) { int mul = 0 ; for ( int i = 0 ; i < ( int ) S . Length ; i ++ ) { if ( S [ i ] == '*' ) mul += 1 ; } int ans = 1000000 ; for ( int i = 0 ; i < ( 1 << ( N - 1 ) ) ; i ++ ) { int cnt = 0 ; List < char > v = new List < char > ( ) ; for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( ( ( 1 << j ) & ( i ) ) > 0 ) { cnt += 1 ; v . Add ( '*' ) ; } else { v . Add ( '+' ) ; } } if ( cnt == mul ) { List < int > d = new List < int > ( ) ; d . Add ( A [ 0 ] ) ; for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( v [ j ] == '*' ) { int x = d [ d . Count - 1 ] ; d . RemoveAt ( d . Count - 1 ) ; x = x * A [ j + 1 ] ; d . Add ( x ) ; } else { d . Add ( A [ j + 1 ] ) ; } } int sum = 0 ; while ( d . Count > 0 ) { int x = d [ 0 ] ; sum += x ; d . RemoveAt ( 0 ) ; } ans = Math . Min ( ans , sum ) ; } } return ans ; }
int MinimumOperations ( int [ ] A , int N , int K ) { int Count = 0 ; int i = 0 ; while ( i < N - 1 ) { i = i + K - 1 ; Count ++ ; } return Count ; }
void findSequence ( int n , int k ) { int [ ] arr = new int [ n ] ; int sumPos = 0 , sumNeg = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { arr [ i ] = - ( i + 1 ) ; sumNeg += arr [ i ] ; } for ( int i = n - k ; i < n ; i ++ ) { arr [ i ] = i + 1 ; sumPos += arr [ i ] ; } if ( Math . Abs ( sumNeg ) >= sumPos ) { Console . Write ( - 1 ) ; return ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void sumOfMedians ( int [ ] arr , int N , int K ) { int selectMedian = ( K + 1 ) / 2 ; int totalArrays = N / K ; int minSum = 0 ; int i = selectMedian - 1 ; while ( i < N && totalArrays != 0 ) { minSum = minSum + arr [ i ] ; i = i + selectMedian ; totalArrays -- ; } Console . WriteLine ( minSum ) ; }
void generateString ( int K ) { string s = "" ; for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + ( char ) ( i ) ; for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += ( char ) ( i ) ; s += ( char ) ( j ) ; } } s += ( char ) ( 97 ) ; Console . Write ( s ) ; }
int countEqual ( int [ ] A , int [ ] B , int N ) { int first = 0 ; int second = N - 1 ; int count = 0 ; while ( first < N && second >= 0 ) { if ( A [ first ] < B [ second ] ) { first ++ ; } else if ( B [ second ] < A [ first ] ) { second -- ; } else { count ++ ; first ++ ; second -- ; } } return count ; }
int minimumValue ( int N , int K ) { return ( int ) Math . Ceiling ( ( double ) K / ( double ) N ) ; }
void minSizeArr ( int [ ] A , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += A [ i ] ; if ( K > sum ) { Console . WriteLine ( - 1 ) ; return ; } if ( K == sum ) { for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( A [ i ] + " " ) ; } return ; } int tar = sum - K ; Dictionary < int , int > um = new Dictionary < int , int > ( ) ; um [ 0 ] = - 1 ; int left = 0 , right = 0 ; int cur = 0 , maxi = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { cur += A [ i ] ; if ( um . ContainsKey ( cur - tar ) && i - um [ cur - tar ] > maxi ) { maxi = i - um [ cur - tar ] ; right = i ; left = um [ cur - tar ] ; } if ( ! um . ContainsKey ( cur ) ) um [ cur ] = i ; } if ( maxi == - 1 ) Console . Write ( - 1 ) ; else { for ( int i = 0 ; i <= left ; i ++ ) Console . Write ( A [ i ] + " " ) ; for ( int i = 0 ; i < right ; i ++ ) Console . Write ( A [ N - i - 1 ] + " " ) ; } }
void findPath ( int [ , ] arr , int M , int N ) { for ( int row = 0 ; row < M ; row ++ ) { char dir = 'L' ; int i = row ; int j = 0 ; while ( j < N ) { if ( arr [ i , j ] == 1 ) { if ( dir == 'L' ) { i -- ; dir = 'D' ; } else if ( dir == 'U' ) { j -- ; dir = 'R' ; } else if ( dir == 'R' ) { i ++ ; dir = 'U' ; } else if ( dir == 'D' ) { j ++ ; dir = 'L' ; } } else { if ( dir == 'L' ) { i ++ ; dir = 'U' ; } else if ( dir == 'U' ) { j ++ ; dir = 'L' ; } else if ( dir == 'R' ) { i -- ; dir = 'D' ; } else if ( dir == 'D' ) { j -- ; dir = 'R' ; } } if ( i < 0 == M j < 0 j == N ) break ; } if ( j == N ) Console . Write ( i + " " ) ; else Console . Write ( - 1 + " " ) ; } }
int getSum ( int n ) { int ans = 0 ; string str = n . ToString ( ) ; Char [ ] arr = str . ToCharArray ( ) ; foreach ( Char ch in arr ) { ans += ( int ) Char . GetNumericValue ( ch ) ; } return ans ; }
void minModulo ( int L , int R , int N ) { if ( R - L < N ) { int ans = Int32 . MaxValue ; for ( int i = L ; i <= R ; i ++ ) for ( int j = L ; j <= R ; j ++ ) if ( i != j ) ans = Math . Min ( ans , ( i * j ) % N ) ; Console . WriteLine ( ans ) ; } else { Console . WriteLine ( 0 ) ; } }
int countNumbers ( int N ) { int count = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { count ++ ; if ( N / i != i ) { count ++ ; } } } return count ; }
void findEquation ( int A , int B , int C , int K ) { Console . Write ( A + " " + K * B + " " + K * K * C ) ; }
int calc ( int a , int b ) { return a * b + ( b - a ) ; }
int findMaximum ( List < int > arr , int N ) { arr . Sort ( ) ; int ans = - 1000000000 ; ans = Math . Max ( ans , calc ( arr [ 0 ] , arr [ 1 ] ) ) ; ans = Math . Max ( ans , calc ( arr [ N - 2 ] , arr [ N - 1 ] ) ) ; return ans ; }
int findMin ( int [ ] arr , int N , int k ) { int pairs = 0 ; for ( int i = 0 ; i < N ; i ++ ) { pairs += arr [ i ] / 2 ; } if ( k > pairs ) return - 1 ; else return 2 * k + N - 1 ; }
int minOperations ( int [ ] arr , int n ) { int oddcount = 0 , evencount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) oddcount ++ ; else evencount ++ ; } return Math . Min ( oddcount , evencount ) ; }
int minimumFlips ( int A , int B , int C ) { int res = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int x = 0 , y = 0 , z = 0 ; if ( ( A & ( 1 << i ) ) != 0 ) { x = 1 ; } if ( ( B & ( 1 << i ) ) != 0 ) { y = 1 ; } if ( ( C & ( 1 << i ) ) != 0 ) { z = 1 ; } if ( z == 0 ) { if ( x == 1 ) { res ++ ; } if ( y == 1 ) { res ++ ; } } if ( z == 1 ) { if ( x == 0 && y == 0 ) { res ++ ; } } } return res ; }
long gcd ( long a , long b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void countDistinctNumbers ( long A , long B , long C ) { long g = gcd ( A , B ) ; long count = C / g ; Console . Write ( count ) ; }
void printLastElement ( int [ ] arr , int N ) { bool leftTurn = true ; int remainElements = N ; int step = 1 ; int head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } Console . Write ( arr [ head - 1 ] ) ; }
void findPrefixCount ( List < int > arr , int size ) { for ( int i = 0 ; i < 32 ; i ++ ) { prefixCount [ i , 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( int j = 1 ; j < size ; j ++ ) { prefixCount [ i , j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefixCount [ i , j ] += prefixCount [ i , j - 1 ] ; } } }
void applyQuery ( int currentVal , int newVal , int size ) { for ( int i = 0 ; i < 32 ; i ++ ) { int bit1 = ( ( currentVal >> i ) & 1 ) ; int bit2 = ( ( newVal >> i ) & 1 ) ; if ( bit2 > 0 && bit1 == 0 ) prefixCount [ i , size - 1 ] ++ ; else if ( bit1 > 0 && bit2 == 0 ) prefixCount [ i , size - 1 ] -- ; } }
void shortestSubarray ( int [ ] A , int N ) { int i ; int left_index ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] + 1 != A [ i + 1 ] ) break ; } left_index = i ; int right_index ; for ( i = N - 1 ; i >= 1 ; i -- ) { if ( A [ i ] != A [ i - 1 ] + 1 ) break ; } right_index = i ; int updated_right ; int minLength = Math . Min ( N - left_index - 1 , right_index ) ; if ( A [ right_index ] <= A [ left_index ] + 1 ) { updated_right = right_index + A [ left_index ] - A [ right_index ] + 1 ; if ( updated_right < N ) minLength = Math . Min ( minLength , updated_right - left_index - 1 ) ; } Console . WriteLine ( minLength ) ; }
string freqCheck ( string S , int N ) { int [ ] hash = new int [ 26 ] ; for ( int i = 0 ; i < N ; i ++ ) { hash [ S [ i ] - 'a' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( hash [ i ] > 2 ) { return "Yes" ; } } return "No" ; }
int countTriplets ( int N , int K ) { if ( K % 2 == 0 ) { int x = N / K ; int y = ( N + ( K / 2 ) ) / K ; return x * x * x + y * y * y ; } else { int x = N / K ; return x * x * x ; } }
int minLength ( string s ) { int i = 0 , j = s . Length - 1 ; for ( ; i < j && s [ i ] == s [ j ] ; ) { char d = s [ i ] ; while ( i <= j && s [ i ] == d ) i ++ ; while ( i <= j && s [ j ] == d ) j -- ; } return j - i + 1 ; }
long power ( long x , int y ) { long res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
long CountBST ( int H ) { return power ( 2 , H ) ; }
void canBeEmptied ( int A , int B ) { if ( Math . Max ( A , B ) > 2 * Math . Min ( A , B ) ) { Console . WriteLine ( "No" ) ; return ; } if ( ( A + B ) % 3 == 0 ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
int Check ( int [ , ] A , int [ , ] B , int M , int N , int X ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j <= N - X ; j ++ ) { if ( A [ i , j ] != B [ i , j ] ) { int diff = B [ i , j ] - A [ i , j ] ; for ( int k = 0 ; k < X ; k ++ ) { A [ i , j + k ] = A [ i , j + k ] + diff ; } } } } for ( int i = 0 ; i <= M - X ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i , j ] != B [ i , j ] ) { int diff = B [ i , j ] - A [ i , j ] ; for ( int k = 0 ; k < X ; k ++ ) { A [ i + k , j ] = A [ i + k , j ] + diff ; } } } } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i , j ] != B [ i , j ] ) { return 0 ; } } } return 1 ; }
void check ( int X , int Y ) { if ( X > 3 ) { Console . WriteLine ( "Yes" ) ; } else if ( X == 1 && Y == 1 ) { Console . WriteLine ( "Yes" ) ; } else if ( X == 2 && Y <= 3 ) { Console . WriteLine ( "Yes" ) ; } else if ( X == 3 && Y <= 3 ) { Console . WriteLine ( "Yes" ) ; } else { Console . WriteLine ( "No" ) ; } }
bool isPrime ( int n ) { if ( n <= 1 ) { return false ; } for ( int i = 2 ; i <= n / 2 ; ++ i ) { if ( n % i == 0 ) return false ; } return true ; }
void precompute ( ) { for ( int i = 1 ; i <= 100000 ; i ++ ) { if ( isPalindrome ( i ) ) { int sum = sumOfDigits ( i ) ; if ( isPrime ( sum ) ) arr [ i ] = 1 ; else arr [ i ] = 0 ; } else arr [ i ] = 0 ; } for ( int i = 1 ; i <= 100000 ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; } }
void minimumOperations ( List < int > A , int K ) { List < int > isflipped = new List < int > ( ) ; for ( int i = 0 ; i < A . Count + 1 ; i ++ ) isflipped . Add ( 0 ) ; int ans = 0 ; for ( int i = 0 ; i < A . Count ; i ++ ) { if ( i > 0 ) { isflipped [ i ] += isflipped [ i - 1 ] ; isflipped [ i ] %= 2 ; } if ( A [ i ] == 0 && isflipped [ i ] == 0 ) { if ( ( A . Count - i + 1 ) <= K ) { Console . Write ( - 1 ) ; return ; } ans += 1 ; isflipped [ i ] += 1 ; isflipped [ i + K ] -= 1 ; } else if ( A [ i ] == 1 && isflipped [ i ] != 0 ) { if ( ( A . Count - i + 1 ) <= K ) { Console . Write ( - 1 ) ; return ; } ans += 1 ; isflipped [ i ] += 1 ; isflipped [ i + K ] -= 1 ; } } Console . WriteLine ( ans ) ; }
void findScoreSum ( int n ) { int total = 0 ; int prev_monday = 0 , curr_day = 0 ; for ( int day = 1 ; day <= n ; day ++ ) { if ( day % 7 == 1 ) { prev_monday ++ ; curr_day = prev_monday ; } total += curr_day ++ ; } Console . Write ( total ) ; }
void findScoreSum ( int n ) { int F = n / 7 ; int D = n % 7 ; int fullWeekScore = ( 49 + 7 * F ) * F / 2 ; int lastNonFullWeekScore = ( 2 * F + D + 1 ) * D / 2 ; Console . WriteLine ( fullWeekScore + lastNonFullWeekScore ) ; }
void evenXorSubarray ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int XOR = 0 ; for ( int j = i ; j < n ; j ++ ) { XOR = XOR ^ arr [ j ] ; if ( ( XOR & 1 ) == 0 ) ans ++ ; } } Console . WriteLine ( ans ) ; }
void evenXorSubarray ( int [ ] arr , int n ) { int ans = 0 ; int [ ] freq = { 0 , 0 } ; int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { XOR = XOR ^ arr [ i ] ; if ( XOR % 2 == 0 ) { ans += freq [ 0 ] + 1 ; freq [ 0 ] ++ ; } else { ans += freq [ 1 ] ; freq [ 1 ] ++ ; } } Console . WriteLine ( ans ) ; }
int getArea ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return Math . Abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2 ) ; }
int isInside ( List < List < int > > triangle , List < int > point ) { List < int > A = triangle [ 0 ] ; List < int > B = triangle [ 1 ] ; List < int > C = triangle [ 2 ] ; int x = point [ 0 ] ; int y = point [ 1 ] ; int ABC = getArea ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] , C [ 0 ] , C [ 1 ] ) ; int BPC = getArea ( x , y , B [ 0 ] , B [ 1 ] , C [ 0 ] , C [ 1 ] ) ; int APC = getArea ( A [ 0 ] , A [ 1 ] , x , y , C [ 0 ] , C [ 1 ] ) ; int APB = getArea ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] , x , y ) ; return ABC == ( APC + APB + BPC ) ? 1 : 0 ; }
int GCD ( int a , int b ) { if ( b < 1 ) return a ; return GCD ( b , a % b ) ; }
int GCDArr ( List < int > a ) { int ans = a [ 0 ] ; foreach ( int i in a ) ans = GCD ( ans , i ) ; return ans ; }
bool findSubseqUtil ( List < int > a , List < int > b , List < int > ans , int k , int i ) { if ( ans . Count == a . Count ) { if ( GCDArr ( ans ) == k ) { Console . Write ( "[" ) ; int m = ans . Count ; for ( int j = 0 ; j < m - 1 ; j ++ ) Console . Write ( ans [ j ] + ", " ) ; Console . Write ( ans [ m - 1 ] + "]" ) ; return true ; } else return false ; } ans . Add ( a [ i ] ) ; bool temp = findSubseqUtil ( a , b , ans , k , i + 1 ) ; if ( temp ) return true ; ans . RemoveAt ( ans . Count - 1 ) ; ans . Add ( b [ i ] ) ; temp = findSubseqUtil ( a , b , ans , k , i + 1 ) ; if ( temp ) return true ; ans . RemoveAt ( ans . Count - 1 ) ; return false ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
int GCDArr ( List < int > a ) { int ans = a [ 0 ] ; foreach ( int val in a ) { ans = GCD ( ans , val ) ; } return ans ; }
void findString ( char [ ] S , int N ) { int strLen = 4 * N ; for ( int i = 1 ; i <= N ; i ++ ) { S [ strLen - 1 ] = '1' ; strLen -= 2 ; } Console . WriteLine ( S ) ; }
void minimumOperations ( int [ ] A , int n ) { int cnt = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( A [ i ] != ( i + 1 ) ) { if ( ( ( i - 1 ) >= 0 ) && A [ i - 1 ] == ( i + 1 ) ) { cnt ++ ; int t = A [ i ] ; A [ i ] = A [ i - 1 ] ; A [ i - 1 ] = t ; } else if ( ( ( i - 2 ) >= 0 ) && A [ i - 2 ] == ( i + 1 ) ) { cnt += 2 ; A [ i - 2 ] = A [ i - 1 ] ; A [ i - 1 ] = A [ i ] ; A [ i ] = i + 1 ; } else { Console . WriteLine ( - 1 ) ; return ; } } } Console . WriteLine ( cnt ) ; }
void countOccurrences ( int n , int x ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( x % i == 0 ) { if ( x / i <= n ) count ++ ; } } Console . WriteLine ( count ) ; }
int countOccurrences ( int N , int X ) { int count = 0 ; for ( int i = 1 ; i < Math . Sqrt ( X ) ; i ++ ) { if ( X % i == 0 ) { int a = i ; int b = X / i ; if ( a <= N && b <= N ) { if ( a == b ) count += 1 ; else count += 2 ; } } } return count ; }
void countOfPrimefactors ( int [ ] CountDistinct ) { bool [ ] prime = new bool [ MAX + 1 ] ; for ( int i = 0 ; i <= MAX ; i ++ ) { CountDistinct [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) { CountDistinct [ i ] = 1 ; for ( int j = i * 2 ; j <= MAX ; j += i ) { CountDistinct [ j ] ++ ; prime [ j ] = false ; } } } }
int CountEvenPair ( int [ ] A , int [ ] B , int N , int M ) { int [ ] countDistinct = new int [ ( MAX + 1 ) ] ; countOfPrimefactors ( countDistinct ) ; int evenCount = 0 ; int oddCount = 0 ; int evenPairs = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( countDistinct [ B [ i ] ] == 0 ) continue ; if ( ( countDistinct [ B [ i ] ] & 1 ) != 0 ) { oddCount ++ ; } else { evenCount ++ ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( countDistinct [ A [ i ] ] == 0 ) continue ; if ( ( countDistinct [ A [ i ] ] & 1 ) != 0 ) { evenPairs += ( evenCount ) ; } else { evenPairs += evenCount + oddCount ; } } return evenPairs ; }
void maxOccuringCharacter ( string s ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '1' ) { count1 ++ ; } else if ( s [ i ] == '0' ) { count0 ++ ; } } int prev = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '1' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . Length ; i ++ ) { if ( s [ i ] != 'X' ) { if ( s [ i ] == '1' ) { count1 += i - prev - 1 ; prev = i ; } else { bool flag = true ; for ( int j = i + 1 ; j < s . Length ; j ++ ) { if ( s [ j ] == '1' ) { flag = false ; prev = j ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . Length ; } } } } prev = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '0' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . Length ; i ++ ) { if ( s [ i ] != 'X' ) { if ( s [ i ] == '0' ) { count0 += i - prev - 1 ; prev = i ; } else { bool flag = true ; for ( int j = i + 1 ; j < s . Length ; j ++ ) { if ( s [ j ] == '0' ) { prev = j ; flag = false ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . Length ; } } } } if ( s [ 0 ] == 'X' ) { int count = 0 ; int i = 0 ; while ( s [ i ] == 'X' ) { count ++ ; i ++ ; } if ( s [ i ] == '1' ) { count1 += count ; } } if ( s [ s . Length - 1 ] == 'X' ) { int count = 0 ; int i = s . Length - 1 ; while ( s [ i ] == 'X' ) { count ++ ; i -- ; } if ( s [ i ] == '0' ) { count0 += count ; } } if ( count0 == count1 ) { Console . WriteLine ( "X" ) ; } else if ( count0 > count1 ) { Console . WriteLine ( 0 ) ; } else Console . WriteLine ( 1 ) ; }
void minRequiredOperation ( int [ ] arr , int N , int K ) { int TotalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) TotalSum += arr [ i ] ; int maxLen = longestSubarray ( arr , N , TotalSum - K ) ; if ( maxLen == - 1 ) { Console . WriteLine ( - 1 ) ; } else Console . WriteLine ( N - maxLen ) ; }
void minimumDeletions ( string s ) { int n = s . Length ; int ans = n ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int t = s [ i ] - '0' ; if ( t % 2 == 0 ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { int num = ( s [ j ] - '0' ) * 10 + t ; if ( num % 4 == 0 ) { int k1 = i - j - 1 ; int k2 = n - i - 1 ; ans = Math . Min ( ans , k1 + k2 ) ; } } } } if ( ans == n ) { for ( int i = 0 ; i < n ; i ++ ) { int num = s [ i ] - '0' ; if ( num % 4 == 0 ) { ans = n - 1 ; } } } Console . WriteLine ( ans ) ; }
bool isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) return true ; if ( ch == 'A' ch == 'E' ch == 'I' ch == 'O' ch == 'U' ) return true ; return false ; }
void winner ( int [ ] arr , int N ) { if ( N % 2 == 1 ) { Console . Write ( "A" ) ; } else { Console . Write ( "B" ) ; } }
void LCMPairs ( int [ ] arr , int N ) { int total_pairs = ( N * ( N - 1 ) ) / 2 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; } odd = ( odd * ( odd - 1 ) ) / 2 ; Console . Write ( "Even = " + ( total_pairs - odd ) + ", Odd = " + odd ) ; }
void getMaxSum ( int [ , ] A , int M , int N ) { int sum = 0 ; int negative = 0 ; int minVal = Int32 . MaxValue ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { sum += Math . Abs ( A [ i , j ] ) ; if ( A [ i , j ] < 0 ) { negative ++ ; } minVal = Math . Min ( minVal , Math . Abs ( A [ i , j ] ) ) ; } } if ( negative % 2 != 0 ) { sum -= 2 * minVal ; } Console . Write ( sum ) ; }
int printNumber ( int N , int K , int M ) { int sum = K * ( M * ( M + 1 ) / 2 ) ; return sum - N ; }
void countEvenOdd ( int L , int R ) { int range = R - L + 1 ; int even = ( range / 4 ) * 2 ; if ( ( L & 1 ) != 0 && ( range % 4 == 3 ) ) { even ++ ; } else if ( ( L & 1 ) == 0 && ( range % 4 != 0 ) ) { even ++ ; } Console . Write ( "Even = " + even + ", Odd = " + ( range - even ) ) ; }
void findPerfectIndex ( int N , int K ) { int i = 0 ; for ( ; i < K ; i ++ ) { Console . Write ( ( N - K + 1 ) + i + " " ) ; } for ( ; i < N ; i ++ ) { Console . Write ( i - K + 1 + " " ) ; } }
bool isPrime ( int N ) { if ( N <= 1 ) return false ; for ( int i = 2 ; i <= Math . Sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; }
void countPrimeTuples ( int N ) { int count = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( isPrime ( i ) && isPrime ( i - 2 ) ) count ++ ; } Console . WriteLine ( count ) ; }
void countPairs ( int [ ] A , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( A [ i ] A [ j ] ) > ( A [ i ] & A [ j ] ) ) { count ++ ; } } Console . Write ( count ) ; }
void checkArrays ( int [ ] arr1 , int [ ] arr2 , int N ) { int count = 0 ; bool flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { if ( arr1 [ i ] == 0 ) count ++ ; else { count -- ; if ( count < 0 ) { flag = false ; break ; } } } } if ( ( flag && ( count == 0 ) ) == true ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
void construct_Array ( int N , int K ) { for ( int i = 1 ; i <= N ; i ++ ) { Console . Write ( K * i + " " ) ; } }
void maxSumOfDistinctPrimeFactors ( int [ ] arr , int N , int K ) { int [ ] CountDistinct = new int [ MAX + 1 ] ; bool [ ] prime = new bool [ MAX + 1 ] ; for ( int i = 0 ; i <= MAX ; i ++ ) { CountDistinct [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) { CountDistinct [ i ] = 1 ; for ( int j = i * 2 ; j <= MAX ; j += i ) { CountDistinct [ j ] ++ ; prime [ j ] = false ; } } } int sum = 0 ; int [ ] PrimeFactor = new int [ 20 ] ; for ( int i = 0 ; i < N ; i ++ ) { PrimeFactor [ CountDistinct [ arr [ i ] ] ] ++ ; } for ( int i = 19 ; i >= 1 ; i -- ) { while ( PrimeFactor [ i ] > 0 ) { sum += i ; PrimeFactor [ i ] -- ; K -- ; if ( K == 0 ) break ; } if ( K == 0 ) break ; } Console . Write ( sum ) ; }
void Print ( int N ) { if ( ( N / 2 ) % 2 == 1 || ( N % 2 == 1 ) ) { Console . WriteLine ( - 1 ) ; return ; } int CurEven = 2 , CurOdd = 1 ; int SumOdd = 0 , SumEven = 0 ; for ( int i = 0 ; i < ( N / 2 ) ; i ++ ) { Console . Write ( CurEven + " " ) ; SumEven += CurEven ; CurEven += 2 ; } for ( int i = 0 ; i < N / 2 - 1 ; i ++ ) { Console . Write ( CurOdd + " " ) ; SumOdd += CurOdd ; CurOdd += 2 ; } CurOdd = SumEven - SumOdd ; Console . WriteLine ( CurOdd ) ; }
int minimize ( int n ) { int optEle = n ; string strEle = n . ToString ( ) ; for ( int idx = 0 ; idx < strEle . Length ; idx ++ ) { int temp = Int32 . Parse ( strEle . Substring ( idx ) + strEle . Substring ( 0 , idx ) ) ; optEle = Math . Min ( optEle , temp ) ; } return optEle ; }
int maximize ( int n ) { int optEle = n ; string strEle = n . ToString ( ) ; for ( int idx = 0 ; idx < strEle . Length ; idx ++ ) { int temp = Int32 . Parse ( strEle . Substring ( idx ) + strEle . Substring ( 0 , idx ) ) ; optEle = Math . Max ( optEle , temp ) ; } return optEle ; }
void minOperations ( int [ ] arr , int N ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int res = arr [ i ] ; while ( res > 0 ) { if ( mp . ContainsKey ( res ) ) { mp [ res ] ++ ; } else { mp [ res ] = 1 ; } res /= 2 ; } } int mx = 1 ; foreach ( KeyValuePair < int , int > it in mp ) { if ( it . Value == N ) { mx = it . Key ; } } int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int res = arr [ i ] ; while ( res != mx ) { ans ++ ; res /= 2 ; } } Console . Write ( ans ) ; }
int MinimumMoves ( int [ ] A , int [ ] B , int N ) { int totalOperations = 0 ; int carry = 0 ; int K = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int nearestMultiple = ( int ) ( Math . Ceiling ( ( double ) ( A [ i ] + carry ) / ( double ) ( B [ i ] ) ) * B [ i ] ) ; K = nearestMultiple - ( A [ i ] + carry ) ; totalOperations += K ; carry += K ; } return totalOperations ; }
int maxSheets ( int A , int B ) { int area = A * B ; int count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; }
void minimumDeviation ( int [ ] A , int N ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) s . Add ( A [ i ] ) ; else s . Add ( 2 * A [ i ] ) ; } List < int > S = s . ToList ( ) ; S . Sort ( ) ; int diff = S [ S . Count - 1 ] - S [ 0 ] ; while ( ( int ) S . Count != 0 && S [ S . Count - 1 ] % 2 == 0 ) { int maxEl = S [ S . Count - 1 ] ; S . RemoveAt ( S . Count - 1 ) ; S . Add ( maxEl / 2 ) ; S . Sort ( ) ; diff = Math . Min ( diff , S [ S . Count - 1 ] - S [ 0 ] ) ; } Console . Write ( diff ) ; }
int findMaxNum ( int num ) { string binaryNumber = Convert . ToString ( num , 2 ) ; string maxBinaryNumber = "" ; int count0 = 0 , count1 = 0 ; int N = binaryNumber . Length ; for ( int i = 0 ; i < N ; i ++ ) { if ( binaryNumber [ i ] == '1' ) { count1 ++ ; } else { count0 ++ ; } } for ( int i = 0 ; i < count1 ; i ++ ) { maxBinaryNumber += '1' ; } for ( int i = 0 ; i < count0 ; i ++ ) { maxBinaryNumber += '0' ; } return Convert . ToInt32 ( maxBinaryNumber , 2 ) ; }
void findMinMoves ( int a , int b ) { int ans = 0 ; if ( a == b || Math . Abs ( a - b ) == 1 ) { ans = a + b ; } else { int k = Math . Min ( a , b ) ; int j = Math . Max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } Console . Write ( ans ) ; }
void FindwinnerOfGame ( string S ) { int cntZero = 0 ; int cntConOne = 0 ; int nimSum = 0 ; int N = S . Length ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) { cntConOne += 1 ; } else { nimSum ^= cntConOne ; cntConOne = 0 ; cntZero ++ ; } } nimSum ^= cntConOne ; if ( cntZero % 2 == 0 ) { Console . Write ( "Tie" ) ; } else if ( nimSum != 0 ) { Console . Write ( "player 1" ) ; } else { Console . Write ( "player 2" ) ; } }
string check ( int current_row , int current_col , int destination_row , int destination_col ) { if ( current_row == destination_row ) return "POSSIBLE" ; else if ( current_col == destination_col ) return "POSSIBLE" ; else return "NOT POSSIBLE" ; }
int maxChange ( char [ ] str ) { if ( str . Length <= 1 ) { return 0 ; } int minChanges = 0 ; for ( int i = 0 ; i < str . Length - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { str [ i + 1 ] = 'N' ; minChanges += 1 ; } else if ( i > 0 && str [ i - 1 ] == str [ i + 1 ] ) { str [ i + 1 ] = 'N' ; minChanges += 1 ; } } return minChanges ; }
void generatepermutation ( int N ) { int [ ] answer = new int [ N ] ; answer [ 0 ] = N ; for ( int i = 1 ; i < N ; i ++ ) { answer [ i ] = i ; } foreach ( int i in answer ) Console . Write ( i + " " ) ; }
int maxNumPalindrome ( string S ) { int i = 0 ; int [ ] freq = new int [ 26 ] ; int freqPair = 0 ; int len = S . Length / 3 ; while ( i < S . Length ) { freq [ S [ i ] - 'a' ] ++ ; i ++ ; } for ( i = 0 ; i < 26 ; i ++ ) { freqPair += ( freq [ i ] / 2 ) ; } return Math . Min ( freqPair , len ) ; }
long cntEvenSumPairs ( long X , long Y ) { long cntXEvenNums = X / 2 ; long cntXOddNums = ( X + 1 ) / 2 ; long cntYEvenNums = Y / 2 ; long cntYOddNums = ( Y + 1 ) / 2 ; long cntPairs = ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ; return cntPairs ; }
void farthestCellDistance ( int N , int M , int R , int C ) { int d1 = N + M - R - C ; int d2 = R + C - 2 ; int d3 = N - R + C - 1 ; int d4 = M - C + R - 1 ; int maxDistance = Math . Max ( d1 , Math . Max ( d2 , Math . Max ( d3 , d4 ) ) ) ; Console . WriteLine ( maxDistance ) ; }
void maxSum ( int [ ] arr , int N ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { int t = i ; if ( t + arr [ i ] < N ) { arr [ i ] += arr [ t + arr [ i ] ] ; } } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
void constructArray ( int [ ] arr , int N ) { int [ ] brr = new int [ N ] ; Array . Clear ( brr , 0 , brr . Length ) ; for ( int i = 0 ; i < N ; i ++ ) { int K = ( int ) ( Math . Log ( arr [ i ] ) / Math . Log ( 2 ) ) ; int R = ( int ) Math . Pow ( 2 , K ) ; brr [ i ] = R ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( brr [ i ] + " " ) ; } }
void findMinKToMakeAllEqual ( int N , int [ ] A ) { var B = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { B . Add ( A [ i ] ) ; } List < int > b = new List < int > ( B ) ; int M = b . Count ; int j = 0 ; if ( M > 3 ) { Console . Write ( "-1" ) ; } else if ( M == 3 ) { int B_1 = b [ j ++ ] ; int B_2 = b [ j ++ ] ; int B_3 = b [ j ++ ] ; if ( B_2 - B_1 == B_3 - B_2 ) { Console . Write ( B_2 - B_1 ) ; } else { Console . Write ( "-1" ) ; } } else if ( M == 2 ) { int B_1 = b [ j ++ ] ; int B_2 = b [ j ++ ] ; if ( ( B_2 - B_1 ) % 2 == 0 ) { Console . Write ( ( B_2 - B_1 ) / 2 ) ; } else { Console . Write ( B_2 - B_1 ) ; } } else { Console . Write ( 0 ) ; } }
void minOpsToTurnArrToZero ( int [ ] arr , int N ) { HashSet < int > st = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( st . Contains ( arr [ i ] ) arr [ i ] == 0 ) { continue ; } else { st . Add ( arr [ i ] ) ; } } Console . WriteLine ( st . Count ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void splitArray ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . ContainsKey ( arr [ i ] ) == true ) mp [ arr [ i ] ] += 1 ; else mp [ arr [ i ] ] = 1 ; } int G = 0 ; foreach ( KeyValuePair < int , int > i in mp ) { G = gcd ( G , i . Value ) ; } if ( G > 1 ) Console . Write ( "YES" ) ; else Console . Write ( "NO" ) ; }
int minMoves ( List < int > arr ) { int N = arr . Count ; if ( N <= 2 ) return 0 ; int ans = Int32 . MaxValue ; for ( int i = - 1 ; i <= 1 ; i ++ ) { for ( int j = - 1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = Math . Abs ( i ) + Math . Abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( Math . Abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . Abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag != 0 ) ans = Math . Min ( ans , moves ) ; } } if ( ans == Int32 . MaxValue ) return - 1 ; return ans ; }
void querySum ( int [ ] arr , int N , int [ , ] Q , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i , 0 ] ; int y = Q [ i , 1 ] ; int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } Console . Write ( sum + " " ) ; } }
bool CheckAllEqual ( int [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return false ; } } return true ; }
int minCntOperations ( int [ ] arr , int N ) { int Max = arr . Max ( ) ; bool isPower2 ; if ( ( int ) ( Math . Ceiling ( ( Math . Log ( N ) / Math . Log ( N ) ) ) ) == ( int ) ( Math . Floor ( ( ( Math . Log ( N ) / Math . Log ( 2 ) ) ) ) ) ) { isPower2 = true ; } else { isPower2 = false ; } if ( isPower2 && CheckAllEqual ( arr , N ) ) { return ( int ) ( Math . Log ( Max ) / Math . Log ( 2 ) ) ; } else { return ( int ) Math . Ceiling ( Math . Log ( Max ) / Math . Log ( 2 ) ) + 1 ; } }
string greatestReducedNumber ( string num , string s ) { bool [ ] vis_s = new bool [ 10 ] ; for ( int i = 0 ; i < ( int ) s . Length ; i ++ ) { vis_s [ ( int ) ( s [ i ] ) - 48 ] = true ; } int n = num . Length ; int In = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis_s [ ( int ) num [ i ] - '0' ] ) { In = i ; break ; } } if ( In == - 1 ) { return num ; } for ( char dig = num [ In ] ; dig >= '0' ; dig -- ) { if ( vis_s [ ( int ) dig - '0' ] == false ) { num = num . Substring ( 0 , In ) + dig + num . Substring ( In + 1 , n - In - 1 ) ; break ; } } char LargestDig = '0' ; for ( char dig = '9' ; dig >= '0' ; dig -- ) { if ( vis_s [ dig - '0' ] == false ) { LargestDig = dig ; break ; } } for ( int i = In + 1 ; i < n ; i ++ ) { num = num . Substring ( 0 , i ) + LargestDig ; } int Count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( num [ i ] == '0' ) Count ++ ; else break ; } num = num . Substring ( Count , n ) ; if ( ( int ) num . Length == 0 ) return "0" ; return num ; }
void minXOR ( int [ ] Arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( Arr [ i ] == 2 ) { Console . Write ( ( Arr [ i ] ^ 3 ) + " " ) ; } else { Console . Write ( ( Arr [ i ] ^ 2 ) + " " ) ; } } }
int [ ] findArray ( int n ) { int [ ] Arr = new int [ n + 1 ] ; Arr [ 0 ] = 0 ; Arr [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { Arr [ i ] = Arr [ i / 2 ] ; } else { Arr [ i ] = Arr [ ( i - 1 ) / 2 ] + Arr [ ( i - 1 ) / 2 + 1 ] ; } } return Arr ; }
int maxElement ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; int [ ] Arr = findArray ( n ) ; int ans = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . Max ( ans , Arr [ i ] ) ; } return ans ; }
int findMaxValByRearrArr ( int [ ] arr , int N ) { int res = 0 ; res = ( N * ( N + 1 ) ) / 2 ; return res ; }
int min_steps_required ( int n , int m , int r , int c ) { int i , j ; int corner_steps_req = int . MaxValue ; i = 1 ; j = 1 ; corner_steps_req = Math . Min ( corner_steps_req , Math . Abs ( r - i ) + Math . Abs ( j - c ) ) ; i = n ; j = 1 ; corner_steps_req = Math . Min ( corner_steps_req , Math . Abs ( r - i ) + Math . Abs ( j - c ) ) ; i = 1 ; j = m ; corner_steps_req = Math . Min ( corner_steps_req , Math . Abs ( r - i ) + Math . Abs ( j - c ) ) ; i = n ; j = m ; corner_steps_req = Math . Min ( corner_steps_req , Math . Abs ( r - i ) + Math . Abs ( j - c ) ) ; int minimum_steps = Math . Min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) ; return minimum_steps + corner_steps_req ; }
int min_elements ( int [ ] arr , int N , int K ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } List < int > Freq = new List < int > ( ) ; foreach ( KeyValuePair < int , int > it in mp ) { int i = it . Key ; Freq . Add ( mp [ i ] ) ; } Freq . Sort ( ) ; Freq . Reverse ( ) ; int len = Freq . Count ; if ( len <= K ) { return 0 ; } int cntMin = 0 ; for ( int i = K ; i < len ; i ++ ) { cntMin += Freq [ i ] ; } return cntMin ; }
int sumzero ( int [ ] arr , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 0 ) Console . Write ( "Yes" ) ; else if ( sum > 0 ) { if ( sum % K == 0 ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; } else Console . Write ( "No" ) ; return 0 ; }
int cntOnesArrWithGivenOp ( int [ ] arr , int N ) { int cntOnes = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i - 1 ; j < N ; j += i ) { arr [ j ] = arr [ j ] == 0 ? 1 : 0 ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) { cntOnes += 1 ; } } return cntOnes ; }
int cntOnesArrWithGivenOp ( int [ ] arr , int N ) { int cntOnes = 0 ; cntOnes = ( int ) Math . Sqrt ( N ) ; return cntOnes ; }
void minimumMoves ( int [ ] arr , int N ) { int sum = 0 ; int maxelement = - 1 ; if ( N == 2 ) { Console . Write ( "0" ) ; return ; } for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; maxelement = Math . Max ( maxelement , arr [ i ] ) ; } int k = ( sum + N - 2 ) / ( N - 1 ) ; k = Math . Max ( maxelement , k ) ; int ans = k * ( N - 1 ) - sum ; Console . WriteLine ( ans ) ; }
void minimumSwaps ( int [ ] arr1 , int [ ] arr2 , int n ) { int sumArr1 = 0 , sumArr2 = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sumArr1 += arr1 [ i ] ; sumArr2 += arr2 [ i ] ; } if ( sumArr1 % 2 == 0 && sumArr2 % 2 == 0 ) { Console . Write ( 0 ) ; return ; } if ( sumArr1 % 2 != 0 && sumArr2 % 2 != 0 ) { int flag = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( arr1 [ i ] + arr2 [ i ] ) % 2 == 1 ) { flag = 1 ; break ; } } Console . Write ( flag ) ; return ; } Console . Write ( - 1 ) ; }
void corpFlightBookings ( int [ , ] Bookings , int N ) { int [ ] res = new int [ N ] ; for ( int i = 0 ; i < Bookings . GetLength ( 0 ) ; i ++ ) { int l = Bookings [ i , 0 ] ; int r = Bookings [ i , 1 ] ; int K = Bookings [ i , 2 ] ; res [ l - 1 ] = res [ l - 1 ] + K ; if ( r <= res . Length - 1 ) res [ r ] = ( - K ) + res [ r ] ; } for ( int i = 1 ; i < res . Length ; i ++ ) res [ i ] = res [ i ] + res [ i - 1 ] ; for ( int i = 0 ; i < res . Length ; i ++ ) { Console . Write ( res [ i ] + " " ) ; } }
void findOddXOR ( int n ) { if ( n % 2 == 0 ) Console . Write ( ( ( findXOR ( n ) ) ^ ( 2 * findXOR ( n / 2 ) ) ) ) ; else Console . Write ( ( ( findXOR ( n ) ) ^ ( 2 * findXOR ( ( n - 1 ) / 2 ) ) ) ) ; }
void findSmallestNumber ( int n ) { for ( int i = n ; i <= ( n + 2520 ) ; ++ i ) { int possible = 1 ; int temp = i ; while ( temp != 0 ) { if ( temp % 10 != 0 ) { int digit = temp % 10 ; if ( i % digit != 0 ) { possible = 0 ; break ; } } temp /= 10 ; } if ( possible == 1 ) { Console . Write ( i ) ; return ; } } }
void path_to_root ( int node ) { while ( node >= 1 ) { Console . Write ( node + " " ) ; node /= 2 ; } }
int minValue ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int minimum = arr [ 0 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] - minimum ) ; } return sum ; }
void computeLPSArray ( String pat , int M , int [ ] lps ) { int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } }
char lastRemovedCharacter ( char [ ] str ) { int n = str . Length ; if ( n == 1 ) return str [ 0 ] ; if ( str [ n - 2 ] == '0' ) { return ( char ) ( '1' - str [ n - 1 ] + '0' ) ; } else return str [ n - 1 ] ; }
void findNumbers ( int aXORb , int aANDb , int aXORc , int aANDc , int bXORc , int bANDc ) { int a , b , c ; int aSUMb ; int aSUMc ; int bSUMc ; aSUMb = aXORb + aANDb * 2 ; aSUMc = aXORc + aANDc * 2 ; bSUMc = bXORc + bANDc * 2 ; a = ( aSUMb - bSUMc + aSUMc ) / 2 ; b = aSUMb - a ; c = aSUMc - a ; System . Console . Write ( "a = " + a ) ; System . Console . Write ( ", b = " + b ) ; System . Console . Write ( ", c = " + c ) ; }
void findArray ( int N , int K ) { if ( N == 1 ) { Console . Write ( K + " " ) ; return ; } if ( N == 2 ) { Console . Write ( 0 + " " + K ) ; return ; } int P = N - 2 ; int Q = N - 1 ; int VAL = 0 ; for ( int i = 1 ; i <= ( N - 3 ) ; i ++ ) { Console . Write ( i + " " ) ; VAL ^= i ; } if ( VAL == K ) { Console . Write ( P + " " + Q + " " + ( P ^ Q ) ) ; } else { Console . Write ( 0 + " " + P + " " + ( P ^ K ^ VAL ) ) ; } }
int findNumber ( int N ) { int count = 0 ; while ( ( N & 1 ) == 1 ) { N = N >> 1 ; count ++ ; } return N << count ; }
int findNumber ( int N ) { return N & ( N + 1 ) ; }
void array_divisbleby_k ( int N , int K ) { bool flag = false ; int d1 = 0 , d2 = 0 ; for ( int i = 2 ; i * i <= K ; i ++ ) { if ( K % i == 0 ) { flag = true ; d1 = i ; d2 = K / i ; break ; } } if ( flag ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 1 ) { Console . Write ( d2 + " " ) ; } else { Console . Write ( d1 + " " ) ; } } } else { Console . Write ( - 1 ) ; } }
int min_elements ( int [ ] arr , int N ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] ++ ; } else { mp [ arr [ i ] ] = 1 ; } } int cntMinRem = 0 ; foreach ( KeyValuePair < int , int > it in mp ) { int i = it . Key ; if ( mp [ i ] < i ) { cntMinRem += mp [ i ] ; } else if ( mp [ i ] > i ) { cntMinRem += ( mp [ i ] - i ) ; } } return cntMinRem ; }
bool CheckAllarrayEqual ( int [ ] arr , int N ) { if ( N == 1 ) { return true ; } int totalSum = arr [ 0 ] ; int secMax = Int32 . MinValue ; int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= Max ) { secMax = Max ; Max = arr [ i ] ; } else if ( arr [ i ] > secMax ) { secMax = arr [ i ] ; } totalSum += arr [ i ] ; } if ( ( secMax * ( N - 1 ) ) > totalSum ) { return false ; } if ( totalSum % ( N - 1 ) != 0 ) { return false ; } return true ; }
int getSum ( int [ ] ar ) { int sum = 0 ; foreach ( int i in ar ) { sum += i ; } return sum ; }
int getMinSum ( int pos , int [ ] arr , List < int > primePow ) { if ( pos == primePow . Count ) { return getSum ( arr ) ; } int res = int . MaxValue ; for ( int i = 0 ; i < arr . Length ; i ++ ) { arr [ i ] *= primePow [ pos ] ; res = Math . Min ( res , getMinSum ( pos + 1 , arr , primePow ) ) ; arr [ i ] /= primePow [ pos ] ; } return res ; }
int minimumSumWithGivenLCM ( int k , int x ) { List < int > primePow = primePower ( x ) ; int n = primePow . Count ; int sum = 0 ; if ( n <= k ) { foreach ( int i in primePow ) { sum += i ; } sum += k - n ; } else { int [ ] arr = new int [ k ] ; for ( int l = 0 ; l < arr . Length ; l ++ ) arr [ l ] = 1 ; sum = getMinSum ( 0 , arr , primePow ) ; } return sum ; }
int IsPresent ( string str , string target ) { if ( str . Contains ( target ) ) { return 1 ; } return - 1 ; }
int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; }
void minOperation ( int [ ] X , int [ ] Y , int n ) { int C = 0 ; int count = 0 ; for ( int i = 1 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; count = 0 ; for ( int i = 0 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; Console . Write ( C ) ; }
int minimumcntOperationReq ( int [ ] arr , int N ) { int cntOp = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cntOp ++ ; } } return ( cntOp + 1 ) / 2 ; }
void ConstArrayAdjacentCoprime ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { Console . Write ( i + " " ) ; } }
int cntIndexesToMakeBalance ( int [ ] arr , int n ) { if ( n == 1 ) { return 1 ; } if ( n == 2 ) return 0 ; int sumEven = 0 ; int sumOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { sumEven += arr [ i ] ; } else { sumOdd += arr [ i ] ; } } int currOdd = 0 ; int currEven = arr [ 0 ] ; int res = 0 ; int newEvenSum = 0 ; int newOddSum = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( i % 2 != 0 ) { currOdd += arr [ i ] ; newEvenSum = currEven + sumOdd - currOdd ; newOddSum = currOdd + sumEven - currEven - arr [ i ] ; } else { currEven += arr [ i ] ; newOddSum = currOdd + sumEven - currEven ; newEvenSum = currEven + sumOdd - currOdd - arr [ i ] ; } if ( newEvenSum == newOddSum ) { res ++ ; } } if ( sumOdd == sumEven - arr [ 0 ] ) { res ++ ; } if ( n % 2 == 1 ) { if ( sumOdd == sumEven - arr [ n - 1 ] ) { res ++ ; } } else { if ( sumEven == sumOdd - arr [ n - 1 ] ) { res ++ ; } } return res ; }
int findMinOperationsReqEmpStr ( String str ) { int cntOne = 0 ; int cntZero = 0 ; int N = str . Length ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == '0' ) { if ( cntOne != 0 ) { cntOne -- ; } cntZero ++ ; } else { if ( cntZero != 0 ) { cntZero -- ; } cntOne ++ ; } } return ( cntOne + cntZero ) ; }
void minimumOperations ( String S , int m ) { int V = 100 ; List < int > [ ] adj = new List < int > [ V ] ; int total = 0 , N = S . Length ; for ( int i = 0 ; i < adj . Length ; i ++ ) adj [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { addEdge ( adj , i , N - i - 1 ) ; addEdge ( adj , N - i - 1 , i ) ; } for ( int i = 0 ; i < N - m ; i ++ ) { addEdge ( adj , i , i + m ) ; addEdge ( adj , i + m , i ) ; } visited = new bool [ V ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! visited [ i ] ) { int [ ] fre = new int [ 26 ] ; cnt = 0 ; int maxx = - 1 ; DFS ( i , adj , fre , S ) ; for ( int j = 0 ; j < 26 ; j ++ ) maxx = Math . Max ( maxx , fre [ j ] ) ; total += cnt - maxx ; } } Console . Write ( total ) ; }
int countChanges ( char [ , ] mat ) { int n = mat . GetLength ( 0 ) ; int m = mat . GetLength ( 1 ) ; int ans = 0 ; for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( mat [ n - 1 , j ] != 'R' ) ans ++ ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( mat [ i , m - 1 ] != 'D' ) ans ++ ; } return ans ; }
int findMaxSumByAlternatingSign ( int [ ] arr , int N ) { int cntNeg = 0 ; int MaxAltSum = 0 ; int SmValue = 0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { cntNeg += 1 ; } sum += Math . Abs ( arr [ i ] ) ; SmValue = Math . Min ( SmValue , Math . Abs ( arr [ i ] ) ) ; } MaxAltSum = sum ; if ( cntNeg % 2 == 1 ) { MaxAltSum -= 2 * SmValue ; } return MaxAltSum ; }
int minCntCharDeletionsfrequency ( char [ ] str , int N ) { Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; List < int > pq = new List < int > ( ) ; int cntChar = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( str [ i ] ) ) { mp [ str [ i ] ] ++ ; } else { mp . Add ( str [ i ] , 1 ) ; } } foreach ( KeyValuePair < char , int > it in mp ) { pq . Add ( it . Value ) ; } pq . Sort ( ) ; pq . Reverse ( ) ; while ( pq . Count != 0 ) { pq . Sort ( ) ; pq . Reverse ( ) ; int frequent = pq [ 0 ] ; pq . RemoveAt ( 0 ) ; if ( pq . Count == 0 ) { return cntChar ; } if ( frequent == pq [ 0 ] ) { if ( frequent > 1 ) { pq . Add ( frequent - 1 ) ; pq . Sort ( ) ; pq . Reverse ( ) ; } cntChar ++ ; } } return cntChar ; }
void constructNewArraySumZero ( int [ ] arr , int N ) { int [ ] newArr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { newArr [ i ] = arr [ i + 1 ] ; } else { newArr [ i ] = - arr [ i - 1 ] ; } } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( newArr [ i ] + " " ) ; } }
int minimumCntOfFlipsRequired ( string str ) { int n = str . Length ; int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) { zeros ++ ; } } if ( zeros == 0 zeros == n ) { return 0 ; } int minFlips = Int32 . MaxValue ; int currOnes = 0 ; int flips ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { currOnes ++ ; } flips = currOnes + ( zeros - ( i + 1 - currOnes ) ) ; minFlips = Math . Min ( minFlips , flips ) ; } return minFlips ; }
void constructMEX ( int [ ] arr , int N ) { int [ ] hash = new int [ MAXN ] ; for ( int i = 0 ; i < N ; i ++ ) { hash [ i ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { hash [ arr [ i ] ] = 1 ; } int MexOfArr = 0 ; for ( int i = 1 ; i < MAXN ; i ++ ) { if ( hash [ i ] == 0 ) { MexOfArr = i ; break ; } } int [ ] B = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < MexOfArr ) B [ i ] = arr [ i ] ; else B [ i ] = MexOfArr ; } for ( int i = 0 ; i < N ; i ++ ) Console . Write ( B [ i ] + " " ) ; }
void smallestNumberLeftInPQ ( int [ ] arr , int N ) { List < int > pq = new List < int > ( ) ; List < pair > pairsArr = new List < pair > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { pq . Add ( arr [ i ] ) ; } pq . Sort ( ) ; pq . Reverse ( ) ; while ( pq . Count > 1 ) { int X = pq [ 0 ] ; pq . RemoveAt ( 0 ) ; int Y = pq [ 0 ] ; pq . RemoveAt ( 0 ) ; pq . Add ( ( X + Y + 1 ) / 2 ) ; pq . Sort ( ) ; pq . Reverse ( ) ; pairsArr . Add ( new pair ( X , Y ) ) ; } Console . Write ( "{" + pq [ 0 ] + "}, " ) ; int sz = pairsArr . Count ; for ( int i = 0 ; i < sz ; i ++ ) { if ( i == 0 ) { Console . Write ( "{ " ) ; } Console . Write ( "(" + pairsArr [ i ] . first + ", " + pairsArr [ i ] . second + ")" ) ; if ( i != sz - 1 ) { Console . Write ( ", " ) ; } if ( i == sz - 1 ) { Console . Write ( " }" ) ; } } }
void findPairs ( int N ) { for ( int i = 0 ; i <= N ; i ++ ) { Console . Write ( "(" + i + ", " + ( N - i ) + "), " ) ; } }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
void canReach ( int N , int A , int B , int K ) { int gcd = GCD ( N , K ) ; if ( Math . Abs ( A - B ) % gcd == 0 ) { Console . WriteLine ( "Yes" ) ; } else { Console . WriteLine ( "No" ) ; } }
int sum ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; }
int smallestNumber ( int n , int s ) { if ( sum ( n ) <= s ) { return n ; } int ans = n , k = 1 ; for ( int i = 0 ; i < 9 ; ++ i ) { int digit = ( ans / k ) % 10 ; int add = k * ( ( 10 - digit ) % 10 ) ; ans += add ; if ( sum ( ans ) <= s ) { break ; } k *= 10 ; } return ans ; }
int separate ( int [ ] arr , int n , int parity ) { int count = 1 , res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( ( arr [ i ] + parity ) & 1 ) != 0 && ( ( arr [ i - 1 ] + parity ) & 1 ) != 0 ) count ++ ; else { if ( count > 1 ) res += count - 1 ; count = 1 ; } } return res ; }
void requiredOps ( int [ ] arr , int N ) { int res1 = separate ( arr , N , 0 ) ; int res2 = separate ( arr , N , 1 ) ; Console . Write ( Math . Max ( res1 , res2 ) ) ; }
bool [ ] SieveOfEratosthenes ( int N ) { bool [ ] isPrime = new bool [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) { isPrime [ i ] = true ; } isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( isPrime [ p ] ) { for ( int i = p * p ; i <= N ; i += p ) { isPrime [ i ] = false ; } } } return isPrime ; }
int cntPairsdiffOfPrimeisPrime ( int N ) { int cntPairs = 0 ; bool [ ] isPrime = SieveOfEratosthenes ( N ) ; for ( int i = 2 ; i <= N ; i ++ ) { if ( isPrime [ i ] && isPrime [ i - 2 ] ) { cntPairs += 2 ; } } return cntPairs ; }
void longestSubsequence ( int [ ] arr , int N ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count ++ ; } } Console . WriteLine ( count ) ; }
int substringCount ( string s ) { int [ ] freq = new int [ 26 ] ; char max_char = '#' ; int maxfreq = Int32 . MinValue ; for ( int i = 0 ; i < s . Length ; i ++ ) { freq [ s [ i ] - 'a' ] ++ ; if ( maxfreq < freq [ s [ i ] - 'a' ] ) maxfreq = freq [ s [ i ] - 'a' ] ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( maxfreq == freq [ i ] ) { max_char = ( char ) ( i + 'a' ) ; break ; } } int ans = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { char ch = s [ i ] ; if ( max_char == ch ) { ans += ( s . Length - i ) ; } } return ans ; }
int findSum ( int [ ] S , int n , int x ) { int [ , ] table = new int [ n + 1 , x + 1 ] ; for ( int i = 1 ; i <= x ; i ++ ) { table [ 0 , i ] = int . MaxValue - 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= x ; j ++ ) { if ( S [ i - 1 ] > j ) { table [ i , j ] = table [ i - 1 , j ] ; } else { table [ i , j ] = Math . Min ( table [ i - 1 , j ] , table [ i , j - S [ i - 1 ] ] + 1 ) ; } } } return ( table [ n , x ] > n ) ? - 1 : table [ n , x ] ; }
void minRemovals ( int [ ] arr , int n , int m , int x ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int requied_Sum = 0 ; if ( sum % m < x ) requied_Sum = m + sum % m - x ; else requied_Sum = sum % m - x ; Console . Write ( findSum ( arr , n , requied_Sum ) ) ; }
void findXandYwithminABSX_Y ( int N ) { if ( N % 2 == 1 ) { Console . Write ( ( N / 2 ) + " " + ( N / 2 + 1 ) ) ; } else { Console . Write ( ( N / 2 - 1 ) + " " + ( N / 2 + 1 ) ) ; } }
string removeDuplicateLetters ( string s ) { int [ ] cnt = new int [ 26 ] ; int [ ] vis = new int [ 26 ] ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) cnt [ s [ i ] - 'a' ] ++ ; String res = "" ; for ( int i = 0 ; i < n ; i ++ ) { cnt [ s [ i ] - 'a' ] -- ; if ( vis [ s [ i ] - 'a' ] == 0 ) { int size = res . Length ; while ( size > 0 && res [ size - 1 ] > s [ i ] && cnt [ res [ size - 1 ] - 'a' ] > 0 ) { vis [ res [ size - 1 ] - 'a' ] = 0 ; res = res . Substring ( 0 , size - 1 ) ; size -- ; } res += s [ i ] ; vis [ s [ i ] - 'a' ] = 1 ; } } return res ; }
int minChange ( String s , int n ) { int [ ] L = new int [ 26 ] ; int [ ] R = new int [ 26 ] ; for ( int i = 0 ; i < n / 2 ; i ++ ) { char ch = s [ i ] ; L [ ch - 'a' ] ++ ; } for ( int i = n / 2 ; i < n ; i ++ ) { char ch = s [ i ] ; R [ ch - 'a' ] ++ ; } int count = n ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { count = Math . Min ( count , n - L [ ch - 'a' ] - R [ ch - 'a' ] ) ; } int change = n / 2 ; for ( int d = 0 ; d + 1 < 26 ; d ++ ) { change -= L [ d ] ; change += R [ d ] ; count = Math . Min ( count , change ) ; } change = n / 2 ; for ( int d = 0 ; d + 1 < 26 ; d ++ ) { change -= R [ d ] ; change += L [ d ] ; count = Math . Min ( change , count ) ; } return count ; }
void minSteps ( string S ) { string new_str = "" ; int N = S . Length ; int i = 0 ; while ( i < N ) { new_str += S [ i ] ; int j = i ; while ( i < N && S [ i ] == S [ j ] ) ++ i ; } Console . Write ( ( int ) Math . Ceiling ( ( new_str . Length + 1 ) / 2.0 ) ) ; }
int MaximumSides ( int n ) { if ( n < 4 ) return - 1 ; return n % 2 == 0 ? n / 2 : - 1 ; }
int minimumMoves ( int n ) { int cnt2 = 0 , cnt5 = 0 ; while ( n % 2 == 0 ) { n /= 2 ; cnt2 ++ ; } while ( n % 5 == 0 ) { n /= 5 ; cnt5 ++ ; } if ( n == 1 && cnt2 <= cnt5 ) { return 2 * cnt5 - cnt2 ; } else return - 1 ; }
void check ( int n ) { if ( ( n & n - 1 ) != 0 ) Console . WriteLine ( "YES" ) ; else Console . WriteLine ( "NO" ) ; }
void rearrangeArrayUtil ( ArrayList A , ArrayList B , int N ) { ArrayList ans = rearrangeArray ( A , B , N ) ; if ( ans . Count != 0 ) { for ( int i = 0 ; i < ans . Count ; i ++ ) { Console . Write ( ans [ i ] + " " ) ; } } else { Console . WriteLine ( "-1" ) ; } }
void countOfSubarray ( int [ ] arr , int N ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int answer = 0 ; int sum = 0 ; mp [ 1 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( mp . ContainsKey ( sum - i ) ) answer += mp [ sum - i ] ; if ( mp . ContainsKey ( sum - 1 ) ) mp [ sum - 1 ] ++ ; else mp [ sum - 1 ] = 1 ; } Console . Write ( answer - 2 ) ; }
void countInverse ( int [ ] arr , int N , int M ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int gcdOfMandelement = gcd ( M , arr [ i ] ) ; if ( gcdOfMandelement == 1 ) { XOR ^= arr [ i ] ; } } Console . WriteLine ( XOR ) ; }
int Moves_Calculator ( int x , int y , int row , int col ) { int total_moves = 0 ; if ( ( row - x ) > 0 && ( col - y ) > 0 ) total_moves += Math . Min ( ( row - x ) , ( col - y ) ) ; if ( ( y - 1 ) > 0 && ( x - 1 ) > 0 ) total_moves += Math . Min ( ( y - 1 ) , ( x - 1 ) ) ; if ( ( x - 1 ) > 0 && ( col - y ) > 0 ) total_moves += Math . Min ( ( x - 1 ) , ( col - y ) ) ; if ( ( row - x ) > 0 && ( y - 1 ) > 0 ) total_moves += Math . Min ( ( row - x ) , ( y - 1 ) ) ; total_moves += ( row - 1 ) + ( col - 1 ) ; int king_moves = 0 ; if ( x + 1 <= row ) king_moves += 1 ; if ( x - 1 > 0 ) king_moves += 1 ; if ( y + 1 <= col ) king_moves += 1 ; if ( y - 1 > 0 ) king_moves += 1 ; if ( x + 1 <= row && y + 1 <= col ) king_moves += 1 ; if ( x + 1 <= row && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y + 1 <= col ) king_moves += 1 ; return total_moves - king_moves ; }
int clstNum ( int N ) { return ( N - 1 ) ; }
int findMax ( int [ ] a , int [ , ] dp , int i , int flag ) { if ( i == ( int ) a . Length ) { return 0 ; } if ( dp [ i , flag ] != - 1 ) { return dp [ i , flag ] ; } int ans ; if ( flag == 0 ) { ans = Math . Max ( findMax ( a , dp , i + 1 , 0 ) , a [ i ] + findMax ( a , dp , i + 1 , 1 ) ) ; } else { ans = Math . Max ( findMax ( a , dp , i + 1 , 1 ) , - 1 * a [ i ] + findMax ( a , dp , i + 1 , 0 ) ) ; } return dp [ i , flag ] = ans ; }
void findMaxSumUtil ( int [ ] arr , int N ) { int [ , ] dp = new int [ N , 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { dp [ i , j ] = - 1 ; } } Console . WriteLine ( findMax ( arr , dp , 0 , 0 ) ) ; }
int equvInverse ( int [ ] arr , int N , int P ) { int cntElem = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] * arr [ i ] ) % P == 1 ) { cntElem ++ ; } } return cntElem ; }
int power ( int K , int M ) { int res = 1 ; while ( M > 0 ) { if ( ( M & 1 ) == 1 ) { res = ( res * K ) ; } M = M >> 1 ; K = ( K * K ) ; } return res ; }
int cntWays ( int [ ] arr , int N , int K ) { int cntways = 0 ; int M = 0 ; HashSet < int > st = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { st . Add ( arr [ i ] ) ; } M = st . Count ; cntways = power ( K , M ) ; return cntways ; }
void minCost ( string s , int k ) { int n = s . Length ; int ans = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int [ ] a = new int [ 26 ] ; for ( int j = i ; j < n ; j += k ) { a [ s [ j ] - 'a' ] ++ ; } int min_cost = Int32 . MaxValue ; for ( int ch = 0 ; ch < 26 ; ch ++ ) { int cost = 0 ; for ( int tr = 0 ; tr < 26 ; tr ++ ) cost += Math . Abs ( ch - tr ) * a [ tr ] ; min_cost = Math . Min ( min_cost , cost ) ; } ans += min_cost ; } Console . WriteLine ( ans ) ; }
double pairProductMean ( int [ ] arr , int N ) { List < int > pairArray = new List < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pairProduct = arr [ i ] * arr [ j ] ; pairArray . Add ( pairProduct ) ; } } int length = pairArray . Count ; float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pairArray [ i ] ; float mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; }
double pairProductMean ( int [ ] arr , int N ) { int [ ] suffixSumArray = new int [ N ] ; suffixSumArray [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] ; } int length = ( N * ( N - 1 ) ) / 2 ; double res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffixSumArray [ i + 1 ] ; } double mean ; if ( length != 0 ) mean = res / length ; else mean = 0 ; return mean ; }
int TotalXorPair ( int [ ] arr , int N ) { int totalXOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalXOR ^= arr [ i ] ^ arr [ j ] ; } } return totalXOR ; }
int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; }
void findWinner ( char [ ] s ) { int vowels_count = 0 , consonants_count = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == 'a' s [ i ] == 'e' s [ i ] == 'i' s [ i ] == 'o' s [ i ] == 'u' ) { vowels_count ++ ; } else { consonants_count ++ ; } } if ( vowels_count == 0 ) { if ( consonants_count % 2 == 0 ) { Console . Write ( "Player B" ) ; } else { Console . Write ( "Player A" ) ; } } else if ( vowels_count == 1 && consonants_count % 2 != 0 ) { Console . Write ( "Player A" ) ; } else { Console . Write ( "D" ) ; } }
void possibleAcyclicGraph ( int N ) { Console . Write ( ( int ) Math . Pow ( 2 , N - 1 ) ) ; return ; }
int minProd ( int X , int Y , int N ) { if ( X <= Y ) { if ( N < X ) return ( X - N ) * Y ; else { return Math . Max ( Y - ( N - X + 1 ) , 1 ) ; } } if ( Y >= N ) return ( Y - N ) * X ; return Math . Max ( X - ( N - Y + 1 ) , 1 ) ; }
void sieve ( ) { is_prime = new int [ MAXN ] ; count_of_primes = new int [ MAXN ] ; Array . Fill ( is_prime , 0 ) ; Array . Fill ( count_of_primes , 0 ) ; for ( int i = 3 ; i < MAXN ; i += 2 ) { is_prime [ i ] = 1 ; } for ( int i = 3 ; i * i < MAXN ; i += 2 ) { if ( is_prime [ i ] == 1 ) { for ( int j = i * i ; j < MAXN ; j += i ) { is_prime [ j ] = 0 ; } } } is_prime [ 2 ] = 1 ; for ( int i = 1 ; i < MAXN ; i ++ ) count_of_primes [ i ] = count_of_primes [ i - 1 ] + is_prime [ i ] ; }
long power ( long x , long y , long p ) { long result = 1 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) result = ( result * x ) % p ; x = ( x * x ) % p ; y >>= 1 ; } return result ; }
void maxSumOfSquares ( int N , int S ) { int res = 0 ; if ( S < N S > 9 * N ) { Console . WriteLine ( - 1 ) ; return ; } S = S - N ; int c = 0 ; while ( S > 0 ) { c ++ ; if ( S / 8 > 0 ) { res += 9 * 9 ; S -= 8 ; } else { res += ( S + 1 ) * ( S + 1 ) ; break ; } } res = res + ( N - c ) ; Console . WriteLine ( res ) ; }
int cntMinSub ( int [ ] arr , int N , int K ) { int res = 0 ; int start = 0 ; int end = N - 1 ; Array . Sort ( arr ) ; while ( end - start > 1 ) { if ( arr [ start ] + arr [ end ] <= K ) { start ++ ; } else { res ++ ; end -- ; } } if ( end - start == 1 ) { if ( arr [ start ] + arr [ end ] <= K ) { res ++ ; start ++ ; end -- ; } else { res ++ ; end -- ; } } if ( start == end ) { res ++ ; } return res ; }
int condition ( int a , int b ) { int d = Math . Abs ( a - b ) , count = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( d ) ; i ++ ) { if ( d % i == 0 ) { if ( d / i == i ) count += 1 ; else count += 2 ; } } return count ; }
bool isComposite ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return true ; } } return false ; }
int compositePair ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int prod = arr [ i ] * arr [ j ] ; if ( isComposite ( prod ) ) { res ++ ; } } } return res ; }
bool [ ] getPrimeNum ( ) { bool [ ] isPrime = new bool [ X ] ; for ( int i = 0 ; i < X ; i ++ ) isPrime [ i ] = true ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= X ; i ++ ) { if ( isPrime [ i ] == true ) { for ( int j = i * i ; j < X ; j += i ) { isPrime [ j ] = false ; } } } return isPrime ; }
long power ( int x , int y ) { if ( y == 0 ) return 1 ; int p = ( int ) ( power ( x , y / 2 ) % mod ) ; p = ( p * p ) % mod ; if ( y % 2 == 1 ) { p = ( x * p ) % mod ; } return p ; }
bool checkDigits ( int n ) { do { int r = n % 10 ; if ( r == 3 r == 4 r == 6 r == 7 r == 9 ) return false ; n /= 10 ; } while ( n != 0 ) ; return true ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
bool isAllPrime ( int n ) { return isPrime ( n ) && checkDigits ( n ) ; }
void generateArray ( int [ ] arr , int n ) { List < int > ans = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) != 0 ) ans . Insert ( 0 , arr [ i ] ) ; else ans . Add ( arr [ i ] ) ; } if ( ( n & 1 ) != 0 ) { ans . Reverse ( ) ; } foreach ( int x in ans ) { Console . Write ( x + " " ) ; } Console . WriteLine ( ) ; }
int No_Of_subsequences ( Dictionary < int , int > mp ) { int count = 0 ; int left = 0 ; foreach ( KeyValuePair < int , int > x in mp ) { if ( ! mp . ContainsKey ( x . Key ) ) mp . Add ( x . Key , x . Value + left ) ; count += ( x . Value / x . Key ) ; left = x . Value % x . Key ; } return count ; }
void maximumsubsequences ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } Console . WriteLine ( No_Of_subsequences ( mp ) ) ; }
int power ( int X , int n ) { int res = 1 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) res = res * X ; X = X * X ; n = n >> 1 ; } return res ; }
int closestgtNum ( int N ) { int n = ( int ) Math . Log10 ( N ) + 1 ; int P = power ( 10 , n - 1 ) ; int Y = N % P ; int res = N + ( P - Y ) ; return res ; }
string closestgtNum ( string str ) { string res = "" ; int n = str . Length ; if ( str [ 0 ] < '9' ) { res = res + ( char ) ( str [ 0 ] + 1 ) ; } else { res = res + '1' ; res = res + '0' ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { res = res + '0' ; } return res ; }
int find_next ( int n , int k ) { int M = n + 1 ; while ( true ) { if ( ( M & ( 1L << k ) ) > 0 ) break ; M ++ ; } return M ; }
bool check ( List < int > arr , List < List < int > > pieces ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < arr . Count ; i ++ ) m . Add ( arr [ i ] , i ) ; for ( int i = 0 ; i < pieces . Count ; i ++ ) { if ( pieces [ i ] . Count == 1 && m . ContainsKey ( pieces [ i ] [ 0 ] ) ) { continue ; } else if ( pieces [ i ] . Count > 1 && m . ContainsKey ( pieces [ i ] [ 0 ] ) ) { int idx = m [ pieces [ i ] [ 0 ] ] ; idx ++ ; if ( idx >= arr . Count ) return false ; for ( int j = 1 ; j < pieces [ i ] . Count ; j ++ ) { if ( arr [ idx ] == pieces [ i ] [ j ] ) { idx ++ ; if ( idx >= arr . Count && j < pieces [ i ] . Count - 1 ) return false ; } else { return false ; } } } else { return false ; } } return true ; }
int maximumSubarrays ( int [ ] arr , int N , int target ) { int ans = 0 ; int availIdx = - 1 ; int cur_sum = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; mp . Add ( 0 , 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { cur_sum += arr [ i ] ; if ( mp . ContainsKey ( cur_sum - target ) && mp [ cur_sum - target ] >= availIdx ) { ans ++ ; availIdx = i ; } if ( mp . ContainsKey ( cur_sum ) ) mp [ cur_sum ] = i ; else mp . Add ( cur_sum , i ) ; } return ans ; }
int power ( int x , int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
void maximumPossibleSum ( int N , int X ) { Console . WriteLine ( X * ( power ( 2 , N ) - 1 ) ) ; }
int countOfPairs ( int x , int y ) { int counter = 1 ; while ( x > 0 y > 0 ) { int bit1 = x % 2 ; int bit2 = y % 2 ; x >>= 1 ; y >>= 1 ; if ( bit1 == 1 && bit2 == 0 ) { counter *= 2 ; continue ; } if ( ( bit1 & bit2 ) > 0 ) { counter = 0 ; break ; } } return counter ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findGCD ( int [ ] arr , int N ) { int result = 0 ; foreach ( int element in arr ) { result = gcd ( result , element ) ; if ( result == 1 ) { return 1 ; } } return result ; }
bool check_digits ( long N ) { while ( N > 0 ) { int n = ( int ) ( N % 10 ) ; if ( ( n != 0 ) && ( n != 1 ) && ( n != 4 ) && ( n != 9 ) ) { return false ; } N = N / 10 ; } return true ; }
void isFullSquare ( long N ) { if ( is_perfect ( N ) && check_digits ( N ) ) { Console . Write ( "Yes" ) ; } else { Console . Write ( "No" ) ; } }
int maxBottles ( int n , int e ) { int s = 0 , b = 0 ; int a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; }
int power ( int x , int n ) { int temp ; if ( n == 0 ) return 1 ; temp = power ( x , n / 2 ) ; if ( n % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
int count_Total_Numbers ( int n , int x ) { int total , multiples = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( i % x == 0 ) multiples ++ ; } if ( n == 1 ) return multiples ; total = ( multiples - 1 ) * power ( multiples , n - 1 ) ; return total ; }
int getPosition ( int N , int M ) { if ( M > ( N / 2 ) ) { return ( M - ( N / 2 ) ) ; } return ( M + ( N / 2 ) ) ; }
void number_of_strings ( int N , int M ) { int ans = 0 ; while ( N > 0 && M > 0 ) { if ( N > M ) { if ( N >= 2 ) { N -= 2 ; -- M ; ++ ans ; } else { break ; } } else { if ( M >= 2 ) { M -= 2 ; -- N ; ++ ans ; } else { break ; } } } Console . WriteLine ( ans ) ; }
int clearLastBit ( int N , int K ) { int mask = ( - 1 << K + 1 ) ; return N = N & mask ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < prime . Length ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < maxm ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < maxm ; i += p ) prime [ i ] = false ; } } prime [ 0 ] = false ; prime [ 1 ] = false ; }
void num_prime ( ) { prime_number [ 0 ] = 0 ; for ( int i = 1 ; i <= maxm ; i ++ ) { int tmp ; if ( prime [ i ] == true ) { tmp = 1 ; } else { tmp = 0 ; } prime_number [ i ] = prime_number [ i - 1 ] + tmp ; } }
void min_steps ( int [ ] arr , int n ) { SieveOfEratosthenes ( ) ; num_prime ( ) ; if ( n == 1 ) { Console . WriteLine ( "0" ) ; } else if ( n == 2 ) { Console . WriteLine ( "1" ) ; } else { Console . WriteLine ( prime_number [ n ] - 1 + ( n - 2 ) ) ; } }
void findWinner ( int [ ] a , int n ) { int win = 0 ; if ( n % 2 == 0 ) win = 1 ; else win = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) { if ( win == 0 && a [ i ] > 1 ) win = 1 ; } else { if ( win == 1 && a [ i ] > 1 ) win = 0 ; } } if ( win == 0 ) Console . Write ( "A" ) ; else Console . Write ( "B" ) ; }
bool isPossible ( int r , int b , int g ) { r = r % 3 ; b = b % 3 ; g = g % 3 ; if ( r == b b == == r ) { return true ; } else { return false ; } }
void checkWinner ( int N , int K ) { if ( N % ( K + 1 ) > 0 ) { Console . Write ( "A" ) ; } else { Console . Write ( "B" ) ; } }
int ncr ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
int countPath ( int N , int M , int K ) { int answer ; if ( K >= 2 ) answer = 0 ; else if ( K == 0 ) answer = ncr ( N + M - 2 , N - 1 ) ; else { answer = ncr ( N + M - 2 , N - 1 ) ; int X = ( N - 1 ) / 2 + ( M - 1 ) / 2 ; int Y = ( N - 1 ) / 2 ; int midCount = ncr ( X , Y ) ; X = ( ( N - 1 ) - ( N - 1 ) / 2 ) + ( ( M - 1 ) - ( M - 1 ) / 2 ) ; Y = ( ( N - 1 ) - ( N - 1 ) / 2 ) ; midCount *= ncr ( X , Y ) ; answer -= midCount ; } return answer ; }
int calculate_steps ( int [ ] arr , int n , int minimum ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int val = arr [ i ] ; if ( arr [ i ] > minimum ) { arr [ i ] = arr [ i ] - minimum ; count += arr [ i ] / 5 ; arr [ i ] = arr [ i ] % 5 ; count += arr [ i ] / 2 ; arr [ i ] = arr [ i ] % 2 ; if ( arr [ i ] > 0 ) { count ++ ; } } arr [ i ] = val ; } return count ; }
int solve ( int [ ] arr , int n ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; int minimum = arr [ n - 1 ] ; int count1 = 0 , count2 = 0 , count3 = 0 ; count1 = calculate_steps ( arr , n , minimum ) ; count2 = calculate_steps ( arr , n , minimum - 1 ) ; count3 = calculate_steps ( arr , n , minimum - 2 ) ; return Math . Min ( count1 , Math . Min ( count2 , count3 ) ) ; }
int maxSubset ( int [ ] arr , int N , int X ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; int counter = 0 ; int sz = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sz ++ ; if ( arr [ i ] * sz >= X ) { counter ++ ; sz = 0 ; } } return counter ; }
int getCount ( int N , int M ) { int total_count = 0 ; total_count += ( N / 10 ) ; int x = ( N / 10 ) * 10 ; if ( ( N - x ) >= M ) { total_count = total_count + 1 ; } return total_count ; }
int maximumModuloValue ( int [ ] A , int n ) { int mn = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . Min ( A [ i ] , mn ) ; } return mn ; }
int RightAngled ( int [ , ] a , int n ) { Dictionary < int , int > xpoints = new Dictionary < int , int > ( ) ; Dictionary < int , int > ypoints = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( xpoints . ContainsKey ( a [ i , 0 ] ) ) { xpoints [ a [ i , 0 ] ] = xpoints [ a [ i , 0 ] ] + 1 ; } else { xpoints . Add ( a [ i , 0 ] , 1 ) ; } if ( ypoints . ContainsKey ( a [ i , 1 ] ) ) { ypoints [ a [ i , 1 ] ] = ypoints [ a [ i , 1 ] ] + 1 ; } else { ypoints . Add ( a [ i , 1 ] , 1 ) ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( xpoints [ a [ i , 0 ] ] >= 1 && ypoints [ a [ i , 1 ] ] >= 1 ) { count += ( xpoints [ a [ i , 0 ] ] - 1 ) * ( ypoints [ a [ i , 1 ] ] - 1 ) ; } } return count ; }
void updateQuery ( int from_x , int from_y , int to_x , int to_y , int k , int [ , ] aux ) { aux [ from_x , from_y ] += k ; if ( to_x + 1 < N ) aux [ to_x + 1 , from_y ] -= k ; if ( to_x + 1 < N && to_y + 1 < M ) aux [ to_x + 1 , to_y + 1 ] += k ; if ( to_y + 1 < M ) aux [ from_x , to_y + 1 ] -= k ; }
void RepeatingSubarray ( int [ ] arr , int N ) { if ( N < 2 ) { Console . Write ( "-1" ) ; } List < int > brr = new List < int > ( ) ; brr . Add ( arr [ 0 ] ) ; brr . Add ( arr [ 1 ] ) ; for ( int i = 2 ; i < N / 2 + 1 ; i ++ ) { if ( N % i == 0 ) { bool a = false ; int n = brr . Count ; int j = i ; while ( j < N ) { int K = j % i ; if ( arr [ j ] == brr [ K ] ) { j ++ ; } else { a = true ; break ; } } if ( ! a && j == N ) { printArray ( brr ) ; return ; } } brr . Add ( arr [ i ] ) ; } Console . Write ( "-1" ) ; return ; }
void SieveOfEratosthenes ( int n ) { for ( int i = 0 ; i < isprime . Length ; i ++ ) isprime [ i ] = true ; isprime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isprime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) isprime [ i ] = false ; } } }
int KDistinctPrime ( int [ ] arr , int n , int k ) { SieveOfEratosthenes ( 2000000 ) ; Dictionary < int , int > cnt = new Dictionary < int , int > ( ) ; int result = - 1 ; for ( int i = 0 , j = - 1 ; i < n ; ++ i ) { int x = arr [ i ] ; if ( isprime [ x ] ) { if ( cnt . ContainsKey ( x ) ) cnt [ x ] = cnt [ x ] + 1 ; else cnt . Add ( x , 1 ) ; if ( cnt [ x ] == 1 ) { -- k ; } } while ( k < 0 ) { x = arr [ ++ j ] ; if ( isprime [ x ] ) { if ( cnt . ContainsKey ( x ) ) cnt [ x ] = cnt [ x ] - 1 ; else cnt . Add ( x , 0 ) ; if ( cnt [ x ] == 0 ) { ++ k ; } } } if ( k == 0 ) result = Math . Max ( result , i - j ) ; } return result ; }
void printMissingElements ( int [ ] arr , int N ) { int [ ] b = new int [ arr [ N - 1 ] + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int i = arr [ 0 ] ; i <= arr [ N - 1 ] ; i ++ ) { if ( b [ i ] == 0 ) { Console . Write ( i + " " ) ; } } }
void SieveOfEratosthenes ( List < int > StorePrimes ) { bool [ ] IsPrime = new bool [ MAX_SIZE ] ; for ( int i = 0 ; i < MAX_SIZE ; i ++ ) IsPrime [ i ] = true ; for ( int p = 2 ; p * p < MAX_SIZE ; p ++ ) { if ( IsPrime [ p ] == true ) { for ( int i = p * p ; i < MAX_SIZE ; i += p ) IsPrime [ i ] = false ; } } for ( int p = 2 ; p < MAX_SIZE ; p ++ ) if ( IsPrime [ p ] ) StorePrimes . Add ( p ) ; }
int Smallest_non_Prime ( List < int > StorePrimes , int N ) { int x = StorePrimes [ N ] ; return x * x ; }
int countNestedPolygons ( int sides ) { int count = 0 ; while ( sides > 5 ) { sides /= 2 ; count += 1 ; } return count ; }
int smallestCommon ( int a , int b , int c , int d ) { if ( a == c ) return a ; if ( a > c ) { swap ( a , c ) ; swap ( b , d ) ; } int first_term_diff = ( c - a ) ; int possible_y ; for ( possible_y = 0 ; possible_y < b ; possible_y ++ ) { if ( ( first_term_diff % b + possible_y * d ) % b == 0 ) { break ; } } if ( possible_y != b ) { return c + possible_y * d ; } return - 1 ; }
int isprm ( int n ) { if ( n <= 1 ) return 0 ; if ( n <= 3 ) return 1 ; if ( n % 2 == 0 n % 3 == 0 ) return 0 ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return 0 ; return 1 ; }
int NumberOfTrees ( int [ ] arr , int N ) { int maxElement = arr . Max ( ) ; int [ ] level = new int [ maxElement + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { level [ arr [ i ] ] ++ ; } if ( arr [ 0 ] != 0 level [ 0 ] != 1 ) { return 0 ; } int ans = 1 ; for ( int i = 0 ; i < maxElement ; i ++ ) { for ( int j = 0 ; j < level [ i + 1 ] ; j ++ ) { ans = ( ans * level [ i ] ) % mod ; } } return ans ; }
int power ( int x , int y ) { if ( y == 0 ) return 1 ; int p = power ( x , y / 2 ) % mod ; p = ( p * p ) % mod ; if ( ( y & 1 ) != 0 ) p = ( x * p ) % mod ; return p ; }
int NumberOfTrees ( int [ ] arr , int N ) { int maxElement = arr . Max ( ) ; int [ ] level = new int [ maxElement + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { level [ arr [ i ] ] ++ ; } if ( arr [ 0 ] != 0 level [ 0 ] != 1 ) { return 0 ; } int ans = 1 ; for ( int i = 0 ; i < maxElement ; i ++ ) { ans = ( ans * power ( level [ i ] , level [ i + 1 ] ) ) % mod ; } return ans ; }
int carryCount ( int num1 , int num2 ) { int count = 0 ; while ( num2 != 0 ) { int carry = num1 & num2 ; num1 = num1 ^ num2 ; num2 = carry << 1 ; count += countSetBits ( num2 ) ; } return count ; }
int power ( int X , int Y , int Mod ) { if ( Y == 0 ) return 1 ; int p = power ( X , Y / 2 , Mod ) % Mod ; p = ( p * p ) % Mod ; if ( ( Y & 1 ) != 0 ) { p = ( X * p ) % Mod ; } return p ; }
int Inversefactorial ( int N ) { if ( N <= 0 ) return 1 ; int fact = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = ( fact * i ) % Mod ; } return power ( fact , Mod - 2 , Mod ) ; }
int nck ( int N , int K ) { int factN = factorial ( N ) ; int inv = Inversefactorial ( K ) ; int invFact = Inversefactorial ( N - K ) ; return ( ( ( factN * inv ) % Mod ) * invFact ) % Mod ; }
bool checkEvenSum ( int [ ] arr , int N , int size ) { int even_freq = 0 , odd_freq = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd_freq ++ ; else even_freq ++ ; } if ( even_freq >= N ) return true ; else { if ( odd_freq % 2 == 1 ) { int taken = odd_freq - 1 ; int req = N - taken ; if ( even_freq < req ) { return false ; } else return true ; } else { int taken = odd_freq ; int req = N - taken ; if ( even_freq < req ) { return false ; } else return true ; } } }
int digitsOf ( int num ) { return num . ToString ( ) . Length ; }
int count ( int a , int tn ) { int diff = ( int ) Math . Pow ( 10 , digitsOf ( a ) ) ; return ( ( tn - a ) / diff ) + 1 ; }
int countOfSubarray ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] -- ; int [ ] pref = new int [ N ] ; pref [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) pref [ i ] = pref [ i - 1 ] + arr [ i ] ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int answer = 0 ; mp . Add ( 0 , 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( pref [ i ] ) ) { answer += mp [ pref [ i ] ] ; mp [ pref [ i ] ] = mp [ pref [ i ] ] + 1 ; } else { mp . Add ( pref [ i ] , 1 ) ; } } return answer ; }
int minOperations ( int [ ] a , int N ) { int num_of_ops1 , num_of_ops2 , sum ; num_of_ops1 = num_of_ops2 = sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 0 && sum >= 0 ) { num_of_ops1 += ( 1 + Math . Abs ( sum ) ) ; sum = - 1 ; } else if ( i % 2 == 1 && sum <= 0 ) { num_of_ops1 += ( 1 + Math . Abs ( sum ) ) ; sum = 1 ; } } sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 1 && sum >= 0 ) { num_of_ops2 += ( 1 + Math . Abs ( sum ) ) ; sum = - 1 ; } else if ( i % 2 == 0 && sum <= 0 ) { num_of_ops2 += ( 1 + Math . Abs ( sum ) ) ; sum = 1 ; } } return Math . Min ( num_of_ops1 , num_of_ops2 ) ; }
void printSubset ( int n , int k ) { List < int > answer = new List < int > ( ) ; while ( n > 0 ) { int p = ( int ) Math . Log ( n , 2 ) ; answer . Add ( ( int ) Math . Pow ( k , p ) ) ; n %= ( int ) Math . Pow ( 2 , p ) ; } answer . Reverse ( ) ; foreach ( int x in answer ) { Console . Write ( x + " " ) ; } }
void printsubset ( int n , int k ) { int count = 0 , x = 0 ; List < int > vec = new List < int > ( ) ; while ( n != 0 ) { x = n & 1 ; if ( x != 0 ) { vec . Add ( ( int ) Math . Pow ( k , count ) ) ; } n = n >> 1 ; count ++ ; } for ( int i = 0 ; i < vec . Count ; i ++ ) Console . Write ( vec [ i ] + " " ) ; }
bool checkEquall ( int [ ] arr , int N ) { int sumEven = 0 , sumOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 1 ) sumOdd += arr [ i ] ; else sumEven += arr [ i ] ; } if ( sumEven == sumOdd ) return true ; else return false ; }
bool isSumOfPower ( int n ) { bool [ ] isSum = new bool [ n + 1 ] ; List < int > perfectPowers = new List < int > ( ) ; perfectPowers . Add ( 1 ) ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { isSum [ i ] = false ; } for ( int i = 2 ; i < ( n + 1 ) ; i ++ ) { if ( isSum [ i ] == true ) { perfectPowers . Add ( i ) ; continue ; } for ( int j = i * i ; j > 0 && j < ( n + 1 ) ; j *= i ) { isSum [ j ] = true ; } } for ( int i = 0 ; i < perfectPowers . Count ; i ++ ) { isSum [ perfectPowers [ i ] ] = false ; } for ( int i = 0 ; i < perfectPowers . Count ; i ++ ) { for ( int j = i ; j < perfectPowers . Count ; j ++ ) { int sum = perfectPowers [ i ] + perfectPowers [ j ] ; if ( sum < ( n + 1 ) ) isSum [ sum ] = true ; } } return isSum [ n ] ; }
void countEvenSum ( int low , int high , int k ) { int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; long even_sum = 1 ; long odd_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { long prev_even = even_sum ; long prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } Console . WriteLine ( even_sum ) ; }
void update ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] += ( i + 1 ) ; } }
void incrementCount ( int [ ] arr , int N ) { int min = 0 ; while ( check ( arr , N ) != true ) { update ( arr , N ) ; min ++ ; } Console . WriteLine ( min ) ; }
void incrementCount ( int [ ] arr , int N ) { int mini = arr [ 0 ] - arr [ 1 ] ; for ( int i = 2 ; i < N ; i ++ ) { mini = Math . Min ( mini , arr [ i - 1 ] - arr [ i ] ) ; } Console . WriteLine ( mini ) ; }
double [ ] Length_Diagonals ( int a , double theta ) { double p = a * Math . Sqrt ( 2 + ( 2 * Math . Cos ( theta * ( Math . PI / 180 ) ) ) ) ; double q = a * Math . Sqrt ( 2 - ( 2 * Math . Cos ( theta * ( Math . PI / 180 ) ) ) ) ; return new double [ ] { p , q } ; }
int solve ( String s , int x , int y ) { int res = 0 ; foreach ( char c in s . ToCharArray ( ) ) { if ( c - '0' == x ) { res ++ ; x = x + y ; y = x - y ; x = x - y ; } } if ( x != y && res % 2 == 1 ) -- res ; return res ; }
int find_min ( String s ) { int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { count = Math . Max ( count , solve ( s , i , j ) ) ; } } return count ; }
int maxORminusXOR ( int N ) { int MSB = ( int ) Math . Ceiling ( Math . Log ( N ) ) ; int M = 0 ; for ( int i = 0 ; i <= MSB ; i ++ ) M += ( 1 << i ) ; return M ; }
int No_of_Triangle ( int N , int K ) { if ( N < K ) return - 1 ; else { int Tri_up = 0 ; Tri_up = ( ( N - K + 1 ) * ( N - K + 2 ) ) / 2 ; int Tri_down = 0 ; Tri_down = ( ( N - 2 * K + 1 ) * ( N - 2 * K + 2 ) ) / 2 ; return Tri_up + Tri_down ; } }
void AddEdge ( int u , int v ) { adj [ u ] . Add ( v ) ; adj [ v ] . Add ( u ) ; }
void Matching_dfs ( int u , int p ) { for ( int i = 0 ; i < adj [ u ] . Count ; i ++ ) { if ( adj [ u ] [ i ] != p ) { Matching_dfs ( adj [ u ] [ i ] , u ) ; } } if ( used [ u ] == 0 && used [ p ] == 0 && p != 0 ) { max_matching ++ ; used [ u ] = used [ p ] = 1 ; } }
bool canMake ( int n , int [ ] ar ) { if ( n == 1 ) return true ; else { if ( ar [ 0 ] < ar [ 1 ] ) { int i = 1 ; while ( i < n && ar [ i - 1 ] < ar [ i ] ) { i ++ ; } while ( i + 1 < n && ar [ i ] > ar [ i + 1 ] ) { i ++ ; } if ( i >= n - 1 ) return true ; else return false ; } else if ( ar [ 0 ] > ar [ 1 ] ) { int i = 1 ; while ( i < n && ar [ i - 1 ] > ar [ i ] ) { i ++ ; } while ( i + 1 < n && ar [ i ] < ar [ i + 1 ] ) { i ++ ; } if ( i >= n - 1 ) return true ; else return false ; } else { for ( int i = 2 ; i < n ; i ++ ) { if ( ar [ i - 1 ] <= ar [ i ] ) return false ; } return true ; } } }
int check_length ( int n ) { int ans = 0 ; while ( n != 0 ) { n = n >> 1 ; ans ++ ; } return ans ; }
bool check_ith_bit ( int n , int i ) { return ( n & ( 1 << ( i - 1 ) ) ) != 0 ? true : false ; }
void findPair ( int A , int B , int N ) { int X , Y ; X = N - B + A ; if ( X % 2 != 0 ) { Console . Write ( "-1" ) ; } else { X = X / 2 ; Y = N - X ; Console . Write ( X + " " + Y ) ; } }
int countSetBitsUtil ( int x ) { if ( x <= 0 ) return 0 ; return ( ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( x / 2 ) ) ; }
int countSetBits ( int L , int R ) { int bitCount = 0 ; for ( int i = L ; i <= R ; i ++ ) { bitCount += countSetBitsUtil ( i ) ; } return bitCount ; }
int countSetBit ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { bool k = true ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { ans += k == true ? 0 : 1 ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
int countSetBits ( int L , int R ) { return Math . Abs ( countSetBit ( R ) - countSetBit ( L - 1 ) ) ; }
int countSetBits ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { int n = i ; while ( n > 0 ) { count += ( n & 1 ) ; n = n >> 1 ; } } return count ; }
void countElement ( int [ ] A , int N , int [ ] B , int M , int K ) { int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int currentElement = B [ i ] ; for ( int j = 0 ; j < N ; j ++ ) { int diff = Math . Abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } Console . Write ( cnt ) ; }
double AreaofRectangle ( int L , int W ) { double area = ( W + L ) * ( W + L ) / 2 ; return area ; }
int downToZero ( int n ) { if ( n <= 3 ) return n ; int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; int sqr ; for ( int i = 4 ; i <= n ; i ++ ) { sqr = ( int ) Math . Sqrt ( i ) ; int best = int . MaxValue ; while ( sqr > 1 ) { if ( i % sqr == 0 ) { best = Math . Min ( best , 1 + dp [ sqr ] ) ; } sqr -- ; } best = Math . Min ( best , 1 + dp [ i - 1 ] ) ; dp [ i ] = best ; } return dp [ n ] ; }
int downToZero ( int n ) { if ( n <= 3 ) return n ; return n % 2 == 0 ? 3 : 4 ; }
int maxSubset ( int [ ] A , bool flag ) { int n = A . Length ; int sum = 0 ; if ( flag ) { for ( int i = 1 ; i < n ; i ++ ) A [ i ] = - A [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] > 0 ) { sum += A [ i ] ; } } return sum ; }
int findBest ( int [ ] A ) { int x = maxSubset ( A , false ) ; int y = maxSubset ( A , true ) ; y = - y ; y += A [ 0 ] ; y = - y ; return Math . Max ( x , y ) ; }
int getMinCost ( int [ ] A , int [ ] B , int N ) { int mini = int . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { mini = Math . Min ( mini , Math . Min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; }
int countSwaps ( int [ ] A , int n ) { Array . Sort ( A ) ; int ind = 1 , res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ind < n && A [ ind ] == A [ i ] ) ind ++ ; if ( ind < n && A [ ind ] > A [ i ] ) { res ++ ; ind ++ ; } if ( ind >= n ) break ; } return res ; }
int countSwaps ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int max_frequency = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } max_frequency = Math . Max ( max_frequency , mp [ arr [ i ] ] ) ; } return n - max_frequency ; }
int min_operation ( int [ ] a , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) ans += Math . Abs ( a [ i ] - a [ i - 1 ] ) ; else ans += Math . Abs ( a [ i ] ) ; } return ans ; }
int minimumrequired ( int [ ] A , int N ) { int K = N ; int ans = 0 ; while ( K > 0 ) { if ( K % 2 == 1 ) { ans = K ; break ; } int ispalindrome = 1 ; for ( int i = 0 ; i < K / 2 ; i ++ ) { if ( A [ i ] != A [ K - 1 - i ] ) ispalindrome = 0 ; } if ( ispalindrome == 1 ) { ans = K / 2 ; K /= 2 ; } else { ans = K ; break ; } } return ans ; }
void count ( int n , int k ) { long count = ( long ) ( Math . Pow ( 10 , k ) - Math . Pow ( 10 , k - 1 ) ) ; Console . Write ( count ) ; }
int maxSelections ( int [ ] A , int n , int k ) { Array . Sort ( A ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + A [ i ] ; if ( sum > k ) { break ; } count ++ ; } return count ; }
int getMaxDifference ( int N ) { int M = - 1 ; int maxDiff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int diff = ( N ^ i ) - ( N & i ) ; if ( diff >= maxDiff ) { maxDiff = diff ; M = i ; } } return M ; }
int findM ( int N ) { int M = 0 ; int MSB = ( int ) Math . Log ( N ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) M += ( 1 << i ) ; } return M ; }
int func ( int N , int P ) { int sumUptoN = ( N * ( N + 1 ) / 2 ) ; int sumOfMultiplesOfP ; if ( N < P ) { return sumUptoN ; } else if ( ( N / P ) == 1 ) { return sumUptoN - P + 1 ; } sumOfMultiplesOfP = ( ( N / P ) * ( 2 * P + ( N / P - 1 ) * P ) ) / 2 ; return ( sumUptoN + func ( N / P , P ) - sumOfMultiplesOfP ) ; }
long countStrings ( long A , long B , long K ) { long X = ( A + B ) / ( K + 1 ) ; return ( Math . Min ( A , Math . Min ( B , X ) ) * ( K + 1 ) ) ; }
int countPairs ( int [ ] a , int n , int k ) { int [ ] len = new int [ n ] ; int [ ] p = new int [ 11 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= 10 ; i ++ ) { p [ i ] = ( p [ i - 1 ] * 10 ) % k ; } for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; while ( x > 0 ) { len [ i ] ++ ; x /= 10 ; } rem [ len [ i ] , a [ i ] % k ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= 10 ; j ++ ) { int r = ( a [ i ] * p [ j ] ) % k ; int xr = ( k - r ) % k ; ans += rem [ j , xr ] ; if ( len [ i ] == j && ( r + a [ i ] % k ) % k == 0 ) ans -- ; } } return ans ; }
bool isDivisible ( int N ) { return ( N a 1 ) % 3 != 0 ; }
void maxLengthSubArray ( int [ ] A , int N ) { int [ ] forward = new int [ N ] ; int [ ] backward = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 A [ i ] != A [ i - 1 ] ) { forward [ i ] = 1 ; } else forward [ i ] = forward [ i - 1 ] + 1 ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 A [ i ] != A [ i + 1 ] ) { backward [ i ] = 1 ; } else backward [ i ] = backward [ i + 1 ] + 1 ; } int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) ans = Math . Max ( ans , Math . Min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; } Console . WriteLine ( ans ) ; }
int countDigitSum ( int N , int K ) { int l = ( int ) Math . Pow ( 10 , N - 1 ) , r = ( int ) Math . Pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; int [ ] digits = new int [ N ] ; for ( int j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num /= 10 ; } int sum = 0 , flag = 0 ; for ( int j = 0 ; j < K ; j ++ ) sum += digits [ j ] ; for ( int j = 1 ; j < N - K + 1 ; j ++ ) { int curr_sum = 0 ; for ( int m = j ; m < j + K ; m ++ ) { curr_sum += digits [ m ] ; } if ( sum != curr_sum ) { flag = 1 ; break ; } } if ( flag == 0 ) { count ++ ; } } return count ; }
int countDigitSum ( int N , int K ) { int l = ( int ) Math . Pow ( 10 , N - 1 ) , r = ( int ) Math . Pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; int [ ] digits = new int [ N ] ; for ( int j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num /= 10 ; } int sum = 0 , flag = 0 ; for ( int j = 0 ; j < K ; j ++ ) sum += digits [ j ] ; for ( int j = K ; j < N ; j ++ ) { if ( sum - digits [ j - K ] + digits [ j ] != sum ) { flag = 1 ; break ; } } if ( flag == 0 ) { count ++ ; } } return count ; }
int nth_angle ( int N , int a , int b , int n ) { int nth = 0 ; nth = a + ( n - 1 ) * b ; return nth ; }
bool findTriplet ( int [ ] arr ) { int n = arr . Length ; Stack < int > st = new Stack < int > ( ) ; int h3 = int . MinValue ; int h1 = int . MaxValue ; for ( int i = n - 1 ; i >= 0 ; i -- ) { h1 = arr [ i ] ; while ( st . Count != 0 && st . Peek ( ) < arr [ i ] ) { h3 = st . Peek ( ) ; st . Pop ( ) ; } st . Push ( arr [ i ] ) ; if ( h1 < h3 ) { return true ; } } return false ; }
void findWays ( List < int > arr , int i , int n ) { if ( n == 0 ) printList ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . Add ( j ) ; findWays ( arr , j , n - j ) ; arr . RemoveAt ( arr . Count - 1 ) ; } }
int distinctNumbers ( int [ ] arr , int m , int n ) { Dictionary < int , int > count = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( count . ContainsKey ( arr [ i ] ) ) { count [ arr [ i ] ] = count [ arr [ i ] ] + 1 ; } else { count . Add ( arr [ i ] , 1 ) ; } int [ ] fre_arr = new int [ n + 1 ] ; foreach ( int it in count . Values ) { fre_arr [ it ] ++ ; } int ans = count . Count ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = fre_arr [ i ] ; if ( temp == 0 ) continue ; int t = Math . Min ( temp , m / i ) ; ans -= t ; m -= i * t ; } return ans ; }
void no_of_moves ( int [ , ] Matrix , int x , int y ) { int moves = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( Matrix [ i , j ] != 0 ) { moves += Math . Abs ( x - i ) ; moves += Math . Abs ( y - j ) ; } } } Console . WriteLine ( moves ) ; }
bool is_linear ( String s ) { int tmp = 0 ; char first = s [ 0 ] ; for ( int pos = 0 ; pos < s . Length ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } tmp ++ ; } return true ; }
void DFS ( int U , int [ ] vis , ArrayList adj ) { vis [ U ] = 1 ; foreach ( int V in ( ArrayList ) adj [ U ] ) { if ( vis [ V ] == 0 ) DFS ( V , vis , adj ) ; } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int find_gcd ( List < int > arr ) { if ( arr . Count == 1 ) return arr [ 0 ] ; int g = arr [ 0 ] ; for ( int i = 1 ; i < arr . Count ; i ++ ) { g = gcd ( g , arr [ 1 ] ) ; } return g ; }
void maxm_gcd ( Node root , List < int > ans ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { ans . Add ( root . val ) ; maxm = Math . Max ( find_gcd ( ans ) , maxm ) ; return ; } ans . Add ( root . val ) ; maxm_gcd ( root . left , ans ) ; maxm_gcd ( root . right , ans ) ; }
void checkInfinite ( String s ) { bool flag = true ; int N = s . Length ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( s [ i ] == ( char ) ( ( int ) ( s [ i + 1 ] ) + 1 ) ) { continue ; } else if ( s [ i ] == 'a' && s [ i + 1 ] == 'z' ) { continue ; } else { flag = false ; break ; } } if ( ! flag ) Console . Write ( "NO" ) ; else Console . Write ( "YES" ) ; }
int calculateWays ( int [ ] arr1 , int [ ] arr2 , int N ) { int A = arr2 [ 0 ] , B = arr2 [ 1 ] ; int C = arr2 [ 2 ] , D = arr2 [ 3 ] ; int ans = 0 ; for ( int b = 0 ; b <= B && b * 5 <= ( N ) ; b ++ ) for ( int c = 0 ; c <= C && b * 5 + c * 10 <= ( N ) ; c ++ ) for ( int d = 0 ; d <= D && b * 5 + c * 10 + d * 20 <= ( N ) ; d ++ ) if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) ans ++ ; return ans ; }
int calculateWays ( int [ ] arr1 , int [ ] arr2 , int N ) { int A = arr2 [ 0 ] , B = arr2 [ 1 ] ; int C = arr2 [ 2 ] , D = arr2 [ 3 ] ; int ans = 0 ; for ( int b = 0 ; b <= B && b * 5 <= N ; b ++ ) { for ( int a = 0 ; a <= A && a * 1 + b * 5 <= N ; a ++ ) { ways [ a + b * 5 ] ++ ; } } for ( int c = 0 ; c <= C && c * 10 <= ( N ) ; c ++ ) { for ( int d = 0 ; d <= D && c * 10 + d * 20 <= ( N ) ; d ++ ) { ans += ways [ N - c * 10 - d * 20 ] ; } } return ans ; }
void removeAll ( int [ ] arr , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) Console . Write ( "YES" ) ; else Console . Write ( "NO" ) ; }
void minNum ( int n ) { if ( n < 3 ) Console . WriteLine ( - 1 ) ; else Console . WriteLine ( 210 * ( ( int ) ( Math . Pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ; }
void findMinimum ( String s ) { int n = s . Length ; int [ ] x = new int [ n + 1 ] ; StringBuilder s2 = new StringBuilder ( s ) ; s2 = reverse ( s2 . ToString ( ) ) ; String s3 = s2 . ToString ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s3 [ i ] == '1' ) { if ( x [ i ] == 1 ) { x [ i + 1 ] = 1 ; x [ i ] = 0 ; } else if ( 1 <= i && ( i & x [ i - 1 ] ) == 1 ) { x [ i + 1 ] = 1 ; x [ i - 1 ] = - 1 ; } else x [ i ] = 1 ; } } int c = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( x [ i ] != 0 ) c ++ ; } Console . WriteLine ( c ) ; }
void splitIntoFibonacci ( string S ) { ArrayList seq = new ArrayList ( ) ; splitIntoFibonacciHelper ( 0 , S , seq ) ; if ( seq . Count >= 3 ) { for ( int i = 0 ; i < seq . Count ; i ++ ) Console . Write ( seq [ i ] + " " ) ; } else { Console . Write ( "-1" ) ; } }
int countChanges ( int [ , ] matrix , int n , int m ) { int dist = n + m - 1 ; int [ , ] freq = new int [ dist , 10 ] ; for ( int i = 0 ; i < dist ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) freq [ i , j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { freq [ i + j , matrix [ i , j ] ] ++ ; } } int min_changes_sum = 0 ; for ( int i = 0 ; i < dist / 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) { maximum = Math . Max ( maximum , freq [ i , j ] + freq [ n + m - 2 - i , j ] ) ; total_values += ( freq [ i , j ] + freq [ n + m - 2 - i , j ] ) ; } min_changes_sum += ( total_values - maximum ) ; } return min_changes_sum ; }
int numberOfPairs ( int n ) { if ( n % 2 == 0 ) return n / 2 - 1 ; else return n / 2 ; }
int good_pair ( String [ ] str , int N ) { int countStr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { String res = str [ i ] + str [ j ] ; int [ ] vowel = new int [ 5 ] ; for ( int k = 0 ; k < res . Length ; k ++ ) { if ( res [ k ] == 'a' ) vowel [ 0 ] = 1 ; else if ( res [ k ] == 'e' ) vowel [ 1 ] = 1 ; else if ( res [ k ] == 'i' ) vowel [ 2 ] = 1 ; else if ( res [ k ] == 'o' ) vowel [ 3 ] = 1 ; else if ( res [ k ] == 'u' ) vowel [ 4 ] = 1 ; } int temp = 0 ; for ( int ind = 0 ; ind < 5 ; ind ++ ) { if ( vowel [ ind ] == 1 ) temp ++ ; } if ( temp == 5 ) countStr ++ ; } } return countStr ; }
void sieveOfEratosthenes ( int N , int [ ] s ) { bool [ ] prime = new bool [ N + 1 ] ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
int generatePrimeFactors ( int N ) { int [ ] s = new int [ N + 1 ] ; int sum = 0 ; sieveOfEratosthenes ( N , s ) ; int curr = s [ N ] ; int cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } sum = sum + cnt ; curr = s [ N ] ; cnt = 1 ; } return sum ; }
int LCM ( int a , int b ) { int lcm = a > b ? a : b ; while ( true ) { if ( lcm % a == 0 && lcm % b == 0 ) break ; else lcm ++ ; } return lcm ; }
int countSubstrings ( String s ) { int n = s . Length ; int answer = ( n * ( n - 1 ) ) / 2 ; int cnt = 1 ; List < int > v = new List < int > ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) cnt ++ ; else { v . Add ( cnt ) ; cnt = 1 ; } } if ( cnt > 0 ) v . Add ( cnt ) ; for ( int i = 0 ; i < v . Count - 1 ; i ++ ) { answer -= ( v [ i ] + v [ i + 1 ] - 1 ) ; } return answer ; }
int find_max ( int n , int k ) { int [ ] X = new int [ 32 ] ; int cnt = 0 ; for ( int i = 31 ; i >= 0 && cnt != k ; i -- ) { if ( ( n & ( 1 << i ) ) != 0 ) { X [ i ] = 1 ; cnt ++ ; } } String s = "" ; for ( int i = 31 ; i >= 0 ; i -- ) s += X [ i ] == 0 ? '0' : '1' ; return Convert . ToInt32 ( s , 2 ) ; }
int get_palindrome_time ( string str ) { int hh , mm ; hh = ( str [ 0 ] - 48 ) * 10 + ( str [ 1 ] - 48 ) ; mm = ( str [ 3 ] - 48 ) * 10 + ( str [ 4 ] - 48 ) ; int requiredTime = 0 ; while ( hh % 10 != mm / 10 hh / 10 != mm % 10 ) { ++ mm ; if ( mm == 60 ) { mm = 0 ; ++ hh ; } if ( hh == 24 ) hh = 0 ; ++ requiredTime ; } return requiredTime ; }
int maximumSubarraySum ( int [ ] a , int n , List < List < int > > subarrays ) { int i , maxsum = 0 ; int [ ] prefixArray = new int [ n ] ; for ( i = 0 ; i < subarrays . Count ; ++ i ) { prefixArray [ subarrays [ i ] [ 0 ] - 1 ] ++ ; prefixArray [ subarrays [ i ] [ 1 ] ] -- ; } for ( i = 1 ; i < n ; i ++ ) { prefixArray [ i ] += prefixArray [ i - 1 ] ; } Array . Sort ( prefixArray ) ; Array . Sort ( a ) ; for ( i = 0 ; i < n ; i ++ ) maxsum += a [ i ] * prefixArray [ i ] ; return maxsum ; }
int maxProfit ( int [ ] value , int N , int K ) { Array . Sort ( value ) ; int maxval = value [ N - 1 ] ; int maxProfit = 0 ; int curr_val ; do { curr_val = 0 ; for ( int i = 0 ; i < N ; i ++ ) { curr_val += value [ i ] ; if ( curr_val <= K ) { maxProfit = Math . Max ( curr_val + maxval * ( i + 1 ) , maxProfit ) ; } } } while ( next_permutation ( value ) ) ; return maxProfit ; }
int findways ( string s , int x ) { if ( x > s . Length ) return 0 ; int n = s . Length ; int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; ++ i ) freq [ s [ i ] - 'a' ] ++ ; multiset < int > se ; HashSet < int > se = new HashSet < int > ( ) ; for ( int i = 0 ; i < 26 ; ++ i ) if ( freq [ i ] > 0 ) se . Add ( freq [ i ] ) ; int ans = 1 ; for ( int i = 0 ; i < x / 2 ; ++ i ) { int count = 0 ; foreach ( int u in se ) { if ( u >= 2 ) count ++ ; } if ( count == 0 ) return 0 ; else ans = ans * count ; int [ ] arr = new int [ se . Count ] ; se . CopyTo ( arr ) ; int p = arr [ se . Count - 1 ] ; int val = p ; se . Remove ( p ) ; if ( val > 2 ) se . Add ( val - 2 ) ; } if ( x % 2 != 0 ) { int count = 0 ; foreach ( int u in se ) if ( u > 0 ) count ++ ; ans = ans * count ; } return ans ; }
bool checkUniqueFrequency ( int [ ] arr , int n ) { Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . ContainsKey ( arr [ i ] ) ) { freq [ arr [ i ] ] = freq [ arr [ i ] ] + 1 ; } else { freq . Add ( arr [ i ] , 1 ) ; } } HashSet < int > uniqueFreq = new HashSet < int > ( ) ; foreach ( KeyValuePair < int , int > i in freq ) { if ( uniqueFreq . Contains ( i . Value ) ) return false ; else uniqueFreq . Add ( i . Value ) ; } return true ; }
double specialSum ( int n ) { double sum = ( double ) ( n ) * ( n + 1 ) / 2 ; int a = log2 ( n ) ; sum = ( sum ) + power ( 2 , a + 1 ) - 1 ; return sum ; }
string findMin ( int x , int Y ) { string y = Y . ToString ( ) ; int n = y . Length ; ArrayList p = new ArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { p . Add ( 0 ) ; } for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = ( int ) ( ( int ) y [ i ] - ( int ) '0' ) ; if ( i > 0 ) { p [ i ] = ( int ) p [ i ] + ( int ) p [ i - 1 ] ; } } for ( int i = n - 1 , k = 0 ; ; i -- , k ++ ) { int d = 0 ; if ( i >= 0 ) { d = ( int ) y [ i ] - ( int ) '0' ; } for ( int j = d + 1 ; j <= 9 ; j ++ ) { int r = j ; if ( i > 0 ) { r += ( int ) p [ i - 1 ] ; } if ( x - r >= 0 && x - r <= 9 * k ) { string suf = helper ( k , x - r ) ; string pre = "" ; if ( i > 0 ) pre = y . Substring ( 0 , i ) ; char cur = ( char ) ( j + ( int ) '0' ) ; pre += cur ; return pre + suf ; } } } }
void largestNumber ( int n , int X , int Y ) { int maxm = Math . Max ( X , Y ) ; Y = X + Y - maxm ; X = maxm ; int Xs = 0 ; int Ys = 0 ; while ( n > 0 ) { if ( n % Y == 0 ) { Xs += n ; n = 0 ; } else { n -= X ; Ys += X ; } } if ( n == 0 ) { while ( Xs -- > 0 ) Console . Write ( X ) ; while ( Ys -- > 0 ) Console . Write ( Y ) ; } else Console . Write ( "-1" ) ; }
int check ( int unit_digit , int X ) { int times , digit ; for ( times = 1 ; times <= 10 ; times ++ ) { digit = ( X * times ) % 10 ; if ( digit == unit_digit ) return times ; } return - 1 ; }
int getNum ( int N , int X ) { int unit_digit ; unit_digit = N % 10 ; int times = check ( unit_digit , X ) ; if ( times == - 1 ) return times ; else { if ( N >= ( times * X ) ) return times ; else return - 1 ; } }
bool dfs ( List < int > [ ] g , int [ ] cost , int u , int pre ) { vis [ u ] = true ; dp [ u ] = cost [ u ] ; bool check = true ; int cur = cost [ u ] ; foreach ( int x in g [ u ] ) { if ( vis [ x ] && x != pre ) { check = false ; } else if ( ! vis [ x ] ) { check = dfs ( g , cost , x , u ) ? false : true ; cur = Math . Max ( cur , cost [ u ] + dp [ x ] ) ; } } dp [ u ] = cur ; if ( ! check ) { canTake += cost [ u ] ; } else { best = Math . Max ( best , dp [ u ] ) ; } return check ; }
void FindMaxCost ( List < int > [ ] g , int [ ] cost , int source ) { dfs ( g , cost , source , - 1 ) ; Console . Write ( canTake + best ) ; }
int after_rev ( List < int > v ) { int mini = 0 , count = 0 ; for ( int i = 0 ; i < v . Count ; i ++ ) { count += v [ i ] ; if ( count > 0 ) count = 0 ; if ( mini > count ) mini = count ; } return mini ; }
int moduloEquality ( int [ ] A , int [ ] B , int n , int m ) { Dictionary < int , int > mapA = new Dictionary < int , int > ( ) ; Dictionary < int , int > mapB = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mapA . ContainsKey ( A [ i ] ) ) { mapA [ A [ i ] ] = mapA [ A [ i ] ] + 1 ; } else { mapA . Add ( A [ i ] , 1 ) ; } if ( mapB . ContainsKey ( B [ i ] ) ) { mapB [ B [ i ] ] = mapB [ B [ i ] ] + 1 ; } else { mapB . Add ( B [ i ] , 1 ) ; } } HashSet < int > possibleValues = new HashSet < int > ( ) ; int FirstElement = B [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { int cur = A [ i ] ; possibleValues . Add ( cur > FirstElement ? m - cur + FirstElement : FirstElement - cur ) ; } int ans = Int32 . MaxValue ; foreach ( int it in possibleValues ) { bool possible = true ; foreach ( KeyValuePair < int , int > it2 in mapA ) { if ( it2 . Value != mapB [ ( it2 . Key + it ) % m ] ) { possible = false ; break ; } } if ( possible ) { ans = Math . Min ( ans , it ) ; } } return ans ; }
int countCyclicShifts ( string S , int n ) { int [ ] aux = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { if ( S [ i ] == '(' ) aux [ i ] = 1 ; else aux [ i ] = - 1 ; } int mn = aux [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { aux [ i ] += aux [ i - 1 ] ; mn = Math . Min ( mn , aux [ i ] ) ; } if ( aux [ n - 1 ] != 0 ) return 0 ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( aux [ i ] == mn ) count ++ ; } return count ; }
int count ( int k , String s ) { int [ ] ar = new int [ s . Length ] ; int end = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '1' ) { for ( int j = i ; j < s . Length && j <= i + k ; j ++ ) { ar [ j ] = - 1 ; end = j ; } i = end ; } } end = 0 ; for ( int i = s . Length - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) { for ( int j = i ; j >= 0 && j >= i - k ; j -- ) { ar [ j ] = - 1 ; end = j ; } i = end ; } } int ans = 0 ; end = 0 ; for ( int j = 0 ; j < s . Length ; j ++ ) { if ( ar [ j ] == 0 ) { ans ++ ; for ( int g = j ; g <= j + k && g < s . Length ; g ++ ) { ar [ g ] = - 1 ; end = g ; } j = end - 1 ; } } return ans ; }
int find_set ( int a ) { if ( parent [ a ] == a ) return a ; return parent [ a ] = find_set ( parent [ a ] ) ; }
void union_set ( int a , int b ) { int x = find_set ( a ) , y = find_set ( b ) ; if ( x == y ) return ; if ( rnk [ x ] == rnk [ y ] ) rnk [ x ] ++ ; if ( rnk [ y ] > rnk [ x ] ) swap ( x , y ) ; parent [ y ] = x ; }
void dfsBridges ( int a , int par ) { vis [ a ] = true ; init [ a ] = low [ a ] = timer ++ ; foreach ( int i in v [ a ] ) { if ( i == par ) continue ; if ( vis [ i ] ) low [ a ] = Math . Min ( low [ a ] , init [ i ] ) ; else { dfsBridges ( i , a ) ; low [ a ] = Math . Min ( low [ a ] , low [ i ] ) ; if ( init [ a ] < low [ i ] ) bridges . Add ( new pair ( i , a ) ) ; else union_set ( i , a ) ; } } }
bool isPalindrome ( int l , int r , string s ) { while ( l <= r ) { if ( s [ l ] != s [ r ] ) return false ; l ++ ; r -- ; } return true ; }
int numWays ( string s ) { int n = s . Length ; int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( isPalindrome ( 0 , i , s ) && isPalindrome ( i + 1 , n - 1 , s ) ) { ans ++ ; } } return ans ; }
int maxProfit ( int [ ] prices , int n ) { int profit = 0 , currentDay = n - 1 ; while ( currentDay > 0 ) { int day = currentDay - 1 ; while ( day >= 0 && ( prices [ currentDay ] > prices [ day ] ) ) { profit += ( prices [ currentDay ] - prices [ day ] ) ; day -- ; } currentDay = day ; } return profit ; }
void numberofsubstrings ( String str , int k , char [ ] charArray ) { int N = str . Length ; int [ ] available = new int [ 26 ] ; for ( int i = 0 ; i < k ; i ++ ) { available [ charArray [ i ] - 'a' ] = 1 ; } int lastPos = - 1 ; int ans = ( N * ( N + 1 ) ) / 2 ; for ( int i = 0 ; i < N ; i ++ ) { if ( available [ str [ i ] - 'a' ] == 0 ) { ans -= ( ( i - lastPos ) * ( N - i ) ) ; lastPos = i ; } } Console . WriteLine ( ans ) ; }
bool isOddStringPalindrome ( String str , int n ) { int oddStringSize = n / 2 ; bool lengthOdd = ( ( oddStringSize % 2 == 1 ) ? true : false ) ; Stack < char > s = new Stack < char > ( ) ; int i = 1 ; int c = 0 ; while ( i < n && c < oddStringSize / 2 ) { s . Push ( str [ i ] ) ; i += 2 ; c ++ ; } if ( lengthOdd ) i = i + 2 ; while ( i < n && s . Count > 0 ) { if ( s . Peek ( ) == str [ i ] ) s . Pop ( ) ; else break ; i = i + 2 ; } if ( s . Count == 0 ) return true ; return false ; }
bool isOddStringPalindrome ( String str , int n ) { int left , right ; if ( n % 2 == 0 ) { left = 1 ; right = n - 1 ; } else { left = 1 ; right = n - 2 ; } while ( left < n && right >= 0 && left < right ) { if ( str [ left ] != str [ right ] ) return false ; left += 2 ; right -= 2 ; } return true ; }
void min_remove ( string str ) { int N = str . Length ; int [ ] prefix_a = new int [ N + 1 ] ; int [ ] prefix_b = new int [ N + 1 ] ; int [ ] prefix_c = new int [ N + 1 ] ; prefix_a [ 0 ] = 0 ; prefix_b [ 0 ] = 0 ; prefix_c [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix_a [ i ] = prefix_a [ i - 1 ] + ( int ) ( ( str [ i - 1 ] == 'a' ) ? 1 : 0 ) ; prefix_b [ i ] = prefix_b [ i - 1 ] + ( int ) ( ( str [ i - 1 ] == 'b' ) ? 1 : 0 ) ; prefix_c [ i ] = prefix_c [ i - 1 ] + ( int ) ( ( str [ i - 1 ] == 'c' ) ? 1 : 0 ) ; } int maxi = Int32 . MinValue ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = i ; j <= N ; j ++ ) { maxi = Math . Max ( maxi , ( prefix_a [ i ] + ( prefix_b [ j ] - prefix_b [ i ] ) + ( prefix_c [ N ] - prefix_c [ j ] ) ) ) ; } } Console . WriteLine ( ( N - maxi ) ) ; }
int maximum_partition ( String str ) { int i = 0 , j = 0 , k = 0 ; int c = 0 , r = 0 ; Dictionary < char , int > m = new Dictionary < char , int > ( ) ; for ( i = str . Length - 1 ; i >= 0 ; i -- ) { if ( ! m . ContainsKey ( str [ i ] ) ) { m . Add ( str [ i ] , i ) ; } } i = 0 ; k = m [ str [ i ] ] ; for ( i = 0 ; i < str . Length ; i ++ ) { if ( i <= k ) { c = c + 1 ; k = Math . Max ( k , m [ str [ i ] ] ) ; } else { r = r + 1 ; c = 1 ; k = Math . Max ( k , m [ str [ i ] ] ) ; } } if ( c != 0 ) { r = r + 1 ; } return r ; }
int findAns ( int [ , ] mat , int x , int y , int n , int m ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i , j ] == 1 ) { ans += Math . Abs ( x - i ) + Math . Abs ( y - j ) ; } } } return ans ; }
void solve ( int [ ] P , int n ) { int [ ] arr = new int [ n + 1 ] ; arr [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i + 1 ] = P [ i ] ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { int t = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ i ] ; arr [ i ] = t ; cnt ++ ; } } if ( arr [ n ] == n ) { int t = arr [ n - 1 ] ; arr [ n - 1 ] = arr [ n ] ; arr [ n ] = t ; cnt ++ ; } Console . WriteLine ( cnt ) ; }
int longestSequence ( int n , int [ ] arr ) { int l = 0 , r = n - 1 ; int prev = int . MinValue ; int ans = 0 ; while ( l <= r ) { if ( arr [ l ] > prev && arr [ r ] > prev ) { if ( arr [ l ] < arr [ r ] ) { ans += 1 ; prev = arr [ l ] ; l += 1 ; } else { ans += 1 ; prev = arr [ r ] ; r -= 1 ; } } else if ( arr [ l ] > prev ) { ans += 1 ; prev = arr [ l ] ; l += 1 ; } else if ( arr [ r ] > prev ) { ans += 1 ; prev = arr [ r ] ; r -= 1 ; } else { break ; } } return ans ; }
int solve ( int n , int m , int x , int y , int d ) { int top = Math . Min ( d , x - 1 ) ; int down = Math . Min ( d , n - x ) ; int left = Math . Min ( d , y - 1 ) ; int right = Math . Min ( d , m - y ) ; int quad1 = top * left ; int quad2 = left * down ; int quad3 = down * right ; int quad4 = right * top ; int totalsq = quad1 + quad2 + quad3 + quad4 ; int singleBlocks = top + down + left + right + 1 ; return totalsq + singleBlocks ; }
int minchanges ( int [ , ] mat ) { int count = 0 ; int left = 0 , right = N + M - 2 ; while ( left < right ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int totalsize = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i + j == left ) { if ( mp . ContainsKey ( mat [ i , j ] ) ) { mp [ mat [ i , j ] ] ++ ; } else { mp [ mat [ i , j ] ] = 1 ; } totalsize ++ ; } else if ( i + j == right ) { if ( mp . ContainsKey ( mat [ i , j ] ) ) { mp [ mat [ i , j ] ] ++ ; } else { mp [ mat [ i , j ] ] = 1 ; } totalsize ++ ; } } } int changes = 0 ; foreach ( KeyValuePair < int , int > itr in mp ) { changes = Math . Max ( changes , itr . Value ) ; } count += totalsize - changes ; left ++ ; right -- ; } return count ; }
int CountLongestSubarrays ( int [ ] arr , int n , int k ) { int i , s = 0 ; for ( i = 0 ; i < n ; ++ i ) { s += arr [ i ] ; } if ( ( s % k ) != 0 ) { return 1 ; } else { int ini = 0 ; while ( ini < n && arr [ ini ] % k == 0 ) { ++ ini ; } int fin = n - 1 ; while ( fin >= 0 && arr [ fin ] % k == 0 ) { -- fin ; } int len , sum = 0 , count = 0 ; if ( ini == n ) { return - 1 ; } else { len = Math . Max ( n - 1 - ini , fin ) ; } for ( i = 0 ; i < len ; i ++ ) { sum += arr [ i ] ; } if ( sum % k != 0 ) { count ++ ; } for ( i = len ; i < n ; i ++ ) { sum = sum + arr [ i ] ; sum = sum - arr [ i - len ] ; if ( sum % k != 0 ) { count ++ ; } } return count ; } }
int nC3 ( int n ) { if ( n < 3 ) return 0 ; return ( n * ( n - 1 ) * ( n - 2 ) ) / 6 ; }
void count_triplet ( int [ ] arr , int N , int K ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( i = 1 ; i <= 1000000 ; i ++ ) { for ( j = i ; j <= 1000000 ; j += i ) { mul [ i ] += freq [ j ] ; } cnt [ i ] = nC3 ( mul [ i ] ) ; } for ( i = 1000000 ; i >= 1 ; i -- ) { for ( j = 2 * i ; j <= 1000000 ; j += i ) { cnt [ i ] -= cnt [ j ] ; } } Console . Write ( "Number of triplets " + "with GCD " + K ) ; Console . Write ( " are " + cnt [ K ] ) ; }
int getMinJumps ( string s ) { ArrayList ones = new ArrayList ( ) ; int jumps = 0 , median = 0 , ind = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '1' ) ones . Add ( i ) ; } if ( ones . Count == 0 ) return jumps ; median = ( int ) ones [ ones . Count / 2 ] ; ind = median ; for ( int i = ind ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) { jumps += ind - i ; ind -- ; } } ind = median ; for ( int i = ind ; i < s . Length ; i ++ ) { if ( s [ i ] == '1' ) { jumps += i - ind ; ind ++ ; } } return jumps ; }
void getSubsequence ( int [ ] ar ) { int N = ar . Length ; List < int > ans = new List < int > ( ) ; ans . Add ( ar [ 0 ] ) ; for ( int i = 1 ; i < N - 1 ; i ++ ) { if ( ar [ i ] > ar [ i - 1 ] ) { if ( i < N - 1 && ar [ i ] <= ar [ i + 1 ] ) { continue ; } else { ans . Add ( ar [ i ] ) ; } } else { if ( i < N - 1 && ar [ i + 1 ] < ar [ i ] ) { continue ; } else { ans . Add ( ar [ i ] ) ; } } } ans . Add ( ar [ N - 1 ] ) ; foreach ( int it in ans ) Console . Write ( it + " " ) ; }
bool isSubseqPossible ( int [ ] arr , int N , int K ) { int i ; int odd = 0 , even = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 || ( even == 0 && K % 2 == 0 ) ) return false ; return true ; }
void print_path ( int N , int jump , int coin ) { if ( jump > coin || jump * ( N - 1 ) < coin ) { Console . WriteLine ( "-1" ) ; } else { int pos = 1 ; while ( jump > 0 ) { int tmp = Math . Min ( N - 1 , coin - ( jump - 1 ) ) ; if ( pos + tmp <= N ) { pos += tmp ; } else { pos -= tmp ; } Console . Write ( pos + " " ) ; coin -= tmp ; jump -= 1 ; } } }
void countEvenOdd ( int [ ] arr , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( ( y & 1 ) != 0 ) { Console . WriteLine ( "Even = " + odd + ", Odd = " + even ) ; } else { Console . WriteLine ( "Even = " + even + ", Odd = " + odd ) ; } }
void findMinHike ( List < int > arr , int n ) { arr . Insert ( 0 , INF ) ; arr . Add ( INF ) ; int [ ] hike = new int [ n + 2 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] && arr [ i ] <= arr [ i + 1 ] ) { hike [ i ] = 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] <= arr [ i + 1 ] ) { hike [ i ] = hike [ i - 1 ] + 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { hike [ i ] = hike [ i + 1 ] + 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { hike [ i ] = Math . Max ( hike [ i - 1 ] , hike [ i + 1 ] ) + 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( hike [ i ] + " " ) ; } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void preprocess ( ) { DFS ( 1 , - 1 ) ; }
void maximumSumSubarray ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 ) mp . Add ( arr [ i ] , 1 ) ; } int first = 0 ; int last = 0 ; int ans = 0 ; int INF = ( int ) 1e6 ; foreach ( KeyValuePair < int , int > i in mp ) { int mx = i . Key ; int curr = 0 ; int curr_start = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( curr == 0 ) curr_start = j ; int val = arr [ j ] > mx ? - INF : arr [ j ] ; curr += val ; if ( curr < 0 ) curr = 0 ; if ( curr > ans ) { ans = curr ; first = curr_start ; last = j ; } } } Console . Write ( ( first + 1 ) + " " + ( last + 1 ) ) ; }
int make_xor_half ( ArrayList arr ) { int sum = 0 , xr = 0 ; foreach ( int a in arr ) { sum += a ; xr ^= a ; } if ( 2 * xr == sum ) return - 1 ; if ( xr == 0 ) { arr . Add ( sum ) ; return 1 ; } arr . Add ( xr ) ; arr . Add ( sum + xr ) ; return 2 ; }
void makeZero ( int x , int y , int a , int b ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int tot_cost = ( y - x ) * a ; int cost1 = 2 * x * a ; int cost2 = x * b ; tot_cost += Math . Min ( cost1 , cost2 ) ; Console . Write ( tot_cost ) ; }
void splitFraction ( int n , int d ) { long [ ] ar = new long [ n ] ; long first = d + n - 1 ; ar [ 0 ] = first ; for ( int i = 1 ; i < n ; i ++ ) { ar [ i ] = first * ( -- first ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ar [ i ] % n == 0 ) { Console . Write ( "1/" + ar [ i ] / n + ", " ) ; } else { Console . Write ( n + "/" + ar [ i ] + ", " ) ; } } }
int numPairs ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) ans ++ ; } } return ans ; }
int minOperations ( String s , int len ) { int operationCnt = 0 ; Stack < char > st = new Stack < char > ( ) ; int cntClosing = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s [ i ] == '{' ) { if ( cntClosing > 0 ) { operationCnt ++ ; st . Pop ( ) ; } st . Push ( s [ i ] ) ; cntClosing = 0 ; } else if ( st . Count != 0 ) { st . Push ( '{' ) ; operationCnt ++ ; cntClosing = 1 ; } else { cntClosing = ( cntClosing + 1 ) % 2 ; if ( cntClosing == 0 && st . Count != 0 ) { st . Pop ( ) ; } } } operationCnt += st . Count * 2 - cntClosing + 1 ; return operationCnt ; }
int longestSubsequence ( String s ) { int n = s . Length ; int answer = 0 ; char prev = '-' ; for ( int i = 0 ; i < n ; i ++ ) { if ( prev != s [ i ] ) { prev = s [ i ] ; answer ++ ; } } return answer ; }
int calculate ( int pos , int prev , String s ) { if ( pos == s . Length ) { return 0 ; } if ( dp [ pos , prev ] != - 1 ) return dp [ pos , prev ] ; int val = 0 ; if ( s [ pos ] - 'a' + 1 != prev ) { val = Math . Max ( val , 1 + calculate ( pos + 1 , s [ pos ] - 'a' + 1 , s ) ) ; } val = Math . Max ( val , calculate ( pos + 1 , prev , s ) ) ; return dp [ pos , prev ] = val ; }
int longestSubsequence ( String s ) { int n = s . Length ; for ( int i = 0 ; i < 100005 ; i ++ ) { for ( int j = 0 ; j < 27 ; j ++ ) { dp [ i , j ] = - 1 ; } } return calculate ( 0 , 0 , s ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void MinDiff ( int n ) { int val = ( int ) Math . Pow ( 2 , n ) ; int sep = n / 2 ; int grp1 = 0 ; int grp2 = 0 ; grp1 = grp1 + val ; for ( int i = 1 ; i < sep ; i ++ ) grp1 = grp1 + ( int ) Math . Pow ( 2 , i ) ; for ( int i = sep ; i < n ; i ++ ) grp2 = grp2 + ( int ) Math . Pow ( 2 , i ) ; Console . Write ( Math . Abs ( grp1 - grp2 ) ) ; }
int minOccupiedPosition ( int [ ] A , int n ) { int minPos = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] > 0 ) { ++ minPos ; i += 2 ; } } return minPos ; }
int missingnumber ( int n , int [ ] arr ) { int mn = Int32 . MaxValue , mx = Int32 . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == - 1 && arr [ i - 1 ] != - 1 ) { mn = Math . Min ( mn , arr [ i - 1 ] ) ; mx = Math . Max ( mx , arr [ i - 1 ] ) ; } if ( i < ( n - 1 ) && arr [ i ] == - 1 && arr [ i + 1 ] != - 1 ) { mn = Math . Min ( mn , arr [ i + 1 ] ) ; mx = Math . Max ( mx , arr [ i + 1 ] ) ; } } int res = ( mx + mn ) / 2 ; return res ; }
int Minsteps ( int n ) { int ans = 0 ; while ( n > 1 ) { if ( n % 5 == 0 ) { ans ++ ; n = n / 5 ; continue ; } else if ( n % 4 == 0 ) { ans ++ ; n = n / 4 ; continue ; } else if ( n % 3 == 0 ) { ans ++ ; n = n / 3 ; continue ; } else if ( n % 2 == 0 ) { ans ++ ; n = n / 2 ; continue ; } return - 1 ; } return ans ; }
void countDist ( int [ ] arr1 , int n , int [ ] arr2 , int m , int k ) { int count = 0 ; int smallest = arr2 [ 0 ] ; int largest = arr2 [ 0 ] ; for ( int i = 0 ; i < m ; i ++ ) { smallest = Math . Max ( smallest , arr2 [ i ] ) ; largest = Math . Min ( largest , arr1 [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( Math . Abs ( arr1 [ i ] - smallest ) > k || Math . Abs ( arr1 [ i ] - largest ) > k ) count ++ ; } Console . Write ( count ) ; }
int palindromeWinner ( string S ) { int [ ] freq = new int [ 26 ] ; int count = 0 ; for ( int i = 0 ; i < ( int ) S . Length ; ++ i ) { if ( freq [ S [ i ] - 'a' ] == 0 ) count ++ ; freq [ S [ i ] - 'a' ] ++ ; } int unique = 0 ; int duplicate = 0 ; for ( int i = 0 ; i < 26 ; ++ i ) { if ( freq [ i ] == 1 ) unique ++ ; else if ( freq [ i ] >= 2 ) duplicate ++ ; } if ( unique == 1 && ( unique + duplicate ) == count ) return 1 ; return 2 ; }
int findMinimumK ( int [ ] a , int n , int S ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return ( int ) Math . Ceiling ( ( ( S + 1 ) * 1.0 ) / ( sum * 1.0 ) ) ; }
int MinimumValue ( int [ ] a , int n ) { int answer = Int32 . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { answer = Math . Min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) ; } } return answer ; }
int MinimumValue ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int minXor = Int32 . MaxValue ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = Math . Min ( minXor , val ) ; } return minXor ; }
int count_element ( int N , int K , int [ ] arr ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; ++ i ) if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } int answer = 0 ; foreach ( KeyValuePair < int , int > i in mp ) { if ( mp . ContainsKey ( i . Key + K ) ) answer += i . Value ; } return answer ; }
int largestNum ( int n ) { int num = 0 ; int max_setBits = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { int setBits = countSetBits ( i ) ; if ( setBits >= max_setBits ) { num = i ; max_setBits = setBits ; } } return num ; }
int find_count ( int n ) { Dictionary < int , int > mpp = new Dictionary < int , int > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( mpp . ContainsKey ( digit_xor ( i ) ) ) mpp [ digit_xor ( i ) ] = mpp [ digit_xor ( i ) ] + 1 ; else mpp . Add ( digit_xor ( i ) , 1 ) ; } int maxm = 0 ; foreach ( KeyValuePair < int , int > x in mpp ) { if ( x . Value > maxm ) maxm = x . Value ; } return maxm ; }
void findString ( int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( ( char ) ( 'A' + i % K ) ) ; } }
int digit_prod ( int x ) { int prod = 1 ; while ( x != 0 ) { prod *= x % 10 ; x = x / 10 ; } return prod ; }
int find_count ( int n ) { Dictionary < int , int > mpp = new Dictionary < int , int > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { int t = digit_prod ( i ) ; if ( mpp . ContainsKey ( t ) ) { mpp [ t ] ++ ; } else { mpp [ i ] = 1 ; } } int ans = 1 ; int maxm = 0 ; foreach ( KeyValuePair < int , int > x in mpp ) { if ( x . Value > maxm ) { maxm = x . Value ; ans = 1 ; } else if ( x . Value == maxm ) { ans ++ ; } } return ans ; }
bool isPrime ( int n ) { int i ; if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) { return false ; } for ( i = 5 ; i * i <= n ; i += 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
int findSubarraySum ( int [ ] arr , int n , int K ) { Dictionary < int , int > prevSum = new Dictionary < int , int > ( ) ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == K ) { res ++ ; } if ( prevSum . ContainsKey ( currsum - K ) ) { res += ( prevSum [ currsum - K ] ) ; } if ( prevSum . ContainsKey ( currsum ) ) { prevSum [ currsum ] = prevSum [ currsum ] + 1 ; } else { prevSum . Add ( currsum , 1 ) ; } } return res ; }
void countSubarray ( int [ ] arr , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( arr [ i ] ) ) { arr [ i ] = 1 ; } else { arr [ i ] = 0 ; } } Console . Write ( findSubarraySum ( arr , n , K ) ) ; }
int find_maxm ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } int ans = 0 ; foreach ( KeyValuePair < int , int > x in mp ) { int value = x . Key ; int freq = x . Value ; if ( value == freq ) { ans ++ ; } } return ans ; }
int pow ( int x , int y ) { if ( y == 1 ) return x ; if ( y == 0 ) return 1 ; int temp = pow ( x , y / 2 ) ; temp *= temp ; if ( y % 2 == 1 ) temp *= x ; return temp ; }
int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = Math . Max ( max_sum , i + j ) ; } } return max_sum ; }
int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = Math . Max ( max_sum , a + b ) ; } } return max_sum ; }
int findSum ( int L , int R ) { ArrayList arr = new ArrayList ( ) ; int i = 0 ; int x = 2 ; while ( i <= R ) { arr . Add ( i + x ) ; if ( i + 1 <= R ) arr . Add ( i + 1 + x ) ; x *= - 1 ; i += 2 ; } int sum = 0 ; for ( i = L ; i <= R ; ++ i ) sum += ( int ) arr [ i ] ; return sum ; }
int GetMinSubarrayLength ( int [ ] a , int n ) { int ans = Math . Max ( a [ 0 ] , a [ n - 1 ] ) ; int lo = 0 , hi = n - 1 ; while ( lo < n && a [ lo ] % ans == 0 ) lo ++ ; while ( hi > lo && a [ hi ] % ans == 0 ) hi -- ; return ( hi - lo + 1 ) ; }
int count ( String s ) { int N , i , cnt = 0 , ans = 0 ; N = s . Length ; for ( i = 0 ; i < N ; i ++ ) { if ( s [ i ] == 'R' ) cnt ++ ; if ( s [ i ] == 'L' ) ans += cnt ; } return ans ; }
int maxSubArraySum ( int [ ] a , int size ) { int max_so_far = int . MinValue , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; }
int minimumValue ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int answer = 0 ; for ( int i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; }
int sumOfDigits ( int n ) { string s = n . ToString ( ) ; int sum = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { sum += ( s [ i ] - '0' ) ; } return sum ; }
int height ( int s , List < int > [ ] adj , int [ ] visited ) { visited [ s ] = 1 ; int h = 0 ; foreach ( int child in adj [ s ] ) { if ( visited [ child ] == 0 ) { h = Math . Max ( h , 1 + height ( child , adj , visited ) ) ; } } return h ; }
int minimumGroups ( List < int > [ ] adj , int N ) { int [ ] visited = new int [ N + 1 ] ; int groups = int . MinValue ; for ( int i = 1 ; i <= N ; i ++ ) { if ( visited [ i ] == 0 ) { int comHeight ; comHeight = height ( i , adj , visited ) ; groups = Math . Max ( groups , comHeight ) ; } } return groups ; }
bool isPrime ( int n ) { int flag = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { flag = 0 ; break ; } } return ( flag == 1 ? true : false ) ; }
bool isPerfectSquare ( int x ) { double sr = Math . Sqrt ( x ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ; }
int countInterestingPrimes ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime ( i ) ) { for ( int j = 1 ; j * j * j * j <= i ; j ++ ) { if ( isPerfectSquare ( i - j * j * j * j ) ) { answer ++ ; break ; } } } } return answer ; }
int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; }
int findSmallNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
int findLargeNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
int sumDivisibles ( int A , int B , int M ) { int first = findSmallNum ( A , M ) ; int last = findLargeNum ( B , M ) ; if ( first < A ) first += M ; if ( last > B ) first -= M ; int n = ( B / M ) - ( A - 1 ) / M ; return n * ( first + last ) / 2 ; }
int check ( int [ ] A , int [ ] B , int N ) { List < int > pq1 = new List < int > ( ) ; List < int > pq2 = new List < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { pq1 . Add ( A [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { pq2 . Add ( B [ i ] ) ; } pq1 . Sort ( ) ; pq1 . Reverse ( ) ; pq2 . Sort ( ) ; pq2 . Reverse ( ) ; int c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( pq1 [ 0 ] > pq2 [ 0 ] ) { c ++ ; pq1 . RemoveAt ( 0 ) ; pq2 . RemoveAt ( 0 ) ; } else { if ( pq2 . Count == 0 ) { break ; } pq2 . RemoveAt ( 0 ) ; } } return c ; }
void calcSum ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i <= n - k ; i ++ ) { int sum = 0 ; for ( int j = i ; j < k + i ; j ++ ) sum += arr [ j ] ; Console . Write ( sum + " " ) ; } }
void calcSum ( int [ ] arr , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; Console . Write ( sum + " " ) ; for ( int i = k ; i < n ; i ++ ) { sum = ( sum - arr [ i - k ] ) + arr [ i ] ; Console . Write ( sum + " " ) ; } }
long getPairs ( List < int > A , List < int > B , int n ) { int [ ] D = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { D [ i ] = A [ i ] - B [ i ] ; } Array . Sort ( D ) ; long total = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( D [ i ] > 0 ) { total += n - i - 1 ; } else { int k = upper_bound ( D , 0 , D . Length , - D [ i ] ) ; total += n - k ; } } return total ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; }
int countPairs ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) ans ++ ; return ans ; }
int countPairs ( int [ ] a , int n ) { Dictionary < int , int > frequency = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( frequency . ContainsKey ( a [ i ] ) ) { var val = frequency [ a [ i ] ] ; frequency . Remove ( a [ i ] ) ; frequency . Add ( a [ i ] , val + 1 ) ; } else { frequency . Add ( a [ i ] , 1 ) ; } } int count = 0 ; foreach ( KeyValuePair < int , int > entry in frequency ) { int f = entry . Value ; count += f * ( f - 1 ) / 2 ; } return count ; }
void preCompute ( int N ) { fact [ 0 ] = 1 ; for ( int i = 1 ; fact [ i - 1 ] <= N ; i ++ ) { fact [ i ] = ( fact [ i - 1 ] * i ) ; size ++ ; } }
int findLCS ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } return mp . Count ; }
void segments ( int n ) { if ( n == 1 n == 0 ) { return ; } if ( n % 2 == 0 ) { Console . Write ( "1" ) ; segments ( n - 2 ) ; } else if ( n % 2 == 1 ) { Console . Write ( "7" ) ; segments ( n - 3 ) ; } }
int countOperations ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { arr [ i ] ++ ; arr [ i + 1 ] ++ ; count += 2 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) return - 1 ; } return count ; }
int findMinimumSubsequences ( String A , String B ) { int numberOfSubsequences = 1 ; int sizeOfB = B . Length ; int sizeOfA = A . Length ; int inf = 1000000 ; int [ , ] next = new int [ 26 , sizeOfB ] ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < sizeOfB ; j ++ ) { next [ i , j ] = inf ; } } for ( int i = 0 ; i < sizeOfB ; i ++ ) { next [ B [ i ] - 'a' , i ] = i ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = sizeOfB - 2 ; j >= 0 ; j -- ) { if ( next [ i , j ] == inf ) { next [ i , j ] = next [ i , j + 1 ] ; } } } int pos = 0 ; int I = 0 ; while ( I < sizeOfA ) { if ( pos == 0 && next [ A [ I ] - 'a' , pos ] == inf ) { numberOfSubsequences = - 1 ; break ; } else if ( pos < sizeOfB && next [ A [ I ] - 'a' , pos ] < inf ) { int nextIndex = next [ A [ I ] - 'a' , pos ] + 1 ; pos = nextIndex ; I ++ ; } else { numberOfSubsequences ++ ; pos = 0 ; } } return numberOfSubsequences ; }
void convolution ( int [ ] x , int [ ] h , int n , int m ) { int [ ] row_vec = new int [ MAX_SIZE ] ; int [ ] col_vec = new int [ MAX_SIZE ] ; int [ ] out_ = new int [ MAX_SIZE ] ; int [ , ] circular_shift_mat = new int [ MAX_SIZE , MAX_SIZE ] ; int maxSize = n > m ? n : m ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i >= n ) { row_vec [ i ] = 0 ; } else { row_vec [ i ] = x [ i ] ; } } for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i >= m ) { col_vec [ i ] = 0 ; } else { col_vec [ i ] = h [ i ] ; } } int k = 0 , d = 0 ; for ( int i = 0 ; i < maxSize ; i ++ ) { int curIndex = k - d ; for ( int j = 0 ; j < maxSize ; j ++ ) { circular_shift_mat [ j , i ] = row_vec [ curIndex % maxSize ] ; curIndex ++ ; } k = maxSize ; d ++ ; } for ( int i = 0 ; i < maxSize ; i ++ ) { for ( int j = 0 ; j < maxSize ; j ++ ) { out_ [ i ] += circular_shift_mat [ i , j ] * col_vec [ j ] ; } Console . Write ( out_ [ i ] + " " ) ; } }
int maxLength ( string str , int len ) { int res = 0 ; int [ ] lastPos = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { lastPos [ i ] = - 1 ; } for ( int i = 0 ; i < len ; i ++ ) { int C = str [ i ] - 'a' ; if ( lastPos [ C ] != - 1 ) { res = Math . Max ( len - ( i - lastPos [ C ] - 1 ) - 1 , res ) ; } lastPos [ C ] = i ; } return res ; }
int maxProfit ( int [ ] profitA , int [ ] profitB , int n ) { int [ ] preSum = new int [ n ] ; preSum [ 0 ] = profitA [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { preSum [ i ] = preSum [ i - 1 ] + profitA [ i ] ; } int [ ] suffSum = new int [ n ] ; suffSum [ n - 1 ] = profitB [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + profitB [ i ] ; } int res = preSum [ n - 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { res = Math . Max ( res , preSum [ i ] + suffSum [ i + 1 ] ) ; } res = Math . Max ( res , suffSum [ 0 ] ) ; return res ; }
int countPartitions ( int [ ] A , int N ) { int count = 0 ; int i , j ; for ( i = 0 ; i < N ; i ++ ) { int min_elem = min_element ( A , N ) ; if ( min_elem == INT_MAX ) break ; count ++ ; for ( j = 0 ; j < N ; j ++ ) { if ( A [ j ] % min_elem == 0 ) A [ j ] = INT_MAX ; } } return count ; }
int max_palindrome ( string [ ] s , int n ) { int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] . Length % 2 != 0 ) { flag = 1 ; } } if ( flag == 1 ) { return n ; } int z = 0 ; int o = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < s [ i ] . Length ; j ++ ) { if ( s [ i ] [ j ] == '0' ) z += 1 ; else o += 1 ; } } if ( o % 2 == 0 && z % 2 == 0 ) { return n ; } else { return n - 1 ; } }
int minChanges ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { var val = mp [ arr [ i ] ] ; mp . Remove ( arr [ i ] ) ; mp . Add ( arr [ i ] , val + 1 ) ; } else { mp . Add ( arr [ i ] , 1 ) ; } } int maxElem = 0 ; foreach ( KeyValuePair < int , int > entry in mp ) { maxElem = Math . Max ( maxElem , entry . Value ) ; } return n - maxElem ; }
int minOperations ( int n , int m ) { int a = 0 , k = 1 ; int p = Math . Max ( n , m ) ; while ( n != m ) { float s = ( float ) ( p - n + p - m ) ; float q = ( float ) ( ( - 1 + Math . Sqrt ( 8 * s + 1 ) ) / 2 ) ; if ( q - Math . Floor ( q ) == 0 ) { a = ( int ) q ; n = m ; } p = p + 1 ; } return a ; }
void decBinary ( int [ ] arr , int n ) { int k = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } }
int binaryDec ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }
int maxNum ( int n , int k ) { int l = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; int [ ] a = new int [ l ] ; decBinary ( a , n ) ; int cn = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == 0 && cn < k ) { a [ i ] = 1 ; cn ++ ; } } return binaryDec ( a , l ) ; }
int minFlipsSub ( String [ ] mat , int i , int j ) { int cnt0 = 0 , cnt1 = 0 ; if ( mat [ i ] [ j ] == '1' ) cnt1 ++ ; else cnt0 ++ ; if ( mat [ i ] [ j + 1 ] == '1' ) cnt1 ++ ; else cnt0 ++ ; if ( mat [ i + 1 ] [ j ] == '1' ) cnt1 ++ ; else cnt0 ++ ; if ( mat [ i + 1 ] [ j + 1 ] == '1' ) cnt1 ++ ; else cnt0 ++ ; return Math . Min ( cnt0 , cnt1 ) ; }
int minFlips ( String [ ] mat , int r , int c ) { int res = int . MaxValue ; for ( int i = 0 ; i < r - 1 ; i ++ ) { for ( int j = 0 ; j < c - 1 ; j ++ ) { res = Math . Min ( res , minFlipsSub ( mat , i , j ) ) ; } } return res ; }
void findSubSeq ( int [ ] arr , int n , int sum ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( sum < arr [ i ] ) arr [ i ] = - 1 ; else sum -= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != - 1 ) Console . Write ( arr [ i ] + " " ) ; } }
int k_sum ( int [ ] a , int n , int k ) { int r = 0 , sum = 0 ; int ans = 0 ; for ( int l = 0 ; l < n ; l ++ ) { while ( sum < k ) { if ( r == n ) break ; else { sum += a [ r ] ; r ++ ; } } if ( sum < k ) break ; ans += n - r + 1 ; sum -= a [ l ] ; } return ans ; }
void balBracketSequence ( string str ) { int n = str . Length ; if ( str [ 0 ] == str [ n - 1 ] ) { Console . Write ( "No" ) ; } else { int cntForOpen = 0 , cntForClose = 0 ; int check = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) cntForOpen ++ ; else if ( str [ i ] == str [ n - 1 ] ) cntForOpen -- ; else cntForOpen ++ ; if ( cntForOpen < 0 ) { check = 0 ; break ; } } if ( check != 0 && cntForOpen == 0 ) { Console . Write ( "Yes, " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ n - 1 ] ) Console . Write ( ')' ) ; else Console . Write ( '(' ) ; } return ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) cntForClose ++ ; else cntForClose -- ; if ( cntForClose < 0 ) { check = 0 ; break ; } } if ( check != 0 && cntForClose == 0 ) { Console . Write ( "Yes, " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) Console . Write ( '(' ) ; else Console . Write ( ')' ) ; } return ; } } Console . Write ( "No" ) ; } }
int countSetBits ( int n , int k ) { int kth = findK ( n , k ) ; int count = 0 ; while ( kth > 0 ) { count += kth & 1 ; kth >>= 1 ; } return count ; }
char maxAlpha ( String str , int len ) { int [ ] first = new int [ MAX ] ; int [ ] last = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str [ i ] - 'a' ) ; if ( first [ index ] == - 1 ) first [ index ] = i ; last [ index ] = i ; } int ans = - 1 , maxVal = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == - 1 ) continue ; if ( ( last [ i ] - first [ i ] ) > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return ( char ) ( ans + 'a' ) ; }
int maxSum ( int [ ] arr1 , int [ ] arr2 , int n ) { int initialParity = 0 , finalParity = 0 ; int sum = 0 , minPositive = int . MaxValue , maxNegative = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { initialParity += arr2 [ i ] ; if ( arr1 [ i ] >= 0 ) { finalParity += 1 ; sum += arr1 [ i ] ; minPositive = Math . Min ( minPositive , arr1 [ i ] ) ; } else { maxNegative = Math . Max ( maxNegative , arr1 [ i ] ) ; } } if ( initialParity % 2 == finalParity % 2 ) { return sum ; } else { if ( minPositive + maxNegative >= 0 ) { return sum + maxNegative ; } else { return sum - minPositive ; } } }
bool IsLarger ( int [ ] X , int [ ] Y , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( X [ i ] < Y [ i ] ) { return false ; } } return true ; }
int solve ( int [ ] X , int [ ] Y , int n ) { int ans = 0 ; if ( IsLarger ( X , Y , n ) ) ans = 0 ; else { int d = Y [ 0 ] - X [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) X [ i ] += d ; if ( IsLarger ( X , Y , n ) ) ans = d ; else { ans = d + 1 ; } } return ans ; }
int valueofX ( int [ ] ar , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ar [ i ] ; } if ( sum % n == 0 ) { return sum / n ; } else { int A = sum / n , B = sum / n + 1 ; int ValueA = 0 , ValueB = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) ; ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) ; } if ( ValueA < ValueB ) { return A ; } else { return B ; } } }
int minLength ( int n ) { int ans = n / 26 ; if ( n % 26 != 0 ) ans ++ ; return ans ; }
int minHalls ( int [ , ] lectures , int n ) { int [ ] prefix_sum = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { prefix_sum [ lectures [ i , 0 ] ] ++ ; prefix_sum [ lectures [ i , 1 ] + 1 ] -- ; } int ans = prefix_sum [ 0 ] ; for ( int i = 1 ; i < MAX ; i ++ ) { prefix_sum [ i ] += prefix_sum [ i - 1 ] ; ans = Math . Max ( ans , prefix_sum [ i ] ) ; } return ans ; }
int minCapacity ( int [ ] enter , int [ ] exit , int n ) { int minCap = 0 ; int currCap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currCap = currCap + enter [ i ] - exit [ i ] ; minCap = Math . Max ( minCap , currCap ) ; } return minCap ; }
void generate ( ) { Queue < String > q = new Queue < String > ( ) ; q . Enqueue ( "1" ) ; q . Enqueue ( "2" ) ; q . Enqueue ( "3" ) ; q . Enqueue ( "4" ) ; q . Enqueue ( "5" ) ; bool flag = true ; ans . Add ( "0" ) ; while ( q . Count != 0 ) { String x = q . Peek ( ) ; q . Dequeue ( ) ; if ( isValidNum ( x ) ) { ans . Add ( x ) ; } if ( x . Length == 6 ) continue ; for ( int i = 0 ; i <= 5 ; i ++ ) { String z = i . ToString ( ) ; String temp = x + z ; q . Enqueue ( temp ) ; } } }
bool comp ( String a , String b ) { if ( a . Length == b . Length ) { int i = a . CompareTo ( b ) ; return i < 0 ? true : false ; } else return a . Length < b . Length ; }
int findcount ( String l , String r ) { generate ( ) ; int count = 0 ; for ( int i = 0 ; i < ans . Count ; i ++ ) { String a = ans [ i ] ; if ( comp ( l , a ) && comp ( a , r ) ) { count ++ ; } else if ( a == l a == r ) { count ++ ; } } return count ; }
int [ ] Findpermutation ( int n ) { int [ ] a = new int [ n + 1 ] ; a [ 1 ] = n ; for ( int i = 2 ; i <= n ; i ++ ) a [ i ] = i - 1 ; return a ; }
int Balanced_Substring ( String str , int n ) { int ans = 0 ; int [ ] arr = new int [ n / 2 + 1 ] ; int d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '(' ) d ++ ; else { if ( d == 1 ) { for ( int j = 2 ; j <= n / 2 + 1 && arr [ j ] != 0 ; j ++ ) arr [ j ] = 0 ; } ++ ans ; ans += arr [ d ] ; arr [ d ] ++ ; d -- ; } } return ans ; }
int power ( long x , int y , int mod ) { long res = 1 ; while ( y != 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % mod ; x = ( x * x ) % mod ; y = ( y >> 1 ) ; } return ( int ) ( res % mod ) ; }
int NoOfChords ( int A ) { int mod = ( int ) ( 1e9 + 7 ) ; long ans = ncr ( 2 * A , A , mod ) ; int inv = power ( A + 1 , mod - 2 , mod ) ; ans = ( ans * inv ) % mod ; return ( int ) ( ans % mod ) ; }
int StrictlyPositiveXor ( int [ ] A , int N ) { int allxor = 0 ; bool checkallzero = true ; for ( int i = 0 ; i < N ; i += 1 ) { allxor ^= A [ i ] ; if ( A [ i ] > 0 ) checkallzero = false ; } if ( allxor != 0 ) return N ; if ( checkallzero ) return - 1 ; int l = N , r = - 1 ; for ( int i = 0 ; i < N ; i += 1 ) { if ( A [ i ] > 0 ) { l = i + 1 ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -= 1 ) { if ( A [ i ] > 0 ) { r = i + 1 ; break ; } } return Math . Max ( N - l , r - 1 ) ; }
int FindMinOperation ( int [ ] a , int n , int k ) { List < int > Q = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) Q . Add ( a [ i ] ) ; Q . Sort ( ) ; int ans = 0 ; while ( true ) { if ( Q [ 0 ] >= k ) break ; if ( Q . Count < 2 ) return - 1 ; int x = Q [ 0 ] ; Q . RemoveAt ( 0 ) ; int y = Q [ 0 ] ; Q . RemoveAt ( 0 ) ; int z = ( x * y ) / gcd ( x , y ) ; Q . Add ( z ) ; Q . Sort ( ) ; ans ++ ; } return ans ; }
void findWeights ( int X ) { int sum = 0 ; int power = 0 ; int number = 3 ; while ( sum < X ) { sum = number - 1 ; sum /= 2 ; power ++ ; number *= 3 ; } int ans = 1 ; for ( int i = 1 ; i <= power ; i ++ ) { Console . Write ( ans + " " ) ; ans = ans * 3 ; } }
int solve ( int [ ] Array , int N , int K ) { int [ ] count_Arr = new int [ N + 2 ] ; int factor = 1 ; int size = N ; while ( size > 0 ) { int end = size ; count_Arr [ 1 ] += factor * N ; count_Arr [ end + 1 ] -= factor * N ; factor ++ ; size /= 2 ; } for ( int i = 2 ; i <= N ; i ++ ) count_Arr [ i ] += count_Arr [ i - 1 ] ; List < Pair > element = new List < Pair > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Pair x = new Pair ( Array [ i ] , count_Arr [ i + 1 ] ) ; element . Add ( x ) ; } int start = 1 ; for ( int i = 0 ; i < N ; i ++ ) { int end = start + element [ 0 ] . getSecond ( ) - 1 ; if ( K >= start && K <= end ) return element [ i ] . getFirst ( ) ; start += element [ i ] . getSecond ( ) ; } return - 1 ; }
void find_distinct ( int [ ] a , int n , int q , int [ ] queries ) { int [ ] check = new int [ MAX ] ; int [ ] idx = new int [ MAX ] ; int cnt = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( check [ a [ i ] ] == 0 ) { idx [ i ] = cnt ; check [ a [ i ] ] = 1 ; cnt ++ ; } else { idx [ i ] = cnt - 1 ; } } for ( int i = 0 ; i < q ; i ++ ) { int m = queries [ i ] ; Console . Write ( idx [ m ] + " " ) ; } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int lcm ( int n , int m ) { return ( n * m ) / gcd ( n , m ) ; }
bool matrix_exist ( int [ ] row , int [ ] column , int r , int c ) { int row_sum = 0 ; int column_sum = 0 ; int row_max = - 1 ; int column_max = - 1 ; int row_non_zero = 0 ; int column_non_zero = 0 ; for ( int i = 0 ; i < r ; i ++ ) { row_sum += row [ i ] ; row_max = Math . Max ( row_max , row [ i ] ) ; if ( row [ i ] > 0 ) { row_non_zero ++ ; } } for ( int i = 0 ; i < c ; i ++ ) { column_sum += column [ i ] ; column_max = Math . Max ( column_max , column [ i ] ) ; if ( column [ i ] > 0 ) { column_non_zero ++ ; } } if ( ( row_sum != column_sum ) || ( row_max > column_non_zero ) || ( column_max > row_non_zero ) ) { return false ; } return true ; }
int longestSubarray ( int [ ] arr , int n ) { int maxMean = 0 ; for ( int i = 1 ; i < n ; i ++ ) maxMean = Math . Max ( maxMean , ( arr [ i ] + arr [ i - 1 ] ) / 2 ) ; int ans = 0 ; int subarrayLength = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= maxMean ) ans = Math . Max ( ans , ++ subarrayLength ) ; else subarrayLength = 0 ; return ans ; }
int maxDistance ( int [ ] arr , int n ) { if ( arr [ 0 ] != arr [ n - 1 ] ) return ( n - 1 ) ; int i = n - 1 ; while ( i > 0 ) { if ( arr [ i ] != arr [ 0 ] ) break ; i -- ; } int distFirst = ( i == 0 ) ? - 1 : i ; i = 0 ; while ( i < n - 1 ) { if ( arr [ i ] != arr [ n - 1 ] ) break ; i ++ ; } int distLast = ( i == n - 1 ) ? - 1 : ( n - 1 - i ) ; int maxDist = Math . Max ( distFirst , distLast ) ; return maxDist ; }
int SubarraySum ( int [ ] a , int n , int x ) { int ans = - 10000 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int curans = 0 ; List < int > pq = new List < int > ( ) ; List < int > pq2 = new List < int > ( ) ; for ( int k = 0 ; k < n ; k ++ ) { if ( k >= i && k <= j ) { curans += a [ k ] ; pq2 . Add ( a [ k ] ) ; } else pq . Add ( a [ k ] ) ; } pq . Sort ( ) ; pq . Reverse ( ) ; pq2 . Sort ( ) ; ans = Math . Max ( ans , curans ) ; for ( int k = 1 ; k <= x ; k ++ ) { if ( pq . Count == 0 pq2 . Count == 0 pq2 [ 0 ] >= pq [ 0 ] ) break ; curans -= pq2 [ 0 ] ; pq2 . RemoveAt ( 0 ) ; curans += pq [ 0 ] ; pq . RemoveAt ( 0 ) ; ans = Math . Max ( ans , curans ) ; } } } return ans ; }
void solve ( int n , int k ) { int mini = 0 ; int x1 = 1 ; int [ ] a = new int [ k ] ; for ( int i = 1 ; i <= k ; i ++ ) { mini += x1 ; a [ i - 1 ] = x1 ; x1 += 1 ; } if ( n < mini ) { Console . Write ( "-1" ) ; return ; } int rem = n - mini ; int cnt = rem / k ; rem = rem % k ; for ( int i = 0 ; i < k ; i ++ ) a [ i ] += cnt ; for ( int i = k - 1 ; i > 0 && rem > 0 ; i -- ) { int xx = a [ i - 1 ] * 2 ; int left = xx - a [ i ] ; if ( rem >= left ) { a [ i ] = xx ; rem -= left ; } else { a [ i ] += rem ; rem = 0 ; } } int sum = a [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) { if ( a [ i ] > 2 * a [ i - 1 ] ) { Console . Write ( "-1" ) ; return ; } sum += a [ i ] ; } if ( sum != n ) { Console . Write ( "-1" ) ; return ; } for ( int i = 0 ; i < k ; i ++ ) Console . Write ( a [ i ] + " " ) ; }
void printMaxNumber ( int n ) { if ( n % 2 != 0 ) { Console . Write ( "7" ) ; for ( int i = 0 ; i < ( n - 3 ) / 2 ; i ++ ) Console . Write ( "1" ) ; } else { for ( int i = 0 ; i < n / 2 ; i ++ ) Console . Write ( "1" ) ; } }
int minOperations ( int [ ] arr , int n ) { int maxi , result = 0 ; int [ ] freq = new int [ 1000001 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; } maxi = arr . Max ( ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; }
int maxCoins ( int X , int Y ) { if ( X < Y ) { swap ( X , Y ) ; } int coins = X ; X -- ; coins += Math . Max ( X , Y ) ; return coins ; }
int findElementsCrossed ( int [ ] arr , int a , int b , int n ) { int aa = a ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a == 0 && b == 0 ) break ; else if ( a == 0 ) { if ( arr [ i ] == 1 ) { b -= 1 ; a = Math . Min ( aa , a + 1 ) ; } else b -= 1 ; } else if ( b == 0 ) a -- ; else if ( arr [ i ] == 1 && a < aa ) { b -= 1 ; a = Math . Min ( aa , a + 1 ) ; } else a -- ; ans ++ ; } return ans ; }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void pushBinaryToBorder ( int [ ] arr , int n ) { int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 1 ) arr [ count1 ++ ] = arr [ i ] ; while ( count1 < n ) arr [ count1 ++ ] = 1 ; int lastNonOne = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == 1 ) continue ; if ( lastNonOne == 0 ) { lastNonOne = i ; } if ( arr [ i ] != 0 ) arr [ lastNonOne -- ] = arr [ i ] ; } while ( lastNonOne >= 0 ) arr [ lastNonOne -- ] = 0 ; }
int getMaxValue ( int [ ] arr , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { return 0 ; } first = second = int . MinValue ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) { second = arr [ i ] ; } } if ( second == int . MinValue ) { return 0 ; } else { return second ; } }
bool isVowel ( char ch ) { switch ( ch ) { case 'a' : case 'e' : case 'i' : case 'o' : case 'u' : return true ; default : return false ; } }
int vowelPairs ( string s , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( isVowel ( s [ i ] ) && isVowel ( s [ i + 1 ] ) ) cnt ++ ; } return cnt ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int solve ( int [ ] health , int n ) { int currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) ; for ( int i = 2 ; i < n ; ++ i ) { currentgcd = gcd ( currentgcd , health [ i ] ) ; } return currentgcd ; }
string smallestString ( int N , int [ ] A ) { char ch = 'a' ; string S = "" ; if ( N < 1 A [ 0 ] != 1 ) { S = "-1" ; return S ; } S += ch ; ch ++ ; for ( int i = 1 ; i < N ; i ++ ) { int diff = A [ i ] - A [ i - 1 ] ; if ( diff > 1 diff < 0 A [ i ] > 26 ) { S = "-1" ; return S ; } else if ( diff == 0 ) S += 'a' ; else { S += ch ; ch ++ ; } } return S ; }
int bankNotes ( int A , int B , int S , int N ) { int numerator = S - ( B * N ) ; int denominator = A - B ; if ( numerator % denominator == 0 ) return ( numerator / denominator ) ; return - 1 ; }
int countSteps ( int n ) { int steps = 0 ; while ( n > 0 ) { int largest = ( int ) Math . Sqrt ( n ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; }
int longestSubstring ( string s ) { int cnt = 1 , maxi = 1 ; int n = s . Length ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] != s [ i - 1 ] ) cnt ++ ; else { maxi = Math . Max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . Max ( cnt , maxi ) ; return maxi ; }
int Minimum_Operations ( int [ ] a , int n ) { int [ ] np = new int [ n + 1 ] ; np [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { np [ i ] = np [ i + 1 ] ; if ( a [ i ] <= 0 ) np [ i ] ++ ; } int pos = 0 ; int ans = n ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] >= 0 ) pos ++ ; ans = Math . Min ( ans , pos + np [ i + 1 ] ) ; } return ans ; }
int findSumofEle ( int [ ] arr1 , int m , int [ ] arr2 , int n , int k ) { float arraySum = 0 ; for ( int i = 0 ; i < n ; i ++ ) arraySum += arr2 [ i ] ; float mean = arraySum / n ; int sumOfElements = 0 ; float difference = 0 ; for ( int i = 0 ; i < m ; i ++ ) { difference = arr1 [ i ] - mean ; if ( ( difference < 0 ) && ( k > ( - 1 ) * difference ) ) { sumOfElements += arr1 [ i ] ; } if ( ( difference >= 0 ) && ( k > difference ) ) { sumOfElements += arr1 [ i ] ; } } return sumOfElements ; }
void findIntegers ( int n , int x , int y ) { ArrayList ans = new ArrayList ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) ans . Add ( 1 ) ; if ( y - ( n - 1 ) <= 0 ) { Console . Write ( "-1" ) ; return ; } ans . Add ( y - ( n - 1 ) ) ; int store = 0 ; for ( int i = 0 ; i < n ; i ++ ) store += ( int ) ans [ i ] * ( int ) ans [ i ] ; if ( store < x ) { Console . Write ( "-1" ) ; return ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( ( int ) ans [ i ] + " " ) ; }
int Minsteps ( int n , int m ) { int ans = 0 ; while ( m > n ) { if ( m % 2 != 0 ) { m ++ ; ans ++ ; } m /= 2 ; ans ++ ; } return ans + n - m ; }
int getsum ( int x ) { return ( x * ( x + 1 ) ) / 2 ; }
int maxCandies ( int [ ] arr , int n ) { int prevBought = arr [ n - 1 ] ; int candies = prevBought ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int x = Math . Min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; }
int sumArr ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
int maxSum ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int i = 0 ; while ( i < n && k > 0 && arr [ i ] < 0 ) { arr [ i ] *= - 1 ; k -- ; i ++ ; } if ( k % 2 == 1 ) { int min = 0 ; for ( i = 1 ; i < n ; i ++ ) if ( arr [ min ] > arr [ i ] ) min = i ; arr [ min ] *= - 1 ; } return sumArr ( arr , n ) ; }
int Maxsum ( int c1 , int c2 , int c3 , int c4 ) { int sum = 0 ; int two34 = Math . Min ( c2 , Math . Min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += Math . Min ( c2 , c1 ) * 12 ; return sum ; }
void replacedArray ( int N , int [ ] arr ) { int pos_sum , neg_sum , i , j , diff ; for ( i = 0 ; i < N ; i ++ ) { pos_sum = 0 ; neg_sum = 0 ; for ( j = i + 1 ; j < N ; j ++ ) { if ( arr [ j ] > 0 ) pos_sum += arr [ j ] ; else neg_sum += arr [ j ] ; } diff = Math . Abs ( pos_sum ) - Math . Abs ( neg_sum ) ; arr [ i ] = Math . Abs ( diff ) ; } }
int maximumResult ( int a , int b , int c ) { int countOfNegative = 0 ; int sum = a + b + c ; int product = a * b * c ; int largest = ( a > b ) ? ( ( a > c ) ? a : c ) : ( ( b > c ) ? b : c ) ; int smallest = ( a < b ) ? ( ( a < c ) ? a : c ) : ( ( b < c ) ? b : c ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } return - 1 ; }
bool isPalindrome ( string s ) { for ( int i = 0 ; i < s . Length ; ++ i ) { if ( s [ i ] != s [ s . Length - i - 1 ] ) { return false ; } } return true ; }
bool ans ( string s ) { string s2 = s ; for ( int i = 0 ; i < s . Length ; ++ i ) { s2 = s2 [ s2 . Length - 1 ] + s2 ; s2 = s2 . Substring ( 0 , s2 . Length - 1 ) ; if ( ( s == null ? s2 != null : ! s . Equals ( s2 ) ) && isPalindrome ( s2 ) ) { return true ; } } return false ; }
int solve ( string s ) { if ( s . Length <= 3 ) { return - 1 ; } int [ ] cnt = new int [ 25 ] ; for ( int i = 0 ; i < s . Length ; i ++ ) { cnt [ s [ i ] - 'a' ] ++ ; } if ( cnt . Max ( ) >= ( s . Length - 1 ) ) { return - 1 ; } else { return ( ans ( s ) ? 1 : 2 ) ; } }
int solveEven ( String s ) { if ( s . Length % 2 == 1 ) { return 2 ; } String ls = s . Substring ( 0 , s . Length / 2 ) ; String rs = s . Substring ( s . Length / 2 , s . Length ) ; if ( ls != rs ) { return 1 ; } return solveEven ( ls ) ; }
int solveOdd ( String s ) { return 2 ; }
int solve ( String s ) { if ( s . Length <= 3 ) { return - 1 ; } int [ ] cnt = new int [ 25 ] ; for ( int i = 0 ; i < s . Length ; i ++ ) { cnt [ s [ i ] - 'a' ] ++ ; } if ( cnt . Max ( ) >= s . Length - 1 ) { return - 1 ; } if ( s . Length % 2 == 0 ) { return solveEven ( s ) ; } if ( s . Length % 2 == 1 ) { return solveOdd ( s ) ; } return int . MinValue ; }
int minChanges ( char [ ] str , int n ) { int count = 0 , zeros = 0 , ones = 0 ; if ( str [ 0 ] != '1' ) { count ++ ; ones ++ ; } for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) zeros ++ ; else ones ++ ; if ( zeros > ones ) { zeros -- ; ones ++ ; count ++ ; } } return count ; }
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; for ( int i = 1 ; i <= a ; i ++ ) { ans += b / n ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }
int findCountOfPairs ( int a , int b , int n ) { if ( a > b ) { int temp1 = a ; a = b ; b = temp1 ; } int temp = 1 , count = 0 ; for ( int i = n ; temp > 0 ; i += n ) { if ( a >= i ) { temp = i - 1 ; } else if ( b >= i ) { temp = a ; } else if ( i > b ) { temp = a - ( i - b ) + 1 ; } if ( temp > 0 ) { count += temp ; } } return count ; }
int minGCD ( int [ ] arr , int n ) { int minGCD = 0 ; for ( int i = 0 ; i < n ; i ++ ) minGCD = __gcd ( minGCD , arr [ i ] ) ; return minGCD ; }
int minLCM ( int [ ] arr , int n ) { int minLCM = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minLCM = Math . Min ( minLCM , arr [ i ] ) ; return minLCM ; }
int countSteps ( int curx , int cury , int n , int m , int [ , ] moves ) { int count = 0 ; int k = moves . GetLength ( 0 ) ; for ( int i = 0 ; i < k ; i ++ ) { int x = moves [ i , 0 ] ; int y = moves [ i , 1 ] ; int stepct = Math . Min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) ; count += stepct ; curx += stepct * x ; cury += stepct * y ; } return count ; }
int min_elimination ( int n , int [ ] arr ) { int count = 0 ; int prev_val = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; }
string getCount ( int N ) { if ( N % 2 == 1 ) return "0" ; string result = "9" ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += "0" ; return result ; }
int cmp ( int a , int b ) { if ( a > b ) return 1 ; else if ( a == b ) return 0 ; else return - 1 ; }
int maxSubStrings ( String s , int k ) { int maxSubStr = 0 , n = s . Length ; for ( int c = 0 ; c < 26 ; c ++ ) { char ch = ( char ) ( ( int ) 'a' + c ) ; int curr = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( s [ i ] != ch ) continue ; int cnt = 0 ; while ( i < n && s [ i ] == ch && cnt != k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt == k ) curr ++ ; } maxSubStr = Math . Max ( maxSubStr , curr ) ; } return maxSubStr ; }
bool canFormTeam ( int n , int m ) { if ( n >= 1 && m >= 2 ) return true ; if ( m >= 1 && n >= 2 ) return true ; return false ; }
int maxTeams ( int n , int m ) { int count = 0 ; while ( canFormTeam ( n , m ) ) { if ( n > m ) { n -= 2 ; m -= 1 ; } else { m -= 2 ; n -= 1 ; } count ++ ; } return count ; }
bool canBePicked ( int [ ] digits , int num ) { int [ ] copyDigits = ( int [ ] ) digits . Clone ( ) ; while ( num > 0 ) { int digit = num % 10 ; if ( copyDigits [ digit ] == 0 ) return false ; else copyDigits [ digit ] -- ; num /= 10 ; } return true ; }
long max ( long a , long b ) { if ( a > b ) return a ; else return b ; }
long smallestSide ( long [ ] a ) { Array . Sort ( a ) ; long side1 , side2 , side3 , side4 , side11 , side12 , sideOfSquare ; side1 = a [ 0 ] + a [ 3 ] ; side2 = a [ 1 ] + a [ 2 ] ; side3 = a [ 0 ] + a [ 1 ] ; side4 = a [ 2 ] + a [ 3 ] ; side11 = max ( side1 , side2 ) ; side12 = max ( side3 , side4 ) ; sideOfSquare = max ( side11 , side12 ) ; return sideOfSquare ; }
void find_rectangle ( int area ) { for ( int i = ( int ) Math . Ceiling ( Math . Sqrt ( area ) ) ; i <= area ; i ++ ) { if ( area / i * i == area ) { Console . WriteLine ( i + " " + ( int ) ( area / i ) ) ; return ; } } }
int sizeSubSet ( int [ ] a , int k , int n ) { Array . Sort ( a ) ; Dictionary < int , int > s = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % k != 0 || ! s . ContainsKey ( a [ i ] / k ) ) { if ( s . ContainsKey ( a [ i ] ) ) { var val = s [ a [ i ] ] ; s . Remove ( a [ i ] ) ; s . Add ( a [ i ] , val + 1 ) ; } else { s . Add ( a [ i ] , 1 ) ; } } } return s . Count ; }
int minimumSets ( string s , int y ) { int cnt = 0 ; int num = 0 ; int l = s . Length ; bool f = false ; for ( int i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s [ i ] - '0' ) ; if ( num <= y ) f = true ; { if ( f ) cnt += 1 ; num = s [ i ] - '0' ; f = false ; if ( num <= y ) f = true ; else num = 0 ; } } if ( f == true ) cnt += 1 ; return cnt ; }
void ModifiedArray ( int [ ] a , int n ) { int l = 0 , r = int . MaxValue ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n / 2 ; i ++ ) { b [ i ] = Math . Max ( l , a [ i ] - r ) ; b [ n - i - 1 ] = a [ i ] - b [ i ] ; l = b [ i ] ; r = b [ n - i - 1 ] ; } printArr ( b , n ) ; }
int greatestKBits ( int X , int K ) { int set_bit_count = countSetBits ( X ) ; if ( set_bit_count <= K ) return X ; int diff = set_bit_count - K ; for ( int i = 0 ; i < diff ; i ++ ) X &= ( X - 1 ) ; return X ; }
int minItems ( int k , int r ) { for ( int i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; }
int maxSubArraySum ( int [ ] a , int size ) { int max_so_far = int . MinValue , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int maxSum ( int [ ] a , int n ) { int S = 0 ; int S1 = maxSubArraySum ( a , n ) ; for ( int i = 0 ; i < n ; i ++ ) S += a [ i ] ; return ( 2 * S1 - S ) ; }
void check_distribution ( int n , int k , int [ ] age , int [ ] candy ) { int mxage = age [ 0 ] ; for ( int i = 0 ; i < age . Length ; i ++ ) { if ( mxage < age [ i ] ) { mxage = age [ i ] ; } } int mxcandy = candy [ 0 ] ; for ( int i = 0 ; i < candy . Length ; i ++ ) { if ( mxcandy < candy [ i ] ) { mxcandy = candy [ i ] ; } } int [ ] fr1 = new int [ mxage + 1 ] ; Array . Fill ( fr1 , 0 ) ; int [ ] fr2 = new int [ mxcandy + 1 ] ; Array . Fill ( fr2 , 0 ) ; for ( int j = 0 ; j < n ; j ++ ) { fr1 [ age [ j ] ] += 1 ; } for ( int j = 0 ; j < k ; j ++ ) { fr2 [ candy [ j ] ] += 1 ; } k = 0 ; bool Tf = true ; for ( int j = 0 ; j < mxage ; j ++ ) { if ( fr1 [ j ] == 0 ) { continue ; } bool flag = false ; while ( k < mxcandy ) { if ( fr1 [ j ] <= fr2 [ k ] ) { flag = true ; break ; } k += 1 ; } k = k + 1 ; if ( flag == false ) { Tf = false ; break ; } } if ( Tf ) { Console . WriteLine ( "Yes" ) ; } else { Console . WriteLine ( "No" ) ; } }
int check ( int n , List < int > marks ) { int x = marks . Max ( ) ; int bonus = 100 - x ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( marks [ i ] + bonus >= 50 ) c += 1 ; } return c ; }
int find_sum ( int n , int k ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; }
void findTwoNumbers ( int sum , int gcd ) { if ( __gcd ( gcd , sum - gcd ) == gcd && sum != gcd ) Console . WriteLine ( "a = " + Math . Min ( gcd , sum - gcd ) + ", b = " + ( int ) ( sum - Math . Min ( gcd , sum - gcd ) ) ) ; else Console . WriteLine ( - 1 ) ; }
void maxLitres ( int budget , int plastic , int glass , int refund ) { if ( glass - refund < plastic ) { int ans = Math . Max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += budget / plastic ; Console . WriteLine ( ans ) ; } else { Console . WriteLine ( ( budget / plastic ) ) ; } }
void smallestPermute ( int n ) { char [ ] res = new char [ n + 1 ] ; if ( n % 2 == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = ( char ) ( 48 + i + 2 ) ; else res [ i ] = ( char ) ( 48 + i ) ; } } else { for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = ( char ) ( 48 + i + 2 ) ; else res [ i ] = ( char ) ( 48 + i ) ; } res [ n - 1 ] = ( char ) ( 48 + n - 2 ) ; res [ n - 2 ] = ( char ) ( 48 + n ) ; res [ n - 3 ] = ( char ) ( 48 + n - 1 ) ; } res [ n ] = '\0' ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( res [ i ] ) ; } }
int leastValue ( int P , int A , int N , int [ ] a ) { int ans = - 1 ; float tmp = float . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { float t = ( float ) ( P - a [ i ] * 0.006 ) ; if ( Math . Abs ( t - A ) < tmp ) { tmp = Math . Abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
int minOperations ( int [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { hashTable [ arr [ i ] ] ++ ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hashTable [ arr [ i ] ] != 0 ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) { hashTable [ arr [ j ] ] = 0 ; } } res ++ ; } } return res ; }
int minInsertions ( int [ ] H , int n , int K ) { int inser = 0 ; for ( int i = 1 ; i < n ; ++ i ) { float diff = Math . Abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += ( int ) Math . Ceiling ( diff / K ) - 1 ; } return inser ; }
int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( ( N & 1 ) > 0 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; }
int count_minimum_operations ( long n ) { int count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; }
int count_minimum_operations ( int n ) { if ( n == 2 ) { return 1 ; } else if ( n == 1 ) { return 0 ; } if ( n % 3 == 0 ) { return 1 + count_minimum_operations ( n / 3 ) ; } else if ( n % 3 == 1 ) { return 1 + count_minimum_operations ( n - 1 ) ; } else { return 1 + count_minimum_operations ( n + 1 ) ; } }
int findPermutation ( int n ) { int len = ( int ) Math . Ceiling ( Math . Log10 ( n ) ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return n ; } else { n = ( n / 10 ) + ( n % 10 ) * ( int ) Math . Pow ( 10 , len - i - 1 ) ; continue ; } } return - 1 ; }
int maxMatrixScore ( int [ , ] A , int K ) { Dictionary < int , int > update = new Dictionary < int , int > ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i , 0 ] == 0 ) { ans = 0 ; for ( int j = 1 ; j < m ; ++ j ) ans = ( int ) ( ans + A [ i , j ] * Math . Pow ( 2 , m - j - 1 ) ) ; update . Add ( ( int ) ans , i ) ; } } foreach ( KeyValuePair < int , int > it in update ) if ( K > 0 ) { int idx = it . Value ; for ( int j = 0 ; j < m ; ++ j ) A [ idx , j ] = ( A [ idx , j ] + 1 ) % 2 ; K -- ; } ans = 0 ; for ( int j = 0 ; j < m ; ++ j ) { int zero = 0 , one = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i , j ] == 0 ) zero ++ ; else one ++ ; } if ( K > 0 && zero > one ) { ans += zero * ( int ) Math . Pow ( 2 , m - j - 1 ) ; K -- ; } else ans += one * ( int ) Math . Pow ( 2 , m - j - 1 ) ; } return ans ; }
bool isSellingPossible ( int n , int [ ] a ) { int i , c25 = 0 , c50 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 25 ) c25 ++ ; else if ( a [ i ] == 50 ) { c50 ++ ; if ( c25 == 0 ) break ; c25 -- ; } else { if ( c50 > 0 && c25 > 0 ) { c50 -- ; c25 -- ; } else if ( c25 >= 3 ) c25 -= 3 ; else break ; } } if ( i == n ) return true ; else return false ; }
long cal_minimum_time ( long X ) { long t = 0 ; long sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; }
int countMinSwaps ( string s ) { int N = s . Length ; int one = 0 ; int zero = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) one ++ ; else zero ++ ; } if ( one > zero + 1 zero > one + 1 ) return - 1 ; if ( N % 2 == 1 ) { int num = ( N + 1 ) / 2 ; int one_even = 0 , zero_even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { if ( s [ i ] == '1' ) one_even ++ ; else zero_even ++ ; } } if ( one > zero ) return num - one_even ; else return num - zero_even ; } else { int one_odd = 0 , one_even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) { if ( i % 2 == 1 ) one_odd ++ ; else one_even ++ ; } } return Math . Min ( N / 2 - one_odd , N / 2 - one_even ) ; } }
int minDiff ( int n , int x , int [ ] A ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = Math . Min ( mn , A [ i ] ) ; mx = Math . Max ( mx , A [ i ] ) ; } return Math . Max ( 0 , mx - mn - 2 * x ) ; }
void LengthLCP ( String x , String y ) { int [ ] fr = new int [ 26 ] ; for ( int i = 0 ; i < b ; i ++ ) { fr [ y [ i ] - 97 ] += 1 ; } int c = 0 ; for ( int i = 0 ; i < a ; i ++ ) { if ( fr [ x [ i ] - 97 ] > 0 ) { c += 1 ; fr [ x [ i ] - 97 ] -= 1 ; } else break ; } Console . Write ( ( c ) ) ; }
bool checkIfOverlap ( String str ) { int len = str . Length ; int [ ] visited = new int [ len + 1 ] ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '.' ) continue ; for ( int j = Math . Max ( 0 , i - str [ i ] ) ; j <= Math . Min ( len , i + str [ i ] ) ; j ++ ) visited [ j ] ++ ; } for ( int i = 0 ; i < len ; i ++ ) { if ( visited [ i ] > 1 ) { return true ; } } return false ; }
bool isWaveArray ( int [ ] arr , int n ) { bool result = true ; if ( arr [ 1 ] > arr [ 0 ] && arr [ 1 ] > arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] <= arr [ n - 2 ] ) { result = false ; } } } else if ( arr [ 1 ] < arr [ 0 ] && arr [ 1 ] < arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] >= arr [ n - 2 ] ) { result = false ; } } } return result ; }
void printCoins ( int [ ] arr , int n ) { int oddSum = 0 ; for ( int i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; int evenSum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; int start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( int i = start ; i < n ; i += 2 ) Console . Write ( arr [ i ] + " " ) ; }
void countSubstrings ( string s ) { int ans = 0 ; int subs = 1 ; char pre = '0' ; foreach ( char i in s ) { if ( pre == i ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = i ; } Console . WriteLine ( ans ) ; }
int find ( int i ) { while ( parent [ i ] != i ) i = parent [ i ] ; return i ; }
bool isValidEdge ( int u , int v , bool [ ] inMST ) { if ( u == v ) return false ; if ( inMST [ u ] == false && inMST [ v ] == false ) return false ; else if ( inMST [ u ] == true && inMST [ v ] == true ) return false ; return true ; }
int smallestSumSubarr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ; int sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum_here = Math . Max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = Math . Max ( max_sum , sum_here ) ; } return ( - 1 ) * max_sum ; }
int [ , ] solve ( int [ , ] arr , int n ) { int [ , ] ans = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { ans [ i , j ] = arr [ j , ( i + j ) % n ] ; } } return ans ; }
int [ , ] makeArray ( int n ) { int [ , ] arr = new int [ n , n ] ; int c = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) arr [ i , j ] = c ++ ; } return arr ; }
void printLargest ( int [ ] a , int n ) { int max = - 1 ; int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( num > 0 ) { int r = num % 10 ; num = num / 10 ; if ( num == 0 ) { if ( max < r ) { max = r ; ind = i ; } } } } for ( int i = ind ; i < n ; i ++ ) Console . Write ( a [ i ] ) ; for ( int i = 0 ; i < ind ; i ++ ) Console . Write ( a [ i ] ) ; }
int findMinimumAdjacentSwaps ( int [ ] arr , int N ) { bool [ ] visited = new bool [ N + 1 ] ; int minimumSwaps = 0 ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; }
int DecreasingArray ( int [ ] a , int n ) { int sum = 0 , dif = 0 ; List < int > pq = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( pq . Count > 0 && pq [ 0 ] < a [ i ] ) { dif = a [ i ] - pq [ 0 ] ; sum += dif ; pq . RemoveAt ( 0 ) ; } pq . Add ( a [ i ] ) ; pq . Sort ( ) ; } return sum ; }
bool ifPossible ( int [ ] arr , int n ) { int [ ] cp = new int [ n ] ; Array . Copy ( arr , cp , n ) ; Array . Sort ( cp ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == cp [ i ] ) && ! ( arr [ n - 1 - i ] == cp [ i ] ) ) return false ; } return true ; }
int findMinRooms ( string [ ] slots , int n , int m ) { int [ ] counts = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ; int max = - 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }
int MinOperation ( int [ ] a , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . Min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }
int maxProductSubset ( int [ ] a , int n ) { if ( n == 1 ) { return a [ 0 ] ; } int max_neg = int . MinValue ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = Math . Max ( max_neg , a [ i ] ) ; } prod = prod * a [ i ] ; } if ( count_zero == n ) { return 0 ; } if ( count_neg % 2 == 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) { return 0 ; } prod = prod / max_neg ; } return prod ; }
List < String > preProcess ( int n ) { List < String > preProcessedCubes = new List < String > ( ) ; for ( int i = 1 ; i * i * i <= n ; i ++ ) { int iThCube = i * i * i ; String cubeString = String . Join ( "" , iThCube ) ; preProcessedCubes . Add ( cubeString ) ; } return preProcessedCubes ; }
int solve ( int [ ] a , int [ ] b , int n ) { int i ; int s = 0 ; for ( i = 0 ; i < n ; i ++ ) s += ( a [ i ] + b [ i ] ) ; if ( n == 1 ) return a [ 0 ] + b [ 0 ] ; if ( s % n != 0 ) return - 1 ; int x = s / n ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) return - 1 ; if ( i > 0 ) { a [ i ] += b [ i - 1 ] ; b [ i - 1 ] = 0 ; } if ( a [ i ] == x ) continue ; int y = a [ i ] + b [ i ] ; if ( i + 1 < n ) y += b [ i + 1 ] ; if ( y == x ) { a [ i ] = y ; b [ i ] = 0 ; continue ; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ] ; b [ i ] = 0 ; continue ; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ] ; b [ i + 1 ] = 0 ; continue ; } return - 1 ; } for ( i = 0 ; i < n ; i ++ ) if ( b [ i ] != 0 ) return - 1 ; return x ; }
void calcFiboTerms ( List < int > fiboterms , int k ) { int i = 3 , nextTerm = 0 ; fiboterms . Add ( 0 ) ; fiboterms . Add ( 1 ) ; fiboterms . Add ( 1 ) ; while ( true ) { nextTerm = fiboterms [ i - 1 ] + fiboterms [ i - 2 ] ; if ( nextTerm > k ) return ; fiboterms . Add ( nextTerm ) ; i ++ ; } }
void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) Console . Write ( "No" ) ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; Console . WriteLine ( "Yes " + days ) ; } }
void findTwoGroup ( int n ) { int sum = n * ( n + 1 ) / 2 ; int group1Sum = sum / 2 ; ArrayList group1 = new ArrayList ( ) ; ArrayList group2 = new ArrayList ( ) ; for ( int i = n ; i > 0 ; i -- ) { if ( group1Sum - i >= 0 ) { group1 . Add ( i ) ; group1Sum -= i ; } else { group2 . Add ( i ) ; } } printVector ( group1 ) ; printVector ( group2 ) ; }
int cost ( int [ ] a , int n ) { return ( n - 1 ) * a . Min ( ) ; }
int winner ( int [ ] a , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i == 1 ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }
int minproduct ( int [ ] a , int [ ] b , int n , int k ) { int diff = 0 , res = 0 ; int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = Math . Abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input > 0 unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . Min ( Math . Abs ( input_digit - code_digit ) , 10 - Math . Abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }
void findWaitingTime ( Process [ ] proc , int n , int [ ] wt ) { int [ ] rt = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) rt [ i ] = proc [ i ] . bt ; int complete = 0 , t = 0 , minm = int . MaxValue ; int shortest = 0 , finish_time ; bool check = false ; while ( complete != n ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( proc [ j ] . art <= t ) && ( rt [ j ] < minm ) && rt [ j ] > 0 ) { minm = rt [ j ] ; shortest = j ; check = true ; } } if ( check == false ) { t ++ ; continue ; } rt [ shortest ] -- ; minm = rt [ shortest ] ; if ( minm == 0 ) minm = int . MaxValue ; if ( rt [ shortest ] == 0 ) { complete ++ ; check = false ; finish_time = t + 1 ; wt [ shortest ] = finish_time - proc [ shortest ] . bt - proc [ shortest ] . art ; if ( wt [ shortest ] < 0 ) wt [ shortest ] = 0 ; } t ++ ; } }
void findTurnAroundTime ( Process [ ] proc , int n , int [ ] wt , int [ ] tat ) { for ( int i = 0 ; i < n ; i ++ ) tat [ i ] = proc [ i ] . bt + wt [ i ] ; }
int minCost ( int [ ] coin , int n , int k ) { Array . Sort ( coin ) ; int coins_needed = ( int ) Math . Ceiling ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
void preprocess ( int [ ] coin , int n ) { Array . Sort ( coin ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) coin [ i ] += coin [ i - 1 ] ; }
int minCost ( int [ ] coin , int n , int k ) { int coins_needed = ( int ) Math . Ceiling ( 1.0 * n / ( k + 1 ) ) ; return coin [ coins_needed - 1 ] ; }
void minimizeWithKSwaps ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } int temp ; for ( int j = pos ; j > i ; -- j ) { temp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = temp ; } k -= pos - i ; } }
int minimumSquare ( int a , int b ) { int result = 0 , rem = 0 ; if ( a < b ) swap ( a , b ) ; while ( b > 0 ) { result += a / b ; rem = a % b ; a = b ; b = rem ; } return result ; }
int minimumCostOfBreaking ( int [ ] X , int [ ] Y , int m , int n ) { int res = 0 ; Array . Sort < int > ( X , new Comparison < int > ( ( i1 , i2 ) => i2 . CompareTo ( i1 ) ) ) ; Array . Sort < int > ( Y , new Comparison < int > ( ( i1 , i2 ) => i2 . CompareTo ( i1 ) ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }
int maximumSum ( int [ ] arr , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = + 2147483647 ; int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
int maximizeSum ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( k != 0 && arr [ i ] < 0 ) { arr [ i ] *= - 1 ; k -- ; continue ; } break ; } if ( i == n ) i -- ; if ( k == 0 k % 2 == 0 ) { return sumArray ( arr , n ) ; } if ( i != 0 && Math . Abs ( arr [ i ] ) >= Math . Abs ( arr [ i - 1 ] ) ) { i -- ; } arr [ i ] *= - 1 ; return sumArray ( arr , n ) ; }
void findLargest ( int m , int s ) { if ( s == 0 ) { Console . Write ( m == 1 ? "Largest number is 0" : "Not possible" ) ; return ; } if ( s > 9 * m ) { Console . WriteLine ( "Not possible" ) ; return ; } int [ ] res = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( s >= 9 ) { res [ i ] = 9 ; s -= 9 ; } else { res [ i ] = s ; s = 0 ; } } Console . Write ( "Largest number is " ) ; for ( int i = 0 ; i < m ; i ++ ) Console . Write ( res [ i ] ) ; }
int getMax ( int [ ] arr , int n ) { int result = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > result ) result = arr [ i ] ; return result ; }
bool isPossible ( int time , int K , int [ ] job , int n ) { int cnt = 1 ; int curr_time = 0 ; for ( int i = 0 ; i < n ; ) { if ( curr_time + job [ i ] > time ) { curr_time = 0 ; cnt ++ ; } else { curr_time += job [ i ] ; i ++ ; } } return ( cnt <= K ) ; }
int findMinTime ( int K , int T , int [ ] job , int n ) { int end = 0 , start = 0 ; for ( int i = 0 ; i < n ; ++ i ) end += job [ i ] ; int ans = end ; int job_max = getMax ( job , n ) ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid >= job_max && isPossible ( mid , K , job , n ) ) { ans = Math . Min ( ans , mid ) ; end = mid - 1 ; } else start = mid + 1 ; } return ( ans * T ) ; }
void findMin ( int V ) { List < int > ans = new List < int > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . Add ( deno [ i ] ) ; } } for ( int i = 0 ; i < ans . Count ; i ++ ) { Console . Write ( " " + ans [ i ] ) ; } }
int maxDiffSum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int maxVal = arr [ i ] , minVal = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { minVal = Math . Min ( minVal , arr [ j ] ) ; maxVal = Math . Max ( maxVal , arr [ j ] ) ; if ( j - 1 >= 0 ) dp [ i ] = Math . Max ( dp [ i ] , maxVal - minVal + dp [ j - 1 ] ) ; else dp [ i ] = Math . Max ( dp [ i ] , maxVal - minVal ) ; } } return dp [ n - 1 ] ; }
long modPow ( long x , long y ) { long r = 1 , a = x ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) { r = ( r * a ) % MOD ; } a = ( a * a ) % MOD ; y /= 2 ; } return r ; }
long modInverse ( long x ) { return modPow ( x , MOD - 2 ) ; }
long modDivision ( long p , long q ) { return ( p * modInverse ( q ) ) % MOD ; }
long C ( long n , int k ) { if ( k > n ) { return 0 ; } long p = 1 , q = 1 ; for ( int i = 1 ; i <= k ; i ++ ) { q = ( q * i ) % MOD ; p = ( p * ( n - i + 1 ) ) % MOD ; } return modDivision ( p , q ) ; }
long countArrays ( int N , int K ) { long res = 1 ; for ( int p = 2 ; p <= K / p ; p ++ ) { int c = 0 ; while ( K % p == 0 ) { K /= p ; c ++ ; } res = ( res * C ( N - 1 + c , c ) ) % MOD ; } if ( N > 1 ) { res = ( res * N ) % MOD ; } return res ; }
int minSessions ( int [ ] codeTime , int [ , ] dp , int ones , int n , int mask , int currTime , int WorkingSessionTime ) { if ( currTime > WorkingSessionTime ) return Int32 . MaxValue ; if ( mask == ones ) return 1 ; if ( dp [ mask , currTime ] != - 1 ) return dp [ mask , currTime ] ; int ans = Int32 . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( mask & ( 1 << i ) ) == 0 ) { int inc = minSessions ( codeTime , dp , ones , n , mask | ( 1 << i ) , currTime + codeTime [ i ] , WorkingSessionTime ) ; int inc_next = 1 + minSessions ( codeTime , dp , ones , n , mask | ( 1 << i ) , codeTime [ i ] , WorkingSessionTime ) ; ans = Math . Min ( ans , Math . Min ( inc , inc_next ) ) ; } } return dp [ mask , currTime ] = ans ; }
int solve ( int [ ] codeTime , int n , int WorkingSessionTime ) { int [ , ] dp = new int [ ( 1 << 14 ) , 15 ] ; for ( int i = 0 ; i < 1 << 14 ; i ++ ) { for ( int j = 0 ; j < 15 ; j ++ ) { dp [ i , j ] = - 1 ; } } int ones = ( 1 << n ) - 1 ; int ans = minSessions ( codeTime , dp , ones , n , 0 , 0 , WorkingSessionTime ) ; if ( WorkingSessionTime < 6 ) { if ( ans % 2 == 0 ) ans = ans / 2 ; else ans = ( ans / 2 ) + 1 ; } return ans ; }
int solve ( int len , int gap ) { if ( dp [ len , gap ] != - 1 ) { return dp [ len , gap ] ; } if ( len == 0 gap == 0 ) { return 1 ; } if ( gap < 0 ) { return 0 ; } int ans = 0 ; for ( int i = 0 ; i <= gap ; i ++ ) { ans += solve ( len - 1 , gap - i ) ; } return dp [ len , gap ] = ans ; }
int countValidStrings ( string S ) { for ( int i = 0 ; i < MAXN ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { dp [ i , j ] = - 1 ; } } int N = S . Length ; int L = 1 , R = 9 ; int cnt = 0 ; int ans = 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] != '?' ) { R = ( int ) S [ i ] - 48 ; ans *= solve ( cnt , R - L ) ; L = R ; R = 9 ; cnt = 0 ; } else { cnt ++ ; } } ans *= solve ( cnt , R - L ) ; return ans ; }
int recBananaCnt ( int A , int B , int C ) { if ( B <= A ) { return 0 ; } if ( B <= C ) { return B - A ; } if ( A == 0 ) { return B ; } if ( dp [ A , B ] != - 1 ) { return dp [ A , B ] ; } int maxCount = Int32 . MinValue ; int tripCount = B % C == 0 ? ( ( 2 * B ) / C ) - 1 : ( ( 2 * B ) / C ) + 1 ; for ( int i = 1 ; i <= A ; i ++ ) { int curCount = recBananaCnt ( A - i , B - tripCount * i , C ) ; if ( curCount > maxCount ) { maxCount = curCount ; dp [ A , B ] = maxCount ; } } return maxCount ; }
int maxBananaCnt ( int A , int B , int C ) { for ( int i = 0 ; i < 1001 ; i ++ ) for ( int j = 0 ; j < 3001 ; j ++ ) dp [ i , j ] = - 1 ; return recBananaCnt ( A , B , C ) ; }
int combinationsPossible ( int N , int idx , int prev , int val , int K , int [ , , ] dp ) { if ( val > K ) { return 0 ; } if ( dp [ val , idx , prev ] != - 1 ) { return dp [ val , idx , prev ] ; } if ( idx == N - 1 ) { if ( val == K ) { return 1 ; } return 0 ; } int ans = 0 ; if ( prev == 1 ) { ans += combinationsPossible ( N , idx + 1 , 1 , val + 1 , K , dp ) ; ans += combinationsPossible ( N , idx + 1 , 0 , val , K , dp ) ; } else { ans += combinationsPossible ( N , idx + 1 , 1 , val , K , dp ) ; ans += combinationsPossible ( N , idx + 1 , 0 , val , K , dp ) ; } return dp [ val , idx , prev ] = ans ; }
int countArray ( int [ ] arr , int N , int M ) { int [ , ] dp = new int [ N , M + 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M + 2 ; j ++ ) { dp [ i , j ] = 0 ; } } if ( arr [ 0 ] == - 1 ) { for ( int j = 1 ; j <= M ; j ++ ) { dp [ 0 , j ] = 1 ; } } else { dp [ 0 , arr [ 0 ] ] = 1 ; } for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != - 1 ) { int j = arr [ i ] ; dp [ i , j ] += dp [ i - 1 , j - 1 ] + dp [ i - 1 , j ] + dp [ i - 1 , j + 1 ] ; } if ( arr [ i ] == - 1 ) { for ( int j = 1 ; j <= M ; j ++ ) { dp [ i , j ] += dp [ i - 1 , j - 1 ] + dp [ i - 1 , j ] + dp [ i - 1 , j + 1 ] ; } } } int arrCount = 0 ; for ( int j = 1 ; j <= M ; j ++ ) { arrCount += dp [ N - 1 , j ] ; } return arrCount ; }
int minChangeInLane ( int [ ] barrier , int n ) { int [ ] dp = { 1 , 0 , 1 } ; for ( int j = 0 ; j < n ; j ++ ) { int val = barrier [ j ] ; if ( val > 0 ) { dp [ val - 1 ] = ( int ) 1e6 ; } for ( int i = 0 ; i < 3 ; i ++ ) { if ( val != i + 1 ) { dp [ i ] = Math . Min ( dp [ i ] , Math . Min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) ; } } } return Math . Min ( dp [ 0 ] , Math . Min ( dp [ 1 ] , dp [ 2 ] ) ) ; }
int calculate ( int position , int used , int unused , int P , int M , int [ , , ] dp ) { if ( position == P ) { return unused == 0 ? 1 : 0 ; } if ( dp [ position , used , unused ] != - 1 ) return dp [ position , used , unused ] ; int result = 0 ; if ( unused > 0 ) { result += calculate ( position + 1 , used + 1 , unused - 1 , P , M , dp ) * unused ; } if ( used > M ) { result += calculate ( position + 1 , used , unused , P , M , dp ) * ( used - M ) ; } return dp [ position , used , unused ] = result ; }
int solve ( int N , int P , int M ) { int [ , , ] dp = new int [ 101 , 101 , 101 ] ; for ( int i = 0 ; i < 101 ; i ++ ) { for ( int j = 0 ; j < 101 ; j ++ ) for ( int k = 0 ; k < 101 ; k ++ ) dp [ i , j , k ] = - 1 ; } return calculate ( 0 , 0 , N , P , M , dp ) ; }
int maxMergingScore ( int [ ] A , int N ) { int [ , ] dp = new int [ 101 , 101 ] ; for ( int i = 0 ; i < 101 ; i ++ ) { { for ( int j = 0 ; j < 101 ; j ++ ) dp [ i , j ] = 0 ; } } for ( int len = 1 ; len < N ; ++ len ) { for ( int i = 0 ; i + len < N ; ++ i ) { int j = i + len ; dp [ i , j ] = 0 ; for ( int k = i + 1 ; k < j ; ++ k ) { dp [ i , j ] = Math . Max ( dp [ i , j ] , dp [ i , k ] + dp [ k , j ] + A [ i ] * A [ j ] ) ; } } } return dp [ 0 , N - 1 ] ; }
int getMin ( int x , int y , int z ) { return Math . Min ( Math . Min ( x , y ) , z ) ; }
int editDistance ( string str1 , string str2 , int m , int n ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i , j ] = j ; else if ( j == 0 ) dp [ i , j ] = i ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i , j ] = dp [ i - 1 , j - 1 ] ; else { dp [ i , j ] = 1 + getMin ( dp [ i , j - 1 ] , dp [ i - 1 , j ] , dp [ i - 1 , j - 1 ] ) ; } } } return dp [ m , n ] ; }
void minimumSteps ( string S , int N ) { int ans = int . MaxValue ; for ( int i = 1 ; i < N ; i ++ ) { string S1 = S . Substring ( 0 , i ) ; string S2 = S . Substring ( i ) ; int count = editDistance ( S1 , S2 , S1 . Length , S2 . Length ) ; ans = Math . Min ( ans , count ) ; } Console . Write ( ans ) ; }
int countOfWays ( int [ ] arr , int N ) { int [ ] pre = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { pre [ i + 1 ] = pre [ i ] + arr [ i ] ; } int [ , ] dp = new int [ N + 2 , N + 2 ] ; dp [ 1 , 0 ] ++ ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N ; j >= 1 ; j -- ) { dp [ j + 1 , pre [ i + 1 ] % ( j + 1 ) ] += dp [ j , pre [ i + 1 ] % j ] ; if ( i == N - 1 ) { ans += dp [ j , pre [ i + 1 ] % j ] ; } } } return ans ; }
void minimumDifference ( int [ ] arr , Query [ ] q , int N , int m ) { int [ ] diff = new int [ N ] ; for ( int i = 0 ; i < N - 1 ; i ++ ) diff [ i ] = Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ; minDifference ( diff , N - 1 , q , m ) ; }
int LongestOddEvenSubarray ( int [ ] A , int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 1 ; int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp [ i ] = dp [ i - 1 ] + 1 ; } else dp [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) ans = Math . Max ( ans , dp [ i ] ) ; return ans ; }
int minimumOperations ( int N ) { int [ ] dp = new int [ N + 1 ] ; int i ; for ( i = 0 ; i <= N ; i ++ ) { dp [ i ] = ( int ) 1e9 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { if ( dp [ i ] == ( int ) 1e9 ) continue ; if ( i * 5 <= N ) { dp [ i * 5 ] = Math . Min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= N ) { dp [ i + 3 ] = Math . Min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } if ( dp [ N ] == 1e9 ) return - 1 ; return dp [ N ] ; }
int numTilings ( int N ) { if ( N < 3 ) { return N ; } int [ , ] dp = new int [ N + 1 , 3 ] ; dp [ 0 , 0 ] = dp [ 1 , 0 ] = 1 ; dp [ 1 , 1 ] = dp [ 1 , 2 ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i , 0 ] = ( dp [ i - 1 , 0 ] + dp [ i - 2 , 0 ] + dp [ i - 2 , 1 ] + dp [ i - 2 , 2 ] ) % MOD ; dp [ i , 1 ] = ( dp [ i - 1 , 0 ] + dp [ i - 1 , 2 ] ) % MOD ; dp [ i , 2 ] = ( dp [ i - 1 , 0 ] + dp [ i - 1 , 1 ] ) % MOD ; } return dp [ N , 0 ] ; }
void SieveOfEratosthenes ( int n ) { prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } }
int countOfNumbers ( int index , int sum , int N ) { if ( index == N + 1 ) { if ( prime [ sum ] == true ) { return 1 ; } return 0 ; } int val = dp [ index , sum ] ; if ( val != - 1 ) { return val ; } val = 0 ; if ( index == 1 ) { for ( int digit = ( N == 1 ? 0 : 1 ) ; digit <= 9 ; ++ digit ) { val += countOfNumbers ( index + 1 , sum + digit , N ) ; } } else { for ( int digit = 0 ; digit <= 9 ; ++ digit ) { val += countOfNumbers ( index + 1 , sum + digit , N ) ; } } return val ; }
int countStrings ( int N ) { if ( N == 1 ) return 0 ; if ( dp . ContainsKey ( N ) ) return dp [ N ] ; int ret = 0 ; for ( int div = 1 ; div <= Math . Sqrt ( N ) ; div ++ ) { if ( N % div == 0 ) { ret += ( 1 << div ) - countStrings ( div ) ; int div2 = N / div ; if ( div2 != div && div != 1 ) ret += ( 1 << div2 ) - countStrings ( div2 ) ; } } dp [ N ] = ret ; return ret ; }
void countOfNumbers ( int N ) { int ans = 1 ; for ( int index = 1 ; index <= N ; ++ index ) { int choices = 0 ; for ( int digit = 1 ; digit <= 9 ; ++ digit ) { if ( index % digit == 0 ) { ++ choices ; } } ans = ( ans * choices ) % mod ; } Console . Write ( ans ) ; }
int MaxProfit ( int [ ] arr , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ; buy = Math . Max ( buy , sell - arr [ i ] ) ; sell = Math . Max ( sell , temp + arr [ i ] - transactionFee ) ; } return Math . Max ( sell , buy ) ; }
int dfs ( int [ ] arr , int left , int K ) { int q = 0 ; if ( left == 0 ) { for ( int i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; q = Math . Max ( q , 1 + dfs ( arr , K - i , K ) ) ; arr [ i ] ++ ; } } } else { for ( int i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; int nleft = ( i <= left ? left - i : K + left - i ) ; q = Math . Max ( q , dfs ( arr , nleft , K ) ) ; arr [ i ] ++ ; } } } return q ; }
int dfs ( int [ ] V , int left , int K ) { int q = 0 ; String key = string . Join ( "," , V ) ; key += left . ToString ( ) ; if ( memo . ContainsKey ( key ) ) return memo [ key ] ; else if ( left == 0 ) { for ( int i = 1 ; i < K ; ++ i ) if ( V [ i ] > 0 ) { V [ i ] -- ; q = Math . Max ( q , 1 + dfs ( V , K - i , K ) ) ; V [ i ] ++ ; } } else { for ( int i = 1 ; i < K ; ++ i ) { if ( V [ i ] > 0 ) { V [ i ] -- ; int nleft = i <= left ? left - i : K + left - i ; q = Math . Max ( q , dfs ( V , nleft , K ) ) ; V [ i ] ++ ; } } } if ( memo . ContainsKey ( key ) ) memo [ key ] = q ; else memo . Add ( key , q ) ; return q ; }
int maxGroups ( int K , int [ ] arr ) { int [ ] V = new int [ K ] ; foreach ( int x in arr ) V [ x % K ] ++ ; memo = new Dictionary < String , int > ( ) ; int ans = V [ 0 ] + dfs ( V , 0 , K ) ; return ans ; }
int countMinSteps ( string A , string B , int N ) { int [ ] dp = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( A [ i - 1 ] == B [ i - 1 ] ) { dp [ i ] = dp [ i - 1 ] ; } else { dp [ i ] = dp [ i - 1 ] + 1 ; } if ( i >= 2 && A [ i - 2 ] == B [ i - 1 ] && A [ i - 1 ] == B [ i - 2 ] ) { dp [ i ] = Math . Min ( dp [ i ] , dp [ i - 2 ] + 1 ) ; } } return dp [ N ] ; }
void findMaxJumps ( int [ ] arr , int N ) { int [ ] dp = new int [ N ] ; int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { dp [ i ] = arr [ i ] ; int j = i + arr [ i ] ; if ( j < N ) { dp [ i ] = dp [ i ] + dp [ j ] ; } ans = Math . Max ( ans , dp [ i ] ) ; } Console . Write ( ans ) ; }
void countNDigitNumber ( int N ) { for ( int i = 0 ; i < 50 ; i ++ ) { for ( int j = 0 ; j < 1 << 10 ; j ++ ) { for ( int k = 0 ; k < 2 ; k ++ ) { dp [ i , j , k ] = - 1 ; } } } Console . Write ( countOfNumbers ( 1 , 0 , 0 , N ) ) ; }
string getMaximum ( string S , string T ) { if ( S . IndexOf ( "0" ) > - 1 ) return T ; if ( T . IndexOf ( "0" ) > - 1 ) return S ; return ( S . Length > T . Length ? S : T ) ; }
string recursion ( int [ ] arr , int idx , int N , int K , List < List < string > > dp ) { if ( K == 0 ) { return "" ; } if ( K < 0 idx == N ) { return "0" ; } if ( dp [ idx ] [ K ] != "-1" ) return dp [ idx ] [ K ] ; string include = ( idx + 1 ) . ToString ( ) + recursion ( arr , 0 , N , K - arr [ idx ] , dp ) ; string exclude = recursion ( arr , idx + 1 , N , K , dp ) ; return dp [ idx ] [ K ] = getMaximum ( include , exclude ) ; }
void longestSubsequence ( int [ ] arr , int N ) { int [ , ] dp = new int [ N , N + 1 ] ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N + 1 ; ++ j ) { dp [ i , j ] = - 1 ; } } for ( int i = 0 ; i < N ; ++ i ) { dp [ i , 0 ] = 0 ; } dp [ 0 , 1 ] = ( arr [ 0 ] >= 0 ? arr [ 0 ] : - 1 ) ; for ( int i = 1 ; i < N ; ++ i ) { for ( int j = 1 ; j <= ( i + 1 ) ; ++ j ) { if ( dp [ i - 1 , j ] != - 1 ) { dp [ i , j ] = Math . Max ( dp [ i , j ] , dp [ i - 1 , j ] ) ; } if ( dp [ i - 1 , j - 1 ] >= 0 && dp [ i - 1 , j - 1 ] + arr [ i ] >= 0 ) { dp [ i , j ] = Math . Max ( dp [ i , j ] , dp [ i - 1 , j - 1 ] + arr [ i ] ) ; } } } int ans = 0 ; for ( int j = 0 ; j <= N ; ++ j ) { if ( dp [ N - 1 , j ] >= 0 ) { ans = j ; } } Console . Write ( ans ) ; }
int Count ( int N , int L , int R ) { int [ , ] dp = new int [ N , R - L + 1 ] ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i , 0 ] = 1 ; } for ( int i = 1 ; i < dp . GetLength ( 1 ) ; i ++ ) { dp [ 0 , i ] = dp [ 0 , i - 1 ] + 1 ; } ans = dp [ 0 , R - L ] ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < dp . GetLength ( 1 ) ; j ++ ) { dp [ i , j ] = dp [ i - 1 , j ] + dp [ i , j - 1 ] ; } ans += dp [ i , R - L ] ; } return ans ; }
int largestCommonSubarray ( int [ , ] arr , int n , int m ) { int [ , ] dp = new int [ n , m + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { dp [ i , arr [ i , j ] ] = j ; } } int ans = 1 ; int len = 1 ; for ( int i = 1 ; i < m ; i ++ ) { bool check = true ; for ( int j = 1 ; j < n ; j ++ ) { if ( dp [ j , arr [ 0 , i - 1 ] ] + 1 != dp [ j , arr [ 0 , i ] ] ) { check = false ; break ; } } if ( check == true ) { len ++ ; ans = Math . Max ( ans , len ) ; } else { len = 1 ; } } return ans ; }
int countOfNumbers ( int digit , int prev1 , int prev2 , int n ) { if ( digit == n + 1 ) { return 1 ; } int val = dp [ digit , prev1 , prev2 ] ; if ( val != - 1 ) { return val ; } val = 0 ; if ( digit == 1 ) { for ( int i = ( n == 1 ? 0 : 1 ) ; i <= 9 ; ++ i ) { val += countOfNumbers ( digit + 1 , i , prev1 , n ) ; } } else if ( digit == 2 ) { for ( int i = 0 ; i <= 9 ; ++ i ) { val += countOfNumbers ( digit + 1 , i , prev1 , n ) ; } } else { int mean = prev1 ; int current = ( 2 * mean ) - prev2 ; if ( current >= 0 && current <= 9 ) val += countOfNumbers ( digit + 1 , current , prev1 , n ) ; if ( ( current + 1 ) >= 0 && ( current + 1 ) <= 9 ) val += countOfNumbers ( digit + 1 , current + 1 , prev1 , n ) ; } return val ; }
int countOfNumbers ( int digit , int prev , int n ) { if ( digit == n + 1 ) { return 1 ; } int val = dp [ digit , prev ] ; if ( val != - 1 ) { return val ; } val = 0 ; if ( digit == 1 ) { for ( int i = ( n == 1 ? 0 : 1 ) ; i <= 9 ; ++ i ) { val += countOfNumbers ( digit + 1 , i , n ) ; } } else { for ( int i = 0 ; i <= 9 ; ++ i ) { if ( ( i & prev ) == 0 ) { val += countOfNumbers ( digit + 1 , i , n ) ; } } } return val ; }
int totalSubarrays ( int [ ] arr , int n , int k ) { int ans = 0 , i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } int count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } ans += ( ( count * ( count + 1 ) ) / 2 ) ; } return ans ; }
int countSubarrays ( int [ ] arr , int n , int k ) { int count1 = totalSubarrays ( arr , n , k - 1 ) ; int count2 = totalSubarrays ( arr , n , k ) ; int ans = count2 - count1 ; return ans ; }
int MaximumSum ( int [ ] a , int [ ] b , int n ) { int [ , ] dp = new int [ n , 2 ] ; dp [ 0 , 0 ] = a [ 0 ] ; dp [ 0 , 1 ] = b [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i , 0 ] = Math . Max ( dp [ i - 1 , 0 ] , dp [ i - 1 , 1 ] ) + a [ i ] ; dp [ i , 1 ] = Math . Max ( dp [ i - 1 , 0 ] , dp [ i - 1 , 1 ] ) ; if ( i - 2 >= 0 ) { dp [ i , 1 ] = Math . Max ( dp [ i , 1 ] , Math . Max ( dp [ i - 2 , 0 ] , dp [ i - 2 , 1 ] ) + b [ i ] ) ; } else { dp [ i , 1 ] = Math . Max ( dp [ i , 1 ] , b [ i ] ) ; } } return Math . Max ( dp [ n - 1 , 0 ] , dp [ n - 1 , 1 ] ) ; }
int numberOfArrays ( int n , int l ) { int [ , ] dp = new int [ l + 1 , n + 1 ] ; for ( int i = 0 ; i < l + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) dp [ i , j ] = 0 ; } dp [ 0 , 1 ] = 1 ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { for ( int k = j ; k <= n ; k += j ) { dp [ i + 1 , k ] += dp [ i , j ] ; } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans += dp [ l , i ] ; } return ans ; }
int waysOfDecoding ( String s ) { long [ ] dp = new long [ s . Length + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == '*' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( s [ i ] == '*' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '*' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != '0' ? dp [ i ] : 0 ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '*' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= '6' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return ( int ) dp [ s . Length ] ; }
int KvisibleFromLeft ( int N , int K ) { if ( dp [ N , K ] != - 1 ) return dp [ N , K ] ; if ( N == K ) return dp [ N , K ] = 1 ; if ( K == 1 ) { int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) ans *= i ; return dp [ N , K ] = ans ; } return dp [ N , K ] = KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; }
int minimumDeletions ( int [ ] A , int N ) { int ans = Int32 . MaxValue ; for ( int i = 1 ; i < ( 1 << N ) ; i ++ ) { List < int > temp = new List < int > ( ) ; for ( int j = 0 ; j < N ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) { temp . Add ( A [ j ] ) ; } } int flag = 0 ; for ( int j = 1 ; j < temp . Count ; j ++ ) if ( temp [ j ] < temp [ j - 1 ] ) flag = 1 ; for ( int j = 1 ; j < temp . Count - 1 ; j ++ ) if ( temp [ j ] - temp [ j - 1 ] > temp [ j + 1 ] - temp [ j ] ) flag = 1 ; if ( flag == 0 ) { ans = Math . Min ( ans , N - temp . Count ) ; } } return ans ; }
int kvowelwords ( int N , int K ) { int i , j ; int MOD = 1000000007 ; int [ , ] dp = new int [ N + 1 , K + 1 ] ; int sum = 1 ; for ( i = 1 ; i <= N ; i ++ ) { dp [ i , 0 ] = sum * 21 ; dp [ i , 0 ] %= MOD ; sum = dp [ i , 0 ] ; for ( j = 1 ; j <= K ; j ++ ) { if ( j > i ) dp [ i , j ] = 0 ; else if ( j == i ) { dp [ i , j ] = power ( 5 , i , MOD ) ; } else { dp [ i , j ] = dp [ i - 1 , j - 1 ] * 5 ; } dp [ i , j ] %= MOD ; sum += dp [ i , j ] ; sum %= MOD ; } } return sum ; }
int maximumSum ( List < int > A , int N , int K , int D ) { int ans = 0 ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) { int sum = 0 ; int c = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( ( i >> j & 1 ) != 0 ) { sum += A [ j ] ; c ++ ; } } if ( sum % D == 0 && c <= K ) ans = Math . Max ( ans , sum ) ; } return ans ; }
int maxSumWO3Consec ( int [ ] A , int N ) { if ( N == 1 ) return A [ 0 ] ; if ( N == 2 ) return A [ 0 ] + A [ 1 ] ; int third = A [ 0 ] ; int second = third + A [ 1 ] ; int first = Math . Max ( second , A [ 1 ] + A [ 2 ] ) ; int sum = Math . Max ( Math . Max ( third , second ) , first ) ; for ( int i = 3 ; i < N ; i ++ ) { sum = Math . Max ( Math . Max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) ; third = second ; second = first ; first = sum ; } return sum ; }
string longestSubsequence ( string X , string Y ) { int i , j ; int n = X . Length ; int m = Y . Length ; int [ , ] mat = new int [ n + 1 , m + 1 ] ; for ( i = 0 ; i < n + 1 ; i ++ ) { for ( j = 0 ; j < m + 1 ; j ++ ) { if ( i == 0 j == 0 ) mat [ i , j ] = 0 ; } } for ( i = 1 ; i < n + 1 ; i ++ ) { for ( j = 1 ; j < m + 1 ; j ++ ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { mat [ i , j ] = 1 + mat [ i - 1 , j - 1 ] ; } else { mat [ i , j ] = mat [ i - 1 , j ] ; } } } int len = 0 , col = 0 ; for ( i = 0 ; i < m + 1 ; i ++ ) { if ( mat [ n , i ] > len ) { len = mat [ n , i ] ; col = i ; } } string res = "" ; i = n ; j = col ; while ( len > 0 ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { res = X [ i - 1 ] + res ; i -- ; j -- ; len -- ; } else { i -- ; } } return res ; }
void calculateStart ( int n , int m ) { for ( int i = 1 ; i < m ; ++ i ) { start [ 0 , i ] += start [ 0 , i - 1 ] ; } for ( int i = 1 ; i < n ; ++ i ) { start [ i , 0 ] += start [ i - 1 , 0 ] ; } for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) { start [ i , j ] += Math . Max ( start [ i - 1 , j ] , start [ i , j - 1 ] ) ; } } }
void calculateEnd ( int n , int m ) { for ( int i = n - 2 ; i >= 0 ; -- i ) { ending [ i , m - 1 ] += ending [ i + 1 , m - 1 ] ; } for ( int i = m - 2 ; i >= 0 ; -- i ) { ending [ n - 1 , i ] += ending [ n - 1 , i + 1 ] ; } for ( int i = n - 2 ; i >= 0 ; -- i ) { for ( int j = m - 2 ; j >= 0 ; -- j ) { ending [ i , j ] += Math . Max ( ending [ i + 1 , j ] , ending [ i , j + 1 ] ) ; } } }
void maximumPathSum ( int [ , ] mat , int n , int m , int q , int [ , ] coordinates ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { start [ i , j ] = mat [ i , j ] ; ending [ i , j ] = mat [ i , j ] ; } } calculateStart ( n , m ) ; calculateEnd ( n , m ) ; int ans = 0 ; for ( int i = 0 ; i < q ; ++ i ) { int X = coordinates [ i , 0 ] - 1 ; int Y = coordinates [ i , 1 ] - 1 ; ans = Math . Max ( ans , start [ X , Y ] + ending [ X , Y ] - mat [ X , Y ] ) ; } Console . Write ( ans ) ; }
int countAlternatingSubstrings ( string S , int N ) { int [ , ] dp = new int [ 2 , N ] ; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i , j ] = 0 ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 ) { if ( S [ i ] == '1' ) dp [ 1 , i ] = 1 ; else dp [ 0 , i ] = 1 ; } else { if ( S [ i ] == '0' ) dp [ 0 , i ] = 1 + dp [ 1 , i + 1 ] ; else dp [ 1 , i ] = 1 + dp [ 0 , i + 1 ] ; } } int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { ans += Math . Max ( dp [ 0 , i ] , dp [ 1 , i ] ) ; } return ans ; }
int countSubset ( int [ ] arr , int n , int diff ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum += diff ; sum = sum / 2 ; int [ , ] t = new int [ n + 1 , sum + 1 ] ; for ( int j = 0 ; j <= sum ; j ++ ) t [ 0 , j ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) t [ i , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i , j ] = t [ i - 1 , j ] ; else { t [ i , j ] = t [ i - 1 , j ] + t [ i - 1 , j - arr [ i - 1 ] ] ; } } } return t [ n , sum ] ; }
int maximizeAnd ( int i , int mask , int [ ] A , int [ ] B , int N , int [ , ] dp ) { if ( i == N ) return 0 ; if ( dp [ i , mask ] != - 1 ) return dp [ i , mask ] ; for ( int j = 0 ; j < N ; ++ j ) { if ( ( mask & ( 1 << j ) ) == 0 ) { dp [ i , mask ] = Math . Max ( dp [ i , mask ] , ( A [ i ] & B [ j ] ) + maximizeAnd ( i + 1 , mask | ( 1 << j ) , A , B , N , dp ) ) ; } } return dp [ i , mask ] ; }
int maximizeAndUtil ( int [ ] A , int [ ] B , int N ) { int [ , ] dp = new int [ N , ( 1 << N ) + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < ( 1 << N ) + 1 ; j ++ ) { dp [ i , j ] = - 1 ; } } return maximizeAnd ( 0 , 0 , A , B , N , dp ) ; }
int countOfNumbers ( int digit , int prev1 , int prev2 , int N ) { if ( digit == N + 1 ) return 1 ; if ( dp [ digit , prev1 , prev2 ] != - 1 ) return dp [ digit , prev1 , prev2 ] ; dp [ digit , prev1 , prev2 ] = 0 ; if ( digit == 1 ) { for ( int j = ( N == 1 ? 0 : 1 ) ; j <= 9 ; ++ j ) { dp [ digit , prev1 , prev2 ] += countOfNumbers ( digit + 1 , j , prev1 , N ) ; } } else if ( digit == 2 ) { for ( int j = 0 ; j <= 9 ; ++ j ) { dp [ digit , prev1 , prev2 ] += countOfNumbers ( digit + 1 , j , prev1 , N ) ; } } else { for ( int j = 0 ; j <= Math . Abs ( prev1 - prev2 ) ; ++ j ) { dp [ digit , prev1 , prev2 ] += countOfNumbers ( digit + 1 , j , prev1 , N ) ; } } return dp [ digit , prev1 , prev2 ] ; }
void findNthNum ( int N ) { int a = 0 , b , left ; int right , mid ; int t ; left = 1 ; right = N ; while ( left <= right ) { mid = left + ( right - left ) / 2 ; t = ( mid * ( mid + 1 ) ) / 2 ; if ( t < N ) { left = mid + 1 ; } else if ( t == N ) { a = mid ; break ; } else { a = mid ; right = mid - 1 ; } } t = a - 1 ; b = N - ( t * ( t + 1 ) ) / 2 - 1 ; Console . Write ( ( 1 << a ) + ( 1 << b ) ) ; }
void longestSubWithMaxSum ( int [ ] arr , int N ) { int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( Max < arr [ i ] ) Max = arr [ i ] ; } if ( Max < 0 ) { Console . Write ( Max ) ; return ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 0 ) { Console . Write ( arr [ i ] + " " ) ; } } }
void maxSumUtil ( int [ ] arr , int n ) { int [ , ] dp = new int [ 100 , 3 ] ; for ( int i = 0 ; i < 100 ; ++ i ) { for ( int j = 0 ; j < 3 ; ++ j ) { dp [ i , j ] = - 1 ; } } Console . Write ( maxSum ( arr , 0 , n , 2 , false , dp ) ) ; }
void maximumSum ( int [ ] arr , int n ) { long [ ] preSum = new long [ n ] ; long sum = 0 ; long maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = Math . Max ( arr [ i ] , sum + arr [ i ] ) ; maxSum = Math . Max ( maxSum , sum ) ; preSum [ i ] = maxSum ; } sum = 0 ; maxSum = 0 ; long [ ] postSum = new long [ n + 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum = Math . Max ( arr [ i ] , sum + arr [ i ] ) ; maxSum = Math . Max ( maxSum , sum ) ; postSum [ i ] = maxSum ; } long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . Max ( ans , preSum [ i ] + postSum [ i + 1 ] ) ; } Console . WriteLine ( ans ) ; }
int NumberOfways ( int N , int K ) { int [ ] dp = new int [ ( N + 1 ) ] ; dp [ 0 ] = 1 ; for ( int row = 1 ; row < K + 1 ; row ++ ) { for ( int col = 1 ; col < N + 1 ; col ++ ) { if ( col >= row ) dp [ col ] = dp [ col ] + dp [ col - row ] ; } } return ( dp [ N ] ) ; }
void findAPSequence ( int [ ] arr , int N , int [ , ] Q , int M ) { int [ ] dp = new int [ N + 5 ] ; for ( int i = 0 ; i + 1 < N ; ) { int j = i + 1 ; while ( j + 1 < N && arr [ j + 1 ] - arr [ j ] == arr [ i + 1 ] - arr [ i ] ) j ++ ; for ( int k = i ; k < j ; k ++ ) { dp [ k ] = j - k ; } i = j ; } for ( int i = 0 ; i < M ; i ++ ) { if ( dp [ Q [ i , 0 ] ] >= Q [ i , 1 ] - Q [ i , 0 ] ) { Console . WriteLine ( "Yes" ) ; } else { Console . WriteLine ( "No" ) ; } } }
bool isUnique ( string s ) { HashSet < char > set = new HashSet < char > ( ) ; foreach ( char c in s ) set . Add ( c ) ; return set . Count == 1 ; }
int maxScore ( string s , int [ ] a ) { int n = s . Length ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; int mx = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { string sub = s . Substring ( i , j + 1 - i ) ; if ( isUnique ( sub ) ) mx = Math . Max ( mx , a [ sub . Length - 1 ] + maxScore ( s . Substring ( 0 , i ) + s . Substring ( j + 1 ) , a ) ) ; } } return mx ; }
int numberOfUniqueOutcomes ( int N , int S ) { if ( S < N ) return 0 ; if ( N == 1 N == S ) return 1 ; return ( numberOfUniqueOutcomes ( N - 1 , S - 1 ) + numberOfUniqueOutcomes ( N - 1 , S - 2 ) ) ; }
int numberOfUniqueOutcomes ( int n , int s ) { if ( s < n ) ans [ n , s ] = 0 ; else if ( n == 1 n == s ) ans [ n , s ] = 1 ; else if ( ans [ n , s ] == 0 ) { ans [ n , s ] = numberOfUniqueOutcomes ( n - 1 , s - 1 ) + numberOfUniqueOutcomes ( n - 1 , s - 2 ) ; } return ans [ n , s ] ; }
int MinimumLength ( int [ ] A , int N , int K ) { Array . Sort ( A ) ; int [ ] suffix = new int [ N + 1 ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) suffix [ i ] = suffix [ i + 1 ] + A [ i ] ; int [ , ] dp = new int [ N + 1 , K + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= K ; j ++ ) dp [ i , j ] = MAX ; dp [ N , 0 ] = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = K ; j >= 0 ; j -- ) { if ( j <= A [ i ] ) { dp [ i , j ] = A [ i ] ; continue ; } if ( dp [ i + 1 , j - A [ i ] ] == MAX ) dp [ i , j ] = MAX ; else dp [ i , j ] = Math . Min ( dp [ i + 1 , j ] , dp [ i + 1 , j - A [ i ] ] + A [ i ] ) ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( suffix [ i ] - dp [ i , K ] >= K ) { return N - i ; } } return - 1 ; }
void countXOR ( int [ ] arr , int [ ] comb , int start , int end , int index , int r ) { if ( index == r ) { int new_xor = 0 ; for ( int j = 0 ; j < r ; j ++ ) { new_xor ^= comb [ j ] ; } s . Add ( new_xor ) ; return ; } for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { comb [ index ] = arr [ i ] ; countXOR ( arr , comb , i + 1 , end , index + 1 , r ) ; } }
void maxSizeSet ( int [ ] arr , int N ) { for ( int r = 1 ; r <= N ; r ++ ) { int [ ] comb = new int [ r + 1 ] ; countXOR ( arr , comb , 0 , N - 1 , 0 , r ) ; } Console . WriteLine ( s . Count ) ; }
void maxSizeSet ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { insertVector ( arr [ i ] ) ; } Console . WriteLine ( 1 << ans ) ; }
void waysToPaint ( int n ) { long same = 6 ; long diff = 6 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long sameTmp = 3 * same + 2 * diff ; long diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } Console . WriteLine ( same + diff ) ; }
void printMinimumRemovals ( string str , string X ) { int N = str . Length ; int M = X . Length ; int [ , ] dp = new int [ N , M ] ; for ( int j = 0 ; j < M ; j ++ ) { if ( str [ 0 ] == X [ j ] ) { dp [ 0 , j ] = 1 ; } } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( str [ i ] == X [ j ] ) { dp [ i , j ] = dp [ i - 1 , j ] + 1 ; if ( j != 0 ) dp [ i , j ] = Math . Min ( dp [ i , j ] , dp [ i - 1 , j - 1 ] ) ; } else { dp [ i , j ] = dp [ i - 1 , j ] ; } } } Console . WriteLine ( dp [ N - 1 , M - 1 ] ) ; }
int maxSubarraySum ( int [ ] sum , int k , int row ) { int curSum = 0 , curMax = Int32 . MinValue ; HashSet < int > sumSet = new HashSet < int > ( ) ; sumSet . Add ( 0 ) ; for ( int r = 0 ; r < row ; ++ r ) { curSum += sum [ r ] ; List < int > list = new List < int > ( ) ; list . AddRange ( sumSet ) ; int it = list . LastIndexOf ( curSum - k ) ; if ( it > - 1 ) { curMax = Math . Max ( curMax , curSum - it ) ; } sumSet . Add ( curSum ) ; } return curMax ; }
void maxSumSubmatrix ( int [ , ] matrix , int k ) { int row = matrix . GetLength ( 0 ) ; int col = matrix . GetLength ( 1 ) ; int ret = Int32 . MinValue ; for ( int i = 0 ; i < col ; ++ i ) { int [ ] sum = new int [ row ] ; for ( int j = i ; j < col ; ++ j ) { for ( int r = 0 ; r < row ; ++ r ) { sum [ r ] += matrix [ r , j ] ; } int curMax = maxSubarraySum ( sum , k , row ) ; ret = Math . Max ( ret , curMax ) ; } } Console . Write ( ret ) ; }
void minCost ( int [ ] arr , int n ) { if ( n < 3 ) { Console . WriteLine ( arr [ 0 ] ) ; return ; } int [ ] dp = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = Math . Min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = Math . Min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; Console . WriteLine ( dp [ n - 1 ] ) ; }
void maxSum ( int [ ] arr , int N , int K ) { int [ ] dp = new int [ N + 2 ] ; for ( int i = 0 ; i < N + 2 ; i ++ ) { dp [ i ] = 0 ; } int maxval = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( ( i + K * arr [ i ] ) >= N ) { dp [ i ] = arr [ i ] ; } else { dp [ i ] = dp [ i + K * arr [ i ] ] + arr [ i ] ; } maxval = Math . Max ( maxval , dp [ i ] ) ; } Console . WriteLine ( maxval ) ; }
void maxSubmatrixSum ( int [ , ] matrix ) { int r = matrix . GetLength ( 0 ) ; int c = matrix . GetLength ( 1 ) ; int maxSubmatrix = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { for ( int k = i ; k < r ; k ++ ) { for ( int l = j ; l < c ; l ++ ) { int sumSubmatrix = 0 ; for ( int m = i ; m <= k ; m ++ ) { for ( int n = j ; n <= l ; n ++ ) { sumSubmatrix += matrix [ m , n ] ; } } maxSubmatrix = Math . Max ( maxSubmatrix , sumSubmatrix ) ; } } } } Console . WriteLine ( maxSubmatrix ) ; }
int kadane ( List < int > v ) { int currSum = 0 ; int maxSum = int . MinValue ; for ( int i = 0 ; i < ( int ) v . Count ; i ++ ) { currSum += v [ i ] ; if ( currSum > maxSum ) { maxSum = currSum ; } if ( currSum < 0 ) { currSum = 0 ; } } return maxSum ; }
int minCost ( List < List < int > > costs , int N ) { if ( N == 0 ) return 0 ; List < int > temp = new List < int > ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) temp . Add ( 0 ) ; List < List < int > > dp = new List < List < int > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) dp . Add ( temp ) ; dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] ; dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] ; dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = Math . Min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] ; dp [ i ] [ 1 ] = Math . Min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] ; dp [ i ] [ 2 ] = Math . Min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] ; } return ( Math . Min ( dp [ N - 1 ] [ 0 ] , Math . Min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ) - 11 ; }
int findCnt ( int [ ] arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i , required_sum + Base ] ) return dp [ i , required_sum + Base ] ; v [ i , required_sum + Base ] = true ; dp [ i , required_sum + Base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i , required_sum + Base ] ; }
void countSubsets ( int [ ] arr , int K , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int S1 = ( sum + K ) / 2 ; Console . Write ( findCnt ( arr , 0 , S1 , n ) ) ; }
int solve ( int [ ] A , int i , int sum , int N ) { int res = 2001 ; if ( sum < 0 || ( i == N && sum != 0 ) ) { return 2001 ; } if ( sum == 0 i >= N ) { return dp [ i , sum ] = 0 ; } if ( dp [ i , sum ] != - 1 ) { return dp [ i , sum ] ; } res = Math . Min ( solve ( A , i + 1 , sum - A [ i ] , N ) + 1 , solve ( A , i + 1 , sum , N ) ) ; return dp [ i , sum ] = res ; }
void daysToCure ( int [ ] arr , int N , int P ) { int risk = 0 ; int normal_risk = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 60 arr [ i ] <= 10 ) { risk ++ ; } else { normal_risk ++ ; } } int days = ( risk / P ) + ( normal_risk / P ) ; if ( risk % P > 0 ) { days ++ ; } if ( normal_risk % P > 0 ) { days ++ ; } Console . Write ( days ) ; }
int countAverage ( int n , int K , int [ ] arr ) { dp [ 0 , 0 , 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int s = 0 ; s <= 100 ; s ++ ) { dp [ i + 1 , k + 1 , s + arr [ i ] ] += dp [ i , k , s ] ; dp [ i + 1 , k , s ] += dp [ i , k , s ] ; } } } int cnt = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { cnt += dp [ n , j , K * j ] ; } return cnt ; }
void maximumSubsetSum ( int [ ] arr1 , int [ ] arr2 , int length ) { int [ ] dp = new int [ length + 1 ] ; if ( length == 1 ) { Console . WriteLine ( Math . Max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ; return ; } if ( length == 2 ) { Console . WriteLine ( Math . Max ( Math . Max ( arr1 [ 1 ] , arr2 [ 1 ] ) , Math . Max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ) ; return ; } else { dp [ 0 ] = Math . Max ( arr1 [ 0 ] , arr2 [ 0 ] ) ; dp [ 1 ] = Math . Max ( Math . Max ( arr1 [ 1 ] , arr2 [ 1 ] ) , Math . Max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ; int index = 2 ; while ( index < length ) { dp [ index ] = Math . Max ( Math . Max ( arr1 [ index ] , arr2 [ index ] ) , Math . Max ( Math . Max ( arr1 [ index ] + dp [ index - 2 ] , arr2 [ index ] + dp [ index - 2 ] ) , dp [ index - 1 ] ) ) ; ++ index ; } Console . WriteLine ( dp [ length - 1 ] ) ; } }
int FindMaxS ( int X , int Y , int Z , int n , int [ ] A , int [ ] B , int [ ] C ) { if ( X < 0 Y < 0 Z < 0 ) return Int32 . MinValue ; if ( n < 0 ) return 0 ; if ( dp [ n , X , Y , Z ] != - 1 ) { return dp [ n , X , Y , Z ] ; } int ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; int ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; int co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; int no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; int maximum = Math . Max ( ch , Math . Max ( ca , Math . Max ( co , no ) ) ) ; return dp [ n , X , Y , Z ] = maximum ; }
void findCount ( int N , int [ ] maxDigit ) { int position = 0 ; int previous = 0 ; int count = 1 ; int ans = findCountUtil ( N , maxDigit , position , previous , count ) ; Console . WriteLine ( ans ) ; }
double find ( int N , int sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; }
float find ( int N , int sum ) { if ( N < 0 sum < 0 ) return 0 ; if ( dp [ N , sum ] > 0 ) return dp [ N , sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return ( float ) ( 1.0 / 6 ) ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N , sum ] = dp [ N , sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N , sum ] ; }
float find ( int N , int a , int b ) { float probability = 0.0f ; for ( int i = 1 ; i <= 6 ; i ++ ) dp [ 1 , i ] = ( float ) ( 1.0 / 6 ) ; for ( int i = 2 ; i <= N ; i ++ ) { for ( int j = i ; j <= 6 * i ; j ++ ) { for ( int k = 1 ; k <= 6 && k <= j ; k ++ ) { dp [ i , j ] = dp [ i , j ] + dp [ i - 1 , j - k ] / 6 ; } } } for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N , sum ] ; return probability ; }
void minAtEachIndex ( int n , int [ ] arr ) { int [ ] dp1 = new int [ n ] ; int [ ] dp2 = new int [ n ] ; int i ; dp1 [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) dp1 [ i ] = Math . Min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) ; dp2 [ n - 1 ] = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) dp2 [ i ] = Math . Min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) ; List < int > v = new List < int > ( ) ; for ( i = 0 ; i < n ; i ++ ) v . Add ( Math . Min ( dp1 [ i ] , dp2 [ i ] ) ) ; foreach ( int x in v ) Console . Write ( x + " " ) ; }
int totalArrays ( int N , int M ) { int [ ] end_with_one = new int [ N + 1 ] ; int [ ] end_not_with_one = new int [ N + 1 ] ; end_with_one [ 0 ] = 1 ; end_not_with_one [ 0 ] = 0 ; end_with_one [ 1 ] = 0 ; end_not_with_one [ 1 ] = M - 1 ; for ( int i = 2 ; i < N ; i ++ ) { end_with_one [ i ] = end_not_with_one [ i - 1 ] ; end_not_with_one [ i ] = end_with_one [ i - 1 ] * ( M - 1 ) + end_not_with_one [ i - 1 ] * ( M - 2 ) ; } return end_with_one [ N - 1 ] ; }
int prodOfDigit ( int N ) { int res = 1 ; while ( N > 0 ) { res = res * ( N % 10 ) ; N /= 10 ; } return res ; }
int cntNum ( String X , int i , int prod , int K , int st , int tight , int [ , , , ] dp ) { if ( i >= X . Length prod > K ) { return prod == K ? 1 : 0 ; } if ( dp [ prod , i , tight , st ] != - 1 ) { return dp [ prod , i , tight , st ] ; } int res = 0 ; int end = tight > 0 ? X [ i ] - '0' : 9 ; for ( int j = 0 ; j <= end ; j ++ ) { if ( j == 0 && st == 0 ) { res += cntNum ( X , i + 1 , prod , K , 0 , ( tight & ( ( j == end ) ? 1 : 0 ) ) , dp ) ; } else { res += cntNum ( X , i + 1 , prod * j , K , 1 , ( tight & ( ( j == end ) ? 1 : 0 ) ) , dp ) ; } } return dp [ prod , i , tight , st ] = res ; }
int power ( int X , int Y ) { int res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( ( Y & 1 ) != 0 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; }
int findValue ( int n ) { int X = 0 ; int pow_10 = 1 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) { X += pow_10 ; } pow_10 *= 10 ; n /= 2 ; } X = ( X * 2 ) % M ; int res = power ( 2 , X ) ; return res ; }
int mod_pow2 ( int n ) { while ( n >= MEM . Count ) MEM . Add ( ( MEM [ MEM . Count - 1 ] * 2 ) % MOD ) ; return MEM [ n ] ; }
int inversions ( char [ ] bstr ) { int total = 0 , zeros = 0 , questions = 0 ; Array . Reverse ( bstr ) ; foreach ( char x in bstr ) { int q ; if ( x == '1' ) { int z = zeros * mod_pow2 ( questions ) ; if ( questions == 0 ) q = 0 ; else q = questions * mod_pow2 ( questions - 1 ) ; total = ( total + z + q ) % MOD ; } else if ( x == '0' ) { zeros += 1 ; } else { total *= 2 ; int z = zeros * mod_pow2 ( questions ) ; if ( questions == 0 ) q = 0 ; else q = questions * mod_pow2 ( questions - 1 ) ; total = ( total + z + q ) % MOD ; questions += 1 ; } } return total ; }
double findMedXOR ( int [ , ] mat , int N , int M ) { int [ , ] dp = new int [ N , M ] ; int [ ] med = new int [ N * M ] ; dp [ 0 , 0 ] = mat [ 0 , 0 ] ; med [ 0 ] = dp [ 0 , 0 ] ; int len = 1 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i , 0 ] = dp [ i - 1 , 0 ] ^ mat [ i , 0 ] ; med [ len ++ ] = dp [ i , 0 ] ; } for ( int i = 1 ; i < M ; i ++ ) { dp [ 0 , i ] = dp [ 0 , i - 1 ] ^ mat [ 0 , i ] ; med [ len ++ ] = dp [ 0 , i ] ; } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { dp [ i , j ] = dp [ i - 1 , j ] ^ dp [ i , j - 1 ] ^ dp [ i - 1 , j - 1 ] ^ mat [ i , j ] ; med [ len ++ ] = dp [ i , j ] ; } } Array . Sort ( med ) ; if ( len % 2 == 0 ) { return ( med [ ( len / 2 ) ] + med [ ( len / 2 ) - 1 ] ) / 2.0 ; } return med [ len / 2 ] ; }
int countTriplets ( int [ ] A ) { int cnt = 0 ; Dictionary < int , int > tuples = new Dictionary < int , int > ( ) ; foreach ( int a in A ) foreach ( int b in A ) { if ( tuples . ContainsKey ( a & b ) ) tuples [ a & b ] = tuples [ a & b ] + 1 ; else tuples . Add ( a & b , 1 ) ; } foreach ( int a in A ) foreach ( KeyValuePair < int , int > t in tuples ) if ( ( t . Key & a ) == 0 ) cnt += t . Value ; return cnt ; }
int countVowelPermutation ( int n ) { int MOD = ( int ) ( 1e9 + 7 ) ; long [ , ] dp = new long [ n + 1 , 5 ] ; for ( int i = 0 ; i < 5 ; i ++ ) { dp [ 1 , i ] = 1 ; } List < List < int > > relation = new List < List < int > > ( ) ; relation . Add ( new List < int > { 1 } ) ; relation . Add ( new List < int > { 0 , 2 } ) ; relation . Add ( new List < int > { 0 , 1 , 3 , 4 } ) ; relation . Add ( new List < int > { 2 , 4 } ) ; relation . Add ( new List < int > { 0 } ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int u = 0 ; u < 5 ; u ++ ) { dp [ i + 1 , u ] = 0 ; foreach ( int v in relation [ u ] ) { dp [ i + 1 , u ] += dp [ i , v ] % MOD ; } } } long ans = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans = ( ans + dp [ n , i ] ) % MOD ; } return ( int ) ans ; }
int MaximumSubarraySum ( int n , int [ ] arr , int k ) { int [ , ] dp = new int [ M , M ] ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) dp [ i , j ] = - 1 ; mxSubSum ( n - 1 , arr , k , dp ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= k ; j ++ ) { res = Math . Max ( res , dp [ i , j ] ) ; } } Array . Sort ( arr ) ; if ( arr [ n - 1 ] < 0 ) { res = arr [ n - 1 ] ; } return res ; }
void countWaysToTileBoard ( int N ) { int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; } Console . Write ( dp [ N ] ) ; }
void DFS ( int node , int parent , int [ ] Val ) { answer [ node ] = Val [ node ] ; foreach ( int child in adj [ node ] ) { if ( child == parent ) continue ; DFS ( child , node , Val ) ; answer [ node ] = ( answer [ node ] answer [ child ] ) ; } }
void preprocess ( int [ ] Val ) { DFS ( 1 , - 1 , Val ) ; }
void findSubtreeOR ( int [ ] Queries , int Q , int [ ] Val ) { preprocess ( Val ) ; for ( int i = 0 ; i < Q ; i ++ ) { Console . Write ( answer [ Queries [ i ] ] + " " ) ; } }
void minCost ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int m = 2 * n ; int [ , ] cost = new int [ n + 1 , m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { cost [ i , j ] = INF ; } } cost [ 0 , 0 ] = 0 ; int prev = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { prev = cost [ i - 1 , 0 ] ; for ( int j = 1 ; j <= m ; j ++ ) { cost [ i , j ] = Math . Min ( cost [ i , j ] , prev + Math . Abs ( j - arr [ i - 1 ] ) ) ; prev = Math . Min ( prev , cost [ i - 1 , j ] ) ; } } int minCost = INF ; for ( int j = 1 ; j <= m ; j ++ ) { minCost = Math . Min ( minCost , cost [ n , j ] ) ; } Console . Write ( minCost ) ; }
void FindSub ( string str , string res , int i ) { if ( i == str . Length ) { if ( res . Length > 0 ) { Console . Write ( res + " " ) ; } return ; } char ch = str [ i ] ; FindSub ( str , res , i + 1 ) ; FindSub ( str , res + ch , i + 1 ) ; FindSub ( str , res + ( int ) ch , i + 1 ) ; }
int MinOp ( int N ) { if ( N <= 1 ) return N ; int bit = ( int ) ( Math . Log ( N ) / Math . Log ( 2 ) ) + 1 ; return ( ( 1 << bit ) - 1 ) - MinOp ( N - ( 1 << ( bit - 1 ) ) ) ; }
int max ( int a , int b ) { return a > b ? a : b ; }
int maximumsum ( int [ , ] arr , int K , int N , int M ) { int sum = 0 , maxSum ; int i , j , k ; int [ , ] dp = new int [ K + 1 , N + 1 ] ; for ( i = 0 ; i <= N ; i ++ ) dp [ 0 , i ] = 0 ; for ( i = 0 ; i <= K ; i ++ ) dp [ i , 0 ] = 0 ; for ( i = 1 ; i <= K ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { sum = 0 ; maxSum = dp [ i , j ] ; for ( k = 1 ; k <= M && k <= i ; k ++ ) { sum += arr [ j , k - 1 ] ; maxSum = Math . Max ( maxSum , sum + dp [ i - k , j ] ) ; } dp [ i , j + 1 ] = maxSum ; } } return dp [ K , N ] ; }
int check ( int [ , ] memo , int i , int j , int [ ] A ) { if ( i == N - 1 ) return 1 ; if ( memo [ i , j ] != - 1 ) return memo [ i , j ] ; int flag = 0 , k ; for ( k = i + 1 ; k < N ; k ++ ) { if ( A [ k ] - A [ i ] > j + 1 ) break ; if ( A [ k ] - A [ i ] >= j - 1 && A [ k ] - A [ i ] <= j + 1 ) flag = check ( memo , k , A [ k ] - A [ i ] , A ) ; if ( flag != 0 ) break ; } memo [ i , j ] = flag ; return memo [ i , j ] ; }
void checkEndReach ( int [ ] A , int K ) { int [ , ] memo = new int [ N , N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { memo [ i , j ] = - 1 ; } } int startIndex = 1 ; if ( check ( memo , startIndex , K , A ) != 0 ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
int maxProductPath ( int [ , ] grid ) { int n = grid . GetLength ( 0 ) ; int m = grid . GetLength ( 1 ) ; int [ , ] maxPath = new int [ n , m ] ; int [ , ] minPath = new int [ n , m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int mn = Int32 . MaxValue ; int mx = Int32 . MinValue ; if ( i == 0 && j == 0 ) { mx = grid [ i , j ] ; mn = grid [ i , j ] ; } if ( i > 0 ) { int tempmx = Math . Max ( ( maxPath [ i - 1 , j ] * grid [ i , j ] ) , ( minPath [ i - 1 , j ] * grid [ i , j ] ) ) ; mx = Math . Max ( mx , tempmx ) ; int tempmn = Math . Min ( ( maxPath [ i - 1 , j ] * grid [ i , j ] ) , ( minPath [ i - 1 , j ] * grid [ i , j ] ) ) ; mn = Math . Min ( mn , tempmn ) ; } if ( j > 0 ) { int tempmx = Math . Max ( ( maxPath [ i , j - 1 ] * grid [ i , j ] ) , ( minPath [ i , j - 1 ] * grid [ i , j ] ) ) ; mx = Math . Max ( mx , tempmx ) ; int tempmn = Math . Min ( ( maxPath [ i , j - 1 ] * grid [ i , j ] ) , ( minPath [ i , j - 1 ] * grid [ i , j ] ) ) ; mn = Math . Min ( mn , tempmn ) ; } maxPath [ i , j ] = mx ; minPath [ i , j ] = mn ; } } if ( maxPath [ n - 1 , m - 1 ] < 0 ) { return - 1 ; } else { return ( maxPath [ n - 1 , m - 1 ] ) ; } }
void waysToArrangeKLengthStrings ( int N , int K ) { int [ ] column_sum = new int [ N + 1 ] ; int i , j ; for ( i = 1 ; i < N + 1 ; i ++ ) { column_sum [ i ] = 0 ; } int [ , ] dp = new int [ K + 1 , N + 1 ] ; for ( i = 1 ; i < K + 1 ; i ++ ) { for ( j = 1 ; j < N + 1 ; j ++ ) { dp [ i , j ] = 0 ; } } for ( i = 0 ; i <= N ; i ++ ) { dp [ 0 , i ] = 1 ; column_sum [ i ] = 1 ; } for ( i = 1 ; i <= K ; i ++ ) { for ( j = 1 ; j <= N ; j ++ ) { dp [ i , j ] += column_sum [ j - 1 ] ; column_sum [ j ] += dp [ i , j ] ; } } Console . Write ( dp [ K , N ] ) ; }
int findNumberOfLIS ( int [ ] nums ) { if ( nums . Length == 0 ) return 0 ; int n = nums . Length ; int [ ] dp_l = new int [ n ] ; Array . Fill ( dp_l , 1 ) ; int [ ] dp_c = new int [ n ] ; Array . Fill ( dp_c , 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( nums [ i ] <= nums [ j ] ) continue ; if ( dp_l [ j ] + 1 > dp_l [ i ] ) { dp_l [ i ] = dp_l [ j ] + 1 ; dp_c [ i ] = dp_c [ j ] ; } else if ( dp_l [ j ] + 1 == dp_l [ i ] ) dp_c [ i ] += dp_c [ j ] ; } } int max_length = 0 ; foreach ( int i in dp_l ) max_length = Math . Max ( i , max_length ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp_l [ i ] == max_length ) count += dp_c [ i ] ; } return count ; }
int countPenality ( int [ ] arr , int N ) { int pos = 0 ; int turn = 0 ; return findMinimum ( arr , N , pos , turn ) + 1 ; }
void printAnswer ( int [ ] arr , int N ) { int a = countPenality ( arr , N ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } Console . WriteLine ( a ) ; }
int removeSmallestSubarray ( int [ ] arr , int S , int n , int k ) { int target_remainder = S % k ; Dictionary < int , int > map1 = new Dictionary < int , int > ( ) ; map1 . Add ( 0 , - 1 ) ; int curr_remainder = 0 ; int res = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { curr_remainder = ( curr_remainder + arr [ i ] + k ) % k ; map1 [ curr_remainder ] = i ; int mod = ( curr_remainder - target_remainder + k ) % k ; if ( map1 . ContainsKey ( mod ) ) { res = Math . Min ( res , i - map1 [ mod ] ) ; } } if ( res == int . MaxValue res == n ) { res = - 1 ; } return res ; }
int smstSubmatDeleted ( int [ , ] mat , int N , int M , int K ) { int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) S += mat [ i , j ] ; } int min_area = N * M ; int left = 0 ; int right = 0 ; int width ; int area ; int [ ] prefixRowSum = new int [ N ] ; for ( left = 0 ; left < M ; left ++ ) { for ( int i = 0 ; i < prefixRowSum . Length ; i ++ ) prefixRowSum [ i ] = 0 ; for ( right = left ; right < M ; right ++ ) { for ( int i = 0 ; i < N ; i ++ ) { prefixRowSum [ i ] += mat [ i , right ] ; } width = removeSmallestSubarray ( prefixRowSum , S , N , K ) ; if ( width != - 1 ) { area = ( right - left + 1 ) * ( width ) ; if ( area < min_area ) { min_area = area ; } } } } return min_area ; }
int countstrings ( int n , int start ) { if ( n == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = start ; i < 5 ; i ++ ) { cnt += countstrings ( n - 1 , i ) ; } return cnt ; }
int findNumberOfStrings ( int n ) { int [ , ] DP = new int [ n + 1 , 6 ] ; DP [ 1 , 1 ] = 1 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < 6 ; j ++ ) { if ( i == 1 ) { DP [ i , j ] = DP [ i , j - 1 ] + 1 ; } else { DP [ i , j ] = DP [ i , j - 1 ] + DP [ i - 1 , j ] ; } } } return DP [ n , 5 ] ; }
int findNumberOfStrings ( int n ) { return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ; }
int check ( int sum , int x , int y ) { while ( sum > 0 ) { int ln = sum % 10 ; if ( ln != x && ln != y ) { return 0 ; } sum /= 10 ; } return 1 ; }
int countNumbers ( int n , int x , int y , int sum ) { for ( int i = 0 ; i < dp . GetLength ( 0 ) ; i ++ ) { for ( int j = 0 ; j < dp . GetLength ( 1 ) ; j ++ ) { dp [ i , j ] = - 1 ; } } if ( n == 0 ) { return check ( sum , x , y ) ; } if ( dp [ n , sum ] != - 1 ) { return dp [ n , sum ] % mod ; } int option1 = countNumbers ( n - 1 , x , y , sum + x ) % mod ; int option2 = countNumbers ( n - 1 , x , y , sum + y ) % mod ; return dp [ n , sum ] = ( option1 + option2 ) % mod ; }
int findTotalPath ( int X , int n , int [ ] dp ) { if ( X == 0 ) { return 1 ; } int ans = 0 ; if ( dp [ X ] != - 1 ) { return dp [ X ] ; } for ( int i = 1 ; i <= Math . Min ( X , n ) ; ++ i ) { ans += findTotalPath ( X - i , n , dp ) % mod ; ans %= mod ; } dp [ X ] = ans ; return ans ; }
void printAnswer ( int n , int [ , ] edges , int [ ] values ) { List < int > [ ] adj = new List < int > [ n ] ; for ( int i = 0 ; i < n ; i ++ ) adj [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int u = edges [ i , 0 ] - 1 ; int v = edges [ i , 1 ] - 1 ; adj [ u ] . Add ( v ) ; adj [ v ] . Add ( u ) ; } int [ ] ans = new int [ n ] ; dfs ( 0 , - 1 , adj , ans , values ) ; foreach ( int x in ans ) { Console . Write ( x + " " ) ; } }
bool checkEvenOddLevel ( Node root ) { if ( root == null ) return true ; Queue < Node > q = new Queue < Node > ( ) ; q . Enqueue ( root ) ; int level = 0 ; while ( q . Count != 0 ) { List < int > list = new List < int > ( ) ; int size = q . Count ; for ( int i = 0 ; i < size ; i ++ ) { Node node = q . Dequeue ( ) ; list . Add ( node . val ) ; if ( node . left != null ) q . Enqueue ( node . left ) ; if ( node . right != null ) q . Enqueue ( node . right ) ; } if ( level % 2 == 0 ) { for ( int i = 0 ; i < list . Count - 1 ; i ++ ) { if ( list [ i + 1 ] > list [ i ] ) continue ; return false ; } } else if ( level % 2 == 1 ) { for ( int i = 0 ; i < list . Count - 1 ; i ++ ) { if ( list [ i + 1 ] < list [ i ] ) continue ; return false ; } } level ++ ; } return true ; }
void build ( int [ ] dp , int [ ] arr , int N ) { dp [ 0 ] = 0 ; dp [ 1 ] = 0 ; List < int > prime = SieveOfEratosthenes ( ) ; int [ ] pref = new int [ N + 1 ] ; pref [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { pref [ i ] = pref [ i - 1 ] + arr [ i - 1 ] ; } for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; for ( int j = 0 ; j <= prime . Count ; j ++ ) { int r = i - 1 ; int l = r - prime [ j ] + 1 ; if ( l < 0 ) break ; int temp = 0 ; temp = pref [ r + 1 ] - pref [ l ] ; if ( l - 2 >= 0 ) temp += dp [ l - 2 + 1 ] ; dp [ i ] = Math . Max ( dp [ i ] , temp ) ; } } }
void maxSumSubseq ( int [ ] arr , int N ) { int [ ] dp = new int [ N + 1 ] ; build ( dp , arr , N ) ; Console . Write ( dp [ N ] ) ; }
int MinRunLengthEncoding ( String s , int n , int k ) { for ( int i = 0 ; i < maxN ; i ++ ) for ( int j = 0 ; j < maxN ; j ++ ) for ( int p = 0 ; p < 27 ; p ++ ) for ( int l = 0 ; l < maxN ; l ++ ) dp [ i , j , p , l ] = - 1 ; return solve ( s , n , 0 , k , ( char ) 123 , 0 ) ; }
int minimumCost ( int [ ] A , int [ ] B , int M , int N , int C ) { int [ ] nums = new int [ 100000 ] ; int [ ] index = new int [ 100000 ] ; for ( int i = 0 ; i < 100000 ; i ++ ) index [ i ] = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { index [ B [ i ] ] = i ; } int k = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( index [ A [ i ] ] != - 1 ) { nums [ k ++ ] = index [ A [ i ] ] ; } } int lcs_length = findLCS ( nums , k ) ; int elements_to_be_added = N - lcs_length ; int min_cost = elements_to_be_added * C ; Console . WriteLine ( min_cost ) ; return 0 ; }
void numberOfPermWithKInversion ( int N , int K ) { int [ , ] dp = new int [ 2 , K + 1 ] ; int mod = 1000000007 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) { dp [ i % 2 , j ] = ( j == 0 ) ? 1 : 0 ; } else if ( j == 0 ) dp [ i % 2 , j ] = 1 ; else dp [ i % 2 , j ] = ( dp [ i % 2 , j - 1 ] % mod + ( dp [ 1 - i % 2 , j ] - ( ( Math . Max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 , Math . Max ( j - ( i - 1 ) , 0 ) - 1 ] ) + mod ) % mod ) % mod ; } } Console . WriteLine ( dp [ N % 2 , K ] ) ; }
int maxScore ( int [ ] arr ) { int N = arr . Length ; N ++ ; int [ , ] dp = new int [ N + 1 , 2 * ( N - 1 ) + 1 ] ; dp [ 0 , 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int s = 1 ; s <= 2 * ( N - 1 ) ; s ++ ) { for ( int j = 1 ; j <= N - 1 && j <= s ; j ++ ) { dp [ i , s ] = Math . Max ( dp [ i , s ] , arr [ j - 1 ] + dp [ i - 1 , s - j ] ) ; } } } return dp [ N , 2 * ( N - 1 ) ] - 1 ; }
void minimumCost ( int [ ] cost , int n , int x ) { int [ ] dp = new int [ n + 2 ] ; dp [ 0 ] = cost [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( i == 1 ) dp [ i ] = cost [ i ] + dp [ i - 1 ] ; if ( i == 2 ) dp [ i ] = cost [ i ] + Math . Min ( dp [ i - 1 ] , x + dp [ i - 2 ] ) ; if ( i >= 3 ) dp [ i ] = cost [ i ] + Math . Min ( dp [ i - 1 ] , Math . Min ( x + dp [ i - 2 ] , 2 * x + dp [ i - 3 ] ) ) ; } Console . WriteLine ( dp [ n - 1 ] ) ; }
int maxSum ( int [ ] a , int n , int k ) { if ( n <= 0 ) return 0 ; int option = maxSum ( a , n - 1 , k ) ; if ( k >= a [ n - 1 ] ) option = Math . Max ( option , a [ n - 1 ] + maxSum ( a , n - 2 , k - a [ n - 1 ] ) ) ; return option ; }
bool checkStr ( string str , int P , int Q ) { int N = str . Length ; char prev = str [ 0 ] ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == prev ) { cnt ++ ; } else { if ( prev == '1' && cnt >= Q ) { return false ; } if ( prev == '0' && cnt >= P ) { return false ; } cnt = 1 ; } prev = str [ i ] ; } if ( prev == '1' && cnt >= Q ) { return false ; } if ( prev == '0' && cnt >= P ) { return false ; } return true ; }
int cntBinStr ( string str , int N , int P , int Q ) { int len = str . Length ; if ( len == N ) { if ( checkStr ( str , P , Q ) ) return 1 ; return 0 ; } int X = cntBinStr ( str + '0' , N , P , Q ) ; int Y = cntBinStr ( str + '1' , N , P , Q ) ; return X + Y ; }
int maxCount ( int [ ] arr , int m , int V ) { int [ ] table = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = - 1 ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ j ] <= i ) { int sub_res = table [ i - arr [ j ] ] ; if ( sub_res != - 1 && sub_res + 1 > table [ i ] ) table [ i ] = sub_res + 1 ; } } } return table [ V ] ; }
int binCoff ( int N , int R ) { int res = 1 ; if ( R > ( N - R ) ) { R = ( N - R ) ; } for ( int i = 0 ; i < R ; i ++ ) { res *= ( N - i ) ; res /= ( i + 1 ) ; } return res ; }
int cntPermutation ( int N ) { int cntPerm ; int C_2N_N = binCoff ( 2 * N , N ) ; cntPerm = C_2N_N / ( N + 1 ) ; return cntPerm ; }
int solve ( int [ , ] a , String s , int n , int prev , int mask , int [ , ] dp ) { if ( mask == 0 ) return 0 ; if ( dp [ mask , prev + 1 ] != - 1 ) return dp [ mask , prev + 1 ] ; int ans = 10000 ; for ( int i = 0 ; i < s . Length ; i ++ ) { int id = s [ i ] - 'a' ; if ( check ( mask , id ) ) { if ( prev == - 1 ) { ans = Math . Min ( ans , solve ( a , s , n , id , mask ^ ( 1 << id ) , dp ) ) ; } else { ans = Math . Min ( ans , a [ prev , id ] + solve ( a , s , n , id , mask ^ ( 1 << id ) , dp ) ) ; } } } dp [ mask , prev + 1 ] = ans ; return ans ; }
int longestPalSubstr ( string str ) { int n = str . Length ; int maxLength = 1 , start = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { for ( int j = i ; j < str . Length ; j ++ ) { int flag = 1 ; for ( int k = 0 ; k < ( j - i + 1 ) / 2 ; k ++ ) if ( str [ i + k ] != str [ j - k ] ) flag = 0 ; if ( flag != 0 && ( j - i + 1 ) > maxLength ) { start = i ; maxLength = j - i + 1 ; } } } return maxLength ; }
int mElementsWithMaxSum ( int [ , ] matrix , int M , int block , int [ , ] dp ) { if ( block == matrix . GetLength ( 0 ) ) return 0 ; if ( dp [ block , M ] != - 1 ) return dp [ block , M ] ; int ans = mElementsWithMaxSum ( matrix , M , block + 1 , dp ) ; for ( int i = 0 ; i < GetRow ( matrix , block ) . Length ; i ++ ) { for ( int j = i ; j < GetRow ( matrix , block ) . Length ; j ++ ) { if ( j - i + 1 <= M ) { ans = Math . Max ( ans , matrix [ block , j ] - ( ( i - 1 ) >= 0 ? matrix [ block , i - 1 ] : 0 ) + mElementsWithMaxSum ( matrix , M - j + i - 1 , block + 1 , dp ) ) ; } } } return dp [ block , M ] = ans ; }
void preComputing ( int [ , ] matrix , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < GetRow ( matrix , i ) . Length ; j ++ ) { matrix [ i , j ] = ( j > 0 ? matrix [ i , j - 1 ] : 0 ) + matrix [ i , j ] ; } } }
void mElementsWithMaxSumUtil ( int [ , ] matrix , int M , int N ) { preComputing ( matrix , N ) ; int [ , ] dp = new int [ N + 5 , M + 5 ] ; for ( int i = 0 ; i < N + 5 ; i ++ ) { for ( int j = 0 ; j < M + 5 ; j ++ ) { dp [ i , j ] = - 1 ; } } int sum = mElementsWithMaxSum ( matrix , M , 0 , dp ) ; Console . Write ( sum ) ; }
int lastRemaining ( int n , Dictionary < int , int > dp ) { if ( dp . ContainsKey ( n ) ) return dp [ n ] ; if ( n == 1 ) return 1 ; else dp . Add ( n , 2 * ( 1 + n / 2 - lastRemaining ( n / 2 , dp ) ) ) ; return dp [ n ] ; }
int Max_Sum ( int [ ] arr , int K , int N ) { int [ ] dp = new int [ N + 1 ] ; Array . Fill ( dp , 0 ) ; int [ ] prefix = new int [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } dp [ 0 ] = 0 ; for ( int i = 1 ; i <= K - 1 ; i ++ ) { dp [ i ] = prefix [ i ] ; } for ( int i = K ; i <= N ; ++ i ) { for ( int j = i ; j >= ( i - K + 1 ) ; j -- ) { dp [ i ] = Math . Max ( dp [ i ] , dp [ j - 1 ] + prefix [ i ] - prefix [ j ] ) ; } } return dp [ N ] ; }
int binomialCoeff ( int n , int k ) { int [ , ] C = new int [ n + 1 , k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } return C [ n , k ] ; }
int waysToSplitN ( int k , int n , int P ) { int new_N = n - k * P ; return binomialCoeff ( new_N + k - 1 , new_N ) ; }
int maximumSumUtil ( int [ ] a , int index , int count , int n ) { if ( index > n count > n + 1 ) { return 0 ; } if ( dp [ index , count ] != - 1 ) return dp [ index , count ] ; int ans1 = maximumSumUtil ( a , index + 1 , count + 1 , n ) + a [ index ] * count ; int ans2 = maximumSumUtil ( a , index + 1 , count , n ) ; return ( dp [ index , count ] = Math . Max ( ans1 , ans2 ) ) ; }
void maximumSum ( int [ ] arr , int N ) { for ( int i = 0 ; i < 1005 ; i ++ ) { for ( int j = 0 ; j < 1005 ; j ++ ) { dp [ i , j ] = - 1 ; } } Console . Write ( maximumSumUtil ( arr , 0 , 1 , N - 1 ) ) ; }
void Calculate_factorial ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i <= mx ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; fact [ i ] %= mod ; } }
int UniModal_per ( int a , int b ) { int res = 1 ; while ( b > 0 ) { if ( b % 2 != 0 ) res = res * a ; res %= mod ; a = a * a ; a %= mod ; b /= 2 ; } return res ; }
void countPermutations ( int n ) { Calculate_factorial ( ) ; int uni_modal = UniModal_per ( 2 , n - 1 ) ; int nonuni_modal = fact [ n ] - uni_modal ; Console . Write ( uni_modal + " " + nonuni_modal ) ; return ; }
void countMinCoinsUtil ( int X , int [ ] C , int N ) { for ( int i = 0 ; i < dp . Length ; i ++ ) dp [ i ] = - 1 ; int isPossible = countMinCoins ( X , C , N ) ; if ( isPossible == int . MaxValue ) { Console . Write ( "-1" ) ; } else { findSolution ( X , C , N ) ; } }
int helper ( int [ ] arr , int left , int right , int count , int m ) { if ( left > right ) return 0 ; if ( dp [ left , right , count ] != - 1 ) { return dp [ left , right , count ] ; } int ans = ( count + 1 ) * m + helper ( arr , left + 1 , right , 0 , m ) ; for ( int i = left + 1 ; i <= right ; ++ i ) { if ( arr [ i ] == arr [ left ] ) { ans = Math . Max ( ans , helper ( arr , left + 1 , i - 1 , 0 , m ) + helper ( arr , i , right , count + 1 , m ) ) ; } } dp [ left , right , count ] = ans ; return ans ; }
int maxPoints ( int [ ] arr , int n , int m ) { int len = n ; for ( int i = 0 ; i < 101 ; i ++ ) { for ( int j = 0 ; j < 101 ; j ++ ) { for ( int k = 0 ; k < 101 ; k ++ ) dp [ i , j , k ] = - 1 ; } } return helper ( arr , 0 , len - 1 , 0 , m ) ; }
int findWays ( int N ) { if ( N == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i ) ; } } return cnt ; }
int findWays ( int N , int [ ] dp ) { if ( N == 0 ) { return 1 ; } if ( dp [ N ] != - 1 ) { return dp [ N ] ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i , dp ) ; } } return dp [ N ] = cnt ; }
void findWays ( int N ) { int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } Console . Write ( dp [ N ] ) ; }
int findWays ( int n ) { n -- ; int a , b , ans ; a = binCoff ( 2 * n , n ) ; b = a / ( n + 1 ) ; ans = 2 * b ; return ans ; }
List < int > find_sequence ( int n ) { List < int > temp = new List < int > ( ) ; temp . Add ( 1 ) ; temp . Add ( - 1 ) ; if ( n == 1 ) return temp ; List < int > arr = find_sequence ( n - 1 ) ; List < int > ans = new List < int > ( n ) ; ans . Add ( arr [ 0 ] + 1 ) ; ans . Add ( n - 1 ) ; if ( n % 2 == 0 ) { List < int > div_by_2 = find_sequence ( n / 2 ) ; if ( div_by_2 [ 0 ] < ans [ 0 ] ) { ans . Clear ( ) ; ans . Add ( div_by_2 [ 0 ] + 1 ) ; ans . Add ( n / 2 ) ; } } if ( n % 3 == 0 ) { List < int > div_by_3 = find_sequence ( n / 3 ) ; if ( div_by_3 [ 0 ] < ans [ 0 ] ) { ans . Clear ( ) ; ans . Add ( div_by_3 [ 0 ] + 1 ) ; ans . Add ( n / 3 ) ; } } return ans ; }
int FindNoOfFullVessels ( int n , int t ) { double [ , ] Matrix = new double [ n , n ] ; Matrix [ 0 , 0 ] = t * 1.0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { double exceededwater = Matrix [ i , j ] - 1.0 ; if ( exceededwater < 0 ) continue ; ans ++ ; if ( i + 1 < n ) Matrix [ i + 1 , j ] += exceededwater / 2 ; if ( i + 1 < n && j + 1 < n ) Matrix [ i + 1 , j + 1 ] += exceededwater / 2 ; } } return ans ; }
int minCountOfNumbers ( int N ) { int k = N % 10 ; int z = N - ( 9 * ( 9 - k ) ) ; if ( z >= 9 && z % 10 == 9 ) { return 10 - k ; } else return - 1 ; }
int checkEqualSumUtil ( int [ ] arr , int N , int sm1 , int sm2 , int sm3 , int j ) { if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return Math . Max ( Math . Max ( l , m ) , r ) ; } }
int checkEqualSumUtil ( int [ ] arr , int N , int sm1 , int sm2 , int sm3 , int j ) { string s = sm1 . ToString ( ) + "_" + sm2 . ToString ( ) + j . ToString ( ) ; if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } if ( dp . ContainsKey ( s ) ) return dp [ s ] ; else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; dp [ s ] = Math . Max ( Math . Max ( l , m ) , r ) ; return dp [ s ] ; } }
void checkEqualSum ( int [ ] arr , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { Console . Write ( "Yes" ) ; } else { Console . Write ( "No" ) ; } }
void manipulation ( int [ , ] matrix , int [ ] q ) { int x1 = q [ 0 ] , y1 = q [ 1 ] , x2 = q [ 2 ] , y2 = q [ 3 ] ; for ( int i = x1 - 1 ; i < x2 ; i ++ ) { for ( int j = y1 - 1 ; j < y2 ; j ++ ) { if ( matrix [ i , j ] == 1 ) matrix [ i , j ] = 0 ; else matrix [ i , j ] = 1 ; } } }
int solve ( String s , String t ) { int n = s . Length ; int r = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i , j ] = 0 ; if ( i > 0 ) { dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] , dp [ i , j ] ) ; } if ( s [ i ] == t [ j ] ) { int ans = 1 ; if ( i > 0 && j > 0 ) { ans = 1 + dp [ i - 1 , j - 1 ] ; } dp [ i , j ] = Math . Max ( dp [ i , j ] , ans ) ; r = Math . Max ( r , dp [ i , j ] ) ; } } } return ( n - r ) ; }
int min_op ( int cur , int M ) { if ( cur > M ) return INF ; if ( cur == M ) return 0 ; int op = INF ; for ( int i = 2 ; i * i <= cur ; i ++ ) { if ( cur % i == 0 ) { if ( i % 2 == 0 ) { op = Math . Min ( op , 1 + min_op ( cur + i , M ) ) ; } if ( ( cur / i ) != i && ( cur / i ) % 2 == 0 ) { op = Math . Min ( op , 1 + min_op ( cur + ( cur / i ) , M ) ) ; } } } return op ; }
int min_op ( int cur , int M ) { if ( cur > M ) return INF ; if ( cur == M ) return 0 ; if ( dp [ cur ] != - 1 ) return dp [ cur ] ; int op = INF ; for ( int i = 2 ; i * i <= cur ; i ++ ) { if ( cur % i == 0 ) { if ( i % 2 == 0 ) { op = Math . Min ( op , 1 + min_op ( cur + i , M ) ) ; } if ( ( cur / i ) != i && ( cur / i ) % 2 == 0 ) { op = Math . Min ( op , 1 + min_op ( cur + ( cur / i ) , M ) ) ; } } } return dp [ cur ] = op ; }
int min_operations ( int N , int M ) { for ( int i = N ; i <= M ; i ++ ) { dp [ i ] = - 1 ; } return min_op ( N , M ) ; }
int solve ( int [ ] a ) { int n = a . Length ; int [ ] dp = new int [ n + 1 ] ; int [ ] val = new int [ n + 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int sum = a [ i ] ; int j = i ; while ( j + 1 < n && sum < val [ j + 1 ] ) { j ++ ; sum += a [ j ] ; } dp [ i ] = ( j - i ) + dp [ j + 1 ] ; val [ i ] = sum ; } return dp [ 0 ] ; }
int [ ] findPrimeFactors ( int n ) { int [ ] primeFactors = new int [ 9 ] ; int j = 0 ; if ( n % 2 == 0 ) { primeFactors [ j ++ ] = 2 ; while ( n % 2 == 0 ) n >>= 1 ; } for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) { primeFactors [ j ++ ] = i ; while ( n % i == 0 ) n /= i ; } } if ( n > 2 ) primeFactors [ j ++ ] = n ; int [ ] temp = new int [ j ] ; Array . Copy ( primeFactors , temp , j ) ; return temp ; }
void findShortestSubsequence ( int [ ] dp , int [ ] a , int index , int [ ] primeFactors ) { int n = a . Length ; for ( int j = index ; j < n ; j ++ ) { int bitmask = 0 ; for ( int p = 0 ; p < primeFactors . Length ; p ++ ) { if ( a [ j ] % primeFactors [ p ] == 0 ) { bitmask ^= ( 1 << p ) ; } } for ( int i = 0 ; i < dp . Length ; i ++ ) { if ( dp [ i ] == n + 1 ) continue ; dp [ bitmask & i ] = Math . Min ( dp [ bitmask & i ] , dp [ i ] + 1 ) ; } } }
int minDays ( int n ) { if ( n < 1 ) return n ; int cnt = 1 + Math . Min ( n % 2 + minDays ( n / 2 ) , n % 3 + minDays ( n / 3 ) ) ; return cnt ; }
int count ( int n ) { Dictionary < int , int > dp = new Dictionary < int , int > ( ) ; dp . Add ( 0 , 0 ) ; dp . Add ( 1 , 1 ) ; if ( ! dp . ContainsKey ( n ) ) dp . Add ( n , 1 + Math . Min ( n % 2 + count ( n / 2 ) , n % 3 + count ( n / 3 ) ) ) ; return dp [ n ] ; }
int findMaxTimes ( String S ) { int [ ] arr = new int [ 26 ] ; int [ , ] dp = new int [ 26 , 26 ] ; for ( int i = 0 ; i < S . Length ; i ++ ) { int now = S [ i ] - 'a' ; for ( int j = 0 ; j < 26 ; j ++ ) { dp [ j , now ] += arr [ j ] ; } arr [ now ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) ans = Math . Max ( ans , arr [ i ] ) ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { ans = Math . Max ( ans , dp [ i , j ] ) ; } } return ans ; }
int xorSum ( int [ ] a , int n , int mask , int [ ] dp ) { if ( dp [ mask ] != - 1 ) { return dp [ mask ] ; } int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( i != j && ( mask & ( 1 << i ) ) == 0 && ( mask & ( 1 << j ) ) == 0 ) { max_value = Math . Max ( max_value , ( a [ i ] ^ a [ j ] ) + xorSum ( a , n , ( mask | ( 1 << i ) | ( 1 << j ) ) , dp ) ) ; } } } return dp [ mask ] = max_value ; }
int maxValue ( int [ ] a , int n , int pos , int moves , int left , int [ , ] dp ) { if ( moves == 0 || ( pos > n - 1 pos < 0 ) ) return 0 ; if ( dp [ pos , left ] != - 1 ) return dp [ pos , left ] ; int value = 0 ; if ( left > 0 && pos >= 1 ) value = Math . Max ( value , a [ pos ] + maxValue ( a , n , pos - 1 , moves - 1 , left - 1 , dp ) ) ; if ( pos <= n - 1 ) value = Math . Max ( value , a [ pos ] + maxValue ( a , n , pos + 1 , moves - 1 , left , dp ) ) ; return dp [ pos , left ] = value ; }
int maximumSum ( int [ ] a , int count , int index , int n , int [ , ] dp ) { if ( index == n ) return 0 ; if ( dp [ index , count ] != - 1 ) return dp [ index , count ] ; int take_element = a [ index ] * count + maximumSum ( a , count + 1 , index + 1 , n , dp ) ; int dont_take = maximumSum ( a , count , index + 1 , n , dp ) ; return dp [ index , count ] = Math . Max ( take_element , dont_take ) ; }
void fibonacci ( ) { fib [ 1 ] = 1 ; fib [ 2 ] = 2 ; for ( int i = 3 ; i <= 87 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } }
long find ( long num ) { int cnt = 0 ; for ( int i = 87 ; i > 0 ; i -- ) { if ( num >= fib [ i ] ) { v [ cnt ++ ] = i ; num -= fib [ i ] ; } } for ( int i = 0 ; i < cnt / 2 ; i ++ ) { long t = v [ i ] ; v [ i ] = v [ cnt - i - 1 ] ; v [ cnt - i - 1 ] = t ; } dp1 [ 0 ] = 1 ; dp2 [ 0 ] = ( v [ 0 ] - 1 ) / 2 ; for ( int i = 1 ; i < cnt ; i ++ ) { dp1 [ i ] = dp1 [ i - 1 ] + dp2 [ i - 1 ] ; dp2 [ i ] = ( ( v [ i ] - v [ i - 1 ] ) / 2 ) * dp2 [ i - 1 ] + ( ( v [ i ] - v [ i - 1 ] - 1 ) / 2 ) * dp1 [ i - 1 ] ; } return ( dp1 [ cnt - 1 ] + dp2 [ cnt - 1 ] ) ; }
int [ ] preprocess ( int [ ] a , int n ) { int [ ] p = new int [ n ] ; p [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) p [ i ] = p [ i - 1 ] + a [ i ] ; return p ; }
int Combine ( int [ ] p , int i , int j ) { if ( i == 0 ) return p [ j ] ; else return p [ j ] - p [ i - 1 ] ; }
int minCost ( int [ ] a , int i , int j , int k , int [ ] prefix , int [ , ] dp ) { if ( i >= j ) return 0 ; if ( dp [ i , j ] != - 1 ) return dp [ i , j ] ; int best_cost = inf ; for ( int pos = i ; pos < j ; pos ++ ) { int left = minCost ( a , i , pos , k , prefix , dp ) ; int right = minCost ( a , pos + 1 , j , k , prefix , dp ) ; best_cost = Math . Min ( best_cost , left + right + ( k * Combine ( prefix , i , j ) ) ) ; } return dp [ i , j ] = best_cost ; }
void countNums ( int N ) { int l = ( int ) Math . Pow ( 10 , N - 1 ) , r = ( int ) Math . Pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int xor = 0 , temp = i ; while ( temp > 0 ) { xor = xor ^ ( temp % 10 ) ; temp /= 10 ; } if ( xor <= 9 ) count ++ ; } Console . WriteLine ( count ) ; }
int distinctSimilarSubstrings ( string str ) { int n = str . Length ; if ( n <= 1 ) return 0 ; long [ , ] dp = new long [ n + 1 , n + 1 ] ; List < string > list = new List < string > ( ) ; for ( int j = n - 1 ; j >= 0 ; j -- ) { for ( int i = j - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == str [ j ] ) { dp [ i , j ] = dp [ i + 1 , j + 1 ] + 1 ; } else { dp [ i , j ] = 0 ; } if ( dp [ i , j ] >= j - i ) { list . Add ( str . Substring ( i , j - i ) ) ; } } } return list . Count ; }
void SubarrayWithMaxSum ( List < int > nums ) { int endIndex = 0 , currMax = nums [ 0 ] ; int globalMax = nums [ 0 ] ; for ( int i = 1 ; i < nums . Count ; ++ i ) { currMax = Math . Max ( nums [ i ] , nums [ i ] + currMax ) ; if ( currMax > globalMax ) { globalMax = currMax ; endIndex = i ; } } int startIndex = endIndex ; while ( startIndex >= 0 ) { globalMax -= nums [ startIndex ] ; if ( globalMax == 0 ) break ; startIndex -- ; } for ( int i = startIndex ; i <= endIndex ; ++ i ) { Console . Write ( nums [ i ] + " " ) ; } }
int count ( int [ ] a , int M , int N ) { int cnt = 0 ; for ( int i = 1 ; i <= M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i % a [ j ] == 0 ) { cnt ++ ; break ; } } } return cnt ; }
void sieve ( ) { primes = new List < int > ( ) ; bool [ ] mark = new bool [ M ] ; for ( int i = 2 ; i < M ; i ++ ) mark [ i ] = true ; for ( int i = 2 ; i * i < M ; i ++ ) { if ( mark [ i ] ) { for ( int j = i * i ; j < M ; j += i ) mark [ j ] = false ; } } for ( int i = 2 ; i < M ; i ++ ) if ( mark [ i ] ) primes . Add ( i ) ; }
void countPrimonacci ( int l , int r ) { List < int > dp = new List < int > ( ) ; dp . Add ( 1 ) ; dp . Add ( 1 ) ; int i = 2 ; HashSet < int > s = new HashSet < int > ( ) ; while ( true ) { int x = 0 ; for ( int j = 0 ; j < primes . Count ; j ++ ) { int p = primes [ j ] ; if ( p >= i ) break ; x += dp [ i - p ] ; } if ( x >= l && x <= r ) s . Add ( x ) ; if ( x > r ) break ; dp . Add ( x ) ; i ++ ; } Console . WriteLine ( s . Count ) ; }
long minSum ( int n , int [ ] num , int [ ] price ) { long [ ] dp = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = int . MaxValue ; long ans = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( num [ j ] > num [ i ] ) { dp [ j ] = ( long ) Math . Min ( ( long ) dp [ j ] , ( long ) price [ i ] + ( long ) price [ j ] ) ; ans = Math . Min ( ans , ( long ) dp [ i ] + ( long ) price [ j ] ) ; } } } return ans != int . MaxValue ? ans : - 1 ; }
void SieveOfEratosthenes ( ) { Array . Fill ( prime , 1 ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * p ; i <= MAX - 1 ; i += p ) prime [ i ] = 0 ; } } }
int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; }
int getSumUtil ( int [ ] st , int ss , int se , int qs , int qe , int si ) { if ( qs <= ss && qe >= se ) return st [ si ] ; if ( se < qs ss > qe ) return 0 ; int mid = getMid ( ss , se ) ; return getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ; }
void updateValueUtil ( int [ ] st , int ss , int se , int i , int diff , int si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } }
void updateValue ( int [ ] arr , int [ ] st , int n , int i , int new_val ) { if ( i < 0 i > n - 1 ) { Console . Write ( "-1" ) ; return ; } int diff = new_val - arr [ i ] ; int prev_val = arr [ i ] ; arr [ i ] = new_val ; if ( ( prime [ new_val ] prime [ prev_val ] ) ! = 0 ) { if ( prime [ prev_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) ; else if ( prime [ new_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) ; else updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; } }
int getSum ( int [ ] st , int n , int qs , int qe ) { if ( qs < 0 qe > n - 1 qs > qe ) { Console . WriteLine ( "-1" ) ; return - 1 ; } return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; }
long countStrings ( int N ) { if ( N % 2 == 1 ) return 0 ; else { N /= 2 ; long c = binomialCoeff ( 2 * N , N ) ; return c / ( N + 1 ) ; } }
int solve ( int n , int k , int mod , int [ ] dp ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; int cnt = 0 ; for ( int i = 2 ; i <= k ; i += 2 ) { cnt = ( cnt % mod + solve ( n - i , k , mod , dp ) % mod ) % mod ; } dp [ n ] = cnt ; return cnt ; }
void fact ( ) { f [ 0 ] = f [ 1 ] = 1 ; for ( int i = 2 ; i <= 10 ; i ++ ) f [ i ] = i * 1 * f [ i - 1 ] ; }
void dfs2 ( int a , int par ) { foreach ( Tuple < int , int > i in v [ a ] ) { if ( i . Item1 == par ) continue ; int leafOutside = leaves [ a ] - leaves [ i . Item1 ] ; dp [ i . Item1 ] += ( dp [ a ] - dp [ i . Item1 ] ) ; dp [ i . Item1 ] += i . Item2 * ( leafOutside - leaves [ i . Item1 ] ) ; leaves [ i . Item1 ] += leafOutside ; dfs2 ( i . Item1 , a ) ; } }
int countPairs ( Node first , Node second , int value ) { int count = 0 ; while ( first != null && second != null && first != second && second . next != first ) { if ( ( first . data + second . data ) == value ) { count ++ ; first = first . next ; second = second . prev ; } else if ( ( first . data + second . data ) > value ) second = second . prev ; else first = first . next ; } return count ; }
int countTriplets ( Node head , int x ) { if ( head == null ) return 0 ; Node current , first , last ; int count = 0 ; last = head ; while ( last . next != null ) last = last . next ; for ( current = head ; current != null ; current = current . next ) { first = current . next ; count += countPairs ( first , last , x - current . data ) ; } return count ; }
int countChanges ( int [ , ] matrix , int n , int m ) { int i , j , dist = n + m - 1 ; int Max_element = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { Max_element = Math . Max ( Max_element , matrix [ i , j ] ) ; } } int [ , ] freq = new int [ dist , Max_element + 1 ] ; for ( i = 0 ; i < dist ; i ++ ) { for ( j = 0 ; j < Max_element + 1 ; j ++ ) freq [ i , j ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { freq [ i + j , matrix [ i , j ] ] ++ ; } } int min_changes_sum = 0 ; for ( i = 0 ; i < dist / 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ; for ( j = 0 ; j < Max_element + 1 ; j ++ ) { maximum = Math . Max ( maximum , freq [ i , j ] + freq [ n + m - 2 - i , j ] ) ; total_values += freq [ i , j ] + freq [ n + m - 2 - i , j ] ; } min_changes_sum += total_values - maximum ; } return min_changes_sum ; }
void maxLength ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = 1 ; } for ( int i = n - 1 ; i > 1 ; i -- ) { for ( int j = 1 ; j <= Math . Sqrt ( i ) ; j ++ ) { if ( i % j == 0 ) { int s = i / j ; if ( s == j ) { if ( arr [ i ] > arr [ s ] ) { dp [ s ] = Math . Max ( dp [ i ] + 1 , dp [ s ] ) ; } } else { if ( s != i && arr [ i ] > arr [ s ] ) dp [ s ] = Math . Max ( dp [ i ] + 1 , dp [ s ] ) ; if ( arr [ i ] > arr [ j ] ) { dp [ j ] = Math . Max ( dp [ i ] + 1 , dp [ j ] ) ; } } } } } int max = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( dp [ i ] > max ) max = dp [ i ] ; } Console . WriteLine ( max ) ; }
int maxProfit ( int [ ] price , int n ) { int buy1 , profit1 , buy2 , profit2 ; buy1 = buy2 = int . MaxValue ; profit1 = profit2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { buy1 = Math . Min ( buy1 , price [ i ] ) ; profit1 = Math . Max ( profit1 , price [ i ] - buy1 ) ; buy2 = Math . Min ( buy2 , price [ i ] - profit1 ) ; profit2 = Math . Max ( profit2 , price [ i ] - buy2 ) ; } return profit2 ; }
int validsubsequences ( int [ ] arr , int n ) { long [ , ] dp = new long [ n + 1 , 2 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i , 0 ] = 0 ; dp [ i , 1 ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 != 0 ) { dp [ i , 1 ] += 1 ; dp [ i , 1 ] += dp [ i - 1 , 0 ] ; dp [ i , 1 ] += dp [ i - 1 , 1 ] ; dp [ i , 0 ] += dp [ i - 1 , 0 ] ; } else { dp [ i , 0 ] += 1 ; dp [ i , 0 ] += dp [ i - 1 , 1 ] ; dp [ i , 0 ] += dp [ i - 1 , 0 ] ; dp [ i , 1 ] += dp [ i - 1 , 1 ] ; } } return ( int ) ( dp [ n , 0 ] + dp [ n , 1 ] ) ; }
long getCount ( int n , int k ) { if ( n == 1 ) return 10 ; long [ , ] dp = new long [ n + 1 , 11 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 1 , i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { int l = Math . Max ( 0 , j - k ) ; int r = Math . Min ( 9 , j + k ) ; dp [ i , l ] += dp [ i - 1 , j ] ; dp [ i , r + 1 ] -= dp [ i - 1 , j ] ; } for ( int j = 1 ; j <= 9 ; j ++ ) dp [ i , j ] += dp [ i , j - 1 ] ; } long count = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) count += dp [ n , i ] ; return count ; }
bool existPath ( int V , int [ , ] edges , int u , int v ) { bool [ , ] mat = new bool [ V , V ] ; for ( int i = 0 ; i < X ; i ++ ) mat [ edges [ i , 0 ] , edges [ i , 1 ] ] = true ; for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { mat [ i , j ] = mat [ i , j ] || mat [ i , k ] && mat [ k , j ] ; } } } if ( u >= V v >= V ) { return false ; } if ( mat [ u , v ] ) return true ; return false ; }
int calculate_maximum_splits ( int [ ] arr , int N ) { int [ ] pre = { 0 , - 1 , - 1 } ; int [ ] dp = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = 0 ; } int C = 0 ; for ( int i = 0 ; i < N ; i ++ ) { C = C + arr [ i ] ; C = C % 3 ; if ( pre [ C ] == - 1 ) { if ( 1 <= i ) dp [ i ] = dp [ i - 1 ] ; } else { dp [ i ] = Math . Max ( dp [ i - 1 ] , dp [ pre [ C ] ] + 1 ) ; } pre [ C ] = i ; } return dp [ N - 1 ] ; }
int solve ( int n , int last , int k ) { if ( n == 1 ) { if ( last == k ) { return ( k - 1 ) ; } else { return 1 ; } } if ( dp [ n , last ] == 1 ) return dp [ n , last ] ; if ( last == k ) { return dp [ n , last ] = ( k - 1 ) * solve ( n - 1 , k , k ) + ( k - 1 ) * solve ( n - 1 , 1 , k ) ; } else { return dp [ n , last ] = solve ( n - 1 , k , k ) ; } }
int mergeTwoNumbers ( int [ ] numbers ) { int len , i , j , k ; int n = numbers . Length ; if ( numbers . Length == 0 ) { return 0 ; } int [ ] prefixSum = new int [ n + 1 ] ; for ( i = 1 ; i <= n ; i ++ ) { prefixSum [ i ] = prefixSum [ i - 1 ] + numbers [ i - 1 ] ; } int [ , ] dp = new int [ n + 1 , n + 1 ] ; for ( len = 2 ; len <= n ; len ++ ) { for ( i = 1 ; i <= n - len + 1 ; i ++ ) { j = i + len - 1 ; int sum = prefixSum [ j ] - prefixSum [ i - 1 ] ; dp [ i , j ] = int . MaxValue ; for ( k = i ; k < j ; k ++ ) { dp [ i , j ] = Math . Min ( dp [ i , j ] , dp [ i , k ] + dp [ k + 1 , j ] + sum ) ; } } } return dp [ 1 , n ] ; }
void seiveOfEratosthenes ( ) { for ( int i = 2 ; i < 1000001 ; i ++ ) { prime [ i ] = 1 ; } for ( int i = 2 ; i * i < 1000001 ; i ++ ) { if ( prime [ i ] == 1 ) { for ( int j = i * i ; j < 1000001 ; j += i ) { prime [ j ] = 0 ; } } } }
List < int > constructPath ( int u , int v ) { if ( Next [ u , v ] == - 1 ) return null ; List < int > path = new List < int > ( ) ; path . Add ( u ) ; while ( u != v ) { u = Next [ u , v ] ; path . Add ( u ) ; } return path ; }
void floydWarshall ( int V ) { for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( dis [ i , k ] == INF dis [ k , j ] == INF ) continue ; if ( dis [ i , j ] > dis [ i , k ] + dis [ k , j ] ) { dis [ i , j ] = dis [ i , k ] + dis [ k , j ] ; Next [ i , j ] = Next [ i , k ] ; } } } } }
int maximumSum ( int [ ] A , int [ ] B , int length , int X , int Y ) { int l = length ; int l1 = Math . Min ( length , X ) ; int l2 = Math . Min ( length , Y ) ; int [ , ] dp = new int [ l1 + 1 , l2 + 1 ] ; int max_sum = int . MinValue ; for ( int i = 1 ; i <= l1 ; i ++ ) { dp [ i , 0 ] = dp [ i - 1 , 0 ] + A [ i - 1 ] ; max_sum = Math . Max ( max_sum , dp [ i , 0 ] ) ; } for ( int i = 1 ; i <= l2 ; i ++ ) { dp [ 0 , i ] = dp [ 0 , i - 1 ] + B [ i - 1 ] ; max_sum = Math . Max ( max_sum , dp [ 0 , i ] ) ; } for ( int i = 1 ; i <= l1 ; i ++ ) { for ( int j = 1 ; j <= l2 ; j ++ ) { if ( i + j <= l ) dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] + A [ i + j - 1 ] , dp [ i , j - 1 ] + B [ i + j - 1 ] ) ; max_sum = Math . Max ( dp [ i , j ] , max_sum ) ; } } return max_sum ; }
void finding_factors ( int n ) { int i ; for ( i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i == n ) { vp [ n ] . Add ( i ) ; } else { vp [ n ] . Add ( i ) ; vp [ n ] . Add ( n / i ) ; } } } }
int countSeq ( int N , int K ) { int i , j , k ; int [ , ] dp = new int [ 109 , 109 ] ; for ( i = 1 ; i <= N ; i ++ ) { finding_factors ( i ) ; dp [ 0 , i ] = 0 ; dp [ 1 , i ] = 1 ; } for ( i = 2 ; i <= K ; i ++ ) { for ( j = 1 ; j <= N ; j ++ ) { int sum = 0 ; for ( k = 0 ; k < vp [ j ] . Count ; k ++ ) { sum = ( sum + dp [ i - 1 , vp [ j ] [ k ] ] ) ; } dp [ i , j ] = sum ; } } int ans = 0 ; for ( j = 1 ; j <= N ; j ++ ) { ans = ( ans + dp [ K , j ] ) ; } return ans ; }
void find_minimum_operations ( int n , int [ ] b , int k ) { int [ ] d = new int [ n + 1 ] ; int i , operations = 0 , need ; for ( i = 0 ; i < n ; i ++ ) { if ( i > 0 ) { d [ i ] += d [ i - 1 ] ; } if ( b [ i ] > d [ i ] ) { operations += b [ i ] - d [ i ] ; need = b [ i ] - d [ i ] ; d [ i ] += need ; if ( i + k <= n ) { d [ i + k ] -= need ; } } } Console . Write ( operations ) ; }
void sieve ( ) { for ( int i = 0 ; i < primes . Length ; i ++ ) { primes [ i ] = true ; } primes [ 0 ] = false ; primes [ 1 ] = false ; for ( int i = 2 ; i * i <= maxn ; i ++ ) { if ( primes [ i ] ) { for ( int j = i * i ; j <= maxn ; j += i ) primes [ j ] = false ; } } }
int printpentaRec ( int n ) { if ( n == 0 n == 1 n == 2 n == 3 n == 4 ) return 0 ; else if ( n == 5 ) return 1 ; else return ( printpentaRec ( n - 1 ) + printpentaRec ( n - 2 ) + printpentaRec ( n - 3 ) + printpentaRec ( n - 4 ) + printpentaRec ( n - 5 ) ) ; }
int possibleBinaries ( int pos , int ones , int sum , int k ) { if ( ones == k ) return 0 ; if ( pos == 0 ) return ( sum == 0 ) ? 1 : 0 ; if ( dp [ pos , ones , sum ] != - 1 ) return dp [ pos , ones , sum ] ; int ret = possibleBinaries ( pos - 1 , ones + 1 , ( sum + 1 ) % 2 , k ) + possibleBinaries ( pos - 1 , 0 , sum , k ) ; dp [ pos , ones , sum ] = ret ; return dp [ pos , ones , sum ] ; }
int MAX_value ( int [ , ] arr ) { int row = arr . GetLength ( 0 ) ; int col = arr . GetLength ( 1 ) ; int [ , ] dp = new int [ row , col ] ; int i = 0 , j = 0 ; int c = arr [ 0 , 0 ] , p = 0 ; int d = row ; for ( i = 0 ; i < d ; i ++ ) { for ( j = 0 ; j < d ; j ++ ) { if ( c < arr [ i , j ] ) { c = arr [ i , j ] ; } if ( i == 0 j == 0 ) { dp [ i , j ] = 1 ; } else { if ( arr [ i - 1 , j - 1 ] == arr [ i , j ] && arr [ i - 1 , j ] == arr [ i , j ] && arr [ i , j - 1 ] == arr [ i , j ] ) { dp [ i , j ] = Math . Min ( dp [ i - 1 , j - 1 ] , Math . Min ( dp [ i - 1 , j ] , dp [ i , j - 1 ] ) ) + 1 ; } else { dp [ i , j ] = 1 ; } } } } for ( i = 0 ; i < d ; i ++ ) { for ( j = 0 ; j < d ; j ++ ) { if ( arr [ i , j ] == c ) { if ( p < dp [ i , j ] ) { p = dp [ i , j ] ; } } } } return p * p ; }
void printList ( Node head ) { if ( head == null ) Console . Write ( "Doubly Linked list empty" ) ; while ( head != null ) { Console . Write ( head . data + " " ) ; head = head . next ; } }
int countStableNum ( String str , int N ) { int [ , ] count1 = new int [ N , 10 ] ; int [ , ] count2 = new int [ N , 10 ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < 10 ; j ++ ) count1 [ i , j ] = count2 [ i , j ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i != 0 ) { for ( int j = 0 ; j < 10 ; j ++ ) { count1 [ i , j ] += count1 [ i - 1 , j ] ; } } count1 [ i , str [ i ] - '0' ] ++ ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i != N - 1 ) { for ( int j = 0 ; j < 10 ; j ++ ) { count2 [ i , j ] += count2 [ i + 1 , j ] ; } } count2 [ i , str [ i ] - '0' ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { if ( str [ i ] == '9' ) continue ; int c1 = count1 [ i - 1 , str [ i ] - '0' ] ; int c2 = count2 [ i + 1 , str [ i ] - '0' + 1 ] ; if ( c2 == 0 ) continue ; ans = ( ans + ( c1 * ( ( c2 * ( c2 - 1 ) / 2 ) ) ) ) ; } return ans ; }
long countWays ( string s , string t , int k ) { int n = s . Length ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string p = s . Substring ( i , n - i ) + s . Substring ( 0 , i ) ; if ( p == t ) a ++ ; else b ++ ; } long [ ] dp1 = new long [ k + 1 ] ; long [ ] dp2 = new long [ k + 1 ] ; if ( s == t ) { dp1 [ 0 ] = 1 ; dp2 [ 0 ] = 0 ; } else { dp1 [ 0 ] = 0 ; dp2 [ 0 ] = 1 ; } for ( int i = 1 ; i <= k ; i ++ ) { dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ; dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ; } return dp1 [ k ] ; }
void dfs1 ( int u , int par , List < List < int > > g , int [ ] weight ) { dp1 [ u ] = weight [ u ] ; for ( int c = 0 ; c < g [ u ] . Count ; c ++ ) { if ( g [ u ] != par ) { dfs1 ( g [ u ] , u , g , weight ) ; dp1 [ u ] += Math . Max ( 0 , dp1 [ g [ u ] ] ) ; } } }
void dfs2 ( int u , int par , List < List < int > > g , int [ ] weight ) { if ( par != 0 ) { int maxSumAncestors = dp2 [ par ] - Math . Max ( 0 , dp1 [ u ] ) ; dp2 [ u ] = dp1 [ u ] + Math . Max ( 0 , maxSumAncestors ) ; } for ( int c = 0 ; c < g [ u ] . Count ; c ++ ) { if ( g [ u ] != par ) { dfs2 ( g [ u ] , u , g , weight ) ; } } }
void addEdge ( int u , int v , List < List < int > > g ) { g [ u ] . Add ( v ) ; g [ v ] . Add ( u ) ; }
void maxSumSegments ( List < List < int > > g , int [ ] weight , int n ) { dfs1 ( 1 , 0 , g , weight ) ; for ( int i = 1 ; i < n + 1 ; i ++ ) dp2 [ i ] = dp1 [ i ] ; dfs2 ( 1 , 0 , g , weight ) ; }
void printAns ( int n ) { for ( int i = 1 ; i < n ; i ++ ) Console . Write ( dp2 [ i ] + " " ) ; }
void countMaximum ( int [ ] a , int n ) { a . OrderByDescending ( c => c ) . ToArray ( ) ; int count = 0 ; int mark = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( a [ i ] + n >= mark ) ) { count += 1 ; } mark = Math . Max ( mark , a [ i ] + i + 1 ) ; } Console . Write ( count ) ; }
int CountWays ( int i , int j , int k ) { if ( i >= N i < 0 >= < 0 < 0 ) return 0 ; if ( i == 0 && j == 0 && k == 0 ) return 1 ; if ( dp [ i , j , k ] != - 1 ) return dp [ i , j , k ] ; else dp [ i , j , k ] = ( CountWays ( i + 1 , j , k - 1 ) % MOD + CountWays ( i - 1 , j , k - 1 ) % MOD + CountWays ( i , j - 1 , k - 1 ) % MOD + CountWays ( i , j + 1 , k - 1 ) % MOD + CountWays ( i , j , k - 1 ) % MOD ) % MOD ; return dp [ i , j , k ] ; }
int smallestNum ( int n ) { for ( int i = 2 ; ; i *= 2 ) { int length = ( int ) ( Math . Log10 ( i ) ) + 1 ; if ( length == n ) return ( int ) ( Math . Log ( i ) / Math . Log ( 2 ) ) ; } }
int findResultUtil ( int [ ] arr , int L , int R ) { int result = 0 ; bool flag = false ; for ( int i = L ; i <= R ; i ++ ) { if ( flag == false ) { result = result + arr [ i ] ; flag = true ; } else { result = result - arr [ i ] ; flag = false ; } } return result ; }
bool isKPartitionPossible ( int [ ] arr , int N , int K ) { if ( K == 1 ) return true ; if ( N < K ) return false ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % K != 0 ) return false ; int target = sum / K ; int [ ] dp = new int [ ( 1 << 15 ) ] ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( int mask = 0 ; mask < ( 1 << N ) ; mask ++ ) { if ( dp [ mask ] == - 1 ) continue ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( ( mask & ( 1 << i ) ) == 0 ) && dp [ mask ] + arr [ i ] <= target ) { dp [ mask ( 1 << i ) ] = ( dp [ mask ] + arr [ i ] ) % target ; } } } if ( dp [ ( 1 << N ) - 1 ] == 0 ) return true ; else return false ; }
long min_operation ( long i , long j , long val , long x ) { if ( i == n - 1 && j == m - 1 ) { if ( val > v [ ( int ) i ] [ ( int ) j ] ) { return dp [ ( int ) i , ( int ) j ] = MAX ; } else { return dp [ ( int ) i , ( int ) j ] = v [ ( int ) i ] [ ( int ) j ] - val ; } } if ( i == n j == m ) { return dp [ ( int ) i , ( int ) j ] = MAX ; } if ( dp [ ( int ) i , ( int ) j ] != - 1 ) { return dp [ ( int ) i , ( int ) j ] ; } if ( val > v [ ( int ) i ] [ ( int ) j ] ) { return dp [ ( int ) i , ( int ) j ] = MAX ; } long temp = v [ ( int ) i ] [ ( int ) j ] - val ; temp += Math . Min ( min_operation ( i + 1 , j , val + x , x ) , min_operation ( i , j + 1 , val + x , x ) ) ; return dp [ ( int ) i , ( int ) j ] = temp ; }
long solve ( long x ) { long ans = Int64 . MaxValue ; for ( long i = 0 ; i < n ; i ++ ) { for ( long j = 0 ; j < m ; j ++ ) { long val = v [ ( int ) i ] [ ( int ) j ] - x * ( i + j ) ; for ( long k = 0 ; k < dp . GetLength ( 0 ) ; k ++ ) { for ( long l = 0 ; l < dp . GetLength ( 1 ) ; l ++ ) { dp [ k , l ] = - 1 ; } } val = min_operation ( 0 , 0 , val , x ) ; ans = Math . Min ( ans , val ) ; } } return ans ; }
void printList ( Node head ) { if ( head == null ) Console . WriteLine ( "Doubly Linked list empty" ) ; while ( head != null ) { Console . Write ( head . data + " " ) ; head = head . next ; } }
int Count ( int [ ] S , int m , int n ) { int [ , ] table = new int [ m + 1 , n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { table [ 0 , i ] = int . MaxValue - 1 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( S [ i - 1 ] > j ) { table [ i , j ] = table [ i - 1 , j ] ; } else { table [ i , j ] = Math . Min ( table [ i - 1 , j ] , table [ i , j - S [ i - 1 ] ] + 1 ) ; } } } return table [ m , n ] ; }
int maxProductUtil ( int X , int Y , int [ ] A , int [ ] B , int [ , ] dp ) { if ( X < 0 Y < 0 ) return - INF ; if ( dp [ X , Y ] != - 1 ) return dp [ X , Y ] ; dp [ X , Y ] = maximum ( A [ X ] * B [ Y ] + maxProductUtil ( X - 1 , Y - 1 , A , B , dp ) , A [ X ] * B [ Y ] , maxProductUtil ( X - 1 , Y , A , B , dp ) , maxProductUtil ( X , Y - 1 , A , B , dp ) ) ; return dp [ X , Y ] ; }
int maxProduct ( int [ ] A , int N , int [ ] B , int M ) { int [ , ] dp = new int [ N , M ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { dp [ i , j ] = - 1 ; } } return maxProductUtil ( N - 1 , M - 1 , A , B , dp ) ; }
int minOperation ( int k ) { int [ ] dp = new int [ k + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = Math . Min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; }
int maximumSum ( int S , int M , int N , int [ , ] stacks ) { int [ , ] dp = new int [ S + 1 , N + 1 ] ; for ( int i = 0 ; i < S ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { for ( int k = 0 ; k <= Math . Min ( j , M ) ; k ++ ) { dp [ i + 1 , j ] = Math . Max ( dp [ i + 1 , j ] , stacks [ i , k ] + dp [ i , j - k ] ) ; } } } int result = int . MinValue ; for ( int i = 0 ; i <= N ; i ++ ) { result = Math . Max ( result , dp [ S , i ] ) ; } return result ; }
int findSum ( int [ ] arr , int n ) { int totalSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; } int [ , ] dp = new int [ 2 , n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ 0 , i ] = 1 ; dp [ 1 , i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { if ( dp [ 0 , i ] < dp [ 0 , j ] + 1 ) { dp [ 0 , i ] = dp [ 0 , j ] + 1 ; dp [ 1 , i ] = dp [ 1 , j ] + arr [ i ] ; } else if ( dp [ 0 , i ] == dp [ 0 , j ] + 1 ) { dp [ 1 , i ] = Math . Min ( dp [ 1 , i ] , dp [ 1 , j ] + arr [ i ] ) ; } } } } int maxm = 0 ; int subtractSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ 0 , i ] > maxm ) { maxm = dp [ 0 , i ] ; subtractSum = dp [ 1 , i ] ; } else if ( dp [ 0 , i ] == maxm ) { subtractSum = Math . Min ( subtractSum , dp [ 1 , i ] ) ; } } return totalSum - subtractSum ; }
int count ( int n ) { if ( n == 2 ) return 1 ; else if ( n == 4 ) return 2 ; else if ( n == 6 ) return 4 ; int [ ] table = new int [ n + 1 ] ; int i ; for ( i = 0 ; i < n + 1 ; i ++ ) table [ i ] = 0 ; table [ 0 ] = 0 ; table [ 2 ] = 1 ; table [ 4 ] = 2 ; table [ 6 ] = 4 ; for ( i = 8 ; i <= n ; i = i + 2 ) { table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] ; } return table [ n ] ; }
bool isPrime ( String number ) { int num = Int32 . Parse ( number ) ; for ( int i = 2 ; i * i <= num ; i ++ ) { if ( ( num % i ) == 0 ) return false ; } return num > 1 ? true : false ; }
int countPrimeStrings ( String number , int i ) { if ( i == 0 ) return 1 ; int cnt = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 && number [ i - j ] != '0' && isPrime ( number . Substring ( i - j , j ) ) ) { cnt += countPrimeStrings ( number , i - j ) ; cnt %= MOD ; } } return cnt ; }
void buildSieve ( ) { for ( int j = 0 ; j < sieve . Length ; j ++ ) sieve [ j ] = true ; sieve [ 0 ] = false ; sieve [ 1 ] = false ; for ( int p = 2 ; p * p <= 1000000 ; p ++ ) { if ( sieve [ p ] == true ) { for ( int i = p * p ; i < 1000000 ; i += p ) sieve [ i ] = false ; } } }
bool isPrime ( String number ) { int num = Int32 . Parse ( number ) ; return sieve [ num ] ; }
int rec ( String number , int i , int [ ] dp ) { if ( dp [ i ] != - 1 ) return dp [ i ] ; int cnt = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 && number [ i - j ] != '0' && isPrime ( number . Substring ( i - j , j ) ) ) { cnt += rec ( number , i - j , dp ) ; cnt %= MOD ; } } return dp [ i ] = cnt ; }
int countPrimeStrings ( String number ) { int n = number . Length ; int [ ] dp = new int [ n + 1 ] ; for ( int j = 0 ; j < dp . Length ; j ++ ) dp [ j ] = - 1 ; dp [ 0 ] = 1 ; return rec ( number , n , dp ) ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < prime . Length ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p < 100000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 100000 ; i += p ) prime [ i ] = false ; } } }
int distinctPrimeSubSeq ( int [ ] a , int n , int k ) { SieveOfEratosthenes ( ) ; List < int > primes = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ a [ i ] ] ) primes . Add ( a [ i ] ) ; } int l = primes . Count ; primes . Sort ( ) ; List < int > b = new List < int > ( ) ; List < int > dp = new List < int > ( ) ; int sum = 0 ; for ( int i = 0 ; i < l ; ) { int count = 1 , x = a [ i ] ; i ++ ; while ( i < l && a [ i ] == x ) { count ++ ; i ++ ; } b . Add ( count ) ; dp . Add ( count ) ; sum += count ; } int of_length = 2 ; int len = dp . Count ; int ans = 0 ; while ( of_length <= k ) { int freq = 0 ; int prev = 0 ; for ( int i = 0 ; i < ( len ) ; i ++ ) { freq += dp [ i ] ; int j = sum - freq ; int subseq = b [ i ] * j ; ans += subseq ; dp [ i ] = subseq ; prev += dp [ i ] ; } len -- ; sum = prev ; of_length ++ ; } ans += ( l + 1 ) ; return ans ; }
int ways ( int [ , ] arr , int K ) { int R = arr . GetLength ( 0 ) ; int C = arr . GetLength ( 1 ) ; int [ , ] preSum = new int [ R , C ] ; for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { preSum [ r , c ] = arr [ r , c ] ; if ( r + 1 < R ) preSum [ r , c ] += preSum [ r + 1 , c ] ; if ( c + 1 < C ) preSum [ r , c ] += preSum [ r , c + 1 ] ; if ( r + 1 < R && c + 1 < C ) preSum [ r , c ] -= preSum [ r + 1 , c + 1 ] ; } } int [ , , ] dp = new int [ K + 1 , R , C ] ; for ( int k = 1 ; k <= K ; k ++ ) { for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { if ( k == 1 ) { dp [ k , r , c ] = ( preSum [ r , c ] > 0 ) ? 1 : 0 ; } else { dp [ k , r , c ] = 0 ; for ( int r1 = r + 1 ; r1 < R ; r1 ++ ) { if ( preSum [ r , c ] - preSum [ r1 , c ] > 0 ) dp [ k , r , c ] += dp [ k - 1 , r1 , c ] ; } for ( int c1 = c + 1 ; c1 < C ; c1 ++ ) { if ( preSum [ r , c ] - preSum [ r , c1 ] > 0 ) dp [ k , r , c ] += dp [ k - 1 , r , c1 ] ; } } } } } return dp [ K , 0 , 0 ] ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int sumPathCost ( int [ , ] grid , int m , int n ) { int sum = 0 , count ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { count = nCr ( i + j , i ) * nCr ( m + n - i - j , m - i ) ; sum += count * grid [ i , j ] ; } } return sum ; }
void init ( int x ) { for ( int i = 0 ; i < 20 ; i ++ ) for ( int j = 0 ; j < 1000 ; j ++ ) for ( int k = 0 ; k < 10 ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) for ( int m = 0 ; m < 2 ; m ++ ) dp [ i , j , k , l , m ] = - 1 ; v . Clear ( ) ; while ( x > 0 ) { v . Add ( x % 10 ) ; x /= 10 ; } v . Reverse ( ) ; N = v . Count ; }
void findCount ( int L , int R , int K ) { init ( R ) ; int r_ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; init ( L - 1 ) ; int l_ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; Console . Write ( r_ans - l_ans ) ; }
void dfs_lca ( int a , int par , int lev ) { dp [ 0 , a ] = par ; level [ a ] = lev ; for ( int i = 0 ; i < v [ a ] . Count ; i ++ ) { if ( v [ a ] [ i ] . Item1 == par ) continue ; mx [ 0 , v [ a ] [ i ] . Item1 ] = v [ a ] [ i ] . Item2 ; dfs_lca ( v [ a ] [ i ] . Item1 , a , lev + 1 ) ; } }
void find_ancestor ( ) { for ( int i = 1 ; i < 16 ; i ++ ) { for ( int j = 1 ; j < n + 1 ; j ++ ) { dp [ i , j ] = dp [ i - 1 , dp [ i - 1 , j ] ] ; mx [ i , j ] = Math . Max ( mx [ i - 1 , j ] , mx [ i - 1 , dp [ i - 1 , j ] ] ) ; } } }
int getMax ( int a , int b ) { if ( level [ b ] < level [ a ] ) { int temp = a ; a = b ; b = temp ; } int ans = 0 ; int diff = level [ b ] - level [ a ] ; while ( diff > 0 ) { int log = ( int ) ( Math . Log ( diff ) / Math . Log ( 2 ) ) ; ans = Math . Max ( ans , mx [ log , b ] ) ; b = dp [ log , b ] ; diff -= ( 1 << log ) ; } while ( a != b ) { int i = ( int ) ( Math . Log ( level [ a ] ) / Math . Log ( 2 ) ) ; while ( i > 0 && dp [ i , a ] == dp [ i , b ] ) { i -= 1 ; } ans = Math . Max ( ans , mx [ i , a ] ) ; ans = Math . Max ( ans , mx [ i , b ] ) ; a = dp [ i , a ] ; b = dp [ i , b ] ; } return ans ; }
void compute_lca ( ) { dfs_lca ( 1 , 0 , 0 ) ; find_ancestor ( ) ; }
int dfs ( ArrayList adj , int [ ] order , int [ ] bridge_detect , bool [ ] mark , int v , int l ) { mark [ v ] = true ; order [ v ] = order [ l ] + 1 ; bridge_detect [ v ] = order [ v ] ; for ( int i = 0 ; i < ( ( ArrayList ) adj [ v ] ) . Count ; i ++ ) { int u = ( int ) ( ( ArrayList ) adj [ v ] ) [ i ] ; if ( u == l ) { continue ; } if ( order [ v ] < order [ u ] ) { continue ; } if ( mark [ u ] ) { bridge_detect [ v ] = Math . Min ( order [ u ] , bridge_detect [ v ] ) ; } else { dfs ( adj , order , bridge_detect , mark , u , v ) ; } bridge_detect [ v ] = Math . Min ( bridge_detect [ u ] , bridge_detect [ v ] ) ; ans . Add ( new int [ ] { v , u } ) ; } if ( bridge_detect [ v ] == order [ v ] && l != 0 ) { flag = 0 ; } return flag ; }
void createGraph ( int [ , ] Edges , ArrayList adj , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i , 0 ] ; int v = Edges [ i , 1 ] ; ( ( ArrayList ) adj [ u ] ) . Add ( v ) ; ( ( ArrayList ) adj [ v ] ) . Add ( u ) ; } }
void depthFirst ( int v , List < List < int > > graph , bool [ ] visited , List < int > storeChain ) { visited [ v ] = true ; storeChain . Add ( v ) ; foreach ( int i in graph [ v ] ) { if ( visited [ i ] == false ) { depthFirst ( i , graph , visited , storeChain ) ; } } }
int subarraySum ( int [ ] arr , int n ) { int maxSubarraySum = arr [ 0 ] ; int currentMax = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { currentMax = Math . Max ( arr [ i ] , arr [ i ] + currentMax ) ; maxSubarraySum = Math . Max ( maxSubarraySum , currentMax ) ; } return maxSubarraySum ; }
int get_max_sum ( int [ ] arr , int n ) { Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . ContainsKey ( arr [ i ] ) ) { int x = freq [ arr [ i ] ] ; freq [ arr [ i ] ] = x + 1 ; } else freq . Add ( arr [ i ] , 1 ) ; } int [ ] dp = new int [ 100001 ] ; for ( int i = 0 ; i < 100001 ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 0 ; if ( freq . ContainsKey ( 0 ) ) dp [ 1 ] = freq [ 0 ] ; else dp [ 1 ] = 0 ; for ( int i = 2 ; i <= 100000 ; i ++ ) { int temp = ( freq . ContainsKey ( i ) ) ? freq [ i ] : 0 ; dp [ i ] = Math . Max ( dp [ i - 1 ] , dp [ i - 2 ] + i * temp ) ; } return dp [ 100000 ] ; }
int minFlip ( string a ) { int n = a . Length ; int [ , ] dp = new int [ n + 1 , 2 ] ; dp [ 0 , 0 ] = ( a [ 0 ] == '1' ? 1 : 0 ) ; dp [ 0 , 1 ] = ( a [ 0 ] == '0' ? 1 : 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i , 0 ] = dp [ i - 1 , 0 ] + ( a [ i ] == '1' ? 1 : 0 ) ; dp [ i , 1 ] = Math . Min ( dp [ i - 1 , 0 ] , dp [ i - 1 , 1 ] ) + ( a [ i ] == '0' ? 1 : 0 ) ; } int answer = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { answer = Math . Min ( answer , dp [ i , 1 ] + dp [ n - 1 , 0 ] - dp [ i , 0 ] ) ; } return Math . Min ( answer , dp [ n - 1 , 0 ] ) ; }
int LIIDS ( int [ ] arr , int N ) { int [ ] dp = new int [ N + 1 ] ; int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + i ; j <= N ; j += i ) { if ( j < arr . Length && arr [ j ] > arr [ i ] ) { dp [ j ] = Math . Max ( dp [ j ] , dp [ i ] + 1 ) ; } } ans = Math . Max ( ans , dp [ i ] ) ; } return ans ; }
bool isPerfectSquare ( double x ) { double sr = Math . Sqrt ( x ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ; }
int findSubarraySum ( int [ ] arr , int n , int K ) { Dictionary < int , int > prevSum = new Dictionary < int , int > ( ) ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == K ) { res ++ ; } if ( prevSum . ContainsKey ( currsum - K ) ) res += ( prevSum [ currsum - K ] ) ; if ( prevSum . ContainsKey ( currsum ) ) { prevSum [ currsum ] ++ ; } else { prevSum [ currsum ] = 1 ; } } return res ; }
void countSubarray ( int [ ] arr , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) { if ( isPerfectSquare ( arr [ i ] ) ) { arr [ i ] = 1 ; } else { arr [ i ] = 0 ; } } Console . Write ( findSubarraySum ( arr , n , K ) ) ; }
int calculate ( int pos , int left , int k , int L , int R ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; int answer = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( i > left ) break ; answer = ( ( answer + calculate ( pos + 1 , left - i , k , L , R ) ) % mod ) ; } return answer ; }
int countWaystoDivide ( int n , int k , int L , int R ) { return calculate ( 0 , n , k , L , R ) ; }
int calculate ( int pos , int left , int k , int L , int R ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos , left ] != - 1 ) return dp [ pos , left ] ; int answer = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( i > left ) break ; answer = ( answer + calculate ( pos + 1 , left - i , k , L , R ) ) % mod ; } return dp [ pos , left ] = answer ; }
int countWaystoDivide ( int n , int k , int L , int R ) { for ( int i = 0 ; i < 1000 ; i ++ ) { for ( int j = 0 ; j < 1000 ; j ++ ) { dp [ i , j ] = - 1 ; } } return calculate ( 0 , n , k , L , R ) ; }
void PossibleSum ( int n , int m , int [ , ] v , int k ) { int [ , ] dp = new int [ n + 1 , k + 1 ] ; dp [ 0 , 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= k ; j ++ ) { if ( dp [ i , j ] == 1 ) { for ( int d = 0 ; d < m ; d ++ ) { if ( ( j + v [ i , d ] ) <= k ) { dp [ i + 1 , j + v [ i , d ] ] = 1 ; } } } } } if ( dp [ n , k ] == 1 ) Console . WriteLine ( "YES" ) ; else Console . WriteLine ( "NO" ) ; }
void printList ( Node temp ) { while ( temp != null ) { Console . Write ( temp . info + " " ) ; temp = temp . next ; } }
bool solve ( int [ ] arr , int curr , int mask , int n ) { if ( isprime ( curr ) ) { if ( mask == ( 1 << n ) - 1 ) { return true ; } curr = 0 ; } if ( mask == ( 1 << n ) - 1 ) { if ( ! isprime ( curr ) ) { return false ; } } if ( dp [ mask ] ) return dp [ mask ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( mask & ( 1 << i ) ) == 0 ) { if ( solve ( arr , curr + arr [ i ] , mask 1 << i , n ) ) { return true ; } } } return dp [ mask ] = false ; }
List < int > minSqrNum ( int n ) { int [ ] arr = new int [ n + 1 ] ; int k = 0 ; int [ ] sqrNum = new int [ n + 1 ] ; List < int > v = new List < int > ( ) ; arr [ 0 ] = 0 ; sqrNum [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { arr [ i ] = arr [ i - 1 ] + 1 ; sqrNum [ i ] = 1 ; k = 1 ; while ( k * k <= i ) { if ( arr [ i ] > arr [ i - k * k ] + 1 ) { arr [ i ] = arr [ i - k * k ] + 1 ; sqrNum [ i ] = k * k ; } k ++ ; } } while ( n > 0 ) { v . Add ( sqrNum [ n ] ) ; n -= sqrNum [ n ] ; } return v ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
void nCr ( int n , int p , int [ , ] f , int m ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( j > i ) { f [ i , j ] = 0 ; } else if ( j == 0 j == i ) { f [ i , j ] = 1 ; } else { f [ i , j ] = ( f [ i - 1 , j ] + f [ i - 1 , j - 1 ] ) % p ; } } } }
void sieve ( ) { for ( int i = 0 ; i < 1000 ; i ++ ) isprime [ i ] = true ; for ( int i = 2 ; i * i < 1000 ; i ++ ) { if ( isprime [ i ] ) { for ( int j = i * i ; j < 1000 ; j += i ) { isprime [ j ] = false ; } } } for ( int i = 2 ; i < 1000 ; i ++ ) { if ( isprime [ i ] ) { prime . Add ( i ) ; } } }
int CountWays ( int i , int j , int sum , int n , int k ) { if ( i >= prime . Count - 1 sum > n ) { return 0 ; } if ( sum == n ) { if ( j == k ) { return 1 ; } return 0 ; } if ( j == k ) return 0 ; if ( dp [ i , j , sum ] != 0 ) return dp [ i , j , sum ] ; int inc = 0 , exc = 0 ; inc = CountWays ( i + 1 , j + 1 , sum + prime [ i ] , n , k ) ; exc = CountWays ( i + 1 , j , sum , n , k ) ; return dp [ i , j , sum ] = inc + exc ; }
void createTable ( int [ , ] mtrx , int k , int p , int [ , ] dp ) { dp [ 0 , 0 ] = mtrx [ 0 , 0 ] ; for ( int j = 1 ; j < dim ; j ++ ) { dp [ 0 , j ] = mtrx [ 0 , j ] + dp [ 0 , j - 1 ] ; } for ( int i = 1 ; i < dim ; i ++ ) { dp [ i , 0 ] = mtrx [ i , 0 ] + dp [ i - 1 , 0 ] ; } for ( int i = 1 ; i < dim ; i ++ ) { for ( int j = 1 ; j < dim ; j ++ ) { dp [ i , j ] = mtrx [ i , j ] + dp [ i - 1 , j ] + dp [ i , j - 1 ] - dp [ i - 1 , j - 1 ] ; } } }
int countSubMatrixUtil ( int [ , ] dp , int k , int p ) { int count = 0 ; int subMatSum = 0 ; for ( int i = k - 1 ; i < dim ; i ++ ) { for ( int j = k - 1 ; j < dim ; j ++ ) { if ( i == ( k - 1 ) || j == ( k - 1 ) ) { if ( i == ( k - 1 ) && j == ( k - 1 ) ) { subMatSum = dp [ i , j ] ; } else if ( i == ( k - 1 ) ) { subMatSum = dp [ i , j ] - dp [ i , j - k ] ; } else { subMatSum = dp [ i , j ] - dp [ i - k , j ] ; } } else { subMatSum = dp [ i , j ] - dp [ i - k , j ] - dp [ i , j - k ] + dp [ i - k , j - k ] ; } if ( subMatSum >= p ) { count ++ ; } } } return count ; }
int solve ( int [ ] arr , int i , int len , int prev , int n , int k ) { if ( len == k ) return 0 ; if ( i == n ) return Int32 . MinValue ; if ( dp [ i , len , prev ] != 0 ) return dp [ i , len , prev ] ; int inc = 0 , exc = 0 ; if ( ( len & 1 ) != 0 ) { inc = ( productDigitSum ( arr [ prev ] , arr [ i ] ) + solve ( arr , i + 1 , len + 1 , 0 , n , k ) ) ; } else { inc = solve ( arr , i + 1 , len + 1 , i , n , k ) ; } exc = solve ( arr , i + 1 , len , prev , n , k ) ; return dp [ i , len , prev ] = Math . Max ( inc , exc ) ; }
void precompute ( ) { for ( int i = 0 ; i < factors . Length ; i ++ ) factors [ i ] = new List < int > ( ) ; for ( int i = 1 ; i <= 100000 ; i ++ ) { for ( int j = i ; j <= 100000 ; j += i ) { factors [ j ] . Add ( i ) ; } } }
int solve ( int [ ] arr , int k , int n ) { if ( k == n - 1 ) { return 0 ; } if ( k >= n ) { return int . MaxValue ; } if ( dp [ k ] != 0 ) { return dp [ k ] ; } int ans = int . MaxValue ; foreach ( int j in factors [ arr [ k ] ] ) { int res = solve ( arr , k + j , n ) ; if ( res != int . MaxValue ) { ans = Math . Min ( ans , res + 1 ) ; } } return dp [ k ] = ans ; }
void precompute ( ) { for ( int i = 1 ; i <= 100000 ; i ++ ) { for ( int j = i ; j <= 100000 ; j += i ) factors [ j ] . Add ( i ) ; } }
int solve ( int [ ] arr , int n ) { for ( int i = 0 ; i < 100005 ; i ++ ) { dp [ i ] = int . MaxValue ; } dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { foreach ( int j in factors [ arr [ i ] ] ) { if ( i + j < n ) dp [ i + j ] = Math . Min ( dp [ i + j ] , 1 + dp [ i ] ) ; } } return dp [ n - 1 ] ; }
long operation ( int n ) { dp = new int [ n + 1 , n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { dp [ i , j ] = - 1 ; } } long ans = 0 , fac = 1 ; for ( int k = 1 ; k <= n ; k ++ ) { fac *= k ; ans = ( ans + ( fac * f ( n , k ) ) % mod ) % mod ; } return ans ; }
int countWays ( int n , int m ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 , i ] = 1 ; } int sum ; for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { sum = 0 ; for ( int k = 0 ; k <= j ; k ++ ) { sum += dp [ i - 1 , k ] ; } dp [ i , j ] = sum ; } } return dp [ m , n ] ; }
int countWays ( int n , int m ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 , i ] = 1 ; if ( i != 0 ) { dp [ 1 , i ] += dp [ 1 , i - 1 ] ; } } for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) { dp [ i , j ] = dp [ i - 1 , j ] ; } else { dp [ i , j ] = dp [ i - 1 , j ] ; if ( i == m && j == n ) { return dp [ i , j ] ; } dp [ i , j ] += dp [ i , j - 1 ] ; } } } return Int32 . MinValue ; }
void ConvertIntoDigit ( int n ) { while ( n > 0 ) { int dig = n % 10 ; digits . Add ( dig ) ; n /= 10 ; } digits . Reverse ( ) ; }
int solve ( int idx , int k , int tight , int sum ) { if ( idx == digits . Count && k == 0 && sum % 2 == 1 ) { if ( ! vis [ sum ] ) { vis [ sum ] = true ; return 1 ; } return 0 ; } if ( idx > digits . Count ) { return 0 ; } if ( dp [ idx , k , tight , sum ] > 0 ) { return dp [ idx , k , tight , sum ] ; } int j ; if ( idx < digits . Count && tight == 0 ) { j = digits [ idx ] ; } else { j = 9 ; } int cnt = 0 ; for ( int i = ( k > 0 ? 0 : 1 ) ; i <= j ; i ++ ) { int newtight = tight ; if ( i < j ) { newtight = 1 ; } if ( i == 0 ) cnt += solve ( idx + 1 , k - 1 , newtight , sum ) ; else cnt += solve ( idx + 1 , k , newtight , sum + i ) ; } return dp [ idx , k , tight , sum ] = cnt ; }
int minDominatingSet ( Node root , int covered , int compulsory ) { if ( root == null ) return 0 ; if ( root . left != null && root . right != null && covered > 0 ) compulsory = 1 ; if ( dp [ root . data , covered , compulsory ] != - 1 ) return dp [ root . data , covered , compulsory ] ; if ( compulsory > 0 ) { return dp [ root . data , covered , compulsory ] = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; } if ( covered > 0 ) { return dp [ root . data , covered , compulsory ] = Math . Min ( 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; } int ans = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; if ( root . left != null ) { ans = Math . Min ( ans , minDominatingSet ( root . left , 0 , 1 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; } if ( root . right != null ) { ans = Math . Min ( ans , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 1 ) ) ; } return dp [ root . data , covered , compulsory ] = ans ; }
int getmask ( int val ) { int mask = 0 ; int [ ] prime = { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 } ; for ( int i = 0 ; i < 15 ; i ++ ) { if ( val % prime [ i ] == 0 ) { mask = mask | ( 1 << i ) ; } } return mask ; }
int calculate ( int pos , int mask , int [ ] a , int n ) { if ( pos == n || mask == ( int ) ( 1 << n - 1 ) ) return 0 ; if ( dp [ pos , mask ] != - 1 ) return dp [ pos , mask ] ; int size = 0 ; size = Math . Max ( size , calculate ( pos + 1 , mask , a , n ) ) ; if ( ( getmask ( a [ pos ] ) & mask ) == 0 ) { int new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) ; size = Math . Max ( size , 1 + calculate ( pos + 1 , new_mask , a , n ) ) ; } return dp [ pos , mask ] = size ; }
int largestSubset ( int [ ] a , int n ) { for ( int i = 0 ; i < 5000 ; i ++ ) { for ( int j = 0 ; j < 1029 ; j ++ ) dp [ i , j ] = - 1 ; } return calculate ( 0 , 0 , a , n ) ; }
int countSubsets ( int N ) { if ( N <= 2 ) return N ; if ( N == 3 ) return 2 ; int [ ] DP = new int [ N + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; DP [ 2 ] = 2 ; DP [ 3 ] = 2 ; for ( int i = 4 ; i <= N ; i ++ ) { DP [ i ] = DP [ i - 2 ] + DP [ i - 3 ] ; } return DP [ N ] ; }
int CountSets ( int x , int pos ) { if ( x <= 0 ) { if ( pos == 0 ) return 1 ; else return 0 ; } if ( pos == 0 ) return 1 ; int answer = CountSets ( x - 1 , pos ) + CountSets ( x - 2 , pos - 1 ) ; return answer ; }
int CountOrderedSets ( int n ) { int [ ] factorial = new int [ 10000 ] ; factorial [ 0 ] = 1 ; for ( int i = 1 ; i < 10000 ; i ++ ) factorial [ i ] = factorial [ i - 1 ] * i ; int answer = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int sets = CountSets ( n , i ) * factorial [ i ] ; answer = answer + sets ; } return answer ; }
int CountOrderedSets ( int n ) { int [ ] factorial = new int [ 10000 ] ; factorial [ 0 ] = 1 ; for ( int i = 1 ; i < 10000 ; i ++ ) factorial [ i ] = factorial [ i - 1 ] * i ; int answer = 0 ; for ( int i = 0 ; i < 500 ; i ++ ) { for ( int j = 0 ; j < 500 ; j ++ ) { dp [ i , j ] = - 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { int sets = CountSets ( n , i ) * factorial [ i ] ; answer = answer + sets ; } return answer ; }
int numberOfArithmeticSequences ( int [ ] L , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i ] - L [ i - 1 ] == L [ i - 1 ] - L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
int count_special ( int n ) { int [ ] fib = new int [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; }
int CountOfTriplets ( int [ ] a , int n ) { int answer = 0 ; int x = 0 ; int [ ] count = new int [ 100005 ] ; int [ ] ways = new int [ 100005 ] ; for ( int i = 0 ; i < n ; i ++ ) { x ^= a [ i ] ; answer += count [ x ] * i - ways [ x ] ; count [ x ] ++ ; ways [ x ] += ( i + 1 ) ; } return answer ; }
int MaximumSum ( int [ ] a , int n ) { int [ , ] dp = new int [ n + 1 , n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) dp [ i , j ] = Int32 . MinValue ; } for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i , 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { int val = Int32 . MinValue ; if ( ( i - 2 >= 0 && dp [ i - 2 , j - 1 ] != Int32 . MinValue ) i - 2 < 0 ) { val = a [ i - 1 ] + ( i - 2 >= 0 ? dp [ i - 2 , j - 1 ] : 0 ) ; } if ( i - 1 >= j ) { val = Math . Max ( val , dp [ i - 1 , j ] ) ; } dp [ i , j ] = val ; } } return dp [ n , n / 2 ] ; }
int MaximumSum ( int [ ] a , int n ) { int [ , ] dp = new int [ n + 1 , 2 ] ; dp [ 2 , 1 ] = a [ 1 ] ; dp [ 2 , 0 ] = a [ 0 ] ; for ( int i = 3 ; i < n + 1 ; i ++ ) { if ( i % 2 == 1 ) { int temp = Math . Max ( ( Math . Max ( dp [ i - 3 , 1 ] , dp [ i - 3 , 0 ] ) ) , Math . Max ( dp [ i - 2 , 1 ] , dp [ i - 2 , 0 ] ) ) ; dp [ i , 1 ] = a [ i - 1 ] + temp ; dp [ i , 0 ] = Math . Max ( ( Math . Max ( a [ i - 2 ] + dp [ i - 2 , 0 ] , a [ i - 2 ] + dp [ i - 3 , 1 ] ) ) , Math . Max ( a [ i - 2 ] + dp [ i - 3 , 0 ] , a [ i - 3 ] + dp [ i - 3 , 0 ] ) ) ; } else { dp [ i , 1 ] = a [ i - 1 ] + ( Math . Max ( ( Math . Max ( dp [ i - 2 , 1 ] , dp [ i - 2 , 0 ] ) ) , dp [ i - 1 , 0 ] ) ) ; dp [ i , 0 ] = a [ i - 2 ] + dp [ i - 2 , 0 ] ; } } return Math . Max ( dp [ n , 1 ] , dp [ n , 0 ] ) ; }
int func ( int n ) { if ( n <= 0 ) return 0 ; if ( kPowKform . Contains ( n ) ) return 1 ; int answer = 0 ; int x = n ; while ( x > 0 ) { int d = x % 10 ; if ( d != 0 ) { if ( func ( n - d * d ) == 1 ) { answer = 1 ; break ; } } x /= 10 ; } return answer ; }
void canBeConverted ( int n ) { if ( func ( n ) == 1 ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
int divisorGame ( int N , int A , int [ , ] dp ) { if ( N == 1 N == 3 ) return 0 ; if ( N == 2 ) return 1 ; if ( dp [ N , A ] != - 1 ) return dp [ N , A ] ; int ans = ( A == 1 ) ? 0 : 1 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( A == 1 ) ans |= divisorGame ( N - i , 0 , dp ) ; else ans &= divisorGame ( N - i , 1 , dp ) ; } } return dp [ N , A ] = ans ; }
bool check ( List < int > v ) { HashSet < int > digits = new HashSet < int > ( ) ; for ( int i = 0 ; i < v . Count ; i ++ ) { HashSet < int > d = new HashSet < int > ( ) ; while ( v [ i ] > 0 ) { d . Add ( v [ i ] % 10 ) ; v [ i ] = v [ i ] / 10 ; } foreach ( int it in d ) { if ( digits . Contains ( it ) ) return false ; } foreach ( int it in d ) digits . Add ( it ) ; } return true ; }
int numberOfSubarrays ( int [ ] a , int n ) { int answer = 0 ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { List < int > temp = new List < int > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) > 0 ) temp . Add ( a [ j ] ) ; } if ( check ( temp ) ) answer ++ ; } return answer ; }
int countWays ( int pos , int mask , int [ ] a , int n ) { if ( pos == n ) return ( mask > 0 ? 1 : 0 ) ; if ( dp [ pos , mask ] != - 1 ) return dp [ pos , mask ] ; int count = 0 ; count = count + countWays ( pos + 1 , mask , a , n ) ; if ( ( getmask ( a [ pos ] ) & mask ) == 0 ) { int new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) ; count = count + countWays ( pos + 1 , new_mask , a , n ) ; } return dp [ pos , mask ] = count ; }
int numberOfSubarrays ( int [ ] a , int n ) { for ( int i = 0 ; i < 5000 ; i ++ ) { for ( int j = 0 ; j < ( 1 << 10 ) + 5 ; j ++ ) { dp [ i , j ] = - 1 ; } } return countWays ( 0 , 0 , a , n ) ; }
void change ( ref pair p , int x ) { if ( p . second > x ) p . second = x ; if ( p . first > p . second ) { int tmp = p . first ; p . first = p . second ; p . second = tmp ; } }
int minNodetoRemove ( int n , ArrayList edges ) { for ( int i = 0 ; i < edges . Count ; i ++ ) { ( ( ArrayList ) adj [ ( ( pair ) edges [ i ] ) . first ] ) . Add ( ( ( pair ) edges [ i ] ) . second ) ; ( ( ArrayList ) adj [ ( ( pair ) edges [ i ] ) . second ] ) . Add ( ( ( pair ) edges [ i ] ) . first ) ; } Array . Fill ( vis , 0 ) ; totBackEdges = 0 ; for ( int v = 1 ; v <= n ; v ++ ) { if ( vis [ v ] == 0 ) dfs ( v ) ; } if ( totBackEdges == 0 ) return - 1 ; int node = - 1 ; for ( int v = 1 ; v <= n ; v ++ ) { if ( ( countAdj [ v ] + small [ v ] == totBackEdges ) && isPossible [ v ] != 0 ) { node = v ; } if ( node != - 1 ) break ; } return node ; }
int height ( node root ) { if ( root == null ) return 0 ; return ( Math . Max ( height ( root . left ) , height ( root . right ) ) + 1 ) ; }
void FibonacciSeries ( int n ) { fib . Add ( 0 ) ; fib . Add ( 1 ) ; for ( int i = 2 ; i < n ; i ++ ) fib . Add ( fib [ i - 1 ] + fib [ i - 2 ] ) ; }
int CountPathUtil ( node root , int i , int count ) { if ( root == null || ! ( fib [ i ] == root . data ) ) { return count ; } if ( root . left != null && root . right != null ) { count ++ ; } count = CountPathUtil ( root . left , i + 1 , count ) ; return CountPathUtil ( root . right , i + 1 , count ) ; }
void CountPath ( node root ) { int ht = height ( root ) ; FibonacciSeries ( ht ) ; Console . Write ( CountPathUtil ( root , 0 , 0 ) ) ; }
void SieveOfEratosthenes ( ) { bool [ ] isPrime = new bool [ Large + 1 ] ; for ( int p = 0 ; p <= Large ; p ++ ) isPrime [ p ] = true ; for ( int p = 2 ; p * p <= Large ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= Large ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= Large ; p ++ ) if ( isPrime [ p ] ) prime . Add ( p ) ; }
void Display ( int [ , ] arr , int row ) { for ( int i = 0 ; i < M ; i ++ ) Console . Write ( arr [ row , i ] + " " ) ; }
void countDivisorsMult ( int [ , ] arr ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int row_no = 0 ; long max_factor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int no = arr [ i , j ] ; for ( int k = 0 ; k < prime . Count ; k ++ ) { while ( no > 1 && no % prime [ k ] == 0 ) { no /= prime [ k ] ; if ( mp . ContainsKey ( prime [ k ] ) ) mp [ prime [ k ] ] = prime [ k ] + 1 ; else mp . Add ( prime [ k ] , 1 ) ; } if ( no == 1 ) break ; } } int res = 1 ; foreach ( KeyValuePair < int , int > it in mp ) { res *= ( it . Value + 1 ) ; } if ( max_factor < res ) { row_no = i ; max_factor = res ; } mp . Clear ( ) ; } Display ( arr , row_no ) ; }
int isSquare ( int n ) { int k = ( int ) Math . Sqrt ( n ) ; return k * k == n ? 1 : 0 ; }
int calculate ( int pos , int prev , int sum , int [ ] v ) { if ( pos == v . Length ) return isSquare ( sum ) ; for ( int i = prev ; i <= 9 ; i ++ ) { v [ pos ] = i ; sum += i * i ; if ( calculate ( pos + 1 , i , sum , v ) != 0 ) return 1 ; sum -= i * i ; } return 0 ; }
int countMountains ( int [ , ] a , int n ) { int [ , ] A = new int [ n + 2 , n + 2 ] ; int count = 0 ; for ( int i = 0 ; i < n + 2 ; i ++ ) { for ( int j = 0 ; j < n + 2 ; j ++ ) { if ( ( i == 0 ) || ( j == 0 ) || ( i == n + 1 ) || ( j == n + 1 ) ) { A [ i , j ] = int . MinValue ; } else { A [ i , j ] = a [ i - 1 , j - 1 ] ; } } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( ( A [ i , j ] > A [ i - 1 , j ] ) && ( A [ i , j ] > A [ i + 1 , j ] ) && ( A [ i , j ] > A [ i , j - 1 ] ) && ( A [ i , j ] > A [ i , j + 1 ] ) && ( A [ i , j ] > A [ i - 1 , j - 1 ] ) && ( A [ i , j ] > A [ i + 1 , j + 1 ] ) && ( A [ i , j ] > A [ i - 1 , j + 1 ] ) && ( A [ i , j ] > A [ i + 1 , j - 1 ] ) ) { count ++ ; } } } return count ; }
int calculate ( int pos , int g , int n , int k ) { if ( pos == n ) { return g ; } int answer = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { answer = ( answer % MOD + calculate ( pos + 1 , __gcd ( g , i ) , n , k ) % MOD ) ; answer %= MOD ; } return answer ; }
int sumofGCD ( int n , int k ) { return calculate ( 0 , 0 , n , k ) ; }
int fastexpo ( int a , int b ) { int res = 1 ; a %= MOD ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res * a ) % MOD ; a *= a ; a %= MOD ; b >>= 1 ; } return res ; }
int sumofGCD ( int n , int k ) { int [ ] count = new int [ k + 1 ] ; for ( int g = k ; g >= 1 ; g -- ) { int count_multiples = k / g ; int temp ; temp = fastexpo ( count_multiples , n ) ; temp %= MOD ; int extra = 0 ; for ( int j = g * 2 ; j <= k ; j += g ) { extra = ( extra + count [ j ] ) ; extra %= MOD ; } count [ g ] = ( temp - extra + MOD ) ; count [ g ] %= MOD ; } int sum = 0 ; int add ; for ( int i = 1 ; i <= k ; ++ i ) { add = ( count [ i ] % MOD * i % MOD ) ; add %= MOD ; sum += add ; sum %= MOD ; } return sum ; }
int findCost ( int [ , ] cost_mat , int N , int M ) { int [ , ] dp = new int [ N , M ] ; for ( int i = 0 ; i < M ; i ++ ) dp [ 0 , i ] = cost_mat [ 0 , i ] ; for ( int row = 1 ; row < N ; row ++ ) { for ( int curr_col = 0 ; curr_col < M ; curr_col ++ ) { int val = 999999999 ; for ( int prev_col = 0 ; prev_col < M ; prev_col ++ ) { if ( curr_col != prev_col ) val = Math . Min ( val , dp [ row - 1 , prev_col ] ) ; } dp [ row , curr_col ] = val + cost_mat [ row , curr_col ] ; } } int ans = int . MaxValue ; for ( int i = 0 ; i < M ; i ++ ) ans = Math . Min ( ans , dp [ N - 1 , i ] ) ; return ans ; }
int checkOdd ( string number ) { int n = number . Length ; int num = number [ n - 1 ] - '0' ; return ( num & 1 ) ; }
void getPrimesFromSeive ( HashSet < String > primes ) { bool [ ] prime = new bool [ 1000001 ] ; for ( int i = 0 ; i < 1000001 ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i * i <= 1000000 ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * i ; j <= 1000000 ; j += i ) prime [ j ] = false ; } } for ( int i = 2 ; i <= 1000000 ; i ++ ) { if ( prime [ i ] == true ) primes . Add ( String . Join ( "" , i ) ) ; } }
int splitIntoPrimes ( String number ) { int numLen = number . Length ; int [ ] splitDP = new int [ numLen + 1 ] ; for ( int i = 0 ; i < numLen + 1 ; i ++ ) splitDP [ i ] = - 1 ; HashSet < String > primes = new HashSet < String > ( ) ; getPrimesFromSeive ( primes ) ; for ( int i = 1 ; i <= numLen ; i ++ ) { if ( i <= 6 && ( primes . Contains ( number . Substring ( 0 , i ) ) ) ) splitDP [ i ] = 1 ; if ( splitDP [ i ] != - 1 ) { for ( int j = 1 ; j <= 6 && i + j <= numLen ; j ++ ) { if ( primes . Contains ( number . Substring ( i , j ) ) ) { if ( splitDP [ i + j ] == - 1 ) splitDP [ i + j ] = 1 + splitDP [ i ] ; else splitDP [ i + j ] = Math . Min ( splitDP [ i + j ] , 1 + splitDP [ i ] ) ; } } } } return splitDP [ numLen ] ; }
int k_nonzero_numbers ( string s , int n , int k ) { int [ , , ] dp = new int [ n + 1 , 2 , k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) for ( int x = 0 ; x <= k ; x ++ ) dp [ i , j , x ] = 0 ; dp [ 0 , 0 , 0 ] = 1 ; for ( int i = 0 ; i < n ; ++ i ) { int sm = 0 ; while ( sm < 2 ) { for ( int j = 0 ; j < k + 1 ; ++ j ) { int x = 0 ; while ( x <= ( sm != 0 ? 9 : s [ i ] - '0' ) ) { if ( j + ( x > 0 ? 1 : 0 ) < k + 1 ) { dp [ i + 1 , ( ( sm != 0 || x < ( s [ i ] - '0' ) ) ? 1 : 0 ) , j + ( x > 0 ? 1 : 0 ) ] += dp [ i , sm , j ] ; } ++ x ; } } ++ sm ; } } return dp [ n , 0 , k ] + dp [ n , 1 , k ] ; }
int maximumOccurrence ( string s ) { int n = s . Length ; Dictionary < string , int > freq = new Dictionary < string , int > ( ) ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { string temp = "" ; temp += s [ i ] ; if ( freq . ContainsKey ( temp ) ) { freq [ temp ] ++ ; } else { freq [ temp ] = 1 ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { string temp = "" ; temp += s [ i ] ; temp += s [ j ] ; if ( freq . ContainsKey ( temp ) ) freq [ temp ] ++ ; else freq [ temp ] = 1 ; } } int answer = int . MinValue ; foreach ( KeyValuePair < string , int > it in freq ) answer = Math . Max ( answer , it . Value ) ; return answer ; }
int maximumOccurrence ( string s ) { int n = s . Length ; int [ ] freq = new int [ 26 ] ; int [ , ] dp = new int [ 26 , 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( s [ i ] - 'a' ) ; for ( int j = 0 ; j < 26 ; j ++ ) dp [ x , j ] += freq [ j ] ; freq [ x ] ++ ; } int answer = int . MinValue ; for ( int i = 0 ; i < 26 ; i ++ ) answer = Math . Max ( answer , freq [ i ] ) ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { answer = Math . Max ( answer , dp [ i , j ] ) ; } } return answer ; }
int calculate ( int pos , int rem , int z , int k , int n ) { if ( rem == 0 && z != 0 ) { if ( pos != n ) return ( powers [ n - pos - 1 ] * 9 ) % mod ; else return 1 ; } if ( pos == n ) return 0 ; if ( dp [ pos , rem , z ] != - 1 ) return dp [ pos , rem , z ] ; int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( i == 0 ) count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , z , k , n ) ) ) % mod ; else count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , 1 , k , n ) ) ) % mod ; } return dp [ pos , rem , z ] = count ; }
int waysToSplit ( string s ) { int n = s . Length ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { string left = s . Substring ( 0 , i ) ; string right = s . Substring ( i , n - i ) ; if ( distinctChars ( left ) == distinctChars ( right ) ) answer ++ ; } return answer ; }
int waysToSplit ( string s ) { int n = s . Length ; int answer = 0 ; int [ ] prefix = new int [ n ] ; int [ ] suffix = new int [ n ] ; int [ ] seen = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int prev = ( i - 1 >= 0 ? prefix [ i - 1 ] : 0 ) ; if ( seen [ s [ i ] - 'a' ] == 0 ) { prefix [ i ] += ( prev + 1 ) ; } else prefix [ i ] = prev ; seen [ s [ i ] - 'a' ] = 1 ; } for ( int i = 0 ; i < 26 ; i ++ ) seen [ i ] = 0 ; suffix [ n - 1 ] = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int prev = suffix [ i ] ; if ( seen [ s [ i ] - 'a' ] == 0 ) { suffix [ i - 1 ] += ( prev + 1 ) ; } else suffix [ i - 1 ] = prev ; seen [ s [ i ] - 'a' ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( prefix [ i ] == suffix [ i ] ) answer ++ ; } return answer ; }
int calculate ( int pos , int tight , int [ ] D , int sz , String num ) { if ( pos == num . Length ) return 1 ; if ( dp [ pos , tight ] != - 1 ) return dp [ pos , tight ] ; int val = 0 ; if ( tight == 0 ) { for ( int i = 0 ; i < sz ; i ++ ) { if ( D [ i ] < ( num [ pos ] - '0' ) ) { val += calculate ( pos + 1 , 1 , D , sz , num ) ; } else if ( D [ i ] == num [ pos ] - '0' ) val += calculate ( pos + 1 , tight , D , sz , num ) ; } } else { for ( int i = 0 ; i < sz ; i ++ ) { val += calculate ( pos + 1 , tight , D , sz , num ) ; } } return dp [ pos , tight ] = val ; }
int countNumbers ( int [ ] D , int N , int sz ) { String num = convertToString ( N ) ; int len = num . Length ; for ( int i = 0 ; i < 15 ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) dp [ i , j ] = - 1 ; int ans = calculate ( 0 , 0 , D , sz , num ) ; for ( int i = 1 ; i < len ; i ++ ) ans += calculate ( i , 1 , D , sz , num ) ; return ans ; }
void fibonacci ( ) { int i ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( i = 2 ; i <= MAX_SIZE ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } }
void printLevel ( int level ) { int left_index = ( int ) Math . Pow ( 2 , level - 1 ) ; int right_index = ( int ) ( Math . Pow ( 2 , level ) - 1 ) ; for ( int i = left_index ; i <= right_index ; i ++ ) { Console . Write ( fib [ i - 1 ] + " " ) ; } Console . WriteLine ( ) ; }
int calculate ( int pos , int prev , int left , int k ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; int answer = 0 ; for ( int i = prev ; i <= left ; i ++ ) { answer += calculate ( pos + 1 , i , left - i , k ) ; } return answer ; }
int countWaystoDivide ( int n , int k ) { return calculate ( 0 , 1 , n , k ) ; }
int calculate ( int pos , int prev , int left , int k ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos , prev , left ] != - 1 ) return dp [ pos , prev , left ] ; int answer = 0 ; for ( int i = prev ; i <= left ; i ++ ) { answer += calculate ( pos + 1 , i , left - i , k ) ; } return dp [ pos , prev , left ] = answer ; }
int countWaystoDivide ( int n , int k ) { for ( int i = 0 ; i < 50 ; i ++ ) { for ( int j = 0 ; j < 50 ; j ++ ) { for ( int l = 0 ; l < 50 ; l ++ ) dp [ i , j , l ] = - 1 ; } } return calculate ( 0 , 1 , n , k ) ; }
int countWays ( List < String > a , String s ) { int n = a . Count ; List < int > [ ] index = new List < int > [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) index [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < a [ i ] . Length ; j ++ ) { index [ a [ i ] [ j ] - 'a' ] . Add ( j + 1 ) ; } } for ( int i = 0 ; i < 1000 ; i ++ ) { for ( int j = 0 ; j < 1000 ; j ++ ) { dp [ i , j ] = - 1 ; } } return calculate ( 0 , 0 , s , index [ 0 ] ) ; }
int minimalLength ( int [ ] a , int n ) { int [ , ] dp = new int [ n + 1 , n + 1 ] ; int [ ] dp1 = new int [ n ] ; int i , j , k ; for ( i = 0 ; i < n + 1 ; i ++ ) { for ( j = 0 ; j < n + 1 ; j ++ ) { dp [ i , j ] = - 1 ; } } for ( int size = 1 ; size <= n ; size ++ ) { for ( i = 0 ; i < n - size + 1 ; i ++ ) { j = i + size - 1 ; if ( i == j ) dp [ i , j ] = a [ i ] ; else { for ( k = i ; k < j ; k ++ ) { if ( dp [ i , k ] != - 1 && dp [ i , k ] == dp [ k + 1 , j ] ) dp [ i , j ] = dp [ i , k ] + 1 ; } } } } for ( i = 0 ; i < n ; i ++ ) dp1 [ i ] = ( int ) 1e7 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( dp [ j , i ] != - 1 ) { if ( j == 0 ) dp1 [ i ] = 1 ; else dp1 [ i ] = Math . Min ( dp1 [ i ] , dp1 [ j - 1 ] + 1 ) ; } } } return dp1 [ n - 1 ] ; }
int maxScore ( int l , int r , int [ ] prefix_sum , int num ) { if ( l > r ) return 0 ; int current_sum = prefix_sum [ r ] - ( l - 1 >= 0 ? prefix_sum [ l - 1 ] : 0 ) ; if ( num % 2 == 0 ) current_sum *= - 1 ; return current_sum + Math . Max ( maxScore ( l + 1 , r , prefix_sum , num + 1 ) , maxScore ( l , r - 1 , prefix_sum , num + 1 ) ) ; }
int findMaxScore ( int [ ] a , int n ) { int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix_sum [ i ] = prefix_sum [ i - 1 ] + a [ i ] ; } return maxScore ( 0 , n - 1 , prefix_sum , 1 ) ; }
int MaximumScoreDP ( int l , int r , int [ ] prefix_sum , int num ) { if ( l > r ) return 0 ; if ( dp [ l , r , num ] != - 1 ) return dp [ l , r , num ] ; int current_sum = prefix_sum [ r ] - ( l - 1 >= 0 ? prefix_sum [ l - 1 ] : 0 ) ; if ( num % 2 == 0 ) current_sum *= - 1 ; dp [ l , r , num ] = current_sum + Math . Max ( MaximumScoreDP ( l + 1 , r , prefix_sum , num + 1 ) , MaximumScoreDP ( l , r - 1 , prefix_sum , num + 1 ) ) ; return dp [ l , r , num ] ; }
int findMaxScore ( int [ ] a , int n ) { int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix_sum [ i ] = prefix_sum [ i - 1 ] + a [ i ] ; } for ( int i = 0 ; i < 100 ; i ++ ) { for ( int j = 0 ; j < 100 ; j ++ ) { for ( int l = 0 ; l < 100 ; l ++ ) dp [ i , j , l ] = - 1 ; } } return MaximumScoreDP ( 0 , n - 1 , prefix_sum , 1 ) ; }
void computeFibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 100005 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } }
int countString ( string str ) { int ans = 1 ; int cnt = 1 ; for ( int i = 1 ; i < str . Length ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) { cnt ++ ; } else { ans = ans * fib [ cnt ] ; cnt = 1 ; } } ans = ans * fib [ cnt ] ; return ans ; }
int find_max ( int i , int sum , int [ ] v , int k ) { if ( i == v . Length ) return 0 ; if ( dp [ i , sum ] != - 1 ) return dp [ i , sum ] ; int ans = 0 ; if ( ( sum + find_max ( i + 1 , sum , v , k ) ) % k == 0 ) ans = find_max ( i + 1 , sum , v , k ) ; if ( ( sum + v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) % k == 0 ) ans = Math . Max ( ans , v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) ; return dp [ i , sum ] = ans ; }
int maxLength ( int [ ] a , int n ) { int maximum = 1 ; int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = 1 ; right [ i ] = 1 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { right [ i ] = right [ i + 1 ] + 1 ; } maximum = Math . Max ( maximum , right [ i ] ) ; } for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { left [ i ] = left [ i - 1 ] + 1 ; } } if ( n > 2 ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i - 1 ] > a [ i + 1 ] ) { maximum = Math . Max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; } } } return maximum ; }
void printGolombSequence ( int N ) { int [ ] arr = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) arr [ i ] = 0 ; int cnt = 0 ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; Dictionary < int , int > M = new Dictionary < int , int > ( ) ; M . Add ( 2 , 2 ) ; for ( int i = 2 ; i <= N ; i ++ ) { if ( cnt == 0 ) { arr [ i ] = 1 + arr [ i - 1 ] ; cnt = M [ arr [ i ] ] ; cnt -- ; } else { arr [ i ] = arr [ i - 1 ] ; cnt -- ; } if ( M . ContainsKey ( i ) ) { M [ i ] = arr [ i ] ; } else { M . Add ( i , arr [ i ] ) ; } } for ( int i = 1 ; i <= N ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
int number_of_ways ( int n ) { int [ ] includes_3 = new int [ n + 1 ] ; int [ ] not_includes_3 = new int [ n + 1 ] ; includes_3 [ 3 ] = 1 ; not_includes_3 [ 1 ] = 1 ; not_includes_3 [ 2 ] = 2 ; not_includes_3 [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] ; not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] ; } return includes_3 [ n ] ; }
int cntSubSeq ( int [ ] arr , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = ( int ) Math . Pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= ( int ) Math . Pow ( 2 , neg_count - 1 ) ; else result = 0 ; return result ; }
void generateDivisors ( int n ) { for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisors [ i ] ++ ; } else { divisors [ i ] ++ ; divisors [ n / i ] ++ ; } } } }
int findMaxMultiples ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . Max ( divisors [ arr [ i ] ] , ans ) ; generateDivisors ( arr [ i ] ) ; } return ans ; }
int max_sum ( int [ ] arr , int n , int k ) { int [ ] dp = new int [ n ] ; dp [ 0 ] = Math . Max ( 0 , arr [ 0 ] ) ; int i = 1 ; while ( i < k ) { dp [ i ] = Math . Max ( dp [ i - 1 ] , arr [ i ] ) ; i ++ ; } i = k ; while ( i < n ) { dp [ i ] = Math . Max ( dp [ i - 1 ] , arr [ i ] + dp [ i - k ] ) ; i ++ ; } return dp [ n - 1 ] ; }
int maxIncSubarr ( int [ ] a , int n ) { int [ ] pre = new int [ n ] ; int [ ] pos = new int [ n ] ; pre [ 0 ] = 1 ; pos [ n - 1 ] = 1 ; int l = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) pre [ i ] = pre [ i - 1 ] + 1 ; else pre [ i ] = 1 ; } l = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] < a [ i + 1 ] ) pos [ i ] = pos [ i + 1 ] + 1 ; else pos [ i ] = 1 ; } int ans = 0 ; l = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) l ++ ; else l = 1 ; ans = Math . Max ( ans , l ) ; } for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( a [ i - 1 ] < a [ i + 1 ] ) ans = Math . Max ( pre [ i - 1 ] + pos [ i + 1 ] , ans ) ; } return ans ; }
int countWays ( int n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; int f0 = 1 , f1 = 1 , f2 = 2 ; int ans = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; }
long countStr ( int N ) { long [ , ] dp = new long [ N + 1 , 3 ] ; dp [ 1 , 0 ] = 1 ; dp [ 1 , 1 ] = 1 ; dp [ 1 , 2 ] = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i , 0 ] = ( dp [ i - 1 , 0 ] + dp [ i - 1 , 1 ] + dp [ i - 1 , 2 ] ) % MOD ; dp [ i , 1 ] = dp [ i - 1 , 0 ] % MOD ; dp [ i , 2 ] = dp [ i - 1 , 1 ] % MOD ; } long ans = ( dp [ N , 0 ] + dp [ N , 1 ] + dp [ N , 2 ] ) % MOD ; return ans ; }
int update ( int In , int l , int r , int up_in , int val ) { if ( r < up_in l > up_in ) return seg [ In ] ; if ( l == up_in && r == up_in ) return seg [ In ] = val ; int m = ( l + r ) / 2 ; return seg [ In ] = update ( 2 * In + 1 , l , m , up_in , val ) + update ( 2 * In + 2 , m + 1 , r , up_in , val ) ; }
int maxLengthSquare ( int row , int column , int [ , ] arr , int k ) { int [ , ] sum = new int [ row + 1 , column + 1 ] ; int cur_max = 1 ; int max = 0 ; for ( int i = 1 ; i <= row ; i ++ ) { for ( int j = 1 ; j <= column ; j ++ ) { sum [ i , j ] = sum [ i - 1 , j ] + sum [ i , j - 1 ] + arr [ i - 1 , j - 1 ] - sum [ i - 1 , j - 1 ] ; if ( i >= cur_max && j >= cur_max && sum [ i , j ] - sum [ i - cur_max , j ] - sum [ i , j - cur_max ] + sum [ i - cur_max , j - cur_max ] <= k ) { max = cur_max ++ ; } } } return max ; }
int getSum ( int x , int y , int z ) { int ans = 0 ; exactnum [ 0 , 0 , 0 ] = 1 ; for ( int i = 0 ; i <= x ; ++ i ) { for ( int j = 0 ; j <= y ; ++ j ) { for ( int k = 0 ; k <= z ; ++ k ) { if ( i > 0 ) { exactsum [ i , j , k ] += ( exactsum [ i - 1 , j , k ] * 10 + 4 * exactnum [ i - 1 , j , k ] ) % mod ; exactnum [ i , j , k ] += exactnum [ i - 1 , j , k ] % mod ; } if ( j > 0 ) { exactsum [ i , j , k ] += ( exactsum [ i , j - 1 , k ] * 10 + 5 * exactnum [ i , j - 1 , k ] ) % mod ; exactnum [ i , j , k ] += exactnum [ i , j - 1 , k ] % mod ; } if ( k > 0 ) { exactsum [ i , j , k ] += ( exactsum [ i , j , k - 1 ] * 10 + 6 * exactnum [ i , j , k - 1 ] ) % mod ; exactnum [ i , j , k ] += exactnum [ i , j , k - 1 ] % mod ; } ans += exactsum [ i , j , k ] % mod ; ans %= mod ; } } } return ans ; }
int maximum_set ( int [ ] a , int n ) { int [ ] dp = new int [ N ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ a [ i ] ] = 1 ; int ans = 1 ; for ( int i = N - 1 ; i >= 1 ; i -- ) { if ( dp [ i ] != 0 ) { for ( int j = 2 * i ; j < N ; j += i ) { dp [ i ] = Math . Max ( dp [ i ] , 1 + dp [ j ] ) ; ans = Math . Max ( ans , dp [ i ] ) ; } } } return ans ; }
int findMaxCount ( Node root ) { res = int . MinValue ; countUntil ( root ) ; return res ; }
int findLargestString ( String s , int i , int r ) { if ( i == s . Length ) { if ( r == 0 ) return 0 ; else return INT_MIN ; } if ( v [ i , r ] == 1 ) return dp [ i , r ] ; v [ i , r ] = 1 ; dp [ i , r ] = Math . Max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s [ i ] - '0' ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i , r ] ; }
int findCnt ( String s , int i , int r ) { if ( i == s . Length ) { if ( r == 0 ) return 1 ; else return 0 ; } if ( v [ i , r ] == 1 ) return dp [ i , r ] ; v [ i , r ] = 1 ; dp [ i , r ] = findCnt ( s , i + 1 , ( r * 2 + ( s [ i ] - '0' ) ) % 3 ) + findCnt ( s , i + 1 , r ) ; return dp [ i , r ] ; }
long modInv ( long a ) { long p = MOD - 2 ; long s = 1 ; while ( p != 1 ) { if ( p % 2 == 1 ) s = ( s * a ) % MOD ; a = ( a * a ) % MOD ; p /= 2 ; } return ( a * s ) % MOD ; }
long findCnt ( char x , String y ) { long ans = 0 ; long [ ] fact = new long [ y . Length + 1 ] ; for ( int i = 0 ; i < y . Length + 1 ; i ++ ) fact [ i ] = 1 ; for ( int i = 1 ; i <= y . Length ; i ++ ) fact [ i ] = ( fact [ i - 1 ] * i ) % MOD ; for ( int i = 0 ; i < y . Length ; i ++ ) { if ( y [ i ] == x ) { ans += ( modInv ( fact [ i ] ) * modInv ( fact [ y . Length - i - 1 ] ) ) % MOD ; ans %= MOD ; } } ans *= fact [ ( y . Length - 1 ) ] ; ans %= MOD ; return ans ; }
int minCount ( int [ ] arr , int n , int k ) { int ans = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum -= k ; int l = 0 ; int r = 0 ; int tot = 0 ; while ( l < n ) { if ( tot <= sum ) { ans = Math . Max ( ans , r - l ) ; if ( r == n ) break ; tot += arr [ r ++ ] ; } else { tot -= arr [ l ++ ] ; } } return ( n - ans ) ; }
void findSubSeq ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int [ ] count = new int [ n ] ; int [ ] prev = new int [ n ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) count [ i ] = 1 ; for ( j = 0 ; j < n ; j ++ ) prev [ j ] = - 1 ; int max = 0 ; int maxprev = - 1 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] % arr [ j ] == 0 && count [ j ] + 1 > count [ i ] ) { count [ i ] = count [ j ] + 1 ; prev [ i ] = j ; } } if ( max < count [ i ] ) { max = count [ i ] ; maxprev = i ; } } i = maxprev ; while ( i >= 0 ) { if ( arr [ i ] != - 1 ) Console . Write ( arr [ i ] + " " ) ; i = prev [ i ] ; } }
int solve ( int [ ] arr , int l , int r , int k ) { if ( r - l + 1 <= k ) return sum ( arr , l , r ) ; if ( dp [ l , r , k ] != 0 ) return dp [ l , r , k ] ; int sum_ = sum ( arr , l , r ) ; int len_r = ( r - l + 1 ) - k ; int len = ( r - l + 1 ) ; int ans = 0 ; for ( int i = 0 ; i < len - len_r + 1 ; i ++ ) { int sum_sub = sum ( arr , i + l , i + l + len_r - 1 ) ; ans = Math . Max ( ans , ( sum_ - sum_sub ) + ( sum_sub - solve ( arr , i + l , i + l + len_r - 1 , k ) ) ) ; } dp [ l , r , k ] = ans ; return ans ; }
int minDifference ( int x , int y , int k , int [ , ] b , int [ , ] c ) { int diff = 0 ; if ( x >= n y >= m ) return INT_MAX ; if ( x == n - 1 && y == m - 1 ) { diff = b [ x , y ] - c [ x , y ] ; return Math . Min ( Math . Abs ( k - diff ) , Math . Abs ( k + diff ) ) ; } int ans = dp [ x , y , k ] ; if ( ans != - 1 ) return ans ; ans = INT_MAX ; diff = b [ x , y ] - c [ x , y ] ; ans = Math . Min ( ans , minDifference ( x + 1 , y , Math . Abs ( k + diff ) , b , c ) ) ; ans = Math . Min ( ans , minDifference ( x , y + 1 , Math . Abs ( k + diff ) , b , c ) ) ; ans = Math . Min ( ans , minDifference ( x + 1 , y , Math . Abs ( k - diff ) , b , c ) ) ; ans = Math . Min ( ans , minDifference ( x , y + 1 , Math . Abs ( k - diff ) , b , c ) ) ; return ans ; }
int countSubSeq ( string str , int len ) { int ans = 0 ; int mul = 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) ans += mul ; mul *= 2 ; } return ans ; }
int solveDp ( int r , int i , int [ ] w , int [ ] val , int n ) { if ( r <= 0 ) return 0 ; if ( i == n ) return W_MAX ; if ( v [ r , i ] ) return dp [ r , i ] ; v [ r , i ] = true ; dp [ r , i ] = Math . Min ( solveDp ( r , i + 1 , w , val , n ) , w [ i ] + solveDp ( r - val [ i ] , i + 1 , w , val , n ) ) ; return dp [ r , i ] ; }
int maxWeight ( int [ ] w , int [ ] val , int n , int c ) { for ( int i = V_SUM_MAX ; i >= 0 ; i -- ) { if ( solveDp ( i , 0 , w , val , n ) <= c ) { return i ; } } return 0 ; }
int dfs ( int node ) { vis [ node ] = 1 ; subtree_size [ node ] = 1 ; foreach ( int child in tree [ node ] ) { if ( vis [ child ] == 0 ) { subtree_size [ node ] += dfs ( child ) ; } } return subtree_size [ node ] ; }
void contribution ( int node , ref int ans ) { vis [ node ] = 1 ; foreach ( int child in tree [ node ] ) { if ( vis [ child ] == 0 ) { ans += ( subtree_size [ child ] * ( n - subtree_size [ child ] ) ) ; contribution ( child , ref ans ) ; } } }
int getSum ( ) { Array . Fill ( vis , 0 ) ; dfs ( 0 ) ; int ans = 0 ; Array . Fill ( vis , 0 ) ; contribution ( 0 , ref ans ) ; return ans ; }
int longest_subseq ( int n , int k , String s ) { int [ ] dp = new int [ n ] ; int [ ] max_length = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int curr = s [ i ] - 'a' ; int lower = Math . Max ( 0 , curr - k ) ; int upper = Math . Min ( 25 , curr + k ) ; for ( int j = lower ; j < upper + 1 ; j ++ ) { dp [ i ] = Math . Max ( dp [ i ] , max_length [ j ] + 1 ) ; } max_length [ curr ] = Math . Max ( dp [ i ] , max_length [ curr ] ) ; } int ans = 0 ; foreach ( int i in dp ) ans = Math . Max ( i , ans ) ; return ans ; }
int countNum ( int idx , int sum , int tight , List < int > num , int len , int k ) { if ( len == idx ) { if ( sum == 0 ) return 1 ; else return 0 ; } if ( dp [ idx , sum , tight ] != - 1 ) return dp [ idx , sum , tight ] ; int res = 0 , limit ; if ( tight == 0 ) { limit = num [ idx ] ; } else { limit = 9 ; } for ( int i = 0 ; i <= limit ; i ++ ) { int new_tight = tight ; if ( tight == 0 && i < limit ) new_tight = 1 ; res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len , k ) ; res %= MOD ; } if ( res < 0 ) res += MOD ; return dp [ idx , sum , tight ] = res ; }
List < int > process ( String s ) { List < int > num = new List < int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { num . Add ( s [ i ] - '0' ) ; } return num ; }
void maxLengthOf1s ( int [ ] arr , int n ) { int [ ] prefix = new int [ n ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i - 2 ] == 1 ) prefix [ i ] = prefix [ i - 1 ] + 1 ; else prefix [ i ] = 0 ; } int [ ] suffix = new int [ n ] ; for ( int i = n - 3 ; i >= 0 ; i -- ) { if ( arr [ i + 2 ] == 1 ) suffix [ i ] = suffix [ i + 1 ] + 1 ; else suffix [ i ] = 0 ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = Math . Max ( ans , prefix [ i + 1 ] + suffix [ i ] ) ; } Console . WriteLine ( ans ) ; }
int MaxGCD ( int [ ] a , int n ) { int [ ] Prefix = new int [ n + 2 ] ; int [ ] Suffix = new int [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = __gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = __gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = Math . Max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . Max ( ans , __gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; }
int max_sum ( int [ ] a , int n ) { int [ , ] dp = new int [ n + 1 , 2 ] ; dp [ 0 , 0 ] = 0 ; dp [ 0 , 1 ] = - 999999 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { dp [ i + 1 , 0 ] = Math . Max ( dp [ i , 0 ] + a [ i ] , dp [ i , 1 ] - a [ i ] ) ; dp [ i + 1 , 1 ] = Math . Max ( dp [ i , 0 ] - a [ i ] , dp [ i , 1 ] + a [ i ] ) ; } return dp [ n , 0 ] ; }
int sumOfProduct ( int [ ] arr , int n , int k ) { int [ , ] dp = new int [ n + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i , j ] = 0 ; int cur_sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ 1 , i ] = arr [ i - 1 ] ; cur_sum += arr [ i - 1 ] ; } for ( int i = 2 ; i <= k ; i ++ ) { int temp_sum = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { cur_sum -= dp [ i - 1 , j ] ; dp [ i , j ] = arr [ j - 1 ] * cur_sum ; temp_sum += dp [ i , j ] ; } cur_sum = temp_sum ; } return cur_sum ; }
int number_of_ways ( int [ ] arr , int n , int k ) { if ( k == 1 ) return 1 ; int [ ] dp = new int [ k + 1 ] ; int i ; for ( i = 0 ; i < k + 1 ; i ++ ) dp [ i ] = - 1 ; for ( i = 0 ; i < n ; i ++ ) dp [ arr [ i ] ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = ( dp [ 1 ] == - 1 ) ? 1 : dp [ 1 ] ; for ( i = 2 ; i <= k ; ++ i ) { if ( dp [ i ] == 0 ) continue ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; dp [ i ] %= MOD ; } return dp [ k ] ; }
int MinCost ( int [ ] arr , int n ) { int [ , ] dp = new int [ n + 5 , n + 5 ] ; int [ , ] sum = new int [ n + 5 , n + 5 ] ; for ( int i = 0 ; i < n ; i ++ ) { int k = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { if ( i == j ) sum [ i , j ] = k ; else { k += arr [ j ] ; sum [ i , j ] = k ; } } } for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j < n ; j ++ ) { dp [ i , j ] = int . MaxValue ; if ( i == j ) dp [ i , j ] = 0 ; else { for ( int k = i ; k < j ; k ++ ) { dp [ i , j ] = Math . Min ( dp [ i , j ] , dp [ i , k ] + dp [ k + 1 , j ] + sum [ i , j ] ) ; } } } } return dp [ 0 , n - 1 ] ; }
int findCount ( int N ) { List < int > list = new List < int > ( ) ; int sum = 0 ; int i ; for ( i = 0 ; i < 20 ; i ++ ) { sum += ( int ) Math . Pow ( 2 , i ) ; list . Add ( sum ) ; } for ( i = 0 ; i < 20 ; i ++ ) { if ( ( int ) list [ i ] >= N ) return ( i + 1 ) ; } return 0 ; }
int findMax ( int [ ] arr , int n ) { int res = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) count += 1 ; } res = Math . Max ( count , res ) ; } return res ; }
int findMax ( int [ ] arr , int n ) { bool [ ] divisible = new bool [ n ] ; int res = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( divisible [ i ] ) continue ; int cnt = 0 ; for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] % arr [ i ] ) == 0 ) { divisible [ j ] = true ; cnt ++ ; } } res = Math . Max ( res , cnt ) ; } return res ; }
void findSetBits ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) Console . Write ( count ( i ) + " " ) ; }
void findSetBits ( int n ) { int [ ] dp = new int [ n + 1 ] ; Console . Write ( dp [ 0 ] + " " ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { dp [ i ] = dp [ i / 2 ] ; } else { dp [ i ] = dp [ i / 2 ] + 1 ; } Console . Write ( dp [ i ] + " " ) ; } }
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 0 ; else return - 1 ; } if ( v [ i , curr ] ) return dp [ i , curr ] ; v [ i , curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i , curr ] = l ; if ( r != - 1 ) dp [ i , curr ] = Math . Max ( dp [ i , curr ] , r + 1 ) ; return dp [ i , curr ] ; }
int findCnt ( int [ ] arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i , required_sum + Base ] ) return dp [ i , required_sum + Base ] ; v [ i , required_sum + Base ] = true ; dp [ i , required_sum + Base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i , required_sum + Base ] ; }
int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ? 1 : 0 ) ; } if ( v [ i , curr ] ) return dp [ i , curr ] ; v [ i , curr ] = true ; dp [ i , curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr arr [ i ] ) , n , m ) ; return dp [ i , curr ] ; }
int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ? 1 : 0 ) ; } if ( v1 [ i , curr ] ) return dp1 [ i , curr ] ; v1 [ i , curr ] = true ; dp1 [ i , curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; return dp1 [ i , curr ] ; }
int modulo_13 ( String s , int n ) { long [ , ] dp = new long [ n + 1 , 13 ] ; dp [ 0 , 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { int nxt = s [ i ] - '0' ; if ( s [ i ] == '?' ) nxt = j ; for ( int k = 0 ; k < 13 ; k ++ ) { int rem = ( 10 * k + nxt ) % 13 ; dp [ i + 1 , rem ] += dp [ i , k ] ; dp [ i + 1 , rem ] %= MOD ; } if ( s [ i ] != '?' ) break ; } } return ( int ) dp [ n , 5 ] ; }
int f ( int i , int state , int [ ] A , int [ , ] dp , int N ) { if ( i >= N ) return 0 ; else if ( dp [ i , state ] != - 1 ) { return dp [ i , state ] ; } else { if ( i == N - 1 ) dp [ i , state ] = 1 ; else if ( state == 1 && A [ i ] > A [ i + 1 ] ) dp [ i , state ] = 1 ; else if ( state == 2 && A [ i ] < A [ i + 1 ] ) dp [ i , state ] = 1 ; else if ( state == 1 && A [ i ] <= A [ i + 1 ] ) dp [ i , state ] = 1 + f ( i + 1 , 2 , A , dp , N ) ; else if ( state == 2 && A [ i ] >= A [ i + 1 ] ) dp [ i , state ] = 1 + f ( i + 1 , 1 , A , dp , N ) ; return dp [ i , state ] ; } }
int maxLenSeq ( int [ ] A , int N ) { int i , j , tmp , y , ans ; int [ , ] dp = new int [ 1000 , 3 ] ; for ( i = 0 ; i < 1000 ; i ++ ) for ( j = 0 ; j < 3 ; j ++ ) dp [ i , j ] = - 1 ; for ( i = 0 ; i < N ; i ++ ) { tmp = f ( i , 1 , A , dp , N ) ; tmp = f ( i , 2 , A , dp , N ) ; } ans = - 1 ; for ( i = 0 ; i < N ; i ++ ) { y = dp [ i , 1 ] ; if ( i + y >= N ) ans = Math . Max ( ans , dp [ i , 1 ] + 1 ) ; else if ( y % 2 == 0 ) { ans = Math . Max ( ans , dp [ i , 1 ] + 1 + dp [ i + y , 2 ] ) ; } else if ( y % 2 == 1 ) { ans = Math . Max ( ans , dp [ i , 1 ] + 1 + dp [ i + y , 1 ] ) ; } } return ans ; }
int countWays ( int n ) { List < int > a = new List < int > ( ) ; int i = 1 ; while ( i <= n ) a . Add ( i ++ ) ; int ways = 0 ; do { bool flag = ( a [ 0 ] == 1 ) ; for ( int j = 1 ; j < n ; j ++ ) { if ( Math . Abs ( a [ j ] - a [ j - 1 ] ) > 2 ) flag = false ; } if ( flag ) ways ++ ; } while ( next_permutation ( a ) ) ; return ways ; }
int LISusingLCS ( List < int > seq ) { int n = seq . Count ; int [ , ] L = new int [ n + 1 , n + 1 ] ; List < int > sortedseq = new List < int > ( seq ) ; sortedseq . Sort ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i , j ] = 0 ; else if ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) L [ i , j ] = L [ i - 1 , j - 1 ] + 1 ; else L [ i , j ] = Math . Max ( L [ i - 1 , j ] , L [ i , j - 1 ] ) ; } } return L [ n , n ] ; }
int count_numbers ( int k , int n , bool flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , false ) + count_numbers ( k , n - 1 , true ) ) ; else return count_numbers ( k , n - 1 , true ) ; }
int count_numbers ( int k , int n ) { int [ , ] dp = new int [ n + 1 , 2 ] ; dp [ 1 , 0 ] = 0 ; dp [ 1 , 1 ] = k - 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i , 0 ] = dp [ i - 1 , 1 ] ; dp [ i , 1 ] = ( dp [ i - 1 , 0 ] + dp [ i - 1 , 1 ] ) * ( k - 1 ) ; } return dp [ n , 0 ] + dp [ n , 1 ] ; }
int divideArray ( int [ ] arr , int n , int k ) { int [ , ] dp = new int [ 500 , 500 ] ; int i , j ; for ( i = 0 ; i < 500 ; i ++ ) for ( j = 0 ; j < 500 ; j ++ ) dp [ i , j ] = 0 ; k -= 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { for ( j = 0 ; j <= k ; j ++ ) { dp [ i , j ] = int . MaxValue ; int max_ = - 1 , sum = 0 ; for ( int l = i ; l < n ; l ++ ) { max_ = Math . Max ( max_ , arr [ l ] ) ; sum += arr [ l ] ; int diff = ( l - i + 1 ) * max_ - sum ; if ( j > 0 ) dp [ i , j ] = Math . Min ( dp [ i , j ] , diff + dp [ l + 1 , j - 1 ] ) ; else dp [ i , j ] = diff ; } } } return dp [ 0 , k ] ; }
int cntSubsets ( int [ ] arr , int n ) { int max = ( int ) Math . Pow ( 2 , n ) ; int result = 0 ; for ( int i = 0 ; i < max ; i ++ ) { int counter = i ; if ( ( counter & ( counter >> 1 ) ) > 0 ) continue ; result ++ ; } return result ; }
int cntSubsets ( int [ ] arr , int n ) { int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } int result = a [ n - 1 ] + b [ n - 1 ] ; return result ; }
void perfix_calculate ( int [ , ] A , int [ , ] row , int [ , ] col ) { int n = ( int ) A . GetLength ( 0 ) ; int m = ( int ) A . GetLength ( 1 ) ; for ( int i = 0 ; i < n ; ++ i ) { row [ i , 0 ] = A [ i , 0 ] ; } for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) { row [ i , j ] = row [ i , j - 1 ] + A [ i , j ] ; } } for ( int i = 0 ; i < m ; ++ i ) { col [ 0 , i ] = A [ 0 , i ] ; } for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 1 ; j < n ; ++ j ) { col [ j , i ] = A [ j , i ] + col [ j - 1 , i ] ; } } }
int perimeter ( int i , int j , int k , int [ , ] row , int [ , ] col , int [ , ] A ) { int row_s , col_s ; if ( j == 0 ) row_s = 0 ; else row_s = row [ i , j - 1 ] ; if ( i == 0 ) col_s = 0 ; else col_s = col [ i - 1 , j ] ; int upper_row = row [ i , j + k ] - row_s ; int left_col = col [ i + k , j ] - col_s ; if ( j == 0 ) row_s = 0 ; else row_s = row [ i + k , j - 1 ] ; if ( i == 0 ) col_s = 0 ; else col_s = col [ i - 1 , j + k ] ; int lower_row = row [ i + k , j + k ] - row_s ; int right_col = col [ i + k , j + k ] - col_s ; int sum = upper_row + lower_row + left_col + right_col ; sum -= ( A [ i , j ] + A [ i + k , j ] + A [ i , j + k ] + A [ i + k , j + k ] ) ; return sum ; }
int maxPerimeter ( int [ , ] A ) { int n = ( int ) A . GetLength ( 0 ) ; int m = ( int ) A . GetLength ( 1 ) ; int [ , ] row = new int [ n , m ] ; int [ , ] col = new int [ n , m ] ; perfix_calculate ( A , row , col ) ; int maxPer = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { for ( int k = 0 ; k < Math . Min ( n - i , m - j ) ; ++ k ) { int perimtr = perimeter ( i , j , k , row , col , A ) ; maxPer = Math . Max ( maxPer , perimtr ) ; } } } return maxPer ; }
bool mazeProb ( List < List < int > > maze , int xpos , int ypos ) { bool key = true ; if ( findPath ( maze , xpos , ypos , key ) ) return true ; return false ; }
int ways ( int i , int [ ] arr , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; }
int minJumps ( int [ ] arr , int N ) { int MAX = 1000000 ; int [ ] fib = new int [ 30 ] ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 30 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; int [ ] DP = new int [ N + 2 ] ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= N + 1 ; i ++ ) DP [ i ] = MAX ; for ( int i = 1 ; i <= N + 1 ; i ++ ) { for ( int j = 1 ; j < 30 ; j ++ ) { if ( ( i == N + 1 arr [ i - 1 ] == 1 ) && i - fib [ j ] >= 0 ) DP [ i ] = Math . Min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) ; } } if ( DP [ N + 1 ] != MAX ) return DP [ N + 1 ] ; else return - 1 ; }
int CountOfOddSum ( int [ , ] a , int n ) { int [ , ] dp = new int [ n , 2 ] ; int [ , ] cnt = new int [ n , 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { if ( a [ i , j ] % 2 == 0 ) { cnt [ i , 0 ] ++ ; } else { cnt [ i , 1 ] ++ ; } } } dp [ 0 , 0 ] = cnt [ 0 , 0 ] ; dp [ 0 , 1 ] = cnt [ 0 , 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i , 0 ] = ( dp [ i - 1 , 0 ] * cnt [ i , 0 ] + dp [ i - 1 , 1 ] * cnt [ i , 1 ] ) ; dp [ i , 1 ] = ( dp [ i - 1 , 0 ] * cnt [ i , 1 ] + dp [ i - 1 , 1 ] * cnt [ i , 0 ] ) ; } return dp [ n - 1 , 1 ] ; }
int recur ( int ind , int cnt , int last , int [ ] a , int n , int k , int [ , ] dp ) { if ( cnt == k ) return 0 ; if ( ind == n ) return ( int ) - 1e9 ; if ( dp [ ind , cnt ] != - 1 ) return dp [ ind , cnt ] ; int ans = 0 ; for ( int i = ind ; i < n ; i ++ ) { if ( cnt % 2 == 0 ) ans = Math . Max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) ; else ans = Math . Max ( ans , __gcd ( a [ last ] , a [ i ] ) + recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) ; } return dp [ ind , cnt ] = ans ; }
int Max_Sum ( int [ ] arr1 , int [ ] arr2 , int n ) { int [ , ] dp = new int [ n , 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { dp [ i , 0 ] = arr1 [ i ] ; dp [ i , 1 ] = arr2 [ i ] ; continue ; } dp [ i , 0 ] = Math . Max ( dp [ i - 1 , 0 ] , dp [ i - 1 , 1 ] + arr1 [ i ] ) ; dp [ i , 1 ] = Math . Max ( dp [ i - 1 , 1 ] , dp [ i - 1 , 0 ] + arr2 [ i ] ) ; } return Math . Max ( dp [ n - 1 , 0 ] , dp [ n - 1 , 1 ] ) ; }
int maximizeSum ( int [ ] a , int n , int ind , int k , int [ ] dp ) { if ( k == 0 ) { if ( ind == n ) return 0 ; else return - 1000000000 ; } else if ( ind == n ) return - 1000000000 ; else if ( dp [ ind , k ] != - 1 ) return dp [ ind , k ] ; else { int ans = 0 ; int mini = a [ ind ] ; for ( int i = ind ; i < n ; i ++ ) { mini = Math . Min ( mini , a [ i ] ) ; ans = Math . Max ( ans , maximizeSum ( a , n , i + 1 , k - 1 , dp ) + mini ) ; } return dp [ ind , k ] = ans ; } }
int Partition ( int [ ] arr , int n , int k ) { int [ ] prefix = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; } int LOGS = 20 ; int ans = 0 ; for ( int i = LOGS ; i >= 0 ; -- i ) { if ( checkpossible ( ans | ( 1 << i ) , arr , prefix , n , k ) ) { ans = ans | ( 1 << i ) ; } } return ans ; }
void SieveOfEratosthenes ( int MAX , List < int > primes ) { Boolean [ ] prime = new Boolean [ MAX + 1 ] ; for ( int i = 0 ; i < MAX + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] ) primes . Add ( i ) ; } }
int findLongest ( int [ ] A , int n ) { Dictionary < int , int > mpp = new Dictionary < int , int > ( ) ; List < int > primes = new List < int > ( ) ; SieveOfEratosthenes ( A [ n - 1 ] , primes ) ; int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 1 ; mpp . Add ( A [ n - 1 ] , n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int num = A [ i ] ; dp [ i ] = 1 ; foreach ( int it in primes ) { int xx = num * it ; if ( xx > A [ n - 1 ] ) break ; else if ( mpp . ContainsKey ( xx ) && mpp [ xx ] != 0 ) { dp [ i ] = Math . Max ( dp [ i ] , 1 + dp [ mpp [ xx ] ] ) ; } } if ( mpp . ContainsKey ( A [ i ] ) ) mpp [ A [ i ] ] = i ; else mpp . Add ( A [ i ] , i ) ; } int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . Max ( ans , dp [ i ] ) ; return ans ; }
void initialize ( ) { for ( int i = 0 ; i <= N ; i += 1 ) { for ( int j = 1 ; j <= RODS ; j ++ ) { for ( int k = 1 ; k <= RODS ; k += 1 ) { dp [ i , j , k ] = int . MaxValue ; } } } }
int mincost ( int idx , int src , int dest , int [ , ] costs ) { if ( idx > N ) return 0 ; if ( dp [ idx , src , dest ] != int . MaxValue ) return dp [ idx , src , dest ] ; int rem = 6 - ( src + dest ) ; int ans = int . MaxValue ; int case1 = costs [ src - 1 , dest - 1 ] + mincost ( idx + 1 , src , rem , costs ) + mincost ( idx + 1 , rem , dest , costs ) ; int case2 = costs [ src - 1 , rem - 1 ] + mincost ( idx + 1 , src , dest , costs ) + mincost ( idx + 1 , dest , src , costs ) + costs [ rem - 1 , dest - 1 ] + mincost ( idx + 1 , src , dest , costs ) ; ans = Math . Min ( case1 , case2 ) ; dp [ idx , src , dest ] = ans ; return ans ; }
int MaxGCD ( int [ ] a , int n ) { int [ ] Prefix = new int [ n + 2 ] ; int [ ] Suffix = new int [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = Math . Max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . Max ( ans , gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; }
List < int > numToVec ( int N ) { List < int > digit = new List < int > ( ) ; while ( N != 0 ) { digit . Add ( N % 10 ) ; N = N / 10 ; } if ( digit . Count == 0 ) digit . Add ( 0 ) ; digit . Reverse ( ) ; return digit ; }
int solve ( List < int > A , int B , int C ) { List < int > digit = new List < int > ( ) ; int d , d2 ; digit = numToVec ( C ) ; d = A . Count ; if ( B > digit . Count d == 0 ) return 0 ; else if ( B < digit . Count ) { if ( A [ 0 ] == 0 && B != 1 ) return ( int ) ( ( d - 1 ) * Math . Pow ( d , B - 1 ) ) ; else return ( int ) Math . Pow ( d , B ) ; } else { int [ ] dp = new int [ B + 1 ] ; int [ ] lower = new int [ MAX + 1 ] ; for ( int i = 0 ; i < d ; i ++ ) lower [ A [ i ] + 1 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; Boolean flag = true ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit [ i - 1 ] ] ; dp [ i ] = dp [ i - 1 ] * d ; if ( i == 1 && A [ 0 ] == 0 && B != 1 ) d2 = d2 - 1 ; if ( flag ) dp [ i ] += d2 ; flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) ; } return dp [ B ] ; } }
int LongestConsSeq ( int [ ] arr , int N ) { int maxval = 1 ; for ( int i = 0 ; i < N ; i += 1 ) { maxval = Math . Max ( maxval , arr [ i ] ) ; } int [ , ] dp = new int [ maxval + 1 , 2 ] ; int ans = 1 ; for ( int i = 0 ; i < N ; i += 1 ) { dp [ arr [ i ] , 0 ] = ( 1 + dp [ arr [ i ] - 1 , 0 ] ) ; if ( arr [ i ] >= 2 ) dp [ arr [ i ] , 1 ] = Math . Max ( 1 + dp [ arr [ i ] - 1 , 1 ] , 2 + dp [ arr [ i ] - 2 , 0 ] ) ; else dp [ arr [ i ] , 1 ] = 1 ; ans = Math . Max ( ans , dp [ arr [ i ] , 1 ] ) ; } return ans ; }
int min ( int p , int q , int r , int s ) { int temp1 = p < q ? p : q ; int temp2 = r < s ? r : s ; if ( temp1 < temp2 ) return temp1 ; return temp2 ; }
int Distance ( int [ , ] arr , int i , int j ) { if ( i >= R j >= < 0 < 0 ) return INT_MAX ; else if ( arr [ i , j ] == 0 ) { table [ i , j ] = INT_MAX ; return INT_MAX ; } else if ( arr [ i , j ] == 2 ) { table [ i , j ] = 0 ; return 0 ; } else if ( visited [ i , j ] == 1 ) { return INT_MAX ; } else { visited [ i , j ] = 1 ; int temp1 = Distance ( arr , i + 1 , j ) ; int temp2 = Distance ( arr , i - 1 , j ) ; int temp3 = Distance ( arr , i , j + 1 ) ; int temp4 = Distance ( arr , i , j - 1 ) ; int min_value = 1 + min ( temp1 , temp2 , temp3 , temp4 ) ; if ( table [ i , j ] > 0 && table [ i , j ] < INT_MAX ) { if ( min_value < table [ i , j ] ) table [ i , j ] = min_value ; } else table [ i , j ] = min_value ; visited [ i , j ] = 0 ; } return table [ i , j ] ; }
int minTime ( int [ , ] arr ) { int max = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( arr [ i , j ] == 1 ) Distance ( arr , i , j ) ; } } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( arr [ i , j ] == 1 && table [ i , j ] > max ) max = table [ i , j ] ; } } if ( max < INT_MAX ) return max ; return - 1 ; }
int findDepthRec ( char [ ] tree , int n , int index ) { if ( index >= n tree [ index ] == 'l' ) return 0 ; index ++ ; int left = findDepthRec ( tree , n , index ) ; index ++ ; int right = findDepthRec ( tree , n , index ) ; return Math . Max ( left , right ) + 1 ; }
int findDepth ( char [ ] tree , int n ) { int index = 0 ; return ( findDepthRec ( tree , n , index ) ) ; }
int solve ( string str , int K ) { int N = str . Length ; dp = new int [ N , K ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < K ; j ++ ) { dp [ i , j ] = - 1 ; } } int ans = solveUtil ( 0 , 0 , str , K ) ; return ans == Int32 . MaxValue ? - 1 : ans ; }
long solve ( string str , int K ) { int n = str . Length ; long [ , ] dp = new long [ K , n ] ; if ( n < K ) return - 1 ; else if ( n == K ) return 0 ; long zeroes = 0 , ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) zeroes ++ ; else ones ++ ; dp [ 0 , i ] = ones * zeroes ; } for ( int s = 1 ; s < K ; s ++ ) { for ( int i = 0 ; i < n ; i ++ ) { dp [ s , i ] = Int32 . MaxValue ; ones = 0 ; zeroes = 0 ; for ( int k = i ; k >= 0 ; k -- ) { if ( str [ k ] == '0' ) zeroes ++ ; else ones ++ ; dp [ s , i ] = Math . Min ( dp [ s , i ] , + ( ( k - 1 >= 0 ) ? ones * zeroes + dp [ s - 1 , k - 1 ] : Int32 . MaxValue ) ) ; } } } return ( dp [ K - 1 , n - 1 ] == Int32 . MaxValue ) ? - 1 : dp [ K - 1 , n - 1 ] ; }
int max_sum ( int [ ] a , int n ) { int [ ] dp = new int [ n ] ; if ( n == 1 ) { dp [ 0 ] = Math . Max ( 0 , a [ 0 ] ) ; } else if ( n == 2 ) { dp [ 0 ] = Math . Max ( 0 , a [ 0 ] ) ; dp [ 1 ] = Math . Max ( a [ 1 ] , dp [ 0 ] ) ; } else if ( n >= 3 ) { dp [ 0 ] = Math . Max ( 0 , a [ 0 ] ) ; dp [ 1 ] = Math . Max ( a [ 1 ] , Math . Max ( 0 , a [ 0 ] ) ) ; dp [ 2 ] = Math . Max ( a [ 2 ] , Math . Max ( a [ 1 ] , Math . Max ( 0 , a [ 0 ] ) ) ) ; int i = 3 ; while ( i < n ) { dp [ i ] = Math . Max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) ; i ++ ; } } return dp [ n - 1 ] ; }
int minCount ( int K ) { int [ ] memo = new int [ 100 ] ; for ( int i = 0 ; i < 100 ; i ++ ) { memo [ i ] = int . MaxValue ; } memo [ 0 ] = 0 ; for ( int i = 1 ; i < 100 ; i ++ ) { memo [ i ] = Math . Min ( memo [ i - 1 ] + 1 , memo [ i ] ) ; } for ( int i = 10 ; i < 100 ; i ++ ) { memo [ i ] = Math . Min ( memo [ i - 10 ] + 1 , memo [ i ] ) ; } for ( int i = 25 ; i < 100 ; i ++ ) { memo [ i ] = Math . Min ( memo [ i - 25 ] + 1 , memo [ i ] ) ; } int min_count = 0 ; while ( K > 0 ) { min_count += memo [ K % 100 ] ; K /= 100 ; } return min_count ; }
int NoofWays ( int face , int throwsVal , int sum ) { if ( sum == 0 && throwsVal == 0 ) { return 1 ; } if ( sum < 0 throwsVal == 0 ) { return 0 ; } if ( dp [ throwsVal , sum ] != - 1 ) { return dp [ throwsVal , sum ] ; } int ans = 0 ; for ( int i = 1 ; i <= face ; i ++ ) { ans += NoofWays ( face , throwsVal - 1 , sum - i ) ; } return dp [ throwsVal , sum ] = ans ; }
void solve ( char [ ] s ) { int n = s . Length ; int [ , ] dp = new int [ n , n ] ; for ( int len = n - 1 ; len >= 0 ; -- len ) { for ( int i = 0 ; i + len < n ; ++ i ) { int j = i + len ; if ( i == 0 && j == n - 1 ) { if ( s [ i ] == s [ j ] ) dp [ i , j ] = 2 ; else if ( s [ i ] != s [ j ] ) dp [ i , j ] = 1 ; } else { if ( s [ i ] == s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i , j ] += dp [ i - 1 , j ] ; } if ( j + 1 <= n - 1 ) { dp [ i , j ] += dp [ i , j + 1 ] ; } if ( i - 1 < 0 j + 1 >= n ) { dp [ i , j ] += 1 ; } } else if ( s [ i ] != s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i , j ] += dp [ i - 1 , j ] ; } if ( j + 1 <= n - 1 ) { dp [ i , j ] += dp [ i , j + 1 ] ; } if ( i - 1 >= 0 && j + 1 <= n - 1 ) { dp [ i , j ] -= dp [ i - 1 , j + 1 ] ; } } } } } List < int > ways = new List < int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( i == 0 i == n - 1 ) { ways . Add ( 1 ) ; } else { int total = dp [ i - 1 , i + 1 ] ; ways . Add ( total ) ; } } for ( int i = 0 ; i < ways . Capacity ; ++ i ) { Console . Write ( ways [ i ] + " " ) ; } }
int maxSum ( int [ ] arr , int i , int n , int k ) { if ( i >= n ) return 0 ; if ( visit [ i ] ) return dp [ i ] ; visit [ i ] = true ; int tot = 0 ; dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; for ( int j = i ; j < ( i + k ) && ( j < n ) ; j ++ ) { tot += arr [ j ] ; dp [ i ] = Math . Max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; } return dp [ i ] ; }
int get_binary ( int u ) { int ans = 0 ; while ( u > 0 ) { int rem = u % 10 ; ans |= ( 1 << rem ) ; u /= 10 ; } return ans ; }
int waysutil ( int index , int sum , int count , List < int > arr , int K ) { if ( index < 0 ) { return 0 ; } if ( index == 0 ) { if ( count == 0 ) { return 0 ; } int remainder = sum % count ; if ( remainder != 0 ) { return 0 ; } int average = sum / count ; if ( average == K ) { return 1 ; } } if ( dp [ index , sum , count ] != - 1 ) { return dp [ index , sum , count ] ; } int dontpick = waysutil ( index - 1 , sum , count , arr , K ) ; int pick = waysutil ( index - 1 , sum + arr [ index ] , count + 1 , arr , K ) ; int total = pick + dontpick ; dp [ index , sum , count ] = total ; return total ; }
int ways ( int N , int K , int [ ] arr ) { List < int > Arr = new List < int > ( ) ; Arr . Add ( - 1 ) ; for ( int i = 0 ; i < N ; ++ i ) { Arr . Add ( arr [ i ] ) ; } for ( int i = 0 ; i < MAX_INDEX ; i ++ ) { for ( int j = 0 ; j < MAX_SUM ; j ++ ) { for ( int l = 0 ; l < MAX_INDEX ; l ++ ) { dp [ i , j , l ] = - 1 ; } } } int answer = waysutil ( N , 0 , 0 , Arr , K ) ; return answer ; }
int RetClose ( int a , int b , int s ) { if ( Math . Abs ( a - s ) < Math . Abs ( b - s ) ) return a ; else return b ; }
void FindClose ( int [ ] arr , int n ) { int ans = inf ; for ( int i = 1 ; i <= n ; i ++ ) ans = RetClose ( arr [ i - 1 ] + MinDiff ( i , arr [ i - 1 ] , arr , n ) , ans , 0 ) ; Console . WriteLine ( ans ) ; }
int FindMax ( int i , int r , int [ ] w , int n , int c , int k ) { if ( i >= n ) { return 0 ; } if ( v [ i ] [ r ] ) { return dp [ i ] [ r ] ; } v [ i ] [ r ] = true ; dp [ i ] [ r ] = FindMax ( i + 1 , r , w , n , c , k ) ; for ( int j = 0 ; j < k ; j ++ ) { int x = ( r / exp_c [ j ] ) % ( c + 1 ) ; if ( x - w [ i ] >= 0 ) { dp [ i ] [ r ] = Math . Max ( dp [ i ] [ r ] , w [ i ] + FindMax ( i + 1 , r - w [ i ] * exp_c [ j ] , w , n , c , k ) ) ; } } return dp [ i ] [ r ] ; }
int PreCompute ( int n , int c , int k ) { for ( int i = 0 ; i < k ; i ++ ) { exp_c . Add ( 0 ) ; } exp_c [ 0 ] = 1 ; for ( int i = 1 ; i < k ; i ++ ) { exp_c [ i ] = ( exp_c [ i - 1 ] * ( c + 1 ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { dp . Add ( new List < int > ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < ( exp_c [ k - 1 ] * ( c + 1 ) ) ; j ++ ) { dp [ i ] . Add ( 0 ) ; } } for ( int i = 0 ; i < n ; i ++ ) { v . Add ( new List < bool > ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < ( exp_c [ k - 1 ] * ( c + 1 ) ) ; j ++ ) { v [ i ] . Add ( false ) ; } } int R = 0 ; for ( int i = 0 ; i < k ; i ++ ) { R += exp_c [ i ] * c ; } return R ; }
int findMax ( int i , int r , int [ ] w , int n ) { if ( r < 0 ) return Int32 . MaxValue ; if ( i == n ) return 0 ; if ( v [ i , r ] ) return dp [ i , r ] ; v [ i , r ] = true ; dp [ i , r ] = Math . Max ( w [ i ] + findMax ( i + 1 , r - w [ i ] , w , n ) , findMax ( i + 1 , r , w , n ) ) ; return dp [ i , r ] ; }
void preCompute ( int [ ] w , int n ) { for ( int i = C_MAX ; i >= 0 ; i -- ) findMax ( 0 , i , w , n ) ; }
int ansQuery ( int w ) { return dp [ 0 , w ] ; }
int minSum ( int [ ] A , int [ ] B , int [ ] C , int i , int n , int curr , int [ , ] dp ) { if ( n <= 0 ) return 0 ; if ( dp [ n , curr ] != - 1 ) return dp [ n , curr ] ; if ( curr == 0 ) { return dp [ n , curr ] = Math . Min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; } if ( curr == 1 ) return dp [ n , curr ] = Math . Min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; return dp [ n , curr ] = Math . Min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) ; }
void findPrefixSum ( int [ ] arr , int n ) { prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix_sum [ i ] = arr [ i ] + prefix_sum [ i - 1 ] ; } }
int maxSum ( int [ ] arr , int i , int n , int k ) { if ( i + k > n ) { return 0 ; } if ( v [ i ] ) { return dp [ i ] ; } v [ i ] = true ; int x ; if ( i == 0 ) { x = prefix_sum [ k - 1 ] ; } else { x = prefix_sum [ i + k - 1 ] - prefix_sum [ i - 1 ] ; } dp [ i ] = Math . Max ( maxSum ( arr , i + 1 , n , k ) , x + maxSum ( arr , i + k + 1 , n , k ) ) ; return dp [ i ] ; }
long getChicks ( int n ) { int size = Math . Max ( n , 7 ) ; long [ ] dp = new long [ size ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < 6 ; i ++ ) { dp [ i ] = dp [ i - 1 ] * 3 ; } dp [ 6 ] = 726 ; for ( int i = 8 ; i <= n ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] - ( 2 * dp [ i - 6 ] / 3 ) ) * 3 ; } return dp [ n ] ; }
int getChicks ( int n ) { int chicks = ( int ) Math . Pow ( 3 , n - 1 ) ; return chicks ; }
int MaximumMarks ( int [ ] marksarr , int [ ] timearr , int h , int n , int p ) { int no_of_topics = n + 1 ; int total_time = h + 1 ; int [ , ] T = new int [ no_of_topics , total_time ] ; int i , j ; for ( i = 0 ; i < no_of_topics ; i ++ ) { T [ i , 0 ] = 0 ; } for ( j = 0 ; j < total_time ; j ++ ) { T [ 0 , j ] = 0 ; } for ( i = 1 ; i < no_of_topics ; i ++ ) { for ( j = 1 ; j < total_time ; j ++ ) { if ( j < timearr [ i ] ) { T [ i , j ] = T [ i - 1 , j ] ; } else { T [ i , j ] = Math . Max ( marksarr [ i ] + T [ i - 1 , j - timearr [ i ] ] , T [ i - 1 , j ] ) ; } } } i = no_of_topics - 1 ; j = total_time - 1 ; int sum = 0 ; while ( i > 0 && j > 0 ) { if ( T [ i , j ] == T [ i - 1 , j ] ) { i -- ; } else { sum += timearr [ i ] ; j -= timearr [ i ] ; i -- ; } } int marks = T [ no_of_topics - 1 , total_time - 1 ] ; if ( marks < p ) return - 1 ; return sum ; }
void findSum ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; }
int cntWays ( int [ ] arr , int i , int ck , int k , int n , int curr_sum ) { if ( sum % k != 0 ) return 0 ; if ( i != n && ck == k + 1 ) return 0 ; if ( i == n ) { if ( ck == k + 1 ) return 1 ; else return 0 ; } if ( v [ i , ck ] ) return dp [ i , ck ] ; curr_sum += arr [ i ] ; v [ i , ck ] = true ; dp [ i , ck ] = cntWays ( arr , i + 1 , ck , k , n , curr_sum ) ; if ( curr_sum == ( sum / k ) * ck ) dp [ i , ck ] += cntWays ( arr , i + 1 , ck + 1 , k , n , curr_sum ) ; return dp [ i , ck ] ; }
int SubsetCnt ( int i , int s , int [ ] arr , int n ) { if ( i == n ) { if ( s == 0 ) { return 1 ; } else { return 0 ; } } if ( visit [ i , s + arrSize ] ) { return dp [ i , s + arrSize ] ; } visit [ i , s + arrSize ] = true ; dp [ i , s + arrSize ] = SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ; return dp [ i , s + arrSize ] ; }
int sumMax ( int i , int [ ] arr , int n ) { if ( i >= n - 1 ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = Math . Max ( arr [ i ] + arr [ i + 1 ] + sumMax ( i + 3 , arr , n ) , sumMax ( i + 1 , arr , n ) ) ; return dp [ i ] ; }
int MaxIncreasingSub ( int [ ] arr , int n , int k ) { int [ , ] dp = new int [ n , k + 1 ] ; int ans = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < k + 1 ; j ++ ) dp [ i , j ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i , 1 ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { for ( int l = 1 ; l <= k - 1 ; l ++ ) { if ( dp [ j , l ] != - 1 ) { dp [ i , l + 1 ] = Math . Max ( dp [ i , l + 1 ] , dp [ j , l ] + arr [ i ] ) ; } } } } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans < dp [ i , k ] ) ans = dp [ i , k ] ; } return ( ans == - 1 ) ? 0 : ans ; }
void solve ( int remSum , int maxVal , int idx , int count ) { if ( remSum == 0 ) { print ( idx ) ; count ++ ; return ; } for ( int i = maxVal ; i >= 1 ; i -- ) { if ( i > remSum ) { continue ; } else if ( i <= remSum ) { dp [ idx ] = i ; solve ( remSum - i , i , idx + 1 , count ) ; } } }
void findPrefixCount ( int [ , ] arr ) { for ( int i = 0 ; i < bitscount ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { prefix_count [ i , j , 0 ] = ( ( arr [ j , 0 ] >> i ) & 1 ) ; for ( int k = 1 ; k < n ; k ++ ) { prefix_count [ i , j , k ] = ( ( arr [ j , k ] >> i ) & 1 ) ; prefix_count [ i , j , k ] += prefix_count [ i , j , k - 1 ] ; } } } for ( int i = 0 ; i < bitscount ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) prefix_count [ i , j , k ] += prefix_count [ i , j - 1 , k ] ; }
int rangeOr ( int x1 , int y1 , int x2 , int y2 ) { int ans = 0 ; for ( int i = 0 ; i < bitscount ; i ++ ) { int p ; if ( x1 == 0 && y1 == 0 ) p = prefix_count [ i , x2 , y2 ] ; else if ( x1 == 0 ) p = prefix_count [ i , x2 , y2 ] - prefix_count [ i , x2 , y1 - 1 ] ; else if ( y1 == 0 ) p = prefix_count [ i , x2 , y2 ] - prefix_count [ i , x1 - 1 , y2 ] ; else p = prefix_count [ i , x2 , y2 ] - prefix_count [ i , x1 - 1 , y2 ] - prefix_count [ i , x2 , y1 - 1 ] + prefix_count [ i , x1 - 1 , y1 - 1 ] ; if ( p != 0 ) ans = ( ans | ( 1 << i ) ) ; } return ans ; }
void findPrefixCount ( int [ , ] arr ) { for ( int i = 0 ; i < bitscount ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { prefix_count [ i , j , 0 ] = ( ( arr [ j , 0 ] >> i ) & 1 ) ; for ( int k = 1 ; k < n ; k ++ ) { prefix_count [ i , j , k ] = ( ( arr [ j , k ] >> i ) & 1 ) ; prefix_count [ i , j , k ] += prefix_count [ i , j , k - 1 ] ; } } } for ( int i = 0 ; i < bitscount ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) prefix_count [ i , j , k ] += prefix_count [ i , j - 1 , k ] ; }
void findPrefixCount ( int [ ] arr , int n ) { for ( int i = 0 ; i < bitscount ; i ++ ) { prefix_count [ i , 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( int j = 1 ; j < n ; j ++ ) { prefix_count [ i , j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefix_count [ i , j ] += prefix_count [ i , j - 1 ] ; } } }
int rangeOr ( int l , int r ) { int ans = 0 ; for ( int i = 0 ; i < bitscount ; i ++ ) { int x ; if ( l == 0 ) x = prefix_count [ i , r ] ; else x = prefix_count [ i , r ] - prefix_count [ i , l - 1 ] ; if ( x != 0 ) ans = ( ans | ( 1 << i ) ) ; } return ans ; }
int palindromeSubStrs ( String s ) { int [ , ] dp = new int [ s . Length , s . Length ] ; int st , end , i , len ; Dictionary < String , Boolean > m = new Dictionary < String , Boolean > ( ) ; for ( i = 0 ; i < s . Length ; i ++ ) { dp [ i , i ] = 1 ; if ( ! m . ContainsKey ( s . Substring ( i , 1 ) ) ) m . Add ( s . Substring ( i , 1 ) , true ) ; } for ( i = 0 ; i < s . Length - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { dp [ i , i + 1 ] = 1 ; if ( ! m . ContainsKey ( s . Substring ( i , 2 ) ) ) m . Add ( s . Substring ( i , 2 ) , true ) ; } else dp [ i , i + 1 ] = 0 ; } for ( len = 3 ; len <= s . Length ; len ++ ) { for ( st = 0 ; st <= s . Length - len ; st ++ ) { end = st + len - 1 ; if ( s [ st ] == s [ end ] && dp [ st + 1 , end - 1 ] == 1 ) { dp [ st , end ] = 1 ; m . Add ( s . Substring ( st , end + 1 - st ) , true ) ; } else dp [ st , end ] = 0 ; } } return m . Count ; }
int maxSum ( int [ ] arr , int i , int n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = Math . Max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; }
int countWays ( int i , int j , int x , int [ , ] arr ) { if ( i == n j == n ) { return 0 ; } x = ( x & arr [ i , j ] ) ; if ( x == 0 ) { return 0 ; } if ( i == n - 1 && j == n - 1 ) { return 1 ; } if ( v [ i , j , x ] == 1 ) { return dp [ i , j , x ] ; } v [ i , j , x ] = 1 ; dp [ i , j , x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; return dp [ i , j , x ] ; }
int minSteps ( int i , int j , int [ , ] arr ) { if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; } if ( v [ i , j ] == 1 ) { return dp [ i , j ] ; } v [ i , j ] = 1 ; dp [ i , j ] = 9999999 ; for ( int k = Math . Max ( 0 , arr [ i , j ] + j - n + 1 ) ; k <= Math . Min ( n - i - 1 , arr [ i , j ] ) ; k ++ ) { dp [ i , j ] = Math . Min ( dp [ i , j ] , minSteps ( i + k , j + arr [ i , j ] - k , arr ) ) ; } dp [ i , j ] ++ ; return dp [ i , j ] ; }
int minSteps ( int i , int j , int [ , ] arr ) { if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; } if ( v [ i , j ] == 1 ) { return dp [ i , j ] ; } v [ i , j ] = 1 ; dp [ i , j ] = 1 + Math . Min ( minSteps ( i + arr [ i , j ] , j , arr ) , minSteps ( i , j + arr [ i , j ] , arr ) ) ; return dp [ i , j ] ; }
int oSRec ( int [ ] arr , int i , int j , int sum ) { if ( j == i + 1 ) return Math . Max ( arr [ i ] , arr [ j ] ) ; return Math . Max ( ( sum - oSRec ( arr , i + 1 , j , sum - arr [ i ] ) ) , ( sum - oSRec ( arr , i , j - 1 , sum - arr [ j ] ) ) ) ; }
int optimalStrategyOfGame ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } return oSRec ( arr , 0 , n - 1 , sum ) ; }
int oSRec ( int [ ] arr , int i , int j , int sum ) { if ( j == i + 1 ) return Math . Max ( arr [ i ] , arr [ j ] ) ; if ( memo [ i , j ] != - 1 ) return memo [ i , j ] ; memo [ i , j ] = Math . Max ( ( sum - oSRec ( arr , i + 1 , j , sum - arr [ i ] ) ) , ( sum - oSRec ( arr , i , j - 1 , sum - arr [ j ] ) ) ) ; return memo [ i , j ] ; }
int optimalStrategyOfGame ( int [ ] arr , int n ) { int sum = 0 ; sum = accumulate ( arr , 0 , n ) ; for ( int j = 0 ; j < MAX ; j ++ ) { for ( int k = 0 ; k < MAX ; k ++ ) memo [ j , k ] = - 1 ; } return oSRec ( arr , 0 , n - 1 , sum ) ; }
long number ( String s , int i , int j ) { long ans = 0 ; for ( int x = i ; x < j ; x ++ ) { ans = ans * 2 + ( s [ x ] - '0' ) ; } return ans ; }
int minCuts ( String s , int n ) { int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = n + 1 ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( s [ i - 1 ] == '0' ) { continue ; } for ( int j = 0 ; j < i ; j ++ ) { if ( s [ j ] == '0' ) { continue ; } long num = number ( s , j , i ) ; if ( ! ispower ( num ) ) { continue ; } dp [ i ] = Math . Min ( dp [ i ] , dp [ j ] + 1 ) ; } } return ( ( dp [ n ] < n + 1 ) ? dp [ n ] : - 1 ) ; }
int sum ( int i1 , int j1 , int i2 , int j2 ) { if ( i1 == i2 && j1 == j2 ) { return arr [ i1 , j1 ] ; } return arr [ i1 , j1 ] + arr [ i2 , j2 ] ; }
int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . Min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
int MinOfCubedDP ( int k ) { int [ ] DP = new int [ k + 1 ] ; int j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { DP [ i ] = int . MaxValue ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; }
int getMaximumSum ( int [ ] a , int n , int x ) { int [ , ] dp = new int [ n , 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { dp [ i , j ] = - 1 ; } } int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxi = Math . Max ( maxi , func ( i , 0 , a , dp , n , x ) ) ; } return maxi ; }
void pre_process ( bool [ , ] dp , char [ ] s ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i , j ] = false ; } } for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i , i + j - 1 ] = true ; } } else if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i , i + j - 1 ] = dp [ i + 1 , i + j - 2 ] ; } } } }
int countPairs ( String s ) { bool [ , ] dp = new bool [ N , N ] ; pre_process ( dp , s . ToCharArray ( ) ) ; int n = s . Length ; int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; left [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( dp [ j , i ] == true ) { left [ i ] ++ ; } } } right [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { right [ i ] = right [ i + 1 ] ; for ( int j = n - 1 ; j >= i ; j -- ) { if ( dp [ i , j ] == true ) { right [ i ] ++ ; } } } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans += left [ i ] * right [ i + 1 ] ; } return ans ; }
void answerQuery ( int l , int r , bool [ , ] dp ) { if ( dp [ l , r ] ) { Console . WriteLine ( "Yes" ) ; } else { Console . WriteLine ( "No" ) ; } }
int LIS ( int [ ] a , int n ) { int [ ] dp = new int [ N ] ; int [ ] d = new int [ N ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . Max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . Max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . Max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
bool check ( String s ) { int n = s . Length ; for ( int i = 2 ; i < n ; i ++ ) { if ( s [ i ] == '1' && s [ i - 1 ] == '1' && s [ i - 2 ] == '1' ) return true ; } return false ; }
int solve ( int i , int x , int [ , ] dp ) { if ( i < 0 ) { return x == 3 ? 1 : 0 ; } if ( dp [ i , x ] != - 1 ) { return dp [ i , x ] ; } dp [ i , x ] = solve ( i - 1 , 0 , dp ) ; dp [ i , x ] += solve ( i - 1 , x + 1 , dp ) ; return dp [ i , x ] ; }
void dfs ( int u , int p ) { foreach ( int v in g [ u ] ) { if ( v != p ) { dfs ( v , u ) ; for ( int i = 0 ; i < 22 ; i ++ ) a [ u , i ] += a [ v , i ] ; } } int pp = 0 ; for ( int i = 0 ; i < 22 ; i ++ ) { if ( ! ( ( a [ u , i ] > 0 && x [ i ] - a [ u , i ] > 0 ) || ( a [ u , i ] == 0 && x [ i ] == 0 ) ) ) { pp = 1 ; break ; } } if ( pp == 0 ) ans ++ ; }
int findCount ( int [ , ] mat , int i , int j , int m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 , 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i , j , m ] ) return dp [ i , j , m ] ; v [ i , j , m ] = true ; dp [ i , j , m ] = findCount ( mat , i - 1 , j , m - mat [ i , j ] ) + findCount ( mat , i , j - 1 , m - mat [ i , j ] ) ; return dp [ i , j , m ] ; }
int maxSum ( int [ ] arr , int k , int n ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . Max ( arr [ 0 ] , arr [ 1 ] ) ; int [ ] dp = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) dp [ i ] = Math . Max ( arr [ i ] , dp [ i - 1 ] ) ; for ( int i = k + 1 ; i < n ; i ++ ) dp [ i ] = Math . Max ( arr [ i ] , dp [ i - ( k + 1 ) ] + arr [ i ] ) ; int max = dp . Max ( ) ; return max ; }
void precompute ( ) { for ( int i = 0 ; i <= maxn ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; int [ ] vec = { 4 , 6 , 9 } ; for ( int i = 1 ; i < maxn ; ++ i ) { foreach ( int j in vec ) { if ( i >= j && dp [ i - j ] != - 1 ) { dp [ i ] = Math . Max ( dp [ i ] , dp [ i - j ] + 1 ) ; } } } }
int CountWays ( int r , int b , int l , int R , int B , int W , int [ , , ] dp ) { if ( l > W ) return 0 ; if ( r > R ) return 0 ; if ( b == B && r == R ) return 1 ; if ( b == B ) return 0 ; if ( dp [ r , b , l ] != - 1 ) return dp [ r , b , l ] ; int ans = 0 ; ans += CountWays ( r , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) ; ans = ans % mod ; return dp [ r , b , l ] = ans ; }
int FindMinimumCost ( int ind , int [ ] a , int n , int k , int [ ] dp ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { int ans = int . MaxValue ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . Min ( ans , Math . Abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
int minCostJumpsDP ( int [ ] A , int k ) { int size = A . Length ; int [ ] x = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) x [ i ] = int . MaxValue ; x [ 0 ] = 0 ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = i + 1 ; j < i + k + 1 && j < size ; j ++ ) { x [ j ] = min ( x [ j ] , x [ i ] + Math . Abs ( A [ i ] - A [ j ] ) ) ; } } return x [ size - 1 ] ; }
int FindMaximumSum ( int ind , int kon , int [ ] a , int [ ] b , int [ ] c , int n , int [ , ] dp ) { if ( ind == n ) return 0 ; if ( dp [ ind , kon ] != - 1 ) return dp [ ind , kon ] ; int ans = ( int ) ( - 1e9 + 5 ) ; if ( kon == 0 ) { ans = Math . Max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . Max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 1 ) { ans = Math . Max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; ans = Math . Max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 2 ) { ans = Math . Max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . Max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; } return dp [ ind , kon ] = ans ; }
bool isVowel ( char x ) { return ( x == 'a' x == 'e' x == 'i' x == 'o' x == 'u' ) ; }
int findMinimumDeletion ( int l , int r , int [ , ] dp , String s ) { if ( l > r ) { return 0 ; } if ( l == r ) { return 1 ; } if ( dp [ l , r ] != - 1 ) { return dp [ l , r ] ; } int res = 1 + findMinimumDeletion ( l + 1 , r , dp , s ) ; for ( int i = l + 1 ; i <= r ; ++ i ) { if ( s [ l ] == s [ i ] ) { res = Math . Min ( res , findMinimumDeletion ( l + 1 , i - 1 , dp , s ) + findMinimumDeletion ( i , r , dp , s ) ) ; } } return dp [ l , r ] = res ; }
int noOfBinaryStrings ( int N , int k ) { int [ ] dp = new int [ 100002 ] ; for ( int i = 1 ; i <= k - 1 ; i ++ ) { dp [ i ] = 1 ; } dp [ k ] = 2 ; for ( int i = k + 1 ; i <= N ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; } return dp [ N ] ; }
long answer ( int n ) { int [ ] dp = new int [ 10 ] ; int [ ] prev = new int [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { prev [ j ] = dp [ j ] ; } for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ j ] = prev [ j + 1 ] ; else if ( j == 9 ) dp [ j ] = prev [ j - 1 ] ; else dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ j ] ; return sum ; }
int MinimumCost ( int [ ] a , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = Math . Min ( a [ i ] , 2 * a [ i - 1 ] ) ; } int ind = 0 ; int sum = 0 ; while ( x > 0 ) { if ( x != 0 ) sum += a [ ind ] ; ind ++ ; x = x >> 1 ; } return sum ; }
void dfs ( int node , List < int > [ ] adj , int [ ] dp , Boolean [ ] visited ) { visited [ node ] = true ; for ( int i = 0 ; i < adj [ node ] . Count ; i ++ ) { if ( ! visited [ adj [ node ] [ i ] ] ) dfs ( adj [ node ] [ i ] , adj , dp , visited ) ; dp [ node ] = Math . Max ( dp [ node ] , 1 + dp [ adj [ node ] [ i ] ] ) ; } }
void sieve_modified ( ) { for ( int i = 2 ; i < MAX ; i += 2 ) { for ( int j = i ; j < MAX ; j += i ) { prefix [ j ] += i ; } } for ( int i = 1 ; i < MAX ; i ++ ) { prefix [ i ] += prefix [ i - 1 ] ; } }
void binomialCoeff ( int n ) { int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } }
int findSubarraySum ( int ind , int flips , int n , int [ ] a , int k ) { if ( flips > k ) return - ( int ) 1e9 ; if ( ind == n ) return 0 ; if ( dp [ ind , flips ] != - 1 ) return dp [ ind , flips ] ; int ans = 0 ; ans = Math . Max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ; ans = Math . Max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ; return dp [ ind , flips ] = ans ; }
void catalanDP ( long n ) { catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } } }
int CatalanSequence ( int [ ] arr , int n ) { catalanDP ( n ) ; HashSet < int > s = new HashSet < int > ( ) ; int a = 1 , b = 1 ; s . Add ( a ) ; if ( n >= 2 ) { s . Add ( b ) ; } for ( int i = 2 ; i < n ; i ++ ) { s . Add ( ( int ) catalan [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( s . Contains ( arr [ i ] ) ) { s . Remove ( arr [ i ] ) ; } } return s . Count ; }
int findSubsequence ( int [ ] arr , int n ) { int len = 1 ; int tmp ; int i , j , d ; int [ , ] dp = new int [ n , 10 ] ; int [ ] cnt = new int [ 10 ] ; int locMax ; tmp = arr [ 0 ] ; while ( tmp > 0 ) { dp [ 0 , tmp % 10 ] = 1 ; tmp /= 10 ; } for ( i = 1 ; i < n ; i ++ ) { tmp = arr [ i ] ; locMax = 1 ; for ( int x = 0 ; x < 10 ; x ++ ) cnt [ x ] = 0 ; while ( tmp > 0 ) { cnt [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] > 0 ) { dp [ i , d ] = 1 ; for ( j = 0 ; j < i ; j ++ ) { dp [ i , d ] = Math . Max ( dp [ i , d ] , dp [ j , d ] + 1 ) ; locMax = Math . Max ( dp [ i , d ] , locMax ) ; } } } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] > 0 ) { dp [ i , d ] = locMax ; } } len = Math . Max ( len , locMax ) ; } return len ; }
int solve ( int x ) { List < int > num = new List < int > ( ) ; while ( x != 0 ) { num . Add ( x % 10 ) ; x /= 10 ; } num . Reverse ( ) ; for ( int i = 0 ; i < dp . GetLength ( 0 ) ; i ++ ) for ( int j = 0 ; j < dp . GetLength ( 1 ) ; j ++ ) for ( int k = 0 ; k < dp . GetLength ( 2 ) ; k ++ ) for ( int k1 = 0 ; k1 < dp . GetLength ( 3 ) ; k1 ++ ) dp [ i , j , k , k1 ] = - 1 ; return count ( 0 , 0 , 0 , 0 , num ) ; }
void Add_edge ( int x , int y ) { gr [ x ] . Add ( y ) ; gr [ y ] . Add ( x ) ; }
void dfs ( int v , int par ) { d [ v , 0 ] = 1 ; foreach ( int i in gr [ v ] ) { if ( i != par ) { dfs ( i , v ) ; for ( int j = 1 ; j <= k ; j ++ ) ans += d [ i , j - 1 ] * d [ v , k - j ] ; for ( int j = 1 ; j <= k ; j ++ ) d [ v , j ] += d [ i , j - 1 ] ; } } }
int count ( int pos , int sum , int rem , int tight , int nonz , List < int > num ) { if ( pos == num . Count ) { if ( rem == 0 && sum == n ) return 1 ; return 0 ; } if ( dp [ pos , sum , rem , tight ] != - 1 ) return dp [ pos , sum , rem , tight ] ; int ans = 0 ; int limit = ( tight != 0 ? 9 : num [ pos ] ) ; for ( int d = 0 ; d <= limit ; d ++ ) { if ( d == 0 && nonz != 0 ) continue ; int currSum = sum + d ; int currRem = ( rem * 10 + d ) % m ; int currF = ( tight != 0 || ( d < num [ pos ] ) ) ? 1 : 0 ; ans += count ( pos + 1 , currSum , currRem , currF , ( nonz != 0 d != 0 ) ? 1 : 0 , num ) ; } return dp [ pos , sum , rem , tight ] = ans ; }
int findXorSum ( int [ ] arr , int n ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { int c_odd = 0 ; bool odd = false ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) odd = ( ! odd ) ; if ( odd ) c_odd ++ ; } for ( int j = 0 ; j < n ; j ++ ) { sum += ( mul * c_odd ) ; if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) c_odd = ( n - j - c_odd ) ; } mul *= 2 ; } return sum ; }
void preCompute ( ) { lpd [ 0 ] = lpd [ 1 ] = 1 ; for ( int i = 2 ; i * i < MAX ; i ++ ) { for ( int j = i * 2 ; j < MAX ; j += i ) { if ( lpd [ j ] == 0 ) { lpd [ j ] = i ; } } } for ( int i = 2 ; i < MAX ; i ++ ) { if ( lpd [ i ] == 0 ) { lpd [ i ] = i ; } } }
int maxLengthSubsequence ( int [ ] arr , int n ) { int [ ] dp = new int [ N ] ; Hashtable pos = new Hashtable ( ) ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { while ( arr [ i ] > 1 ) { int p = lpd [ arr [ i ] ] ; if ( pos . ContainsKey ( p ) ) { dp [ i ] = Math . Max ( dp [ i ] , 1 + dp [ Convert . ToInt32 ( pos [ p ] ) ] ) ; } pos [ p ] = i ; while ( arr [ i ] % p == 0 ) arr [ i ] /= p ; } } int ans = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { ans = Math . Max ( ans , dp [ i ] ) ; } return ans ; }
int charVal ( string s , int i ) { if ( s [ i ] == '0' ) { return 0 ; } else if ( s [ i ] == '1' ) { return 1 ; } else { return 2 ; } }
int getSum ( int r1 , int r2 , int c1 , int c2 , int [ , ] dp ) { return dp [ r2 , c2 ] - dp [ r2 , c1 ] - dp [ r1 , c2 ] + dp [ r1 , c1 ] ; }
bool sumFound ( int K , int S , int [ , ] grid ) { int [ , ] dp = new int [ N + 1 , N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i + 1 , j + 1 ] = dp [ i + 1 , j ] + dp [ i , j + 1 ] - dp [ i , j ] + grid [ i , j ] ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int sum = getSum ( i , i + K , j , j + K , dp ) ; if ( sum == S ) { return true ; } } } return false ; }
int totalSubSets ( int n , int l , int r ) { int zero = ( int ) Math . Floor ( ( double ) r / 3 ) - ( int ) Math . Ceiling ( ( double ) l / 3 ) + 1 ; int one = ( int ) Math . Floor ( ( double ) ( r - 1 ) / 3 ) - ( int ) Math . Ceiling ( ( double ) ( l - 1 ) / 3 ) + 1 ; int two = ( int ) Math . Floor ( ( double ) ( r - 2 ) / 3 ) - ( int ) Math . Ceiling ( ( double ) ( l - 2 ) / 3 ) + 1 ; int [ , ] dp = new int [ n , 3 ] ; dp [ 0 , 0 ] = zero ; dp [ 0 , 1 ] = one ; dp [ 0 , 2 ] = two ; for ( int i = 1 ; i < n ; ++ i ) { dp [ i , 0 ] = ( ( dp [ i - 1 , 0 ] * zero ) + ( dp [ i - 1 , 1 ] * two ) + ( dp [ i - 1 , 2 ] * one ) ) % MOD ; dp [ i , 1 ] = ( ( dp [ i - 1 , 0 ] * one ) + ( dp [ i - 1 , 1 ] * zero ) + ( dp [ i - 1 , 2 ] * two ) ) % MOD ; dp [ i , 2 ] = ( ( dp [ i - 1 , 0 ] * two ) + ( dp [ i - 1 , 1 ] * one ) + ( dp [ i - 1 , 2 ] * zero ) ) % MOD ; } return dp [ n - 1 , 0 ] ; }
int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx , diff ] != - 1 ) return dp [ idx , diff ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx , diff ] = ans % MOD ; }
int maxPathSum ( int [ , ] tri ) { int ans = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i , j ] += Math . Max ( tri [ i + 1 , j ] , tri [ i + 1 , j - 1 ] ) ; else tri [ i , j ] += tri [ i + 1 , j ] ; ans = Math . Max ( ans , tri [ i , j ] ) ; } } return ans ; }
int subsetXOR ( int [ ] arr , int n , int K ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( Math . Log ( max_ele ) / Math . Log ( 2 ) + 1 ) ) - 1 ; int [ , , ] dp = new int [ n + 1 , m + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) for ( int k = 0 ; k <= n ; k ++ ) dp [ i , j , k ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { dp [ i , j , k ] = dp [ i - 1 , j , k ] ; if ( k != 0 ) { dp [ i , j , k ] += k * dp [ i - 1 , j ^ arr [ i - 1 ] , k - 1 ] ; } } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans += dp [ n , K , i ] ; } return ans ; }
float calcProbability ( int [ , ] M , int k ) { float [ , ] dp = new float [ m , n ] ; float [ ] sum = new float [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { dp [ 0 , j ] = M [ 0 , j ] ; sum [ 0 ] = sum [ 0 ] + dp [ 0 , j ] ; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i , j ] += dp [ i - 1 , j ] / sum [ i - 1 ] + M [ i , j ] ; sum [ i ] += dp [ i , j ] ; } } return dp [ n - 1 , k - 1 ] / sum [ n - 1 ] ; }
int MaximumNumbers ( String s ) { int n = s . Length ; int [ ] remIndex = { - 1 , - 1 , - 1 } ; remIndex [ 0 ] = 0 ; int [ ] res = new int [ n + 1 ] ; int r = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { r = ( r + s [ i - 1 ] - '0' ) % 3 ; res [ i ] = res [ i - 1 ] ; if ( remIndex [ r ] != - 1 ) res [ i ] = Math . Max ( res [ i ] , res [ remIndex [ r ] ] + 1 ) ; remIndex [ r ] = i + 1 ; } return res [ n ] ; }
int get_max_splits ( String num_String ) { int count = 0 , current_num ; int running_sum = 0 ; for ( int i = 0 ; i < num_String . Length ; i ++ ) { current_num = num_String [ i ] - '0' ; running_sum += current_num ; if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; }
int findMinimumSteps ( int [ , ] mat , int x , int y , int n ) { int i , j , k ; int [ , ] dist = new int [ n , n ] ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( mat [ i , j ] == 0 ) dist [ i , j ] = INF ; else dist [ i , j ] = 1 ; if ( i == j ) dist [ i , j ] = 1 ; } } for ( k = 0 ; k < n ; k ++ ) { for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( dist [ i , k ] + dist [ k , j ] < dist [ i , j ] ) dist [ i , j ] = dist [ i , k ] + dist [ k , j ] ; } } } if ( dist [ x , y ] < INF ) return dist [ x , y ] ; else return - 1 ; }
bool findmatch ( char [ , ] mat , String pat , int x , int y , int nrow , int ncol , int level ) { int l = pat . Length ; if ( level == l ) return true ; if ( x < 0 y < 0 >= nrow y >= ncol ) return false ; if ( mat [ x , y ] == pat [ level ] ) { char temp = mat [ x , y ] ; mat [ x , y ] = '#' ; bool res = findmatch ( mat , pat , x - 1 , y , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x + 1 , y , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x , y - 1 , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x , y + 1 , nrow , ncol , level + 1 ) ; mat [ x , y ] = temp ; return res ; } return false ; }
bool checkMatch ( char [ , ] mat , String pat , int nrow , int ncol ) { int l = pat . Length ; if ( l > nrow * ncol ) return false ; for ( int i = 0 ; i < nrow ; i ++ ) { for ( int j = 0 ; j < ncol ; j ++ ) { if ( mat [ i , j ] == pat [ 0 ] ) if ( findmatch ( mat , pat , i , j , nrow , ncol , 0 ) ) return true ; } } return false ; }
int countPaths ( int sum , int get , int m , int n , int [ , ] dp ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum , get ] != - 1 ) return dp [ sum , get ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum , get ] = res ; return dp [ sum , get ] ; }
int countInRange ( int x ) { num = new List < int > ( ) ; while ( x != 0 ) { num . Add ( x % 10 ) ; x /= 10 ; } num . Reverse ( ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) dp [ i , j , k ] = - 1 ; return countInRangeUtil ( 0 , 0 , 0 ) ; }
int solve ( int x ) { List < int > num = new List < int > ( ) ; while ( x != 0 ) { num . Add ( x % 10 ) ; x /= 10 ; } num . Reverse ( ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) dp [ i , j , k , l ] = - 1 ; return count ( 0 , 0 , 0 , 0 , num ) ; }
int bin ( int a , int b ) { int ans = ( ( fac [ a ] ) / ( fac [ a - b ] * fac [ b ] ) ) ; return ans ; }
int sumofn ( int n , int k ) { int p = 0 ; int num1 , temp ; int [ ] arr = new int [ 1000 ] ; for ( int j = 1 ; j <= k ; j ++ ) { if ( j == 1 ) { num1 = ( n * ( n + 1 ) ) / 2 ; arr [ p ++ ] = num1 ; temp = num1 ; } else { temp = ( ( int ) Math . Pow ( n + 1 , j + 1 ) - 1 - n ) ; for ( int s = 1 ; s < j ; s ++ ) { temp = temp - ( arr [ j - s - 1 ] * bin ( j + 1 , s + 1 ) ) ; } temp = temp / ( j + 1 ) ; arr [ p ++ ] = temp ; } } temp = arr [ p - 1 ] ; return temp ; }
int findMinOperations ( String S ) { S = reverse ( S ) ; int n = S . Length ; int [ , ] dp = new int [ n + 1 , 2 ] ; if ( S [ 0 ] == '0' ) { dp [ 0 , 0 ] = 0 ; } else { dp [ 0 , 0 ] = 1 ; } dp [ 0 , 1 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( S [ i ] == '0' ) { dp [ i , 0 ] = dp [ i - 1 , 0 ] ; dp [ i , 1 ] = 1 + Math . Min ( dp [ i - 1 , 1 ] , dp [ i - 1 , 0 ] ) ; } else { dp [ i , 1 ] = dp [ i - 1 , 1 ] ; dp [ i , 0 ] = 1 + Math . Min ( dp [ i - 1 , 0 ] , dp [ i - 1 , 1 ] ) ; } } return dp [ n - 1 , 0 ] ; }
int solve ( int x ) { int ans = 0 , first = 0 , last , temp = x ; if ( x < 10 ) return x ; last = x % 10 ; while ( x != 0 ) { first = x % 10 ; x /= 10 ; } if ( first <= last ) ans = 9 + temp / 10 ; else ans = 8 + temp / 10 ; return ans ; }
int findMinimumCost ( int n , int x , int y ) { int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = x ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) != 0 ) { dp [ i ] = Math . Min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) / 2 ] + y + x ) ; } else { dp [ i ] = Math . Min ( dp [ i - 1 ] + x , dp [ i / 2 ] + y ) ; } } return dp [ n ] ; }
int countWays ( int index , int cnt , int [ , ] dp , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index , cnt ] != - 1 ) return dp [ index , cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index , cnt ] = ans ; }
int findMinSteps ( int [ , ] mat , int n , int m , int [ , ] dp , bool [ , ] vis ) { if ( n == 0 || m == 0 || n == ( r - 1 ) || m == ( c - 1 ) ) { return 0 ; } if ( dp [ n , m ] != - 1 ) return dp [ n , m ] ; vis [ n , m ] = true ; int ans1 , ans2 , ans3 , ans4 ; ans1 = ans2 = ans3 = ans4 = ( int ) 1e9 ; if ( mat [ n - 1 , m ] == 0 ) { if ( ! vis [ n - 1 , m ] ) ans1 = 1 + findMinSteps ( mat , n - 1 , m , dp , vis ) ; } if ( mat [ n , m + 1 ] == 0 ) { if ( ! vis [ n , m + 1 ] ) ans2 = 1 + findMinSteps ( mat , n , m + 1 , dp , vis ) ; } if ( mat [ n , m - 1 ] == 0 ) { if ( ! vis [ n , m - 1 ] ) ans3 = 1 + findMinSteps ( mat , n , m - 1 , dp , vis ) ; } if ( mat [ n + 1 , m ] == 0 ) { if ( ! vis [ n + 1 , m ] ) ans4 = 1 + findMinSteps ( mat , n + 1 , m , dp , vis ) ; } dp [ n , m ] = Math . Min ( ans1 , Math . Min ( ans2 , Math . Min ( ans3 , ans4 ) ) ) ; return dp [ n , m ] ; }
int minimumSteps ( int [ , ] mat , int n , int m ) { int twox = - 1 ; int twoy = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i , j ] == 2 ) { twox = i ; twoy = j ; break ; } } if ( twox != - 1 ) break ; } int [ , ] dp = new int [ r , r ] ; for ( int j = 0 ; j < r ; j ++ ) for ( int i = 0 ; i < r ; i ++ ) dp [ j , i ] = - 1 ; bool [ , ] vis = new bool [ r , r ] ; for ( int j = 0 ; j < r ; j ++ ) for ( int i = 0 ; i < r ; i ++ ) vis [ j , i ] = false ; int res = findMinSteps ( mat , twox , twoy , dp , vis ) ; if ( res >= 1e9 ) return - 1 ; else return res ; }
int nCr ( int n , int r ) { int ans = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; i ++ ) { ans *= ( n - i ) ; ans /= ( i + 1 ) ; } return ans ; }
int countDerangements ( int n ) { int [ ] der = new int [ n + 3 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
int countPermutations ( int n , int k ) { int ans = 0 ; for ( int i = n - k ; i <= n ; i ++ ) { int ways = nCr ( n , i ) ; ans += ( ways * countDerangements ( n - i ) ) ; } return ans ; }
int solve ( int [ , ] dp , int wt , int K , int M , int used ) { if ( wt < 0 ) return 0 ; if ( wt == 0 ) { if ( used == 1 ) return 1 ; return 0 ; } if ( dp [ wt , used ] != - 1 ) return dp [ wt , used ] ; int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( i >= M ) ans += solve ( dp , wt - i , K , M , used 1 ) ; else ans += solve ( dp , wt - i , K , M , used ) ; } return dp [ wt , used ] = ans ; }
int squares ( int i ) { if ( ( i & 1 ) == 1 ) return i / 4 * 2 + 1 ; else return ( i - 1 ) / 4 * 2 + 2 ; }
long bishop_placements ( int n , int k ) { if ( k > 2 * n - 1 ) return 0 ; long [ , ] dp = new long [ n * 2 , k + 1 ] ; for ( int i = 0 ; i < n * 2 ; i ++ ) dp [ i , 0 ] = 1 ; dp [ 1 , 1 ] = 1 ; for ( int i = 2 ; i < n * 2 ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) dp [ i , j ] = dp [ i - 2 , j ] + dp [ i - 2 , j - 1 ] * ( squares ( i ) - j + 1 ) ; } long ans = 0 ; for ( int i = 0 ; i <= k ; i ++ ) { ans += dp [ n * 2 - 1 , i ] * dp [ n * 2 - 2 , k - i ] ; } return ans ; }
int sumOddFibonacci ( int n ) { int [ ] Sum = new int [ n + 1 ] ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( int i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; }
int noOfAssignments ( String s , int n , int i , int c_x , int c_y ) { if ( F [ i , c_x , c_y ] != - 1 ) return F [ i , c_x , c_y ] ; if ( i == n ) { F [ i , c_x , c_y ] = ( c_x == 0 && c_y == 0 ) ? 1 : 0 ; return F [ i , c_x , c_y ] ; } if ( s [ i ] == '(' ) { F [ i , c_x , c_y ] = noOfAssignments ( s , n , i + 1 , c_x + 1 , c_y ) + noOfAssignments ( s , n , i + 1 , c_x , c_y + 1 ) ; return F [ i , c_x , c_y ] ; } F [ i , c_x , c_y ] = 0 ; if ( c_x != 0 ) F [ i , c_x , c_y ] += noOfAssignments ( s , n , i + 1 , c_x - 1 , c_y ) ; if ( c_y != 0 ) F [ i , c_x , c_y ] += noOfAssignments ( s , n , i + 1 , c_x , c_y - 1 ) ; return F [ i , c_x , c_y ] ; }
int noOfAssignments ( string S , int n , int i , int c_x ) { if ( F [ i , c_x ] != - 1 ) { return F [ i , c_x ] ; } if ( i == n ) { if ( c_x == 1 ) { F [ i , c_x ] = 0 ; } else { F [ i , c_x ] = 1 ; } return F [ i , c_x ] ; } int c_y = C [ i ] - c_x ; if ( S [ i ] == '(' ) { F [ i , c_x ] = noOfAssignments ( S , n , i + 1 , c_x + 1 ) + noOfAssignments ( S , n , i + 1 , c_x ) ; return F [ i , c_x ] ; } F [ i , c_x ] = 0 ; if ( c_x == 1 ) { F [ i , c_x ] += noOfAssignments ( S , n , i + 1 , c_x - 1 ) ; } if ( c_y == 1 ) { F [ i , c_x ] += noOfAssignments ( S , n , i + 1 , c_x ) ; } return F [ i , c_x ] ; }
int MaxProfit ( int [ ] treasure , int [ ] color , int n , int k , int col , int A , int B ) { int sum = 0 ; if ( k == n ) return 0 ; if ( col == color [ k ] ) sum += Math . Max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . Max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return sum ; }
int calculateEvenSum ( int n ) { if ( n <= 0 ) return 0 ; int [ ] fibo = new int [ 2 * n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = 0 ; for ( int i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; }
int fib ( int n ) { if ( n == 0 ) { return 0 ; } if ( n == 1 n == 2 ) { return ( f [ n ] = 1 ) ; } if ( f [ n ] == 1 ) { return f [ n ] ; } int k = ( n % 2 == 1 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( n % 2 == 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
int calculateEvenSum ( int n ) { return ( fib ( 2 * n + 1 ) - 1 ) ; }
int find ( int index , int openbrk , int n , int [ , ] adj ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index , openbrk ] != - 1 ) return dp [ index , openbrk ] ; dp [ index , openbrk ] = Math . Min ( adj [ index , 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index , 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index , openbrk ] ; }
void gouldSequence ( int n ) { for ( int row_num = 1 ; row_num <= n ; row_num ++ ) { int count = 1 ; int c = 1 ; for ( int i = 1 ; i <= row_num ; i ++ ) { c = c * ( row_num - i ) / i ; if ( c % 2 == 1 ) count ++ ; } Console . Write ( count + " " ) ; } }
void gouldSequence ( ) { arr [ 0 ] = 1 ; int i = 1 ; int p = 1 ; while ( i <= MAX ) { int j = 0 ; while ( j < i ) { arr [ i + j ] = 2 * arr [ j ] ; j ++ ; } i = ( 1 << p ) ; p ++ ; } }
void printSequence ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
int minFallingPathSum ( int [ , ] A ) { for ( int R = n - 2 ; R >= 0 ; -- R ) { for ( int C = 0 ; C < n ; ++ C ) { int best = A [ R + 1 , C ] ; if ( C > 0 ) best = Math . Min ( best , A [ R + 1 , C - 1 ] ) ; if ( C + 1 < n ) best = Math . Min ( best , A [ R + 1 , C + 1 ] ) ; A [ R , C ] = A [ R , C ] + best ; } } int ans = int . MaxValue ; for ( int i = 0 ; i < n ; ++ i ) ans = Math . Min ( ans , A [ 0 , i ] ) ; return ans ; }
int maxPlus ( int [ , ] arr ) { int ans = int . MinValue ; int [ , ] left = new int [ N , N ] ; int [ , ] right = new int [ N , N ] ; int [ , ] up = new int [ N , N ] ; int [ , ] down = new int [ N , N ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { left [ i , j ] = Math . Max ( 0 , ( ( j != 0 ) ? left [ i , j - 1 ] : 0 ) ) + arr [ i , j ] ; up [ i , j ] = Math . Max ( 0 , ( ( i != 0 ) ? up [ i - 1 , j ] : 0 ) ) + arr [ i , j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { right [ i , j ] = Math . Max ( 0 , ( j + 1 == m ? 0 : right [ i , j + 1 ] ) ) + arr [ i , j ] ; down [ i , j ] = Math . Max ( 0 , ( i + 1 == n ? 0 : down [ i + 1 , j ] ) ) + arr [ i , j ] ; } } for ( int i = 1 ; i < n - 1 ; ++ i ) for ( int j = 1 ; j < m - 1 ; ++ j ) ans = Math . Max ( ans , up [ i - 1 , j ] + down [ i + 1 , j ] + left [ i , j - 1 ] + right [ i , j + 1 ] + arr [ i , j ] ) ; return ans ; }
long fun ( int [ ] marks , int n ) { long [ ] dp = new long [ n ] ; long temp ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; }
long getNumberOfWays ( long N , long [ ] Coins ) { long [ ] ways = new long [ ( int ) N + 1 ] ; ways [ 0 ] = 1 ; for ( int i = 0 ; i < Coins . Length ; i ++ ) { for ( int j = 0 ; j < ways . Length ; j ++ ) { if ( Coins [ i ] <= j ) { ways [ j ] += ways [ ( int ) ( j - Coins [ i ] ) ] ; } } } return ways [ ( int ) N ] ; }
int countStaircases ( int N ) { int [ , ] memo = new int [ N + 5 , N + 5 ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { memo [ i , j ] = 0 ; } } memo [ 3 , 2 ] = memo [ 4 , 2 ] = 1 ; for ( int i = 5 ; i <= N ; i ++ ) { for ( int j = 2 ; j <= i ; j ++ ) { if ( j == 2 ) { memo [ i , j ] = memo [ i - j , j ] + 1 ; } else { memo [ i , j ] = memo [ i - j , j ] + memo [ i - j , j - 1 ] ; } } } int answer = 0 ; for ( int i = 1 ; i <= N ; i ++ ) answer = answer + memo [ N , i ] ; return answer ; }
long partitions ( int n ) { long [ ] p = new long [ n + 1 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; }
int find ( int m , int n , int [ ] adj ) { int [ ] sweet = new int [ n + 1 ] ; int [ , , ] dp = new int [ n + 1 , n + 1 , n + 1 ] ; sweet [ 0 ] = 0 ; for ( int i = 1 ; i <= m ; ++ i ) sweet [ i ] = adj [ i - 1 ] ; for ( int i = 0 ; i <= m ; ++ i ) { for ( int k = 0 ; k <= n ; ++ k ) dp [ i , 0 , k ] = 0 ; for ( int k = 1 ; k <= n ; ++ k ) dp [ i , k , 0 ] = - 1 ; } for ( int i = 0 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { for ( int k = 1 ; k <= n ; ++ k ) { dp [ i , j , k ] = - 1 ; if ( i > 0 && j >= k && sweet [ k ] > 0 && dp [ i - 1 , j - k , k ] != - 1 ) dp [ i , j , k ] = dp [ i - 1 , j - k , k ] + sweet [ k ] ; if ( dp [ i , j , k ] == - 1 || ( dp [ i , j , k - 1 ] != - 1 && dp [ i , j , k ] > dp [ i , j , k - 1 ] ) ) dp [ i , j , k ] = dp [ i , j , k - 1 ] ; } } } if ( dp [ m , n , n ] == - 1 ) return 0 ; else return dp [ m , n , n ] ; }
int find_min_odd_cost ( int [ , ] given , int m , int n ) { int [ , ] floor = new int [ M , N ] ; int min_odd_cost = 0 ; int i , j , temp ; for ( j = 0 ; j < n ; j ++ ) floor [ 0 , j ] = given [ 0 , j ] ; for ( i = 1 ; i < m ; i ++ ) for ( j = 0 ; j < n ; j ++ ) { if ( j == 0 ) { floor [ i , j ] = given [ i , j ] ; floor [ i , j ] += Math . Min ( floor [ i - 1 , j ] , floor [ i - 1 , j + 1 ] ) ; } else if ( j == n - 1 ) { floor [ i , j ] = given [ i , j ] ; floor [ i , j ] += Math . Min ( floor [ i - 1 , j ] , floor [ i - 1 , j - 1 ] ) ; } else { temp = Math . Min ( floor [ i - 1 , j ] , floor [ i - 1 , j - 1 ] ) ; temp = Math . Min ( temp , floor [ i - 1 , j + 1 ] ) ; floor [ i , j ] = given [ i , j ] + temp ; } } min_odd_cost = int . MaxValue ; for ( j = 0 ; j < n ; j ++ ) { if ( floor [ n - 1 , j ] % 2 == 1 ) { if ( min_odd_cost > floor [ n - 1 , j ] ) min_odd_cost = floor [ n - 1 , j ] ; } } if ( min_odd_cost == int . MinValue ) return - 1 ; return min_odd_cost ; }
int countPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }
int countPaths ( int m , int n ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i , j ] = 1 ; else dp [ i , j ] = dp [ i - 1 , j ] + dp [ i , j - 1 ] ; } } return dp [ m , n ] ; }
int factorial ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
int countWays ( int m , int n ) { m = m - 1 ; n = n - 1 ; return factorial ( m + n ) / ( factorial ( m ) * factorial ( n ) ) ; }
int MatrixChainOrder ( int [ ] p , int n ) { int [ , ] dp = new int [ n , n ] ; for ( int i = 1 ; i < n ; i ++ ) dp [ i , i ] = 0 ; for ( int L = 1 ; L < n - 1 ; L ++ ) for ( int i = 1 ; i < n - L ; i ++ ) dp [ i , i + L ] = Math . Min ( dp [ i + 1 , i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i , i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 , n - 1 ] ; }
int createPalindrome ( int input , int isOdd ) { int n = input ; int palin = input ; if ( isOdd % 2 == 1 ) { n /= 10 ; } while ( n > 0 ) { palin = palin * 10 + ( n % 10 ) ; n /= 10 ; } return palin ; }
List < int > generatePalindromes ( int N ) { List < int > palindromes = new List < int > ( ) ; int number ; for ( int j = 0 ; j < 2 ; j ++ ) { int i = 1 ; while ( ( number = createPalindrome ( i ++ , j ) ) <= N ) { palindromes . Add ( number ) ; } } return palindromes ; }
int minimumNoOfPalindromes ( int N ) { String a = String . Join ( "" , N ) ; String b = String . Join ( "" , N ) ; b = reverse ( b ) ; if ( a . Equals ( b ) ) { return 1 ; } List < int > palindromes = generatePalindromes ( N ) ; palindromes . Sort ( ) ; int l = 0 , r = palindromes . Count - 1 ; while ( l < r ) { if ( palindromes [ l ] + palindromes [ r ] == N ) { return 2 ; } else if ( palindromes [ l ] + palindromes [ r ] < N ) { ++ l ; } else { -- r ; } } return 3 ; }
int costOfString ( String str ) { int cost = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) cost += ( str [ i ] - 48 ) ; return cost ; }
int lds ( int [ ] arr , int n ) { int [ ] lds = new int [ n ] ; lds [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { lds [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( lds [ j ] != 0 && arr [ i ] % arr [ j ] == 0 ) lds [ i ] = Math . Max ( lds [ i ] , lds [ j ] + 1 ) ; } int max = lds . Max ( ) ; return max ; }
int find ( int start , string adj , int n , int [ ] dp ) { if ( start == n ) return 0 ; if ( dp [ start ] != - 1 ) return dp [ start ] ; dp [ start ] = 0 ; int one = 0 , zero = 0 , k ; for ( k = start ; k < n ; k ++ ) { if ( adj [ k ] == '1' ) one ++ ; else zero ++ ; if ( one > zero ) dp [ start ] = Math . Max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) ; else dp [ start ] = Math . Max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) ; } return dp [ start ] ; }
int isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) return 1 ; return 0 ; }
int lcs ( String X , String Y , int m , int n ) { int [ , ] L = new int [ m + 1 , n + 1 ] ; int i , j ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i , j ] = 0 ; else if ( ( X [ i - 1 ] == Y [ j - 1 ] ) && isVowel ( X [ i - 1 ] ) == 1 ) L [ i , j ] = L [ i - 1 , j - 1 ] + 1 ; else L [ i , j ] = max ( L [ i - 1 , j ] , L [ i , j - 1 ] ) ; } } return L [ m , n ] ; }
long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
void makePairs ( List < int > pairs , int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { int sumOfDigits = 0 , k = i ; while ( k > 0 ) { sumOfDigits += k % 10 ; k /= 10 ; } if ( sumOfDigits <= 162 ) { pairs . Add ( sumOfDigits ) ; } } }
int countCoPrime ( int a , int b ) { List < int > pairs = new List < int > ( ) ; makePairs ( pairs , a , b ) ; int count = 0 ; for ( int i = 0 ; i < pairs . Count ; i ++ ) { for ( int j = i + 1 ; j < pairs . Count ; j ++ ) { if ( GCD ( pairs [ i ] , pairs [ j ] ) == 1 ) { count ++ ; } } } return count ; }
long recursive ( long idx , long sum , long tight , string st , long [ , , ] dp , long num ) { if ( idx == num ) { return sum == 0 ? 1 : 0 ; } if ( dp [ ( int ) idx , ( int ) tight , ( int ) sum ] != - 1 ) return dp [ ( int ) idx , ( int ) tight , ( int ) sum ] ; long newTight ; long ans = 0 ; long d ; for ( d = 0 ; d < 10 ; ++ d ) { newTight = 0 ; if ( tight == 1 && st [ ( ( int ) idx ) ] - '0' < d ) continue ; if ( tight == 1 && st [ ( ( int ) idx ) ] - '0' == d ) newTight = 1 ; if ( sum >= d ) ans += recursive ( idx + 1 , sum - d , ( int ) newTight , st , dp , num ) ; } return dp [ ( int ) idx , ( int ) tight , ( int ) sum ] = ans ; }
List < long > formArray ( long N ) { long [ , , ] dp = new long [ 20 , 2 , 166 ] ; for ( int i = 0 ; i < 20 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { for ( int k = 0 ; k < 166 ; k ++ ) { dp [ i , j , k ] = - 1 ; } } } string st = N . ToString ( ) ; long num = st . Length ; List < long > arr = new List < long > ( ) ; for ( int i = 1 ; i <= 162 ; ++ i ) { arr . Add ( recursive ( 0 , i , 1 , st , dp , num ) ) ; } return arr ; }
long findPair ( long a , long b ) { List < long > arr_smaller = formArray ( a - 1 ) ; List < long > arr_greater = formArray ( b ) ; for ( int i = 0 ; i < arr_greater . Count ; ++ i ) { arr_greater [ i ] = arr_greater [ i ] - arr_smaller [ i ] ; } long ans = 0 ; for ( int i = 1 ; i <= 162 ; ++ i ) { for ( int j = i + 1 ; j <= 162 ; ++ j ) { if ( gcd ( i , j ) == 1 ) { ans = ( ans + arr_greater [ i - 1 ] * arr_greater [ j - 1 ] ) ; } } } return ans ; }
int printTetraRec ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return 1 ; if ( n == 3 ) return 2 ; else return printTetraRec ( n - 1 ) + printTetraRec ( n - 2 ) + printTetraRec ( n - 3 ) + printTetraRec ( n - 4 ) ; }
void printTetra ( int n ) { int [ ] dp = new int [ n + 5 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; System . Console . WriteLine ( dp [ n ] ) ; }
void printTetra ( int n ) { if ( n < 0 ) return ; int first = 0 , second = 1 ; int third = 1 , fourth = 2 ; int curr = 0 ; if ( n == 0 ) Console . Write ( first ) ; else if ( n == 1 n == 2 ) Console . Write ( second ) ; else if ( n == 3 ) Console . Write ( fourth ) ; else { for ( int i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } Console . Write ( curr ) ; } }
bool check ( int n ) { List < int > v = new List < int > ( ) ; v = factors ( n ) ; v . Sort ( ) ; int r = v . Count ; bool [ , ] subset = new bool [ r + 1 , n + 1 ] ; for ( int i = 0 ; i <= r ; i ++ ) subset [ i , 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) subset [ 0 , i ] = false ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j < v [ i - 1 ] ) subset [ i , j ] = subset [ i - 1 , j ] ; else { subset [ i , j ] = subset [ i - 1 , j ] || subset [ i - 1 , ( j - v [ i - 1 ] ) ] ; } } } if ( ( subset [ r , n ] ) == false ) return false ; else return true ; }
int maxSum1 ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; int maxi = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( int i = 2 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < dp [ j ] + arr [ i ] ) { dp [ i ] = dp [ j ] + arr [ i ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; }
int maxSum2 ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; int maxi = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( int i = 3 ; i < n ; i ++ ) { for ( int j = 1 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < arr [ i ] + dp [ j ] ) { dp [ i ] = arr [ i ] + dp [ j ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; }
int findMaxSum ( int [ ] arr , int n ) { int t = Math . Max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) ) ; return t ; }
int solve ( int N , int K ) { int [ ] combo ; combo = new int [ 50 ] ; combo [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { if ( j >= i ) { combo [ j ] += combo [ j - i ] ; } } } return combo [ N ] ; }
void fibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i < 43 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; }
int rec ( int x , int y , int last ) { if ( y == 0 ) { if ( x == 0 ) return 1 ; return 0 ; } int sum = 0 ; for ( int i = last ; i >= 0 && fib [ i ] * y >= x ; i -- ) { if ( fib [ i ] > x ) continue ; sum += rec ( x - fib [ i ] , y - 1 , i ) ; } return sum ; }
double MinimumPrimes ( int n ) { double [ ] dp ; dp = new double [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] = 1e9 ; dp [ 0 ] = dp [ 2 ] = dp [ 3 ] = dp [ 5 ] = dp [ 7 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( check ( i , 2 ) ) dp [ i ] = Math . Min ( dp [ i ] , 1 + dp [ i - 2 ] ) ; if ( check ( i , 3 ) ) dp [ i ] = Math . Min ( dp [ i ] , 1 + dp [ i - 3 ] ) ; if ( check ( i , 5 ) ) dp [ i ] = Math . Min ( dp [ i ] , 1 + dp [ i - 5 ] ) ; if ( check ( i , 7 ) ) dp [ i ] = Math . Min ( dp [ i ] , 1 + dp [ i - 7 ] ) ; } if ( dp [ n ] == ( 1e9 ) ) return - 1 ; else return dp [ n ] ; }
int minimumCost ( int [ ] cost , int n ) { int [ ] dp = new int [ n ] ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( int i = 2 ; i < n ; i ++ ) { dp [ i ] = Math . Min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return Math . Min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; }
int minimumCost ( int [ ] cost , int n ) { int dp1 = 0 , dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + Math . Min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . Min ( dp1 , dp2 ) ; }
void subsetSum ( int [ ] arr , int n , int maxSum ) { bool [ ] dp = new bool [ maxSum + 1 ] ; Array . Fill ( dp , false ) ; dp [ arr [ 0 ] ] = true ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = maxSum ; j >= 1 ; j -- ) { if ( arr [ i ] <= j ) { if ( arr [ i ] == j || dp [ j ] || dp [ ( j - arr [ i ] ) ] ) dp [ j ] = true ; else dp [ j ] = false ; } } } Console . Write ( 0 + " " ) ; for ( int j = 0 ; j < maxSum + 1 ; j ++ ) { if ( dp [ j ] == true ) Console . Write ( j + " " ) ; } Console . Write ( "21" ) ; }
void printDistinct ( int [ ] a , int n ) { int maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxSum += a [ i ] ; } subsetSum ( a , n , maxSum ) ; }
int maxCost ( int [ , ] a , int m , int n , int [ , ] dp ) { if ( n < 0 m < 0 ) return ( int ) - 1e9 ; else if ( m == 0 && n == 0 ) return 0 ; else if ( dp [ m , n ] != - 1 ) return dp [ m , n ] ; else { int num = m + n ; if ( ( num & ( num - 1 ) ) == 0 ) return dp [ m , n ] = a [ m , n ] + maxCost ( a , m - 1 , n - 1 , dp ) ; else return dp [ m , n ] = ( a [ m , n ] + Math . Max ( maxCost ( a , m - 1 , n , dp ) , maxCost ( a , m , n - 1 , dp ) ) ) ; } }
int answer ( int [ , ] a , int n ) { int [ , ] dp = new int [ size , size ] ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) { dp [ i , j ] = - 1 ; } } return maxCost ( a , n - 1 , n - 1 , dp ) ; }
int editDistanceWith2Ops ( String X , String Y ) { int m = X . Length , n = Y . Length ; int [ , ] L = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) { L [ i , j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { L [ i , j ] = L [ i - 1 , j - 1 ] + 1 ; } else { L [ i , j ] = Math . Max ( L [ i - 1 , j ] , L [ i , j - 1 ] ) ; } } } int lcs = L [ m , n ] ; return ( m - lcs ) + ( n - lcs ) ; }
int lcs ( String X , String Y , int m , int n ) { if ( m == 0 n == 0 ) { return 0 ; } if ( X [ m - 1 ] == Y [ n - 1 ] ) { return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; } else { return Math . Max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } }
int lcs ( String X , String Y , int m , int n , int [ , ] dp ) { if ( m == 0 n == 0 ) { return 0 ; } if ( dp [ m - 1 , n - 1 ] != - 1 ) { return dp [ m - 1 , n - 1 ] ; } if ( X [ m - 1 ] == Y [ n - 1 ] ) { dp [ m - 1 , n - 1 ] = 1 + lcs ( X , Y , m - 1 , n - 1 , dp ) ; return dp [ m - 1 , n - 1 ] ; } else { dp [ m - 1 , n - 1 ] = Math . Max ( lcs ( X , Y , m , n - 1 , dp ) , lcs ( X , Y , m - 1 , n , dp ) ) ; return dp [ m - 1 , n - 1 ] ; } }
int countPaths ( int n ) { int zB = 1 ; int zADC = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int nzB = zADC * 3 ; int nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }
int sumSubSequence ( int [ ] arr , int len , int m ) { int sum = 0 ; foreach ( int x in arr ) { sum += x ; } int [ , ] dp = new int [ len + 1 , sum + 1 ] ; for ( int i = 0 ; i <= len ; i ++ ) dp [ i , 0 ] ++ ; for ( int i = 1 ; i <= len ; i ++ ) { dp [ i , arr [ i - 1 ] ] ++ ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 , j ] > 0 ) { dp [ i , j ] ++ ; dp [ i , j + arr [ i - 1 ] ] ++ ; } } } int count = 0 ; for ( int j = 1 ; j <= sum ; j ++ ) if ( dp [ len , j ] > 0 ) if ( j % m == 0 ) count += dp [ len , j ] ; return count ; }
int totalWays ( int N , int M , int X ) { int [ , ] dp = new int [ N + 1 , 2 ] ; if ( X == 1 ) { dp [ 0 , 0 ] = 1 ; } else { dp [ 0 , 1 ] = 0 ; } if ( X == 1 ) { dp [ 1 , 0 ] = 0 ; dp [ 1 , 1 ] = M - 1 ; } else { dp [ 1 , 0 ] = 1 ; dp [ 1 , 1 ] = ( M - 2 ) ; } for ( int i = 2 ; i < N ; i ++ ) { dp [ i , 0 ] = dp [ i - 1 , 1 ] ; dp [ i , 1 ] = dp [ i - 1 , 0 ] * ( M - 1 ) + dp [ i - 1 , 1 ] * ( M - 2 ) ; } return dp [ N - 1 , 0 ] ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
int fib ( int n ) { int [ ] term = new int [ 1000 ] ; if ( n <= 1 ) return n ; if ( term [ n ] != 0 ) return term [ n ] ; else { term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; return term [ n ] ; } }
int lcs ( string X , string Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }
int lcs ( String X , String Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( arr [ m - 1 , n - 1 ] != - 1 ) return arr [ m - 1 , n - 1 ] ; if ( X [ m - 1 ] == Y [ n - 1 ] ) { arr [ m - 1 , n - 1 ] = 1 + lcs ( X , Y , m - 1 , n - 1 ) ; return arr [ m - 1 , n - 1 ] ; } else { arr [ m - 1 , n - 1 ] = max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; return arr [ m - 1 , n - 1 ] ; } }
int lcs ( String X , String Y , String Z , int m , int n , int o ) { if ( m == 0 n == 0 o == 0 ) return 0 ; if ( arr [ m - 1 , n - 1 , o - 1 ] != - 1 ) return arr [ m - 1 , n - 1 , o - 1 ] ; if ( X [ m - 1 ] == Y [ n - 1 ] && Y [ n - 1 ] == Z [ o - 1 ] ) { arr [ m - 1 , n - 1 , o - 1 ] = 1 + lcs ( X , Y , Z , m - 1 , n - 1 , o - 1 ) ; return arr [ m - 1 , n - 1 , o - 1 ] ; } else { arr [ m - 1 , n - 1 , o - 1 ] = max ( lcs ( X , Y , Z , m , n - 1 , o ) , max ( lcs ( X , Y , Z , m - 1 , n , o ) , lcs ( X , Y , Z , m , n , o - 1 ) ) ) ; return arr [ m - 1 , n - 1 , o - 1 ] ; } }
int minStepsNeeded ( int k , int d1 , int d2 , int x ) { int gcd = __gcd ( d1 , d2 ) ; if ( ( k - x ) % gcd != 0 ) return - 1 ; Queue < pair > q = new Queue < pair > ( ) ; HashSet < int > visited = new HashSet < int > ( ) ; q . Enqueue ( new pair ( k , 0 ) ) ; visited . Add ( k ) ; while ( q . Count != 0 ) { int s = q . Peek ( ) . first ; int stp = q . Peek ( ) . second ; if ( s == x ) return stp ; q . Dequeue ( ) ; if ( ! visited . Contains ( s + d1 ) ) { q . Enqueue ( new pair ( s + d1 , stp + 1 ) ) ; visited . Add ( s + d1 ) ; } if ( ! visited . Contains ( s + d2 ) ) { q . Enqueue ( new pair ( s + d2 , stp + 1 ) ) ; visited . Add ( s + d2 ) ; } if ( ! visited . Contains ( s - d1 ) ) { q . Enqueue ( new pair ( s - d1 , stp + 1 ) ) ; visited . Add ( s - d1 ) ; } if ( ! visited . Contains ( s - d2 ) ) { q . Enqueue ( new pair ( s - d2 , stp + 1 ) ) ; visited . Add ( s - d2 ) ; } } return int . MinValue ; }
int lds ( int [ ] arr , int n ) { int [ ] lds = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; }
int minimumNumberOfDigits ( int a , int b ) { if ( a > b a < 0 < 0 > 900 > 8100 ) { return - 1 ; } if ( a == 0 && b == 0 ) { return 0 ; } if ( dp [ a , b ] != - 1 ) { return dp [ a , b ] ; } int ans = 101 ; for ( int i = 9 ; i >= 1 ; i -- ) { int k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) ; if ( k != - 1 ) { ans = Math . Min ( ans , k + 1 ) ; } } return dp [ a , b ] = ans ; }
void printSmallestNumber ( int a , int b ) { for ( int i = 0 ; i < dp . GetLength ( 0 ) ; i ++ ) for ( int j = 0 ; j < dp . GetLength ( 1 ) ; j ++ ) dp [ i , j ] = - 1 ; dp [ 0 , 0 ] = 0 ; int k = minimumNumberOfDigits ( a , b ) ; if ( k == - 1 k > 100 ) { Console . WriteLine ( "-1" ) ; } else { while ( a > 0 && b > 0 ) { for ( int i = 1 ; i <= 9 ; i ++ ) { if ( a >= i && b >= i * i && 1 + dp [ a - i , b - i * i ] == dp [ a , b ] ) { Console . Write ( i ) ; a -= i ; b -= i * i ; break ; } } } } }
void binomialCoeff ( int [ ] C , int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } }
int sumOfproduct ( int n ) { int sum = 0 ; int [ ] C = new int [ MAX ] ; binomialCoeff ( C , n ) ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ i ] * C [ i + 1 ] ; return sum ; }
int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int sumOfproduct ( int n ) { return binomialCoeff ( 2 * n , n - 1 ) ; }
int check ( int i , int sum , int n , int k , int [ ] a , int [ , ] dp ) { if ( sum <= 0 ) { return 0 ; } if ( i >= n ) { if ( sum == k ) { return 1 ; } return 0 ; } if ( dp [ i , sum ] != - 1 ) { return dp [ i , sum ] ; } dp [ i , sum ] = check ( i + 1 , sum - 2 * a [ i ] , n , k , a , dp ) | check ( i + 1 , sum , n , k , a , dp ) ; dp [ i , sum ] = check ( i + 1 , sum - ( i + 1 ) , n , k , a , dp ) | dp [ i , sum ] ; dp [ i , sum ] = check ( i + 1 , sum + i + 1 , n , k , a , dp ) | dp [ i , sum ] ; return dp [ i , sum ] ; }
int wrapper ( int n , int k , int [ ] a ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int [ , ] dp = new int [ MAX , MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i , j ] = - 1 ; } } return check ( 0 , sum , n , k , a , dp ) ; }
bool isPowerOf ( long val , int b ) { while ( val > 1 ) { if ( val % b != 0 ) val /= b ; } return true ; }
int numberOfPartitions ( string binaryNo ) { int i , j , n = binaryNo . Length ; long val ; int [ ] dp = new int [ n ] ; dp [ n - 1 ] = ( ( ( binaryNo [ n - 1 ] - '0' ) == 0 ) ? - 1 : 1 ) ; for ( i = n - 2 ; i >= 0 ; i -- ) { val = 0 ; if ( ( binaryNo [ i ] - '0' ) == 0 ) { dp [ i ] = - 1 ; continue ; } dp [ i ] = int . MaxValue ; for ( j = i ; j < n ; j ++ ) { val = ( val * 2 ) + ( long ) ( binaryNo [ j ] - '0' ) ; if ( isPowerOf ( val , 4 ) || isPowerOf ( val , 6 ) ) { if ( j == n - 1 ) { dp [ i ] = 1 ; } else { if ( dp [ j + 1 ] != - 1 ) dp [ i ] = Math . Min ( dp [ i ] , dp [ j + 1 ] + 1 ) ; } } } if ( dp [ i ] == int . MaxValue ) dp [ i ] = - 1 ; } return dp [ 0 ] ; }
void binomialCoeff ( int n , int [ ] C ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } }
int summation ( int n ) { int [ ] C = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) C [ i ] = 0 ; binomialCoeff ( n , C ) ; int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += ( i * C [ i ] ) ; return sum ; }
int summation ( int n ) { return n << ( n - 1 ) ; }
int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int countArray ( int N , int K ) { return binomialCoeff ( K - 1 , N - 1 ) ; }
int count ( int n , int c , int [ ] a , int [ ] b ) { int [ ] need = new int [ N ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i + n ] = a [ i ] ; b [ i + n ] = b [ i ] ; } int s = 0 ; int tank = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { tank += a [ i ] ; tank = Math . Min ( tank , c ) ; tank -= b [ i ] ; if ( tank < 0 ) { tank = 0 ; s = i + 1 ; } } if ( s >= n ) return 0 ; int ans = 1 ; need [ s + n ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int id = s + n - i ; need [ id ] = Math . Max ( 0 , need [ id + 1 ] + b [ id ] - Math . Min ( a [ id ] , c ) ) ; if ( need [ id ] == 0 ) ans ++ ; } return ans ; }
void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) Console . Write ( a + " " ) ; if ( n >= 1 ) Console . Write ( b + " " ) ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; Console . Write ( c + " " ) ; a = b ; b = c ; } }
int countDigits ( int n ) { int count = 0 ; while ( n > 0 ) { count += 1 ; n /= 10 ; } return count ; }
int findCount ( int L , int R ) { int count = 0 ; int countDigitsL = countDigits ( L ) ; int countDigitsR = countDigits ( R ) ; int firstDigitL = ( L / ( int ) Math . Pow ( 10 , countDigitsL - 1 ) ) ; int firstDigitR = ( R / ( int ) Math . Pow ( 10 , countDigitsR - 1 ) ) ; if ( countDigitsL < countDigitsR ) { count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) ; if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count += firstDigitR ; else count += ( firstDigitR - 1 ) ; } else { if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count -= ( 9 - firstDigitR ) ; else count -= ( 9 - firstDigitR + 1 ) ; } return count ; }
double score ( int n , List < int > A , int k ) { if ( memo [ n , k ] > 0 ) return memo [ n , k ] ; double sum = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { sum += A [ i ] ; memo [ n , k ] = Math . Max ( memo [ n , k ] , score ( i , A , k - 1 ) + sum / ( n - i ) ) ; } return memo [ n , k ] ; }
int pre_compute ( int [ ] a , int n , int index , int k ) { int [ , ] dp = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 , i ] = a [ i ] + a [ 0 ] ; else dp [ 0 , i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 , i ] + a [ j ] > dp [ i - 1 , j ] ) dp [ i , j ] = dp [ i - 1 , i ] + a [ j ] ; else dp [ i , j ] = dp [ i - 1 , j ] ; } else dp [ i , j ] = dp [ i - 1 , j ] ; } } return dp [ index , k ] ; }
int gen ( int n ) { int [ ] S = new int [ n + 1 ] ; S [ 0 ] = 0 ; if ( n != 0 ) S [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) S [ i ] = 4 * S [ i / 2 ] ; else S [ i ] = 4 * S [ i / 2 ] + 1 ; } return S [ n ] ; }
void moserDeBruijn ( int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( gen ( i ) + " " ) ; }
int LCSubStr ( string X , string Y ) { int m = X . Length ; int n = Y . Length ; int result = 0 ; int [ , ] len = new int [ 2 , n ] ; int currRow = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 j == 0 ) { len [ currRow , j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { len [ currRow , j ] = len [ ( 1 - currRow ) , ( j - 1 ) ] + 1 ; result = Math . Max ( result , len [ currRow , j ] ) ; } else { len [ currRow , j ] = 0 ; } } currRow = 1 - currRow ; } return result ; }
bool isPartitionPoss ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; List < int > set1 = new List < int > ( ) ; List < int > set2 = new List < int > ( ) ; return findSets ( arr , n , ref set1 , ref set2 , 0 , 0 , 0 ) ; }
void func ( int n , int m , int [ ] A ) { List < int > ModArray = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ModArray . Add ( 0 ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ModArray [ i ] = ( A [ i ] % m ) ; sum += ( ( int ) ModArray [ i ] ) ; } sum = sum % m ; if ( sum % m == 0 ) { Console . WriteLine ( "True" ) ; return ; } if ( sum % 2 != 0 ) { Console . WriteLine ( "False" ) ; } else { ModArray . Remove ( 0 ) ; int i = 0 ; int j = ModArray . Count - 1 ; ModArray . Sort ( ) ; sum = sum / 2 ; int i1 , i2 ; while ( i <= j ) { int s = ( int ) ModArray [ i ] + ( int ) ModArray [ j ] ; if ( s == sum ) { i1 = i ; i2 = j ; Console . WriteLine ( "True" ) ; break ; } else if ( s > sum ) j -- ; else i ++ ; } } }
void dfs1 ( List < List < int > > v , int u , int parent ) { In [ u ] = 0 ; for ( int j = 0 ; j < v [ u ] . Count ; j ++ ) { int child = v [ u ] [ j ] ; if ( child == parent ) continue ; dfs1 ( v , child , u ) ; In [ u ] = Math . Max ( In [ u ] , 1 + In [ child ] ) ; } }
void dfs2 ( List < List < int > > v , int u , int parent ) { int mx1 = - 1 , mx2 = - 1 ; for ( int j = 0 ; j < v [ u ] . Count ; j ++ ) { int child = v [ u ] [ j ] ; if ( child == parent ) continue ; if ( In [ child ] >= mx1 ) { mx2 = mx1 ; mx1 = In [ child ] ; } else if ( In [ child ] > mx2 ) mx2 = In [ child ] ; } for ( int j = 0 ; j < v [ u ] . Count ; j ++ ) { int child = v [ u ] [ j ] ; if ( child == parent ) continue ; int longest = mx1 ; if ( mx1 == In [ child ] ) longest = mx2 ; Out [ child ] = 1 + Math . Max ( Out [ u ] , 1 + longest ) ; dfs2 ( v , child , u ) ; } }
void printGolomb ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( findGolomb ( i ) + " " ) ; }
void dfs ( int [ ] a , List < int > [ ] v , int u , int parent ) { dp [ u ] = a [ u - 1 ] ; int maximum = 0 ; foreach ( int child in v [ u ] ) { if ( child == parent ) continue ; dfs ( a , v , child , u ) ; maximum = Math . Max ( maximum , dp [ child ] ) ; } dp [ u ] += maximum ; }
int maximumValue ( int [ ] a , List < int > [ ] v ) { dfs ( a , v , 1 , 0 ) ; return dp [ 1 ] ; }
int countRemovals ( int [ ] a , int i , int j , int k ) { if ( i >= j ) return 0 ; else if ( ( a [ j ] - a [ i ] ) <= k ) return 0 ; else if ( dp [ i , j ] != - 1 ) return dp [ i , j ] ; else if ( ( a [ j ] - a [ i ] ) > k ) { dp [ i , j ] = 1 + Math . Min ( countRemovals ( a , i + 1 , j , k ) , countRemovals ( a , i , j - 1 , k ) ) ; } return dp [ i , j ] ; }
int removals ( int [ ] a , int n , int k ) { Array . Sort ( a ) ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) dp [ i , j ] = - 1 ; } if ( n == 1 ) return 0 ; else return countRemovals ( a , 0 , n - 1 , k ) ; }
int removals ( int [ ] arr , int n , int k ) { int i , j , ans = n - 1 ; Array . Sort ( arr ) ; for ( i = 0 ; i < n ; i ++ ) { j = findInd ( arr [ i ] , i , n , k , arr ) ; if ( j != - 1 ) { ans = Math . Min ( ans , n - ( j - i + 1 ) ) ; } } return ans ; }
int removals ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = - 1 ; int ans = n - 1 ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = i ; int j = dp [ i - 1 ] ; while ( j != i && arr [ i ] - arr [ j ] > k ) { j ++ ; } dp [ i ] = Math . Min ( dp [ i ] , j ) ; ans = Math . Min ( ans , ( n - ( i - j + 1 ) ) ) ; } return ans ; }
int maximumSegments ( int n , int a , int b , int c ) { int [ ] dp = new int [ n + 10 ] ; for ( int i = 0 ; i < n + 10 ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { dp [ i + a ] = Math . Max ( dp [ i ] + 1 , dp [ i + a ] ) ; dp [ i + b ] = Math . Max ( dp [ i ] + 1 , dp [ i + b ] ) ; dp [ i + c ] = Math . Max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
void postfix ( int [ ] a , int n ) { for ( int i = n - 1 ; i > 0 ; i -- ) { a [ i - 1 ] = a [ i - 1 ] + a [ i ] ; } }
void modify ( int [ ] a , int n ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i - 1 ] = i * a [ i ] ; } }
void sequence ( int n ) { int [ ] f = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; Console . Write ( f [ 1 ] + " " + f [ 2 ] + " " ) ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; Console . Write ( f [ i ] + " " ) ; } }
long sum ( int [ ] a , int i , int j ) { long ans = 0 ; for ( int m = i ; m <= j ; m ++ ) ans = ( ans + a [ m ] ) % 100 ; return ans ; }
long solve ( int [ ] a , int i , int j ) { if ( i == j ) return 0 ; if ( dp [ i , j ] != - 1 ) return dp [ i , j ] ; dp [ i , j ] = 100000000 ; for ( int k = i ; k < j ; k ++ ) { dp [ i , j ] = Math . Min ( dp [ i , j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) ; } return dp [ i , j ] ; }
void initialize ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i , j ] = - 1 ; }
void reverseFibonacci ( int n ) { int [ ] a = new int [ n ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { Console . Write ( a [ i ] + " " ) ; } }
int longestSubsequenceCommonSegment ( int k , string s1 , string s2 ) { int n = s1 . Length ; int m = s2 . Length ; int [ , ] lcs = new int [ n + 1 , m + 1 ] ; int [ , ] cnt = new int [ n + 1 , m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { lcs [ i , j ] = Math . Max ( lcs [ i - 1 , j ] , lcs [ i , j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i , j ] = cnt [ i - 1 , j - 1 ] + 1 ; if ( cnt [ i , j ] >= k ) { for ( int a = k ; a <= cnt [ i , j ] ; a ++ ) lcs [ i , j ] = Math . Max ( lcs [ i , j ] , lcs [ i - a , j - a ] + a ) ; } } } return lcs [ n , m ] ; }
long arrangeBraces ( int n , int [ ] pos , int k ) { bool [ ] h = new bool [ N ] ; int [ , ] dp = new int [ N , N ] ; for ( int i = 0 ; i < N ; i ++ ) h [ i ] = false ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) dp [ i , j ] = 0 ; for ( int i = 0 ; i < k ; i ++ ) h [ pos [ i ] ] = true ; dp [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { for ( int j = 0 ; j <= 2 * n ; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) dp [ i , j ] = dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = 0 ; } else { if ( j != 0 ) dp [ i , j ] = dp [ i - 1 , j - 1 ] + dp [ i - 1 , j + 1 ] ; else dp [ i , j ] = dp [ i - 1 , j + 1 ] ; } } } return dp [ 2 * n , 0 ] ; }
bool check ( string s1 , string s2 ) { int n = s1 . Length ; int m = s2 . Length ; bool [ , ] dp = new bool [ n + 1 , m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i , j ] = false ; } } dp [ 0 , 0 ] = true ; for ( int i = 0 ; i < s1 . Length ; i ++ ) { for ( int j = 0 ; j <= s2 . Length ; j ++ ) { if ( dp [ i , j ] ) { if ( j < s2 . Length && ( Char . ToUpper ( s1 [ i ] ) == s2 [ j ] ) ) dp [ i + 1 , j + 1 ] = true ; if ( ! Char . IsUpper ( s1 [ i ] ) ) dp [ i + 1 , j ] = true ; } } } return ( dp [ n , m ] ) ; }
int findLength ( string str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == '0' ? 1 : - 1 ) ; if ( current_sum < 0 ) { current_sum = 0 ; } max_sum = Math . Max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }
float find_prob ( int N , float P ) { double [ ] dp = new double [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( ( float ) ( dp [ N ] ) ) ; }
int maxSubArraySumRepeated ( int [ ] a , int n , int k ) { int max_so_far = 0 ; int max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int chordCnt ( int A ) { int n = 2 * A ; int [ ] dpArray = new int [ n + 1 ] ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i += 2 ) { for ( int j = 0 ; j < i - 1 ; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } } return dpArray [ n ] ; }
int maximumSumSubarray ( int [ ] arr , int n ) { int min_prefix_sum = 0 ; int res = int . MinValue ; int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = Math . Max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . Min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }
bool isPath ( int [ , ] arr ) { int [ , ] dir = { { 0 , 1 } , { 0 , - 1 } , { 1 , 0 } , { - 1 , 0 } } ; Queue q = new Queue ( ) ; q . Enqueue ( new Tuple < int , int > ( 0 , 0 ) ) ; while ( q . Count > 0 ) { Tuple < int , int > p = ( Tuple < int , int > ) ( q . Peek ( ) ) ; q . Dequeue ( ) ; arr [ p . Item1 , p . Item2 ] = - 1 ; if ( p == new Tuple < int , int > ( row - 1 , col - 1 ) ) return true ; for ( int i = 0 ; i < 4 ; i ++ ) { int a = p . Item1 + dir [ i , 0 ] ; int b = p . Item2 + dir [ i , 1 ] ; if ( a >= 0 && b >= 0 && a < row && b < col && arr [ a , b ] != - 1 ) { q . Enqueue ( new Tuple < int , int > ( a , b ) ) ; } } } return false ; }
bool isPath ( int [ , ] arr ) { arr [ 0 , 0 ] = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) if ( arr [ i , 0 ] != - 1 ) arr [ i , 0 ] = arr [ i - 1 , 0 ] ; for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ 0 , j ] != - 1 ) arr [ 0 , j ] = arr [ 0 , j - 1 ] ; for ( int i = 1 ; i < 5 ; i ++ ) for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ i , j ] != - 1 ) arr [ i , j ] = Math . Max ( arr [ i , j - 1 ] , arr [ i - 1 , j ] ) ; return ( arr [ 5 - 1 , 5 - 1 ] == 1 ) ; }
int Jacobsthal ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; }
int Jacobsthal_Lucas ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 2 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; }
int findStep ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }
int countWays ( int n ) { int [ ] res = new int [ n + 2 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }
int countWays ( int n ) { int a = 1 , b = 2 , c = 4 ; int d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( int i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; }
int sequence ( int n ) { if ( n == 1 n == 2 ) return 1 ; else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; }
int sequence ( int n ) { int [ ] f = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; int i ; for ( i = 3 ; i <= n ; i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; return f [ n ] ; }
int choose ( int n , int k ) { if ( k > n ) return 0 ; if ( n <= 1 ) return 1 ; if ( k == 0 ) return 1 ; if ( nck [ n , k ] != - 1 ) return nck [ n , k ] ; int answer = choose ( n - 1 , k - 1 ) + choose ( n - 1 , k ) ; nck [ n , k ] = answer ; return answer ; }
int getLeft ( int n ) { if ( n == 1 ) return 0 ; int h = log2 [ n ] ; int last = n - ( ( 1 << h ) - 1 ) ; if ( last >= ( numh / 2 ) ) else return ( 1 << h )  - 1 - ( ( numh / 2 ) - last )  ; }
int numberOfHeaps ( int n ) { if ( n <= 1 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; int left = getLeft ( n ) ; int ans = ( choose ( n - 1 , left ) * numberOfHeaps ( left ) ) * ( numberOfHeaps ( n - 1 - left ) ) ; dp [ n ] = ans ; return ans ; }
int Hosoya ( int n , int m ) { if ( ( n == 0 && m == 0 ) || ( n == 1 && m == 0 ) || ( n == 1 && m == 1 ) || ( n == 2 && m == 1 ) ) return 1 ; if ( n > m ) return Hosoya ( n - 1 , m ) + Hosoya ( n - 2 , m ) ; else if ( m == n ) return Hosoya ( n - 1 , m - 1 ) + Hosoya ( n - 2 , m - 2 ) ; else return 0 ; }
int numberofways ( int n , int m ) { int [ , ] dp = new int [ n + 2 , n + 2 ] ; dp [ 0 , n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i , k ] = dp [ i , k + 1 ] ; if ( i - k >= 0 ) dp [ i , k ] = ( dp [ i , k ] + dp [ i - k , k ] ) ; } } return dp [ n , m ] ; }
int zigzag ( int n , int k ) { int [ , ] dp = new int [ n + 1 , k + 1 ] ; dp [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i , 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= Math . Min ( i , k ) ; j ++ ) dp [ i , j ] = dp [ i , j - 1 ] + dp [ i - 1 , i - j ] ; } return dp [ n , k ] ; }
int eulerian ( int n , int m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
int eulerian ( int n , int m ) { int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i , j ] = 1 ; else dp [ i , j ] = ( ( i - j ) * dp [ i - 1 , j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 , j ] ) ; } } } return dp [ n , m ] ; }
int nswp ( int n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
int binomialCoeff ( int n , int k ) { int [ , ] C = new int [ n + 1 , k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } return C [ n , k ] ; }
int longOddEvenIncSeq ( int [ ] arr , int n ) { int [ ] lioes = new int [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }
int dealnnoy ( int n , int m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }
int dealnnoy ( int n , int m ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i , 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) dp [ 0 , i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i , j ] = dp [ i - 1 , j ] + dp [ i - 1 , j - 1 ] + dp [ i , j - 1 ] ; return dp [ m , n ] ; }
void longestAlternating ( int [ ] arr , int n ) { int [ ] count = new int [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( count [ i ] + " " ) ; }
int maxDP ( int n ) { int [ ] res = new int [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = Math . Max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; }
int findlength ( int [ ] arr , string s , int n , int ind , int st , int [ , ] dp ) { if ( ind >= n ) return 0 ; if ( dp [ ind , st ] != - 1 ) return dp [ ind , st ] ; if ( st == 0 ) return dp [ ind , st ] = Math . Max ( arr [ ind ] + findlength ( arr , s , n , ind + 1 , 1 , dp ) , findlength ( arr , s , n , ind + 1 , 0 , dp ) ) ; else return dp [ ind , st ] = Math . Max ( arr [ ind ] + findlength ( arr , s , n , ind + 1 , 1 , dp ) , 0 ) ; }
int maxLen ( string s , int n ) { if ( allones ( s , n ) ) return - 1 ; int [ ] arr = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = ( s [ i ] == '0' ? 1 : - 1 ) ; int [ , ] dp = new int [ MAX , 3 ] ; for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) dp [ i , j ] = - 1 ; return findlength ( arr , s , n , 0 , 0 , dp ) ; }
int countarray ( int n , int k , int x ) { int [ ] dp = new int [ 109 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
int countPalindromes ( int k , int n , int [ , ] l , int [ , ] r ) { int ans = 0 ; if ( k == 1 ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) ans += l [ i , n - 1 ] ; return ans ; } if ( k == 2 ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) ans += ( ( l [ i , n - 1 ] * ( l [ i , n - 1 ] - 1 ) ) / 2 ) ; return ans ; } for ( int i = 1 ; i < n - 1 ; i ++ ) for ( int j = 0 ; j < MAX_CHAR ; j ++ ) ans += l [ j , i - 1 ] * r [ j , i + 1 ] ; return ans ; }
int lcs ( string X , string Y , int m , int n ) { int [ , ] L = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; ++ i ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i , j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i , j ] = L [ i - 1 , j - 1 ] + 2 * ( X [ i - 1 ] - '0' ) ; else L [ i , j ] = L [ i - 1 , j ] > L [ i , j - 1 ] ? L [ i - 1 , j ] : L [ i , j - 1 ] ; } } return L [ m , n ] ; }
int findMinCost ( string X , string Y ) { int m = X . Length , n = Y . Length ; int cost = 0 ; for ( int i = 0 ; i < m ; ++ i ) cost += X [ i ] - '0' ; for ( int i = 0 ; i < n ; ++ i ) cost += Y [ i ] - '0' ; return cost - lcs ( X , Y , m , n ) ; }
int isSubsetSum ( int [ ] set , int n , int sum ) { bool [ , ] subset = new bool [ sum + 1 , n + 1 ] ; int [ , ] count = new int [ sum + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { subset [ 0 , i ] = true ; count [ 0 , i ] = 0 ; } for ( int i = 1 ; i <= sum ; i ++ ) { subset [ i , 0 ] = false ; count [ i , 0 ] = - 1 ; } for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i , j ] = subset [ i , j - 1 ] ; count [ i , j ] = count [ i , j - 1 ] ; if ( i >= set [ j - 1 ] ) { subset [ i , j ] = subset [ i , j ] || subset [ i - set [ j - 1 ] , j - 1 ] ; if ( subset [ i , j ] ) count [ i , j ] = Math . Max ( count [ i , j - 1 ] , count [ i - set [ j - 1 ] , j - 1 ] + 1 ) ; } } } return count [ sum , n ] ; }
long answer ( int n ) { int [ , ] dp = new int [ n + 1 , 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 , j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i , j ] = dp [ i - 1 , j + 1 ] ; else if ( j == 9 ) dp [ i , j ] = dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = dp [ i - 1 , j - 1 ] + dp [ i - 1 , j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n , j ] ; return sum ; }
bool isSubSeqDivisible ( string str ) { int i , j , k , l = str . Length ; int [ ] arr = new int [ l ] ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = str [ i ] - '0' ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
int maxLength ( String s , int n ) { int [ , ] dp = new int [ n , n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == '(' && s [ i + 1 ] == ')' ) dp [ i , i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == '(' && s [ j ] == ')' ) dp [ i , j ] = 2 + dp [ i + 1 , j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i , j ] = Math . Max ( dp [ i , j ] , dp [ i , k ] + dp [ k + 1 , j ] ) ; } } return dp [ 0 , n - 1 ] ; }
int maxLength ( String s , int n ) { int invalidOpenBraces = 0 ; int invalidCloseBraces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '(' ) { invalidOpenBraces ++ ; } else { if ( invalidOpenBraces == 0 ) { invalidCloseBraces ++ ; } else { invalidOpenBraces -- ; } } } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; }
int numberOfWays ( int x ) { int [ ] dp = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
void dfs ( int node , int parent , List < int > [ ] tree , int [ ] colour , int [ ] answer ) { answer [ node ] = colour [ node ] ; foreach ( int u in tree [ node ] ) { if ( u == parent ) continue ; dfs ( u , node , tree , colour , answer ) ; answer [ node ] += Math . Max ( answer [ u ] , 0 ) ; } }
int maxDiff ( List < int > [ ] tree , int [ ] colour , int N ) { int [ ] answer = new int [ N + 1 ] ; dfs ( 1 , 0 , tree , colour , answer ) ; int high = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { high = Math . Max ( high , answer [ i ] ) ; answer [ i ] = 0 ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( colour [ i ] == - 1 ) colour [ i ] = 1 ; else colour [ i ] = - 1 ; } dfs ( 1 , 0 , tree , colour , answer ) ; for ( int i = 1 ; i < N ; i ++ ) high = Math . Max ( high , answer [ i ] ) ; return high ; }
void alternateSubarray ( bool [ ] arr , int n ) { int [ ] len = new int [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) Console . Write ( len [ i ] + " " ) ; }
void alternateSubarray ( bool [ ] arr , int n ) { int count = 1 ; bool prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { if ( ( arr [ i ] ^ prev ) == false ) { while ( count > 0 ) { Console . Write ( count -- + " " ) ; } } ++ count ; prev = arr [ i ] ; } while ( count != 0 ) { Console . Write ( count -- + " " ) ; } }
int lcs ( int [ , , ] dp , int [ ] arr1 , int n , int [ ] arr2 , int m , int k ) { if ( k < 0 ) return - 10000000 ; if ( n < 0 m < 0 ) return 0 ; int ans = dp [ n , m , k ] ; if ( ans != - 1 ) return ans ; try { ans = Math . Max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . Max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = Math . Max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; } catch ( Exception e ) { } return ans ; }
int productSubSeqCount ( ArrayList arr , int k ) { int n = arr . Count ; int [ , ] dp = new int [ k + 1 , n + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i , j ] = dp [ i , j - 1 ] ; if ( Convert . ToInt32 ( arr [ j - 1 ] ) <= i && Convert . ToInt32 ( arr [ j - 1 ] ) > 0 ) dp [ i , j ] += dp [ i / Convert . ToInt32 ( arr [ j - 1 ] ) , j - 1 ] + 1 ; } } return dp [ k , n ] ; }
int waysToArrange ( int N , int K , int [ ] k ) { int [ , ] C = new int [ N + 1 , N + 1 ] ; int i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = ( C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ) ; } } int [ ] dp = new int [ K + 1 ] ; int count = 0 ; dp [ 0 ] = 1 ; for ( i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 , k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; }
int LIP ( int [ , ] dp , int [ , ] mat , int n , int m , int x , int y ) { if ( dp [ x , y ] < 0 ) { int result = 0 ; if ( x == n - 1 && y == m - 1 ) return dp [ x , y ] = 1 ; if ( x == n - 1 y == m - 1 ) result = 1 ; if ( x + 1 < n && mat [ x , y ] < mat [ x + 1 , y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ; if ( y + 1 < m && mat [ x , y ] < mat [ x , y + 1 ] ) result = Math . Max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x , y ] = result ; } return dp [ x , y ] ; }
int wrapper ( int [ , ] mat , int n , int m ) { int [ , ] dp = new int [ 10 , 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { dp [ i , j ] = - 1 ; } } return LIP ( dp , mat , n , m , 0 , 0 ) ; }
int minCells ( int [ , ] mat , int m , int n ) { int [ , ] dp = new int [ m , n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i , j ] = int . MaxValue ; dp [ 0 , 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i , j ] != int . MaxValue && ( j + mat [ i , j ] ) < n && ( dp [ i , j ] + 1 ) < dp [ i , j + mat [ i , j ] ] ) dp [ i , j + mat [ i , j ] ] = dp [ i , j ] + 1 ; if ( dp [ i , j ] != int . MaxValue && ( i + mat [ i , j ] ) < m && ( dp [ i , j ] + 1 ) < dp [ i + mat [ i , j ] , j ] ) dp [ i + mat [ i , j ] , j ] = dp [ i , j ] + 1 ; } } if ( dp [ m - 1 , n - 1 ] != int . MaxValue ) return dp [ m - 1 , n - 1 ] ; return - 1 ; }
int GetCeilIndex ( int [ ] arr , int [ ] T , int l , int r , int key ) { while ( r - l > 1 ) { int m = l + ( r - l ) / 2 ; if ( arr [ T [ m ] ] >= key ) r = m ; else l = m ; } return r ; }
void LIS ( int [ ] arr , int n ) { int [ ] tailIndices = new int [ n ] ; int [ ] prevIndices = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { tailIndices [ i ] = 0 ; prevIndices [ i ] = - 1 ; } int len = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ tailIndices [ 0 ] ] ) tailIndices [ 0 ] = i ; else if ( arr [ i ] > arr [ tailIndices [ len - 1 ] ] ) { prevIndices [ i ] = tailIndices [ len - 1 ] ; tailIndices [ len ++ ] = i ; } else { int pos = GetCeilIndex ( arr , tailIndices , - 1 , len - 1 , arr [ i ] ) ; prevIndices [ i ] = tailIndices [ pos - 1 ] ; tailIndices [ pos ] = i ; } } for ( int i = tailIndices [ len - 1 ] ; i >= 0 ; i = prevIndices [ i ] ) res . Add ( arr [ i ] ) ; }
void longestBitonic ( int [ ] arr1 , int n1 , int [ ] arr2 , int n2 ) { LIS ( arr1 , n1 ) ; res . Reverse ( ) ; arr2 = reverse ( arr2 ) ; LIS ( arr2 , n2 ) ; for ( int i = 0 ; i < res . Count ; i ++ ) Console . Write ( res [ i ] + " " ) ; }
bool ElementsCalculationFunc ( int [ ] pre , int [ ] maxx , int x , int k , int n ) { for ( int i = 0 , j = x ; j <= n ; j ++ , i ++ ) { if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; }
int solve ( int [ , ] dp , int [ ] a , int low , int high , int turn ) { if ( low == high ) return a [ low ] * turn ; if ( dp [ low , high ] != 0 ) return dp [ low , high ] ; dp [ low , high ] = Math . Max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low , high ] ; }
int cal ( int [ , ] ones , int x , int y , int k ) { return ones [ x + k - 1 , y + k - 1 ] - ones [ x - 1 , y + k - 1 ] - ones [ x + k - 1 , y - 1 ] + ones [ x - 1 , y - 1 ] ; }
int sol ( int [ , ] mat ) { int ans = 0 ; int val = 0 ; int [ , ] ones = new int [ R + 1 , C + 1 ] ; for ( int i = 1 ; i <= R ; i ++ ) for ( int j = 1 ; j <= C ; j ++ ) { if ( mat [ i - 1 , j - 1 ] == 1 ) val = 1 ; ones [ i , j ] = ones [ i - 1 , j ] + ones [ i , j - 1 ] - ones [ i - 1 , j - 1 ] + ( val ) ; } for ( int k = 1 ; k <= Math . Min ( R , C ) ; k ++ ) for ( int i = 1 ; i + k - 1 <= R ; i ++ ) for ( int j = 1 ; j + k - 1 <= C ; j ++ ) ans = Math . Max ( ans , ( ones [ R , C ] + k * k - 2 * cal ( ones , i , j , k ) ) ) ; return ans ; }
int maxSumBitonicSubArr ( int [ ] arr , int n ) { int [ ] msis = new int [ n ] ; int [ ] msds = new int [ n ] ; int max_sum = int . MinValue ; msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; }
int maxSumBitonicSubArr ( int [ ] arr , int n ) { int max_sum = - 1000000 ; int i = 0 ; while ( i < n ) { int j = i ; while ( j + 1 < n && arr [ j ] < arr [ j + 1 ] ) j ++ ; while ( i < j && arr [ i ] <= 0 ) i ++ ; int k = j ; while ( k + 1 < n && arr [ k ] > arr [ k + 1 ] ) k ++ ; int last = k ; while ( k > j && arr [ k ] <= 0 ) k -- ; int sum_inc = find_partial_sum ( arr , i , j + 1 ) ; int sum_dec = find_partial_sum ( arr , j , k + 1 ) ; int sum_all = sum_inc + sum_dec - arr [ j ] ; max_sum = Math . Max ( Math . Max ( max_sum , sum_inc ) , Math . Max ( sum_dec , sum_all ) ) ; i = Math . Max ( last , i + 1 ) ; } return max_sum ; }
long countWays ( int n ) { long [ , ] dp = new long [ 2 , n + 1 ] ; dp [ 0 , 1 ] = 1 ; dp [ 1 , 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 , i ] = dp [ 0 , i - 1 ] + dp [ 1 , i - 1 ] ; dp [ 1 , i ] = dp [ 0 , i - 1 ] * 2 + dp [ 1 , i - 1 ] ; } return dp [ 0 , n ] + dp [ 1 , n ] ; }
int countways ( int n ) { int [ ] A = new int [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 3 ; A [ 2 ] = 7 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] ; } return A [ n ] ; }
bool findWinner ( int x , int y , int n ) { bool [ ] dp = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] = false ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && dp [ i - 1 ] == false ) dp [ i ] = true ; else if ( i - x >= 0 && dp [ i - x ] == false ) dp [ i ] = true ; else if ( i - y >= 0 && dp [ i - y ] == false ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }
void printSuperSeq ( string a , string b ) { int m = a . Length , n = b . Length ; int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i , j ] = j ; else if ( j == 0 ) dp [ i , j ] = i ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i , j ] = 1 + dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = 1 + Math . Min ( dp [ i - 1 , j ] , dp [ i , j - 1 ] ) ; } } string res = "" ; int k = m , l = n ; while ( k > 0 && l > 0 ) { if ( a [ k - 1 ] == b [ l - 1 ] ) { res = a [ k - 1 ] + res ; k -- ; l -- ; } else if ( dp [ k - 1 , l ] < dp [ k , l - 1 ] ) { res = a [ k - 1 ] + res ; k -- ; } else { res = b [ l - 1 ] + res ; l -- ; } } while ( k > 0 ) { res = a [ k - 1 ] + res ; k -- ; } while ( l > 0 ) { res = b [ l - 1 ] + res ; l -- ; } Console . WriteLine ( res ) ; }
int maxGameByWinner ( int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
bool isSubsetSum ( int [ ] arr , int n , int sum ) { bool [ , ] subset = new bool [ 2 , sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 , j ] = true ; else if ( i == 0 ) subset [ i % 2 , j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 , j ] = subset [ ( i + 1 ) % 2 , j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 , j ] ; else subset [ i % 2 , j ] = subset [ ( i + 1 ) % 2 , j ] ; } } return subset [ n % 2 , sum ] ; }
int countTransformation ( string a , string b ) { int n = a . Length , m = b . Length ; if ( m == 0 ) return 1 ; int [ , ] dp = new int [ m , n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i , j ] = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( i == 0 ) { if ( j == 0 ) dp [ i , j ] = ( a [ j ] == b [ i ] ) ? 1 : 0 ; else if ( a [ j ] == b [ i ] ) dp [ i , j ] = dp [ i , j - 1 ] + 1 ; else dp [ i , j ] = dp [ i , j - 1 ] ; } else { if ( a [ j ] == b [ i ] ) dp [ i , j ] = dp [ i , j - 1 ] + dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = dp [ i , j - 1 ] ; } } } return dp [ m - 1 , n - 1 ] ; }
int getSpecialNumber ( int N ) { return ans ( -- N ) ; }
int minimumSquare ( int m , int n ) { int vertical_min = int . MaxValue ; int horizontal_min = int . MaxValue ; if ( n == 13 && m == 11 ) return 6 ; if ( m == 13 && n == 11 ) return 6 ; if ( m == n ) return 1 ; if ( dp [ m , n ] != 0 ) return dp [ m , n ] ; for ( int i = 1 ; i <= m / 2 ; i ++ ) { horizontal_min = Math . Min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) ; } for ( int j = 1 ; j <= n / 2 ; j ++ ) { vertical_min = Math . Min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) ; } dp [ m , n ] = Math . Min ( vertical_min , horizontal_min ) ; return dp [ m , n ] ; }
long fact ( int n ) { long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
long nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; long same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }
int computeLIS ( int [ ] circBuff , int start , int end , int n ) { int [ ] LIS = new int [ n + end - start ] ; for ( int i = start ; i < end ; i ++ ) LIS [ i ] = 1 ; for ( int i = start + 1 ; i < end ; i ++ ) for ( int j = start ; j < i ; j ++ ) if ( circBuff [ i ] > circBuff [ j ] && LIS [ i ] < LIS [ j ] + 1 ) LIS [ i ] = LIS [ j ] + 1 ; int res = int . MinValue ; for ( int i = start ; i < end ; i ++ ) res = Math . Max ( res , LIS [ i ] ) ; return res ; }
int LICS ( int [ ] arr , int n ) { int [ ] circBuff = new int [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) circBuff [ i ] = arr [ i ] ; for ( int i = n ; i < 2 * n ; i ++ ) circBuff [ i ] = arr [ i - n ] ; int res = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) res = Math . Max ( computeLIS ( circBuff , i , i + n , n ) , res ) ; return res ; }
long countBT ( int h ) { long [ ] dp = new long [ h + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; }
int minTimeForWritingChars ( int N , int insert , int remove , int copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; int [ ] dp = new int [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) dp [ i ] = 0 ; dp [ 1 ] = insert ; for ( int i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . Min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ; else dp [ i ] = Math . Min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ; } return dp [ N ] ; }
int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }
int countPaths ( int n , int m ) { int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 , i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i , j ] = dp [ i - 1 , j ] + dp [ i , j - 1 ] ; return dp [ n , m ] ; }
int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
long sumOfSubstrings ( string num ) { long sum = 0 ; long mf = 1 ; for ( int i = num . Length - 1 ; i >= 0 ; i -- ) { sum += ( num [ i ] - '0' ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; }
int countWays ( int n , int m ) { int [ ] count = new int [ n + 1 ] ; count [ 0 ] = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
int maxSum ( int [ , ] grid , int n ) { int incl = Math . Max ( grid [ 0 , 0 ] , grid [ 1 , 0 ] ) ; int excl = 0 , excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = Math . Max ( excl , incl ) ; incl = excl + Math . Max ( grid [ 0 , i ] , grid [ 1 , i ] ) ; excl = excl_new ; } return Math . Max ( excl , incl ) ; }
int maxSumWithK ( int [ ] a , int n , int k ) { int [ ] maxSum = new int [ n ] ; maxSum [ 0 ] = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { curr_max = Math . Max ( a [ i ] , curr_max + a [ i ] ) ; maxSum [ i ] = curr_max ; } int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += a [ i ] ; int result = sum ; for ( int i = k ; i < n ; i ++ ) { sum = sum + a [ i ] - a [ i - k ] ; result = Math . Max ( result , sum ) ; result = Math . Max ( result , sum + maxSum [ i - k ] ) ; } return result ; }
int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
int getTotalNumberOfSequences ( int m , int n ) { int [ , ] T = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i , j ] = 0 ; else if ( i < j ) T [ i , j ] = 0 ; else if ( j == 1 ) T [ i , j ] = i ; else T [ i , j ] = T [ i - 1 , j ] + T [ i / 2 , j - 1 ] ; } } return T [ m , n ] ; }
int minInsertionStepToSortArray ( int [ ] arr , int N ) { int [ ] lis = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; }
void printDistinct ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str . Length ; i ++ ) if ( str [ i ] != ' ' ) count [ ( int ) str [ i ] ] ++ ; int n = i ; for ( i = 0 ; i < n ; i ++ ) if ( count [ ( int ) str [ i ] ] == 1 ) Console . Write ( str [ i ] ) ; }
int lcs ( string str1 , string str2 , int m , int n ) { int [ , ] L = new int [ m + 1 , n + 1 ] ; int i , j ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i , j ] = 0 ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) L [ i , j ] = L [ i - 1 , j - 1 ] + 1 ; else L [ i , j ] = Math . Max ( L [ i - 1 , j ] , L [ i , j - 1 ] ) ; } } return L [ m , n ] ; }
void countWaysToJump ( int [ ] arr , int n ) { int [ ] count_jump = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) count_jump [ i ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( count_jump [ i ] + " " ) ; }
int lis ( int [ ] arr , int n ) { int result = 0 ; int [ ] lis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < lis [ i ] ) result = lis [ i ] ; return result ; }
int minStepToDeleteString ( string str ) { int N = str . Length ; int [ , ] dp = new int [ N + 1 , N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i , j ] = 0 ; for ( int len = 1 ; len <= N ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i , j ] = 1 ; else { dp [ i , j ] = 1 + dp [ i + 1 , j ] ; if ( str [ i ] == str [ i + 1 ] ) dp [ i , j ] = Math . Min ( 1 + dp [ i + 2 , j ] , dp [ i , j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) if ( str [ i ] == str [ K ] ) dp [ i , j ] = Math . Min ( dp [ i + 1 , K - 1 ] + dp [ K + 1 , j ] , dp [ i , j ] ) ; } } } return dp [ 0 , N - 1 ] ; }
void solve ( int i , int par , int [ ] a , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . Min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
int minCost ( int [ ] a , int n , int k ) { int [ , ] dp = new int [ n + 1 , k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i , j ] = inf ; dp [ 0 , 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i , j ] = Math . Min ( dp [ i , j ] , dp [ m , j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n , k ] ; }
int getMinSteps ( int n ) { int [ ] table = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) table [ i ] = n - i ; for ( int i = n ; i >= 1 ; i -- ) { if ( ! ( i % 2 > 0 ) ) table [ i / 2 ] = Math . Min ( table [ i ] + 1 , table [ i / 2 ] ) ; if ( ! ( i % 3 > 0 ) ) table [ i / 3 ] = Math . Min ( table [ i ] + 1 , table [ i / 3 ] ) ; } return table [ 1 ] ; }
int minimumNumberOfDeletions ( string str ) { int n = str . Length ; int len = lps ( str ) ; return ( n - len ) ; }
int utility_fun_for_del ( string str , int i , int j ) { if ( i >= j ) return 0 ; if ( str [ i ] == str [ j ] ) { return utility_fun_for_del ( str , i + 1 , j - 1 ) ; } return 1 + Math . Min ( utility_fun_for_del ( str , i + 1 , j ) , utility_fun_for_del ( str , i , j - 1 ) ) ; }
int min_ele_del ( string str ) { return utility_fun_for_del ( str , 0 , str . Length - 1 ) ; }
int numofArray ( int n , int m ) { int [ , ] dp = new int [ MAX , MAX ] ; List < int > [ ] di = new List < int > [ MAX ] ; List < int > [ ] mu = new List < int > [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i , j ] = 0 ; } } for ( int i = 0 ; i < MAX ; i ++ ) { di [ i ] = new List < int > ( ) ; mu [ i ] = new List < int > ( ) ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 2 * i ; j <= m ; j += i ) { di [ j ] . Add ( i ) ; mu [ i ] . Add ( j ) ; } di [ i ] . Add ( i ) ; } for ( int i = 1 ; i <= m ; i ++ ) dp [ 1 , i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i , j ] = 0 ; foreach ( int x in di [ j ] ) dp [ i , j ] += dp [ i - 1 , x ] ; foreach ( int x in mu [ j ] ) dp [ i , j ] += dp [ i - 1 , x ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans += dp [ n , i ] ; di [ i ] . Clear ( ) ; mu [ i ] . Clear ( ) ; } return ans ; }
int offeringNumber ( int n , int [ ] templeHeight ) { for ( int i = 0 ; i < n ; ++ i ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; } for ( int j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; } sum += Math . Max ( right , left ) + 1 ; } return sum ; }
int stringReduction ( String str ) { int n = str . Length ; int [ ] count = new int [ 3 ] ; for ( int i = 0 ; i < n ; ++ i ) { count [ str [ i ] - 'a' ] ++ ; } if ( count [ 0 ] == n count [ 1 ] == n count [ 2 ] == n ) { return n ; } if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) { return 2 ; } return 1 ; }
bool modularSum ( int [ ] arr , int n , int m ) { if ( n > m ) return true ; bool [ ] DP = new bool [ m ] ; for ( int l = 0 ; l < DP . Length ; l ++ ) DP [ l ] = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; bool [ ] temp = new bool [ m ] ; for ( int l = 0 ; l < temp . Length ; l ++ ) temp [ l ] = false ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
int maxSum ( int [ , ] tri , int n ) { if ( n > 1 ) tri [ 1 , 1 ] = tri [ 1 , 1 ] + tri [ 0 , 0 ] ; tri [ 1 , 0 ] = tri [ 1 , 0 ] + tri [ 0 , 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { tri [ i , 0 ] = tri [ i , 0 ] + tri [ i - 1 , 0 ] ; tri [ i , i ] = tri [ i , i ] + tri [ i - 1 , i - 1 ] ; for ( int j = 1 ; j < i ; j ++ ) { if ( tri [ i , j ] + tri [ i - 1 , j - 1 ] >= tri [ i , j ] + tri [ i - 1 , j ] ) tri [ i , j ] = tri [ i , j ] + tri [ i - 1 , j - 1 ] ; else tri [ i , j ] = tri [ i , j ] + tri [ i - 1 , j ] ; } } int max = tri [ n - 1 , 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < tri [ n - 1 , i ] ) max = tri [ n - 1 , i ] ; } return max ; }
int largestZigZagSumRec ( int [ , ] mat , int i , int j , int n ) { if ( dp [ i , j ] != - 1 ) return dp [ i , j ] ; if ( i == n - 1 ) return ( dp [ i , j ] = mat [ i , j ] ) ; int zzs = 0 ; for ( int k = 0 ; k < n ; k ++ ) if ( k != j ) zzs = Math . Max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) ; return ( dp [ i , j ] = ( zzs + mat [ i , j ] ) ) ; }
int largestZigZag ( int [ , ] mat , int n ) { for ( int i = 0 ; i < MAX ; i ++ ) for ( int k = 0 ; k < MAX ; k ++ ) dp [ i , k ] = - 1 ; int res = 0 ; for ( int j = 0 ; j < n ; j ++ ) res = Math . Max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) ; return res ; }
int countEndless ( bool [ , ] input , int n ) { bool [ , ] row = new bool [ n , n ] ; bool [ , ] col = new bool [ n , n ] ; for ( int j = 0 ; j < n ; j ++ ) { bool isEndless = true ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( input [ i , j ] == false ) isEndless = false ; col [ i , j ] = isEndless ; } } for ( int i = 0 ; i < n ; i ++ ) { bool isEndless = true ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i , j ] == false ) isEndless = false ; row [ i , j ] = isEndless ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( row [ i , j ] && col [ i , j ] ) ans ++ ; return ans ; }
int countSubsequences ( String s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == 'a' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == 'b' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == 'c' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
int maximumDifferenceSum ( int [ ] arr , int N ) { int [ , ] dp = new int [ N , 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i , 0 ] = dp [ i , 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 , 0 ] = Math . Max ( dp [ i , 0 ] , dp [ i , 1 ] + Math . Abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 , 1 ] = Math . Max ( dp [ i , 0 ] + Math . Abs ( arr [ i + 1 ] - 1 ) , dp [ i , 1 ] + Math . Abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . Max ( dp [ N - 1 , 0 ] , dp [ N - 1 , 1 ] ) ; }
int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
int maxRevenue ( int m , int [ ] x , int [ ] revenue , int n , int t ) { int [ ] maxRev = new int [ m + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) maxRev [ i ] = 0 ; int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . Max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . Max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }
int getMaxGold ( int [ , ] gold , int m , int n ) { int [ , ] goldTable = new int [ m , n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) goldTable [ i , j ] = 0 ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row , col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 , col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 , col + 1 ] ; goldTable [ row , col ] = gold [ row , col ] + Math . Max ( right , Math . Max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 , 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . Max ( res , goldTable [ i , 0 ] ) ; return res ; }
int largestKSubmatrix ( int [ , ] a ) { int [ , ] dp = new int [ Row , Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i , j ] = 1 ; else { if ( a [ i , j ] == a [ i - 1 , j ] && a [ i , j ] == a [ i , j - 1 ] && a [ i , j ] == a [ i - 1 , j - 1 ] ) { dp [ i , j ] = ( dp [ i - 1 , j ] > dp [ i , j - 1 ] && dp [ i - 1 , j ] > dp [ i - 1 , j - 1 ] + 1 ) ? dp [ i - 1 , j ] : ( dp [ i , j - 1 ] > dp [ i - 1 , j ] && dp [ i , j - 1 ] > dp [ i - 1 , j - 1 ] + 1 ) ? dp [ i , j - 1 ] : dp [ i - 1 , j - 1 ] + 1 ; } else dp [ i , j ] = 1 ; } result = result > dp [ i , j ] ? result : dp [ i , j ] ; } } return result ; }
int countDivisibleSubseq ( string str , int n ) { int len = str . Length ; int [ , ] dp = new int [ len , n ] ; dp [ 0 , ( str [ 0 ] - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i , ( str [ i ] - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i , j ] += dp [ i - 1 , j ] ; dp [ i , ( j * 10 + ( str [ i ] - '0' ) ) % n ] += dp [ i - 1 , j ] ; } } return dp [ len - 1 , 0 ] ; }
int MaximumPath ( int [ , ] Mat ) { int result = 0 ; int [ , ] dp = new int [ N , N + 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ 0 , i + 1 ] = Mat [ 0 , i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i , j ] = Math . Max ( dp [ i - 1 , j - 1 ] , Math . Max ( dp [ i - 1 , j ] , dp [ i - 1 , j + 1 ] ) ) + Mat [ i , j - 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) result = Math . Max ( result , dp [ N - 1 , i ] ) ; return result ; }
double probability ( int k , int n ) { double ans = 0 ; for ( int i = k ; i <= n ; ++ i ) ans += fact [ n ] / ( fact [ i ] * fact [ n - i ] ) ; ans = ans / ( 1 << n ) ; return ans ; }
void precompute ( ) { fact [ 0 ] = fact [ 1 ] = 1 ; for ( int i = 2 ; i < 20 ; ++ i ) fact [ i ] = fact [ i - 1 ] * i ; }
double probability ( int k , int n ) { double ans = 0.0 ; for ( int i = k ; i <= n ; ++ i ) { double res = dp [ n ] - dp [ i ] - dp [ n - i ] - n ; ans += Math . Pow ( 2.0 , res ) ; } return ans ; }
void precompute ( ) { for ( int i = 2 ; i < MAX ; ++ i ) dp [ i ] = ( Math . Log ( i ) / Math . Log ( 2 ) ) + dp [ i - 1 ] ; }
int countStrings ( int n , int k ) { int [ , , ] dp = new int [ n + 1 , k + 1 , 2 ] ; dp [ 1 , 0 , 0 ] = 1 ; dp [ 1 , 0 , 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i , j , 0 ] = dp [ i - 1 , j , 0 ] + dp [ i - 1 , j , 1 ] ; dp [ i , j , 1 ] = dp [ i - 1 , j , 0 ] ; if ( j - 1 >= 0 ) { dp [ i , j , 1 ] += dp [ i - 1 , j - 1 , 1 ] ; } } } return dp [ n , k , 0 ] + dp [ n , k , 1 ] ; }
bool canVote ( int [ ] a , int n , int x ) { int [ , ] dp = new int [ n + 1 , x + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < x + 1 ; j ++ ) { dp [ i , j ] = 0 ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) if ( a [ i ] <= j ) dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] , a [ i ] + dp [ i - 1 , j - a [ i ] ] ) ; else dp [ i , j ] = dp [ i - 1 , j ] ; return ( sum - dp [ n , x ] >= x ) ; }
int countFriendsPairings ( int n ) { int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
int countFriendsPairings ( int n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }
int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) { return n ; } for ( int i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; }
int maxPathSum ( int [ , ] tri , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 , j ] > tri [ i + 1 , j + 1 ] ) tri [ i , j ] += tri [ i + 1 , j ] ; else tri [ i , j ] += tri [ i + 1 , j + 1 ] ; } } return tri [ 0 , 0 ] ; }
int findMaxPoints ( int [ , ] A ) { int [ , ] P1S = new int [ M + 2 , N + 2 ] ; int [ , ] P1E = new int [ M + 2 , N + 2 ] ; int [ , ] P2S = new int [ M + 2 , N + 2 ] ; int [ , ] P2E = new int [ M + 2 , N + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 1 ; j <= M ; j ++ ) P1S [ i , j ] = Math . Max ( P1S [ i - 1 , j ] , P1S [ i , j - 1 ] ) + A [ i - 1 , j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = M ; j >= 1 ; j -- ) P1E [ i , j ] = Math . Max ( P1E [ i + 1 , j ] , P1E [ i , j + 1 ] ) + A [ i - 1 , j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = 1 ; j <= M ; j ++ ) P2S [ i , j ] = Math . Max ( P2S [ i + 1 , j ] , P2S [ i , j - 1 ] ) + A [ i - 1 , j - 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = M ; j >= 1 ; j -- ) P2E [ i , j ] = Math . Max ( P2E [ i - 1 , j ] , P2E [ i , j + 1 ] ) + A [ i - 1 , j - 1 ] ; int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { for ( int j = 2 ; j < M ; j ++ ) { int op1 = P1S [ i , j - 1 ] + P1E [ i , j + 1 ] + P2S [ i + 1 , j ] + P2E [ i - 1 , j ] ; int op2 = P1S [ i - 1 , j ] + P1E [ i + 1 , j ] + P2S [ i , j - 1 ] + P2E [ i , j + 1 ] ; ans = Math . Max ( ans , Math . Max ( op1 , op2 ) ) ; } } return ans ; }
bool inside ( int x , int y ) { return ( x >= 0 && x < N && y >= 0 && y < N ) ; }
double findProb ( int start_x , int start_y , int steps ) { double [ , , ] dp1 = new double [ N , N , steps + 1 ] ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) dp1 [ i , j , 0 ] = 1 ; for ( int s = 1 ; s <= steps ; ++ s ) { for ( int x = 0 ; x < N ; ++ x ) { for ( int y = 0 ; y < N ; ++ y ) { double prob = 0.0 ; for ( int i = 0 ; i < 8 ; ++ i ) { int nx = x + dx [ i ] ; int ny = y + dy [ i ] ; if ( inside ( nx , ny ) ) prob += dp1 [ nx , ny , s - 1 ] / 8.0 ; } dp1 [ x , y , s ] = prob ; } } } return dp1 [ start_x , start_y , steps ] ; }
int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int [ , , ] L = new int [ m + 1 , n + 1 , o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i , j , k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i , j , k ] = L [ i - 1 , j - 1 , k - 1 ] + 1 ; else L [ i , j , k ] = Math . Max ( Math . Max ( L [ i - 1 , j , k ] , L [ i , j - 1 , k ] ) , L [ i , j , k - 1 ] ) ; } } } return L [ m , n , o ] ; }
int lcsOf3 ( int i , int j , int k ) { if ( i == - 1 j == - 1 k == - 1 ) return 0 ; if ( dp [ i , j , k ] != - 1 ) return dp [ i , j , k ] ; if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) return dp [ i , j , k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; else return dp [ i , j , k ] = Math . Max ( Math . Max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; }
void distSumRec ( int [ ] arr , int n , int sum , int currindex , HashSet < int > s ) { if ( currindex > n ) return ; if ( currindex == n ) { s . Add ( sum ) ; return ; } distSumRec ( arr , n , sum + arr [ currindex ] , currindex + 1 , s ) ; distSumRec ( arr , n , sum , currindex + 1 , s ) ; }
void printDistSum ( int [ ] arr , int n ) { HashSet < int > s = new HashSet < int > ( ) ; distSumRec ( arr , n , 0 , 0 , s ) ; foreach ( int i in s ) Console . Write ( i + " " ) ; }
void printDistSum ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; bool [ , ] dp = new bool [ n + 1 , sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i , arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 , j ] == true ) { dp [ i , j ] = true ; dp [ i , j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) if ( dp [ n , j ] == true ) Console . Write ( j + " " ) ; }
void printMaxSum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= Math . Sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( dp [ i ] + " " ) ; }
int countPaths ( int [ , ] maze ) { if ( maze [ 0 , 0 ] == - 1 ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( maze [ i , 0 ] == 0 ) maze [ i , 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i ++ ) { if ( maze [ 0 , i ] == 0 ) maze [ 0 , i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( maze [ i , j ] == - 1 ) continue ; if ( maze [ i - 1 , j ] > 0 ) maze [ i , j ] = ( maze [ i , j ] + maze [ i - 1 , j ] ) ; if ( maze [ i , j - 1 ] > 0 ) maze [ i , j ] = ( maze [ i , j ] + maze [ i , j - 1 ] ) ; } } return ( maze [ R - 1 , C - 1 ] > 0 ) ? maze [ R - 1 , C - 1 ] : 0 ; }
int minSum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . Min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return Math . Min ( arr [ 0 ] , Math . Min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return Math . Min ( Math . Min ( arr [ 0 ] , arr [ 1 ] ) , Math . Min ( arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + Math . Min ( Math . Min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . Min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; return Math . Min ( Math . Min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . Min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; }
int minSum ( int [ ] ar , int n ) { if ( n <= 4 ) return ar . Min ( ) ; int [ ] sum = new int [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; int [ ] tempArr ; for ( int i = 4 ; i < n ; i ++ ) { tempArr = new int [ 4 ] ; Array . Copy ( sum , i - 4 , tempArr , 0 , 4 ) ; sum [ i ] = ar [ i ] + tempArr . Min ( ) ; } tempArr = new int [ 4 ] ; Array . Copy ( sum , n - 4 , tempArr , 0 , 4 ) ; return tempArr . Min ( ) ; }
void printMinAndMaxValueOfExp ( string exp ) { List < int > num = new List < int > ( ) ; List < char > opr = new List < char > ( ) ; string tmp = "" ; for ( int i = 0 ; i < exp . Length ; i ++ ) { if ( isOperator ( exp [ i ] ) ) { opr . Add ( exp [ i ] ) ; num . Add ( int . Parse ( tmp ) ) ; tmp = "" ; } else { tmp += exp [ i ] ; } } num . Add ( int . Parse ( tmp ) ) ; int len = num . Count ; int [ , ] minVal = new int [ len , len ] ; int [ , ] maxVal = new int [ len , len ] ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { minVal [ i , j ] = Int32 . MaxValue ; maxVal [ i , j ] = 0 ; if ( i == j ) { minVal [ i , j ] = maxVal [ i , j ] = num [ i ] ; } } } for ( int L = 2 ; L <= len ; L ++ ) { for ( int i = 0 ; i < len - L + 1 ; i ++ ) { int j = i + L - 1 ; for ( int k = i ; k < j ; k ++ ) { int minTmp = 0 , maxTmp = 0 ; if ( opr [ k ] == '+' ) { minTmp = minVal [ i , k ] + minVal [ k + 1 , j ] ; maxTmp = maxVal [ i , k ] + maxVal [ k + 1 , j ] ; } else if ( opr [ k ] == '*' ) { minTmp = minVal [ i , k ] * minVal [ k + 1 , j ] ; maxTmp = maxVal [ i , k ] * maxVal [ k + 1 , j ] ; } if ( minTmp < minVal [ i , j ] ) minVal [ i , j ] = minTmp ; if ( maxTmp > maxVal [ i , j ] ) maxVal [ i , j ] = maxTmp ; } } } Console . Write ( "Minimum value : " + minVal [ 0 , len - 1 ] + ", Maximum value : " + maxVal [ 0 , len - 1 ] ) ; }
int maxDecimalValue ( int [ , ] mat , int i , int j , int p ) { if ( i >= N j >= N ) { return 0 ; } int result = Math . Max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i , j ] == 1 ) { return ( int ) ( Math . Pow ( 2 , p ) + result ) ; } else { return result ; } }
int MaximumDecimalValue ( int [ , ] mat , int n ) { int [ , ] dp = new int [ n , n ] ; if ( mat [ 0 , 0 ] == 1 ) { } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 , i ] == 1 ) { dp [ 0 , i ] = ( int ) ( dp [ 0 , i - 1 ] + Math . Pow ( 2 , i ) ) ; else { dp [ 0 , i ] = dp [ 0 , i - 1 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ i , 0 ] == 1 ) { dp [ i , 0 ] = ( int ) ( dp [ i - 1 , 0 ] + Math . Pow ( 2 , i ) ) ; else { dp [ i , 0 ] = dp [ i - 1 , 0 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i , j ] == 1 ) { dp [ i , j ] = ( int ) ( Math . Max ( dp [ i , j - 1 ] , dp [ i - 1 , j ] ) + Math . Pow ( 2 , i + j ) ) ; } else { dp [ i , j ] = Math . Max ( dp [ i , j - 1 ] , dp [ i - 1 , j ] ) ; } } } return dp [ n - 1 , n - 1 ] ; }
int longestSubseqWithDiffOne ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . Max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
int nCr ( int n , int k ) { int [ , ] C = new int [ n + 1 , k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } return C [ n , k ] ; }
double resultOfAllSubsets ( int [ ] arr , int N ) { double result = 0.0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; for ( int n = 1 ; n <= N ; n ++ ) result += ( double ) ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n ; return result ; }
int maxSumWO3Consec ( int [ ] arr , int n ) { int [ ] sum = new int [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . Max ( sum [ 1 ] , Math . Max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = Math . Max ( Math . Max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = Math . Max ( Math . Max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
int maxAlternateSum ( int [ ] arr , int n ) { if ( n == 1 ) return arr [ 0 ] ; int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( min > arr [ i ] ) min = arr [ i ] ; } if ( min == arr [ 0 ] ) { return arr [ 0 ] ; } int [ ] dec = new int [ n ] ; int [ ] inc = new int [ n ] ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = Math . Max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = Math . Max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } int result = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } return result ; }
int maxSumPairWithDifferenceLessThanK ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; int [ ] dp = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . Max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . Max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }
void printInorder ( TreeNode node ) { if ( node == null ) return ; printInorder ( node . left ) ; Console . Write ( node . val + " " ) ; printInorder ( node . right ) ; }
int lucas ( int n ) { int a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; }
double maxAverageOfPath ( int [ , ] cost , int N ) { int [ , ] dp = new int [ N + 1 , N + 1 ] ; dp [ 0 , 0 ] = cost [ 0 , 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i , 0 ] = dp [ i - 1 , 0 ] + cost [ i , 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 , j ] = dp [ 0 , j - 1 ] + cost [ 0 , j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] , dp [ i , j - 1 ] ) + cost [ i , j ] ; return ( double ) dp [ N - 1 , N - 1 ] / ( 2 * N - 1 ) ; }
int breakSum ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . Max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }
int countPS ( string str ) { int N = str . Length ; int [ , ] cps = new int [ N + 1 , N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) cps [ i , i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i <= N - L ; i ++ ) { int k = L + i - 1 ; if ( k < N ) { if ( str [ i ] == str [ k ] ) cps [ i , k ] = cps [ i , k - 1 ] + cps [ i + 1 , k ] + 1 ; else cps [ i , k ] = cps [ i , k - 1 ] + cps [ i + 1 , k ] - cps [ i + 1 , k - 1 ] ; } } } return cps [ 0 , N - 1 ] ; }
int countPS ( int i , int j ) { if ( i > j ) return 0 ; if ( dp [ i , j ] != - 1 ) return dp [ i , j ] ; if ( i == j ) return dp [ i , j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i , j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i , j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
int lcs ( string str1 , string str2 , int len1 , int len2 , int i , int j ) { int ret = dp [ i , j ] ; if ( i == len1 j == len2 ) return ret = 0 ; if ( ret != - 1 ) return ret ; ret = 0 ; if ( str1 [ i ] == str2 [ j ] ) ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) ; else ret = Math . Max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) ; return ret ; }
void prinlAllLCSSorted ( string str1 , string str2 ) { int len1 = str1 . Length , len2 = str2 . Length ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i , j ] = - 1 ; } } lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) ; char [ ] data = new char [ MAX ] ; printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) ; }
int maxCost ( int [ , ] mat , int N ) { int [ , ] dp = new int [ N , N ] ; dp [ 0 , 0 ] = mat [ 0 , 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i , 0 ] = mat [ i , 0 ] + dp [ i - 1 , 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i , j ] = mat [ i , j ] + Math . Max ( dp [ i - 1 , j - 1 ] , dp [ i - 1 , j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 , i ] ) result = dp [ N - 1 , i ] ; return result ; }
int numberOfPermWithKInversion ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N , K ] != 0 ) return memo [ N , K ] ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N , K ] = sum ; return sum ; }
int countSub ( int [ ] arr , int n ) { int [ ] count = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - 1 ; j >= 0 ; j -- ) count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] ++ ; } int result = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) result += count [ i ] ; return result ; }
int minimum ( int a , int b , int c ) { return Math . Min ( Math . Min ( a , b ) , c ) ; }
int countSub ( String s ) { Dictionary < char , int > map = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ! map . ContainsKey ( s [ i ] ) ) { map . Add ( s [ i ] , - 1 ) ; } } int allCount = 0 ; int levelCount = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { char c = s [ i ] ; if ( i == 0 ) { allCount = 1 ; if ( ! map . ContainsKey ( c ) ) { map . Add ( c , 1 ) ; } else { map = 1 ; } levelCount = 1 ; continue ; } levelCount = allCount + 1 ; if ( map . ContainsKey ( c ) ) { if ( map < 0 ) { allCount = ( allCount + levelCount ) ; } else { allCount = ( allCount + levelCount - map ) ; } } if ( ! map . ContainsKey ( c ) ) { map . Add ( c , levelCount ) ; } else { map = levelCount ; } } return allCount ; }
int catalanDP ( int n ) { int [ ] catalan = new int [ n + 1 ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; }
int countWays ( int n ) { if ( n < 1 ) { Console . WriteLine ( "Invalid" ) ; return 0 ; } return catalanDP ( n / 2 ) ; }
int countGroups ( int position , int previous_sum , int length , char [ ] num ) { if ( position == length ) return 1 ; if ( dp [ position , previous_sum ] != - 1 ) return dp [ position , previous_sum ] ; dp [ position , previous_sum ] = 0 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position , previous_sum ] = res ; return res ; }
int MinimumCost ( int [ ] cost , int n , int W ) { List < int > val = new List < int > ( ) ; List < int > wt = new List < int > ( ) ; int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != - 1 ) { val . Add ( cost [ i ] ) ; wt . Add ( i + 1 ) ; size ++ ; } } n = size ; int [ , ] min_cost = new int [ n + 1 , W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) min_cost [ 0 , i ] = int . MaxValue ; for ( int i = 1 ; i <= n ; i ++ ) min_cost [ i , 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) { if ( wt [ i - 1 ] > j ) min_cost [ i , j ] = min_cost [ i - 1 , j ] ; else min_cost [ i , j ] = Math . Min ( min_cost [ i - 1 , j ] , min_cost [ i , j - wt [ i - 1 ] ] + val [ i - 1 ] ) ; } } return ( min_cost [ n , W ] == int . MaxValue ) ? - 1 : min_cost [ n , W ] ; }
int minCost ( int [ ] cost , int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int min_cost = Int32 . MaxValue ; for ( int j = 0 ; j < i ; j ++ ) if ( j < n && cost [ j ] != - 1 ) min_cost = Math . Min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) ; dp [ i ] = min_cost ; } return dp [ n ] ; }
int KnapSack ( int [ ] val , int [ ] wt , int n , int W ) { int [ ] dp = new int [ W + 1 ] ; for ( int i = 0 ; i < W + 1 ; i ++ ) dp [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . Max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }
int count ( string a , string b , int m , int n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
int count ( String a , String b ) { int m = a . Length ; int n = b . Length ; int [ , ] lookup = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) lookup [ 0 , i ] = 0 ; for ( int i = 0 ; i <= m ; ++ i ) lookup [ i , 0 ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i , j ] = lookup [ i - 1 , j - 1 ] + lookup [ i - 1 , j ] ; else lookup [ i , j ] = lookup [ i - 1 , j ] ; } } return lookup [ m , n ] ; }
int lcs ( String X , String Y , int m , int n ) { int [ , ] L = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i , j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i , j ] = L [ i - 1 , j - 1 ] + 1 ; else L [ i , j ] = Math . Max ( L [ i - 1 , j ] , L [ i , j - 1 ] ) ; } } return L [ m , n ] ; }
int findMinCost ( String X , String Y , int costX , int costY ) { int m = X . Length ; int n = Y . Length ; int len_LCS ; len_LCS = lcs ( X , Y , m , n ) ; return costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ; }
int findSum ( List < int > arr ) { int sum = 0 ; foreach ( int i in arr ) sum += i ; return sum ; }
int maxTasks ( int [ ] high , int [ ] low , int n ) { if ( n <= 0 ) return 0 ; return Math . Max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; }
int maxTasks ( int [ ] high , int [ ] low , int n ) { int [ ] task_dp = new int [ n + 1 ] ; task_dp [ 0 ] = 0 ; task_dp [ 1 ] = high [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) task_dp [ i ] = max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) ; return task_dp [ n ] ; }
HashSet < String > findLCS ( String X , String Y , int m , int n ) { HashSet < String > s = new HashSet < String > ( ) ; if ( m == 0 n == 0 ) { s . Add ( "" ) ; return s ; } if ( X [ m - 1 ] == Y [ n - 1 ] ) { HashSet < String > tmp = findLCS ( X , Y , m - 1 , n - 1 ) ; foreach ( String str in tmp ) s . Add ( str + X [ m - 1 ] ) ; } else { if ( L [ m - 1 , n ] >= L [ m , n - 1 ] ) s = findLCS ( X , Y , m - 1 , n ) ; if ( L [ m , n - 1 ] >= L [ m - 1 , n ] ) { HashSet < String > tmp = findLCS ( X , Y , m , n - 1 ) ; foreach ( String str in tmp ) s . Add ( str ) ; } } return s ; }
int LCS ( String X , String Y , int m , int n ) { for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i , j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i , j ] = L [ i - 1 , j - 1 ] + 1 ; else L [ i , j ] = Math . Max ( L [ i - 1 , j ] , L [ i , j - 1 ] ) ; } } return L [ m , n ] ; }
int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; }
int LCIS ( int [ ] arr1 , int n , int [ ] arr2 , int m ) { int [ ] table = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
int minTime ( int [ ] arr , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + Math . Min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . Min ( incl , excl ) ; }
int lcs ( string X , string Y ) { int m = X . Length , n = Y . Length ; int [ , ] L = new int [ 2 , n + 1 ] ; int bi = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi , j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi , j ] = L [ 1 - bi , j - 1 ] + 1 ; else L [ bi , j ] = Math . Max ( L [ 1 - bi , j ] , L [ bi , j - 1 ] ) ; } } return L [ bi , n ] ; }
int countUtil ( int p , int q , int r ) { return countWays ( p , q , r , 0 ) + countWays ( p , q , r , 1 ) + countWays ( p , q , r , 2 ) ; }
int countWays ( int p , int q , int r , int last ) { if ( p < 0 q < 0 r < 0 ) return 0 ; if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ; if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ; if ( dp [ p , q , r , last ] != - 1 ) return dp [ p , q , r , last ] ; if ( last == 0 ) dp [ p , q , r , last ] = countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ; else if ( last == 1 ) dp [ p , q , r , last ] = countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; else dp [ p , q , r , last ] = countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; return dp [ p , q , r , last ] ; }
int countUtil ( int p , int q , int r ) { for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) for ( int k = 0 ; k < MAX ; k ++ ) for ( int l = 0 ; l < 4 ; l ++ ) dp [ i , j , k , l ] = - 1 ; }
void multiply ( int [ , ] a , int [ , ] b ) { int [ , ] mul = new int [ 3 , 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { mul [ i , j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++ ) mul [ i , j ] += a [ i , k ] * b [ k , j ] ; } } for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) a [ i , j ] = mul [ i , j ] ; }
int power ( int [ , ] F , int n ) { int [ , ] M = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; if ( n == 1 ) return F [ 0 , 0 ] + F [ 0 , 1 ] ; power ( F , n / 2 ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) multiply ( F , M ) ; return F [ 0 , 0 ] + F [ 0 , 1 ] ; }
int findNthTerm ( int n ) { int [ , ] F = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; return power ( F , n - 2 ) ; }
int count ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }
int KSmallestUsingMorris ( Node root , int k ) { int count = 0 ; int ksmall = int . MinValue ; Node curr = root ; while ( curr != null ) { if ( curr . left == null ) { count ++ ; if ( count == k ) ksmall = curr . key ; curr = curr . right ; } else { Node pre = curr . left ; while ( pre . right != null && pre . right != curr ) pre = pre . right ; if ( pre . right == null ) { pre . right = curr ; curr = curr . left ; } else { pre . right = null ; count ++ ; if ( count == k ) ksmall = curr . key ; curr = curr . right ; } } } return ksmall ; }
int subsetXOR ( int [ ] arr , int n , int k ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( Math . Log ( max_ele , 2 ) + 1 ) ) - 1 ; if ( k > m ) { return 0 ; } int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i , j ] = 0 ; dp [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i , j ] = dp [ i - 1 , j ] + dp [ i - 1 , j ^ arr [ i - 1 ] ] ; return dp [ n , k ] ; }
int permutationCoeff ( int n , int k ) { int [ ] fact = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; }
int findMin ( int [ ] arr , int n ) { int sumTotal = 0 ; for ( int i = 0 ; i < n ; i ++ ) sumTotal += arr [ i ] ; return findMinRec ( arr , n , 0 , sumTotal ) ; }
int countDer ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
int countDer ( int n ) { int [ ] der = new int [ n + 1 ] ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
int countDer ( int n ) { if ( n == 1 n == 2 ) { return n - 1 ; } int a = 0 ; int b = 1 ; for ( int i = 3 ; i <= n ; ++ i ) { int cur = ( i - 1 ) * ( a + b ) ; a = b ; b = cur ; } return b ; }
int bellNumber ( int n ) { int [ , ] bell = new int [ n + 1 , n + 1 ] ; bell [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i , 0 ] = bell [ i - 1 , i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) bell [ i , j ] = bell [ i - 1 , j - 1 ] + bell [ i , j - 1 ] ; } return bell [ n , 0 ] ; }
int minSizeRec ( int [ ] arr , int low , int high , int k ) { if ( dp [ low , high ] != - 1 ) { return dp [ low , high ] ; } if ( ( high - low + 1 ) < 3 ) { return high - low + 1 ; } int res = 1 + minSizeRec ( arr , low + 1 , high , k ) ; for ( int i = low + 1 ; i <= high - 1 ; i ++ ) { for ( int j = i + 1 ; j <= high ; j ++ ) { if ( arr [ i ] == ( arr [ low ] + k ) && arr [ j ] == ( arr [ low ] + 2 * k ) && minSizeRec ( arr , low + 1 , i - 1 , k ) == 0 && minSizeRec ( arr , i + 1 , j - 1 , k ) == 0 ) { res = Math . Min ( res , minSizeRec ( arr , j + 1 , high , k ) ) ; } } } return ( dp [ low , high ] = res ) ; }
int countSol ( int [ ] coeff , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
int countSol ( int [ ] coeff , int n , int rhs ) { int [ ] dp = new int [ rhs + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
int printCountDP ( int dist ) { int [ ] count = new int [ dist + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
int findLongestRepeatingSubSeq ( string str ) { int n = str . Length ; int [ , ] dp = new int [ n + 1 , n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i , j ] = 1 + dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = Math . Max ( dp [ i , j - 1 ] , dp [ i - 1 , j ] ) ; } } return dp [ n , n ] ; }
bool isInorder ( int [ ] arr , int n ) { if ( n == 0 n == 1 ) { return true ; } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) { return false ; } } return true ; }
int getMaxRec ( string str , int i , int n , int [ ] lookup ) { if ( i >= n ) return 0 ; if ( lookup [ i ] != - 1 ) return lookup [ i ] ; int ans = 1 + getMaxRec ( str , i + 1 , n , lookup ) ; if ( i + 1 < n ) { if ( str [ i ] != str [ i + 1 ] ) ans = Math . Max ( 4 + getMaxRec ( str , i + 2 , n , lookup ) , ans ) ; else ans = Math . Max ( 3 + getMaxRec ( str , i + 2 , n , lookup ) , ans ) ; } return lookup [ i ] = ans ; }
int getMaxWeight ( string str ) { int n = str . Length ; int [ ] lookup = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] = - 1 ; return getMaxRec ( str , 0 , str . Length , lookup ) ; }
int countRec ( int digits , int esum , int osum , int isOdd , int n ) { if ( digits == n ) return ( esum - osum == 1 ) ? 1 : 0 ; if ( lookup [ digits , esum , osum , isOdd ] != - 1 ) return lookup [ digits , esum , osum , isOdd ] ; int ans = 0 ; if ( isOdd == 1 ) for ( int i = 0 ; i <= 9 ; i ++ ) ans += countRec ( digits + 1 , esum , osum + i , 0 , n ) ; for ( int i = 0 ; i <= 9 ; i ++ ) ans += countRec ( digits + 1 , esum + i , osum , 1 , n ) ; return lookup [ digits , esum , osum , isOdd ] = ans ; }
int finalCount ( int n ) { int digits = 0 ; for ( int i = 0 ; i < 50 ; i ++ ) for ( int j = 0 ; j < 1000 ; j ++ ) for ( int k = 0 ; k < 1000 ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) lookup [ i , j , k , l ] = - 1 ; int ans = 0 ; int esum = 0 , osum = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) ans += countRec ( digits + 1 , esum + i , osum , 1 , n ) ; return ans ; }
int steps ( int source , int step , int dest ) { if ( Math . Abs ( source ) > ( dest ) ) return int . MaxValue ; if ( source == dest ) return step ; int pos = steps ( source + step + 1 , step + 1 , dest ) ; int neg = steps ( source - step - 1 , step + 1 , dest ) ; return Math . Min ( pos , neg ) ; }
int countNumbersWith4 ( int n ) { int result = 0 ; for ( int x = 1 ; x <= n ; x ++ ) result += has4 ( x ) ? 1 : 0 ; return result ; }
int countNumbersWith4 ( int n ) { if ( n < 4 ) return 0 ; int d = ( int ) Math . Log10 ( n ) ; int [ ] a = new int [ d + 2 ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + ( int ) Math . Ceiling ( Math . Pow ( 10 , i - 1 ) ) ; int p = ( int ) Math . Ceiling ( Math . Pow ( 10 , d ) ) ; int msd = n / p ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; }
int max ( int [ ] arr , int l , int h ) { int mx = arr [ l ] ; for ( int i = l + 1 ; i <= h ; i ++ ) if ( mx < arr [ i ] ) mx = arr [ i ] ; return mx ; }
int minRemovalsDP ( int [ ] arr , int n ) { int [ , ] table = new int [ n , n ] ; int gap , i , j , mn , mx ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { mn = min ( arr , i , j ) ; mx = max ( arr , i , j ) ; table [ i , j ] = ( 2 * mn > mx ) ? 0 : min ( table [ i , j - 1 ] + 1 , table [ i + 1 , j ] + 1 ) ; } } return table [ 0 , n - 1 ] ; }
int minRemovalsDP ( int [ ] arr , int n ) { int longest_start = - 1 , longest_end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = int . MaxValue , max = int . MinValue ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) { min = val ; } if ( val > max ) { max = val ; } if ( 2 * min <= max ) { break ; } if ( end - start > longest_end - longest_start longest_start == - 1 ) { longest_start = start ; longest_end = end ; } } } if ( longest_start == - 1 ) { return n ; } return ( n - ( longest_end - longest_start + 1 ) ) ; }
int numberOfPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
int numberOfPaths ( int m , int n ) { int [ , ] count = new int [ m , n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i , 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 , j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ )  } return count [ m - 1 , n - 1 ] ; }
int numberOfPaths ( int m , int n ) { int [ ] dp = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; }
int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }
bool checkBSTs ( Node root1 , Node root2 ) { if ( root1 != null && root2 != null ) return true ; if ( ( root1 == null && root2 != null ) || ( root1 != null && root2 == null ) ) return false ; List < int > v1 = new List < int > ( ) ; List < int > v2 = new List < int > ( ) ; storeInorder ( root1 , v1 ) ; storeInorder ( root2 , v2 ) ; return ( v1 == v2 ) ; }
int lenghtOfLongestAP ( int [ ] set , int n ) { if ( n <= 2 ) return n ; int [ , ] L = new int [ n , n ] ; int llap = 2 ; for ( int i = 0 ; i < n ; i ++ ) L [ i , n - 1 ] = 2 ; for ( int j = n - 2 ; j >= 1 ; j -- ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ; else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) { L [ i , j ] = 2 ; i -- ; } else { L [ i , j ] = L [ j , k ] + 1 ; llap = Math . Max ( llap , L [ i , j ] ) ; i -- ; k ++ ; } } while ( i >= 0 ) { L [ i , j ] = 2 ; i -- ; } } return llap ; }
int carAssembly ( int [ , ] a , int [ , ] t , int [ ] e , int [ ] x ) { int [ ] T1 = new int [ NUM_STATION ] ; int [ ] T2 = new int [ NUM_STATION ] ; int i ; T1 [ 0 ] = e [ 0 ] + a [ 0 , 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 , 0 ] ; for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 , i ] , T2 [ i - 1 ] + t [ 1 , i ] + a [ 0 , i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 , i ] , T1 [ i - 1 ] + t [ 0 , i ] + a [ 1 , i ] ) ; } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; }
int findWays ( int m , int n , int x ) { int [ , ] table = new int [ n + 1 , x + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= x ; j ++ ) table [ i , j ] = 0 ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 , j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) for ( int k = 1 ; k <= m && k < j ; k ++ ) table [ i , j ] += table [ i - 1 , j - k ] ; return table [ n , x ] ; }
long findWays ( int f , int d , int s ) { long [ , ] mem = new long [ d + 1 , s + 1 ] ; mem [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i , j ] = mem [ i , j - 1 ] + mem [ i - 1 , j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i , j ] -= mem [ i - 1 , j - f - 1 ] ; } } return mem [ d , s ] ; }
int LCSubStr ( string X , string Y , int m , int n ) { int [ , ] LCStuff = new int [ m + 1 , n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCStuff [ i , j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i , j ] = LCStuff [ i - 1 , j - 1 ] + 1 ; result = Math . Max ( result , LCStuff [ i , j ] ) ; } else LCStuff [ i , j ] = 0 ; } } return result ; }
int LCSubStr ( string s , string t , int n , int m ) { int [ , ] dp = new int [ 2 , m + 1 ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ] ) { dp [ i % 2 , j ] = dp [ ( i - 1 ) % 2 , j - 1 ] + 1 ; if ( dp [ i % 2 , j ] > res ) res = dp [ i % 2 , j ] ; } else dp [ i % 2 , j ] = 0 ; } } return res ; }
int lcs ( int i , int j , int count ) { if ( i == 0 j == 0 ) { return count ; } if ( X [ i - 1 ] == Y [ j - 1 ] ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; } count = Math . Max ( count , Math . Max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) ; return count ; }
int findMinInsertions ( char [ ] str , int l , int h ) { if ( l > h ) return int . MaxValue ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Math . Min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
int maxCrossingSum ( int [ ] arr , int l , int m , int h ) { int sum = 0 ; int left_sum = int . MinValue ; for ( int i = m ; i >= l ; i -- ) { sum = sum + arr [ i ] ; if ( sum > left_sum ) left_sum = sum ; } sum = 0 ; int right_sum = int . MinValue ; ; for ( int i = m + 1 ; i <= h ; i ++ ) { sum = sum + arr [ i ] ; if ( sum > right_sum ) right_sum = sum ; } return Math . Max ( left_sum + right_sum , Math . Max ( left_sum , right_sum ) ) ; }
int maxSubArraySum ( int [ ] arr , int l , int h ) { if ( l == h ) return arr [ l ] ; int m = ( l + h ) / 2 ; return Math . Max ( Math . Max ( maxSubArraySum ( arr , l , m ) , maxSubArraySum ( arr , m + 1 , h ) ) , maxCrossingSum ( arr , l , m , h ) ) ; }
bool isSubsetSum ( int [ ] set , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
int subsetSum ( int [ ] a , int n , int sum ) { int [ , ] tab = new int [ n + 1 , sum + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { tab [ i , j ] = - 1 ; } } if ( sum == 0 ) return 1 ; if ( n <= 0 ) return 0 ; if ( tab [ n - 1 , sum ] != - 1 ) return tab [ n - 1 , sum ] ; if ( a [ n - 1 ] > sum ) return tab [ n - 1 , sum ] = subsetSum ( a , n - 1 , sum ) ; else { if ( subsetSum ( a , n - 1 , sum ) != 0 || subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) != 0 ) { return tab [ n - 1 , sum ] = 1 ; } else return tab [ n - 1 , sum ] = 0 ; } }
float findWater ( int i , int j , float X ) { if ( j > i ) { Console . WriteLine ( "Incorrect Input" ) ; Environment . Exit ( 0 ) ; } int ll = ( int ) Math . Round ( ( double ) ( i * ( i + 1 ) ) ) ; float [ ] glass = new float [ ll + 2 ] ; int index = 0 ; glass [ index ] = X ; for ( int row = 1 ; row <= i ; ++ row ) { for ( int col = 1 ; col <= row ; ++ col , ++ index ) { X = glass [ index ] ; glass [ index ] = ( X >= 1.0f ) ? 1.0f : X ; X = ( X >= 1.0f ) ? ( X - 1 ) : 0.0f ; glass [ index + row ] += X / 2 ; glass [ index + row + 1 ] += X / 2 ; } } return glass [ ( int ) ( i * ( i - 1 ) / 2 + j - 1 ) ] ; }
int maxChainLength ( Pair [ ] arr , int n ) { int i , j , max = 0 ; int [ ] mcl = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) mcl [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] . a > arr [ j ] . b && mcl [ i ] < mcl [ j ] + 1 ) mcl [ i ] = mcl [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < mcl [ i ] ) max = mcl [ i ] ; return max ; }
void solveWordWrap ( int [ ] l , int n , int M ) { int [ , ] extras = new int [ n + 1 , n + 1 ] ; int [ , ] lc = new int [ n + 1 , n + 1 ] ; int [ ] c = new int [ n + 1 ] ; int [ ] p = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { extras [ i , i ] = M - l [ i - 1 ] ; for ( int j = i + 1 ; j <= n ; j ++ ) extras [ i , j ] = extras [ i , j - 1 ] - l [ j - 1 ] - 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( extras [ i , j ] < 0 ) lc [ i , j ] = MAX ; else if ( j == n && extras [ i , j ] >= 0 ) lc [ i , j ] = 0 ; else lc [ i , j ] = extras [ i , j ] * extras [ i , j ] ; } } c [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { c [ j ] = MAX ; for ( int i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != MAX && lc [ i , j ] != MAX && ( c [ i - 1 ] + lc [ i , j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i , j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; }
int distanceFromRoot ( Node root , int x ) { if ( root . key == x ) return 0 ; else if ( root . key > x ) return 1 + distanceFromRoot ( root . left , x ) ; return 1 + distanceFromRoot ( root . right , x ) ; }
int findDistWrapper ( Node root , int a , int b ) { int temp = 0 ; if ( a > b ) { temp = a ; a = b ; b = temp ; } return distanceBetween2 ( root , a , b ) ; }
bool isSubsetSum ( int [ ] arr , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( arr [ n - 1 ] > sum ) return isSubsetSum ( arr , n - 1 , sum ) ; return isSubsetSum ( arr , n - 1 , sum ) || isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; }
bool findPartiion ( int [ ] arr , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool [ ] part = new bool [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = false ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ sum / 2 ] ; }
int minPalPartion ( string String , int i , int j ) { if ( i >= j || isPalindrome ( String , i , j ) ) return 0 ; int ans = Int32 . MaxValue , count ; for ( int k = i ; k < j ; k ++ ) { count = minPalPartion ( String , i , k ) + minPalPartion ( String , k + 1 , j ) + 1 ; ans = Math . Min ( ans , count ) ; } return ans ; }
int minCut ( string a ) { int [ ] cut = new int [ a . Length ] ; bool [ , ] palindrome = new bool [ a . Length , a . Length ] ; for ( int i = 0 ; i < a . Length ; i ++ ) { int minCut = i ; for ( int j = 0 ; j <= i ; j ++ ) { if ( a [ i ] == a [ j ] && ( i - j < 2 palindrome [ j + 1 , i - 1 ] ) ) { palindrome [ j , i ] = true ; minCut = Math . Min ( minCut , j == 0 ? 0 : ( cut [ j - 1 ] + 1 ) ) ; } } cut [ i ] = minCut ; } return cut [ a . Length - 1 ] ; }
int maxSumIS ( int [ ] arr , int n ) { int i , j , max = 0 ; int [ ] msis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
int cutRod ( int [ ] price , int n ) { int [ ] val = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = int . MinValue ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . Max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }
int max ( int x , int y ) { return ( x > y ) ? x : y ; }
int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long m = 1000000007 ; long [ ] inv = new long [ r + 1 ] ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ ( int ) ( m % i ) ] % m ; } int ans = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { ans = ( int ) ( ( ( ans % m ) * ( inv [ i ] % m ) ) % m ) ; } for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( int ) ( ( ( ans % m ) * ( i % m ) ) % m ) ; } return ans ; }
int matrixChainMemoised ( int [ ] p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i , j ] != - 1 ) { return dp [ i , j ] ; } dp [ i , j ] = Int32 . MaxValue ; for ( int k = i ; k < j ; k ++ ) { dp [ i , j ] = Math . Min ( dp [ i , j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i , j ] ; }
int MatrixChainOrder ( int [ ] p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; }
int count ( int [ ] S , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
int factorial ( int n ) { int res = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { res *= i ; } return res ; }
int catalan ( int n ) { int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
int countBST ( int n ) { int count = catalan ( n ) ; return count ; }
int countBT ( int n ) { int count = catalan ( n ) ; return count * factorial ( n ) ; }
int checkArray ( int [ ] arr , int N , int k ) { if ( N < 3 ) return - 1 ; int i , Sum = 0 , temp = 0 ; for ( i = 0 ; i < N ; i ++ ) Sum += arr [ i ] ; int R = ( k * k + k + 1 ) ; if ( Sum % R != 0 ) return 0 ; int Mid = k * ( Sum / R ) ; for ( i = 1 ; i < N - 1 ; i ++ ) { temp += arr [ i - 1 ] ; if ( arr [ i ] == Mid ) { if ( temp == Mid / k ) return i + 1 ; else return 0 ; } } return 0 ; }
void encodeString ( String str ) { String res = "" ; int [ ] small = new int [ 26 ] ; int [ ] capital = new int [ 26 ] ; int [ ] num = new int [ 10 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { small [ i ] = 0 ; capital [ i ] = 0 ; } for ( int i = 0 ; i < 10 ; i ++ ) { num [ i ] = 0 ; } int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] >= '0' && str [ i ] <= '9' ) { num [ str [ i ] - 48 ] = i ; } else if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) { small [ str [ i ] - 97 ] = i ; } else if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { capital [ str [ i ] - 65 ] = i ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( str [ i ] >= 'a' && str [ i ] <= 'z' ) && small [ str [ i ] - 97 ] == i ) { int occ = str [ i ] - 96 ; while ( occ -- > 0 ) { res += str [ i ] ; } } else if ( ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) && capital [ str [ i ] - 65 ] == i ) { int occ = str [ i ] - 64 ; while ( occ -- > 0 ) { res = res + str [ i ] ; } } else if ( ( str [ i ] >= '0' && str [ i ] <= '9' ) && num [ str [ i ] - 48 ] == i ) { int occ = str [ i ] - 48 ; while ( occ -- > 0 ) { res = res + str [ i ] ; } } else { res = res + str [ i ] ; } } Console . Write ( res ) ; }
void possibleEqualArray ( int [ ] A , int N ) { int [ ] pref = new int [ N ] ; pref [ 0 ] = A [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { pref [ i ] = pref [ i - 1 ] ^ A [ i ] ; } if ( pref [ N - 1 ] == 0 ) { Console . WriteLine ( "YES" ) ; return ; } int cur_xor = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { cur_xor ^= A [ i ] ; for ( int j = 0 ; j < i ; j ++ ) { if ( j != 0 ) { int middle_xor = pref [ j - 1 ] ^ pref [ i - 1 ] ; int left_xor = pref [ j - 1 ] ; int right_xor = cur_xor ; if ( left_xor == middle_xor && middle_xor == right_xor ) { Console . WriteLine ( "YES" ) ; return ; } } } } Console . WriteLine ( "NO" ) ; }
void RangeTraversal ( node root , int n1 , int n2 ) { if ( root == null ) return ; node curr = root ; while ( curr != null ) { if ( curr . left == null ) { if ( curr . data <= n2 && curr . data >= n1 ) { Console . Write ( curr . data + " " ) ; } curr = curr . right ; } else { node pre = curr . left ; while ( pre . right != null && pre . right != curr ) pre = pre . right ; if ( pre . right == null ) { pre . right = curr ; curr = curr . left ; } else { pre . right = null ; if ( curr . data <= n2 && curr . data >= n1 ) { Console . Write ( curr . data + " " ) ; } curr = curr . right ; } } } }
void possibleEqualArray ( int [ ] A , int N ) { int tot_XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { tot_XOR ^= A [ i ] ; } if ( tot_XOR == 0 ) { Console . Write ( "YES" ) ; return ; } int cur_XOR = 0 ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cur_XOR ^= A [ i ] ; if ( cur_XOR == tot_XOR ) { cnt ++ ; cur_XOR = 0 ; } } if ( cnt > 2 ) { Console . Write ( "YES" ) ; } else { Console . Write ( "NO" ) ; } }
void GenerateArray ( int N , int X ) { int prev_xor = X ; for ( int i = 1 ; i <= N ; i ++ ) { Console . Write ( i ^ prev_xor ) ; if ( i != N ) { Console . Write ( " " ) ; } prev_xor = i ; } }
void createGrid ( char [ , ] grid , bool is1 , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( is1 ) { grid [ i , j ] = '0' ; is1 = false ; } else { grid [ i , j ] = '1' ; is1 = true ; } } if ( M % 2 == 0 ) is1 = ! is1 ; } }
bool testGrid ( char [ , ] testGrid , char [ , ] Grid , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( Grid [ i , j ] != '*' ) { if ( Grid [ i , j ] != testGrid [ i , j ] ) { return false ; } } } } return true ; }
void findPossibleGrid ( int N , int M , char [ , ] grid ) { char [ , ] gridTest1 = new char [ N , 1001 ] ; char [ , ] gridTest2 = new char [ N , 1001 ] ; createGrid ( gridTest1 , true , N , M ) ; createGrid ( gridTest2 , false , N , M ) ; if ( testGrid ( gridTest1 , grid , N , M ) ) { Console . WriteLine ( "Yes" ) ; printGrid ( gridTest1 , N , M ) ; } else if ( testGrid ( gridTest2 , grid , N , M ) ) { Console . WriteLine ( "Yes" ) ; printGrid ( gridTest2 , N , M ) ; } else { Console . WriteLine ( "No" ) ; } }
void brute ( int ind , int l , int r ) { if ( ind == n / 2 ) { for ( int i = 0 ; i < ( int ) n ; i ++ ) Console . Write ( brr [ i ] + " " ) ; System . Environment . Exit ( 0 ) ; } for ( int i = l ; i <= arr [ ind ] / 2 ; ++ i ) if ( arr [ ind ] - i <= r ) { brr [ ind ] = i ; brr [ n - ind - 1 ] = arr [ ind ] - i ; brute ( ind + 1 , i , arr [ ind ] - i ) ; } }
int minCount ( int N , int K ) { int [ ] SmallestNumber = new int [ 10 ] ; int [ ] MinimumSteps = new int [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) { SmallestNumber [ i ] = Int32 . MaxValue ; MinimumSteps [ i ] = Int32 . MaxValue ; } for ( int i = 1 ; i <= 10 ; i ++ ) { int num = K * i ; SmallestNumber [ num % 10 ] = Math . Min ( SmallestNumber [ num % 10 ] , num ) ; MinimumSteps [ num % 10 ] = Math . Min ( MinimumSteps [ num % 10 ] , i ) ; } if ( N < SmallestNumber [ N % 10 ] ) { return - 1 ; } else { return MinimumSteps [ N % 10 ] ; } }
bool inRange ( node root , int low , int high ) { return root . data >= low && root . data <= high ; }
int countMinSteps ( int [ ] arr , int N ) { int val = 0 ; int mx = Int32 . MinValue ; for ( int i = 0 ; i < N ; i ++ ) { int curr = arr [ i ] ; mx = Math . Max ( mx , curr ) ; val = Math . Max ( val , mx - curr ) ; } int res = 0 ; while ( ( 1 << res ) - 1 < val ) { ++ res ; } return res ; }
int func2 ( int L , int R , int K ) { if ( R - L >= 2 ) return 1 ; return Math . Min ( L , L ^ R ) ; }
int func3 ( int L , int R , int K ) { if ( ( R ^ L ) > L && ( R ^ L ) < R ) return 0 ; return func2 ( L , R , K ) ; }
int func4 ( int L , int R , int K ) { if ( R - L >= 4 ) return 0 ; int minval = L ^ ( L + 1 ) ^ ( L + 2 ) ^ ( L + 3 ) ; return Math . Min ( minval , func3 ( L , R , K ) ) ; }
int minimumXor ( int L , int R , int K ) { if ( K > 4 ) return 0 ; else if ( K == 4 ) return func4 ( L , R , K ) ; else if ( K == 3 ) return func3 ( L , R , K ) ; else if ( K == 2 ) return func2 ( L , R , K ) ; else return L ; }
int setBits ( long n ) { int count = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; }
void findNthTerm ( int N ) { int x = setBits ( N ^ ( N - 1 ) ) ; Console . WriteLine ( x ) ; }
void findEquation ( int A , int B , int C ) { Console . Write ( "(" + C + ")" + "x^2 +(" + B + ")x + (" + A + ") = 0" ) ; }
int findMinMoves ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % N != 0 ) return - 1 ; int avg = sum / N ; int total = 0 ; int needCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { needCount += ( arr [ i ] - avg ) ; total = Math . Max ( Math . Max ( Math . Abs ( needCount ) , arr [ i ] - avg ) , total ) ; } return total ; }
string checkPro ( int n , int k ) { double exp = 1.0 / k ; int KthRoot = ( int ) Math . Pow ( n , exp ) ; int product = 1 ; for ( int i = 1 ; i < k + 1 ; i ++ ) { product = product * i ; } if ( product == n ) return "Yes" ; else { for ( int j = 2 ; j < KthRoot + 1 ; j ++ ) { product = product * ( j + k - 1 ) ; product = product / ( j - 1 ) ; if ( product == n ) return "Yes" ; } } return "No" ; }
int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; }
void inorder ( Node root ) { if ( root != null ) { inorder ( root . left ) ; Console . Write ( root . data + " " ) ; inorder ( root . right ) ; } }
void getZarr ( string str , int [ ] Z ) { int n = str . Length ; int k ; int L = 0 ; int R = 0 ; for ( int i = 1 ; i < n ; ++ i ) { if ( i > R ) { L = R = i ; while ( R < n && str [ R - L ] == str [ R ] ) { R ++ ; } Z [ i ] = R - L ; R -- ; } else { k = i - L ; if ( Z [ k ] < R - i + 1 ) { Z [ i ] = Z [ k ] ; } else { L = i ; while ( R < n && str [ R - L ] == str [ R ] ) { R ++ ; } Z [ i ] = R - L ; R -- ; } } } }
string goodStr ( string str , string word ) { string concat = word + "$" + str ; int l = concat . Length ; int [ ] Z = new int [ l ] ; getZarr ( concat , Z ) ; string res = "" ; int pSize = word . Length ; for ( int i = 0 ; i < l ; ++ i ) { if ( i + pSize < l - 1 && Z [ i + pSize + 1 ] == pSize ) { i += pSize - 1 ; } else if ( i < str . Length ) { res += str [ i ] ; } } return res ; }
int findCount0th ( int [ ] arr , int N , int K ) { int oddsum = 0 , evensum = 0 ; for ( int i = 1 ; i < N ; i += 2 ) { oddsum += arr [ i ] ; } for ( int i = 2 ; i < N ; i += 2 ) { evensum += arr [ i ] ; } if ( Math . Abs ( oddsum - evensum ) == K ) return 1 ; else return 0 ; }
int findCount1st ( int [ ] arr , int N , int K ) { int evensum = arr [ 0 ] , oddsum = 0 ; for ( int i = 3 ; i < N ; i += 2 ) { evensum += arr [ i ] ; } for ( int i = 2 ; i < N ; i += 2 ) { oddsum += arr [ i ] ; } if ( Math . Abs ( oddsum - evensum ) == K ) return 1 ; else return 0 ; }
void printDiagonalTraversal ( int [ , ] nums ) { int max_size = nums . GetLength ( 0 ) ; List < List < int > > v = new List < List < int > > ( ) ; for ( int i = 0 ; i < 2 * max_size - 1 ; i ++ ) { v . Add ( new List < int > ( ) ) ; } for ( int i = 0 ; i < nums . GetLength ( 0 ) ; i ++ ) { for ( int j = 0 ; j < nums . GetLength ( 0 ) ; j ++ ) { v [ i + j ] . Add ( nums [ i , j ] ) ; } } for ( int i = 0 ; i < v . Count ; i ++ ) { for ( int j = v [ i ] . Count - 1 ; j >= 0 ; j -- ) { Console . Write ( v [ i ] [ j ] + " " ) ; } } }
void printDiagonalTraversal ( int [ , ] nums ) { int m = nums . GetLength ( 0 ) ; Queue < pair > q = new Queue < pair > ( ) ; q . Enqueue ( new pair ( 0 , 0 ) ) ; while ( q . Count != 0 ) { pair p = q . Peek ( ) ; q . Dequeue ( ) ; Console . Write ( nums [ p . first , p . second ] + " " ) ; if ( p . second == 0 && p . first + 1 < m ) { q . Enqueue ( new pair ( p . first + 1 , p . second ) ) ; } if ( p . second + 1 < nums . GetLength ( 1 ) ) q . Enqueue ( new pair ( p . first , p . second + 1 ) ) ; } }
void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } Console . Write ( A + " " + B ) ; }
void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; Console . Write ( A + " " + B ) ; }
void isValid ( string s ) { int n = ( int ) Math . Sqrt ( s . Length ) ; char check = s [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = i , y = i ; while ( x >= 0 && y < n ) { if ( s [ ( n * x ) + y ] != check || s [ ( n * y ) + x ] != check ) { Console . Write ( "No" ) ; return ; } x -- ; y ++ ; } } Console . Write ( "Yes" ) ; }
void minimumOperations ( string orig_str , int m , int n ) { string orig = orig_str ; int turn = 1 ; int j = 1 ; for ( int i = 0 ; i < orig_str . Length ; i ++ ) { string m_cut = orig_str . Substring ( orig_str . Length - m ) ; orig_str = orig_str . Substring ( 0 , orig_str . Length - m ) ; orig_str = m_cut + orig_str ; j = j + 1 ; if ( ! orig . Equals ( orig_str ) ) { turn = turn + 1 ; String n_cut = orig_str . Substring ( orig_str . Length - n ) ; orig_str = orig_str . Substring ( 0 , orig_str . Length - n ) ; orig_str = n_cut + orig_str ; j = j + 1 ; } if ( orig . Equals ( orig_str ) ) { break ; } turn = turn + 1 ; } Console . WriteLine ( turn ) ; }
int gcd ( int a , int b ) { if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a % b == 0 ) return b ; return gcd ( b , a % b ) ; }
void printAnswer ( int x , int y ) { int val = gcd ( x , y ) ; if ( ( val & ( val - 1 ) ) == 0 ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
int toDigit ( char ch ) { return ( ch - '0' ) ; }
void powerOf10 ( ) { power [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) power [ i ] = power [ i - 1 ] * 10 ; }
void precomputePrefix ( char [ ] str , int n ) { pref [ 0 ] = str [ 0 ] - '0' ; for ( int i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + toDigit ( str [ i ] ) ; }
int triangularNumber ( int i ) { int res = i * ( i + 1 ) / 2 ; return res ; }
void sumOfSubarrayProd ( int [ ] arr , int n ) { int ans = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } Console . WriteLine ( ans ) ; }
int OddLengthSum ( int [ ] arr ) { int sum = 0 ; int l = arr . Length ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j += 2 ) { for ( int k = i ; k <= j ; k ++ ) { sum += arr [ k ] ; } } } return sum ; }
int phi ( int n ) { int result = 1 ; for ( int p = 2 ; p < n ; p ++ ) { if ( __gcd ( p , n ) == 1 ) { result ++ ; } } return result ; }
bool sameEulerTotient ( int n ) { return phi ( n ) == phi ( 2 * n ) ; }
int sameEulerTotient ( int N ) { return ( N & 1 ) ; }
List < int > restore ( int [ ] arr , int N ) { List < int > result = new List < int > ( ) ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) && mp [ arr [ i ] ] == 0 ) { result . Add ( arr [ i ] ) ; if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } else mp . Add ( arr [ i ] , 0 ) ; } return result ; }
void print_result ( List < int > result ) { for ( int i = 0 ; i < result . Count ; i ++ ) Console . Write ( result [ i ] + " " ) ; }
List < int > restore ( int [ ] arr , int N ) { List < int > result = new List < int > ( ) ; int count1 = 1 ; HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { s . Add ( arr [ i ] ) ; if ( s . Count == count1 ) { result . Add ( arr [ i ] ) ; count1 ++ ; } } return result ; }
void print_result ( List < int > result ) { for ( int i = 0 ; i < result . Count ; i ++ ) Console . Write ( result [ i ] + " " ) ; }
bool checkReverseBitonic ( int [ ] arr , int n ) { int i , j , f = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { f = 1 ; break ; } } if ( i == n ) return true ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { if ( f == 1 ) return false ; } } return true ; }
int sum ( int n ) { return n * ( n - 1 ) / 2 ; }
int getFirstSetBitPos ( int n ) { return ( int ) ( Math . Log ( n & - n ) / Math . Log ( 2 ) ) ; }
int oddFirst ( int a , int b ) { int steps_a = getFirstSetBitPos ( a ) ; int steps_b = getFirstSetBitPos ( b ) ; if ( steps_a == steps_b ) { return - 1 ; } else if ( steps_a > steps_b ) { return b ; } else { return a ; } }
int nCycle ( int N ) { return ( N ) * ( N - 1 ) + 1 ; }
int checkReverseBitonic ( String s ) { int i , j ; for ( i = 1 ; i < s . Length ; i ++ ) { if ( s [ i ] < s [ i - 1 ] ) continue ; if ( s [ i ] >= s [ i - 1 ] ) break ; } if ( i == s . Length - 1 ) return 1 ; for ( j = i + 1 ; j < s . Length ; j ++ ) { if ( s [ j ] > s [ j - 1 ] ) continue ; if ( s [ j ] <= s [ j - 1 ] ) break ; } i = j ; if ( i != s . Length ) return 0 ; return 1 ; }
void solve ( long n ) { long s = 0 ; for ( int l = 1 ; l <= n ; ) { int r = ( int ) ( n / ( Math . Floor ( ( double ) n / l ) ) ) ; int x = ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; int y = ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; int p = ( int ) ( ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } Console . Write ( ( s + m ) % m ) ; }
int solve ( int n ) { int i , sum = 0 ; while ( n > 0 ) { i = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; n = n - ( int ) Math . Pow ( 2 , i ) ; sum = sum + ( i + 1 ) + Count ( i - 1 ) ; } return sum ; }
int smallestNum ( int N ) { float x = ( float ) ( Math . Pow ( 10 , ( N - 1 ) / 2.0 ) ) ; return ( int ) ( Math . Ceiling ( x ) ) ; }
int checkBitonic ( char [ ] s ) { int i , j ; for ( i = 1 ; i < s . Length ; i ++ ) { if ( s [ i ] > s [ i - 1 ] ) continue ; if ( s [ i ] <= s [ i - 1 ] ) break ; } if ( i == s . Length - 1 ) return 1 ; for ( j = i + 1 ; j < s . Length ; j ++ ) { if ( s [ j ] < s [ j - 1 ] ) continue ; if ( s [ j ] >= s [ j - 1 ] ) break ; } i = j ; if ( i != s . Length ) return 0 ; return 1 ; }
void findArray ( int [ ] a , int n , int P ) { int mi = a . Min ( ) ; int ctr = 0 ; mi = Math . Max ( 0 , mi - 1 ) ; int i ; for ( i = 0 ; i < n ; i ++ ) { a [ i ] -= mi ; ctr += mi ; } i = P - 1 ; int start = - 1 ; while ( true ) { if ( a [ i ] == 0 ) { start = i ; break ; } a [ i ] -= 1 ; ctr += 1 ; i = ( i - 1 + n ) % n ; } a [ start ] = ctr ; for ( i = 0 ; i < n ; i ++ ) { Console . Write ( a [ i ] + ", " ) ; } }
void checkstateA ( string n ) { if ( n [ 0 ] == '0' ) stateB ( n . Substring ( 1 ) ) ; else stateD ( n . Substring ( 1 ) ) ; }
void stateB ( string n ) { if ( n . Length == 0 ) { Console . Write ( "string not accepted" ) ; } else { if ( n [ 0 ] == '1' ) stateC ( n . Substring ( 1 ) ) ; else stateD ( n . Substring ( 1 ) ) ; } }
void stateD ( string n ) { if ( n . Length == 0 ) Console . Write ( "string not accepted" ) ; else { if ( n [ 0 ] == '1' ) stateD ( n . Substring ( 1 ) ) ; else stateE ( n . Substring ( 1 ) ) ; } }
void stateE ( string n ) { if ( n . Length == 0 ) Console . Write ( "string not accepted" ) ; else { if ( n [ 0 ] == '0' ) stateE ( n . Substring ( 1 ) ) ; else stateF ( n . Substring ( 1 ) ) ; } }
void stateF ( string n ) { if ( n . Length == 0 ) Console . Write ( "string accepted" ) ; else { if ( n [ 0 ] == '1' ) stateD ( n . Substring ( 1 ) ) ; else stateE ( n . Substring ( 1 ) ) ; } }
int HogbenNumber ( int a ) { int p = ( int ) ( Math . Pow ( a , 2 ) - a + 1 ) ; return p ; }
int countKCountdown ( int [ ] arr , int N , int K ) { int flag = - 1 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) flag = K ; if ( arr [ i ] == flag ) flag -- ; else flag = - 1 ; if ( flag == 0 ) count ++ ; } return count ; }
int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; }
Tuple < int , int > count_ht ( char s , int N ) { Tuple < int , int > p = Tuple . Create ( 0 , 0 ) ; if ( s == 'H' ) { p = Tuple . Create ( ( int ) Math . Floor ( N / 2.0 ) , ( int ) Math . Ceiling ( N / 2.0 ) ) ; } else if ( s == 'T' ) { p = Tuple . Create ( ( int ) Math . Ceiling ( N / 2.0 ) , ( int ) Math . Floor ( N / 2.0 ) ) ; } return p ; }
int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
int productinRange ( int l , int r ) { if ( r - l > 9 ) return 0 ; else { int p = 1 ; for ( int i = l ; i <= r ; i ++ ) p *= getProduct ( i ) ; return p ; } }
int checkQwertyRow ( char x ) { char [ ] first_row1 = { '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '0' , '-' , '=' } ; HashSet < char > first_row = new HashSet < char > ( first_row1 ) ; char [ ] second_row1 = { 'Q' , 'W' , 'E' , 'R' , 'T' , 'Y' , 'U' , 'I' , 'O' , 'P' , '[' , ']' , 'q' , 'w' , 'e' , 'r' , 't' , 'y' , 'u' , 'i' , 'o' , 'p' } ; HashSet < char > second_row = new HashSet < char > ( second_row1 ) ; char [ ] third_row1 = { 'A' , 'S' , 'D' , 'F' , 'G' , 'H' , 'J' , 'K' , 'L' , ';' , ':' , 'a' , 's' , 'd' , 'f' , 'g' , 'h' , 'j' , 'k' , 'l' } ; HashSet < char > third_row = new HashSet < char > ( third_row1 ) ; char [ ] fourth_row1 = { 'Z' , 'X' , 'C' , 'V' , 'B' , 'N' , 'M' , ',' , '.' , '/' , 'z' , 'x' , 'c' , 'v' , 'b' , 'n' , 'm' } ; HashSet < char > fourth_row = new HashSet < char > ( fourth_row1 ) ; if ( first_row . Contains ( x ) ) { return 1 ; } else if ( second_row . Contains ( x ) ) { return 2 ; } else if ( third_row . Contains ( x ) ) { return 3 ; } else if ( fourth_row . Contains ( x ) ) { return 4 ; } return 0 ; }
bool checkValidity ( String str ) { char x = str [ 0 ] ; int row = checkQwertyRow ( x ) ; for ( int i = 0 ; i < str . Length ; i ++ ) { x = str [ i ] ; if ( row != checkQwertyRow ( x ) ) { return false ; } } return true ; }
int fib ( long n ) { int f0 = 0 ; int f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { int rem = ( int ) ( n % 60 ) ; if ( rem == 0 ) return 0 ; for ( int i = 2 ; i < rem + 3 ; i ++ ) { int f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } int s = f1 - 1 ; return s ; } }
void sumBetweenZero ( int [ ] arr , int N ) { int i = 0 ; List < int > A = new List < int > ( ) ; int sum = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { i ++ ; break ; } } for ( ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { A . Add ( sum ) ; sum = 0 ; } else { sum += arr [ i ] ; } } for ( int j = 0 ; j < A . Count ; j ++ ) { Console . Write ( A [ j ] + " " ) ; } if ( A . Count == 0 ) Console . Write ( "-1" ) ; }
int nthTerm ( int N ) { if ( N == 1 ) { return 2 ; } return ( ( N - 1 ) * 13 ) + nthTerm ( N - 1 ) ; }
void maximumSubsequence ( int [ ] arr , int N ) { Dictionary < int , int > M = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( M . ContainsKey ( arr [ i ] ) ) { M [ arr [ i ] ] = M [ arr [ i ] ] + 1 ; } else { M . Add ( arr [ i ] , 1 ) ; } } int distinct_size = M . Count ; int maxFreq = 1 ; foreach ( KeyValuePair < int , int > m in M ) { maxFreq = Math . Max ( maxFreq , m . Value ) ; } Console . Write ( Math . Max ( Math . Min ( distinct_size , maxFreq - 1 ) , Math . Min ( distinct_size - 1 , maxFreq ) ) ) ; }
string decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 2 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } string hexCode = "" ; if ( i == 2 ) { hexCode += hexaDeciNum [ 0 ] ; hexCode += hexaDeciNum [ 1 ] ; } else if ( i == 1 ) { hexCode = "0" ; hexCode += hexaDeciNum [ 0 ] ; } else if ( i == 0 ) hexCode = "00" ; return hexCode ; }
string convertRGBtoHex ( int R , int G , int B ) { if ( ( R >= 0 && R <= 255 ) && ( G >= 0 && G <= 255 ) && ( B >= 0 && B <= 255 ) ) { string hexCode = "#" ; hexCode += decToHexa ( R ) ; hexCode += decToHexa ( G ) ; hexCode += decToHexa ( B ) ; return hexCode ; } else return "-1" ; }
bool isKAlternating ( String s , int k ) { if ( s . Length < k ) return false ; int checker = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int bitAtIndex = s [ i ] - 'a' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } for ( int i = k ; i < s . Length ; i ++ ) if ( s [ i - k ] != s [ i ] ) return false ; return true ; }
void findFactors ( int N ) { int temp = ( int ) Math . Sqrt ( N ) ; int [ ] factor = new int [ MAX ] ; for ( int l = 0 ; l < MAX ; l ++ ) factor [ l ] = 1 ; int i , j , k ; int len1 = 1 ; while ( temp % 2 == 0 ) { factor [ len1 ++ ] = 2 ; factor [ len1 ++ ] = 2 ; temp /= 2 ; } for ( j = 3 ; j < Math . Sqrt ( temp ) ; j += 2 ) { while ( temp % j == 0 ) { factor [ len1 ++ ] = j ; factor [ len1 ++ ] = j ; temp /= j ; } } if ( temp > 2 ) { factor [ len1 ++ ] = temp ; factor [ len1 ++ ] = temp ; } int [ , ] M = new int [ len1 , MAX ] ; int tpc = 0 , tpr = 0 ; M [ 0 , 0 ] = 1 ; j = 1 ; while ( j < len1 ) { if ( factor [ j ] != factor [ j - 1 ] ) { tpr ++ ; M [ tpr , 0 ] = factor [ j ] ; j ++ ; tpc = 1 ; } else { M [ tpr , tpc ] = M [ tpr , tpc - 1 ] * factor [ j ] ; j ++ ; tpc ++ ; } } int [ ] arr1 = new int [ MAX ] ; int [ ] arr2 = new int [ MAX ] ; int l1 , l2 ; l1 = l2 = 1 ; arr1 [ 0 ] = arr2 [ 0 ] = 1 ; for ( i = 1 ; i < tpr + 1 ; i ++ ) { for ( j = 0 ; M [ i , j ] != 0 ; j ++ ) { for ( k = 0 ; k < l1 ; k ++ ) { arr2 [ l2 ++ ] = arr1 [ k ] * M [ i , j ] ; } } for ( j = l1 ; j < l2 ; j ++ ) { arr1 [ j ] = arr2 [ j ] ; } l1 = l2 ; } for ( i = 0 ; i < l2 ; i ++ ) { Console . Write ( arr2 [ i ] + " " ) ; } }
int countSubstring ( string S , int n ) { int ans = 0 ; int i = 0 ; while ( i < n ) { int cnt0 = 0 , cnt1 = 0 ; if ( S [ i ] == '0' ) { while ( i < n && S [ i ] == '0' ) { cnt0 ++ ; i ++ ; } int j = i ; while ( j < n && S [ j ] == '1' ) { cnt1 ++ ; j ++ ; } } else { while ( i < n && S [ i ] == '1' ) { cnt1 ++ ; i ++ ; } int j = i ; while ( j < n && S [ j ] == '0' ) { cnt0 ++ ; j ++ ; } } ans += Math . Min ( cnt0 , cnt1 ) ; } return ans ; }
void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { Console . Write ( ( 3 * i * ( i - 1 ) + 1 ) + " " ) ; i ++ ; } }
int [ ] zArray ( int [ ] arr ) { int [ ] z ; int n = arr . Length ; z = new int [ n ] ; int r = 0 , l = 0 ; for ( int k = 1 ; k < n ; k ++ ) { if ( k > r ) { r = l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } else { int k1 = k - l ; if ( z [ k1 ] < r - k + 1 ) z [ k ] = z [ k1 ] ; else { l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } } } return z ; }
int [ ] mergeArray ( int [ ] A , int [ ] B ) { int n = A . Length ; int m = B . Length ; int [ ] z ; int [ ] c = new int [ n + m + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) c [ i ] = B [ i ] ; c [ m ] = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) c [ m + i + 1 ] = A [ i ] ; z = zArray ( c ) ; return z ; }
void findZArray ( int [ ] A , int [ ] B , int n ) { int flag = 0 ; int [ ] z ; z = mergeArray ( A , B ) ; for ( int i = 0 ; i < z . Length ; i ++ ) { if ( z [ i ] == n ) { Console . Write ( ( i - n - 1 ) + " " ) ; flag = 1 ; } } if ( flag == 0 ) { Console . WriteLine ( "Not Found" ) ; } }
void insertNode ( Node root , int x ) { Node p = root , q = null ; while ( p != null ) { q = p ; if ( p . data < x ) { p = p . right ; } else { p = p . left ; } } if ( q == null ) { p = createNode ( x ) ; } else { if ( q . data < x ) { q . right = createNode ( x ) ; } else { q . left = createNode ( x ) ; } } }
int maxelpath ( Node q , int x ) { Node p = q ; int mx = - 1 ; while ( p . data != x ) { if ( p . data > x ) { mx = Math . Max ( mx , p . data ) ; p = p . left ; } else { mx = Math . Max ( mx , p . data ) ; p = p . right ; } } return Math . Max ( mx , x ) ; }
int maximumElement ( Node root , int x , int y ) { Node p = root ; while ( ( x < p . data && y < p . data ) || ( x > p . data && y > p . data ) ) { if ( x < p . data && y < p . data ) { p = p . left ; } else if ( x > p . data && y > p . data ) { p = p . right ; } } return Math . Max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) ; }
void q1 ( string s , int i ) { if ( i == s . Length ) { Console . WriteLine ( "Yes" ) ; return ; } if ( s [ i ] == 'a' ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
void q2 ( string s , int i ) { if ( i == s . Length ) { Console . WriteLine ( "No" ) ; return ; } if ( s [ i ] == 'a' ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
void q4 ( string s , int i ) { if ( i == s . Length ) { Console . WriteLine ( "No" ) ; return ; } if ( s [ i ] == 'a' ) q4 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
void q0 ( string s , int i ) { if ( i == s . Length ) { Console . WriteLine ( "No" ) ; return ; } if ( s [ i ] == 'a' ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
int nthTerm ( int N ) { int nth = 0 , first_term = 4 ; int pi = 1 , po = 1 ; int n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; }
void q1 ( string s , int i ) { Console . Write ( "q1->" ) ; if ( i == s . Length ) { Console . WriteLine ( "NO" ) ; return ; } if ( s [ i ] == '0' ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
void q2 ( string s , int i ) { Console . Write ( "q2->" ) ; if ( i == s . Length ) { Console . WriteLine ( "NO " ) ; return ; } if ( s [ i ] == '0' ) q4 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
void q3 ( string s , int i ) { Console . Write ( "q3->" ) ; if ( i == s . Length ) { Console . WriteLine ( "YES" ) ; return ; } if ( s [ i ] == '0' ) q4 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
void q4 ( string s , int i ) { Console . Write ( "q4->" ) ; if ( i == s . Length ) { Console . WriteLine ( "YES" ) ; return ; } if ( s [ i ] == '0' ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
void q0 ( string s , int i ) { Console . Write ( "q0->" ) ; if ( i == s . Length ) { Console . WriteLine ( "NO" ) ; return ; } if ( s [ i ] == '0' ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
int findSum ( int [ ] arr , int n , int k ) { if ( k <= n - 2 ) return ( arr [ n - 1 ] - arr [ 0 ] ) ; return 0 ; }
int finalNum ( int [ ] arr , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result = __gcd ( result , arr [ i ] ) ; } return result ; }
int maxSubStr ( String str , int n ) { int count0 = 0 , count1 = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) { count0 ++ ; } else { count1 ++ ; } if ( count0 == count1 ) { cnt ++ ; } } if ( cnt == 0 ) { return - 1 ; } return cnt ; }
bool isSatisfied ( char [ ] str , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( ! isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) ) { return false ; } } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) && ! isVowel ( str [ i + 1 ] ) ) { return false ; } } return true ; }
long squareDigitSum ( String s ) { long lengthN = s . Length ; long result = ( lengthN / 9 ) * 81 + ( long ) Math . Pow ( ( lengthN % 9 ) , 2 ) ; return result ; }
int getElement ( int N , int r , int c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } int a = ( r + 1 ) * ( int ) ( Math . Pow ( 2 , ( r - 2 ) ) ) ; int d = ( int ) ( Math . Pow ( 2 , ( r - 1 ) ) ) ; c = c - r ; int element = a + d * c ; return element ; }
void computeLPSArray ( char [ ] pat , int M , int [ ] lps ) { int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } }
void CntSubstr ( char [ ] s , int l ) { int hash = 0 ; for ( int i = 0 ; i < l ; i ++ ) { hash = ( hash * x + ( s [ i ] - 97 ) ) % mod ; } int pow_l = 1 ; for ( int i = 0 ; i < l - 1 ; i ++ ) { pow_l = ( pow_l * x ) % mod ; } HashSet < int > result = new HashSet < int > ( ) ; result . Add ( hash ) ; for ( int i = l ; i < s . Length ; i ++ ) { hash = ( ( hash - pow_l * ( s [ i - l ] - 97 ) + 2 * mod ) * x + ( s [ i ] - 97 ) ) % mod ; result . Add ( hash ) ; } Console . WriteLine ( result . Count ) ; }
int LengthlongestPrefixSuffix ( string s ) { int n = s . Length ; int [ ] lps = new int [ n ] ; lps [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } int res = lps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; }
int no_of_characters ( int M ) { int k = 1 ; while ( true ) { if ( ( int ) Math . Pow ( 2 , k + 1 ) - 2 < M ) k ++ ; else break ; } return k ; }
string updateString ( string S , string A , string B ) { int l = A . Length ; for ( int i = 0 ; i + l <= S . Length ; i ++ ) { string curr = S . Substring ( i , l ) ; if ( curr . Equals ( A ) ) { string new_string = S . Substring ( 0 , i ) + B + S . Substring ( i + l ) ; S = new_string ; i += l - 1 ; } else { string new_string = S . Substring ( 0 , i ) + A + S . Substring ( i + l ) ; S = new_string ; i += l - 1 ; } } return S ; }
int findCount ( string str1 , string str2 ) { int len = str1 . Length ; int len2 = str2 . Length ; int ans = Int32 . MaxValue ; int [ ] hash1 = new int [ 26 ] ; int [ ] hash2 = new int [ 26 ] ; for ( int i = 0 ; i < len ; i ++ ) hash1 [ str1 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < len2 ; i ++ ) hash2 [ str2 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] != 0 ) ans = Math . Min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; }
int getEndingIndex ( string str , int n , int i ) { i ++ ; while ( i < n ) { char curr = str [ i ] ; char prev = str [ i - 1 ] ; if ( ( curr == 'a' && prev == 'z' ) || ( curr - prev == 1 ) ) i ++ ; else break ; } return i - 1 ; }
void printPattern ( int n , int m ) { if ( m > 2 * ( n + 1 ) m < n - 1 ) { Console . Write ( "-1" ) ; } else if ( Math . Abs ( n - m ) <= 1 ) { while ( n > 0 && m > 0 ) { Console . Write ( "01" ) ; n -- ; m -- ; } if ( n != 0 ) { Console . Write ( "0" ) ; } if ( m != 0 ) { Console . Write ( "1" ) ; } } else { while ( m - n > 1 && n > 0 ) { Console . Write ( "110" ) ; m = m - 2 ; n = n - 1 ; } while ( n > 0 ) { Console . Write ( "10" ) ; n -- ; m -- ; } while ( m > 0 ) { Console . Write ( "1" ) ; m -- ; } } }
void printPermutation ( int N , int K ) { ArrayList res = new ArrayList ( ) ; int l = 1 , r = N , flag = 0 ; for ( int i = 0 ; i < K ; i ++ ) { if ( flag == 0 ) { res . Add ( l ) ; l ++ ; } else { res . Add ( r ) ; r -- ; } flag ^= 1 ; } if ( flag != 1 ) { for ( int i = r ; i >= l ; i -- ) { res . Add ( i ) ; } } else { for ( int i = l ; i <= r ; i ++ ) { res . Add ( i ) ; } } foreach ( int i in res ) { Console . Write ( i + " " ) ; } }
bool hasDigit ( Dictionary < int , int > hashMap , int digit ) { if ( hashMap . ContainsKey ( digit ) && hashMap [ digit ] > 0 ) { hashMap [ digit ] = hashMap [ digit ] - 1 ; return true ; } return false ; }
void compute_z ( string s , int [ ] z ) { int l = 0 , r = 0 ; int n = s . Length ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( i > r ) { l = i ; r = i ; while ( r < n && s [ r - l ] == s [ r ] ) { r ++ ; } z [ i ] = r - l ; r -- ; } else { int k = i - l ; if ( z [ k ] < r - i + 1 ) { z [ i ] = z [ k ] ; } else { l = i ; while ( r < n && s [ r - l ] == s [ r ] ) { r ++ ; } z [ i ] = r - l ; r -- ; } } } }
int countPermutation ( string a , string b ) { b = b + b ; b = b . Substring ( 0 , b . Length - 1 ) ; int ans = 0 ; string s = a + "$" + b ; int n = s . Length ; int [ ] z = new int [ n ] ; compute_z ( s , z ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( z [ i ] == a . Length ) { ans ++ ; } } return ans ; }
int countDecreasing ( int [ ] A , int n ) { int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
int doMatch ( String A , String B ) { for ( int i = 0 ; i < A . Length ; i ++ ) { if ( A [ i ] != '*' && B [ i ] != '*' ) if ( A [ i ] != B [ i ] ) return 0 ; } return 1 ; }
bool printRLE ( string str , string typed ) { int n = str . Length , m = typed . Length ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != typed [ j ] ) { return false ; } if ( isVowel ( str [ i ] ) == false ) { j ++ ; continue ; } int count1 = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count1 ++ ; i ++ ; } int count2 = 1 ; while ( j < m - 1 && typed [ j ] == str [ i ] ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) { return false ; } } return true ; }
int minimumChar ( String S1 , String S2 ) { int n = S1 . Length ; int m = S2 . Length ; int ans = Int32 . MaxValue ; for ( int i = 0 ; i < m - n + 1 ; i ++ ) { int minRemovedChar = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( S1 [ j ] != S2 [ i + j ] ) { minRemovedChar ++ ; } } ans = Math . Min ( minRemovedChar , ans ) ; } return ans ; }
int fact ( int N ) { int i , product = 1 ; for ( i = 1 ; i <= N ; i ++ ) product = product * i ; return product ; }
int nthTerm ( int N ) { return ( N * N ) * fact ( N ) ; }
int factorial ( int N ) { int fact = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fact = fact * i ; return fact ; }
int nthTerm ( int N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; }
int factorial ( int N ) { if ( N == 0 N == 1 ) return 1 ; return N * factorial ( N - 1 ) ; }
int nthTerm ( int N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; }
bool check ( String S1 , String S2 ) { int n1 = S1 . Length ; int n2 = S2 . Length ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( mp . ContainsKey ( ( int ) S1 [ i ] ) ) { mp [ ( int ) S1 [ i ] ] = mp [ ( int ) S1 [ i ] ] + 1 ; } else { mp . Add ( ( int ) S1 [ i ] , 1 ) ; } } for ( int i = 0 ; i < n2 ; i ++ ) { if ( mp . ContainsKey ( ( int ) S2 [ i ] ) ) { mp [ ( int ) S2 [ i ] ] = mp [ ( int ) S2 [ i ] ] - 1 ; } else if ( mp . ContainsKey ( S2 [ i ] - 1 ) && mp . ContainsKey ( S2 [ i ] - 2 ) ) { mp [ S2 [ i ] - 1 ] = mp [ S2 [ i ] - 1 ] - 1 ; mp [ S2 [ i ] - 2 ] = mp [ S2 [ i ] - 2 ] - 1 ; } else { return false ; } } return true ; }
void state1 ( char c ) { if ( c == 't' c == 'T' ) dfa = 1 ; else if ( c == 'h' c == 'H' ) dfa = 2 ; else dfa = 0 ; }
void state2 ( char c ) { if ( c == 'e' c == 'E' ) dfa = 3 ; else dfa = 0 ; }
void state3 ( char c ) { if ( c == 't' c == 'T' ) dfa = 1 ; else dfa = 0 ; }
bool isAccepted ( char [ ] str ) { int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( dfa == 0 ) start ( str [ i ] ) ; else if ( dfa == 1 ) state1 ( str [ i ] ) ; else if ( dfa == 2 ) state2 ( str [ i ] ) ; else state3 ( str [ i ] ) ; } return ( dfa != 3 ) ; }
int isSubstring ( string s1 , string s2 ) { int M = s1 . Length ; int N = s2 . Length ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 [ i + j ] != s1 [ j ] ) break ; if ( j == M ) return i ; } return - 1 ; }
int countFreq ( String pat , String txt ) { int M = pat . Length ; int N = txt . Length ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) { break ; } } if ( j == M ) { res ++ ; j = 0 ; } } return res ; }
int countPattern ( string str ) { int len = str . Length ; bool oneSeen = false ; for ( int i = 0 ; i < len ; i ++ ) { char getChar = str [ i ] ; if ( getChar == '1' && oneSeen == true ) { if ( str [ i - 1 ] == '0' ) { count ++ ; } } if ( getChar == '1' && oneSeen == false ) { oneSeen = true ; } if ( getChar != '0' && str [ i ] != '1' ) { oneSeen = false ; } } return count ; }
int patternCount ( String str ) { char last = str [ 0 ] ; int i = 1 , counter = 0 ; while ( i < str . Length ) { if ( str [ i ] == '0' && last == '1' ) { while ( str [ i ] == '0' ) i ++ ; if ( str [ i ] == '1' ) counter ++ ; } last = str [ i ] ; i ++ ; } return counter ; }
int maxPrefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < t . Length ; i ++ ) { if ( count == s . Length ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; }
void translate ( char [ ] str ) { for ( int i = 1 ; i < str . Length ; i ++ ) { if ( str [ i - 1 ] == 'A' && str [ i ] == 'B' ) { str [ i - 1 ] = 'C' ; int j ; for ( j = i ; j < str . Length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ' ; } } return ; }
bool isvalid ( int row , int col , int prevRow , int prevCol ) { return ( row >= 0 ) && ( row < ROW ) && ( col >= 0 ) && ( col < COL ) && ! ( row == prevRow && col == prevCol ) ; }
int getNextState ( char [ ] pat , int M , int state , int x ) { if ( state < M && ( char ) x == pat [ state ] ) { return state + 1 ; } int ns , i ; for ( ns = state ; ns > 0 ; ns -- ) { if ( pat [ ns - 1 ] == ( char ) x ) { for ( i = 0 ; i < ns - 1 ; i ++ ) { if ( pat [ i ] != pat [ state - ns + 1 + i ] ) { break ; } } if ( i == ns - 1 ) { return ns ; } } } return 0 ; }
void calculate ( String ans ) { int [ ] dp = new int [ 26 ] ; for ( int i = 0 ; i < ans . Length ; ++ i ) { dp [ ( int ) ans [ i ] - ( int ) 'A' ] ++ ; } for ( int i = 0 ; i < dp . Length ; ++ i ) { if ( dp [ i ] % 2 == 1 ) { return ; } } if ( max < ans . Length ) { max = ans . Length ; ans1 = ans ; } }
void longestString ( String [ ] arr , int index , String str ) { if ( index == arr . Length ) { return ; } longestString ( arr , index + 1 , str ) ; str += arr [ index ] ; calculate ( str ) ; longestString ( arr , index + 1 , str ) ; }
int countSubstrings ( string str ) { int [ ] freq = new int [ 3 ] ; int count = 0 ; int i = 0 ; for ( int j = 0 ; j < str . Length ; j ++ ) { freq [ str [ j ] - '0' ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str [ i ++ ] - '0' ] -- ; } count += i ; } return count ; }
int minSwaps ( String s ) { int ones = 0 , zeros = 0 ; int N = s . Length ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) ones ++ ; else zeros ++ ; } if ( ( N % 2 == 0 && ones != zeros ) || ( N % 2 == 1 && Math . Abs ( ones - zeros ) != 1 ) ) { return - 1 ; } int ans_1 = 0 ; int j = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) { ans_1 += Math . Abs ( j - i ) ; j += 2 ; } } int ans_0 = 0 ; int k = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '0' ) { ans_0 += Math . Abs ( k - i ) ; k += 2 ; } } if ( N % 2 == 0 ) return Math . Min ( ans_1 , ans_0 ) ; else { if ( ones > zeros ) return ans_1 ; else return ans_0 ; } }
void isOnesGreater ( string S , int N ) { StringBuilder st = new StringBuilder ( S ) ; int cnt0 = 0 ; int cnt1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( st [ i ] == '1' ) cnt1 ++ ; else cnt0 ++ ; } for ( int i = 0 ; i < N ; i ++ ) { if ( st [ i ] == '1' ) { if ( i > 0 && st [ i - 1 ] == '0' ) { st [ i - 1 ] = '_' ; cnt0 -- ; } else if ( i < N && st [ i + 1 ] == '0' ) { st [ i + 1 ] = '_' ; cnt0 -- ; } } } if ( cnt1 > cnt0 ) { Console . WriteLine ( "Yes" ) ; } else { Console . WriteLine ( "No" ) ; } }
string findString ( string [ ] arr , int N ) { string ans = "" ; for ( int i = 0 ; i < N ; i ++ ) { ans += arr [ i ] [ i ] == '0' ? '1' : '0' ; } return ans ; }
int waysToClearString ( string S ) { for ( int i = 0 ; i < 505 ; i ++ ) { for ( int j = 0 ; j < 505 ; j ++ ) dp [ i , j ] = - 1 ; } int n = S . Length ; choose [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= n / 2 ; ++ i ) { choose [ i , 0 ] = 1 ; for ( int j = 1 ; j <= i ; ++ j ) { choose [ i , j ] = ( choose [ i - 1 , j ] + choose [ i - 1 , j - 1 ] ) ; } } return calc ( 0 , n - 1 , S ) ; }
int minFlips ( string str ) { int count = 0 ; if ( str . Length <= 2 ) { return 0 ; } for ( int i = 0 ; i < str . Length - 2 ; ) { if ( str [ i ] == str [ i + 1 ] && str [ i + 2 ] == str [ i + 1 ] ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; }
int findMissingDigit ( string a , string b , string c ) { int w = 1 ; int a_mod_11 = 0 ; for ( int i = a . Length - 1 ; i >= 0 ; i -- ) { a_mod_11 = ( a_mod_11 + w * ( ( int ) a [ i ] - 48 ) ) % 11 ; w = w * - 1 ; } int b_mod_11 = 0 ; w = 1 ; for ( int i = b . Length - 1 ; i >= 0 ; i -- ) { b_mod_11 = ( b_mod_11 + w * ( ( int ) b [ i ] - 48 ) ) % 11 ; w = w * - 1 ; } int c_mod_11 = 0 ; bool xSignIsPositive = true ; w = 1 ; for ( int i = c . Length - 1 ; i >= 0 ; i -- ) { if ( c [ i ] == 'x' ) { xSignIsPositive = ( w == 1 ) ; } else { c_mod_11 = ( c_mod_11 + w * ( ( int ) c [ i ] - '0' ) ) % 11 ; } w = w * - 1 ; } int x = ( ( a_mod_11 * b_mod_11 ) - c_mod_11 ) % 11 ; if ( xSignIsPositive == false ) { x = - x ; } return ( x % 11 + 11 ) % 11 ; }
bool validInsertionstring ( string S1 , string S2 ) { int N = S1 . Length ; int M = S2 . Length ; Stack < char > st = new Stack < char > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { st . Push ( S1 [ i ] ) ; if ( S1 [ i ] == S2 [ M - 1 ] ) { int idx = M - 1 ; while ( idx >= 0 ) { if ( st . Count == 0 ) { return false ; } char c = st . Peek ( ) ; st . Pop ( ) ; if ( c != S2 [ idx ] ) { return false ; } idx -- ; } } } if ( st . Count > 0 ) { return false ; } else { return true ; } }
int lengthNPalindrome ( int N , int K ) { int half = N / 2 ; if ( N % 2 == 1 ) { half += 1 ; } int ans = 1 ; for ( int i = 1 ; i <= half ; i ++ ) { ans *= K ; K -- ; } return ans ; }
int palindromicStrings ( int N , int K ) { if ( N == 1 ) { return K ; } if ( N == 2 ) { return 2 * K ; } int ans = 0 ; ans += ( 2 * K ) ; for ( int i = 3 ; i <= N ; i ++ ) { ans += lengthNPalindrome ( i , K ) ; } return ans ; }
int LCS ( String S , int N , String T , int M , int [ , ] dp ) { if ( N == 0 M == 0 ) return 0 ; if ( dp [ N , M ] != 0 ) return dp [ N , M ] ; if ( S [ N - 1 ] == T [ M - 1 ] ) { return dp [ N , M ] = 1 + LCS ( S , N - 1 , T , M - 1 , dp ) ; } return dp [ N , M ] = Math . Max ( LCS ( S , N - 1 , T , M , dp ) , LCS ( S , N , T , M - 1 , dp ) ) ; }
int maxlength ( String s ) { int n = s . Length , i , j ; int ans = 0 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { if ( s [ i ] == '1' ) { int count = 1 ; for ( j = i + 1 ; j <= n - 1 && s [ j ] == '1' ; j ++ ) count ++ ; ans = Math . Max ( ans , count ) ; } } return ans ; }
int maximumK ( String S ) { int N = S . Length ; int ans = N ; int flag = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) { flag = 1 ; ans = Math . Min ( ans , Math . Max ( i + 1 , N - i - 1 ) ) ; } } if ( flag == 0 ) return 0 ; return ans ; }
void findIfPossible ( int N , string str ) { int countG = 0 , countF = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == 'G' ) countG ++ ; else countF ++ ; } if ( 2 * countF != countG ) { Console . WriteLine ( "NO" ) ; } else { int id = 0 ; bool flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == 'G' ) { countG -- ; id ++ ; } else { countF -- ; id -- ; } if ( id < 0 ) { flag = false ; break ; } if ( countG < countF ) { flag = false ; break ; } } if ( flag ) { Console . WriteLine ( "YES" ) ; } else { Console . WriteLine ( "NO" ) ; } } }
int findComb ( int N , int M ) { int x = fact ( N + 1 ) ; int y = fact ( M ) ; return ( x * y ) ; }
void isPossible ( string str1 , string str2 ) { int [ ] arr = new int [ 256 ] ; Array . Clear ( arr , 0 , 256 ) ; int l1 = str1 . Length ; int l2 = str2 . Length ; int i ; bool possible = true ; for ( i = 0 ; i < l1 ; i ++ ) { arr [ str1 [ i ] ] = 1 ; } for ( i = 0 ; i < l2 ; i ++ ) { if ( str2 [ i ] != ' ' ) { if ( arr [ str2 [ i ] ] == 1 ) continue ; else { possible = false ; break ; } } } if ( possible ) { Console . Write ( "Yes" ) ; } else { Console . Write ( "No" ) ; } }
bool check ( char [ ] S ) { for ( int i = 1 ; i < S . Length ; i ++ ) { if ( S [ i - 1 ] == S [ i ] ) { return false ; } } return true ; }
void findMinimumSwaps ( char [ ] S ) { ansSwaps = int . MaxValue ; minimumSwaps ( S , 0 , 0 ) ; if ( ansSwaps == int . MaxValue ) Console . Write ( "-1" ) ; else Console . Write ( ansSwaps ) ; }
char FindKthChar ( string str , int K , int X ) { char ans = ' ' ; int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { int digit = ( int ) str [ i ] - 48 ; int range = ( int ) Math . Pow ( digit , X ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; }
string convertToHex ( int num ) { string temp = "" ; while ( num != 0 ) { int rem = num % 16 ; char c ; if ( rem < 10 ) { c = ( char ) ( rem + 48 ) ; } else { c = ( char ) ( rem + 87 ) ; } temp = temp + c ; num = num / 16 ; } return temp ; }
int minimumHammingDistance ( string S , int K ) { int n = S . Length ; int [ ] pref = new int [ n ] ; pref [ 0 ] = ( int ) S [ 0 ] - 48 ; for ( int i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + ( ( int ) S [ i ] - 48 ) ; int cnt = pref [ n - 1 ] ; int ans = cnt ; for ( int i = 0 ; i < n - K ; i ++ ) { int value = pref [ i + K - 1 ] - ( i - 1 >= 0 ? pref [ i - 1 ] : 0 ) ; ans = Math . Min ( ans , cnt - value + ( K - value ) ) ; } return ans ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; else if ( n == 2 ) return true ; else if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { if ( n % i == 0 ) return false ; } return true ; }
void checkPermutation ( string s1 , string s2 ) { int [ ] freq = new int [ 26 ] ; foreach ( char ch in s1 . ToCharArray ( ) ) { freq [ ch - 'a' ] -- ; } foreach ( char ch in s2 . ToCharArray ( ) ) { freq [ ch - 'a' ] ++ ; } bool isAllChangesPrime = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) { continue ; } else if ( ! isPrime ( Math . Abs ( freq [ i ] ) ) ) { isAllChangesPrime = false ; break ; } } if ( isAllChangesPrime != false ) { Console . WriteLine ( "Yes" ) ; } else { Console . WriteLine ( "No" ) ; } }
void minimumOperations ( string S , int N ) { int ans = 0 ; int cntOne = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == '0' ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } Console . WriteLine ( ans ) ; }
void differentBitwiseOR ( String s1 , String s2 ) { int n = s1 . Length ; int t00 = 0 , t10 = 0 , t01 = 0 , t11 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == '0' && s2 [ i ] == '0' ) { t00 ++ ; } if ( s1 [ i ] == '1' && s2 [ i ] == '0' ) { t10 ++ ; } if ( s1 [ i ] == '1' && s2 [ i ] == '1' ) { t11 ++ ; } if ( s1 [ i ] == '0' && s2 [ i ] == '1' ) { t01 ++ ; } } int ans = t00 * t10 + t01 * t10 + t00 * t11 ; Console . Write ( ans ) ; }
void RemoveCharacters ( string s ) { string ans = "" ; int [ ] c = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) c [ i ] = 0 ; int pos = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( c [ ( int ) s [ i ] - 97 ] == 0 ) { c [ ( int ) s [ i ] - 97 ] = 1 ; pos = i ; ans += s [ i ] ; } } for ( int i = pos + 1 ; i < s . Length ; i ++ ) { if ( s [ i ] == s [ 0 ] ) { ans += s [ i ] ; break ; } } Console . Write ( ans ) ; }
void changeCharacters ( string S , int N , int K ) { int flag = 1 ; int count = 0 ; Stack < char > st = new Stack < char > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( st . Count == 0 ) { if ( S [ i ] == '0' ) { flag = 0 ; break ; } count = 0 ; st . Push ( S [ i ] ) ; } else { if ( S [ i ] == '0' ) { count ++ ; if ( count == K ) { st . Pop ( ) ; count = 0 ; } } else { count = 0 ; } } } if ( flag == 1 ) Console . Write ( "YES" ) ; else Console . Write ( "NO" ) ; }
int findSubsequence ( string S , char ch ) { int N = S . Length ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ch ) { ans ++ ; ch ++ ; } } return ans ; }
int findMaxSubsequence ( string S ) { int ans = 0 ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { ans = Math . Max ( ans , findSubsequence ( S , ch ) ) ; } return ans ; }
void minOpsToEmptyString ( string s ) { int ans = 0 ; int cn0 = 0 ; int cn1 = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '0' ) { if ( cn1 > 0 ) cn1 -- ; cn0 ++ ; } else { if ( cn0 > 0 ) cn0 -- ; cn1 ++ ; } ans = Math . Max ( ans , Math . Max ( cn0 , cn1 ) ) ; } Console . Write ( ans ) ; }
bool prefixDivisble ( int n ) { int i = 1 ; while ( n > 0 ) { if ( n % i != 0 ) return false ; n = n / 10 ; i ++ ; } return true ; }
bool isPrime ( int num ) { bool flag = false ; if ( num > 1 ) { for ( int i = 2 ; i < num ; i ++ ) { if ( ( num % i ) == 0 ) { flag = true ; break ; } } } if ( flag ) return false ; else return true ; }
int order ( int x ) { int n = 0 ; while ( x != 0 ) { n = n + 1 ; x = x / 10 ; } return n ; }
bool isArmstrong ( int x ) { int n = order ( x ) ; int temp = x ; int sum1 = 0 ; while ( temp != 0 ) { int r = temp % 10 ; sum1 = sum1 + ( int ) ( Math . Pow ( r , n ) ) ; temp = temp / 10 ; } return ( sum1 == x ) ; }
int count_armstrong ( string [ ] li ) { int c = 0 ; foreach ( string ele in li ) { int val = 0 ; foreach ( char che in ele ) val += che ; if ( isArmstrong ( val ) ) c += 1 ; } return c ; }
int count_prime ( string [ ] li ) { int c = 0 ; foreach ( string ele in li ) { int val = 0 ; foreach ( char che in ele ) val += che ; if ( isPrime ( val ) ) c += 1 ; } return c ; }
void findMinimumCost ( String s , int N ) { int count_1 = 0 , count_0 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) count_1 ++ ; else count_0 ++ ; } int k = Math . Abs ( count_0 - count_1 ) ; if ( count_1 == N count_0 == N ) Console . WriteLine ( - 1 ) ; else Console . WriteLine ( k / 2 ) ; }
void countOccurrences ( string S , string X , string Y ) { int count = 0 ; int N = S . Length , A = X . Length ; int B = Y . Length ; int P = Math . Min ( A , Math . Min ( N , B ) ) ; for ( int i = 0 ; i < N - P + 1 ; i ++ ) { if ( S . Substring ( i , Math . Min ( N , B ) ) . Equals ( Y ) ) count ++ ; if ( S . Substring ( i , Math . Min ( N , A ) ) . Equals ( X ) ) Console . Write ( count + " " ) ; } }
int findLength ( String str , int n ) { int [ ] pre = new int [ n ] ; int [ ] post = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { pre [ i ] = 0 ; post [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 ) { pre [ i ] += pre [ i - 1 ] ; } if ( str [ i ] == '1' ) { pre [ i ] += 1 ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i != n - 1 ) post [ i ] += post [ i + 1 ] ; if ( str [ i ] == '0' ) post [ i ] += 1 ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . Max ( ans , pre [ i ] + post [ i ] ) ; } return ans ; }
int countSubstring ( String S , int N ) { Dictionary < int , int > prevSum = new Dictionary < int , int > ( ) ; int res = 0 ; int currentSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] >= 'A' && S [ i ] <= 'Z' ) { currentSum ++ ; } else currentSum -- ; if ( currentSum == 0 ) res ++ ; if ( prevSum . ContainsKey ( currentSum ) ) { res += prevSum [ currentSum ] ; prevSum [ currentSum ] = prevSum [ currentSum ] + 1 ; } else prevSum . Add ( currentSum , 1 ) ; } return res ; }
void checkforSubsequence ( String S , String target ) { Stack < char > s = new Stack < char > ( ) ; for ( int i = 0 ; i < target . Length ; i ++ ) { s . Push ( target [ i ] ) ; } for ( int i = ( int ) S . Length - 1 ; i >= 0 ; i -- ) { if ( s . Count == 0 ) { Console . WriteLine ( "Yes" ) ; return ; } if ( S [ i ] == s . Peek ( ) ) { s . Pop ( ) ; } } if ( s . Count == 0 ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
void makeDFA ( ) { dfa [ 0 , 0 ] = 1 ; dfa [ 1 , 0 ] = 1 ; dfa [ 1 , 2 ] = 3 ; dfa [ 1 , 3 ] = 2 ; dfa [ 1 , 4 ] = 6 ; dfa [ 3 , 0 ] = 4 ; dfa [ 4 , 0 ] = 4 ; dfa [ 4 , 3 ] = 5 ; dfa [ 4 , 4 ] = 6 ; dfa [ 6 , 0 ] = 8 ; dfa [ 6 , 1 ] = 7 ; dfa [ 7 , 0 ] = 8 ; dfa [ 8 , 0 ] = 8 ; dfa [ 8 , 3 ] = 9 ; }
void buildDFA ( ) { for ( int i = 0 ; i < 11 ; i ++ ) for ( int j = 0 ; j < 5 ; j ++ ) dfa [ i , j ] = 10 ; makeDFA ( ) ; }
void checkDFA ( string s ) { buildDFA ( ) ; int currentstate = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( digits . IndexOf ( s [ i ] ) != - 1 ) currentstate = dfa [ currentstate , 0 ] ; else if ( sign . IndexOf ( s [ i ] ) != - 1 ) currentstate = dfa [ currentstate , 1 ] ; else if ( dot . IndexOf ( s [ i ] ) != - 1 ) currentstate = dfa [ currentstate , 2 ] ; else if ( ex . IndexOf ( s [ i ] ) != - 1 ) currentstate = dfa [ currentstate , 4 ] ; else currentstate = dfa [ currentstate , 3 ] ; } if ( currentstate == 1 currentstate == 4 currentstate == 8 ) { Console . WriteLine ( "Unsigned integer" ) ; } else { Console . WriteLine ( "Not an unsigned integer" ) ; } }
string getString ( int N ) { string ans = "" ; while ( N >= 26 ) { ans += 'z' ; N -= 26 ; } ans += ( char ) ( N + 'a' - 1 ) ; return ans ; }
int subString ( string s , int n ) { Dictionary < int , int > hash = new Dictionary < int , int > ( ) ; hash [ 0 ] = 1 ; int pre = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { pre ^= ( 1 << ( int ) ( s [ i ] ) - 97 ) ; if ( hash . ContainsKey ( pre ) ) count += hash [ pre ] ; else count += 0 ; if ( hash . ContainsKey ( pre ) ) hash [ pre ] = hash [ pre ] + 1 ; else hash . Add ( pre , 1 ) ; } return count ; }
void countSamePrefixSuffix ( string s , int n ) { string prefix = "" ; for ( int i = 0 ; i < n - 1 ; i ++ ) { prefix += s [ i ] ; string suffix = s . Substring ( n - 1 - i , i + 1 ) ; if ( prefix == suffix ) { Console . Write ( prefix . Length + " " ) ; } } }
void atleastkDistinctChars ( string s , int k ) { int n = s . Length ; Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; int begin = 0 , end = 0 ; int ans = 0 ; while ( end < n ) { char c = s [ end ] ; if ( mp . ContainsKey ( c ) ) mp ++ ; else mp . Add ( c , 1 ) ; end ++ ; while ( mp . Count >= k ) { char pre = s [ begin ] ; mp [ pre ] -- ; if ( mp [ pre ] == 0 ) { mp . Remove ( pre ) ; } ans += s . Length - end + 1 ; begin ++ ; } } Console . Write ( ans ) ; }
void minimumMoves ( string s , int n , int k ) { if ( n % 2 == 1 ) { Console . WriteLine ( "No" ) ; return ; } int countOpen = 0 , countClose = 0 ; foreach ( char ch in s . ToCharArray ( ) ) if ( ch == '(' ) countOpen ++ ; else if ( ch == ')' ) countClose ++ ; if ( countOpen != countClose ) { Console . WriteLine ( "No" ) ; return ; } int ans = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == '(' ) ++ cnt ; else { -- cnt ; if ( cnt < 0 ) { cnt = 0 ; ++ ans ; } } } if ( ans <= k ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
void inOrder ( Node root ) { if ( root == null ) { return ; } Node cur = leftMost ( root ) ; while ( cur != null ) { Console . Write ( cur . key + " " ) ; if ( cur . isThreaded ) { cur = cur . right ; } else { cur = leftMost ( cur . right ) ; } } }
void countFrequency ( string S , int N ) { int [ ] freq = new int [ 26 ] ; Array . Clear ( freq , 0 , freq . Length ) ; for ( int i = 0 ; i < N ; i ++ ) { freq [ ( int ) S [ i ] - 'a' ] += 1 ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) continue ; int lg = ( int ) Math . Log ( ( double ) freq [ i ] , 2.0 ) ; int a = ( int ) Math . Pow ( 2 , lg ) ; if ( a == freq [ i ] ) { while ( freq [ i ] > 0 ) { freq [ i ] -= 1 ; Console . Write ( ( char ) ( i + 'a' ) ) ; } } } }
void buildTree ( char [ ] s , treeNode [ ] tree , int start , int end , int treenode ) { if ( start == end ) { tree [ treenode ] . square_sum = ( int ) Math . Pow ( s [ start ] - 'a' + 1 , 2 ) ; return ; } int mid = start + ( ( end - start ) / 2 ) ; buildTree ( s , tree , start , mid , 2 * treenode ) ; buildTree ( s , tree , mid + 1 , end , 1 + 2 * treenode ) ; tree [ treenode ] . square_sum = tree [ ( 2 * treenode ) ] . square_sum + tree [ ( 2 * treenode ) + 1 ] . square_sum ; }
int querySquareSum ( treeNode [ ] tree , int start , int end , int treenode , int l , int r ) { if ( ( l > end ) || ( r < start ) ) { return 0 ; } if ( ( l <= start ) && ( r >= end ) ) { return tree [ treenode ] . square_sum ; } int mid = start + ( ( end - start ) / 2 ) ; int X = querySquareSum ( tree , start , mid , 2 * treenode , l , r ) ; int Y = + querySquareSum ( tree , mid + 1 , end , 1 + 2 * treenode , l , r ) ; return X + Y ; }
void canSplit ( string S ) { int [ ] frequency = new int [ 26 ] ; int cnt_singles = 0 ; int k = 0 ; for ( int i = 0 ; i < S . Length ; i ++ ) frequency [ S [ i ] - 'a' ] ++ ; int odd = 0 , eve = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] != 0 ) { odd += ( frequency [ i ] & 1 ) ; eve += frequency [ i ] / 2 ; } } if ( eve >= odd ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
string isPossible ( string S , int R , int N ) { int cntl = 0 , cntr = 0 ; int cntu = 0 , cntd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == 'L' ) cntl ++ ; else if ( S [ i ] == 'R' ) cntr ++ ; else if ( S [ i ] == 'U' ) cntu ++ ; else cntd ++ ; } if ( Math . Max ( Math . Max ( cntl , cntr ) , Math . Max ( cntu , cntd ) ) >= R ) return "Yes" ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int r_square = R * R ; for ( int i = 1 ; i * i <= r_square ; i ++ ) { mp . Add ( i * i , i ) ; if ( mp . ContainsKey ( r_square - i * i ) ) { if ( Math . Max ( cntl , cntr ) >= mp [ r_square - i * i ] && Math . Max ( cntu , cntd ) >= i ) return "Yes" ; if ( Math . Max ( cntl , cntr ) >= i && Math . Max ( cntu , cntd ) >= mp [ r_square - i * i ] ) return "Yes" ; } } return "No" ; }
void inorder ( Node root ) { Boolean leftdone = false ; while ( root != null ) { if ( ! leftdone ) { while ( root . left != null ) { root = root . left ; } } Console . Write ( root . key + " " ) ; leftdone = true ; if ( root . right != null ) { leftdone = false ; root = root . right ; } else if ( root . parent != null ) { while ( root . parent != null && root == root . parent . right ) root = root . parent ; if ( root . parent == null ) break ; root = root . parent ; } else break ; } }
int findDuplicate ( int [ ] arr , int n , int k ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { Console . WriteLine ( "Out of range" ) ; return - 1 ; } freq [ arr [ i ] ] += 1 ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == k ) return i ; } return - 1 ; }
void nearestPowerOfTwo ( string S ) { int N = S . Length ; Dictionary < char , int > freq = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . ContainsKey ( S [ i ] ) ) freq [ S [ i ] ] += 1 ; else freq [ S [ i ] ] = 1 ; } nearestPowerOfTwoUtil ( freq ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; }
int canMakeSame ( string s1 , string s2 ) { int ans = 0 ; if ( s1 . Length != s2 . Length ) { return - 1 ; } int N = s1 . Length ; for ( int i = 0 ; i < N ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { while ( i < s1 . Length && s1 [ i ] != s2 [ i ] ) { i ++ ; } ans ++ ; } } return ans ; }
void printSorted ( int [ ] arr , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; Console . Write ( arr [ start ] + " " ) ; printSorted ( arr , start * 2 + 2 , end ) ; }
int minDeletions ( string str ) { int [ ] fre = new int [ 26 ] ; int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) { fre [ str [ i ] - 'a' ] += 1 ; } int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( fre [ i ] % 2 == 1 ) { count += 1 ; } } if ( count == 0 count == 1 ) { return 0 ; } else { return count - 1 ; } }
void countTotalFrequencies ( string S1 , string S2 ) { HashSet < char > bset = new HashSet < char > ( ) ; foreach ( char x in S1 ) bset . Add ( x ) ; int count = 0 ; foreach ( char x in S2 ) { if ( bset . Contains ( x ) ) count += 1 ; } Console . Write ( count ) ; }
void min_length ( string str ) { int n = str . Length ; int total_zeros = 0 ; int total_ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) { total_zeros ++ ; } else { total_ones ++ ; } } int ans = Math . Min ( total_zeros , total_ones ) ; int cur_zeros = 0 , cur_ones = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { char x = str [ i ] ; if ( x == '0' ) { cur_zeros ++ ; } else { cur_ones ++ ; } ans = Math . Min ( ans , cur_ones + ( total_zeros - cur_zeros ) ) ; } Console . WriteLine ( ans ) ; }
void findWinner ( string a , int n ) { List < int > v = new List < int > ( ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == '0' ) { c ++ ; } else { if ( c != 0 ) v . Add ( c ) ; c = 0 ; } } if ( c != 0 ) v . Add ( c ) ; if ( v . Count == 0 ) { Console . Write ( "Player B" ) ; return ; } if ( v . Count == 1 ) { if ( ( v [ 0 ] & 1 ) != 0 ) Console . Write ( "Player A" ) ; else Console . Write ( "Player B" ) ; return ; } int first = Int32 . MinValue ; int second = Int32 . MinValue ; for ( int i = 0 ; i < v . Count ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } if ( ( first & 1 ) != 0 && ( first + 1 ) / 2 > second ) Console . Write ( "Player A" ) ; else Console . Write ( "Player B" ) ; }
int minimumSwaps ( string s , int l , int r , int k ) { int n = s . Length ; int tot_ones = 0 , tot_zeros = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '1' ) tot_ones ++ ; else tot_zeros ++ ; } int ones = 0 , zeros = 0 , sum = 0 ; for ( int i = l - 1 ; i < r ; i ++ ) { if ( s [ i ] == '1' ) { ones ++ ; sum ++ ; } else zeros ++ ; } int rem_ones = tot_ones - ones ; int rem_zeros = tot_zeros - zeros ; if ( k >= sum ) { int rem = k - sum ; if ( zeros >= rem && rem_ones >= rem ) return rem ; } else if ( k < sum ) { int rem = sum - k ; if ( ones >= rem && rem_zeros >= rem ) return rem ; } return - 1 ; }
bool longHelper ( int [ ] freq1 , int [ ] freq2 ) { for ( int i = 0 ; i < SIZE ; ++ i ) { if ( freq1 [ i ] != freq2 [ i ] ) { return false ; } } return true ; }
void longCommomPrefixAnagram ( string s1 , string s2 , int n1 , int n2 ) { int [ ] freq1 = new int [ 26 ] ; int [ ] freq2 = new int [ 26 ] ; int ans = 0 ; int mini_len = Math . Min ( n1 , n2 ) ; for ( int i = 0 ; i < mini_len ; ++ i ) { freq1 [ s1 [ i ] - 'a' ] ++ ; freq2 [ s2 [ i ] - 'a' ] ++ ; if ( longHelper ( freq1 , freq2 ) ) { ans = i + 1 ; } } Console . Write ( ans ) ; }
void getMin ( int [ ] arr ) { int minSum = Int32 . MaxValue ; for ( int i = 0 ; i < 10 ; i ++ ) { int curSum = 0 ; foreach ( int num in arr ) curSum += remove ( num , i ) ; minSum = Math . Min ( minSum , curSum ) ; } Console . WriteLine ( minSum ) ; }
bool isReducible ( string str ) { int N = str . Length ; List < char > s = new List < char > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == '1' ) s . Add ( str [ i ] ) ; else if ( s . Count > 0 ) s . RemoveAt ( s . Count - 1 ) ; else return false ; } if ( s . Count == 0 ) { return true ; } else { return false ; } }
bool checkPalindrome ( String s ) { int low = 0 , high = ( int ) s . Length - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; }
void populateNumber ( ) { Ans [ index ++ ] = ( 2 ) ; Ans [ index ++ ] = ( 5 ) ; long x = 5 ; long inf = 1000000000001L ; while ( x < inf ) { x *= 2 ; Ans [ index ++ ] = ( x ) ; x = x * 2 + 1 ; Ans [ index ++ ] = ( x ) ; } }
void checkString ( int N ) { populateNumber ( ) ; for ( int i = 0 ; i < index ; i ++ ) { if ( Ans [ i ] == N ) { Console . WriteLine ( "YES" ) ; return ; } } Console . WriteLine ( "NO" ) ; }
void DFA ( string str , int N ) { if ( N <= 1 ) { Console . Write ( "No" ) ; return ; } int count = 0 ; if ( str [ 0 ] == 'C' ) { count ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( str [ i ] == 'A' str [ i ] == 'B' ) count ++ ; else break ; } } else { Console . Write ( "No" ) ; return ; } if ( count == N ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
bool balanced ( int [ ] small , int [ ] caps ) { for ( int i = 0 ; i < 26 ; i ++ ) { if ( small [ i ] != 0 && ( caps [ i ] == 0 ) ) return false ; else if ( ( small [ i ] == 0 ) && ( caps [ i ] != 0 ) ) return false ; } return true ; }
int GCD ( int lena , int lenb ) { if ( lena == 0 ) return lenb ; if ( lenb == 0 ) return lena ; if ( lena == lenb ) return lena ; if ( lena > lenb ) return GCD ( lena - lenb , lenb ) ; return GCD ( lena , lenb - lena ) ; }
void cntBalancedParenthesis ( String s , int N ) { int cntPairs = 0 ; int cntCurly = 0 ; int cntSml = 0 ; int cntSqr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '{' ) { cntCurly ++ ; } else if ( s [ i ] == '(' ) { cntSml ++ ; } else if ( s [ i ] == '[' ) { cntSqr ++ ; } else if ( s [ i ] == '}' && cntCurly > 0 ) { cntCurly -- ; cntPairs ++ ; } else if ( s [ i ] == ')' && cntSml > 0 ) { cntSml -- ; cntPairs ++ ; } else if ( s [ i ] == ']' && cntSqr > 0 ) { cntSqr -- ; cntPairs ++ ; } } Console . WriteLine ( cntPairs ) ; }
bool canBeBalanced ( String sequence ) { if ( sequence . Length % 2 == 1 ) return false ; Stack < char > stack_ = new Stack < char > ( ) ; Stack < char > stack2_ = new Stack < char > ( ) ; int countOpen = 0 , countClosed = 0 ; int countSymbol = 0 ; for ( int i = 0 ; i < sequence . Length ; i ++ ) { if ( sequence [ i ] == ')' ) { countClosed ++ ; if ( stack_ . Count == 0 ) { return false ; } else { stack_ . Pop ( ) ; } } else { if ( sequence [ i ] == '$' ) { countSymbol ++ ; } else { countOpen ++ ; } stack_ . Push ( sequence [ i ] ) ; } } for ( int i = sequence . Length - 1 ; i >= 0 ; i -- ) { if ( sequence [ i ] == '(' ) { if ( stack2_ . Count == 0 ) { return false ; } else { stack2_ . Pop ( ) ; } } else { stack2_ . Push ( sequence [ i ] ) ; } } int extra = Math . Abs ( countClosed - countOpen ) ; if ( countSymbol < extra ) { return false ; } else { countSymbol -= extra ; if ( countSymbol % 2 == 0 ) { return true ; } } return false ; }
void maximum_pallindromic ( int [ ] arr ) { int res = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { res += arr [ i ] / 3 ; arr [ i ] = arr [ i ] % 3 ; if ( arr [ i ] == 1 ) c1 ++ ; else if ( arr [ i ] == 2 ) c2 ++ ; } res += Math . Min ( c1 , c2 ) ; int t = Math . Min ( c1 , c2 ) ; c1 -= t ; c2 -= t ; res += 2 * ( c2 / 3 ) ; c2 %= 3 ; res += c2 / 2 ; Console . Write ( res ) ; }
void inorder ( node root ) { if ( root != null ) { inorder ( root . left ) ; Console . Write ( root . key + "(" + root . count + ") " ) ; inorder ( root . right ) ; } }
int query ( int [ , ] BIT , int idx , int i ) { int ans = 0 ; while ( i > 0 ) { ans += BIT [ idx , i ] ; i = i - ( i & ( - i ) ) ; } return ans ; }
int minOperation ( String [ ] arr , int N ) { int cntMinOP = 0 ; int M = arr [ 0 ] . Length ; int [ , ] hash = new int [ 256 , M ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { hash [ arr [ i ] [ j ] , j ] ++ ; } } for ( int i = 0 ; i < M ; i ++ ) { int Sum = 0 ; int Max = 0 ; for ( int j = 0 ; j < 256 ; j ++ ) { Sum += hash [ j , i ] ; Max = Math . Max ( Max , hash [ j , i ] ) ; } cntMinOP += ( Sum - Max ) ; } return cntMinOP ; }
void find_Winner ( String [ ] arr , int N ) { List < char > [ ] Q = new List < char > [ N ] ; for ( int i = 0 ; i < Q . Length ; i ++ ) Q [ i ] = new List < char > ( ) ; int M = arr . Length ; for ( int i = 0 ; i < M ; i ++ ) { int len = arr [ i ] . Length ; for ( int j = 0 ; j < len ; j ++ ) { Q [ i ] . Add ( arr [ i ] [ j ] ) ; } } int player = 0 ; while ( Q [ player ] . Count > 0 ) { int nextPlayer = Q [ player ] [ 0 ] - '0' - 1 ; Q [ player ] . RemoveAt ( 0 ) ; player = nextPlayer ; } Console . Write ( "Player " + ( player + 1 ) ) ; }
int longestSubstring ( string s ) { int [ ] dp = new int [ 1024 ] ; for ( int i = 0 ; i < 1024 ; ++ i ) { dp [ i ] = s . Length ; } int res = 0 , mask = 0 ; dp [ 0 ] = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { mask = mask ^ ( 1 << ( s [ i ] - '0' ) ) ; res = Math . Max ( res , i - dp [ mask ] ) ; for ( int j = 0 ; j < 10 ; j ++ ) { res = Math . Max ( res , i - dp [ mask ^ ( 1 << j ) ] ) ; } dp [ mask ] = Math . Min ( dp [ mask ] , i ) ; } return res ; }
int countStrings ( String S , String [ ] list ) { HashSet < char > valid = new HashSet < char > ( ) ; foreach ( char x in S . ToCharArray ( ) ) { valid . Add ( x ) ; } int cnt = 0 ; for ( int i = 0 ; i < list . Length ; i ++ ) { int j = 0 ; for ( j = 0 ; j < list [ i ] . Length ; j ++ ) { if ( valid . Contains ( list [ i ] [ j ] ) ) continue ; else break ; } if ( j == list [ i ] . Length ) cnt ++ ; } return cnt ; }
void inorder ( node root ) { if ( root != null ) { inorder ( root . left ) ; Console . Write ( root . key + " " ) ; inorder ( root . right ) ; } }
void countStrings ( String s , int k ) { int ans = 1 ; int len = s . Length ; int flag = 0 ; int start_ind = 0 ; for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( s [ i ] - '0' + s [ i + 1 ] - '0' == k && flag == 0 ) { flag = 1 ; start_ind = i ; } if ( flag == 1 && s [ i ] - '0' + s [ i + 1 ] - '0' != k ) { flag = 0 ; if ( ( i - start_ind + 1 ) % 2 != 0 ) ans *= ( i - start_ind + 1 - 1 ) / 2 + 1 ; } } if ( flag == 1 && ( len - start_ind ) % 2 != 0 ) ans *= ( len - start_ind ) / 2 + 1 ; Console . WriteLine ( ans ) ; }
int minLength ( String str , int N , String K , int M ) { Stack < char > stackOfChar = new Stack < char > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { stackOfChar . Push ( str [ i ] ) ; if ( stackOfChar . Count >= M ) { String l = "" ; for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( K [ j ] != stackOfChar . Peek ( ) ) { int f = 0 ; while ( f != l . Length ) { stackOfChar . Push ( l [ f ] ) ; f ++ ; } break ; } else { l = stackOfChar . Peek ( ) + l ; stackOfChar . Pop ( ) ; } } } } return stackOfChar . Count ; }
void printSequences ( SortedSet < String > combinations ) { foreach ( String s in combinations ) { Console . Write ( s + " " ) ; } }
void generateCombinations ( String s , int n ) { for ( int i = 0 ; i < s . Length ; i ++ ) { combination += ( s [ i ] ) ; long x = Int32 . Parse ( combination ) ; if ( x <= n ) { combinations . Add ( combination ) ; generateCombinations ( s , n ) ; } combination = combination . Substring ( 0 , combination . Length - 1 ) ; } }
int compute_hash ( string str ) { int p = 31 ; int MOD = ( int ) 1e9 + 7 ; int hash_val = 0 ; int mul = 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) { char ch = str [ i ] ; hash_val = ( hash_val + ( ch - 'a' + 1 ) * mul ) % MOD ; mul = ( mul * p ) % MOD ; } return hash_val ; }
int distinct_str ( string [ ] arr , int n ) { int [ ] hash = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ i ] = compute_hash ( arr [ i ] ) ; } Array . Sort ( hash ) ; int cntElem = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( hash [ i ] != hash [ i - 1 ] ) { cntElem ++ ; } } return cntElem ; }
bool isEqualStrings ( string [ ] arr , int N ) { int M = arr [ 0 ] . Length ; int [ ] cntFreq = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { cntFreq [ i ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { cntFreq [ arr [ i ] [ j ] - 'a' ] += 1 ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( cntFreq [ i ] % N != 0 ) { return false ; } } return true ; }
void minimumOperations ( string s , int n ) { Dictionary < char , List < int > > mp = new Dictionary < char , List < int > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( s [ i ] ) ) { mp [ s [ i ] ] . Add ( i ) ; } else { mp [ s [ i ] ] = new List < int > ( ) ; mp [ s [ i ] ] . Add ( i ) ; } } int ans = Int32 . MaxValue ; foreach ( KeyValuePair < char , List < int > > x in mp ) { int curr = 0 ; int prev = 0 ; bool first = true ; foreach ( int index in ( x . Value ) ) { if ( first ) { if ( index > 0 ) { curr ++ ; } prev = index ; first = false ; } else { if ( index != prev + 1 ) { curr ++ ; } prev = index ; } } if ( prev != n - 1 ) { curr ++ ; } ans = Math . Min ( ans , curr ) ; } Console . Write ( ans ) ; }
void PrintStack ( Stack < char > s ) { if ( s . Count == 0 ) return ; char x = s . Peek ( ) ; s . Pop ( ) ; PrintStack ( s ) ; Console . Write ( ( char ) x ) ; s . Push ( x ) ; }
void minString ( String s ) { Stack < char > Stack = new Stack < char > ( ) ; Stack . Push ( s [ 0 ] ) ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( Stack . Count == 0 ) { Stack . Push ( s [ i ] ) ; } else { if ( Stack . Peek ( ) == s [ i ] ) { Stack . Pop ( ) ; } else { Stack . Push ( s [ i ] ) ; } } } PrintStack ( Stack ) ; }
void SieveOfEratosthenes ( bool [ ] prime , int n ) { for ( int i = 0 ; i <= n ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = 2 ; i * j <= n ; j ++ ) { prime [ i * j ] = false ; } } } }
void removePrimeFrequencies ( char [ ] s ) { int n = s . Length ; bool [ ] prime = new bool [ n + 1 ] ; SieveOfEratosthenes ( prime , n ) ; Dictionary < char , int > m = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( m . ContainsKey ( s [ i ] ) ) { m [ s [ i ] ] ++ ; } else { m . Add ( s [ i ] , 1 ) ; } } String new_String = "" ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( prime [ m [ s [ i ] ] ] ) continue ; new_String += s [ i ] ; } Console . Write ( new_String ) ; }
void minMaxDigits ( string str , int N ) { int [ ] arr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = ( str [ i ] - '0' ) % 3 ; int zero = 0 , one = 0 , two = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero ++ ; if ( arr [ i ] == 1 ) one ++ ; if ( arr [ i ] == 2 ) two ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum = ( sum + arr [ i ] ) % 3 ; } if ( sum == 0 ) { Console . Write ( 0 + " " ) ; } if ( sum == 1 ) { if ( ( one != 0 ) && ( N > 1 ) ) Console . Write ( 1 + " " ) ; else if ( two > 1 && N > 2 ) Console . Write ( 2 + " " ) ; else Console . Write ( - 1 + " " ) ; } if ( sum == 2 ) { if ( two != 0 && N > 1 ) Console . Write ( 1 + " " ) ; else if ( one > 1 && N > 2 ) Console . Write ( 2 + " " ) ; else Console . Write ( - 1 + " " ) ; } if ( zero > 0 ) Console . Write ( N - 1 + " " ) ; else if ( one > 0 && two > 0 ) Console . Write ( N - 2 + " " ) ; else if ( one > 2 two > 2 ) Console . Write ( N - 3 + " " ) ; else Console . Write ( - 1 + " " ) ; }
void findDisStr ( List < string > arr , int N ) { HashSet < string > DistString = new HashSet < string > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! DistString . Contains ( arr [ i ] ) ) { DistString . Add ( arr [ i ] ) ; } } foreach ( string a in DistString ) { Console . Write ( a + " " ) ; } }
int count_of_accident ( String a , String b ) { int n = a . Length , m = b . Length ; if ( n > m ) return ( m * ( m + 1 ) ) / 2 ; else return ( n * ( n + 1 ) ) / 2 + ( m - n ) * n ; }
double count_of_collision ( String a , String b ) { int n = a . Length , m = b . Length ; double answer = 0 ; int count_of_truck_in_lane_b = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] == 'T' ) count_of_truck_in_lane_b ++ ; for ( int i = 0 ; i < n && i < m ; i ++ ) { if ( a [ i ] == 'T' ) answer += count_of_truck_in_lane_b ; if ( b [ i ] == 'T' ) count_of_truck_in_lane_b -- ; } return answer ; }
int arcIntersection ( String S , int len ) { Stack < char > stk = new Stack < char > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { stk . Push ( S [ i ] ) ; if ( stk . Count >= 2 ) { char temp = stk . Peek ( ) ; stk . Pop ( ) ; if ( stk . Peek ( ) == temp ) { stk . Pop ( ) ; } else { stk . Push ( temp ) ; } } } if ( stk . Count == 0 ) return 1 ; return 0 ; }
int findMinimumChanges ( int N , int K , char [ ] S ) { int ans = 0 ; for ( int i = 0 ; i < ( K + 1 ) / 2 ; i ++ ) { Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; for ( int j = i ; j < N ; j += K ) { if ( mp . ContainsKey ( S [ j ] ) ) { mp [ S [ j ] ] ++ ; } else { mp . Add ( S [ j ] , 1 ) ; } } for ( int j = N - i - 1 ; j >= 0 ; j -= K ) { if ( K % 2 == 1 && i == K / 2 ) break ; if ( mp . ContainsKey ( S [ j ] ) ) { mp [ S [ j ] ] ++ ; } else { mp . Add ( S [ j ] , 1 ) ; } } int curr_max = int . MinValue ; foreach ( KeyValuePair < char , int > p in mp ) { curr_max = Math . Max ( curr_max , p . Value ) ; } if ( ( K % 2 == 1 ) && i == K / 2 ) ans += ( N / K - curr_max ) ; else ans += ( N / K * 2 - curr_max ) ; } return ans ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
void checkValidDFA ( string s ) { int final_state = 0 ; int previous_state = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ( s [ i ] == '0' && previous_state == 0 ) || ( s [ i ] == '1' && previous_state == 3 ) ) { final_state = 1 ; } else if ( ( s [ i ] == '0' && previous_state == 3 ) || ( s [ i ] == '1' && previous_state == 0 ) ) { final_state = 2 ; } else if ( ( s [ i ] == '0' && previous_state == 1 ) || ( s [ i ] == '1' && previous_state == 2 ) ) { final_state = 0 ; } else if ( ( s [ i ] == '0' && previous_state == 2 ) || ( s [ i ] == '1' && previous_state == 1 ) ) { final_state = 3 ; } previous_state = final_state ; } if ( final_state == 3 ) { Console . WriteLine ( "Accepted" ) ; } else { Console . WriteLine ( "Not Accepted" ) ; } }
void findFraction ( String s ) { String be_deci = "" , af_deci = "" , reccu = "" ; bool x = true , y = false , z = false ; for ( int i = 0 ; i < s . Length ; ++ i ) { if ( s [ i ] == '.' ) { x = false ; y = true ; continue ; } if ( s [ i ] == '(' ) { z = true ; y = false ; continue ; } if ( x ) be_deci += s [ i ] ; if ( y ) af_deci += s [ i ] ; if ( z ) { for ( ; i < s . Length && s [ i ] != ')' ; ++ i ) reccu += s [ i ] ; break ; } } int num_be_deci = Int32 . Parse ( be_deci ) ; int num_af_deci = 0 ; if ( af_deci . Length != 0 ) num_af_deci = Int32 . Parse ( af_deci ) ; int numr = num_be_deci * ( int ) Math . Pow ( 10 , af_deci . Length ) + num_af_deci ; int deno = ( int ) Math . Pow ( 10 , af_deci . Length ) ; if ( reccu . Length == 0 ) { int gd = __gcd ( numr , deno ) ; Console . Write ( numr / gd + " / " + deno / gd ) ; } else { int reccu_num = Int32 . Parse ( reccu ) ; int numr1 = numr * ( int ) Math . Pow ( 10 , reccu . Length ) + reccu_num ; int deno1 = deno * ( int ) Math . Pow ( 10 , reccu . Length ) ; int res_numr = numr1 - numr , res_deno = deno1 - deno ; int gd = __gcd ( res_numr , res_deno ) ; Console . Write ( res_numr / gd + " / " + res_deno / gd ) ; } }
int minCost ( string s , int n ) { int minValue = 100000000 ; for ( int i = 0 ; i <= 25 ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < n ; j ++ ) { cnt += Math . Min ( Math . Abs ( i - ( s [ j ] - 'a' ) ) , 26 - Math . Abs ( i - ( s [ j ] - 'a' ) ) ) ; } minValue = Math . Min ( minValue , cnt ) ; } return minValue ; }
int longComPre ( String [ ] arr , int N ) { int [ , ] freq = new int [ N , 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { int M = arr [ i ] . Length ; for ( int j = 0 ; j < M ; j ++ ) { freq [ i , arr [ i ] [ j ] ] ++ ; } } int maxLen = 0 ; for ( int j = 0 ; j < 256 ; j ++ ) { int minRowVal = int . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { minRowVal = Math . Min ( minRowVal , freq [ i , j ] ) ; } maxLen += minRowVal ; } return maxLen ; }
int fact ( int n ) { int res = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { res = res * i ; } return res ; }
int distinctWays ( string str1 , string str2 ) { int n = str1 . Length ; int m = str2 . Length ; if ( n == m ) { return 2 * fact ( n ) * fact ( m ) ; } return fact ( n ) * fact ( m ) ; }
void printResult ( List < int > result ) { result . Reverse ( ) ; int i = 0 ; while ( i < result . Count ) { Console . Write ( result [ i ] ) ; i ++ ; } }
void sumOfLargeNumbers ( String [ ] v , int k , int N ) { List < List < int > > x = new List < List < int > > ( 1000 ) ; for ( int i = 0 ; i < k ; i ++ ) x . Add ( new List < int > ( ) ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { x [ i ] . Add ( v [ i ] [ j ] - '0' ) ; } } int carry = 0 ; List < int > result = new List < int > ( ) ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += x [ j ] [ i ] ; sum += carry ; int temp = sum ; int count = 0 ; while ( temp > 9 ) { temp = temp % 10 ; count ++ ; } long l = ( long ) Math . Pow ( 10 , count ) ; if ( l != 1 ) carry = ( int ) ( sum / l ) ; sum = sum % 10 ; result . Add ( sum ) ; } while ( carry != 0 ) { int a = carry % 10 ; result . Add ( a ) ; carry = carry / 10 ; } printResult ( result ) ; }
void printRev ( string str ) { Stack st = new Stack ( ) ; String [ ] separator = { " " } ; string [ ] ss = str . Split ( separator , int . MaxValue , StringSplitOptions . RemoveEmptyEntries ) ; foreach ( string temp in ss ) { st . Push ( temp ) ; } while ( st . Count > 0 ) { Console . Write ( st . Peek ( ) + " " ) ; st . Pop ( ) ; } }
void printLeaves ( int [ ] preorder , int n ) { isLeaf ( preorder , n , int . MinValue , int . MaxValue ) ; }
int min_cost ( String S ) { int cost = 0 ; int F = 0 ; int B = 0 ; int count = 0 ; foreach ( char c in S . ToCharArray ( ) ) if ( c == ' ' ) count ++ ; int n = S . Length - count ; if ( n == 1 ) return cost ; foreach ( char inn in S . ToCharArray ( ) ) { if ( inn != ' ' ) { if ( B != 0 ) { cost += Math . Min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; }
int findPermutations ( int n ) { int sum = 0 , P ; for ( int r = 1 ; r <= n ; r ++ ) { P = permute ( n , r ) ; sum = sum + P ; } return sum ; }
int countOfString ( int N ) { int Stotal = ( int ) Math . Pow ( 2 , N ) ; int Sequal = 0 ; if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N / 2 ) ; int S1 = ( Stotal - Sequal ) / 2 ; return S1 ; }
bool check ( string s ) { HashSet < char > a = new HashSet < char > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( a . Contains ( s [ i ] ) ) { return false ; } a . Add ( s [ i ] ) ; } return true ; }
long binExp ( long Base , long power ) { long x = 1 ; while ( power != 0 ) { if ( power % 2 == 1 ) x = ( ( x % mod ) * ( Base % mod ) ) % mod ; Base = ( ( Base % mod ) * ( Base % mod ) ) % mod ; power = power / 2 ; } return x ; }
long fact ( long num ) { long result = 1 ; for ( long i = 1 ; i <= num ; ++ i ) { result = ( ( result % mod ) * ( i % mod ) ) % mod ; } return result ; }
long calculate_nCi ( long N , long i ) { long nfact = fact ( N ) ; long ifact = fact ( i ) ; long dfact = fact ( N - i ) ; long inv_ifact = binExp ( ifact , mod - 2 ) ; long inv_dfact = binExp ( dfact , mod - 2 ) ; long denm = ( ( inv_ifact % mod ) * ( inv_dfact % mod ) ) % mod ; long answer = ( ( nfact % mod ) * ( denm % mod ) ) % mod ; return answer ; }
void countSubstring ( long N , long s , long k ) { long allWays = binExp ( 26 , N ) ; long noWays = 0 ; for ( long i = 0 ; i < s ; ++ i ) { long nCi = calculate_nCi ( N , i ) ; long remaining = binExp ( 25 , N - i ) ; long multiply = ( ( nCi % mod ) * ( remaining % mod ) ) % mod ; noWays = ( ( noWays % mod ) + ( multiply % mod ) ) % mod ; } long answer = ( ( allWays % mod ) - ( noWays % mod ) ) % mod ; if ( answer < 0 ) answer += mod ; Console . WriteLine ( answer ) ; }
bool is_rtol ( String s ) { int tmp = ( int ) ( Math . Sqrt ( s . Length ) ) - 1 ; char first = s [ tmp ] ; for ( int pos = tmp ; pos < s . Length - 1 ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } } return true ; }
int isSpecial ( char c , char [ ] special ) { foreach ( char i in special ) if ( i == c ) return 1 ; return 0 ; }
double countRatio ( char [ ] s , char [ ] special ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ i ] = ( isSpecial ( s [ i ] , special ) ) ; if ( i > 0 ) prefix [ i ] += prefix [ i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { sum [ i ] = prefix [ i ] ; if ( i > 0 ) sum [ i ] += sum [ i - 1 ] ; } double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int count = sum [ n - 1 ] - ( i > 1 ? sum [ i - 2 ] : 0 ) ; count -= ( i < n ? sum [ n - i - 1 ] : 0 ) ; ans += ( double ) count / ( double ) i ; } return ans ; }
bool isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) return true ; else return false ; }
int minCost ( String S ) { int cA = 0 ; int cE = 0 ; int cI = 0 ; int cO = 0 ; int cU = 0 ; for ( int i = 0 ; i < S . Length ; i ++ ) { if ( isVowel ( S [ i ] ) ) { cA += Math . Abs ( S [ i ] - 'a' ) ; cE += Math . Abs ( S [ i ] - 'e' ) ; cI += Math . Abs ( S [ i ] - 'i' ) ; cO += Math . Abs ( S [ i ] - 'o' ) ; cU += Math . Abs ( S [ i ] - 'u' ) ; } } return Math . Min ( Math . Min ( Math . Min ( Math . Min ( cA , cE ) , cI ) , cO ) , cU ) ; }
bool isPalindrome ( string str ) { int l = 0 ; int h = str . Length - 1 ; while ( h > l ) { if ( str [ l ++ ] != str [ h -- ] ) return false ; } return true ; }
string makeOddString ( string str ) { string odd = "" ; for ( int i = 1 ; i < str . Length ; i += 2 ) { odd += str [ i ] ; } return odd ; }
string makeevenString ( string str ) { string even = "" ; for ( int i = 0 ; i < str . Length ; i += 2 ) { even += str [ i ] ; } return even ; }
void checkevenOddPalindrome ( string str ) { string odd = makeOddString ( str ) ; string even = makeevenString ( str ) ; if ( isPalindrome ( odd ) && isPalindrome ( even ) ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
bool inRange ( int hh , int mm , int L , int R ) { int a = Math . Abs ( hh - mm ) ; if ( a < L a > R ) { return false ; } return true ; }
void firstNonRepElement ( string str ) { LinkedList < char > list = new LinkedList < char > ( ) ; list . AddLast ( str [ 0 ] ) ; for ( int i = 1 ; i < str . Length ; i ++ ) { if ( list . Contains ( str [ i ] ) ) list . Remove ( str [ i ] ) ; else list . AddLast ( str [ i ] ) ; } Console . Write ( list . First . Value ) ; }
string makeOddString ( string str ) { string odd = "" ; for ( int i = 1 ; i < str . Length ; i += 2 ) { odd += str [ i ] ; } return odd ; }
void checkOddlyPalindrome ( string str ) { string odd = makeOddString ( str ) ; if ( isPalindrome ( odd ) ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
void decrypt ( String Str , int Start , int End ) { if ( Start > End ) { return ; } int mid = ( Start + End ) >> 1 ; Console . Write ( Str [ mid ] ) ; decrypt ( Str , mid + 1 , End ) ; decrypt ( Str , Start , mid - 1 ) ; }
bool isSuffix ( String s1 , String s2 ) { int n1 = s1 . Length , n2 = s2 . Length ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
bool CheckBinaryEquivalent ( int N , String str ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; int c = ( int ) Math . Pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } String bin = B_Number . ToString ( ) ; return isSuffix ( str , bin ) ; }
void decode_String ( String str , int K ) { String ans = "" ; for ( int i = 0 ; i < str . Length ; i += K ) ans += str [ i ] ; for ( int i = str . Length - ( K - 1 ) ; i < str . Length ; i ++ ) ans += str [ i ] ; Console . WriteLine ( ans ) ; }
bool check ( string str , int K ) { if ( str . Length % K == 0 ) { int sum = 0 , i ; for ( i = 0 ; i < K ; i ++ ) { sum += str [ i ] ; } for ( int j = i ; j < str . Length ; j += K ) { int s_comp = 0 ; for ( int p = j ; p < j + K ; p ++ ) s_comp += str [ p ] ; if ( s_comp != sum ) return false ; } return true ; } return false ; }
bool check ( String s , int n ) { Stack < int > st = new Stack < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( st . Count != 0 && st . Peek ( ) == s [ i ] ) st . Pop ( ) ; else st . Push ( s [ i ] ) ; } if ( st . Count == 0 ) { return true ; } else { return false ; } }
bool isPalindrome ( String str ) { int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] != str [ len - i - 1 ] ) return false ; } return true ; }
bool isCompressablePalindrome ( String str ) { int len = str . Length ; String compressed = "" ; compressed = String . Join ( "" , str [ 0 ] ) ; for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] != str [ i - 1 ] ) compressed += str [ i ] ; } return isPalindrome ( compressed ) ; }
int CountTotal ( string s ) { int ans = 0 ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { string temp = "" ; for ( int j = i ; j < n ; j ++ ) { temp += s [ j ] ; if ( isvalid ( temp ) ) ans += 1 ; } } return ans ; }
bool isvowel ( char x ) { return ( x == 'a' x == 'e' x == 'i' x == 'o' x == 'u' ) ; }
void getTotCount ( int num ) { totCount = 1 ; firstCount = 1 ; int temp = 1 ; while ( ( num & temp ) == 0 ) { temp = temp << 1 ; totCount += 1 ; } firstCount = totCount ; temp = num >> totCount ; while ( temp != 0 ) { totCount += 1 ; temp = temp >> 1 ; } }
int flipBitsFromRightMostSetBit ( int num ) { getTotCount ( num ) ; int num1 = num ^ ( ( 1 << totCount ) - 1 ) ; num1 = num1 ^ ( ( 1 << firstCount ) - 1 ) ; return num1 ; }
bool isVowel ( char c ) { return ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) ; }
bool isValid ( string s ) { int n = s . Length ; if ( n == 1 ) return ( isVowel ( s [ 0 ] ) ) ; if ( isVowel ( s [ 0 ] ) == false ) return false ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] || ! isVowel ( s [ i ] ) ) return false ; } return true ; }
int findMaxLen ( string s ) { int maxLen = 0 ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { string temp = "" ; for ( int j = i ; j < n ; j ++ ) { temp = temp + s [ j ] ; if ( isValid ( temp ) ) maxLen = Math . Max ( maxLen , ( j - i + 1 ) ) ; } } return maxLen ; }
int findMaxLen ( string s ) { int maxLen = 0 ; int cur ; if ( isVowel ( s [ 0 ] ) ) maxLen = 1 ; cur = maxLen ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( isVowel ( s [ i ] ) ) { if ( s [ i ] != s [ i - 1 ] ) cur += 1 ; else cur = 1 ; } else { cur = 0 ; } maxLen = Math . Max ( cur , maxLen ) ; } return maxLen ; }
long power ( long Base , long pow ) { long res = 1 ; while ( pow > 0 ) { if ( ( pow & 1 ) == 1 ) res = ( res * Base ) ; Base = ( Base * Base ) ; pow >>= 1 ; } return res ; }
long countNonPalindromicString ( long n , long m ) { long total = power ( n , m ) ; long palindrome = power ( n , m / 2 + m % 2 ) ; long count = total - palindrome ; return count ; }
void BalancedNumber ( string s ) { int Leftsum = 0 ; int Rightsum = 0 ; for ( int i = 0 ; i < s . Length / 2 ; i ++ ) { Leftsum += ( int ) ( Char . GetNumericValue ( s [ i ] ) - Char . GetNumericValue ( '0' ) ) ; Rightsum += ( int ) ( Char . GetNumericValue ( s [ s . Length - 1 - i ] ) - Char . GetNumericValue ( '0' ) ) ; } if ( Leftsum == Rightsum ) Console . WriteLine ( "Balanced" ) ; else Console . WriteLine ( "Not Balanced" ) ; }
int expo ( int Base , int exponent ) { int ans = 1 ; while ( exponent != 0 ) { if ( ( exponent & 1 ) == 1 ) { ans = ans * Base ; ans = ans % mod ; } Base = Base * Base ; Base %= mod ; exponent >>= 1 ; } return ans % mod ; }
int findCount ( int N ) { int ans = ( expo ( 26 , N ) - expo ( 5 , N ) - expo ( 21 , N ) ) % mod ; ans += mod ; ans %= mod ; return ans ; }
int countPalindromePermutation ( char [ ] s , int k ) { int i = 0 ; for ( i = 0 ; i < k ; i ++ ) { freq [ s [ i ] - 97 ] ++ ; } int ans = 0 ; if ( checkPalindrome ( ) ) { ans ++ ; } int j = k ; i = 0 ; while ( j < s . Length ) { freq [ s [ i ++ ] - 97 ] -- ; freq [ s [ j ++ ] - 97 ] ++ ; if ( checkPalindrome ( ) ) { ans ++ ; } } return ans ; }
int minFlips ( String target ) { char curr = '1' ; int count = 0 ; for ( int i = 0 ; i < target . Length ; i ++ ) { if ( target [ i ] == curr ) { count ++ ; curr = ( char ) ( 48 + ( curr + 1 ) % 2 ) ; } } return count ; }
int decompose ( List < int > S ) { Stack < int > s = new Stack < int > ( ) ; int N = S . Count ; int ans = 0 ; int nix = Int32 . MaxValue ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( s . Count == 0 ) { s . Push ( S [ i ] ) ; nix = S [ i ] ; } else { if ( S [ i ] < s . Peek ( ) ) { s . Push ( S [ i ] ) ; nix = Math . Min ( nix , S [ i ] ) ; } else { int val = S [ i ] ; while ( s . Count != 0 && val >= s . Peek ( ) ) { s . Pop ( ) ; } nix = Math . Min ( nix , S [ i ] ) ; s . Push ( nix ) ; } } ans += s . Count ; } return ans ; }
int maxSetBitCount ( string s , int k ) { int maxCount = 0 , n = s . Length ; int count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s [ i ] == '1' ) count ++ ; } maxCount = count ; for ( int i = k ; i < n ; i ++ ) { if ( s [ i - k ] == '1' ) count -- ; if ( s [ i ] == '1' ) count ++ ; maxCount = Math . Max ( maxCount , count ) ; } return maxCount ; }
string maxVowelSubString ( string str , int K ) { int N = str . Length ; int [ ] pref = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == 'a' str [ i ] == 'e' str [ i ] == 'i' str [ i ] == 'o' str [ i ] == 'u' ) pref [ i ] = 1 ; else pref [ i ] = 0 ; if ( i != 0 ) pref [ i ] += pref [ i - 1 ] ; } int maxCount = pref [ K - 1 ] ; string res = str . Substring ( 0 , K ) ; for ( int i = K ; i < N ; i ++ ) { int currCount = pref [ i ] - pref [ i - K ] ; if ( currCount > maxCount ) { maxCount = currCount ; res = str . Substring ( i - K + 1 , K ) ; } else if ( currCount == maxCount ) { string temp = str . Substring ( i - K + 1 , K ) ; if ( string . Compare ( temp , res ) == - 1 ) res = temp ; } } return res ; }
void miniOperToMakeAllEleEqual ( int [ ] arr , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % n != 0 ) { Console . WriteLine ( - 1 ) ; return ; } int valueAfterDivision = sum / n ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . Abs ( valueAfterDivision - arr [ i ] ) % k != 0 ) { Console . WriteLine ( - 1 ) ; return ; } count += Math . Abs ( valueAfterDivision - arr [ i ] ) / k ; } Console . WriteLine ( ( int ) count / 2 ) ; }
void minOperations ( List < int > a ) { int res = Int32 . MaxValue ; int N = a . Count ; for ( int r = 0 ; r < 2 ; r ++ ) { int sum = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( ( i + r ) % 2 == 1 ) { if ( sum <= 0 ) { ans += - sum + 1 ; sum = 1 ; } } else { if ( sum >= 0 ) { ans += sum + 1 ; sum = - 1 ; } } } res = Math . Min ( res , ans ) ; } Console . Write ( res ) ; }
bool checkWord ( char [ , ] board , String word , int index , int row , int col ) { if ( row < 0 || col < 0 || row >= board . GetLength ( 0 ) || col >= board . GetLength ( 1 ) ) return false ; if ( board [ row , col ] != word [ index ] ) return false ; else if ( index == word . Length - 1 ) return true ; char temp = board [ row , col ] ; board [ row , col ] = '*' ; if ( checkWord ( board , word , index + 1 , row + 1 , col ) || checkWord ( board , word , index + 1 , row - 1 , col ) || checkWord ( board , word , index + 1 , row , col + 1 ) || checkWord ( board , word , index + 1 , row , col - 1 ) ) { board [ row , col ] = temp ; return true ; } board [ row , col ] = temp ; return false ; }
int count ( String N , int X , String subStr , int index , int n ) { if ( index == n ) return 0 ; String a = subStr + N [ index ] ; int b = 0 ; if ( long . Parse ( a ) % X == 0 ) b = 1 ; int m1 = count ( N , X , a , index + 1 , n ) ; int m2 = b + count ( N , X , "" , index + 1 , n ) ; return Math . Max ( m1 , m2 ) ; }
bool checkSuffix ( int A , int B ) { string s1 = A . ToString ( ) ; string s2 = B . ToString ( ) ; int n1 = s1 . Length ; int n2 = s2 . Length ; if ( n1 < n2 ) { return false ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) { return false ; } } return true ; }
void checkSuffix ( int A , int B ) { String s1 = String . Join ( "" , A ) ; String s2 = String . Join ( "" , B ) ; bool result ; result = s1 . EndsWith ( s2 ) ; if ( result ) { Console . Write ( "Yes" ) ; } else { Console . Write ( "No" ) ; } }
bool checkSuffix ( int A , int B ) { int digit_B = ( int ) ( Math . Log10 ( B ) + 1 ) ; A -= B ; return ( A % ( int ) ( Math . Pow ( 10 , digit_B ) ) > 0 ) ; }
bool check ( string s ) { bool ok = true ; for ( int i = 0 ; i + 1 < s . Length ; ++ i ) ok &= ( Math . Abs ( s [ i ] - s [ i + 1 ] ) != 1 ) ; return ok ; }
int findMinLength ( String s ) { int n = s . Length ; int i = 0 ; Dictionary < char , int > counts = new Dictionary < char , int > ( ) ; List < int > indices = new List < int > ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == 'a' s [ i ] == 'e' s [ i ] == 'o' s [ i ] == 'i' s [ i ] == 'u' ) { if ( counts . ContainsKey ( s [ i ] ) ) { counts [ s [ i ] ] = counts [ s [ i ] ] + 1 ; } else { counts . Add ( s [ i ] , 1 ) ; } indices . Add ( i ) ; } } if ( counts . Count < 5 ) return - 1 ; int flag1 = 0 , flag2 = 0 ; i = 0 ; int j = indices . Count - 1 ; while ( ( j - i ) >= 4 ) { if ( flag1 == 0 && counts [ s [ indices [ i ] ] ] > 1 ) { counts [ s [ indices [ i ] ] ] = counts [ s [ indices [ i ] ] ] - 1 ; i ++ ; } else flag1 = 1 ; if ( flag2 == 0 && counts [ s [ indices [ j ] ] ] > 1 ) { counts [ s [ indices [ j ] ] ] = counts [ s [ indices [ j ] ] ] - 1 ; j -- ; } else flag2 = 1 ; if ( flag1 == 1 && flag2 == 1 ) break ; } return ( indices [ j ] - indices [ i ] + 1 ) ; }
int get_index ( char ch ) { if ( ch == 'a' ) return 0 ; else if ( ch == 'e' ) return 1 ; else if ( ch == 'i' ) return 2 ; else if ( ch == 'o' ) return 3 ; else if ( ch == 'u' ) return 4 ; else return - 1 ; }
int findMinLength ( String s ) { int n = s . Length ; int ans = n + 1 ; int start = 0 ; int [ ] count = new int [ 5 ] ; for ( int x = 0 ; x < n ; x ++ ) { int idx = get_index ( s [ x ] ) ; if ( idx != - 1 ) { count [ idx ] ++ ; } int idx_start = get_index ( s [ start ] ) ; while ( idx_start == - 1 count [ idx_start ] > 1 ) { if ( idx_start != - 1 ) { count [ idx_start ] -- ; } start ++ ; if ( start < n ) idx_start = get_index ( s [ start ] ) ; } if ( count [ 0 ] > 0 && count [ 1 ] > 0 && count [ 2 ] > 0 && count [ 3 ] > 0 && count [ 4 ] > 0 ) { ans = Math . Min ( ans , x - start + 1 ) ; } } if ( ans == n + 1 ) return - 1 ; return ans ; }
int count_min_length ( string s ) { int [ ] hash = new int [ 26 ] ; int ans = int . MaxValue ; for ( int i = 0 ; i < 26 ; i ++ ) hash [ i ] = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( hash [ s [ i ] - 'a' ] == - 1 ) hash [ s [ i ] - 'a' ] = i ; else { if ( hash [ s [ i ] - 'a' ] == i - 1 hash [ s [ i ] - 'a' ] == i - 2 ) return 0 ; ans = Math . Min ( ans , i - hash [ s [ i ] - 'a' ] - 1 ) ; hash [ s [ i ] - 'a' ] = i ; } } if ( ans == int . MaxValue ) return - 1 ; return ans ; }
int countStrings ( String s ) { int cnt = 0 ; for ( int i = 1 ; i < s . Length - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { cnt ++ ; } } return cnt ; }
void RemoveHTMLTags ( String str ) { System . Text . RegularExpressions . Regex rx = new System . Text . RegularExpressions . Regex ( "<[^>]*>" ) ; str = rx . Replace ( str , "" ) ; Console . WriteLine ( str ) ; }
bool checkValidString ( String str ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < str . Length ; i ++ ) { freq [ str [ i ] - 'a' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] != 0 ) { if ( freq [ i ] != i + 1 ) { return false ; } } } return true ; }
bool checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) { ++ cnt ; } return cnt == 2 ; }
void makeCypherString ( int N ) { String semiPrime = "" ; String sumOfPrime = "" ; String str = String . Join ( "" , N ) ; if ( checkSemiprime ( N ) ) { for ( int i = 0 ; i < str . Length ; i ++ ) { if ( i % 2 == 1 ) { semiPrime += str [ i ] ; } else { semiPrime += ( char ) ( str [ i ] - '0' + 65 ) ; } } } if ( isPossibleSum ( N ) ) { for ( int i = 0 ; i < str . Length ; i ++ ) { if ( i % 2 == 1 ) { sumOfPrime += ( char ) ( str [ i ] - '0' + 65 ) ; } else { sumOfPrime += str [ i ] ; } } } if ( semiPrime + sumOfPrime == "" ) { Console . Write ( "-1" ) ; } else { Console . Write ( semiPrime + sumOfPrime ) ; } }
int modulo_by_26 ( String num ) { int res = 0 ; for ( int i = 0 ; i < num . Length ; i ++ ) { res = ( ( res * 10 + ( int ) num [ i ] - '0' ) % MOD ) ; } return res ; }
string longestConsonantsSubsequence ( string str ) { string answer = "" ; int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( isConsonants ( str [ i ] ) ) { answer += str [ i ] ; } } return answer ; }
string generateTheString ( int n ) { string ans = "" ; if ( n % 2 == 0 ) { for ( int i = 0 ; i < Math . Min ( n , 24 ) ; i ++ ) { ans += ( char ) ( 'b' + i ) ; } if ( n > 24 ) { for ( int i = 0 ; i < ( n - 24 ) ; i ++ ) ans += 'a' ; } } else { for ( int i = 0 ; i < Math . Min ( n , 25 ) ; i ++ ) { ans += ( char ) ( 'b' + i ) ; } if ( n > 25 ) { for ( int i = 0 ; i < ( n - 25 ) ; i ++ ) ans += 'a' ; } } return ans ; }
void finalCoordinates ( int SX , int SY , char [ ] D ) { for ( int i = 0 ; i < D . Length ; i ++ ) { if ( D [ i ] == 'N' ) { SY += 1 ; } else if ( D [ i ] == 'S' ) { SY -= 1 ; } else if ( D [ i ] == 'E' ) { SX += 1 ; } else { SX -= 1 ; } } String ans = '(' + String . Join ( "" , SX ) + ',' + String . Join ( "" , SY ) + ')' ; Console . Write ( ans ) ; }
void shortestPalindrome ( string s ) { int [ ] abcd = new int [ 26 ] ; for ( int i = 0 ; i < s . Length ; i ++ ) abcd [ s [ i ] - 97 ] = 1 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( abcd [ i ] == 1 ) { Console . Write ( ( char ) ( i + 97 ) + " " ) ; } } }
void contain ( int L , int U , int M ) { int count = 0 ; for ( int j = L ; j < U ; j ++ ) { HashSet < string > num = new HashSet < string > ( ) ; string str = j . ToString ( ) ; num . Add ( str ) ; if ( j % M == 0 && ! num . Contains ( M . ToString ( ) ) ) { count += 1 ; } } Console . Write ( count - 2 ) ; }
int MaxLength ( List < String > v , int i , int m ) { if ( i >= m ) { return m - 1 ; } for ( int k = 0 ; k < 26 ; k ++ ) { char c = ( char ) ( 'a' + k ) ; List < String > v1 = new List < String > ( ) ; for ( int j = 0 ; j < v . Count ; j ++ ) { if ( v [ j ] [ i ] == c ) { v1 . Add ( v [ j ] ) ; } } if ( v1 . Count >= 2 ) { max1 = Math . Max ( max1 , MaxLength ( v1 , i + 1 , m ) ) ; } else { max1 = Math . Max ( max1 , i - 1 ) ; } } return max1 ; }
void group_formed ( String S ) { int count = 1 ; for ( int i = 0 ; i < S . Length - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) count += 1 ; } Console . Write ( count ) ; }
int value ( char x ) { return ( int ) ( x - 'a' ) ; }
void finalString ( String str ) { int x = 0 , y = 0 ; int left ; int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) x ++ ; else y ++ ; } if ( x > y ) left = 1 ; else left = 0 ; int length = n - 2 * Math . Min ( x , y ) ; for ( int i = 0 ; i < length ; i ++ ) { Console . Write ( left ) ; } }
int noOfDeletions ( String str , char k ) { int ans = 0 , cnt = 0 , pos = 0 ; while ( pos < str . Length && str [ pos ] != k ) { pos ++ ; } int i = pos ; while ( i < str . Length ) { while ( i < str . Length && str [ i ] == k ) { i = i + 1 ; } ans = ans + cnt ; cnt = 0 ; while ( i < str . Length && str [ i ] != k ) { i = i + 1 ; cnt = cnt + 1 ; } } return ans ; }
int GetDigitalRoot ( String str ) { if ( str . Length == 1 ) { return str [ 0 ] - '0' ; } str = GetIndividulaDigitSum ( str , str . Length ) ; return GetDigitalRoot ( str ) ; }
int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - 'A' + 10 ; }
int toDeci ( String str , int Base ) { int len = str . Length ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= Base ) { return - 1 ; } num += val ( str [ i ] ) * power ; power = power * Base ; } return num ; }
bool repeatingString ( String s , int n , int k ) { if ( n % k != 0 ) { return false ; } int [ ] frequency = new int [ 123 ] ; for ( int i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { frequency [ s [ i ] ] ++ ; } int repeat = n / k ; for ( int i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; }
int longestPalindromic ( String str , int i , int j , int count ) { if ( i > j ) return count ; if ( i == j ) return ( count + 1 ) ; if ( str [ i ] == str [ j ] ) { count = longestPalindromic ( str , i + 1 , j - 1 , count + 2 ) ; return max ( count , max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) ) ; } return Math . Max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) ; }
int longest_palindromic_substr ( String str ) { return longestPalindromic ( str , 0 , str . Length - 1 , 0 ) ; }
string removeOddFrequencyCharacters ( string s ) { Dictionary < char , int > m = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { char p = s [ i ] ; if ( m . ContainsKey ( p ) ) { m [ p ] ++ ; } else { m [ p ] = 1 ; } } string new_string = "" ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ( m [ s [ i ] ] & 1 ) == 1 ) continue ; new_string += s [ i ] ; } return new_string ; }
int LexicoLesserStrings ( String s ) { int count = 0 ; int len ; len = s . Length ; for ( int i = 0 ; i < len ; i ++ ) { count += ( ( s [ i ] - 'a' ) * ( int ) Math . Pow ( 26 , len - i - 1 ) ) ; } return count ; }
int countString ( String S1 , String S2 ) { int countS1 , countS2 , totalString ; countS1 = LexicoLesserStrings ( S1 ) ; countS2 = LexicoLesserStrings ( S2 ) ; totalString = countS2 - countS1 - 1 ; return ( totalString < 0 ? 0 : totalString ) ; }
bool isVowel ( char x ) { x = char . ToLower ( x ) ; return ( x == 'a' x == 'e' x == 'i' x == 'o' x == 'u' ) ; }
void MaxPrefix ( string s ) { Dictionary < char , int > Dict = new Dictionary < char , int > ( ) ; foreach ( char i in s ) { if ( Dict . ContainsKey ( i ) ) { Dict [ i ] ++ ; } else { Dict [ i ] = 1 ; } } int minfrequency = Int32 . MaxValue ; foreach ( int x in Dict . Values . ToList ( ) ) { minfrequency = Math . Min ( minfrequency , x ) ; } int countminFrequency = 0 ; foreach ( char x in Dict . Keys . ToList ( ) ) { if ( Dict [ x ] == minfrequency ) countminFrequency += 1 ; } Dictionary < char , int > mapper = new Dictionary < char , int > ( ) ; int indi = 0 ; foreach ( char i in s ) { if ( mapper . ContainsKey ( i ) ) { mapper [ i ] ++ ; } else { mapper [ i ] = 1 ; } if ( mapper [ i ] > countminFrequency ) break ; indi += 1 ; } Console . Write ( s . Substring ( 0 , indi ) ) ; }
long countSubstr ( String s , int k ) { int n = s . Length ; int l = n - 1 ; int r = n - 1 ; int [ ] arr = new int [ n ] ; int last_indexof1 = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) { arr [ i ] = i ; last_indexof1 = i ; } else { arr [ i ] = last_indexof1 ; } } long no_of_substr = 0 ; for ( r = n - 1 ; r >= 0 ; r -- ) { l = r ; while ( l >= 0 && ( r - l + 1 ) <= 64 && ( int ) ( Convert . ToInt32 ( s . Substring ( l , r + 1 - l ) , 2 ) ) < k ) { l -- ; } if ( r - l + 1 <= 64 ) no_of_substr += l + 1 ; else { no_of_substr += arr [ l + 1 ] + 1 ; } } return no_of_substr ; }
bool isPerfectCubeString ( String str ) { int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) sum += ( int ) str [ i ] ; double cr = Math . Round ( Math . Pow ( sum , ( double ) 1 / 3 ) ) ; return ( cr * cr * cr == sum ) ; }
int XorAscii ( String str , int len ) { int ans = ( str [ 0 ] ) ; for ( int i = 1 ; i < len ; i ++ ) { ans = ( ans ^ ( ( str [ i ] ) ) ) ; } return ans ; }
int countSticks ( string str ) { int cnt = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { char ch = str [ i ] ; if ( ch >= 'A' && ch <= 'Z' ) { cnt += sticks [ ch - 'A' ] ; } else { cnt += number [ ch - '0' ] ; } } return cnt ; }
void count ( string str1 , string str2 ) { int c = 0 , j = 0 ; for ( int i = 0 ; i < str1 . Length ; i ++ ) { if ( str2 . IndexOf ( str1 [ i ] ) >= 0 ) { c += 1 ; } } Console . WriteLine ( "No. of matching characters are: " + c ) ; }
int checkIfStartsWithCapital ( string str ) { if ( str [ 0 ] >= 'A' && str [ 0 ] <= 'Z' ) return 1 ; else return 0 ; }
int checkIfAllVowels ( String str ) { int [ ] hash = new int [ 5 ] ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == 'A' str [ i ] == 'a' ) hash [ 0 ] = 1 ; else if ( str [ i ] == 'E' str [ i ] == 'e' ) hash [ 1 ] = 1 ; else if ( str [ i ] == 'I' str [ i ] == 'i' ) hash [ 2 ] = 1 ; else if ( str [ i ] == 'O' str [ i ] == 'o' ) hash [ 3 ] = 1 ; else if ( str [ i ] == 'U' str [ i ] == 'u' ) hash [ 4 ] = 1 ; } for ( int i = 0 ; i < 5 ; i ++ ) { if ( hash [ i ] == 0 ) { return 1 ; } } return 0 ; }
int countOfLetters ( String str ) { int letter = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) || ( str [ i ] >= 'a' && str [ i ] <= 'z' ) ) letter ++ ; } return letter ; }
int countOfNumbers ( String str ) { int number = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] >= '0' && str [ i ] <= '9' ) number ++ ; } return number ; }
int findNthOccur ( String str , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return - 1 ; }
void countSmaller ( String str ) { int n = str . Length ; int [ ] arr = new int [ 26 ] ; int [ ] ans = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { arr [ str [ i ] - 'a' ] ++ ; int ct = 0 ; for ( int j = 0 ; j < str [ i ] - 'a' ; j ++ ) { ct += arr [ j ] ; } ans [ i ] = ct ; } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( ans [ i ] + " " ) ; } }
void printValue ( char digit ) { switch ( digit ) { case '0' : Console . Write ( "Zero " ) ; break ; case '1' : Console . Write ( "One " ) ; break ; case '2' : Console . Write ( "Two " ) ; break ; case '3' : Console . Write ( "Three " ) ; break ; case '4' : Console . Write ( "Four " ) ; break ; case '5' : Console . Write ( "Five " ) ; break ; case '6' : Console . Write ( "Six " ) ; break ; case '7' : Console . Write ( "Seven " ) ; break ; case '8' : Console . Write ( "Eight " ) ; break ; case '9' : Console . Write ( "Nine " ) ; break ; } }
void printWord ( string N ) { int i , length = N . Length ; for ( i = 0 ; i < length ; i ++ ) { printValue ( N [ i ] ) ; } }
int solve ( string X , string Y , int N , int K ) { int [ ] count = new int [ N + 1 ] ; int sol = 0 ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count [ i ] = count [ i - 1 ] + Math . Abs ( X [ i - 1 ] - Y [ i - 1 ] ) ; } int j = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { while ( ( count [ i ] - count [ j ] ) > K ) { j ++ ; } sol = Math . Max ( sol , i - j ) ; } return sol ; }
int find ( int x ) { if ( x != parent [ x ] ) return parent [ x ] = find ( parent [ x ] ) ; return x ; }
void join ( int x , int y ) { int px = find ( x ) ; int pz = find ( y ) ; if ( px != pz ) { parent [ pz ] = px ; } }
bool convertible ( String s1 , String s2 ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < s1 . Length ; i ++ ) { if ( ! mp . ContainsKey ( s1 [ i ] - 'a' ) ) { mp . Add ( s1 [ i ] - 'a' , s2 [ i ] - 'a' ) ; } else { if ( mp [ s1 [ i ] - 'a' ] != s2 [ i ] - 'a' ) return false ; } } foreach ( KeyValuePair < int , int > it in mp ) { if ( it . Key == it . Value ) continue ; else { if ( find ( it . Key ) == find ( it . Value ) ) return false ; else join ( it . Key , it . Value ) ; } } return true ; }
void initialize ( ) { for ( int i = 0 ; i < 26 ; i ++ ) { parent [ i ] = i ; } }
double jaro_distance ( string s1 , string s2 ) { if ( s1 == s2 ) return 1.0 ; int len1 = s1 . Length ; int len2 = s2 . Length ; int max_dist = ( int ) ( Math . Floor ( ( double ) ( ( Math . Max ( len1 , len2 ) / 2 ) - 1 ) ) ) ; int match = 0 ; int [ ] hash_s1 = new int [ s1 . Length ] ; int [ ] hash_s2 = new int [ s2 . Length ] ; for ( int i = 0 ; i < len1 ; i ++ ) { for ( int j = Math . Max ( 0 , i - max_dist ) ; j < Math . Min ( len2 , i + max_dist + 1 ) ; j ++ ) if ( s1 [ i ] == s2 [ j ] && hash_s2 [ j ] == 0 ) { hash_s1 [ i ] = 1 ; hash_s2 [ j ] = 1 ; match ++ ; break ; } } if ( match == 0 ) return 0.0 ; double t = 0 ; int point = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) if ( hash_s1 [ i ] == 1 ) { while ( hash_s2 [ point ] == 0 ) point ++ ; if ( s1 [ i ] != s2 [ point ++ ] ) t ++ ; } t /= 2 ; return ( ( ( double ) match ) / ( ( double ) len1 ) + ( ( double ) match ) / ( ( double ) len2 ) + ( ( double ) match - t ) / ( ( double ) match ) ) / 3.0 ; }
double jaro_distance ( string s1 , string s2 ) { if ( s1 == s2 ) return 1.0 ; int len1 = s1 . Length , len2 = s2 . Length ; if ( len1 == 0 len2 == 0 ) return 0.0 ; int max_dist = ( int ) Math . Floor ( ( double ) Math . Max ( len1 , len2 ) / 2 ) - 1 ; int match = 0 ; int [ ] hash_s1 = new int [ s1 . Length ] ; int [ ] hash_s2 = new int [ s2 . Length ] ; for ( int i = 0 ; i < len1 ; i ++ ) { for ( int j = Math . Max ( 0 , i - max_dist ) ; j < Math . Min ( len2 , i + max_dist + 1 ) ; j ++ ) if ( s1 [ i ] == s2 [ j ] && hash_s2 [ j ] == 0 ) { hash_s1 [ i ] = 1 ; hash_s2 [ j ] = 1 ; match ++ ; break ; } } if ( match == 0 ) return 0.0 ; double t = 0 ; int point = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) if ( hash_s1 [ i ] == 1 ) { while ( hash_s2 [ point ] == 0 ) point ++ ; if ( s1 [ i ] != s2 [ point ++ ] ) t ++ ; } t /= 2 ; return ( ( ( double ) match ) / ( ( double ) len1 ) + ( ( double ) match ) / ( ( double ) len2 ) + ( ( double ) match - t ) / ( ( double ) match ) ) / 3.0 ; }
double jaro_Winkler ( string s1 , string s2 ) { double jaro_dist = jaro_distance ( s1 , s2 ) ; if ( jaro_dist > 0.7 ) { int prefix = 0 ; for ( int i = 0 ; i < Math . Min ( s1 . Length , s2 . Length ) ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) prefix ++ ; else break ; } prefix = Math . Min ( 4 , prefix ) ; jaro_dist += 0.1 * prefix * ( 1 - jaro_dist ) ; } return jaro_dist ; }
bool isWordPresent ( String sentence , String word ) { String [ ] s = sentence . Split ( ' ' ) ; foreach ( String temp in s ) { if ( temp . CompareTo ( word ) == 0 ) { return true ; } } return false ; }
string canMake ( string s ) { int o = 0 , z = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] - '0' == 1 ) o ++ ; else z ++ ; } if ( o % 2 == 1 && z % 2 == 1 ) return "NO" ; else return "YES" ; }
int countChars ( string str , int n ) { int i = 0 , cnt = 0 ; while ( i < n ) { if ( str [ i ] == '0' ) i += 1 ; else i += 2 ; cnt += 1 ; } return cnt ; }
int findMinSwaps ( string s , int k ) { int ans = 0 ; int c_one = 0 , c_zero = 0 ; for ( int i = s . Length - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) c_one ++ ; if ( s [ i ] == '0' ) { c_zero ++ ; ans += c_one ; } if ( c_zero == k ) break ; } if ( c_zero < k ) return - 1 ; return ans ; }
bool checkvowel ( char ch ) { ch = char . ToLower ( ch ) ; if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) { return true ; } else { return false ; } }
void decBinary ( int [ ] arr , int n ) { int k = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } }
int concat ( int m , int n ) { int k = ( int ) ( Math . Log ( m ) / Math . Log ( 2 ) ) + 1 ; int l = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; int [ ] a = new int [ k ] ; int [ ] b = new int [ l ] ; int [ ] c = new int [ k + l ] ; decBinary ( a , m ) ; decBinary ( b , n ) ; int iN = 0 ; for ( int i = 0 ; i < k ; i ++ ) c [ iN ++ ] = a [ i ] ; for ( int i = 0 ; i < l ; i ++ ) c [ iN ++ ] = b [ i ] ; return ( binaryDec ( c , k + l ) ) ; }
int getBinaryLength ( int n ) { int length = 0 ; while ( n > 0 ) { length += 1 ; n /= 2 ; } return length ; }
int concat ( int m , int n ) { int length = getBinaryLength ( n ) ; return ( m << length ) + n ; }
int countSubStr ( string str , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) ans += ( i + 1 ) ; } return ans ; }
string largestSubStr ( string s ) { while ( s . Length != 0 && s [ s . Length - 1 ] == '1' ) s = s . Substring ( 0 , s . Length - 1 ) ; if ( s . Length == 0 ) return "-1" ; else return s ; }
bool areEqual ( int [ ] a , int [ ] b ) { for ( int i = 0 ; i < MAX ; i ++ ) if ( a [ i ] != b [ i ] ) return false ; return true ; }
string reverseParentheses ( string str , int len ) { Stack < int > st = new Stack < int > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '(' ) { st . Push ( i ) ; } else if ( str [ i ] == ')' ) { char [ ] A = str . ToCharArray ( ) ; reverse ( A , st . Peek ( ) + 1 , i ) ; str = new string ( A ) ; st . Pop ( ) ; } } string res = "" ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] != ')' && str [ i ] != '(' ) { res += str [ i ] ; } } return res ; }
int maxCount ( String str , String patt ) { int [ ] strFreq = new int [ MAX ] ; updateFreq ( str , strFreq ) ; int [ ] pattFreq = new int [ MAX ] ; updateFreq ( patt , pattFreq ) ; int ans = int . MaxValue ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( pattFreq [ i ] == 0 ) continue ; ans = Math . Min ( ans , strFreq [ i ] / pattFreq [ i ] ) ; } return ans ; }
int minNum ( char [ ] str , int len ) { int res = int . MaxValue ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '4' str [ i ] == '8' ) { res = Math . Min ( res , str [ i ] - '0' ) ; } } for ( int i = 0 ; i < len - 1 ; i ++ ) { for ( int j = i + 1 ; j < len ; j ++ ) { int num = ( str [ i ] - '0' ) * TEN + ( str [ j ] - '0' ) ; if ( num % 4 == 0 ) { res = Math . Min ( res , num ) ; } } } return ( ( res == int . MaxValue ) ? - 1 : res ) ; }
int minOperation ( String str , int len ) { int [ ] first = new int [ MAX ] ; int [ ] last = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str [ i ] - 'a' ) ; if ( first [ index ] == - 1 ) first [ index ] = i ; last [ index ] = i ; } int minOp = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == - 1 first [ i ] == last [ i ] ) continue ; int cnt = len - ( last [ i ] - first [ i ] + 1 ) ; if ( minOp == - 1 cnt < minOp ) minOp = cnt ; } return minOp ; }
void findMidAlphabet ( String s1 , String s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int mid = ( s1 [ i ] + s2 [ i ] ) / 2 ; Console . Write ( ( char ) mid ) ; } }
int countVowels ( String str , int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( isVowel ( str [ i ] ) ) cnt ++ ; } return cnt ; }
int sumDigits ( int n ) { int sum = 0 ; while ( n > 0 ) { int digit = n % 10 ; sum += digit ; n /= 10 ; } return sum ; }
bool isDivBySix ( String str , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ( int ) ( str [ i ] - 'a' + 1 ) ; } if ( sum % 3 != 0 ) return false ; int lastDigit = ( ( int ) ( str [ n - 1 ] - 'a' + 1 ) ) % 10 ; if ( lastDigit % 2 != 0 ) return false ; return true ; }
int minLength ( String str , int len ) { Stack < char > s = new Stack < char > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( s . Count == 0 ) { s . Push ( str [ i ] ) ; } else { char c = s . Peek ( ) ; if ( c != str [ i ] && char . ToUpper ( c ) == char . ToUpper ( ( str [ i ] ) ) ) { s . Pop ( ) ; } else { s . Push ( str [ i ] ) ; } } } return s . Count ; }
int cntSplits ( String s ) { if ( s [ s . Length - 1 ] == '1' ) return 0 ; int c_zero = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) c_zero += ( s [ i ] == '0' ) ? 1 : 0 ; return ( int ) Math . Pow ( 2 , c_zero - 1 ) ; }
bool isDivisible ( String s , int m ) { Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < DIGITS ; i ++ ) { if ( mp . ContainsKey ( CHARS [ i ] ) ) mp [ CHARS [ i ] ] = i ; else mp . Add ( CHARS [ i ] , i ) ; } int r = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { r = ( r * 16 + mp [ s [ i ] ] ) % m ; } if ( r == 0 ) return true ; return false ; }
bool isPalindrome ( float num ) { string s = num . ToString ( ) ; int low = 0 ; int high = s . Length - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; }
int maxSubStr ( char [ ] str1 , int len1 , char [ ] str2 , int len2 ) { if ( len1 > len2 ) return 0 ; int [ ] freq1 = new int [ MAX ] ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ i ] = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ str1 [ i ] - 'a' ] ++ ; int [ ] freq2 = new int [ MAX ] ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ i ] = 0 ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ str2 [ i ] - 'a' ] ++ ; int minPoss = int . MaxValue ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq1 [ i ] == 0 ) continue ; if ( freq1 [ i ] > freq2 [ i ] ) return 0 ; minPoss = Math . Min ( minPoss , freq2 [ i ] / freq1 [ i ] ) ; } return minPoss ; }
int Count ( String s , int pos ) { int c = s [ pos - 1 ] ; int counter = 0 ; for ( int i = 0 ; i < pos - 1 ; i ++ ) { if ( s [ i ] == c ) counter = counter + 1 ; } return counter ; }
void findSubStr ( String str , int cnt , int start ) { if ( start == str . Length ) { minCnt = Math . Min ( cnt , minCnt ) ; } for ( int len = 1 ; len <= ( str . Length - start ) ; len ++ ) { String subStr = str . Substring ( start , len ) ; if ( uSet . Contains ( subStr ) ) { findSubStr ( str , cnt + 1 , start + len ) ; } } }
int getMod ( string str , int n , int k ) { int i ; int [ ] pwrTwo = new int [ n ] ; pwrTwo [ 0 ] = 1 % k ; for ( i = 1 ; i < n ; i ++ ) { pwrTwo [ i ] = pwrTwo [ i - 1 ] * ( 2 % k ) ; pwrTwo [ i ] %= k ; } int res = 0 ; i = 0 ; int j = n - 1 ; while ( i < n ) { if ( str [ j ] == '1' ) { res += ( pwrTwo [ i ] ) ; res %= k ; } i ++ ; j -- ; } return res ; }
long countStrings ( int N ) { int i , j ; int [ , ] dp = new int [ N + 1 , 3 ] ; for ( i = 0 ; i < N + 1 ; i ++ ) { for ( j = 9 ; j < 3 ; j ++ ) { dp [ i , j ] = 0 ; } } dp [ 1 , 0 ] = 1 ; dp [ 1 , 1 ] = 1 ; dp [ 1 , 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { dp [ i , 0 ] = ( dp [ i - 1 , 0 ] + dp [ i - 1 , 1 ] + dp [ i - 1 , 2 ] ) % MOD ; dp [ i , 1 ] = dp [ i - 1 , 0 ] % MOD ; dp [ i , 2 ] = dp [ i - 1 , 1 ] % MOD ; } int ans = ( dp [ N , 0 ] + dp [ N , 1 ] + dp [ N , 2 ] ) % MOD ; return ans ; }
int getCount ( string str , int n ) { int cnt = 0 ; int i = 0 ; while ( i < n - 2 ) { if ( str [ i ] == str [ i + 1 ] && str [ i ] == str [ i + 2 ] ) { cnt ++ ; i = i + 2 ; } else { i ++ ; } } return cnt ; }
string maxNumber ( string str , int n ) { int [ ] freq = new int [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == 'z' ) { freq [ 0 ] ++ ; } else if ( str [ i ] == 'n' ) { freq [ 1 ] ++ ; } } string num = "" ; for ( int i = 0 ; i < freq [ 1 ] ; i ++ ) num += '1' ; for ( int i = 0 ; i < freq [ 0 ] ; i ++ ) num += '0' ; return num ; }
int fact ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact *= i ; return fact ; }
int countStrings ( String str , int n ) { HashSet < char > distinct_char = new HashSet < char > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { distinct_char . Add ( str [ i ] ) ; } return fact ( distinct_char . Count ) ; }
char getChar ( String str ) { int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { sum += ( str [ i ] - 'a' + 1 ) ; } if ( sum % 26 == 0 ) return 'z' ; else { sum = sum % 26 ; return ( char ) ( 'a' + sum - 1 ) ; } }
int countFreq ( String pat , String txt ) { int M = pat . Length ; int N = txt . Length ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) { break ; } } if ( j == M ) { res ++ ; j = 0 ; } } return res ; }
void findOccurrence ( int [ ] arr , int n , String pattern ) { for ( int i = 0 ; i < n ; i ++ ) { String binary = decToBinary ( arr [ i ] ) ; Console . Write ( countFreq ( pattern , binary ) + " " ) ; } }
void findNumbers ( String s ) { int n = s . Length ; int count = 1 ; int result = 0 ; int left = 0 ; int right = 1 ; while ( right < n ) { if ( s [ left ] == s [ right ] ) count ++ ; else { result += count * ( count + 1 ) / 2 ; left = right ; count = 1 ; } right ++ ; } result += count * ( count + 1 ) / 2 ; Console . WriteLine ( result ) ; }
void SieveOfEratosthenes ( bool [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < p_size ; i += p ) prime [ i ] = false ; } } }
bool canBeBalanced ( string s , int n ) { if ( n % 2 == 1 ) return false ; string k = "(" ; k += s + ")" ; List < string > d = new List < string > ( ) ; for ( int i = 0 ; i < k . Length ; i ++ ) { if ( k [ i ] == '(' ) d . Add ( "(" ) ; else { if ( d . Count != 0 ) d . RemoveAt ( d . Count - 1 ) ; else return false ; } } if ( d . Count == 0 ) return true ; return false ; }
int maxLenSubStr ( String s ) { if ( s . Length < 3 ) return s . Length ; int temp = 2 ; int ans = 2 ; for ( int i = 2 ; i < s . Length ; i ++ ) { if ( s [ i ] != s [ i - 1 ] s [ i ] != s [ i - 2 ] ) temp ++ ; else { ans = Math . Max ( temp , ans ) ; temp = 2 ; } } ans = Math . Max ( temp , ans ) ; return ans ; }
bool CompareAlphanumeric ( char [ ] str1 , char [ ] str2 ) { int i , j ; i = 0 ; j = 0 ; int len1 = str1 . Length ; int len2 = str2 . Length ; while ( i <= len1 && j <= len2 ) { while ( i < len1 && ( ! ( ( str1 [ i ] >= 'a' && str1 [ i ] <= 'z' ) || ( str1 [ i ] >= 'A' && str1 [ i ] <= 'Z' ) || ( str1 [ i ] >= '0' && str1 [ i ] <= '9' ) ) ) ) { i ++ ; } while ( j < len2 && ( ! ( ( str2 [ j ] >= 'a' && str2 [ j ] <= 'z' ) || ( str2 [ j ] >= 'A' && str2 [ j ] <= 'Z' ) || ( str2 [ j ] >= '0' && str2 [ j ] <= '9' ) ) ) ) { j ++ ; } if ( i == len1 && j == len2 ) { return true ; } else if ( str1 [ i ] != str2 [ j ] ) { return false ; } else { i ++ ; j ++ ; } } return false ; }
void expandString ( string strin ) { string temp = "" ; int j ; for ( int i = 0 ; i < strin . Length ; i ++ ) { if ( strin [ i ] >= 0 ) { int num = strin [ i ] - '0' ; if ( strin [ i + 1 ] == '(' ) { for ( j = i + 1 ; strin [ j ] != ')' ; j ++ ) { if ( ( strin [ j ] >= 'a' && strin [ j ] <= 'z' ) || ( strin [ j ] >= 'A' && strin [ j ] <= 'Z' ) ) { temp += strin [ j ] ; } } for ( int k = 1 ; k <= num ; k ++ ) { Console . Write ( temp ) ; } num = 0 ; temp = "" ; if ( j < strin . Length ) { i = j ; } } } } }
int countSubStr ( String s , int n ) { int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 5 && "geeks" . Equals ( s . Substring ( i , 5 ) ) ) { c1 ++ ; } if ( i < n - 3 && "for" . Equals ( s . Substring ( i , 3 ) ) ) { c2 = c2 + c1 ; } } return c2 ; }
bool isVowel ( char ch ) { ch = char . ToUpper ( ch ) ; return ( ch == 'A' ch == 'E' ch == 'I' ch == 'O' ch == 'U' ) ; }
string balancedBrackets ( string str ) { int dep = 0 ; int minDep = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == '(' ) dep ++ ; else dep -- ; if ( minDep > dep ) minDep = dep ; } if ( minDep < 0 ) { for ( int i = 0 ; i < Math . Abs ( minDep ) ; i ++ ) str = '(' + str ; } dep = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == '(' ) dep ++ ; else dep -- ; } if ( dep != 0 ) { for ( int i = 0 ; i < dep ; i ++ ) str = str + ')' ; } return str ; }
int minOperations ( string str , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ ( i ) ] != str [ ( i + 1 ) ] ) count ++ ; } return ( count + 1 ) / 2 ; }
int stringToInt ( String str ) { if ( str . Length == 1 ) return ( str [ 0 ] - '0' ) ; double y = stringToInt ( str . Substring ( 1 ) ) ; double x = str [ 0 ] - '0' ; x = x * Math . Pow ( 10 , str . Length - 1 ) + y ; return ( int ) ( x ) ; }
int largestSubSeq ( string [ ] arr , int n ) { int [ ] count = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { string str = arr [ i ] ; bool [ ] hash = new bool [ MAX ] ; for ( int j = 0 ; j < str . Length ; j ++ ) { hash [ str [ j ] - 'a' ] = true ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( hash [ j ] ) count [ j ] ++ ; } } int max = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( max < count [ i ] ) max = count [ i ] ; } return max ; }
int longest_substring ( String s , int k ) { int n = s . Length ; if ( k > 1 ) { s += s ; n *= 2 ; } int ans = 0 ; int i = 0 ; while ( i < n ) { int x = 0 ; while ( i < n && s [ i ] == '0' ) { x ++ ; i ++ ; } ans = Math . Max ( ans , x ) ; i ++ ; } if ( k == 1 ans != n ) return ans ; else return ( ans / 2 ) * k ; }
int Occurrence ( String s , int position ) { int count = 0 ; for ( int i = 0 ; i < position - 1 ; i ++ ) if ( s [ i ] == s [ position - 1 ] ) count ++ ; return count ; }
int countOccurrence ( String s , int position ) { int [ ] alpha = new int [ 26 ] ; int [ ] b = new int [ s . Length ] ; for ( int i = 0 ; i < s . Length ; i ++ ) { b [ i ] = alpha [ ( int ) s [ i ] - 97 ] ; alpha [ ( int ) s [ i ] - 97 ] ++ ; } return b [ position - 1 ] ; }
void find_permutation ( String str1 , String str2 , int len1 , int len2 , int i , int j , String res ) { if ( res . Length == len1 + len2 ) { stringSet . Add ( res ) ; return ; } if ( i < len1 ) find_permutation ( str1 , str2 , len1 , len2 , i + 1 , j , res + str1 [ i ] ) ; if ( j < len2 ) find_permutation ( str1 , str2 , len1 , len2 , i , j + 1 , res + str2 [ j ] ) ; }
bool canConvert ( string str1 , string str2 ) { int i = 0 , j = 0 ; while ( i < str1 . Length && j < str2 . Length ) { if ( str1 [ i ] != str2 [ j ] ) { if ( str1 [ i ] == '0' && str2 [ j ] == '1' && i + 1 < str1 . Length && str1 [ i + 1 ] == '0' ) { i += 2 ; j ++ ; } else { return false ; } } else { i ++ ; j ++ ; } } if ( i == str1 . Length && j == str2 . Length ) return true ; return false ; }
void reverse ( string s ) { Stack stc = new Stack ( ) ; string temp = "" ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == ' ' ) { stc . Push ( temp ) ; temp = "" ; } else { temp = temp + s [ i ] ; } } stc . Push ( temp ) ; while ( stc . Count != 0 ) { temp = ( string ) stc . Peek ( ) ; Console . Write ( temp + " " ) ; stc . Pop ( ) ; } Console . WriteLine ( ) ; }
int countPairs ( char [ ] str , int k ) { int n = str . Length ; int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str [ i ] - 'a' ] ++ ; } int cnt = 0 ; if ( k == 0 ) { for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] > 1 ) { cnt += ( ( freq [ i ] * ( freq [ i ] - 1 ) ) / 2 ) ; } } } else { for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] > 0 && i + k < MAX && freq [ i + k ] > 0 ) { cnt += ( freq [ i ] * freq [ i + k ] ) ; } } ; } return cnt ; }
void printUncommon ( string str1 , string str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . Length ; i ++ ) { int ch = ( str1 [ i ] - 'a' ) ; a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . Length ; i ++ ) { int ch = ( str2 [ i ] - 'a' ) ; a2 = a2 | ( 1 << ch ) ; } int ans = a1 ^ a2 ; int j = 0 ; while ( j < 26 ) { if ( ans % 2 == 1 ) { Console . Write ( ( char ) ( 'a' + j ) ) ; } ans = ans / 2 ; j ++ ; } }
bool isPalin ( int i , int j , int k , int l , int p , int q , String s ) { int start = i , end = q ; while ( start < end ) { if ( s [ start ] != s [ end ] ) { return false ; } start ++ ; if ( start == j + 1 ) { start = k ; } end -- ; if ( end == p - 1 ) { end = l ; } } return true ; }
int countSubStr ( String s ) { int count = 0 ; int n = s . Length ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k ; l < n - 1 ; l ++ ) { for ( int p = l + 1 ; p < n ; p ++ ) { for ( int q = p ; q < n ; q ++ ) { if ( isPalin ( i , j , k , l , p , q , s ) ) { count ++ ; } } } } } } } return count ; }
bool isPrime ( int n ) { if ( n == 0 n == 1 ) { return false ; } for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
int sumAscii ( string str , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( i + 1 ) ) { sum += ( int ) ( str [ i ] ) ; } } return sum ; }
bool Pangram ( String x ) { Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; int n = x . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( x [ i ] ) ) { mp [ x [ i ] ] = mp [ x [ i ] ] + 1 ; } else { mp . Add ( x [ i ] , 1 ) ; } } if ( mp . Count == 26 ) return true ; else return false ; }
int countTotalPangram ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( Pangram ( weight [ i ] ) ) cnt ++ ; return cnt ; }
void dfs ( int node , int parent ) { foreach ( int to in graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; weight [ node ] += weight [ to ] ; } }
bool uniqueChars ( char [ ] arr ) { Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; int n = arr . Length ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } if ( mp . Count == arr . Length ) return true ; else return false ; }
void dfs ( int node , int parent ) { if ( uniqueChars ( weight [ node ] . ToCharArray ( ) ) ) cnt += 1 ; foreach ( int to in graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } }
void preCalculate ( string str , int n ) { freq [ ( int ) str [ 0 ] , 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { char ch = str [ i ] ; for ( int j = 0 ; j < MAX ; j ++ ) { char charToUpdate = ( char ) j ; if ( charToUpdate == ch ) freq [ j , i ] = freq [ j , i - 1 ] + 1 ; else freq [ j , i ] = freq [ j , i - 1 ] ; } } }
int getFrequency ( char ch , int l , int r ) { if ( l == 0 ) return freq [ ( int ) ch , r ] ; else return ( freq [ ( int ) ch , r ] - freq [ ( int ) ch , l - 1 ] ) ; }
bool isValid ( string s ) { if ( ( s . IndexOf ( "geek" ) != - 1 ) && ( s . IndexOf ( "keeg" , s . IndexOf ( "geek" ) + 4 ) != - 1 ) ) return true ; return false ; }
bool isTwoAlter ( string s ) { for ( int i = 0 ; i < s . Length - 2 ; i ++ ) { if ( s [ i ] != s [ i + 2 ] ) { return false ; } } if ( s [ 0 ] == s [ 1 ] ) return false ; return true ; }
int findCount ( string s , int n , int a , int b ) { int res = 0 ; for ( int i = 0 ; i < b ; i ++ ) { if ( i == a ) { if ( s [ n - i - 1 ] != '1' ) res += 1 ; } else { if ( s [ n - i - 1 ] != '0' ) res += 1 ; } } return res ; }
int lenoflongestnonpalindrome ( String s ) { int max1 = 1 , len = 0 ; char [ ] new_str = s . ToCharArray ( ) ; for ( int i = 0 ; i < new_str . Length - 1 ; i ++ ) { if ( new_str [ i ] == new_str [ i + 1 ] ) len = 0 ; else if ( i > 0 && ( new_str [ i + 1 ] == new_str [ i - 1 ] ) ) len = 1 ; len ++ ; } if ( max1 == 1 ) return 0 ; else return max1 ; }
int calcScore ( String str ) { int score = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; ) { int chunkSize = 1 ; char currentChar = str [ i ++ ] ; while ( i < len && str [ i ] == currentChar ) { chunkSize ++ ; i ++ ; } if ( currentChar == '1' ) score += ( int ) Math . Pow ( chunkSize , 2 ) ; else score -= ( int ) Math . Pow ( chunkSize , 2 ) ; } return score ; }
void pre_process ( String [ ] substrings , String s ) { int n = s . Length ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String dup = "" ; for ( int j = i ; j < n ; j ++ ) { dup += s [ j ] ; substrings [ count ++ ] = dup ; } } int size = substrings . Length ; for ( int i = 0 ; i < size - 1 ; i ++ ) { for ( int j = i + 1 ; j < substrings . Length ; j ++ ) { if ( substrings [ i ] . CompareTo ( substrings [ j ] ) > 0 ) { String temp = substrings [ i ] ; substrings [ i ] = substrings [ j ] ; substrings [ j ] = temp ; } } } }
bool check ( String s ) { int n = s . Length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) return true ; } return false ; }
int countSubString ( char [ ] s , char c , int k ) { int leftCount = 0 , rightCount = 0 ; int left = 0 , right = 0 ; int freq = 0 ; int result = 0 , len = s . Length ; while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } right = left + 1 ; while ( freq != ( k - 1 ) && ( right - 1 ) < len ) { if ( s [ right ] == c ) freq ++ ; right ++ ; } while ( left < len && ( right - 1 ) < len ) { while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } while ( right < len && s [ right ] != c ) { if ( s [ right ] == c ) freq ++ ; right ++ ; rightCount ++ ; } result = result + ( leftCount + 1 ) * ( rightCount + 1 ) ; freq = k - 1 ; leftCount = 0 ; rightCount = 0 ; left ++ ; right ++ ; } return result ; }
int performQueries ( int l , int r , int [ , ] prefix ) { l -- ; r -- ; bool flag = false ; int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int cnt = prefix [ r , i ] ; if ( l > 0 ) cnt -= prefix [ l - 1 , i ] ; if ( cnt % 2 == 1 ) { flag = true ; count += cnt - 1 ; } else count += cnt ; } if ( flag ) count += 1 ; return count ; }
void printSmallSub ( int [ ] arr , int N ) { int gcdArr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { gcdArr = gcd ( gcdArr , arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == gcdArr ) { Console . Write ( arr [ i ] + " " ) ; return ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( gcd ( arr [ i ] , arr [ j ] ) == gcdArr ) { Console . Write ( arr [ i ] + " " + arr [ j ] ) ; return ; } } } }
int countSubStr ( String str , int n , char x ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; }
bool isValid ( String str , int n ) { if ( ! ( ( str [ 0 ] >= 'a' && str [ 0 ] <= 'z' ) || ( str [ 0 ] >= 'A' && str [ 0 ] <= 'Z' ) str [ 0 ] == '_' ) ) return false ; for ( int i = 1 ; i < str . Length ; i ++ ) { if ( ! ( ( str [ i ] >= 'a' && str [ i ] <= 'z' ) || ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) || ( str [ i ] >= '0' && str [ i ] <= '9' ) str [ i ] == '_' ) ) return false ; } return true ; }
int countSubStr ( string str , int n ) { int len = str . Length ; return ( len - n + 1 ) ; }
int countSubstrings ( string s , char c ) { int n = s . Length ; int cnt = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; }
bool equalIgnoreCase ( String str1 , String str2 ) { str1 = str1 . ToUpper ( ) ; str2 = str2 . ToUpper ( ) ; int x = str1 . CompareTo ( str2 ) ; if ( x != 0 ) { return false ; } else { return true ; } }
void equalIgnoreCaseUtil ( String str1 , String str2 ) { bool res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) { Console . WriteLine ( "Same" ) ; } else { Console . WriteLine ( "Not Same" ) ; } }
bool equalIgnoreCase ( String str1 , String str2 ) { str1 = str1 . ToUpper ( ) ; str2 = str2 . ToUpper ( ) ; int x = str1 . CompareTo ( str2 ) ; if ( x != 0 ) { return false ; } else { return true ; } }
void equalIgnoreCaseUtil ( String str1 , String str2 ) { bool res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) { Console . WriteLine ( "Same" ) ; } else { Console . WriteLine ( "Not Same" ) ; } }
int findM ( String s , int x ) { int cnt = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] - '0' != x ) cnt ++ ; } return cnt ; }
void FirstAndLast ( string str ) { int i ; for ( i = 0 ; i < str . Length ; i ++ ) { if ( i == 0 ) Console . Write ( str [ i ] ) ; if ( i == str . Length - 1 ) Console . Write ( str [ i ] ) ; if ( str [ i ] == ' ' ) { Console . Write ( str [ i - 1 ] + " " + str [ i + 1 ] ) ; } } }
void Longestsubstring ( string s ) { int [ ] lps = compute_lps ( s ) ; int n = s . Length ; if ( lps [ n - 1 ] == 0 ) { Console . WriteLine ( - 1 ) ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( lps [ i ] == lps [ n - 1 ] ) { Console . WriteLine ( s . Substring ( 0 , lps [ i ] ) ) ; return ; } } if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) Console . WriteLine ( - 1 ) ; else Console . WriteLine ( s . Substring ( 0 , lps [ lps [ n - 1 ] - 1 ] ) ) ; }
int getBitmask ( char [ ] s ) { int temp = 0 ; for ( int j = 0 ; j < s . Length ; j ++ ) { switch ( s [ j ] ) { case 's' : temp = temp | ( 1 ) ; break ; case 't' : temp = temp | ( 2 ) ; break ; case 'r' : temp = temp | ( 4 ) ; break ; case 'i' : temp = temp | ( 8 ) ; break ; case 'n' : temp = temp | ( 16 ) ; break ; case 'g' : temp = temp | ( 32 ) ; break ; default : break ; } } return temp ; }
int calculateWays ( String s , int n , int l , int r ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < l i > r ) freq [ s [ i ] - 'a' ] ++ ; } int ways = 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( freq [ s [ i ] - 'a' ] != 0 ) { ways = ways * freq [ s [ i ] - 'a' ] ; freq [ s [ i ] - 'a' ] -- ; } else { ways = 0 ; break ; } } return ways ; }
void asciiToSentence ( String str , int len ) { int num = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str [ i ] - '0' ) ; if ( num >= 32 && num <= 122 ) { char ch = ( char ) num ; Console . Write ( ch ) ; num = 0 ; } } }
int countDistinctCode ( String str ) { HashSet < String > codes = new HashSet < String > ( ) ; for ( int i = 0 ; i < str . Length - 1 ; i ++ ) codes . Add ( str . Substring ( i , 2 ) ) ; return codes . Count ; }
bool isReverseEqual ( String s1 , String s2 ) { if ( s1 . Length != s2 . Length ) return false ; int len = s1 . Length ; for ( int i = 0 ; i < len ; i ++ ) if ( s1 [ i ] != s2 [ len - i - 1 ] ) return false ; return true ; }
bool isPrefix ( String str , int len , int i , int k ) { if ( i + k > len ) return false ; for ( int j = 0 ; j < k ; j ++ ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; } return true ; }
bool isKPeriodic ( String str , int len , int k ) { for ( int i = k ; i < len ; i += k ) if ( ! isPrefix ( str , len , i , k ) ) return false ; return true ; }
bool isFrequencyEqual ( String str , int len ) { if ( len % 2 == 1 ) { return false ; } int i ; int [ ] freq = new int [ 26 ] ; for ( i = 0 ; i < len ; i ++ ) { freq [ str [ i ] - 'a' ] ++ ; } for ( i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == len / 2 ) { return true ; } } return false ; }
int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; }
int countMinReversals ( String expr ) { int len = expr . Length ; if ( len % 2 != 0 ) return - 1 ; int ans = 0 ; int i ; int open = 0 ; int close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == '{' ) open ++ ; else { if ( open == 0 ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close != 0 ) ans += 2 ; return ans ; }
int minReplacement ( String s , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s [ i ] == '1' ) ans ++ ; if ( i % 2 == 1 && s [ i ] == '0' ) ans ++ ; } return Math . Min ( ans , len - ans ) ; }
int maxBalancedStr ( string s ) { int open1 = 0 , close1 = 0 ; int open2 = 0 , close2 = 0 ; int open3 = 0 , close3 = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { switch ( s [ i ] ) { case '(' : open1 ++ ; break ; case ')' : close1 ++ ; break ; case '{' : open2 ++ ; break ; case '}' : close2 ++ ; break ; case '[' : open3 ++ ; break ; case ']' : close3 ++ ; break ; } } int maxLen = 2 * Math . Min ( open1 , close1 ) + 2 * Math . Min ( open2 , close2 ) + 2 * Math . Min ( open3 , close3 ) ; return maxLen ; }
int totalPairs ( string s1 , string s2 ) { int count = 0 ; int [ ] arr1 = new int [ 7 ] ; int [ ] arr2 = new int [ 7 ] ; for ( int i = 0 ; i < s1 . Length ; i ++ ) { int set_bits = Convert . ToString ( ( int ) s1 [ i ] , 2 ) . Count ( c => c == '1' ) ; arr1 [ set_bits ] ++ ; } for ( int i = 0 ; i < s2 . Length ; i ++ ) { int set_bits = Convert . ToString ( ( int ) s2 [ i ] , 2 ) . Count ( c => c == '1' ) ; arr2 [ set_bits ] ++ ; } for ( int i = 1 ; i <= 6 ; i ++ ) count += ( arr1 [ i ] * arr2 [ i ] ) ; return count ; }
int findCost ( string s1 , string s2 , int a , int b , int c , int d , int n ) { int cost = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; else { if ( ( s1 [ i ] == '1' && s2 [ i ] == '2' ) || ( s2 [ i ] == '1' && s1 [ i ] == '2' ) ) cost += Math . Min ( d , Math . Min ( a , b + c ) ) ; else if ( ( s1 [ i ] == '2' && s2 [ i ] == '3' ) || ( s2 [ i ] == '2' && s1 [ i ] == '3' ) ) cost += Math . Min ( d , Math . Min ( b , a + c ) ) ; else if ( ( s1 [ i ] == '1' && s2 [ i ] == '3' ) || ( s2 [ i ] == '1' && s1 [ i ] == '3' ) ) cost += Math . Min ( d , Math . Min ( c , a + b ) ) ; } } return cost ; }
int totalPairs ( String s1 , String s2 ) { int a1 = 0 , b1 = 0 ; for ( int i = 0 ; i < s1 . Length ; i ++ ) { if ( ( int ) s1 [ i ] % 2 != 0 ) a1 ++ ; else b1 ++ ; } int a2 = 0 , b2 = 0 ; for ( int i = 0 ; i < s2 . Length ; i ++ ) { if ( ( int ) s2 [ i ] % 2 != 0 ) a2 ++ ; else b2 ++ ; } return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; }
string replaceConsonants ( string str ) { string res = "" ; int i = 0 , count = 0 ; while ( i < str . Length ) { if ( str [ i ] != 'a' && str [ i ] != 'e' && str [ i ] != 'i' && str [ i ] != 'o' && str [ i ] != 'u' ) { i ++ ; count ++ ; } else { if ( count > 0 ) { res += count ; } res += str [ i ] ; i ++ ; count = 0 ; } } if ( count > 0 ) { res += count ; } return res ; }
int prefixOccurrences ( string str ) { char c = str [ 0 ] ; int countc = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == c ) countc ++ ; } return countc ; }
int Preprocess ( string A , string B ) { int n = A . Length ; int ans = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; if ( mp . ContainsKey ( A [ i ] ) ) mp [ A [ i ] ] ++ ; else mp [ A [ i ] ] = 1 ; if ( mp . ContainsKey ( A [ n - i - 1 ] ) ) mp [ A [ n - i - 1 ] ] ++ ; else mp [ A [ n - i - 1 ] ] = 1 ; if ( mp . ContainsKey ( B [ i ] ) ) mp [ B [ i ] ] ++ ; else mp [ B [ i ] ] = 1 ; if ( mp . ContainsKey ( B [ n - i - 1 ] ) ) mp [ B [ n - i - 1 ] ] ++ ; else mp [ B [ n - i - 1 ] ] = 1 ; int sz = mp . Count ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A [ i ] == A [ n - i - 1 ] ? 1 : 0 ) ; else if ( sz == 2 ) ans += mp [ A [ i ] ] != 2 ? 1 : 0 ; } if ( n % 2 == 1 && A [ n / 2 ] != B [ n / 2 ] ) ans ++ ; return ans ; }
bool isPalindrome ( string s ) { int i = 0 ; int j = s . Length - 1 ; while ( i < j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; }
int getIndex ( string S1 , string S2 , int n ) { string S = "" ; for ( int i = 0 ; i < n ; i ++ ) { S = S + S1 [ i ] ; string Temp = "" ; for ( int j = i + 1 ; j < n ; j ++ ) Temp += S2 [ j ] ; if ( isPalindrome ( S + Temp ) ) { return i ; } } return - 1 ; }
bool isPalindrome ( string s , int i , int j ) { while ( i < j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; }
bool isVowel ( char c ) { if ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) return true ; return false ; }
bool checkPossibility ( string s1 , string s2 ) { int l1 = s1 . Length ; int l2 = s2 . Length ; if ( l1 != l2 ) return false ; for ( int i = 0 ; i < l1 ; i ++ ) { if ( isVowel ( s1 [ i ] ) && isVowel ( s2 [ i ] ) ) continue ; else if ( ! ( isVowel ( s1 [ i ] ) ) && ! ( isVowel ( s2 [ i ] ) ) ) continue ; else return false ; } return true ; }
void generateString ( int A , int B ) { string rt = "" ; while ( 0 < A 0 < B ) { if ( A < B ) { if ( 0 < B -- ) { rt += ( 'b' ) ; } if ( 0 < B -- ) { rt += ( 'b' ) ; } if ( 0 < A -- ) { rt += ( 'a' ) ; } } else if ( B < A ) { if ( 0 < A -- ) { rt += ( 'a' ) ; } if ( 0 < A -- ) { rt += ( 'a' ) ; } if ( 0 < B -- ) { rt += ( 'b' ) ; } } else { if ( 0 < A -- ) { rt += ( 'a' ) ; } if ( 0 < B -- ) { rt += ( 'b' ) ; } } } Console . WriteLine ( rt ) ; }
int countStrings ( int n , int m , String [ ] s ) { HashSet < int > ind = new HashSet < int > ( ) ; for ( int j = 0 ; j < m ; j ++ ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) mx = Math . Max ( mx , ( int ) ( s [ i ] [ j ] - '0' ) ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] [ j ] - '0' == mx ) ind . Add ( i ) ; } return ind . Count ; }
int minOperations ( string s , string t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == t [ i ] ) continue ; if ( s [ i ] == '0' ) ct0 ++ ; else ct1 ++ ; } return Math . Max ( ct0 , ct1 ) ; }
int count_acronym ( int n , string [ ] arr ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] [ 0 ] - 'a' ] ++ ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string st = arr [ i ] ; int [ ] num = new int [ 26 ] ; for ( int j = 0 ; j < st . Length ; j ++ ) num [ st [ j ] - 'a' ] ++ ; bool flag = true ; for ( int j = 1 ; j < 26 ; j ++ ) { if ( num [ j ] > freq [ j ] ) { flag = false ; break ; } } int x = st [ 0 ] - 'a' ; if ( freq [ x ] - 1 < num [ x ] ) flag = false ; if ( flag ) cnt ++ ; } return cnt ; }
int minOperations ( string str , int n ) { int i , lastUpper = - 1 , firstLower = - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( Char . IsUpper ( str [ i ] ) ) { lastUpper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( Char . IsLower ( str [ i ] ) ) { firstLower = i ; break ; } } if ( lastUpper == - 1 firstLower == - 1 ) return 0 ; int countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( Char . IsUpper ( str [ i ] ) ) { countUpper ++ ; } } int countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( Char . IsLower ( str [ i ] ) ) { countLower ++ ; } } return Math . Min ( countLower , countUpper ) ; }
bool check ( string s , int k ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] != s [ i % k ] ) { return false ; } } return true ; }
int countCommonDivisors ( string a , string b ) { int ct = 0 ; int n = a . Length , m = b . Length ; for ( int i = 1 ; i <= Math . Min ( n , m ) ; i ++ ) { if ( n % i == 0 && m % i == 0 ) { if ( a . Substring ( 0 , i ) == ( b . Substring ( 0 , i ) ) ) { if ( check ( a , i ) && check ( b , i ) ) { ct ++ ; } } } } return ct ; }
bool valid ( int [ ] cnt ) { for ( int i = 0 ; i < 26 ; i ++ ) { if ( cnt [ i ] >= 2 ) return false ; } return true ; }
bool isVowel ( char c ) { c = char . ToLower ( c ) ; if ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) { return true ; } return false ; }
string largestPalinSub ( string s ) { string res = "" ; char mx = s [ 0 ] ; for ( int i = 1 ; i < s . Length ; i ++ ) mx = ( char ) Math . Max ( ( int ) mx , ( int ) s [ i ] ) ; for ( int i = 0 ; i < s . Length ; i ++ ) if ( s [ i ] == mx ) res += s [ i ] ; return res ; }
bool isValid ( string str , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; } return true ; }
string decryptString ( string str , int n ) { int i = 0 , jump = 1 ; string decryptedStr = "" ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; }
int countSubStr ( String str , int len , int k ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int n = 0 ; for ( int j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] - '0' ) ; if ( n % k == 0 ) count ++ ; } } return count ; }
int nextZero ( int i , int [ ] occurrences ) { while ( i < occurrences . Length ) { if ( occurrences [ i ] == 0 ) return i ; i ++ ; } return - 1 ; }
int findPermutation ( string str , int k ) { bool [ ] has = new bool [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) has [ i ] = false ; int cnt = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( ! has [ str [ i ] - 'a' ] ) { cnt ++ ; has [ str [ i ] - 'a' ] = true ; } } int ans = 1 ; for ( int i = 2 ; i <= cnt ; i ++ ) ans *= i ; for ( int i = cnt - k ; i > 1 ; i -- ) ans /= i ; return ans ; }
int countPairs ( string [ ] bracks , int num ) { Dictionary < int , int > open = new Dictionary < int , int > ( ) ; Dictionary < int , int > close = new Dictionary < int , int > ( ) ; int cnt = 0 ; for ( int i = 0 ; i < num ; i ++ ) { string s = bracks [ i ] ; int l = s . Length ; int op = 0 , cl = 0 ; for ( int j = 0 ; j < l ; j ++ ) { if ( s [ j ] == '(' ) op ++ ; else { if ( op != 0 ) op -- ; else cl ++ ; } } if ( op != 0 && cl == 0 ) { if ( open . ContainsKey ( op ) ) { open [ op ] ++ ; } else { open [ op ] = 1 ; } } if ( cl != 0 && op == 0 ) { if ( close . ContainsKey ( cl ) ) { close [ cl ] ++ ; } else { close [ cl ] = 1 ; } } if ( op == 0 && cl == 0 ) cnt ++ ; } cnt /= 2 ; foreach ( KeyValuePair < int , int > it in open ) { cnt += Math . Min ( it . Value , close [ it . Value ] ) ; } return cnt ; }
int no_of_ways ( string s ) { int n = s . Length ; int count_left = 0 , count_right = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == s [ 0 ] ) { ++ count_left ; } else break ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == s [ n - 1 ] ) { ++ count_right ; } else break ; } if ( s [ 0 ] == s [ n - 1 ] ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ; else return ( count_left + count_right + 1 ) ; }
bool isPalindrome ( string str ) { int len = str . Length ; for ( int i = 0 ; i < len / 2 ; i ++ ) { if ( str [ i ] != str [ len - 1 - i ] ) return false ; } return true ; }
bool createStringAndCheckPalindrome ( int N ) { string sub = "" + N , res_str = "" ; int sum = 0 ; while ( N > 0 ) { int digit = N % 10 ; sum += digit ; N = N / 10 ; } while ( res_str . Length < sum ) res_str += sub ; if ( res_str . Length > sum ) res_str = res_str . Substring ( 0 , sum ) ; if ( isPalindrome ( res_str ) ) return true ; return false ; }
int product ( int x ) { int prod = 1 ; while ( x > 0 ) { prod *= ( x % 10 ) ; x /= 10 ; } return prod ; }
string removeChars ( string s ) { string modifiedStr = "" ; modifiedStr += s [ 0 ] ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( char . IsUpper ( s [ i ] ) && char . IsLower ( s [ i - 1 ] ) || char . IsLower ( s [ i ] ) && char . IsUpper ( s [ i - 1 ] ) ) modifiedStr += s [ i ] ; } return modifiedStr ; }
int pangramCost ( int [ ] arr , string str ) { int cost = 0 ; bool [ ] occurred = new bool [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) occurred [ i ] = false ; for ( int i = 0 ; i < str . Length ; i ++ ) occurred [ str [ i ] - 'a' ] = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( occurred [ i ] == false ) cost += arr [ i ] ; } return cost ; }
void pairStar ( String input , int i ) { output = output + input [ i ] ; if ( i == input . Length - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + '*' ; pairStar ( input , i + 1 ) ; }
int countMinParts ( String str ) { int n = str . Length ; int [ ] freq = getFrequencies ( str ) ; List < int > oddFreq = new List < int > ( ) ; List < int > evenFreq = new List < int > ( ) ; int i , sumEven = 0 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) continue ; if ( freq [ i ] % 2 == 0 ) evenFreq . Add ( freq [ i ] ) ; else oddFreq . Add ( freq [ i ] ) ; } for ( i = 0 ; i < evenFreq . Count ; i ++ ) { sumEven += evenFreq [ i ] ; } if ( oddFreq . Count == 0 ) return 1 ; if ( sumEven == 0 ) { if ( oddFreq . Count == 1 ) return 1 ; return 0 ; } i = 0 ; while ( i < oddFreq . Count ) { if ( ( sumEven / 2 ) % oddFreq . Count == 0 ) return oddFreq . Count ; if ( oddFreq [ i ] == 1 ) { i ++ ; continue ; } sumEven += 2 ; oddFreq . Insert ( i , oddFreq [ i ] - 2 ) ; } return n ; }
int check ( String s , int K ) { for ( int ch = 0 ; ch < 26 ; ch ++ ) { char c = ( char ) ( 'a' + ch ) ; int last = - 1 ; bool found = true ; for ( int i = 0 ; i < K ; i ++ ) if ( s [ i ] == c ) last = i ; if ( last == - 1 ) continue ; for ( int i = K ; i < s . Length ; i ++ ) { if ( s [ i ] == c ) last = i ; if ( last <= ( i - K ) ) { found = false ; break ; } } if ( found ) return 1 ; } return 0 ; }
int binarySearch ( String s ) { int low = 1 , high = s . Length ; int ans = 0 ; while ( low <= high ) { int mid = ( high + low ) >> 1 ; if ( check ( s , mid ) == 1 ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; }
int subStringsStartingHere ( String str , int n , int startIndex ) { int count = 0 , i = startIndex + 1 ; while ( i <= n ) { if ( str . StartsWith ( str . Substring ( startIndex , i - startIndex ) ) ) { count ++ ; } else break ; i ++ ; } return count ; }
void printExpansion ( String str ) { for ( int i = ( int ) str . Length - 1 ; i >= 0 ; i -- ) { String subStr = str . Substring ( i ) ; Console . Write ( subStr ) ; } }
void printExpansion ( String str ) { String suff = "" ; for ( int i = str . Length - 1 ; i >= 0 ; i -- ) { suff = suff + str [ i ] ; Console . Write ( suff ) ; } }
bool search ( String pat , String txt ) { int M = pat . Length ; int N = txt . Length ; int i ; char [ ] countP = new char [ ALL_CHARS ] ; char [ ] countTW = new char [ ALL_CHARS ] ; for ( i = 0 ; i < M ; i ++ ) { ( countP [ pat [ i ] ] ) ++ ; ( countTW [ txt [ i ] ] ) ++ ; } for ( i = M ; i < N ; i ++ ) { if ( compare ( countP , countTW ) ) { return true ; } ( countTW [ txt [ i ] ] ) ++ ; countTW [ txt [ i - M ] ] -- ; } if ( compare ( countP , countTW ) ) return true ; return false ; }
char logicalExpressionEvaluation ( String str ) { Stack < char > arr = new Stack < char > ( ) ; for ( int i = str . Length - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '[' ) { List < char > s = new List < char > ( ) ; while ( arr . Peek ( ) != ']' ) { s . Add ( arr . Peek ( ) ) ; arr . Pop ( ) ; } arr . Pop ( ) ; if ( s . Count == 3 ) { arr . Push ( s [ 2 ] == '1' ? '0' : '1' ) ; } else if ( s . Count == 5 ) { int a = s [ 0 ] - 48 , b = s [ 4 ] - 48 , c ; if ( s [ 2 ] == '&' ) { c = a & b ; } else { c = a | b ; } arr . Push ( ( char ) ( c + 48 ) ) ; } } else { arr . Push ( str [ i ] ) ; } } return arr . Peek ( ) ; }
int count ( string s , int k ) { int n = s . Length ; int d = 0 , i ; int count = 0 ; for ( i = 0 ; i < n ; i ++ ) d += s [ i ] ; if ( d % k == 0 ) count += 1 ; for ( i = k ; i < n ; i ++ ) { int prev = s [ i - k ] ; d -= prev ; d += s [ i ] ; if ( d % k == 0 ) count += 1 ; } return count ; }
string MaxFreq ( string str ) { int n = str . Length ; Dictionary < string , int > m = new Dictionary < string , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { string sp = "" ; for ( int j = i ; j < n ; j ++ ) { sp += str [ j ] ; if ( m . ContainsKey ( sp ) ) { m [ sp ] ++ ; } else { m [ sp ] = 1 ; } } } int maxi = 0 ; string s = "" ; foreach ( KeyValuePair < string , int > i in m ) { if ( i . Value > maxi ) { maxi = i . Value ; s = i . Key ; } else if ( i . Value == maxi ) { string ss = i . Key ; if ( ss . Length > s . Length ) s = ss ; } } return s ; }
void preCompute ( int n , string s , int [ ] pref ) { pref [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { pref [ i ] = pref [ i - 1 ] ; if ( s [ i - 1 ] == s [ i ] ) pref [ i ] ++ ; } }
int query ( int [ ] pref , int l , int r ) { return pref [ r ] - pref [ l ] ; }
int countWays ( string s1 , string s2 , int n ) { int a , b , c , d ; a = b = c = d = 0 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s2 [ i ] == '0' ) { if ( s1 [ i ] == '0' ) { c ++ ; } else { d ++ ; } } else { if ( s1 [ i ] == '0' ) { a ++ ; } else { b ++ ; } } } result = a * d + b * c + c * d ; return result ; }
bool isPrime ( int n ) { int i ; if ( n == 1 ) { return false ; } for ( i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
bool check_frequency ( char [ ] s ) { Dictionary < char , int > m = new Dictionary < char , int > ( ) ; { if ( m . ContainsKey ( s [ i ] ) ) { var c = m [ s [ i ] ] + 1 ; m . Remove ( s [ i ] ) ; m . Add ( s [ i ] , c ) ; } else { m . Add ( s [ i ] , 1 ) ; } } for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { if ( m . ContainsKey ( ch ) && m [ ch ] > 0 && ! isPrime ( m [ ch ] ) ) { return false ; } } return true ; }
int returnWinner ( String s , int l ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < l ; i ++ ) { freq [ s [ i ] - 'a' ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] % 2 != 0 ) cnt ++ ; } if ( ( cnt == 0 ) || ( cnt & 1 ) == 1 ) return 1 ; else return 2 ; }
int check ( string s ) { int i , j ; int [ ] fr = new int [ 26 ] ; int n = s . Length ; for ( i = 0 ; i < n ; i ++ ) { char x = s [ i ] ; fr [ x - 'a' ] += 1 ; } int minimum = int . MaxValue ; for ( i = 0 ; i < 26 ; i ++ ) { for ( j = i + 1 ; j < 26 ; j ++ ) { int z = fr [ i ] + fr [ j ] ; minimum = Math . Min ( minimum , n - z ) ; } } return minimum ; }
int findSubstringCount ( string str ) { int result = 0 ; int n = str . Length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( char ) ( str [ i ] + 1 ) == str [ i + 1 ] ) { result ++ ; while ( ( char ) ( str [ i ] + 1 ) == str [ i + 1 ] ) { i ++ ; } } } return result ; }
int CountCharacters ( string str , int l , int r ) { int cnt = 0 ; Dictionary < char , int > m = new Dictionary < char , int > ( ) ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] && str [ i ] <= r ) ) { cnt ++ ; if ( ! m . ContainsKey ( str [ i ] ) ) { m [ str [ i ] ] = 0 ; Console . Write ( str [ i ] + " " ) ; } m [ str [ i ] ] ++ ; } } return cnt ; }
int strScore ( String [ ] str , String s , int n ) { int score = 0 , index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( int j = 0 ; j < s . Length ; j ++ ) score += s [ j ] - 'a' + 1 ; index = i + 1 ; break ; } } score = score * index ; return score ; }
int countChar ( string str , char x ) { int count = 0 ; int n = 10 ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( str [ i ] == x ) count ++ ; int repetitions = n / str . Length ; count = count * repetitions ; for ( int i = 0 ; i < n % str . Length ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; }
int countConsecutive ( String s ) { int count = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { i ++ ; } else { count ++ ; } } return count ; }
int check_digits ( int n ) { while ( n != 0 ) { return 0 ; n /= 10 ; } return 1 ; }
int smallest_number ( int n ) { for ( int i = n ; ; i ++ ) if ( check_digits ( i ) == 1 ) return i ; }
int minSteps ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . Length - 2 ; i ++ ) { if ( ( ( int ) str [ i ] ) == '0' ) { if ( str [ i + 1 ] == '1' ) { if ( str [ i + 2 ] == '0' ) { count ++ ; i += 2 ; } } } } return count ; }
void SieveOfEratosthenes ( Boolean [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
int xorOfPrime ( char [ ] s ) { Boolean [ ] prime = new Boolean [ 100005 ] ; for ( int i = 0 ; i < 100005 ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , 10005 ) ; Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( mp . ContainsKey ( s [ i ] ) ) { var v = mp [ s [ i ] ] + 1 ; mp . Remove ( s [ i ] ) ; mp . Add ( s [ i ] , v ) ; } else { mp . Add ( s [ i ] , 1 ) ; } } int result = 0 ; int flag = 0 ; foreach ( KeyValuePair < char , int > entry in mp ) { if ( prime [ entry . Value ] ) { result ^= entry . Value ; flag = 1 ; } } if ( flag != 1 ) return - 1 ; return result ; }
int CountCharacters ( String str , int k ) { int cnt = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( ( ( int ) str [ i ] ) < k ) cnt ++ ; } return cnt ; }
void dfs ( String node , int k , String A ) { for ( int i = 0 ; i < k ; ++ i ) { String str = node + A [ i ] ; if ( ! seen . Contains ( str ) ) { seen . Add ( str ) ; dfs ( str . Substring ( 1 ) , k , A ) ; edges . Add ( i ) ; } } }
int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { f = f * i ; } return f ; }
int npr ( int n , int r ) { return fact ( n ) / fact ( n - r ) ; }
bool checkIfUnequal ( int n , int q ) { string s1 = n . ToString ( ) ; int [ ] a = new int [ 26 ] ; for ( int i = 0 ; i < s1 . Length ; i ++ ) a [ s1 [ i ] - '0' ] ++ ; int prod = n * q ; string s2 = prod . ToString ( ) ; for ( int i = 0 ; i < s2 . Length ; i ++ ) { if ( a [ s2 [ i ] - '0' ] ) return false ; } return true ; }
int countInRange ( int l , int r , int q ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( checkIfUnequal ( i , q ) ) count ++ ; } return count ; }
virtual int search ( int [ ] arr , int strt , int end , int value ) { int i ; for ( i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) { break ; } } return i ; }
virtual void preOrder ( Node node ) { if ( node == null ) { return ; } Console . Write ( node . data + " " ) ; preOrder ( node . left ) ; preOrder ( node . right ) ; }
int countOnOff ( string n ) { int [ ] Led = new int [ ] { 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 5 } ; int len = n . Length ; int sum = Led [ n [ 0 ] - '0' ] ; for ( int i = 1 ; i < len ; i ++ ) { sum = sum + Math . Abs ( Led [ n [ i ] - '0' ] - Led [ n [ i - 1 ] - '0' ] ) ; } return sum ; }
bool checkMarkov ( double [ , ] m ) { for ( int i = 0 ; i < m . GetLength ( 0 ) ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < m . GetLength ( 1 ) ; j ++ ) sum = sum + m [ i , j ] ; if ( sum != 1 ) return false ; } return true ; }
bool isBinary ( int n ) { while ( n != 0 ) { int temp = n % 10 ; if ( temp != 0 && temp != 1 ) { return false ; } n = n / 10 ; } return true ; }
bool checkPalindrome ( String s ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] != s [ ( s . Length - i - 1 ) ] ) return false ; } return true ; }
bool CheckOdd ( String s ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { String x = "" ; for ( int j = i ; j < n ; j ++ ) { x += s [ j ] ; if ( x . Length % 2 == 0 && checkPalindrome ( x ) == true ) return false ; } } return true ; }
bool areVowelsInOrder ( string s ) { int n = s . Length ; char c = ( char ) 64 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == 'a' s [ i ] == 'e' s [ i ] == 'i' s [ i ] == 'o' s [ i ] == 'u' ) { if ( s [ i ] < c ) { return false ; } else { c = s [ i ] ; } } } return true ; }
void solve ( string s , int k ) { int count = 0 , length = 0 , pos = 0 ; Dictionary < char , int > m = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( m . ContainsKey ( s [ i ] ) ) m [ s [ i ] ] ++ ; else m [ s [ i ] ] = 1 ; length ++ ; if ( length > k ) { m [ s [ pos ] ] -- ; pos ++ ; length -- ; } if ( length == k && m [ s [ i ] ] == length ) count ++ ; } Console . WriteLine ( count ) ; }
void solve ( String s ) { Dictionary < char , int > m = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( m . ContainsKey ( s [ i ] ) ) { var val = m [ s [ i ] ] ; m . Remove ( s [ i ] ) ; m . Add ( s [ i ] , val + 1 ) ; } else m . Add ( s [ i ] , 1 ) ; } String new_string = "" ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( m [ s [ i ] ] % 2 == 0 ) continue ; new_string = new_string + s [ i ] ; } Console . WriteLine ( new_string ) ; }
bool isDiagonalMatrix ( int [ , ] mat ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i , j ] != 0 ) ) return false ; return true ; }
int minParentheses ( string p ) { int bal = 0 ; int ans = 0 ; for ( int i = 0 ; i < p . Length ; ++ i ) { bal += p [ i ] == '(' ? 1 : - 1 ; if ( bal == - 1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }
int fact ( int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result *= i ; return result ; }
int getResult ( string str , char ch ) { int [ ] has = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) has [ i ] = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) has [ str [ i ] - 'A' ] ++ ; int particular = has [ ch - 'A' ] ; if ( particular == 0 ) return 0 ; has [ ch - 'A' ] = 0 ; int total = str . Length ; total = total - particular + 1 ; int result = fact ( total ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( has [ i ] > 1 ) { result = result / fact ( has [ i ] ) ; } } return result ; }
bool isAnyNotPalindrome ( String s ) { HashSet < char > unique = new HashSet < char > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) unique . Add ( s [ i ] ) ; if ( unique . Count > 1 ) return true ; else return false ; }
long factorial ( long n ) { long res = 1 ; for ( int i = 1 ; i <= n ; i ++ ) res = res * i ; return res ; }
bool isScalarMatrix ( int [ , ] mat ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i , j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i , i ] != mat [ i + 1 , i + 1 ] ) return false ; return true ; }
int Remainder ( String str , int R ) { int len = str . Length ; int Num , Rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - '0' ) ; Rem = Num % R ; } return Rem ; }
void Solve ( int N , int M ) { int temp = ( N - 1 ) * ( M - 1 ) ; int ans = ( int ) ( Math . Pow ( 2 , temp ) ) ; if ( ( N + M ) % 2 != 0 ) Console . Write ( ans ) ; else Console . Write ( 2 * ans ) ; }
void countWays ( int [ ] a , int n ) { int i , j ; long [ ] suff = new long [ n ] ; if ( a [ n - 1 ] == 2 ) suff [ n - 1 ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] == 2 ) suff [ i ] = suff [ i + 1 ] + 1 ; else suff [ i ] = suff [ i + 1 ] ; } long ss = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ss += suff [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && suff [ j ] >= 2 ) { ss += ( suff [ j ] ) * ( suff [ j ] - 1 ) / 2 ; } } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && ( suff [ i ] - suff [ j ] ) >= 1 && suff [ j ] >= 1 ) { ss += ( suff [ i ] - suff [ j ] ) * suff [ j ] ; } } } Console . WriteLine ( ss ) ; }
long productAscii ( String str ) { long prod = 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) { prod *= str [ i ] ; } return prod ; }
void sortByRow ( int [ , ] mat , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( mat [ i , j ] > mat [ i , j + 1 ] ) { var temp = mat [ i , j ] ; mat [ i , j ] = mat [ i , j + 1 ] ; mat [ i , j + 1 ] = temp ; } } } }
void transpose ( int [ , ] mat , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { var temp = mat [ i , j ] ; mat [ i , j ] = mat [ j , i ] ; mat [ j , i ] = temp ; } }
void sortMatRowAndColWise ( int [ , ] mat , int n ) { sortByRow ( mat , n ) ; transpose ( mat , n ) ; sortByRow ( mat , n ) ; transpose ( mat , n ) ; }
int minimumLength ( String s ) { int maxOcc = 0 , n = s . Length ; int [ ] arr = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ s [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; }
void balancedString ( String str ) { int count = 0 , i ; int n = str . Length ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '(' ) { Console . Write ( str [ i ] ) ; count ++ ; } else if ( str [ i ] == ')' && count != 0 ) { Console . Write ( str [ i ] ) ; count -- ; } else if ( str [ i ] != ')' ) Console . Write ( str [ i ] ) ; } if ( count != 0 ) for ( i = 0 ; i < count ; i ++ ) Console . Write ( ")" ) ; }
int minOperation ( string s , int i , int j , int count ) { if ( ( i >= s . Length && j < 0 ) || ( i == j ) ) return MAX ; if ( s [ i ] == s [ j ] ) return count ; if ( i >= s . Length ) return minOperation ( s , i , j - 1 , count + 1 ) ; else if ( j < 0 ) return minOperation ( s , i + 1 , j , count + 1 ) ; else return Math . Min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ; }
int minOperation ( string s , int i , int j , int count ) { if ( ( i >= s . Length && j < 0 ) || ( i == j ) ) { return MAX ; } if ( s [ i ] == s [ j ] || ( count >= Min ) ) { return count ; } string str = i . ToString ( ) + "|" + j . ToString ( ) ; if ( ! m . ContainsKey ( str ) ) { if ( i >= s . Length ) { m [ str ] = minOperation ( s , i , j - 1 , count + 1 ) ; } else if ( j < 0 ) { m [ str ] = minOperation ( s , i + 1 , j , count + 1 ) ; } else { m [ str ] = Math . Min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ; } } if ( m [ str ] < Min ) { Min = m [ str ] ; } return m [ str ] ; }
int countStrings ( String s ) { int sum = 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( i % 2 == 0 && s [ i ] == '$' ) sum *= 21 ; else if ( s [ i ] == '$' ) sum *= 5 ; } return sum ; }
int firstPos ( string str , int start , int end ) { int firstChar = - 1 ; for ( int i = start ; i <= end ; i ++ ) { if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) { firstChar = i ; break ; } } return firstChar ; }
int lastPos ( string str , int start , int end ) { int lastChar = - 1 ; for ( int i = start ; i >= end ; i -- ) { if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) { lastChar = i ; break ; } } return lastChar ; }
bool isInGivenBase ( String str , int bas ) { if ( bas > 16 ) return false ; else if ( bas <= 10 ) { for ( int i = 0 ; i < str . Length ; i ++ ) if ( ! ( str [ i ] >= '0' && str [ i ] < ( '0' + bas ) ) ) return false ; } else { for ( int i = 0 ; i < str . Length ; i ++ ) if ( ! ( ( str [ i ] >= '0' && str [ i ] < ( '0' + bas ) ) || ( str [ i ] >= 'A' && str [ i ] < ( 'A' + bas - 10 ) ) ) ) return false ; } return true ; }
void frequency ( int [ , ] fre , string [ ] s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { string str = s [ i ] ; for ( int j = 0 ; j < str . Length ; j ++ ) { fre [ i , str [ j ] - 'a' ] ++ ; } } }
void printIndex ( String str , String s ) { bool flag = false ; for ( int i = 0 ; i < str . Length - s . Length + 1 ; i ++ ) { if ( str . Substring ( i , s . Length ) . Equals ( s ) ) { Console . Write ( i + " " ) ; flag = true ; } } if ( flag == false ) { Console . WriteLine ( "NONE" ) ; } }
int powerOfJump ( String s ) { int count = 1 ; int max_so_far = int . MinValue ; char ch = s [ s . Length - 1 ] ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; }
int findLongestSub ( String bin ) { int n = bin . Length , i ; int sum = 0 ; Dictionary < int , int > prevSum = new Dictionary < int , int > ( ) ; int maxlen = 0 ; int currlen ; for ( i = 0 ; i < n ; i ++ ) { if ( bin [ i ] == '1' ) sum ++ ; else sum -- ; if ( sum > 0 ) { maxlen = i + 1 ; } else if ( sum <= 0 ) { if ( prevSum . ContainsKey ( sum - 1 ) ) { currlen = i - ( prevSum [ sum - 1 ] == 0 ? 1 : prevSum [ sum - 1 ] ) ; maxlen = Math . Max ( maxlen , currlen ) ; } } if ( ! prevSum . ContainsKey ( sum ) ) prevSum . Add ( sum , i ) ; } return maxlen ; }
void countEvenOdd ( int [ ] arr , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( ( y & 1 ) != 0 ) { Console . WriteLine ( "Even = " + odd + ", Odd = " + even ) ; } else { Console . WriteLine ( "Even = " + even + ", Odd = " + odd ) ; } }
int averageValue ( String s ) { int sum_char = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { sum_char += ( int ) s [ i ] ; } return sum_char / s . Length ; }
int findNumberOfTimes ( String str1 , String str2 ) { int [ ] freq = new int [ 26 ] ; int l1 = str1 . Length ; int [ ] freq2 = new int [ 26 ] ; int l2 = str2 . Length ; for ( int i = 0 ; i < l1 ; i ++ ) { freq [ str1 [ i ] - 'a' ] += 1 ; } for ( int i = 0 ; i < l2 ; i ++ ) { freq2 [ str2 [ i ] - 'a' ] += 1 ; } int count = int . MaxValue ; for ( int i = 0 ; i < l2 ; i ++ ) { if ( freq2 [ str2 [ i ] - 'a' ] != 0 ) count = Math . Min ( count , freq [ str2 [ i ] - 'a' ] / freq2 [ str2 [ i ] - 'a' ] ) ; } return count ; }
bool solve ( String s1 , String s2 ) { bool flag1 = false , flag2 = false ; if ( s1 . Length != s2 . Length ) return false ; int l = s1 . Length ; for ( int i = 0 ; i < l ; i ++ ) { if ( s1 [ i ] == '1' ) flag1 = true ; if ( s2 [ i ] == '1' ) flag2 = true ; if ( flag1 == true && flag2 == true ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; }
bool check ( String s , int l ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < l ; i ++ ) { freq [ s [ i ] - 'a' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] >= 2 ) return true ; } return false ; }
bool isPalindrome ( String str , int l , int r ) { while ( l < r ) { if ( str [ l ] != str [ r ] ) return false ; l ++ ; r -- ; } return true ; }
int CyclicShifts ( String str ) { int n = str . Length ; int left = 0 ; int right = n - 1 ; str = str + str ; int cnt = 0 ; while ( right < 2 * n - 1 ) { if ( isPalindrome ( str , left , right ) ) break ; cnt ++ ; left ++ ; right ++ ; } return cnt ; }
void printNum ( String s ) { int i = 0 , val = 0 ; Dictionary < int , int > hm = new Dictionary < int , int > ( ) ; val = ( s [ 0 ] - '0' ) * 100 + ( s [ 1 ] - '0' ) * 10 + ( s [ 2 ] - '0' ) ; hm . Add ( val , 1 ) ; for ( i = 3 ; i < s . Length ; i ++ ) { val = ( val % 100 ) * 10 + s [ i ] - '0' ; if ( hm . ContainsKey ( val ) ) { hm [ val ] = hm [ val ] + 1 ; } else { hm . Add ( val , 1 ) ; } } foreach ( KeyValuePair < int , int > en in hm ) { int key = en . Key ; int value = en . Value ; if ( value > 1 ) Console . WriteLine ( key + " - " + value + " times" ) ; } }
int countSubstrig ( String str1 , String str2 ) { int n1 = str1 . Length ; int n2 = str2 . Length ; if ( n1 == 0 n1 < n2 ) return 0 ; if ( str1 . Substring ( 0 , n2 ) . Equals ( str2 ) ) return countSubstrig ( str1 . Substring ( n2 - 1 ) , str2 ) + 1 ; return countSubstrig ( str1 . Substring ( n2 - 1 ) , str2 ) ; }
bool check ( string s , int m ) { int l = s . Length ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }
char nextGreatestAlphabet ( char [ ] alphabets , char K ) { int n = alphabets . Length ; if ( K >= alphabets [ n - 1 ] ) return alphabets [ 0 ] ; int l = 0 , r = alphabets . Length - 1 ; int ans = - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( alphabets [ mid ] > K ) { ans = mid ; r = mid - 1 ; } else l = mid + 1 ; } return alphabets [ ans ] ; }
void reverse ( char [ ] str , int start , int end ) { char temp ; while ( start <= end ) { temp = str [ start ] ; str [ start ] = str [ end ] ; str [ end ] = temp ; start ++ ; end -- ; } }
void reverseletter ( char [ ] str , int start , int end ) { int wstart , wend ; for ( wstart = wend = start ; wend < end ; wend ++ ) { if ( str [ wend ] == ' ' ) { continue ; } while ( wend <= end && str [ wend ] != ' ' ) { wend ++ ; } wend -- ; reverse ( str , wstart , wend ) ; } }
int subCount ( int [ ] arr , int n , int k ) { int [ ] mod = new int [ k ] ; int cumSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumSum += arr [ i ] ; mod [ ( ( cumSum % k ) + k ) % k ] ++ ; } int result = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( mod [ i ] > 1 ) result += ( mod [ i ] * ( mod [ i ] - 1 ) ) / 2 ; result += mod [ 0 ] ; return result ; }
int countSubmatrix ( int [ , ] mat , int n , int k ) { int tot_count = 0 ; int left , right , i ; int [ ] temp = new int [ n ] ; for ( left = 0 ; left < n ; left ++ ) { for ( right = left ; right < n ; right ++ ) { for ( i = 0 ; i < n ; ++ i ) temp [ i ] += mat [ i , right ] ; tot_count += subCount ( temp , n , k ) ; } } return tot_count - 3 ; }
int matchClosing ( char [ ] X , int start , int end , char open , char close ) { int c = 1 ; int i = start + 1 ; while ( i <= end ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i ++ ; } return i ; }
int matchingOpening ( char [ ] X , int start , int end , char open , char close ) { int c = - 1 ; int i = end - 1 ; while ( i >= start ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i -- ; } return - 1 ; }
bool isBalanced ( char [ ] X , int n ) { int i , j = 0 , k , x , start , end ; for ( i = 0 ; i < n ; i ++ ) { if ( X [ i ] == '(' ) { j = matchClosing ( X , i , n - 1 , '(' , ')' ) ; } else if ( X [ i ] == '{' ) { j = matchClosing ( X , i , n - 1 , '{' , '}' ) ; } else if ( X [ i ] == '[' ) { j = matchClosing ( X , i , n - 1 , '[' , ']' ) ; } else { if ( X [ i ] == ')' ) { j = matchingOpening ( X , 0 , i , '(' , ')' ) ; } else if ( X [ i ] == '}' ) { j = matchingOpening ( X , 0 , i , '{' , '}' ) ; } else if ( X [ i ] == ']' ) { j = matchingOpening ( X , 0 , i , '[' , ']' ) ; } if ( j < 0 j >= i ) { return false ; } continue ; } if ( j >= n j < 0 ) { return false ; } start = i ; end = j ; for ( k = start + 1 ; k < end ; k ++ ) { if ( X [ k ] == '(' ) { x = matchClosing ( X , k , end , '(' , ')' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ')' ) { x = matchingOpening ( X , start , k , '(' , ')' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == '{' ) { x = matchClosing ( X , k , end , '{' , '}' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == '}' ) { x = matchingOpening ( X , start , k , '{' , '}' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == '[' ) { x = matchClosing ( X , k , end , '[' , ']' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ']' ) { x = matchingOpening ( X , start , k , '[' , ']' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } } } return true ; }
string possibleToSort ( int [ ] arr , int n , string str ) { int max_element = - 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) { max_element = Math . Max ( max_element , arr [ i ] ) ; if ( str [ i ] == '0' ) { if ( max_element > i + 1 ) return "No" ; } } return "Yes" ; }
int largestNum ( int n ) { int num = 0 ; int max_setBits = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { int setBits = countSetBits ( i ) ; if ( setBits >= max_setBits ) { num = i ; max_setBits = setBits ; } } return num ; }
int findMinOpeartion ( int [ , ] matrix , int n ) { int [ ] sumRow = new int [ n ] ; int [ ] sumCol = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { sumRow [ i ] += matrix [ i , j ] ; sumCol [ j ] += matrix [ i , j ] ; } int maxSum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { maxSum = Math . Max ( maxSum , sumRow [ i ] ) ; maxSum = Math . Max ( maxSum , sumCol [ i ] ) ; } int count = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { int diff = Math . Min ( maxSum - sumRow [ i ] , maxSum - sumCol [ j ] ) ; matrix [ i , j ] += diff ; sumRow [ i ] += diff ; sumCol [ j ] += diff ; count += diff ; if ( sumRow [ i ] == maxSum ) ++ i ; if ( sumCol [ j ] == maxSum ) ++ j ; } return count ; }
int countPair ( String [ ] str , int n ) { int [ ] cnt = new int [ 1 << 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { int mask = 0 ; for ( int j = 0 ; j < str [ i ] . Length ; ++ j ) mask |= ( 1 << ( str [ i ] [ j ] - '0' ) ) ; cnt [ mask ] ++ ; } int ans = 0 ; for ( int m1 = 0 ; m1 <= 1023 ; m1 ++ ) for ( int m2 = 0 ; m2 <= 1023 ; m2 ++ ) if ( ( m1 m2 ) == 1023 ) { ans += ( ( m1 == m2 ) ? ( cnt [ m1 ] * ( cnt [ m1 ] - 1 ) ) : ( cnt [ m1 ] * cnt [ m2 ] ) ) ; } return ans / 2 ; }
long computeStringCount ( int N ) { int n = N / 2 ; long ans = 0 ; for ( int i = 2 ; i <= n ; i += 2 ) ans = ( ans + ( ( nCr [ n , i ] * nCr [ n , i / 2 ] ) % mod ) ) % mod ; return ans ; }
void countSubsequence ( string s , int n ) { int cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s [ i ] ) { case 'G' : cntG ++ ; result += C ; break ; case 'F' : cntF ++ ; C += cntG ; break ; default : continue ; } } Console . WriteLine ( result ) ; }
int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
string LexicographicalMaxString ( string str ) { char maxchar = 'a' ; List < int > index = new List < int > ( ) ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] >= maxchar ) { maxchar = str [ i ] ; index . Add ( i ) ; } } string maxstring = "" ; for ( int i = 0 ; i < index . Count ; i ++ ) { if ( str . Substring ( index [ i ] ) . CompareTo ( maxstring ) > 0 ) { maxstring = str . Substring ( index [ i ] ) ; } } return maxstring ; }
bool isDivisible ( String str , int k ) { int n = str . Length ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ; return ( c == k ) ; }
string longestPalin ( string str ) { str = str + " " ; string longestword = "" , word = "" ; int length , length1 = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { char ch = str [ i ] ; if ( ch != ' ' ) word = word + ch ; else { length = word . Length ; if ( checkPalin ( word ) && length > length1 ) { length1 = length ; longestword = word ; } word = "" ; } } return longestword ; }
bool isCommonBase ( String Base , String s1 , String s2 ) { for ( int j = 0 ; j < s1 . Length ; ++ j ) { if ( Base [ j % Base . Length ] != s1 [ j ] ) { return false ; } } for ( int j = 0 ; j < s2 . Length ; ++ j ) { if ( Base [ j % Base . Length ] != s2 [ j ] ) { return false ; } } return true ; }
int countCommonBases ( String s1 , String s2 ) { int n1 = s1 . Length , n2 = s2 . Length ; int count = 0 ; for ( int i = 1 ; i <= Math . Min ( n1 , n2 ) ; i ++ ) { String Base = s1 . Substring ( 0 , i ) ; if ( isCommonBase ( Base , s1 , s2 ) ) { count ++ ; } } return count ; }
bool isPrimeString ( string str ) { int len = str . Length , n = 0 ; for ( int i = 0 ; i < len ; i ++ ) { n += ( int ) str [ i ] ; } if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return true ; } if ( n % 2 == 0 n % 3 == 0 ) { return false ; } for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
int countPalin ( string str ) { str = str + " " ; string word = "" ; int count = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { char ch = str [ i ] ; if ( ch != ' ' ) { word = word + ch ; } else { if ( checkPalin ( word ) ) { count ++ ; } word = "" ; } } return count ; }
bool targetstring ( string str1 , string str2 ) { int l1 = str1 . Length ; int l2 = str2 . Length ; if ( l1 != l2 ) return false ; int [ ] map = new int [ MAX ] ; Array . Clear ( map , 0 , 26 ) ; for ( int i = 0 ; i < l1 ; i ++ ) map [ str1 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) { map [ str2 [ i ] - 'a' ] -- ; if ( map [ str2 [ i ] - 'a' ] < 0 ) return false ; } return true ; }
bool isDigitPresent ( int x , int d ) { while ( x > 0 ) { if ( x % 10 == d ) break ; x = x / 10 ; } return ( x > 0 ) ; }
void printNumbers ( int n , int d ) { for ( int i = 0 ; i <= n ; i ++ ) if ( i == d || isDigitPresent ( i , d ) ) Console . Write ( i + " " ) ; }
void printNumbers ( int n , int d ) { String st = "" + d ; char ch = st [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { st = "" ; st = st + i ; if ( i == d || st . IndexOf ( ch ) >= 0 ) Console . Write ( i + " " ) ; } }
char findExtraCharcter ( string strA , string strB ) { int res = 0 , i ; for ( i = 0 ; i < strA . Length ; i ++ ) { res ^= strA [ i ] ; } for ( i = 0 ; i < strB . Length ; i ++ ) { res ^= strB [ i ] ; } return ( ( char ) ( res ) ) ; }
char findExtraCharacter ( String s1 , String s2 ) { String smallStr ; String largeStr ; if ( s1 . Length > s2 . Length ) { smallStr = s2 ; largeStr = s1 ; } else { smallStr = s1 ; largeStr = s2 ; } int smallStrCodeTotal = 0 ; int largeStrCodeTotal = 0 ; int i = 0 ; for ( ; i < smallStr . Length ; i ++ ) { smallStrCodeTotal += smallStr [ i ] ; largeStrCodeTotal += largeStr [ i ] ; } largeStrCodeTotal += largeStr [ i ] ; int intChar = largeStrCodeTotal - smallStrCodeTotal ; return ( char ) intChar ; }
long fact ( int n ) { long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int countPalinPermutations ( string str ) { int n = str . Length ; int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] ] ++ ; long res = fact ( n / 2 ) ; bool oddFreq = false ; for ( int i = 0 ; i < MAX ; i ++ ) { int half = freq [ i ] / 2 ; if ( freq [ i ] % 2 != 0 ) { if ( oddFreq == true ) return 0 ; oddFreq = true ; } res = res / fact ( half ) ; } return ( int ) res ; }
int minChanges ( string str ) { int n = str . Length ; if ( n > MAX_CHAR ) return - 1 ; int dist_count = 0 ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ str [ i ] - 'a' ] == 0 ) dist_count ++ ; count [ str [ i ] - 'a' ] ++ ; } return ( n - dist_count ) ; }
void printList ( Node head ) { while ( head != null ) { Console . Write ( head . c + " " ) ; head = head . next ; } }
void strToBinary ( String s ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { int val = s [ i ] ; String bin = "" ; while ( val > 0 ) { if ( val % 2 == 1 ) { bin += '1' ; } else bin += '0' ; val /= 2 ; } bin = reverse ( bin ) ; Console . Write ( bin + " " ) ; } }
int numofstring ( int n , int m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * ( int ) Math . Pow ( m - 2 , n - 2 ) ; }
int calculateSum ( string [ ] arr , int n ) { if ( n == 0 ) return 0 ; string s = arr [ 0 ] ; int value = int . Parse ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = int . Parse ( s ) ; char operation = arr [ i - 1 ] [ 0 ] ; if ( operation == '+' ) sum += value ; else sum -= value ; } return sum ; }
int FindMaxProduct ( int [ , ] arr , int n ) { int max = 0 , result ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i , j ] * arr [ i , j - 1 ] * arr [ i , j - 2 ] * arr [ i , j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 ) { result = arr [ i , j ] * arr [ i - 1 , j ] * arr [ i - 2 , j ] * arr [ i - 3 , j ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i , j ] * arr [ i - 1 , j - 1 ] * arr [ i - 2 , j - 2 ] * arr [ i - 3 , j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 1 ) <= 0 ) { result = arr [ i , j ] * arr [ i - 1 , j + 1 ] * arr [ i - 2 , j + 2 ] * arr [ i - 3 , j + 3 ] ; if ( max < result ) max = result ; } } } return max ; }
int CountSpecialPalindrome ( String str ) { int n = str . Length ; int result = 0 ; int [ ] sameChar = new int [ n ] ; for ( int v = 0 ; v < n ; v ++ ) sameChar [ v ] = 0 ; int i = 0 ; while ( i < n ) { int sameCharCount = 1 ; int j = i + 1 ; while ( j < n && str [ i ] == str [ j ] ) { sameCharCount ++ ; j ++ ; } result += ( sameCharCount * ( sameCharCount + 1 ) / 2 ) ; sameChar [ i ] = sameCharCount ; i = j ; } for ( int j = 1 ; j < n ; j ++ ) { if ( str [ j ] == str [ j - 1 ] ) sameChar [ j ] = sameChar [ j - 1 ] ; if ( j > 0 && j < ( n - 1 ) && ( str [ j - 1 ] == str [ j + 1 ] && str [ j ] != str [ j - 1 ] ) ) result += Math . Min ( sameChar [ j - 1 ] , sameChar [ j + 1 ] ) ; } return result - n ; }
int productAtKthLevel ( string tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == '(' ) level ++ ; else if ( tree [ i ] == ')' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] - '0' ) ; } } return product ; }
bool isCornerPresent ( string str , string corner ) { int n = str . Length ; int cl = corner . Length ; if ( n < cl ) return false ; return ( str . Substring ( 0 , cl ) . Equals ( corner ) && str . Substring ( n - cl , cl ) . Equals ( corner ) ) ; }
int factorial ( int n ) { int f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) f = f * i ; return f ; }
int calculateTotal ( char [ ] temp , int n ) { int f = factorial ( n ) ; Dictionary < char , int > hm = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < temp . Length ; i ++ ) { if ( hm . ContainsKey ( temp [ i ] ) ) hm [ temp [ i ] ] = hm [ temp [ i ] ] + 1 ; else hm . Add ( temp [ i ] , 1 ) ; } foreach ( KeyValuePair < char , int > e in hm ) { int x = e . Value ; if ( x > 1 ) { int temp5 = factorial ( x ) ; f = f / temp5 ; } } return f ; }
void nextPermutation ( char [ ] temp ) { int i ; for ( i = temp . Length - 1 ; i > 0 ; i -- ) if ( temp [ i ] > temp [ i - 1 ] ) break ; int min = i ; int j , x = temp [ i - 1 ] ; for ( j = i + 1 ; j < temp . Length ; j ++ ) if ( ( temp [ j ] < temp [ min ] ) && ( temp [ j ] > x ) ) min = j ; char temp_to_swap ; temp_to_swap = temp [ i - 1 ] ; temp [ i - 1 ] = temp [ min ] ; temp [ min ] = temp_to_swap ; Array . Sort ( temp , i , temp . Length - i ) ; print ( temp ) ; }
int countSpecial ( char [ ] str ) { int len = str . Length ; if ( len == 0 ) return 0 ; int [ ] co = new int [ len + 1 ] ; int [ ] vo = new int [ len + 1 ] ; if ( isCons ( str [ len - 1 ] ) == true ) co [ len - 1 ] = 1 ; else vo [ len - 1 ] = 1 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( isCons ( str [ i ] ) == true ) { co [ i ] = co [ i + 1 ] + 1 ; vo [ i ] = vo [ i + 1 ] ; } else { co [ i ] = co [ i + 1 ] ; vo [ i ] = vo [ i + 1 ] + 1 ; } } long ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( isVowel ( str [ i ] ) ) ans = ans + co [ i + 1 ] ; else ans = ans + vo [ i + 1 ] ; } return ( int ) ans ; }
int findSubSequence ( string s , int num ) { int res = 0 ; int i = 0 ; while ( num > 0 ) { if ( ( num & 1 ) == 1 ) res += s [ i ] - '0' ; i ++ ; num = num >> 1 ; } return res ; }
void findSubsequence ( string str , int k ) { int [ ] a = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . Length ; i ++ ) a [ str [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( a [ str [ i ] - 'a' ] >= k ) Console . Write ( str [ i ] ) ; }
bool isConvertible ( string str1 , string str2 , int k ) { if ( ( str1 . Length + str2 . Length ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < Math . Min ( str1 . Length , str2 . Length ) ; i ++ ) { if ( str1 == str2 ) commonLength ++ ; else break ; } if ( ( k - str1 . Length - str2 . Length + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }
int maxLower ( String str ) { int n = str . Length ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { i ++ ; break ; } } int maxCount = 0 ; int [ ] count = new int [ MAX_CHAR ] ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { int currCount = 0 ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) { if ( count [ j ] > 0 ) { currCount ++ ; } } maxCount = Math . Max ( maxCount , currCount ) ; Array . Fill ( count , 0 ) ; } if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) { count [ str [ i ] - 'a' ] ++ ; } } return maxCount ; }
int maxLower ( char [ ] str ) { int n = str . Length ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { i ++ ; break ; } } int maxCount = 0 ; HashSet < int > s = new HashSet < int > ( ) ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { maxCount = Math . Max ( maxCount , ( int ) s . Count ) ; s . Clear ( ) ; } if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) s . Add ( ( int ) str [ i ] ) ; } return maxCount ; }
bool checkPalindrome ( string str ) { int n = str . Length ; int count = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) if ( str [ i ] != str [ n - i - 1 ] ) ++ count ; return ( count <= 1 ) ; }
int minimumflip ( int [ , ] mat , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i , j ] != mat [ j , i ] ) flip ++ ; return flip ; }
int findLUSlength ( string a , string b ) { Dictionary < string , int > map = new Dictionary < string , int > ( ) ; List < string > strArr = new List < string > ( ) ; strArr . Add ( a ) ; strArr . Add ( b ) ; foreach ( string s in strArr ) { for ( int i = 0 ; i < ( 1 << s . Length ) ; i ++ ) { string t = "" ; for ( int j = 0 ; j < s . Length ; j ++ ) { if ( ( ( i >> j ) & 1 ) != 0 ) t += s [ j ] ; } if ( map . ContainsKey ( t ) ) { int value = map [ t ] + 1 ; map . Remove ( t ) ; map . Add ( t , value ) ; } else map . Add ( t , 1 ) ; } } int res = 0 ; foreach ( KeyValuePair < string , int > entry in map ) { if ( entry . Value == 1 ) res = Math . Max ( res , entry . Key . Length ) ; } return res ; }
int findLUSlength ( String a , String b ) { if ( a . Equals ( b ) == true ) return 0 ; return Math . Max ( a . Length , b . Length ) ; }
string convert ( string str ) { string w = "" , z = "" ; str = str . ToUpper ( ) + " " ; for ( int i = 0 ; i < str . Length ; i ++ ) { char ch = str [ i ] ; if ( ch != ' ' ) w = w + ch ; else { z = z + ( Char . ToLower ( w [ 0 ] ) ) + w . Substring ( 1 ) + " " ; w = "" ; } } return z ; }
char first ( string str ) { for ( int i = 0 ; i < str . Length ; i ++ ) if ( char . IsUpper ( str [ i ] ) ) return str [ i ] ; return '0' ; }
int fact ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ( ans ) ; }
int evenDecimalValue ( string str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int decimalValue = 0 ; int powerOf2 = 1 ; for ( int k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - '0' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }
void solve ( string s ) { int l = s . Length ; int x = l / 2 ; int y = l ; string p = "" ; while ( x > 0 && y > l / 2 ) { char ch = s [ x - 1 ] ; p += ch ; x -- ; ch = s [ y - 1 ] ; p += ch ; y -- ; } if ( y > l / 2 ) { char ch = s [ x - 1 ] ; p += ch ; y -- ; } Console . WriteLine ( p ) ; }
bool isConsonant ( char ch ) { ch = Char . ToUpper ( ch ) ; return ! ( ch == 'A' ch == 'E' ch == 'I' ch == 'O' ch == 'U' ) && ch >= 65 && ch <= 90 ; }
int totalConsonants ( String str , int n ) { if ( n == 1 ) { if ( isConsonant ( str [ 0 ] ) ) return 1 ; else return 0 ; } if ( isConsonant ( str [ n - 1 ] ) ) return totalConsonants ( str , n - 1 ) + 1 ; else return totalConsonants ( str , n - 1 ) ; }
int countSubstr ( string s ) { int n = s . Length ; int [ ] auxArr = new int [ n ] ; if ( s [ 0 ] == '1' ) auxArr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( s [ i ] == '1' ) count += auxArr [ i ] ; return count ; }
int calSumUtil ( int [ ] a , int [ ] b , int n , int m ) { int [ ] sum = new int [ n ] ; int i = n - 1 , j = m - 1 , k = n - 1 ; int carry = 0 , s = 0 ; while ( j >= 0 ) { s = a [ i ] + b [ j ] + carry ; sum [ k ] = ( s % 10 ) ; carry = s / 10 ; k -- ; i -- ; j -- ; } while ( i >= 0 ) { s = a [ i ] + carry ; sum [ k ] = ( s % 10 ) ; carry = s / 10 ; i -- ; k -- ; } int ans = 0 ; if ( carry == 1 ) ans = 10 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { ans += sum [ i ] ; ans *= 10 ; } return ans / 10 ; }
int calSum ( int [ ] a , int [ ] b , int n , int m ) { if ( n >= m ) return calSumUtil ( a , b , n , m ) ; else return calSumUtil ( b , a , m , n ) ; }
int longCommomAnagramSubseq ( string str1 , string str2 , int n1 , int n2 ) { int [ ] freq1 = new int [ SIZE ] ; int [ ] freq2 = new int [ SIZE ] ; for ( int i = 0 ; i < SIZE ; i ++ ) { freq1 [ i ] = 0 ; freq2 [ i ] = 0 ; } int len = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < SIZE ; i ++ ) len += Math . Min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }
bool isPanalphabeticWindow ( string s , int n ) { char ch = 'a' ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch ) ch ++ ; if ( ch == 'z' + 1 ) return true ; } return false ; }
int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
bool HalfDiagonalSums ( int [ , ] mat , int n ) { int diag1_left = 0 , diag1_right = 0 ; int diag2_left = 0 , diag2_right = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( i < n / 2 ) { diag1_left += mat [ i , i ] ; diag2_left += mat [ j , i ] ; } else if ( i > n / 2 ) { diag1_right += mat [ i , i ] ; diag2_right += mat [ j , i ] ; } } return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 , n / 2 ] ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
void prime_index ( string input ) { int n = input . Length ; for ( int i = 2 ; i <= n ; i ++ ) if ( isPrime ( i ) ) Console . Write ( input [ i - 1 ] ) ; }
bool isHeterogram ( string s , int n ) { int [ ] hash = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != ' ' ) { if ( hash [ s [ i ] - 'a' ] == 0 ) hash [ s [ i ] - 'a' ] = 1 ; else return false ; } } return true ; }
void ASCIISentence ( string str ) { int l = str . Length ; int convert ; for ( int i = 0 ; i < l ; i ++ ) { convert = str [ i ] ; Console . Write ( convert ) ; } }
void preProcess ( string a , string b ) { int n = a . Length ; int j = 0 ; for ( int i = 1 ; i <= a . Length ; i ++ ) { if ( j < b . Length && a [ i - 1 ] == b [ j ] ) j ++ ; fwd [ i ] = j ; } j = 0 ; for ( int i = a . Length ; i >= 1 ; i -- ) { if ( j < b . Length && a [ i - 1 ] == b [ b . Length - j - 1 ] ) j ++ ; bwd [ i ] = j ; } }
int findOccurrences ( string str1 , string substr1 ) { int counter = 0 ; for ( int i = 0 ; i < str1 . Length ; i ++ ) { if ( str1 [ i ] == substr1 [ 0 ] ) { for ( int j = i + 1 ; j < str1 . Length ; j ++ ) { if ( str1 [ j ] == substr1 [ 1 ] ) { for ( int k = j + 1 ; k < str1 . Length ; k ++ ) { if ( str1 [ k ] == substr1 [ 2 ] ) counter ++ ; } } } } } return counter ; }
int findOccurrences ( string str1 , string substr1 ) { int n = str1 . Length ; int [ ] preLeft = new int [ n ] ; int [ ] preRight = new int [ n ] ; if ( str1 [ 0 ] == substr1 [ 0 ] ) preLeft [ 0 ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { if ( str1 [ i ] == substr1 [ 0 ] ) preLeft [ i ] = preLeft [ i - 1 ] + 1 ; else preLeft [ i ] = preLeft [ i - 1 ] ; } if ( str1 [ n - 1 ] == substr1 [ 2 ] ) preRight [ n - 1 ] ++ ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( str1 [ i ] == substr1 [ 2 ] ) preRight [ i ] = preRight [ i + 1 ] + 1 ; else preRight [ i ] = preRight [ i + 1 ] ; } int counter = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( str1 [ i ] == str1 [ 1 ] ) { int total = preLeft [ i - 1 ] * preRight [ i + 1 ] ; counter += total ; } } return counter ; }
bool canMakeStr2 ( string str1 , string str2 ) { int [ ] count = new int [ MAX ] ; for ( int i = 0 ; i < str1 . Length ; i ++ ) count [ str1 [ i ] ] ++ ; for ( int i = 0 ; i < str2 . Length ; i ++ ) { if ( count [ str2 [ i ] ] == 0 ) return false ; count [ str2 [ i ] ] -- ; } return true ; }
bool isVowel ( char c ) { return ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) ; }
bool isVowel ( char c ) { return ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) ; }
void finalPosition ( String move ) { int l = move . Length ; int countUp = 0 , countDown = 0 ; int countLeft = 0 , countRight = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( move [ i ] == 'U' ) countUp ++ ; else if ( move [ i ] == 'D' ) countDown ++ ; else if ( move [ i ] == 'L' ) countLeft ++ ; else if ( move [ i ] == 'R' ) countRight ++ ; } Console . WriteLine ( "Final Position: (" + ( countRight - countLeft ) + ", " + ( countUp - countDown ) + ")" ) ; }
bool isIdentity ( int [ , ] mat , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row , col ] != 1 ) return false ; else if ( row != col && mat [ row , col ] != 0 ) return false ; } } return true ; }
int maxbalancedprefix ( string str , int n ) { int sum = 0 ; int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '(' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
int countOccurrences ( string str , string word ) { string [ ] a = str . Split ( ' ' ) ; int count = 0 ; for ( int i = 0 ; i < a . Length ; i ++ ) { if ( word . Equals ( a [ i ] ) ) count ++ ; } return count ; }
int minCost ( char [ ] s ) { bool [ ] alphabets = new bool [ 26 ] ; for ( int i = 0 ; i < s . Length ; i ++ ) { alphabets [ ( int ) s [ i ] - 97 ] = true ; } int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( alphabets [ i ] ) { count ++ ; } } return count ; }
int numberOfDifferentSubstrings ( String s , char a , char b ) { int ans = 0 ; int ls = s . Length ; int [ ] x = new int [ ls ] ; int [ ] y = new int [ ls ] ; for ( int i = 0 ; i < ls ; i ++ ) { if ( s [ i ] == a ) x [ i ] = 1 ; if ( s [ i ] == b ) y [ i ] = 1 ; } HashSet < String > hash = new HashSet < String > ( ) ; String curr_substr = "" ; for ( int i = 0 ; i < ls ; i ++ ) { if ( x [ i ] != 0 ) { for ( int j = i ; j < ls ; j ++ ) { if ( y [ j ] == 0 ) curr_substr += s [ i ] ; if ( y [ j ] != 0 ) { curr_substr += s [ j ] ; if ( ! hash . Contains ( curr_substr ) ) ans ++ ; hash . Add ( curr_substr ) ; } } curr_substr = "" ; } } return ans ; }
long countWays ( int n , int m , int k ) { if ( n == 1 m == 1 ) return 1 ; else if ( ( n + m ) % 2 == 1 && k == - 1 ) return 0 ; return ( modPower ( modPower ( ( long ) 2 , n - 1 , mod ) , m - 1 , mod ) % mod ) ; }
int cost ( String str ) { int len = str . Length ; int res = 0 ; for ( int i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) if ( str [ i ] != str [ j ] ) res += Math . Min ( str [ i ] , str [ j ] ) - 'a' + 1 ; return res ; }
string pigLatin ( string s ) { int len = s . Length ; int index = - 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( isVowel ( s [ i ] ) ) { index = i ; break ; } } if ( index == - 1 ) return "-1" ; return s . Substring ( index ) + s . Substring ( 0 , index ) + "ay" ; }
bool isValidISBN ( string isbn ) { int n = isbn . Length ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn [ i ] - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn [ 9 ] ; if ( last != 'X' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }
int remainder ( string str ) { int len = str . Length ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - '0' ) ; rem = num % 11 ; } return rem ; }
int longestSubseq ( String s ) { int n = s . Length ; int [ ] pre_count_0 = new int [ n + 2 ] ; int [ ] pre_count_1 = new int [ n + 1 ] ; int [ ] post_count_0 = new int [ n + 2 ] ; pre_count_0 [ 0 ] = 0 ; post_count_0 [ n + 1 ] = 0 ; pre_count_1 [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { pre_count_0 [ j ] = pre_count_0 [ j - 1 ] ; pre_count_1 [ j ] = pre_count_1 [ j - 1 ] ; post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] ; if ( s [ j - 1 ] == '0' ) pre_count_0 [ j ] ++ ; else pre_count_1 [ j ] ++ ; if ( s [ n - j ] == '0' ) post_count_0 [ n - j + 1 ] ++ ; } if ( pre_count_0 [ n ] == n pre_count_0 [ n ] == 0 ) return n ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) ans = Math . Max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) ; return ans ; }
void removeSpecialCharacter ( string s ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] < 'A' s [ i ] > 'Z' && s [ i ] < 'a' s [ i ] > 'z' ) { s = s . Remove ( i , 1 ) ; i -- ; } } Console . Write ( s ) ; }
void imageSwap ( int [ , ] mat , int n ) { int row = 0 ; for ( int j = 0 ; j < n ; j ++ ) { Stack < int > s = new Stack < int > ( ) ; int i = row , k = j ; while ( i < n && k >= 0 ) { s . Push ( mat [ i ++ , k -- ] ) ; } i = row ; k = j ; while ( i < n && k >= 0 ) { mat [ i ++ , k -- ] = s . Peek ( ) ; s . Pop ( ) ; } } int column = n - 1 ; for ( int j = 1 ; j < n ; j ++ ) { Stack < int > s = new Stack < int > ( ) ; int i = j , k = column ; while ( i < n && k >= 0 ) { s . Push ( mat [ i ++ , k -- ] ) ; } i = j ; k = column ; while ( i < n && k >= 0 ) { mat [ i ++ , k -- ] = s . Peek ( ) ; s . Pop ( ) ; } } }
bool shouldSwap ( char [ ] str , int start , int curr ) { for ( int i = start ; i < curr ; i ++ ) { if ( str [ i ] == str [ curr ] ) { return false ; } } return true ; }
string decodeMedianString ( string s ) { int l = s . Length ; string s1 = "" ; bool isEven = ( l % 2 == 0 ) ? true : false ; for ( int i = 0 ; i < l ; i += 2 ) { if ( isEven ) { s1 = s [ i ] + s1 ; s1 += s [ i + 1 ] ; } else { if ( l - i > 1 ) { s1 += s [ i ] ; s1 = s [ i + 1 ] + s1 ; } else { s1 += s [ i ] ; } } } return s1 ; }
int maximumChars ( string str ) { int n = str . Length ; int res = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) res = Math . Max ( res , Math . Abs ( j - i - 1 ) ) ; return res ; }
int maximumChars ( string str ) { int n = str . Length ; int res = - 1 ; int [ ] firstInd = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ str [ i ] ] ; if ( first_ind == - 1 ) firstInd [ str [ i ] ] = i ; else res = Math . Max ( res , Math . Abs ( i - first_ind - 1 ) ) ; } return res ; }
bool isUnique ( int [ ] a , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; }
void imageSwap ( int [ , ] mat , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j <= i ; j ++ ) mat [ i , j ] = mat [ i , j ] + mat [ j , i ] - ( mat [ j , i ] = mat [ i , j ] ) ; }
bool isPresent ( string s , string q ) { int [ ] freq = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < s . Length ; i ++ ) freq [ s [ i ] ] ++ ; for ( int i = 0 ; i < q . Length ; i ++ ) { freq [ q [ i ] ] -- ; if ( freq [ q [ i ] ] < 0 ) return false ; } return true ; }
string findString ( int n , int k ) { string res = "" ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( 'a' + i ) ; int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( 'a' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }
bool isValid ( string p ) { int n = p . Length ; int c1 = 0 , c0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] == '0' ) { c0 ++ ; } if ( p [ i ] == '1' ) { c1 ++ ; } } if ( c0 == c1 ) { return true ; } else { return false ; } }
int longestSub ( string s ) { int max_len = 0 ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( isValid ( s . Substring ( i , j - i + 1 ) ) && max_len < j - i + 1 ) { max_len = j - i + 1 ; } } } return max_len ; }
bool isPalindrome ( String s , int i , int j ) { int p = j ; for ( int k = i ; k <= p ; k ++ ) { if ( s [ k ] != s [ p ] ) return false ; p -- ; } return true ; }
int countWays ( String s ) { int n = s . Length ; int count = 0 ; if ( isPalindrome ( s , 0 , n - 1 ) ) { for ( int i = n / 2 ; i < n ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) count ++ ; else break ; } if ( n % 2 == 0 ) { count ++ ; count = 2 * count + 1 ; } else count = 2 * count + 2 ; } else { for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( s [ i ] != s [ n - 1 - i ] ) { int j = n - 1 - i ; if ( isPalindrome ( s , i , n - 2 - i ) ) { for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( s [ k ] != s [ j ] ) break ; count ++ ; } count ++ ; } if ( isPalindrome ( s , i + 1 , n - 1 - i ) ) { for ( int k = n - i ; k < n ; k ++ ) { if ( s [ k ] != s [ i ] ) break ; count ++ ; } count ++ ; } break ; } } } return count ; }
bool makeAndCheckString ( List < String > words , String str ) { int n = words . Count ; bool first = false , second = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( words [ i ] == str ) return true ; if ( str [ 0 ] == words [ i ] [ 1 ] ) first = true ; if ( str [ 1 ] == words [ i ] [ 0 ] ) second = true ; if ( first && second ) return true ; } return false ; }
int countOfSubstringWithKOnes ( string s , int K ) { int N = s . Length ; int res = 0 ; int countOfOne = 0 ; int [ ] freq = new int [ N + 1 ] ; freq [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { countOfOne += ( s [ i ] - '0' ) ; if ( countOfOne >= K ) { res += freq [ countOfOne - K ] ; } freq [ countOfOne ] ++ ; } return res ; }
void printRec ( String number , int extraOnes , int remainingPlaces ) { if ( 0 == remainingPlaces ) { Console . Write ( number + " " ) ; return ; } printRec ( number + "1" , extraOnes + 1 , remainingPlaces - 1 ) ; if ( 0 < extraOnes ) printRec ( number + "0" , extraOnes - 1 , remainingPlaces - 1 ) ; }
void printNums ( int n ) { String str = "" ; printRec ( str , 0 , n ) ; }
string getBinaryRep ( int N , int num_of_bits ) { string r = "" ; num_of_bits -- ; while ( num_of_bits >= 0 ) { if ( ( N & ( 1 << num_of_bits ) ) != 0 ) r += "1" ; else r += "0" ; num_of_bits -- ; } return r ; }
List < string > NBitBinary ( int N ) { List < string > r = new List < string > ( ) ; int first = 1 << ( N - 1 ) ; int last = first * 2 ; for ( int i = last - 1 ; i >= first ; -- i ) { int zero_cnt = 0 ; int one_cnt = 0 ; int t = i ; int num_of_bits = 0 ; while ( t > 0 ) { if ( ( t & 1 ) != 0 ) one_cnt ++ ; else zero_cnt ++ ; num_of_bits ++ ; t = t >> 1 ; } if ( one_cnt >= zero_cnt ) { bool all_prefix_match = true ; int msk = ( 1 << num_of_bits ) - 2 ; int prefix_shift = 1 ; while ( msk > 0 ) { int prefix = ( msk & i ) >> prefix_shift ; int prefix_one_cnt = 0 ; int prefix_zero_cnt = 0 ; while ( prefix > 0 ) { if ( ( prefix & 1 ) != 0 ) prefix_one_cnt ++ ; else prefix_zero_cnt ++ ; prefix = prefix >> 1 ; } if ( prefix_zero_cnt > prefix_one_cnt ) { all_prefix_match = false ; break ; } prefix_shift ++ ; msk = msk & ( msk << 1 ) ; } if ( all_prefix_match ) { r . Add ( getBinaryRep ( i , num_of_bits ) ) ; } } } return r ; }
bool isPossible ( String s1 , String s2 ) { int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < s2 . Length ; i ++ ) count [ ( int ) s2 [ i ] ] ++ ; for ( int i = 0 ; i < s1 . Length ; i ++ ) { if ( count [ ( int ) s1 [ i ] ] == 0 ) return false ; count [ ( int ) s1 [ i ] ] -- ; } return true ; }
bool checkLuhn ( String cardNo ) { int nDigits = cardNo . Length ; int nSum = 0 ; bool isSecond = false ; for ( int i = nDigits - 1 ; i >= 0 ; i -- ) { int d = cardNo [ i ] - '0' ; if ( isSecond == true ) d = d * 2 ; nSum += d / 10 ; nSum += d % 10 ; isSecond = ! isSecond ; } return ( nSum % 10 == 0 ) ; }
bool isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) { return true ; } return false ; }
int findRepeatFirstN2 ( string s ) { int p = - 1 , i , j ; for ( i = 0 ; i < s . Length ; i ++ ) { for ( j = i + 1 ; j < s . Length ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }
bool isVowel ( char c ) { return ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) ; }
bool isVowel ( char x ) { return ( x == 'a' x == 'e' x == 'i' x == 'o' x == 'u' ) ; }
bool isVowel ( char x ) { return ( x == 'a' x == 'e' x == 'i' x == 'o' x == 'u' ) ; }
int substrings ( String s , int k ) { for ( int i = 0 ; i < s . Length ; i ++ ) { int [ ] freq = new int [ MAX_CHAR ] ; for ( int j = i ; j < s . Length ; j ++ ) { int index = s [ j ] - 'a' ; freq [ index ] ++ ; if ( freq [ index ] > k ) break ; else if ( freq [ index ] == k && check ( freq , k ) == true ) res ++ ; } } return res ; }
void longestSubseqWithK ( String str , int k ) { int n = str . Length ; int [ ] freq = new int [ MAX_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str [ i ] - 'a' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - 'a' ] >= k ) { Console . Write ( str [ i ] ) ; } } }
bool canFormPalindrome ( string str ) { int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < str . Length ; i ++ ) count [ str [ i ] ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) != 0 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; }
void generate ( HashSet < String > st , String s ) { if ( s . Length == 0 ) { return ; } if ( ! st . Contains ( s ) ) { st . Add ( s ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { String t = s ; t = t . Substring ( 0 , i ) + t . Substring ( i + 1 ) ; generate ( st , t ) ; } } return ; }
int countSubstrs ( string str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str [ i ] == str [ j ] ) res ++ ; return res ; }
int countManipulations ( string s1 , string s2 ) { int count = 0 ; int [ ] char_count = new int [ 26 ] ; for ( int i = 0 ; i < s1 . Length ; i ++ ) char_count [ s1 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < s2 . Length ; i ++ ) char_count [ s2 [ i ] - 'a' ] -- ; for ( int i = 0 ; i < 26 ; ++ i ) { if ( char_count [ i ] != 0 ) { count += Math . Abs ( char_count [ i ] ) ; } } return count / 2 ; }
char stringPalindrome ( string A , string B ) { int [ ] countA = new int [ MAX_CHAR ] ; int [ ] countB = new int [ MAX_CHAR ] ; int l1 = A . Length ; int l2 = B . Length ; for ( int i = 0 ; i < l1 ; i ++ ) countA [ A [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) countB [ B [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return 'A' ; return 'B' ; }
bool check ( List < String > list , String s ) { int n = ( int ) list . Count ; if ( n == 0 ) { return false ; } for ( int i = 0 ; i < n ; i ++ ) { if ( list [ i ] . Length != s . Length ) { continue ; } bool diff = false ; for ( int j = 0 ; j < ( int ) list [ i ] . Length ; j ++ ) { if ( list [ i ] [ j ] != s [ j ] ) { if ( ! diff ) { diff = true ; } else { diff = false ; break ; } } } if ( diff ) { return true ; } } return false ; }
int FirstRepeated ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . Length ; ++ i ) { int val = ( str [ i ] - 'a' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
void search ( int [ , ] mat , int n , int x ) { int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i , j ] == x ) { Console . Write ( "n Found at " + i + ", " + j ) ; return ; } if ( mat [ i , j ] > x ) j -- ; else i ++ ; } Console . Write ( "n Element not found" ) ; return ; }
void nPermute ( String str , int n ) { precomputeFactorirals ( ) ; int len = str . Length ; int [ ] freq = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < len ; i ++ ) freq [ str [ i ] - 'a' ] ++ ; string ou = "" ; int sum = 10 ; int k = 0 ; while ( sum >= n ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] == 0 ) continue ; freq [ i ] -- ; sum = 0 ; int xsum = ( int ) fact [ len - 1 - k ] ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) xsum /= ( int ) ( fact [ freq [ j ] ] ) ; sum += xsum ; if ( sum >= n ) { ou += ( char ) ( i + 'a' ) ; k ++ ; n -= ( sum - xsum ) ; break ; } if ( sum < n ) freq [ i ] ++ ; } } for ( int i = MAX_CHAR - 1 ; k < len && i >= 0 ; i -- ) if ( freq [ i ] != 0 ) { ou += ( char ) ( i + 'a' ) ; freq [ i ++ ] -- ; } Console . Write ( ou ) ; }
bool sentencePalindrome ( String str ) { int l = 0 ; int h = str . Length - 1 ; str = str . ToLower ( ) ; while ( l <= h ) { char getAtl = str [ l ] ; char getAth = str [ h ] ; if ( ! ( getAtl >= 'a' && getAtl <= 'z' ) ) l ++ ; else if ( ! ( getAth >= 'a' && getAth <= 'z' ) ) h -- ; else if ( getAtl == getAth ) { l ++ ; h -- ; } else return false ; } return true ; }
void substringConversions ( String str , int k , int b ) { for ( int i = 0 ; i + k <= str . Length ; i ++ ) { String sub = str . Substring ( i , k ) ; int sum = 0 , counter = 0 ; for ( int j = sub . Length - 1 ; j >= 0 ; j -- ) { sum = ( int ) ( sum + ( ( sub [ j ] - '0' ) * Math . Pow ( b , counter ) ) ) ; counter ++ ; } Console . Write ( sum + " " ) ; } }
int countBalance ( string s ) { int [ ] rightVisited = new int [ MAX_CHAR ] ; int [ ] leftVisited = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) rightVisited [ s [ i ] ] ++ ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { leftVisited [ s [ i ] ] ++ ; rightVisited [ s [ i ] ] -- ; int j ; for ( j = 0 ; j < MAX_CHAR ; j ++ ) { if ( ( leftVisited [ j ] == 0 && rightVisited [ j ] != 0 ) || ( leftVisited [ j ] != 0 && rightVisited [ j ] == 0 ) ) break ; } if ( j == MAX_CHAR ) res ++ ; } return res ; }
int countWords ( String [ ] str , int n ) { Dictionary < String , int > m = new Dictionary < String , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . ContainsKey ( str [ i ] ) ) { int get = m [ str [ i ] ] ; m . Remove ( str [ i ] ) ; m . Add ( str [ i ] , get + 1 ) ; } else { m . Add ( str [ i ] , 1 ) ; } } int res = 0 ; foreach ( KeyValuePair < String , int > it in m ) { if ( it . Value == 2 ) res ++ ; } return res ; }
int findFlips ( String str , int n ) { char last = ' ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str [ i ] ) res ++ ; last = str [ i ] ; } return res / 2 ; }
int findLen ( string A , int n , int k , char ch ) { int maxlen = 1 ; int cnt = 0 ; int l = 0 , r = 0 ; while ( r < n ) { if ( A [ r ] != ch ) { ++ cnt ; } while ( cnt > k ) { if ( A [ l ] != ch ) { -- cnt ; } ++ l ; } maxlen = Math . Max ( maxlen , r - l + 1 ) ; ++ r ; } return maxlen ; }
int answer ( string A , int n , int k ) { int maxlen = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) { maxlen = Math . Max ( maxlen , findLen ( A , n , k , ( char ) ( i + 'A' ) ) ) ; maxlen = Math . Max ( maxlen , findLen ( A , n , k , ( char ) ( i + 'a' ) ) ) ; } return maxlen ; }
void printString ( string str , char ch , int count ) { int occ = 0 , i ; if ( count == 0 ) { Console . WriteLine ( str ) ; return ; } for ( i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . Length - 1 ) Console . WriteLine ( str . Substring ( i + 1 ) ) ; else Console . WriteLine ( "Empty string" ) ; }
bool checkCorrectOrNot ( string s ) { int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int n = s . Length ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count1 [ s [ i ] - 'a' ] ++ ; count2 [ s [ j ] - 'a' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; }
bool checkCorrectOrNot ( String s ) { int [ ] count = new int [ MAX_CHAR ] ; int n = s . Length ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s [ i ] - 'a' ] ++ ; count [ s [ j ] - 'a' ] -- ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; }
int possibleStrings ( int n , int r , int b , int g ) { int [ ] fact = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
bool checkString ( String s ) { int len = s . Length ; int first = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s [ i ] == '1' ) { first = i ; break ; } } int last = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) { last = i ; break ; } } for ( int i = first ; i <= last ; i ++ ) if ( s [ i ] == '0' ) return false ; return true ; }
bool isVowel ( char c ) { return ( c == 'a' c == 'A' c == 'e' c == 'E' c == 'i' c == 'I' c == 'o' c == 'O' c == 'u' c == 'U' ) ; }
bool isUnique ( int [ , ] mat , int i , int j , int n , int m ) { int sumrow = 0 ; for ( int k = 0 ; k < m ; k ++ ) { sumrow += mat [ i , k ] ; if ( sumrow > 1 ) return false ; } int sumcol = 0 ; for ( int k = 0 ; k < n ; k ++ ) { sumcol += mat [ k , j ] ; if ( sumcol > 1 ) return false ; } return true ; }
void findAndPrintUncommonChars ( String str1 , String str2 ) { int [ ] present = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { present [ i ] = 0 ; } int l1 = str1 . Length ; int l2 = str2 . Length ; for ( int i = 0 ; i < l1 ; i ++ ) { present [ str1 [ i ] - 'a' ] = 1 ; } for ( int i = 0 ; i < l2 ; i ++ ) { if ( present [ str2 [ i ] - 'a' ] == 1 present [ str2 [ i ] - 'a' ] == - 1 ) { present [ str2 [ i ] - 'a' ] = - 1 ; } else { present [ str2 [ i ] - 'a' ] = 2 ; } } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( present [ i ] == 1 present [ i ] == 2 ) { Console . Write ( ( char ) ( i + 'a' ) + " " ) ; } } }
int countUnique ( int [ , ] mat , int n , int m ) { int [ ] rowsum = new int [ n ] ; int [ ] colsum = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i , j ] != 0 ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i , j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }
virtual int lengthOfLastWord ( string a ) { int len = 0 ; string x = a . Trim ( ) ; for ( int i = 0 ; i < x . Length ; i ++ ) { if ( x [ i ] == ' ' ) { len = 0 ; } else { len ++ ; } } return len ; }
bool isVowel ( char ch ) { ch = char . ToUpper ( ch ) ; return ( ch == 'A' ch == 'E' ch == 'I' ch == 'O' ch == 'U' ) ; }
int countVowels ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { ++ count ; } } return count ; }
int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
int countDistinctPermutations ( String str ) { int length = str . Length ; int [ ] freq = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < length ; i ++ ) if ( str [ i ] >= 'a' ) freq [ str [ i ] - 'a' ] ++ ; int fact = 1 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) fact = fact * factorial ( freq [ i ] ) ; return factorial ( length ) / fact ; }
virtual bool uniqueCharacters ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { int bitAtIndex = str [ i ] - 'a' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } return true ; }
int solve ( int i , int X , int Y , int [ ] a , int [ ] b , int n ) { if ( i == n ) return 0 ; if ( X <= 0 ) return b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ; if ( Y <= 0 ) return a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) ; else return Math . Max ( a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) , b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ) ; }
char smallest_alphabet ( String a , int n ) { char min = 'z' ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] < min ) min = a [ i ] ; return min ; }
bool isPalindrome ( String str ) { int n = str . Length ; for ( int i = 0 ; i < n / 2 ; i ++ ) if ( str [ i ] != str [ n - i - 1 ] ) return false ; return true ; }
void moveSpaceInFront ( char [ ] str ) { int i = str . Length - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ' ) { char c = str [ i ] ; str [ i ] = str [ j ] ; str [ j ] = c ; i -- ; } }
int countCommon ( int [ , ] mat , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i , i ] == mat [ i , n - i - 1 ] ) res ++ ; return res ; }
void moveSpaceInFront ( char [ ] str ) { int i = str . Length - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ' ; }
int titleToNumber ( string s ) { int result = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { result *= 26 ; result += s [ i ] - 'A' + 1 ; } return result ; }
void isKthBitSet ( int n , int k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) Console . Write ( "SET" ) ; else Console . Write ( "NOT SET" ) ; }
void isKthBitSet ( int n , int k ) { if ( ( ( n >> ( k - 1 ) ) & 1 ) > 0 ) Console . WriteLine ( "SET" ) ; else Console . WriteLine ( "NOT SET" ) ; }
bool isPalindrome ( String str ) { int n = str . Length ; if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; }
bool areSumSame ( int [ , ] a , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i , j ] ; sum2 += a [ j , i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }
int getIdx ( char ch ) { return ( ch - 'a' ) ; }
bool allSame ( int [ ] freq , int N ) { int same = 0 ; int i ; for ( i = 0 ; i < N ; i ++ ) { if ( freq [ i ] > 0 ) { same = freq [ i ] ; break ; } } for ( int j = i + 1 ; j < N ; j ++ ) if ( freq [ j ] > 0 && freq [ j ] != same ) return false ; return true ; }
bool possibleSameCharFreqByOneRemoval ( string str ) { int l = str . Length ; int [ ] freq = new int [ M ] ; for ( int i = 0 ; i < l ; i ++ ) freq [ getIdx ( str [ i ] ) ] ++ ; if ( allSame ( freq , M ) ) return true ; for ( char c = 'a' ; c <= 'z' ; c ++ ) { int i = getIdx ( c ) ; if ( freq [ i ] > 0 ) { freq [ i ] -- ; if ( allSame ( freq , M ) ) return true ; freq [ i ] ++ ; } } return false ; }
int findIndex ( string str ) { int len = str . Length ; int [ ] open = new int [ len + 1 ] ; int [ ] close = new int [ len + 1 ] ; int index = - 1 ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str [ 0 ] == '(' ) open [ 1 ] = 1 ; if ( str [ len - 1 ] == ')' ) close [ len - 1 ] = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] == '(' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; } for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] == ')' ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; } if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ; for ( int i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; }
bool checkEquality ( string s ) { return ( s [ 0 ] == s [ s . Length - 1 ] ) ; }
int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . Length ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ s [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
int getValue ( String str , int i , int m ) { if ( i + m > str . Length ) { return - 1 ; } int value = 0 ; for ( int j = 0 ; j < m ; j ++ ) { int c = str [ i + j ] - '0' ; if ( c < 0 c > 9 ) { return - 1 ; } value = value * 10 + c ; } return value ; }
int findMissingNumber ( String str ) { for ( int m = 1 ; m <= MAX_DIGITS ; ++ m ) { int n = getValue ( str , 0 , m ) ; if ( n == - 1 ) { break ; } int missingNo = - 1 ; bool fail = false ; for ( int i = m ; i != str . Length ; i += 1 + ( int ) Math . Log10 ( n ) ) { if ( ( missingNo == - 1 ) && ( getValue ( str , i , ( int ) ( 1 + Math . Log10 ( n + 2 ) ) ) == n + 2 ) ) { missingNo = n + 1 ; n += 2 ; else if ( getValue ( str , i , ( int ) ( 1 + Math . Log10 ( n + 1 ) ) ) == n + 1 ) { n ++ ; } else { fail = true ; break ; } } if ( ! fail ) { return missingNo ; } } }
bool isSmaller ( string str1 , string str2 ) { int n1 = str1 . Length , n2 = str2 . Length ; if ( n1 < n2 ) return true ; if ( n2 < n1 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( str1 [ i ] < str2 [ i ] ) return true ; else if ( str1 [ i ] > str2 [ i ] ) return false ; } return false ; }
char maxRepeating ( string str ) { int len = str . Length ; int count = 0 ; char res = str [ 0 ] ; for ( int i = 0 ; i < len ; i ++ ) { int cur_count = 1 ; for ( int j = i + 1 ; j < len ; j ++ ) { if ( str [ i ] != str [ j ] ) break ; cur_count ++ ; } if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } } return res ; }
bool isSymmetric ( int [ , ] mat , int N ) { int [ , ] tr = new int [ N , MAX ] ; transpose ( mat , tr , N ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i , j ] != tr [ i , j ] ) return false ; return true ; }
char maxRepeating ( string str ) { int n = str . Length ; int count = 0 ; char res = str [ 0 ] ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; }
bool check ( string str ) { int n = str . Length ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - '0' ) ; else evenDigSum += ( str [ i ] - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
bool isSubSequence ( String str1 , String str2 ) { int m = str1 . Length , n = str2 . Length ; for ( int i = 0 ; i < n && j < m ; i ++ ) { if ( str1 [ j ] == str2 [ i ] ) { j ++ ; } } return ( j == m ) ; }
bool isSymmetric ( int [ , ] mat , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i , j ] != mat [ j , i ] ) return false ; return true ; }
int countWords ( string str , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ; else if ( str [ j ] == str [ j - 1 ] str [ j ] == str [ j + 1 ] str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ; else count *= 3 ; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; }
int hammingDist ( String str1 , String str2 ) { int i = 0 , count = 0 ; while ( i < str1 . Length ) { if ( str1 [ i ] != str2 [ i ] ) count ++ ; i ++ ; } return count ; }
int replaceDig ( int x , int from , int to ) { int result = 0 ; int multiply = 1 ; while ( x > 0 ) { int reminder = x % 10 ; if ( reminder == from ) result = result + to * multiply ; else result = result + reminder * multiply ; multiply *= 10 ; x = x / 10 ; } return result ; }
void calculateMinMaxSum ( int x1 , int x2 ) { int minSum = replaceDig ( x1 , 6 , 5 ) + replaceDig ( x2 , 6 , 5 ) ; int maxSum = replaceDig ( x1 , 5 , 6 ) + replaceDig ( x2 , 5 , 6 ) ; Console . Write ( "Minimum sum = " + minSum ) ; Console . Write ( "\nMaximum sum = " + maxSum ) ; }
void qType2 ( int l , int r , char [ ] str ) { int [ ] freq = new int [ 27 ] ; for ( int i = l - 1 ; i <= r - 1 ; i ++ ) { freq [ str [ i ] - 'a' ] ++ ; } int count = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( freq [ j ] % 2 != 0 ) { count ++ ; } } if ( count <= 1 ) { Console . WriteLine ( "Yes" ) ; } else { Console . WriteLine ( "No" ) ; } }
void update ( int [ , ] tree , int idx , int val , int i ) { while ( idx <= max ) { tree [ idx , i ] += val ; idx += ( idx & - idx ) ; } }
void buildBIT ( int [ , ] tree , char [ ] str , int n ) { for ( int i = 0 ; i < n ; i ++ ) update ( tree , i + 1 , 1 , str [ i ] - 97 + 1 ) ; }
void precompute ( int [ , ] mat , string str , int len ) { for ( int i = 0 ; i < CHAR_SIZE ; ++ i ) mat [ len , i ] = len ; for ( int i = len - 1 ; i >= 0 ; -- i ) { for ( int j = 0 ; j < CHAR_SIZE ; ++ j ) mat [ i , j ] = mat [ i + 1 , j ] ; mat [ i , str [ i ] - 'a' ] = i ; } }
bool query ( int [ , ] mat , string str , int len ) { int pos = 0 ; for ( int i = 0 ; i < str . Length ; ++ i ) { if ( mat [ pos , str [ i ] - 'a' ] >= len ) return false ; else pos = mat [ pos , str [ i ] - 'a' ] + 1 ; } return true ; }
string findTwoscomplement ( StringBuilder str ) { int n = str . Length ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '1' ) { break ; } } if ( i == - 1 ) { return "1" + str ; } for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str [ k ] == '1' ) { str . Remove ( k , k + 1 - k ) . Insert ( k , "0" ) ; } else { str . Remove ( k , k + 1 - k ) . Insert ( k , "1" ) ; } } return str . ToString ( ) ; }
bool isequal ( string str ) { int n = str . Length ; int num = 0 , x = 1 , i = n - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( '0' <= str [ i ] && str [ i ] <= '9' ) { num = ( str [ i ] - '0' ) * x + num ; x = x * 10 ; if ( num >= n ) return false ; } else break ; } return num == i + 1 ; }
bool arekAnagrams ( string str1 , string str2 , int k ) { int n = str1 . Length ; if ( str2 . Length != n ) return false ; int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) count1 [ str1 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . Abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }
bool areKAnagrams ( String str1 , String str2 , int k ) { int n = str1 . Length ; if ( str2 . Length != n ) return false ; int [ ] hash_str1 = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) hash_str1 [ str1 [ i ] - 'a' ] ++ ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ str2 [ i ] - 'a' ] > 0 ) hash_str1 [ str2 [ i ] - 'a' ] -- ; else count ++ ; if ( count > k ) return false ; } return true ; }
int countToMake0lternate ( string s ) { int result = 0 ; for ( int i = 0 ; i < ( s . Length - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }
char getDigit ( int N , int d ) { string str = Convert . ToString ( N ) ; return str [ d - 1 ] ; }
char getNthChar ( int N ) { int sum = 0 , nine = 9 ; int dist = 0 , len ; for ( len = 1 ; ; len ++ ) { sum += nine * len ; dist += nine ; if ( sum >= N ) { sum -= nine * len ; dist -= nine ; N -= sum ; break ; } nine *= 10 ; } int diff = ( int ) ( Math . Ceiling ( ( double ) ( N ) / ( double ) ( len ) ) ) ; int d = N % len ; if ( d == 0 ) d = len ; return getDigit ( dist + diff , d ) ; }
bool ispalindrome ( String s ) { int l = s . Length ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s [ i ] != s [ j ] ) { return false ; } } return true ; }
int findCount ( string str ) { int result = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( i == ( str [ i ] - 'a' ) || i == ( str [ i ] - 'A' ) ) result ++ ; return result ; }
void sortByPattern ( char [ ] str , char [ ] pat ) { int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . Length ; i ++ ) { count [ str [ i ] - 'a' ] ++ ; } int index = 0 ; for ( int i = 0 ; i < pat . Length ; i ++ ) { for ( int j = 0 ; j < count [ pat [ i ] - 'a' ] ; j ++ ) { str [ index ++ ] = pat [ i ] ; } } }
char flip ( char ch ) { return ( ch == '0' ) ? '1' : '0' ; }
int getFlipWithStartingCharcter ( String str , char expected ) { int flipCount = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] != expected ) flipCount ++ ; expected = flip ( expected ) ; } return flipCount ; }
int minFlipToMakeStringAlternate ( string str ) { return Math . Min ( getFlipWithStartingCharcter ( str , '0' ) , getFlipWithStartingCharcter ( str , '1' ) ) ; }
int remAnagram ( string str1 , string str2 ) { int [ ] count1 = new int [ 26 ] ; int [ ] count2 = new int [ 26 ] ; for ( int i = 0 ; i < str1 . Length ; i ++ ) count1 [ str1 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < str2 . Length ; i ++ ) count2 [ str2 [ i ] - 'a' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += Math . Abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }
bool isPalin ( string str ) { int len = str . Length / 2 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] != str [ str . Length - i - 1 ] ) { return false ; } } return true ; }
int remainderWith7 ( String num ) { int [ ] series = { 1 , 3 , 2 , - 1 , - 3 , - 2 } ; int series_index = 0 ; int result = 0 ; for ( int i = num . Length - 1 ; i >= 0 ; i -- ) { int digit = num [ i ] - '0' ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; }
bool checkForVariation ( String str ) { if ( str == null str . Length != 0 ) { return true ; } Dictionary < char , int > map = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( map . ContainsKey ( str [ i ] ) ) map [ str [ i ] ] = map [ str [ i ] ] + 1 ; else map . Add ( str [ i ] , 1 ) ; } bool first = true , second = true ; int val1 = 0 , val2 = 0 ; int countOfVal1 = 0 , countOfVal2 = 0 ; foreach ( KeyValuePair < char , int > itr in map ) { int i = itr . Key ; if ( first ) { val1 = i ; first = false ; countOfVal1 ++ ; continue ; } if ( i == val1 ) { countOfVal1 ++ ; continue ; } if ( second ) { val2 = i ; countOfVal2 ++ ; second = false ; continue ; } if ( i == val2 ) { countOfVal2 ++ ; continue ; } return false ; } if ( countOfVal1 > 1 && countOfVal2 > 1 ) { return false ; } else { return true ; } }
void waysToPaint ( int n ) { long same = 6 ; long diff = 6 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long sameTmp = 3 * same + 2 * diff ; long diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } Console . WriteLine ( same + diff ) ; }
bool isReversible ( string str ) { int i = 0 , j = str . Length - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) { return false ; } i ++ ; j -- ; } return true ; }
int findPossibleMoves ( int [ , ] mat , int p , int q ) { int [ ] X = { 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 } ; int [ ] Y = { 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 } ; int count = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int x = p + X [ i ] ; int y = q + Y [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x , y ] == 0 ) count ++ ; } return count ; }
int countCompletePairs ( String [ ] set1 , String [ ] set2 , int n , int m ) { int result = 0 ; int [ ] con_s1 = new int [ n ] ; int [ ] con_s2 = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { con_s1 [ i ] = 0 ; for ( int j = 0 ; j < set1 [ i ] . Length ; j ++ ) { con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( set1 [ i ] [ j ] - 'a' ) ) ; } } for ( int i = 0 ; i < m ; i ++ ) { con_s2 [ i ] = 0 ; for ( int j = 0 ; j < set2 [ i ] . Length ; j ++ ) { con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( set2 [ i ] [ j ] - 'a' ) ) ; } } long complete = ( 1 << 26 ) - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) { result ++ ; } } } return result ; }
bool checkPattern ( String str , String pat ) { int [ ] label = new int [ CHAR_SIZE ] ; for ( int i = 0 ; i < CHAR_SIZE ; i ++ ) label [ i ] = - 1 ; int order = 1 ; for ( int i = 0 ; i < pat . Length ; i ++ ) { label [ pat [ i ] ] = order ; order ++ ; } int last_order = - 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( label [ str [ i ] ] != - 1 ) { if ( label [ str [ i ] ] < last_order ) return false ; last_order = label [ str [ i ] ] ; } } return true ; }
char encodedChar ( string str , int k ) { String expand = "" ; for ( int i = 0 ; i < str . Length ; ) { while ( i < str . Length && str [ i ] >= 'a' && str [ i ] <= 'z' ) { temp += str [ i ] ; i ++ ; } while ( i < str . Length && str [ i ] >= '1' && str [ i ] <= '9' ) { freq = freq * 10 + str [ i ] - '0' ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) expand += temp ; } if ( freq == 0 ) expand += temp ; return expand [ k - 1 ] ; }
void findMatchedWords ( String [ ] dict , String pattern ) { int len = pattern . Length ; String hash = encodeString ( pattern ) ; foreach ( String word in dict ) { if ( word . Length == len && encodeString ( word ) . Equals ( hash ) ) Console . Write ( word + " " ) ; } }
bool check ( string pattern , string word ) { if ( pattern . Length != word . Length ) return false ; int [ ] ch = new int [ 128 ] ; int Len = word . Length ; for ( int i = 0 ; i < Len ; i ++ ) { if ( ch [ ( int ) pattern [ i ] ] == 0 ) { ch [ ( int ) pattern [ i ] ] = word [ i ] ; } else if ( ch [ ( int ) pattern [ i ] ] != word [ i ] ) { return false ; } } return true ; }
int findSum ( String str ) { String temp = "0" ; int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { char ch = str [ i ] ; if ( char . IsDigit ( ch ) ) temp += ch ; else { sum += int . Parse ( temp ) ; temp = "0" ; } } return sum + int . Parse ( temp ) ; }
int countkDist ( string str , int k ) { int res = 0 ; int n = str . Length ; int [ ] cnt = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ; Array . Clear ( cnt , 0 , cnt . Length ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str [ j ] - 'a' ] == 0 ) dist_count ++ ; cnt [ str [ j ] - 'a' ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; }
string commonPrefixUtil ( string str1 , string str2 ) { string result = "" ; int n1 = str1 . Length , n2 = str2 . Length ; for ( int i = 0 , j = 0 ; i <= n1 - 1 && j <= n2 - 1 ; i ++ , j ++ ) { if ( str1 [ i ] != str2 [ j ] ) break ; result += str1 [ i ] ; } return ( result ) ; }
string commonPrefix ( string [ ] arr , int low , int high ) { if ( low == high ) return ( arr [ low ] ) ; if ( high > low ) { int mid = low + ( high - low ) / 2 ; string str1 = commonPrefix ( arr , low , mid ) ; string str2 = commonPrefix ( arr , mid + 1 , high ) ; return ( commonPrefixUtil ( str1 , str2 ) ) ; } return null ; }
int countTriplets ( int [ ] A ) { int cnt = 0 ; Dictionary < int , int > tuples = new Dictionary < int , int > ( ) ; foreach ( int a in A ) foreach ( int b in A ) { if ( tuples . ContainsKey ( a & b ) ) tuples [ a & b ] = tuples [ a & b ] + 1 ; else tuples . Add ( a & b , 1 ) ; } foreach ( int a in A ) foreach ( KeyValuePair < int , int > t in tuples ) if ( ( t . Key & a ) == 0 ) cnt += t . Value ; return cnt ; }
bool isPalindrome ( String str ) { int l = 0 ; int h = str . Length - 1 ; while ( h > l ) if ( str [ l ++ ] != str [ h -- ] ) return false ; return true ; }
char flip ( char c ) { return ( c == '0' ) ? '1' : '0' ; }
string zigZagConcat ( string s , int n ) { if ( n <= 1 ) { return s ; } string result = "" ; for ( int rowNum = 0 ; rowNum < n ; rowNum ++ ) { int i = rowNum ; bool up = true ; while ( i < s . Length ) { result += s [ i ] ; if ( rowNum == 0 rowNum == n - 1 ) { i += ( 2 * n - 2 ) ; } else { if ( up ) { i += ( 2 * ( n - rowNum ) - 2 ) ; } else { i += rowNum * 2 ; } up ^= true ; } } } return result ; }
bool isEditDistanceOne ( String s1 , String s2 ) { int m = s1 . Length , n = s2 . Length ; if ( Math . Abs ( m - n ) > 1 ) return false ; int count = 0 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 [ i ] != s2 [ j ] ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; else { i ++ ; j ++ ; } count ++ ; } else { i ++ ; j ++ ; } } if ( i < m < n ) count ++ ; return count == 1 ; }
int countOccurrences ( int x , int d ) { int count = 0 ; while ( x > 0 ) { if ( x % 10 == d ) count ++ ; x = x / 10 ; } return count ; }
int maxOccurring ( int x ) { if ( x < 0 ) x = - x ; int result = 0 ; int max_count = 1 ; for ( int d = 0 ; d <= 9 ; d ++ ) { int count = countOccurrences ( x , d ) ; if ( count >= max_count ) { max_count = count ; result = d ; } } return result ; }
int maxSubarrayXOR ( int [ ] arr , int n ) { int ans = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . Max ( ans , curr_xor ) ; } } return ans ; }
int cntNum ( String X , int i , int sum , int tight , int [ , , ] dp ) { if ( i >= X . Length sum < 0 ) { if ( sum == 0 ) { return 1 ; } return 0 ; } if ( dp [ sum , i , tight ] != - 1 ) { return dp [ sum , i , tight ] ; } int res = 0 ; int end = tight != 0 ? X [ i ] - '0' : 9 ; for ( int j = 0 ; j <= end ; j ++ ) { res += cntNum ( X , i + 1 , sum - j , ( tight > 0 & ( j == end ) ) == true ? 1 : 0 , dp ) ; } return dp [ sum ] [ i ] [ tight ] = res ; }
int UtilCntNumRange ( int L , int R , int Y ) { if ( R == 0 && Y == 0 ) { return 1 ; } String str = String . Join ( "" , R ) ; int [ , , ] dp = new int [ M , M , 2 ] ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < 2 ; k ++ ) dp [ i , j , k ] = - 1 ; } } int cntR = cntNum ( str , 0 , Y , 1 , dp ) ; str = String . Join ( "" , L - 1 ) ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < 2 ; k ++ ) dp [ i , j , k ] = - 1 ; } } int cntL = cntNum ( str , 0 , Y , 1 , dp ) ; return ( cntR - cntL ) ; }
bool areIsomorphic ( String str1 , String str2 ) { int m = str1 . Length ; int n = str2 . Length ; if ( m != n ) return false ; bool [ ] marked = new bool [ size ] ; for ( int i = 0 ; i < size ; i ++ ) marked [ i ] = false ; int [ ] map = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) map [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( map [ str1 [ i ] ] == - 1 ) { if ( marked [ str2 [ i ] ] == true ) return false ; marked [ str2 [ i ] ] = true ; map [ str1 [ i ] ] = str2 [ i ] ; } else if ( map [ str1 [ i ] ] != str2 [ i ] ) return false ; } return true ; }
bool isPalin ( char [ ] str , int st , int end ) { while ( st < end ) { if ( str [ st ] != str [ end ] ) return false ; st ++ ; end -- ; } return true ; }
int findMinInsert ( char [ ] str , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( isPalin ( str , 0 , i ) ) return ( n - i - 1 ) ; } return 0 ; }
long removeRecur ( long n ) { long prev_digit = n % 10 ; long pow = 10 ; long res = prev_digit ; while ( n > 0 ) { long curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = n / 10 ; } return res ; }
int removeSpaces ( char [ ] str ) { int count = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( str [ i ] != ' ' ) return count ; }
bool isValid ( int [ ] count , int k ) { int val = 0 ; for ( int i = 0 ; i < MAX_CHARS ; i ++ ) { if ( count [ i ] > 0 ) { val ++ ; } } return ( k >= val ) ; }
void kUniques ( string s , int k ) { int u = 0 ; int n = s . Length ; int [ ] count = new int [ MAX_CHARS ] ; Array . Fill ( count , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ s [ i ] - 'a' ] == 0 ) { u ++ ; } count [ s [ i ] - 'a' ] ++ ; } if ( u < k ) { Console . Write ( "Not enough unique characters" ) ; return ; } int curr_start = 0 , curr_end = 0 ; int max_window_size = 1 ; int max_window_start = 0 ; Array . Fill ( count , 0 ) ; count [ s [ 0 ] - 'a' ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { count [ s [ i ] - 'a' ] ++ ; curr_end ++ ; while ( ! isValid ( count , k ) ) { count [ s [ curr_start ] - 'a' ] -- ; curr_start ++ ; } if ( curr_end - curr_start + 1 > max_window_size ) { max_window_size = curr_end - curr_start + 1 ; max_window_start = curr_start ; } } Console . WriteLine ( "Max substring is : " + s . Substring ( max_window_start , max_window_size ) + " with length " + max_window_size ) ; }
bool canFormPalindrome ( string str ) { int [ ] count = new int [ NO_OF_CHARS ] ; Array . Fill ( count , 0 ) ; for ( int i = 0 ; i < str . Length ; i ++ ) count [ ( int ) ( str [ i ] ) ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) == 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; }
int count9s ( String number ) { int count = 0 ; int n = number . Length ; for ( int i = 0 ; i < n ; i ++ ) { int sum = number [ i ] - '0' ; if ( number [ i ] == '9' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number [ j ] - '0' ) % 9 ; if ( sum == 0 ) count ++ ; } } return count ; }
int difference ( int [ , ] arr , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i , i ] ; d2 += arr [ i , n - i - 1 ] ; } return Math . Abs ( d1 - d2 ) ; }
List < String > generateGray ( int n ) { if ( n <= 0 ) { List < String > temp = new List < String > ( ) ; temp . Add ( "0" ) ; return temp ; } if ( n == 1 ) { List < String > temp = new List < String > ( ) ; temp . Add ( "0" ) ; temp . Add ( "1" ) ; return temp ; } List < String > recAns = generateGray ( n - 1 ) ; List < String > mainAns = new List < String > ( ) ; for ( int i = 0 ; i < recAns . Count ; i ++ ) { String s = recAns [ i ] ; mainAns . Add ( "0" + s ) ; } for ( int i = recAns . Count - 1 ; i >= 0 ; i -- ) { String s = recAns [ i ] ; mainAns . Add ( "1" + s ) ; } return mainAns ; }
bool areAnagram ( char [ ] str1 , char [ ] str2 ) { int [ ] count1 = new int [ NO_OF_CHARS ] ; int [ ] count2 = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str1 . Length && i < str2 . Length ; i ++ ) { count1 [ str1 [ i ] ] ++ ; count2 [ str2 [ i ] ] ++ ; } if ( str1 . Length != str2 . Length ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; }
bool areAnagram ( char [ ] str1 , char [ ] str2 ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str1 . Length ; i ++ ) { count [ str1 [ i ] - 'a' ] ++ ; count [ str2 [ i ] - 'a' ] -- ; } if ( str1 . Length != str2 . Length ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count [ i ] != 0 ) { return false ; } return true ; }
int longestUniqueSubsttr ( string str ) { int n = str . Length ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( areDistinct ( str , i , j ) ) res = Math . Max ( res , j - i + 1 ) ; return res ; }
int longestUniqueSubsttr ( string str ) { int n = str . Length ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { bool [ ] visited = new bool [ 256 ] ; for ( int j = i ; j < n ; j ++ ) { if ( visited [ str [ j ] ] == true ) break ; else { res = Math . Max ( res , j - i + 1 ) ; visited [ str [ j ] ] = true ; } } visited [ str [ i ] ] = false ; } return res ; }
void spiralFill ( int m , int n , int [ , ] a ) { int val = 1 ; int k = 0 , l = 0 ; while ( k < m && l < n ) { for ( int i = l ; i < n ; ++ i ) { a [ k , i ] = val ++ ; } k ++ ; for ( int i = k ; i < m ; ++ i ) { a [ i , n - 1 ] = val ++ ; } n -- ; if ( k < m ) { for ( int i = n - 1 ; i >= l ; -- i ) { a [ m - 1 , i ] = val ++ ; } m -- ; } if ( l < n ) { for ( int i = m - 1 ; i >= k ; -- i ) { a [ i , l ] = val ++ ; } l ++ ; } } }
bool isValid ( int [ , ] board , int i , int j , int K ) { if ( board [ i , j ] <= K ) { return true ; } return false ; }
bool findPath ( int [ , ] board , int X , int Y , int M , int N , int K ) { if ( X < 0 == M Y < 0 Y == N ) { return true ; } if ( isValid ( board , X , Y , K ) ) { int board_XY = board [ X , Y ] ; board [ X , Y ] = int . MaxValue ; if ( findPath ( board , X + 1 , Y , M , N , K - board_XY ) || findPath ( board , X - 1 , Y , M , N , K - board_XY ) || findPath ( board , X , Y + 1 , M , N , K - board_XY ) || findPath ( board , X , Y - 1 , M , N , K - board_XY ) ) { return true ; } board [ X , Y ] = board_XY ; } return false ; }
void pathMoves ( char [ , ] mat , Point src , Point dest ) { int [ , ] d = new int [ ROW , COL ] ; for ( int i = 0 ; i < ROW ; i ++ ) { for ( int j = 0 ; j < COL ; j ++ ) d [ i , j ] = - 1 ; } d [ src . x , src . y ] = 0 ; bool [ , ] visited = new bool [ ROW , COL ] ; visited [ src . x , src . y ] = true ; Queue < Node > q = new Queue < Node > ( ) ; Node s = newNode ( src , 0 ) ; q . Enqueue ( s ) ; bool ok = false ; while ( q . Count > 0 ) { Node curr = q . Peek ( ) ; q . Dequeue ( ) ; Point pt = curr . pt ; if ( pt . x == dest . x && pt . y == dest . y ) { int xx = pt . x , yy = pt . y ; int dist = curr . dist ; d [ pt . x , pt . y ] = dist ; string pathmoves = "" ; while ( xx != src . x yy != src . y ) { if ( xx > 0 && d [ xx - 1 , yy ] == dist - 1 ) { pathmoves += 'D' ; xx -- ; } if ( xx < ROW - 1 && d [ xx + 1 , yy ] == dist - 1 ) { pathmoves += 'U' ; xx ++ ; } if ( yy > 0 && d [ xx , yy - 1 ] == dist - 1 ) { pathmoves += 'R' ; yy -- ; } if ( yy < COL - 1 && d [ xx , yy + 1 ] == dist - 1 ) { pathmoves += 'L' ; yy ++ ; } dist -- ; } for ( int i = pathmoves . Length - 1 ; i >= 0 ; -- i ) Console . Write ( pathmoves [ i ] ) ; ok = true ; break ; } if ( q . Count > 0 ) { q . Peek ( ) ; q . Dequeue ( ) ; } for ( int i = 0 ; i < 4 ; i ++ ) { int row = pt . x + dRow [ i ] ; int col = pt . y + dCol [ i ] ; if ( isValid ( row , col ) && ( mat [ row , col ] == '1' mat [ row , col ] == 's' mat [ row , col ] == 'd' ) && ! visited [ row , col ] ) { visited [ row , col ] = true ; Node adjCell = newNode ( newPoint ( row , col ) , curr . dist + 1 ) ; q . Enqueue ( adjCell ) ; d [ row , col ] = curr . dist + 1 ; } } } if ( ok == false ) Console . Write ( - 1 ) ; }
int isPerfect ( int x ) { int sum_div = 1 ; for ( int i = 2 ; i <= x / 2 ; ++ i ) { if ( x % i == 0 ) { sum_div += i ; } } if ( sum_div == x ) { return 1 ; } else return 0 ; }
int isPerfect ( int x ) { int sum_div = 1 ; for ( int i = 2 ; i <= x / 2 ; ++ i ) { if ( x % i == 0 ) { sum_div += i ; } } if ( sum_div == x ) { return 1 ; } else return 0 ; }
void subsetSum ( int [ ] arr , int n ) { long total = 1 << n ; for ( long i = 0 ; i < total ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( i & ( 1 << j ) ) != 0 ) sum += arr [ j ] ; if ( isPerfect ( sum ) != 0 ) { Console . Write ( sum + " " ) ; } } }
void factorial ( int N ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; }
void printLevelOrder ( node root ) { if ( root == null ) return ; Queue < node > q = new Queue < node > ( ) ; q . Enqueue ( root ) ; while ( q . Count != 0 ) { node temp = q . Peek ( ) ; Console . Write ( temp . data + " " ) ; q . Dequeue ( ) ; if ( temp . left != null ) { q . Enqueue ( temp . left ) ; } else if ( temp . right != null ) { Console . Write ( "null " ) ; } if ( temp . right != null ) { q . Enqueue ( temp . right ) ; } else if ( temp . left != null ) { Console . Write ( "null " ) ; } } }
void PenGame ( int N ) { int P1 = 0 ; int P2 = 0 ; int X = 0 ; int Move = 0 ; bool QuitP1 = false ; bool QuitP2 = false ; solve ( N , P1 , P2 , X , Move , QuitP1 , QuitP2 ) ; }
int findTrace ( int [ , ] mat , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += mat [ i , i ] ; return sum ; }
void checkUntil ( int num , int K , int N , List < int > ans ) { if ( N == 1 ) { ans . Add ( num ) ; return ; } if ( ( num % 10 + K ) <= 9 ) checkUntil ( 10 * num + ( num % 10 + K ) , K , N - 1 , ans ) ; if ( K > 0 ) { if ( ( num % 10 - K ) >= 0 ) checkUntil ( 10 * num + num % 10 - K , K , N - 1 , ans ) ; } }
void check ( int K , int N , List < int > ans ) { for ( int i = 1 ; i <= 9 ; i ++ ) { checkUntil ( i , K , N , ans ) ; } }
void comb ( int [ ] arr , int len , int r , int ipos , int [ ] op , int opos , int sum ) { if ( opos == r ) { int sum2 = 0 ; for ( int i = 0 ; i < opos ; i ++ ) { sum2 = sum2 + op [ i ] ; } if ( sum == sum2 ) { for ( int i = 0 ; i < opos ; i ++ ) Console . Write ( op [ i ] + ", " ) ; Console . WriteLine ( ) ; } return ; } if ( ipos < len ) { comb ( arr , len , r , ipos + 1 , op , opos , sum ) ; op [ opos ] = arr [ ipos ] ; comb ( arr , len , r , ipos + 1 , op , opos + 1 , sum ) ; } }
void SieveOfEratosthenes ( bool [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
void primeCliques ( int i , int l , bool [ ] prime ) { for ( int j = i + 1 ; j <= n ; j ++ ) { store [ l ] = j ; if ( is_clique ( l + 1 ) ) { if ( prime [ l ] ) ans ++ ; primeCliques ( j , l + 1 , prime ) ; } } }
int countWays ( int [ , ] mtrx , int vrtx , int i , int dest , bool [ ] visited ) { if ( i == dest ) { return 1 ; } int total = 0 ; for ( int j = 0 ; j < vrtx ; j ++ ) { if ( mtrx [ i , j ] == 1 && ! visited [ j ] ) { visited [ j ] = true ; total += countWays ( mtrx , vrtx , j , dest , visited ) ; visited [ j ] = false ; } } return total ; }
int totalWays ( int [ , ] mtrx , int vrtx , int src , int dest ) { bool [ ] visited = new bool [ vrtx ] ; for ( int i = 0 ; i < vrtx ; i ++ ) { visited [ i ] = false ; } visited [ src ] = true ; return countWays ( mtrx , vrtx , src , dest , visited ) ; }
int minOperation ( bool [ ] [ ] arr ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; }
int find_x ( int n ) { if ( n == 1 ) return 1 ; double num , den , p ; num = Math . Log10 ( n ) ; int x = 0 , no = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { den = Math . Log10 ( i ) ; p = num / den ; no = ( int ) ( Math . Pow ( i , ( int ) p ) ) ; if ( Math . Abs ( no - n ) < 0.000001 ) { x = i ; break ; } } return x ; }
bool is_key ( int n , int x ) { double p ; p = Math . Log10 ( n ) / Math . Log10 ( x ) ; int no = ( int ) ( Math . Pow ( x , ( int ) p ) ) ; if ( n == no ) return true ; return false ; }
int evenPaths ( Node node , int count , int x ) { if ( node == null || ! is_key ( node . key , x ) ) { return count ; } if ( node . left == null && node . right == null ) { count ++ ; } count = evenPaths ( node . left , count , x ) ; return evenPaths ( node . right , count , x ) ; }
void dfs ( int a , int b , List < int > [ ] v , int [ ] vis ) { vis [ a ] = 1 ; c ++ ; foreach ( int i in v [ a ] ) { if ( vis [ i ] == 0 && i != b ) dfs ( i , b , v , vis ) ; } }
void printExistPath ( Stack < int > sx , Stack < int > sy , int last ) { if ( sx . Count == 0 sy . Count == 0 ) { return ; } int x = sx . Peek ( ) ; int y = sy . Peek ( ) ; sx . Pop ( ) ; sy . Pop ( ) ; printExistPath ( sx , sy , last ) ; if ( sx . Count == last - 1 ) { Console . Write ( "(" + x + ", " + y + ")" ) ; } else { Console . Write ( "(" + x + ", " + y + ")->" ) ; } }
bool storePath ( int srcX , int srcY , int destX , int destY , Stack < int > sx , Stack < int > sy ) { if ( srcX > destX srcY > destY ) { return false ; } sx . Push ( srcX ) ; sy . Push ( srcY ) ; if ( srcX == destX && srcY == destY ) { printExistPath ( sx , sy , sx . Count ) ; return true ; } if ( storePath ( ( 2 * srcX ) + srcY , srcY , destX , destY , sx , sy ) ) { return true ; } if ( storePath ( srcX , ( 2 * srcY ) + srcX , destX , destY , sx , sy ) ) { return true ; } sx . Pop ( ) ; sy . Pop ( ) ; return false ; }
bool isPathExist ( int srcX , int srcY , int destX , int destY ) { Stack < int > sx = new Stack < int > ( ) ; Stack < int > sy = new Stack < int > ( ) ; return storePath ( srcX , srcY , destX , destY , sx , sy ) ; }
void printPath ( int srcX , int srcY , int destX , int destY ) { if ( ! isPathExist ( srcX , srcY , destX , destY ) ) { Console . Write ( "-1" ) ; } }
void dfs ( int v ) { col [ v ] = 1 ; foreach ( pair p in g [ v ] ) { int to = p . first , id = p . second ; if ( col [ to ] == 0 ) { dfs ( to ) ; res [ id ] = 1 ; } else if ( col [ to ] == 2 ) { res [ id ] = 1 ; } else { res [ id ] = 2 ; cyc = true ; } } col [ v ] = 2 ; }
void sumSubsets ( int [ ] set , int n , int target ) { int [ ] x = new int [ set . Length ] ; int j = set . Length - 1 ; while ( n > 0 ) { x [ j ] = n % 2 ; n = n / 2 ; j -- ; } int sum = 0 ; for ( int i = 0 ; i < set . Length ; i ++ ) if ( x [ i ] == 1 ) sum = sum + set [ i ] ; if ( sum == target ) { Console . Write ( "{" ) ; for ( int i = 0 ; i < set . Length ; i ++ ) if ( x [ i ] == 1 ) Console . Write ( set [ i ] + ", " ) ; Console . Write ( "}, " ) ; } }
void findSubsets ( int [ ] arr , int K ) { int x = ( int ) Math . Pow ( 2 , arr . Length ) ; for ( int i = 1 ; i < x ; i ++ ) sumSubsets ( arr , i , K ) ; }
int ncr ( int n , int r ) { return ( fact [ n ] / fact [ r ] ) / fact [ n - r ] ; }
int findSum ( int [ ] arr , int n ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int mul = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) mul += ( int ) Math . Pow ( 2 , i ) * ncr ( n - 1 , i ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += mul * arr [ i ] ; return ans ; }
int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }
int solve ( int [ , ] maze ) { int ans = numberOfPaths ( R , C ) - countPaths ( maze ) ; return ans ; }
void dfs1 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent [ u ] . Count ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] ) { temp ++ ; parent [ adjacent [ u ] [ i ] ] = u ; dfs1 ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; endnode = u ; } } }
void dfs2 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent [ u ] . Count ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] && ! vis [ adjacent [ u ] [ i ] ] ) { temp ++ ; dfs2 ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; thirdnode = u ; } } }
void findNodes ( ) { dfs ( 1 , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; maxi = - 1 ; dfs1 ( startnode , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; int x = endnode ; vis [ startnode ] = true ; while ( x != startnode ) { vis [ x ] = true ; x = parent [ x ] ; } maxi = - 1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] ) dfs2 ( i , 0 ) ; } }
void dfsUtil ( int u , int node , bool [ ] visited , List < List < int > > road_used , int parent , int it ) { int c = 0 ; for ( int i = 0 ; i < node ; i ++ ) if ( visited [ i ] ) c ++ ; if ( c == node ) return ; visited [ u ] = true ; road_used . Add ( new List < int > ( ) { parent , u } ) ; Console . Write ( u + " " ) ; foreach ( int x in adj [ u ] ) { if ( ! visited [ x ] ) { dfsUtil ( x , node , visited , road_used , u , it + 1 ) ; } } for ( int y = 0 ; y < road_used . Count ; y ++ ) { if ( road_used [ y ] [ 1 ] == u ) { dfsUtil ( road_used [ y ] [ 0 ] , node , visited , road_used , u , it + 1 ) ; } } }
void dfs ( int node ) { bool [ ] visited = new bool [ node ] ; List < List < int > > road_used = new List < List < int > > ( ) ; for ( int i = 0 ; i < node ; i ++ ) { visited [ i ] = false ; } dfsUtil ( 0 , node , visited , road_used , - 1 , 0 ) ; }
void primeSum ( int total , int N , int S , int index ) { if ( total == S && set . Count == N ) { display ( ) ; return ; } if ( total > S index == prime . Count ) return ; set . Add ( prime [ index ] ) ; primeSum ( total + prime [ index ] , N , S , index + 1 ) ; set . RemoveAt ( set . Count - 1 ) ; primeSum ( total , N , S , index + 1 ) ; }
void allPrime ( int N , int S , int P ) { for ( int i = P + 1 ; i <= S ; i ++ ) { if ( isPrime ( i ) ) prime . Add ( i ) ; } if ( prime . Count < N ) return ; primeSum ( 0 , N , S , 0 ) ; }
List < int > grayCodes ( int n ) { List < int > res = new List < int > ( ) ; num = 0 ; grayCodeUtil ( res , n ) ; return res ; }
bool isParenthesis ( char c ) { return ( ( c == '(' ) || ( c == ')' ) ) ; }
bool isValidString ( String str ) { int cnt = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == '(' ) cnt ++ ; else if ( str [ i ] == ')' ) cnt -- ; if ( cnt < 0 ) return false ; } return ( cnt == 0 ) ; }
int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
bool isSafe ( int [ , ] grid , int row , int col , int num ) { for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ row , x ] == num ) return false ; for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ x , col ] == num ) return false ; int startRow = row - row % 3 , startCol = col - col % 3 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) if ( grid [ i + startRow , j + startCol ] == num ) return false ; return true ; }
bool solveSuduko ( int [ , ] grid , int row , int col ) { if ( row == N - 1 && col == N ) return true ; if ( col == N ) { row ++ ; col = 0 ; } if ( grid [ row , col ] != 0 ) return solveSuduko ( grid , row , col + 1 ) ; for ( int num = 1 ; num < 10 ; num ++ ) { if ( isSafe ( grid , row , col , num ) ) { grid [ row , col ] = num ; if ( solveSuduko ( grid , row , col + 1 ) ) return true ; } grid [ row , col ] = 0 ; } return false ; }
int fact ( int n ) { int ans = 1 ; for ( int i = 2 ; i <= n ; i ++ ) ans *= i ; return ans ; }
int remainder ( int n , int a , int p ) { int len = fact ( n ) ; int ans = 1 ; for ( int i = 1 ; i <= len ; i ++ ) ans = ( ans * a ) % p ; return ans ; }
long power ( long x , long y , long p ) { long res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
long remainder ( long n , long a , long p ) { long ans = a % p ; for ( long i = 1 ; i <= n ; i ++ ) ans = power ( ans , i , p ) ; return ans ; }
bool check ( int n , int w ) { int [ ] a = new int [ 105 ] ; int p = 0 ; while ( n > 0 ) { a [ p ++ ] = n % w ; n /= w ; } bool flag = true ; for ( int i = 0 ; i <= 100 ; i ++ ) { if ( a [ i ] == 0 a [ i ] == 1 ) continue ; else if ( a [ i ] == w a [ i ] == w - 1 ) a [ i + 1 ] ++ ; else flag = false ; } return flag ; }
int numPairs ( int [ ] a , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = Math . Abs ( a [ i ] ) ; Array . Sort ( a ) ; for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; } return ans ; }
int exponentMod ( int A , int B ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 ) ; y = ( y * y ) % mod ; } else { y = A % mod ; y = ( y * exponentMod ( A , B - 1 ) % mod ) % mod ; } return ( int ) ( ( y + mod ) % mod ) ; }
void countWays ( int N ) { long select = exponentMod ( 2 , N - 1 ) ; long ways = ( ( N % mod ) * ( select % mod ) ) ; ways %= mod ; Console . Write ( ways ) ; }
int findSum ( int n ) { int [ , ] arr = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i , j ] = Math . Abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i , j ] ; return sum ; }
int MaxUtil ( int [ ] st , int ss , int se , int l , int r , int node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return - 1 ; int mid = getMid ( ss , se ) ; return Math . Max ( MaxUtil ( st , ss , mid , l , r , 2 * node ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 1 ) ) ; }
int count ( int [ ] arr , int low , int high , int x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , ( low + high ) / 2 , x ) + count ( arr , 1 + ( low + high ) / 2 , high , x ) ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
double [ , ] matrix_product ( double [ , ] a , double [ , ] b ) { double [ , ] c = new double [ 7 , 7 ] ; for ( int i = 0 ; i < 7 ; i ++ ) for ( int j = 0 ; j < 7 ; j ++ ) for ( int k = 0 ; k < 7 ; k ++ ) c [ i , j ] += a [ i , k ] * b [ k , j ] ; return c ; }
double [ , ] mul_expo ( double [ , ] mul , int p ) { double [ , ] s = { { 1 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } } ; while ( p != 1 ) { if ( p % 2 == 1 ) s = matrix_product ( s , mul ) ; mul = matrix_product ( mul , mul ) ; p /= 2 ; } return matrix_product ( mul , s ) ; }
double expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 6 ) return 6 ; double [ , ] mul = { { ( double ) 7 / 6 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } , { ( double ) - 1 / 6 , 0 , 0 , 0 , 0 , 0 , 0 } } ; mul = mul_expo ( mul , x - 6 ) ; return ( mul [ 0 , 0 ] + mul [ 1 , 0 ] + mul [ 2 , 0 ] + mul [ 3 , 0 ] + mul [ 4 , 0 ] + mul [ 5 , 0 ] ) * 6 ; }
int maxDistance ( int [ ] cell , int n , int p ) { Array . Sort ( cell ) ; int start = 0 ; int end = cell [ n - 1 ] - cell [ 0 ] ; int ans = 0 ; while ( start <= end ) { int mid = start + ( ( end - start ) / 2 ) ; if ( canPlace ( cell , n , p , mid ) ) { ans = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; }
int [ ] solve ( int n ) { int low = 1 , high = ( int ) 1e4 , x = n , p = 0 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * ( mid + 1 ) ) / 2 ; if ( x - sum >= 1 ) { p = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } int start = 1 , end = ( int ) 1e4 , y = 1 , q = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int sum = ( mid * ( mid + 1 ) ) / 2 ; if ( y + sum <= n ) { q = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } x = x - ( p * ( p + 1 ) ) / 2 ; y = y + ( q * ( q + 1 ) ) / 2 ; int r = x ; int c = q + 1 - n + y ; int [ ] ans = { r , c } ; return ans ; }
int build ( int l , int r , int ind , int [ ] arr ) { if ( l == r ) return seg [ ind ] = arr [ l ] ; int mid = ( l + r ) / 2 ; return seg [ ind ] = __gcd ( build ( l , mid , 2 * ind + 1 , arr ) , build ( mid + 1 , r , 2 * ind + 2 , arr ) ) ; }
int query ( int l , int r , int l1 , int r1 , int ind ) { if ( l1 <= l && r <= r1 ) return seg [ ind ] ; if ( l > r1 r < l1 ) return 0 ; int mid = ( l + r ) / 2 ; return __gcd ( query ( l , mid , l1 , r1 , 2 * ind + 1 ) , query ( mid + 1 , r , l1 , r1 , 2 * ind + 2 ) ) ; }
int findLen ( int [ ] arr , int n ) { build ( 0 , n - 1 , 0 , arr ) ; int i = 0 , j = 0 ; int ans = int . MaxValue ; while ( i < n ) { while ( j < n && query ( 0 , n - 1 , i , j , 0 ) != 1 ) j ++ ; if ( j == n ) break ; ans = Math . Min ( ( j - i + 1 ) , ans ) ; i ++ ; j = Math . Max ( j , i ) ; } if ( ans == int . MaxValue ) return - 1 ; else return ans ; }
int mergeSort ( int [ ] arr , int array_size ) { int [ ] temp = new int [ array_size ] ; return _mergeSort ( arr , temp , 0 , array_size - 1 ) ; }
int merge ( int [ ] arr , int [ ] temp , int left , int mid , int right ) { int i , j , k ; int inv_count = 0 ; i = left ; j = mid ; k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] > 2 * arr [ j ] ) { inv_count += ( mid - i ) ; j ++ ; } else { i ++ ; } } i = left ; j = mid ; k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) { temp [ k ++ ] = arr [ i ++ ] ; } else { temp [ k ++ ] = arr [ j ++ ] ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; }
void findGrid ( int n ) { int [ , ] arr = new int [ n , n ] ; int x = 0 ; for ( int i = 0 ; i < n / 4 ; i ++ ) { for ( int j = 0 ; j < n / 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { for ( int l = 0 ; l < 4 ; l ++ ) { arr [ i * 4 + k , j * 4 + l ] = x ; x ++ ; } } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { Console . Write ( arr [ i , j ] + " " ) ; } Console . WriteLine ( " " ) ; } }
int buildTree ( int l , int r , int i , int [ ] arr ) { if ( l == r ) { segtree [ i ] = l ; return l ; } int l1 = buildTree ( l , ( l + r ) / 2 , 2 * i + 1 , arr ) ; int r1 = buildTree ( ( l + r ) / 2 + 1 , r , 2 * i + 2 , arr ) ; if ( arr [ l1 ] > arr [ r1 ] ) segtree [ i ] = l1 ; else segtree [ i ] = r1 ; return segtree [ i ] ; }
int rangeMax ( int l , int r , int rl , int rr , int i , int [ ] arr ) { if ( r < rl l > rr ) return - 1 ; if ( l >= rl && r <= rr ) return segtree [ i ] ; int l1 = rangeMax ( l , ( l + r ) / 2 , rl , rr , 2 * i + 1 , arr ) ; int r1 = rangeMax ( ( l + r ) / 2 + 1 , r , rl , rr , 2 * i + 2 , arr ) ; if ( l1 == - 1 ) return r1 ; if ( r1 == - 1 ) return l1 ; if ( arr [ l1 ] > arr [ r1 ] ) return l1 ; else return r1 ; }
void inorder ( node curr ) { if ( curr == null ) return ; inorder ( curr . left ) ; Console . Write ( curr . data + " " ) ; inorder ( curr . right ) ; }
int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
int kthSmallest ( int [ ] arr , int k , int n ) { int low = arr . Min ( ) ; int high = arr . Max ( ) ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; int countless = 0 , countequal = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] < mid ) ++ countless ; else if ( arr [ i ] == mid ) ++ countequal ; } if ( countless < k && ( countless + countequal ) >= k ) { return mid ; } else if ( countless >= k ) { high = mid - 1 ; } else if ( countless < k && countless + countequal < k ) { low = mid + 1 ; } } return int . MinValue ; }
void update ( int x , int y , int value , int id , int l , int r ) { if ( x >= r l >= y ) return ; if ( x <= l && r <= y ) { lazy [ id ] = value ; return ; } int mid = ( l + r ) / 2 ; if ( lazy [ id ] != 0 ) lazy [ 2 * id ] = lazy [ 2 * id + 1 ] = lazy [ id ] ; lazy [ id ] = 0 ; update ( x , y , value , 2 * id , l , mid ) ; update ( x , y , value , 2 * id + 1 , mid , r ) ; }
void query ( int id , int l , int r ) { if ( lazy [ id ] != 0 ) { se . Add ( lazy [ id ] ) ; return ; } if ( r - l < 2 ) return ; int mid = ( l + r ) / 2 ; query ( 2 * id , l , mid ) ; query ( 2 * id + 1 , mid , r ) ; }
void updateRangeUtil ( int si , int ss , int se , int us , int ue , int diff ) { if ( lazy [ si ] != 0 ) { tree [ si ] += lazy [ si ] ; if ( ss != se ) { lazy [ si * 2 + 1 ] += lazy [ si ] ; lazy [ si * 2 + 2 ] += lazy [ si ] ; } lazy [ si ] = 0 ; } if ( ss > se ss > < us ) return ; if ( ss >= us && se <= ue ) { tree [ si ] += diff ; if ( ss != se ) { lazy [ si * 2 + 1 ] += diff ; lazy [ si * 2 + 2 ] += diff ; } return ; } int mid = ( ss + se ) / 2 ; updateRangeUtil ( si * 2 + 1 , ss , mid , us , ue , diff ) ; updateRangeUtil ( si * 2 + 2 , mid + 1 , se , us , ue , diff ) ; tree [ si ] = Math . Max ( tree [ si * 2 + 1 ] , tree [ si * 2 + 2 ] ) ; }
void updateRange ( int n , int us , int ue , int diff ) { updateRangeUtil ( 0 , 0 , n - 1 , us , ue , diff ) ; }
void constructSTUtil ( int [ ] arr , int ss , int se , int si ) { if ( ss > se ) return ; if ( ss == se ) { tree [ si ] = arr [ ss ] ; return ; } int mid = ( ss + se ) / 2 ; constructSTUtil ( arr , ss , mid , si * 2 + 1 ) ; constructSTUtil ( arr , mid + 1 , se , si * 2 + 2 ) ; tree [ si ] = Math . Max ( tree [ si * 2 + 1 ] , tree [ si * 2 + 2 ] ) ; }
void constructST ( int [ ] arr , int n ) { constructSTUtil ( arr , 0 , n - 1 , 0 ) ; }
int getCount ( int n ) { int count = 1 ; while ( n != 0 ) { int leadDigit = firstDigit ( n ) ; n -= leadDigit ; count ++ ; } return count ; }
int getLargestNumber ( int k ) { int left = k ; int right = k * 10 ; int mid = ( left + right ) / 2 ; int len = getCount ( mid ) ; while ( len != k ) { mid = ( left + right ) / 2 ; len = getCount ( mid ) ; if ( len > k ) { right = mid ; } else { left = mid ; } } while ( len == k ) { if ( len != getCount ( mid + 1 ) ) { break ; } mid ++ ; } return ( mid ) ; }
long F ( long A , long B ) { if ( A == 1 ) return ( 4 % B ) ; else { long temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
void checkHV ( int [ , ] arr , int N , int M ) { bool horizontal = true ; bool vertical = true ; for ( int i = 0 , k = N - 1 ; i < N / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i , j ] != arr [ k , j ] ) { horizontal = false ; break ; } } } for ( int i = 0 , k = M - 1 ; i < M / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i , j ] != arr [ k , j ] ) { horizontal = false ; break ; } } } if ( ! horizontal && ! vertical ) Console . WriteLine ( "NO" ) ; else if ( horizontal && ! vertical ) Console . WriteLine ( "HORIZONTAL" ) ; else if ( vertical && ! horizontal ) Console . WriteLine ( "VERTICAL" ) ; else Console . WriteLine ( "BOTH" ) ; }
int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = Math . Max ( l , a ) ; int R = Math . Min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
int getSetBitsFromOneToN ( int N ) { int two = 2 , ans = 0 ; int n = N ; while ( n != 0 ) { ans += ( N / two ) * ( two >> 1 ) ; if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 ; two <<= 1 ; n >>= 1 ; } return ans ; }
int findMinimum ( int x ) { int low = 0 , high = 100000 ; int ans = high ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( getSetBitsFromOneToN ( mid ) >= x ) { ans = Math . Min ( ans , mid ) ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; }
int exponentMod ( int A , int B , int C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; }
int trailingZeroes ( int n ) { int cnt = 0 ; while ( n > 0 ) { n /= 5 ; cnt += n ; } return cnt ; }
void binarySearch ( int n ) { int low = 0 ; int high = 1000000 ; while ( low < high ) { int mid = ( low + high ) / 2 ; int count = trailingZeroes ( mid ) ; if ( count < n ) low = mid + 1 ; else high = mid ; } int [ ] result = new int [ 1000 ] ; int k = 0 ; while ( trailingZeroes ( low ) == n ) { result [ k ] = low ; k ++ ; low ++ ; } for ( int i = 0 ; i < k ; i ++ ) Console . Write ( result [ i ] + " " ) ; }
int maxDet ( int n ) { return ( 2 * n * n * n ) ; }
void resMatrix ( int n ) { for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( i == 0 && j == 2 ) Console . Write ( "0 " ) ; else if ( i == 1 && j == 0 ) Console . Write ( "0 " ) ; else if ( i == 2 && j == 1 ) Console . Write ( "0 " ) ; else Console . Write ( n + " " ) ; } Console . WriteLine ( "" ) ; } }
int getCumulateSum ( int n ) { return ( n * ( n + 1 ) ) / 2 ; }
int minDaysToEmpty ( int C , int l ) { if ( C <= l ) return C ; int lo = 0 ; int hi = ( int ) 1e4 ; int mid ; while ( lo < hi ) { mid = ( lo + hi ) / 2 ; if ( getCumulateSum ( mid ) >= ( C - l ) ) hi = mid ; else lo = mid + 1 ; } return ( l + lo ) ; }
int minDaysToEmpty ( int C , int l ) { if ( l >= C ) return C ; double eq_root = ( Math . Sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( int ) ( Math . Ceiling ( eq_root ) + l ) ; }
void shuffleArray ( int [ ] a , int n ) { for ( int i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( int j = k ; j > i + q ; j -- ) { int temp = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = temp ; } }
int kth ( int [ ] arr1 , int [ ] arr2 , int m , int n , int k ) { int [ ] sorted1 = new int [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }
int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
void binarySearch ( int [ , ] mat , int i , int j_low , int j_high , int x ) { while ( j_low <= j_high ) { int j_mid = ( j_low + j_high ) / 2 ; if ( mat [ i , j_mid ] == x ) { Console . Write ( "Found at (" + i + ", " + j_mid + ")" ) ; return ; } else if ( mat [ i , j_mid ] > x ) j_high = j_mid - 1 ; else j_low = j_mid + 1 ; } Console . Write ( "Element no found" ) ; }
void sortedMatrixSearch ( int [ , ] mat , int n , int m , int x ) { if ( n == 1 ) { binarySearch ( mat , 0 , 0 , m - 1 , x ) ; return ; } int i_low = 0 ; int i_high = n - 1 ; int j_mid = m / 2 ; while ( ( i_low + 1 ) < i_high ) { int i_mid = ( i_low + i_high ) / 2 ; if ( mat [ i_mid , j_mid ] == x ) { Console . Write ( "Found at (" + i_mid + ", " + j_mid + ")" ) ; return ; } else if ( mat [ i_mid , j_mid ] > x ) i_high = i_mid ; else i_low = i_mid ; } if ( mat [ i_low , j_mid ] == x ) Console . Write ( "Found at (" + i_low + "," + j_mid + ")" ) ; else if ( mat [ i_low + 1 , j_mid ] == x ) Console . Write ( "Found at (" + ( i_low + 1 ) + ", " + j_mid + ")" ) ; else if ( x <= mat [ i_low , j_mid - 1 ] ) binarySearch ( mat , i_low , 0 , j_mid - 1 , x ) ; else if ( x >= mat [ i_low , j_mid + 1 ] && x <= mat [ i_low , m - 1 ] ) binarySearch ( mat , i_low , j_mid + 1 , m - 1 , x ) ; else if ( x <= mat [ i_low + 1 , j_mid - 1 ] ) binarySearch ( mat , i_low + 1 , 0 , j_mid - 1 , x ) ; else binarySearch ( mat , i_low + 1 , j_mid + 1 , m - 1 , x ) ; }
bool isFeasible ( int mid , int [ ] arr , int n , int k ) { int pos = arr [ 0 ] ; int elements = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - pos >= mid ) { pos = arr [ i ] ; elements ++ ; if ( elements == k ) return true ; } } return false ; }
int largestMinDist ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int res = - 1 ; int left = 1 , right = arr [ n - 1 ] ; while ( left < right ) { int mid = ( left + right ) / 2 ; if ( isFeasible ( mid , arr , n , k ) ) { res = Math . Max ( res , mid ) ; left = mid + 1 ; } else right = mid ; } return res ; }
int bsearch ( int low , int high , int n , int [ ] arr ) { int mid = ( low + high ) / 2 ; if ( low <= high ) { if ( arr [ mid ] < n ) return bsearch ( mid + 1 , high , n , arr ) ; return bsearch ( low , mid - 1 , n , arr ) ; } return low ; }
int mindiff ( int [ , ] arr , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) Array . Sort ( GetRow ( arr , i ) ) ; int ans = + 2147483647 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int p = bsearch ( 0 , m - 1 , arr [ i , j ] , GetRow ( arr , i + 1 ) ) ; ans = Math . Min ( ans , Math . Abs ( arr [ i + 1 , p ] - arr [ i , j ] ) ) ; if ( p - 1 >= 0 ) ans = Math . Min ( ans , Math . Abs ( arr [ i + 1 , p - 1 ] - arr [ i , j ] ) ) ; } } return ans ; }
int binarySearch ( int [ ] arr , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; }
int findRepeatingElement ( int [ ] arr , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }
double diff ( double n , double mid ) { if ( n > ( mid * mid * mid ) ) return ( n - ( mid * mid * mid ) ) ; else return ( ( mid * mid * mid ) - n ) ; }
double cubicRoot ( double n ) { double start = 0 , end = n ; double e = 0.0000001 ; while ( true ) { double mid = ( start + end ) / 2 ; double error = diff ( n , mid ) ; if ( error <= e ) return mid ; if ( ( mid * mid * mid ) > n ) end = mid ; else start = mid ; } }
void findFrequencyUtil ( int [ ] arr , int low , int high , int [ ] freq ) { if ( arr [ low ] == arr [ high ] ) { freq [ arr [ low ] ] += high - low + 1 ; } else { int mid = ( low + high ) / 2 ; findFrequencyUtil ( arr , low , mid , freq ) ; findFrequencyUtil ( arr , mid + 1 , high , freq ) ; } }
void findFrequency ( int [ ] arr , int n ) { int [ ] freq = new int [ arr [ n - 1 ] + 1 ] ; findFrequencyUtil ( arr , 0 , n - 1 , freq ) ; for ( int i = 0 ; i <= arr [ n - 1 ] ; i ++ ) if ( freq [ i ] != 0 ) Console . WriteLine ( "Element " + i + " occurs " + freq [ i ] + " times" ) ; }
int floorSqrt ( int x ) { if ( x == 0 x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }
int countDirectPath ( int N ) { return N + ( N * ( N - 3 ) ) / 2 ; }
int isPossibleToReach ( int [ ] A , int N , int X , int Y ) { double distance = Math . Sqrt ( ( X * X + Y * Y ) ) ; double mx = 0 ; for ( int i = 0 ; i < N ; i ++ ) { mx += ( A [ i ] ) ; } if ( mx < distance ) { Console . Write ( "NO" ) ; return 0 ; } if ( ( mx - distance ) < 0.000001 ) { Console . Write ( "YES" ) ; return 0 ; } for ( int i = 0 ; i < N ; i ++ ) { if ( distance + mx < 2 * A [ i ] ) { Console . Write ( "No" ) ; return 0 ; } } Console . Write ( "Yes" ) ; return 0 ; }
bool canReach ( int X , int Y ) { int steps = 0 ; while ( X != 0 Y != 0 ) { int pos1 = X % 3 ; int pos2 = Y % 3 ; if ( pos1 == 2 pos2 == 2 ) { return false ; } if ( pos1 == 1 && pos2 == 1 ) { return false ; } if ( pos1 == 0 && pos2 == 0 ) { return false ; } X /= 3 ; Y /= 3 ; steps ++ ; } return true ; }
int numofneighbour ( int [ ] [ ] mat , int i , int j ) { int count = 0 ; if ( i > 0 && mat [ i - 1 ] [ j ] == 1 ) { count ++ ; } if ( j > 0 && mat [ i ] [ j - 1 ] == 1 ) { count ++ ; } if ( i < R - 1 && mat [ i + 1 ] [ j ] == 1 ) { count ++ ; } if ( j < C - 1 && mat [ i ] [ j + 1 ] == 1 ) { count ++ ; } return count ; }
int findperimeter ( int [ ] [ ] mat ) { int perimeter = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { perimeter += ( 4 - numofneighbour ( mat , i , j ) ) ; } } } return perimeter ; }
double findRadius ( double r1 , double r2 , double r3 ) { double r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * Math . Sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) ; return r4 ; }
void findSides ( double A , double C , double c ) { double B = 180 - ( A + C ) ; A = A * ( 3.14159 / 180 ) ; C = C * ( 3.14159 / 180 ) ; B = B * ( 3.14159 / 180 ) ; double a = ( c / Math . Sin ( C ) ) * Math . Sin ( A ) ; double b = ( c / Math . Sin ( C ) ) * Math . Sin ( B ) ; Console . WriteLine ( "{0:F2}" , a ) ; Console . WriteLine ( "{0:F2}" , b ) ; }
void closestsAngle ( int N , int A ) { double mi = Int32 . MaxValue ; int ans = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { double angle = 180.0 * i / N ; if ( Math . Abs ( angle - A ) < Math . Abs ( mi - A ) ) { mi = angle ; ans = i ; } } Console . Write ( 2 + " " + 1 + " " + ( 2 + ans ) ) ; }
double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
double radius ( int a , int b , int c ) { int g = a / 2 ; int f = b / 2 ; if ( g * g + f * f - c < 0 ) return ( - 1 ) ; return ( Math . Sqrt ( g * g + f * f - c ) ) ; }
double centerDistanceFromLine ( int a , int b , int i , int j , int k ) { int g = a / 2 ; int f = b / 2 ; double distance = Math . Abs ( i * g + j * f + k ) / ( Math . Sqrt ( i * i + j * j ) ) ; if ( distance < 0 ) return ( - 1 ) ; return distance ; }
void check_position ( int a , int b , int c , int d , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { int value_1 = a * x1 + b * y1 + c * z1 + d ; int value_2 = a * x2 + b * y2 + c * z2 + d ; if ( ( value_1 > 0 && value_2 > 0 ) || ( value_1 < 0 && value_2 < 0 ) ) Console . Write ( "On same side" ) ; if ( ( value_1 > 0 && value_2 < 0 ) || ( value_1 < 0 && value_2 > 0 ) ) Console . Write ( "On different sides" ) ; if ( value_1 == 0 && value_2 == 0 ) Console . Write ( "Both on the plane" ) ; if ( value_1 == 0 && value_2 != 0 ) Console . Write ( "Point 1 on the plane" ) ; if ( value_1 != 0 && value_2 == 0 ) Console . Write ( "Point 2 on the plane" ) ; }
void normal_equation ( double a , double b , double x1 , double y1 ) { double slope = normal_slope ( a , b , x1 , y1 ) ; if ( slope == - 1 ) { Console . WriteLine ( "x = " + x1 ) ; } if ( slope == - 2 ) { Console . WriteLine ( "y = " + y1 ) ; } if ( slope != - 1 && slope != - 2 ) { x1 *= - slope ; x1 += y1 ; if ( x1 > 0 ) Console . WriteLine ( "y = " + slope + "x +" + Math . Round ( x1 , 2 ) ) ; else Console . WriteLine ( "y = " + slope + "x " + Math . Round ( x1 , 2 ) ) ; } }
double point_distance ( int x1 , int y1 , int x2 , int y2 ) { int p = ( x2 - x1 ) ; int q = ( y2 - y1 ) ; double distance = Math . Sqrt ( p * p + q * q ) ; return distance ; }
bool check ( circle [ ] C ) { double C1C2 = Math . Sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) ; bool flag = false ; if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) { if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x && ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) { flag = true ; } } return flag ; }
bool IsFairTriplet ( circle [ ] c ) { bool f = false ; f |= check ( c ) ; for ( int i = 0 ; i < 2 ; i ++ ) { swap ( c [ 0 ] , c [ 2 ] ) ; f |= check ( c ) ; } return f ; }
double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return Math . Sqrt ( r ) ; }
double findInteriorAngle ( int n ) { return ( ( n - 2 ) * PI ) / n ; }
void findAngle ( double M1 , double M2 ) { double angle = Math . Abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) ; double ret = Math . Atan ( angle ) ; double val = ( ret * 180 ) / PI ; Console . Write ( val ) ; }
float calculateArea ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = ( float ) Math . Sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; }
float angle ( float R1 , float R2 , float D ) { float ans = ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) ; return ans ; }
void triangleArea ( int a , int b ) { double ratio = ( double ) b / a ; Console . WriteLine ( ratio ) ; }
int countInscribed ( int R1 , int R2 ) { if ( R2 > R1 ) return 0 ; double angle ; double ratio ; int number_of_circles = 0 ; ratio = R2 / ( double ) ( R1 - R2 ) ; if ( R1 < 2 * R2 ) { number_of_circles = 1 ; } else { angle = Math . Abs ( Math . Asin ( ratio ) * 180 ) / 3.14159265 ; number_of_circles = ( int ) ( 360 / ( 2 * Math . Floor ( angle ) ) ) ; } return number_of_circles ; }
float distance ( int m , int n , int p , int q ) { return ( float ) Math . Sqrt ( Math . Pow ( n - m , 2 ) + Math . Pow ( q - p , 2 ) * 1.0 ) ; }
double magnitude ( double [ ] arr , int N ) { double magnitude = 0 ; for ( int i = 0 ; i < N ; i ++ ) magnitude += arr [ i ] * arr [ i ] ; return Math . Sqrt ( magnitude ) ; }
double dotProduct ( double [ ] arr , double [ ] brr , int N ) { double product = 0 ; for ( int i = 0 ; i < N ; i ++ ) product = product + arr [ i ] * brr [ i ] ; return product ; }
void angleBetweenVectors ( double [ ] arr , double [ ] brr , int N ) { double dotProductOfVectors = dotProduct ( arr , brr , N ) ; double magnitudeOfA = magnitude ( arr , N ) ; double magnitudeOfB = magnitude ( brr , N ) ; double angle = dotProductOfVectors / ( magnitudeOfA * magnitudeOfB ) ; Console . Write ( angle ) ; }
double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
int totalCircles ( int L , int B ) { if ( L > B ) { int temp = L ; L = B ; B = temp ; } return B / L ; }
void findSquareSum ( int [ , ] Coordinates , int N ) { long xq = 0 , yq = 0 ; long xs = 0 , ys = 0 ; long res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int a , b ; a = Coordinates [ i , 0 ] ; b = Coordinates [ i , 1 ] ; res += xq ; res -= 2 * xs * a ; res += i * ( long ) ( a * a ) ; xq += a * a ; xs += a ; res += yq ; res -= 2 * ys * b ; res += i * ( long ) b * b ; yq += b * b ; ys += b ; } Console . Write ( res ) ; }
double findDiagonal ( double s ) { return ( double ) Math . Sqrt ( 2 ) * s ; }
void triangleArea ( float a , float b ) { if ( a < 0 b < 0 ) { Console . WriteLine ( - 1 ) ; return ; } float area = ( 3 * ( float ) Math . Sqrt ( 3 ) * a * b ) / ( 4 ) ; Console . WriteLine ( area ) ; }
int maxRowDiff ( int [ , ] mat , int m , int n ) { int [ ] rowSum = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i , j ] ; rowSum [ i ] = sum ; } int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; int min_element = rowSum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; }
float distance ( float x1 , float y1 , float x2 , float y2 ) { return ( float ) Math . Sqrt ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) ; }
void lengthOfLatusRectum ( float a , float b , float c ) { pair vertex = new pair ( ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) ) ; pair focus = new pair ( ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) ) ; Console . Write ( 4 * distance ( ( float ) focus . first , ( float ) focus . second , ( float ) vertex . first , ( float ) vertex . second ) ) ; }
bool doIntersect ( int [ ] X , int [ ] Y ) { if ( X [ 0 ] > X [ 3 ] X [ 2 ] > X [ 1 ] ) return false ; if ( Y [ 0 ] > Y [ 3 ] Y [ 2 ] > Y [ 1 ] ) return false ; return true ; }
int getUnionPerimeter ( int [ ] X , int [ ] Y ) { int perimeter = 0 ; if ( ! doIntersect ( X , Y ) ) { perimeter += 2 * ( Math . Abs ( X [ 1 ] - X [ 0 ] ) + Math . Abs ( Y [ 1 ] - Y [ 0 ] ) ) ; perimeter += 2 * ( Math . Abs ( X [ 3 ] - X [ 2 ] ) + Math . Abs ( Y [ 3 ] - Y [ 2 ] ) ) ; } else { int w = X . Max ( ) - X . Min ( ) ; int l = X . Max ( ) - Y . Min ( ) ; perimeter = 2 * ( l + w ) ; } return perimeter ; }
int getPointsIns ( int x1 , int y1 , int radius , int x2 , int y2 , pair [ ] points ) { int ans = 0 ; for ( int i = 0 ; i < points . Length ; i ++ ) { bool condOne = false , condTwo = false ; if ( ( points [ i ] . b - y2 ) * ( x2 - x1 ) - ( y2 - y1 ) * ( points [ i ] . a - x2 ) >= 0 ) { condOne = true ; } if ( radius >= ( int ) Math . Sqrt ( Math . Pow ( ( y1 - points [ i ] . b ) , 2 ) + Math . Pow ( x1 - points [ i ] . a , 2 ) ) ) { condTwo = true ; } if ( condOne && condTwo ) { ans += 1 ; } } return ans ; }
double Convert ( double degree ) { double pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; }
double findRadius ( double r1 , double r2 ) { double a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = Math . Sqrt ( a3 / 3.14 ) ; return r3 ; }
int find_lcm ( int a , int b , int c ) { int g = __gcd ( a , b ) ; int LCM1 = ( a * b ) / g ; g = __gcd ( LCM1 , c ) ; int LCM = ( LCM1 * c ) / g ; return LCM ; }
void minimumCuboids ( int L , int B , int H ) { int lcm = find_lcm ( L , B , H ) ; int volume_cube = lcm * lcm * lcm ; int volume_cuboid = L * B * H ; Console . Write ( ( volume_cube / volume_cuboid ) ) ; }
double distance ( pair p1 , pair p2 ) { double x1 = p1 . first , x2 = p2 . first ; double y1 = p1 . second , y2 = p2 . second ; return Math . Sqrt ( Math . Pow ( x2 - x1 , 2 ) + Math . Pow ( y2 - y1 , 2 ) * 1.0 ) ; }
int CrossProduct ( int [ , ] A ) { int X1 = ( A [ 1 , 0 ] - A [ 0 , 0 ] ) ; int Y1 = ( A [ 1 , 1 ] - A [ 0 , 1 ] ) ; int X2 = ( A [ 2 , 0 ] - A [ 0 , 0 ] ) ; int Y2 = ( A [ 2 , 1 ] - A [ 0 , 1 ] ) ; return ( X1 * Y2 - Y1 * X2 ) ; }
bool isConvex ( int [ , ] points ) { int N = points . GetLength ( 0 ) ; int prev = 0 ; int curr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int [ ] temp1 = GetRow ( points , i ) ; int [ ] temp2 = GetRow ( points , ( i + 1 ) % N ) ; int [ ] temp3 = GetRow ( points , ( i + 2 ) % N ) ; int [ , ] temp = new int [ points . GetLength ( 0 ) , points . GetLength ( 1 ) ] ; temp = newTempIn ( points , temp1 , temp2 , temp3 ) ; curr = CrossProduct ( temp ) ; if ( curr != 0 ) { if ( curr * prev < 0 ) { return false ; } else { prev = curr ; } } } return true ; }
int cntRect ( int [ , ] points , int N , int [ , ] rectangle ) { HashSet < int > cntHor = new HashSet < int > ( ) ; HashSet < int > cntVer = new HashSet < int > ( ) ; cntHor . Add ( 0 ) ; cntVer . Add ( 0 ) ; cntHor . Add ( rectangle [ 3 , 0 ] ) ; cntVer . Add ( rectangle [ 3 , 1 ] ) ; for ( int i = 0 ; i < N ; i ++ ) { cntHor . Add ( points [ i , 0 ] ) ; cntVer . Add ( points [ i , 1 ] ) ; } return ( cntHor . Count - 1 ) * ( cntVer . Count - 1 ) ; }
int numberOfSquares ( int [ ] X , int [ ] Y , int N , int M ) { Dictionary < int , int > m1 = new Dictionary < int , int > ( ) ; Dictionary < int , int > m2 = new Dictionary < int , int > ( ) ; int i , j , ans = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { int dist = Math . Abs ( X [ i ] - X [ j ] ) ; if ( m1 . ContainsKey ( dist ) ) m1 [ dist ] ++ ; else m1 . Add ( dist , 1 ) ; } } for ( i = 0 ; i < M ; i ++ ) { for ( j = i + 1 ; j < M ; j ++ ) { int dist = Math . Abs ( Y [ i ] - Y [ j ] ) ; if ( m2 . ContainsKey ( dist ) ) m2 [ dist ] ++ ; else m2 . Add ( dist , 1 ) ; } } foreach ( KeyValuePair < int , int > entry in m1 ) { if ( m2 . ContainsKey ( entry . Key ) ) { ans += ( entry . Value * m2 [ entry . Key ] ) ; } } return ans ; }
double Area_Parallelogram1 ( int a , int b , int theta ) { double area = ( Math . Abs ( Math . Tan ( ( theta * Math . PI ) / 180 ) ) / 2 ) * Math . Abs ( a * a - b * b ) ; return area ; }
double Area_Parallelogram3 ( int d1 , int d2 , int theta ) { double area = ( Math . Abs ( Math . Sin ( ( theta * Math . PI ) / 180 ) ) / 2 ) * Math . Abs ( d1 * d2 ) ; return area ; }
int noOfTriangles ( int n ) { return ( n * ( n + 2 ) * ( 2 * n + 1 ) / 8 ) ; }
int No_of_squares ( int N , int K ) { int no_of_squares = 0 ; no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) ; return no_of_squares ; }
void checkTriangle ( int x , int y , int z ) { if ( x == y && y == z ) Console . WriteLine ( "Equilateral Triangle" ) ; else if ( x == y y == == x ) Console . WriteLine ( "Isosceles Triangle" ) ; else Console . WriteLine ( "Scalene Triangle" ) ; }
int getTotalCoverageOfMatrix ( int [ , ] mat ) { int res = 0 ; for ( int i = 0 ; i < R ; i ++ ) { bool isOne = false ; for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i , j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } isOne = false ; for ( int j = C - 1 ; j >= 0 ; j -- ) { if ( mat [ i , j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } } for ( int j = 0 ; j < C ; j ++ ) { bool isOne = false ; for ( int i = 0 ; i < R ; i ++ ) { if ( mat [ i , j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } isOne = false ; for ( int i = R - 1 ; i >= 0 ; i -- ) { if ( mat [ i , j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } } return res ; }
double Circumradius ( int a , int b , int c , int d ) { double s = ( a + b + c + d ) / 2.0 ; double radius = Math . Sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) ; return radius / 4 ; }
int calculateTriangles ( int [ ] sides ) { double count = Math . Pow ( sides [ 0 ] + sides [ 1 ] + sides [ 2 ] , 2 ) ; count -= Math . Pow ( sides [ 0 ] , 2 ) ; count -= Math . Pow ( sides [ 2 ] , 2 ) ; count -= Math . Pow ( sides [ 4 ] , 2 ) ; return ( int ) ( count ) ; }
double Length_Diagonal ( int a , int b , double theta ) { double diagonal = Math . Sqrt ( ( Math . Pow ( a , 2 ) + Math . Pow ( b , 2 ) ) - 2 * a * b * Math . Cos ( theta * ( Math . PI / 180 ) ) ) ; return diagonal ; }
void maximumTiles ( int n , int m ) { Console . WriteLine ( ( m * n ) / 2 ) ; }
float Length_Diagonal ( int a , int b , int d ) { float diagonal = ( float ) Math . Sqrt ( 2 * ( ( a * a ) + ( b * b ) ) - ( d * d ) ) ; return diagonal ; }
List < float > Diagonals ( int a , int b , int c , int d ) { List < float > ans = new List < float > ( ) ; ans . Add ( ( float ) Math . Sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) ) ; ans . Add ( ( float ) Math . Sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) ) ; return ans ; }
double find ( double x , double y , int [ , ] p ) { double mind = 0 ; for ( int i = 0 ; i < p . GetLength ( 0 ) ; i ++ ) { double a = p [ i , 0 ] , b = p [ i , 1 ] ; mind += Math . Sqrt ( ( x - a ) * ( x - a ) + ( y - b ) * ( y - b ) ) ; } return mind ; }
double getMinDistSum ( int [ , ] p ) { double x = 0 , y = 0 ; for ( int i = 0 ; i < p . GetLength ( 0 ) ; i ++ ) { x += p [ i , 0 ] ; y += p [ i , 1 ] ; } x = x / p . Length ; y = y / p . Length ; double mind = find ( x , y , p ) ; return mind ; }
int det ( int [ , ] d ) { int Sum = d [ 0 , 0 ] * ( ( d [ 1 , 1 ] * d [ 2 , 2 ] ) - ( d [ 2 , 1 ] * d [ 1 , 2 ] ) ) ; Sum -= d [ 0 , 1 ] * ( ( d [ 1 , 0 ] * d [ 2 , 2 ] ) - ( d [ 1 , 2 ] * d [ 2 , 0 ] ) ) ; Sum += d [ 0 , 2 ] * ( ( d [ 0 , 1 ] * d [ 1 , 2 ] ) - ( d [ 0 , 2 ] * d [ 1 , 1 ] ) ) ; return Sum ; }
double distance ( int r , int R ) { double d = Math . Sqrt ( Math . Pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void replacematrix ( int [ , ] mat , int n , int m ) { int [ ] rgcd = new int [ R ] ; int [ ] cgcd = new int [ C ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i , j ] ) ; cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i , j ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) mat [ i , j ] = Math . Max ( rgcd [ i ] , cgcd [ j ] ) ; }
int areaOfSquare ( int S ) { int area = S * S ; return area ; }
bool isAllKs ( int n , int b , int k ) { int len = findNumberOfDigits ( n , b ) ; int sum = k * ( 1 - ( int ) Math . Pow ( b , len ) ) / ( 1 - b ) ; return sum == n ; }
void checkRightAngled ( int X1 , int Y1 , int X2 , int Y2 , int X3 , int Y3 ) { int A = ( int ) Math . Pow ( ( X2 - X1 ) , 2 ) + ( int ) Math . Pow ( ( Y2 - Y1 ) , 2 ) ; int B = ( int ) Math . Pow ( ( X3 - X2 ) , 2 ) + ( int ) Math . Pow ( ( Y3 - Y2 ) , 2 ) ; int C = ( int ) Math . Pow ( ( X3 - X1 ) , 2 ) + ( int ) Math . Pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( A > 0 && B > 0 && C > 0 ) && ( A == ( B + C ) || B == ( A + C ) || C == ( A + B ) ) ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
void checkValidPolygon ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 180 * ( N - 2 ) ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
double minAnglRot ( int N ) { double res ; res = 360 / ( double ) N ; return res ; }
int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
int sortedCount ( int [ , ] mat , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i , j + 1 ] <= mat [ i , j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i , j - 1 ] <= mat [ i , j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; }
double Area_of_Triangle ( int a , int b , int c ) { int s = ( a + b + c ) / 2 ; int x = s * ( s - a ) ; x = x * ( s - b ) ; x = x * ( s - c ) ; double area = ( 4 / ( double ) 3 ) * Math . Sqrt ( x ) ; return area ; }
float Area_of_Triangle ( int a , int b , int k ) { float area = ( float ) ( ( 1 / 2.0 ) * a * b * Math . Sin ( k ) ) ; return area ; }
int findAreaCovered ( ) { int area = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { if ( arr [ i , j ] == true ) { area ++ ; } } } return area ; }
void findEquation ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int d , int e , int f ) { double a = x2 - x1 ; double b = y2 - y1 ; double c = z2 - z1 ; int A = ( int ) ( b * f - c * e ) ; int B = ( int ) ( a * f - c * d ) ; int C = ( int ) ( a * e - b * d ) ; int D = - ( int ) ( A * d - B * e + C * f ) ; Console . Write ( A + "x + " + B + "y + " + C + "z + " + D + "= 0 " ) ; }
void createPrefixArray ( int n , int [ ] arr , int prefSize , int [ ] pref ) { for ( int i = 0 ; i < prefSize ; i ++ ) { pref [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] + 1000000 ; pref [ x ] ++ ; } for ( int i = 1 ; i < prefSize ; i ++ ) { pref [ i ] += pref [ i - 1 ] ; } }
int count_rectangles ( int N , int M ) { int p_x = ( N * ( N - 1 ) ) / 2 ; int p_y = ( M * ( M - 1 ) ) / 2 ; return p_x * p_y ; }
float median ( int a , int b , int c ) { float n = ( float ) ( Math . Sqrt ( 2 * b * b + 2 * c * c - a * a ) / 2 ) ; return n ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i < n + 1 ; i ++ ) res = res * i ; return res ; }
double circleArea ( double r ) { double pi = 3.14159265358979323846 ; return ( pi * r * r ) ; }
double findCircleAreaByMedian ( int m ) { double r = 2 * m / 3 ; return circleArea ( r ) ; }
int areaSquare ( int L , int B ) { int large = Math . Max ( L , B ) ; int small = Math . Min ( L , B ) ; if ( large >= 2 * small ) { return large * large ; } else { return ( 2 * small ) * ( 2 * small ) ; } }
double nGon ( int N ) { double proAngleVar ; if ( N % 4 == 0 ) { proAngleVar = pi * ( 180.0 / N ) / 180 ; } else { proAngleVar = pi * ( 180.0 / ( 2 * N ) ) / 180 ; } double negX = 1.0e+99 , posX = - 1.0e+99 , negY = 1.0e+99 , posY = - 1.0e+99 ; for ( int j = 0 ; j < N ; ++ j ) { double px = Math . Cos ( 2 * pi * j / N + proAngleVar ) ; double py = Math . Sin ( 2 * pi * j / N + proAngleVar ) ; negX = Math . Min ( negX , px ) ; posX = Math . Max ( posX , px ) ; negY = Math . Min ( negY , py ) ; posY = Math . Max ( posY , py ) ; } double opt2 = Math . Max ( posX - negX , posY - negY ) ; return ( double ) opt2 / Math . Sin ( pi / N ) / 2 ; }
float cal_cos ( float n ) { float accuracy = ( float ) 0.0001 , x1 , denominator , cosx , cosval ; n = ( float ) ( n * ( 3.142 / 180.0 ) ) ; x1 = 1 ; cosx = x1 ; cosval = ( float ) Math . Cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . Abs ( cosval - cosx ) ) ; return cosx ; }
int triacontagonalNum ( int n ) { return ( 28 * n * n - 26 * n ) / 2 ; }
int hexacontagonNum ( int n ) { return ( 58 * n * n - 56 * n ) / 2 ; }
bool isicositetragonal ( int N ) { float n = ( float ) ( ( 10 + Math . Sqrt ( 44 * N + 100 ) ) / 22 ) ; return ( n - ( int ) n ) == 0 ; }
int enneacontagonNum ( int n ) { return ( 88 * n * n - 86 * n ) / 2 ; }
int triacontakaidigonNum ( int n ) { return ( 30 * n * n - 28 * n ) / 2 ; }
int maxXOR ( int [ , ] mat , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 ; c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i , j ] ; c_xor = c_xor ^ mat [ j , i ] ; } if ( max_xor < Math . Max ( r_xor , c_xor ) ) max_xor = Math . Max ( r_xor , c_xor ) ; } return max_xor ; }
bool isTridecagon ( int N ) { float n = ( float ) ( ( 9 + Math . Sqrt ( 88 * N + 81 ) ) / 22 ) ; return ( n - ( int ) n ) == 0 ; }
bool isicosihenagonal ( int N ) { float n = ( float ) ( ( 17 + Math . Sqrt ( 152 * N + 289 ) ) / 38 ) ; return ( n - ( int ) n ) == 0 ; }
bool isicositrigonal ( int N ) { float n = ( float ) ( 19 + Math . Sqrt ( 168 * N + 361 ) ) / 42 ; return ( n - ( int ) n ) == 0 ; }
int IcosihexagonalNum ( int n ) { return ( 24 * n * n - 22 * n ) / 2 ; }
int icosikaioctagonalNum ( int n ) { return ( 26 * n * n - 24 * n ) / 2 ; }
int hectagonNum ( int n ) { return ( 98 * n * n - 96 * n ) / 2 ; }
int tetracontagonNum ( int n ) { return ( 38 * n * n - 36 * n ) / 2 ; }
int Tridecagonal_num ( int n ) { return ( 11 * n * n - 9 * n ) / 2 ; }
int Octadecagonal_num ( int n ) { return ( 16 * n * n - 14 * n ) / 2 ; }
int Icositetragonal_num ( int n ) { return ( 22 * n * n - 20 * n ) / 2 ; }
int Icosihenagonal_num ( int n ) { return ( 19 * n * n - 17 * n ) / 2 ; }
void checkTriangle ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a = x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ; if ( a == 0 ) Console . WriteLine ( "No" ) ; else Console . WriteLine ( "Yes" ) ; }
int numTrip ( ArrayList points ) { int res = 0 ; for ( int i = 0 ; i < points . Count ; ++ i ) { Dictionary < long , int > map = new Dictionary < long , int > ( ) ; for ( int j = 0 ; j < points . Count ; ++ j ) { if ( j == i ) continue ; int dy = ( ( pair ) points [ i ] ) . second - ( ( pair ) points [ j ] ) . second ; int dx = ( ( pair ) points [ i ] ) . first - ( ( pair ) points [ j ] ) . first ; int key = dy * dy ; key += dx * dx ; if ( map . ContainsKey ( key ) ) { map [ key ] ++ ; } else { map [ key ] = 1 ; } } foreach ( int p in map . Values ) res += p * ( p - 1 ) ; } return res ; }
bool checkOverlap ( int R , int Xc , int Yc , int X1 , int Y1 , int X2 , int Y2 ) { int Xn = Math . Max ( X1 , Math . Min ( Xc , X2 ) ) ; int Yn = Math . Max ( Y1 , Math . Min ( Yc , Y2 ) ) ; int Dx = Xn - Xc ; int Dy = Yn - Yc ; return ( Dx * Dx + Dy * Dy ) <= R * R ; }
double area_of_circle ( int m , int n ) { int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; }
void direction ( int R , int C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) { Console . WriteLine ( "Left" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) { Console . WriteLine ( "Up" ) ; return ; } if ( R == C && R % 2 != 0 && C % 2 != 0 ) { Console . WriteLine ( "Right" ) ; return ; } if ( R == C && R % 2 == 0 && C % 2 == 0 ) { Console . WriteLine ( "Left" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { Console . WriteLine ( "Right" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) { Console . WriteLine ( "Down" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) { Console . WriteLine ( "Left" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) { Console . WriteLine ( "Up" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) { Console . WriteLine ( "Down" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) { Console . WriteLine ( "Right" ) ; return ; } }
int checkIntersection ( pair p1 , pair p2 , pair p ) { int val ; if ( p1 . second == p2 . second && p1 . second == p . second ) { if ( p . first <= Math . Max ( p1 . first , p2 . first ) && ( p . first >= Math . Min ( p1 . first , p2 . first ) ) ) return 1 ; } if ( p1 . first == p2 . first && p1 . first == p . first ) { if ( p . second <= Math . Max ( p1 . second , p2 . second ) && ( p . second >= Math . Min ( p1 . second , p2 . second ) ) ) return 1 ; } else { val = ( p . second - p1 . second ) * ( p2 . first - p1 . first ) - ( p . first - p1 . first ) * ( p2 . second - p1 . second ) ; if ( val == 0 ) if ( ( p . first <= Math . Max ( p1 . first , p2 . first ) && ( p . first >= Math . Min ( p1 . first , p2 . first ) ) ) && ( p . second <= Math . Max ( p1 . second , p2 . second ) && ( p . second >= Math . Min ( p1 . second , p2 . second ) ) ) ) return 1 ; } return 0 ; }
void towerOfSight ( pair a , pair b , pair c , pair d ) { int flag = 0 ; if ( checkIntersection ( a , c , b ) == 1 ) flag = 1 ; else if ( checkIntersection ( a , c , d ) == 1 ) flag = 1 ; else if ( checkIntersection ( b , d , a ) == 1 ) flag = 1 ; else if ( checkIntersection ( b , d , c ) == 1 ) flag = 1 ; Console . Write ( flag == 1 ? "Yes\n" : "No\n" ) ; }
int NotParallel ( int [ , ] p , int n ) { Dictionary < int , int > x_axis = new Dictionary < int , int > ( ) ; Dictionary < int , int > y_axis = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( x_axis . ContainsKey ( p [ i , 0 ] ) ) x_axis [ p [ i , 0 ] ] = x_axis [ p [ i , 0 ] ] + 1 ; else x_axis . Add ( p [ i , 0 ] , 1 ) ; if ( y_axis . ContainsKey ( p [ i , 1 ] ) ) y_axis [ p [ i , 1 ] ] = y_axis [ p [ i , 1 ] ] + 1 ; else y_axis . Add ( p [ i , 1 ] , 1 ) ; } int total = ( n * ( n - 1 ) ) / 2 ; foreach ( KeyValuePair < int , int > i in x_axis ) { int c = i . Value ; total -= ( c * ( c - 1 ) ) / 2 ; } foreach ( KeyValuePair < int , int > i in y_axis ) { int c = i . Value ; total -= ( c * ( c - 1 ) ) / 2 ; } return total ; }
void checkTypeOfTriangle ( int a , int b , int c ) { int sqa = ( int ) Math . Pow ( a , 2 ) ; int sqb = ( int ) Math . Pow ( b , 2 ) ; int sqc = ( int ) Math . Pow ( c , 2 ) ; if ( sqa == sqa + sqb sqb == + == + sqb ) { Console . Write ( "Right-angled Triangle" ) ; } else if ( sqa > sqc + sqb sqb > + > + sqb ) { Console . Write ( "Obtuse-angled Triangle" ) ; } else { Console . Write ( "Acute-angled Triangle" ) ; } }
void lineFromPoints ( point P , point Q , double a , double b , double c ) { a = Q . y - P . y ; b = P . x - Q . x ; c = a * ( P . x ) + b * ( P . y ) ; }
double LineInterX ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { double determ = a1 * b2 - a2 * b1 ; double x = ( b2 * c1 - b1 * c2 ) ; x /= determ ; return x ; }
double LineInterY ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { double determ = a1 * b2 - a2 * b1 ; double y = ( a1 * c2 - a2 * c1 ) ; y /= determ ; return y ; }
void findPosition ( point P , point Q , point R , point D ) { point r = new point ( ) ; double a = 0 , b = 0 , c = 0 ; lineFromPoints ( P , Q , a , b , c ) ; double e = 0 , f = 0 , g = 0 ; lineFromPoints ( Q , R , e , f , g ) ; perpenBisectorFromLine ( P , Q , a , b , c ) ; perpenBisectorFromLine ( Q , R , e , f , g ) ; r . x = LineInterX ( a , b , c , e , f , g ) ; r . y = LineInterY ( a , b , c , e , f , g ) ; double q = ( r . x - P . x ) * ( r . x - P . x ) + ( r . y - P . y ) * ( r . y - P . y ) ; double dis = ( r . x - D . x ) * ( r . x - D . x ) + ( r . y - D . y ) * ( r . y - D . y ) ; if ( dis < q ) { Console . Write ( "Point (" + D . x + ", " + D . y + ") is inside " + "the circumcircle" ) ; } else if ( dis == q ) { Console . Write ( "Point (" + D . x + ", " + D . y + ") lies on the " + "circumcircle" ) ; } else { Console . Write ( "Point (" + D . x + ", " + D . y + ") lies outside" + " the circumcircle" ) ; } }
void disp ( int row_no , int block ) { Console . Write ( row_no * block ) ; }
int row ( int ht , int h ) { return ht / h ; }
void calculate ( int l , int w , int h , int a , int ht ) { int no_block = ( 4 * a ) / l ; int row_no ; if ( h < w ) row_no = row ( ht , w ) ; else row_no = row ( ht , h ) ; disp ( row_no , no_block ) ; }
double solve ( int s ) { double area = ( 1.732 * Math . Pow ( s , 2 ) ) / 8 ; return area ; }
double area ( int R ) { double Base = 1.732 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * Base * height ; return area ; }
void spiralPrint ( int m , int n , int [ , ] a , int c ) { int i , k = 0 , l = 0 ; int count = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { count ++ ; if ( count == c ) Console . WriteLine ( a [ k , i ] + " " ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { count ++ ; if ( count == c ) Console . WriteLine ( a [ i , n - 1 ] + " " ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { count ++ ; if ( count == c ) Console . WriteLine ( a [ m - 1 , i ] + " " ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { count ++ ; if ( count == c ) Console . WriteLine ( a [ i , l ] + " " ) ; } l ++ ; } } }
float find_Area ( float a ) { float R = a * ( float ) ( 2.0 - Math . Sqrt ( 2 ) ) ; float area = ( float ) ( ( 3.14 * R * R ) / 2.0 ) ; return area ; }
int times ( int [ ] steps , int n ) { int current_level = 0 ; int previous_level = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { previous_level = current_level ; current_level = current_level + steps [ i ] ; if ( ( previous_level < 0 && current_level >= 0 ) || ( previous_level > 0 && current_level <= 0 ) ) { count ++ ; } } return count ; }
int solve ( int n , int m , int obstacles , double [ ] range ) { double val = Math . Min ( n , m ) ; Array . Sort ( range ) ; int c = 1 ; for ( int i = obstacles - 1 ; i >= 0 ; i -- ) { range [ i ] = 2 * range [ i ] ; val -= range [ i ] ; if ( val <= 0 ) { return c ; } else { c ++ ; } } if ( val > 0 ) { return - 1 ; } return 0 ; }
void equation_plane ( int [ ] p , int [ ] q , int [ ] r ) { int x1 = p [ 0 ] ; int y1 = p [ 1 ] ; int z1 = p [ 2 ] ; int x2 = q [ 0 ] ; int y2 = q [ 1 ] ; int z2 = q [ 2 ] ; int x3 = r [ 0 ] ; int y3 = r [ 1 ] ; int z3 = r [ 2 ] ; int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int A = ( b1 * c2 - b2 * c1 ) ; int B = ( a2 * c1 - a1 * c2 ) ; int C = ( a1 * b2 - b1 * a2 ) ; int D = ( - A * x1 - B * y1 - C * z1 ) ; double [ ] rslt = XandYandZintercept ( A , B , C , D ) ; for ( int i = 0 ; i < 3 ; i ++ ) { Console . Write ( rslt [ i ] + " " ) ; } }
int countPairs ( int [ ] P , int [ ] Q , int N , int M ) { int [ ] A = new int [ 2 ] ; int [ ] B = new int [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; }
float find_angle ( int x , int y , int z ) { int volume = x * x * y ; float ans = 0 ; if ( z < volume / 2 ) { float d = ( float ) ( ( x * y * y ) / ( 2.0 * z ) ) ; ans = ( float ) Math . Atan ( d ) ; } else { z = volume - z ; float d = ( 2 * z ) / ( float ) ( x * x * x ) ; ans = ( float ) Math . Atan ( d ) ; } ans = ( float ) ( ( ans * 180 ) / 3.14159265 ) ; return ans ; }
List < pair > FindPoints ( int n ) { List < pair > v = new List < pair > ( ) ; v . Add ( new pair ( 0 , 0 ) ) ; v . Add ( new pair ( 0 , n ) ) ; v . Add ( new pair ( n , 0 ) ) ; v . Add ( new pair ( n , n ) ) ; if ( n % 2 == 0 ) v . Add ( new pair ( n / 2 , n / 2 ) ) ; return v ; }
double findsolution ( double d , double h , double m , double n ) { double k = ( 4 * m ) / ( pie * d * d ) ; if ( n > k ) return - 1 ; double ans = ( h / ( k - n ) ) ; return ans ; }
double [ ] find_Centroid ( double [ , ] v ) { double [ ] ans = new double [ 2 ] ; int n = v . GetLength ( 0 ) ; double signedArea = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x0 = v [ i , 0 ] , y0 = v [ i , 1 ] ; double x1 = v [ ( i + 1 ) % n , 0 ] , y1 = v [ ( i + 1 ) % n , 1 ] ; double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) ; ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) ; return ans ; }
int sumOfInternalAngles ( int n ) { if ( n < 3 ) return 0 ; return ( ( n - 2 ) * 180 ) ; }
int cntWays ( int n ) { if ( n % 2 == 1 ) { return 0 ; } else { return ( n - 2 ) / 4 ; } }
int noOfTriangles ( int n ) { int y = 4 * n ; return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) / 6 ; }
int angle ( int n ) { return 2 * n ; }
bool checkDiagonal ( int [ , ] mat , int i , int j ) { int res = mat [ i , j ] ; while ( ++ i < N && ++ j < M ) { if ( mat [ i , j ] != res ) return false ; } return true ; }
bool ifRight ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a = ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ; int b = ( ( x1 - x3 ) * ( x1 - x3 ) ) + ( ( y1 - y3 ) * ( y1 - y3 ) ) ; int c = ( ( x2 - x3 ) * ( x2 - x3 ) ) + ( ( y2 - y3 ) * ( y2 - y3 ) ) ; if ( ( a == ( b + c ) && a != 0 && b != 0 && c != 0 ) || ( b == ( a + c ) && a != 0 && b != 0 && c != 0 ) || ( c == ( a + b ) && a != 0 && b != 0 && c != 0 ) ) { return true ; } return false ; }
void isValidCombination ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int x , y ; bool possible = false ; if ( ifRight ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { Console . WriteLine ( "ALREADY RIGHT ANGLED" ) ; return ; } else { for ( int i = 0 ; i < 4 ; i ++ ) { x = dx [ i ] + x1 ; y = dy [ i ] + y1 ; if ( ifRight ( x , y , x2 , y2 , x3 , y3 ) ) { Console . WriteLine ( "POSSIBLE" ) ; return ; } x = dx [ i ] + x2 ; y = dy [ i ] + y2 ; if ( ifRight ( x1 , y1 , x , y , x3 , y3 ) ) { Console . WriteLine ( "POSSIBLE" ) ; return ; } x = dx [ i ] + x3 ; y = dy [ i ] + y3 ; if ( ifRight ( x1 , y1 , x2 , y2 , x , y ) ) { Console . Write ( "POSSIBLE" ) ; return ; } } } if ( ! possible ) Console . WriteLine ( "NOT POSSIBLE" ) ; }
double area_of_regular_polygon ( double n , double len ) { double P = ( len * n ) ; double A = len / ( 2 * Math . Tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; double area = ( P * A ) / 2 ; return area ; }
double area_of_triangle_inscribed ( double n , double len ) { double area = area_of_regular_polygon ( n , len ) ; double triangle = area / n ; double ins_tri = ( triangle * 3 ) ; return ins_tri ; }
void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ; Console . WriteLine ( num ) ; }
bool pointsAreOnSameSideOfLine ( int a , int b , int c , int x1 , int y1 , int x2 , int y2 ) { fx1 = a * x1 + b * y1 - c ; fx2 = a * x2 + b * y2 - c ; if ( ( fx1 * fx2 ) > 0 ) return true ; return false ; }
float Area ( int d , int h1 , int h2 ) { float area ; area = ( float ) 0.5 * d * ( h1 + h2 ) ; return area ; }
float diagonal_length ( float a ) { float L ; L = a * ( float ) Math . Sqrt ( 3 ) ; return L ; }
double find_area ( int r , int d ) { double R = d / PI ; R += Math . Pow ( r , 2 ) ; R = Math . Sqrt ( R ) ; double area = PI * Math . Pow ( R , 2 ) ; return area ; }
bool Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return true ; return false ; }
int Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; }
double calculate_angle ( double n ) { double total_angle = 360 ; return total_angle / n ; }
float areaOfKite ( int a , int b , double angle ) { angle = angle * PI ; double area = a * b * Math . Sin ( angle ) ; return ( float ) area ; }
float angleOncirCumference ( float z ) { return ( z / 2 ) ; }
void newvol ( double x ) { Console . Write ( "percentage increase " + "in the volume of the cube is " + ( Math . Pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . Pow ( x , 2 ) ) / 100 ) ) ; Console . Write ( "%" ) ; }
void newvol ( double x ) { Console . WriteLine ( "percentage increase in the" + " volume of the sphere is " + ( Math . Pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . Pow ( x , 2 ) ) / 100 ) + "%" ) ; }
int countZeroes ( int [ , ] mat ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row , col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }
void newvol ( double x ) { Console . WriteLine ( "percentage increase " + "in the volume of the cylinder is " + x + "%" ) ; }
void radius ( double n , double d ) { Console . WriteLine ( "The side of each square is " + d / ( ( n - 1 ) * Math . Sqrt ( 2 ) ) ) ; }
void findTriangles ( int n ) { int num = n ; Console . Write ( num + " " ) ; Console . WriteLine ( num * ( num - 4 ) * ( num - 5 ) / 6 ) ; }
void radius ( int n , int d ) { Console . Write ( "The radius of each circle is " + d / ( 2 * n - 2 ) ) ; }
void radius ( int n , int d ) { Console . Write ( "The side of each square is " + d / ( n - 1 ) ) ; }
double innerCirclearea ( double radius ) { if ( radius < 0 ) { return - 1 ; } double r = radius / 2 ; double Area = ( 3.14 * Math . Pow ( r , 2 ) ) ; return Area ; }
double areaOfTriangle ( float d ) { float c = ( float ) ( 1.618 * d ) ; float s = ( d + c + c ) / 2 ; double area = Math . Sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) ; return 5 * area ; }
double areaOfRegPentagon ( float d ) { double cal = 4 * Math . Tan ( PI / 5 ) ; double area = ( 5 * d * d ) / cal ; return area ; }
double areaOfPentagram ( float d ) { return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) ; }
void lengperpbisect ( double r1 , double r2 ) { double z = 2 * Math . Sqrt ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ; Console . WriteLine ( "The length of the " + "perpendicular bisector is " + z ) ; }
void anglequichord ( int z ) { Console . WriteLine ( "The angle is " + z + " degrees" ) ; }
void lengchord ( int z ) { Console . WriteLine ( "The length is " + z ) ; }
void angleextcycquad ( int z ) { Console . WriteLine ( "The exterior angle of the" + " cyclic quadrilateral is " + z + " degrees" ) ; }
void anglechordtang ( int z ) { Console . WriteLine ( "The angle between tangent" + " and the chord is " + z + " degrees" ) ; }
void circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( int ) Math . Sqrt ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ; if ( distSq + r2 == r1 ) { Console . WriteLine ( "The smaller circle lies completely" + " inside the bigger circle with " + "touching each other " + "at a point of circumference. " ) ; } else if ( distSq + r2 < r1 ) { Console . WriteLine ( "The smaller circle lies completely" + " inside the bigger circle without" + " touching each other " + "at a point of circumference." ) ; } else { Console . WriteLine ( "The smaller does not lies inside" + " the bigger circle completely." ) ; } }
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
int countOdd ( int n ) { int coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i >= 1 ) { m = ( n - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } else { m = ( ( n - 1 ) - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } } return coun ; }
int countEven ( int n ) { int coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i >= 1 ) { m = ( ( n - 1 ) - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } else { m = ( n - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } } return coun ; }
int countNegative ( int [ , ] M , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i , j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }
int GCD ( int a , int b ) { return ( b != 0 ? GCD ( b , a % b ) : a ) ; }
void ratiotang ( int r1 , int r2 ) { Console . WriteLine ( "The ratio is " + r1 / GCD ( r1 , r2 ) + ":" + r2 / GCD ( r1 , r2 ) ) ; }
int Regions ( int Vertices , int Edges ) { int R = Edges + 2 - Vertices ; return R ; }
void ratiotang ( int r1 , int r2 ) { Console . WriteLine ( "The ratio is " + r1 / GCD ( r1 , r2 ) + " : " + r2 / GCD ( r1 , r2 ) ) ; }
void lengthOfTangent ( double r1 , double r2 , double d ) { Console . WriteLine ( "The length of the transverse" + " common tangent is " + Math . Sqrt ( Math . Pow ( d , 2 ) - Math . Pow ( ( r1 + r2 ) , 2 ) ) ) ; }
int remainingArea ( int N , int M , int K ) { while ( K -- > 0 && N > 0 && M > 0 ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }
void lengtang ( double r1 , double r2 , double d ) { Console . WriteLine ( "The length of the direct" + " common tangent is " + ( Math . Sqrt ( Math . Pow ( d , 2 ) - Math . Pow ( ( r1 - r2 ) , 2 ) ) ) ) ; }
void rad ( double d , double h ) { Console . WriteLine ( "The radius of the circle is " + ( ( d * d ) / ( 8 * h ) + h / 2 ) ) ; }
void lengtang ( double r1 , double r2 ) { Console . WriteLine ( "The length of the " + "direct common tangent is " + ( 2 * Math . Sqrt ( r1 * r2 ) ) ) ; }
void diameter ( double r ) { Console . WriteLine ( "The length of the longest chord" + " or diameter of the circle is " + 2 * r ) ; }
double dist ( double m , double b1 , double b2 ) { double d = Math . Abs ( b2 - b1 ) / ( ( m * m ) - 1 ) ; return d ; }
double getSlope ( double m ) { return m ; }
int totalTriangles ( int h , int v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; int total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; }
int findLargestPlus ( int [ , ] mat ) { int [ , ] left = new int [ N , N ] ; int [ , ] right = new int [ N , N ] ; int [ , ] top = new int [ N , N ] ; int [ , ] bottom = new int [ N , N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 , i ] = mat [ 0 , i ] ; bottom [ N - 1 , i ] = mat [ N - 1 , i ] ; left [ i , 0 ] = mat [ i , 0 ] ; right [ i , N - 1 ] = mat [ i , N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i , j ] == 1 ) left [ i , j ] = left [ i , j - 1 ] + 1 ; else left [ i , j ] = 0 ; if ( mat [ j , i ] == 1 ) top [ j , i ] = top [ j - 1 , i ] + 1 ; else top [ j , i ] = 0 ; j = N - 1 - j ; if ( mat [ j , i ] == 1 ) bottom [ j , i ] = bottom [ j + 1 , i ] + 1 ; else bottom [ j , i ] = 0 ; if ( mat [ i , j ] == 1 ) right [ i , j ] = right [ i , j + 1 ] + 1 ; else right [ i , j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = Math . Min ( Math . Min ( top [ i , j ] , bottom [ i , j ] ) , Math . Min ( left [ i , j ] , right [ i , j ] ) ) ; if ( len > n ) n = len ; } } if ( n > 0 ) return 4 * ( n - 1 ) + 1 ; return 0 ; }
void noOfSquares ( int x1 , int y1 , int x2 , int y2 ) { int dx = Math . Abs ( x2 - x1 ) ; int dy = Math . Abs ( y2 - y1 ) ; int ans = dx + dy - __gcd ( dx , dy ) ; Console . WriteLine ( ans ) ; }
int countSteps ( int x , int y ) { if ( x < y ) { return x + y + 2 * ( ( y - x ) / 2 ) ; } else { return x + y + 2 * ( ( ( x - y ) + 1 ) / 2 ) ; } }
bool isSlopeGood ( double slope , int [ ] arr , int n ) { HashSet < Double > setOfLines = new HashSet < Double > ( ) ; for ( int i = 0 ; i < n ; i ++ ) setOfLines . Add ( arr [ i ] - slope * ( i ) ) ; return setOfLines . Count == 2 ; }
bool checkForParallel ( int [ ] arr , int n ) { bool slope1 = isSlopeGood ( arr [ 1 ] - arr [ 0 ] , arr , n ) ; bool slope2 = isSlopeGood ( arr [ 2 ] - arr [ 1 ] , arr , n ) ; bool slope3 = isSlopeGood ( ( arr [ 2 ] - arr [ 0 ] ) / 2 , arr , n ) ; return ( slope1 == true slope2 == true slope3 == true ) ; }
long countPaths ( int x1 , int y1 , int x2 , int y2 ) { int m = Math . Abs ( x1 - x2 ) ; int n = Math . Abs ( y1 - y2 ) ; return ( binomialCoeff ( m + n , n ) ) ; }
Pair < int , int > findFourthVertex ( int n , int m , String [ ] s ) { Dictionary < int , int > row = new Dictionary < int , int > ( ) ; Dictionary < int , int > col = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( s [ i ] [ j ] == '*' ) { if ( row . ContainsKey ( i ) ) { row [ i ] = row [ i ] + 1 ; } else { row . Add ( i , 1 ) ; } if ( col . ContainsKey ( j ) ) { col [ j ] = col [ j ] + 1 ; } else { col . Add ( j , 1 ) ; } } } } int x = 0 , y = 0 ; foreach ( KeyValuePair < int , int > entry in row ) { if ( entry . Value == 1 ) x = entry . Key ; } foreach ( KeyValuePair < int , int > entry in col ) { if ( entry . Value == 1 ) y = entry . Key ; } Pair < int , int > ans = new Pair < int , int > ( x + 1 , y + 1 ) ; return ans ; }
float sph ( float r , float R , float h ) { if ( r < 0 && R < 0 && h < 0 ) return - 1 ; float x = r ; float V = ( float ) ( 4 * 3.14f * Math . Pow ( r , 3 ) ) / 3 ; return V ; }
double Area ( double a , double b ) { if ( a < 0 && b < 0 ) return - 1 ; double h = ( double ) Math . Sqrt ( ( ( Math . Pow ( a , 2 ) + Math . Pow ( b , 2 ) ) / ( Math . Pow ( a , 2 ) * Math . Pow ( b , 2 ) ) ) ) ; double A = ( double ) ( 0.70477 * Math . Pow ( h , 2 ) ) ; return A ; }
int maxRectangles ( int L , int B , int l , int b ) { int horizontal = 0 , vertical = 0 ; if ( l <= L && b <= B ) { int columns = B / b ; int rows = L / l ; horizontal = rows * columns ; } if ( l <= B && b <= L ) { int columns = L / b ; int rows = B / l ; vertical = rows * columns ; } return Math . Max ( horizontal , vertical ) ; }
double cone ( double a ) { if ( a < 0 ) return - 1 ; double r = ( double ) ( a * Math . Sqrt ( 2 ) ) / 3 ; double h = ( 2 * a ) / 3 ; double V = ( double ) ( 3.14 * Math . Pow ( r , 2 ) * h ) ; return Math . Round ( V , 4 ) ; }
float Area ( float a ) { if ( a < 0 ) return - 1 ; float h = ( float ) 1.268 * a ; float A = ( float ) ( 0.70477 * Math . Pow ( h , 2 ) ) ; return A ; }
double Area ( double r ) { if ( r < 0 ) return - 1 ; double x = ( 2 * r ) / ( double ) ( Math . Sqrt ( 5 ) ) ; double A = 0.70477 * ( double ) ( Math . Pow ( x , 2 ) ) ; return A ; }
float Area ( float a ) { if ( a < 0 ) return - 1 ; float x = 0.464f * a ; float A = 0.70477f * ( float ) Math . Pow ( x , 2 ) ; return A ; }
double areaCircle ( double b ) { double area = ( double ) 3.1415926 * b * b ; return area ; }
double areaSquare ( double side , double fold ) { double area = side * side ; return area * 1.0 / Math . Pow ( 2 , fold ) ; }
bool checkOrtho ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int m1 , m2 ; if ( x2 - x1 == 0 && x4 - x3 == 0 ) return false ; else if ( x2 - x1 == 0 ) { m2 = ( y4 - y3 ) / ( x4 - x3 ) ; if ( m2 == 0 ) return true ; else return false ; } else if ( x4 - x3 == 0 ) { m1 = ( y2 - y1 ) / ( x2 - x1 ) ; if ( m1 == 0 ) return true ; else return false ; } else { m1 = ( y2 - y1 ) / ( x2 - x1 ) ; m2 = ( y4 - y3 ) / ( x4 - x3 ) ; if ( m1 * m2 == - 1 ) return true ; else return false ; } }
double square ( double a ) { if ( a < 0 ) return - 1 ; double x = 0.464 * a ; return x ; }
double ReuleauxArea ( double r ) { if ( r < 0 ) return - 1 ; double A = 0.70477 * 2 * Math . Pow ( r , 2 ) ; return A ; }
float cyl ( float a ) { if ( a < 0 ) return - 1 ; float r = ( 2 * a * ( float ) ( Math . Sqrt ( 2 ) ) / 3 ) ; float h = ( 2 * a ) / 3 ; float V = ( 3.14f * ( float ) ( Math . Pow ( r , 2 ) * h ) ) ; return V ; }
double Area ( double l , double b , double h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; double x = ( l * b ) / ( l + b ) ; double A = 0.70477 * Math . Pow ( x , 2 ) ; return A ; }
bool isPossible ( float x , float y , float z ) { float a = x * x + y * y + z * z ; if ( Math . Ceiling ( a ) == 1 && Math . Floor ( a ) == 1 ) return true ; return false ; }
double polyapothem ( double n , double a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * Math . Tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; }
float polydiagonal ( float n , float a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( float ) ( 2 * a * Math . Sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) ; }
double polyarea ( double n , double r ) { if ( r < 0 && n < 0 ) return - 1 ; double A = ( ( r * r * n ) * Math . Sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; }
double decdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.902 * a ; return d ; }
double hexagonside ( double a ) { if ( a < 0 ) return - 1 ; double x = ( 0.5176 * a ) ; return x ; }
float hexagonside ( float a ) { if ( a < 0 ) return - 1 ; float x = a / 3 ; return x ; }
double hexDiagonal ( float a ) { if ( a < 0 ) return - 1 ; double d = ( double ) 1.73 * a ; return d ; }
double pentdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.22 * a ; return d ; }
double ReuleauxArea ( float a ) { if ( a < 0 ) return - 1 ; double A = ( double ) 0.70477 * Math . Pow ( a , 2 ) ; return A ; }
double calculateSide ( double n , double r ) { double theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return Math . Round ( 2 * r * Math . Sin ( theta_in_radians / 2 ) , 4 ) ; }
float squareArea ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) ( Math . Pow ( 1.268 , 2 ) * Math . Pow ( a , 2 ) ) ; return area ; }
float hexagonArea ( float d ) { return ( float ) ( ( 3 * Math . Sqrt ( 3 ) * d * d ) / 8 ) ; }
float cyl ( float r , float R , float h ) { if ( h < 0 && r < 0 && R < 0 ) return - 1 ; float r1 = r ; float h1 = h ; float V = ( float ) ( 3.14 * Math . Pow ( r1 , 2 ) * h1 ) ; return V ; }
float findVolume ( float a ) { if ( a < 0 ) return - 1 ; float r = a / 2 ; float h = a ; float V = ( float ) ( 3.14 * Math . Pow ( r , 2 ) * h ) ; return V ; }
double length_rope ( double r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }
float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float a = ( float ) Math . Pow ( h , 3 ) ; return a ; }
float sph ( float r , float h ) { if ( r < 0 && h < 0 ) return - 1 ; float R = r ; return R ; }
float cyl ( float R ) { if ( R < 0 ) return - 1 ; float V = ( float ) ( ( 2 * 3.14 * Math . Pow ( R , 3 ) ) / ( 3 * Math . Sqrt ( 3 ) ) ) ; return V ; }
float rod ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float l = ( float ) ( Math . Sqrt ( Math . Pow ( h , 2 ) + 4 * Math . Pow ( r , 2 ) ) ) ; return l ; }
float coner ( float R ) { if ( R < 0 ) return - 1 ; float r = ( float ) ( 2 * Math . Sqrt ( 2 ) * R ) / 3 ; return r ; }
float coneh ( float R ) { if ( R < 0 ) return - 1 ; float h = ( 4 * R ) / 3 ; return h ; }
float coneRadius ( float a ) { if ( a < 0 ) return - 1 ; float r = ( float ) ( a / Math . Sqrt ( 2 ) ) ; return r ; }
float coneHeight ( float a ) { if ( a < 0 ) return - 1 ; float h = a ; return h ; }
float largestCube ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 2 * r ) / ( float ) Math . Sqrt ( 3 ) ; return a ; }
float sphere ( float a ) { if ( a < 0 ) return - 1 ; float r = a / 2 ; return r ; }
int numberOfCuts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }
float maxVol ( float P , float A ) { float l = ( float ) ( P - Math . Sqrt ( P * P - 24 * A ) ) / 12 ; float V = ( float ) ( l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ) ; return V ; }
int maxArea ( float perimeter ) { int length = ( int ) Math . Ceiling ( perimeter / 4 ) ; int breadth = ( int ) Math . Floor ( perimeter / 4 ) ; return length * breadth ; }
int findSegment ( int n , int m , int [ ] segment_length ) { double meet_point = ( 1.0 * n ) / 2.0 ; int sum = 0 ; int segment_number = 0 ; for ( int i = 0 ; i < m ; i ++ ) { sum += segment_length [ i ] ; if ( ( double ) sum == meet_point ) { segment_number = - 1 ; break ; } if ( sum > meet_point ) { segment_number = i + 1 ; break ; } } return segment_number ; }
long countMaxIntersect ( long n ) { return ( n ) * ( n - 1 ) / 2 ; }
void equation_parabola ( float x1 , float y1 , float a , float b , float c ) { float t = a * a + b * b ; float a1 = t - ( a * a ) ; float b1 = t - ( b * b ) ; float c1 = ( - 2 * t * x1 ) - ( 2 * c * a ) ; float d1 = ( - 2 * t * y1 ) - ( 2 * c * b ) ; float e1 = - 2 * a * b ; float f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; Console . WriteLine ( "equation of parabola is " + a1 + " x^2 + " + b1 + " y^2 + " + c1 + " x + " + d1 + " y + " + e1 + " xy + " + f1 + " = 0." ) ; }
int countRectangles ( int l , int w ) { int squareSide = __gcd ( l , w ) ; return ( l * w ) / ( squareSide * squareSide ) ; }
void section ( double x1 , double x2 , double y1 , double y2 , double z1 , double z2 , double m , double n ) { double x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; double y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; double z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ; Console . Write ( "(" + x + ", " ) ; Console . Write ( y + ", " ) ; Console . WriteLine ( z + ")" ) ; }
int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; }
float area ( float r ) { return ( float ) ( ( 0.5 ) * ( 3.14 ) * ( r * r ) ) ; }
bool checkEquilibrium ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int resx = x1 + x2 + x3 ; int resy = y1 + y2 + y3 ; int resz = z1 + z2 + z3 ; if ( resx == 0 & resy == 0 & resz == 0 ) return true ; else return false ; }
float hexadiagonal ( float a ) { if ( a < 0 ) return - 1 ; return 2 * a ; }
double octadiagonal ( double a ) { if ( a < 0 ) return - 1 ; return a * Math . Sqrt ( 4 + ( 2 * Math . Sqrt ( 2 ) ) ) ; }
void CalPeri ( ) { int S = 5 , Perimeter ; Perimeter = 10 * S ; Console . WriteLine ( "The Perimeter of " + "Decagon is : " + Perimeter ) ; }
double octaside ( double a ) { if ( a < 0 ) return - 1 ; double s = a / ( Math . Sqrt ( 2 ) + 1 ) ; return s ; }
double findEdges ( double s1 , double s2 , double s3 ) { double a = Math . Sqrt ( s1 * s2 / s3 ) ; double b = Math . Sqrt ( s3 * s1 / s2 ) ; double c = Math . Sqrt ( s3 * s2 / s1 ) ; double sum = a + b + c ; return 4 * sum ; }
float findRadiusOfcircumcircle ( float n , float a ) { if ( n < 0 a < 0 ) return - 1 ; float radius = ( float ) ( a / Math . Sqrt ( 2 - ( 2 * Math . Cos ( 360 / n ) ) ) ) ; return radius ; }
float rhombusarea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; return ( l * b ) / 2 ; }
bool Arrive ( int a , int b , int n ) { if ( n >= Math . Abs ( a ) + Math . Abs ( b ) && ( n - ( Math . Abs ( a ) + Math . Abs ( b ) ) ) % 2 == 0 ) return true ; return false ; }
bool Move ( int a , int x , int b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; }
float area ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float A = a * b ; return A ; }
double circle_inscribed ( int a ) { return PI * ( a * a ) / 12 ; }
float surfaceArea ( float a , float b , float h ) { return 5 * a * b + 5 * b * h ; }
float volume ( float b , float h ) { return ( 5 * b * h ) / 2 ; }
float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float radius = ( float ) Math . Sqrt ( Math . Pow ( l , 2 ) + Math . Pow ( b , 2 ) ) / 2 ; return radius ; }
double circlearea ( double a , double b , double c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; double p = ( a + b + c ) / 2 ; double At = Math . Sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; double A = 3.14 * Math . Pow ( ( ( a * b * c ) / ( 4 * At ) ) , 2 ) ; return A ; }
float altitude ( float a , float b ) { return ( float ) ( Math . Sqrt ( Math . Pow ( a , 2 ) - ( Math . Pow ( b , 2 ) / 4 ) ) ) ; }
int surfaceArea ( int b , int s ) { return 2 * b * s + ( int ) Math . Pow ( b , 2 ) ; }
float trianglearea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float area = ( l * b ) / 2 ; return area ; }
float area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) Math . Sqrt ( a ) / 6 ; return area ; }
void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) Console . WriteLine ( "NO" ) ; else Console . WriteLine ( "YES" ) ; }
int checkpoint ( int h , int k , int x , int y , int a ) { int p = ( int ) Math . Pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; }
int checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( ( int ) Math . Pow ( ( x - h ) , 2 ) / ( int ) Math . Pow ( a , 2 ) ) + ( ( int ) Math . Pow ( ( y - k ) , 2 ) / ( int ) Math . Pow ( b , 2 ) ) ; return p ; }
float area ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { double a = Math . Pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + Math . Pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + Math . Pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ; float area = ( float ) Math . Sqrt ( a ) ; area = area / 2 ; return area ; }
float trianglearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float area = ( float ) ( 3 * Math . Sqrt ( 3 ) * Math . Pow ( a , 2 ) ) / ( 4 * b ) ; return area ; }
float squarearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float area = 4 * ( float ) ( ( Math . Pow ( a , 2 ) + Math . Pow ( b , 2 ) ) / ( Math . Pow ( a , 2 ) * Math . Pow ( b , 2 ) ) ) ; return area ; }
double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ; temp = length * length + breadth * breadth + height * height ; result = Math . Sqrt ( temp ) ; return result ; }
float trianglearea ( float r ) { if ( r < 0 ) return - 1 ; return r * r ; }
float squarearea ( float r ) { if ( r < 0 ) return - 1 ; float a = 4 * ( float ) ( Math . Pow ( r , 2 ) / 5 ) ; return a ; }
float rectanglearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; return 2 * a * b ; }
float trapezoidarea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 3 * ( float ) Math . Sqrt ( 3 ) * ( float ) Math . Pow ( r , 2 ) ) / 4 ; return a ; }
float squareArea ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; float a = ( l * b ) / ( l + b ) ; return a * a ; }
float circlearea ( double a , double b ) { if ( a < 0 b < 0 ) return - 1 ; float A = ( float ) ( ( 3.14 * Math . Pow ( a , 2 ) * Math . Pow ( b , 2 ) ) / ( 4 * ( Math . Pow ( a , 2 ) + Math . Pow ( b , 2 ) ) ) ) ; return A ; }
float circlearea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; if ( l < b ) return ( float ) ( 3.14 * Math . Pow ( l / 2 , 2 ) ) ; else return ( float ) ( 3.14 * Math . Pow ( b / 2 , 2 ) ) ; }
int maxLines ( int n , int [ ] x1 , int [ ] y1 , int [ ] x2 , int [ ] y2 ) { HashSet < Double > s = new HashSet < Double > ( ) ; double slope ; for ( int i = 0 ; i < n ; ++ i ) { if ( x1 [ i ] == x2 [ i ] ) slope = int . MaxValue ; else slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 ; s . Add ( slope ) ; } return s . Count ; }
int squares ( int l , int b , int a ) { return ( int ) ( Math . Ceiling ( l / ( double ) a ) * Math . Ceiling ( b / ( double ) a ) ) ; }
int gcd ( int a , int b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int squarearea ( int l , int b ) { if ( l < 0 b < 0 ) return - 1 ; int n = ( l * b ) / gcd ( l , b ) ; return n * n ; }
double angle_triangle ( int x1 , int x2 , int x3 , int y1 , int y2 , int y3 , int z1 , int z2 , int z3 ) { int num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; double den = Math . Sqrt ( Math . Pow ( ( x2 - x1 ) , 2 ) + Math . Pow ( ( y2 - y1 ) , 2 ) + Math . Pow ( ( z2 - z1 ) , 2 ) ) * Math . Sqrt ( Math . Pow ( ( x3 - x1 ) , 2 ) + Math . Pow ( ( y3 - y1 ) , 2 ) + Math . Pow ( ( z3 - z1 ) , 2 ) ) ; double angle = Math . Acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; }
void is_partition_possible ( int n , int [ ] x , int [ ] y , int [ ] w ) { Dictionary < int , int > weight_at_x = new Dictionary < int , int > ( ) ; int max_x = ( int ) - 2e3 , min_x = ( int ) 2e3 ; for ( int i = 0 ; i < n ; i ++ ) { int new_x = x [ i ] - y [ i ] ; max_x = Math . Max ( max_x , new_x ) ; min_x = Math . Min ( min_x , new_x ) ; if ( weight_at_x . ContainsKey ( new_x ) ) { weight_at_x [ new_x ] += w [ i ] ; } else { weight_at_x . Add ( new_x , w [ i ] ) ; } } List < int > sum_till = new List < int > ( ) ; sum_till . Add ( 0 ) ; for ( int s = min_x ; s <= max_x ; s ++ ) { if ( ! weight_at_x . ContainsKey ( s ) ) { sum_till . Add ( sum_till [ sum_till . Count - 1 ] ) ; } else { sum_till . Add ( sum_till [ sum_till . Count - 1 ] + weight_at_x [ s ] ) ; } } int total_sum = sum_till [ sum_till . Count - 1 ] ; int partition_possible = 0 ; for ( int i = 1 ; i < sum_till . Count ; i ++ ) { if ( sum_till [ i ] == total_sum - sum_till [ i ] ) partition_possible = 1 ; if ( sum_till [ i - 1 ] == total_sum - sum_till [ i ] ) partition_possible = 1 ; } Console . WriteLine ( partition_possible == 1 ? "YES" : "NO" ) ; }
void makePolygon ( double a ) { double n = 360 / ( 180 - a ) ; if ( n == ( int ) n ) Console . WriteLine ( "YES" ) ; else Console . WriteLine ( "NO" ) ; }
bool LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; }
float area ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float area = ( float ) Math . Sqrt ( Math . Pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + Math . Pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + Math . Pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ) ; return area ; }
void equation_plane ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 , int x , int y , int z ) { int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int a = b1 * c2 - b2 * c1 ; int b = a2 * c1 - a1 * c2 ; int c = a1 * b2 - b1 * a2 ; int d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) Console . WriteLine ( "Coplanar" ) ; else Console . WriteLine ( "Not Coplanar" ) ; }
int solve ( int M , int N , int s ) { if ( N % s == 0 ) { N = N / s ; } else { N = ( N / s ) + 1 ; } if ( M % s == 0 ) { M = M / s ; } else { M = ( M / s ) + 1 ; } return M * N ; }
int max_intersection ( int [ ] center , int length , int k ) { Array . Sort ( center ) ; if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) { return 0 ; } else if ( center [ 2 ] - center [ 0 ] >= 2 * k ) { return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) ; } else return length ; }
void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = Math . Max ( x1 , x3 ) ; int y5 = Math . Max ( y1 , y3 ) ; int x6 = Math . Min ( x2 , x4 ) ; int y6 = Math . Min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { Console . WriteLine ( "No intersection" ) ; return ; } Console . Write ( "(" + x5 + ", " + y5 + ") " ) ; Console . Write ( "(" + x6 + ", " + y6 + ") " ) ; int x7 = x5 ; int y7 = y6 ; Console . Write ( "(" + x7 + ", " + y7 + ") " ) ; int x8 = x6 ; int y8 = y5 ; Console . Write ( "(" + x8 + ", " + y8 + ") " ) ; }
bool FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; }
void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { z1 = - d1 / c1 ; d = Math . Abs ( ( c2 * z1 + d2 ) ) / ( float ) ( Math . Sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; Console . Write ( "Perpendicular distance is " + d ) ; } else Console . Write ( "Planes are not parallel" ) ; }
void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = ( float ) Math . Sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = ( float ) Math . Sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = ( float ) 3.14159 ; float A = ( 180 / pi ) * ( float ) ( Math . Acos ( d ) ) ; Console . Write ( "Angle is " + A + " degree" ) ; }
double haversine ( double lat1 , double lon1 , double lat2 , double lon2 ) { double dLat = ( Math . PI / 180 ) * ( lat2 - lat1 ) ; double dLon = ( Math . PI / 180 ) * ( lon2 - lon1 ) ; lat1 = ( Math . PI / 180 ) * ( lat1 ) ; lat2 = ( Math . PI / 180 ) * ( lat2 ) ; double a = Math . Pow ( Math . Sin ( dLat / 2 ) , 2 ) + Math . Pow ( Math . Sin ( dLon / 2 ) , 2 ) * Math . Cos ( lat1 ) * Math . Cos ( lat2 ) ; double rad = 6371 ; double c = 2 * Math . Asin ( Math . Sqrt ( a ) ) ; return rad * c ; }
void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; Console . Write ( "equation of plane is " + a + "x + " + b + "y + " + c + "z + " + d + " = 0" ) ; }
float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }
int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
int countRectangles ( int radius ) { int rectangles = 0 ; int diameter = 2 * radius ; int diameterSquare = diameter * diameter ; for ( int a = 1 ; a < 2 * radius ; a ++ ) { for ( int b = 1 ; b < 2 * radius ; b ++ ) { int diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }
int simi_aaa ( int [ ] a1 , int [ ] a2 ) { Array . Sort ( a1 ) ; Array . Sort ( a2 ) ; if ( a1 [ 0 ] == a2 [ 0 ] && a1 [ 1 ] == a2 [ 1 ] && a1 [ 2 ] == a2 [ 2 ] ) return 1 ; else return 0 ; }
int simi_sas ( int [ ] s1 , int [ ] s2 , int [ ] a1 , int [ ] a2 ) { Array . Sort ( a1 ) ; Array . Sort ( a2 ) ; Array . Sort ( s1 ) ; Array . Sort ( s2 ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] ) { if ( a1 [ 2 ] == a2 [ 2 ] ) return 1 ; } if ( s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] ) { if ( a1 [ 0 ] == a2 [ 0 ] ) return 1 ; } if ( s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) { if ( a1 [ 1 ] == a2 [ 1 ] ) return 1 ; } return 0 ; }
int simi_sss ( int [ ] s1 , int [ ] s2 ) { Array . Sort ( s1 ) ; Array . Sort ( s2 ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] && s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] && s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) return 1 ; return 0 ; }
long centeredDodecagonal ( long n ) { return 6 * n * ( n - 1 ) + 1 ; }
int heptagonalNumber ( int n ) { return ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ; }
long centeredTridecagonalNum ( long n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; }
int pentagon_pyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; }
int pentagon_pyramidal ( int n ) { return n * n * ( n + 1 ) / 2 ; }
bool checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
int getQuadrant ( int X , int Y , int R , int PX , int PY ) { if ( PX == X && PY == Y ) return 0 ; int val = ( int ) Math . Pow ( ( PX - X ) , 2 ) + ( int ) Math . Pow ( ( PY - Y ) , 2 ) ; if ( val > Math . Pow ( R , 2 ) ) return - 1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; return 0 ; }
long center_pentadecagonal_num ( long n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
int icosidigonal_num ( int n ) { return ( 20 * n * n - 18 * n ) / 2 ; }
int center_nonadecagon_num ( int n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; }
int center_octadecagon_num ( int n ) { return 9 * n * n - 9 * n + 1 ; }
int hendecagonal_num ( int n ) { return ( 9 * n * n - 7 * n ) / 2 ; }
int centereddecagonalnum ( int n ) { return ( 5 * n * n + 5 * n + 1 ) ; }
void Ksmallest ( int x , int y , int k ) { if ( x == 0 && y == 0 ) return ; else if ( x == 0 ) { y -- ; Console . Write ( "V" ) ; Ksmallest ( x , y , k ) ; } else if ( y == 0 ) { x -- ; Console . Write ( "H" ) ; Ksmallest ( x , y , k ) ; } else { if ( factorial ( x - 1 , y ) > k ) { Console . Write ( "H" ) ; Ksmallest ( x - 1 , y , k ) ; } else { Console . Write ( "V" ) ; Ksmallest ( x , y - 1 , k - factorial ( x - 1 , y ) ) ; } } }
int nthEnneadecagonal ( int n ) { return ( 17 * n * n - 15 * n ) / 2 ; }
void inorder ( node root ) { if ( root == null ) { return ; } inorder ( root . left ) ; Console . Write ( root . data + " " ) ; inorder ( root . right ) ; }
int centered_pentagonal_Num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
void findPoint ( int x1 , int y1 , int x2 , int y2 ) { Console . WriteLine ( "(" + ( int ) ( 2 * x2 - x1 ) + "," + ( int ) ( 2 * y2 - y1 ) + " )" ) ; }
int pivotDis ( int x0 , int y0 , int x1 , int y1 ) { return ( int ) Math . Sqrt ( ( x1 - x0 ) * ( x1 - x0 ) + ( y1 - y0 ) * ( y1 - y0 ) ) ; }
int minDis ( int D , int r1 , int r2 ) { return Math . Max ( ( D - r1 - r2 ) , 0 ) ; }
int maxDis ( int D , int r1 , int r2 ) { return D + r1 + r2 ; }
double findPCSlope ( double m ) { return - 1.0 / m ; }
void otherEndPoint ( int x1 , int y1 , int m1 , int m2 ) { float x2 = ( float ) ( 2 * m1 - x1 ) ; float y2 = ( float ) ( 2 * m2 - y1 ) ; Console . WriteLine ( "x2 = " + x2 + ", " + "y2 = " + y2 ) ; }
bool isValid ( int [ ] arr , int i , int j , int m , int c ) { if ( i == j ) return false ; int lhs = arr [ j ] ; int rhs = m * arr [ i ] + c ; return ( lhs == rhs ) ; }
int findOrderedPoints ( int [ ] arr , int n , int m , int c ) { int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int firstIndex = i , secondIndex = j ; if ( isValid ( arr , firstIndex , secondIndex , m , c ) ) counter ++ ; } } return counter ; }
int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
int overlappingArea ( Point l1 , Point r1 , Point l2 , Point r2 ) { int area1 = Math . Abs ( l1 . x - r1 . x ) * Math . Abs ( l1 . y - r1 . y ) ; int area2 = Math . Abs ( l2 . x - r2 . x ) * Math . Abs ( l2 . y - r2 . y ) ; int x_dist = ( Math . Min ( r1 . x , r2 . x ) - Math . Max ( l1 . x , l2 . x ) ) ; int y_dist = ( Math . Min ( r1 . y , r2 . y ) - Math . Max ( l1 . y , l2 . y ) ) ; int areaI = 0 ; if ( x_dist > 0 && y_dist > 0 ) { areaI = x_dist * y_dist ; } return ( area1 + area2 - areaI ) ; }
bool checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
bool checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = ( int ) Math . Sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
float areacircumscribed ( float a ) { return ( a * a * ( float ) ( PI / 2 ) ) ; }
double surface_area_octahedron ( double side ) { return ( 2 * ( Math . Sqrt ( 3 ) ) * ( side * side ) ) ; }
int find_Area ( int r ) { return ( 2 * r * r ) ; }
int checkValidity ( int a , int b , int c ) { if ( a + b <= c a + c <= b b + c <= a ) return 0 ; else return 1 ; }
bool isRectangle ( int a , int b , int c , int d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; }
int nCk ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int count_Straightlines ( int n , int m ) { return ( nCk ( n , 2 ) - nCk ( m , 2 ) + 1 ) ; }
bool isBetween ( int a , int b , int c ) { return ( Math . Min ( a , b ) <= c && c <= Math . Max ( a , b ) ) ; }
bool canJoin ( int [ ] x , int [ ] y , int i , int j , int k ) { return ( x [ k ] == x [ i ] x [ k ] == x [ j ] ) && isBetween ( y [ i ] , y [ j ] , y [ k ] ) || ( y [ k ] == y [ i ] y [ k ] == y [ j ] ) && isBetween ( x [ i ] , x [ j ] , x [ k ] ) ; }
int countLineSegments ( int [ ] x , int [ ] y ) { if ( ( x [ 0 ] == x [ 1 ] && x [ 1 ] == x [ 2 ] ) || ( y [ 0 ] == y [ 1 ] && y [ 1 ] == y [ 2 ] ) ) return 1 ; else if ( canJoin ( x , y , 0 , 1 , 2 ) || canJoin ( x , y , 0 , 2 , 1 ) || canJoin ( x , y , 1 , 2 , 0 ) ) return 2 ; else return 3 ; }
float vol_of_dodecahedron ( int side ) { return ( float ) ( ( ( 15 + ( 7 * ( Math . Sqrt ( 5 ) ) ) ) / 4 ) * ( Math . Pow ( side , 3 ) ) ) ; }
int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }
float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . Sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
void midpoint ( int x1 , int x2 , int y1 , int y2 ) { Console . WriteLine ( ( x1 + x2 ) / 2 + " , " + ( y1 + y2 ) / 2 ) ; }
int contribution_height ( int current , int previous ) { return Math . Abs ( current - previous ) ; }
int surfaceArea ( int [ , ] A ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int up = 0 ; int left = 0 ; if ( i > 0 ) up = A [ i - 1 , j ] ; if ( j > 0 ) left = A [ i , j - 1 ] ; ans += contribution_height ( A [ i , j ] , up ) + contribution_height ( A [ i , j ] , left ) ; if ( i == N - 1 ) ans += A [ i , j ] ; if ( j == M - 1 ) ans += A [ i , j ] ; } } ans += N * M * 2 ; return ans ; }
double area_of_tetrahedron ( int side ) { return ( Math . Sqrt ( 3 ) * ( side * side ) ) ; }
double vol_tetra ( int side ) { double volume = ( Math . Pow ( side , 3 ) / ( 6 * Math . Sqrt ( 2 ) ) ) ; return volume ; }
void overflow ( int H , int r , int h , int N , int R ) { double tank_cap = 3.14 * r * r * H ; double water_vol = 3.14 * r * r * h ; double balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; double vol = water_vol + balls_vol ; if ( vol > tank_cap ) { Console . WriteLine ( "Overflow" ) ; } else { Console . WriteLine ( "Not in overflow state" ) ; } }
float volume ( int radius , int height ) { return ( ( 22 / 7 ) * radius * radius * height ) ; }
int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = Math . Max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }
float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = ( float ) 3.14 ; return ( float ) 1.33 * pi * r1 * r2 * r3 ; }
float slope ( float x1 , float y1 , float x2 , float y2 ) { if ( x1 == x2 ) return 1000000000 ; return ( y2 - y1 ) / ( x2 - x1 ) ; }
float cal_cos ( float n ) { float accuracy = 0.0001f , x1 ; float denominator , cosx , cosval ; n = n * ( 3.142f / 180.0f ) ; x1 = 1 ; cosx = x1 ; cosval = ( float ) Math . Cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . Abs ( cosval - cosx ) ) ; return cosx ; }
float third_side ( int a , int b , float c ) { float angle = cal_cos ( c ) ; return ( float ) Math . Sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; }
float volumeTriangular ( int a , int b , int h ) { float vol = ( float ) ( 0.1666 ) * a * b * h ; return vol ; }
float volumeSquare ( int b , int h ) { float vol = ( float ) ( 0.33 ) * b * b * h ; return vol ; }
float volumePentagonal ( int a , int b , int h ) { float vol = ( float ) ( 0.83 ) * a * b * h ; return vol ; }
float volumeHexagonal ( int a , int b , int h ) { float vol = ( float ) a * b * h ; return vol ; }
double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + Math . Sqrt ( 2 ) ) * side * side ) ; }
double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; }
double hexagonArea ( double s ) { return ( ( 3 * Math . Sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }
int findCommon ( int [ , ] mat ) { int [ ] column = new int [ M ] ; int min_row ; int i ; for ( i = 0 ; i < M ; i ++ ) column [ i ] = N - 1 ; min_row = 0 ; while ( column [ min_row ] >= 0 ) { for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i , column [ i ] ] < mat [ min_row , column [ min_row ] ] ) min_row = i ; } int eq_count = 0 ; for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i , column [ i ] ] > mat [ min_row , column [ min_row ] ] ) { if ( column [ i ] == 0 ) return - 1 ; column [ i ] -= 1 ; } else eq_count ++ ; } if ( eq_count == M ) return mat [ min_row , column [ min_row ] ] ; } return - 1 ; }
int Circumference ( int a ) { return 4 * a ; }
double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { Console . WriteLine ( "Angle cannot" + " be formed" ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) Console . WriteLine ( "Angle not possible" ) ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; Console . WriteLine ( sector ) ; } }
int findCommon ( int [ , ] mat ) { Dictionary < int , int > cnt = new Dictionary < int , int > ( ) ; int i , j ; for ( i = 0 ; i < M ; i ++ ) { if ( cnt . ContainsKey ( mat [ i , 0 ] ) ) { cnt [ mat [ i , 0 ] ] = cnt [ mat [ i , 0 ] ] + 1 ; } else { cnt . Add ( mat [ i , 0 ] , 1 ) ; } for ( j = 1 ; j < N ; j ++ ) { if ( mat [ i , j ] != mat [ i , j - 1 ] ) if ( cnt . ContainsKey ( mat [ i , j ] ) ) { cnt [ mat [ i , j ] ] = cnt [ mat [ i , j ] ] + 1 ; } else { cnt . Add ( mat [ i , j ] , 1 ) ; } } } foreach ( KeyValuePair < int , int > ele in cnt ) { if ( ele . Value == M ) return ele . Key ; } return - 1 ; }
double surfaceAreaCuboid ( double l , double h , double w ) { return ( 2 * l * w + 2 * w * h + 2 * l * h ) ; }
double surfaceCube ( double a ) { return ( 6 * a * a ) ; }
int minRadius ( int k , int [ ] x , int [ ] y , int n ) { int [ ] dis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Array . Sort ( dis ) ; return dis [ k - 1 ] ; }
int areaRectangle ( int a , int b ) { int area = a * b ; return area ; }
int perimeterRectangle ( int a , int b ) { int perimeter = 2 * ( a + b ) ; return perimeter ; }
int areaSquare ( int side ) { int area = side * side ; return area ; }
int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }
long minPerimeter ( int n ) { int l = ( int ) Math . Sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long row = n / l ; long perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
void checkCollision ( int a , int b , int c , int x , int y , int radius ) { double dist = ( Math . Abs ( a * x + b * y + c ) ) / Math . Sqrt ( a * a + b * b ) ; if ( radius == dist ) Console . WriteLine ( "Touch" ) ; else if ( radius > dist ) Console . WriteLine ( "Intersect" ) ; else Console . WriteLine ( "Outside" ) ; }
void possibleOrNot ( long a1 , long a2 , long b1 , long b2 , long c1 , long c2 ) { long dis1 = ( long ) Math . Pow ( b1 - a1 , 2 ) + ( long ) Math . Pow ( b2 - a2 , 2 ) ; long dis2 = ( long ) Math . Pow ( c1 - b1 , 2 ) + ( long ) Math . Pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) Console . Write ( "No" ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) Console . Write ( "No" ) ; else Console . Write ( "Yes" ) ; }
void replaceSurrounded ( char [ , ] mat ) { for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i , j ] == 'O' ) mat [ i , j ] = '-' ; for ( int i = 0 ; i < M ; i ++ ) if ( mat [ i , 0 ] == '-' ) floodFillUtil ( mat , i , 0 , '-' , 'O' ) ; for ( int i = 0 ; i < M ; i ++ ) if ( mat [ i , N - 1 ] == '-' ) floodFillUtil ( mat , i , N - 1 , '-' , 'O' ) ; for ( int i = 0 ; i < N ; i ++ ) if ( mat [ 0 , i ] == '-' ) floodFillUtil ( mat , 0 , i , '-' , 'O' ) ; for ( int i = 0 ; i < N ; i ++ ) if ( mat [ M - 1 , i ] == '-' ) floodFillUtil ( mat , M - 1 , i , '-' , 'O' ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i , j ] == '-' ) mat [ i , j ] = 'X' ; }
void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = Math . Sqrt ( Math . Pow ( x , 2 ) + Math . Pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) Console . WriteLine ( "Fits" ) ; else Console . WriteLine ( "Doesn't Fit" ) ; }
bool check ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 , int x , int y ) { float A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) + area ( x1 , y1 , x4 , y4 , x3 , y3 ) ; float A1 = area ( x , y , x1 , y1 , x2 , y2 ) ; float A2 = area ( x , y , x2 , y2 , x3 , y3 ) ; float A3 = area ( x , y , x3 , y3 , x4 , y4 ) ; float A4 = area ( x , y , x1 , y1 , x4 , y4 ) ; return ( A == A1 + A2 + A3 + A4 ) ; }
long rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }
int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return Math . Min ( c1 , c2 ) ; }
int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= Math . Sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
void isPolygonPossible ( int [ ] arr , int N ) { int limit = ( int ) Math . Sqrt ( N ) ; for ( int i = 1 ; i <= limit ; i ++ ) { if ( N % i == 0 ) { if ( checkPolygonWithMidpoints ( arr , N , i ) || checkPolygonWithMidpoints ( arr , N , ( N / i ) ) ) return ; } } Console . WriteLine ( "Not possible" ) ; }
double minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = Math . Sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . Ceiling ( d / ( 2 * r ) ) ; }
bool inside ( List < List < int > > A , List < int > p ) { List < int > mid = new List < int > ( ) { 0 , 0 } ; int n = A . Count ; for ( int i = 0 ; i < n ; i ++ ) { mid [ 0 ] += A [ i ] [ 0 ] ; mid [ 1 ] += A [ i ] [ 1 ] ; } for ( int i = 0 , j ; i < n ; i ++ ) { j = ( i + 1 ) % n ; int x1 = A [ i ] [ 0 ] * n , x2 = A [ j ] [ 0 ] * n ; int y1 = A [ i ] [ 1 ] * n , y2 = A [ j ] [ 1 ] * n ; int a1 = y1 - y2 ; int b1 = x2 - x1 ; int c1 = x1 * y2 - y1 * x2 ; int for_mid = a1 * mid [ 0 ] + b1 * mid [ 1 ] + c1 ; int for_p = a1 * p [ 0 ] * n + b1 * p [ 1 ] * n + c1 ; if ( for_mid * for_p < 0 ) return false ; } return true ; }
void addPoint ( List < List < int > > a , List < int > p ) { if ( inside ( a , p ) ) return ; int ind = 0 ; int n = a . Count ; for ( int i = 1 ; i < n ; i ++ ) { if ( sqDist ( p , a [ i ] ) < sqDist ( p , a [ ind ] ) ) { ind = i ; } } int up = ind ; while ( orientation ( p , a [ up ] , a [ ( up + 1 ) % n ] ) >= 0 ) up = ( up + 1 ) % n ; int low = ind ; while ( orientation ( p , a [ low ] , a [ ( n + low - 1 ) % n ] ) <= 0 ) low = ( n + low - 1 ) % n ; List < List < int > > ret = new List < List < int > > ( ) ; int curr = up ; ret . Add ( a [ curr ] ) ; while ( curr != low ) { curr = ( curr + 1 ) % n ; ret . Add ( a [ curr ] ) ; } ret . Add ( p ) ; a . Clear ( ) ; for ( int i = 0 ; i < ret . Count ; i ++ ) { a . Add ( ret [ i ] ) ; } }
int getDistance ( int x1 , int y1 , int x2 , int y2 ) { return ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ; }
int numberOfSquares ( int _base ) { _base = ( _base - 2 ) ; _base = _base / 2 ; return _base * ( _base + 1 ) / 2 ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
void preprocess ( int [ ] p , int [ ] x , int [ ] y , int n ) { for ( int i = 0 ; i < n ; i ++ ) p [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Array . Sort ( p ) ; }
int query ( int [ ] p , int n , int rad ) { int start = 0 , end = n - 1 ; while ( ( end - start ) > 1 ) { int mid = ( start + end ) / 2 ; double tp = Math . Sqrt ( p [ mid ] ) ; if ( tp > ( rad * 1.0 ) ) end = mid - 1 ; else start = mid ; } double tp1 = Math . Sqrt ( p [ start ] ) ; double tp2 = Math . Sqrt ( p [ end ] ) ; if ( tp1 > ( rad * 1.0 ) ) return 0 ; else if ( tp2 <= ( rad * 1.0 ) ) return end + 1 ; else return start + 1 ; }
double getArea ( double base1 , double hypotenuse ) { double height = Math . Sqrt ( hypotenuse * hypotenuse - base1 * base1 ) ; return 0.5 * base1 * height ; }
void printRightAngleTriangle ( int hypotenuse , int area ) { int hsquare = hypotenuse * hypotenuse ; double sideForMaxArea = Math . Sqrt ( hsquare / 2.0 ) ; double maxArea = getArea ( sideForMaxArea , hypotenuse ) ; if ( area > maxArea ) { Console . Write ( "Not possible" ) ; return ; } double low = 0.0 ; double high = sideForMaxArea ; double base1 = 0 ; while ( Math . Abs ( high - low ) > eps ) { base1 = ( low + high ) / 2.0 ; if ( getArea ( base1 , hypotenuse ) >= area ) { high = base1 ; } else { low = base1 ; } } double height = Math . Sqrt ( hsquare - base1 * base1 ) ; Console . WriteLine ( Math . Round ( base1 ) + " " + Math . Round ( height ) ) ; }
float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001f ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
int findMaximumHeight ( int N ) { int n = 1 + 8 * N ; int maxH = ( int ) ( - 1 + squareRoot ( n ) ) / 2 ; return maxH ; }
double polygonArea ( double [ ] X , double [ ] Y , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . Abs ( area / 2.0 ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int getCount ( Point p , Point q ) { if ( p . x == q . x ) return Math . Abs ( p . y - q . y ) - 1 ; if ( p . y == q . y ) return Math . Abs ( p . x - q . x ) - 1 ; return gcd ( Math . Abs ( p . x - q . x ) , Math . Abs ( p . y - q . y ) ) - 1 ; }
int getMinSteps ( int n ) { int [ ] table = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) table [ i ] = n - i ; for ( int i = n ; i >= 1 ; i -- ) { if ( ! ( i % 2 > 0 ) ) table [ i / 2 ] = Math . Min ( table [ i ] + 1 , table [ i / 2 ] ) ; if ( ! ( i % 3 > 0 ) ) table [ i / 3 ] = Math . Min ( table [ i ] + 1 , table [ i / 3 ] ) ; } return table [ 1 ] ; }
int distSq ( Point p , Point q ) { return ( p . x - q . x ) * ( p . x - q . x ) + ( p . y - q . y ) * ( p . y - q . y ) ; }
double polygonArea ( double [ ] X , double [ ] Y , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . Abs ( area / 2.0 ) ; }
void youngify ( int [ , ] mat , int i , int j ) { int downVal = ( i + 1 < N ) ? mat [ i + 1 , j ] : INF ; int rightVal = ( j + 1 < N ) ? mat [ i , j + 1 ] : INF ; if ( downVal == INF && rightVal == INF ) { return ; } if ( downVal < rightVal ) { mat [ i , j ] = downVal ; mat [ i + 1 , j ] = INF ; youngify ( mat , i + 1 , j ) ; } else { mat [ i , j ] = rightVal ; mat [ i , j + 1 ] = INF ; youngify ( mat , i , j + 1 ) ; } }
int extractMin ( int [ , ] mat ) { int ret = mat [ 0 , 0 ] ; mat [ 0 , 0 ] = INF ; youngify ( mat , 0 , 0 ) ; return ret ; }
void printSorted ( int [ , ] mat ) { Console . WriteLine ( "Elements of matrix in sorted order n" ) ; for ( int i = 0 ; i < N * N ; i ++ ) { Console . Write ( extractMin ( mat ) + " " ) ; } }
double f ( double x , int p , double num ) { return Math . Pow ( x , p ) - num ; }
double f_prime ( double x , int p ) { return p * Math . Pow ( x , p - 1 ) ; }
int minimumAdditionOperation ( int N ) { int count = 0 ; while ( N != 0 ) { if ( ( N & 1 ) == 1 ) { count ++ ; } N = N >> 1 ; } return count ; }
int minimumOperations ( int [ ] arr , int N ) { int mini = Int32 . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = arr [ i ] / 2 ; count ++ ; } if ( mini > count ) { mini = count ; } } return mini ; }
int minimumSizeArr ( int A , int B ) { int currXor = 0 ; int reminder = ( A - 1 ) % 4 ; if ( reminder == 0 ) currXor = A - 1 ; else if ( reminder == 1 ) currXor = 1 ; else if ( reminder == 2 ) currXor = A ; int minSize = A ; if ( currXor == B ) return minSize ; else if ( ( currXor ^ B ) == A ) return minSize + 2 ; else return minSize + 1 ; }
void modifiedSieve ( ) { for ( int i = 0 ; i < maxn ; i ++ ) gpf [ i ] = 0 ; gpf [ 0 ] = 0 ; gpf [ 1 ] = 1 ; for ( int i = 2 ; i < maxn ; i ++ ) { if ( gpf [ i ] > 0 ) continue ; for ( int j = i ; j < maxn ; j += i ) { gpf [ j ] = Math . Max ( i , gpf [ j ] ) ; } } }
int greatestValidInt ( int N ) { modifiedSieve ( ) ; for ( int i = N ; i > 0 ; i -- ) { if ( gpf [ i ] > Math . Sqrt ( i ) ) { return i ; } } return - 1 ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < ( int ) 1e4 + 2 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < ( int ) 1e4 + 2 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < ( int ) 1e4 + 2 ; i += p ) prime [ i ] = false ; } } }
int countMin ( int [ ] arr , int n ) { int cMinSwaps = 0 ; int cPrimeIndices = 0 ; int cPrimeNos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ i + 1 ] ) { cPrimeIndices ++ ; if ( prime [ arr [ i ] ] == false ) cMinSwaps ++ ; else cPrimeNos ++ ; } else if ( prime [ arr [ i ] ] ) { cPrimeNos ++ ; } } if ( cPrimeNos >= cPrimeIndices ) return cMinSwaps ; else return - 1 ; }
double subfactorial ( int N ) { double res = 0 , fact = 1 ; int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = fact * i ; if ( count % 2 == 0 ) res = res - ( 1 / fact ) ; else res = res + ( 1 / fact ) ; count ++ ; } return fact * ( 1 + res ) ; }
int minOperations ( int [ ] A , int [ ] B , int N ) { int cnt = 0 ; int i = 0 ; while ( i < N ) { int j = 0 ; while ( j < N && i < N ) { if ( B [ i ] == A [ j ] ) { i ++ ; } j ++ ; } cnt ++ ; } return cnt ; }
int countPairs ( int N ) { int res = 0 ; for ( int q = 1 ; q * q <= N ; q ++ ) { int maxP = Math . Min ( 2 * N - q , N / q ) ; if ( maxP < q ) continue ; int cnt = maxP - q + 1 ; res += ( cnt / 2 + ( cnt & 1 ) ) ; } return res ; }
void largestSubset ( int [ ] a , int N ) { int [ ] bit = new int [ 32 ] ; for ( int i = 0 ; i < N ; i ++ ) { int x = 31 ; while ( a [ i ] > 0 ) { if ( ( int ) ( a [ i ] & 1 ) == ( int ) 1 ) { bit [ x ] ++ ; } a [ i ] = a [ i ] >> 1 ; x -- ; } } int max = Int32 . MinValue ; for ( int i = 0 ; i < 32 ; i ++ ) { max = Math . Max ( max , bit [ i ] ) ; } Console . WriteLine ( max ) ; }
int countDistinctSums ( int N , int L , int R ) { int minSum = L * N ; int maxSum = R * N ; return maxSum - minSum + 1 ; }
void setSumtoZero ( double [ ] arr , int N ) { int [ ] A = new int [ N ] ; int sum = 0 ; int m = int . MinValue ; for ( int i = 0 ; i < N ; i ++ ) { sum += ( int ) Math . Ceiling ( arr [ i ] ) ; A [ i ] = ( int ) Math . Ceiling ( arr [ i ] ) ; } if ( sum > 0 ) { m = Math . Min ( sum , N ) ; for ( int i = 0 ; i < N && m > 0 ; i ++ ) { A [ i ] = ( int ) Math . Floor ( arr [ i ] ) ; if ( A [ i ] != Math . Floor ( arr [ i ] ) ) m -- ; } } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( A [ i ] + " " ) ; } }
int countDivisors ( int n ) { int divisors = 0 ; int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) { divisors ++ ; } } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) { divisors ++ ; } } return divisors ; }
int possibleTriplets ( int N ) { int count = 0 ; for ( int i = 1 ; i < N ; i ++ ) { count += countDivisors ( N - i ) ; } return count ; }
long convertToBase9 ( long n ) { long ans = 0 ; long a = 1 ; while ( n > 0 ) { ans += ( a * ( n % 9 ) ) ; a *= 10 ; n /= 9 ; } return ans ; }
long getNthnumber ( long base9 , long K ) { long ans = 0 ; long a = 1 ; while ( base9 > 0 ) { int cur = ( int ) ( base9 % 10 ) ; if ( cur >= K ) { ans += a * ( cur + 1 ) ; } else { ans += a * cur ; } base9 /= 10 ; a *= 10 ; } return ans ; }
int UniqueGeometricTerms ( int N , int a1 , int r1 , int a2 , int r2 ) { HashSet < int > S = new HashSet < int > ( ) ; int p1 = a1 ; for ( int i = 0 ; i < N ; i ++ ) { S . Add ( p1 ) ; p1 = ( p1 * r1 ) ; } int p2 = a2 ; for ( int i = 0 ; i < N ; i ++ ) { S . Add ( p2 ) ; p2 = ( p2 * r2 ) ; } return S . Count ; }
void nearestLeft ( int [ ] arr , int N , int [ ] steps ) { int L = - N ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { L = - ( N - i ) ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { L = i ; } steps [ i ] = i - L ; } }
int findSum ( int [ ] arr , int N , int M , int K ) { int [ ] steps = new int [ N ] ; int sum = accumulate ( arr , 0 , N ) ; if ( sum == 0 ) { return 0 ; } nearestLeft ( arr , N , steps ) ; nearestRight ( arr , N , steps ) ; for ( int i = 0 ; i < N ; i ++ ) sum += 2 * K * Math . Max ( 0 , M - steps [ i ] ) ; return sum ; }
int countPairs ( int L , int R ) { int cntPair = 0 ; for ( int a = L ; a <= R ; a ++ ) { for ( int b = a + 1 ; b <= R ; b ++ ) { int x = getProduct ( a ) ; int y = getProduct ( b ) ; if ( x != 0 && y != 0 && ( a * y ) == ( b * x ) ) { cntPair ++ ; } } } return cntPair ; }
int maxSum ( int [ , ] matrix ) { int r = matrix . GetLength ( 0 ) ; int c = matrix . GetLength ( 1 ) ; int sum = 0 ; int mini = int . MaxValue ; int count = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { int k = matrix [ i , j ] ; mini = Math . Min ( mini , Math . Abs ( k ) ) ; if ( k < 0 ) count ++ ; sum += Math . Abs ( k ) ; } } if ( count % 2 == 0 ) { return sum ; } else { return ( sum - 2 * mini ) ; } }
int highestPowerof2 ( int n ) { int p = ( int ) Math . Floor ( Math . Log ( n ) / Math . Log ( 2.0 ) ) ; if ( p % 2 == 0 ) p -= 1 ; int result = ( int ) ( Math . Pow ( 2 , p ) ) ; return result ; }
int minStep ( int N , int X ) { if ( N % 2 != 0 && X == 0 ) return - 1 ; int size = 0 ; while ( X < N ) { N -= highestPowerof2 ( N ) ; size += 1 ; } if ( N != 0 ) size += 1 ; return size ; }
void transpose ( int [ , ] A , int [ , ] B ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i , j ] = A [ j , i ] ; }
int canPossibleReplacement ( int N , int [ ] arr ) { int S = 0 ; int i ; for ( i = 0 ; i < arr . Length ; i ++ ) S += arr [ i ] ; int P = 1 ; for ( i = 0 ; i < arr . Length ; i ++ ) { P *= i ; } foreach ( int x in arr ) { int y = ( S - x ) / ( P / x - 1 ) ; if ( ( S - x + y ) == ( P * y ) / x ) return 1 ; } return 0 ; }
int positionAfterKJumps ( int X , int Y , int K ) { int addY = Y * ( K / 2 ) ; int reduceX = - 1 * X * ( K / 2 + K % 2 ) ; return addY + reduceX ; }
void predictTheWinner ( int K , int N ) { if ( N % ( K + 1 ) == 0 ) Console . WriteLine ( "Bob" ) ; else Console . WriteLine ( "Alice" ) ; }
void countTriplets ( int size , int queries , int [ ] arr , int [ , ] Q ) { int [ ] arr_even = new int [ size + 1 ] ; int [ ] arr_odd = new int [ size + 1 ] ; int even = 0 ; int odd = 0 ; arr_even [ 0 ] = 0 ; arr_odd [ 0 ] = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd ++ ; } else { even ++ ; } arr_even [ i + 1 ] = even ; arr_odd [ i + 1 ] = odd ; } for ( int i = 0 ; i < queries ; i ++ ) { int l = Q [ i , 0 ] , r = Q [ i , 1 ] ; odd = arr_odd [ r ] - arr_odd [ l - 1 ] ; even = arr_even [ r ] - arr_even [ l - 1 ] ; int ans = ( even * ( even - 1 ) * ( even - 2 ) ) / 6 + ( odd * ( odd - 1 ) / 2 ) * even ; Console . Write ( ans + " " ) ; } }
void transpose ( int [ , ] A ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { int temp = A [ i , j ] ; A [ i , j ] = A [ j , i ] ; A [ j , i ] = temp ; } }
int findMaxK ( int N ) { int K = N ; for ( int i = N - 1 ; i >= 0 ; i -- ) { K &= i ; if ( K == 0 ) { return i ; } } return 0 ; }
int countPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ j ] % arr [ i ] == 0 ) && ( j + 1 ) % ( i + 1 ) == 0 && ( arr [ j ] / arr [ i ] == ( j + 1 ) / ( i + 1 ) ) ) { count ++ ; } } } return count ; }
int smallestMaximum ( int N , int K ) { int sum = ( ( N + K - 1 ) / K ) * K ; if ( sum % N != 0 ) return ( sum / N ) + 1 ; else return sum / N ; }
int findMinMax ( int [ ] a ) { int min_val = 1000000000 ; for ( int i = 1 ; i < a . Length ; ++ i ) { min_val = Math . Min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; }
void add ( int [ , ] A , int [ , ] B , int [ , ] C ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i , j ] = A [ i , j ] + B [ i , j ] ; }
int nCr ( int n , int r , int [ ] f ) { if ( n < r ) { return 0 ; } return f [ n ] / ( f [ r ] * f [ n - r ] ) ; }
int Min_sum ( int [ ] arr , int N ) { int min_sum = 1000000 , maxGcd = 1 ; for ( int i = 0 ; i < N ; i ++ ) { int gcd ; if ( i == 0 ) gcd = arr [ 1 ] ; else { gcd = arr [ i - 1 ] ; } for ( int j = 0 ; j < N ; j ++ ) { if ( j != i ) gcd = gcdOfTwoNos ( gcd , arr [ j ] ) ; } if ( gcd > maxGcd ) maxGcd = gcd ; } return maxGcd ; }
void performQuery ( int [ ] arr , int [ , ] Q ) { for ( int i = 0 ; i < Q . Length ; i ++ ) { int or = 0 ; int x = Q [ i , 0 ] ; arr [ x - 1 ] = Q [ i , 1 ] ; for ( int j = 0 ; j < arr . Length ; j ++ ) { or = or | arr [ j ] ; } Console . Write ( or + " " ) ; } }
void subtract ( int [ ] [ ] A , int [ ] [ ] B , int [ , ] C ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { C [ i , j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } } }
int countOddIntegers ( int [ ] arr , int N ) { int [ ] Fact = new int [ N ] ; Fact [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { Fact [ i ] = i * Fact [ i - 1 ] ; } int [ ] freq = new int [ 10 ] ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } int ans = 0 ; for ( int i = 1 ; i <= 9 ; i += 2 ) { if ( freq [ i ] == 0 ) continue ; freq [ i ] -- ; for ( int j = 1 ; j <= 9 ; j ++ ) { int cur_ans = 0 ; if ( freq [ j ] == 0 ) { continue ; } freq [ j ] -- ; cur_ans = Fact [ N - 2 ] ; for ( int k = 0 ; k <= 9 ; k ++ ) { cur_ans = cur_ans / Fact [ freq [ k ] ] ; } ans += cur_ans ; freq [ j ] ++ ; } freq [ i ] ++ ; } return ans ; }
int intCount ( int X , int K ) { int ans = 0 ; for ( int z = 0 ; z < Math . Pow ( 10 , K ) ; z += ( ( int ) Math . Pow ( 10 , K ) - 1 ) / 9 ) { if ( z > X ) break ; ans += ( ( X - z ) / ( int ) Math . Pow ( 10 , K ) + 1 ) ; } return ans ; }
int intCountInRange ( int L , int R , int K ) { return ( intCount ( R , K ) - intCount ( L - 1 , K ) ) ; }
void findSum ( TreeNode root , int target , int K ) { sum = 0 ; kDistanceSum ( root , target , K ) ; Console . Write ( sum ) ; }
int CountPair ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = arr [ i ] + sumOfDigits ( arr [ i ] ) ; if ( mp . ContainsKey ( val ) ) mp [ val ] ++ ; else mp . Add ( val , 1 ) ; } int count = 0 ; foreach ( KeyValuePair < int , int > entry in mp ) { int val = entry . Key ; int times = entry . Value ; count += ( ( times * ( times - 1 ) ) / 2 ) ; } return count ; }
bool isValid ( int x , int y1 , int y2 ) { return ( x >= 0 && x < R && y1 >= 0 && y1 < C && y2 >= 0 && y2 < C ) ; }
int getMaxUtil ( int [ , ] arr , int [ , , ] mem , int x , int y1 , int y2 ) { if ( ! isValid ( x , y1 , y2 ) ) return int . MinValue ; if ( x == R - 1 && y1 == 0 && y2 == C - 1 ) return ( y1 == y2 ) ? arr [ x , y1 ] : arr [ x , y1 ] + arr [ x , y2 ] ; if ( x == R - 1 ) return int . MinValue ; if ( mem [ x , y1 , y2 ] != - 1 ) return mem [ x , y1 , y2 ] ; int ans = int . MinValue ; int temp = ( y1 == y2 ) ? arr [ x , y1 ] : arr [ x , y1 ] + arr [ x , y2 ] ; ans = Math . Max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 - 1 ) ) ; ans = Math . Max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 + 1 ) ) ; ans = Math . Max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 ) ) ; ans = Math . Max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 ) ) ; ans = Math . Max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 - 1 ) ) ; ans = Math . Max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 + 1 ) ) ; ans = Math . Max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 ) ) ; ans = Math . Max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 - 1 ) ) ; ans = Math . Max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 + 1 ) ) ; return ( mem [ x , y1 , y2 ] = ans ) ; }
int geMaxCollection ( int [ , ] arr ) { int [ , , ] mem = new int [ R , C , C ] ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { for ( int l = 0 ; l < C ; l ++ ) mem [ i , j , l ] = - 1 ; } } return getMaxUtil ( arr , mem , 0 , 0 , C - 1 ) ; }
void printFactors ( int n ) { for ( int i = 2 ; i <= ( int ) Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { int d1 = i , d2 = n ; while ( d2 % d1 == 0 ) { d2 = d2 / d1 ; } if ( d1 > 1 && d2 > 1 ) { Console . Write ( d1 + ", " + d2 ) ; return ; } } } Console . Write ( - 1 ) ; }
int countTriplets ( int [ ] arr , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; else even ++ ; } int c1 = odd * ( even * ( even - 1 ) ) / 2 ; int c2 = ( odd * ( odd - 1 ) * ( odd - 2 ) ) / 6 ; return c1 + c2 ; }
int maxUniqueElements ( int [ ] Arr , int N ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( Arr [ i ] ) ) { mp [ Arr [ i ] ] += 1 ; } else { mp [ Arr [ i ] ] = 1 ; } } int cnt = 0 ; foreach ( KeyValuePair < int , int > entry in mp ) { if ( ( entry . Value ) % 2 == 0 ) { cnt ++ ; } } int ans = mp . Count ; if ( cnt % 2 == 1 ) { ans -- ; } return ans ; }
int countCells ( int n , int m , int s ) { int mx1 = - 1 ; int cont1 = 0 ; for ( int i = 0 ; i < s && i < n ; ++ i ) { int aux = ( n - ( i + 1 ) ) / s + 1 ; if ( aux > mx1 ) { mx1 = cont1 = aux ; } else if ( aux == mx1 ) cont1 += aux ; } int mx2 = - 1 ; int cont2 = 0 ; for ( int i = 0 ; i < s && i < m ; ++ i ) { int aux = ( m - ( i + 1 ) ) / s + 1 ; if ( aux > mx2 ) mx2 = cont2 = aux ; else if ( aux == mx2 ) cont2 += aux ; } return ( cont1 * cont2 ) ; }
void build_tree ( int [ ] b , int [ ] seg_tree , int l , int r , int vertex ) { if ( l == r ) { seg_tree [ vertex ] = b [ l ] ; return ; } int mid = ( l + r ) / 2 ; build_tree ( b , seg_tree , l , mid , 2 * vertex ) ; build_tree ( b , seg_tree , mid + 1 , r , 2 * vertex + 1 ) ; seg_tree [ vertex ] = __gcd ( seg_tree [ 2 * vertex ] , seg_tree [ 2 * vertex + 1 ] ) ; }
int range_gcd ( int [ ] seg_tree , int v , int tl , int tr , int l , int r ) { if ( l > r ) return 0 ; if ( l == tl && r == tr ) return seg_tree [ v ] ; int tm = ( tl + tr ) / 2 ; return __gcd ( range_gcd ( seg_tree , 2 * v , tl , tm , l , Math . Min ( tm , r ) ) , range_gcd ( seg_tree , 2 * v + 1 , tm + 1 , tr , Math . Max ( tm + 1 , l ) , r ) ) ; }
void maxSubarrayLen ( int [ ] arr , int n ) { int [ ] seg_tree = new int [ 4 * ( n ) + 1 ] ; build_tree ( arr , seg_tree , 0 , n - 1 , 1 ) ; int maxLen = 0 ; int l = 0 , r = 0 ; while ( r < n && l < n ) { if ( range_gcd ( seg_tree , 1 , 0 , n - 1 , l , r ) == 1 ) { l ++ ; } maxLen = Math . Max ( maxLen , r - l + 1 ) ; r ++ ; } Console . Write ( maxLen ) ; }
bool can_empty ( int a , int b , int c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { int m = Math . Min ( a , Math . Min ( b , c ) ) ; if ( m < ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
int countTotalPairs ( int N , int K ) { if ( K == 0 ) { return N * N ; } int ans = 0 ; for ( int b = K + 1 ; b <= N ; b ++ ) { ans += ( N / b ) * ( b - K ) ; ans += Math . Max ( N % b - K + 1 , 0 ) ; } return ans ; }
void maxFrequencySubarrayUtil ( int [ ] A , int N , int M ) { int i = 0 ; Dictionary < int , int > m = new Dictionary < int , int > ( ) ; int val = 0 ; for ( ; i < M ; i ++ ) { if ( m . ContainsKey ( A [ i ] ) ) { val = m [ A [ i ] ] ; m . Remove ( A [ i ] ) ; m . Add ( A [ i ] , val + 1 ) ; } else { m . Add ( A [ i ] , 1 ) ; } val = Math . Max ( val , m [ A [ i ] ] ) ; } Console . Write ( val + " " ) ; for ( i = M ; i < N ; i ++ ) { if ( m . ContainsKey ( i - M ) ) { val = i - M ; m . Remove ( i - M ) ; m . Add ( i - M , val - 1 ) ; } if ( m . ContainsKey ( A [ i ] ) ) { val = m [ A [ i ] ] ; m . Remove ( A [ i ] ) ; m . Add ( A [ i ] , val + 1 ) ; } else { m . Add ( A [ i ] , 1 ) ; } val = Math . Max ( val , m [ A [ i ] ] ) ; val = 0 ; foreach ( KeyValuePair < int , int > x in m ) { val = Math . Max ( val , x . Value ) ; } Console . Write ( val + " " ) ; } }
int smallest ( int k , int d ) { int cnt = 1 ; int m = d % k ; int [ ] v = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) v [ i ] = 0 ; v [ m ] = 1 ; while ( true ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return - 1 ; v [ m ] = 1 ; cnt ++ ; } }
int getPairsCount ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && Math . Abs ( arr [ i ] - arr [ j ] ) >= Math . Min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
int minSteps ( int N ) { int count = 1 , res = 0 ; for ( int i = 1 ; i <= N ; i += count ) { res = Math . Max ( res , count ) ; count ++ ; } return res ; }
int countReachablePoints ( int X , int Y , int L , int R ) { int [ ] diff_arr = new int [ 100000 ] ; int count = 0 ; diff_arr [ X ] = 1 ; diff_arr [ X + 1 ] = - 1 ; for ( int i = X ; i <= Y ; i ++ ) { diff_arr [ i ] += diff_arr [ i - 1 ] ; if ( diff_arr [ i ] >= 1 ) { diff_arr [ i + L ] += 1 ; diff_arr [ i + R + 1 ] -= 1 ; count ++ ; } } return count ; }
int minimumSubarray ( int [ ] arr , int n , int m ) { int [ ] mapu = new int [ m + 1 ] ; Array . Fill ( mapu , 0 ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mapu [ arr [ i ] ] ++ ; if ( mapu [ arr [ i ] ] == ( n / m ) + 1 ) c ++ ; } if ( c == 0 ) return 0 ; int ans = n ; int l = 0 , r = 0 ; while ( r < n ) { if ( -- mapu [ arr [ r ] ] == ( n / m ) ) c -- ; if ( c == 0 ) { while ( l <= r && c == 0 ) { ans = Math . Min ( ans , r - l + 1 ) ; if ( ++ mapu [ arr [ l ] ] > ( n / m ) ) c ++ ; l ++ ; } } r ++ ; } return ans ; }
void findAandB ( int N ) { int K = ( int ) ( Math . Log ( N ) / Math . Log ( 2 ) ) ; int B = ( 1 << K ) ; int A = B ^ N ; Console . Write ( A + " " + B ) ; }
int pathCountRec ( int [ ] [ ] mat , int m , int n , int k ) { if ( m < 0 n < 0 ) { return 0 ; } if ( m == 0 && n == 0 && ( k == mat [ m ] [ n ] ) ) { return 1 ; } return pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; }
int pathCount ( int [ ] [ ] mat , int k ) { return pathCountRec ( mat , R - 1 , C - 1 , k ) ; }
int minDistance ( int [ ] start , int [ ] end , int n , int d ) { int left = Int32 . MinValue ; int right = Int32 . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { left = Math . Max ( left , start [ i ] ) ; right = Math . Min ( right , end [ i ] ) ; } if ( left > right ) return - 1 ; if ( d >= left && d <= right ) return 0 ; if ( d < left ) return ( left - d ) ; if ( d > right ) return ( d - right ) ; return - 1 ; }
int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; }
int order ( int num ) { int count = 0 ; while ( num > 0 ) { count ++ ; num = num / 10 ; } return count ; }
int isArmstrong ( int N ) { int r = order ( N ) ; int temp = N , sum = 0 ; while ( temp > 0 ) { int d = temp % 10 ; sum += power ( d , r ) ; temp = temp / 10 ; } if ( sum == N ) return 1 ; return 0 ; }
int maxSum ( int [ ] arr , int N , int K ) { if ( N < K ) { return - 1 ; } int res = 0 ; for ( int i = 0 ; i < K ; i ++ ) { res += arr [ i ] ; } int curr_sum = res ; for ( int i = K ; i < N ; i ++ ) { curr_sum += arr [ i ] - arr [ i - K ] ; res = Math . Max ( res , curr_sum ) ; } return res ; }
int maxArmstrong ( int [ ] arr , int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = isArmstrong ( arr [ i ] ) ; } return maxSum ( arr , N , K ) ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
void printArr ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int minDifference = 1000000007 ; int minIndex = - 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( minDifference > Math . Abs ( arr [ i ] - arr [ i - 1 ] ) ) { minDifference = Math . Abs ( arr [ i ] - arr [ i - 1 ] ) ; minIndex = i - 1 ; } } int [ ] Arr = new int [ n ] ; Arr [ 0 ] = arr [ minIndex ] ; Arr [ n - 1 ] = arr [ minIndex + 1 ] ; int pos = 1 ; for ( int i = minIndex + 2 ; i < n ; i ++ ) { Arr [ pos ++ ] = arr [ i ] ; } for ( int i = 0 ; i < minIndex ; i ++ ) { Arr [ pos ++ ] = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( Arr [ i ] + " " ) ; } }
void findValuesOfK ( int g ) { int count = 0 ; for ( int i = 1 ; i * i <= g ; i ++ ) { if ( g % i == 0 ) { if ( i != g / i ) { if ( i % 2 == 1 ) { count ++ ; } if ( ( g / i ) % 2 == 1 ) { count ++ ; } } else if ( i % 2 == 1 ) { count ++ ; } } } Console . WriteLine ( count ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { res = res * i ; } return res ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
void countPairs ( int [ ] arr , int N ) { int answer = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] + arr [ j ] == i + j ) { answer ++ ; } } } Console . Write ( answer ) ; }
int pathCountDPRecDP ( int [ , ] mat , int m , int n , int k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m , n ] ? 1 : 0 ) ; if ( dp [ m , n , k ] != - 1 ) return dp [ m , n , k ] ; dp [ m , n , k ] = pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m , n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m , n ] ) ; return dp [ m , n , k ] ; }
void checkDistribution ( int R , int B , int D ) { if ( Math . Max ( R , B ) <= Math . Min ( R , B ) * ( D + 1 ) ) { Console . WriteLine ( "Yes" ) ; } else { Console . WriteLine ( "No" ) ; } }
int itemType ( int n ) { int count = 0 ; for ( int day = 1 ; ; day ++ ) { for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } }
List < pair > primeFactor ( int N ) { List < pair > v = new List < pair > ( ) ; int count = 0 ; while ( ( N % 2 ) == 0 ) { N >>= 1 ; count ++ ; } if ( count != 0 ) v . Add ( new pair ( 2 , count ) ) ; for ( int i = 3 ; i <= Math . Sqrt ( N ) ; i += 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } if ( count != 0 ) { v . Add ( new pair ( i , count ) ) ; } } if ( N > 2 ) v . Add ( new pair ( N , 1 ) ) ; return v ; }
long ABS ( long x ) { return Math . Max ( x , - x ) ; }
bool isvalid ( int i , int j ) { if ( i < 0 j < 0 >= R j >= C ) return false ; return true ; }
int getLenUtil ( char [ , ] mat , int i , int j , char prev ) { if ( ! isvalid ( i , j ) || ! isadjacent ( prev , mat [ i , j ] ) ) return 0 ; if ( dp [ i , j ] != - 1 ) return dp [ i , j ] ; int ans = 0 ; for ( int k = 0 ; k < 8 ; k ++ ) ans = Math . Max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , mat [ i , j ] ) ) ; return dp [ i , j ] = ans ; }
string BaseConversion ( int N ) { string s = "" ; while ( N != 0 ) { if ( N % 2 == 0 ) { s = "0" + s ; } else { s = "1" + s ; N -- ; } N /= - 2 ; } if ( s == "" ) { s = "0" ; } return s ; }
void check ( int N ) { int twos = 0 , fives = 0 ; while ( N % 2 == 0 ) { N /= 2 ; twos ++ ; } while ( N % 5 == 0 ) { N /= 5 ; fives ++ ; } if ( N == 1 && twos <= fives ) { Console . Write ( 2 * fives - twos ) ; } else { Console . Write ( - 1 ) ; } }
string isMakeZero ( int [ ] arr , int N , int K ) { Dictionary < int , int > MP = new Dictionary < int , int > ( ) ; List < int > V = new List < int > ( ) ; int X = 1 ; int i ; while ( X > 0 && X < Int32 . MaxValue ) { V . Add ( X ) ; X *= K ; } for ( i = 0 ; i < N ; i ++ ) { for ( int j = V . Count - 1 ; j >= 0 ; j -- ) { if ( MP . ContainsKey ( V [ j ] ) == false && V [ j ] <= arr [ i ] ) { arr [ i ] -= V [ j ] ; MP [ V [ j ] ] = 1 ; } } if ( arr [ i ] != 0 ) break ; } if ( i < N ) return "No" ; else return "Yes" ; }
int countOperations ( int N , int M ) { bool [ ] visited = new bool [ 100001 ] ; Queue Q = new Queue ( ) ; Q . Enqueue ( new Tuple < int , int > ( N , 0 ) ) ; visited [ N ] = true ; while ( Q . Count > 0 ) { int aux = ( ( Tuple < int , int > ) ( Q . Peek ( ) ) ) . Item1 ; int cont = ( ( Tuple < int , int > ) ( Q . Peek ( ) ) ) . Item2 ; Q . Dequeue ( ) ; if ( aux == M ) return cont ; for ( int i = 2 ; i * i <= aux ; i ++ ) if ( aux % i == 0 ) { if ( aux + i <= M && ! visited [ aux + i ] ) { Q . Enqueue ( new Tuple < int , int > ( aux + i , cont + 1 ) ) ; visited [ aux + i ] = true ; } if ( aux + aux / i <= M && ! visited [ aux + aux / i ] ) { Q . Enqueue ( new Tuple < int , int > ( aux + aux / i , cont + 1 ) ) ; visited [ aux + aux / i ] = true ; } } } return - 1 ; }
double Avgdifference ( double [ ] arr , int N , int K ) { double min = 1000000 , max = - 1 ; for ( int i = 0 ; i <= N - K ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < K ; j ++ ) { sum += arr [ i + j ] ; } if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
double Avgdifference ( double [ ] arr , int N , int K ) { double sum = 0 ; for ( int i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; double min = sum ; double max = sum ; for ( int i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
int minimumElement ( int [ ] arr , int N , int K ) { int minElement = arr [ 0 ] ; for ( int i = 0 ; i < N ; ++ i ) { minElement = Math . Min ( minElement , arr [ i ] ) ; } int reqOperations = 0 ; for ( int i = 0 ; i < N ; ++ i ) { reqOperations += arr [ i ] - minElement ; } if ( reqOperations < K ) { K -= reqOperations ; minElement -= ( K + N - 1 ) / N ; } return minElement ; }
List < string > FractionSplit ( long n , long d ) { List < string > UnitFactions = new List < string > ( ) ; while ( n > 0 ) { long x = ( d + n - 1 ) / n ; string s = "1/" + x . ToString ( ) ; UnitFactions . Add ( s ) ; n = n * x - d ; d = d * x ; } return UnitFactions ; }
void findPermutation ( int N ) { int [ ] arr = new int [ N ] ; int temp ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = i + 1 ; } for ( int i = 1 ; i < N ; i += 2 ) { temp = arr [ i ] ; arr [ i ] = arr [ i - 1 ] ; arr [ i - 1 ] = temp ; } if ( N % 2 == 1 && N > 1 ) { temp = arr [ N - 1 ] ; arr [ N - 1 ] = arr [ N - 2 ] ; arr [ N - 2 ] = temp ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
void rangeSum ( int [ ] arr , int N , int L , int R ) { int sum = 0 ; for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } Console . Write ( sum ) ; }
void rangeSum ( int [ ] arr , int N , int L , int R ) { int [ ] prefix = new int [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } int leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; int rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; Console . Write ( rightsum - leftsum ) ; }
void addAP ( int [ ] A , int Q , int [ , ] operations ) { for ( int j = 0 ; j < 2 ; ++ j ) { int L = operations [ j , 0 ] , R = operations [ j , 1 ] , a = operations [ j , 2 ] , d = operations [ j , 3 ] ; int curr = a ; for ( int i = L - 1 ; i < R ; i ++ ) { A [ i ] += curr ; curr += d ; } } for ( int i = 0 ; i < 4 ; ++ i ) Console . Write ( A [ i ] + " " ) ; }
void maximizeNumber ( int N , int K ) { String s = N . ToString ( ) ; int L = s . Length ; string result = "" ; int i = 0 ; while ( ( i < L ) && ( K <= ( ( int ) s [ i ] - ( int ) '0' ) ) ) { result += ( s [ i ] ) ; ++ i ; } result += ( ( char ) ( K + ( int ) '0' ) ) ; while ( i < L ) { result += ( s [ i ] ) ; ++ i ; } Console . Write ( result ) ; }
void countArrays ( int N , int K ) { Console . WriteLine ( ( int ) ( power ( N , K ) ) ) ; }
void minimumDistance ( int [ ] arr , int N ) { int ind = 0 ; int prev = arr [ ind ] ; int s = arr . Length ; for ( int i = 0 ; i < N ; i ++ ) { int distance = Int32 . MaxValue ; if ( i < arr [ 0 ] ) { distance = arr [ 0 ] - i ; } else if ( i >= prev && ind + 1 < s && i <= arr [ ind + 1 ] ) { distance = Math . Min ( i - prev , arr [ ind + 1 ] - i ) ; if ( i == arr [ ind + 1 ] ) { distance = 0 ; prev = arr [ ind + 1 ] ; ind ++ ; } } else { distance = i - prev ; } Console . Write ( distance + " " ) ; } }
int countOfPairs ( int [ ] arr , int N , int X ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( ( arr [ i ] ^ arr [ j ] ) & X ) == 0 ) count ++ ; } } return count ; }
int countOfPairs ( int [ ] arr , int N , int X ) { int count = 0 ; Dictionary < int , int > M = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( M . ContainsKey ( arr [ i ] & X ) ) M [ ( arr [ i ] & X ) ] ++ ; else M . Add ( arr [ i ] & X , 1 ) ; } foreach ( KeyValuePair < int , int > entry in M ) { int p = entry . Value ; count += p * ( p - 1 ) / 2 ; } return count ; }
int ConcatenateArr ( int [ ] arr , int N ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { int l = ( int ) Math . Floor ( Math . Log10 ( arr [ i ] ) + 1 ) ; ans = ans * ( int ) Math . Pow ( 10 , l ) ; ans += arr [ i ] ; } return ans ; }
int countXor ( int N ) { int cnt = ( int ) N / 2 + 1 ; return cnt ; }
int DistRecursion ( string S , int i , int dist ) { if ( i == S . Length ) return Math . Abs ( dist ) ; if ( S [ i ] == 'L' ) return DistRecursion ( S , i + 1 , dist - 1 ) ; if ( S [ i ] == 'R' ) return DistRecursion ( S , i + 1 , dist + 1 ) ; return Math . Max ( DistRecursion ( S , i + 1 , dist - 1 ) , DistRecursion ( S , i + 1 , dist + 1 ) ) ; }
int maxDistance ( string S ) { return DistRecursion ( S , 0 , 0 ) ; }
int isPerfect ( long N ) { long sum = 1 ; for ( long i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( i * i != N ) sum = sum + i + N / i ; else sum = sum + i ; } } if ( sum == N && N != 1 ) return 1 ; return 0 ; }
void Query ( int [ , ] arr , int N ) { int [ ] prefix = new int [ MAX + 1 ] ; for ( int i = 2 ; i <= MAX ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + isPerfect ( i ) ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( prefix [ arr [ i , 1 ] ] - prefix [ arr [ i , 0 ] - 1 ] + " " ) ; } }
int ExpoFactorial ( int N ) { int res = 1 ; int mod = 1000000007 ; for ( int i = 2 ; i < N + 1 ; i ++ ) res = ( int ) Math . Pow ( i , res ) % mod ; return res ; }
int maxSubArraySumRepeated ( int [ ] arr , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int curr = arr [ 0 ] ; int ans = arr [ 0 ] ; if ( K == 1 ) { for ( int i = 1 ; i < N ; i ++ ) { curr = Math . Max ( arr [ i ] , curr + arr [ i ] ) ; ans = Math . Max ( ans , curr ) ; } return ans ; } List < int > V = new List < int > ( ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { V . Add ( arr [ i % N ] ) ; } int maxSuf = V [ 0 ] ; int maxPref = V [ 2 * N - 1 ] ; curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr += V [ i ] ; maxPref = Math . Max ( maxPref , curr ) ; } curr = V [ 2 * N - 1 ] ; for ( int i = 2 * N - 2 ; i >= 0 ; i -- ) { curr += V [ i ] ; maxSuf = Math . Max ( maxSuf , curr ) ; } curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr = Math . Max ( V [ i ] , curr + V [ i ] ) ; ans = Math . Max ( ans , curr ) ; } if ( sum > 0 ) { int temp = sum * ( K - 2 ) ; ans = Math . Max ( ans , Math . Max ( temp + maxPref , temp + maxSuf ) ) ; } return ans ; }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
long numOfNecklace ( int N ) { long ans = factorial ( N ) / ( factorial ( N / 2 ) * factorial ( N / 2 ) ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans /= 2 ; return ans ; }
int nthNumber ( int n ) { int [ ] divs = new int [ 1000000 ] ; int [ ] vis = new int [ 1000000 ] ; int cnt = 0 ; for ( int i = 2 ; cnt < n ; i ++ ) { if ( divs [ i ] == 0 ) { for ( int j = 2 * i ; j < 1000000 ; j += i ) { if ( vis [ j ] != 0 ) { continue ; } vis [ j ] = 1 ; int currNum = j ; int count = 0 ; while ( currNum % i == 0 ) { divs [ j ] ++ ; currNum = currNum / i ; count ++ ; } if ( currNum == 1 && count == 3 && divs [ j ] == 3 ) { cnt ++ ; } else if ( currNum != 1 && divs [ currNum ] == 0 && count == 1 && divs [ j ] == 1 ) { cnt ++ ; } if ( cnt == n ) { return j ; } } } } return - 1 ; }
int findkey ( int A , int B , int C ) { int ans = 0 ; int cur = 1 ; while ( A > 0 ) { int a = A % 10 ; int b = B % 10 ; int c = C % 10 ; A = A / 10 ; B = B / 10 ; C = C / 10 ; int m = Math . Max ( a , Math . Max ( c , b ) ) ; ans += cur * m ; cur = cur * 10 ; } return ans ; }
int SumOfPrimeDivisors ( int n ) { int sum = 0 ; if ( n % 2 == 0 ) { sum = sum + 2 ; } while ( n % 2 == 0 ) { n = n / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { sum = sum + i ; } while ( n % i == 0 ) { n = n / i ; } } if ( n > 2 ) { sum = sum + n ; } return sum ; }
int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( ( i & 1 ) == 0 ) count += 1 ; } return count ; }
int countNumbers ( int l , int r ) { return ( ( r / 2 ) - ( l - 1 ) / 2 ) ; }
bool isPerfectSquare ( int x ) { int s = ( int ) Math . Sqrt ( x ) ; return ( s * s == x ) ; }
bool isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
int contiguousFibonacciNumber ( int [ ] arr , int n ) { int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isFibonacci ( arr [ i ] ) ) { current_length ++ ; } else { current_length = 0 ; } max_length = Math . Max ( max_length , current_length ) ; } return max_length ; }
int Kadane ( int [ ] arr , int n ) { int largestSum = 0 , currMax = 0 ; int currSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currSum += arr [ i ] ; currMax = Math . Max ( currMax , arr [ i ] ) ; largestSum = Math . Max ( largestSum , currMax * currSum ) ; if ( currSum < 0 ) { currMax = 0 ; currSum = 0 ; } } return largestSum ; }
int maximumWeight ( int [ ] arr , int n ) { int largestSum = Kadane ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = - arr [ i ] ; } largestSum = Math . Max ( largestSum , Kadane ( arr , n ) ) ; return largestSum ; }
void evenOdd ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int even_digits = 0 ; int odd_digits = 0 ; int temp = arr [ i ] ; while ( temp > 0 ) { if ( ( temp % 10 ) % 2 != 0 ) odd_digits ++ ; else even_digits ++ ; temp /= 10 ; } if ( even_digits > odd_digits ) { int res = 0 ; while ( arr [ i ] > 0 ) { res += arr [ i ] % 10 ; arr [ i ] /= 10 ; } Console . Write ( res + " " ) ; } else if ( odd_digits > even_digits ) { int res = 1 ; while ( arr [ i ] > 0 ) { res *= arr [ i ] % 10 ; arr [ i ] /= 10 ; } Console . Write ( res + " " ) ; } else Console . Write ( arr [ i ] + " " ) ; } }
int sumOfFirstM ( int [ ] A , int N , int M ) { int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { sum = sum + A [ i % N ] ; } return sum ; }
int findSmallestNumK ( int n ) { int cummAnd = n ; int i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return - 1 ; }
int findMinInsertions ( char [ ] str , int l , int h ) { if ( l > h ) return int . MaxValue ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Math . Min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
void canReach0toM ( int [ , ] a , int n , int m ) { int [ ] rightMost = new int [ m + 1 ] ; int [ ] dp = new int [ m + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { rightMost [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int a1 = a [ i , 0 ] ; int b1 = a [ i , 1 ] ; rightMost [ a1 ] = Math . Max ( rightMost [ a1 ] , b1 ) ; } for ( int i = m ; i >= 0 ; i -- ) { dp [ i ] = i ; for ( int j = Math . Min ( m , rightMost [ i ] ) ; j > i ; j -- ) { dp [ i ] = Math . Max ( dp [ i ] , dp [ j ] ) ; } } if ( dp [ 0 ] >= m ) { Console . Write ( "Yes" ) ; } else { Console . Write ( "No" ) ; } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void countPairs ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int x = 1 ; x <= arr [ i ] ; x ++ ) { for ( int y = x ; y <= arr [ i ] ; y ++ ) { if ( gcd ( x , y ) > 1 ) count ++ ; } } Console . Write ( count + " " ) ; } }
int maximumTurns ( int [ ] arr , int N ) { int Count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { while ( arr [ i ] % 2 == 0 ) { Count ++ ; arr [ i ] = arr [ i ] / 2 ; } } return Count ; }
void findSet ( int N , int K ) { List < int > a = new List < int > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i != K ) a . Add ( i ) ; } int MaxDistinct = ( N - K ) + ( K / 2 ) ; a . Reverse ( ) ; for ( int i = 0 ; i < MaxDistinct ; i ++ ) Console . Write ( a [ i ] + " " ) ; }
void linearCongruence ( long A , long B , long N ) { A = A % N ; B = B % N ; long u = 0 , v = 0 ; long [ ] person = ExtendedEuclidAlgo ( A , N ) ; long d = person [ 0 ] ; u = person [ 1 ] ; v = person [ 2 ] ; if ( B % d != 0 ) { Console . WriteLine ( - 1 ) ; return ; } long x0 = ( u * ( B / d ) ) % N ; if ( x0 < 0 ) x0 += N ; for ( long i = 0 ; i <= d - 1 ; i ++ ) { long an = ( x0 + i * ( N / d ) ) % N ; Console . Write ( an + " " ) ; } }
int distinctGCDs ( int [ ] arr , int N ) { int M = - 1 , ans = 0 ; Dictionary < int , int > Mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { M = Math . Max ( M , arr [ i ] ) ; if ( Mp . ContainsKey ( arr [ i ] ) ) Mp [ arr [ i ] ] = 1 ; else Mp . Add ( arr [ i ] , 1 ) ; } for ( int i = 1 ; i <= M ; i ++ ) { int currGcd = 0 ; for ( int j = i ; j <= M ; j += i ) { if ( Mp . ContainsKey ( j ) ) { currGcd = gcd ( currGcd , j ) ; if ( currGcd == i ) { ans ++ ; break ; } } } } return ans ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
void countSubarray ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int mxSubarray = 0 ; int mxOther = 0 ; for ( int k = i ; k <= j ; k ++ ) { mxSubarray = Math . Max ( mxSubarray , arr [ k ] ) ; } for ( int k = 0 ; k < i ; k ++ ) { mxOther = Math . Max ( mxOther , arr [ k ] ) ; } for ( int k = j + 1 ; k < n ; k ++ ) { mxOther = Math . Max ( mxOther , arr [ k ] ) ; } if ( mxSubarray > ( 2 * mxOther ) ) count ++ ; } } Console . Write ( count ) ; }
void countSubarray ( int [ ] arr , int n ) { int L = 0 , R = 0 ; int mx = Int32 . MinValue ; for ( int i = 0 ; i < n ; i ++ ) mx = Math . Max ( mx , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] * 2 > mx ) { L = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] * 2 > mx ) { R = i ; break ; } } Console . WriteLine ( ( L + 1 ) * ( n - R ) ) ; }
int factorialWithoutMul ( int N ) { int ans = N ; for ( int i = N - 1 ; i > 0 ; i -- ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ans ; ans = sum ; } return ans ; }
bool isPrime ( int X ) { for ( int i = 2 ; i * i <= X ; i ++ ) if ( X % i == 0 ) return false ; return true ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; }
int minOperations ( int A , int B ) { int cnt1 = 0 , cnt2 = 0 ; cnt1 += countSetBits ( A ) ; cnt2 += countSetBits ( B ) ; if ( ( cnt1 + cnt2 ) % 2 != 0 ) return - 1 ; int oneZero = 0 , zeroOne = 0 ; int ans = 0 ; for ( int i = 0 ; i < Math . Max ( cnt1 , cnt2 ) ; i ++ ) { int bitpos = 1 << i ; if ( ( ( bitpos & A ) == 0 ) && ( bitpos & B ) != 0 ) zeroOne ++ ; if ( ( bitpos & A ) != 0 && ( ( bitpos & B ) == 0 ) ) oneZero ++ ; } ans = ( zeroOne / 2 ) + ( oneZero / 2 ) ; if ( zeroOne % 2 != 0 ) ans += 2 ; return ans ; }
void sieveSundaram ( ) { int [ ] marked = new int [ MAX / 2 + 100 ] ; Array . Clear ( marked , 0 , MAX / 2 + 100 ) ; for ( int i = 1 ; i <= ( int ) ( Math . Sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = 1 ; primes . Add ( 2 ) ; for ( int i = 1 ; i <= ( int ) MAX / 2 ; i ++ ) if ( marked [ i ] == 0 ) primes . Add ( 2 * i + 1 ) ; }
bool isSmithBrotherPair ( int X , int Y ) { return isSmith ( X ) && isSmith ( Y ) && Math . Abs ( X - Y ) == 1 ; }
int countSmithBrotherPairs ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { if ( isSmithBrotherPair ( A [ i ] , A [ j ] ) ) count ++ ; } return count ; }
void tripletAndSum ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { ans += arr [ i ] & arr [ j ] & arr [ k ] ; } } } Console . WriteLine ( ans ) ; }
void countPairs ( int [ ] arr , int N ) { int count = 0 , totalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( totalSum % ( arr [ i ] + arr [ j ] ) == 0 ) { count += 1 ; } } } Console . WriteLine ( count ) ; }
int countOfBase ( int N ) { int count = 0 ; for ( int i = 2 ; i <= N ; ++ i ) { int highestPower = ( int ) ( Math . Log ( N ) / Math . Log ( i ) ) ; int firstDigit = N / ( int ) Math . Pow ( i , highestPower ) ; if ( firstDigit == 1 ) { ++ count ; } } return count ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
bool PermuteAndFind ( int [ ] power , int idx , int SumSoFar , int target ) { if ( idx == power . Length ) { if ( SumSoFar == target ) return true ; return false ; } bool select = PermuteAndFind ( power , idx + 1 , SumSoFar , target ) ; bool notselect = PermuteAndFind ( power , idx + 1 , SumSoFar + power [ idx ] , target ) ; return ( select notselect ) ; }
void DistinctPowersOf3 ( int N ) { int [ ] power = new int [ 16 ] ; power [ 0 ] = 1 ; for ( int i = 1 ; i < 16 ; i ++ ) power [ i ] = 3 * power [ i - 1 ] ; bool found = PermuteAndFind ( power , 0 , 0 , N ) ; if ( found == true ) { Console . Write ( "Yes" ) ; } else { Console . Write ( "No" ) ; } }
Dictionary < int , int > PrimeFactor ( int N ) { Dictionary < int , int > primef = new Dictionary < int , int > ( ) ; while ( N % 2 == 0 ) { if ( primef . ContainsKey ( 2 ) ) { primef [ 2 ] ++ ; } else { primef [ 2 ] = 1 ; } N = N / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( N ) ; i ++ ) { while ( N % i == 0 ) { if ( primef . ContainsKey ( i ) ) { primef [ i ] ++ ; } else { primef [ i ] = 1 ; } N = N / 2 ; } } if ( N > 2 ) { primef [ N ] = 1 ; } return primef ; }
int CountToMakeEqual ( int X , int Y ) { int gcdofXY = gcd ( X , Y ) ; int newX = Y / gcdofXY ; int newY = X / gcdofXY ; Dictionary < int , int > primeX = PrimeFactor ( newX ) ; Dictionary < int , int > primeY = PrimeFactor ( newY ) ; int ans = 0 ; foreach ( KeyValuePair < int , int > keys in primeX ) { if ( X % keys . Key != 0 ) { return - 1 ; } ans += primeX [ keys . Key ] ; } foreach ( KeyValuePair < int , int > keys in primeY ) { if ( Y % keys . Key != 0 ) { return - 1 ; } ans += primeY [ keys . Key ] ; } return ans ; }
void maximumSubsequenceSum ( int [ ] A , int N ) { int ans = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( A [ i ] - i ) ) mp [ A [ i ] - i ] += A [ i ] ; else mp [ A [ i ] - i ] = A [ i ] ; ans = Math . Max ( ans , mp [ A [ i ] - i ] ) ; } Console . Write ( ans ) ; }
void getPermutation ( int N ) { if ( N <= 3 ) { Console . Write ( - 1 ) ; return ; } int i = N ; if ( N % 2 == 0 ) i -- ; while ( i >= 1 ) { Console . Write ( i + " " ) ; i -= 2 ; } Console . Write ( 4 + " " + 2 + " " ) ; i = 6 ; while ( i <= N ) { Console . Write ( i + " " ) ; i += 2 ; } }
int gcd ( int A , int B ) { if ( B == 0 ) return A ; else return gcd ( B , A % B ) ; }
int getDistinctValues ( int A , int B , int C ) { int g = gcd ( A , B ) ; int num_values = C / g ; return num_values ; }
void nearestPerfectSquare ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int sr = ( int ) Math . Sqrt ( arr [ i ] ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) Console . Write ( a + " " ) ; else Console . Write ( b + " " ) ; } }
int currSubArrayScore ( int [ ] a , int [ ] b , int l , int r ) { int straightScore = 0 ; int reverseScore = 0 ; for ( int i = l ; i <= r ; i ++ ) { straightScore += a [ i ] * b [ i ] ; reverseScore += a [ r - ( i - l ) ] * b [ i ] ; } return Math . Max ( straightScore , reverseScore ) ; }
void maxScoreSubArray ( int [ ] a , int [ ] b , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int currScore = currSubArrayScore ( a , b , i , j ) ; if ( currScore > res ) { res = currScore ; } } } Console . Write ( res ) ; }
void maxScoreSubArray ( int [ ] a , int [ ] b , int n ) { int res = 0 ; for ( int mid = 0 ; mid < n ; mid ++ ) { int straightScore = a [ mid ] * b [ mid ] , reverseScore = a [ mid ] * a [ mid ] ; int prev = mid - 1 , next = mid + 1 ; res = Math . Max ( res , Math . Max ( straightScore , reverseScore ) ) ; while ( prev >= 0 && next < n ) { straightScore += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverseScore += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = Math . Max ( res , Math . Max ( straightScore , reverseScore ) ) ; prev -- ; next ++ ; } straightScore = 0 ; reverseScore = 0 ; prev = mid - 1 ; next = mid ; while ( prev >= 0 && next < n ) { straightScore += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverseScore += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = Math . Max ( res , Math . Max ( straightScore , reverseScore ) ) ; prev -- ; next ++ ; } } Console . WriteLine ( res ) ; }
int minimumSizeSubarray ( int [ ] arr , int N ) { int i = 0 , j = N - 1 ; while ( i < N && arr [ i ] == 0 ) { i ++ ; } if ( i == N ) return 1 ; while ( j >= 0 && arr [ j ] == 0 ) { j -- ; } return ( j - i + 1 ) ; }
void countXorPartition ( int N ) { double a = Math . Pow ( 2 , ( int ) ( N - Math . Log ( N + 1 ) / Math . Log ( 2 ) ) ) ; Console . Write ( a ) ; }
void countValues ( int A , int B , int C ) { if ( B >= A ) { Console . Write ( 0 ) ; return ; } if ( B == 0 ) { Console . Write ( C / A ) ; return ; } int ans = C / A ; if ( ans * A + B <= C ) { ans ++ ; } Console . Write ( ans ) ; }
void SieveOfEratosthenes ( int n ) { for ( int i = 0 ; i < 100001 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } }
int floorDifference ( int [ ] A , int N , int X ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += A [ i ] ; perElementSum += A [ i ] / X ; } int totalFloorSum = totalSum / X ; return Math . Abs ( totalFloorSum - perElementSum ) ; }
int maximumSum ( int [ ] arr , int N ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & ( 1 << bit ) ) != 0 ) { sum += arr [ i ] ; } } ans = Math . Max ( ans , sum ) ; } return ans ; }
void maxCount ( int [ ] arr , int N , int K ) { HashSet < int > st = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { st . Add ( arr [ i ] ) ; } if ( N - st . Count <= K ) { Console . Write ( "Yes" ) ; } else Console . Write ( "No" ) ; }
void kthDigitFromLast ( int n , int k ) { if ( k <= 0 ) { Console . Write ( - 1 ) ; return ; } while ( ( k - 1 ) > 0 && n > 0 ) { n = n / 10 ; k -- ; } if ( n == 0 ) { Console . Write ( - 1 ) ; } else { Console . Write ( n % 10 ) ; } }
void findWinner ( int X , int Y ) { int playerA = ( X ^ Y ) ; bool flag = false ; for ( int i = 1 ; i <= X ; i ++ ) { for ( int j = 1 ; j <= Y ; j ++ ) { int val = ( i ^ j ) ; if ( val > playerA ) { flag = true ; break ; } } if ( flag ) { break ; } } if ( flag ) { Console . WriteLine ( "Yes" ) ; } else { Console . WriteLine ( "No" ) ; } }
void findWinner ( int X , int Y ) { int first = ( X ^ Y ) ; int second = ( X + Y ) ; if ( first == second ) { Console . Write ( "No" ) ; } else { Console . Write ( "Yes" ) ; } }
int countWays ( int [ ] arr , int N ) { int arr_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) arr_xor ^= arr [ i ] ; int pref_xor = 0 , suff_xor = 0 ; List < int > pref_ind = new List < int > ( ) ; int [ ] suff_inds = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { pref_xor ^= arr [ i ] ; if ( pref_xor == arr_xor ) pref_ind . Add ( i ) ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { suff_xor ^= arr [ i ] ; suff_inds [ i ] += suff_inds [ i + 1 ] ; if ( suff_xor == arr_xor ) suff_inds [ i ] ++ ; } int tot_ways = 0 ; foreach ( int idx in pref_ind ) { if ( idx < N - 1 ) tot_ways += suff_inds [ idx + 2 ] ; } return tot_ways ; }
int KthSmallest ( int [ ] A , int [ ] B , int N , int K ) { int M = 0 ; for ( int i = 0 ; i < N ; i ++ ) { M = Math . Max ( A [ i ] , M ) ; } int [ ] freq = new int [ M + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { freq [ A [ i ] ] += B [ i ] ; } int sum = 0 ; for ( int i = 0 ; i <= M ; i ++ ) { sum += freq [ i ] ; if ( sum >= K ) { return i ; } } return - 1 ; }
int xorSumOfArray ( int [ ] arr , int n , int k , int [ ] count ) { int sum = 0 ; int p = 1 ; for ( int i = 0 ; i < 31 ; i ++ ) { int val = 0 ; if ( ( k & ( 1 << i ) ) != 0 ) { int not_set = n - count [ i ] ; val = ( ( not_set ) * p ) ; } else { val = ( count [ i ] * p ) ; } sum += val ; p = ( p * 2 ) ; } return sum ; }
void sumOfXors ( int [ ] arr , int n , int [ ] queries , int q ) { int [ ] count = new int [ 32 ] ; for ( int i = 0 ; i < 32 ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 31 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) != 0 ) count [ j ] ++ ; } } for ( int i = 0 ; i < q ; i ++ ) { int k = queries [ i ] ; Console . Write ( xorSumOfArray ( arr , n , k , count ) + " " ) ; } }
int IsSumEqualsXor ( int i , int n , int bound , char [ ] s ) { if ( i == n ) return 1 ; if ( dp [ i , bound ] != - 1 ) return dp [ i , bound ] ; int ans = 0 ; if ( bound != 0 && s [ i ] == '0' ) { ans = IsSumEqualsXor ( i + 1 , n , 1 , s ) ; } else { ans = 2 * IsSumEqualsXor ( i + 1 , n , bound != 0 & ( s [ i ] == '1' ) ? 1 : 0 , s ) ; ans += IsSumEqualsXor ( i + 1 , n , 0 , s ) ; } return dp [ i , bound ] = ans ; }
int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
int findSmallest ( int M , int N ) { int x = findNum ( M , N ) ; return x - M ; }
int toDeci ( string str , int basse ) { int len = str . Length ; int power = 1 ; int num = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= basse ) { Console . Write ( "Invalid Number" ) ; return - 1 ; } num += val ( str [ i ] ) * power ; power = power * basse ; } return num ; }
int fact ( int N ) { if ( N == 1 N == 0 ) return 1 ; return N * fact ( N - 1 ) ; }
void prefixFactorialArray ( int [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = fact ( arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
void prefixFactorialArray ( int [ ] A , int N ) { for ( int i = 1 ; i < N ; i ++ ) { A [ i ] += A [ i - 1 ] ; } int [ ] fact = new int [ A [ N - 1 ] + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= A [ N - 1 ] ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = fact [ A [ i ] ] ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( A [ i ] + " " ) ; } }
void countPairs ( int [ ] arr , int n , int x ) { int count = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! mp . ContainsKey ( arr [ i ] - x * i ) ) mp [ arr [ i ] - x * i ] = 0 ; mp [ arr [ i ] - x * i ] = mp [ arr [ i ] - x * i ] + 1 ; } foreach ( KeyValuePair < int , int > v in mp ) { count += ( v . Value * ( v . Value - 1 ) ) / 2 ; } Console . WriteLine ( count ) ; }
double findAverage ( int N ) { double S = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { S += i * i * i * i ; } return S / N ; }
double findAverage ( int N ) { double avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 ; return avg ; }
bool ToCheckPowerofX ( int n , int x ) { while ( n > 0 ) { int rem = n % x ; if ( rem >= 2 ) { return false ; } n = n / x ; } return true ; }
int maximumOfTwo ( int N ) { int M = reverseBin ( N ) ; return Math . Max ( N , M ) ; }
void findbitwiseOR ( int [ ] a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } Console . Write ( res ) ; }
void findbitwiseOR ( int [ ] a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; Console . Write ( res ) ; }
void findDecimal ( double [ ] arr , int N ) { int bit , power = 0 , result = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { bit = Math . Abs ( ( int ) Math . Floor ( arr [ i ] ) - ( int ) Math . Round ( arr [ i ] ) ) ; if ( bit != 0 ) result += ( int ) Math . Pow ( 2 , power ) ; power ++ ; } Console . WriteLine ( result ) ; }
int totalMoney ( int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { ans += i / 7 ; ans += ( i % 7 + 1 ) ; } return ans ; }
int minTime ( int [ ] A , int n , int K ) { int max_ability = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { max_ability = Math . Max ( max_ability , A [ i ] ) ; } int [ ] tmp = new int [ max_ability + 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { tmp [ A [ i ] ] ++ ; } for ( int i = max_ability ; i >= 0 ; i -- ) { if ( tmp [ i ] != 0 ) { if ( tmp [ i ] * i < K ) { K -= ( i * tmp [ i ] ) ; tmp [ i / 2 ] += tmp [ i ] ; count += tmp [ i ] ; if ( K <= 0 ) { return count ; } } else { if ( K % i != 0 ) { count += ( K / i ) + 1 ; } else { count += ( K / i ) ; } return count ; } } } return - 1 ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void minimumRod ( int [ ] A , int N ) { Console . WriteLine ( N * findlcm ( A , N ) ) ; }
void check ( int n ) { int sumOfDigit = 0 ; int prodOfDigit = 1 ; while ( n > 0 ) { int rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n /= 10 ; } if ( sumOfDigit > prodOfDigit ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
bool check ( int N , int D ) { while ( N > 0 ) { if ( findDigit ( N , D ) == true ) { return true ; } N -= D ; } return false ; }
int FindSum ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int power = ( int ) ( Math . Log ( arr [ i ] ) / Math . Log ( 2 ) ) ; int LesserValue = ( int ) Math . Pow ( 2 , power ) ; int LargerValue = ( int ) Math . Pow ( 2 , power + 1 ) ; if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) { res += arr [ i ] ; } } return res ; }
int power ( int x , int y ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
void countRelations ( int N ) { Console . Write ( ( power ( 2 , N ) - 2 ) * power ( 2 , N * N - N ) ) ; }
int minOperations ( int N ) { int [ ] arr = new int [ N ] ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = ( 2 * i ) + 1 ; sum = sum + arr [ i ] ; } int mid = 0 ; if ( N % 2 == 0 ) { mid = sum / N ; } else { mid = arr [ N / 2 ] ; } int ans = 0 ; for ( int i = 0 ; i < N / 2 ; i ++ ) { ans += mid - arr [ i ] ; } return ans ; }
int minOperation ( int N ) { if ( N % 2 == 0 ) { return ( N / 2 ) * ( N / 2 ) ; } int k = ( N - 1 ) / 2 ; return k * ( k + 1 ) ; }
int findXORS ( int [ ] arr1 , int [ ] arr2 , int N , int M ) { int XORS1 = 0 ; int XORS2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XORS1 ^= arr1 [ i ] ; } for ( int i = 0 ; i < M ; i ++ ) { XORS2 ^= arr2 [ i ] ; } return ( XORS1 & XORS2 ) ; }
void findPermutation ( int [ ] arr ) { int N = arr . Length ; int i = N - 2 ; while ( i >= 0 && arr [ i ] <= arr [ i + 1 ] ) i -- ; if ( i == - 1 ) { Console . Write ( "-1" ) ; return ; } int j = N - 1 ; while ( j > i && arr [ j ] >= arr [ i ] ) j -- ; while ( j > i && arr [ j ] == arr [ j - 1 ] ) { j -- ; } int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; foreach ( int it in arr ) { Console . Write ( it + " " ) ; } }
bool isPowerof2 ( int n ) { return ( ( n & ( n - 1 ) ) > 0 && n > 0 ) ; }
void countNum ( int N ) { int ans = ( int ) ( Math . Log ( N ) / Math . Log ( 2 ) ) + 1 ; Console . WriteLine ( ans ) ; }
int nearestPow ( int x , int base1 ) { int k = ( int ) ( Math . Log ( x ) / Math . Log ( base1 ) ) ; if ( Math . Abs ( Math . Pow ( base1 , k ) - x ) < Math . Abs ( Math . Pow ( base1 , ( k + 1 ) ) - x ) ) return ( int ) Math . Pow ( base1 , k ) ; else return ( int ) Math . Pow ( base1 , ( k + 1 ) ) ; }
int ceilDifference ( int [ ] arr , int n , int x ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; perElementSum += ( int ) Math . Ceiling ( ( double ) ( arr [ i ] ) / ( double ) ( x ) ) ; } int totalCeilSum = ( int ) Math . Ceiling ( ( double ) ( totalSum ) / ( double ) ( x ) ) ; return Math . Abs ( perElementSum - totalCeilSum ) ; }
void computeTotient ( int N , int [ ] phi ) { for ( int p = 2 ; p <= N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
void countPairs ( int N ) { int cnt_type1 = 0 , cnt_type2 = 0 ; int half_N = N / 2 ; cnt_type1 = ( half_N * ( half_N - 1 ) ) / 2 ; int [ ] phi = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { phi [ i ] = i ; } computeTotient ( N , phi ) ; for ( int i = ( N / 2 ) + 1 ; i <= N ; i ++ ) cnt_type2 += ( i - phi [ i ] - 1 ) ; Console . Write ( cnt_type1 + cnt_type2 ) ; }
int countTriplets ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i * j > N ) break ; ans += N / ( i * j ) ; } } return ans ; }
void findSumOfGP ( double a , double r ) { if ( Math . Abs ( r ) >= 1 ) { Console . Write ( "Infinite" ) ; return ; } double sum = a / ( 1 - r ) ; Console . Write ( sum ) ; }
int power ( long x , int y ) { int res = 1 ; x = x % mod ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( int ) ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
int numberOfRelations ( int N ) { return power ( 3 , ( N * N - N ) / 2 ) ; }
void countNumbers ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( __gcd ( i , N ) != 1 ) count ++ ; } Console . Write ( count ) ; }
int phi ( int N ) { int result = N ; for ( int p = 2 ; p * p <= N ; ++ p ) { if ( N % p == 0 ) { while ( N % p == 0 ) N /= p ; result -= result / p ; } } if ( N > 1 ) result -= result / N ; return result ; }
void countNumbers ( int N ) { int count = N - phi ( N ) ; Console . Write ( count ) ; }
void Query ( int [ ] arr , int N , int [ , ] Q ) { int mul = 1 ; int add = 0 ; for ( int i = 0 ; i < Q . GetLength ( 0 ) ; i ++ ) { if ( Q [ i , 0 ] == 0 ) { add = add + Q [ i , 1 ] ; } else if ( Q [ i , 0 ] == 1 ) { mul = mul * Q [ i , 1 ] ; add = add * Q [ i , 1 ] ; } else { int ans = arr [ Q [ i , 1 ] ] * mul + add ; Console . Write ( ans + " " ) ; } } }
int nearFibo ( int X ) { double a = ( Math . Pow ( 5 , 0.5 ) + 1 ) / 2 ; int n = ( int ) ( Math . Log ( ( Math . Pow ( 5 , 0.5 ) ) * X ) / Math . Log ( a ) ) ; int nth = nthFibo ( n ) ; int nplus = nthFibo ( n + 1 ) ; if ( Math . Abs ( X - nth ) < Math . Abs ( X - nplus ) ) return nth ; else return nplus ; }
void sieveOfEratosthenes ( int N , int [ ] s ) { bool [ ] prime = new bool [ N + 1 ] ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( ! prime [ i * j ] ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
int getMaxPairSum ( int [ ] arr , int N , int K ) { int [ ] preMax = new int [ N ] ; preMax [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { preMax [ i ] = Math . Max ( preMax [ i - 1 ] , arr [ i ] ) ; } int res = Int32 . MinValue ; for ( int i = K ; i < N ; i ++ ) { res = Math . Max ( res , arr [ i ] + preMax [ i - K ] ) ; } return res ; }
void sumOfInfiniteAGP ( double a , double d , double r ) { double ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) ; Console . Write ( ans ) ; }
int countPairs ( int [ ] arr , int N ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 arr [ j ] % arr [ i ] == 0 ) { count ++ ; } } } return count ; }
int CountPairs ( int [ ] arr , int N ) { int res = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) mp [ arr [ i ] ] ++ ; else mp . Add ( arr [ i ] , 1 ) ; } foreach ( KeyValuePair < int , int > kvp in mp ) { int x = kvp . Key ; int y = kvp . Value ; if ( x == 1 ) { res += N - 1 ; continue ; } res += ( y * ( y - 1 ) ) / 2 ; for ( int j = 2 ; j <= Math . Sqrt ( x ) ; j ++ ) { if ( x % j == 0 ) { res += mp [ j ] ; if ( j != x / j ) res += mp [ x / j ] ; } } } return res ; }
void findClosestTarget ( int i , int curr , int [ ] B , int M , int K ) { if ( Math . Abs ( curr - K ) < mini ) { mini = Math . Abs ( curr - K ) ; ans = curr ; } if ( Math . Abs ( curr - K ) == mini ) { ans = Math . Min ( ans , curr ) ; } if ( i >= M ) return ; findClosestTarget ( i + 1 , curr + B [ i ] , B , M , K ) ; findClosestTarget ( i + 1 , curr + 2 * B [ i ] , B , M , K ) ; findClosestTarget ( i + 1 , curr , B , M , K ) ; }
int findClosest ( int [ ] A , int [ ] B , int N , int M , int K ) { for ( int i = 0 ; i < N ; i ++ ) { findClosestTarget ( 0 , A [ i ] , B , M , K ) ; } return ans ; }
int countbits ( int n ) { int count = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) count ++ ; n = n / 2 ; } return count ; }
int BitProduct ( int [ ] arr , int N ) { int product = 1 ; for ( int i = 0 ; i < N ; i ++ ) { int bits = countbits ( arr [ i ] ) ; product *= bits ; } return product ; }
List < int > removeEveryKth ( List < int > l , int k ) { for ( int i = 0 ; i < l . Count ; i ++ ) { if ( i % k == 0 ) l [ i ] = 0 ; } List < int > arr = new List < int > ( ) ; arr . Add ( 0 ) ; for ( int i = 1 ; i < l . Count ; i ++ ) { if ( l [ i ] != 0 ) arr . Add ( l [ i ] ) ; } return arr ; }
void printArray ( List < int > l ) { for ( int i = 1 ; i < l . Count ; i ++ ) Console . Write ( l [ i ] + " " ) ; Console . WriteLine ( ) ; }
void printSequence ( int n , int k ) { List < int > l = new List < int > ( ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) l . Add ( i ) ; int x = 1 ; for ( int i = 0 ; i < k ; i ++ ) { int p = l [ x ] + l [ x + 1 ] ; l = removeEveryKth ( l , p ) ; x += 1 ; } printArray ( l ) ; }
void OddDivisorsSum ( int n , int q , int [ ] a , int [ , ] Query ) { int [ ] DP = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) ( Math . Sqrt ( a [ i ] ) ) ; if ( x * x == a [ i ] ) DP [ i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { DP [ i ] = DP [ i - 1 ] + DP [ i ] ; } for ( int i = 0 ; i < q ; i ++ ) { int l = Query [ i , 0 ] ; int r = Query [ i , 1 ] ; if ( l == 0 ) { Console . Write ( DP [ r ] + " " ) ; } else { Console . Write ( DP [ r ] - DP [ l - 1 ] + " " ) ; } } }
void findSubset ( List < int > arr ) { int N = arr . Count ; int i ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int totSum = 0 ; int s = 0 ; int flag = 0 ; List < int > ans = new List < int > ( ) ; for ( i = 0 ; i < arr . Count ; i ++ ) { totSum += arr [ i ] ; if ( mp . ContainsKey ( arr [ i ] ) ) mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; else mp . Add ( arr [ i ] , 1 ) ; } arr . Sort ( ) ; i = N - 1 ; while ( i >= 0 ) { int frq = mp [ arr [ i ] ] ; if ( ( frq + ans . Count ) < ( N - ( frq + ans . Count ) ) ) { for ( int k = 0 ; k < frq ; k ++ ) { ans . Add ( arr [ i ] ) ; totSum -= arr [ i ] ; s += arr [ i ] ; i -- ; } } else { i -= frq ; } if ( s > totSum ) { flag = 1 ; break ; } } if ( flag == 1 ) { for ( i = ans . Count - 1 ; i >= 0 ; i -- ) { Console . Write ( ans [ i ] + " " ) ; } } else { Console . Write ( - 1 ) ; } }
int minStepK ( int [ ] arr , int N , int K ) { int E = 0 ; int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { S += arr [ i ] ; if ( arr [ i ] % 2 == 0 ) E += 1 ; } if ( S >= K ) return 0 ; else if ( S + E < K ) return - 1 ; else return K - S ; }
int Rotate ( int n , int f ) { int temp = n ; int maxi = n ; int mini = n ; for ( int idx = 0 ; idx < 7 ; idx ++ ) { if ( temp % 2 == 1 ) { temp >>= 1 ; temp += ( int ) Math . Pow ( 2 , 7 ) ; } else temp >>= 1 ; mini = Math . Min ( mini , temp ) ; maxi = Math . Max ( maxi , temp ) ; } if ( f == 1 ) return ( maxi ) ; else return ( mini ) ; }
void minimumDiff ( int [ ] arr , int N ) { int res = arr [ 0 ] , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int min_diff = sum ; for ( int i = 0 ; i < N ; i ++ ) { if ( Math . Abs ( sum - ( arr [ i ] * N ) ) < min_diff ) { min_diff = Math . Abs ( sum - ( arr [ i ] * N ) ) ; res = arr [ i ] ; } } Console . Write ( res ) ; }
int makeEqual ( int [ ] arr , int n ) { int [ ] fre0 = new int [ 33 ] ; int [ ] fre1 = new int [ 33 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; for ( int j = 0 ; j < 33 ; j ++ ) { if ( ( x & 1 ) != 0 ) { fre1 [ j ] += 1 ; } else { fre0 [ j ] += 1 ; } x = x >> 1 ; } } int ans = 0 ; for ( int i = 0 ; i < 33 ; i ++ ) { ans += Math . Min ( fre0 [ i ] , fre1 [ i ] ) ; } return ans ; }
void check ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum == 0 ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
int primeDivisors ( int [ ] arr , int N ) { int K = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { K = Math . Max ( K , arr [ i ] ) ; } int [ ] prime = new int [ K + 1 ] ; prime [ 0 ] = 1 ; prime [ 1 ] = 1 ; for ( int i = 2 ; i < K + 1 ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = 2 * i ; j < K + 1 ; j += i ) { prime [ j ] = 1 ; } } } int [ ] factor = new int [ K + 1 ] ; factor [ 0 ] = 0 ; factor [ 1 ] = 1 ; for ( int i = 2 ; i < K + 1 ; i ++ ) { factor [ i ] += 1 ; for ( int j = i ; j < K + 1 ; j += i ) { factor [ j ] += 1 ; } } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( prime [ factor [ arr [ i ] ] ] == 0 ) count ++ ; } return count ; }
int isPresent ( int n , int x ) { string num = n . ToString ( ) ; for ( int i = 0 ; i < num . Length ; i ++ ) { if ( ( ( int ) num [ i ] - 97 ) == x ) return i ; } return - 1 ; }
int removeDigit ( int n , int index ) { string num = n . ToString ( ) ; string ans = "" ; for ( int i = 0 ; i < num . Length ; i ++ ) { if ( i != index ) ans += num [ i ] ; } if ( ans == "" || ( ans . Length == 1 && ans [ 0 ] == '0' ) ) return - 1 ; int x = Int32 . Parse ( ans ) ; ; return x ; }
bool reduceNtoX ( int a , int b , int [ ] d , int n ) { Queue < int > q = new Queue < int > ( ) ; q . Enqueue ( a ) ; Dictionary < int , bool > visited = new Dictionary < int , bool > ( ) ; visited [ a ] = true ; while ( q . Count > 0 ) { int top = q . Peek ( ) ; q . Dequeue ( ) ; if ( top < 0 ) continue ; if ( top == b ) return true ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] != 0 && top % d [ i ] == 0 && visited . ContainsKey ( top / d [ i ] ) && visited [ top / d [ i ] ] == false ) { q . Enqueue ( top / d [ i ] ) ; visited [ top / d [ i ] ] = true ; } int index = isPresent ( top , d [ i ] ) ; if ( index != - 1 ) { int newElement = removeDigit ( top , index ) ; if ( newElement != - 1 && ( visited . ContainsKey ( newElement ) && visited [ newElement ] == false ) ) { q . Enqueue ( newElement ) ; visited [ newElement ] = true ; } } } } return true ; }
void SieveOfEratosthenes ( int n , bool [ ] prime ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } }
int fact ( int n ) { if ( n == 1 n == 0 ) return 1 ; else return n * fact ( n - 1 ) ; }
int findValue ( int n , int r , int a ) { int k = ( a - 1 ) / fact ( n ) ; int answer = k ; for ( int i = 1 ; i < n + 1 ; i ++ ) answer = answer * ( n + r - i ) ; answer = answer + 1 ; return answer ; }
void expectedValue ( int P , int a , int b , int N ) { double expValue = P + ( N * 0.5 * ( a + b ) ) ; Console . Write ( expValue ) ; }
int startingPoint ( int [ ] A , int N ) { int sum = 0 ; int ind = 0 ; int min = Int32 . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( sum < min ) { min = sum ; ind = i + 1 ; } } if ( sum < 0 ) { return - 1 ; } return ind % N ; }
int findMinSum ( int [ , ] mat , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int res = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i , j ] ; } } sum += res ; } return sum ; }
void findMedian ( int Mean , int Mode ) { double Median = ( 2 * Mean + Mode ) / 3.0 ; Console . Write ( Median ) ; }
void sumOfBinaryNumbers ( int n ) { int ans = 0 ; int one = 1 ; while ( true ) { if ( n <= 1 ) { ans = ( ans + n ) % MOD ; break ; } int x = ( int ) Math . Log ( n , 2 ) ; int cur = 0 ; int add = ( one << ( x - 1 ) ) ; for ( int i = 1 ; i <= x ; i ++ ) { cur = ( cur + add ) % MOD ; add = ( add * 10 % MOD ) ; } ans = ( ans + cur ) % MOD ; int rem = n - ( one << x ) + 1 ; int p = ( int ) Math . Pow ( 10 , x ) ; p = ( p * ( rem % MOD ) ) % MOD ; ans = ( ans + p ) % MOD ; n = rem - 1 ; } Console . WriteLine ( ans ) ; }
void uniqueElementsLCM ( int [ ] arr , int N ) { Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . ContainsKey ( arr [ i ] ) ) freq [ arr [ i ] ] ++ ; else freq . Add ( arr [ i ] , 1 ) ; } int lcm = 1 ; foreach ( KeyValuePair < int , int > kvp in freq ) { if ( kvp . Value == 1 ) { lcm = findLCM ( lcm , kvp . Key ) ; } } if ( lcm == 1 ) lcm = - 1 ; Console . Write ( lcm ) ; }
int maxAdjacentDifference ( List < int > A ) { int diff = 0 ; for ( int i = 1 ; i < A . Count ; i ++ ) { diff = Math . Max ( diff , A [ i ] - A [ i - 1 ] ) ; } return diff ; }
int MinimumValue ( int [ ] arr , int N ) { int MinValue = Int32 . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { List < int > new_arr = new List < int > ( ) ; for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) continue ; new_arr . Add ( arr [ j ] ) ; } MinValue = Math . Min ( MinValue , maxAdjacentDifference ( new_arr ) ) ; } return MinValue ; }
void findNode ( Dictionary < int , int > map , int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . ContainsKey ( i + 1 ) ) a [ i ] = map [ i + 1 ] ; else a [ i ] = 0 ; } int count0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count0 ++ ; } } count0 -= 1 ; if ( count0 <= Math . Floor ( ( ( double ) n ) / ( ( double ) 2 ) ) ) { Console . WriteLine ( "Yes" ) ; } else Console . WriteLine ( "No " ) ; }
int count ( int num ) { int ans = 0 ; while ( num > 0 ) { ans += num & 1 ; num >>= 1 ; } return ans ; }
void checkGoodMatrix ( int [ , ] mat ) { List < int > P = new List < int > ( ) ; List < int > S = new List < int > ( ) ; List < int > MR = new List < int > ( ) ; List < int > MC = new List < int > ( ) ; for ( int i = 0 ; i < mat . GetLength ( 0 ) ; i ++ ) { for ( int j = 0 ; j < mat . GetLength ( 1 ) ; j ++ ) { if ( i == j ) P . Add ( mat [ i , j ] ) ; if ( i + j == mat . GetLength ( 0 ) - 1 ) S . Add ( mat [ i , j ] ) ; if ( i == Math . Floor ( ( mat . GetLength ( 0 ) - 1 ) / 2.0 ) ) MR . Add ( mat [ i , j ] ) ; if ( j == Math . Floor ( ( mat . GetLength ( 0 ) - 1 ) / 2.0 ) ) MC . Add ( mat [ i , j ] ) ; } } S . Reverse ( ) ; int P0 = convert ( P ) ; int S0 = convert ( S ) ; int MR0 = convert ( MR ) ; int MC0 = convert ( MC ) ; int setBitsPS = count ( ( P0 & S0 ) ) ; int setBitsMM = count ( ( MR0 & MC0 ) ) ; if ( setBitsPS > setBitsMM ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
int power ( int x , int y ) { int res = 1 ; x = x % mod ; while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
int antisymmetricRelation ( int N ) { return ( power ( 2 , N ) * power ( 3 , ( N * N - N ) / 2 ) ) % mod ; }
int power ( int x , int y ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
int asymmetricRelation ( int N ) { return power ( 3 , ( N * N - N ) / 2 ) ; }
void crossProduct ( int [ ] vect_A , int [ ] vect_B , int [ ] cross_P ) { cross_P [ 0 ] = vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ; cross_P [ 1 ] = vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ; cross_P [ 2 ] = vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ; }
void checkCollinearity ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { int [ ] A = { x1 , y1 , z1 } ; int [ ] B = { x2 , y2 , z2 } ; int [ ] cross_P = new int [ 3 ] ; crossProduct ( A , B , cross_P ) ; if ( cross_P [ 0 ] == 0 && cross_P [ 1 ] == 0 && cross_P [ 2 ] == 0 ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
double vectorMagnitude ( int x , int y , int z ) { int sum = x * x + y * y + z * z ; return Math . Sqrt ( sum ) ; }
double kineticEnergy ( double M , double V ) { double KineticEnergy ; KineticEnergy = 0.5 * M * V * V ; return KineticEnergy ; }
double potentialEnergy ( double M , double H ) { double PotentialEnergy ; PotentialEnergy = M * 9.8 * H ; return PotentialEnergy ; }
int nearestPow ( int x , int y ) { if ( y == 1 ) return 1 ; int k = ( int ) ( Math . Log ( x , y ) ) ; if ( Math . Abs ( Math . Pow ( y , k ) - x ) < Math . Abs ( Math . Pow ( y , ( k + 1 ) ) - x ) ) return ( int ) ( Math . Pow ( y , k ) ) ; return ( int ) ( Math . Pow ( y , ( k + 1 ) ) ) ; }
void countPairs ( int [ ] arr , int N ) { int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; } if ( N - even >= 1 ) { Console . WriteLine ( even ) ; return ; } Console . WriteLine ( 0 ) ; }
void nearestFibonacci ( int num ) { if ( num == 0 ) { Console . Write ( 0 ) ; return ; } int first = 0 , second = 1 ; int third = first + second ; while ( third <= num ) { first = second ; second = third ; third = first + second ; } int ans = ( Math . Abs ( third - num ) >= Math . Abs ( second - num ) ) ? second : third ; Console . Write ( ans ) ; }
bool checkPermutation ( int [ ] ans , int [ ] a , int n ) { int Max = Int32 . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { Max = Math . Max ( Max , ans [ i ] ) ; if ( Max != a [ i ] ) return false ; } return true ; }
void findPermutation ( int [ ] a , int n ) { int [ ] ans = new int [ n ] ; Dictionary < int , int > um = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! um . ContainsKey ( a [ i ] ) ) { ans [ i ] = a [ i ] ; um [ a [ i ] ] = i ; } } List < int > v = new List < int > ( ) ; int j = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! um . ContainsKey ( i ) ) { v . Add ( i ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans [ i ] == 0 ) { ans [ i ] = v [ j ] ; j ++ ; } } if ( checkPermutation ( ans , a , n ) ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( ans [ i ] + " " ) ; } } else Console . Write ( "-1" ) ; }
bool isPower ( int m , int y ) { int res1 = ( int ) Math . Log ( y ) / ( int ) Math . Log ( m ) ; double res2 = ( int ) Math . Log ( y ) / ( int ) Math . Log ( m ) ; return ( res1 == res2 ) ; }
int numSub ( int [ ] arr , int n , int m ) { int ans = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPower ( m , arr [ i ] ) ) { cnt ++ ; ans += ( cnt * ( cnt - 1 ) ) / 2 ; } else { cnt = 0 ; } } return ans ; }
void SieveOfEratosthenes ( int n ) { for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } }
void assignValues ( int [ , ] Edges , int n ) { LinkedList < int > [ ] tree = new LinkedList < int > [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) tree [ i ] = new LinkedList < int > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int u = Edges [ i , 0 ] ; int v = Edges [ i , 1 ] ; tree [ u ] . AddLast ( v ) ; tree [ v ] . AddLast ( u ) ; } bool [ ] visited = new bool [ n + 1 ] ; int [ ] answer = new int [ n + 1 ] ; int K = 1 ; Queue q = new Queue ( ) ; q . Enqueue ( 1 ) ; answer [ 1 ] = K ; while ( q . Count > 0 ) { int node = ( int ) q . Peek ( ) ; q . Dequeue ( ) ; visited [ node ] = true ; K = ( ( answer [ node ] == 1 ) ? 2 : 1 ) ; foreach ( var child in tree [ node ] ) { if ( ! visited [ child ] ) { q . Enqueue ( child ) ; answer [ child ] = K ; } } } for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( answer [ i ] + " " ) ; } }
void distribute ( int N , int K , int M , int [ ] arr ) { int [ ] distribution = new int [ N ] ; int ptr = K - 1 ; int rem = M ; while ( rem > 0 ) { if ( rem >= arr [ ptr ] ) { distribution [ ptr ] += arr [ ptr ] ; rem -= arr [ ptr ] ; } else { distribution [ ptr ] += rem ; rem = 0 ; } ptr = ( ptr + 1 ) % N ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( distribution [ i ] + " " ) ; } }
void sumOfSquaredDifferences ( int [ ] arr , int N ) { int ans = 0 ; int sumA = 0 , sumB = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumA += ( arr [ i ] * arr [ i ] ) ; sumB += arr [ i ] ; } sumA = N * sumA ; sumB = ( sumB * sumB ) ; ans = sumA - sumB ; Console . WriteLine ( ans ) ; }
bool isPrime ( long n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( long i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void findMinimumNumber ( long [ ] arr , long N ) { List < long > primes = new List < long > ( ) ; findPrime ( primes ) ; long ans = 2147483647 ; int n = primes . Count ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { long temp = 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) > 0 ) { temp *= primes [ j ] ; } } bool check = true ; for ( long k = 0 ; k < N ; k ++ ) { if ( gcd ( temp , arr [ k ] ) == 1 ) { check = false ; break ; } } if ( check == true ) ans = Math . Min ( ans , temp ) ; } Console . Write ( ans ) ; }
void waysToRemove ( int n , int m ) { int ans = 0 ; if ( m == 1 ) { Console . Write ( n ) ; return ; } for ( int d = 0 ; d >= 0 ; d ++ ) { int len = m + ( m - 1 ) * d ; if ( len > n ) break ; ans += ( n - len ) + 1 ; } Console . Write ( ans ) ; }
void countStairs ( int n , int x , int a , int b ) { int [ ] vis = new int [ n + 1 ] ; Array . Clear ( vis , 0 , vis . Length ) ; int [ ] moves = { + a , - a , + b , - b } ; Queue < int > q = new Queue < int > ( ) ; q . Enqueue ( x ) ; vis [ x ] = 1 ; while ( q . Count > 0 ) { int currentStair = q . Peek ( ) ; q . Dequeue ( ) ; for ( int j = 0 ; j < 4 ; j ++ ) { int newStair = currentStair + moves [ j ] ; if ( newStair > 0 && newStair <= n && vis [ newStair ] == 0 ) { q . Enqueue ( newStair ) ; vis [ newStair ] = 1 ; } } } int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( vis [ i ] == 1 ) cnt ++ ; Console . WriteLine ( cnt ) ; }
void minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = - 1 ; Console . WriteLine ( cnt ) ; }
int cntPairs ( int [ ] arr , int N ) { int res = 0 ; int [ ] bit = new int [ 32 ] ; for ( int i = 0 ; i < N ; i ++ ) { int pos = ( int ) ( Math . Log ( arr [ i ] ) / Math . Log ( 2 ) ) ; bit [ pos ] ++ ; } for ( int i = 0 ; i < 32 ; i ++ ) { res += ( bit [ i ] * ( bit [ i ] - 1 ) ) / 2 ; } return res ; }
void minimumMEX ( int [ ] arr , int N , int K ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 1 ; i <= N + 1 ; i ++ ) s . Add ( i ) ; for ( int i = 0 ; i < K ; i ++ ) s . Remove ( arr [ i ] ) ; int mex = s . First ( ) ; for ( int i = K ; i < N ; i ++ ) { s . Remove ( arr [ i ] ) ; s . Add ( arr [ i - K ] ) ; int firstElem = s . First ( ) ; mex = Math . Min ( mex , firstElem ) ; } Console . Write ( mex + " " ) ; }
void smallerNumbers ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { count ++ ; } } Console . Write ( count + " " ) ; } }
int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }
void minimumOperations ( int X , int Y ) { int GCD = gcd ( X , Y ) ; X = X / GCD ; Y = Y / GCD ; int count = 0 ; while ( X != Y ) { if ( Y > X ) { int t = X ; X = Y ; Y = t ; } if ( X % 2 == 0 ) { X = X / 2 ; } else if ( X % 3 == 0 ) { X = X / 3 ; } else if ( X % 5 == 0 ) { X = X / 5 ; } else { Console . WriteLine ( "-1" ) ; return ; } count ++ ; } Console . WriteLine ( count ) ; }
int minOperations ( int [ ] a , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += a [ i ] ; } ans -= n ; for ( int x = 1 ; ; x ++ ) { int curPow = 1 , curCost = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curCost += Math . Abs ( a [ i ] - curPow ) ; curPow *= x ; } if ( curPow / x > ans + a [ n - 1 ] ) break ; ans = Math . Min ( ans , curCost ) ; } return ans ; }
int truncMod ( int a , int n ) { int q = a / n ; return a - n * q ; }
void addEdge ( List < int > [ ] Adj , int u , int v ) { Adj [ u ] . Add ( v ) ; Adj [ v ] . Add ( u ) ; }
void isPossible ( Node [ ] Arr , int N ) { List < int > [ ] Adj = new List < int > [ N ] ; for ( int i = 0 ; i < N ; i ++ ) Adj [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] . R < Arr [ j ] . L Arr [ i ] . L > Arr [ j ] . R ) { continue ; } else { if ( Arr [ i ] . V == Arr [ j ] . V ) { addEdge ( Adj , i , j ) ; } } } } bool [ ] visited = new bool [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( visited [ i ] == false && Adj [ i ] . Count > 0 ) { if ( check ( Adj , i , N , visited ) == false ) { Console . Write ( "No" ) ; return ; } } } Console . Write ( "Yes" ) ; }
void printArray ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } }
int bitOr ( int [ ] arr , int N ) { int count = 0 ; int length = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { length ++ ; } else { if ( length != 0 ) { count += ( ( length ) * ( length + 1 ) ) / 2 ; } length = 0 ; } } count += ( ( length ) * ( length + 1 ) ) / 2 ; return count ; }
double mean ( int [ ] arr , int N ) { double avg = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { avg += ( ( double ) ( ( arr [ i ] - avg ) / ( i + 1 ) ) ) ; } return avg ; }
int maximumAND ( int [ ] arr , int n , int m ) { int tot = 1 << n ; int mx = 0 ; for ( int bm = 0 ; bm < tot ; bm ++ ) { int andans = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( ( bm >> i ) & 1 ) != 0 ) { if ( count == 0 ) { andans = arr [ i ] ; } else { andans = andans & arr [ i ] ; } count ++ ; } } if ( count == ( m + 1 ) ) { mx = Math . Max ( mx , andans ) ; } } return mx ; }
void findTotalSum ( string [ ] ops ) { if ( ops . Length == 0 ) { Console . WriteLine ( 0 ) ; return ; } Stack < int > pts = new Stack < int > ( ) ; int ans = 0 ; for ( int i = 0 ; i < ops . Length ; i ++ ) { if ( ops [ i ] == "C" ) { ans -= pts . Pop ( ) ; } else if ( ops [ i ] == "D" ) { pts . Push ( pts . Peek ( ) * 2 ) ; ans += pts . Peek ( ) ; } else if ( ops [ i ] == "+" ) { int a = pts . Pop ( ) ; int b = pts . Peek ( ) ; pts . Push ( a ) ; ans += ( a + b ) ; pts . Push ( a + b ) ; } else { int n = Int32 . Parse ( ops [ i ] ) ; ans += n ; pts . Push ( n ) ; } } Console . WriteLine ( ans ) ; }
void findXOR ( int [ , , ] mat , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) { if ( ( i == j && j == k ) ) { XOR ^= mat [ i , j , k ] ; XOR ^= mat [ i , j , N - k - 1 ] ; } } } } Console . WriteLine ( XOR ) ; }
void findXOR ( int [ , , ] mat , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XOR ^= mat [ i , i , i ] ; XOR ^= mat [ i , i , N - i - 1 ] ; } Console . Write ( XOR ) ; }
int countSubtreesUtil ( int cur , int par ) { int res = 1 ; for ( int i = 0 ; i < graph [ cur ] . Count ; i ++ ) { int v = graph [ cur ] [ i ] ; if ( v == par ) continue ; res = ( int ) ( ( res * ( countSubtreesUtil ( v , cur ) + 1 ) ) % mod ) ; } ans = ( int ) ( ( ans + res ) % mod ) ; return res ; }
void countSubtrees ( int N , int [ , ] adj ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = adj [ i , 0 ] ; int b = adj [ i , 1 ] ; graph [ a ] . Add ( b ) ; graph [ b ] . Add ( a ) ; } countSubtreesUtil ( 1 , 1 ) ; Console . WriteLine ( ans + 1 ) ; }
void sieve ( ) { prime = new bool [ limit + 1 ] ; Array . Fill ( prime , true ) ; for ( int p = 2 ; p * p <= limit ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= limit ; i += p ) prime [ i ] = false ; } } }
int findOperations ( int [ ] arr , int n ) { sieve ( ) ; int minm = Int32 . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { minm = Math . Min ( minm , arr [ i ] ) ; } int val = minm ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == minm + 1 ) { val = minm - 2 ; break ; } } int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int D = arr [ i ] - val ; if ( D == 0 ) { continue ; } else if ( prime [ D ] == true ) { cnt += 1 ; } else if ( D % 2 == 0 ) { cnt += 2 ; } else { if ( prime [ D - 2 ] == true ) { cnt += 2 ; } else { cnt += 3 ; } } } return cnt ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int maximumRowValue ( int n , int m ) { return gcd ( n , m ) ; }
void checkCommonDivisor ( int [ ] arr , int N , int X ) { int G = 0 ; for ( int i = 0 ; i < N ; i ++ ) { G = GCD ( G , arr [ i ] ) ; } int copy_G = G ; for ( int divisor = 2 ; divisor <= X ; divisor ++ ) { while ( G % divisor == 0 ) { G = G / divisor ; } } if ( G <= X ) { Console . WriteLine ( "Yes" ) ; for ( int i = 0 ; i < N ; i ++ ) Console . Write ( arr [ i ] / copy_G + " " ) ; Console . Write ( "\n" ) ; } else Console . WriteLine ( "No" ) ; }
void countPairs ( int [ ] arr , int N ) { int count = 0 ; Dictionary < double , int > mp = new Dictionary < double , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { double val = 1.0 * arr [ i ] ; double idx = 1.0 * ( i + 1 ) ; if ( mp . ContainsKey ( val / idx ) ) count += mp [ val / idx ] ; if ( mp . ContainsKey ( val / idx ) ) mp [ val / idx ] ++ ; else mp [ val / idx ] = 1 ; } Console . WriteLine ( count ) ; }
void findConvolution ( int [ ] a , int [ ] b ) { int n = a . Length , m = b . Length ; int [ ] c = new int [ ( n + m - 1 ) ] ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { c [ i + j ] += ( a [ i ] * b [ j ] ) % MOD ; } } for ( int k = 0 ; k < c . Length ; ++ k ) { c [ k ] %= MOD ; Console . Write ( c [ k ] + " " ) ; } }
int count1s ( int start_i , int start_j , int end_i , int end_j , List < List < int > > mat ) { int count = 0 ; for ( int x = start_i ; x < end_i ; x ++ ) { for ( int y = start_j ; y < end_j ; y ++ ) { if ( mat [ x ] [ y ] == 1 ) count ++ ; } } return count ; }
void findMinimumCount ( int N , int M , int A , int B , List < List < int > > mat ) { int minimum = 1000000 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( ( i + A <= N ) && ( j + B <= M ) ) { int count = count1s ( i , j , i + A , j + B , mat ) ; minimum = Math . Min ( count , minimum ) ; } if ( ( i + B <= N ) && ( j + A <= M ) ) { int count = count1s ( i , j , i + B , j + A , mat ) ; minimum = Math . Min ( count , minimum ) ; } } } Console . WriteLine ( minimum ) ; }
bool checkEvenPower ( int n ) { int x = 0 ; while ( x < n ) { int value = ( int ) Math . Pow ( 2 , x ) ; if ( value == n ) { if ( x % 2 == 0 ) return true ; else return false ; } x ++ ; } return false ; }
int getMaxUtil ( List < int > p , int [ ] arr , int ans , bool [ ] chosen , int N ) { if ( p . Count == N ) { ans = Math . Max ( ans , calcScore ( p , arr ) ) ; return ans ; } for ( int i = 0 ; i < N ; i ++ ) { if ( chosen [ i ] ) { continue ; } chosen [ i ] = true ; p . Add ( i ) ; ans = getMaxUtil ( p , arr , ans , chosen , N ) ; chosen [ i ] = false ; p . Remove ( p . Count - 1 ) ; } return ans ; }
void getMax ( int [ ] arr , int N ) { int ans = 0 ; bool [ ] chosen = new bool [ N ] ; List < int > p = new List < int > ( ) ; int res = getMaxUtil ( p , arr , ans , chosen , N ) ; Console . Write ( res ) ; }
int multiplyByMersenne ( int N , int M ) { int x = ( int ) ( Math . Log ( M + 1 ) / Math . Log ( 2 ) ) ; return ( ( N << x ) - N ) ; }
void findSum ( int N , int K ) { int ans = 0 ; int i = 1 ; while ( i <= N ) { ans += N / i ; i = i * K ; } Console . Write ( ans ) ; }
void minimumInsertions ( int [ ] arr , int N , int K ) { bool possible = true ; int res = 0 ; int last = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= K ) { possible = false ; break ; } if ( last + arr [ i ] > K ) res ++ ; last = arr [ i ] ; } if ( possible ) { Console . Write ( res ) ; } else { Console . Write ( "-1" ) ; } }
int maxSubSum ( int [ ] arr , int n , int k , int totalDistinct ) { if ( k > n ) return 0 ; int max = 0 , sum = 0 ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { sum = 0 ; HashSet < int > set = new HashSet < int > ( ) ; for ( int j = i ; j < i + k ; j ++ ) { sum += arr [ j ] ; set . Add ( arr [ j ] ) ; } if ( set . Count == totalDistinct ) max = Math . Max ( sum , max ) ; } return max ; }
int distinct ( List < int > arr , int N ) { HashSet < int > st = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { st . Add ( arr [ i ] ) ; } return st . Count ; }
int maxSubarraySumUtil ( List < int > arr , int N , int K , int totalDistinct ) { if ( K > N ) return 0 ; int mx = 0 ; int sum = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) mp [ arr [ i ] ] += 1 ; else mp [ arr [ i ] ] = 1 ; sum += arr [ i ] ; if ( i >= K ) { if ( mp . ContainsKey ( arr [ i - K ] ) ) mp [ arr [ i - K ] ] -= 1 ; else mp [ arr [ i - K ] ] = 1 ; sum -= arr [ i - K ] ; if ( mp [ arr [ i - K ] ] == 0 ) mp . Remove ( arr [ i - K ] ) ; } if ( mp . Count == totalDistinct ) mx = Math . Max ( mx , sum ) ; } return mx ; }
void maxSubarraySum ( List < int > arr , int K ) { int N = arr . Count ; int totalDistinct = distinct ( arr , N ) ; Console . WriteLine ( maxSubarraySumUtil ( arr , N , K , totalDistinct ) ) ; }
int irreflexiveRelation ( int N ) { return power ( 2 , N * N - N ) ; }
void countAPs ( long N ) { long count = 0 ; for ( long i = 1 ; i * i <= 2 * N ; i ++ ) { long res = 2 * N ; if ( res % i == 0 ) { long op = res / i - i + 1 ; if ( op % 2 == 0 ) { count ++ ; } if ( i * i != res && ( i - res / i + 1 ) % 2 == 0 ) { count ++ ; } } } Console . WriteLine ( count - 1 ) ; }
int perfectSquare ( int num ) { int sr = ( int ) ( Math . Sqrt ( num ) ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( num - a ) < ( b - num ) ) { return a ; } else { return b ; } }
int powerOfTwo ( int num ) { int lg = ( int ) ( Math . Log ( num ) / Math . Log ( 2 ) ) ; int p = ( int ) ( Math . Pow ( 2 , lg ) ) ; return p ; }
void uniqueElement ( int [ ] arr , int N ) { bool ans = true ; Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . ContainsKey ( arr [ i ] ) ) { freq [ arr [ i ] ] = freq [ arr [ i ] ] + 1 ; } else { freq [ arr [ i ] ] = 1 ; } } foreach ( var el in freq . OrderBy ( el => el . Key ) ) { if ( el . Value == 1 ) { ans = false ; int ps = perfectSquare ( el . Key ) ; Console . Write ( powerOfTwo ( ps ) + " " ) ; } } if ( ans ) Console . Write ( "-1" ) ; }
bool canExpress ( int N ) { int temp = N ; int n = 0 ; while ( N != 0 ) { N /= 10 ; n ++ ; } N = temp ; int sum = 0 ; while ( N != 0 ) { sum += ( ( int ) Math . Pow ( N % 10 , n ) ) ; N /= 10 ; } if ( sum == temp ) return true ; return false ; }
void precompute ( ) { for ( int i = 1 ; i < R ; i ++ ) { if ( canExpress ( i ) ) { arr [ i ] = 1 ; } } for ( int i = 1 ; i < R ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; } }
void countNumbers ( int [ , ] queries , int N ) { precompute ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int L1 = queries [ i , 0 ] ; int R1 = queries [ i , 1 ] ; Console . Write ( ( arr [ R1 ] - arr [ L1 - 1 ] ) + " " ) ; } }
bool isAnyPrime ( int first , int last ) { int num1 = first * 10 + last ; int num2 = last * 10 + first ; if ( sieve [ num1 ] == 1 sieve [ num2 ] == 1 ) return true ; else return false ; }
void sumOfNodeInAPath ( int node_value ) { int sum_of_node = 0 ; while ( node_value > 0 ) { sum_of_node += node_value ; node_value /= 2 ; } Console . Write ( sum_of_node ) ; }
void findSum ( List < int > Q ) { for ( int i = 0 ; i < Q . Count ; i ++ ) { int node_value = Q [ i ] ; sumOfNodeInAPath ( node_value ) ; Console . Write ( " " ) ; } }
string oddDivisor ( int N ) { int X = N ; while ( N % 2 == 0 ) { N /= 2 ; } for ( int i = 3 ; i * i <= X ; i += 2 ) { if ( N % i == 0 ) { return "Yes" ; } } if ( N != X ) { return "Yes" ; } return "No" ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
void preprocess ( ) { for ( int i = 1 ; i <= 1000000 ; i ++ ) primes [ i ] = i ; for ( int i = 2 ; i * i <= 1000000 ; i ++ ) { if ( primes [ i ] == i ) { for ( int j = 2 * i ; j <= 1000000 ; j += i ) { if ( primes [ j ] == j ) primes [ j ] = i ; } } } }
int Steps ( int x , int m ) { int steps = 0 ; bool flag = false ; while ( x > 1 ) { if ( primes [ x ] > m ) { flag = true ; break ; } x /= primes [ x ] ; steps ++ ; } if ( flag ) return - 1 ; return steps ; }
int minimumSteps ( int x , int y , int m ) { preprocess ( ) ; int g = gcd ( x , y ) ; x = x / g ; y = y / g ; int x_steps = Steps ( x , m ) ; int y_steps = Steps ( y , m ) ; if ( x_steps == - 1 y_steps == - 1 ) return - 1 ; return x_steps + y_steps ; }
int LongestNonDeficientSubsequence ( int [ ] arr , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isNonDeficient ( arr [ i ] ) ) { res += 1 ; } } return res ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == 2 ) { sum += num ; i ++ ; } } return sum ; }
void check ( int n , int k ) { int s = findSum ( k - 1 ) ; if ( s >= n ) Console . WriteLine ( "No" ) ; else Console . WriteLine ( "Yes" ) ; }
int setBitCount ( int n ) { int ans = 0 ; while ( n > 0 ) { ans += n & 1 ; n >>= 1 ; } return ans ; }
bool isPronic ( int n ) { int range = ( int ) Math . Sqrt ( n ) ; for ( int i = 0 ; i < range + 1 ; i ++ ) { if ( i * ( i + 1 ) == n ) return true ; } return false ; }
int LOG ( int a , int b ) { return ( int ) ( Math . Log ( a ) / Math . Log ( b ) ) ; }
void countSubsequences ( int [ ] A ) { int odd = 0 ; int even = 0 ; foreach ( int el in A ) { if ( el % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 ) Console . WriteLine ( 0 ) ; else Console . WriteLine ( 1 << ( A . Length - 1 ) ) ; }
int gcd ( int a , int b ) { while ( b > 0 ) { int rem = a % b ; a = b ; b = rem ; } return a ; }
int countNumberOfWays ( int n ) { if ( n == 1 ) return - 1 ; int g = 0 ; int power = 0 ; while ( n % 2 == 0 ) { power ++ ; n /= 2 ; } g = gcd ( g , power ) ; for ( int i = 3 ; i <= ( int ) Math . Sqrt ( n ) ; i += 2 ) { power = 0 ; while ( n % i == 0 ) { power ++ ; n /= i ; } g = gcd ( g , power ) ; } if ( n > 2 ) g = gcd ( g , 1 ) ; int ways = 1 ; power = 0 ; while ( g % 2 == 0 ) { g /= 2 ; power ++ ; } ways *= ( power + 1 ) ; for ( int i = 3 ; i <= ( int ) Math . Sqrt ( g ) ; i += 2 ) { power = 0 ; while ( g % i == 0 ) { power ++ ; g /= i ; } ways *= ( power + 1 ) ; } if ( g > 2 ) ways *= 2 ; return ways ; }
bool coprime ( int a , int b ) { if ( GCD ( a , b ) == 1 ) return true ; return false ; }
void noOfCoPrimePairs ( int N , int d1 , int d2 ) { List < string > l = new List < string > ( ) ; l . Add ( d1 . ToString ( ) ) ; l . Add ( d2 . ToString ( ) ) ; l . Sort ( ) ; if ( N < Int32 . Parse ( l [ 1 ] ) ) return ; List < string > total = new List < string > ( l ) ; List < string > temp2 = new List < string > ( l ) ; int flag = 0 ; List < string > temp3 = new List < string > ( ) ; while ( l [ 0 ] . Length < 10 ) { for ( int i = 0 ; i < l . Count ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { if ( Int32 . Parse ( l [ i ] + temp2 [ j ] ) > N ) { flag = 1 ; break ; } total . Add ( l [ i ] + temp2 [ j ] ) ; temp3 . Add ( l [ i ] + temp2 [ j ] ) ; } if ( flag == 1 ) break ; } if ( flag == 1 ) break ; l = temp3 ; temp3 . Clear ( ) ; } int lenOfTotal = total . Count ; int ans = numOfPairs ( total , lenOfTotal ) ; Console . WriteLine ( ans ) ; }
void countEqualElementPairs ( int [ ] arr , int N ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! map . ContainsKey ( arr [ i ] ) ) map [ arr [ i ] ] = 1 ; else map [ arr [ i ] ] ++ ; } int total = 0 ; foreach ( KeyValuePair < int , int > e in map ) { total += ( e . Value * ( e . Value - 1 ) ) / 2 ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( total - ( map [ arr [ i ] ] - 1 ) + " " ) ; } }
void minDeletions ( int [ ] arr , int N ) { Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . ContainsKey ( arr [ i ] ) ) freq [ arr [ i ] ] ++ ; else freq [ arr [ i ] ] = 1 ; } List < int > v = new List < int > ( ) ; foreach ( var z in freq ) { v . Add ( z . Value ) ; } int sz = v . Count ; int [ ] temp = new int [ sz ] ; for ( int i = 0 ; i < v . Count ; i ++ ) temp [ i ] = v [ i ] ; Array . Sort ( temp ) ; for ( int i = 0 ; i < v . Count ; i ++ ) v [ i ] = temp [ i ] ; int size = v . Count ; int ans = N - ( v [ 0 ] * size ) ; for ( int i = 1 ; i < v . Count ; i ++ ) { if ( v [ i ] != v [ i - 1 ] ) { int safe = v [ i ] * ( size - i ) ; ans = Math . Min ( ans , N - safe ) ; } } Console . WriteLine ( ans ) ; }
int countPairs ( int [ ] arr , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; } int ans = ( N - odd + odd / 2 - 1 ) + odd / 2 ; return ans ; }
int countBit ( int n ) { return ( int ) ( ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ) ; }
int countSetBit ( int n ) { int ans = 0 ; while ( n > 0 ) { ans += ( n & 1 ) ; n >>= 1 ; } return ans ; }
int maximize ( int n ) { int bits = countBit ( n ) ; int setBits = countSetBit ( n ) ; int ans = 0 ; for ( int i = 0 ; i < bits ; i ++ ) { if ( i < setBits ) ans |= 1 ; if ( i != setBits - 1 ) ans <<= 1 ; } return ans ; }
int minimize ( int n ) { int setBits = countSetBit ( n ) ; int ans = 0 ; for ( int i = 0 ; i < setBits ; i ++ ) { ans |= 1 ; if ( i != setBits - 1 ) ans <<= 1 ; } return ans ; }
int maxDiff ( int [ ] arr ) { int caseOne = 0 ; int SumOfOdd = 0 ; int SumOfeven = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( ( i % 2 ) != 0 ) SumOfOdd += minimize ( arr [ i ] ) ; else SumOfeven += maximize ( arr [ i ] ) ; } caseOne = Math . Abs ( SumOfOdd - SumOfeven ) ; int caseTwo = 0 ; SumOfOdd = 0 ; SumOfeven = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( ( i % 2 ) != 0 ) SumOfOdd += maximize ( arr [ i ] ) ; else SumOfeven += minimize ( arr [ i ] ) ; } caseTwo = Math . Abs ( SumOfOdd - SumOfeven ) ; return Math . Max ( caseOne , caseTwo ) ; }
bool isVowel ( char c ) { string vowel = "aeiou" ; for ( int i = 0 ; i < vowel . Length ; ++ i ) { if ( vowel [ i ] == c ) { return true ; } } return false ; }
bool printRLE ( string str , string typed ) { int n = str . Length , m = typed . Length ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != typed [ j ] ) { return false ; } if ( isVowel ( str [ i ] ) == false ) { j ++ ; continue ; } int count1 = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count1 ++ ; i ++ ; } int count2 = 1 ; while ( j < m - 1 && typed [ j ] == str [ i ] ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) { return false ; } } return true ; }
void findSplit ( int [ ] arr , int N ) { int l = 1 , r = N - 2 ; int lsum , msum , rsum ; int [ ] sum = new int [ N ] ; sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { sum [ i ] = sum [ i - 1 ] + arr [ i ] ; } while ( l < r ) { lsum = sum [ l - 1 ] ; msum = sum [ r - 1 ] - sum [ l ] ; rsum = sum [ N - 1 ] - sum [ r ] ; if ( lsum == msum && msum == rsum ) { Console . Write ( l + " " + r ) ; return ; } if ( lsum < rsum ) l ++ ; else if ( lsum > rsum ) r -- ; else { l ++ ; r -- ; } } Console . Write ( - 1 ) ; }
int solve ( int [ ] A , int n , int [ ] Q , int q ) { int one = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( A [ i ] == 1 ) one ++ ; int glows = 0 , count = 0 ; if ( one >= ( int ) Math . Ceiling ( ( double ) n / 2 ) ) glows = 1 ; for ( int i = 0 ; i < q ; i ++ ) { int prev = glows ; if ( A [ Q [ i ] - 1 ] == 1 ) one -- ; if ( A [ Q [ i ] - 1 ] == 0 ) one ++ ; A [ Q [ i ] - 1 ] ^= 1 ; if ( one >= ( int ) Math . Ceiling ( ( double ) n / 2.0 ) ) { glows = 1 ; } else { glows = 0 ; } if ( prev != glows ) count ++ ; } return count ; }
void elementsHavingDigitSumK ( int [ ] arr , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( sumOfDigits ( arr [ i ] ) == K ) { count ++ ; } } Console . WriteLine ( count ) ; }
int processDiagonal ( List < int > arr ) { int ans = 0 ; int getBit = 1 ; for ( int i = 0 ; i < 32 ; i ++ ) { int S = 0 ; int NS = 0 ; foreach ( int j in arr ) { if ( ( getBit & j ) != 0 ) S += 1 ; else NS += 1 ; } if ( S > NS ) ans += ( int ) Math . Pow ( 2 , i ) ; getBit <<= 1 ; } return ans ; }
int findSum ( int [ , ] mat ) { int i = 0 ; int j = 0 ; List < int > priDiag = new List < int > ( ) ; while ( i < mat . GetLength ( 0 ) ) { priDiag . Add ( mat [ i , j ] ) ; i += 1 ; j += 1 ; } i = 0 ; j = mat . GetLength ( 0 ) - 1 ; List < int > secDiag = new List < int > ( ) ; while ( i < mat . GetLength ( 0 ) ) { secDiag . Add ( mat [ i , j ] ) ; i += 1 ; j -= 1 ; } return ( processDiagonal ( priDiag ) + processDiagonal ( secDiag ) ) ; }
void minimumDifference ( int N ) { int sum1 = ( 1 << N ) , sum2 = 0 ; for ( int i = 1 ; i < N / 2 ; i ++ ) sum1 += ( 1 << i ) ; for ( int i = N / 2 ; i < N ; i ++ ) sum2 += ( 1 << i ) ; Console . WriteLine ( sum1 - sum2 ) ; }
