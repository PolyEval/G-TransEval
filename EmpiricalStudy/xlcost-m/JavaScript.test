function sumOfTwoCubes ( n ) { var lo = 1 , hi = ( n ) ; while ( lo <= hi ) { var curr = ( lo * lo * lo + hi * hi * hi ) ; if ( curr == n ) return true ; if ( curr < n ) lo ++ ; else hi -- ; } return false ; }
function countPairs ( a , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] != 0 && a [ i ] % a [ j ] == 0 ) { if ( ( a [ i ] + a [ j ] ) == ( a [ i ] / a [ j ] ) ) count ++ ; } } } return count ; }
function check ( A , B ) { if ( A == B ) { return 1 ; } let dig1 = Math . floor ( Math . log10 ( A ) + 1 ) ; let dig2 = Math . floor ( Math . log10 ( B ) + 1 ) ; if ( dig1 != dig2 ) { return 0 ; } let temp = A ; while ( true ) { let power = Math . pow ( 10 , dig1 - 1 ) ; let firstdigit = parseInt ( A / power , 10 ) ; A = A - firstdigit * power ; A = A * 10 + firstdigit ; if ( A == B ) { return 1 ; } if ( A == temp ) { return 0 ; } } }
function checkPronic ( x ) { for ( let i = 0 ; i <= parseInt ( Math . sqrt ( x ) ) ; i ++ ) { if ( x == i * ( i + 1 ) ) { return true ; } } return false ; }
function oddDivisors ( arr , N ) { for ( i = 0 ; i < N ; i ++ ) { var powerOfTwo = 2 ; var count = 0 ; while ( powerOfTwo <= arr [ i ] ) { count ++ ; powerOfTwo = 2 * powerOfTwo ; } document . write ( count + "▁" ) ; } return ; }
function calcScr ( arr ) { let ans = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) ans += ( i ^ arr [ i ] ) ; return ans ; }
function maxAdjacent ( arr , N ) { let res = [ ] ; let arr_max = Number . MIN_VALUE ; for ( let i = 1 ; i < N ; i ++ ) { arr_max = Math . max ( arr_max , Math . abs ( arr [ i - 1 ] - arr [ i ] ) ) ; } for ( let i = 1 ; i < N - 1 ; i ++ ) { let curr_max = Math . abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; let ans = Math . max ( curr_max , arr_max ) ; res . push ( ans ) ; } document . write ( res . join ( "▁" ) ) ; }
function flippingBits ( N , K ) { let X = ( 1 << ( K - 1 ) ) - 1 ; N = X - N ; document . write ( N ) ; }
function countSetBits ( n ) { var count = 0 ; while ( n != 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
function minMoves ( arr , N ) { var odd_element_cnt = 0 ; var i ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } var moves = Math . floor ( ( odd_element_cnt ) / 2 ) ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; document . write ( moves ) ; }
function findSum ( arr , N ) { var mp = { } ; for ( let i = 0 ; i < N ; i ++ ) mp [ arr [ i ] ] = 0 ; for ( let i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } var sum_odd = 0 , sum_even = 0 ; for ( let itr in mp ) { if ( mp [ itr ] % 2 != 0 ) { sum_odd += ( itr ) * ( mp [ itr ] ) ; } if ( mp [ itr ] % 2 == 0 ) { sum_even += ( itr ) * ( mp [ itr ] ) ; } } var diff = sum_even - sum_odd ; return diff ; }
function findNumber ( arr , n ) { let res = 0 ; let maxElement = 0 ; for ( let i = 0 ; i < n ; i ++ ) { res = res ^ arr [ i ] ; if ( maxElement < arr [ i ] ) maxElement = arr [ i ] ; } res = onesComplement ( res , maxElement ) ; return ( res ) ; }
function findValOfNWithOperat ( N , K ) { if ( N % 2 == 0 ) { N += K * 2 ; } else { N += smallestDivisorGr1 ( N ) + ( K - 1 ) * 2 ; } return N ; }
function CntOfSubsetsByPartitioning ( arr , N ) { var freq = { } ; for ( var i = 0 ; i < N ; i ++ ) { if ( freq . hasOwnProperty ( arr [ i ] ) ) { freq [ arr [ i ] ] = freq [ arr [ i ] ] + 1 ; } else { freq [ arr [ i ] ] = 1 ; } } var freqGCD = 0 ; for ( const [ key , value ] of Object . entries ( freq ) ) { freqGCD = __gcd ( freqGCD , value ) ; } return parseInt ( N / freqGCD ) ; }
function alternatingSumOfFirst_N ( N ) { var alternateSum = 0 ; for ( i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { alternateSum += - i ; } else { alternateSum += i ; } } return alternateSum ; }
function countOperations ( arr , N ) { var count_zeros = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) count_zeros ++ ; } var sum = array_sum ( arr , N ) ; if ( count_zeros != 0 ) return count_zeros ; if ( sum == 0 ) return 1 ; return 0 ; }
function power ( x , N ) { let res = 1 ; while ( N > 0 ) { if ( N % 2 == 1 ) { res = ( res * x ) ; } x = ( x * x ) ; N = N >> 1 ; } return res ; }
function F_1 ( N , F_N ) { var P_2 = power ( 2 , N - 1 ) ; var modInv = moduloInverse ( P_2 ) ; var res ; res = ( ( modInv % M ) * ( F_N % M ) ) % M ; return res ; }
function findNumbers ( n ) { var i = 0 ; while ( i <= n ) { document . write ( 2 * i * i + 4 * i + 1 + i % 2 + "▁" ) ; i ++ ; } }
function isPower ( x , y ) { let res1 = Math . log ( y ) / Math . log ( x ) ; let res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; }
function countPairs ( A , B , N , M , List ) { var count = 0 ; var par = Array ( N + 1 ) ; for ( var i = 0 ; i <= N ; i ++ ) par [ i ] = i ; for ( var i = 0 ; i < M ; i ++ ) { var index1 = find ( par , List [ i ] [ 0 ] - 1 ) ; var index2 = find ( par , List [ i ] [ 1 ] - 1 ) ; if ( index1 != index2 ) { unionn ( par , index1 , index2 ) ; } } var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { mp . set ( A [ i ] , i ) ; } for ( var i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { if ( ! mp . has ( B [ i ] ) ) { count ++ ; continue ; } var j = mp . get ( B [ i ] ) ; if ( find ( par , i ) != find ( par , j ) ) count ++ ; } } return count ; }
function minDivisior ( n ) { if ( prime ( n ) ) { document . write ( 1 + "▁" + ( n - 1 ) ) ; } else { for ( i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { document . write ( n / i + "▁" + ( n / i * ( i - 1 ) ) ) ; break ; } } } }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function Find_min ( diff_mod , count_mod , k ) { let min_oprn = Number . MAX_VALUE ; let oprn = 0 ; for ( let x = 0 ; x < k ; x ++ ) { oprn = 0 ; for ( let w of diff_mod . values ( ) ) { if ( w != x ) { if ( w == 0 ) { oprn += Math . min ( x , k - x ) * count_mod . get ( w ) ; } else { oprn += Math . min ( Math . abs ( x - w ) , k + x - w ) * count_mod . get ( w ) ; } } } if ( oprn < min_oprn ) min_oprn = oprn ; } return min_oprn ; }
function maxSubarrayRatio ( arr , n ) { var maxRatio = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i ; j < n ; j ++ ) { var ratio = arr [ i ] ; for ( var k = i + 1 ; k <= j ; k ++ ) { ratio = ratio / arr [ k ] ; } maxRatio = maximum ( maxRatio , ratio ) ; } } return maxRatio ; }
function is_possible ( x , y ) { if ( x < 2 && y != 0 ) return false ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return true ; else return false ; }
function sum_of_differences ( arr , N ) { let sum = 0 ; let i , j , flag ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) { flag = 0 ; for ( j = i + 1 ; j < N - 1 ; j ++ ) { if ( arr [ j ] >= arr [ j + 1 ] ) { sum += ( arr [ j ] - arr [ i ] ) ; i = j ; flag = 1 ; break ; } } if ( flag == 0 && arr [ i ] < arr [ N - 1 ] ) { sum += ( arr [ N - 1 ] - arr [ i ] ) ; break ; } } } return sum ; }
function getLastTwoPerson ( n ) { var total = n ; var head = new Node ( 1 ) ; var temp = head ; for ( var i = 2 ; i <= n ; i ++ ) { temp . next = new Node ( i ) ; temp = temp . next ; } temp . next = head ; temp = head ; var del ; while ( total != 2 ) { del = temp . next . next ; temp . next . next = temp . next . next . next ; temp = temp . next ; total -= 1 ; } document . write ( temp . val + "▁" + temp . next . val ) ; }
function gcd ( x , y ) { if ( x == 0 ) return y ; return gcd ( y % x , x ) ; }
function check ( n ) { let temp = n ; while ( temp > 0 ) { let last_digit = temp % 10 ; if ( last_digit == 0 last_digit == 1 ) return false ; if ( n % last_digit == 0 ) return false ; temp = Math . floor ( temp / 10 ) ; } return true ; }
function costOfSubsequence ( N , arr , costArray ) { let i , temp ; let cost = 0 ; let removedElements = new Set ( ) ; let ans = 0 ; for ( i = 1 ; i < ( N - 1 ) ; i ++ ) { temp = arr [ i ] ; if ( ( ( arr [ i - 1 ] < temp ) && ( temp < arr [ i + 1 ] ) ) || ( ( arr [ i - 1 ] > temp ) && ( temp > arr [ i + 1 ] ) ) ) { removedElements . add ( temp ) ; } } for ( i = 0 ; i < ( N ) ; i ++ ) { temp = arr [ i ] ; if ( ! removedElements . has ( temp ) ) { ans += arr [ i ] ; } else { cost += costArray [ i ] ; } } document . write ( ans + ",▁" ) ; document . write ( cost ) ; }
function findRatio ( arr , n ) { var gcd = findGCD ( arr , n ) ; var lcm = findLCM ( arr , n ) ; document . write ( ( lcm / gcd ) ) ; document . write ( ":1" ) ; }
function PentacontahenagonNum ( N ) { return ( 49 * N * N - 47 * N ) / 2 ; }
function isRepdigit ( num , b ) { let prev = - 1 ; while ( num != 0 ) { let digit = num % b ; num = parseInt ( num / b ) ; if ( prev != - 1 && digit != prev ) return false ; prev = digit ; } return true ; }
function isHonakerPrime ( n ) { let pos = position [ n ] ; if ( pos == - 1 ) return false ; return getSum ( n ) == getSum ( pos ) ; }
function checkDivisibility ( n , digit ) { return ( digit != 0 && n % digit == 0 ) ; }
function lastDigit ( n ) { return ( n % 10 ) ; }
function count ( arr , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( check ( arr [ i ] & arr [ j ] ) ) cnt ++ ; } } return cnt ; }
function calculate_SPF ( ) { for ( var i = 0 ; i <= MAX ; i ++ ) spf [ i ] = i ; for ( var i = 4 ; i <= MAX ; i += 2 ) spf [ i ] = 2 ; for ( var i = 3 ; i * i <= MAX ; i ++ ) { if ( spf [ i ] == i ) { for ( var j = i * i ; j <= MAX ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
function isBrilliant ( n ) { let flag = 0 ; let isPrime = Array ( n + 1 ) . fill ( true ) ; SieveOfEratosthenes ( n , isPrime ) ; for ( let i = 2 ; i < n ; i ++ ) { let x = n / i ; if ( isPrime [ i ] && isPrime [ x ] && ( x * i ) == n ) { if ( countDigit ( i ) == countDigit ( x ) ) return true ; } } return false ; }
function icosikaienneagonalNum ( n ) { return ( 27 * n * n - 25 * n ) / 2 ; }
function isPerfectTotientNum ( n ) { let temp = n ; let sum = 0 ; while ( n > 1 ) { sum = sum + phi ( n ) ; n = phi ( n ) ; } if ( sum == temp ) return true ; return false ; }
function nCr ( n , r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
function solve ( N ) { let ans = 0 ; while ( N != 0 ) { ans += N ; N = parseInt ( N / 2 , 10 ) ; } document . write ( ans ) ; }
function smallestNumber ( N ) { let L = Math . pow ( 10 , N ) - 1 ; let S = Math . pow ( 10 , N - 1 ) ; for ( let i = S ; i <= L ; i ++ ) { if ( i % N == 0 ) { document . write ( i ) ; return ; } } }
function maxAdjacentDifference ( N , K ) { if ( N == 1 ) { return 0 ; } if ( N == 2 ) { return K ; } return 2 * K ; }
function CountPairs ( arr , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return ( even * ( even - 1 ) ) / 2 + ( even * odd ) ; }
function getSum ( n ) { let sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = Math . floor ( n / 10 ) ; } return sum ; }
function smallestNumber ( N ) { let i = 1 ; while ( 1 ) { if ( getSum ( i ) == N ) { document . write ( i ) ; break ; } i ++ ; } }
function isZuckerman ( n ) { return n % getProduct ( n ) == 0 ; }
function isGiugaNum ( n ) { if ( ! ( isComposite ( n ) ) ) return false ; let N = n ; while ( n % 2 == 0 ) { if ( ( N / 2 - 1 ) % 2 != 0 ) return false ; n = n / 2 ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( ( N / i - 1 ) % i != 0 ) return false ; n = n / i ; } } if ( n > 2 ) if ( ( N / n - 1 ) % n != 0 ) return false ; return true ; }
function updateFreq ( n , freq ) { while ( n > 0 ) { let digit = n % TEN ; freq [ digit ] ++ ; n = parseInt ( n / TEN ) ; } }
function OrmistonPrime ( n1 , n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && areAnagrams ( n1 , n2 ) ) ; }
function calculateKummer ( n ) { let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) result = result * primes [ i ] ; return - 1 + result ; }
function SieveOfEratosthenes ( maxm ) { prime [ 0 ] = prime [ 1 ] = true ; for ( let i = 2 ; i * i <= maxm ; i ++ ) { if ( ! prime [ i ] ) { for ( let j = i * i ; j <= maxm ; j += i ) { prime [ j ] = true ; } } } }
function func ( arr , n ) { let ans = 0 ; let maxx = 0 ; let freq = Array . from ( { length : 100005 } , ( _ , i ) => 0 ) ; let temp ; for ( let i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = Math . max ( maxx , temp ) ; } for ( let i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( let i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] != 0 ) { let j ; let cur = Math . ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { let val = Math . min ( maxx , ( Math . ceil ( i * j ) - 1.0 ) ) ; let times = ( freq [ i ] - freq [ i - 1 ] ) , con = ( j - 0.5 ) ; ans += times * con * ( freq [ val ] - freq [ cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ans ; }
function findAverageOfCube ( n ) { let sum = 0 ; let i ; for ( i = 1 ; i <= n ; i ++ ) { sum += i * i * i ; } return sum / n ; }
function find ( x ) { if ( x == 0 ) return 0 ; let p = Math . log2 ( x ) ; return binpow ( 2 , p + 1 ) - 1 ; }
function totalCountDifference ( n ) { let ans = getBinary ( n ) ; let req = 0 ; for ( let i = 0 ; i < ans . length ; i ++ ) { if ( ans [ i ] == "1" ) { req += find ( binpow ( 2 , i ) ) ; } } return req ; }
function findIndex ( n ) { let x = Math . sqrt ( 2 * Math . pow ( 10 , ( n - 1 ) ) ) ; return Math . round ( x ) ; }
function getParity ( n , A ) { for ( let x in A ) { if ( ( x & 1 ) == 1 ) { document . write ( "Even" ) ; return ; } } document . write ( "Odd" ) ; }
function lastTwoDigits ( N ) { if ( N >= 10 ) { cout << "00" ; return ; } let fac = 1 ; for ( let i = 1 ; i <= N ; i ++ ) fac = ( fac * i ) % 100 ; document . write ( fac ) ; }
function gcd ( a , b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }
function findArrangement ( N ) { if ( N < 3 ) return 0 ; return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) / 3 ; }
function sumOfProductOfDigits ( n1 , n2 ) { let sum = 0 ; while ( n1 > 0 && n2 > 0 ) { sum += ( ( n1 % 10 ) * ( n2 % 10 ) ) ; n1 = Math . floor ( n1 / 10 ) ; n2 = Math . floor ( n2 / 10 ) ; } return sum ; }
function divisorsSame ( n ) { return ( n - 2 ) % 4 == 0 ; }
function countSubsequences ( arr , n ) { var totalSubsequence = Math . pow ( 2 , n ) - 1 ; var countPrime = 0 , countOnes = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) countOnes ++ ; else if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } var compositeSubsequence ; var onesSequence = Math . pow ( 2 , countOnes ) - 1 ; compositeSubsequence = totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ; return compositeSubsequence ; }
function Centered_Hexadecagonal_num ( n ) { return ( 8 * n * n - 8 * n + 1 ) ; }
function isdecagonal ( N ) { let n = ( 3 + Math . sqrt ( 16 * N + 9 ) ) / 8 ; return ( n - parseInt ( n ) ) == 0 ; }
function ishendecagonal ( N ) { let n = ( 7 + Math . sqrt ( 72 * N + 49 ) ) / 18 ; return ( n - parseInt ( n ) ) == 0 ; }
function isenneadecagonal ( N ) { let n = parseFloat ( 15 + Math . sqrt ( 136 * N + 225 ) ) / 34 ; return ( n - parseInt ( n ) ) == 0 }
function isPowerOfTwo ( n ) { return ( Math . ceil ( Math . log ( n ) / Math . log ( 2 ) ) == Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; }
function cntArray ( A , N ) { let result = 0 ; let frequency = Array . from ( { length : N + 1 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { frequency [ A [ i ] ] ++ ; } for ( let i = 1 ; i <= N ; i ++ ) { let frequency_of_i = frequency [ i ] ; result += ( ( frequency_of_i ) * ( frequency_of_i + 1 ) ) / 2 ; } document . write ( result ) ; }
function solve ( A ) { let i , ctr = 0 ; for ( i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] % 2 ) { ctr ++ ; } } if ( ctr % 2 ) { return "No" ; } else { return "Yes" ; } }
function findNumbers ( N ) { for ( var i = 1 ; i <= N / 2 ; i ++ ) { document . write ( i + ",▁" + - i + ",▁" ) ; } if ( N % 2 == 1 ) document . write ( 0 ) ; }
function previousPerfectSquare ( N ) { let prevN = Math . floor ( Math . sqrt ( N ) ) ; if ( prevN * prevN == N ) prevN -= 1 ; return prevN * prevN ; }
function digit_sum ( n ) { let sum = 0 , m ; while ( n > 0 ) { m = n % 10 ; sum = sum + m ; n = parseInt ( n / 10 , 10 ) ; } return ( sum ) ; }
function dfs ( node , parent ) { if ( isPerfect ( weight [ node ] ) ) ans += 1 ; graph [ node ] . forEach ( to => { if ( to != parent ) dfs ( to , node ) ; } ) ; }
function MinimumGCD ( arr , n ) { var g = 0 ; var i ; for ( i = 0 ; i < n ; i ++ ) { g = calGCD ( g , arr [ i ] ) ; } return g ; }
function fibonacciSubarrays ( arr , n ) { var count = 0 ; for ( var i = 0 ; i < n ; ++ i ) { var sum = 0 ; for ( var j = i ; j < n ; ++ j ) { sum += arr [ j ] ; if ( isFibonacci ( sum ) ) { ++ count ; } } } document . write ( count ) ; }
function Gill ( x0 , y0 , x , h ) { let n = ( ( x - x0 ) / h ) ; let k1 , k2 , k3 , k4 ; let y = y0 ; for ( let i = 1 ; i <= n ; i ++ ) { k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; k3 = h * dydx ( x0 + 0.5 * h , y + 0.5 * ( - 1 + Math . sqrt ( 2 ) ) * k1 + k2 * ( 1 - 0.5 * Math . sqrt ( 2 ) ) ) ; k4 = h * dydx ( x0 + h , y - ( 0.5 * Math . sqrt ( 2 ) ) * k2 + k3 * ( 1 + 0.5 * Math . sqrt ( 2 ) ) ) ; y = y + ( 1.0 / 6 ) * ( k1 + ( 2 - Math . sqrt ( 2 ) ) * k2 + ( 2 + Math . sqrt ( 2 ) ) * k3 + k4 ) ; x0 = x0 + h ; } return y ; }
function PythagoreanTriplet ( n ) { let flag = 0 ; for ( let a = 1 ; a < n ; a ++ ) { let b = ( n * n - 2 * n * a ) / ( 2 * n - 2 * a ) ; let c = n - a - b ; if ( a * a + b * b == c * c && b > 0 && c > 0 ) { document . write ( a + "▁" + b + "▁" + c ) ; flag = 1 ; break ; } } if ( flag == 0 ) { document . write ( "-1" ) ; } return ; }
function Display ( arr , Expo_Prime , n ) { for ( let i = 0 ; i < n ; i ++ ) if ( Expo_Prime [ arr [ i ] ] ) document . write ( arr [ i ] + "▁" ) ; }
function operations ( N ) { var x = probability ( N ) ; var y = parseInt ( Math . pow ( 2 , N ) ) ; return round ( x / y , 2 ) ; }
function pairs ( n ) { let c = new Array ( 10 ) ; for ( var i = 0 ; i < c . length ; i ++ ) { c [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < c . length ; i ++ ) { for ( var j = 0 ; j < c . length ; j ++ ) { c [ i ] [ j ] = 0 ; } } let tmp = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ Math . floor ( i / tmp ) ] [ i % 10 ] ++ ; } let ans = 0 ; for ( let i = 1 ; i < 10 ; i ++ ) for ( let j = 1 ; j < 10 ; j ++ ) ans += c [ i ] [ j ] * c [ j ] [ i ] ; return ans ; }
function gcdFibonacciFreq ( arr , n ) { let hash = new Set ( ) ; createHash ( hash , arr . sort ( ( a , b ) => b - a ) [ 0 ] ) ; let i , j ; let m = new Map ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( m . has ( arr [ i ] ) ) { m . set ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) } else { m . set ( arr [ i ] , 1 ) } } let gcd = 0 ; for ( let it of m ) { if ( hash . has ( it [ 1 ] ) ) { gcd = __gcd ( gcd , it [ 0 ] ) ; } } return gcd ; }
function sumBaseB ( a , b , base_var ) { let len_a , len_b ; len_a = a . length ; len_b = b . length ; let sum , s ; s = "" ; sum = "" ; let diff ; diff = Math . abs ( len_a - len_b ) ; for ( let i = 1 ; i <= diff ; i ++ ) s += "0" ; if ( len_a < len_b ) a = s + a ; else b = s + b ; let curr , carry = 0 ; for ( let i = Math . max ( len_a , len_b ) - 1 ; i > - 1 ; i -- ) { curr = carry + ( a [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ) + ( b [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ) ; carry = parseInt ( curr / base_var , 10 ) ; curr = curr % base_var ; sum = String . fromCharCode ( curr + "0" . charCodeAt ( ) ) + sum ; } if ( carry > 0 ) sum = String . fromCharCode ( carry + "0" . charCodeAt ( ) ) + sum ; return sum ; }
function isPerfectCube ( x ) { var cr = Math . round ( Math . cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; }
function countPairsWithProdK ( arr , n , k ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == k ) count ++ ; } return count ; }
function genArray ( arr , N ) { for ( var i = 0 ; i < N - 1 ; i ++ ) { if ( search ( arr , i , arr [ i ] ) == - 1 ) arr [ i + 1 ] = 0 ; else arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) ; } }
function getPerfectcubes ( n ) { let perfectcubes = [ ] ; let current = 1 ; let i = 1 ; while ( current <= n ) { perfectcubes . push ( current ) ; i += 1 ; current = parseInt ( Math . pow ( i , 3 ) ) ; } return perfectcubes ; }
function insertPF ( primeFact , fact ) { if ( primeFact . has ( fact ) ) { primeFact . set ( fact , primeFact . get ( fact ) + 1 ) ; } else { primeFact . set ( fact , 1 ) ; } return primeFact ; }
function isPerfectSquare ( x ) { var sr = Math . round ( Math . sqrt ( x ) ) ; if ( sr * sr == x ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function canBePerfectCube ( N , K ) { if ( isPerfectCube ( N + K ) || isPerfectCube ( N - K ) ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function summation ( n ) { var abs_sum = n * ( n + 1 ) / 2 ; var sign = n + 1 % 2 == 0 ? 1 : - 1 ; var result_sum = sign * abs_sum ; return result_sum ; }
function findArray ( xorr , n ) { let arr = [ ] ; let xor_all = xor_all_elements ( n ) ; let xor_adjacent = 0 ; for ( let i = 0 ; i < n - 1 ; i += 2 ) { xor_adjacent = xor_adjacent ^ xorr [ i ] ; } let last_element = xor_all ^ xor_adjacent ; arr . push ( last_element ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) { last_element = xorr [ i ] ^ last_element ; arr . push ( last_element ) ; } return arr ; }
function compute ( ) { for ( var i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i ) ; } }
function calNum ( year ) { return parseInt ( year / 4 , 10 ) - parseInt ( year / 100 , 10 ) + parseInt ( year / 400 , 10 ) ; }
function maxValue ( n ) { return n ; }
function findSum ( arr , n ) { sieve ( MAX ) ; for ( i = 0 ; i < n ; i ++ ) { var sum = min_prime [ arr [ i ] ] + max_prime [ arr [ i ] ] ; document . write ( sum + "▁" ) ; } }
function squareRoot ( n , l ) { let x = n ; let root ; let count = 0 ; while ( true ) { count ++ ; root = 0.5 * ( x + ( n / x ) ) ; if ( Math . abs ( root - x ) < l ) break ; x = root ; } return root . toFixed ( 4 ) ; }
function countNumber ( N , S ) { let countElements = 0 ; let currSum = 0 ; while ( currSum <= S ) { currSum += N ; N -- ; countElements ++ ; } return countElements ; }
function countDistinct ( n ) { let arr = new Array ( 10 ) ; arr . fill ( 0 ) ; let count = 0 ; while ( n != 0 ) { let r = n % 10 ; arr [ r ] = 1 ; n = parseInt ( n / 10 , 10 ) ; } for ( let i = 0 ; i < 10 ; i ++ ) { if ( arr [ i ] != 0 ) count ++ ; } return count ; }
function lcm ( a , b ) { return ( a / __gcd ( a , b ) * b ) ; }
function checkZeroArray ( arr , n ) { let sum = 0 , maximum = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + arr [ i ] ; maximum = Math . max ( maximum , arr [ i ] ) ; } if ( sum % 2 == 0 && maximum <= sum / 2 ) return true ; return false ; }
function getSum ( n ) { var start = Math . pow ( 10 , n - 1 ) ; var end = Math . pow ( 10 , n ) - 1 ; var sum = 0 ; for ( var i = start ; i <= end ; i ++ ) { var s = ( i . toString ( ) ) ; if ( isPalindrome ( s ) ) { sum += i ; } } return sum ; }
function findMinDel ( arr , n ) { var min_num = 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) min_num = Math . min ( arr [ i ] , min_num ) ; var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; }
function isPossible ( x , y ) { if ( ( x - y ) == 1 ) return false ; return true ; }
function numSeq ( n ) { return Math . floor ( ( Math . pow ( 3 , n ) + 3 * Math . pow ( - 1 , n ) ) / 4 ) ; }
function digitDividesK ( num , k ) { while ( num ) { let d = num % 10 ; if ( d != 0 && k % d == 0 ) return true ; num = parseInt ( num / 10 ) ; } return false ; }
function xorK ( n , k ) { let res = n ; for ( let i = 1 ; i < k ; i ++ ) res = ( res ^ n ) ; return n ; }
function distinctDigits ( x ) { var present = new Array ( MAX ) . fill ( false ) ; while ( x > 0 ) { var digit = x % 10 ; if ( present [ digit ] ) return false ; present [ digit ] = true ; x = parseInt ( x / 10 ) ; } return true ; }
function isPossible ( arr , n , p ) { let gcd = 0 ; for ( let i = 0 ; i < n ; i ++ ) gcd = __gcd ( gcd , arr [ i ] ) ; if ( p % gcd == 0 ) return true ; return false ; }
function cntCakes ( n , m ) { let sum = ( n * ( n + 1 ) ) / 2 ; let quo = m / sum ; let rem = m % sum ; let ans = m - quo * sum + 6 ; let x = ( - 1 + Math . pow ( ( 8 * rem ) + 1 , 0.5 ) ) ; ans = ans - x * ( x + 1 ) / 2 ; return parseInt ( ans , 10 ) ; }
function factMod ( n ) { var fact = 1 ; for ( i = 2 ; i <= n ; i ++ ) { fact *= ( i % MOD ) ; fact %= MOD ; } return parseInt ( fact ) ; }
function isEulerPseudoprime ( N , A ) { if ( A <= 0 ) return false ; if ( N % 2 == 0 || ! isComposite ( N ) ) return false ; if ( __gcd ( A , N ) != 1 ) return false ; let mod = Power ( A , ( N - 1 ) / 2 , N ) ; if ( mod != 1 && mod != N - 1 ) return false ; return true ; }
function minDifference ( L , R ) { let fst = 0 ; for ( let i = L ; i <= R ; i ++ ) { if ( isPrime [ i ] ) { fst = i ; break ; } } let snd = 0 ; for ( let i = fst + 1 ; i <= R ; i ++ ) { if ( isPrime [ i ] ) { snd = i ; break ; } } if ( snd == 0 ) return - 1 ; let diff = snd - fst ; let left = snd + 1 ; let right = R ; for ( let i = left ; i <= right ; i ++ ) { if ( isPrime [ i ] ) { if ( i - snd <= diff ) { fst = snd ; snd = i ; diff = snd - fst ; } } } return diff ; }
function binomialCoeff ( n , k ) { var C = new Array ( n + 1 ) ; for ( var i = 0 ; i < C . length ; i ++ ) { C [ i ] = new Array ( k + 1 ) ; } var i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
function no_of_ways ( a , n ) { let count_0 = 0 , count_1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; } if ( count_1 % 2 == 0 ) return count_0 ; else return count_1 ; }
function longest_gap ( N ) { let distance = 0 , count = 0 , first_1 = - 1 , last_1 = - 1 ; while ( N ) { count ++ ; let r = N & 1 ; if ( r == 1 ) { first_1 = first_1 == - 1 ? count : first_1 ; last_1 = count ; } N = parseInt ( N / 2 ) ; } if ( last_1 <= first_1 ) { return - 1 ; } else { distance = ( last_1 - first_1 - 1 ) ; return distance ; } }
function isPossible ( n ) { let cnt = CountBits ( n ) ; if ( cnt == parseInt ( TOTAL_BITS / 2 ) ) return true ; return false ; }
function total_ways ( N , X ) { return ( nCr ( N - 1 , X - 1 ) + nCr ( N - 1 , X ) ) ; }
function getSum ( n ) { let sum = 0 ; let k = parseInt ( Math . sqrt ( n ) ) ; for ( let i = 1 ; i <= k ; i ++ ) { sum += Math . floor ( n / i ) ; } sum *= 2 ; sum -= Math . pow ( k , 2 ) ; return sum ; }
function getCount ( l , r , p ) { let cnt = 0 ; let val = p ; while ( 1 ) { let a = parseInt ( r / val ) ; let b = parseInt ( ( l - 1 ) / val ) ; val *= p ; if ( a - b ) { cnt += ( a - b ) ; } else break ; } return cnt ; }
function heapify ( arr , n , i ) { var smallest = i ; var l = 2 * i + 1 ; var r = 2 * i + 2 ; if ( l < n && arr [ l ] < arr [ smallest ] ) smallest = l ; if ( r < n && arr [ r ] < arr [ smallest ] ) smallest = r ; if ( smallest != i ) { [ arr [ i ] , arr [ smallest ] ] = [ arr [ smallest ] , arr [ i ] ] heapify ( arr , n , smallest ) ; } }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function nextPrime ( N ) { if ( N <= 1 ) return 2 ; let prime = N ; let found = false ; while ( ! found ) { prime ++ ; if ( isPrime ( prime ) ) found = true ; } return prime ; }
function find_Solution ( x , n ) { let sum = x , e = 2 , o = 1 , p = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { p += 2 ; sum += ( o / e ) * ( Math . pow ( x , p ) / p ) ; o = o * ( o + 2 ) ; e = e * ( e + 2 ) ; } document . write ( sum . toFixed ( 10 ) ) ; }
function solveOdd ( n , arr , b ) { let left = n - 1 ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) + 1 ; ++ i ) { b [ i ] = arr [ left ] ; left = left - 2 ; if ( left < 0 ) break ; } let right = 1 ; for ( let i = parseInt ( n / 2 , 10 ) + 1 ; i <= n - 1 ; ++ i ) { b [ i ] = arr [ right ] ; right = right + 2 ; if ( right > n - 2 ) break ; } }
function countSetBits ( n ) { n ++ ; var powerOf2 = 2 ; var cnt = n / 2 ; while ( powerOf2 <= n ) { var totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs % 2 == 1 ) ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; }
function nCr ( n ) { if ( n < 4 ) return 0 ; let answer = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; answer = parseInt ( answer / 24 ) ; return answer ; }
function ncr ( n , r ) { let ans = 1 ; for ( let i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans = parseInt ( ans / i ) ; } return ans ; }
function GCD ( a , b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
function findReachable ( arr , D , A , B , n ) { var gcd_AB = GCD ( A , B ) ; var count = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - D ) % gcd_AB == 0 ) count ++ ; } return count ; }
function getSum ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 && arr [ i ] == sumOfFactors ( arr [ i ] ) ) { sum += arr [ i ] ; } } return sum ; }
function isPossible ( k ) { if ( ! exists_zero ) { if ( k >= cnt_neg && ( k - cnt_neg ) % 2 == 0 ) return true ; else return false ; } else { if ( k >= cnt_neg ) return true ; else return false ; } }
function power ( x , y ) { var res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) ; y = y >> 1 ; x = ( x * x ) ; } return res ; }
function solve ( L ) { var n = L / 2 + 1 ; var ans = power ( n , n - 2 ) ; return ans ; }
function total_permutations ( freq ) { let cnt = 0 ; let denom = 1 ; for ( let [ key , value ] of freq . entries ( ) ) { denom *= fact ( value ) ; cnt += value ; } return Math . floor ( fact ( cnt ) / denom ) ; }
function solveQuery ( L , X ) { var res ; var a = Array ( MAXN ) , b = Array ( L ) ; var ref = X , size_a = 0 ; while ( ref > 0 ) { a [ size_a ] = ref % 2 ; ref = parseInt ( ref / 2 ) ; size_a ++ ; } for ( var i = 0 ; i < Math . min ( size_a , L ) ; i ++ ) { if ( a [ i ] == 1 ) b [ i ] = 0 ; else b [ i ] = 1 ; } for ( var i = Math . min ( size_a , L ) ; i < L ; i ++ ) b [ i ] = 1 ; b [ L - 1 ] = 1 ; var temp = 0 , p = 1 ; for ( var i = 0 ; i < L ; i ++ ) { temp += b [ i ] * p ; p *= 2 ; } res = temp ^ X ; return res ; }
function closetAND ( arr , n , k ) { let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let X = arr [ i ] ; for ( let j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; if ( X <= k ) break ; } } return ans ; }
function countQuadruplets ( l , r , k ) { let frequency = new Array ( r + 1 ) ; frequency . fill ( 0 ) ; for ( let i = l ; i <= r ; i ++ ) { for ( let j = l ; j <= r ; j ++ ) { frequency [ gcd ( i , j ) ] ++ ; } } let answer = 0 ; for ( let i = 1 ; i <= r ; i ++ ) { for ( let j = 1 ; j <= r ; j ++ ) { if ( gcd ( i , j ) == k ) { answer += ( frequency [ i ] * frequency [ j ] ) ; } } } return answer ; }
function maxBitElement ( arr , n ) { let num = 0 , max = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { let cnt = BitCount ( arr [ i ] ) ; if ( cnt > max ) { max = cnt ; num = arr [ i ] ; } } return num ; }
function Add_Edge ( u , v ) { gr [ u ] . push ( v ) ; gr [ v ] . push ( u ) ; }
function factorial ( n , p ) { for ( var i = 2 ; i <= n ; i ++ ) res = ( res * i ) % p ; return res ; }
function getValueOfF ( n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; let cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n = parseInt ( n / 2 , 10 ) ; } return 2 * cnt ; }
function printNumbers ( a , n , x ) { let flag = false ; for ( let i = 0 ; i < n ; i ++ ) { let num = a [ i ] ; let g = __gcd ( num , x ) ; while ( g != 1 ) { num = parseInt ( num / g ) ; g = __gcd ( num , x ) ; } if ( num == 1 ) { flag = true ; document . write ( a [ i ] + "▁" ) ; } } if ( ! flag ) document . write ( "There▁are▁no▁such▁numbers" ) ; }
function line ( x0 , y0 ) { var c = parseInt ( 2 * y0 * x0 ) ; document . write ( y0 + "x" + "▁+▁" + x0 + "y▁=▁" + c ) ; }
function isDudeney ( n ) { let cube_rt = parseInt ( Math . round ( ( Math . pow ( n , 1.0 / 3.0 ) ) ) ) ; if ( cube_rt * cube_rt * cube_rt != n ) return false ; let dig_sum = 0 ; let temp = n ; while ( temp > 0 ) { let rem = temp % 10 ; dig_sum += rem ; temp = parseInt ( temp / 10 ) ; } if ( cube_rt != dig_sum ) return false ; return true ; }
function Positive_Divisors ( ) { for ( let i = 1 ; i < N ; i ++ ) { for ( let j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) d [ i ] ++ ; else d [ i ] += 2 ; } } } let ans = 0 ; for ( let i = 2 ; i < N ; i ++ ) { if ( d [ i ] == d [ i - 1 ] ) ans ++ ; pre [ i ] = ans ; } }
function oddDays ( N ) { var hund1 = N / 100 ; var hund4 = N / 400 ; var leap = N >> 2 ; var ord = N - leap ; if ( hund1 > 0 ) { ord += hund1 ; leap -= hund1 ; } if ( hund4 > 0 ) { ord -= hund4 ; leap += hund4 ; } var days = ord + leap * 2 ; var odd = days % 7 ; return odd ; }
function ellipsearea ( r ) { if ( r < 0 ) return - 1 ; var a = ( ( 3.14 * r * r ) / 4 ) ; return a ; }
function recamanGenerator ( arr , n ) { arr [ 0 ] = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { var temp = arr [ i - 1 ] - i ; var j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == temp ) temp < 0 ) { temp = arr [ i - 1 ] + i ; break ; } } arr [ i ] = temp ; } }
function power ( a , n ) { if ( n == 0 ) return 1 ; var p = power ( a , parseInt ( n / 2 ) ) ; p = p * p ; if ( n % 2 == 1 ) p = p * a ; return p ; }
function findPairCount ( N , K ) { var count = 0 ; var rem = Array . from ( { length : K } , ( _ , i ) => 0 ) ; rem [ 0 ] = parseInt ( N / K ) ; for ( i = 1 ; i < K ; i ++ ) rem [ i ] = parseInt ( ( N - i ) / K + 1 ) ; if ( K % 2 == 0 ) { count += parseInt ( ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ) ; for ( i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }
function doesContainB ( a , b , c ) { if ( a == b ) { return true ; } if ( ( b - a ) * c > 0 && ( b - a ) % c == 0 ) { return true ; } return false ; }
function sieve ( ) { for ( let i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } prime [ 1 ] = false ; prime [ 0 ] = false ; for ( let i = 2 ; i < N ; i ++ ) { if ( prime [ i ] ) { for ( let j = i * 2 ; j < N ; j += i ) { prime [ j ] = false ; } } } }
function lastDigit ( a , b ) { var lastDig = ( a [ a . length - 1 ] - "0" ) * ( b [ b . length - 1 ] - "0" ) ; document . write ( lastDig % 10 ) ; }
function printPalindrome ( n ) { if ( n == 1 ) { document . write ( "Smallest▁Palindrome:▁0" ) ; document . write ( "Largest▁Palindrome:▁9" ) ; } else { document . write ( "Smallest▁Palindrome:▁" + ( parseInt ( Math . pow ( 10 , n - 1 ) ) + 1 ) ) ; document . write ( "Largest▁Palindrome:▁" + parseInt ( Math . pow ( 10 , n ) - 1 ) ) ; } }
function countDigits ( a , b ) { var count = 0 ; var p = Math . abs ( parseInt ( a / b ) ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = parseInt ( p / 10 ) ; } return count ; }
function nDigitPerfectCubes ( n ) { document . write ( Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n - 1 ) ) ) ) , 3 ) + "▁" ) ; document . write ( Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ) ; }
function sumOfSeries ( n ) { let ans = Math . pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; }
function countNumbers ( n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * Math . pow ( 10 , parseInt ( n / 2 ) - 1 ) ) ; }
function KthMinValAfterMconcatenate ( A , N , M , K ) { A . sort ( ( a , b ) => a - b ) return ( A [ ( ( K - 1 ) / M ) ] ) ; }
function factorial ( n ) { return ( n == 1 n == 0 ) ? 1 : factorial ( n - 1 ) * n ; }
function gcdOfFactorial ( arr , n ) { var minm = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) minm = minm > arr [ i ] ? arr [ i ] : minm ; return factorial ( minm ) ; }
function findMinimum ( n , m ) { var mini = m ; for ( var i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { var sec = n / i ; if ( __gcd ( m , i ) > 1 ) { return i ; } else if ( __gcd ( sec , m ) > 1 ) { mini = Math . min ( sec , mini ) ; } } } if ( mini == m ) return - 1 ; else return mini ; }
function getProbability ( a , b , c , d ) { var p = a / b ; var q = c / d ; var ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; }
function findMinSum ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; }
function getPosition ( n , m ) { if ( m > ( n / 2 ) ) return ( m - parseInt ( n / 2 ) ) ; return ( m + parseInt ( n / 2 ) ) ; }
function matrixOrValueOne ( arr ) { var p_arr = Array . from ( Array ( n ) , ( ) => Array ( n ) . fill ( 0 ) ) ; findPrefixCount ( p_arr , arr ) ; var count_zero_submatrices = 0 ; for ( var j = 0 ; j < n ; j ++ ) { var i = n - 1 ; var q = [ ] ; var to_sum = 0 ; while ( i >= 0 ) { var c = 0 ; while ( q . length != 0 && q [ q . length - 1 ] [ 0 ] > p_arr [ i ] [ j ] ) { to_sum -= ( q [ q . length - 1 ] [ 1 ] + 1 ) * ( q [ q . length - 1 ] [ 0 ] - p_arr [ i ] [ j ] ) ; c += q [ q . length - 1 ] [ 1 ] + 1 ; q . pop ( ) ; } to_sum += p_arr [ i ] [ j ] ; count_zero_submatrices += to_sum ; q . push ( [ p_arr [ i ] [ j ] , c ] ) ; i -- ; } } return ( n * ( n + 1 ) * n * ( n + 1 ) ) / 4 - count_zero_submatrices ; }
function count ( N , K , R ) { var sum = 0 ; for ( i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; }
function isSpiltPossible ( n , a ) { let sum = 0 , c1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }
function isSunnyNum ( n ) { if ( isPerfectSquare ( n + 1 ) ) return true ; return false ; }
function Cycles ( N ) { var fact = 1 , result = 0 ; result = N - 1 ; var i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; }
function getMaxNum ( a , b , c ) { if ( b % c == 0 ) return b ; var x = ( parseInt ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; }
function findAndSum ( arr , n ) { var sum = 0 ; var mul = 1 ; for ( var i = 0 ; i < 30 ; i ++ ) { var count_on = 0 ; var l = 0 ; for ( var j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) if ( count_on ) l ++ ; else { count_on = 1 ; l ++ ; } else if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = 0 ; l = 0 ; } } if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = 0 ; l = 0 ; } mul *= 2 ; } return sum ; }
function calcNodes ( N , I ) { var result = 0 ; result = I * ( N - 1 ) + 1 ; return result ; }
function findPrimeFactors ( ) { for ( let i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( let j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ parseInt ( j / i , 10 ) ] + 1 ; for ( let i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; }
function mixtureConcentration ( n , p ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return res ; }
function check ( num , a , b ) { while ( num > 0 ) { var rem = num % 10 ; num = parseInt ( num / 10 ) ; if ( rem != a && rem != b ) return false ; } return true ; }
function binomialCoeff ( n , k ) { if ( k > n ) return 0 ; var res = 1 ; if ( k > n - k ) k = n - k ; for ( var i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
function max_gcd ( n , p ) { let count = 0 ; let gcd = 1 ; while ( p % 2 == 0 ) { p >>= 1 ; count ++ ; } if ( count > 0 ) gcd *= Math . pow ( 2 , parseInt ( count / n , 10 ) ) ; for ( let i = 3 ; i <= parseInt ( Math . sqrt ( p ) , 10 ) ; i += 2 ) { count = 0 ; while ( p % i == 0 ) { count ++ ; p = parseInt ( p / i , 10 ) ; } if ( count > 0 ) { gcd *= Math . pow ( i , parseInt ( count / n , 10 ) ) ; } } if ( p > 2 ) gcd *= Math . pow ( p , parseInt ( 1 / n , 10 ) ) ; return gcd ; }
function fib ( n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] != 0 ) return f [ n ] ; let k = 0 ; if ( ( n & 1 ) != 0 ) k = ( n + 1 ) / 2 ; else k = n / 2 ; if ( ( n & 1 ) != 0 ) f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; else f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
function printSequence ( n ) { Sieve ( ) ; let v = [ ] ; let u = [ ] ; for ( let i = 13 ; i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { v . push ( i ) ; } } if ( n == 3 ) { document . write ( 6 + "▁" + 10 + "▁" + 15 ) ; return ; } let k ; for ( k = 0 ; k < n - 2 ; k ++ ) { if ( k % 3 == 0 ) { u . push ( v [ k ] * 6 ) ; } else if ( k % 3 == 1 ) { u . push ( v [ k ] * 15 ) ; } else { u . push ( v [ k ] * 10 ) ; } } k -- ; u . push ( v [ k ] * 7 ) ; u . push ( 7 * 11 ) ; u [ 0 ] = u [ 0 ] * 11 ; for ( let i = 0 ; i < u . length ; i ++ ) { document . write ( u [ i ] + "▁" ) ; } }
function checkSub ( sub , s ) { let j = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) if ( sub [ j ] == s [ i ] ) j ++ ; return j == sub . length ; }
function minPerfectCube ( arr , n ) { let minPerfectCube ; let lcm = lcmOfArray ( arr , n ) ; minPerfectCube = lcm ; let cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm = parseInt ( lcm / 2 ) ; } if ( cnt % 3 == 2 ) minPerfectCube *= 2 ; else if ( cnt % 3 == 1 ) minPerfectCube *= 4 ; let i = 3 ; while ( lcm > 1 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm = parseInt ( lcm / i ) ; } if ( cnt % 3 == 1 ) minPerfectCube *= i * i ; else if ( cnt % 3 == 2 ) minPerfectCube *= i ; i += 2 ; } return minPerfectCube ; }
function powerfulIntegers ( x , y , bound ) { var s = new Set ( ) ; var powersOfY = [ ] ; var i ; powersOfY . push ( 1 ) ; for ( i = y ; i < bound && y != 1 ; i = i * y ) powersOfY . push ( i ) ; i = 0 ; while ( true ) { var xPowI = Math . pow ( x , i ) ; powersOfY . forEach ( j => { var num = xPowI + j ; if ( num <= bound ) s . add ( num ) ; } ) ; if ( xPowI >= bound x == 1 ) break ; i ++ ; } [ ... s ] . sort ( ( a , b ) => a - b ) . forEach ( itr => { document . write ( itr + "▁" ) } ) ; }
function find_probability ( p , q , r , s ) { var t = ( 1 - p / q ) * ( 1 - r / s ) ; var ans = ( p / q ) / ( 1 - t ) ; return ans ; }
function distinctDigitSum ( n ) { var used = Array ( 10 ) . fill ( false ) ; var sum = 0 ; while ( n > 0 ) { var digit = n % 10 ; if ( ! used [ digit ] ) { used [ digit ] = true ; sum += digit ; } n = parseInt ( n / 10 ) ; } return sum ; }
function getDifference ( N ) { if ( N == 0 ) return 2 ; else if ( N == 1 ) return 1 ; else if ( isPrime ( N ) ) return 0 ; let aboveN = - 1 ; let belowN = - 1 ; let n1 = N + 1 ; while ( true ) { if ( isPrime ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; } n1 = N - 1 ; while ( true ) { if ( isPrime ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; } let diff1 = aboveN - N ; let diff2 = N - belowN ; return Math . min ( diff1 , diff2 ) ; }
function maxPrimeFactors ( n ) { var num = n ; var maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n = parseInt ( n / 2 ) ; } for ( var i = 3 ; i <= parseInt ( Math . sqrt ( n ) ) ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = parseInt ( n / i ) ; } } if ( n > 2 ) { maxPrime = n ; } var sum = maxPrime + num ; return sum ; }
function sumOfDigits ( n ) { var res = 0 ; while ( n > 0 ) { res += n % 10 ; n = parseInt ( n / 10 ) ; } return res ; }
function countIntervals ( arr , V , N ) { let min = Number . MAX_VALUE , max = Number . MIN_VALUE ; let li , ri ; let freq = new Array ( MAX_VAL ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] [ 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( let i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }
function sumEven ( l , r ) { return sumNatural ( Math . floor ( r / 2 ) ) - sumNatural ( Math . floor ( l - 1 ) / 2 ) ; }
function isPalindrome ( num ) { let reverse_num = 0 , remainder , temp ; temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_num = reverse_num * 10 + remainder ; temp = Math . floor ( temp / 10 ) ; } if ( reverse_num == num ) { return true ; } return false ; }
function countPairs ( n ) { let count = 0 ; for ( let x = 1 ; x < n ; x ++ ) { for ( let y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; }
function getResult ( n ) { if ( ( n & 1 ) > 0 ) return 1 ; return - 1 ; }
function sumAP ( n , d ) { n = parseInt ( n / d ) ; return ( n ) * ( 1 + n ) * ( d / 2 ) ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function minimum ( n ) { let product = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; product = product * i ; } } if ( n >= 2 ) product = product * n ; return product ; }
function productDivisible ( n , k ) { var product = 1 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 0 ) product *= n % 10 ; n = parseInt ( n / 10 ) ; position ++ ; } if ( product % k == 0 ) return true ; return false ; }
function sumAP ( n , d ) { n = parseInt ( n / d ) ; return ( n ) * ( ( 1 + n ) * parseInt ( d ) / 2 ) ; }
function factorial ( n ) { var fact = 1 ; for ( i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
function isTriangleExists ( a , b , c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return "YES" ; else return "NO" ; else return "NO" ; }
function fact ( n ) { var fact = 1 ; for ( i = 2 ; i <= n ; i ++ ) fact *= i ; return fact ; }
function ways ( m , w , n , k ) { var ans = 0 ; while ( m >= k ) { ans += ncr ( m , k ) * ncr ( w , n - k ) ; k += 1 ; } return parseInt ( ans ) ; }
function SieveOfEratosthenes ( ) { prime . fill ( true ) prime [ 1 ] = false ; prime [ 0 ] = false ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
function square ( n ) { return n * n ; }
function sum ( N ) { var S1 , S2 , S3 ; S1 = ( ( ( N / 2 ) ) * parseInt ( 2 * 2 + parseInt ( N / 2 - 1 ) * 2 ) / 2 ) ; S2 = ( parseInt ( parseInt ( N / 7 ) ) * ( 2 * 7 + parseInt ( N / 7 - 1 ) * 7 ) / 2 ) ; S3 = ( parseInt ( parseInt ( N / 14 ) ) * ( 2 * 14 + parseInt ( N / 14 - 1 ) * 14 ) / 2 ) ; return S1 + S2 - S3 ; }
function largestPrimeFactor ( n ) { var max = - 1 ; while ( n % 2 == 0 ) { max = 2 ; } for ( var i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { max = i ; n = n / i ; } } if ( n > 2 ) max = n ; return max ; }
function isStrongNumber ( n ) { var count = new Map ( ) ; while ( n % 2 == 0 ) { n = n / 2 ; if ( count . has ( 2 ) ) { count . set ( 2 , count . get ( 2 ) + 1 ) ; } else { count . set ( 2 , 1 ) ; } } for ( var i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { n = n / i ; if ( count . has ( i ) ) { count . set ( i , count . get ( i ) + 1 ) ; } else { count . set ( i , 1 ) ; } } } if ( n > 2 ) { if ( count . has ( n ) ) { count . set ( n , count . get ( n ) + 1 ) ; } else { count . set ( n , 1 ) ; } } var flag = 0 ; const iterator = count [ Symbol . iterator ] ( ) ; let itr = iterator . next ( )  for ( let i = 0 ; i < count . size ; i ++ ) { console . log ( itr . value , itr . done )  if ( itr . value == 1 ) { flag = 1 ; break ; } itr = iterator . next ( ) } if ( flag == 1 ) { return false ; } else { return true ; } }
function isChenPrime ( n ) { if ( isPrime ( n ) && ( isSemiprime ( n + 2 ) || isPrime ( n + 2 ) ) ) return true ; else return false ; }
function isPowerOfTwo ( n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
function Divisible ( str , n ) { if ( SumOfDigits ( str , n ) % 3 == 0 && str . charAt ( n - 1 ) == "0" ) return true ; return false ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
function NumberOfRectangles ( n , m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; }
function isPrime ( p ) { if ( p == 4 ) return false ; if ( fact ( p >> 1 ) % p == 0 ) { return 0 ; } return 1 ; }
function findNumUtil ( res , a , aCount , b , bCount , n ) { if ( res > 1e11 ) return 1e11 ; if ( aCount == bCount && res >= n ) return res ; return Math . min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) ) ; }
function isSumDivides ( N ) { var temp = N ; var sum = 0 ; while ( temp > 0 ) { sum += temp % 10 ; temp = parseInt ( temp / 10 ) ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }
function GoodNumber ( n ) { let v = PrimeFactors ( n ) ; let ans = 1 ; for ( let i = 0 ; i < v . length ; i ++ ) ans *= v [ i ] ; return ans ; }
function checkSpecialPrime ( sieve , num ) { while ( num != 0 ) { if ( ! sieve [ num ] ) { return false ; } num = Math . floor ( num / 10 ) ; } return true ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
function nthHarmonic ( N ) { let harmonic = 1.00 ; for ( let i = 2 ; i <= N ; i ++ ) { harmonic += parseFloat ( 1 ) / i ; } return harmonic ; }
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) + n - 2 ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + 4 * n - 2 ; }
function printAngles ( a , b , c ) { let x = a ; let y = b ; let z = c ; let A = findAnglesA ( x , y , z ) ; let B = findAnglesB ( x , y , z ) ; document . write ( "Angles▁are▁A▁=▁" + A + ",▁B▁=▁" + B + ",▁C▁=▁" + 90 ) ; }
function Bits ( kilobytes ) { var Bits = 0 ; Bits = kilobytes * 8192 ; return Bits ; }
function binomial ( ) { for ( var i = 0 ; i < MAX ; i ++ ) { for ( var j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function closest ( x ) { let ans = 0 ; while ( ans * 10 + 9 <= x ) ans = ans * 10 + 9 ; return ans ; }
function nthTerm ( N ) { return parseInt ( N * ( parseInt ( N / 2 ) + ( ( N % 2 ) * 2 ) + N ) ) ; }
function calculateSum ( n ) { return parseInt ( Math . pow ( n * ( n + 1 ) / 2 , 2 ) ) ; }
function digSum ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
function totEdge ( n ) { var result = 0 ; result = ( n * ( n - 1 ) ) / 2 ; return result ; }
function findFactors ( n ) { for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( ( n / i ) == i ) { factors . push ( i ) ; } else { factors . push ( n / i ) ; factors . push ( i ) ; } } } }
function checkPairs ( l , r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }
function calTime ( arr , n ) { var work = 0 ; for ( i = 0 ; i < n ; i ++ ) work += 1 / arr [ i ] ; return 1 / work ; }
function calculate_ways ( m , n ) { if ( m < n ) return 0 ; let ways = binomial_coefficient ( n + m - 1 , n - 1 ) ; return ways ; }
function powerLL ( x , n ) { let result = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) { result = result * x % MOD ; } n = Math . floor ( n / 2 ) ; x = x * x % MOD ; } return result ; }
function powerStrings ( sa , sb ) { let a = 0 , b = 0 ; for ( let i = 0 ; i < sa . length ; i ++ ) { a = ( a * 10 + ( sa [ i ] - "0" ) ) % MOD ; } for ( let i = 0 ; i < sb . length ; i ++ ) { b = ( b * 10 + ( sb [ i ] - "0" ) ) % ( MOD - 1 ) ; } return powerLL ( a , b ) ; }
function findNumbers ( n , w ) { let x = 0 , sum = 0 ; if ( w >= 0 && w <= 8 ) { x = 9 - w ; } else if ( w >= - 9 && w <= - 1 ) { x = 10 + w ; } sum = Math . pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; }
function check ( n ) { n -- ; let ans = n * n ; if ( ans >= mod ) ans %= mod ; ans += n + 2 ; if ( ans >= mod ) ans %= mod ; ans = ( power ( 2 , n , mod ) % mod * ans % mod ) % mod ; ans = ( ans - 1 + mod ) % mod ; return ans ; }
function findOddPair ( A , N ) { var i , j ; var oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
function numberOfDigits ( x ) { let i = 0 ; while ( x != 0 ) { x /= 10 ; i ++ ; } return i ; }
function twoEggDrop ( k ) { return Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8 * k ) ) / 2.0 ) ; }
function findArea ( a , b ) { var Area ; Area = 3.142 * a * b ; document . write ( "Area:▁" + Area . toFixed ( 2 ) ) ; }
function calculate ( x , k , m ) { let result = x ; k = k - 1 ; while ( k -- ) { result = Math . pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; }
function largestNum ( a , b ) { return a * ( parseInt ( a / b ) > 0 ? 1 : 0 ) + b * ( parseInt ( b / a ) > 0 ? 1 : 0 ) ; }
function minimumSquareFreeDivisors ( N ) { let primes = [ ] ; SieveOfEratosthenes ( primes ) ; let max_count = 0 ; for ( let i = 0 ; i < primes . length && primes [ i ] * primes [ i ] <= N ; i ++ ) { if ( N % primes [ i ] == 0 ) { let tmp = 0 ; while ( N % primes [ i ] == 0 ) { tmp ++ ; N = parseInt ( N / primes [ i ] , 10 ) ; } max_count = Math . max ( max_count , tmp ) ; } } if ( max_count == 0 ) { max_count = 1 ; } return max_count ; }
function smar_wln ( n ) { primes ( n ) ; }
function sumOfSeries ( n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; }
function mulmod ( a , b , mod ) { a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b = parseInt ( b / 2 , 10 ) ; } return res % mod ; }
function findProduct ( N ) { let product = 1 , fact = 1 ; let MOD = ( 1e9 + 7 ) ; for ( let i = 1 ; i <= N ; i ++ ) { fact = mulmod ( fact , i , MOD ) ; product = mulmod ( product , fact , MOD ) ; if ( product == 0 ) return 0 ; } return product ; }
function endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) { document . write ( "x2▁=▁" + ( 2 * c1 - x1 ) + "▁" ) ; document . write ( "y2▁=▁" + ( 2 * c2 - y1 ) ) ; }
function divSum ( n ) { let sum = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) sum = sum + i + parseInt ( n / i , 10 ) ; return sum ; }
function centeredTetrahedralNumber ( n ) { return ( 2 * n + 1 ) * ( n * n + n + 3 ) / 3 ; }
function bit ( x ) { let ans = 0 ; while ( x > 0 ) { x = parseInt ( x / 2 , 10 ) ; ans ++ ; } return ans ; }
function bs ( n ) { let l = 1 , r = Math . sqrt ( n ) ; while ( l < r ) { let m = parseInt ( ( l + r ) / 2 , 10 ) ; if ( check ( m , n ) ) r = m ; else l = m + 1 ; } if ( ! check ( l , n ) ) return l + 1 ; else return l ; }
function find_Square_369 ( num ) { let a , b , c , d ; if ( num [ 0 ] == "3" ) { a = "1" ; b = "0" ; c = "8" ; d = "9" ; } else if ( num [ 0 ] == "6" ) { a = "4" ; b = "3" ; c = "5" ; d = "6" ; } else { a = "9" ; b = "8" ; c = "0" ; d = "1" ; } let result = "" ; let size = num . length ; for ( let i = 1 ; i < size ; i ++ ) result += a ; result += b ; for ( let i = 1 ; i < size ; i ++ ) result += c ; result += d ; return result ; }
function everMeet ( x1 , x2 , v1 , v2 ) { if ( x1 < x2 && v1 <= v2 ) return false ; if ( x1 > x2 && v1 >= v2 ) return false ; if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; } while ( x1 >= x2 ) { if ( x1 == x2 ) return true ; x1 = x1 + v1 ; x2 = x2 + v2 ; } return false ; }
function findpos ( n ) { var pos = 0 ; for ( i = 0 ; i < n . length ; i ++ ) { switch ( n . charAt ( i ) ) { case "2" : pos = pos * 4 + 1 ; break ; case "3" : pos = pos * 4 + 2 ; break ; case "5" : pos = pos * 4 + 3 ; break ; case "7" : pos = pos * 4 + 4 ; break ; } } return pos ; }
function isPossibleToZero ( a , n ) { let num = 0 ; for ( let i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }
function fact ( n ) { if ( n == 0 n == 1 ) return 1 ; let ans = 1 ; for ( let i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ans ; }
function solve ( n , base ) { var result = 0 ; while ( n > 0 ) { var remainder = n % base ; result = result + remainder ; n = parseInt ( n / base ) ; } return result ; }
function checkSemiprime ( num ) { let cnt = 0 ; for ( let i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num = parseInt ( num / i , 10 ) ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; }
function possibleTripletInRange ( L , R ) { let flag = false ; let possibleA , possibleB , possibleC ; let numbersInRange = ( R - L + 1 ) ; if ( numbersInRange < 3 ) { flag = false ; } else if ( numbersInRange > 3 ) { flag = true ; if ( L % 2 ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ! ( L % 2 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( flag == true ) { document . write ( "(" + possibleA + ",▁" + possibleB + ",▁" + possibleC + ")" + "▁is▁one▁such▁possible" + L + "▁triplet▁between▁" + R + "▁and▁" ) ; } else { document . write ( "No▁Such▁Triplet" + L + "▁exists▁between▁" + R + "▁and▁" ) ; } }
function isFullTree ( node ) { if ( node == null ) return true ; if ( node . left == null && node . right == null ) return true ; if ( ( node . left != null ) && ( node . right != null ) ) return ( isFullTree ( node . left ) && isFullTree ( node . right ) ) ; return false ; }
function findS ( s ) { let sum = 0 ; for ( let n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }
function findKthGoodNo ( n ) { let lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }
function findGreatest ( arr , n ) { let m = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( m . has ( arr [ i ] ) ) { m . set ( arr [ i ] , m [ arr [ i ] ] + 1 ) ; } else { m . set ( arr [ i ] , m . get ( arr [ i ] ) ) ; } } arr . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = n - 1 ; i > 1 ; i -- ) { for ( let j = 0 ; j < i && arr [ j ] <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) { let result = Math . floor ( arr [ i ] / arr [ j ] ) ; if ( result != arr [ j ] && m [ result ] == null m [ result ] > 0 ) { return arr [ i ] ; } else if ( result == arr [ j ] && m [ result ] > 1 ) { return arr [ i ] ; } } } } return - 1 ; }
function LCMOfNeighbourFact ( n ) { return factorial ( n + 1 ) ; }
function fortunateNumber ( n ) { let p = primorial ( n ) ; return findNextPrime ( p ) - p ; }
function findSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
function factorial ( n ) { let f = 1 ; for ( let i = 2 ; i <= n ; i ++ ) f *= i ; return f ; }
function findNthNumber ( n , k ) { for ( let i = k + 1 , count = 1 ; count < n ; i ++ ) { if ( checkdigit ( i , k ) || ( i % k == 0 ) ) count ++ ; if ( count == n ) return i ; } return - 1 ; }
function isPrime ( p ) { let checkNumber = Math . pow ( 2 , p ) - 1 ; let nextval = 4 % checkNumber ; for ( let i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }
function multiply ( x , res , res_size ) { let carry = 0 ; for ( let i = 0 ; i < res_size ; i ++ ) { let prod = res [ i ] * x + carry ; res [ i ] = prod % 10 ; carry = Math . floor ( prod / 10 ) ; } while ( carry ) { res [ res_size ] = carry % 10 ; carry = Math . floor ( carry / 10 ) ; res_size ++ ; } return res_size ; }
function power ( x , n ) { if ( n == 0 ) { document . write ( "1" ) ; return ; } let res = new Array ( MAX ) ; let res_size = 0 ; let temp = x ; while ( temp != 0 ) { res [ res_size ++ ] = temp % 10 ; temp = Math . floor ( temp / 10 ) ; } for ( let i = 2 ; i <= n ; i ++ ) res_size = multiply ( x , res , res_size ) ; document . write ( x + "^" + n + "▁=▁" ) ; for ( let i = res_size - 1 ; i >= 0 ; i -- ) document . write ( res [ i ] ) ; }
function sumOfSeries ( n ) { return parseInt ( ( 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ) ) ; }
function seriesFunc ( n ) { let sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; let sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; }
function day_of_the_week ( y , m , d ) { let t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] ; if ( m < 3 ) y -= 1 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
function subsetCount ( arr , n ) { return 1 << n ; }
function isSquareFree ( n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; }
function avg_of_even_num ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return sum / n ; }
function reachTarget ( target ) { target = Math . abs ( target ) ; let sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; }
function fourthPowerSum ( n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; }
function aliquotSum ( n ) { let sum = 0 ; for ( let i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
function focal_length_concave ( R ) { return R / 2 ; }
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; let us = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) us . add ( arr1 [ i ] ) ; for ( let j = 0 ; j < n ; j ++ ) if ( us . has ( x - arr2 [ j ] ) ) count ++ ; return count ; }
function binomialCoeff ( n , k ) { let C = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { C [ i ] = new Array ( k + 1 ) ; } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
function isEmirp ( n ) { if ( isPrime ( n ) == false ) return false ; var rev = 0 ; while ( n != 0 ) { var d = n % 10 ; rev = rev * 10 + d ; n = parseInt ( n / 10 ) ; } return isPrime ( rev ) ; }
function squaresum ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
function isPrime ( n ) { let i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) return false ; i ++ ; } return true ; }
function oddSum ( n ) { let sum = 0 ; curr = 1 ; for ( let i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
function Convert ( radian ) { let pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }
function sn ( n , an ) { return ( n * ( 1 + an ) ) / 2 ; }
function distance ( x1 , y1 , x2 , y2 ) { return Math . sqrt ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) * 1.0 ) ; }
function count0s ( mat , Q , sizeQ ) { let prefixCnt = new Array ( M ) ; for ( var i = 0 ; i < prefixCnt . length ; i ++ ) { prefixCnt [ i ] = new Array ( 2 ) ; } preCompute ( mat , prefixCnt ) ; for ( let i = 0 ; i < sizeQ ; i ++ ) { document . write ( countQuery ( prefixCnt , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , Q [ i ] [ 3 ] ) + "▁" ) ; } }
function max_area ( n , m , k ) { if ( k > ( n + m - 2 ) ) document . write ( "Not▁possible" ) ; else { let result ; if ( k < Math . max ( m , n ) - 1 ) { result = Math . max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } document . write ( result ) ; } }
function totalNumber ( n ) { return 8 * Math . pow ( 9 , n - 1 ) ; }
function recDigSum ( n ) { if ( n == 0 ) return 0 ; else { if ( n % 9 == 0 ) return 9 ; else return n % 9 ; } }
function check ( n ) { n = recDigSum ( n ) ; if ( n == 2 n == 3 n == 5 n == 7 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function isDivisible ( s ) { let n = s . length ; if ( s [ n - 1 ] != "5" && s [ n - 1 ] != "0" ) return false ; let sum = accumulate ( s ) ; return ( sum % 3 == 0 ) ; }
function findArmstrong ( low , high ) { for ( let i = low + 1 ; i < high ; ++ i ) { let x = i ; let n = 0 ; while ( x != 0 ) { x = parseInt ( x / 10 ) ; ++ n ; } let pow_sum = 0 ; x = i ; while ( x != 0 ) { let digit = x % 10 ; pow_sum += parseInt ( Math . pow ( digit , n ) ) ; x = parseInt ( x / 10 ) ; } if ( pow_sum == i ) document . write ( i + "▁" ) ; } }
function complement ( number ) { number = number . split ( "." )  for ( let i = 0 ; i < number . length ; i ++ ) { if ( number [ i ] != "9" ) { number [ i ] = String ( 9 - Number ( number [ i ] ) + 0 ) ; } } number = number . join ( "0" ) document . write ( "9's▁complement▁is▁:▁" + number ) ; }
function countWays ( n ) { let count = 0 ; for ( let i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }
function sumDigitSquare ( n ) { let sq = 0 ; while ( n != 0 ) { let digit = n % 10 ; sq += digit * digit ; n = parseInt ( n / 10 , 10 ) ; } return sq ; }
function isHappy ( n ) { while ( true ) { if ( n == 1 ) return true ; n = sumDigitSquare ( n ) ; if ( n == 4 ) return false ; } }
function sumOfSeries ( a , num ) { let res = 0 , prev = 1 ; for ( let i = 1 ; i <= num ; i ++ ) { prev *= ( a / i ) ; res = res + prev ; } return ( res ) ; }
function convert ( arr , n ) { let temp = [ ... arr ] ; temp . sort ( ( a , b ) => a - b ) ; let umap = new Map ( ) ; let val = 0 ; for ( let i = 0 ; i < n ; i ++ ) umap . set ( temp [ i ] , val ++ ) ; for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = umap . get ( arr [ i ] ) ; }
function printTrib ( n ) { if ( n < 1 ) return ; let first = 0 , second = 0 ; let third = 1 ; document . write ( first + "▁" ) ; if ( n > 1 ) document . write ( second + "▁" ) ; if ( n > 2 ) document . write ( second + "▁" ) ; for ( let i = 3 ; i < n ; i ++ ) { let curr = first + second + third ; first = second ; second = third ; third = curr ; document . write ( curr + "▁" ) ; } }
function multiply ( T , M ) { var a , b , c , d , e , f , g , h , i ; a = T [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 0 ] ; b = T [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 1 ] ; c = T [ 0 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 2 ] ; d = T [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 0 ] ; e = T [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 1 ] ; f = T [ 1 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 2 ] ; g = T [ 2 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 0 ] ; h = T [ 2 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 1 ] ; i = T [ 2 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 2 ] ; T [ 0 ] [ 0 ] = a ; T [ 0 ] [ 1 ] = b ; T [ 0 ] [ 2 ] = c ; T [ 1 ] [ 0 ] = d ; T [ 1 ] [ 1 ] = e ; T [ 1 ] [ 2 ] = f ; T [ 2 ] [ 0 ] = g ; T [ 2 ] [ 1 ] = h ; T [ 2 ] [ 2 ] = i ; }
function sackRace ( p1 , s1 , p2 , s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; }
function xorCalc ( k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return parseInt ( k / 2 ) ; return 1 ; }
function multiple ( a , b , x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) document . write ( "1" ) ; else document . write ( "0" ) ; } var mul = parseInt ( Math . pow ( a , b ) ) ; var ans = mul / x ; var ans1 = x * ans ; var ans2 = x * ( ans + 1 ) ; document . write ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }
function checkJumbled ( num ) { if ( parseInt ( num / 10 , 10 ) == 0 ) return true ; while ( num != 0 ) { if ( parseInt ( num / 10 , 10 ) == 0 ) return true ; let digit1 = num % 10 ; let digit2 = parseInt ( num / 10 , 10 ) % 10 ; if ( Math . abs ( digit2 - digit1 ) > 1 ) return false ; num = parseInt ( num / 10 , 10 ) ; } return true ; }
function binomialProbability ( n , k , p ) { return nCr ( n , k ) * Math . pow ( p , k ) * Math . pow ( 1 - p , n - k ) ; }
function flipSign ( a ) { var neg = 0 ; var tmp = a < 0 ? 1 : - 1 ; while ( a != 0 ) { neg += tmp ; a += tmp ; } return neg ; }
function areDifferentSign ( a , b ) { return ( ( a < 0 && b > 0 ) || ( a > 0 && b < 0 ) ) ; }
function FirstDigit ( arr , n ) { let S = 0 ; for ( let i = 0 ; i < n ; i ++ ) S = S + Math . log10 ( arr [ i ] * 1.0 ) ; let fract_S = S - Math . floor ( S ) ; let ans = parseInt ( Math . pow ( 10 , fract_S ) , 10 ) ; return ans ; }
function cal_cos ( n ) { let accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = Math . cos ( n ) ; let i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . abs ( cosval - cosx ) ) ; document . write ( cosx . toFixed ( 5 ) ) ; }
function sumFactDiv ( n ) { return div ( fact ( n ) ) ; }
function printNthElement ( n ) { var arr = Array ( n + 1 ) . fill ( 0 ) ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( var i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
function maxSumLCM ( n ) { for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; }
function check ( str ) { let n = str . length ; if ( n == 0 && n == 1 ) return false ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - "0" ) * 10 + ( str [ n - 1 ] - "0" ) ) % 16 == 0 ) ; if ( n == 3 ) return ( ( ( str [ n - 3 ] - "0" ) * 100 + ( str [ n - 2 ] - "0" ) * 10 + ( str [ n - 1 ] - "0" ) ) % 16 == 0 ) ; let last = str [ n - 1 ] - "0" ; let second_last = str [ n - 2 ] - "0" ; let third_last = str [ n - 3 ] - "0" ; let fourth_last = str [ n - 4 ] - "0" ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; }
function checkPandigital ( b , n ) { if ( n . length < b ) return 0 ; let hash = [ ] ; for ( let i = 0 ; i < b ; i ++ ) hash [ i ] = 0 ; for ( let i = 0 ; i < n . length ; i ++ ) { if ( n [ i ] >= "0" && n [ i ] <= "9" ) hash [ n [ i ] - "0" ] = 1 ; else if ( n . charCodeAt ( i ) - "A" . charCodeAt ( 0 ) <= b - 11 ) hash [ n . charCodeAt ( i ) - "A" . charCodeAt ( 0 ) + 10 ] = 1 ; } for ( let i = 0 ; i < b ; i ++ ) if ( hash [ i ] == 0 ) return 0 ; return 1 ; }
function findStarNum ( n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
function squareFree ( n ) { let cnt = 0 ; for ( let i = 1 ; ; i ++ ) { let isSqFree = true ; for ( let j = 2 ; j * j <= i ; j ++ ) { if ( i % ( j * j ) == 0 ) { isSqFree = false ; break ; } } if ( isSqFree == true ) { cnt ++ ; if ( cnt == n ) return i ; } } }
function check ( str ) { let n = str . length ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str [ 0 ] - "0" ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - "0" ) * 10 + ( str [ n - 1 ] - "0" ) ) % 8 == 0 ) ; let last = str [ n - 1 ] - "0" ; let second_last = str [ n - 2 ] - "0" ; let third_last = str [ n - 3 ] - "0" ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; }
function isRefactorableNumber ( n ) { let divCount = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) { if ( n / i == i ) ++ divCount ; else divCount += 2 ; } } return n % divCount == 0 ; }
function nearestGcd ( arr , n ) { for ( let i = 0 ; i < n ; ++ i ) { let closest = - 1 ; for ( let j = i - 1 , k = i + 1 ; j > 0 k <= n ; -- j , ++ k ) { if ( j >= 0 && __gcd ( arr [ i ] , arr [ j ] ) > 1 ) { closest = j + 1 ; break ; } if ( k < n && __gcd ( arr [ i ] , arr [ k ] ) > 1 ) { closest = k + 1 ; break ; } } document . write ( closest + "▁" ) ; } }
function GCD ( a , b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
function lastNon0Digit ( n ) { if ( n < 10 ) return dig [ n ] ; if ( ( parseInt ( n / 10 , 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( parseInt ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( parseInt ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; }
function Special_Factorial_Number ( k ) { for ( let i = 1 ; i <= k ; i ++ ) { if ( fact ( i ) % k == 0 ) { return i ; } } return 0 ; }
function findnum ( str ) { var n = str . length ; var count_after_dot = 0 ; let dot_seen = false ; var num = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) != "." ) { num = num * 10 + ( str . charAt ( i ) - "0" ) ; if ( dot_seen == true ) count_after_dot ++ ; } else dot_seen = true ; } if ( dot_seen == false ) return 1 ; var dem = parseInt ( Math . pow ( 10 , count_after_dot ) ) ; return ( dem / gcd ( num , dem ) ) ; }
function iskaprekar ( n ) { if ( n == 1 ) return true ; let sq_n = n * n ; let count_digits = 0 ; while ( sq_n ) { count_digits ++ ; sq_n = parseInt ( sq_n / 10 ) ; } for ( let r_digits = 1 ; r_digits < count_digits ; r_digits ++ ) { let eq_parts = Math . pow ( 10 , r_digits ) ; if ( eq_parts == n ) continue ; let sum = parseInt ( ( sq_n1 / eq_parts ) + sq_n1 % eq_parts ) ; if ( sum == n ) return true ; } return false ; }
function kDivisors ( a , b , k ) { var count = 0 ; for ( var i = a ; i <= b ; i ++ ) { if ( isPerfect ( i ) ) { if ( divisorsCount ( i ) == k ) { count ++ ; } } } return count ; }
function buildDivisorsArray ( ) { for ( let i = 1 ; i < maxn ; i ++ ) { divisors [ i ] = 1 ; let n = i ; let p = smallest_prime [ i ]  let k = 0 ; while ( n > 1 ) { n = Math . floor ( n / p ) ; k ++ ; if ( smallest_prime [ n ] != p ) { divisors [ i ] = divisors [ i ] * ( k + 1 ) ; k = 0 ; } p = smallest_prime [ n ] ; } } }
function commDiv ( a , b ) { let n = gcd ( a , b ) ; let result = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) result += 1 ; else result += 2 ; } } return result ; }
function findCountOfSolutions ( n , p ) { let ans = 0 ; for ( let x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { let last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
function isTriangular ( num ) { if ( num < 0 ) return false ; var c = ( - 2 * num ) ; var b = 1 , a = 1 ; var d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; var root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; var root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ; return false ; }
function flip ( c ) { return ( c == "0" ) ? "1" : "0" ; }
function areElementsContiguous ( arr , n ) { let max = Number . MIN_VALUE ; let min = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } let m = max - min + 1 ; if ( m > n ) return false ; let visited = new Array ( n ) ; visited . fill ( false ) ; for ( let i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( let i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }
function SieveOfAtkin ( limit ) { if ( limit > 2 ) document . write ( 2 + "▁" ) ; if ( limit > 3 ) document . write ( 3 + "▁" ) ; let sieve = new Array ( ) sieve [ limit ] = 0 ; for ( let i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ; for ( let x = 1 ; x * x < limit ; x ++ ) { for ( let y = 1 ; y * y < limit ; y ++ ) { let n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] = true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( let r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( let a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) document . write ( a , "▁" ) ; }
function SieveOfSundaram ( n ) { let nNew = ( n - 1 ) / 2 ; let marked = [ ] ; for ( let i = 0 ; i < nNew + 1 ; i ++ ) marked [ i ] = false ; for ( let i = 1 ; i <= nNew ; i ++ ) for ( let j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) document . write ( 2 + "▁" ) ; for ( let i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) document . write ( 2 * i + 1 + "▁" ) ; return - 1 ; }
function squareRootExists ( n , p ) { n = n % p ; for ( let x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
function power ( x , y , p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function modFact ( n , p ) { if ( p <= n ) return 0 ; let res = ( p - 1 ) ; for ( let i = n + 1 ; i < p ; i ++ ) res = ( res * modInverse ( i , p ) ) % p ; return res ; }
function countWays ( n ) { for ( let i = 1 ; i < n ; i ++ ) for ( let j = i ; j < n ; j ++ ) for ( let k = j ; k < n ; k ++ ) for ( let l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
function isInside ( circle_x , circle_y , rad , x , y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; }
function checkUtil ( num , dig , base ) { if ( dig == 1 && num < base ) return true ; if ( dig > 1 && num >= base ) return checkUtil ( parseInt ( num / base ) , -- dig , base ) ; return false ; }
function countLeapYears ( d ) { let years = d . y ; if ( d . m <= 2 ) { years -- ; } return Math . floor ( years / 4 ) - Math . floor ( years / 100 ) + Math . floor ( years / 400 ) ; }
function binomialCoeff ( n , k ) { let res = 1 ; if ( k > n - k ) k = n - k ; for ( let i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
function findWays ( n ) { if ( n & 1 ) return 0 ; return catalan ( n / 2 ) ; }
function XorSum ( A , B , N , M ) { let ans1 = 0 , ans2 = 0 ; for ( let i = 0 ; i < N ; i ++ ) ans1 = ans1 ^ A [ i ] ; for ( let i = 0 ; i < M ; i ++ ) ans2 = ans2 ^ B [ i ] ; return ( ans1 & ans2 ) ; }
function check ( x ) { if ( ( ( x ) & ( x - 1 ) ) == 0 ) return 1 ; return 0 ; }
function maxAndXor ( arr , n ) { let ans = Number . MAX_VALUE ; arr . sort ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) { ans = Math . min ( ans , arr [ i ] ^ arr [ i + 1 ] ) ; } return ans ; }
function FlipBits ( n ) { for ( let bit = 0 ; bit < 32 ; bit ++ ) { if ( ( ( n >> bit ) & 1 ) > 0 ) { n = n ^ ( 1 << bit ) ; break ; } } document . write ( "The▁number▁after▁unsetting▁the" ) ; document . write ( "▁rightmost▁set▁bit▁" + n ) ; }
function minRange ( arr , n , k ) { let l = 0 , r = n ; for ( let i = 0 ; i < n ; i ++ ) { let s = new Set ( ) ; let j ; for ( j = i ; j < n ; j ++ ) { s . add ( arr [ j ] ) ; if ( s . size == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) break ; } if ( l == 0 && r == n ) document . write ( "Invalid▁k" ) ; else document . write ( l + "▁" + r ) ; }
function construct_Xor_Tree ( arr , n ) { construct_Xor_Tree_Util ( arr , 0 , n - 1 , 0 ) ; }
function maximizeExpression ( a , b ) { let result = a ; for ( let bit = MAX - 1 ; bit >= 0 ; bit -- ) { let bitOfD = 1 << bit ; let x = b & bitOfD ; if ( x == bitOfD ) { let y = result & bitOfD ; if ( y == 0 ) { result = result ^ bitOfD ; } } } return result ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
function hasEqualBlockFrequency ( N ) { let S = N . toString ( 2 ) ; let p = new Set ( ) ; let c = 1 ; for ( let i = 0 ; i < S . length - 1 ; i ++ ) { if ( S [ i ] == S [ i + 1 ] ) c += 1 ; else { p . add ( c ) ; c = 1 ; } p . add ( c ) ; } if ( p . size == 1 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function isEqualBlock ( n ) { var first_bit = n % 2 ; var first_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit && n > 0 ) { n = n / 2 ; first_count ++ ; } if ( n == 0 ) return false ; while ( n > 0 ) { first_bit = n % 2 ; var curr_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit ) { n = n / 2 ; curr_count ++ ; } if ( curr_count != first_count ) return false ; } return true ; }
function printMaxAfterRemoval ( s ) { let flag = false ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == "0" && flag == false ) { flag = true ; continue ; } else document . write ( s [ i ] ) ; } return 0 ; }
function bitPos ( n1 , n2 ) { if ( n1 == n2 ) return 0 ; let bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; let bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; let bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; let maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } let xorValue = n1 ^ n2 ; let bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; let disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }
function findevenPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; let oddCount = parseInt ( ( count * ( count - 1 ) ) / 2 ) ; return parseInt ( ( N * ( N - 1 ) ) / 2 ) - oddCount ; }
function ReplaceElements ( arr , n ) { if ( n <= 1 ) return ; let prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( let i = 1 ; i < n - 1 ; i ++ ) { let curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }
function highestPowerOf2 ( n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
function maxTriplet ( a , n ) { let f = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { f [ i ] = true ; } let bits = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { bits [ i ] = new Array ( 33 ) ; for ( let j = 0 ; j < 33 ; j ++ ) { bits [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; ++ i ) { let num = a [ i ] ; let j = 32 ; while ( num > 0 ) { if ( num % 2 == 1 ) { bits [ i ] [ j ] = 1 ; } j -- ; num >>= 1 ; } } let ans = 0 ; for ( let i = 0 ; i <= 32 ; ++ i ) { let cnt = 0 ; for ( let j = 0 ; j < n ; ++ j ) { if ( bits [ j ] [ i ] == 1 & f [ j ] ) { cnt ++ ; } } if ( cnt >= 3 ) { ans += Math . pow ( 2 , 32 - i ) ; for ( let j = 0 ; j < n ; ++ j ) { if ( bits [ j ] [ i ] != 1 ) { f [ j ] = false ; } } } } let cnt = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( f [ i ] ) { cnt ++ ; } } let NumberOfTriplets = ( cnt * ( cnt - 1 ) * ( cnt - 2 ) ) / 6 ; document . write ( NumberOfTriplets + "▁" + ans ) ; }
function AND ( a , n ) { let ans = a [ 0 ] ; for ( let i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; }
function findEvenPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ( ! ( ( A [ i ] & 1 ) > 0 ) ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
function printOdds ( arr , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; let set_bit = res & ( ~ ( res - 1 ) ) ; let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( x + "▁" + y ) ; }
function printKthBit ( n , k ) { document . write ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ; }
function decimalToBinaryNumber ( x , n ) { var binaryNumber = Array ( x ) ; var i = 0 ; while ( x > 0 ) { binaryNumber [ i ] = x % 2 ; x = parseInt ( x / 2 ) ; i ++ ; } for ( var j = 0 ; j < n - i ; j ++ ) document . write ( "0" ) ; for ( var j = i - 1 ; j >= 0 ; j -- ) document . write ( binaryNumber [ j ] ) ; }
function XOR ( a , b ) { let c = Math . min ( a , b ) ; let d = Math . max ( a , b ) ; if ( count ( c ) < count ( d ) ) c = c << ( count ( d ) - count ( c ) ) ; return ( c ^ d ) ; }
function toggleBits ( n1 , n2 ) { return ( n1 ^ n2 ) ; }
function evenbittogglenumber ( n ) { let res = 0 , count = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
function maxXorSum ( n , k ) { if ( k == 1 ) return n ; let res = 1 ; while ( res <= n ) res <<= 1 ; return res - 1 ; }
function evenbittogglenumber ( n ) { let res = 0 , count = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
function countPairs ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
function maxAND ( arr , n ) { let res = 0 , count ; for ( let bit = 31 ; bit >= 0 ; bit -- ) { count = checkBit ( res | ( 1 << bit ) , arr , n ) ; if ( count >= 2 ) res |= ( 1 << bit ) ; } return res ; }
function countSetBits ( n ) { let count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
function countUnsetBits ( n ) { let x = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return BitCount ( x ^ n ) ; }
function setBitNumber ( n ) { let k = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; return 1 << k ; }
function toggle ( n ) { let temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } return n ; }
function getFirstSetBitPos ( n ) { return parseInt ( Math . log ( n & - n ) / Math . log ( 2 ) ) + 1 ; }
function countNum ( arr , n ) { let count = 0 ; arr . sort ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
function CountZeroBit ( x ) { let count = 0 ; while ( x > 0 ) { if ( ( x & 1 ) == 0 ) count ++ ; x >>= 1 ; } return count ; }
function bitCount ( n ) { let count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) ++ count ; n >>= 1 ; } return count ; }
function sumoflength ( arr , n ) { let s = new Set ( ) ; let j = 0 , ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . has ( arr [ j ] ) ) { s . add ( arr [ i ] ) ; j ++ ; } ans += Math . floor ( ( ( j - i ) * ( j - i + 1 ) ) / 2 ) ; s . delete ( arr [ i ] ) ; } return ans ; }
function areSetBitsIncreasing ( n ) { var prev_count = Number . MAX_VALUE ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = parseInt ( n / 2 ) ; var curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; }
function findPattern ( n ) { let prev = n % 2 ; n = Math . floor ( n / 2 ) ; while ( n > 0 ) { let curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = Math . floor ( n / 2 ) ; } return true ; }
function isMultipleOf4 ( n ) { if ( n == 1 ) return false ; let XOR = 0 ; for ( let i = 1 ; i <= n ; i ++ ) XOR = XOR ^ i ; return ( XOR == n ) ; }
function findProffesion ( level , pos ) { if ( level == 1 ) return "e" ; if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == "d" ) return ( pos % 2 > 0 ) ? "d" : "e" ; return ( pos % 2 > 0 ) ? "e" : "d" ; }
function swapBits ( n , p1 , p2 ) { var bit1 = ( n >> p1 ) & 1 ; var bit2 = ( n >> p2 ) & 1 ; var x = ( bit1 ^ bit2 ) ; x = ( x << p1 ) | ( x << p2 ) ; var result = n ^ x ; return result ; }
function getElements ( root ) { if ( root == null ) return 0 ; return getElements ( root . left ) + getElements ( root . right ) + 1 ; }
function sumOfDiv ( x ) { let sum = 1 ; for ( let i = 2 ; i <= Math . sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { sum += i ; if ( x / i != i ) sum += x / i ; } } return sum ; }
function leftRotate ( arr , d , n ) { for ( i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; }
function merge ( arr , l , m , r ) { let i = l ; let j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ; while ( j <= r && arr [ j ] < 0 ) j ++ ; reverse ( arr , i , m ) ; reverse ( arr , m + 1 , j - 1 ) ; reverse ( arr , i , j - 1 ) ; }
function arrayEvenAndOdd ( arr , n ) { let i = - 1 , j = 0 ; let t ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) { if ( k > n1 * n2 ) { document . write ( "k▁pairs▁don't▁exist" ) ; return ; } let index2 = new Array ( n1 ) ; index2 . fill ( 0 ) ; while ( k > 0 ) { let min_sum = Number . MAX_VALUE ; let min_index = 0 ; for ( let i1 = 0 ; i1 < n1 ; i1 ++ ) { if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) { min_index = i1 ; min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ; } } document . write ( "(" + arr1 [ min_index ] + ",▁" + arr2 [ index2 [ min_index ] ] + ")▁" ) ; index2 [ min_index ] ++ ; k -- ; } }
function Solve ( L , R ) { let l = L , r = R ; let tot_bits = r - l + 1 ; let X = MAX ; for ( let i = 0 ; i < 31 ; i ++ ) { let x = one [ r ] [ i ] - one [ l - 1 ] [ i ] ; if ( x >= tot_bits - x ) { let ith_bit = Math . pow ( 2 , i ) ; X = X ^ ith_bit ; } } return X ; }
function swap ( arr , i , j ) { let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; }
function findNumberOfTriangles ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] > arr [ k ] && arr [ i ] + arr [ k ] > arr [ j ] && arr [ k ] + arr [ j ] > arr [ i ] ) count ++ ; } } return count ; }
function CountTriangles ( A ) { var n = A . length ; A . sort ( ) ; var count = 0 ; for ( i = n - 1 ; i >= 1 ; i -- ) { var l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else { l ++ ; } } } document . write ( "No▁of▁possible▁solutions:▁" + count ) ; }
function countPairsWithDiffK ( arr , n , k ) { let count = 0 ; arr . sort ( ) ; let l = 0 ; let r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
function getSumAlternate ( root ) { if ( root == null ) return 0 ; let sum = root . data ; if ( root . left != null ) { sum += getSum ( root . left . left ) ; sum += getSum ( root . left . right ) ; } if ( root . right != null ) { sum += getSum ( root . right . left ) ; sum += getSum ( root . right . right ) ; } return sum ; }
function getSum ( root ) { if ( root == null ) return 0 ; return Math . max ( getSumAlternate ( root ) , ( getSumAlternate ( root . left ) + getSumAlternate ( root . right ) ) ) ; }
function binarySearch ( arr , low , high , key ) { if ( high < low ) return - 1 ; let mid = Math . trunc ( ( low + high ) / 2 ) ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }
function getHeight ( Node ) { if ( Node == null ) return 0 ; else { let lHeight = getHeight ( Node . left ) ; let rHeight = getHeight ( Node . right ) ; if ( lHeight > rHeight ) return ( lHeight + 1 ) ; else return ( rHeight + 1 ) ; } }
function printLeaders ( arr , size ) { for ( let i = 0 ; i < size ; i ++ ) { let j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) document . write ( arr [ i ] + "▁" ) ; } }
function binarySearch ( arr , low , high ) { if ( high >= low ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }
function getMin ( arr , n ) { let min = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } return min ; }
function interpolationSearch ( arr , lo , hi , x ) { let pos ; if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { pos = lo + Math . floor ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; ; if ( arr [ pos ] == x ) { return pos ; } if ( arr [ pos ] < x ) { return interpolationSearch ( arr , pos + 1 , hi , x ) ; } if ( arr [ pos ] > x ) { return interpolationSearch ( arr , lo , pos - 1 , x ) ; } } return - 1 ; }
function sort ( arr , n ) { countSort ( arr , n , 1 ) ; countSort ( arr , n , n ) ; }
function countOnes ( arr , low , high ) { if ( high >= low ) { let mid = Math . trunc ( low + ( high - low ) / 2 ) ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
function isUgly ( no ) { no = maxDivide ( no , 2 ) ; no = maxDivide ( no , 3 ) ; no = maxDivide ( no , 5 ) ; return ( no == 1 ) ? 1 : 0 ; }
function countRec ( n , sum ) { if ( n == 0 ) return sum == 0 ; if ( sum == 0 ) return 1 ; let ans = 0 ; for ( let i = 0 ; i <= 9 ; i ++ ) { if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; } return ans ; }
function countRec ( n , sum ) { if ( n == 0 ) return sum == 0 ? 1 : 0 ; if ( lookup [ n ] [ sum ] != - 1 ) return lookup [ n ] [ sum ] ; let ans = 0 ; for ( let i = 0 ; i < 10 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return lookup [ n ] [ sum ] = ans ; }
function sumOfDigitsFrom1ToNUtil ( n , a ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; var d = ( parseInt ) ( Math . log10 ( n ) ) ; var p = ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; var msd = ( parseInt ) ( n / p ) ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToNUtil ( n % p , a ) ) ; }
function findoptimal ( N ) { if ( N <= 6 ) return N ; let screen = [ ] ; let b ; let n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }
function printCombination ( arr , n , r ) { let data = new Array ( r ) ; combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; }
function findCeil ( arr , r , l , h ) { let mid ; while ( l < h ) { mid = l + ( ( h - l ) >> 1 ) ; ( r > arr [ mid ] ) ? ( l = mid + 1 ) : ( h = mid ) ; } return ( arr [ l ] >= r ) ? l : - 1 ; }
function multiplyWith3Point5 ( x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
function isPowerOfFour ( n ) { if ( n == 0 ) return false ; return Math . floor ( logn ( n , 4 ) ) == Math . ceil ( logn ( n , 4 ) ) ; }
function countSetBits ( n ) { return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) ; }
function countSetBitsRec ( num ) { var nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }
function PositionRightmostSetbit ( n ) { let position = 1 ; let m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }
function swapBits ( x ) { even_bits = x & 0xAAAAAAAA ; odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; }
function isPowerOfTwo ( n ) { return ( n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ) ? true : false ; }
function segregate0and1 ( arr , size ) { let left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }
function maxSum ( arr , n ) { let sum = 0 ; arr . sort ( ) ; for ( let i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }
function updateindex ( index , a , ai , b , bi ) { index [ a ] = ai ; index [ b ] = bi ; }
function minSwapsUtil ( arr , pairs , index , i , n ) { if ( i > n ) return 0 ; if ( pairs [ arr [ i ] ] == arr [ i + 1 ] ) return minSwapsUtil ( arr , pairs , index , i + 2 , n ) ; var one = arr [ i + 1 ] ; var indextwo = i + 1 ; var indexone = index [ pairs [ arr [ i ] ] ] ; var two = arr [ index [ pairs [ arr [ i ] ] ] ] ; arr [ i + 1 ] = arr [ i + 1 ] ^ arr [ indexone ] ^ ( arr [ indexone ] = arr [ i + 1 ] ) ; updateindex ( index , one , indexone , two , indextwo ) ; var a = minSwapsUtil ( arr , pairs , index , i + 2 , n ) ; arr [ i + 1 ] = arr [ i + 1 ] ^ arr [ indexone ] ^ ( arr [ indexone ] = arr [ i + 1 ] ) ; updateindex ( index , one , indextwo , two , indexone ) ; one = arr [ i ] ; indexone = index [ pairs [ arr [ i + 1 ] ] ] ; two = arr [ index [ pairs [ arr [ i + 1 ] ] ] ] ; indextwo = i ; arr [ i ] = arr [ i ] ^ arr [ indexone ] ^ ( arr [ indexone ] = arr [ i ] ) ; updateindex ( index , one , indexone , two , indextwo ) ; var b = minSwapsUtil ( arr , pairs , index , i + 2 , n ) ; arr [ i ] = arr [ i ] ^ arr [ indexone ] ^ ( arr [ indexone ] = arr [ i ] ) ; updateindex ( index , one , indextwo , two , indexone ) ; return 1 + Math . min ( a , b ) ; }
function process ( arr , n ) { for ( var k = 1 ; k <= n ; k ++ ) arr [ k ] ^= arr [ k - 1 ] ; }
function prefixXOR ( arr , preXOR , n ) { for ( let i = 0 ; i < n ; i ++ ) { while ( arr [ i ] % 2 != 1 ) arr [ i ] = parseInt ( arr [ i ] / 2 ) ; preXOR [ i ] = arr [ i ] ; } for ( let i = 1 ; i < n ; i ++ ) preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] ; }
function query ( preXOR , l , r ) { if ( l == 0 ) return preXOR [ r ] ; else return preXOR [ r ] ^ preXOR [ l - 1 ] ; }
function maxPartitions ( arr , n ) { let ans = 0 , max_so_far = 0 ; for ( let i = 0 ; i < n ; ++ i ) { max_so_far = Math . max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; }
function countPairs ( a , n , k ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; }
function getInvCount ( arr , n ) { let invcount = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let small = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; let great = 0 ; for ( let j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }
function countPairs ( A , n , k ) { var ans = 0 ; A . sort ( ( a , b ) => a - b )  for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { var x = 0 ; while ( ( A [ i ] * Math . pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * Math . pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; }
function printMax ( arr , k , n ) { var brr = arr . slice ( ) ; brr . sort ( ( a , b ) => b - a ) ; for ( var i = 0 ; i < n ; ++ i ) if ( brr . indexOf ( arr [ i ] ) < k ) document . write ( arr [ i ] + "▁" ) ; }
function find_consecutive_steps ( arr , len ) { let count = 0 ; let maximum = 0 ; for ( let index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = Math . max ( maximum , count ) ; count = 0 ; } } return Math . max ( maximum , count ) ; }
function findSum ( arr , n ) { let sum = 0 ; arr . sort ( ) ; let i = 0 ; while ( i < n && arr [ i ] < 0 ) { if ( i != n - 1 && arr [ i + 1 ] <= 0 ) { sum = ( sum + ( arr [ i ] * arr [ i + 1 ] ) % Mod ) % Mod ; i += 2 ; } else break ; } let j = n - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { if ( j != 0 && arr [ j - 1 ] > 0 ) { sum = ( sum + ( arr [ j ] * arr [ j - 1 ] ) % Mod ) % Mod ; j -= 2 ; } else break ; } if ( j > i ) sum = ( sum + ( arr [ i ] * arr [ j ] ) % Mod ) % Mod ; else if ( i == j ) sum = ( sum + arr [ i ] ) % Mod ; return sum ; }
function printList ( head ) { var temp = head ; while ( temp != null ) { document . write ( temp . data + "▁" ) ; temp = temp . next ; } }
function insertAfterNthNode ( head , n , x ) { if ( head == null ) return ; var newNode = getNode ( x ) ; var ptr = head ; var len = 0 , i ; while ( ptr != null ) { len ++ ; ptr = ptr . next ; } ptr = head ; for ( i = 1 ; i <= ( len - n ) ; i ++ ) ptr = ptr . next ; newNode . next = ptr . next ; ptr . next = newNode ; }
function findLargestRotation ( num ) { let ans = num ; let len = Math . floor ( Math . log10 ( num ) + 1 ) ; let x = Math . pow ( 10 , len - 1 ) ; for ( let i = 1 ; i < len ; i ++ ) { let lastDigit = num % 10 ; num = parseInt ( num / 10 ) ; num += ( lastDigit * x ) ; if ( num > ans ) { ans = num ; } } document . write ( ans ) ; }
function reverse ( arr , s , e ) { while ( s < e ) { var tem = arr [ s ] ; arr [ s ] = arr [ e ] ; arr [ e ] = tem ; s = s + 1 ; e = e - 1 ; } }
function countRotation ( arr , low , high ) { if ( low > high ) { return 0 ; } let mid = low + Math . floor ( ( high - low ) / 2 ) ; if ( mid < high && arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) { return mid ; } if ( arr [ mid ] > arr [ low ] ) { return countRotation ( arr , mid + 1 , high ) ; } if ( arr [ mid ] < arr [ high ] ) { return countRotation ( arr , low , mid - 1 ) ; } else { let rightIndex = countRotation ( arr , mid + 1 , high ) ; let leftIndex = countRotation ( arr , low , mid - 1 ) ; if ( rightIndex == 0 ) { return leftIndex ; } return rightIndex ; } }
function build ( node , l , r , a ) { if ( l == r ) seg [ node ] = a [ l ] ; else { var mid = parseInt ( ( l + r ) / 2 ) ; build ( 2 * node , l , mid , a ) ; build ( 2 * node + 1 , mid + 1 , r , a ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } }
function rightRotationDivisor ( N ) { let lastDigit = N % 10 ; let rightRotation = ( lastDigit * Math . pow ( 10 , Math . floor ( ( Math . log10 ( N ) ) ) ) + Math . floor ( N / 10 ) ) ; return ( rightRotation % N == 0 ) ; }
function digitSum ( num ) { var sum = 0 ; while ( num > 0 ) { sum += ( num % 10 ) ; num = parseInt ( num / 10 ) ; } return sum ; }
function printList ( start ) { var temp ; if ( start != null ) { temp = start ; do { document . write ( temp . data + "▁" ) ; temp = temp . next ; } while ( temp != start ) ; } }
function displayList ( start ) { let temp = start ; while ( temp . next != start ) { document . write ( temp . data + "%d▁" ) ; temp = temp . next ; } document . write ( temp . data + "%d▁" ) ; }
function alivesol ( Num ) { if ( Num == 1 ) return 1 ; var last = newNode ( 1 ) ; last . next = last ; for ( var i = 2 ; i <= Num ; i ++ ) { var tem = newNode ( i ) ; tem . next = last . next ; last . next = tem ; last = tem ; } var curr = last . next ; var tem1 = new Node ( ) ; while ( curr . next != curr ) { tem1 = curr ; curr = curr . next ; tem1 . next = curr . next ; tem1 = tem1 . next ; curr = tem1 ; } var res = tem1 . data ; return res ; }
function addEdge ( u , v , cost ) { graph [ u ] . push ( [ v , cost ] ) ; graph [ v ] . push ( [ u , cost ] ) ; }
function dfs ( node , parent , h ) { lca [ node ] [ 0 ] = parent ; level [ node ] = h ; if ( parent != - 1 ) { minWeight [ node ] [ 0 ] = Math . min ( weight [ node ] , weight [ parent ] ) ; maxWeight [ node ] [ 0 ] = Math . max ( weight [ node ] , weight [ parent ] ) ; } for ( let i = 1 ; i < log ; i ++ ) { if ( lca [ node ] [ i - 1 ] != - 1 ) { lca [ node ] [ i ] = lca [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ; minWeight [ node ] [ i ] = Math . min ( minWeight [ node ] [ i - 1 ] , minWeight [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; maxWeight [ node ] [ i ] = Math . max ( maxWeight [ node ] [ i - 1 ] , maxWeight [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; } } for ( let i = 0 ; i < graph [ node ] . length ; i ++ ) { if ( graph [ node ] [ i ] == parent ) continue ; dfs ( graph [ node ] [ i ] , node , h + 1 ) ; } }
function LCANaive ( u , v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) { var temp = u ; u = v ; v = temp ; } v = parent [ v ] ; return LCANaive ( u , v ) ; }
function solve ( A , n ) { let i , cnt = 0 , j ; let parent = new Array ( n ) ; let vis = new Array ( n ) ; parent . fill ( - 1 ) ; vis . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == - 1 ) { while ( parent [ j ] == - 1 ) { parent [ j ] = i ; j = __gcd ( j , A [ j ] ) % n ; } if ( parent [ j ] == i ) { while ( vis [ j ] == 0 ) { vis [ j ] = 1 ; cnt ++ ; j = __gcd ( j , A [ j ] ) % n ; } } } } return cnt ; }
function clear ( n ) { for ( let i = 0 ; i <= n ; i ++ ) { lvl [ i ] = 0 ; } maxi = 0 ; dist1 [ 0 ] = dist2 [ 0 ] = - 1 ; }
function possiblePositions ( n ) { let term1 = Math . pow ( n , 4 ) ; let term2 = Math . pow ( n , 3 ) ; let term3 = Math . pow ( n , 2 ) ; let term4 = n / 3 ; let ans = ( Math . ceil ( term1 / 2 ) ) - ( Math . ceil ( 5 * term2 ) / 3 ) + ( Math . ceil ( 3 * term3 ) / 2 ) - term4 ; return ans ; }
function countSingleRec ( node , c ) { if ( node == null ) return true ; var left = countSingleRec ( node . left , c ) ; var right = countSingleRec ( node . right , c ) ; if ( left == false right == false ) return false ; if ( node . left != null && node . data != node . left . data ) return false ; if ( node . right != null && node . data != node . right . data ) return false ; c . count ++ ; return true ; }
function maxSubArraySum ( a , size ) { var max_so_far = - 1000000000 , max_ending_here = 0 ; for ( var i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function modInverse ( n , p ) { return power ( n , p - 2 , p ) ; }
function CountEvenSumSequences ( n ) { let count = 0 ; for ( let i = 0 ; i <= n ; i ++ ) { let even = i , odd = n - i ; if ( odd % 2 == 1 ) continue ; let tot = ( power ( countOdd ( n ) , odd , M ) * nCrModPFermat ( n , odd , M ) ) % M ; tot = ( tot * power ( counteEven ( n ) , i , M ) ) % M ; count += tot * 0 + 521 ; count %= M ; } return ( count - 1 ) ; }
function SieveOfEratosthenes ( ) { for ( let i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( let p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * p ; i < MAX ; i += p ) prime [ i ] = false ; } } }
function nextOccurrence ( str , n , start , ch ) { for ( var i = start ; i < n ; i ++ ) { if ( str [ i ] === ch ) return i ; } return - 1 ; }
function changeToOnes ( str ) { var i , l , ctr = 0 ; l = str . length ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == "1" ) ctr ++ ; else break ; } return l - ctr ; }
function getCount ( a , n ) { let gcd = 0 ; for ( let i = 0 ; i < n ; i ++ ) gcd = calgcd ( gcd , a [ i ] ) ; let cnt = 0 ; for ( let i = 1 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { if ( i * i == gcd ) cnt ++ ; else cnt += 2 ; } } return cnt ; }
function findMissingPositive ( arr , n ) { let m = 1 ; let x = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( m < arr [ i ] ) { x . add ( arr [ i ] ) ; } else if ( m == arr [ i ] ) { m = m + 1 ; while ( x . has ( m ) ) { x . delete ( m ) ; m = m + 1 ; } } } return m ; }
function isPalindrome ( str , i , j ) { while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
function revereseArray ( arr , n ) { let rev = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) rev [ n - i - 1 ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = rev [ i ] ; }
function _log ( x , base ) { return ( Math . log ( x ) / Math . log ( base ) ) ; }
function maximumCut ( arr , K ) { let low = 0  let high = arr [ 0 ] ; for ( let i = 1 ; i < arr . length ; i ++ ) { high = Math . max ( high , arr [ i ] ) ; } while ( low <= high ) { mid = Math . floor ( ( low + high ) / 2 ) ; chocolate = cal ( arr , mid )  if ( chocolate == K ) { return mid } else if ( chocolate < K ) { high = mid - 1 } else { low = mid + 1  if ( mid > high ) high = mid } } return high }
function findMissingBinaryString ( nums , N ) { let s = new Set ( ) ; let counter = 0 ; for ( let str of nums ) { s . add ( str ) ; } let total = Math . pow ( 2 , N ) ; let ans = "" ; for ( let i = 0 ; i < total ; i ++ ) { let num = "" ; for ( let j = N - 1 ; j >= 0 ; j -- ) { if ( i & ( 1 << j ) ) { num += "1" ; } else { num += "0" ; } } if ( s . has ( num ) ) { continue ; counter ++ ; } else { document . write ( num + ",▁" ) ; } } if ( counter == total ) { document . write ( "-1" ) ; } }
function Minimum ( N , K ) { let sum = N * ( N + 1 ) / 2 ; if ( K > sum ) return - 1 ; if ( K <= N ) return 1 ; sum = 0 ; let count = 0 ; while ( N >= 1 && sum < K ) { count += 1 ; sum += N ; N -= 1 ; } return count ; }
function Count ( N , K ) { if ( K == 0 ) return 0 ; let sum = 0 ; let res = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum += i ; if ( sum <= K ) res ++ ; else break ; } return res ; }
function mostFrequent ( arr , N ) { let ans = new Array ( N ) . fill ( 0 )  for ( let i = 0 ; i < N ; i ++ ) { let count = new Array ( N ) ; count . fill ( 0 )  let best = 1 ; for ( let j = i ; j < N ; j ++ ) { count [ arr [ j ] - 1 ] ++ ; if ( count [ arr [ j ] - 1 ] > count [ best - 1 ] || ( count [ arr [ j ] - 1 ] == count [ best - 1 ] && arr [ j ] < best ) ) { best = arr [ j ] ; } ans [ best - 1 ] ++ ; } } console . log ( ans )  for ( let i = 0 ; i < N ; i ++ ) document . write ( ans [ i ] + "▁" ) ; }
function Add_edge ( u , v ) { edges [ u ] . push ( v ) ; edges [ v ] . push ( u ) ; }
function minCost ( arr , A , B ) { let n = arr . length ; let m = arr [ 0 ] . length ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == "*" ) continue ; if ( j == m - 1 ) ans += A ; else { if ( arr [ i ] [ j + 1 ] == "." ) { ans += Math . min ( 2 * A , B ) ; j ++ ; } else ans += A ; } } } document . write ( ans ) ; }
function binarySeach ( P , N ) { var i = 0 ; var j = P . length - 1 ; var index = - 1 ; while ( i <= j ) { var mid = i + parseInt ( ( j - i ) / 2 ) ; if ( P [ mid ] >= N ) { index = mid ; j = mid - 1 ; } else { i = mid + 1 ; } } return index ; }
function countPairs ( arr , N ) { let count = 0 ; let S = [ ] ; for ( let i = 0 ; i < N ; i ++ ) S . push ( arr [ i ] ) ; for ( let ele in S ) { let sum = 2 * ele ; count += getCountPairs ( arr , N , sum ) ; } return count ; }
function SieveOfEratosthenes ( prime ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i < MAX ; i += p ) prime [ i ] = false ; } } }
function printReverse ( sentence ) { var newlist = [ ] ; var lis = [ ] ; var temp = "" ; for ( var i = 0 ; i < sentence . length ; i ++ ) { if ( sentence [ i ] == "▁" ) { lis . push ( temp ) ; temp = "" ; } else temp += sentence [ i ] ; } lis . push ( temp ) ; for ( var i = 0 ; i < lis . length ; i ++ ) { if ( palindrome ( lis [ i ] ) ) newlist . push ( lis [ i ] ) ; } newlist . reverse ( ) ; var j = 0 ; for ( var i = 0 ; i < lis . length ; i ++ ) { if ( palindrome ( lis [ i ] ) ) { lis [ i ] = newlist [ j ] ; j = j + 1 ; } } for ( var i = 0 ; i < lis . length ; i ++ ) { document . write ( lis [ i ] + "▁" ) ; } }
function maximumNumber ( arr , N , K ) { let minimum = Math . min ( ... arr )  let ans = minimum + K ; for ( let i = 0 ; i < N ; i ++ ) { if ( Math . abs ( arr [ i ] - ans ) > K ) { ans = - 1 ; break ; } } document . write ( ans ) }
function CountPairs ( arr , n ) { var count = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( i * j ) == ( arr [ i ] * arr [ j ] ) ) count ++ ; } } return count ; }
function checkGroup ( arr ) { if ( arr . length <= 2 ) return true ; let corner = arr [ 0 ] + arr [ arr . length - 1 ] ; let xorSum = 0 ; for ( let i = 0 ; i < arr . length - 1 ; i ++ ) xorSum += ( arr [ i ] ^ arr [ i + 1 ] ) ; if ( corner == 0 ) if ( xorSum > 2 ) return false ; else if ( corner == 1 ) if ( xorSum > 1 ) return false ; else if ( xorSum > 0 ) return false ; return true ; }
function isPalindrome ( S , i , j ) { while ( i < j ) { if ( S [ i ] !== S [ j ] ) return false ; i ++ ; j -- ; } return true ; }
function printLongestPalindrome ( S , N ) { var palLength = new Array ( N ) ; for ( var i = 0 ; i < N ; i ++ ) { var maxlength = 1 ; for ( var j = 0 ; j < i ; j ++ ) { if ( S [ j ] === S [ i ] ) { if ( isPalindrome ( S , j , i ) !== false ) { maxlength = i - j + 1 ; break ; } } } for ( var j = N - 1 ; j > i ; j -- ) { if ( S [ j ] === S [ i ] ) { if ( isPalindrome ( S , i , j ) ) { maxlength = Math . max ( j - i + 1 , maxlength ) ; break ; } } } palLength [ i ] = maxlength ; } for ( var i = 0 ; i < N ; i ++ ) { document . write ( palLength [ i ] + "▁" ) ; } }
function findMaxIntervals ( v , n ) { var maxi = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var c = n ; for ( var j = 0 ; j < n ; j ++ ) { if ( v [ i ] [ 1 ] < v [ j ] [ 0 ] v [ i ] [ 0 ] > v [ j ] [ 1 ] ) { c -- ; } } maxi = Math . max ( c , maxi ) ; } document . write ( maxi ) ; }
function update ( ss , se , si , X , V , tree , arr ) { if ( ss == se ) { if ( ss == X ) { arr [ X ] = V ; tree [ si ] = check ( V ) ; } return ; } var mid = parseInt ( ( ss + se ) / 2 ) ; if ( X <= mid ) update ( ss , mid , 2 * si + 1 , X , V , tree , arr ) ; else update ( mid + 1 , se , 2 * si + 2 , X , V , tree , arr ) ; tree [ si ] = tree [ 2 * si + 1 ] + tree [ 2 * si + 2 ] ; }
function atleast_x ( index , s , e , ql , qr , x ) { if ( ql > e qr < s ) return - 1 ; if ( s <= ql && e <= qr ) { if ( Tree [ index ] < x ) return - 1 ; while ( s != e ) { let m = parseInt ( ( s + e ) / 2 , 10 ) ; if ( Tree [ 2 * index ] >= x ) { e = m ; index = 2 * index ; } else { s = m + 1 ; index = 2 * index + 1 ; } } return s ; } let m = parseInt ( ( s + e ) / 2 , 10 ) ; let val = atleast_x ( 2 * index , s , m , ql , qr , x ) ; if ( val != - 1 ) return val ; return atleast_x ( 2 * index + 1 , m + 1 , e , ql , qr , x ) ; }
function rearrange ( a , n , x ) { for ( let i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; a . sort ( ) ; x = n - x ; let z = count ( a ) ; if ( x > n - z ) { document . write ( "-1" ) ; return ; } for ( let i = 0 ; i < n && x > 0 ; i += 2 ) { a [ i ] = - a [ i ] ; x -- ; } for ( let i = n - 1 ; i >= 0 && x > 0 ; i -- ) { if ( a [ i ] > 0 ) { a [ i ] = - a [ i ] ; x -- ; } } for ( let i = 0 ; i < n ; i ++ ) { document . write ( a [ i ] + "▁" ) ; } }
function countTriplets ( arr , N ) { var zero_i = [ ] ; var one_i = [ ] ; var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero_i . push ( i + 1 ) ; else if ( arr [ i ] == 1 ) one_i . push ( i + 1 ) ; else mp . set ( i + 1 , 1 ) ; } var total = zero_i . length * one_i . length * mp . size ; for ( var i = 0 ; i < zero_i . length ; i ++ ) { for ( var j = 0 ; j < one_i . length ; j ++ ) { var p = zero_i [ i ] ; var q = one_i [ j ] ; var r = 2 * p - q ; if ( mp . has ( r ) ) total -- ; r = 2 * q - p ; if ( mp . has ( r ) ) total -- ; r = ( p + q ) / 2 ; if ( mp . has ( r ) && Math . abs ( r - p ) == Math . abs ( r - q ) ) total -- ; } } document . write ( total ) ; }
function Pairs ( N , A , B ) { let powerA , powerB ; powerA = power ( A , N ) ; powerB = power ( B , N ) ; let letialB = B , letialA = A ; A = 1 ; for ( let i = 0 ; i <= powerA ; i ++ ) { B = 1 ; for ( let j = 0 ; j <= powerB ; j ++ ) { if ( B == N - A ) { document . write ( i + "▁" + j ) ; return ; } B *= letialB ; } A *= letialA ; } document . write ( "-1" ) ; return ; }
function CountSubarray ( arr , n , k ) { var temp = k , count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; }
function findElement ( arr , N , K ) { let ele = findElementUtil ( arr , N , K ) ; if ( ele == - 1 ) document . write ( "-1" ) ; else document . write ( ele ) ; }
function findCntTriplet ( N ) { let cntTriplet = 0 ; for ( let i = 1 ; i < N ; i ++ ) { if ( N % i != 0 ) { cntTriplet += Math . floor ( N / i ) ; } else { cntTriplet += Math . floor ( N / i ) - 1 ; } } return cntTriplet ; }
function splitString ( S , N ) { var c = S . charAt ( N - 1 ) ; var f = 0 ; for ( var i = 0 ; i < N - 1 ; i ++ ) { if ( S . charAt ( i ) == c ) { f = 1 ; break ; } } if ( f > 0 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function minOperations ( arr , n ) { let flips = 0 ; for ( let i = 0 ; i < n ; i += 2 ) { if ( arr [ i ] % 2 == 1 ) { continue ; } while ( i < n && arr [ i ] % 2 == 0 ) { i += 2 ; } flips ++ ; } for ( let i = 1 ; i < n ; i += 2 ) { if ( arr [ i ] % 2 == 1 ) { continue ; } while ( i < n && arr [ i ] % 2 == 0 ) { i += 2 ; } flips ++ ; } document . write ( flips ) ; }
function checkAnswer ( mp , N , K ) { for ( let i = 1 ; i <= N ; i ++ ) { if ( mp . has ( i ) ) if ( mp . get ( i ) == ( N - K + 1 ) ) { document . write ( i + "▁" ) ; return ; } } document . write ( - 1 + "▁" ) ; }
function updateAnswerArray ( answer , N ) { let i = 0 ; while ( answer [ i ] == - 1 ) i ++ ; let minimum = answer [ i ] ; while ( i <= N ) { if ( answer [ i ] == - 1 ) answer [ i ] = minimum ; else answer [ i ] = Math . min ( minimum , answer [ i ] ) ; minimum = Math . min ( minimum , answer [ i ] ) ; i ++ ; } }
function checkString ( X , Y ) { var L = - 1 ; var R = - 1 ; for ( var i = 0 ; i < X . length ; ++ i ) { if ( X [ i ] !== Y [ i ] ) { L = i ; break ; } } for ( var i = X . length - 1 ; i > 0 ; -- i ) { if ( X [ i ] !== Y [ i ] ) { R = i ; break ; } } X = X . substring ( 0 , L ) + reverse ( X . substring ( L , R + 1 ) ) + X . substring ( R + 1 ) ; if ( X === Y ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function longestLastingBulb ( onTime , s ) { let ans ; let n = onTime . length ; let maxDur = Number . MIN_VALUE ; let maxPos = Number . MIN_VALUE ; let currentDiff = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { currentDiff = onTime [ i ] ; maxDur = currentDiff ; maxPos = i ; } else { currentDiff = onTime [ i ] - onTime [ i - 1 ] ; if ( maxDur < currentDiff ) { maxDur = currentDiff ; maxPos = i ; } else { if ( maxDur == currentDiff ) { let one = s [ i ] ; let two = s [ maxPos ] ; if ( one > two ) { maxDur = currentDiff ; maxPos = i ; } } } } } ans = s [ maxPos ] ; return ans ; }
function max_freq ( arr , N ) { arr . sort ( ) ; let Max = arr [ N - 1 ] ; let Min = arr [ 0 ] ; let freq = [ ] ; for ( let i = 0 ; i < Max - Min + 1 ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] - Min ] ++ ; } let maxSum = 0 ; for ( let i = 0 ; i < ( Max - Min - 1 ) ; i ++ ) { let val = freq [ i ] + freq [ i + 1 ] + freq [ i + 2 ] ; maxSum = Math . max ( maxSum , val ) ; } document . write ( maxSum ) ; }
function find_longest_subarray ( A , N , K ) { let MaxLen = 0 ; let Len = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( K % A [ i ] == 0 ) { Len ++ ; MaxLen = Math . max ( MaxLen , Len ) ; } else { Len = 0 ; } } return MaxLen ; }
function SieveOfEratosthenes ( prime , p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; var p , i ; for ( p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
function kReducingStringUtil ( n , k , str , no_of_zeroes ) { var zeroes_in_2k = parseInt ( ( no_of_zeroes * ( 2 * k ) ) / n ) ; var ones_in_2k = 2 * k - zeroes_in_2k ; var temp_str = "" ; for ( var i = 0 ; i < zeroes_in_2k / 2 ; i ++ ) { temp_str += "0" ; } for ( var i = 0 ; i < ones_in_2k ; i ++ ) { temp_str += "1" ; } for ( var i = 0 ; i < zeroes_in_2k / 2 ; i ++ ) { temp_str += "0" ; } var final_str = "" ; for ( var i = 0 ; i < n / ( 2 * k ) ; i ++ ) { final_str += temp_str ; } for ( var i = 0 ; i < n % ( 2 * k ) ; i ++ ) { final_str += temp_str [ i ] ; } return final_str ; }
function power ( x , N ) { let res = 1 ; while ( N > 0 ) { if ( ( N & 1 ) != 0 ) { res = ( res * x ) ; } x = ( x * x ) ; N = N >> 1 ; } return res ; }
function countRemovableElem ( arr , N ) { let hash = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { hash [ i ] = 0 ; } let mex = N + 1 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= N ) hash [ arr [ i ] ] = 1 ; } for ( let i = 1 ; i <= N ; i ++ ) { if ( hash [ i ] == 0 ) { mex = i ; break ; } } document . write ( N - ( mex - 1 ) ) ; }
function findMaxPoints ( arr , n ) { let ans = findMaxPoint ( arr , 0 , n ) ; if ( ans [ 0 ] == INF ) { document . write ( - 1 ) ; } else { document . write ( "(" + ans [ 0 ] + "▁" + ans [ 1 ] + ")" ) ; } }
function numberOfGP ( L , N ) { if ( N <= 2 ) return 0 ; let count = 0 ; let res = 0 ; for ( let i = 2 ; i < N ; ++ i ) { if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
function palindrome ( a , i , j ) { while ( i < j ) { if ( a [ i ] != a [ j ] ) return false ; i ++ ; j -- ; } return true ; }
function countGreater ( arr , N ) { let St = new Set ( ) ; let countLeftGreater = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { St . add ( arr [ i ] ) ; let it = 0 ; for ( let st of St ) { if ( arr [ i ] < st ) it += 1 ; } countLeftGreater [ i ] = Math . abs ( it ) ; } display ( countLeftGreater , N ) ; }
function key ( N ) { let num = "" + N . toString ( ) ; let ans = 0 ; let j = 0 ; for ( j = 0 ; j < num . length ; j ++ ) { if ( ( num [ j ] . charCodeAt ( ) - 48 ) % 2 == 0 ) { let add = 0 ; let i ; for ( i = j ; j < num . length ; j ++ ) { add += num [ j ] . charCodeAt ( ) - 48 ; if ( add % 2 == 1 ) break ; } if ( add == 0 ) { ans *= 10 ; } else { let digit = Math . floor ( Math . log10 ( add ) + 1 ) ; ans *= parseInt ( Math . pow ( 10 , digit ) , 10 ) ; ans += add ; } i = j ; } else { let add = 0 ; let i ; for ( i = j ; j < num . length ; j ++ ) { add += num [ j ] . charCodeAt ( ) - 48 ; if ( add % 2 == 0 ) { break ; } } if ( add == 0 ) { ans *= 10 ; } else { let digit = Math . floor ( Math . log10 ( add ) + 1 ) ; ans *= parseInt ( Math . pow ( 10 , digit ) , 10 ) ; ans += add ; } i = j ; } } if ( j + 1 >= num . length ) { return ans ; } else { return ans += num [ num . length - 1 ] . charCodeAt ( ) - 48 ; } }
function longDelSub ( str1 , str2 ) { var N = str1 . length ; var M = str2 . length ; var prev_pos = 0 ; var pos = new Array ( M ) ; for ( let i = 0 ; i < M ; i ++ ) { var index = prev_pos ; while ( index < N && str1 [ index ] != str2 [ i ] ) { index ++ ; } pos [ i ] = index ; prev_pos = index + 1 ; } var res = N - prev_pos ; prev_pos = N - 1 ; for ( let i = M - 1 ; i >= 0 ; i -- ) { var index = prev_pos ; while ( index >= 0 && str1 [ index ] != str2 [ i ] ) { index -- ; } if ( i != 0 ) { res = Math . max ( res , index - pos [ i - 1 ] - 1 ) ; } prev_pos = index - 1 ; } res = Math . max ( res , prev_pos + 1 ) ; return res ; }
function countSubArray ( arr , n ) { if ( n < 2 ) return n ; let i = max_element ( arr ) ; let j = min_element ( arr ) ; if ( i > j ) { let tmp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = tmp ; } return ( i + 1 ) * ( n - j ) ; }
function isPerfectSquare ( n ) { var sr = Math . sqrt ( n ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
function updateFreq ( n , freq ) { while ( n ) { var digit = n % TEN ; freq [ digit ] ++ ; n = parseInt ( n / TEN ) ; } }
function count_numbers ( L , R ) { let ans = 0 ; let LogR = ( Math . log ( R ) + 1 ) ; for ( let zero_bit = 0 ; zero_bit < LogR ; zero_bit ++ ) { let cur = 0 ; for ( let j = 0 ; j < zero_bit ; j ++ ) { cur |= ( 1 << j ) ; } for ( let j = zero_bit + 1 ; j < LogR ; j ++ ) { cur |= ( 1 << j ) ; if ( cur >= L && cur <= R ) { ans ++ ; } } } return ans ; }
function maxGCD ( n ) { return parseInt ( n / 2 ) ; }
function updateTree ( str , pos , s ) { let index = pos ; update_BITree ( index , str [ index ] , - 1 ) ; str = str . substring ( 0 , index ) + s + str . substring ( index + 1 ) ; update_BITree ( index , s , 1 ) ; }
function minServerLoads ( n , servers ) { var totalLoad = 0 ; servers . forEach ( i => { totalLoad += i ; } ) ; var requiredLoad = parseInt ( totalLoad / 2 ) ; var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( requiredLoad + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i < n + 1 ; i ++ ) { for ( var j = 1 ; j < requiredLoad + 1 ; j ++ ) { if ( servers [ i - 1 ] > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , servers [ i - 1 ] + dp [ i - 1 ] [ j - servers [ i - 1 ] ] ) ; } } return totalLoad - 2 * dp [ n ] [ requiredLoad ] ; }
function maxLength ( arr ) { let len = Number . MIN_VALUE ; let N = arr . length ; for ( let i = 0 ; i < N ; i ++ ) { let l = arr [ i ] . length ; if ( len < l ) { len = l ; } } return len ; }
function dfs ( node ) { vis [ node ] = true ; for ( let x = 0 ; x < vec [ node ] . length ; x ++ ) { if ( ! vis [ vec [ node ] [ x ] ] ) { cc ++ ; dfs ( vec [ node ] [ x ] ) ; } } }
function solve ( D , N , X , Y ) { let T = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { let x = D [ i ] [ 0 ] ; let y = D [ i ] [ 1 ] ; let speed = D [ i ] [ 2 ] ; let time = ( ( x * x - X * X ) + ( y * y - Y * Y ) ) / ( speed * speed ) ; T . push ( time ) ; } T . sort ( function ( a , b ) { return a - b ; } ) ; let i = 0 ; let total = 0 ; while ( i < ( T . length - 1 ) ) { let count = 1 ; while ( ( i < ( T . length - 1 ) ) && ( T [ i ] == T [ i + 1 ] ) ) { count += 1 ; i += 1 ; } total += ( count * ( count - 1 ) ) / 2 ; i += 1 ; } return total ; }
function findSubarrays ( a ) { let n = a . length ; let freq = new Array ( n + 1 ) . fill ( 0 ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { if ( count == 0 ) continue ; else { let value = count ; for ( let j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } count = 0 ; } } else count ++ ; } if ( count > 0 ) { let value = count ; for ( let j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } } return freq ; }
function sumOfIndices ( s ) { let N = s . length ; let x = ( Math . ceil ( Math . log ( N ) / Math . log ( 2 ) ) ) ; let seg_size = 2 * Math . pow ( 2 , x ) - 1 ; let segment = new Array ( seg_size ) ; segment . fill ( 0 ) ; let count = 41 ; let fre = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { let key = s [ i ] . charCodeAt ( ) ; let que = [ ] ; if ( fre . has ( key ) ) { que = fre [ key ] ; } que . push ( i ) ; fre [ key ] = que ; } let array = Array . from ( fre . keys ( ) ) ; while ( array . length > 0 ) { let a = Array . from ( fre . keys ( ) ) ; let it = a [ 0 ] ; if ( fre [ it ] . length == 0 ) fre . delete ( it ) ; else { let que = fre [ it ] ; let original_index = que [ 0 ] ; let curr_index = deleted ( segment , 0 , original_index - 1 , 0 , N - 1 , 0 ) ; let new_index = original_index - curr_index ; count += new_index + 1 ; add_seg ( segment , 0 , N - 1 , 0 , original_index ) ; que . shift ( ) ; fre [ it ] = que ; } } document . write ( count ) ; }
function maxLength ( n , m ) { sieve ( ) ; smallestPrimeFactors ( ) ; let ans = Number . MIN_VALUE ; for ( let i = n ; i <= m ; i ++ ) { if ( i == 4 ) { continue ; } ans = Math . max ( ans , findLength ( i ) ) ; } return ans ; }
function getMax ( st , n , l , r ) { if ( l < 0 r > n - 1 l > r ) { document . write ( "Invalid▁Input" ) ; return - 1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; }
function subArraylen ( arr , n , K ) { var mp = new Map ( ) ; mp . set ( arr [ 0 ] , 0 ) ; for ( var i = 1 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; mp . set ( arr [ i ] , i ) ; } var len = 10000000000 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < K ) continue ; else { var x = arr [ i ] - K ; if ( x == 0 ) len = Math . min ( len , i ) ; if ( ! mp . has ( x ) ) continue ; else { len = Math . min ( len , i - mp . get ( x ) ) ; } } } return len ; }
function check ( arr , n ) { var i , g ; g = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 0 && g == 1 ) return false ; if ( arr [ i ] - arr [ i - 1 ] < 0 ) g = 1 ; } return true ; }
function addedge ( node1 , node2 ) { G [ node1 ] . push ( node2 ) ; G [ node2 ] . push ( node1 ) ; }
function countElements ( arr , n , k ) { var s = [ ] ; var next_greater = new Array ( n + 1 ) . fill ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( s . length === 0 ) { s . push ( i ) ; continue ; } while ( s . length !== 0 && arr [ s [ s . length - 1 ] ] < arr [ i ] ) { next_greater [ s [ s . length - 1 ] ] = i ; s . pop ( ) ; } s . push ( i ) ; } var count = 0 ; var maxi = - 2147483648 ; for ( var i = 0 ; i < n ; i ++ ) { if ( next_greater [ i ] - i > k && maxi < arr [ i ] ) { maxi = Math . max ( maxi , arr [ i ] ) ; count ++ ; } } return count ; }
function addEdge ( u , v ) { adj [ u ] . push ( v ) ; adj [ v ] . push ( u ) ; }
function constructTree ( n , edges ) { let adjl = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { adjl . push ( [ ] ) ; } for ( let e = 0 ; e < edges . length ; e ++ ) { let u = edges [ e ] [ 0 ] ; let v = edges [ e ] [ 1 ] ; adjl [ u ] . push ( v ) ; adjl [ v ] . push ( u ) ; } return adjl ; }
function min_remove ( arr , n , k ) { arr . sort ( ) ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { if ( arr [ j ] - arr [ i ] <= k ) { ans = Math . min ( ans , n - j + i - 1 ) ; } } } return ans ; }
function lcm ( a , b ) { return ( a * b ) / __gcd ( a , b ) ; }
function countPair ( N ) { var count = 0 ; for ( i = 1 ; i <= N ; i ++ ) { for ( j = 1 ; j <= N ; j ++ ) { if ( __gcd ( i , j ) + lcm ( i , j ) == N ) { count ++ ; } } } return count ; }
function isVowel ( c ) { if ( c == "a" c == "e" c == "i" c == "o" c == "u" ) return true ; return false ; }
function countSubstrings ( s , n ) { let temp = [ 1 , 0 ] ; let result = 0 , sum = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { sum += ( isVowel ( s [ i ] ) ? 1 : 0 ) ; sum %= 2 ; temp [ sum ] ++ ; } result += ( ( temp [ 0 ] * ( temp [ 0 ] - 1 ) ) / 2 ) ; result += ( ( temp [ 1 ] * ( temp [ 1 ] - 1 ) ) / 2 ) ; document . write ( result ) ; }
function minOperations ( s ) { let n = s . length ; let pos = - 1 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == "1" ) { pos = i ; break ; } } if ( pos == - 1 ) { return 0 ; } let last = 1 ; let ans = 1 ; for ( let i = pos + 1 ; i < n ; i ++ ) { if ( s [ i ] == "0" ) { if ( last == 1 ) { ans ++ ; last = 0 ; } } else { if ( last == 0 ) { ans ++ ; last = 1 ; } } } return ans ; }
function checkBitonic ( arr , n ) { let i , j , f = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { f = 1 ; break ; } } if ( i == n ) return true ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < arr [ j - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { if ( f == 1 ) return false ; } } return true ; }
function isNudeNum ( n ) { let copy , length , flag = 0 ; copy = n ; let temp ; temp = copy . toString ( ) ; length = temp . length ; for ( let i = 0 ; i < length ; i ++ ) { let num = temp [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ; if ( num == 0 n % num != 0 ) { flag = 1 ; } } if ( flag == 1 ) return false ; else return true ; }
function get_subminarr ( arr , n , y ) { var j = 0 ; var stk = [ ] ; var minarr = Array ( n ) ; stk . push ( 0 ) ; for ( var i = 1 ; i < n ; i ++ ) { while ( stk . length != 0 && arr [ i ] < arr [ stk [ stk . length - 1 ] ] ) { minarr [ stk [ stk . length - 1 ] ] = i ; stk . pop ( ) ; } stk . push ( i ) ; } while ( stk . length != 0 ) { minarr [ stk [ stk . length - 1 ] ] = n ; stk . pop ( ) ; } var submin = [ ] ; for ( var i = 0 ; i <= n - y ; i ++ ) { while ( minarr [ j ] <= i + y - 1 j < i ) { j ++ ; } submin . push ( arr [ j ] ) ; } return submin ; }
function PrintSequence ( freq , n ) { let sequence = generateSequence ( freq , n ) ; if ( sequence . length == 0 ) { document . write ( "-1" ) ; } else { for ( let i = 0 ; i < sequence . length ; i ++ ) { document . write ( sequence [ i ] + "▁" ) ; } } }
function checkArray ( A , B , N ) { var start = 0 ; var end = N - 1 ; for ( var i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { start = i ; break ; } } for ( var i = N - 1 ; i >= 0 ; i -- ) { if ( A [ i ] != B [ i ] ) { end = i ; break ; } } var l = start ; var r = end ; var d = parseInt ( ( r - l + 2 ) / 2 ) ; for ( var i = 0 ; i < d ; i ++ ) { var t = A [ l + i ] ; A [ l + i ] = A [ r - i ] ; A [ r - i ] = t ; } for ( var i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { document . write ( "No" ) ; return ; } } document . write ( "Yes" ) ; }
function longestSubarray ( a , n ) { var l = Array ( n ) . fill ( 0 ) ; var r = Array ( n ) . fill ( 0 ) ; for ( i = 0 , count = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; else { l [ i ] = count ; count = 0 ; } } for ( i = n - 1 , count = 0 ; i >= 0 ; i -- ) { if ( a [ i ] == 1 ) count ++ ; else { r [ i ] = count ; count = 0 ; } } var ans = - 1 ; for ( i = 0 ; i < n ; ++ i ) { if ( a [ i ] == 0 ) ans = Math . max ( ans , l [ i ] + r [ i ] ) ; } return ans < 0 ? n : ans ; }
function solve ( n , k ) { let ans = 0 ; for ( let j = 1 ; j * j <= n ; j ++ ) { if ( n % j == 0 ) { if ( j <= k ) { ans = Math . max ( ans , j ) ; } if ( n / j <= k ) { ans = Math . max ( ans , n / j ) ; } } } return ans ; }
function splitArray ( arr , N ) { arr . sort ( ) ; let result = Number . MAX_VALUE ; for ( let i = 1 ; i < N ; i ++ ) { result = Math . min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
function countTriplets ( a , n , x ) { var answer = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { for ( var k = j + 1 ; k < n ; k ++ ) { var temp = [ ] ; temp . push ( a [ i ] ) ; temp . push ( a [ j ] ) ; temp . push ( a [ k ] ) ; temp . sort ( ( a , b ) => a - b )  if ( temp [ 0 ] < temp [ 1 ] && temp [ 1 ] < temp [ 2 ] && temp [ 0 ] * temp [ 1 ] * temp [ 2 ] <= x ) answer ++ ; } } } return answer ; }
function fibonacci ( ) { let prev = 0 , curr = 1 , len = 2 ; fib . add ( prev ) ; fib . add ( curr ) ; while ( len <= MAX ) { let temp = curr + prev ; fib . add ( temp ) ; prev = curr ; curr = temp ; len ++ ; } }
function xorOfSum ( a , n ) { let answer = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; }
function createHash ( hash , maxElement ) { let prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr < maxElement ) { let temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } }
function state8 ( c ) { if ( c == "c" ) nfa = 9 ; else if ( c == "b" c == "a" ) nfa = 8 ; else flag = 1 ; }
function maxSum ( arr , n , k ) { if ( n < k ) { return - 1 ; } var res = 0 ; for ( i = 0 ; i < k ; i ++ ) res += arr [ i ] ; var curr_sum = res ; for ( i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; res = Math . max ( res , curr_sum ) ; } return res ; }
function isDigit ( ch ) { if ( ch >= "0" && ch <= "9" ) return true ; return false ; }
function nextPosition ( tempGCD , startPointer , prevEndPointer , n ) { let high = n - 1 ; let low = prevEndPointer ; let mid = prevEndPointer ; let nextPos = prevEndPointer ; while ( high >= low ) { mid = ( ( high + low ) >> 1 ) ; if ( queryForGCD ( startPointer , mid ) == tempGCD ) { nextPos = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return nextPos + 1 ; }
function gcd ( A , B ) { if ( B === 0 ) return A ; return gcd ( B , A % B ) ; }
function farthest_min ( a , n ) { let suffix_min = new Array ( n ) ; suffix_min [ n - 1 ] = a [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { suffix_min [ i ] = Math . min ( suffix_min [ i + 1 ] , a [ i ] ) ; } for ( let i = 0 ; i < n ; i ++ ) { let low = i + 1 , high = n - 1 , ans = - 1 ; while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( suffix_min [ mid ] < a [ i ] ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } document . write ( ans + "▁" ) ; } }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function solve ( array , n , K ) { var max = array . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var end = 0 ; for ( var i = 0 ; i < n ; i ++ ) { } var answer = 0 ; while ( start <= end ) { var mid = parseInt ( ( start + end ) / 2 ) ; if ( check ( mid , array , n , K ) ) { answer = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } return answer ; }
function isPossible ( box , truck , n , m , min_time ) { let temp = 0 ; let count = 0 ; while ( count < m ) { for ( let j = 0 ; j < min_time && temp < n && truck [ count ] >= box [ temp ] ; j += 2 ) temp ++ ; count ++ ; } if ( temp == n ) return true ; return false ; }
function solve ( interval , N , Q ) { var Mark = Array ( Q ) . fill ( 0 ) ; for ( var i = 0 ; i < N ; i ++ ) { var l = interval [ i ] [ 0 ] - 1 ; var r = interval [ i ] [ 1 ] - 1 ; for ( var j = l ; j <= r ; j ++ ) Mark [ j ] ++ ; } var count = 0 ; for ( var i = 0 ; i < Q ; i ++ ) { if ( Mark [ i ] ) count ++ ; } var count1 = Array ( Q ) . fill ( 0 ) ; if ( Mark [ 0 ] == 1 ) count1 [ 0 ] = 1 ; for ( var i = 1 ; i < Q ; i ++ ) { if ( Mark [ i ] == 1 ) count1 [ i ] = count1 [ i - 1 ] + 1 ; else count1 [ i ] = count1 [ i - 1 ] ; } var maxindex ; var maxcoverage = 0 ; for ( var i = 0 ; i < N ; i ++ ) { var l = interval [ i ] [ 0 ] - 1 ; var r = interval [ i ] [ 1 ] - 1 ; var elem1 ; if ( l != 0 ) elem1 = count1 [ r ] - count1 [ l - 1 ] ; else elem1 = count1 [ r ] ; if ( count - elem1 >= maxcoverage ) { maxcoverage = count - elem1 ; maxindex = i ; } } document . write ( "Maximum▁Coverage▁is▁" + maxcoverage + "▁after▁removing▁interval▁at▁index▁" + maxindex ) ; }
function maxSum ( arr , n , K ) { var maximum = - 1000000000 ; var sum = Array ( n ) . fill ( 0 ) ; for ( var i = n - 1 ; i >= 0 ; i -- ) { if ( i + K < n ) sum [ i ] = sum [ i + K ] + arr [ i ] ; else sum [ i ] = arr [ i ] ; maximum = Math . max ( maximum , sum [ i ] ) ; } return maximum ; }
function countGreater ( arr , n , k ) { var l = 0 ; var r = n - 1 ; var leftGreater = n ; while ( l <= r ) { var m = l + parseInt ( ( r - l ) / 2 ) ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; }
function countFactor ( P , X ) { if ( X < P ) return 0 ; return ( parseInt ( X / P ) + countFactor ( P , parseInt ( X / P ) ) ) ; }
function squareSum ( N ) { var sum = parseInt ( ( N * ( N + 1 ) * ( 2 * N + 1 ) ) / 6 ) ; return sum ; }
function countPattern ( n , pat ) { let pattern_int = 0 ; let power_two = 1 ; let all_ones = 0 ; for ( let i = pat . length - 1 ; i >= 0 ; i -- ) { let current_bit = pat . charAt ( i ) - "0" ; pattern_int += ( power_two * current_bit ) ; all_ones = all_ones + power_two ; power_two = power_two * 2 ; } let count = 0 ; while ( n != 0 && n >= pattern_int ) { if ( ( n & all_ones ) == pattern_int ) { count ++ ; } n = n >> 1 ; } return count ; }
function getMax ( arr , n ) { let res = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) res = Math . max ( res , arr [ i ] ) ; return res ; }
function printDuplicates ( arr , n ) { let i ; let fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { document . write ( arr [ i ] % n + "▁" ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! fl ) document . write ( "-1" ) ; }
function maxProduct ( arr , n ) { if ( n < 4 ) return - 1 ; arr . sort ( function ( a , b ) { return a - b ; } ) ; let x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; let y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; let z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return Math . max ( x , Math . max ( y , z ) ) ; }
function maxProduct ( arr , n ) { if ( n < 4 ) { return - 1 ; } let maxA = Number . MIN_VALUE , maxB = Number . MIN_VALUE , maxC = Number . MIN_VALUE , maxD = Number . MIN_VALUE ; let minA = Number . MAX_VALUE , minB = Number . MAX_VALUE , minC = Number . MAX_VALUE , minD = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxD = maxC ; maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxD = maxC ; maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) { maxD = maxC ; maxC = arr [ i ] ; } else if ( arr [ i ] > maxD ) { maxD = arr [ i ] ; } if ( arr [ i ] < minA ) { minD = minC ; minC = minB ; minB = minA ; minA = arr [ i ] ; } else if ( arr [ i ] < minB ) { minD = minC ; minC = minB ; minB = arr [ i ] ; } else if ( arr [ i ] < minC ) { minD = minC ; minC = arr [ i ] ; } else if ( arr [ i ] < minD ) { minD = arr [ i ] ; } } let x = maxA * maxB * maxC * maxD ; let y = minA * minB * minC * minD ; let z = minA * minB * maxA * maxB ; return Math . max ( x , Math . max ( y , z ) ) ; }
function push ( head_ref , new_data ) { var new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; head = head_ref ; }
function isPossible ( arr , n , m , curr_min ) { let studentsRequired = 1 ; let curr_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > curr_min ) return false ; if ( curr_sum + arr [ i ] > curr_min ) { studentsRequired ++ ; curr_sum = arr [ i ] ; if ( studentsRequired > m ) return false ; } else curr_sum += arr [ i ] ; } return true ; }
function sortArray ( arr , N ) { var i = 0 , j = N - 1 , mid = 0 ; while ( mid <= j ) { if ( arr [ mid ] == 0 ) { var temp = arr [ i ] ; arr [ i ] = arr [ mid ] ; arr [ mid ] = temp ; i ++ ; mid ++ ; } else if ( arr [ mid ] == 3 ) { var temp = arr [ mid ] ; arr [ mid ] = arr [ j ] ; arr [ j ] = temp ; j -- ; } else if ( arr [ mid ] == 1 arr [ mid ] == 2 ) { mid ++ ; } } while ( i <= j ) { if ( arr [ i ] == 2 ) { var temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; j -- ; } else { i ++ ; } } for ( i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function isSorted ( arr , N ) { for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] [ 0 ] > arr [ i - 1 ] [ 0 ] ) { return false ; } } return true ; }
function isSortedArray ( arr , n ) { var l = 0  var r = ( n - 1 )  while ( ( l + 1 ) < r ) { if ( arr [ l ] >= Math . max ( arr [ l + 1 ] , arr [ r - 1 ] ) && arr [ r ] >= Math . max ( arr [ r - 1 ] , arr [ l + 1 ] ) ) { l += 1 r -= 1 } else return false } return true }
function findMaxNumbers ( arr , n , k ) { arr . sort ( ) ; let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let opr = Math . ceil ( Math . log2 ( arr [ i ] ) ) ; k -= opr ; if ( k < 0 ) { break ; } cnt ++ ; } document . write ( cnt ) ; }
function rearrange ( A , B , N , X ) { let flag = true ; A . sort ( ) ; B . sort ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ N - 1 - i ] > X ) { flag = false ; break ; } } if ( flag == true ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function getMinCost ( arr , n , k ) { arr . sort ( ( a , b ) => b - a ) ; var min_cost = 0 ; var X = 0 ; for ( var i = 0 ; i < n ; i += k ) { for ( var j = i ; j < i + k && j < n ; j ++ ) { min_cost += arr [ j ] * ( X + 1 ) ; } X ++ ; } return min_cost ; }
function mergeSortUtil ( arr , temp , l , r , K ) { let cnt = 0 ; if ( l < r ) { let m = parseInt ( ( l + r ) / 2 , 10 ) ; cnt += mergeSortUtil ( arr , temp , l , m , K ) ; cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) ; cnt += merge ( arr , temp , l , m , r , K ) ; } return cnt ; }
function Bubble_Sort ( arr , n ) { for ( var i = 1 ; i < n ; ++ i ) { for ( var j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { var temm = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temm ; } } } }
function mostvisitedsector ( N , A ) { var maxVisited = 0 ; var mp = new Map ( ) ; for ( var i = 0 ; i < A . length - 1 ; i ++ ) { var start = A [ i ] % N ; var end = A [ i + 1 ] % N ; while ( start != end ) { if ( start == 0 ) { if ( mp . has ( N ) ) mp . set ( N , mp . get ( N ) + 1 ) ; else mp . set ( N , 1 ) ; if ( mp . get ( N ) > maxVisited ) { maxVisited = mp . get ( N ) ; } } else { if ( mp . has ( start ) ) mp . set ( start , mp . get ( start ) + 1 ) else mp . set ( start , 1 ) ; if ( mp . get ( start ) > maxVisited ) { maxVisited = mp . get ( start ) ; } } start = ( start + 1 ) % N ; } } var back = A [ A . length - 1 ] ; if ( mp . has ( back ) ) mp . set ( back , mp . get ( back ) + 1 ) else mp . set ( back , 1 ) ; if ( mp . get ( back ) > maxVisited ) { maxVisited = mp . get ( back ) ; } mp . forEach ( ( value , key ) => { if ( value == maxVisited ) { document . write ( key + "▁" ) ; } } ) ; }
function maxRectangle ( sequence , size ) { let X_Cord = [ ] ; let Y_Cord = [ ] ; for ( let i = 0 ; i < size ; i ++ ) { X_Cord [ i ] = sequence [ i ] [ 0 ] ; Y_Cord [ i ] = sequence [ i ] [ 1 ] ; } X_Cord . sort ( ) ; Y_Cord . sort ( ) ; let X_Max = 0 , Y_Max = 0 ; for ( let i = 0 ; i < size - 1 ; i ++ ) { X_Max = Math . max ( X_Max , X_Cord [ i + 1 ] - X_Cord [ i ] ) ; Y_Max = Math . max ( Y_Max , Y_Cord [ i + 1 ] - Y_Cord [ i ] ) ; } return X_Max * Y_Max ; }
function evenSumK ( arr , N , K ) { if ( K > N ) { return - 1 ; } var maxSum = 0 ; var Even = [ ] ; var Odd = [ ] ; for ( var i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 ) { Odd . push ( arr [ i ] ) ; } else { Even . push ( arr [ i ] ) ; } } Odd . sort ( ( a , b ) => a - b ) ; Even . sort ( ( a , b ) => a - b ) ; var i = Even . length - 1 ; var j = Odd . length - 1 ; while ( K > 0 ) { if ( K % 2 == 1 ) { if ( i >= 0 ) { maxSum += Even [ i ] ; i -- ; } else { return - 1 ; } K -- ; } else if ( i >= 1 && j >= 1 ) { if ( Even [ i ] + Even [ i - 1 ] <= Odd [ j ] + Odd [ j - 1 ] ) { maxSum += Odd [ j ] + Odd [ j - 1 ] ; j -= 2 ; } else { maxSum += Even [ i ] + Even [ i - 1 ] ; i -= 2 ; } K -= 2 ; } else if ( i >= 1 ) { maxSum += Even [ i ] + Even [ i - 1 ] ; i -= 2 ; K -= 2 ; } else if ( j >= 1 ) { maxSum += Odd [ j ] + Odd [ j - 1 ] ; j -= 2 ; K -= 2 ; } } return maxSum ; }
function find_mth_bitUtil ( n , m ) { let fib = new Array ( maxN ) ; calculateFib ( fib , maxN ) ; let ans = find_mth_bit ( n , m , fib ) ; document . write ( ans + "▁" ) ; }
function range_sum ( arr , a , b ) { let sum = 0 ; if ( a - 2 < 0 ) sum = arr [ b - 1 ] ; else sum = arr [ b - 1 ] - arr [ a - 2 ] ; return sum ; }
function XorSum ( A , B , N ) { let maxBit = 29 ; let ans = 0 ; for ( let k = 0 ; k < maxBit ; k ++ ) { let C = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { C [ i ] = B [ i ] % ( 1 << ( k + 1 ) ) ; } C . sort ( function ( x , y ) { return x - y ; } ) ; let count = 0 ; let l , r ; for ( let i = 0 ; i < N ; i ++ ) { let x = A [ i ] % ( 1 << ( k + 1 ) ) ; l = lower_bound ( C , 0 , N , ( 1 << k ) - x ) ; r = lower_bound ( C , 0 , N , ( 1 << k ) * 2 - x ) ; count += ( r - l ) ; l = lower_bound ( C , 0 , N , ( 1 << k ) * 3 - x ) ; r = lower_bound ( C , 0 , N , ( 1 << k ) * 4 - x ) ; count += ( r - l ) ; } if ( ( count & 1 ) != 0 ) ans += ( 1 << k ) ; } return ans ; }
function countPairs ( arr , n ) { let ans = 0 ; let count = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( count . has ( arr [ i ] ) ) { ans += count . get ( arr [ i ] ) ; count . set ( arr [ i ] , count . get ( arr [ i ] ) + 1 ) ; } else { count . set ( arr [ i ] , 1 ) ; } } return ans ; }
function getAlphaScore ( node ) { if ( node . left != null ) getAlphaScore ( node . left ) ; sum = ( sum + node . data ) % mod ; total_sum = ( total_sum + sum ) % mod ; if ( node . right != null ) getAlphaScore ( node . right ) ; return total_sum ; }
function sortArr ( a , n ) { let i , k ; k = parseInt ( Math . log ( n ) / Math . log ( 2 ) ) ; k = parseInt ( Math . pow ( 2 , k ) ) ; while ( k > 0 ) { for ( i = 0 ; i + k < n ; i ++ ) if ( a [ i ] > a [ i + k ] ) { let tmp = a [ i ] ; a [ i ] = a [ i + k ] ; a [ i + k ] = tmp ; } k = k / 2 ; } for ( i = 0 ; i < n ; i ++ ) { document . write ( a [ i ] + "▁" ) ; } }
function maximizeval10 ( a , n , k ) { let increments = 0 ; let ans = 0 ; let v = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { ans += Math . floor ( a [ i ] / 10 ) ; if ( a [ i ] == 1000 ) continue ; else { v . push ( 10 - a [ i ] % 10 ) ; increments += ( 100 - ( Math . floor ( a [ i ] ) / 10 ) - 1 ) ; } } v . sort ( function ( a , b ) { return a - b ; } ) ; let sum = 0 ; for ( let i = 0 ; i < v . length ; i ++ ) { sum += v [ i ] ; if ( sum <= k ) { ans ++ ; } else break ; } if ( sum < k ) { let remaining = k - sum ; ans += Math . min ( increments , Math . floor ( remaining / 10 ) ) ; } document . write ( ans ) ; }
function number ( a , n , p , k ) { a . sort ( ) ; var pre = Array ( n ) . fill ( 0 ) , val , i , j , ans = 0 ; pre [ 0 ] = a [ 0 ] ; if ( pre [ 0 ] <= p ) ans = 1 ; for ( i = 1 ; i < k - 1 ; i ++ ) { pre [ i ] = pre [ i - 1 ] + a [ i ] ; if ( pre [ i ] <= p ) ans = i + 1 ; } pre [ k - 1 ] = a [ k - 1 ] ; for ( i = k - 1 ; i < n ; i ++ ) { if ( i >= k ) { pre [ i ] += pre [ i - k ] + a [ i ] ; } if ( pre [ i ] <= p ) ans = i + 1 ; } return ans ; }
function checkIsAP ( arr , n ) { if ( n == 1 ) return true ; arr . sort ( function ( a , b ) { return a - b ; } ) ; var d = arr [ 1 ] - arr [ 0 ] ; for ( var i = 2 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != d ) { return false ; } } return true ; }
function findK ( arr , size , N ) { arr . sort ( function ( a , b ) { return a - b } ) ; let temp_sum = 0 ; for ( let i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return - 1 ; }
function findSum ( arr , n , k , l , r ) { if ( ( l ) + ( n - 1 - r ) == k ) return arr [ r ] - arr [ l ] ; if ( vis [ l ] [ r ] ) return dp [ l ] [ r ] ; vis [ l ] [ r ] = 1 ; dp [ l ] [ r ] = Math . min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; return dp [ l ] [ r ] ; }
function printList ( node ) { last ; while ( node != null ) { document . write ( node . data + "▁" ) ; last = node ; node = node . next ; } }
function Removal ( v , n ) { v . sort ( ( a , b ) => a - b ) ; var ans = 2147483648 ; var k = 0 ; for ( const i of v ) { var j = upperBound ( v , 2 * i ) ; ans = Math . min ( ans , n - ( j - k ) ) ; k ++ ; } return ans ; }
function printArrangement ( a , n ) { a . sort ( ) ; var b = Array ( n ) . fill ( 0 ) ; var low = 0 , high = n - 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) b [ low ++ ] = a [ i ] ; else b [ high -- ] = a [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { if ( b [ n - 1 ] + b [ 1 ] <= b [ i ] ) { document . write ( - 1 ) ; return ; } } else if ( i == ( n - 1 ) ) { if ( b [ n - 2 ] + b [ 0 ] <= b [ i ] ) { document . write ( - 1 ) ; return ; } } else { if ( b [ i - 1 ] + b [ i + 1 ] <= b [ i ] ) { document . write ( - 1 ) ; return ; } } } for ( i = 0 ; i < n ; i ++ ) document . write ( b [ i ] + "▁" ) ; }
function K_multiple ( a , n , k ) { a . sort ( ( a , b ) => a - b ) ; let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] % k == 0 && ! s . has ( a [ i ] / k ) ) a [ i ] % k != 0 ) s . add ( a [ i ] ) ; } for ( let i of s ) { document . write ( i + "▁" ) ; } }
function powmod ( a , n ) { if ( ! n ) return 1 ; let pt = powmod ( a , parseInt ( n / 2 ) ) ; pt = ( pt * pt ) % mod ; if ( n % 2 ) return ( pt * a ) % mod ; else return pt ; }
function product ( a , n , k ) { let ans = 1 ; a . sort ( function ( a , b ) { return a - b } ) ; let powa = C [ n - 1 ] [ k - 1 ] ; for ( let i = 0 ; i < n ; i ++ ) { let powla = C [ i ] [ k - 1 ] ; let powfa = C [ n - i - 1 ] [ k - 1 ] ; let powe = ( ( powa % MOD ) - ( powla + powfa ) % MOD + MOD ) % MOD ; let mul = power ( a [ i ] , powe ) % MOD ; ans = ( ( ans % MOD ) * ( mul % MOD ) ) % MOD ; } return ans % MOD ; }
function check ( s ) { let l = s . length ; s . sort ( ) ; for ( let i = 1 ; i < l ; i ++ ) { if ( ( s [ i ] . charCodeAt ( ) - s [ i - 1 ] . charCodeAt ( ) ) != 1 ) return false ; } return true ; }
function printNumbers ( arr , n ) { arr . sort ( ( a , b ) => { return a - b ; } ) ; var A = arr [ n - 1 ] , B = - 1 ; for ( var i = n - 2 ; i >= 0 ; i -- ) { if ( ( A % arr [ i ] ) != 0 ) { B = arr [ i ] ; break ; } if ( i - 1 >= 0 && arr [ i ] == arr [ i - 1 ] ) { B = arr [ i ] ; break ; } } document . write ( "A▁=▁" + A + ",▁B▁=▁" + B ) ; }
function findNonPalinString ( s ) { var freq = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; var flag = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] != s [ 0 ] ) flag = 1 ; freq [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } if ( flag == 0 ) document . write ( "-1" ) ; else { for ( var i = 0 ; i < 26 ; i ++ ) for ( var j = 0 ; j < freq [ i ] ; j ++ ) document . write ( String . fromCharCode ( "a" . charCodeAt ( 0 ) + i ) ) ; } }
function countDistinct ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } res ++ ; } return res ; }
function minSubarray ( A , n ) { let minValue = Number . MAX_VALUE ; let maxValue = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { minValue = Math . min ( minValue , A [ i ] ) ; maxValue = Math . max ( maxValue , A [ i ] ) ; } let pos_min = - 1 , pos_max = - 1 , ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( A [ i ] == minValue ) pos_min = i ; if ( A [ i ] == maxValue ) pos_max = i ; if ( pos_max != - 1 && pos_min != - 1 ) ans = Math . min ( ans , Math . abs ( pos_min - pos_max ) + 1 ) ; } return ans ; }
function countTriplets ( head , x ) { let ptr , ptr1 , ptr2 ; let count = 0 ; let um = new Map ( ) ; for ( ptr = head ; ptr != null ; ptr = ptr . next ) { um . set ( ptr . data , ptr ) ; } for ( ptr1 = head ; ptr1 != null ; ptr1 = ptr1 . next ) { for ( ptr2 = ptr1 . next ; ptr2 != null ; ptr2 = ptr2 . next ) { let p_product = ( ptr1 . data * ptr2 . data ) ; if ( um . has ( x / p_product ) && um . get ( x / p_product ) != ptr1 && um . get ( x / p_product ) != ptr2 ) { count ++ ; } } } return ( count / 3 ) ; }
function countTriplets ( arr , n , m ) { let count = 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; let end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { let prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
function countTripletsLessThan ( arr , n , val ) { arr . sort ( ) ; var ans = 0 ; var j , k ; var sum ; for ( var i = 0 ; i < n - 2 ; i ++ ) { j = i + 1 ; k = n - 1 ; while ( j != k ) { sum = arr [ i ] + arr [ j ] + arr [ k ] ; if ( sum > val ) k -- ; else { ans += k - j ; j ++ ; } } } return ans ; }
function MaxSumDifference ( a , n ) { let finalSequence = [ ] ; a . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < n / 2 ; ++ i ) { finalSequence . push ( a [ i ] ) ; finalSequence . push ( a [ n - i - 1 ] ) ; } if ( n % 2 != 0 ) finalSequence . push ( a [ Math . floor ( n / 2 ) ] ) ; let MaximumSum = 0 ; for ( let i = 0 ; i < n - 1 ; ++ i ) { MaximumSum = MaximumSum + Math . abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ; } MaximumSum = MaximumSum + Math . abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ; return MaximumSum ; }
function findMinimum ( arr , n , k ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { res += arr [ i ] ; n = n - k ; } return res ; }
function minSwapToReachArr ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] - 1 ) - i > 2 ) { return - 1 ; } } let numOfInversion = mergeSort ( arr , N ) ; return numOfInversion ; }
function getIndexInSortedArray ( arr , n , idx ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function gnomeSort ( arr , n ) { let index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { let temp = 0 ; temp = arr [ index ] ; arr [ index ] = arr [ index - 1 ] ; arr [ index - 1 ] = temp ; index -- ; } } return ; }
function flip ( arr , i ) { let temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } }
function possible ( x , S , N ) { let minSum = ( x * ( x + 1 ) ) / 2 ; let maxSum = ( x * ( 2 * N - x + 1 ) ) / 2 ; if ( S < minSum S > maxSum ) { return false ; } return true ; }
function TotalPerfectPowerSum ( L , R ) { let pows = [ ] ; pows . push ( 0 ) ; pows . push ( 1 ) ; for ( let p = 2 ; p < 25 ; p ++ ) { let num = 2 ; while ( Math . floor ( Math . pow ( num , p ) + 0.5 ) <= R ) { pows . push ( Math . floor ( Math . pow ( num , p ) + 0.5 ) ) ; num ++ ; } } let ok = new Array ( R + 1 ) . fill ( 0 ) ; for ( let i = 0 ; i < pows . length ; i ++ ) { for ( let j = 0 ; j < pows . length ; j ++ ) { if ( pows [ i ] + pows [ j ] <= R && pows [ i ] + pows [ j ] >= L ) { ok [ pows [ i ] + pows [ j ] ] = 1 ; } } } for ( let i = 1 ; i <= R ; i ++ ) { ok [ i ] += ok [ i - 1 ] ; } return ok [ R ] - ok [ L - 1 ] ; }
function KthSolution ( X , K ) { let ans = 0 ; for ( let i = 0 ; i < 64 ; i ++ ) { if ( ! ( X & ( 1 << i ) ) ) { if ( K & 1 ) { ans |= ( 1 << i ) ; } K >>= 1 ; if ( ! K ) { break ; } } } return ans ; }
function countNoOfsuchX ( N ) { let k = Math . floor ( Math . log10 ( N ) ) + 1 ; let count = 1 ; for ( let x = ( N - ( k * ( k + 1 ) * 5 ) ) ; x <= N ; x ++ ) { if ( check ( x , N ) ) { count += 1 ; } } return count ; }
function countArrays ( n , k ) { let divisors = new Array ( k + 1 ) . fill ( new Array ( ) ) ; for ( let i = 1 ; i <= k ; i ++ ) { for ( let j = 2 * i ; j <= k ; j += i ) { divisors [ j ] . push ( i ) ; } } let dp = new Array ( n + 1 ) . fill ( new Array ( k + 1 ) ) ; for ( let j = 1 ; j <= k ; j ++ ) { dp [ 1 ] [ j ] = 1 ; } for ( let x = 2 ; x <= n ; x ++ ) { let sum = 0 ; for ( let j = 1 ; j <= k ; j ++ ) { sum += dp [ x - 1 ] [ j ] ; } for ( let y = 1 ; y <= k ; y ++ ) { dp [ x ] [ y ] = sum ; for ( let d of divisors [ y ] ) { dp [ x ] [ y ] = ( dp [ x ] [ y ] - dp [ x - 1 ] [ d ] ) ; } } } let sum = 0 ; for ( let j = 1 ; j <= k ; j ++ ) { sum += dp [ n ] [ j ] ; } sum ++ ; return sum ; }
function checkStar ( mat ) { var vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( var i = 0 ; i < size ; i ++ ) { var degreeI = 0 ; for ( var j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function convertXintoY ( X , Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y = parseInt ( Y / 2 ) ; else if ( Y % 10 == 1 ) Y = parseInt ( Y /= 10 ) ; else break ; } if ( X == Y ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function MaxXOR ( arr , N ) { var res = 0 ; for ( var i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; }
function countCandies ( arr , n ) { let sum = 0 ; let ans = new Array ( n ) ; if ( n == 1 ) { return 1 ; } for ( let i = 0 ; i < n ; i ++ ) ans [ i ] = 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i + 1 ] > arr [ i ] && ans [ i + 1 ] <= ans [ i ] ) { ans [ i + 1 ] = ans [ i ] + 1 ; } } for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > arr [ i + 1 ] && ans [ i ] <= ans [ i + 1 ] ) { ans [ i ] = ans [ i + 1 ] + 1 ; } else if ( arr [ i ] == arr [ i + 1 ] && ans [ i ] < ans [ i + 1 ] ) { ans [ i ] = ans [ i + 1 ] + 1 ; } sum += ans [ i ] ; } sum += ans [ n - 1 ] ; return sum ; }
function findMinOperations ( arr , N , K ) { var operations = 0 ; var i , j ; for ( i = 0 ; i < K ; i ++ ) { var freq = new Map ( ) ; for ( j = i ; j < N ; j += K ) { if ( freq . has ( arr [ j ] ) ) freq . set ( arr [ j ] , freq . get ( arr [ j ] ) + 1 ) ; else freq . set ( arr [ j ] , 1 ) ; } var max1 = 0 , num ; for ( const [ key , value ] of freq . entries ( ) ) { if ( value > max1 ) { max1 = value ; num = key ; } } for ( const [ key , value ] of freq . entries ( ) ) { if ( key != num ) operations += value ; } } document . write ( operations ) ; }
function minSizeArr ( A , N , K ) { let leftTaken = N , rightTaken = N ; let leftSum = 0 , rightSum = 0 ; for ( let left = - 1 ; left < N ; left ++ ) { if ( left != - 1 ) leftSum += A [ left ] ; rightSum = 0 ; for ( let right = N - 1 ; right > left ; right -- ) { rightSum += A [ right ] ; if ( leftSum + rightSum == K ) { if ( leftTaken + rightTaken > ( left + 1 ) + ( N - right ) ) { leftTaken = left + 1 ; rightTaken = N - right ; } break ; } if ( leftSum + rightSum > K ) break ; } } if ( leftTaken + rightTaken <= N ) { for ( let i = 0 ; i < leftTaken ; i ++ ) document . write ( A [ i ] + "▁" ) ; for ( let i = 0 ; i < rightTaken ; i ++ ) document . write ( A [ N - i - 1 ] + "▁" ) ; } else document . write ( - 1 ) ; }
function is_prime ( n ) { if ( n == 1 ) { return false ; } for ( var i = 2 ; i <= parseInt ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
function consecutive_primes ( n ) { var first = - 1 , second = - 1 ; for ( var i = parseInt ( Math . sqrt ( n ) ) ; i >= 2 ; i -- ) { if ( is_prime ( i ) ) { first = i ; break ; } } for ( var i = parseInt ( Math . sqrt ( n ) ) + 1 ; i <= parseInt ( n / 2 ) ; i ++ ) { if ( is_prime ( i ) ) { second = i ; break ; } } if ( first * second >= n ) { document . write ( first + "▁" + second ) ; } else { for ( var i = second + 1 ; i <= n ; i ++ ) { if ( is_prime ( i ) ) { document . write ( second + "▁" + i ) ; return ; } } } }
function arrayBitwiseAND ( size ) { let result = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) { let temp = prefixCount [ i ] [ size - 1 ] ; if ( temp == size ) result = ( result | ( 1 << i ) ) ; } document . write ( result + "▁" ) ; }
function findbitwiseAND ( queries , arr , N , M ) { prefixCount = new Array ( 32 ) ; for ( var i = 0 ; i < prefixCount . length ; i ++ ) { prefixCount [ i ] = new Array ( 2 ) ; } findPrefixCount ( arr , N ) ; for ( let i = 0 ; i < M ; i ++ ) { let id = queries [ i ] [ 0 ] ; let newVal = queries [ i ] [ 1 ] ; let currentVal = arr [ id ] ; arr [ id ] = newVal ; applyQuery ( currentVal , newVal , N ) ; arrayBitwiseAND ( N ) ; } }
function stepscount ( a , b ) { let chanceA = 2 * a - 1 ; ; let chanceB = 2 * b ; if ( chanceA < chanceB ) { document . write ( "B" ) ; } else if ( chanceB < chanceA ) { document . write ( "A" ) ; } return 0 ; }
function checkpoint ( h , k , x , y , a , b ) { p = ( ( Math . pow ( ( x - h ) , 2 ) / Math . pow ( a , 2 ) ) - ( Math . pow ( ( y - k ) , 2 ) / Math . pow ( b , 2 ) ) )  if ( p > 1 ) console . log ( "Outside" ) ; else if ( p == 1 ) console . log ( "On▁the▁Hyperbola" ) ; else console . log ( "Inside" ) ; }
function rotateString ( n , m , s ) { var v = [ ] ; var cnt = 0 ; var i ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == "1" ) { v . push ( i ) ; } } for ( i = 1 ; i < v . length ; i ++ ) { if ( ( v [ i ] - v [ i - 1 ] - 1 ) > m ) { cnt ++ ; } } if ( v . length >= 2 && ( n - ( v [ v . length - 1 ] - v [ 0 ] ) - 1 ) > m ) { cnt ++ ; } if ( cnt <= 1 ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function findNumber ( N ) { let ans = [ 1 , 2 , 4 , 8 , 7 , 5 ] ; return ans [ N % 6 ] ; }
function countDecrements ( arr ) { let count_1 = 0 ; let count_2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_1 ++ ; if ( 1 - ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_2 ++ ; } } document . write ( Math . min ( count_1 , count_2 ) ) ; }
function maximumIndex ( N , B ) { let i = 0 , j = 1 ; let cnt = 0 ; let sum = Math . floor ( N * ( N + 1 ) / 2 ) ; let flag = false ; while ( cnt < N ) { i += j ; j ++ ; cnt ++ ; if ( i == B ) { flag = true ; break ; } } if ( ! flag ) { document . write ( sum ) ; } else document . write ( sum - 1 ) ; }
function sumOfDigits ( N ) { let sum = 0 ; while ( N != 0 ) { sum += N % 10 ; N = Math . floor ( N / 10 ) ; } return sum ; }
function distIntegers ( L , R ) { return 2 * R - 2 * L + 1 ; }
function maximumNum ( X , Y , N ) { let num = 0 ; if ( N - N % X + Y <= N ) { num = N - N % X + Y ; } else { num = N - N % X - ( X - Y ) ; } return num ; }
function findKthElement ( N , K ) { var v = [ ] ; for ( i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { v . push ( i ) ; } } for ( i = 1 ; i <= N ; i ++ ) { if ( i % 2 != 0 ) { v . push ( i ) ; } } document . write ( v [ K - 1 ] ) ; }
function printLargestDivisible ( arr , N ) { var i , count0 = 0 , count7 = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) count0 ++ ; else count7 ++ ; } if ( count7 % 50 == 0 ) { while ( count7 -- ) document . write ( 7 ) ; while ( count0 -- ) document . write ( 0 ) ; } else if ( count7 < 5 ) { if ( count0 == 0 ) document . write ( "No" ) ; else document . write ( "0" ) ; } else { count7 = count7 - count7 % 5 ; while ( count7 -- ) document . write ( 7 ) ; while ( count0 -- ) document . write ( 0 ) ; } }
function minimumStepReqArr ( arr , N ) { let cntStep = 0 ; N += 1 ; for ( let i = 31 ; i >= 0 ; i -- ) { if ( ( N & ( 1 << i ) ) != 0 ) { cntStep += 1 ; } } return cntStep ; }
function minOpsToEmptyString ( S , N ) { let one = 0 , zero = 0 ; let x0 = 0 , x1 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( S [ i ] == "0" ) { x0 ++ ; x1 = 0 ; } else { x1 ++ ; x0 = 0 ; } zero = Math . max ( x0 , zero ) ; one = Math . max ( x1 , one ) ; } document . write ( Math . max ( one , zero ) ) ; }
function findMaxValByRearrArr ( arr , N ) { arr . sort ( ) ; let res = 0 ; do { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += __gcd ( i + 1 , arr [ i ] ) ; } res = Math . max ( res , sum ) ; } while ( next_permutation ( arr ) ) ; return res ; }
function cntKnightsAttackPawn ( knights , pawn , M ) { let cntKnights = 0 ; for ( let i = 0 ; i < M ; i ++ ) { let X = Math . abs ( knights [ i ] [ 0 ] - pawn [ 0 ] ) ; let Y = Math . abs ( knights [ i ] [ 1 ] - pawn [ 1 ] ) ; if ( ( X == 1 && Y == 2 ) || ( X == 2 && Y == 1 ) ) { cntKnights ++ ; } } return cntKnights ; }
function findXOR ( n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } }
function findMinimumTime ( p , n , target ) { let um = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( um [ p [ i ] ] ) um [ p [ i ] ] ++ ; else um [ p [ i ] ] = 1 } let time = 0 ; let sum = 0 ; while ( sum < target ) { sum = 0 ; time ++ ; for ( let it in um ) { sum += um [ it ] * Math . floor ( time / it ) ; } } document . write ( time ) ; }
function isSequenceValid ( B , N ) { for ( let i = 0 ; i < N ; i ++ ) { if ( ( i + 1 ) % B [ i ] != 0 ) { document . write ( "No" ) ; return ; } } document . write ( "Yes" ) ; }
function Remove_one_element ( arr , n ) { let post_odd = 0 , post_even = 0 ; let curr_odd = 0 , curr_even = 0 ; let res = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 != 0 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; } for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; let X = curr_odd ^ post_even ; let Y = curr_even ^ post_odd ; if ( X == Y ) res ++ ; if ( i % 2 != 0 ) curr_odd ^= arr [ i ] ; else curr_even ^= arr [ i ] ; } document . write ( res ) ; }
function findLongestNonDecreasing ( A , N ) { let res = 0 ; let start = 0 ; let end = N - 1 ; let prev = - 1 ; while ( start <= end ) { if ( A [ start ] <= A [ end ] ) { if ( prev == - 1 ) { prev = A [ start ] ; res ++ ; start ++ ; } else { if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else { break ; } } } else { if ( prev == - 1 ) { prev = A [ end ] ; res ++ ; end -- ; } else { if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else { break ; } } } } return res ; }
function countPairs ( arr , N ) { var cntPairs = 0 ; var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) else mp . set ( arr [ i ] , 1 ) ; } mp . forEach ( ( value , key ) => { cntPairs += parseInt ( ( value * ( value - 1 ) ) / 2 ) ; } ) ; return cntPairs ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function minAbsDiff ( N ) { var sumSet1 = 0 ; var sumSet2 = 0 ; for ( i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return Math . abs ( sumSet1 - sumSet2 ) ; }
function countPairs ( arr , n ) { let oneCount = 0 ; let desiredPair = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) { oneCount ++ ; } if ( arr [ i ] == 0 ) { desiredPair += oneCount ; } } return desiredPair ; }
function TotalNumber ( N ) { var ans = ( power ( 10 , N ) - 2 * power ( 9 , N ) + power ( 8 , N ) + 2 * mod ) % mod ; return ans ; }
function minLength ( A , N ) { var elem = A [ 0 ] , count = 1 ; for ( var i = 1 ; i < N ; i ++ ) { if ( A [ i ] == elem ) { count ++ ; } else { break ; } } if ( count == N ) return N ; else return 1 ; }
function NegEqu ( N , X , Y ) { while ( X > 0 && ( N > N / 2 + 10 ) ) { N = N / 2 + 10 ; X -= 1 ; } while ( Y > 0 ) { N = N - 10 ; Y -= 1 ; } if ( N <= 0 ) return true ; return false ; }
function minSubarrays ( arr , n ) { var right = n - 1 ; var left = 0 ; var subarrays = 0 ; while ( right >= 0 ) { for ( left = 0 ; left <= right ; left += 1 ) { if ( __gcd ( arr [ left ] , arr [ right ] ) > 1 ) { subarrays += 1 ; right = left - 1 ; break ; } if ( left == right && __gcd ( arr [ left ] , arr [ right ] ) == 1 ) { return 0 ; } } } return subarrays ; }
function check ( arr , N ) { let f = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < N ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { count ++ ; } } if ( count >= 2 ) { f = 1 ; break ; } } if ( f == 1 ) return true ; else return false ; }
function no_of_flips ( n ) { let len = check_length ( n ) ; let ans = 0 ; let right = 1 ; let left = len ; while ( right < left ) { if ( check_ith_bit ( n , right ) != check_ith_bit ( n , left ) ) ans ++ ; left -- ; right ++ ; } return ans ; }
function find_max ( v , n ) { let count = 0 ; if ( n >= 2 ) count = 2 ; else count = 1 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( v [ i - 1 ] [ 0 ] < ( v [ i ] [ 0 ] - v [ i ] [ 1 ] ) ) count ++ ; else if ( v [ i + 1 ] [ 0 ] > ( v [ i ] [ 0 ] + v [ i ] [ 1 ] ) ) { count ++ ; v [ i ] [ 0 ] = v [ i ] [ 0 ] + v [ i ] [ 1 ] ; } else continue ; } return count ; }
function createString ( N ) { for ( let i = 0 ; i < N ; i ++ ) { document . write ( "a" ) ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( "b" ) ; } }
function maxSubsequences ( arr , n ) { let map = new Map ( ) ; let maxCount = 0 ; let count ; for ( let i = 0 ; i < n ; i ++ ) { if ( map . has ( arr [ i ] ) ) { count = map [ arr [ i ] ] ; if ( count > 1 ) { map . add ( arr [ i ] , count - 1 ) ; } else map . delete ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) if ( map . has ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . set ( arr [ i ] - 1 , 1 ) ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) if ( map . has ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . set ( arr [ i ] - 1 , 1 ) ; } } return maxCount ; }
function sumOfFactors ( N ) { var ans = 0 ; for ( i = 1 ; i <= N ; i ++ ) { var first = i ; var last = parseInt ( N / i ) * i ; var factors = parseInt ( ( last - first ) / i ) + 1 ; var totalContribution = parseInt ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += totalContribution ; } return ans ; }
function findShifts ( A , N ) { let shift = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( let i = 0 ; i < N ; i ++ ) document . write ( shift [ i ] + "▁" ) ; }
function possible ( N , a , b , n ) { let sum_of_angle = 180 * ( N - 2 ) ; let Total_angle = Math . floor ( ( N * ( ( 2 * a ) + ( N - 1 ) * b ) ) / 2 ) ; if ( sum_of_angle != Total_angle ) return false ; else return true ; }
function splitIntoFibonacciHelper ( pos , S , seq ) { if ( pos == S . length && ( seq . length >= 3 ) ) { return true ; } let num = 0 ; for ( let i = pos ; i < S . length ; i ++ ) { num = num * 10 + ( S [ i ] - "0" ) ; if ( num > Number . MAX_VALUE ) break ; if ( S [ pos ] == "0" && i > pos ) break ; if ( seq . length > 2 && ( num > ( seq [ seq . length - 1 ] + seq [ seq . length - 2 ] ) ) ) break ; if ( seq . length < 2 || ( num == ( seq [ seq . length - 1 ] + seq [ seq . length - 2 ] ) ) ) { seq . push ( num ) ; if ( splitIntoFibonacciHelper ( i + 1 , S , seq ) ) return true ; seq . pop ( ) ; } } return false ; }
function good_pairs ( str , N ) { let arr = new Array ( 32 ) ; arr . fill ( 0 ) ; let strCount = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let Weight = 0 ; for ( let j = 0 ; j < str [ i ] . length ; j ++ ) { switch ( str [ i ] [ j ] ) { case "a" : Weight = Weight | 1 ; break ; case "e" : Weight = Weight | 2 ; break ; case "i" : Weight = Weight | 4 ; break ; case "o" : Weight = Weight | 8 ; break ; case "u" : Weight = Weight | 16 ; break ; } } arr [ Weight ] ++ ; } for ( let i = 0 ; i < 32 ; i ++ ) { for ( let j = i + 1 ; j < 32 ; j ++ ) { if ( ( i j ) == 31 ) strCount += arr [ i ] * arr [ j ] ; } } strCount += parseInt ( ( arr [ 31 ] * ( arr [ 31 ] - 1 ) ) / 2 , 10 ) ; return strCount ; }
function countUniqueDigits ( N ) { let res = 0 ; let cnt = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; while ( N > 0 ) { let rem = N % 10 ; cnt [ rem ] ++ ; N = Math . floor ( N / 10 ) ; } for ( let i = 0 ; i < 10 ; i ++ ) { if ( cnt [ i ] == 1 ) { res ++ ; } } return res ; }
function DFS ( node , parent ) { answer [ node ] = val [ node ] ; v [ node ] . forEach ( child => { if ( child != parent ) { DFS ( child , node ) ; answer [ node ] = gcd ( answer [ node ] , answer [ child ] ) ; } } ) ; }
function count_triangles ( a , b , c , d ) { var ans = 0 ; for ( x = a ; x <= b ; ++ x ) { var num_greater_than_d = Math . max ( d , c + x ) - Math . max ( d , b + x - 1 ) ; ans += num_greater_than_d * ( d - c + 1 ) ; var r = Math . min ( Math . max ( c , c + x ) , d ) - c ; var l = Math . min ( Math . max ( c , b + x - 1 ) , d ) - c ; var x1 = ( r * ( r + 1 ) ) / 2 ; var x2 = ( l * ( l + 1 ) ) / 2 ; ans += x1 - x2 ; } return ans ; }
function maxRemainingSum ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; var i = 0 ; var j = n - 1 ; var result = 0 ; while ( i < j ) { if ( arr [ i ] < arr [ j ] ) { sum -= arr [ i ] ; i ++ ; } else { sum -= arr [ j ] ; j -- ; } result += sum ; } return result ; }
function check ( arr , n ) { var flag = true ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < n - i ) { flag = false ; } } if ( flag ) { return true ; } else { return false ; } }
function minOperations ( a , b , n ) { var minA = Math . max . apply ( Math , a ) ; ; for ( x = minA ; x >= 0 ; x -- ) { var check = true ; var operations = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = false ; break ; } } if ( check ) return operations ; } return - 1 ; }
function largestNum ( n ) { let num = 0 ; for ( let i = 0 ; i <= 32 ; i ++ ) { let x = ( 1 << i ) ; if ( ( x - 1 ) <= n ) num = ( 1 << i ) - 1 ; else break ; } return num ; }
function digit_xor ( x ) { let xorr = 0 ; while ( x ) { xorr ^= x % 10 ; x = x / 10 ; } return xorr ; }
function maxSum ( a , n ) { var S = 0 ; var i ; for ( i = 0 ; i < n ; i ++ ) S += a [ i ] ; var X = maxSubArraySum ( a , n ) ; return 2 * X - S ; }
function Transform ( n , d , steps ) { if ( n < min_val ) { min_val = n ; min_steps = steps ; } else if ( n == min_val ) { min_steps = Math . min ( min_steps , steps ) ; } if ( steps < 15 ) { Transform ( sumOfDigits ( n ) , d , steps + 1 ) ; Transform ( n + d , d , steps + 1 ) ; } }
function addEdge ( adj , u , v ) { adj [ u ] . push ( v ) ; adj [ v ] . push ( u ) ; }
function minCost ( cost , n ) { var totalCost = 0 ; var boardingBus = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; }
function findK ( n , k ) { let pos ; if ( n % 2 == 0 ) { pos = parseInt ( n / 2 , 10 ) ; } else { pos = parseInt ( n / 2 , 10 ) + 1 ; } if ( k <= pos ) { return ( k * 2 - 1 ) ; } else { return ( ( k - pos ) * 2 ) ; } }
function max_bitwise_or ( L , R ) { let v1 = [ ] , v2 = [ ] , v3 = [ ] ; let z = 0 , i , ans = 0 , cnt = 1 ; while ( L > 0 ) { v1 . push ( L % 2 ) ; L = parseInt ( L / 2 ) ; } while ( R > 0 ) { v2 . push ( R % 2 ) ; R = parseInt ( R / 2 ) ; } while ( v1 . length != v2 . length ) { v1 . push ( 0 ) ; } for ( i = v2 . length - 1 ; i >= 0 ; i -- ) { if ( v2 [ i ] == 1 && v1 [ i ] == 0 && z == 0 ) { z = 1 ; continue ; } if ( z == 1 ) { v1 [ i ] = 1 ; } } for ( i = 0 ; i < v2 . length ; i ++ ) { v3 . push ( v2 [ i ] v1 [ i ] ) ; } for ( i = 0 ; i < v2 . length ; i ++ ) { if ( v3 [ i ] == 1 ) { ans += cnt ; } cnt *= 2 ; } return ans ; }
function ncr ( n , r , mod ) { var res = 1 ; for ( var i = 1 ; i <= r ; i += 1 ) { res = ( res * ( n - i + 1 ) ) % mod ; var inv = power ( i , mod - 2 , mod ) ; res = ( res * inv ) % mod ; } return parseInt ( res % mod ) ; }
function solve ( array , N ) { let pos = new Array ( 5 ) ; for ( let i = 0 ; i < 5 ; i ++ ) { pos [ i ] = new Array ( 10000 ) ; for ( let j = 0 ; j < 10000 ; j ++ ) { pos [ i ] [ j ] = 0 ; } } let pref = new Array ( 5 ) ; for ( let i = 0 ; i < 5 ; i ++ ) { pref [ i ] = 0 ; } if ( array [ 0 ] == 0 ) { pref [ 0 ] = 1 ; pos [ 0 ] [ pos [ 0 ] . length - 1 ] = 0 ; } let ans = MAX_INT ; for ( let i = 1 ; i < N ; i ++ ) { if ( array [ i ] == 0 ) { pref [ 0 ] ++ ; pos [ 0 ] [ pos [ 0 ] . length - 1 ] = i ; } else { if ( pref [ array [ i ] - 1 ] > 0 ) { pref [ array [ i ] ] ++ ; pos [ array [ i ] ] [ pos [ array [ i ] ] . length - 1 ] = i ; if ( array [ i ] == 4 ) { let end = i ; let start = i ; for ( let j = 3 ; j >= 0 ; j -- ) { let s = 0 ; let e = pos [ j ] . length - 1 ; let temp = - 1 ; while ( s <= e ) { let m = Math . floor ( ( s + e ) / 2 ) ; if ( pos [ j ] [ m ] <= start ) { temp = pos [ j ] [ m ] ; s = m + 1 ; } else e = m - 1 ; } start = temp ; } ans = Math . min ( ans , end - start + 1 ) ; } } } } return ans ; }
function solve ( X , A ) { let min = Number . MAX_VALUE ; let ind = - 1 ; for ( let i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] < min ) { min = A [ i ] ; ind = i ; } } let maxIndChosen = Math . floor ( X / min ) ; let ans = [ ] ; if ( maxIndChosen == 0 ) { return ans ; } for ( let i = 0 ; i < maxIndChosen ; i ++ ) { ans . push ( ind ) ; } let temp = maxIndChosen ; let sum = maxIndChosen * A [ ind ] ; for ( let i = 0 ; i < ind ; i ++ ) { if ( sum - X == 0 temp == 0 ) break ; while ( ( sum - A [ ind ] + A [ i ] ) <= X && temp != 0 ) { ans . shift ( ) ; ans . push ( i ) ; temp -- ; sum += ( A [ i ] - A [ ind ] ) ; } } ans . sort ( function ( a , b ) { return a - b ; } ) ; return ans ; }
function CheckForSequence ( arr , n , k ) { for ( var i = n - 1 ; i >= 0 ; i -- ) { if ( k >= arr [ i ] ) k -= arr [ i ] ; } if ( k != 0 ) return false ; else return true ; }
function reverse ( n ) { let rev = 0 ; while ( n != 0 ) { rev = ( rev * 10 ) + ( n % 10 ) ; n = Math . floor ( n / 10 ) ; } return rev ; }
function countJumps ( n ) { n = Math . abs ( n ) ; let ans = 0 ; while ( getsum ( ans ) < n || ( ( getsum ( ans ) - n ) & 1 ) > 0 ) ans ++ ; return ans ; }
function steps ( cur , x , n ) { if ( x == 0 ) return Number . MAX_VALUE ; if ( x > 0 ) return Math . abs ( ( n - cur ) / x ) ; else return Math . abs ( ( cur - 1 ) / x ) ; }
function find_rectangle ( area ) { let l = 0 , b = 0 ; let M = Math . floor ( Math . sqrt ( area ) ) , ans ; for ( let i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = Math . floor ( area / i ) ; b = i ; break ; } } document . write ( "l▁=▁" + l + ",▁b▁=▁" + b ) ; }
function countMinSwaps ( st ) { let min_swaps = 0 ; let odd_0 = 0 , even_0 = 0 ; let odd_1 = 0 , even_1 = 0 ; let n = st . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( st [ i ] == "1" ) { even_1 ++ ; } else { even_0 ++ ; } } else { if ( st [ i ] == "1" ) { odd_1 ++ ; } else { odd_0 ++ ; } } } let cnt_swaps_1 = Math . min ( even_0 , odd_1 ) ; let cnt_swaps_2 = Math . min ( even_1 , odd_0 ) ; return Math . min ( cnt_swaps_1 , cnt_swaps_2 ) ; }
function problemsLeft ( K , P , N ) { if ( K <= P ) return 0 ; else return ( K - P ) * N ; }
function isCorrectOrder ( n ) { let flag = true ; let prev = - 1 ; let type = - 1 ; while ( n != 0 ) { if ( type === - 1 ) { if ( prev === - 1 ) { prev = n % 10 ; n = Math . floor ( n / 10 ) ; continue ; } if ( prev == n % 10 ) { flag = false ; break ; } if ( prev > n % 10 ) { type = 1 ; prev = n % 10 ; n = Math . floor ( n / 10 ) ; continue ; } prev = n % 10 ; n = Math . floor ( n / 10 ) ; } else { if ( prev == n % 10 ) { flag = false ; break ; } if ( prev < n % 10 ) { flag = false ; break ; } prev = n % 10 ; n = Math . floor ( n / 10 ) ; } } return flag ; }
function maxDifference ( arr , N , k ) { let M , S = 0 , S1 = 0 , max_difference = 0 ; for ( let i = 0 ; i < N ; i ++ ) S += arr [ i ] ; let temp ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . max ( k , N - k ) ; for ( let i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
function MinimumRemovals ( a , N , K ) { let b = new Array ( N + 1 ) ; for ( let i = 0 ; i < N ; i ++ ) { b [ i + 1 ] = a [ i ] ; } let dp = new Array ( N + 1 ) . fill ( 0 ) . map ( ( ) => new Array ( N + 1 ) . fill ( 0 ) ) ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j <= i ; j ++ ) { dp [ i + 1 ] [ j ] = Math . max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] ) ; dp [ i + 1 ] [ j + 1 ] = Math . max ( dp [ i + 1 ] [ j + 1 ] , dp [ i ] [ j ] + ( ( b [ i + 1 ] == j + 1 ) ? 1 : 0 ) ) ; } } for ( let j = N ; j >= 0 ; j -- ) { if ( dp [ N ] [ j ] >= K ) { return ( N - j ) ; } } return - 1 ; }
function countOfNumbers ( digit , mask , repeated , n ) { if ( digit == n + 1 ) { if ( repeated == true ) { return 1 ; } return 0 ; } if ( repeated == true ) { return Math . pow ( 10 , n - digit + 1 ) ; } let val = dp [ digit ] [ mask ] [ repeated ] ; if ( val != - 1 ) { return val ; } val = 0 ; if ( digit == 1 ) { for ( let i = ( n == 1 ? 0 : 1 ) ; i <= 9 ; ++ i ) { if ( mask & ( 1 << i ) ) { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 1 , n ) ; } else { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 0 , n ) ; } } } else { for ( let i = 0 ; i <= 9 ; ++ i ) { if ( mask & ( 1 << i ) ) { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 1 , n ) ; } else { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 0 , n ) ; } } } return val ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
function maxBoundary ( N , V ) { let dp = new Array ( N ) . fill ( 0 ) . map ( ( ) => new Array ( 2 ) . fill ( 0 ) ) ; dp [ 0 ] [ 0 ] = V [ 0 ] [ 0 ] ; dp [ 0 ] [ 1 ] = V [ 0 ] [ 1 ] ; for ( let i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = V [ i ] [ 0 ] ; let height1 = Math . abs ( V [ i - 1 ] [ 1 ] - V [ i ] [ 1 ] ) ; let height2 = Math . abs ( V [ i - 1 ] [ 0 ] - V [ i ] [ 1 ] ) ; dp [ i ] [ 0 ] += Math . max ( height1 + dp [ i - 1 ] [ 0 ] , height2 + dp [ i - 1 ] [ 1 ] ) ; dp [ i ] [ 1 ] = V [ i ] [ 1 ] ; let vertical1 = Math . abs ( V [ i ] [ 0 ] - V [ i - 1 ] [ 1 ] ) ; let vertical2 = Math . abs ( V [ i ] [ 0 ] - V [ i - 1 ] [ 0 ] ) ; dp [ i ] [ 1 ] += Math . max ( vertical1 + dp [ i - 1 ] [ 0 ] , vertical2 + dp [ i - 1 ] [ 1 ] ) ; } document . write ( Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ) ; }
function findMinOperations ( n ) { let i = 0 ; let dp = new Array ( n + 1 ) ; for ( i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = 999999 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i < n + 1 ; i ++ ) { if ( i * 5 <= n ) { dp [ i * 5 ] = Math . min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= n ) { dp [ i + 3 ] = Math . min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } return dp [ n ] ; }
function solve ( A , N , K ) { let sum = 0 ; let c = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( A [ i ] == 0 ) c ++ ; } if ( K > sum || ( sum + K ) % 2 ) return 0 ; sum = ( sum + K ) / 2 ; let dp = new Array ( N + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( sum + 1 ) ; } for ( let i = 0 ; i <= sum ; i ++ ) dp [ 0 ] [ i ] = 0 ; for ( let i = 0 ; i <= N ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 1 ; j <= sum ; j ++ ) { if ( A [ i - 1 ] <= j && A [ i - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - A [ i - 1 ] ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ N ] [ sum ] + Math . pow ( 2 , c ) ; }
function countSortedArrays ( start , m , size , n ) { if ( size === m ) return 1 ; if ( start > n ) return 0 ; var notTaken = 0 , taken = 0 ; taken = countSortedArrays ( start , m , size + 1 , n ) ; notTaken = countSortedArrays ( start + 1 , m , size , n ) ; return taken + notTaken ; }
function getValue ( arr , N ) { let dp = Array . from ( { length : N } , ( _ , i ) => 0 ) ; dp [ 0 ] = 0 ; for ( let i = 1 ; i < N ; i ++ ) { let min = arr [ i ] ; let max = arr [ i ] ; for ( let j = i ; j >= 0 ; j -- ) { min = Math . min ( arr [ j ] , min ) ; max = Math . max ( arr [ j ] , max ) ; dp [ i ] = Math . max ( dp [ i ] , max - min + ( ( j >= 1 ) ? dp [ j - 1 ] : 0 ) ) ; } } return dp [ N - 1 ] ; }
function maxScore ( s , a ) { if ( dp . has ( s ) ) return dp . get ( s ) ; let n = s . length ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; let head = 0 ; let mx = - 1 ; while ( head < n ) { let tail = head ; while ( tail < n ) { if ( s [ tail ] != s [ head ] ) { head = tail ; break ; } let sub = s . substring ( head , head + tail + 1 ) ; mx = Math . max ( mx , a [ sub . length - 1 ] + maxScore ( s . substring ( 0 , head ) + s . substring ( tail + 1 , tail + 1 + s . length ) , a ) ) ; tail += 1 ; } if ( tail == n ) break ; } dp . set ( s , mx ) ; return mx ; }
function minSumDifference ( arr , n , k1 , k2 , sum1 , sum2 ) { if ( n < 0 ) { if ( k1 == 0 && k2 == 0 ) { return Math . abs ( sum1 - sum2 ) ; } else { return Number . MAX_VALUE ; } } if ( dp [ n ] [ sum1 ] [ sum2 ] != - 1 ) { return dp [ n ] [ sum1 ] [ sum2 ] ; } let op1 = Number . MAX_VALUE ; let op2 = Number . MAX_VALUE ; let op3 = Number . MAX_VALUE ; if ( k1 > 0 ) { op1 = minSumDifference ( arr , n - 1 , k1 - 1 , k2 , sum1 + arr [ n ] , sum2 ) ; } if ( k2 > 0 ) { op2 = minSumDifference ( arr , n - 1 , k1 , k2 - 1 , sum1 , sum2 + arr [ n ] ) ; } op3 = minSumDifference ( arr , n - 1 , k1 , k2 , sum1 , sum2 ) ; dp [ n ] [ sum1 ] [ sum2 ] = Math . min ( op1 , Math . min ( op2 , op3 ) ) ; return dp [ n ] [ sum1 ] [ sum2 ] ; }
function insertVector ( mask ) { for ( let i = 0 ; i < 20 ; i ++ ) { if ( ( mask & 1 << i ) == 0 ) continue ; if ( dp [ i ] == 0 ) { dp [ i ] = mask ; ++ ans ; return ; } mask ^= dp [ i ] ; } }
function cntNumRange ( L , R , K ) { let cnt = 0 ; for ( let i = L ; i <= R ; i ++ ) { if ( prodOfDigit ( i ) == K ) { cnt ++ ; } } return cnt ; }
function findSubtreeORUtil ( N , Edges , Val , Queries , Q ) { addEdgesToGraph ( Edges , N ) ; findSubtreeOR ( Queries , Q , Val ) ; }
function findMinimum ( arr , N , pos , turn ) { let x = [ pos , turn ] ; if ( m . has ( x ) ) { return m [ x ] ; } if ( pos >= N - 1 ) { return 0 ; } if ( turn == 0 ) { let ans = Math . min ( findMinimum ( arr , N , pos + 1 , 1 ) + arr [ pos ] , findMinimum ( arr , N , pos + 2 , 1 ) + arr [ pos ] + arr [ pos + 1 ] ) ; let v = [ pos , turn ] ; m [ v ] = ans ; return ans ; } if ( turn != 0 ) { let ans = Math . min ( findMinimum ( arr , N , pos + 1 , 0 ) , findMinimum ( arr , N , pos + 2 , 0 ) ) ; let v = [ pos , turn ] ; m [ v ] = ans ; return ans ; } return 0 ; }
function countVowelStrings ( n ) { return countstrings ( n , 0 ) ; }
function maxSum ( arr , n , m ) { let dp = new Array ( n ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < 2 ; i ++ ) { for ( let j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ m - 1 ] = arr [ 0 ] [ m - 1 ] ; dp [ 1 ] [ m - 1 ] = arr [ 1 ] [ m - 1 ] ; for ( let j = m - 2 ; j >= 0 ; j -- ) { for ( let i = 0 ; i < 2 ; i ++ ) { if ( i == 1 ) { dp [ i ] [ j ] = Math . max ( arr [ i ] [ j ] + dp [ 0 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 0 ] [ j + 2 ] ) ; } else { dp [ i ] [ j ] = Math . max ( arr [ i ] [ j ] + dp [ 1 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 1 ] [ j + 2 ] ) ; } } } document . write ( Math . max ( dp [ 0 ] [ 0 ] , dp [ 1 ] [ 0 ] ) ) ; }
function findMaxGCD ( arr , N ) { var high = 0 ; for ( i = 0 ; i < N ; i ++ ) { high = Math . max ( high , arr [ i ] ) ; } var count = Array ( high + 1 ) . fill ( 0 ) ; for ( i = 0 ; i < N ; i ++ ) { count [ arr [ i ] ] += 1 ; } var counter = 0 ; for ( i = high ; i > 0 ; i -- ) { var j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } return 0 ; }
function findLCS ( nums , N ) { var k = 0 ; for ( i = 0 ; i < N ; i ++ ) { var pos = LowerBound ( nums , k , nums [ i ] ) ; nums [ pos ] = nums [ i ] ; if ( k == pos ) { k = pos + 1 ; } } return k ; }
function check ( mask , i ) { var c = ( mask & ( 1 << i ) ) ; return c != 0 ; }
function minSteps ( m , n ) { if ( n == m ) return 0 ; if ( m > n ) return inf ; let min_cost = inf ; for ( let i = 2 ; i < m ; i += 2 ) { if ( m % i == 0 ) { min_cost = Math . min ( min_cost , m / i + minSteps ( m + i , n ) ) ; } } return min_cost ; }
function checkEqualSum ( arr , N ) { let sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function queries_fxn ( matrix , queries ) { for ( let q of queries ) manipulation ( matrix , q ) ; }
function countNums ( N ) { var dp = Array ( N ) ; for ( var i = 0 ; i < N ; i ++ ) dp [ i ] = Array ( 16 ) . fill ( 0 ) ; for ( i = 1 ; i <= 9 ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( i = 1 ; i < N ; i ++ ) { for ( j = 0 ; j < 10 ; j ++ ) { for ( k = 0 ; k < 16 ; k ++ ) { var xor = j ^ k ; dp [ i ] [ xor ] += dp [ i - 1 ] [ k ] ; } } } var count = 0 ; for ( i = 0 ; i < 10 ; i ++ ) count += dp [ N - 1 ] [ i ] ; document . write ( count ) ; }
function constructSTUtil ( arr , ss , se , st , si ) { if ( ss == se ) { if ( prime [ arr [ ss ] ] != 0 ) st [ si ] = arr [ ss ] ; else st [ si ] = 0 ; return st [ si ] ; } let mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ; return st [ si ] ; }
function dfs ( a , par ) { let leaf = 1 ; for ( let i = 0 ; i < v [ a ] . length ; i ++ ) { if ( v [ a ] [ i ] . first == par ) continue ; leaf = 0 ; dfs ( v [ a ] [ i ] . first , a ) ; } if ( leaf == 1 ) { leaves [ a ] += 1 ; } else { for ( let i = 0 ; i < v [ a ] . length ; i ++ ) { if ( v [ a ] [ i ] . first == par ) continue ; leaves [ a ] += leaves [ v [ a ] [ i ] . first ] ; dp [ a ] = dp [ a ] + dp [ v [ a ] [ i ] . first ] + leaves [ v [ a ] [ i ] . first ] * v [ a ] [ i ] . second ; } } }
function getCount ( n , k ) { if ( n == 1 ) return 10 ; var dp = Array ( 11 ) . fill ( 0 ) ; var next = Array ( 11 ) . fill ( 0 ) ; for ( var i = 1 ; i <= 9 ; i ++ ) dp [ i ] = 1 ; for ( var i = 2 ; i <= n ; i ++ ) { for ( var j = 0 ; j <= 9 ; j ++ ) { var l = Math . max ( 0 , ( j - k ) ) ; var r = Math . min ( 9 , ( j + k ) ) ; next [ l ] += dp [ j ] ; next [ r + 1 ] -= dp [ j ] ; } for ( var j = 1 ; j <= 9 ; j ++ ) next [ j ] += next [ j - 1 ] ; for ( var j = 0 ; j < 10 ; j ++ ) { dp [ j ] = next [ j ] ; next [ j ] = 0 ; } } var count = 0 ; for ( var i = 0 ; i <= 9 ; i ++ ) count += dp [ i ] ; return count ; }
function nCrModp ( n , r ) { if ( n % 2 == 1 ) { return - 1 ; } var C = Array ( r + 1 ) . fill ( 0 ) ; C [ 0 ] = 1 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = Math . min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % MOD ; } return C [ r ] ; }
function findResult ( arr , n , q , m ) { for ( var i = 0 ; i < m ; i ++ ) { document . write ( findResultUtil ( arr , q [ i ] [ 0 ] , q [ i ] [ 1 ] ) + "▁" ) ; } }
function insert ( idx , s , root ) { let temp = root ; for ( let i = idx ; i < s . length ; i ++ ) { if ( temp . child [ s [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] == null ) temp . child [ s [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] = new TrieNode ( ) ; temp = temp . child [ s [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ; } }
function minCuts ( S1 , S2 ) { let n1 = S1 . length ; let n2 = S2 . length ; let root = new TrieNode ( ) ; for ( let i = 0 ; i < n2 ; i ++ ) { insert ( i , S2 , root ) ; } let dp = new Array ( n1 + 1 ) ; dp . fill ( INF ) ; dp [ 0 ] = 0 ; for ( let i = 0 ; i < n1 ; i ++ ) { let temp = root ; for ( let j = i + 1 ; j <= n1 ; j ++ ) { if ( temp . child [ S1 [ j - 1 ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] == null ) break ; dp [ j ] = Math . min ( dp [ j ] , dp [ i ] + 1 ) ; temp = temp . child [ S1 [ j - 1 ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ; } } if ( dp [ n1 ] >= INF ) return - 1 ; else return dp [ n1 ] ; }
function maximum ( A , B , C , D ) { return Math . max ( Math . max ( A , B ) , Math . max ( C , D ) ) ; }
function maxSubarraySum ( graph , vertices , values ) { let visited = new Array ( 1001 ) ; visited . fill ( false ) ; let maxSum = - 1000000 ; for ( let i = 1 ; i <= vertices ; i ++ ) { if ( visited [ i ] == false ) { let sizeChain ; let tempSum ; let storeChain = [ ] ; depthFirst ( i , graph , visited , storeChain ) ; sizeChain = storeChain . length ; let chainValues = new Array ( sizeChain + 1 ) ; for ( let j = 0 ; j < sizeChain ; j ++ ) { let temp = values [ storeChain [ j ] - 1 ] ; chainValues [ j ] = temp ; } tempSum = subarraySum ( chainValues , sizeChain ) ; if ( tempSum > maxSum ) { maxSum = tempSum ; } } } document . write ( "Maximum▁subarray▁sum▁among▁all▁" ) ; document . write ( "connected▁components▁=▁" ) ; document . write ( maxSum ) ; }
function countDecodingDP ( digits , n ) { if ( digits [ 0 ] == "0" ) return 0 ; var count0 = 1 , count1 = 1 , count2 ; for ( var i = 2 ; i <= n ; i ++ ) { count2 = ( ( digits [ i - 1 ] != "0" ) * count1 ) + ( ( digits [ i - 2 ] == "1" ) || ( digits [ i - 2 ] == "2" && digits [ i - 1 ] < "7" ) ) * count0 ; count0 = count1 ; count1 = count2 ; } return count1 ; }
function countSubMatrix ( mtrx , k , p ) { var dp = Array . from ( Array ( dim ) , ( ) => Array ( dim ) ) ; for ( var i = 0 ; i < dim ; i ++ ) { for ( var j = 0 ; j < dim ; j ++ ) { dp [ i ] [ j ] = 0 ; } } createTable ( mtrx , k , p , dp ) ; return countSubMatrixUtil ( dp , k , p ) ; }
function f ( n , k ) { if ( n < k ) return 0 ; if ( n == k ) return 1 ; if ( k == 1 ) return 1 ; if ( dp [ n ] [ k ] != - 1 ) return dp [ n ] [ k ] ; return dp [ n ] [ k ] = ( ( k * f ( n - 1 , k ) ) % mod + ( f ( n - 1 , k - 1 ) ) % mod ) % mod ; }
function checkPrime ( number ) { let num = String ( number ) ; for ( let i = 2 ; i * i <= num ; i ++ ) if ( ( num % i ) == 0 ) return false ; return true ; }
function countNumbers ( n , k ) { var st = 1 ; for ( var i = 0 ; i <= n ; i ++ ) { powers [ i ] = st ; st *= 10 ; st %= mod ; } st = 1 ; for ( var i = 0 ; i <= n ; i ++ ) { powersModk [ i ] = st ; st *= 10 ; st %= mod ; } return calculate ( 0 , 0 , 0 , k , n ) ; }
function maxSum ( p0 , p1 , a , pos , n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } var ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = Math . max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = Math . max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; }
function maxSum ( a , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += a [ i ] ; var limit = 2 * sum + 1 ; var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( limit ) ) ; for ( var i = 0 ; i < n + 1 ; i ++ ) { for ( var j = 0 ; j < limit ; j ++ ) dp [ i ] [ j ] = - 1000000000 ; } dp [ 0 ] [ sum ] = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 0 ; j < limit ; j ++ ) { if ( ( j - a [ i - 1 ] ) >= 0 && dp [ i - 1 ] [ j - a [ i - 1 ] ] != - 1000000000 ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ; if ( ( j + a [ i - 1 ] ) < limit && dp [ i - 1 ] [ j + a [ i - 1 ] ] != - 1000000000 ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ; if ( dp [ i - 1 ] [ j ] != - 1000000000 ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ sum ] ; }
function minSteps ( str , n , k ) { if ( str [ n - 1 ] == "0" ) return - 1 ; if ( n == 1 ) return 0 ; if ( n < 4 ) return 1 ; var dp = Array ( n ) ; dp [ n - 1 ] = 0 ; dp [ n - 2 ] = 1 ; dp [ n - 3 ] = 1 ; for ( var i = n - 4 ; i >= 0 ; i -- ) { if ( str [ i ] == "0" ) continue ; var steps = 1000000000 ; if ( i + k < n && str [ i + k ] == "1" ) steps = Math . min ( steps , dp [ i + k ] ) ; if ( str [ i + 1 ] == "1" ) steps = Math . min ( steps , dp [ i + 1 ] ) ; if ( str [ i + 2 ] == "1" ) steps = Math . min ( steps , dp [ i + 2 ] ) ; dp [ i ] = ( steps == 1000000000 ) ? steps : 1 + steps ; } if ( dp [ 0 ] == 1000000000 ) return - 1 ; return dp [ 0 ] ; }
function eggDrop ( n , k ) { let dp = new Array ( ) ; for ( let i = 0 ; i < k + 1 ; i ++ ) { dp . push ( new Array ( n + 1 ) . fill ( 0 ) ) } let x = 0 ; while ( dp [ x ] [ n ] < k ) { x ++ ; for ( let i = 1 ; i <= n ; i ++ ) dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; } return x ; }
function findMax ( a , n ) { var dp = Array ( n ) . fill ( ) . map ( ( ) => Array ( 2 ) . fill ( 0 ) ) ; var i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) dp [ i ] [ j ] = 0 ; dp [ 0 ] [ 0 ] = a [ 0 ] + a [ 1 ] ; dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 1 ] ; for ( i = 1 ; i <= n - 2 ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i + 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] ; } document . write ( Math . max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] ) ) ; }
function expectedSteps ( x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] ) return dp [ x ] ; v [ x ] = 1 ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; }
function findCnt ( arr , i , curr , n , m ) { if ( i == n ) { if ( curr == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; return dp [ i ] [ curr ] ; }
function ways ( arr , n ) { let dp = new Array ( n + 1 ) ; dp . fill ( 0 ) ; dp [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( let j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; }
function Probability ( p , n ) { var dp = Array ( n + 1 ) . fill ( 0 ) . map ( x => Array ( n + 1 ) . fill ( 0 ) ) ; dp [ 0 ] [ 0 ] = 1.0 ; for ( var i = 1 ; i <= n ; i += 1 ) { for ( var j = 0 ; j <= i ; j += 1 ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 ] [ j - 1 ] * p [ i ] ; } } var ans = 0.0 ; for ( var i = parseInt ( ( n + 1 ) / 2 ) ; i <= n ; i += 1 ) ans += dp [ n ] [ i ] ; return ans ; }
function count_required_sequence ( n , arr ) { var total_required_subsequence = 0 ; var total_n_required_subsequence = 0 ; var dp = Array . from ( Array ( N ) , ( ) => Array ( 2 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var turn_required = 0 ; for ( var j = - 1 ; j <= 1 ; j ++ ) turn_required += dp [ arr [ i ] + j ] [ 0 ] ; var required_end_i = ( total_required_subsequence + turn_required ) ; var n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) ; total_required_subsequence += required_end_i ; total_n_required_subsequence += n_required_end_i ; dp [ arr [ i ] ] [ 1 ] += required_end_i ; dp [ arr [ i ] ] [ 0 ] += n_required_end_i ; } return total_required_subsequence ; }
function recur ( u , array , n ) { if ( u == 0 ) return 0 ; if ( dp [ u ] != - 1 ) return dp [ u ] ; for ( let i = 0 ; i < n ; i ++ ) { let mask = get_binary ( array [ i ] ) ; if ( ( mask u ) == u ) { dp [ u ] = Math . max ( Math . max ( 0 , dp [ u ^ mask ] ) + array [ i ] , dp [ u ] ) ; } } return dp [ u ] ; }
function solve ( array , n ) { for ( let i = 0 ; i < ( 1 << 10 ) ; i ++ ) { dp [ i ] = - 1 ; } let ans = 0 ; for ( let i = 0 ; i < ( 1 << 10 ) ; i ++ ) { ans = Math . max ( ans , recur ( i , array , n ) ) ; } return ans ; }
function MinDiff ( i , sum , arr , n ) { if ( i == n ) return 0 ; if ( visit [ i ] [ sum + MAX ] > 0 ) return dp [ i ] [ sum + MAX ] ; visit [ i ] [ sum + MAX ] = 1 ; dp [ i ] [ sum + MAX ] = RetClose ( arr [ i ] + MinDiff ( i + 1 , sum + arr [ i ] , arr , n ) , MinDiff ( i + 1 , sum , arr , n ) , - 1 * sum ) ; return dp [ i ] [ sum + MAX ] ; }
function minSteps ( arr , i , mask , n ) { if ( i == n - 1 ) { return 0 ; } if ( i > n - 1 i < 0 ) { return 9999999 ; } if ( ( mask >> i ) % 2 == 1 ) { return 9999999 ; } if ( v [ i ] [ mask ] ) { return dp [ i ] [ mask ] ; } v [ i ] [ mask ] = true ; dp [ i ] [ mask ] = 1 + Math . min ( minSteps ( arr , i - arr [ i ] , ( mask | ( 1 << i ) ) , n ) , minSteps ( arr , i + arr [ i ] , ( mask | ( 1 << i ) ) , n ) ) ; return dp [ i ] [ mask ] ; }
function maxSumPath ( i1 , j1 , i2 ) { let j2 = i1 + j1 - i2 ; if ( i1 >= n i2 >= n j1 >= m j2 >= m ) { return 0 ; } if ( cache [ i1 ] [ j1 ] [ i2 ] != - 1 ) { return cache [ i1 ] [ j1 ] [ i2 ] ; } let ans = Number . MIN_VALUE ; ans = Math . max ( ans , maxSumPath ( i1 + 1 , j1 , i2 + 1 ) + sum ( i1 , j1 , i2 , j2 ) ) ; ans = Math . max ( ans , maxSumPath ( i1 , j1 + 1 , i2 ) + sum ( i1 , j1 , i2 , j2 ) ) ; ans = Math . max ( ans , maxSumPath ( i1 , j1 + 1 , i2 + 1 ) + sum ( i1 , j1 , i2 , j2 ) ) ; ans = Math . max ( ans , maxSumPath ( i1 + 1 , j1 , i2 ) + sum ( i1 , j1 , i2 , j2 ) ) ; cache [ i1 ] [ j1 ] [ i2 ] = ans ; return ans ; }
function pre_process ( dp , s ) { var n = s . length ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = false ; } } for ( j = 1 ; j <= n ; j ++ ) { for ( i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = true ; } } else if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] ; } } } }
function maxSum ( a , n ) { let ans = 0 ; let arr = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; ++ i ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; ++ j ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = Math . max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i ] [ 2 ] = Math . max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = Math . max ( ans , dp [ i ] [ 0 ] ) ; ans = Math . max ( ans , dp [ i ] [ 1 ] ) ; ans = Math . max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; }
function sumEvenFactors ( L , R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; }
function numberOfWays ( x , y , z ) { binomialCoeff ( Math . max ( x , Math . max ( y , z ) ) ) ; var sum = 0 ; for ( i = 1 ; i <= z ; i ++ ) { sum = ( sum + C [ z ] [ i ] ) ; } var sum1 = 0 ; for ( i = 1 ; i <= y ; i ++ ) { for ( j = i + 1 ; j <= x ; j ++ ) { sum1 = ( sum1 + ( C [ y ] [ i ] * C [ x ] [ j ] ) ) ; } } sum1 = ( sum * sum1 ) ; return sum1 ; }
function findMaxSubarraySum ( a , n , k ) { for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( k ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } let ans = ( - 1e9 ) ; for ( let i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ; if ( ans == 0 && k == 0 ) { let max = Number . MIN_VALUE ; for ( let i = 0 ; i < a . length ; i ++ ) { max = Math . max ( max , a [ i ] ) ; } return max ; } return ans ; }
function count ( pos , even , odd , tight , num ) { if ( pos == num . length ) { if ( num . length & 1 ) [ odd , even ] = [ even , odd ]  var d = even - odd ; for ( var i = 0 ; i < 24 ; i ++ ) if ( d == prime [ i ] ) return 1 ; return 0 ; } if ( dp [ pos ] [ even ] [ odd ] [ tight ] != - 1 ) return dp [ pos ] [ even ] [ odd ] [ tight ] ; var ans = 0 ; var limit = ( tight ? 9 : num [ pos ] ) ; for ( var d = 0 ; d <= limit ; d ++ ) { var currF = tight , currEven = even ; var currOdd = odd ; if ( d < num [ pos ] ) currF = 1 ; if ( pos & 1 ) currOdd += d ; else currEven += d ; ans += count ( pos + 1 , currEven , currOdd , currF , num ) ; } return dp [ pos ] [ even ] [ odd ] [ tight ] = ans ; }
function maxWeight ( arr , n , w1_r , w2_r , i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != - 1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; var fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = Math . max ( fill_none , Math . max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; }
function solve ( x ) { var num = [ ] ; while ( x ) { num . push ( x % 10 ) ; x = parseInt ( x / 10 ) ; } num . reverse ( ) ; for ( var i = 0 ; i < M ; i ++ ) for ( var j = 0 ; j < 165 ; j ++ ) dp [ i ] [ j ] = Array . from ( Array ( M ) , ( ) => Array ( 2 ) . fill ( - 1 ) ) ; return count ( 0 , 0 , 0 , 0 , 0 , num ) ; }
function factorial ( k ) { fac [ 0 ] = 1 ; for ( i = 1 ; i <= k + 1 ; i ++ ) { fac [ i ] = ( i * fac [ i - 1 ] ) ; } }
function MaxProfit ( treasure , color , n , k , col , A , B ) { return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != - 1 ) return dp [ k ] [ col ] ; let sum = 0 ; if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k ] [ col ] = sum ; }
function maxCost ( a , n , l , r ) { var mx = 0 , k ; for ( var i = 0 ; i < n ; ++ i ) mx = Math . max ( mx , a [ i ] ) ; var count = new Array ( mx + 1 ) ; count . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; var res = new Array ( mx + 1 ) ; res [ 0 ] = 0 ; l = Math . min ( l , r ) ; for ( var num = 1 ; num <= mx ; num ++ ) { k = Math . max ( num - l - 1 , 0 ) ; res [ num ] = Math . max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; }
function alternateFib ( n ) { if ( n < 0 ) return ; var f1 = 0 ; var f2 = 1 ; document . write ( f1 + "▁" ) ; for ( i = 2 ; i <= n ; i ++ ) { var f3 = f2 + f1 ; if ( i % 2 == 0 ) document . write ( f3 + "▁" ) ; f1 = f2 ; f2 = f3 ; } }
function findSDSFunc ( n ) { let DP = [ ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }
function findInd ( key , i , n , k , arr ) { var start , end , mid , ind = - 1 ; start = i + 1 ; end = n - 1 ; while ( start < end ) { mid = start + ( end - start ) / 2 ; if ( arr [ mid ] - key <= k ) { ind = mid ; start = mid + 1 ; } else { end = mid ; } } return ind ; }
function Combination ( a , combi , n , r , depth , index ) { if ( index == r ) { let product = 1 ; for ( let i = 0 ; i < r ; i ++ ) product = product * combi [ i ] ; sum += product ; return ; } for ( let i = depth ; i < n ; i ++ ) { combi [ index ] = a [ i ] ; Combination ( a , combi , n , r , i + 1 , index + 1 ) ; } }
function zigzag ( n , k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
function lobb ( n , m ) { return ( ( 2 * m + 1 ) * binomialCoeff ( 2 * n , m + n ) ) / ( m + n + 1 ) ; }
function numberofways ( A , B , N , M ) { let pos = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) pos [ i ] = [ ] ; for ( let i = 0 ; i < M ; i ++ ) pos [ B [ i ] . charCodeAt ( 0 ) ] . push ( i + 1 ) ; let dpl = new Array ( N + 2 ) ; for ( let i = 0 ; i < N + 2 ; i ++ ) { dpl [ i ] = new Array ( M + 2 ) ; for ( let j = 0 ; j < M + 2 ; j ++ ) dpl [ i ] [ j ] = 0 ; } for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 1 ; j <= M ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ; else dpl [ i ] [ j ] = Math . max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ; } } let LCS = dpl [ N ] [ M ] ; let dpr = new Array ( N + 2 ) ; for ( let i = 0 ; i < N + 2 ; i ++ ) { dpr [ i ] = new Array ( M + 2 ) ; for ( let j = 0 ; j < M + 2 ; j ++ ) dpr [ i ] [ j ] = 0 ; } for ( let i = N ; i >= 1 ; i -- ) { for ( let j = M ; j >= 1 ; j -- ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ; else dpr [ i ] [ j ] = Math . max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ; } } let ans = 0 ; for ( let i = 0 ; i <= N ; i ++ ) { for ( let j = 0 ; j < MAX ; j ++ ) { for ( let x = 0 ; x < pos [ j ] . length ; x ++ ) { if ( dpl [ i ] [ pos [ j ] [ x ] - 1 ] + dpr [ i + 1 ] [ pos [ j ] [ x ] + 1 ] == LCS ) { ans ++ ; break ; } } } } return ans ; }
function precompute ( s , n , l , r ) { l [ s [ 0 ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < MAX_CHAR ; j ++ ) l [ j ] [ i ] += l [ j ] [ i - 1 ] ; l [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] [ i ] ++ ; } r [ s [ n - 1 ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < MAX_CHAR ; j ++ ) r [ j ] [ i ] += r [ j ] [ i + 1 ] ; r [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] [ i ] ++ ; } }
function maxSum ( mat , n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; let dp = new Array ( n ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } let maxSum = Number . MIN_VALUE , max ; for ( let j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < n ; j ++ ) { max = Number . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( let j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
function minJump ( height , x , y ) { if ( x == R - 1 && y == C - 1 ) return 0 ; var diag = 1000000000 ; if ( isSafe ( x + 1 , y + 1 ) ) diag = minJump ( height , x + 1 , y + 1 ) + Math . abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ; var down = 1000000000 ; if ( isSafe ( x + 1 , y ) ) down = minJump ( height , x + 1 , y ) + Math . abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ; var right = 1000000000 ; if ( isSafe ( x , y + 1 ) ) right = minJump ( height , x , y + 1 ) + Math . abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ; return Math . min ( down , Math . min ( right , diag ) ) ; }
function numberOfWays ( x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
function minRemove ( arr , n ) { let LIS = new Array ( n ) . fill ( 0 ) ; let len = 0 ; for ( let i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; }
function smallestSumSubarr ( arr , n ) { let min_ending_here = 2147483647 ; let min_so_far = 2147483647 ; for ( let i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . min ( min_so_far , min_ending_here ) ; } return min_so_far ; }
function baseconversion ( arr , num , base ) { var i = 0 , rem , j ; if ( num == 0 ) { return 0 ; } while ( num > 0 ) { rem = num % base ; arr [ i ++ ] = rem ; num = parseInt ( num / base ) ; } return i ; }
function ans ( n ) { if ( n < 6 ) { return n ; } return n % 6 + 10 * ( ans ( parseInt ( n / 6 ) ) ) ; }
function nonDecNums ( n ) { let a = new Array ( n + 1 )  for ( let i = 0 ; i < n + 1 ; i ++ ) { a [ i ] = new Array ( 10 ) ; } for ( let i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
function LAS ( arr , n ) { let inc = 1 ; let dec = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) { inc = dec + 1 ; } else if ( arr [ i ] < arr [ i - 1 ] ) { dec = inc + 1 ; } } return Math . max ( inc , dec ) ; }
function lps ( str ) { let n = str . length ; let L = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { L [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { L [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( let cl = 2 ; cl <= n ; cl ++ ) { for ( let i = 0 ; i < n - cl + 1 ; i ++ ) { let j = i + cl - 1 ; if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; }
function largestZigZagSumRec ( mat , i , j , n ) { if ( i == n - 1 ) return mat [ i ] [ j ] ; let zzs = 0 ; for ( let k = 0 ; k < n ; k ++ ) if ( k != j ) zzs = Math . max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) ; return zzs + mat [ i ] [ j ] ; }
function largestZigZag ( mat , n ) { let res = 0 ; for ( let j = 0 ; j < n ; j ++ ) res = Math . max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) ; return res ; }
function MaxDotProduct ( A , B , m , n ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j < m + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= n ; i ++ ) for ( let j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; }
function unboundedKnapsack ( W , n , val , wt ) { let dp = new Array ( W + 1 ) ; dp . fill ( 0 ) ; for ( let i = 0 ; i <= W ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( wt [ j ] <= i ) { dp [ i ] = Math . max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ; } } } return dp [ W ] ; }
function countSubarray ( arr , n , k ) { let s = 0 ; let i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } let count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } s += parseInt ( ( count * ( count + 1 ) ) / 2 , 10 ) ; } return ( n * parseInt ( ( n + 1 ) / 2 , 10 ) - s ) ; }
function CountPS ( str , n ) { let dp = new Array ( n ) ; let P = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; P [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; P [ i ] [ j ] = false ; } } for ( let i = 0 ; i < n ; i ++ ) P [ i ] [ i ] = true ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { P [ i ] [ i + 1 ] = true ; dp [ i ] [ i + 1 ] = 1 ; } } for ( let gap = 2 ; gap < n ; gap ++ ) { for ( let i = 0 ; i < n - gap ; i ++ ) { let j = gap + i ; if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ; if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } } return dp [ 0 ] [ n - 1 ] ; }
function breakSum ( n ) { if ( n == 0 n == 1 ) return n ; return Math . max ( ( breakSum ( Math . floor ( n / 2 ) ) + breakSum ( Math . floor ( n / 3 ) ) + breakSum ( Math . floor ( n / 4 ) ) ) , n ) ; }
function findMinSum ( arr , n ) { var sum = Array ( n ) . fill ( 0 ) ; sum [ 0 ] = arr [ 0 ] ; sum [ 1 ] = arr [ 1 ] ; sum [ 2 ] = arr [ 2 ] ; for ( var i = 3 ; i < n ; i ++ ) sum [ i ] = arr [ i ] + minimum ( sum [ i - 3 ] , sum [ i - 2 ] , sum [ i - 1 ] ) ; return minimum ( sum [ n - 1 ] , sum [ n - 2 ] , sum [ n - 3 ] ) ; }
function minAdjustmentCost ( A , n , target ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Number . MAX_VALUE ; let k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } let res = Number . MAX_VALUE ; for ( let j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }
function countWays ( p , q , r , last ) { if ( p < 0 q < 0 r < 0 ) return 0 ; if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ; if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ; if ( last == 0 ) return countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ; if ( last == 1 ) return countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; if ( last == 2 ) return countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; return 0 ; }
function countP ( n , k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }
function countP ( n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( let i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= k ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }
function has4 ( x ) { while ( x != 0 ) { if ( x % 10 == 4 ) return true ; x = Math . floor ( x / 10 ) ; } return false ; }
function findMaxforN ( root , N ) { if ( root == null ) return - 1 ; if ( root . key == N ) return N ; else if ( root . key < N ) { var k = findMaxforN ( root . right , N ) ; if ( k == - 1 ) return root . key ; else return k ; } else if ( root . key > N ) return findMaxforN ( root . left , N ) ; return - 1 ; }
function findMinInsertionsDP ( str , n ) { let table = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { table [ i ] = new Array ( n ) ; } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { table [ i ] [ j ] = 0 ; } } let l = 0 , h = 0 , gap = 0 ; for ( gap = 1 ; gap < n ; gap ++ ) { for ( l = 0 , h = gap ; h < n ; l ++ , h ++ ) { table [ l ] [ h ] = ( str [ l ] == str [ h ] ) ? table [ l + 1 ] [ h - 1 ] : ( Math . min ( table [ l ] [ h - 1 ] , table [ l + 1 ] [ h ] ) + 1 ) ; } } return table [ 0 ] [ n - 1 ] ; }
function distanceBetween2 ( root , a , b ) { if ( root == null ) return 0 ; if ( root . key > a && root . key > b ) return distanceBetween2 ( root . left , a , b ) ; if ( root . key < a && root . key < b ) return distanceBetween2 ( root . right , a , b ) ; if ( root . key >= a && root . key <= b ) return distanceFromRoot ( root , a ) + distanceFromRoot ( root , b ) ; return 0 ; }
function eggDrop ( n , k ) { let eggFloor = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { eggFloor [ i ] = new Array ( k + 1 ) ; } let res ; let i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = Number . MAX_VALUE ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; }
function getCountUtil ( root , low , high , count ) { if ( root == null ) return true ; var l = getCountUtil ( root . left , low , high , count ) ; var r = getCountUtil ( root . right , low , high , count ) ; if ( l && r && inRange ( root , low , high ) ) { ++ count . a ; return true ; } return false ; }
function ksmallestElementSum ( root , k ) { var res = ksmallestElementSumRec ( root , k ) ; return res ; }
function findOccurrences ( S , T ) { let n1 = S . length ; let n2 = T . length ; let ans = 0 ; let last = 0 ; for ( let i = 0 ; i <= n1 - n2 ; i ++ ) { let chk = true ; for ( let j = 0 ; j < n2 ; j ++ ) { if ( T [ j ] != S [ i + j ] ) { chk = false ; break ; } } if ( chk ) { ans += ( i + 1 - last ) * ( n1 - ( i + n2 - 1 ) ) ; last = i + 1 ; } } document . write ( ans ) ; }
function countTimes ( arr , K ) { let N = arr . length ; if ( N == 1 ) return 1 ; if ( N < 3 ) return 0 ; if ( N == 3 ) { let cnt = 0 ; cnt += ( Math . abs ( arr [ 0 ] - arr [ 1 ] ) == K ? 1 : 0 ) + ( Math . abs ( arr [ 2 ] - arr [ 1 ] ) == K ? 1 : 0 ) + ( Math . abs ( arr [ 0 ] - arr [ 2 ] ) == K ? 1 : 0 ) ; return cnt ; } let prefix = new Array ( N + 2 ) ; let suffix = new Array ( N + 2 ) ; for ( let i = 0 ; i < N + 2 ; i ++ ) { prefix [ i ] = 0 ; } for ( let i = 0 ; i < N + 2 ; i ++ ) { suffix [ i ] = 0 ; } prefix [ 0 ] = arr [ 0 ] ; prefix [ 1 ] = arr [ 1 ] ; suffix [ N - 1 ] = arr [ N - 1 ] ; suffix [ N - 2 ] = arr [ N - 2 ] ; for ( let i = 2 ; i < N ; i += 2 ) { prefix [ i ] = arr [ i ] + prefix [ i - 2 ] ; } for ( let i = 3 ; i < N ; i += 2 ) { prefix [ i ] = arr [ i ] + prefix [ i - 2 ] ; } for ( let i = N - 3 ; i >= 0 ; i -= 2 ) { suffix [ i ] = arr [ i ] + suffix [ i + 2 ] ; } for ( let i = N - 4 ; i >= 0 ; i -= 2 ) { suffix [ i ] = arr [ i ] + suffix [ i + 2 ] ; } let count = 0 ; for ( let i = 2 ; i < N ; i ++ ) { if ( Math . abs ( prefix [ i - 1 ] + suffix [ i + 2 ] - prefix [ i - 2 ] - suffix [ i + 1 ] ) == K ) { count ++ ; } } count += findCount0th ( arr , N , K ) ; count += findCount1st ( arr , N , K ) ; return count ; }
function LargestArray ( N , low , high ) { let high_index = N - ( high - low + 1 ) ; if ( high_index > ( N - 1 ) / 2 ) { document . write ( "Not▁Possible" ) ; return ; } if ( high_index <= 0 ) high_index = 1 ; let A = [ ] ; let temp = high ; for ( let i = high_index ; i >= 0 ; i -- ) { A [ i ] = temp -- ; } high -= 1 ; for ( let i = high_index + 1 ; i < N ; i ++ ) A [ i ] = high -- ; for ( let i = 0 ; i < N ; i ++ ) { document . write ( A [ i ] + "▁" ) ; } }
function OddLengthSum ( arr ) { let sum = 0 ; let l = arr . length ; for ( let i = 0 ; i < l ; i ++ ) { sum += Math . floor ( ( ( i + 1 ) * ( l - i ) + 1 ) / 2 ) * arr [ i ] ; } return sum ; }
function SpiralElement ( x , y ) { var r ; if ( x < y ) { if ( y % 2 == 1 ) { r = y * y ; return ( r - x + 1 ) ; } else { r = ( y - 1 ) * ( y - 1 ) ; return ( r + x ) ; } } else { if ( x % 2 == 0 ) { r = x * x ; return ( r - y + 1 ) ; } else { r = ( x - 1 ) * ( x - 1 ) ; return ( r + y ) ; } } }
function checkprefix ( A , B ) { var s1 = A . toString ( ) ; var s2 = B . toString ( ) ; var n1 = s1 . length ; var n2 = s2 . length ; if ( n1 < n2 ) { return false ; } for ( var i = 0 ; i < n2 ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { return false ; } } return true ; }
function Count ( i ) { if ( i == 0 ) return 1 ; else if ( i < 0 ) return 0 ; if ( a [ i ] == 0 ) { a [ i ] = ( i + 1 ) + 2 * Count ( i - 1 ) ; return a [ i ] ; } else return a [ i ] ; }
function printOddFactorNumber ( n , m ) { for ( let i = n ; i <= m ; i ++ ) { if ( ( i > 0 ) && ( ( i & ( i - 1 ) ) != 0 ) ) document . write ( i + "▁" ) ; } return 0 ; }
function stateC ( n ) { document . write ( "String▁accepted" ) ; }
function findDistinctSums ( n ) { s = new Set ( ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = i ; j <= n ; j ++ ) { s . add ( i + j ) ; } } return s . size ; }
function check_string_exist ( S ) { var size = S . length ; var check = true ; for ( var i = 0 ; i < size ; i ++ ) { if ( S [ i ] != S [ ( i + 2 ) % size ] ) { check = false ; break ; } } if ( check ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function nthTerm ( N ) { let nth = 0 , first_term = 12 ; nth = ( first_term * ( Math . pow ( 2 , N - 1 ) ) ) + 11 * ( ( Math . pow ( 2 , N - 1 ) ) - 1 ) ; return nth ; }
function isVowel ( ch ) { switch ( ch ) { case "a" : case "e" : case "i" : case "o" : case "u" : return true ; } return false ; }
function KMPSearch ( pat , txt ) { let M = pat . length ; let N = txt . length ; let lps = new Array ( M ) ; lps . fill ( 0 ) ; computeLPSArray ( pat , M , lps ) ; let i = 0 ; let j = 0 ; while ( i < N ) { if ( pat [ j ] == txt [ i ] ) { j ++ ; i ++ ; } if ( j == M ) { return i - j ; } else if ( i < N && pat [ j ] != txt [ i ] ) { if ( j != 0 ) j = lps [ j - 1 ] ; else i = i + 1 ; } } return 0 ; }
function checkSequence ( a , b ) { if ( b . length == 0 ) return true ; if ( a . length == 0 ) return false ; if ( a [ 0 ] == b [ 0 ] ) return checkSequence ( a . substring ( 1 ) , b . substring ( 1 ) ) ; else return checkSequence ( a . substring ( 1 ) , b ) ; }
function getCount ( a , b ) { if ( b . length % a . length != 0 ) return - 1 ; var count = parseInt ( b . length / a . length ) ; var str = "" ; for ( i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str == ( b ) ) return count ; return - 1 ; }
function isVowel ( c ) { let vowel = "aeiou" ; for ( let i = 0 ; i < vowel . length ; ++ i ) { if ( vowel [ i ] == c ) { return true ; } } return false ; }
function calc ( l , r , s ) { if ( Math . abs ( r - l ) % 2 == 0 ) { return 0 ; } if ( l > r ) { return dp [ l ] [ r ] = 1 ; } if ( dp [ l ] [ r ] != - 1 ) { return dp [ l ] [ r ] ; } if ( ( r - l ) == 1 ) { if ( s [ l ] == s [ r ] ) { dp [ l ] [ r ] = 1 ; } else { dp [ l ] [ r ] = 0 ; } return dp [ l ] [ r ] ; } let ans = 0 ; for ( let k = l + 1 ; k <= r ; k += 2 ) { let temp = 1 ; if ( s [ l ] == s [ k ] ) { temp = calc ( l + 1 , k - 1 , s ) * calc ( k + 1 , r , s ) * choose [ Math . floor ( ( r - l + 1 ) / 2 ) ] [ Math . floor ( ( r - k ) / 2 ) ] ; ans += temp ; } } return dp [ l ] [ r ] = ans ; }
function number_of_tower ( house , range , n ) { house . sort ( function ( a , b ) { return a - b ; } ) ; let numOfTower = 0 ; let i = 0 ; while ( i < n ) { numOfTower ++ ; let loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
function minimumFlips ( s ) { let n = s . length ; let i ; let cnt0 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == "0" ) cnt0 ++ ; } let cnt1 = 0  let res = n - cnt0  for ( i = 0 ; i < n ; i ++ ) if ( s [ i ] == "0" ) { cnt0 -= 1 } else if ( s [ i ] == "1" ) { res = Math . min ( res , cnt1 + cnt0 )  cnt1 += 1 } return res }
function KthCharacter ( s , t , k ) { let f = 1 ; let ss = 2 ; let tmp = "" ; let len = tmp . length ; while ( len < k ) { let tf = f ; let ts = ss ; while ( tf -- != 0 ) { tmp += s ; } while ( ts -- != 0 ) { tmp += t ; } f += 2 ; ss += 2 ; len = tmp . length ; } let output = tmp [ k - 1 ] ; return output ; }
function fact ( n ) { var ans = 1 ; for ( var i = 2 ; i <= n ; i ++ ) ans = ans * i ; return ans ; }
function checkIfPossible ( N , arr , T ) { let freqS = new Array ( 256 ) . fill ( 0 ) ; let freqT = new Array ( 256 ) . fill ( 0 ) ; for ( let ch of T ) { freqT [ ch . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } for ( let i = 0 ; i < N ; i ++ ) { for ( let ch of arr [ i ] ) { freqS [ ch . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } } for ( let i = 0 ; i < 256 ; i ++ ) { if ( freqT [ i ] == 0 && freqS [ i ] != 0 ) { return "No" ; } else if ( freqS [ i ] == 0 && freqT [ i ] != 0 ) { return "No" ; } else if ( freqT [ i ] != 0 && freqS [ i ] != ( freqT [ i ] * N ) ) { return "No" ; } } return "Yes" ; }
function findSubstringInWraproundString ( p ) { let ans = 0 ; let curLen = 0 ; let arr = new Array ( 26 ) ; arr . fill ( 0 ) ; for ( let i = 0 ; i < p . length ; i ++ ) { let curr = p [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ; if ( i > 0 && ( p [ i - 1 ] . charCodeAt ( ) != ( ( curr + 26 - 1 ) % 26 + "a" . charCodeAt ( ) ) ) ) { curLen = 0 ; } curLen ++ ; if ( curLen > arr [ curr ] ) { ans += ( curLen - arr [ curr ] ) ; arr [ curr ] = curLen ; } } document . write ( ans ) ; }
function update ( BIT , idx , i , val ) { while ( i < 10005 ) { BIT [ idx ] [ i ] += val ; i = i + ( i & ( - i ) ) ; } }
function fact ( a ) { var i , f = 1 ; for ( i = 2 ; i <= a ; i ++ ) f = f * i ; return f ; }
function maxLength ( arr ) { let tmp = helper ( arr , 0 ) ; let len = 0 ; for ( let i = 0 ; i < tmp . length ; i ++ ) { len = len > tmp [ i ] . length ? len : tmp [ i ] . length ; } return len ; }
function polynomialRollingHash ( str ) { let p = 31 ; let m = ( 1e9 + 9 ) ; let power_of_p = 1 ; let hash_val = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { hash_val = ( hash_val + ( str [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) + 1 ) * power_of_p ) % m ; power_of_p = ( power_of_p * p ) % m ; } return hash_val ; }
function isPalindrome ( str ) { var l = 0 ; var h = str . length - 1 ; while ( h > l ) { if ( str [ l ++ ] != str [ h -- ] ) { return false ; } } return true ; }
function checkPalindrome ( ) { var oddCnt = 0 ; freq . forEach ( x => { if ( x % 2 == 1 ) oddCnt ++ ; } ) ; return oddCnt <= 1 ; }
function countSubstrings ( str , K ) { var N = str . length ; var answer = 0 ; var map = new Map ( ) ; for ( var i = 0 ; i < K ; i ++ ) { if ( map . has ( str [ i ] ) ) map . set ( str [ i ] , map . get ( str [ i ] ) + 1 ) else map . set ( str [ i ] , 1 ) } if ( map . size == K ) answer ++ ; for ( var i = K ; i < N ; i ++ ) { if ( map . has ( str [ i ] ) ) map . set ( str [ i ] , map . get ( str [ i ] ) + 1 ) else map . set ( str [ i ] , 1 )  if ( map . has ( str [ i - K ] ) ) map . set ( str [ i - K ] , map . get ( str [ i - K ] ) - 1 )  if ( map . has ( str [ i - K ] ) && map . get ( str [ i - K ] ) == 0 ) { map . delete ( str [ i - K ] ) ; } if ( map . size == K ) { answer ++ ; } } return answer ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
function moveAtEnd ( s , i , l ) { if ( i >= l ) return ; let curr = s [ i ] ; if ( curr != "x" ) document . write ( curr ) ; moveAtEnd ( s , i + 1 , l ) ; if ( curr == "x" ) document . write ( curr ) ; return ; }
function kthString ( n , k ) { var total = 0 ; var i = 1 ; while ( total < k ) { total = total + n - i ; i ++ ; } var first_y_position = i - 1 ; var second_y_position = k - ( total - n + first_y_position ) ; for ( var j = 1 ; j < first_y_position ; j ++ ) document . write ( "x" ) ; document . write ( "y" ) ; var j = first_y_position + 1 ; while ( second_y_position > 1 ) { document . write ( "x" ) ; second_y_position -- ; j ++ ; } document . write ( "y" ) ; while ( j < n ) { document . write ( "x" ) ; j ++ ; } }
function check ( str ) { if ( checkIfStartsWithCapital ( str ) ) document . write ( "Accepted" ) ; else document . write ( "Not▁Accepted" ) ; }
function compressString ( s , n ) { let freq = new Array ( MAX ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { freq [ s [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ++ ; } for ( let i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == 0 ) continue ; document . write ( String . fromCharCode ( i + "a" . charCodeAt ( ) ) + "" + freq [ i ] ) ; } }
function binaryDec ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }
function findLength ( s , k ) { var ans = 1000000000 ; var l = 0 ; var r = 0 ; var cnt_zero = 0 , cnt_one = 0 ; while ( l < s . length && r <= s . length ) { if ( cnt_zero >= k && cnt_one >= 1 ) { ans = Math . min ( ans , r - l ) ; l ++ ; if ( s [ l - 1 ] == "0" ) cnt_zero -- ; else cnt_one -- ; } else { if ( r == s . length ) break ; if ( s [ r ] == "0" ) cnt_zero ++ ; else cnt_one ++ ; r ++ ; } } if ( ans == 1000000000 ) return - 1 ; return ans ; }
function cntSplits ( s ) { if ( s [ s . length - 1 ] == "1" ) return - 1 ; var ans = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) ans += ( s [ i ] == "0" ) ; return ans ; }
function findMinSubStr ( arr , n , str ) { for ( var i = 0 ; i < n ; i ++ ) uSet . add ( arr [ i ] ) ; findSubStr ( str , 0 , 0 ) ; }
function printChar ( str , n ) { let freq = new Array ( SIZE ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { freq [ str . charCodeAt ( i ) - "a" . charCodeAt ( 0 ) ] ++ ; } for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str . charCodeAt ( i ) - "a" . charCodeAt ( 0 ) ] % 2 == 0 ) { document . write ( str [ i ] ) ; } } }
function find_digit ( s , n ) { var first_digit = - 1 ; for ( var i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] < "0" s [ i ] > "9" ) { first_digit = i ; break ; } } first_digit ++ ; var s_len = first_digit ; var num = 0 , pw = 1 ; var i = n - 1 ; while ( i >= 0 ) { if ( s [ i ] >= "0" && s [ i ] <= "9" ) { var digit = s [ i ] - "0" ; num = num + ( pw * digit ) ; if ( num >= s_len ) return - 1 ; pw = pw * 10 ; } i -- ; } num = num * 10 ; var req = s_len - num ; if ( req > 9 req < 0 ) return - 1 ; return req ; }
function countSubString ( s , c , k ) { var leftCount = 0 , rightCount = 0 ; var left = 0 , right = 0 ; var freq = 0 ; var result = 0 , len = s . length ; while ( s [ left ] !== c && left < len ) { left ++ ; leftCount ++ ; } right = left + 1 ; while ( freq !== k - 1 && right - 1 < len ) { if ( s [ right ] === c ) freq ++ ; right ++ ; } while ( left < len && right - 1 < len ) { while ( s [ left ] !== c && left < len ) { left ++ ; leftCount ++ ; } while ( right < len && s [ right ] !== c ) { if ( s [ right ] === c ) freq ++ ; right ++ ; rightCount ++ ; } result = result + ( leftCount + 1 ) * ( rightCount + 1 ) ; freq = k - 1 ; leftCount = 0 ; rightCount = 0 ; left ++ ; right ++ ; } return result ; }
function minOperations ( n , a , b , c ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let x = a [ i ] ; let y = b [ i ] ; let z = c [ i ] ; if ( x == y && y == z ) { ; } else if ( x == y y == z x == z ) { ans ++ ; } else { ans += 2 ; } } return ans ; }
function preCalculate ( s , prefix ) { let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { prefix [ i ] [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < 26 ; j ++ ) prefix [ i ] [ j ] += prefix [ i - 1 ] [ j ] ; } }
function check ( s , l ) { var pos = [ ] ; for ( var i = 0 ; i < l ; i ++ ) { if ( s [ i ] == "1" ) pos . push ( i ) ; } var t = pos . length ; for ( var i = 1 ; i < t ; i ++ ) { if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) return false ; } return true ; }
function compute_lps ( s ) { var n = s . length ; var lps = Array ( n ) ; var len = 0 ; lps [ 0 ] = 0 ; var i = 1 ; while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = lps [ len - 1 ] ; else { lps [ i ] = 0 ; i ++ ; } } } return lps ; }
function printLastChar ( str ) { str = str + "▁" ; for ( var i = 1 ; i < str . length ; i ++ ) { if ( str [ i ] === "▁" ) document . write ( str [ i - 1 ] + "▁" ) ; } }
function getMinimizedSum ( str , len ) { var i , maxVal = - 2147483648 , sum = 0 ; var occurrences = new Array ( 26 ) . fill ( 0 ) ; for ( i = 0 ; i < len ; i ++ ) { occurrences [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; sum += str [ i ] . charCodeAt ( 0 ) ; } for ( i = 0 ; i < 26 ; i ++ ) { maxVal = Math . max ( maxVal , occurrences [ i ] * ( i + "a" . charCodeAt ( 0 ) ) ) ; } return sum - maxVal ; }
function substrDeletion ( str , len ) { let count0 = 0 , count1 = 0 ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] == "0" ) count0 ++ ; else count1 ++ ; } return Math . min ( count0 , count1 ) ; }
function printString ( str , n ) { let ones = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( str [ i ] == "1" ) ones ++ ; let used = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == "2" && ! used ) { used = true ; for ( let j = 0 ; j < ones ; j ++ ) document . write ( "1" ) ; } if ( str [ i ] != "1" ) document . write ( str [ i ] ) ; } if ( ! used ) for ( let j = 0 ; j < ones ; j ++ ) document . write ( "1" ) ; }
function Colour_Combination ( s ) { let temp = s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == "B" temp == "G" ) && ( s [ i ] == "G" s [ i ] == "B" ) ) temp = "Y" ; else if ( ( temp == "B" temp == "Y" ) && ( s [ i ] == "Y" s [ i ] == "B" ) ) temp = "G" ; else temp = "B" ; } } return temp ; }
function reverse ( str , x ) { var n = ( str . length - x ) / 2 ; for ( i = 0 ; i < n ; i ++ ) document . write ( str . charAt ( i ) ) ; for ( i = n + x - 1 ; i >= n ; i -- ) document . write ( str . charAt ( i ) ) ; for ( i = n + x ; i < str . length ; i ++ ) document . write ( str . charAt ( i ) ) ; }
function countSubStrings ( str , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) count += subStringsStartingHere ( str , n , i ) ; } return count ; }
function maxFreq ( s , a , b ) { var fre = new Array ( 10 ) . fill ( 0 ) ; var n = s . length ; if ( a > b ) { var temp = a ; a = b ; b = temp ; } for ( var i = 0 ; i < n ; i ++ ) fre [ s [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ] ++ ; if ( fre [ a ] === 0 && fre [ b ] === 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; }
function sumProdOfPrimeFreq ( s ) { let prime = new Array ( s . length + 1 ) ; prime . fill ( true ) ; SieveOfEratosthenes ( prime , s . length + 1 ) ; let i , j ; let m = new Map ( ) ; for ( i = 0 ; i < s . length ; i ++ ) m . set ( s [ i ] , m . get ( s [ i ] ) == null ? 1 : m . get ( s [ i ] ) + 1 ) ; let sum = 0 , product = 1 ; for ( let it of m ) { console . log ( m )  if ( prime [ it [ 1 ] ] ) { sum += it [ 1 ] ; product *= it [ 1 ] ; } } document . write ( "Sum▁=▁" + sum ) ; document . write ( "Product=" + product ) ; }
function StringMatch ( s ) { var lo = 0 , hi = s . length , len = s . length ; var ans = [ ] ; for ( var x = 0 ; x < len ; x ++ ) { if ( s [ x ] == "I" ) { ans . push ( lo ) ; lo += 1 ; } else { ans . push ( hi ) ; hi -= 1 ; } } ans . push ( lo ) ; document . write ( "[" ) ; for ( var i = 0 ; i < ans . length ; i ++ ) { document . write ( ans [ i ] ) ; if ( i != ans . length - 1 ) document . write ( "," ) ; } document . write ( "]" ) ; }
function CountCharacters ( str , l , r ) { let cnt = 0 ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( l <= str [ i ] . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= r ) { cnt ++ ; document . write ( str [ i ] + "▁" ) ; } } return cnt ; }
function countPermutations ( str ) { let even = Math . floor ( str . length / 2 ) ; let odd = str . length - even ; let ways = 0 ; let freq = new Array ( 26 ) . fill ( 0 ) ; for ( let i = 0 ; i < str . length ; i ++ ) { ++ freq [ str . charCodeAt ( i ) - "a" . charCodeAt ( 0 ) ] ; } let nvowels = freq [ 0 ] + freq [ 4 ] + freq [ 8 ] + freq [ 14 ] + freq [ 20 ] ; let nconsonants = str . length - nvowels ; ways = npr ( odd , nvowels ) * npr ( nconsonants , nconsonants ) ; return ways ; }
function isVowel ( ch ) { if ( ch != "a" && ch != "e" && ch != "i" && ch != "o" && ch != "u" ) return false ; return true ; }
function maxLength ( s , n ) { var right = 0 , left = 0 ; var coun = 0 , max_length = Number . MIN_VALUE ; s = s + "1" ; for ( var i = 0 ; i <= n ; i ++ ) { if ( s [ i ] == "o" ) coun ++ ; else { if ( coun > max_length ) { right = 0 ; left = 0 ; if ( s [ i ] == "x" ) right = 1 ; if ( ( ( i - coun ) > 0 ) && ( s [ i - coun - 1 ] == "x" ) ) left = 1 ; coun = Math . ceil ( coun / ( right + left ) ) ; max_length = Math . max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; }
function is_possible ( s ) { let l = s . length ; let one = 0 , zero = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( s [ i ] == "0" ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( Math . abs ( one - zero ) == 1 ) ; }
function oddEquivalent ( s , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == "1" ) count ++ ; } return count ; }
function isPalindrome ( str ) { let firstChar = 0 , lastChar = str . length - 1 ; let ch = true ; for ( let i = 0 ; i < str . length ; i ++ ) { firstChar = firstPos ( str , firstChar , lastChar ) ; lastChar = lastPos ( str , lastChar , firstChar ) ; if ( lastChar < 0 firstChar < 0 ) break ; if ( str [ firstChar ] == str [ lastChar ] ) { firstChar ++ ; lastChar -- ; continue ; } ch = false ; break ; } return ch ; }
function find ( s ) { let max = 0 , i , j = 0 , countk = 0 , countr = 0 ; let table = new Array ( s . length ) ; for ( let i = 0 ; i < s . length ; i ++ ) { table [ i ] = new Array ( 2 ) ; } for ( i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == "R" ) countr ++ ; else table [ j ++ ] [ 0 ] = countr ; } j -- ; for ( i = s . length - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == "K" ) { countk ++ ; table [ j -- ] [ 1 ] = countk ; } if ( Math . min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) > max ) max = Math . min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) ; } return max ; }
function LongestSequence ( fre , n ) { for ( let i = 24 ; i >= 0 ; i -- ) { let mi = fre [ 0 ] [ i ] ; for ( let j = 1 ; j < n ; j ++ ) mi = Math . min ( fre [ j ] [ i ] , mi ) ; while ( mi -- != 0 ) document . write ( String . fromCharCode ( "a" . charCodeAt ( 0 ) + i ) ) ; } }
function firstNonRepeating ( str ) { let NO_OF_CHARS = 256 ; let arr = new Array ( NO_OF_CHARS ) ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) arr [ i ] = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( arr [ str [ i ] . charCodeAt ( 0 ) ] == - 1 ) arr [ str [ i ] . charCodeAt ( 0 ) ] = i ; else arr [ str [ i ] . charCodeAt ( 0 ) ] = - 2 ; } let res = Number . MAX_VALUE ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( arr [ i ] >= 0 ) res = Math . min ( res , arr [ i ] ) ; return res ; }
function preComputeCoeff ( ) { for ( var i = 0 ; i < max ; i ++ ) { for ( var j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = ( nCr [ i - 1 ] [ j - 1 ] + nCr [ i - 1 ] [ j ] ) % mod ; } } }
function countNonEmptySubstr ( str ) { let n = str . length ; return n * ( n + 1 ) / 2 ; }
function countWays ( s ) { let count = new Array ( 26 ) ; count . fill ( 0 ) ; for ( let i = 0 ; i < s . length ; i ++ ) count [ s [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ++ ; count [ s [ 0 ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] = 1 ; let ans = 1 ; for ( let i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
function isPerfectSquareString ( str ) { var sum = 0 ; var len = str . length ; for ( var i = 0 ; i < len ; i ++ ) sum += str . charCodeAt ( i ) ; var squareRoot = Math . sqrt ( sum ) ; return squareRoot - Math . floor ( squareRoot ) == 0 ; }
function findSubstrings ( s , k ) { var ans = 0 ; var cnt = Array ( 26 ) ; var i , j , n = s . length ; for ( i = 0 ; i < n ; i ++ ) { cnt = Array ( 26 ) . fill ( 0 ) ; for ( j = i ; j < n ; j ++ ) { cnt [ ( s [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ) ] ++ ; if ( cnt [ ( s [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ) ] <= k ) ans ++ ; else break ; } } return ans ; }
function isPanDigital ( s ) { let digits = new Array ( 10 ) . fill ( false ) ; for ( let i = 0 ; i < s . length ; i ++ ) digits [ s [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ] = true ; for ( let i = 0 ; i <= 9 ; i ++ ) if ( digits [ i ] == false ) return false ; return true ; }
function combinedSum ( s ) { let n = s . length ; let c_sum = 0 ; let range = ( 1 << n ) - 1 ; for ( let i = 0 ; i <= range ; i ++ ) c_sum += findSubSequence ( s , i ) ; return c_sum ; }
function numberOfPossiblePallindrome ( str , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) mp . set ( str [ i ] , mp . get ( str [ i ] ) == null ? 1 : mp . get ( str [ i ] ) + 1 ) ; let fi ; for ( let [ key , value ] of mp . entries ( ) ) { if ( value % 2 == 0 ) fi = value / 2 ; else { fi = ( value - 1 ) / 2 ; k ++ ; } num = num + fi ; den = den * fact ( fi ) ; } if ( num != 0 ) num = fact ( num ) ; let ans = Math . floor ( num / den ) ; if ( k != 0 ) { ans = ans * k ; } return ( ans ) ; }
function totalConsonants ( str ) { var count = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) if ( isConsonant ( str [ i ] ) ) ++ count ; return count ; }
function convert ( str ) { let n = str . length ; let str1 = "" ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == "▁" ) str1 = str1 + "_" ; else str1 = str1 + ( str [ i ] ) . toLowerCase ( ) ; } document . write ( str1 ) ; }
function isEven ( s ) { let l = s . length ; let dotSeen = false ; for ( let i = l - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == "0" && dotSeen == false ) continue ; if ( s [ i ] == "." ) { dotSeen = true ; continue ; } if ( ( s [ i ] - "0" ) % 2 == 0 ) return true ; return false ; } }
function isVowel ( c ) { return ( c == "A" c == "E" c == "I" c == "O" c == "U" c == "a" c == "e" c == "i" c == "o" c == "u" ) ; }
function countReduce ( str ) { let n = str . length ; let res = 0 ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; i ++ ) res += Math . abs ( str [ i ] . charCodeAt ( ) - str [ n - i - 1 ] . charCodeAt ( ) ) ; return res ; }
function reverse ( num , i , j ) { while ( i < j ) { var temp = num [ i ] ; num [ i ] = num [ j ] ; num [ j ] = temp ; i ++ ; j -- ; } }
function findWinner ( votes ) { let map = new Map ( ) ; for ( let i = 0 ; i < votes . length ; i ++ ) { if ( map . has ( votes [ i ] ) ) { map . set ( votes [ i ] , map . get ( votes [ i ] ) + 1 ) ; } else map . set ( votes [ i ] , 1 ) ; } let maxValueInMap = 0 ; let winner = "" ; for ( let [ key , value ] of map . entries ( ) ) { let Key = key ; let val = value ; if ( val > maxValueInMap ) { maxValueInMap = val ; winner = key ; } else if ( val == maxValueInMap && winner > Key ) winner = Key ; } document . write ( winner ) ; }
function distributingBalls ( k , n , str ) { let a = new Array ( MAX_CHAR ) ; a . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { a [ str [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ++ ; } for ( let i = 0 ; i < MAX_CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; }
function check ( freq , k ) { for ( let i = 0 ; i < MAX_CHAR ; i ++ ) if ( freq [ i ] != 0 && freq [ i ] != k ) return false ; return true ; }
function countSets ( a ) { var res = 0 ; for ( i = 0 ; i < n ; i ++ ) { var u = 0 , v = 0 ; for ( j = 0 ; j < m ; j ++ ) { if ( a [ i ] [ j ] == 1 ) u ++ ; else v ++ ; } res += Math . pow ( 2 , u ) - 1 + Math . pow ( 2 , v ) - 1 ; } for ( i = 0 ; i < m ; i ++ ) { var u = 0 , v = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( a [ j ] [ i ] == 1 ) u ++ ; else v ++ ; } res += Math . pow ( 2 , u ) - 1 + Math . pow ( 2 , v ) - 1 ; } return res - ( n * m ) ; }
function traverseTree ( root ) { if ( root == null ) return ; while ( root != null ) { document . write ( root . data + "▁" ) ; if ( root . child != null ) traverseTree ( root . child ) ; root = root . next ; } }
function calculateEnergy ( mat , n ) { let i_des , j_des , q ; let tot_energy = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { q = Math . floor ( mat [ i ] [ j ] / n ) ; i_des = q ; j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ; } } return tot_energy ; }
function countUnique ( mat , n , m ) { let uniquecount = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 && isUnique ( mat , i , j , n , m ) ) uniquecount ++ ; return uniquecount ; }
function uniqueCharacters ( str ) { for ( let i = 0 ; i < str . length ; i ++ ) for ( let j = i + 1 ; j < str . length ; j ++ ) if ( str [ i ] == str [ j ] ) return false ; return true ; }
function largest_alphabet ( a , n ) { let max = "A" ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] . charCodeAt ( ) > max . charCodeAt ( ) ) max = a [ i ] ; return max ; }
function isPalRec ( str , s , e ) { if ( s == e ) return true ; if ( ( str . charAt ( s ) ) != ( str . charAt ( e ) ) ) return false ; if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; }
function evenNumSubstring ( str ) { let len = str . length ; let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let temp = str [ i ] - "0" ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
function countSubstringWithEqualEnds ( s ) { var result = 0 ; var n = s . length ; for ( var i = 0 ; i < n ; i ++ ) for ( var len = 1 ; len <= n - i ; len ++ ) if ( checkEquality ( s . substring ( i , i + len ) ) ) result ++ ; return result ; }
function unique ( s ) { for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { return false ; } } return true ; }
function qType1 ( tree , l , x , str ) { update ( tree , l , - 1 , str [ l - 1 ] . charCodeAt ( 0 ) - 97 + 1 ) ; str [ l - 1 ] = x ; update ( tree , l , 1 , str [ l - 1 ] . charCodeAt ( 0 ) - 97 + 1 ) ; }
function countPairs ( str ) { let result = 0 ; let n = str . length ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str [ i ] . charCodeAt ( ) - str [ j ] . charCodeAt ( ) ) == Math . abs ( i - j ) ) result ++ ; return result ; }
function findMinLength ( arr , n ) { let min = arr [ 0 ] . length ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] . length < min ) { min = arr [ i ] . length ; } } return ( min ) ; }
function areDistinct ( str , i , j ) { var visited = new [ 26 ] ; for ( var k = i ; k <= j ; k ++ ) { if ( visited [ str . charAt ( k ) - "a" ] == true ) return false ; visited [ str . charAt ( k ) - "a" ] = true ; } return true ; }
function printRLE ( str ) { let n = str . length ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count ++ ; i ++ ; } document . write ( str [ i ] ) ; document . write ( count ) ; } }
function antiSpiralTraversal ( m , n , a ) { let i , k = 0 , l = 0 ; let stk = [ ] ; while ( k <= m && l <= n ) { for ( i = l ; i <= n ; ++ i ) stk . push ( a [ k ] [ i ] ) ; k ++ ; for ( i = k ; i <= m ; ++ i ) stk . push ( a [ i ] [ n ] ) ; n -- ; if ( k <= m ) { for ( i = n ; i >= l ; -- i ) stk . push ( a [ m ] [ i ] ) ; m -- ; } if ( l <= n ) { for ( i = m ; i >= k ; -- i ) stk . push ( a [ i ] [ l ] ) ; l ++ ; } } while ( stk . length != 0 ) { document . write ( stk [ stk . length - 1 ] + "▁" ) ; stk . pop ( ) ; } }
function findNormal ( mat , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] * mat [ i ] [ j ] ; return parseInt ( Math . sqrt ( sum ) ) ; }
function countExpPaths ( node , x ) { return evenPaths ( node , 0 , x ) ; }
function evenPaths ( node , count ) { if ( node == null || ( node . key % 2 != 0 ) ) { return count ; } if ( node . left == null && node . right == null ) { count ++ ; } count = evenPaths ( node . left , count ) ; return evenPaths ( node . right , count ) ; }
function countEvenPaths ( node ) { return evenPaths ( node , 0 ) ; }
function dfs ( u , count ) { visited [ u ] = true ; let temp = 0 ; for ( let i = 0 ; i < adjacent [ u ] . length ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] ) { temp ++ ; dfs ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; startnode = u ; } } }
function insertEdge ( u , v ) { adj [ u ] . push ( v ) ; adj [ v ] . push ( u ) ; }
function canPaint ( nodes , n , m ) { var visited = [ ] ; for ( var i = 0 ; i < n + 1 ; i ++ ) { visited . push ( 0 ) ; } var maxColors = 1 ; for ( var sv = 1 ; sv <= n ; sv ++ ) { if ( visited [ sv ] > 0 ) continue ; visited [ sv ] = 1 ; var q = [ ] ; q . push ( sv ) ; while ( q . length != 0 ) { var top = q [ 0 ] ; q . shift ( ) ; for ( var it of nodes [ top ] . edges ) { if ( nodes [ top ] . color == nodes [ it ] . color ) nodes [ it ] . color += 1 ; maxColors = Math . max ( maxColors , Math . max ( nodes [ top ] . color , nodes [ it ] . color ) ) ; if ( maxColors > m ) return 0 ; if ( visited [ it ] == 0 ) { visited [ it ] = 1 ; q . push ( it ) ; } } } } return 1 ; }
function FastDoubling ( n , res ) { if ( n == 0 ) { res [ 0 ] = 0 ; res [ 1 ] = 1 ; return ; } FastDoubling ( parseInt ( n / 2 , 10 ) , res ) ; a = res [ 0 ] ; b = res [ 1 ] ; c = 2 * b - a ; if ( c < 0 ) c += MOD ; c = ( a * c ) % MOD ; d = ( a * a + b * b ) % MOD ; if ( n % 2 == 0 ) { res [ 0 ] = c ; res [ 1 ] = d ; } else { res [ 0 ] = d ; res [ 1 ] = c + d ; } }
function canPlace ( a , n , p , sep ) { var prisoners_placed = 1 ; var last_prisoner_placed = a [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) { var current_cell = a [ i ] ; if ( current_cell - last_prisoner_placed >= sep ) { prisoners_placed ++ ; last_prisoner_placed = current_cell ; if ( prisoners_placed == p ) { return true ; } } } return false ; }
function _mergeSort ( arr , temp , left , right ) { let mid , inv_count = 0 ; if ( right > left ) { mid = parseInt ( ( right + left ) / 2 , 10 ) ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; }
function minSteps ( height , N ) { return minStepsRecur ( height , 0 , N , 0 ) ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = $y / 2 y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
function minimumRectangleArea ( A , N ) { let ans ; A . sort ( ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( let i = 1 ; i < N ; i ++ ) ans = Math . min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; }
function areaOftriangle ( side ) { let a = Math . sqrt ( Math . pow ( side / 2 , 2 ) + Math . pow ( side / 2 , 2 ) ) ; let b = Math . sqrt ( Math . pow ( side , 2 ) + Math . pow ( side / 2 , 2 ) ) ; let c = Math . sqrt ( Math . pow ( side , 2 ) + Math . pow ( side / 2 , 2 ) ) ; let s = ( a + b + c ) / 2 ; let area = Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; return area . toFixed ( 1 ) ; }
function interceptLength ( a , b , c , i , j , k ) { let rad = radius ( a , b , c ) ; let dist = centerDistanceFromLine ( a , b , i , j , k ) ; if ( rad < 0 dist < 0 ) { document . write ( "circle▁not▁possible" ) ; return ; } if ( dist > rad ) { document . write ( "Line▁not▁cutting▁circle" ) ; } else document . write ( 2 * Math . sqrt ( rad * rad - dist * dist ) ) ; }
function centralPoints ( arr , N ) { let count = 0 ; let c1 , c2 , c3 , c4 ; for ( let i = 0 ; i < N ; i ++ ) { c1 = 0 ; c2 = 0 ; c3 = 0 ; c4 = 0 ; let x = arr [ i ] [ 0 ] ; let y = arr [ i ] [ 1 ] ; for ( let j = 0 ; j < N ; j ++ ) { if ( arr [ j ] [ 0 ] > x && arr [ j ] [ 1 ] == y ) { c1 = 1 ; } if ( arr [ j ] [ 1 ] > y && arr [ j ] [ 0 ] == x ) { c2 = 1 ; } if ( arr [ j ] [ 0 ] < x && arr [ j ] [ 1 ] == y ) { c3 = 1 ; } if ( arr [ j ] [ 1 ] < y && arr [ j ] [ 0 ] == x ) { c4 = 1 ; } } if ( c1 + c2 + c3 + c4 == 4 ) { count ++ ; } } return count ; }
function printMatrixDiagonal ( arr , len ) { let i = 0 , j = 0 ; let isUp = true ; for ( let k = 0 ; k < len * len ; ) { if ( isUp ) { for ( ; i >= 0 && j < len ; i -- , j ++ ) { document . write ( arr [ i ] [ j ] + "▁" ) ; k ++ ; } if ( i < 0 && j < len ) i = 0 ; if ( j === len ) i = i + 2 , j -- ; } else { for ( ; j >= 0 && i < len ; i ++ , j -- ) { document . write ( arr [ i ] [ j ] + "▁" ) ; k ++ ; } if ( j < 0 && i < len ) j = 0 ; if ( i === len ) j = j + 2 , i -- ; } isUp = ! isUp } }
function calculateSideLength ( L , N , K ) { let angle = findInteriorAngle ( N ) ; let length = L * Math . pow ( Math . sin ( angle / 2 ) , ( K - 1 ) ) ; return length ; }
function minimumTriangleArea ( a , b ) { var area = a * b console . log ( area ) }
function finalPosition ( a , b , M ) { let n = 0 , s = 0 , e = 0 , w = 0 ; let p = "N" ; for ( let i = 0 ; i < M ; i ++ ) { if ( p == "N" ) { if ( a [ i ] == "U" ) { p = "N" ; n = n + b [ i ] ; } else if ( a [ i ] == "D" ) { p = "S" ; s = s + b [ i ] ; } else if ( a [ i ] == "R" ) { p = "E" ; e = e + b [ i ] ; } else if ( a [ i ] == "L" ) { p = "W" ; w = w + b [ i ] ; } } else if ( p == "S" ) { if ( a [ i ] == "U" ) { p = "S" ; s = s + b [ i ] ; } else if ( a [ i ] == "D" ) { p = "N" ; n = n + b [ i ] ; } else if ( a [ i ] == "R" ) { p = "W" ; w = w + b [ i ] ; } else if ( a [ i ] == "L" ) { p = "E" ; e = e + b [ i ] ; } } else if ( p == "E" ) { if ( a [ i ] == "U" ) { p = "E" ; e = e + b [ i ] ; } else if ( a [ i ] == "D" ) { p = "W" ; w = w + b [ i ] ; } else if ( a [ i ] == "R" ) { p = "S" ; s = s + b [ i ] ; } else if ( a [ i ] == "L" ) { p = "N" ; n = n + b [ i ] ; } } else if ( p == "W" ) { if ( a [ i ] == "U" ) { p = "W" ; w = w + b [ i ] ; } else if ( a [ i ] == "D" ) { p = "E" ; e = e + b [ i ] ; } else if ( a [ i ] == "R" ) { p = "N" ; n = n + b [ i ] ; } else if ( a [ i ] == "L" ) { p = "S" ; s = s + b [ i ] ; } } } let ver_disp = n - s ; let hor_disp = e - w ; let displacement = Math . ceil ( Math . sqrt ( ( ver_disp * ver_disp ) + ( hor_disp * hor_disp ) ) ) ; document . write ( displacement + "▁" + p ) ; }
function findPairs ( x , y , K ) { let n = x . length ; let ans = 0 ; for ( let i = 0 ; i < n ; ++ i ) { for ( let j = i + 1 ; j < n ; ++ j ) { if ( K * Math . abs ( x [ i ] - x [ j ] ) >= Math . abs ( y [ i ] - y [ j ] ) ) { ++ ans ; } } } document . write ( ans ) ; }
function pyramidSlantHeight ( pyramid_h , pyramid_s ) { var slant_height_pyramid = Math . sqrt ( Math . pow ( pyramid_s / 2 , 2 ) + Math . pow ( pyramid_h , 2 ) ) ; document . write ( "Slant▁height▁of▁pyramid▁is:▁" + slant_height_pyramid . toFixed ( 5 ) ) ; }
function Area_Parallelogram2 ( a , b , gamma ) { let area = ( Math . abs ( Math . sin ( toRadians ( gamma ) ) ) ) * Math . abs ( a * b ) ; return area ; }
function No_of_rectangles ( L , B , l , b ) { if ( ( l > L ) || ( b > B ) ) { return - 1 ; } else { return ( L - l + 1 ) * ( B - b + 1 ) ; } }
function Area_of_Rhombus ( a , theta ) { var area = ( a ** 2 ) * Math . sin ( theta * Math . PI / 180 ) ; return area ; }
function nCr ( n , r ) { return ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) ; }
function distanceEndpoints ( a , b , c ) { var angle = cal_cos ( c ) ; return Math . sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; }
function perpenBisectorFromLine ( P , Q , a , b , c ) { let mid_point = new point ( ) ; mid_point . x = ( P . x + Q . x ) / 2 ; mid_point . y = ( P . y + Q . y ) / 2 ; c = - b * ( mid_point . x ) + a * ( mid_point . y ) ; let temp = a ; a = - b ; b = temp ; }
function circlearea ( R ) { if ( R < 0 ) return - 1 ; var a = 3.14 * R * R / 4 ; return a ; }
function countIntersections ( n ) { return n * ( n - 1 ) / 2 ; }
function area ( d1 , a ) { var d2 = Math . sqrt ( 4 * ( a * a ) - d1 * d1 ) ; var area = 0.5 * d1 * d2 ; return area ; }
function areaOfKite ( d1 , d2 ) { var area = ( d1 * d2 ) / 2 ; return area ; }
function findTriangles ( n ) { var num ; num = n * ( n - 4 ) ; document . write ( num ) ; }
function countNegative ( M , n , m ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }
function normal ( m , n ) { var N = ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ) ; return N ; }
function isPossible ( a , n ) { let sum = 0 , maxS = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; maxS = Math . max ( a [ i ] , maxS ) ; } if ( ( sum - maxS ) > maxS ) return true ; return false ; }
function pointIsOnLine ( m , c , x , y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
function polyarea ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; var A = ( a * a * n ) / ( 4 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; }
function heptdiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.802 * a ; return d ; }
function trianglearea ( a ) { if ( a < 0 ) return - 1 ; var area = ( 3 * Math . sqrt ( 3 ) * Math . pow ( a , 2 ) ) / 4 ; return area . toFixed ( 4 ) ; }
function circle_equation ( x1 , y1 , r ) { let a = - 2 * x1 ; let b = - 2 * y1 ; let c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; document . write ( "x^2▁+▁(" + a + "▁x)▁+▁" ) ; document . write ( "y^2▁+▁(" + b + "▁y)▁=▁" ) ; document . write ( c + "." ) ; }
function Perimeter ( s , n ) { var perimeter = 1 ; perimeter = n * s ; return perimeter ; }
function dis ( x1 , y1 , x2 , y2 ) { return Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; }
function area ( b , h ) { return ( 1 * b * h ) / 2 ; }
function findRadiusOfIncircle ( a , b , c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; var p = ( a + b + c ) / 2 ; var area = Math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; var radius = area / p ; return radius ; }
function findVolume ( u , v , w , U , V , W , b ) { let uPow = Math . pow ( u , 2 ) ; let vPow = Math . pow ( v , 2 ) ; let wPow = Math . pow ( w , 2 ) ; let UPow = Math . pow ( U , 2 ) ; let VPow = Math . pow ( V , 2 ) ; let WPow = Math . pow ( W , 2 ) ; let a = 4 * ( uPow * vPow * wPow ) - uPow * Math . pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * Math . pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * Math . pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ; let vol = Math . sqrt ( a ) ; vol /= b ; document . write ( vol . toFixed ( 4 ) ) ; }
function rectanglearea ( r ) { if ( r < 0 ) return - 1 ; var a = r * r ; return a ; }
function findMaximumPieces ( n ) { var x = parseInt ( n / 2 ) ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; }
function solve ( M , N , s ) { let ans = Math . floor ( ( ( Math . ceil ( M / s ) ) * ( Math . ceil ( N / s ) ) ) ) ; return ans ; }
function centered_cube ( n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
function center ( x1 , x2 , y1 , y2 ) { document . write ( ( x1 + x2 ) / 2 + ",▁" + ( y1 + y2 ) / 2 ) ; }
function vol_of_octahedron ( side ) { return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) ) ; }
function circumference ( r ) { let cir = 2 * 3.1415 * r ; return cir ; }
function floodFillUtil ( mat , x , y , prevV , newV ) { if ( x < 0 x >= M y < 0 y >= N ) return ; if ( mat [ x ] [ y ] != prevV ) return ; mat [ x ] [ y ] = newV ; floodFillUtil ( mat , x + 1 , y , prevV , newV ) ; floodFillUtil ( mat , x - 1 , y , prevV , newV ) ; floodFillUtil ( mat , x , y + 1 , prevV , newV ) ; floodFillUtil ( mat , x , y - 1 , prevV , newV ) ; }
function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { let distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; let radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
function area ( x1 , y1 , x2 , y2 , x3 , y3 ) { return Math . abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; }
function numberOfDiagonals ( n ) { return n * ( n - 3 ) / 2 ; }
function orientation ( a , b , c ) { let res = ( b [ 1 ] - a [ 1 ] ) * ( c [ 0 ] - b [ 0 ] ) - ( c [ 1 ] - b [ 1 ] ) * ( b [ 0 ] - a [ 0 ] ) ; if ( res == 0 ) return 0 ; if ( res > 0 ) return 1 ; return - 1 ; }
function countLattice ( r ) { if ( r <= 0 ) return 0 ; var result = 4 ; for ( x = 1 ; x < r ; x ++ ) { var ySquare = r * r - x * x ; var y = parseInt ( Math . sqrt ( ySquare ) ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }
function minimumCost ( arr , N , X , Y ) { let even_count = 0 , odd_count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) && ( i % 2 == 0 ) ) { odd_count ++ ; } if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) ) { even_count ++ ; } } let cost1 = X * Math . min ( odd_count , even_count ) ; let cost2 = Y * ( Math . max ( odd_count , even_count ) - Math . min ( odd_count , even_count ) ) ; let cost3 = ( odd_count + even_count ) * Y ; return Math . min ( cost1 + cost2 , cost3 ) ; }
function root ( num , p ) { let left = - num ; let right = num ; let x ; while ( true ) { x = ( left + right ) / 2.0 ; let value = f ( x , p , num ) ; let prime = f_prime ( x , p ) ; if ( value * prime <= 0 ) left = x ; else right = x ; if ( value < 0.000001 && value >= 0 ) { return x ; } } }
function countTriplets ( N ) { let cnt = 0 ; for ( let A = 1 ; A <= N ; ++ A ) { for ( let B = 1 ; B <= N / A ; ++ B ) { cnt += N / ( A * B ) ; } } return cnt ; }
function nearestRight ( arr , N , steps ) { let R = 2 * N ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { R = N + i ; break ; } } for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { R = i ; } steps [ i ] = Math . min ( steps [ i ] , R - i ) ; } }
function updateArray ( arr , K ) { let sum = 0 ; let res = [ ] ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] < K ) { sum += arr [ i ] ; } else { if ( sum != 0 ) { res . push ( sum ) ; } sum = 0 ; res . push ( arr [ i ] ) ; } } if ( sum != 0 ) res . push ( sum ) ; for ( let it of res ) document . write ( it + "▁" ) ; }
function checkSameDigits ( N ) { var digit = N % 10 ; while ( N != 0 ) { var current_digit = N % 10 ; N = parseInt ( N / 10 ) ; if ( current_digit != digit ) { return "No" ; } } return "Yes" ; }
function maxPossibleMoves ( X , Y , A , B ) { let ans = 0 ; let L = 1 , R = MAXN ; while ( L <= R ) { let Mid = Math . floor ( ( L + R ) / 2 ) ; if ( can ( Mid , X , Y , A , B ) ) { L = Mid + 1 ; ans = Math . max ( ans , Mid ) ; } else { R = Mid - 1 ; } } return ans ; }
function possiblePair ( X , Y ) { let Z = Y - X ; if ( Z < 0 ) { document . write ( "-1" ) ; return 0 ; } for ( let k = 0 ; k < MaxBit ; k ++ ) { let bit1 = ( Z >> k ) & 1 ; let bit2 = ( Z >> k ) & 1 ; if ( bit1 && ! bit2 ) { document . write ( "-1" ) ; return 0 ; } } document . write ( Z + "▁" + X ) ; return 0 ; }
function minSumDifference ( ar , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ar [ i ] ; let rem = sum % n ; return rem * ( n - rem ) ; }
function minSteps ( N ) { var res = parseInt ( ( Math . sqrt ( 1 + 8 * N ) - 1 ) / 2 ) ; return res ; }
function oppositeFaceOfDice ( N ) { let ans = 7 - N ; document . write ( ans ) ; }
function IsEvenPath ( Source , Destination ) { let x_dif = Math . abs ( Source [ 0 ] - Destination [ 0 ] ) ; let y_dif = Math . abs ( Source [ 1 ] - Destination [ 1 ] ) ; let minsteps = x_dif + y_dif ; if ( minsteps % 2 == 0 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function findFraction ( x , y , n ) { let A = - 1 , B = - 1 ; for ( let i = 1 ; i <= n ; i ++ ) { let d = Math . floor ( ( i * x ) / y ) ; if ( d >= 0 && ( A == - 1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d ; B = i ; d ++ ; if ( d >= 0 && ( A == - 1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d ; B = i ; } A -- ; B -- ; document . write ( A + "/" + B ) ; }
function countKAverageSubarrays ( arr , n , k ) { let res = 0 ; for ( let L = 0 ; L < n ; L ++ ) { let sum = 0 ; for ( let R = L ; R < n ; R ++ ) { sum += arr [ R ] ; let len = R - L + 1 ; if ( sum % len == 0 ) { let avg = sum / len ; if ( avg == k ) res ++ ; } } } return res ; }
function power ( x , y ) { let res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }
function numberOfPairs ( N , arr ) { adj = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { adj . push ( [ ] ) ; } for ( let i = 0 ; i < arr . length ; i ++ ) { adj [ arr [ i ] [ 0 ] ] . push ( arr [ i ] [ 1 ] ) ; adj [ arr [ i ] [ 1 ] ] . push ( arr [ i ] [ 0 ] ) ; } visited = new Array ( N ) ; visited . fill ( false ) ; let v = [ ] ; num = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( ! visited [ i ] ) { dfs ( i ) ; v . push ( num ) ; num = 0 ; } } let ans = N * ( N - 1 ) / 2 ; for ( let i = 0 ; i < v . length ; i ++ ) { ans -= ( v [ i ] * ( v [ i ] - 1 ) / 2 ) ; } document . write ( ans ) ; }
function isPossible ( W , B , D ) { if ( W > B ) { let temp = W ; W = B ; B = temp ; } if ( B > W * ( D + 1 ) ) document . write ( "NO" ) ; else document . write ( "YES" ) ; }
function tripletAndSum ( arr , n ) { let ans = 0 ; for ( let bit = 0 ; bit < 32 ; bit ++ ) { let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & ( 1 << bit ) ) cnt ++ ; } ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) / 6 ; } return ans ; }
function largestK ( A , N ) { let l = 0 , r = N - 1 , flag = 0 ; while ( l < r ) { if ( A [ l ] != A [ r ] ) { flag = 1 ; break ; } l ++ ; r -- ; } if ( flag == 0 ) return - 1 ; let K = Math . abs ( A [ 0 ] - A [ N - 1 ] ) ; for ( let i = 1 ; i < N / 2 ; i ++ ) K = gcd ( K , Math . abs ( A [ i ] - A [ N - i - 1 ] ) ) ; return K ; }
function NumberofSets ( N ) { SieveOfEratosthenes ( N ) ; if ( N == 2 ) { document . write ( 1 ) ; } else if ( N == 3 ) { document . write ( 2 ) ; } else { let ans = 1 ; for ( let i = Math . floor ( N / 2 ) + 1 ; i <= N ; i ++ ) { if ( prime [ i ] ) { ans += 1 ; } } document . write ( ans ) ; } }
function sumOfDivisors ( N ) { return N ; }
function findDigit ( N , D ) { while ( N > 0 ) { let a = N % 10 ; if ( a == D ) { return true ; } N = Math . floor ( N / 10 ) ; } return false ; }
function findXORS ( arr1 , arr2 , N , M ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { let temp = arr1 [ i ] & arr2 [ j ] ; res ^= temp ; } } return res ; }
function findMedian ( root , node1 , node2 ) { getIntermediateNodes ( root , node1 , node2 ) ; let nSize = interNodes . length ; return ( nSize % 2 == 1 ) ? interNodes [ parseInt ( nSize / 2 , 10 ) ] : ( interNodes [ parseInt ( ( nSize - 1 ) / 2 , 10 ) ] + interNodes [ nSize / 2 ] ) / 2 ; }
function findDifference ( N ) { let s = Array . from ( { length : N + 1 } , ( _ , i ) => 0 ) ; sieveOfEratosthenes ( N , s ) ; let total = 1 , odd = 1 , even = 0 ; let curr = s [ N ] ; let cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } if ( curr == 2 ) { total = total * ( cnt + 1 ) ; } else { total = total * ( cnt + 1 ) ; odd = odd * ( cnt + 1 ) ; } curr = s [ N ] ; cnt = 1 ; } even = total - odd ; document . write ( Math . abs ( even - odd ) ) ; }
function countPrime ( n ) { var prime = new Array ( n + 1 ) ; var x = new Boolean ( true ) ; prime . fill ( x ) ; SieveOfEratosthenes ( n , prime ) ; var dp = new Array ( n + 1 ) ; dp . fill ( 0 ) ; dp [ 1 ] = 0 ; for ( var i = 2 ; i <= n ; i ++ ) { dp [ i ] += dp [ i - 1 ] ; if ( prime [ i ] == Boolean ( true ) && prime [ i - 2 ] == Boolean ( true ) ) { dp [ i ] ++ ; } } document . write ( dp [ n ] ) ; }
function findGCD ( a , b ) { if ( b == 0 ) return a ; return findGCD ( b , a % b ) ; }
function findLCM ( a , b ) { return ( a * b ) / findGCD ( a , b ) ; }
function convert ( p ) { let ans = 0 ; for ( let i of p ) { ans = ( ans << 1 ) | i ; } return ans ; }
function check ( Adj , Src , N , visited ) { let color = new Array ( N ) ; visited [ Src ] = true ; let q = [ ] ; q . push ( Src ) ; while ( q . length != 0 ) { let u = q . shift ( ) ; let Col = color [ u ] ; for ( let x = 0 ; x < Adj [ u ] . length ; x ++ ) { if ( visited [ Adj [ u ] [ x ] ] == true && color [ Adj [ u ] [ x ] ] == Col ) { return false ; } else if ( visited [ Adj [ u ] [ x ] ] == false ) { visited [ Adj [ u ] [ x ] ] = true ; q . push ( Adj [ u ] [ x ] ) ; color [ Adj [ u ] [ x ] ] = 1 - Col ; } } } return true ; }
function average ( arr , N ) { var sum = 0 ; for ( var i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum > 2147483647 ) { sum = - 2147483647 + ( sum - 2147483649 ) } return parseInt ( sum / N ) ; }
function checkWinner ( arr , N ) { let diff = 0 ; for ( let i = 0 ; i < N ; i ++ ) { diff -= arr [ i ] ; } if ( diff % 2 == 0 ) { document . write ( "A" ) ; } else { document . write ( "B" ) ; } }
function countAPs ( S , D ) { S = S * 2 ; let answer = 0 ; for ( let i = 1 ; i <= Math . sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { if ( ( ( S / i ) - D * i + D ) % 2 == 0 ) answer ++ ; if ( ( D * i - ( S / i ) + D ) % 2 == 0 ) answer ++ ; } } return answer ; }
function buildSieve ( ) { for ( i = 2 ; i < 100 ; i ++ ) sieve [ i ] = 1 ; for ( i = 2 ; i < 100 ; i ++ ) { if ( sieve [ i ] == 1 ) { for ( j = i * i ; j < 100 ; j += i ) sieve [ j ] = 0 ; } } }
function countPrimeFactors ( n ) { var count = 0 ; while ( n % 2 == 0 ) { n = parseInt ( n / 2 ) ; count ++ ; } for ( i = 3 ; i <= parseInt ( Math . sqrt ( n ) ) ; i = i + 2 ) { while ( n % i == 0 ) { n = parseInt ( n / i ) ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; }
function numOfPairs ( arr , N ) { let count = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( coprime ( parseInt ( arr [ i ] ) , parseInt ( arr [ j ] ) ) ) { count = count + 1 ; } } } return count ; }
function countPairs ( arr , N ) { var freq = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( freq . has ( parseInt ( Math . log2 ( arr [ i ] ) ) ) ) { freq . set ( parseInt ( Math . log2 ( arr [ i ] ) ) , freq . get ( parseInt ( Math . log2 ( arr [ i ] ) ) ) + 1 ) ; } else { freq . set ( parseInt ( Math . log2 ( arr [ i ] ) ) , 1 ) ; } } var pairs = 0 ; freq . forEach ( ( value , key ) => { pairs += value - 1 ; } ) ; return pairs ; }
function sumOfDigits ( N ) { let sum = 0 ; while ( N != 0 ) { sum += N % 10 ; N = parseInt ( N / 10 , 10 ) ; } return sum ; }
