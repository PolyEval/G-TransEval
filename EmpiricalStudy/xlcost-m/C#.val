void sumOfTwoPerfectCubes ( int N ) { Dictionary < int , int > cubes = new Dictionary < int , int > ( ) ; for ( int i = 1 ; i * i * i <= N ; i ++ ) cubes . Add ( ( i * i * i ) , i ) ; var val = cubes . Keys . ToList ( ) ; foreach ( var key in val ) { int firstNumber = cubes [ 1 ] ; int secondNumber = N - cubes [ 1 ] ; if ( cubes . ContainsKey ( secondNumber ) ) { Console . Write ( "True" ) ; return ; } } Console . Write ( "False" ) ; }
void SieveOfEratosthenes ( int N ) { Array . Fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= N ; i += p ) prime [ i ] = false ; } } }
void checksubarrayExist1_N ( int [ ] arr , int N ) { Dictionary < int , int > pos = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { pos [ arr [ i ] ] = i ; } HashSet < int > st = new HashSet < int > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { st . Add ( pos [ i ] ) ; int Min = st . Min ( ) ; int Max = st . Max ( ) ; if ( Max - Min + 1 == i ) { Console . Write ( "True " ) ; } else { Console . Write ( "False " ) ; } } }
void reverseCircularArray ( int [ ] arr , int N , int K ) { int start = K , end = K - 1 ; int count = N / 2 ; while ( count != 0 ) { int temp = arr [ start % N ] ; arr [ start % N ] = arr [ end % N ] ; arr [ end % N ] = temp ; start ++ ; end -- ; if ( end == - 1 ) { end = N - 1 ; } count -= 1 ; } printArray ( arr , N ) ; }
void XOR_for_every_i ( int [ ] A , int N ) { int [ ] frequency_of_bits = new int [ 32 ] ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int M = A [ i ] ; while ( M != 0 ) { if ( ( M & 1 ) != 0 ) { frequency_of_bits [ bit_position ] += 1 ; } bit_position += 1 ; M >>= 1 ; } } for ( int i = 0 ; i < N ; i ++ ) { int M = A [ i ] ; int value_at_that_bit = 1 ; int XOR_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( ( M & 1 ) != 0 ) { XOR_sum += ( N - frequency_of_bits [ bit_position ] ) * value_at_that_bit ; } else { XOR_sum += ( frequency_of_bits [ bit_position ] ) * value_at_that_bit ; } M >>= 1 ; value_at_that_bit <<= 1 ; } Console . Write ( XOR_sum + " " ) ; } return ; }
void findSum ( int a , int b , int n ) { if ( n == 1 ) { Console . WriteLine ( a ) ; return ; } int s = a + b ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int x = a ^ b ; s += x ; a = b ; b = x ; } Console . WriteLine ( s ) ; }
int countNumbersUtil ( int N ) { int count = 0 ; List < int > digits = new List < int > ( ) ; while ( N > 0 ) { digits . Add ( N % 10 ) ; N /= 10 ; } digits . Reverse ( ) ; int D = digits . Count ; for ( int i = 1 ; i <= D ; i ++ ) { int res = getPower ( i ) ; if ( i == D ) { for ( int p = 1 ; p <= D ; p ++ ) { int x = digits [ p - 1 ] ; int tmp = 0 ; if ( p % 2 == 0 ) { tmp = ( 5 - ( x / 2 + 1 ) ) * getPower ( D - p ) ; } else { tmp = ( 5 - ( x + 1 ) / 2 ) * getPower ( D - p ) ; } res -= tmp ; if ( p % 2 != x % 2 ) { break ; } } } count += res ; } return count ; }
int array_sum ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
bool check ( int n ) { return 2 * rev ( n ) == n + 1 ; }
int highestPower ( int n ) { return ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; }
bool isPrimePossible ( int N ) { String s = String . Join ( "" , N ) ; int l = s . Length ; if ( l < 2 ) return false ; for ( int i = 0 ; i < l ; i ++ ) { String str = deleteIth ( s , i ) ; int num = Int32 . Parse ( str ) ; if ( isPrime ( num ) ) return true ; } return false ; }
bool isPerfectSquare ( double x ) { double sr = Math . Sqrt ( x ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int findlcm ( int [ ] arr , int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; return ans ; }
void findAandB ( int n , int k ) { int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( freqCount ( i . ToString ( ) , ( char ) ( k + 48 ) ) == 0 && freqCount ( ( n - i ) . ToString ( ) , ( char ) ( k + 48 ) ) == 0 ) { Console . Write ( "(" + i + ", " + ( n - i ) + ")" ) ; flag = 1 ; break ; } } if ( flag == 0 ) Console . Write ( - 1 ) ; }
int SquareRoot ( int num ) { int count = 0 ; for ( int n = 1 ; n <= num ; n += 2 ) { num = num - n ; count += 1 ; if ( num == 0 ) break ; } return count ; }
void IncrementFactors ( int [ ] count , int val ) { for ( int i = 1 ; i * i <= val ; i ++ ) { if ( val % i == 0 ) { if ( i == val / i ) { count [ i ] ++ ; } else { count [ i ] ++ ; count [ val / i ] ++ ; } } } }
int calcSum ( int k , int n ) { int value = ( k * n * ( n + 1 ) ) / 2 ; return value ; }
void storeDivisors ( int n , List < int > div ) { for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) div . Add ( i ) ; else { div . Add ( i ) ; div . Add ( n / i ) ; } } } }
void sieveSundaram ( ) { bool [ ] marked = new bool [ MAX / 2 + 1 ] ; for ( int i = 1 ; i <= ( Math . Sqrt ( MAX ) - 1 ) / 2 ; i ++ ) { for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) { marked [ j ] = true ; } } primes . Add ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . Add ( 2 * i + 1 ) ; }
int firstDigit ( int n ) { int digits = ( int ) ( Math . Log ( n ) / Math . Log ( 10 ) ) ; n = ( int ) ( n / Math . Pow ( 10 , digits ) ) ; return n ; }
long sumOfSumSeries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
bool isTetradic ( int n ) { if ( ispalindrome ( n ) && isContaindigit ( n ) ) return true ; return false ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
List < int > getRow ( int rowIndex ) { List < int > currow = new List < int > ( ) ; currow . Add ( 1 ) ; if ( rowIndex == 0 ) { return currow ; } List < int > prev = getRow ( rowIndex - 1 ) ; for ( int i = 1 ; i < prev . Count ; i ++ ) { int curr = prev [ i - 1 ] + prev [ i ] ; currow . Add ( curr ) ; } currow . Add ( 1 ) ; return currow ; }
int gonNum360 ( int n ) { return ( 358 * n * n - 356 * n ) / 2 ; }
int gonNum257 ( int n ) { return ( 255 * n * n - 253 * n ) / 2 ; }
void solve ( int n ) { for ( int x = 1 ; x <= Math . Sqrt ( n ) ; x ++ ) { if ( n % x == 0 ) { int small = x ; int big = n / x ; if ( small % 2 == big % 2 ) { int a = ( small + big ) / 2 ; int b = ( big - small ) / 2 ; Console . WriteLine ( a + " " + b ) ; return ; } } } Console . WriteLine ( - 1 ) ; }
bool Is_Practical ( int A ) { ArrayList divisors = new ArrayList ( ) ; divisors = get_divisors ( A ) ; for ( int i = 2 ; i < A ; i ++ ) { if ( Sum_Possible ( divisors , i ) == false ) return false ; } return true ; }
long operation ( int [ ] arr , int N ) { int right = 0 ; int num = 0 ; long ans = 0 ; for ( int left = 0 ; left < N ; left ++ ) { while ( right < N && num + arr [ right ] == ( num ^ arr [ right ] ) ) { num += arr [ right ] ; right ++ ; } ans += right - left ; if ( left == right ) right ++ ; else num -= arr [ left ] ; } return ans ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int findMaxSize ( int [ ] a , int n ) { ArrayList frq = new ArrayList ( n + 1 ) ; for ( int i = 0 ; i <= n ; i ++ ) frq . Add ( 0 ) ; for ( int i = 0 ; i < n ; ++ i ) frq [ a [ i ] ] = ( int ) frq [ a [ i ] ] + 1 ; int maxfrq = int . MinValue ; for ( int i = 0 ; i < frq . Count ; i ++ ) { if ( maxfrq < ( int ) frq [ i ] ) { maxfrq = ( int ) frq [ i ] ; } } int dist = n + 1 ; for ( int i = 0 ; i < frq . Count ; i ++ ) { if ( ( int ) frq [ i ] == 0 ) { dist -- ; } } int ans1 = Math . Min ( maxfrq - 1 , dist ) ; int ans2 = Math . Min ( maxfrq , dist - 1 ) ; int ans = Math . Max ( ans1 , ans2 ) ; return ans ; }
int minCount ( int n ) { int [ ] hasharr = { 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ; if ( n > 69 ) return hasharr [ n % 10 ] ; else { if ( n >= hasharr [ n % 10 ] * 7 ) return ( hasharr [ n % 10 ] ) ; else return - 1 ; } }
long power ( long x , long y , long p ) { long res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
int findMaxSum ( int [ ] A , int [ ] B , int n ) { int [ ] maxArr = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { int X = joinNumbers ( A [ i ] , B [ i ] ) ; int Y = joinNumbers ( B [ i ] , A [ i ] ) ; int mx = Math . Max ( X , Y ) ; maxArr [ i ] = mx ; } int maxAns = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxAns += maxArr [ i ] ; } return maxAns ; }
long SmallestPerfectSquare ( long N ) { long X = ( long ) 1e9 ; long ans ; for ( int i = 1 ; i < Math . Sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { long a = i ; long b = N / i ; if ( ( b - a != 0 ) && ( ( b - a ) % 2 == 0 ) ) { X = Math . Min ( X , ( b - a ) / 2 ) ; } } } if ( X != 1e9 ) ans = X * X ; else ans = - 1 ; return ans ; }
void PrintReverseOrder ( int N ) { for ( int i = N ; i > 0 ; i -- ) Console . Write ( i + " " ) ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int dfs ( int u , List < int > [ ] adj , int [ ] vis ) { vis [ u ] = 1 ; int componentSize = 1 ; foreach ( int it in adj [ u ] ) { if ( vis [ it ] == 0 ) { componentSize += dfs ( it , adj , vis ) ; } } return componentSize ; }
void prefix ( ) { for ( int i = 1 ; i < N ; i ++ ) pref [ i ] = pref [ i - 1 ] + phi [ i ] ; }
void findCo_PrimePaths ( Node root , List < int > path ) { if ( root == null ) return ; path . Add ( root . key ) ; findCo_PrimePaths ( root . left , path ) ; findCo_PrimePaths ( root . right , path ) ; if ( root . left == null && root . right == null ) { if ( isPathCo_Prime ( path ) ) { printCo_PrimePaths ( path ) ; } } path . RemoveAt ( path . Count - 1 ) ; }
void sieve ( ) { position [ 0 ] = - 1 ; position [ 1 ] = - 1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = - 1 ; } } }
string permutation ( int [ ] arr , int N ) { int [ ] hash = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( hash [ i ] != 1 ) return "No" ; } return "Yes" ; }
bool isDivisible ( int n ) { int d ; while ( n / 100 > 0 ) { d = n % 10 ; n /= 10 ; n = Math . Abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; }
int countDigit ( int n ) { bool [ ] prime = new bool [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) prime [ i ] = false ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 && prime [ d ] == true ) count ++ ; } return count ; }
void maxValue ( int a ) { String c = Convert . ToString ( a , 2 ) ; String b = "" ; for ( int i = 0 ; i < c . Length ; i ++ ) { if ( ( c [ i ] - '0' ) == 1 ) b += '0' ; else b += '1' ; } Console . Write ( Convert . ToInt32 ( b , 2 ) ) ; }
int nextFibonacci ( int n ) { double a = n * ( 1 + Math . Sqrt ( 5 ) ) / 2.0 ; return ( int ) Math . Round ( a ) ; }
void preCompute ( ) { for ( int i = 1 ; i < 100001 ; i ++ ) { pref [ i ] = pref [ i - 1 ] + checkArmstrong ( i ) ; } }
void isPrime ( int N ) { bool isPrime = true ; int [ ] arr = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ; if ( N < 2 ) { isPrime = false ; } if ( N % 2 == 0 N % 3 == 0 N % 5 == 0 ) { isPrime = false ; } for ( int i = 0 ; i < ( int ) Math . Sqrt ( N ) ; i += 30 ) { foreach ( int c in arr ) { if ( c > ( int ) Math . Sqrt ( N ) ) { break ; } else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } } if ( ! isPrime ) break ; } } if ( isPrime ) Console . WriteLine ( "Prime Number" ) ; else Console . WriteLine ( "Not a Prime Number" ) ; }
void perfectCube ( int N ) { int cube ; for ( int i = 0 ; i <= N ; i ++ ) { cube = i * i * i ; if ( cube == N ) { Console . WriteLine ( "Yes" ) ; return ; } else if ( cube > N ) { Console . WriteLine ( "NO" ) ; return ; } } }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
int count ( int n , int k ) { int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum = sum + binomialCoeff ( n , j ) ; } return sum ; }
int prevPowerofK ( int n , int k ) { int p = ( int ) ( Math . Log ( n ) / Math . Log ( k ) ) ; return ( int ) Math . Pow ( k , p ) ; }
int kth_element ( int [ ] a , int n , int k ) { List < int > pos = new List < int > ( ) ; List < int > neg = new List < int > ( ) ; ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) pos . Add ( a [ i ] ) ; else neg . Add ( a [ i ] ) ; } sort ( pos . begin ( ) , pos . end ( ) ) ; sort ( neg . begin ( ) , neg . end ( ) ) ; pos . Sort ( ) ; neg . Sort ( ) ; int l = ( int ) - 1e8 , ans = 0 , r = ( int ) 1e8 ; while ( l <= r ) { int mid = ( l + r ) >> 1 ; if ( check ( mid , pos , neg , k ) ) { ans = mid ; r = mid - 1 ; } else l = mid + 1 ; } return ans ; }
int nextNumberDistinctDigit ( int n ) { while ( n < INT_MAX ) { int distinct_digits = countDistinct ( n + 1 ) ; int total_digits = countDigit ( n + 1 ) ; if ( distinct_digits == total_digits ) { return n + 1 ; } else n ++ ; } return - 1 ; }
int Count_subarray ( int [ ] arr , int n ) { int total_sum = 0 , subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { subarray_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ; if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; }
double getSum ( int n ) { double sum = 0 ; if ( n == 1 ) { sum = 45.0 ; } else { sum = ( 99.0 / 2.0 ) * Math . Pow ( 10 , n - 1 ) * Math . Pow ( 10 , ( n - 1 ) / 2 ) ; } return sum ; }
int getSize ( Node a ) { int sz = 0 ; while ( a != null ) { a = a . next ; sz ++ ; } return sz ; }
int diameter ( int n ) { int L , H ; L = 1 ; H = 0 ; if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; } while ( L * 2 <= n ) { L *= 2 ; H ++ ; } if ( n >= L * 2 - 1 ) return 2 * H + 1 ; else if ( n >= L + ( L / 2 ) - 1 ) return 2 * H ; return 2 * H - 1 ; }
int countSquares ( int n ) { return ( int ) ( Math . Pow ( n , 2 ) - ( 2 * n ) + 2 ) ; }
void max_element ( int [ ] a , int n ) { int [ ] pre = new int [ n ] ; pre [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = Math . Max ( pre [ i - 1 ] , a [ i ] ) ; int [ ] suf = new int [ n ] ; suf [ n - 1 ] = a [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = Math . Max ( suf [ i + 1 ] , a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) Console . Write ( suf [ i + 1 ] + " " ) ; else if ( i == n - 1 ) Console . Write ( pre [ i - 1 ] + " " ) ; else Console . Write ( Math . Max ( pre [ i - 1 ] , suf [ i + 1 ] ) + " " ) ; } }
int cntCells ( int n ) { int cells = ( int ) Math . Pow ( n , 2 ) + ( int ) Math . Pow ( n - 1 , 2 ) ; return cells ; }
void findNums ( int n ) { if ( n <= 11 ) { if ( n == 8 ) Console . Write ( "4 4" ) ; if ( n == 10 ) Console . Write ( "4 6" ) ; else Console . Write ( "-1" ) ; return ; } if ( n % 2 == 0 ) Console . Write ( "4 " + ( n - 4 ) ) ; else Console . Write ( "9 " + ( n - 9 ) ) ; }
int oddFib ( int n ) { n = ( 3 * n + 1 ) / 2 ; int a = - 1 , b = 1 , c = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n == 2 n == 3 ) return true ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int difference ( int n ) { int S , res ; S = ( n * ( n + 1 ) ) / 2 ; res = S * ( S - 1 ) ; return res ; }
long findSmallestNonZeroY ( long A_num ) { String A_binary = Convert . ToString ( A_num , 2 ) ; long B = 1 ; int len = A_binary . Length ; int no_ones = bitCount ( A_num ) ; if ( len == no_ones ) { return A_num + 1 ; } for ( int i = 0 ; i < len ; i ++ ) { char ch = A_binary [ len - i - 1 ] ; if ( ch == '0' ) { B = ( long ) Math . Pow ( 2.0 , ( double ) i ) ; break ; } } return B ; }
int minimum_elements ( int n , int [ ] arr ) { if ( n < 3 ) return 0 ; int g , ans = 0 , diff , cnt ; diff = arr [ 1 ] - arr [ 0 ] ; g = diff ; for ( int i = 2 ; i < n ; i ++ ) { diff = arr [ i ] - arr [ i - 1 ] ; g = gcd ( g , diff ) ; } for ( int i = 1 ; i < n ; i ++ ) { diff = arr [ i ] - arr [ i - 1 ] ; cnt = diff / g ; ans += ( cnt - 1 ) ; } return ans ; }
void Digits ( int n ) { int largest = 0 ; int smallest = 9 ; while ( n != 0 ) { int r = n % 10 ; largest = Math . Max ( r , largest ) ; smallest = Math . Min ( r , smallest ) ; n = n / 10 ; } Console . WriteLine ( largest + " " + smallest ) ; }
int countWords ( int N , int M ) { return ( int ) Math . Pow ( N , M ) - nPr ( N , M ) ; }
int countBits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n >>= 1 ; } return count ; }
int sum_of_4_squares ( int n ) { int i , odd = 0 , even = 0 ; for ( i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i % 2 == 0 ) even += i ; else odd += i ; if ( ( n / i ) != i ) { if ( ( n / i ) % 2 == 0 ) even += ( n / i ) ; else odd += ( n / i ) ; } } } if ( n % 2 == 1 ) return 8 * ( odd + even ) ; else return 24 * ( odd ) ; }
int Maximum_Length ( List < int > a ) { int [ ] counts = new int [ 11 ] ; int ans = 0 ; for ( int index = 0 ; index < a . Count ; index ++ ) { counts [ a [ index ] ] += 1 ; List < int > k = new List < int > ( ) ; foreach ( int i in counts ) if ( i != 0 ) k . Add ( i ) ; k . Sort ( ) ; if ( k . Count == 1 || ( k [ 0 ] == k [ k . Count - 2 ] && k [ k . Count - 1 ] - k [ k . Count - 2 ] == 1 ) || ( k [ 0 ] == 1 && k [ 1 ] == k [ k . Count - 1 ] ) ) ans = index ; } return ans + 1 ; }
int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; }
int countX ( int a , int b ) { if ( b > a ) return 0 ; else if ( a == b ) return - 1 ; else { int x = a - b , ans = 0 ; for ( int i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { int d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = x / i ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } }
bool isSafe ( int N , int M , char [ ] str ) { int coll = 0 , colr = 0 , rowu = 0 , rowd = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == 'L' ) { coll ++ ; if ( colr > 0 ) { colr -- ; } if ( coll == M ) { break ; } } else if ( str [ i ] == 'R' ) { colr ++ ; if ( coll > 0 ) { coll -- ; } if ( colr == M ) { break ; } } else if ( str [ i ] == 'U' ) { rowu ++ ; if ( rowd > 0 ) { rowd -- ; } if ( rowu == N ) { break ; } } else if ( str [ i ] == 'D' ) { rowd ++ ; if ( rowu > 0 ) { rowu -- ; } if ( rowd == N ) { break ; } } } if ( Math . Abs ( rowd ) < N && Math . Abs ( rowu ) < N && Math . Abs ( coll ) < M && Math . Abs ( colr ) < M ) { return true ; } return false ; }
int countOnes ( int [ ] arr , int N ) { for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i ; j <= N ; j ++ ) { if ( j % i == 0 ) { if ( arr [ j - 1 ] == 0 ) { } else { } } } } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) { } } return count ; }
long power ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int findSum ( int num ) { int sumo = 0 ; int sume = 0 ; int x = 1 ; int cur = 0 ; int ans = 0 ; while ( num > 0 ) { int inc = Math . Min ( x , num ) ; num -= inc ; if ( cur == 0 ) { ans = ans + sumodd ( sumo + inc ) - sumodd ( sumo ) ; sumo += inc ; } else { ans = ans + sumeven ( sume + inc ) - sumeven ( sume ) ; sume += inc ; } x *= 2 ; cur ^= 1 ; } return ans ; }
float noOfYears ( int t1 , int n1 , int t2 ) { float years = ( ( t2 - 1 ) * n1 / ( float ) ( t1 - 1 ) ) ; return years ; }
bool isPossible ( int n ) { int [ ] fac = new int [ 10 ] ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( int i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; int sum = 0 ; int x = n ; while ( x != 0 ) { sum += fac [ x % 10 ] ; x /= 10 ; } if ( sum % n == 0 ) return true ; return false ; }
int countSquares ( int r , int c , int m ) { int squares = 0 ; for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) { if ( Math . Max ( Math . Abs ( i - r ) , Math . Abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; }
int minOperations ( int n , int m ) { if ( m % n != 0 ) return - 1 ; int minOperations = 0 ; int q = m / n ; while ( q % 2 == 0 ) { q = q / 2 ; minOperations ++ ; } while ( q % 3 == 0 ) { q = q / 3 ; minOperations ++ ; } if ( q == 1 ) return minOperations ; return - 1 ; }
int getCount ( int a , int b , int c ) { int count = 0 ; for ( int i = 1 ; i <= 81 ; i ++ ) { int cr = b * ( int ) Math . Pow ( i , a ) + c ; int tmp = cr ; int sm = 0 ; while ( tmp != 0 ) { sm += tmp % 10 ; tmp /= 10 ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; }
bool checkSpecialPrime ( bool [ ] sieve , int num ) { while ( num > 0 ) { if ( sieve [ num ] ) { return false ; } num /= 10 ; } return true ; }
bool canTakeDown ( int bishopX , int bishopY , int pawnX , int pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }
bool isPossible ( int n , int k , int [ ] arr ) { int sum = arr [ 0 ] ; int maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = Math . Max ( maxVal , arr [ i ] ) ; } if ( ( float ) maxVal > ( float ) ( sum + k ) / n ) return false ; return true ; }
bool checkTriangularSumRepresentation ( int n ) { HashSet < int > tri = new HashSet < int > ( ) ; int i = 1 ; while ( true ) { int x = i * ( i + 1 ) / 2 ; if ( x >= n ) { break ; } tri . Add ( x ) ; i ++ ; } foreach ( int tm in tri ) { if ( tri . Contains ( n - tm ) ) { return true ; } } return false ; }
void secondary_polygon ( int Angle ) { int edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { int edges_max_secondary = edges_primary / 2 ; Console . WriteLine ( edges_max_secondary + 3 ) ; } else Console . WriteLine ( "Not Possible" ) ; }
float CPwithProfit ( int sellingPrice , int profit ) { float costPrice ; costPrice = ( sellingPrice * 100 ) / ( 100 + profit ) ; return costPrice ; }
int removeZero ( int n ) { int res = 0 ; int d = 1 ; while ( n > 0 ) { if ( n % 10 != 0 ) { res += ( n % 10 ) * d ; d *= 10 ; } n /= 10 ; } return res ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void ETF ( ) { for ( int i = 1 ; i <= n ; i ++ ) { phi [ i ] = i ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( phi [ i ] == i ) { phi [ i ] = i - 1 ; for ( int j = 2 * i ; j <= n ; j += i ) { phi [ j ] = ( phi [ j ] * ( i - 1 ) ) / i ; } } } }
bool checkIsHP ( double [ ] arr ) { int n = arr . Length ; if ( n == 1 ) return true ; ArrayList rec = new ArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) rec . Add ( ( int ) ( 1 / arr [ i ] ) ) ; rec . Sort ( ) ; int d = ( int ) rec [ 1 ] - ( int ) rec [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( ( int ) rec [ i ] - ( int ) rec [ i - 1 ] != d ) return false ; return true ; }
int Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; }
int solve ( int n , int base1 ) { int sum = 0 ; while ( n > 0 ) { int remainder1 = n % base1 ; sum += remainder1 ; n = n / base1 ; } return sum ; }
void SieveOfEratosthenes ( bool [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
int findEle ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return - 1 ; }
bool divisibleBy3 ( string number ) { int sumOfDigit = 0 ; for ( int i = 0 ; i < number . Length ; i ++ ) sumOfDigit += number [ i ] - '0' ; if ( sumOfDigit % 3 == 0 ) return true ; return false ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
int largestNumber ( int n ) { string s = "" ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ( ( int ) ( s [ i ] - '0' ) % 2 & 1 ) == 0 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; int num = 0 ; for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( int ) ( s [ i ] - '0' ) ; num = num * 10 + ( ( int ) s [ index ] - ( int ) ( '0' ) - 1 ) ; for ( int i = index + 1 ; i < s . Length ; i ++ ) num = num * 10 + 9 ; return num ; }
void Sum_upto_nth_Term ( int n ) { int r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; Console . Write ( r ) ; }
int get_unit_digit ( int N ) { if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ; return 3 ; }
void SieveOfEratosthenes ( ) { Boolean [ ] prime = new Boolean [ MAX ] ; for ( int p = 0 ; p < MAX ; p ++ ) prime [ p ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { product = product * p ; s . Add ( product + 1 ) ; } } }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
long findF_N ( long n ) { long ans = 0 ; for ( long i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * ( n - i - 1 ) ; return ans ; }
List < int > PrimeFactors ( int n ) { List < int > v = new List < int > ( ) ; int x = n ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( x % i == 0 ) { v . Add ( i ) ; while ( x % i == 0 ) x /= i ; } } if ( x > 1 ) v . Add ( x ) ; return v ; }
void computeSemiPrime ( ) { for ( int i = 0 ; i < MAX ; i ++ ) sprime [ i ] = false ; for ( int i = 2 ; i < MAX ; i ++ ) { int cnt = 0 ; int num = i ; for ( int j = 2 ; cnt < 2 && j * j <= num ; ++ j ) { while ( num % j == 0 ) { num /= j ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; if ( cnt == 2 ) { sprime [ i ] = true ; arr . Add ( i ) ; } } }
double sumProductDifference ( int a , int b , int c , int d , int e ) { double rootSum = ( double ) ( - 1 * b ) / a ; double rootProduct = ( double ) e / a ; return Math . Abs ( rootSum - rootProduct ) ; }
double findAnglesA ( double a , double b , double c ) { double A = Math . Acos ( ( b * b + c * c - a * a ) / ( 2 * b * c ) ) ; return A * 180 / PI ; }
double findAnglesB ( double a , double b , double c ) { double B = Math . Acos ( ( a * a + c * c - b * b ) / ( 2 * a * c ) ) ; return B * 180 / PI ; }
bool isPerfectSquare ( double x ) { double sr = Math . Sqrt ( x ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ; }
int findSum ( int N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }
bool isPower ( int a ) { if ( a == 1 ) { return true ; } for ( int i = 2 ; i * i <= a ; i ++ ) { double val = Math . Log ( a ) / Math . Log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) { return true ; } } return false ; }
int mostFrequent ( int [ ] arr , int n ) { Dictionary < int , int > hp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int key = arr [ i ] ; if ( hp . ContainsKey ( key ) ) { int freq = hp [ key ] ; freq ++ ; hp [ key ] = freq ; } else hp . Add ( key , 1 ) ; } int min_count = 0 , res = - 1 ; foreach ( KeyValuePair < int , int > pair in hp ) { if ( min_count < pair . Value ) { res = pair . Key ; min_count = pair . Value ; } } return res ; }
int Profit ( int costPrice , int sellingPrice ) { int profit = ( sellingPrice - costPrice ) ; return profit ; }
int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; }
bool isPrime ( int num ) { if ( num < 2 num % 2 == 0 ) return num == 2 ; for ( int i = 3 ; i * i <= num ; i += 2 ) if ( num % i == 0 ) return false ; return true ; }
void value ( int a , int b , int c ) { int no , x = 0 , q = 0 , w = 0 ; List < int > v = new List < int > ( ) ; for ( int i = 1 ; i < 82 ; i ++ ) { no = ( int ) Math . Pow ( i , a ) ; no = b * no + c ; if ( no > 0 && no < 1000000000 ) { x = getsum ( no ) ; if ( x == i ) { q ++ ; v . Add ( no ) ; w ++ ; } } } for ( int i = 0 ; i < v . Count ; i ++ ) { Console . Write ( v [ i ] + " " ) ; } }
int countOddSum ( int [ ] ar , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int val = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }
void printSeries ( int n ) { long prev = 0 ; long curr ; for ( int i = 1 ; i <= n ; i ++ ) { curr = findTriangularNumber ( i ) ; curr = curr + prev ; Console . Write ( curr + " " ) ; prev = curr ; } }
int rev ( int n , int temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( n / 10 , temp ) ; }
double determinantOfMatrix ( double [ , ] mat ) { double ans ; ans = mat [ 0 , 0 ] * ( mat [ 1 , 1 ] * mat [ 2 , 2 ] - mat [ 2 , 1 ] * mat [ 1 , 2 ] ) - mat [ 0 , 1 ] * ( mat [ 1 , 0 ] * mat [ 2 , 2 ] - mat [ 1 , 2 ] * mat [ 2 , 0 ] ) + mat [ 0 , 2 ] * ( mat [ 1 , 0 ] * mat [ 2 , 1 ] - mat [ 1 , 1 ] * mat [ 2 , 0 ] ) ; return ans ; }
int calculateSeries ( int n ) { return 2 + ( n * n + n - 2 ) * factorial ( n + 1 ) ; }
bool isEmirpimes ( int n ) { if ( checkSemiprime ( n ) == false ) return false ; int r = 0 ; for ( int t = n ; t != 0 ; t = t / n ) r = r * 10 + t % 10 ; if ( r == n ) return false ; return ( checkSemiprime ( r ) ) ; }
int isTriangular ( int num ) { if ( num < 0 ) return 0 ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return - 1 ; double root1 = ( - b + Math . Sqrt ( d ) ) / ( 2 * a ) ; double root2 = ( - b - Math . Sqrt ( d ) ) / ( 2 * a ) ; if ( ( int ) ( root1 ) > 0 && ( int ) ( Math . Floor ( root1 ) ) == ( int ) ( root1 ) ) return ( int ) ( root1 ) ; if ( ( int ) ( root2 ) > 0 && ( int ) ( Math . Floor ( root2 ) ) == ( int ) ( root2 ) ) return ( int ) ( root2 ) ; return - 1 ; }
double calculateProbability ( int N ) { double probability = ( double ) N / ( N + 1 ) ; return probability ; }
int fnMod ( int n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; }
int findHcf ( int [ , ] arr , int size ) { int ans = arr [ 0 , 0 ] ; for ( int i = 1 ; i < size ; i ++ ) ans = gcd ( ans , arr [ i , 0 ] ) ; return ( ans ) ; }
int nthTrimorphic ( int n ) { int count = 0 ; for ( int i = 0 ; i < INT_MAX ; i ++ ) { if ( checkTrimorphic ( i ) ) count ++ ; if ( count == n ) return i ; } return - 1 ; }
bool check ( int n ) { int m = n ; while ( n != 0 ) { int r = n % 10 ; if ( r > 0 ) if ( ( m % r ) != 0 ) return false ; n /= 10 ; } return true ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; }
void generatePrimeFactors ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } }
void quadrant ( int x , int y ) { if ( x > 0 && y > 0 ) Console . WriteLine ( "lies in First quadrant" ) ; else if ( x < 0 && y > 0 ) Console . WriteLine ( "lies in Second quadrant" ) ; else if ( x < 0 && y < 0 ) Console . WriteLine ( "lies in Third quadrant" ) ; else if ( x > 0 && y < 0 ) Console . WriteLine ( "lies in Fourth quadrant" ) ; else if ( x == 0 && y > 0 ) Console . WriteLine ( "lies at positive y axis" ) ; else if ( x == 0 && y < 0 ) Console . WriteLine ( "lies at negative y axis" ) ; else if ( y == 0 && x < 0 ) Console . WriteLine ( "lies at negative x axis" ) ; else if ( y == 0 && x > 0 ) Console . WriteLine ( "lies at positive x axis" ) ; else Console . WriteLine ( "lies at origin" ) ; }
int kthgroupsum ( int k ) { return k * k * k ; }
double kmphTOmph ( double kmph ) { return 0.6214 * kmph ; }
void point ( int a , int b , int c , int d , int n ) { int x , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x = b + i * a ; if ( ( x - d ) % c == 0 && x - d >= 0 ) { Console . WriteLine ( x ) ; flag = 1 ; break ; } } if ( flag == 0 ) { Console . WriteLine ( "No collision point" ) ; } }
int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; }
long isPalindrome ( long n ) { long divide = ( isOctal ( n ) == 0 ) ? 8 : 10 ; long [ ] octal = new long [ MAX_DIGITS ] ; long i = 0 ; while ( n != 0 ) { octal [ i ++ ] = n % divide ; n = n / divide ; } for ( long j = i - 1 , k = 0 ; k <= j ; j -- , k ++ ) if ( octal [ j ] != octal [ k ] ) return 0 ; return 1 ; }
bool isThreeDisctFactors ( long n ) { int sq = ( int ) Math . Sqrt ( n ) ; if ( 1L L * sq * sq != n ) return false ; return isPrime ( sq ) ? true : false ; }
void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) Console . Write ( hexaDeciNum [ j ] ) ; }
int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base1 = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base1 ; base1 = base1 * 2 ; } return dec_value ; }
int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; }
long firstkdigits ( int n , int k ) { long product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product *= n ; while ( ( int ) ( product / Math . Pow ( 10 , k ) ) != 0 ) product = product / 10 ; return product ; }
int countDigits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n / 10 ; } return count ; }
void printGenerators ( int n ) { Console . Write ( "1 " ) ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) Console . Write ( i + " " ) ; }
long SubArraySum ( int [ ] arr , int n ) { long result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; }
void generateNumbers ( int [ ] factor , int n , int k ) { int [ ] next = new int [ k ] ; for ( int i = 0 ; i < n ; ) { int toincrement = 0 ; for ( int j = 0 ; j < k ; j ++ ) if ( next [ j ] < next [ toincrement ] ) toincrement = j ; if ( output != next [ toincrement ] ) { output = next [ toincrement ] ; Console . Write ( next [ toincrement ] + " " ) ; i ++ ; } next [ toincrement ] += factor [ toincrement ] ; } }
int sumofproduct ( int n ) { int ans = 0 ; for ( int x = 1 ; x <= n ; x ++ ) { int y = n / x ; ans += ( y * x ) ; } return ans ; }
void findPrimePair ( int n ) { bool [ ] isPrime = new bool [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime [ i ] && isPrime [ n - i ] ) { Console . Write ( i + " " + ( n - i ) ) ; return ; } } }
long lcm ( long n ) { long ans = 1 ; for ( long i = 1 ; i <= n ; i ++ ) ans = ( ans * i ) / ( gcd ( ans , i ) ) ; return ans ; }
void findSmallestPrimeFactors ( ) { for ( int i = 0 ; i < maxn ; i ++ ) smallest_prime [ i ] = INF ; for ( int i = 2 ; i < maxn ; i ++ ) { if ( smallest_prime [ i ] == INF ) { smallest_prime [ i ] = i ; for ( int j = i * i ; j < maxn ; j += i ) if ( smallest_prime [ j ] > i ) smallest_prime [ j ] = i ; } } }
void prepareSum ( String s ) { sum [ 0 ] = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { sum [ i + 1 ] = sum [ i ] + toInt ( s [ i ] ) ; } }
bool oneDigit ( int num ) { return ( num >= 0 && num < 10 ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
void updateBIT ( int [ ] BITree , int n , int index , int val ) { while ( index <= n ) { BITree [ index ] += val ; index += index & ( - index ) ; } }
int nearestSmallerEqFib ( int n ) { if ( n == 0 n == 1 ) return n ; int f1 = 0 , f2 = 1 , f3 = 1 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; }
int mod ( String num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . Length ; i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % a ; return res ; }
int replace0with5 ( int number ) { return number += calculateAddedValue ( number ) ; }
int findXOR ( int X ) { int ans = 0 ; while ( X != 0 ) { ans ^= ( X % 10 ) ; X /= 10 ; } return ans ; }
int findLen ( int [ ] arr , int n , int m ) { List < int > filter = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] m ) == m ) filter . Add ( arr [ i ] ) ; if ( filter . Count == 0 ) return 0 ; int c_or = filter [ 0 ] ; for ( int i = 1 ; i < filter . Count ; i ++ ) c_or |= filter [ i ] ; if ( c_or == m ) return filter . Count ; return 0 ; }
void Add_Edge ( int x , int y ) { al [ x ] . Add ( y ) ; root_node [ y ] = false ; }
long multiplyByFifteen ( long n ) { long prod = ( n << 4 ) ; prod = prod - n ; return prod ; }
int ternary ( int number ) { int ans = 0 , rem = 1 , b = 1 ; while ( number > 0 ) { rem = number % 3 ; ans = ans + rem * b ; number = ( int ) ( number / 3 ) ; b = b * 10 ; } return ans ; }
void ReplaceElements ( int [ ] arr , int n ) { int X = 0 ; for ( int i = 0 ; i < n ; ++ i ) { X ^= arr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = X ^ arr [ i ] ; } }
int findSubArray ( int [ ] arr , int n ) { int sum = 0 ; int maxsize = - 1 , startindex = 0 ; int endindex = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) Console . WriteLine ( "No such subarray" ) ; else Console . WriteLine ( startindex + " to " + endindex ) ; return maxsize ; }
int BinaryLifting ( int [ ] presum , int n , int x ) { int pos = 0 ; int LOGN = ( int ) Math . Log ( n ) ; if ( x <= presum [ 0 ] ) return 0 ; for ( int i = LOGN ; i >= 0 ; i -- ) { if ( pos + ( 1 << i ) < n && presum [ pos + ( 1 << i ) ] < x ) { pos += ( 1 << i ) ; } } return pos + 1 ; }
int setbitsfromLtoR ( int L , int R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; }
bool isFibbinaryNum ( int n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; }
int oddbitsetnumber ( int n ) { int count = 0 ; int res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
int posOfRightmostSetBit ( int n ) { return ( int ) ( Math . Log ( n & - n ) / Math . Log ( 2 ) ) + 1 ; }
int modifyBit ( int n , int p , int b ) { int mask = 1 << p ; return ( n & ~ mask ) | ( ( b << p ) & mask ) ; }
bool isOnesComplementOfOther ( long a , long b ) { return areAllBitsSet ( a ^ b ) ; }
int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; }
int posOfRightMostSameBit ( int m , int n ) { int loopCounter = 1 ; while ( m > 0 n > 0 ) { Boolean a = m % 2 == 1 ; Boolean b = n % 2 == 1 ; if ( ! ( a ^ b ) ) { return loopCounter ; } m = m >> 1 ; n = n >> 1 ; loopCounter ++ ; } return - 1 ; }
int CountZeroBit ( int n ) { int count = 0 ; while ( n > 0 ) { if ( n % 2 != 0 ) count ++ ; n >>= 1 ; } return count ; }
long countPairsWithKDiff ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int xoredNum = arr [ i ] ^ arr [ j ] ; if ( k == bitCount ( xoredNum ) ) ++ ans ; } } return ans ; }
int countTrailingZero ( int x ) { int [ ] lookup = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; }
int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }
int findXOR ( int [ ] Set , int n ) { if ( n == 1 ) return Set [ 0 ] ; else return 0 ; }
int findFourElements ( int [ ] arr , int n ) { Dictionary < int , Indexes > map = new Dictionary < int , Indexes > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { map . Add ( arr [ i ] + arr [ j ] , new Indexes ( i , j ) ) ; } } int d = int . MinValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = Math . Abs ( arr [ i ] - arr [ j ] ) ; if ( map . ContainsKey ( abs_diff ) ) { Indexes indexes = map [ abs_diff ] ; if ( indexes . getI ( ) != i && indexes . getI ( ) != j && indexes . getJ ( ) != i && indexes . getJ ( ) != j ) { d = Math . Max ( d , Math . Max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; }
void recaman ( int n ) { if ( n <= 0 ) return ; Console . Write ( "{0}, " , 0 ) ; HashSet < int > s = new HashSet < int > ( ) ; s . Add ( 0 ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || s . Contains ( curr ) ) curr = prev + i ; s . Add ( curr ) ; Console . Write ( "{0}, " , curr ) ; prev = curr ; } }
int findMin ( int [ ] arr , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; }
void splitArr ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
void printSmall ( int [ ] arr , int n , int k ) { for ( int i = k ; i < n ; ++ i ) { int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } } if ( max_var > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( int i = 0 ; i < k ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
int findFirstMissing ( int [ ] array , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
int countInRange ( int [ ] arr , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }
int upperIndex ( int [ ] arr , int n , int y ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] <= y ) l = mid + 1 ; else h = mid - 1 ; } return h ; }
virtual void printArray ( int [ ] arr , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } Console . WriteLine ( "" ) ; }
int findPeakUtil ( int [ ] arr , int low , int high , int n ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ; else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return findPeakUtil ( arr , low , ( mid - 1 ) , n ) ; else return findPeakUtil ( arr , ( mid + 1 ) , high , n ) ; }
int maximum ( int a , int b , int c ) { return Math . Max ( Math . Max ( a , b ) , c ) ; }
void printClosest ( int [ ] arr , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = int . MaxValue ; while ( r > l ) { if ( Math . Abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . Abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } Console . Write ( " The closest pair is " + arr [ res_l ] + " and " + arr [ res_r ] ) ; }
bool findPartiion ( int [ ] arr , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool [ ] part = new bool [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = false ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ sum / 2 ] ; }
void solveWordWrap ( int [ ] l , int n , int M ) { int [ , ] extras = new int [ n + 1 , n + 1 ] ; int [ , ] lc = new int [ n + 1 , n + 1 ] ; int [ ] c = new int [ n + 1 ] ; int [ ] p = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { extras [ i , i ] = M - l [ i - 1 ] ; for ( int j = i + 1 ; j <= n ; j ++ ) extras [ i , j ] = extras [ i , j - 1 ] - l [ j - 1 ] - 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( extras [ i , j ] < 0 ) lc [ i , j ] = MAX ; else if ( j == n && extras [ i , j ] >= 0 ) lc [ i , j ] = 0 ; else lc [ i , j ] = extras [ i , j ] * extras [ i , j ] ; } } c [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { c [ j ] = MAX ; for ( int i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != MAX && lc [ i , j ] != MAX && ( c [ i - 1 ] + lc [ i , j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i , j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; }
int optCost ( int [ ] freq , int i , int j ) { if ( j < i ) return 0 ; if ( j == i ) return freq [ i ] ; int fsum = sum ( freq , i , j ) ; int min = int . MaxValue ; for ( int r = i ; r <= j ; ++ r ) { int cost = optCost ( freq , i , r - 1 ) + optCost ( freq , r + 1 , j ) ; if ( cost < min ) min = cost ; } return min + fsum ; }
int minCoins ( int [ ] coins , int m , int V ) { if ( V == 0 ) return 0 ; int res = int . MaxValue ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != int . MaxValue && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }
int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; }
int maximumNumberDistinctPrimeRange ( int m , int n ) { long [ ] factorCount = new long [ n + 1 ] ; bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( int j = i * 2 ; j <= n ; j += i ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } } int max = ( int ) factorCount [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = ( int ) factorCount [ i ] ; num = i ; } } return num ; }
int getSingle ( int [ ] arr , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & x ) == 0 ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; }
int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { bool k = false ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { if ( k == true ) ans += 1 ; else ans += 0 ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
int swapBits ( int x , int p1 , int p2 , int n ) { int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; int result = x ^ xor ; return result ; }
int minSwaps ( int n , int [ ] pairs , int [ ] arr ) { int [ ] index = new int [ 2 * n + 1 ] ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { index [ arr [ i ] ] = i ; } return minSwapsUtil ( arr , pairs , index , 1 , 2 * n ) ; }
int maxOfSegmentMins ( int [ ] a , int n , int k ) { if ( k == 1 ) return a . Min ( ) ; if ( k == 2 ) return Math . Max ( a [ 0 ] , a [ n - 1 ] ) ; return a . Max ( ) ; }
int MinOperation ( int [ ] a , int [ ] b , int n ) { Array . Sort ( a ) ; Array . Sort ( b ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . Abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . Abs ( a [ i ] - b [ i ] ) ; } return result ; }
void findMissing ( int [ ] arr1 , int [ ] arr2 , int M , int N ) { if ( M != N - 1 && N != M - 1 ) { Console . WriteLine ( "Invalid Input" ) ; return ; } int res = 0 ; for ( int i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( int i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; Console . WriteLine ( "Missing element is " + res ) ; }
long calculate ( long [ ] a , int n ) { Array . Sort ( a ) ; int i , j ; List < long > s = new List < long > ( ) ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . Add ( ( a [ i ] + a [ j ] ) ) ; long mini = s . Min ( ) ; long maxi = s . Max ( ) ; return Math . Abs ( maxi - mini ) ; }
long findMinSum ( long [ ] a , long [ ] b , long n ) { Array . Sort ( a ) ; Array . Sort ( b ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + Math . Abs ( a [ i ] - b [ i ] ) ; return sum ; }
void push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; head = head_ref ; }
void fun ( int [ ] arr , int k ) { int n = 4 - 1 ; int v = n - k ; if ( v >= 0 ) { reverse ( arr , 0 , v ) ; reverse ( arr , v + 1 , n ) ; reverse ( arr , 0 , n ) ; } }
void rotateSubList ( ListNode A , int m , int n , int k ) { int size = n - m + 1 ; if ( k > size ) { k = k % size ; } if ( k == 0 k == size ) { ListNode head = A ; while ( head != null ) { Console . Write ( head . data ) ; head = head . next ; } return ; } ListNode link = null ; if ( m == 1 ) { link = A ; } ListNode c = A ; int count = 0 ; ListNode end = null ; ListNode pre = null ; while ( c != null ) { count ++ ; if ( count == m - 1 ) { pre = c ; link = c . next ; } if ( count == n - k ) { if ( m == 1 ) { end = c ; A = c . next ; } else { end = c ; pre . next = c . next ; } } if ( count == n ) { ListNode d = c . next ; c . next = link ; end . next = d ; ListNode head = A ; while ( head != null ) { Console . Write ( head . data + " " ) ; head = head . next ; } return ; } c = c . next ; } }
void printArray ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void createHash ( HashSet < int > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . Add ( prev ) ; hash . Add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . Add ( temp ) ; prev = curr ; curr = temp ; } }
int solve ( int n , int m ) { int ans = n * ( m / 2 ) ; if ( m % 2 == 1 ) { ans += ( n + 1 ) / 2 ; } return ans ; }
int rangeXor ( int [ ] BITree , int l , int r ) { return getXOR ( BITree , r ) ^ getXOR ( BITree , l - 1 ) ; }
int query ( int L , int R ) { if ( L == 0 ) return prefix [ R ] ; return prefix [ R ] - prefix [ L - 1 ] ; }
void game ( int [ ] v , int n ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m . ContainsKey ( v [ i ] ) ) m . Add ( v [ i ] , 1 ) ; else m [ v [ i ] ] = m [ v [ i ] ] + 1 ; } int count = 0 ; int check = 0 ; foreach ( KeyValuePair < int , int > i in m ) { if ( i . Value > 1 ) { if ( i . Value >= 4 && i . Value % 2 == 0 ) check ++ ; count ++ ; } } bool flag ; if ( check % 2 != 0 ) flag = false ; if ( check % 2 != 0 ) Console . WriteLine ( "Yes" ) ; else if ( n % 2 == 0 && count % 2 == 0 ) Console . WriteLine ( "No" ) ; else Console . WriteLine ( "Yes" ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < N ; i ++ ) prime [ i ] = 1 ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * p ; i < N ; i += p ) prime [ i ] = 0 ; } } }
int fact ( int n ) { return factTR ( n , 1 ) ; }
int maximumMedian ( int [ , ] arr , int N , int K ) { int low = 0 , high = ( int ) 1e9 ; while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( isMaximumMedian ( arr , N , K , mid ) ) { low = mid + 1 ; } else { high = mid ; } } return low ; }
void findMinDays ( int [ ] arr , int [ ] R , int N , int X , int K ) { int low = 0 , high = X ; int minDays = - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int temp = arr [ i ] + R [ i ] * mid ; if ( temp >= K ) { sum += temp ; } } if ( sum >= X ) { minDays = mid ; high = mid - 1 ; } else { low = mid + 1 ; } } Console . Write ( minDays ) ; }
void maximumIndices ( int [ ] arr , int N ) { int [ ] temp = new int [ N ] ; int maxIndices = ( N - 1 ) / 2 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < maxIndices ; i ++ ) { temp [ 2 * i + 1 ] = arr [ i ] ; } int j = 0 ; for ( int i = maxIndices ; i < N ; ) { if ( temp [ j ] == 0 ) { temp [ j ] = arr [ i ] ; i ++ ; } j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( temp [ i ] + " " ) ; } }
bool check ( int n , int m , int x , int y , int vl ) { int temp = m ; if ( vl > n ) return false ; int ex = n - vl ; ex *= y ; temp += ex ; int cr = temp / x ; if ( cr >= vl ) return true ; return false ; }
void findPoint ( int [ ] arr , int N , int K ) { int left ; if ( N % 2 != 0 ) { left = arr [ N / 2 ] ; } else { left = arr [ N / 2 - 1 ] + 1 ; } int right = arr [ N - 1 ] ; while ( left <= right ) { int mid = ( left + right ) / 2 ; int temp = findSum ( arr , N , mid ) ; if ( temp == K ) { Console . WriteLine ( mid ) ; return ; } else if ( K < temp ) { right = mid - 1 ; } else { left = mid + 1 ; } } left = arr [ 0 ] ; right = arr [ N / 2 ] - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; int temp = findSum ( arr , N , mid ) ; if ( temp == K ) { Console . WriteLine ( mid ) ; return ; } else if ( K > temp ) { right = mid - 1 ; } else { left = mid + 1 ; } } Console . WriteLine ( "-1" ) ; }
int NthComposite ( int N ) { int MAX_SIZE = 1000005 ; bool [ ] IsPrime = new bool [ MAX_SIZE ] ; Array . Fill ( IsPrime , true ) ; for ( int p = 2 ; p * p < MAX_SIZE ; p ++ ) { if ( IsPrime [ p ] == true ) { for ( int i = p * p ; i < MAX_SIZE ; i += p ) IsPrime [ i ] = false ; } } List < int > Composites = new List < int > ( ) ; for ( int p = 4 ; p < MAX_SIZE ; p ++ ) if ( ! IsPrime [ p ] ) Composites . Add ( p ) ; return Composites [ N - 1 ] ; }
void printArray ( List < string > res ) { ( res ) . Sort ( ) ; for ( int i = 0 ; i < res . Count ; i ++ ) { Console . Write ( res [ i ] + " " ) ; } }
int minCount ( int [ ] A , int [ ] B , int N ) { int i = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] == B [ j ] ) { i ++ ; } } return N - i ; }
void minimumNumber ( int K , int X ) { if ( K > X ) { Console . Write ( "-1" ) ; return ; } int low = K , high = X , res = - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( isGreaterEqual ( mid , K , X ) ) { res = mid ; high = mid - 1 ; } else low = mid + 1 ; } Console . WriteLine ( res ) ; }
int right_search ( List < int > A , int num ) { int low = 0 , high = A . Count - 1 ; int ans = high ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( A [ mid ] <= num ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; }
int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
void prefixArr ( int [ ] arr , int [ , ] prefix , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 ) { prefix [ i , 0 ] = arr [ i ] ; prefix [ i , 1 ] = arr [ i ] ; } else { prefix [ i , 0 ] = Math . Max ( prefix [ i - 1 , 0 ] , arr [ i ] ) ; prefix [ i , 1 ] = Math . Min ( prefix [ i - 1 , 1 ] , arr [ i ] ) ; } } }
void Query ( int [ ] arr , int N , List < List < int > > Q ) { int [ ] tree = new int [ 4 * N ] ; build_seg_tree ( 0 , N - 1 , 0 , tree , arr ) ; for ( int i = 0 ; i < ( int ) Q . Count ; i ++ ) { if ( Q [ i ] [ 0 ] == 1 ) Console . Write ( query ( Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , 0 , N - 1 , 0 , tree ) + " " ) ; else update ( 0 , N - 1 , 0 , Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , tree , arr ) ; } }
void Sieve ( ) { index = 0 ; int [ ] p = new int [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) { p [ i ] = 1 ; } p [ 0 ] = p [ 1 ] = 0 ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( p [ i ] == 1 ) { for ( int j = i * i ; j <= N ; j += i ) { p [ j ] = 0 ; } } } for ( int i = 1 ; i < N ; i ++ ) { if ( p [ i ] == 1 ) { prime [ index ++ ] = ( int ) ( Math . Pow ( i , 4 ) ) ; } } }
bool isValidDigit ( int digit , int K ) { while ( K != 0 ) { if ( K % 10 == digit ) { return true ; } K = K / 10 ; } return false ; }
void update ( int index , int s , int e , int new_val , int pos ) { if ( s == e ) Tree [ index ] = new_val ; else { int m = ( s + e ) / 2 ; if ( pos <= m ) { update ( 2 * index , s , m , new_val , pos ) ; } else { update ( 2 * index + 1 , m + 1 , e , new_val , pos ) ; } Tree [ index ] = Math . Max ( Tree [ 2 * index ] , Tree [ 2 * index + 1 ] ) ; } }
void printAnswer ( int N , List < List < int > > edges ) { for ( int i = 0 ; i <= N ; i ++ ) { parent [ i ] = i ; } for ( int i = 0 ; i < edges . Count ; i ++ ) { connect ( edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; } connectedComponents ( N ) ; }
void countNumbers ( int n , int d ) { int total = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int x = i ; while ( x > 0 ) { if ( x % 8 == d ) { total ++ ; break ; } x = x / 8 ; } } Console . WriteLine ( total ) ; }
int smallestLeft ( int [ ] arr , int total , int sum , int i , int [ , ] dp ) { if ( i == 0 ) { return Math . Abs ( total - 2 * sum ) ; } if ( dp [ i , sum ] != - 1 ) return dp [ i , sum ] ; int X = smallestLeft ( arr , total , sum + arr [ i - 1 ] , i - 1 , dp ) ; int Y = smallestLeft ( arr , total , sum , i - 1 , dp ) ; return dp [ i , sum ] = Math . Min ( X , Y ) ; }
void findWordsSameRow ( List < string > arr ) { Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; mp . Add ( 'q' , 1 ) ; mp . Add ( 'w' , 1 ) ; mp . Add ( 'e' , 1 ) ; mp . Add ( 'r' , 1 ) ; mp . Add ( 't' , 1 ) ; mp . Add ( 'y' , 1 ) ; mp . Add ( 'u' , 1 ) ; mp . Add ( 'i' , 1 ) ; mp . Add ( 'o' , 1 ) ; mp . Add ( 'p' , 1 ) ; mp . Add ( 'a' , 2 ) ; mp . Add ( 's' , 2 ) ; mp . Add ( 'd' , 2 ) ; mp . Add ( 'f' , 2 ) ; mp . Add ( 'g' , 2 ) ; mp . Add ( 'h' , 2 ) ; mp . Add ( 'j' , 2 ) ; mp . Add ( 'k' , 2 ) ; mp . Add ( 'l' , 2 ) ; mp . Add ( 'z' , 3 ) ; mp . Add ( 'x' , 3 ) ; mp . Add ( 'c' , 3 ) ; mp . Add ( 'v' , 3 ) ; mp . Add ( 'b' , 3 ) ; mp . Add ( 'n' , 3 ) ; mp . Add ( 'm' , 3 ) ; foreach ( string word in arr ) { if ( word . Length != 0 ) { bool flag = true ; int rowNum = mp [ char . ToLower ( word [ 0 ] ) ] ; int M = word . Length ; for ( int i = 1 ; i < M ; i ++ ) { if ( mp [ Char . ToLower ( word [ i ] ) ] != rowNum ) { flag = false ; break ; } } if ( flag ) { Console . Write ( word + " " ) ; } } } }
int countSubsequece ( int [ ] a , int n ) { int i , j , k , l ; int answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; }
int countSubsequence ( int [ ] a , int n ) { int i , j ; fill_counts ( a , n ) ; int answer = 0 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n - 1 ; j ++ ) { answer += lcount [ a [ j ] , i - 1 ] * rcount [ a [ i ] , j + 1 ] ; } } return answer ; }
int MincntBothPalin ( string str1 , string str2 , int N ) { int i = 0 ; int j = N - 1 ; int cntOp = 0 ; while ( i < j ) { if ( str1 [ i ] == str1 [ j ] && str2 [ i ] != str2 [ j ] ) { cntOp += 1 ; } else if ( str1 [ i ] != str1 [ j ] && str2 [ i ] == str2 [ j ] ) { cntOp += 1 ; } else if ( str1 [ i ] != str1 [ j ] && str2 [ i ] != str2 [ j ] ) { if ( str1 [ i ] == str2 [ j ] && str2 [ i ] == str1 [ j ] ) { cntOp += 1 ; } else { cntOp += 2 ; } } i += 1 ; j -= 1 ; } return cntOp ; }
bool isValid ( int [ ] wood , int N , int len , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { count += wood [ i ] / len ; } return count >= K ; }
bool isMorannumber ( int n ) { int dup = n ; int sum = digiSum ( dup ) ; if ( n % sum == 0 ) { int c = n / sum ; if ( isPrime ( c ) ) { return true ; } } return false ; }
int maxEqualIdx ( int [ ] arr , int k ) { Array . Sort ( arr ) ; int [ ] prefixSum = new int [ arr . Length + 1 ] ; prefixSum [ 1 ] = arr [ 0 ] ; for ( int i = 1 ; i < prefixSum . Length - 1 ; ++ i ) { prefixSum [ i + 1 ] = prefixSum [ i ] + arr [ i ] ; } int max = arr . Length ; int min = 1 ; int ans = 1 ; while ( min <= max ) { int mid = ( max + min ) / 2 ; if ( check ( prefixSum , mid , k , arr ) ) { ans = mid ; min = mid + 1 ; } else { max = mid - 1 ; } } return ans ; }
bool sfpa ( int V , int src , int [ , ] Edges , int M ) { List < pair > [ ] g = new List < pair > [ V ] ; for ( int i = 0 ; i < V ; i ++ ) { g [ i ] = new List < pair > ( ) ; } for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i , 0 ] ; int v = Edges [ i , 1 ] ; int w = Edges [ i , 2 ] ; g [ u ] . Add ( new pair ( v , w ) ) ; } int [ ] dist = new int [ V ] ; for ( int i = 0 ; i < V ; i ++ ) dist [ i ] = int . MaxValue ; bool [ ] inQueue = new bool [ V ] ; int [ ] cnt = new int [ V ] ; dist [ src ] = 0 ; Queue < int > q = new Queue < int > ( ) ; q . Enqueue ( src ) ; inQueue [ src ] = true ; while ( q . Count != 0 ) { int u = q . Peek ( ) ; q . Dequeue ( ) ; inQueue [ u ] = false ; foreach ( pair x in g [ u ] ) { int v = x . first ; int cost = x . second ; if ( dist [ v ] > dist [ u ] + cost ) { dist [ v ] = dist [ u ] + cost ; if ( ! inQueue [ v ] ) { q . Enqueue ( v ) ; inQueue [ v ] = true ; cnt [ v ] ++ ; if ( cnt [ v ] >= V ) return true ; } } } } return false ; }
int countNum ( int N , int sum , int K , int st , int [ , , ] dp ) { if ( N == 0 && sum == 0 ) { return 1 ; } if ( N < 0 ) { return 0 ; } if ( dp [ N , sum , st ] != - 1 ) { return dp [ N , sum , st ] ; } int res = 0 ; int start = ( st == 1 ? 0 : 1 ) ; for ( int i = start ; i <= 9 ; i ++ ) { res += countNum ( N - 1 , ( sum + i ) % K , K , ( ( st i ) > 0 ) ? 1 : 0 , dp ) ; } return dp [ N , sum , st ] = res ; }
int hIndex ( int [ ] citations , int n ) { int hindex = 0 ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( citations [ mid ] >= ( mid + 1 ) ) { low = mid + 1 ; hindex = mid + 1 ; } else { high = mid - 1 ; } } Console . WriteLine ( hindex ) ; return hindex ; }
int countNodes ( int V , int E , int src , int dest , int [ , ] edges ) { List < int > [ ] adj = new List < int > [ V + 1 ] ; for ( int i = 0 ; i < adj . Length ; i ++ ) adj [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < E ; i ++ ) { adj [ edges [ i , 0 ] ] . Add ( edges [ i , 1 ] ) ; adj [ edges [ i , 1 ] ] . Add ( edges [ i , 0 ] ) ; } int [ ] vis = new int [ V + 1 ] ; int count = dfs ( src , dest , vis , adj ) ; return count - 2 ; }
int longestGP ( int [ ] A , int N ) { if ( N < 2 ) return N ; int length = 1 , common_ratio = 1 ; int maxlength = 1 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i + 1 ] % A [ i ] == 0 ) { if ( A [ i + 1 ] / A [ i ] == common_ratio ) { length = length + 1 ; maxlength = Math . Max ( maxlength , length ) ; } else { common_ratio = A [ i + 1 ] / A [ i ] ; length = 2 ; } } else { maxlength = Math . Max ( maxlength , length ) ; length = 1 ; } } maxlength = Math . Max ( maxlength , length ) ; return maxlength ; }
void add_seg ( int [ ] seg , int start , int end , int current , int index ) { if ( index > end index < start ) return ; if ( start == end ) { seg [ current ] = 1 ; return ; } int mid = ( start + end ) / 2 ; add_seg ( seg , start , mid , 2 * current + 1 , index ) ; add_seg ( seg , mid + 1 , end , 2 * current + 2 , index ) ; seg [ current ] = seg [ 2 * current + 1 ] + seg [ 2 * current + 2 ] ; }
int getPrefixLength ( string srcStr , string targetStr ) { if ( targetStr . Length == 0 ) return 0 ; srcStr = srcStr . ToLower ( ) ; targetStr = targetStr . ToLower ( ) ; Dictionary < char , int > dictCount = new Dictionary < char , int > ( ) ; int nUnique = 0 ; foreach ( var ch in targetStr ) { if ( dictCount . ContainsKey ( ch ) != true ) { nUnique += 1 ; dictCount [ ch ] = 0 ; } dictCount [ ch ] += 1 ; } for ( int i = 0 ; i < srcStr . Length ; i ++ ) { char ch = srcStr [ i ] ; if ( dictCount . ContainsKey ( ch ) != true ) continue ; dictCount [ ch ] -= 1 ; if ( dictCount [ ch ] == 0 ) nUnique -= 1 ; if ( nUnique == 0 ) return ( i + 1 ) ; } return - 1 ; }
int minOperations ( String S , int K ) { int ans = 0 ; for ( int i = 0 ; i < K ; i ++ ) { int zero = 0 , one = 0 ; for ( int j = i ; j < S . Length ; j += K ) { if ( S [ j ] == '0' ) zero ++ ; else one ++ ; } ans += Math . Min ( zero , one ) ; } return ans ; }
int func ( int A , int B , int C , int x ) { return ( A * x * x + B * x + C ) ; }
int minDays ( int [ ] arr , int n , int k ) { int l = arr . Length ; int left = 1 , right = ( int ) 1e9 ; if ( n * k > l ) return - 1 ; while ( left < right ) { int mid = ( left + right ) / 2 , cnt = 0 , product = 0 ; for ( int j = 0 ; j < l ; ++ j ) { if ( arr [ j ] > mid ) { cnt = 0 ; } else if ( ++ cnt >= k ) { product ++ ; cnt = 0 ; } } if ( product < n ) { left = mid + 1 ; } else { right = mid ; } } return left ; }
int minimumMoves ( String s , int K ) { StringBuilder S = new StringBuilder ( s ) ; int N = S . Length ; int ops = 0 ; int last_idx = - 1 ; for ( int i = 0 ; i < K ; i ++ ) { if ( S [ i ] == '1' ) last_idx = i ; } if ( last_idx == - 1 ) { ++ ops ; S . Insert ( K - 1 , '1' ) ; last_idx = K - 1 ; } for ( int i = 1 ; i < N - K + 1 ; i ++ ) { if ( last_idx < i ) last_idx = - 1 ; if ( S [ i + K - 1 ] == '1' ) last_idx = i + K - 1 ; if ( last_idx == - 1 ) { ++ ops ; S . Insert ( i + K - 1 , '1' ) ; last_idx = i + K - 1 ; } } return ops ; }
int missingElement ( int [ ] arr , int n ) { int max_ele = arr [ 0 ] ; int min_ele = arr [ 0 ] ; int x = 0 ; int d ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; if ( arr [ i ] < min_ele ) min_ele = arr [ i ] ; } d = ( max_ele - min_ele ) / n ; for ( int i = 0 ; i < n ; i ++ ) { x = x ^ arr [ i ] ; } for ( int i = 0 ; i <= n ; i ++ ) { x = x ^ ( min_ele + ( i * d ) ) ; } return x ; }
int longestPermutation ( int [ ] arr , int n ) { Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . ContainsKey ( arr [ i ] ) ) { freq [ arr [ i ] ] = freq [ arr [ i ] ] + 1 ; } else { freq . Add ( arr [ i ] , 1 ) ; } } int len = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! freq . ContainsKey ( i ) ) { break ; } len ++ ; } return len ; }
int findColor ( Dictionary < int , int > mapWithColor , int query ) { int maximum = 0 ; while ( query >= 1 ) { if ( mapWithColor . ContainsKey ( query ) ) { maximum = Math . Max ( maximum , mapWithColor [ query ] ) ; } if ( query % 2 == 1 ) query = ( query - 1 ) / 2 ; else query = query / 2 ; } return maximum ; }
int findlength ( String str , int n , int k ) { int maxLen = 0 ; int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { setZero ( freq ) ; for ( int j = i ; j < n ; j ++ ) { freq [ str [ j ] - 'a' ] ++ ; if ( atLeastK ( freq , k ) ) { maxLen = Math . Max ( maxLen , j - i + 1 ) ; } } } return maxLen ; }
int maxSumArray ( int [ ] arr , int n ) { int sum = 0 ; Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( m . ContainsKey ( arr [ i ] ) ) { var val = m [ arr [ i ] ] ; m . Remove ( arr [ i ] ) ; m . Add ( arr [ i ] , val + 1 ) ; } else { m . Add ( arr [ i ] , 1 ) ; } } int minimum = int . MaxValue ; foreach ( KeyValuePair < int , int > x in m ) minimum = Math . Min ( minimum , ( x . Value * x . Key ) ) ; return ( sum - minimum ) ; }
void create_table ( int n ) { int pow = 1 ; int co = 0 ; do { pow <<= 1 ; lookup_table [ co ] = ( n + ( pow >> 1 ) ) / pow ; } while ( lookup_table [ co ++ ] != 0 ) ; }
int costToPanagram ( string str , int [ ] cost ) { int i , n = str . Length ; int [ ] occurrences = new int [ 26 ] ; for ( i = 0 ; i < n ; i ++ ) occurrences [ str [ i ] - 'a' ] ++ ; int gain = 0 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( occurrences [ i ] == 0 ) gain -= ( 2 * cost [ i ] ) ; else if ( occurrences [ i ] > 1 ) gain += ( cost [ i ] * ( occurrences [ i ] - 1 ) ) ; } if ( gain >= 0 ) return 0 ; return ( gain * - 1 ) ; }
int strScore ( string [ ] str , string s , int n ) { Dictionary < string , int > m = new Dictionary < string , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) m [ str [ i ] ] = i + 1 ; if ( ! m . ContainsKey ( s ) ) return 0 ; int score = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) score += s [ i ] - 'a' + 1 ; score = score * m [ s ] ; return score ; }
string replacePi ( string input ) { string output = "" ; int size = input . Length ; for ( int i = 0 ; i < size ; ++ i ) { if ( i + 1 < size && input [ i ] == 'p' && input [ i + 1 ] == 'i' ) { output += "3.14" ; i ++ ; } else { output += input [ i ] ; } } return output ; }
bool check_pair_product ( Node head , int prod ) { List < int > s = new List < int > ( ) ; Node p = head ; while ( p != null ) { int curr = p . data ; if ( ( prod % curr == 0 ) && ( s . Contains ( prod / curr ) ) ) { Console . Write ( curr + " " + ( prod / curr ) ) ; return true ; } s . Add ( p . data ) ; p = p . next ; } return false ; }
int minSum ( int [ ] arr , int n ) { int sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { int j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; }
int totalNumbersWithSpecificDifference ( int N , int diff ) { int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( mid - sumOfDigit ( mid ) < diff ) low = mid + 1 ; else high = mid - 1 ; } return ( N - high ) ; }
int computeCost ( int [ ] arr , int N , int X ) { int cost = 0 ; for ( int i = 0 ; i < N ; i ++ ) cost += Math . Abs ( arr [ i ] - X ) ; return cost ; }
void insertionSort ( int [ ] arr , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } }
void minimumRange ( int [ ] arr , int N , int K ) { if ( K >= N ) { Console . Write ( 0 ) ; return ; } Array . Sort ( arr ) ; int left = 0 , right = N - 1 , i ; for ( i = 0 ; i < K ; i ++ ) { if ( arr [ right - 1 ] - arr [ left ] < arr [ right ] - arr [ left + 1 ] ) right -- ; else left ++ ; } Console . Write ( arr [ right ] - arr [ left ] ) ; }
int minimum_possible_sum ( int [ ] arr , int n , int k ) { if ( n == 0 ) { return 0 ; } if ( n == 1 ) { return arr [ 0 ] ; } for ( int i = 0 ; i < k ; i ++ ) { int smallest_element = arr [ 0 ] ; int smallest_pos = 0 ; int largest_element = arr [ 0 ] ; int largest_pos = 0 ; for ( int j = 1 ; j < n ; j ++ ) { if ( arr [ j ] >= largest_element ) { largest_element = arr [ j ] ; largest_pos = j ; } if ( arr [ j ] < smallest_element ) { smallest_element = arr [ j ] ; smallest_pos = j ; } } int a = smallest_element * 2 ; int b = largest_element / 2 ; if ( a + b < smallest_element + largest_element ) { arr [ smallest_pos ] = a ; arr [ largest_pos ] = b ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += arr [ i ] ; } return ans ; }
int XorSum ( int [ ] A , int [ ] B , int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { ans = ans ^ ( A [ i ] + B [ j ] ) ; } } return ans ; }
int findCount ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; int result = 1 ; int cur_max = arr [ 0 ] ; int cur_min = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { cur_max = arr [ i ] ; if ( cur_max - cur_min > K ) { result ++ ; cur_max = arr [ i ] ; cur_min = arr [ i ] ; } } return result ; }
void checkToMakeEqual ( String S1 , String S2 ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < S1 . Length ; i ++ ) { freq [ S1 [ i ] - 'a' ] ++ ; } bool flag = false ; for ( int i = 0 ; i < S2 . Length ; i ++ ) { if ( freq [ S2 [ i ] - 'a' ] == 0 ) { flag = true ; break ; } freq [ S2 [ i ] - 'a' ] -- ; } if ( flag == true ) { Console . WriteLine ( "No" ) ; return ; } int invCount1 = inversionCount ( S1 ) ; int invCount2 = inversionCount ( S2 ) ; if ( invCount1 == invCount2 || ( invCount1 & 1 ) == ( invCount2 & 1 ) || haveRepeated ( S1 , S2 ) ) { Console . WriteLine ( "Yes" ) ; } else Console . WriteLine ( "No" ) ; }
int findKthSmallest ( int [ ] arr , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } int [ ] counter = new int [ max + 1 ] ; int smallest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; } for ( int num = 1 ; num <= max ; num ++ ) { if ( counter [ num ] > 0 ) { smallest += counter [ num ] ; } if ( smallest >= k ) { return num ; } } return - 1 ; }
void printArr ( int [ ] arr , int n ) { Array . Sort ( arr ) ; if ( arr [ 0 ] == arr [ n - 1 ] ) { Console . Write ( "No\n" ) ; } else { Console . Write ( "Yes\n" ) ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " " ) ; } } }
int countVowels ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) ++ count ; return count ; }
int findSum ( int [ ] arr , int n , int k ) { int ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) { ans = Math . Min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }
int cntElements ( int [ ] arr , int n ) { int [ ] copy_arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; int count = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; }
void UpdateArr ( int [ ] arr , int n ) { int i = 0 , j = n - 1 ; while ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i += 2 ; j -= 2 ; } printArr ( arr , n ) ; }
void pre ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; } }
void sieve ( long n ) { for ( int i = 2 ; i <= n ; i += 1 ) { prime [ i ] = true ; } for ( int p = 2 ; ( int ) p * ( int ) p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = ( int ) p * ( int ) p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) pr . Add ( ( long ) p ) ; }
long SemiPrimeSum ( long N ) { long ans = 0 ; for ( int i = 0 ; i < pr . Count ; i += 1 ) { for ( int j = i ; j < pr . Count ; j += 1 ) { if ( ( long ) pr [ i ] * ( long ) pr [ j ] > N ) break ; ans += ( long ) pr [ i ] * ( long ) pr [ j ] ; } } return ans ; }
void quickSort ( char [ ] arr , int low , int high , int mod ) { if ( low < high ) { int pi = partition ( arr , low , high , mod ) ; quickSort ( arr , low , pi - 1 , mod ) ; quickSort ( arr , pi + 1 , high , mod ) ; } }
int maxWater ( int [ ] height , int n ) { int max = 0 ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( height [ i ] < height [ j ] ) { max = Math . Max ( max , ( j - i - 1 ) * height [ i ] ) ; i ++ ; } else if ( height [ j ] < height [ i ] ) { max = Math . Max ( max , ( j - i - 1 ) * height [ j ] ) ; j -- ; } else { max = Math . Max ( max , ( j - i - 1 ) * height [ i ] ) ; i ++ ; j -- ; } } return max ; }
bool check ( string str ) { int min = Int32 . MaxValue ; int max = Int32 . MinValue ; int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { int ascii = ( int ) str [ i ] ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; int eSum = ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; }
void findNumbers ( int [ ] arr , int n ) { Array . Sort ( arr ) ; reverse ( arr ) ; int [ ] freq = new int [ arr [ 0 ] + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int size = ( int ) Math . Sqrt ( n ) ; int [ ] brr = new int [ size ] ; int x , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ arr [ i ] ] > 0 && l < size ) { brr [ l ] = arr [ i ] ; freq [ brr [ l ] ] -- ; l ++ ; for ( int j = 0 ; j < l ; j ++ ) { if ( i != j ) { x = __gcd ( arr [ i ] , brr [ j ] ) ; freq [ x ] -= 2 ; } } } } printArr ( brr , size ) ; }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void merge_and_sort ( int [ ] output , int [ , ] arr , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { output [ i * n + j ] = arr [ i , j ] ; } } Array . Sort ( output ) ; }
void AlternateRearrange ( int [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] % 2 == 0 ) v1 . Add ( arr [ j ] ) ; else v2 . Add ( arr [ j ] ) ; int index = 0 , i = 0 , k = 0 ; bool flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ] = ( int ) v1 [ i ] ; i += 1 ; index += 1 ; flag = ! flag ; } else { arr [ index ] = ( int ) v2 [ k ] ; k += 1 ; index += 1 ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
int getNumToAdd ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; int numToAdd = - 1 ; bool numAdded = false ; for ( int i = 2 ; i < n ; i ++ ) { int diff = arr [ i ] - arr [ i - 1 ] ; if ( diff != d ) { if ( numAdded ) return - 1 ; if ( diff == 2 * d ) { numToAdd = arr [ i ] - d ; numAdded = true ; } else return - 1 ; } } if ( numToAdd == - 1 ) return ( arr [ n - 1 ] + d ) ; return numToAdd ; }
int PointInKSquares ( int n , int [ ] a , int k ) { Array . Sort ( a ) ; return a [ n - k ] ; }
int maxArrayCover ( int [ ] a , int n , int x ) { Array . Sort ( a ) ; int cc = 0 ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += a [ i ] ; if ( s > x ) { break ; } cc += 1 ; } if ( a . Sum ( ) == x ) { return n ; } else { if ( cc == n ) { return n - 1 ; } else { return cc ; } } }
int findMaxNum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int num = arr [ 0 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { num = num * 10 + arr [ i ] ; } return num ; }
void sort ( int [ ] arr , int n ) { int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 999 ) { index = i ; break ; } } if ( index == - 1 ) return ; sortRec ( arr , index , n , n ) ; }
void merge ( int [ ] arr1 , int [ ] arr2 , int n , int m ) { int i , j , gap = n + m ; for ( gap = nextGap ( gap ) ; gap > 0 ; gap = nextGap ( gap ) ) { for ( i = 0 ; i + gap < n ; i ++ ) if ( arr1 [ i ] > arr1 [ i + gap ] ) { int temp = arr1 [ i ] ; arr1 [ i ] = arr1 [ i + gap ] ; arr1 [ i + gap ] = temp ; } for ( j = gap > n ? gap - n : 0 ; i < n && j < m ; i ++ , j ++ ) if ( arr1 [ i ] > arr2 [ j ] ) { int temp = arr1 [ i ] ; arr1 [ i ] = arr2 [ j ] ; arr2 [ j ] = temp ; } if ( j < m ) { for ( j = 0 ; j + gap < m ; j ++ ) if ( arr2 [ j ] > arr2 [ j + gap ] ) { int temp = arr2 [ j ] ; arr2 [ j ] = arr2 [ j + gap ] ; arr2 [ j + gap ] = temp ; } } } }
int _mergeSort ( int [ ] arr , int [ ] temp , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; }
void printSorted ( int a , int b , int c ) { int get_max = Math . Max ( a , Math . Max ( b , c ) ) ; int get_min = - Math . Max ( - a , Math . Max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; Console . Write ( get_min + " " + get_mid + " " + get_max ) ; }
int countSwaps ( int [ ] arr , int n ) { int [ ] temp = new int [ n ] ; return _mergeSort ( arr , temp , 0 , n - 1 ) ; }
int pancakeSort ( int [ ] arr , int n ) { for ( int curr_size = n ; curr_size > 1 ; -- curr_size ) { int mi = findMax ( arr , curr_size ) ; if ( mi != curr_size - 1 ) { flip ( arr , mi ) ; flip ( arr , curr_size - 1 ) ; } } return 0 ; }
string largestMerge ( string word1 , string word2 ) { string merge = "" ; while ( word1 . Length != 0 word2 . Length != 0 ) { if ( String . Compare ( word1 , word2 ) == 0 || String . Compare ( word1 , word2 ) > 0 ) { merge = merge + word1 [ 0 ] ; word1 = word1 . Substring ( 1 ) ; } else { merge = merge + word2 [ 0 ] ; word2 = word2 . Substring ( 1 ) ; } } return merge ; }
int find ( List < int > arr , int N ) { int Sum = 0 ; foreach ( int item in arr ) Sum += item ; if ( Sum % N == 1 ) return - 1 ; int k = Sum / N ; int ans = 0 ; int i = 0 ; while ( i < N ) { ans = ans + Math . Abs ( k - arr [ i ] ) ; i += 1 ; } return ans / 2 ; }
int maxXORUtil ( int [ ] arr , int N , int xrr , int orr ) { if ( N == 0 ) return xrr ^ orr ; int x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) ; int y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) ; return Math . Max ( x , y ) ; }
int maximumXOR ( int [ ] arr , int N ) { return maxXORUtil ( arr , N , 0 , 0 ) ; }
void findEquation ( int S , int M ) { Console . Write ( "1 " + ( ( - 1 ) * S ) + " " + M ) ; }
bool isPalindrome ( int N ) { int temp = N ; int res = 0 ; while ( temp != 0 ) { int rem = temp % 10 ; res = res * 10 + rem ; temp /= 10 ; } if ( res == N ) { return true ; } else { return false ; } }
int minSteps ( List < int > a , int n ) { int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] + a [ i ] ; int mx = - 1 ; foreach ( int subgroupsum in prefix_sum ) { int sum = 0 ; int i = 0 ; int grp_count = 0 ; while ( i < n ) { sum += a [ i ] ; if ( sum == subgroupsum ) { grp_count += 1 ; sum = 0 ; } else if ( sum > subgroupsum ) { grp_count = - 1 ; break ; } i += 1 ; } if ( grp_count > mx ) mx = grp_count ; } return n - mx ; }
void findSubseq ( List < int > A , List < int > B , int K , int i ) { List < int > ans = new List < int > ( ) ; findSubseqUtil ( A , B , ans , K , i ) ; if ( ans . Count < 1 ) Console . WriteLine ( - 1 ) ; }
int MinimumCost ( int [ ] A , int [ ] B , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int mod_A = B [ i ] % A [ i ] ; int totalCost_A = Math . Min ( mod_A , A [ i ] - mod_A ) ; int mod_B = A [ i ] % B [ i ] ; int totalCost_B = Math . Min ( mod_B , B [ i ] - mod_B ) ; totalCost += Math . Min ( totalCost_A , totalCost_B ) ; } return totalCost ; }
int longestSubarray ( int [ ] arr , int N , int K ) { Dictionary < int , int > um = new Dictionary < int , int > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( sum == K ) maxLen = i + 1 ; if ( ! um . ContainsKey ( sum ) ) um [ sum ] = i ; if ( um . ContainsKey ( sum - K ) ) { if ( maxLen < ( i - um [ sum - K ] ) ) maxLen = i - um [ sum - K ] ; } } return maxLen ; }
void findArrayWithMaxProduct ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) if ( arr [ i ] >= 0 ) { arr [ i ] = - arr [ i ] - 1 ; } if ( N % 2 == 1 ) { int max_element = - 1 ; int index = - 1 ; for ( int i = 0 ; i < N ; i ++ ) if ( Math . Abs ( arr [ i ] ) > max_element ) { max_element = Math . Abs ( arr [ i ] ) ; index = i ; } arr [ index ] = - arr [ index ] - 1 ; } for ( int i = 0 ; i < N ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
int maximumCandy ( int [ ] candies , int [ ] safety , int N , int M ) { int total = 0 ; int ans = Int32 . MaxValue ; bool all_safe = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = Math . Min ( ans , safety [ i ] ) ; } else { ans = Math . Min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; }
void canArrayBeReduced ( int [ ] arr , int N ) { if ( N == 1 ) { Console . Write ( arr [ 0 ] ) ; return ; } if ( arr [ 0 ] < arr [ N - 1 ] ) { Console . Write ( arr [ N - 1 ] ) ; } else Console . Write ( "Not Possible" ) ; }
void maxValueAtIndexK ( int N , int K , int M ) { int S1 = 0 , S2 = 0 ; S1 = K * ( K + 1 ) / 2 ; S2 = ( N - K - 1 ) * ( N - K ) / 2 ; int X = ( M + S1 + S2 ) / N ; Console . WriteLine ( X ) ; }
int countEvenPairs ( int N , int M ) { int count = 0 ; int nEven = ( int ) Math . Floor ( ( double ) N / 2 ) ; int nOdd = ( int ) Math . Ceiling ( ( double ) N / 2 ) ; int mEven = ( int ) Math . Floor ( ( double ) M / 2 ) ; int mOdd = ( int ) Math . Ceiling ( ( double ) M / 2 ) ; count = nEven * mEven + nOdd * mOdd ; return count ; }
void findNums ( int X , int Y ) { int A , B ; if ( X < Y ) { A = - 1 ; B = - 1 ; } else if ( ( ( Math . Abs ( X - Y ) ) & 1 ) != 0 ) { A = - 1 ; B = - 1 ; } else if ( X == Y ) { A = 0 ; B = Y ; } else { A = ( X - Y ) / 2 ; if ( ( A & Y ) == 0 ) { B = ( A + Y ) ; } else { A = - 1 ; B = - 1 ; } } Console . Write ( A + " " + B ) ; }
int findPartition ( int [ ] nums , int N ) { int [ ] prefix = new int [ N ] ; int [ ] suffix = new int [ N ] ; int i , k ; prefix [ 0 ] = nums [ 0 ] ; for ( i = 1 ; i < N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] * nums [ i ] ; } suffix [ N - 1 ] = nums [ N - 1 ] ; for ( i = N - 2 ; i >= 0 ; i -- ) { suffix [ i ] = suffix [ i + 1 ] * nums [ i ] ; } for ( k = 0 ; k < N - 1 ; k ++ ) { if ( GCD ( prefix [ k ] , suffix [ k + 1 ] ) == 1 ) { return k ; } } return - 1 ; }
void palindromeMatrix ( int N , int M , int [ , ] arr ) { int ans = 0 ; for ( int i = 0 ; i < ( N + 1 ) / 2 ; i ++ ) { for ( int j = 0 ; j < ( M + 1 ) / 2 ; j ++ ) { HashSet < pair > s = new HashSet < pair > ( ) ; s . Add ( new pair ( i , j ) ) ; s . Add ( new pair ( i , M - j - 1 ) ) ; s . Add ( new pair ( N - i - 1 , j ) ) ; s . Add ( new pair ( N - i - 1 , M - j - 1 ) ) ; List < int > values = new List < int > ( ) ; foreach ( pair p in s ) { values . Add ( arr [ p . first , p . second ] ) ; } values . Sort ( ) ; int max = values [ values . Count - 1 ] ; for ( int k = 1 ; k < values . Count ; k ++ ) { ans += max - values [ k ] ; } } } Console . Write ( ans ) ; }
int MinOperation ( int [ ] arr , int N , int K ) { int cntOpe = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( K > arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cntOpe += 2 ; } else { cntOpe += 1 ; } } else if ( K < arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cntOpe += 1 ; } else { cntOpe += 2 ; } } } return cntOpe ; }
void printSmallSub ( int [ ] arr , int N ) { int gcdArr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { gcdArr = gcd ( gcdArr , arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == gcdArr ) { Console . Write ( arr [ i ] + " " ) ; return ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( gcd ( arr [ i ] , arr [ j ] ) == gcdArr ) { Console . Write ( arr [ i ] + " " + arr [ j ] ) ; return ; } } } }
void smlstNonNeg ( int [ ] arr , int N ) { int smNonNeg = 0 ; bool [ ] hash = new bool [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { hash [ i ] = false ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 0 && arr [ i ] < N ) { hash [ arr [ i ] ] = true ; } while ( hash [ smNonNeg ] ) { smNonNeg ++ ; } Console . Write ( smNonNeg + " " ) ; } }
void numberOfWays ( int N ) { long count = count_of_primes [ N ] - 1 ; long mod = 1000000007 ; long answer = power ( 2 , count , mod ) ; if ( N == 1 ) answer = 0 ; long ans = answer ; Console . Write ( ans ) ; }
int cntPairs ( int [ ] arr , int N ) { bool [ ] isPrime = getPrimeNum ( ) ; int cntOne = 0 ; int cntPrime = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) { cntOne += 1 ; } else if ( isPrime [ i ] ) { cntPrime += 1 ; } } int cntNonComp = 0 ; cntNonComp = cntPrime * cntOne + cntOne * ( cntOne - 1 ) / 2 ; int res = 0 ; res = N * ( N - 1 ) / 2 - cntNonComp ; return res ; }
void printArray ( List < int > brr ) { foreach ( int it in brr ) { Console . Write ( it + " " ) ; } }
int MinimumFlips ( String s , int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( s [ i ] == '1' ? 1 : 0 ) ; } int [ ] oddone = new int [ n + 1 ] ; int [ ] evenone = new int [ n + 1 ] ; oddone [ 0 ] = 0 ; evenone [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) { oddone [ i + 1 ] = oddone [ i ] + ( a [ i ] == 1 ? 1 : 0 ) ; evenone [ i + 1 ] = evenone [ i ] + ( a [ i ] == 0 ? 1 : 0 ) ; } else { oddone [ i + 1 ] = oddone [ i ] + ( a [ i ] == 0 ? 1 : 0 ) ; evenone [ i + 1 ] = evenone [ i ] + ( a [ i ] == 1 ? 1 : 0 ) ; } } int minimum = Math . Min ( oddone [ n ] , evenone [ n ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( n % 2 != 0 ) { minimum = Math . Min ( minimum , oddone [ n ] - oddone [ i + 1 ] + evenone [ i + 1 ] ) ; minimum = Math . Min ( minimum , evenone [ n ] - evenone [ i + 1 ] + oddone [ i + 1 ] ) ; } } return minimum ; }
void shortestpath ( int m , int n ) { List < int > mfactor = new List < int > ( ) ; List < int > nfactor = new List < int > ( ) ; Dictionary < int , int > fre = new Dictionary < int , int > ( ) ; mfactor . Add ( m ) ; fre . Add ( m , 1 ) ; while ( m != 1 ) { if ( isprm ( m ) != 0 ) { mfactor . Add ( 1 ) ; if ( ! fre . ContainsKey ( 1 ) ) fre . Add ( 1 , 1 ) ; m = 1 ; } else { for ( int i = 2 ; i <= Math . Sqrt ( m ) ; i ++ ) { if ( m % i == 0 ) { mfactor . Add ( m / i ) ; if ( ! fre . ContainsKey ( m / i ) ) fre . Add ( m / i , 1 ) ; m = ( m / i ) ; break ; } } } } nfactor . Add ( n ) ; while ( fre . ContainsKey ( n ) && fre [ n ] != 1 ) { if ( isprm ( n ) != 0 ) { nfactor . Add ( 1 ) ; n = 1 ; } else { for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { nfactor . Add ( n / i ) ; n = ( n / i ) ; break ; } } } } for ( int i = 0 ; i < mfactor . Count ; i ++ ) { if ( mfactor [ i ] == n ) break ; Console . Write ( mfactor [ i ] + " <--> " ) ; } for ( int i = nfactor . Count - 1 ; i >= 0 ; i -- ) { if ( i == 0 ) Console . Write ( nfactor [ i ] ) ; else Console . Write ( nfactor [ i ] + " <--> " ) ; } }
int factorial ( int N ) { if ( N <= 0 ) return 1 ; int fact = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = ( fact * i ) % Mod ; } return fact ; }
int noOfFactors ( int N ) { if ( N == 1 ) return 1 ; int count = 0 ; int ans = 1 ; while ( N % 2 == 0 ) { count ++ ; N = N / 2 ; } ans *= ( count / 2 + 1 ) ; for ( int i = 3 ; i * i <= N ; i = i + 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } ans *= ( count / 2 + 1 ) ; } return ans ; }
void minCost ( int N , int M , int vCost , int eCost , int [ ] sorc , ArrayList colored , int [ ] destination ) { ArrayList adj = new ArrayList ( ) ; for ( int i = 0 ; i < N + 1 ; i ++ ) adj . Add ( new ArrayList ( ) ) ; for ( int i = 0 ; i < M ; i ++ ) { ( ( ArrayList ) adj [ sorc [ i ] ] ) . Add ( destination [ i ] ) ; ( ( ArrayList ) adj [ destination [ i ] ] ) . Add ( sorc [ i ] ) ; } int [ ] vis = new int [ N + 1 ] ; for ( int i = 0 ; i < colored . Count ; i ++ ) { DFS ( ( int ) colored [ i ] , vis , adj ) ; } int X = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] == 0 ) { X ++ ; DFS ( i , vis , adj ) ; } } int mincost = X * Math . Min ( vCost , eCost ) ; Console . Write ( mincost ) ; }
double power ( int N , int P ) { return Math . Pow ( N , P ) ; }
void Solve ( int N , int M ) { int temp = ( N - 1 ) * ( M - 1 ) ; int ans = ( int ) ( Math . Pow ( 2 , temp ) ) ; if ( ( N + M ) % 2 != 0 ) Console . Write ( ans ) ; else Console . Write ( 2 * ans ) ; }
void findMaximumLength ( int [ , ] lis ) { id ++ ; length = 0 ; diameter = 0 ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < col ; j ++ ) { if ( lis [ i , j ] != 0 ) { dfs ( i , j , lis ) ; i = row ; break ; } } } id ++ ; length = 0 ; diameter = 0 ; dfs ( x , y , lis ) ; Console . Write ( diameter ) ; }
int maxModulosum ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return sum - n ; }
int noOfPermutations ( int [ ] a , int n ) { if ( n == 1 ) { return 1 ; } Array . Sort ( a ) ; if ( a [ n - 1 ] == a [ n - 2 ] ) { return 0 ; } int x = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( a [ i ] == a [ i + 1 ] ) { if ( a [ i ] == a [ i + 2 ] ) { return 0 ; } x ++ ; i ++ ; } } return pow ( 2 , n - 2 * x - 1 ) ; }
int maxValue ( int [ ] arr , int n , int moves ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { int distance = n - 1 - i ; if ( moves < distance ) break ; int can_take = moves / distance ; int take = Math . Min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; }
bool hasCrest ( int [ ] arr , int n , int L , int R ) { int [ ] present = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { present [ i ] = 0 ; } for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( ( arr [ i ] <= arr [ i + 1 ] ) && ( arr [ i ] <= arr [ i - 1 ] ) ) { present [ i ] = 1 ; } } for ( int i = 1 ; i < n ; i ++ ) { present [ i ] += present [ i - 1 ] ; } if ( present [ L ] == present [ R - 1 ] ) return true ; return false ; }
int getMin ( int [ ] arr , int n ) { int minVal = arr . Min ( ) ; return minVal ; }
int Substring ( String s ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = Math . Max ( ans , temp ) ; temp = 1 ; } } ans = Math . Max ( ans , temp ) ; return ans ; }
int countOp ( int x ) { int [ ] arr = new int [ MAX ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ; int temp = x ; bool flag = true ; int ans = 0 ; int operations = 0 ; bool flag2 = false ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag2 = true ; if ( arr [ i ] > x ) { ans = i ; break ; } } if ( flag2 ) return 0 ; while ( flag ) { if ( arr [ ans ] < x ) ans ++ ; operations ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { int take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) { if ( take > temp ) temp = take ; } } if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; } return operations ; }
int getMinSum ( int [ ] arr , int n ) { int [ ] bits_count = new int [ MAX ] ; int max_bit = 0 , sum = 0 , ans = 0 ; for ( int d = 0 ; d < n ; d ++ ) { int e = arr [ d ] , f = 0 ; while ( e > 0 ) { int rem = e % 2 ; e = e / 2 ; if ( rem == 1 ) { bits_count [ f ] += rem ; } f ++ ; } max_bit = Math . Max ( max_bit , f ) ; } for ( int d = 0 ; d < max_bit ; d ++ ) { int temp = ( int ) Math . Pow ( 2 , d ) ; if ( bits_count [ d ] > n / 2 ) ans = ans + temp ; } for ( int d = 0 ; d < n ; d ++ ) { arr [ d ] = arr [ d ] ^ ans ; sum = sum + arr [ d ] ; } return sum ; }
void replacedArray ( int N , int [ ] arr ) { int pos_sum , neg_sum , i , diff ; pos_sum = 0 ; neg_sum = 0 ; for ( i = N - 1 ; i >= 0 ; i -- ) { diff = Math . Abs ( pos_sum ) - Math . Abs ( neg_sum ) ; if ( arr [ i ] > 0 ) pos_sum += arr [ i ] ; else neg_sum += arr [ i ] ; arr [ i ] = Math . Abs ( diff ) ; } }
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * ( a / n ) * ( b / n ) ; ans += ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( b / n ) ; ans += ( ( a % n ) + ( b % n ) ) / n ; return ans ; }
int minChanges ( int [ ] A , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; }
int solve ( int [ , ] v , int n ) { int ans , ul , ll ; int first = 0 ; int second = 1 ; ll = v [ 0 , first ] ; ul = v [ 0 , second ] ; ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( v [ i , first ] <= ul && v [ i , first ] >= ll ) || ( v [ i , second ] >= ll && v [ i , second ] <= ul ) ) { if ( v [ i , first ] > ll ) { ll = v [ i , first ] ; } if ( v [ i , second ] < ul ) { ul = v [ i , second ] ; } } else if ( v [ i , first ] > ul ) { ans += Math . Abs ( ul - v [ i , first ] ) ; ul = v [ i , first ] ; ll = v [ i , first ] ; } else if ( v [ i , second ] < ll ) { ans += Math . Abs ( ll - v [ i , second ] ) ; ul = v [ i , second ] ; ll = v [ i , second ] ; } } return ans ; }
int steps ( int N , int M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; }
int dfs ( int w ) { if ( cd [ w ] == 0 ) return w ; if ( wt [ w ] < ans ) ans = wt [ w ] ; return dfs ( cd [ w ] ) ; }
void digitsNum ( int N ) { if ( N == 0 ) Console . Write ( "0" ) ; if ( N % 9 != 0 ) Console . Write ( ( N % 9 ) ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) Console . Write ( "9" ) ; for ( int i = 1 ; i <= N ; ++ i ) Console . Write ( "0" ) ; Console . WriteLine ( "" ) ; }
void bestpermutation ( List < int > arr , int k , int n ) { Dictionary < int , int > h = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { h . Add ( arr [ i ] , i ) ; } if ( n <= k ) { arr . Sort ( ) ; arr . Reverse ( ) ; } else { for ( int j = n ; j >= 1 ; j -- ) { if ( k > 0 ) { int initial_index = h [ j ] ; int best_index = n - j ; if ( initial_index != best_index ) { h [ j ] = best_index ; int element = arr [ best_index ] ; h [ element ] = initial_index ; int temp = arr [ best_index ] ; arr [ best_index ] = arr [ initial_index ] ; arr [ initial_index ] = temp ; k -- ; } } } } }
int sumArray ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } return sum ; }
int firstFit ( int [ ] weight , int n , int c ) { int res = 0 ; int [ ] bin_rem = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < res ; j ++ ) { if ( bin_rem [ j ] >= weight [ i ] ) { bin_rem [ j ] = bin_rem [ j ] - weight [ i ] ; break ; } } if ( j == res ) { bin_rem [ res ] = c - weight [ i ] ; res ++ ; } } return res ; }
int find ( int A , int B , int C , int N ) { int [ ] arr = new int [ N ] ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; for ( int i = 3 ; i < N ; i ++ ) { arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] + arr [ i - 3 ] ; } return arr [ N - 1 ] ; }
void maxSum ( int [ , ] arr , int n ) { int r1 = 0 , r2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = r1 ; r1 = Math . Max ( r1 , r2 + arr [ 0 , i ] ) ; r2 = Math . Max ( r2 , temp + arr [ 1 , i ] ) ; } Console . WriteLine ( Math . Max ( r1 , r2 ) ) ; }
int countMinCoins ( int n , int [ ] C , int m ) { if ( n == 0 ) { dp [ 0 ] = 0 ; return 0 ; } if ( dp [ n ] != - 1 ) return dp [ n ] ; int ret = int . MaxValue ; for ( int i = 0 ; i < m ; i ++ ) { if ( C [ i ] <= n ) { int x = countMinCoins ( n - C [ i ] , C , m ) ; if ( x != int . MaxValue ) ret = Math . Min ( ret , 1 + x ) ; } } dp [ n ] = ret ; return ret ; }
void findSolution ( int n , int [ ] C , int m ) { if ( n == 0 ) { foreach ( int it in denomination ) { Console . Write ( it + " " ) ; } return ; } for ( int i = 0 ; i < m ; i ++ ) { if ( n - C [ i ] >= 0 && dp [ n - C [ i ] ] + 1 == dp [ n ] ) { denomination . Add ( C [ i ] ) ; findSolution ( n - C [ i ] , C , m ) ; break ; } } }
int count_unique_sum ( int n ) { int i ; int [ ] ar = new int [ n + 1 ] ; int [ ] fsum = new int [ n + 1 ] ; int [ ] rsum = new int [ n + 1 ] ; int ans = 1 ; for ( i = 0 ; i <= n ; i ++ ) { ar [ i ] = i ; } fsum [ 0 ] = ar [ 0 ] ; rsum [ n ] = ar [ n ] ; for ( i = 1 ; i <= n ; i ++ ) { fsum [ i ] = ar [ i ] + fsum [ i - 1 ] ; } for ( i = n - 1 ; i >= 0 ; i -- ) { rsum [ i ] = ar [ i ] + rsum [ i + 1 ] ; } for ( int k = 2 ; k <= n ; k ++ ) { ans += 1 + rsum [ n + 1 - k ] - fsum [ k - 1 ] ; } return ans ; }
void precompute ( int [ ] nextpos , int [ ] arr , int N ) { nextpos [ N - 1 ] = N ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) nextpos [ i ] = nextpos [ i + 1 ] ; else nextpos [ i ] = i + 1 ; } }
int fun ( int pos , int sum , int st , int check , int f ) { if ( pos == N ) { return ( sum == 0 && check == 1 ) ? 1 : 0 ; } if ( dp [ pos , sum , st , check , f ] != - 1 ) return dp [ pos , sum , st , check , f ] ; int lmt = 9 ; if ( f == 0 ) lmt = v [ pos ] ; int ans = 0 ; for ( int digit = 0 ; digit <= lmt ; digit ++ ) { int nf = f ; int new_sum = ( sum + digit ) % K ; int new_check = check ; int new_st = st ; if ( f == 0 && digit < lmt ) nf = 1 ; if ( check == 0 && digit != 0 ) { new_st = digit ; new_check = 1 ; } if ( pos == N - 1 && new_st == digit ) continue ; ans += fun ( pos + 1 , new_sum , new_st , new_check , nf ) ; } return dp [ pos , sum , st , check , f ] = ans ; }
int minSumProd ( string S , int K ) { int len = S . Length ; if ( K > len ) return - 1 ; if ( K == len ) return 0 ; int [ ] dp = new int [ len ] ; int count_zero = 0 , count_one = 0 ; for ( int j = 0 ; j < len ; j ++ ) { if ( S [ j ] == '0' ) { count_zero ++ ; } else { count_one ++ ; } dp [ j ] = count_zero * count_one ; } for ( int i = 1 ; i < K ; i ++ ) { for ( int j = len - 1 ; j >= i ; j -- ) { count_zero = 0 ; count_one = 0 ; dp [ j ] = Int32 . MaxValue ; for ( int k = j ; k >= i ; k -- ) { if ( S [ k ] == '0' ) { count_zero ++ ; } else { count_one ++ ; } dp [ j ] = Math . Min ( dp [ j ] , count_zero * count_one + dp [ k - 1 ] ) ; } } } return dp [ len - 1 ] ; }
int countPairs ( int [ ] arr , int N ) { int maxm = - int . MaxValue ; for ( int j = 0 ; j < N ; j ++ ) { if ( maxm < arr [ j ] ) { maxm = arr [ j ] ; } } int i , k = 0 ; int [ ] bitscount = new int [ maxm + 1 ] ; Array . Fill ( bitscount , 0 ) ; for ( i = 1 ; i <= maxm ; i *= 2 ) bitscount [ i ] = 1 ; for ( i = 1 ; i <= maxm ; i ++ ) { if ( bitscount [ i ] == 1 ) k = i ; if ( bitscount [ i ] == 0 ) { bitscount [ i ] = bitscount [ k ] + bitscount [ i - k ] ; } } Dictionary < int , int > setbits = new Dictionary < int , int > ( ) ; for ( int j = 0 ; j < N ; j ++ ) { if ( setbits . ContainsKey ( bitscount [ arr [ j ] ] ) ) { setbits [ bitscount [ arr [ j ] ] ] ++ ; } else { setbits [ bitscount [ arr [ j ] ] ] = 1 ; } } int ans = 0 ; foreach ( KeyValuePair < int , int > it in setbits ) { ans += it . Value * ( it . Value - 1 ) / 2 ; } return ans ; }
int solve ( int n , int k , int m ) { if ( n == 0 && k == 0 ) return 1 ; if ( n == 0 && k != 0 ) return 0 ; if ( n != 0 && k == 0 ) return 0 ; if ( n < 0 k < 0 ) return 0 ; if ( dp [ n , k ] > 0 ) return dp [ n , k ] ; int ans = 0 ; for ( int j = 1 ; j <= m ; j ++ ) { ans += solve ( n - j , k - 1 , m ) ; } return dp [ n , k ] = ans ; }
bool isprime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
int productDigitSum ( int x , int y ) { int sumx = 0 ; while ( x > 0 ) { sumx += ( x % 10 ) ; x /= 10 ; } int sumy = 0 ; while ( y > 0 ) { sumy += ( y % 10 ) ; y /= 10 ; } return ( sumx * sumy ) ; }
int CountSets ( int x , int pos ) { if ( x <= 0 ) { if ( pos == 0 ) return 1 ; else return 0 ; } if ( pos == 0 ) return 1 ; if ( dp [ x , pos ] != - 1 ) return dp [ x , pos ] ; int answer = CountSets ( x - 1 , pos ) + CountSets ( x - 2 , pos - 1 ) ; return dp [ x , pos ] = answer ; }
int splitIntoPrimes ( String number ) { if ( number . Length == 0 ) return 0 ; if ( number . Length <= 6 && checkPrime ( number ) ) return 1 ; else { int numLen = number . Length ; int ans = 1000000 ; for ( int i = 1 ; i <= 6 && i <= numLen ; i ++ ) { if ( checkPrime ( number . Substring ( 0 , i ) ) ) { int val = splitIntoPrimes ( number . Substring ( i ) ) ; if ( val != - 1 ) { ans = Math . Min ( ans , 1 + val ) ; } } } if ( ans == 1000000 ) return - 1 ; return ans ; } }
int dp ( int pos , int fl , int pr , String bin ) { if ( pos == bin . Length ) return 1 ; if ( memo [ pos , fl , pr ] != - 1 ) return memo [ pos , fl , pr ] ; int val = 0 ; if ( bin [ pos ] == '0' ) val = val + dp ( pos + 1 , fl , 0 , bin ) ; else if ( bin [ pos ] == '1' ) val = val + dp ( pos + 1 , 1 , 0 , bin ) ; if ( pr == 0 ) { if ( fl == 1 ) { val += dp ( pos + 1 , fl , 1 , bin ) ; } else if ( bin [ pos ] == '1' ) { val += dp ( pos + 1 , fl , 1 , bin ) ; } } return memo [ pos , fl , pr ] = val ; }
int TotalWays ( int n , int s , int k ) { int [ ] dp = new int [ n ] ; dp [ s - 1 ] = 1 ; for ( int i = s ; i < n ; i ++ ) { int idx = Math . Max ( s - 1 , i - k ) ; for ( int j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; }
int solve ( int [ ] arr , int n , int i , int pos ) { if ( i == n ) return 0 ; if ( LAS [ i , pos ] == 1 ) return LAS [ i , pos ] ; int inc = 0 , exc = 0 ; if ( arr [ i ] > 0 && pos == 1 ) { pos = 0 ; inc = 1 + solve ( arr , n , i + 1 , pos ) ; } else if ( arr [ i ] < 0 && pos == 0 ) { pos = 1 ; inc = 1 + solve ( arr , n , i + 1 , pos ) ; } exc = solve ( arr , n , i + 1 , pos ) ; LAS [ i , pos ] = Math . Max ( inc , exc ) ; return LAS [ i , pos ] ; }
int query ( int In , int l , int r , int l1 , int r1 ) { if ( l > r ) return 0 ; if ( r < l1 l > r1 ) return 0 ; if ( l1 <= l && r <= r1 ) return seg [ In ] ; int m = ( l + r ) / 2 ; return query ( 2 * In + 1 , l , m , l1 , r1 ) + query ( 2 * In + 2 , m + 1 , r , l1 , r1 ) ; }
int minMergeCost ( int i , int j , int [ ] arr ) { if ( i == j ) return 0 ; if ( v [ i , j ] ) return dp [ i , j ] ; v [ i , j ] = true ; int x = dp [ i , j ] ; x = int . MaxValue ; int tot = 0 ; for ( int k = i ; k <= j ; k ++ ) tot += arr [ k ] ; for ( int k = i + 1 ; k <= j ; k ++ ) { x = Math . Min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) ; } return x ; }
int numberOfCells ( int [ , ] mat ) { bool [ , ] row = new bool [ N , N ] ; bool [ , ] col = new bool [ N , N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat [ i , j ] == 1 ) { row [ i , j ] = ( j + 1 < N ) ? row [ i , j + 1 ] : true ; } else { row [ i , j ] = false ; } } } for ( int j = 0 ; j < N ; j ++ ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( mat [ i , j ] == 1 ) { col [ i , j ] = ( i + 1 < N ) ? col [ i + 1 , j ] : true ; } else { col [ i , j ] = false ; } } } int cnt = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( row [ i , j ] && col [ i , j ] ) { cnt ++ ; } } } for ( int i = 0 ; i < N ; i ++ ) { if ( col [ i , N - 1 ] ) cnt ++ ; } for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( row [ N - 1 , j ] ) cnt ++ ; } return cnt ; }
int subsequence ( int [ ] S , int [ ] T , int n , int m ) { int [ , ] dp = new int [ n + 1 , m + 1 ] ; int mod = 1000000007 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 ] = 1 ; for ( int j = 0 ; j <= m ; j ++ ) dp [ 0 , j ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { dp [ i , j ] = dp [ i - 1 , j ] + dp [ i , j - 1 ] - dp [ i - 1 , j - 1 ] ; if ( S [ i - 1 ] == T [ j - 1 ] ) dp [ i , j ] += dp [ i - 1 , j - 1 ] ; dp [ i , j ] += mod ; dp [ i , j ] %= mod ; } } return dp [ n , m ] ; }
int findCount ( int n ) { return ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; }
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i , curr ] ) return dp [ i , curr ] ; v [ i , curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i , curr ] = l ; if ( r != - 1 ) dp [ i , curr ] = Math . Max ( dp [ i , curr ] , r + 1 ) ; return dp [ i , curr ] ; }
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i , curr ] ) return dp [ i , curr ] ; v [ i , curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; dp [ i , curr ] = l ; if ( r != - 1 ) dp [ i , curr ] = Math . Max ( dp [ i , curr ] , r + 1 ) ; return dp [ i , curr ] ; }
int countWays ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; }
bool findPath ( List < List < int > > maze , int xpos , int ypos , bool key ) { if ( xpos < 0 >= maze . Count ypos < 0 ypos >= maze . Count ) return false ; if ( maze [ xpos ] [ ypos ] == '1' ) { if ( key == true ) if ( xpos == maze . Count - 1 && ypos == maze . Count - 1 ) return true ; return findPath ( maze , xpos + 1 , ypos , false ) || findPath ( maze , xpos , ypos + 1 , false ) ; } if ( xpos == maze . Count - 1 && ypos == maze . Count - 1 ) return true ; return findPath ( maze , xpos + 1 , ypos , key ) || findPath ( maze , xpos , ypos + 1 , key ) ; }
void findPrefixCount ( int [ ] arr , int n ) { for ( int i = 0 ; i < bitscount ; i ++ ) { prefix_count [ i , 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( int j = 1 ; j < n ; j ++ ) { prefix_count [ i , j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefix_count [ i , j ] += prefix_count [ i , j - 1 ] ; } } }
int countWays ( int n , int l , int r ) { int tL = l , tR = r ; int [ ] L = new int [ 3 ] ; int [ ] R = new int [ 3 ] ; L [ l % 2 ] = l ; R [ r % 2 ] = r ; l ++ ; r -- ; if ( l <= tR && r >= tL ) { L [ l % 2 ] = l ; R [ r % 2 ] = r ; } int cnt0 = 0 , cnt1 = 0 ; if ( R [ 0 ] > 0 && L [ 0 ] > 0 ) cnt0 = ( R [ 0 ] - L [ 0 ] ) / 2 + 1 ; if ( R [ 1 ] > 0 && L [ 1 ] > 0 ) cnt1 = ( R [ 1 ] - L [ 1 ] ) / 2 + 1 ; int [ , ] dp = new int [ n + 1 , 3 ] ; dp [ 1 , 0 ] = cnt0 ; dp [ 1 , 1 ] = cnt1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i , 0 ] = ( cnt0 * dp [ i - 1 , 0 ] + cnt1 * dp [ i - 1 , 1 ] ) ; dp [ i , 1 ] = ( cnt0 * dp [ i - 1 , 1 ] + cnt1 * dp [ i - 1 , 0 ] ) ; } return dp [ n , 0 ] ; }
int dfs ( int node , int parent , int [ ] dp1 , int [ ] dp2 , List < List < int > > adj ) { int firstmax = - 1 ; int secondmax = - 1 ; for ( int i = 0 ; i < adj [ node ] . Count ; ++ i ) { if ( adj [ node ] [ i ] == parent ) continue ; dfs ( adj [ node ] [ i ] , node , dp1 , dp2 , adj ) ; if ( firstmax == - 1 ) { firstmax = dp1 [ adj [ node ] [ i ] ] ; } else if ( dp1 [ adj [ node ] [ i ] ] >= firstmax ) { secondmax = firstmax ; firstmax = dp1 [ adj [ node ] [ i ] ] ; } else if ( dp1 [ adj [ node ] [ i ] ] > secondmax ) { secondmax = dp1 [ adj [ node ] [ i ] ] ; } } dp1 [ node ] = 1 ; dp1 [ node ] += firstmax ; if ( secondmax != - 1 ) dp2 [ node ] = 1 + firstmax + secondmax ; return Math . Max ( dp1 [ node ] , dp2 [ node ] ) ; }
int countRec ( int start , int end , int [ , ] dp , string st ) { int sum = 0 ; if ( start > end ) return 1 ; if ( dp [ start , end ] != - 1 ) return dp [ start , end ] ; int i ; for ( i = start + 1 ; i <= end ; i += 2 ) { if ( checkFunc ( start , i , st ) == 1 ) { sum = sum + countRec ( start + 1 , i - 1 , dp , st ) * countRec ( i + 1 , end , dp , st ) ; } else if ( st [ start ] == '?' && st [ i ] == '?' ) { sum = sum + countRec ( start + 1 , i - 1 , dp , st ) * countRec ( i + 1 , end , dp , st ) * 3 ; } } return dp [ start , end ] = sum ; }
int countWays ( string st ) { int n = st . Length ; if ( n % 2 == 1 ) return 0 ; int [ , ] dp = new int [ MAX , MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) dp [ i , j ] = - 1 ; return countRec ( 0 , n - 1 , dp , st ) ; }
void pre_compute ( char [ , ] a ) { if ( a [ 0 , 0 ] == 'a' ) dp [ 0 , 0 ] = 0 ; else dp [ 0 , 0 ] = 1 ; for ( int row = 0 ; row < n ; row ++ ) { for ( int col = 0 ; col < n ; col ++ ) { if ( row != 0 col != 0 ) dp [ row , col ] = int . MaxValue ; if ( row != 0 ) { dp [ row , col ] = Math . Min ( dp [ row , col ] , dp [ row - 1 , col ] ) ; } if ( col != 0 ) { dp [ row , col ] = Math . Min ( dp [ row , col ] , dp [ row , col - 1 ] ) ; } if ( a [ row , col ] != 'a' && ( row != 0 col != 0 ) ) dp [ row , col ] += 1 ; } } }
int CommomSubsequencesCount ( string s , string t ) { int n1 = s . Length ; int n2 = t . Length ; int [ , ] dp = new int [ n1 + 1 , n2 + 1 ] ; for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { dp [ i , j ] = 0 ; } } for ( int i = 1 ; i <= n1 ; i ++ ) { for ( int j = 1 ; j <= n2 ; j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ] ) dp [ i , j ] = 1 + dp [ i , j - 1 ] + dp [ i - 1 , j ] ; else dp [ i , j ] = dp [ i , j - 1 ] + dp [ i - 1 , j ] - dp [ i - 1 , j - 1 ] ; } } return dp [ n1 , n2 ] ; }
int lcs ( int [ , ] dp , String a , String b , int m , int n ) { for ( int i = 0 ; i < 100 ; i ++ ) for ( int j = 0 ; j < 100 ; j ++ ) dp [ i , j ] = - 1 ; if ( m < 0 n < 0 ) { return 0 ; } if ( dp [ m , n ] != - 1 ) return dp [ m , n ] ; int ans = 0 ; if ( a [ m ] == b [ n ] ) { ans = ( a [ m ] - 48 ) + lcs ( dp , a , b , m - 1 , n - 1 ) ; } else ans = Math . Max ( lcs ( dp , a , b , m - 1 , n ) , lcs ( dp , a , b , m , n - 1 ) ) ; dp [ m , n ] = ans ; return ans ; }
double largestSumOfAverages ( List < int > A , int K ) { int n = A . Count ; double sum = 0 ; for ( int i = 0 ; i < memo . GetLength ( 0 ) ; i ++ ) { for ( int j = 0 ; j < memo . GetLength ( 1 ) ; j ++ ) memo [ i , j ] = 0.0 ; } for ( int i = 0 ; i < n ; i ++ ) { sum += A [ i ] ; memo [ i + 1 , 1 ] = sum / ( i + 1 ) ; } return score ( n , A , K ) ; }
double largestSumOfAverages ( int [ ] A , int K ) { int n = A . Length ; double [ ] pre_sum = new double [ n + 1 ] ; pre_sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; double [ ] dp = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; for ( int k = 0 ; k < K - 1 ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) dp [ i ] = Math . Max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }
int findMaxVal ( int [ ] arr , int n , int num , int maxLimit ) { int ans = 0 ; int ind = 0 ; findMaxValUtil ( arr , n , num , maxLimit , ind , ref ans ) ; return ans ; }
int findMaxVal ( int [ ] arr , int n , int num , int maxLimit ) { int ind ; int val ; int [ , ] dp = new int [ n , maxLimit + 1 ] ; for ( ind = 0 ; ind < n ; ind ++ ) { for ( val = 0 ; val <= maxLimit ; val ++ ) { if ( ind == 0 ) { if ( num - arr [ ind ] == val num + arr [ ind ] == val ) { dp [ ind , val ] = 1 ; } else { dp [ ind , val ] = 0 ; } } else { if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) { if ( dp [ ind - 1 , val - arr [ ind ] ] == 1 dp [ ind - 1 , val + arr [ ind ] ] == 1 ) dp [ ind , val ] = 1 ; } else if ( val - arr [ ind ] >= 0 ) { dp [ ind , val ] = dp [ ind - 1 , val - arr [ ind ] ] ; } else if ( val + arr [ ind ] <= maxLimit ) { dp [ ind , val ] = dp [ ind - 1 , val + arr [ ind ] ] ; } else { dp [ ind , val ] = 0 ; } } } } for ( val = maxLimit ; val >= 0 ; val -- ) { if ( dp [ n - 1 , val ] == 1 ) { return val ; } } return - 1 ; }
int gen ( int n ) { if ( n == 0 ) return 0 ; else if ( n == 1 ) return 1 ; else if ( n % 2 == 0 ) return 4 * gen ( n / 2 ) ; else if ( n % 2 == 1 ) return 4 * gen ( n / 2 ) + 1 ; return 0 ; }
int solve ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = - 1 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) nck [ i , j ] = - 1 ; int currLog2 = - 1 ; int currPower2 = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( currPower2 == i ) { currLog2 ++ ; currPower2 *= 2 ; } log2 [ i ] = currLog2 ; } return numberOfHeaps ( n ) ; }
int largestSubset ( int [ ] a , int n ) { int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) mxm = Math . Max ( mxm , dp [ j ] ) ; dp [ i ] = 1 + mxm ; } return dp . Max ( ) ; }
int maxLenSub ( int [ ] arr , int n ) { int [ ] mls = new int [ n ] ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( Math . Abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
int minimumNumberOfDeletions ( int [ ] arr , int n ) { int len = lis ( arr , n ) ; return ( n - len ) ; }
int countGroups ( int position , int previous_sum , int length , String num ) { if ( position == length ) return 1 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; }
int lenOfLongestGP ( int [ ] Set , int n ) { if ( n < 2 ) { return n ; } if ( n == 2 ) { return ( Set [ 1 ] % Set [ 0 ] == 0 ? 2 : 1 ) ; } Array . Sort ( Set ) ; int [ , ] L = new int [ n , n ] ; int llgp = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( Set [ n - 1 ] % Set [ i ] == 0 ) { L [ i , n - 1 ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i , n - 1 ] = 1 ; } } L [ n - 1 , n - 1 ] = 1 ; for ( int j = n - 2 ; j >= 1 ; -- j ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( Set [ i ] * Set [ k ] < Set [ j ] * Set [ j ] ) { ++ k ; } else if ( Set [ i ] * Set [ k ] > Set [ j ] * Set [ j ] ) { if ( Set [ j ] % Set [ i ] == 0 ) { L [ i , j ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i , j ] = 1 ; } -- i ; } else { if ( Set [ j ] % Set [ i ] == 0 ) { L [ i , j ] = L [ j , k ] + 1 ; if ( L [ i , j ] > llgp ) { llgp = L [ i , j ] ; } } else { L [ i , j ] = 1 ; } -- i ; ++ k ; } } while ( i >= 0 ) { if ( Set [ j ] % Set [ i ] == 0 ) { L [ i , j ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i , j ] = 1 ; } -- i ; } } return llgp ; }
int findMinRec ( int [ ] arr , int i , int sumCalculated , int sumTotal ) { if ( i == 0 ) return Math . Abs ( ( sumTotal - sumCalculated ) - sumCalculated ) ; return Math . Min ( findMinRec ( arr , i - 1 , sumCalculated + arr [ i - 1 ] , sumTotal ) , findMinRec ( arr , i - 1 , sumCalculated , sumTotal ) ) ; }
int findMin ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; bool [ , ] dp = new bool [ n + 1 , sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) dp [ 0 , i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { dp [ i , j ] = dp [ i - 1 , j ] ; if ( arr [ i - 1 ] <= j ) dp [ i , j ] |= dp [ i - 1 , j - arr [ i - 1 ] ] ; } } int diff = int . MaxValue ; for ( int j = sum / 2 ; j >= 0 ; j -- ) { if ( dp [ n , j ] == true ) { diff = sum - 2 * j ; break ; } } return diff ; }
int minSize ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i , j ] = - 1 ; } } return minSizeRec ( arr , 0 , n - 1 , k ) ; }
int minRemovals ( int [ ] arr , int l , int h ) { if ( l >= h ) return 0 ; int mn = min ( arr , l , h ) ; int mx = max ( arr , l , h ) ; if ( 2 * mn > mx ) return 0 ; return min ( minRemovals ( arr , l + 1 , h ) , minRemovals ( arr , l , h - 1 ) ) + 1 ; }
int optimalStrategyOfGame ( int [ ] arr , int n ) { int [ , ] table = new int [ n , n ] ; int gap , i , j , x , y , z ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 , j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 , j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i , j - 2 ] : 0 ; table [ i , j ] = Math . Max ( arr [ i ] + Math . Min ( x , y ) , arr [ j ] + Math . Min ( y , z ) ) ; } } return table [ 0 , n - 1 ] ; }
int lps ( char [ ] seq , int i , int j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return lps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; }
int knapSack ( int W , int [ ] wt , int [ ] val , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
int MatrixChainOrder ( int [ ] p , int i , int j ) { if ( i == j ) return 0 ; int min = int . MaxValue ; for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
void solve ( int [ ] arr , int N ) { Dictionary < int , int > M = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { M . Add ( i , arr [ i ] ) ; } Array . Sort ( arr ) ; Dictionary < int , int > Count = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Count . Add ( arr [ i ] , ( int ) Math . Pow ( 2 , N - i - 1 ) ) ; } foreach ( KeyValuePair < int , int > m in M ) { Console . Write ( Count [ m . Value ] ) ; } }
int min_time_to_cut ( int N ) { if ( N == 0 ) return 0 ; return ( int ) Math . Ceiling ( Math . Log ( N ) / Math . Log ( 2 ) ) ; }
void q3 ( string s , int i ) { if ( i == s . Length ) { Console . WriteLine ( "Yes" ) ; return ; } if ( s [ i ] == 'a' ) q4 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
int nthTerm ( int N ) { int nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
void start ( char c ) { if ( c == 't' c == 'T' ) dfa = 1 ; }
void isEqualSubstring ( string str , int x ) { int n = str . Length ; int i = 0 ; while ( i < n && i < x ) { if ( str [ i ] != str [ n - i - 1 ] ) { Console . Write ( "false" ) ; return ; } i ++ ; } Console . Write ( "true" ) ; }
void canMakeEqual ( String S ) { int N = S . Length ; int weightOfString = 0 ; for ( int i = 0 ; i < N ; i ++ ) { weightOfString += S [ i ] - 'a' + 1 ; } if ( weightOfString % N == 0 ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
void updateTree ( char [ ] s , treeNode [ ] tree , int start , int end , int treenode , int idx , char X ) { if ( ( start == end ) && ( idx == start ) ) { s [ idx ] = X ; tree [ treenode ] . square_sum = ( int ) Math . Pow ( X - 'a' + 1 , 2 ) ; return ; } int mid = start + ( ( end - start ) / 2 ) ; if ( idx <= mid ) { updateTree ( s , tree , start , mid , ( 2 * treenode ) , idx , X ) ; } else { updateTree ( s , tree , mid + 1 , end , ( 2 * treenode ) + 1 , idx , X ) ; } tree [ treenode ] . square_sum = tree [ ( 2 * treenode ) ] . square_sum + tree [ ( 2 * treenode ) + 1 ] . square_sum ; }
void getPalindromePath ( Node root ) { finalAns = "$" ; lexicographicallySmall ( root , "" ) ; if ( finalAns == "$" ) Console . Write ( "No Palindromic Path exists" ) ; else Console . Write ( finalAns ) ; }
int permute ( int n , int r ) { int ans = 0 ; ans = ( fact ( n ) / fact ( n - r ) ) ; return ans ; }
bool isValid ( char a1 , char a2 , string str , int flag ) { char v1 , v2 ; if ( flag == 0 ) { v1 = str [ 4 ] ; v2 = str [ 3 ] ; } else { v1 = str [ 1 ] ; v2 = str [ 0 ] ; } if ( v1 != a1 && v1 != '?' ) { return false ; } if ( v2 != a2 && v2 != '?' ) { return false ; } return true ; }
int minDel ( string s1 , string s2 ) { int i = s1 . Length ; int j = s2 . Length ; while ( i > 0 && j > 0 ) { if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) { break ; } i -- ; j -- ; } return i + j ; }
bool can_Construct ( String S , int K ) { Dictionary < char , int > m = new Dictionary < char , int > ( ) ; int p = 0 ; if ( S . Length == K ) return true ; for ( int i = 0 ; i < S . Length ; i ++ ) if ( ! m . ContainsKey ( S [ i ] ) ) m . Add ( S [ i ] , 1 ) ; else m [ S [ i ] ] = m [ S [ i ] ] + 1 ; if ( K > S . Length ) return false ; else { foreach ( int h in m . Values ) { if ( h % 2 != 0 ) p = p + 1 ; } } if ( K < p ) return false ; return true ; }
int bcdToDecimal ( String s ) { int len = s . Length ; int check = 0 , check0 = 0 ; int num = 0 , sum = 0 ; int mul = 1 , rev = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { sum += ( s [ i ] - '0' ) * mul ; mul *= 2 ; check ++ ; if ( check == 4 i == 0 ) { if ( sum == 0 && check0 == 0 ) { num = 1 ; check0 = 1 ; } else { num = num * 10 + sum ; } check = 0 ; sum = 0 ; mul = 1 ; } } while ( num > 0 ) { rev = rev * 10 + ( num % 10 ) ; num /= 10 ; } if ( check0 == 1 ) return rev - 1 ; return rev ; }
bool isPossibleSum ( int N ) { if ( isPrime ( N ) && isPrime ( N - 2 ) ) { return true ; } else { return false ; } }
void findMaxFrequency ( String s ) { int [ ] arr = new int [ 26 ] ; for ( int i = 0 ; i < s . Length ; i ++ ) arr [ s [ i ] - 'a' ] ++ ; Dictionary < int , int > hash = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] != 0 ) { if ( hash . ContainsKey ( arr [ i ] ) ) { hash [ arr [ i ] ] = hash [ arr [ i ] ] + 1 ; } else { hash . Add ( arr [ i ] , 1 ) ; } } int max_count = 0 , res = - 1 ; foreach ( KeyValuePair < int , int > i in hash ) { if ( max_count < i . Value ) { res = i . Key ; max_count = i . Value ; } } Console . WriteLine ( "Frequency " + res + " is repeated " + max_count + " times" ) ; }
int checkIfStartsWithVowels ( char [ ] str ) { if ( ! ( str [ 0 ] == 'A' str [ 0 ] == 'a' str [ 0 ] == 'E' str [ 0 ] == 'e' str [ 0 ] == 'I' str [ 0 ] == 'i' str [ 0 ] == 'O' str [ 0 ] == 'o' str [ 0 ] == 'U' str [ 0 ] == 'u' ) ) return 1 ; else return 0 ; }
bool xExistsInY ( String x , String y ) { if ( x . Length > y . Length ) return false ; int [ ] cnt_x = new int [ MAX ] ; int [ ] cnt = new int [ MAX ] ; for ( int i = 0 ; i < x . Length ; i ++ ) cnt_x [ x [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < x . Length ; i ++ ) cnt [ y [ i ] - 'a' ] ++ ; if ( areEqual ( cnt_x , cnt ) ) return true ; for ( int i = 1 ; i < y . Length - x . Length + 1 ; i ++ ) { cnt [ y [ i - 1 ] - 'a' ] -- ; cnt [ y [ i + x . Length - 1 ] - 'a' ] ++ ; if ( areEqual ( cnt , cnt_x ) ) return true ; } return false ; }
void updateFreq ( String str , int [ ] freq ) { int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { freq [ str [ i ] - 'a' ] ++ ; } }
int cntWays ( String str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; }
int countSticks ( String str , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ str [ i ] - '0' ] ) ; } return cnt ; }
int countTotalDistinct ( String str ) { int cnt = 0 ; HashSet < String > items = new HashSet < String > ( ) ; for ( int i = 0 ; i < str . Length ; ++ i ) { String temp = "" ; HashSet < char > ans = new HashSet < char > ( ) ; for ( int j = i ; j < str . Length ; ++ j ) { temp = temp + str [ j ] ; ans . Add ( str [ j ] ) ; if ( ! items . Contains ( temp ) ) { items . Add ( temp ) ; cnt += ans . Count ; } } } return cnt ; }
void getOrgString ( String s ) { Console . Write ( s [ 0 ] ) ; int i = 1 ; while ( i < s . Length ) { if ( s [ i ] >= 'A' && s [ i ] <= 'Z' ) Console . Write ( " " + char . ToLower ( s [ i ] ) ) ; else Console . Write ( s [ i ] ) ; i ++ ; } }
int getIndex ( string s1 , string s2 , int len ) { int i = 0 , j = len - 1 ; while ( i < j ) { if ( s1 [ i ] != s2 [ j ] ) { break ; } i ++ ; j -- ; } if ( i == j ) { return i - 1 ; } else if ( isPalindrome ( s2 , i , j ) ) return i - 1 ; else if ( isPalindrome ( s1 , i , j ) ) return j ; return - 1 ; }
int countSubStrings ( String s , String anotherStr , int k ) { bool [ ] illegal = new bool [ MAX_CHAR ] ; for ( int i = 0 ; i < anotherStr . Length ; i ++ ) { illegal [ anotherStr [ i ] ] = true ; } HashSet < String > us = new HashSet < String > ( ) ; for ( int i = 0 ; i < s . Length ; ++ i ) { String ss = "" ; int count = 0 ; for ( int j = i ; j < s . Length ; ++ j ) { if ( illegal [ s [ j ] ] ) { ++ count ; } ss = ss + s [ j ] ; if ( count <= k ) { us . Add ( ss ) ; } else { break ; } } } return us . Count ; }
int PrimeCharacters ( String s ) { bool [ ] prime = new bool [ max_val + 1 ] ; for ( int i = 0 ; i <= max_val ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < s . Length ; ++ i ) { if ( prime [ ( int ) ( s [ i ] ) ] ) count ++ ; } return count ; }
bool matchPattern ( string s ) { int count = 0 ; int n = s . Length ; int i = 0 ; while ( i < n ) { while ( i < n && s [ i ] == 'a' ) { count ++ ; i ++ ; } while ( i < n && s [ i ] == 'b' ) { count -- ; i ++ ; } if ( count != 0 ) return false ; } return true ; }
bool compare ( char [ ] arr1 , char [ ] arr2 ) { for ( int i = 0 ; i < ALL_CHARS ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }
int maximum_one ( string s , int n ) { int cnt_one = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) cnt_one ++ ; } int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; if ( s [ 0 ] == '1' ) left [ 0 ] = 1 ; else left [ 0 ] = 0 ; if ( s [ n - 1 ] == '1' ) right [ n - 1 ] = 1 ; else right [ n - 1 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) left [ i ] = left [ i - 1 ] + 1 ; else left [ i ] = 0 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) right [ i ] = right [ i + 1 ] + 1 ; else right [ i ] = 0 ; } int cnt = 0 , max_cnt = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( s [ i ] == '0' ) { int sum = left [ i - 1 ] + right [ i + 1 ] ; if ( sum < cnt_one ) cnt = sum + 1 ; else cnt = sum ; max_cnt = Math . Max ( max_cnt , cnt ) ; cnt = 0 ; } } return max_cnt ; }
char bitToBeFlipped ( String s ) { char last = s [ s . Length - 1 ] ; char first = s [ 0 ] ; if ( last == first ) { if ( last == '0' ) { return '1' ; } else { return '0' ; } } else if ( last != first ) { return last ; } return last ; }
int countPalindrome ( String str ) { int n = str . Length ; int sum = 0 ; int [ ] hashTable = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { hashTable [ str [ i ] - 'a' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( hashTable [ i ] != 0 ) { sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) / 2 ) ; } } return sum ; }
int smallestNumber ( int n ) { int num = 0 ; String s = "" ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { int digit = s [ i ] - '0' ; if ( ( digit & 1 ) == 0 ) { index = i ; break ; } } if ( index == - 1 ) { return duplicate ; } for ( int i = 0 ; i < index ; i ++ ) { num = num * 10 + ( s [ i ] - '0' ) ; } num = num * 10 + ( s [ index ] - '0' + 1 ) ; for ( int i = index + 1 ; i < s . Length ; i ++ ) { num = num * 10 + 1 ; } return num ; }
int count_carry ( string a , string b ) { int carry = 0 ; int count = 0 ; int len_a = a . Length , len_b = b . Length ; while ( len_a != 0 len_b != 0 ) { int x = 0 , y = 0 ; if ( len_a > 0 ) { x = a [ len_a - 1 ] - '0' ; len_a -- ; } if ( len_b > 0 ) { y = b [ len_b - 1 ] - '0' ; len_b -- ; } int sum = x + y + carry ; if ( sum >= 10 ) { carry = 1 ; count ++ ; } else carry = 0 ; } return count ; }
int leastCount ( string s1 , string s2 , int n ) { int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { count1 [ s1 [ i ] - 'a' ] += 1 ; count2 [ s2 [ i ] - 'a' ] += 1 ; } int res = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( count1 [ i ] != 0 ) { res += Math . Abs ( count1 [ i ] - count2 [ i ] ) ; } } return res ; }
void allCharactersSame ( string s ) { HashSet < char > s1 = new HashSet < char > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) s1 . Add ( s [ i ] ) ; if ( s1 . Count == 1 ) Console . WriteLine ( "YES" ) ; else Console . WriteLine ( "NO" ) ; }
bool check_isogram ( String str ) { int length = str . Length ; int [ ] mapHash = new int [ 26 ] ; for ( int i = 0 ; i < length ; i ++ ) { mapHash [ str [ i ] - 'a' ] ++ ; if ( mapHash [ str [ i ] - 'a' ] > 1 ) { return false ; } } return true ; }
int maxLengthNonPalinSubstring ( String str ) { int n = str . Length ; char ch = str [ 0 ] ; int i = 1 ; for ( i = 1 ; i < n ; i ++ ) if ( str [ i ] != ch ) break ; if ( i == n ) return 0 ; if ( isPalindrome ( str ) ) return n - 1 ; return n ; }
void traverseTree ( Node root ) { if ( root == null ) return ; Console . Write ( root . data + " " ) ; if ( root . child == null ) return ; Queue < Node > q = new Queue < Node > ( ) ; Node curr = root . child ; q . Enqueue ( curr ) ; while ( q . Count != 0 ) { curr = q . Peek ( ) ; q . Dequeue ( ) ; while ( curr != null ) { Console . Write ( curr . data + " " ) ; if ( curr . child != null ) { q . Enqueue ( curr . child ) ; } curr = curr . next ; } } }
void transpose ( int [ , ] mat , int [ , ] tr , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) tr [ i , j ] = mat [ j , i ] ; }
void qType1 ( int l , int x , char [ ] str ) { str [ l - 1 ] = ( char ) x ; }
int getFrequency ( int [ , ] tree , int idx , int i ) { int sum = 0 ; while ( idx > 0 ) { sum += tree [ idx , i ] ; idx -= ( idx & - idx ) ; } return sum ; }
void qType2 ( int [ , ] tree , int l , int r , char [ ] str ) { int count = 0 ; for ( int i = 1 ; i <= 26 ; i ++ ) { if ( l == 1 ) { if ( getFrequency ( tree , r , i ) % 2 == 1 ) count ++ ; } else { if ( ( getFrequency ( tree , r , i ) - getFrequency ( tree , l - 1 , i ) ) % 2 == 1 ) count ++ ; } } if ( count <= 1 ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
int difference ( int [ , ] arr , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i , j ] ; if ( i == n - j - 1 ) d2 += arr [ i , j ] ; } } return Math . Abs ( d1 - d2 ) ; }
bool isValid ( int row , int col ) { return ( row >= 0 ) && ( col >= 0 ) && ( row < ROW ) && ( col < COL ) ; }
long comb ( int n , int r ) { long res = fact [ n ] / fact [ r ] ; res /= fact [ n - r ] ; return res ; }
void getMinPathSum ( Dictionary < int , ArrayList > graph , bool [ ] visited , ArrayList necessary , int source , int dest , int currSum ) { if ( src == dest ) { bool flag = true ; foreach ( int i in necessary ) { if ( ! visited [ i ] ) { flag = false ; break ; } } if ( flag ) minSum = Math . Min ( minSum , currSum ) ; return ; } else { visited [ src ] = true ; foreach ( pair node in graph ) { if ( ! visited [ node . first ] ) { visited [ node . first ] = true ; getMinPathSum ( graph , visited , necessary , node . first , dest , currSum + node . second ) ; visited [ node . first ] = false ; } } visited [ src ] = false ; } }
bool is_clique ( int b ) { for ( int i = 1 ; i < b ; i ++ ) { for ( int j = i + 1 ; j < b ; j ++ ) if ( graph [ store [ i ] , store [ j ] ] == 0 ) return false ; } return true ; }
void generateAllBinaryStrings ( int n , int [ ] arr , int i ) { if ( i == n ) { printTheArray ( arr , n ) ; return ; } arr [ i ] = 0 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; arr [ i ] = 1 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; }
int uniquePaths ( int [ , ] grid ) { int n = grid . GetLength ( 0 ) , m = grid . GetLength ( 1 ) ; bool [ , ] vis = new bool [ n , m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { vis [ i , j ] = false ; } } int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { if ( grid [ i , j ] == 0 ) z_count ++ ; else if ( grid [ i , j ] == 1 ) { x = i ; y = j ; } } } dfs ( x , y , grid , vis , 0 , z_count ) ; return ans ; }
bool isPrime ( int x ) { int sqroot = ( int ) Math . Sqrt ( x ) ; if ( x == 1 ) return false ; for ( int i = 2 ; i <= sqroot ; i ++ ) if ( x % i == 0 ) return false ; return true ; }
int minStepsRecur ( int [ ] height , int l , int r , int h ) { if ( l >= r ) return 0 ; int m = l ; for ( int i = l ; i < r ; i ++ ) if ( height [ i ] < height [ m ] ) m = i ; return Math . Min ( r - l , minStepsRecur ( height , l , m , height [ m ] ) + minStepsRecur ( height , m + 1 , r , height [ m ] ) + height [ m ] - h ) ; }
void findFrequency ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! mp . ContainsKey ( arr [ i ] ) ) mp [ arr [ i ] ] = 0 ; mp [ arr [ i ] ] ++ ; } foreach ( KeyValuePair < int , int > kvp in mp ) Console . WriteLine ( "Element " + kvp . Key + " occurs " + kvp . Value + " times" ) ; }
void secondary_polygon ( int Angle ) { int edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { int edges_max_secondary = edges_primary / 2 ; Console . WriteLine ( edges_max_secondary + 3 ) ; } else Console . WriteLine ( "Not Possible" ) ; }
void parallel ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { if ( ( - ( a1 / b1 ) ) == ( - ( a2 / b2 ) ) ) { Console . Write ( "Yes" ) ; } else { Console . Write ( "No" ) ; } }
int No_of_cubes ( int N , int K ) { int No = 0 ; No = ( N - K + 1 ) ; No = ( int ) Math . Pow ( No , 3 ) ; return No ; }
void updateArray ( int x1 , int y1 , int x2 , int y2 ) { for ( int i = x1 ; i < x2 ; i ++ ) { for ( int j = y1 ; j < y2 ; j ++ ) { arr [ i , j ] = true ; } } }
int calcAngle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) Console . Write ( "Wrong input" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ; int minute_angle = ( int ) ( 6 * m ) ; int angle = Math . Abs ( hour_angle - minute_angle ) ; angle = Math . Min ( 360 - angle , angle ) ; return angle ; }
int heptacontagonNum ( int n ) { return ( 68 * n * n - 66 * n ) / 2 ; }
int octacontagonNum ( int n ) { return ( 78 * n * n - 76 * n ) / 2 ; }
int Pentadecagonal_num ( int n ) { return ( 13 * n * n - 11 * n ) / 2 ; }
int check ( int n , int m ) { if ( m % n == 0 ) { Console . Write ( "YES" ) ; } else { Console . Write ( "NO" ) ; } return 0 ; }
void dist ( double x1 , double y1 , double x2 , double y2 , double r ) { Console . WriteLine ( "The shortest distance " + "between a point and a circle is " + ( Math . Sqrt ( ( Math . Pow ( ( x2 - x1 ) , 2 ) ) + ( Math . Pow ( ( y2 - y1 ) , 2 ) ) ) - r ) ) ; }
float ellipse ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float x = ( float ) ( 3.14 * l * b ) / 4 ; return x ; }
float squareSide ( float a ) { if ( a < 0 ) return - 1 ; float x = ( 0.423f * a ) ; return x ; }
float CubeVolume ( float d ) { float Volume ; Volume = ( float ) ( Math . Sqrt ( 3 ) * Math . Pow ( d , 3 ) ) / 9 ; return Volume ; }
double cyl ( double r , double h ) { if ( r < 0 && h < 0 ) return - 1 ; double R = ( 2 * r ) / 3 ; double H = ( 2 * h ) / 3 ; double V = 3.14 * Math . Pow ( R , 2 ) * H ; return V ; }
float perimeter ( float r ) { return ( float ) ( ( 3.14 ) * ( r ) ) ; }
long hexadecagonalNum ( long n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
int intersection ( int n ) { return n * ( n - 1 ) ; }
int numberOfWays ( int x ) { int [ ] dp = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
void check_and_print ( double required_time , double given_time ) { if ( required_time < given_time ) Console . WriteLine ( "Overflow" ) ; else if ( required_time > given_time ) Console . WriteLine ( "Underflow" ) ; else Console . WriteLine ( "Filled" ) ; }
double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return Math . Sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
int directionOfPoint ( point A , point B , point P ) { B . x -= A . x ; B . y -= A . y ; P . x -= A . x ; P . y -= A . y ; int cross_product = B . x * P . y - B . y * P . x ; if ( cross_product > 0 ) return RIGHT ; if ( cross_product < 0 ) return LEFT ; return ZERO ; }
double areaCube ( double a ) { return ( a * a * a ) ; }
int sqDist ( List < int > p1 , List < int > p2 ) { return ( p1 [ 0 ] - p2 [ 0 ] ) * ( p1 [ 0 ] - p2 [ 0 ] ) + ( p1 [ 1 ] - p2 [ 1 ] ) * ( p1 [ 1 ] - p2 [ 1 ] ) ; }
bool isSquare ( Point p1 , Point p2 , Point p3 , Point p4 ) { if ( d2 == 0 d3 == 0 d4 == 0 ) return false ; if ( d2 == d3 && 2 * d2 == d4 && 2 * distSq ( p2 , p4 ) == distSq ( p2 , p3 ) ) { return true ; } if ( d3 == d4 && 2 * d3 == d2 && 2 * distSq ( p3 , p2 ) == distSq ( p3 , p4 ) ) { return true ; } if ( d2 == d4 && 2 * d2 == d3 && 2 * distSq ( p2 , p3 ) == distSq ( p2 , p4 ) ) { return true ; } return false ; }
int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
int lastPositiveElement ( int [ ] arr ) { int N = arr . Length ; if ( N == 1 ) return arr [ 0 ] ; int greatest = - 1 , secondGreatest = - 1 ; for ( int x = 0 ; x < N ; x ++ ) { if ( arr [ x ] >= greatest ) { secondGreatest = greatest ; greatest = arr [ x ] ; } else if ( arr [ x ] >= secondGreatest ) { secondGreatest = arr [ x ] ; } } return greatest - secondGreatest ; }
int countQuadruples ( int [ ] A , int N ) { int ans = 0 ; Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . ContainsKey ( A [ i ] ) ) ans += freq [ A [ i ] ] ; else freq . Add ( A [ i ] , 0 ) ; for ( int j = 0 ; j < i ; j ++ ) { for ( int k = 0 ; k < j ; k ++ ) { if ( freq . ContainsKey ( A [ i ] * A [ j ] * A [ k ] ) ) freq [ A [ i ] * A [ j ] * A [ k ] ] ++ ; else freq . Add ( A [ i ] * A [ j ] * A [ k ] , 1 ) ; } } } return ans ; }
int countArrays ( int n , int k ) { int mod = 1000000007 ; int ans = power ( n , k , mod ) ; return ans ; }
void printInorder ( Node root ) { if ( root == null ) return ; printInorder ( root . left ) ; Console . Write ( root . data + " " ) ; printInorder ( root . right ) ; }
void countWays ( string s , string t ) { int n = s . Length ; int sum1 = 0 , sum2 = 0 , K = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) { sum1 ++ ; } else sum1 -- ; } int m = t . Length ; for ( int i = 0 ; i < m ; i ++ ) { if ( t [ i ] == '1' ) { sum2 ++ ; } else if ( t [ i ] == '0' ) { sum2 -- ; } else K ++ ; } int P = Math . Abs ( sum1 - sum2 ) ; if ( ( P > K ) || ( ( K - P ) % 2 ) != 0 ) { Console . WriteLine ( 0 ) ; return ; } Console . WriteLine ( nCr ( K , ( P + K ) / 2 ) ) ; }
int pathCountDP ( int [ , ] mat , int k ) { for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) for ( int l = 0 ; l < MAX_K ; l ++ ) dp [ i , j , l ] = - 1 ; return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) ; }
bool isadjacent ( char prev , char curr ) { return ( ( curr - prev ) == 1 ) ; }
int getLen ( char [ , ] mat , char s ) { for ( int i = 0 ; i < R ; ++ i ) for ( int j = 0 ; j < C ; ++ j ) dp [ i , j ] = - 1 ; int ans = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i , j ] == s ) { for ( int k = 0 ; k < 8 ; k ++ ) ans = Math . Max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , s ) ) ; } } } return ans ; }
bool isSmith ( int n ) { int original_no = n ; int pDigitSum = 0 ; for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { while ( n % primes [ i ] == 0 ) { int p = primes [ i ] ; n = n / p ; while ( p > 0 ) { pDigitSum += ( p % 10 ) ; p = p / 10 ; } } } if ( n != 1 && n != original_no ) { while ( n > 0 ) { pDigitSum = pDigitSum + n % 10 ; n = n / 10 ; } } int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits = sumDigits + original_no % 10 ; original_no = original_no / 10 ; } return ( pDigitSum == sumDigits ) ; }
void smallestPermutation ( int [ ] arr , int N ) { bool [ ] w = new bool [ 2 * N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { w [ arr [ i ] ] = true ; } HashSet < int > S = new HashSet < int > ( ) ; for ( int i = 1 ; i <= 2 * N ; i ++ ) { if ( ! w [ i ] ) S . Add ( i ) ; } bool found = true ; List < int > P = new List < int > ( ) ; int [ ] p = { 4 , 5 , 1 , 2 , 3 , 6 } ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . Contains ( arr [ i ] ) ) { found = false ; break ; } P . Add ( arr [ i ] ) ; P . Add ( arr [ i ] ) ; S . Remove ( arr [ i ] ) ; } if ( ! found ) { Console . WriteLine ( "-1" ) ; } else { for ( int i = 0 ; i < 2 * N ; i ++ ) Console . Write ( p [ i ] + " " ) ; } }
int findlcm ( int [ ] arr , int n ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; } return ans ; }
void findLast ( int [ , ] mat ) { int m = 3 ; int n = 3 ; HashSet < int > rows = new HashSet < int > ( ) ; HashSet < int > cols = new HashSet < int > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( mat [ i , j ] > 0 ) ) { rows . Add ( i ) ; cols . Add ( j ) ; } } } int avRows = m - rows . Count ; int avCols = n - cols . Count ; int choices = Math . Min ( avRows , avCols ) ; if ( ( choices & 1 ) != 0 ) Console . WriteLine ( "P1" ) ; else Console . WriteLine ( "P2" ) ; }
void nearestPowerDiff ( int [ ] arr , int N , int a , int b ) { for ( int i = 0 ; i < N ; i ++ ) { int log_a = ( int ) ( Math . Log ( arr [ i ] ) / Math . Log ( a ) ) ; int A = ( int ) ( Math . Pow ( a , log_a ) ) ; int B = ( int ) ( Math . Pow ( a , log_a + 1 ) ) ; if ( ( arr [ i ] - A ) < ( B - arr [ i ] ) ) log_a = A ; else log_a = B ; int log_b = ( int ) ( Math . Log ( arr [ i ] ) / Math . Log ( b ) ) ; A = ( int ) ( Math . Pow ( b , log_b ) ) ; B = ( int ) ( Math . Pow ( b , log_b + 1 ) ) ; if ( ( arr [ i ] - A ) < ( B - arr [ i ] ) ) log_b = A ; else log_b = B ; arr [ i ] = Math . Abs ( log_a - log_b ) ; } printArray ( arr , N ) ; }
bool checkEvenPower ( long N ) { if ( ( N & ( N - 1 ) ) != 0 ) return false ; N = N & 0x55555555 ; return ( N > 0 ) ; }
int distinct ( int [ ] arr , int n ) { HashSet < int > set = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { set . Add ( arr [ i ] ) ; } return set . Count ; }
int power ( int x , int y ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
bool isNonDeficient ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { sum = sum + i ; } else { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum >= 2 * n ; }
int lastElement ( int [ ] arr , int n ) { int sum = 0 ; int multiplier = n % 2 == 0 ? - 1 : 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * multiplier ; multiplier = multiplier * ( n - 1 - i ) / ( i + 1 ) * ( - 1 ) ; } return sum ; }
