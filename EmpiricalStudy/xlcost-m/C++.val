void sumOfTwoPerfectCubes ( int N ) { map < int , int > cubes ; for ( int i = 1 ; i * i * i <= N ; i ++ ) cubes [ i * i * i ] = i ; map < int , int > :: iterator itr ; for ( itr = cubes . begin ( ) ; itr != cubes . end ( ) ; itr ++ ) { int firstNumber = itr -> first ; int secondNumber = N - itr -> first ; if ( cubes . find ( secondNumber ) != cubes . end ( ) ) { cout << "True" ; return ; } } cout << "False" ; }
void SieveOfEratosthenes ( int N ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= N ; i += p ) prime [ i ] = false ; } } }
void checksubarrayExist1_N ( int arr [ ] , int N ) { unordered_map < int , int > pos ; for ( int i = 0 ; i < N ; i ++ ) { pos [ arr [ i ] ] = i ; } set < int > st ; for ( int i = 1 ; i <= N ; i ++ ) { st . insert ( pos [ i ] ) ; int Min = * ( st . begin ( ) ) ; int Max = * ( st . rbegin ( ) ) ; if ( Max - Min + 1 == i ) { cout << "True " ; } else { cout << "False " ; } } }
void reverseCircularArray ( int arr [ ] , int N , int K ) { int start = K , end = K - 1 ; int count = N / 2 ; while ( count -- ) { int temp = arr [ start % N ] ; arr [ start % N ] = arr [ end % N ] ; arr [ end % N ] = temp ; start ++ ; end -- ; if ( end == -1 ) { end = N - 1 ; } } printArray ( arr , N ) ; }
void XOR_for_every_i ( int A [ ] , int N ) { int frequency_of_bits [ 32 ] { } ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int M = A [ i ] ; while ( M ) { if ( M & 1 ) { frequency_of_bits [ bit_position ] += 1 ; } bit_position += 1 ; M >>= 1 ; } } for ( int i = 0 ; i < N ; i ++ ) { int M = A [ i ] ; int value_at_that_bit = 1 ; int XOR_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( M & 1 ) { XOR_sum += ( N - frequency_of_bits [ bit_position ] ) * value_at_that_bit ; } else { XOR_sum += ( frequency_of_bits [ bit_position ] ) * value_at_that_bit ; } M >>= 1 ; value_at_that_bit <<= 1 ; } cout << XOR_sum << ' ' ; } return ; }
void findSum ( int a , int b , int n ) { if ( n == 1 ) { cout << a ; return ; } int s = a + b ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int x = a xor b ; s += x ; a = b ; b = x ; } cout << s ; }
ll countNumbersUtil ( ll N ) { ll count = 0 ; vector < int > digits ; while ( N ) { digits . push_back ( N % 10 ) ; N /= 10 ; } reverse ( digits . begin ( ) , digits . end ( ) ) ; int D = digits . size ( ) ; for ( int i = 1 ; i <= D ; i ++ ) { ll res = getPower ( i ) ; if ( i == D ) { for ( int p = 1 ; p <= D ; p ++ ) { int x = digits [ p - 1 ] ; ll tmp = 0 ; if ( p % 2 == 0 ) { tmp = ( 5 - ( x / 2 + 1 ) ) * getPower ( D - p ) ; } else { tmp = ( 5 - ( x + 1 ) / 2 ) * getPower ( D - p ) ; } res -= tmp ; if ( p % 2 != x % 2 ) { break ; } } } count += res ; } return count ; }
int array_sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
bool check ( int n ) { return 2 * rev ( n ) == n + 1 ; }
int highestPower ( int n ) { return log ( n ) / log ( 2 ) ; }
bool isPrimePossible ( int N ) { string s = to_string ( N ) ; int l = s . length ( ) ; if ( l < 2 ) return false ; for ( int i = 0 ; i < l ; i ++ ) { string str = deleteIth ( s , i ) ; int num = stoi ( str ) ; if ( isPrime ( num ) ) return true ; } return false ; }
bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int findlcm ( int arr [ ] , int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; return ans ; }
void findAandB ( int n , int k ) { int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( freqCount ( to_string ( i ) , ( char ) ( k + 48 ) ) == 0 and freqCount ( to_string ( n - i ) , ( char ) ( k + 48 ) ) == 0 ) { cout << "(" << i << ", " << n - i << ")" ; flag = 1 ; break ; } } if ( flag == 0 ) cout << -1 ; }
int SquareRoot ( int num ) { int count = 0 ; for ( int n = 1 ; n <= num ; n += 2 ) { num = num - n ; count += 1 ; if ( num == 0 ) break ; } return count ; }
void IncrementFactors ( int count [ ] , int val ) { for ( int i = 1 ; i * i <= val ; i ++ ) { if ( val % i == 0 ) { if ( i == val / i ) { count [ i ] ++ ; } else { count [ i ] ++ ; count [ val / i ] ++ ; } } } }
int calcSum ( int k , int n ) { int value = ( k * n * ( n + 1 ) ) / 2 ; return value ; }
void storeDivisors ( int n , vector < int > & div ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) div . push_back ( i ) ; else { div . push_back ( i ) ; div . push_back ( n / i ) ; } } } }
void sieveSundaram ( ) { bool marked [ MAX / 2 + 1 ] = { 0 } ; for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) { for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) { marked [ j ] = true ; } } primes . push_back ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; }
int firstDigit ( int n ) { int digits = ( int ) log10 ( n ) ; n = ( int ) ( n / pow ( 10 , digits ) ) ; return n ; }
long sumOfSumSeries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
bool isTetradic ( int n ) { if ( ispalindrome ( n ) && isContaindigit ( n ) ) return true ; return false ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
vector < int > getRow ( int rowIndex ) { vector < int > currow ; currow . push_back ( 1 ) ; if ( rowIndex == 0 ) { return currow ; } vector < int > prev = getRow ( rowIndex - 1 ) ; for ( int i = 1 ; i < prev . size ( ) ; i ++ ) { int curr = prev [ i - 1 ] + prev [ i ] ; currow . push_back ( curr ) ; } currow . push_back ( 1 ) ; return currow ; }
int gonNum360 ( int n ) { return ( 358 * n * n - 356 * n ) / 2 ; }
int gonNum257 ( int n ) { return ( 255 * n * n - 253 * n ) / 2 ; }
void solve ( int n ) { for ( int x = 1 ; x <= sqrt ( n ) ; x ++ ) { if ( n % x == 0 ) { int small = x ; int big = n / x ; if ( small % 2 == big % 2 ) { int a = ( small + big ) / 2 ; int b = ( big - small ) / 2 ; cout << a << " " << b << endl ; return ; } } } cout << -1 << endl ; }
bool Is_Practical ( int A ) { vector < int > divisors ; divisors = get_divisors ( A ) ; for ( int i = 2 ; i < A ; i ++ ) { if ( Sum_Possible ( divisors , i ) == false ) return false ; } return true ; }
ll operation ( int arr [ ] , int N ) { ll right = 0 , ans = 0 , num = 0 ; for ( ll left = 0 ; left < N ; left ++ ) { while ( right < N && num + arr [ right ] == ( num ^ arr [ right ] ) ) { num += arr [ right ] ; right ++ ; } ans += right - left ; if ( left == right ) right ++ ; else num -= arr [ left ] ; } return ans ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int findMaxSize ( int a [ ] , int n ) { vector < int > frq ( n + 1 ) ; for ( int i = 0 ; i < n ; ++ i ) frq [ a [ i ] ] ++ ; int maxfrq = * max_element ( frq . begin ( ) , frq . end ( ) ) ; int dist = n + 1 - count ( frq . begin ( ) , frq . end ( ) , 0 ) ; int ans1 = min ( maxfrq - 1 , dist ) ; int ans2 = min ( maxfrq , dist - 1 ) ; int ans = max ( ans1 , ans2 ) ; return ans ; }
int minCount ( int n ) { int hasharr [ TEN ] = { 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ; if ( n > 69 ) return hasharr [ n % TEN ] ; else { if ( n >= hasharr [ n % TEN ] * 7 ) return ( hasharr [ n % TEN ] ) ; else return -1 ; } }
long long int power ( lli x , lli y , lli p ) { lli res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
int findMaxSum ( int A [ ] , int B [ ] , int n ) { int maxArr [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { int X = joinNumbers ( A [ i ] , B [ i ] ) ; int Y = joinNumbers ( B [ i ] , A [ i ] ) ; int mx = max ( X , Y ) ; maxArr [ i ] = mx ; } int maxAns = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxAns += maxArr [ i ] ; } return maxAns ; }
long SmallestPerfectSquare ( long N ) { long X = ( long ) 1e9 ; long ans ; for ( int i = 1 ; i < sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { long a = i ; long b = N / i ; if ( ( b - a != 0 ) && ( ( b - a ) % 2 == 0 ) ) { X = min ( X , ( b - a ) / 2 ) ; } } } if ( X != 1e9 ) ans = X * X ; else ans = -1 ; return ans ; }
void PrintReverseOrder ( int N ) { for ( int i = N ; i > 0 ; i -- ) cout << i << " " ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int dfs ( int u , vector < int > * adj , int vis [ ] ) { vis [ u ] = 1 ; int componentSize = 1 ; for ( auto it : adj [ u ] ) { if ( ! vis [ it ] ) { componentSize += dfs ( it , adj , vis ) ; } } return componentSize ; }
void prefix ( ) { for ( int i = 1 ; i < N ; i ++ ) pref [ i ] = pref [ i - 1 ] + phi [ i ] ; }
void findCo_PrimePaths ( struct Node * root , vector < int > & path ) { if ( root == NULL ) return ; path . push_back ( root -> key ) ; findCo_PrimePaths ( root -> left , path ) ; findCo_PrimePaths ( root -> right , path ) ; if ( root -> left == NULL && root -> right == NULL ) { if ( isPathCo_Prime ( path ) ) { printCo_PrimePaths ( path ) ; } } path . pop_back ( ) ; }
void sieve ( ) { position [ 0 ] = -1 , position [ 1 ] = -1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = -1 ; } } }
string permutation ( int arr [ ] , int N ) { int hash [ N + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( hash [ i ] != 1 ) return "No" ; } return "Yes" ; }
bool isDivisible ( int n ) { int d ; while ( n / 100 ) { d = n % 10 ; n /= 10 ; n = abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; }
int countDigit ( int n ) { bool prime [ 10 ] ; memset ( prime , false , sizeof ( prime ) ) ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 && prime [ d ] ) count ++ ; } return count ; }
void maxValue ( int a ) { string c = bitset < 3 > ( a ) . to_string ( ) ; string b = "" ; for ( int i = 0 ; i < c . length ( ) ; i ++ ) { if ( ( c [ i ] - '0' ) == 1 ) b += '0' ; else b += '1' ; } cout << bitset < 3 > ( b ) . to_ulong ( ) ; }
int nextFibonacci ( int n ) { double a = n * ( 1 + sqrt ( 5 ) ) / 2.0 ; return round ( a ) ; }
void preCompute ( ) { for ( int i = 1 ; i < 100001 ; i ++ ) { pref [ i ] = pref [ i - 1 ] + checkArmstrong ( i ) ; } }
void isPrime ( int N ) { bool isPrime = true ; int arr [ 8 ] = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ; if ( N < 2 ) { isPrime = false ; } if ( N % 2 == 0 N % 3 == 0 N % 5 == 0 ) { isPrime = false ; } for ( int i = 0 ; i < sqrt ( N ) ; i += 30 ) { for ( int c : arr ) { if ( c > sqrt ( N ) ) { break ; } else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } } if ( ! isPrime ) break ; } } if ( isPrime ) cout << "Prime Number" ; else cout << "Not a Prime Number" ; }
void perfectCube ( int N ) { int cube ; for ( int i ; i <= N ; i ++ ) { cube = i * i * i ; if ( cube == N ) { cout << "Yes" ; return ; } else if ( cube > N ) { cout << "NO" ; return ; } } }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int count ( int n , int k ) { int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum = sum + binomialCoeff ( n , j ) ; } return sum ; }
int prevPowerofK ( int n , int k ) { int p = ( int ) ( log ( n ) / log ( k ) ) ; return ( int ) pow ( k , p ) ; }
long long kth_element ( int a [ ] , int n , int k ) { vector < int > pos , neg ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) pos . push_back ( a [ i ] ) ; else neg . push_back ( a [ i ] ) ; } sort ( pos . begin ( ) , pos . end ( ) ) ; sort ( neg . begin ( ) , neg . end ( ) ) ; long long l = -1e18 , ans = 0 , r = 1e18 ; while ( l <= r ) { long long mid = ( l + r ) >> 1 ; if ( check ( mid , pos , neg , k ) ) { ans = mid ; r = mid - 1 ; } else l = mid + 1 ; } return ans ; }
int nextNumberDistinctDigit ( int n ) { while ( n < INT_MAX ) { int distinct_digits = countDistinct ( n + 1 ) ; int total_digits = countDigit ( n + 1 ) ; if ( distinct_digits == total_digits ) { return n + 1 ; } else n ++ ; } return -1 ; }
int Count_subarray ( int arr [ ] , int n ) { int total_sum = 0 , subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { subarray_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ; if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; }
long double getSum ( int n ) { long double sum = 0 ; if ( n == 1 ) { sum = 45.0 ; } else { sum = ( 99.0 / 2.0 ) * pow ( 10 , n - 1 ) * pow ( 10 , ( n - 1 ) / 2 ) ; } return sum ; }
int getSize ( struct Node * a ) { int sz = 0 ; while ( a != NULL ) { a = a -> next ; sz ++ ; } return sz ; }
int diameter ( int n ) { int L , H , templen ; L = 1 ; H = 0 ; if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; } while ( L * 2 <= n ) { L *= 2 ; H ++ ; } if ( n >= L * 2 - 1 ) return 2 * H + 1 ; else if ( n >= L + ( L / 2 ) - 1 ) return 2 * H ; return 2 * H - 1 ; }
int countSquares ( int n ) { return ( pow ( n , 2 ) - ( 2 * n ) + 2 ) ; }
int max_element ( int a [ ] , int n ) { int pre [ n ] ; pre [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) ; int suf [ n ] ; suf [ n - 1 ] = a [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) cout << suf [ i + 1 ] << " " ; else if ( i == n - 1 ) cout << pre [ i - 1 ] << " " ; else cout << max ( pre [ i - 1 ] , suf [ i + 1 ] ) << " " ; } }
int cntCells ( int n ) { int cells = pow ( n , 2 ) + pow ( n - 1 , 2 ) ; return cells ; }
void findNums ( int n ) { if ( n <= 11 ) { if ( n == 8 ) cout << "4 4" ; if ( n == 10 ) cout << "4 6" ; else cout << "-1" ; return ; } if ( n % 2 == 0 ) cout << "4 " << ( n - 4 ) ; else cout << "9 " << ( n - 9 ) ; }
int oddFib ( int n ) { n = ( 3 * n + 1 ) / 2 ; int a = -1 , b = 1 , c , i ; for ( i = 1 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n == 2 or n == 3 ) return true ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int difference ( int n ) { int S , res ; S = ( n * ( n + 1 ) ) / 2 ; res = S * ( S - 1 ) ; return res ; }
int findSmallestNonZeroY ( int A_num ) { string A_binary = bitset < 8 > ( A_num ) . to_string ( ) ; int B = 1 ; int length = A_binary . size ( ) ; int no_ones = __builtin_popcount ( A_num ) ; if ( length == no_ones ) return A_num + 1 ; for ( int i = 0 ; i < length ; i ++ ) { char ch = A_binary [ length - i - 1 ] ; if ( ch == '0' ) { B = pow ( 2.0 , i ) ; break ; } } return B ; }
int minimum_elements ( int n , int arr [ ] ) { if ( n < 3 ) return 0 ; int g , ans = 0 , diff , cnt ; diff = arr [ 1 ] - arr [ 0 ] ; g = diff ; for ( int i = 2 ; i < n ; i ++ ) { diff = arr [ i ] - arr [ i - 1 ] ; g = gcd ( g , diff ) ; } for ( int i = 1 ; i < n ; i ++ ) { diff = arr [ i ] - arr [ i - 1 ] ; cnt = diff / g ; ans += ( cnt - 1 ) ; } return ans ; }
void Digits ( int n ) { int largest = 0 ; int smallest = 9 ; while ( n ) { int r = n % 10 ; largest = max ( r , largest ) ; smallest = min ( r , smallest ) ; n = n / 10 ; } cout << largest << " " << smallest ; }
int countWords ( int N , int M ) { return pow ( N , M ) - nPr ( N , M ) ; }
int countBits ( int n ) { int count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; }
int sum_of_4_squares ( int n ) { int i , odd = 0 , even = 0 ; for ( i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i % 2 == 0 ) even += i ; else odd += i ; if ( ( n / i ) != i ) { if ( ( n / i ) % 2 == 0 ) even += ( n / i ) ; else odd += ( n / i ) ; } } } if ( n % 2 == 1 ) return 8 * ( odd + even ) ; else return 24 * ( odd ) ; }
int Maximum_Length ( vector < int > a ) { int counts [ 11 ] = { 0 } ; int ans = 0 ; for ( int index = 0 ; index < a . size ( ) ; index ++ ) { counts [ a [ index ] ] += 1 ; vector < int > k ; for ( auto i : counts ) if ( i != 0 ) k . push_back ( i ) ; sort ( k . begin ( ) , k . end ( ) ) ; if ( k . size ( ) == 1 || ( k [ 0 ] == k [ k . size ( ) - 2 ] && k . back ( ) - k [ k . size ( ) - 2 ] == 1 ) || ( k [ 0 ] == 1 and k [ 1 ] == k . back ( ) ) ) ans = index ; } return ans + 1 ; }
int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; }
int countX ( int a , int b ) { if ( b > a ) return 0 ; else if ( a == b ) return -1 ; else { int x = a - b , ans = 0 ; for ( int i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { int d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = x / i ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } }
bool isSafe ( int N , int M , string str ) { int coll = 0 , colr = 0 , rowu = 0 , rowd = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == 'L' ) { coll ++ ; if ( colr > 0 ) { colr -- ; } if ( coll == M ) { break ; } } else if ( str [ i ] == 'R' ) { colr ++ ; if ( coll > 0 ) { coll -- ; } if ( colr == M ) { break ; } } else if ( str [ i ] == 'U' ) { - rowu ++ ; if ( rowd > 0 ) { rowd -- ; } if ( rowu == N ) { break ; } } else if ( str [ i ] == 'D' ) { rowd ++ ; if ( rowu > 0 ) { rowu -- ; } if ( rowd == N ) { break ; } } } if ( abs ( rowd ) < N && abs ( rowu ) < N && abs ( coll ) < M && abs ( colr ) < M ) { return true ; } return false ; }
int countOnes ( int arr [ ] , int N ) { for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i ; j <= N ; j ++ ) { if ( j % i == 0 ) { if ( arr [ j - 1 ] == 0 ) else  } } } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( arr [ i ] == 1 ) return count ; }
ll power ( ll x , ll y , ll p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int findSum ( int num ) { int sumo = 0 ; int sume = 0 ; int x = 1 ; int cur = 0 ; int ans = 0 ; while ( num > 0 ) { int inc = min ( x , num ) ; num -= inc ; if ( cur == 0 ) { ans = ans + sumodd ( sumo + inc ) - sumodd ( sumo ) ; sumo += inc ; } else { ans = ans + sumeven ( sume + inc ) - sumeven ( sume ) ; sume += inc ; } x *= 2 ; cur ^= 1 ; } return ans ; }
float noOfYears ( int t1 , int n1 , int t2 ) { float years = ( ( t2 - 1 ) * n1 / ( float ) ( t1 - 1 ) ) ; return years ; }
bool isPossible ( int n ) { int fac [ 10 ] ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( int i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; int sum = 0 ; int x = n ; while ( x ) { sum += fac [ x % 10 ] ; x /= 10 ; } if ( sum % n == 0 ) return true ; return false ; }
int countSquares ( int r , int c , int m ) { int squares = 0 ; for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) { if ( max ( abs ( i - r ) , abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; }
int minOperations ( int n , int m ) { if ( m % n != 0 ) return -1 ; int minOperations = 0 ; int q = m / n ; while ( q % 2 == 0 ) { q = q / 2 ; minOperations ++ ; } while ( q % 3 == 0 ) { q = q / 3 ; minOperations ++ ; } if ( q == 1 ) return minOperations ; return -1 ; }
int getCount ( int a , int b , int c ) { int count = 0 ; for ( int i = 1 ; i <= 81 ; i ++ ) { int cr = b * pow ( i , a ) + c ; int tmp = cr ; int sm = 0 ; while ( tmp ) { sm += tmp % 10 ; tmp /= 10 ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; }
bool checkSpecialPrime ( bool * sieve , int num ) { while ( num ) { if ( ! sieve [ num ] ) { return false ; } num /= 10 ; } return true ; }
bool canTakeDown ( int bishopX , int bishopY , int pawnX , int pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }
bool isPossible ( int n , int k , int arr [ ] ) { int sum = arr [ 0 ] , maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = max ( maxVal , arr [ i ] ) ; } if ( ( float ) maxVal > ( float ) ( sum + k ) / n ) return false ; return true ; }
bool checkTriangularSumRepresentation ( int n ) { unordered_set < int > tri ; int i = 1 ; while ( 1 ) { int x = i * ( i + 1 ) / 2 ; if ( x >= n ) break ; tri . insert ( x ) ; i ++ ; } for ( auto tm : tri ) if ( tri . find ( n - tm ) != tri . end ( ) ) return true ; return false ; }
void secondary_polygon ( int Angle ) { int edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { int edges_max_secondary = edges_primary / 2 ; cout << edges_max_secondary + 3 ; } else cout << "Not Possible" ; }
float CPwithProfit ( int sellingPrice , int profit ) { float costPrice ; costPrice = ( sellingPrice * 100.0 ) / ( 100 + profit ) ; return costPrice ; }
int removeZero ( int n ) { int res = 0 ; int d = 1 ; while ( n > 0 ) { if ( n % 10 != 0 ) { res += ( n % 10 ) * d ; d *= 10 ; } n /= 10 ; } return res ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void ETF ( ) { for ( int i = 1 ; i <= n ; i ++ ) { phi [ i ] = i ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( phi [ i ] == i ) { phi [ i ] = i - 1 ; for ( int j = 2 * i ; j <= n ; j += i ) { phi [ j ] = ( phi [ j ] * ( i - 1 ) ) / i ; } } } }
bool checkIsHP ( vector < double > & arr ) { int n = arr . size ( ) ; if ( n == 1 ) { return true ; } vector < int > rec ; for ( int i = 0 ; i < n ; i ++ ) { rec . push_back ( ( 1 / arr [ i ] ) ) ; } sort ( rec . begin ( ) , rec . end ( ) ) ; int d = ( rec [ 1 ] ) - ( rec [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( rec [ i ] - rec [ i - 1 ] != d ) { return false ; } } return true ; }
bool Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return true ; else return false ; }
int solve ( int n , int base ) { int sum = 0 ; while ( n > 0 ) { int remainder = n % base ; sum += remainder ; n = n / base ; } return sum ; }
void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
int findEle ( int arr [ ] , int n ) { ll sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return -1 ; }
bool divisibleBy3 ( string number ) { int sumOfDigit = 0 ; for ( int i = 0 ; i < number . length ( ) ; i ++ ) sumOfDigit += number [ i ] - '0' ; if ( sumOfDigit % 3 == 0 ) return true ; return false ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
int largestNumber ( int n ) { string s = "" ; int duplicate = n ; while ( n ) { s = char ( n % 10 + 48 ) + s ; n /= 10 ; } int index = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( ( s [ i ] - '0' ) % 2 & 1 ) == 0 ) { index = i ; break ; } } if ( index == -1 ) return duplicate ; int num = 0 ; for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; num = num * 10 + ( s [ index ] - '0' - 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 + 9 ; return num ; }
void Sum_upto_nth_Term ( int n ) { int r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; cout << r ; }
int get_unit_digit ( long long int N ) { if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ; return 3 ; }
void SieveOfEratosthenes ( ) { bool prime [ MAX ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } long long int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { product = product * p ; s . insert ( product + 1 ) ; } } }
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
ll findF_N ( ll n ) { ll ans = 0 ; for ( ll i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * ( n - i - 1 ) ; return ans ; }
vector < int > PrimeFactors ( int n ) { vector < int > v ; int x = n ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( x % i == 0 ) { v . push_back ( i ) ; while ( x % i == 0 ) x /= i ; } } if ( x > 1 ) v . push_back ( x ) ; return v ; }
void computeSemiPrime ( ) { memset ( sprime , false , sizeof ( sprime ) ) ; for ( int i = 2 ; i < MAX ; i ++ ) { int cnt = 0 ; int num = i ; for ( int j = 2 ; cnt < 2 && j * j <= num ; ++ j ) { while ( num % j == 0 ) { } } if ( num > 1 ) ++ cnt ; if ( cnt == 2 ) { sprime [ i ] = true ; arr . push_back ( i ) ; } } }
double sumProductDifference ( int a , int b , int c , int d , int e ) { double rootSum = ( double ) ( -1 * b ) / a ; double rootProduct = ( double ) e / a ; return abs ( rootSum - rootProduct ) ; }
double findAnglesA ( double a , double b , double c ) { double A = acos ( ( b * b + c * c - a * a ) / ( 2 * b * c ) ) ; return A * 180 / PI ; }
double findAnglesB ( double a , double b , double c ) { double B = acos ( ( a * a + c * c - b * b ) / ( 2 * a * c ) ) ; return B * 180 / PI ; }
bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; }
int findSum ( int N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }
bool isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = log ( a ) / log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; }
int mostFrequent ( int arr [ ] , int n ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash [ arr [ i ] ] ++ ; int max_count = 0 , res = -1 ; for ( auto i : hash ) { if ( max_count < i . second ) { res = i . first ; max_count = i . second ; } } return res ; }
int Profit ( int costPrice , int sellingPrice ) { int profit = ( sellingPrice - costPrice ) ; return profit ; }
int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; }
bool isPrime ( int num ) { if ( num < 2 num % 2 == 0  ) return num == 2 ; for ( int i = 3 ; i * i <= num ; i += 2 ) if ( num % i == 0 ) return false ; return true ; }
void value ( int a , int b , int c ) { int co = 0 , p = 0 ; int no , r = 0 , x = 0 , q = 0 , w = 0 ; vector < int > v ; for ( int i = 1 ; i < 82 ; i ++ ) { no = pow ( ( double ) i , double ( a ) ) ; no = b * no + c ; if ( no > 0 && no < 1000000000 ) { x = getsum ( no ) ; if ( x == i ) { q ++ ; v . push_back ( no ) ; w ++ ; } } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { cout << v [ i ] << " " ; } }
int countOddSum ( int ar [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int val = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }
void printSeries ( int n ) { int prev = 0 ; int curr ; for ( int i = 1 ; i <= n ; i ++ ) { curr = findTriangularNumber ( i ) ; curr = curr + prev ; cout << curr << " " ; prev = curr ; } }
int rev ( int n , int temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( n / 10 , temp ) ; }
double determinantOfMatrix ( double mat [ 3 ] [ 3 ] ) { double ans ; ans = mat [ 0 ] [ 0 ] * ( mat [ 1 ] [ 1 ] * mat [ 2 ] [ 2 ] - mat [ 2 ] [ 1 ] * mat [ 1 ] [ 2 ] ) - mat [ 0 ] [ 1 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 2 ] - mat [ 1 ] [ 2 ] * mat [ 2 ] [ 0 ] ) + mat [ 0 ] [ 2 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 1 ] - mat [ 1 ] [ 1 ] * mat [ 2 ] [ 0 ] ) ; return ans ; }
int calculateSeries ( int n ) { return 2 + ( n * n + n - 2 ) * factorial ( n + 1 ) ; }
bool isEmirpimes ( int n ) { if ( checkSemiprime ( n ) == false ) return false ; int r = 0 ; for ( int t = n ; t != 0 ; t = t / n ) r = r * 10 + t % 10 ; if ( r == n ) return false ; return ( checkSemiprime ( r ) ) ; }
int isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( -2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return -1 ; float root1 = ( - b + sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && floor ( root1 ) == root1 ) return root1 ; if ( root2 > 0 && floor ( root2 ) == root2 ) return root2 ; return -1 ; }
double calculateProbability ( int N ) { double probability = ( double ) N / ( N + 1 ) ; return probability ; }
int fnMod ( int n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; }
int findHcf ( int * * arr , int size ) { int ans = arr [ 0 ] [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) ans = gcd ( ans , arr [ i ] [ 0 ] ) ; return ( ans ) ; }
int nthTrimorphic ( int n ) { int count = 0 ; for ( int i = 0 ; i < INT_MAX ; i ++ ) { if ( checkTrimorphic ( i ) ) count ++ ; if ( count == n ) return i ; } }
bool check ( int n ) { int m = n ; while ( n ) { int r = n % 10 ; if ( r > 0 ) if ( ( m % r ) != 0 ) return false ; n /= 10 ; } return true ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; }
void generatePrimeFactors ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } }
void quadrant ( int x , int y ) { if ( x > 0 and y > 0 ) cout << "lies in First quadrant" ; else if ( x < 0 and y > 0 ) cout << "lies in Second quadrant" ; else if ( x < 0 and y < 0 ) cout << "lies in Third quadrant" ; else if ( x > 0 and y < 0 ) cout << "lies in Fourth quadrant" ; else if ( x == 0 and y > 0 ) cout << "lies at positive y axis" ; else if ( x == 0 and y < 0 ) cout << "lies at negative y axis" ; else if ( y == 0 and x < 0 ) cout << "lies at negative x axis" ; else if ( y == 0 and x > 0 ) cout << "lies at positive x axis" ; else cout << "lies at origin" ; }
int kthgroupsum ( int k ) { return k * k * k ; }
double kmphTOmph ( double kmph ) { return 0.6214 * kmph ; }
void point ( int a , int b , int c , int d , int n ) { int x , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x = b + i * a ; if ( ( x - d ) % c == 0 and x - d >= 0 ) { cout << x << endl ; flag = 1 ; break ; } } if ( flag == 0 ) { cout << "No collision point" << endl ; } }
int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; }
int isPalindrome ( long n ) { int divide = ( isOctal ( n ) == false ) ? 8 : 10 ; int octal [ MAX_DIGITS ] ; int i = 0 ; while ( n != 0 ) { octal [ i ++ ] = n % divide ; n = n / divide ; } for ( int j = i - 1 , k = 0 ; k <= j ; j -- , k ++ ) if ( octal [ j ] != octal [ k ] ) return false ; return true ; }
bool isThreeDisctFactors ( long long n ) { int sq = ( int ) sqrt ( n ) ; if ( 1LL * sq * sq != n ) return false ; return isPrime ( sq ) ? true : false ; }
void decToHexa ( int n ) { char hexaDeciNum [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = temp + 48 ; i ++ ; } else { hexaDeciNum [ i ] = temp + 55 ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) cout << hexaDeciNum [ j ] ; }
int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; }
unsigned long long firstkdigits ( int n , int k ) { unsigned long long product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product *= n ; while ( ( int ) ( product / pow ( 10 , k ) ) != 0 ) product = product / 10 ; return product ; }
int countDigits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n / 10 ; } return count ; }
int printGenerators ( unsigned int n ) { cout << "1 " ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) cout << i << " " ; }
long int SubArraySum ( int arr [ ] , int n ) { long int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; }
void generateNumbers ( int factor [ ] , int n , int k ) { int next [ k ] = { 0 } ; for ( int i = 0 ; i < n ; ) { int toincrement = 0 ; for ( int j = 0 ; j < k ; j ++ ) if ( next [ j ] < next [ toincrement ] ) toincrement = j ; if ( output != next [ toincrement ] ) { output = next [ toincrement ] ; printf ( "%d " , next [ toincrement ] ) ; i ++ ; } next [ toincrement ] += factor [ toincrement ] ; } }
int sumofproduct ( int n ) { int ans = 0 ; for ( int x = 1 ; x <= n ; x ++ ) { int y = n / x ; ans += ( y * x ) ; } return ans ; }
void findPrimePair ( int n ) { bool isPrime [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime [ i ] && isPrime [ n - i ] ) { cout << i << " " << ( n - i ) ; return ; } } }
long long lcm ( long long n ) { long long ans = 1 ; for ( long long i = 1 ; i <= n ; i ++ ) ans = ( ans * i ) / ( __gcd ( ans , i ) ) ; return ans ; }
void findSmallestPrimeFactors ( ) { for ( int i = 0 ; i < maxn ; i ++ ) smallest_prime [ i ] = INF ; for ( long long i = 2 ; i < maxn ; i ++ ) { if ( smallest_prime [ i ] == INF ) { smallest_prime [ i ] = i ; for ( long long j = i * i ; j < maxn ; j += i ) if ( smallest_prime [ j ] > i ) smallest_prime [ j ] = i ; } } }
void prepareSum ( string s ) { sum [ 0 ] = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) sum [ i + 1 ] = sum [ i ] + toInt ( s [ i ] ) ; }
int oneDigit ( int num ) { return ( num >= 0 && num < 10 ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
void updateBIT ( int BITree [ ] , int n , int index , int val ) { while ( index <= n ) { BITree [ index ] += val ; index += index & ( - index ) ; } }
int nearestSmallerEqFib ( int n ) { if ( n == 0 n == 1 ) return n ; int f1 = 0 , f2 = 1 , f3 = 1 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; }
int mod ( string num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % a ; return res ; }
int replace0with5 ( int number ) { return number += calculateAddedValue ( number ) ; }
int findXOR ( int X ) { int ans = 0 ; while ( X ) { ans ^= ( X % 10 ) ; X /= 10 ; } return ans ; }
int findLen ( int * arr , int n , int m ) { vector < int > filter ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] m ) == m ) filter . push_back ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_or = filter [ 0 ] ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_or |= filter [ i ] ; if ( c_or == m ) return filter . size ( ) ; return 0 ; }
void Add_Edge ( int x , int y ) { al [ x ] . push_back ( y ) ; root_node [ y ] = false ; }
long multiplyByFifteen ( long n ) { long prod = ( n << 4 ) ; prod = prod - n ; return prod ; }
int ternary ( int number ) { int ans = 0 , rem = 1 , base = 1 ; while ( number > 0 ) { rem = number % 3 ; ans = ans + rem * base ; number /= 3 ; base = base * 10 ; } return ans ; }
void ReplaceElements ( int arr [ ] , int n ) { int X = 0 ; for ( int i = 0 ; i < n ; ++ i ) { X ^= arr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = X ^ arr [ i ] ; } }
int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = -1 , startindex ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? -1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += -1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == -1 ) cout << "No such subarray" ; else cout << startindex << " to " << startindex + maxsize - 1 ; return maxsize ; }
int BinaryLifting ( int presum [ ] , int n , int x ) { int pos = 0 ; int LOGN = log2 ( n ) ; if ( x <= presum [ 0 ] ) return 0 ; for ( int i = LOGN ; i >= 0 ; i -- ) { if ( pos + ( 1 << i ) < n && presum [ pos + ( 1 << i ) ] < x ) { pos += ( 1 << i ) ; } } return pos + 1 ; }
int setbitsfromLtoR ( int L , int R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; }
bool isFibbinaryNum ( unsigned int n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; }
int oddbitsetnumber ( int n ) { int count = 0 ; int res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
unsigned int posOfRightmostSetBit ( ull n ) { return log2 ( n & - n ) + 1 ; }
int modifyBit ( int n , int p , int b ) { int mask = 1 << p ; return ( ( n & ~ mask ) | ( b << p ) ) ; }
bool isOnesComplementOfOther ( unsigned int a , unsigned int b ) { return areAllBitsSet ( a ^ b ) ; }
int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; }
static int posOfRightMostSameBit ( int m , int n ) { int loopCounter = 1 ; while ( m > 0 n > 0 ) { bool a = m % 2 == 1 ; bool b = n % 2 == 1 ; if ( ! ( a ^ b ) ) { return loopCounter ; } m = m >> 1 ; n = n >> 1 ; loopCounter ++ ; } return -1 ; }
unsigned int CountZeroBit ( int n ) { unsigned int count = 0 ; while ( n ) { if ( ! ( n & 1 ) ) count ++ ; n >>= 1 ; } return count ; }
long long countPairsWithKDiff ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int xoredNum = arr [ i ] ^ arr [ j ] ; if ( k == bitCount ( xoredNum ) ) ++ ans ; } } return ans ; }
int countTrailingZero ( int x ) { static const int lookup [ ] = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; }
int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }
int findXOR ( int Set [ ] , int n ) { if ( n == 1 ) return Set [ 0 ] ; else return 0 ; }
int findFourElements ( int arr [ ] , int n ) { unordered_map < int , pair < int , int > > mp ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) mp [ arr [ i ] + arr [ j ] ] =  { i , j } ; int d = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = abs ( arr [ i ] - arr [ j ] ) ; if ( mp . find ( abs_diff ) != mp . end ( ) ) { pair < int , int > p = mp [ abs_diff ] ; if ( p . first != i && p . first != j && p . second != i && p . second != j ) d = max ( d , max ( arr [ i ] , arr [ j ] ) ) ; } } } return d ; }
void recaman ( int n ) { if ( n <= 0 ) return ; printf ( "%d, " , 0 ) ; unordered_set < int > s ; s . insert ( 0 ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || s . find ( curr ) != s . end ( ) ) curr = prev + i ; s . insert ( curr ) ; printf ( "%d, " , curr ) ; prev = curr ; } }
int findMin ( int arr [ ] , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; }
void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
void printSmall ( int arr [ ] , int n , int k ) { for ( int i = k ; i < n ; ++ i ) { int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } } if ( max_var > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( int i = 0 ; i < k ; i ++ ) cout << arr [ i ] << " " ; }
int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }
int upperIndex ( int arr [ ] , int n , int y ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] <= y ) l = mid + 1 ; else h = mid - 1 ; } return h ; }
void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " " ; cout << endl ; }
int findPeakUtil ( int arr [ ] , int low , int high , int n ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ; else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return findPeakUtil ( arr , low , ( mid - 1 ) , n ) ; else return findPeakUtil ( arr , ( mid + 1 ) , high , n ) ; }
int maximum ( int a , int b , int c ) { return max ( max ( a , b ) , c ) ; }
void printClosest ( int arr [ ] , int n , int x ) { int res_l , res_r ; int l = 0 , r = n - 1 , diff = INT_MAX ; while ( r > l ) { if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } cout << " The closest pair is " << arr [ res_l ] << " and " << arr [ res_r ] ; }
bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == 1 j == arr [ i ] ) part [ j ] = 1 ; } } return part [ sum / 2 ] ; }
void solveWordWrap ( int l [ ] , int n , int M ) { int extras [ n + 1 ] [ n + 1 ] ; int lc [ n + 1 ] [ n + 1 ] ; int c [ n + 1 ] ; int p [ n + 1 ] ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { extras [ i ] [ i ] = M - l [ i - 1 ] ; for ( j = i + 1 ; j <= n ; j ++ ) extras [ i ] [ j ] = extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ; } for ( i = 1 ; i <= n ; i ++ ) { for ( j = i ; j <= n ; j ++ ) { if ( extras [ i ] [ j ] < 0 ) lc [ i ] [ j ] = INF ; else if ( j == n && extras [ i ] [ j ] >= 0 ) lc [ i ] [ j ] = 0 ; else lc [ i ] [ j ] = extras [ i ] [ j ] * extras [ i ] [ j ] ; } } c [ 0 ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { c [ j ] = INF ; for ( i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != INF && lc [ i ] [ j ] != INF && ( c [ i - 1 ] + lc [ i ] [ j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; }
int optCost ( int freq [ ] , int i , int j ) { if ( j < i ) return 0 ; if ( j == i ) return freq [ i ] ; int fsum = sum ( freq , i , j ) ; int min = INT_MAX ; for ( int r = i ; r <= j ; ++ r ) { int cost = optCost ( freq , i , r - 1 ) + optCost ( freq , r + 1 , j ) ; if ( cost < min ) min = cost ; } return min + fsum ; }
int minCoins ( int coins [ ] , int m , int V ) { if ( V == 0 ) return 0 ; int res = INT_MAX ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != INT_MAX && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }
int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; }
int maximumNumberDistinctPrimeRange ( int m , int n ) { long long factorCount [ n + 1 ] ; bool prime [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( int j = i * 2 ; j <= n ; j += i ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } } int max = factorCount [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = factorCount [ i ] ; num = i ; } } return num ; }
int getSingle ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; }
int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { bool k = 0 ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
int swapBits ( unsigned int x , unsigned int p1 , unsigned int p2 , unsigned int n ) { unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ; unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ; unsigned int Xor = ( set1 ^ set2 ) ; Xor = ( Xor << p1 ) | ( Xor << p2 ) ; unsigned int result = x ^ Xor ; return result ; }
int minSwaps ( int n , int pairs [ ] , int arr [ ] ) { int index [ 2 * n + 1 ] ; for ( int i = 1 ; i <= 2 * n ; i ++ ) index [ arr [ i ] ] = i ; return minSwapsUtil ( arr , pairs , index , 1 , 2 * n ) ; }
int maxOfSegmentMins ( int a [ ] , int n , int k ) { if ( k == 1 ) return * min_element ( a , a + n ) ; if ( k == 2 ) return max ( a [ 0 ] , a [ n - 1 ] ) ; return * max_element ( a , a + n ) ; }
int MinOperation ( int a [ ] , int b [ ] , int n ) { sort ( a , a + n ) ; sort ( b , b + n ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { result = result + abs ( a [ i ] - b [ i ] ) ; } return result ; }
void findMissing ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { if ( M != N - 1 && N != M - 1 ) { cout << "Invalid Input" ; return ; } int res = 0 ; for ( int i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( int i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; cout << "Missing element is " << res ; }
ll calculate ( ll a [ ] , ll n ) { sort ( a , a + n ) ; vector < ll > s ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . push_back ( a [ i ] + a [ j ] ) ; ll mini = * min_element ( s . begin ( ) , s . end ( ) ) ; ll maxi = * max_element ( s . begin ( ) , s . end ( ) ) ; return abs ( maxi - mini ) ; }
long long int findMinSum ( long long int a [ ] , long long int b [ ] , int n ) { sort ( a , a + n ) ; sort ( b , b + n ) ; long long int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + abs ( a [ i ] - b [ i ] ) ; return sum ; }
void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; }
void fun ( int arr [ ] , int k ) { int n = 4 - 1 ; int v = n - k ; if ( v >= 0 ) { reverse ( arr , 0 , v ) ; reverse ( arr , v + 1 , n ) ; reverse ( arr , 0 , n ) ; } }
void rotateSubList ( ListNode * A , int m , int n , int k ) { int size = n - m + 1 ; if ( k > size ) { k = k % size ; } if ( k == 0 k == size ) { ListNode * head = A ; while ( head != NULL ) { cout << head -> data ; head = head -> next ; } return ; } ListNode * link = NULL ; if ( m == 1 ) { link = A ; } ListNode * c = A ; int count = 0 ; ListNode * end = NULL ; ListNode * pre = NULL ; while ( c != NULL ) { count ++ ; if ( count == m - 1 ) { pre = c ; link = c -> next ; } if ( count == n - k ) { if ( m == 1 ) { end = c ; A = c -> next ; } else { end = c ; pre -> next = c -> next ; } } if ( count == n ) { ListNode * d = c -> next ; c -> next = link ; end -> next = d ; ListNode * head = A ; while ( head != NULL ) { cout << head -> data << " " ; head = head -> next ; } return ; } c = c -> next ; } }
void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " " ; }
void createHash ( set < int > & hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } }
void solve ( int N , int M ) { ll ans = ( N ) * ( M / 2 ) ; if ( M % 2 == 1 ) { ans += ( N + 1 ) / 2 ; } cout << ans << endl ; }
int rangeXor ( int BITree [ ] , int l , int r ) { return getXOR ( BITree , r ) ^ getXOR ( BITree , l - 1 ) ; }
int query ( int L , int R ) { return prefix [ R ] - prefix [ L - 1 ] ; }
void game ( int v [ ] , int n ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . find ( v [ i ] ) == m . end ( ) ) m [ v [ i ] ] = 1 ; else m [ v [ i ] ] ++ ; } int count = 0 ; int check = 0 ; for ( auto i : m ) { if ( i . second > 1 ) { if ( i . second >= 4 && i . second % 2 == 0 ) check ++ ; count ++ ; } } if ( check % 2 != 0 ) bool flag = false ; if ( check % 2 != 0 ) cout << "Yes" << endl ; else if ( n % 2 == 0 && count % 2 == 0 ) cout << "No" << endl ; else cout << "Yes" << endl ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < N ; i ++ ) prime [ i ] = 1 ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * p ; i < N ; i += p ) prime [ i ] = 0 ; } } }
unsigned int fact ( unsigned int n ) { return factTR ( n , 1 ) ; }
int maximumMedian ( vector < vector < int > > & arr , int N , int K ) { int low = 0 , high = 1e9 ; while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( isMaximumMedian ( arr , N , K , mid ) ) { low = mid + 1 ; } else { high = mid ; } } return low ; }
void findMinDays ( int arr [ ] , int R [ ] , int N , int X , int K ) { int low = 0 , high = X ; int minDays ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int temp = arr [ i ] + R [ i ] * mid ; if ( temp >= K ) { sum += temp ; } } if ( sum >= X ) { minDays = mid ; high = mid - 1 ; } else { low = mid + 1 ; } } cout << minDays ; }
void maximumIndices ( int arr [ ] , int N ) { int temp [ N ] = { 0 } ; int maxIndices = ( N - 1 ) / 2 ; sort ( arr , arr + N ) ; for ( int i = 0 ; i < maxIndices ; i ++ ) { temp [ 2 * i + 1 ] = arr [ i ] ; } int j = 0 ; for ( int i = maxIndices ; i < N ; ) { if ( temp [ j ] == 0 ) { temp [ j ] = arr [ i ] ; i ++ ; } j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { cout << temp [ i ] << " " ; } }
bool check ( int n , int m , int x , int y , int vl ) { int temp = m ; if ( vl > n ) return false ; int ex = n - vl ; ex *= y ; temp += ex ; int cr = temp / x ; if ( cr >= vl ) return true ; return false ; }
void findPoint ( int * arr , int N , int K ) { int left ; if ( N % 2 ) { left = arr [ N / 2 ] ; } else { left = arr [ N / 2 - 1 ] + 1 ; } int right = arr [ N - 1 ] ; while ( left <= right ) { int mid = ( left + right ) / 2 ; int temp = findSum ( arr , N , mid ) ; if ( temp == K ) { cout << mid << endl ; return ; } else if ( K < temp ) { right = mid - 1 ; } else { left = mid + 1 ; } } left = arr [ 0 ] ; right = arr [ N / 2 ] - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; int temp = findSum ( arr , N , mid ) ; if ( temp == K ) { cout << mid << endl ; return ; } else if ( K > temp ) { right = mid - 1 ; } else { left = mid + 1 ; } } cout << "-1" << endl ; }
int NthComposite ( int N ) { bool IsPrime [ MAX_SIZE ] ; memset ( IsPrime , true , sizeof ( IsPrime ) ) ; for ( int p = 2 ; p * p < MAX_SIZE ; p ++ ) { if ( IsPrime [ p ] == true ) { for ( int i = p * p ; i < MAX_SIZE ; i += p ) IsPrime [ i ] = false ; } } vector < int > Composites ; for ( int p = 4 ; p < MAX_SIZE ; p ++ ) if ( ! IsPrime [ p ] ) Composites . push_back ( p ) ; return Composites [ N - 1 ] ; }
void printArray ( vector < string > res ) { sort ( res . begin ( ) , res . end ( ) ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) { cout << res [ i ] << " " ; } }
int minCount ( int A [ ] , int B [ ] , int N ) { int i = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] == B [ j ] ) { i ++ ; } } return N - i ; }
void minimumNumber ( int K , int X ) { if ( K > X ) { cout << "-1" ; return ; } int low = K , high = X , res = -1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( isGreaterEqual ( mid , K , X ) ) { res = mid ; high = mid - 1 ; } else low = mid + 1 ; } cout << res ; }
int right_search ( vector < int > A , int num ) { int low = 0 , high = A . size ( ) - 1 ; int ans = high ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( A [ mid ] <= num ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; }
int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
void prefixArr ( int arr [ ] , int prefix [ ] [ 2 ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 ) { prefix [ i ] [ 0 ] = arr [ i ] ; prefix [ i ] [ 1 ] = arr [ i ] ; } else { prefix [ i ] [ 0 ] = max ( prefix [ i - 1 ] [ 0 ] , arr [ i ] ) ; prefix [ i ] [ 1 ] = min ( prefix [ i - 1 ] [ 1 ] , arr [ i ] ) ; } } }
void Query ( int arr [ ] , int N , vector < vector < int > > Q ) { int tree [ 4 * N ] = { 0 } ; build_seg_tree ( 0 , N - 1 , 0 , tree , arr ) ; for ( int i = 0 ; i < ( int ) Q . size ( ) ; i ++ ) { if ( Q [ i ] [ 0 ] == 1 ) cout << query ( Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , 0 , N - 1 , 0 , tree ) << " " ; else update ( 0 , N - 1 , 0 , Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , tree , arr ) ; } }
void Sieve ( ) { prime . clear ( ) ; vector < bool > p ( N + 1 , true ) ; p [ 0 ] = p [ 1 ] = false ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( p [ i ] == true ) { for ( int j = i * i ; j <= N ; j += i ) { p [ j ] = false ; } } } for ( int i = 1 ; i < N ; i ++ ) { if ( p [ i ] ) { prime . push_back ( 1LL * pow ( i , 4 ) ) ; } } }
static bool isValidDigit ( int digit , int K ) { while ( K != 0 ) { if ( K % 10 == digit ) { return true ; } K = K / 10 ; } return false ; }
void update ( int index , int s , int e , int new_val , int pos ) { if ( s == e ) Tree [ index ] = new_val ; else { int m = ( s + e ) / 2 ; if ( pos <= m ) { update ( 2 * index , s , m , new_val , pos ) ; } else { update ( 2 * index + 1 , m + 1 , e , new_val , pos ) ; } Tree [ index ] = max ( Tree [ 2 * index ] , Tree [ 2 * index + 1 ] ) ; } }
void printAnswer ( int N , vector < vector < int > > edges ) { for ( int i = 0 ; i <= N ; i ++ ) { parent [ i ] = i ; } for ( int i = 0 ; i < edges . size ( ) ; i ++ ) { connect ( edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; } connectedComponents ( N ) ; }
void countNumbers ( int n , int d ) { int total = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int x = i ; while ( x > 0 ) { if ( x % 8 == d ) { total ++ ; break ; } x = x / 8 ; } } cout << total ; }
int smallestLeft ( int arr [ ] , int total , int sum , int i , vector < vector < int > > & dp ) { if ( i == 0 ) { return abs ( total - 2 * sum ) ; } if ( dp [ i ] [ sum ] != -1 ) return dp [ i ] [ sum ] ; int X = smallestLeft ( arr , total , sum + arr [ i - 1 ] , i - 1 , dp ) ; int Y = smallestLeft ( arr , total , sum , i - 1 , dp ) ; return dp [ i ] [ sum ] = min ( X , Y ) ; }
void findWordsSameRow ( vector < string > & arr ) { unordered_map < char , int > mp { { 'q' , 1 } , { 'w' , 1 } , { 'e' , 1 } , { 'r' , 1 } , { 't' , 1 } , { 'y' , 1 } , { 'u' , 1 } , { 'o' , 1 } , { 'p' , 1 } , { 'i' , 1 } , { 'a' , 2 } , { 's' , 2 } , { 'd' , 2 } , { 'f' , 2 } , { 'g' , 2 } , { 'h' , 2 } , { 'j' , 2 } , { 'k' , 2 } , { 'l' , 2 } , { 'z' , 3 } , { 'x' , 3 } , { 'c' , 3 } , { 'v' , 3 } , { 'b' , 3 } , { 'n' , 3 } , { 'm' , 3 } } ; for ( auto word : arr ) { if ( ! word . empty ( ) ) { bool flag = true ; int rowNum = mp [ tolower ( word [ 0 ] ) ] ; int M = word . length ( ) ; for ( int i = 1 ; i < M ; i ++ ) { if ( mp [ tolower ( word [ i ] ) ] != rowNum ) { flag = false ; break ; } } if ( flag ) { cout << word << " " ; } } } }
int countSubsequece ( int a [ ] , int n ) { int i , j , k , l ; int answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; }
int countSubsequence ( int a [ ] , int n ) { int i , j ; fill_counts ( a , n ) ; int answer = 0 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n - 1 ; j ++ ) { answer += lcount [ a [ j ] ] [ i - 1 ] * rcount [ a [ i ] ] [ j + 1 ] ; } } return answer ; }
int MincntBothPalin ( string str1 , string str2 , int N ) { int i = 0 ; int j = N - 1 ; int cntOp = 0 ; while ( i < j ) { if ( str1 [ i ] == str1 [ j ] && str2 [ i ] != str2 [ j ] ) { cntOp += 1 ; } else if ( str1 [ i ] != str1 [ j ] && str2 [ i ] == str2 [ j ] ) { cntOp += 1 ; } else if ( str1 [ i ] != str1 [ j ] && str2 [ i ] != str2 [ j ] ) { if ( str1 [ i ] == str2 [ j ] && str2 [ i ] == str1 [ j ] ) { cntOp += 1 ; } else { cntOp += 2 ; } } i += 1 ; j -= 1 ; } return cntOp ; }
bool isValid ( int wood [ ] , int N , int len , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { count += wood [ i ] / len ; } return count >= K ; }
bool isMorannumber ( int n ) { int dup = n ; int sum = digiSum ( dup ) ; if ( n % sum == 0 ) { int c = n / sum ; if ( isPrime ( c ) ) { return true ; } } return false ; }
int maxEqualIdx ( vector < int > arr , int k ) { sort ( arr . begin ( ) , arr . end ( ) ) ; vector < int > prefixSum ( arr . size ( ) ) ; prefixSum [ 1 ] = arr [ 0 ] ; for ( int i = 1 ; i < prefixSum . size ( ) - 1 ; ++ i ) { prefixSum [ i + 1 ] = prefixSum [ i ] + arr [ i ] ; } int max = arr . size ( ) ; int min = 1 ; int ans = 1 ; while ( min <= max ) { int mid = ( max + min ) / 2 ; if ( check ( prefixSum , mid , k , arr ) ) { ans = mid ; min = mid + 1 ; } else { max = mid - 1 ; } } return ans ; }
bool sfpa ( int V , int src , int Edges [ ] [ 3 ] , int M ) { vector < pair < int , int > > g [ V ] ; for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i ] [ 0 ] ; int v = Edges [ i ] [ 1 ] ; int w = Edges [ i ] [ 2 ] ; g [ u ] . push_back ( { v , w } ) ; } vector < int > dist ( V , INT_MAX ) ; vector < bool > inQueue ( V , false ) ; vector < int > cnt ( V , 0 ) ; dist [ src ] = 0 ; queue < int > q ; q . push ( src ) ; inQueue [ src ] = true ; while ( ! q . empty ( ) ) { int u = q . front ( ) ; q . pop ( ) ; inQueue [ u ] = false ; for ( pair < int , int > x : g [ u ] ) { int v = x . first ; int cost = x . second ; if ( dist [ v ] > dist [ u ] + cost ) { dist [ v ] = dist [ u ] + cost ; if ( ! inQueue [ v ] ) { q . push ( v ) ; inQueue [ v ] = true ; cnt [ v ] ++ ; if ( cnt [ v ] >= V ) return true ; } } } } return false ; }
int countNum ( int N , int sum , int K , bool st , int dp [ M ] [ M ] [ 2 ] ) { if ( N == 0 and sum == 0 ) { return 1 ; } if ( N < 0 ) { return 0 ; } if ( dp [ N ] [ sum ] [ st ] != -1 ) { return dp [ N ] [ sum ] [ st ] ; } int res = 0 ; int start = st == 1 ? 0 : 1 ; for ( int i = start ; i <= 9 ; i ++ ) { res += countNum ( N - 1 , ( sum + i ) % K , K , ( st i > 0 ) , dp ) ; } return dp [ N ] [ sum ] [ st ] = res ; }
int hIndex ( vector < int > citations , int n ) { int hindex = 0 ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( citations [ mid ] >= ( mid + 1 ) ) { low = mid + 1 ; hindex = mid + 1 ; } else { high = mid - 1 ; } } cout << hindex << endl ; return hindex ; }
int countNodes ( int V , int E , int src , int dest , int edges [ ] [ 2 ] ) { vector < int > adj [ V + 1 ] ; for ( int i = 0 ; i < E ; i ++ ) { adj [ edges [ i ] [ 0 ] ] . push_back ( edges [ i ] [ 1 ] ) ; adj [ edges [ i ] [ 1 ] ] . push_back ( edges [ i ] [ 0 ] ) ; } int vis [ V + 1 ] = { 0 } ; int count = dfs ( src , dest , vis , adj ) ; return count - 2 ; }
int longestGP ( int A [ ] , int N ) { if ( N < 2 ) return N ; int length = 1 , common_ratio = 1 ; int maxlength = 1 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i + 1 ] % A [ i ] == 0 ) { if ( A [ i + 1 ] / A [ i ] == common_ratio ) { length = length + 1 ; maxlength = max ( maxlength , length ) ; } else { common_ratio = A [ i + 1 ] / A [ i ] ; length = 2 ; } } else { maxlength = max ( maxlength , length ) ; length = 1 ; } } maxlength = max ( maxlength , length ) ; return maxlength ; }
void add_seg ( int seg [ ] , int start , int end , int current , int index ) { if ( index > end or index < start ) return ; if ( start == end ) { seg [ current ] = 1 ; return ; } int mid = ( start + end ) / 2 ; add_seg ( seg , start , mid , 2 * current + 1 , index ) ; add_seg ( seg , mid + 1 , end , 2 * current + 2 , index ) ; seg [ current ] = seg [ 2 * current + 1 ] + seg [ 2 * current + 2 ] ; }
int getPrefixLength ( string srcStr , string targetStr ) { if ( targetStr . length ( ) == 0 ) return 0 ; transform ( srcStr . begin ( ) , srcStr . end ( ) , srcStr . begin ( ) , :: tolower ) ; transform ( targetStr . begin ( ) , targetStr . end ( ) , targetStr . begin ( ) , :: tolower ) ; map < char , int > dictCount ; int nUnique = 0 ; for ( char ch : targetStr ) { if ( dictCount . find ( ch ) == dictCount . end ( ) ) { nUnique += 1 ; dictCount [ ch ] = 0 ; } dictCount [ ch ] += 1 ; } for ( int i = 0 ; i < srcStr . length ( ) ; i ++ ) { char ch = srcStr [ i ] ; if ( dictCount . find ( ch ) == dictCount . end ( ) ) continue ; dictCount [ ch ] -= 1 ; if ( dictCount [ ch ] == 0 ) nUnique -= 1 ; if ( nUnique == 0 ) return ( i + 1 ) ; } return -1 ; }
int minOperations ( string S , int K ) { int ans = 0 ; for ( int i = 0 ; i < K ; i ++ ) { int zero = 0 , one = 0 ; for ( int j = i ; j < S . size ( ) ; j += K ) { if ( S [ j ] == '0' ) zero ++ ; else one ++ ; } ans += min ( zero , one ) ; } return ans ; }
int func ( int A , int B , int C , int x ) { return ( A * x * x + B * x + C ) ; }
int minDays ( vector < int > & arr , int n , int k ) { int l = arr . size ( ) , left = 1 , right = 1e9 ; if ( n * k > l ) return -1 ; while ( left < right ) { int mid = ( left + right ) / 2 , cnt = 0 , product = 0 ; for ( int j = 0 ; j < l ; ++ j ) { if ( arr [ j ] > mid ) { cnt = 0 ; } else if ( ++ cnt >= k ) { product ++ ; cnt = 0 ; } } if ( product < n ) { left = mid + 1 ; } else { right = mid ; } } return left ; }
int minimumMoves ( string S , int K ) { int N = S . length ( ) ; int ops = 0 ; int last_idx = -1 ; for ( int i = 0 ; i < K ; i ++ ) { if ( S [ i ] == '1' ) last_idx = i ; } if ( last_idx == -1 ) { ++ ops ; S [ K - 1 ] = '1' ; last_idx = K - 1 ; } for ( int i = 1 ; i < N - K + 1 ; i ++ ) { if ( last_idx < i ) last_idx = -1 ; if ( S [ i + K - 1 ] == '1' ) last_idx = i + K - 1 ; if ( last_idx == -1 ) { ++ ops ; S [ i + K - 1 ] = '1' ; last_idx = i + K - 1 ; } } return ops ; }
int missingElement ( int arr [ ] , int n ) { int max_ele = arr [ 0 ] ; int min_ele = arr [ 0 ] ; int x = 0 ; int d ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; if ( arr [ i ] < min_ele ) min_ele = arr [ i ] ; } d = ( max_ele - min_ele ) / n ; for ( int i = 0 ; i < n ; i ++ ) { x = x ^ arr [ i ] ; } for ( int i = 0 ; i <= n ; i ++ ) { x = x ^ ( min_ele + ( i * d ) ) ; } return x ; }
int longestPermutation ( int a [ ] , int n ) { map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; } int len = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( freq [ i ] == 0 ) { break ; } len ++ ; } return len ; }
int findColor ( map < int , int > mapWithColor , int query ) { int maximum = 0 ; while ( query >= 1 ) { if ( mapWithColor . find ( query ) != mapWithColor . end ( ) ) { maximum = max ( maximum , mapWithColor [ query ] ) ; } if ( query % 2 == 1 ) query = ( query - 1 ) / 2 ; else query = query / 2 ; } return maximum ; }
int findlength ( string str , int n , int k ) { int maxLen = 0 ; int freq [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { setZero ( freq ) ; for ( int j = i ; j < n ; j ++ ) { freq [ str [ j ] - 'a' ] ++ ; if ( atLeastK ( freq , k ) ) { maxLen = max ( maxLen , j - i + 1 ) ; } } } return maxLen ; }
int maxSumArray ( int arr [ ] , int n ) { int sum = 0 ; unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; mp [ arr [ i ] ] ++ ; } int minimum = INT_MAX ; for ( auto x : mp ) minimum = min ( minimum , x . second * x . first ) ; return ( sum - minimum ) ; }
void create_table ( int n ) { int pow = 1 ; int co = 0 ; do { pow <<= 1 ; lookup_table [ co ] = ( n + ( pow >> 1 ) ) / pow ; } while ( lookup_table [ co ++ ] != 0 ) ; }
int costToPanagram ( string str , int cost [ ] ) { int i , n = str . length ( ) ; int occurrences [ 26 ] = { 0 } ; for ( i = 0 ; i < n ; i ++ ) occurrences [ str [ i ] - 'a' ] ++ ; int gain = 0 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( occurrences [ i ] == 0 ) gain -= ( 2 * cost [ i ] ) ; else if ( occurrences [ i ] > 1 ) gain += ( cost [ i ] * ( occurrences [ i ] - 1 ) ) ; } if ( gain >= 0 ) return 0 ; return ( gain * -1 ) ; }
int strScore ( string str [ ] , string s , int n ) { unordered_map < string , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ str [ i ] ] = i + 1 ; if ( m . find ( s ) == m . end ( ) ) return 0 ; int score = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) score += s [ i ] - 'a' + 1 ; score = score * m [ s ] ; return score ; }
string replacePi ( string input ) { string output ; int size = input . length ( ) ; for ( int i = 0 ; i < size ; ++ i ) { if ( i + 1 < size and input [ i ] == 'p' and input [ i + 1 ] == 'i' ) { output += "3.14" ; i ++ ; } else { output += input [ i ] ; } } return output ; }
bool check_pair_product ( struct Node * head , int prod ) { unordered_set < int > s ; struct Node * p = head ; while ( p != NULL ) { int curr = p -> data ; if ( ( prod % curr == 0 ) && ( s . find ( prod / curr ) != s . end ( ) ) ) { cout << curr << " " << prod / curr ; return true ; } s . insert ( p -> data ) ; p = p -> next ; } return false ; }
int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { int j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; }
int totalNumbersWithSpecificDifference ( int N , int diff ) { int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( mid - sumOfDigit ( mid ) < diff ) low = mid + 1 ; else high = mid - 1 ; } return ( N - high ) ; }
int computeCost ( int arr [ ] , int N , int X ) { int cost = 0 ; for ( int i = 0 ; i < N ; i ++ ) cost += abs ( arr [ i ] - X ) ; return cost ; }
void insertionSort ( int arr [ ] , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } }
void minimumRange ( int arr [ ] , int N , int K ) { if ( K >= N ) { cout << 0 ; return ; } sort ( arr , arr + N ) ; int left = 0 , right = N - 1 , i ; for ( i = 0 ; i < K ; i ++ ) { if ( arr [ right - 1 ] - arr [ left ] < arr [ right ] - arr [ left + 1 ] ) right -- ; else left ++ ; } cout << arr [ right ] - arr [ left ] ; }
int minimum_possible_sum ( int arr [ ] , int n , int k ) { if ( n == 0 ) { return 0 ; } if ( n == 1 ) { return arr [ 0 ] ; } for ( int i = 0 ; i < k ; i ++ ) { int smallest_element = arr [ 0 ] ; int smallest_pos = 0 ; int largest_element = arr [ 0 ] ; int largest_pos = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] >= largest_element ) { largest_element = arr [ i ] ; largest_pos = i ; } if ( arr [ i ] < smallest_element ) { smallest_element = arr [ i ] ; smallest_pos = i ; } } int a = smallest_element * 2 ; int b = largest_element / 2 ; if ( a + b < smallest_element + largest_element ) { arr [ smallest_pos ] = a ; arr [ largest_pos ] = b ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += arr [ i ] ; } return ans ; }
int XorSum ( int A [ ] , int B [ ] , int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { ans = ans ^ ( A [ i ] + B [ j ] ) ; } } return ans ; }
int findCount ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int result = 1 ; int cur_max = arr [ 0 ] ; int cur_min = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { cur_max = arr [ i ] ; if ( cur_max - cur_min > K ) { result ++ ; cur_max = arr [ i ] ; cur_min = arr [ i ] ; } } return result ; }
void checkToMakeEqual ( string S1 , string S2 ) { int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < S1 . length ( ) ; i ++ ) { freq [ S1 [ i ] - 'a' ] ++ ; } bool flag = 0 ; for ( int i = 0 ; i < S2 . length ( ) ; i ++ ) { if ( freq [ S2 [ i ] - 'a' ] == 0 ) { flag = true ; break ; } freq [ S2 [ i ] - 'a' ] -- ; } if ( flag == true ) { cout << "No\n" ; return ; } int invCount1 = inversionCount ( S1 ) ; int invCount2 = inversionCount ( S2 ) ; if ( invCount1 == invCount2 || ( invCount1 & 1 ) == ( invCount2 & 1 ) || haveRepeated ( S1 , S2 ) ) { cout << "Yes\n" ; } else cout << "No\n" ; }
int findKthSmallest ( int arr [ ] , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } int counter [ max + 1 ] = { 0 } ; int smallest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; } for ( int num = 1 ; num <= max ; num ++ ) { if ( counter [ num ] > 0 ) { smallest += counter [ num ] ; } if ( smallest >= k ) { return num ; } } }
void printArr ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; if ( arr [ 0 ] == arr [ n - 1 ] ) { cout << "No" << endl ; } else { cout << "Yes" << endl ; for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << " " ; } } }
int countVowels ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) ++ count ; return count ; }
int findSum ( int * arr , int n , int k ) { int ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) { ans = min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }
int cntElements ( int arr [ ] , int n ) { int copy_arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; int count = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; }
void UpdateArr ( int arr [ ] , int n ) { int i = 0 , j = n - 1 ; while ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i += 2 ; j -= 2 ; } printArr ( arr , n ) ; }
void pre ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; } }
void sieve ( ll n ) { for ( int i = 2 ; i <= n ; i += 1 ) { prime [ i ] = 1 ; } for ( ll p = 2 ; ( ll ) p * ( ll ) p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( ll i = ( ll ) p * ( ll ) p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( ll p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) pr . push_back ( p ) ; }
ll SemiPrimeSum ( ll N ) { ll ans = 0 ; for ( int i = 0 ; i < pr . size ( ) ; i += 1 ) { for ( int j = i ; j < pr . size ( ) ; j += 1 ) { if ( ( ll ) pr [ i ] * ( ll ) pr [ j ] > N ) break ; ans += ( ll ) pr [ i ] * ( ll ) pr [ j ] ; } } return ans ; }
void quickSort ( char arr [ ] , int low , int high , int mod ) { if ( low < high ) { int pi = partition ( arr , low , high , mod ) ; quickSort ( arr , low , pi - 1 , mod ) ; quickSort ( arr , pi + 1 , high , mod ) ; } }
int maxWater ( int height [ ] , int n ) { int maximum = 0 ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( height [ i ] < height [ j ] ) { maximum = max ( maximum , ( j - i - 1 ) * height [ i ] ) ; i ++ ; } else if ( height [ j ] < height [ i ] ) { maximum = max ( maximum , ( j - i - 1 ) * height [ j ] ) ; j -- ; } else { maximum = max ( maximum , ( j - i - 1 ) * height [ i ] ) ; i ++ ; j -- ; } } return maximum ; }
bool check ( string str ) { int min = INT_MAX ; int max = - INT_MAX ; int sum = 0 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { int ascii = str [ i ] ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; int eSum = ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; }
void findNumbers ( int arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; int freq [ arr [ 0 ] + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int size = sqrt ( n ) ; int brr [ size ] = { 0 } , x , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ arr [ i ] ] > 0 ) { brr [ l ] = arr [ i ] ; freq [ brr [ l ] ] -- ; l ++ ; for ( int j = 0 ; j < l ; j ++ ) { if ( i != j ) { x = __gcd ( arr [ i ] , brr [ j ] ) ; freq [ x ] -= 2 ; } } } } printArr ( brr , size ) ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << ( arr [ i ] ) << " " ; }
void merge_and_sort ( int * output , int arr [ ] [ N ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { output [ i * n + j ] = arr [ i ] [ j ] ; } } sort ( output , output + n * k ) ; }
void AlternateRearrange ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) v1 . push_back ( arr [ i ] ) ; else v2 . push_back ( arr [ i ] ) ; int index = 0 , i = 0 , j = 0 ; bool flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ++ ] = v1 [ i ++ ] ; flag = ! flag ; } else { arr [ index ++ ] = v2 [ j ++ ] ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
int getNumToAdd ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int d = arr [ 1 ] - arr [ 0 ] ; int numToAdd = -1 ; bool numAdded = false ; for ( int i = 2 ; i < n ; i ++ ) { int diff = arr [ i ] - arr [ i - 1 ] ; if ( diff != d ) { if ( numAdded ) return -1 ; if ( diff == 2 * d ) { numToAdd = arr [ i ] - d ; numAdded = true ; } else return -1 ; } } if ( numToAdd == -1 ) return ( arr [ n - 1 ] + d ) ; return numToAdd ; }
int PointInKSquares ( int n , int a [ ] , int k ) { sort ( a , a + n ) ; return a [ n - k ] ; }
int maxArrayCover ( vector < int > a , int n , int x ) { sort ( a . begin ( ) , a . end ( ) ) ; int cc = 0 ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += a [ i ] ; if ( s > x ) { break ; } cc += 1 ; } if ( accumulate ( a . begin ( ) , a . end ( ) , 0 ) == x ) { return n ; } else { if ( cc == n ) { return n - 1 ; } else { return cc ; } } }
int findMaxNum ( int arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; int num = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { num = num * 10 + arr [ i ] ; } return num ; }
void sort ( int arr [ ] , int n ) { int index = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 999 ) { index = i ; break ; } } if ( index == -1 ) return ; sortRec ( arr , index , n , n ) ; }
void merge ( int * arr1 , int * arr2 , int n , int m ) { int i , j , gap = n + m ; for ( gap = nextGap ( gap ) ; gap > 0 ; gap = nextGap ( gap ) ) { for ( i = 0 ; i + gap < n ; i ++ ) if ( arr1 [ i ] > arr1 [ i + gap ] ) swap ( arr1 [ i ] , arr1 [ i + gap ] ) ; for ( j = gap > n ? gap - n : 0 ; i < n && j < m ; i ++ , j ++ ) if ( arr1 [ i ] > arr2 [ j ] ) swap ( arr1 [ i ] , arr2 [ j ] ) ; if ( j < m ) { for ( j = 0 ; j + gap < m ; j ++ ) if ( arr2 [ j ] > arr2 [ j + gap ] ) swap ( arr2 [ j ] , arr2 [ j + gap ] ) ; } } }
int _mergeSort ( int arr [ ] , int temp [ ] , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; }
void printSorted ( int a , int b , int c ) { int get_max = max ( a , max ( b , c ) ) ; int get_min = - max ( - a , max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; cout << get_min << " " << get_mid << " " << get_max ; }
int countSwaps ( int arr [ ] , int n ) { int temp [ n ] ; return _mergeSort ( arr , temp , 0 , n - 1 ) ; }
void pancakeSort ( int * arr , int n ) { for ( int curr_size = n ; curr_size > 1 ; -- curr_size ) { int mi = findMax ( arr , curr_size ) ; if ( mi != curr_size - 1 ) { flip ( arr , mi ) ; flip ( arr , curr_size - 1 ) ; } } }
string largestMerge ( string word1 , string word2 ) { string merge = "" ; while ( word1 . size ( ) != 0 || word2 . size ( ) != 0 ) { if ( word1 >= word2 ) { merge = merge + word1 [ 0 ] ; word1 . erase ( word1 . begin ( ) + 0 ) ; } else { merge = merge + word2 [ 0 ] ; word2 . erase ( word2 . begin ( ) + 0 ) ; } } return merge ; }
int find ( vector < int > arr , int N ) { int Sum = 0 ; for ( auto i : arr ) Sum += i ; if ( Sum % N ) return -1 ; int k = Sum / N ; int ans = 0 ; int i = 0 ; while ( i < N ) { ans = ans + abs ( k - arr [ i ] ) ; i += 1 ; } return ans / 2 ; }
int maxXORUtil ( int arr [ ] , int N , int xrr , int orr ) { if ( N == 0 ) return xrr ^ orr ; int x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) ; int y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) ; return max ( x , y ) ; }
int maximumXOR ( int arr [ ] , int N ) { return maxXORUtil ( arr , N , 0 , 0 ) ; }
void findEquation ( int S , int M ) { cout << "1 " << ( -1 ) * S << " " << M << endl ; }
bool isPalindrome ( int N ) { int temp = N ; int res = 0 ; while ( temp != 0 ) { int rem = temp % 10 ; res = res * 10 + rem ; temp /= 10 ; } if ( res == N ) { return true ; } else { return false ; } }
int minSteps ( vector < int > a , int n ) { vector < int > prefix_sum ( n ) ; prefix_sum [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] + a [ i ] ; int mx = -1 ; for ( int subgroupsum : prefix_sum ) { int sum = 0 ; int i = 0 ; int grp_count = 0 ; while ( i < n ) { sum += a [ i ] ; if ( sum == subgroupsum ) { grp_count += 1 ; sum = 0 ; } else if ( sum > subgroupsum ) { grp_count = -1 ; break ; } i += 1 ; } if ( grp_count > mx ) mx = grp_count ; } return n - mx ; }
void findSubseq ( vector < int > A , vector < int > B , int K , int i ) { vector < int > ans ; findSubseqUtil ( A , B , ans , K , i ) ; if ( ! ans . size ( ) ) cout << -1 ; }
int MinimumCost ( int A [ ] , int B [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int mod_A = B [ i ] % A [ i ] ; int totalCost_A = min ( mod_A , A [ i ] - mod_A ) ; int mod_B = A [ i ] % B [ i ] ; int totalCost_B = min ( mod_B , B [ i ] - mod_B ) ; totalCost += min ( totalCost_A , totalCost_B ) ; } return totalCost ; }
int longestSubarray ( int arr [ ] , int N , int K ) { unordered_map < int , int > um ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( sum == K ) maxLen = i + 1 ; if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i ; if ( um . find ( sum - K ) != um . end ( ) ) { if ( maxLen < ( i - um [ sum - K ] ) ) maxLen = i - um [ sum - K ] ; } } return maxLen ; }
void findArrayWithMaxProduct ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) if ( arr [ i ] >= 0 ) { arr [ i ] = - arr [ i ] - 1 ; } if ( N % 2 == 1 ) { int max_element = -1 ; int index = -1 ; for ( int i = 0 ; i < N ; i ++ ) if ( abs ( arr [ i ] ) > max_element ) { max_element = abs ( arr [ i ] ) ; index = i ; } arr [ index ] = - arr [ index ] - 1 ; } for ( int i = 0 ; i < N ; i ++ ) printf ( "%d " , arr [ i ] ) ; }
int maximumCandy ( int candies [ ] , int safety [ ] , int N , int M ) { int total = 0 ; int ans = INT_MAX ; bool all_safe = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = min ( ans , safety [ i ] ) ; } else { ans = min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; }
void canArrayBeReduced ( int arr [ ] , int N ) { if ( N == 1 ) { cout << arr [ 0 ] ; return ; } if ( arr [ 0 ] < arr [ N - 1 ] ) { cout << arr [ N - 1 ] ; } else cout << "Not Possible" ; }
void maxValueAtIndexK ( int N , int K , int M ) { int S1 = 0 , S2 = 0 ; S1 = K * ( K + 1 ) / 2 ; S2 = ( N - K - 1 ) * ( N - K ) / 2 ; int X = ( M + S1 + S2 ) / N ; cout << X ; }
int countEvenPairs ( int N , int M ) { int count = 0 ; int nEven = floor ( N / 2 ) ; int nOdd = ceil ( N / 2 ) ; int mEven = floor ( M / 2 ) ; int mOdd = ceil ( M / 2 ) ; count = nEven * mEven + nOdd * mOdd ; return count ; }
void findNums ( int X , int Y ) { int A , B ; if ( X < Y ) { A = -1 ; B = -1 ; } else if ( abs ( X - Y ) & 1 ) { A = -1 ; B = -1 ; } else if ( X == Y ) { A = 0 ; B = Y ; } else { A = ( X - Y ) / 2 ; if ( ( A & Y ) == 0 ) { B = ( A + Y ) ; } else { A = -1 ; B = -1 ; } } cout << A << " " << B ; }
int findPartition ( int nums [ ] , int N ) { int prefix [ N ] , suffix [ N ] , i , k ; prefix [ 0 ] = nums [ 0 ] ; for ( i = 1 ; i < N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] * nums [ i ] ; } suffix [ N - 1 ] = nums [ N - 1 ] ; for ( i = N - 2 ; i >= 0 ; i -- ) { suffix [ i ] = suffix [ i + 1 ] * nums [ i ] ; } for ( k = 0 ; k < N - 1 ; k ++ ) { if ( GCD ( prefix [ k ] , suffix [ k + 1 ] ) == 1 ) { return k ; } } return -1 ; }
int palindromeMatrix ( int N , int M , vector < vector < int > > arr ) { int ans = 0 ; for ( int i = 0 ; i < ( N + 1 ) / 2 ; i ++ ) { for ( int j = 0 ; j < ( M + 1 ) / 2 ; j ++ ) { set < pair < int , int > > s ; s . insert ( { i , j } ) ; s . insert ( { i , M - j - 1 } ) ; s . insert ( { N - i - 1 , j } ) ; s . insert ( { N - i - 1 , M - j - 1 } ) ; vector < int > values ; for ( pair < int , int > p : s ) { values . push_back ( arr [ p . first ] [ p . second ] ) ; } int max = * max_element ( values . begin ( ) , values . end ( ) ) ; for ( int k = 0 ; k < values . size ( ) ; k ++ ) { ans += max - values [ k ] ; } } } cout << ans ; }
int MinOperation ( int arr [ ] , int N , int K ) { int cntOpe = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( K > arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cntOpe += 2 ; } else { cntOpe += 1 ; } } else if ( K < arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cntOpe += 1 ; } else { cntOpe += 2 ; } } } return cntOpe ; }
void printSmallSub ( int arr [ ] , int N ) { int gcdArr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { gcdArr = __gcd ( gcdArr , arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == gcdArr ) { cout << arr [ i ] << " " ; return ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( __gcd ( arr [ i ] , arr [ j ] ) == gcdArr ) { cout << arr [ i ] << " " << arr [ j ] ; return ; } } } }
void smlstNonNeg ( int arr [ ] , int N ) { int smNonNeg = 0 ; bool hash [ N + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 0 and arr [ i ] < N ) { hash [ arr [ i ] ] = true ; } while ( hash [ smNonNeg ] ) { smNonNeg ++ ; } cout << smNonNeg << " " ; } }
void numberOfWays ( int N ) { long long int count = count_of_primes [ N ] - 1 ; long long int mod = 1000000007 ; long long int answer = power ( 2 , count , mod ) ; if ( N == 1 ) answer = 0 ; cout << answer ; }
int cntPairs ( int arr [ ] , int N ) { vector < bool > isPrime = getPrimeNum ( ) ; int cntOne = 0 ; int cntPrime = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) { cntOne += 1 ; } else if ( isPrime [ i ] ) { cntPrime += 1 ; } } int cntNonComp = 0 ; cntNonComp = cntPrime * cntOne + cntOne * ( cntOne - 1 ) / 2 ; int res = 0 ; res = N * ( N - 1 ) / 2 - cntNonComp ; return res ; }
void printArray ( vector < int > & brr ) { for ( auto & it : brr ) { cout << it << ' ' ; } }
int MinimumFlips ( string s , int n ) { int a [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( s [ i ] == '1' ? 1 : 0 ) ; } int oddone [ n + 1 ] ; int evenone [ n + 1 ] ; oddone [ 0 ] = 0 ; evenone [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) { oddone [ i + 1 ] = oddone [ i ] + ( a [ i ] == 1 ? 1 : 0 ) ; evenone [ i + 1 ] = evenone [ i ] + ( a [ i ] == 0 ? 1 : 0 ) ; } else { oddone [ i + 1 ] = oddone [ i ] + ( a [ i ] == 0 ? 1 : 0 ) ; evenone [ i + 1 ] = evenone [ i ] + ( a [ i ] == 1 ? 1 : 0 ) ; } } int minimum = min ( oddone [ n ] , evenone [ n ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( n % 2 != 0 ) { minimum = min ( minimum , oddone [ n ] - oddone [ i + 1 ] + evenone [ i + 1 ] ) ; minimum = min ( minimum , evenone [ n ] - evenone [ i + 1 ] + oddone [ i + 1 ] ) ; } } return minimum ; }
void shortestpath ( int m , int n ) { vector < int > mfactor , nfactor ; map < int , int > fre ; mfactor . push_back ( m ) ; fre [ m ] = 1 ; while ( m != 1 ) { if ( isprm ( m ) ) { mfactor . push_back ( 1 ) ; fre [ 1 ] = 1 ; m = 1 ; } else { for ( int i = 2 ; i <= sqrt ( m ) ; i ++ ) { if ( m % i == 0 ) { mfactor . push_back ( m / i ) ; fre [ m / i ] = 1 ; m = ( m / i ) ; break ; } } } } nfactor . push_back ( n ) ; while ( fre [ n ] != 1 ) { if ( isprm ( n ) ) { nfactor . push_back ( 1 ) ; n = 1 ; } else { for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { nfactor . push_back ( n / i ) ; n = ( n / i ) ; break ; } } } } for ( int i = 0 ; i < mfactor . size ( ) ; i ++ ) { if ( mfactor [ i ] == n ) break ; cout << mfactor [ i ] << " <--> " ; } for ( int i = nfactor . size ( ) - 1 ; i >= 0 ; i -- ) { if ( i == 0 ) cout << nfactor [ i ] ; else cout << nfactor [ i ] << " <--> " ; } }
int factorial ( int N ) { if ( N <= 0 ) return 1 ; int fact = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = ( fact * i ) % Mod ; } return fact ; }
int noOfFactors ( int N ) { if ( N == 1 ) return 1 ; int count = 0 ; int ans = 1 ; while ( N % 2 == 0 ) { count ++ ; N = N / 2 ; } ans *= ( count / 2 + 1 ) ; for ( int i = 3 ; i * i <= N ; i = i + 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } ans *= ( count / 2 + 1 ) ; } return ans ; }
void minCost ( int N , int M , int vCost , int eCost , int sorc [ ] , vector < int > colored , int destination [ ] ) { vector < int > adj [ N + 1 ] ; for ( int i = 0 ; i < M ; i ++ ) { adj [ sorc [ i ] ] . push_back ( destination [ i ] ) ; adj [ destination [ i ] ] . push_back ( sorc [ i ] ) ; } int vis [ N + 1 ] = { 0 } ; for ( int i = 0 ; i < colored . size ( ) ; i ++ ) { DFS ( colored [ i ] , vis , adj ) ; } int X = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] == 0 ) { X ++ ; DFS ( i , vis , adj ) ; } } int mincost = X * min ( vCost , eCost ) ; cout << mincost << endl ; }
double power ( int N , int P ) { return pow ( N , P ) ; }
void Solve ( int N , int M ) { int temp = ( N - 1 ) * ( M - 1 ) ; int ans = pow ( 2 , temp ) ; if ( ( N + M ) % 2 != 0 ) cout << ans ; else cout << 2 * ans ; cout << endl ; }
void findMaximumLength ( int lis [ ] [ col ] ) { int x , y ; id ++ ; length = 0 ; diameter = 0 ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < col ; j ++ ) { if ( lis [ i ] [ j ] != 0 ) { dfs ( i , j , lis , x , y ) ; i = row ; break ; } } } id ++ ; length = 0 ; diameter = 0 ; dfs ( x , y , lis , x , y ) ; cout << diameter ; }
int maxModulosum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return sum - n ; }
int noOfPermutations ( int * a , int n ) { if ( n == 1 ) { return 1 ; } sort ( a , a + n ) ; if ( a [ n - 1 ] == a [ n - 2 ] ) { return 0 ; } int x = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( a [ i ] == a [ i + 1 ] ) { if ( a [ i ] == a [ i + 2 ] ) { return 0 ; } x ++ ; i ++ ; } } return pow ( 2 , n - 2 * x - 1 ) ; }
int maxValue ( int arr [ ] , int n , int moves ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { int distance = n - 1 - i ; if ( moves < distance ) break ; int can_take = moves / distance ; int take = min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; }
bool hasCrest ( int arr [ ] , int n , int L , int R ) { int present [ n ] = { 0 } ; for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( ( arr [ i ] <= arr [ i + 1 ] ) && ( arr [ i ] <= arr [ i - 1 ] ) ) { present [ i ] = 1 ; } } for ( int i = 1 ; i < n ; i ++ ) { present [ i ] += present [ i - 1 ] ; } if ( present [ L ] == present [ R - 1 ] ) return true ; return false ; }
int getMin ( int arr [ ] , int n ) { int minVal = * min_element ( arr , arr + n ) ; return minVal ; }
int Substring ( string s ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = max ( ans , temp ) ; temp = 1 ; } } ans = max ( ans , temp ) ; return ans ; }
int countOp ( int x ) { int arr [ MAX ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ; int temp = x ; bool flag = true ; int ans ; int operations = 0 ; bool flag2 = false ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag2 = true ; if ( arr [ i ] > x ) { ans = i ; break ; } } if ( flag2 ) return 0 ; while ( flag ) { if ( arr [ ans ] < x ) ans ++ ; operations ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { int take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) { if ( take > temp ) temp = take ; } } if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; } return operations ; }
int getMinSum ( int arr [ ] , int n ) { int bits_count [ MAX ] , max_bit = 0 , sum = 0 , ans = 0 ; memset ( bits_count , 0 , sizeof ( bits_count ) ) ; for ( int d = 0 ; d < n ; d ++ ) { int e = arr [ d ] , f = 0 ; while ( e > 0 ) { int rem = e % 2 ; e = e / 2 ; if ( rem == 1 ) { bits_count [ f ] += rem ; } f ++ ; } max_bit = max ( max_bit , f ) ; } for ( int d = 0 ; d < max_bit ; d ++ ) { int temp = pow ( 2 , d ) ; if ( bits_count [ d ] > n / 2 ) ans = ans + temp ; } for ( int d = 0 ; d < n ; d ++ ) { arr [ d ] = arr [ d ] ^ ans ; sum = sum + arr [ d ] ; } return sum ; }
void replacedArray ( int N , int arr [ ] ) { int pos_sum , neg_sum , i , j , diff ; pos_sum = 0 ; neg_sum = 0 ; for ( i = N - 1 ; i >= 0 ; i -- ) { diff = abs ( pos_sum ) - abs ( neg_sum ) ; if ( arr [ i ] > 0 ) pos_sum += arr [ i ] ; else neg_sum += arr [ i ] ; arr [ i ] = abs ( diff ) ; } }
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * ( a / n ) * ( b / n ) ; ans += ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( b / n ) ; ans += ( ( a % n ) + ( b % n ) ) / n ; return ans ; }
int minChanges ( int A [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; }
int solve ( pair < int , int > v [ ] , int n ) { int ans , ul , ll ; ll = v [ 0 ] . first ; ul = v [ 0 ] . second ; ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( v [ i ] . first <= ul && v [ i ] . first >= ll ) || ( v [ i ] . second >= ll && v [ i ] . second <= ul ) ) { if ( v [ i ] . first > ll ) { ll = v [ i ] . first ; } if ( v [ i ] . second < ul ) { ul = v [ i ] . second ; } } else if ( v [ i ] . first > ul ) { ans += abs ( ul - v [ i ] . first ) ; ul = v [ i ] . first ; ll = v [ i ] . first ; } else if ( v [ i ] . second < ll ) { ans += abs ( ll - v [ i ] . second ) ; ul = v [ i ] . second ; ll = v [ i ] . second ; } } return ans ; }
int steps ( int N , int M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; }
int dfs ( int w ) { if ( cd [ w ] == 0 ) return w ; if ( wt [ w ] < ans ) ans = wt [ w ] ; return dfs ( cd [ w ] ) ; }
void digitsNum ( int N ) { if ( N == 0 ) cout << "0\n" ; if ( N % 9 != 0 ) cout << ( N % 9 ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) cout << "9" ; for ( int i = 1 ; i <= N ; ++ i ) cout << "0" ; cout << "\n" ; }
void bestpermutation ( int arr [ ] , int k , int n ) { unordered_map < int , int > h ; for ( int i = 0 ; i < n ; i ++ ) { h . insert ( make_pair ( arr [ i ] , i ) ) ; } if ( n <= k ) { sort ( arr , arr + n , greater < int > ( ) ) ; } else { for ( int j = n ; j >= 1 ; j -- ) { if ( k > 0 ) { int initial_index = h [ j ] ; int best_index = n - j ; if ( initial_index != best_index ) { h [ j ] = best_index ; int element = arr [ best_index ] ; h [ element ] = initial_index ; swap ( arr [ best_index ] , arr [ initial_index ] ) ; k -- ; } } } } }
long long int sumArray ( long long int * arr , int n ) { long long int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } return sum ; }
int firstFit ( int weight [ ] , int n , int c ) { int res = 0 ; int bin_rem [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < res ; j ++ ) { if ( bin_rem [ j ] >= weight [ i ] ) { bin_rem [ j ] = bin_rem [ j ] - weight [ i ] ; break ; } } if ( j == res ) { bin_rem [ res ] = c - weight [ i ] ; res ++ ; } } return res ; }
int find ( int A , int B , int C , int N ) { int arr [ N ] ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; for ( int i = 3 ; i < N ; i ++ ) { arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] + arr [ i - 3 ] ; } return arr [ N - 1 ] ; }
void maxSum ( vector < vector < int > > arr , int n ) { int r1 = 0 , r2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = r1 ; r1 = max ( r1 , r2 + arr [ 0 ] [ i ] ) ; r2 = max ( r2 , temp + arr [ 1 ] [ i ] ) ; } cout << max ( r1 , r2 ) ; }
int countMinCoins ( int n , int C [ ] , int m ) { if ( n == 0 ) { dp [ 0 ] = 0 ; return 0 ; } if ( dp [ n ] != -1 ) return dp [ n ] ; int ret = INT_MAX ; for ( int i = 0 ; i < m ; i ++ ) { if ( C [ i ] <= n ) { int x = countMinCoins ( n - C [ i ] , C , m ) ; if ( x != INT_MAX ) ret = min ( ret , 1 + x ) ; } } dp [ n ] = ret ; return ret ; }
void findSolution ( int n , int C [ ] , int m ) { if ( n == 0 ) { for ( auto it : denomination ) { cout << it << ' ' ; } return ; } for ( int i = 0 ; i < m ; i ++ ) { if ( n - C [ i ] >= 0 and dp [ n - C [ i ] ] + 1 == dp [ n ] ) { denomination . push_back ( C [ i ] ) ; findSolution ( n - C [ i ] , C , m ) ; break ; } } }
int count_unique_sum ( int n ) { int i , ar [ n + 1 ] , fsum [ n + 1 ] ; int rsum [ n + 1 ] , ans = 1 ; memset ( fsum , 0 , sizeof fsum ) ; memset ( rsum , 0 , sizeof rsum ) ; for ( i = 0 ; i <= n ; i ++ ) { ar [ i ] = i ; } fsum [ 0 ] = ar [ 0 ] ; rsum [ n ] = ar [ n ] ; for ( i = 1 ; i <= n ; i ++ ) { fsum [ i ] = ar [ i ] + fsum [ i - 1 ] ; } for ( i = n - 1 ; i >= 0 ; i -- ) { rsum [ i ] = ar [ i ] + rsum [ i + 1 ] ; } for ( int k = 2 ; k <= n ; k ++ ) { ans += 1 + rsum [ n + 1 - k ] - fsum [ k - 1 ] ; } return ans ; }
void precompute ( int nextpos [ ] , int arr [ ] , int N ) { nextpos [ N - 1 ] = N ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) nextpos [ i ] = nextpos [ i + 1 ] ; else nextpos [ i ] = i + 1 ; } }
ll fun ( ll pos , ll sum , ll st , ll check , ll f ) { if ( pos == N ) { return ( sum == 0 and check == 1 ) ; } if ( dp [ pos ] [ sum ] [ st ] [ check ] [ f ] != -1 ) return dp [ pos ] [ sum ] [ st ] [ check ] [ f ] ; ll lmt = 9 ; if ( ! f ) lmt = v [ pos ] ; ll ans = 0 ; for ( int digit = 0 ; digit <= lmt ; digit ++ ) { ll nf = f ; ll new_sum = ( sum + digit ) % K ; ll new_check = check ; ll new_st = st ; if ( f == 0 and digit < lmt ) nf = 1 ; if ( check == 0 and digit != 0 ) { new_st = digit ; new_check = 1 ; } if ( pos == N - 1 and new_st == digit ) continue ; ans += fun ( pos + 1 , new_sum , new_st , new_check , nf ) ; } return dp [ pos ] [ sum ] [ st ] [ check ] [ f ] = ans ; }
int minSumProd ( string S , int K ) { int len = S . length ( ) ; if ( K > len ) return -1 ; if ( K == len ) return 0 ; vector < int > dp ( len ) ; int count_zero = 0 , count_one = 0 ; for ( int j = 0 ; j < len ; j ++ ) { ( S [ j ] == '0' ) ? count_zero ++ : count_one ++ ; dp [ j ] = count_zero * count_one ; } for ( int i = 1 ; i < K ; i ++ ) { for ( int j = len ; j >= i ; j -- ) { count_zero = 0 , count_one = 0 ; dp [ j ] = INT_MAX ; for ( int k = j ; k >= i ; k -- ) { ( S [ k ] == '0' ) ? count_zero ++ : count_one ++ ; dp [ j ] = min ( dp [ j ] , count_zero * count_one + dp [ k - 1 ] ) ; } } } return dp [ len - 1 ] ; }
int countPairs ( int arr [ ] , int N ) { int maxm = * max_element ( arr , arr + N ) ; int i , k ; int bitscount [ maxm + 1 ] = { 0 } ; for ( i = 1 ; i <= maxm ; i *= 2 ) bitscount [ i ] = 1 ; for ( i = 1 ; i <= maxm ; i ++ ) { if ( bitscount [ i ] == 1 ) k = i ; if ( bitscount [ i ] == 0 ) { bitscount [ i ] = bitscount [ k ] + bitscount [ i - k ] ; } } map < int , int > setbits ; for ( int i = 0 ; i < N ; i ++ ) { setbits [ bitscount [ arr [ i ] ] ] ++ ; } int ans = 0 ; for ( auto it : setbits ) { ans += it . second * ( it . second - 1 ) / 2 ; } return ans ; }
int solve ( int n , int k , int m ) { if ( n == 0 && k == 0 ) return 1 ; if ( n == 0 && k != 0 ) return 0 ; if ( n != 0 && k == 0 ) return 0 ; if ( n < 0 k < 0  ) return 0 ; if ( dp [ n ] [ k ] ) return dp [ n ] [ k ] ; int ans = 0 ; for ( int j = 1 ; j <= m ; j ++ ) { ans += solve ( n - j , k - 1 , m ) ; } return dp [ n ] [ k ] = ans ; }
bool isprime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
int productDigitSum ( int x , int y ) { int sumx = 0 ; while ( x ) { sumx += ( x % 10 ) ; x /= 10 ; } int sumy = 0 ; while ( y ) { sumy += ( y % 10 ) ; y /= 10 ; } return ( sumx * sumy ) ; }
int CountSets ( int x , int pos ) { if ( x <= 0 ) { if ( pos == 0 ) return 1 ; else return 0 ; } if ( pos == 0 ) return 1 ; if ( dp [ x ] [ pos ] != -1 ) return dp [ x ] [ pos ] ; int answer = CountSets ( x - 1 , pos ) + CountSets ( x - 2 , pos - 1 ) ; return dp [ x ] [ pos ] = answer ; }
int splitIntoPrimes ( string number ) { if ( number . length ( ) == 0 ) return 0 ; if ( number . length ( ) <= 6 and checkPrime ( number ) ) return 1 ; else { int numLen = number . length ( ) ; int ans = 1000000 ; for ( int i = 1 ; i <= 6 && i <= numLen ; i ++ ) { if ( checkPrime ( number . substr ( 0 , i ) ) ) { int val = splitIntoPrimes ( number . substr ( i ) ) ; if ( val != -1 ) { ans = min ( ans , 1 + val ) ; } } } if ( ans == 1000000 ) return -1 ; return ans ; } }
int dp ( int pos , int fl , int pr , string & bin ) { if ( pos == bin . length ( ) ) return 1 ; if ( memo [ pos ] [ fl ] [ pr ] != -1 ) return memo [ pos ] [ fl ] [ pr ] ; int val = 0 ; if ( bin [ pos ] == '0' ) val = val + dp ( pos + 1 , fl , 0 , bin ) ; else if ( bin [ pos ] == '1' ) val = val + dp ( pos + 1 , 1 , 0 , bin ) ; if ( pr == 0 ) { if ( fl == 1 ) { val += dp ( pos + 1 , fl , 1 , bin ) ; } else if ( bin [ pos ] == '1' ) { val += dp ( pos + 1 , fl , 1 , bin ) ; } } return memo [ pos ] [ fl ] [ pr ] = val ; }
int TotalWays ( int n , int s , int k ) { int dp [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ s - 1 ] = 1 ; for ( int i = s ; i < n ; i ++ ) { int idx = max ( s - 1 , i - k ) ; for ( int j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; }
int solve ( int arr [ ] , int n , int i , bool pos ) { if ( i == n ) return 0 ; if ( LAS [ i ] [ pos ] ) return LAS [ i ] [ pos ] ; int inc = 0 , exc = 0 ; if ( arr [ i ] > 0 && pos == true ) { pos = false ; inc = 1 + solve ( arr , n , i + 1 , pos ) ; } else if ( arr [ i ] < 0 && pos == false ) { pos = true ; inc = 1 + solve ( arr , n , i + 1 , pos ) ; } exc = solve ( arr , n , i + 1 , pos ) ; LAS [ i ] [ pos ] = max ( inc , exc ) ; return LAS [ i ] [ pos ] ; }
int query ( int in , int l , int r , int l1 , int r1 ) { if ( l > r ) return 0 ; if ( r < l1 l > r1 ) return 0 ; if ( l1 <= l and r <= r1 )  return seg [ in ] ; int m = ( l + r ) / 2 ; return query ( 2 * in + 1 , l , m , l1 , r1 ) + query ( 2 * in + 2 , m + 1 , r , l1 , r1 ) ; }
int minMergeCost ( int i , int j , int * arr ) { if ( i == j ) return 0 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; int & x = dp [ i ] [ j ] ; x = INT_MAX ; int tot = 0 ; for ( int k = i ; k <= j ; k ++ ) tot += arr [ k ] ; for ( int k = i + 1 ; k <= j ; k ++ ) { x = min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) ; } return x ; }
int numberOfCells ( int mat [ ] [ N ] ) { bool row [ N ] [ N ] = { { false } } ; bool col [ N ] [ N ] = { { false } } ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat [ i ] [ j ] == 1 ) { row [ i ] [ j ] = ( j + 1 < N ) ? row [ i ] [ j + 1 ] : true ; } else { row [ i ] [ j ] = false ; } } } for ( int j = 0 ; j < N ; j ++ ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( mat [ i ] [ j ] == 1 ) { col [ i ] [ j ] = ( i + 1 < N ) ? col [ i + 1 ] [ j ] : true ; } else { col [ i ] [ j ] = false ; } } } int cnt = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( row [ i ] [ j ] && col [ i ] [ j ] ) { cnt ++ ; } } } for ( int i = 0 ; i < N ; i ++ ) { if ( col [ i ] [ N - 1 ] ) cnt ++ ; } for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( row [ N - 1 ] [ j ] ) cnt ++ ; } return cnt ; }
int subsequence ( int S [ ] , int T [ ] , int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j <= m ; j ++ ) dp [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; if ( S [ i - 1 ] == T [ j - 1 ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] ; dp [ i ] [ j ] += mod ; dp [ i ] [ j ] %= mod ; } } return dp [ n ] [ m ] ; }
int findCount ( int n ) { return log ( n ) / log ( 2 ) + 1 ; }
int findLen ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return -1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != -1 ) dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
int findLen ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return -1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != -1 ) dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
int countWays ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; }
bool findPath ( vector < vector < int > > maze , int xpos , int ypos , bool key ) { if ( xpos < 0 || xpos >= maze . size ( ) || ypos < 0 || ypos >= maze . size ( ) ) return false ; if ( maze [ xpos ] [ ypos ] == '1' ) { if ( key == true ) if ( xpos == maze . size ( ) - 1 && ypos == maze . size ( ) - 1 ) return true ; return findPath ( maze , xpos + 1 , ypos , false ) || findPath ( maze , xpos , ypos + 1 , false ) ; return false ; } if ( xpos == maze . size ( ) - 1 && ypos == maze . size ( ) - 1 ) return true ; return findPath ( maze , xpos + 1 , ypos , key ) || findPath ( maze , xpos , ypos + 1 , key ) ; }
void findPrefixCount ( int arr [ ] , int n ) { for ( int i = 0 ; i < bitscount ; i ++ ) { prefix_count [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( int j = 1 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] += prefix_count [ i ] [ j - 1 ] ; } } }
int countWays ( int n , int l , int r ) { int tL = l , tR = r ; int L [ 2 ] = { 0 } , R [ 2 ] = { 0 } ; L [ l % 2 ] = l , R [ r % 2 ] = r ; l ++ , r -- ; if ( l <= tR && r >= tL ) L [ l % 2 ] = l , R [ r % 2 ] = r ; int cnt0 = 0 , cnt1 = 0 ; if ( R [ 0 ] && L [ 0 ] ) cnt0 = ( R [ 0 ] - L [ 0 ] ) / 2 + 1 ; if ( R [ 1 ] && L [ 1 ] ) cnt1 = ( R [ 1 ] - L [ 1 ] ) / 2 + 1 ; int dp [ n ] [ 2 ] ; dp [ 1 ] [ 0 ] = cnt0 ; dp [ 1 ] [ 1 ] = cnt1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = ( cnt0 * dp [ i - 1 ] [ 0 ] + cnt1 * dp [ i - 1 ] [ 1 ] ) ; dp [ i ] [ 1 ] = ( cnt0 * dp [ i - 1 ] [ 1 ] + cnt1 * dp [ i - 1 ] [ 0 ] ) ; } return dp [ n ] [ 0 ] ; }
int dfs ( int node , int parent , int dp1 [ ] , int dp2 [ ] , list < int > * adj ) { int firstmax = -1 ; int secondmax = -1 ; for ( auto i = adj [ node ] . begin ( ) ; i != adj [ node ] . end ( ) ; ++ i ) { if ( * i == parent ) continue ; dfs ( * i , node , dp1 , dp2 , adj ) ; if ( firstmax == -1 ) { firstmax = dp1 [ * i ] ; } else if ( dp1 [ * i ] >= firstmax ) { secondmax = firstmax ; firstmax = dp1 [ * i ] ; } { secondmax = dp1 [ * i ] ; } } dp1 [ node ] = 1 ; dp1 [ node ] += firstmax ; if ( secondmax != -1 ) dp2 [ node ] = 1 + firstmax + secondmax ; return max ( dp1 [ node ] , dp2 [ node ] ) ; }
int countRec ( int start , int end , int dp [ ] [ MAX ] , string st ) { int sum = 0 ; if ( start > end ) return 1 ; if ( dp [ start ] [ end ] != -1 ) return dp [ start ] [ end ] ; lli i , r = 0 ; for ( i = start + 1 ; i <= end ; i += 2 ) { if ( checkFunc ( start , i , st ) ) { sum = sum + countRec ( start + 1 , i - 1 , dp , st ) * countRec ( i + 1 , end , dp , st ) ; } else if ( st [ start ] == '?' && st [ i ] == '?' ) { sum = sum + countRec ( start + 1 , i - 1 , dp , st ) * countRec ( i + 1 , end , dp , st ) * 3 ; } } return dp [ start ] [ end ] = sum ; }
int countWays ( string st ) { int n = st . length ( ) ; if ( n % 2 == 1 ) return 0 ; int dp [ MAX ] [ MAX ] ; memset ( dp , -1 , sizeof ( dp ) ) ; return countRec ( 0 , n - 1 , dp , st ) ; }
void pre_compute ( char a [ ] [ n ] ) { if ( a [ 0 ] [ 0 ] == 'a' ) dp [ 0 ] [ 0 ] = 0 ; else dp [ 0 ] [ 0 ] = 1 ; for ( int row = 0 ; row < n ; row ++ ) { for ( int col = 0 ; col < n ; col ++ ) { if ( row != 0 col != 0 ) dp [ row ] [ col ] = INT_MAX ; if ( row != 0 ) { dp [ row ] [ col ] = min ( dp [ row ] [ col ] , dp [ row - 1 ] [ col ] ) ; } if ( col != 0 ) { dp [ row ] [ col ] = min ( dp [ row ] [ col ] , dp [ row ] [ col - 1 ] ) ; } if ( a [ row ] [ col ] != 'a' && ( row != 0 col != 0 ) ) dp [ row ] [ col ] += 1 ; } } }
int CommomSubsequencesCount ( string s , string t ) { int n1 = s . length ( ) ; int n2 = t . length ( ) ; int dp [ n1 + 1 ] [ n2 + 1 ] ; for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i <= n1 ; i ++ ) { for ( int j = 1 ; j <= n2 ; j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] - dp [ i - 1 ] [ j - 1 ] ; } } return dp [ n1 ] [ n2 ] ; }
int lcs ( int dp [ 101 ] [ 101 ] , string a , string b , int m , int n ) { for ( int i = 0 ; i < 100 ; i ++ ) for ( int j = 0 ; j < 100 ; j ++ ) dp [ i ] [ j ] = -1 ; if ( m < 0 n < 0  ) { return 0 ; } if ( dp [ m ] [ n ] != -1 ) return dp [ m ] [ n ] ; int ans = 0 ; if ( a [ m ] == b [ n ] ) { ans = int ( a [ m ] - 48 ) + lcs ( dp , a , b , m - 1 , n - 1 ) ; } else ans = max ( lcs ( dp , a , b , m - 1 , n ) , lcs ( dp , a , b , m , n - 1 ) ) ; dp [ m ] [ n ] = ans ; return ans ; }
double largestSumOfAverages ( vector < int > & A , int K ) { int n = A . size ( ) ; double sum = 0 ; memset ( memo , 0.0 , sizeof ( memo ) ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += A [ i ] ; memo [ i + 1 ] [ 1 ] = sum / ( i + 1 ) ; } return score ( n , A , K ) ; }
double largestSumOfAverages ( vector < int > & A , int K ) { int n = A . size ( ) ; double pre_sum [ n + 1 ] ; pre_sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; double dp [ n ] = { 0 } ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; for ( int k = 0 ; k < K - 1 ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }
int findMaxVal ( int arr [ ] , int n , int num , int maxLimit ) { int ans = 0 ; int ind = 0 ; findMaxValUtil ( arr , n , num , maxLimit , ind , ans ) ; return ans ; }
int findMaxVal ( int arr [ ] , int n , int num , int maxLimit ) { int ind ; int val ; int dp [ n ] [ maxLimit + 1 ] ; for ( ind = 0 ; ind < n ; ind ++ ) { for ( val = 0 ; val <= maxLimit ; val ++ ) { if ( ind == 0 ) { if ( num - arr [ ind ] == val num + arr [ ind ] == val ) { dp [ ind ] [ val ] = 1 ; } else { dp [ ind ] [ val ] = 0 ; } } else { if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] || dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else if ( val - arr [ ind ] >= 0 ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ; } else if ( val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else { dp [ ind ] [ val ] = 0 ; } } } } for ( val = maxLimit ; val >= 0 ; val -- ) { if ( dp [ n - 1 ] [ val ] ) { return val ; } } return -1 ; }
int gen ( int n ) { if ( n == 0 ) return 0 ; else if ( n == 1 ) return 1 ; else if ( n % 2 == 0 ) return 4 * gen ( n / 2 ) ; else if ( n % 2 == 1 ) return 4 * gen ( n / 2 ) + 1 ; }
int solve ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = -1 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) nck [ i ] [ j ] = -1 ; int currLog2 = -1 ; int currPower2 = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( currPower2 == i ) { currLog2 ++ ; currPower2 *= 2 ; } log2 [ i ] = currLog2 ; } return numberOfHeaps ( n ) ; }
int largestSubset ( int a [ ] , int n ) { int dp [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) mxm = max ( mxm , dp [ j ] ) ; dp [ i ] = 1 + mxm ; } return * max_element ( dp , dp + n ) ; }
int maxLenSub ( int arr [ ] , int n ) { int mls [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
int minimumNumberOfDeletions ( int arr [ ] , int n ) { int len = lis ( arr , n ) ; return ( n - len ) ; }
int countGroups ( int position , int previous_sum , int length , char * num ) { if ( position == length ) return 1 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; }
int lenOfLongestGP ( int set [ ] , int n ) { if ( n < 2 ) return n ; if ( n == 2 ) return ( set [ 1 ] % set [ 0 ] == 0 ) ? 2 : 1 ; sort ( set , set + n ) ; int L [ n ] [ n ] ; int llgp = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( set [ n - 1 ] % set [ i ] == 0 ) { L [ i ] [ n - 1 ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i ] [ n - 1 ] = 1 ; } } L [ n - 1 ] [ n - 1 ] = 1 ; for ( int j = n - 2 ; j >= 1 ; -- j ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) { ++ k ; } else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; } else { L [ i ] [ j ] = 1 ; } -- i ; } else { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; if ( L [ i ] [ j ] > llgp ) llgp = L [ i ] [ j ] ; } else { L [ i ] [ j ] = 1 ; } -- i ; ++ k ; } } while ( i >= 0 ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else L [ i ] [ j ] = 1 ; -- i ; } } return llgp ; }
int findMinRec ( int arr [ ] , int i , int sumCalculated , int sumTotal ) { if ( i == 0 ) return abs ( ( sumTotal - sumCalculated ) - sumCalculated ) ; return min ( findMinRec ( arr , i - 1 , sumCalculated + arr [ i - 1 ] , sumTotal ) , findMinRec ( arr , i - 1 , sumCalculated , sumTotal ) ) ; }
int findMin ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; bool dp [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) dp [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( arr [ i - 1 ] <= j ) dp [ i ] [ j ] |= dp [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } int diff = INT_MAX ; for ( int j = sum / 2 ; j >= 0 ; j -- ) { if ( dp [ n ] [ j ] == true ) { diff = sum - 2 * j ; break ; } } return diff ; }
int minSize ( int arr [ ] , int n , int k ) { memset ( dp , -1 , sizeof ( dp ) ) ; return minSizeRec ( arr , 0 , n - 1 , k ) ; }
int minRemovals ( int arr [ ] , int l , int h ) { if ( l >= h ) return 0 ; int mn = min ( arr , l , h ) ; int mx = max ( arr , l , h ) ; if ( 2 * mn > mx ) return 0 ; return min ( minRemovals ( arr , l + 1 , h ) , minRemovals ( arr , l , h - 1 ) ) + 1 ; }
int optimalStrategyOfGame ( int * arr , int n ) { int table [ n ] [ n ] ; for ( int gap = 0 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { int x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; int y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; int z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
int lps ( char * seq , int i , int j ) { if ( i == j ) return 1 ; if ( seq [ i ] == seq [ j ] && i + 1 == j ) return 2 ; if ( seq [ i ] == seq [ j ] ) return lps ( seq , i + 1 , j - 1 ) + 2 ; return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; }
int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int k ; int min = INT_MAX ; int count ; for ( k = i ; k < j ; k ++ ) { count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
void solve ( int arr [ ] , int N ) { map < int , int > M ; for ( int i = 0 ; i < N ; i ++ ) { M [ i ] = arr [ i ] ; } sort ( arr , arr + N ) ; unordered_map < int , int > Count ; for ( int i = 0 ; i < N ; i ++ ) { Count [ arr [ i ] ] = pow ( 2 , N - i - 1 ) ; } for ( auto & it : M ) { cout << Count [ M [ it . second ] ] << ' ' ; } }
int min_time_to_cut ( int N ) { if ( N == 0 ) return 0 ; return ceil ( log2 ( N ) ) ; }
void q3 ( string s , int i ) { if ( i == s . length ( ) ) { cout << "Yes \n" ; return ; } if ( s [ i ] == 'a' ) q4 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
int nthTerm ( int N ) { int nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
void start ( char c ) { if ( c == 't' c == 'T' ) dfa = 1 ; }
void isEqualSubstring ( string str , int x ) { int n = str . length ( ) ; int i = 0 ; while ( i < n && i < x ) { if ( str [ i ] != str [ n - i - 1 ] ) { cout << "false" ; return ; } i ++ ; } cout << "true" ; }
void canMakeEqual ( string S ) { int N = S . size ( ) ; int weightOfString = 0 ; for ( int i = 0 ; i < N ; i ++ ) { weightOfString += S [ i ] - 'a' + 1 ; } if ( weightOfString % N == 0 ) cout << "Yes" ; else cout << "No" ; }
void updateTree ( string s , treeNode * tree , int start , int end , int treeNode , int idx , char X ) { if ( ( start == end ) && ( idx == start ) ) { s [ idx ] = X ; tree [ treeNode ] . square_sum = pow ( X - 'a' + 1 , 2 ) ; return ; } int mid = start + ( ( end - start ) / 2 ) ; if ( idx <= mid ) { updateTree ( s , tree , start , mid , ( 2 * treeNode ) , idx , X ) ; } else { updateTree ( s , tree , mid + 1 , end , ( 2 * treeNode ) + 1 , idx , X ) ; } tree [ treeNode ] . square_sum = tree [ ( 2 * treeNode ) ] . square_sum + tree [ ( 2 * treeNode ) + 1 ] . square_sum ; }
void getPalindromePath ( Node * root ) { string finalAns = "$" ; lexicographicallySmall ( root , "" , finalAns ) ; if ( finalAns == "$" ) cout << "No Palindromic Path exists" ; else cout << finalAns ; }
int permute ( int n , int r ) { int ans = 0 ; ans = ( fact ( n ) / fact ( n - r ) ) ; return ans ; }
bool isValid ( char a1 , char a2 , string str , int flag ) { char v1 , v2 ; if ( flag == 0 ) { v1 = str [ 4 ] ; v2 = str [ 3 ] ; } else { v1 = str [ 1 ] ; v2 = str [ 0 ] ; } if ( v1 != a1 && v1 != '?' ) return false ; if ( v2 != a2 && v2 != '?' ) return false ; return true ; }
int minDel ( string s1 , string s2 ) { int i = s1 . length ( ) ; int j = s2 . length ( ) ; while ( i > 0 && j > 0 ) { if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) { break ; } i -- ; j -- ; } return i + j ; }
bool can_Construct ( string S , int K ) { map < int , int > m ; int i = 0 , j = 0 , p = 0 ; if ( S . length ( ) == K ) { return true ; } map < int , int > :: iterator h ; for ( i = 0 ; i < S . length ( ) ; i ++ ) { m [ S [ i ] ] = m [ S [ i ] ] + 1 ; } if ( K > S . length ( ) ) { return false ; } else { for ( h = m . begin ( ) ; h != m . end ( ) ; h ++ ) { if ( m [ h -> first ] % 2 != 0 ) { p = p + 1 ; } } } if ( K < p ) { return false ; } return true ; }
int bcdToDecimal ( string s ) { int len = s . length ( ) , check = 0 , check0 = 0 ; int num = 0 , sum = 0 , mul = 1 , rev = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { sum += ( s [ i ] - '0' ) * mul ; mul *= 2 ; check ++ ; if ( check == 4 i == 0 ) { if ( sum == 0 && check0 == 0 ) { num = 1 ; check0 = 1 ; } else { num = num * 10 + sum ; } check = 0 ; sum = 0 ; mul = 1 ; } } while ( num > 0 ) { rev = rev * 10 + ( num % 10 ) ; num /= 10 ; } if ( check0 == 1 ) return rev - 1 ; return rev ; }
bool isPossibleSum ( int N ) { if ( isPrime ( N ) && isPrime ( N - 2 ) ) { return true ; } else { return false ; } }
void findMaxFrequency ( string s ) { int arr [ 26 ] = { 0 } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) arr [ s [ i ] - 'a' ] ++ ; unordered_map < int , int > hash ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] != 0 ) hash [ arr [ i ] ] ++ ; int max_count = 0 , res = -1 ; for ( auto i : hash ) { if ( max_count < i . second ) { res = i . first ; max_count = i . second ; } } cout << "Frequency " << res << " is repeated " << max_count << " times" ; }
int checkIfStartsWithVowels ( string str ) { if ( ! ( str [ 0 ] == 'A' str [ 0 ] == 'a' str [ 0 ] == 'E' str [ 0 ] == 'e' str [ 0 ] == 'I' str [ 0 ] == 'i' str [ 0 ] == 'O' str [ 0 ] == 'o' str [ 0 ] == 'U' str [ 0 ] == 'u' ) ) return 1 ; else return 0 ; }
bool xExistsInY ( string x , string y ) { if ( x . size ( ) > y . size ( ) ) return false ; int cnt_x [ MAX ] = { 0 } ; int cnt [ MAX ] = { 0 } ; for ( int i = 0 ; i < x . size ( ) ; i ++ ) cnt_x [ x [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < x . size ( ) ; i ++ ) cnt [ y [ i ] - 'a' ] ++ ; if ( areEqual ( cnt_x , cnt ) ) return true ; for ( int i = 1 ; i < y . size ( ) - x . size ( ) + 1 ; i ++ ) { cnt [ y [ i - 1 ] - 'a' ] -- ; cnt [ y [ i + x . size ( ) - 1 ] - 'a' ] ++ ; if ( areEqual ( cnt , cnt_x ) ) return true ; } return false ; }
void updateFreq ( string str , int freq [ ] ) { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { freq [ str [ i ] - 'a' ] ++ ; } }
int cntWays ( string str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; }
int countSticks ( string str , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ str [ i ] - '0' ] ) ; } return cnt ; }
int countTotalDistinct ( string str ) { int cnt = 0 ; set < string > items ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { string temp = "" ; set < char > ans ; for ( int j = i ; j < str . length ( ) ; ++ j ) { temp = temp + str [ j ] ; ans . insert ( str [ j ] ) ; if ( items . find ( temp ) == items . end ( ) ) { items . insert ( temp ) ; cnt += ans . size ( ) ; } } } return cnt ; }
void getOrgString ( string s ) { cout << s [ 0 ] ; int i = 1 ; while ( i < s . length ( ) ) { if ( s [ i ] >= 'A' && s [ i ] <= 'Z' ) cout << " " << ( char ) tolower ( s [ i ] ) ; else cout << s [ i ] ; i ++ ; } }
int getIndex ( string s1 , string s2 , int len ) { int i = 0 , j = len - 1 ; while ( i < j ) { if ( s1 [ i ] != s2 [ j ] ) { break ; } i ++ ; j -- ; } if ( i == j ) { return i - 1 ; } else if ( isPalindrome ( s2 , i , j ) ) return i - 1 ; else if ( isPalindrome ( s1 , i , j ) ) return j ; return -1 ; }
int countSubStrings ( string s , string anotherStr , int k ) { bool illegal [ MAX_CHAR ] = { false } ; for ( int i = 0 ; i < anotherStr . size ( ) ; i ++ ) illegal [ anotherStr [ i ] ] = true ; unordered_set < string > us ; for ( int i = 0 ; i < s . size ( ) ; ++ i ) { string ss = "" ; int count = 0 ; for ( int j = i ; j < s . size ( ) ; ++ j ) { if ( illegal [ s [ j ] ] ) ++ count ; ss = ss + s [ j ] ; if ( count <= k ) { us . insert ( ss ) ; } else break ; } } return us . size ( ) ; }
int PrimeCharacters ( string s ) { vector < bool > prime ( max_val + 1 , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( prime [ int ( s [ i ] ) ] ) count ++ ; } return count ; }
int matchPattern ( string s ) { int count = 0 ; int n = s . length ( ) ; int i = 0 ; while ( i < n ) { while ( i < n && s [ i ] == 'a'  ) { count ++ ; i ++ ; } while ( i < n && s [ i ] == 'b'  ) { count -- ; i ++ ; } if ( count != 0 ) return false ; } return true ; }
bool compare ( char * arr1 , char * arr2 ) { for ( int i = 0 ; i < ALL_CHARS ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }
int maximum_one ( string s , int n ) { int cnt_one = 0 ; int max_cnt = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) { cnt_one ++ ; temp ++ ; } else { max_cnt = max ( temp , max_cnt ) ; temp = 0 ; } } max_cnt = max ( max_cnt , temp ) ; int left [ n ] , right [ n ] ; if ( s [ 0 ] == '1' ) left [ 0 ] = 1 ; else left [ 0 ] = 0 ; if ( s [ n - 1 ] == '1' ) right [ n - 1 ] = 1 ; else right [ n - 1 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) left [ i ] = left [ i - 1 ] + 1 ; else left [ i ] = 0 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) right [ i ] = right [ i + 1 ] + 1 ; else right [ i ] = 0 ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( s [ i ] == '0' ) { int sum = left [ i - 1 ] + right [ i + 1 ] ; if ( sum < cnt_one ) max_cnt = max ( max_cnt , sum + 1 ) ; else max_cnt = max ( max_cnt , sum ) ; } } return max_cnt ; }
char bitToBeFlipped ( string s ) { char last = s [ s . length ( ) - 1 ] ; char first = s [ 0 ] ; if ( last == first ) { if ( last == '0' ) { return '1' ; } else { return '0' ; } } else if ( last != first ) { return last ; } }
int countPalindrome ( string str ) { int n = str . size ( ) ; int sum = 0 ; int hashTable [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) hashTable [ str [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( hashTable [ i ] ) sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) / 2 ) ; } return sum ; }
int smallestNumber ( int n ) { int num = 0 ; string s = "" ; int duplicate = n ; while ( n ) { s = char ( n % 10 + 48 ) + s ; n /= 10 ; } int index = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int digit = s [ i ] - '0' ; if ( ( digit & 1 ) == 0 ) { index = i ; break ; } } if ( index == -1 ) return duplicate ; for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; num = num * 10 + ( s [ index ] - '0' + 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 + 1 ; return num ; }
int count_carry ( string a , string b ) { int carry = 0 ; int count = 0 ; int len_a = a . length ( ) , len_b = b . length ( ) ; while ( len_a != 0 len_b != 0 ) { int x = 0 , y = 0 ; if ( len_a > 0 ) { x = a [ len_a - 1 ] - '0' ; len_a -- ; } if ( len_b > 0 ) { y = b [ len_b - 1 ] - '0' ; len_b -- ; } int sum = x + y + carry ; if ( sum >= 10 ) { carry = 1 ; count ++ ; } else carry = 0 ; } return count ; }
int leastCount ( string s1 , string s2 , int n ) { int count1 [ MAX_CHAR ] = { 0 } ; int count2 [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { count1 [ s1 [ i ] - 'a' ] += 1 ; count2 [ s2 [ i ] - 'a' ] += 1 ; } int res = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( count1 [ i ] != 0 ) { res += abs ( count1 [ i ] - count2 [ i ] ) ; } } return res ; }
void allCharactersSame ( string s ) { set < char > s1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) s1 . insert ( s [ i ] ) ; if ( s1 . size ( ) == 1 ) cout << "YES" ; else cout << "NO" ; }
bool check_isogram ( string str ) { int length = str . length ( ) ; int mapHash [ 26 ] = { 0 } ; for ( int i = 0 ; i < length ; i ++ ) { mapHash [ str [ i ] - 'a' ] ++ ; if ( mapHash [ str [ i ] - 'a' ] > 1 ) { return false ; } } return true ; }
int maxLengthNonPalinSubstring ( string str ) { int n = str . size ( ) ; char ch = str . at ( 0 ) ; int i = 1 ; for ( i = 1 ; i < n ; i ++ ) if ( str . at ( i ) != ch ) break ; if ( i == n ) return 0 ; if ( isPalindrome ( str ) ) return n - 1 ; return n ; }
void traverseTree ( Node * root ) { if ( root == NULL ) return ; cout << root -> data << " " ; if ( root -> child == NULL ) return ; queue < Node * > q ; Node * curr = root -> child ; q . push ( curr ) ; while ( ! q . empty ( ) ) { curr = q . front ( ) ; q . pop ( ) ; while ( curr != NULL ) { cout << curr -> data << " " ; if ( curr -> child != NULL ) { q . push ( curr -> child ) ; } curr = curr -> next ; } } }
void transpose ( int mat [ ] [ MAX ] , int tr [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) tr [ i ] [ j ] = mat [ j ] [ i ] ; }
void qType1 ( int l , int x , char str [ ] ) { str [ l - 1 ] = x ; }
int getFrequency ( int tree [ max ] [ 27 ] , int idx , int i ) { int sum = 0 ; while ( idx > 0 ) { sum += tree [ idx ] [ i ] ; idx -= ( idx & - idx ) ; } return sum ; }
void qType2 ( int tree [ max ] [ 27 ] , int l , int r , char str [ ] ) { int count = 0 ; for ( int i = 1 ; i <= 26 ; i ++ ) { if ( l == 1 ) { if ( getFrequency ( tree , r , i ) % 2 == 1 ) count ++ ; } else { if ( ( getFrequency ( tree , r , i ) - getFrequency ( tree , l - 1 , i ) ) % 2 == 1 ) count ++ ; } } ( count <= 1 ) ? ( cout << "Yes" << endl ) : ( cout << "No" << endl ) ; }
int difference ( int arr [ ] [ MAX ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return abs ( d1 - d2 ) ; }
bool isValid ( int row , int col ) { return ( row >= 0 ) && ( col >= 0 ) && ( row < ROW ) && ( col < COL ) ; }
long comb ( int n , int r ) { long res = fact [ n ] / fact [ r ] ; res /= fact [ n - r ] ; return res ; }
void getMinPathSum ( unordered_map < int , vector < pair < int , int > > > & graph , vector < bool > & visited , vector < int > necessary , int src , int dest , int currSum ) { if ( src == dest ) { bool flag = true ; for ( int i : necessary ) { if ( ! visited [ i ] ) { flag = false ; break ; } } if ( flag ) minSum = min ( minSum , currSum ) ; return ; } else { visited [ src ] = true ; for ( auto node : graph [ src ] ) { if ( ! visited [ node . first ] ) { visited [ node . first ] = true ; getMinPathSum ( graph , visited , necessary , node . first , dest , currSum + node . second ) ; visited [ node . first ] = false ; } } visited [ src ] = false ; } }
bool is_clique ( int b ) { for ( int i = 1 ; i < b ; i ++ ) { for ( int j = i + 1 ; j < b ; j ++ ) if ( graph [ store [ i ] ] [ store [ j ] ] == 0 ) return false ; } return true ; }
void generateAllBinaryStrings ( int n , int arr [ ] , int i ) { if ( i == n ) { printTheArray ( arr , n ) ; return ; } arr [ i ] = 0 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; arr [ i ] = 1 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; }
int uniquePaths ( vector < vector < int > > & grid ) { int n = grid . size ( ) , m = grid [ 0 ] . size ( ) ; int ans = 0 ; vector < vector < bool > > vis ( n , vector < bool > ( m , 0 ) ) ; int x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { if ( grid [ i ] [ j ] == 0 ) z_count ++ ; else if ( grid [ i ] [ j ] == 1 ) { x = i , y = j ; } } } dfs ( x , y , grid , vis , ans , 0 , z_count ) ; return ans ; }
bool isPrime ( int x ) { int sqroot = sqrt ( x ) ; bool flag = true ; if ( x == 1 ) return false ; for ( int i = 2 ; i <= sqroot ; i ++ ) if ( x % i == 0 ) return false ; return true ; }
int minStepsRecur ( int height [ ] , int l , int r , int h ) { if ( l >= r ) return 0 ; int m = l ; for ( int i = l ; i < r ; i ++ ) if ( height [ i ] < height [ m ] ) m = i ; return min ( r - l , minStepsRecur ( height , l , m , height [ m ] ) + minStepsRecur ( height , m + 1 , r , height [ m ] ) + height [ m ] - h ) ; }
void findFrequency ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] ++ ; } for ( auto i : mp ) { cout << "Element " << i . first << " occurs " << i . second << " times" << endl ; } }
void secondary_polygon ( int Angle ) { int edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { int edges_max_secondary = edges_primary / 2 ; cout << edges_max_secondary + 3 ; } else cout << "Not Possible" ; }
void parallel ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { if ( ( - ( a1 / b1 ) ) == ( - ( a2 / b2 ) ) ) { cout << "Yes" ; } else { cout << "No" ; } }
int No_of_cubes ( int N , int K ) { int No = 0 ; No = ( N - K + 1 ) ; No = pow ( No , 3 ) ; return No ; }
void updateArray ( int x1 , int y1 , int x2 , int y2 ) { for ( int i = x1 ; i < x2 ; i ++ ) { for ( int j = y1 ; j < y2 ; j ++ ) { arr [ i ] [ j ] = true ; } } }
int calcAngle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) printf ( "Wrong input" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; int hour_angle = 0.5 * ( h * 60 + m ) ; int minute_angle = 6 * m ; int angle = abs ( hour_angle - minute_angle ) ; angle = min ( 360 - angle , angle ) ; return angle ; }
int heptacontagonNum ( int n ) { return ( 68 * n * n - 66 * n ) / 2 ; }
int octacontagonNum ( int n ) { return ( 78 * n * n - 76 * n ) / 2 ; }
int Pentadecagonal_num ( int n ) { return ( 13 * n * n - 11 * n ) / 2 ; }
int check ( int n , int m ) { if ( m % n == 0 ) { cout << "YES" ; } else { cout << "NO" ; } return 0 ; }
void dist ( double x1 , double y1 , double x2 , double y2 , double r ) { cout << "The shortest distance " << "between a point and a circle is " << sqrt ( ( pow ( ( x2 - x1 ) , 2 ) ) + ( pow ( ( y2 - y1 ) , 2 ) ) ) - r << endl ; }
float ellipse ( float l , float b ) { if ( l < 0 b < 0  ) return -1 ; float x = ( 3.14 * l * b ) / 4 ; return x ; }
float squareSide ( float a ) { if ( a < 0 ) return -1 ; float x = 0.423 * a ; return x ; }
float CubeVolume ( float d ) { float Volume ; Volume = ( sqrt ( 3 ) * pow ( d , 3 ) ) / 9 ; return Volume ; }
float cyl ( float r , float h ) { if ( r < 0 && h < 0 ) return -1 ; float R = ( 2 * r ) / 3 ; float H = ( 2 * h ) / 3 ; float V = 3.14 * pow ( R , 2 ) * H ; return V ; }
float perimeter ( float r ) { return ( 3.14 ) * ( r ) ; }
int hexadecagonalNum ( long int n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
int intersection ( int n ) { return n * ( n - 1 ) ; }
int numberOfWays ( int x ) { int dp [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
void check_and_print ( float required_time , float given_time ) { if ( required_time < given_time ) cout << "Overflow" ; else if ( required_time > given_time ) cout << "Underflow" ; else cout << "Filled" ; }
double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
int directionOfPoint ( point A , point B , point P ) { B . x -= A . x ; B . y -= A . y ; P . x -= A . x ; P . y -= A . y ; int cross_product = B . x * P . y - B . y * P . x ; if ( cross_product > 0 ) return RIGHT ; if ( cross_product < 0 ) return LEFT ; return ZERO ; }
double areaCube ( double a ) { return ( a * a * a ) ; }
int sqDist ( pair < int , int > p1 , pair < int , int > p2 ) { return ( p1 . first - p2 . first ) * ( p1 . first - p2 . first ) + ( p1 . second - p2 . second ) * ( p1 . second - p2 . second ) ; }
bool isSquare ( Point p1 , Point p2 , Point p3 , Point p4 ) { if ( d2 == 0 d3 == 0 d4 == 0 ) return false ; if ( d2 == d3 && 2 * d2 == d4 && 2 * distSq ( p2 , p4 ) == distSq ( p2 , p3 ) ) { return true ; } if ( d3 == d4 && 2 * d3 == d2 && 2 * distSq ( p3 , p2 ) == distSq ( p3 , p4 ) ) { return true ; } if ( d2 == d4 && 2 * d2 == d3 && 2 * distSq ( p2 , p3 ) == distSq ( p2 , p4 ) ) { return true ; } return false ; }
int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
int lastPositiveElement ( vector < int > arr ) { int N = arr . size ( ) ; if ( N == 1 ) return arr [ 0 ] ; int greatest = -1 , secondGreatest = -1 ; for ( int x : arr ) { if ( x >= greatest ) { secondGreatest = greatest ; greatest = x ; } else if ( x >= secondGreatest ) { secondGreatest = x ; } } return greatest - secondGreatest ; }
int countQuadruples ( int A [ ] , int N ) { int ans = 0 ; unordered_map < int , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { ans += freq [ A [ i ] ] ; for ( int j = 0 ; j < i ; j ++ ) { for ( int k = 0 ; k < j ; k ++ ) { freq [ A [ i ] * A [ j ] * A [ k ] ] ++ ; } } } return ans ; }
int countArrays ( int n , int k ) { int mod = 1000000007 ; int ans = power ( n , k , mod ) ; return ans ; }
void printInorder ( Node * root ) { if ( ! root ) return ; printInorder ( root -> left ) ; cout << root -> data << " " ; printInorder ( root -> right ) ; }
void countWays ( string s , string t ) { int n = s . length ( ) ; int sum1 = 0 , sum2 = 0 , K = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) { sum1 ++ ; } else sum1 -- ; } int m = t . length ( ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( t [ i ] == '1' ) { sum2 ++ ; } else if ( t [ i ] == '0' ) { sum2 -- ; } else K ++ ; } int P = abs ( sum1 - sum2 ) ; if ( P > K or ( K - P ) % 2 ) { cout << 0 ; return ; } cout << nCr ( K , ( P + K ) / 2 ) ; }
int pathCountDP ( int mat [ ] [ C ] , int k ) { memset ( dp , -1 , sizeof dp ) ; return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) ; }
bool isadjacent ( char prev , char curr ) { return ( ( curr - prev ) == 1 ) ; }
int getLen ( char mat [ R ] [ C ] , char s ) { memset ( dp , -1 , sizeof dp ) ; int ans = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == s ) { for ( int k = 0 ; k < 8 ; k ++ ) ans = max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , s ) ) ; } } } return ans ; }
bool isSmith ( int n ) { int original_no = n ; int pDigitSum = 0 ; for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { while ( n % primes [ i ] == 0 ) { int p = primes [ i ] ; n = n / p ; while ( p > 0 ) { pDigitSum += ( p % 10 ) ; p = p / 10 ; } } } if ( n != 1 && n != original_no ) { while ( n > 0 ) { pDigitSum = pDigitSum + n % 10 ; n = n / 10 ; } } int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits = sumDigits + original_no % 10 ; original_no = original_no / 10 ; } return ( pDigitSum == sumDigits ) ; }
void smallestPermutation ( int arr [ ] , int N ) { vector < bool > w ( 2 * N + 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { w [ arr [ i ] ] = true ; } set < int > S ; for ( int i = 1 ; i <= 2 * N ; i ++ ) { if ( ! w [ i ] ) S . insert ( i ) ; } bool found = true ; vector < int > P ; for ( int i = 0 ; i < N ; i ++ ) { auto it = S . lower_bound ( arr [ i ] ) ; if ( it == S . end ( ) ) { found = false ; break ; } P . push_back ( arr [ i ] ) ; P . push_back ( * it ) ; S . erase ( it ) ; } if ( ! found ) { cout << "-1\n" ; } else { for ( int i = 0 ; i < 2 * N ; i ++ ) cout << P [ i ] << " " ; } }
int findlcm ( int arr [ ] , int n ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; } return ans ; }
void findLast ( int mat [ ] [ 3 ] ) { int m = 3 ; int n = 3 ; set < int > rows ; set < int > cols ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] ) { rows . insert ( i ) ; cols . insert ( j ) ; } } } int avRows = m - rows . size ( ) ; int avCols = n - cols . size ( ) ; int choices = min ( avRows , avCols ) ; if ( choices & 1 ) cout << "P1" ; else cout << "P2" ; }
void nearestPowerDiff ( int arr [ ] , int N , int a , int b ) { for ( int i = 0 ; i < N ; i ++ ) { int log_a = log ( arr [ i ] ) / log ( a ) ; int A = pow ( a , log_a ) ; int B = pow ( a , log_a + 1 ) ; if ( ( arr [ i ] - A ) < ( B - arr [ i ] ) ) log_a = A ; else log_a = B ; int log_b = log ( arr [ i ] ) / log ( b ) ; A = pow ( b , log_b ) ; B = pow ( b , log_b + 1 ) ; if ( ( arr [ i ] - A ) < ( B - arr [ i ] ) ) log_b = A ; else log_b = B ; arr [ i ] = abs ( log_a - log_b ) ; } printArray ( arr , N ) ; }
bool checkEvenPower ( long long int N ) { if ( ( N & ( N - 1 ) ) != 0 ) return false ; N = N & 0x55555555 ; return ( N > 0 ) ; }
int distinct ( int arr [ ] , int n ) { map < int , int > mpp ; for ( int i = 0 ; i < n ; i ++ ) { mpp [ arr [ i ] ] = 1 ; } return mpp . size ( ) ; }
int power ( long long x , unsigned int y ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
bool isNonDeficient ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { sum = sum + i ; } else { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum >= 2 * n ; }
int lastElement ( const int arr [ ] , int n ) { int sum = 0 ; int multiplier = n % 2 == 0 ? -1 : 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * multiplier ; multiplier = multiplier * ( n - 1 - i ) / ( i + 1 ) * ( -1 ) ; } return sum ; }
