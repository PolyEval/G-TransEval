bool sumOfTwoCubes ( int n ) { int lo = 1 , hi = ( int ) Math . Pow ( n , ( 1.0 / 3.0 ) ) ; while ( lo <= hi ) { int curr = ( lo * lo * lo + hi * hi * hi ) ; if ( curr == n ) return true ; if ( curr < n ) lo ++ ; else hi -- ; } return false ; }
int countPairs ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] != 0 && a [ i ] % a [ j ] == 0 ) { if ( ( a [ i ] + a [ j ] ) == ( a [ i ] / a [ j ] ) ) count ++ ; } } } return count ; }
int check ( int A , int B ) { if ( A == B ) { return 1 ; } int dig1 = ( int ) Math . Floor ( Math . Log10 ( A ) + 1 ) ; int dig2 = ( int ) Math . Floor ( Math . Log10 ( B ) + 1 ) ; if ( dig1 != dig2 ) { return 0 ; } int temp = A ; while ( true ) { int power = ( int ) Math . Pow ( 10 , dig1 - 1 ) ; int firstdigit = A / power ; A = A - firstdigit * power ; A = A * 10 + firstdigit ; if ( A == B ) { return 1 ; } if ( A == temp ) { return 0 ; } } }
bool checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( Math . Sqrt ( x ) ) ; i ++ ) { if ( ( x == i * ( i + 1 ) ) != false ) { return true ; } } return false ; }
void oddDivisors ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int powerOfTwo = 2 ; int count = 0 ; while ( powerOfTwo <= arr [ i ] ) { count ++ ; powerOfTwo = 2 * powerOfTwo ; } Console . Write ( count + " " ) ; } return ; }
int calcScr ( List < int > arr ) { int ans = 0 ; for ( int i = 0 ; i < arr . Count ; i ++ ) ans += ( i ^ arr [ i ] ) ; return ans ; }
void maxAdjacent ( int [ ] arr , int N ) { List < int > res = new List < int > ( ) ; int arr_max = Int32 . MinValue ; for ( int i = 1 ; i < N ; i ++ ) { arr_max = Math . Max ( arr_max , Math . Abs ( arr [ i - 1 ] - arr [ i ] ) ) ; } for ( int i = 1 ; i < N - 1 ; i ++ ) { int curr_max = Math . Abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; int ans = Math . Max ( curr_max , arr_max ) ; res . Add ( ans ) ; } foreach ( int x in res ) Console . Write ( x + " " ) ; Console . WriteLine ( ) ; }
void flippingBits ( int N , int K ) { int X = ( 1 << ( K - 1 ) ) - 1 ; N = X - N ; Console . Write ( N ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
void minMoves ( int [ ] arr , int N ) { int odd_element_cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } int moves = ( odd_element_cnt ) / 2 ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; Console . Write ( moves ) ; }
int findSum ( int [ ] arr , int N ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] ++ ; } else { mp [ arr [ i ] ] = 1 ; } } int sum_odd = 0 , sum_even = 0 ; foreach ( KeyValuePair < int , int > itr in mp ) { if ( itr . Value % 2 != 0 ) sum_odd += ( itr . Key ) * ( itr . Value ) ; if ( itr . Value % 2 == 0 ) sum_even += ( itr . Key ) * ( itr . Value ) ; } int diff = sum_even - sum_odd ; return diff ; }
int findNumber ( int [ ] arr , int n ) { int res = 0 ; int maxElement = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res = res ^ arr [ i ] ; if ( maxElement < arr [ i ] ) maxElement = arr [ i ] ; } res = onesComplement ( res , maxElement ) ; return ( res ) ; }
int findValOfNWithOperat ( int N , int K ) { if ( N % 2 == 0 ) { N += K * 2 ; } else { N += smallestDivisorGr1 ( N ) + ( K - 1 ) * 2 ; } return N ; }
int CntOfSubsetsByPartitioning ( int [ ] arr , int N ) { Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . ContainsKey ( arr [ i ] ) ) { freq [ arr [ i ] ] = freq [ arr [ i ] ] + 1 ; } else { freq . Add ( arr [ i ] , 1 ) ; } } int freqGCD = 0 ; foreach ( KeyValuePair < int , int > i in freq ) { freqGCD = __gcd ( freqGCD , i . Value ) ; } return ( N ) / freqGCD ; }
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { alternateSum += - i ; } else { alternateSum += i ; } } return alternateSum ; }
int countOperations ( int [ ] arr , int N ) { int count_zeros = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) count_zeros ++ ; } int sum = array_sum ( arr , N ) ; if ( count_zeros != 0 ) return count_zeros ; if ( sum == 0 ) return 1 ; return 0 ; }
int power ( int x , int N ) { int res = 1 ; while ( N > 0 ) { if ( N % 2 == 1 ) { res = ( res * x ) ; } x = ( x * x ) ; N = N >> 1 ; } return res ; }
long F_1 ( long N , long F_N ) { long P_2 = power ( 2 , N - 1 ) ; long modInv = moduloInverse ( P_2 ) ; long res ; res = ( ( modInv % M ) * ( F_N % M ) ) % M ; return res ; }
void findNumbers ( int n ) { int i = 0 ; while ( i <= n ) { Console . Write ( 2 * i * i + 4 * i + 1 + i % 2 + " " ) ; i ++ ; } }
bool isPower ( int x , int y ) { double res1 = Math . Log ( y ) / Math . Log ( x ) ; double res2 = Math . Log ( y ) / Math . Log ( x ) ; return ( res1 == res2 ) ; }
int countPairs ( int [ ] A , int [ ] B , int N , int M , int [ , ] List ) { int count = 0 ; int [ ] par = new int [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) par [ i ] = i ; for ( int i = 0 ; i < M ; i ++ ) { int index1 = find ( par , List [ i , 0 ] - 1 ) ; int index2 = find ( par , List [ i , 1 ] - 1 ) ; if ( index1 != index2 ) { union ( par , index1 , index2 ) ; } } Dictionary < int , int > map = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( map . ContainsKey ( A [ i ] ) ) map [ A [ i ] ] = i ; else map . Add ( A [ i ] , i ) ; } for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { if ( ! map . ContainsKey ( B [ i ] ) ) { count ++ ; continue ; } int j = map [ B [ i ] ] ; if ( find ( par , i ) != find ( par , j ) ) count ++ ; } } return count ; }
void minDivisior ( int n ) { if ( prime ( n ) ) { Console . Write ( 1 + " " + ( n - 1 ) ) ; } else { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { Console . Write ( n / i + " " + ( n / i * ( i - 1 ) ) ) ; break ; } } } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int Find_min ( HashSet < int > diff_mod , Dictionary < int , int > count_mod , int k ) { int min_oprn = int . MaxValue ; int oprn = 0 ; for ( int x = 0 ; x < k ; x ++ ) { oprn = 0 ; foreach ( int w in diff_mod ) { if ( w != x ) { if ( w == 0 ) { oprn += Math . Min ( x , k - x ) * count_mod [ w ] ; } else { oprn += Math . Min ( Math . Abs ( x - w ) , k + x - w ) * count_mod [ w ] ; } } } if ( oprn < min_oprn ) min_oprn = oprn ; } return min_oprn ; }
double maxSubarrayRatio ( double [ ] arr , int n ) { double maxRatio = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { double ratio = arr [ i ] ; for ( int k = i + 1 ; k <= j ; k ++ ) { ratio = ratio / arr [ k ] ; } maxRatio = maximum ( maxRatio , ratio ) ; } } return maxRatio ; }
bool is_possible ( int x , int y ) { if ( x < 2 && y != 0 ) return false ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return true ; else return false ; }
int sum_of_differences ( int [ ] arr , int N ) { int sum = 0 ; int i , j , flag ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) { flag = 0 ; for ( j = i + 1 ; j < N - 1 ; j ++ ) { if ( arr [ j ] >= arr [ j + 1 ] ) { sum += ( arr [ j ] - arr [ i ] ) ; i = j ; flag = 1 ; break ; } } if ( flag == 0 && arr [ i ] < arr [ N - 1 ] ) { sum += ( arr [ N - 1 ] - arr [ i ] ) ; break ; } } } return sum ; }
void getLastTwoPerson ( int n ) { int total = n ; Node head = new Node ( 1 ) ; Node temp = head ; for ( int i = 2 ; i <= n ; i ++ ) { temp . next = new Node ( i ) ; temp = temp . next ; } temp . next = head ; temp = head ; Node del ; while ( total != 2 ) { del = temp . next . next ; temp . next . next = temp . next . next . next ; temp = temp . next ; del = null ; total -= 1 ; } Console . Write ( temp . val + " " + temp . next . val ) ; }
int gcd ( int x , int y ) { if ( x == 0 ) return y ; return gcd ( y % x , x ) ; }
bool check ( int n ) { int temp = n ; while ( temp > 0 ) { int last_digit = temp % 10 ; if ( last_digit == 0 last_digit == 1 ) return false ; if ( n % last_digit == 0 ) return false ; temp = temp / 10 ; } return true ; }
void costOfSubsequence ( int N , int [ ] arr , int [ ] costArray ) { int i , temp ; int cost = 0 ; HashSet < int > removedElements = new HashSet < int > ( ) ; int ans = 0 ; for ( i = 1 ; i < ( N - 1 ) ; i ++ ) { temp = arr [ i ] ; if ( ( ( arr [ i - 1 ] < temp ) && ( temp < arr [ i + 1 ] ) ) || ( ( arr [ i - 1 ] > temp ) && ( temp > arr [ i + 1 ] ) ) ) { removedElements . Add ( temp ) ; } } for ( i = 0 ; i < ( N ) ; i ++ ) { temp = arr [ i ] ; if ( ! ( removedElements . Contains ( temp ) ) ) { ans += arr [ i ] ; } else { cost += costArray [ i ] ; } } Console . Write ( ans + ", " ) ; Console . Write ( cost ) ; }
void findRatio ( int [ ] arr , int n ) { int gcd = findGCD ( arr , n ) ; int lcm = findLCM ( arr , n ) ; Console . Write ( ( lcm / gcd ) ) ; Console . Write ( ":1" ) ; }
int PentacontahenagonNum ( int N ) { return ( 49 * N * N - 47 * N ) / 2 ; }
bool isRepdigit ( int num , int b ) { int prev = - 1 ; while ( num != 0 ) { int digit = num % b ; num /= b ; if ( prev != - 1 && digit != prev ) return false ; prev = digit ; } return true ; }
bool isHonakerPrime ( int n ) { int pos = position [ n ] ; if ( pos == - 1 ) return false ; return getSum ( n ) == getSum ( pos ) ; }
bool checkDivisibility ( int n , int digit ) { return ( digit != 0 && n % digit == 0 ) ; }
int lastDigit ( int n ) { return ( n % 10 ) ; }
int count ( int [ ] arr , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( check ( arr [ i ] & arr [ j ] ) ) cnt ++ ; } } return cnt ; }
void calculate_SPF ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i <= MAX ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i <= MAX ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j <= MAX ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
bool isBrilliant ( int n ) { bool [ ] isPrime = new bool [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 2 ; i < n ; i ++ ) { int x = n / i ; if ( isPrime [ i ] && isPrime [ x ] && ( x * i ) == n ) { if ( countDigit ( i ) == countDigit ( x ) ) return true ; } } return false ; }
int icosikaienneagonalNum ( int n ) { return ( 27 * n * n - 25 * n ) / 2 ; }
bool isPerfectTotientNum ( int n ) { int temp = n ; int sum = 0 ; while ( n > 1 ) { sum = sum + phi ( n ) ; n = phi ( n ) ; } if ( sum == temp ) return true ; return false ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
void solve ( int N ) { int ans = 0 ; while ( N != 0 ) { ans += N ; N /= 2 ; } Console . Write ( ans ) ; }
void smallestNumber ( int N ) { int L = ( int ) ( Math . Pow ( 10 , N ) - 1 ) ; int S = ( int ) Math . Pow ( 10 , N - 1 ) ; for ( int i = S ; i <= L ; i ++ ) { if ( i % N == 0 ) { Console . Write ( i ) ; return ; } } }
int maxAdjacentDifference ( int N , int K ) { if ( N == 1 ) { return 0 ; } if ( N == 2 ) { return K ; } return 2 * K ; }
int CountPairs ( int [ ] arr , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return ( even * ( even - 1 ) ) / 2 + ( even * odd ) ; }
int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
void smallestNumber ( int N ) { int i = 1 ; while ( 1 != 0 ) { if ( getSum ( i ) == N ) { Console . Write ( i ) ; break ; } i ++ ; } }
bool isZuckerman ( int n ) { return n % getProduct ( n ) == 0 ; }
bool isGiugaNum ( int n ) { if ( ! ( isComposite ( n ) ) ) return false ; int N = n ; while ( n % 2 == 0 ) { if ( ( N / 2 - 1 ) % 2 != 0 ) return false ; n = n / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( ( N / i - 1 ) % i != 0 ) return false ; n = n / i ; } } if ( n > 2 ) if ( ( N / n - 1 ) % n != 0 ) return false ; return true ; }
void updateFreq ( int n , int [ ] freq ) { while ( n > 0 ) { int digit = n % TEN ; freq [ digit ] ++ ; n /= TEN ; } }
bool OrmistonPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && areAnagrams ( n1 , n2 ) ) ; }
int calculateKummer ( int n ) { int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result = result * primes [ i ] ; return - 1 + result ; }
void SieveOfEratosthenes ( int maxm ) { prime [ 0 ] = prime [ 1 ] = true ; for ( int i = 2 ; i * i <= maxm ; i ++ ) { if ( ! prime [ i ] ) { for ( int j = i * i ; j <= maxm ; j += i ) { prime [ j ] = true ; } } } }
long func ( int [ ] arr , int n ) { double ans = 0 ; int maxx = 0 ; double [ ] freq = new double [ 100005 ] ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = Math . Max ( maxx , temp ) ; } for ( int i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( int i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] != 0 ) { double j ; double cur = Math . Ceiling ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { int val = Math . Min ( maxx , ( int ) ( Math . Ceiling ( i * j ) - 1.0 ) ) ; int times = ( int ) ( freq [ i ] - freq [ i - 1 ] ) , con = ( int ) ( j - 0.5 ) ; ans += times * con * ( freq [ ( int ) val ] - freq [ ( int ) cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ( long ) ans ; }
double findAverageOfCube ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * i * i ; } return sum / n ; }
int find ( int x ) { if ( x == 0 ) return 0 ; int p = ( int ) ( Math . Log ( x ) / Math . Log ( 2 ) ) ; return binpow ( 2 , p + 1 ) - 1 ; }
int totalCountDifference ( int n ) { string ans = getBinary ( n ) ; int req = 0 ; for ( int i = 0 ; i < ans . Length ; i ++ ) { if ( ans [ i ] == '1' ) { req += find ( binpow ( 2 , i ) ) ; } } return req ; }
double findIndex ( int n ) { double x = Math . Sqrt ( 2 * Math . Pow ( 10 , ( n - 1 ) ) ) ; return Math . Round ( x ) ; }
void getParity ( int n , int [ ] A ) { foreach ( int x in A ) { if ( ( x & 1 ) == 1 ) { Console . WriteLine ( "Even" ) ; return ; } } Console . WriteLine ( "Odd" ) ; }
void lastTwoDigits ( double N ) { if ( N >= 10 ) { Console . Write ( "00" ) ; return ; } double fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fac = ( fac * i ) % 100 ; Console . Write ( fac ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }
int findArrangement ( int N ) { if ( N < 3 ) return 0 ; return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) / 3 ; }
int sumOfProductOfDigits ( int n1 , int n2 ) { int sum = 0 ; while ( n1 > 0 && n2 > 0 ) { sum += ( ( n1 % 10 ) * ( n2 % 10 ) ) ; n1 /= 10 ; n2 /= 10 ; } return sum ; }
bool divisorsSame ( int n ) { return ( n - 2 ) % 4 == 0 ; }
int countSubsequences ( int [ ] arr , int n ) { int totalSubsequence = ( int ) ( Math . Pow ( 2 , n ) - 1 ) ; int countPrime = 0 , countOnes = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) countOnes ++ ; else if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } int compositeSubsequence ; int onesSequence = ( int ) ( Math . Pow ( 2 , countOnes ) - 1 ) ; compositeSubsequence = totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ; return compositeSubsequence ; }
int Centered_Hexadecagonal_num ( int n ) { return ( 8 * n * n - 8 * n + 1 ) ; }
bool isdecagonal ( int N ) { double n = ( 3 + Math . Sqrt ( 16 * N + 9 ) ) / 8 ; return ( n - ( int ) n ) == 0 ; }
bool ishendecagonal ( int N ) { double n = ( 7 + Math . Sqrt ( 72 * N + 49 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; }
bool isenneadecagonal ( int N ) { float n = ( float ) ( 15 + Math . Sqrt ( 136 * N + 225 ) ) / 34 ; return ( n - ( int ) n ) == 0 ; }
bool isPowerOfTwo ( int n ) { return ( Math . Ceiling ( Math . Log ( n ) / Math . Log ( 2 ) ) == Math . Floor ( Math . Log ( n ) / Math . Log ( 2 ) ) ) ; }
void cntArray ( int [ ] A , int N ) { int result = 0 ; int [ ] frequency = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { frequency [ A [ i ] ] ++ ; } for ( int i = 1 ; i <= N ; i ++ ) { int frequency_of_i = frequency [ i ] ; result += ( ( frequency_of_i ) * ( frequency_of_i + 1 ) ) / 2 ; } Console . Write ( result ) ; }
string solve ( int [ ] A ) { int i , ctr = 0 ; for ( i = 0 ; i < A . Length ; i ++ ) { if ( A [ i ] % 2 == 1 ) { ctr ++ ; } } if ( ctr % 2 == 1 ) { return "No" ; } else { return "Yes" ; } }
void findNumbers ( int N ) { for ( int i = 1 ; i <= ( N / 2 ) ; i ++ ) { Console . Write ( i + ", " + - i + ", " ) ; } if ( N % 2 == 1 ) Console . Write ( 0 ) ; }
int previousPerfectSquare ( int N ) { int prevN = ( int ) Math . Floor ( Math . Sqrt ( N ) ) ; if ( prevN * prevN == N ) prevN -= 1 ; return prevN * prevN ; }
int digit_sum ( int n ) { int sum = 0 , m ; while ( n > 0 ) { m = n % 10 ; sum = sum + m ; n = n / 10 ; } return ( sum ) ; }
void dfs ( int node , int parent ) { if ( isPerfect ( weight [ node ] ) ) ans += 1 ; foreach ( int to in graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } }
int MinimumGCD ( int [ ] arr , int n ) { int g = 0 ; for ( int i = 0 ; i < n ; i ++ ) { g = __gcd ( g , arr [ i ] ) ; } return g ; }
void fibonacciSubarrays ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int sum = 0 ; for ( int j = i ; j < n ; ++ j ) { sum += arr [ j ] ; if ( isFibonacci ( sum ) ) { ++ count ; } } } Console . Write ( count ) ; }
double Gill ( double x0 , double y0 , double x , double h ) { int n = ( int ) ( ( x - x0 ) / h ) ; double k1 , k2 , k3 , k4 ; double y = y0 ; for ( int i = 1 ; i <= n ; i ++ ) { k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; k3 = h * dydx ( x0 + 0.5 * h , y + 0.5 * ( - 1 + Math . Sqrt ( 2 ) ) * k1 + k2 * ( 1 - 0.5 * Math . Sqrt ( 2 ) ) ) ; k4 = h * dydx ( x0 + h , y - ( 0.5 * Math . Sqrt ( 2 ) ) * k2 + k3 * ( 1 + 0.5 * Math . Sqrt ( 2 ) ) ) ; y = y + ( 1.0 / 6 ) * ( k1 + ( 2 - Math . Sqrt ( 2 ) ) * k2 + ( 2 + Math . Sqrt ( 2 ) ) * k3 + k4 ) ; x0 = x0 + h ; } return y ; }
void PythagoreanTriplet ( int n ) { int flag = 0 ; for ( int a = 1 ; a < n ; a ++ ) { int b = ( n * n - 2 * n * a ) / ( 2 * n - 2 * a ) ; int c = n - a - b ; if ( a * a + b * b == c * c && b > 0 && c > 0 ) { Console . Write ( a + " " + b + " " + c ) ; flag = 1 ; break ; } } if ( flag == 0 ) { Console . Write ( "-1" ) ; } return ; }
void Display ( int [ ] arr , bool [ ] Expo_Prime , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( Expo_Prime [ arr [ i ] ] ) Console . Write ( arr [ i ] + " " ) ; }
float operations ( int N ) { int x = probability ( N ) ; int y = ( int ) Math . Pow ( 2 , N ) ; return round ( ( float ) x / ( float ) y , 2 ) ; }
int pairs ( int n ) { int [ , ] c = new int [ 10 , 10 ] ; int tmp = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ i / tmp , i % 10 ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) for ( int j = 1 ; j < 10 ; j ++ ) ans += c [ i , j ] * c [ j , i ] ; return ans ; }
int gcdFibonacciFreq ( int [ ] arr , int n ) { HashSet < int > hash = new HashSet < int > ( ) ; createHash ( hash , hash . Count > 0 ? hash . Max ( ) : 0 ) ; int i ; Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( m . ContainsKey ( arr [ i ] ) ) { m [ arr [ i ] ] = m [ arr [ i ] ] + 1 ; } else { m . Add ( arr [ i ] , 1 ) ; } } int gcd = 0 ; foreach ( KeyValuePair < int , int > it in m ) { if ( hash . Contains ( it . Value ) ) { gcd = __gcd ( gcd , it . Key ) ; } } return gcd ; }
string sumBaseB ( string a , string b , int base_var ) { int len_a , len_b ; len_a = a . Length ; len_b = b . Length ; string sum , s ; s = "" ; sum = "" ; int diff ; diff = Math . Abs ( len_a - len_b ) ; for ( int i = 1 ; i <= diff ; i ++ ) s += "0" ; if ( len_a < len_b ) a = s + a ; else b = s + b ; int curr , carry = 0 ; for ( int i = Math . Max ( len_a , len_b ) - 1 ; i > - 1 ; i -- ) { curr = carry + ( a [ i ] - '0' ) + ( b [ i ] - '0' ) ; carry = curr / base_var ; curr = curr % base_var ; sum = ( char ) ( curr + '0' ) + sum ; } if ( carry > 0 ) sum = ( char ) ( carry + '0' ) + sum ; return sum ; }
bool isPerfectCube ( int x ) { double cr = Math . Round ( Math . Cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; }
int countPairsWithProdK ( int [ ] arr , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == k ) count ++ ; } return count ; }
void genArray ( int [ ] arr , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( search ( arr , i , arr [ i ] ) == - 1 ) arr [ i + 1 ] = 0 ; else arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) ; } }
List < int > getPerfectcubes ( int n ) { List < int > perfectcubes = new List < int > ( ) ; int current = 1 ; int i = 1 ; while ( current <= n ) { perfectcubes . Add ( current ) ; i += 1 ; current = ( int ) ( Math . Pow ( i , 3 ) ) ; } return perfectcubes ; }
Dictionary < int , int > insertPF ( Dictionary < int , int > primeFact , int fact ) { if ( primeFact . ContainsKey ( fact ) ) { int freq ; freq = primeFact [ fact ] ; primeFact [ fact ] = ++ freq ; } else { primeFact . Add ( fact , 1 ) ; } return primeFact ; }
void isPerfectSquare ( int x ) { int sr = ( int ) Math . Sqrt ( x ) ; if ( sr * sr == x ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
void canBePerfectCube ( int N , int K ) { if ( isPerfectCube ( N + K ) || isPerfectCube ( N - K ) == true ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
int summation ( int n ) { int abs_sum = ( int ) ( n * ( n + 1 ) / 2 ) ; int sign = n + 1 % 2 == 0 ? 1 : - 1 ; int result_sum = sign * abs_sum ; return result_sum ; }
List < int > findArray ( int [ ] xorr , int n ) { List < int > arr = new List < int > ( ) ; int xor_all = xor_all_elements ( n ) ; int xor_adjacent = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { xor_adjacent = xor_adjacent ^ xorr [ i ] ; } int last_element = xor_all ^ xor_adjacent ; arr . Add ( last_element ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { last_element = xorr [ i ] ^ last_element ; arr . Add ( last_element ) ; } return arr ; }
void compute ( ) { for ( long i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i ) ; } }
int calNum ( int year ) { return ( year / 4 ) - ( year / 100 ) + ( year / 400 ) ; }
int maxValue ( int n ) { return n ; }
void findSum ( int [ ] arr , int n ) { sieve ( MAX ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = min_prime [ arr [ i ] ] + max_prime [ arr [ i ] ] ; Console . Write ( sum + " " ) ; } }
double squareRoot ( double n , double l ) { double x = n ; double root ; int count = 0 ; while ( true ) { count ++ ; root = 0.5 * ( x + ( n / x ) ) ; if ( Math . Abs ( root - x ) < l ) break ; x = root ; } return root ; }
int countNumber ( int N , int S ) { int countElements = 0 ; int currSum = 0 ; while ( currSum <= S ) { currSum += N ; N -- ; countElements ++ ; } return countElements ; }
int countDistinct ( int n ) { int [ ] arr = new int [ 10 ] ; int count = 0 ; while ( n != 0 ) { int r = n % 10 ; arr [ r ] = 1 ; n /= 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( arr [ i ] != 0 ) count ++ ; } return count ; }
int lcm ( int a , int b ) { return ( a / __gcd ( a , b ) * b ) ; }
bool checkZeroArray ( int [ ] arr , int n ) { int sum = 0 , maximum = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + arr [ i ] ; maximum = Math . Max ( maximum , arr [ i ] ) ; } if ( sum % 2 == 0 && maximum <= sum / 2 ) return true ; return false ; }
long getSum ( int n ) { int start = ( int ) Math . Pow ( 10 , n - 1 ) ; int end = ( int ) ( Math . Pow ( 10 , n ) - 1 ) ; long sum = 0 ; for ( int i = start ; i <= end ; i ++ ) { string s = i . ToString ( ) ; ; if ( isPalindrome ( s ) ) { sum += i ; } } return sum ; }
int findMinDel ( int [ ] arr , int n ) { int min_num = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) min_num = Math . Min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; }
bool isPossible ( int x , int y ) { if ( ( x - y ) == 1 ) return false ; return true ; }
int numSeq ( int n ) { return ( int ) ( ( Math . Pow ( 3 , n ) + 3 * Math . Pow ( - 1 , n ) ) / 4 ) ; }
bool digitDividesK ( int num , int k ) { while ( num != 0 ) { int d = num % 10 ; if ( d != 0 && k % d == 0 ) return true ; num = num / 10 ; } return false ; }
int xorK ( int n , int k ) { int res = n ; for ( int i = 1 ; i < k ; i ++ ) res = ( res ^ n ) ; return n ; }
bool distinctDigits ( int x ) { bool [ ] present = new bool [ MAX ] ; while ( x > 0 ) { int digit = x % 10 ; if ( present [ digit ] ) return false ; present [ digit ] = true ; x /= 10 ; } return true ; }
bool isPossible ( int [ ] arr , int n , int p ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( gcd , arr [ i ] ) ; if ( p % gcd == 0 ) return true ; return false ; }
int cntCakes ( int n , int m ) { int sum = ( n * ( n + 1 ) ) / 2 ; int quo = m / sum ; int rem = m % sum ; double ans = m - quo * sum ; double x = ( - 1 + Math . Pow ( ( 8 * rem ) + 1 , 0.5 ) ) / 2 ; ans = ans - x * ( x + 1 ) / 2 ; return ( int ) ans ; }
int factMod ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact *= ( i % MOD ) ; fact %= MOD ; } return fact ; }
bool isEulerPseudoprime ( int N , int A ) { if ( A <= 0 ) return false ; if ( N % 2 == 0 || ! isComposite ( N ) ) return false ; if ( __gcd ( A , N ) != 1 ) return false ; int mod = Power ( A , ( N - 1 ) / 2 , N ) ; if ( mod != 1 && mod != N - 1 ) return false ; return true ; }
int minDifference ( int L , int R ) { int fst = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( isPrime [ i ] ) { fst = i ; break ; } } int snd = 0 ; for ( int i = fst + 1 ; i <= R ; i ++ ) { if ( isPrime [ i ] ) { snd = i ; break ; } } if ( snd == 0 ) return - 1 ; int diff = snd - fst ; int left = snd + 1 ; int right = R ; for ( int i = left ; i <= right ; i ++ ) { if ( isPrime [ i ] ) { if ( i - snd <= diff ) { fst = snd ; snd = i ; diff = snd - fst ; } } } return diff ; }
int binomialCoeff ( int n , int k ) { int [ , ] C = new int [ n + 1 , k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } return C [ n , k ] ; }
int no_of_ways ( int [ ] a , int n ) { int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; } if ( count_1 % 2 == 0 ) return count_0 ; else return count_1 ; }
int longest_gap ( int N ) { int distance = 0 , count = 0 , first_1 = - 1 , last_1 = - 1 ; while ( N != 0 ) { count ++ ; int r = N & 1 ; if ( r == 1 ) { first_1 = first_1 == - 1 ? count : first_1 ; last_1 = count ; } N = N / 2 ; } if ( last_1 <= first_1 ) { return - 1 ; } else { distance = ( last_1 - first_1 - 1 ) ; return distance ; } }
bool isPossible ( int n ) { int cnt = CountBits ( n ) ; if ( cnt == TOTAL_BITS / 2 ) return true ; return false ; }
int total_ways ( int N , int X ) { return ( nCr ( N - 1 , X - 1 ) + nCr ( N - 1 , X ) ) ; }
double getSum ( int n ) { double sum = 0 ; int k = ( int ) Math . Sqrt ( n ) ; for ( int i = 1 ; i <= k ; i ++ ) { sum += Math . Floor ( ( double ) n / i ) ; } sum *= 2 ; sum -= Math . Pow ( k , 2 ) ; return sum ; }
int getCount ( int l , int r , int p ) { int cnt = 0 ; int val = p ; while ( true ) { int a = r / val ; int b = ( l - 1 ) / val ; val *= p ; if ( ( a - b ) > 0 ) { cnt += ( a - b ) ; } else break ; } return cnt ; }
void heapify ( int [ ] arr , int n , int i ) { int smallest = i ; int l = 2 * i + 1 ; int r = 2 * i + 2 ; if ( l < n && arr [ l ] < arr [ smallest ] ) smallest = l ; if ( r < n && arr [ r ] < arr [ smallest ] ) smallest = r ; if ( smallest != i ) { int temp = arr [ i ] ; arr [ i ] = arr [ smallest ] ; arr [ smallest ] = temp ; heapify ( arr , n , smallest ) ; } }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int nextPrime ( int N ) { if ( N <= 1 ) return 2 ; int prime = N ; bool found = false ; while ( ! found ) { prime ++ ; if ( isPrime ( prime ) ) found = true ; } return prime ; }
void find_Solution ( double x , int n ) { double sum = x , e = 2 , o = 1 , p = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { p += 2 ; sum += ( double ) ( o / e ) * ( double ) ( Math . Pow ( x , p ) / p ) ; o = o * ( o + 2 ) ; e = e * ( e + 2 ) ; } Console . WriteLine ( sum ) ; }
void solveOdd ( int n , int [ ] arr , int [ ] b ) { int left = n - 1 ; for ( int i = 0 ; i < ( n / 2 ) + 1 ; ++ i ) { b [ i ] = arr [ left ] ; left = left - 2 ; if ( left < 0 ) break ; } int right = 1 ; for ( int i = ( n / 2 ) + 1 ; i <= n - 1 ; ++ i ) { b [ i ] = arr [ right ] ; right = right + 2 ; if ( right > n - 2 ) break ; } }
int countSetBits ( int n ) { n ++ ; int powerOf2 = 2 ; int cnt = n / 2 ; while ( powerOf2 <= n ) { int totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs % 2 == 1 ) ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; }
int nCr ( int n ) { if ( n < 4 ) return 0 ; int answer = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; answer /= 24 ; return answer ; }
int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
int findReachable ( int [ ] arr , int D , int A , int B , int n ) { int gcd_AB = GCD ( A , B ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - D ) % gcd_AB == 0 ) count ++ ; } return count ; }
int getSum ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 && arr [ i ] == sumOfFactors ( arr [ i ] ) ) { sum += arr [ i ] ; } } return sum ; }
bool isPossible ( int k ) { if ( ! exists_zero ) { if ( k >= cnt_neg && ( k - cnt_neg ) % 2 == 0 ) return true ; else return false ; } else { if ( k >= cnt_neg ) return true ; else return false ; } }
long power ( int x , long y ) { long res = 1 ; while ( y > 0 ) { if ( y == 1 ) res = ( res * x ) ; y = y >> 1 ; x = ( x * x ) ; } return res ; }
long solve ( int L ) { int n = L / 2 + 1 ; long ans = power ( n , n - 2 ) ; return ans ; }
long total_permutations ( Dictionary < char , int > freq ) { long cnt = 0 ; long denom = 1 ; foreach ( KeyValuePair < char , int > itr in freq ) { denom *= fact ( itr . Value ) ; cnt += itr . Value ; } return fact ( cnt ) / denom ; }
int solveQuery ( int L , int X ) { int res ; int [ ] a = new int [ MAXN ] ; int [ ] b = new int [ L ] ; int refer = X , size_a = 0 ; while ( refer > 0 ) { a [ size_a ] = refer % 2 ; refer /= 2 ; size_a ++ ; } for ( int i = 0 ; i < Math . Min ( size_a , L ) ; i ++ ) { if ( a [ i ] == 1 ) b [ i ] = 0 ; else b [ i ] = 1 ; } for ( int i = Math . Min ( size_a , L ) ; i < L ; i ++ ) b [ i ] = 1 ; b [ L - 1 ] = 1 ; int temp = 0 , p = 1 ; for ( int i = 0 ; i < L ; i ++ ) { temp += b [ i ] * p ; p *= 2 ; } res = temp ^ X ; return res ; }
int closetAND ( int [ ] arr , int n , int k ) { int ans = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . Min ( ans , Math . Abs ( k - X ) ) ; if ( X <= k ) break ; } } return ans ; }
int countQuadruplets ( int l , int r , int k ) { int [ ] frequency = new int [ r + 1 ] ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = l ; j <= r ; j ++ ) { frequency [ gcd ( i , j ) ] ++ ; } } long answer = 0 ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= r ; j ++ ) { if ( gcd ( i , j ) == k ) { answer += ( frequency [ i ] * frequency [ j ] ) ; } } } return ( int ) answer ; }
int maxBitElement ( int [ ] arr , int n ) { int num = 0 , max = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = BitCount ( arr [ i ] ) ; if ( cnt > max ) { max = cnt ; num = arr [ i ] ; } } return num ; }
void Add_Edge ( int u , int v ) { gr [ u ] . Add ( v ) ; gr [ v ] . Add ( u ) ; }
long factorial ( long n , long p ) { for ( int i = 2 ; i <= n ; i ++ ) res = ( res * i ) % p ; return res ; }
int getValueOfF ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; int cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n /= 2 ; } return 2 * cnt ; }
void printNumbers ( int [ ] a , int n , int x ) { bool flag = false ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; int g = __gcd ( num , x ) ; while ( g != 1 ) { num /= g ; g = __gcd ( num , x ) ; } if ( num == 1 ) { flag = true ; Console . Write ( a [ i ] + " " ) ; } } if ( ! flag ) Console . WriteLine ( "There are no such numbers" ) ; }
void line ( double x0 , double y0 ) { double c = ( int ) ( 2 * y0 * x0 ) ; Console . WriteLine ( y0 + "x" + " + " + x0 + "y = " + c ) ; }
bool isDudeney ( int n ) { int cube_rt = ( int ) ( Math . Round ( ( Math . Pow ( n , 1.0 / 3.0 ) ) ) ) ; if ( cube_rt * cube_rt * cube_rt != n ) return false ; int dig_sum = 0 ; int temp = n ; while ( temp > 0 ) { int rem = temp % 10 ; dig_sum += rem ; temp /= 10 ; } if ( cube_rt != dig_sum ) return false ; return true ; }
void Positive_Divisors ( ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) d [ i ] ++ ; else d [ i ] += 2 ; } } } int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( d [ i ] == d [ i - 1 ] ) ans ++ ; pre [ i ] = ans ; } }
int oddDays ( int N ) { int hund1 = N / 100 ; int hund4 = N / 400 ; int leap = N >> 2 ; int ord = N - leap ; if ( hund1 > 0 ) { ord += hund1 ; leap -= hund1 ; } if ( hund4 > 0 ) { ord -= hund4 ; leap += hund4 ; } int days = ord + leap * 2 ; int odd = days % 7 ; return odd ; }
float ellipsearea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( float ) ( ( 3.14 * r * r ) / 4 ) ; return a ; }
int recamanGenerator ( int [ ] arr , int n ) { arr [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == temp ) temp < 0 ) { temp = arr [ i - 1 ] + i ; break ; } } arr [ i ] = temp ; } return 0 ; }
long power ( long a , long n ) { if ( n == 0 ) return 1 ; long p = power ( a , n / 2 ) ; p = p * p ; if ( n % 2 == 1 ) p = p * a ; return p ; }
int findPairCount ( int N , int K ) { int count = 0 ; int [ ] rem = new int [ K ] ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ; if ( K % 2 == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }
bool doesContainB ( int a , int b , int c ) { if ( a == b ) { return true ; } if ( ( b - a ) * c > 0 && ( b - a ) % c == 0 ) { return true ; } return false ; }
void sieve ( ) { Array . Fill ( prime , true ) ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int i = 2 ; i < N ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * 2 ; j < N ; j += i ) { prime [ j ] = false ; } } } }
void lastDigit ( String a , String b ) { int lastDig = ( a [ a . Length - 1 ] - '0' ) * ( b [ b . Length - 1 ] - '0' ) ; Console . Write ( lastDig % 10 ) ; }
void printPalindrome ( int n ) { if ( n == 1 ) { Console . WriteLine ( "Smallest Palindrome: 0" ) ; Console . WriteLine ( "Largest Palindrome: 9" ) ; } else { Console . WriteLine ( "Smallest Palindrome: " + ( int ) ( Math . Pow ( 10 , n - 1 ) ) + 1 ) ; Console . WriteLine ( "Largest Palindrome: " + ( ( int ) ( Math . Pow ( 10 , n ) ) - 1 ) ) ; } }
int countDigits ( int a , int b ) { int count = 0 ; int p = Math . Abs ( a / b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
void nDigitPerfectCubes ( int n ) { int smallest = ( int ) Math . Pow ( Math . Ceiling ( MathF . Cbrt ( ( float ) Math . Pow ( 10 , ( n - 1 ) ) ) ) , 3 ) ; Console . Write ( smallest + " " ) ; int largest = ( int ) Math . Pow ( Math . Ceiling ( MathF . Cbrt ( ( float ) Math . Pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ; Console . Write ( largest ) ; }
int sumOfSeries ( int n ) { int ans = ( int ) Math . Pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; }
int countNumbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * ( int ) Math . Pow ( 10 , n / 2 - 1 ) ) ; }
int KthMinValAfterMconcatenate ( int [ ] A , int N , int M , int K ) { Array . Sort ( A ) ; return ( A [ ( ( K - 1 ) / M ) ] ) ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : factorial ( n - 1 ) * n ; }
int gcdOfFactorial ( int [ ] arr , int n ) { int minm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minm = minm > arr [ i ] ? arr [ i ] : minm ; return factorial ( minm ) ; }
int findMinimum ( int n , int m ) { int mini = m ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int sec = n / i ; if ( __gcd ( m , i ) > 1 ) { return i ; } else if ( __gcd ( sec , m ) > 1 ) { mini = Math . Min ( sec , mini ) ; } } } if ( mini == m ) return - 1 ; else return mini ; }
double getProbability ( int a , int b , int c , int d ) { double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ; double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; }
int findMinSum ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; }
int getPosition ( int n , int m ) { if ( m > ( n / 2 ) ) return ( m - ( n / 2 ) ) ; return ( m + ( n / 2 ) ) ; }
int matrixOrValueOne ( bool [ , ] arr ) { int [ , ] p_arr = new int [ n , n ] ; findPrefixCount ( p_arr , arr ) ; int count_zero_submatrices = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int i = n - 1 ; Stack < pair > q = new Stack < pair > ( ) ; int to_sum = 0 ; while ( i >= 0 ) { int c = 0 ; while ( q . Count != 0 && q . Peek ( ) . first > p_arr [ i , j ] ) { to_sum -= ( q . Peek ( ) . second + 1 ) * ( q . Peek ( ) . first - p_arr [ i , j ] ) ; c += q . Peek ( ) . second + 1 ; q . Pop ( ) ; } to_sum += p_arr [ i , j ] ; count_zero_submatrices += to_sum ; q . Push ( new pair ( p_arr [ i , j ] , c ) ) ; i -- ; } } return ( n * ( n + 1 ) * n * ( n + 1 ) ) / 4 - count_zero_submatrices ; }
long count ( int N , int K , int R ) { long sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; }
bool isSpiltPossible ( int n , int [ ] a ) { int sum = 0 , c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }
bool isSunnyNum ( int n ) { if ( isPerfectSquare ( n + 1 ) ) return true ; return false ; }
int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; }
int getMaxNum ( int a , int b , int c ) { if ( b % c == 0 ) return b ; int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; }
int findAndSum ( int [ ] arr , int n ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { bool count_on = false ; int l = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) if ( count_on ) l ++ ; else { count_on = true ; l ++ ; } else if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = false ; l = 0 ; } } if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = false ; l = 0 ; } mul *= 2 ; } return sum ; }
int calcNodes ( int N , int I ) { int result = 0 ; result = I * ( N - 1 ) + 1 ; return result ; }
void findPrimeFactors ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ j / i ] + 1 ; for ( int i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; }
double mixtureConcentration ( int n , int [ ] p ) { double res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return Math . Round ( res , 4 ) ; }
bool check ( long num , long a , long b ) { while ( num > 0 ) { long rem = num % 10 ; num /= 10 ; if ( rem != a && rem != b ) return false ; } return true ; }
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
long max_gcd ( long n , long p ) { int count = 0 ; long gcd = 1 ; while ( p % 2 == 0 ) { p >>= 1 ; count ++ ; } if ( count > 0 ) gcd *= ( long ) Math . Pow ( 2 , count / n ) ; for ( long i = 3 ; i <= Math . Sqrt ( p ) ; i += 2 ) { count = 0 ; while ( p % i == 0 ) { count ++ ; p = p / i ; } if ( count > 0 ) { gcd *= ( long ) Math . Pow ( i , count / n ) ; } } if ( p > 2 ) gcd *= ( long ) Math . Pow ( p , 1 / n ) ; return gcd ; }
int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] != 0 ) return f [ n ] ; int k = 0 ; if ( ( n & 1 ) != 0 ) k = ( n + 1 ) / 2 ; else k = n / 2 ; if ( ( n & 1 ) != 0 ) f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; else f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
void printSequence ( int n ) { Sieve ( ) ; List < int > v = new List < int > ( ) ; List < int > u = new List < int > ( ) ; for ( int i = 13 ; i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { v . Add ( i ) ; } } if ( n == 3 ) { Console . Write ( 6 + " " + 10 + " " + 15 ) ; return ; } int k ; for ( k = 0 ; k < n - 2 ; k ++ ) { if ( k % 3 == 0 ) { u . Add ( v [ k ] * 6 ) ; } else if ( k % 3 == 1 ) { u . Add ( v [ k ] * 15 ) ; } else { u . Add ( v [ k ] * 10 ) ; } } k -- ; u . Add ( v [ k ] * 7 ) ; u . Add ( 7 * 11 ) ; u [ 0 ] = u [ 0 ] * 11 ; for ( int i = 0 ; i < u . Count ; i ++ ) { Console . Write ( u [ i ] + " " ) ; } }
bool checkSub ( string sub , string s ) { int j = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) if ( sub [ j ] == s [ i ] ) j ++ ; return j == sub . Length ; }
int minPerfectCube ( int [ ] arr , int n ) { int minPerfectCube ; int lcm = lcmOfArray ( arr , n ) ; minPerfectCube = lcm ; int cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm /= 2 ; } if ( cnt % 3 == 2 ) minPerfectCube *= 2 ; else if ( cnt % 3 == 1 ) minPerfectCube *= 4 ; int i = 3 ; while ( lcm > 1 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm /= i ; } if ( cnt % 3 == 1 ) minPerfectCube *= i * i ; else if ( cnt % 3 == 2 ) minPerfectCube *= i ; i += 2 ; } return minPerfectCube ; }
void powerfulIntegers ( int x , int y , int bound ) { HashSet < int > s = new HashSet < int > ( ) ; ArrayList powersOfY = new ArrayList ( ) ; int i ; powersOfY . Add ( 1 ) ; for ( i = y ; i < bound && y != 1 ; i = i * y ) powersOfY . Add ( i ) ; i = 0 ; while ( true ) { int xPowI = ( int ) Math . Pow ( x , i ) ; for ( int j = 0 ; j != powersOfY . Count ; ++ j ) { int num = xPowI + ( int ) powersOfY [ j ] ; if ( num <= bound ) s . Add ( num ) ; else break ; } if ( xPowI >= bound x == 1 ) break ; i ++ ; } int [ ] ar = s . ToArray ( ) ; Array . Sort ( ar ) ; s . Clear ( ) ; s . UnionWith ( ar ) ; foreach ( int t in s ) { Console . Write ( t + " " ) ; } }
double find_probability ( double p , double q , double r , double s ) { double t = ( 1 - p / q ) * ( 1 - r / s ) ; double ans = ( p / q ) / ( 1 - t ) ; return ans ; }
int distinctDigitSum ( int n ) { bool [ ] used = new bool [ 10 ] ; int sum = 0 ; while ( n > 0 ) { int digit = n % 10 ; if ( ! used [ digit ] ) { used [ digit ] = true ; sum += digit ; } n = n / 10 ; } return sum ; }
int getDifference ( int N ) { if ( N == 0 ) return 2 ; else if ( N == 1 ) return 1 ; else if ( isPrime ( N ) ) return 0 ; int aboveN = - 1 , belowN = - 1 ; int n1 ; n1 = N + 1 ; while ( true ) { if ( isPrime ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; } n1 = N - 1 ; while ( true ) { if ( isPrime ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; } int diff1 = aboveN - N ; int diff2 = N - belowN ; return Math . Min ( diff1 , diff2 ) ; }
int maxPrimeFactors ( int n ) { int num = n ; int maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n /= 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } } if ( n > 2 ) { maxPrime = n ; } int sum = maxPrime + num ; return sum ; }
int sumOfDigits ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; }
int countIntervals ( int [ , ] arr , int V , int N ) { int min = int . MaxValue , max = int . MinValue ; int li , ri ; int [ ] freq = new int [ MAX_VAL ] ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i , 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i , 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( int i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }
int sumEven ( int l , int r ) { return sumNatural ( r / 2 ) - sumNatural ( ( l - 1 ) / 2 ) ; }
bool isPalindrome ( int num ) { int reverse_num = 0 , remainder , temp ; temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_num = reverse_num * 10 + remainder ; temp /= 10 ; } if ( reverse_num == num ) { return true ; } return false ; }
int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; }
int getResult ( int n ) { if ( ( n & 1 ) > 0 ) return 1 ; return - 1 ; }
long sumAP ( long n , long d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; }
long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int minimum ( int n ) { int product = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; product = product * i ; } } if ( n >= 2 ) product = product * n ; return product ; }
bool productDivisible ( int n , int k ) { int product = 1 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 0 ) product *= n % 10 ; n = n / 10 ; position ++ ; } if ( product % k == 0 ) return true ; return false ; }
long sumAP ( long n , long d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; }
int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
string isTriangleExists ( int a , int b , int c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return "YES" ; else return "NO" ; else return "NO" ; }
int fact ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact *= i ; return fact ; }
int ways ( int m , int w , int n , int k ) { int ans = 0 ; while ( m >= k ) { ans += ncr ( m , k ) * ncr ( w , n - k ) ; k += 1 ; } return ans ; }
void SieveOfEratosthenes ( ) { prime [ 1 ] = true ; prime [ 0 ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } } }
int square ( int n ) { return n * n ; }
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 2 ) ) * ( 2 * 2 + ( N / 2 - 1 ) * 2 ) / 2 ; S2 = ( ( N / 7 ) ) * ( 2 * 7 + ( N / 7 - 1 ) * 7 ) / 2 ; S3 = ( ( N / 14 ) ) * ( 2 * 14 + ( N / 14 - 1 ) * 14 ) / 2 ; return S1 + S2 - S3 ; }
int largestPrimeFactor ( int n ) { int max = - 1 ; while ( n % 2 == 0 ) { max = 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { max = i ; n = n / i ; } } if ( n > 2 ) max = n ; return max ; }
bool isStrongNumber ( int n ) { Dictionary < int , int > count = new Dictionary < int , int > ( ) ; while ( n % 2 == 0 ) { n = n / 2 ; if ( count . ContainsKey ( 2 ) ) { count [ 2 ] = count [ 2 ] + 1 ; } else { count . Add ( 2 , 1 ) ; } } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { n = n / i ; if ( count . ContainsKey ( i ) ) { count [ i ] = count [ i ] + 1 ; } else { count . Add ( i , 1 ) ; } } } if ( n > 2 ) { if ( count . ContainsKey ( n ) ) { count [ n ] = count [ n ] + 1 ; } else { count . Add ( n , 1 ) ; } } int flag = 0 ; foreach ( KeyValuePair < int , int > b in count ) { if ( b . Value == 1 ) { flag = 1 ; break ; } } if ( flag == 1 ) { return false ; } else { return true ; } }
bool isChenPrime ( int n ) { if ( isPrime ( n ) && ( isSemiPrime ( n + 2 ) || isPrime ( n + 2 ) ) ) return true ; else return false ; }
bool isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
bool Divisible ( String str , int n ) { if ( SumOfDigits ( str , n ) % 3 == 0 && str [ n - 1 ] == '0' ) return true ; return false ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
int NumberOfRectangles ( int n , int m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; }
long isPrime ( int p ) { if ( p == 4 ) return 0 ; return ( fact ( p >> 1 ) % p ) ; }
long findNumUtil ( long res , int a , int aCount , int b , int bCount , int n ) { if ( res > 1e11 ) return ( long ) 1e11 ; if ( aCount == bCount && res >= n ) return res ; return Math . Min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) ) ; }
int isSumDivides ( int N ) { int temp = N , sum = 0 ; while ( temp > 0 ) { sum += temp % 10 ; temp /= 10 ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }
int GoodNumber ( int n ) { List < int > v = new List < int > ( PrimeFactors ( n ) ) ; int ans = 1 ; for ( int i = 0 ; i < v . Count ; i ++ ) ans *= v [ i ] ; return ans ; }
bool checkSpecialPrime ( bool [ ] sieve , int num ) { while ( num != 0 ) { if ( ! sieve [ num ] ) { return false ; } num /= 10 ; } return true ; }
bool isPrime ( int n ) { if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return true ; } if ( n % 2 == 0 n % 3 == 0 ) { return false ; } for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
double nthHarmonic ( int N ) { float harmonic = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { harmonic += ( float ) 1 / i ; } return harmonic ; }
int nthTerm ( int n ) { return 3 * ( int ) Math . Pow ( n , 2 ) + n - 2 ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 2 ) + 4 * n - 2 ; }
void printAngles ( int a , int b , int c ) { double x = ( double ) a ; double y = ( double ) b ; double z = ( double ) c ; double A = findAnglesA ( x , y , z ) ; double B = findAnglesB ( x , y , z ) ; Console . WriteLine ( "Angles are A = " + A + ", B = " + B + ", C = " + 90 ) ; }
long Bits ( int kilobytes ) { long Bits = 0 ; Bits = kilobytes * 8192 ; return Bits ; }
void binomial ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i , j ] = 1 ; else nCr [ i , j ] = nCr [ i - 1 , j ] + nCr [ i - 1 , j - 1 ] ; } } }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int closest ( int x ) { int ans = 0 ; while ( ans * 10 + 9 <= x ) ans = ans * 10 + 9 ; return ans ; }
int nthTerm ( int N ) { return ( N * ( ( N / 2 ) + ( ( N % 2 ) * 2 ) + N ) ) ; }
int calculateSum ( int n ) { return ( int ) Math . Pow ( n * ( n + 1 ) / 2 , 2 ) ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int totEdge ( int n ) { int result = 0 ; result = ( n * ( n - 1 ) ) / 2 ; return result ; }
void findFactors ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( ( n / i ) == i ) { factors . Insert ( factors . Count , i ) ; } else { factors . Insert ( factors . Count , n / i ) ; factors . Insert ( factors . Count , i ) ; } } } }
bool checkPairs ( int l , int r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }
double calTime ( double [ ] arr , int n ) { double work = 0 ; for ( int i = 0 ; i < n ; i ++ ) work += 1 / arr [ i ] ; return Math . Round ( 1 / work , 5 ) ; }
int calculate_ways ( int m , int n ) { if ( m < n ) { return 0 ; } int ways = binomial_coefficient ( n + m - 1 , n - 1 ) ; return ways ; }
long powerLL ( long x , long n ) { long result = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) { result = result * x % MOD ; } n = n / 2 ; x = x * x % MOD ; } return result ; }
long powerStrings ( String sa , String sb ) { long a = 0 , b = 0 ; for ( int i = 0 ; i < sa . Length ; i ++ ) { a = ( a * 10 + ( sa [ i ] - '0' ) ) % MOD ; } for ( int i = 0 ; i < sb . Length ; i ++ ) { b = ( b * 10 + ( sb [ i ] - '0' ) ) % ( MOD - 1 ) ; } return powerLL ( a , b ) ; }
int findNumbers ( int n , int w ) { int x = 0 , sum = 0 ; if ( w >= 0 && w <= 8 ) { x = 9 - w ; } else if ( w >= - 9 && w <= - 1 ) { x = 10 + w ; } sum = ( int ) Math . Pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; }
int check ( int n ) { int mod = ( int ) ( 1e9 + 7 ) ; n -- ; int ans = n * n ; if ( ans >= mod ) ans %= mod ; ans += n + 2 ; if ( ans >= mod ) ans %= mod ; ans = ( power ( 2 , n , mod ) % mod * ans % mod ) % mod ; ans = ( ans - 1 + mod ) % mod ; return ans ; }
int findOddPair ( int [ ] A , int N ) { int i , j ; int oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
int numberOfDigits ( int x ) { int i = 0 ; while ( x != 0 ) { x /= 10 ; i ++ ; } return i ; }
int twoEggDrop ( int k ) { return ( int ) System . Math . Ceiling ( ( - 1.0 + System . Math . Sqrt ( 1 + 8 * k ) ) / 2.0 ) ; }
void findArea ( float a , float b ) { float Area ; Area = ( float ) 3.142 * a * b ; Console . WriteLine ( "Area: " + Area ) ; }
int calculate ( int x , int k , int m ) { int result = x ; k -- ; while ( k -- > 0 ) { result = ( int ) Math . Pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; }
int largestNum ( int a , int b ) { return a * ( ( a / b ) > 0 ? 1 : 0 ) + b * ( ( b / a ) > 0 ? 1 : 0 ) ; }
int minimumSquareFreeDivisors ( int N ) { List < int > primes = new List < int > ( ) ; SieveOfEratosthenes ( primes ) ; int max_count = 0 ; for ( int i = 0 ; i < primes . Count && primes [ i ] * primes [ i ] <= N ; i ++ ) { if ( N % primes [ i ] == 0 ) { int tmp = 0 ; while ( N % primes [ i ] == 0 ) { tmp ++ ; N /= primes [ i ] ; } max_count = Math . Max ( max_count , tmp ) ; } } if ( max_count == 0 ) { max_count = 1 ; } return max_count ; }
void smar_wln ( int n ) { primes ( n ) ; }
int sumOfSeries ( int n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; }
double mulmod ( long a , long b , long mod ) { a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; }
long findProduct ( long N ) { long product = 1 , fact = 1 ; long MOD = ( long ) ( 1e9 + 7 ) ; for ( int i = 1 ; i <= N ; i ++ ) { fact = ( long ) mulmod ( fact , i , MOD ) ; product = ( long ) mulmod ( product , fact , MOD ) ; if ( product == 0 ) return 0 ; } return product ; }
void endPointOfDiameterofCircle ( int x1 , int y1 , int c1 , int c2 ) { Console . Write ( "x2 = " + ( 2 * c1 - x1 ) + " " ) ; Console . Write ( "y2 = " + ( 2 * c2 - y1 ) ) ; }
int divSum ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) sum = sum + i + n / i ; return sum ; }
int centeredTetrahedralNumber ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 3 ) / 3 ; }
int bit ( int x ) { int ans = 0 ; while ( x > 0 ) { x /= 2 ; ans ++ ; } return ans ; }
int bs ( int n ) { int l = 1 , r = ( int ) Math . Sqrt ( n ) ; while ( l < r ) { int m = ( l + r ) / 2 ; if ( check ( m , n ) ) r = m ; else l = m + 1 ; } if ( ! check ( l , n ) ) return l + 1 ; else return l ; }
string find_Square_369 ( string num ) { char a , b , c , d ; if ( num [ 0 ] == '3' ) { a = '1' ; b = '0' ; c = '8' ; d = '9' ; } else if ( num [ 0 ] == '6' ) { a = '4' ; b = '3' ; c = '5' ; d = '6' ; } else { a = '9' ; b = '8' ; c = '0' ; d = '1' ; } string result = "" ; int size = num . Length ; for ( int i = 1 ; i < size ; i ++ ) result += a ; result += b ; for ( int i = 1 ; i < size ; i ++ ) result += c ; result += d ; return result ; }
bool everMeet ( int x1 , int x2 , int v1 , int v2 ) { if ( x1 < x2 && v1 <= v2 ) return false ; if ( x1 > x2 && v1 >= v2 ) return false ; if ( x1 < x2 ) { swap ( ref x1 , ref x2 ) ; swap ( ref v1 , ref v2 ) ; } while ( x1 >= x2 ) { if ( x1 == x2 ) return true ; x1 = x1 + v1 ; x2 = x2 + v2 ; } return false ; }
int findpos ( String n ) { int pos = 0 ; for ( int i = 0 ; i < n . Length ; i ++ ) { switch ( n [ i ] ) { case '2' : pos = pos * 4 + 1 ; break ; case '3' : pos = pos * 4 + 2 ; break ; case '5' : pos = pos * 4 + 3 ; break ; case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; }
bool isPossibleToZero ( int [ ] a , int n ) { int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }
int fact ( int n ) { if ( n == 0 n == 1 ) return 1 ; int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ans ; }
int solve ( int n , int base1 ) { int result = 0 ; while ( n > 0 ) { int remainder = n % base1 ; result = result + remainder ; n = n / base1 ; } return result ; }
bool checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; }
void possibleTripletInRange ( int L , int R ) { bool flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ; int numbersInRange = ( R - L + 1 ) ; if ( numbersInRange < 3 ) { flag = false ; } else if ( numbersInRange > 3 ) { flag = true ; if ( L % 2 > 0 ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ! ( L % 2 > 0 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( flag == true ) { Console . WriteLine ( "(" + possibleA + ", " + possibleB + ", " + possibleC + ")" + " is one such possible" + " triplet between " + L + " and " + R ) ; } else { Console . WriteLine ( "No Such Triplet" + " exists between " + L + " and " + R ) ; } }
virtual bool isFullTree ( Node node ) { if ( node == null ) { return true ; } if ( node . left == null && node . right == null ) { return true ; } if ( ( node . left != null ) && ( node . right != null ) ) { return ( isFullTree ( node . left ) && isFullTree ( node . right ) ) ; } return false ; }
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }
int findKthGoodNo ( int n ) { int lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }
int findGreatest ( int [ ] arr , int n ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . ContainsKey ( arr [ i ] ) ) { var a = m [ arr [ i ] ] + 1 ; m . Add ( arr [ i ] , a ) ; } else { m . Add ( arr [ i ] , arr [ i ] ) ; } } Array . Sort ( arr ) ; for ( int i = n - 1 ; i > 1 ; i -- ) { for ( int j = 0 ; j < i && arr [ j ] <= Math . Sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) { int result = arr [ i ] / arr [ j ] ; if ( result != arr [ j ] && m [ result ] == null m [ result ] > 0 ) { return arr [ i ] ; } else if ( result == arr [ j ] && m [ result ] > 1 ) { return arr [ i ] ; } } } } return - 1 ; }
int LCMOfNeighbourFact ( int n ) { return factorial ( n + 1 ) ; }
int fortunateNumber ( int n ) { int p = primorial ( n ) ; return findNextPrime ( p ) - p ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
int factorial ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; }
int findNthNumber ( int n , int k ) { for ( int i = k + 1 , count = 1 ; count < n ; i ++ ) { if ( checkdigit ( i , k ) || ( i % k == 0 ) ) count ++ ; if ( count == n ) return i ; } return - 1 ; }
bool isPrime ( int p ) { double checkNumber = Math . Pow ( 2 , p ) - 1 ; double nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }
int multiply ( int x , int [ ] res , int res_size ) { int carry = 0 ; for ( int i = 0 ; i < res_size ; i ++ ) { int prod = res [ i ] * x + carry ; res [ i ] = prod % 10 ; carry = prod / 10 ; } while ( carry > 0 ) { res [ res_size ] = carry % 10 ; carry = carry / 10 ; res_size ++ ; } return res_size ; }
void power ( int x , int n ) { if ( n == 0 ) { Console . Write ( "1" ) ; return ; } int [ ] res = new int [ MAX ] ; int res_size = 0 ; int temp = x ; while ( temp != 0 ) { res [ res_size ++ ] = temp % 10 ; temp = temp / 10 ; } for ( int i = 2 ; i <= n ; i ++ ) res_size = multiply ( x , res , res_size ) ; Console . Write ( x + "^" + n + " = " ) ; for ( int i = res_size - 1 ; i >= 0 ; i -- ) Console . Write ( res [ i ] ) ; }
int sumOfSeries ( int n ) { return ( int ) ( 0.6172 * ( Math . Pow ( 10 , n ) - 1 ) - 0.55 * n ) ; }
int seriesFunc ( int n ) { int sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; }
int day_of_the_week ( int y , int m , int d ) { int [ ] t = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; if ( m < 3 ) y -= 1 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
int subsetCount ( int [ ] arr , int n ) { return 1 << n ; }
bool isSquareFree ( int n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; }
int avg_of_even_num ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return ( sum / n ) ; }
int reachTarget ( int target ) { target = Math . Abs ( target ) ; int sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; }
long fourthPowerSum ( int n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; }
int aliquotSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
float focal_length_concave ( float R ) { return R / 2 ; }
int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; HashSet < int > us = new HashSet < int > ( ) ; for ( int i = 0 ; i < m ; i ++ ) us . Add ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( us . Contains ( x - arr2 [ j ] ) ) count ++ ; return count ; }
int binomialCoeff ( int n , int k ) { int [ , ] C = new int [ n + 1 , k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } return C [ n , k ] ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
bool isEmirp ( int n ) { if ( isPrime ( n ) == false ) return false ; int rev = 0 ; while ( n != 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n /= 10 ; } return isPrime ( rev ) ; }
int squaresum ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
bool isPrime ( int n ) { int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) return false ; i ++ ; } return true ; }
int oddSum ( int n ) { int sum = 0 , curr = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }
int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; }
double distance ( int x1 , int y1 , int x2 , int y2 ) { return Math . Sqrt ( Math . Pow ( x2 - x1 , 2 ) + Math . Pow ( y2 - y1 , 2 ) * 1.0 ) ; }
void count0s ( int [ , ] mat , int [ , ] Q , int sizeQ ) { int [ , ] prefixCnt = new int [ M , N ] ; preCompute ( mat , prefixCnt ) ; for ( int i = 0 ; i < sizeQ ; i ++ ) { Console . Write ( countQuery ( prefixCnt , Q [ i , 0 ] , Q [ i , 1 ] , Q [ i , 2 ] , Q [ i , 3 ] ) + " " ) ; } }
void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) Console . WriteLine ( "Not possible" ) ; else { int result ; if ( k < Math . Max ( m , n ) - 1 ) { result = Math . Max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . Max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } Console . WriteLine ( result ) ; } }
int totalNumber ( int n ) { return 8 * ( int ) Math . Pow ( 9 , n - 1 ) ; }
int recDigSum ( int n ) { if ( n == 0 ) return 0 ; else { if ( n % 9 == 0 ) return 9 ; else return n % 9 ; } }
void check ( int n ) { n = recDigSum ( n ) ; if ( n == 2 n == 3 n == 5 n == 7 ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
bool isDivisible ( String S ) { int n = S . Length ; if ( S [ n - 1 ] != '5' && S [ n - 1 ] != '0' ) return false ; int sum = 0 ; for ( int i = 0 ; i < S . Length ; i ++ ) sum += ( int ) S [ i ] ; if ( sum % 3 == 0 ) return true ; else return false ; }
void findArmstrong ( int low , int high ) { for ( int i = low + 1 ; i < high ; ++ i ) { int x = i ; int n = 0 ; while ( x != 0 ) { x /= 10 ; ++ n ; } int pow_sum = 0 ; x = i ; while ( x != 0 ) { int digit = x % 10 ; pow_sum += ( int ) Math . Pow ( digit , n ) ; x /= 10 ; } if ( pow_sum == i ) Console . Write ( i + " " ) ; } }
void complement ( string number1 ) { char [ ] number = number1 . ToCharArray ( ) ; for ( int i = 0 ; i < number . Length ; i ++ ) if ( number [ i ] != '.' ) number [ i ] = ( char ) ( ( int ) ( '9' ) - ( int ) ( number [ i ] ) + ( int ) ( '0' ) ) ; System . Console . WriteLine ( "9's complement is : " + new string ( number ) ) ; }
int countWays ( int n ) { int count = 0 ; for ( int i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }
int sumDigitSquare ( int n ) { int sq = 0 ; while ( n != 0 ) { int digit = n % 10 ; sq += digit * digit ; n = n / 10 ; } return sq ; }
bool isHappy ( int n ) { while ( true ) { if ( n == 1 ) return true ; n = sumDigitSquare ( n ) ; if ( n == 4 ) return false ; } }
float sumOfSeries ( double a , double n ) { double res = 0 , prev = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { prev *= ( a / i ) ; res = res + prev ; } return ( float ) ( res ) ; }
void convert ( int [ ] arr , int n ) { int [ ] temp = new int [ arr . Length ] ; Array . Copy ( arr , 0 , temp , 0 , arr . Length ) ; Array . Sort ( temp ) ; Dictionary < int , int > umap = new Dictionary < int , int > ( ) ; int val = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( umap . ContainsKey ( temp [ i ] ) ) umap [ temp [ i ] ] = val ++ ; else umap . Add ( temp [ i ] , val ++ ) ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = umap [ arr [ i ] ] ; }
void printTrib ( int n ) { if ( n < 1 ) return ; int first = 0 , second = 0 ; int third = 1 ; Console . Write ( first + " " ) ; if ( n > 1 ) Console . Write ( second + " " ) ; if ( n > 2 ) Console . Write ( second + " " ) ; for ( int i = 3 ; i < n ; i ++ ) { int curr = first + second + third ; first = second ; second = third ; third = curr ; Console . Write ( curr + " " ) ; } }
void multiply ( int [ , ] T , int [ , ] M ) { int a , b , c , d , e , f , g , h , i ; a = T [ 0 , 0 ] * M [ 0 , 0 ] + T [ 0 , 1 ] * M [ 1 , 0 ] + T [ 0 , 2 ] * M [ 2 , 0 ] ; b = T [ 0 , 0 ] * M [ 0 , 1 ] + T [ 0 , 1 ] * M [ 1 , 1 ] + T [ 0 , 2 ] * M [ 2 , 1 ] ; c = T [ 0 , 0 ] * M [ 0 , 2 ] + T [ 0 , 1 ] * M [ 1 , 2 ] + T [ 0 , 2 ] * M [ 2 , 2 ] ; d = T [ 1 , 0 ] * M [ 0 , 0 ] + T [ 1 , 1 ] * M [ 1 , 0 ] + T [ 1 , 2 ] * M [ 2 , 0 ] ; e = T [ 1 , 0 ] * M [ 0 , 1 ] + T [ 1 , 1 ] * M [ 1 , 1 ] + T [ 1 , 2 ] * M [ 2 , 1 ] ; f = T [ 1 , 0 ] * M [ 0 , 2 ] + T [ 1 , 1 ] * M [ 1 , 2 ] + T [ 1 , 2 ] * M [ 2 , 2 ] ; g = T [ 2 , 0 ] * M [ 0 , 0 ] + T [ 2 , 1 ] * M [ 1 , 0 ] + T [ 2 , 2 ] * M [ 2 , 0 ] ; h = T [ 2 , 0 ] * M [ 0 , 1 ] + T [ 2 , 1 ] * M [ 1 , 1 ] + T [ 2 , 2 ] * M [ 2 , 1 ] ; i = T [ 2 , 0 ] * M [ 0 , 2 ] + T [ 2 , 1 ] * M [ 1 , 2 ] + T [ 2 , 2 ] * M [ 2 , 2 ] ; T [ 0 , 0 ] = a ; T [ 0 , 1 ] = b ; T [ 0 , 2 ] = c ; T [ 1 , 0 ] = d ; T [ 1 , 1 ] = e ; T [ 1 , 2 ] = f ; T [ 2 , 0 ] = g ; T [ 2 , 1 ] = h ; T [ 2 , 2 ] = i ; }
bool sackRace ( int p1 , int s1 , int p2 , int s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; }
int xorCalc ( int k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return k / 2 ; return 1 ; }
void multiple ( int a , int b , int x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) Console . WriteLine ( "1" ) ; else Console . WriteLine ( "0" ) ; } int mul = ( int ) Math . Pow ( a , b ) ; int ans = mul / x ; int ans1 = x * ans ; int ans2 = x * ( ans + 1 ) ; Console . WriteLine ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }
bool checkJumbled ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( Math . Abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; }
float binomialProbability ( int n , int k , float p ) { return nCr ( n , k ) * ( float ) Math . Pow ( p , k ) * ( float ) Math . Pow ( 1 - p , n - k ) ; }
int flipSign ( int a ) { int neg = 0 ; int tmp = a < 0 ? 1 : - 1 ; while ( a != 0 ) { neg += tmp ; a += tmp ; } return neg ; }
bool areDifferentSign ( int a , int b ) { return ( ( a < 0 && b > 0 ) || ( a > 0 && b < 0 ) ) ; }
int FirstDigit ( int [ ] arr , int n ) { double S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S = S + Math . Log10 ( arr [ i ] * 1.0 ) ; double fract_S = S - Math . Floor ( S ) ; int ans = ( int ) Math . Pow ( 10 , fract_S ) ; return ans ; }
void cal_cos ( float n ) { float accuracy = ( float ) 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( float ) ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = ( float ) Math . Cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= cosval - cosx ) ; Console . WriteLine ( cosx ) ; }
int sumFactDiv ( int n ) { return div ( fac ( n ) ) ; }
int printNthElement ( int n ) { int [ ] arr = new int [ n + 1 ] ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
int maxSumLCM ( int n ) { int max_sum = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; }
bool check ( String str ) { int n = str . Length ; if ( n == 0 && n == 1 ) return false ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ; if ( n == 3 ) return ( ( ( str [ n - 3 ] - '0' ) * 100 + ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ; int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; int fourth_last = str [ n - 4 ] - '0' ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; }
bool checkPandigital ( int b , string n ) { if ( n . Length < b ) return false ; bool [ ] hash = new bool [ b ] ; for ( int i = 0 ; i < b ; i ++ ) hash [ i ] = false ; for ( int i = 0 ; i < n . Length ; i ++ ) { if ( n [ i ] >= '0' && n [ i ] <= '9' ) hash [ n [ i ] - '0' ] = true ; else if ( n [ i ] - 'A' <= b - 11 ) hash [ n [ i ] - 'A' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; }
int findStarNum ( int n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
int squareFree ( int n ) { int cnt = 0 ; for ( int i = 1 ; ; i ++ ) { bool isSqFree = true ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % ( j * j ) == 0 ) { isSqFree = false ; break ; } } if ( isSqFree == true ) { cnt ++ ; if ( cnt == n ) return i ; } } }
bool check ( String str ) { int n = str . Length ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str [ 0 ] - '0' ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 8 == 0 ) ; int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; }
bool isRefactorableNumber ( int n ) { int divCount = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) { if ( n / i == i ) ++ divCount ; else divCount += 2 ; } } return n % divCount == 0 ; }
void nearestGcd ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; ++ i ) { int closest = - 1 ; for ( int j = i - 1 , k = i + 1 ; j > 0 k <= n ; -- j , ++ k ) { if ( j >= 0 && __gcd ( arr [ i ] , arr [ j ] ) > 1 ) { closest = j + 1 ; break ; } if ( k < n && __gcd ( arr [ i ] , arr [ k ] ) > 1 ) { closest = k + 1 ; break ; } } Console . Write ( closest + " " ) ; } }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; }
int Special_Factorial_Number ( int k ) { for ( int i = 1 ; i <= k ; i ++ ) { if ( fact ( i ) % k == 0 ) { return i ; } } return 0 ; }
int findnum ( String str ) { int n = str . Length ; int count_after_dot = 0 ; bool dot_seen = false ; int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != '.' ) { num = num * 10 + ( str [ i ] - '0' ) ; if ( dot_seen == true ) count_after_dot ++ ; } else dot_seen = true ; } if ( dot_seen == false ) return 1 ; int dem = ( int ) Math . Pow ( 10 , count_after_dot ) ; return ( dem / gcd ( num , dem ) ) ; }
bool iskaprekar ( int n ) { if ( n == 1 ) return true ; int sq_n = n * n ; int count_digits = 0 ; while ( sq_n != 0 ) { count_digits ++ ; sq_n /= 10 ; } sq_n = n * n ; for ( int r_digits = 1 ; r_digits < count_digits ; r_digits ++ ) { int eq_parts = ( int ) Math . Pow ( 10 , r_digits ) ; if ( eq_parts == n ) continue ; int sum = sq_n / eq_parts + sq_n % eq_parts ; if ( sum == n ) return true ; } return false ; }
int kDivisors ( int a , int b , int k ) { int count = 0 ; for ( int i = a ; i <= b ; i ++ ) { if ( isPerfect ( i ) ) if ( divisorsCount ( i ) == k ) count ++ ; } return count ; }
void buildDivisorsArray ( ) { for ( int i = 1 ; i < maxn ; i ++ ) { divisors [ i ] = 1 ; int n = i , p = smallest_prime [ i ] , k = 0 ; while ( n > 1 ) { n = n / p ; k ++ ; if ( smallest_prime [ n ] != p ) { divisors [ i ] = divisors [ i ] * ( k + 1 ) ; k = 0 ; } p = smallest_prime [ n ] ; } } }
int commDiv ( int a , int b ) { int n = gcd ( a , b ) ; int result = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) result += 1 ; else result += 2 ; } } return result ; }
int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
bool isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( - b + ( float ) Math . Sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - ( float ) Math . Sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . Floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . Floor ( root2 ) == root2 ) return true ; return false ; }
char flip ( char c ) { return ( c == '0' ) ? '1' : '0' ; }
bool areElementsContiguous ( int [ ] arr , int n ) { int max = int . MinValue ; int min = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . Max ( max , arr [ i ] ) ; min = Math . Min ( min , arr [ i ] ) ; } int m = max - min + 1 ; if ( m > n ) return false ; bool [ ] visited = new bool [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }
int SieveOfAtkin ( int limit ) { if ( limit > 2 ) Console . Write ( 2 + " " ) ; if ( limit > 3 ) Console . Write ( 3 + " " ) ; bool [ ] sieve = new bool [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) Console . Write ( a + " " ) ; return 0 ; }
int SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; bool [ ] marked = new bool [ nNew + 1 ] ; for ( int i = 0 ; i < nNew + 1 ; i ++ ) marked [ i ] = false ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) Console . Write ( 2 + " " ) ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) Console . Write ( 2 * i + 1 + " " ) ; return - 1 ; }
bool squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
int power ( int x , int y , int p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int modFact ( int n , int p ) { if ( p <= n ) return 0 ; int res = ( p - 1 ) ; for ( int i = n + 1 ; i < p ; i ++ ) res = ( res * modInverse ( i , p ) ) % p ; return res ; }
int countWays ( int n ) { for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) for ( int k = j ; k < n ; k ++ ) for ( int l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
bool isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; }
bool checkUtil ( int num , int dig , int i ) { if ( dig == 1 && num < i ) return true ; if ( dig > 1 && num >= i ) return checkUtil ( ( num / i ) , -- dig , i ) ; return false ; }
int countLeapYears ( Date d ) { int years = d . y ; if ( d . m <= 2 ) { years -- ; } return years / 4 - years / 100 + years / 400 ; }
long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
long findWays ( int n ) { if ( ( n & 1 ) != 0 ) return 0 ; return catalan ( n / 2 ) ; }
int XorSum ( int [ ] A , int [ ] B , int N , int M ) { int ans1 = 0 , ans2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) ans1 = ans1 ^ A [ i ] ; for ( int i = 0 ; i < M ; i ++ ) ans2 = ans2 ^ B [ i ] ; return ( ans1 & ans2 ) ; }
int check ( int x ) { if ( ( ( x ) & ( x - 1 ) ) == 0 ) return 1 ; return 0 ; }
int maxAndXor ( int [ ] arr , int n ) { int ans = 9999999 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = Math . Min ( ans , arr [ i ] ^ arr [ i + 1 ] ) ; } return ans ; }
void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( n >> bit ) % 2 > 0 ) { n = n ^ ( 1 << bit ) ; break ; } } Console . Write ( "The number after unsetting the " ) ; Console . Write ( "rightmost set bit " + n ) ; }
void minRange ( int [ ] arr , int n , int k ) { int l = 0 , r = n ; for ( int i = 0 ; i < n ; i ++ ) { ISet < int > s = new HashSet < int > ( ) ; int j ; for ( j = i ; j < n ; j ++ ) { s . Add ( arr [ j ] ) ; if ( s . Count == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) { break ; } } if ( l == 0 && r == n ) { Console . WriteLine ( "Invalid k" ) ; } else { Console . WriteLine ( l + " " + r ) ; } }
void construct_Xor_Tree ( int [ ] arr , int n ) { construct_Xor_Tree_Util ( arr , 0 , n - 1 , 0 ) ; }
int maximizeExpression ( int a , int b ) { int result = a ; for ( int bit = MAX - 1 ; bit >= 0 ; bit -- ) { int bitOfD = 1 << bit ; int x = b & bitOfD ; if ( x == bitOfD ) { int y = result & bitOfD ; if ( y == 0 ) { result = result ^ bitOfD ; } } } return result ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) { if ( ( n % i ) == 0 ) return false ; } return true ; }
void hasEqualBlockFrequency ( int N ) { string S = Convert . ToString ( N , 2 ) ; HashSet < int > p = new HashSet < int > ( ) ; int c = 1 ; for ( int i = 0 ; i < S . Length - 1 ; i ++ ) { if ( S [ i ] == S [ i + 1 ] ) c += 1 ; else { p . Add ( c ) ; c = 1 ; } p . Add ( c ) ; } if ( p . Count == 1 ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
bool isEqualBlock ( int n ) { int first_bit = n % 2 ; int first_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit && n > 0 ) { n = n / 2 ; first_count ++ ; } if ( n == 0 ) return false ; while ( n > 0 ) { first_bit = n % 2 ; int curr_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit ) { n = n / 2 ; curr_count ++ ; } if ( curr_count != first_count ) return false ; } return true ; }
int printMaxAfterRemoval ( String s ) { bool flag = false ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' && flag == false ) { flag = true ; continue ; } else Console . Write ( s [ i ] ) ; } return 0 ; }
int bitPos ( int n1 , int n2 ) { if ( n1 == n2 ) return 0 ; int bitCount1 = ( int ) Math . Floor ( Math . Log ( n1 ) / Math . Log ( 2 ) ) + 1 ; int bitCount2 = ( int ) Math . Floor ( Math . Log ( n2 ) / Math . Log ( 2 ) ) + 1 ; int bitDiff = Math . Abs ( bitCount1 - bitCount2 ) ; int maxBitCount = Math . Max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * ( int ) Math . Pow ( 2 , bitDiff ) ; } else { n1 = n1 * ( int ) Math . Pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue = ( int ) Math . Floor ( Math . Log ( xorValue ) / Math . Log ( 2 ) ) + 1 ; int disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }
int findevenPair ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; int oddCount = count * ( count - 1 ) / 2 ; return ( N * ( N - 1 ) / 2 ) - oddCount ; }
void ReplaceElements ( int [ ] arr , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }
int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
void maxTriplet ( int [ ] a , int n ) { Boolean [ ] f = new Boolean [ n ] ; for ( int i = 0 ; i < n ; ++ i ) f [ i ] = true ; int [ , ] bits = new int [ n , 33 ] ; for ( int i = 0 ; i < n ; ++ i ) { int num = a [ i ] ; int j = 32 ; while ( num > 0 ) { if ( num % 2 == 1 ) { bits [ i , j ] = 1 ; } j -- ; num >>= 1 ; } } long ans = 0 ; int cnt ; for ( int i = 0 ; i <= 32 ; ++ i ) { cnt = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( bits [ j , i ] == 1 & f [ j ] ) { cnt ++ ; } } if ( cnt >= 3 ) { ans += ( long ) Math . Pow ( 2 , 32 - i ) ; for ( int j = 0 ; j < n ; ++ j ) { if ( bits [ j , i ] != 1 ) { f [ j ] = false ; } } } } cnt = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( f [ i ] ) { cnt ++ ; } } long NumberOfTriplets = ( cnt * ( cnt - 1 ) * ( cnt - 2 ) ) / 6 ; Console . Write ( NumberOfTriplets + " " + ans ) ; }
int AND ( int [ ] a , int n ) { int ans = a [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; }
int findEvenPair ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( ! ( ( A [ i ] & 1 ) > 0 ) ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
void printOdds ( int [ ] arr , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; int set_bit = res & ( ~ ( res - 1 ) ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit ) != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } Console . WriteLine ( x + " " + y ) ; }
void printKthBit ( long n , long k ) { Console . WriteLine ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ; }
void decimalToBinaryNumber ( int x , int n ) { int [ ] binaryNumber = new int [ x ] ; int i = 0 ; while ( x > 0 ) { binaryNumber [ i ] = x % 2 ; x = x / 2 ; i ++ ; } for ( int j = 0 ; j < n - i ; j ++ ) Console . Write ( '0' ) ; for ( int j = i - 1 ; j >= 0 ; j -- ) Console . Write ( binaryNumber [ j ] ) ; }
int XOR ( int a , int b ) { int c = Math . Min ( a , b ) ; int d = Math . Max ( a , b ) ; if ( count ( c ) < count ( d ) ) c = c << ( count ( d ) - count ( c ) ) ; return ( c ^ d ) ; }
int toggleBits ( int n1 , int n2 ) { return ( n1 ^ n2 ) ; }
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
int maxXorSum ( int n , int k ) { if ( k == 1 ) return n ; int res = 1 ; while ( res <= n ) res <<= 1 ; return res - 1 ; }
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
int countPairs ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
int maxAND ( int [ ] arr , int n ) { int res = 0 , count ; for ( int bit = 31 ; bit >= 0 ; bit -- ) { count = checkBit ( res | ( 1 << bit ) , arr , n ) ; if ( count >= 2 ) res |= ( 1 << bit ) ; } return res ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int countUnsetBits ( int n ) { int x = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return BitCount ( x ^ n ) ; }
int setBitNumber ( int n ) { int k = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; return 1 << k ; }
int toggle ( int n ) { int temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } return n ; }
int getFirstSetBitPos ( int n ) { return ( int ) ( Math . Log ( n & - n ) / Math . Log ( 2 ) ) + 1 ; }
int countNum ( int [ ] arr , int n ) { int count = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
int CountZeroBit ( int x ) { int count = 0 ; while ( x > 0 ) { if ( ( x & 1 ) == 0 ) count ++ ; x >>= 1 ; } return count ; }
int bitCount ( int n ) { int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) ++ count ; n >>= 1 ; } return count ; }
int sumoflength ( int [ ] arr , int n ) { HashSet < int > s = new HashSet < int > ( ) ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . Contains ( arr [ j ] ) ) { s . Add ( arr [ i ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . Remove ( arr [ i ] ) ; } return ans ; }
bool areSetBitsIncreasing ( int n ) { int prev_count = int . MaxValue ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = n / 2 ; int curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; }
bool findPattern ( int n ) { int prev = n % 2 ; n = n / 2 ; while ( n > 0 ) { int curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = n / 2 ; } return true ; }
bool isMultipleOf4 ( int n ) { if ( n == 1 ) return false ; int XOR = 0 ; for ( int i = 1 ; i <= n ; i ++ ) XOR = XOR ^ i ; return ( XOR == n ) ; }
char findProffesion ( int level , int pos ) { if ( level == 1 ) return 'e' ; if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == 'd' ) return ( pos % 2 > 0 ) ? 'd' : 'e' ; return ( pos % 2 > 0 ) ? 'e' : 'd' ; }
int swapBits ( int n , int p1 , int p2 ) { int bit1 = ( n >> p1 ) & 1 ; int bit2 = ( n >> p2 ) & 1 ; int x = ( bit1 ^ bit2 ) ; x = ( x << p1 ) | ( x << p2 ) ; int result = n ^ x ; return result ; }
int getElements ( Node root ) { if ( root == null ) return 0 ; return getElements ( root . left ) + getElements ( root . right ) + 1 ; }
int sumOfDiv ( int x ) { int sum = 1 ; for ( int i = 2 ; i <= Math . Sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { sum += i ; if ( x / i != i ) sum += x / i ; } } return sum ; }
void leftRotate ( int [ ] arr , int d , int n ) { for ( int i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; }
void merge ( int [ ] arr , int l , int m , int r ) { int i = l ; int j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ; while ( j <= r && arr [ j ] < 0 ) j ++ ; reverse ( arr , i , m ) ; reverse ( arr , m + 1 , j - 1 ) ; reverse ( arr , i , j - 1 ) ; }
void arrayEvenAndOdd ( int [ ] arr , int n ) { int i = - 1 , j = 0 ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( int k = 0 ; k < n ; k ++ ) Console . Write ( arr [ k ] + " " ) ; }
void kSmallestPair ( int [ ] arr1 , int n1 , int [ ] arr2 , int n2 , int k ) { if ( k > n1 * n2 ) { Console . Write ( "k pairs don't exist" ) ; return ; } int [ ] index2 = new int [ n1 ] ; while ( k > 0 ) { int min_sum = int . MaxValue ; int min_index = 0 ; for ( int i1 = 0 ; i1 < n1 ; i1 ++ ) { if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) { min_index = i1 ; min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ; } } Console . Write ( "(" + arr1 [ min_index ] + ", " + arr2 [ index2 [ min_index ] ] + ") " ) ; index2 [ min_index ] ++ ; k -- ; } }
int Solve ( int L , int R ) { int l = L , r = R ; int tot_bits = r - l + 1 ; int X = MAX ; for ( int i = 0 ; i < 31 ; i ++ ) { int x = one [ r , i ] - one [ l - 1 , i ] ; if ( x >= tot_bits - x ) { int ith_bit = ( int ) Math . Pow ( 2 , i ) ; X = X ^ ith_bit ; } } return X ; }
void swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; }
int findNumberOfTriangles ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] > arr [ k ] && arr [ i ] + arr [ k ] > arr [ j ] && arr [ k ] + arr [ j ] > arr [ i ] ) count ++ ; } } return count ; }
void CountTriangles ( int [ ] A ) { int n = A . Length ; Array . Sort ( A ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else { l ++ ; } } } Console . Write ( "No of possible solutions: " + count ) ; }
int countPairsWithDiffK ( int [ ] arr , int n , int k ) { int count = 0 ; Array . Sort ( arr ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
int getSumAlternate ( Node root ) { if ( root == null ) return 0 ; int sum = root . data ; if ( root . left != null ) { sum += getSum ( root . left . left ) ; sum += getSum ( root . left . right ) ; } if ( root . right != null ) { sum += getSum ( root . right . left ) ; sum += getSum ( root . right . right ) ; } return sum ; }
int getSum ( Node root ) { if ( root == null ) return 0 ; return Math . Max ( getSumAlternate ( root ) , ( getSumAlternate ( root . left ) + getSumAlternate ( root . right ) ) ) ; }
int binarySearch ( int [ ] arr , int low , int high , int key ) { if ( high < low ) { return - 1 ; } int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) { return mid ; } if ( key > arr [ mid ] ) { return binarySearch ( arr , ( mid + 1 ) , high , key ) ; } return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }
int getHeight ( Node Node ) { if ( Node == null ) return 0 ; else { int lHeight = getHeight ( Node . left ) ; int rHeight = getHeight ( Node . right ) ; if ( lHeight > rHeight ) return ( lHeight + 1 ) ; else return ( rHeight + 1 ) ; } }
void printLeaders ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) Console . Write ( arr [ i ] + " " ) ; } }
int binarySearch ( int [ ] arr , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }
int getMin ( int [ ] arr , int n ) { int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } return min ; }
int interpolationSearch ( int [ ] arr , int lo , int hi , int x ) { int pos ; if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; if ( arr [ pos ] < x ) return interpolationSearch ( arr , pos + 1 , hi , x ) ; if ( arr [ pos ] > x ) return interpolationSearch ( arr , lo , pos - 1 , x ) ; } return - 1 ; }
void sort ( int [ ] arr , int n ) { countSort ( arr , n , 1 ) ; countSort ( arr , n , n ) ; }
int countOnes ( int [ ] arr , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
int isUgly ( int no ) { no = maxDivide ( no , 2 ) ; no = maxDivide ( no , 3 ) ; no = maxDivide ( no , 5 ) ; return ( no == 1 ) ? 1 : 0 ; }
int countRec ( int n , int sum ) { if ( n == 0 ) return sum == 0 ? 1 : 0 ; if ( sum == 0 ) return 1 ; int ans = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; }
int countRec ( int n , int sum ) { if ( n == 0 ) return sum == 0 ? 1 : 0 ; if ( lookup [ n , sum ] != - 1 ) return lookup [ n , sum ] ; int ans = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return lookup [ n , sum ] = ans ; }
int sumOfDigitsFrom1ToNUtil ( int n , int [ ] a ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . Log10 ( n ) ) ; int p = ( int ) ( Math . Ceiling ( Math . Pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToNUtil ( n % p , a ) ) ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int [ ] screen = new int [ N ] ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . Max ( 2 * screen [ n - 4 ] , Math . Max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }
void printCombination ( int [ ] arr , int n , int r ) { int [ ] data = new int [ r ] ; combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; }
int findCeil ( int [ ] arr , int r , int l , int h ) { int mid ; while ( l < h ) { mid = l + ( ( h - l ) >> 1 ) ; if ( r > arr [ mid ] ) l = mid + 1 ; else h = mid ; } return ( arr [ l ] >= r ) ? l : - 1 ; }
int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
bool isPowerOfFour ( int n ) { if ( n == 0 ) return false ; return Math . Floor ( logn ( n , 4 ) ) == Math . Ceiling ( logn ( n , 4 ) ) ; }
int countSetBits ( int n ) { return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) ; }
int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }
int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }
long swapBits ( int x ) { long even_bits = x & 0xAAAAAAAA ; long odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; }
bool isPowerOfTwo ( int n ) { return ( n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ) ? true : false ; }
void segregate0and1 ( int [ ] arr , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }
int maxSum ( int [ ] arr , int n ) { int sum = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }
void updateindex ( int [ ] index , int a , int ai , int b , int bi ) { index [ a ] = ai ; index [ b ] = bi ; }
int minSwapsUtil ( int [ ] arr , int [ ] pairs , int [ ] index , int i , int n ) { if ( i > n ) { return 0 ; } if ( pairs [ arr [ i ] ] == arr [ i + 1 ] ) { return minSwapsUtil ( arr , pairs , index , i + 2 , n ) ; } int one = arr [ i + 1 ] ; int indextwo = i + 1 ; int indexone = index [ pairs [ arr [ i ] ] ] ; int two = arr [ index [ pairs [ arr [ i ] ] ] ] ; arr [ i + 1 ] = arr [ i + 1 ] ^ arr [ indexone ] ^ ( arr [ indexone ] = arr [ i + 1 ] ) ; updateindex ( index , one , indexone , two , indextwo ) ; int a = minSwapsUtil ( arr , pairs , index , i + 2 , n ) ; arr [ i + 1 ] = arr [ i + 1 ] ^ arr [ indexone ] ^ ( arr [ indexone ] = arr [ i + 1 ] ) ; updateindex ( index , one , indextwo , two , indexone ) ; one = arr [ i ] ; indexone = index [ pairs [ arr [ i + 1 ] ] ] ; two = arr [ index [ pairs [ arr [ i + 1 ] ] ] ] ; indextwo = i ; arr [ i ] = arr [ i ] ^ arr [ indexone ] ^ ( arr [ indexone ] = arr [ i ] ) ; updateindex ( index , one , indexone , two , indextwo ) ; int b = minSwapsUtil ( arr , pairs , index , i + 2 , n ) ; arr [ i ] = arr [ i ] ^ arr [ indexone ] ^ ( arr [ indexone ] = arr [ i ] ) ; updateindex ( index , one , indextwo , two , indexone ) ; return 1 + Math . Min ( a , b ) ; }
void process ( bool [ ] arr , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { arr [ k ] ^= arr [ k - 1 ] ; } }
void prefixXOR ( int [ ] arr , int [ ] preXOR , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( arr [ i ] % 2 != 1 ) arr [ i ] /= 2 ; preXOR [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] ; }
int query ( int [ ] preXOR , int l , int r ) { if ( l == 0 ) return preXOR [ r ] ; else return preXOR [ r ] ^ preXOR [ l - 1 ] ; }
int maxPartitions ( int [ ] arr , int n ) { int ans = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; ++ i ) { max_so_far = Math . Max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; }
int countPairs ( int [ ] a , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . Abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; }
int getInvCount ( int [ ] arr , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }
int countPairs ( int [ ] A , int n , int k ) { int ans = 0 ; Array . Sort ( A ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int x = 0 ; while ( ( A [ i ] * Math . Pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * Math . Pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; }
void printMax ( int [ ] arr , int k , int n ) { int [ ] brr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; Array . Sort ( brr ) ; Array . Reverse ( brr ) ; int [ ] crr = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { crr [ i ] = brr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { if ( crr . Contains ( arr [ i ] ) ) { Console . Write ( arr [ i ] + " " ) ; } } }
int find_consecutive_steps ( int [ ] arr , int len ) { int count = 0 ; int maximum = 0 ; for ( int index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = Math . Max ( maximum , count ) ; count = 0 ; } } return Math . Max ( maximum , count ) ; }
long findSum ( int [ ] arr , int n ) { long sum = 0 ; Array . Sort ( arr ) ; int i = 0 ; while ( i < n && arr [ i ] < 0 ) { if ( i != n - 1 && arr [ i + 1 ] <= 0 ) { sum = ( sum + ( arr [ i ] * arr [ i + 1 ] ) % Mod ) % Mod ; i += 2 ; } else break ; } int j = n - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { if ( j != 0 && arr [ j - 1 ] > 0 ) { sum = ( sum + ( arr [ j ] * arr [ j - 1 ] ) % Mod ) % Mod ; j -= 2 ; } else break ; } if ( j > i ) sum = ( sum + ( arr [ i ] * arr [ j ] ) % Mod ) % Mod ; else if ( i == j ) sum = ( sum + arr [ i ] ) % Mod ; return sum ; }
void printList ( Node head ) { Node temp = head ; while ( temp != null ) { Console . Write ( temp . data + " " ) ; temp = temp . next ; } }
void insertAfterNthNode ( Node head , int n , int x ) { if ( head == null ) return ; Node newNode = getNode ( x ) ; Node ptr = head ; int len = 0 , i ; while ( ptr != null ) { len ++ ; ptr = ptr . next ; } ptr = head ; for ( i = 1 ; i <= ( len - n ) ; i ++ ) ptr = ptr . next ; newNode . next = ptr . next ; ptr . next = newNode ; }
void findLargestRotation ( int num ) { int ans = num ; double lg = ( double ) ( Math . Log10 ( num ) + 1 ) ; int len = ( int ) ( Math . Floor ( lg ) ) ; int x = ( int ) Math . Pow ( 10 , len - 1 ) ; for ( int i = 1 ; i < len ; i ++ ) { int lastDigit = num % 10 ; num = num / 10 ; num += ( lastDigit * x ) ; if ( num > ans ) { ans = num ; } } Console . Write ( ans ) ; }
void reverse ( int [ ] arr , int s , int e ) { while ( s < e ) { int tem = arr [ s ] ; arr [ s ] = arr [ e ] ; arr [ e ] = tem ; s = s + 1 ; e = e - 1 ; } }
int countRotation ( int [ ] arr , int low , int high ) { if ( low > high ) { return 0 ; } int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) { return mid ; } if ( arr [ mid ] > arr [ low ] ) { return countRotation ( arr , mid + 1 , high ) ; } if ( arr [ mid ] < arr [ high ] ) { return countRotation ( arr , low , mid - 1 ) ; } else { int rightIndex = countRotation ( arr , mid + 1 , high ) ; int leftIndex = countRotation ( arr , low , mid - 1 ) ; if ( rightIndex == 0 ) { return leftIndex ; } return rightIndex ; } }
void build ( int node , int l , int r , int [ ] a ) { if ( l == r ) seg [ node ] = a [ l ] ; else { int mid = ( l + r ) / 2 ; build ( 2 * node , l , mid , a ) ; build ( 2 * node + 1 , mid + 1 , r , a ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } }
bool rightRotationDivisor ( int N ) { int lastDigit = N % 10 ; int rightRotation = ( int ) ( lastDigit * Math . Pow ( 10 , ( int ) ( Math . Log10 ( N ) ) ) + Math . Floor ( ( double ) N / 10 ) ) ; return ( rightRotation % N == 0 ) ; }
int digitSum ( int num ) { int sum = 0 ; while ( num > 0 ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; }
void printList ( Node start ) { Node temp ; if ( start != null ) { temp = start ; do { Console . Write ( temp . data + " " ) ; temp = temp . next ; } while ( temp != start ) ; } }
void displayList ( Node start ) { Node temp = start ; while ( temp . next != start ) { Console . Write ( "{0} " , temp . data ) ; temp = temp . next ; } Console . Write ( "{0} " , temp . data ) ; }
int alivesol ( int Num ) { if ( Num == 1 ) return 1 ; Node last = newNode ( 1 ) ; last . next = last ; for ( int i = 2 ; i <= Num ; i ++ ) { Node tem = newNode ( i ) ; tem . next = last . next ; last . next = tem ; last = tem ; } Node curr = last . next ; Node tem1 = new Node ( ) ; while ( curr . next != curr ) { tem1 = curr ; curr = curr . next ; tem1 . next = curr . next ; tem1 = tem1 . next ; curr = tem1 ; } int res = tem1 . data ; return res ; }
void addEdge ( int u , int v , int cost ) { graph [ u ] . Add ( new int [ ] { v , cost } ) ; graph [ v ] . Add ( new int [ ] { u , cost } ) ; }
void dfs ( int node , int parent , int h ) { lca [ node , 0 ] = parent ; level [ node ] = h ; if ( parent != - 1 ) { minWeight [ node , 0 ] = Math . Min ( weight [ node ] , weight [ parent ] ) ; maxWeight [ node , 0 ] = Math . Max ( weight [ node ] , weight [ parent ] ) ; } for ( int i = 1 ; i < log ; i ++ ) { if ( lca [ node , i - 1 ] != - 1 ) { lca [ node , i ] = lca [ lca [ node , i - 1 ] , i - 1 ] ; minWeight [ node , i ] = Math . Min ( minWeight [ node , i - 1 ] , minWeight [ lca [ node , i - 1 ] , i - 1 ] ) ; maxWeight [ node , i ] = Math . Max ( maxWeight [ node , i - 1 ] , maxWeight [ lca [ node , i - 1 ] , i - 1 ] ) ; } } foreach ( int i in graph [ node ] ) { if ( i == parent ) continue ; dfs ( i , node , h + 1 ) ; } }
int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) { int temp = u ; u = v ; v = temp ; } v = parent [ v ] ; return LCANaive ( u , v ) ; }
int solve ( int [ ] A , int n ) { int i , cnt = 0 , j ; int [ ] parent = new int [ n ] ; int [ ] vis = new int [ n ] ; Array . Fill ( parent , - 1 ) ; Array . Fill ( vis , 0 ) ; for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == - 1 ) { while ( parent [ j ] == - 1 ) { parent [ j ] = i ; j = __gcd ( j , A [ j ] ) % n ; } if ( parent [ j ] == i ) { while ( vis [ j ] == 0 ) { vis [ j ] = 1 ; cnt ++ ; j = __gcd ( j , A [ j ] ) % n ; } } } } return cnt ; }
void clear ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) { lvl [ i ] = 0 ; } maxi = 0 ; dist1 [ 0 ] = dist2 [ 0 ] = - 1 ; }
double possiblePositions ( double n ) { double term1 = Math . Pow ( n , 4 ) ; double term2 = Math . Pow ( n , 3 ) ; double term3 = Math . Pow ( n , 2 ) ; double term4 = n / 3 ; double ans = ( Math . Ceiling ( term1 / 2 ) ) - ( Math . Ceiling ( 5 * term2 ) / 3 ) + ( Math . Ceiling ( 3 * term3 ) / 2 ) - term4 ; return ( long ) ans ; }
virtual bool countSingleRec ( Node node , Count c ) { if ( node == null ) { return true ; } bool left = countSingleRec ( node . left , c ) ; bool right = countSingleRec ( node . right , c ) ; if ( left == false right == false ) { return false ; } if ( node . left != null && node . data != node . left . data ) { return false ; } if ( node . right != null && node . data != node . right . data ) { return false ; } c . count ++ ; return true ; }
int maxSubArraySum ( int [ ] a , int size ) { int max_so_far = int . MinValue , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
long modInverse ( long n , int p ) { return power ( n , p - 2 , p ) ; }
long CountEvenSumSequences ( long n ) { long count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { int even = i , odd = ( int ) n - i ; if ( odd % 2 == 1 ) continue ; long tot = ( power ( countOdd ( n ) , odd , M ) * nCrModPFermat ( n , odd , M ) ) % M ; tot = ( tot * power ( counteEven ( n ) , i , M ) ) % M ; count += tot ; count %= M ; } return count ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * p ; i < MAX ; i += p ) prime [ i ] = false ; } } }
int nextOccurrence ( String str , int n , int start , char ch ) { for ( int i = start ; i < n ; i ++ ) { if ( str [ i ] == ch ) return i ; } return - 1 ; }
int changeToOnes ( String str ) { int i , l , ctr = 0 ; l = str . Length ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '1' ) ctr ++ ; else break ; } return l - ctr ; }
int getCount ( int [ ] a , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = calgcd ( gcd , a [ i ] ) ; int cnt = 0 ; for ( int i = 1 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { if ( i * i == gcd ) cnt ++ ; else cnt += 2 ; } } return cnt ; }
int findMissingPositive ( int [ ] arr , int n ) { int m = 1 ; HashSet < int > x = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m < arr [ i ] ) { x . Add ( arr [ i ] ) ; } else if ( m == arr [ i ] ) { m = m + 1 ; while ( x . Contains ( m ) ) { x . Remove ( m ) ; m = m + 1 ; } } } return m ; }
bool isPalindrome ( string str , int i , int j ) { while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
void revereseArray ( int [ ] arr , int n ) { int [ ] rev = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) rev [ n - i - 1 ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = rev [ i ] ; }
int _log ( double x , double baset ) { return ( int ) ( Math . Log ( x ) / Math . Log ( baset ) ) ; }
int maximumCut ( List < int > arr , int K ) { int low = 0 ; int high = arr . Max ( ) ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int chocolate = cal ( arr , mid ) ; if ( chocolate == K ) return mid ; else if ( chocolate < K ) high = mid - 1 ; else { low = mid + 1 ; if ( mid > high ) high = mid ; } } return high ; }
void findMissingBinaryString ( string [ ] nums , int N ) { HashSet < string > s = new HashSet < string > ( ) ; int counter = 0 ; foreach ( string str in nums ) { s . Add ( str ) ; } int total = ( int ) Math . Pow ( 2 , N ) ; for ( int i = 0 ; i < total ; i ++ ) { string num = "" ; for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( ( i & ( 1 << j ) ) > 0 ) { num += '1' ; } else { num += '0' ; } } if ( s . Contains ( num ) ) { counter ++ ; continue ; } else { Console . Write ( num + ", " ) ; } } if ( counter == total ) { Console . Write ( "-1" ) ; } }
int Minimum ( int N , int K ) { int sum = N * ( N + 1 ) / 2 ; if ( K > sum ) return - 1 ; if ( K <= N ) return 1 ; sum = 0 ; int count = 0 ; while ( N >= 1 && sum < K ) { count += 1 ; sum += N ; N -= 1 ; } return count ; }
int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int sum = 0 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += i ; if ( sum <= K ) res ++ ; else break ; } return res ; }
void mostFrequent ( int [ ] arr , int N ) { int [ ] ans = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int [ ] count = new int [ N ] ; int best = 1 ; for ( int j = i ; j < N ; j ++ ) { count [ arr [ j ] - 1 ] ++ ; if ( best > 0 ) { if ( ( count [ arr [ j ] - 1 ] > count [ best - 1 ] ) || ( count [ arr [ j ] - 1 ] == count [ best - 1 ] && arr [ j ] < best ) ) { best = arr [ j ] ; } ans [ best - 1 ] ++ ; } } } for ( int i = 0 ; i < N ; i ++ ) Console . Write ( ans [ i ] + " " ) ; }
void Add_edge ( int u , int v ) { edges [ u ] . Add ( v ) ; edges [ v ] . Add ( u ) ; }
void minCost ( char [ , ] arr , int A , int B ) { int n = arr . GetLength ( 0 ) ; int m = arr . GetLength ( 1 ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i , j ] == '*' ) continue ; if ( j == m - 1 ) ans += A ; else { if ( arr [ i , j + 1 ] == '.' ) { ans += Math . Min ( 2 * A , B ) ; j ++ ; } else ans += A ; } } } Console . WriteLine ( ans ) ; }
int binarySeach ( int [ ] P , int N ) { int i = 0 ; int j = P . Length - 1 ; int index = - 1 ; while ( i <= j ) { int mid = i + ( j - i ) / 2 ; if ( P [ mid ] >= N ) { index = mid ; j = mid - 1 ; } else { i = mid + 1 ; } } return index ; }
int countPairs ( int [ ] arr , int N ) { int count = 0 ; HashSet < int > S = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) S . Add ( arr [ i ] ) ; foreach ( int ele in S ) { int sum = 2 * ele ; count += getCountPairs ( arr , N , sum ) ; } return count ; }
void SieveOfEratosthenes ( bool [ ] prime ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < MAX ; i += p ) prime [ i ] = false ; } } }
void printReverse ( string sentence ) { List < string > newlist = new List < string > ( ) ; List < string > lis = new List < string > ( ) ; string temp = "" ; foreach ( char x in sentence ) { if ( x == ' ' ) { lis . Add ( temp ) ; temp = "" ; } else temp += x ; } lis . Add ( temp ) ; foreach ( string x in lis ) { if ( palindrome ( x ) ) newlist . Add ( x ) ; } newlist . Reverse ( ) ; int j = 0 ; for ( int i = 0 ; i < lis . Count ; i ++ ) { if ( palindrome ( lis [ i ] ) ) { lis [ i ] = newlist [ j ] ; j = j + 1 ; } } foreach ( string x in lis ) Console . Write ( x + " " ) ; }
void maximumNumber ( int [ ] arr , int N , int K ) { int mn = 100000000 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < mn ) mn = arr [ i ] ; } int ans = mn + K ; for ( int i = 0 ; i < N ; i ++ ) { if ( Math . Abs ( arr [ i ] - ans ) > K ) { ans = - 1 ; break ; } } Console . Write ( ans ) ; }
int CountPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( i * j ) == ( arr [ i ] * arr [ j ] ) ) count ++ ; } } return count ; }
bool checkGroup ( List < int > arr ) { if ( arr . Count <= 2 ) return true ; int corner = arr [ 0 ] + arr [ arr . Count - 1 ] ; int xorSum = 0 ; for ( int i = 0 ; i < arr . Count - 1 ; i ++ ) xorSum += ( arr [ i ] ^ arr [ i + 1 ] ) ; if ( corner == 0 ) if ( xorSum > 2 ) return false ; else if ( corner == 1 ) if ( xorSum > 1 ) return false ; else if ( xorSum > 0 ) return false ; return true ; }
bool isPalindrome ( string S , int i , int j ) { while ( i < j ) { if ( S [ i ] != S [ j ] ) return false ; i ++ ; j -- ; } return true ; }
void printLongestPalindrome ( string S , int N ) { int [ ] palLength = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int maxlength = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( S [ j ] == S [ i ] ) { if ( ( isPalindrome ( S , j , i ) ) != false ) { maxlength = i - j + 1 ; break ; } } } for ( int j = N - 1 ; j > i ; j -- ) { if ( S [ j ] == S [ i ] ) { if ( isPalindrome ( S , i , j ) ) { maxlength = Math . Max ( j - i + 1 , maxlength ) ; break ; } } } palLength [ i ] = maxlength ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( palLength [ i ] + " " ) ; } }
void findMaxIntervals ( List < Tuple < int , int > > v , int n ) { int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int c = n ; for ( int j = 0 ; j < n ; j ++ ) { if ( v [ i ] . Item2 < v [ j ] . Item1 v [ i ] . Item1 > v [ j ] . Item2 ) { c -- ; } } maxi = Math . Max ( c , maxi ) ; } Console . Write ( maxi ) ; }
void update ( int ss , int se , int si , int X , int V , int [ ] tree , int [ ] arr ) { if ( ss == se ) { if ( ss == X ) { arr [ X ] = V ; tree [ si ] = check ( V ) ; } return ; } int mid = ( ss + se ) / 2 ; if ( X <= mid ) update ( ss , mid , 2 * si + 1 , X , V , tree , arr ) ; else update ( mid + 1 , se , 2 * si + 2 , X , V , tree , arr ) ; tree [ si ] = tree [ 2 * si + 1 ] + tree [ 2 * si + 2 ] ; }
int atleast_x ( int index , int s , int e , int ql , int qr , int x ) { if ( ql > e qr < s ) return - 1 ; if ( s <= ql && e <= qr ) { if ( Tree [ index ] < x ) return - 1 ; while ( s != e ) { int m = ( s + e ) / 2 ; if ( Tree [ 2 * index ] >= x ) { e = m ; index = 2 * index ; } else { s = m + 1 ; index = 2 * index + 1 ; } } return s ; } int mm = ( s + e ) / 2 ; int val = atleast_x ( 2 * index , s , mm , ql , qr , x ) ; if ( val != - 1 ) return val ; return atleast_x ( 2 * index + 1 , mm + 1 , e , ql , qr , x ) ; }
void rearrange ( int [ ] a , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Math . Abs ( a [ i ] ) ; Array . Sort ( a ) ; x = n - x ; int z = count ( a ) ; if ( x > n - z ) { Console . WriteLine ( "-1" ) ; return ; } for ( int i = 0 ; i < n && x > 0 ; i += 2 ) { a [ i ] = - a [ i ] ; x -- ; } for ( int i = n - 1 ; i >= 0 && x > 0 ; i -- ) { if ( a [ i ] > 0 ) { a [ i ] = - a [ i ] ; x -- ; } } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( a [ i ] + " " ) ; } }
void countTriplets ( int [ ] arr , int N ) { List < int > zero_i = new List < int > ( ) ; List < int > one_i = new List < int > ( ) ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero_i . Add ( i + 1 ) ; else if ( arr [ i ] == 1 ) one_i . Add ( i + 1 ) ; else mp . Add ( i + 1 , 1 ) ; } int total = zero_i . Count * one_i . Count * mp . Count ; for ( int i = 0 ; i < zero_i . Count ; i ++ ) { for ( int j = 0 ; j < one_i . Count ; j ++ ) { int p = zero_i [ i ] ; int q = one_i [ j ] ; int r = 2 * p - q ; if ( mp . ContainsKey ( r ) && mp [ r ] > 0 ) total -- ; r = 2 * q - p ; if ( mp . ContainsKey ( r ) && mp [ r ] > 0 ) total -- ; r = ( p + q ) / 2 ; if ( mp . ContainsKey ( r ) && mp [ r ] > 0 && Math . Abs ( r - p ) == Math . Abs ( r - q ) ) total -- ; } } Console . Write ( total ) ; }
void Pairs ( int N , int A , int B ) { int powerA , powerB ; powerA = power ( A , N ) ; powerB = power ( B , N ) ; int intialB = B , intialA = A ; A = 1 ; for ( int i = 0 ; i <= powerA ; i ++ ) { B = 1 ; for ( int j = 0 ; j <= powerB ; j ++ ) { if ( B == N - A ) { Console . WriteLine ( i + " " + j ) ; return ; } B *= intialB ; } A *= intialA ; } Console . WriteLine ( "-1" ) ; return ; }
int CountSubarray ( int [ ] arr , int n , int k ) { int temp = k , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; }
void findElement ( int [ ] arr , int N , int K ) { int ele = findElementUtil ( arr , N , K ) ; if ( ele == - 1 ) Console . Write ( "-1" ) ; else Console . Write ( ele ) ; }
int findCntTriplet ( int N ) { int cntTriplet = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( N % i != 0 ) { cntTriplet += N / i ; } else { cntTriplet += ( N / i ) - 1 ; } } return cntTriplet ; }
void splitString ( string S , int N ) { char c = S [ N - 1 ] ; int f = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] == c ) { f = 1 ; break ; } } if ( f != 0 ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
void minOperations ( int [ ] arr , int n ) { int flips = 0 ; for ( int i = 0 ; i < n ; i += 2 ) { if ( arr [ i ] % 2 == 1 ) { continue ; } while ( i < n && arr [ i ] % 2 == 0 ) { i += 2 ; } flips ++ ; } for ( int i = 1 ; i < n ; i += 2 ) { if ( arr [ i ] % 2 == 1 ) { continue ; } while ( i < n && arr [ i ] % 2 == 0 ) { i += 2 ; } flips ++ ; } Console . WriteLine ( flips ) ; }
void checkAnswer ( Dictionary < int , int > mp , int N , int K ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( mp . ContainsKey ( i ) ) if ( mp [ i ] == ( N - K + 1 ) ) { Console . Write ( i + " " ) ; return ; } } Console . Write ( - 1 + " " ) ; }
void updateAnswerArray ( int [ ] answer , int N ) { int i = 0 ; while ( answer [ i ] == - 1 ) i ++ ; int minimum = answer [ i ] ; while ( i <= N ) { if ( answer [ i ] == - 1 ) answer [ i ] = minimum ; else answer [ i ] = Math . Min ( minimum , answer [ i ] ) ; minimum = Math . Min ( minimum , answer [ i ] ) ; i ++ ; } }
void checkString ( String X , String Y ) { int L = - 1 ; int R = - 1 ; for ( int i = 0 ; i < X . Length ; ++ i ) { if ( X [ i ] != Y [ i ] ) { L = i ; break ; } } for ( int i = X . Length - 1 ; i > 0 ; -- i ) { if ( X [ i ] != Y [ i ] ) { R = i ; break ; } } X = X . Substring ( 0 , L ) + reverse ( X . Substring ( L , R + 1 - L ) ) + X . Substring ( R + 1 ) ; if ( X . Equals ( Y ) ) { Console . Write ( "Yes" ) ; } else { Console . Write ( "No" ) ; } }
char longestLastingBulb ( List < int > onTime , string s ) { char ans ; int n = onTime . Count ; int maxDur = Int32 . MinValue ; int maxPos = Int32 . MinValue ; int currentDiff = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { currentDiff = onTime [ i ] ; maxDur = currentDiff ; maxPos = i ; } else { currentDiff = onTime [ i ] - onTime [ i - 1 ] ; if ( maxDur < currentDiff ) { maxDur = currentDiff ; maxPos = i ; } else { if ( maxDur == currentDiff ) { char one = s [ i ] ; char two = s [ maxPos ] ; if ( one > two ) { maxDur = currentDiff ; maxPos = i ; } } } } } ans = s [ maxPos ] ; return ans ; }
void max_freq ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int Max = arr [ N - 1 ] ; int Min = arr [ 0 ] ; int [ ] freq = new int [ Max - Min + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] - Min ] ++ ; } int maxSum = 0 ; for ( int i = 0 ; i < ( Max - Min - 1 ) ; i ++ ) { int val = freq [ i ] + freq [ i + 1 ] + freq [ i + 2 ] ; maxSum = Math . Max ( maxSum , val ) ; } Console . WriteLine ( maxSum ) ; }
int find_longest_subarray ( int [ ] A , int N , int K ) { int MaxLen = 0 ; int Len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( K % A [ i ] == 0 ) { Len ++ ; MaxLen = Math . Max ( MaxLen , Len ) ; } else { Len = 0 ; } } return MaxLen ; }
void SieveOfEratosthenes ( bool [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
string kReducingStringUtil ( int n , int k , string str , int no_of_zeroes ) { int zeroes_in_2k = ( ( no_of_zeroes ) * ( 2 * k ) ) / n ; int ones_in_2k = 2 * k - zeroes_in_2k ; string temp_str = "" ; for ( int i = 0 ; i < ( zeroes_in_2k ) / 2 ; i ++ ) { temp_str += '0' ; } for ( int i = 0 ; i < ones_in_2k ; i ++ ) { temp_str += '1' ; } for ( int i = 0 ; i < ( zeroes_in_2k ) / 2 ; i ++ ) { temp_str += '0' ; } string final_str = "" ; for ( int i = 0 ; i < n / ( 2 * k ) ; i ++ ) { final_str += ( temp_str ) ; } for ( int i = 0 ; i < n % ( 2 * k ) ; i ++ ) { final_str += temp_str [ i ] ; } return final_str ; }
int power ( int x , int N ) { int res = 1 ; while ( N > 0 ) { if ( ( N & 1 ) != 0 ) { res = ( res * x ) ; } x = ( x * x ) ; N = N >> 1 ; } return res ; }
void countRemovableElem ( int [ ] arr , int N ) { int [ ] hash = new int [ N + 1 ] ; Array . Fill ( hash , 0 ) ; int mex = N + 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= N ) hash [ arr [ i ] ] = 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( hash [ i ] == 0 ) { mex = i ; break ; } } Console . WriteLine ( N - ( mex - 1 ) ) ; }
void findMaxPoints ( int [ , ] arr , int n ) { int [ ] ans = findMaxPoint ( arr , 0 , n ) ; if ( ans [ 0 ] == INF ) { Console . WriteLine ( - 1 ) ; } else { Console . WriteLine ( "(" + ans [ 0 ] + " " + ans [ 1 ] + ")" ) ; } }
int numberOfGP ( int [ ] L , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
bool palindrome ( int [ ] a , int i , int j ) { while ( i < j ) { if ( a [ i ] != a [ j ] ) return false ; i ++ ; j -- ; } return true ; }
void countGreater ( int [ ] arr , int N ) { List < int > St = new List < int > ( ) ; int [ ] countLeftGreater = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { St . Add ( arr [ i ] ) ; int it = 0 ; St . Sort ( ) ; foreach ( int itr in St ) { if ( arr [ i ] < itr ) { break ; } it ++ ; } countLeftGreater [ i ] = Math . Abs ( it - St . Count ) ; } display ( countLeftGreater , N ) ; }
int key ( int N ) { String num = "" + N ; int ans = 0 ; int j = 0 ; for ( j = 0 ; j < num . Length ; j ++ ) { if ( ( num [ j ] - 48 ) % 2 == 0 ) { int add = 0 ; int i ; for ( i = j ; j < num . Length ; j ++ ) { add += num [ j ] - 48 ; if ( add % 2 == 1 ) break ; } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) Math . Floor ( Math . Log10 ( add ) + 1 ) ; ans *= ( int ) ( Math . Pow ( 10 , digit ) ) ; ans += add ; } i = j ; } else { int add = 0 ; int i ; for ( i = j ; j < num . Length ; j ++ ) { add += num [ j ] - 48 ; if ( add % 2 == 0 ) { break ; } } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) Math . Floor ( Math . Log10 ( add ) + 1 ) ; ans *= ( int ) ( Math . Pow ( 10 , digit ) ) ; ans += add ; } i = j ; } } if ( j + 1 >= num . Length ) { return ans ; } else { return ans += num [ num . Length - 1 ] - 48 ; } }
int longDelSub ( string str1 , string str2 ) { int N = str1 . Length ; int M = str2 . Length ; int prev_pos = 0 ; int [ ] pos = new int [ M ] ; for ( int i = 0 ; i < M ; i ++ ) { int index = prev_pos ; while ( index < N && str1 [ index ] != str2 [ i ] ) { index ++ ; } pos [ i ] = index ; prev_pos = index + 1 ; } int res = N - prev_pos ; prev_pos = N - 1 ; for ( int i = M - 1 ; i >= 0 ; i -- ) { int index = prev_pos ; while ( index >= 0 && str1 [ index ] != str2 [ i ] ) { index -- ; } if ( i != 0 ) { res = Math . Max ( res , index - pos [ i - 1 ] - 1 ) ; } prev_pos = index - 1 ; } res = Math . Max ( res , prev_pos + 1 ) ; return res ; }
int countSubArray ( int [ ] arr , int n ) { if ( n < 2 ) return n ; int i = max_element ( arr ) ; int j = min_element ( arr ) ; if ( i > j ) { int tmp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = tmp ; } return ( i + 1 ) * ( n - j ) ; }
bool isPerfectSquare ( int n ) { double sr = Math . Sqrt ( n ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ; }
void updateFreq ( int n , int [ ] freq ) { while ( n > 0 ) { int digit = n % TEN ; freq [ digit ] ++ ; n /= TEN ; } }
int count_numbers ( int L , int R ) { int ans = 0 ; int LogR = ( int ) ( Math . Log ( R ) + 1 ) ; for ( int zero_bit = 0 ; zero_bit < LogR ; zero_bit ++ ) { int cur = 0 ; for ( int j = 0 ; j < zero_bit ; j ++ ) { cur |= ( 1 << j ) ; } for ( int j = zero_bit + 1 ; j < LogR ; j ++ ) { cur |= ( 1 << j ) ; if ( cur >= L && cur <= R ) { ans ++ ; } } } return ans ; }
int maxGCD ( int n ) { return ( n / 2 ) ; }
void updateTree ( String str , int pos , char s ) { int index = pos ; update_BITree ( index , str [ index ] , - 1 ) ; str = str . Substring ( 0 , index ) + s + str . Substring ( index + 1 ) ; update_BITree ( index , s , 1 ) ; }
int minServerLoads ( int n , int [ ] servers ) { int totalLoad = 0 ; for ( int i = 0 ; i < servers . Length ; i ++ ) totalLoad += servers [ i ] ; int requiredLoad = totalLoad / 2 ; int [ , ] dp = new int [ n + 1 , requiredLoad + 1 ] ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < requiredLoad + 1 ; j ++ ) { if ( servers [ i - 1 ] > j ) dp [ i , j ] = dp [ i - 1 , j ] ; else dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] , servers [ i - 1 ] + dp [ i - 1 , j - servers [ i - 1 ] ] ) ; } } return totalLoad - 2 * dp [ n , requiredLoad ] ; }
int maxLength ( String [ ] arr ) { int len = int . MinValue ; int N = arr . Length ; for ( int i = 0 ; i < N ; i ++ ) { int l = arr [ i ] . Length ; if ( len < l ) { len = l ; } } return len ; }
void dfs ( int node ) { vis [ node ] = true ; foreach ( int x in vec [ node ] ) { if ( ! vis [ x ] ) { cc ++ ; dfs ( x ) ; } } }
double solve ( int [ , ] D , int N , int X , int Y ) { ArrayList T = new ArrayList ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int x = D [ i , 0 ] ; int y = D [ i , 1 ] ; double speed = D [ i , 2 ] ; double time = ( ( x * x - X * X ) + ( y * y - Y * Y ) ) / ( speed * speed ) ; T . Add ( time ) ; } T . Sort ( ) ; int j = 0 ; int total = 0 ; while ( j < ( T . Count - 1 ) ) { int count = 1 ; while ( ( j < ( T . Count - 1 ) ) && ( Convert . ToDouble ( T [ j ] ) . CompareTo ( Convert . ToDouble ( T [ j + 1 ] ) ) == 0 ) ) { count += 1 ; j += 1 ; } total += ( count * ( count - 1 ) ) / 2 ; j += 1 ; } return total ; }
int [ ] findSubarrays ( int [ ] a ) { int n = a . Length ; int [ ] freq = new int [ n + 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { if ( count == 0 ) continue ; else { int value = count ; for ( int j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } count = 0 ; } } else count ++ ; } if ( count > 0 ) { int value = count ; for ( int j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } } return freq ; }
void sumOfIndices ( string s ) { int N = s . Length ; int x = ( int ) ( Math . Ceiling ( Math . Log ( N ) / Math . Log ( 2 ) ) ) ; int seg_size = 2 * ( int ) Math . Pow ( 2 , x ) - 1 ; int [ ] segment = new int [ seg_size ] ; int count = 4 ; Dictionary < int , List < int > > fre = new Dictionary < int , List < int > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int key = ( int ) ( s [ i ] ) ; List < int > que = new List < int > ( ) ; if ( fre . ContainsKey ( key ) ) { que = fre [ key ] ; } que . Add ( i ) ; fre [ key ] = que ; } while ( fre . Count > 0 ) { int it = fre . Keys . First ( ) ; if ( fre [ it ] . Count == 0 ) fre . Remove ( it ) ; else { List < int > que = fre [ it ] ; int original_index = que [ 0 ] ; int curr_index = deleted ( segment , 0 , original_index - 1 , 0 , N - 1 , 0 ) ; int new_index = original_index - curr_index ; count += new_index + 1 ; add_seg ( segment , 0 , N - 1 , 0 , original_index ) ; que . RemoveAt ( 0 ) ; fre [ it ] = que ; } } Console . Write ( count ) ; }
int maxLength ( int n , int m ) { sieve ( ) ; smallestPrimeFactors ( ) ; int ans = int . MinValue ; for ( int i = n ; i <= m ; i ++ ) { if ( i == 4 ) { continue ; } ans = Math . Max ( ans , findLength ( i ) ) ; } return ans ; }
int getMax ( int [ ] st , int n , int l , int r ) { if ( l < 0 r > n - 1 l > r ) { Console . Write ( "Invalid Input" ) ; return - 1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; }
int subArraylen ( int [ ] arr , int n , int K ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; mp . Add ( arr [ 0 ] , 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; mp . Add ( arr [ i ] , i ) ; } int len = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < K ) continue ; else { int x = K - arr [ i ] ; if ( x == 0 ) len = Math . Min ( len , i ) ; if ( mp . ContainsValue ( x ) ) continue ; else { len = Math . Min ( len , i ) ; } } } return len ; }
bool check ( int [ ] arr , int n ) { int i , g ; g = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 0 && g == 1 ) return false ; if ( arr [ i ] - arr [ i - 1 ] < 0 ) g = 1 ; } return true ; }
void addedge ( int node1 , int node2 ) { G [ node1 ] . Add ( node2 ) ; G [ node2 ] . Add ( node1 ) ; }
int countElements ( int [ ] arr , int n , int k ) { Stack < int > s = new Stack < int > ( ) ; int [ ] next_greater = new int [ n + 1 ] ; Array . Fill ( next_greater , n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . Count == 0 ) { s . Push ( i ) ; continue ; } while ( s . Count != 0 && arr [ s . Peek ( ) ] < arr [ i ] ) { next_greater [ s . Peek ( ) ] = i ; s . Pop ( ) ; } s . Push ( i ) ; } int count = 0 ; int maxi = Int32 . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( next_greater [ i ] - i > k && maxi < arr [ i ] ) { maxi = Math . Max ( maxi , arr [ i ] ) ; count ++ ; } } return count ; }
void addEdge ( int u , int v ) { adj [ u ] . Add ( v ) ; adj [ v ] . Add ( u ) ; }
List < List < int > > constructTree ( int n , int [ , ] edges ) { List < List < int > > adjl = new List < List < int > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { adjl . Add ( new List < int > ( ) ) ; } for ( int i = 0 ; i < edges . GetLength ( 0 ) ; i ++ ) { int u = edges [ i , 0 ] ; int v = edges [ i , 1 ] ; adjl [ u ] . Add ( v ) ; adjl [ v ] . Add ( u ) ; } return adjl ; }
int min_remove ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int ans = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] - arr [ i ] <= k ) { ans = Math . Min ( ans , n - j + i - 1 ) ; } } } return ans ; }
int lcm ( int a , int b ) { return ( a * b ) / __gcd ( a , b ) ; }
int countPair ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( __gcd ( i , j ) + lcm ( i , j ) == N ) { count ++ ; } } } return count ; }
bool isVowel ( char c ) { if ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) return true ; return false ; }
void countSubstrings ( String s , int n ) { int [ ] temp = { 1 , 0 } ; int result = 0 , sum = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { sum += ( isVowel ( s [ i ] ) ? 1 : 0 ) ; sum %= 2 ; temp [ sum ] ++ ; } result += ( ( temp [ 0 ] * ( temp [ 0 ] - 1 ) ) / 2 ) ; result += ( ( temp [ 1 ] * ( temp [ 1 ] - 1 ) ) / 2 ) ; Console . Write ( result ) ; }
int minOperations ( String s ) { int n = s . Length ; int pos = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '1' ) { pos = i ; break ; } } if ( pos == - 1 ) { return 0 ; } int last = 1 ; int ans = 1 ; for ( int i = pos + 1 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) { if ( last == 1 ) { ans ++ ; last = 0 ; } } else { if ( last == 0 ) { ans ++ ; last = 1 ; } } } return ans ; }
bool checkBitonic ( int [ ] arr , int n ) { int i , j , f = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { f = 1 ; break ; } } if ( i == n ) return true ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < arr [ j - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { if ( f == 1 ) return false ; } } return true ; }
bool isNudeNum ( int n ) { int copy , length , flag = 0 ; copy = n ; String temp ; temp = String . Join ( "" , copy ) ; length = temp . Length ; for ( int i = 0 ; i < length ; i ++ ) { int num = temp [ i ] - '0' ; if ( num == 0 n % num != 0 ) { flag = 1 ; } } if ( flag == 1 ) return false ; else return true ; }
List < int > get_subminarr ( int [ ] arr , int n , int y ) { int j = 0 ; Stack < int > stk = new Stack < int > ( ) ; int [ ] minarr = new int [ n ] ; Array . Fill ( minarr , 0 ) ; stk . Push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( stk . Count != 0 && arr [ i ] < arr [ stk . Peek ( ) ] ) { minarr [ stk . Peek ( ) ] = i ; stk . Pop ( ) ; } stk . Push ( i ) ; } while ( stk . Count != 0 ) { minarr [ stk . Peek ( ) ] = n ; stk . Pop ( ) ; } List < int > submin = new List < int > ( ) ; for ( int i = 0 ; i <= n - y ; i ++ ) { while ( minarr [ j ] <= i + y - 1 j < i ) { j ++ ; } submin . Add ( arr [ j ] ) ; } return submin ; }
void PrintSequence ( int [ ] freq , int n ) { List < int > sequence = generateSequence ( freq , n ) ; if ( sequence . Count == 0 ) { Console . Write ( "-1" ) ; } else { for ( int i = 0 ; i < sequence . Count ; i ++ ) { Console . Write ( sequence [ i ] + " " ) ; } } }
void checkArray ( int [ ] A , int [ ] B , int N ) { int start = 0 ; int end = N - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { start = i ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( A [ i ] != B [ i ] ) { end = i ; break ; } } Array . Reverse ( A , start , end ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { Console . Write ( "No" ) ; return ; } } Console . Write ( "Yes" ) ; }
int longestSubarray ( int [ ] a , int n ) { int [ ] l = new int [ n ] ; int [ ] r = new int [ n ] ; for ( int i = 0 , count = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; else { l [ i ] = count ; count = 0 ; } } for ( int i = n - 1 , count = 0 ; i >= 0 ; i -- ) { if ( a [ i ] == 1 ) count ++ ; else { r [ i ] = count ; count = 0 ; } } int ans = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] == 0 ) ans = Math . Max ( ans , l [ i ] + r [ i ] ) ; } return ans < 0 ? n : ans ; }
int solve ( int n , int k ) { int ans = 0 ; for ( int j = 1 ; j * j <= n ; j ++ ) { if ( n % j == 0 ) { if ( j <= k ) { ans = Math . Max ( ans , j ) ; } if ( n / j <= k ) { ans = Math . Max ( ans , n / j ) ; } } } return ans ; }
int splitArray ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int result = Int32 . MaxValue ; for ( int i = 1 ; i < N ; i ++ ) { result = Math . Min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
int countTriplets ( int [ ] a , int n , int x ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { int [ ] temp = { a [ i ] , a [ j ] , a [ k ] } ; Array . Sort ( temp ) ; if ( temp [ 0 ] < temp [ 1 ] && temp [ 1 ] < temp [ 2 ] && temp [ 0 ] * temp [ 1 ] * temp [ 2 ] <= x ) answer ++ ; } } } return answer ; }
void fibonacci ( ) { int prev = 0 , curr = 1 , len = 2 ; fib . Add ( prev ) ; fib . Add ( curr ) ; while ( len <= MAX ) { int temp = curr + prev ; fib . Add ( temp ) ; prev = curr ; curr = temp ; len ++ ; } }
int xorOfSum ( int [ ] a , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; }
void createHash ( HashSet < int > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . Add ( prev ) ; hash . Add ( curr ) ; while ( curr < maxElement ) { int temp = curr + prev ; hash . Add ( temp ) ; prev = curr ; curr = temp ; } }
void state8 ( char c ) { if ( c == 'c' ) nfa = 9 ; else if ( c == 'b' c == 'a' ) nfa = 8 ; else flag = 1 ; }
int maxSum ( int [ ] arr , int n , int k ) { if ( n < k ) { return - 1 ; } int res = 0 ; for ( int i = 0 ; i < k ; i ++ ) res += arr [ i ] ; int curr_sum = res ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; res = Math . Max ( res , curr_sum ) ; } return res ; }
bool isDigit ( char ch ) { if ( ch >= '0' && ch <= '9' ) return true ; return false ; }
int nextPosition ( int tempGCD , int startPointer , int prevEndPointer , int n ) { int high = n - 1 ; int low = prevEndPointer ; int mid = prevEndPointer ; int nextPos = prevEndPointer ; while ( high >= low ) { mid = ( ( high + low ) >> 1 ) ; if ( queryForGCD ( startPointer , mid ) == tempGCD ) { nextPos = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return nextPos + 1 ; }
int gcd ( int A , int B ) { if ( B == 0 ) return A ; return gcd ( B , A % B ) ; }
void farthest_min ( int [ ] a , int n ) { int [ ] suffix_min = new int [ n ] ; suffix_min [ n - 1 ] = a [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffix_min [ i ] = Math . Min ( suffix_min [ i + 1 ] , a [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { int low = i + 1 , high = n - 1 , ans = - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( suffix_min [ mid ] < a [ i ] ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } Console . Write ( ans + " " ) ; } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int solve ( int [ ] array , int n , int K ) { int start = 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( array [ i ] > start ) } int end = 0 ; for ( int i = 0 ; i < n ; i ++ ) { } int answer = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( check ( mid , array , n , K ) ) { answer = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } return answer ; } public static void Main ( String [ ] args ) { int [ ] array = { 1 , 2 , 3 , 4 } ; int n = array . Length ; int K = 3 ; Console . WriteLine ( solve ( array , n , K ) ) ; } }
bool isPossible ( int [ ] box , int [ ] truck , int n , int m , int min_time ) { int temp = 0 ; int count = 0 ; while ( count < m ) { for ( int j = 0 ; j < min_time && temp < n && truck [ count ] >= box [ temp ] ; j += 2 ) temp ++ ; count ++ ; } if ( temp == n ) return true ; return false ; }
void solve ( int [ , ] interval , int N , int Q ) { int [ ] Mark = new int [ Q ] ; for ( int i = 0 ; i < N ; i ++ ) { int l = interval [ i , 0 ] - 1 ; int r = interval [ i , 1 ] - 1 ; for ( int j = l ; j <= r ; j ++ ) Mark [ j ] ++ ; } int count = 0 ; for ( int i = 0 ; i < Q ; i ++ ) { if ( Mark [ i ] != 0 ) count ++ ; } int [ ] count1 = new int [ Q ] ; if ( Mark [ 0 ] == 1 ) count1 [ 0 ] = 1 ; for ( int i = 1 ; i < Q ; i ++ ) { if ( Mark [ i ] == 1 ) count1 [ i ] = count1 [ i - 1 ] + 1 ; else count1 [ i ] = count1 [ i - 1 ] ; } int maxindex = 0 ; int maxcoverage = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int l = interval [ i , 0 ] - 1 ; int r = interval [ i , 1 ] - 1 ; int elem1 ; if ( l != 0 ) elem1 = count1 [ r ] - count1 [ l - 1 ] ; else elem1 = count1 [ r ] ; if ( count - elem1 >= maxcoverage ) { maxcoverage = count - elem1 ; maxindex = i ; } } Console . WriteLine ( "Maximum Coverage is " + maxcoverage + " after removing interval at index " + maxindex ) ; }
int maxSum ( int [ ] arr , int n , int K ) { int maximum = int . MinValue ; int [ ] sum = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i + K < n ) sum [ i ] = sum [ i + K ] + arr [ i ] ; else sum [ i ] = arr [ i ] ; maximum = Math . Max ( maximum , sum [ i ] ) ; } return maximum ; }
int countGreater ( int [ ] arr , int n , int k ) { int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; }
int countFactor ( int P , int X ) { if ( X < P ) return 0 ; return ( X / P + countFactor ( P , X / P ) ) ; }
long squareSum ( long N ) { long sum = ( long ) ( N * ( N + 1 ) * ( 2 * N + 1 ) ) / 6 ; return sum ; }
int countPattern ( int n , string pat ) { int pattern_int = 0 ; int power_two = 1 ; int all_ones = 0 ; for ( int i = pat . Length - 1 ; i >= 0 ; i -- ) { int current_bit = pat [ i ] - '0' ; pattern_int += ( power_two * current_bit ) ; all_ones = all_ones + power_two ; power_two = power_two * 2 ; } int count = 0 ; while ( n != 0 && n >= pattern_int ) { if ( ( n & all_ones ) == pattern_int ) { count ++ ; } n = n >> 1 ; } return count ; }
int getMax ( int [ ] arr , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = Math . Max ( res , arr [ i ] ) ; return res ; }
void printDuplicates ( int [ ] arr , int n ) { int i ; int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { Console . Write ( arr [ i ] % n + " " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! ( fl > 0 ) ) Console . Write ( "-1" ) ; }
int maxProduct ( int [ ] arr , int n ) { if ( n < 4 ) return - 1 ; Array . Sort ( arr ) ; int x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; int y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; int z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return Math . Max ( x , Math . Max ( y , z ) ) ; }
int maxProduct ( int [ ] arr , int n ) { if ( n < 4 ) { return - 1 ; } int maxA = int . MinValue , maxB = int . MinValue , maxC = int . MinValue , maxD = int . MinValue ; int minA = int . MaxValue , minB = int . MaxValue , minC = int . MaxValue , minD = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxD = maxC ; maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxD = maxC ; maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) { maxD = maxC ; maxC = arr [ i ] ; } else if ( arr [ i ] > maxD ) { maxD = arr [ i ] ; } if ( arr [ i ] < minA ) { minD = minC ; minC = minB ; minB = minA ; minA = arr [ i ] ; } else if ( arr [ i ] < minB ) { minD = minC ; minC = minB ; minB = arr [ i ] ; } else if ( arr [ i ] < minC ) { minD = minC ; minC = arr [ i ] ; } else if ( arr [ i ] < minD ) { minD = arr [ i ] ; } } int x = maxA * maxB * maxC * maxD ; int y = minA * minB * minC * minD ; int z = minA * minB * maxA * maxB ; return Math . Max ( x , Math . Max ( y , z ) ) ; }
void push ( Node head_ref , char new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; head = head_ref ; }
bool isPossible ( int [ ] arr , int n , int m , int curr_min ) { int studentsRequired = 1 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > curr_min ) return false ; if ( curr_sum + arr [ i ] > curr_min ) { studentsRequired ++ ; curr_sum = arr [ i ] ; if ( studentsRequired > m ) return false ; } else curr_sum += arr [ i ] ; } return true ; }
void sortArray ( int [ ] arr , int N ) { int i = 0 , j = N - 1 , mid = 0 ; while ( mid <= j ) { if ( arr [ mid ] == 0 ) { int temp = arr [ i ] ; arr [ i ] = arr [ mid ] ; arr [ mid ] = temp ; i ++ ; mid ++ ; } else if ( arr [ mid ] == 3 ) { int temp = arr [ mid ] ; arr [ mid ] = arr [ j ] ; arr [ j ] = temp ; j -- ; } else if ( arr [ mid ] == 1 arr [ mid ] == 2 ) { mid ++ ; } } while ( i <= j ) { if ( arr [ i ] == 2 ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; j -- ; } else { i ++ ; } } for ( int k = 0 ; k < N ; k ++ ) { Console . Write ( arr [ k ] + " " ) ; } }
bool isSorted ( int [ , ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i , 0 ] > arr [ i - 1 , 0 ] ) { return false ; } } return true ; }
bool isSortedArray ( int [ ] arr , int n ) { int l = 0 , r = ( n - 1 ) ; while ( ( l + 1 ) < r ) { if ( arr [ l ] >= Math . Max ( arr [ l + 1 ] , arr [ r - 1 ] ) && arr [ r ] >= Math . Max ( arr [ r - 1 ] , arr [ l + 1 ] ) ) { l ++ ; r -- ; } else { return false ; } } return true ; }
void findMaxNumbers ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int opr = ( int ) Math . Ceiling ( ( Math . Log ( arr [ i ] ) / Math . Log ( 2 ) ) ) ; k -= opr ; if ( k < 0 ) { break ; } cnt ++ ; } Console . Write ( cnt ) ; }
void rearrange ( int [ ] A , int [ ] B , int N , int X ) { bool flag = true ; Array . Sort ( A ) ; Array . Sort ( B ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ N - 1 - i ] > X ) { flag = false ; break ; } } if ( flag == true ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
int getMinCost ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; reverse ( arr , n ) ; int min_cost = 0 ; int X = 0 ; for ( int i = 0 ; i < n ; i += k ) { for ( int j = i ; j < i + k && j < n ; j ++ ) { min_cost += arr [ j ] * ( X + 1 ) ; } X ++ ; } return min_cost ; }
int mergeSortUtil ( int [ ] arr , int [ ] temp , int l , int r , int K ) { int cnt = 0 ; if ( l < r ) { int m = ( l + r ) / 2 ; cnt += mergeSortUtil ( arr , temp , l , m , K ) ; cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) ; cnt += merge ( arr , temp , l , m , r , K ) ; } return cnt ; }
void Bubble_Sort ( int [ ] arr , int n ) { for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; } } } }
void mostvisitedsector ( int N , ArrayList A ) { int maxVisited = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < A . Count - 1 ; i ++ ) { int start = ( int ) A [ i ] % N ; int end = ( int ) A [ i + 1 ] % N ; while ( start != end ) { if ( start == 0 ) { if ( mp . ContainsKey ( N ) ) mp [ N ] = mp [ N ] + 1 ; else mp [ N ] = 1 ; if ( mp [ N ] > maxVisited ) { maxVisited = mp [ N ] ; } } else { if ( mp . ContainsKey ( start ) ) mp [ start ] = mp [ start ] + 1 ; else mp [ start ] = 1 ; if ( mp [ start ] > maxVisited ) { maxVisited = mp [ start ] ; } } start = ( start + 1 ) % N ; } } int last_element = ( int ) A [ A . Count - 1 ] ; if ( mp . ContainsKey ( last_element ) ) mp [ last_element ] = mp [ last_element ] + 1 ; else mp [ last_element ] = 1 ; if ( mp [ last_element ] > maxVisited ) { maxVisited = mp [ last_element ] ; } foreach ( var x in mp ) { if ( ( int ) x . Value == maxVisited ) { Console . Write ( x . Key + " " ) ; } } }
int maxRectangle ( int [ , ] sequence , int size ) { int [ ] X_Cord = new int [ size ] ; int [ ] Y_Cord = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { X_Cord [ i ] = sequence [ i , 0 ] ; Y_Cord [ i ] = sequence [ i , 1 ] ; } Array . Sort ( X_Cord ) ; Array . Sort ( Y_Cord ) ; int X_Max = 0 , Y_Max = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { X_Max = Math . Max ( X_Max , X_Cord [ i + 1 ] - X_Cord [ i ] ) ; Y_Max = Math . Max ( Y_Max , Y_Cord [ i + 1 ] - Y_Cord [ i ] ) ; } return X_Max * Y_Max ; }
int evenSumK ( int [ ] arr , int N , int K ) { if ( K > N ) { return - 1 ; } int maxSum = 0 ; List < int > Even = new List < int > ( ) ; List < int > Odd = new List < int > ( ) ; for ( int l = 0 ; l < N ; l ++ ) { if ( arr [ l ] % 2 == 1 ) { Odd . Add ( arr [ l ] ) ; } else { Even . Add ( arr [ l ] ) ; } } Odd . Sort ( ) ; Even . Sort ( ) ; int i = Even . Count - 1 ; int j = Odd . Count - 1 ; while ( K > 0 ) { if ( K % 2 == 1 ) { if ( i >= 0 ) { maxSum += Even [ i ] ; i -- ; } else { return - 1 ; } K -- ; } else if ( i >= 1 && j >= 1 ) { if ( Even [ i ] + Even [ i - 1 ] <= Odd [ j ] + Odd [ j - 1 ] ) { maxSum += Odd [ j ] + Odd [ j - 1 ] ; j -= 2 ; } else { maxSum += Even [ i ] + Even [ i - 1 ] ; i -= 2 ; } K -= 2 ; } else if ( i >= 1 ) { maxSum += Even [ i ] + Even [ i - 1 ] ; i -= 2 ; K -= 2 ; } else if ( j >= 1 ) { maxSum += Odd [ j ] + Odd [ j - 1 ] ; j -= 2 ; K -= 2 ; } } return maxSum ; }
void find_mth_bitUtil ( int n , int m ) { int [ ] fib = new int [ maxN ] ; calculateFib ( fib , maxN ) ; int ans = find_mth_bit ( n , m , fib ) ; Console . Write ( ans + " " ) ; }
int range_sum ( int [ ] arr , int a , int b ) { int sum = 0 ; if ( a - 2 < 0 ) sum = arr [ b - 1 ] ; else sum = arr [ b - 1 ] - arr [ a - 2 ] ; return sum ; }
int XorSum ( int [ ] A , int [ ] B , int N ) { int maxBit = 29 ; int ans = 0 ; for ( int k = 0 ; k < maxBit ; k ++ ) { int [ ] C = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { C [ i ] = B [ i ] % ( 1 << ( k + 1 ) ) ; } Array . Sort ( C ) ; long count = 0 ; long l , r ; for ( int i = 0 ; i < N ; i ++ ) { int x = A [ i ] % ( 1 << ( k + 1 ) ) ; l = lower_bound ( C , 0 , N , ( 1 << k ) - x ) ; r = lower_bound ( C , 0 , N , ( 1 << k ) * 2 - x ) ; count += ( r - l ) ; l = lower_bound ( C , 0 , N , ( 1 << k ) * 3 - x ) ; r = lower_bound ( C , 0 , N , ( 1 << k ) * 4 - x ) ; count += ( r - l ) ; } if ( ( count & 1 ) != 0 ) ans += ( 1 << k ) ; } return ans ; }
int countPairs ( int [ ] arr , int n ) { int ans = 0 ; Dictionary < int , int > count = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . ContainsKey ( arr [ i ] ) ) { ans += count [ arr [ i ] ] ; count [ arr [ i ] ] = count [ arr [ i ] ] + 1 ; } else { count . Add ( arr [ i ] , 1 ) ; } } return ans ; }
long getAlphaScore ( Node node ) { if ( node . left != null ) getAlphaScore ( node . left ) ; sum = ( sum + node . data ) % mod ; total_sum = ( total_sum + sum ) % mod ; if ( node . right != null ) getAlphaScore ( node . right ) ; return total_sum ; }
void sortArr ( int [ ] a , int n ) { int i , k ; k = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; k = ( int ) Math . Pow ( 2 , k ) ; while ( k > 0 ) { for ( i = 0 ; i + k < n ; i ++ ) if ( a [ i ] > a [ i + k ] ) { int tmp = a [ i ] ; a [ i ] = a [ i + k ] ; a [ i + k ] = tmp ; } k = k / 2 ; } for ( i = 0 ; i < n ; i ++ ) { Console . Write ( a [ i ] + " " ) ; } }
void maximizeval10 ( int [ ] a , int n , int k ) { int increments = 0 ; int ans = 0 ; List < int > v = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( a [ i ] / 10 ) ; if ( a [ i ] == 1000 ) continue ; else { v . Add ( 10 - a [ i ] % 10 ) ; increments += ( 100 - ( ( a [ i ] ) / 10 ) - 1 ) ; } } v . Sort ( ) ; int sum = 0 ; for ( int i = 0 ; i < v . Count ; i ++ ) { sum += v [ i ] ; if ( sum <= k ) { ans ++ ; } else break ; } if ( sum < k ) { int remaining = k - sum ; ans += Math . Min ( increments , remaining / 10 ) ; } Console . Write ( ans ) ; }
int number ( int [ ] a , int n , int p , int k ) { Array . Sort ( a ) ; int [ ] pre = new int [ n ] ; int i , ans = 0 ; pre [ 0 ] = a [ 0 ] ; if ( pre [ 0 ] <= p ) ans = 1 ; for ( i = 1 ; i < k - 1 ; i ++ ) { pre [ i ] = pre [ i - 1 ] + a [ i ] ; if ( pre [ i ] <= p ) ans = i + 1 ; } pre [ k - 1 ] = a [ k - 1 ] ; for ( i = k - 1 ; i < n ; i ++ ) { if ( i >= k ) { pre [ i ] += pre [ i - k ] + a [ i ] ; } if ( pre [ i ] <= p ) ans = i + 1 ; } return ans ; }
bool checkIsAP ( double [ ] arr , int n ) { if ( n == 1 ) return true ; Array . Sort ( arr ) ; double d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != d ) { return false ; } } return true ; }
int findK ( int [ ] arr , int size , int N ) { Array . Sort ( arr ) ; int temp_sum = 0 ; for ( int i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return - 1 ; }
int findSum ( int [ ] arr , int n , int k , int l , int r ) { if ( ( l ) + ( n - 1 - r ) == k ) return arr [ r ] - arr [ l ] ; if ( vis [ l , r ] == 1 ) return dp [ l , r ] ; vis [ l , r ] = 1 ; dp [ l , r ] = Math . Min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; return dp [ l , r ] ; }
void printList ( Node node ) { Node last ; while ( node != null ) { Console . Write ( node . data + " " ) ; last = node ; node = node . next ; } }
int Removal ( int [ ] v , int n ) { Array . Sort ( v ) ; int ans = int . MaxValue ; int k = 0 ; foreach ( int i in v ) { int j = upperBound ( v , ( 2 * i ) ) ; ans = Math . Min ( ans , n - ( j - k ) ) ; k ++ ; } return ans ; }
void printArrangement ( int [ ] a , int n ) { Array . Sort ( a ) ; int [ ] b = new int [ n ] ; int low = 0 , high = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) b [ low ++ ] = a [ i ] ; else b [ high -- ] = a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { if ( b [ n - 1 ] + b [ 1 ] <= b [ i ] ) { Console . Write ( - 1 ) ; return ; } } else if ( i == ( n - 1 ) ) { if ( b [ n - 2 ] + b [ 0 ] <= b [ i ] ) { Console . Write ( - 1 ) ; return ; } } else { if ( b [ i - 1 ] + b [ i + 1 ] <= b [ i ] ) { Console . Write ( - 1 ) ; return ; } } } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( b [ i ] + " " ) ; }
void K_multiple ( int [ ] a , int n , int k ) { Array . Sort ( a ) ; HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] % k == 0 && ! s . Contains ( a [ i ] / k ) ) a [ i ] % k != 0 ) s . Add ( a [ i ] ) ; } foreach ( int i in s ) Console . Write ( i + " " ) ; }
long powmod ( long a , long n ) { if ( n == 0 ) return 1 ; long pt = powmod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 == 1 ) return ( pt * a ) % mod ; else return pt ; }
long product ( long [ ] a , int n , int k ) { long ans = 1 ; Array . Sort ( a ) ; long powa = C [ n - 1 , k - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { long powla = C [ i , k - 1 ] ; long powfa = C [ n - i - 1 , k - 1 ] ; long powe = ( ( powa % MOD ) - ( powla + powfa ) % MOD + MOD ) % MOD ; long mul = power ( a [ i ] , powe ) % MOD ; ans = ( ( ans % MOD ) * ( mul % MOD ) ) % MOD ; } return ans % MOD ; }
bool check ( char [ ] s ) { int l = s . Length ; Array . Sort ( s ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( s [ i ] - s [ i - 1 ] != 1 ) return false ; } return true ; }
void printNumbers ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int A = arr [ n - 1 ] , B = - 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( A % arr [ i ] != 0 ) { B = arr [ i ] ; break ; } if ( i - 1 >= 0 && arr [ i ] == arr [ i - 1 ] ) { B = arr [ i ] ; break ; } } Console . WriteLine ( "A = " + A + ", B = " + B ) ; }
void findNonPalinString ( char [ ] s ) { int [ ] freq = new int [ 26 ] ; int flag = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] != s [ 0 ] ) flag = 1 ; freq [ s [ i ] - 'a' ] ++ ; } if ( flag == 0 ) Console . WriteLine ( "-1" ) ; else { for ( int i = 0 ; i < 26 ; i ++ ) for ( int j = 0 ; j < freq [ i ] ; j ++ ) Console . Write ( ( char ) ( 'a' + i ) ) ; } }
int countDistinct ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } res ++ ; } return res ; }
int minSubarray ( int [ ] A , int n ) { int minValue = A . Min ( ) ; int maxValue = A . Max ( ) ; int pos_min = - 1 , pos_max = - 1 , ans = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] == minValue ) pos_min = i ; if ( A [ i ] == maxValue ) pos_max = i ; if ( pos_max != - 1 && pos_min != - 1 ) ans = Math . Min ( ans , Math . Abs ( pos_min - pos_max ) + 1 ) ; } return ans ; }
int countTriplets ( Node head , int x ) { Node ptr , ptr1 , ptr2 ; int count = 0 ; Dictionary < int , Node > um = new Dictionary < int , Node > ( ) ; for ( ptr = head ; ptr != null ; ptr = ptr . next ) { um . Add ( ptr . data , ptr ) ; } for ( ptr1 = head ; ptr1 != null ; ptr1 = ptr1 . next ) { for ( ptr2 = ptr1 . next ; ptr2 != null ; ptr2 = ptr2 . next ) { int p_product = ( ptr1 . data * ptr2 . data ) ; if ( um . ContainsKey ( x / p_product ) && um [ x / p_product ] != ptr1 && um [ x / p_product ] != ptr2 ) { count ++ ; } } } return ( count / 3 ) ; }
int countTriplets ( int [ ] arr , int n , int m ) { int count = 0 ; Array . Sort ( arr ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { long prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
int countTripletsLessThan ( int [ ] arr , int n , int val ) { Array . Sort ( arr ) ; int ans = 0 ; int j , k ; int sum ; for ( int i = 0 ; i < n - 2 ; i ++ ) { j = i + 1 ; k = n - 1 ; while ( j != k ) { sum = arr [ i ] + arr [ j ] + arr [ k ] ; if ( sum > val ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; }
int MaxSumDifference ( int [ ] a , int n ) { List < int > finalSequence = new List < int > ( ) ; Array . Sort ( a ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { finalSequence . Add ( a [ i ] ) ; finalSequence . Add ( a [ n - i - 1 ] ) ; } if ( n % 2 != 0 ) finalSequence . Add ( a [ n / 2 ] ) ; int MaximumSum = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { MaximumSum = MaximumSum + Math . Abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ; } MaximumSum = MaximumSum + Math . Abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ; return MaximumSum ; }
int findMinimum ( int [ ] arr , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += arr [ i ] ; n = n - k ; } return res ; }
int minSwapToReachArr ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] - 1 ) - i > 2 ) { return - 1 ; } } int numOfInversion = mergeSort ( arr , N ) ; return numOfInversion ; }
int getIndexInSortedArray ( int [ ] arr , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " " ) ; }
void gnomeSort ( int [ ] arr , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { int temp = 0 ; temp = arr [ index ] ; arr [ index ] = arr [ index - 1 ] ; arr [ index - 1 ] = temp ; index -- ; } } return ; }
void flip ( int [ ] arr , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } }
bool possible ( int x , int S , int N ) { int minSum = ( x * ( x + 1 ) ) / 2 ; int maxSum = ( x * ( ( 2 * N ) - x + 1 ) ) / 2 ; if ( S < minSum S > maxSum ) { return false ; } return true ; }
int TotalPerfectPowerSum ( long L , long R ) { List < long > pows = new List < long > ( ) ; pows . Add ( 0 ) ; pows . Add ( 1 ) ; for ( int p = 2 ; p < 25 ; p ++ ) { long num = 2 ; while ( ( long ) ( Math . Pow ( num , p ) + 0.5 ) <= R ) { pows . Add ( ( long ) ( Math . Pow ( num , p ) + 0.5 ) ) ; num ++ ; } } int [ ] ok = new int [ R + 2 ] ; for ( int i = 0 ; i < pows . Count ; i ++ ) { for ( int j = 0 ; j < pows . Count ; j ++ ) { if ( pows [ i ] + pows [ j ] <= R && pows [ i ] + pows [ j ] >= L ) { ok [ pows [ i ] + pows [ j ] ] = 1 ; } } } for ( int i = 1 ; i <= R ; i ++ ) { ok [ i ] += ok [ i - 1 ] ; } return ok [ R ] - ok [ L - 1 ] ; }
long KthSolution ( long X , long K ) { int ans = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( X & ( 1 << i ) ) == 0 ) { if ( ( K & 1 ) > 0 ) { ans |= ( 1 << i ) ; } K >>= 1 ; if ( K == 0 ) { break ; } } } return ans ; }
int countNoOfsuchX ( int N ) { int k = ( int ) ( Math . Log10 ( N ) ) + 1 ; int count = 1 ; for ( int x = ( N - ( k * ( k + 1 ) * 5 ) ) ; x <= N ; x ++ ) { if ( check ( x , N ) ) { count += 1 ; } } return count ; }
int countArrays ( int n , int k ) { List < int > [ ] divisors = new List < int > [ k + 1 ] ; for ( int i = 0 ; i < divisors . Length ; i ++ ) divisors [ i ] = new List < int > ( ) ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 2 * i ; j <= k ; j += i ) { divisors [ j ] . Add ( i ) ; } } int [ , ] dp = new int [ n + 1 , k + 1 ] ; for ( int j = 1 ; j <= k ; j ++ ) { dp [ 1 , j ] = 1 ; } int sum ; for ( int x = 2 ; x <= n ; x ++ ) { sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum += dp [ x - 1 , j ] ; } for ( int y = 1 ; y <= k ; y ++ ) { dp [ x , y ] = sum ; foreach ( int d in divisors [ y ] ) { dp [ x , y ] = ( dp [ x , y ] - dp [ x - 1 , d ] ) ; } } } sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum += dp [ n , j ] ; } return sum ; }
bool checkStar ( int [ , ] mat ) { int vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 , 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 , 0 ] == 0 && mat [ 0 , 1 ] == 1 && mat [ 1 , 0 ] == 1 && mat [ 1 , 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i , j ] == 1 ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void convertXintoY ( int X , int Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y /= 2 ; else if ( Y % 10 == 1 ) Y /= 10 ; else break ; } if ( X == Y ) Console . Write ( "Yes" ) ; else Console . Write ( "No" ) ; }
int MaxXOR ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; }
int countCandies ( int [ ] arr , int n ) { int sum = 0 ; int [ ] ans = new int [ n ] ; if ( n == 1 ) { return 1 ; } for ( int i = 0 ; i < n ; i ++ ) ans [ i ] = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i + 1 ] > arr [ i ] && ans [ i + 1 ] <= ans [ i ] ) { ans [ i + 1 ] = ans [ i ] + 1 ; } } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > arr [ i + 1 ] && ans [ i ] <= ans [ i + 1 ] ) { ans [ i ] = ans [ i + 1 ] + 1 ; } else if ( arr [ i ] == arr [ i + 1 ] && ans [ i ] < ans [ i + 1 ] ) { ans [ i ] = ans [ i + 1 ] + 1 ; } sum += ans [ i ] ; } sum += ans [ n - 1 ] ; return sum ; }
void findMinOperations ( int [ ] arr , int N , int K ) { int operations = - 1 ; for ( int i = 0 ; i < K ; i ++ ) { Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int j = i ; j < N ; j += K ) { if ( freq . ContainsKey ( arr [ j ] ) ) freq [ arr [ j ] ] ++ ; else freq . Add ( arr [ j ] , 1 ) ; } int max1 = - 1 , num = 0 ; foreach ( KeyValuePair < int , int > entry in freq ) { if ( entry . Key > max1 ) { max1 = entry . Value ; num = entry . Key ; } } foreach ( KeyValuePair < int , int > entry in freq ) { if ( entry . Key != num ) operations += entry . Value ; } } Console . Write ( operations ) ; }
void minSizeArr ( int [ ] A , int N , int K ) { int leftTaken = N , rightTaken = N ; int leftSum = 0 , rightSum = 0 ; for ( int left = - 1 ; left < N ; left ++ ) { if ( left != - 1 ) leftSum += A [ left ] ; rightSum = 0 ; for ( int right = N - 1 ; right > left ; right -- ) { rightSum += A [ right ] ; if ( leftSum + rightSum == K ) { if ( leftTaken + rightTaken > ( left + 1 ) + ( N - right ) ) { leftTaken = left + 1 ; rightTaken = N - right ; } break ; } if ( leftSum + rightSum > K ) break ; } } if ( leftTaken + rightTaken <= N ) { for ( int i = 0 ; i < leftTaken ; i ++ ) Console . Write ( A [ i ] + " " ) ; for ( int i = 0 ; i < rightTaken ; i ++ ) Console . Write ( A [ N - i - 1 ] + " " ) ; } else Console . Write ( - 1 ) ; }
bool is_prime ( long n ) { if ( n == 1 ) { return false ; } for ( long i = 2 ; i <= ( long ) Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
void consecutive_primes ( long n ) { long first = - 1 , second = - 1 ; for ( long i = ( long ) Math . Sqrt ( n ) ; i >= 2 ; i -- ) { if ( is_prime ( i ) ) { first = i ; break ; } } for ( long i = ( long ) Math . Sqrt ( n ) + 1 ; i <= n / 2 ; i ++ ) { if ( is_prime ( i ) ) { second = i ; break ; } } if ( first * second >= n ) { Console . WriteLine ( first + " " + second ) ; } else { for ( long i = second + 1 ; i <= n ; i ++ ) { if ( is_prime ( i ) ) { Console . WriteLine ( second + " " + i ) ; return ; } } } }
void arrayBitwiseAND ( int size ) { int result = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int temp = prefixCount [ i , size - 1 ] ; if ( temp == size ) result = ( result | ( 1 << i ) ) ; } Console . Write ( result + " " ) ; }
void findbitwiseAND ( int [ , ] queries , List < int > arr , int N , int M ) { findPrefixCount ( arr , N ) ; for ( int i = 0 ; i < M ; i ++ ) { int id = queries [ i , 0 ] ; int newVal = queries [ i , 1 ] ; int currentVal = arr [ id ] ; arr [ id ] = newVal ; applyQuery ( currentVal , newVal , N ) ; arrayBitwiseAND ( N ) ; } }
void stepscount ( int a , int b ) { int chanceA = 2 * a - 1 ; int chanceB = 2 * b ; if ( chanceA < chanceB ) { Console . Write ( "B" ) ; } else if ( chanceB < chanceA ) { Console . Write ( "A" ) ; } }
void checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( int ) ( Math . Pow ( ( x - h ) , 2 ) / Math . Pow ( a , 2 ) ) - ( int ) ( Math . Pow ( ( y - k ) , 2 ) / Math . Pow ( b , 2 ) ) ; if ( p > 1 ) { Console . WriteLine ( "Outside" ) ; } else if ( p == 1 ) { Console . WriteLine ( "On the Hyperbola" ) ; } else { Console . WriteLine ( "Inside" ) ; } }
void rotateString ( int n , int m , string s ) { List < int > v = new List < int > ( ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) { v . Add ( i ) ; } } for ( int i = 1 ; i < v . Count ; i ++ ) { if ( ( v [ i ] - v [ i - 1 ] - 1 ) > m ) { cnt ++ ; } } if ( v . Count >= 2 && ( n - ( v [ v . Count - 1 ] - v [ 0 ] ) - 1 ) > m ) { cnt ++ ; } if ( cnt <= 1 ) { Console . Write ( "Yes" ) ; } else { Console . Write ( "No" ) ; } }
int findNumber ( int N ) { int [ ] ans = { 1 , 2 , 4 , 8 , 7 , 5 } ; return ans [ N % 6 ] ; }
void countDecrements ( long [ , ] arr ) { int n = arr . GetLength ( 0 ) ; int m = arr . GetLength ( 1 ) ; int count_1 = 0 ; int count_2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( i + j ) % 2 == arr [ i , j ] % 2 ) count_1 ++ ; if ( 1 - ( i + j ) % 2 == arr [ i , j ] % 2 ) count_2 ++ ; } } Console . WriteLine ( Math . Min ( count_1 , count_2 ) ) ; }
void maximumIndex ( int N , int B ) { int i = 0 , j = 1 ; int cnt = 0 ; int sum = N * ( N + 1 ) / 2 ; bool flag = false ; while ( cnt < N ) { i += j ; j ++ ; cnt ++ ; if ( i == B ) { flag = true ; break ; } } if ( ! flag == true ) { Console . Write ( sum ) ; } else { Console . Write ( sum - 1 ) ; } }
int sumOfDigits ( int N ) { int sum = 0 ; while ( N != 0 ) { sum += N % 10 ; N /= 10 ; } return sum ; }
int distIntegers ( int L , int R ) { return 2 * R - 2 * L + 1 ; }
long maximumNum ( long X , long Y , long N ) { long num = 0 ; if ( N - N % X + Y <= N ) { num = N - N % X + Y ; } else { num = N - N % X - ( X - Y ) ; } return num ; }
void findKthElement ( int N , int K ) { List < int > v = new List < int > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { v . Add ( i ) ; } } for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 != 0 ) { v . Add ( i ) ; } } Console . WriteLine ( v [ K - 1 ] ) ; }
void printLargestDivisible ( int [ ] arr , int N ) { int i , count0 = 0 , count7 = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) count0 ++ ; else count7 ++ ; } if ( count7 % 50 == 0 ) { while ( count7 != 0 ) { Console . Write ( 7 ) ; count7 -= 1 ; } while ( count0 != 0 ) { Console . Write ( 0 ) ; count0 -= 1 ; } } else if ( count7 < 5 ) { if ( count0 == 0 ) Console . Write ( "No" ) ; else Console . Write ( "0" ) ; } else { count7 = count7 - count7 % 5 ; while ( count7 != 0 ) { Console . Write ( 7 ) ; count7 -= 1 ; } while ( count0 != 0 ) { Console . Write ( 0 ) ; count0 -= 1 ; } } }
int minimumStepReqArr ( int [ ] arr , int N ) { int cntStep = 0 ; N += 1 ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( ( N & ( 1 << i ) ) != 0 ) { cntStep += 1 ; } } return cntStep ; }
void minOpsToEmptyString ( string S , int N ) { int one = 0 , zero = 0 ; int x0 = 0 , x1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '0' ) { x0 ++ ; x1 = 0 ; } else { x1 ++ ; x0 = 0 ; } zero = Math . Max ( x0 , zero ) ; one = Math . Max ( x1 , one ) ; } Console . WriteLine ( Math . Max ( one , zero ) ) ; }
int findMaxValByRearrArr ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int res = 0 ; do { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += __gcd ( i + 1 , arr [ i ] ) ; } res = Math . Max ( res , sum ) ; } while ( next_permutation ( arr ) ) ; return res ; }
int cntKnightsAttackPawn ( int [ , ] knights , int [ ] pawn , int M ) { int cntKnights = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int X = Math . Abs ( knights [ i , 0 ] - pawn [ 0 ] ) ; int Y = Math . Abs ( knights [ i , 1 ] - pawn [ 1 ] ) ; if ( ( X == 1 && Y == 2 ) || ( X == 2 && Y == 1 ) ) { cntKnights ++ ; } } return cntKnights ; }
int findXOR ( int n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; } return 0 ; }
void findMinimumTime ( int [ ] p , int n , int target ) { Dictionary < int , int > um = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( um . ContainsKey ( p [ i ] ) == true ) um [ p [ i ] ] += 1 ; else um [ p [ i ] ] = 1 ; } int time = 0 ; int sum = 0 ; var val = um . Keys . ToList ( ) ; while ( sum < target ) { sum = 0 ; time ++ ; foreach ( var key in val ) { sum += um [ key ] * ( time / key ) ; } } Console . WriteLine ( time ) ; }
void isSequenceValid ( int [ ] B , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( ( i + 1 ) % B [ i ] != 0 ) { Console . WriteLine ( "No" ) ; return ; } } Console . WriteLine ( "Yes" ) ; }
void Remove_one_element ( int [ ] arr , int n ) { int post_odd = 0 , post_even = 0 ; int curr_odd = 0 , curr_even = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 != 0 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; int X = curr_odd ^ post_even ; int Y = curr_even ^ post_odd ; if ( X == Y ) res ++ ; if ( i % 2 != 0 ) curr_odd ^= arr [ i ] ; else curr_even ^= arr [ i ] ; } Console . WriteLine ( res ) ; }
int findLongestNonDecreasing ( int [ ] A , int N ) { int res = 0 ; int start = 0 ; int end = N - 1 ; int prev = - 1 ; while ( start <= end ) { if ( A [ start ] <= A [ end ] ) { if ( prev == - 1 ) { prev = A [ start ] ; res ++ ; start ++ ; } else { if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else { break ; } } } else { if ( prev == - 1 ) { prev = A [ end ] ; res ++ ; end -- ; } else { if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else { break ; } } } } return res ; }
int countPairs ( int [ ] arr , int N ) { int cntPairs = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! mp . ContainsKey ( arr [ i ] ) ) mp . Add ( arr [ i ] , 1 ) ; else mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } foreach ( KeyValuePair < int , int > freq in mp ) { cntPairs += ( freq . Value * ( freq . Value - 1 ) ) / 2 ; } return cntPairs ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int minAbsDiff ( int N ) { int sumSet1 = 0 ; int sumSet2 = 0 ; for ( int i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return Math . Abs ( sumSet1 - sumSet2 ) ; }
int countPairs ( int [ ] arr , int n ) { int oneCount = 0 ; int desiredPair = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) { oneCount ++ ; } if ( arr [ i ] == 0 ) { desiredPair += oneCount ; } } return desiredPair ; }
int TotalNumber ( int N ) { int ans = ( int ) ( ( power ( 10 , N ) - 2 * power ( 9 , N ) + power ( 8 , N ) + 2 * mod ) % mod ) ; return ans ; }
int minLength ( int [ ] A , int N ) { int elem = A [ 0 ] , count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( A [ i ] == elem ) { count ++ ; } else { break ; } } if ( count == N ) return N ; else return 1 ; }
bool NegEqu ( int N , int X , int Y ) { while ( X > 0 && ( N > N / 2 + 10 ) ) { N = N / 2 + 10 ; X -= 1 ; } while ( Y > 0 ) { N = N - 10 ; Y -= 1 ; } if ( N <= 0 ) return true ; return false ; }
int minSubarrays ( int [ ] arr , int n ) { int right = n - 1 ; int left = 0 ; int subarrays = 0 ; while ( right >= 0 ) { for ( left = 0 ; left <= right ; left += 1 ) { if ( __gcd ( arr [ left ] , arr [ right ] ) > 1 ) { subarrays += 1 ; right = left - 1 ; break ; } if ( left == right && __gcd ( arr [ left ] , arr [ right ] ) == 1 ) { return 0 ; } } } return subarrays ; }
bool check ( int [ ] arr , int N ) { int f = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { count ++ ; } } if ( count >= 2 ) { f = 1 ; break ; } } if ( f == 1 ) return true ; else return false ; }
int no_of_flips ( int n ) { int len = check_length ( n ) ; int ans = 0 ; int right = 1 ; int left = len ; while ( right < left ) { if ( check_ith_bit ( n , right ) != check_ith_bit ( n , left ) ) ans ++ ; left -- ; right ++ ; } return ans ; }
int find_max ( List < pair > v , int n ) { int count = 0 ; if ( n >= 2 ) count = 2 ; else count = 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( v [ i - 1 ] . first < ( v [ i ] . first - v [ i ] . second ) ) count ++ ; else if ( v [ i + 1 ] . first > ( v [ i ] . first + v [ i ] . second ) ) { count ++ ; v [ i ] . first = v [ i ] . first + v [ i ] . second ; } else continue ; } return count ; }
void createString ( int N ) { for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( 'a' ) ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( 'b' ) ; } }
int maxSubsequences ( int [ ] arr , int n ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; int maxCount = 0 ; int count ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . ContainsKey ( arr [ i ] ) ) { count = map [ arr [ i ] ] ; if ( count > 1 ) { map . Add ( arr [ i ] , count - 1 ) ; } else map . Remove ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) if ( map . ContainsKey ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . Add ( arr [ i ] - 1 , 1 ) ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) if ( map . ContainsKey ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . Add ( arr [ i ] - 1 , 1 ) ; } } return maxCount ; }
int sumOfFactors ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int first = i ; int last = ( N / i ) * i ; int factors = ( last - first ) / i + 1 ; int totalContribution = ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += totalContribution ; } return ans ; }
void findShifts ( int [ ] A , int N ) { int [ ] shift = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( int i = 0 ; i < N ; i ++ ) Console . Write ( shift [ i ] + " " ) ; }
bool possible ( int N , int a , int b , int n ) { int sum_of_angle = 180 * ( N - 2 ) ; int Total_angle = ( N * ( ( 2 * a ) + ( N - 1 ) * b ) ) / 2 ; if ( sum_of_angle != Total_angle ) return false ; else return true ; }
bool splitIntoFibonacciHelper ( int pos , string S , ArrayList seq ) { if ( pos == S . Length && ( seq . Count >= 3 ) ) { return true ; } long num = 0 ; for ( int i = pos ; i < S . Length ; i ++ ) { num = num * 10 + ( S [ i ] - '0' ) ; if ( num > Int64 . MaxValue ) break ; if ( S [ pos ] == '0' && i > pos ) break ; if ( seq . Count > 2 && ( num > ( ( long ) seq [ seq . Count - 1 ] + ( long ) seq [ seq . Count - 2 ] ) ) ) break ; if ( seq . Count < 2 || ( num == ( ( long ) seq [ seq . Count - 1 ] + ( long ) seq [ seq . Count - 2 ] ) ) ) { seq . Add ( num ) ; if ( splitIntoFibonacciHelper ( i + 1 , S , seq ) ) return true ; seq . Remove ( seq . Count - 1 ) ; } } return false ; }
int good_pairs ( string [ ] str , int N ) { int [ ] arr = new int [ 32 ] ; int strCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int Weight = 0 ; for ( int j = 0 ; j < str [ i ] . Length ; j ++ ) { switch ( str [ i ] [ j ] ) { case 'a' : Weight = Weight | 1 ; break ; case 'e' : Weight = Weight | 2 ; break ; case 'i' : Weight = Weight | 4 ; break ; case 'o' : Weight = Weight | 8 ; break ; case 'u' : Weight = Weight | 16 ; break ; } } arr [ Weight ] ++ ; } for ( int i = 0 ; i < 32 ; i ++ ) { for ( int j = i + 1 ; j < 32 ; j ++ ) { if ( ( i j ) == 31 ) strCount += arr [ i ] * arr [ j ] ; } } strCount += ( arr [ 31 ] * ( arr [ 31 ] - 1 ) ) / 2 ; return strCount ; }
void countUniqueDigits ( int N ) { int res = 0 ; int [ ] cnt = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; while ( N > 0 ) { int rem = N % 10 ; cnt [ rem ] ++ ; N = N / 10 ; } for ( int i = 0 ; i < cnt . Length ; i ++ ) { if ( cnt [ i ] == 1 ) { res ++ ; } } Console . WriteLine ( res ) ; }
void DFS ( int node , int parent ) { answer [ node ] = val [ node ] ; foreach ( int child in v [ node ] ) { if ( child == parent ) continue ; DFS ( child , node ) ; answer [ node ] = gcd ( answer [ node ] , answer [ child ] ) ; } }
int count_triangles ( int a , int b , int c , int d ) { int ans = 0 ; for ( int x = a ; x <= b ; ++ x ) { int num_greater_than_d = Math . Max ( d , c + x ) - Math . Max ( d , b + x - 1 ) ; ans += num_greater_than_d * ( d - c + 1 ) ; int r = Math . Min ( Math . Max ( c , c + x ) , d ) - c ; int l = Math . Min ( Math . Max ( c , b + x - 1 ) , d ) - c ; int x1 = ( r * ( r + 1 ) ) / 2 ; int x2 = ( l * ( l + 1 ) ) / 2 ; ans += x1 - x2 ; } return ans ; }
int maxRemainingSum ( int [ ] arr , int n ) { int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; i = 0 ; int j = n - 1 ; int result = 0 ; while ( i < j ) { if ( arr [ i ] < arr [ j ] ) { sum -= arr [ i ] ; i ++ ; } else { sum -= arr [ j ] ; j -- ; } result += sum ; } return result ; }
bool check ( int [ ] arr , int n ) { bool flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < n - i ) { flag = false ; } } if ( flag ) { return true ; } else { return false ; } }
int minOperations ( int [ ] a , int [ ] b , int n ) { int minA = a . Max ( ) ; for ( int x = minA ; x >= 0 ; x -- ) { bool check = true ; int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = false ; break ; } } if ( check ) return operations ; } return - 1 ; }
int largestNum ( int n ) { int num = 0 ; for ( int i = 0 ; i <= 32 ; i ++ ) { int x = ( 1 << i ) ; if ( ( x - 1 ) <= n ) num = ( 1 << i ) - 1 ; else break ; } return num ; }
int digit_xor ( int x ) { int xorr = 0 ; while ( x > 0 ) { xorr ^= x % 10 ; x = x / 10 ; } return xorr ; }
int maxSum ( int [ ] a , int n ) { int S = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) S += a [ i ] ; int X = maxSubArraySum ( a , n ) ; return 2 * X - S ; }
void Transform ( int n , int d , int steps ) { if ( n < min_val ) { min_val = n ; min_steps = steps ; } else if ( n == min_val ) { min_steps = Math . Min ( min_steps , steps ) ; } if ( steps < 15 ) { Transform ( sumOfDigits ( n ) , d , steps + 1 ) ; Transform ( n + d , d , steps + 1 ) ; } }
void addEdge ( List < int > [ ] adj , int u , int v ) { adj [ u ] . Add ( v ) ; adj [ v ] . Add ( u ) ; }
int minCost ( int [ ] cost , int n ) { int totalCost = 0 ; int boardingBus = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; }
int findK ( int n , int k ) { int pos ; if ( n % 2 == 0 ) { pos = n / 2 ; } else { pos = ( n / 2 ) + 1 ; } if ( k <= pos ) { return ( k * 2 - 1 ) ; } else return ( ( k - pos ) * 2 ) ; }
int max_bitwise_or ( int L , int R ) { List < int > v1 = new List < int > ( ) , v2 = new List < int > ( ) , v3 = new List < int > ( ) ; int z = 0 , i , ans = 0 , cnt = 1 ; while ( L > 0 ) { v1 . Add ( L % 2 ) ; L = L / 2 ; } while ( R > 0 ) { v2 . Add ( R % 2 ) ; R = R / 2 ; } while ( v1 . Count != v2 . Count ) { v1 . Add ( 0 ) ; } for ( i = v2 . Count - 1 ; i >= 0 ; i -- ) { if ( v2 [ i ] == 1 && v1 [ i ] == 0 && z == 0 ) { z = 1 ; continue ; } if ( z == 1 ) { v1 . RemoveAt ( i ) ; v1 . Insert ( i , 1 ) ; } } for ( i = 0 ; i < v2 . Count ; i ++ ) { v3 . Add ( v2 [ i ] v1 [ i ] ) ; } for ( i = 0 ; i < v2 . Count ; i ++ ) { if ( v3 [ i ] == 1 ) { ans += cnt ; } cnt *= 2 ; } return ans ; }
int ncr ( int n , int r , int mod ) { long res = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { res = ( res * ( n - i + 1 ) ) % mod ; int inv = power ( i , mod - 2 , mod ) ; res = ( res * inv ) % mod ; } return ( int ) ( res % mod ) ; }
int solve ( int [ ] array , int N ) { int [ , ] pos = new int [ 5 , 10000 ] ; int [ ] pref = new int [ 5 ] ; if ( array [ 0 ] == 0 ) { pref [ 0 ] = 1 ; pos [ 0 , pos . GetLength ( 0 ) - 1 ] = 0 ; } int ans = MAX_INT ; for ( int i = 1 ; i < N ; i ++ ) { if ( array [ i ] == 0 ) { pref [ 0 ] ++ ; pos [ 0 , pos . GetLength ( 0 ) - 1 ] = i ; } else { if ( pref [ array [ i ] - 1 ] > 0 ) { pref [ array [ i ] ] ++ ; pos [ array [ i ] , pos . GetLength ( 1 ) - 1 ] = i ; if ( array [ i ] == 4 ) { int end = i ; int start = i ; for ( int j = 3 ; j >= 0 ; j -- ) { int s = 0 ; int e = pos . GetLength ( 1 ) - 1 ; int temp = - 1 ; while ( s <= e ) { int m = ( s + e ) / 2 ; if ( pos [ j , m ] <= start ) { temp = pos [ j , m ] ; s = m + 1 ; } else e = m - 1 ; } start = temp ; } ans = Math . Min ( ans , end - start + 1 ) ; } } } } return ans ; }
List < int > solve ( int X , List < int > A ) { int min = int . MaxValue ; int ind = - 1 ; for ( int i = 0 ; i < A . Count ; i ++ ) { if ( A [ i ] < min ) { min = A [ i ] ; ind = i ; } } int maxIndChosen = X / min ; List < int > ans = new List < int > ( ) ; if ( maxIndChosen == 0 ) { return ans ; } for ( int i = 0 ; i < maxIndChosen ; i ++ ) { ans . Add ( ind ) ; } int temp = maxIndChosen ; int sum = maxIndChosen * A [ ind ] ; for ( int i = 0 ; i < ind ; i ++ ) { if ( sum - X == 0 temp == 0 ) break ; while ( ( sum - A [ ind ] + A [ i ] ) <= X && temp != 0 ) { ans . RemoveAt ( 0 ) ; ans . Add ( i ) ; temp -- ; sum += ( A [ i ] - A [ ind ] ) ; } } ans . Sort ( ) ; return ans ; }
bool CheckForSequence ( int [ ] arr , int n , int k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( k >= arr [ i ] ) k -= arr [ i ] ; } if ( k != 0 ) return false ; else return true ; }
int reverse ( int n ) { int rev = 0 ; while ( n != 0 ) { rev = ( rev * 10 ) + ( n % 10 ) ; n /= 10 ; } return rev ; }
int countJumps ( int n ) { n = Math . Abs ( n ) ; int ans = 0 ; while ( getsum ( ans ) < n || ( ( getsum ( ans ) - n ) & 1 ) > 0 ) ans ++ ; return ans ; }
int steps ( int cur , int x , int n ) { if ( x == 0 ) return int . MaxValue ; if ( x > 0 ) return Math . Abs ( ( n - cur ) / x ) ; else return Math . Abs ( ( cur - 1 ) / x ) ; }
void find_rectangle ( int area ) { int l = 0 , b = 0 ; int M = ( int ) Math . Sqrt ( area ) ; for ( int i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = ( area / i ) ; b = i ; break ; } } Console . WriteLine ( "l = " + l + ", b = " + b ) ; }
int countMinSwaps ( string st ) { int min_swaps = 0 ; int odd_0 = 0 , even_0 = 0 ; int odd_1 = 0 , even_1 = 0 ; int n = st . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( st [ i ] == '1' ) { even_1 ++ ; } else { even_0 ++ ; } } else { if ( st [ i ] == '1' ) { odd_1 ++ ; } else { odd_0 ++ ; } } } int cnt_swaps_1 = Math . Min ( even_0 , odd_1 ) ; int cnt_swaps_2 = Math . Min ( even_1 , odd_0 ) ; return Math . Min ( cnt_swaps_1 , cnt_swaps_2 ) ; }
int problemsLeft ( int K , int P , int N ) { if ( K <= P ) return 0 ; else return ( ( K - P ) * N ) ; }
bool isCorrectOrder ( int n ) { bool flag = true ; int prev = - 1 ; int type = - 1 ; while ( n != 0 ) { if ( type == - 1 ) { if ( prev == - 1 ) { prev = n % 10 ; n = n / 10 ; continue ; } if ( prev == n % 10 ) { flag = false ; break ; } if ( prev > n % 10 ) { type = 1 ; prev = n % 10 ; n = n / 10 ; continue ; } prev = n % 10 ; n = n / 10 ; } else { if ( prev == n % 10 ) { flag = false ; break ; } if ( prev < n % 10 ) { flag = false ; break ; } prev = n % 10 ; n = n / 10 ; } } return flag ; }
int maxDifference ( int [ ] arr , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; int temp ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . Max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
int MinimumRemovals ( int [ ] a , int N , int K ) { int [ ] b = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { b [ i + 1 ] = a [ i ] ; } int [ , ] dp = new int [ N + 1 , N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { dp [ i + 1 , j ] = Math . Max ( dp [ i + 1 , j ] , dp [ i , j ] ) ; dp [ i + 1 , j + 1 ] = Math . Max ( dp [ i + 1 , j + 1 ] , dp [ i , j ] + ( ( b [ i + 1 ] == j + 1 ) ? 1 : 0 ) ) ; } } for ( int j = N ; j >= 0 ; j -- ) { if ( dp [ N , j ] >= K ) { return ( N - j ) ; } } return - 1 ; }
int countOfNumbers ( int digit , int mask , int repeated , int n ) { if ( digit == n + 1 ) { if ( repeated == 1 ) { return 1 ; } return 0 ; } if ( repeated == 1 ) { return ( int ) Math . Pow ( 10 , n - digit + 1 ) ; } int val = dp [ digit , mask , repeated ] ; if ( val != - 1 ) { return val ; } val = 0 ; if ( digit == 1 ) { for ( int i = ( n == 1 ? 0 : 1 ) ; i <= 9 ; ++ i ) { if ( ( mask & ( 1 << i ) ) > 0 ) { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 1 , n ) ; } else { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 0 , n ) ; } } } else { for ( int i = 0 ; i <= 9 ; ++ i ) { if ( ( mask & ( 1 << i ) ) > 0 ) { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 1 , n ) ; } else { val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 0 , n ) ; } } } return val ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
void maxBoundary ( int N , List < Tuple < int , int > > V ) { int [ , ] dp = new int [ N , 2 ] ; dp [ 0 , 0 ] = V [ 0 ] . Item1 ; dp [ 0 , 1 ] = V [ 0 ] . Item2 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i , 0 ] = V [ i ] . Item1 ; int height1 = Math . Abs ( V [ i - 1 ] . Item2 - V [ i ] . Item2 ) ; int height2 = Math . Abs ( V [ i - 1 ] . Item1 - V [ i ] . Item2 ) ; dp [ i , 0 ] += Math . Max ( height1 + dp [ i - 1 , 0 ] , height2 + dp [ i - 1 , 1 ] ) ; dp [ i , 1 ] = V [ i ] . Item2 ; int vertical1 = Math . Abs ( V [ i ] . Item1 - V [ i - 1 ] . Item2 ) ; int vertical2 = Math . Abs ( V [ i ] . Item1 - V [ i - 1 ] . Item1 ) ; dp [ i , 1 ] += Math . Max ( vertical1 + dp [ i - 1 , 0 ] , vertical2 + dp [ i - 1 , 1 ] ) ; } Console . WriteLine ( Math . Max ( dp [ N - 1 , 0 ] , dp [ N - 1 , 1 ] ) ) ; }
int findMinOperations ( int n ) { int i ; int [ ] dp = new int [ n + 1 ] ; for ( i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = 999999 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i < n + 1 ; i ++ ) { if ( i * 5 <= n ) { dp [ i * 5 ] = Math . Min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= n ) { dp [ i + 3 ] = Math . Min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } return dp [ n ] ; }
int solve ( int [ ] A , int N , int K ) { int sum = 0 ; int c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( A [ i ] == 0 ) c ++ ; } if ( ( K > sum ) || ( ( ( sum + K ) % 2 ) != 0 ) ) return 0 ; sum = ( sum + K ) / 2 ; int [ , ] dp = new int [ N + 1 , sum + 1 ] ; for ( int i = 0 ; i <= sum ; i ++ ) dp [ 0 , i ] = 0 ; for ( int i = 0 ; i <= N ; i ++ ) dp [ i , 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( ( A [ i - 1 ] <= j ) && ( A [ i - 1 ] != 0 ) ) dp [ i , j ] = dp [ i - 1 , j ] + dp [ i - 1 , j - A [ i - 1 ] ] ; else dp [ i , j ] = dp [ i - 1 , j ] ; } } return dp [ N , sum ] + ( int ) Math . Pow ( 2 , c ) ; }
int countSortedArrays ( int start , int m , int size , int n ) { if ( size == m ) return 1 ; if ( start > n ) return 0 ; int notTaken = 0 , taken = 0 ; taken = countSortedArrays ( start , m , size + 1 , n ) ; notTaken = countSortedArrays ( start + 1 , m , size , n ) ; return taken + notTaken ; }
int getValue ( int [ ] arr , int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { int min = arr [ i ] ; int max = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { min = Math . Min ( arr [ j ] , min ) ; max = Math . Max ( arr [ j ] , max ) ; dp [ i ] = Math . Max ( dp [ i ] , max - min + ( ( j >= 1 ) ? dp [ j - 1 ] : 0 ) ) ; } } return dp [ N - 1 ] ; }
int maxScore ( string s , int [ ] a ) { if ( dp . ContainsKey ( s ) ) return dp [ s ] ; int n = s . Length ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; int head = 0 ; int mx = - 1 ; while ( head < n ) { int tail = head ; while ( tail < n ) { if ( s [ tail ] != s [ head ] ) { head = tail ; break ; } string sub = s . Substring ( head , tail + 1 - head ) ; mx = Math . Max ( mx , a [ sub . Length - 1 ] + maxScore ( s . Substring ( 0 , head ) + s . Substring ( tail + 1 , s . Length - tail - 1 ) , a ) ) ; tail += 1 ; } if ( tail == n ) break ; } dp . Add ( s , mx ) ; return mx ; }
int minSumDifference ( int [ ] arr , int n , int k1 , int k2 , int sum1 , int sum2 ) { if ( n < 0 ) { if ( k1 == 0 && k2 == 0 ) { return Math . Abs ( sum1 - sum2 ) ; } else { return Int32 . MaxValue ; } } if ( dp [ n , sum1 , sum2 ] != - 1 ) { return dp [ n , sum1 , sum2 ] ; } int op1 = Int32 . MaxValue ; int op2 = Int32 . MaxValue ; int op3 = Int32 . MaxValue ; if ( k1 > 0 ) { op1 = minSumDifference ( arr , n - 1 , k1 - 1 , k2 , sum1 + arr [ n ] , sum2 ) ; } if ( k2 > 0 ) { op2 = minSumDifference ( arr , n - 1 , k1 , k2 - 1 , sum1 , sum2 + arr [ n ] ) ; } op3 = minSumDifference ( arr , n - 1 , k1 , k2 , sum1 , sum2 ) ; dp [ n , sum1 , sum2 ] = Math . Min ( op1 , Math . Min ( op2 , op3 ) ) ; return dp [ n , sum1 , sum2 ] ; }
void insertVector ( int mask ) { for ( int i = 0 ; i < 20 ; i ++ ) { if ( ( mask & 1 << i ) == 0 ) continue ; if ( dp [ i ] == 0 ) { dp [ i ] = mask ; ++ ans ; return ; } mask ^= dp [ i ] ; } }
int cntNumRange ( int L , int R , int K ) { int cnt = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( prodOfDigit ( i ) == K ) { cnt ++ ; } } return cnt ; }
void findSubtreeORUtil ( int N , int [ , ] Edges , int [ ] Val , int [ ] Queries , int Q ) { AddEdgesToGraph ( Edges , N ) ; findSubtreeOR ( Queries , Q , Val ) ; }
int findMinimum ( int [ ] arr , int N , int pos , int turn ) { Tuple < int , int > x = new Tuple < int , int > ( pos , turn ) ; if ( m . ContainsKey ( x ) ) { return m [ x ] ; } if ( pos >= N - 1 ) { return 0 ; } if ( turn == 0 ) { int ans = Math . Min ( findMinimum ( arr , N , pos + 1 , 1 ) + arr [ pos ] , findMinimum ( arr , N , pos + 2 , 1 ) + arr [ pos ] + arr [ pos + 1 ] ) ; Tuple < int , int > v = new Tuple < int , int > ( pos , turn ) ; m [ v ] = ans ; return ans ; } if ( turn != 0 ) { int ans = Math . Min ( findMinimum ( arr , N , pos + 1 , 0 ) , findMinimum ( arr , N , pos + 2 , 0 ) ) ; Tuple < int , int > v = new Tuple < int , int > ( pos , turn ) ; m [ v ] = ans ; return ans ; } return 0 ; }
int countVowelStrings ( int n ) { return countstrings ( n , 0 ) ; }
void maxSum ( int [ , ] arr , int n , int m ) { int [ , ] dp = new int [ n , m + 1 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i , j ] = 0 ; } } dp [ 0 , m - 1 ] = arr [ 0 , m - 1 ] ; dp [ 1 , m - 1 ] = arr [ 1 , m - 1 ] ; for ( int j = m - 2 ; j >= 0 ; j -- ) { for ( int i = 0 ; i < 2 ; i ++ ) { if ( i == 1 ) { dp [ i , j ] = Math . Max ( arr [ i , j ] + dp [ 0 , j + 1 ] , arr [ i , j ] + dp [ 0 , j + 2 ] ) ; } else { dp [ i , j ] = Math . Max ( arr [ i , j ] + dp [ 1 , j + 1 ] , arr [ i , j ] + dp [ 1 , j + 2 ] ) ; } } } Console . WriteLine ( Math . Max ( dp [ 0 , 0 ] , dp [ 1 , 0 ] ) ) ; }
int findMaxGCD ( int [ ] arr , int N ) { int high = 0 ; for ( int i = 0 ; i < N ; i ++ ) { high = Math . Max ( high , arr [ i ] ) ; } int [ ] count = new int [ high + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { count [ arr [ i ] ] += 1 ; } int counter = 0 ; for ( int i = high ; i > 0 ; i -- ) { int j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } return 0 ; }
int findLCS ( int [ ] nums , int N ) { int k = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int pos = LowerBound ( nums , k , nums [ i ] ) ; nums [ pos ] = nums [ i ] ; if ( k == pos ) { k = pos + 1 ; } } return k ; }
bool check ( int mask , int i ) { int c = ( mask & ( 1 << i ) ) ; return c != 0 ; }
int minSteps ( int m , int n ) { if ( n == m ) return 0 ; if ( m > n ) return inf ; int min_cost = inf ; for ( int i = 2 ; i < m ; i += 2 ) { if ( m % i == 0 ) { min_cost = Math . Min ( min_cost , m / i + minSteps ( m + i , n ) ) ; } } return min_cost ; }
void checkEqualSum ( int [ ] arr , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { Console . Write ( "Yes" ) ; } else { Console . Write ( "No" ) ; } }
void queries_fxn ( int [ , ] matrix , int [ , ] queries ) { for ( int i = 0 ; i < queries . GetLength ( 0 ) ; i ++ ) manipulation ( matrix , GetRow ( queries , i ) ) ; }
void countNums ( int N ) { int [ , ] dp = new int [ N , 16 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 0 , i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { for ( int k = 0 ; k < 16 ; k ++ ) { int xor = j ^ k ; dp [ i , xor ] += dp [ i - 1 , k ] ; } } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ N - 1 , i ] ; Console . Write ( count ) ; }
int constructSTUtil ( int [ ] arr , int ss , int se , int [ ] st , int si ) { if ( ss == se ) { if ( prime [ arr [ ss ] ] != 0 ) st [ si ] = arr [ ss ] ; else st [ si ] = 0 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ; return st [ si ] ; }
void dfs ( int a , int par ) { bool leaf = true ; foreach ( Tuple < int , int > i in v [ a ] ) { if ( i . Item1 == par ) continue ; leaf = false ; dfs ( i . Item1 , a ) ; } if ( leaf == true ) { leaves [ a ] += 1 ; } else { foreach ( Tuple < int , int > i in v [ a ] ) { if ( i . Item1 == par ) continue ; leaves [ a ] += leaves [ i . Item1 ] ; dp [ a ] = ( dp [ a ] + dp [ i . Item1 ] + leaves [ i . Item1 ] * i . Item2 ) ; } } }
long getCount ( int n , int k ) { if ( n == 1 ) return 10 ; long [ ] dp = new long [ 11 ] ; long [ ] next = new long [ 11 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { int l = Math . Max ( 0 , j - k ) ; int r = Math . Min ( 9 , j + k ) ; next [ l ] += dp [ j ] ; next [ r + 1 ] -= dp [ j ] ; } for ( int j = 1 ; j <= 9 ; j ++ ) next [ j ] += next [ j - 1 ] ; for ( int j = 0 ; j < 10 ; j ++ ) { dp [ j ] = next [ j ] ; next [ j ] = 0 ; } } long count = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) count += dp [ i ] ; return count ; }
int nCrModp ( int n , int r ) { if ( n % 2 == 1 ) { return - 1 ; } int [ ] C = new int [ r + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % MOD ; } return C [ r ] ; }
void findResult ( int [ ] arr , int n , Query [ ] q , int m ) { for ( int i = 0 ; i < m ; i ++ ) { Console . Write ( findResultUtil ( arr , q [ i ] . L , q [ i ] . R ) + " " ) ; } }
void insert ( int idx , String s , TrieNode root ) { TrieNode temp = root ; for ( int i = idx ; i < s . Length ; i ++ ) { if ( temp . child [ s [ i ] - 'a' ] == null ) temp . child [ s [ i ] - 'a' ] = new TrieNode ( ) ; temp = temp . child [ s [ i ] - 'a' ] ; } }
int minCuts ( String S1 , String S2 ) { int n1 = S1 . Length ; int n2 = S2 . Length ; TrieNode root = new TrieNode ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) { insert ( i , S2 , root ) ; } int [ ] dp = new int [ n1 + 1 ] ; for ( int i = 0 ; i <= n1 ; i ++ ) dp [ i ] = INF ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { TrieNode temp = root ; for ( int j = i + 1 ; j <= n1 ; j ++ ) { if ( temp . child [ S1 [ j - 1 ] - 'a' ] == null ) break ; dp [ j ] = Math . Min ( dp [ j ] , dp [ i ] + 1 ) ; temp = temp . child [ S1 [ j - 1 ] - 'a' ] ; } } if ( dp [ n1 ] >= INF ) return - 1 ; else return dp [ n1 ] ; }
int maximum ( int A , int B , int C , int D ) { return Math . Max ( Math . Max ( A , B ) , Math . Max ( C , D ) ) ; }
void maxSubarraySum ( List < List < int > > graph , int vertices , List < int > values ) { bool [ ] visited = new bool [ 1001 ] ; int maxSum = - 1000000 ; for ( int i = 1 ; i <= vertices ; i ++ ) { if ( visited [ i ] == false ) { int sizeChain ; int tempSum ; List < int > storeChain = new List < int > ( ) ; depthFirst ( i , graph , visited , storeChain ) ; sizeChain = storeChain . Count ; int [ ] chainValues = new int [ sizeChain + 1 ] ; for ( int j = 0 ; j < sizeChain ; j ++ ) { int temp = values [ storeChain [ j ] - 1 ] ; chainValues [ j ] = temp ; } tempSum = subarraySum ( chainValues , sizeChain ) ; if ( tempSum > maxSum ) { maxSum = tempSum ; } } } Console . Write ( "Maximum subarray sum among all " ) ; Console . Write ( "connected components = " ) ; Console . Write ( maxSum ) ; }
int countDecodingDP ( String digits , int n ) { if ( digits [ 0 ] == '0' ) { return 0 ; } int count0 = 1 , count1 = 1 , count2 ; for ( int i = 2 ; i <= n ; i ++ ) { int dig1 = 0 , dig2 , dig3 = 0 ; if ( digits [ i - 1 ] != '0' ) { dig1 = 1 ; } if ( digits [ i - 2 ] == '1' ) { dig2 = 1 ; } else dig2 = 0 ; if ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) { dig3 = 1 ; } count2 = dig1 * count1 + dig2 + dig3 * count0 ; count0 = count1 ; count1 = count2 ; } return count1 ; }
int countSubMatrix ( int [ , ] mtrx , int k , int p ) { int [ , ] dp = new int [ dim , dim ] ; for ( int i = 0 ; i < dim ; i ++ ) { for ( int j = 0 ; j < dim ; j ++ ) { dp [ i , j ] = 0 ; } } createTable ( mtrx , k , p , dp ) ; return countSubMatrixUtil ( dp , k , p ) ; }
int f ( int n , int k ) { if ( n < k ) return 0 ; if ( n == k ) return 1 ; if ( k == 1 ) return 1 ; if ( dp [ n , k ] != - 1 ) return dp [ n , k ] ; return dp [ n , k ] = ( ( k * f ( n - 1 , k ) ) % mod + ( f ( n - 1 , k - 1 ) ) % mod ) % mod ; }
bool checkPrime ( String number ) { int num = Int32 . Parse ( number ) ; for ( int i = 2 ; i * i <= num ; i ++ ) if ( ( num % i ) == 0 ) return false ; return true ; }
int countNumbers ( int n , int k ) { int st = 1 ; int i ; for ( i = 0 ; i <= n ; i ++ ) { powers [ i ] = st ; st *= 10 ; st %= mod ; } st = 1 ; for ( i = 0 ; i <= n ; i ++ ) { powersModk [ i ] = st ; st *= 10 ; st %= mod ; } for ( i = 0 ; i < 1005 ; i ++ ) { for ( int j = 0 ; j < 105 ; j ++ ) { for ( int l = 0 ; l < 2 ; l ++ ) dp [ i , j , l ] = - 1 ; } } return calculate ( 0 , 0 , 0 , k , n ) ; }
int maxSum ( int p0 , int p1 , int [ ] a , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = Math . Max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = Math . Max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; }
int maxSum ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int limit = 2 * sum + 1 ; int [ , ] dp = new int [ n + 1 , limit ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) dp [ i , j ] = INT_MIN ; } dp [ 0 , sum ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) { if ( ( j - a [ i - 1 ] ) >= 0 && dp [ i - 1 , j - a [ i - 1 ] ] != INT_MIN ) dp [ i , j ] = Math . Max ( dp [ i , j ] , dp [ i - 1 , j - a [ i - 1 ] ] + a [ i - 1 ] ) ; if ( ( j + a [ i - 1 ] ) < limit && dp [ i - 1 , j + a [ i - 1 ] ] != INT_MIN ) dp [ i , j ] = Math . Max ( dp [ i , j ] , dp [ i - 1 , j + a [ i - 1 ] ] ) ; if ( dp [ i - 1 , j ] != INT_MIN ) dp [ i , j ] = Math . Max ( dp [ i , j ] , dp [ i - 1 , j ] ) ; } } return dp [ n , sum ] ; }
int minSteps ( string str , int n , int k ) { if ( str [ n - 1 ] == '0' ) return - 1 ; if ( n == 1 ) return 0 ; if ( n < 4 ) return 1 ; int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 0 ; dp [ n - 2 ] = 1 ; dp [ n - 3 ] = 1 ; for ( int i = n - 4 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) continue ; int steps = INT_MAX ; if ( i + k < n && str [ i + k ] == '1' ) steps = Math . Min ( steps , dp [ i + k ] ) ; if ( str [ i + 1 ] == '1' ) steps = Math . Min ( steps , dp [ i + 1 ] ) ; if ( str [ i + 2 ] == '1' ) steps = Math . Min ( steps , dp [ i + 2 ] ) ; dp [ i ] = ( steps == INT_MAX ) ? steps : 1 + steps ; } if ( dp [ 0 ] == INT_MAX ) return - 1 ; return dp [ 0 ] ; }
int eggDrop ( int n , int k ) { int [ , ] dp = new int [ k + 1 , n + 1 ] ; int x = 0 ; while ( dp [ x , n ] < k ) { x ++ ; for ( int i = 1 ; i <= n ; i ++ ) dp [ x , i ] = dp [ x - 1 , i - 1 ] + dp [ x - 1 , i ] + 1 ; } return x ; }
void findMax ( int [ ] a , int n ) { int [ , ] dp = new int [ n , 2 ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) dp [ i , j ] = 0 ; dp [ 0 , 0 ] = a [ 0 ] + a [ 1 ] ; dp [ 0 , 1 ] = a [ 0 ] * a [ 1 ] ; for ( i = 1 ; i <= n - 2 ; i ++ ) { dp [ i , 0 ] = Math . Max ( dp [ i - 1 , 0 ] , dp [ i - 1 , 1 ] ) + a [ i + 1 ] ; dp [ i , 1 ] = dp [ i - 1 , 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] ; } Console . WriteLine ( Math . Max ( dp [ n - 2 , 0 ] , dp [ n - 2 , 1 ] ) ) ; }
double expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] == 1 ) return dp [ x ] ; v [ x ] = 1 ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; }
int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 1 ; else return 0 ; } if ( v [ i , curr ] ) return dp [ i , curr ] ; v [ i , curr ] = true ; return dp [ i , curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; }
int ways ( int [ ] arr , int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; }
double Probability ( double [ ] p , int n ) { double [ , ] dp = new double [ n + 1 , n + 1 ] ; dp [ 0 , 0 ] = 1.0 ; for ( int i = 1 ; i <= n ; i += 1 ) { for ( int j = 0 ; j <= i ; j += 1 ) { if ( j == 0 ) dp [ i , j ] = dp [ i - 1 , j ] * ( 1.0 - p [ i ] ) ; else dp [ i , j ] = dp [ i - 1 , j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 , j - 1 ] * p [ i ] ; } } double ans = 0.0 ; for ( int i = ( n + 1 ) / 2 ; i <= n ; i += 1 ) ans += dp [ n , i ] ; return ans ; }
int count_required_sequence ( int n , int [ ] arr ) { int total_required_subsequence = 0 ; int total_n_required_subsequence = 0 ; int [ , ] dp = new int [ N , 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { int turn_required = 0 ; for ( int j = - 1 ; j <= 1 ; j ++ ) turn_required += dp [ arr [ i ] + j , 0 ] ; int required_end_i = ( total_required_subsequence + turn_required ) ; int n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) ; total_required_subsequence += required_end_i ; total_n_required_subsequence += n_required_end_i ; dp [ arr [ i ] , 1 ] += required_end_i ; dp [ arr [ i ] , 0 ] += n_required_end_i ; } return total_required_subsequence ; }
int recur ( int u , int [ ] array , int n ) { if ( u == 0 ) return 0 ; if ( dp [ u ] != - 1 ) return dp [ u ] ; for ( int i = 0 ; i < n ; i ++ ) { int mask = get_binary ( array [ i ] ) ; if ( ( mask u ) == u ) { dp [ u ] = Math . Max ( Math . Max ( 0 , dp [ u ^ mask ] ) + array [ i ] , dp [ u ] ) ; } } return dp [ u ] ; }
int solve ( int [ ] array , int n ) { for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { dp [ i ] = - 1 ; } int ans = 0 ; for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { ans = Math . Max ( ans , recur ( i , array , n ) ) ; } return ans ; }
int MinDiff ( int i , int sum , int [ ] arr , int n ) { if ( i == n ) return 0 ; if ( visit [ i , sum + MAX ] > 0 ) return dp [ i , sum + MAX ] ; visit [ i , sum + MAX ] = 1 ; dp [ i , sum + MAX ] = RetClose ( arr [ i ] + MinDiff ( i + 1 , sum + arr [ i ] , arr , n ) , MinDiff ( i + 1 , sum , arr , n ) , - 1 * sum ) ; return dp [ i , sum + MAX ] ; }
int minSteps ( int [ ] arr , int i , int mask , int n ) { if ( i == n - 1 ) { return 0 ; } if ( i > n - 1 i < 0 ) { return 9999999 ; } if ( ( mask >> i ) % 2 == 1 ) { return 9999999 ; } if ( v [ i , mask ] ) { return dp [ i , mask ] ; } v [ i , mask ] = true ; dp [ i , mask ] = 1 + Math . Min ( minSteps ( arr , i - arr [ i ] , ( mask | ( 1 << i ) ) , n ) , minSteps ( arr , i + arr [ i ] , ( mask | ( 1 << i ) ) , n ) ) ; return dp [ i , mask ] ; }
int maxSumPath ( int i1 , int j1 , int i2 ) { int j2 = i1 + j1 - i2 ; if ( i1 >= n i2 >= >= >= ) { return 0 ; } if ( cache [ i1 , j1 , i2 ] != - 1 ) { return cache [ i1 , j1 , i2 ] ; } int ans = int . MinValue ; ans = Math . Max ( ans , maxSumPath ( i1 + 1 , j1 , i2 + 1 ) + sum ( i1 , j1 , i2 , j2 ) ) ; ans = Math . Max ( ans , maxSumPath ( i1 , j1 + 1 , i2 ) + sum ( i1 , j1 , i2 , j2 ) ) ; ans = Math . Max ( ans , maxSumPath ( i1 , j1 + 1 , i2 + 1 ) + sum ( i1 , j1 , i2 , j2 ) ) ; ans = Math . Max ( ans , maxSumPath ( i1 + 1 , j1 , i2 ) + sum ( i1 , j1 , i2 , j2 ) ) ; cache [ i1 , j1 , i2 ] = ans ; return ans ; }
void pre_process ( bool [ , ] dp , char [ ] s ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i , j ] = false ; } } for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i , i + j - 1 ] = true ; } } else if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i , i + j - 1 ] = dp [ i + 1 , i + j - 2 ] ; } } } }
int maxSum ( int [ ] a , int n ) { int ans = 0 ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; int [ , ] dp = new int [ n + 1 , 3 ] ; for ( int i = 1 ; i <= n ; ++ i ) { dp [ i , 0 ] = Math . Max ( arr [ i ] , dp [ i - 1 , 0 ] + arr [ i ] ) ; dp [ i , 1 ] = Math . Max ( 0 , dp [ i - 1 , 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i , 1 ] = Math . Max ( dp [ i , 1 ] , dp [ i - 1 , 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i , 2 ] = dp [ i - 1 , 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i , 2 ] = Math . Max ( dp [ i , 2 ] , dp [ i - 1 , 2 ] + arr [ i ] ) ; ans = Math . Max ( ans , dp [ i , 0 ] ) ; ans = Math . Max ( ans , dp [ i , 1 ] ) ; ans = Math . Max ( ans , dp [ i , 2 ] ) ; } return ans ; }
long sumEvenFactors ( int L , int R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; }
int numberOfWays ( int x , int y , int z ) { binomialCoeff ( Math . Max ( x , Math . Max ( y , z ) ) ) ; int sum = 0 ; for ( int i = 1 ; i <= z ; i ++ ) { sum = ( sum + C [ z , i ] ) ; } int sum1 = 0 ; for ( int i = 1 ; i <= y ; i ++ ) { for ( int j = i + 1 ; j <= x ; j ++ ) { sum1 = ( sum1 + ( C [ y , i ] * C [ x , j ] ) ) ; } } sum1 = ( sum * sum1 ) ; return sum1 ; }
int findMaxSubarraySum ( int [ ] a , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < k + 1 ; j ++ ) dp [ i , j ] = - 1 ; int ans = - ( int ) 1e9 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . Max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ; if ( ans == 0 && k == 0 ) return a . Max ( ) ; return ans ; }
int count ( int pos , int even , int odd , int tight , List < int > num ) { if ( pos == num . Count ) { if ( ( num . Count & 1 ) != 0 ) { int t = odd ; odd = even ; even = t ; } int d = even - odd ; for ( int i = 0 ; i < 24 ; i ++ ) if ( d == prime [ i ] ) return 1 ; return 0 ; } if ( dp [ pos , even , odd , tight ] != - 1 ) return dp [ pos , even , odd , tight ] ; int ans = 0 ; int limit = ( tight != 0 ? 9 : num [ pos ] ) ; for ( int d = 0 ; d <= limit ; d ++ ) { int currF = tight , currEven = even ; int currOdd = odd ; if ( d < num [ pos ] ) currF = 1 ; if ( ( pos & 1 ) != 0 ) currOdd += d ; else currEven += d ; ans += count ( pos + 1 , currEven , currOdd , currF , num ) ; } return dp [ pos , even , odd , tight ] = ans ; }
int maxWeight ( int [ ] arr , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i , w1_r , w2_r ] != - 1 ) return dp [ i , w1_r , w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i , w1_r , w2_r ] = Math . Max ( fill_none , Math . Max ( fill_w1 , fill_w2 ) ) ; return dp [ i , w1_r , w2_r ] ; }
int solve ( int x ) { List < int > num = new List < int > ( ) ; while ( x != 0 ) { num . Add ( x % 10 ) ; x /= 10 ; } num . Reverse ( ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < 165 ; j ++ ) for ( int k = 0 ; k < M ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) dp [ i , j , k , l ] = - 1 ; return count ( 0 , 0 , 0 , 0 , 0 , num ) ; }
void factorial ( int k ) { fac [ 0 ] = 1 ; for ( int i = 1 ; i <= k + 1 ; i ++ ) { fac [ i ] = ( i * fac [ i - 1 ] ) ; } }
int MaxProfit ( int [ ] treasure , int [ ] color , int n , int k , int col , int A , int B ) { return dp [ k , col ] = 0 ; if ( dp [ k , col ] != - 1 ) return dp [ k , col ] ; int sum = 0 ; if ( col == color [ k ] ) sum += Math . Max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . Max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k , col ] = sum ; }
int maxCost ( int [ ] a , int n , int l , int r ) { int mx = 0 , k ; for ( int i = 0 ; i < n ; ++ i ) mx = Math . Max ( mx , a [ i ] ) ; int [ ] count = new int [ mx + 1 ] ; for ( int i = 0 ; i < count . Length ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int [ ] res = new int [ mx + 1 ] ; res [ 0 ] = 0 ; l = Math . Min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { k = Math . Max ( num - l - 1 , 0 ) ; res [ num ] = Math . Max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; }
void alternateFib ( int n ) { if ( n < 0 ) return ; int f1 = 0 ; int f2 = 1 ; Console . Write ( f1 + " " ) ; for ( int i = 2 ; i <= n ; i ++ ) { int f3 = f2 + f1 ; if ( i % 2 == 0 ) Console . Write ( f3 + " " ) ; f1 = f2 ; f2 = f3 ; } }
int findSDSFunc ( int n ) { int [ ] DP = new int [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }
int findInd ( int key , int i , int n , int k , int [ ] arr ) { int start , end , mid , ind = - 1 ; start = i + 1 ; end = n - 1 ; while ( start < end ) { mid = start + ( end - start ) / 2 ; if ( arr [ mid ] - key <= k ) { ind = mid ; start = mid + 1 ; } else { end = mid ; } } return ind ; }
void Combination ( int [ ] a , int [ ] combi , int n , int r , int depth , int index ) { if ( index == r ) { int product = 1 ; for ( int i = 0 ; i < r ; i ++ ) product = product * combi [ i ] ; sum += product ; return ; } for ( int i = depth ; i < n ; i ++ ) { combi [ index ] = a [ i ] ; Combination ( a , combi , n , r , i + 1 , index + 1 ) ; } }
int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
int lobb ( int n , int m ) { return ( ( 2 * m + 1 ) * binomialCoeff ( 2 * n , m + n ) ) / ( m + n + 1 ) ; }
int numberofways ( String A , String B , int N , int M ) { List < int > [ ] pos = new List < int > [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) pos [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < M ; i ++ ) pos [ B [ i ] ] . Add ( i + 1 ) ; int [ , ] dpl = new int [ N + 2 , M + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i , j ] = dpl [ i - 1 , j - 1 ] + 1 ; else dpl [ i , j ] = Math . Max ( dpl [ i - 1 , j ] , dpl [ i , j - 1 ] ) ; } } int LCS = dpl [ N , M ] ; int [ , ] dpr = new int [ N + 2 , M + 2 ] ; for ( int i = N ; i >= 1 ; i -- ) { for ( int j = M ; j >= 1 ; j -- ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i , j ] = dpr [ i + 1 , j + 1 ] + 1 ; else dpr [ i , j ] = Math . Max ( dpr [ i + 1 , j ] , dpr [ i , j + 1 ] ) ; } } int ans = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { foreach ( int x in pos [ j ] ) { if ( dpl [ i , x - 1 ] + dpr [ i + 1 , x + 1 ] == LCS ) { ans ++ ; break ; } } } } return ans ; }
void precompute ( string s , int n , int [ , ] l , int [ , ] r ) { l [ s [ 0 ] - 'a' , 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < MAX_CHAR ; j ++ ) l [ j , i ] += l [ j , i - 1 ] ; l [ s [ i ] - 'a' , i ] ++ ; } r [ s [ n - 1 ] - 'a' , n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < MAX_CHAR ; j ++ ) r [ j , i ] += r [ j , i + 1 ] ; r [ s [ i ] - 'a' , i ] ++ ; } }
int maxSum ( int [ , ] mat , int n ) { if ( n == 1 ) return mat [ 0 , 0 ] ; int [ , ] dp = new int [ n , n ] ; int maxSum = int . MinValue , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 , j ] = mat [ n - 1 , j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = int . MinValue ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 , j - 1 ] ) ) max = dp [ i + 1 , j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 , j + 1 ] ) ) max = dp [ i + 1 , j + 1 ] ; dp [ i , j ] = mat [ i , j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 , j ] ) maxSum = dp [ 0 , j ] ; return maxSum ; }
int minJump ( int [ , ] height , int x , int y ) { if ( x == 4 - 1 && y == 3 - 1 ) return 0 ; int diag = int . MaxValue ; if ( isSafe ( x + 1 , y + 1 ) ) diag = minJump ( height , x + 1 , y + 1 ) + Math . Abs ( height [ x , y ] - height [ x + 1 , y + 1 ] ) ; int down = int . MaxValue ; if ( isSafe ( x + 1 , y ) ) down = minJump ( height , x + 1 , y ) + Math . Abs ( height [ x , y ] - height [ x + 1 , y ] ) ; int right = int . MaxValue ; if ( isSafe ( x , y + 1 ) ) right = minJump ( height , x , y + 1 ) + Math . Abs ( height [ x , y ] - height [ x , y + 1 ] ) ; return Math . Min ( down , Math . Min ( right , diag ) ) ; }
int numberOfWays ( int x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
int minRemove ( int [ ] arr , int n ) { int [ ] LIS = new int [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . Max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . Max ( len , LIS [ i ] ) ; } return n - len ; }
int smallestSumSubarr ( int [ ] arr , int n ) { int min_ending_here = 2147483647 ; int min_so_far = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . Min ( min_so_far , min_ending_here ) ; } return min_so_far ; }
int baseconversion ( int [ ] arr , int num , int bas ) { int i = 0 , rem ; if ( num == 0 ) { return 0 ; } while ( num > 0 ) { rem = num % bas ; arr [ i ++ ] = rem ; num /= bas ; } return i ; }
int ans ( int n ) { if ( n < 6 ) { return n ; } return n % 6 + 10 * ( ans ( n / 6 ) ) ; }
int nonDecNums ( int n ) { int [ , ] a = new int [ n + 1 , 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 , i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i , 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i , j ] = a [ i - 1 , j ] + a [ i , j + 1 ] ; return a [ n , 0 ] ; }
int LAS ( int [ ] arr , int n ) { int inc = 1 ; int dec = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) { inc = dec + 1 ; } else if ( arr [ i ] < arr [ i - 1 ] ) { dec = inc + 1 ; } } return Math . Max ( inc , dec ) ; }
int lps ( String str ) { int n = str . Length ; int [ , ] L = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) L [ i , i ] = 1 ; for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( str [ i ] == str [ j ] && cl == 2 ) L [ i , j ] = 2 ; else if ( str [ i ] == str [ j ] ) L [ i , j ] = L [ i + 1 , j - 1 ] + 2 ; else L [ i , j ] = Math . Max ( L [ i , j - 1 ] , L [ i + 1 , j ] ) ; } } return L [ 0 , n - 1 ] ; }
int largestZigZagSumRec ( int [ , ] mat , int i , int j , int n ) { if ( i == n - 1 ) return mat [ i , j ] ; int zzs = 0 ; for ( int k = 0 ; k < n ; k ++ ) if ( k != j ) zzs = Math . Max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) ; return zzs + mat [ i , j ] ; }
int largestZigZag ( int [ , ] mat , int n ) { int res = 0 ; for ( int j = 0 ; j < n ; j ++ ) res = Math . Max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) ; return res ; }
int MaxDotProduct ( int [ ] A , int [ ] B , int m , int n ) { int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= m ; j ++ ) dp [ i , j ] = Math . Max ( ( dp [ i - 1 , j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i , j - 1 ] ) ; return dp [ n , m ] ; }
int unboundedKnapsack ( int W , int n , int [ ] val , int [ ] wt ) { int [ ] dp = new int [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( wt [ j ] <= i ) { dp [ i ] = Math . Max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ; } } } return dp [ W ] ; }
int countSubarray ( int [ ] arr , int n , int k ) { int s = 0 ; int i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } int count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } s += ( ( count * ( count + 1 ) ) / 2 ) ; } return ( n * ( n + 1 ) / 2 - s ) ; }
int CountPS ( char [ ] str , int n ) { int [ ] [ ] dp = RectangularArrays . ReturnRectangularIntArray ( n , n ) ; bool [ ] [ ] P = RectangularArrays . ReturnRectangularBoolArray ( n , n ) ; for ( int i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { P [ i ] [ i + 1 ] = true ; dp [ i ] [ i + 1 ] = 1 ; } } for ( int gap = 2 ; gap < n ; gap ++ ) { for ( int i = 0 ; i < n - gap ; i ++ ) { int j = gap + i ; if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) { P [ i ] [ j ] = true ; } if ( P [ i ] [ j ] == true ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } } } return dp [ 0 ] [ n - 1 ] ; }
int breakSum ( int n ) { if ( n == 0 n == 1 ) return n ; return Math . Max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; }
int findMinSum ( int [ ] arr , int n ) { int [ ] sum = new int [ n ] ; sum [ 0 ] = arr [ 0 ] ; sum [ 1 ] = arr [ 1 ] ; sum [ 2 ] = arr [ 2 ] ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = arr [ i ] + minimum ( sum [ i - 3 ] , sum [ i - 2 ] , sum [ i - 1 ] ) ; return minimum ( sum [ n - 1 ] , sum [ n - 2 ] , sum [ n - 3 ] ) ; }
int minAdjustmentCost ( int [ ] A , int n , int target ) { int [ , ] dp = new int [ n , M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 , j ] = Math . Abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i , j ] = int . MaxValue ; int k = Math . Max ( j - target , 0 ) ; for ( ; k <= Math . Min ( M , j + target ) ; k ++ ) dp [ i , j ] = Math . Min ( dp [ i , j ] , dp [ i - 1 , k ] + Math . Abs ( A [ i ] - j ) ) ; } } int res = int . MaxValue ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . Min ( res , dp [ n - 1 , j ] ) ; return res ; }
int countWays ( int p , int q , int r , int last ) { if ( p < 0 q < 0 r < 0 ) return 0 ; if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ; if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ; if ( last == 0 ) return countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ; if ( last == 1 ) return countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; if ( last == 2 ) return countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; return 0 ; }
int countP ( int n , int k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }
int countP ( int n , int k ) { int [ , ] dp = new int [ n + 1 , k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 , k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) if ( j == 1 i == j ) dp [ i , j ] = 1 ; else dp [ i , j ] = j * dp [ i - 1 , j ] + dp [ i - 1 , j - 1 ] ; return dp [ n , k ] ; }
bool has4 ( int x ) { while ( x != 0 ) { if ( x % 10 == 4 ) return true ; x = x / 10 ; } return false ; }
int findMaxforN ( Node root , int N ) { if ( root == null ) return - 1 ; if ( root . key == N ) return N ; else if ( root . key < N ) { int k = findMaxforN ( root . right , N ) ; if ( k == - 1 ) return root . key ; else return k ; } else if ( root . key > N ) return findMaxforN ( root . left , N ) ; return - 1 ; }
int findMinInsertionsDP ( char [ ] str , int n ) { int [ , ] table = new int [ n , n ] ; int l , h , gap ; for ( gap = 1 ; gap < n ; ++ gap ) for ( l = 0 , h = gap ; h < n ; ++ l , ++ h ) table [ l , h ] = ( str [ l ] == str [ h ] ) ? table [ l + 1 , h - 1 ] : ( Math . Min ( table [ l , h - 1 ] , table [ l + 1 , h ] ) + 1 ) ; return table [ 0 , n - 1 ] ; }
int distanceBetween2 ( Node root , int a , int b ) { if ( root == null ) return 0 ; if ( root . key > a && root . key > b ) return distanceBetween2 ( root . left , a , b ) ; if ( root . key < a && root . key < b ) return distanceBetween2 ( root . right , a , b ) ; if ( root . key >= a && root . key <= b ) return distanceFromRoot ( root , a ) + distanceFromRoot ( root , b ) ; return 0 ; }
int eggDrop ( int n , int k ) { int [ , ] eggFloor = new int [ n + 1 , k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i , 1 ] = 1 ; eggFloor [ i , 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 , j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i , j ] = int . MaxValue ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 , x - 1 ] , eggFloor [ i , j - x ] ) ; if ( res < eggFloor [ i , j ] ) eggFloor [ i , j ] = res ; } } } return eggFloor [ n , k ] ; }
bool getCountUtil ( node root , int low , int high , INT count ) { if ( root == null ) return true ; bool l = getCountUtil ( root . left , low , high , count ) ; bool r = getCountUtil ( root . right , low , high , count ) ; if ( l && r && inRange ( root , low , high ) ) { ++ count . a ; return true ; } return false ; }
int ksmallestElementSum ( Node root , int k ) { int res = ksmallestElementSumRec ( root , k ) ; return res ; }
void findOccurrences ( String S , String T ) { int n1 = S . Length ; int n2 = T . Length ; int ans = 0 ; int last = 0 ; for ( int i = 0 ; i <= n1 - n2 ; i ++ ) { bool chk = true ; for ( int j = 0 ; j < n2 ; j ++ ) { if ( T [ j ] != S [ i + j ] ) { chk = false ; break ; } } if ( chk ) { ans += ( i + 1 - last ) * ( n1 - ( i + n2 - 1 ) ) ; last = i + 1 ; } } Console . WriteLine ( ans ) ; }
int countTimes ( int [ ] arr , int K ) { int N = ( int ) arr . Length ; if ( N == 1 ) return 1 ; if ( N < 3 ) return 0 ; if ( N == 3 ) { int cnt = 0 ; cnt += ( Math . Abs ( arr [ 0 ] - arr [ 1 ] ) == K ? 1 : 0 ) + ( Math . Abs ( arr [ 2 ] - arr [ 1 ] ) == K ? 1 : 0 ) + ( Math . Abs ( arr [ 0 ] - arr [ 2 ] ) == K ? 1 : 0 ) ; return cnt ; } int [ ] prefix = new int [ N + 2 ] ; int [ ] suffix = new int [ N + 2 ] ; for ( int i = 0 ; i < N + 2 ; i ++ ) { prefix [ i ] = 0 ; } for ( int i = 0 ; i < N + 2 ; i ++ ) { suffix [ i ] = 0 ; } prefix [ 0 ] = arr [ 0 ] ; prefix [ 1 ] = arr [ 1 ] ; suffix [ N - 1 ] = arr [ N - 1 ] ; suffix [ N - 2 ] = arr [ N - 2 ] ; for ( int i = 2 ; i < N ; i += 2 ) { prefix [ i ] = arr [ i ] + prefix [ i - 2 ] ; } for ( int i = 3 ; i < N ; i += 2 ) { prefix [ i ] = arr [ i ] + prefix [ i - 2 ] ; } for ( int i = N - 3 ; i >= 0 ; i -= 2 ) { suffix [ i ] = arr [ i ] + suffix [ i + 2 ] ; } for ( int i = N - 4 ; i >= 0 ; i -= 2 ) { suffix [ i ] = arr [ i ] + suffix [ i + 2 ] ; } int count = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( Math . Abs ( prefix [ i - 1 ] + suffix [ i + 2 ] - prefix [ i - 2 ] - suffix [ i + 1 ] ) == K ) { count ++ ; } } count += findCount0th ( arr , N , K ) ; count += findCount1st ( arr , N , K ) ; return count ; }
void LargestArray ( int N , int low , int high ) { int high_index = N - ( high - low + 1 ) ; if ( high_index > ( N - 1 ) / 2 ) { Console . Write ( "Not Possible" ) ; return ; } if ( high_index <= 0 ) high_index = 1 ; int [ ] A = new int [ N ] ; int temp = high ; for ( int i = high_index ; i >= 0 ; i -- ) { A [ i ] = temp -- ; } high -= 1 ; for ( int i = high_index + 1 ; i < N ; i ++ ) A [ i ] = high -- ; for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( A [ i ] + " " ) ; } }
int OddLengthSum ( int [ ] arr ) { int sum = 0 ; int l = arr . Length ; for ( int i = 0 ; i < l ; i ++ ) { sum += ( ( ( i + 1 ) * ( l - i ) + 1 ) / 2 ) * arr [ i ] ; } return sum ; }
int SpiralElement ( int x , int y ) { int r ; if ( x < y ) { if ( y % 2 == 1 ) { r = y * y ; return ( r - x + 1 ) ; } else { r = ( y - 1 ) * ( y - 1 ) ; return ( r + x ) ; } } else { if ( x % 2 == 0 ) { r = x * x ; return ( r - y + 1 ) ; } else { r = ( x - 1 ) * ( x - 1 ) ; return ( r + y ) ; } } }
bool checkprefix ( int A , int B ) { String s1 = A . ToString ( ) ; String s2 = B . ToString ( ) ; int n1 = s1 . Length ; int n2 = s2 . Length ; if ( n1 < n2 ) { return false ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { return false ; } } return true ; }
int Count ( int i ) { if ( i == 0 ) return 1 ; else if ( i < 0 ) return 0 ; if ( a [ i ] == 0 ) { a [ i ] = ( i + 1 ) + 2 * Count ( i - 1 ) ; return a [ i ] ; } else return a [ i ] ; }
int printOddFactorNumber ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) { if ( ( i > 0 ) && ( ( i & ( i - 1 ) ) != 0 ) ) Console . Write ( i + " " ) ; } return 0 ; }
void stateC ( string n ) { Console . Write ( "string accepted" ) ; }
int findDistinctSums ( int n ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { s . Add ( i + j ) ; } } return s . Count ; }
void check_string_exist ( String S ) { int size = S . Length ; bool check = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( S [ i ] != S [ ( i + 2 ) % size ] ) { check = false ; break ; } } if ( check ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
int nthTerm ( int N ) { int nth = 0 , first_term = 12 ; nth = ( int ) ( ( first_term * ( Math . Pow ( 2 , N - 1 ) ) ) + 11 * ( ( Math . Pow ( 2 , N - 1 ) ) - 1 ) ) ; return nth ; }
bool isVowel ( char ch ) { switch ( ch ) { case 'a' : case 'e' : case 'i' : case 'o' : case 'u' : return true ; } return false ; }
int KMPSearch ( char [ ] pat , char [ ] txt ) { int M = pat . Length ; int N = txt . Length ; int [ ] lps = new int [ M ] ; computeLPSArray ( pat , M , lps ) ; int i = 0 ; int j = 0 ; while ( i < N ) { if ( pat [ j ] == txt [ i ] ) { j ++ ; i ++ ; } if ( j == M ) { return i - j ; } else if ( i < N && pat [ j ] != txt [ i ] ) { if ( j != 0 ) j = lps [ j - 1 ] ; else i = i + 1 ; } } return 0 ; }
bool checkSequence ( String a , String b ) { if ( b . Length == 0 ) return true ; if ( a . Length == 0 ) return false ; if ( a [ 0 ] == b [ 0 ] ) return checkSequence ( a . Substring ( 1 ) , b . Substring ( 1 ) ) ; else return checkSequence ( a . Substring ( 1 ) , b ) ; }
int getCount ( String a , String b ) { if ( b . Length % a . Length != 0 ) return - 1 ; int count = b . Length / a . Length ; String str = "" ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str . Equals ( b ) ) return count ; return - 1 ; }
bool isVowel ( char c ) { string vowel = "aeiou" ; for ( int i = 0 ; i < vowel . Length ; ++ i ) { if ( vowel [ i ] == c ) { return true ; } } return false ; }
int calc ( int l , int r , string s ) { if ( Math . Abs ( r - l ) % 2 == 0 ) { return 0 ; } if ( l > r ) { return dp [ l , r ] = 1 ; } if ( dp [ l , r ] != - 1 ) { return dp [ l , r ] ; } if ( ( r - l ) == 1 ) { if ( s [ l ] == s [ r ] ) { dp [ l , r ] = 1 ; } else { dp [ l , r ] = 0 ; } return dp [ l , r ] ; } int ans = 0 ; for ( int k = l + 1 ; k <= r ; k += 2 ) { int temp = 1 ; if ( s [ l ] == s [ k ] ) { temp = calc ( l + 1 , k - 1 , s ) * calc ( k + 1 , r , s ) * choose [ ( r - l + 1 ) / 2 , ( r - k ) / 2 ] ; ans += temp ; } } return dp [ l , r ] = ans ; }
int number_of_tower ( int [ ] house , int range , int n ) { Array . Sort ( house ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
int minimumFlips ( String s ) { int n = s . Length ; int cnt0 = count ( s , '0' ) ; int cnt1 = 0 ; int res = n - cnt0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) { cnt0 -= 1 ; } else if ( s [ i ] == '1' ) { res = Math . Min ( res , cnt1 + cnt0 ) ; cnt1 ++ ; } } return res ; }
char KthCharacter ( string s , string t , long k ) { long f = 1 ; long ss = 2 ; string tmp = "" ; int len = tmp . Length ; while ( len < k ) { long tf = f ; long ts = ss ; while ( tf -- != 0 ) { tmp += s ; } while ( ts -- != 0 ) { tmp += t ; } f += 2 ; ss += 2 ; len = tmp . Length ; } char output = tmp [ ( int ) k - 1 ] ; return output ; }
int fact ( int n ) { int ans = 1 ; for ( int i = 2 ; i <= n ; i ++ ) ans = ans * i ; return ans ; }
string checkIfPossible ( int N , string [ ] arr , string T ) { int [ ] freqS = new int [ 256 ] ; int [ ] freqT = new int [ 256 ] ; foreach ( char ch in T . ToCharArray ( ) ) { freqT [ ch - 'a' ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { foreach ( char ch in arr [ i ] . ToCharArray ( ) ) { freqS [ ch - 'a' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freqT [ i ] == 0 && freqS [ i ] != 0 ) { return "No" ; } else if ( freqS [ i ] == 0 && freqT [ i ] != 0 ) { return "No" ; } else if ( freqT [ i ] != 0 && freqS [ i ] != ( freqT [ i ] * N ) ) { return "No" ; } } return "Yes" ; }
void findSubstringInWraproundString ( string p ) { int ans = 0 ; int curLen = 0 ; int [ ] arr = new int [ 26 ] ; for ( int i = 0 ; i < ( int ) p . Length ; i ++ ) { int curr = p [ i ] - 'a' ; if ( i > 0 && ( p [ i - 1 ] != ( ( curr + 26 - 1 ) % 26 + 'a' ) ) ) { curLen = 0 ; } curLen ++ ; if ( curLen > arr [ curr ] ) { ans += ( curLen - arr [ curr ] ) ; arr [ curr ] = curLen ; } } Console . Write ( ans ) ; }
void update ( int [ , ] BIT , int idx , int i , int val ) { while ( i < 10005 ) { BIT [ idx , i ] += val ; i = i + ( i & ( - i ) ) ; } }
int fact ( int a ) { int i , f = 1 ; for ( i = 2 ; i <= a ; i ++ ) f = f * i ; return f ; }
int maxLength ( ArrayList arr ) { ArrayList tmp = helper ( arr , 0 ) ; int len = 0 ; for ( int i = 0 ; i < tmp . Count ; i ++ ) { len = len > ( ( string ) tmp [ i ] ) . Length ? len : ( ( string ) tmp [ i ] ) . Length ; } return len ; }
long polynomialRollingHash ( String str ) { int p = 31 ; int m = ( int ) ( 1e9 + 9 ) ; long power_of_p = 1 ; long hash_val = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { hash_val = ( hash_val + ( str [ i ] - 'a' + 1 ) * power_of_p ) % m ; power_of_p = ( power_of_p * p ) % m ; } return hash_val ; }
bool isPalindrome ( string str ) { int l = 0 ; int h = str . Length - 1 ; while ( h > l ) { if ( str [ l ] != str [ h ] ) { return false ; } l ++ ; h -- ; } return true ; }
bool checkPalindrome ( ) { int oddCnt = 0 ; foreach ( int x in freq ) { if ( x % 2 == 1 ) oddCnt ++ ; } return oddCnt <= 1 ; }
int countSubstrings ( string str , int K ) { int N = str . Length ; int answer = 0 ; Dictionary < char , int > map = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < K ; i ++ ) { if ( ! map . ContainsKey ( str [ i ] ) ) { map [ str [ i ] ] = 1 ; } else { map [ str [ i ] ] ++ ; } } if ( map . Count == K ) answer ++ ; for ( int i = K ; i < N ; i ++ ) { if ( ! map . ContainsKey ( str [ i ] ) ) { map [ str [ i ] ] = 1 ; } else { map [ str [ i ] ] ++ ; } map [ str [ i - K ] ] -- ; if ( map [ str [ i - K ] ] == 0 ) { map . Remove ( str [ i - K ] ) ; } if ( map . Count == K ) { answer ++ ; } } return answer ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
void moveAtEnd ( string s , int i , int l ) { if ( i >= l ) return ; char curr = s [ i ] ; if ( curr != 'x' ) Console . Write ( curr ) ; moveAtEnd ( s , i + 1 , l ) ; if ( curr == 'x' ) Console . Write ( curr ) ; return ; }
void kthString ( int n , int k ) { int total = 0 ; int i = 1 ; while ( total < k ) { total = total + n - i ; i ++ ; } int first_y_position = i - 1 ; int second_y_position = k - ( total - n + first_y_position ) ; int j ; for ( j = 1 ; j < first_y_position ; j ++ ) Console . Write ( "x" ) ; Console . Write ( "y" ) ; j = first_y_position + 1 ; while ( second_y_position > 1 ) { Console . Write ( "x" ) ; second_y_position -- ; j ++ ; } Console . Write ( "y" ) ; while ( j < n ) { Console . Write ( "x" ) ; j ++ ; } }
void check ( string str ) { if ( checkIfStartsWithCapital ( str ) == 1 ) Console . WriteLine ( "Accepted" ) ; else Console . WriteLine ( "Not Accepted" ) ; }
void compressString ( string s , int n ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ s [ i ] - 'a' ] ++ ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == 0 ) continue ; Console . Write ( ( char ) ( i + 'a' ) + "" + freq [ i ] ) ; } }
int binaryDec ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }
int findLength ( string s , int k ) { int ans = INT_MAX ; int l = 0 ; int r = 0 ; int cnt_zero = 0 , cnt_one = 0 ; while ( l < s . Length && r <= s . Length ) { if ( cnt_zero >= k && cnt_one >= 1 ) { ans = Math . Min ( ans , r - l ) ; l ++ ; if ( s [ l - 1 ] == '0' ) cnt_zero -- ; else cnt_one -- ; } else { if ( r == s . Length ) break ; if ( s [ r ] == '0' ) cnt_zero ++ ; else cnt_one ++ ; r ++ ; } } if ( ans == INT_MAX ) return - 1 ; return ans ; }
int cntSplits ( String s ) { if ( s [ s . Length - 1 ] == '1' ) return - 1 ; int ans = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) ans += ( s [ i ] == '0' ) ? 1 : 0 ; return ans ; }
void findMinSubStr ( String [ ] arr , int n , String str ) { for ( int i = 0 ; i < n ; i ++ ) uSet . Add ( arr [ i ] ) ; findSubStr ( str , 0 , 0 ) ; }
void printChar ( String str , int n ) { int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - 'a' ] % 2 == 0 ) { Console . Write ( str [ i ] ) ; } } }
int find_digit ( String s , int n ) { int first_digit = - 1 , i ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] < '0' s [ i ] > '9' ) { first_digit = i ; break ; } } first_digit ++ ; int s_len = first_digit ; int num = 0 , pw = 1 ; i = n - 1 ; while ( i >= 0 ) { if ( s [ i ] >= '0' && s [ i ] <= '9' ) { int digit = s [ i ] - '0' ; num = num + ( pw * digit ) ; if ( num >= s_len ) return - 1 ; pw = pw * 10 ; } i -- ; } num = num * 10 ; int req = s_len - num ; if ( req > 9 req < 0 ) return - 1 ; return req ; }
int countSubString ( string s , char c , int k ) { int leftCount = 0 , rightCount = 0 ; int left = 0 , right = 0 ; int freq = 0 ; int result = 0 , len = s . Length ; while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } right = left + 1 ; while ( freq != ( k - 1 ) && ( right - 1 ) < len ) { if ( s [ right ] == c ) freq ++ ; right ++ ; } while ( left < len && ( right - 1 ) < len ) { while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } while ( right < len && s [ right ] != c ) { if ( s [ right ] == c ) freq ++ ; right ++ ; rightCount ++ ; } result = result + ( leftCount + 1 ) * ( rightCount + 1 ) ; freq = k - 1 ; leftCount = 0 ; rightCount = 0 ; left ++ ; right ++ ; } return result ; }
int minOperations ( int n , string a , string b , string c ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char x = a [ i ] ; char y = b [ i ] ; char z = c [ i ] ; if ( x == y && y == z ) { ; } else if ( x == y y == == z ) { ans ++ ; } else { ans += 2 ; } } return ans ; }
void preCalculate ( string s , int [ , ] prefix ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ i , s [ i ] - 'a' ] ++ ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) prefix [ i , j ] += prefix [ i - 1 , j ] ; } }
bool check ( String s , int l ) { List < int > pos = new List < int > ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '1' ) { pos . Add ( i ) ; } } int t = pos . Count ; for ( int i = 1 ; i < t ; i ++ ) { if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) return false ; } return true ; }
int [ ] compute_lps ( string s ) { int n = s . Length ; int [ ] lps = new int [ n ] ; int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = lps [ len - 1 ] ; else { lps [ i ] = 0 ; i ++ ; } } } return lps ; }
void printLastChar ( string str ) { str = str + " " ; for ( int i = 1 ; i < str . Length ; i ++ ) { if ( str [ i ] == ' ' ) Console . Write ( str [ i - 1 ] + " " ) ; } }
int getMinimizedSum ( string str , int len ) { int i , maxVal = Int32 . MinValue , sum = 0 ; int [ ] occurrences = new int [ 26 ] ; for ( i = 0 ; i < len ; i ++ ) { occurrences [ str [ i ] - 'a' ] ++ ; sum += ( int ) str [ i ] ; } for ( i = 0 ; i < 26 ; i ++ ) maxVal = Math . Max ( maxVal , occurrences [ i ] * ( i + 'a' ) ) ; return ( sum - maxVal ) ; }
int substrDeletion ( string str , int len ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) count0 ++ ; else count1 ++ ; } return Math . Min ( count0 , count1 ) ; }
void printString ( char [ ] str , int n ) { int ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) ones ++ ; bool used = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '2' && ! used ) { used = true ; for ( int j = 0 ; j < ones ; j ++ ) Console . Write ( "1" ) ; } if ( str [ i ] != '1' ) Console . Write ( str [ i ] ) ; } if ( ! used ) for ( int j = 0 ; j < ones ; j ++ ) Console . Write ( "1" ) ; }
char Colour_Combination ( string s ) { char temp = s [ 0 ] ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == 'B' temp == 'G' ) && ( s [ i ] == 'G' s [ i ] == 'B' ) ) temp = 'Y' ; else if ( ( temp == 'B' temp == 'Y' ) && ( s [ i ] == 'Y' s [ i ] == 'B' ) ) temp = 'G' ; else temp = 'B' ; } } return temp ; }
void reverse ( string str , int x ) { int n = ( str . Length - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( str [ i ] ) ; for ( int i = n + x - 1 ; i >= n ; i -- ) Console . Write ( str [ i ] ) ; for ( int i = n + x ; i < str . Length ; i ++ ) Console . Write ( str [ i ] ) ; }
int countSubStrings ( String str , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) count += subStringsStartingHere ( str , n , i ) ; } return count ; }
int maxFreq ( string s , int a , int b ) { int [ ] fre = new int [ 10 ] ; int n = s . Length ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } for ( int i = 0 ; i < n ; i ++ ) fre [ s [ i ] - '0' ] ++ ; if ( fre [ a ] == 0 && fre [ b ] == 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; }
void sumProdOfPrimeFreq ( char [ ] s ) { int i ; bool [ ] prime = new bool [ s . Length + 1 ] ; for ( i = 0 ; i < s . Length + 1 ; i ++ ) { prime [ i ] = true ; } SieveOfEratosthenes ( prime , s . Length + 1 ) ; Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; for ( i = 0 ; i < s . Length ; i ++ ) { if ( mp . ContainsKey ( s [ i ] ) ) { var val = mp [ s [ i ] ] ; mp . Remove ( s [ i ] ) ; mp . Add ( s [ i ] , val + 1 ) ; } else { mp . Add ( s [ i ] , 1 ) ; } } int sum = 0 , product = 1 ; foreach ( KeyValuePair < char , int > it in mp ) { if ( prime [ it . Value ] ) { sum += it . Value ; product *= it . Value ; } } Console . Write ( "Sum = " + sum ) ; Console . WriteLine ( "Product=" }
void StringMatch ( String s ) { int lo = 0 , hi = s . Length , len = s . Length ; List < int > ans = new List < int > ( ) ; for ( int x = 0 ; x < len ; x ++ ) { if ( s [ x ] == 'I' ) { ans . Add ( lo ) ; lo += 1 ; } else { ans . Add ( hi ) ; hi -= 1 ; } } ans . Add ( lo ) ; Console . Write ( "[" ) ; for ( int i = 0 ; i < ans . Count ; i ++ ) { Console . Write ( ans [ i ] ) ; if ( i != ans . Count - 1 ) Console . Write ( "," ) ; } Console . Write ( "]" ) ; }
int CountCharacters ( string str , int l , int r ) { int cnt = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( l <= str [ i ] && str [ i ] <= r ) { cnt ++ ; Console . Write ( str [ i ] + " " ) ; } } return cnt ; }
int countPermutations ( String str ) { int even = ( int ) Math . Floor ( ( double ) ( str . Length / 2 ) ) ; int odd = str . Length - even ; int ways = 0 ; int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < str . Length ; i ++ ) { freq [ ( int ) ( str [ i ] - 'a' ) ] ++ ; } int nvowels = freq [ 0 ] + freq [ 4 ] + freq [ 8 ] + freq [ 14 ] + freq [ 20 ] ; int nconsonants = str . Length - nvowels ; ways = npr ( odd , nvowels ) * npr ( nconsonants , nconsonants ) ; return ways ; }
bool isVowel ( char ch ) { if ( ch != 'a' && ch != 'e' && ch != 'i' && ch != 'o' && ch != 'u' ) { return false ; } return true ; }
int maxLength ( string s , int n ) { int right = 0 , left = 0 ; int coun = 0 , max_length = int . MinValue ; s = s + '1' ; for ( int i = 0 ; i <= n ; i ++ ) { if ( s [ i ] == 'o' ) coun ++ ; else { if ( coun > max_length ) { right = 0 ; left = 0 ; if ( s [ i ] == 'x' ) right = 1 ; if ( ( ( i - coun ) > 0 ) && ( s [ i - coun - 1 ] == 'x' ) ) left = 1 ; coun = ( int ) Math . Ceiling ( ( double ) coun / ( right + left ) ) ; max_length = Math . Max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; }
bool is_possible ( String s ) { int l = s . Length ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( Math . Abs ( one - zero ) == 1 ) ; }
int oddEquivalent ( String s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) count ++ ; } return count ; }
bool isPalindrome ( string str ) { int firstChar = 0 , lastChar = str . Length - 1 ; bool ch = true ; for ( int i = 0 ; i < str . Length ; i ++ ) { firstChar = firstPos ( str , firstChar , lastChar ) ; lastChar = lastPos ( str , lastChar , firstChar ) ; if ( lastChar < 0 firstChar < 0 ) break ; if ( str [ firstChar ] == str [ lastChar ] ) { firstChar ++ ; lastChar -- ; continue ; } ch = false ; break ; } return ch ; }
int find ( String s ) { int max = 0 , i , j = 0 , countk = 0 , countr = 0 ; int [ , ] table = new int [ s . Length , 2 ] ; for ( i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == 'R' ) countr ++ ; else table [ ( j ++ ) , 0 ] = countr ; } j -- ; for ( i = s . Length - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == 'K' ) { countk ++ ; table [ j -- , 1 ] = countk ; } if ( Math . Min ( table [ j + 1 , 0 ] , table [ j + 1 , 1 ] ) > max ) max = Math . Min ( table [ j + 1 , 0 ] , table [ j + 1 , 1 ] ) ; } return max ; }
void LongestSequence ( int [ , ] fre , int n ) { for ( int i = 24 ; i >= 0 ; i -- ) { int mi = fre [ 0 , i ] ; for ( int j = 1 ; j < n ; j ++ ) { mi = Math . Min ( fre [ j , i ] , mi ) ; } while ( mi -- != 0 ) { Console . Write ( ( char ) ( 'a' + i ) ) ; } } }
int firstNonRepeating ( String str ) { int NO_OF_CHARS = 256 ; int [ ] arr = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) arr [ i ] = - 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( arr [ str [ i ] ] == - 1 ) arr [ str [ i ] ] = i ; else arr [ str [ i ] ] = - 2 ; } int res = int . MaxValue ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( arr [ i ] >= 0 ) res = Math . Min ( res , arr [ i ] ) ; return res ; }
void preComputeCoeff ( ) { for ( int i = 0 ; i < max ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i , j ] = 1 ; else nCr [ i , j ] = ( nCr [ i - 1 , j - 1 ] + nCr [ i - 1 , j ] ) % mod ; } } }
int countNonEmptySubstr ( string str ) { int n = str . Length ; return n * ( n + 1 ) / 2 ; }
int countWays ( string s ) { int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < s . Length ; i ++ ) count [ s [ i ] - 'a' ] ++ ; count [ s [ 0 ] - 'a' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
bool isPerfectSquareString ( string str ) { int sum = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) sum += ( int ) str [ i ] ; double squareRoot = Math . Sqrt ( sum ) ; double F = Math . Floor ( squareRoot ) ; return ( ( squareRoot - F ) == 0 ) ; }
int findSubstrings ( string s , int k ) { int ans = 0 ; int [ ] cnt = new int [ 26 ] ; int i , j , n = s . Length ; for ( i = 0 ; i < n ; i ++ ) { Array . Clear ( cnt , 0 , cnt . Length ) ; for ( j = i ; j < n ; j ++ ) { cnt [ s [ j ] - 'a' ] ++ ; if ( cnt [ s [ j ] - 'a' ] <= k ) ans ++ ; else break ; } } return ans ; }
int isPanDigital ( string s ) { int [ ] digits = new int [ 10 ] ; Array . Clear ( digits , 0 , 10 ) ; for ( int i = 0 ; i < s . Length ; i ++ ) digits [ s [ i ] - ( int ) '0' ] = 1 ; for ( int i = 0 ; i <= 9 ; i ++ ) if ( digits [ i ] == 0 ) return 0 ; return 1 ; }
int combinedSum ( string s ) { int n = s . Length ; int c_sum = 0 ; int range = ( 1 << n ) - 1 ; for ( int i = 0 ; i <= range ; i ++ ) c_sum += findSubSequence ( s , i ) ; return c_sum ; }
int numberOfPossiblePallindrome ( String str , int n ) { Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( str [ i ] ) ) { var val = mp [ str [ i ] ] ; mp . Remove ( str [ i ] ) ; mp . Add ( str [ i ] , val + 1 ) ; } else { mp . Add ( str [ i ] , 1 ) ; } } int fi ; foreach ( KeyValuePair < char , int > it in mp ) { if ( it . Value % 2 == 0 ) fi = it . Value / 2 ; else { fi = ( it . Value - 1 ) / 2 ; k ++ ; } num = num + fi ; den = den * fact ( fi ) ; } if ( num != 0 ) num = fact ( num ) ; int ans = num / den ; if ( k != 0 ) { ans = ans * k ; } return ( ans ) ; }
int totalConsonants ( String str ) { int count = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( isConsonant ( str [ i ] ) ) ++ count ; return count ; }
void convert ( string str ) { int n = str . Length ; string str1 = "" ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) str1 = str1 + '_' ; else str1 = str1 + Char . ToLower ( str [ i ] ) ; } Console . Write ( str1 ) ; }
bool isEven ( string s1 ) { int l = s1 . Length ; bool dotSeen = false ; for ( int i = l - 1 ; i >= 0 ; i -- ) { if ( s1 [ i ] == '0' && dotSeen == false ) continue ; if ( s1 [ i ] == '.' ) { dotSeen = true ; continue ; } if ( ( s1 [ i ] - '0' ) % 2 == 0 ) return true ; return false ; } return false ; }
bool isVowel ( char c ) { return ( c == 'A' c == 'E' c == 'I' c == 'O' c == 'U' c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) ; }
int countReduce ( string str ) { int n = str . Length ; int res = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) res += Math . Abs ( str [ i ] - str [ n - i - 1 ] ) ; return res ; }
void reverse ( char [ ] num , int i , int j ) { while ( i < j ) { char temp = num [ i ] ; num [ i ] = num [ j ] ; num [ j ] = temp ; i ++ ; j -- ; } }
void findWinner ( String [ ] votes ) { Dictionary < String , int > map = new Dictionary < String , int > ( ) ; foreach ( String str in votes ) { if ( map . ContainsKey ( str ) ) map [ str ] = map [ str ] + 1 ; else map . Add ( str , 1 ) ; } int maxValueInMap = 0 ; String winner = "" ; foreach ( KeyValuePair < String , int > entry in map ) { String key = entry . Key ; int val = entry . Value ; if ( val > maxValueInMap ) { maxValueInMap = val ; winner = key ; } else if ( val == maxValueInMap && winner . CompareTo ( key ) > 0 ) winner = key ; } Console . WriteLine ( winner ) ; }
bool distributingBalls ( long k , long n , string str ) { int [ ] a = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ str [ i ] - 'a' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; }
bool check ( int [ ] freq , int k ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( freq [ i ] != 0 && freq [ i ] != k ) return false ; return true ; }
long countSets ( int [ , ] a ) { long res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i , j ] == 1 ) u ++ ; else v ++ ; } res += ( long ) ( Math . Pow ( 2 , u ) - 1 + Math . Pow ( 2 , v ) ) - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j , i ] == 1 ) u ++ ; else v ++ ; } res += ( long ) ( Math . Pow ( 2 , u ) - 1 + Math . Pow ( 2 , v ) ) - 1 ; } return res - ( n * m ) ; }
void traverseTree ( NodeTemp root ) { if ( root == null ) { return ; } while ( root != null ) { Console . Write ( root . data + " " ) ; if ( root . child != null ) { traverseTree ( root . child ) ; } root = root . next ; } }
int calculateEnergy ( int [ , ] mat , int n ) { int i_des , j_des , q ; int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { q = mat [ i , j ] / n ; i_des = q ; j_des = mat [ i , j ] - ( n * q ) ; tot_energy += Math . Abs ( i_des - i ) + Math . Abs ( j_des - j ) ; } } return tot_energy ; }
int countUnique ( int [ , ] mat , int n , int m ) { int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i , j ] != 0 && isUnique ( mat , i , j , n , m ) ) uniquecount ++ ; return uniquecount ; }
bool uniqueCharacters ( String str ) { for ( int i = 0 ; i < str . Length ; i ++ ) for ( int j = i + 1 ; j < str . Length ; j ++ ) if ( str [ i ] == str [ j ] ) return false ; return true ; }
char largest_alphabet ( String a , int n ) { char max = 'A' ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] > max ) max = a [ i ] ; return max ; }
bool isPalRec ( String str , int s , int e ) { if ( s == e ) return true ; if ( ( str [ s ] ) != ( str [ e ] ) ) return false ; if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; }
int evenNumSubstring ( string str ) { int len = str . Length ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) if ( checkEquality ( s . Substring ( i , len ) ) ) result ++ ; return result ; }
bool unique ( String s ) { Array . Sort ( s . ToCharArray ( ) ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { return false ; } } return true ; }
void qType1 ( int [ , ] tree , int l , int x , char [ ] str ) { update ( tree , l , - 1 , str [ l - 1 ] - 97 + 1 ) ; str [ l - 1 ] = ( char ) x ; update ( tree , l , 1 , str [ l - 1 ] - 97 + 1 ) ; }
int countPairs ( string str ) { int result = 0 ; int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . Abs ( str [ i ] - str [ j ] ) == Math . Abs ( i - j ) ) result ++ ; return result ; }
int findMinLength ( String [ ] arr , int n ) { int min = arr [ 0 ] . Length ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] . Length < min ) { min = arr [ i ] . Length ; } } return ( min ) ; }
bool areDistinct ( string str , int i , int j ) { bool [ ] visited = new bool [ 26 ] ; for ( int k = i ; k <= j ; k ++ ) { if ( visited [ str [ k ] - 'a' ] == true ) return false ; visited [ str [ k ] - 'a' ] = true ; } return true ; }
void printRLE ( String str ) { int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count ++ ; i ++ ; } Console . Write ( str [ i ] ) ; Console . Write ( count ) ; } }
void antiSpiralTraversal ( int m , int n , int [ ] [ ] a ) { int i , k = 0 , l = 0 ; Stack < int > stk = new Stack < int > ( ) ; while ( k <= m && l <= n ) { for ( i = l ; i <= n ; ++ i ) { stk . Push ( a [ k ] [ i ] ) ; } k ++ ; for ( i = k ; i <= m ; ++ i ) { stk . Push ( a [ i ] [ n ] ) ; } n -- ; if ( k <= m ) { for ( i = n ; i >= l ; -- i ) { stk . Push ( a [ m ] [ i ] ) ; } m -- ; } if ( l <= n ) { for ( i = m ; i >= k ; -- i ) { stk . Push ( a [ i ] [ l ] ) ; } l ++ ; } } while ( stk . Count > 0 ) { Console . Write ( stk . Peek ( ) + " " ) ; stk . Pop ( ) ; } }
int findNormal ( int [ , ] mat , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i , j ] * mat [ i , j ] ; return ( int ) Math . Sqrt ( sum ) ; }
int countExpPaths ( Node node , int x ) { return evenPaths ( node , 0 , x ) ; }
int evenPaths ( Node node , int count ) { if ( node == null || ( node . key % 2 != 0 ) ) { return count ; } if ( node . left == null && node . right == null ) { count ++ ; } count = evenPaths ( node . left , count ) ; return evenPaths ( node . right , count ) ; }
int countEvenPaths ( Node node ) { return evenPaths ( node , 0 ) ; }
void dfs ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent [ u ] . Count ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] ) { temp ++ ; dfs ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; startnode = u ; } } }
void insertEdge ( int u , int v ) { adj [ u ] . Add ( v ) ; adj [ v ] . Add ( u ) ; }
int canPaint ( List < node > nodes , int n , int m ) { List < int > visited = new List < int > ( ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { visited . Add ( 0 ) ; } int maxColors = 1 ; for ( int sv = 1 ; sv <= n ; sv ++ ) { if ( visited [ sv ] > 0 ) continue ; visited [ sv ] = 1 ; Queue q = new Queue ( ) ; q . Enqueue ( sv ) ; while ( q . Count != 0 ) { int top = ( int ) q . Peek ( ) ; q . Dequeue ( ) ; foreach ( int it in nodes [ top ] . edges ) { if ( nodes [ top ] . color == nodes [ it ] . color ) nodes [ it ] . color += 1 ; maxColors = Math . Max ( maxColors , Math . Max ( nodes [ top ] . color , nodes [ it ] . color ) ) ; if ( maxColors > m ) return 0 ; if ( visited [ it ] == 0 ) { visited [ it ] = 1 ; q . Enqueue ( it ) ; } } } } return 1 ; }
void FastDoubling ( int n , int [ ] res ) { int a , b , c , d ; int MOD = 1000000007 ; if ( n == 0 ) { res [ 0 ] = 0 ; res [ 1 ] = 1 ; return ; } FastDoubling ( ( n / 2 ) , res ) ; a = res [ 0 ] ; b = res [ 1 ] ; c = 2 * b - a ; if ( c < 0 ) c += MOD ; c = ( a * c ) % MOD ; d = ( a * a + b * b ) % MOD ; if ( n % 2 == 0 ) { res [ 0 ] = c ; res [ 1 ] = d ; } else { res [ 0 ] = d ; res [ 1 ] = c + d ; } }
bool canPlace ( int [ ] a , int n , int p , int sep ) { int prisoners_placed = 1 ; int last_prisoner_placed = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int current_cell = a [ i ] ; if ( current_cell - last_prisoner_placed >= sep ) { prisoners_placed ++ ; last_prisoner_placed = current_cell ; if ( prisoners_placed == p ) { return true ; } } } return false ; }
int _mergeSort ( int [ ] arr , int [ ] temp , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; }
int minSteps ( int [ ] height , int N ) { return minStepsRecur ( height , 0 , N , 0 ) ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; y = y >> 1 ; y = y / 2 x = ( x * x ) % p ; } return res ; }
int minimumRectangleArea ( int [ ] A , int N ) { int ans ; Array . Sort ( A ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( int i = 1 ; i < N ; i ++ ) ans = Math . Min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; }
double areaOftriangle ( int side ) { double a = Math . Sqrt ( Math . Pow ( side / 2 , 2 ) + Math . Pow ( side / 2 , 2 ) ) ; double b = Math . Sqrt ( Math . Pow ( side , 2 ) + Math . Pow ( side / 2 , 2 ) ) ; double c = Math . Sqrt ( Math . Pow ( side , 2 ) + Math . Pow ( side / 2 , 2 ) ) ; double s = ( a + b + c ) / 2 ; double area = Math . Sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; return area ; }
void interceptLength ( int a , int b , int c , int i , int j , int k ) { double rad = radius ( a , b , c ) ; double dist = centerDistanceFromLine ( a , b , i , j , k ) ; if ( rad < 0 dist < 0 ) { Console . WriteLine ( "circle not possible" ) ; return ; } if ( dist > rad ) { Console . WriteLine ( "Line not cutting circle" ) ; } else Console . WriteLine ( 2 * Math . Sqrt ( rad * rad - dist * dist ) ) ; }
int centralPoints ( int [ , ] arr , int N ) { int count = 0 ; int c1 , c2 , c3 , c4 ; for ( int i = 0 ; i < N ; i ++ ) { c1 = 0 ; c2 = 0 ; c3 = 0 ; c4 = 0 ; int x = arr [ i , 0 ] ; int y = arr [ i , 1 ] ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ j , 0 ] > x && arr [ j , 1 ] == y ) { c1 = 1 ; } if ( arr [ j , 1 ] > y && arr [ j , 0 ] == x ) { c2 = 1 ; } if ( arr [ j , 0 ] < x && arr [ j , 1 ] == y ) { c3 = 1 ; } if ( arr [ j , 1 ] < y && arr [ j , 0 ] == x ) { c4 = 1 ; } } if ( c1 + c2 + c3 + c4 == 4 ) { count ++ ; } } return count ; }
void printMatrixDiagonal ( int [ , ] mat , int n ) { int i = 0 , j = 0 ; bool isUp = true ; for ( int k = 0 ; k < n * n ; ) { if ( isUp ) { for ( ; i >= 0 && j < n ; j ++ , i -- ) { Console . Write ( mat [ i , j ] + " " ) ; k ++ ; } if ( i < 0 && j <= n - 1 ) i = 0 ; if ( j == n ) { i = i + 2 ; j -- ; } } else { for ( ; j >= 0 && i < n ; i ++ , j -- ) { Console . Write ( mat [ i , j ] + " " ) ; k ++ ; } if ( j < 0 && i <= n - 1 ) j = 0 ; if ( i == n ) { j = j + 2 ; i -- ; } } isUp = ! isUp ; } }
double calculateSideLength ( double L , int N , int K ) { double angle = findInteriorAngle ( N ) ; double length = L * Math . Pow ( Math . Sin ( angle / 2 ) , ( K - 1 ) ) ; return length ; }
void minimumTriangleArea ( int a , int b ) { int area = a * b ; Console . WriteLine ( area ) ; }
void finalPosition ( char [ ] a , int [ ] b , int M ) { int n = 0 , s = 0 , e = 0 , w = 0 ; char p = 'N' ; for ( int i = 0 ; i < M ; i ++ ) { if ( p == 'N' ) { if ( a [ i ] == 'U' ) { p = 'N' ; n = n + b [ i ] ; } else if ( a [ i ] == 'D' ) { p = 'S' ; s = s + b [ i ] ; } else if ( a [ i ] == 'R' ) { p = 'E' ; e = e + b [ i ] ; } else if ( a [ i ] == 'L' ) { p = 'W' ; w = w + b [ i ] ; } } else if ( p == 'S' ) { if ( a [ i ] == 'U' ) { p = 'S' ; s = s + b [ i ] ; } else if ( a [ i ] == 'D' ) { p = 'N' ; n = n + b [ i ] ; } else if ( a [ i ] == 'R' ) { p = 'W' ; w = w + b [ i ] ; } else if ( a [ i ] == 'L' ) { p = 'E' ; e = e + b [ i ] ; } } else if ( p == 'E' ) { if ( a [ i ] == 'U' ) { p = 'E' ; e = e + b [ i ] ; } else if ( a [ i ] == 'D' ) { p = 'W' ; w = w + b [ i ] ; } else if ( a [ i ] == 'R' ) { p = 'S' ; s = s + b [ i ] ; } else if ( a [ i ] == 'L' ) { p = 'N' ; n = n + b [ i ] ; } } else if ( p == 'W' ) { if ( a [ i ] == 'U' ) { p = 'W' ; w = w + b [ i ] ; } else if ( a [ i ] == 'D' ) { p = 'E' ; e = e + b [ i ] ; } else if ( a [ i ] == 'R' ) { p = 'N' ; n = n + b [ i ] ; } else if ( a [ i ] == 'L' ) { p = 'S' ; s = s + b [ i ] ; } } } int ver_disp = n - s ; int hor_disp = e - w ; int displacement = ( int ) Math . Ceiling ( Math . Sqrt ( ( ver_disp * ver_disp ) + ( hor_disp * hor_disp ) ) ) ; Console . WriteLine ( displacement + " " + p ) ; }
void findPairs ( int [ ] x , int [ ] y , int K ) { int n = x . Length ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { if ( K * Math . Abs ( x [ i ] - x [ j ] ) >= Math . Abs ( y [ i ] - y [ j ] ) ) { ++ ans ; } } } Console . WriteLine ( ans ) ; }
void pyramidSlantHeight ( double pyramid_h , double pyramid_s ) { double slant_height_pyramid = Math . Sqrt ( Math . Pow ( pyramid_s / 2 , 2 ) + Math . Pow ( pyramid_h , 2 ) ) ; Console . WriteLine ( "Slant height of pyramid is: " + slant_height_pyramid ) ; }
double Area_Parallelogram2 ( int a , int b , int gamma ) { double area = ( Math . Abs ( Math . Sin ( ( gamma * Math . PI ) / 180 ) ) ) * Math . Abs ( a * b ) ; return area ; }
int No_of_rectangles ( int L , int B , int l , int b ) { if ( ( l > L ) || ( b > B ) ) { return - 1 ; } else { return ( L - l + 1 ) * ( B - b + 1 ) ; } }
double Area_of_Rhombus ( int a , int theta ) { double area = ( a * a ) * Math . Sin ( ( RADIAN * theta ) ) ; return area ; }
int nCr ( int n , int r ) { return ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) ; }
float distanceEndpoints ( int a , int b , float c ) { float angle = cal_cos ( c ) ; return ( float ) Math . Sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; }
void perpenBisectorFromLine ( point P , point Q , double a , double b , double c ) { point mid_point = new point ( ) ; mid_point . x = ( P . x + Q . x ) / 2 ; mid_point . y = ( P . y + Q . y ) / 2 ; c = - b * ( mid_point . x ) + a * ( mid_point . y ) ; double temp = a ; a = - b ; b = temp ; }
float circlearea ( float R ) { if ( R < 0 ) return - 1 ; float a = ( float ) ( ( 3.14 * R * R ) / 4 ) ; return a ; }
int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; }
double area ( double d1 , double a ) { double d2 = Math . Sqrt ( 4 * ( a * a ) - d1 * d1 ) ; double area = 0.5 * d1 * d2 ; return area ; }
float areaOfKite ( int d1 , int d2 ) { float area = ( d1 * d2 ) / 2 ; return area ; }
void findTriangles ( int n ) { int num ; num = n * ( n - 4 ) ; Console . WriteLine ( num ) ; }
int countNegative ( int [ , ] M , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i , j ] < 0 ) count += 1 ; else break ; } } return count ; }
float normal ( float m , float n ) { float N = ( float ) ( ( Math . Abs ( m ) * Math . Abs ( n ) ) / Math . Sqrt ( ( Math . Abs ( m ) * Math . Abs ( m ) ) + ( Math . Abs ( n ) * Math . Abs ( n ) ) ) ) ; return N ; }
bool isPossible ( int [ ] a , int n ) { int sum = 0 , maxS = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; maxS = Math . Max ( a [ i ] , maxS ) ; } if ( ( sum - maxS ) > maxS ) return true ; return false ; }
bool pointIsOnLine ( int m , int c , int x , int y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return - 1 ; float A = ( a * a * n ) / ( float ) ( 4 * Math . Tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; }
double heptdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.802 * a ; return d ; }
double trianglearea ( double a ) { if ( a < 0 ) return - 1 ; double area = ( 3 * Math . Sqrt ( 3 ) * Math . Pow ( a , 2 ) ) / 4 ; return Math . Round ( area , 4 ) ; }
void circle_equation ( double x1 , double y1 , double r ) { double a = - 2 * x1 ; double b = - 2 * y1 ; double c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; Console . Write ( "x^2 + (" + a + " x) + " ) ; Console . Write ( "y^2 + (" + b + " y) = " ) ; Console . WriteLine ( c + "." ) ; }
double Perimeter ( double s , int n ) { double perimeter = 1 ; perimeter = n * s ; return perimeter ; }
long dis ( long x1 , long y1 , long x2 , long y2 ) { return ( long ) Math . Sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; }
float area ( float b , float h ) { return ( 1 * b * h ) / 2 ; }
float findRadiusOfIncircle ( float a , float b , float c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; float p = ( a + b + c ) / 2 ; float area = ( float ) Math . Sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; float radius = area / p ; return ( float ) ( radius ) ; }
void findVolume ( double u , double v , double w , double U , double V , double W , double b ) { double uPow = Math . Pow ( u , 2 ) ; double vPow = Math . Pow ( v , 2 ) ; double wPow = Math . Pow ( w , 2 ) ; double UPow = Math . Pow ( U , 2 ) ; double VPow = Math . Pow ( V , 2 ) ; double WPow = Math . Pow ( W , 2 ) ; double a = 4 * ( uPow * vPow * wPow ) - uPow * Math . Pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * Math . Pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * Math . Pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ; double vol = Math . Sqrt ( a ) ; vol /= b ; Console . Write ( System . Math . Round ( vol , 4 ) ) ; }
float rectanglearea ( float r ) { if ( r < 0 ) return - 1 ; float a = r * r ; return a ; }
int findMaximumPieces ( int n ) { int x = n / 2 ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; }
int solve ( double M , double N , double s ) { int ans = ( ( int ) ( Math . Ceiling ( M / s ) ) * ( int ) ( Math . Ceiling ( N / s ) ) ) ; return ans ; }
int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
void center ( int x1 , int x2 , int y1 , int y2 ) { Console . WriteLine ( ( float ) ( x1 + x2 ) / 2 + ", " + ( float ) ( y1 + y2 ) / 2 ) ; }
double vol_of_octahedron ( double side ) { return ( ( side * side * side ) * ( Math . Sqrt ( 2 ) / 3 ) ) ; }
double circumference ( double r ) { double PI = 3.1415 ; double cir = 2 * PI * r ; return cir ; }
void floodFillUtil ( char [ , ] mat , int x , int y , char prevV , char newV ) { if ( x < 0 >= M y < 0 y >= N ) return ; if ( mat [ x , y ] != prevV ) return ; mat [ x , y ] = newV ; floodFillUtil ( mat , x + 1 , y , prevV , newV ) ; floodFillUtil ( mat , x - 1 , y , prevV , newV ) ; floodFillUtil ( mat , x , y + 1 , prevV , newV ) ; floodFillUtil ( mat , x , y - 1 , prevV , newV ) ; }
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
float area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return ( float ) Math . Abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; }
int numberOfDiagonals ( int n ) { return n * ( n - 3 ) / 2 ; }
int orientation ( List < int > a , List < int > b , List < int > c ) { int res = ( b [ 1 ] - a [ 1 ] ) * ( c [ 0 ] - b [ 0 ] ) - ( c [ 1 ] - b [ 1 ] ) * ( b [ 0 ] - a [ 0 ] ) ; if ( res == 0 ) return 0 ; if ( res > 0 ) return 1 ; return - 1 ; }
int countLattice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int ySquare = r * r - x * x ; int y = ( int ) Math . Sqrt ( ySquare ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }
int minimumCost ( int [ ] arr , int N , int X , int Y ) { int even_count = 0 , odd_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) > 0 && ( i % 2 == 0 ) ) { odd_count ++ ; } if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) > 0 ) { even_count ++ ; } } int cost1 = X * Math . Min ( odd_count , even_count ) ; int cost2 = Y * ( Math . Max ( odd_count , even_count ) - Math . Min ( odd_count , even_count ) ) ; int cost3 = ( odd_count + even_count ) * Y ; return Math . Min ( cost1 + cost2 , cost3 ) ; }
double root ( double num , int p ) { double left = - num ; double right = num ; double x ; while ( true ) { x = ( left + right ) / 2.0 ; double value = f ( x , p , num ) ; double prime = f_prime ( x , p ) ; if ( value * prime <= 0 ) left = x ; else right = x ; if ( value < 0.000001 && value >= 0 ) { return x ; } } }
int countTriplets ( int N ) { int cnt = 0 ; for ( int A = 1 ; A <= N ; ++ A ) { for ( int B = 1 ; B <= N / A ; ++ B ) { cnt += N / ( A * B ) ; } } return cnt ; }
void nearestRight ( int [ ] arr , int N , int [ ] steps ) { int R = 2 * N ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { R = N + i ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { R = i ; } steps [ i ] = Math . Min ( steps [ i ] , R - i ) ; } }
void updateArray ( List < int > arr , int K ) { int sum = 0 ; List < int > res = new List < int > ( ) ; for ( int i = 0 ; i < arr . Count ; i ++ ) { if ( arr [ i ] < K ) { sum += arr [ i ] ; } else { if ( sum != 0 ) { res . Add ( sum ) ; } sum = 0 ; res . Add ( arr [ i ] ) ; } } if ( sum != 0 ) res . Add ( sum ) ; foreach ( int it in res ) Console . Write ( it + " " ) ; }
string checkSameDigits ( int N ) { int digit = N % 10 ; while ( N != 0 ) { int current_digit = N % 10 ; N = N / 10 ; if ( current_digit != digit ) { return "No" ; } } return "Yes" ; }
int maxPossibleMoves ( int X , int Y , int A , int B ) { int ans = 0 ; int L = 1 , R = MAXN ; while ( L <= R ) { int Mid = ( L + R ) / 2 ; if ( can ( Mid , X , Y , A , B ) ) { L = Mid + 1 ; ans = Math . Max ( ans , Mid ) ; } else { R = Mid - 1 ; } } return ans ; }
void possiblePair ( int X , int Y ) { int Z = Y - X ; if ( Z < 0 ) { Console . Write ( "-1" ) ; } for ( int k = 0 ; k < MaxBit ; k ++ ) { int bit1 = ( Z >> k ) & 1 ; int bit2 = ( Z >> k ) & 1 ; if ( bit1 != 0 && bit2 == 0 ) { Console . Write ( "-1" ) ; } } Console . Write ( Z + " " + X ) ; }
int minSumDifference ( int [ ] ar , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ar [ i ] ; int rem = sum % n ; return rem * ( n - rem ) ; }
int minSteps ( int N ) { int res = ( ( int ) Math . Sqrt ( 1 + 8 * N ) - 1 ) / 2 ; return res ; }
void oppositeFaceOfDice ( int N ) { int ans = 7 - N ; Console . Write ( ans ) ; }
void IsEvenPath ( int [ ] Source , int [ ] Destination ) { int x_dif = Math . Abs ( Source [ 0 ] - Destination [ 0 ] ) ; int y_dif = Math . Abs ( Source [ 1 ] - Destination [ 1 ] ) ; int minsteps = x_dif + y_dif ; if ( minsteps % 2 == 0 ) Console . WriteLine ( "Yes" ) ; else Console . WriteLine ( "No" ) ; }
void findFraction ( long x , long y , long n ) { long A = - 1 , B = - 1 ; for ( long i = 1 ; i <= n ; i ++ ) { long d = ( i * x ) / y ; if ( d >= 0 && ( A == - 1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d ; B = i ; d ++ ; if ( d >= 0 && ( A == - 1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d ; B = i ; } A -- ; B -- ; Console . Write ( A + "/" + B ) ; }
int countKAverageSubarrays ( int [ ] arr , int n , int k ) { int res = 0 ; for ( int L = 0 ; L < n ; L ++ ) { int sum = 0 ; for ( int R = L ; R < n ; R ++ ) { sum += arr [ R ] ; int len = ( R - L + 1 ) ; if ( sum % len == 0 ) { int avg = sum / len ; if ( avg == k ) res ++ ; } } } return res ; }
int power ( int x , int y ) { int res = 1 ; while ( y > 0 ) { if ( y % 2 != 0 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }
void numberOfPairs ( int N , int [ , ] arr ) { adj = new List < List < int > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { adj . Add ( new List < int > ( ) ) ; } for ( int i = 0 ; i < 2 ; i ++ ) { adj [ arr [ i , 0 ] ] . Add ( arr [ i , 1 ] ) ; adj [ arr [ i , 1 ] ] . Add ( arr [ i , 0 ] ) ; } visited = new bool [ N ] ; Array . Fill ( visited , false ) ; List < int > v = new List < int > ( ) ; num = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! visited [ i ] ) { dfs ( i ) ; v . Add ( num ) ; num = 0 ; } } int ans = N * ( N - 1 ) / 2 + 1 ; for ( int i = 0 ; i < v . Count ; i ++ ) { ans -= ( v [ i ] * ( v [ i ] - 1 ) / 2 ) + 1 ; } Console . Write ( ans ) ; }
void isPossible ( int W , int B , int D ) { if ( W > B ) { int temp = W ; W = B ; B = temp ; } if ( B > W * ( D + 1 ) ) Console . WriteLine ( "NO" ) ; else Console . WriteLine ( "YES" ) ; }
int tripletAndSum ( int [ ] arr , int n ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & ( 1 << bit ) ) != 0 ) cnt ++ ; } ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) / 6 ; } return ans ; }
int largestK ( int [ ] A , int N ) { int l = 0 , r = N - 1 , flag = 0 ; while ( l < r ) { if ( A [ l ] != A [ r ] ) { flag = 1 ; break ; } l ++ ; r -- ; } if ( flag == 0 ) return - 1 ; int K = Math . Abs ( A [ 0 ] - A [ N - 1 ] ) ; for ( int i = 1 ; i < N / 2 ; i ++ ) K = gcd ( K , Math . Abs ( A [ i ] - A [ N - i - 1 ] ) ) ; return K ; }
void NumberofSets ( int N ) { SieveOfEratosthenes ( N ) ; if ( N == 2 ) { Console . Write ( 1 ) ; } else if ( N == 3 ) { Console . Write ( 2 ) ; } else { int ans = 1 ; for ( int i = N / 2 + 1 ; i <= N ; i ++ ) { if ( prime [ i ] ) { ans += 1 ; } } Console . Write ( ans ) ; } }
int sumOfDivisors ( int N ) { return N ; }
bool findDigit ( int N , int D ) { while ( N > 0 ) { int a = N % 10 ; if ( a == D ) { return true ; } N /= 10 ; } return false ; }
int findXORS ( int [ ] arr1 , int [ ] arr2 , int N , int M ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int temp = arr1 [ i ] & arr2 [ j ] ; res ^= temp ; } } return res ; }
float findMedian ( Node root , int node1 , int node2 ) { getIntermediateNodes ( root , node1 , node2 ) ; int nSize = interNodes . Count ; return ( nSize % 2 == 1 ) ? ( float ) interNodes [ nSize / 2 ] : ( float ) ( interNodes [ ( nSize - 1 ) / 2 ] + interNodes [ nSize / 2 ] ) / 2 ; }
void findDifference ( int N ) { int [ ] s = new int [ N + 1 ] ; sieveOfEratosthenes ( N , s ) ; int total = 1 , odd = 1 , even = 0 ; int curr = s [ N ] ; int cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } if ( curr == 2 ) { total = total * ( cnt + 1 ) ; } else { total = total * ( cnt + 1 ) ; odd = odd * ( cnt + 1 ) ; } curr = s [ N ] ; cnt = 1 ; } even = total - odd ; Console . Write ( Math . Abs ( even - odd ) ) ; }
void countPrime ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < prime . Length ; i ++ ) { prime [ i ] = true ; } SieveOfEratosthenes ( n , prime ) ; int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i < dp . Length ; i ++ ) { dp [ i ] = 0 ; } dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] += dp [ i - 1 ] ; if ( prime [ i ] == true && prime [ i - 2 ] == true ) { dp [ i ] ++ ; } } Console . Write ( dp [ n ] ) ; }
int findGCD ( int a , int b ) { if ( b == 0 ) return a ; return findGCD ( b , a % b ) ; }
int findLCM ( int a , int b ) { return ( a * b ) / findGCD ( a , b ) ; }
int convert ( List < int > p ) { int ans = 0 ; foreach ( int i in p ) { ans = ( ans << 1 ) | i ; } return ans ; }
bool check ( List < int > [ ] Adj , int Src , int N , bool [ ] visited ) { int [ ] color = new int [ N ] ; visited [ Src ] = true ; Queue < int > q = new Queue < int > ( ) ; q . Enqueue ( Src ) ; while ( q . Count > 0 ) { int u = q . Peek ( ) ; q . Dequeue ( ) ; int Col = color [ u ] ; foreach ( int x in Adj [ u ] ) { if ( visited [ x ] == true && color [ x ] == Col ) { return false ; } else if ( visited [ x ] == false ) { visited [ x ] = true ; q . Enqueue ( x ) ; color [ x ] = 1 - Col ; } } } return true ; }
double average ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; return ( double ) ( sum / N ) ; }
void checkWinner ( int [ ] arr , int N ) { int diff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { diff -= arr [ i ] ; } if ( diff % 2 == 0 ) { Console . Write ( "A" ) ; } else { Console . Write ( "B" ) ; } }
int countAPs ( int S , int D ) { S = S * 2 ; int answer = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { if ( ( ( S / i ) - D * i + D ) % 2 == 0 ) answer ++ ; if ( ( D * i - ( S / i ) + D ) % 2 == 0 ) answer ++ ; } } return answer ; }
void buildSieve ( ) { for ( int i = 2 ; i < 100 ; i ++ ) sieve [ i ] = 1 ; for ( int i = 2 ; i < 100 ; i ++ ) { if ( sieve [ i ] == 1 ) { for ( int j = i * i ; j < 100 ; j += i ) sieve [ j ] = 0 ; } } }
int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= ( int ) Math . Sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; }
int numOfPairs ( List < string > arr , int N ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( coprime ( Int32 . Parse ( arr [ i ] ) , Int32 . Parse ( arr [ j ] ) ) ) { count = count + 1 ; } } } return count ; }
int countPairs ( int [ ] arr , int N ) { Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . ContainsKey ( ( int ) ( Math . Log ( Convert . ToDouble ( arr [ i ] ) , 2.0 ) ) ) ) freq [ ( int ) ( Math . Log ( Convert . ToDouble ( arr [ i ] ) , 2.0 ) ) ] ++ ; else freq [ ( int ) ( Math . Log ( Convert . ToDouble ( arr [ i ] ) , 2.0 ) ) ] = 1 ; } int pairs = 0 ; foreach ( var item in freq ) { pairs += item . Value - 1 ; } return pairs ; }
int sumOfDigits ( int N ) { int sum = 0 ; while ( N != 0 ) { sum += N % 10 ; N /= 10 ; } return sum ; }
