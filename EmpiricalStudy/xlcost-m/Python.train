def isPerfect ( N ) : NEW_LINE INDENT sumOfDivisors = 1 NEW_LINE for i in range ( 2 , int ( N / 2 ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT sumOfDivisors += i NEW_LINE DEDENT DEDENT if ( sumOfDivisors == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def countPerfectNumbers ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( isPerfect ( arr [ i ] ) ) : NEW_LINE INDENT sum = sumOfDigits ( arr [ i ] ) NEW_LINE if ( isPerfect ( sum ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def issafe ( m , n , i , j ) : NEW_LINE INDENT if i < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if j < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if i >= m : NEW_LINE INDENT return False NEW_LINE DEDENT if j >= n : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def endpoints ( arr , m , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE current_d = 'r' NEW_LINE rcd = { 'l' : 'u' , 'u' : 'r' , 'r' : 'd' , 'd' : 'l' } NEW_LINE while issafe ( m , n , i , j ) : NEW_LINE INDENT current_i = i NEW_LINE current_j = j NEW_LINE if arr [ i ] [ j ] == 1 : NEW_LINE INDENT move_in = rcd [ current_d ] NEW_LINE arr [ i ] [ j ] = 0 NEW_LINE if move_in == 'u' : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif move_in == 'd' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif move_in == 'l' : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT elif move_in == 'r' : NEW_LINE INDENT j += 1 NEW_LINE DEDENT current_d = move_in NEW_LINE DEDENT else : NEW_LINE INDENT if current_d == 'u' : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif current_d == 'd' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif current_d == 'l' : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT elif current_d == 'r' : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return ( current_i , current_j ) NEW_LINE DEDENT
def maxPresum ( a , b ) : NEW_LINE INDENT X = max ( a [ 0 ] , 0 ) NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT a [ i ] += a [ i - 1 ] NEW_LINE X = max ( X , a [ i ] ) NEW_LINE DEDENT Y = max ( b [ 0 ] , 0 ) NEW_LINE for i in range ( 1 , len ( b ) ) : NEW_LINE INDENT b [ i ] += b [ i - 1 ] NEW_LINE Y = max ( Y , b [ i ] ) NEW_LINE DEDENT return X + Y NEW_LINE DEDENT
def findSum ( root ) : NEW_LINE INDENT que = [ root ] NEW_LINE ans = 0 NEW_LINE while ( len ( que ) ) : NEW_LINE INDENT leaf = 0 NEW_LINE nonleaf = 0 NEW_LINE length = len ( que ) NEW_LINE while length : NEW_LINE INDENT temp = que . pop ( 0 ) NEW_LINE if not temp . left and not temp . right : NEW_LINE INDENT leaf += temp . val NEW_LINE DEDENT else : NEW_LINE INDENT nonleaf += temp . val NEW_LINE DEDENT if temp . left : NEW_LINE INDENT que . append ( temp . left ) NEW_LINE DEDENT if temp . right : NEW_LINE INDENT que . append ( temp . right ) NEW_LINE DEDENT length -= 1 NEW_LINE DEDENT ans += leaf & nonleaf NEW_LINE DEDENT return ans NEW_LINE DEDENT
def fizzBuzz ( N ) : NEW_LINE INDENT count3 = 0 NEW_LINE count5 = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count3 += 1 NEW_LINE count5 += 1 NEW_LINE flag = False NEW_LINE if ( count3 == 3 ) : NEW_LINE INDENT print ( "Fizz" , end = "" ) NEW_LINE count3 = 0 NEW_LINE flag = True NEW_LINE DEDENT if ( count5 == 5 ) : NEW_LINE INDENT print ( "Buzz" , end = "" ) NEW_LINE count5 = 0 NEW_LINE flag = True NEW_LINE DEDENT if ( not flag ) : NEW_LINE INDENT print ( i , end = "" ) NEW_LINE DEDENT print ( end = " " ) NEW_LINE DEDENT DEDENT
def checkElementsOnDiagonal ( M , N ) : NEW_LINE INDENT flag = 1 NEW_LINE SieveOfEratosthenes ( 1000000 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT flag &= ( prime [ M [ i ] [ i ] ] and prime [ M [ i ] [ N - 1 - i ] ] ) NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def circularPermutation ( n , start ) : NEW_LINE INDENT res = [ 0 ] NEW_LINE ret = [ ] NEW_LINE index , add = - 1 , 1 NEW_LINE for k in range ( n ) : NEW_LINE INDENT add = 1 << k NEW_LINE for i in range ( len ( res ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( res [ i ] + add == start ) : NEW_LINE INDENT index = len ( res ) NEW_LINE DEDENT res . append ( res [ i ] + add ) NEW_LINE DEDENT add = 1 << k NEW_LINE DEDENT if ( start == 0 ) : NEW_LINE INDENT return res NEW_LINE DEDENT while ( len ( ret ) < len ( res ) ) : NEW_LINE INDENT ret . append ( res [ index ] ) NEW_LINE index = ( index + 1 ) % len ( res ) NEW_LINE DEDENT return ret NEW_LINE DEDENT
def countPairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT y = a [ i ] NEW_LINE if ( y != 0 and y != 1 ) : NEW_LINE INDENT x = ( ( ( y * 1.0 ) // ( 1 - y ) ) * y ) NEW_LINE count += mp . get ( x , 0 ) NEW_LINE DEDENT mp [ y ] = mp . get ( y , 0 ) + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def sieveOfPrimes ( ) : NEW_LINE INDENT global sieve NEW_LINE N = 1000000 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT if ( sieve [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT sieve [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT
def getArray ( arr , N ) : NEW_LINE INDENT global sieve NEW_LINE A = [ 0 ] * N NEW_LINE v = [ ] NEW_LINE sieveOfPrimes ( ) NEW_LINE for i in range ( 2 , int ( 1e5 ) + 1 ) : NEW_LINE INDENT if ( sieve [ i ] ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT j = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ind = arr [ i ] NEW_LINE if ( A [ i ] != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( A [ ind ] != 0 ) : NEW_LINE INDENT A [ i ] = A [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT prime = v [ j ] NEW_LINE A [ i ] = prime NEW_LINE A [ ind ] = A [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( A [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def contains ( num , K , base ) : NEW_LINE INDENT isThere = 0 NEW_LINE while ( num ) : NEW_LINE INDENT remainder = num % base NEW_LINE if ( remainder == K ) : NEW_LINE INDENT isThere = 1 NEW_LINE DEDENT num //= base NEW_LINE DEDENT return isThere NEW_LINE DEDENT
def numberOfTiles ( N , M ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( N * M ) // 2 NEW_LINE DEDENT
def canMakeEqual ( arr1 , arr2 , N ) : NEW_LINE INDENT count = 0 NEW_LINE arr1_one = 0 NEW_LINE arr1_zero = 0 NEW_LINE arr2_one = 0 NEW_LINE arr2_zero = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr1 [ i ] == 1 ) : NEW_LINE INDENT arr1_one += 1 NEW_LINE DEDENT elif ( arr1 [ i ] == 0 ) : NEW_LINE INDENT arr1_zero += 1 NEW_LINE DEDENT if ( arr2 [ i ] == 1 ) : NEW_LINE INDENT arr2_one += 1 NEW_LINE DEDENT elif ( arr2 [ i ] == 0 ) : NEW_LINE INDENT arr2_zero += 1 NEW_LINE DEDENT DEDENT if ( arr1_one != arr2_one or arr1_zero != arr2_zero ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT count = count + ( arr1 [ i ] - arr2 [ i ] ) NEW_LINE if ( count < 0 ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "Yes" ) NEW_LINE DEDENT
def findNthNumber ( N ) : NEW_LINE INDENT result = 0 NEW_LINE p = 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT result += ( p * ( N % 9 ) ) NEW_LINE N = N // 9 NEW_LINE p = p * 10 NEW_LINE DEDENT return result NEW_LINE DEDENT
def cntMaxOperationToMakeN_1_0 ( arr , N ) : NEW_LINE INDENT cntOp = 0 NEW_LINE PQ = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT PQ . append ( arr [ i ] ) NEW_LINE DEDENT PQ = sorted ( PQ ) NEW_LINE while ( len ( PQ ) > 1 ) : NEW_LINE INDENT X = PQ [ - 1 ] NEW_LINE del PQ [ - 1 ] NEW_LINE Y = PQ [ - 1 ] NEW_LINE del PQ [ - 1 ] NEW_LINE X -= 1 NEW_LINE Y -= 1 NEW_LINE if ( X != 0 ) : NEW_LINE INDENT PQ . append ( X ) NEW_LINE DEDENT if ( Y != 0 ) : NEW_LINE INDENT PQ . append ( Y ) NEW_LINE DEDENT cntOp += 1 NEW_LINE PQ = sorted ( PQ ) NEW_LINE DEDENT return cntOp NEW_LINE DEDENT
def checkSamePosition ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = ( ( i + arr [ i ] ) % n + n ) % n NEW_LINE if temp in mp : NEW_LINE INDENT print ( "Yes" ) NEW_LINE return NEW_LINE DEDENT if ( temp in mp ) : NEW_LINE INDENT mp [ temp ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ temp ] = mp . get ( temp , 0 ) + 1 NEW_LINE DEDENT DEDENT print ( "No" ) NEW_LINE DEDENT
def sumFib ( N ) : NEW_LINE INDENT num = round ( pow ( ( pow ( 5 , 1 / 2 ) + 1 ) / 2.0 , N + 2 ) / pow ( 5 , 1 / 2 ) ) NEW_LINE print ( num - 1 ) NEW_LINE DEDENT
def sumFib ( N ) : NEW_LINE INDENT num = ( 1 - math . sqrt ( 5 ) ) / 2 NEW_LINE val = round ( abs ( 1 / ( pow ( num , N + 2 ) + pow ( num , N + 1 ) + pow ( num , N ) + pow ( num , N - 1 ) ) ) - 1 ) NEW_LINE print ( val ) NEW_LINE DEDENT
def poorPigs ( buckets , minutesToDie , minutesToTest ) : NEW_LINE INDENT print ( math . ceil ( math . log ( buckets ) // math . log ( ( minutesToTest // minutesToDie ) + 1 ) ) ) NEW_LINE DEDENT
def countTrailingZeroes ( N ) : NEW_LINE INDENT res = int ( log2 ( N ^ ( N - 1 ) ) ) NEW_LINE return res if res >= 0 else 0 NEW_LINE DEDENT
def maxProduct ( arr , N ) : NEW_LINE INDENT max_product = - sys . maxsize NEW_LINE prefix_sum = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT prefix_sum += arr [ i ] NEW_LINE X = prefix_sum NEW_LINE Y = sum - prefix_sum NEW_LINE max_product = max ( max_product , X * Y ) NEW_LINE DEDENT print ( max_product ) NEW_LINE DEDENT
def findMask ( K ) : NEW_LINE INDENT mask = 1 NEW_LINE while ( ( K & mask ) == 0 ) : NEW_LINE INDENT mask = mask << 1 NEW_LINE DEDENT return mask NEW_LINE DEDENT
def sameRightSetBitPos ( arr , N , K ) : NEW_LINE INDENT mask = findMask ( K ) NEW_LINE pos = ( K & mask ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( ( arr [ i ] & mask ) == pos ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def countPronic ( A , B ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( checkPronic ( i ) != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def pronic ( num ) : NEW_LINE INDENT N = int ( num ** ( 1 / 2 ) ) NEW_LINE if ( N * ( N + 1 ) <= num ) : NEW_LINE INDENT return N NEW_LINE DEDENT return N - 1 NEW_LINE DEDENT
def countPronic ( A , B ) : NEW_LINE INDENT return pronic ( B ) - pronic ( A - 1 ) NEW_LINE DEDENT
def sameProductQuadruples ( nums , N ) : NEW_LINE INDENT umap = { } NEW_LINE res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT prod = nums [ i ] * nums [ j ] NEW_LINE if prod in umap : NEW_LINE INDENT res += 8 * umap [ prod ] NEW_LINE umap [ prod ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT umap [ prod ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def productExceptSelf ( arr , N ) : NEW_LINE INDENT product = 1 NEW_LINE z = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT product *= arr [ i ] NEW_LINE DEDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT z += 1 NEW_LINE DEDENT DEDENT a = abs ( product ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( z == 1 ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = product NEW_LINE DEDENT continue NEW_LINE DEDENT elif ( z > 1 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE continue NEW_LINE DEDENT b = abs ( arr [ i ] ) NEW_LINE curr = round ( math . exp ( math . log ( a ) - math . log ( b ) ) ) NEW_LINE if ( arr [ i ] < 0 and product < 0 ) : NEW_LINE INDENT arr [ i ] = curr NEW_LINE DEDENT elif ( arr [ i ] > 0 and product > 0 ) : NEW_LINE INDENT arr [ i ] = curr NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 * curr NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def getMax ( arr , ans , chosen , N ) : NEW_LINE INDENT if len ( arr ) == N : NEW_LINE INDENT ans = max ( ans , calcScr ( arr ) ) NEW_LINE return ans NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if chosen [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT chosen [ i ] = True NEW_LINE arr . append ( i ) NEW_LINE ans = getMax ( arr , ans , chosen , N ) NEW_LINE chosen [ i ] = False NEW_LINE arr . pop ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def singleDigitSubarrayCount ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] <= 9 ) : NEW_LINE INDENT count += 1 NEW_LINE res += count NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def maxSumAfterKReverse ( arr , K , N ) : NEW_LINE INDENT sum = - sys . maxsize - 1 NEW_LINE if ( K & 1 ) : NEW_LINE INDENT arr . reverse ( ) NEW_LINE DEDENT currsum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT currsum += arr [ i ] NEW_LINE sum = max ( sum , currsum ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def isPossible ( N ) : NEW_LINE INDENT return ( ( N & ( N - 1 ) ) and N ) NEW_LINE DEDENT
def countElements ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( isPossible ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def countElements ( N ) : NEW_LINE INDENT Cur_Ele = 1 NEW_LINE Count = 0 NEW_LINE while ( Cur_Ele <= N ) : NEW_LINE INDENT Count += 1 NEW_LINE Cur_Ele = Cur_Ele * 2 NEW_LINE DEDENT print ( N - Count ) NEW_LINE DEDENT
def SubMasks ( N ) : NEW_LINE INDENT S = N NEW_LINE while S > 0 : NEW_LINE INDENT print ( S , end = ' ' ) NEW_LINE S = ( S - 1 ) & N NEW_LINE DEDENT DEDENT
def power ( x , y ) : NEW_LINE INDENT MOD = 1000000007 NEW_LINE res = 1 NEW_LINE x = x % MOD NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % MOD NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT
def countPairs ( N ) : NEW_LINE INDENT MOD = 1000000007 NEW_LINE high = power ( 2 , N ) NEW_LINE count = 0 NEW_LINE for i in range ( high ) : NEW_LINE INDENT for j in range ( high ) : NEW_LINE INDENT X = ( i ^ j ) NEW_LINE Y = ( i j ) NEW_LINE if ( X == Y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count % MOD ) NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % MOD NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) % MOD NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT
def countPairs ( N ) : NEW_LINE INDENT print ( power ( 3 , N ) ) NEW_LINE DEDENT
def minSum ( A , N ) : NEW_LINE INDENT mp = { } NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE if A [ i ] in mp : NEW_LINE INDENT mp [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT DEDENT minSum = float ( 'inf' ) NEW_LINE for it in mp : NEW_LINE INDENT minSum = min ( minSum , sum - ( it * mp [ it ] ) ) NEW_LINE DEDENT return minSum NEW_LINE DEDENT
def minimumMoves ( a , n ) : NEW_LINE INDENT min_element = sys . maxsize NEW_LINE max_element = - sys . maxsize - 1 NEW_LINE min_ind = - 1 NEW_LINE max_ind = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] <= min_element ) : NEW_LINE INDENT min_element = a [ i ] NEW_LINE min_ind = i NEW_LINE DEDENT if ( a [ i ] > max_element ) : NEW_LINE INDENT max_element = a [ i ] NEW_LINE max_ind = i NEW_LINE DEDENT DEDENT if ( max_ind == min_ind ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( max_ind > min_ind ) : NEW_LINE INDENT return max_ind + ( n - min_ind - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max_ind + n - min_ind - 1 NEW_LINE DEDENT DEDENT
def isCycleExists ( arr , N ) : NEW_LINE INDENT valley = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "No" ) NEW_LINE DEDENT
def findIndex ( arr , n , K ) : NEW_LINE INDENT sum = 0 NEW_LINE res = - 1 NEW_LINE mini = 1e9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT temp = sum - arr [ i ] NEW_LINE if ( temp % K == 0 ) : NEW_LINE INDENT if ( res == - 1 or mini > arr [ i ] ) : NEW_LINE INDENT res = i + 1 NEW_LINE mini = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def minimumIncrement ( arr , N ) : NEW_LINE INDENT if ( N % 2 != 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT cntEven = 0 NEW_LINE cntOdd = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT cntEven += 1 NEW_LINE DEDENT DEDENT cntOdd = N - cntEven NEW_LINE return abs ( cntEven - cntOdd ) // 2 NEW_LINE DEDENT
def divisionalArrays ( arr , N ) : NEW_LINE INDENT sum = N NEW_LINE mp = defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] > 1 ) : NEW_LINE INDENT sum += mp [ x ] - 1 NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE DEDENT
def totalInversions ( arr , K , N ) : NEW_LINE INDENT inv = 0 NEW_LINE X = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and i < j ) : NEW_LINE INDENT inv += 1 NEW_LINE DEDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT X += 1 NEW_LINE DEDENT DEDENT DEDENT totalInv = X * K * ( K - 1 ) // 2 + inv * K NEW_LINE print ( totalInv ) NEW_LINE DEDENT
def findSize ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT Size = 2 * findSize ( N // 2 ) + 1 NEW_LINE return Size NEW_LINE DEDENT
def CountOnes ( N , L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N <= 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT ret = 0 NEW_LINE M = N // 2 NEW_LINE Siz_M = findSize ( M ) NEW_LINE if ( L <= Siz_M ) : NEW_LINE INDENT ret += CountOnes ( N // 2 , L , min ( Siz_M , R ) ) NEW_LINE DEDENT if ( L <= Siz_M + 1 and Siz_M + 1 <= R ) : NEW_LINE INDENT ret += N % 2 NEW_LINE DEDENT if ( Siz_M + 1 < R ) : NEW_LINE INDENT ret += CountOnes ( N // 2 , max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT
def Fact ( N ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT result = ( result * i ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def numberOfWays ( M , arr , N ) : NEW_LINE INDENT B = [ 0 ] * ( M ) NEW_LINE counter = [ 0 ] * ( M + 1 ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT if ( B [ i % M ] == 0 ) : NEW_LINE INDENT B [ i % M ] = arr [ i ] NEW_LINE counter [ arr [ i ] ] += 1 NEW_LINE if ( counter [ arr [ i ] ] > 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT DEDENT elif ( B [ i % M ] != arr [ i ] ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT cnt = 0 NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT if ( B [ i ] == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( Fact ( cnt ) ) NEW_LINE DEDENT
def getMax ( arr , N , K ) : NEW_LINE INDENT for i in range ( 1 , N , 1 ) : NEW_LINE INDENT cur_val = arr [ i ] NEW_LINE while ( K >= i ) : NEW_LINE INDENT if ( cur_val > 0 ) : NEW_LINE INDENT arr [ 0 ] = arr [ 0 ] + 1 NEW_LINE cur_val = cur_val - 1 NEW_LINE K = K - i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( arr [ 0 ] ) NEW_LINE DEDENT
def MaximumSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y , sum = 0 , i , 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum , x , y = sum + arr [ x ] [ y ] , x + 1 , y + 1 NEW_LINE DEDENT if ( sum > ans ) : NEW_LINE INDENT ans = sum NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT x , y , sum = i , 0 , 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum , x , y = sum + arr [ x ] [ y ] , x + 1 , y + 1 NEW_LINE DEDENT if ( sum > ans ) : NEW_LINE INDENT ans = sum NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def numberOfIntegers ( arr , N ) : NEW_LINE INDENT cur_max = 0 NEW_LINE count = 0 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT count = 1 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( N - 1 ) : NEW_LINE INDENT if ( arr [ i ] > cur_max ) : NEW_LINE INDENT cur_max = arr [ i ] NEW_LINE if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( arr [ N - 1 ] > cur_max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def numberOfWays ( n , k ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n >= pow ( 2 , k ) ) : NEW_LINE INDENT curr_val = pow ( 2 , k ) NEW_LINE return numberOfWays ( n - curr_val , k ) + numberOfWays ( n , k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return numberOfWays ( n , k - 1 ) NEW_LINE DEDENT DEDENT
def possibleTriplets ( arr , N ) : NEW_LINE INDENT freq = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT DEDENT return ( freq * ( freq - 1 ) * ( freq - 2 ) ) // 6 NEW_LINE DEDENT
def build ( tree , arr , start , end , index ) : NEW_LINE INDENT if ( start == end ) : NEW_LINE INDENT if ( start % 2 == 0 ) : NEW_LINE INDENT tree [ index ] = arr [ start ] NEW_LINE DEDENT else : NEW_LINE INDENT tree [ index ] = - arr [ start ] NEW_LINE DEDENT return NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE build ( tree , arr , start , mid , 2 * index + 1 ) NEW_LINE build ( tree , arr , mid + 1 , end , 2 * index + 2 ) NEW_LINE tree [ index ] = tree [ 2 * index + 1 ] + tree [ 2 * index + 2 ] NEW_LINE DEDENT
def update ( tree , index , start , end , pos , val ) : NEW_LINE INDENT if ( start == end ) : NEW_LINE INDENT if ( start % 2 == 0 ) : NEW_LINE INDENT tree [ index ] = val NEW_LINE DEDENT else : NEW_LINE INDENT tree [ index ] = - val NEW_LINE DEDENT return NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE if ( mid >= pos ) : NEW_LINE INDENT update ( tree , 2 * index + 1 , start , mid , pos , val ) NEW_LINE DEDENT else : NEW_LINE INDENT update ( tree , 2 * index + 2 , mid + 1 , end , pos , val ) NEW_LINE DEDENT tree [ index ] = tree [ 2 * index + 1 ] + tree [ 2 * index + 2 ] NEW_LINE DEDENT
def FindSum ( tree , start , end , L , R , index ) : NEW_LINE INDENT if ( L > end or R < start ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( L <= start and R >= end ) : NEW_LINE INDENT return tree [ index ] NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE X = FindSum ( tree , start , mid , L , R , 2 * index + 1 ) NEW_LINE Y = FindSum ( tree , mid + 1 , end , L , R , 2 * index + 2 ) NEW_LINE return X + Y NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def DistinctValues ( arr , N ) : NEW_LINE INDENT max_value = - sys . maxsize - 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT max_value = max ( arr ) NEW_LINE DEDENT GCDArr = arr [ 0 ] NEW_LINE GCDArr = gcd ( GCDArr , arr [ i ] ) NEW_LINE answer = max_value // GCDArr NEW_LINE return answer + 1 NEW_LINE DEDENT
def findDay ( Y , B ) : NEW_LINE INDENT lyear , rest , totaldays , day = 0 , 0 , 0 , 0 NEW_LINE Y = ( Y - 1 ) - B NEW_LINE lyear = Y // 4 NEW_LINE rest = Y - lyear NEW_LINE totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 NEW_LINE day = ( totaldays % 7 ) NEW_LINE if ( day == 0 ) : NEW_LINE INDENT print ( "Monday" ) NEW_LINE DEDENT elif ( day == 1 ) : NEW_LINE INDENT print ( "Tuesday" ) NEW_LINE DEDENT elif ( day == 2 ) : NEW_LINE INDENT print ( "Wednesday" ) NEW_LINE DEDENT elif ( day == 3 ) : NEW_LINE INDENT print ( "Thursday" ) NEW_LINE DEDENT elif ( day == 4 ) : NEW_LINE INDENT print ( "Friday" ) NEW_LINE DEDENT elif ( day == 5 ) : NEW_LINE INDENT print ( "Saturday" ) NEW_LINE DEDENT elif ( day == 6 ) : NEW_LINE INDENT print ( "Sunday" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "INPUT YEAR IS WRONG!" ) NEW_LINE DEDENT DEDENT
def maxPossibleDiff ( arr , N ) : NEW_LINE INDENT arr . append ( - 1 ) NEW_LINE arr = arr [ : : - 1 ] NEW_LINE arr . append ( - 1 ) NEW_LINE arr = arr [ : : - 1 ] NEW_LINE maxDiff = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT maxDiff += arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < arr [ i - 1 ] and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT maxDiff -= arr [ i ] NEW_LINE DEDENT DEDENT print ( maxDiff ) NEW_LINE DEDENT
def printArray ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def modifyArray ( arr , N , Q , cntQuery ) : NEW_LINE INDENT arr1 = [ 0 for i in range ( N + 2 ) ] NEW_LINE arr2 = [ 0 for i in range ( N + 2 ) ] NEW_LINE for i in range ( cntQuery ) : NEW_LINE INDENT L = Q [ i ] [ 0 ] + 1 NEW_LINE R = Q [ i ] [ 1 ] + 1 NEW_LINE arr1 [ L ] += 1 NEW_LINE arr1 [ R + 1 ] -= 1 NEW_LINE arr2 [ R + 1 ] -= R - L + 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT arr1 [ i ] += arr1 [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT arr2 [ i ] += arr2 [ i - 1 ] + arr1 [ i ] NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT arr [ i - 1 ] = arr2 [ i ] NEW_LINE DEDENT printArray ( arr , N ) NEW_LINE DEDENT
def gcd ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return x NEW_LINE DEDENT return gcd ( y , x % y ) NEW_LINE DEDENT
def lcm ( x , y ) : NEW_LINE INDENT return ( x * y ) // gcd ( x , y ) NEW_LINE DEDENT
def minimumCost ( x , y ) : NEW_LINE INDENT lcm_ = lcm ( x , y ) NEW_LINE costx = ( lcm_ - x ) // x NEW_LINE costy = ( lcm_ - y ) // y NEW_LINE return costx + costy NEW_LINE DEDENT
def findProduct ( number_1 , number_2 ) : NEW_LINE INDENT if ( number_1 == None or number_2 == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return number_1 * number_2 NEW_LINE DEDENT DEDENT
def calculateProduct ( List , index ) : NEW_LINE INDENT highest = max ( List [ index ] ) NEW_LINE lowest = min ( List [ index ] ) NEW_LINE if ( index + 1 == len ( List ) ) : NEW_LINE INDENT if ( lowest < 0 and highest >= 0 ) : NEW_LINE INDENT return [ highest , lowest ] NEW_LINE DEDENT elif ( lowest <= 0 and highest <= 0 ) : NEW_LINE INDENT return [ None , lowest ] NEW_LINE DEDENT elif ( lowest >= 0 and highest >= 0 ) : NEW_LINE INDENT return [ highest , None ] NEW_LINE DEDENT DEDENT [ positive , negative ] = calculateProduct ( List , index + 1 ) NEW_LINE highPos = findProduct ( highest , positive ) NEW_LINE highNeg = findProduct ( highest , negative ) NEW_LINE lowPos = findProduct ( lowest , positive ) NEW_LINE lowNeg = findProduct ( lowest , negative ) NEW_LINE if ( lowest < 0 and highest >= 0 ) : NEW_LINE INDENT return [ max ( highPos , lowNeg ) , min ( highNeg , lowPos ) ] NEW_LINE DEDENT elif ( lowest <= 0 and highest <= 0 ) : NEW_LINE INDENT return [ lowNeg , lowPos ] NEW_LINE DEDENT elif ( lowest >= 0 and highest >= 0 ) : NEW_LINE INDENT return [ max ( lowPos , highPos ) , min ( lowNeg , highNeg ) ] NEW_LINE DEDENT DEDENT
def calculateSpan ( price , n , S ) : NEW_LINE INDENT S [ 0 ] = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT S [ i ] = 1 NEW_LINE j = i - 1 NEW_LINE while ( j >= 0 ) and ( price [ i ] >= price [ j ] ) : NEW_LINE INDENT S [ i ] += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT
def power ( a , n , d ) : NEW_LINE INDENT res = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( ( n % 2 ) != 0 ) : NEW_LINE INDENT res = ( ( res % d ) * ( a % d ) ) % d NEW_LINE DEDENT a = ( ( a % d ) * ( a % d ) ) % d NEW_LINE n /= 2 NEW_LINE DEDENT return res NEW_LINE DEDENT
def gcd ( p , q , n ) : NEW_LINE INDENT if ( p == q ) : NEW_LINE INDENT return ( power ( p , n , mod ) + power ( q , n , mod ) ) % mod NEW_LINE DEDENT candidate = 1 NEW_LINE num = p - q NEW_LINE sq = ( int ) ( math . sqrt ( num ) ) NEW_LINE for i in range ( 1 , sq ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT X = power ( p , n , i ) NEW_LINE Y = power ( q , n , i ) NEW_LINE temp = ( X + Y ) % i NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT candidate = max ( candidate , i ) NEW_LINE DEDENT temp = ( power ( p , n , num / i ) + power ( q , n , num / i ) ) % ( num / i ) NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT candidate = max ( candidate , num / i ) NEW_LINE DEDENT DEDENT DEDENT return candidate % mod NEW_LINE DEDENT
def minimumSubarrays ( arr , n ) : NEW_LINE INDENT current = 'N' NEW_LINE answer = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( current == 'N' ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT current = 'D' NEW_LINE DEDENT elif ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT current = 'N' NEW_LINE DEDENT else : NEW_LINE INDENT current = 'I' NEW_LINE DEDENT DEDENT elif ( current == 'I' ) : NEW_LINE INDENT if ( arr [ i ] >= arr [ i - 1 ] ) : NEW_LINE INDENT current = 'I' NEW_LINE DEDENT else : NEW_LINE INDENT current = 'N' NEW_LINE answer += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ i ] <= arr [ i - 1 ] ) : NEW_LINE INDENT current = 'D' NEW_LINE DEDENT else : NEW_LINE INDENT current = 'N' NEW_LINE answer += 1 NEW_LINE DEDENT DEDENT DEDENT print ( answer ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def calculateK ( x , y ) : NEW_LINE INDENT g = gcd ( x , y ) NEW_LINE n = y // g NEW_LINE res = n NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT res -= ( res // i ) NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n //= i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( n != 1 ) : NEW_LINE INDENT res -= ( res // n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def nearestPowerOfTwo ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT lg = ( int ) ( math . log2 ( arr [ i ] ) ) NEW_LINE a = ( int ) ( math . pow ( 2 , lg ) ) NEW_LINE b = ( int ) ( math . pow ( 2 , lg + 1 ) ) NEW_LINE if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) : NEW_LINE INDENT print ( a , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def Conversion ( centi ) : NEW_LINE INDENT pixels = ( 96 * centi ) / 2.54 NEW_LINE print ( round ( pixels , 2 ) ) NEW_LINE DEDENT
def minSwaps ( b ) : NEW_LINE INDENT n = len ( b ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( b [ 0 ] [ 0 ] ^ b [ 0 ] [ j ] ^ b [ i ] [ 0 ] ^ b [ i ] [ j ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT rowSum = 0 NEW_LINE colSum = 0 NEW_LINE rowSwap = 0 NEW_LINE colSwap = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT rowSum += b [ i ] [ 0 ] NEW_LINE colSum += b [ 0 ] [ i ] NEW_LINE rowSwap += b [ i ] [ 0 ] == i % 2 NEW_LINE colSwap += b [ 0 ] [ i ] == i % 2 NEW_LINE DEDENT if ( rowSum != n // 2 and rowSum != ( n + 1 ) // 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( colSum != n // 2 and colSum != ( n + 1 ) // 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT if ( colSwap % 2 ) : NEW_LINE INDENT colSwap = n - colSwap NEW_LINE DEDENT if ( rowSwap % 2 ) : NEW_LINE INDENT rowSwap = n - rowSwap NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT colSwap = min ( colSwap , n - colSwap ) NEW_LINE rowSwap = min ( rowSwap , n - rowSwap ) NEW_LINE DEDENT return ( rowSwap + colSwap ) // 2 NEW_LINE DEDENT
def maxNumTrailNine ( n , d ) : NEW_LINE INDENT res = n NEW_LINE cntDigits = int ( log10 ( n ) + 1 ) NEW_LINE p10 = 10 NEW_LINE for i in range ( 1 , cntDigits + 1 ) : NEW_LINE INDENT if ( n % p10 >= d ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = n - n % p10 - 1 NEW_LINE DEDENT p10 = p10 * 10 NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def MinimumNoOfWays ( arr , n ) : NEW_LINE INDENT min_no_of_ways = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT mini_no_of_ways = n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT mini_no_of_ways = n // 2 + 1 NEW_LINE DEDENT return mini_no_of_ways NEW_LINE DEDENT
def count_setbit ( N ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT if ( ( 1 << i ) & N ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def cntWaysConsArray ( A , N ) : NEW_LINE INDENT total = 1 NEW_LINE oddArray = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT total = total * 3 NEW_LINE if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT oddArray *= 2 NEW_LINE DEDENT DEDENT print ( total - oddArray ) NEW_LINE DEDENT
def invertBits ( n ) : NEW_LINE INDENT x = ( int ) ( math . log ( n ) / math . log ( 2 ) ) NEW_LINE m = 1 << x NEW_LINE m = m | m - 1 NEW_LINE n = n ^ m NEW_LINE return n NEW_LINE DEDENT
def invertSum ( A , B ) : NEW_LINE INDENT temp = countSetBits ( A ) + countSetBits ( B ) NEW_LINE print ( invertBits ( temp ) ) NEW_LINE DEDENT
def ValOfTheExpression ( n ) : NEW_LINE INDENT global mod NEW_LINE factorial = [ 0 for i in range ( n + 1 ) ] NEW_LINE factorial [ 0 ] = 1 NEW_LINE factorial [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT factorial [ i ] = ( ( factorial [ i - 1 ] % mod ) * ( i % mod ) ) % mod NEW_LINE DEDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT dp [ i ] = ( ( dp [ i - 1 ] % mod ) * ( factorial [ i ] % mod ) ) % mod NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def minChocolates ( a , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE val , res = 1 , 0 NEW_LINE while ( j < n - 1 ) : NEW_LINE INDENT if ( a [ j ] > a [ j + 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE continue NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT res += val NEW_LINE DEDENT else : NEW_LINE INDENT res += get_sum ( val , i , j ) NEW_LINE DEDENT if ( a [ j ] < a [ j + 1 ] ) : NEW_LINE INDENT val += 1 NEW_LINE DEDENT else : NEW_LINE INDENT val = 1 NEW_LINE DEDENT j += 1 NEW_LINE i = j NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT res += val NEW_LINE DEDENT else : NEW_LINE INDENT res += get_sum ( val , i , j ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def get_sum ( peak , start , end ) : NEW_LINE INDENT count = end - start + 1 NEW_LINE peak = max ( peak , count ) NEW_LINE s = peak + ( ( ( count - 1 ) * count ) >> 1 ) NEW_LINE return s NEW_LINE DEDENT
def RemoveElemArr ( arr , n , k ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return arr NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( j < k or arr [ i ] > arr [ j - k ] ) : NEW_LINE INDENT arr [ j ] , j = arr [ i ] , j + 1 NEW_LINE DEDENT DEDENT while ( len ( arr ) > j ) : NEW_LINE INDENT del arr [ - 1 ] NEW_LINE DEDENT return arr NEW_LINE DEDENT
def printArray ( arr ) : NEW_LINE INDENT for i in arr : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def UtilRemov ( arr , n , k ) : NEW_LINE INDENT arr = RemoveElemArr ( arr , n , k ) NEW_LINE printArray ( arr ) NEW_LINE DEDENT
def countNumberHavingKthBitSet ( N , K ) : NEW_LINE INDENT numbers_rightmost_setbit_K = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT numbers_rightmost_bit_i = ( N + 1 ) // 2 NEW_LINE N -= numbers_rightmost_bit_i NEW_LINE if ( i == K ) : NEW_LINE INDENT numbers_rightmost_setbit_K = numbers_rightmost_bit_i NEW_LINE DEDENT DEDENT print ( numbers_rightmost_setbit_K ) NEW_LINE DEDENT
def pairs_after_removing ( arr , N ) : NEW_LINE INDENT cntPairs = 0 NEW_LINE mp = { } NEW_LINE for i in arr : NEW_LINE INDENT mp [ i ] = mp . get ( i , 0 ) + 1 NEW_LINE DEDENT for element in mp : NEW_LINE INDENT i = element NEW_LINE cntPairs += mp [ i ] * ( mp [ i ] - 1 ) // 2 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT pairs_after_arr_i_removed = cntPairs + 1 - mp [ arr [ i ] ] NEW_LINE print ( pairs_after_arr_i_removed , end = ' ' ) NEW_LINE DEDENT return NEW_LINE DEDENT
def minimumMaxDiff ( nums ) : NEW_LINE INDENT s = { } NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT if ( nums [ i ] % 2 == 0 ) : NEW_LINE INDENT s [ nums [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT s [ nums [ i ] * 2 ] = 1 NEW_LINE DEDENT DEDENT sr = list ( s . keys ( ) ) NEW_LINE res = sr [ - 1 ] - sr [ 0 ] NEW_LINE while ( list ( s . keys ( ) ) [ - 1 ] % 2 == 0 ) : NEW_LINE INDENT r = list ( s . keys ( ) ) NEW_LINE x = r [ - 1 ] NEW_LINE del s [ x ] NEW_LINE s [ x // 2 ] = 1 NEW_LINE rr = list ( s . keys ( ) ) NEW_LINE res = min ( res , rr [ - 1 ] - r [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def bitwiseXorRange ( n ) : NEW_LINE INDENT if ( n % 4 == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n % 4 == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 4 == 2 ) : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def evenXorRange ( l , r ) : NEW_LINE INDENT xor_r = 2 * bitwiseXorRange ( r // 2 ) NEW_LINE xor_l = 2 * bitwiseXorRange ( ( l - 1 ) // 2 ) NEW_LINE return xor_l ^ xor_r NEW_LINE DEDENT
def find_Variance ( n ) : NEW_LINE INDENT numerator = n * n - 1 NEW_LINE ans = ( numerator * 1.0 ) / 12 NEW_LINE return ans NEW_LINE DEDENT
def noOfArraysPossible ( N , M ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans = ans * ( M - i ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def findSum ( a , b , N ) : NEW_LINE INDENT sum = 0 NEW_LINE x = a ^ b NEW_LINE if N % 3 == 0 : NEW_LINE INDENT sum = ( N // 3 ) * ( a + b + x ) NEW_LINE DEDENT elif N % 3 == 1 : NEW_LINE INDENT sum = ( N // 3 ) * ( a + b + x ) + a NEW_LINE DEDENT else : NEW_LINE INDENT sum = ( N // 3 ) * ( a + b + x ) + a + b NEW_LINE DEDENT print ( sum ) NEW_LINE return NEW_LINE DEDENT
def constructArrayWithGivenLCM ( N ) : NEW_LINE INDENT newArr = [ ] NEW_LINE for i in range ( 1 , ceil ( sqrt ( N + 1 ) ) ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT newArr . append ( i ) NEW_LINE if ( N // i != i ) : NEW_LINE INDENT newArr . append ( N // i ) NEW_LINE DEDENT DEDENT DEDENT newArr = sorted ( newArr ) NEW_LINE for i in newArr : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def onesComplement ( n , maxElement ) : NEW_LINE INDENT bits = math . floor ( math . log2 ( maxElement ) ) + 1 NEW_LINE return ( ( 1 << bits ) - 1 ) ^ n NEW_LINE DEDENT
def calculateFactorial ( N ) : NEW_LINE INDENT fact = [ 0 ] * ( N + 1 ) NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT return fact NEW_LINE DEDENT
def cntWaysSelection ( arr , N , K , L , R ) : NEW_LINE INDENT cntWays = 0 NEW_LINE cntNum = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] >= L and arr [ i ] <= R ) : NEW_LINE INDENT cntNum += 1 NEW_LINE DEDENT DEDENT fact = list ( calculateFactorial ( cntNum ) ) NEW_LINE for i in range ( K , cntNum + 1 ) : NEW_LINE INDENT cntWays += fact [ cntNum ] // ( fact [ i ] * fact [ cntNum - i ] ) NEW_LINE DEDENT return cntWays NEW_LINE DEDENT
def TotalAndPair ( arr , N ) : NEW_LINE INDENT totalAND = ( 1 << 30 ) - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT totalAND &= ( arr [ i ] & arr [ j ] ) NEW_LINE DEDENT DEDENT return totalAND NEW_LINE DEDENT
def getPower ( p ) : NEW_LINE INDENT res = 1 NEW_LINE while ( p ) : NEW_LINE INDENT res *= 5 NEW_LINE p -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def printFinalPrices ( arr ) : NEW_LINE INDENT minStk = [ ] NEW_LINE reduce = [ 0 ] * len ( arr ) NEW_LINE for i in range ( len ( arr ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if minStk : NEW_LINE INDENT if minStk [ - 1 ] <= arr [ i ] : NEW_LINE INDENT reduce [ i ] = minStk [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT while minStk and minStk [ - 1 ] > arr [ i ] : NEW_LINE INDENT minStk . pop ( ) NEW_LINE DEDENT if minStk : NEW_LINE INDENT reduce [ i ] = minStk [ - 1 ] NEW_LINE DEDENT DEDENT DEDENT minStk . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] - reduce [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT
def smallestDivisorGr1 ( N ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return N NEW_LINE DEDENT
def findValOfNWithOperat ( N , K ) : NEW_LINE INDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT N += smallestDivisorGr1 ( N ) NEW_LINE DEDENT return N NEW_LINE DEDENT
def smallestDivisorGr1 ( N ) : NEW_LINE INDENT for i in range ( sqrt ( N ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( N % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT return N NEW_LINE DEDENT
def findTripleSum ( A , B , C ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT prod = ( ( ( i % M ) * ( j % M ) ) % M * ( k % M ) ) % M NEW_LINE sum = ( sum + prod ) % M NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def getMaximum ( N , M , mat ) : NEW_LINE INDENT global_max = - 1 * ( sys . maxsize ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT row_min = sys . maxsize NEW_LINE for k in range ( 0 , M ) : NEW_LINE INDENT m = max ( mat [ i ] [ k ] , mat [ j ] [ k ] ) NEW_LINE row_min = min ( row_min , m ) NEW_LINE DEDENT global_max = max ( global_max , row_min ) NEW_LINE DEDENT DEDENT return global_max NEW_LINE DEDENT
def makeTree ( tree , edges , N ) : NEW_LINE INDENT for i in range ( N - 1 ) : NEW_LINE INDENT u = edges [ i ] [ 0 ] NEW_LINE v = edges [ i ] [ 1 ] NEW_LINE tree [ u ] . append ( v ) NEW_LINE DEDENT return tree NEW_LINE DEDENT
def findTheGreatestX ( P , Q ) : NEW_LINE INDENT divisiors = defaultdict ( int ) NEW_LINE i = 2 NEW_LINE while i * i <= Q : NEW_LINE INDENT while ( Q % i == 0 and Q > 1 ) : NEW_LINE INDENT Q //= i NEW_LINE divisiors [ i ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( Q > 1 ) : NEW_LINE INDENT divisiors [ Q ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in divisiors : NEW_LINE INDENT frequency = divisiors [ i ] NEW_LINE temp = P NEW_LINE cur = 0 NEW_LINE while ( temp % i == 0 ) : NEW_LINE INDENT temp //= i NEW_LINE cur += 1 NEW_LINE DEDENT if ( cur < frequency ) : NEW_LINE INDENT ans = P NEW_LINE break NEW_LINE DEDENT temp = P NEW_LINE for j in range ( cur , frequency - 1 , - 1 ) : NEW_LINE INDENT temp //= i NEW_LINE DEDENT ans = max ( temp , ans ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def divisorCount ( n ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i == n // i ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x += 2 NEW_LINE DEDENT DEDENT if ( i * i > n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def minvalue_y ( x ) : NEW_LINE INDENT a = divisorCount ( x ) NEW_LINE y = x + 1 NEW_LINE while ( ( a & 1 ) == ( divisorCount ( y ) & 1 ) ) : NEW_LINE INDENT y += 1 NEW_LINE DEDENT return y NEW_LINE DEDENT
def minvalue_y ( x ) : NEW_LINE INDENT n = int ( pow ( x , 1 / 2 ) ) NEW_LINE if ( n * n == x ) : NEW_LINE INDENT return x + 1 NEW_LINE DEDENT return ( pow ( n + 1 , 2 ) ) NEW_LINE DEDENT
def alternatingSumOfFirst_N ( N ) : NEW_LINE INDENT alternateSum = 0 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT alternateSum = ( - N ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT alternateSum = ( N + 1 ) // 2 NEW_LINE DEDENT return alternateSum NEW_LINE DEDENT
def minStartValue ( nums ) : NEW_LINE INDENT minValue = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT sum += nums [ i ] NEW_LINE minValue = min ( minValue , sum ) NEW_LINE DEDENT startValue = 1 - minValue NEW_LINE return startValue NEW_LINE DEDENT
def countSubArrayRemove ( arr , N ) : NEW_LINE INDENT prefix_element_count = { } NEW_LINE suffix_element_count = { } NEW_LINE total_sum_of_elements = 0 NEW_LINE i = N - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT total_sum_of_elements += arr [ i ] NEW_LINE suffix_element_count [ arr [ i ] ] = suffix_element_count . get ( arr [ i ] , 0 ) + 1 NEW_LINE i -= 1 NEW_LINE DEDENT prefix_sum = 0 NEW_LINE suffix_sum = 0 NEW_LINE count_subarray_equal_sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT prefix_sum += arr [ i ] NEW_LINE prefix_element_count [ arr [ i ] ] = prefix_element_count . get ( arr [ i ] , 0 ) + 1 NEW_LINE suffix_sum = total_sum_of_elements - prefix_sum NEW_LINE suffix_element_count [ arr [ i ] ] = suffix_element_count . get ( arr [ i ] , 0 ) - 1 NEW_LINE difference = prefix_sum - suffix_sum NEW_LINE number_of_subarray_at_i_split = ( prefix_element_count . get ( difference , 0 ) + suffix_element_count . get ( - difference , 0 ) ) NEW_LINE count_subarray_equal_sum += number_of_subarray_at_i_split NEW_LINE DEDENT return count_subarray_equal_sum NEW_LINE DEDENT
def countXORSetBitsAdjElemRange1_N ( N ) : NEW_LINE INDENT total_set_bits = 0 NEW_LINE bit_Position = 1 NEW_LINE while ( N ) : NEW_LINE INDENT total_set_bits += ( ( N + 1 ) // 2 * bit_Position ) NEW_LINE N -= ( N + 1 ) // 2 NEW_LINE bit_Position += 1 NEW_LINE DEDENT return total_set_bits NEW_LINE DEDENT
def checkPerfectSquare ( N ) : NEW_LINE INDENT if ( N <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sq = sqrt ( N ) NEW_LINE if ( floor ( sq ) == ceil ( sq ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def checktwoSidesareRighTriangle ( A , B ) : NEW_LINE INDENT checkTriangle = False NEW_LINE if ( checkPerfectSquare ( A * A + B * B ) ) : NEW_LINE INDENT checkTriangle = True NEW_LINE DEDENT if ( checkPerfectSquare ( A * A - B * B ) ) : NEW_LINE INDENT checkTriangle = True NEW_LINE DEDENT if ( checkPerfectSquare ( B * B - A * A ) ) : NEW_LINE INDENT checkTriangle = True NEW_LINE DEDENT return checkTriangle NEW_LINE DEDENT
def valid ( i , j ) : NEW_LINE INDENT if ( i >= 0 and j >= 0 and i < r and j < c ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def find ( i , j , v ) : NEW_LINE INDENT s = 0 NEW_LINE for k in range ( 8 ) : NEW_LINE INDENT ni = i + dir [ k ] [ 0 ] NEW_LINE nj = j + dir [ k ] [ 1 ] NEW_LINE if ( valid ( ni , nj ) ) : NEW_LINE INDENT s += v [ ni ] [ nj ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def findsumofneighbors ( M ) : NEW_LINE INDENT v = [ [ 0 for i in range ( c ) ] for j in range ( r ) ] NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT v [ i ] [ j ] = find ( i , j , M ) NEW_LINE print ( v [ i ] [ j ] , end = " " ) NEW_LINE DEDENT print ( "" ) NEW_LINE DEDENT DEDENT
def TotalBitwiseORPair ( arr , N ) : NEW_LINE INDENT totalOR = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT totalOR |= arr [ i ] NEW_LINE DEDENT return totalOR NEW_LINE DEDENT
def checkSolveable ( n , m ) : NEW_LINE INDENT if n == 1 or m == 1 : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT elif m == 2 and n == 2 : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def printFinalArray ( a , n , operations , p , capacity ) : NEW_LINE INDENT curr = 0 NEW_LINE picked = False NEW_LINE for i in range ( p ) : NEW_LINE INDENT s = operations [ i ] NEW_LINE flag = False NEW_LINE if ( curr != 0 ) : NEW_LINE INDENT curr -= 1 NEW_LINE break NEW_LINE DEDENT if ( curr != n - 1 ) : NEW_LINE INDENT curr += 1 NEW_LINE break NEW_LINE DEDENT if ( picked == False and a [ curr ] != 0 ) : NEW_LINE INDENT picked = True NEW_LINE a [ curr ] -= 1 NEW_LINE break NEW_LINE DEDENT if ( picked == True and a [ curr ] != capacity ) : NEW_LINE INDENT picked = False NEW_LINE a [ curr ] += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT flag = True NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def constructArray ( A , N ) : NEW_LINE INDENT left = [ 0 ] * ( N + 1 ) NEW_LINE right = [ 0 ] * ( N + 1 ) NEW_LINE X = [ 0 ] * ( N + 1 ) NEW_LINE Y = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT X [ i ] = left [ A [ i ] ] NEW_LINE left [ A [ i ] ] += 1 NEW_LINE DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT Y [ i ] = right [ A [ i ] ] NEW_LINE right [ A [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT print ( Y [ i ] - X [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( math . sqrt ( n ) + 1 ) , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def largestElement ( head_ref ) : NEW_LINE INDENT Max = - 10000000 NEW_LINE head = head_ref NEW_LINE while ( head != None ) : NEW_LINE INDENT if ( Max < head . data ) : NEW_LINE INDENT Max = head . data NEW_LINE DEDENT head = head . next NEW_LINE DEDENT return Max NEW_LINE DEDENT
def probablityPrimeprod ( N ) : NEW_LINE INDENT N_E = 3 * N NEW_LINE N_S = power ( 6 , N ) NEW_LINE print ( N_E , " / " , N_S ) NEW_LINE DEDENT
def checkPalindrome ( N ) : NEW_LINE INDENT rev = 0 NEW_LINE temp = N NEW_LINE while ( N != 0 ) : NEW_LINE INDENT rev = rev * 10 + N % 10 NEW_LINE N = N // 10 NEW_LINE DEDENT N = temp NEW_LINE if ( N == rev ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def closestSmallerPalindrome ( N ) : NEW_LINE INDENT while N >= 0 and not checkPalindrome ( N ) : NEW_LINE INDENT N -= 1 NEW_LINE DEDENT return N NEW_LINE DEDENT
def MinimumOperationReq ( N ) : NEW_LINE INDENT cntDecr = 0 NEW_LINE temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT X = int ( pow ( temp , 1 / 2 ) ) NEW_LINE if ( X * X == temp ) : NEW_LINE INDENT break NEW_LINE DEDENT temp = temp - 2 NEW_LINE cntDecr += 1 NEW_LINE DEDENT cntIncr = 0 NEW_LINE while ( True ) : NEW_LINE INDENT X = int ( pow ( N , 1 / 2 ) ) NEW_LINE if ( X * X == N ) : NEW_LINE INDENT break NEW_LINE DEDENT N = N + 2 NEW_LINE cntIncr += 1 NEW_LINE DEDENT return min ( cntIncr , cntDecr ) NEW_LINE DEDENT
def power ( x , N ) : NEW_LINE INDENT res = 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N & 1 ) : NEW_LINE INDENT res = ( res * x ) % M NEW_LINE DEDENT x = ( x * x ) % M NEW_LINE N = N >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def moduloInverse ( X ) : NEW_LINE INDENT return power ( X , M - 2 ) NEW_LINE DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return GCD ( b , a % b ) NEW_LINE DEDENT DEDENT
def check ( x , y ) : NEW_LINE INDENT if ( GCD ( x , y ) == 1 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def findSubArray ( arr , k ) : NEW_LINE INDENT ans = [ ( 0 , 0 ) ] NEW_LINE sm = 0 NEW_LINE i = 0 NEW_LINE found = 0 NEW_LINE while ( i < k ) : NEW_LINE INDENT sm += arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT if ( sm % 3 == 0 ) : NEW_LINE INDENT ans = [ ( 0 , i - 1 ) ] NEW_LINE found = 1 NEW_LINE DEDENT for j in range ( i , len ( arr ) , 1 ) : NEW_LINE INDENT if ( found == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT sm = sm + arr [ j ] - arr [ j - k ] NEW_LINE if ( sm % 3 == 0 ) : NEW_LINE INDENT ans = [ ( j - k + 1 , j ) ] NEW_LINE found = 1 NEW_LINE DEDENT DEDENT if ( found == 0 ) : NEW_LINE INDENT ans = [ ( - 1 , 0 ) ] NEW_LINE DEDENT if ( ans [ 0 ] [ 0 ] == - 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( ans [ 0 ] [ 0 ] , ans [ 0 ] [ 1 ] + 1 , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def sumOfProd ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum * sum NEW_LINE DEDENT
def rev ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = ( rev_num * 10 + num % 10 ) NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT x = ( n + 7 ) // 8 NEW_LINE if ( ( n + 7 ) % 8 == 0 and isPower ( 10 , x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def mul_2 ( K ) : NEW_LINE INDENT temp = [ [ 0 for x in range ( K + 1 ) ] for y in range ( K + 1 ) ] NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 1 , K + 1 ) : NEW_LINE INDENT for k in range ( 1 , K + 1 ) : NEW_LINE INDENT temp [ i ] [ j ] = ( ( temp [ i ] [ j ] + ( T [ i ] [ k ] * T [ k ] [ j ] ) % mod ) % mod ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 1 , K + 1 ) : NEW_LINE INDENT T [ i ] [ j ] = temp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
def mul_1 ( K ) : NEW_LINE INDENT temp = [ [ 0 for x in range ( K + 1 ) ] for y in range ( K + 1 ) ] NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 1 , K + 1 ) : NEW_LINE INDENT for k in range ( 1 , K + 1 ) : NEW_LINE INDENT temp [ i ] [ j ] = ( ( temp [ i ] [ j ] + ( result [ i ] [ k ] * T [ k ] [ j ] ) % mod ) % mod ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 1 , K + 1 ) : NEW_LINE INDENT result [ i ] [ j ] = temp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
def matrix_pow ( K , n ) : NEW_LINE INDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT result [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT while ( n > 0 ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT mul_1 ( K ) NEW_LINE DEDENT mul_2 ( K ) NEW_LINE n //= 2 NEW_LINE DEDENT DEDENT
def countFreq ( arr , n ) : NEW_LINE INDENT mp1 = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp1 [ arr [ i ] ] += 1 NEW_LINE mp2 = defaultdict ( int ) NEW_LINE for it in mp1 : NEW_LINE INDENT mp2 [ mp1 [ it ] ] += 1 NEW_LINE DEDENT M = - sys . maxsize - 1 NEW_LINE for it in mp2 : NEW_LINE INDENT M = max ( M , mp2 [ it ] ) NEW_LINE for it in mp2 : NEW_LINE INDENT if ( M == mp2 [ it ] ) : NEW_LINE INDENT return it NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT DEDENT DEDENT
def computeSalary ( basic , grade ) : NEW_LINE INDENT hra = 0.2 * basic NEW_LINE da = 0.5 * basic NEW_LINE pf = 0.11 * basic NEW_LINE if grade == 'A' : NEW_LINE INDENT allowance = 1700.0 NEW_LINE DEDENT elif grade == 'B' : NEW_LINE INDENT allowance = 1500.0 NEW_LINE DEDENT else : NEW_LINE INDENT allowance = 1300.0 NEW_LINE DEDENT gross = round ( basic + hra + da + allowance - pf ) NEW_LINE return gross NEW_LINE DEDENT
def maxDisconnected ( N , E ) : NEW_LINE INDENT curr = 1 NEW_LINE rem = E NEW_LINE while ( rem > 0 ) : NEW_LINE INDENT rem = rem - min ( curr , rem ) NEW_LINE curr += 1 NEW_LINE DEDENT if ( curr > 1 ) : NEW_LINE INDENT return N - curr NEW_LINE DEDENT else : NEW_LINE INDENT return N NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def findSum ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( gcd ( i , N ) == 1 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def solve ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in arr : NEW_LINE INDENT mp [ i ] = mp . get ( i , 0 ) + 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for x in mp : NEW_LINE INDENT cnt += ( ( mp [ x ] ) * ( mp [ x ] - 1 ) // 2 ) NEW_LINE DEDENT ans = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans [ i ] = cnt - ( mp [ arr [ i ] ] - 1 ) NEW_LINE DEDENT for i in ans : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def nthRoot ( A , N ) : NEW_LINE INDENT xPre = random . random ( ) % 10 NEW_LINE eps = 1e-3 NEW_LINE delX = sys . maxsize NEW_LINE xK = 0 NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) / N ) NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT
def RMNValue ( arr , n , k ) : NEW_LINE INDENT Nth = 0 NEW_LINE mean = 0.0 NEW_LINE root = 0.0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Nth += pow ( arr [ i ] , k ) NEW_LINE DEDENT mean = ( Nth // ( n ) ) NEW_LINE root = nthRoot ( mean , k ) NEW_LINE return root NEW_LINE DEDENT
def xor_operations ( N , arr , M , K ) : NEW_LINE INDENT if M < 0 or M >= N : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if K < 0 or K >= N - M : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for _ in range ( M ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT value = arr [ i ] ^ arr [ i + 1 ] NEW_LINE temp . append ( value ) NEW_LINE DEDENT arr = temp [ : ] NEW_LINE DEDENT ans = arr [ K ] NEW_LINE return ans NEW_LINE DEDENT
def checkPalindromeB ( N , B ) : NEW_LINE INDENT rev = 0 NEW_LINE N1 = N NEW_LINE while ( N1 > 0 ) : NEW_LINE INDENT rev = rev * B + N1 % B NEW_LINE N1 = N1 // B NEW_LINE DEDENT return N == rev NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def findProduct ( N ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( gcd ( i , N ) == 1 ) : NEW_LINE INDENT result *= i NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def countEqual ( n ) : NEW_LINE INDENT return ( n + 1 ) // 2 NEW_LINE DEDENT
def smallSubarray ( arr , n , total_sum ) : NEW_LINE INDENT m = { } NEW_LINE length = sys . maxsize NEW_LINE prefixSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefixSum += arr [ i ] NEW_LINE if ( prefixSum == total_sum ) : NEW_LINE INDENT length = min ( length , i + 1 ) NEW_LINE DEDENT m [ prefixSum ] = i NEW_LINE if ( ( prefixSum - total_sum ) in m . keys ( ) ) : NEW_LINE INDENT length = min ( length , i - m [ prefixSum - total_sum ] ) NEW_LINE DEDENT DEDENT return length NEW_LINE DEDENT
def smallestSubarrayremoved ( arr , n , k ) : NEW_LINE INDENT total_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT elif ( arr [ i ] < k ) : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT total_sum += arr [ i ] NEW_LINE DEDENT if ( total_sum == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return smallSubarray ( arr , n , total_sum ) NEW_LINE DEDENT DEDENT
def find ( par , x ) : NEW_LINE INDENT if ( par [ x ] == x ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT par [ x ] = find ( par , par [ x ] ) NEW_LINE return par [ x ] NEW_LINE DEDENT DEDENT
def functionMax ( arr , n ) : NEW_LINE INDENT setBit = [ [ ] for i in range ( 32 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 32 ) : NEW_LINE INDENT if ( arr [ i ] & ( 1 << j ) ) : NEW_LINE INDENT setBit [ j ] . append ( i ) NEW_LINE DEDENT DEDENT DEDENT i = 31 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( len ( setBit [ i ] ) == 1 ) : NEW_LINE INDENT temp = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ setBit [ i ] [ 0 ] ] NEW_LINE arr [ setBit [ i ] [ 0 ] ] = temp NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT maxAnd = arr [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT maxAnd = ( maxAnd & ( ~ arr [ i ] ) ) NEW_LINE DEDENT return maxAnd NEW_LINE DEDENT
def modexp ( x , n , m ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return modexp ( ( x * x ) % m , n / 2 , m ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 , m ) % m ) NEW_LINE DEDENT DEDENT DEDENT
def modInverse ( x , m ) : NEW_LINE INDENT return modexp ( x , m - 2 , m ) NEW_LINE DEDENT
def countNumbers ( N ) : NEW_LINE INDENT m = 1000000007 NEW_LINE factorial = [ 0 for x in range ( 100001 ) ] NEW_LINE factorial [ 0 ] = 1 NEW_LINE for i in range ( 1 , 100001 ) : NEW_LINE INDENT factorial [ i ] = ( factorial [ i - 1 ] * i ) % m NEW_LINE DEDENT count = [ 0 for x in range ( 10 ) ] NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE DEDENT length = len ( N ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT count [ int ( N [ i ] ) ] += 1 NEW_LINE DEDENT result = factorial [ int ( length ) ] NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT result = ( result * modInverse ( factorial [ int ( count [ i ] ) ] , m ) ) % m NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT
def max_valid_triplet ( A , n ) : NEW_LINE INDENT ans = - 1 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( A [ i ] < A [ j ] and A [ j ] < A [ k ] ) : NEW_LINE INDENT value = A [ i ] + A [ j ] * A [ k ] NEW_LINE if ( value > ans ) : NEW_LINE INDENT ans = value NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def productOfProperDivi ( num ) : NEW_LINE INDENT return ans [ num ] NEW_LINE DEDENT
def findlcm ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ( ( ( i * ans ) ) // ( __gcd ( i , ans ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def highestPower ( n ) : NEW_LINE INDENT lcm = findlcm ( n ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT x = int ( pow ( 2 , i ) ) NEW_LINE if ( lcm % x == 0 ) : NEW_LINE INDENT ans = i NEW_LINE DEDENT if ( x > n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( n ** 1 / 2 ) , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countofPermutations ( N ) : NEW_LINE INDENT return int ( ( 3 * pow ( 2 , N - 1 ) ) ) NEW_LINE DEDENT
def answer ( L , R ) : NEW_LINE INDENT if ( 2 * L <= R ) : NEW_LINE INDENT print ( L , "," , 2 * L ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def spf_array ( spf ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , 1000 , 1 ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , 1000 , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i < 1000 ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT j = i * i NEW_LINE while ( j < 1000 ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def frequent_prime ( arr , N , K ) : NEW_LINE INDENT spf_array ( spf ) NEW_LINE Hmap = { } NEW_LINE result = [ ] NEW_LINE i = 0 NEW_LINE c = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE while ( x != 1 ) : NEW_LINE INDENT Hmap [ spf [ x ] ] = Hmap . get ( spf [ x ] , 0 ) + 1 NEW_LINE x = x // spf [ x ] NEW_LINE DEDENT DEDENT if ( 1 in Hmap ) : NEW_LINE INDENT Hmap . pop ( 1 ) NEW_LINE DEDENT for key , value in Hmap . items ( ) : NEW_LINE INDENT primeNum = key NEW_LINE frequency = value NEW_LINE if ( frequency % K == 0 ) : NEW_LINE INDENT result . append ( primeNum ) NEW_LINE DEDENT DEDENT result = result [ : : - 1 ] NEW_LINE if ( len ( result ) > 0 ) : NEW_LINE INDENT for it in result : NEW_LINE INDENT print ( it , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "{}" ) NEW_LINE DEDENT DEDENT
def initialize_xor ( arr , n ) : NEW_LINE INDENT global total_xor NEW_LINE for i in range ( n ) : NEW_LINE INDENT total_xor = total_xor ^ arr [ i ] NEW_LINE DEDENT DEDENT
def gcd ( x , y ) : NEW_LINE INDENT if ( x % y == 0 ) : NEW_LINE INDENT return y NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( y , x % y ) NEW_LINE DEDENT DEDENT
def countPairwiseCoprime ( N , M ) : NEW_LINE INDENT answer = 1 NEW_LINE g = gcd ( N , M ) NEW_LINE temp = g NEW_LINE for i in range ( 2 , g + 1 ) : NEW_LINE INDENT if i * i > g : NEW_LINE INDENT break NEW_LINE DEDENT if ( temp % i == 0 ) : NEW_LINE INDENT answer += 1 NEW_LINE while ( temp % i == 0 ) : NEW_LINE INDENT temp //= i NEW_LINE DEDENT DEDENT DEDENT if ( temp != 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT return answer NEW_LINE DEDENT
def countCoprimePair ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( countPairwiseCoprime ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) , end = " " ) NEW_LINE DEDENT DEDENT
def prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def getProduct ( a , n ) : NEW_LINE INDENT p = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT p *= abs ( a [ i ] - a [ j ] ) NEW_LINE DEDENT DEDENT return p NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT
def diffCube ( N ) : NEW_LINE INDENT return isPerfectSquare ( 12 * N - 3 ) NEW_LINE DEDENT
def totalCountDifference ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n + totalCountDifference ( n // 2 ) NEW_LINE DEDENT
def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT
def findLCM ( arr ) : NEW_LINE INDENT global Landau NEW_LINE nth_lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT nth_lcm = lcm ( nth_lcm , arr [ i ] ) NEW_LINE DEDENT Landau = max ( Landau , nth_lcm ) NEW_LINE DEDENT
def findWays ( arr , i , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT findLCM ( arr ) NEW_LINE DEDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT arr . append ( j ) NEW_LINE findWays ( arr , j , n - j ) NEW_LINE arr . pop ( ) NEW_LINE DEDENT DEDENT
def Landau_function ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE findWays ( arr , 1 , n ) NEW_LINE print ( Landau ) NEW_LINE DEDENT
def findSum ( arr , n , left , right ) : NEW_LINE INDENT k = right - left + 1 NEW_LINE d = arr [ 1 ] // arr [ 0 ] NEW_LINE ans = arr [ left - 1 ] NEW_LINE if d == 1 : NEW_LINE INDENT ans = ans * d * k NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans * ( d ** k - 1 ) // ( d - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countRepeatingDigits ( N ) : NEW_LINE INDENT res = 0 NEW_LINE cnt = [ 0 ] * 10 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT rem = N % 10 NEW_LINE cnt [ rem ] += 1 NEW_LINE N = N // 10 NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT if ( cnt [ i ] > 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT res = 1 NEW_LINE if r > n - r : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def solve ( n , m , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT sum += nCr ( n , i ) * nCr ( m , k - i ) NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT res = 1 NEW_LINE if ( r > n - r ) : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def modPower ( a , b , M ) : NEW_LINE INDENT res = 1 NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res * a % M NEW_LINE DEDENT a = a * a % M NEW_LINE b >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def Cal_min ( arr , n , k ) : NEW_LINE INDENT diff_mod = set ( [ ] ) NEW_LINE count_mod = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT diff_mod . add ( arr [ i ] % k ) NEW_LINE count_mod [ arr [ i ] % k ] += 1 NEW_LINE DEDENT return Find_min ( diff_mod , count_mod , k ) NEW_LINE DEDENT
def canBreakN ( n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT m = i * ( i + 1 ) // 2 NEW_LINE if ( m > n ) : NEW_LINE INDENT break NEW_LINE DEDENT k = n - m NEW_LINE if ( k % i ) : NEW_LINE INDENT continue NEW_LINE DEDENT print ( i ) NEW_LINE return NEW_LINE DEDENT print ( "-1" ) NEW_LINE DEDENT
def minimumSteps ( arr , n ) : NEW_LINE INDENT dat = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dat [ arr [ i - 1 ] ] = i NEW_LINE DEDENT b = [ 0 ] * ( n + 1 ) NEW_LINE j = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT c = 1 NEW_LINE j = dat [ i ] NEW_LINE while ( j != i ) : NEW_LINE INDENT c += 1 NEW_LINE j = dat [ j ] NEW_LINE DEDENT b [ i ] = c NEW_LINE DEDENT print ( findlcm ( b , n ) ) NEW_LINE DEDENT
def maximum ( a , b ) : NEW_LINE INDENT if ( a > b ) : NEW_LINE INDENT return a NEW_LINE DEDENT return b NEW_LINE DEDENT
def check ( num ) : NEW_LINE INDENT root = ( int ) ( math . sqrt ( num ) ) NEW_LINE poww = ( int ) ( math . log ( root ) / math . log ( 2 ) ) NEW_LINE if ( num == ( int ) ( pow ( 2 , poww ) * ( pow ( 2 , poww + 1 ) - 1 ) ) ) : NEW_LINE INDENT if ( isPrime ( poww + 1 ) ) : NEW_LINE INDENT if ( isPrime ( ( int ) ( pow ( 2 , poww + 1 ) ) - 1 ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return bool ( False ) NEW_LINE DEDENT elif ( n == 2 or n == 3 ) : NEW_LINE INDENT return bool ( True ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return bool ( False ) NEW_LINE DEDENT for i in range ( 5 , sqrt ( n + 1 ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return bool ( False ) NEW_LINE DEDENT DEDENT return bool ( True ) NEW_LINE DEDENT DEDENT
def isTriplet ( ar , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( abs ( ar [ i ] - ar [ j ] ) == 1 or abs ( ar [ j ] - ar [ k ] ) == 1 or abs ( ar [ i ] - ar [ k ] ) == 1 ) : NEW_LINE INDENT x = ar [ i ] * ar [ i ] NEW_LINE y = ar [ j ] * ar [ j ] NEW_LINE z = ar [ k ] * ar [ k ] NEW_LINE if ( x == y + z or y == x + z or z == x + y ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def closestDivisors ( n ) : NEW_LINE INDENT for i in range ( ceil ( sqrt ( n + 2 ) ) , - 1 , - 1 ) : NEW_LINE INDENT if ( ( n + 1 ) % i == 0 ) : NEW_LINE INDENT print ( i , "," , ( n + 1 ) // i ) NEW_LINE break NEW_LINE DEDENT if ( ( n + 2 ) % i == 0 ) : NEW_LINE INDENT print ( i , "," , ( n + 2 ) // i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def count ( n ) : NEW_LINE INDENT phi = [ 0 ] * ( n + 1 ) NEW_LINE divs = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] += i NEW_LINE for j in range ( i * 2 , n + 1 , i ) : NEW_LINE INDENT phi [ j ] -= phi [ i ] NEW_LINE DEDENT for j in range ( i , n + 1 , i ) : NEW_LINE INDENT divs [ j ] += 1 NEW_LINE DEDENT DEDENT return ( n - phi [ n ] - divs [ n ] + 1 ) NEW_LINE DEDENT
def inorder ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT inorder ( node . left ) NEW_LINE print ( node . data , end = ' ' ) NEW_LINE inorder ( node . right ) NEW_LINE DEDENT
def MinimumString ( x ) : NEW_LINE INDENT b = 1 NEW_LINE left_lim = sqrt ( x ) + 1.0 NEW_LINE right_lim = sqrt ( x ) + 2.0 NEW_LINE for i in range ( int ( left_lim ) , int ( right_lim ) + 1 ) : NEW_LINE INDENT if ( i > left_lim and i < right_lim ) : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT return b + r NEW_LINE DEDENT
def isPerfectSquare ( N ) : NEW_LINE INDENT floorSqrt = floor ( sqrt ( N ) ) NEW_LINE return ( N == floorSqrt * floorSqrt ) NEW_LINE DEDENT
def legendreFunction ( N ) : NEW_LINE INDENT while ( N % 4 == 0 ) : NEW_LINE INDENT N //= 4 NEW_LINE DEDENT if ( N % 8 != 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def minSquares ( N ) : NEW_LINE INDENT if ( isPerfectSquare ( N ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if i * i < N : NEW_LINE INDENT break NEW_LINE DEDENT if ( isPerfectSquare ( N - i * i ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT if ( legendreFunction ( N ) ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT return 4 NEW_LINE DEDENT
def is_distinct ( n , k ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT tmp = n % i NEW_LINE if ( tmp in s ) : NEW_LINE INDENT return False NEW_LINE DEDENT s . add ( tmp ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def getDivisors ( min , n ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( min , n ) : NEW_LINE INDENT if ( n % i == 0 and n // i >= i ) : NEW_LINE INDENT total += 1 NEW_LINE if ( n // i > i ) : NEW_LINE INDENT total += getDivisors ( i , n // i ) NEW_LINE DEDENT DEDENT DEDENT return total NEW_LINE DEDENT
def findWays ( arr , i , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT printVector ( arr ) NEW_LINE DEDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT arr . append ( j ) NEW_LINE findWays ( arr , j , n - j ) NEW_LINE del arr [ - 1 ] NEW_LINE DEDENT DEDENT
def spt_function ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE findWays ( arr , 1 , n ) NEW_LINE print ( spt ) NEW_LINE DEDENT
def isUgly ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return ( isUgly ( n // 2 ) ) NEW_LINE DEDENT if ( n % 3 == 0 ) : NEW_LINE INDENT return ( isUgly ( n // 3 ) ) NEW_LINE DEDENT if ( n % 5 == 0 ) : NEW_LINE INDENT return ( isUgly ( n // 5 ) ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def findMinDenomin ( n ) : NEW_LINE INDENT return log2 ( n ) + 1 NEW_LINE DEDENT
def calculate ( p , q ) : NEW_LINE INDENT mod = 998244353 NEW_LINE expo = 0 NEW_LINE expo = mod - 2 NEW_LINE while ( expo ) : NEW_LINE INDENT if ( expo & 1 ) : NEW_LINE INDENT p = ( p * q ) % mod NEW_LINE DEDENT q = ( q * q ) % mod NEW_LINE expo >>= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
def powerOptimised ( a , n ) : NEW_LINE INDENT ans = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT last_bit = ( n & 1 ) NEW_LINE if ( last_bit ) : NEW_LINE INDENT ans = ans * a NEW_LINE DEDENT a = a * a NEW_LINE n = n >> 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxGCD ( N ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return N // i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def findMaximumGcd ( n ) : NEW_LINE INDENT max_gcd = 1 NEW_LINE i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if ( i > max_gcd ) : NEW_LINE INDENT max_gcd = i NEW_LINE DEDENT if ( ( n / i != i ) and ( n / i != n ) and ( ( n / i ) > max_gcd ) ) : NEW_LINE INDENT max_gcd = n / i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ( int ( max_gcd ) ) NEW_LINE DEDENT
def findContent ( arr , n ) : NEW_LINE INDENT content = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT content = gcd ( content , arr [ i ] ) NEW_LINE DEDENT return content NEW_LINE DEDENT
def inverseEqual ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT present_index = arr [ i ] - 1 NEW_LINE brr [ present_index ] = i + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != brr [ i ] : NEW_LINE INDENT print ( "NO" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "YES" ) NEW_LINE DEDENT
def linearCongruentialMethod ( Xo , m , a , c , randomNums , noOfRandomNums ) : NEW_LINE INDENT randomNums [ 0 ] = Xo NEW_LINE for i in range ( 1 , noOfRandomNums ) : NEW_LINE INDENT randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m NEW_LINE DEDENT DEDENT
def multiplicativeCongruentialMethod ( Xo , m , a , randomNums , noOfRandomNums ) : NEW_LINE INDENT randomNums [ 0 ] = Xo NEW_LINE for i in range ( 1 , noOfRandomNums ) : NEW_LINE INDENT randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m NEW_LINE DEDENT DEDENT
def additiveCongruentialMethod ( Xo , m , c , randomNums , noOfRandomNums ) : NEW_LINE INDENT randomNums [ 0 ] = Xo NEW_LINE for i in range ( 1 , noOfRandomNums ) : NEW_LINE INDENT randomNums [ i ] = ( randomNums [ i - 1 ] + c ) % m NEW_LINE DEDENT DEDENT
def power ( a , b , m ) : NEW_LINE INDENT a %= m NEW_LINE res = 1 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( ( res % m ) * ( a % m ) ) % m NEW_LINE DEDENT a = ( ( a % m ) * ( a % m ) ) % m NEW_LINE b >>= 1 NEW_LINE DEDENT return res % m NEW_LINE DEDENT
def productOfDivisors ( p , n ) : NEW_LINE INDENT prime = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT prime [ p [ i ] ] += 1 NEW_LINE DEDENT product , d = 1 , 1 NEW_LINE for itr in prime . keys ( ) : NEW_LINE INDENT val = ( power ( itr , ( prime [ itr ] ) * ( prime [ itr ] + 1 ) // 2 , MOD ) ) NEW_LINE product = ( power ( product , prime [ itr ] + 1 , MOD ) * power ( val , d , MOD ) % MOD ) NEW_LINE d = ( d * ( prime [ itr ] + 1 ) ) % ( MOD - 1 ) NEW_LINE DEDENT return product NEW_LINE DEDENT
def numberOfObjects ( N , M ) : NEW_LINE INDENT initial = min ( N , M ) NEW_LINE final = ( N + M ) // 3 NEW_LINE return min ( initial , final ) NEW_LINE DEDENT
def MaxSubarrayLength ( arr , n , k ) : NEW_LINE INDENT left = - 1 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] % k ) != 0 ) : NEW_LINE INDENT if ( left == - 1 ) : NEW_LINE INDENT left = i NEW_LINE DEDENT right = i NEW_LINE DEDENT sum += arr [ i ] NEW_LINE DEDENT if ( ( sum % k ) != 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT elif ( left == - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT prefix_length = left + 1 NEW_LINE suffix_length = n - right NEW_LINE return n - min ( prefix_length , suffix_length ) NEW_LINE DEDENT DEDENT
def findDistinct ( arr , n ) : NEW_LINE INDENT maximum = max ( arr ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( maximum // gcd ( arr [ 0 ] , arr [ 1 ] ) ) NEW_LINE DEDENT k = gcd ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT k = gcd ( k , arr [ i ] ) NEW_LINE DEDENT return ( maximum // k ) NEW_LINE DEDENT
def power ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( b == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT tmp = power ( a , b // 2 ) NEW_LINE result = tmp * tmp NEW_LINE if ( b % 2 == 1 ) : NEW_LINE INDENT result *= a NEW_LINE DEDENT return result NEW_LINE DEDENT
def solve ( X , Y ) : NEW_LINE INDENT if ( X > Y ) : NEW_LINE INDENT temp = X NEW_LINE X = Y NEW_LINE Y = temp NEW_LINE DEDENT if ( X == Y ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( Y % X == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT DEDENT
def findWinner ( n , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT elif ( ( n & 1 ) or n == 2 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp = n NEW_LINE val = 1 NEW_LINE while ( tmp > k and tmp % 2 == 0 ) : NEW_LINE INDENT tmp //= 2 NEW_LINE val *= 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( tmp ) ) + 1 ) : NEW_LINE INDENT while ( tmp % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE tmp //= i NEW_LINE DEDENT DEDENT if ( tmp > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( val == n ) : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT elif ( n / tmp == 2 and cnt == 1 ) : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT DEDENT DEDENT
def countQuadraples ( N ) : NEW_LINE INDENT cnt = 0 NEW_LINE m = defaultdict ( int ) NEW_LINE for a in range ( 1 , N + 1 ) : NEW_LINE INDENT for b in range ( 1 , N + 1 ) : NEW_LINE INDENT x = a * a + b * b NEW_LINE m [ x ] += 1 NEW_LINE DEDENT DEDENT for c in range ( 1 , N + 1 ) : NEW_LINE INDENT for d in range ( 1 , N + 1 ) : NEW_LINE INDENT x = c * c + d * d NEW_LINE if x in m : NEW_LINE INDENT cnt += m [ x ] NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def numberOfPairs ( a , b , n ) : NEW_LINE INDENT c = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = a [ i ] - b [ i ] NEW_LINE DEDENT c = sorted ( c ) NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( c [ i ] <= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT pos = bisect_left ( c , - c [ i ] + 1 ) NEW_LINE answer += ( i - pos ) NEW_LINE DEDENT return answer NEW_LINE DEDENT
def isEqualFactors ( N ) : NEW_LINE INDENT if ( ( N % 2 == 0 ) and ( N % 4 != 0 ) ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def count_crazy_primes ( L , R ) : NEW_LINE INDENT prime = [ 0 ] * ( R + 1 ) NEW_LINE countPrime = [ 0 ] * ( R + 1 ) NEW_LINE freqPrime = [ 0 ] * ( R + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = 1 NEW_LINE p = 2 NEW_LINE while p * p <= R : NEW_LINE INDENT if ( prime [ p ] == 0 ) : NEW_LINE INDENT for i in range ( p * p , R + 1 , p ) : NEW_LINE INDENT prime [ i ] = 1 NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for i in range ( 1 , R + 1 ) : NEW_LINE INDENT countPrime [ i ] = countPrime [ i - 1 ] NEW_LINE if ( not prime [ i ] ) : NEW_LINE INDENT countPrime [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , R + 1 ) : NEW_LINE INDENT freqPrime [ i ] = freqPrime [ i - 1 ] NEW_LINE if ( not prime [ countPrime [ i ] ] ) : NEW_LINE INDENT freqPrime [ i ] += 1 NEW_LINE DEDENT DEDENT return ( freqPrime [ R ] - freqPrime [ L - 1 ] ) NEW_LINE DEDENT
def findNumbers ( n , b ) : NEW_LINE INDENT largest = pow ( b , n ) - 1 NEW_LINE print ( largest ) NEW_LINE DEDENT
def maximizedArray ( arr , N ) : NEW_LINE INDENT i = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT num = arr [ i ] NEW_LINE one = 0 NEW_LINE zero = 0 NEW_LINE while ( num ) : NEW_LINE INDENT if ( num % 2 == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT one += 1 NEW_LINE DEDENT num = num >> 1 NEW_LINE DEDENT for j in range ( zero , ( one + zero ) ) : NEW_LINE INDENT num += ( 1 << j ) NEW_LINE DEDENT print ( num , end = "" ) NEW_LINE i += 1 NEW_LINE if ( N > 0 ) : NEW_LINE INDENT print ( ", " , end = "" ) NEW_LINE DEDENT N -= 1 NEW_LINE DEDENT DEDENT
def sieve ( ) : NEW_LINE INDENT v [ 1 ] = 1 NEW_LINE for i in range ( 2 , x ) : NEW_LINE INDENT v [ i ] = i NEW_LINE DEDENT for i in range ( 4 , x , 2 ) : NEW_LINE INDENT v [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i < x ) : NEW_LINE INDENT if ( v [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , x , i ) : NEW_LINE INDENT if ( v [ j ] == j ) : NEW_LINE INDENT v [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def prime_factors ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE while ( n != 1 ) : NEW_LINE INDENT s . add ( v [ n ] ) NEW_LINE n = n // v [ n ] NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT
def distinctPrimes ( m , k ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( 14 , m + k ) : NEW_LINE INDENT count = prime_factors ( i ) NEW_LINE if ( count == k ) : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT DEDENT p = len ( result ) NEW_LINE for index in range ( p - 1 ) : NEW_LINE INDENT element = result [ index ] NEW_LINE count = 1 NEW_LINE z = index NEW_LINE while ( z < p - 1 and count <= k and result [ z ] + 1 == result [ z + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE z += 1 NEW_LINE DEDENT if ( count >= k ) : NEW_LINE INDENT print ( element , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT
def findGCD ( arr , n ) : NEW_LINE INDENT gcd = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT gcd = int ( math . gcd ( arr [ i ] , gcd ) ) NEW_LINE if ( gcd == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return gcd NEW_LINE DEDENT
def findLCM ( arr , n ) : NEW_LINE INDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = int ( ( ( ( arr [ i ] * lcm ) ) / ( math . gcd ( arr [ i ] , lcm ) ) ) ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT
def compute ( a , N , K ) : NEW_LINE INDENT eqVal = defaultdict ( int ) NEW_LINE maxX = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT val = a [ i ] % K NEW_LINE if ( val != 0 ) : NEW_LINE INDENT val = K - val NEW_LINE DEDENT if ( val == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( val in eqVal ) : NEW_LINE INDENT numVal = eqVal [ val ] NEW_LINE maxX = max ( maxX , val + ( K * numVal ) ) NEW_LINE eqVal [ val ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT eqVal [ val ] += 1 NEW_LINE maxX = max ( maxX , val ) NEW_LINE DEDENT DEDENT if maxX == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( maxX + 1 ) NEW_LINE DEDENT DEDENT
def print_h_index ( arr , N ) : NEW_LINE INDENT ms = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT ms . append ( arr [ i ] ) NEW_LINE ms . sort ( ) NEW_LINE if ( ms [ 0 ] < len ( ms ) ) : NEW_LINE INDENT ms . pop ( 0 ) NEW_LINE DEDENT print ( len ( ms ) , end = ' ' ) NEW_LINE DEDENT DEDENT
def pen_hex ( n ) : NEW_LINE INDENT pn = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT pn = ( int ) ( i * ( 3 * i - 1 ) / 2 ) NEW_LINE if ( pn > n ) : NEW_LINE INDENT break NEW_LINE DEDENT seqNum = ( 1 + math . sqrt ( 8 * pn + 1 ) ) / 4 NEW_LINE if ( seqNum == ( int ) ( seqNum ) ) : NEW_LINE INDENT print ( pn , end = ", " ) NEW_LINE DEDENT DEDENT DEDENT
def min_value ( arr , N ) : NEW_LINE INDENT x , X , K = 0 , 0 , 0 NEW_LINE S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT S . add ( arr [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 1 , 1024 ) : NEW_LINE INDENT count = 0 NEW_LINE for it in S : NEW_LINE INDENT X = ( ( i it ) - ( i & it ) ) NEW_LINE if X in S : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == len ( S ) ) : NEW_LINE INDENT K = i NEW_LINE return K NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def prefixProduct ( a , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i ] * a [ i - 1 ] NEW_LINE DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( a [ j ] , end = ", " ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def sumOfTheArrayForQuery ( A , N , X , Y , Q ) : NEW_LINE INDENT sum = 0 NEW_LINE count = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE if A [ i ] in count : NEW_LINE INDENT count [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ A [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( Q ) : NEW_LINE INDENT x = X [ i ] NEW_LINE y = Y [ i ] NEW_LINE if X [ i ] not in count : NEW_LINE INDENT count [ X [ i ] ] = 0 NEW_LINE DEDENT if Y [ i ] not in count : NEW_LINE INDENT count [ Y [ i ] ] = 0 NEW_LINE DEDENT sum -= ( count [ X [ i ] ] * X [ i ] ) NEW_LINE sum += count [ X [ i ] ] * Y [ i ] NEW_LINE count [ Y [ i ] ] += count [ X [ i ] ] NEW_LINE count [ X [ i ] ] = 0 NEW_LINE print ( sum , end = " " ) NEW_LINE DEDENT DEDENT
def maxOR ( arr , n ) : NEW_LINE INDENT max_value = max ( arr ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , ( max_value arr [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def generateArr ( A , n ) : NEW_LINE INDENT B = [ 0 ] * n NEW_LINE maxi = max ( A ) NEW_LINE count = [ 0 ] * ( maxi + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT B [ i ] = count [ A [ i ] ] NEW_LINE IncrementFactors ( count , A [ i ] ) NEW_LINE DEDENT printArr ( B , n ) NEW_LINE DEDENT
def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime = [ True for i in range ( 2 * n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= 2 * n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * p NEW_LINE while ( i <= n * 2 ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT primes = [ ] NEW_LINE for p in range ( 2 , ( 2 * n ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT return primes NEW_LINE DEDENT
def minChanges ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE ans = 0 NEW_LINE maxi = max ( arr ) NEW_LINE primes = SieveOfEratosthenes ( maxi ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = - 1 NEW_LINE for j in range ( len ( primes ) ) : NEW_LINE INDENT if ( arr [ i ] == primes [ j ] ) : NEW_LINE INDENT x = j NEW_LINE break NEW_LINE DEDENT elif ( arr [ i ] < primes [ j ] ) : NEW_LINE INDENT x = j NEW_LINE break NEW_LINE DEDENT DEDENT minm = abs ( primes [ x ] - arr [ i ] ) NEW_LINE if ( x > 1 ) : NEW_LINE INDENT minm = min ( minm , abs ( primes [ x - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT ans += minm NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findSum ( a , n , L , R ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( L % a [ i ] == 0 and L != 0 ) : NEW_LINE INDENT sum += ( calcSum ( a [ i ] , R // a [ i ] ) - calcSum ( a [ i ] , ( L - 1 ) // a [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += ( calcSum ( a [ i ] , R // a [ i ] ) - calcSum ( a [ i ] , L // a [ i ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def findPrimes ( ) : NEW_LINE INDENT for i in range ( 1 , maxN + 1 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT arr [ 0 ] = 0 NEW_LINE arr [ 1 ] = 0 NEW_LINE i = 2 NEW_LINE while i * i <= maxN : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i * i , maxN , i ) : NEW_LINE INDENT arr [ j ] = 0 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT sum = 0 NEW_LINE prefix [ 0 ] = 0 NEW_LINE for i in range ( 1 , maxN + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT temp = i NEW_LINE sum = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT x = temp % 10 NEW_LINE sum += x NEW_LINE temp = temp // 10 NEW_LINE if ( arr [ sum ] == 1 ) : NEW_LINE INDENT prefix [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 1 , maxN + 1 ) : NEW_LINE INDENT prefix [ i ] += prefix [ i - 1 ] NEW_LINE DEDENT DEDENT
def print_product ( a , b , c , d ) : NEW_LINE INDENT prod1 = a * c NEW_LINE prod2 = b * d NEW_LINE prod3 = ( a + b ) * ( c + d ) NEW_LINE real = prod1 - prod2 NEW_LINE imag = prod3 - ( prod1 + prod2 ) NEW_LINE print ( real , " + " , imag , "i" ) NEW_LINE DEDENT
def countWays ( N ) : NEW_LINE INDENT if ( N < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = ( ( N - 1 ) * ( N - 2 ) ) // 2 NEW_LINE s = 0 NEW_LINE for i in range ( 2 , N - 2 , 1 ) : NEW_LINE INDENT for j in range ( 1 , i , 1 ) : NEW_LINE INDENT if ( N == 2 * i + j ) : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT DEDENT if ( N % 3 == 0 ) : NEW_LINE INDENT s = 3 * s + 1 NEW_LINE DEDENT else : NEW_LINE INDENT s = 3 * s NEW_LINE DEDENT return ans - s NEW_LINE DEDENT
def get_concentration ( mass , volume ) : NEW_LINE INDENT if ( volume == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( mass / volume ) * 1000 NEW_LINE DEDENT DEDENT
def isSubsetSum ( Set , n , Sum ) : NEW_LINE INDENT subset = [ [ False for i in range ( Sum + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , Sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , Sum + 1 ) : NEW_LINE INDENT if ( j < Set [ i - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT if ( j >= Set [ i - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - Set [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT return subset [ n ] [ Sum ] NEW_LINE DEDENT
def isPractical ( N ) : NEW_LINE INDENT div = [ ] NEW_LINE storeDivisors ( N , div ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( not isSubsetSum ( div , len ( div ) , i ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isJunction ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i + sum1 ( i ) == n ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count >= 2 NEW_LINE DEDENT
def isDivBySubsetSums ( arr , num ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE total = 1 << n NEW_LINE i = 0 NEW_LINE while i < total : NEW_LINE INDENT sum = 0 NEW_LINE j = 0 NEW_LINE while j < n : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( sum != 0 ) and ( num % sum != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isSuperNivenNum ( n ) : NEW_LINE INDENT temp = n NEW_LINE digits = [ ] NEW_LINE while ( n > 1 ) : NEW_LINE INDENT digit = int ( n ) % 10 NEW_LINE digits . append ( digit ) NEW_LINE n = n / 10 NEW_LINE DEDENT return isDivBySubsetSums ( digits , temp ) NEW_LINE DEDENT
def divCount ( n ) : NEW_LINE INDENT Hash = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( ( p * p ) < n ) : NEW_LINE INDENT if bool ( Hash [ p ] ) : NEW_LINE INDENT i = p * 2 NEW_LINE while i < n : NEW_LINE INDENT Hash [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT total = 1 NEW_LINE for P in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( bool ( Hash [ P ] ) ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % P == 0 ) : NEW_LINE INDENT while ( n % P == 0 ) : NEW_LINE INDENT n = n // P NEW_LINE count += 1 NEW_LINE DEDENT total = total * ( count + 1 ) NEW_LINE DEDENT DEDENT DEDENT return total NEW_LINE DEDENT
def isHighlyCompositeNumber ( N ) : NEW_LINE INDENT NdivCount = divCount ( N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT idivCount = divCount ( i ) NEW_LINE if ( idivCount >= NdivCount ) : NEW_LINE INDENT return bool ( False ) NEW_LINE DEDENT DEDENT return bool ( True ) NEW_LINE DEDENT
def isInsolite ( n ) : NEW_LINE INDENT N = n NEW_LINE sum = 0 NEW_LINE product = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE sum = sum + r * r NEW_LINE product = product * r * r NEW_LINE n = n // 10 NEW_LINE DEDENT return ( ( N % sum == 0 ) and ( N % product == 0 ) ) NEW_LINE DEDENT
def isSaintExuperyNum ( n ) : NEW_LINE INDENT for i in range ( 1 , ( n // 3 ) + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , ( n // 2 ) + 1 ) : NEW_LINE INDENT k = n / i / j NEW_LINE if i * i + j * j == k * k : NEW_LINE INDENT if i * j * k == n : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 ) or ( n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isMagnanimous ( N ) : NEW_LINE INDENT s = str ( N ) NEW_LINE l = len ( s ) NEW_LINE if ( l < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( l - 1 ) : NEW_LINE INDENT left = s [ 0 : i + 1 ] NEW_LINE right = s [ i + 1 : ] NEW_LINE x = int ( left ) NEW_LINE y = int ( right ) NEW_LINE if ( not isPrime ( x + y ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def digProduct ( n ) : NEW_LINE INDENT product = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT product = product * ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return product NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def nextPrime ( N ) : NEW_LINE INDENT if ( N <= 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT prime = N NEW_LINE found = False NEW_LINE while ( not found ) : NEW_LINE INDENT prime = prime + 1 NEW_LINE if ( isPrime ( prime ) ) : NEW_LINE INDENT found = True NEW_LINE DEDENT DEDENT return prime NEW_LINE DEDENT
def isPointerPrime ( n ) : NEW_LINE INDENT if ( isPrime ( n ) and ( n + digProduct ( n ) == nextPrime ( n ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def sieve ( ) : NEW_LINE INDENT position [ 0 ] = - 1 NEW_LINE position [ 1 ] = - 1 NEW_LINE pos = 0 NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if ( position [ i ] == 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE position [ i ] = pos NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def getSum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT Sum = Sum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( y % 2 == 0 ) : NEW_LINE INDENT return ( power ( x , y // 2 ) * power ( x , y // 2 ) ) NEW_LINE DEDENT return ( x * power ( x , y // 2 ) * power ( x , y // 2 ) ) NEW_LINE DEDENT
def isPerfectDigitalInvariant ( x ) : NEW_LINE INDENT fixed_power = 0 NEW_LINE while True : NEW_LINE INDENT fixed_power += 1 NEW_LINE temp = x NEW_LINE summ = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT r = temp % 10 NEW_LINE summ = summ + power ( r , fixed_power ) NEW_LINE temp = temp // 10 NEW_LINE DEDENT if ( summ == x ) : NEW_LINE INDENT return ( True ) NEW_LINE DEDENT if ( summ > x ) : NEW_LINE INDENT return ( False ) NEW_LINE DEDENT DEDENT DEDENT
def isWasteful ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT original_no = n NEW_LINE sumDigits = 0 NEW_LINE while ( original_no > 0 ) : NEW_LINE INDENT sumDigits += 1 NEW_LINE original_no = original_no // 10 NEW_LINE DEDENT pDigit , count_exp , p = 0 , 0 , 0 NEW_LINE i = 0 NEW_LINE while ( primes [ i ] <= ( n // 2 ) ) : NEW_LINE INDENT while ( n % primes [ i ] == 0 ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE n = n // p NEW_LINE count_exp += 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT pDigit += 1 NEW_LINE p = p // 10 NEW_LINE DEDENT while ( count_exp > 1 ) : NEW_LINE INDENT pDigit += 1 NEW_LINE count_exp = count_exp // 10 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( n != 1 ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT pDigit += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT DEDENT return bool ( pDigit > sumDigits ) NEW_LINE DEDENT
def Solve ( N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( isWasteful ( i ) ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def isDNum ( n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT return False NEW_LINE DEDENT for k in range ( 2 , n ) : NEW_LINE INDENT numerator = pow ( k , n - 2 ) - k NEW_LINE hcf = math . gcd ( n , k ) NEW_LINE if ( hcf == 1 and ( numerator % n ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isComposite ( n ) : NEW_LINE INDENT if n <= 3 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT
def isEnlightened ( N ) : NEW_LINE INDENT if ( not isComposite ( N ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = str ( N ) NEW_LINE prefixConc = concatenatePrimeFactors ( N ) NEW_LINE return int ( prefixConc ) NEW_LINE DEDENT
def isIdoneal ( n ) : NEW_LINE INDENT for a in range ( 1 , n + 1 ) : NEW_LINE INDENT for b in range ( a + 1 , n + 1 ) : NEW_LINE INDENT for c in range ( b + 1 , n + 1 ) : NEW_LINE INDENT if ( a * b + b * c + c * a == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def isAllDigitsDivide ( n ) : NEW_LINE INDENT temp = n NEW_LINE while ( temp >= 1 ) : NEW_LINE INDENT digit = int ( temp % 10 ) NEW_LINE if ( checkDivisibility ( n , digit ) == False ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT temp = temp / 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def isAllDigitsDistinct ( n ) : NEW_LINE INDENT arr = [ 0 ] * 10 NEW_LINE while ( n >= 1 ) : NEW_LINE INDENT digit = int ( n % 10 ) NEW_LINE if ( arr [ digit ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr [ digit ] = 1 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def isLynchBell ( n ) : NEW_LINE INDENT return ( isAllDigitsDivide ( n ) and isAllDigitsDistinct ( n ) ) NEW_LINE DEDENT
def printhexaRec ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 or n == 2 or n == 3 or n == 4 or n == 5 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( n == 6 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( printhexaRec ( n - 1 ) + printhexaRec ( n - 2 ) + printhexaRec ( n - 3 ) + printhexaRec ( n - 4 ) + printhexaRec ( n - 5 ) + printhexaRec ( n - 6 ) ) NEW_LINE DEDENT DEDENT
def printhexa ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE third = 0 NEW_LINE fourth = 0 NEW_LINE fifth = 0 NEW_LINE sixth = 1 NEW_LINE curr = 0 NEW_LINE if ( n < 6 ) : NEW_LINE INDENT print ( first ) NEW_LINE DEDENT elif ( n == 6 ) : NEW_LINE INDENT print ( sixth ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 6 , n ) : NEW_LINE INDENT curr = first + second + third + fourth + fifth + sixth NEW_LINE first = second NEW_LINE second = third NEW_LINE third = fourth NEW_LINE fourth = fifth NEW_LINE fifth = sixth NEW_LINE sixth = curr NEW_LINE DEDENT DEDENT print ( curr ) NEW_LINE DEDENT
def isGapful ( n ) : NEW_LINE INDENT concatenation = ( firstDigit ( n ) * 10 ) + lastDigit ( n ) NEW_LINE return ( n % concatenation ) NEW_LINE DEDENT
def check ( x ) : NEW_LINE INDENT return x and ( not ( x & ( x - 1 ) ) ) NEW_LINE DEDENT
def isPossible ( A , B , N , K , L ) : NEW_LINE INDENT needa = 0 NEW_LINE needb = 0 NEW_LINE if ( A % K == 0 ) : NEW_LINE INDENT needa = A // K NEW_LINE DEDENT else : NEW_LINE INDENT needa = A // K + 1 NEW_LINE DEDENT if ( B % L == 0 ) : NEW_LINE INDENT needb = B // L NEW_LINE DEDENT else : NEW_LINE INDENT needb = B // L + 1 NEW_LINE DEDENT total = needa + needb NEW_LINE if ( total > N ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def CountTotalfactors ( ) : NEW_LINE INDENT tfactor [ 1 ] = pre [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT mspf = spf [ i ] NEW_LINE prim = mspf NEW_LINE temp = i NEW_LINE cnt = 0 NEW_LINE while ( temp % mspf == 0 ) : NEW_LINE INDENT temp //= mspf NEW_LINE cnt += 1 NEW_LINE prim = prim * mspf NEW_LINE DEDENT tfactor [ i ] = ( cnt + 1 ) * tfactor [ temp ] NEW_LINE pre [ i ] = pre [ i - 1 ] + tfactor [ i ] NEW_LINE DEDENT DEDENT
def BinarySearch ( X ) : NEW_LINE INDENT start = 1 NEW_LINE end = MAX - 1 NEW_LINE while ( start < end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( pre [ mid ] == X ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( pre [ mid ] < X ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid NEW_LINE DEDENT DEDENT return start NEW_LINE DEDENT
def buildSieve ( sum ) : NEW_LINE INDENT global prime NEW_LINE prime = [ True for i in range ( sum + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p < ( sum + 1 ) ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , sum + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def getSum ( a ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 5 ) : NEW_LINE INDENT s += a [ i ] [ j ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def checkIndex ( n , m , a ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( prime [ i + j ] and not prime [ a [ i ] [ j ] ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def takeSum ( a ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 5 ) : NEW_LINE INDENT s += a [ i ] [ j ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def sumOfSumSeries ( N ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT _sum = _sum + ( i * ( i + 1 ) ) // 2 NEW_LINE DEDENT return _sum NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( n % 2 == 0 ) or ( n % 3 == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) or ( n % ( i + 2 ) == 0 ) ) : NEW_LINE INDENT return False NEW_LINE i += 6 NEW_LINE DEDENT DEDENT return true NEW_LINE DEDENT
def checkExpression ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def placeValue ( N , num ) : NEW_LINE INDENT total = 1 NEW_LINE value = 0 NEW_LINE rem = 0 NEW_LINE while ( True ) : NEW_LINE INDENT rem = N % 10 NEW_LINE N = N // 10 NEW_LINE if ( rem == num ) : NEW_LINE INDENT value = total * rem NEW_LINE break NEW_LINE DEDENT total = total * 10 NEW_LINE DEDENT return value NEW_LINE DEDENT
def isContaindigit ( n ) : NEW_LINE INDENT temp = str ( n ) NEW_LINE for i in temp : NEW_LINE INDENT if i not in [ '0' , '1' , '8' ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def ispalindrome ( n ) : NEW_LINE INDENT temp = str ( n ) NEW_LINE if temp == temp [ : : - 1 ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def printTetradicPrimesLessThanN ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] and isTetradic ( p ) ) : NEW_LINE INDENT print ( p , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def BeattySequence ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = math . floor ( i * math . sqrt ( 2 ) ) NEW_LINE print ( ans , end = ', ' ) NEW_LINE DEDENT DEDENT
def concat ( a , b ) : NEW_LINE INDENT s1 = str ( a ) NEW_LINE s2 = str ( b ) NEW_LINE s = s1 + s2 NEW_LINE c = int ( s ) NEW_LINE return c NEW_LINE DEDENT
def isAstonishing ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum += j NEW_LINE if ( sum == n ) : NEW_LINE INDENT concatenation = concat ( i , j ) NEW_LINE if ( concatenation == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum1 = sum1 + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum1 NEW_LINE DEDENT
def isSelfNum ( n ) : NEW_LINE INDENT for m in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( m + getSum ( m ) == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def Sum ( N ) : NEW_LINE INDENT SumOfPrimeDivisors = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( SumOfPrimeDivisors [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N + 1 , i ) : NEW_LINE INDENT SumOfPrimeDivisors [ j ] += i NEW_LINE DEDENT DEDENT DEDENT return SumOfPrimeDivisors [ N ] NEW_LINE DEDENT
def RuthAaronNumber ( n ) : NEW_LINE INDENT if ( Sum ( n ) == Sum ( n + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for j in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def countDigit ( n ) : NEW_LINE INDENT return math . floor ( math . log10 ( n ) + 1 ) NEW_LINE DEDENT
def sortStack ( input ) : NEW_LINE INDENT tmpStack = [ ] NEW_LINE while ( len ( input ) > 0 ) : NEW_LINE INDENT tmp = input [ - 1 ] NEW_LINE input . pop ( ) NEW_LINE while ( len ( tmpStack ) > 0 and tmpStack [ - 1 ] < tmp ) : NEW_LINE INDENT input . append ( tmpStack [ - 1 ] ) NEW_LINE tmpStack . pop ( ) NEW_LINE DEDENT tmpStack . append ( tmp ) NEW_LINE DEDENT return tmpStack NEW_LINE DEDENT
def sortArrayUsingStacks ( arr , n ) : NEW_LINE INDENT input = [ ] NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT input . append ( arr [ i ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT tmpStack = sortStack ( input ) NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT arr [ i ] = tmpStack [ - 1 ] NEW_LINE tmpStack . pop ( ) NEW_LINE i = i + 1 NEW_LINE DEDENT return arr NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT sum1 = sum1 + i NEW_LINE DEDENT else : NEW_LINE INDENT sum1 = sum1 + i NEW_LINE sum1 = sum1 + ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return sum1 NEW_LINE DEDENT
def MultiplyPerfectNumber ( n ) : NEW_LINE INDENT if ( getSum ( n ) % n == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def phi ( n ) : NEW_LINE INDENT result = n NEW_LINE for p in range ( 2 , n ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % p == 0 ) : NEW_LINE INDENT while ( n % p == 0 ) : NEW_LINE INDENT n //= p NEW_LINE DEDENT result -= result // p NEW_LINE DEDENT DEDENT if ( n > 1 ) : NEW_LINE INDENT result -= result // n NEW_LINE DEDENT return result NEW_LINE DEDENT
def isPower ( a ) : NEW_LINE INDENT if ( a == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 2 NEW_LINE while ( i * i <= a ) : NEW_LINE INDENT val = math . log ( a ) / math . log ( i ) NEW_LINE if ( ( val - int ( val ) ) < 0.00000001 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def isCunningham ( n ) : NEW_LINE INDENT return isPower ( n - 1 ) or isPower ( n + 1 ) NEW_LINE DEDENT
def checkSame ( n , b ) : NEW_LINE INDENT m = { } NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % b NEW_LINE n = n // b NEW_LINE if r in m : NEW_LINE INDENT m [ r ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ r ] = 1 NEW_LINE DEDENT DEDENT last = - 1 NEW_LINE for i in m : NEW_LINE INDENT if last != - 1 and m [ i ] != last : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT last = m [ i ] NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def SubArrayProdct ( arr , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result *= pow ( arr [ i ] , ( i + 1 ) * ( n - i ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def countWays ( m , n , x , y ) : NEW_LINE INDENT return ( nCr ( m + n , m ) - nCr ( x + y , x ) * nCr ( m + n - x - y , m - x ) ) NEW_LINE DEDENT
def averageRuns ( runs , matches , notout ) : NEW_LINE INDENT out = matches - notout NEW_LINE if ( out == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT avg = runs // out NEW_LINE return avg NEW_LINE DEDENT
def seriesSum ( n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE currProd = 1 NEW_LINE currSum = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT currProd *= i NEW_LINE currSum += i NEW_LINE sum1 += currProd - currSum NEW_LINE DEDENT return sum1 NEW_LINE DEDENT
def seriesSumUtil ( k , n , prevSum , multi , add ) : NEW_LINE INDENT if ( k == n + 1 ) : NEW_LINE INDENT return prevSum NEW_LINE DEDENT multi = multi * k NEW_LINE add = add + k NEW_LINE prevSum = prevSum + multi - add NEW_LINE return seriesSumUtil ( k + 1 , n , prevSum , multi , add ) NEW_LINE DEDENT
def seriesSum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT prevSum = 0 NEW_LINE multi = 1 NEW_LINE add = 1 NEW_LINE return seriesSumUtil ( 2 , n , prevSum , multi , add ) NEW_LINE DEDENT
def Is_possible ( N ) : NEW_LINE INDENT C = 0 NEW_LINE D = 0 NEW_LINE while ( N % 10 == 0 ) : NEW_LINE INDENT N = N / 10 NEW_LINE C += 1 NEW_LINE DEDENT if ( math . log ( N , 2 ) - int ( math . log ( N , 2 ) ) == 0 ) : NEW_LINE INDENT D = int ( math . log ( N , 2 ) ) NEW_LINE if ( C >= D ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def maximumAND ( L , R ) : NEW_LINE INDENT return R NEW_LINE DEDENT
def count ( a , n ) : NEW_LINE INDENT countElements = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT flag = True NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i ] % a [ j ] == 0 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT countElements += 1 NEW_LINE DEDENT DEDENT return countElements NEW_LINE DEDENT
def countEle ( a , n ) : NEW_LINE INDENT len = 0 NEW_LINE hmap = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT len = max ( len , a [ i ] ) NEW_LINE hmap [ a [ i ] ] = hmap . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT v = [ True for i in range ( len + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( v [ a [ i ] ] == False ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( 2 * a [ i ] , len + 1 , a [ i ] ) : NEW_LINE INDENT v [ j ] = False NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( 1 , len + 1 ) : NEW_LINE INDENT if ( v [ i ] == True and ( i in hmap ) and hmap [ i ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def find_min_sum ( a , b , c ) : NEW_LINE INDENT global x , y , g NEW_LINE x , y , g = 0 , 0 , 0 NEW_LINE if ( possible_solution ( a , b , c ) == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( g != 0 ) : NEW_LINE INDENT a //= g NEW_LINE b //= g NEW_LINE DEDENT if a > 0 : NEW_LINE INDENT sign_a = 1 NEW_LINE DEDENT else : NEW_LINE INDENT sign_a = - 1 NEW_LINE DEDENT if b > 0 : NEW_LINE INDENT sign_b = 1 NEW_LINE DEDENT else : NEW_LINE INDENT sign_b = - 1 NEW_LINE DEDENT shift_solution ( a , b , - x // b ) NEW_LINE if ( x < 0 ) : NEW_LINE INDENT shift_solution ( a , b , sign_b ) NEW_LINE DEDENT minx1 = x NEW_LINE shift_solution ( a , b , y // a ) NEW_LINE if ( y < 0 ) : NEW_LINE INDENT shift_solution ( a , b , - sign_a ) NEW_LINE DEDENT minx2 = x NEW_LINE if ( minx2 > x ) : NEW_LINE INDENT temp = minx2 NEW_LINE minx2 = x NEW_LINE x = temp NEW_LINE DEDENT minx = max ( minx1 , minx2 ) NEW_LINE if ( minx > x ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT miny = ( c - a * x ) // b NEW_LINE return ( miny + minx ) NEW_LINE DEDENT
def countPairs ( A , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( A [ i ] % 2 == 0 and A [ j ] % 2 == 0 ) or ( A [ i ] % 2 != 0 and A [ j ] % 2 != 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def smallestNumber ( N ) : NEW_LINE INDENT return N * math . ceil ( pow ( 10 , ( N - 1 ) ) // N ) NEW_LINE DEDENT
def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT arr . append ( 1 ) NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] *= i NEW_LINE DEDENT DEDENT DEDENT maxValue = 1 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( arr [ i ] > maxValue ) : NEW_LINE INDENT maxValue = i NEW_LINE DEDENT DEDENT return maxValue NEW_LINE DEDENT
def linearSum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) // 2 % mod NEW_LINE DEDENT
def rangeSum ( b , a ) : NEW_LINE INDENT return ( linearSum ( b ) - ( linearSum ( a ) ) ) % mod NEW_LINE DEDENT
def totalSum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT result += rangeSum ( n // i , n // ( i + 1 ) ) * ( i % mod ) % mod NEW_LINE result %= mod NEW_LINE if i == n : NEW_LINE INDENT break NEW_LINE DEDENT i = n // ( n // ( i + 1 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def CountPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 or arr [ j ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def isPal ( a , n , m ) : NEW_LINE INDENT for i in range ( 0 , n // 2 ) : NEW_LINE INDENT for j in range ( 0 , m - 1 ) : NEW_LINE INDENT if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def smallestNum ( n ) : NEW_LINE INDENT return ( ( n * n % 9 + 1 ) * pow ( 10 , int ( n * n / 9 ) ) - 1 ) NEW_LINE DEDENT
def smallestNumber ( N ) : NEW_LINE INDENT print ( ( N % 9 + 1 ) * pow ( 10 , ( N // 9 ) ) - 1 ) NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT print ( n * ( 5 * n + 3 ) // 2 ) NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT print ( n * ( 2 * n + 1 ) ) NEW_LINE DEDENT
def reversDigits ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - int ( sr ) ) == 0 ) NEW_LINE DEDENT
def isRare ( N ) : NEW_LINE INDENT reverseN = reversDigits ( N ) NEW_LINE if ( reverseN == N ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( isPerfectSquare ( N + reverseN ) and isPerfectSquare ( N - reverseN ) ) NEW_LINE DEDENT
def getProduct ( n ) : NEW_LINE INDENT product = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT product = product * ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT
def isDouble ( num ) : NEW_LINE INDENT s = str ( num ) NEW_LINE l = len ( s ) NEW_LINE if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( l % 2 == 1 ) : NEW_LINE INDENT s = s + s [ 1 ] NEW_LINE l += 1 NEW_LINE DEDENT s1 = s [ : l // 2 ] NEW_LINE s2 = s [ l // 2 : ] NEW_LINE return s1 == s2 NEW_LINE DEDENT
def isNontrivialUndulant ( N ) : NEW_LINE INDENT return N > 100 and isDouble ( N ) NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT print ( n * ( 4 * n + 3 ) ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( n ** 0.5 ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n / 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isAdditivePrime ( n ) : NEW_LINE INDENT if ( not isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isPrime ( getSum ( n ) ) NEW_LINE DEDENT
def isStraighLineNum ( N ) : NEW_LINE INDENT if ( N <= 99 ) : NEW_LINE INDENT return False NEW_LINE DEDENT str1 = str ( N ) NEW_LINE d = int ( str1 [ 1 ] ) - int ( str1 [ 0 ] ) NEW_LINE for i in range ( 2 , len ( str1 ) ) : NEW_LINE INDENT if ( int ( str1 [ i ] ) - int ( str1 [ i - 1 ] ) != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT print ( pow ( 2 , n ) - 2 * n ) NEW_LINE DEDENT
def isEvenOddForm ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 and int ( s [ i ] ) % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i % 2 == 1 and int ( s [ i ] ) % 2 != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isOddEvenForm ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 and int ( s [ i ] ) % 2 != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i % 2 == 1 and int ( s [ i ] ) % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isAlternating ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE return ( isEvenOddForm ( s ) or isOddEvenForm ( s ) ) NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT print ( n * n - n + 1 ) NEW_LINE DEDENT
def isDroll ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum_even = 0 NEW_LINE sum_odd = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT sum_even += 2 NEW_LINE n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT sum_odd += i NEW_LINE n = n // i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT sum_odd += n NEW_LINE DEDENT return sum_even == sum_odd NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def areAnagrams ( a , b ) : NEW_LINE INDENT freqA = [ 0 ] * TEN NEW_LINE freqB = [ 0 ] * TEN NEW_LINE updateFreq ( a , freqA ) NEW_LINE updateFreq ( b , freqB ) NEW_LINE for i in range ( TEN ) : NEW_LINE INDENT if ( freqA [ i ] != freqB [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def DecakismyriagonNum ( N ) : NEW_LINE INDENT return ( 99998 * N * N - 99996 * N ) // 2 NEW_LINE DEDENT
def iszygodromeNum ( N ) : NEW_LINE INDENT s = str ( N ) NEW_LINE s = ' ' + s + ' ' NEW_LINE i = 1 NEW_LINE while i < len ( s ) - 1 : NEW_LINE INDENT if ( ( s [ i ] != s [ i - 1 ] ) and ( s [ i ] != s [ i + 1 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isLoeschian ( n ) : NEW_LINE INDENT for x in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT for y in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( x * x + x * y + y * y == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def printSeries ( N ) : NEW_LINE INDENT ith_term = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ith_term = ( 13 * i * ( i - 1 ) ) / 2 + 2 NEW_LINE print ( int ( ith_term ) , ", " , end = "" ) NEW_LINE DEDENT DEDENT
def printSeries ( n , a , b , c ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( a , end = " " ) NEW_LINE return NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT print ( a , b , end = " " ) NEW_LINE return NEW_LINE DEDENT print ( a , b , c , end = " " ) NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT d = a + b + c NEW_LINE print ( d , end = " " ) NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE DEDENT DEDENT
def sieveSundaram ( ) : NEW_LINE INDENT marked = [ 0 ] * int ( MAX / 2 + 1 ) NEW_LINE for i in range ( 1 , int ( ( math . sqrt ( MAX ) - 1 ) // 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , MAX // 2 + 1 , 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True NEW_LINE DEDENT DEDENT primes . append ( 2 ) NEW_LINE for i in range ( 1 , MAX // 2 + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def Pairs ( C ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( C ) : NEW_LINE INDENT for j in range ( i + 1 , C ) : NEW_LINE INDENT if ( ( i * i ) + ( j * j ) == ( C * C ) ) : NEW_LINE INDENT ans . append ( [ i , j ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def strikerate ( bowls , runs ) : NEW_LINE INDENT z = ( float ( runs ) / bowls ) * 100 NEW_LINE return z NEW_LINE DEDENT
def factorize ( N ) : NEW_LINE INDENT count = 0 NEW_LINE cnt = 0 NEW_LINE while ( ( N % 2 ) == 0 ) : NEW_LINE INDENT N = N // 2 NEW_LINE count += 1 NEW_LINE DEDENT cnt = cnt + count NEW_LINE sq = int ( math . sqrt ( N ) ) NEW_LINE for i in range ( 3 , sq , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE N = N // i NEW_LINE DEDENT cnt = cnt + count NEW_LINE DEDENT if ( N > 2 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def ifNumberExists ( X , Y ) : NEW_LINE INDENT C = X - Y - 1 NEW_LINE dsum = factorize ( X ) NEW_LINE if ( dsum >= C ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def checkArray ( n , k , arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= k and cnt % 2 == k % 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def print_nearest_prime ( arr , N ) : NEW_LINE INDENT maxm = max ( arr ) NEW_LINE SieveOfEratosthenes ( maxm ) NEW_LINE primes = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( not prime [ arr [ i ] ] ) : NEW_LINE INDENT primes . append ( i ) NEW_LINE DEDENT DEDENT if len ( primes ) == 0 : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( - 1 , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT curr = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( curr == len ( primes ) - 1 or i <= primes [ curr ] ) : NEW_LINE INDENT print ( arr [ primes [ curr ] ] , end = " " ) NEW_LINE continue NEW_LINE DEDENT if ( abs ( primes [ curr ] - i ) < abs ( primes [ curr + 1 ] - i ) ) : NEW_LINE INDENT print ( arr [ primes [ curr ] ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT curr += 1 NEW_LINE print ( arr [ primes [ curr ] ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def CountPairs ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT div1 = i NEW_LINE div2 = n // i NEW_LINE sum = div1 + div2 NEW_LINE if ( m . gcd ( sum , n ) == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def allQuotients ( N ) : NEW_LINE INDENT s = set ( ) NEW_LINE for k in range ( 1 , N + 2 ) : NEW_LINE INDENT s . add ( N // k ) NEW_LINE DEDENT for it in s : NEW_LINE INDENT print ( it , end = ' ' ) NEW_LINE DEDENT DEDENT
def findPosition ( n ) : NEW_LINE INDENT i = 0 NEW_LINE pos = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == 7 ) : NEW_LINE INDENT pos = pos + pow ( 2 , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT pos = pos + pow ( 2 , i ) NEW_LINE DEDENT i += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT print ( pos ) NEW_LINE DEDENT
def greatestOddFactor ( n ) : NEW_LINE INDENT pow_2 = int ( math . log ( n , 2 ) ) NEW_LINE i = 1 NEW_LINE while i <= pow_2 : NEW_LINE INDENT fac_2 = ( 2 ** i ) NEW_LINE if ( n % fac_2 == 0 ) : NEW_LINE INDENT if ( ( n // fac_2 ) % 2 == 1 ) : NEW_LINE INDENT print ( n // fac_2 ) NEW_LINE break NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def countSmaller ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ j ] < str [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt , end = " " ) NEW_LINE DEDENT DEDENT
def sum_star_num ( n ) : NEW_LINE INDENT summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n NEW_LINE return summ NEW_LINE DEDENT
def solve ( n , vec ) : NEW_LINE INDENT a = [ ] NEW_LINE b = [ ] NEW_LINE for pr in vec : NEW_LINE INDENT a . append ( pr [ 0 ] ) NEW_LINE b . append ( pr [ 1 ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE if ( ( n & 1 ) ) : NEW_LINE INDENT left = a [ n // 2 ] NEW_LINE right = b [ n // 2 ] NEW_LINE ans = right - left + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = ( a [ n // 2 ] + a [ n // 2 - 1 ] ) NEW_LINE right = ( b [ n // 2 ] + b [ n // 2 - 1 ] ) NEW_LINE ans = right - left + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def find_pairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in mp . values ( ) : NEW_LINE INDENT count = i NEW_LINE if ( count > 1 ) : NEW_LINE INDENT ans += ( ( count * ( count - 1 ) ) // 2 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def Majority_in_linklist ( head ) : NEW_LINE INDENT s , t = "" , "" NEW_LINE p , q = 0 , 0 NEW_LINE ptr = None NEW_LINE while head != None : NEW_LINE INDENT if s == head . i : NEW_LINE INDENT p = p + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if t == head . i : NEW_LINE INDENT q = q + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if p == 0 : NEW_LINE INDENT s = head . i NEW_LINE p = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if q == 0 : NEW_LINE INDENT t = head . i NEW_LINE q = 1 NEW_LINE DEDENT else : NEW_LINE INDENT p = p - 1 NEW_LINE q = q - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT head = head . next NEW_LINE DEDENT head = ptr NEW_LINE p = 0 NEW_LINE q = 0 NEW_LINE while head != None : NEW_LINE INDENT if s == head . i : NEW_LINE INDENT p = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if t == head . i : NEW_LINE INDENT q = 1 NEW_LINE DEDENT DEDENT head = head . next NEW_LINE DEDENT if p > q : NEW_LINE INDENT return s NEW_LINE DEDENT else : NEW_LINE INDENT return t NEW_LINE DEDENT DEDENT
def gonNum65537 ( n ) : NEW_LINE INDENT return ( 65535 * n * n - 65533 * n ) // 2 NEW_LINE DEDENT
def MegagonNum ( n ) : NEW_LINE INDENT return ( 999998 * n * n - 999996 * n ) // 2 NEW_LINE DEDENT
def gonNum120 ( n ) : NEW_LINE INDENT return ( 118 * n * n - 116 * n ) // 2 NEW_LINE DEDENT
def TetracontaoctagonalNum ( n ) : NEW_LINE INDENT return ( 46 * n * n - 44 * n ) / 2 NEW_LINE DEDENT
def TetracontadigonalNum ( n ) : NEW_LINE INDENT return int ( ( 40 * n * n - 38 * n ) / 2 ) NEW_LINE DEDENT
def HexacontatetragonNum ( n ) : NEW_LINE INDENT return ( 62 * n * n - 60 * n ) / 2 NEW_LINE DEDENT
def binpow ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = res * a NEW_LINE DEDENT a = a * a NEW_LINE b //= 2 NEW_LINE DEDENT return res NEW_LINE DEDENT
def checkOverlapping ( a , b ) : NEW_LINE INDENT a , b = max ( a , b ) , min ( a , b ) NEW_LINE if b [ 0 ] <= a [ 0 ] <= b [ 1 ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def find ( a , i ) : NEW_LINE INDENT if a [ i ] == i : NEW_LINE INDENT return i NEW_LINE DEDENT a [ i ] = find ( a , a [ i ] ) NEW_LINE return a [ i ] NEW_LINE DEDENT
def checkNonOverlapping ( arr , n ) : NEW_LINE INDENT dsu = [ i for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if checkOverlapping ( arr [ i ] , arr [ j ] ) : NEW_LINE INDENT if union ( dsu , i , j ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def isPossible ( A , B ) : NEW_LINE INDENT return ( A - B > 1 ) NEW_LINE DEDENT
def minDivisorDifference ( n ) : NEW_LINE INDENT num1 = 0 NEW_LINE num2 = 0 NEW_LINE for i in range ( int ( math . sqrt ( n ) ) , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT num1 = i NEW_LINE num2 = n // i NEW_LINE break NEW_LINE DEDENT DEDENT return abs ( num1 - num2 ) NEW_LINE DEDENT
def dfs ( g , u , par ) : NEW_LINE INDENT sub [ u ] = minDivisorDifference ( u ) NEW_LINE mx = 0 NEW_LINE for c in g [ u ] : NEW_LINE INDENT if ( c != par ) : NEW_LINE INDENT ans = dfs ( g , c , u ) NEW_LINE mx = max ( mx , ans ) NEW_LINE DEDENT DEDENT sub [ u ] += mx NEW_LINE return sub [ u ] NEW_LINE DEDENT
def findLCMPrime ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT return a * b NEW_LINE DEDENT
def smallestNumber ( N ) : NEW_LINE INDENT print ( N * ceil ( pow ( 2 , ( N - 1 ) ) / N ) ) NEW_LINE DEDENT
def smallestNumber ( N ) : NEW_LINE INDENT print ( N * floor ( ( pow ( 10 , N ) - 1 ) / N ) ) NEW_LINE DEDENT
def istriacontagonal ( N ) : NEW_LINE INDENT n = ( 26 + math . sqrt ( 224 * N + 676 ) ) // 56 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( a == c ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def isComposite ( n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT
def Compositorial_list ( n ) : NEW_LINE INDENT l = 0 NEW_LINE for i in range ( 4 , 10 ** 6 ) : NEW_LINE INDENT if l < n : NEW_LINE INDENT if isComposite ( i ) : NEW_LINE INDENT compo . append ( i ) NEW_LINE l += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def calculateCompositorial ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = result * compo [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def numberOfDigits ( N ) : NEW_LINE INDENT nod = floor ( log10 ( N ) + 1 ) NEW_LINE toDecrease = ( pow ( 10 , nod ) - 1 ) // 9 NEW_LINE print ( ( N + 1 ) * nod - toDecrease ) NEW_LINE DEDENT
def Maxlength ( arr , N ) : NEW_LINE INDENT zeroindex = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT zeroindex . append ( i ) NEW_LINE DEDENT DEDENT if ( len ( zeroindex ) == 0 ) : NEW_LINE INDENT maxlen = N NEW_LINE DEDENT else : NEW_LINE INDENT maxlen = zeroindex [ 0 ] NEW_LINE for i in range ( 0 , len ( zeroindex ) - 1 ) : NEW_LINE INDENT if ( zeroindex [ i + 1 ] - zeroindex [ i ] - 1 > maxlen ) : NEW_LINE INDENT maxlen = zeroindex [ i + 1 ] - zeroindex [ i ] - 1 NEW_LINE DEDENT DEDENT if ( N - zeroindex [ len ( zeroindex ) - 1 ] - 1 > maxlen ) : NEW_LINE INDENT maxlen = N - zeroindex [ len ( zeroindex ) - 1 ] - 1 NEW_LINE DEDENT DEDENT print ( maxlen ) NEW_LINE DEDENT
def isPossible ( arr , N , K ) : NEW_LINE INDENT oddCount = 0 NEW_LINE evenCount = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT evenCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT oddCount += 1 NEW_LINE DEDENT DEDENT if ( evenCount == N or ( oddCount == N and K % 2 == 0 ) or ( K == N and oddCount % 2 == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def productOfGP ( a , r , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product = product * a NEW_LINE a = a * r NEW_LINE DEDENT return product NEW_LINE DEDENT
def productOfGP ( a , r , n ) : NEW_LINE INDENT return pow ( a , n ) * pow ( r , n * ( n - 1 ) // 2 ) NEW_LINE DEDENT
def productOfGP ( a , r , n ) : NEW_LINE INDENT an = a * pow ( r , n - 1 ) NEW_LINE return ( math . sqrt ( pow ( a * an , n ) ) ) NEW_LINE DEDENT
def is_Chiliagon ( N ) : NEW_LINE INDENT n = ( 996 + math . sqrt ( 7984 * N + 992016 ) ) // 1996 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def commonSubarrays ( A , B , N ) : NEW_LINE INDENT Map = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT Map [ A [ i ] ] = i NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT B [ i ] = Map [ B [ i ] ] NEW_LINE DEDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT K = 1 NEW_LINE i += 1 NEW_LINE while i < N and B [ i ] == B [ i - 1 ] + 1 : NEW_LINE INDENT i += 1 NEW_LINE K += 1 NEW_LINE DEDENT count = count + ( ( K ) * ( K + 1 ) ) // 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
def getArrayOfSizeK ( n , k ) : NEW_LINE INDENT ans = [ ] NEW_LINE odd = n - ( ( k - 1 ) * 1 ) NEW_LINE if ( odd > 0 and odd % 2 != 0 ) : NEW_LINE INDENT for i in range ( k - 1 ) : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT ans . append ( odd ) NEW_LINE DEDENT even = n - ( ( k - 1 ) * 2 ) NEW_LINE if ( even > 0 and even % 2 == 0 and len ( ans ) == 0 ) : NEW_LINE INDENT for i in range ( k - 1 ) : NEW_LINE INDENT ans . append ( 2 ) NEW_LINE DEDENT ans . append ( even ) NEW_LINE DEDENT if ( len ( ans ) > 0 ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def checkDivisbility ( num ) : NEW_LINE INDENT digit = 0 NEW_LINE N = num NEW_LINE while ( num != 0 ) : NEW_LINE INDENT digit = num % 10 NEW_LINE num = num // 10 NEW_LINE if ( digit == 0 or N % digit != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def inv ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE x0 = 0 NEW_LINE x1 = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if ( x1 < 0 ) : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT
def derivative ( x ) : NEW_LINE INDENT return 3 * x * x NEW_LINE DEDENT
def Image ( x , k ) : NEW_LINE INDENT return x * x * x - k NEW_LINE DEDENT
def next_power ( a_t , t , a1 , prime , k ) : NEW_LINE INDENT power_p = int ( pow ( prime , t + 1 ) ) NEW_LINE next_a = ( a_t - Image ( a_t , k ) * inv ( derivative ( a1 ) , prime ) ) % power_p NEW_LINE if ( next_a < 0 ) : NEW_LINE INDENT next_a += power_p NEW_LINE return next_a NEW_LINE DEDENT return next_a NEW_LINE DEDENT
def powerOfPrime ( prime , power , k , a1 ) : NEW_LINE INDENT if ( derivative ( a1 ) != 0 ) : NEW_LINE INDENT a_t = a1 NEW_LINE for p in range ( 1 , power ) : NEW_LINE INDENT a_t = next_power ( a_t , p , a1 , prime , k ) NEW_LINE DEDENT return a_t NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findlcm ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = ( ( ( arr [ i ] * ans ) ) // ( gcd ( arr [ i ] , ans ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def minLCM ( arr , n ) : NEW_LINE INDENT ans = 1000000000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT g = gcd ( arr [ i ] , arr [ j ] ) NEW_LINE lcm = arr [ i ] / g * arr [ j ] NEW_LINE ans = min ( ans , lcm ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minLCM ( arr , n ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , arr [ i ] ) NEW_LINE DEDENT mul = [ [ ] for i in range ( mx + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( mul [ arr [ i ] ] ) > 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT mul [ arr [ i ] ] . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 1 , mx + 1 ) : NEW_LINE INDENT for j in range ( i + i , mx + 1 , i ) : NEW_LINE INDENT if ( len ( mul [ i ] ) > 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT for k in mul [ j ] : NEW_LINE INDENT if ( len ( mul [ i ] ) > 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT mul [ i ] . append ( k ) NEW_LINE DEDENT DEDENT DEDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , mx + 1 ) : NEW_LINE INDENT if ( len ( mul [ i ] ) <= 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT a , b = mul [ i ] [ 0 ] , mul [ i ] [ 1 ] NEW_LINE lcm = ( a * b ) // i NEW_LINE ans = min ( ans , lcm ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isSuffix ( s1 , s2 ) : NEW_LINE INDENT n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE if ( n1 > n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def CheckBinaryEquivalent ( N ) : NEW_LINE INDENT B_Number = 0 NEW_LINE cnt = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT rem = N % 2 NEW_LINE c = 10 ** cnt NEW_LINE B_Number += rem * c NEW_LINE N //= 2 NEW_LINE cnt += 1 NEW_LINE DEDENT bin = str ( B_Number ) NEW_LINE return isSuffix ( "001" , bin ) NEW_LINE DEDENT
def CheckBinaryEquivalent ( N ) : NEW_LINE INDENT return ( N - 1 ) % 8 == 0 NEW_LINE DEDENT
def print_practica_No ( A , B ) : NEW_LINE INDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( Is_Practical ( i ) == True ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def maxDivision ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE mxdiv = arr [ 1 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT mxdiv = mxdiv / arr [ i ] NEW_LINE DEDENT return arr [ 0 ] / mxdiv NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT upper_limit = ceil ( pow ( n , 1.0 / 4 ) ) NEW_LINE for x in range ( upper_limit + 1 ) : NEW_LINE INDENT for y in range ( upper_limit + 1 ) : NEW_LINE INDENT num1 = x * x * x * x NEW_LINE num2 = y * y * y * y NEW_LINE if ( num1 - num2 == n ) : NEW_LINE INDENT print ( "x =" , x , ", y =" , y ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def productPairs ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod NEW_LINE product = product % mod NEW_LINE DEDENT DEDENT return product % mod NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT p = 1000000007 NEW_LINE res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) != 0 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def productPairs ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = ( product % mod * ( int ) ( power ( arr [ i ] , ( 2 * n ) ) ) % mod ) % mod NEW_LINE DEDENT return ( product % mod ) NEW_LINE DEDENT
def numPairsWithPrimeSum ( arr , n ) : NEW_LINE INDENT N = 2 * 1000000 NEW_LINE isPrime = sieveOfEratosthenes ( N ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] NEW_LINE if ( isPrime [ sum ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def constructArray ( N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT arr [ i - 1 ] = i NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = ", " ) NEW_LINE DEDENT DEDENT
def digitsPresent ( n ) : NEW_LINE INDENT lastDigit = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT lastDigit = n % 10 NEW_LINE digit [ int ( lastDigit ) ] = 1 NEW_LINE n /= 10 NEW_LINE DEDENT DEDENT
def checkLastDigit ( num ) : NEW_LINE INDENT count = 0 NEW_LINE lastDigit = 0 NEW_LINE lastDigit = num % 10 NEW_LINE if ( digit [ int ( lastDigit ) ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def divisorsSame ( n ) : NEW_LINE INDENT even_div = 0 NEW_LINE odd_div = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT even_div += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_div += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT even_div += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_div += 1 NEW_LINE DEDENT if ( n // ( i % 2 ) == 0 ) : NEW_LINE INDENT even_div += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_div += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ( even_div == odd_div ) NEW_LINE DEDENT
def sieveoferanthones ( ) : NEW_LINE INDENT prime = [ 1 ] * ( n + 1 ) NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ i ] != 0 ) : NEW_LINE INDENT for j in range ( i * i , n + 1 , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( prime [ i ] != 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT DEDENT
def find ( K , N ) : NEW_LINE INDENT N = N - 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT curr_term = K NEW_LINE min_d = 9 NEW_LINE max_d = 0 NEW_LINE while curr_term > 0 : NEW_LINE INDENT r = int ( curr_term % 10 ) NEW_LINE min_d = min ( min_d , r ) NEW_LINE max_d = max ( max_d , r ) NEW_LINE curr_term = int ( curr_term / 10 ) NEW_LINE DEDENT if min_d == 0 : NEW_LINE INDENT break NEW_LINE DEDENT K = K + min_d * max_d NEW_LINE return K NEW_LINE DEDENT DEDENT
def Convert ( degree ) : NEW_LINE INDENT pi = 3.14159265359 NEW_LINE return ( degree * ( pi / 180 ) ) NEW_LINE DEDENT
def countSubarrays ( arr , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE prefixSum = [ 0 ] * n NEW_LINE prefixMin = 0 NEW_LINE prefixSum [ 0 ] = arr [ 0 ] NEW_LINE prefixMin = min ( prefixMin , prefixSum [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] NEW_LINE prefixMin = min ( prefixMin , prefixSum [ i ] ) NEW_LINE DEDENT countSubs = 0 NEW_LINE mp [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while prefixSum [ i ] - j * j >= prefixMin : NEW_LINE INDENT if prefixSum [ i ] - j * j in mp : NEW_LINE INDENT countSubs += mp [ prefixSum [ i ] - j * j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT mp [ prefixSum [ i ] ] += 1 NEW_LINE DEDENT return countSubs NEW_LINE DEDENT
def checkSolution ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT return ( ( a1 / a2 ) == ( b1 / b2 ) and ( b1 / b2 ) == ( c1 / c2 ) ) NEW_LINE DEDENT
def chiliagonNum ( n ) : NEW_LINE INDENT return ( 998 * n * n - 996 * n ) // 2 NEW_LINE DEDENT
def checkSolution ( a , b , c ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isBalancedPrime ( n ) : NEW_LINE INDENT if not isPrime ( n ) or n == 2 : NEW_LINE INDENT return False NEW_LINE DEDENT previous_prime = n - 1 NEW_LINE next_prime = n + 1 NEW_LINE while not isPrime ( next_prime ) : NEW_LINE INDENT next_prime += 1 NEW_LINE DEDENT while not isPrime ( previous_prime ) : NEW_LINE INDENT previous_prime -= 1 NEW_LINE DEDENT mean = ( previous_prime + next_prime ) / 2 NEW_LINE if n == mean : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def pentacontagonNum ( n ) : NEW_LINE INDENT return ( 48 * n * n - 46 * n ) // 2 NEW_LINE DEDENT
def positiveProduct ( arr , n ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE total_count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( total_count % 2 == 0 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT total_count += 1 NEW_LINE DEDENT if ( total_count % 2 == 0 ) : NEW_LINE INDENT ans += even_count NEW_LINE DEDENT else : NEW_LINE INDENT ans += odd_count NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def sumOfGCDofPairs ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , int ( pow ( n , 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT d1 = i NEW_LINE d2 = n // i NEW_LINE res += d1 * getCount ( d1 , n ) NEW_LINE if ( d1 != d2 ) : NEW_LINE INDENT res += d2 * getCount ( d2 , n ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def checkIsFibonacci ( arr , n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( ( arr [ i - 1 ] + arr [ i - 2 ] ) != arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def lastDigitFactorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT elif ( n == 3 ) : NEW_LINE INDENT return 6 NEW_LINE DEDENT elif ( n == 4 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def lastDigit2PowerN ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n % 4 == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif n % 4 == 2 : NEW_LINE INDENT return 4 NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT return 8 NEW_LINE DEDENT else : NEW_LINE INDENT  DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def sumSubsequences ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT kLengthSubSequence = nCr ( n , k ) NEW_LINE ans = sum * ( ( k * kLengthSubSequence ) / n ) NEW_LINE return ans NEW_LINE DEDENT
def hasOddNumberOfDivisors ( n ) : NEW_LINE INDENT if ( math . sqrt ( n ) == int ( math . sqrt ( n ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def dfs ( node , parent ) : NEW_LINE INDENT count = 0 NEW_LINE for i in adj [ node ] : NEW_LINE INDENT if ( i != parent ) : NEW_LINE INDENT count += dfs ( i , node ) NEW_LINE DEDENT DEDENT if ( hasOddNumberOfDivisors ( a [ node ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT ans [ node ] = count NEW_LINE return count NEW_LINE DEDENT
def costCalculation ( current , arr , n , pref , a , r , minimum ) : NEW_LINE INDENT index = lowerBound ( arr , len ( arr ) , current ) NEW_LINE left = index * current - pref [ index ] NEW_LINE right = ( pref [ n ] - pref [ index ] - ( n - index ) * current ) NEW_LINE res = min ( left , right ) NEW_LINE left -= res NEW_LINE right -= res NEW_LINE total = res * minimum NEW_LINE total += left * a NEW_LINE total += right * r NEW_LINE return total NEW_LINE DEDENT
def solve ( arr , n , a , r , m ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minimum = min ( a + r , m ) NEW_LINE pref = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pref [ i + 1 ] = pref [ i ] + arr [ i ] NEW_LINE DEDENT ans = 10000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = min ( ans , costCalculation ( arr [ i ] , arr , n , pref , a , r , minimum ) ) NEW_LINE DEDENT ans = min ( ans , costCalculation ( pref [ n ] // n , arr , n , pref , a , r , minimum ) ) NEW_LINE ans = min ( ans , costCalculation ( pref [ n ] // n + 1 , arr , n , pref , a , r , minimum ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def findSum ( n , k ) : NEW_LINE INDENT val = ( k // ( n - 1 ) ) * n NEW_LINE rem = k % ( n - 1 ) NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT val = val - 1 NEW_LINE DEDENT else : NEW_LINE INDENT val = val + rem NEW_LINE DEDENT sum = ( val * ( val + 1 ) ) // 2 NEW_LINE x = k // ( n - 1 ) NEW_LINE sum_of_multiples = ( x * ( x + 1 ) * n ) // 2 NEW_LINE sum -= sum_of_multiples NEW_LINE return sum NEW_LINE DEDENT
def getFactorization ( x ) : NEW_LINE INDENT count = 0 NEW_LINE v = [ ] NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE x = x // 2 NEW_LINE DEDENT if ( count != 0 ) : NEW_LINE INDENT v . append ( count ) NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( x ) ) + 12 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE x //= i NEW_LINE DEDENT if ( count != 0 ) : NEW_LINE INDENT v . append ( count ) NEW_LINE DEDENT DEDENT if ( x > 1 ) : NEW_LINE INDENT v . append ( 1 ) NEW_LINE DEDENT return v NEW_LINE DEDENT
def nonPrimeDivisors ( N ) : NEW_LINE INDENT v = getFactorization ( N ) NEW_LINE ret = 1 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT ret = ret * ( v [ i ] + 1 ) NEW_LINE DEDENT ret = ret - len ( v ) NEW_LINE return ret NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT s = sqrt ( x ) NEW_LINE return ( s * s == x ) NEW_LINE DEDENT
def isFibonacci ( n ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) NEW_LINE DEDENT
def checkDigits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT dig = n % 10 NEW_LINE if ( dig == 4 and dig == 6 and dig == 7 and dig == 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n /= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isFullfibonacci ( n ) : NEW_LINE INDENT return ( checkDigits ( n ) and isFibonacci ( n ) ) NEW_LINE DEDENT
def checksilverRatio ( a , b ) : NEW_LINE INDENT a , b = max ( a , b ) , min ( a , b ) NEW_LINE ratio1 = round ( a / b , 3 ) NEW_LINE ratio2 = round ( ( 2 * a + b ) / a , 3 ) NEW_LINE if ratio1 == ratio2 and ratio1 == 2.414 : NEW_LINE INDENT print ( "Yes" ) NEW_LINE return True NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE return False NEW_LINE DEDENT DEDENT
def MIN ( n ) : NEW_LINE INDENT ans = 11 NEW_LINE while n : NEW_LINE INDENT ans = min ( ans , n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def MAX ( n ) : NEW_LINE INDENT ans = - 1 NEW_LINE while n : NEW_LINE INDENT ans = max ( ans , n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def Find_value ( n , k ) : NEW_LINE INDENT k -= 1 NEW_LINE ( x , y ) = ( 0 , 0 ) NEW_LINE while k : NEW_LINE INDENT k -= 1 NEW_LINE x = MIN ( n ) NEW_LINE y = MAX ( n ) NEW_LINE if ( ( y - x ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT n *= ( y - x ) NEW_LINE DEDENT print ( n , end = ' ' ) NEW_LINE DEDENT
def countBinaries ( N ) : NEW_LINE INDENT ctr = 1 NEW_LINE ans = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 == 1 ) : NEW_LINE INDENT ans += pow ( 2 , ctr - 1 ) NEW_LINE DEDENT elif ( N % 10 > 1 ) : NEW_LINE INDENT ans = pow ( 2 , ctr ) - 1 NEW_LINE DEDENT ctr += 1 NEW_LINE N //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countBinaries ( N ) : NEW_LINE INDENT powersOfTwo = [ 0 ] * 11 NEW_LINE powersOfTwo [ 0 ] = 1 NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT powersOfTwo [ i ] = powersOfTwo [ i - 1 ] * 2 NEW_LINE DEDENT ctr = 1 NEW_LINE ans = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 == 1 ) : NEW_LINE INDENT ans += powersOfTwo [ ctr - 1 ] NEW_LINE DEDENT elif ( N % 10 > 1 ) : NEW_LINE INDENT ans = powersOfTwo [ ctr ] - 1 NEW_LINE DEDENT ctr += 1 NEW_LINE N = N // 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sum_Centered_Hexadecagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += Centered_Hexadecagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT
def heptadecagonal_num ( n ) : NEW_LINE INDENT return ( ( 15 * n * n ) - 13 * n ) // 2 NEW_LINE DEDENT
def sum_heptadecagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += heptadecagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT
def center_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) // 2 NEW_LINE DEDENT
def sum_center_heptagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += center_heptagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT
def Centered_Dodecagonal_num ( n ) : NEW_LINE INDENT return 6 * n * ( n - 1 ) + 1 NEW_LINE DEDENT
def sum_Centered_Dodecagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += Centered_Dodecagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT
def center_Octagonal_num ( n ) : NEW_LINE INDENT return ( 4 * n * n - 4 * n + 1 ) NEW_LINE DEDENT
def sum_center_Octagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += center_Octagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT
def Centered_decagonal_num ( n ) : NEW_LINE INDENT return ( 5 * n * n - 5 * n + 1 ) NEW_LINE DEDENT
def sum_Centered_decagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += Centered_decagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT
def center_octadecagon_num ( n ) : NEW_LINE INDENT return ( 9 * n * n - 9 * n + 1 ) NEW_LINE DEDENT
def sum_center_octadecagon_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += center_octadecagon_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT
def Centered_Pentadecagonal_num ( n ) : NEW_LINE INDENT return ( 15 * n * n - 15 * n + 2 ) // 2 NEW_LINE DEDENT
def sum_Centered_Pentadecagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += Centered_Pentadecagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT
def isMyriagon ( N ) : NEW_LINE INDENT n = ( 9996 + math . sqrt ( 79984 * N + 99920016 ) ) / 19996 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isOctadecagon ( N ) : NEW_LINE INDENT n = ( 14 + math . sqrt ( 128 * N + 196 ) ) // 32 NEW_LINE return ( ( n - int ( n ) ) == 0 ) NEW_LINE DEDENT
def isoctagonal ( N ) : NEW_LINE INDENT n = ( 2 + sqrt ( 12 * N + 4 ) ) / 6 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isheptagonal ( N ) : NEW_LINE INDENT n = ( 3 + math . sqrt ( 40 * N + 9 ) ) / 10 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isPentadecagon ( N ) : NEW_LINE INDENT n = ( 11 + sqrt ( 104 * N + 121 ) ) / 26 NEW_LINE return ( n - int ( n ) == 0 ) NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return ( fact ( n ) // ( fact ( r ) * fact ( n - r ) ) ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countSubsequences ( arr , n , k ) : NEW_LINE INDENT countPrime = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPrime ( arr [ i ] ) ) : NEW_LINE INDENT countPrime += 1 NEW_LINE DEDENT DEDENT if ( countPrime < k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( nCr ( countPrime , k ) * pow ( 2 , ( n - countPrime ) ) ) NEW_LINE DEDENT
def longestEvenOddSubarray ( arr , n ) : NEW_LINE INDENT longest = 1 NEW_LINE cnt = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ( arr [ i ] + arr [ i + 1 ] ) % 2 == 1 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT else : NEW_LINE INDENT longest = max ( longest , cnt ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT if ( longest == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max ( cnt , longest ) NEW_LINE DEDENT
def digSum ( a ) : NEW_LINE INDENT _sum = 0 NEW_LINE while ( a ) : NEW_LINE INDENT _sum += a % 10 NEW_LINE a = a // 10 NEW_LINE DEDENT return _sum NEW_LINE DEDENT
def isPrime ( r ) : NEW_LINE INDENT s = True NEW_LINE i = 2 NEW_LINE while i * i <= r : NEW_LINE INDENT if ( r % i == 0 ) : NEW_LINE INDENT s = False NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def istetradecagonal ( N ) : NEW_LINE INDENT n = ( 10 + math . sqrt ( 96 * N + 100 ) ) / 24 NEW_LINE if ( n - int ( n ) ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def ishexadecagonal ( N ) : NEW_LINE INDENT n = ( 12 + sqrt ( 112 * N + 144 ) ) / 28 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isnonagonal ( N ) : NEW_LINE INDENT n = ( 5 + pow ( ( 56 * N + 25 ) , 1 / 2 ) ) / 14 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return fact ( n ) // ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def countSubsequences ( arr , n , k ) : NEW_LINE INDENT countOdd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT countOdd += 1 NEW_LINE DEDENT DEDENT ans = nCr ( n , k ) - nCr ( countOdd , k ) NEW_LINE return ans NEW_LINE DEDENT
def divParts ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT print ( ( N / 2 ) - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N / 2 ) NEW_LINE DEDENT DEDENT
def solve ( s , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = 0 NEW_LINE maxlength = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '(' ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT right += 1 NEW_LINE DEDENT if ( left == right ) : NEW_LINE INDENT maxlength = max ( maxlength , 2 * right ) NEW_LINE DEDENT elif ( right > left ) : NEW_LINE INDENT left = right = 0 NEW_LINE DEDENT DEDENT left = right = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '(' ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT right += 1 NEW_LINE DEDENT if ( left == right ) : NEW_LINE INDENT maxlength = max ( maxlength , 2 * left ) NEW_LINE DEDENT elif ( left > right ) : NEW_LINE INDENT left = right = 0 NEW_LINE DEDENT DEDENT return maxlength NEW_LINE DEDENT
def Icosagonal_num ( n ) : NEW_LINE INDENT return ( 18 * n * n - 16 * n ) // 2 NEW_LINE DEDENT
def sum_Icosagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += Icosagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT
def Centered_Pentagonal_num ( n ) : NEW_LINE INDENT return ( 5 * n * n - 5 * n + 2 ) // 2 NEW_LINE DEDENT
def sum_Centered_Pentagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += Centered_Pentagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT
def Centered_tridecagonal_num ( n ) : NEW_LINE INDENT return ( 13 * n * ( n - 1 ) + 2 ) // 2 NEW_LINE DEDENT
def sum_Centered_tridecagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += Centered_tridecagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT
def getMinSteps ( n , jump ) : NEW_LINE INDENT quotient = int ( n / jump ) NEW_LINE remainder = n % jump NEW_LINE steps = quotient + remainder NEW_LINE return steps NEW_LINE DEDENT
def Betrothed_Sum ( n ) : NEW_LINE INDENT Set = [ ] NEW_LINE for number_1 in range ( 1 , n ) : NEW_LINE INDENT sum_divisor_1 = 1 NEW_LINE i = 2 NEW_LINE while i * i <= number_1 : NEW_LINE INDENT if ( number_1 % i == 0 ) : NEW_LINE INDENT sum_divisor_1 = sum_divisor_1 + i NEW_LINE if ( i * i != number_1 ) : NEW_LINE INDENT sum_divisor_1 += number_1 // i NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT if ( sum_divisor_1 > number_1 ) : NEW_LINE INDENT number_2 = sum_divisor_1 - 1 NEW_LINE sum_divisor_2 = 1 NEW_LINE j = 2 NEW_LINE while j * j <= number_2 : NEW_LINE INDENT if ( number_2 % j == 0 ) : NEW_LINE INDENT sum_divisor_2 += j NEW_LINE if ( j * j != number_2 ) : NEW_LINE INDENT sum_divisor_2 += number_2 // j NEW_LINE DEDENT DEDENT j = j + 1 NEW_LINE DEDENT if ( sum_divisor_2 == number_1 + 1 and number_1 <= n and number_2 <= n ) : NEW_LINE INDENT Set . append ( number_1 ) NEW_LINE Set . append ( number_2 ) NEW_LINE DEDENT DEDENT DEDENT Summ = 0 NEW_LINE for i in Set : NEW_LINE INDENT if i <= n : NEW_LINE INDENT Summ += i NEW_LINE DEDENT DEDENT return Summ NEW_LINE DEDENT
def constructArray ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE DEDENT DEDENT
def prod_of_max_min ( n ) : NEW_LINE INDENT largest = 0 NEW_LINE smallest = 10 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE largest = max ( r , largest ) NEW_LINE smallest = min ( r , smallest ) NEW_LINE n = n // 10 NEW_LINE DEDENT return largest * smallest NEW_LINE DEDENT
def formed_no ( N , K ) : NEW_LINE INDENT if ( K == 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT answer = N NEW_LINE while ( K != 0 ) : NEW_LINE INDENT a_current = prod_of_max_min ( answer ) NEW_LINE if ( a_current == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT answer += a_current NEW_LINE K -= 1 NEW_LINE DEDENT return answer NEW_LINE DEDENT
def isCenteredtridecagonal ( N ) : NEW_LINE INDENT n = ( 13 + np . sqrt ( 104 * N + 65 ) ) / 26 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isCenteredpentagonal ( N ) : NEW_LINE INDENT n = ( 5 + np . sqrt ( 40 * N - 15 ) ) / 10 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isCentereddecagonal ( N ) : NEW_LINE INDENT n = ( 5 + np . sqrt ( 20 * N + 5 ) ) / 10 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isdodecagonal ( N ) : NEW_LINE INDENT n = ( 4 + np . sqrt ( 20 * N + 16 ) ) / 10 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 6 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def SexyPrime ( n1 , n2 ) : NEW_LINE INDENT return ( isPrime ( n1 ) and isPrime ( n2 ) and abs ( n1 - n2 ) == 6 ) NEW_LINE DEDENT
def countSexyPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( SexyPrime ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def computePrime ( N ) : NEW_LINE INDENT Prime = [ True ] * ( N + 1 ) NEW_LINE Prime [ 0 ] = False NEW_LINE Prime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i <= N : NEW_LINE INDENT if ( Prime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N , i ) : NEW_LINE INDENT Prime [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return Prime NEW_LINE DEDENT
def countSexyPairs ( arr , n ) : NEW_LINE INDENT maxE = max ( arr ) NEW_LINE Prime = computePrime ( maxE ) NEW_LINE count = 0 NEW_LINE freq = [ 0 ] * ( maxE + 6 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Prime [ arr [ i ] ] ) : NEW_LINE INDENT if ( ( arr [ i ] + 6 ) <= ( maxE ) and freq [ arr [ i ] + 6 ] > 0 and Prime [ arr [ i ] + 6 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def nDigitPerfectSquares ( n , b ) : NEW_LINE INDENT largest = pow ( math . ceil ( math . sqrt ( pow ( b , n ) ) ) - 1 , 2 ) NEW_LINE print ( largest ) NEW_LINE DEDENT
def findNum ( n , k ) : NEW_LINE INDENT q = k // ( n - 1 ) NEW_LINE r = k % ( n - 1 ) NEW_LINE if ( r != 0 ) : NEW_LINE INDENT a = ( n * q ) + r NEW_LINE DEDENT else : NEW_LINE INDENT a = ( n * q ) - 1 NEW_LINE DEDENT print ( a ) NEW_LINE DEDENT
def cubeRoot ( n ) : NEW_LINE INDENT ans = pow ( 3 , ( 1.0 / 3 ) * ( np . log ( n ) / np . log ( 3 ) ) ) NEW_LINE return ans NEW_LINE DEDENT
def floorMax ( A , B , N ) : NEW_LINE INDENT x = min ( B - 1 , N ) NEW_LINE return ( A * x ) // B NEW_LINE DEDENT
def calculateMoves ( n ) : NEW_LINE INDENT count = 0 NEW_LINE layers = n // 2 NEW_LINE for k in range ( 1 , layers + 1 ) : NEW_LINE INDENT count += 8 * k * k NEW_LINE DEDENT return count NEW_LINE DEDENT
def countWays ( N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N - 1 ) * ( N - 2 ) / 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def isSumSquare ( N ) : NEW_LINE INDENT n = ( 2 + math . sqrt ( 8 * N - 4 ) ) / 2 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isCenteredheptagonal ( N ) : NEW_LINE INDENT n = ( 7 + math . sqrt ( 56 * N - 7 ) ) / 14 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isCenterednonadecagonal ( N ) : NEW_LINE INDENT n = ( 19 + math . sqrt ( 152 * N + 209 ) ) / 38 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isCenteredOctadecagonal ( N ) : NEW_LINE INDENT n = ( 9 + math . sqrt ( 36 * N + 45 ) ) / 18 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def countDigit ( n ) : NEW_LINE INDENT return ( math . floor ( math . log10 ( n ) + 1 ) ) NEW_LINE DEDENT
def isPower ( n , k ) : NEW_LINE INDENT res1 = int ( log ( n ) / log ( k ) ) NEW_LINE res2 = log ( n ) / log ( k ) NEW_LINE return ( res1 == res2 ) NEW_LINE DEDENT
def prevPowerofK ( n , k ) : NEW_LINE INDENT p = ( int ) ( log ( n ) / log ( k ) ) NEW_LINE return pow ( k , p ) NEW_LINE DEDENT
def nextPowerOfK ( n , k ) : NEW_LINE INDENT return prevPowerofK ( n , k ) * k NEW_LINE DEDENT
def subarray ( arr , n ) : NEW_LINE INDENT ans , temp = 1 , 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT temp = temp + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , temp ) NEW_LINE temp = 1 NEW_LINE DEDENT DEDENT ans = max ( ans , temp ) NEW_LINE return ans NEW_LINE DEDENT
def findMaxMinSubArray ( arr , K , n ) : NEW_LINE INDENT min = n NEW_LINE max = 0 NEW_LINE left = 0 NEW_LINE right = n NEW_LINE tmp = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tmp = 1 NEW_LINE left = i NEW_LINE while ( left - 1 >= 0 and abs ( arr [ left ] - arr [ left - 1 ] ) <= K ) : NEW_LINE INDENT left = left - 1 NEW_LINE tmp = tmp + 1 NEW_LINE DEDENT right = i NEW_LINE while ( right + 1 <= n - 1 and abs ( arr [ right ] - arr [ right + 1 ] ) <= K ) : NEW_LINE INDENT right = right + 1 NEW_LINE tmp = tmp + 1 NEW_LINE DEDENT if ( min > tmp ) : NEW_LINE INDENT min = tmp NEW_LINE DEDENT if ( max < tmp ) : NEW_LINE INDENT max = tmp NEW_LINE DEDENT DEDENT print ( min , end = ', ' ) NEW_LINE print ( max , end = '' ) NEW_LINE DEDENT
def countElement ( arr , n ) : NEW_LINE INDENT freq = { } NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT tmpsum = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT tmpsum += arr [ j ] NEW_LINE if tmpsum in freq : NEW_LINE INDENT ans += freq [ tmpsum ] NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def first_digit ( x , y ) : NEW_LINE INDENT length = int ( math . log ( x ) / math . log ( y ) + 1 ) NEW_LINE first_digit = x / math . pow ( y , length - 1 ) NEW_LINE print ( int ( first_digit ) ) NEW_LINE DEDENT
def kthRoot ( n , k ) : NEW_LINE INDENT return pow ( k , ( ( 1.0 / k ) * ( np . log ( n ) / np . log ( k ) ) ) ) NEW_LINE DEDENT
def checksum ( n , k ) : NEW_LINE INDENT first_term = ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 NEW_LINE if ( first_term - int ( first_term ) == 0 ) : NEW_LINE INDENT for i in range ( int ( first_term ) , int ( first_term ) + k ) : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( '-1' ) NEW_LINE DEDENT DEDENT
def distributeN ( A , B , C , n ) : NEW_LINE INDENT maximum = max ( A , B , C ) NEW_LINE sum = A + B + C NEW_LINE p = ( 3 * maximum ) - sum NEW_LINE diff = n - p NEW_LINE if diff < 0 or diff % 3 : NEW_LINE INDENT print "No" NEW_LINE DEDENT else : NEW_LINE INDENT print "Yes" NEW_LINE DEDENT DEDENT
def minimumSteps ( a , b , c ) : NEW_LINE INDENT if a < 1 or b < 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if a == 1 and b == 1 : NEW_LINE INDENT return c NEW_LINE DEDENT if a < b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT return minimumSteps ( a - b , b , c + 1 ) NEW_LINE DEDENT
def count_pairs ( x ) : NEW_LINE INDENT ans = 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 2 == 1 ) : NEW_LINE INDENT ans = ans * 3 NEW_LINE DEDENT x = x // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT
def countSquares ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( int ( math . pow ( 10 , ( n - 1 ) ) ) , int ( math . pow ( 10 , n ) ) ) : NEW_LINE INDENT if ( i != 0 and isPerfectSquare ( i ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def countSquares ( n ) : NEW_LINE INDENT r = math . ceil ( math . sqrt ( math . pow ( 10 , n ) ) ) NEW_LINE l = math . ceil ( math . sqrt ( math . pow ( 10 , n - 1 ) ) ) NEW_LINE return r - l NEW_LINE DEDENT
def summation ( N ) : NEW_LINE INDENT co = ( N + 1 ) / 2 NEW_LINE co = int ( co ) NEW_LINE ce = N / 2 NEW_LINE ce = int ( ce ) NEW_LINE se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) NEW_LINE so = ( co * co ) * ( 2 * ( co * co ) - 1 ) NEW_LINE return so - se NEW_LINE DEDENT
def isStar ( N ) : NEW_LINE INDENT n = ( math . sqrt ( 24 * N + 12 ) + 6 ) / 6 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def sumEvenNumbers ( N , K ) : NEW_LINE INDENT check = N - 2 * ( K - 1 ) NEW_LINE if ( check > 0 and check % 2 == 0 ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( "2 " , end = "" ) NEW_LINE DEDENT print ( check ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def findMinDivisor ( arr , n , limit ) : NEW_LINE INDENT low = 0 NEW_LINE high = 10 ** 9 NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ceil ( arr [ i ] / mid ) NEW_LINE DEDENT if ( sum <= limit ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT
def getCount ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 1 , n - 1 ) : NEW_LINE INDENT p , q = 0 , 0 NEW_LINE for i in range ( j ) : NEW_LINE INDENT if ( arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ k ] % arr [ j ] == 0 ) : NEW_LINE INDENT q += 1 NEW_LINE DEDENT DEDENT count += p * q NEW_LINE DEDENT return count NEW_LINE DEDENT
def computeMaxValue ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT val = max ( arr [ i ] / arr [ j ] , arr [ j ] / arr [ i ] ) NEW_LINE ans = max ( ans , val ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def kthNonDivisible ( N , K ) : NEW_LINE INDENT L = 1 NEW_LINE H = sys . maxsize NEW_LINE ans = 0 NEW_LINE while ( L <= H ) : NEW_LINE INDENT mid = ( L + H ) // 2 NEW_LINE sol = mid - mid // N NEW_LINE if ( sol > K ) : NEW_LINE INDENT H = mid - 1 NEW_LINE DEDENT elif ( sol < K ) : NEW_LINE INDENT L = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE DEDENT H = mid - 1 NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
def kthNonDivisible ( N , K ) : NEW_LINE INDENT return K + math . floor ( ( K - 1 ) / ( N - 1 ) ) NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT
def checkSunnyNumber ( N ) : NEW_LINE INDENT if ( isPerfectSquare ( N + 1 ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def findPairEvenParity ( arr , n ) : NEW_LINE INDENT firstMaximum = - 1 NEW_LINE secondMaximum = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if isEvenParity ( arr [ i ] ) == True : NEW_LINE INDENT if ( arr [ i ] >= firstMaximum ) : NEW_LINE INDENT secondMaximum = firstMaximum NEW_LINE firstMaximum = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] >= secondMaximum ) : NEW_LINE INDENT secondMaximum = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( firstMaximum , secondMaximum ) NEW_LINE DEDENT
def isHexagonal ( N ) : NEW_LINE INDENT val = 8 * N + 1 NEW_LINE x = 1 + sqrt ( val ) NEW_LINE n = x / 4 NEW_LINE if ( ( n - int ( n ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def NumbertoCharacter ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE r = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE rev = rev * 10 + r NEW_LINE n = n // 10 NEW_LINE DEDENT while ( rev > 0 ) : NEW_LINE INDENT r = rev % 10 NEW_LINE switcher = { 0 : "zero " , 1 : "one " , 2 : "two " , 3 : "three " , 4 : "four " , 5 : "five " , 6 : "six " , 7 : "seven " , 8 : "eight " , 9 : "nine " } NEW_LINE print ( switcher . get ( r , "UnValid" ) , end = " " ) NEW_LINE rev = rev // 10 NEW_LINE DEDENT DEDENT
def Solve ( arr , n ) : NEW_LINE INDENT temp = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp = temp + arr [ j ] NEW_LINE if ( ( temp + 2 ) % 4 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def nCr ( n , p , f ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT if ( j > i ) : NEW_LINE INDENT f [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( j == 0 or j == i ) : NEW_LINE INDENT f [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT f [ i ] [ j ] = ( ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def prodSquare ( n ) : NEW_LINE INDENT for i in range ( 2 , ( n ) + 1 ) : NEW_LINE INDENT if ( i * i < ( n + 1 ) ) : NEW_LINE INDENT for j in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( ( i * i * j * j ) == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def prodSquare ( n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT s [ i * i ] = 1 NEW_LINE if ( ( n // ( i * i ) ) in s ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def printPair ( n ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE print ( n - 1 ) NEW_LINE DEDENT
def isAutoBiographyNum ( number ) : NEW_LINE INDENT count = 0 NEW_LINE NUM = str ( number ) NEW_LINE size = len ( NUM ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT position = ord ( NUM [ i ] ) - ord ( '0' ) NEW_LINE count = 0 NEW_LINE for j in range ( size ) : NEW_LINE INDENT digit = ord ( NUM [ j ] ) - ord ( '0' ) NEW_LINE if ( digit == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( position != count ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def checkArray ( arr , n ) : NEW_LINE INDENT current_length = 0 NEW_LINE max_length = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isAutoBiographyNum ( arr [ i ] ) ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT current_length = 0 NEW_LINE DEDENT max_length = max ( max_length , current_length ) NEW_LINE DEDENT return max_length NEW_LINE DEDENT
def GetSum ( n ) : NEW_LINE INDENT divisors = [ ] NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT divisors . append ( i ) NEW_LINE if ( i != n // i ) : NEW_LINE INDENT divisors . append ( n // i ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT ans = 1 NEW_LINE for i in divisors : NEW_LINE INDENT ans *= ( i + 1 ) NEW_LINE DEDENT ans = ans - 1 NEW_LINE return ans NEW_LINE DEDENT
def calculateWays ( N ) : NEW_LINE INDENT x = 0 NEW_LINE v = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT v . append ( 0 ) NEW_LINE DEDENT for i in range ( N // 2 + 1 ) : NEW_LINE INDENT if ( N % 2 == 0 and i == N // 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT x = N * ( i + 1 ) - ( i + 1 ) * i NEW_LINE v [ i ] = x NEW_LINE v [ N - i - 1 ] = x NEW_LINE DEDENT return v NEW_LINE DEDENT
def isPowerful ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n //= 2 NEW_LINE power += 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for factor in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % factor == 0 ) : NEW_LINE INDENT n = n // factor NEW_LINE power += 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return ( n == 1 ) NEW_LINE DEDENT
def longestPowerfulSubsequence ( arr , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPowerful ( arr [ i ] ) ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def maxOR ( arr , n ) : NEW_LINE INDENT max_value = max ( arr ) NEW_LINE number_of_bits = floor ( log2 ( max_value ) ) + 1 NEW_LINE complement = ( ( ( 1 << number_of_bits ) - 1 ) ^ max_value ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != max_value ) : NEW_LINE INDENT c = max ( c , ( complement & arr [ i ] ) ) NEW_LINE DEDENT DEDENT return ( max_value + c ) NEW_LINE DEDENT
def update ( res , L , R , K ) : NEW_LINE INDENT L = L - 1 NEW_LINE R = R - 1 NEW_LINE res [ L ] = res [ L ] ^ K NEW_LINE res [ R + 1 ] = res [ R + 1 ] ^ K NEW_LINE DEDENT
def check ( a , n , k ) : NEW_LINE INDENT m = defaultdict ( int ) NEW_LINE extra = 0 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT m [ a [ i ] ] += 1 NEW_LINE DEDENT for x in m : NEW_LINE INDENT extra += m [ x ] - 1 NEW_LINE DEDENT if ( extra == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , i + k - 1 < n ) : NEW_LINE INDENT if ( m [ a [ i + k - 1 ] ] > 1 ) : NEW_LINE INDENT extra -= 1 NEW_LINE DEDENT m [ a [ i + k - 1 ] ] -= 1 NEW_LINE m [ a [ i - 1 ] ] += 1 NEW_LINE if ( m [ a [ i - 1 ] ] > 1 ) : NEW_LINE INDENT extra += 1 NEW_LINE DEDENT if ( extra == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def minlength ( a , n ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = n + 1 NEW_LINE ans = 0 NEW_LINE while ( lo < hi ) : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE if ( check ( a , n , mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT Prime [ 0 ] = Prime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i <= MAX : NEW_LINE INDENT if ( Prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , MAX , i ) : NEW_LINE INDENT Prime [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def dfs ( node , parent , h ) : NEW_LINE INDENT height [ node ] = h NEW_LINE for to in graph [ node ] : NEW_LINE INDENT if ( to == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( to , node , h + 1 ) NEW_LINE DEDENT DEDENT
def primeHeightNode ( N ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( Prime [ height [ i ] ] ) : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT
def sumOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def smallestNum ( X , Y ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( X , MAXN ) : NEW_LINE INDENT sum_of_digit = sumOfDigits ( i ) NEW_LINE if sum_of_digit % Y == 0 : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def calculateBill ( units ) : NEW_LINE INDENT if ( units <= 100 ) : NEW_LINE INDENT return units * 10 NEW_LINE DEDENT elif ( units <= 200 ) : NEW_LINE INDENT return ( ( 100 * 10 ) + ( units - 100 ) * 15 ) NEW_LINE DEDENT elif ( units <= 300 ) : NEW_LINE INDENT return ( ( 100 * 10 ) + ( 100 * 15 ) + ( units - 200 ) * 20 ) NEW_LINE DEDENT elif ( units > 300 ) : NEW_LINE INDENT return ( ( 100 * 10 ) + ( 100 * 15 ) + ( 100 * 20 ) + ( units - 300 ) * 25 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def countValues ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT k = n NEW_LINE while ( k >= i ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT k //= i NEW_LINE DEDENT else : NEW_LINE INDENT k -= i NEW_LINE DEDENT DEDENT if ( k == 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def countValues ( N ) : NEW_LINE INDENT div = [ ] NEW_LINE i = 2 NEW_LINE while ( ( i * i ) <= N ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT div . append ( i ) NEW_LINE if ( N != i * i ) : NEW_LINE INDENT div . append ( N // i ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT answer = 0 NEW_LINE i = 1 NEW_LINE while ( ( i * i ) <= N - 1 ) : NEW_LINE INDENT if ( ( N - 1 ) % i == 0 ) : NEW_LINE INDENT if ( i * i == N - 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT else : NEW_LINE INDENT answer += 2 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for d in div : NEW_LINE INDENT K = N NEW_LINE while ( K % d == 0 ) : NEW_LINE INDENT K //= d NEW_LINE DEDENT if ( ( K - 1 ) % d == 0 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def reverse ( a ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT r = a % 10 NEW_LINE rev = rev * 10 + r NEW_LINE a = a // 10 NEW_LINE DEDENT return ( rev ) NEW_LINE DEDENT
def prime ( a ) : NEW_LINE INDENT k = 0 NEW_LINE for i in range ( 2 , a ) : NEW_LINE INDENT if ( a % i == 0 ) : NEW_LINE INDENT k = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( k == 1 ) : NEW_LINE INDENT return ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 1 ) NEW_LINE DEDENT DEDENT
def adam ( a ) : NEW_LINE INDENT r1 = reverse ( a ) NEW_LINE s1 = a * a NEW_LINE s2 = r1 * r1 NEW_LINE r2 = reverse ( s2 ) NEW_LINE if ( s1 == r2 ) : NEW_LINE INDENT return ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 0 ) NEW_LINE DEDENT DEDENT
def sieve ( ) : NEW_LINE INDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT for j in range ( i , MAX , i ) : NEW_LINE INDENT divisor [ j ] . append ( i ) NEW_LINE DEDENT DEDENT DEDENT
def countPrimeFactors ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT cnt = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def preCompute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isComposite ( i ) NEW_LINE DEDENT DEDENT
def countPalindromic ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT count = pow ( 9 , ( n - 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT count = pow ( 9 , ( n - 2 ) // 2 ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def countSubArrayWithOddProduct ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE last = - 1 NEW_LINE K = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT K = ( i - last - 1 ) NEW_LINE count += ( K * ( K + 1 ) / 2 ) NEW_LINE last = i NEW_LINE DEDENT DEDENT K = ( N - last - 1 ) NEW_LINE count += ( K * ( K + 1 ) / 2 ) NEW_LINE return count NEW_LINE DEDENT
def CgpaCalc ( marks , n ) : NEW_LINE INDENT grade = [ 0 ] * n NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT grade [ i ] = ( marks [ i ] / 10 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT Sum += grade [ i ] NEW_LINE DEDENT cgpa = Sum / n NEW_LINE return cgpa NEW_LINE DEDENT
def printMaxPair ( arr , n ) : NEW_LINE INDENT largest = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT number = int ( getNumber ( arr [ i ] , arr [ j ] ) ) NEW_LINE largest = max ( largest , number ) NEW_LINE DEDENT DEDENT print ( largest ) NEW_LINE DEDENT
def printKNumbers ( N , K ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( 1 , end = ' ' ) NEW_LINE DEDENT print ( N - K + 1 ) NEW_LINE DEDENT
def minNum ( n , k ) : NEW_LINE INDENT x = int ( ( math . log ( n ) // math . log ( k ) ) ) + 1 NEW_LINE mn = pow ( k , x ) - n NEW_LINE return mn NEW_LINE DEDENT
def previousPerfectCube ( N ) : NEW_LINE INDENT prevN = math . floor ( np . cbrt ( N ) ) NEW_LINE if ( prevN * prevN * prevN == N ) : NEW_LINE INDENT prevN -= 1 NEW_LINE DEDENT return prevN * prevN * prevN NEW_LINE DEDENT
def findCount ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] % 2 == 0 ) and ( arr [ j ] % 2 == 1 ) ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def findCount ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + count NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def sumDig ( n ) : NEW_LINE INDENT s = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT s = s + int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return s NEW_LINE DEDENT
def Pec ( n ) : NEW_LINE INDENT dup = n NEW_LINE dig = sumDig ( n ) NEW_LINE if ( dig * 3 == dup ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT else : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT
def power ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = power ( a , b // 2 ) NEW_LINE temp = ( temp * temp ) % MOD NEW_LINE if ( b % 2 != 0 ) : NEW_LINE INDENT temp = ( temp * a ) % MOD NEW_LINE DEDENT return temp NEW_LINE DEDENT
def joinNumbers ( numA , numB ) : NEW_LINE INDENT revB = 0 NEW_LINE while ( numB > 0 ) : NEW_LINE INDENT revB = revB * 10 + ( numB % 10 ) NEW_LINE numB = numB // 10 NEW_LINE DEDENT while ( revB > 0 ) : NEW_LINE INDENT numA = numA * 10 + ( revB % 10 ) NEW_LINE revB = revB // 10 NEW_LINE DEDENT return numA NEW_LINE DEDENT
def reverse ( n ) : NEW_LINE INDENT r = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = r * 10 NEW_LINE r = r + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return ( r ) NEW_LINE DEDENT
def operation ( n ) : NEW_LINE INDENT i = 1 NEW_LINE count = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT a = digit_sum ( i ) NEW_LINE r = reverse ( i ) NEW_LINE if ( i % a == 0 and r % a == 0 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE count += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT
def calcCount ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( k % arr [ i ] == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if sum == n and n != 1 else False ) NEW_LINE DEDENT
def contiguousPerfectNumber ( arr , n ) : NEW_LINE INDENT current_length = 0 NEW_LINE max_length = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( isPerfect ( arr [ i ] ) ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT current_length = 0 NEW_LINE DEDENT max_length = max ( max_length , current_length ) NEW_LINE DEDENT return max_length NEW_LINE DEDENT
def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE i = 2 NEW_LINE while ( i * i < n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i * i != n ) : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( sum == n and n != 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isPowerful ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n /= 2 NEW_LINE power += 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT factor = 3 NEW_LINE while ( factor * factor <= n ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % factor == 0 ) : NEW_LINE INDENT n = n / factor NEW_LINE power += 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT factor += 2 NEW_LINE DEDENT return ( n == 1 ) NEW_LINE DEDENT
def dfs ( Node , parent ) : NEW_LINE INDENT global ans NEW_LINE if ( isPowerful ( weight [ Node ] ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT for to in graph [ Node ] : NEW_LINE INDENT if ( to == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( to , Node ) NEW_LINE DEDENT DEDENT
def isPowerful ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE power = power + 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for factor in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % factor == 0 ) : NEW_LINE INDENT n = n // factor NEW_LINE power = power + 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT return ( n == 1 ) NEW_LINE DEDENT
def contiguousPowerfulNumber ( arr , n ) : NEW_LINE INDENT current_length = 0 NEW_LINE max_length = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( isPowerful ( arr [ i ] ) ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT current_length = 0 NEW_LINE DEDENT max_length = max ( max_length , current_length ) NEW_LINE DEDENT return max_length NEW_LINE DEDENT
def maxSum ( arr , K , start , end , max_sum ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return max_sum NEW_LINE DEDENT max_sum_start = max_sum + arr [ start ] NEW_LINE max_sum_end = max_sum + arr [ end ] NEW_LINE ans = max ( maxSum ( arr , K - 1 , start + 1 , end , max_sum_start ) , maxSum ( arr , K - 1 , start , end - 1 , max_sum_end ) ) NEW_LINE return ans NEW_LINE DEDENT
def maximizeSum ( arr , K , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE start = 0 NEW_LINE end = n - 1 NEW_LINE print ( maxSum ( arr , K , start , end , max_sum ) ) NEW_LINE DEDENT
def maxPointCount ( arr , K , size ) : NEW_LINE INDENT curr_points = 0 NEW_LINE max_points = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT curr_points += arr [ i ] NEW_LINE DEDENT max_points = curr_points NEW_LINE j = size - 1 NEW_LINE for i in range ( K - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr_points = ( curr_points + arr [ j ] - arr [ i ] ) NEW_LINE max_points = max ( curr_points , max_points ) NEW_LINE j -= 1 NEW_LINE DEDENT return max_points NEW_LINE DEDENT
def count ( N , B ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += ( B - 1 ) * pow ( B , i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def GetMinCost ( N ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT pq . append ( i ) NEW_LINE DEDENT pq . sort ( reverse = False ) NEW_LINE cost = 0 NEW_LINE while ( len ( pq ) > 1 ) : NEW_LINE INDENT mini = pq [ 0 ] NEW_LINE pq . remove ( pq [ 0 ] ) NEW_LINE secondmini = pq [ 0 ] NEW_LINE pq . remove ( pq [ 0 ] ) NEW_LINE current = mini * secondmini NEW_LINE cost += current NEW_LINE pq . append ( current ) NEW_LINE pq . sort ( reverse = False ) NEW_LINE DEDENT return cost NEW_LINE DEDENT
def CountWays ( N , M ) : NEW_LINE INDENT count = 1 NEW_LINE count = pow ( 3 , M + N ) NEW_LINE count *= pow ( 2 , M * N ) NEW_LINE return count NEW_LINE DEDENT
def minCost ( arr , n , circumference ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE arr2 = [ 0 ] * ( 2 * n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr2 [ i ] = arr [ i ] NEW_LINE arr2 [ i + n ] = arr [ i ] + circumference NEW_LINE DEDENT res = 9999999999999999999 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = min ( res , arr2 [ i + ( n - 1 ) ] - arr2 [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def CountWays ( n ) : NEW_LINE INDENT ans = ( n - 1 ) // 2 NEW_LINE return ans NEW_LINE DEDENT
def findUniqueElements ( arr , N , K ) : NEW_LINE INDENT s = set ( ) NEW_LINE for x in arr : NEW_LINE INDENT s . add ( x ) NEW_LINE DEDENT arr_sum = sum ( arr ) NEW_LINE set_sum = 0 NEW_LINE for x in s : NEW_LINE INDENT set_sum += x NEW_LINE DEDENT print ( ( K * set_sum - arr_sum ) // ( K - 1 ) ) NEW_LINE DEDENT
def findunique ( a , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT p = 0 NEW_LINE for j in range ( len ( a ) ) : NEW_LINE INDENT if ( abs ( a [ j ] ) & ( 1 << i ) ) != 0 : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT p %= k NEW_LINE res += pow ( 2 , i ) * p NEW_LINE DEDENT c = 0 NEW_LINE for x in a : NEW_LINE INDENT if ( x == res ) : NEW_LINE INDENT c = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if c == 1 : NEW_LINE INDENT return res NEW_LINE DEDENT else : NEW_LINE INDENT return - res NEW_LINE DEDENT DEDENT
def stepRequired ( N ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT N = N & ( N - 1 ) NEW_LINE cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT s = int ( math . sqrt ( x ) ) NEW_LINE if s * s == x : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isFibonacci ( n ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) NEW_LINE DEDENT
def findEquation ( a , b , c ) : NEW_LINE INDENT X = ( a + b + c ) NEW_LINE Y = ( a * b ) + ( b * c ) + ( c * a ) NEW_LINE Z = ( a * b * c ) NEW_LINE print ( "x^3 - " , X , "x^2 + " , Y , "x - " , Z , " = 0" ) NEW_LINE DEDENT
def dydx ( x , y ) : NEW_LINE INDENT return ( x - y ) / 2 NEW_LINE DEDENT
def numPrimeArrangements ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT factor = 2 NEW_LINE while factor * i <= n : NEW_LINE INDENT prime [ factor * i ] = False NEW_LINE factor += 1 NEW_LINE DEDENT DEDENT DEDENT primeIndices = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT primeIndices += 1 NEW_LINE DEDENT DEDENT mod = 1000000007 NEW_LINE res = 1 NEW_LINE for i in range ( 1 , primeIndices + 1 ) : NEW_LINE INDENT res = ( res * i ) % mod NEW_LINE DEDENT for i in range ( 1 , n - primeIndices + 1 ) : NEW_LINE INDENT res = ( res * i ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def count_heads ( n , r ) : NEW_LINE INDENT output = fact ( n ) / ( fact ( r ) * fact ( n - r ) ) NEW_LINE output = output / ( pow ( 2 , n ) ) NEW_LINE return output NEW_LINE DEDENT
def PrintReverseOrder ( N ) : NEW_LINE INDENT if ( N <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , end = " " ) NEW_LINE PrintReverseOrder ( N - 1 ) NEW_LINE DEDENT DEDENT
def findAns ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) // __gcd ( a , b ) NEW_LINE multiples = ( n // lcm ) + 1 NEW_LINE answer = max ( a , b ) * multiples NEW_LINE lastvalue = lcm * ( n // lcm ) + max ( a , b ) NEW_LINE if ( lastvalue > n ) : NEW_LINE INDENT answer = answer - ( lastvalue - n - 1 ) NEW_LINE DEDENT return answer NEW_LINE DEDENT
def modInverse ( n , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT
def nCrModPFermat ( n , r , p ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n < r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fac = [ 0 ] * ( n + 1 ) NEW_LINE fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p NEW_LINE DEDENT
def SumOfXor ( a , n ) : NEW_LINE INDENT mod = 10037 NEW_LINE answer = 0 NEW_LINE for k in range ( 32 ) : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] & ( 1 << k ) ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT y += 1 NEW_LINE DEDENT DEDENT answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod NEW_LINE DEDENT return answer NEW_LINE DEDENT
def movesRequired ( a , b ) : NEW_LINE INDENT total_moves = a % b NEW_LINE print ( total_moves ) NEW_LINE DEDENT
def Volume_of_cone ( R ) : NEW_LINE INDENT V = ( 1 / 3 ) * ( 3.14 ) * ( 2 * ( R ** 2 ) ) * ( 4 * R ) NEW_LINE return V NEW_LINE DEDENT
def maximumComponentSize ( a , n ) : NEW_LINE INDENT adj = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( gcd ( a [ i ] , a [ j ] ) > 1 ) : NEW_LINE INDENT adj [ i ] . append ( j ) NEW_LINE DEDENT adj [ j ] . append ( i ) NEW_LINE DEDENT DEDENT answer = 0 NEW_LINE vis = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] == False ) : NEW_LINE INDENT answer = max ( answer , dfs ( i , adj , vis ) ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT for i in range ( 2 , 100005 ) : NEW_LINE INDENT if ( spf [ i ] == 0 ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE for j in range ( 2 * i , 100005 , i ) : NEW_LINE INDENT if ( spf [ j ] == 0 ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def factorize ( n , s ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT z = spf [ n ] NEW_LINE s . add ( z ) NEW_LINE while ( n % z == 0 ) : NEW_LINE INDENT n //= z NEW_LINE DEDENT DEDENT DEDENT
def root ( i ) : NEW_LINE INDENT if ( par [ i ] == i ) : NEW_LINE INDENT return i NEW_LINE DEDENT else : NEW_LINE INDENT return root ( par [ i ] ) NEW_LINE return par [ i ] NEW_LINE DEDENT DEDENT
def merge ( a , b ) : NEW_LINE INDENT p = root ( a ) NEW_LINE q = root ( b ) NEW_LINE if ( p == q ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( sizeContainer [ p ] > sizeContainer [ q ] ) : NEW_LINE INDENT p = p + q NEW_LINE q = p - q NEW_LINE p = p - q NEW_LINE DEDENT par [ p ] = q NEW_LINE sizeContainer [ q ] += sizeContainer [ p ] NEW_LINE DEDENT
def maximumComponentsizeContainer ( a , n ) : NEW_LINE INDENT for i in range ( 100005 ) : NEW_LINE INDENT par [ i ] = i NEW_LINE sizeContainer [ i ] = 1 NEW_LINE DEDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE factorize ( a [ i ] , s ) NEW_LINE for it in s : NEW_LINE INDENT if ( id [ it ] == 0 ) : NEW_LINE INDENT id [ it ] = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT merge ( i + 1 , id [ it ] ) NEW_LINE DEDENT DEDENT DEDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer = max ( answer , sizeContainer [ i ] ) NEW_LINE DEDENT return answer NEW_LINE DEDENT
def check ( X , K ) : NEW_LINE INDENT prime = 0 NEW_LINE temp = X NEW_LINE sqr = int ( sqrt ( X ) ) NEW_LINE for i in range ( 2 , sqr + 1 , 1 ) : NEW_LINE INDENT while ( temp % i == 0 ) : NEW_LINE INDENT temp = temp // i NEW_LINE prime += 1 NEW_LINE DEDENT DEDENT if ( temp > 2 ) : NEW_LINE INDENT prime += 1 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( prime == 1 and K == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( prime >= K ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def precompute ( ) : NEW_LINE INDENT phi [ 1 ] = 0 NEW_LINE for i in range ( 2 , N , 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , N ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , N , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def maxAlternatingSum ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT current_max = arr [ i ] NEW_LINE k = i NEW_LINE while k < n and ( ( arr [ i ] > 0 and arr [ k ] > 0 ) or ( arr [ i ] < 0 and arr [ k ] < 0 ) ) : NEW_LINE INDENT current_max = max ( current_max , arr [ k ] ) NEW_LINE k += 1 NEW_LINE DEDENT max_sum += current_max NEW_LINE i = k NEW_LINE DEDENT return max_sum NEW_LINE DEDENT
def subarrayLength ( A , R , N , M ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT l = R [ i ] [ 0 ] NEW_LINE r = R [ i ] [ 1 ] + 1 NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE A [ l ] += 1 NEW_LINE if ( r < N ) : NEW_LINE INDENT A [ r ] -= 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT A [ i ] += A [ i - 1 ] NEW_LINE DEDENT count = 0 NEW_LINE s = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] not in s ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT s . append ( A [ i ] ) NEW_LINE DEDENT repeat = [ 0 ] * ( count + 1 ) NEW_LINE ans = N NEW_LINE counter , left , right = 0 , 0 , 0 NEW_LINE while ( right < N ) : NEW_LINE INDENT cur_element = A [ right ] NEW_LINE repeat [ cur_element ] += 1 NEW_LINE if ( repeat [ cur_element ] == 1 ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT while ( counter == count ) : NEW_LINE INDENT ans = min ( ans , right - left + 1 ) NEW_LINE cur_element = A [ left ] NEW_LINE repeat [ cur_element ] -= 1 NEW_LINE left += 1 NEW_LINE if ( repeat [ cur_element ] == 0 ) : NEW_LINE INDENT counter -= 1 NEW_LINE DEDENT DEDENT right += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def ModifiedSieveOfEratosthenes ( N , Expo_Prime ) : NEW_LINE INDENT primes = [ True ] * N NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( primes [ i ] ) : NEW_LINE INDENT no = i NEW_LINE while ( no <= N ) : NEW_LINE INDENT Expo_Prime [ no ] = True NEW_LINE no *= i NEW_LINE DEDENT for j in range ( i * i , N , i ) : NEW_LINE INDENT primes [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def FindExpoPrime ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max < arr [ i ] ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT Expo_Prime = [ False ] * ( max + 1 ) NEW_LINE ModifiedSieveOfEratosthenes ( max + 1 , Expo_Prime ) NEW_LINE Display ( arr , Expo_Prime , n ) NEW_LINE DEDENT
def nthRoot ( A , N ) : NEW_LINE INDENT xPre = 7 NEW_LINE eps = 1e-3 NEW_LINE delX = 10 ** 9 NEW_LINE xK = 0 NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) / N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT
def check ( no , k ) : NEW_LINE INDENT kth_root = nthRoot ( no , k ) NEW_LINE num = int ( kth_root ) NEW_LINE if ( abs ( num - kth_root ) < 1e-4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def printExpo ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] , k ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT check = [ True for i in range ( N + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( check [ p ] ) : NEW_LINE INDENT prime . append ( p ) NEW_LINE for i in range ( p * p , N + 1 , p ) : NEW_LINE INDENT check [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def isPathCo_Prime ( path ) : NEW_LINE INDENT max = 0 NEW_LINE for x in path : NEW_LINE INDENT if ( max < x ) : NEW_LINE INDENT max = x NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i * prime [ i ] <= max // 2 ) : NEW_LINE INDENT ct = 0 NEW_LINE for x in path : NEW_LINE INDENT if ( x % prime [ i ] == 0 ) : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT if ( ct > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def CntcontSubs ( a , n ) : NEW_LINE INDENT c = 0 NEW_LINE d = 0 NEW_LINE sum = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 != 0 or a [ i ] % 4 == 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT sum = a [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = sum * a [ j ] NEW_LINE if ( sum % 2 != 0 or sum % 4 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT sum = 1 NEW_LINE DEDENT return c + d NEW_LINE DEDENT
def CntcontSubs ( a , n ) : NEW_LINE INDENT prod = 1 NEW_LINE vect = [ ] NEW_LINE vect . append ( ( 0 , 2 ) ) NEW_LINE two , zero = [ ] , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = a [ i ] % 4 NEW_LINE if ( a [ i ] < 0 ) : NEW_LINE INDENT a [ i ] = a [ i ] + 4 NEW_LINE DEDENT if ( a [ i ] == 2 ) : NEW_LINE INDENT two . append ( i + 1 ) NEW_LINE DEDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT zero . append ( i + 1 ) NEW_LINE DEDENT if ( a [ i ] == 0 or a [ i ] == 2 ) : NEW_LINE INDENT vect . append ( ( i + 1 , a [ i ] ) ) NEW_LINE DEDENT DEDENT vect . append ( ( n + 1 , 2 ) ) NEW_LINE total = ( n * ( n + 1 ) ) // 2 NEW_LINE if ( len ( two ) == 0 ) : NEW_LINE INDENT return total NEW_LINE DEDENT else : NEW_LINE INDENT Sum = 0 NEW_LINE pos1 , pos2 , pos3 = - 1 , - 1 , - 1 NEW_LINE sz = len ( vect ) NEW_LINE for i in range ( 1 , sz - 1 ) : NEW_LINE INDENT if ( vect [ i ] [ 1 ] == 2 ) : NEW_LINE INDENT Sum += ( ( vect [ i ] [ 0 ] - vect [ i - 1 ] [ 0 ] ) * ( vect [ i + 1 ] [ 0 ] - vect [ i ] [ 0 ] ) - 1 ) NEW_LINE DEDENT DEDENT return ( total - Sum - len ( two ) ) NEW_LINE DEDENT DEDENT
def countSubarray ( n ) : NEW_LINE INDENT return ( ( n ) * ( n + 1 ) ) // 2 NEW_LINE DEDENT
def countSubsequence ( n ) : NEW_LINE INDENT return ( 2 ** n ) NEW_LINE DEDENT
def y ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x ) ) NEW_LINE DEDENT
def BooleRule ( a , b ) : NEW_LINE INDENT n = 4 NEW_LINE h = ( ( b - a ) / n ) NEW_LINE sum = 0 NEW_LINE bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 NEW_LINE sum = sum + bl NEW_LINE return sum NEW_LINE DEDENT
def countSubsets ( a , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT bitwiseAND = - 1 NEW_LINE bitwiseOR = 0 NEW_LINE bitwiseXOR = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT if ( bitwiseAND == - 1 ) : NEW_LINE INDENT bitwiseAND = a [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT bitwiseAND &= a [ j ] NEW_LINE DEDENT bitwiseOR |= a [ j ] NEW_LINE bitwiseXOR ^= a [ j ] NEW_LINE DEDENT DEDENT if ( bitwiseAND == bitwiseOR and bitwiseOR == bitwiseXOR ) : NEW_LINE INDENT answer = ( answer + 1 ) % mod NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def countSubsets ( a , n ) : NEW_LINE INDENT answer = 0 NEW_LINE powerOfTwo = [ 0 for x in range ( 100005 ) ] NEW_LINE powerOfTwo [ 0 ] = 1 NEW_LINE for i in range ( 1 , 100005 ) : NEW_LINE INDENT powerOfTwo [ i ] = ( powerOfTwo [ i - 1 ] * 2 ) % mod NEW_LINE DEDENT frequency = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] in frequency : NEW_LINE INDENT frequency [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT frequency [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT for key , value in frequency . items ( ) : NEW_LINE INDENT if ( key != 0 ) : NEW_LINE INDENT answer = ( answer % mod + powerOfTwo [ value - 1 ] ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT answer = ( answer % mod + powerOfTwo [ value ] - 1 + mod ) % mod NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def count ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( count * ( count + 1 ) ) // 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT ans = ans + ( count * ( count + 1 ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT
def precomputation ( ) : NEW_LINE INDENT for i in range ( 1 , 10000 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isPerfect ( i ) NEW_LINE DEDENT DEDENT
def convertToTernary ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT x = N % 3 NEW_LINE N //= 3 NEW_LINE if ( x < 0 ) : NEW_LINE INDENT N += 1 NEW_LINE DEDENT convertToTernary ( N ) NEW_LINE if ( x < 0 ) : NEW_LINE INDENT print ( x + ( 3 * - 1 ) , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , end = "" ) NEW_LINE DEDENT DEDENT
def isPerfectSquare ( N ) : NEW_LINE INDENT sr = sqrt ( N ) NEW_LINE return ( sr - floor ( sr ) ) == 0 NEW_LINE DEDENT
def EulerTotientFunction ( limit ) : NEW_LINE INDENT copy = limit NEW_LINE primes = [ ] NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if i * i > limit : NEW_LINE INDENT break NEW_LINE DEDENT if ( limit % i == 0 ) : NEW_LINE INDENT while ( limit % i == 0 ) : NEW_LINE INDENT limit //= i NEW_LINE DEDENT primes . append ( i ) NEW_LINE DEDENT DEDENT if ( limit >= 2 ) : NEW_LINE INDENT primes . append ( limit ) NEW_LINE DEDENT ans = copy NEW_LINE for it in primes : NEW_LINE INDENT ans = ( ans // it ) * ( it - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def product ( mat , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d1 += mat [ i ] [ i ] NEW_LINE d2 += mat [ i ] [ n - i - 1 ] NEW_LINE DEDENT return d1 * d2 NEW_LINE DEDENT
def getPercentile ( rank , students ) : NEW_LINE INDENT result = ( students - rank ) / students * 100 NEW_LINE return result NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) / 2 NEW_LINE return round ( pow ( phi , n ) / math . sqrt ( 5 ) ) NEW_LINE DEDENT
def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT
def sumFibonacci ( k ) : NEW_LINE INDENT l = ( k * ( k - 1 ) ) / 2 NEW_LINE r = l + k NEW_LINE sum = calculateSum ( l , r - 1 ) NEW_LINE return sum NEW_LINE DEDENT
def NthSmallest ( K ) : NEW_LINE INDENT Q = [ ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT Q . append ( i ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT x = Q [ 0 ] NEW_LINE Q . remove ( Q [ 0 ] ) NEW_LINE if ( x % 10 != 0 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 - 1 ) NEW_LINE DEDENT Q . append ( x * 10 + x % 10 ) NEW_LINE if ( x % 10 != 9 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 + 1 ) NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def sumOfPrevK ( N , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( N ) ] NEW_LINE arr [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT j = i - 1 NEW_LINE count = 0 NEW_LINE sum = 0 NEW_LINE while ( j >= 0 and count < K ) : NEW_LINE INDENT sum = sum + arr [ j ] NEW_LINE j = j - 1 NEW_LINE count = count + 1 NEW_LINE DEDENT arr [ i ] = sum NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def findSum ( arr , n , left , right ) : NEW_LINE INDENT k = right - left NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE ans = arr [ left - 1 ] * ( k + 1 ) NEW_LINE ans = ans + ( d * ( k * ( k + 1 ) ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT
def get ( x , y , z ) : NEW_LINE INDENT if ( x > z ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT val = z - x NEW_LINE div = ( z - x ) // y NEW_LINE ans = div * y + x NEW_LINE return ans NEW_LINE DEDENT
def subarrayPossible ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( sum <= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( sum <= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def probability ( N ) : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE if N == 1 : NEW_LINE INDENT return a NEW_LINE DEDENT elif N == 2 : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 3 , N + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE DEDENT DEDENT
def y ( x ) : NEW_LINE INDENT num = 1 NEW_LINE denom = float ( 1.0 + x * x ) NEW_LINE return num / denom NEW_LINE DEDENT
def WeedleRule ( a , b ) : NEW_LINE INDENT h = ( b - a ) / 6 NEW_LINE sum = 0 NEW_LINE sum = sum + ( ( ( 3 * h ) / 10 ) * ( y ( a ) + y ( a + 2 * h ) + 5 * y ( a + h ) + 6 * y ( a + 3 * h ) + y ( a + 4 * h ) + 5 * y ( a + 5 * h ) + y ( a + 6 * h ) ) ) NEW_LINE return sum NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def findSmallest ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT prime , counter = N , 0 NEW_LINE found = False NEW_LINE while ( not found ) : NEW_LINE INDENT if ( isPrime ( prime ) ) : NEW_LINE INDENT found = True NEW_LINE DEDENT else : NEW_LINE INDENT prime += 1 NEW_LINE counter += 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - 10 ** 9 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def findRemainder ( n ) : NEW_LINE INDENT x = n & 3 NEW_LINE return x NEW_LINE DEDENT
def reverse ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT
def countReverse ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( reverse ( arr [ i ] ) == arr [ j ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def reverse ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT
def countReverse ( arr , n ) : NEW_LINE INDENT freq = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] -= 1 NEW_LINE res += freq [ reverse ( arr [ i ] ) ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def rangeSum ( l , r ) : NEW_LINE INDENT a = 1 NEW_LINE b = 9 NEW_LINE res = 0 NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT L = max ( l , a ) NEW_LINE R = min ( r , b ) NEW_LINE if ( L <= R ) : NEW_LINE INDENT sum = ( L + R ) * ( R - L + 1 ) // 2 NEW_LINE res += pow ( i , i ) * ( sum % MOD ) NEW_LINE res %= MOD NEW_LINE DEDENT a = a * 10 NEW_LINE b = b * 10 + 9 NEW_LINE DEDENT return res NEW_LINE DEDENT
def TrialDivision ( N ) : NEW_LINE INDENT i = 2 NEW_LINE k = int ( N ** 0.5 ) NEW_LINE while ( i <= k ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def isPossible ( A , n , k ) : NEW_LINE INDENT countOfTwo = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT countOfTwo += 1 NEW_LINE DEDENT DEDENT if ( k == 0 and countOfTwo == n ) : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT elif ( countOfTwo >= k ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def countWays ( A , B , C ) : NEW_LINE INDENT minAddA = max ( 0 , ( C + B - A + 2 ) // 2 ) NEW_LINE count_ways = max ( C - minAddA + 1 , 0 ) NEW_LINE return count_ways NEW_LINE DEDENT
def createHash ( hash1 , maxElement ) : NEW_LINE INDENT prev , curr = 0 , 1 NEW_LINE hash1 . add ( prev ) NEW_LINE hash1 . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if temp <= maxElement : NEW_LINE INDENT hash1 . add ( temp ) NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT
def printSeries ( N ) : NEW_LINE INDENT ith_term = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ith_term = 0 NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT ith_term = 2 * i * i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ith_term = 2 * i * i - 1 NEW_LINE DEDENT print ( ith_term , end = ", " ) NEW_LINE DEDENT DEDENT
def sieve ( a , b ) : NEW_LINE INDENT prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( size ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , size , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for p in range ( 1 , size , 1 ) : NEW_LINE INDENT for q in range ( 1 , size , 1 ) : NEW_LINE INDENT if ( prime [ p ] == 0 and prime [ q ] == 0 and a * p + b * q < size ) : NEW_LINE INDENT freq [ a * p + b * q ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def SieveOfEratosthenes ( ) -> None : NEW_LINE INDENT check = [ True for _ in range ( N + 1 ) ] NEW_LINE p = 2 NEW_LINE while p * p <= N : NEW_LINE INDENT if ( check [ p ] ) : NEW_LINE INDENT prime . append ( p ) NEW_LINE for i in range ( p * p , N + 1 , p ) : NEW_LINE INDENT check [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def printSumSeries ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += 1.0 / ( 2 * i - 1 ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE a = 1 NEW_LINE cnt = 0 NEW_LINE flag = True NEW_LINE sum += a NEW_LINE while ( cnt < N ) : NEW_LINE INDENT nextElement = None NEW_LINE if ( flag ) : NEW_LINE INDENT nextElement = a * 2 NEW_LINE sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT else : NEW_LINE INDENT nextElement = a * ( 3 / 2 ) NEW_LINE sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT a = nextElement NEW_LINE cnt += 1 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def MinimumSwapOperations ( s ) : NEW_LINE INDENT zero_exist = False NEW_LINE multiple_of_2 = False NEW_LINE sum = 0 NEW_LINE index_of_zero = 0 NEW_LINE more_zero = False NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT val = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( zero_exist == True ) : NEW_LINE INDENT more_zero = True NEW_LINE DEDENT if ( val == 0 ) : NEW_LINE INDENT zero_exist = True NEW_LINE index_of_zero = i NEW_LINE DEDENT sum += val NEW_LINE DEDENT if ( zero_exist == False or sum % 3 != 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT val = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( val % 2 == 0 and i != index_of_zero ) : NEW_LINE INDENT multiple_of_2 = True NEW_LINE DEDENT DEDENT if ( multiple_of_2 == False ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT last_val = ord ( s [ len ( s ) - 1 ] ) - ord ( '0' ) NEW_LINE second_last_val = ord ( s [ len ( s ) - 2 ] ) - ord ( '0' ) NEW_LINE if ( last_val == 0 and second_last_val % 2 == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( ( last_val == 0 and second_last_val % 2 != 0 ) or ( last_val % 2 == 0 and second_last_val == 0 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif ( more_zero == True and ( last_val == 0 and second_last_val % 2 != 0 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT DEDENT
def sieve ( n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( min_prime [ i ] > 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT min_prime [ i ] = i NEW_LINE max_prime [ i ] = i NEW_LINE j = i + i NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( min_prime [ j ] == 0 ) : NEW_LINE INDENT min_prime [ j ] = i NEW_LINE DEDENT max_prime [ j ] = i NEW_LINE j += i NEW_LINE DEDENT DEDENT DEDENT
def findCost ( A , B , C , X ) : NEW_LINE INDENT sieve ( MAX ) NEW_LINE if ( X == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT min_cost = C + X NEW_LINE cost_for_prime = A NEW_LINE N = max_prime [ X ] NEW_LINE if ( N != X ) : NEW_LINE INDENT M = X // N NEW_LINE cost_for_prime += M NEW_LINE min_cost = min ( min_cost , cost_for_prime ) NEW_LINE DEDENT M = min_prime [ X ] NEW_LINE N = X // M NEW_LINE if ( N != min_prime [ N ] ) : NEW_LINE INDENT cost_for_comp = B + M NEW_LINE min_cost = min ( min_cost , cost_for_comp ) NEW_LINE DEDENT return min_cost NEW_LINE DEDENT
def minOperations ( A , B ) : NEW_LINE INDENT if ( A > B ) : NEW_LINE INDENT swap ( A , B ) NEW_LINE DEDENT B = B // math . gcd ( A , B ) NEW_LINE return B - 1 NEW_LINE DEDENT
def quadrant ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE if ( '+' in s ) : NEW_LINE INDENT i = s . index ( '+' ) NEW_LINE DEDENT else : NEW_LINE INDENT i = s . index ( '-' ) NEW_LINE DEDENT real = s [ 0 : i ] NEW_LINE imaginary = s [ i + 1 : l - 1 ] NEW_LINE x = int ( real ) NEW_LINE y = int ( imaginary ) NEW_LINE if ( x > 0 and y > 0 ) : NEW_LINE INDENT print ( "Quadrant 1" ) NEW_LINE DEDENT elif ( x < 0 and y > 0 ) : NEW_LINE INDENT print ( "Quadrant 2" ) NEW_LINE DEDENT elif ( x < 0 and y < 0 ) : NEW_LINE INDENT print ( "Quadrant 3" ) NEW_LINE DEDENT elif ( x > 0 and y < 0 ) : NEW_LINE INDENT print ( "Quadrant 4" ) NEW_LINE DEDENT elif ( x == 0 and y > 0 ) : NEW_LINE INDENT print ( "Lies on positive" , "Imaginary axis" ) NEW_LINE DEDENT elif ( x == 0 and y < 0 ) : NEW_LINE INDENT print ( "Lies on negative" , "Imaginary axis" ) NEW_LINE DEDENT elif ( y == 0 and x < 0 ) : NEW_LINE INDENT print ( "Lies on negative" , "X-axis" ) NEW_LINE DEDENT elif ( y == 0 and x > 0 ) : NEW_LINE INDENT print ( "Lies on positive" , "X-axis" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Lies on the Origin" ) NEW_LINE DEDENT DEDENT
def highestPower ( n , k ) : NEW_LINE INDENT i = 0 NEW_LINE a = pow ( n , i ) NEW_LINE while ( a <= k ) : NEW_LINE INDENT i += 1 NEW_LINE a = pow ( n , i ) NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT
def PowerArray ( n , k ) : NEW_LINE INDENT while ( k ) : NEW_LINE INDENT t = highestPower ( n , k ) NEW_LINE if ( b [ t ] ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT b [ t ] = 1 NEW_LINE DEDENT k -= pow ( n , t ) NEW_LINE DEDENT for i in range ( 50 ) : NEW_LINE INDENT if ( b [ i ] ) : NEW_LINE INDENT print ( i , end = ', ' ) NEW_LINE DEDENT DEDENT DEDENT
def PowerArray ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE while ( k ) : NEW_LINE INDENT if ( k % n == 0 ) : NEW_LINE INDENT k //= n NEW_LINE count += 1 NEW_LINE DEDENT elif ( k % n == 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE b [ count ] += 1 NEW_LINE if ( b [ count ] > 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT for i in range ( 50 ) : NEW_LINE INDENT if ( b [ i ] ) : NEW_LINE INDENT print ( i , end = "," ) NEW_LINE DEDENT DEDENT DEDENT
def countdigits ( n , k ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT digit = n % 10 NEW_LINE if digit == k : NEW_LINE INDENT return 1 + countdigits ( n / 10 , k ) NEW_LINE DEDENT return countdigits ( n / 10 , k ) NEW_LINE DEDENT
def largestElement ( head_ref ) : NEW_LINE INDENT max = - sys . maxsize NEW_LINE head = head_ref NEW_LINE while ( head != None ) : NEW_LINE INDENT if ( max < head . data ) : NEW_LINE INDENT max = head . data NEW_LINE DEDENT head = head . next NEW_LINE DEDENT return max NEW_LINE DEDENT
def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT return hash NEW_LINE DEDENT
def printModulus ( X , Y ) : NEW_LINE INDENT n = max ( X , Y ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( X % i == Y % i ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def printModulus ( X , Y ) : NEW_LINE INDENT d = abs ( X - Y ) NEW_LINE i = 1 NEW_LINE while ( i * i <= d ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT print ( i , end = "" ) NEW_LINE if ( d // i != i ) : NEW_LINE INDENT print ( d // i , end = " " ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def difSquare ( n ) : NEW_LINE INDENT if ( n % 4 != 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def countFibonacciDivisors ( n ) : NEW_LINE INDENT hash = createHash ( n ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , ceil ( sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( ( n // i == i ) and ( n // i in hash ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n // i in hash ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( n // ( n // i ) in hash ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def findCount ( root , K ) : NEW_LINE INDENT res = 0 NEW_LINE tmp , res = rec ( root , res , K ) NEW_LINE return res NEW_LINE DEDENT
def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += arr [ i ] & 1 NEW_LINE DEDENT print ( min ( x , n - x ) ) NEW_LINE DEDENT
def SieveOfEratosthenes ( composite ) : NEW_LINE INDENT for p in range ( 2 , N ) : NEW_LINE INDENT if p * p > N : NEW_LINE INDENT break NEW_LINE DEDENT if ( composite [ p ] == False ) : NEW_LINE INDENT for i in range ( 2 * p , N , p ) : NEW_LINE INDENT composite [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT
def sumOfElements ( arr , n ) : NEW_LINE INDENT composite = [ False ] * N NEW_LINE SieveOfEratosthenes ( composite ) NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT sum = 0 NEW_LINE for it in m : NEW_LINE INDENT if ( composite [ m [ it ] ] ) : NEW_LINE INDENT sum += ( it ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def val ( c ) : NEW_LINE INDENT if ( ord ( c ) >= ord ( '0' ) and ord ( c ) <= ord ( '9' ) ) : NEW_LINE INDENT return ord ( c ) - ord ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT return ord ( c ) - ord ( 'A' ) + 10 NEW_LINE DEDENT DEDENT
def toDeci ( str , base ) : NEW_LINE INDENT Len = len ( str ) NEW_LINE power = 1 NEW_LINE num = 0 NEW_LINE for i in range ( Len - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( val ( str [ i ] ) >= base ) : NEW_LINE INDENT print ( "Invalid Number" ) NEW_LINE return - 1 NEW_LINE DEDENT num += val ( str [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT
def isEven ( num , N ) : NEW_LINE INDENT deci = toDeci ( num , N ) NEW_LINE return ( deci % 2 == 0 ) NEW_LINE DEDENT
def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp //= 10 NEW_LINE if ( d == 2 or d == 3 or d == 5 or d == 7 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def remove ( arr , n ) : NEW_LINE INDENT m = dict . fromkeys ( arr , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( ( m [ arr [ i ] ] & 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT print ( arr [ i ] , end = ", " ) NEW_LINE DEDENT DEDENT
def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def longestPrimeSubsequence ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( N + 1 ) NEW_LINE SieveOfEratosthenes ( prime , N ) NEW_LINE answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def checkPalindrome ( num ) : NEW_LINE INDENT string = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( string ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( string [ l ] != string [ r ] ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT l = l + 1 NEW_LINE r = r - 1 NEW_LINE DEDENT print ( "Yes" ) NEW_LINE return NEW_LINE DEDENT
def dydx ( x , y ) : NEW_LINE INDENT return ( x + y - 2 ) NEW_LINE DEDENT
def rungeKutta ( x0 , y0 , x , h ) : NEW_LINE INDENT n = round ( ( x - x0 ) / h ) NEW_LINE y = y0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k1 = h * dydx ( x0 , y ) NEW_LINE k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) NEW_LINE y = y + ( 1.0 / 6.0 ) * ( k1 + 2 * k2 ) NEW_LINE x0 = x0 + h NEW_LINE DEDENT return y NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT s = int ( math . sqrt ( x ) ) NEW_LINE return ( s * s ) == x NEW_LINE DEDENT
def isFibonacci ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def compute ( a , b ) : NEW_LINE INDENT for i in range ( 1 , 100010 ) : NEW_LINE INDENT fib [ i ] = isFibonacci ( i ) NEW_LINE DEDENT for x in range ( 1 , 100010 ) : NEW_LINE INDENT for y in range ( 1 , size ) : NEW_LINE INDENT if ( fib [ x ] == 1 and fib [ y ] == 1 and a * x + b * y < 100010 ) : NEW_LINE INDENT freq [ a * x + b * y ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findMaxSum ( n1 , n2 ) : NEW_LINE INDENT arr1 = [ 0 ] * ( MAX ) NEW_LINE arr2 = [ 0 ] * ( MAX ) NEW_LINE l1 = 0 NEW_LINE l2 = 0 NEW_LINE max1 = max ( n1 , n2 ) NEW_LINE min1 = min ( n1 , n2 ) NEW_LINE i = max1 NEW_LINE while i > 0 : NEW_LINE INDENT arr1 [ l1 ] = ( i % 10 ) NEW_LINE l1 += 1 NEW_LINE i //= 10 NEW_LINE DEDENT i = min1 NEW_LINE while i > 0 : NEW_LINE INDENT arr2 [ l2 ] = ( i % 10 ) NEW_LINE l2 += 1 NEW_LINE i //= 10 NEW_LINE DEDENT f = 0 NEW_LINE if ( l1 != l2 ) : NEW_LINE INDENT index = arr2 . index ( max ( arr2 ) ) NEW_LINE for i in range ( l1 - 1 , ( l2 - 1 ) , - 1 ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ index ] ) : NEW_LINE INDENT ( arr1 [ i ] , arr2 [ index ] ) = ( arr2 [ index ] , arr1 [ i ] ) NEW_LINE f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( f != 1 ) : NEW_LINE INDENT index1 = 0 NEW_LINE index2 = 0 NEW_LINE diff1 = 0 NEW_LINE diff2 = 0 NEW_LINE for i in range ( l2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT index1 = arr1 . index ( max ( arr1 [ : i ] ) ) NEW_LINE index2 = arr2 . index ( max ( arr2 [ : i ] ) ) NEW_LINE diff1 = ( arr2 [ index2 ] - arr1 [ i ] ) NEW_LINE diff2 = ( arr1 [ index1 ] - arr2 [ i ] ) NEW_LINE if ( diff1 > 0 or diff2 > 0 ) : NEW_LINE INDENT if ( diff1 > diff2 ) : NEW_LINE INDENT arr1 [ i ] , arr2 [ index2 ] = arr2 [ index2 ] , arr1 [ i ] NEW_LINE break NEW_LINE DEDENT elif ( diff2 > diff1 ) : NEW_LINE INDENT arr2 [ i ] , arr1 [ index1 ] = arr1 [ index1 ] , arr2 [ i ] NEW_LINE break NEW_LINE DEDENT elif ( diff1 == diff2 ) : NEW_LINE INDENT if ( index1 <= index2 ) : NEW_LINE INDENT arr2 [ i ] , arr1 [ index1 ] = arr1 [ index1 ] , arr2 [ i ] NEW_LINE break NEW_LINE DEDENT elif ( index2 <= index1 ) : NEW_LINE INDENT arr1 [ i ] , arr2 [ index2 ] = arr2 [ index2 ] , arr1 [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT f_n1 = 0 NEW_LINE f_n2 = 0 NEW_LINE for i in range ( l1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT f_n1 = ( f_n1 * 10 ) + arr1 [ i ] NEW_LINE f_n2 = ( f_n2 * 10 ) + arr2 [ i ] NEW_LINE DEDENT print ( f_n1 + f_n2 ) NEW_LINE DEDENT
def checkCube ( a , b ) : NEW_LINE INDENT s1 = str ( a ) NEW_LINE s2 = str ( b ) NEW_LINE c = int ( s1 + s2 ) NEW_LINE if ( isPerfectCube ( c ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT
def even_or_odd ( N ) : NEW_LINE INDENT l = len ( N ) NEW_LINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' or N [ l - 1 ] == '8' or N [ l - 1 ] == 'A' or N [ l - 1 ] == 'C' or N [ l - 1 ] == 'E' ) : NEW_LINE INDENT return ( "Even" ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( "Odd" ) NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 3 ) ) NEW_LINE DEDENT return ( n % 31 == 0 ) NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT s = sqrt ( x ) NEW_LINE return ( s * s == x ) NEW_LINE DEDENT
def isFibonacci ( N ) : NEW_LINE INDENT return isPerfectSquare ( 5 * N * N + 4 ) or isPerfectSquare ( 5 * N * N - 4 ) NEW_LINE DEDENT
def nextNonFibonacci ( N ) : NEW_LINE INDENT if ( N <= 3 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT if ( isFibonacci ( N + 1 ) ) : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 7 ) ) NEW_LINE DEDENT return ( n % 71 == 0 ) NEW_LINE DEDENT
def findDigits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT digit [ count ] = n % 10 NEW_LINE n = n // 10 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def OR_of_Digits ( n , count ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( count ) : NEW_LINE INDENT ans = ans | digit [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def AND_of_Digits ( n , count ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( count ) : NEW_LINE INDENT ans = ans & digit [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def XOR_of_Digits ( n , count ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( count ) : NEW_LINE INDENT ans = ans ^ digit [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , 18 ) : NEW_LINE INDENT fact [ i ] = ( fact [ i - 1 ] * i ) NEW_LINE DEDENT DEDENT
def nextFactorial ( N ) : NEW_LINE INDENT for i in range ( 21 ) : NEW_LINE INDENT if N < fact [ i ] : NEW_LINE INDENT print ( fact [ i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def largest_sum ( arr , n ) : NEW_LINE INDENT maximum = - 1 NEW_LINE m = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT for j in list ( m ) : NEW_LINE INDENT if ( ( j in m ) and m [ j ] > 1 ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE if 2 * j in m : NEW_LINE INDENT m [ 2 * j ] = m [ 2 * j ] + m [ j ] // 2 NEW_LINE DEDENT else : NEW_LINE INDENT m [ 2 * j ] = m [ j ] // 2 NEW_LINE DEDENT if ( 2 * j > maximum ) : NEW_LINE INDENT maximum = 2 * j NEW_LINE DEDENT DEDENT DEDENT return maximum NEW_LINE DEDENT
def maxLength ( arr , N ) : NEW_LINE INDENT product = 1 NEW_LINE Len = 0 NEW_LINE for i in arr : NEW_LINE INDENT product *= i NEW_LINE DEDENT if ( product >= 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Len = max ( Len , max ( N - i - 1 , i ) ) NEW_LINE DEDENT DEDENT return Len NEW_LINE DEDENT
def findNumbers ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= N ) : NEW_LINE INDENT print ( ( i * i * i ) , end = " " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if j * j > i : NEW_LINE INDENT break NEW_LINE DEDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( i // j == j ) : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i // j NEW_LINE DEDENT DEDENT DEDENT sum = sum - i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( n // i ) * i NEW_LINE DEDENT return sum - n * ( n + 1 ) // 2 NEW_LINE DEDENT
def findMinimumOperation ( n , d , arrays ) : NEW_LINE INDENT cnt = 0 NEW_LINE first = - 10 ** 9 NEW_LINE end = 10 ** 9 NEW_LINE while ( n ) : NEW_LINE INDENT arr = [ arrays [ cnt ] [ 0 ] , arrays [ cnt ] [ 1 ] ] NEW_LINE arr = sorted ( arr ) NEW_LINE first = max ( first , arr [ 0 ] ) NEW_LINE end = min ( end , arr [ 1 ] ) NEW_LINE cnt += 1 NEW_LINE n -= 1 NEW_LINE DEDENT if ( first > end ) : NEW_LINE INDENT print ( "-1" , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( d >= first and d <= end ) : NEW_LINE INDENT print ( "0" , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( abs ( first - d ) , abs ( d - end ) ) , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def mult ( a , b ) : NEW_LINE INDENT return ( ( a % mod ) * ( b % mod ) ) % mod NEW_LINE DEDENT
def calculate_factors ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE ans = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT if ( cnt ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) , 2 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // i NEW_LINE DEDENT if ( cnt ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans = mult ( ans , 2 ) NEW_LINE DEDENT return ans % mod NEW_LINE DEDENT
def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT
def generatePrime ( ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , sz + 1 ) : NEW_LINE INDENT if i * i > sz : NEW_LINE INDENT break NEW_LINE DEDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , sz , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def Pair_of_PrimeXor ( A , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( isPrime [ ( A [ i ] ^ A [ j ] ) ] ) : NEW_LINE INDENT print ( "(" , A [ i ] , "," , A [ j ] , ")" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def primeFactors ( n ) : NEW_LINE INDENT Prime = [ ] NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT Prime . append ( 2 ) NEW_LINE DEDENT while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( n ** ( 1 / 2 ) ) , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT Prime . append ( i ) NEW_LINE DEDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT Prime . append ( n ) NEW_LINE DEDENT return Prime NEW_LINE DEDENT
def checkDistinctPrime ( n ) : NEW_LINE INDENT Prime = primeFactors ( n ) NEW_LINE product = 1 NEW_LINE for i in Prime : NEW_LINE INDENT product *= i NEW_LINE DEDENT if ( product == n ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def nthRoot ( A , N ) : NEW_LINE INDENT xPre = ( random . randint ( 0 , 9 ) ) % 10 NEW_LINE eps = 1e-3 NEW_LINE delX = sys . maxsize NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) / N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT
def countPowers ( a , b , k ) : NEW_LINE INDENT return ( floor ( nthRoot ( b , k ) ) - ceil ( nthRoot ( a , k ) ) + 1 ) NEW_LINE DEDENT
def findDigits ( n , b ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT M_PI = 3.141592 NEW_LINE M_E = 2.7182 NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( log10 ( b ) ) NEW_LINE return floor ( x ) + 1 NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findSum ( N , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT sum += pow ( i , k ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT s = int ( sqrt ( x ) ) NEW_LINE if ( s * s == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isNonFibonacci ( n ) : NEW_LINE INDENT x = 5 * n * n NEW_LINE if ( isPerfectSquare ( x + 4 ) or isPerfectSquare ( x - 4 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT
def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isNonFibonacci ( i ) NEW_LINE DEDENT DEDENT
def printSum ( L , R ) : NEW_LINE INDENT sum = pref [ R ] - pref [ L - 1 ] NEW_LINE print ( sum , end = " " ) NEW_LINE DEDENT
def checkArray ( a , b , n ) : NEW_LINE INDENT operations = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( a [ i ] - b [ i ] == 0 ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT diff = a [ i ] - b [ i ] NEW_LINE i += 1 NEW_LINE while ( i < n and a [ i ] - b [ i ] == diff ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT operations += 1 NEW_LINE DEDENT print ( operations ) NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT s = sqrt ( x ) NEW_LINE return ( s * s == x ) NEW_LINE DEDENT
def isFibonacci ( n ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) NEW_LINE DEDENT
def countFibonacciPairs ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( isFibonacci ( arr [ i ] ) and isFibonacci ( arr [ j ] ) ) : NEW_LINE INDENT prevFib = previousFibonacci ( arr [ i ] ) NEW_LINE nextFib = nextFibonacci ( arr [ i ] ) NEW_LINE if ( prevFib == arr [ j ] or nextFib == arr [ j ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def countPairsWithProductK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE hashmap = [ False ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashmap [ arr [ i ] ] = True NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE index = 1.0 * k / arr [ i ] NEW_LINE if ( index >= 0 and ( ( index - int ( index ) ) == 0 ) and hashmap [ k // x ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT hashmap [ x ] = False NEW_LINE DEDENT return count NEW_LINE DEDENT
def simpleSieve ( limit , prime ) : NEW_LINE INDENT mark = [ False ] * ( limit + 1 ) NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if mark [ i ] == False : NEW_LINE INDENT prime . append ( i ) NEW_LINE for j in range ( i , limit + 1 , i ) : NEW_LINE INDENT mark [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT
def primesInRange ( low , high ) : NEW_LINE INDENT limit = math . floor ( math . sqrt ( high ) ) + 1 NEW_LINE prime = [ ] NEW_LINE simpleSieve ( limit , prime ) NEW_LINE n = high - low + 1 NEW_LINE mark = [ False ] * ( n + 1 ) NEW_LINE for i in range ( len ( prime ) ) : NEW_LINE INDENT loLim = low // prime [ i ] NEW_LINE loLim *= prime [ i ] NEW_LINE if loLim < low : NEW_LINE INDENT loLim += prime [ i ] NEW_LINE DEDENT if loLim == prime [ i ] : NEW_LINE INDENT loLim += prime [ i ] NEW_LINE DEDENT for j in range ( loLim , high + 1 , prime [ i ] ) : NEW_LINE INDENT mark [ j - low ] = True NEW_LINE DEDENT DEDENT for i in range ( low , high + 1 ) : NEW_LINE INDENT if not mark [ i - low ] : NEW_LINE INDENT allPrimes . add ( i ) NEW_LINE DEDENT DEDENT DEDENT
def maxPrimeSubarray ( arr , n ) : NEW_LINE INDENT current_max = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in allPrimes : NEW_LINE INDENT current_max = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current_max += 1 NEW_LINE max_so_far = max ( current_max , max_so_far ) NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def search ( a , k , x ) : NEW_LINE INDENT for j in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ j ] == x ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countPairsWith ( n , perfectcubes , nums ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( perfectcubes ) ) : NEW_LINE INDENT temp = perfectcubes [ i ] - n NEW_LINE if ( temp > n and ( temp in nums ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countCubes ( a , b ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if j * j * j > i : NEW_LINE INDENT break NEW_LINE DEDENT if j * j * j == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def countCubes ( a , b ) : NEW_LINE INDENT return ( floor ( b ** ( 1. / 3. ) ) - ceil ( a ** ( 1. / 3. ) ) + 1 ) NEW_LINE DEDENT
def checkArmstrong ( x ) : NEW_LINE INDENT n = len ( str ( x ) ) NEW_LINE sum1 = 0 NEW_LINE temp = x NEW_LINE while temp > 0 : NEW_LINE INDENT digit = temp % 10 NEW_LINE sum1 += digit ** n NEW_LINE temp //= 10 NEW_LINE DEDENT if sum1 == x : NEW_LINE INDENT return x NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def printSumarmstrong ( arr , Q ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT
def isArmstrong ( x , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE temp = x NEW_LINE while temp > 0 : NEW_LINE INDENT digit = temp % 10 NEW_LINE sum1 += digit ** n NEW_LINE temp //= 10 NEW_LINE DEDENT return sum1 == x NEW_LINE DEDENT
def perfectCube ( N ) : NEW_LINE INDENT cube_root = round ( N ** ( 1 / 3 ) ) NEW_LINE if cube_root * cube_root * cube_root == N : NEW_LINE INDENT print ( "Yes" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE return NEW_LINE DEDENT DEDENT
def primeFactors ( n ) : NEW_LINE INDENT primeFact = { } NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT primeFact = insertPF ( primeFact , 2 ) NEW_LINE n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT primeFact = insertPF ( primeFact , i ) NEW_LINE n = n // i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT primeFact = insertPF ( primeFact , n ) NEW_LINE DEDENT return primeFact NEW_LINE DEDENT
def check ( arr , N ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( even == N or odd == N ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def findSum ( N ) : NEW_LINE INDENT sum = ( N ) * ( N + 1 ) // 2 NEW_LINE r = log2 ( N ) + 1 NEW_LINE expSum = pow ( 2 , r ) - 1 NEW_LINE print ( int ( sum - expSum ) ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def twinPrime ( n1 , n2 ) : NEW_LINE INDENT return ( isPrime ( n1 ) and isPrime ( n2 ) and abs ( n1 - n2 ) == 2 ) NEW_LINE DEDENT
def countTwinPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( twinPrime ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findMinNumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n /= 2 NEW_LINE DEDENT if ( count % 3 != 0 ) : NEW_LINE INDENT ans *= pow ( 2 , ( count % 3 ) ) NEW_LINE DEDENT for i in range ( 3 , int ( pow ( n , 1 / 2 ) ) , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n /= i NEW_LINE DEDENT if ( count % 3 != 0 ) : NEW_LINE INDENT ans *= pow ( i , ( count % 3 ) ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans *= n NEW_LINE DEDENT return ans NEW_LINE DEDENT
def printPairs ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( "(" , arr [ i ] , "," , arr [ j ] , ")" , end = ", " ) NEW_LINE DEDENT DEDENT DEDENT
def countSteps ( n ) : NEW_LINE INDENT steps = 0 NEW_LINE while ( n ) : NEW_LINE INDENT largest = floor ( n ** ( 1 / 3 ) ) NEW_LINE n -= ( largest * largest * largest ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT
def product ( N ) : NEW_LINE INDENT ans = 1 NEW_LINE val = 2 ** ( N - 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans *= ( i ** val ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def nearest ( n ) : NEW_LINE INDENT prevSquare = int ( sqrt ( n ) ) NEW_LINE nextSquare = prevSquare + 1 NEW_LINE prevSquare = prevSquare * prevSquare NEW_LINE nextSquare = nextSquare * nextSquare NEW_LINE ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) NEW_LINE return ans NEW_LINE DEDENT
def ways ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT c2 = 0 NEW_LINE c1 = n - 3 NEW_LINE l = c1 + 1 NEW_LINE s = 0 NEW_LINE exp_c2 = c1 / 2 NEW_LINE while exp_c2 >= c2 : NEW_LINE INDENT f1 = math . factorial ( l ) NEW_LINE f2 = math . factorial ( c1 ) NEW_LINE f3 = math . factorial ( c2 ) NEW_LINE s += f1 // ( f2 * f3 ) NEW_LINE c2 += 1 NEW_LINE c1 -= 2 NEW_LINE l -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def isPerfectCube ( x ) : NEW_LINE INDENT cr = int ( x ** ( 1 / 3 ) ) NEW_LINE return ( cr * cr * cr == x ) NEW_LINE DEDENT
def sqrtSearch ( low , high , N ) : NEW_LINE INDENT if ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( ( mid * mid <= N ) and ( ( mid + 1 ) * ( mid + 1 ) > N ) ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( mid * mid < N ) : NEW_LINE INDENT return sqrtSearch ( mid + 1 , high , N ) NEW_LINE DEDENT else : NEW_LINE INDENT return sqrtSearch ( low , mid - 1 , N ) NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def printAllDivisors ( arr , N ) : NEW_LINE INDENT g = arr [ 0 ] NEW_LINE divisors = dict ( ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT g = gcd ( arr [ i ] , g ) NEW_LINE DEDENT for i in range ( 1 , g + 1 ) : NEW_LINE INDENT if i * i > g : NEW_LINE INDENT break NEW_LINE DEDENT if ( g % i == 0 ) : NEW_LINE INDENT divisors [ i ] = 1 NEW_LINE if ( g // i != i ) : NEW_LINE INDENT divisors [ g // i ] = 1 NEW_LINE DEDENT DEDENT DEDENT for it in sorted ( divisors ) : NEW_LINE INDENT print ( it , end = " " ) NEW_LINE DEDENT DEDENT
def getSmallestPrimefactor ( n ) : NEW_LINE INDENT for i in range ( 2 , ( int ) ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def ispalin ( num ) : NEW_LINE INDENT s = str ( num ) NEW_LINE st = 0 NEW_LINE ed = len ( s ) - 1 NEW_LINE while ( st <= ed ) : NEW_LINE INDENT if ( s [ st ] != s [ ed ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT st += 1 NEW_LINE ed -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def CalculateXORandOR ( n ) : NEW_LINE INDENT CalculateXOR = 0 NEW_LINE CalculateOR = 0 NEW_LINE start = 10 ** ( n - 1 ) NEW_LINE end = ( 10 ** n ) - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( ispalin ( i ) ) : NEW_LINE INDENT CalculateXOR = CalculateXOR ^ i NEW_LINE CalculateOR = CalculateOR | i NEW_LINE DEDENT DEDENT print ( "XOR =" , CalculateXOR , end = " " ) NEW_LINE print ( "OR = " , CalculateOR ) NEW_LINE DEDENT
def checkPalindrome ( num ) : NEW_LINE INDENT strr = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( strr ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( strr [ l ] != strr [ r ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT
def preCompute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + checkPalindrome ( i ) NEW_LINE DEDENT DEDENT
def Sieve ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT k [ i ] = i NEW_LINE DEDENT for i in range ( 2 , 100001 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , 100001 , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE while ( k [ j ] % ( i * i ) == 0 ) : NEW_LINE INDENT k [ j ] /= ( i * i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if k [ arr [ i ] ] in freq . keys ( ) : NEW_LINE INDENT freq [ k [ arr [ i ] ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ k [ arr [ i ] ] ] = 1 NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE for i in freq : NEW_LINE INDENT Sum += ( freq [ i ] * ( freq [ i ] - 1 ) ) / 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def powOfPositive ( n ) : NEW_LINE INDENT pos = floor ( log2 ( n ) ) NEW_LINE return 2 ** pos NEW_LINE DEDENT
def powOfNegative ( n ) : NEW_LINE INDENT pos = ceil ( log2 ( n ) ) NEW_LINE return ( - 1 * pow ( 2 , pos ) ) NEW_LINE DEDENT
def highestPowerOf2 ( n ) : NEW_LINE INDENT if ( n > 0 ) : NEW_LINE INDENT print ( powOfPositive ( n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n = - n NEW_LINE print ( powOfNegative ( n ) ) NEW_LINE DEDENT DEDENT
def summation ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT else : NEW_LINE INDENT sum -= ( i * i ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def isPower ( x , y ) : NEW_LINE INDENT res1 = log ( y ) // log ( x ) NEW_LINE res2 = log ( y ) / log ( x ) NEW_LINE return ( res1 == res2 ) NEW_LINE DEDENT
def countPower ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if isPower ( arr [ i ] , arr [ j ] ) or isPower ( arr [ j ] , arr [ i ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def xor_all_elements ( n ) : NEW_LINE INDENT if n & 3 == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT elif n & 3 == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n & 3 == 2 : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def precompute ( ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , 19 ) : NEW_LINE INDENT fact = fact * i NEW_LINE m [ fact ] = i NEW_LINE DEDENT DEDENT
def sumOfParts ( arr , N ) : NEW_LINE INDENT sum_part1 , sum_part2 , sum_part3 , sum_part4 = 0 , 0 , 0 , 0 NEW_LINE totalsum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if i + j < N - 1 : NEW_LINE INDENT if ( i < j and i != j and i + j ) : NEW_LINE INDENT sum_part1 += arr [ i ] [ j ] NEW_LINE DEDENT elif i != j : NEW_LINE INDENT sum_part2 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if i > j and i + j != N - 1 : NEW_LINE INDENT sum_part3 += arr [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT if i + j != N - 1 and i != j : NEW_LINE INDENT sum_part4 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return sum_part1 + sum_part2 + sum_part3 + sum_part4 NEW_LINE DEDENT
def noOfCards ( n ) : NEW_LINE INDENT return n * ( 3 * n + 1 ) // 2 NEW_LINE DEDENT
def subsetSum ( arr , n , i , sum , count ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) NEW_LINE count = subsetSum ( arr , n , i + 1 , sum , count ) NEW_LINE return count NEW_LINE DEDENT
def ifPossible ( X , Y ) : NEW_LINE INDENT if ( X > Y ) : NEW_LINE INDENT X , Y = Y , X NEW_LINE DEDENT if ( ( X + Y ) % 5 == 0 and 3 * X >= 2 * Y ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def isPerfectCube ( x ) : NEW_LINE INDENT cr = round ( x ** ( 1 / 3 ) ) NEW_LINE rslt = x if ( cr * cr * cr == x ) else 0 NEW_LINE return rslt NEW_LINE DEDENT
def printSum ( L , R ) : NEW_LINE INDENT sum = pref [ R ] - pref [ L - 1 ] NEW_LINE print ( sum , end = " " ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE i , j = 0 , 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT
def sieve ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT allPrimes = [ x for x in range ( 2 , n ) if prime [ x ] ] NEW_LINE return allPrimes NEW_LINE DEDENT
def log_a_to_base_b ( a , b ) : NEW_LINE INDENT return log ( a ) // log ( b ) NEW_LINE DEDENT
def findSmallest ( N ) : NEW_LINE INDENT smallest = '1' + '0' * ( N - 1 ) NEW_LINE return smallest NEW_LINE DEDENT
def heapify ( arr , n , i ) : NEW_LINE INDENT largest = i NEW_LINE l = 2 * i + 1 NEW_LINE r = 2 * i + 2 NEW_LINE if l < n and arr [ largest ] < arr [ l ] : NEW_LINE INDENT largest = l NEW_LINE DEDENT if r < n and arr [ largest ] < arr [ r ] : NEW_LINE INDENT largest = r NEW_LINE DEDENT if largest != i : NEW_LINE INDENT arr [ i ] , arr [ largest ] = arr [ largest ] , arr [ i ] NEW_LINE heapify ( arr , n , largest ) NEW_LINE DEDENT DEDENT
def count ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT sum += 7 * ( 8 ** ( i - 1 ) ) NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT
def nextPowerOfK ( n , k ) : NEW_LINE INDENT return prevPowerofK ( n , k ) * k NEW_LINE DEDENT
def isPalindrome ( n ) : NEW_LINE INDENT string = str ( n ) NEW_LINE s = 0 NEW_LINE e = len ( string ) - 1 NEW_LINE while ( s < e ) : NEW_LINE INDENT if ( string [ s ] != string [ e ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT s += 1 NEW_LINE e -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def palindromicDivisors ( n ) : NEW_LINE INDENT PalindromDivisors = [ ] NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT if ( isPalindrome ( i ) ) : NEW_LINE INDENT PalindromDivisors . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( isPalindrome ( i ) ) : NEW_LINE INDENT PalindromDivisors . append ( i ) NEW_LINE DEDENT if ( isPalindrome ( n // i ) ) : NEW_LINE INDENT PalindromDivisors . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT PalindromDivisors . sort ( ) NEW_LINE for i in range ( len ( PalindromDivisors ) ) : NEW_LINE INDENT print ( PalindromDivisors [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE rslt = x if ( sr - floor ( sr ) == 0 ) else 0 NEW_LINE return rslt NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isPerfectSquare ( i ) NEW_LINE DEDENT DEDENT
def printSum ( L , R ) : NEW_LINE INDENT sum = pref [ R ] - pref [ L - 1 ] NEW_LINE print ( sum , end = " " ) NEW_LINE DEDENT
def factors ( n , i ) : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT factors ( n , i + 1 ) NEW_LINE DEDENT DEDENT
def solve ( n ) : NEW_LINE INDENT ans = ( n * n // 4 ) NEW_LINE return ans NEW_LINE DEDENT
def solve ( arr , n ) : NEW_LINE INDENT unfilled_indices = { } NEW_LINE missing = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT missing [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT unfilled_indices [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT del missing [ arr [ i ] ] NEW_LINE DEDENT DEDENT it2 = list ( missing . keys ( ) ) NEW_LINE m = len ( it2 ) NEW_LINE for it in unfilled_indices : NEW_LINE INDENT arr [ it ] = it2 [ m - 1 ] NEW_LINE m -= 1 NEW_LINE DEDENT pos = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == i ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT DEDENT x = 0 NEW_LINE if ( pos != 0 ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( pos != i ) : NEW_LINE INDENT if i in unfilled_indices : NEW_LINE INDENT x = arr [ i ] NEW_LINE arr [ i ] = pos NEW_LINE arr [ pos ] = x NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT printArray ( arr , n ) NEW_LINE DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def maximum ( x , y ) : NEW_LINE INDENT return ( ( x + y + abs ( x - y ) ) // 2 ) NEW_LINE DEDENT
def minimum ( x , y ) : NEW_LINE INDENT return ( ( x + y - abs ( x - y ) ) // 2 ) NEW_LINE DEDENT
def SubarraysWithSumS ( n , k , s ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT print ( s , end = " " ) NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT print ( s + 1 , end = " " ) NEW_LINE DEDENT DEDENT
def check ( x , pos , neg , k ) : NEW_LINE INDENT pairs = 0 NEW_LINE p = len ( neg ) - 1 NEW_LINE nn = len ( neg ) - 1 NEW_LINE pp = len ( pos ) - 1 NEW_LINE for i in range ( len ( neg ) ) : NEW_LINE INDENT while ( p >= 0 and neg [ i ] * neg [ p ] <= x ) : NEW_LINE INDENT p -= 1 NEW_LINE DEDENT pairs += min ( nn - p , nn - i ) NEW_LINE DEDENT p = 0 NEW_LINE for i in range ( len ( pos ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( p < len ( pos ) and pos [ i ] * pos [ p ] <= x ) : NEW_LINE INDENT p += 1 NEW_LINE DEDENT pairs += min ( p , i ) NEW_LINE DEDENT p = len ( pos ) - 1 NEW_LINE for i in range ( len ( neg ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( p >= 0 and neg [ i ] * pos [ p ] <= x ) : NEW_LINE INDENT p -= 1 NEW_LINE DEDENT pairs += pp - p NEW_LINE DEDENT return ( pairs >= k ) NEW_LINE DEDENT
def pay ( n ) : NEW_LINE INDENT cuts = int ( math . log ( n , 2 ) ) NEW_LINE return cuts NEW_LINE DEDENT
def sieve ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( min_prime [ i ] > 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT min_prime [ i ] = i NEW_LINE max_prime [ i ] = i NEW_LINE j = i + i NEW_LINE while ( j <= n ) : NEW_LINE INDENT if ( min_prime [ j ] == 0 ) : NEW_LINE INDENT min_prime [ j ] = i NEW_LINE DEDENT max_prime [ j ] = i NEW_LINE j += i NEW_LINE DEDENT DEDENT DEDENT
def pairCount ( n , m ) : NEW_LINE INDENT cnt = 0 NEW_LINE for b in range ( int ( pow ( m , 1 / 2 ) ) ) : NEW_LINE INDENT a = m - b * b NEW_LINE if ( a * a + b == n ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def Calc_Max_Div ( arr , n ) : NEW_LINE INDENT vis = [ 1 ] * ( maxin + 1 ) NEW_LINE vis [ 0 ] = vis [ 1 ] = 0 NEW_LINE for i in range ( 1 , maxin + 1 ) : NEW_LINE INDENT divisors [ i ] = i NEW_LINE DEDENT for i in range ( 4 , maxin + 1 , 2 ) : NEW_LINE INDENT vis [ i ] = 0 NEW_LINE divisors [ i ] = i // 2 NEW_LINE DEDENT for i in range ( 3 , maxin + 1 , 2 ) : NEW_LINE INDENT if ( divisors [ i ] != i ) : NEW_LINE INDENT divisors [ i ] = i // divisors [ i ] NEW_LINE DEDENT if ( vis [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i * i , maxin , i ) : NEW_LINE INDENT vis [ j ] = 0 NEW_LINE if ( divisors [ j ] == j ) : NEW_LINE INDENT divisors [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( divisors [ arr [ i ] ] == arr [ i ] ) : NEW_LINE INDENT print ( "-1 " , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( divisors [ arr [ i ] ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def sumOfDigit ( n , b ) : NEW_LINE INDENT unitDigit = 0 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT unitDigit = n % b NEW_LINE sum += unitDigit NEW_LINE n = n // b NEW_LINE DEDENT return sum NEW_LINE DEDENT
def nthDigit ( a , n , b ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT a = a // b NEW_LINE DEDENT return a % b NEW_LINE DEDENT
def countSum ( N , L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return R - L + 1 NEW_LINE DEDENT if ( N > 1 ) : NEW_LINE INDENT return ( N - 2 ) * ( R - L ) + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def solve ( arr , n , k ) : NEW_LINE INDENT minx = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT minx = min ( minx , arr [ i ] ) NEW_LINE DEDENT decrements = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] - minx ) % k != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT decrements += ( ( arr [ i ] - minx ) // k ) NEW_LINE DEDENT DEDENT return decrements NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT
def count_of_subarrays ( N ) : NEW_LINE INDENT count = binomialCoeff ( 2 * N - 1 , N ) NEW_LINE return count NEW_LINE DEDENT
def distribution ( n , k , l , r , S , Sk ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE len = k NEW_LINE temp , rem , s = 0 , 0 , 0 NEW_LINE diff = S - Sk NEW_LINE for i in range ( len ) : NEW_LINE INDENT temp = Sk / k NEW_LINE rem = Sk % k NEW_LINE if ( temp + rem >= l and temp + rem <= r ) : NEW_LINE INDENT a [ i ] = temp NEW_LINE DEDENT elif ( temp + rem > r ) : NEW_LINE INDENT a [ i ] = r NEW_LINE DEDENT elif ( temp + rem < r ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT Sk = Sk - a [ i ] NEW_LINE k = k - 1 NEW_LINE DEDENT if ( Sk > 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT if ( len != 0 ) : NEW_LINE INDENT k = n - len NEW_LINE for i in range ( len , n ) : NEW_LINE INDENT temp = diff / k NEW_LINE rem = diff % k NEW_LINE if ( temp + rem >= l and temp + rem <= r ) : NEW_LINE INDENT a [ i ] = temp NEW_LINE DEDENT elif ( temp + rem > r ) : NEW_LINE INDENT a [ i ] = r NEW_LINE DEDENT elif ( temp + rem < r ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT diff = diff - a [ i ] NEW_LINE k = k - 1 NEW_LINE DEDENT if ( diff != 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( int ( a [ i ] ) , end = " " ) NEW_LINE DEDENT DEDENT
def countDigit ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE c += 1 NEW_LINE n //= 10 NEW_LINE DEDENT return c NEW_LINE DEDENT
def min_index ( p , n ) : NEW_LINE INDENT ans = 0 NEW_LINE mini = INT_MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] <= mini ) : NEW_LINE INDENT mini = p [ i ] NEW_LINE DEDENT if ( mini == p [ i ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE Xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE Xor = Xor ^ arr [ i ] NEW_LINE DEDENT if ( Sum == Xor ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def Count_subarray ( arr , n ) : NEW_LINE INDENT subarray_sum , remaining_sum , count = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT subarray_sum = 0 NEW_LINE remaining_sum = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT subarray_sum += arr [ k ] NEW_LINE DEDENT for l in range ( i ) : NEW_LINE INDENT remaining_sum += arr [ l ] NEW_LINE DEDENT for l in range ( j + 1 , n ) : NEW_LINE INDENT remaining_sum += arr [ l ] NEW_LINE DEDENT if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def set_bits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n % 2 NEW_LINE n //= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
def minSteps ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( n != 1 ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT elif ( n == 3 or set_bits ( n - 1 ) < set_bits ( n + 1 ) ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT n += 1 NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minimumNo ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE stack1 = [ ] NEW_LINE stack2 = [ ] NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE if ( r % 2 == 0 ) : NEW_LINE INDENT stack1 . append ( r ) NEW_LINE DEDENT else : NEW_LINE INDENT stack2 . append ( r ) NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT while ( len ( stack1 ) > 0 and len ( stack2 ) > 0 ) : NEW_LINE INDENT if ( stack1 [ - 1 ] < stack2 [ - 1 ] ) : NEW_LINE INDENT ans = ans * 10 + stack1 [ - 1 ] NEW_LINE del stack1 [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans * 10 + stack2 [ - 1 ] NEW_LINE del stack2 [ - 1 ] NEW_LINE DEDENT DEDENT while ( len ( stack1 ) > 0 ) : NEW_LINE INDENT ans = ans * 10 + stack1 [ - 1 ] NEW_LINE del stack1 [ - 1 ] NEW_LINE DEDENT while ( len ( stack2 ) > 0 ) : NEW_LINE INDENT ans = ans * 10 + stack2 [ - 1 ] NEW_LINE del stack2 [ - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findNums ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , ceil ( sqrt ( x ) ) ) : NEW_LINE INDENT if ( x % i == 0 and lcm ( i , x // i ) == x ) : NEW_LINE INDENT ans = i NEW_LINE DEDENT DEDENT print ( ans , ( x // ans ) ) NEW_LINE DEDENT
def maxCommonElement ( A , D , N ) : NEW_LINE INDENT cnt = [ 0 ] * MAXN NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( A [ i ] , MAXN , D [ i ] ) : NEW_LINE INDENT cnt [ j ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE com = 0 NEW_LINE for i in range ( MAXN ) : NEW_LINE INDENT if cnt [ i ] > ans : NEW_LINE INDENT ans = cnt [ i ] NEW_LINE com = i NEW_LINE DEDENT DEDENT return com NEW_LINE DEDENT
def findTrailingZeros ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE n //= 2 NEW_LINE while ( n ) : NEW_LINE INDENT ans += n // 5 NEW_LINE n //= 5 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
def maxGCD ( N , K ) : NEW_LINE INDENT minSum = ( K * ( K + 1 ) ) / 2 NEW_LINE if ( N < minSum ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = ceil ( sqrt ( N ) ) NEW_LINE res = 1 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i >= minSum ) : NEW_LINE INDENT res = max ( res , N / i ) NEW_LINE DEDENT if ( N / i >= minSum ) : NEW_LINE INDENT res = max ( res , i ) NEW_LINE DEDENT DEDENT i -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def findNumberOfEvenCells ( n , q , size ) : NEW_LINE INDENT row = [ 0 ] * n NEW_LINE col = [ 0 ] * n NEW_LINE for i in range ( size ) : NEW_LINE INDENT x = q [ i ] [ 0 ] NEW_LINE y = q [ i ] [ 1 ] NEW_LINE row [ x - 1 ] += 1 NEW_LINE col [ y - 1 ] += 1 NEW_LINE DEDENT r1 = 0 NEW_LINE r2 = 0 NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( row [ i ] % 2 == 0 ) : NEW_LINE INDENT r1 += 1 NEW_LINE DEDENT if ( row [ i ] % 2 == 1 ) : NEW_LINE INDENT r2 += 1 NEW_LINE DEDENT if ( col [ i ] % 2 == 0 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if ( col [ i ] % 2 == 1 ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT count = r1 * c1 + r2 * c2 NEW_LINE return count NEW_LINE DEDENT
def fastmod ( base , exp , mod ) : NEW_LINE INDENT if ( exp == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( exp % 2 == 0 ) : NEW_LINE INDENT ans = fastmod ( base , exp / 2 , mod ) NEW_LINE return ( ans % mod * ans % mod ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( fastmod ( base , exp - 1 , mod ) % mod * base % mod ) % mod NEW_LINE DEDENT DEDENT
def findPowerSum ( n , ar ) : NEW_LINE INDENT mod = int ( 1e9 ) + 7 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT base = bin ( ar [ i ] ) . count ( '1' ) NEW_LINE exp = ar [ i ] NEW_LINE sum += fastmod ( base , exp , mod ) NEW_LINE sum %= mod NEW_LINE DEDENT return sum NEW_LINE DEDENT
def maxHeight ( h1 , h2 ) : NEW_LINE INDENT return ( ( h1 * h2 ) - h1 - h2 ) NEW_LINE DEDENT
def area ( a , b , c ) : NEW_LINE INDENT p = ( a + b + c ) / 2 NEW_LINE return ( ( math . sqrt ( p ) ) * ( math . sqrt ( p - a ) ) * ( math . sqrt ( p - b ) ) * ( math . sqrt ( p - c ) ) ) NEW_LINE DEDENT
def binary_search ( ) : NEW_LINE INDENT global r1 , r2 , r3 NEW_LINE s = area ( r1 + r2 , r2 + r3 , r3 + r1 ) NEW_LINE l = 0 NEW_LINE h = s / ( r1 + r2 + r3 ) NEW_LINE while ( h - l > 0.00000001 ) : NEW_LINE INDENT mid = ( l + h ) / 2 NEW_LINE s1 = area ( mid + r1 , mid + r2 , r1 + r2 ) NEW_LINE s2 = area ( mid + r1 , mid + r3 , r1 + r3 ) NEW_LINE s3 = area ( mid + r2 , mid + r3 , r2 + r3 ) NEW_LINE if ( s1 + s2 + s3 < s ) : NEW_LINE INDENT l = mid NEW_LINE DEDENT else : NEW_LINE INDENT h = mid NEW_LINE DEDENT DEDENT return ( ( l + h ) / 2 ) NEW_LINE DEDENT
def subArray ( arr , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = i + 1 NEW_LINE DEDENT sumcur = 0 NEW_LINE p = 10 ** 9 NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT sumcur += mp [ i ] NEW_LINE p = min ( p , mp [ i ] ) NEW_LINE val = p * i - i + ( i * ( i + 1 ) ) / 2 NEW_LINE if ( i == m ) : NEW_LINE INDENT if ( val == sumcur ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def isPalindrome ( s ) : NEW_LINE INDENT left = 0 NEW_LINE right = len ( s ) - 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT if ( s [ left ] != s [ right ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT left = left + 1 NEW_LINE right = right - 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def cntSubSeq ( arr , n ) : NEW_LINE INDENT pos_count = 0 NEW_LINE neg_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_count += 1 NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT neg_count += 1 NEW_LINE DEDENT DEDENT result = int ( math . pow ( 2 , pos_count ) ) NEW_LINE if ( neg_count > 0 ) : NEW_LINE INDENT result *= int ( math . pow ( 2 , neg_count - 1 ) ) NEW_LINE DEDENT result -= 1 NEW_LINE return result NEW_LINE DEDENT
def FermatFactors ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return [ n ] NEW_LINE DEDENT if ( n & 1 ) == 0 : NEW_LINE INDENT return [ n / 2 , 2 ] NEW_LINE DEDENT a = ceil ( sqrt ( n ) ) NEW_LINE if ( a * a == n ) : NEW_LINE INDENT return [ a , a ] NEW_LINE DEDENT while ( True ) : NEW_LINE INDENT b1 = a * a - n NEW_LINE b = int ( sqrt ( b1 ) ) NEW_LINE if ( b * b == b1 ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT a += 1 NEW_LINE DEDENT DEDENT return [ a - b , a + b ] NEW_LINE DEDENT
def findNums ( arr , n ) : NEW_LINE INDENT S = 0 NEW_LINE X = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE X ^= arr [ i ] NEW_LINE DEDENT print ( X , X + S ) NEW_LINE DEDENT
def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n // 2 NEW_LINE DEDENT DEDENT
def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def getNum ( n , k ) : NEW_LINE INDENT l = int ( math . log2 ( n ) ) + 1 NEW_LINE a = [ 0 for i in range ( 0 , l ) ] NEW_LINE decBinary ( a , n ) NEW_LINE if ( k > l ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( a [ k - 1 ] == 0 ) : NEW_LINE INDENT a [ k - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ k - 1 ] = 0 NEW_LINE DEDENT return binaryDec ( a , l ) NEW_LINE DEDENT
def solve ( A , B ) : NEW_LINE INDENT p = B / 2 NEW_LINE M = int ( 4 * p ) NEW_LINE N = 1 NEW_LINE O = - 2 * A NEW_LINE Q = int ( A * A + 4 * p * p ) NEW_LINE return [ M , N , O , Q ] NEW_LINE DEDENT
def findMin ( arr , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 ] * ( m + 2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , m + 2 ) : NEW_LINE INDENT j = i NEW_LINE cnt = 0 NEW_LINE while ( j <= m ) : NEW_LINE INDENT cnt += freq [ j ] NEW_LINE j += i NEW_LINE DEDENT if ( not cnt ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return m + 1 NEW_LINE DEDENT
def findMin ( arr , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT cnt = [ 0 ] * ( m + 2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 1 NEW_LINE while j * j <= arr [ i ] : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT if ( j * j == arr [ i ] ) : NEW_LINE INDENT cnt [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ j ] += 1 NEW_LINE cnt [ arr [ i ] // j ] += 1 NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , m + 2 ) : NEW_LINE INDENT if ( cnt [ i ] == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def find_composite_nos ( n ) : NEW_LINE INDENT print ( 9 * n , 8 * n ) NEW_LINE DEDENT
def maxXOR ( arr , n ) : NEW_LINE INDENT xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , ( xorArr ^ arr [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findLargest ( arr , n ) : NEW_LINE INDENT gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( arr [ i ] , gcd ) NEW_LINE DEDENT return gcd NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i < sz : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , sz , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def removePrimes ( arr , lenn ) : NEW_LINE INDENT sieve ( ) NEW_LINE i = 0 NEW_LINE while i < lenn : NEW_LINE INDENT if ( isPrime [ arr [ i ] ] ) : NEW_LINE INDENT for j in range ( i , lenn - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT i -= 1 NEW_LINE lenn -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT prArray ( arr , lenn ) NEW_LINE DEDENT
def minOR ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT pre = [ 0 ] * n NEW_LINE suf = [ 0 ] * n NEW_LINE pre [ 0 ] = arr [ 0 ] NEW_LINE suf [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) NEW_LINE DEDENT ans = min ( pre [ n - 2 ] , suf [ 1 ] ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT ans = min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def subgrids ( N , Z , row , col , r , d ) : NEW_LINE INDENT conrow = [ ] NEW_LINE concol = [ ] NEW_LINE K = int ( sqrt ( Z ) ) NEW_LINE conrow . append ( row [ 0 ] - 0 - 1 ) NEW_LINE conrow . append ( N + 1 - row [ r - 1 ] - 1 ) NEW_LINE for i in range ( 1 , r ) : NEW_LINE INDENT conrow . append ( row [ i ] - row [ i - 1 ] - 1 ) NEW_LINE DEDENT concol . append ( col [ 0 ] - 0 - 1 ) NEW_LINE concol . append ( N + 1 - col [ d - 1 ] - 1 ) NEW_LINE for i in range ( 1 , d ) : NEW_LINE INDENT concol . append ( col [ i ] - col [ i - 1 ] - 1 ) NEW_LINE DEDENT row_size = len ( conrow ) NEW_LINE col_size = len ( concol ) NEW_LINE answer = 0 NEW_LINE for i in range ( row_size ) : NEW_LINE INDENT for j in range ( col_size ) : NEW_LINE INDENT total = ( concol [ j ] // K ) * ( conrow [ i ] // K ) NEW_LINE answer += ( total ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def sub_arrays ( a , n , k ) : NEW_LINE INDENT sum = [ 0 for i in range ( n + 2 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] -= 1 NEW_LINE a [ i ] %= k NEW_LINE sum [ i + 1 ] += sum [ i ] + a [ i ] NEW_LINE sum [ i + 1 ] %= k NEW_LINE DEDENT ans = 0 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if sum [ i ] in mp : NEW_LINE INDENT ans += mp [ sum [ i ] ] NEW_LINE DEDENT mp [ sum [ i ] ] = mp . get ( sum [ i ] , 0 ) + 1 NEW_LINE r += 1 NEW_LINE if ( r - l >= k ) : NEW_LINE INDENT mp [ sum [ l ] ] -= 1 NEW_LINE l += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findCount ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( digitDividesK ( i , k ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n // divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n // divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( n % divisor ) // 10 NEW_LINE divisor = divisor // 100 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isDigitSumPalindrome ( n ) : NEW_LINE INDENT sum = digitSum ( n ) NEW_LINE if ( isPalindrome ( sum ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def countDigits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n //= 10 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def digitPowSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE pw = countDigits ( n ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE sum += pow ( d , pw ) NEW_LINE pw -= 1 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def countNum ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == digitPowSum ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def perfectSquares ( l , r ) : NEW_LINE INDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i ** ( .5 ) == int ( i ** ( .5 ) ) ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def perfectSquares ( l , r ) : NEW_LINE INDENT number = ceil ( sqrt ( l ) ) NEW_LINE n2 = number * number NEW_LINE number = ( number * 2 ) + 1 NEW_LINE while ( ( n2 >= l and n2 <= r ) ) : NEW_LINE INDENT print ( n2 , end = " " ) NEW_LINE n2 = n2 + number NEW_LINE number += 2 NEW_LINE DEDENT DEDENT
def xorK ( n , k ) : NEW_LINE INDENT if ( k % 2 == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def findRemainders ( n ) : NEW_LINE INDENT vc = dict ( ) NEW_LINE for i in range ( 1 , ceil ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT vc [ n // i ] = 1 NEW_LINE DEDENT for i in range ( n // ceil ( sqrt ( n ) ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT vc [ i ] = 1 NEW_LINE DEDENT for it in sorted ( vc ) : NEW_LINE INDENT print ( it , end = " " ) NEW_LINE DEDENT DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( MAX ) : NEW_LINE INDENT if ( p * p > MAX ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countPrimes ( n ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i - 2 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def power ( a , m1 ) : NEW_LINE INDENT if ( m1 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( m1 == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( m1 == 2 ) : NEW_LINE INDENT return ( a * a ) % mod NEW_LINE DEDENT elif ( m1 & 1 ) : NEW_LINE INDENT return ( a * power ( power ( a , m1 // 2 ) , 2 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return power ( power ( a , m1 // 2 ) , 2 ) % mod NEW_LINE DEDENT DEDENT
def factorialfun ( ) : NEW_LINE INDENT factorial [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT factorial [ i ] = ( factorial [ i - 1 ] * i ) % mod NEW_LINE DEDENT DEDENT
def modinversefun ( ) : NEW_LINE INDENT modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT modinverse [ i ] = ( modinverse [ i + 1 ] * ( i + 1 ) ) % mod NEW_LINE DEDENT DEDENT
def binomial ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = ( factorial [ n ] * modinverse [ n - r ] ) % mod NEW_LINE a = ( a * modinverse [ r ] ) % mod NEW_LINE return a NEW_LINE DEDENT
def arrange ( n , m , k ) : NEW_LINE INDENT factorialfun ( ) NEW_LINE modinversefun ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans += ( i * ( n - i ) * m * m ) % mod NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT ans += ( i * ( m - i ) * n * n ) % mod NEW_LINE DEDENT ans = ( ans * binomial ( n * m - 2 , k - 2 ) ) % mod NEW_LINE return int ( ans ) NEW_LINE DEDENT
def findK ( l , r ) : NEW_LINE INDENT maxExp = - sys . maxsize - 1 NEW_LINE k = - 1 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT if ( distinctDigits ( i ) ) : NEW_LINE INDENT exp = ( l - i ) * ( i - r ) NEW_LINE if ( exp >= maxExp ) : NEW_LINE INDENT k = i NEW_LINE maxExp = exp NEW_LINE DEDENT DEDENT DEDENT return k NEW_LINE DEDENT
def findWinner ( n ) : NEW_LINE INDENT if ( ( n - 1 ) % 6 == 0 ) : NEW_LINE INDENT print ( "Second Player wins the game" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "First Player wins the game" ) NEW_LINE DEDENT DEDENT
def countIndices ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max < arr [ i ] ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def min_changes ( a , n ) : NEW_LINE INDENT ans_a = 0 NEW_LINE ans_b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT ans_a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans_b += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT ans_b += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans_a += 1 NEW_LINE DEDENT DEDENT DEDENT return min ( ans_a , ans_b ) NEW_LINE DEDENT
def ans ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( "1" , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = "" ) NEW_LINE DEDENT DEDENT
def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def sumPrime ( d ) : NEW_LINE INDENT maxVal = int ( pow ( 2 , d ) ) - 1 NEW_LINE prime = [ True for i in range ( maxVal + 1 ) ] NEW_LINE sieve ( prime , maxVal ) NEW_LINE sum = 0 NEW_LINE for i in range ( 2 , maxVal + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def isPossible ( w , h , x , y ) : NEW_LINE INDENT if ( x * 2 == w and y * 2 == h ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findNthDigit ( p , q , N ) : NEW_LINE INDENT while ( N > 0 ) : NEW_LINE INDENT N -= 1 NEW_LINE p *= 10 NEW_LINE res = p // q NEW_LINE p %= q NEW_LINE DEDENT return res NEW_LINE DEDENT
def minsteps ( n , m ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) // 2 + m - 1 ) // m * m NEW_LINE DEDENT DEDENT
def compare ( a , b ) : NEW_LINE INDENT a = removeLeadingZeros ( a ) NEW_LINE b = removeLeadingZeros ( b ) NEW_LINE lenA = getSize ( a ) NEW_LINE lenB = getSize ( b ) NEW_LINE if ( lenA > lenB ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( lenB > lenA ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT while ( a != None and b != None ) : NEW_LINE INDENT if ( a . data > b . data ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( a . data < b . data ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = a . next NEW_LINE b = b . next NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def power ( a , m1 ) : NEW_LINE INDENT if ( m1 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( m1 == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( m1 == 2 ) : NEW_LINE INDENT return ( a * a ) % mod NEW_LINE DEDENT elif ( m1 & 1 ) : NEW_LINE INDENT return ( a * power ( power ( a , m1 // 2 ) , 2 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return power ( power ( a , m1 // 2 ) , 2 ) % mod NEW_LINE DEDENT DEDENT
def factorialfun ( ) : NEW_LINE INDENT factorial [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT factorial [ i ] = ( factorial [ i - 1 ] * i ) % mod NEW_LINE DEDENT DEDENT
def modinversefun ( ) : NEW_LINE INDENT modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT modinverse [ i ] = ( modinverse [ i + 1 ] * ( i + 1 ) ) % mod NEW_LINE DEDENT DEDENT
def binomial ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = ( factorial [ n ] * modinverse [ n - r ] ) % mod NEW_LINE a = ( a * modinverse [ r ] ) % mod NEW_LINE return a NEW_LINE DEDENT
def maxFreq ( s ) : NEW_LINE INDENT binary = "" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT binary += bin [ ord ( s [ i ] ) - ord ( '0' ) ] NEW_LINE DEDENT binary = binary [ 0 : len ( binary ) - 1 ] NEW_LINE count = 1 NEW_LINE prev = - 1 NEW_LINE j = 0 NEW_LINE for i in range ( len ( binary ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( binary [ i ] == '1' ) : NEW_LINE INDENT count = max ( count , j - prev ) NEW_LINE prev = j NEW_LINE DEDENT j += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def sumArr ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumModArr ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT subSum = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT subSum += arr [ j ] NEW_LINE DEDENT arr [ i ] -= subSum NEW_LINE DEDENT return sumArr ( arr , n ) NEW_LINE DEDENT
def sumArr ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumModArr ( arr , n ) : NEW_LINE INDENT subSum = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] -= subSum NEW_LINE subSum += curr NEW_LINE DEDENT return sumArr ( arr , n ) NEW_LINE DEDENT
def lcm ( a , b ) : NEW_LINE INDENT GCD = gcd ( a , b ) NEW_LINE return ( a * b ) // GCD NEW_LINE DEDENT
def MinLCM ( a , n ) : NEW_LINE INDENT Prefix = [ 0 ] * ( n + 2 ) NEW_LINE Suffix = [ 0 ] * ( n + 2 ) NEW_LINE Prefix [ 1 ] = a [ 0 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) NEW_LINE DEDENT Suffix [ n ] = a [ n - 1 ] NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) NEW_LINE DEDENT ans = min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT ans = min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findNum ( x ) : NEW_LINE INDENT for i in range ( NumUnsignBits - 1 ) : NEW_LINE INDENT if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) : NEW_LINE INDENT x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) NEW_LINE return x NEW_LINE DEDENT DEDENT DEDENT
def minHealth ( health , n ) : NEW_LINE INDENT __gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT __gcd = gcd ( __gcd , health [ i ] ) NEW_LINE DEDENT return __gcd NEW_LINE DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def constructArr ( pair , n ) : NEW_LINE INDENT size = int ( ( 1 + sqrt ( 1 + 8 * n ) ) // 2 ) NEW_LINE arr = [ 0 ] * ( size ) NEW_LINE arr [ 0 ] = int ( sqrt ( ( pair [ 0 ] * pair [ 1 ] ) / pair [ size - 1 ] ) ) NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT arr [ i ] = pair [ i - 1 ] // arr [ 0 ] NEW_LINE DEDENT printArr ( arr , size ) NEW_LINE DEDENT
def countWays ( n , m ) : NEW_LINE INDENT return factMod ( m ) NEW_LINE DEDENT
def Fuss_catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 3 * n , n ) NEW_LINE return c // ( 2 * n + 1 ) NEW_LINE DEDENT
def isComposite ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def Power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( sqrt ( sz ) ) + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , sz , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findCnt ( arr , n , k ) : NEW_LINE INDENT ret = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT x = max ( 0 , j - i - k ) NEW_LINE ret += ( x * ( x + 1 ) ) / 2 NEW_LINE i = j NEW_LINE DEDENT return ret NEW_LINE DEDENT
def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) : NEW_LINE INDENT if arr [ 2 * i + 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def reverse ( num ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev = rev * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT
def isPalindrome ( num ) : NEW_LINE INDENT if ( num == reverse ( num ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def printPalindromes ( d ) : NEW_LINE INDENT if ( d <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT smallest = pow ( 10 , d - 1 ) NEW_LINE largest = pow ( 10 , d ) - 1 NEW_LINE for i in range ( smallest , largest + 1 ) : NEW_LINE INDENT if ( isPalindrome ( i ) ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def countElements ( p , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif ( p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countNums ( a , b , c , d ) : NEW_LINE INDENT x = b // c - ( a - 1 ) // c NEW_LINE y = b // d - ( a - 1 ) // d NEW_LINE k = ( c * d ) // gcd ( c , d ) NEW_LINE z = b // k - ( a - 1 ) // k NEW_LINE return ( b - a + 1 - x - y + z ) NEW_LINE DEDENT
def cntSubArrays ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT res += max ( j - i - k + 1 , 0 ) NEW_LINE i = j NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxLen ( arr , n ) : NEW_LINE INDENT min_val = min ( arr ) NEW_LINE freq = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_val ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT DEDENT return freq NEW_LINE DEDENT
def print_primes_till_N ( N ) : NEW_LINE INDENT i , j , flag = 0 , 0 , 0 NEW_LINE print ( "Prime numbers between 1 and " , N , " are:" ) NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT if ( i == 1 or i == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT flag = 1 NEW_LINE for j in range ( 2 , ( ( i // 2 ) + 1 ) , 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def last_digit ( X , Y ) : NEW_LINE INDENT print ( X % Y ) NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( sqrt ( sz ) ) + 1 , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , sz , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findPrimesD ( d ) : NEW_LINE INDENT left = int ( pow ( 10 , d - 1 ) ) NEW_LINE right = int ( pow ( 10 , d ) - 1 ) NEW_LINE for i in range ( left , right + 1 , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def geometricMean ( n ) : NEW_LINE INDENT return int ( sqrt ( n ) ) NEW_LINE DEDENT
def two_sets ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return ( a [ n // 2 ] - a [ ( n // 2 ) - 1 ] ) NEW_LINE DEDENT
def min_moves ( n ) : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT ans = min ( ans , i + n // i - 2 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findX ( A , B ) : NEW_LINE INDENT X = 0 NEW_LINE for bit in range ( MAX ) : NEW_LINE INDENT tempBit = 1 << bit NEW_LINE bitOfX = A & B & tempBit NEW_LINE X += bitOfX NEW_LINE DEDENT return X NEW_LINE DEDENT
def cntPairs ( a , n ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT elif ( ( a [ i ] / 2 ) % 2 == 1 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT ans = odd * even + ( odd * ( odd - 1 ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT
def min_modulo ( l , r ) : NEW_LINE INDENT if ( r - l >= MOD ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans = MOD - 1 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) % MOD ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
def kthNum ( n , k ) : NEW_LINE INDENT a = ( n + 1 ) // 2 NEW_LINE if ( k > a ) : NEW_LINE INDENT return ( 2 * ( k - a ) ) NEW_LINE DEDENT return ( 2 * k - 1 ) NEW_LINE DEDENT
def find_numbers ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( - 1 , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , N + 1 , N * ( N + 1 ) ) NEW_LINE DEDENT DEDENT
def findNum ( a , n , b , m ) : NEW_LINE INDENT x = max ( a ) NEW_LINE y = max ( b ) NEW_LINE print ( x , y ) NEW_LINE DEDENT
def find_k ( a , b ) : NEW_LINE INDENT if ( ( a + b ) % 2 == 0 ) : NEW_LINE INDENT return ( ( a + b ) // 2 ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def odd_digits ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return n NEW_LINE DEDENT elif ( n / 10 < 10 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT elif ( n / 100 < 10 ) : NEW_LINE INDENT return 9 + n - 99 NEW_LINE DEDENT elif ( n / 1000 < 10 ) : NEW_LINE INDENT return 9 + 900 NEW_LINE DEDENT elif ( n / 10000 < 10 ) : NEW_LINE INDENT return 909 + n - 9999 NEW_LINE DEDENT else : NEW_LINE INDENT return 90909 NEW_LINE DEDENT DEDENT
def nDigitPalindromes ( n ) : NEW_LINE INDENT return ( 9 * pow ( 10 , ( n - 1 ) // 2 ) ) NEW_LINE DEDENT
def maxLCM ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) NEW_LINE DEDENT
def cntSubSets ( arr , n ) : NEW_LINE INDENT maxVal = max ( arr ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == maxVal ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return ( ( 2 ** cnt ) - 1 ) NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT return ( ( n - 1 ) + pow ( n , 2 ) ) NEW_LINE DEDENT
def cntEdges ( n ) : NEW_LINE INDENT edges = 2 ** n - 2 NEW_LINE return edges NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT return n * ( 3 * n - 1 ) // 2 NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT return n ** 3 NEW_LINE DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def generateArr ( arr , n ) : NEW_LINE INDENT flip = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT flip ^= True NEW_LINE if ( flip ) : NEW_LINE INDENT print ( int ( ceil ( ( arr [ i ] ) / 2 ) ) , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( floor ( ( arr [ i ] ) / 2 ) ) , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( int ( arr [ i ] / 2 ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def count ( n ) : NEW_LINE INDENT return 15 * pow ( 16 , n - 1 ) NEW_LINE DEDENT
def nth_term ( a , b , n ) : NEW_LINE INDENT z = 0 NEW_LINE if ( n % 6 == 1 ) : NEW_LINE INDENT z = a NEW_LINE DEDENT elif ( n % 6 == 2 ) : NEW_LINE INDENT z = b NEW_LINE DEDENT elif ( n % 6 == 3 ) : NEW_LINE INDENT z = b - a NEW_LINE DEDENT elif ( n % 6 == 4 ) : NEW_LINE INDENT z = - a NEW_LINE DEDENT elif ( n % 6 == 5 ) : NEW_LINE INDENT z = - b NEW_LINE DEDENT if ( n % 6 == 0 ) : NEW_LINE INDENT z = - ( b - a ) NEW_LINE DEDENT return z NEW_LINE DEDENT
def cntSubSeq ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE num = arr [ k - 1 ] NEW_LINE Y = 0 NEW_LINE for i in range ( k - 1 , - 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] == num ) : NEW_LINE INDENT Y += 1 NEW_LINE DEDENT DEDENT cntX = Y NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if ( arr [ i ] == num ) : NEW_LINE INDENT cntX += 1 NEW_LINE DEDENT DEDENT return binomialCoeff ( cntX , Y ) NEW_LINE DEDENT
def inProportion ( arr ) : NEW_LINE INDENT n = 4 NEW_LINE arr . sort ( ) NEW_LINE extremes = arr [ 0 ] * arr [ 3 ] NEW_LINE means = arr [ 1 ] * arr [ 2 ] NEW_LINE if ( extremes == means ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findProb ( arr , n ) : NEW_LINE INDENT maxSum = - ( sys . maxsize - 1 ) NEW_LINE maxCount = 0 NEW_LINE totalPairs = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] NEW_LINE if ( sum == maxSum ) : NEW_LINE INDENT maxCount += 1 NEW_LINE DEDENT elif ( sum > maxSum ) : NEW_LINE INDENT maxSum = sum NEW_LINE maxCount = 1 NEW_LINE DEDENT totalPairs += 1 NEW_LINE DEDENT DEDENT prob = maxCount / totalPairs NEW_LINE return prob NEW_LINE DEDENT
def findMissing ( arr , n , k , avg ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT num = ( avg * ( n + k ) ) - sum NEW_LINE den = k NEW_LINE if ( num % den != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( int ) ( num / den ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT
def countNum ( n ) : NEW_LINE INDENT if ( n > 10 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 9 * factorial ( 9 ) // factorial ( 10 - n ) ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT
def findMax ( n ) : NEW_LINE INDENT return binomialCoeff ( n , n // 2 ) NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT return ( - 1 + sqrt ( 1 + 8 * n ) ) // 2 NEW_LINE DEDENT
def findEquation ( a , b ) : NEW_LINE INDENT summ = ( a + b ) NEW_LINE product = ( a * b ) NEW_LINE print ( "x^2 - (" , summ , "x) + (" , product , ") = 0" ) NEW_LINE DEDENT
def cal ( n ) : NEW_LINE INDENT res = pow ( ceil ( ( pow ( pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 ) NEW_LINE return int ( res ) NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT return 3 * n * ( n - 1 ) + 1 NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT if ( k == 0 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT if ( n >= 1 ) : NEW_LINE INDENT return n * fact ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT
def isVowel ( ch ) : NEW_LINE INDENT if ( ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def countWords ( s , p , q ) : NEW_LINE INDENT countc = 0 NEW_LINE countv = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) ) : NEW_LINE INDENT countv += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countc += 1 NEW_LINE DEDENT DEDENT a = binomialCoeff ( countc , p ) NEW_LINE b = binomialCoeff ( countv , q ) NEW_LINE c = fact ( p + q ) NEW_LINE ans = ( a * b ) * c NEW_LINE return ans NEW_LINE DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in arr : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def generateArr ( A , n ) : NEW_LINE INDENT B = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( A [ j ] % A [ i ] == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT B [ i ] = cnt NEW_LINE DEDENT printArr ( B , n ) NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT return pow ( 2 , n - 1 ) NEW_LINE DEDENT
def nextFibonacci ( n ) : NEW_LINE INDENT a = n * ( 1 + sqrt ( 5 ) ) / 2.0 NEW_LINE return round ( a ) NEW_LINE DEDENT
def product ( a , n ) : NEW_LINE INDENT ans = 1 NEW_LINE val = pow ( 2 , n - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans *= pow ( a [ i ] , val ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def max_distinct_char ( str , n ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT max_distinct = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT max_distinct += 1 NEW_LINE DEDENT DEDENT return max_distinct NEW_LINE DEDENT
def smallesteSubstr_maxDistictChar ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE max_distinct = max_distinct_char ( str , n ) NEW_LINE minl = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT subs = str [ i : j ] NEW_LINE subs_lenght = len ( subs ) NEW_LINE sub_distinct_char = max_distinct_char ( subs , subs_lenght ) NEW_LINE if ( subs_lenght < minl and max_distinct == sub_distinct_char ) : NEW_LINE INDENT minl = subs_lenght NEW_LINE DEDENT DEDENT DEDENT return minl NEW_LINE DEDENT
def findPair ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT i = 0 NEW_LINE first = - 1 NEW_LINE second = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT print ( "n =" , first , "and r =" , second ) NEW_LINE DEDENT
def sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in arr : NEW_LINE INDENT sum += i NEW_LINE DEDENT sum = sum * pow ( 2 , n - 1 ) NEW_LINE return sum NEW_LINE DEDENT
def maxHeight ( n ) : NEW_LINE INDENT ans = ( sqrt ( 1 + 8.0 * n ) - 1 ) // 2 NEW_LINE return int ( ans ) NEW_LINE DEDENT
def ways ( n ) : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT
def prevPowerof2 ( n ) : NEW_LINE INDENT p = int ( log ( n ) ) NEW_LINE return pow ( 2 , p ) NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
def minDiff ( n ) : NEW_LINE INDENT low = prevPowerof2 ( n ) NEW_LINE high = nextPowerOf2 ( n ) NEW_LINE return min ( n - low , high - n ) NEW_LINE DEDENT
def isPossible ( x , y , k ) : NEW_LINE INDENT minMoves = abs ( x ) + abs ( y ) NEW_LINE if ( k >= minMoves and ( k - minMoves ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT map = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ arr [ i ] - i ] = map . get ( arr [ i ] - i , 0 ) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in map : NEW_LINE INDENT cnt = map [ x ] NEW_LINE res += ( ( cnt * ( cnt - 1 ) ) // 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findMinValue ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return ( sum // n ) + 1 NEW_LINE DEDENT
def isFactorion ( n ) : NEW_LINE INDENT fact = [ 0 ] * MAX NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT org = n NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE sum += fact [ d ] NEW_LINE n = n // 10 NEW_LINE DEDENT if ( sum == org ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def modFact ( n , m ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT
def minOperations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE d = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n > 9 ) : NEW_LINE INDENT d = max ( n % 10 , d ) NEW_LINE n //= 10 NEW_LINE count += 10 NEW_LINE DEDENT d = max ( d , n - 1 ) NEW_LINE count += abs ( d ) NEW_LINE return count - 1 NEW_LINE DEDENT
def maxCommonFactors ( a , b ) : NEW_LINE INDENT gcd = math . gcd ( a , b ) NEW_LINE ans = 1 NEW_LINE i = 2 NEW_LINE while ( i * i <= gcd ) : NEW_LINE INDENT if ( gcd % i == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE while ( gcd % i == 0 ) : NEW_LINE INDENT gcd = gcd // i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( gcd != 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def updateFreq ( n , freq ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT digit = n % TEN NEW_LINE freq [ digit ] += 1 NEW_LINE n //= TEN NEW_LINE DEDENT DEDENT
def areAnagrams ( a , b ) : NEW_LINE INDENT freqA = [ 0 ] * TEN NEW_LINE freqB = [ 0 ] * TEN NEW_LINE updateFreq ( a , freqA ) NEW_LINE updateFreq ( b , freqB ) NEW_LINE for i in range ( TEN ) : NEW_LINE INDENT if ( freqA [ i ] != freqB [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def dayOfYear ( date ) : NEW_LINE INDENT year = ( int ) ( date [ 0 : 4 ] ) NEW_LINE month = ( int ) ( date [ 5 : 7 ] ) NEW_LINE day = ( int ) ( date [ 8 : ] ) NEW_LINE if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day += 1 NEW_LINE DEDENT month -= 1 NEW_LINE while ( month > 0 ) : NEW_LINE INDENT day = day + days [ month - 1 ] NEW_LINE month -= 1 NEW_LINE DEDENT return day NEW_LINE DEDENT
def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) // 2 NEW_LINE DEDENT
def convertToBinary ( num , a , n ) : NEW_LINE INDENT pointer = n - 1 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT a [ pointer ] = num % 2 NEW_LINE num = num // 2 NEW_LINE pointer -= 1 NEW_LINE DEDENT DEDENT
def print_seq ( m ) : NEW_LINE INDENT n = ( 2 * m ) NEW_LINE a = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( pow ( 2 , n ) ) : NEW_LINE INDENT convertToBinary ( i , a , n ) NEW_LINE checkforsum ( a , n ) NEW_LINE DEDENT DEDENT
def isDivisible ( arr , n ) : NEW_LINE INDENT lastDigit = arr [ n - 1 ] % 10 NEW_LINE if ( lastDigit == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) // 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT
def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD NEW_LINE result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE DEDENT DEDENT
def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n + 1 : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def thirdNumber ( a , b ) : NEW_LINE INDENT summ = 0 NEW_LINE temp = 0 NEW_LINE summ = a + b NEW_LINE temp = 1 NEW_LINE if ( summ & 1 ) : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while ( prime ( summ + temp ) == False ) : NEW_LINE INDENT temp += 2 NEW_LINE DEDENT print ( temp ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def divTermCount ( a , b , c , num ) : NEW_LINE INDENT return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) NEW_LINE DEDENT
def findNthTerm ( a , b , c , n ) : NEW_LINE INDENT low = 1 NEW_LINE high = sys . maxsize NEW_LINE mid = 0 NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 NEW_LINE if ( divTermCount ( a , b , c , mid ) < n ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT return int ( low ) NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans *= ( n - r + i ) NEW_LINE ans //= i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def divTermCount ( a , b , c , num ) : NEW_LINE INDENT return ( num // a + num // b + num // c - num // lcm ( a , b ) - num // lcm ( c , b ) - num // lcm ( a , c ) + num // ( lcm ( lcm ( a , b ) , c ) ) ) NEW_LINE DEDENT
def calculate_angle ( n , i , j , k ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE if ( i < j ) : NEW_LINE INDENT x = j - i NEW_LINE DEDENT else : NEW_LINE INDENT x = j + n - i NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT y = k - j NEW_LINE DEDENT else : NEW_LINE INDENT y = k + n - j NEW_LINE DEDENT ang1 = ( 180 * x ) // n NEW_LINE ang2 = ( 180 * y ) // n NEW_LINE ans = 180 - ang1 - ang2 NEW_LINE return ans NEW_LINE DEDENT
def getIndex ( n , shuffle ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT if ( shuffle [ i ] [ 0 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 1 ] NEW_LINE DEDENT elif ( shuffle [ i ] [ 1 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 0 ] NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE DEDENT
def calculate ( n , k , m , power ) : NEW_LINE INDENT if n > m : NEW_LINE INDENT if power == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return power - 1 NEW_LINE DEDENT DEDENT elif n == m : NEW_LINE INDENT return power NEW_LINE DEDENT else : NEW_LINE INDENT return calculate ( n * k , k , m , power + 1 ) NEW_LINE DEDENT DEDENT
def printNumber ( holes ) : NEW_LINE INDENT if ( holes == 0 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT elif ( holes == 1 ) : NEW_LINE INDENT print ( "0" , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE quo = 0 NEW_LINE rem = holes % 2 NEW_LINE quo = holes // 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT print ( "4" , end = "" ) NEW_LINE DEDENT for i in range ( quo ) : NEW_LINE INDENT print ( "8" , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def power ( p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , p + 1 ) : NEW_LINE INDENT res *= 2 NEW_LINE res %= mod NEW_LINE DEDENT return res % mod NEW_LINE DEDENT
def subset_square_sum ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE for i in A : NEW_LINE INDENT ans += i * i % mod NEW_LINE ans %= mod NEW_LINE DEDENT return ans * power ( n - 1 ) % mod NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) // ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT
def number_of_subsequences ( arr , k , n ) : NEW_LINE INDENT s = 0 NEW_LINE m = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT for j in m : NEW_LINE INDENT s = s + nCr ( m [ j ] , k ) NEW_LINE DEDENT return s NEW_LINE DEDENT
def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT
def coprime ( a , b ) : NEW_LINE INDENT if ( gcd ( a , b ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def findNumbers ( a , b , n ) : NEW_LINE INDENT possible = True NEW_LINE if ( not coprime ( a , b ) ) : NEW_LINE INDENT possible = False NEW_LINE DEDENT c1 = 1 NEW_LINE c2 = 1 NEW_LINE num1 = 0 NEW_LINE num2 = 0 NEW_LINE st = set ( ) NEW_LINE if ( possible ) : NEW_LINE INDENT while ( len ( st ) != n ) : NEW_LINE INDENT num1 = a + ( c1 * b ) NEW_LINE if ( isPrime ( num1 ) ) : NEW_LINE INDENT st . add ( num1 ) NEW_LINE DEDENT c1 += 1 NEW_LINE num2 = b + ( c2 * a ) NEW_LINE if ( isPrime ( num2 ) ) : NEW_LINE INDENT st . add ( num2 ) NEW_LINE DEDENT c2 += 1 NEW_LINE DEDENT for i in st : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def sumPairs ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( arr [ i ] * ( 2 * n ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE arr . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 4 < 2 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def getCount ( A , B2 , C ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while ( i < A ) : NEW_LINE INDENT j = ( B2 // i ) + 1 NEW_LINE if ( C >= j ) : NEW_LINE INDENT count = count + C - j + 1 NEW_LINE DEDENT if ( A >= j and C >= i ) : NEW_LINE INDENT count = count + ( C - i + 1 ) * ( A - j + 1 ) NEW_LINE DEDENT if ( A >= j ) : NEW_LINE INDENT A = j - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT
def posProdSubArr ( arr , n ) : NEW_LINE INDENT total = ( n * ( n + 1 ) ) / 2 NEW_LINE cntNeg = negProdSubArr ( arr , n ) NEW_LINE return ( total - cntNeg ) NEW_LINE DEDENT
def distinctRemainders ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT return ( ( n // 2 ) + 1 ) NEW_LINE DEDENT
def countUnsetBits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = i NEW_LINE while ( temp ) : NEW_LINE INDENT if ( temp % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT temp = temp // 2 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def least_prime_factor ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT if ( lpf [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( lpf [ j ] == 0 ) : NEW_LINE INDENT lpf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def Mobius ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT mobius [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( lpf [ ( i // lpf [ i ] ) ] == lpf [ i ] ) : NEW_LINE INDENT mobius [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT mobius [ i ] = - 1 * mobius [ i // lpf [ i ] ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def gcd_pairs ( a , n ) : NEW_LINE INDENT maxi = 0 NEW_LINE fre = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT fre [ a [ i ] ] += 1 NEW_LINE maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT least_prime_factor ( ) NEW_LINE Mobius ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if ( mobius [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = 0 NEW_LINE for j in range ( i , maxi + 1 , i ) : NEW_LINE INDENT temp += fre [ j ] NEW_LINE DEDENT ans += temp * ( temp - 1 ) // 2 * mobius [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def xorFirstNPrime ( n ) : NEW_LINE INDENT count = 0 NEW_LINE num = 1 NEW_LINE xorVal = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT if ( prime [ num ] ) : NEW_LINE INDENT xorVal ^= num NEW_LINE count += 1 NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return xorVal NEW_LINE DEDENT
def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) ) // 2 NEW_LINE return sum NEW_LINE DEDENT
def repeatedSum ( n , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT n = sum ( n ) NEW_LINE DEDENT return n NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT digit = n % 10 NEW_LINE sum += digit NEW_LINE n //= 10 NEW_LINE DEDENT n = temp NEW_LINE while ( n ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( sum % digit != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
def least_prime_factor ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT if ( not lpf [ i ] ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( not lpf [ j ] ) : NEW_LINE INDENT lpf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def Mobius ( n ) : NEW_LINE INDENT mobius = [ 0 ] * N NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT mobius [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( lpf [ i // lpf [ i ] ] == lpf [ i ] ) : NEW_LINE INDENT mobius [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT mobius [ i ] = - 1 * mobius [ i // lpf [ i ] ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( mobius [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def getBest ( prev , cur ) : NEW_LINE INDENT maximum = max ( MIN , prev ) NEW_LINE for i in range ( maximum , MAX + 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE a = i NEW_LINE b = cur NEW_LINE for k in range ( DIGITS ) : NEW_LINE INDENT if ( a % 10 != b % 10 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT a //= 10 NEW_LINE b //= 10 NEW_LINE DEDENT if ( cnt <= 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def getList ( arr , n ) : NEW_LINE INDENT myList = [ ] NEW_LINE possible = True NEW_LINE myList . append ( 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cur = arr [ i ] NEW_LINE myList . append ( getBest ( myList [ - 1 ] , cur ) ) NEW_LINE if ( myList [ - 1 ] == - 1 ) : NEW_LINE INDENT possible = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( possible ) : NEW_LINE INDENT for i in range ( 1 , len ( myList ) ) : NEW_LINE INDENT print ( myList [ i ] , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def maxItems ( x , y , z ) : NEW_LINE INDENT type1 = x // COST NEW_LINE x %= COST NEW_LINE type2 = y // COST NEW_LINE y %= COST NEW_LINE type3 = z // COST NEW_LINE z %= COST NEW_LINE type4 = min ( x , min ( y , z ) ) NEW_LINE maxItems = type1 + type2 + type3 + type4 NEW_LINE return maxItems NEW_LINE DEDENT
def countFactors ( n , p ) : NEW_LINE INDENT pwr = 0 NEW_LINE while ( n > 0 and n % p == 0 ) : NEW_LINE INDENT n //= p NEW_LINE pwr += 1 NEW_LINE DEDENT return pwr NEW_LINE DEDENT
def getCount ( l , r , p ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT cnt += countFactors ( i , p ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def topsyTurvy ( string ) : NEW_LINE INDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == '2' or string [ i ] == '4' or string [ i ] == '5' or string [ i ] == '6' or string [ i ] == '7' or string [ i ] == '9' ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countSubSeq ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( 2 ** count - 1 ) NEW_LINE DEDENT
def countNum ( N , K ) : NEW_LINE INDENT sumPF = [ 0 ] * MAX NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( sumPF [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT sumPF [ j ] += i NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( sumPF [ i ] == K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def smallestPrime ( d ) : NEW_LINE INDENT l = 10 ** ( d - 1 ) NEW_LINE r = ( 10 ** d ) - 1 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def largestPrime ( d ) : NEW_LINE INDENT l = 10 ** ( d - 1 ) NEW_LINE r = ( 10 ** d ) - 1 NEW_LINE for i in range ( r , l , - 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findNumbers ( a , b ) : NEW_LINE INDENT __gcd = gcd ( a , b ) NEW_LINE print ( ( a // __gcd ) , ( b // __gcd ) ) NEW_LINE DEDENT
def possible ( n ) : NEW_LINE INDENT if ( n > 3 ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) ) // 2 NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findNthNumber ( A , B , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT sum = A + B NEW_LINE A = B NEW_LINE B = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT
def modulo ( num ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + int ( num [ i ] ) - 0 ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT
def findSum ( L , R ) : NEW_LINE INDENT a = modulo ( L ) NEW_LINE b = modulo ( R ) NEW_LINE l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod NEW_LINE r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod NEW_LINE ret = ( r % mod - l % mod ) NEW_LINE if ( ret < 0 ) : NEW_LINE INDENT ret = ret + mod NEW_LINE DEDENT else : NEW_LINE INDENT ret = ret % mod NEW_LINE DEDENT return ret NEW_LINE DEDENT
def heapSort ( arr , n ) : NEW_LINE INDENT for i in range ( int ( n / 2 ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT heapify ( arr , n , i ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT arr [ 0 ] , arr [ i ] = arr [ i ] , arr [ 0 ] NEW_LINE heapify ( arr , i , 0 ) NEW_LINE DEDENT DEDENT
def checkType ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] <= arr [ n - 1 ] ) : NEW_LINE INDENT print ( "Increasing" ) NEW_LINE DEDENT elif ( arr [ 0 ] >= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( "Decreasing" ) NEW_LINE DEDENT elif ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( "Increasing then decreasing" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Decreasing then increasing" ) NEW_LINE DEDENT DEDENT
def cal_IST ( h , r ) : NEW_LINE INDENT IST = round ( ( h * r * 1.0 ) / 360 , 3 ) NEW_LINE int_IST = int ( IST ) NEW_LINE float_IST = ceil ( ( IST - int_IST ) * 60 ) NEW_LINE print ( int_IST , ":" , float_IST ) NEW_LINE DEDENT
def isPossible ( arr , p , n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( p ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum == ( n * m ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def maxSubArraySum ( a , n , k , i ) : NEW_LINE INDENT max_so_far = - sys . maxsize NEW_LINE max_ending_here = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT i += k NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT
def find ( arr , n , k ) : NEW_LINE INDENT maxSum = 0 NEW_LINE for i in range ( 0 , min ( n , k ) + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE maxSum = max ( maxSum , maxSubArraySum ( arr , n , k , i ) ) NEW_LINE DEDENT return maxSum NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def solve ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 3 NEW_LINE while count < n : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
def sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def firstN ( n ) : NEW_LINE INDENT num = 19 NEW_LINE cnt = 1 NEW_LINE while ( cnt != n ) : NEW_LINE INDENT if ( sum ( num ) == 10 ) : NEW_LINE INDENT print ( num , end = " " ) NEW_LINE cnt += 1 NEW_LINE DEDENT num += 9 NEW_LINE DEDENT DEDENT
def compareVal ( x , y ) : NEW_LINE INDENT a = y * log ( x ) NEW_LINE b = x * log ( y ) NEW_LINE if ( a > b ) : NEW_LINE INDENT print ( x , "^" , y , ">" , y , "^" , x ) NEW_LINE DEDENT elif ( a < b ) : NEW_LINE INDENT print ( x , "^" , y , "<" , y , "^" , x ) NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT print ( x , "^" , y , "=" , y , "^" , x ) NEW_LINE DEDENT DEDENT
def countWays ( n ) : NEW_LINE INDENT return ( ( ( 2 ** n ) - 1 ) % MOD ) NEW_LINE DEDENT
def findIntegers ( n , a , x , t1 , t2 ) : NEW_LINE INDENT flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = pow ( a [ i ] , 2 ) + x NEW_LINE if ( temp % 10 != t1 and temp % 10 != t2 ) : NEW_LINE INDENT print ( temp , end = " " ) NEW_LINE flag = False NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def findMin ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE min = arr [ 0 ] NEW_LINE max = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT num = arr [ i ] NEW_LINE total = num + min NEW_LINE for j in range ( 2 , num + 1 ) : NEW_LINE INDENT if ( num % j == 0 ) : NEW_LINE INDENT d = j NEW_LINE now = ( num // d ) + ( min * d ) NEW_LINE reduce = total - now NEW_LINE if ( reduce > max ) : NEW_LINE INDENT max = reduce NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( sum - max ) NEW_LINE DEDENT
def Survives ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( True ) : NEW_LINE INDENT if ( i > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n -= n // i NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += n % TEN NEW_LINE n //= TEN NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getNthTerm ( n ) : NEW_LINE INDENT sum = digitSum ( n ) NEW_LINE if ( sum % TEN == 0 ) : NEW_LINE INDENT return ( n * TEN ) NEW_LINE DEDENT extra = TEN - ( sum % TEN ) NEW_LINE return ( ( n * TEN ) + extra ) NEW_LINE DEDENT
def firstNTerms ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( getNthTerm ( i ) , end = " " ) NEW_LINE DEDENT DEDENT
def nthXorFib ( n , a , b ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return b NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return a ^ b NEW_LINE DEDENT return nthXorFib ( n % 3 , a , b ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def flip ( a , b ) : NEW_LINE INDENT lcm = ( a * b ) // gcd ( a , b ) NEW_LINE a = lcm // a NEW_LINE b = lcm // b NEW_LINE print ( a - 1 , b - 1 ) NEW_LINE DEDENT
def findRemainder ( n ) : NEW_LINE INDENT l = n % 10 NEW_LINE while ( n >= 10 ) : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT f = n NEW_LINE remainder = f % l NEW_LINE print ( remainder ) NEW_LINE DEDENT
def increaseInVol ( l , b , h ) : NEW_LINE INDENT percentInc = ( ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ) NEW_LINE percentInc -= 1 NEW_LINE percentInc *= 100 NEW_LINE return percentInc NEW_LINE DEDENT
def countOccurrances ( n , d ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == d ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findFactors ( a , b ) : NEW_LINE INDENT c = a + b - 1 NEW_LINE print ( c ) NEW_LINE DEDENT
def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 for i in range ( K ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT rem = A [ i ] % K NEW_LINE ans += freq [ ( K - rem ) % K ] NEW_LINE freq [ rem ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def expressDigit ( arr , n ) : NEW_LINE INDENT min = 9 NEW_LINE index = 0 NEW_LINE temp = 0 NEW_LINE temp = arr [ 0 ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( arr [ i ] < min ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE index = i NEW_LINE DEDENT DEDENT if ( temp < min ) : NEW_LINE INDENT print ( 1 , end = "" ) NEW_LINE for i in range ( 1 , temp + 1 ) : NEW_LINE INDENT print ( 0 , end = "" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( min ) : NEW_LINE INDENT print ( index , end = "" ) NEW_LINE DEDENT print ( index ) NEW_LINE DEDENT DEDENT
def countDigits ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE num //= 10 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def sumFromStart ( num , n , rem ) : NEW_LINE INDENT num //= pow ( 10 , rem ) NEW_LINE sum = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT sum += ( num % 10 ) NEW_LINE num //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumFromEnd ( num , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( num % 10 ) NEW_LINE num //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getAverage ( n , k , l ) : NEW_LINE INDENT totalDigits = countDigits ( n ) NEW_LINE if ( totalDigits < ( k + l ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum1 = sumFromEnd ( n , l ) NEW_LINE sum2 = sumFromStart ( n , k , totalDigits - k ) NEW_LINE return ( sum1 + sum2 ) / ( k + l ) NEW_LINE DEDENT
def totalways ( arr , n ) : NEW_LINE INDENT cnt = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ arr [ i ] ] = cnt . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT start , endd = 0 , n - 1 NEW_LINE for i in range ( start , endd + 1 , 2 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( cnt [ i ] != 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( cnt [ i ] != 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT ways = 1 NEW_LINE start = 2 NEW_LINE endd = n - 1 NEW_LINE for i in range ( start , endd + 1 , 2 ) : NEW_LINE INDENT ways = ways * 2 NEW_LINE DEDENT return ways NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT start = 1 NEW_LINE endd = n - 1 NEW_LINE for i in range ( 1 , endd + 1 , 2 ) : NEW_LINE INDENT if ( cnt [ i ] != 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ways = 1 NEW_LINE for i in range ( start , endd + 1 , 2 ) : NEW_LINE INDENT ways = ways * 2 NEW_LINE DEDENT return ways NEW_LINE DEDENT DEDENT
def proizvolov ( a , b , n ) : NEW_LINE INDENT return n * n NEW_LINE DEDENT
def compareValues ( a , b , c , d ) : NEW_LINE INDENT log1 = math . log10 ( a ) NEW_LINE num1 = log1 * b NEW_LINE log2 = math . log10 ( c ) NEW_LINE num2 = log2 * d NEW_LINE if num1 > num2 : NEW_LINE INDENT print ( a , '^' , b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c , '^' , d ) NEW_LINE DEDENT DEDENT
def sum ( a , b , c , d , x ) : NEW_LINE INDENT ans = ( ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ) NEW_LINE return ans NEW_LINE DEDENT
def calculateLnx ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE num = ( n - 1 ) / ( n + 1 ) NEW_LINE for i in range ( 1 , 1001 , 1 ) : NEW_LINE INDENT mul = ( 2 * i ) - 1 NEW_LINE cal = pow ( num , mul ) NEW_LINE cal = cal / mul NEW_LINE sum = sum + cal NEW_LINE DEDENT sum = 2 * sum NEW_LINE return sum NEW_LINE DEDENT
def calculateLogx ( lnx ) : NEW_LINE INDENT return ( lnx / 2.303 ) NEW_LINE DEDENT
def printRoots ( a , b , c ) : NEW_LINE INDENT print ( 1 , "," , c / ( a * 1.0 ) ) NEW_LINE DEDENT
def permutation ( str1 , i , n , p ) : NEW_LINE INDENT global min1 , _count NEW_LINE if ( i == n ) : NEW_LINE INDENT str1 = "" . join ( str1 ) NEW_LINE q = int ( str1 ) NEW_LINE if ( q - p > 0 and q < min1 ) : NEW_LINE INDENT min1 = q NEW_LINE _count = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT str1 [ i ] , str1 [ j ] = str1 [ j ] , str1 [ i ] NEW_LINE permutation ( str1 , i + 1 , n , p ) NEW_LINE str1 [ i ] , str1 [ j ] = str1 [ j ] , str1 [ i ] NEW_LINE DEDENT DEDENT return min1 NEW_LINE DEDENT
def longestAlternativeSequence ( a , n ) : NEW_LINE INDENT maxi1 = 0 NEW_LINE f1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( f1 == 0 ) : NEW_LINE INDENT if ( a [ i ] % 2 ) : NEW_LINE INDENT f1 = 1 NEW_LINE maxi1 += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT maxi1 += 1 NEW_LINE f1 = 0 NEW_LINE DEDENT DEDENT DEDENT maxi2 = 0 NEW_LINE f2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( f2 ) : NEW_LINE INDENT if ( a [ i ] % 2 ) : NEW_LINE INDENT f2 = 1 NEW_LINE maxi2 += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT maxi2 += 1 NEW_LINE f2 = 0 NEW_LINE DEDENT DEDENT DEDENT return max ( maxi1 , maxi2 ) NEW_LINE DEDENT
def Cells ( n , x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x % i == 0 and x / i <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def Cells ( n , x ) : NEW_LINE INDENT if ( n <= 0 or x <= 0 or x > n * n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = 1 NEW_LINE count = 0 NEW_LINE while ( i * i < x ) : NEW_LINE INDENT if ( x % i == 0 and x <= n * i ) : NEW_LINE INDENT count += 2 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i * i == x ) : NEW_LINE INDENT return count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return count NEW_LINE DEDENT DEDENT
def ZigZag ( n ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE zig = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT zig [ 0 ] = 1 NEW_LINE zig [ 1 ] = 1 NEW_LINE print ( "zig zag numbers: " , end = " " ) NEW_LINE print ( zig [ 0 ] , zig [ 1 ] , end = " " ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 0 , i ) : NEW_LINE INDENT sum += ( ( fact [ i - 1 ] // ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ) NEW_LINE DEDENT zig [ i ] = sum // 2 NEW_LINE print ( sum // 2 , end = " " ) NEW_LINE DEDENT DEDENT
def evenNumSubstring ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , length , 1 ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def Depreciation ( v , r , t ) : NEW_LINE INDENT D = v * pow ( ( 1 - r / 100 ) , t ) NEW_LINE return D NEW_LINE DEDENT
def nextPowerOfFour ( n ) : NEW_LINE INDENT x = math . floor ( ( n ** ( 1 / 2 ) ) ** ( 1 / 2 ) ) NEW_LINE if ( ( x ** 4 ) == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT x = x + 1 NEW_LINE return ( x ** 4 ) NEW_LINE DEDENT DEDENT
def Alcuin ( n ) : NEW_LINE INDENT _n = n NEW_LINE ans = 0 NEW_LINE ans = ( round ( ( _n * _n ) / 12 ) - floor ( _n / 4 ) * floor ( ( _n + 2 ) / 4 ) ) NEW_LINE return ans NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( Alcuin ( i ) , end = ", " ) NEW_LINE DEDENT DEDENT
def find_count ( ele ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( ele ) ) : NEW_LINE INDENT p = [ ] NEW_LINE c = 0 NEW_LINE j = len ( ele ) - 1 NEW_LINE while j >= ( len ( ele ) - 1 - i ) and j >= 0 : NEW_LINE INDENT p . append ( ele [ j ] ) NEW_LINE j -= 1 NEW_LINE DEDENT j = len ( ele ) - 1 NEW_LINE k = 0 NEW_LINE while j >= 0 : NEW_LINE INDENT if ele [ j ] != p [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE if k == len ( p ) : NEW_LINE INDENT c += 1 NEW_LINE k = 0 NEW_LINE DEDENT DEDENT count = max ( count , c ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT count = 1 NEW_LINE ele = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( count , end = " " ) NEW_LINE ele . append ( count ) NEW_LINE count = find_count ( ele ) NEW_LINE DEDENT DEDENT
def speedOfTrain ( X , Y ) : NEW_LINE INDENT Speed = 0 NEW_LINE Speed = 1188 * ( ( X - Y ) / Y ) NEW_LINE return Speed NEW_LINE DEDENT
def Division ( a , n ) : NEW_LINE INDENT maxi = - 10 ** 9 NEW_LINE mini = 10 ** 9 NEW_LINE for i in a : NEW_LINE INDENT maxi = max ( i , maxi ) NEW_LINE mini = min ( i , mini ) NEW_LINE DEDENT return maxi // mini NEW_LINE DEDENT
def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def find_Sum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 NEW_LINE a = a // 10 NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE Sum = Sum + v [ i ] NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT
def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def pi ( x , v ) : NEW_LINE INDENT l , r = 0 , len ( v ) - 1 NEW_LINE m , i = 0 , - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if ( v [ m ] <= x ) : NEW_LINE INDENT i = m NEW_LINE l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return i + 1 NEW_LINE DEDENT
def Ramanujan ( n , v ) : NEW_LINE INDENT upperbound = ceil ( 4 * n * ( log ( 4 * n ) / log ( 2 ) ) ) NEW_LINE for i in range ( upperbound , - 1 , - 1 ) : NEW_LINE INDENT if ( pi ( i , v ) - pi ( i / 2 , v ) < n ) : NEW_LINE INDENT return 1 + i NEW_LINE DEDENT DEDENT DEDENT
def Ramanujan_Numbers ( n ) : NEW_LINE INDENT c = 1 NEW_LINE v = addPrimes ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( Ramanujan ( i , v ) , end = "" ) NEW_LINE if ( i != n ) : NEW_LINE INDENT print ( end = ", " ) NEW_LINE DEDENT DEDENT DEDENT
def solveEven ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( ( n // 2 ) ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left - 2 NEW_LINE if ( left < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT right = 0 NEW_LINE for i in range ( n // 2 , n , 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def solve ( n , arr ) : NEW_LINE INDENT b = [ 0 for i in range ( n ) ] NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT solveEven ( n , arr , b ) NEW_LINE DEDENT else : NEW_LINE INDENT solveOdd ( n , arr , b ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) // ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT
def NumberOfWays ( X , Y , M , N ) : NEW_LINE INDENT return fact ( X + Y ) * nCr ( M , X ) * nCr ( N , Y ) NEW_LINE DEDENT
def Wedderburn ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return store [ n ] NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT x = n // 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT ans += store [ i ] * store [ n - i ] NEW_LINE DEDENT ans += ( store [ x ] * ( store [ x ] + 1 ) ) // 2 NEW_LINE store [ n ] = ans NEW_LINE return ans NEW_LINE DEDENT else : NEW_LINE INDENT x = ( n + 1 ) // 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT ans += store [ i ] * store [ n - i ] NEW_LINE DEDENT store [ n ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT
def Wedderburn_Etherington ( n ) : NEW_LINE INDENT store [ 0 ] = 0 NEW_LINE store [ 1 ] = 1 NEW_LINE store [ 2 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( Wedderburn ( i ) , end = "" ) NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( end = ", " ) NEW_LINE DEDENT DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return ( factorial ( n ) / ( factorial ( n - r ) * factorial ( r ) ) ) NEW_LINE DEDENT
def NumberOfWays ( n , x , y ) : NEW_LINE INDENT return ( nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT i , fac = 1 , 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE DEDENT return fac NEW_LINE DEDENT
def log_Expansion ( x , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + pow ( x , 2 * i ) / fact ( 2 * i ) NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def prime_range ( start , end , a ) : NEW_LINE INDENT for i in range ( start , end ) : NEW_LINE INDENT if ( prime ( a [ i ] ) ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def countElements ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT mean = Sum / n NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT newMean = ( Sum - arr [ i ] ) / ( n - 1 ) NEW_LINE if ( newMean == mean ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def Prime ( n ) : NEW_LINE INDENT for j in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % j == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def find_prime ( x , xsqmodp , y , ysqmodp ) : NEW_LINE INDENT n = x * x - xsqmodp NEW_LINE n1 = y * y - ysqmodp NEW_LINE for j in range ( 2 , max ( int ( sqrt ( n ) ) , int ( sqrt ( n1 ) ) ) , 1 ) : NEW_LINE INDENT if ( n % j == 0 and ( x * x ) % j == xsqmodp and n1 % j == 0 and ( y * y ) % j == ysqmodp ) : NEW_LINE INDENT if ( Prime ( j ) ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT j1 = n // j NEW_LINE if ( n % j1 == 0 and ( x * x ) % j1 == xsqmodp and n1 % j1 == 0 and ( y * y ) % j1 == ysqmodp ) : NEW_LINE INDENT if ( Prime ( j1 ) ) : NEW_LINE INDENT return j1 NEW_LINE DEDENT DEDENT j1 = n1 // j NEW_LINE if ( n % j1 == 0 and ( x * x ) % j1 == xsqmodp and n1 % j1 == 0 and ( y * y ) % j1 == ysqmodp ) : NEW_LINE INDENT if ( Prime ( j1 ) ) : NEW_LINE INDENT return j1 NEW_LINE DEDENT DEDENT DEDENT if ( n == n1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT
def numberOfMinutes ( S , S1 ) : NEW_LINE INDENT Min = 0 NEW_LINE Min = ( ( S - S1 ) / math . floor ( S ) ) * 60 NEW_LINE return int ( Min ) NEW_LINE DEDENT
def FindElement ( a , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + a [ i ] NEW_LINE DEDENT if s % n == 0 : NEW_LINE INDENT m = s // n NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] == m : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def fac ( num ) : NEW_LINE INDENT if ( num == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT fact = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def Max_sum ( a , n ) : NEW_LINE INDENT pos = 0 NEW_LINE neg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > 0 ) : NEW_LINE INDENT pos = 1 NEW_LINE DEDENT elif ( a [ i ] < 0 ) : NEW_LINE INDENT neg = 1 NEW_LINE DEDENT if ( pos == 1 and neg == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE if ( pos == 1 and neg == 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sum += abs ( a [ i ] ) NEW_LINE DEDENT DEDENT elif ( pos == 1 ) : NEW_LINE INDENT mini = a [ 0 ] NEW_LINE sum = a [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT mini = min ( mini , a [ i ] ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT sum -= 2 * mini NEW_LINE DEDENT elif ( neg == 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT mini = a [ 0 ] NEW_LINE sum = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT mini = min ( mini , a [ i ] ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT sum -= 2 * mini NEW_LINE DEDENT return sum NEW_LINE DEDENT
def checkcomposite ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def power ( x , y , mod ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % mod NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT
def Check ( n , a ) : NEW_LINE INDENT if ( a > 1 and checkcomposite ( n ) and power ( a , n - 1 , n ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def count ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE cnt = 0 NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return ( factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ) NEW_LINE DEDENT
def Probability ( M , N , X ) : NEW_LINE INDENT return float ( nCr ( M - N - 1 , X - 2 ) / ( nCr ( M - 1 , X - 1 ) * 1.0 ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def Count_number ( N ) : NEW_LINE INDENT return ( N * fact ( N ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT
def nPr ( n , r ) : NEW_LINE INDENT return fact ( n ) // fact ( n - r ) NEW_LINE DEDENT
def decimalToBinary ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT print ( "0" , end = "" ) NEW_LINE return NEW_LINE DEDENT decimalToBinary ( n // 2 ) NEW_LINE print ( n % 2 , end = "" ) NEW_LINE DEDENT
def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT
def getHeight ( X ) : NEW_LINE INDENT return ( 2 * X ) NEW_LINE DEDENT
def volumeRec ( a , b , e , h ) : NEW_LINE INDENT return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) NEW_LINE DEDENT
def firstSetBit ( n ) : NEW_LINE INDENT x = n & ( n - 1 ) NEW_LINE return ( n ^ x ) NEW_LINE DEDENT
def NoofSequences ( N , M ) : NEW_LINE INDENT prime = { } NEW_LINE for i in range ( 2 , int ( M ** ( .5 ) ) + 1 ) : NEW_LINE INDENT while ( M % i == 0 ) : NEW_LINE INDENT prime [ i ] = prime . get ( i , 0 ) + 1 NEW_LINE M //= i NEW_LINE DEDENT DEDENT if ( M > 1 ) : NEW_LINE INDENT prime [ M ] = prime . get ( M , 0 ) + 1 NEW_LINE DEDENT ans = 1 NEW_LINE for it in prime : NEW_LINE INDENT ans *= ( ncr ( N + prime [ it ] - 1 , N - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findHours ( a , b , k ) : NEW_LINE INDENT if ( a >= b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT time = k // ( b - a ) NEW_LINE time = time + 1 NEW_LINE return time NEW_LINE DEDENT
def countQuadruples ( N , K ) : NEW_LINE INDENT M = N // K NEW_LINE answer = nCr ( M ) NEW_LINE for i in range ( 2 , M ) : NEW_LINE INDENT j = i NEW_LINE temp2 = M // i NEW_LINE count = 0 NEW_LINE check = 0 NEW_LINE temp = j NEW_LINE while ( j % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE j //= 2 NEW_LINE if ( count >= 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT check = 1 NEW_LINE DEDENT for k in range ( 3 , int ( sqrt ( temp ) ) , 2 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( j % k == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE j //= k NEW_LINE if ( cnt >= 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( cnt >= 2 ) : NEW_LINE INDENT check = 1 NEW_LINE break NEW_LINE DEDENT elif ( cnt == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( j > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( check ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( count % 2 == 1 ) : NEW_LINE INDENT answer -= nCr ( temp2 ) NEW_LINE DEDENT else : NEW_LINE INDENT answer += nCr ( temp2 ) NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT
def minimum_sum ( n , k ) : NEW_LINE INDENT if ( k % n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def ncr ( n , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans *= ( n - r + i ) NEW_LINE ans //= i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def NoOfDistributions ( N , R ) : NEW_LINE INDENT return ncr ( N - 1 , R - 1 ) NEW_LINE DEDENT
def ncr ( n , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans *= ( n - r + i ) NEW_LINE ans //= i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def NoOfDistributions ( N , R ) : NEW_LINE INDENT return ncr ( N + R - 1 , R - 1 ) NEW_LINE DEDENT
def maxElement ( a , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT maxElement = a [ 0 ] NEW_LINE maxProd = a [ n - 1 ] * a [ 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currprod = a [ i - 1 ] * a [ ( i + 1 ) % n ] NEW_LINE if currprod > maxProd : NEW_LINE INDENT maxProd = currprod NEW_LINE maxElement = a [ i ] NEW_LINE DEDENT elif currprod == maxProd : NEW_LINE INDENT maxElement = max ( maxElement , a [ i ] ) NEW_LINE DEDENT DEDENT return maxElement NEW_LINE DEDENT
def totalWays ( X , Y , M , W ) : NEW_LINE INDENT return ( ncr ( M , X ) * ncr ( W , Y ) ) NEW_LINE DEDENT
def checkPerfectcube ( n ) : NEW_LINE INDENT d = int ( n ** ( 1 / 3 ) ) NEW_LINE if ( d * d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def smallestPerfectCube ( a , n ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkPerfectcube ( a [ i ] ) ) : NEW_LINE INDENT mini = min ( a [ i ] , mini ) NEW_LINE DEDENT DEDENT return mini NEW_LINE DEDENT
def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) NEW_LINE if x < 0 : NEW_LINE INDENT x = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = 1 NEW_LINE DEDENT print ( val * x , "0" , end = " " ) NEW_LINE if y < 0 : NEW_LINE INDENT y = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = 1 NEW_LINE DEDENT print ( "0" , val * y ) NEW_LINE DEDENT
def SumofInverseDivisors ( N , Sum ) : NEW_LINE INDENT ans = float ( Sum ) * 1.0 / float ( N ) NEW_LINE return round ( ans , 2 ) NEW_LINE DEDENT
def CheckSubarray ( arr , N ) : NEW_LINE INDENT presum = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( i , N + 1 ) : NEW_LINE INDENT if ( ( presum [ j ] - presum [ i - 1 ] ) % N == 0 ) : NEW_LINE INDENT print ( i - 1 , j - 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( "-1" ) NEW_LINE DEDENT
def CheckSubarray ( arr , N ) : NEW_LINE INDENT presum = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT moduloclass = [ [ ] ] * N NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT moduloclass [ presum [ i ] % N ] . append ( i - 1 ) NEW_LINE DEDENT if ( len ( moduloclass [ 0 ] ) > 0 ) : NEW_LINE INDENT print ( 0 + 1 , moduloclass [ 0 ] [ 0 ] + 2 ) NEW_LINE return NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( len ( moduloclass [ i ] ) >= 2 ) : NEW_LINE INDENT print ( moduloclass [ i ] [ 0 ] + 1 , moduloclass [ i ] [ 1 ] ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT
def findNearestNumber ( n ) : NEW_LINE INDENT cnt = countBits ( n ) NEW_LINE cnt -= 1 NEW_LINE if ( cnt % 2 ) : NEW_LINE INDENT return 1 << ( cnt + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT tempnum = 0 NEW_LINE for i in range ( 0 , cnt + 1 , 2 ) : NEW_LINE INDENT tempnum += 1 << i NEW_LINE DEDENT if ( tempnum < n ) : NEW_LINE INDENT return ( 1 << ( cnt + 2 ) ) NEW_LINE DEDENT elif ( tempnum == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT for i in range ( 0 , cnt + 1 , 2 ) : NEW_LINE INDENT tempnum -= ( 1 << i ) NEW_LINE if ( tempnum < n ) : NEW_LINE INDENT tempnum += ( 1 << i ) NEW_LINE return tempnum NEW_LINE DEDENT DEDENT DEDENT DEDENT
def getX ( a , b , c , d ) : NEW_LINE INDENT X = ( b * c - a * d ) // ( d - c ) NEW_LINE return X NEW_LINE DEDENT
def NoofTriplets ( N , K ) : NEW_LINE INDENT cnt = [ 0 ] * K NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT cnt [ i % K ] += 1 NEW_LINE DEDENT if ( K & 1 ) : NEW_LINE INDENT rslt = cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] NEW_LINE return rslt NEW_LINE DEDENT else : NEW_LINE INDENT rslt = ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K // 2 ] * cnt [ K // 2 ] * cnt [ K // 2 ] ) NEW_LINE return rslt NEW_LINE DEDENT DEDENT
def countNum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT count = pow ( 2 , n - 2 ) NEW_LINE return count NEW_LINE DEDENT
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE Len = len ( num ) NEW_LINE for i in range ( Len - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base NEW_LINE DEDENT base = base * 2 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT
def findNumber ( n ) : NEW_LINE INDENT s = constructString ( n - 1 ) NEW_LINE num = binaryToDecimal ( s ) NEW_LINE return num NEW_LINE DEDENT
def findNumber ( n ) : NEW_LINE INDENT num = n - 1 NEW_LINE num = 2 * ( 4 ** num ) NEW_LINE num = num // 3 NEW_LINE return num NEW_LINE DEDENT
def bitonic_point ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( node . next == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( node . data > node . next . data ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT while ( node . next != None ) : NEW_LINE INDENT if ( node . data > node . next . data ) : NEW_LINE INDENT break NEW_LINE DEDENT node = node . next NEW_LINE DEDENT bitonicPoint = node . data NEW_LINE while ( node . next != None ) : NEW_LINE INDENT if ( node . data < node . next . data ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT node = node . next NEW_LINE DEDENT return bitonicPoint NEW_LINE DEDENT
def minSum ( a , n ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE num1 , num2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT num1 = num1 * 10 + a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT num2 = num2 * 10 + a [ i ] NEW_LINE DEDENT DEDENT return num2 + num1 NEW_LINE DEDENT
def canConvert ( a , b ) : NEW_LINE INDENT while ( b > a ) : NEW_LINE INDENT if ( b % 10 == 1 ) : NEW_LINE INDENT b //= 10 NEW_LINE continue NEW_LINE DEDENT if ( b % 2 == 0 ) : NEW_LINE INDENT b /= 2 NEW_LINE continue NEW_LINE DEDENT return false NEW_LINE DEDENT if ( b == a ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def MinRemove ( a , n , k ) : NEW_LINE INDENT cnt = [ 0 ] * k NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT cnt [ 0 ] += 1 NEW_LINE DEDENT elif ( cnt [ a [ i ] - 1 ] > 0 ) : NEW_LINE INDENT cnt [ a [ i ] - 1 ] -= 1 NEW_LINE cnt [ a [ i ] ] += 1 NEW_LINE DEDENT DEDENT return n - ( k * cnt [ k - 1 ] ) NEW_LINE DEDENT
def mosaic ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 and n > 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE count += 1 NEW_LINE DEDENT ans *= count * i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def nMosaicNumbers ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print mosaic ( i ) , NEW_LINE DEDENT DEDENT
def mosaic ( n ) : NEW_LINE INDENT i = 0 NEW_LINE ans = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 and n > 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n //= i NEW_LINE count += 1 NEW_LINE DEDENT ans *= count * i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def lowerWythoff ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = floor ( i * phi ) NEW_LINE print ( ans , end = "" ) NEW_LINE if ( i != n ) : NEW_LINE INDENT print ( ", " , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def Total_Ways ( n ) : NEW_LINE INDENT fac = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT fac = fac * i NEW_LINE DEDENT return ( fac * 2 ) NEW_LINE DEDENT
def MaxNumbers ( a , n ) : NEW_LINE INDENT fre = [ 0 for i in range ( 3 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] %= 3 NEW_LINE fre [ a [ i ] ] += 1 NEW_LINE DEDENT ans = fre [ 0 ] NEW_LINE k = min ( fre [ 1 ] , fre [ 2 ] ) NEW_LINE ans += k NEW_LINE fre [ 1 ] -= k NEW_LINE fre [ 2 ] -= k NEW_LINE ans += fre [ 1 ] // 3 + fre [ 2 ] // 3 NEW_LINE return ans NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = countSetBits ( arr [ i ] ) + countSetBits ( arr [ j ] ) NEW_LINE if ( sum == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE f = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT f [ countSetBits ( arr [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT for j in range ( 1 , MAX + 1 ) : NEW_LINE INDENT if ( i + j == k ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT count += ( ( f [ i ] * ( f [ i ] - 1 ) ) / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( f [ i ] * f [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def composite_factors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE a = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT a [ i ] = i NEW_LINE DEDENT DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT j = 2 NEW_LINE p = 1 NEW_LINE while ( j < a [ i ] ) : NEW_LINE INDENT if ( a [ i ] % j == 0 ) : NEW_LINE INDENT p = 0 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( p == 0 and a [ i ] != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def count ( N ) : NEW_LINE INDENT a = 0 NEW_LINE a = ( N * ( N + 1 ) ) / 2 NEW_LINE return int ( a ) NEW_LINE DEDENT
def specialSieve ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE prime = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE for j in range ( i , n + 1 , i ) : NEW_LINE INDENT prime [ j ] = cnt NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( prime [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def sumOfMersenne ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 and isMersenne ( arr [ i ] ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def sumOfFactors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for f in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT if ( n % f == 0 ) : NEW_LINE INDENT sum += f NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def sameLength ( A , B ) : NEW_LINE INDENT while ( A > 0 and B > 0 ) : NEW_LINE INDENT A = A / 10 NEW_LINE B = B / 10 NEW_LINE DEDENT if ( A == 0 and B == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def preProcess ( arr , n ) : NEW_LINE INDENT global cnt_neg NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT cnt_neg += 1 NEW_LINE DEDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT exists_zero = True NEW_LINE DEDENT DEDENT DEDENT
def FindXorSum ( arr , k , n ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x = [ 0 ] * n NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT x [ i ] = x [ i - 1 ] ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT x [ i ] = arr [ i ] NEW_LINE DEDENT if ( i >= k - 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = x [ i ] NEW_LINE if ( i - k > - 1 ) : NEW_LINE INDENT sum ^= x [ i - k ] NEW_LINE DEDENT result += sum NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def reverse ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE rev = rev * 10 + d NEW_LINE n = n // 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT
def isPalin ( n ) : NEW_LINE INDENT return ( n == reverse ( n ) ) NEW_LINE DEDENT
def countDigits ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n // 10 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
def countPalinDigits ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 10 or isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += countDigits ( arr [ i ] ) NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def reverse ( n ) : NEW_LINE INDENT d = 0 NEW_LINE s = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE s = s * 10 + d NEW_LINE n = n // 10 NEW_LINE DEDENT return s NEW_LINE DEDENT
def isPalin ( n ) : NEW_LINE INDENT return n == reverse ( n ) NEW_LINE DEDENT
def sumOfArray ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] > 10 ) and isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def isVowel ( ch ) : NEW_LINE INDENT if ( ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def fact ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT
def only_vowels ( freq ) : NEW_LINE INDENT denom = 1 NEW_LINE cnt_vwl = 0 NEW_LINE for itr in freq : NEW_LINE INDENT if ( isVowel ( itr ) ) : NEW_LINE INDENT denom *= fact ( freq [ itr ] ) NEW_LINE cnt_vwl += freq [ itr ] NEW_LINE DEDENT DEDENT return fact ( cnt_vwl ) // denom NEW_LINE DEDENT
def all_vowels_together ( freq ) : NEW_LINE INDENT vow = only_vowels ( freq ) NEW_LINE denom = 1 NEW_LINE cnt_cnst = 0 NEW_LINE for itr in freq : NEW_LINE INDENT if ( isVowel ( itr ) == False ) : NEW_LINE INDENT denom *= fact ( freq [ itr ] ) NEW_LINE cnt_cnst += freq [ itr ] NEW_LINE DEDENT DEDENT ans = fact ( cnt_cnst + 1 ) // denom NEW_LINE return ( ans * vow ) NEW_LINE DEDENT
def no_vowels_together ( word ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in word : NEW_LINE INDENT ch = i . lower ( ) NEW_LINE freq [ ch ] = freq . get ( ch , 0 ) + 1 NEW_LINE DEDENT total = total_permutations ( freq ) NEW_LINE vwl_tgthr = all_vowels_together ( freq ) NEW_LINE res = total - vwl_tgthr NEW_LINE return res NEW_LINE DEDENT
def updatePrimes ( ) : NEW_LINE INDENT for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT prime [ i ] = 1 NEW_LINE DEDENT prime [ 0 ] = prime [ 1 ] = 0 NEW_LINE for i in range ( 2 , int ( sqrt ( MAX ) + 1 ) ) : NEW_LINE INDENT if ( prime [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT prime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT prime [ i ] += prime [ i - 1 ] NEW_LINE DEDENT DEDENT
def getDifference ( l , r ) : NEW_LINE INDENT total = r - l + 1 NEW_LINE primes = prime [ r ] - prime [ l - 1 ] NEW_LINE composites = total - primes NEW_LINE return ( abs ( primes - composites ) ) NEW_LINE DEDENT
def e ( x , n ) : NEW_LINE INDENT global p , f NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT r = e ( x , n - 1 ) NEW_LINE p = p * x NEW_LINE f = f * n NEW_LINE return ( r + p / f ) NEW_LINE DEDENT
def constructSieve ( ) : NEW_LINE INDENT for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( Sieve [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , MAX + 1 , i ) : NEW_LINE INDENT temp = j NEW_LINE while ( temp > 1 and temp % i == 0 ) : NEW_LINE INDENT Sieve [ j ] += 1 NEW_LINE temp = temp // i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def checkElements ( A , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( Sieve [ A [ i ] ] == k ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT DEDENT
def modularexpo ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def multiply ( F , M , m ) : NEW_LINE INDENT x = ( ( F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] ) % m + ( F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ) % m ) % m NEW_LINE y = ( ( F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] ) % m + ( F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ) % m ) % m NEW_LINE z = ( ( F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] ) % m + ( F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ) % m ) % m NEW_LINE w = ( ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] ) % m + ( F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) % m ) % m NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE DEDENT
def power ( F , n , m ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE power ( F , n // 2 , m ) NEW_LINE multiply ( F , F , m ) NEW_LINE if ( n % 2 != 0 ) : NEW_LINE INDENT multiply ( F , M , m ) NEW_LINE DEDENT DEDENT
def fib ( n , m ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 , m ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT
def cntWays ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT tot_sum = 0 NEW_LINE sum = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tot_sum += arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( sum == tot_sum / 2 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def power_2 ( ) : NEW_LINE INDENT an = 1 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT pow2 [ i ] = an NEW_LINE an *= 2 NEW_LINE DEDENT DEDENT
def countSetBits ( x ) : NEW_LINE INDENT setBits = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x & ( x - 1 ) NEW_LINE setBits += 1 NEW_LINE DEDENT return setBits NEW_LINE DEDENT
def add ( num ) : NEW_LINE INDENT point = 0 NEW_LINE value = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( visited [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT value += ( 1 << i ) NEW_LINE DEDENT num = num // 2 NEW_LINE DEDENT DEDENT ans . append ( value ) NEW_LINE DEDENT
def solve ( n , k ) : NEW_LINE INDENT ans . append ( k ) NEW_LINE countk = countSetBits ( k ) NEW_LINE if ( pow2 [ countk ] < n ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( pow2 [ countk ] - 1 ) : NEW_LINE INDENT add ( i ) NEW_LINE count += 1 NEW_LINE if ( count == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def numberOfMen ( D , m , d ) : NEW_LINE INDENT Men = ( m * ( D - d ) ) / d NEW_LINE return int ( Men ) NEW_LINE DEDENT
def sumPowersK ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE num = 1 NEW_LINE while ( num <= n ) : NEW_LINE INDENT sum += num NEW_LINE num *= k NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getSum ( n , k ) : NEW_LINE INDENT pwrK = sumPowersK ( n , k ) NEW_LINE sumAll = ( n * ( n + 1 ) ) / 2 NEW_LINE return ( sumAll - pwrK ) NEW_LINE DEDENT
def maxPeople ( p ) : NEW_LINE INDENT tmp = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( p ) ) + 1 ) : NEW_LINE INDENT tmp = tmp + ( i * i ) NEW_LINE if ( tmp <= p ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maxPeople ( p ) : NEW_LINE INDENT sums = [ 0 ] * kN NEW_LINE sums [ 0 ] = 0 NEW_LINE for i in range ( 1 , kN ) : NEW_LINE INDENT sums [ i ] = ( i * i ) + sums [ i - 1 ] NEW_LINE DEDENT it = lower_bound ( sums , 0 , kN , p ) NEW_LINE if ( it > p ) : NEW_LINE INDENT it -= 1 NEW_LINE DEDENT return it NEW_LINE DEDENT
def squareSeries ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) // 6 NEW_LINE DEDENT
def maxPeople ( n ) : NEW_LINE INDENT low = 0 NEW_LINE high = 1000000000000000 NEW_LINE while low <= high : NEW_LINE INDENT mid = low + ( ( high - low ) // 2 ) NEW_LINE value = squareSeries ( mid ) NEW_LINE if value <= n : NEW_LINE INDENT ans = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def getAverage ( x , y ) : NEW_LINE INDENT avg = ( x & y ) + ( ( x ^ y ) >> 1 ) NEW_LINE return avg NEW_LINE DEDENT
def getfactor ( n , p ) : NEW_LINE INDENT pw = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n //= p NEW_LINE pw += n NEW_LINE DEDENT return pw NEW_LINE DEDENT
def isDivisible ( n , r , p ) : NEW_LINE INDENT x1 = getfactor ( n , p ) NEW_LINE x2 = getfactor ( r , p ) NEW_LINE x3 = getfactor ( n - r , p ) NEW_LINE if ( x1 > x2 + x3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findIndex ( a , n , k ) : NEW_LINE INDENT index = - 1 NEW_LINE max_ceil = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] + k - 1 ) // k NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= max_ceil ) : NEW_LINE INDENT max_ceil = a [ i ] NEW_LINE index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def Count_Segment ( p , n ) : NEW_LINE INDENT count = 0 NEW_LINE upto = [ False ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if p [ i ] > p [ i - 1 ] and p [ i ] > p [ i + 1 ] : NEW_LINE INDENT curr = p [ i ] NEW_LINE j = i - 1 NEW_LINE while j >= 0 and p [ j ] < curr : NEW_LINE INDENT upto [ p [ j ] ] = curr NEW_LINE j -= 1 NEW_LINE DEDENT j = i + 1 NEW_LINE while j < n and p [ j ] < curr : NEW_LINE INDENT if upto [ curr - p [ j ] ] == curr : NEW_LINE INDENT count += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def dfs ( node , parent ) : NEW_LINE INDENT global x , ans , graph , weight , maximum NEW_LINE a = bin ( weight [ node ] + x ) . count ( '1' ) NEW_LINE if maximum < a : NEW_LINE INDENT maximum = a NEW_LINE ans = node NEW_LINE DEDENT elif maximum == a : NEW_LINE INDENT ans = min ( ans , node ) NEW_LINE DEDENT for to in graph [ node ] : NEW_LINE INDENT if to == parent : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( to , node ) NEW_LINE DEDENT DEDENT
def solve ( n , k ) : NEW_LINE INDENT if ( n >= ( k * ( k + 1 ) ) // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def solve ( a , b ) : NEW_LINE INDENT if ( a > 0 and b > 0 ) : NEW_LINE INDENT print ( "Positive" ) NEW_LINE DEDENT elif ( a <= 0 and b >= 0 ) : NEW_LINE INDENT print ( "Zero" ) NEW_LINE DEDENT else : NEW_LINE INDENT n = abs ( a - b ) + 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT print ( "Positive" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Negative" ) NEW_LINE DEDENT DEDENT DEDENT
def isEven ( arr , n , r ) : NEW_LINE INDENT if ( r % 2 == 0 ) : NEW_LINE INDENT if ( arr [ n - 1 ] % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT oddCount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT oddCount += 1 NEW_LINE DEDENT DEDENT if ( oddCount % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def closetAND ( arr , n , k ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT X = arr [ i ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT X &= arr [ j ] NEW_LINE ans = min ( ans , abs ( k - X ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countQuadruplets ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for u in range ( l , r + 1 , 1 ) : NEW_LINE INDENT for v in range ( l , r + 1 , 1 ) : NEW_LINE INDENT for w in range ( l , r + 1 , 1 ) : NEW_LINE INDENT for x in range ( l , r + 1 , 1 ) : NEW_LINE INDENT if ( gcd ( gcd ( u , v ) , gcd ( w , x ) ) == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def count_square ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT k = n - i + 1 NEW_LINE count += ( k * k ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def Rate ( N1 , N2 ) : NEW_LINE INDENT rate = ( N2 - N1 ) * 100 // ( N1 ) NEW_LINE return rate NEW_LINE DEDENT
def solve ( a , n ) : NEW_LINE INDENT ones , twos = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT else : NEW_LINE INDENT twos += 1 NEW_LINE DEDENT DEDENT ind = 0 NEW_LINE if ( twos ) : NEW_LINE INDENT a [ ind ] = 2 NEW_LINE ind += 1 NEW_LINE DEDENT if ones % 2 == 0 : NEW_LINE INDENT evenOnes = True NEW_LINE DEDENT else : NEW_LINE INDENT evenOnes = False NEW_LINE DEDENT if ( evenOnes ) : NEW_LINE INDENT ones -= 1 NEW_LINE DEDENT for i in range ( ones ) : NEW_LINE INDENT a [ ind ] = 1 NEW_LINE ind += 1 NEW_LINE DEDENT for i in range ( twos - 1 ) : NEW_LINE INDENT a [ ind ] = 2 NEW_LINE ind += 1 NEW_LINE DEDENT if ( evenOnes ) : NEW_LINE INDENT a [ ind ] = 1 NEW_LINE ind += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even1 = 0 NEW_LINE odd2 = 0 NEW_LINE even2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] % 2 == 1 ) : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , odd2 ) + min ( even1 , even2 ) NEW_LINE return pairs NEW_LINE DEDENT
def primeCount ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def getPrefixArray ( arr , n , pre ) : NEW_LINE INDENT pre [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT
def getPrime ( arr , n ) : NEW_LINE INDENT max_val = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > max_val ) : NEW_LINE INDENT max_val = arr [ i ] NEW_LINE DEDENT DEDENT prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( max_val ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT maximum = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT
def CreateArray ( N , even , odd ) : NEW_LINE INDENT temp = - 1 NEW_LINE for i in range ( N + 2 ) : NEW_LINE INDENT if ( i * ( ( N + 1 ) - i ) == odd ) : NEW_LINE INDENT temp = 0 NEW_LINE OddPreSums = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( temp == - 1 ) : NEW_LINE INDENT print ( temp ) NEW_LINE DEDENT else : NEW_LINE INDENT EvenPreSums = ( N + 1 ) - OddPreSums NEW_LINE e = 1 NEW_LINE o = 0 NEW_LINE CurrSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( CurrSum % 2 == 0 ) : NEW_LINE INDENT if ( e < EvenPreSums ) : NEW_LINE INDENT e += 1 NEW_LINE print ( "0 " , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT o += 1 NEW_LINE print ( "1 " , end = "" ) NEW_LINE CurrSum += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( e < EvenPreSums ) : NEW_LINE INDENT e += 1 NEW_LINE print ( "1 " ) NEW_LINE CurrSum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT o += 1 NEW_LINE print ( "0 " , end = "" ) NEW_LINE DEDENT DEDENT DEDENT print ( "" ,   end   =   "" ) NEW_LINE DEDENT DEDENT
def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE minOperations = sys . maxsize NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != num : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT
def getMinNum ( N ) : NEW_LINE INDENT lcm = 1 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT lcm = ( ( i * lcm ) // ( gcd ( i , lcm ) ) ) NEW_LINE DEDENT return ( lcm + 1 ) NEW_LINE DEDENT
def maxEdges ( N ) : NEW_LINE INDENT edges = 0 NEW_LINE edges = ( N * N ) // 4 NEW_LINE return edges NEW_LINE DEDENT
def findX ( A , B ) : NEW_LINE INDENT j = 0 NEW_LINE x = 0 NEW_LINE while ( A or B ) : NEW_LINE INDENT if ( ( A & 1 ) and ( B & 1 ) ) : NEW_LINE INDENT x += ( 1 << j ) NEW_LINE DEDENT A >>= 1 NEW_LINE B >>= 1 NEW_LINE j += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
def findX ( A , B ) : NEW_LINE INDENT return A & B NEW_LINE DEDENT
def findSum ( A , B ) : NEW_LINE INDENT return A ^ B NEW_LINE DEDENT
def isSumEqual ( ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sum += ar [ i ] NEW_LINE DEDENT if ( sum == ar [ n - 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findIndex ( a , n ) : NEW_LINE INDENT res , min_diff = None , float ( 'inf' ) NEW_LINE prod = [ None ] * n NEW_LINE prod [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prod [ i ] = prod [ i - 1 ] * a [ i ] NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT curr_diff = abs ( ( prod [ n - 1 ] // prod [ i ] ) - prod [ i ] ) NEW_LINE if curr_diff < min_diff : NEW_LINE INDENT min_diff = curr_diff NEW_LINE res = i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def Permutation ( n , k ) : NEW_LINE INDENT p = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n - k ) : NEW_LINE INDENT p [ i + 1 ] = i NEW_LINE DEDENT p [ 1 ] = n - k NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( p [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def perfectSquares ( a , b ) : NEW_LINE INDENT return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ) NEW_LINE DEDENT
def countOnes ( arr , n ) : NEW_LINE INDENT return perfectSquares ( 1 , n ) NEW_LINE DEDENT
def validPosition ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def count_unique ( s , n ) : NEW_LINE INDENT if ( s . count ( n ) ) : NEW_LINE INDENT return NEW_LINE DEDENT s . append ( n ) NEW_LINE n += 1 NEW_LINE while ( n % 10 == 0 ) : NEW_LINE INDENT n = n // 10 NEW_LINE DEDENT count_unique ( s , n ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT size = ( 2 * N ) + 1 NEW_LINE freq = [ 0 for i in range ( size ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x + N ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT ans += int ( ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ) NEW_LINE for j in range ( i + 2 , 2001 , 2 ) : NEW_LINE INDENT if ( freq [ j ] > 0 and ( freq [ int ( ( i + j ) / 2 ) ] > 0 ) ) : NEW_LINE INDENT ans += ( freq [ i ] * freq [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def smallestSum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 2 * pow ( 10 , n - 1 ) ) NEW_LINE DEDENT
def largestSum ( n ) : NEW_LINE INDENT return ( 2 * ( pow ( 10 , n ) - 1 ) ) NEW_LINE DEDENT
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even1 = 0 NEW_LINE odd2 = 0 NEW_LINE even2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] % 2 ) : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = ( min ( odd1 , even2 ) + min ( odd2 , even1 ) ) NEW_LINE return pairs NEW_LINE DEDENT
def find_leftmost_unsetbit ( n ) : NEW_LINE INDENT ind = - 1 NEW_LINE i = 1 NEW_LINE while ( n ) : NEW_LINE INDENT if ( ( n % 2 ) != 1 ) : NEW_LINE INDENT ind = i NEW_LINE DEDENT i += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return ind NEW_LINE DEDENT
def vertices ( N , A , B ) : NEW_LINE INDENT position = 0 NEW_LINE miniSum = 10 ** 9 NEW_LINE Sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i == A or i == B ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT x = abs ( i - A ) NEW_LINE y = abs ( i - B ) NEW_LINE Sum = x + y NEW_LINE if ( Sum < miniSum ) : NEW_LINE INDENT miniSum = Sum NEW_LINE position = i NEW_LINE DEDENT DEDENT DEDENT return position NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT f = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT f *= i NEW_LINE DEDENT return f NEW_LINE DEDENT
def sumFactorial ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s += factorial ( arr [ i ] ) NEW_LINE DEDENT return s NEW_LINE DEDENT
def dfs ( child , par , color ) : NEW_LINE INDENT global ans NEW_LINE if ( color [ child ] != color [ par ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT for it in gr [ child ] : NEW_LINE INDENT if ( it == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( it , child , color ) NEW_LINE DEDENT DEDENT
def highestPower ( str , length ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def modInverse ( n , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT
def nCrModP ( n , r , p ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT fac = [ 0 for i in range ( n + 1 ) ] NEW_LINE fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p NEW_LINE DEDENT
def countArrangements ( n , k , p ) : NEW_LINE INDENT return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p NEW_LINE DEDENT
def maxProd ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N < 10 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( maxProd ( N // 10 ) * ( N % 10 ) , maxProd ( N // 10 - 1 ) * 9 ) NEW_LINE DEDENT
def primeFactors ( n , freq ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE n = int ( n // 2 ) NEW_LINE DEDENT freq [ 2 ] = cnt NEW_LINE i = 3 NEW_LINE while i <= math . sqrt ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE n = int ( n // i ) NEW_LINE DEDENT freq [ int ( i ) ] = cnt NEW_LINE i = i + 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT freq [ int ( n ) ] = 1 NEW_LINE DEDENT DEDENT
def getMaximumPower ( n , m ) : NEW_LINE INDENT freq1 = [ 0 ] * ( n + 1 ) NEW_LINE freq2 = [ 0 ] * ( m + 1 ) NEW_LINE primeFactors ( n , freq1 ) NEW_LINE primeFactors ( m , freq2 ) NEW_LINE maxi = 0 NEW_LINE i = 2 NEW_LINE while i <= m : NEW_LINE INDENT if ( freq1 [ i ] == 0 and freq2 [ i ] == 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT if ( freq2 [ i ] > freq1 [ i ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( freq2 [ i ] ) : NEW_LINE INDENT maxi = max ( maxi , int ( freq1 [ i ] // freq2 [ i ] ) ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return maxi NEW_LINE DEDENT
def check ( mat ) : NEW_LINE INDENT xorr = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT xorr ^= mat [ i ] [ 0 ] NEW_LINE DEDENT if ( xorr != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , M ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ i ] [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def sumodd ( n ) : NEW_LINE INDENT return ( n * n ) NEW_LINE DEDENT
def sumeven ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) NEW_LINE DEDENT
def radiated_Station ( station , n ) : NEW_LINE INDENT rStation = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT li = i - 1 NEW_LINE ri = i + 1 NEW_LINE lRad = station [ i ] - 1 NEW_LINE rRad = station [ i ] - 1 NEW_LINE rStation [ i ] += station [ i ] NEW_LINE while ( li >= 1 and lRad >= 1 ) : NEW_LINE INDENT rStation [ li ] += lRad NEW_LINE lRad -= 1 NEW_LINE li -= 1 NEW_LINE DEDENT while ( ri <= n and rRad >= 1 ) : NEW_LINE INDENT rStation [ ri ] += rRad NEW_LINE rRad -= 1 NEW_LINE ri += 1 NEW_LINE DEDENT DEDENT printf ( rStation , n ) NEW_LINE DEDENT
def oddTriangularNumber ( N ) : NEW_LINE INDENT return ( N * ( ( 2 * N ) - 1 ) ) NEW_LINE DEDENT
def idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT if ( ( a1 // a2 == b1 // b2 ) and ( a1 // a2 == c1 // c2 ) and ( b1 // b2 == c1 // c2 ) ) : NEW_LINE INDENT print ( "The given straight lines" , "are identical" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "The given straight lines" , "are not identical" ) NEW_LINE DEDENT DEDENT
def area ( a , b , c ) : NEW_LINE INDENT d = abs ( ( c * c ) / ( 2 * a * b ) ) NEW_LINE return d NEW_LINE DEDENT
def percent ( n , x ) : NEW_LINE INDENT p = ( int ) ( n ) * x NEW_LINE p /= 100 NEW_LINE return p NEW_LINE DEDENT
def getLoss ( price , quantity , X , n ) : NEW_LINE INDENT loss = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT originalPrice = price [ i ] NEW_LINE sellingPrice = originalPrice + percent ( originalPrice , X [ i ] ) NEW_LINE afterDiscount = sellingPrice - percent ( sellingPrice , X [ i ] ) NEW_LINE loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) NEW_LINE DEDENT return round ( loss , 2 ) NEW_LINE DEDENT
def maxAbsDiff ( arr , n ) : NEW_LINE INDENT minEle = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minEle = min ( minEle , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT return ( maxEle - minEle ) NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( sys . maxsize - 1 ) NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def maximizeSum ( a , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE mini = sys . maxsize NEW_LINE minSubarray = sys . maxsize NEW_LINE sum = maxSubArraySum ( a , n ) NEW_LINE max_so_far = - ( sys . maxsize - 1 ) NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE cnt += 1 NEW_LINE minSubarray = min ( a [ i ] , minSubarray ) NEW_LINE if ( sum == max_ending_here ) : NEW_LINE INDENT if ( cnt == 1 ) : NEW_LINE INDENT mini = min ( mini , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT mini = min ( mini , minSubarray ) NEW_LINE DEDENT DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE cnt = 0 NEW_LINE minSubarray = sys . maxsize NEW_LINE DEDENT DEDENT return sum - mini NEW_LINE DEDENT
def isOsiris ( n ) : NEW_LINE INDENT a = n % 10 NEW_LINE b = ( n // 10 ) % 10 NEW_LINE c = n // 100 NEW_LINE digit_sum = a + b + c NEW_LINE if ( n == ( 2 * ( digit_sum ) * 11 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def countTriangles ( a , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE pairs = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT pairs += a [ i ] // 2 NEW_LINE if ( a [ i ] % 2 == 1 and pairs > 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE pairs -= 1 NEW_LINE DEDENT DEDENT cnt += ( 2 * pairs ) // 3 NEW_LINE return cnt NEW_LINE DEDENT
def smallestMultiple ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT return pow ( 10 , n - 1 ) NEW_LINE DEDENT
def countAnomalies ( arr , n , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE i , Sum = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( abs ( arr [ i ] - ( Sum - arr [ i ] ) ) > k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N // i ) : NEW_LINE INDENT cnt [ i * j ] += 1 NEW_LINE DEDENT DEDENT DEDENT
def Sumofdivisors ( A , B , C ) : NEW_LINE INDENT sum = 0 NEW_LINE Divisors ( ) NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT x = i * j * k NEW_LINE sum += cnt [ x ] NEW_LINE if ( sum >= mod ) : NEW_LINE INDENT sum -= mod NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def getHCF ( x , y ) : NEW_LINE INDENT minimum = min ( x , y ) NEW_LINE if ( x % minimum == 0 and y % minimum == 0 ) : NEW_LINE INDENT return minimum NEW_LINE DEDENT for i in range ( minimum // 2 , 1 , - 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT if ( isPrime ( n + 1 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def findDivisors ( n ) : NEW_LINE INDENT div = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if j * i <= n : NEW_LINE INDENT div [ i * j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( div [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def findMaxCock ( ar ) : NEW_LINE INDENT if ( R < 3 or C < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_sum = - sys . maxsize - 1 NEW_LINE for i in range ( R - 2 ) : NEW_LINE INDENT for j in range ( C - 2 ) : NEW_LINE INDENT sum = ( ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ) NEW_LINE max_sum = max ( max_sum , sum ) NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT
def segments ( n , p , m ) : NEW_LINE INDENT c = dict ( ) NEW_LINE c [ 0 ] = 1 NEW_LINE has = False NEW_LINE Sum = 0 NEW_LINE ans = 0 NEW_LINE for r in range ( n ) : NEW_LINE INDENT if ( p [ r ] < m ) : NEW_LINE INDENT Sum -= 1 NEW_LINE DEDENT elif ( p [ r ] > m ) : NEW_LINE INDENT Sum += 1 NEW_LINE DEDENT if ( p [ r ] == m ) : NEW_LINE INDENT has = True NEW_LINE DEDENT if ( has ) : NEW_LINE INDENT if ( Sum in c . keys ( ) ) : NEW_LINE INDENT ans += c [ Sum ] NEW_LINE DEDENT if Sum - 1 in c . keys ( ) : NEW_LINE INDENT ans += c [ Sum - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT c [ Sum ] = c . get ( Sum , 0 ) + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findMaximumDiff ( a , n ) : NEW_LINE INDENT ind1 = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ 0 ] != a [ i ] ) : NEW_LINE INDENT ind1 = i NEW_LINE break NEW_LINE DEDENT DEDENT ind2 = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ n - 1 ] != a [ i ] ) : NEW_LINE INDENT ind2 = ( n - 1 - i ) NEW_LINE break NEW_LINE DEDENT DEDENT return max ( ind1 , ind2 ) NEW_LINE DEDENT
def decideWinner ( a , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE count3 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 4 == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 1 ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 2 ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 3 ) : NEW_LINE INDENT count3 += 1 NEW_LINE DEDENT DEDENT if ( count0 % 2 == 0 and count1 % 2 == 0 and count2 % 2 == 0 and count3 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT
def minOperations ( arr , n ) : NEW_LINE INDENT mp = dict . fromkeys ( arr , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT maxFreq = - ( sys . maxsize - 1 ) NEW_LINE for key in mp : NEW_LINE INDENT maxFreq = max ( maxFreq , mp [ key ] ) NEW_LINE DEDENT return ( n - maxFreq ) NEW_LINE DEDENT
def Add_edge ( u , v ) : NEW_LINE INDENT tree [ u ] . append ( v ) NEW_LINE tree [ v ] . append ( u ) NEW_LINE DEDENT
def intisalise ( ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def Dfs ( ch , par ) : NEW_LINE INDENT global currentIdx NEW_LINE p [ currentIdx ] = ch NEW_LINE startIdx [ ch ] = currentIdx NEW_LINE currentIdx += 1 NEW_LINE for c in tree [ ch ] : NEW_LINE INDENT if ( c != par ) : NEW_LINE INDENT Dfs ( c , ch ) NEW_LINE DEDENT DEDENT endIdx [ ch ] = currentIdx - 1 NEW_LINE DEDENT
def findNode ( v , k ) : NEW_LINE INDENT k += startIdx [ v ] - 1 NEW_LINE if ( k <= endIdx [ v ] ) : NEW_LINE INDENT return p [ k ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def CntDivbyX ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT number = number * 2 + arr [ i ] NEW_LINE if ( ( number % x == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def CntDivbyX ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT number = ( number * 2 + arr [ i ] ) % x NEW_LINE if number == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def smallestIndex ( a , n ) : NEW_LINE INDENT right1 = 0 NEW_LINE right0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT DEDENT return min ( right1 , right0 ) NEW_LINE DEDENT
def A_mod_B ( N , a ) : NEW_LINE INDENT Len = len ( N ) NEW_LINE ans = 0 NEW_LINE for i in range ( Len ) : NEW_LINE INDENT ans = ( ans * 10 + int ( N [ i ] ) ) % a NEW_LINE DEDENT return ans % a NEW_LINE DEDENT
def findMod ( N ) : NEW_LINE INDENT mod = A_mod_B ( N , 4 ) NEW_LINE ans = ( 1 + pow ( 2 , mod ) + pow ( 3 , mod ) + pow ( 4 , mod ) ) NEW_LINE return ans % 5 NEW_LINE DEDENT
def countCon ( ar , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ar [ i ] == ar [ i + 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def printElements ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def reduceFraction ( x , y ) : NEW_LINE INDENT d = gcd ( x , y ) NEW_LINE x = x // d NEW_LINE y = y // d NEW_LINE print ( "x =" , x , ", y =" , y ) NEW_LINE DEDENT
def generateSubStrings ( s , mpp ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT temp = "" NEW_LINE for j in range ( i , l ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE mpp [ temp ] += 1 NEW_LINE DEDENT DEDENT DEDENT
def binomialCoeff ( C ) : NEW_LINE INDENT for i in range ( 0 , 100 ) : NEW_LINE INDENT for j in range ( 0 , 100 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def answerQuery ( mpp , C , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for it in mpp : NEW_LINE INDENT if mpp [ it ] >= k : NEW_LINE INDENT ans += C [ mpp [ it ] ] [ k ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def numLen ( K ) : NEW_LINE INDENT if ( K % 2 == 0 or K % 5 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT number = 0 NEW_LINE len = 1 NEW_LINE for len in range ( 1 , K + 1 ) : NEW_LINE INDENT number = number * 10 + 1 NEW_LINE if ( ( number % K == 0 ) ) : NEW_LINE INDENT return len NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def numLen ( K ) : NEW_LINE INDENT if ( K % 2 == 0 or K % 5 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT number = 0 NEW_LINE len = 1 NEW_LINE for len in range ( 1 , K + 1 ) : NEW_LINE INDENT number = ( number * 10 + 1 ) % K NEW_LINE if number == 0 : NEW_LINE INDENT return len NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def precomputation ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum1 [ j ] += i NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum2 [ j ] += ( sum1 [ j ] - i ) * i NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT sum2 [ i ] = int ( sum2 [ i ] / 2 ) NEW_LINE DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT sum3 [ i ] = int ( sum3 [ i ] / 3 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum3 [ arr [ i ] ] , end = " " ) NEW_LINE DEDENT DEDENT
def sum ( k , n ) : NEW_LINE INDENT sum = ( pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ) NEW_LINE return sum NEW_LINE DEDENT
def exponent ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponent ( A , B / 2 ) NEW_LINE y = ( y * y ) NEW_LINE DEDENT else : NEW_LINE INDENT y = A NEW_LINE y = ( y * exponent ( A , B - 1 ) ) NEW_LINE DEDENT return y NEW_LINE DEDENT
def sum ( k , n ) : NEW_LINE INDENT sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) NEW_LINE return sum NEW_LINE DEDENT
def freqPairs ( arr , n ) : NEW_LINE INDENT max = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT freq = [ 0 for i in range ( max + 1 ) ] NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 * arr [ i ] , max + 1 , arr [ i ] ) : NEW_LINE INDENT if ( freq [ j ] >= 1 ) : NEW_LINE INDENT count += freq [ j ] NEW_LINE DEDENT DEDENT if ( freq [ arr [ i ] ] > 1 ) : NEW_LINE INDENT count += freq [ arr [ i ] ] - 1 NEW_LINE freq [ arr [ i ] ] -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def is_prime ( num ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT if i * i > num : NEW_LINE INDENT break NEW_LINE DEDENT if ( ( num ) % i == 0 ) : NEW_LINE INDENT if ( i * i != ( num ) ) : NEW_LINE INDENT count += 2 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( count == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def is_divisible ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return "YES" NEW_LINE DEDENT else : NEW_LINE INDENT if ( is_prime ( n + 1 ) ) : NEW_LINE INDENT return "NO" NEW_LINE DEDENT DEDENT else : return "YES" NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def findCount ( N ) : NEW_LINE INDENT count = power ( 2 , N , mod ) NEW_LINE return count NEW_LINE DEDENT
def msb ( x ) : NEW_LINE INDENT ret = 0 NEW_LINE while ( ( x >> ( ret + 1 ) ) != 0 ) : NEW_LINE INDENT ret = ret + 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT
def xorRange ( l , r ) : NEW_LINE INDENT max_bit = msb ( r ) NEW_LINE mul = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , max_bit + 1 ) : NEW_LINE INDENT if ( ( l // mul ) * mul == ( r // mul ) * mul ) : NEW_LINE INDENT if ( ( ( ( l & ( 1 << i ) ) != 0 ) and ( r - l + 1 ) % 2 == 1 ) ) : NEW_LINE INDENT ans = ans + mul NEW_LINE DEDENT mul = mul * 2 NEW_LINE continue NEW_LINE DEDENT odd_c = 0 NEW_LINE if ( ( ( l & ( 1 << i ) ) != 0 ) and l % 2 == 1 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( ( ( r & ( 1 << i ) ) != 0 ) and r % 2 == 0 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( odd_c ) : NEW_LINE INDENT ans = ans + mul NEW_LINE DEDENT mul = mul * 2 NEW_LINE DEDENT zero_bit_cnt = ( r - l + 1 ) // 2 NEW_LINE if ( ( l % 2 == 1 ) and ( r % 2 == 1 ) ) : NEW_LINE INDENT zero_bit_cnt = zero_bit_cnt + 1 NEW_LINE DEDENT if ( zero_bit_cnt % 2 == 1 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def computeXOR ( n ) : NEW_LINE INDENT switch = { 0 : n , 1 : 1 , 2 : n + 1 , 3 : 0 , } NEW_LINE return switch . get ( n & 3 , "" ) NEW_LINE DEDENT
def countNumbers ( x , n ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ) NEW_LINE DEDENT
def checkfact ( N , countprime , prime ) : NEW_LINE INDENT countfact = 0 NEW_LINE if ( prime == 2 or prime == 3 ) : NEW_LINE INDENT countfact += 1 NEW_LINE DEDENT divide = prime NEW_LINE while ( int ( N / divide ) != 0 ) : NEW_LINE INDENT countfact += int ( N / divide ) NEW_LINE divide = divide * divide NEW_LINE DEDENT if ( countfact >= countprime ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def check ( N ) : NEW_LINE INDENT sumsquares = ( N + 1 ) * ( 2 * N + 1 ) NEW_LINE countprime = 0 NEW_LINE for i in range ( 2 , int ( sqrt ( sumsquares ) ) + 1 , 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE while ( sumsquares % i == 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE countprime += 1 NEW_LINE sumsquares /= i NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT if ( checkfact ( N - 1 , countprime , i ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT countprime = 0 NEW_LINE DEDENT DEDENT if ( sumsquares != 1 ) : NEW_LINE INDENT if ( checkfact ( N - 1 , 1 , sumsquares ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countNonIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] <= arr [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) / 2 ) NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) / 2 ) NEW_LINE DEDENT return int ( cnt ) NEW_LINE DEDENT
def recamanArray ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE recaman = [ 0 for i in range ( n ) ] NEW_LINE recamanGenerator ( recaman , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ recaman [ i ] ] = s . get ( recaman [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in s . keys ( ) : NEW_LINE INDENT del s [ arr [ i ] ] NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT
def countSubarrays ( arr , n , k ) : NEW_LINE INDENT prefix_sum = [ 0 ] * MAX NEW_LINE prefix_sum [ 0 ] = 0 NEW_LINE prefix_sum = partial_sum ( prefix_sum , arr , n ) NEW_LINE if ( k == 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE m = defaultdict ( int ) NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT if ( ( prefix_sum [ i ] + 1 ) in m ) : NEW_LINE INDENT sum += m [ prefix_sum [ i ] + 1 ] NEW_LINE DEDENT m [ prefix_sum [ i ] ] += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT if ( k == - 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE m = defaultdict ( int ) NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT if ( ( prefix_sum [ i ] + 1 ) in m ) : NEW_LINE INDENT sum += m [ prefix_sum [ i ] + 1 ] NEW_LINE DEDENT if ( ( prefix_sum [ i ] - 1 ) in m ) : NEW_LINE INDENT sum += m [ prefix_sum [ i ] - 1 ] NEW_LINE DEDENT m [ prefix_sum [ i ] ] += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT sum = 0 NEW_LINE m = defaultdict ( int ) NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT b = 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( b > 100000000000000 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( ( prefix_sum [ i ] + b ) in m ) : NEW_LINE INDENT sum += m [ prefix_sum [ i ] + b ] NEW_LINE DEDENT b *= k NEW_LINE DEDENT m [ prefix_sum [ i ] ] += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def kadaneAlgorithm ( ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ar [ i ] NEW_LINE if ( sum < 0 ) : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT maxSum = max ( maxSum , sum ) NEW_LINE DEDENT return maxSum NEW_LINE DEDENT
def maxFunction ( arr , n ) : NEW_LINE INDENT b = [ 0 ] * MAX NEW_LINE c = [ 0 ] * MAX NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT b [ i ] = abs ( arr [ i + 1 ] - arr [ i ] ) NEW_LINE c [ i ] = - b [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT c [ i ] = abs ( arr [ i + 1 ] - arr [ i ] ) NEW_LINE b [ i ] = - c [ i ] NEW_LINE DEDENT DEDENT ans = kadaneAlgorithm ( b , n - 1 ) NEW_LINE ans = max ( ans , kadaneAlgorithm ( c , n - 1 ) ) NEW_LINE return ans NEW_LINE DEDENT
def isPerfectSquare ( arr , n ) : NEW_LINE INDENT umap = dict . fromkeys ( arr , n ) NEW_LINE for key in arr : NEW_LINE INDENT umap [ key ] += 1 NEW_LINE DEDENT for key in arr : NEW_LINE INDENT if ( umap [ key ] % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def minimumSteps ( n , m , a , b ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return MAXN NEW_LINE DEDENT if ( n == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) NEW_LINE DEDENT
def isPrime ( x ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( x ) ) + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def minimumCost ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 1 and isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT phi = ( ( 1 + ( 5 ** ( 1 / 2 ) ) ) / 2 ) NEW_LINE return round ( ( phi ** n ) / ( 5 ** ( 1 / 2 ) ) ) NEW_LINE DEDENT
def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) / 2 NEW_LINE return int ( round ( pow ( phi , n ) / math . sqrt ( 5 ) ) ) NEW_LINE DEDENT
def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT
def wastedWater ( V , M , N ) : NEW_LINE INDENT amt_per_min = M - N NEW_LINE time_to_fill = V / amt_per_min NEW_LINE wasted_amt = N * time_to_fill NEW_LINE return wasted_amt NEW_LINE DEDENT
def sphereSide ( h , r ) : NEW_LINE INDENT if h < 0 and r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT R = ( ( ( h * r * math . sqrt ( 2 ) ) ) / ( h + math . sqrt ( 2 ) * r ) / 2 ) NEW_LINE return R NEW_LINE DEDENT
def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ) NEW_LINE print ( "Loss =" , round ( loss , 3 ) ) NEW_LINE DEDENT
def possibleways ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( n % 4 == 0 ) : NEW_LINE INDENT return n // 4 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n // 4 NEW_LINE DEDENT DEDENT
def countSubarrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT product = 1 NEW_LINE for x in range ( i , j + 1 ) : NEW_LINE INDENT product *= arr [ x ] NEW_LINE DEDENT if ( product % K == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def build ( node , start , end , arr , k ) : NEW_LINE INDENT if ( start == end ) : NEW_LINE INDENT tree [ node ] = ( arr [ start ] ) % k NEW_LINE return NEW_LINE DEDENT mid = ( start + end ) >> 1 NEW_LINE build ( 2 * node , start , mid , arr , k ) NEW_LINE build ( 2 * node + 1 , mid + 1 , end , arr , k ) NEW_LINE tree [ node ] = ( tree [ 2 * node ] * tree [ 2 * node + 1 ] ) % k NEW_LINE DEDENT
def query ( node , start , end , l , r , k ) : NEW_LINE INDENT if ( start > end or start > r or end < l ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( start >= l and end <= r ) : NEW_LINE INDENT return tree [ node ] % k NEW_LINE DEDENT mid = ( start + end ) >> 1 NEW_LINE q1 = query ( 2 * node , start , mid , l , r , k ) NEW_LINE q2 = query ( 2 * node + 1 , mid + 1 , end , l , r , k ) NEW_LINE return ( q1 * q2 ) % k NEW_LINE DEDENT
def countSubarrays ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT product_mod_k = query ( 1 , 0 , n - 1 , i , j , k ) NEW_LINE if ( product_mod_k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def printMaxValPair ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE N = v [ n - 1 ] NEW_LINE if N % 2 == 1 : NEW_LINE INDENT first_maxima = N // 2 NEW_LINE second_maxima = first_maxima + 1 NEW_LINE ans1 , ans2 = 3 * ( 10 ** 18 ) , 3 * ( 10 ** 18 ) NEW_LINE from_left , from_right = - 1 , - 1 NEW_LINE _from = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if v [ i ] > first_maxima : NEW_LINE INDENT _from = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT diff = first_maxima - v [ i ] NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE from_left = v [ i ] NEW_LINE DEDENT DEDENT DEDENT from_right = v [ _from ] NEW_LINE diff1 = first_maxima - from_left NEW_LINE diff2 = from_right - second_maxima NEW_LINE if diff1 < diff2 : NEW_LINE INDENT print ( N , from_left ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , from_right ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxima = N // 2 NEW_LINE ans1 = 3 * ( 10 ** 18 ) NEW_LINE R = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT diff = abs ( v [ i ] - maxima ) NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE R = v [ i ] NEW_LINE DEDENT DEDENT print ( N , R ) NEW_LINE DEDENT DEDENT
def Permutations ( n , k ) : NEW_LINE INDENT ans = 1 NEW_LINE if k >= 2 : NEW_LINE INDENT ans += ( n ) * ( n - 1 ) // 2 NEW_LINE DEDENT if k >= 3 : NEW_LINE INDENT ans += ( ( n ) * ( n - 1 ) * ( n - 2 ) * 2 // 6 ) NEW_LINE DEDENT if k >= 4 : NEW_LINE INDENT ans += ( ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 // 24 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countIntegers ( l , r ) : NEW_LINE INDENT ans , i = 0 , 1 NEW_LINE v = power ( 2 , i ) NEW_LINE while v <= r : NEW_LINE INDENT while v <= r : NEW_LINE INDENT if v >= l : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT v = v * 3 NEW_LINE DEDENT i += 1 NEW_LINE v = power ( 2 , i ) NEW_LINE DEDENT if l == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sumTruncatablePrimes ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT num = i NEW_LINE flag = True NEW_LINE while ( num ) : NEW_LINE INDENT if ( prime [ num ] == False ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT num //= 10 NEW_LINE DEDENT num = i NEW_LINE power = 10 NEW_LINE while ( num // power ) : NEW_LINE INDENT if ( prime [ num % power ] == False ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT power *= 10 NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def nDigitPerfectSquares ( n ) : NEW_LINE INDENT print ( pow ( math . ceil ( math . sqrt ( pow ( 10 , n - 1 ) ) ) , 2 ) , end = " " ) NEW_LINE print ( pow ( math . ceil ( math . sqrt ( pow ( 10 , n ) ) ) - 1 , 2 ) ) NEW_LINE DEDENT
def MaxTraceSub ( mat ) : NEW_LINE INDENT max_trace = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT r = i NEW_LINE s = j NEW_LINE trace = 0 NEW_LINE while ( r < N and s < N ) : NEW_LINE INDENT trace += mat [ r ] NEW_LINE r += 1 NEW_LINE s += 1 NEW_LINE max_trace = max ( trace , max_trace ) NEW_LINE DEDENT DEDENT DEDENT return max_trace NEW_LINE DEDENT
def printSum ( a , b ) : NEW_LINE INDENT res , temp1 , temp2 = 0 , 0 , 0 NEW_LINE while a > 0 : NEW_LINE INDENT temp1 = temp1 * 10 + ( a % 10 ) NEW_LINE a //= 10 NEW_LINE DEDENT a = temp1 NEW_LINE while b > 0 : NEW_LINE INDENT temp2 = temp2 * 10 + ( b % 10 ) NEW_LINE b //= 10 NEW_LINE DEDENT b = temp2 NEW_LINE while a : NEW_LINE INDENT Sum = a % 10 + b % 10 NEW_LINE if Sum // 10 == 0 : NEW_LINE INDENT res = res * 10 + Sum NEW_LINE DEDENT else : NEW_LINE INDENT temp1 = 0 NEW_LINE while Sum > 0 : NEW_LINE INDENT temp1 = temp1 * 10 + ( Sum % 10 ) NEW_LINE Sum //= 10 NEW_LINE DEDENT Sum = temp1 NEW_LINE while Sum > 0 : NEW_LINE INDENT res = res * 10 + ( Sum % 10 ) NEW_LINE Sum //= 10 NEW_LINE DEDENT DEDENT a //= 10 NEW_LINE b //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT return math . floor ( math . log10 ( abs ( a ) ) - math . log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT
def smallestOdd ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return pow ( 10 , n - 1 ) + 1 NEW_LINE DEDENT
def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def smallestEven ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return pow ( 10 , n - 1 ) NEW_LINE DEDENT
def printBalancedExpression ( a , b , c , d ) : NEW_LINE INDENT if ( ( a == d and a ) or ( a == 0 and c == 0 and d == 0 ) ) : NEW_LINE INDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT print ( "((" , end = "" ) NEW_LINE DEDENT for i in range ( 1 , c + 1 ) : NEW_LINE INDENT print ( ")(" , end = "" ) NEW_LINE DEDENT for i in range ( 1 , d + 1 ) : NEW_LINE INDENT print ( "))" , end = "" ) NEW_LINE DEDENT for i in range ( 1 , b + 1 ) : NEW_LINE INDENT print ( "()" , end = "" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def maxProfit ( n , a , b , x , y ) : NEW_LINE INDENT res = x * ( n // a ) NEW_LINE res += y * ( n // b ) NEW_LINE res -= min ( x , y ) * ( n // ( ( a * b ) // gcd ( a , b ) ) ) NEW_LINE return res NEW_LINE DEDENT
def factorial ( f ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , f + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT
def kthOdd ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def lastFiveDigits ( n ) : NEW_LINE INDENT n = ( ( int ) ( n / 10000 ) * 10000 + ( ( int ) ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( int ) ( n / 10 ) % 10 ) * 10 + ( int ) ( n / 1000 ) % 10 ) NEW_LINE ans = 1 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans *= n NEW_LINE ans %= 100000 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def power ( a , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , n // 2 ) % mod NEW_LINE p = ( p * p ) % mod NEW_LINE if n & 1 == 1 : NEW_LINE INDENT p = ( p * a ) % mod NEW_LINE DEDENT return p NEW_LINE DEDENT
def computeSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT maxs = ( power ( 2 , i ) - 1 + mod ) % mod NEW_LINE maxs = ( maxs * arr [ i ] ) % mod NEW_LINE mins = ( power ( 2 , n - 1 - i ) - 1 + mod ) % mod NEW_LINE mins = ( mins * arr [ i ] ) % mod NEW_LINE V = ( maxs - mins + mod ) % mod NEW_LINE Sum = ( Sum + V ) % mod NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def maxValue ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( ( n * n // 2 ) - 1 ) NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE p = 1 NEW_LINE while ( p <= n ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE p *= 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT return ( n - n // 2 - n // 3 - n // 5 - n // 7 + n // 6 + n // 10 + n // 14 + n // 15 + n // 21 + n // 35 - n // 30 - n // 42 - n // 70 - n // 105 + n // 210 ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( n , n ) + sum ( n - 1 ) NEW_LINE DEDENT DEDENT
def power ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , int ( n / 2 ) ) % mod NEW_LINE p = ( p * p ) % mod NEW_LINE if ( n & 1 ) : NEW_LINE INDENT p = ( p * a ) % mod NEW_LINE DEDENT return p NEW_LINE DEDENT
def countPermutations ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( power ( 2 , n - 1 ) - 2 ) % mod NEW_LINE DEDENT
def numbers ( n ) : NEW_LINE INDENT return pow ( 2 , n + 1 ) - 2 NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT return n // 2520 NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT nth += pow ( i , i ) NEW_LINE DEDENT return nth NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE nth = ( N * N * ( N + 1 ) ) // 2 NEW_LINE return nth NEW_LINE DEDENT
def kthSmallest ( n , k ) : NEW_LINE INDENT return 2 * k NEW_LINE DEDENT
def isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def sieve_modified ( ) : NEW_LINE INDENT for i in range ( 1 , MAX , 2 ) : NEW_LINE INDENT for j in range ( i , MAX , i ) : NEW_LINE INDENT prefix [ j ] += i NEW_LINE DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT prefix [ i ] += prefix [ i - 1 ] NEW_LINE DEDENT DEDENT
def sumOddFactors ( L , R ) : NEW_LINE INDENT return ( prefix [ R ] - prefix [ L - 1 ] ) NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN ) : NEW_LINE INDENT if i * i >= MAXN : NEW_LINE INDENT break NEW_LINE DEDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x // spf [ x ] NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT DEDENT
def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findMinRemoval ( arr , n ) : NEW_LINE INDENT value = 0 NEW_LINE maximum = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i != 0 and i != n - 1 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = ( abs ( arr [ i ] - arr [ i + 1 ] ) + abs ( arr [ i ] - arr [ i - 1 ] ) - abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ) NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT maximum = max ( maximum , temp ) NEW_LINE DEDENT return ( value - maximum ) NEW_LINE DEDENT
def countQuadruples ( a , n ) : NEW_LINE INDENT mpp = dict . fromkeys ( a , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mpp [ a [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if ( j == k ) : NEW_LINE INDENT continue NEW_LINE DEDENT mpp [ a [ j ] ] -= 1 NEW_LINE mpp [ a [ k ] ] -= 1 NEW_LINE first = a [ j ] - ( a [ k ] - a [ j ] ) NEW_LINE if first not in mpp : NEW_LINE INDENT mpp [ first ] = 0 NEW_LINE DEDENT fourth = ( a [ k ] * a [ k ] ) // a [ j ] NEW_LINE if fourth not in mpp : NEW_LINE INDENT mpp [ fourth ] = 0 NEW_LINE DEDENT if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) : NEW_LINE INDENT if ( a [ j ] != a [ k ] ) : NEW_LINE INDENT count += mpp [ first ] * mpp [ fourth ] NEW_LINE DEDENT else : NEW_LINE INDENT count += ( mpp [ first ] * ( mpp [ fourth ] - 1 ) ) NEW_LINE DEDENT DEDENT mpp [ a [ j ] ] += 1 NEW_LINE mpp [ a [ k ] ] += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def getTime ( u , v , x ) : NEW_LINE INDENT speed = u + v NEW_LINE time = x / speed NEW_LINE return time NEW_LINE DEDENT
def number_of_teams ( M ) : NEW_LINE INDENT N1 , N2 , sqr = 0 , 0 , 0 NEW_LINE sqr = math . sqrt ( 1 + ( 8 * M ) ) NEW_LINE N1 = ( 1 + sqr ) / 2 NEW_LINE N2 = ( 1 - sqr ) / 2 NEW_LINE if ( N1 > 0 ) : NEW_LINE INDENT return int ( N1 ) NEW_LINE DEDENT return int ( N2 ) NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT p = mod NEW_LINE res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) != 0 : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def solve ( n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( power ( ( k - 1 ) , n - 1 ) % mod - solve ( n - 1 , k ) + mod ) % mod NEW_LINE DEDENT
def findMinimum ( x , y ) : NEW_LINE INDENT low = 0 NEW_LINE high = y NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( ( mid * 2 + ( y - mid ) ) >= x ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT
def LucasSum ( N ) : NEW_LINE INDENT Sum = 0 NEW_LINE a = 2 NEW_LINE b = 1 NEW_LINE c = 0 NEW_LINE Sum += a NEW_LINE while ( b <= N ) : NEW_LINE INDENT Sum += b NEW_LINE c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def sumOfDigits ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum += x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if i % 2 == 0 and sumOfDigits ( i ) % 3 == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countNumbers ( l , r ) : NEW_LINE INDENT return ( ( r // 6 ) - ( l - 1 ) // 6 ) NEW_LINE DEDENT
def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers // 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countWays ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) / 2 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEW_LINE DEDENT
def BalanceArray ( A , Q ) : NEW_LINE INDENT ANS = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT DEDENT for i in range ( len ( Q ) ) : NEW_LINE INDENT index = Q [ i ] [ 0 ] NEW_LINE value = Q [ i ] [ 1 ] NEW_LINE if ( A [ index ] % 2 == 0 ) : NEW_LINE INDENT sum -= A [ index ] NEW_LINE DEDENT A [ index ] += value NEW_LINE if ( A [ index ] % 2 == 0 ) : NEW_LINE INDENT sum += A [ index ] NEW_LINE DEDENT ANS . append ( sum ) NEW_LINE DEDENT for i in range ( len ( ANS ) ) : NEW_LINE INDENT print ( ANS [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def findMinSum ( arr , n ) : NEW_LINE INDENT occ = n - 1 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] * pow ( 2 , occ ) NEW_LINE occ -= 1 NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def findPowerOfP ( N , p ) : NEW_LINE INDENT count = 0 NEW_LINE r = p NEW_LINE while ( r <= N ) : NEW_LINE INDENT count += int ( N / r ) NEW_LINE r = r * p NEW_LINE DEDENT return count NEW_LINE DEDENT
def primeFactorsofB ( B ) : NEW_LINE INDENT ans = [ ] NEW_LINE i = 2 NEW_LINE while ( B != 1 ) : NEW_LINE INDENT if ( B % i == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( B % i == 0 ) : NEW_LINE INDENT B = int ( B / i ) NEW_LINE count += 1 NEW_LINE DEDENT ans . append ( ( i , count ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def largestPowerOfB ( N , B ) : NEW_LINE INDENT vec = [ ] NEW_LINE vec = primeFactorsofB ( B ) NEW_LINE ans = sys . maxsize NEW_LINE ans = min ( ans , int ( findPowerOfP ( N , vec [ 0 ] [ 0 ] ) / vec [ 0 ] [ 1 ] ) ) NEW_LINE return ans NEW_LINE DEDENT
def maxLenSubArr ( a , n ) : NEW_LINE INDENT cm , Max = 1 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] > Max : NEW_LINE INDENT Max = a [ i ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT count = 1 NEW_LINE if a [ i ] == a [ i + 1 ] and a [ i ] == Max : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] == Max : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if count > cm : NEW_LINE INDENT cm = count NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return cm NEW_LINE DEDENT
def minSum ( arr , n , x ) : NEW_LINE INDENT Sum = 0 NEW_LINE largestDivisible , minimum = - 1 , arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( arr [ i ] % x == 0 and largestDivisible < arr [ i ] ) : NEW_LINE INDENT largestDivisible = arr [ i ] NEW_LINE DEDENT if arr [ i ] < minimum : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT if largestDivisible == - 1 : NEW_LINE INDENT return Sum NEW_LINE DEDENT sumAfterOperation = ( Sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible // x ) ) NEW_LINE return min ( Sum , sumAfterOperation ) NEW_LINE DEDENT
def parity ( a ) : NEW_LINE INDENT return a % 3 NEW_LINE DEDENT
def solve ( array , size ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( 0 , size - 1 ) : NEW_LINE INDENT if parity ( array [ i ] ) == parity ( array [ i + 1 ] ) : NEW_LINE INDENT operations += 1 NEW_LINE if i + 2 < size : NEW_LINE INDENT pari1 = parity ( array [ i ] ) NEW_LINE pari2 = parity ( array [ i + 2 ] ) NEW_LINE if pari1 == pari2 : NEW_LINE INDENT if pari1 == 0 : NEW_LINE INDENT array [ i + 1 ] = 1 NEW_LINE DEDENT elif pari1 == 1 : NEW_LINE INDENT array [ i + 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT array [ i + 1 ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( pari1 == 0 and pari2 == 1 ) or ( pari1 == 1 and pari2 == 0 ) ) : NEW_LINE INDENT array [ i + 1 ] = 2 NEW_LINE DEDENT if ( ( pari1 == 1 and pari2 == 2 ) or ( pari1 == 2 and pari2 == 1 ) ) : NEW_LINE INDENT array [ i + 1 ] = 0 NEW_LINE DEDENT if ( ( pari1 == 2 and pari2 == 0 ) and ( pari1 == 0 and pari2 == 2 ) ) : NEW_LINE INDENT array [ i + 1 ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return operations NEW_LINE DEDENT
def findDigitalRoot ( num ) : NEW_LINE INDENT sum = sys . maxsize NEW_LINE tempNum = num NEW_LINE while ( sum >= 10 ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( tempNum > 0 ) : NEW_LINE INDENT sum += tempNum % 10 NEW_LINE tempNum //= 10 NEW_LINE DEDENT tempNum = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findAnswer ( X , N ) : NEW_LINE INDENT counter = 0 NEW_LINE i = 0 NEW_LINE while ( counter < N ) : NEW_LINE INDENT i += 1 NEW_LINE digitalRoot = findDigitalRoot ( i ) NEW_LINE if ( digitalRoot == X ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT if ( counter == N ) : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def findAnswer ( X , N ) : NEW_LINE INDENT return ( N - 1 ) * 9 + X NEW_LINE DEDENT
def preComputeXor ( arr , prefix_xor ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT prefix_xor [ i ] [ j ] = arr [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT prefix_xor [ i ] [ j ] = ( prefix_xor [ i ] [ j - 1 ] ^ arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT prefix_xor [ j ] [ i ] = ( prefix_xor [ j - 1 ] [ i ] ^ prefix_xor [ j ] [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
def ansQuerie ( prefix_xor , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT xor_1 , xor_2 , xor_3 = 0 , 0 , 0 NEW_LINE if ( x1 != 0 ) : NEW_LINE INDENT xor_1 = prefix_xor [ x1 - 1 ] [ y2 ] NEW_LINE DEDENT if ( y1 != 0 ) : NEW_LINE INDENT xor_2 = prefix_xor [ x2 ] [ y1 - 1 ] NEW_LINE DEDENT if ( x1 != 0 and y1 != 0 ) : NEW_LINE INDENT xor_3 = prefix_xor [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT return ( ( prefix_xor [ x2 ] [ y2 ] ^ xor_1 ) ^ ( xor_2 ^ xor_3 ) ) NEW_LINE DEDENT
def LucasSequence ( arr , n ) : NEW_LINE INDENT max = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT s = set ( ) NEW_LINE a = 2 NEW_LINE b = 1 NEW_LINE s . add ( a ) NEW_LINE s . add ( b ) NEW_LINE while ( b < max ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE s . add ( b ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in s ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def matrixSum ( arr ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT top_left = ( i + 1 ) * ( j + 1 ) NEW_LINE bottom_right = ( n - i ) * ( n - j ) NEW_LINE sum += ( top_left * bottom_right * arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def maxAND ( L , R ) : NEW_LINE INDENT maximum = L & R NEW_LINE for i in range ( L , R , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , R + 1 , 1 ) : NEW_LINE INDENT maximum = max ( maximum , ( i & j ) ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT
def maxAND ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L NEW_LINE DEDENT elif ( ( R - L ) == 1 ) : NEW_LINE INDENT return ( R & L ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) : NEW_LINE INDENT return ( ( R - 1 ) & R ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( R - 2 ) & ( R - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT
def checkArray ( arr , n ) : NEW_LINE INDENT return ( ( arr [ 0 ] % 2 ) and ( arr [ n - 1 ] % 2 ) and ( n % 2 ) ) NEW_LINE DEDENT
def findCount ( arr , n ) : NEW_LINE INDENT countOdd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT countOdd += 1 NEW_LINE DEDENT DEDENT if ( countOdd % 2 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = mt . sqrt ( x ) NEW_LINE return ( ( sr - mt . floor ( sr ) ) == 0 ) NEW_LINE DEDENT
def Prime_Numbers ( n ) : NEW_LINE INDENT primes = SieveOfEratosthenes ( ) NEW_LINE for i in range ( len ( primes ) - 1 ) : NEW_LINE INDENT if ( primes [ i ] + primes [ i + 1 ] + 1 < N ) : NEW_LINE INDENT can [ primes [ i ] + primes [ i + 1 ] + 1 ] = True NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( can [ i ] and isprime [ i ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def printPermutation ( n , k ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = 2 * i - 1 NEW_LINE y = 2 * i NEW_LINE if ( i <= k ) : NEW_LINE INDENT print ( y , x , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , y , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def isPossible ( Sx , Sy , Dx , Dy , x , y ) : NEW_LINE INDENT if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dy ) % y == 0 and ( abs ( Sx - Dx ) / x ) % 2 == ( abs ( Sy - Dy ) / y ) % 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def getPairs ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE count = ( n * ( n - 1 ) ) // 2 NEW_LINE return count NEW_LINE DEDENT
def isDigitSumOne ( nm ) : NEW_LINE INDENT if ( nm % 9 == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def printValidNums ( n ) : NEW_LINE INDENT cbrt_n = math . ceil ( n ** ( 1. / 3. ) ) NEW_LINE for i in range ( 1 , cbrt_n + 1 ) : NEW_LINE INDENT cube = i * i * i NEW_LINE if ( cube >= 1 and cube <= n and isDigitSumOne ( cube ) ) : NEW_LINE INDENT print ( cube , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def isDigitSumOne ( nm ) : NEW_LINE INDENT while ( nm > 9 ) : NEW_LINE INDENT sum_digit = 0 NEW_LINE while ( nm != 0 ) : NEW_LINE INDENT digit = nm % 10 NEW_LINE sum_digit = sum_digit + digit NEW_LINE nm = nm // 10 NEW_LINE DEDENT nm = sum_digit NEW_LINE DEDENT if ( nm == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def printValidNums ( m , n ) : NEW_LINE INDENT for i in range ( m , n + 1 ) : NEW_LINE INDENT if ( isComposite ( i ) and isDigitSumOne ( i ) ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def initialize ( ) : NEW_LINE INDENT l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return l [ n ] [ r ] NEW_LINE DEDENT
def countRhombi ( h , w ) : NEW_LINE INDENT ct = 0 NEW_LINE for i in range ( 2 , h + 1 , 2 ) : NEW_LINE INDENT for j in range ( 2 , w + 1 , 2 ) : NEW_LINE INDENT ct += ( h - i + 1 ) * ( w - j + 1 ) NEW_LINE DEDENT DEDENT return ct NEW_LINE DEDENT
def maxSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for u in range ( 1 , N + 1 ) : NEW_LINE INDENT for v in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( u == v ) : NEW_LINE INDENT continue NEW_LINE DEDENT degreeU = 2 NEW_LINE if ( u == 1 or u == N ) : NEW_LINE INDENT degreeU = 1 NEW_LINE DEDENT degreeV = 2 NEW_LINE if ( v == 1 or v == N ) : NEW_LINE INDENT degreeV = 1 NEW_LINE DEDENT ans += ( degreeU * degreeV ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countSquares ( row , column ) : NEW_LINE INDENT topLeft = min ( row , column ) - 1 NEW_LINE bottomRight = 8 - max ( row , column ) NEW_LINE topRight = min ( row , 9 - column ) - 1 NEW_LINE bottomLeft = 8 - max ( row , 9 - column ) NEW_LINE return ( topLeft + topRight + bottomRight + bottomLeft ) NEW_LINE DEDENT
def cal_factorial ( ) : NEW_LINE INDENT arr [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1000001 ) : NEW_LINE INDENT arr [ i ] = ( arr [ i - 1 ] * i ) % mod NEW_LINE DEDENT DEDENT
def mod_exponent ( num , p ) : NEW_LINE INDENT if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( p & 1 ) : NEW_LINE INDENT return ( ( num % mod ) * ( mod_exponent ( ( num * num ) % mod , p // 2 ) ) % mod ) % mod NEW_LINE DEDENT elif ( not ( p & 1 ) ) : NEW_LINE INDENT return ( mod_exponent ( ( num * num ) % mod , p // 2 ) ) % mod NEW_LINE DEDENT DEDENT
def getCount ( x , y ) : NEW_LINE INDENT ans = arr [ x + y - 1 ] NEW_LINE ans *= mod_exponent ( arr [ x ] , mod - 2 ) NEW_LINE ans %= mod NEW_LINE ans *= mod_exponent ( arr [ y ] , mod - 2 ) NEW_LINE ans %= mod NEW_LINE ans *= ( x - y ) NEW_LINE ans %= mod NEW_LINE return ans NEW_LINE DEDENT
def calculateArea ( x , y ) : NEW_LINE INDENT pi = 3.1415926536 NEW_LINE arx = pi * x * x NEW_LINE ary = pi * y * y NEW_LINE return arx - ary NEW_LINE DEDENT
def findValues ( a , b ) : NEW_LINE INDENT if ( ( a - b ) % 2 == 1 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT print ( ( a - b ) // 2 , ( a + b ) // 2 ) NEW_LINE DEDENT
def minValue ( n , x , y ) : NEW_LINE INDENT val = ( y * n ) / 100 NEW_LINE if x >= val : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return math . ceil ( val ) - x NEW_LINE DEDENT DEDENT
def countTriplets ( n , points ) : NEW_LINE INDENT pts = [ ] NEW_LINE ct = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pts . append ( points [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = points [ i ] [ 0 ] + points [ j ] [ 0 ] NEW_LINE y = points [ i ] [ 1 ] + points [ j ] [ 1 ] NEW_LINE if ( x % 2 == 0 and y % 2 == 0 ) : NEW_LINE INDENT if [ x // 2 , y // 2 ] in pts : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT
def getWinner ( arr , n ) : NEW_LINE INDENT __gcd = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT __gcd = gcd ( __gcd , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT totalMoves = ( maxEle / __gcd ) - n NEW_LINE if ( totalMoves % 2 == 1 ) : NEW_LINE INDENT return 'A' NEW_LINE DEDENT return 'B' NEW_LINE DEDENT
def maximumFactor ( arr ) : NEW_LINE INDENT rank , factors = [ ] , [ ] NEW_LINE for i in range ( 2 , max ( arr ) + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in arr : NEW_LINE INDENT if j % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT rank . append ( count ) NEW_LINE factors . append ( i ) NEW_LINE DEDENT m = max ( rank ) NEW_LINE for i in range ( len ( rank ) ) : NEW_LINE INDENT if rank [ i ] == m : NEW_LINE INDENT print ( factors [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def digitSum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( n ) : NEW_LINE INDENT ans += n % 10 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findInt ( n , m ) : NEW_LINE INDENT minDigit = floor ( m / 9 ) NEW_LINE start = ( int ( pow ( 10 , minDigit ) ) - int ( pow ( 10 , minDigit ) ) % n ) NEW_LINE while ( start < sys . maxsize ) : NEW_LINE INDENT if ( digitSum ( start ) == m ) : NEW_LINE INDENT return start NEW_LINE DEDENT else : NEW_LINE INDENT start += n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def smallestDivisor ( n ) : NEW_LINE INDENT mx = int ( sqrt ( n ) ) NEW_LINE for i in range ( 2 , mx + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def maxSum ( n ) : NEW_LINE INDENT res = n NEW_LINE while ( n > 1 ) : NEW_LINE INDENT divi = smallestDivisor ( n ) NEW_LINE n = int ( n / divi ) NEW_LINE res += n NEW_LINE DEDENT return res NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT ans = 1 NEW_LINE while ( y ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT ans = ( ans * x ) % MOD NEW_LINE DEDENT y >>= 1 NEW_LINE x = ( x * x ) % MOD NEW_LINE DEDENT return ans % MOD NEW_LINE DEDENT
def modInverse ( x ) : NEW_LINE INDENT return power ( x , MOD - 2 ) NEW_LINE DEDENT
def countNumbers ( n , a , b ) : NEW_LINE INDENT fact = [ 0 for i in range ( MAX ) ] NEW_LINE inv = [ 0 for i in range ( MAX ) ] NEW_LINE ans = 0 NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX , 1 ) : NEW_LINE INDENT fact [ i ] = ( 1 * fact [ i - 1 ] * i ) NEW_LINE fact [ i ] %= MOD NEW_LINE DEDENT inv [ MAX - 1 ] = modInverse ( fact [ MAX - 1 ] ) NEW_LINE i = MAX - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT inv [ i ] = ( inv [ i + 1 ] * ( i + 1 ) ) NEW_LINE inv [ i ] %= MOD NEW_LINE i -= 1 NEW_LINE DEDENT if ( a < b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT for s in range ( n , 9 * n + 1 , 1 ) : NEW_LINE INDENT if ( check ( s , a , b ) == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s < n * b or ( s - n * b ) % ( a - b ) != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT numDig = int ( ( s - n * b ) / ( a - b ) ) NEW_LINE if ( numDig > n ) : NEW_LINE INDENT continue NEW_LINE DEDENT curr = fact [ n ] NEW_LINE curr = ( curr * inv [ numDig ] ) % MOD NEW_LINE curr = ( curr * inv [ n - numDig ] ) % MOD NEW_LINE ans = ( ans + curr ) % MOD NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countOddSquares ( n , m ) : NEW_LINE INDENT return ( int ( pow ( m , 0.5 ) ) - int ( pow ( n - 1 , 0.5 ) ) ) NEW_LINE DEDENT
def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE total = 0 NEW_LINE a = row - moves NEW_LINE b = row + moves NEW_LINE c = column - moves NEW_LINE d = column + moves NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 NEW_LINE return total NEW_LINE DEDENT
def findNumber ( n , m ) : NEW_LINE INDENT num = ( m - 1 ) * 9 + n NEW_LINE return num NEW_LINE DEDENT
def count ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( count ( root . left ) + count ( root . right ) + 1 ) NEW_LINE DEDENT
def checkRec ( root , n ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( count ( root ) == n - count ( root ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return ( checkRec ( root . left , n ) or checkRec ( root . right , n ) ) NEW_LINE DEDENT
def check ( root ) : NEW_LINE INDENT n = count ( root ) NEW_LINE return checkRec ( root , n ) NEW_LINE DEDENT
def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( 0 , n + 1 , a ) : NEW_LINE INDENT for j in range ( 0 , n - i + 1 , b ) : NEW_LINE INDENT z = ( n - ( i + j ) ) / c NEW_LINE if ( floor ( z ) == ceil ( z ) ) : NEW_LINE INDENT x = i // a NEW_LINE y = j // b NEW_LINE maxVal = max ( maxVal , x + y + int ( z ) ) NEW_LINE DEDENT DEDENT DEDENT return maxVal NEW_LINE DEDENT
def digitsCount ( n ) : NEW_LINE INDENT length = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT length += 1 NEW_LINE n //= 10 NEW_LINE DEDENT return length NEW_LINE DEDENT
def absoluteFirstLast ( n , x ) : NEW_LINE INDENT i = 0 NEW_LINE mod = 1 NEW_LINE while ( i < x ) : NEW_LINE INDENT mod *= 10 NEW_LINE i += 1 NEW_LINE DEDENT last = n % mod NEW_LINE length = digitsCount ( n ) NEW_LINE while ( length != x ) : NEW_LINE INDENT n //= 10 NEW_LINE length -= 1 NEW_LINE DEDENT first = n NEW_LINE return abs ( first - last ) NEW_LINE DEDENT
def EqualNumbers ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT while a [ i ] % 2 == 0 : NEW_LINE INDENT a [ i ] //= 2 NEW_LINE DEDENT while a [ i ] % 3 == 0 : NEW_LINE INDENT a [ i ] //= 3 NEW_LINE DEDENT if a [ i ] != a [ 0 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def make_sequence ( N ) : NEW_LINE INDENT arr = [ 0 ] * ( N + 1 ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 2 NEW_LINE DEDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % 2 == 1 ) : NEW_LINE INDENT arr [ 2 ] = 3 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def countOdd ( L , R ) : NEW_LINE INDENT N = ( R - L ) // 2 NEW_LINE if ( R % 2 != 0 or L % 2 != 0 ) : NEW_LINE INDENT N += 1 NEW_LINE DEDENT return N NEW_LINE DEDENT
def getMinCost ( n , m ) : NEW_LINE INDENT cost = ( n - 1 ) * m + ( m - 1 ) * n NEW_LINE return cost NEW_LINE DEDENT
def minOperation ( n , k , a ) : NEW_LINE INDENT for i in range ( k , n ) : NEW_LINE INDENT if ( a [ i ] != a [ k - 1 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for i in range ( k - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] != a [ k - 1 ] ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT
def digitWell ( n , m , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == m ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT n = ( int ) ( n / 10 ) NEW_LINE DEDENT return cnt == k NEW_LINE DEDENT
def findInt ( n , m , k ) : NEW_LINE INDENT i = n + 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( digitWell ( i , m , k ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT
def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def generateSequence ( n , g ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( i * g , end = " " ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def findLCMFibonacci ( a , b ) : NEW_LINE INDENT return ( fib ( a ) * fib ( b ) ) // fib ( gcd ( a , b ) ) NEW_LINE DEDENT
def getMinNum ( a , b , c ) : NEW_LINE INDENT if ( c < a or c > b ) : NEW_LINE INDENT return c NEW_LINE DEDENT x = ( ( b // c ) * c ) + c NEW_LINE return x NEW_LINE DEDENT
def isEvenOrOdd ( L , R ) : NEW_LINE INDENT oddCount = ( R - L ) / 2 NEW_LINE if ( R % 2 == 1 or L % 2 == 1 ) : NEW_LINE INDENT oddCount = oddCount + 1 NEW_LINE DEDENT if ( oddCount % 2 == 0 ) : NEW_LINE INDENT return "Even" NEW_LINE DEDENT else : NEW_LINE INDENT return "Odd" NEW_LINE DEDENT DEDENT
def trailing_zeros ( N ) : NEW_LINE INDENT count_of_two = 0 NEW_LINE count_of_five = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT val = i NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val /= 2 NEW_LINE count_of_two += i NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val /= 5 NEW_LINE count_of_five += i NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT
def SieveOfEratosthenes ( n ) : NEW_LINE INDENT global j NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT b [ j ] = p NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def Sieve ( ) : NEW_LINE INDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , MAX , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countPairs ( n ) : NEW_LINE INDENT num = ( ( n // 2 ) + 1 ) NEW_LINE Max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n NEW_LINE if ( val == Max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT num = ( ( n // 2 ) + 1 ) NEW_LINE max = n % num NEW_LINE count = n - max NEW_LINE return count NEW_LINE DEDENT
def countOdd ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT DEDENT return odd NEW_LINE DEDENT
def countValidPairs ( arr , n ) : NEW_LINE INDENT odd = countOdd ( arr , n ) NEW_LINE return ( odd * ( odd - 1 ) ) / 2 NEW_LINE DEDENT
def getMultiple ( s ) : NEW_LINE INDENT for i in range ( 0 , 10 ** 3 , 8 ) : NEW_LINE INDENT if ( checkSub ( str ( i ) , s ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def alter ( x , y ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT if ( x == 0 or y == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( x >= 2 * y ) : NEW_LINE INDENT x = x % ( 2 * y ) NEW_LINE DEDENT elif ( y >= 2 * x ) : NEW_LINE INDENT y = y % ( 2 * x ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( "X =" , x , ", " , "Y =" , y ) NEW_LINE DEDENT
def digitProduct ( n ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( n ) : NEW_LINE INDENT prod = prod * ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return prod NEW_LINE DEDENT
def printMultiplicativePrimes ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ digitProduct ( i ) ] ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT
def coPrime ( n1 , n2 ) : NEW_LINE INDENT if ( gcd ( n1 , n2 ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def largestCoprime ( N ) : NEW_LINE INDENT half = mt . floor ( N / 2 ) NEW_LINE while ( coPrime ( N , half ) == False ) : NEW_LINE INDENT half -= 1 NEW_LINE DEDENT return half NEW_LINE DEDENT
def largestCoprime ( N ) : NEW_LINE INDENT if N == 6 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif N % 4 == 0 : NEW_LINE INDENT return N // 2 - 1 NEW_LINE DEDENT elif N % 2 == 0 : NEW_LINE INDENT return N // 2 - 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( N - 1 ) // 2 NEW_LINE DEDENT DEDENT
def sieve ( maxEle , prime ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , int ( sqrt ( maxEle ) ) + 1 ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , maxEle + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def printAdditivePrime ( arr , n ) : NEW_LINE INDENT maxEle = max ( arr ) NEW_LINE prime = [ 0 ] * ( maxEle + 1 ) NEW_LINE sieve ( maxEle , prime ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == 0 ) : NEW_LINE INDENT sum = digitSum ( arr [ i ] ) NEW_LINE if ( prime [ sum ] == 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def printSafePrimes ( n ) : NEW_LINE INDENT prime = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prime [ i ] = 1 NEW_LINE DEDENT prime [ 0 ] = prime [ 1 ] = 0 NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] != 0 ) : NEW_LINE INDENT temp = ( 2 * i ) + 1 NEW_LINE if ( temp <= n and prime [ temp ] != 0 ) : NEW_LINE INDENT prime [ temp ] = 2 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == 2 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def sum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i NEW_LINE DEDENT return s NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT
def findSum ( m , n , mth , nth , p ) : NEW_LINE INDENT a , d = findingValues ( m , n , mth , nth ) NEW_LINE Sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) / 2 NEW_LINE return Sum NEW_LINE DEDENT
def ABUNDANT ( ) : NEW_LINE INDENT v = set ( ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT sum = 1 NEW_LINE for j in range ( 2 , int ( sqrt ( i ) ) + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT sum += j NEW_LINE DEDENT if ( i / j != j ) : NEW_LINE INDENT sum += i // j NEW_LINE DEDENT DEDENT if ( sum > i ) : NEW_LINE INDENT v . add ( i ) NEW_LINE DEDENT DEDENT return v NEW_LINE DEDENT
def SumOfAbundant ( n ) : NEW_LINE INDENT v = ABUNDANT ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( list ( v ) . count ( i ) and list ( v ) . count ( n - i ) ) : NEW_LINE INDENT print ( i , " " , n - i ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def nthTermOfTheSeries ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT nthTerm = pow ( n - 1 , 2 ) + n NEW_LINE DEDENT else : NEW_LINE INDENT nthTerm = pow ( n + 1 , 2 ) + n NEW_LINE DEDENT return nthTerm NEW_LINE DEDENT
def Divisors ( x ) : NEW_LINE INDENT c = 0 NEW_LINE v = [ ] NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x /= 2 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE while ( x % 3 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x /= 3 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE while ( x % 7 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x /= 7 NEW_LINE DEDENT v . append ( c ) NEW_LINE v . append ( x ) NEW_LINE return v NEW_LINE DEDENT
def MinOperations ( a , b ) : NEW_LINE INDENT va = Divisors ( a ) NEW_LINE vb = Divisors ( b ) NEW_LINE if ( va [ 3 ] != vb [ 3 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minOperations = abs ( va [ 0 ] - vb [ 0 ] ) + abs ( va [ 1 ] - vb [ 1 ] ) + abs ( va [ 2 ] - vb [ 2 ] ) NEW_LINE return minOperations NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT
def lcmOfArray ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT lcm = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // gcd ( lcm , arr [ i ] ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT
def candies ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE ind = 1 NEW_LINE arr = [ 0 ] * k NEW_LINE low = 0 NEW_LINE high = n NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE sum = ( mid * ( mid + 1 ) ) >> 1 NEW_LINE if ( sum <= n ) : NEW_LINE INDENT count = int ( mid / k ) NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT last = ( count * k ) NEW_LINE n -= int ( ( last * ( last + 1 ) ) / 2 ) NEW_LINE i = 0 NEW_LINE term = ( count * k ) + 1 NEW_LINE while ( n ) : NEW_LINE INDENT if ( term <= n ) : NEW_LINE INDENT arr [ i ] = term NEW_LINE i += 1 NEW_LINE n -= term NEW_LINE term += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += n NEW_LINE n = 0 NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT arr [ i ] += ( ( count * ( i + 1 ) ) + int ( k * ( count * ( count - 1 ) ) / 2 ) ) NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def CPwithLoss ( sellingPrice , loss ) : NEW_LINE INDENT costPrice = ( ( sellingPrice * 100.0 ) / ( 100 - loss ) ) NEW_LINE return costPrice NEW_LINE DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def replaceMax ( arr , n ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE ranges = max_element - min_element NEW_LINE coeffOfRange = ranges / ( max_element + min_element ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == max_element ) : NEW_LINE INDENT arr [ i ] = coeffOfRange NEW_LINE break NEW_LINE DEDENT DEDENT printArr ( arr , n ) NEW_LINE DEDENT
def largestOddDigit ( n ) : NEW_LINE INDENT maxOdd = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( digit % 2 == 1 and digit > maxOdd ) : NEW_LINE INDENT maxOdd = digit NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return maxOdd NEW_LINE DEDENT
def getProduct ( n ) : NEW_LINE INDENT maxOdd = largestOddDigit ( n ) NEW_LINE if ( maxOdd == - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n * maxOdd ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def commDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE a = a // n NEW_LINE b = b // n NEW_LINE print ( "A =" , a , ", B =" , b ) NEW_LINE DEDENT
def minAbsDiff ( n ) : NEW_LINE INDENT left = 1 << ( int ) ( math . floor ( math . log2 ( n ) ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( n - left ) , ( right - n ) ) NEW_LINE DEDENT
def FindAllElements ( n , k ) : NEW_LINE INDENT sum = k NEW_LINE A = [ 1 for i in range ( k ) ] NEW_LINE i = k - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT while ( sum + A [ i ] <= n ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE A [ i ] *= 2 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( sum != n ) : NEW_LINE INDENT print ( "Impossible" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , k , 1 ) : NEW_LINE INDENT print ( A [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT
def isEqual ( a , b ) : NEW_LINE INDENT if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT left = 1 NEW_LINE right = x NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) >> 1 NEW_LINE if ( ( mid * mid ) == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( mid * mid < x ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def isStrongPrime ( n ) : NEW_LINE INDENT if ( isPrime ( n ) == False or n == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT previous_prime = n - 1 NEW_LINE next_prime = n + 1 NEW_LINE while ( isPrime ( next_prime ) == False ) : NEW_LINE INDENT next_prime += 1 NEW_LINE DEDENT while ( isPrime ( previous_prime ) == False ) : NEW_LINE INDENT previous_prime -= 1 NEW_LINE DEDENT mean = ( previous_prime + next_prime ) / 2 NEW_LINE if ( n > mean ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isFactorialPrime ( n ) : NEW_LINE INDENT if ( not isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE i = 1 NEW_LINE while ( fact <= n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( n + 1 == fact or n - 1 == fact ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def sumArray ( arr , n ) : NEW_LINE INDENT leftSum = [ 0 for i in range ( n ) ] NEW_LINE rightSum = [ 0 for i in range ( n ) ] NEW_LINE Sum = [ 0 for i in range ( n ) ] NEW_LINE i , j = 0 , 0 NEW_LINE leftSum [ 0 ] = 0 NEW_LINE rightSum [ n - 1 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] NEW_LINE DEDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT Sum [ i ] = leftSum [ i ] + rightSum [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( Sum [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def LcmSum ( m ) : NEW_LINE INDENT ETF ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 , i ) : NEW_LINE INDENT ans [ j ] += ( i * phi [ i ] ) NEW_LINE DEDENT DEDENT answer = ans [ m ] NEW_LINE answer = ( answer + 1 ) * m NEW_LINE answer = answer // 2 NEW_LINE return answer NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT
def ncr ( n , r ) : NEW_LINE INDENT return factorial ( n ) // ( factorial ( r ) * factorial ( n - r ) ) NEW_LINE DEDENT
def countWays ( string ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE nvowels , nconsonants = 0 , 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( i == 0 or i == 4 or i == 8 or i == 14 or i == 20 ) : NEW_LINE INDENT nvowels += freq [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT nconsonants += freq [ i ] NEW_LINE DEDENT DEDENT vplaces = nconsonants + 1 NEW_LINE cways = factorial ( nconsonants ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( i != 0 and i != 4 and i != 8 and i != 14 and i != 20 and freq [ i ] > 1 ) : NEW_LINE INDENT cways = cways // factorial ( freq [ i ] ) NEW_LINE DEDENT DEDENT vways = ncr ( vplaces , nvowels ) * factorial ( nvowels ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( i == 0 or i == 4 or i == 8 or i == 14 or i == 20 and freq [ i ] > 1 ) : NEW_LINE INDENT vways = vways // factorial ( freq [ i ] ) NEW_LINE DEDENT DEDENT return cways * vways NEW_LINE DEDENT
def setBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n = n & ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countPairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT setbits_x = setBits ( a [ i ] ) NEW_LINE for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT setbits_y = setBits ( a [ j ] ) NEW_LINE setbits_xor_xy = setBits ( a [ i ] ^ a [ j ] ) NEW_LINE if ( setbits_x + setbits_y == setbits_xor_xy ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def findPossibleDerivables ( arr , n , D , A , B ) : NEW_LINE INDENT gcdAB = gcd ( A , B ) NEW_LINE counter = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( abs ( arr [ i ] - D ) % gcdAB ) == 0 ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT
def calSum ( n ) : NEW_LINE INDENT return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 NEW_LINE DEDENT
def maxOfMin ( a , n , S ) : NEW_LINE INDENT mi = 10 ** 9 NEW_LINE s1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s1 += a [ i ] NEW_LINE mi = min ( a [ i ] , mi ) NEW_LINE DEDENT if ( s1 < S ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( s1 == S ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT low = 0 NEW_LINE high = mi NEW_LINE ans = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( s1 - ( mid * n ) >= S ) : NEW_LINE INDENT ans = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def getElements ( a , arr , n ) : NEW_LINE INDENT elements = [ 1 for i in range ( n + 1 ) ] NEW_LINE elements [ 0 ] = a NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( elements [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def minimumX ( n , k ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT fir = i NEW_LINE sec = n // i NEW_LINE num1 = fir * k + sec NEW_LINE res = ( num1 // k ) * ( num1 % k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num1 , mini ) NEW_LINE DEDENT num2 = sec * k + fir NEW_LINE res = ( num2 // k ) * ( num2 % k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num2 , mini ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return mini NEW_LINE DEDENT
def minimumX ( n , k ) : NEW_LINE INDENT ans = 10 ** 18 NEW_LINE for i in range ( k - 1 , 0 , - 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT ans = min ( ans , i + ( n / i ) * k ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maxGCD ( N , P ) : NEW_LINE INDENT ans = 1 NEW_LINE prime_factors = { } NEW_LINE for i in range ( 2 , int ( sqrt ( P ) + 1 ) ) : NEW_LINE INDENT while ( P % i == 0 ) : NEW_LINE INDENT if i not in prime_factors : NEW_LINE INDENT prime_factors [ i ] = 0 NEW_LINE DEDENT prime_factors [ i ] += 1 NEW_LINE P //= i NEW_LINE DEDENT DEDENT if ( P != 1 ) : NEW_LINE INDENT prime_factors [ P ] += 1 NEW_LINE DEDENT for key , value in prime_factors . items ( ) : NEW_LINE INDENT ans *= pow ( key , value // N ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def getSum ( arr , p ) : NEW_LINE INDENT return len ( arr ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def countPairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if isPrime ( a [ i ] ^ a [ j ] ) and m . get ( a [ i ] ^ a [ j ] , 0 ) == 0 : NEW_LINE INDENT m [ ( a [ i ] ^ a [ j ] ) ] = 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def count ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( count ( node . left ) + count ( node . right ) + 1 ) NEW_LINE DEDENT
def check ( root ) : NEW_LINE INDENT n = count ( root ) NEW_LINE checkRec ( root , n ) NEW_LINE DEDENT
def countDivisors ( n ) : NEW_LINE INDENT x , ans = 0 , 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT x += 1 NEW_LINE n = n / 2 NEW_LINE DEDENT ans = ans * ( x + 1 ) NEW_LINE for i in range ( 3 , int ( n ** 1 / 2 ) + 1 , 2 ) : NEW_LINE INDENT x = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT x += 1 NEW_LINE n = n / i NEW_LINE DEDENT ans = ans * ( x + 1 ) NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT ans = ans * 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def getTotalCount ( n , k ) : NEW_LINE INDENT k_count = countDivisors ( k ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( k_count == countDivisors ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( k < n ) : NEW_LINE INDENT count = count - 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def getHermiteNumber ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ) NEW_LINE DEDENT DEDENT
def doubleFactorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT
def hermiteNumber ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT number = ( ( pow ( 2 , n / 2 ) ) * doubleFactorial ( n - 1 ) ) NEW_LINE if ( ( n / 2 ) % 2 == 1 ) : NEW_LINE INDENT number = number * - 1 NEW_LINE DEDENT return number NEW_LINE DEDENT DEDENT
def find ( n ) : NEW_LINE INDENT b = n NEW_LINE a = b * ( n - 1 ) NEW_LINE if a * b > n and a // b < n : NEW_LINE INDENT print ( "a = {}, b = {}" . format ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def SquareCube ( N ) : NEW_LINE INDENT cnt , i = 0 , 1 NEW_LINE while ( i ** 6 <= N ) : NEW_LINE INDENT cnt += 1 NEW_LINE i += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def getSum ( n , d ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( d <= n ) : NEW_LINE INDENT sum += d NEW_LINE d += 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isPerfect ( N ) : NEW_LINE INDENT if ( sqrt ( N ) - floor ( sqrt ( N ) ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def printThreeParts ( N ) : NEW_LINE INDENT if ( N % 3 == 0 ) : NEW_LINE INDENT print ( " x = 1, y = 1, z = " , N - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " x = 1, y = 2, z = " , N - 3 ) NEW_LINE DEDENT DEDENT
def sumX ( N , M , K ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT N = int ( Sum ( K + N ) ) NEW_LINE DEDENT N = N % MOD NEW_LINE return N NEW_LINE DEDENT
def countDigitsToBeRemoved ( N , K ) : NEW_LINE INDENT s = str ( N ) NEW_LINE res = 0 NEW_LINE f_zero = 0 NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return res NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT f_zero = 1 NEW_LINE K -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT if ( K == 0 ) : NEW_LINE INDENT return res NEW_LINE DEDENT elif ( f_zero > 0 ) : NEW_LINE INDENT return len ( s ) - 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n / divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n // divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( n % divisor ) // 10 NEW_LINE divisor = divisor // 100 NEW_LINE DEDENT return True NEW_LINE DEDENT
def largestPalindrome ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isPalindrome ( A [ i ] ) ) : NEW_LINE INDENT return A [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( int ( n / divisor ) >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = int ( n / divisor ) NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( ( n % divisor ) / 10 ) NEW_LINE divisor = int ( divisor / 100 ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def largestPalindrome ( A , n ) : NEW_LINE INDENT currentMax = - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( A [ i ] > currentMax and isPalindrome ( A [ i ] ) ) : NEW_LINE INDENT currentMax = A [ i ] NEW_LINE DEDENT DEDENT return currentMax NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE x = 1 NEW_LINE while x <= n : NEW_LINE INDENT sum = sum + x NEW_LINE x = x + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isPrime ( N ) : NEW_LINE INDENT k = int ( sqrt ( N ) ) + 1 NEW_LINE for i in range ( 2 , k , 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def printMode ( a , n ) : NEW_LINE INDENT max_element = max ( a ) NEW_LINE t = max_element + 1 NEW_LINE count = [ 0 ] * t NEW_LINE for i in range ( t ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT mode = 0 NEW_LINE k = count [ 0 ] NEW_LINE for i in range ( 1 , t ) : NEW_LINE INDENT if ( count [ i ] > k ) : NEW_LINE INDENT k = count [ i ] NEW_LINE mode = i NEW_LINE DEDENT DEDENT print ( "mode = " , mode ) NEW_LINE DEDENT
def checkTypeOfTriangle ( a , b , c ) : NEW_LINE INDENT sqa = pow ( a , 2 ) NEW_LINE sqb = pow ( b , 2 ) NEW_LINE sqc = pow ( c , 2 ) NEW_LINE if ( sqa == sqa + sqb or sqb == sqa + sqc or sqc == sqa + sqb ) : NEW_LINE INDENT print ( "Right-angled Triangle" ) NEW_LINE DEDENT elif ( sqa > sqc + sqb or sqb > sqa + sqc or sqc > sqa + sqb ) : NEW_LINE INDENT print ( "Obtuse-angled Triangle" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Acute-angled Triangle" ) NEW_LINE DEDENT DEDENT
def findLargestDivisor ( n ) : NEW_LINE INDENT m = n NEW_LINE s = set ( ) NEW_LINE s . add ( 1 ) NEW_LINE s . add ( n ) NEW_LINE for i in range ( 2 , int ( n ** ( 0.5 ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT s . add ( n // i ) NEW_LINE s . add ( i ) NEW_LINE while m % i == 0 : NEW_LINE INDENT m //= i NEW_LINE DEDENT DEDENT DEDENT if m > 1 : NEW_LINE INDENT s . add ( m ) NEW_LINE DEDENT vec = [ i ** 2 for i in range ( 2 , MAX + 1 ) ] NEW_LINE for d in sorted ( s , reverse = True ) : NEW_LINE INDENT divi , j = 0 , 0 NEW_LINE while j < len ( vec ) and vec [ j ] <= d : NEW_LINE INDENT if d % vec [ j ] == 0 : NEW_LINE INDENT divi = 1 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if not divi : NEW_LINE INDENT return d NEW_LINE DEDENT DEDENT DEDENT
def findLargestDivisor ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT while ( n % ( i * i ) == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def findMedian ( a , n ) : NEW_LINE INDENT sorted ( a ) NEW_LINE if n % 2 != 0 : NEW_LINE INDENT return float ( a [ n // 2 ] ) NEW_LINE DEDENT return float ( ( a [ int ( ( n - 1 ) / 2 ) ] + a [ int ( n / 2 ) ] ) / 2.0 ) NEW_LINE DEDENT
def printAMeans ( A , B , N ) : NEW_LINE INDENT d = ( B - A ) / ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( int ( A + i * d ) , end = " " ) NEW_LINE DEDENT DEDENT
def getFinalElement ( n ) : NEW_LINE INDENT finalNum = 2 NEW_LINE while finalNum * 2 <= n : NEW_LINE INDENT finalNum *= 2 NEW_LINE DEDENT return finalNum NEW_LINE DEDENT
def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isTriPerfect ( n ) : NEW_LINE INDENT sum = 1 + n NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ( True if sum == 3 * n and n != 1 else False ) NEW_LINE DEDENT
def findGreater ( a , b ) : NEW_LINE INDENT x = a * ( math . log ( b ) ) NEW_LINE y = b * ( math . log ( a ) ) NEW_LINE if ( y > x ) : NEW_LINE INDENT print ( "a^b is greater" ) NEW_LINE DEDENT elif ( y < x ) : NEW_LINE INDENT print ( "b^a is greater" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Both are equal" ) NEW_LINE DEDENT DEDENT
def sum ( N , X , Y ) : NEW_LINE INDENT S1 = floor ( floor ( N / X ) * floor ( 2 * X + floor ( N / X - 1 ) * X ) / 2 ) NEW_LINE S2 = floor ( floor ( N / Y ) ) * floor ( 2 * Y + floor ( N / Y - 1 ) * Y ) / 2 NEW_LINE S3 = floor ( floor ( N / ( X * Y ) ) ) * floor ( 2 * ( X * Y ) + floor ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def modexp ( x , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return modexp ( ( x * x ) % m , n // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 ) % m ) NEW_LINE DEDENT DEDENT
def getFractionModulo ( a , b ) : NEW_LINE INDENT c = gcd ( a , b ) NEW_LINE a = a // c NEW_LINE b = b // c NEW_LINE d = modexp ( b , m - 2 ) NEW_LINE ans = ( ( a % m ) * ( d % m ) ) % m NEW_LINE return ans NEW_LINE DEDENT
def startingPoint ( Length , Speed1 , Speed2 ) : NEW_LINE INDENT result1 = 0 NEW_LINE result2 = 0 NEW_LINE time1 = Length // Speed1 NEW_LINE time2 = Length // Speed2 NEW_LINE result1 = gcd ( time1 , time2 ) NEW_LINE result2 = time1 * time2 // ( result1 ) NEW_LINE return result2 NEW_LINE DEDENT
def firstTime ( Length , Speed1 , Speed2 ) : NEW_LINE INDENT result = 0 NEW_LINE relativeSpeed = abs ( Speed1 - Speed2 ) NEW_LINE result = Length / relativeSpeed NEW_LINE return result NEW_LINE DEDENT
def findNumber ( n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( sumOfDigits ( i ) > sumOfDigits ( n ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findTwoThreePrime ( l , r ) : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT num = i NEW_LINE while ( num % 2 == 0 ) : NEW_LINE INDENT num //= 2 NEW_LINE DEDENT while ( num % 3 == 0 ) : NEW_LINE INDENT num //= 3 NEW_LINE DEDENT if ( num == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findNth ( N ) : NEW_LINE INDENT b = 14 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT b = b * 2 NEW_LINE DEDENT else : NEW_LINE INDENT b = b - 8 NEW_LINE DEDENT DEDENT return b NEW_LINE DEDENT
def icanobifNumbers ( N ) : NEW_LINE INDENT first = 0 NEW_LINE second = 1 NEW_LINE if N == 1 : NEW_LINE INDENT print ( first ) NEW_LINE DEDENT elif N == 2 : NEW_LINE INDENT print ( first , second ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( first , second , end = " " ) NEW_LINE for i in range ( 3 , N + 1 ) : NEW_LINE INDENT x = reversedigit ( first ) NEW_LINE y = reversedigit ( second ) NEW_LINE print ( x + y , end = " " ) NEW_LINE temp = second NEW_LINE second = x + y NEW_LINE first = temp NEW_LINE DEDENT DEDENT DEDENT
def addNDigits ( a , b , n ) : NEW_LINE INDENT num = a NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT tmp = a * 10 + i NEW_LINE if ( tmp % b == 0 ) : NEW_LINE INDENT a = tmp NEW_LINE break NEW_LINE DEDENT DEDENT if ( num == a ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for j in range ( n - 1 ) : NEW_LINE INDENT a *= 10 NEW_LINE DEDENT return a NEW_LINE DEDENT
def predictMatrix ( arr , range1a , range1b , range0a , range0b , K , b ) : NEW_LINE INDENT c = 0 NEW_LINE while ( K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT c = 0 NEW_LINE if ( i > 0 and arr [ i - 1 ] [ j ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( j > 0 and arr [ i ] [ j - 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( i > 0 and j > 0 and arr [ i - 1 ] [ j - 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( i < N - 1 and arr [ i + 1 ] [ j ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( j < N - 1 and arr [ i ] [ j + 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( i < N - 1 and j < N - 1 and arr [ i + 1 ] [ j + 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( i < N - 1 and j > 0 and arr [ i + 1 ] [ j - 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( i > 0 and j < N - 1 and arr [ i - 1 ] [ j + 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( arr [ i ] [ j ] == 1 ) : NEW_LINE INDENT if ( c >= range1a and c <= range1b ) : NEW_LINE INDENT b [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT if ( c >= range0a and c <= range0b ) : NEW_LINE INDENT b [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT K -= 1 NEW_LINE for k in range ( N ) : NEW_LINE INDENT for m in range ( N ) : NEW_LINE INDENT arr [ k ] [ m ] = b [ k ] [ m ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countMoves ( n ) : NEW_LINE INDENT ct = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ct += i * ( n - i ) NEW_LINE DEDENT ct += n NEW_LINE return ct NEW_LINE DEDENT
def Triplets ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT x = i * i + j * j NEW_LINE y = int ( math . sqrt ( x ) ) NEW_LINE if ( y * y == x and y <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countTriplets ( n ) : NEW_LINE INDENT perfectSquares = getPerfectSquares ( n ** 2 ) NEW_LINE count = 0 NEW_LINE for a in range ( 1 , n + 1 ) : NEW_LINE INDENT aSquare = a ** 2 NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT cSquare = perfectSquares [ i ] NEW_LINE bSquare = abs ( cSquare - aSquare ) NEW_LINE b = math . sqrt ( bSquare ) NEW_LINE b = int ( b ) NEW_LINE c = math . sqrt ( cSquare ) NEW_LINE c = int ( c ) NEW_LINE if ( c < a or ( bSquare not in perfectSquares ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( ( b >= a ) and ( b <= c ) and ( aSquare + bSquare == cSquare ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def SumsOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE N = floor ( n / 2 ) NEW_LINE for base in range ( 2 , N + 1 , 1 ) : NEW_LINE INDENT sum = sum + solve ( n , base ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def minimumMoves ( k , l , r ) : NEW_LINE INDENT count = r - l + 1 NEW_LINE if ( count % k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( k - ( count % k ) ) NEW_LINE DEDENT
def checkPerfectcube ( n ) : NEW_LINE INDENT cube_root = n ** ( 1. / 3. ) NEW_LINE if round ( cube_root ) ** 3 == n : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def largestNonPerfectcubeNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( checkPerfectcube ( a [ i ] ) == False ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT
def sumNatural ( n ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) ) NEW_LINE return int ( sum ) NEW_LINE DEDENT
def checkIfPossibleRec ( x , a , b , isPossible , n ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return NEW_LINE DEDENT if isPossible [ x ] : NEW_LINE INDENT return NEW_LINE DEDENT isPossible [ x ] = True NEW_LINE checkIfPossibleRec ( x + a , a , b , isPossible , n ) NEW_LINE checkIfPossibleRec ( x + b , a , b , isPossible , n ) NEW_LINE DEDENT
def checkPossible ( n , a , b ) : NEW_LINE INDENT isPossible = [ False ] * ( n + 1 ) NEW_LINE checkIfPossibleRec ( 0 , a , b , isPossible , n ) NEW_LINE return isPossible [ n ] NEW_LINE DEDENT
def isDivisibleRec ( x , a , b , n ) : NEW_LINE INDENT if ( x > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return ( isDivisibleRec ( x * 10 + a , a , b , n ) or isDivisibleRec ( x * 10 + b , a , b , n ) ) NEW_LINE DEDENT
def isDivisible ( a , b , n ) : NEW_LINE INDENT return ( isDivisibleRec ( a , a , b , n ) or isDivisibleRec ( b , a , b , n ) ) NEW_LINE DEDENT
def sumOdd ( n ) : NEW_LINE INDENT terms = ( n + 1 ) // 2 NEW_LINE sum1 = terms * terms NEW_LINE return sum1 NEW_LINE DEDENT
def suminRange ( l , r ) : NEW_LINE INDENT return sumOdd ( r ) - sumOdd ( l - 1 ) NEW_LINE DEDENT
def sumNatural ( n ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) ) // 2 NEW_LINE return sum NEW_LINE DEDENT
def suminRange ( l , r ) : NEW_LINE INDENT return sumNatural ( r ) - sumNatural ( l - 1 ) NEW_LINE DEDENT
def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == prod / arr [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE freq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq . append ( arr [ i ] ) NEW_LINE prod *= arr [ i ] NEW_LINE DEDENT root = math . sqrt ( prod ) NEW_LINE if ( root * root == prod ) : NEW_LINE INDENT if root in freq : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def sumOfAllPalindrome ( L , R ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( L <= R ) : NEW_LINE INDENT for i in range ( L , R + 1 , 1 ) : NEW_LINE INDENT if ( isPalindrome ( i ) and isOddLength ( i ) ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def divisibleBy25 ( number ) : NEW_LINE INDENT if ( len ( number ) < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT length = len ( number ) NEW_LINE lastTwo = ( ( ord ( number [ length - 2 ] ) - ord ( '0' ) ) * 10 + ( ord ( number [ length - 1 ] ) - ord ( '0' ) ) ) NEW_LINE if ( lastTwo % 25 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def divisibleBy75 ( number ) : NEW_LINE INDENT if ( divisibleBy3 ( number ) and divisibleBy25 ( number ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def breakEvenPoint ( exp , S , M ) : NEW_LINE INDENT earn = S - M NEW_LINE if res != 0 : NEW_LINE INDENT res = math . ceil ( exp / earn ) NEW_LINE DEDENT else : NEW_LINE INDENT res = float ( 'inf' ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def otherNumber ( a , Lcm , Hcf ) : NEW_LINE INDENT return ( Lcm * Hcf ) // A NEW_LINE DEDENT
def sum ( a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , min ( a , b ) ) : NEW_LINE INDENT if ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def sumcommDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE sum = 0 NEW_LINE N = int ( sqrt ( n ) ) + 1 NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT else : NEW_LINE INDENT sum += ( n / i ) + i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def minimumNumbers ( n , s ) : NEW_LINE INDENT if ( s % n ) : NEW_LINE INDENT return s / n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return s / n NEW_LINE DEDENT DEDENT
def search ( arr , strt , end , value ) : NEW_LINE INDENT for i in range ( strt , end + 1 ) : NEW_LINE INDENT if ( arr [ i ] == value ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT
def checkPostorder ( node , postOrder , index ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return index NEW_LINE DEDENT index = checkPostorder ( node . left , postOrder , index ) NEW_LINE index = checkPostorder ( node . right , postOrder , index ) NEW_LINE if ( node . data == postOrder [ index ] ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return index NEW_LINE DEDENT
def sumAP ( n , d ) : NEW_LINE INDENT n = int ( n / d ) NEW_LINE return ( n ) * ( 1 + n ) * d / 2 NEW_LINE DEDENT
def sumMultiples ( A , B , n ) : NEW_LINE INDENT n -= 1 NEW_LINE common = int ( ( A * B ) / gcd ( A , B ) ) NEW_LINE return ( sumAP ( n , A ) + sumAP ( n , B ) - sumAP ( n , common ) ) NEW_LINE DEDENT
def isPossible ( n ) : NEW_LINE INDENT if isPrime ( n ) and isPrime ( n - 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def totalPairs ( arr1 , arr2 , K , n , m ) : NEW_LINE INDENT s = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT if ( arr1 [ i ] % arr2 [ j ] == K ) : NEW_LINE INDENT s [ ( arr1 [ i ] , arr2 [ j ] ) ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr2 [ j ] % arr1 [ i ] == K ) : NEW_LINE INDENT s [ ( arr2 [ j ] , arr1 [ i ] ) ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) NEW_LINE DEDENT
def contiguousPerfectSquare ( arr , n ) : NEW_LINE INDENT current_length = 0 NEW_LINE max_length = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT b = sqrt ( arr [ i ] ) NEW_LINE a = int ( b ) NEW_LINE if ( a == b ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT current_length = 0 NEW_LINE DEDENT max_length = max ( max_length , current_length ) NEW_LINE DEDENT return max_length NEW_LINE DEDENT
def getSum ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i / math . pow ( a , i ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getIndex ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ptrL = 0 NEW_LINE ptrR = n - 1 NEW_LINE sumL = a [ 0 ] NEW_LINE sumR = a [ n - 1 ] NEW_LINE while ( ptrR - ptrL > 1 ) : NEW_LINE INDENT if ( sumL < sumR ) : NEW_LINE INDENT ptrL += 1 NEW_LINE sumL += a [ ptrL ] NEW_LINE DEDENT elif ( sumL > sumR ) : NEW_LINE INDENT ptrR -= 1 NEW_LINE sumR += a [ ptrR ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ptrL NEW_LINE DEDENT
def getPosition ( a , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] // m + ( a [ i ] % m != 0 ) ) NEW_LINE DEDENT ans , maxx = - 1 , - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxx < a [ i ] ) : NEW_LINE INDENT maxx = a [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT
def calcFunction ( n , r ) : NEW_LINE INDENT finalDenominator = 1 NEW_LINE mx = max ( r , n - r ) NEW_LINE for i in range ( mx + 1 , n + 1 ) : NEW_LINE INDENT denominator = pow ( i , i ) NEW_LINE numerator = pow ( i - mx , i - mx ) NEW_LINE finalDenominator = ( finalDenominator * denominator ) // numerator NEW_LINE DEDENT return finalDenominator NEW_LINE DEDENT
def generateNumbers ( n , num , a , b ) : NEW_LINE INDENT if ( num > 0 and num < n ) : NEW_LINE INDENT st . add ( num ) NEW_LINE DEDENT if ( num >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( num * 10 + a > num ) : NEW_LINE INDENT generateNumbers ( n , num * 10 + a , a , b ) NEW_LINE DEDENT generateNumbers ( n , num * 10 + b , a , b ) NEW_LINE DEDENT
def findSmallest ( arr , n ) : NEW_LINE INDENT MAX = max ( arr ) NEW_LINE prime = findPrime ( MAX ) NEW_LINE s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT ans = - 1 NEW_LINE for i in range ( 0 , len ( prime ) ) : NEW_LINE INDENT if prime [ i ] not in s : NEW_LINE INDENT ans = prime [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minOperations ( A , n ) : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT zeros , consZeros , ones = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ i ] : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT if ( i + 1 < n ) : NEW_LINE INDENT if A [ i ] == 0 and A [ i + 1 ] == 0 : NEW_LINE INDENT consZeros += 1 NEW_LINE DEDENT DEDENT DEDENT if A [ 0 ] == A [ n - 1 ] and A [ 0 ] == 0 : NEW_LINE INDENT consZeros += 1 NEW_LINE DEDENT if zeros == ones : NEW_LINE INDENT return consZeros NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def minimumCuts ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE gcd = a [ 1 ] - a [ 0 ] NEW_LINE s = gcd NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT gcd = math . gcd ( gcd , a [ i ] - a [ i - 1 ] ) NEW_LINE s += a [ i ] - a [ i - 1 ] NEW_LINE DEDENT if ( 360 - s > 0 ) : NEW_LINE INDENT gcd = math . gcd ( gcd , 360 - s ) NEW_LINE DEDENT return ( 360 // gcd ) - n NEW_LINE DEDENT
def countdig ( m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countdig ( m // 10 ) NEW_LINE DEDENT DEDENT
def countSteps ( x ) : NEW_LINE INDENT c = 0 NEW_LINE last = x NEW_LINE while ( last ) : NEW_LINE INDENT digits = countdig ( last ) NEW_LINE digits -= 1 NEW_LINE divisor = pow ( 10 , digits ) NEW_LINE first = last // divisor NEW_LINE lastnumber = first * divisor NEW_LINE skipped = ( last - lastnumber ) // first NEW_LINE skipped += 1 NEW_LINE c += skipped NEW_LINE last = last - ( first * skipped ) NEW_LINE DEDENT return c NEW_LINE DEDENT
def findNum ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT
def profitLoss ( N , M ) : NEW_LINE INDENT if ( N == M ) : NEW_LINE INDENT print ( "No Profit nor Loss" ) NEW_LINE DEDENT else : NEW_LINE INDENT result = 0.0 NEW_LINE result = float ( abs ( N - M ) ) / M NEW_LINE if ( N - M < 0 ) : NEW_LINE INDENT print ( "Loss = -" , '{0:.6}' . format ( result * 100 ) , "%" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Profit = " , '{0:.6}' . format ( result * 100 ) , "%" ) NEW_LINE DEDENT DEDENT DEDENT
def niceIndices ( A , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ A [ i ] ] += 1 NEW_LINE Sum += A [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT k = Sum - A [ i ] NEW_LINE if k % 2 == 0 : NEW_LINE INDENT k = k >> 1 NEW_LINE if k in m : NEW_LINE INDENT if ( ( A [ i ] == k and m [ k ] > 1 ) or ( A [ i ] != k ) ) : NEW_LINE INDENT print ( ( i + 1 ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAXN ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , mt . ceil ( mt . sqrt ( MAXN + 1 ) ) ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( 2 * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def getFactorization ( x ) : NEW_LINE INDENT ret = list ( ) NEW_LINE while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE ret . append ( temp ) NEW_LINE while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT
def maxElement ( A , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = getFactorization ( A [ i ] ) NEW_LINE for i in range ( len ( p ) ) : NEW_LINE INDENT if p [ i ] in m . keys ( ) : NEW_LINE INDENT m [ p [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ p [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT cnt = 0 NEW_LINE ans = 10 ** 9 + 7 NEW_LINE for i in m : NEW_LINE INDENT if ( m [ i ] >= cnt ) : NEW_LINE INDENT cnt = m [ i ] NEW_LINE if ans > i : NEW_LINE INDENT ans = i NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countPieces ( N ) : NEW_LINE INDENT return 2 * N NEW_LINE DEDENT
def SellingPrice ( CP , PP ) : NEW_LINE INDENT Pdecimal = 1 + ( PP / 100 ) NEW_LINE res = Pdecimal * CP NEW_LINE return res NEW_LINE DEDENT
def sumMultiples ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE return int ( sumAP ( n , 3 ) + sumAP ( n , 7 ) - sumAP ( n , 21 ) ) NEW_LINE DEDENT
def productSumDivisible ( n , size ) : NEW_LINE INDENT sum = 0 NEW_LINE product = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( size % 2 == 0 ) : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT else : NEW_LINE INDENT sum += n % 10 NEW_LINE DEDENT n = n // 10 NEW_LINE size -= 1 NEW_LINE DEDENT if ( product % sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def powGCD ( a , n , b ) : NEW_LINE INDENT for i in range ( 0 , n + 1 , 1 ) : NEW_LINE INDENT a = a * a NEW_LINE DEDENT return gcd ( a , b ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def powerGCD ( a , b , n ) : NEW_LINE INDENT e = power ( a , n , b ) NEW_LINE return gcd ( e , b ) NEW_LINE DEDENT
def lastCoordinate ( n , a , b ) : NEW_LINE INDENT return ( ( ( n + 1 ) // 2 ) * a - ( n // 2 ) * b ) NEW_LINE DEDENT
def allOddDigits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def largestNumber ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT i = n NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( allOddDigits ( i ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 2 NEW_LINE DEDENT DEDENT
def findNum ( N , K ) : NEW_LINE INDENT rem = ( N + K ) % K NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return ( N + K - rem ) NEW_LINE DEDENT DEDENT
def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE product = 1 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp //= 10 NEW_LINE if ( d > 0 and n % d == 0 ) : NEW_LINE INDENT sum += d NEW_LINE product *= d NEW_LINE DEDENT DEDENT print ( "Sum =" , sum ) NEW_LINE print ( "Product =" , product ) NEW_LINE DEDENT
def findNum ( N , K ) : NEW_LINE INDENT rem = N % K NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return N - rem NEW_LINE DEDENT DEDENT
def isDivisiblePalindrome ( n ) : NEW_LINE INDENT hash = [ 0 ] * 10 NEW_LINE digitSum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT digitSum += n % 10 NEW_LINE hash [ n % 10 ] += 1 NEW_LINE n //= 10 NEW_LINE DEDENT if ( digitSum % 3 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT oddCount = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] % 2 != 0 ) : NEW_LINE INDENT oddCount += 1 NEW_LINE DEDENT DEDENT if ( oddCount > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def countNumbers ( N ) : NEW_LINE INDENT return int ( math . sqrt ( N ) ) - 1 NEW_LINE DEDENT
def countOrderedPairs ( N ) : NEW_LINE INDENT count_pairs = 0 NEW_LINE p = int ( sqrt ( N - 1 ) ) + 1 NEW_LINE q = int ( sqrt ( N ) ) + 2 NEW_LINE for i in range ( 1 , p , 1 ) : NEW_LINE INDENT for j in range ( i , q , 1 ) : NEW_LINE INDENT count_pairs += 1 NEW_LINE DEDENT DEDENT count_pairs *= 2 NEW_LINE count_pairs -= int ( sqrt ( N - 1 ) ) NEW_LINE return count_pairs NEW_LINE DEDENT
def toK ( N , K ) : NEW_LINE INDENT w = 1 NEW_LINE s = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT r = N % K NEW_LINE N = N // K NEW_LINE s = r * w + s NEW_LINE w * = 10 NEW_LINE DEDENT return s NEW_LINE DEDENT
def hasConsecutiveZeroes ( N , K ) : NEW_LINE INDENT z = toK ( N , K ) NEW_LINE if ( check ( z ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = s // 10 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor = xor ^ freq [ i ] NEW_LINE DEDENT if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // ( math . gcd ( a , b ) ) NEW_LINE DEDENT
def dfs ( src , adj , visited ) : NEW_LINE INDENT visited [ src ] = True NEW_LINE count = 1 NEW_LINE if adj [ src ] != 0 : NEW_LINE INDENT for i in range ( len ( adj [ src ] ) ) : NEW_LINE INDENT if ( not visited [ adj [ src ] [ i ] ] ) : NEW_LINE INDENT count += dfs ( adj [ src ] [ i ] , adj , visited ) NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findMinTime ( arr , P , n ) : NEW_LINE INDENT adj = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if adj [ arr [ i ] ] == 0 : NEW_LINE INDENT adj [ arr [ i ] ] = [ ] NEW_LINE DEDENT adj [ arr [ i ] ] . append ( P [ i ] ) NEW_LINE DEDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not visited [ i ] ) : NEW_LINE INDENT ans = lcm ( ans , dfs ( i , adj , visited ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= MAX ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= MAX ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def superpower ( n ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE superPower = 0 NEW_LINE factor = 0 NEW_LINE i = 2 NEW_LINE while ( n > 1 and i <= MAX ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT factor = 0 NEW_LINE while ( n % i == 0 and n > 1 ) : NEW_LINE INDENT factor += 1 NEW_LINE n = int ( n / i ) NEW_LINE DEDENT if ( superPower < factor ) : NEW_LINE INDENT superPower = factor NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return superPower NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def countPrime ( self ) : NEW_LINE INDENT count = 0 NEW_LINE ptr = self . head NEW_LINE while ptr != None : NEW_LINE INDENT if isPrime ( ptr . data ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT ptr = ptr . next NEW_LINE DEDENT return count NEW_LINE DEDENT
def pairwiseDifference ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE print ( diff , end = " " ) NEW_LINE DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT
def npr ( n , r ) : NEW_LINE INDENT pnr = factorial ( n ) / factorial ( n - r ) NEW_LINE return pnr NEW_LINE DEDENT
def countPermutations ( n , r , k ) : NEW_LINE INDENT return int ( factorial ( k ) * ( r - k + 1 ) * npr ( n - k , r - k ) ) NEW_LINE DEDENT
def sumMultiples ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE return ( int ( sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ) ) NEW_LINE DEDENT
def GIF ( n ) : NEW_LINE INDENT return int ( math . floor ( n ) ) NEW_LINE DEDENT
def ncr ( n , r ) : NEW_LINE INDENT return ( factorial ( n ) // ( factorial ( r ) * factorial ( n - r ) ) ) NEW_LINE DEDENT
def smallestDivisor ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return n NEW_LINE DEDENT
def countRabbits ( Heads , Legs ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( Legs ) - 2 * ( Heads ) NEW_LINE count = count / 2 NEW_LINE return count NEW_LINE DEDENT
def compositeProduct ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = True NEW_LINE prime [ 1 ] = True NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( max_val ) ) ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == False : NEW_LINE INDENT product *= arr [ i ] NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT
def markingScheme ( N , answerKey , studentAnswer ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 0 NEW_LINE notattempt = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( studentAnswer [ i ] == 0 ) : NEW_LINE INDENT notattempt += 1 NEW_LINE DEDENT elif ( answerKey [ i ] == studentAnswer [ i ] ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT elif ( answerKey [ i ] != studentAnswer [ i ] ) : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * 3 ) + ( negative * - 1 ) NEW_LINE DEDENT
def SumDivisible ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE position = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( position % 2 == 1 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE DEDENT n = n // 10 NEW_LINE position += 1 NEW_LINE DEDENT if ( sum % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT f = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f = f * i NEW_LINE DEDENT return f NEW_LINE DEDENT
def waysOfConsonants ( size1 , freq ) : NEW_LINE INDENT ans = fact ( size1 ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( i == 0 or i == 4 or i == 8 or i == 14 or i == 20 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans // fact ( freq [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def waysOfVowels ( size2 , freq ) : NEW_LINE INDENT return ( fact ( size2 ) // ( fact ( freq [ 0 ] ) * fact ( freq [ 4 ] ) * fact ( freq [ 8 ] ) * fact ( freq [ 14 ] ) * fact ( freq [ 20 ] ) ) ) NEW_LINE DEDENT
def countWays ( str1 ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT vowel = 0 NEW_LINE consonant = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] != 'a' and str1 [ i ] != 'e' and str1 [ i ] != 'i' and str1 [ i ] != 'o' and str1 [ i ] != 'u' ) : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT else : NEW_LINE INDENT vowel += 1 NEW_LINE DEDENT DEDENT return ( waysOfConsonants ( consonant + 1 , freq ) * waysOfVowels ( vowel , freq ) ) NEW_LINE DEDENT
def findX ( n , k ) : NEW_LINE INDENT r = n NEW_LINE m = int ( math . sqrt ( k ) ) + 1 NEW_LINE i = 2 NEW_LINE while i <= m and k > 1 : NEW_LINE INDENT if ( i == m ) : NEW_LINE INDENT i = k NEW_LINE DEDENT u = 0 NEW_LINE v = 0 NEW_LINE while k % i == 0 : NEW_LINE INDENT k //= i NEW_LINE v += 1 NEW_LINE DEDENT if ( v > 0 ) : NEW_LINE INDENT t = n NEW_LINE while ( t > 0 ) : NEW_LINE INDENT t //= i NEW_LINE u += t NEW_LINE DEDENT r = min ( r , u // v ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return r NEW_LINE DEDENT
def ncr ( n , r ) : NEW_LINE INDENT ncr = fact ( n ) // ( fact ( r ) * fact ( n - r ) ) NEW_LINE return ncr NEW_LINE DEDENT
def maxSum ( a , n ) : NEW_LINE INDENT maxAnd = max ( a ) NEW_LINE maxOR = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxOR |= a [ i ] NEW_LINE DEDENT print ( maxAnd + maxOR ) NEW_LINE DEDENT
def sum_odd ( n ) : NEW_LINE INDENT sums = 0 NEW_LINE pos = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( pos % 2 == 1 ) : NEW_LINE INDENT sums += n % 10 NEW_LINE DEDENT n = n // 10 NEW_LINE pos += 1 NEW_LINE DEDENT return sums NEW_LINE DEDENT
def check_prime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , n , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT a = int ( n ) NEW_LINE return ( 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ) NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT count , num = 0 , 1 NEW_LINE prod = 1 NEW_LINE while count < n : NEW_LINE INDENT if prime [ num ] : NEW_LINE INDENT prod *= num NEW_LINE count += 1 NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return prod NEW_LINE DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = prod // arr [ i ] NEW_LINE DEDENT DEDENT
def sum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return ( square ( int ( ( n + 1 ) / 2 ) ) + sum ( int ( n / 2 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( square ( int ( n / 2 ) ) + sum ( int ( n / 2 ) ) ) NEW_LINE DEDENT DEDENT
def oddDivSum ( a , b ) : NEW_LINE INDENT return sum ( b ) - sum ( a - 1 ) NEW_LINE DEDENT
def countBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def isPowerful ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n /= 2 NEW_LINE power += 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT p = int ( sqrt ( n ) ) + 1 NEW_LINE for factor in range ( 3 , p , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % factor == 0 ) : NEW_LINE INDENT n = n / factor NEW_LINE power += 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return ( n == 1 ) NEW_LINE DEDENT
def isPower ( a ) : NEW_LINE INDENT if ( a == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT p = int ( sqrt ( a ) ) + 1 NEW_LINE for i in range ( 2 , a , 1 ) : NEW_LINE INDENT val = log ( a ) / log ( i ) NEW_LINE if ( ( val - int ( val ) ) < 0.00000001 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def isAchillesNumber ( n ) : NEW_LINE INDENT if ( isPowerful ( n ) == True and isPower ( n ) == False ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( divCount % 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def divisor ( a ) : NEW_LINE INDENT div = 1 NEW_LINE count = 0 NEW_LINE for i in range ( 2 , int ( pow ( a , 1 / 2 ) ) + 1 ) : NEW_LINE INDENT while ( a % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE a = a / i NEW_LINE DEDENT div = div * ( count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT if ( a > 1 ) : NEW_LINE INDENT div = div * ( 2 ) NEW_LINE DEDENT return div NEW_LINE DEDENT
def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = divisor ( i ) NEW_LINE if ( divCount % 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def Check_is_possible ( l , r , k ) : NEW_LINE INDENT div_count = ( r // k ) - ( l // k ) NEW_LINE if l % k == 0 : NEW_LINE INDENT div_count += 1 NEW_LINE DEDENT return div_count > 1 NEW_LINE DEDENT
def isValid ( N , K ) : NEW_LINE INDENT m1 = [ ] NEW_LINE m2 = [ ] NEW_LINE while ( N > 0 ) : NEW_LINE INDENT m1 . append ( N % 10 ) NEW_LINE N //= 10 NEW_LINE DEDENT while ( K > 0 ) : NEW_LINE INDENT m2 . append ( K % 10 ) NEW_LINE K //= 10 NEW_LINE DEDENT if ( m1 == m2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def largestSquareFactor ( num ) : NEW_LINE INDENT answer = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( num ) ) ) : NEW_LINE INDENT cnt = 0 NEW_LINE j = i NEW_LINE while ( num % j == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE j *= i NEW_LINE DEDENT if ( cnt & 1 ) : NEW_LINE INDENT cnt -= 1 NEW_LINE answer *= pow ( i , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT answer *= pow ( i , cnt ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT
def checkUnusual ( n ) : NEW_LINE INDENT factor = largestPrimeFactor ( n ) NEW_LINE if factor > sqrt ( n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def printPossible ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c ) % 2 != 0 or a + b < c ) : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT DEDENT
def isChangeable ( notes , n ) : NEW_LINE INDENT fiveCount = 0 NEW_LINE tenCount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( notes [ i ] == 5 ) : NEW_LINE INDENT fiveCount += 1 NEW_LINE DEDENT elif ( notes [ i ] == 10 ) : NEW_LINE INDENT if ( fiveCount > 0 ) : NEW_LINE INDENT fiveCount -= 1 NEW_LINE tenCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( fiveCount > 0 and tenCount > 0 ) : NEW_LINE INDENT fiveCount -= 1 NEW_LINE tenCount -= 1 NEW_LINE DEDENT elif ( fiveCount >= 3 ) : NEW_LINE INDENT fiveCount -= 3 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 1 NEW_LINE DEDENT
def sumSubarrayMins ( A , n ) : NEW_LINE INDENT left , right = [ None ] * n , [ None ] * n NEW_LINE s1 , s2 = [ ] , [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cnt = 1 NEW_LINE while len ( s1 ) > 0 and s1 [ - 1 ] [ 0 ] > A [ i ] : NEW_LINE INDENT cnt += s1 [ - 1 ] [ 1 ] NEW_LINE s1 . pop ( ) NEW_LINE DEDENT s1 . append ( [ A [ i ] , cnt ] ) NEW_LINE left [ i ] = cnt NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT cnt = 1 NEW_LINE while len ( s2 ) > 0 and s2 [ - 1 ] [ 0 ] >= A [ i ] : NEW_LINE INDENT cnt += s2 [ - 1 ] [ 1 ] NEW_LINE s2 . pop ( ) NEW_LINE DEDENT s2 . append ( [ A [ i ] , cnt ] ) NEW_LINE right [ i ] = cnt NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result += A [ i ] * left [ i ] * right [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def isPerfectPower ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT for x in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT y = 2 NEW_LINE p = pow ( x , y ) NEW_LINE while p <= n and p > 0 : NEW_LINE INDENT if p == n : NEW_LINE INDENT return True NEW_LINE DEDENT y += 1 NEW_LINE p = pow ( x , y ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def isTrojan ( n ) : NEW_LINE INDENT return isPerfectPower ( n ) == False and isStrongNumber ( n ) NEW_LINE DEDENT
def Nth_Term ( n ) : NEW_LINE INDENT return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) // 6 NEW_LINE DEDENT
def Sum_upto_nth_Term ( n ) : NEW_LINE INDENT return ( 1 - pow ( - 2 , n ) ) NEW_LINE DEDENT
def Nth_Term ( n ) : NEW_LINE INDENT return ( 3 * pow ( n , 2 ) - n + 2 ) // ( 2 ) NEW_LINE DEDENT
def countPermutations ( N , B ) : NEW_LINE INDENT x = B ** N NEW_LINE y = B ** ( N - 1 ) NEW_LINE print ( x - y ) NEW_LINE DEDENT
def calculateDifference ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = ( max_val + 1 ) * [ True ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT P1 = 1 NEW_LINE P2 = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT P1 *= arr [ i ] NEW_LINE DEDENT elif arr [ i ] != 1 : NEW_LINE INDENT P2 *= arr [ i ] NEW_LINE DEDENT DEDENT return abs ( P2 - P1 ) NEW_LINE DEDENT
def CalculateDifference ( arr , n ) : NEW_LINE INDENT max_val = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_val ) : NEW_LINE INDENT max_val = arr [ i ] NEW_LINE DEDENT DEDENT prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= max_val ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT S1 = 0 NEW_LINE S2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT elif arr [ i ] != 1 : NEW_LINE INDENT S2 += arr [ i ] NEW_LINE DEDENT DEDENT return abs ( S2 - S1 ) NEW_LINE DEDENT
def EqualNumbers ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT if ( sum % n ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT return n NEW_LINE DEDENT
def getMin ( arr , n , k ) : NEW_LINE INDENT res = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT res = min ( res , arr [ i ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def getMax ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT res = max ( res , arr [ i ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def printNumberWithDR ( k , d ) : NEW_LINE INDENT if d == 0 and k != 1 : NEW_LINE INDENT print ( - 1 , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d , end = "" ) NEW_LINE k -= 1 NEW_LINE while k : NEW_LINE INDENT print ( 0 , end = "" ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT
def count_odd_pair ( n , a ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT even = even + 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT DEDENT ans = odd * even * 2 NEW_LINE return ans NEW_LINE DEDENT
def count_even_pair ( odd_sum_pairs , n ) : NEW_LINE INDENT total_pairs = ( n * ( n - 1 ) ) NEW_LINE ans = total_pairs - odd_sum_pairs NEW_LINE return ans NEW_LINE DEDENT
def findSteps ( n , m , a ) : NEW_LINE INDENT cur = 1 NEW_LINE steps = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( a [ i ] >= cur ) : NEW_LINE INDENT steps += ( a [ i ] - cur ) NEW_LINE DEDENT else : NEW_LINE INDENT steps += ( n - cur + a [ i ] ) NEW_LINE DEDENT cur = a [ i ] NEW_LINE DEDENT return steps NEW_LINE DEDENT
def xorEqualsOrCount ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT bit = N % 2 NEW_LINE if bit == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT N //= 2 NEW_LINE DEDENT return int ( pow ( 2 , count ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n * fact ( n - 1 ) NEW_LINE DEDENT DEDENT
def sum ( x , n ) : NEW_LINE INDENT total = 1.0 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT total = total + ( pow ( x , i ) / fact ( i + 1 ) ) NEW_LINE DEDENT return total NEW_LINE DEDENT
def sum ( x , n ) : NEW_LINE INDENT total = 1.0 NEW_LINE previous = 1.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT previous = ( previous * x ) / ( i + 1 ) NEW_LINE total = total + previous NEW_LINE DEDENT return total NEW_LINE DEDENT
def isPowerOfTwo ( x ) : NEW_LINE INDENT return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE DEDENT
def Count_pairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if isPowerOfTwo ( a [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = ( count * ( count - 1 ) ) / 2 NEW_LINE print ( ans ) NEW_LINE DEDENT
def numberOfDivisors ( num ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( numberOfDivisors ( i ) == 9 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT c = 0 NEW_LINE limit = int ( n ** ( 0.5 ) ) NEW_LINE prime = [ i for i in range ( limit + 1 ) ] NEW_LINE i = 2 NEW_LINE while i * i <= limit : NEW_LINE INDENT if prime [ i ] == i : NEW_LINE INDENT for j in range ( i * i , limit + 1 , i ) : NEW_LINE INDENT if prime [ j ] == j : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT p = prime [ i ] NEW_LINE q = prime [ i // prime [ i ] ] NEW_LINE if p * q == i and q != 1 and p != q : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif prime [ i ] == i : NEW_LINE INDENT if i ** 8 <= n : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT
def sumNth ( A , B , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + A [ i ] NEW_LINE DEDENT DEDENT elif ( n == 2 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + B [ i ] * m NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = [ 0 ] * n NEW_LINE f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT res = ( res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result *= i NEW_LINE DEDENT return result NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return ( factorial ( n ) // ( factorial ( r ) * factorial ( n - r ) ) ) NEW_LINE DEDENT
def calculate_result ( n ) : NEW_LINE INDENT result = 2 * nCr ( ( n - 2 ) , ( n // 2 - 1 ) ) NEW_LINE return result NEW_LINE DEDENT
def isHalfReducible ( arr , n , m ) : NEW_LINE INDENT frequencyHash = [ 0 ] * ( m + 1 ) NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT frequencyHash [ ( arr [ i ] % ( m + 1 ) ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while ( i <= m ) : NEW_LINE INDENT if ( frequencyHash [ i ] >= ( n / 2 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i <= m ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def generateDivisors ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( n ** ( 0.5 ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n // i == i : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT arr . append ( i ) NEW_LINE arr . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT
def harmonicMean ( n ) : NEW_LINE INDENT generateDivisors ( n ) NEW_LINE Sum = 0 NEW_LINE length = len ( arr ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT Sum = Sum + ( n / arr [ i ] ) NEW_LINE DEDENT Sum = Sum / n NEW_LINE return length / Sum NEW_LINE DEDENT
def isOreNumber ( n ) : NEW_LINE INDENT mean = harmonicMean ( n ) NEW_LINE if mean - int ( mean ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def sum_of_series ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT result = result - pow ( i , 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result + pow ( i , 2 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def sum_of_series ( n ) : NEW_LINE INDENT result = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT result = - ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT result = ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT return result NEW_LINE DEDENT
def digitProduct ( digits , start , end ) : NEW_LINE INDENT pro = 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT pro *= digits [ i ] NEW_LINE DEDENT return pro NEW_LINE DEDENT
def numberOfDistinct ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE if ( ( n // i ) != i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT i = p * 2 NEW_LINE while i <= MAX : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT sum [ i ] = 1 NEW_LINE DEDENT sum [ i ] += sum [ i - 1 ] NEW_LINE DEDENT DEDENT
def calculateAlternateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 0 ] = 0 NEW_LINE fibo [ 1 ] = 1 NEW_LINE sum = pow ( fibo [ 0 ] , 2 ) + pow ( fibo [ 1 ] , 2 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT sum -= fibo [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += fibo [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def getValue ( n ) : NEW_LINE INDENT i = 0 NEW_LINE k = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT i = i + k NEW_LINE k = k * 2 NEW_LINE DEDENT return int ( k / 2 ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def ulam ( ) : NEW_LINE INDENT arr . append ( 1 ) NEW_LINE arr . append ( 2 ) NEW_LINE for i in range ( 3 , MAX ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( len ( arr ) - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ j ] + arr [ k ] == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count > 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( count > 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( count == 1 ) : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT DEDENT DEDENT
def nthKyneaNumber ( n ) : NEW_LINE INDENT n = ( 1 << n ) + 1 NEW_LINE n = n * n NEW_LINE n = n - 2 NEW_LINE return n NEW_LINE DEDENT
def nthKyneaNumber ( n ) : NEW_LINE INDENT return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) NEW_LINE DEDENT
def isProthNumber ( n ) : NEW_LINE INDENT k = 1 NEW_LINE while ( k < ( n // k ) ) : NEW_LINE INDENT if ( n % k == 0 ) : NEW_LINE INDENT if ( isPowerOfTwo ( n // k ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT k = k + 2 NEW_LINE DEDENT return False NEW_LINE int n = 25 NEW_LINE DEDENT
def isInterprime ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_prime = n NEW_LINE next_prime = n NEW_LINE while ( isPrime ( prev_prime ) == 0 ) : NEW_LINE INDENT prev_prime = prev_prime - 1 NEW_LINE DEDENT while ( isPrime ( next_prime ) == 0 ) : NEW_LINE INDENT next_prime = next_prime + 1 NEW_LINE DEDENT if ( ( prev_prime + next_prime ) == 2 * n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT
def isThabitNumber ( n ) : NEW_LINE INDENT n = n + 1 NEW_LINE if ( n % 3 == 0 ) : NEW_LINE INDENT n = n // 3 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT if ( isPowerOfTwo ( n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def get_last_two_digit ( N ) : NEW_LINE INDENT if N <= 10 : NEW_LINE INDENT ans = 0 NEW_LINE fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE DEDENT ans = ans % 100 NEW_LINE return ans NEW_LINE DEDENT else : NEW_LINE INDENT return 13 NEW_LINE DEDENT DEDENT
def isProductEven ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ i ] & 1 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def calculateSquareSum ( n ) : NEW_LINE INDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo [ 0 ] = 0 NEW_LINE fibo [ 1 ] = 1 NEW_LINE sum = ( ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = ( fibo [ i - 1 ] + fibo [ i - 2 ] ) NEW_LINE sum += ( fibo [ i ] * fibo [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 or n == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if f [ n ] : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT if n & 1 : NEW_LINE INDENT k = ( n + 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n // 2 NEW_LINE DEDENT if n & 1 : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT
def calculateSumOfSquares ( n ) : NEW_LINE INDENT return fib ( n ) * fib ( n + 1 ) NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT array = [ 0 ] * ( N + 1 ) NEW_LINE array [ 0 ] = 1 NEW_LINE array [ 1 ] = 1 NEW_LINE for i in range ( 2 , math . ceil ( math . sqrt ( N ) + 1 ) ) : NEW_LINE INDENT if array [ i ] == 0 : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT array [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT runningPrimeSum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if array [ i ] == 0 : NEW_LINE INDENT runningPrimeSum += i NEW_LINE DEDENT dp [ i ] = runningPrimeSum NEW_LINE DEDENT DEDENT
def fnMod ( n ) : NEW_LINE INDENT rem = n % 4 NEW_LINE if ( rem == 0 or rem == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( rem == 1 or rem == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT
def MinimumMoves ( a , n , x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= a [ i - 1 ] : NEW_LINE INDENT p = ( a [ i - 1 ] - a [ i ] ) // x + 1 NEW_LINE ans += p NEW_LINE a [ i ] += p * x NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def SumOfDigits ( str , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += int ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isPrime ( k ) : NEW_LINE INDENT if ( k <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , k ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def check ( num , k ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , k ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT if ( num % k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def findCount ( a , b , k ) : NEW_LINE INDENT count = 0 NEW_LINE if ( not isPrime ( k ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT ans = check ( i , k ) NEW_LINE if ( ans == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findMinEqualSums ( a , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum = sum + a [ i ] NEW_LINE DEDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE min = sys . maxsize NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE sum2 = sum - sum1 NEW_LINE if ( abs ( sum1 - sum2 ) < min ) : NEW_LINE INDENT min = abs ( sum1 - sum2 ) NEW_LINE DEDENT if ( min == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT
def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT
def NumberOfSolutions ( x , y , z , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT temp = n - i - j NEW_LINE if temp >= 0 : NEW_LINE INDENT temp = min ( temp , z ) NEW_LINE ans += temp + 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT count = 0 NEW_LINE num = 1 NEW_LINE total = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT if ( prime [ num ] ) : NEW_LINE INDENT total = total + num NEW_LINE count = count + 1 NEW_LINE DEDENT num = num + 1 NEW_LINE DEDENT return total NEW_LINE DEDENT
def fact ( p ) : NEW_LINE INDENT if ( p <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return p * fact ( p - 1 ) NEW_LINE DEDENT
def findNum ( n , a , b ) : NEW_LINE INDENT result = 0 NEW_LINE aCount = 0 NEW_LINE bCount = 0 NEW_LINE return findNumUtil ( result , a , aCount , b , bCount , n ) NEW_LINE DEDENT
def findkth ( n , k ) : NEW_LINE INDENT v1 = list ( ) NEW_LINE v2 = list ( ) NEW_LINE for i in range ( 1 , mt . ceil ( n ** ( .5 ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE if ( i != mt . ceil ( mt . sqrt ( n ) ) ) : NEW_LINE INDENT v2 . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT v2 [ : : - 1 ] NEW_LINE if ( k > ( len ( v1 ) + len ( v2 ) ) ) : NEW_LINE INDENT print ( "Doesn't Exist" , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k <= len ( v1 ) ) : NEW_LINE INDENT print ( v1 [ k - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v2 [ k - len ( v1 ) - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT
def NumberOfSolutions ( a , b , c , d ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if d >= max ( c , i + 1 ) : NEW_LINE INDENT ans += d - max ( c , i + 1 ) + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def CountDigits ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT sum += ma . log ( i , 10 ) NEW_LINE DEDENT sum *= n NEW_LINE return ma . ceil ( sum ) NEW_LINE DEDENT
def findNumber ( n , d ) : NEW_LINE INDENT ans = "" NEW_LINE if ( d != 10 ) : NEW_LINE INDENT ans += str ( d ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans += '0' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT ans += "Impossible" NEW_LINE DEDENT else : NEW_LINE INDENT ans += '1' NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans += '0' NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countDigits ( val , arr ) : NEW_LINE INDENT while ( val > 0 ) : NEW_LINE INDENT digit = val % 10 NEW_LINE arr [ int ( digit ) ] += 1 NEW_LINE val = val // 10 NEW_LINE DEDENT return NEW_LINE DEDENT
def countFrequency ( x , n ) : NEW_LINE INDENT freq_count = [ 0 ] * 10 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT val = math . pow ( x , i ) NEW_LINE countDigits ( val , freq_count ) NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( freq_count [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if sieve_Prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if sieve_Prime [ j ] == 0 : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return n ** 2 + 4 * n NEW_LINE DEDENT
def NthTerm ( N ) : NEW_LINE INDENT x = ( 3 * N * N ) % 1000000009 NEW_LINE return ( ( x - N + 1000000009 ) % 1000000009 ) NEW_LINE DEDENT
def PowerOfTwo ( ) : NEW_LINE INDENT x = 1 NEW_LINE for i in range ( 31 ) : NEW_LINE INDENT power [ i ] = x NEW_LINE x *= 2 NEW_LINE DEDENT pre [ 0 ] = 1 NEW_LINE for i in range ( 1 , 31 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + power [ i ] NEW_LINE DEDENT DEDENT
def Sum ( n ) : NEW_LINE INDENT ans = n * ( n + 1 ) // 2 NEW_LINE for i in range ( 31 ) : NEW_LINE INDENT if ( power [ i ] > n ) : NEW_LINE INDENT ans -= 2 * pre [ i - 1 ] NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def checkSemiPrime ( n ) : NEW_LINE INDENT i = 0 NEW_LINE while arr [ i ] <= n // 2 : NEW_LINE INDENT if sprime [ n - arr [ i ] ] == True : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def sum ( N ) : NEW_LINE INDENT global S1 , S2 , S3 NEW_LINE S1 = ( ( ( N // 3 ) ) * ( 2 * 3 + ( N // 3 - 1 ) * 3 ) // 2 ) NEW_LINE S2 = ( ( ( N // 4 ) ) * ( 2 * 4 + ( N // 4 - 1 ) * 4 ) // 2 ) NEW_LINE S3 = ( ( ( N // 12 ) ) * ( 2 * 12 + ( N // 12 - 1 ) * 12 ) // 2 ) NEW_LINE return int ( S1 + S2 - S3 ) NEW_LINE DEDENT
def nextGreater ( N ) : NEW_LINE INDENT power_of_2 = 1 NEW_LINE shift_count = 0 NEW_LINE while ( True ) : NEW_LINE INDENT if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT shift_count += 1 NEW_LINE power_of_2 = power_of_2 * 2 NEW_LINE DEDENT return ( N + power_of_2 ) NEW_LINE DEDENT
def area ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = 3.14 * pow ( r / ( 2 * sqrt ( 2 ) ) , 2 ) NEW_LINE return area NEW_LINE DEDENT
def area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = pow ( ( a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) NEW_LINE return area NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( N ) ) ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( 2 * p , N , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def almostPrimes ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 6 , n + 1 ) : NEW_LINE INDENT c = 0 NEW_LINE for j in range ( 2 , int ( sqrt ( i ) ) + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if j * j == i : NEW_LINE INDENT if prime [ j ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if prime [ j ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if prime [ i // j ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if c == 2 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def heightCalculate ( H , n , m ) : NEW_LINE INDENT N = n * 1.0 NEW_LINE M = m * 1.0 NEW_LINE h = H * sqrt ( N / ( N + M ) ) NEW_LINE return h NEW_LINE DEDENT
def numberOfSolutions ( n ) : NEW_LINE INDENT c = 0 NEW_LINE for x in range ( n + 1 ) : NEW_LINE INDENT if ( n == ( x + ( n ^ x ) ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT
def findNumber ( n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT count = [ 0 for i in range ( 10 ) ] NEW_LINE x = i NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE while ( x ) : NEW_LINE INDENT count [ x % 10 ] += 1 NEW_LINE x = int ( x / 10 ) NEW_LINE count1 += 1 NEW_LINE DEDENT for j in range ( 0 , 10 , 1 ) : NEW_LINE INDENT if ( count [ j ] == 1 ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT DEDENT if ( count1 == count2 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT
def isprime ( x ) : NEW_LINE INDENT for i in range ( 2 , math . sqrt ( x ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isNSqMinusnMSqPrime ( m , n ) : NEW_LINE INDENT if ( n - m == 1 and isprime ( m + n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def countNumbers ( N ) : NEW_LINE INDENT return ( pow ( 10 , N ) - pow ( 8 , N ) ) // 2 NEW_LINE DEDENT
def buildPrefix ( ) : NEW_LINE INDENT prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT prefix [ 0 ] = 0 NEW_LINE prefix [ 1 ] = 0 NEW_LINE for p in range ( 2 , MAX + 1 , 1 ) : NEW_LINE INDENT prefix [ p ] = prefix [ p - 1 ] NEW_LINE if ( prime [ p ] ) : NEW_LINE INDENT prefix [ p ] += p NEW_LINE DEDENT DEDENT DEDENT
def sumPrimeRange ( L , R ) : NEW_LINE INDENT buildPrefix ( ) NEW_LINE return prefix [ R ] - prefix [ L - 1 ] NEW_LINE DEDENT
def findPosition ( n , f , b ) : NEW_LINE INDENT return n - max ( f + 1 , n - b ) + 1 NEW_LINE DEDENT
def nthOdd ( n ) : NEW_LINE INDENT return ( 2 * n - 1 ) NEW_LINE DEDENT
def countSolutions ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a + 1 ) : NEW_LINE INDENT if ( a == ( i + ( a ^ i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countSolutions ( a ) : NEW_LINE INDENT count = bin ( a ) . count ( '1' ) NEW_LINE return 2 ** count NEW_LINE DEDENT
def isPermutation ( first , second ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE mul1 = 1 NEW_LINE mul2 = 1 NEW_LINE temp1 = first NEW_LINE while ( temp1 != None ) : NEW_LINE INDENT sum1 += temp1 . data NEW_LINE mul1 *= temp1 . data NEW_LINE temp1 = temp1 . next NEW_LINE DEDENT temp2 = second NEW_LINE while ( temp2 != None ) : NEW_LINE INDENT sum2 += temp2 . data NEW_LINE mul2 *= temp2 . data NEW_LINE temp2 = temp2 . next NEW_LINE DEDENT return ( ( sum1 == sum2 ) and ( mul1 == mul2 ) ) NEW_LINE DEDENT
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] , isPrime [ 1 ] = False , False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if isPrime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findPrimePair ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE isPrime = [ False ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT x = int ( n / i ) NEW_LINE if ( isPrime [ i ] & isPrime [ x ] and x != i and x * i == n ) : NEW_LINE INDENT print ( i , x ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT print ( "No such pair found" ) NEW_LINE DEDENT DEDENT
def solveProportion ( a , b1 , b2 , c ) : NEW_LINE INDENT A = a * b2 NEW_LINE B = b1 * b2 NEW_LINE C = b1 * c NEW_LINE gcd1 = math . gcd ( math . gcd ( A , B ) , C ) NEW_LINE print ( str ( A // gcd1 ) + ":" + str ( B // gcd1 ) + ":" + str ( C // gcd1 ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + n - 3 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 5 * pow ( n , 2 ) - 5 * n NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + 2 * n - 5 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 3 * n - 5 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) - 4 * n + 2 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 4 * pow ( n , 2 ) - 3 * n + 2 NEW_LINE DEDENT
def isProduct ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 2 NEW_LINE while cnt < 2 and i * i <= num : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT num //= i NEW_LINE cnt += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt == 2 NEW_LINE DEDENT
def findNumbers ( N ) : NEW_LINE INDENT vec = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( isProduct ( i ) and not isPerfectSquare ( i ) ) : NEW_LINE INDENT vec . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( len ( vec ) ) : NEW_LINE INDENT print ( vec [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 and i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 3 ) + pow ( n , 2 ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) // 2 + pow ( ( n * ( n + 1 ) // 2 ) , 2 ) ) NEW_LINE DEDENT
def volume ( r , h ) : NEW_LINE INDENT return ( 1 / 3 ) * pi * r * r * h NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) // 2 + n * ( n + 1 ) * ( 2 * n + 1 ) // 6 ) NEW_LINE DEDENT
def maxDistance ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE maxDict = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT maxDict = max ( maxDict , i - mp [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT return maxDict NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) // 6 ) + n * ( n + 1 ) // 2 + 2 * ( n ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) - n - 1 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return int ( 6 * pow ( n , 2 ) - 4 * n - 2 ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 4 * pow ( n , 2 ) - 7 * n + 3 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return pow ( n , 2 ) + 2 * n + 2 NEW_LINE DEDENT
def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( ( b * b ) - ( 4 * a * c ) ) > 0 : NEW_LINE INDENT print ( "2 solutions" ) NEW_LINE DEDENT elif ( ( b * b ) - ( 4 * a * c ) ) == 0 : NEW_LINE INDENT print ( "1 solution" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No solutions" ) NEW_LINE DEDENT DEDENT
def Bytes ( kilobytes ) : NEW_LINE INDENT Bytes = kilobytes * 1024 NEW_LINE return Bytes NEW_LINE DEDENT
def NthTerm ( N ) : NEW_LINE INDENT
def sum ( n ) : NEW_LINE INDENT ans = ( n * ( n - 1 ) ) / 2 NEW_LINE return ans NEW_LINE DEDENT
def getNthTerm ( N ) : NEW_LINE INDENT return ( pow ( N , 2 ) + N + 1 ) NEW_LINE DEDENT
def findSum ( N ) : NEW_LINE INDENT return ( ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ) NEW_LINE DEDENT
def getNthTerm ( N ) : NEW_LINE INDENT return 4 * pow ( N , 2 ) - 3 * N + 2 NEW_LINE DEDENT
def findCosNTheta ( sinTheta , n ) : NEW_LINE INDENT
def findSum ( n ) : NEW_LINE INDENT sum2 = ( ( n // 2 ) * ( 4 + ( n // 2 - 1 ) * 2 ) ) // 2 NEW_LINE sum5 = ( ( n // 5 ) * ( 10 + ( n // 5 - 1 ) * 5 ) ) // 2 NEW_LINE sum10 = ( ( n // 10 ) * ( 20 + ( n // 10 - 1 ) * 10 ) ) // 2 NEW_LINE return sum2 + sum5 - sum10 NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT return ( ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ) NEW_LINE DEDENT
def binomial ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT nCr [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findTanNTheta ( tanTheta , n ) : NEW_LINE INDENT numerator = 0 NEW_LINE denominator = 1 NEW_LINE ans = 0 NEW_LINE toggle = 1 NEW_LINE for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT numerator = ( numerator + nCr [ n ] [ i ] * ( tanTheta ** ( i ) ) * toggle ) NEW_LINE toggle = toggle * - 1 NEW_LINE DEDENT toggle = - 1 NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT numerator = ( numerator + nCr [ n ] [ i ] * ( tanTheta ** i ) * toggle ) NEW_LINE toggle = toggle * - 1 NEW_LINE DEDENT ans = numerator / denominator NEW_LINE return ans NEW_LINE DEDENT
def product ( n ) : NEW_LINE INDENT v = [ [ ] ] * ( n + 100 ) NEW_LINE factors ( n + 100 , v ) NEW_LINE if ( n % 4 == 0 ) : NEW_LINE INDENT x = n // 4 NEW_LINE x *= x NEW_LINE return x * x NEW_LINE DEDENT else : NEW_LINE INDENT if ( isPrime [ n ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE if ( len ( v [ n ] ) > 2 ) : NEW_LINE INDENT fac = v [ n ] [ len ( v [ n ] ) - 3 ] NEW_LINE for i in range ( len ( v [ n ] - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( len ( v [ n ] - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT if ( ( fac * 2 ) + ( v [ n ] [ j ] + v [ n ] [ i ] ) == n ) : NEW_LINE INDENT ans = max ( ans , fac * fac * v [ n ] [ j ] * v [ n ] [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT DEDENT DEDENT
def arePermutations ( a , b , n , m ) : NEW_LINE INDENT sum1 , sum2 , mul1 , mul2 = 0 , 0 , 1 , 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE mul1 *= a [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT sum2 += b [ i ] NEW_LINE mul2 *= b [ i ] NEW_LINE DEDENT return ( ( sum1 == sum2 ) and ( mul1 == mul2 ) ) NEW_LINE DEDENT
def binomial ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT  DEDENT DEDENT DEDENT
def findCosnTheta ( cosTheta , n ) : NEW_LINE INDENT sinTheta = math . sqrt ( 1 - cosTheta * cosTheta ) NEW_LINE ans = 0 NEW_LINE DEDENT
def CalculateRatio ( m , n ) : NEW_LINE INDENT return ( 2 * m - 1 ) / ( 2 * n - 1 ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while y > 0 : NEW_LINE INDENT if y & 1 : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def sumProd ( n , t ) : NEW_LINE INDENT dino = power ( t + 1 , MOD - 2 , MOD ) NEW_LINE ans = 1 NEW_LINE for i in range ( n + t + 1 , n , - 1 ) : NEW_LINE INDENT ans = ( ans % MOD * i % MOD ) % MOD NEW_LINE DEDENT tfact = 1 NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT tfact = ( tfact * i ) % MOD NEW_LINE DEDENT ans = ans * dino - tfact + MOD NEW_LINE return ans % MOD NEW_LINE DEDENT
def sumOfDigitsSingle ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while x : NEW_LINE INDENT ans += x % 10 NEW_LINE x //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sumOfDigitsTwoParts ( N ) : NEW_LINE INDENT A = closest ( N ) NEW_LINE return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) NEW_LINE DEDENT
def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = floor ( N ** ( 1 / 3 ) ) + 1 NEW_LINE return nextN ** 3 NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT return math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT
def sum ( x , y , n ) : NEW_LINE INDENT sum1 = ( ( x ** 2 ) * ( x ** ( 2 * n ) - 1 ) ) // ( x ** 2 - 1 ) NEW_LINE sum2 = ( x * y * ( x ** n * y ** n - 1 ) ) // ( x * y - 1 ) NEW_LINE return ( sum1 + sum2 ) NEW_LINE DEDENT
def powerDigitSum ( a , n ) : NEW_LINE INDENT res = 1 NEW_LINE while ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT res = res * digSum ( a ) NEW_LINE res = digSum ( res ) NEW_LINE DEDENT a = digSum ( digSum ( a ) * digSum ( a ) ) NEW_LINE n //= 2 NEW_LINE DEDENT return res NEW_LINE DEDENT
def printPair ( g , l ) : NEW_LINE INDENT print ( g , l ) NEW_LINE DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE max_count = 1 NEW_LINE res = arr [ 0 ] NEW_LINE curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT curr_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT DEDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def findMaximumPieces ( n ) : NEW_LINE INDENT return int ( 1 + n * ( n + 1 ) / 2 ) NEW_LINE DEDENT
def power ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res *= a NEW_LINE res %= mod NEW_LINE DEDENT b //= 2 NEW_LINE a *= a NEW_LINE a %= mod NEW_LINE DEDENT return res NEW_LINE DEDENT
def minPlayer ( n , k ) : NEW_LINE INDENT num = ( ( power ( k , n ) - 1 ) + mod ) % mod NEW_LINE den = ( power ( k - 1 , mod - 2 ) + mod ) % mod NEW_LINE ans = ( ( ( num * den ) % mod ) * k ) % mod NEW_LINE return ans NEW_LINE DEDENT
def sieve ( N ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( i * j > N ) : NEW_LINE INDENT break NEW_LINE DEDENT prime [ i * j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countLogNeeded ( N ) : NEW_LINE INDENT count = 0 NEW_LINE sieve ( N ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def rmsValue ( arr , n ) : NEW_LINE INDENT square = 0 NEW_LINE mean = 0.0 NEW_LINE root = 0.0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT square += ( arr [ i ] ** 2 ) NEW_LINE DEDENT mean = ( square / ( float ) ( n ) ) NEW_LINE root = math . sqrt ( mean ) NEW_LINE return root NEW_LINE DEDENT
def Mixture ( X , Y , Z ) : NEW_LINE INDENT result = 0.0 NEW_LINE result1 = 0.0 NEW_LINE result1 = ( ( X - Y ) / X ) NEW_LINE result = pow ( result1 , Z ) NEW_LINE result = result * X NEW_LINE return result NEW_LINE DEDENT
def coin ( totalRupees , X , Y , Z ) : NEW_LINE INDENT one = X * 1 NEW_LINE fifty = ( ( Y * 1 ) / 2.0 ) NEW_LINE twentyfive = ( ( Z * 1 ) / 4.0 ) NEW_LINE total = one + fifty + twentyfive NEW_LINE result = ( ( totalRupees ) / total ) NEW_LINE return int ( result ) NEW_LINE DEDENT
def sumOfSeries ( x , k ) : NEW_LINE INDENT return ( float ( x ) / 81 ) * ( 9 * k - 1 + 10 ** ( ( - 1 ) * k ) ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT a1 = 1 NEW_LINE a2 = 2 NEW_LINE r = 2 NEW_LINE d = 1 NEW_LINE return ( ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( pow ( r , n ) - 1 ) / ( r - 1 ) ) NEW_LINE DEDENT
def findProduct ( n ) : NEW_LINE INDENT product = - 1 NEW_LINE si = len ( factors ) NEW_LINE for i in range ( si ) : NEW_LINE INDENT for j in range ( si ) : NEW_LINE INDENT for k in range ( si ) : NEW_LINE INDENT for l in range ( si ) : NEW_LINE INDENT s = ( factors [ i ] + factors [ j ] + factors [ k ] + factors [ l ] ) NEW_LINE if ( s == n ) : NEW_LINE INDENT p = ( factors [ i ] * factors [ j ] * factors [ k ] * factors [ l ] ) NEW_LINE if ( p > product ) : NEW_LINE INDENT product = p NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return product NEW_LINE DEDENT
def modExp ( a , b ) : NEW_LINE INDENT result = 1 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( int ( b ) & 1 ) : NEW_LINE INDENT result = result * a NEW_LINE DEDENT a = a * a NEW_LINE b /= 2 NEW_LINE DEDENT return result NEW_LINE DEDENT
def check ( num ) : NEW_LINE INDENT if ( num & 1 or num < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( num % 4 == 0 ) : NEW_LINE INDENT return modExp ( num / 4 , 4 ) NEW_LINE DEDENT elif ( num % 6 == 0 ) : NEW_LINE INDENT return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 ) NEW_LINE DEDENT elif ( num % 10 == 0 ) : NEW_LINE INDENT return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if prime [ i ] == False : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , ( N + 1 ) // i , 2 ) : NEW_LINE INDENT if prime [ i * j ] == False : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def findSum ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE ans = 1 NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE currFactor = s [ N ] NEW_LINE power = 1 NEW_LINE while N > 1 : NEW_LINE INDENT N //= s [ N ] NEW_LINE if currFactor == s [ N ] : NEW_LINE INDENT power += 1 NEW_LINE continue NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( power + 1 ) : NEW_LINE INDENT sum += pow ( currFactor , i ) NEW_LINE DEDENT ans *= sum NEW_LINE currFactor = s [ N ] NEW_LINE power = 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countMultiples ( n ) : NEW_LINE INDENT multiple = [ 2 , 3 , 5 ] NEW_LINE count = 0 NEW_LINE mask = int ( pow ( 2 , 3 ) ) NEW_LINE for i in range ( 1 , mask ) : NEW_LINE INDENT prod = 1 NEW_LINE for j in range ( 3 ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT prod = prod * multiple [ j ] NEW_LINE DEDENT DEDENT if ( bin ( i ) . count ( '1' ) % 2 == 1 ) : NEW_LINE INDENT count = count + n // prod NEW_LINE DEDENT else : NEW_LINE INDENT count = count - n // prod NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def Race ( B , C ) : NEW_LINE INDENT result = 0 NEW_LINE result = ( ( C * 100 ) // B ) NEW_LINE return 100 - result NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n -= d * 5 NEW_LINE DEDENT return ( n % 17 == 0 ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( 2 ** ( n + 1 ) + n - 2 ) NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and not ( n and ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while n != 0 : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT
def removeElement ( n ) : NEW_LINE INDENT if n == 1 or n == 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = nextPowerOf2 ( n ) NEW_LINE if n == a or n == a - 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n == a - 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) NEW_LINE DEDENT
def bridge_length ( trainLength , Speed , Time ) : NEW_LINE INDENT return ( ( Time * Speed ) - trainLength ) NEW_LINE DEDENT
def findN ( k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif ( k % 4 == 0 ) : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def repeatedSum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 9 if ( n % 9 == 0 ) else ( n % 9 ) NEW_LINE DEDENT
def repeatedProduct ( n ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( n > 0 or prod > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = prod NEW_LINE prod = 1 NEW_LINE DEDENT prod *= n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return prod NEW_LINE DEDENT
def maxSumProduct ( N ) : NEW_LINE INDENT if ( N < 10 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( repeatedSum ( N ) , repeatedProduct ( N ) ) NEW_LINE DEDENT
def Circular ( n ) : NEW_LINE INDENT Result = 1 NEW_LINE while n > 0 : NEW_LINE INDENT Result = Result * n NEW_LINE n -= 1 NEW_LINE DEDENT return Result NEW_LINE DEDENT
def Time ( arr , n , Emptypipe ) : NEW_LINE INDENT fill = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT fill += ( 1 / arr [ i ] ) NEW_LINE DEDENT fill = fill - ( 1 / float ( Emptypipe ) ) NEW_LINE return int ( 1 / fill ) NEW_LINE DEDENT
def smallestSubsegment ( a , n ) : NEW_LINE INDENT left = dict ( ) NEW_LINE count = dict ( ) NEW_LINE mx = 0 NEW_LINE mn , strindex = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE if ( x not in count . keys ( ) ) : NEW_LINE INDENT left [ x ] = i NEW_LINE count [ x ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ x ] += 1 NEW_LINE DEDENT if ( count [ x ] > mx ) : NEW_LINE INDENT mx = count [ x ] NEW_LINE mn = i - left [ x ] + 1 NEW_LINE strindex = left [ x ] NEW_LINE DEDENT elif ( count [ x ] == mx and i - left [ x ] + 1 < mn ) : NEW_LINE INDENT mn = i - left [ x ] + 1 NEW_LINE strindex = left [ x ] NEW_LINE DEDENT DEDENT for i in range ( strindex , strindex + mn ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def modInv ( x ) : NEW_LINE INDENT n = MOD - 2 NEW_LINE result = 1 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT result = result * x % MOD NEW_LINE DEDENT x = x * x % MOD NEW_LINE n = int ( n / 2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def getSum ( n , k ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( n + 1 , n - k , - 1 ) : NEW_LINE INDENT ans = ans * i % MOD NEW_LINE DEDENT ans = ans * modInv ( k + 1 ) % MOD NEW_LINE return ans NEW_LINE DEDENT
def calculateAreaSum ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE maxSize = min ( l , b ) NEW_LINE totalArea = 0 NEW_LINE for i in range ( 1 , maxSize + 1 ) : NEW_LINE INDENT totalSquares = ( ( l - size + 1 ) * ( b - size + 1 ) ) NEW_LINE area = ( totalSquares * size * size ) NEW_LINE totalArea += area NEW_LINE size += 1 NEW_LINE DEDENT return totalArea NEW_LINE DEDENT
def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 ) : NEW_LINE INDENT for k in range ( 1 , n ) : NEW_LINE INDENT if ( k % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , k ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
def printCombination ( n ) : NEW_LINE INDENT print ( "1 " , end = "" ) NEW_LINE if ( ( n - 2 ) % 3 == 0 ) : NEW_LINE INDENT print ( "2" , n - 3 , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "1" , ( n - 2 ) , end = "" ) NEW_LINE DEDENT DEDENT
def Loss ( costPrice , sellingPrice ) : NEW_LINE INDENT Loss = ( costPrice - sellingPrice ) NEW_LINE return Loss NEW_LINE DEDENT
def isPalindrome ( n ) : NEW_LINE INDENT if n % 11 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def percent ( a , b ) : NEW_LINE INDENT result = int ( ( ( b - a ) * 100 ) / a ) NEW_LINE return result NEW_LINE DEDENT
def nextPerfectSquare ( N ) : NEW_LINE INDENT nextN = math . floor ( math . sqrt ( N ) ) + 1 NEW_LINE return nextN * nextN NEW_LINE DEDENT
def Smallest_prime_factor ( ) : NEW_LINE INDENT for i in range ( 1 , MAXN ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while i * i <= MAXN : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 2 NEW_LINE DEDENT DEDENT
def Digit_Sum ( copy ) : NEW_LINE INDENT d = 0 NEW_LINE while ( copy ) : NEW_LINE INDENT d += copy % 10 NEW_LINE copy //= 10 NEW_LINE DEDENT return d NEW_LINE DEDENT
def Sum_Of_All_Digits ( ) : NEW_LINE INDENT for n in range ( 2 , MAXN ) : NEW_LINE INDENT sum_digits [ n ] = ( sum_digits [ n // spf [ n ] ] + Digit_Sum ( spf [ n ] ) ) NEW_LINE if ( Digit_Sum ( n ) == sum_digits [ n ] ) : NEW_LINE INDENT isValid [ n ] = True NEW_LINE DEDENT DEDENT for n in range ( 2 , MAXN ) : NEW_LINE INDENT if ( isValid [ n ] ) : NEW_LINE INDENT ans [ n ] = 1 NEW_LINE DEDENT ans [ n ] += ans [ n - 1 ] NEW_LINE DEDENT DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if k > n - k : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res // ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return c // ( n + 1 ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT i , c = 0 , 0 NEW_LINE for i in range ( 1 , n // 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def prevComplement ( n , b ) : NEW_LINE INDENT maxNum , digits , num = 0 , 0 , n NEW_LINE while n > 1 : NEW_LINE INDENT digits += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT maxDigit = b - 1 NEW_LINE while digits : NEW_LINE INDENT maxNum = maxNum * 10 + maxDigit NEW_LINE digits -= 1 NEW_LINE DEDENT return maxNum - num NEW_LINE DEDENT
def complement ( n , b ) : NEW_LINE INDENT return prevComplement ( n , b ) + 1 NEW_LINE DEDENT
def isFascinating ( num ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE val = ( str ( num ) + str ( num * 2 ) + str ( num * 3 ) ) NEW_LINE for i in range ( len ( val ) ) : NEW_LINE INDENT digit = int ( val [ i ] ) NEW_LINE if freq [ digit ] and digit != 0 > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT freq [ digit ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if freq [ i ] == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def binomial_coefficient ( n , m ) : NEW_LINE INDENT res = 1 NEW_LINE if m > n - m : NEW_LINE INDENT m = n - m NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def computeTotient ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , N ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , N , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def CoPrimes ( ) : NEW_LINE INDENT computeTotient ( ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT S [ i ] = S [ i - 1 ] + phi [ i ] NEW_LINE DEDENT DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT
def previousPowerOfTwo ( n ) : NEW_LINE INDENT while ( n & n - 1 ) : NEW_LINE INDENT n = n & n - 1 NEW_LINE DEDENT return n NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def MaximumDivisors ( X , Y ) : NEW_LINE INDENT arr = [ 0 ] * ( Y - X + 1 ) NEW_LINE mx = 0 NEW_LINE cnt = 0 NEW_LINE i = 1 NEW_LINE while i * i <= Y : NEW_LINE INDENT sq = i * i NEW_LINE if ( ( X // i ) * i >= X ) : NEW_LINE INDENT first_divisible = ( X // i ) * i NEW_LINE DEDENT else : NEW_LINE INDENT first_divisible = ( X // i + 1 ) * i NEW_LINE DEDENT for j in range ( first_divisible , Y + 1 , i ) : NEW_LINE INDENT if j < sq : NEW_LINE INDENT continue NEW_LINE DEDENT elif j == sq : NEW_LINE INDENT arr [ j - X ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ j - X ] += 2 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( X , Y + 1 ) : NEW_LINE INDENT if arr [ i - X ] > mx : NEW_LINE INDENT cnt = 1 NEW_LINE mx = arr [ i - X ] NEW_LINE DEDENT elif arr [ i - X ] == mx : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while y > 0 : NEW_LINE INDENT if y & 1 : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def NearestElement ( A , D , P ) : NEW_LINE INDENT if A == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif D == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT X = power ( D , P - 2 , P ) NEW_LINE return ( X * ( P - A ) ) % P NEW_LINE DEDENT DEDENT
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE l = len ( num ) NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base NEW_LINE DEDENT base = base * 2 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT
def numberSequence ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT s = "" NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += '1' NEW_LINE DEDENT s += '0' NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s += '1' NEW_LINE DEDENT num = binaryToDecimal ( s ) NEW_LINE return num NEW_LINE DEDENT
def numberSequence ( n ) : NEW_LINE INDENT num = pow ( 4 , n ) - pow ( 2 , n ) - 1 NEW_LINE return num NEW_LINE DEDENT
def complement ( num ) : NEW_LINE INDENT i = 0 NEW_LINE len = 0 NEW_LINE comp = 0 NEW_LINE temp = num NEW_LINE while ( 1 ) : NEW_LINE INDENT len += 1 NEW_LINE num = int ( num / 10 ) NEW_LINE if ( abs ( num ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT num = temp NEW_LINE comp = math . pow ( 10 , len ) - num NEW_LINE return int ( comp ) NEW_LINE DEDENT
def calculate ( array , size ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( array [ i ] % 2 == 0 and array [ i ] != 0 and array [ i ] != 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def prime ( num ) : NEW_LINE INDENT flag = 0 NEW_LINE for i in range ( 2 , num // 2 + 1 ) : NEW_LINE INDENT if num % i == 0 : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def print_alternate_prime ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for num in range ( 2 , n ) : NEW_LINE INDENT if prime ( num ) == 1 : NEW_LINE INDENT if counter % 2 == 0 : NEW_LINE INDENT print ( num , end = " " ) NEW_LINE DEDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT
def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime = [ None ] * ( n + 1 ) NEW_LINE for i in range ( len ( prime ) ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT flag = True NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT print ( str ( p ) , end = " " ) NEW_LINE flag = False NEW_LINE DEDENT else : NEW_LINE INDENT flag = True NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findGreater ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def max_profit ( a , b , n , fee ) : NEW_LINE INDENT i , j , profit = 1 , n - 1 , 0 NEW_LINE l , r , diff_day = 0 , 0 , 1 NEW_LINE b [ 0 ] = 0 NEW_LINE b [ 1 ] = diff_day NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = diff_day NEW_LINE Sum = 0 NEW_LINE for j in range ( n - 1 , i - 1 , - 1 ) : NEW_LINE INDENT profit = ( a [ r ] - a [ l ] ) - fee NEW_LINE if ( profit > 0 ) : NEW_LINE INDENT Sum = Sum + profit NEW_LINE DEDENT l += 1 NEW_LINE r += 1 NEW_LINE DEDENT if ( b [ 0 ] < Sum ) : NEW_LINE INDENT b [ 0 ] = Sum NEW_LINE b [ 1 ] = diff_day NEW_LINE DEDENT DEDENT diff_day += 1 NEW_LINE return 0 NEW_LINE DEDENT
def binomialCoeff ( x , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE term = 1 NEW_LINE i = 1 NEW_LINE while ( i <= n and sum < k ) : NEW_LINE INDENT term *= x - i + 1 NEW_LINE term /= i NEW_LINE sum += term NEW_LINE i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def minTrials ( n , k ) : NEW_LINE INDENT low = 1 NEW_LINE high = k NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( binomialCoeff ( mid , n , k ) < k ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT return int ( low ) NEW_LINE DEDENT
def preprocess ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT num = i NEW_LINE for j in range ( 2 , ceil ( sqrt ( num ) ) + 1 ) : NEW_LINE INDENT if ( num % j == 0 ) : NEW_LINE INDENT v [ i ] . append ( j ) NEW_LINE while ( num % j == 0 ) : NEW_LINE INDENT num = num // j NEW_LINE DEDENT DEDENT DEDENT if ( num > 2 ) : NEW_LINE INDENT v [ i ] . append ( num ) NEW_LINE DEDENT DEDENT DEDENT
def query ( number , n ) : NEW_LINE INDENT return v [ number ] [ n - 1 ] NEW_LINE DEDENT
def getsum ( a ) : NEW_LINE INDENT r = 0 NEW_LINE sum = 0 NEW_LINE while ( a > 0 ) : NEW_LINE INDENT r = a % 10 NEW_LINE sum = sum + r NEW_LINE a = a // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def boost_hyperfactorial ( num ) : NEW_LINE INDENT val = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT val = val * pow ( i , i ) NEW_LINE DEDENT return val NEW_LINE DEDENT
def boost_hyperfactorial ( num ) : NEW_LINE INDENT val = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT val *= i NEW_LINE DEDENT DEDENT return val NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if ( ( A [ i ] % 2 == 1 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count * ( count - 1 ) / 2 NEW_LINE DEDENT
def summ ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 9 == 0 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n % 9 ) NEW_LINE DEDENT DEDENT
def printDigitalRoot ( n ) : NEW_LINE INDENT maxi = 1 NEW_LINE dig = 1 NEW_LINE for i in range ( 1 , int ( pow ( n , 1 / 2 ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT d1 = summ ( n / i ) NEW_LINE d2 = summ ( i ) NEW_LINE if ( d1 > maxi ) : NEW_LINE INDENT dig = n / i NEW_LINE maxi = d1 NEW_LINE DEDENT if ( d2 > maxi ) : NEW_LINE INDENT dig = i NEW_LINE maxi = d2 NEW_LINE DEDENT if ( d1 == maxi ) : NEW_LINE INDENT if ( dig < ( n / i ) ) : NEW_LINE INDENT dig = n / i NEW_LINE maxi = d1 NEW_LINE DEDENT DEDENT if ( d2 == maxi ) : NEW_LINE INDENT if ( dig < i ) : NEW_LINE INDENT dig = i NEW_LINE maxi = d2 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( int ( dig ) , " " , int ( maxi ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def isSurd ( n ) : NEW_LINE INDENT i = 2 NEW_LINE for i in range ( 2 , ( i * i ) + 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n ) : NEW_LINE INDENT j = j * i NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def LastTwoDigit ( num ) : NEW_LINE INDENT one = num % 10 NEW_LINE num //= 10 NEW_LINE tens = num % 10 NEW_LINE tens *= 10 NEW_LINE num = tens + one NEW_LINE return num NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def modPower ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def gcdPow ( a , n , c ) : NEW_LINE INDENT if ( a % c == 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT modexpo = modPower ( a , n , c ) NEW_LINE return gcd ( modexpo , c ) NEW_LINE DEDENT
def countOddSum ( ar , n ) : NEW_LINE INDENT temp = [ 1 , 0 ] NEW_LINE result = 0 NEW_LINE val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = ( ( val + ar [ i ] ) % 2 + 2 ) % 2 NEW_LINE temp [ val ] += 1 NEW_LINE DEDENT result = ( temp [ 0 ] * temp [ 1 ] ) NEW_LINE return ( result ) NEW_LINE DEDENT
def countOddSum ( a , n ) : NEW_LINE INDENT c_odd = 0 NEW_LINE result = 0 NEW_LINE odd = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT if ( odd == True ) : NEW_LINE INDENT odd = False NEW_LINE DEDENT else : NEW_LINE INDENT odd = True NEW_LINE DEDENT DEDENT if ( odd ) : NEW_LINE INDENT c_odd += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT result += c_odd NEW_LINE if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT c_odd = ( n - i - c_odd ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def findNthRoot ( x , n ) : NEW_LINE INDENT x = float ( x ) NEW_LINE n = int ( n ) NEW_LINE if ( x >= 0 and x <= 1 ) : NEW_LINE INDENT low = x NEW_LINE high = 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = 1 NEW_LINE high = x NEW_LINE DEDENT epsilon = 0.00000001 NEW_LINE guess = ( low + high ) / 2 NEW_LINE while abs ( guess ** n - x ) >= epsilon : NEW_LINE INDENT if guess ** n > x : NEW_LINE INDENT high = guess NEW_LINE DEDENT else : NEW_LINE INDENT low = guess NEW_LINE DEDENT guess = ( low + high ) / 2 NEW_LINE DEDENT print ( guess ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def Sum ( N ) : NEW_LINE INDENT SumOfPrimeDivisors = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( SumOfPrimeDivisors [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N + 1 , i ) : NEW_LINE INDENT SumOfPrimeDivisors [ j ] += i NEW_LINE DEDENT DEDENT DEDENT return SumOfPrimeDivisors [ N ] NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE root_n = ( int ) ( math . sqrt ( n ) ) NEW_LINE for i in range ( 1 , root_n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i == ( int ) ( n / i ) and isPrime ( i ) ) : NEW_LINE INDENT Sum += i NEW_LINE DEDENT else : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT Sum += i NEW_LINE DEDENT if ( isPrime ( ( int ) ( n / i ) ) ) : NEW_LINE INDENT Sum += ( int ) ( n / i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return Sum NEW_LINE DEDENT
def rangesum ( n , l , r ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE c = 1 NEW_LINE i = 0 NEW_LINE while ( c <= n ) : NEW_LINE INDENT arr [ i ] = c NEW_LINE i += 1 NEW_LINE c += 2 NEW_LINE DEDENT c = 2 NEW_LINE while ( c <= n ) : NEW_LINE INDENT arr [ i ] = c NEW_LINE i += 1 NEW_LINE c += 2 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( l - 1 , r , 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumeven ( n , l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE mid = n // 2 NEW_LINE if ( r <= mid ) : NEW_LINE INDENT first = ( 2 * l - 1 ) NEW_LINE last = ( 2 * r - 1 ) NEW_LINE no_of_terms = r - l + 1 NEW_LINE sum = ( ( no_of_terms ) * ( ( first + last ) ) ) // 2 NEW_LINE DEDENT elif ( l >= mid ) : NEW_LINE INDENT first = ( 2 * ( l - n // 2 ) ) NEW_LINE last = ( 2 * ( r - n // 2 ) ) NEW_LINE no_of_terms = r - l + 1 NEW_LINE sum = ( ( no_of_terms ) * ( ( first + last ) ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT sumleft , sumright = 0 , 0 NEW_LINE first_term1 = ( 2 * l - 1 ) NEW_LINE last_term1 = ( 2 * ( n // 2 ) - 1 ) NEW_LINE no_of_terms1 = n // 2 - l + 1 NEW_LINE sumleft = ( ( ( no_of_terms1 ) * ( ( first_term1 + last_term1 ) ) ) // 2 ) NEW_LINE first_term2 = 2 NEW_LINE last_term2 = ( 2 * ( r - n // 2 ) ) NEW_LINE no_of_terms2 = r - mid NEW_LINE sumright = ( ( ( no_of_terms2 ) * ( ( first_term2 + last_term2 ) ) ) // 2 ) NEW_LINE sum = ( sumleft + sumright ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumodd ( n , l , r ) : NEW_LINE INDENT mid = n // 2 + 1 NEW_LINE sum = 0 NEW_LINE if ( r <= mid ) : NEW_LINE INDENT first = ( 2 * l - 1 ) NEW_LINE last = ( 2 * r - 1 ) NEW_LINE no_of_terms = r - l + 1 NEW_LINE sum = ( ( ( no_of_terms ) * ( ( first + last ) ) ) // 2 ) NEW_LINE DEDENT elif ( l > mid ) : NEW_LINE INDENT first = ( 2 * ( l - mid ) ) NEW_LINE last = ( 2 * ( r - mid ) ) NEW_LINE no_of_terms = r - l + 1 NEW_LINE sum = ( ( ( no_of_terms ) * ( ( first + last ) ) ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT sumleft , sumright = 0 , 0 NEW_LINE first_term1 = ( 2 * l - 1 ) NEW_LINE last_term1 = ( 2 * mid - 1 ) NEW_LINE no_of_terms1 = mid - l + 1 NEW_LINE sumleft = ( ( ( no_of_terms1 ) * ( ( first_term1 + last_term1 ) ) ) // 2 ) NEW_LINE first_term2 = 2 NEW_LINE last_term2 = ( 2 * ( r - mid ) ) NEW_LINE no_of_terms2 = r - mid NEW_LINE sumright = ( ( ( no_of_terms2 ) * ( ( first_term2 + last_term2 ) ) ) // 2 ) NEW_LINE sum = ( sumleft + sumright ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def rangesum ( n , l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT return sumeven ( n , l , r ) NEW_LINE DEDENT else : NEW_LINE INDENT return sumodd ( n , l , r ) NEW_LINE DEDENT DEDENT
def groupElements ( arr , n ) : NEW_LINE INDENT visited = [ False ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE visited [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def rainDayProbability ( a , n ) : NEW_LINE INDENT count = a . count ( 1 ) NEW_LINE m = count / n NEW_LINE return m NEW_LINE DEDENT
def distance ( x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT d = math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) + math . pow ( z2 - z1 , 2 ) * 1.0 ) NEW_LINE print ( "Distance is " ) NEW_LINE print ( d ) NEW_LINE DEDENT
def DivisibleBy41 ( first , second , c , n ) : NEW_LINE INDENT digit = [ 0 ] * n NEW_LINE digit [ 0 ] = first NEW_LINE digit [ 1 ] = second NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 NEW_LINE DEDENT ans = digit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = ( ans * 10 + digit [ i ] ) % 41 NEW_LINE DEDENT if ( ans % 41 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def findTetrahedralNumber ( n ) : NEW_LINE INDENT return ( int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) ) NEW_LINE DEDENT
def printSeries ( n ) : NEW_LINE INDENT prev = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT curr = findTetrahedralNumber ( i ) NEW_LINE curr = curr + prev NEW_LINE print ( curr , end = ' ' ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT
def printSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = int ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) // 24 ) NEW_LINE print ( num , end = ' ' ) NEW_LINE DEDENT DEDENT
def findTriangularNumber ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) / 2 NEW_LINE DEDENT
def printSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = i * ( i + 1 ) * ( i + 2 ) // 6 NEW_LINE print ( num , end = ' ' ) NEW_LINE DEDENT DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT
def findArea ( a ) : NEW_LINE INDENT area = 5 * sqrt ( 3 ) * a * a NEW_LINE return area NEW_LINE DEDENT
def findVolume ( a ) : NEW_LINE INDENT volume = ( ( 5 / 12 ) * ( 3 + sqrt ( 5 ) ) * a * a * a ) NEW_LINE return volume NEW_LINE DEDENT
def findNthNonSquare ( n ) : NEW_LINE INDENT x = n NEW_LINE ans = x + math . floor ( 0.5 + math . sqrt ( x ) ) NEW_LINE return int ( ans ) NEW_LINE DEDENT
def count_even_odd ( min , max , steps ) : NEW_LINE INDENT beven = True NEW_LINE aeven = False NEW_LINE n = 2 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a = steps [ i ] [ 0 ] NEW_LINE b = steps [ i ] [ 1 ] NEW_LINE if ( not ( aeven or a & 1 ) ) : NEW_LINE INDENT aeven = True NEW_LINE DEDENT if ( beven ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT beven = False NEW_LINE DEDENT DEDENT elif ( not ( a & 1 ) ) : NEW_LINE INDENT if ( not ( b & 1 ) ) : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT DEDENT if ( beven ) : NEW_LINE INDENT even = ( int ( max / 2 ) - int ( ( min - 1 ) / 2 ) ) NEW_LINE odd = 0 NEW_LINE DEDENT else : NEW_LINE INDENT even = ( int ( max / 2 ) - int ( ( min - 1 ) / 2 ) ) NEW_LINE odd = 0 NEW_LINE DEDENT if ( not ( beven ^ aeven ) ) : NEW_LINE INDENT even += ( max - min + 1 - int ( max / 2 ) + int ( ( min - 1 ) / 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT odd += ( max - min + 1 - int ( max / 2 ) + int ( ( min - 1 ) / 2 ) ) NEW_LINE DEDENT print ( "even = " , even , ", odd = " , odd , sep = "" ) NEW_LINE DEDENT
def getMaxOnes ( n , x ) : NEW_LINE INDENT zeroes = ( int ) ( n / x ) NEW_LINE zeroes = zeroes * zeroes NEW_LINE total = n * n NEW_LINE ans = total - zeroes NEW_LINE return ans NEW_LINE DEDENT
def ways ( n ) : NEW_LINE INDENT first = 2 NEW_LINE second = 3 NEW_LINE res = 0 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT res = first + second NEW_LINE first = second NEW_LINE second = res NEW_LINE DEDENT return res NEW_LINE DEDENT
def minimumOperations ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for it in mp : NEW_LINE INDENT if ( mp [ it ] > 1 ) : NEW_LINE INDENT count += mp [ it ] - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findVolume ( a , h ) : NEW_LINE INDENT Volume = 0 NEW_LINE Volume = ( 3 * math . sqrt ( 3 ) * a * a * h / 2 ) NEW_LINE print ( "Volume:" , round ( Volume , 3 ) ) NEW_LINE DEDENT
def MinimumMail ( n , k , x ) : NEW_LINE INDENT m = ( ( n - 1 ) + int ( math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + math . ceil ( n * 1.0 / x ) * ( k - n ) ) ) NEW_LINE return m NEW_LINE DEDENT
def findAllSequence ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return ( pow ( 2 , N / 2 + 1 ) + pow ( 2 , N / 2 ) - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( pow ( 2 , ( N + 1 ) / 2 ) + pow ( 2 , ( N + 1 ) / 2 ) - 2 ) NEW_LINE DEDENT DEDENT
def computeTotient ( ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , N + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def calculate ( x , k , mod ) : NEW_LINE INDENT arr = [ 0 for i in range ( N ) ] NEW_LINE count = 0 NEW_LINE while ( mod > 1 ) : NEW_LINE INDENT arr [ count ] = mod NEW_LINE count += 1 NEW_LINE mod = phi [ mod ] NEW_LINE DEDENT result = 1 NEW_LINE loop = count + 1 NEW_LINE arr [ count ] = 1 NEW_LINE for i in range ( min ( k , loop ) , - 1 , - 1 ) : NEW_LINE INDENT result = power ( x , result , arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def countOnes ( n ) : NEW_LINE INDENT count = 1 NEW_LINE rem = 1 NEW_LINE while ( rem != 0 ) : NEW_LINE INDENT rem = ( rem * 10 + 1 ) % n NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def fibonacci ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT fib = ( ( pow ( ( 1 + math . sqrt ( 5 ) ) , i ) - pow ( ( 1 - math . sqrt ( 5 ) ) , i ) ) / ( pow ( 2 , i ) * math . sqrt ( 5 ) ) ) NEW_LINE print ( int ( fib ) , end = " " ) NEW_LINE DEDENT DEDENT
def findLCM ( a , b ) : NEW_LINE INDENT lar = max ( a , b ) NEW_LINE small = min ( a , b ) NEW_LINE i = lar NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( i % small == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += lar NEW_LINE DEDENT DEDENT
def center_hexadecagonal_num ( n ) : NEW_LINE INDENT return 8 * n * n - 8 * n + 1 NEW_LINE DEDENT
def findNature ( a , b , n ) : NEW_LINE INDENT seq = [ 0 ] * MAX NEW_LINE seq [ 0 ] = a NEW_LINE seq [ 1 ] = b NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] NEW_LINE DEDENT return ( seq [ n ] & 1 ) NEW_LINE DEDENT
def findNature ( a , b , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( a & 1 ) NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( b & 1 ) NEW_LINE DEDENT if ( ( a & 1 ) == 0 ) : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True if ( n % 3 != 0 ) else False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return True if ( ( n - 1 ) % 3 != 0 ) else False NEW_LINE DEDENT else : NEW_LINE INDENT return True if ( ( n + 1 ) % 3 != 0 ) else False NEW_LINE DEDENT DEDENT DEDENT
def check ( m , n ) : NEW_LINE INDENT RHS = m * math . log ( n ) NEW_LINE LHS = n * math . log ( m ) NEW_LINE if ( LHS > RHS ) : NEW_LINE INDENT print ( "m^n > n^m" ) NEW_LINE DEDENT elif ( LHS < RHS ) : NEW_LINE INDENT print ( "m^n < n^m" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "m^n = n^m" ) NEW_LINE DEDENT DEDENT
def numberOfmeet ( a , b ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( a > b ) : NEW_LINE INDENT ans = a - b NEW_LINE DEDENT else : NEW_LINE INDENT ans = b - a NEW_LINE DEDENT if ( a < 0 ) : NEW_LINE INDENT a = a * ( - 1 ) NEW_LINE DEDENT if ( b < 0 ) : NEW_LINE INDENT b = b * ( - 1 ) NEW_LINE DEDENT return int ( ans / math . gcd ( a , b ) ) NEW_LINE DEDENT
def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True for i in range ( MAX ) ] NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT return primes NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def maxDivisorRange ( a , b , l , h ) : NEW_LINE INDENT g = gcd ( a , b ) NEW_LINE res = - 1 NEW_LINE i = l NEW_LINE while ( i * i <= g and i <= h ) : NEW_LINE INDENT if ( g % i == 0 ) : NEW_LINE INDENT res = max ( res , max ( i , g / i ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return int ( res ) NEW_LINE DEDENT
def findMaxGCD ( arr , n , k ) : NEW_LINE INDENT high = max ( arr ) NEW_LINE divisors = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , int ( math . sqrt ( arr [ i ] ) ) + 1 ) : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE if ( j != arr [ i ] // j ) : NEW_LINE INDENT divisors [ arr [ i ] // j ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( high , 0 , - 1 ) : NEW_LINE INDENT if ( divisors [ i ] >= k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT
def primes ( n ) : NEW_LINE INDENT i , j = 2 , 0 NEW_LINE result = [ ] NEW_LINE while j < n : NEW_LINE INDENT flag = True NEW_LINE for item in range ( 2 , int ( i ** 0.5 ) + 1 ) : NEW_LINE INDENT if i % item == 0 and i != item : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT result . append ( i ) NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
def subtractOne ( x ) : NEW_LINE INDENT m = 1 NEW_LINE while ( ( x & m ) == False ) : NEW_LINE INDENT x = x ^ m NEW_LINE m = m << 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT
def subtractOne ( x ) : NEW_LINE INDENT return ( ( x << 1 ) + ( ~ x ) ) NEW_LINE DEDENT
def Log2n ( n ) : NEW_LINE INDENT return ( 1 + Log2n ( n / 2 ) ) if ( n > 1 ) else 0 NEW_LINE DEDENT
def isPowerOfd ( n , d ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return ( count % ( Log2n ( d ) ) == 0 ) NEW_LINE DEDENT return False NEW_LINE DEDENT
def meanVector ( mat ) : NEW_LINE INDENT print ( "[ " , end = "" ) NEW_LINE for i in range ( rows ) : NEW_LINE INDENT mean = 0.00 NEW_LINE sum = 0 NEW_LINE for j in range ( cols ) : NEW_LINE INDENT sum = sum + mat [ j ] [ i ] NEW_LINE mean = int ( sum / rows ) NEW_LINE print ( mean , end = " " ) NEW_LINE print ( "]" ) NEW_LINE DEDENT DEDENT DEDENT
def findMissing ( a , b , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( a [ i ] == b [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == m - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def countDigits ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += math . log10 ( i ) NEW_LINE DEDENT ans = ans * n NEW_LINE return 1 + math . floor ( ans ) NEW_LINE DEDENT
def checksum ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT print ( "-2 -1 0 1 2" ) NEW_LINE return 0 NEW_LINE DEDENT inc = 0 NEW_LINE if n > 0 : NEW_LINE INDENT inc = 1 NEW_LINE DEDENT else : NEW_LINE INDENT inc = - 1 NEW_LINE DEDENT for i in range ( 0 , n - 3 , inc ) : NEW_LINE INDENT if i + i + 1 + i + 2 + i + 3 + i + 4 == n : NEW_LINE INDENT print ( i , " " , i + 1 , " " , i + 2 , " " , i + 3 , " " , i + 4 ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT print ( "-1" ) NEW_LINE DEDENT
def checksum ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if n % 5 == 0 : NEW_LINE INDENT print ( int ( n / 5 - 2 ) , " " , int ( n / 5 - 1 ) , " " , int ( n / 5 ) , " " , int ( n / 5 + 1 ) , " " , int ( n / 5 + 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def printGreater ( x , y ) : NEW_LINE INDENT X = y * math . log ( x ) NEW_LINE Y = x * math . log ( y ) NEW_LINE if ( abs ( X - Y ) < 1e-9 ) : NEW_LINE INDENT print ( "Equal" ) NEW_LINE DEDENT elif ( X > Y ) : NEW_LINE INDENT print ( x , "^" , y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( y , "^" , x ) NEW_LINE DEDENT DEDENT
def dfs ( i ) : NEW_LINE INDENT if ( visited [ i ] == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT visited [ i ] = 1 NEW_LINE x = dfs ( goesTo [ i ] ) NEW_LINE return ( x + 1 ) NEW_LINE DEDENT
def noOfTranspositions ( P , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT visited [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT goesTo [ P [ i ] ] = i + 1 NEW_LINE DEDENT transpositions = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT ans = dfs ( i ) NEW_LINE transpositions += ans - 1 NEW_LINE DEDENT DEDENT return transpositions NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans + i * i * i * i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findMissing ( a , b , n , m ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT s [ b [ i ] ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in s . keys ( ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def countUnmarked ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return N / 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N / 2 + 1 NEW_LINE DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def calculateSeries ( n ) : NEW_LINE INDENT return factorial ( n + 1 ) - 1 NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE i = 2 NEW_LINE for i in ( n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def Pentatope_number ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) // 24 ) NEW_LINE DEDENT
def minimumLength ( x , y , z ) : NEW_LINE INDENT return ( 1 + abs ( x - y ) + abs ( y - z ) ) NEW_LINE DEDENT
def areEquivalent ( num1 , num2 ) : NEW_LINE INDENT return divSum ( num1 ) == divSum ( num2 ) NEW_LINE DEDENT
def dodecahedral_num ( n ) : NEW_LINE INDENT return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) // 2 NEW_LINE DEDENT
def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) // 2 NEW_LINE DEDENT
def centeredIcosahedralNum ( n ) : NEW_LINE INDENT return ( ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) // 3 ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ = ( summ + ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ) NEW_LINE DEDENT return summ NEW_LINE DEDENT
def checkHankelMatrix ( n , m ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) NEW_LINE DEDENT
def Centered_Triangular_num ( n ) : NEW_LINE INDENT return ( 3 * n * n + 3 * n + 2 ) // 2 NEW_LINE DEDENT
def Dodecagonal_number ( n ) : NEW_LINE INDENT return 5 * n * n - 4 * n NEW_LINE DEDENT
def check ( d , x ) : NEW_LINE INDENT if ( bit ( x / d ) <= bit ( d ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def countDivisor ( n ) : NEW_LINE INDENT return n - bs ( n ) + 1 NEW_LINE DEDENT
def isPower ( n ) : NEW_LINE INDENT for x in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT f = math . log ( n ) / math . log ( x ) NEW_LINE if ( ( f - int ( f ) ) == 0.0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def wrapper ( q , n ) : NEW_LINE INDENT global N , digitSum , factorDigitSum NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT digitSum [ i ] = 0 NEW_LINE factorDigitSum [ i ] = 0 NEW_LINE DEDENT sumOddDigit ( ) NEW_LINE sumFactor ( ) NEW_LINE for i in range ( 0 , q ) : NEW_LINE INDENT print ( "{} " . format ( factorDigitSum [ n [ i ] ] ) , end = "" ) NEW_LINE DEDENT DEDENT
def everMeet ( x1 , x2 , v1 , v2 ) : NEW_LINE INDENT if ( x1 < x2 and v1 <= v2 ) : NEW_LINE INDENT return False NEW_LINE if ( x1 > x2 and v1 >= v2 ) : NEW_LINE INDENT return False NEW_LINE if ( x1 < x2 ) : NEW_LINE INDENT swap ( x1 , x2 ) NEW_LINE swap ( v1 , v2 ) NEW_LINE return ( ( x1 - x2 ) % ( v1 - v2 ) == 0 ) NEW_LINE def swap ( a , b ) : NEW_LINE INDENT t = a NEW_LINE a = b NEW_LINE b = t NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def find_maximum ( a , n , k ) : NEW_LINE INDENT b = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE d = min ( 1 + i , n - i ) NEW_LINE if x not in b . keys ( ) : NEW_LINE INDENT b [ x ] = d NEW_LINE DEDENT else : NEW_LINE INDENT b [ x ] = min ( d , b [ x ] ) NEW_LINE DEDENT DEDENT ans = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE if ( x != ( k - x ) and ( k - x ) in b . keys ( ) ) : NEW_LINE INDENT ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def number_of_digits ( n ) : NEW_LINE INDENT i = 4 NEW_LINE res = 1 NEW_LINE sum = 0 NEW_LINE while ( True ) : NEW_LINE INDENT i *= 4 NEW_LINE res += 1 NEW_LINE sum += i NEW_LINE if ( sum >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def MaximumHeight ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) / 2 NEW_LINE if ( y < n ) : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def distinctGCDs ( arr , N ) : NEW_LINE INDENT M = - 1 NEW_LINE ans = 0 NEW_LINE Mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT M = max ( M , arr [ i ] ) NEW_LINE Mp [ arr [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , M + 1 , 1 ) : NEW_LINE INDENT currGcd = 0 NEW_LINE for j in range ( i , M + 1 , i ) : NEW_LINE INDENT if ( j in Mp ) : NEW_LINE INDENT currGcd = gcd ( currGcd , j ) NEW_LINE if ( currGcd == i ) : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def printCollatz ( n ) : NEW_LINE INDENT while n != 1 : NEW_LINE INDENT print ( n , end = ' ' ) NEW_LINE if n & 1 : NEW_LINE INDENT n = 3 * n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE DEDENT
def isProduct ( arr , n , x ) : NEW_LINE INDENT for i in arr : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if i * j == x : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def SieveOfEratosthenes ( n , prime , primesquare , a ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT for i in range ( ( n * n + 1 ) + 1 ) : NEW_LINE INDENT primesquare [ i ] = False NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT j = 0 NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT a [ j ] = p NEW_LINE primesquare [ p * p ] = True NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT
def countDivisors ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT prime = [ False ] * ( n + 2 ) NEW_LINE primesquare = [ False ] * ( n * n + 3 ) NEW_LINE a = [ 0 ] * n NEW_LINE SieveOfEratosthenes ( n , prime , primesquare , a ) NEW_LINE ans = 1 NEW_LINE for i in range ( 0 , True ) : NEW_LINE INDENT if ( a [ i ] * a [ i ] * a [ i ] > n ) : NEW_LINE INDENT break NEW_LINE DEDENT cnt = 1 NEW_LINE while ( n % a [ i ] == 0 ) : NEW_LINE INDENT n //= a [ i ] NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT ans = ans * cnt NEW_LINE DEDENT if ( prime [ n ] ) : NEW_LINE INDENT ans = ans * 2 NEW_LINE DEDENT elif ( primesquare [ n ] ) : NEW_LINE INDENT ans = ans * 3 NEW_LINE DEDENT elif ( n != 1 ) : NEW_LINE INDENT ans = ans * 4 NEW_LINE DEDENT DEDENT
def sumofFactors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n //= i NEW_LINE curr_term *= i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res *= curr_sum NEW_LINE DEDENT if ( n >= 2 ) : NEW_LINE INDENT res *= ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def checkArithmetic ( n ) : NEW_LINE INDENT count = countDivisors ( n ) NEW_LINE sum = sumofFactors ( n ) NEW_LINE return ( sum % count == 0 ) NEW_LINE DEDENT
def findGCD ( arr , n ) : NEW_LINE INDENT result = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result = gcd ( arr [ i ] , result ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT
def sumTillX ( x , n ) : NEW_LINE INDENT odd = math . ceil ( n / 2.0 ) NEW_LINE if ( x <= odd ) : NEW_LINE INDENT return x * x NEW_LINE DEDENT even = x - odd NEW_LINE return ( ( odd * odd ) + ( even * even ) + even ) NEW_LINE DEDENT
def rangeSum ( N , L , R ) : NEW_LINE INDENT return ( sumTillX ( R , N ) - sumTillX ( L - 1 , N ) ) NEW_LINE DEDENT
def magicOfSequence ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += ( i * i * i + i * 2 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def magicOfSequence ( N ) : NEW_LINE INDENT return ( N * ( N + 1 ) / 2 ) + 2 * N NEW_LINE DEDENT
def isProduct ( arr , n , x ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if x % arr [ i ] == 0 : NEW_LINE INDENT if x // arr [ i ] in s : NEW_LINE INDENT return True NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def repUnitValue ( n ) : NEW_LINE INDENT if ( n % 2 == 0 or n % 5 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT rem = 1 NEW_LINE power = 1 NEW_LINE k = 1 NEW_LINE while ( rem % n != 0 ) : NEW_LINE INDENT k += 1 NEW_LINE power = power * 10 % n NEW_LINE rem = ( rem + power ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT
def isSplittable ( n , m ) : NEW_LINE INDENT total_sum = ( int ) ( ( n * ( n + 1 ) ) / 2 ) NEW_LINE sum_s1 = int ( ( total_sum + m ) / 2 ) NEW_LINE sum_s2 = total_sum - sum_s1 NEW_LINE if ( total_sum < m ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( sum_s1 + sum_s2 == total_sum and sum_s1 - sum_s2 == m ) : NEW_LINE INDENT return ( __gcd ( sum_s1 , sum_s2 ) == 1 ) NEW_LINE DEDENT return False NEW_LINE DEDENT
def isPossibleToZero ( a , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT odd += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT even += a [ i ] NEW_LINE DEDENT DEDENT return ( odd == even ) NEW_LINE DEDENT
def cosXSertiesSum ( x , n ) : NEW_LINE INDENT x = x * ( PI / 180.0 ) NEW_LINE res = 1 NEW_LINE sign = 1 NEW_LINE fact = 1 NEW_LINE pow = 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * ( - 1 ) NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i ) NEW_LINE pow = pow * x * x NEW_LINE res = res + sign * pow / fact NEW_LINE DEDENT return res NEW_LINE DEDENT
def isBlumInteger ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT for j in range ( i * 2 , n + 1 , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT if ( ( n % i == 0 ) and ( ( i - 3 ) % 4 ) == 0 ) : NEW_LINE INDENT q = int ( n / i ) NEW_LINE return ( q != i and prime [ q ] and ( q - 3 ) % 4 == 0 ) NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def primeFactors ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT res . append ( 2 ) NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = int ( n / i ) NEW_LINE DEDENT res . append ( i ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT res . append ( n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def isHoax ( n ) : NEW_LINE INDENT pf = primeFactors ( n ) NEW_LINE if ( pf [ 0 ] == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT all_pf_sum = 0 NEW_LINE for i in range ( 0 , len ( pf ) ) : NEW_LINE INDENT pf_sum = 0 NEW_LINE while ( pf [ i ] > 0 ) : NEW_LINE INDENT pf_sum += pf [ i ] % 10 NEW_LINE pf [ i ] = int ( pf [ i ] / 10 ) NEW_LINE DEDENT all_pf_sum += pf_sum NEW_LINE DEDENT sum_n = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum_n += n % 10 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum_n == all_pf_sum NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def summingSeries ( n ) : NEW_LINE INDENT return math . pow ( n , 2 ) NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT Nr = n NEW_LINE Dr = 1 NEW_LINE ans = 1 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans = int ( ( ans * Nr ) / ( Dr ) ) NEW_LINE Nr = Nr - 1 NEW_LINE Dr = Dr + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT N = 2 * n - 2 NEW_LINE R = n - 1 NEW_LINE return ( nCr ( N , R ) * fact ( n - 1 ) ) NEW_LINE DEDENT
def printSumsOfDigits ( n ) : NEW_LINE INDENT for base in range ( 2 , n ) : NEW_LINE INDENT print ( solve ( n , base ) , end = " " ) NEW_LINE DEDENT DEDENT
def check ( N , D ) : NEW_LINE INDENT temp = N * ( N + 1 ) // 2 + D NEW_LINE return ( bool ( temp % 2 == 0 ) ) NEW_LINE DEDENT
def isValidNesbitt ( a , b , c ) : NEW_LINE INDENT A = a / ( b + c ) NEW_LINE B = b / ( a + c ) NEW_LINE C = c / ( a + b ) NEW_LINE inequality = A + B + C NEW_LINE return ( inequality >= 1.5 ) NEW_LINE DEDENT
def exactPrimeFactorCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT DEDENT i = 3 NEW_LINE while ( i <= int ( math . sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = int ( n / i ) NEW_LINE DEDENT DEDENT i = i + 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def no_of_digit ( a , b ) : NEW_LINE INDENT return ( ( int ) ( b * math . log10 ( a ) ) + 1 ) NEW_LINE DEDENT
def gen ( n , r ) : NEW_LINE INDENT a = r [ - 1 ] NEW_LINE a += 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT r . append ( a ) NEW_LINE a += 2 NEW_LINE DEDENT return r NEW_LINE DEDENT
def conell ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE k = 1 NEW_LINE res . append ( 0 ) NEW_LINE while 1 : NEW_LINE INDENT res = gen ( k , res ) NEW_LINE k += 1 NEW_LINE j = len ( res ) - 1 NEW_LINE while j != n and j + k > n : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if j >= n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res . remove ( res [ 0 ] ) NEW_LINE return res NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT
def printNComposite ( n ) : NEW_LINE INDENT fact = factorial ( n + 1 ) NEW_LINE for i in range ( 2 , n + 2 ) : NEW_LINE INDENT print ( fact + i , end = " " ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def coprime ( a , b ) : NEW_LINE INDENT return ( gcd ( a , b ) == 1 ) NEW_LINE DEDENT
def isCubeFree ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( n ** ( 1 / 3 ) + 1 ) ) : NEW_LINE INDENT if ( n % ( i * i * i ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def printCubeFree ( n ) : NEW_LINE INDENT cubFree = [ 1 ] * ( n + 1 ) NEW_LINE i = 2 NEW_LINE while ( i * i * i <= n ) : NEW_LINE INDENT if ( cubFree [ i ] == 1 ) : NEW_LINE INDENT multiple = 1 NEW_LINE while ( i * i * i * multiple <= n ) : NEW_LINE INDENT cubFree [ i * i * i * multiple ] = 0 NEW_LINE multiple += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( cubFree [ i ] == 1 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def inversegrayCode ( n ) : NEW_LINE INDENT inv = 0 NEW_LINE while ( n ) : NEW_LINE INDENT inv = inv ^ n NEW_LINE n = n >> 1 NEW_LINE DEDENT return inv NEW_LINE DEDENT
def calculateDivisors ( A , B ) : NEW_LINE INDENT N = A - B NEW_LINE noOfDivisors = 0 NEW_LINE a = math . sqrt ( N ) NEW_LINE for i in range ( 1 , int ( a + 1 ) ) : NEW_LINE INDENT if ( ( N % i == 0 ) ) : NEW_LINE INDENT if ( i > B ) : NEW_LINE INDENT noOfDivisors += 1 NEW_LINE DEDENT if ( ( N / i ) != i and ( N / i ) > B ) : NEW_LINE INDENT noOfDivisors += 1 NEW_LINE DEDENT DEDENT DEDENT return noOfDivisors NEW_LINE DEDENT
def numberOfPossibleWaysUtil ( A , B ) : NEW_LINE INDENT if ( A == B ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( A < B ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT noOfDivisors = 0 NEW_LINE noOfDivisors = calculateDivisors NEW_LINE return noOfDivisors NEW_LINE DEDENT
def printPowerNumber ( X , N ) : NEW_LINE INDENT global power NEW_LINE power . append ( 1 ) NEW_LINE res = [ ] NEW_LINE for i in range ( 1 , X + 1 ) : NEW_LINE INDENT nextPower ( N ) NEW_LINE res . append ( power [ - 1 ] ) NEW_LINE res . append ( power [ 0 ] ) NEW_LINE DEDENT for i in range ( 0 , len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = "" ) NEW_LINE DEDENT DEDENT
def firstDigit ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE while ( fact % 10 == 0 ) : NEW_LINE INDENT fact = int ( fact / 10 ) NEW_LINE DEDENT DEDENT while ( fact >= 10 ) : NEW_LINE INDENT fact = int ( fact / 10 ) NEW_LINE DEDENT return math . floor ( fact ) NEW_LINE DEDENT
def possibleToReach ( a , b ) : NEW_LINE INDENT c = np . cbrt ( a * b ) NEW_LINE re1 = a // c NEW_LINE re2 = b // c NEW_LINE if ( ( re1 * re1 * re2 == a ) and ( re2 * re2 * re1 == b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def primes ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT j = i * 2 NEW_LINE while ( j <= n ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT arr = [ ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT
def countDigits ( n ) : NEW_LINE INDENT temp = n NEW_LINE c = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT temp = int ( temp / 10 ) NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
def frugal ( n ) : NEW_LINE INDENT r = primes ( n ) NEW_LINE t = n NEW_LINE s = 0 NEW_LINE for i in range ( len ( r ) ) : NEW_LINE INDENT if ( t % r [ i ] == 0 ) : NEW_LINE INDENT k = 0 NEW_LINE while ( t % r [ i ] == 0 ) : NEW_LINE INDENT t = int ( t / r [ i ] ) NEW_LINE k += 1 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT s = s + countDigits ( r [ i ] ) NEW_LINE DEDENT elif ( k != 1 ) : NEW_LINE INDENT s = ( s + countDigits ( r [ i ] ) + countDigits ( k ) ) NEW_LINE DEDENT DEDENT DEDENT return ( countDigits ( n ) > s and s != 0 ) NEW_LINE DEDENT
def nthSquareCube ( n ) : NEW_LINE INDENT return n * n * n * n * n * n NEW_LINE DEDENT
def findGreatest ( arr , n ) : NEW_LINE INDENT result = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] * arr [ k ] == arr [ i ] ) : NEW_LINE INDENT result = max ( result , arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE if ( ( sr - math . floor ( sr ) ) == 0 ) : NEW_LINE INDENT return math . floor ( sr ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def findS ( s ) : NEW_LINE INDENT sr = isPerfectSquare ( s ) NEW_LINE if ( sr == - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return int ( isTriangular ( sr ) ) NEW_LINE DEDENT
def powerNumbers ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 2 , int ( math . pow ( n , 1.0 / 3.0 ) ) + 1 ) : NEW_LINE INDENT j = i * i NEW_LINE while ( j * i <= n ) : NEW_LINE INDENT j = j * i NEW_LINE s = int ( math . sqrt ( j ) ) NEW_LINE if ( s * s != j ) : NEW_LINE INDENT v . append ( j ) NEW_LINE DEDENT DEDENT DEDENT v . sort ( ) NEW_LINE v = list ( dict . fromkeys ( v ) ) NEW_LINE return len ( v ) + int ( math . sqrt ( n ) ) NEW_LINE DEDENT
def NicomachuTheorum_sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += k * k * k NEW_LINE DEDENT triNo = n * ( n + 1 ) / 2 NEW_LINE if ( sum == triNo * triNo ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def checkDigits ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def largestNumber ( n ) : NEW_LINE INDENT for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT if ( checkDigits ( i ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT
def largestNumber ( n ) : NEW_LINE INDENT s = "" NEW_LINE duplicate = n NEW_LINE while ( n > 0 ) : NEW_LINE INDENT s = chr ( n % 10 + 48 ) + s NEW_LINE n = n // 10 NEW_LINE DEDENT index = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ( ord ( s [ i ] ) - ord ( '0' ) ) % 2 & 1 ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return duplicate NEW_LINE DEDENT num = 0 NEW_LINE for i in range ( index ) : NEW_LINE INDENT num = num * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT num = num * 10 + ( ord ( s [ index ] ) - ord ( '0' ) - 1 ) NEW_LINE for i in range ( index + 1 , len ( s ) ) : NEW_LINE INDENT num = num * 10 + 8 NEW_LINE DEDENT return num NEW_LINE DEDENT
def countDigits ( n ) : NEW_LINE INDENT return int ( n * math . log10 ( 2 ) + 1 ) NEW_LINE DEDENT
def check_digits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n , 2401 ) : NEW_LINE INDENT if ( check_digits ( i ) == 1 ) : NEW_LINE INDENT return ( i ) NEW_LINE DEDENT DEDENT DEDENT
def trickyCase ( s , index ) : NEW_LINE INDENT index1 = - 1 NEW_LINE for i in range ( index - 1 , - 1 , - 1 ) : NEW_LINE INDENT digit = s [ i ] - '0' NEW_LINE if ( digit != 8 ) : NEW_LINE INDENT index1 = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( index1 == - 1 ) : NEW_LINE INDENT return 2 * pow ( 10 , len ( s ) ) NEW_LINE DEDENT num = 0 NEW_LINE for i in range ( index1 ) : NEW_LINE INDENT num = num * 10 + ( s [ i ] - '0' ) NEW_LINE DEDENT if ( s [ index1 ] % 2 == 0 ) : NEW_LINE INDENT num = num * 10 + ( s [ index1 ] - '0' + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT num = num * 10 + ( s [ index1 ] - '0' + 1 ) NEW_LINE DEDENT for i in range ( index1 + 1 , len ( s ) ) : NEW_LINE INDENT num = num * 10 NEW_LINE DEDENT return num NEW_LINE DEDENT
def smallestNumber ( n ) : NEW_LINE INDENT num = 0 NEW_LINE s = "" NEW_LINE duplicate = n NEW_LINE while ( n ) : NEW_LINE INDENT s = chr ( n % 10 + 48 ) + s NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT index = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT digit = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( digit & 1 ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return duplicate NEW_LINE DEDENT if ( s [ index ] == '9' ) : NEW_LINE INDENT num = trickyCase ( s , index ) NEW_LINE return num NEW_LINE DEDENT for i in range ( index ) : NEW_LINE INDENT num = num * 10 + ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT num = num * 10 + ( ord ( s [ index ] ) - ord ( '0' ) + 1 ) NEW_LINE for i in range ( index + 1 , len ( s ) ) : NEW_LINE INDENT num = num * 10 NEW_LINE DEDENT return num NEW_LINE DEDENT
def findBucketNo ( p ) : NEW_LINE INDENT return math . ceil ( ( math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) NEW_LINE DEDENT
def mean ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT DEDENT return math . floor ( int ( sum / ( n * n ) ) ) NEW_LINE DEDENT
def variance ( a , n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT a [ i ] [ j ] -= m NEW_LINE a [ i ] [ j ] *= a [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT DEDENT return math . floor ( int ( sum / ( n * n ) ) ) NEW_LINE DEDENT
def productPrimeFactors ( n ) : NEW_LINE INDENT product = 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT product *= 2 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT product = product * i NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = n / i NEW_LINE DEDENT DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT product = product * n NEW_LINE DEDENT return product NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT isPrime = [ True ] * ( MAX ) NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT DEDENT
def modMult ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b //= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT
def countWays ( n , m ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , len ( primes ) ) : NEW_LINE INDENT powers = power ( n , primes [ i ] ) NEW_LINE if ( powers == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = modMult ( ans , powers + 1 , m ) % m NEW_LINE DEDENT if ( ( ( ans - 1 ) % m ) < 0 ) : NEW_LINE INDENT return ( ans - 1 + m ) % m NEW_LINE DEDENT else : NEW_LINE INDENT return ( ans - 1 ) % m NEW_LINE DEDENT DEDENT
def subset ( ar , n ) : NEW_LINE INDENT res = 0 NEW_LINE ar . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ar [ i ] == ar [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res = max ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE curr = 19 NEW_LINE while ( True ) : NEW_LINE INDENT sum = 0 NEW_LINE x = curr NEW_LINE while ( x > 0 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT curr += 9 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def pythagoreanTriplet ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( n / 3 ) + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if ( i * i + j * j == k * k ) : NEW_LINE INDENT print ( i , ", " , j , ", " , k , sep = "" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( "No Triplet" ) NEW_LINE DEDENT
def sumofFactors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n // i NEW_LINE curr_term *= i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res *= curr_sum NEW_LINE DEDENT if ( n >= 2 ) : NEW_LINE INDENT res *= ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def checkFriendly ( n , m ) : NEW_LINE INDENT sumFactors_n = sumofFactors ( n ) NEW_LINE sumFactors_m = sumofFactors ( m ) NEW_LINE gcd_n = gcd ( n , sumFactors_n ) NEW_LINE gcd_m = gcd ( m , sumFactors_m ) NEW_LINE if ( n // gcd_n == m // gcd_m and sumFactors_n // gcd_n == sumFactors_m // gcd_m ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def primorial ( n ) : NEW_LINE INDENT p = 2 NEW_LINE n -= 1 NEW_LINE i = 3 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT p = p * i NEW_LINE n -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
def findNextPrime ( n ) : NEW_LINE INDENT nextPrime = n + 2 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPrime ( nextPrime ) ) : NEW_LINE INDENT break NEW_LINE DEDENT nextPrime += 1 NEW_LINE DEDENT return nextPrime NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT multiTerms = n * ( n + 1 ) // 2 NEW_LINE sm = multiTerms NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiTerms = multiTerms - ( i - 1 ) NEW_LINE sm = sm + multiTerms * i NEW_LINE DEDENT return sm NEW_LINE DEDENT
def procal ( n ) : NEW_LINE INDENT return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) NEW_LINE DEDENT
def testSomeNumbers ( limit , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return NEW_LINE DEDENT for a in range ( 1 , limit + 1 ) : NEW_LINE INDENT for b in range ( a , limit + 1 ) : NEW_LINE INDENT pow_sum = pow ( a , n ) + pow ( b , n ) NEW_LINE c = pow ( pow_sum , 1.0 / n ) NEW_LINE c_pow = pow ( int ( c ) , n ) NEW_LINE if ( c_pow == pow_sum ) : NEW_LINE INDENT print ( "Count example found" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( "No counter example within given range and data" ) NEW_LINE DEDENT
def series ( A , X , n ) : NEW_LINE INDENT nFact = factorial ( n ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT niFact = factorial ( n - i ) NEW_LINE iFact = factorial ( i ) NEW_LINE aPow = pow ( A , n - i ) NEW_LINE xPow = pow ( X , i ) NEW_LINE print ( int ( ( nFact * aPow * xPow ) / ( niFact * iFact ) ) , end = " " ) NEW_LINE DEDENT DEDENT
def series ( A , X , n ) : NEW_LINE INDENT term = pow ( A , n ) NEW_LINE print ( term , end = " " ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT term = int ( term * X * ( n - i + 1 ) / ( i * A ) ) NEW_LINE print ( term , end = " " ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def productReduce ( n , num , den ) : NEW_LINE INDENT new_num = 1 NEW_LINE new_den = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT new_num = new_num * num [ i ] NEW_LINE new_den = new_den * den [ i ] NEW_LINE DEDENT GCD = gcd ( new_num , new_den ) NEW_LINE new_num = new_num / GCD NEW_LINE new_den = new_den / GCD NEW_LINE print ( int ( new_num ) , "/" , int ( new_den ) ) NEW_LINE DEDENT
def digSum ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( n % 9 == 0 ) and 9 or ( n % 9 ) NEW_LINE DEDENT
def repeatedNumberSum ( n , x ) : NEW_LINE INDENT sum = x * digSum ( n ) NEW_LINE return digSum ( sum ) NEW_LINE DEDENT
def totalSumDivisibleByNum ( n , number ) : NEW_LINE INDENT firstnum = pow ( 10 , n - 1 ) NEW_LINE lastnum = pow ( 10 , n ) NEW_LINE sum = 0 NEW_LINE for i in range ( firstnum , lastnum ) : NEW_LINE INDENT if ( i % number == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def minRemove ( a , b , n , m ) : NEW_LINE INDENT countA = dict ( ) NEW_LINE countB = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT countA [ a [ i ] ] = countA . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT countB [ b [ i ] ] = countB . get ( b [ i ] , 0 ) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in countA : NEW_LINE INDENT if x in countB . keys ( ) : NEW_LINE INDENT res += min ( countA [ x ] , countB [ x ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def totalSumDivisibleByNum ( digit , number ) : NEW_LINE INDENT firstnum = pow ( 10 , digit - 1 ) NEW_LINE lastnum = pow ( 10 , digit ) NEW_LINE firstnum = ( firstnum - firstnum % number ) + number NEW_LINE lastnum = ( lastnum - lastnum % number ) NEW_LINE count = ( ( lastnum - firstnum ) / number + 1 ) NEW_LINE return int ( ( ( lastnum + firstnum ) * count ) / 2 ) NEW_LINE DEDENT
def numberofterm ( n , number ) : NEW_LINE INDENT firstnum = math . pow ( 10 , n - 1 ) NEW_LINE lastnum = math . pow ( 10 , n ) NEW_LINE count = 0 NEW_LINE for i in range ( int ( firstnum ) , int ( lastnum ) ) : NEW_LINE INDENT if ( i % number == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def sumofseries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += ( i ) * ( i + 1 ) * ( i + 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def sumofseries ( n ) : NEW_LINE INDENT return int ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) NEW_LINE DEDENT
def seiresSum ( n , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , 2 * n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res += a [ i ] * a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT res -= a [ i ] * a [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def seiresSum ( n , a ) : NEW_LINE INDENT return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ) NEW_LINE DEDENT
def printGMeans ( A , B , N ) : NEW_LINE INDENT R = ( math . pow ( ( B / A ) , 1.0 / ( N + 1 ) ) ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( int ( A * math . pow ( R , i ) ) , end = " " ) NEW_LINE DEDENT DEDENT
def checkdigit ( n , k ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT rem = n % 10 NEW_LINE if ( rem == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT n = n / 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def isValid ( i , m ) : NEW_LINE INDENT sq_i = math . sqrt ( i ) NEW_LINE sq = min ( m , sq_i ) NEW_LINE for j in range ( 2 , sq + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findLargestNum ( n , m ) : NEW_LINE INDENT for i in range ( n , m , - 1 ) : NEW_LINE INDENT if ( isValid ( i , m ) ) : NEW_LINE INDENT print ( "{}" . format ( i ) ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "NumberDoesn'tExists" ) NEW_LINE DEDENT
def georgeCantor ( n ) : NEW_LINE INDENT i = 1 NEW_LINE j = 1 NEW_LINE k = 1 NEW_LINE while k < n : NEW_LINE INDENT j += 1 NEW_LINE k += 1 NEW_LINE if k == n : NEW_LINE INDENT break NEW_LINE DEDENT while j > 1 and k < n : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE k += 1 NEW_LINE DEDENT if k == n : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE k += 1 NEW_LINE if k == n : NEW_LINE INDENT break NEW_LINE DEDENT while i > 1 and k < n : NEW_LINE INDENT i -= 1 NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT print ( "N-th term : %d/%d" % ( i , j ) ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( int ( n / 100 ) ) : NEW_LINE INDENT last_digit = int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE n += last_digit * 3 NEW_LINE DEDENT return ( n % 29 == 0 ) NEW_LINE DEDENT
def digitSum ( n ) : NEW_LINE INDENT digSum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digSum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return digSum NEW_LINE DEDENT
def countInteger ( n , s ) : NEW_LINE INDENT if ( n < s ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( s , min ( n , s + 163 ) + 1 ) : NEW_LINE INDENT if ( ( i - digitSum ( i ) ) > s ) : NEW_LINE INDENT return ( n - i + 1 ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def division ( num1 , num2 ) : NEW_LINE INDENT if ( num1 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( num2 == 0 ) : NEW_LINE INDENT return INT_MAX NEW_LINE DEDENT negResult = 0 NEW_LINE if ( num1 < 0 ) : NEW_LINE INDENT num1 = - num1 NEW_LINE if ( num2 < 0 ) : NEW_LINE INDENT num2 = - num2 NEW_LINE DEDENT else : NEW_LINE INDENT negResult = true NEW_LINE DEDENT DEDENT elif ( num2 < 0 ) : NEW_LINE INDENT num2 = - num2 NEW_LINE negResult = true NEW_LINE DEDENT quotient = 0 NEW_LINE while ( num1 >= num2 ) : NEW_LINE INDENT num1 = num1 - num2 NEW_LINE quotient += 1 NEW_LINE DEDENT if ( negResult ) : NEW_LINE INDENT quotient = - quotient NEW_LINE DEDENT return quotient NEW_LINE DEDENT
def pronic_check ( n ) : NEW_LINE INDENT x = ( int ) ( math . sqrt ( n ) ) NEW_LINE if ( x * ( x + 1 ) == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def power ( n , r ) : NEW_LINE INDENT count = 0 NEW_LINE i = r NEW_LINE while ( ( n / i ) >= 1 ) : NEW_LINE INDENT count += n / i NEW_LINE i = i * r NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT
def isOrthogonal ( a , m , n ) : NEW_LINE INDENT if ( m != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT trans = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT trans [ i ] [ j ] = a [ j ] [ i ] NEW_LINE DEDENT DEDENT prod = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( a [ i ] [ k ] * a [ j ] [ k ] ) NEW_LINE DEDENT prod [ i ] [ j ] = sum NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i != j and prod [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i == j and prod [ i ] [ j ] != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def digitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT temp = digitNumber ( ( n - 1 ) // 2 ) % mod NEW_LINE return ( 9 * ( temp * temp ) % mod ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT temp = digitNumber ( n // 2 ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE DEDENT DEDENT
def countExcluding ( n , d ) : NEW_LINE INDENT if ( d == 0 ) : NEW_LINE INDENT return ( 9 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT if ( x >= 0 ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr * sr ) == float ( x ) ) NEW_LINE DEDENT return false NEW_LINE DEDENT
def checkperfectsquare ( x ) : NEW_LINE INDENT if ( math . ceil ( math . sqrt ( n ) ) == math . floor ( math . sqrt ( n ) ) ) : NEW_LINE INDENT print ( "perfect square" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "not a perfect square" ) NEW_LINE DEDENT DEDENT
def printGP ( a , r , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT curr_term = a * pow ( r , i ) NEW_LINE print ( curr_term , end = " " ) NEW_LINE DEDENT DEDENT
def Nth_of_AP ( a , d , N ) : NEW_LINE INDENT return ( a + ( N - 1 ) * d ) NEW_LINE DEDENT
def checkFibinnary ( n ) : NEW_LINE INDENT prev_last = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( ( n & 1 ) and prev_last ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_last = n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def check ( n , p ) : NEW_LINE INDENT maximum = - 1 NEW_LINE while ( not ( n % 2 ) ) : NEW_LINE INDENT maximum = max ( maximum , 2 ) NEW_LINE n = int ( n / 2 ) NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT maximum = max ( maximum , i ) NEW_LINE n = int ( n / i ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT maximum = max ( maximum , n ) NEW_LINE DEDENT return ( maximum <= p ) NEW_LINE DEDENT
def Nonagonal ( n ) : NEW_LINE INDENT return int ( n * ( 7 * n - 5 ) / 2 ) NEW_LINE DEDENT
def Nonagonal ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( int ( i * ( 7 * i - 5 ) / 2 ) , end = " " ) NEW_LINE DEDENT DEDENT
def findLcm ( arr , size ) : NEW_LINE INDENT ans = arr [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , size , 1 ) : NEW_LINE INDENT ans = int ( ( ( ( arr [ i ] [ 1 ] * ans ) ) / ( gcd ( arr [ i ] [ 1 ] , ans ) ) ) ) NEW_LINE DEDENT return ( ans ) NEW_LINE DEDENT
def checkplusperfect ( x ) : NEW_LINE INDENT temp = x NEW_LINE n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x // 10 NEW_LINE n = n + 1 NEW_LINE DEDENT x = temp NEW_LINE sm = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) NEW_LINE x = x // 10 NEW_LINE DEDENT return ( sm == temp ) NEW_LINE DEDENT
def sum_series ( n ) : NEW_LINE INDENT nSquare = n * n NEW_LINE return int ( nSquare * ( nSquare - 1 ) / 4 ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT root = int ( math . sqrt ( n ) ) NEW_LINE for i in range ( 2 , root + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isSandwitched ( n ) : NEW_LINE INDENT return ( isPrime ( n - 1 ) and isPrime ( n + 1 ) ) NEW_LINE DEDENT
def Div_by_8 ( n ) : NEW_LINE INDENT return ( ( ( n >> 3 ) << 3 ) == n ) NEW_LINE DEDENT
def mean ( mid , freq , n ) : NEW_LINE INDENT sum = 0 NEW_LINE freqSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + mid [ i ] * freq [ i ] NEW_LINE freqSum = freqSum + freq [ i ] NEW_LINE DEDENT return sum / freqSum NEW_LINE DEDENT
def groupedSD ( lower_limit , upper_limit , freq , n ) : NEW_LINE INDENT mid = [ [ 0 ] for i in range ( 0 , n ) ] NEW_LINE sum = 0 NEW_LINE freqSum = 0 NEW_LINE sd = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 NEW_LINE sum = sum + freq [ i ] * mid [ i ] * mid [ i ] NEW_LINE freqSum = freqSum + freq [ i ] NEW_LINE DEDENT sd = math . sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) NEW_LINE return sd NEW_LINE DEDENT
def divisibleBy20 ( num ) : NEW_LINE INDENT lastTwoDigits = int ( num [ - 2 : ] ) NEW_LINE return ( ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 == 0 ) ) NEW_LINE DEDENT
def findArea ( d ) : NEW_LINE INDENT return ( d * d ) / 2 NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return int ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ) NEW_LINE DEDENT
def getMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return ( ( n + 1 ) >> 2 ) NEW_LINE DEDENT
def multiply ( F , M ) : NEW_LINE INDENT x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE DEDENT
def power ( F , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE m = getMSB ( n ) NEW_LINE while m : NEW_LINE INDENT multiply ( F , F ) NEW_LINE if ( n & m ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT m = m >> 1 NEW_LINE DEDENT DEDENT
def fib ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT
def isDvisibleBy12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = int ( num [ len ( num ) - 1 ] ) NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d2 = int ( num [ len ( num ) - 2 ] ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT sum += int ( num [ i ] ) NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT number = int ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT DEDENT
def StepstoReachTarget ( target ) : NEW_LINE INDENT target = abs ( target ) NEW_LINE n = math . ceil ( ( - 1.0 + math . sqrt ( 1 + 8.0 * target ) ) / 2 ) NEW_LINE sum = n * ( n + 1 ) / 2 NEW_LINE if ( sum == target ) : NEW_LINE INDENT return n NEW_LINE DEDENT d = sum - target NEW_LINE if ( ( int ( d ) & 1 ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT if ( int ( d ) & 1 ) : NEW_LINE INDENT return n + 2 NEW_LINE DEDENT return n + 1 NEW_LINE DEDENT DEDENT
def Calculate_GST ( org_cost , N_price ) : NEW_LINE INDENT return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) NEW_LINE DEDENT
def avg_of_even_num ( n ) : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT
def avg_of_odd_num ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 2 * i + 1 ) NEW_LINE DEDENT return sm // n NEW_LINE DEDENT
def avg_of_odd_num ( n ) : NEW_LINE INDENT return n NEW_LINE DEDENT
def seriesSum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE res = 0.0 NEW_LINE sign = True NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n - 1 NEW_LINE if ( sign ) : NEW_LINE INDENT sign = False NEW_LINE res = res + ( i + 1 ) / ( i + 2 ) NEW_LINE i = i + 2 NEW_LINE DEDENT else : NEW_LINE INDENT sign = True NEW_LINE res = res - ( i + 1 ) / ( i + 2 ) NEW_LINE i = i + 2 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT d = int ( math . sqrt ( n ) ) NEW_LINE if ( d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def largestNonPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( check ( a [ i ] ) == False ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT
def modInverse ( a , prime ) : NEW_LINE INDENT a = a % prime NEW_LINE for x in range ( 1 , prime ) : NEW_LINE INDENT if ( ( a * x ) % prime == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def printModIverses ( n , prime ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( modInverse ( i , prime ) , end = " " ) NEW_LINE DEDENT DEDENT
def countSymmetric ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( 1 << ( ( n * ( n + 1 ) ) // 2 ) ) NEW_LINE DEDENT
def SternSequenceFunc ( BrocotSequence , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT considered_element = BrocotSequence [ i ] NEW_LINE precedent = BrocotSequence [ i - 1 ] NEW_LINE BrocotSequence . append ( considered_element + precedent ) NEW_LINE BrocotSequence . append ( considered_element ) NEW_LINE DEDENT for i in range ( 0 , 15 ) : NEW_LINE INDENT print ( BrocotSequence [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def centeredNonagonal ( n ) : NEW_LINE INDENT return ( 3 * n - 2 ) * ( 3 * n - 1 ) // 2 NEW_LINE DEDENT
def sieve ( n , prime ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def printSophieGermanNumber ( n ) : NEW_LINE INDENT prime = [ True ] * ( 2 * n + 1 ) NEW_LINE sieve ( 2 * n + 1 , prime ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ 2 * i + 1 ] ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def fib ( f , N ) : NEW_LINE INDENT f [ 1 ] = 1 NEW_LINE f [ 2 ] = 1 NEW_LINE for i in range ( 3 , N + 1 ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] NEW_LINE DEDENT DEDENT
def printAP ( a , d , n ) : NEW_LINE INDENT curr_term NEW_LINE DEDENT
def Mean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE DEDENT return sm // n NEW_LINE DEDENT
def isRevDiffDivisible ( x , k ) : NEW_LINE INDENT n = x NEW_LINE m = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT m = m * 10 + x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return ( abs ( n - m ) % k == 0 ) NEW_LINE DEDENT
def countNumbers ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( isRevDiffDivisible ( i , k ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) : NEW_LINE INDENT for i in range ( lowQuant , upQuant + 1 ) : NEW_LINE INDENT ans = i * r NEW_LINE if ( lowCost <= ans and ans <= upCost ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def centeredHexagonalNumber ( n ) : NEW_LINE INDENT return 3 * n * ( n - 1 ) + 1 NEW_LINE DEDENT
def oddNumSum ( n ) : NEW_LINE INDENT return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 NEW_LINE DEDENT
def isPerfectSquare ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT root = round ( math . sqrt ( n ) ) NEW_LINE return ( n == root * root ) NEW_LINE DEDENT
def printnonsquare ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while ( count < n ) : NEW_LINE INDENT if ( isPerfectSquare ( i ) == False ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE count = count + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT
def nonsquare ( n ) : NEW_LINE INDENT return n + ( int ) ( 0.5 + math . sqrt ( n ) ) NEW_LINE DEDENT
def printNonSquare ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( nonsquare ( i ) , end = " " ) NEW_LINE DEDENT DEDENT
def trailingZero ( x ) : NEW_LINE INDENT i = 5 NEW_LINE count = 0 NEW_LINE while ( x > i ) : NEW_LINE INDENT count = count + x // i NEW_LINE i = i * 5 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countProductTrailing ( M , N ) : NEW_LINE INDENT return trailingZero ( N ) + trailingZero ( M ) NEW_LINE DEDENT
def isTrimorphic ( N ) : NEW_LINE INDENT cube = N * N * N NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 != cube % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT N = N // 10 NEW_LINE cube = cube // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
def checkTrimorphic ( num ) : NEW_LINE INDENT cube = num * num * num NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( num % 10 != cube % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = int ( num / 10 ) NEW_LINE cube = int ( cube / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def averageEven ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( "Invalid Input" ) NEW_LINE return - 1 NEW_LINE DEDENT sm = 0 NEW_LINE count = 0 NEW_LINE while ( n >= 2 ) : NEW_LINE INDENT count = count + 1 NEW_LINE sm = sm + n NEW_LINE n = n - 2 NEW_LINE DEDENT return sm // count NEW_LINE DEDENT
def averageEven ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( "Invalid Input" ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 2 ) // 2 NEW_LINE DEDENT
def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( "Invalid Input" ) NEW_LINE return - 1 NEW_LINE DEDENT sm = 0 NEW_LINE count = 0 NEW_LINE while ( n >= 1 ) : NEW_LINE INDENT count = count + 1 NEW_LINE sm = sm + n NEW_LINE n = n - 2 NEW_LINE DEDENT return sm // count NEW_LINE DEDENT
def fifthPowerSum ( n ) : NEW_LINE INDENT return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) // 12 NEW_LINE DEDENT
def find_distance ( n ) : NEW_LINE INDENT return n * ( ( 3 * n ) + 7 ) NEW_LINE DEDENT
def nearestPerfectSquare ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT sr = int ( math . sqrt ( arr [ i ] ) ) NEW_LINE if ( ( sr & 1 ) == ( arr [ i ] & 1 ) ) : NEW_LINE INDENT print ( sr * sr , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT sr += 1 NEW_LINE print ( sr * sr , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def squareSum ( n ) : NEW_LINE INDENT return int ( n * ( 4 * n * n - 1 ) / 3 ) NEW_LINE DEDENT
def squareSum ( n ) : NEW_LINE INDENT return int ( 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE DEDENT
def isMunchhausen ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE temp = n NEW_LINE while ( temp ) : NEW_LINE INDENT sm = sm + pwr [ ( temp % 10 ) ] NEW_LINE temp = temp // 10 NEW_LINE DEDENT return ( sm == n ) NEW_LINE DEDENT
def kthdigit ( a , b , k ) : NEW_LINE INDENT p = a ** b NEW_LINE count = 0 NEW_LINE while ( p > 0 and count < k ) : NEW_LINE INDENT rem = p % 10 NEW_LINE count = count + 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT return rem NEW_LINE DEDENT p = p / 10 NEW_LINE DEDENT DEDENT
def isPentagonal ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while True : NEW_LINE INDENT M = ( 3 * i * i - i ) / 2 NEW_LINE i += 1 NEW_LINE if ( M >= N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ( M == N ) NEW_LINE DEDENT
def fourthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def unitDigitXRaisedY ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( y ) : NEW_LINE INDENT res = ( res * x ) % 10 NEW_LINE DEDENT return res NEW_LINE DEDENT
def unitnumber ( x , y ) : NEW_LINE INDENT x = x % 10 NEW_LINE if y != 0 : NEW_LINE INDENT y = y % 4 + 4 NEW_LINE DEDENT return ( ( ( int ) ( math . pow ( x , y ) ) ) % 10 ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT return True NEW_LINE DEDENT
def nextPrime ( start ) : NEW_LINE INDENT nxt = start + 1 NEW_LINE while ( isPrime ( nxt ) == False ) : NEW_LINE INDENT nxt = nxt + 1 NEW_LINE DEDENT return nxt NEW_LINE DEDENT
def areAdjacentPrimes ( a , b , c ) : NEW_LINE INDENT if ( isPrime ( a ) == False or isPrime ( b ) == False or isPrime ( c ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT nxt = nextPrime ( a ) NEW_LINE if ( nxt != b ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( nextPrime ( b ) != c ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def findDivisor ( x , y ) : NEW_LINE INDENT if ( x == y ) : NEW_LINE INDENT return y NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def digSum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n % 9 == 0 : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n % 9 ) NEW_LINE DEDENT DEDENT
def PowDigSum ( n , x ) : NEW_LINE INDENT sum = digSum ( n ) NEW_LINE rem = x % 6 NEW_LINE if ( ( sum == 3 or sum == 6 ) and x > 1 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT elif ( x == 1 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT elif ( x == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( rem == 0 ) : NEW_LINE INDENT return digSum ( math . pow ( sum , 6 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return digSum ( math . pow ( sum , rem ) ) NEW_LINE DEDENT DEDENT
def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum / n NEW_LINE DEDENT
def AvgofSquareN ( n ) : NEW_LINE INDENT return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE DEDENT
def sumofFactors ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE n = n // i NEW_LINE if ( i == 2 and count == 1 ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE DEDENT curr_term = curr_term * i NEW_LINE curr_sum = curr_sum + curr_term NEW_LINE DEDENT res = res * curr_sum NEW_LINE DEDENT if ( n >= 2 ) : NEW_LINE INDENT res = res * ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def func ( x ) : NEW_LINE INDENT return ( float ( 1 ) / ( 1 + x * x ) ) NEW_LINE DEDENT
def calculate ( lower_limit , upper_limit , interval_limit ) : NEW_LINE INDENT interval_size = ( float ( upper_limit - lower_limit ) / interval_limit ) NEW_LINE sum = func ( lower_limit ) + func ( upper_limit ) NEW_LINE for i in range ( 1 , interval_limit ) : NEW_LINE INDENT if ( i % 3 == 0 ) : NEW_LINE INDENT sum = sum + 2 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + 3 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT DEDENT return ( ( float ( 3 * interval_size ) / 8 ) * sum ) NEW_LINE DEDENT
def LCM ( a , b ) : NEW_LINE INDENT return ( a * b ) // ( math . gcd ( a , b ) ) NEW_LINE DEDENT
def lcmOfNumerator ( vect ) : NEW_LINE INDENT lcm = vect [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , len ( vect ) ) : NEW_LINE INDENT lcm = LCM ( vect [ i ] [ 0 ] , lcm ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT
def gcdOfDemoninators ( vect ) : NEW_LINE INDENT gcd = vect [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , len ( vect ) ) : NEW_LINE INDENT gcd = math . gcd ( vect [ i ] [ 1 ] , gcd ) NEW_LINE DEDENT return gcd NEW_LINE DEDENT
def lcmOfRationals ( vect ) : NEW_LINE INDENT print ( lcmOfNumerator ( vect ) , "/" , gcdOfDemoninators ( vect ) , sep = "" ) NEW_LINE DEDENT
def makePermutation ( a , n ) : NEW_LINE INDENT count = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count . get ( a [ i ] ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT next_missing = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count [ a [ i ] ] != 1 or a [ i ] > n or a [ i ] < 1 : NEW_LINE INDENT count [ a [ i ] ] -= 1 NEW_LINE while count . get ( next_missing ) : NEW_LINE INDENT next_missing += 1 NEW_LINE DEDENT a [ i ] = next_missing NEW_LINE count [ next_missing ] = 1 NEW_LINE DEDENT DEDENT DEDENT
def focal_length_convex ( R ) : NEW_LINE INDENT return - ( R / 2 ) NEW_LINE DEDENT
def focal_length ( image_distance , object_distance ) : NEW_LINE INDENT return 1 / ( ( 1 / image_distance ) + ( 1 / object_distance ) ) NEW_LINE DEDENT
def sumofoddFactors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while n % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE n = n // i NEW_LINE curr_term *= i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res *= curr_sum NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT res *= ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countSolutions ( n , val ) : NEW_LINE INDENT total = 0 NEW_LINE if n == 1 and val >= 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( val + 1 ) : NEW_LINE INDENT total += countSolutions ( n - 1 , val - i ) NEW_LINE DEDENT return total NEW_LINE DEDENT
def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // ( math . gcd ( a , b ) ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( math . sqrt ( n ) + 1 ) , 6 ) : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def twinPrime ( n1 , n2 ) : NEW_LINE INDENT return ( isPrime ( n1 ) and isPrime ( n2 ) and abs ( n1 - n2 ) == 2 ) NEW_LINE DEDENT
def mobius ( n ) : NEW_LINE INDENT p = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE p = p + 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT n = int ( n / i ) NEW_LINE p = p + 1 NEW_LINE if ( n % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT i = i + 2 NEW_LINE DEDENT if ( p % 2 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT
def fib ( f , n ) : NEW_LINE INDENT f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] NEW_LINE DEDENT DEDENT
def fibcoef ( fc , f , n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT fc [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT k = j NEW_LINE while ( k > 0 ) : NEW_LINE INDENT k -= 1 NEW_LINE fc [ i ] [ j ] *= f [ k ] NEW_LINE DEDENT k = 1 NEW_LINE while ( ( j + 1 ) != k ) : NEW_LINE INDENT fc [ i ] [ j ] /= f [ k ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) ) NEW_LINE DEDENT
def sumofNterm ( a , d , b , r , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( ( a + ( i - 1 ) * d ) * ( b * math . pow ( r , i - 1 ) ) ) NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += 1.0 / ( i * ( i + 1 ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT root = ( int ) ( math . sqrt ( n ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , root + 1 ) : NEW_LINE INDENT ans = ans + n // i NEW_LINE DEDENT ans = 2 * ans - ( root * root ) NEW_LINE return ans NEW_LINE DEDENT
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT k = 2 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT sum = sum + k NEW_LINE k = k + 2 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum_n = int ( ( n * ( n + 1 ) / 2 ) ) NEW_LINE sum_sq_n = int ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE return ( sum_n + sum_sq_n ) NEW_LINE DEDENT
def sumofsquare ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def factorial ( start , end ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT
def sumofsquare ( n ) : NEW_LINE INDENT return int ( factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) ) NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return ( ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ) NEW_LINE DEDENT
def evenSum ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n + 1 ) ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT sum = sum + C [ n ] [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if arr1 [ i ] + arr2 [ j ] == x : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def evenbinomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
def Series ( n ) : NEW_LINE INDENT sums = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ser = 1 / ( i ** i ) NEW_LINE sums += ser NEW_LINE DEDENT return sums NEW_LINE DEDENT
def TrinomialValue ( n , k ) : NEW_LINE INDENT if n == 0 and k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k < - n or k > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 ) ) NEW_LINE DEDENT
def Series ( n ) : NEW_LINE INDENT sums = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sums += ( i * i ) NEW_LINE DEDENT return sums NEW_LINE DEDENT
def Series ( x , n ) : NEW_LINE INDENT sum = 1 NEW_LINE term = 1 NEW_LINE fct = 1 NEW_LINE p = 1 NEW_LINE multi = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT fct = fct * multi * ( multi + 1 ) NEW_LINE p = p * x * x NEW_LINE term = ( - 1 ) * term NEW_LINE multi += 2 NEW_LINE sum = sum + ( term * p ) / fct NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isPresent ( arr , low , high , value ) : NEW_LINE INDENT while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] == value ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( arr [ mid ] > value ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT value = x - arr1 [ i ] NEW_LINE if ( isPresent ( arr2 , 0 , n - 1 , value ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def two_factor ( n ) : NEW_LINE INDENT twocount = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT twocount += 1 NEW_LINE n = int ( n / 2 ) NEW_LINE DEDENT return twocount NEW_LINE DEDENT
def five_factor ( n ) : NEW_LINE INDENT fivecount = 0 NEW_LINE while n % 5 == 0 : NEW_LINE INDENT fivecount += 1 NEW_LINE n = int ( n / 5 ) NEW_LINE DEDENT return fivecount NEW_LINE DEDENT
def find_con_zero ( arr , n ) : NEW_LINE INDENT twocount = 0 NEW_LINE fivecount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twocount += two_factor ( arr [ i ] ) NEW_LINE fivecount += five_factor ( arr [ i ] ) NEW_LINE DEDENT if twocount < fivecount : NEW_LINE INDENT return twocount NEW_LINE DEDENT else : NEW_LINE INDENT return fivecount NEW_LINE DEDENT DEDENT
def fib ( n ) : NEW_LINE INDENT if n < 6 : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while t < n : NEW_LINE INDENT fn = round ( fn * PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT
def first ( a , b , c ) : NEW_LINE INDENT a %= b NEW_LINE for i in range ( 1 , b + 1 ) : NEW_LINE INDENT a = a * 10 NEW_LINE if int ( a / b ) == c : NEW_LINE INDENT return i NEW_LINE DEDENT a %= b NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def subsetDifference ( n ) : NEW_LINE INDENT s = int ( n * ( n + 1 ) / 2 ) NEW_LINE if n % 4 == 0 : NEW_LINE INDENT print ( "First subset sum = " , int ( s / 2 ) ) NEW_LINE print ( "Second subset sum = " , int ( s / 2 ) ) NEW_LINE print ( "Difference = " , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 4 == 1 or n % 4 == 2 : NEW_LINE INDENT print ( "First subset sum = " , int ( s / 2 ) ) NEW_LINE print ( "Second subset sum = " , int ( s / 2 ) + 1 ) NEW_LINE print ( "Difference = " , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "First subset sum = " , int ( s / 2 ) ) NEW_LINE print ( "Second subset sum = " , int ( s / 2 ) ) NEW_LINE print ( "Difference = " , 0 ) NEW_LINE DEDENT DEDENT DEDENT
def func ( x , y ) : NEW_LINE INDENT return ( x + y + x * y ) NEW_LINE DEDENT
def euler ( x0 , y , h , x ) : NEW_LINE INDENT temp = - 0 NEW_LINE while x0 < x : NEW_LINE INDENT temp = y NEW_LINE y = y + h * func ( x0 , y ) NEW_LINE x0 = x0 + h NEW_LINE DEDENT print ( "Approximate solution at x = " , x , " is " , "%.6f" % y ) NEW_LINE DEDENT
def timeToMeet ( s , v ) : NEW_LINE INDENT V = 3 * v / 2 NEW_LINE time = s / V NEW_LINE print ( time ) NEW_LINE DEDENT
def maxcoefficientvalue ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return binomialCoeff ( n , int ( n / 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return binomialCoeff ( n , int ( ( n + 1 ) / 2 ) ) NEW_LINE DEDENT DEDENT
def LCM ( x , y , z ) : NEW_LINE INDENT ans = int ( ( x * y ) / ( gcd ( x , y ) ) ) NEW_LINE return int ( ( z * ans ) / ( gcd ( ans , z ) ) ) NEW_LINE DEDENT
def findDivisible ( n , x , y , z ) : NEW_LINE INDENT lcm = LCM ( x , y , z ) NEW_LINE ndigitnumber = math . pow ( 10 , n - 1 ) NEW_LINE reminder = ndigitnumber % lcm NEW_LINE if reminder == 0 : NEW_LINE INDENT return ndigitnumber NEW_LINE DEDENT ndigitnumber += lcm - reminder NEW_LINE if ndigitnumber < math . pow ( 10 , n ) : NEW_LINE INDENT return int ( ndigitnumber ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT sum += k NEW_LINE k += 2 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def sumOfTheSeries ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE DEDENT
def checksum ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT print ( "-1 0 1" ) NEW_LINE return 0 NEW_LINE DEDENT inc = 0 NEW_LINE if n > 0 : NEW_LINE INDENT inc = 1 NEW_LINE DEDENT else : NEW_LINE INDENT inc = - 1 NEW_LINE DEDENT for i in range ( 0 , n - 1 , inc ) : NEW_LINE INDENT if i + i + 1 + i + 2 == n : NEW_LINE INDENT print ( i , " " , i + 1 , " " , i + 2 ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT print ( "-1" ) NEW_LINE DEDENT
def checksum ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if n % 3 == 0 : NEW_LINE INDENT print ( int ( n / 3 - 1 ) , " " , int ( n / 3 ) , " " , int ( n / 3 + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def solution ( a , b , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i * a <= n : NEW_LINE INDENT if ( n - ( i * a ) ) % b == 0 : NEW_LINE INDENT print ( "x = " , i , ", y = " , int ( ( n - ( i * a ) ) / b ) ) NEW_LINE return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT print ( "No solution" ) NEW_LINE DEDENT
def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while j * j <= i : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if i / j == j : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i / j NEW_LINE DEDENT DEDENT j = j + 1 NEW_LINE DEDENT DEDENT return int ( sum ) NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count , l , r = 0 , 0 , n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) : NEW_LINE INDENT l += 1 NEW_LINE r -= 1 NEW_LINE count += 1 NEW_LINE DEDENT elif ( ( arr1 [ l ] + arr2 [ r ] ) < x ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += int ( n / i ) * i NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT
def sum_all_divisors ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , math . floor ( math . sqrt ( num ) ) + 1 ) : NEW_LINE INDENT sum += t1 + t2 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def sumOfLargePrimeFactor ( n ) : NEW_LINE INDENT prime = [ 0 ] * ( n + 1 ) NEW_LINE sum = 0 NEW_LINE max = int ( n / 2 ) NEW_LINE for p in range ( 2 , max + 1 ) : NEW_LINE INDENT if prime [ p ] == 0 : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = p NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT sum += prime [ p ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT
def cpFact ( x , y ) : NEW_LINE INDENT while gcd ( x , y ) != 1 : NEW_LINE INDENT x = x / gcd ( x , y ) NEW_LINE DEDENT return int ( x ) NEW_LINE DEDENT
def binomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << n ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countUnsetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return ( r - l + 1 ) - countSetBits ( n & num ) NEW_LINE DEDENT
def evenPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = 2 * i NEW_LINE sum = sum + ( j * j * j * j ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def evenPowerSum ( n ) : NEW_LINE INDENT return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 NEW_LINE DEDENT
def balancedprime ( n ) : NEW_LINE INDENT prime = [ True ] * ( MAX + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT i = p * 2 NEW_LINE while i <= MAX : NEW_LINE INDENT prime [ i ] = False NEW_LINE i = i + p NEW_LINE DEDENT DEDENT p = p + 1 NEW_LINE DEDENT v = list ( ) NEW_LINE p = 3 NEW_LINE while p <= MAX : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT v . append ( p ) NEW_LINE DEDENT p = p + 2 NEW_LINE DEDENT count = 0 NEW_LINE i = 1 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if v [ i ] == ( v [ i + 1 ] + v [ i - 1 ] ) / 2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == n : NEW_LINE INDENT return v [ i ] NEW_LINE DEDENT DEDENT DEDENT
def calculateNoOFactors ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 1 NEW_LINE dup = factor [ n ] NEW_LINE c = 1 NEW_LINE j = int ( n / factor [ n ] ) NEW_LINE while ( j != 1 ) : NEW_LINE INDENT if ( factor [ j ] == dup ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dup = factor [ j ] NEW_LINE ans = ans * ( c + 1 ) NEW_LINE c = 1 NEW_LINE DEDENT j = int ( j / factor [ j ] ) NEW_LINE DEDENT ans = ans * ( c + 1 ) NEW_LINE return ans NEW_LINE DEDENT
def smallest ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( calculateNoOFactors ( i ) >= n ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
def squaresum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sm = sm + ( i * i ) NEW_LINE DEDENT return sm NEW_LINE DEDENT
def counLastDigitK ( low , high , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( i % 10 == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def minimumSum ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT
def lastDigit ( n ) : NEW_LINE INDENT return ( n % 10 ) NEW_LINE DEDENT
def numberOfTriangles ( n ) : NEW_LINE INDENT ans = 2 * ( pow ( 3 , n ) ) - 1 NEW_LINE return ans NEW_LINE DEDENT
def isPrime ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = 2 NEW_LINE while i * i <= x : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def findPrimes ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT print ( n , end = " " ) NEW_LINE DEDENT elif ( isPrime ( n - 2 ) ) : NEW_LINE INDENT print ( "2" , end = " " ) NEW_LINE print ( n - 2 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "3" , end = " " ) NEW_LINE n = n - 3 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( isPrime ( i ) and isPrime ( n - i ) ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE print ( ( n - i ) , end = " " ) NEW_LINE break NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT DEDENT
def checkDigits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT dig = n % 10 NEW_LINE if ( dig != 2 and dig != 3 and dig != 5 and dig != 7 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = n / 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def isFullPrime ( n ) : NEW_LINE INDENT return ( checkDigits ( n ) and prime ( n ) ) NEW_LINE DEDENT
def coef ( n ) : NEW_LINE INDENT c [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ 1 + i ] = 1 NEW_LINE for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT c [ j ] = c [ j - 1 ] - c [ j ] NEW_LINE DEDENT c [ 0 ] = - c [ 0 ] NEW_LINE DEDENT DEDENT
def isPrime ( n ) : NEW_LINE INDENT coef ( n ) NEW_LINE c [ 0 ] = c [ 0 ] + 1 NEW_LINE c [ n ] = c [ n ] - 1 NEW_LINE i = n NEW_LINE while ( i > - 1 and c [ i ] % n == 0 ) : NEW_LINE INDENT i = i - 1 NEW_LINE DEDENT return True if i < 0 else False NEW_LINE DEDENT
def motzkin ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ) NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT l = countDigit ( n ) NEW_LINE dup = n NEW_LINE sm = 0 NEW_LINE while ( dup ) : NEW_LINE INDENT sm = sm + pow ( dup % 10 , l ) NEW_LINE dup = dup // 10 NEW_LINE DEDENT return ( n == sm ) NEW_LINE DEDENT
def getResult ( st ) : NEW_LINE INDENT sum = 0 NEW_LINE length = len ( st ) NEW_LINE for i in st : NEW_LINE INDENT sum = sum + int ( i ) ** length NEW_LINE DEDENT number = int ( st ) NEW_LINE if ( number == sum ) : NEW_LINE INDENT return "true" NEW_LINE DEDENT else : NEW_LINE INDENT return "false" NEW_LINE DEDENT DEDENT
def solve ( low , high , T ) : NEW_LINE INDENT while low <= high : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( mid * ( mid + 1 ) ) == T : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > 0 and ( mid * ( mid + 1 ) ) > T and ( mid * ( mid - 1 ) ) <= T ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( mid * ( mid + 1 ) ) > T : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def nthSHN ( n , dp ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT dp [ n ] = 1 NEW_LINE return dp [ n ] NEW_LINE DEDENT if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n NEW_LINE return dp [ n ] NEW_LINE DEDENT
def summation ( n ) : NEW_LINE INDENT return sum ( [ i ** 2 for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT
def leyland ( n ) : NEW_LINE INDENT ans = [ ] NEW_LINE x = 2 NEW_LINE y = 2 NEW_LINE while x <= n : NEW_LINE INDENT y = 2 NEW_LINE while y <= x : NEW_LINE INDENT temp = pow ( x , y ) + pow ( y , x ) NEW_LINE ans . append ( temp ) NEW_LINE y = y + 1 NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT ans . sort ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT
def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT if ( a == ( result // b ) ) : NEW_LINE INDENT print ( result // b ) NEW_LINE return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def kthgroupsum ( k ) : NEW_LINE INDENT cur = int ( ( k * ( k - 1 ) ) + 1 ) NEW_LINE sum = 0 NEW_LINE while k : NEW_LINE INDENT sum += cur NEW_LINE cur += 2 NEW_LINE k = k - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def oddSum ( n ) : NEW_LINE INDENT return ( n * n ) NEW_LINE DEDENT
def mphTOkmph ( mph ) : NEW_LINE INDENT kmph = ( float ) ( mph * 1.60934 ) NEW_LINE return kmph NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return ( n * n ) + ( n * n * n ) NEW_LINE DEDENT
def trace ( n , m ) : NEW_LINE INDENT an = 1 + ( n - 1 ) * ( m + 1 ) NEW_LINE rowmajorSum = sn ( n , an ) NEW_LINE an = 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE colmajorSum = sn ( n , an ) NEW_LINE return int ( rowmajorSum + colmajorSum ) NEW_LINE DEDENT
def precompute ( prefix , suffix ) : NEW_LINE INDENT prime = [ True for i in range ( MAX ) ] NEW_LINE k = int ( sqrt ( MAX ) ) NEW_LINE for i in range ( 2 , k , 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT prefix [ 1 ] = 1 NEW_LINE suffix [ MAX - 1 ] = int ( 1e9 + 7 ) NEW_LINE for i in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT prefix [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] NEW_LINE DEDENT DEDENT i = MAX - 2 NEW_LINE while ( i > 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT suffix [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i ] = suffix [ i + 1 ] NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT
def query ( prefix , suffix , L , R ) : NEW_LINE INDENT if ( prefix [ R ] < L or suffix [ L ] > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return prefix [ R ] - suffix [ L ] NEW_LINE DEDENT DEDENT
def printXYZ ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "x is " , n ) NEW_LINE print ( "y is " , n + 1 ) NEW_LINE print ( "z is " , n * ( n + 1 ) ) NEW_LINE DEDENT DEDENT
def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) NEW_LINE DEDENT
def term ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans + i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) / 2 NEW_LINE DEDENT
def avgOfFirstN ( n ) : NEW_LINE INDENT return ( float ) ( 1 + n ) / 2 NEW_LINE DEDENT
def summation ( n ) : NEW_LINE INDENT return int ( ( pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ) NEW_LINE DEDENT
def sum ( x , n ) : NEW_LINE INDENT total = 1.0 NEW_LINE multi = x NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total = total + multi / i NEW_LINE multi = multi * x NEW_LINE DEDENT return total NEW_LINE DEDENT
def term ( n ) : NEW_LINE INDENT x = ( ( ( 1 ) + math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) NEW_LINE return x NEW_LINE DEDENT
def isMember ( a , d , x ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT return x == a NEW_LINE DEDENT return ( ( x - a ) % d == 0 and int ( ( x - a ) / d ) >= 0 ) NEW_LINE DEDENT
def compute ( a , b ) : NEW_LINE INDENT AM = ( a + b ) / 2 NEW_LINE GM = math . sqrt ( a * b ) NEW_LINE HM = ( GM * GM ) / AM NEW_LINE return HM NEW_LINE DEDENT
def countDigits ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT c += 1 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return c NEW_LINE DEDENT
def isDeserium ( x ) : NEW_LINE INDENT temp = x NEW_LINE p = countDigits ( x ) NEW_LINE sum = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT digit = int ( x % 10 ) NEW_LINE sum += pow ( digit , p ) NEW_LINE p -= 1 NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT return ( sum == temp ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def sameRemainder ( a , b , c ) : NEW_LINE INDENT a1 = ( b - a ) NEW_LINE b1 = ( c - b ) NEW_LINE c1 = ( c - a ) NEW_LINE return gcd ( a1 , gcd ( b1 , c1 ) ) NEW_LINE DEDENT
def mean ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT mean = sum / n NEW_LINE return mean NEW_LINE DEDENT
def sd ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ) NEW_LINE DEDENT sdd = sum / n NEW_LINE return sdd NEW_LINE DEDENT
def checkDivisibility ( num ) : NEW_LINE INDENT length = len ( num ) NEW_LINE if ( length == 1 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( length % 3 == 1 ) : NEW_LINE INDENT num = str ( num ) + "00" NEW_LINE length += 2 NEW_LINE DEDENT elif ( length % 3 == 2 ) : NEW_LINE INDENT num = str ( num ) + "0" NEW_LINE length += 1 NEW_LINE DEDENT sum = 0 NEW_LINE p = 1 NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE sum = sum + group * p NEW_LINE p *= ( - 1 ) NEW_LINE DEDENT sum = abs ( sum ) NEW_LINE return ( sum % 13 == 0 ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def findNumber ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = gcd ( ans , arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == ans ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def modularEquation ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT print ( "No solution possible " ) NEW_LINE return NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT print ( "Infinite Solution possible " ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE n = a - b NEW_LINE y = ( int ) ( math . sqrt ( a - b ) ) NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i > b ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( i > b ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT if ( y * y == n and y > b ) : NEW_LINE INDENT count = count - 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def SieveofEratosthenes ( n ) : NEW_LINE INDENT visited = [ False ] * ( n + 2 ) NEW_LINE for i in range ( 2 , n + 2 ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT for j in range ( i * i , n + 2 , i ) : NEW_LINE INDENT visited [ j ] = True NEW_LINE DEDENT primes . append ( i ) NEW_LINE DEDENT DEDENT DEDENT
def specialPrimeNumbers ( n , k ) : NEW_LINE INDENT SieveofEratosthenes ( n ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT for j in range ( i - 1 ) : NEW_LINE INDENT if ( primes [ j ] + primes [ j + 1 ] + 1 == primes [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( count == k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def minOp ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num ) : NEW_LINE INDENT rem = num % 10 NEW_LINE if ( not ( rem == 3 or rem == 8 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT num = num // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findSubarraySum ( arr , n , Sum ) : NEW_LINE INDENT prevSum = defaultdict ( lambda : 0 ) NEW_LINE res = 0 NEW_LINE currsum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT currsum += arr [ i ] NEW_LINE if currsum == Sum : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( currsum - Sum ) in prevSum : NEW_LINE INDENT res += prevSum [ currsum - Sum ] NEW_LINE DEDENT prevSum [ currsum ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def minimumMoves ( A , N ) : NEW_LINE INDENT one = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] == 1 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT if ( one != 0 ) : NEW_LINE INDENT return N - one NEW_LINE DEDENT minimum = + 2147483647 NEW_LINE for i in range ( N ) : NEW_LINE INDENT g = A [ i ] NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT g = __gcd ( A [ j ] , g ) NEW_LINE if ( g == 1 ) : NEW_LINE INDENT minimum = min ( minimum , j - i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minimum == + 2147483647 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return N + minimum - 1 NEW_LINE DEDENT DEDENT
def sumSquare ( n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT s [ i * i ] = 1 NEW_LINE if ( n - i * i ) in s . keys ( ) : NEW_LINE INDENT print ( ( n - i * i ) ** ( 1 / 2 ) , "^2 +" , i , "^2" ) NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ k ] == product ) : NEW_LINE INDENT result = result + 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def judgeSquareSum ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % i == 0 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = int ( n / i ) NEW_LINE DEDENT if ( i % 4 == 3 and count % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return n % 4 != 3 NEW_LINE DEDENT
def preCompute ( mat , prefixCnt ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 0 ) : NEW_LINE INDENT prefixCnt [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prefixCnt [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT prefixCnt [ i ] [ j ] += prefixCnt [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT prefixCnt [ i ] [ j ] += prefixCnt [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return prefixCnt NEW_LINE DEDENT
def countQuery ( prefixCnt , pi , pj , qi , qj ) : NEW_LINE INDENT cnt = prefixCnt [ qi ] [ qj ] NEW_LINE if ( pi > 0 ) : NEW_LINE INDENT cnt -= prefixCnt [ pi - 1 ] [ qj ] NEW_LINE DEDENT if ( pj > 0 ) : NEW_LINE INDENT cnt -= prefixCnt [ qi ] [ pj - 1 ] NEW_LINE DEDENT if ( pi > 0 and pj > 0 ) : NEW_LINE INDENT cnt += prefixCnt [ pi - 1 ] [ pj - 1 ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def series ( n , d ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( "0" , end = ' ' ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT print ( "%.5f" % ( ( math . pow ( - 1 , i ) * d ) ) , end = ' ' ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT m = n NEW_LINE r = ( m / ( m - 1 ) ) NEW_LINE g = ( float ) ( d * float ( math . sqrt ( r ) ) ) NEW_LINE print ( "0 " , end = ' ' ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT print ( "%.5f" % ( math . pow ( - 1 , i ) * g ) , end = ' ' ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT print ( "" ) NEW_LINE DEDENT
def countDigitOne ( n ) : NEW_LINE INDENT countr = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT str1 = str ( i ) NEW_LINE countr += str1 . count ( "1" ) NEW_LINE DEDENT return countr NEW_LINE DEDENT
def countDigitOne ( n ) : NEW_LINE INDENT countr = 0 NEW_LINE i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT divider = i * 10 NEW_LINE countr += ( int ( n / divider ) * i + min ( max ( n % divider - i + 1 , 0 ) , i ) ) NEW_LINE i *= 10 NEW_LINE DEDENT return countr NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE Hash = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] NEW_LINE if product in ( Hash ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def check ( a , b ) : NEW_LINE INDENT c = 0 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT c = c + a % 10 NEW_LINE a = int ( a / 10 ) NEW_LINE DEDENT return True if ( c == b ) else False NEW_LINE DEDENT
def root ( n ) : NEW_LINE INDENT found = False NEW_LINE mx = 1000000000000000001 NEW_LINE for i in range ( 91 ) : NEW_LINE INDENT s = i * i + 4 * n NEW_LINE sq = int ( math . sqrt ( s ) ) NEW_LINE if ( sq * sq == s and check ( int ( ( sq - i ) / 2 ) , i ) ) : NEW_LINE INDENT found = True NEW_LINE mx = min ( mx , int ( ( sq - i ) / 2 ) ) NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT return mx NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def factors ( n ) : NEW_LINE INDENT prime = dict ( ) NEW_LINE for i in range ( 2 , mt . ceil ( mt . sqrt ( n + 1 ) ) ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT if i in prime . keys ( ) : NEW_LINE INDENT prime [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT prime [ i ] = 1 NEW_LINE DEDENT n = n // i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT if n in prime . keys ( ) : NEW_LINE INDENT prime [ n ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT prime [ n ] = 1 NEW_LINE DEDENT DEDENT ans1 = 1 NEW_LINE ans2 = 1 NEW_LINE for it in prime : NEW_LINE INDENT ans1 *= 2 * prime [ it ] + 1 NEW_LINE ans2 *= prime [ it ] + 1 NEW_LINE DEDENT return ans1 - ans2 NEW_LINE DEDENT
def gcdOfFactorial ( m , n ) : NEW_LINE INDENT return math . factorial ( min ( m , n ) ) NEW_LINE DEDENT
def asPowerSum ( w , m ) : NEW_LINE INDENT while ( m > 0 ) : NEW_LINE INDENT if ( ( m - 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m - 1 ) / w NEW_LINE DEDENT elif ( ( m + 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m + 1 ) / w NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = m / w NEW_LINE DEDENT else : NEW_LINE INDENT return ( m == 0 ) NEW_LINE DEDENT DEDENT DEDENT
def dotProduct ( vect_A , vect_B ) : NEW_LINE INDENT product = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product = product + vect_A [ i ] * vect_B [ i ] NEW_LINE DEDENT return product NEW_LINE DEDENT
def crossProduct ( vect_A , vect_B , cross_P ) : NEW_LINE INDENT cross_P . append ( vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ) NEW_LINE cross_P . append ( vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ) NEW_LINE cross_P . append ( vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ) NEW_LINE DEDENT
def calculate ( n , power ) : NEW_LINE INDENT return sum ( [ int ( i ) for i in str ( pow ( n , power ) ) ] ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( 1 * res * x ) % p NEW_LINE DEDENT x = ( 1 * x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def countEvenWays ( n ) : NEW_LINE INDENT return power ( 2 , n / 2 - 1 , MOD ) NEW_LINE DEDENT
def cal_factor ( ) : NEW_LINE INDENT factor [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT factor [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAX , 2 ) : NEW_LINE INDENT factor [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while i * i < MAX : NEW_LINE INDENT if ( factor [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT if ( factor [ j ] == j ) : NEW_LINE INDENT factor [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def no_of_representations ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE flag = 0 NEW_LINE while ( factor [ temp ] != 1 ) : NEW_LINE INDENT flag = - 1 NEW_LINE count += 1 NEW_LINE temp = temp // factor [ temp ] NEW_LINE DEDENT count += flag NEW_LINE DEDENT return count NEW_LINE DEDENT
def coprime ( a , b ) : NEW_LINE INDENT return 1 if ( math . gcd ( a , b ) == 1 ) else 0 NEW_LINE DEDENT
def pairSum ( n ) : NEW_LINE INDENT mid = int ( n / 2 ) NEW_LINE i = mid NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( coprime ( i , n - i ) == 1 ) : NEW_LINE INDENT print ( i , n - i ) NEW_LINE break NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT DEDENT
def coutSubSeq ( A , N , M ) : NEW_LINE INDENT sum = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT for k in range ( j + 1 , N ) : NEW_LINE INDENT sum = A [ i ] + A [ j ] + A [ k ] NEW_LINE if ( sum % M == 0 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countSubSeq ( A , N , M ) : NEW_LINE INDENT ans = 0 NEW_LINE h = [ 0 ] * M NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT A [ i ] = A [ i ] % M NEW_LINE h [ A [ i ] ] = h [ A [ i ] ] + 1 NEW_LINE DEDENT for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( i , M ) : NEW_LINE INDENT rem = ( M - ( i + j ) % M ) % M NEW_LINE if ( rem < j ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == j and rem == j ) : NEW_LINE INDENT ans = ans + h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 NEW_LINE DEDENT elif ( i == j ) : NEW_LINE INDENT ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ) NEW_LINE DEDENT elif ( i == rem ) : NEW_LINE INDENT ans = ans + h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 NEW_LINE DEDENT elif ( rem == j ) : NEW_LINE INDENT ans = ans + h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + h [ i ] * h [ j ] * h [ rem ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
def findTerm ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT term = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT term = term * 2 + ( i - 1 ) NEW_LINE DEDENT DEDENT return term NEW_LINE DEDENT
def findNumber ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE i = 1 NEW_LINE while n >= 0 : NEW_LINE INDENT n -= i NEW_LINE i += 1 NEW_LINE DEDENT return ( n + i ) NEW_LINE DEDENT
def findNumber ( n ) : NEW_LINE INDENT x = int ( math . floor ( ( - 1 + math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ) NEW_LINE base = ( x * ( x + 1 ) ) / 2 + 1 NEW_LINE return n - base + 1 NEW_LINE DEDENT
def correlationCoefficient ( X , Y , n ) : NEW_LINE INDENT sum_X = 0 NEW_LINE sum_Y = 0 NEW_LINE sum_XY = 0 NEW_LINE squareSum_X = 0 NEW_LINE squareSum_Y = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum_X = sum_X + X [ i ] NEW_LINE sum_Y = sum_Y + Y [ i ] NEW_LINE sum_XY = sum_XY + X [ i ] * Y [ i ] NEW_LINE squareSum_X = squareSum_X + X [ i ] * X [ i ] NEW_LINE squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( float ) ( math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) NEW_LINE return corr NEW_LINE DEDENT
def result ( n , k , t ) : NEW_LINE INDENT if ( t <= k ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT elif ( t <= n ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = t - n NEW_LINE temp = k - temp NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT
def weightedMean ( X , W , n ) : NEW_LINE INDENT sum = 0 NEW_LINE numWeight = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT numWeight = numWeight + X [ i ] * W [ i ] NEW_LINE sum = sum + W [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT return ( float ) ( numWeight / sum ) NEW_LINE DEDENT
def weightedMean ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) / 3 NEW_LINE DEDENT
def sumOfDigits ( a ) : NEW_LINE INDENT sm = 0 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT sm = sm + a % 10 NEW_LINE a = a // 10 NEW_LINE DEDENT return sm NEW_LINE DEDENT
def findMax ( x ) : NEW_LINE INDENT b = 1 NEW_LINE ans = x NEW_LINE while ( x != 0 ) : NEW_LINE INDENT cur = ( x - 1 ) * b + ( b - 1 ) NEW_LINE if ( sumOfDigits ( cur ) > sumOfDigits ( ans ) or ( sumOfDigits ( cur ) == sumOfDigits ( ans ) and cur > ans ) ) : NEW_LINE INDENT ans = cur NEW_LINE DEDENT x = x // 10 NEW_LINE b = b * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def series ( n ) : NEW_LINE INDENT print ( ( 8 * n ** 2 ) + 1 ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT return gcd ( b , a ) NEW_LINE DEDENT if ( abs ( b ) < 0.001 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( b , a - math . floor ( a / b ) * b ) ) NEW_LINE DEDENT DEDENT
def harmonicMean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 1 ) / arr [ i ] NEW_LINE DEDENT return n / sm NEW_LINE DEDENT
def harmonicMean ( arr , freq , n ) : NEW_LINE INDENT sm = 0 NEW_LINE frequency_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + freq [ i ] / arr [ i ] NEW_LINE frequency_sum = frequency_sum + freq [ i ] NEW_LINE DEDENT return ( round ( frequency_sum / sm , 4 ) ) NEW_LINE DEDENT
def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = math . floor ( a [ i ] / mul ) NEW_LINE print ( x , end = " " ) NEW_LINE DEDENT DEDENT
def modBigNumber ( num , m ) : NEW_LINE INDENT vec = [ ] NEW_LINE mod = 0 NEW_LINE for i in range ( 0 , len ( num ) , 1 ) : NEW_LINE INDENT digit = ord ( num [ i ] ) - ord ( '0' ) NEW_LINE mod = mod * 10 + digit NEW_LINE quo = int ( mod / m ) NEW_LINE vec . append ( quo ) NEW_LINE mod = mod % m NEW_LINE DEDENT print ( "Remainder :" , mod ) NEW_LINE print ( "Quotient :" , end = " " ) NEW_LINE zeroflag = 0 NEW_LINE for i in range ( 0 , len ( vec ) , 1 ) : NEW_LINE INDENT if ( vec [ i ] == 0 and zeroflag == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT zeroflag = 1 NEW_LINE print ( vec [ i ] , end = "" ) NEW_LINE DEDENT return NEW_LINE DEDENT
def findPowerOfP ( n , p ) : NEW_LINE INDENT count = 0 NEW_LINE r = p NEW_LINE while ( r <= n ) : NEW_LINE INDENT count += ( n // r ) NEW_LINE r = r * p NEW_LINE DEDENT return count NEW_LINE DEDENT
def primeFactorsofK ( k ) : NEW_LINE INDENT ans = [ ] NEW_LINE i = 2 NEW_LINE while k != 1 : NEW_LINE INDENT if k % i == 0 : NEW_LINE INDENT count = 0 NEW_LINE while k % i == 0 : NEW_LINE INDENT k = k // i NEW_LINE count += 1 NEW_LINE DEDENT ans . append ( [ i , count ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def largestPowerOfK ( n , k ) : NEW_LINE INDENT vec = primeFactorsofK ( k ) NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( len ( vec ) ) : NEW_LINE INDENT ans = min ( ans , findPowerOfP ( n , vec [ i ] [ 0 ] ) // vec [ i ] [ 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def calculate_sum ( a , N ) : NEW_LINE INDENT m = N / a NEW_LINE sum = m * ( m + 1 ) / 2 NEW_LINE ans = a * sum NEW_LINE print ( "Sum of multiples of " , a , " up to " , N , " = " , ans ) NEW_LINE DEDENT
def fourDistinctFactors ( ) : NEW_LINE INDENT primeAll = [ True ] * ( N + 1 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( primeAll [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= N ) : NEW_LINE INDENT primeAll [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT prime = [ ] NEW_LINE for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( primeAll [ p ] ) : NEW_LINE INDENT prime . append ( p ) NEW_LINE DEDENT DEDENT for i in range ( len ( prime ) ) : NEW_LINE INDENT p = prime [ i ] NEW_LINE if ( 1 * p * p * p <= N ) : NEW_LINE INDENT fourDiv [ p * p * p ] = True NEW_LINE DEDENT for j in range ( i + 1 , len ( prime ) ) : NEW_LINE INDENT q = prime [ j ] NEW_LINE if ( 1 * p * q > N ) : NEW_LINE INDENT break NEW_LINE DEDENT fourDiv [ p * q ] = True NEW_LINE DEDENT DEDENT DEDENT
def horner ( poly , n , x ) : NEW_LINE INDENT result = poly [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result = ( result * x + poly [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def findSign ( poly , n , x ) : NEW_LINE INDENT result = horner ( poly , n , x ) NEW_LINE if ( result > 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( result < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def ucal ( u , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = u NEW_LINE for i in range ( 1 , int ( n / 2 + 1 ) ) : NEW_LINE INDENT temp = temp * ( u - i ) NEW_LINE DEDENT for i in range ( 1 , int ( n / 2 ) ) : NEW_LINE INDENT temp = temp * ( u + i ) NEW_LINE DEDENT return temp NEW_LINE DEDENT
def digitLCM ( n ) : NEW_LINE INDENT lcm = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT lcm = int ( ( n % 10 * lcm ) / lcm_fun ( n % 10 , lcm ) ) NEW_LINE if ( lcm == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT
def gcdMax ( a , b , n , N ) : NEW_LINE INDENT cnt = [ 0 ] * N NEW_LINE first = [ 0 ] * N NEW_LINE second = [ 0 ] * N NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ a [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( cnt [ j ] ) : NEW_LINE INDENT first [ i ] = max ( first [ i ] , j ) NEW_LINE DEDENT DEDENT DEDENT cnt = [ 0 ] * N NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ b [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( cnt [ j ] > 0 ) : NEW_LINE INDENT second [ i ] = max ( second [ i ] , j ) NEW_LINE DEDENT DEDENT DEDENT i = N - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( first [ i ] > 0 and second [ i ] > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( str ( first [ i ] ) + " " + str ( second [ i ] ) ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
def ispowerof2 ( num ) : NEW_LINE INDENT if ( ( num & ( num - 1 ) ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def median ( a , l , r ) : NEW_LINE INDENT n = r - l + 1 NEW_LINE n = ( n + 1 ) // 2 - 1 NEW_LINE return n + l NEW_LINE DEDENT
def IQR ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE mid_index = median ( a , 0 , n ) NEW_LINE Q1 = a [ median ( a , 0 , mid_index ) ] NEW_LINE Q3 = a [ mid_index + median ( a , mid_index + 1 , n ) ] NEW_LINE return ( Q3 - Q1 ) NEW_LINE DEDENT
def printPierpont ( n ) : NEW_LINE INDENT arr = [ False ] * ( n + 1 ) NEW_LINE two = 1 NEW_LINE three = 1 NEW_LINE while ( two + 1 < n ) : NEW_LINE INDENT arr [ two ] = True NEW_LINE while ( two * three + 1 < n ) : NEW_LINE INDENT arr [ three ] = True NEW_LINE arr [ two * three ] = True NEW_LINE three *= 3 NEW_LINE DEDENT three = 1 NEW_LINE two *= 2 NEW_LINE DEDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT v . append ( i + 1 ) NEW_LINE DEDENT DEDENT arr1 = [ False ] * ( len ( arr ) ) NEW_LINE p = 2 NEW_LINE while ( p * p < n ) : NEW_LINE INDENT if ( arr1 [ p ] == False ) : NEW_LINE INDENT for i in range ( p * 2 , n , p ) : NEW_LINE INDENT arr1 [ i ] = True NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT if ( not arr1 [ v [ i ] ] ) : NEW_LINE INDENT print ( v [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def isWoodall ( x ) : NEW_LINE INDENT if ( x % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( x == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT p = 0 NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = x / 2 NEW_LINE p = p + 1 NEW_LINE if ( p == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def print_result ( a , n , k , m ) : NEW_LINE INDENT v = [ [ ] for i in range ( m ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT rem = a [ i ] % m NEW_LINE v [ rem ] . append ( a [ i ] ) NEW_LINE if ( len ( v [ rem ] ) == k ) : NEW_LINE INDENT for j in range ( 0 , k ) : NEW_LINE INDENT print ( v [ rem ] [ j ] , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def smallestX ( n ) : NEW_LINE INDENT temp = [ 0 ] * 10 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE x = 1 NEW_LINE while ( count < 10 ) : NEW_LINE INDENT y = x * n NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( temp [ y % 10 ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE temp [ y % 10 ] = 1 NEW_LINE DEDENT y = int ( y / 10 ) NEW_LINE DEDENT x += 1 NEW_LINE DEDENT return x - 1 NEW_LINE DEDENT
def digSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE rem = 0 NEW_LINE while ( n ) : NEW_LINE INDENT rem = n % 10 NEW_LINE sum = sum + rem NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findX ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( i + digSum ( i ) == n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def isDivisible ( x , y ) : NEW_LINE INDENT if ( y == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT z = gcd ( x , y ) NEW_LINE if ( z == 1 ) : NEW_LINE INDENT return false NEW_LINE DEDENT return isDivisible ( x , y / z ) NEW_LINE DEDENT
def isDigitPresent ( m , Hash ) : NEW_LINE INDENT while ( m ) : NEW_LINE INDENT if ( Hash [ m % 10 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT m = m // 10 NEW_LINE DEDENT return False NEW_LINE DEDENT
def countDivisibles ( n ) : NEW_LINE INDENT Hash = [ False for i in range ( 10 ) ] NEW_LINE m = n NEW_LINE while ( m ) : NEW_LINE INDENT Hash [ m % 10 ] = True NEW_LINE m = m // 10 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( isDigitPresent ( i , Hash ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( n // i != i ) : NEW_LINE INDENT if ( isDigitPresent ( n // i , Hash ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def printTwoDivisibleParts ( num , f , s ) : NEW_LINE INDENT N = len ( num ) NEW_LINE prefixReminder = [ 0 ] * ( N + 1 ) NEW_LINE suffixReminder = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT suffixReminder [ i ] = ( suffixReminder [ i - 1 ] * 10 + ( ord ( num [ i - 1 ] ) - 48 ) ) % f NEW_LINE DEDENT base = 1 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT prefixReminder [ i ] = ( prefixReminder [ i + 1 ] + ( ord ( num [ i ] ) - 48 ) * base ) % s NEW_LINE base = ( base * 10 ) % s NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( prefixReminder [ i ] == 0 and suffixReminder [ i ] == 0 and num [ i ] != '0' ) : NEW_LINE INDENT print ( num [ 0 : i ] , num [ i : N ] ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT print ( "Not Possible" ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT rem = 0 NEW_LINE sum_of_digits = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rem = n % 10 NEW_LINE sum_of_digits += rem NEW_LINE n = n // 10 NEW_LINE DEDENT return sum_of_digits NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( n - 97 , n + 1 ) : NEW_LINE INDENT a = sum ( i ) NEW_LINE b = sum ( a ) NEW_LINE if ( ( i + a + b ) == n ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT
def isPowerOfK ( n , k ) : NEW_LINE INDENT oneSeen = False NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % k NEW_LINE if ( digit > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( digit == 1 ) : NEW_LINE INDENT if ( oneSeen ) : NEW_LINE INDENT return False NEW_LINE DEDENT oneSeen = True NEW_LINE DEDENT n //= k NEW_LINE DEDENT return True NEW_LINE DEDENT
def isOctal ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) >= 8 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT n = int ( n / 10 ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def printFactorialNums ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 2 NEW_LINE while fact <= n : NEW_LINE INDENT print ( fact , end = " " ) NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT DEDENT
def Cel_To_Fah ( n ) : NEW_LINE INDENT return ( n * 1.8 ) + 32 NEW_LINE DEDENT
def printPairs ( arr , n , k ) : NEW_LINE INDENT isPairFound = True NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i != j and arr [ i ] % arr [ j ] == k ) : NEW_LINE INDENT print ( "(" , arr [ i ] , ", " , arr [ j ] , ")" , sep = "" , end = " " ) NEW_LINE isPairFound = True NEW_LINE DEDENT DEDENT DEDENT return isPairFound NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT k = int ( sqrt ( n ) ) + 1 NEW_LINE for i in range ( 5 , k , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def print_sequence ( n , k ) : NEW_LINE INDENT b = int ( n / ( k * ( k + 1 ) / 2 ) ) NEW_LINE if b == 0 : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT else : NEW_LINE INDENT r = 1 NEW_LINE x = 1 NEW_LINE while x ** 2 <= n : NEW_LINE INDENT if n % x != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT elif x <= b and x > r : NEW_LINE INDENT r = x NEW_LINE DEDENT elif n / x <= b and n / x > r : NEW_LINE INDENT r = n / x NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < k : NEW_LINE INDENT print ( r * i , end = " " ) NEW_LINE i = i + 1 NEW_LINE DEDENT last_term = n - ( r * ( k * ( k - 1 ) / 2 ) ) NEW_LINE print ( last_term ) NEW_LINE DEDENT DEDENT
def countCompositions ( n ) : NEW_LINE INDENT return ( 2 ** ( n - 1 ) ) NEW_LINE DEDENT
def computeLastDigit ( A , B ) : NEW_LINE INDENT variable = 1 NEW_LINE DEDENT return 1 NEW_LINE elif ( ( B - A ) >= 5 ) : return 0 NEW_LINE
def findSumSubsets ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
def findMin ( a , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = m . exp ( _sum / n ) NEW_LINE DEDENT return int ( x + 1 ) NEW_LINE DEDENT
def countdigits ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N ) : NEW_LINE INDENT count = count + 1 NEW_LINE N = int ( math . floor ( N / 10 ) ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + a NEW_LINE a = a + d NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT
def printPairs ( arr , n , k ) : NEW_LINE INDENT occ = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT occ [ arr [ i ] ] = True NEW_LINE DEDENT isPairFound = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( occ [ k ] and k < arr [ i ] ) : NEW_LINE INDENT print ( "(" , k , "," , arr [ i ] , ")" , end = " " ) NEW_LINE isPairFound = True NEW_LINE DEDENT if ( arr [ i ] >= k ) : NEW_LINE INDENT v = findDivisors ( arr [ i ] - k ) NEW_LINE for j in range ( len ( v ) ) : NEW_LINE INDENT if ( arr [ i ] % v [ j ] == k and arr [ i ] != v [ j ] and occ [ v [ j ] ] ) : NEW_LINE INDENT print ( "(" , arr [ i ] , "," , v [ j ] , ")" , end = " " ) NEW_LINE isPairFound = True NEW_LINE DEDENT DEDENT DEDENT DEDENT return isPairFound NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT x = 0 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT x = ( n / 2 ) * ( n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT x = ( ( n + 1 ) / 2 ) * n NEW_LINE DEDENT return ( int ) ( x * x ) NEW_LINE DEDENT
def findValue ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT ans = ans if ans > ( abs ( arr [ i ] - arr [ j ] ) + abs ( i - j ) ) else ( abs ( arr [ i ] - arr [ j ] ) + abs ( i - j ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findValue ( arr , n ) : NEW_LINE INDENT a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( arr [ i ] + i ) NEW_LINE b . append ( arr [ i ] - i ) NEW_LINE DEDENT x = a [ 0 ] NEW_LINE y = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT x = a [ i ] NEW_LINE DEDENT if ( a [ i ] < y ) : NEW_LINE INDENT y = a [ i ] NEW_LINE DEDENT DEDENT ans1 = ( x - y ) NEW_LINE x = b [ 0 ] NEW_LINE y = b [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] > x ) : NEW_LINE INDENT x = b [ i ] NEW_LINE DEDENT if ( b [ i ] < y ) : NEW_LINE INDENT y = b [ i ] NEW_LINE DEDENT DEDENT ans2 = ( x - y ) NEW_LINE return max ( ans1 , ans2 ) NEW_LINE DEDENT
def countsubarray ( array , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if array [ i ] < k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT mul = array [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT mul = mul * array [ j ] NEW_LINE if mul < k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def multiplyFactors ( n ) : NEW_LINE INDENT prod = 1 NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT prod = ( prod * i ) % M NEW_LINE DEDENT else : NEW_LINE INDENT prod = ( prod * i ) % M NEW_LINE prod = ( prod * n / i ) % M NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return prod NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) % M NEW_LINE DEDENT y = ( y >> 1 ) % M NEW_LINE x = ( x * x ) % M NEW_LINE DEDENT return res NEW_LINE DEDENT
def countFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = count + 2 NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def multiplyFactors ( n ) : NEW_LINE INDENT numFactor = countFactors ( n ) NEW_LINE product = power ( n , numFactor / 2 ) NEW_LINE if ( numFactor % 2 == 1 ) : NEW_LINE INDENT product = ( product * ( int ) ( math . sqrt ( n ) ) ) % M NEW_LINE DEDENT return product NEW_LINE DEDENT
def printTrib ( n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = dp [ 1 ] = 0 NEW_LINE dp [ 2 ] = 1 NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( dp [ i ] , " " , end = "" ) NEW_LINE DEDENT DEDENT
def power ( T , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT M = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] NEW_LINE power ( T , n // 2 ) NEW_LINE multiply ( T , T ) NEW_LINE if ( n % 2 ) : NEW_LINE INDENT multiply ( T , M ) NEW_LINE DEDENT DEDENT
def tribonacci ( n ) : NEW_LINE INDENT T = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] NEW_LINE if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT power ( T , n - 2 ) NEW_LINE DEDENT return T [ 0 ] [ 0 ] NEW_LINE DEDENT
def getMaxOccuringChar ( str ) : NEW_LINE INDENT count = [ 0 ] * ASCII_SIZE NEW_LINE for i in str : NEW_LINE INDENT count [ ord ( i ) ] += 1 NEW_LINE DEDENT max = - 1 NEW_LINE c = '' NEW_LINE for i in str : NEW_LINE INDENT if max < count [ ord ( i ) ] : NEW_LINE INDENT max = count [ ord ( i ) ] NEW_LINE c = i NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT
def counDivisors ( X ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , X + 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countDivisorsMult ( arr , n ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mul *= arr [ i ] NEW_LINE DEDENT return counDivisors ( mul ) NEW_LINE DEDENT
def SieveOfEratosthenes ( largest , prime ) : NEW_LINE INDENT isPrime = [ True ] * ( largest + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= largest : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , largest + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , largest + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT prime . append ( p ) NEW_LINE DEDENT DEDENT DEDENT
def countDivisorsMult ( arr , n ) : NEW_LINE INDENT largest = max ( arr ) NEW_LINE prime = [ ] NEW_LINE SieveOfEratosthenes ( largest , prime ) NEW_LINE mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( prime ) ) : NEW_LINE INDENT while ( arr [ i ] > 1 and arr [ i ] % prime [ j ] == 0 ) : NEW_LINE INDENT arr [ i ] //= prime [ j ] NEW_LINE mp [ prime [ j ] ] += 1 NEW_LINE DEDENT DEDENT if ( arr [ i ] != 1 ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT res = 1 NEW_LINE for it in mp . values ( ) : NEW_LINE INDENT res *= ( it + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def generatePrimeFactors ( ) : NEW_LINE INDENT factor [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT factor [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAX , 2 ) : NEW_LINE INDENT factor [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i < MAX ) : NEW_LINE INDENT if ( factor [ i ] == i ) : NEW_LINE INDENT j = i * i NEW_LINE while ( j < MAX ) : NEW_LINE INDENT if ( factor [ j ] == j ) : NEW_LINE INDENT factor [ j ] = i NEW_LINE DEDENT j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def calculateNoOFactors ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 1 NEW_LINE dup = factor [ n ] NEW_LINE c = 1 NEW_LINE j = int ( n / factor [ n ] ) NEW_LINE while ( j > 1 ) : NEW_LINE INDENT if ( factor [ j ] == dup ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dup = factor [ j ] NEW_LINE ans = ans * ( c + 1 ) NEW_LINE c = 1 NEW_LINE DEDENT j = int ( j / factor [ j ] ) NEW_LINE DEDENT ans = ans * ( c + 1 ) NEW_LINE return ans NEW_LINE DEDENT
def digit_product_Sum ( N ) : NEW_LINE INDENT a = [ 0 ] * ( N + 1 ) NEW_LINE product = 1 NEW_LINE a [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = int ( a [ i - 1 ] / 10 ) NEW_LINE if ( product == 0 ) : NEW_LINE INDENT product = 1 NEW_LINE DEDENT else : NEW_LINE INDENT product = a [ i - 1 ] % 10 NEW_LINE DEDENT val = int ( a [ i - 1 ] / 10 ) NEW_LINE if ( val == 0 ) : NEW_LINE INDENT val = a [ i - 1 ] NEW_LINE DEDENT a [ i ] = a [ i - 1 ] + ( val * product ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def geometricMean ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE DEDENT gm = ( float ) ( math . pow ( product , ( 1 / n ) ) ) NEW_LINE return ( float ) ( gm ) NEW_LINE DEDENT
def geometricMean ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + math . log ( arr [ i ] ) NEW_LINE DEDENT sum = sum / n NEW_LINE return math . exp ( sum ) NEW_LINE DEDENT
def smallestNumber ( n ) : NEW_LINE INDENT if ( n >= 0 and n <= 9 ) : NEW_LINE INDENT return n NEW_LINE DEDENT digits = list ( ) NEW_LINE for i in range ( 9 , 1 , - 1 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT digits . append ( i ) NEW_LINE n = n // i NEW_LINE DEDENT DEDENT if ( n != 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT k = 0 NEW_LINE while ( len ( digits ) != 0 ) : NEW_LINE INDENT k = k * 10 + digits [ - 1 ] NEW_LINE digits . pop ( ) NEW_LINE DEDENT return k NEW_LINE DEDENT
def isMagic ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = sum NEW_LINE sum = 0 NEW_LINE DEDENT sum = sum + n % 10 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return True if ( sum == 1 ) else False NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def checkCircular ( N ) : NEW_LINE INDENT count = 0 NEW_LINE temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE temp = temp / 10 NEW_LINE DEDENT num = N NEW_LINE while ( isPrime ( num ) ) : NEW_LINE INDENT rem = num % 10 NEW_LINE div = num / 10 NEW_LINE num = ( int ) ( ( math . pow ( 10 , count - 1 ) ) * rem ) + div NEW_LINE if ( num == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def productOfSingelDgt ( n ) : NEW_LINE INDENT if n >= 0 and n <= 9 : NEW_LINE INDENT return True NEW_LINE DEDENT prime = [ 2 , 3 , 5 , 7 ] NEW_LINE i = 0 NEW_LINE while i < SIZE and n > 1 : NEW_LINE INDENT while n % prime [ i ] == 0 : NEW_LINE INDENT n = n / prime [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return n == 1 NEW_LINE DEDENT
def printSequence ( n ) : NEW_LINE INDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE x = 1 NEW_LINE while x <= n : NEW_LINE INDENT sum = sum + x NEW_LINE x = x + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) / 2 NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return ( n / 2 ) * ( n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) / 2 ) * n NEW_LINE DEDENT DEDENT
def count ( x , y ) : NEW_LINE INDENT m = dict ( ) NEW_LINE while x % y != 0 : NEW_LINE INDENT x %= y NEW_LINE ans += 1 NEW_LINE if x in m : NEW_LINE INDENT return - 1 NEW_LINE DEDENT m [ x ] = 1 NEW_LINE x *= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT a = float ( n / 2 ) NEW_LINE if ( n % 2 != 0 ) : NEW_LINE INDENT print ( ( math . ceil ( a ) - 1 ) , ( math . floor ( a ) + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( a % 2 == 0 ) : NEW_LINE INDENT print ( ( math . ceil ( a ) - 1 ) , ( math . floor ( a ) + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( math . ceil ( a ) - 2 ) , ( math . floor ( a ) + 2 ) ) NEW_LINE DEDENT DEDENT DEDENT
def divCount ( n ) : NEW_LINE INDENT hh = [ 1 ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while ( ( p * p ) < n ) : NEW_LINE INDENT if ( hh [ p ] == 1 ) : NEW_LINE INDENT for i in range ( ( p * 2 ) , n , p ) : NEW_LINE INDENT hh [ i ] = 0 NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT total = 1 NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( hh [ p ] == 1 ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % p == 0 ) : NEW_LINE INDENT while ( n % p == 0 ) : NEW_LINE INDENT n = int ( n / p ) NEW_LINE count += 1 NEW_LINE DEDENT total *= ( count + 1 ) NEW_LINE DEDENT DEDENT DEDENT return total NEW_LINE DEDENT
def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ 0 ] * ( N + 1 ) NEW_LINE i = 2 NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT for j in range ( 2 * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE arr [ i ] = 1 NEW_LINE DEDENT return max ( arr ) NEW_LINE DEDENT
def maxPrimefactorNum ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr = [ True ] * ( N + 1 ) NEW_LINE prod = 1 NEW_LINE res = 0 NEW_LINE p = 2 NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( arr [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , N + 1 , p ) : NEW_LINE INDENT arr [ i ] = False NEW_LINE DEDENT prod *= p NEW_LINE if ( prod > N ) : NEW_LINE INDENT return res NEW_LINE DEDENT res += 1 NEW_LINE DEDENT p += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def arraySum ( arr , n ) : NEW_LINE INDENT x = ( n + 1 ) / 2 NEW_LINE return ( arr [ 0 ] - 1 ) * n + x * x NEW_LINE DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a * b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT
def area_fun ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT
def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n / divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n // divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( n % divisor ) // 10 NEW_LINE divisor = divisor / 100 NEW_LINE DEDENT return True NEW_LINE DEDENT
def lastPosition ( n , m , k ) : NEW_LINE INDENT if ( m <= n - k + 1 ) : NEW_LINE INDENT return m + k - 1 NEW_LINE DEDENT m = m - ( n - k + 1 ) NEW_LINE if ( m % n == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return m % n NEW_LINE DEDENT DEDENT
def maxSum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return int ( ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ) NEW_LINE DEDENT DEDENT
def check ( n ) : NEW_LINE INDENT return 1162261467 % n == 0 NEW_LINE DEDENT
def productPuzzle ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += math . log10 ( a [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print int ( ( EPS + pow ( 10.00 , sum - math . log10 ( a [ i ] ) ) ) ) , NEW_LINE DEDENT return NEW_LINE DEDENT
def changeEvenBits ( n ) : NEW_LINE INDENT to_subtract = 0 NEW_LINE m = 0 NEW_LINE x = n NEW_LINE while ( x ) : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT to_subtract += ( 1 << m ) NEW_LINE DEDENT m += 2 NEW_LINE x >>= 2 NEW_LINE DEDENT return n - to_subtract NEW_LINE DEDENT
def closestNumber ( n , m ) : NEW_LINE INDENT q = int ( n / m ) NEW_LINE n1 = m * q NEW_LINE if ( ( n * m ) > 0 ) : NEW_LINE INDENT n2 = ( m * ( q + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n2 = ( m * ( q - 1 ) ) NEW_LINE DEDENT if ( abs ( n - n1 ) < abs ( n - n2 ) ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT
def checkPronic ( x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i <= ( int ) ( math . sqrt ( x ) ) ) : NEW_LINE INDENT if ( x == i * ( i + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def countConsecutive ( N ) : NEW_LINE INDENT count = 0 NEW_LINE L = 1 NEW_LINE while ( L * ( L + 1 ) < 2 * N ) : NEW_LINE INDENT a = ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) NEW_LINE if ( a - int ( a ) == 0.0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT L += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findMinSum ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 2 NEW_LINE while ( i * i <= num ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE num /= i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT sum += num NEW_LINE return sum NEW_LINE DEDENT
def compute_average ( a , b ) : NEW_LINE INDENT return floor ( ( a + b ) / 2 ) NEW_LINE DEDENT
def minNum ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT if ( odd % 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def minNum ( arr , n ) : NEW_LINE INDENT odd = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd = not odd NEW_LINE DEDENT DEDENT if ( odd ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num ) : NEW_LINE INDENT if isPrime ( num ) : NEW_LINE INDENT return num NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def sieveOfEratostheneses ( ) : NEW_LINE INDENT isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i < 100005 : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT j = 2 * i NEW_LINE while j < 100005 : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT
def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num ) : NEW_LINE INDENT if isPrime [ num ] : NEW_LINE INDENT return num NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( 2 * pell ( n - 1 ) + pell ( n - 2 ) ) NEW_LINE DEDENT
def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT c = 2 * b + a NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT if ( r > n / 2 ) : NEW_LINE INDENT r = n - r NEW_LINE DEDENT answer = 1 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT answer *= ( n - r + i ) NEW_LINE answer /= i NEW_LINE DEDENT return answer NEW_LINE DEDENT
def findMaxGCD ( arr , n ) : NEW_LINE INDENT high = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT divisors = [ 0 ] * ( high + 1 ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = 1 NEW_LINE while j <= math . sqrt ( arr [ i ] ) : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT divisors [ j ] = divisors [ j ] + 1 NEW_LINE if ( j != arr [ i ] / j ) : NEW_LINE INDENT divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ] NEW_LINE + 1 NEW_LINE DEDENT DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT i = high NEW_LINE while i >= 1 : NEW_LINE INDENT if ( divisors [ i ] > 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def findMaxGCD ( arr , n ) : NEW_LINE INDENT high = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT counter = 0 NEW_LINE for i in range ( high , 0 , - 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( j <= high ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT counter += count [ j ] NEW_LINE DEDENT j += i NEW_LINE if ( counter == 2 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT counter = 0 NEW_LINE DEDENT DEDENT
def count_one ( n ) : NEW_LINE INDENT c_one = 0 NEW_LINE while n != 0 : NEW_LINE INDENT rem = n % 10 NEW_LINE if rem == 1 : NEW_LINE INDENT c_one = c_one + 1 NEW_LINE DEDENT n = n / 10 NEW_LINE DEDENT return c_one NEW_LINE DEDENT
def checkEvil ( n ) : NEW_LINE INDENT i = 0 NEW_LINE binary = 0 NEW_LINE while n != 0 : NEW_LINE INDENT r = n % 2 NEW_LINE binary = binary + r * ( int ( 10 ** i ) ) NEW_LINE n = n / 2 NEW_LINE DEDENT n_one = count_one ( binary ) NEW_LINE if n_one % 2 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def calculateLeaps ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT leaps = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT leaps = leaps + calculateLeaps ( i ) NEW_LINE DEDENT return leaps NEW_LINE DEDENT DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def printLastKDigits ( a , b , k ) : NEW_LINE INDENT print ( "Last " + str ( k ) + " digits of " + str ( a ) + "^" + str ( b ) , end = " = " ) NEW_LINE temp = 1 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT temp *= 10 NEW_LINE DEDENT temp = power ( a , b , temp ) NEW_LINE for i in range ( k - numberOfDigits ( temp ) ) : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT if ( temp ) : NEW_LINE INDENT print ( temp ) NEW_LINE DEDENT DEDENT
def msbPos ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE while n != 0 : NEW_LINE INDENT pos += 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT
def josephify ( n ) : NEW_LINE INDENT position = msbPos ( n ) NEW_LINE j = 1 << ( position - 1 ) NEW_LINE n = n ^ j NEW_LINE n = n << 1 NEW_LINE n = n | 1 NEW_LINE return n NEW_LINE DEDENT
def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while ( imin <= n ) : NEW_LINE INDENT imax = n / k NEW_LINE ans += k * ( imax - imin + 1 ) NEW_LINE imin = imax + 1 NEW_LINE k = n / imin NEW_LINE DEDENT return ans NEW_LINE DEDENT
def reverseDigits ( num ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev = rev * 10 + num % 10 NEW_LINE num /= 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT
def square ( num ) : NEW_LINE INDENT return ( num * num ) NEW_LINE DEDENT
def checkAdamNumber ( num ) : NEW_LINE INDENT a = square ( num ) NEW_LINE b = square ( reverseDigits ( num ) ) NEW_LINE if ( a == reverseDigits ( b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def PowerOFPINnfactorial ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while ( temp <= n ) : NEW_LINE INDENT ans += n / temp NEW_LINE temp = temp * p NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT
def totalDigits ( n ) : NEW_LINE INDENT number_of_digits = 0 NEW_LINE for i in range ( 1 , n , 10 ) : NEW_LINE INDENT number_of_digits = ( number_of_digits + ( n - i + 1 ) ) NEW_LINE DEDENT return number_of_digits NEW_LINE DEDENT
def findSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = arr [ 0 ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT sum = sum + arr [ i + 1 ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * n NEW_LINE i = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 NEW_LINE n = int ( n / 2 ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = "" ) NEW_LINE DEDENT DEDENT
def decimalToBinary ( N ) : NEW_LINE INDENT B_Number = 0 NEW_LINE cnt = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT rem = N % 2 NEW_LINE c = pow ( 10 , cnt ) NEW_LINE B_Number += rem * c NEW_LINE N //= 2 NEW_LINE cnt += 1 NEW_LINE DEDENT return B_Number NEW_LINE DEDENT
def stirlingFactorial ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT e = 2.71 NEW_LINE z = ( math . sqrt ( 2 * 3.14 * n ) * math . pow ( ( n / e ) , n ) ) NEW_LINE return math . floor ( z ) NEW_LINE DEDENT
def countXorPair ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countXorPair ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT return odd * even NEW_LINE DEDENT
def count_of_ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( n + 1 ) * ( n + 2 ) // 2 NEW_LINE return count NEW_LINE DEDENT
def isPalindrome ( number ) : NEW_LINE INDENT return number == reverse ( number ) NEW_LINE DEDENT
def reverse ( number ) : NEW_LINE INDENT reverse = 0 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT remainder = number % 10 NEW_LINE reverse = ( reverse * 10 ) + remainder NEW_LINE number = int ( number / 10 ) NEW_LINE DEDENT return reverse NEW_LINE DEDENT
def sub ( a , b ) : NEW_LINE INDENT return a + flipSign ( b ) NEW_LINE DEDENT
def mul ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT return mul ( b , a ) NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( abs ( b ) , 0 , - 1 ) : NEW_LINE INDENT sum += a NEW_LINE DEDENT if ( b < 0 ) : NEW_LINE INDENT sum = flipSign ( sum ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def division ( a , b ) : NEW_LINE INDENT quotient = 0 NEW_LINE divisor = flipSign ( abs ( b ) ) NEW_LINE for dividend in range ( abs ( a ) , abs ( divisor ) + divisor , divisor ) : NEW_LINE INDENT quotient += 1 NEW_LINE DEDENT if ( areDifferentSign ( a , b ) ) : NEW_LINE INDENT quotient = flipSign ( quotient ) NEW_LINE DEDENT return quotient NEW_LINE DEDENT
def numOfCombinations ( arr , N ) : NEW_LINE INDENT C = [ 0 , 0 , 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT C [ arr [ i ] % 3 ] = C [ arr [ i ] % 3 ] + 1 NEW_LINE DEDENT return ( C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ) NEW_LINE DEDENT
def powmod ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) NEW_LINE value = [ 0 ] * m NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT value [ powmod ( a , i * n , m ) ] = i NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT cur = ( powmod ( a , j , m ) * b ) % m NEW_LINE if ( value [ cur ] ) : NEW_LINE INDENT ans = value [ cur ] * n - j NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) NEW_LINE an = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT an = ( an * a ) % m NEW_LINE DEDENT value = [ 0 ] * m NEW_LINE cur = an NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT value [ cur ] = i NEW_LINE DEDENT cur = ( cur * an ) % m NEW_LINE DEDENT cur = b NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( value [ cur ] > 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - i NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findRectNum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) NEW_LINE DEDENT
def f ( x ) : NEW_LINE INDENT return ( 1 * pow ( x , 3 ) + 2 * x * x + 10 * x - 20 ) NEW_LINE DEDENT
def Muller ( a , b , c ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while ( True ) : NEW_LINE INDENT f1 = f ( a ) NEW_LINE f2 = f ( b ) NEW_LINE f3 = f ( c ) NEW_LINE d1 = f1 - f3 NEW_LINE d2 = f2 - f3 NEW_LINE h1 = a - c NEW_LINE h2 = b - c NEW_LINE a0 = f3 NEW_LINE a1 = ( ( ( d2 * pow ( h1 , 2 ) ) - ( d1 * pow ( h2 , 2 ) ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) NEW_LINE a2 = ( ( ( d1 * h2 ) - ( d2 * h1 ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) NEW_LINE x = ( ( - 2 * a0 ) / ( a1 + abs ( math . sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) NEW_LINE y = ( ( - 2 * a0 ) / ( a1 - abs ( math . sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) NEW_LINE if ( x >= y ) : NEW_LINE INDENT res = x + c NEW_LINE DEDENT else : NEW_LINE INDENT res = y + c NEW_LINE DEDENT m = res * 100 NEW_LINE n = c * 100 NEW_LINE m = math . floor ( m ) NEW_LINE n = math . floor ( n ) NEW_LINE if ( m == n ) : NEW_LINE INDENT break NEW_LINE DEDENT a = b NEW_LINE b = c NEW_LINE c = res NEW_LINE if ( i > MAX_ITERATIONS ) : NEW_LINE INDENT print ( "Root cannot be found using" , "Muller's method" ) NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i <= MAX_ITERATIONS ) : NEW_LINE INDENT print ( "The value of the root is" , round ( res , 4 ) ) NEW_LINE DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT a = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT a *= i NEW_LINE DEDENT return a NEW_LINE DEDENT
def countPairs ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( math . pow ( N , 1 / 3 ) + 1 ) ) : NEW_LINE INDENT cb = i * i * i NEW_LINE diff = N - cb NEW_LINE cbrtDiff = int ( math . pow ( diff , 1 / 3 ) ) NEW_LINE if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findMinValue ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val += ( math . log ( arr [ i ] ) ) NEW_LINE DEDENT left = arr [ 0 ] NEW_LINE right = arr [ n - 1 ] + 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE temp = n * ( math . log ( mid ) ) NEW_LINE if ( val < temp ) : NEW_LINE INDENT ans = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isprime ( x ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= x ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def isSumOfKprimes ( N , K ) : NEW_LINE INDENT if ( N < 2 * K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT return isprime ( N ) NEW_LINE DEDENT if ( K == 2 ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return isprime ( N - 2 ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def sumOfTermsInNthRow ( n ) : NEW_LINE INDENT sum = n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE return sum NEW_LINE DEDENT
def printEqualModNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE d = arr [ n - 1 ] - arr [ 0 ] NEW_LINE if ( d == 0 ) : NEW_LINE INDENT print ( "Infinite solution" ) NEW_LINE return NEW_LINE DEDENT v = [ ] NEW_LINE i = 1 NEW_LINE while ( i * i <= d ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE if ( i != d / i ) : NEW_LINE INDENT v . append ( d / i ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT temp = arr [ 0 ] % v [ i ] NEW_LINE j = 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ j ] % v [ i ] != temp ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT print ( v [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def firstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = x // 10 NEW_LINE DEDENT return x NEW_LINE DEDENT
def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while temp != 0 : NEW_LINE INDENT d = temp % 10 NEW_LINE temp //= 10 NEW_LINE if d > 0 and n % d == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def FindLCM ( a , b ) : NEW_LINE INDENT return ( a * b ) / __gcd ( a , b ) NEW_LINE DEDENT
def rangeDivisor ( m , n , a , b ) : NEW_LINE INDENT lcm = FindLCM ( a , b ) NEW_LINE a_divisor = int ( n / a - ( m - 1 ) / a ) NEW_LINE b_divisor = int ( n / b - ( m - 1 ) / b ) NEW_LINE common_divisor = int ( n / lcm - ( m - 1 ) / lcm ) NEW_LINE ans = a_divisor + b_divisor - common_divisor NEW_LINE return ans NEW_LINE DEDENT
def getOccurence ( n , d ) : NEW_LINE INDENT result = 0 NEW_LINE itr = d NEW_LINE while ( itr <= n ) : NEW_LINE INDENT if ( itr % 10 == d ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT if ( itr != 0 and math . floor ( itr / 10 ) == d ) : NEW_LINE INDENT result += 1 NEW_LINE itr += 1 NEW_LINE DEDENT elif ( math . floor ( itr / 10 ) == d - 1 ) : NEW_LINE INDENT itr = itr + ( 10 - d ) NEW_LINE DEDENT else : NEW_LINE INDENT itr = itr + 10 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def printUnique ( l , r ) : NEW_LINE INDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT num = i NEW_LINE visited = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE while ( num ) : NEW_LINE INDENT if visited [ num % 10 ] == 1 : NEW_LINE INDENT break NEW_LINE DEDENT visited [ num % 10 ] = 1 NEW_LINE num = ( int ) ( num / 10 ) NEW_LINE DEDENT if num == 0 : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def findSumOfDigits ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT multiply ( v , i ) NEW_LINE DEDENT sum = 0 NEW_LINE size = len ( v ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT sum += v [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findMinZero ( p ) : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE number = 2 NEW_LINE next = 1 NEW_LINE while ( next ) : NEW_LINE INDENT next = ( first + second ) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number = number + 1 NEW_LINE DEDENT return number NEW_LINE DEDENT
def makeOdd ( n ) : NEW_LINE INDENT if n % 2 != 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 and ( int ) ( n / i ) % 2 == 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT
def makeOdd ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT resul = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE resul = resul * 2 NEW_LINE DEDENT return resul NEW_LINE DEDENT
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , N , 2 ) : NEW_LINE INDENT res ^= arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def printKDistinct ( arr , n , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if ( i != j and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if ( dist_count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def div ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def sieve ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT allPrimes . append ( p ) NEW_LINE DEDENT DEDENT DEDENT
def factorialDivisors ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( len ( allPrimes ) ) : NEW_LINE INDENT p = allPrimes [ i ] NEW_LINE exp = 0 NEW_LINE while ( p <= n ) : NEW_LINE INDENT exp = exp + int ( n / p ) NEW_LINE p = p * allPrimes [ i ] NEW_LINE DEDENT result = int ( result * ( pow ( allPrimes [ i ] , exp + 1 ) - 1 ) / ( allPrimes [ i ] - 1 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def countIterations ( arr , n ) : NEW_LINE INDENT oneFound = False NEW_LINE res = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT oneFound = True NEW_LINE DEDENT while ( i < n and arr [ i ] == 1 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT count_zero = 0 NEW_LINE while ( i < n and arr [ i ] == 0 ) : NEW_LINE INDENT count_zero += 1 NEW_LINE i += 1 NEW_LINE DEDENT if ( oneFound == False and i == n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT curr_count = 0 NEW_LINE if ( i < n and oneFound == True ) : NEW_LINE INDENT if ( ( count_zero & 1 ) == 0 ) : NEW_LINE INDENT curr_count = count_zero // 2 NEW_LINE DEDENT else : NEW_LINE INDENT curr_count = ( count_zero + 1 ) // 2 NEW_LINE DEDENT count_zero = 0 NEW_LINE DEDENT else : NEW_LINE INDENT curr_count = count_zero NEW_LINE count_zero = 0 NEW_LINE DEDENT res = max ( res , curr_count ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def isAutomorphic ( N ) : NEW_LINE INDENT sq = N * N NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 != sq % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT N /= 10 NEW_LINE sq /= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
def printConsecutive ( last , first ) : NEW_LINE INDENT print ( first , end = "" ) NEW_LINE first += 1 NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( " +" , x , end = "" ) NEW_LINE DEDENT DEDENT
def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , N ) : NEW_LINE INDENT for first in range ( 0 , last ) : NEW_LINE INDENT if 2 * N == ( last - first ) * ( last + first + 1 ) : NEW_LINE INDENT print ( N , "= " , end = "" ) NEW_LINE printConsecutive ( last , first + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( "-1" ) NEW_LINE DEDENT
def printCubes ( a , b ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE for j in range ( j ** 3 , i + 1 ) : NEW_LINE INDENT if ( j ** 3 == i ) : NEW_LINE INDENT print ( j ** 3 , end = " " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT
def printCubes ( a , b ) : NEW_LINE INDENT acrt = cbrt ( a ) NEW_LINE bcrt = cbrt ( b ) NEW_LINE for i in range ( acrt , bcrt + 1 ) : NEW_LINE INDENT if ( i * i * i >= a and i * i * i <= b ) : NEW_LINE INDENT print ( i * i * i , " " , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def findCount ( m , n ) : NEW_LINE INDENT num1 = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT num1 = ( num1 * 10 ) + 9 NEW_LINE DEDENT num2 = 0 NEW_LINE for i in range ( 0 , ( m - 1 ) ) : NEW_LINE INDENT num2 = ( num2 * 10 ) + 9 NEW_LINE DEDENT return int ( ( num1 / n ) - ( num2 / n ) ) NEW_LINE DEDENT
def findNthEvenDigitNumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while ( True ) : NEW_LINE INDENT curr = i NEW_LINE isCurrEvenDigit = True NEW_LINE while ( curr != 0 ) : NEW_LINE INDENT if ( curr % 10 == 1 or curr % 10 == 3 or curr % 10 == 5 or curr % 10 == 7 or curr % 10 == 9 ) : NEW_LINE INDENT isCurrEvenDigit = False NEW_LINE DEDENT curr = curr // 10 NEW_LINE DEDENT if ( isCurrEvenDigit == True ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
def findNthEvenDigitNumber ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT v = [ ] NEW_LINE n = n - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT v . append ( n % 5 ) NEW_LINE n = n // 5 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT result = result * 10 NEW_LINE result = result + v [ i ] NEW_LINE DEDENT return 2 * result NEW_LINE DEDENT
def fibonacci ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return c NEW_LINE DEDENT
def isMultipleOf10 ( n ) : NEW_LINE INDENT f = fibonacci ( 30 ) NEW_LINE return ( f % 10 == 0 ) NEW_LINE DEDENT
def isMultipleOf10 ( n ) : NEW_LINE INDENT return ( n % 15 == 0 ) NEW_LINE DEDENT
def isDivisibleBy25 ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( int ) ( st [ n - 1 ] ) == 0 and ( ( int ) ( st [ n - 2 ] ) == 0 ) or ( ( int ) ( st [ n - 2 ] ) * 10 + ( int ) ( st [ n - 1 ] ) % 25 == 0 ) ) NEW_LINE DEDENT
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res = res + 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT
def isLeap ( y ) : NEW_LINE INDENT if ( y % 100 != 0 and y % 4 == 0 or y % 400 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def offsetDays ( d , m , y ) : NEW_LINE INDENT offset = d NEW_LINE switcher = { 10 : 30 , 9 : 31 , 8 : 30 , 7 : 31 , 6 : 31 , 5 : 30 , 4 : 31 , 3 : 30 , 2 : 31 , 1 : 28 , 0 : 31 } NEW_LINE if ( isLeap ( y ) and m > 1 ) : NEW_LINE INDENT offset += 1 NEW_LINE DEDENT offset += switcher . get ( m ) NEW_LINE return offset NEW_LINE DEDENT
def addDays ( d1 , m1 , y1 , x ) : NEW_LINE INDENT offset1 = offsetDays ( d1 , m1 , y1 ) NEW_LINE if isLeap ( y1 ) : NEW_LINE INDENT remDays = 366 - offset1 NEW_LINE DEDENT else : NEW_LINE INDENT remDays = 365 - offset1 NEW_LINE DEDENT if ( x <= remDays ) : NEW_LINE INDENT y2 = y1 NEW_LINE offset2 = offset1 + x NEW_LINE DEDENT else : NEW_LINE INDENT x -= remDays NEW_LINE y2 = y1 + 1 NEW_LINE if isLeap ( y2 ) : NEW_LINE INDENT y2days = 366 NEW_LINE DEDENT else : NEW_LINE INDENT y2days = 365 NEW_LINE DEDENT while ( x >= y2days ) : NEW_LINE INDENT x -= y2days NEW_LINE y2 += 1 NEW_LINE if isLeap ( y2 ) : NEW_LINE INDENT y2days = 366 NEW_LINE DEDENT else : NEW_LINE INDENT y2days = 365 NEW_LINE DEDENT DEDENT offset2 = x NEW_LINE DEDENT m2 = [ 0 ] NEW_LINE d2 = [ 0 ] NEW_LINE revoffsetDays ( offset2 , y2 , d2 , m2 ) NEW_LINE print ( "d2 = " , * d2 , ", m2 = " , * m2 , ", y2 = " , y2 , sep = "" ) NEW_LINE DEDENT
def divisorSum ( N , K ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( 2 , math . ceil ( math . sqrt ( N ) ) ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT Sum += ( i + int ( N / i ) ) NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n == 1 or n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isHyperPerfect ( N , K ) : NEW_LINE INDENT Sum = divisorSum ( N , K ) NEW_LINE if ( ( 1 + K * ( Sum ) ) == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def printWellOrdered ( number , x , k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT print ( number , end = " " ) NEW_LINE return NEW_LINE DEDENT for i in range ( ( x + 1 ) , 10 ) : NEW_LINE INDENT printWellOrdered ( number * 10 + i , i , k - 1 ) NEW_LINE DEDENT DEDENT
def generateWellOrdered ( k ) : NEW_LINE INDENT printWellOrdered ( 0 , 0 , k ) NEW_LINE DEDENT
def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT a = a % mod NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( 2 * a ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT
def number0f2s ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == 2 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def numberOf2sinRange ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT count = count + number0f2s ( i ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def numberOf2sinRange ( n ) : NEW_LINE INDENT s = "" NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT s += str ( i ) NEW_LINE DEDENT return ( list ( s ) . count ( '2' ) ) NEW_LINE DEDENT
def count2sinRangeAtDigit ( number , d ) : NEW_LINE INDENT powerOf10 = int ( pow ( 10 , d ) ) NEW_LINE nextPowerOf10 = powerOf10 * 10 NEW_LINE right = number % powerOf10 NEW_LINE roundDown = number - number % nextPowerOf10 NEW_LINE roundup = roundDown + nextPowerOf10 NEW_LINE digit = ( number // powerOf10 ) % 10 NEW_LINE if ( digit < 2 ) : NEW_LINE INDENT return roundDown // 10 NEW_LINE DEDENT if ( digit == 2 ) : NEW_LINE INDENT return roundDown // 10 + right + 1 NEW_LINE DEDENT return roundup // 10 NEW_LINE DEDENT
def numberOf2sinRange ( number ) : NEW_LINE INDENT s = str ( number ) NEW_LINE len1 = len ( s ) NEW_LINE count = 0 NEW_LINE for digit in range ( len1 ) : NEW_LINE INDENT count += count2sinRangeAtDigit ( number , digit ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def isDivisibleBy5 ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE return ( ( st [ n - 1 ] == '0' ) or ( st [ n - 1 ] == '5' ) ) NEW_LINE DEDENT
def isTidy ( num ) : NEW_LINE INDENT prev = 10 NEW_LINE while ( num ) : NEW_LINE INDENT rem = num % 10 NEW_LINE num /= 10 NEW_LINE if rem > prev : NEW_LINE INDENT return False NEW_LINE DEDENT prev = rem NEW_LINE DEDENT return True NEW_LINE DEDENT
def areMirror ( a , b ) : NEW_LINE INDENT if a is None and b is None : NEW_LINE INDENT return True NEW_LINE DEDENT if a is None or b is None : NEW_LINE INDENT return False NEW_LINE DEDENT return ( a . data == b . data and areMirror ( a . left , b . right ) and areMirror ( a . right , b . left ) ) NEW_LINE DEDENT
def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT print ( - v [ i ] , "" , v [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def minToggle ( arr , n ) : NEW_LINE INDENT zero = [ 0 for i in range ( n + 1 + 1 ) ] NEW_LINE zero [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] == 0 ) : NEW_LINE INDENT zero [ i ] = zero [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero [ i ] = zero [ i - 1 ] NEW_LINE DEDENT DEDENT ans = n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def LCM ( arr , n ) : NEW_LINE INDENT max_num = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max_num < arr [ i ] ) : NEW_LINE INDENT max_num = arr [ i ] NEW_LINE DEDENT DEDENT res = 1 NEW_LINE while ( x <= max_num ) : NEW_LINE INDENT indexes = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % x == 0 ) : NEW_LINE INDENT indexes . append ( j ) NEW_LINE DEDENT DEDENT if ( len ( indexes ) >= 2 ) : NEW_LINE INDENT for j in range ( len ( indexes ) ) : NEW_LINE INDENT arr [ indexes [ j ] ] = int ( arr [ indexes [ j ] ] / x ) NEW_LINE DEDENT res = res * x NEW_LINE DEDENT else : NEW_LINE INDENT x += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT res = res * arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def kFactors ( n , k ) : NEW_LINE INDENT a = list ( ) NEW_LINE while n % 2 == 0 : NEW_LINE INDENT a . append ( 2 ) NEW_LINE n = n // 2 NEW_LINE DEDENT for i in range ( 3 , mt . ceil ( mt . sqrt ( n ) ) , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT n = n / i NEW_LINE a . append ( i ) NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT a . append ( n ) NEW_LINE DEDENT if len ( a ) < k : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT for i in range ( k - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = ", " ) NEW_LINE DEDENT product = 1 NEW_LINE for i in range ( k - 1 , len ( a ) ) : NEW_LINE INDENT product *= a [ i ] NEW_LINE DEDENT print ( product ) NEW_LINE DEDENT
def nondecdigits ( n ) : NEW_LINE INDENT x = 0 NEW_LINE for x in range ( n , 0 , - 1 ) : NEW_LINE INDENT no = x NEW_LINE prev_dig = 11 NEW_LINE flag = True NEW_LINE while ( no != 0 ) : NEW_LINE INDENT if ( prev_dig < no % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT prev_dig = no % 10 NEW_LINE no //= 10 NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def nondecdigits ( s ) : NEW_LINE INDENT m = len ( s ) NEW_LINE a = [ 0 ] * m NEW_LINE for i in range ( m ) : NEW_LINE INDENT a [ i ] = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT level = m - 1 NEW_LINE for i in range ( m - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT a [ i - 1 ] -= 1 NEW_LINE level = i - 1 NEW_LINE DEDENT DEDENT if ( a [ 0 ] != 0 ) : NEW_LINE INDENT for i in range ( level + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = "" ) NEW_LINE DEDENT for i in range ( level + 1 , m ) : NEW_LINE INDENT print ( "9" , end = "" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , level ) : NEW_LINE INDENT print ( a [ i ] , end = "" ) NEW_LINE DEDENT for i in range ( level + 1 , m ) : NEW_LINE INDENT print ( "9" , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def countDivisors ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE cnt = cnt + 2 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def hasEvenNumberOfFactors ( n ) : NEW_LINE INDENT root_n = math . sqrt ( n ) NEW_LINE if ( ( root_n * root_n ) == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def printStatusOfDoors ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( hasEvenNumberOfFactors ( i ) == True ) : NEW_LINE INDENT print ( "closed" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "open" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def validate ( n ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT if ( temp % 10 == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count > i ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT temp //= 10 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 9 == 0 ) NEW_LINE DEDENT
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT res = res ^ arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT
def checkPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def printPrimePoints ( n ) : NEW_LINE INDENT count = countDigits ( n ) NEW_LINE if ( count == 1 or count == 2 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT found = False NEW_LINE for i in range ( 1 , ( count - 1 ) ) : NEW_LINE INDENT left = n // ( pow ( 10 , count - i ) ) NEW_LINE right = n % ( pow ( 10 , count - i - 1 ) ) NEW_LINE if ( checkPrime ( left ) == 0 and checkPrime ( right ) == 0 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE found = True NEW_LINE DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def countOddPrimeFactors ( n ) : NEW_LINE INDENT result = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n /= 2 NEW_LINE DEDENT i = 3 NEW_LINE while i * i <= n : NEW_LINE INDENT divCount = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n /= i NEW_LINE divCount = divCount + 1 NEW_LINE DEDENT result = result * divCount + 1 NEW_LINE i = i + 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT result = result * 2 NEW_LINE DEDENT return result NEW_LINE DEDENT
def politness ( n ) : NEW_LINE INDENT return countOddPrimeFactors ( n ) - 1 NEW_LINE DEDENT
def politness ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 2 , int ( math . sqrt ( 2 * n ) ) + 1 ) : NEW_LINE INDENT if ( ( 2 * n ) % i != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT a = 2 * n NEW_LINE a = a / i NEW_LINE a = a - ( i - 1 ) NEW_LINE if ( a % 2 != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT a /= 2 NEW_LINE if ( a > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def power ( num , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return power ( num , n // 2 ) * power ( num , n // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return num * power ( num , n // 2 ) * power ( num , n // 2 ) NEW_LINE DEDENT DEDENT
def checkRecursive ( num , rem_num , next_int , n , ans = 0 ) : NEW_LINE INDENT if ( rem_num == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT r = int ( num ** ( 1 / n ) ) NEW_LINE for i in range ( next_int + 1 , r + 1 ) : NEW_LINE INDENT a = rem_num - int ( i ** n ) NEW_LINE if a >= 0 : NEW_LINE INDENT ans += checkRecursive ( num , rem_num - int ( i ** n ) , i , n , 0 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def check ( x , n ) : NEW_LINE INDENT return checkRecursive ( x , x , 0 , n ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def check ( num ) : NEW_LINE INDENT digitSum = 0 NEW_LINE while num > 0 : NEW_LINE INDENT rem = num % 10 NEW_LINE digitSum = digitSum + rem NEW_LINE num = num / 10 NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT
def reverseNum ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( n ) : NEW_LINE INDENT rem = n % 10 NEW_LINE rev = ( rev * 10 ) + rem NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return rev NEW_LINE DEDENT
def isPalindrom ( num ) : NEW_LINE INDENT return num == reverseNum ( num ) NEW_LINE DEDENT
def nthPalindrome ( n , k ) : NEW_LINE INDENT num = math . pow ( 10 , k - 1 ) NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPalindrom ( num ) ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT if ( not n ) : NEW_LINE INDENT break NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return int ( num ) NEW_LINE DEDENT
def findMax ( n , a , b , k , m ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT lowerbound = a [ i ] NEW_LINE upperbound = b [ i ] NEW_LINE for j in range ( lowerbound , upperbound + 1 ) : NEW_LINE INDENT arr [ j ] += k [ i ] NEW_LINE DEDENT res = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = max ( res , arr [ i ] ) NEW_LINE return res NEW_LINE DEDENT DEDENT DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sq = ( int ) ( math . sqrt ( x ) ) NEW_LINE return ( x == sq * sq ) NEW_LINE DEDENT
def countPerfectDivisors ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if isPerfectSquare ( i ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT if n / i != i and isPerfectSquare ( n / i ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def precomputeCounts ( ) : NEW_LINE INDENT i = 1 NEW_LINE while i * i < MAX : NEW_LINE INDENT for j in range ( i * i , MAX , i * i ) : NEW_LINE INDENT perfectDiv [ j ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
def countPerfectDivisors ( n ) : NEW_LINE INDENT return perfectDiv [ n ] NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAXN ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , mt . ceil ( mt . sqrt ( MAXN ) ) ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def getDigitProduct ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT if ( prodDig [ x ] != 0 ) : NEW_LINE INDENT return prodDig [ x ] NEW_LINE DEDENT prod = ( int ( x % 10 ) * getDigitProduct ( int ( x / 10 ) ) ) NEW_LINE prodDig [ x ] = prod NEW_LINE return prod NEW_LINE DEDENT
def findSeed ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 1 , int ( n / 2 + 2 ) ) : NEW_LINE INDENT if ( i * getDigitProduct ( i ) == n ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( "NO seed exists" ) NEW_LINE return NEW_LINE DEDENT for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def sieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT if i * i > MAX : NEW_LINE INDENT break NEW_LINE DEDENT if ( primedivisor [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , MAX , i ) : NEW_LINE INDENT primedivisor [ j ] = i NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT if ( primedivisor [ i ] == 0 ) : NEW_LINE INDENT primedivisor [ i ] = i NEW_LINE DEDENT DEDENT DEDENT
def findDivisors ( arr , n ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT pos [ i ] = divInd [ i ] = - 1 NEW_LINE dist [ i ] = 10 ** 9 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT num = arr [ i ] NEW_LINE while ( num > 1 ) : NEW_LINE INDENT div = primedivisor [ num ] NEW_LINE divisors [ i ] . append ( div ) NEW_LINE while ( num % div == 0 ) : NEW_LINE INDENT num //= div NEW_LINE DEDENT DEDENT DEDENT DEDENT
def nearestGCD ( arr , n ) : NEW_LINE INDENT findDivisors ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for div in divisors [ i ] : NEW_LINE INDENT if ( divInd [ div ] == - 1 ) : NEW_LINE INDENT divInd [ div ] = i NEW_LINE DEDENT else : NEW_LINE INDENT ind = divInd [ div ] NEW_LINE divInd [ div ] = i NEW_LINE if ( dist [ i ] > abs ( ind - i ) ) : NEW_LINE INDENT dist [ i ] = abs ( ind - i ) NEW_LINE pos [ i ] = ind + 1 NEW_LINE DEDENT if ( dist [ ind ] > abs ( ind - i ) ) : NEW_LINE INDENT  DEDENT DEDENT dist [ ind ] = abs ( ind - i ) NEW_LINE pos [ ind ] = i + 1 NEW_LINE DEDENT DEDENT
def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ 0 for i in range ( N + 5 ) ] NEW_LINE for i in range ( 2 , int ( sqrt ( N ) ) + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] += 1 NEW_LINE DEDENT DEDENT arr [ i ] = 1 NEW_LINE DEDENT maxval = 0 NEW_LINE maxint = 1 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] > maxval ) : NEW_LINE INDENT maxval = arr [ i ] NEW_LINE maxint = i NEW_LINE DEDENT DEDENT return maxint NEW_LINE DEDENT
def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ True ] * ( N + 5 ) NEW_LINE i = 3 NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] = False NEW_LINE DEDENT DEDENT i += 2 NEW_LINE DEDENT prime = [ ] NEW_LINE prime . append ( 2 ) NEW_LINE for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT prime . append ( i ) NEW_LINE DEDENT DEDENT i = 0 NEW_LINE ans = 1 NEW_LINE while ( ans * prime [ i ] <= N and i < len ( prime ) ) : NEW_LINE INDENT ans *= prime [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * ( int ( MAX / 2 ) + 100 ) NEW_LINE for i in range ( 1 , int ( ( math . sqrt ( MAX ) - 1 ) / 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , int ( MAX / 2 ) + 1 , 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True NEW_LINE DEDENT DEDENT primes . append ( 2 ) NEW_LINE for i in range ( 1 , int ( MAX / 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxele = max ( arr ) NEW_LINE for i in range ( 2 , maxele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( 2 , mt . ceil ( mt . sqrt ( MAX + 1 ) ) ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT prime [ i ] = i NEW_LINE DEDENT DEDENT DEDENT
def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT element = arr [ i ] NEW_LINE while ( element > 1 ) : NEW_LINE INDENT div = prime [ element ] NEW_LINE countdiv [ div ] += 1 NEW_LINE ans = max ( ans , countdiv [ div ] ) NEW_LINE while ( element % div == 0 ) : NEW_LINE INDENT element = element // div NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = deque ( ) NEW_LINE q . append ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( q ) : NEW_LINE INDENT t = q . popleft ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE q . append ( t * 10 ) NEW_LINE q . append ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def SubArraySum ( arr , n ) : NEW_LINE INDENT temp , result = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += arr [ j ] NEW_LINE result += temp NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def nthElement ( a , b , n ) : NEW_LINE INDENT seq = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT seq . append ( a * i ) NEW_LINE DEDENT seq . sort ( ) NEW_LINE i = 1 NEW_LINE k = n NEW_LINE while ( i <= n and k > 0 ) : NEW_LINE INDENT try : NEW_LINE INDENT z = seq . index ( b * i ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT seq . append ( b * i ) NEW_LINE seq . sort ( ) NEW_LINE k -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return seq [ n - 1 ] NEW_LINE DEDENT
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT for i in range ( 0 , n1 ) : NEW_LINE INDENT for j in range ( 0 , n2 ) : NEW_LINE INDENT for k in range ( 0 , n3 ) : NEW_LINE INDENT if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def multiplicativeOrder ( A , N ) : NEW_LINE INDENT if ( GCD ( A , N ) != 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT result = 1 NEW_LINE K = 1 NEW_LINE while ( K < N ) : NEW_LINE INDENT result = ( result * A ) % N NEW_LINE if ( result == 1 ) : NEW_LINE INDENT return K NEW_LINE DEDENT K = K + 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def sumOfRange ( a , b ) : NEW_LINE INDENT i = ( a * ( a + 1 ) ) >> 1 NEW_LINE j = ( b * ( b + 1 ) ) >> 1 NEW_LINE return ( i - j ) NEW_LINE DEDENT
def sumofproduct ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE root = int ( math . sqrt ( n ) ) NEW_LINE for i in range ( 1 , root + 1 ) : NEW_LINE INDENT up = int ( n / i ) NEW_LINE low = max ( int ( n / ( i + 1 ) ) , root ) NEW_LINE sum += ( i * sumOfRange ( up , low ) ) NEW_LINE sum += ( i * int ( n / i ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def findPrimefactors ( s , n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT s . add ( 2 ) NEW_LINE n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT s . add ( i ) NEW_LINE n = n // i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT s . add ( n ) NEW_LINE DEDENT DEDENT
def findPrimitive ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE if ( isPrime ( n ) == False ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT phi = n - 1 NEW_LINE findPrimefactors ( s , phi ) NEW_LINE for r in range ( 2 , phi + 1 ) : NEW_LINE INDENT flag = False NEW_LINE for it in s : NEW_LINE INDENT if ( power ( r , phi // it , n ) == 1 ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT return r NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def kPrimeFactor ( n , k ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT k = k - 1 NEW_LINE n = n / 2 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT i = 3 NEW_LINE while i <= math . sqrt ( n ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT k = k - 1 NEW_LINE n = n / i NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT if ( n > 2 and k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def sieveOfEratosthenes ( s ) : NEW_LINE INDENT prime = [ False for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( 2 , MAX + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAX , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , MAX + 1 , 2 ) : NEW_LINE INDENT if j * j > MAX : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def kPrimeFactor ( n , k , s ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return s [ n ] NEW_LINE DEDENT k -= 1 NEW_LINE n //= s [ n ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT return gcd ( b , a % b ) if b > 0 else a NEW_LINE DEDENT
def countGCD ( L , R , g ) : NEW_LINE INDENT L = ( L + g - 1 ) // g NEW_LINE R = R // g NEW_LINE ans = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT for j in range ( L , R + 1 ) : NEW_LINE INDENT if ( gcd ( i , j ) == 1 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def minPower ( n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT ans += ( n % x ) NEW_LINE n //= x NEW_LINE DEDENT return ans NEW_LINE DEDENT
def calSum ( n ) : NEW_LINE INDENT a = 3 NEW_LINE b = 0 NEW_LINE c = 2 NEW_LINE return 3 NEW_LINE return 3 NEW_LINE return 5 NEW_LINE sum = 5 NEW_LINE while ( n > 2 ) : NEW_LINE INDENT d = a + b NEW_LINE sum = sum + d NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE n = n - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumDivisorsOfDivisors ( n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for j in range ( 2 , mt . ceil ( mt . sqrt ( n ) ) ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % j == 0 ) : NEW_LINE INDENT n //= j NEW_LINE count += 1 NEW_LINE DEDENT if ( count ) : NEW_LINE INDENT mp [ j ] = count NEW_LINE DEDENT DEDENT if ( n != 1 ) : NEW_LINE INDENT mp [ n ] = 1 NEW_LINE DEDENT ans = 1 NEW_LINE for it in mp : NEW_LINE INDENT pw = 1 NEW_LINE summ = 0 NEW_LINE for i in range ( mp [ it ] + 1 , 0 , - 1 ) : NEW_LINE INDENT summ += ( i * pw ) NEW_LINE pw *= it NEW_LINE DEDENT ans *= summ NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findMinNumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT count += 1 NEW_LINE n //= 2 NEW_LINE DEDENT if count % 2 is not 0 : NEW_LINE INDENT ans *= 2 NEW_LINE DEDENT for i in range ( 3 , ( int ) ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE n //= i NEW_LINE DEDENT if count % 2 is not 0 : NEW_LINE INDENT ans *= i NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT ans *= n NEW_LINE DEDENT return ans NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def findgcd ( n , x , y ) : NEW_LINE INDENT g = gcd ( x , y ) NEW_LINE for i in range ( g ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( ( a % b ) == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT i = 1 NEW_LINE new_x = x NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT new_x /= gcd ( i , new_x ) NEW_LINE if ( new_x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT
def countFactorialXNotY ( x , y ) : NEW_LINE INDENT return ( firstFactorialDivisibleNumber ( y ) - firstFactorialDivisibleNumber ( x ) ) NEW_LINE DEDENT
def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( fact % x == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( ( a % b ) == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT new_x = x NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT new_x /= gcd ( i , new_x ) NEW_LINE if ( new_x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT num = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = num * i NEW_LINE DEDENT return num NEW_LINE DEDENT
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * p NEW_LINE while ( i <= n ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def highestPowerof2 ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( ( i & ( i - 1 ) ) == 0 ) : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def highestPowerof2 ( n ) : NEW_LINE INDENT p = int ( math . log ( n , 2 ) ) NEW_LINE return int ( pow ( 2 , p ) ) NEW_LINE DEDENT
def getFirstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x //= 10 NEW_LINE DEDENT return x NEW_LINE DEDENT
def getCountWithSameStartAndEndFrom1 ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT tens = x // 10 NEW_LINE res = tens + 9 NEW_LINE firstDigit = getFirstDigit ( x ) NEW_LINE lastDigit = x % 10 NEW_LINE if ( lastDigit < firstDigit ) : NEW_LINE INDENT res = res - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def getCountWithSameStartAndEnd ( start , end ) : NEW_LINE INDENT return ( getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ) NEW_LINE DEDENT
def sieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE i = i + p NEW_LINE DEDENT DEDENT p = p + 1 NEW_LINE DEDENT DEDENT
def rightTruPrime ( n ) : NEW_LINE INDENT isPrime = [ None ] * ( n + 1 ) NEW_LINE sieveOfEratosthenes ( n , isPrime ) NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( isPrime [ n ] ) : NEW_LINE INDENT n = n // 10 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countMaxChoco ( money , price , wrap ) : NEW_LINE INDENT if ( money < price ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT choc = int ( money / price ) NEW_LINE choc = choc + ( choc - 1 ) / ( wrap - 1 ) NEW_LINE return int ( choc ) NEW_LINE DEDENT
def SieveOfEratosthenes ( n , prime ) : NEW_LINE INDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def mersennePrimes ( n ) : NEW_LINE INDENT prime = [ 0 ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , prime ) NEW_LINE k = 2 NEW_LINE while ( ( ( 1 << k ) - 1 ) <= n ) : NEW_LINE INDENT num = ( 1 << k ) - 1 NEW_LINE if ( prime [ num ] ) : NEW_LINE INDENT print ( num , end = " " ) NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += ( i % K ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE y = N / K NEW_LINE x = N % K NEW_LINE ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) NEW_LINE return int ( ans ) NEW_LINE DEDENT
def sieve ( prime , n ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if ( prime [ p ] == False ) : NEW_LINE INDENT for i in range ( p * 2 , n , p ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def maxDigitInPrimes ( L , R ) : NEW_LINE INDENT prime = [ 0 ] * ( R + 1 ) NEW_LINE sieve ( prime , R ) NEW_LINE freq = [ 0 ] * 10 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT while ( p ) : NEW_LINE INDENT freq [ p % 10 ] += 1 NEW_LINE p //= 10 NEW_LINE DEDENT DEDENT DEDENT max = freq [ 0 ] NEW_LINE ans = 0 NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT if ( max <= freq [ j ] ) : NEW_LINE INDENT max = freq [ j ] NEW_LINE ans = j NEW_LINE DEDENT DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def simpleSieve ( ) : NEW_LINE INDENT k = 0 NEW_LINE for p in range ( 2 , 1001 ) : NEW_LINE INDENT if ( p * p > 1001 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ p ] ) : NEW_LINE INDENT for k in range ( p , 1001 , k + p ) : NEW_LINE INDENT arr [ k ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def find_sphene ( N ) : NEW_LINE INDENT arr1 = [ 0 ] * ( 8 ) NEW_LINE count = 0 NEW_LINE j = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( N % i == 0 and count < 8 ) : NEW_LINE INDENT count += 1 NEW_LINE arr1 [ j ] = i NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( count == 8 and ( arr [ arr1 [ 1 ] ] and arr [ arr1 [ 2 ] ] and arr [ arr1 [ 3 ] ] ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def maxHandshake ( n ) : NEW_LINE INDENT return int ( ( n * ( n - 1 ) ) / 2 ) NEW_LINE DEDENT
def gcd ( i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return i NEW_LINE DEDENT if ( i > j ) : NEW_LINE INDENT return gcd ( i - j , j ) NEW_LINE DEDENT return gcd ( i , j - i ) NEW_LINE DEDENT
def ispossible ( x , y , a , b ) : NEW_LINE INDENT x , y , a , b = abs ( x ) , abs ( y ) , abs ( a ) , abs ( b ) NEW_LINE return ( gcd ( x , y ) == gcd ( a , b ) ) NEW_LINE DEDENT
def ApowBmodM ( a , b , m ) : NEW_LINE INDENT ans = aModM ( a , m ) NEW_LINE mul = ans NEW_LINE for i in range ( 1 , b ) : NEW_LINE INDENT ans = ( ans * mul ) % m NEW_LINE DEDENT return ans NEW_LINE DEDENT
def divisible ( N , digit ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( N ) ) : NEW_LINE INDENT ans = ( ans * 10 + ( ord ( N [ i ] ) - ord ( '0' ) ) ) NEW_LINE ans %= digit NEW_LINE DEDENT return ( ans == 0 ) NEW_LINE DEDENT
def allDigits ( N ) : NEW_LINE INDENT divide = [ False ] * 10 NEW_LINE for digit in range ( 2 , 10 ) : NEW_LINE INDENT if ( divisible ( N , digit ) ) : NEW_LINE INDENT divide [ digit ] = True NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in range ( len ( N ) ) : NEW_LINE INDENT if ( divide [ ( ord ( N [ i ] ) - ord ( '0' ) ) ] == True ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ False for i in range ( n + 2 ) ] NEW_LINE if ( x <= n ) : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if ( y <= n ) : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) , n + 1 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT if ( i + x <= n ) : NEW_LINE INDENT arr [ i + x ] = True NEW_LINE DEDENT if ( i + y <= n ) : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def reverse ( x ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + x % 10 NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT return rev NEW_LINE DEDENT
def printEmirp ( n ) : NEW_LINE INDENT prime = [ 1 ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = 0 NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT rev = reverse ( p ) NEW_LINE if ( p != rev and rev <= n and prime [ rev ] == 1 ) : NEW_LINE INDENT print ( p , rev , end = " " ) NEW_LINE prime [ rev ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while i <= ( math . sqrt ( n ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT sum = sum + i NEW_LINE sum = sum + i NEW_LINE sum = sum + ( n / i ) NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT sum = sum - n NEW_LINE return sum NEW_LINE DEDENT
def checkAbundant ( n ) : NEW_LINE INDENT if ( getSum ( n ) > n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def longLenSub ( arr , n ) : NEW_LINE INDENT um = defaultdict ( lambda : 0 ) NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len1 = 0 NEW_LINE if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) : NEW_LINE INDENT len1 = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] + 1 ] ) : NEW_LINE INDENT len1 = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = len1 + 1 NEW_LINE if longLen < um [ arr [ i ] ] : NEW_LINE INDENT longLen = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT
def isPowerful ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE power = power + 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for factor in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % factor == 0 ) : NEW_LINE INDENT n = n // factor NEW_LINE power = power + 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT return ( n == 1 ) NEW_LINE DEDENT
def divisorsSum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= math . sqrt ( n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT sum = sum + i NEW_LINE sum = sum + i NEW_LINE sum = sum + ( n / i ) NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isDeficient ( n ) : NEW_LINE INDENT return ( divisorsSum ( n ) < ( 2 * n ) ) NEW_LINE DEDENT
def isKeith ( x ) : NEW_LINE INDENT terms = [ ] NEW_LINE temp = x NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT terms . append ( temp % 10 ) NEW_LINE temp = int ( temp / 10 ) NEW_LINE n += 1 NEW_LINE DEDENT terms . reverse ( ) NEW_LINE next_term = 0 NEW_LINE i = n NEW_LINE while ( next_term < x ) : NEW_LINE INDENT next_term = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT next_term += terms [ i - j ] NEW_LINE DEDENT terms . append ( next_term ) NEW_LINE i += 1 NEW_LINE DEDENT return ( next_term == x ) NEW_LINE DEDENT
def hcf ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return hcf ( b , a % b ) NEW_LINE DEDENT
def findlcm ( a , b ) : NEW_LINE INDENT if ( b == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT a = ( a * b ) // hcf ( a , b ) NEW_LINE b -= 1 NEW_LINE return findlcm ( a , b ) NEW_LINE DEDENT
def canBeSumofConsec ( n ) : NEW_LINE INDENT return ( ( n & ( n - 1 ) ) and n ) NEW_LINE DEDENT
def Sieve ( ) : NEW_LINE INDENT n = MAX NEW_LINE nNew = int ( math . sqrt ( n ) ) NEW_LINE marked = [ 0 ] * ( int ( n / 2 + 500 ) ) NEW_LINE for i in range ( 1 , int ( ( nNew - 1 ) / 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( ( i * ( i + 1 ) ) << 1 ) , ( int ( n / 2 ) + 1 ) , ( 2 * i + 1 ) ) : NEW_LINE INDENT marked [ j ] = 1 NEW_LINE DEDENT DEDENT primes . append ( 2 ) NEW_LINE for i in range ( 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def binarySearch ( left , right , n ) : NEW_LINE INDENT if ( left <= right ) : NEW_LINE INDENT mid = int ( ( left + right ) / 2 ) NEW_LINE if ( mid == 0 or mid == len ( primes ) - 1 ) : NEW_LINE INDENT return primes [ mid ] NEW_LINE DEDENT if ( primes [ mid ] == n ) : NEW_LINE INDENT return primes [ mid - 1 ] NEW_LINE DEDENT if ( primes [ mid ] < n and primes [ mid + 1 ] > n ) : NEW_LINE INDENT return primes [ mid ] NEW_LINE DEDENT if ( n < primes [ mid ] ) : NEW_LINE INDENT return binarySearch ( left , mid - 1 , n ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( mid + 1 , right , n ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sm = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sm = sm + ef2 NEW_LINE DEDENT return sm NEW_LINE DEDENT
def isPerfect ( n ) : NEW_LINE INDENT s = math . sqrt ( n ) NEW_LINE return ( s * s == n ) NEW_LINE DEDENT
def divisorsCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = count + 2 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def evenFib ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) NEW_LINE DEDENT
def buildSegtmentTree ( node , a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT segmentTree [ node ] = divisors [ a ] NEW_LINE return NEW_LINE DEDENT buildSegtmentTree ( 2 * node , a , ( a + b ) // 2 ) NEW_LINE buildSegtmentTree ( 2 * node + 1 , ( ( a + b ) // 2 ) + 1 , b ) NEW_LINE segmentTree [ node ] = max ( segmentTree [ 2 * node ] , segmentTree [ 2 * node + 1 ] ) NEW_LINE DEDENT
def query ( node , a , b , l , r ) : NEW_LINE INDENT if ( l > b or a > r ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( a >= l and b <= r ) : NEW_LINE INDENT return segmentTree [ node ] NEW_LINE DEDENT return max ( query ( 2 * node , a , ( a + b ) // 2 , l , r ) , query ( 2 * node + 1 , ( ( a + b ) // 2 ) + 1 , b , l , r ) ) NEW_LINE DEDENT
def countSteps ( x , y ) : NEW_LINE INDENT if ( x % y == 0 ) : NEW_LINE INDENT return math . floor ( x / y ) NEW_LINE DEDENT return math . floor ( ( x / y ) + countSteps ( y , x % y ) ) NEW_LINE DEDENT
def primeFactorize ( a ) : NEW_LINE INDENT sqt = int ( math . sqrt ( a ) ) NEW_LINE for i in range ( 2 , sqt , 2 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( a % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE a /= i NEW_LINE DEDENT ma [ i ] = cnt NEW_LINE DEDENT if ( a > 1 ) : NEW_LINE INDENT ma [ a ] = 1 NEW_LINE DEDENT DEDENT
def commDiv ( a , b ) : NEW_LINE INDENT primeFactorize ( a ) NEW_LINE res = 1 NEW_LINE for key , value in ma . items ( ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( b % key == 0 ) : NEW_LINE INDENT b /= key NEW_LINE cnt += 1 NEW_LINE DEDENT res *= ( min ( cnt , value ) + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def y ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x * x ) ) NEW_LINE DEDENT
def trapezoidal ( a , b , n ) : NEW_LINE INDENT h = ( b - a ) / n NEW_LINE s = ( y ( a ) + y ( b ) ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT s += 2 * y ( a + i * h ) NEW_LINE i += 1 NEW_LINE DEDENT return ( ( h / 2 ) * s ) NEW_LINE DEDENT
def spellsCount ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE result = 1 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT count = 1 NEW_LINE while ( i < n - 1 and num [ i + 1 ] == num [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT result = result * int ( pow ( 2 , count - 1 ) ) NEW_LINE i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
def numSquareSum ( n ) : NEW_LINE INDENT squareSum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT squareSum += ( n % 10 ) * ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return squareSum NEW_LINE DEDENT
def isHappynumber ( n ) : NEW_LINE INDENT slow = n NEW_LINE fast = n NEW_LINE while ( True ) : NEW_LINE INDENT slow = numSquareSum ( slow ) NEW_LINE fast = numSquareSum ( numSquareSum ( fast ) ) NEW_LINE if ( slow != fast ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ( slow == 1 ) NEW_LINE DEDENT
def kaprekar ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE return kaprekarRec ( n , rev ) NEW_LINE DEDENT
def sqroot ( s ) : NEW_LINE INDENT pSq = 0 NEW_LINE N = 0 NEW_LINE for i in range ( int ( s ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT pSq = i NEW_LINE N = j NEW_LINE break NEW_LINE DEDENT DEDENT if ( pSq > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def power ( x , a ) : NEW_LINE INDENT res = 1 NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT x = x * x NEW_LINE a >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def breakInteger ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT maxProduct = 0 NEW_LINE if ( N % 3 == 0 ) : NEW_LINE INDENT maxProduct = power ( 3 , int ( N / 3 ) ) NEW_LINE return maxProduct NEW_LINE DEDENT elif ( N % 3 == 1 ) : NEW_LINE INDENT maxProduct = 2 * 2 * power ( 3 , int ( N / 3 ) - 1 ) NEW_LINE return maxProduct NEW_LINE DEDENT elif ( N % 3 == 2 ) : NEW_LINE INDENT maxProduct = 2 * power ( 3 , int ( N / 3 ) ) NEW_LINE return maxProduct NEW_LINE DEDENT DEDENT
def maxProd ( n ) : NEW_LINE INDENT if ( n == 2 or n == 3 ) : NEW_LINE INDENT return ( n - 1 ) NEW_LINE DEDENT res = 1 NEW_LINE while ( n > 4 ) : NEW_LINE INDENT n -= 3 NEW_LINE res *= 3 NEW_LINE DEDENT return ( n * res ) NEW_LINE DEDENT
def digSum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 9 == 0 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n % 9 ) NEW_LINE DEDENT DEDENT
def countMultiples ( n ) : NEW_LINE INDENT return n / 3 + n / 7 - n / 21 NEW_LINE DEDENT
def sieve ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT allPrimes . append ( p ) NEW_LINE DEDENT DEDENT DEDENT
def factorialDivisors ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( len ( allPrimes ) ) : NEW_LINE INDENT p = allPrimes [ i ] NEW_LINE exp = 0 NEW_LINE while ( p <= n ) : NEW_LINE INDENT exp = exp + int ( n / p ) NEW_LINE p = p * allPrimes [ i ] NEW_LINE DEDENT result = result * ( exp + 1 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def nonFibonacci ( n ) : NEW_LINE INDENT prevPrev = 1 NEW_LINE prev = 2 NEW_LINE curr = 3 NEW_LINE while n > 0 : NEW_LINE INDENT prevPrev = prev NEW_LINE prev = curr NEW_LINE curr = prevPrev + prev NEW_LINE n = n - ( curr - prev - 1 ) NEW_LINE DEDENT n = n + ( curr - prev - 1 ) NEW_LINE return prev + n NEW_LINE DEDENT
def reversDigits ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num / 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT
def isPalindrome ( num ) : NEW_LINE INDENT return ( reversDigits ( num ) == num ) NEW_LINE DEDENT
def countOddSquares ( n , m ) : NEW_LINE INDENT return int ( m ** 0.5 ) - int ( ( n - 1 ) ** 0.5 ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT k = 0 NEW_LINE while ( ( ( a b ) & 1 ) == 0 ) : NEW_LINE INDENT a = a >> 1 NEW_LINE b = b >> 1 NEW_LINE k = k + 1 NEW_LINE DEDENT while ( ( a & 1 ) == 0 ) : NEW_LINE INDENT a = a >> 1 NEW_LINE DEDENT while ( b != 0 ) : NEW_LINE INDENT while ( ( b & 1 ) == 0 ) : NEW_LINE INDENT b = b >> 1 NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT b = ( b - a ) NEW_LINE DEDENT return ( a << k ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( ( ~ a & 1 ) == 1 ) : NEW_LINE INDENT if ( ( b & 1 ) == 1 ) : NEW_LINE INDENT return gcd ( a >> 1 , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( a >> 1 , b >> 1 ) << 1 ) NEW_LINE DEDENT DEDENT if ( ( ~ b & 1 ) == 1 ) : NEW_LINE INDENT return gcd ( a , b >> 1 ) NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( ( a - b ) >> 1 , b ) NEW_LINE DEDENT return gcd ( ( b - a ) >> 1 , a ) NEW_LINE DEDENT
def countWindowDistinct ( win , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT j = 0 NEW_LINE while j < i : NEW_LINE INDENT if ( win [ i ] == win [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT DEDENT return dist_count NEW_LINE DEDENT
def toInt ( x ) : NEW_LINE INDENT return int ( x ) NEW_LINE DEDENT
def findNDigitNums ( n ) : NEW_LINE INDENT out = [ 0 ] * ( n + 1 ) NEW_LINE index = 0 NEW_LINE evenSum = 0 NEW_LINE oddSum = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) NEW_LINE DEDENT DEDENT
def findNDigitNumsUtil ( n , sum , out , index ) : NEW_LINE INDENT if ( index > n or sum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT f = "" NEW_LINE if ( index == n ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT out [ index ] = "\0" NEW_LINE for i in out : NEW_LINE INDENT f = f + i NEW_LINE DEDENT print ( f , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , index + 1 ) NEW_LINE DEDENT DEDENT
def findNDigitNums ( n , sum ) : NEW_LINE INDENT out = [ False ] * ( n + 1 ) NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT out [ 0 ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , 1 ) NEW_LINE DEDENT DEDENT
def operation ( n , k ) : NEW_LINE INDENT answered = False NEW_LINE if ( n < k ) : NEW_LINE INDENT answered = True NEW_LINE print ( "No" ) NEW_LINE DEDENT ok = factors ( n , k ) NEW_LINE if ( not ok and not answered ) : NEW_LINE INDENT answered = True NEW_LINE print ( "No" ) NEW_LINE DEDENT if ( ok and not answered ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT DEDENT
def isPalUtil ( num , dupNum ) : NEW_LINE INDENT if ( oneDigit ( num ) ) : NEW_LINE INDENT return ( num == ( dupNum ) % 10 ) NEW_LINE DEDENT if ( not isPalUtil ( int ( num / 10 ) , dupNum ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT dupNum = int ( dupNum / 10 ) NEW_LINE return ( num % 10 == ( dupNum ) % 10 ) NEW_LINE DEDENT
def isPal ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT num = - num NEW_LINE DEDENT return isPalUtil ( num , dupNum ) NEW_LINE DEDENT
def printPalPrimesLessThanN ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] and isPal ( p ) ) : NEW_LINE INDENT print ( p , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE count += 1 NEW_LINE DEDENT i = 3 NEW_LINE while ( i <= math . sqrt ( n ) ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n / i NEW_LINE count += 1 NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return ( count ) NEW_LINE DEDENT
def printKAlmostPrimes ( k , n ) : NEW_LINE INDENT i = 1 NEW_LINE num = 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT if ( countPrimeFactors ( num ) == k ) : NEW_LINE INDENT print ( num , end = "" ) NEW_LINE print ( " " , end = "" ) NEW_LINE i += 1 NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return NEW_LINE DEDENT
def findPieces ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) // 2 + 1 NEW_LINE DEDENT
def numToWords ( n , s ) : NEW_LINE INDENT str = "" NEW_LINE if ( n > 19 ) : NEW_LINE INDENT str += ten [ n // 10 ] + one [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT str += one [ n ] NEW_LINE DEDENT if ( n ) : NEW_LINE INDENT str += s NEW_LINE DEDENT return str NEW_LINE DEDENT
def convertToWords ( n ) : NEW_LINE INDENT out = "" NEW_LINE out += numToWords ( ( n // 10000000 ) , "crore " ) NEW_LINE out += numToWords ( ( ( n // 100000 ) % 100 ) , "lakh " ) NEW_LINE out += numToWords ( ( ( n // 1000 ) % 100 ) , "thousand " ) NEW_LINE out += numToWords ( ( ( n // 100 ) % 10 ) , "hundred " ) NEW_LINE if ( n > 100 and n % 100 ) : NEW_LINE INDENT out += "and " NEW_LINE DEDENT out += numToWords ( ( n % 100 ) , "" ) NEW_LINE return out NEW_LINE DEDENT
def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) NEW_LINE return math . floor ( x ) + 1 NEW_LINE DEDENT
def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT digits = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT digits += math . log10 ( i ) NEW_LINE DEDENT return math . floor ( digits ) + 1 NEW_LINE DEDENT
def findPairs ( n ) : NEW_LINE INDENT cubeRoot = int ( math . pow ( n , 1.0 / 3.0 ) ) NEW_LINE cube = [ 0 ] * ( cubeRoot + 1 ) NEW_LINE for i in range ( 1 , cubeRoot + 1 ) : NEW_LINE INDENT cube [ i ] = i * i * i NEW_LINE DEDENT l = 1 NEW_LINE r = cubeRoot NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( cube [ l ] + cube [ r ] < n ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif ( cube [ l ] + cube [ r ] > n ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( "(" , l , ", " , math . floor ( r ) , ")" , end = "" ) NEW_LINE print ( ) NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT DEDENT
def countEvenSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , n , 1 ) : NEW_LINE INDENT sum = sum + arr [ j ] NEW_LINE if ( sum % 2 == 0 ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT
def countEvenSum ( arr , n ) : NEW_LINE INDENT temp = [ 1 , 0 ] NEW_LINE result = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = ( ( sum + arr [ i ] ) % 2 + 2 ) % 2 NEW_LINE temp [ sum ] += 1 NEW_LINE DEDENT result = result + ( temp [ 0 ] * ( temp [ 0 ] - 1 ) // 2 ) NEW_LINE result = result + ( temp [ 1 ] * ( temp [ 1 ] - 1 ) // 2 ) NEW_LINE return ( result ) NEW_LINE DEDENT
def countEvenSum ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE s = 0 NEW_LINE for i in reversed ( range ( n ) ) : NEW_LINE INDENT if arr [ i ] % 2 == 1 : NEW_LINE INDENT s = n - i - 1 - s NEW_LINE DEDENT else : NEW_LINE INDENT s = s + 1 NEW_LINE DEDENT res = res + s NEW_LINE DEDENT return res NEW_LINE DEDENT
def isPossible ( a , b , c ) : NEW_LINE INDENT return ( c % gcd ( a , b ) == 0 ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT while ( b != 0 ) : NEW_LINE INDENT t = b NEW_LINE b = a % b NEW_LINE a = t NEW_LINE DEDENT return a NEW_LINE DEDENT
def findMinDiff ( a , b , x , y ) : NEW_LINE INDENT g = gcd ( a , b ) NEW_LINE diff = abs ( x - y ) % g NEW_LINE return min ( diff , g - diff ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 1 ] = 1 NEW_LINE sm = fibo [ 0 ] + fibo [ 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE sm = sm + fibo [ i ] NEW_LINE DEDENT return sm NEW_LINE DEDENT
def findCombinations ( n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE findCombinationsUtil ( arr , 0 , n , n ) NEW_LINE DEDENT
def isPower ( x , y ) : NEW_LINE INDENT res1 = math . log ( y ) // math . log ( x ) NEW_LINE res2 = math . log ( y ) / math . log ( x ) NEW_LINE return 1 if ( res1 == res2 ) else 0 NEW_LINE DEDENT
def isPerfectSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE the_sum = 0 NEW_LINE while the_sum < n : NEW_LINE INDENT the_sum += i NEW_LINE if the_sum == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return False NEW_LINE DEDENT
def findCount ( d ) : NEW_LINE INDENT return 9 * ( ( int ) ( math . pow ( 10 , d - 1 ) ) - ( int ) ( math . pow ( 9 , d - 1 ) ) ) NEW_LINE DEDENT
def countDyckPaths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res / ( n + 1 ) NEW_LINE DEDENT
def printDivisors ( n ) : NEW_LINE INDENT list = [ ] NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE list . append ( int ( n / i ) ) NEW_LINE DEDENT DEDENT DEDENT for i in list [ : : - 1 ] : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def printDivisors ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i * i < n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for i in range ( int ( sqrt ( n ) ) , 0 , - 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( n // i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def printDivisors ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print i , NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT
def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum , n = 0 , 1 NEW_LINE while ( sum <= num ) : NEW_LINE INDENT sum = sum + n NEW_LINE if ( sum == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT n += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def has0 ( x ) : NEW_LINE INDENT while ( x != 0 ) : NEW_LINE INDENT if ( x % 10 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def getCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count = count + has0 ( i ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def xor_c ( a , b ) : NEW_LINE INDENT return '0' if ( a == b ) else '1' NEW_LINE DEDENT
def greyConverter ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT
def seriesSum ( calculated , current , N ) : NEW_LINE INDENT i = calculated NEW_LINE cur = 1 NEW_LINE if ( current == N + 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( i < calculated + current ) : NEW_LINE INDENT cur *= i NEW_LINE i += 1 NEW_LINE DEDENT return cur + seriesSum ( i , current + 1 , N ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return ( gcd ( b , a % b ) ) NEW_LINE DEDENT
def findSmallest ( a , b ) : NEW_LINE INDENT lcm = ( a * b ) / gcd ( a , b ) NEW_LINE print ( "x =" , lcm / a , "y=" , lcm / b ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def squareRoot ( n , p ) : NEW_LINE INDENT if ( p % 4 != 3 ) : NEW_LINE INDENT print ( "Invalid Input" ) NEW_LINE return NEW_LINE DEDENT n = n % p NEW_LINE x = power ( n , ( p + 1 ) // 4 , p ) NEW_LINE if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( "Square root is " , x ) NEW_LINE return NEW_LINE DEDENT x = p - x NEW_LINE if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( "Square root is " , x ) NEW_LINE return NEW_LINE DEDENT print ( "Square root doesn't exist " ) NEW_LINE DEDENT
def getSum ( BITree , index ) : NEW_LINE INDENT while ( index > 0 ) : NEW_LINE INDENT sum += BITree [ index ] NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def convert ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp [ i ] = arr [ i ] NEW_LINE DEDENT temp = sorted ( temp ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = lower_bound ( temp , arr [ i ] ) + 1 NEW_LINE DEDENT DEDENT
def getInvCount ( arr , n ) : NEW_LINE INDENT convert ( arr , n ) NEW_LINE BIT = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT invcount += getSum ( BIT , arr [ i ] - 1 ) NEW_LINE updateBIT ( BIT , n , arr [ i ] , 1 ) NEW_LINE DEDENT return invcount NEW_LINE DEDENT
def modFact ( n , p ) : NEW_LINE INDENT if n >= p : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result = ( result * i ) % p NEW_LINE DEDENT return result NEW_LINE DEDENT
def largestPower ( n , p ) : NEW_LINE INDENT x = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n //= p NEW_LINE x += n NEW_LINE DEDENT return x NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def modFact ( n , p ) : NEW_LINE INDENT if ( n >= p ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE isPrime = [ 1 ] * ( n + 1 ) NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , n , i ) : NEW_LINE INDENT isPrime [ j ] = 0 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT k = largestPower ( n , i ) NEW_LINE res = ( res * power ( i , k , p ) ) % p NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def modInverse ( a , p ) : NEW_LINE INDENT return power ( a , p - 2 , p ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def miillerTest ( d , n ) : NEW_LINE INDENT a = 2 + random . randint ( 1 , n - 4 ) NEW_LINE x = power ( a , d , n ) NEW_LINE if ( x == 1 or x == n - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT while ( d != n - 1 ) : NEW_LINE INDENT x = ( x * x ) % n NEW_LINE d *= 2 NEW_LINE if ( x == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def isPrime ( n , k ) : NEW_LINE INDENT if ( n <= 1 or n == 4 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT d = n - 1 NEW_LINE while ( d % 2 == 0 ) : NEW_LINE INDENT d //= 2 NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT if ( miillerTest ( d , n ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def inv ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE x0 = 0 NEW_LINE x1 = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if ( x1 < 0 ) : NEW_LINE INDENT x1 = x1 + m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT
def findMinX ( num , rem , k ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT prod = prod * num [ i ] NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT pp = prod // num [ i ] NEW_LINE result = result + rem [ i ] * inv ( pp , num [ i ] ) * pp NEW_LINE DEDENT return result % prod NEW_LINE DEDENT
def findMinX ( num , rem , k ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( x % num [ j ] != rem [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == k ) : NEW_LINE INDENT return x NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT
def largestFiboLessOrEqual ( n ) : NEW_LINE INDENT
def isValid ( n , d ) : NEW_LINE INDENT digit = n % 10 NEW_LINE sum = digit NEW_LINE if ( digit == d ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( digit == d or digit <= sum ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT sum += digit NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countSquares ( m , n ) : NEW_LINE INDENT if ( n < m ) : NEW_LINE INDENT temp = m NEW_LINE m = n NEW_LINE n = temp NEW_LINE DEDENT return ( ( m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ) ) NEW_LINE DEDENT
def countSquares ( m , n ) : NEW_LINE INDENT if ( n < m ) : NEW_LINE INDENT temp = m NEW_LINE m = n NEW_LINE n = temp NEW_LINE DEDENT return n * ( n + 1 ) * ( 3 * m - n + 1 ) // 6 NEW_LINE DEDENT
def printFibRepresntation ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT f = nearestSmallerEqFib ( n ) NEW_LINE print f , NEW_LINE n = n - f NEW_LINE DEDENT DEDENT
def countWaysUtil ( n , parts , nextPart ) : NEW_LINE INDENT if ( parts == 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 or parts <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT for i in range ( nextPart , n + 1 ) : NEW_LINE INDENT ans += countWaysUtil ( n - i , parts - 1 , i ) NEW_LINE DEDENT dp [ n ] [ nextPart ] [ parts ] = ans NEW_LINE return ( ans ) NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT return countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT
def pairAndSum ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( ( i + 1 ) , n ) : NEW_LINE INDENT ans = ans + arr [ i ] & arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def Euler_totient_function ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = 0 NEW_LINE if n % i == 0 : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE n //= i NEW_LINE DEDENT DEDENT if ( c > 0 ) : NEW_LINE INDENT power = math . pow ( i , c - 1 ) NEW_LINE m = math . pow ( i , c - 1 ) * ( i - 1 ) NEW_LINE result *= m NEW_LINE DEDENT DEDENT if ( n > 1 ) : NEW_LINE INDENT result *= ( n - 1 ) NEW_LINE DEDENT return int ( result ) NEW_LINE DEDENT
def nextSparse ( x ) : NEW_LINE INDENT bin = [ ] NEW_LINE while ( x != 0 ) : NEW_LINE INDENT bin . append ( x & 1 ) NEW_LINE x >>= 1 NEW_LINE DEDENT bin . append ( 0 ) NEW_LINE last_final = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( ( bin [ i ] == 1 and bin [ i - 1 ] == 1 and bin [ i + 1 ] != 1 ) ) : NEW_LINE INDENT bin [ i + 1 ] = 1 NEW_LINE for j in range ( i , last_final - 1 , - 1 ) : NEW_LINE INDENT bin [ j ] = 0 NEW_LINE DEDENT last_final = i + 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += bin [ i ] * ( 1 << i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isPower ( n ) : NEW_LINE INDENT p = 0 NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT p = math . log2 ( n ) / math . log2 ( i ) NEW_LINE if ( ( math . ceil ( p ) == math . floor ( p ) ) and p > 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def sumBitDifferences ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans += ( count * ( n - count ) * 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def generateUtil ( x , arr , curr_sum , curr_idx ) : NEW_LINE INDENT if ( curr_sum == x ) : NEW_LINE INDENT printArr ( arr , curr_idx ) NEW_LINE return NEW_LINE DEDENT num = 1 NEW_LINE while ( num <= x - curr_sum and ( curr_idx == 0 or num <= arr [ curr_idx - 1 ] ) ) : NEW_LINE INDENT arr [ curr_idx ] = num NEW_LINE generateUtil ( x , arr , curr_sum + num , curr_idx + 1 ) NEW_LINE num += 1 NEW_LINE DEDENT DEDENT
def generate ( x ) : NEW_LINE INDENT arr = [ 0 ] * x NEW_LINE generateUtil ( x , arr , 0 , 0 ) NEW_LINE DEDENT
def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if sum == n and n != 1 else False ) NEW_LINE DEDENT
def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 33 ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def isLucky ( n ) : NEW_LINE INDENT ar = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = math . floor ( n % 10 ) NEW_LINE if ( ar [ digit ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ar [ digit ] = 1 NEW_LINE n = n / 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def countFact ( low , high ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 1 NEW_LINE while ( fact < low ) : NEW_LINE INDENT fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT res = 0 NEW_LINE while ( fact <= high ) : NEW_LINE INDENT res += 1 NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def nthMagicNo ( n ) : NEW_LINE INDENT pow = 1 NEW_LINE answer = 0 NEW_LINE while ( n ) : NEW_LINE INDENT pow = pow * 5 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT answer += pow NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def modInverse ( a , m ) : NEW_LINE INDENT for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def modInverse ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE y = 0 NEW_LINE x = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = y NEW_LINE y = x - q * y NEW_LINE x = t NEW_LINE DEDENT if ( x < 0 ) : NEW_LINE INDENT x = x + m0 NEW_LINE DEDENT return x NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def phi ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( gcd ( i , n ) == 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def phi ( n ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if n % p == 0 : NEW_LINE INDENT while n % p == 0 : NEW_LINE INDENT n = n // p NEW_LINE DEDENT result = result * ( 1.0 - ( 1.0 / float ( p ) ) ) NEW_LINE DEDENT p = p + 1 NEW_LINE DEDENT if n > 1 : NEW_LINE INDENT result = result * ( 1.0 - ( 1.0 / float ( n ) ) ) NEW_LINE DEDENT return int ( result ) NEW_LINE DEDENT
def getDifference ( dt1 , dt2 ) : NEW_LINE INDENT n1 = dt1 . y * 365 + dt1 . d NEW_LINE for i in range ( 0 , dt1 . m - 1 ) : NEW_LINE INDENT n1 += monthDays [ i ] NEW_LINE DEDENT n1 += countLeapYears ( dt1 ) NEW_LINE n2 = dt2 . y * 365 + dt2 . d NEW_LINE for i in range ( 0 , dt2 . m - 1 ) : NEW_LINE INDENT n2 += monthDays [ i ] NEW_LINE DEDENT n2 += countLeapYears ( dt2 ) NEW_LINE return ( n2 - n1 ) NEW_LINE DEDENT
def countOfMultiples ( n ) : NEW_LINE INDENT return ( int ( n / 3 ) + int ( n / 5 ) - int ( n / 15 ) ) NEW_LINE DEDENT
def getPeriod ( n ) : NEW_LINE INDENT rem = 1 NEW_LINE for i in range ( 1 , n + 2 ) : NEW_LINE INDENT rem = ( 10 * rem ) % n NEW_LINE DEDENT d = rem NEW_LINE count = 0 NEW_LINE rem = ( 10 * rem ) % n NEW_LINE count += 1 NEW_LINE while rem != d : NEW_LINE INDENT rem = ( 10 * rem ) % n NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def calculateAddedValue ( number ) : NEW_LINE INDENT result = 0 NEW_LINE decimalPlace = 1 NEW_LINE if ( number == 0 ) : NEW_LINE INDENT result += ( 5 * decimalPlace ) NEW_LINE DEDENT while ( number > 0 ) : NEW_LINE INDENT if ( number % 10 == 0 ) : NEW_LINE INDENT result += ( 5 * decimalPlace ) NEW_LINE DEDENT number //= 10 NEW_LINE decimalPlace *= 10 NEW_LINE DEDENT return result NEW_LINE DEDENT
def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num // divisor ) ) NEW_LINE DEDENT
def getRemainder ( num , divisor ) : NEW_LINE INDENT while ( num >= divisor ) : NEW_LINE INDENT num -= divisor NEW_LINE DEDENT return num NEW_LINE DEDENT
def minInsertion ( tr1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE count = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] % 2 == 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT if ( res == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return res - 1 NEW_LINE DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s += 1.0 / factorial ( i ) NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE sum += 1.0 / fact NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return int ( c / ( n + 1 ) ) NEW_LINE DEDENT
def printSquares ( n ) : NEW_LINE INDENT square = 0 NEW_LINE odd = 1 NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT print ( square , end = " " ) NEW_LINE DEDENT square = square + odd NEW_LINE odd = odd + 2 NEW_LINE DEDENT
def isOperand ( c ) : NEW_LINE INDENT return ( c >= '0' and c <= '9' ) NEW_LINE DEDENT
def value ( c ) : NEW_LINE INDENT return ord ( c ) - ord ( '0' ) NEW_LINE DEDENT
def evaluate ( exp ) : NEW_LINE INDENT len1 = len ( exp ) NEW_LINE if ( len1 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT res = value ( exp [ 0 ] ) NEW_LINE for i in range ( 1 , len1 , 2 ) : NEW_LINE INDENT opr = exp [ i ] NEW_LINE opd = exp [ i + 1 ] NEW_LINE if ( isOperand ( opd ) == False ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( opr == '+' ) : NEW_LINE INDENT res += value ( opd ) NEW_LINE DEDENT elif ( opr == '-' ) : NEW_LINE INDENT res -= int ( value ( opd ) ) NEW_LINE DEDENT elif ( opr == '*' ) : NEW_LINE INDENT res *= int ( value ( opd ) ) NEW_LINE DEDENT elif ( opr == '/' ) : NEW_LINE INDENT res /= int ( value ( opd ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i NEW_LINE DEDENT return s NEW_LINE DEDENT
def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( f1 , end = " " ) NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT print ( f2 , end = " " ) NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def lcm ( a , b ) : NEW_LINE INDENT return ( a / gcd ( a , b ) ) * b NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT
def gcd ( a , b ) : ' NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] += ( arr [ arr [ i ] ] % n ) * n NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = int ( arr [ i ] / n ) NEW_LINE DEDENT DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT print ( "" ) NEW_LINE DEDENT
def maxdiff ( arr , n ) : NEW_LINE INDENT freq = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) NEW_LINE DEDENT elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def printSequencesRecur ( arr , n , k , index ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT printArray ( arr , index ) NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ index ] = i NEW_LINE printSequencesRecur ( arr , n , k - 1 , index + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def printSequences ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE printSequencesRecur ( arr , n , k , 0 ) NEW_LINE return NEW_LINE DEDENT
def isMultipleof5 ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT n = n - 5 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def isPowerOfTwo ( x ) : NEW_LINE INDENT return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE DEDENT
def isPowerofTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( n & ( ~ ( n - 1 ) ) ) == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def reversDigits ( num ) : NEW_LINE INDENT global rev_num NEW_LINE global base_pos NEW_LINE if ( num > 0 ) : NEW_LINE INDENT reversDigits ( ( int ) ( num / 10 ) ) NEW_LINE rev_num += ( num % 10 ) * base_pos NEW_LINE base_pos *= 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT
def countSubsequences ( arr ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for x in arr : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT return ( ( 1 << odd ) - 1 ) * ( 1 << even ) NEW_LINE DEDENT
def findDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE max_count = 0 NEW_LINE min_count = n NEW_LINE for i in range ( 0 , ( n - 1 ) ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT max_count = max ( max_count , count ) NEW_LINE min_count = min ( min_count , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return max_count - min_count NEW_LINE DEDENT
def XorSum ( A , B , N , M ) : NEW_LINE INDENT ans = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( ans == - 1 ) : NEW_LINE INDENT ans = ( A [ i ] & B [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans ^= ( A [ i ] & B [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countbitdiff ( xo ) : NEW_LINE INDENT count = 0 NEW_LINE while ( xo ) : NEW_LINE INDENT if ( xo % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT xo = xo // 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
def convertXOR ( arr ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT X = arr [ i ] [ j ] NEW_LINE temp = findXOR ( X ) NEW_LINE arr [ i ] [ j ] = temp NEW_LINE DEDENT DEDENT printXORmatrix ( arr ) NEW_LINE DEDENT
def countSet ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE while N : NEW_LINE INDENT ans += N & 1 NEW_LINE N >>= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countSub ( arr , k ) : NEW_LINE INDENT ans = 0 NEW_LINE setK = 0 NEW_LINE for i in arr : NEW_LINE INDENT if countSet ( i ) == k : NEW_LINE INDENT setK += 1 NEW_LINE DEDENT else : NEW_LINE INDENT setK = 0 NEW_LINE DEDENT ans += setK NEW_LINE DEDENT return ans NEW_LINE DEDENT
def oddXorSubarray ( a , n ) : NEW_LINE INDENT odd = 0 NEW_LINE c_odd = 0 NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] & 1 ) : NEW_LINE INDENT odd = not odd NEW_LINE DEDENT if ( odd ) : NEW_LINE INDENT c_odd += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT result += c_odd NEW_LINE if ( a [ i ] & 1 ) : NEW_LINE INDENT c_odd = ( n - i - c_odd ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def countPairs ( arr , N , K ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cnt += mp [ K - arr [ i ] ] NEW_LINE mp [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT
def uniqueLevels ( root ) : NEW_LINE INDENT uniqueLevels = 0 NEW_LINE que = [ root ] NEW_LINE while len ( que ) : NEW_LINE INDENT length = len ( que ) NEW_LINE prefix_XOR = 0 NEW_LINE prefix_OR = 0 NEW_LINE flag = True NEW_LINE while length : NEW_LINE INDENT temp = que . pop ( 0 ) NEW_LINE prefix_OR |= temp . val NEW_LINE prefix_XOR ^= temp . val NEW_LINE if prefix_XOR != prefix_OR : NEW_LINE INDENT flag = False NEW_LINE DEDENT if temp . left : NEW_LINE INDENT que . append ( temp . left ) NEW_LINE DEDENT if temp . right : NEW_LINE INDENT que . append ( temp . right ) NEW_LINE DEDENT length -= 1 NEW_LINE DEDENT if flag : NEW_LINE INDENT uniqueLevels += 1 NEW_LINE DEDENT DEDENT print ( uniqueLevels ) NEW_LINE DEDENT
def query ( l , r , pre ) : NEW_LINE INDENT if ( l == 0 ) : NEW_LINE INDENT return pre [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return pre [ r ] - pre [ l - 1 ] NEW_LINE DEDENT DEDENT
def countInRange ( arr , N , queries , Q ) : NEW_LINE INDENT pre = [ 0 ] * N NEW_LINE pre [ 0 ] = check ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + check ( arr [ i ] ) NEW_LINE DEDENT c = 0 NEW_LINE while ( Q > 0 ) : NEW_LINE INDENT l = queries [ 0 ] NEW_LINE r = queries [ 1 ] NEW_LINE c += 1 NEW_LINE print ( query ( l , r , pre ) , end = " " ) NEW_LINE Q -= 1 NEW_LINE DEDENT DEDENT
def Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) : NEW_LINE INDENT frequency = [ 0 ] * 32 NEW_LINE for i in range ( N ) : NEW_LINE INDENT bit_position = 0 NEW_LINE num = arr1 [ i ] NEW_LINE while ( num ) : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT frequency [ bit_position ] += 1 NEW_LINE DEDENT bit_position += 1 NEW_LINE num >>= 1 NEW_LINE DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT num = arr2 [ i ] NEW_LINE value_at_that_bit = 1 NEW_LINE bitwise_AND_sum = 0 NEW_LINE for bit_position in range ( 32 ) : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit NEW_LINE DEDENT num >>= 1 NEW_LINE value_at_that_bit <<= 1 NEW_LINE DEDENT print ( bitwise_AND_sum , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT
def Bitwise_OR_sum_i ( arr1 , arr2 , M , N ) : NEW_LINE INDENT frequency = [ 0 ] * 32 NEW_LINE for i in range ( N ) : NEW_LINE INDENT bit_position = 0 NEW_LINE num = arr1 [ i ] NEW_LINE while ( num ) : NEW_LINE INDENT if ( num & 1 != 0 ) : NEW_LINE INDENT frequency [ bit_position ] += 1 NEW_LINE DEDENT bit_position += 1 NEW_LINE num >>= 1 NEW_LINE DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT num = arr2 [ i ] NEW_LINE value_at_that_bit = 1 NEW_LINE bitwise_OR_sum = 0 NEW_LINE for bit_position in range ( 32 ) : NEW_LINE INDENT if ( num & 1 != 0 ) : NEW_LINE INDENT bitwise_OR_sum += N * value_at_that_bit NEW_LINE DEDENT else : NEW_LINE INDENT bitwise_OR_sum += ( frequency [ bit_position ] * value_at_that_bit ) NEW_LINE DEDENT num >>= 1 NEW_LINE value_at_that_bit <<= 1 NEW_LINE DEDENT print ( bitwise_OR_sum , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT
def constructArray ( A , N , K ) : NEW_LINE INDENT B = [ 0 ] * N NEW_LINE totalXOR = A [ 0 ] ^ K NEW_LINE for i in range ( N ) : NEW_LINE INDENT B [ i ] = totalXOR ^ A [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , k , size ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( size - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT x = arr [ i ] | arr [ j ] NEW_LINE if ( x == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def dfs ( node , xorr , k ) : NEW_LINE INDENT global ans NEW_LINE visited [ node ] = 1 NEW_LINE if ( node != 1 and xorr == k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT for x in adj [ node ] : NEW_LINE INDENT if ( not visited [ x [ 0 ] ] ) : NEW_LINE INDENT xorr1 = xorr ^ x [ 1 ] NEW_LINE dfs ( x [ 0 ] , xorr1 , k ) NEW_LINE DEDENT DEDENT DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT SubsetSum_1 = 0 NEW_LINE SubsetSum_2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT isSingleOccurance = True NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT isSingleOccurance = False NEW_LINE arr [ i ] = arr [ j ] = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( isSingleOccurance == True ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT SubsetSum_1 += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT SubsetSum_2 += arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return abs ( SubsetSum_1 - SubsetSum_2 ) NEW_LINE DEDENT
def build_num ( bit ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT if ( bit [ i ] > 0 ) : NEW_LINE INDENT ans += ( 1 << i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maximumOR ( arr , n , k ) : NEW_LINE INDENT bit = [ 0 ] * 32 NEW_LINE for i in range ( k ) : NEW_LINE INDENT for j in range ( 32 ) : NEW_LINE INDENT if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT bit [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT max_or = build_num ( bit ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT for j in range ( 32 ) : NEW_LINE INDENT if ( ( arr [ i - k ] & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT bit [ j ] -= 1 NEW_LINE DEDENT DEDENT for j in range ( 32 ) : NEW_LINE INDENT if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT bit [ j ] += 1 NEW_LINE DEDENT DEDENT max_or = max ( build_num ( bit ) , max_or ) NEW_LINE DEDENT return max_or NEW_LINE DEDENT
def build_num ( bit , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT if ( bit [ i ] == k ) : NEW_LINE INDENT ans += ( 1 << i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minimumAND ( arr , n , k ) : NEW_LINE INDENT bit = [ 0 ] * 32 NEW_LINE for i in range ( k ) : NEW_LINE INDENT for j in range ( 32 ) : NEW_LINE INDENT if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT bit [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT min_and = build_num ( bit , k ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT for j in range ( 32 ) : NEW_LINE INDENT if ( ( arr [ i - k ] & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT bit [ j ] -= 1 NEW_LINE DEDENT DEDENT for j in range ( 32 ) : NEW_LINE INDENT if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT bit [ j ] += 1 NEW_LINE DEDENT DEDENT min_and = min ( build_num ( bit , k ) , min_and ) NEW_LINE DEDENT return min_and NEW_LINE DEDENT
def findMinXORSubarray ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT return NEW_LINE DEDENT res_index = 0 NEW_LINE curr_xor = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_xor ^= arr [ i ] NEW_LINE DEDENT min_xor = curr_xor NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) NEW_LINE if ( curr_xor < min_xor ) : NEW_LINE INDENT min_xor = curr_xor NEW_LINE res_index = ( i - k + 1 ) NEW_LINE DEDENT DEDENT print ( min_xor ) NEW_LINE DEDENT
def findmax ( arr , n , k ) : NEW_LINE INDENT trav , i = 0 , 0 NEW_LINE c = 0 NEW_LINE maximum = 0 NEW_LINE while i < n - k + 1 : NEW_LINE INDENT trav = i - 1 NEW_LINE c = 0 NEW_LINE while trav >= 0 and arr [ trav ] == 1 : NEW_LINE INDENT trav -= 1 NEW_LINE c += 1 NEW_LINE DEDENT trav = i + k NEW_LINE while ( trav < n and arr [ trav ] == 1 ) : NEW_LINE INDENT trav += 1 NEW_LINE c += 1 NEW_LINE DEDENT c += k NEW_LINE if ( c > maximum ) : NEW_LINE INDENT maximum = c NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return maximum NEW_LINE DEDENT
def powerOfTwo ( a , n ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT f = False NEW_LINE for j in range ( 31 ) : NEW_LINE INDENT s = ( 1 << j ) - a [ i ] NEW_LINE if ( s in mp and ( mp [ s ] > 1 or mp [ s ] == 1 and s != a [ i ] ) ) : NEW_LINE INDENT f = True NEW_LINE DEDENT DEDENT if ( f == False ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) : NEW_LINE INDENT result += abs ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT if ( arr [ n - 2 ] != arr [ n - 1 ] ) : NEW_LINE INDENT result += abs ( arr [ n - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def findArray ( n , a , b , c ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) NEW_LINE for bit in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT set = a & ( 1 << bit ) NEW_LINE if ( set ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] |= set NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b & ( 1 << bit ) ) : NEW_LINE INDENT arr [ 0 ] |= ( 1 << bit ) NEW_LINE if ( not ( c & ( 1 << bit ) ) ) : NEW_LINE INDENT arr [ 1 ] |= ( 1 << bit ) NEW_LINE DEDENT DEDENT DEDENT DEDENT aa = sys . maxsize NEW_LINE bb = 0 NEW_LINE cc = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT aa &= arr [ i ] NEW_LINE bb |= arr [ i ] NEW_LINE cc ^= arr [ i ] NEW_LINE DEDENT if ( a == aa and b == bb and c == cc ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def countSubarray ( arr , K , N ) : NEW_LINE INDENT if ( K % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N < K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT start = 0 NEW_LINE i = 0 NEW_LINE count = 0 NEW_LINE currXor = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i < K ) : NEW_LINE INDENT currXor ^= arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT if ( currXor == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT currXor ^= arr [ start ] NEW_LINE start += 1 NEW_LINE while ( i < N ) : NEW_LINE INDENT currXor ^= arr [ i ] NEW_LINE i += 1 NEW_LINE if ( currXor == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT currXor ^= arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findLargestNumber ( arr ) : NEW_LINE INDENT k = max ( arr ) NEW_LINE m = [ 0 ] * ( k + 1 ) NEW_LINE for n in arr : NEW_LINE INDENT m [ n ] += 1 NEW_LINE DEDENT for n in range ( len ( arr ) - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( n == m [ n ] ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT hashPositive = dict ( ) NEW_LINE hashNegative = dict ( ) NEW_LINE SubsetSum_1 , SubsetSum_2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT hashPositive [ arr [ i ] ] = hashPositive . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 and arr [ i ] in hashPositive . keys ( ) and hashPositive [ arr [ i ] ] == 1 ) : NEW_LINE INDENT SubsetSum_1 += arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT hashNegative [ abs ( arr [ i ] ) ] = hashNegative . get ( abs ( arr [ i ] ) , 0 ) + 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 and abs ( arr [ i ] ) in hashNegative . keys ( ) and hashNegative [ abs ( arr [ i ] ) ] == 1 ) : NEW_LINE INDENT SubsetSum_2 += arr [ i ] NEW_LINE DEDENT DEDENT return abs ( SubsetSum_1 - SubsetSum_2 ) NEW_LINE DEDENT
def NoCarrySum ( N , M ) : NEW_LINE INDENT return N ^ M NEW_LINE DEDENT
def CheckBits ( N , K ) : NEW_LINE INDENT check = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if ( ( 1 << i ) & N ) : NEW_LINE INDENT if ( check == 0 ) : NEW_LINE INDENT check = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count < K ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def RecursiveFunction ( ref , bit ) : NEW_LINE INDENT if ( len ( ref ) == 0 or bit < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT curr_on = [ ] NEW_LINE curr_off = [ ] NEW_LINE for i in range ( len ( ref ) ) : NEW_LINE INDENT if ( ( ( ref [ i ] >> bit ) & 1 ) == 0 ) : NEW_LINE INDENT curr_off . append ( ref [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT curr_on . append ( ref [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( curr_off ) == 0 ) : NEW_LINE INDENT return RecursiveFunction ( curr_on , bit - 1 ) NEW_LINE DEDENT if ( len ( curr_on ) == 0 ) : NEW_LINE INDENT return RecursiveFunction ( curr_off , bit - 1 ) NEW_LINE DEDENT return ( min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ) NEW_LINE DEDENT
def minimumFlips ( X , Y , Z ) : NEW_LINE INDENT res = 0 NEW_LINE while ( X > 0 or Y > 0 or Z > 0 ) : NEW_LINE INDENT if ( ( ( X & 1 ) or ( Y & 1 ) ) and ( Z & 1 ) ) : NEW_LINE INDENT X = X >> 1 NEW_LINE Y = Y >> 1 NEW_LINE Z = Z >> 1 NEW_LINE continue NEW_LINE DEDENT elif ( not ( X & 1 ) and not ( Y & 1 ) and ( Z & 1 ) ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT elif ( ( X & 1 ) or ( Y & 1 ) == 1 ) : NEW_LINE INDENT if ( ( X & 1 ) and ( Y & 1 ) and not ( Z & 1 ) ) : NEW_LINE INDENT res += 2 NEW_LINE DEDENT elif ( ( ( X & 1 ) or ( Y & 1 ) ) and not ( Z & 1 ) ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT X = X >> 1 NEW_LINE Y = Y >> 1 NEW_LINE Z = Z >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def FlipBits ( n ) : NEW_LINE INDENT n -= ( n & ( - n ) ) NEW_LINE return n NEW_LINE DEDENT
def calculate ( section , pos ) : NEW_LINE INDENT if ( pos < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT on_section = [ ] NEW_LINE off_section = [ ] NEW_LINE for el in section : NEW_LINE INDENT if ( ( ( el >> pos ) & 1 ) == 0 ) : NEW_LINE INDENT off_section . append ( el ) NEW_LINE DEDENT else : NEW_LINE INDENT on_section . append ( el ) NEW_LINE DEDENT DEDENT if ( len ( off_section ) == 0 ) : NEW_LINE INDENT return calculate ( on_section , pos - 1 ) NEW_LINE DEDENT if ( len ( on_section ) == 0 ) : NEW_LINE INDENT return calculate ( off_section , pos - 1 ) NEW_LINE DEDENT return min ( calculate ( off_section , pos - 1 ) , calculate ( on_section , pos - 1 ) ) + ( 1 << pos ) NEW_LINE DEDENT
def minXorValue ( a , n ) : NEW_LINE INDENT section = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT section . append ( a [ i ] ) NEW_LINE DEDENT return calculate ( section , 30 ) NEW_LINE DEDENT
def SieveOfEratosthenes ( prime ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , int ( MAX ** ( 1 / 2 ) ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def prime_xor ( arr , n , k ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE SieveOfEratosthenes ( prime ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT if ( ( i + 1 ) % k == 0 ) : NEW_LINE INDENT ans ^= arr [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def xorOfArray ( arr , n ) : NEW_LINE INDENT xor_arr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xor_arr = xor_arr ^ arr [ i ] NEW_LINE DEDENT return xor_arr NEW_LINE DEDENT
def countEvenBit ( A , B , n , m ) : NEW_LINE INDENT i , j , cntOdd = 0 , 0 , 0 NEW_LINE cntEven = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = bin ( A [ i ] ) [ 2 : ] . count ( '1' ) NEW_LINE if ( x & 1 ) : NEW_LINE INDENT cntEven += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntOdd += 1 NEW_LINE DEDENT DEDENT CountB = [ 0 ] * m NEW_LINE for i in range ( m ) : NEW_LINE INDENT x = bin ( B [ i ] ) [ 2 : ] . count ( '1' ) NEW_LINE if ( x & 1 ) : NEW_LINE INDENT CountB [ i ] = cntEven NEW_LINE DEDENT else : NEW_LINE INDENT CountB [ i ] = cntOdd NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT print ( CountB [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def isEven ( n ) : NEW_LINE INDENT if ( n ^ 1 == n + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def bitwiseOrTillN ( n ) : NEW_LINE INDENT result = 2 NEW_LINE for i in range ( 4 , n + 1 , 2 ) : NEW_LINE INDENT result = result | i NEW_LINE DEDENT return result NEW_LINE DEDENT
def minRange ( arr , n , k ) : NEW_LINE INDENT l , r = 0 , n NEW_LINE i = 0 NEW_LINE j = - 1 NEW_LINE hm = defaultdict ( lambda : 0 ) NEW_LINE while i < n : NEW_LINE INDENT while j < n : NEW_LINE INDENT j += 1 NEW_LINE if len ( hm ) < k and j < n : NEW_LINE INDENT hm [ arr [ j ] ] += 1 NEW_LINE DEDENT if len ( hm ) == k and ( ( r - l ) >= ( j - i ) ) : NEW_LINE INDENT l , r = i , j NEW_LINE break NEW_LINE DEDENT DEDENT if len ( hm ) < k : NEW_LINE INDENT break NEW_LINE DEDENT while len ( hm ) == k : NEW_LINE INDENT if hm [ arr [ i ] ] == 1 : NEW_LINE INDENT del ( hm [ arr [ i ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT hm [ arr [ i ] ] -= 1 NEW_LINE DEDENT i += 1 NEW_LINE if len ( hm ) == k and ( r - l ) >= ( j - i ) : NEW_LINE INDENT l , r = i , j NEW_LINE DEDENT DEDENT if hm [ arr [ i ] ] == 1 : NEW_LINE INDENT del ( hm [ arr [ i ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT hm [ arr [ i ] ] -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if l == 0 and r == n : NEW_LINE INDENT print ( "Invalid k" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l , r ) NEW_LINE DEDENT DEDENT
def bitwiseOrTillN ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT bitCount = int ( log2 ( n ) ) + 1 NEW_LINE return pow ( 2 , bitCount ) - 2 NEW_LINE DEDENT
def bitwiseAndOdd ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT result = ( result & i ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def bitwiseAndOdd ( n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT
def construct_Xor_Tree_Util ( current , start , end , x ) : NEW_LINE INDENT if ( start == end ) : NEW_LINE INDENT xor_tree [ x ] = current [ start ] NEW_LINE return NEW_LINE DEDENT left = x * 2 + 1 NEW_LINE right = x * 2 + 2 NEW_LINE mid = start + ( end - start ) // 2 NEW_LINE construct_Xor_Tree_Util ( current , start , mid , left ) NEW_LINE construct_Xor_Tree_Util ( current , mid + 1 , end , right ) NEW_LINE xor_tree [ x ] = ( xor_tree [ left ] ^ xor_tree [ right ] ) NEW_LINE DEDENT
def genSequence ( n , val ) : NEW_LINE INDENT for i in range ( 1 << n ) : NEW_LINE INDENT x = i ^ ( i >> 1 ) ^ val NEW_LINE print ( x , end = " " ) NEW_LINE DEDENT DEDENT
def check ( arr , n , m , d ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n and m > 0 ) : NEW_LINE INDENT m -= 1 NEW_LINE i += d NEW_LINE DEDENT if m == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def maximumDistance ( arr , n , m ) : NEW_LINE INDENT low = 1 NEW_LINE high = n - 1 NEW_LINE ans = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE flag = check ( arr , n , m , mid ) NEW_LINE if ( flag ) : NEW_LINE INDENT ans = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minTrees ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def longest ( a , n , k ) : NEW_LINE INDENT freq = collections . defaultdict ( int ) NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE now = 0 NEW_LINE l = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE if ( freq [ a [ i ] ] == 1 ) : NEW_LINE INDENT now += 1 NEW_LINE DEDENT while ( now > k ) : NEW_LINE INDENT freq [ a [ l ] ] -= 1 NEW_LINE if ( freq [ a [ l ] ] == 0 ) : NEW_LINE INDENT now -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT if ( i - l + 1 >= end - start + 1 ) : NEW_LINE INDENT end = i NEW_LINE start = l NEW_LINE DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def extraElement ( A , B , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans ^= A [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT ans ^= B [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def maxOnes ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT currMax = maxConsecutiveOnes ( arr [ i ] ) NEW_LINE ans = max ( ans , currMax ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxOR ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( MAX - 1 , - 1 , - 1 ) : NEW_LINE INDENT p = 1 << i NEW_LINE if ( ( rbit == 1 ) and ( lbit == 0 ) ) : NEW_LINE INDENT ans += ( p << 1 ) - 1 NEW_LINE break NEW_LINE DEDENT if ( rbit == 1 ) : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findLen ( arr , n , m ) : NEW_LINE INDENT filter = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] & m ) == m ) : NEW_LINE INDENT filter . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( filter ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT c_and = filter [ 0 ] NEW_LINE for i in range ( 1 , len ( filter ) ) : NEW_LINE INDENT c_and &= filter [ i ] NEW_LINE DEDENT if ( c_and == m ) : NEW_LINE INDENT return len ( filter ) NEW_LINE DEDENT DEDENT
def toggleBit ( n , k ) : NEW_LINE INDENT return ( n ^ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT
def clearBit ( n , k ) : NEW_LINE INDENT return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) NEW_LINE DEDENT
def getMinSteps ( K ) : NEW_LINE INDENT return bin ( K ) . count ( "1" ) NEW_LINE DEDENT
def sum ( a , n ) : NEW_LINE INDENT cnt = dict ( ) NEW_LINE ans = 0 NEW_LINE pre_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += ( i * a [ i ] ) - pre_sum NEW_LINE pre_sum += a [ i ] NEW_LINE if ( a [ i ] - 1 ) in cnt : NEW_LINE INDENT ans -= cnt [ a [ i ] - 1 ] NEW_LINE DEDENT if ( a [ i ] + 1 ) in cnt : NEW_LINE INDENT ans += cnt [ a [ i ] + 1 ] NEW_LINE DEDENT if a [ i ] not in cnt : NEW_LINE INDENT cnt [ a [ i ] ] = 0 NEW_LINE DEDENT cnt [ a [ i ] ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def cntElements ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def xor_triplet ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT xor1 = 0 NEW_LINE xor2 = 0 NEW_LINE for x in range ( i , j ) : NEW_LINE INDENT xor1 ^= arr [ x ] NEW_LINE DEDENT for x in range ( j , k + 1 ) : NEW_LINE INDENT xor2 ^= arr [ x ] NEW_LINE DEDENT if ( xor1 == xor2 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def findSubarray ( array , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE mp [ 0 ] = 1 NEW_LINE answer = 0 NEW_LINE preXor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT value = 1 NEW_LINE preXor ^= array [ i ] NEW_LINE for j in range ( 1 , MAX + 1 ) : NEW_LINE INDENT Y = value ^ preXor NEW_LINE if ( Y in mp . keys ( ) ) : NEW_LINE INDENT answer += mp [ Y ] NEW_LINE DEDENT value *= 2 NEW_LINE DEDENT if ( preXor in mp . keys ( ) ) : NEW_LINE INDENT mp [ preXor ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ preXor ] = 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def max_xor ( arr , n ) : NEW_LINE INDENT maxXor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxXor = max ( maxXor , arr [ i ] ^ arr [ j ] ) NEW_LINE DEDENT DEDENT return maxXor NEW_LINE DEDENT
def CountTriplets ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT first = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT first ^= arr [ j ] NEW_LINE if ( first == 0 ) : NEW_LINE INDENT ans += ( j - i ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def findMajority ( arr , n ) : NEW_LINE INDENT Len = 32 NEW_LINE number = 0 NEW_LINE for i in range ( Len ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > ( n // 2 ) ) : NEW_LINE INDENT number += ( 1 << i ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == number ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > ( n // 2 ) ) : NEW_LINE INDENT print ( number ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Majority Element Not Present" ) NEW_LINE DEDENT DEDENT
def countBits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a or b ) : NEW_LINE INDENT last_bit_a = a & 1 NEW_LINE last_bit_b = b & 1 NEW_LINE if ( last_bit_a != last_bit_b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT a = a >> 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def CountSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( n & 1 ) == 1 ) : NEW_LINE INDENT return 1 + CountSetBits ( n >> 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return CountSetBits ( n >> 1 ) NEW_LINE DEDENT DEDENT
def calculate ( bit_cnt ) : NEW_LINE INDENT res = 1 NEW_LINE while ( bit_cnt > 0 ) : NEW_LINE INDENT bit_cnt -= 1 NEW_LINE res = res * 3 NEW_LINE DEDENT return res NEW_LINE DEDENT
def unset_bit_count ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def bit_q ( i , j ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( j > 0 ) : NEW_LINE INDENT sum += bit [ j ] NEW_LINE j -= ( j & ( j * - 1 ) ) NEW_LINE DEDENT i -= 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT sum -= bit [ i ] NEW_LINE i -= ( i & ( i * - 1 ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def bit_up ( i , diff ) : NEW_LINE INDENT while ( i <= n ) : NEW_LINE INDENT bit [ i ] += diff NEW_LINE i += i & - i NEW_LINE DEDENT DEDENT
def initialise ( ) : NEW_LINE INDENT Ideal_pair = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT root_node [ i ] = True NEW_LINE bit [ i ] = 0 NEW_LINE DEDENT DEDENT
def Idealpairs ( ) : NEW_LINE INDENT r = - 1 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT if ( root_node [ i ] ) : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT Ideal_pair = dfs ( r , 0 ) NEW_LINE return Ideal_pair NEW_LINE DEDENT
def pairORSum ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( ( i + 1 ) , n ) : NEW_LINE INDENT ans = ans + arr [ i ] | arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def solve ( A , B , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT c = A [ i ] & A [ j ] NEW_LINE if ( bin ( c ) . count ( '1' ) == B [ j ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def multiplyByFifteen ( n ) : NEW_LINE INDENT prod = ( n << 3 ) NEW_LINE prod += ( n << 2 ) NEW_LINE prod += ( n << 1 ) NEW_LINE prod += n NEW_LINE return prod NEW_LINE DEDENT
def balTernary ( ter ) : NEW_LINE INDENT carry , base , i = 0 , 10 , 31 NEW_LINE while ter > 0 : NEW_LINE INDENT rem = ( ter % base ) + carry NEW_LINE if rem == 0 : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE carry , i = 0 , i - 1 NEW_LINE DEDENT elif rem == 1 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE carry , i = 0 , i - 1 NEW_LINE DEDENT elif rem == 2 : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE carry , i = 1 , i - 1 NEW_LINE DEDENT elif rem == 3 : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE carry , i = 1 , i - 1 NEW_LINE DEDENT ter = ter // base NEW_LINE DEDENT if carry == 1 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT
def isDefeat ( s1 , s2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( s1 [ i ] == '0' and s2 [ i ] == '1' ) or ( s1 [ i ] == '1' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( ( s1 [ i ] == '0' and s2 [ i ] == 'Z' ) or ( s1 [ i ] == 'Z' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def check ( a , b ) : NEW_LINE INDENT for i in range ( 1 , N , 1 ) : NEW_LINE INDENT for j in range ( 1 , M , 1 ) : NEW_LINE INDENT if ( a [ i ] [ j ] != b [ i ] [ j ] ) : NEW_LINE INDENT a [ i ] [ j ] ^= 1 NEW_LINE a [ 0 ] [ 0 ] ^= 1 NEW_LINE a [ 0 ] [ j ] ^= 1 NEW_LINE a [ i ] [ 0 ] ^= 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( a [ i ] [ j ] != b [ i ] [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def FindIndexKthBit ( n , k ) : NEW_LINE INDENT cnt , ind = 0 , 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if cnt == k : NEW_LINE INDENT return ind NEW_LINE DEDENT ind += 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def check ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def findArray ( q , n ) : NEW_LINE INDENT arr = [ None ] * n NEW_LINE k = 0 NEW_LINE for j in range ( int ( n / 4 ) ) : NEW_LINE INDENT ans = q [ k ] ^ q [ k + 3 ] NEW_LINE arr [ k + 1 ] = q [ k + 1 ] ^ ans NEW_LINE arr [ k + 2 ] = q [ k + 2 ] ^ ans NEW_LINE arr [ k ] = q [ k ] ^ ( ( arr [ k + 1 ] ) ^ ( arr [ k + 2 ] ) ) NEW_LINE arr [ k + 3 ] = q [ k + 3 ] ^ ( arr [ k + 1 ] ^ arr [ k + 2 ] ) NEW_LINE k += 4 NEW_LINE DEDENT printArray ( arr , n ) NEW_LINE DEDENT
def countX ( n ) : NEW_LINE INDENT binary = "{0:b}" . format ( n ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( binary ) ) : NEW_LINE INDENT if ( binary [ i ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT answer = int ( pow ( 2 , count ) ) NEW_LINE return answer NEW_LINE DEDENT
def binToDecimal3 ( n ) : NEW_LINE INDENT a = [ 0 for i in range ( 64 ) ] NEW_LINE x = 0 NEW_LINE i = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a [ i ] = n % 2 NEW_LINE n = int ( n / 2 ) NEW_LINE i += 1 NEW_LINE DEDENT if ( i < 3 ) : NEW_LINE INDENT x = 3 NEW_LINE DEDENT else : NEW_LINE INDENT x = i NEW_LINE DEDENT d = 0 NEW_LINE p = 0 NEW_LINE for i in range ( x - 3 , x , 1 ) : NEW_LINE INDENT d += a [ i ] * pow ( 2 , p ) NEW_LINE p += 1 NEW_LINE DEDENT print ( int ( d ) , end = " " ) NEW_LINE d = 0 NEW_LINE p = 0 NEW_LINE for i in range ( 0 , 3 , 1 ) : NEW_LINE INDENT d += a [ i ] * pow ( 2 , p ) NEW_LINE p += 1 NEW_LINE DEDENT print ( int ( d ) , end = " " ) NEW_LINE DEDENT
def binToDecimal3 ( n ) : NEW_LINE INDENT last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) NEW_LINE n = n >> 3 NEW_LINE while ( n > 7 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE DEDENT first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) NEW_LINE print ( first_3 , last_3 ) NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
def memoryUsed ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT nearest = nextPowerOf2 ( sum ) NEW_LINE return nearest NEW_LINE DEDENT
def isPowerOfTwo ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( x & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def countNum ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( isPowerOfTwo ( a [ i ] ) or isPowerOfTwo ( a [ i ] + 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def checkEvenParity ( x ) : NEW_LINE INDENT parity = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x & ( x - 1 ) NEW_LINE parity += 1 NEW_LINE DEDENT if ( parity % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def sumlist ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkEvenParity ( a [ i ] ) ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def minDistance ( n1 , n2 ) : NEW_LINE INDENT bitCount1 = int ( log2 ( n1 ) ) + 1 NEW_LINE bitCount2 = int ( log2 ( n2 ) ) + 1 NEW_LINE bitDiff = abs ( bitCount1 - bitCount2 ) NEW_LINE maxBitCount = max ( bitCount1 , bitCount2 ) NEW_LINE if ( bitCount1 > bitCount2 ) : NEW_LINE INDENT n2 = int ( n2 * pow ( 2 , bitDiff ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n1 = int ( n1 * pow ( 2 , bitDiff ) ) NEW_LINE DEDENT xorValue = n1 ^ n2 NEW_LINE if xorValue == 0 : NEW_LINE INDENT bitCountXorValue = 1 NEW_LINE DEDENT else : NEW_LINE INDENT bitCountXorValue = int ( log2 ( xorValue ) ) + 1 NEW_LINE DEDENT disSimilarBitPosition = ( maxBitCount - bitCountXorValue ) NEW_LINE result = ( bitCount1 + bitCount2 - 2 * disSimilarBitPosition ) NEW_LINE return result NEW_LINE DEDENT
def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair += 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT
def countOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT evenPairCount = count * ( count - 1 ) / 2 NEW_LINE totPairs = N * ( N - 1 ) / 2 NEW_LINE return ( int ) ( totPairs - evenPairCount ) NEW_LINE DEDENT
def findevenPair ( A , N ) : NEW_LINE INDENT evenPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] ^ A [ j ] ) % 2 == 0 ) : NEW_LINE INDENT evenPair += 1 NEW_LINE DEDENT DEDENT DEDENT return evenPair NEW_LINE DEDENT
def findEvenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT totalPairs = ( N * ( N - 1 ) / 2 ) NEW_LINE oddEvenPairs = count * ( N - count ) NEW_LINE return ( int ) ( totalPairs - oddEvenPairs ) NEW_LINE DEDENT
def findevenPair ( A , N ) : NEW_LINE INDENT evenPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) : NEW_LINE INDENT evenPair += 1 NEW_LINE DEDENT DEDENT DEDENT return evenPair NEW_LINE DEDENT
def calculate ( X ) : NEW_LINE INDENT number_of_bits = 8 NEW_LINE return ( ( 1 << number_of_bits ) - 1 ) ^ X NEW_LINE DEDENT
def alternate ( a , b , x ) : NEW_LINE INDENT x = a ^ b ^ x NEW_LINE print ( "After exchange" ) NEW_LINE print ( "x is" , x ) NEW_LINE DEDENT
def countZeros ( x ) : NEW_LINE INDENT total_bits = 32 NEW_LINE res = 0 NEW_LINE while ( ( x & ( 1 << ( total_bits - 1 ) ) ) == 0 ) : NEW_LINE INDENT x = ( x << 1 ) NEW_LINE res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countZeros ( x ) : NEW_LINE INDENT n = 32 NEW_LINE y = x >> 16 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 16 NEW_LINE x = y NEW_LINE DEDENT y = x >> 8 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 8 NEW_LINE x = y NEW_LINE DEDENT y = x >> 4 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 4 NEW_LINE x = y NEW_LINE DEDENT y = x >> 2 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 2 NEW_LINE x = y NEW_LINE DEDENT y = x >> 1 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT return n - 2 NEW_LINE DEDENT return n - x NEW_LINE DEDENT
def LeadingZeros ( x , y ) : NEW_LINE INDENT if ( ( x ^ y ) <= ( x & y ) ) : NEW_LINE INDENT print ( "Equal" ) NEW_LINE DEDENT elif ( ( x & ( ~ y ) ) > y ) : NEW_LINE INDENT print ( y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT
def subset ( nthBit , num , numOfBits ) : NEW_LINE INDENT if nthBit >= 0 : NEW_LINE INDENT if num & ( 1 << nthBit ) != 0 : NEW_LINE INDENT print ( numOfBits - nthBit , end = " " ) NEW_LINE DEDENT subset ( nthBit - 1 , num , numOfBits ) NEW_LINE DEDENT else : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT
def solve ( A , B ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT print ( "Number of different bits :" , count ) NEW_LINE DEDENT
def countSubarrWithEqualZeroAndOne ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += ( - 1 if ( arr [ i ] == 0 ) else arr [ i ] ) NEW_LINE if um . get ( curr_sum ) : NEW_LINE INDENT um [ curr_sum ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT um [ curr_sum ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for itr in um : NEW_LINE INDENT if um [ itr ] > 1 : NEW_LINE INDENT count += ( ( um [ itr ] * int ( um [ itr ] - 1 ) ) / 2 ) NEW_LINE DEDENT DEDENT if um . get ( 0 ) : NEW_LINE INDENT count += um [ 0 ] NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT
def setRightmostUnsetBit ( n ) : NEW_LINE INDENT if n & ( n + 1 ) == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT return n | ( n + 1 ) NEW_LINE DEDENT
def OR ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans |= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def hammingDistance ( n1 , n2 ) : NEW_LINE INDENT x = n1 ^ n2 NEW_LINE setBits = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT setBits += x & 1 NEW_LINE x >>= 1 NEW_LINE DEDENT return setBits NEW_LINE DEDENT
def isKthBitSet ( n , k ) : NEW_LINE INDENT if ( ( n >> ( k - 1 ) ) & 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def setKthBit ( n , k ) : NEW_LINE INDENT return ( ( 1 << ( k - 1 ) ) n ) NEW_LINE DEDENT
def allBitsAreSet ( n ) : NEW_LINE INDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def bitsAreInAltOrder ( n ) : NEW_LINE INDENT num = n ^ ( n >> 1 ) NEW_LINE return allBitsAreSet ( num ) NEW_LINE DEDENT
def bitsAreInAltPatrnInGivenRange ( n , l , r ) : NEW_LINE INDENT if ( isKthBitSet ( n , r ) ) : NEW_LINE INDENT num = n NEW_LINE left_shift = r NEW_LINE DEDENT else : NEW_LINE INDENT num = setKthBit ( n , ( r + 1 ) ) NEW_LINE left_shift = r + 1 NEW_LINE DEDENT num = num & ( ( 1 << left_shift ) - 1 ) NEW_LINE num = num >> ( l - 1 ) NEW_LINE return bitsAreInAltOrder ( num ) NEW_LINE DEDENT
def findParity ( x ) : NEW_LINE INDENT y = x ^ ( x >> 1 ) NEW_LINE y = y ^ ( y >> 2 ) NEW_LINE y = y ^ ( y >> 4 ) NEW_LINE y = y ^ ( y >> 8 ) NEW_LINE y = y ^ ( y >> 16 ) NEW_LINE if ( y & 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if incl > excl : NEW_LINE INDENT excl_new = incl NEW_LINE DEDENT else : NEW_LINE INDENT excl_new = excl NEW_LINE DEDENT incl = excl + arr [ i ] NEW_LINE excl = excl_new NEW_LINE DEDENT if incl > excl : NEW_LINE INDENT return incl NEW_LINE DEDENT else : NEW_LINE INDENT return excl NEW_LINE DEDENT DEDENT
def increment ( i ) : NEW_LINE INDENT i = - ( ~ i ) NEW_LINE return i NEW_LINE DEDENT
def increment ( i ) : NEW_LINE INDENT i = - ( ~ ord ( i ) ) NEW_LINE return chr ( i ) NEW_LINE DEDENT
def MakePreSum ( arr , presum , n ) : NEW_LINE INDENT presum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT presum [ i ] = presum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT
def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = { i : 0 for i in range ( 10 ) } NEW_LINE sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT sum += - 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif ( sum not in um ) : NEW_LINE INDENT um [ sum ] = i NEW_LINE DEDENT if ( ( sum - 1 ) in um ) : NEW_LINE INDENT if ( maxLen < ( i - um [ sum - 1 ] ) ) : NEW_LINE INDENT maxLen = i - um [ sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
def bit_count ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def maxsum ( arr , n ) : NEW_LINE INDENT bits = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT bits [ i ] = bit_count ( arr [ i ] ) NEW_LINE DEDENT sum = [ 0 ] * 32 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum [ bits [ i ] ] += arr [ i ] NEW_LINE DEDENT maximum = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT maximum = max ( sum [ i ] , maximum ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE new_num = n & num NEW_LINE if ( num == new_num ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def bitsAreComplement ( a , b , l , r ) : NEW_LINE INDENT xor_value = a ^ b NEW_LINE return allBitsSetInTheGivenRange ( xor_value , l , r ) NEW_LINE DEDENT
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ) NEW_LINE new_num = n & num NEW_LINE if ( new_num == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return false NEW_LINE DEDENT
def checkSame ( n ) : NEW_LINE INDENT set , unset = 0 , 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n and 1 ) : NEW_LINE INDENT set + 1 NEW_LINE DEDENT else : NEW_LINE INDENT unset += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT if ( set == unset ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def isBalanced ( s ) : NEW_LINE INDENT st = list ( ) NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '(' : NEW_LINE INDENT st . append ( s [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( st ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT DEDENT DEDENT if len ( st ) > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def isBalancedSeq ( s1 , s2 ) : NEW_LINE INDENT if ( isBalanced ( s1 + s2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isBalanced ( s2 + s1 ) NEW_LINE DEDENT
def KthCharacter ( m , n , k ) : NEW_LINE INDENT distance = pow ( 2 , n ) NEW_LINE Block_number = int ( k / distance ) NEW_LINE remaining = k % distance NEW_LINE s = [ 0 ] * 32 NEW_LINE x = 0 NEW_LINE while ( m > 0 ) : NEW_LINE INDENT s [ x ] = m % 2 NEW_LINE m = int ( m / 2 ) NEW_LINE x += 1 NEW_LINE DEDENT root = s [ x - 1 - Block_number ] NEW_LINE if ( remaining == 0 ) : NEW_LINE INDENT print ( root ) NEW_LINE return NEW_LINE DEDENT flip = True NEW_LINE while ( remaining > 1 ) : NEW_LINE INDENT if ( remaining & 1 ) : NEW_LINE INDENT flip = not ( flip ) NEW_LINE DEDENT remaining = remaining >> 1 NEW_LINE DEDENT if ( flip ) : NEW_LINE INDENT print ( not ( root ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( root ) NEW_LINE DEDENT DEDENT
def MSBPosition ( N ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( N ) : NEW_LINE INDENT N = N >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT
def findBitwiseOR ( L , R ) : NEW_LINE INDENT res = 0 NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE while ( msb_p1 == msb_p2 ) : NEW_LINE INDENT res_val = ( 1 << msb_p1 ) NEW_LINE res += res_val NEW_LINE L -= res_val NEW_LINE R -= res_val NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE DEDENT msb_p1 = max ( msb_p1 , msb_p2 ) NEW_LINE for i in range ( msb_p1 , - 1 , - 1 ) : NEW_LINE INDENT res_val = ( 1 << i ) NEW_LINE res += res_val NEW_LINE DEDENT return res NEW_LINE DEDENT
def getInteger ( L , R ) : NEW_LINE INDENT number = 0 NEW_LINE for i in range ( L , R + 1 , 1 ) : NEW_LINE INDENT number += pow ( 2 , i ) NEW_LINE DEDENT return number NEW_LINE DEDENT
def maxOR ( arr , n , k , x ) : NEW_LINE INDENT preSum = [ 0 ] * ( n + 1 ) NEW_LINE suffSum = [ 0 ] * ( n + 1 ) NEW_LINE pow = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT pow *= x NEW_LINE DEDENT preSum [ 0 ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT preSum [ i + 1 ] = preSum [ i ] | arr [ i ] NEW_LINE DEDENT suffSum [ n ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res = max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findXor ( arr , n ) : NEW_LINE INDENT xoR = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT xoR = xoR ^ arr [ i ] NEW_LINE DEDENT return xoR * 2 NEW_LINE DEDENT
def turnOnK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n | ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT
def setBitwiseORk ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n + 1 , 1 ) : NEW_LINE INDENT if ( ( i n ) == n ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( v ) , 1 ) : NEW_LINE INDENT print ( v [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT
def smallerNumsWithSameSetBits ( n ) : NEW_LINE INDENT temp = __builtin_popcount ( n ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( temp == __builtin_popcount ( i ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findEletobeInserted ( A , n , k ) : NEW_LINE INDENT ans = k NEW_LINE for i in range ( n ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT
def andSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , BITS ) : NEW_LINE INDENT countSetBits = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT countSetBits = ( countSetBits + 1 ) NEW_LINE DEDENT DEDENT subset = ( ( 1 << countSetBits ) - 1 ) NEW_LINE subset = ( subset * ( 1 << i ) ) NEW_LINE ans = ans + subset NEW_LINE DEDENT return ans NEW_LINE DEDENT
def Root ( idx ) : NEW_LINE INDENT i = idx NEW_LINE while ( i != id [ i ] ) : NEW_LINE INDENT id [ i ] = id [ id [ i ] ] NEW_LINE i = id [ i ] NEW_LINE DEDENT return i NEW_LINE DEDENT
def Union ( a , b ) : NEW_LINE INDENT i = Root ( a ) NEW_LINE j = Root ( b ) NEW_LINE if ( i != j ) : NEW_LINE INDENT if ( sz [ i ] >= sz [ j ] ) : NEW_LINE INDENT id [ j ] = i NEW_LINE sz [ i ] += sz [ j ] NEW_LINE sz [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT id [ i ] = j NEW_LINE sz [ j ] += sz [ i ] NEW_LINE sz [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT
def UnionUtil ( e , W , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT u = e [ i ] . u NEW_LINE DEDENT v = e [ i ] . v NEW_LINE u -= 1 NEW_LINE v -= 1 NEW_LINE if ( W [ u ] % 2 == 0 and W [ v ] % 2 == 0 ) : NEW_LINE INDENT Union ( u , v ) NEW_LINE DEDENT DEDENT
def findMax ( n , W ) : NEW_LINE INDENT maxi = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( W [ i ] % 2 == 0 ) : NEW_LINE INDENT maxi = max ( maxi , sz [ i ] ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def multiplyWith4 ( n ) : NEW_LINE INDENT return ( n << 2 ) NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT isEven = True NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if isEven == True : NEW_LINE INDENT isEven = False NEW_LINE DEDENT else : NEW_LINE INDENT isEven = True NEW_LINE DEDENT DEDENT return isEven NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return ( int ( n / 2 ) * 2 == n ) NEW_LINE DEDENT
def checkValidPair ( num1 , num2 ) : NEW_LINE INDENT s1 = str ( num1 ) NEW_LINE s2 = str ( num2 ) NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT for j in range ( len ( s2 ) ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ j ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT numberOfPairs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( checkValidPair ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT numberOfPairs += 1 NEW_LINE DEDENT DEDENT DEDENT return numberOfPairs NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def isPowerOf2 ( num ) : NEW_LINE INDENT return ( num and ( num & ( num - 1 ) ) == 0 ) NEW_LINE DEDENT
def checkSubsequence ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return isPowerOf2 ( arr [ 0 ] ) NEW_LINE DEDENT total = 0 NEW_LINE for i in range ( 0 , NUM_BITS ) : NEW_LINE INDENT total = total | ( 1 << i ) NEW_LINE DEDENT for i in range ( 0 , NUM_BITS ) : NEW_LINE INDENT ans = total NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT ans = ans & arr [ j ] NEW_LINE DEDENT DEDENT if ( isPowerOf2 ( ans ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def getMid ( s , e ) : NEW_LINE INDENT return s + ( e - s ) // 2 NEW_LINE DEDENT
def constructSTUtil ( arr , ss , se , st , si , operation ) : NEW_LINE INDENT if ( ss == se ) : NEW_LINE INDENT st [ si ] = arr [ ss ] NEW_LINE return NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE constructSTUtil ( arr , ss , mid , st , si * 2 + 1 , not operation ) NEW_LINE constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 , not operation ) NEW_LINE if ( operation == 1 ) : NEW_LINE INDENT st [ si ] = ( st [ 2 * si + 1 ] st [ 2 * si + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT st [ si ] = ( st [ 2 * si + 1 ] ^ st [ 2 * si + 2 ] ) NEW_LINE DEDENT DEDENT
def constructTree ( low , high , pos , a ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT level [ pos ] , tree [ pos ] = 0 , a [ high ] NEW_LINE return NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE constructTree ( low , mid , 2 * pos + 1 , a ) NEW_LINE constructTree ( mid + 1 , high , 2 * pos + 2 , a ) NEW_LINE level [ pos ] = level [ 2 * pos + 1 ] + 1 NEW_LINE if level [ pos ] & 1 : NEW_LINE INDENT tree [ pos ] = tree [ 2 * pos + 1 ] | tree [ 2 * pos + 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT tree [ pos ] = tree [ 2 * pos + 1 ] ^ tree [ 2 * pos + 2 ] NEW_LINE DEDENT DEDENT
def update ( low , high , pos , index , a ) : NEW_LINE INDENT if low == high and low == index : NEW_LINE INDENT tree [ pos ] = a [ low ] NEW_LINE return NEW_LINE DEDENT if index < low or index > high : NEW_LINE INDENT return NEW_LINE DEDENT if low != high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE update ( low , mid , 2 * pos + 1 , index , a ) NEW_LINE update ( mid + 1 , high , 2 * pos + 2 , index , a ) NEW_LINE if level [ pos ] & 1 : NEW_LINE INDENT tree [ pos ] = tree [ 2 * pos + 1 ] | tree [ 2 * pos + 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT tree [ pos ] = tree [ 2 * pos + 1 ] ^ tree [ 2 * pos + 2 ] NEW_LINE DEDENT DEDENT DEDENT
def updateValue ( index , value , a , n ) : NEW_LINE INDENT a [ index ] = value NEW_LINE update ( 0 , n - 1 , 0 , index , a ) NEW_LINE DEDENT
def maxXOR ( n , k ) : NEW_LINE INDENT c = int ( math . log ( n , 2 ) ) + 1 NEW_LINE return ( ( 1 << c ) - 1 ) NEW_LINE DEDENT
def divide ( dividend , divisor ) : NEW_LINE INDENT sign = ( - 1 if ( ( dividend < 0 ) ^ ( divisor < 0 ) ) else 1 ) NEW_LINE dividend = abs ( dividend ) NEW_LINE divisor = abs ( divisor ) NEW_LINE quotient = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if ( temp + ( divisor << i ) <= dividend ) : NEW_LINE INDENT temp += divisor << i NEW_LINE quotient |= 1 << i NEW_LINE DEDENT DEDENT if sign == - 1 : NEW_LINE INDENT quotient = - quotient NEW_LINE DEDENT return quotient NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT c += 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
def swapBitsInPair ( x ) : NEW_LINE INDENT return ( ( x & 0b10101010 ) >> 1 ) or ( ( x & 0b01010101 ) << 1 ) NEW_LINE DEDENT
def evenbitsetnumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE res = 0 NEW_LINE temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( count % 2 == 1 ) : NEW_LINE INDENT res |= ( 1 << count ) NEW_LINE DEDENT count += 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return ( n res ) NEW_LINE DEDENT
def getmsb ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return ( n + 1 ) >> 1 NEW_LINE DEDENT
def getevenbits ( n ) : NEW_LINE INDENT n = getmsb ( n ) NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE DEDENT return n NEW_LINE DEDENT
def setallevenbits ( n ) : NEW_LINE INDENT return n | getevenbits ( n ) NEW_LINE DEDENT
def getmsb ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return ( n + 1 ) >> 1 NEW_LINE DEDENT
def getevenbits ( n ) : NEW_LINE INDENT n = getmsb ( n ) NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE DEDENT return n NEW_LINE DEDENT
def setalloddbits ( n ) : NEW_LINE INDENT return n | getevenbits ( n ) NEW_LINE DEDENT
def setevenbits ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE res = 0 NEW_LINE while temp > 0 : NEW_LINE INDENT if count % 2 : NEW_LINE INDENT res |= ( 1 << count ) NEW_LINE DEDENT count += 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return ( n & res ) NEW_LINE DEDENT
def setoddbits ( m ) : NEW_LINE INDENT temp = m NEW_LINE count = 0 NEW_LINE res = 0 NEW_LINE while temp > 0 : NEW_LINE INDENT if not count % 2 : NEW_LINE INDENT res |= ( 1 << count ) NEW_LINE DEDENT count += 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return ( m & res ) NEW_LINE DEDENT
def getAlternateBits ( n , m ) : NEW_LINE INDENT tempn = setevenbits ( n ) NEW_LINE tempm = setoddbits ( m ) NEW_LINE return ( tempn tempm ) NEW_LINE DEDENT
def takeLandFsetbits ( n ) : NEW_LINE INDENT n = n | n >> 1 NEW_LINE n = n | n >> 2 NEW_LINE n = n | n >> 4 NEW_LINE n = n | n >> 8 NEW_LINE n = n | n >> 16 NEW_LINE return ( ( n + 1 ) >> 1 ) + 1 NEW_LINE DEDENT
def toggleFandLbits ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return n ^ takeLandFsetbits ( n ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n = n & ( n - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def checkOdious ( n ) : NEW_LINE INDENT return ( countSetBits ( n ) % 2 == 1 ) NEW_LINE DEDENT
def setleftmostunsetbit ( n ) : NEW_LINE INDENT if not ( n & ( n + 1 ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT pos , temp , count = 0 , n , 0 NEW_LINE while temp : NEW_LINE INDENT if not ( temp & 1 ) : NEW_LINE INDENT pos = count NEW_LINE DEDENT count += 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return ( n | ( 1 << ( pos ) ) ) NEW_LINE DEDENT
def getPosOfRightmostSetBit ( n ) : NEW_LINE INDENT return math . log2 ( n & - n ) NEW_LINE DEDENT
def toggleLastKBits ( n , k ) : NEW_LINE INDENT num = ( 1 << ( int ) ( k ) ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT
def incrementByOne ( n ) : NEW_LINE INDENT k = getPosOfRightmostSetBit ( ~ n ) NEW_LINE n = ( ( 1 << ( int ) ( k ) ) n ) NEW_LINE if ( k != 0 ) : NEW_LINE INDENT n = toggleLastKBits ( n , k ) NEW_LINE DEDENT return n NEW_LINE DEDENT
def printNumHavingAltBitPatrn ( n ) : NEW_LINE INDENT curr_num = 1 NEW_LINE print ( curr_num ) NEW_LINE while ( 1 ) : NEW_LINE INDENT curr_num = curr_num << 1 NEW_LINE if ( n < curr_num ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( curr_num ) NEW_LINE curr_num = ( ( curr_num ) << 1 ) ^ 1 NEW_LINE if ( n < curr_num ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( curr_num ) NEW_LINE DEDENT DEDENT
def xnor ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT swap ( a , b ) NEW_LINE DEDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT a_rem = 0 NEW_LINE b_rem = 0 NEW_LINE count = 0 NEW_LINE xnornum = 0 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT a_rem = a & 1 NEW_LINE b_rem = b & 1 NEW_LINE if ( a_rem == b_rem ) : NEW_LINE INDENT xnornum |= ( 1 << count ) NEW_LINE DEDENT count = count + 1 NEW_LINE a = a >> 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return xnornum NEW_LINE DEDENT
def togglebit ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT i = n NEW_LINE n = n | ( n >> 1 ) NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return i ^ n NEW_LINE DEDENT
def MaximumSum ( a , b , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 |= a [ i ] NEW_LINE sum2 |= b [ i ] NEW_LINE DEDENT print ( sum1 + sum2 ) NEW_LINE DEDENT
def posOfCarryBit ( a , b ) : NEW_LINE INDENT return posOfRightmostSetBit ( a & b ) NEW_LINE DEDENT
def isPowerOfTwo ( x ) : NEW_LINE INDENT return x and ( not ( x & ( x - 1 ) ) ) NEW_LINE DEDENT
def differAtOneBitPos ( a , b ) : NEW_LINE INDENT return isPowerOfTwo ( a ^ b ) NEW_LINE DEDENT
def power2 ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return power2 ( n / 2 ) * power2 ( n / 2 ) NEW_LINE DEDENT
def multiply ( x , n ) : NEW_LINE INDENT return x * power2 ( n ) NEW_LINE DEDENT
def multiply ( x , n ) : NEW_LINE INDENT return x << n NEW_LINE DEDENT
def isDivBy2PowerM ( n , m ) : NEW_LINE INDENT if ( n & ( ( 1 << m ) - 1 ) ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findWinner ( N ) : NEW_LINE INDENT return N & 1 NEW_LINE DEDENT
def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ 0 ] * N NEW_LINE prefeven = [ 0 ] * N NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i ) % 2 == 0 ) : NEW_LINE INDENT prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT prefeven [ i ] = prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i != q ) : NEW_LINE INDENT ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def countgroup ( a , n ) : NEW_LINE INDENT xs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xs = xs ^ a [ i ] NEW_LINE DEDENT if xs == 0 : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def perfectPowerOf2 ( n ) : NEW_LINE INDENT per_pow = 1 NEW_LINE while n > 0 : NEW_LINE INDENT per_pow = per_pow << 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return per_pow NEW_LINE DEDENT
def solve ( p , n ) : NEW_LINE INDENT G = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] % 2 != 0 ) : NEW_LINE INDENT G ^= ( p [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT G ^= ( p [ i ] - 1 ) NEW_LINE DEDENT DEDENT return G NEW_LINE DEDENT
def isDivisibleby17 ( n ) : NEW_LINE INDENT if ( n == 0 or n == 17 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n < 17 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) NEW_LINE DEDENT
def answer ( n ) : NEW_LINE INDENT m = 2 NEW_LINE ans = 1 NEW_LINE r = 1 NEW_LINE while r < n : NEW_LINE INDENT r = ( int ) ( ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ) NEW_LINE if r < n : NEW_LINE INDENT ans = r NEW_LINE DEDENT m = m + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxAND ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT res = max ( res , arr [ i ] & arr [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def checkBit ( pattern , arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( pattern & arr [ i ] ) == pattern ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def index ( i ) : NEW_LINE INDENT return 1 + ( i >> 31 ) - ( - i >> 31 ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for it in mp : NEW_LINE INDENT count = mp [ it ] NEW_LINE ans += ( count * ( count - 1 ) ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countones ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n & ( n - 1 ) NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
def checking ( s ) : NEW_LINE INDENT c = 0 NEW_LINE n = len ( s ) NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( c >= 6 and s [ i ] == '1' ) : NEW_LINE INDENT return True NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def countSetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return countSetBits ( n & num ) NEW_LINE DEDENT
def areAllBitsSet ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findUnique ( a , n , k ) : NEW_LINE INDENT INT_SIZE = 8 * sys . getsizeof ( int ) NEW_LINE count = [ 0 ] * INT_SIZE NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( a [ j ] & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT res = 0 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT res += ( count [ i ] % k ) * ( 1 << i ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def powerOfTwo ( n ) : NEW_LINE INDENT return ( not ( n & n - 1 ) ) NEW_LINE DEDENT
def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return powerOfTwo ( n - 1 ) NEW_LINE DEDENT
def allBitsAreSet ( n ) : NEW_LINE INDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def bitsAreInAltOrder ( n ) : NEW_LINE INDENT num = n ^ ( n >> 1 ) NEW_LINE return allBitsAreSet ( num ) NEW_LINE DEDENT
def setBit ( xorValue ) : NEW_LINE INDENT count = 0 NEW_LINE while ( xorValue ) : NEW_LINE INDENT if ( xorValue % 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT xorValue = int ( xorValue / 2 ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def minFlip ( n , k ) : NEW_LINE INDENT size = int ( math . log ( n ) / math . log ( 2 ) + 1 ) NEW_LINE max = pow ( 2 , k ) - 1 NEW_LINE max = max << ( size - k ) NEW_LINE xorValue = ( n ^ max ) NEW_LINE return ( setBit ( xorValue ) ) NEW_LINE DEDENT
def setallbitgivenrange ( n , l , r ) : NEW_LINE INDENT range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) NEW_LINE return ( n range ) NEW_LINE DEDENT
def countBits ( number ) : NEW_LINE INDENT return int ( ( math . log ( number ) / math . log ( 2 ) ) + 1 ) NEW_LINE DEDENT
def setBitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT msb = 0 NEW_LINE n = int ( n / 2 ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE msb += 1 NEW_LINE DEDENT return ( 1 << msb ) NEW_LINE DEDENT
def setAllBitsAfterMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return n NEW_LINE DEDENT
def toggle ( n ) : NEW_LINE INDENT n = n ^ setAllBitsAfterMSB ( n ) NEW_LINE return n NEW_LINE DEDENT
def checkPowerof8 ( n ) : NEW_LINE INDENT i = log ( n , 8 ) NEW_LINE return ( i - trunc ( i ) < 0.000001 ) NEW_LINE DEDENT
def adjacentSet ( n ) : NEW_LINE INDENT return ( n & ( n >> 1 ) ) NEW_LINE DEDENT
def getRightMostSetBit ( n ) : NEW_LINE INDENT return int ( math . log2 ( n & - n ) ) + 1 NEW_LINE DEDENT
def posOfRightMostSameBit ( m , n ) : NEW_LINE INDENT return getRightMostSetBit ( ~ ( m ^ n ) ) NEW_LINE DEDENT
def printNonConsecutive ( n ) : NEW_LINE INDENT p = ( 1 << n ) NEW_LINE for i in range ( 1 , p ) : NEW_LINE INDENT if ( ( i & ( i << 1 ) ) == 0 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def isKthBitSet ( x , k ) : NEW_LINE INDENT return 1 if ( x & ( 1 << ( k - 1 ) ) ) else 0 NEW_LINE DEDENT
def leftmostSetBit ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x ) : NEW_LINE INDENT count += 1 NEW_LINE x = x >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def isBinPalindrome ( x ) : NEW_LINE INDENT l = leftmostSetBit ( x ) NEW_LINE r = 1 NEW_LINE while ( l > r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def findNthPalindrome ( n ) : NEW_LINE INDENT pal_count = 0 NEW_LINE i = 0 NEW_LINE for i in range ( 1 , INT_MAX + 1 ) : NEW_LINE INDENT if ( isBinPalindrome ( i ) ) : NEW_LINE INDENT pal_count += 1 NEW_LINE DEDENT if ( pal_count == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT
def convertStringToInt ( s ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ans = ans * 2 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def getNthNumber ( n ) : NEW_LINE INDENT q = [ ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT n = n - 1 NEW_LINE q . append ( "11" ) NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT curr = q . pop ( 0 ) NEW_LINE n -= 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return convertStringToInt ( curr ) NEW_LINE DEDENT lenn = len ( curr ) NEW_LINE if ( len ( curr ) % 2 == 0 ) : NEW_LINE INDENT q . append ( curr [ 0 : int ( lenn / 2 ) ] + "0" + curr [ int ( lenn / 2 ) : ] ) NEW_LINE q . append ( curr [ 0 : int ( lenn / 2 ) ] + "1" + curr [ int ( lenn / 2 ) : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT midChar = curr [ int ( lenn / 2 ) ] NEW_LINE q . append ( curr [ 0 : int ( lenn / 2 ) ] + midChar + curr [ int ( lenn / 2 ) : ] ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def constructNthNumber ( group_no , aux_num , op ) : NEW_LINE INDENT a = [ 0 ] * INT_SIZE NEW_LINE num , i = 0 , 0 NEW_LINE if op == 2 : NEW_LINE INDENT len_f = 2 * group_no NEW_LINE a [ len_f - 1 ] = a [ 0 ] = 1 NEW_LINE while aux_num : NEW_LINE INDENT a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 NEW_LINE aux_num = aux_num >> 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif op == 0 : NEW_LINE INDENT len_f = 2 * group_no + 1 NEW_LINE a [ len_f - 1 ] = a [ 0 ] = 1 NEW_LINE a [ group_no ] = 0 NEW_LINE while aux_num : NEW_LINE INDENT a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 NEW_LINE aux_num = aux_num >> 1 NEW_LINE i += 1 NEW_LINE DEDENT len_f = 2 * group_no + 1 NEW_LINE a [ len_f - 1 ] = a [ 0 ] = 1 NEW_LINE a [ group_no ] = 1 NEW_LINE while aux_num : NEW_LINE INDENT a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 NEW_LINE aux_num = aux_num >> 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , len_f ) : NEW_LINE INDENT num += ( 1 << i ) * a [ i ] NEW_LINE DEDENT return num NEW_LINE DEDENT
def getNthNumber ( n ) : NEW_LINE INDENT group_no = 0 NEW_LINE count_upto_group , count_temp = 0 , 1 NEW_LINE while count_temp < n : NEW_LINE INDENT group_no += 1 NEW_LINE count_upto_group = count_temp NEW_LINE count_temp += 3 * ( 1 << ( group_no - 1 ) ) NEW_LINE DEDENT group_offset = n - count_upto_group - 1 NEW_LINE if ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) : NEW_LINE INDENT aux_num = group_offset NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 ) : NEW_LINE INDENT else : aux_num = ( ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) // 2 ) NEW_LINE DEDENT return constructNthNumber ( group_no , aux_num , op ) NEW_LINE DEDENT DEDENT
def shuffle ( N , key ) : NEW_LINE INDENT NO_OF_BITS = N NEW_LINE reverse_num = 0 NEW_LINE for i in range ( NO_OF_BITS ) : NEW_LINE INDENT temp = ( key & ( 1 << i ) ) NEW_LINE if ( temp ) : NEW_LINE INDENT reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) NEW_LINE DEDENT DEDENT print ( reverse_num ) NEW_LINE DEDENT
def bitExtracted ( number , k , p ) : NEW_LINE INDENT return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) NEW_LINE DEDENT
def areSame ( a , b ) : NEW_LINE INDENT if ( not ( a - b ) ) : NEW_LINE INDENT print "Same" NEW_LINE DEDENT else : NEW_LINE INDENT print "Not Same" NEW_LINE DEDENT DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n = n & ( n - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( countSetBits ( i ) == 2 ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while ( ( 1 << i ) < n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT num = ( 1 << i ) + ( 1 << j ) NEW_LINE if ( num <= n ) : NEW_LINE INDENT sum += num NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findMax ( num ) : NEW_LINE INDENT num_copy = num NEW_LINE j = 4 * 8 - 1 NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT m = ( num_copy >> i ) & 1 NEW_LINE n = ( num_copy >> j ) & 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT x = ( 1 << i 1 << j ) NEW_LINE num = num ^ x NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT
def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT
def getPosOfRightmostSetBit ( n ) : NEW_LINE INDENT return int ( math . log2 ( n & - n ) + 1 ) NEW_LINE DEDENT
def setRightmostUnsetBit ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( ( n & ( n + 1 ) ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT pos = getPosOfRightmostSetBit ( ~ n ) NEW_LINE return ( ( 1 << ( pos - 1 ) ) n ) NEW_LINE DEDENT
def previousSmallerInteger ( n ) : NEW_LINE INDENT pos = getFirstSetBitPos ( n ) NEW_LINE return ( n & ~ ( 1 << ( pos - 1 ) ) ) NEW_LINE DEDENT
def getRightMostSetBit ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return math . log2 ( n & - n ) + 1 NEW_LINE DEDENT
def posOfRightMostDiffBit ( m , n ) : NEW_LINE INDENT return getRightMostSetBit ( m ^ n ) NEW_LINE DEDENT
def posOfRightMostDiffBit ( m , n ) : NEW_LINE INDENT return floor ( log10 ( pow ( m ^ n , 2 ) ) ) + 2 NEW_LINE DEDENT
def getFirstSetBitPos ( n ) : NEW_LINE INDENT return ( ( int ) ( math . log ( n & - n ) / math . log ( 2 ) ) + 1 ) - 1 NEW_LINE DEDENT
def nextGreaterWithOneMoreSetBit ( n ) : NEW_LINE INDENT pos = getFirstSetBitPos ( ~ n ) NEW_LINE if ( pos > - 1 ) : NEW_LINE INDENT return ( 1 << pos ) | n NEW_LINE DEDENT return ( ( n << 1 ) + 1 ) NEW_LINE DEDENT
def setKthBit ( n , k ) : NEW_LINE INDENT return ( ( 1 << k ) n ) NEW_LINE DEDENT
def getNext ( n ) : NEW_LINE INDENT c = n NEW_LINE c0 = 0 NEW_LINE c1 = 0 NEW_LINE while ( ( ( c & 1 ) == 0 ) and ( c != 0 ) ) : NEW_LINE INDENT c0 = c0 + 1 NEW_LINE c >>= 1 NEW_LINE DEDENT while ( ( c & 1 ) == 1 ) : NEW_LINE INDENT c1 = c1 + 1 NEW_LINE c >>= 1 NEW_LINE DEDENT if ( c0 + c1 == 31 or c0 + c1 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return n + ( 1 << c0 ) + ( 1 << ( c1 - 1 ) ) - 1 NEW_LINE DEDENT
def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n // 2 ) : NEW_LINE INDENT arr [ i ] , arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] = arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT
def countNum ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE if ( arr [ i ] < minm ) : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] > maxm ) : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if i not in s . keys ( ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def CountXORandSumEqual ( x ) : NEW_LINE INDENT count = CountZeroBit ( x ) NEW_LINE return ( 1 << count ) NEW_LINE DEDENT
def maxXORInRange ( L , R ) : NEW_LINE INDENT LXR = L ^ R NEW_LINE msbPos = 0 NEW_LINE while ( LXR ) : NEW_LINE INDENT msbPos += 1 NEW_LINE LXR >>= 1 NEW_LINE DEDENT maxXOR , two = 0 , 1 NEW_LINE while ( msbPos ) : NEW_LINE INDENT maxXOR += two NEW_LINE two <<= 1 NEW_LINE msbPos -= 1 NEW_LINE DEDENT return maxXOR NEW_LINE DEDENT
def missingNumber ( arr1 , arr2 , n ) : NEW_LINE INDENT mnum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mnum = mnum ^ arr1 [ i ] NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT mnum = mnum ^ arr2 [ i ] NEW_LINE DEDENT return mnum NEW_LINE DEDENT
def CountORandSumEqual ( N ) : NEW_LINE INDENT count = CountZeroBit ( N ) NEW_LINE return ( 1 << count ) NEW_LINE DEDENT
def toggleKthBit ( n , k ) : NEW_LINE INDENT return ( n ^ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT
def countValues ( x ) : NEW_LINE INDENT count = 0 NEW_LINE n = 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 2 == 0 ) : NEW_LINE INDENT count += n NEW_LINE DEDENT n *= 2 NEW_LINE x /= 2 NEW_LINE x = int ( x ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def constructXOR ( A , n ) : NEW_LINE INDENT XOR = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT XOR ^= A [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT A [ i ] = XOR ^ A [ i ] NEW_LINE DEDENT DEDENT
def kBitDifferencePairs ( arr , n , k ) : NEW_LINE INDENT MAX = max ( arr ) NEW_LINE count = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT ans += ( count [ i ] * ( count [ i ] - 1 ) ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT if ( count [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i + 1 , MAX + 1 ) : NEW_LINE INDENT if ( bin ( i ^ j ) . count ( '1' ) == k ) : NEW_LINE INDENT ans += count [ i ] * count [ j ] NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def multiply ( F , M ) : NEW_LINE INDENT x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE DEDENT
def power ( F , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE power ( F , n // 2 ) NEW_LINE multiply ( F , F ) NEW_LINE if ( n % 2 != 0 ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT DEDENT
def countWays ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT
def countTrailingZero ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( ( x & 1 ) == 0 ) : NEW_LINE INDENT x = x >> 1 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def totalFlips ( A , B , C , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] == B [ i ] and C [ i ] == '1' : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT elif A [ i ] != B [ i ] and C [ i ] == '0' : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT k = 0 NEW_LINE count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT count += pow ( 2 , k ) NEW_LINE DEDENT k += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def multiply ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE count = 0 NEW_LINE while ( m ) : NEW_LINE INDENT if ( m % 2 == 1 ) : NEW_LINE INDENT ans += n << count NEW_LINE DEDENT count += 1 NEW_LINE m = int ( m / 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def EqualNumber ( A , B ) : NEW_LINE INDENT return ( A ^ B ) NEW_LINE DEDENT
def countXOR ( n ) : NEW_LINE INDENT count0 , count1 = 0 , 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT n //= 2 NEW_LINE DEDENT return ( count0 ^ count1 ) NEW_LINE DEDENT
def xorPairCount ( arr , n , x ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( x ^ arr [ i ] in s ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def xorPairCount ( arr , n , x ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_xor = x ^ arr [ i ] NEW_LINE if ( curr_xor in m . keys ( ) ) : NEW_LINE INDENT result += m [ curr_xor ] NEW_LINE DEDENT if arr [ i ] in m . keys ( ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def msbPos ( n ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT
def andOperator ( x , y ) : NEW_LINE INDENT while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p1 = msbPos ( x ) NEW_LINE msb_p2 = msbPos ( y ) NEW_LINE if ( msb_p1 != msb_p2 ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_val = ( 1 << msb_p1 ) NEW_LINE res = res + msb_val NEW_LINE x = x - msb_val NEW_LINE y = y - msb_val NEW_LINE DEDENT return res NEW_LINE DEDENT
def multiplyTen ( n ) : NEW_LINE INDENT return ( n << 1 ) + ( n << 3 ) NEW_LINE DEDENT
def countValues ( n ) : NEW_LINE INDENT countV = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( ( n + i ) == ( n ^ i ) ) : NEW_LINE INDENT countV += 1 NEW_LINE DEDENT DEDENT return countV NEW_LINE DEDENT
def countValues ( n ) : NEW_LINE INDENT unset_bits = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if n & 1 == 0 : NEW_LINE INDENT unset_bits += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return 1 << unset_bits NEW_LINE DEDENT
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT difference = difference + 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference = difference - 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] = hash_negative [ - difference ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] = hash_positive [ difference ] + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def printTwoSetBitNums ( n ) : NEW_LINE INDENT x = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT print ( ( 1 << x ) + ( 1 << y ) , end = " " ) NEW_LINE n -= 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT
def printRepeatingEven ( arr , n ) : NEW_LINE INDENT axor = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT pos = 1 << arr [ i ] NEW_LINE axor ^= pos NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT pos = 1 << arr [ i ] NEW_LINE if ( not ( pos & axor ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE axor ^= pos NEW_LINE DEDENT DEDENT DEDENT
def countSetBits ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x = x & ( x - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def isBleak ( n ) : NEW_LINE INDENT for x in range ( 1 , n ) : NEW_LINE INDENT if ( x + countSetBits ( x ) == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def diameter ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT global ans , lh , rh NEW_LINE global f , k , pathLen NEW_LINE height_of_tree = height ( root ) NEW_LINE lPath = [ 0 for i in range ( 100 ) ] NEW_LINE printPathsRecur ( k . left , lPath , lh , 0 ) NEW_LINE print ( k . data , end = " " ) NEW_LINE rPath = [ 0 for i in range ( 100 ) ] NEW_LINE f = 1 NEW_LINE printPathsRecur ( k . right , rPath , rh , 0 ) NEW_LINE DEDENT
def countSetBits ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x = x & ( x - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def ceilLog2 ( x ) : NEW_LINE INDENT count = 0 NEW_LINE x = x - 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT x = x >> 1 NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def isBleak ( n ) : NEW_LINE INDENT for x in range ( ( n - ceilLog2 ( n ) ) , n ) : NEW_LINE INDENT if ( x + countSetBits ( x ) == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countStrings ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE b = [ 0 ] * n NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] NEW_LINE DEDENT
def myXOR ( x , y ) : NEW_LINE INDENT for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT b1 = x & ( 1 << i ) NEW_LINE b2 = y & ( 1 << i ) NEW_LINE b1 = min ( b1 , 1 ) NEW_LINE b2 = min ( b2 , 1 ) NEW_LINE xoredBit = 0 NEW_LINE if ( b1 & b2 ) : NEW_LINE INDENT xoredBit = 0 NEW_LINE DEDENT else : NEW_LINE INDENT xoredBit = ( b1 b2 ) NEW_LINE DEDENT res <<= 1 NEW_LINE res |= xoredBit NEW_LINE DEDENT return res NEW_LINE DEDENT
def myXOR ( x , y ) : NEW_LINE INDENT return ( ( x y ) & ( ~ x ~ y ) ) NEW_LINE DEDENT
def myXOR ( x , y ) : NEW_LINE INDENT return ( x & ( ~ y ) ) | ( ( ~ x ) & y ) NEW_LINE DEDENT
def swapBits ( n , p1 , p2 ) : NEW_LINE INDENT n ^= 1 << p1 NEW_LINE n ^= 1 << p2 NEW_LINE return n NEW_LINE DEDENT
def multiplyBySevenByEight ( n ) : NEW_LINE INDENT return ( n - ( n >> 3 ) ) NEW_LINE DEDENT
def subtract ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT borrow = ( ~ x ) & y NEW_LINE x = x ^ y NEW_LINE y = borrow << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
def subtract ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return x NEW_LINE DEDENT return subtract ( x ^ y , ( ~ x & y ) << 1 ) NEW_LINE DEDENT
def square ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT res = n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res += n NEW_LINE DEDENT return res NEW_LINE DEDENT
def temp_convert ( F1 , B1 , F2 , B2 , T ) : NEW_LINE INDENT t2 = F2 + ( ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ) NEW_LINE return t2 NEW_LINE DEDENT
def Divisible ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT DEDENT return count_even + ( n - count_even ) // 2 NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT
def maxLength ( arr , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE i = 0 NEW_LINE j = i + 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ j ] ) : NEW_LINE INDENT maxLen = max ( maxLen , 2 ) NEW_LINE l = i - 1 NEW_LINE r = j + 1 NEW_LINE while ( l >= 0 and r < n and arr [ l ] == arr [ i ] and arr [ r ] == arr [ j ] ) : NEW_LINE INDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT maxLen = max ( maxLen , 2 * ( r - j ) ) NEW_LINE DEDENT i += 1 NEW_LINE j = i + 1 NEW_LINE DEDENT return maxLen NEW_LINE DEDENT
def maxLength ( a , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE prev_cnt = 0 NEW_LINE curr_cnt = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] ) : NEW_LINE INDENT curr_cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT prev_cnt = curr_cnt NEW_LINE curr_cnt = 1 NEW_LINE DEDENT maxLen = max ( maxLen , min ( prev_cnt , curr_cnt ) ) NEW_LINE DEDENT return ( 2 * maxLen ) NEW_LINE DEDENT
def freivald ( a , b , c ) : NEW_LINE INDENT r = [ 0 ] * N NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT r [ i ] = ( int ) ( random . randrange ( 509090009 ) % 2 ) NEW_LINE DEDENT br = [ 0 ] * N NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT br [ i ] = br [ i ] + b [ i ] [ j ] * r [ j ] NEW_LINE DEDENT DEDENT cr = [ 0 ] * N NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT cr [ i ] = cr [ i ] + c [ i ] [ j ] * r [ j ] NEW_LINE DEDENT DEDENT axbr = [ 0 ] * N NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT axbr [ i ] = axbr [ i ] + a [ i ] [ j ] * br [ j ] NEW_LINE DEDENT DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT if ( axbr [ i ] - cr [ i ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isProduct ( a , b , c , k ) : NEW_LINE INDENT for i in range ( 0 , k ) : NEW_LINE INDENT if ( freivald ( a , b , c ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def children ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT return root . children + 1 NEW_LINE DEDENT
def randomNodeUtil ( root , count ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT if count == children ( root . left ) : NEW_LINE INDENT return root . data NEW_LINE DEDENT if count < children ( root . left ) : NEW_LINE INDENT return randomNodeUtil ( root . left , count ) NEW_LINE DEDENT return randomNodeUtil ( root . right , count - children ( root . left ) - 1 ) NEW_LINE DEDENT
def randomNode ( root ) : NEW_LINE INDENT count = randint ( 0 , root . children ) NEW_LINE return randomNodeUtil ( root , count ) NEW_LINE DEDENT
def calc_Expectation ( a , n ) : NEW_LINE INDENT prb = 1 / n NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += ( a [ i ] * prb ) NEW_LINE DEDENT return float ( sum ) NEW_LINE DEDENT
def findLargestd ( S , n ) : NEW_LINE INDENT found = False NEW_LINE S . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT continue NEW_LINE DEDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( i == l ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : NEW_LINE INDENT found = True NEW_LINE return S [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def recaman ( n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE arr [ 0 ] = 0 NEW_LINE print ( arr [ 0 ] , end = ", " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = arr [ i - 1 ] - i NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ j ] == curr ) or curr < 0 ) : NEW_LINE INDENT curr = arr [ i - 1 ] + i NEW_LINE break NEW_LINE DEDENT DEDENT arr [ i ] = curr NEW_LINE print ( arr [ i ] , end = ", " ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if sumOfDiv ( arr [ i ] ) in s : NEW_LINE INDENT sum = sumOfDiv ( arr [ i ] ) NEW_LINE if isAmbicle ( arr [ i ] , sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( count / 2 ) NEW_LINE DEDENT
def findArea ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE dimension = [ 0 , 0 ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n - 1 and j < 2 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT dimension [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( dimension [ 0 ] * dimension [ 1 ] ) NEW_LINE DEDENT
def findArea ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . append ( arr [ i ] ) NEW_LINE continue NEW_LINE DEDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT return ( first * second ) NEW_LINE DEDENT
def printAllPaths ( root ) : NEW_LINE INDENT global Allpaths NEW_LINE if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT printAllPathsUtil ( root , 0 , 0 ) NEW_LINE DEDENT
def longLenStrictBitonicSub ( arr , n ) : NEW_LINE INDENT inc , dcr = dict ( ) , dict ( ) NEW_LINE len_inc , len_dcr = [ 0 ] * n , [ 0 ] * n NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len = 0 NEW_LINE if inc . get ( arr [ i ] - 1 ) in inc . values ( ) : NEW_LINE INDENT len = inc . get ( arr [ i ] - 1 ) NEW_LINE DEDENT inc [ arr [ i ] ] = len_inc [ i ] = len + 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT len = 0 NEW_LINE if dcr . get ( arr [ i ] - 1 ) in dcr . values ( ) : NEW_LINE INDENT len = dcr . get ( arr [ i ] - 1 ) NEW_LINE DEDENT dcr [ arr [ i ] ] = len_dcr [ i ] = len + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) : NEW_LINE INDENT longLen = len_inc [ i ] + len_dcr [ i ] - 1 NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT
def leftRotatebyOne ( arr , n ) : NEW_LINE INDENT temp = arr [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = temp NEW_LINE DEDENT
def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( "% d" % arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def search ( arr , l , h , key ) : NEW_LINE INDENT if l > h : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) // 2 NEW_LINE if arr [ mid ] == key : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ l ] <= arr [ mid ] : NEW_LINE INDENT if key >= arr [ l ] and key <= arr [ mid ] : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if key >= arr [ mid ] and key <= arr [ h ] : NEW_LINE INDENT return search ( a , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT
def pairInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE while ( l != r ) : NEW_LINE INDENT if ( arr [ l ] + arr [ r ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] < x ) : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def pairsInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE cnt = 0 NEW_LINE while ( l != r ) : NEW_LINE INDENT if arr [ l ] + arr [ r ] == x : NEW_LINE INDENT cnt += 1 NEW_LINE if l == ( r - 1 + n ) % n : NEW_LINE INDENT return cnt NEW_LINE DEDENT l = ( l + 1 ) % n NEW_LINE r = ( r - 1 + n ) % n NEW_LINE DEDENT elif arr [ l ] + arr [ r ] < x : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT index = int ( ( i + j ) % n ) NEW_LINE curr_sum += j * arr [ index ] NEW_LINE DEDENT res = max ( res , curr_sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT cum_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cum_sum += arr [ i ] NEW_LINE DEDENT curr_val = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_val += i * arr [ i ] NEW_LINE DEDENT res = curr_val NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ) NEW_LINE curr_val = next_val NEW_LINE res = max ( res , next_val ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countRotations ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT return min_index NEW_LINE DEDENT
def countRotations ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) / 2 NEW_LINE mid = int ( mid ) NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) NEW_LINE DEDENT return countRotations ( arr , mid + 1 , high ) NEW_LINE DEDENT
def leftRotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( str ( arr [ i % n ] ) , end = " " ) NEW_LINE DEDENT DEDENT
def findMin ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if high == low : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if mid < high and arr [ mid + 1 ] < arr [ mid ] : NEW_LINE INDENT return arr [ mid + 1 ] NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return findMin ( arr , low , mid - 1 ) NEW_LINE DEDENT return findMin ( arr , mid + 1 , high ) NEW_LINE DEDENT
def reverseArray ( arr , start , end ) : NEW_LINE INDENT while ( start < end ) : NEW_LINE INDENT arr [ start ] , arr [ end ] = arr [ end ] , arr [ start ] NEW_LINE start = start + 1 NEW_LINE end = end - 1 NEW_LINE DEDENT DEDENT
def rightRotate ( arr , d , n ) : NEW_LINE INDENT reverseArray ( arr , 0 , n - 1 ) NEW_LINE reverseArray ( arr , 0 , d - 1 ) NEW_LINE reverseArray ( arr , d , n - 1 ) NEW_LINE DEDENT
def maxHamming ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * ( 2 * n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT brr [ n + i ] = arr [ i ] NEW_LINE DEDENT maxHam = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currHam = 0 NEW_LINE k = 0 NEW_LINE for j in range ( i , i + n ) : NEW_LINE INDENT if brr [ j ] != arr [ k ] : NEW_LINE INDENT currHam += 1 NEW_LINE k = k + 1 NEW_LINE DEDENT DEDENT if currHam == n : NEW_LINE INDENT return n NEW_LINE DEDENT maxHam = max ( maxHam , currHam ) NEW_LINE DEDENT return maxHam NEW_LINE DEDENT
def rearrangeArr ( arr , n ) : NEW_LINE INDENT evenPos = int ( n / 2 ) NEW_LINE oddPos = n - evenPos NEW_LINE tempArr = np . empty ( n , dtype = object ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tempArr [ i ] = arr [ i ] NEW_LINE DEDENT tempArr . sort ( ) NEW_LINE j = oddPos - 1 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT arr [ i ] = tempArr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT j = oddPos NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT arr [ i ] = tempArr [ j ] NEW_LINE j = j + 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT
def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT
def moveZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ count ] , arr [ i ] = arr [ i ] , arr [ count ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while ( count < n ) : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT
def modifyAndRearrangeArr ( ar , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) and ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT arr [ i ] = 2 * arr [ i ] NEW_LINE arr [ i + 1 ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT pushZerosToEnd ( arr , n ) NEW_LINE DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def RearrangePosNeg ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE if ( key > 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j >= 0 and arr [ j ] > 0 ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = key NEW_LINE DEDENT DEDENT
def isLeaf ( node ) : NEW_LINE INDENT if node is None : NEW_LINE INDENT return False NEW_LINE DEDENT if node . left is None and node . right is None : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def leftLeavesSum ( root ) : NEW_LINE INDENT res = 0 NEW_LINE if root is not None : NEW_LINE INDENT if isLeaf ( root . left ) : NEW_LINE INDENT res += root . left . key NEW_LINE DEDENT else : NEW_LINE INDENT res += leftLeavesSum ( root . left ) NEW_LINE DEDENT res += leftLeavesSum ( root . right ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def reverse ( arr , l , r ) : NEW_LINE INDENT if l < r : NEW_LINE INDENT arr [ l ] , arr [ r ] = arr [ r ] , arr [ l ] NEW_LINE l , r = l + 1 , r - 1 NEW_LINE reverse ( arr , l , r ) NEW_LINE DEDENT DEDENT
def RearrangePosNeg ( arr , l , r ) : NEW_LINE INDENT if l < r : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE RearrangePosNeg ( arr , l , m ) NEW_LINE RearrangePosNeg ( arr , m + 1 , r ) NEW_LINE merge ( arr , l , m , r ) NEW_LINE DEDENT DEDENT
def rearrangeNaive ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp [ arr [ i ] ] = i NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ arr [ i ] % n ] += i * n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] //= n NEW_LINE DEDENT DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT max_idx = n - 1 NEW_LINE min_idx = 0 NEW_LINE max_elem = arr [ n - 1 ] + 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem NEW_LINE max_idx -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem NEW_LINE min_idx += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] / max_elem NEW_LINE DEDENT DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT max_ele = arr [ n - 1 ] NEW_LINE min_ele = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT arr [ i ] = max_ele NEW_LINE max_ele -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = min_ele NEW_LINE min_ele += 1 NEW_LINE DEDENT DEDENT DEDENT
def leftLeavesSumRec ( root , isLeft , summ ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT if root . left is None and root . right is None and isLeft == True : NEW_LINE INDENT summ [ 0 ] += root . key NEW_LINE DEDENT leftLeavesSumRec ( root . left , 1 , summ ) NEW_LINE leftLeavesSumRec ( root . right , 0 , summ ) NEW_LINE DEDENT
def leftLeavesSum ( root ) : NEW_LINE INDENT summ = [ 0 ] NEW_LINE leftLeavesSumRec ( root , 0 , summ ) NEW_LINE return summ [ 0 ] NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT print ( arr ) NEW_LINE DEDENT
def segregateElements ( arr , n ) : NEW_LINE INDENT temp = [ 0 for k in range ( n ) ] NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( j == n or j == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for k in range ( n ) : NEW_LINE INDENT arr [ k ] = temp [ k ] NEW_LINE DEDENT DEDENT
def rearrange ( a , size ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 1 NEW_LINE while ( True ) : NEW_LINE INDENT while ( positive < size and a [ positive ] >= 0 ) : NEW_LINE INDENT positive = positive + 2 NEW_LINE DEDENT while ( negative < size and a [ negative ] <= 0 ) : NEW_LINE INDENT negative = negative + 2 NEW_LINE DEDENT if ( positive < size and negative < size ) : NEW_LINE INDENT temp = a [ positive ] NEW_LINE a [ positive ] = a [ negative ] NEW_LINE a [ negative ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def printPostorder ( root ) : NEW_LINE INDENT if root : NEW_LINE INDENT printPostorder ( root . left ) NEW_LINE printPostorder ( root . right ) NEW_LINE print ( root . val ) , NEW_LINE DEDENT DEDENT
def printInorder ( root ) : NEW_LINE INDENT if root : NEW_LINE INDENT printInorder ( root . left ) NEW_LINE print ( root . val ) , NEW_LINE printInorder ( root . right ) NEW_LINE DEDENT DEDENT
def printPreorder ( root ) : NEW_LINE INDENT if root : NEW_LINE INDENT print ( root . val ) , NEW_LINE printPreorder ( root . left ) NEW_LINE printPreorder ( root . right ) NEW_LINE DEDENT DEDENT
def largest ( arr , n ) : NEW_LINE INDENT return max ( arr ) NEW_LINE DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT first = - sys . maxsize NEW_LINE second = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < second ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def findMean ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return float ( sum / n ) NEW_LINE DEDENT
def findMedian ( a , n ) : NEW_LINE INDENT sorted ( a ) NEW_LINE if n % 2 != 0 : NEW_LINE INDENT return float ( a [ int ( n / 2 ) ] ) NEW_LINE DEDENT return float ( ( a [ int ( ( n - 1 ) / 2 ) ] + a [ int ( n / 2 ) ] ) / 2.0 ) NEW_LINE DEDENT
def findSmallestMissinginSortedArray ( arr ) : NEW_LINE INDENT if ( arr [ 0 ] != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ - 1 ] == len ( arr ) - 1 ) : NEW_LINE INDENT return len ( arr ) NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE return findFirstMissing ( arr , 0 , len ( arr ) - 1 , first ) NEW_LINE DEDENT
def findFirstMissing ( arr , start , end , first ) : NEW_LINE INDENT if ( start < end ) : NEW_LINE INDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( arr [ mid ] != mid + first ) : NEW_LINE INDENT return findFirstMissing ( arr , start , mid , first ) NEW_LINE DEDENT else : NEW_LINE INDENT return findFirstMissing ( arr , mid + 1 , end , first ) NEW_LINE DEDENT DEDENT return start + first NEW_LINE DEDENT
def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = math . pow ( 2 , l - 1 ) NEW_LINE sumLastLevel = 0 NEW_LINE sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ) NEW_LINE sum = sumLastLevel * l NEW_LINE return int ( sum ) NEW_LINE DEDENT
def buildSparseTable ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = arr [ i ] NEW_LINE DEDENT j = 1 NEW_LINE while ( 1 << j ) <= n : NEW_LINE INDENT i = 0 NEW_LINE while ( i + ( 1 << j ) - 1 ) < n : NEW_LINE INDENT if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT
def query ( L , R ) : NEW_LINE INDENT j = int ( math . log2 ( R - L + 1 ) ) NEW_LINE if lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] : NEW_LINE INDENT return lookup [ L ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT return lookup [ R - ( 1 << j ) + 1 ] [ j ] NEW_LINE DEDENT DEDENT
def add ( arr , N , lo , hi , val ) : NEW_LINE INDENT arr [ lo ] += val NEW_LINE if ( hi != N - 1 ) : NEW_LINE INDENT arr [ hi + 1 ] -= val NEW_LINE DEDENT DEDENT
def updateArray ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE DEDENT DEDENT
def FillPrefixSuffix ( prefix , arr , suffix , n ) : NEW_LINE INDENT prefix [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = GCD ( prefix [ i - 1 ] , arr [ i ] ) NEW_LINE DEDENT suffix [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffix [ i ] = GCD ( suffix [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT DEDENT
def GCDoutsideRange ( l , r , prefix , suffix , n ) : NEW_LINE INDENT if ( l == 0 ) : NEW_LINE INDENT return suffix [ r + 1 ] NEW_LINE DEDENT if ( r == n - 1 ) : NEW_LINE INDENT return prefix [ l - 1 ] NEW_LINE DEDENT return GCD ( prefix [ l - 1 ] , suffix [ r + 1 ] ) NEW_LINE DEDENT
def lowerIndex ( arr , n , x ) : NEW_LINE INDENT l = 0 NEW_LINE h = n - 1 NEW_LINE while ( l <= h ) : NEW_LINE INDENT mid = int ( ( l + h ) / 2 ) NEW_LINE if ( arr [ mid ] >= x ) : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT return l NEW_LINE DEDENT DEDENT
def countInRange ( arr , n , x , y ) : NEW_LINE INDENT count = 0 NEW_LINE count = upperIndex ( arr , n , y ) - lowerIndex ( arr , n , x ) + 1 NEW_LINE return count NEW_LINE DEDENT
def precompute ( arr , n , pre ) : NEW_LINE INDENT pre [ n - 1 ] = arr [ n - 1 ] * pow ( 2 , 0 ) NEW_LINE i = n - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT pre [ i ] = ( pre [ i + 1 ] + arr [ i ] * ( 1 << ( n - 1 - i ) ) ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT
def decimalOfSubarr ( arr , l , r , n , pre ) : NEW_LINE INDENT if ( r != n - 1 ) : NEW_LINE INDENT return ( ( pre [ l ] - pre [ r + 1 ] ) / ( 1 << ( n - 1 - r ) ) ) NEW_LINE DEDENT return pre [ l ] / ( 1 << ( n - 1 - r ) ) NEW_LINE DEDENT
def answerQuery ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE l = l - 1 NEW_LINE for i in range ( l , r , 1 ) : NEW_LINE INDENT element = a [ i ] NEW_LINE divisors = 0 NEW_LINE for j in range ( l , r , 1 ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT divisors += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( divisors == ( r - l ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def addConsideringGrid ( root , level , index ) : NEW_LINE INDENT global grid NEW_LINE if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT grid [ level - index ] = ( grid . get ( level - index , 0 ) + root . data ) NEW_LINE addConsideringGrid ( root . left , level + 1 , index - 1 ) NEW_LINE addConsideringGrid ( root . right , level + 1 , index + 1 ) NEW_LINE DEDENT
def diagonalSum ( root ) : NEW_LINE INDENT addConsideringGrid ( root , 0 , 0 ) NEW_LINE ans = [ ] NEW_LINE for x in grid : NEW_LINE INDENT ans . append ( grid [ x ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def make_prefix ( A , n ) : NEW_LINE INDENT global one , MAX NEW_LINE for j in range ( 0 , 32 ) : NEW_LINE INDENT one [ 0 ] [ j ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a = A [ i - 1 ] NEW_LINE for j in range ( 0 , 32 ) : NEW_LINE INDENT x = int ( math . pow ( 2 , j ) ) NEW_LINE if ( a & x ) : NEW_LINE INDENT one [ i ] [ j ] = 1 + one [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT one [ i ] [ j ] = one [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def type1 ( arr , start , limit ) : NEW_LINE INDENT for i in range ( start , limit + 1 ) : NEW_LINE INDENT arr [ i ] += 1 NEW_LINE DEDENT DEDENT
def type2 ( arr , query , start , limit ) : NEW_LINE INDENT for i in range ( start , limit + 1 ) : NEW_LINE INDENT if ( query [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) NEW_LINE DEDENT elif ( query [ i ] [ 0 ] == 2 ) : NEW_LINE INDENT type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) NEW_LINE DEDENT DEDENT DEDENT
def record_sum ( record , l , r , n , adder ) : NEW_LINE INDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT record [ i ] += adder NEW_LINE DEDENT DEDENT
def solveQuery ( start , end , arr ) : NEW_LINE INDENT frequency = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] in frequency . keys ( ) : NEW_LINE INDENT frequency [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT frequency [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for x in frequency : NEW_LINE INDENT if x == frequency [ x ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def answer_query ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countIndex ( a , n ) : NEW_LINE INDENT global N , prefixans NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT prefixans [ i ] = 1 NEW_LINE DEDENT if ( i != 0 ) : NEW_LINE INDENT prefixans [ i ] = ( prefixans [ i ] + prefixans [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT
def answer_query ( l , r ) : NEW_LINE INDENT global N , prefixans NEW_LINE if ( l == 0 ) : NEW_LINE INDENT return prefixans [ r - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( prefixans [ r - 1 ] - prefixans [ l - 1 ] ) NEW_LINE DEDENT DEDENT
def update ( D , l , r , x ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ r + 1 ] -= x NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = a [ 0 ] NEW_LINE curr_max = a [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( a [ i ] , curr_max + a [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT
def minJumps ( arr , n ) : NEW_LINE INDENT jumps = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT jumps [ i ] = float ( 'inf' ) NEW_LINE DEDENT elif ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT jumps [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT min = float ( 'inf' ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j <= arr [ i ] + i ) : NEW_LINE INDENT if ( min > jumps [ j ] ) : NEW_LINE INDENT min = jumps [ j ] NEW_LINE DEDENT DEDENT DEDENT if ( min != float ( 'inf' ) ) : NEW_LINE INDENT jumps [ i ] = min + 1 NEW_LINE DEDENT else : NEW_LINE INDENT jumps [ i ] = min NEW_LINE DEDENT DEDENT DEDENT return jumps [ 0 ] NEW_LINE DEDENT
def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE min_len = n + 1 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT while ( curr_sum <= x and end < n ) : NEW_LINE INDENT curr_sum += arr [ end ] NEW_LINE end += 1 NEW_LINE DEDENT while ( curr_sum > x and start < n ) : NEW_LINE INDENT if ( end - start < min_len ) : NEW_LINE INDENT min_len = end - start NEW_LINE DEDENT curr_sum -= arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT DEDENT return min_len NEW_LINE DEDENT
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 ] * n NEW_LINE csum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT max_sum = csum [ k - 1 ] NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum = csum [ i ] - csum [ i - k ] NEW_LINE if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT
def findMinOps ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE i , j = 0 , n - 1 NEW_LINE while i <= j : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif arr [ i ] > arr [ j ] : NEW_LINE INDENT j -= 1 NEW_LINE arr [ j ] += arr [ j + 1 ] NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] += arr [ i - 1 ] NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findSmallest ( arr , n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] <= res : NEW_LINE INDENT res = res + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - maxsize - 1 NEW_LINE max_ending_here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here += a [ i ] NEW_LINE if max_so_far < max_ending_here : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE start = s NEW_LINE end = i NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE s = i + 1 NEW_LINE DEDENT DEDENT return ( end - start + 1 ) NEW_LINE DEDENT
def findMinDiff ( arr , n ) : NEW_LINE INDENT diff = 10 ** 20 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if abs ( arr [ i ] - arr [ j ] ) < diff : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT
def findMinDiff ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE diff = 10 ** 20 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] - arr [ i ] < diff : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE DEDENT DEDENT return diff NEW_LINE DEDENT
def checkbit ( array , index ) : NEW_LINE INDENT return array [ index >> 5 ] & ( 1 << ( index & 31 ) ) NEW_LINE DEDENT
def setbit ( array , index ) : NEW_LINE INDENT array [ index >> 5 ] |= ( 1 << ( index & 31 ) ) NEW_LINE DEDENT
def sortInWave ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT
def sortInWave ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if ( i > 0 and arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] , arr [ i ] NEW_LINE DEDENT if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT DEDENT
def moveToEnd ( mPlusN , size ) : NEW_LINE INDENT i = 0 NEW_LINE j = size - 1 NEW_LINE for i in range ( size - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mPlusN [ i ] != NA ) : NEW_LINE INDENT mPlusN [ j ] = mPlusN [ i ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT
def merge ( mPlusN , N , m , n ) : NEW_LINE INDENT i = n NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( k < ( m + n ) ) : NEW_LINE INDENT if ( ( j == n ) or ( i < ( m + n ) and mPlusN [ i ] <= N [ j ] ) ) : NEW_LINE INDENT mPlusN [ k ] = mPlusN [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mPlusN [ k ] = N [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT
def sortedAfterSwap ( A , B , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( B [ i ] == 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( B [ j ] == 1 ) : NEW_LINE INDENT j = j + 1 NEW_LINE DEDENT A = A [ 0 : i ] + sorted ( A [ i : j + 1 ] ) + A [ j + 1 : ] NEW_LINE i = j NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def sortedAfterSwap ( A , B , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if B [ i ] : NEW_LINE INDENT if A [ i ] != i + 1 : NEW_LINE INDENT A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if A [ i ] != i + 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def segregate0and1 ( arr , n ) : NEW_LINE INDENT type0 = 0 NEW_LINE type1 = n - 1 NEW_LINE while ( type0 < type1 ) : NEW_LINE INDENT if ( arr [ type0 ] == 1 ) : NEW_LINE INDENT arr [ type0 ] , arr [ type1 ] = arr [ type1 ] , arr [ type0 ] NEW_LINE type1 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT type0 += 1 NEW_LINE DEDENT DEDENT DEDENT
def increasing ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= a [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def decreasing ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( a [ i ] < a [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def shortestUnsorted ( a , n ) : NEW_LINE INDENT if ( increasing ( a , n ) == True or decreasing ( a , n ) == True ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT
def indexOf ( arr , ele ) : NEW_LINE INDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] == ele ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minSwaps ( arr , N ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = arr . copy ( ) NEW_LINE temp . sort ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] != temp [ i ] ) : NEW_LINE INDENT ans += 1 NEW_LINE swap ( arr , i , indexOf ( arr , temp [ i ] ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def printUnion ( arr1 , arr2 , m , n ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT tempp = arr1 NEW_LINE arr1 = arr2 NEW_LINE arr2 = tempp NEW_LINE temp = m NEW_LINE m = n NEW_LINE n = temp NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT print ( arr1 [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) == - 1 ) : NEW_LINE INDENT print ( arr2 [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def printIntersection ( arr1 , arr2 , m , n ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT tempp = arr1 NEW_LINE arr1 = arr2 NEW_LINE arr2 = tempp NEW_LINE temp = m NEW_LINE m = n NEW_LINE n = temp NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) != - 1 ) : NEW_LINE INDENT print ( arr2 [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE INDENT mid = int ( l + ( r - l ) / 2 ) NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ mid ] > x ) : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def intersection ( a , b , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( a [ i ] > b [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( b [ j ] > a [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def sort012 ( a , arr_size ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = arr_size - 1 NEW_LINE mid = 0 NEW_LINE while mid <= hi : NEW_LINE INDENT if a [ mid ] == 0 : NEW_LINE INDENT a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ] NEW_LINE lo = lo + 1 NEW_LINE mid = mid + 1 NEW_LINE DEDENT elif a [ mid ] == 1 : NEW_LINE INDENT mid = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ] NEW_LINE hi = hi - 1 NEW_LINE DEDENT DEDENT return a NEW_LINE DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def sortArr ( arr , n ) : NEW_LINE INDENT cnt0 = 0 NEW_LINE cnt1 = 0 NEW_LINE cnt2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT cnt0 += 1 NEW_LINE DEDENT elif arr [ i ] == 1 : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT elif arr [ i ] == 2 : NEW_LINE INDENT cnt2 += 1 NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( cnt0 > 0 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE i += 1 NEW_LINE cnt0 -= 1 NEW_LINE DEDENT while ( cnt1 > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE i += 1 NEW_LINE cnt1 -= 1 NEW_LINE DEDENT while ( cnt2 > 0 ) : NEW_LINE INDENT arr [ i ] = 2 NEW_LINE i += 1 NEW_LINE cnt2 -= 1 NEW_LINE DEDENT printArr ( arr , n ) NEW_LINE DEDENT
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def binarySearch ( arr , low , high , x ) : NEW_LINE INDENT if ( high >= low ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if x == arr [ mid ] : NEW_LINE INDENT return ( mid ) NEW_LINE DEDENT elif ( x > arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , low , ( mid - 1 ) , x ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT if ( binarySearch ( arr , i + 1 , n - 1 , arr [ i ] + k ) != - 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def constructArr ( arr , pair , n ) : NEW_LINE INDENT arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = pair [ i - 1 ] - arr [ 0 ] NEW_LINE DEDENT DEDENT
def minMaxProduct ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT max = arr1 [ 0 ] NEW_LINE min = arr2 [ 0 ] NEW_LINE i = 1 NEW_LINE while ( i < n1 and i < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] > max ) : NEW_LINE INDENT max = arr1 [ i ] NEW_LINE DEDENT if ( arr2 [ i ] < min ) : NEW_LINE INDENT min = arr2 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while ( i < n1 ) : NEW_LINE INDENT if ( arr1 [ i ] > max ) : NEW_LINE INDENT max = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT while ( i < n2 ) : NEW_LINE INDENT if ( arr2 [ i ] < min ) : NEW_LINE INDENT min = arr2 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return max * min NEW_LINE DEDENT
def findElement ( arr , n , key ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == key ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findPos ( a , key ) : NEW_LINE INDENT l , h , val = 0 , 1 , arr [ 0 ] NEW_LINE while val < key : NEW_LINE INDENT l = h NEW_LINE h = 2 * h NEW_LINE val = arr [ h ] NEW_LINE DEDENT return binary_search ( a , l , h , key ) NEW_LINE DEDENT
def findSingle ( ar , n ) : NEW_LINE INDENT res = ar [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res = res ^ ar [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def isPresent ( B , m , x ) : NEW_LINE INDENT for i in range ( 0 , m ) : NEW_LINE INDENT if B [ i ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findMaxSubarraySumUtil ( A , B , n , m ) : NEW_LINE INDENT max_so_far = INT_MIN NEW_LINE curr_max = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if isPresent ( B , m , A [ i ] ) == True : NEW_LINE INDENT curr_max = 0 NEW_LINE continue NEW_LINE DEDENT curr_max = max ( A [ i ] , curr_max + A [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT
def findMaxSum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix_sum = arr [ i ] NEW_LINE for j in range ( i ) : NEW_LINE INDENT prefix_sum += arr [ j ] NEW_LINE DEDENT suffix_sum = arr [ i ] NEW_LINE j = n - 1 NEW_LINE while ( j > i ) : NEW_LINE INDENT suffix_sum += arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( prefix_sum == suffix_sum ) : NEW_LINE INDENT res = max ( res , prefix_sum ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def getTotalHeight ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( getTotalHeight ( root . left ) + getHeight ( root ) + getTotalHeight ( root . right ) ) NEW_LINE DEDENT
def findMaxSum ( arr , n ) : NEW_LINE INDENT preSum = [ 0 for i in range ( n ) ] NEW_LINE suffSum = [ 0 for i in range ( n ) ] NEW_LINE ans = - 10000000 NEW_LINE preSum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT preSum [ i ] = preSum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT suffSum [ n - 1 ] = arr [ n - 1 ] NEW_LINE if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) : NEW_LINE INDENT ans = max ( ans , preSum [ n - 1 ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] NEW_LINE if ( suffSum [ i ] == preSum [ i ] ) : NEW_LINE INDENT ans = max ( ans , preSum [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT i = low NEW_LINE for i in range ( high ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT if arr [ i ] < x and arr [ i + 1 ] >= x : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT if x > arr [ high ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT if mid + 1 <= high and x <= arr [ mid + 1 ] : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if mid - 1 >= low and x > arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT DEDENT DEDENT
def findMajority ( arr , n ) : NEW_LINE INDENT maxCount = 0 NEW_LINE index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > maxCount ) : NEW_LINE INDENT maxCount = count NEW_LINE index = i NEW_LINE DEDENT DEDENT if ( maxCount > n // 2 ) : NEW_LINE INDENT print ( arr [ index ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No Majority Element" ) NEW_LINE DEDENT DEDENT
def getTotalHeight ( root ) : NEW_LINE INDENT getTotalHeightUtil ( root ) NEW_LINE return sum NEW_LINE DEDENT
def majorityElement ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count , max_ele , temp , f = 1 , - 1 , arr [ 0 ] , 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( temp == arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE temp = arr [ i ] NEW_LINE DEDENT if ( max_ele < count ) : NEW_LINE INDENT max_ele = count NEW_LINE ele = arr [ i ] NEW_LINE if ( max_ele > ( n // 2 ) ) : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if f == 1 : NEW_LINE INDENT return ele NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def isMajority ( arr , n , x ) : NEW_LINE INDENT last_index = ( n // 2 + 1 ) if n % 2 == 0 else ( n // 2 ) NEW_LINE for i in range ( last_index ) : NEW_LINE INDENT if arr [ i ] == x and arr [ i + n // 2 ] == x : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT
def _binarySearch ( arr , low , high , x ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( mid == 0 or x > arr [ mid - 1 ] ) and ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif x > arr [ mid ] : NEW_LINE INDENT return _binarySearch ( arr , ( mid + 1 ) , high , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return _binarySearch ( arr , low , ( mid - 1 ) , x ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def isMajority ( arr , n , x ) : NEW_LINE INDENT i = _binarySearch ( arr , 0 , n - 1 , x ) NEW_LINE if i == - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( i + n // 2 ) <= ( n - 1 ) ) and arr [ i + n // 2 ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def isMajorityElement ( arr , n , key ) : NEW_LINE INDENT if ( arr [ n // 2 ] == key ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findPeak ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ 0 ] >= arr [ 1 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ n - 1 ] >= arr [ n - 2 ] ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= arr [ i - 1 ] and arr [ i ] >= arr [ i + 1 ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT
def findPeak ( arr , n ) : NEW_LINE INDENT return findPeakUtil ( arr , 0 , n - 1 , n ) NEW_LINE DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT print ( "Repeating elements are " , end = '' ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT print ( arr [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT count = [ 0 ] * size NEW_LINE print ( " Repeating elements are " , end = "" ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( count [ arr [ i ] ] == 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] = count [ arr [ i ] ] + 1 NEW_LINE DEDENT DEDENT DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT S = 0 NEW_LINE P = 1 NEW_LINE n = size - 2 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT S = S + arr [ i ] NEW_LINE P = P * arr [ i ] NEW_LINE DEDENT S = S - n * ( n + 1 ) // 2 NEW_LINE P = P // fact ( n ) NEW_LINE D = math . sqrt ( S * S - 4 * P ) NEW_LINE x = ( D + S ) // 2 NEW_LINE y = ( S - D ) // 2 NEW_LINE print ( "The two Repeating elements are " , ( int ) ( x ) , " & " , ( int ) ( y ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * fact ( n - 1 ) ) NEW_LINE DEDENT DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT xor = arr [ 0 ] NEW_LINE n = size - 2 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor ^= arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT xor ^= i NEW_LINE DEDENT set_bit_no = xor & ~ ( xor - 1 ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i & set_bit_no ) : NEW_LINE INDENT x = x ^ i NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ i NEW_LINE DEDENT DEDENT print ( "The two repeating" , "elements are" , y , x ) NEW_LINE DEDENT
def linearSearch ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] is i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def subArraySum ( arr , n , sum_ ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT curr_sum = arr [ i ] NEW_LINE j = i + 1 NEW_LINE while j <= n : NEW_LINE INDENT if curr_sum == sum_ : NEW_LINE INDENT print ( "Sum found between" ) NEW_LINE print ( "indexes % d and % d" % ( i , j - 1 ) ) NEW_LINE return 1 NEW_LINE DEDENT if curr_sum > sum_ or j == n : NEW_LINE INDENT break NEW_LINE DEDENT curr_sum = curr_sum + arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( "No subarray found" ) NEW_LINE return 0 NEW_LINE DEDENT
def maxTripletSum ( arr , n ) : NEW_LINE INDENT sm = - 1000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) : NEW_LINE INDENT sm = arr [ i ] + arr [ j ] + arr [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return sm NEW_LINE DEDENT
def maxTripletSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ) NEW_LINE DEDENT
def maxTripletSum ( arr , n ) : NEW_LINE INDENT maxA = - 100000000 NEW_LINE maxB = - 100000000 NEW_LINE maxC = - 100000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > maxA ) : NEW_LINE INDENT maxC = maxB NEW_LINE maxB = maxA NEW_LINE maxA = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxB ) : NEW_LINE INDENT maxC = maxB NEW_LINE maxB = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxC ) : NEW_LINE INDENT maxC = arr [ i ] NEW_LINE DEDENT DEDENT return ( maxA + maxB + maxC ) NEW_LINE DEDENT
def minimum ( a , b , c ) : NEW_LINE INDENT return min ( min ( a , b ) , c ) NEW_LINE DEDENT
def smallestDifferenceTriplet ( arr1 , arr2 , arr3 , n ) : NEW_LINE INDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE arr3 . sort ( ) NEW_LINE res_min = 0 NEW_LINE res_max = 0 NEW_LINE res_mid = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE diff = 2147483647 NEW_LINE while ( i < n and j < n and k < n ) : NEW_LINE INDENT sum = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] NEW_LINE max = maximum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) NEW_LINE min = minimum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) NEW_LINE if ( min == arr1 [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( min == arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT if ( diff > ( max - min ) ) : NEW_LINE INDENT diff = max - min NEW_LINE res_max = max NEW_LINE res_mid = sum - ( max + min ) NEW_LINE res_min = min NEW_LINE DEDENT DEDENT print ( res_max , "," , res_mid , "," , res_min ) NEW_LINE DEDENT
def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT for i in range ( 0 , arr_size - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , arr_size - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , arr_size ) : NEW_LINE INDENT if A [ i ] + A [ j ] + A [ k ] == sum : NEW_LINE INDENT print ( "Triplet is" , A [ i ] , ", " , A [ j ] , ", " , A [ k ] ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT A . sort ( ) NEW_LINE for i in range ( 0 , arr_size - 2 ) : NEW_LINE INDENT l = i + 1 NEW_LINE r = arr_size - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ i ] + A [ l ] + A [ r ] == sum ) : NEW_LINE INDENT print ( "Triplet is" , A [ i ] , ', ' , A [ l ] , ', ' , A [ r ] ) NEW_LINE return True NEW_LINE DEDENT elif ( A [ i ] + A [ l ] + A [ r ] < sum ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def areConsecutive ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT Min = min ( arr ) NEW_LINE Max = max ( arr ) NEW_LINE if ( Max - Min + 1 == n ) : NEW_LINE INDENT visited = [ False for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( visited [ arr [ i ] - Min ] != False ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited [ arr [ i ] - Min ] = True NEW_LINE DEDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def areConsecutive ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT min = getMin ( arr , n ) NEW_LINE max = getMax ( arr , n ) NEW_LINE if ( max - min + 1 == n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT j = - arr [ i ] - min NEW_LINE DEDENT else : NEW_LINE INDENT j = arr [ i ] - min NEW_LINE DEDENT if ( arr [ j ] > 0 ) : NEW_LINE INDENT arr [ j ] = - arr [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def getMax ( arr , n ) : NEW_LINE INDENT max = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def relativeComplement ( arr1 , arr2 , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , " " , end = "" ) NEW_LINE i += 1 NEW_LINE DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( arr1 [ i ] , " " , end = "" ) NEW_LINE DEDENT DEDENT
def minOps ( arr , n , k ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( max1 - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( max1 - arr [ i ] ) / k NEW_LINE DEDENT DEDENT return int ( res ) NEW_LINE DEDENT
def search ( arr , search_Element ) : NEW_LINE INDENT left = 0 NEW_LINE length = len ( arr ) NEW_LINE position = - 1 NEW_LINE right = length - 1 NEW_LINE for left in range ( 0 , right , 1 ) : NEW_LINE INDENT if ( arr [ left ] == search_Element ) : NEW_LINE INDENT position = left NEW_LINE print ( "Element found in Array at " , position + 1 , " Position with " , left + 1 , " Attempt" ) NEW_LINE break NEW_LINE DEDENT if ( arr [ right ] == search_Element ) : NEW_LINE INDENT position = right NEW_LINE print ( "Element found in Array at " , position + 1 , " Position with " , length - right , " Attempt" ) NEW_LINE break NEW_LINE DEDENT left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT if ( position == - 1 ) : NEW_LINE INDENT print ( "Not found in Array with " , left , " Attempt" ) NEW_LINE DEDENT DEDENT
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if r >= l : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] > x : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def exponentialSearch ( arr , n , x ) : NEW_LINE INDENT if arr [ 0 ] == x : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = 1 NEW_LINE while i < n and arr [ i ] <= x : NEW_LINE INDENT i = i * 2 NEW_LINE DEDENT return binarySearch ( arr , i / 2 , min ( i , n - 1 ) , x ) NEW_LINE DEDENT
def findCrossOver ( arr , low , high , x ) : NEW_LINE INDENT if ( arr [ high ] <= x ) : NEW_LINE INDENT return high NEW_LINE DEDENT if ( arr [ low ] > x ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] <= x and arr [ mid + 1 ] > x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ mid ] < x ) : NEW_LINE INDENT return findCrossOver ( arr , mid + 1 , high , x ) NEW_LINE DEDENT return findCrossOver ( arr , low , mid - 1 , x ) NEW_LINE DEDENT
def countSort ( arr , n , exp ) : NEW_LINE INDENT output = [ 0 ] * n NEW_LINE count = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count [ ( arr [ i ] // exp ) % n ] += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT count [ i ] += count [ i - 1 ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT output [ count [ ( arr [ i ] // exp ) % n ] - 1 ] = arr [ i ] NEW_LINE count [ ( arr [ i ] // exp ) % n ] -= 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = output [ i ] NEW_LINE DEDENT DEDENT
def printClosest ( ar1 , ar2 , m , n , x ) : NEW_LINE INDENT diff = sys . maxsize NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) NEW_LINE DEDENT if ar1 [ l ] + ar2 [ r ] > x : NEW_LINE INDENT r = r - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = l + 1 NEW_LINE DEDENT DEDENT print ( "The closest pair is [" , ar1 [ res_l ] , "," , ar2 [ res_r ] , "]" ) NEW_LINE DEDENT
def min ( x , y , z ) : NEW_LINE INDENT if ( x < y ) : NEW_LINE INDENT return x if ( x < z ) else z NEW_LINE DEDENT else : NEW_LINE INDENT return y if ( y < z ) else z NEW_LINE DEDENT DEDENT
def minCost ( cost , m , n ) : NEW_LINE INDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT elif ( m == 0 and n == 0 ) : NEW_LINE INDENT return cost [ m ] [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) NEW_LINE DEDENT DEDENT
def minCost ( cost , m , n ) : NEW_LINE INDENT tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return tc [ m ] [ n ] NEW_LINE DEDENT
def matrixChainMemoised ( p , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT
def MatrixChainOrder ( p , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE return matrixChainMemoised ( p , i , j ) NEW_LINE DEDENT
def MatrixChainOrder ( p , n ) : NEW_LINE INDENT m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT m [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n ) : NEW_LINE INDENT for i in range ( 1 , n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE m [ i ] [ j ] = sys . maxint NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] NEW_LINE if q < m [ i ] [ j ] : NEW_LINE INDENT m [ i ] [ j ] = q NEW_LINE DEDENT DEDENT DEDENT DEDENT return m [ 1 ] [ n - 1 ] NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if k == 0 or k == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 for i in xrange ( k + 1 ) ] NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = min ( i , k ) NEW_LINE while ( j > 0 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT
def max ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return x NEW_LINE DEDENT return y NEW_LINE DEDENT
def lps ( seq , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] and i + 1 == j ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] ) : NEW_LINE INDENT return lps ( seq , i + 1 , j - 1 ) + 2 NEW_LINE DEDENT return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) NEW_LINE DEDENT
def cutRod ( price , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT max_val = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_val = max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) NEW_LINE DEDENT return max_val NEW_LINE DEDENT
def cutRod ( price , n ) : NEW_LINE INDENT val = [ 0 for x in range ( n + 1 ) ] NEW_LINE val [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_val = INT_MIN NEW_LINE for j in range ( i ) : NEW_LINE INDENT max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) NEW_LINE DEDENT val [ i ] = max_val NEW_LINE DEDENT return val [ n ] NEW_LINE DEDENT
def minPalPartion ( string , i , j ) : NEW_LINE INDENT if i >= j or isPalindrome ( string [ i : j + 1 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = float ( 'inf' ) NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT count = ( 1 + minPalPartion ( string , i , k ) + minPalPartion ( string , k + 1 , j ) ) NEW_LINE ans = min ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxDivide ( a , b ) : NEW_LINE INDENT while a % b == 0 : NEW_LINE INDENT a = a / b NEW_LINE DEDENT return a NEW_LINE DEDENT
def getNthUglyNo ( n ) : NEW_LINE INDENT i = 1 NEW_LINE count = 1 NEW_LINE while n > count : NEW_LINE INDENT i += 1 NEW_LINE if isUgly ( i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT
def optimalSearchTree ( keys , freq , n ) : NEW_LINE INDENT return optCost ( freq , 0 , n - 1 ) NEW_LINE DEDENT
def sum ( freq , i , j ) : NEW_LINE INDENT s = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT s += freq [ k ] NEW_LINE DEDENT return s NEW_LINE DEDENT
def optimalSearchTree ( keys , freq , n ) : NEW_LINE INDENT cost = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cost [ i ] [ i ] = freq [ i ] NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 2 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE if i >= n or j >= n : NEW_LINE INDENT break NEW_LINE DEDENT cost [ i ] [ j ] = INT_MAX NEW_LINE for r in range ( i , j + 1 ) : NEW_LINE INDENT c = 0 NEW_LINE if ( r > i ) : NEW_LINE INDENT c += cost [ i ] [ r - 1 ] NEW_LINE DEDENT if ( r < j ) : NEW_LINE INDENT c += cost [ r + 1 ] [ j ] NEW_LINE DEDENT c += sum ( freq , i , j ) NEW_LINE if ( c < cost [ i ] [ j ] ) : NEW_LINE INDENT cost [ i ] [ j ] = c NEW_LINE DEDENT DEDENT DEDENT DEDENT return cost [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( set [ n - 1 ] > sum ) : NEW_LINE INDENT return isSubsetSum ( set , n - 1 , sum ) NEW_LINE DEDENT return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) NEW_LINE DEDENT
def countParenth ( symb , oper , n ) : NEW_LINE INDENT F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if symb [ i ] == 'F' : NEW_LINE INDENT F [ i ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT F [ i ] [ i ] = 0 NEW_LINE DEDENT if symb [ i ] == 'T' : NEW_LINE INDENT T [ i ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ i ] = 0 NEW_LINE DEDENT DEDENT for gap in range ( 1 , n ) : NEW_LINE INDENT i = 0 NEW_LINE for j in range ( gap , n ) : NEW_LINE INDENT T [ i ] [ j ] = F [ i ] [ j ] = 0 NEW_LINE for g in range ( gap ) : NEW_LINE INDENT k = i + g NEW_LINE tik = T [ i ] [ k ] + F [ i ] [ k ] NEW_LINE tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] NEW_LINE if oper [ k ] == '&' : NEW_LINE INDENT T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] NEW_LINE F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) NEW_LINE DEDENT if oper [ k ] == '|' : NEW_LINE INDENT F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] NEW_LINE T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE DEDENT if oper [ k ] == '^' : NEW_LINE INDENT T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT return T [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def getCount ( keypad , n ) : NEW_LINE INDENT if ( keypad == None or n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT row = [ 0 , 0 , - 1 , 0 , 1 ] NEW_LINE col = [ 0 , - 1 , 0 , 1 , 0 ] NEW_LINE count = [ [ 0 ] * ( n + 1 ) ] * 10 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE move = 0 NEW_LINE ro = 0 NEW_LINE co = 0 NEW_LINE num = 0 NEW_LINE nextNum = 0 NEW_LINE totalCount = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count [ i ] [ 0 ] = 0 NEW_LINE count [ i ] [ 1 ] = 1 NEW_LINE DEDENT for k in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if ( keypad [ i ] [ j ] != '*' and keypad [ i ] [ j ] != '#' ) : NEW_LINE INDENT num = ord ( keypad [ i ] [ j ] ) - 48 NEW_LINE count [ num ] [ k ] = 0 NEW_LINE for move in range ( 5 ) : NEW_LINE INDENT ro = i + row [ move ] NEW_LINE co = j + col [ move ] NEW_LINE if ( ro >= 0 and ro <= 3 and co >= 0 and co <= 2 and keypad [ ro ] [ co ] != '*' and keypad [ ro ] [ co ] != '#' ) : NEW_LINE INDENT nextNum = ord ( keypad [ ro ] [ co ] ) - 48 NEW_LINE count [ num ] [ k ] += count [ nextNum ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT totalCount = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT totalCount += count [ i ] [ n ] NEW_LINE DEDENT return totalCount NEW_LINE DEDENT
def getCount ( keypad , n ) : NEW_LINE INDENT if ( not keypad or n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT odd = [ 0 ] * 10 NEW_LINE even = [ 0 ] * 10 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE useOdd = 0 NEW_LINE totalCount = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT odd [ i ] = 1 NEW_LINE DEDENT for j in range ( 2 , n + 1 ) : NEW_LINE INDENT useOdd = 1 - useOdd NEW_LINE if ( useOdd == 1 ) : NEW_LINE INDENT even [ 0 ] = odd [ 0 ] + odd [ 8 ] NEW_LINE even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] NEW_LINE even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] NEW_LINE even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] NEW_LINE even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] NEW_LINE even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] NEW_LINE even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] NEW_LINE even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] NEW_LINE even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] NEW_LINE even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] NEW_LINE DEDENT else : NEW_LINE INDENT odd [ 0 ] = even [ 0 ] + even [ 8 ] NEW_LINE odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] NEW_LINE odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] NEW_LINE odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] NEW_LINE odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] NEW_LINE odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] NEW_LINE odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] NEW_LINE odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] NEW_LINE odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] NEW_LINE odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] NEW_LINE DEDENT DEDENT totalCount = 0 NEW_LINE if ( useOdd == 1 ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT totalCount += even [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT totalCount += odd [ i ] NEW_LINE DEDENT DEDENT return totalCount NEW_LINE DEDENT
def finalCount ( n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans = ans + countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def finalCount ( n , Sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( Sum - i >= 0 ) : NEW_LINE INDENT ans += countRec ( n - 1 , Sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findCount ( n , sum ) : NEW_LINE INDENT start = math . pow ( 10 , n - 1 ) NEW_LINE end = math . pow ( 10 , n ) - 1 NEW_LINE count = 0 NEW_LINE i = start NEW_LINE while ( i <= end ) : NEW_LINE INDENT cur = 0 NEW_LINE temp = i NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cur += temp % 10 NEW_LINE temp = temp // 10 NEW_LINE DEDENT if ( cur == sum ) : NEW_LINE INDENT count = count + 1 NEW_LINE i += 9 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = 1 NEW_LINE DEDENT for digit in range ( 10 ) : NEW_LINE INDENT for len in range ( 2 , n + 1 ) : NEW_LINE INDENT for x in range ( digit + 1 ) : NEW_LINE INDENT dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ n ] NEW_LINE DEDENT return count NEW_LINE DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count = int ( count * ( N + i - 1 ) ) NEW_LINE count = int ( count / i ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def getMinSquares ( n ) : NEW_LINE INDENT if n <= 3 : NEW_LINE INDENT return n NEW_LINE DEDENT res = n NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = x * x NEW_LINE if temp > n : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , 1 + getMinSquares ( n - temp ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def getMinSquares ( n ) : NEW_LINE INDENT dp = [ 0 , 1 , 2 , 3 ] NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp . append ( i ) NEW_LINE for x in range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1 ) : NEW_LINE INDENT temp = x * x NEW_LINE if temp > i : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def minCoins ( coins , m , V ) : NEW_LINE INDENT table = [ 0 for i in range ( V + 1 ) ] NEW_LINE table [ 0 ] = 0 NEW_LINE for i in range ( 1 , V + 1 ) : NEW_LINE INDENT table [ i ] = sys . maxsize NEW_LINE DEDENT for i in range ( 1 , V + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( coins [ j ] <= i ) : NEW_LINE INDENT sub_res = table [ i - coins [ j ] ] NEW_LINE if ( sub_res != sys . maxsize and sub_res + 1 < table [ i ] ) : NEW_LINE INDENT table [ i ] = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if table [ V ] == sys . maxsize : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return table [ V ] NEW_LINE DEDENT
def superSeq ( X , Y , m , n ) : NEW_LINE INDENT if ( not m ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( not n ) : NEW_LINE INDENT return m NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + superSeq ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) NEW_LINE DEDENT
def superSeq ( X , Y , m , n ) : NEW_LINE INDENT dp = [ [ 0 ] * ( n + 2 ) for i in range ( m + 2 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( not i ) : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif ( not j ) : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
def sumOfDigitsFrom1ToN ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT result = result + sumOfDigits ( x ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def sumOfDigits ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumOfDigitsFrom1ToN ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT d = ( int ) ( math . log10 ( n ) ) NEW_LINE a = [ 0 ] * ( d + 1 ) NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 45 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( math . ceil ( math . pow ( 10 , i - 1 ) ) ) NEW_LINE DEDENT p = ( int ) ( math . ceil ( math . pow ( 10 , d ) ) ) NEW_LINE msd = n // p NEW_LINE return ( int ) ( msd * a [ d ] + ( msd * ( msd - 1 ) // 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) NEW_LINE DEDENT
def sumOfDigitsFrom1ToN ( n ) : NEW_LINE INDENT d = int ( math . log ( n , 10 ) ) NEW_LINE a = [ 0 ] * ( d + 1 ) NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 45 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 10 + 45 * int ( math . ceil ( pow ( 10 , i - 1 ) ) ) NEW_LINE DEDENT return sumOfDigitsFrom1ToNUtil ( n , a ) NEW_LINE DEDENT
def countWays ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT countB = 1 NEW_LINE countS = 1 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT prev_countB = countB NEW_LINE prev_countS = countS NEW_LINE countS = prev_countB + prev_countS NEW_LINE countB = prev_countS NEW_LINE DEDENT result = countS + countB NEW_LINE return ( result * result ) NEW_LINE DEDENT
def findoptimal ( N ) : NEW_LINE INDENT if N <= 6 : NEW_LINE INDENT return N NEW_LINE DEDENT maxi = 0 NEW_LINE for b in range ( N - 3 , 0 , - 1 ) : NEW_LINE INDENT curr = ( N - b - 1 ) * findoptimal ( b ) NEW_LINE if curr > maxi : NEW_LINE INDENT maxi = curr NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT
def findoptimal ( N ) : NEW_LINE INDENT if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT screen = [ 0 ] * N NEW_LINE for n in range ( 1 , 7 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT for n in range ( 7 , N + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = 0 NEW_LINE for b in range ( n - 3 , 0 , - 1 ) : NEW_LINE INDENT curr = ( n - b - 1 ) * screen [ b - 1 ] NEW_LINE if ( curr > screen [ n - 1 ] ) : NEW_LINE INDENT screen [ n - 1 ] = curr NEW_LINE DEDENT DEDENT DEDENT return screen [ N - 1 ] NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = power ( x , int ( y / 2 ) ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT if ( y > 0 ) : NEW_LINE INDENT return x * temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return ( temp * temp ) / x NEW_LINE DEDENT DEDENT DEDENT
def getMedian ( ar1 , ar2 , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE m1 = - 1 NEW_LINE m2 = - 1 NEW_LINE count = 0 NEW_LINE while count < n + 1 : NEW_LINE INDENT count += 1 NEW_LINE if i == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ 0 ] NEW_LINE break NEW_LINE DEDENT elif j == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ 0 ] NEW_LINE break NEW_LINE DEDENT if ar1 [ i ] <= ar2 [ j ] : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ( m1 + m2 ) / 2 NEW_LINE DEDENT
def area ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) NEW_LINE DEDENT
def isInside ( x1 , y1 , x2 , y2 , x3 , y3 , x , y ) : NEW_LINE INDENT A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) NEW_LINE A1 = area ( x , y , x2 , y2 , x3 , y3 ) NEW_LINE A2 = area ( x1 , y1 , x , y , x3 , y3 ) NEW_LINE A3 = area ( x1 , y1 , x2 , y2 , x , y ) NEW_LINE if ( A == A1 + A2 + A3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def isLucky ( n ) : NEW_LINE INDENT next_position = n NEW_LINE if isLucky . counter > n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % isLucky . counter == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT next_position = next_position - next_position / isLucky . counter NEW_LINE isLucky . counter = isLucky . counter + 1 NEW_LINE return isLucky ( next_position ) NEW_LINE DEDENT
def squareRoot ( n ) : NEW_LINE INDENT x = n NEW_LINE y = 1 NEW_LINE e = 0.000001 NEW_LINE while ( x - y > e ) : NEW_LINE INDENT x = ( x + y ) / 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE DEDENT
def maxDiffUtil ( t , res ) : NEW_LINE INDENT if ( t == None ) : NEW_LINE INDENT return _MAX , res NEW_LINE DEDENT if ( t . left == None and t . right == None ) : NEW_LINE INDENT return t . key , res NEW_LINE DEDENT a , res = maxDiffUtil ( t . left , res ) NEW_LINE b , res = maxDiffUtil ( t . right , res ) NEW_LINE val = min ( a , b ) NEW_LINE res = max ( res , t . key - val ) NEW_LINE return min ( val , t . key ) , res NEW_LINE DEDENT
def maxDiff ( root ) : NEW_LINE INDENT res = _MIN NEW_LINE x , res = maxDiffUtil ( root , res ) NEW_LINE return res NEW_LINE DEDENT
def inorder ( root ) : NEW_LINE INDENT if ( root ) : NEW_LINE INDENT inorder ( root . left ) NEW_LINE prf ( "%d " , root . key ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT
def pow ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT answer = a NEW_LINE increment = a NEW_LINE for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( 1 , a ) : NEW_LINE INDENT answer += increment NEW_LINE DEDENT increment = answer NEW_LINE DEDENT return answer NEW_LINE DEDENT
def multiply ( x , y ) : NEW_LINE INDENT if ( y ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def pow ( a , b ) : NEW_LINE INDENT if ( b ) : NEW_LINE INDENT return multiply ( a , pow ( a , b - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT
def getAvg ( prev_avg , x , n ) : NEW_LINE INDENT return ( ( prev_avg * n + x ) / ( n + 1 ) ) NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return n NEW_LINE DEDENT elif n >= 3 and n < 10 : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT po = 1 NEW_LINE while n / po > 9 : NEW_LINE INDENT po = po * 10 NEW_LINE DEDENT msd = n / po NEW_LINE if msd != 3 : NEW_LINE INDENT return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( msd * po - 1 ) NEW_LINE DEDENT DEDENT
def fact ( n ) : NEW_LINE INDENT f = 1 NEW_LINE while n >= 1 : NEW_LINE INDENT f = f * n NEW_LINE n = n - 1 NEW_LINE DEDENT return f NEW_LINE DEDENT
def findSmallerInRight ( st , low , high ) : NEW_LINE INDENT countRight = 0 NEW_LINE i = low + 1 NEW_LINE while i <= high : NEW_LINE INDENT if st [ i ] < st [ low ] : NEW_LINE INDENT countRight = countRight + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return countRight NEW_LINE DEDENT
def findRank ( st ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE mul = fact ( ln ) NEW_LINE rank = 1 NEW_LINE i = 0 NEW_LINE while i < ln : NEW_LINE INDENT mul = mul / ( ln - i ) NEW_LINE countRight = findSmallerInRight ( st , i , ln - 1 ) NEW_LINE rank = rank + countRight * mul NEW_LINE i = i + 1 NEW_LINE DEDENT return rank NEW_LINE DEDENT
def printPascal ( n ) : NEW_LINE INDENT for line in range ( 1 , n + 1 ) : NEW_LINE INDENT C = 1 NEW_LINE for i in range ( 1 , line + 1 ) : NEW_LINE INDENT print ( C , end = " " ) NEW_LINE C = int ( C * ( line - i ) / i ) NEW_LINE DEDENT print ( "" ) NEW_LINE DEDENT DEDENT
def exponential ( n , x ) : NEW_LINE INDENT sum = 1.0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT sum = 1 + x * sum / i NEW_LINE DEDENT print ( "e^x =" , sum ) NEW_LINE DEDENT
def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r NEW_LINE combinationUtil ( arr , n , r , 0 , data , 0 ) NEW_LINE DEDENT
def myRand ( arr , freq , n ) : NEW_LINE INDENT prefix = [ 0 ] * n NEW_LINE prefix [ 0 ] = freq [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + freq [ i ] NEW_LINE DEDENT r = random . randint ( 0 , prefix [ n - 1 ] ) + 1 NEW_LINE indexc = findCeil ( prefix , r , 0 , n - 1 ) NEW_LINE return arr [ indexc ] NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT s = int ( math . sqrt ( x ) ) NEW_LINE return s * s == x NEW_LINE DEDENT
def isFibonacci ( n ) : NEW_LINE INDENT return isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) NEW_LINE DEDENT
def findgroups ( arr , n ) : NEW_LINE INDENT c = [ 0 , 0 , 0 ] NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT c [ arr [ i ] % 3 ] += 1 NEW_LINE DEDENT res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) NEW_LINE res += c [ 1 ] * c [ 2 ] NEW_LINE res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 NEW_LINE res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 NEW_LINE res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) NEW_LINE res += c [ 0 ] * c [ 1 ] * c [ 2 ] NEW_LINE return res NEW_LINE DEDENT
def findTrailingZeros ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n >= 5 ) : NEW_LINE INDENT n //= 5 NEW_LINE count += n NEW_LINE DEDENT return count NEW_LINE DEDENT
def catalan ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def catalan ( n ) : NEW_LINE INDENT c = binomialCoefficient ( 2 * n , n ) NEW_LINE return c / ( n + 1 ) NEW_LINE DEDENT
def catalan ( n ) : NEW_LINE INDENT cat_ = 1 NEW_LINE print ( cat_ , " " , end = '' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT cat_ *= ( 4 * i - 2 ) NEW_LINE cat_ //= ( i + 1 ) NEW_LINE print ( cat_ , " " , end = '' ) NEW_LINE DEDENT DEDENT
def calcAngle ( h , m ) : NEW_LINE INDENT if ( h < 0 or m < 0 or h > 12 or m > 60 ) : NEW_LINE INDENT print ( 'Wrong input' ) NEW_LINE DEDENT if ( h == 12 ) : NEW_LINE INDENT h = 0 NEW_LINE DEDENT if ( m == 60 ) : NEW_LINE INDENT m = 0 NEW_LINE h += 1 NEW_LINE if ( h > 12 ) : NEW_LINE INDENT h = h - 12 NEW_LINE DEDENT DEDENT hour_angle = 0.5 * ( h * 60 + m ) NEW_LINE minute_angle = 6 * m NEW_LINE angle = abs ( hour_angle - minute_angle ) NEW_LINE angle = min ( 360 - angle , angle ) NEW_LINE return angle NEW_LINE DEDENT
def getInvCount ( arr ) : NEW_LINE INDENT inv_count = 0 NEW_LINE for i in range ( 0 , 2 ) : NEW_LINE INDENT for j in range ( i + 1 , 3 ) : NEW_LINE INDENT if ( arr [ j ] [ i ] > 0 and arr [ j ] [ i ] > arr [ i ] [ j ] ) : NEW_LINE INDENT inv_count += 1 NEW_LINE DEDENT DEDENT DEDENT return inv_count NEW_LINE DEDENT
def isSolvable ( puzzle ) : NEW_LINE INDENT invCount = getInvCount ( puzzle ) NEW_LINE return ( invCount % 2 == 0 ) NEW_LINE DEDENT
def find ( p ) : NEW_LINE INDENT return math . ceil ( math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) ) NEW_LINE DEDENT
def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE x = 0 NEW_LINE while ( x * x < n ) : NEW_LINE INDENT y = 0 NEW_LINE while ( x * x + y * y < n ) : NEW_LINE INDENT res = res + 1 NEW_LINE y = y + 1 NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countSolutions ( n ) : NEW_LINE INDENT x = 0 NEW_LINE res = 0 NEW_LINE yCount = 0 NEW_LINE while ( yCount * yCount < n ) : NEW_LINE INDENT yCount = yCount + 1 NEW_LINE DEDENT while ( yCount != 0 ) : NEW_LINE INDENT res = res + yCount NEW_LINE x = x + 1 NEW_LINE while ( yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) : NEW_LINE INDENT yCount = yCount - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def func ( x ) : NEW_LINE INDENT return ( x * x * x - x * x + 2 ) NEW_LINE DEDENT
def regulaFalsi ( a , b ) : NEW_LINE INDENT if func ( a ) * func ( b ) >= 0 : NEW_LINE INDENT print ( "You have not assumed right a and b" ) NEW_LINE return - 1 NEW_LINE DEDENT c = a NEW_LINE for i in range ( MAX_ITER ) : NEW_LINE INDENT c = ( a * func ( b ) - b * func ( a ) ) / ( func ( b ) - func ( a ) ) NEW_LINE if func ( c ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT elif func ( c ) * func ( a ) < 0 : NEW_LINE INDENT b = c NEW_LINE DEDENT else : NEW_LINE INDENT a = c NEW_LINE DEDENT DEDENT print ( "The value of root is : " , '%.4f' % c ) NEW_LINE DEDENT
def func ( x ) : NEW_LINE INDENT return x * x * x - x * x + 2 NEW_LINE DEDENT
def derivFunc ( x ) : NEW_LINE INDENT return 3 * x * x - 2 * x NEW_LINE DEDENT
def newtonRaphson ( x ) : NEW_LINE INDENT h = func ( x ) / derivFunc ( x ) NEW_LINE while abs ( h ) >= 0.0001 : NEW_LINE INDENT h = func ( x ) / derivFunc ( x ) NEW_LINE x = x - h NEW_LINE DEDENT print ( "The value of the root is : " , "%.4f" % x ) NEW_LINE DEDENT
def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT
def oppositeSigns ( x , y ) : NEW_LINE INDENT return ( ( x ^ y ) < 0 ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT bitCount = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bitCount += countSetBitsUtil ( i ) NEW_LINE DEDENT return bitCount NEW_LINE DEDENT
def countSetBitsUtil ( x ) : NEW_LINE INDENT if ( x <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 0 if int ( x % 2 ) == 0 else 1 ) + countSetBitsUtil ( int ( x / 2 ) ) NEW_LINE DEDENT
def swapBits ( num , p1 , p2 , n ) : NEW_LINE INDENT shift1 = 0 NEW_LINE shift2 = 0 NEW_LINE value1 = 0 NEW_LINE value2 = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT shift1 = 1 << p1 NEW_LINE shift2 = 1 << p2 NEW_LINE value1 = ( ( num & shift1 ) ) NEW_LINE value2 = ( ( num & shift2 ) ) NEW_LINE if ( ( value1 == 0 and value2 != 0 ) or ( value2 == 0 and value1 != 0 ) ) : NEW_LINE INDENT if ( value1 != 0 ) : NEW_LINE INDENT num = num & ( ~ shift1 ) NEW_LINE num = num | shift2 NEW_LINE DEDENT else : NEW_LINE INDENT num = num & ( ~ shift2 ) NEW_LINE num = num | shift1 NEW_LINE DEDENT DEDENT p1 += 1 NEW_LINE p2 += 1 NEW_LINE n -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT
def Add ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while ( x and y and z ) : NEW_LINE INDENT x = x - 1 NEW_LINE y = y - 1 NEW_LINE z = z - 1 NEW_LINE c = c + 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
def min ( x , y ) : NEW_LINE INDENT return y + ( ( x - y ) & ( ( x - y ) >> ( 32 * CHAR_BIT - 1 ) ) ) NEW_LINE DEDENT
def smallest ( x , y , z ) : NEW_LINE INDENT return min ( x , min ( y , z ) ) NEW_LINE DEDENT
def snoob ( x ) : NEW_LINE INDENT next = 0 NEW_LINE if ( x ) : NEW_LINE INDENT rightOne = x & - ( x ) NEW_LINE nextHigherOneBit = x + int ( rightOne ) NEW_LINE rightOnesPattern = x ^ int ( nextHigherOneBit ) NEW_LINE rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) ) NEW_LINE rightOnesPattern = int ( rightOnesPattern ) >> 2 NEW_LINE next = nextHigherOneBit | rightOnesPattern NEW_LINE DEDENT return next NEW_LINE DEDENT
def addOne ( x ) : NEW_LINE INDENT m = 1 NEW_LINE while ( x & m ) : NEW_LINE INDENT x = x ^ m NEW_LINE m <<= 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT
def addOne ( x ) : NEW_LINE INDENT return ( - ( ~ x ) ) NEW_LINE DEDENT
def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and ( not ( n & ( n - 1 ) ) ) ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not ( n & 0xAAAAAAAA ) ) NEW_LINE DEDENT
def logn ( n , r ) : NEW_LINE INDENT return math . log ( n ) / math . log ( r ) NEW_LINE DEDENT
def findPostOrderUtil ( pre , n , minval , maxval , preIndex ) : NEW_LINE INDENT if ( preIndex [ 0 ] == n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( pre [ preIndex [ 0 ] ] < minval or pre [ preIndex [ 0 ] ] > maxval ) : NEW_LINE INDENT return NEW_LINE DEDENT val = pre [ preIndex [ 0 ] ] NEW_LINE preIndex [ 0 ] += 1 NEW_LINE findPostOrderUtil ( pre , n , minval , val , preIndex ) NEW_LINE findPostOrderUtil ( pre , n , val , maxval , preIndex ) NEW_LINE print ( val , end = " " ) NEW_LINE DEDENT
def findPostOrder ( pre , n ) : NEW_LINE INDENT preIndex = [ 0 ] NEW_LINE findPostOrderUtil ( pre , n , INT_MIN , INT_MAX , preIndex ) NEW_LINE DEDENT
def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT
def min ( x , y ) : NEW_LINE INDENT return y ^ ( ( x ^ y ) & - ( x < y ) ) NEW_LINE DEDENT
def max ( x , y ) : NEW_LINE INDENT return x ^ ( ( x ^ y ) & - ( x < y ) ) NEW_LINE DEDENT
def absbit32 ( x , y ) : NEW_LINE INDENT sub = x - y NEW_LINE mask = ( sub >> 31 ) NEW_LINE return ( sub ^ mask ) - mask NEW_LINE DEDENT
def max ( x , y ) : NEW_LINE INDENT abs = absbit32 ( x , y ) NEW_LINE return ( x + y + abs ) // 2 NEW_LINE DEDENT
def min ( x , y ) : NEW_LINE INDENT abs = absbit32 ( x , y ) NEW_LINE return ( x + y - abs ) // 2 NEW_LINE DEDENT
def getOddOccurrence ( arr , arr_size ) : NEW_LINE INDENT for i in range ( 0 , arr_size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , arr_size ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count % 2 != 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def getOddOccurrence ( arr , size ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in Hash : NEW_LINE INDENT if ( Hash [ i ] % 2 != 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countWays ( N , K ) : NEW_LINE INDENT return K * fastPow ( K - 1 , N - 1 ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEW_LINE DEDENT DEDENT
def initialize ( ) : NEW_LINE INDENT BitsSetTable256 [ 0 ] = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i // 2 ] NEW_LINE DEDENT DEDENT
def countSetBits ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 4 * 8 ) : NEW_LINE INDENT if ( N & ( 1 << i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE N = 15 NEW_LINE print ( countSetBits ( N ) ) NEW_LINE DEDENT DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += 1 NEW_LINE n &= ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def FlippedCount ( a , b ) : NEW_LINE INDENT return countSetBits ( a ^ b ) NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
def getParity ( n ) : NEW_LINE INDENT parity = 0 NEW_LINE while n : NEW_LINE INDENT parity = ~ parity NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return parity NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isPowerOfTwo ( x ) : NEW_LINE INDENT return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE DEDENT
def getFirstSetBitPos ( n ) : NEW_LINE INDENT return math . log2 ( n & - n ) + 1 NEW_LINE DEDENT
def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT if not ( num & ( 1 << i ) ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT
def bin ( n ) : NEW_LINE INDENT i = 1 << 31 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( ( n & i ) != 0 ) : NEW_LINE INDENT print ( "1" , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = "" ) NEW_LINE DEDENT i = i // 2 NEW_LINE DEDENT DEDENT
def findPosition ( n ) : NEW_LINE INDENT if ( isPowerOfTwo ( n ) == True ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = 1 NEW_LINE pos = 1 NEW_LINE while ( ( i & n ) == 0 ) : NEW_LINE INDENT i = i << 1 NEW_LINE pos += 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT
def findPosition ( n ) : NEW_LINE INDENT if not isPowerOfTwo ( n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n = n >> 1 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def swap ( xp , yp ) : NEW_LINE INDENT xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE DEDENT
def swap ( a , b ) : NEW_LINE INDENT a = ( a & b ) + ( a b ) NEW_LINE b = a + ( ~ b ) + 1 NEW_LINE a = a + ( ~ b ) + 1 NEW_LINE print ( "After Swapping: a = " , a , ", b = " , b ) NEW_LINE DEDENT
def checkSentence ( string ) : NEW_LINE INDENT length = len ( string ) NEW_LINE if string [ 0 ] < 'A' or string [ 0 ] > 'Z' : NEW_LINE INDENT return False NEW_LINE DEDENT if string [ length - 1 ] != '.' : NEW_LINE INDENT return False NEW_LINE DEDENT prev_state = 0 NEW_LINE curr_state = 0 NEW_LINE index = 1 NEW_LINE while ( string [ index ] ) : NEW_LINE INDENT if string [ index ] >= 'A' and string [ index ] <= 'Z' : NEW_LINE INDENT curr_state = 0 NEW_LINE DEDENT elif string [ index ] == ' ' : NEW_LINE INDENT curr_state = 1 NEW_LINE DEDENT elif string [ index ] >= 'a' and string [ index ] <= 'z' : NEW_LINE INDENT curr_state = 2 NEW_LINE DEDENT elif string [ index ] == '.' : NEW_LINE INDENT curr_state = 3 NEW_LINE DEDENT if prev_state == curr_state and curr_state != 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if prev_state == 2 and curr_state == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if curr_state == 3 and prev_state != 1 : NEW_LINE INDENT return True NEW_LINE DEDENT index += 1 NEW_LINE prev_state = curr_state NEW_LINE DEDENT return False NEW_LINE DEDENT
def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if ( arr [ curr ] == 0 ) : NEW_LINE INDENT if ( curr - prev_prev_zero > max_count ) : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE DEDENT DEDENT if ( n - prev_prev_zero > max_count ) : NEW_LINE INDENT max_index = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT
def findLength ( arr , n ) : NEW_LINE INDENT max_len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE mx = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT mn = min ( mn , arr [ j ] ) NEW_LINE mx = max ( mx , arr [ j ] ) NEW_LINE if ( ( mx - mn ) == j - i ) : NEW_LINE INDENT max_len = max ( max_len , mx - mn + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT
def isSubSequence ( string1 , string2 , m , n ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if string1 [ m - 1 ] == string2 [ n - 1 ] : NEW_LINE INDENT return isSubSequence ( string1 , string2 , m - 1 , n - 1 ) NEW_LINE DEDENT return isSubSequence ( string1 , string2 , m , n - 1 ) NEW_LINE DEDENT
def segregate0and1 ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , count ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT for i in range ( count , n ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT
def find3Numbers ( nums ) : NEW_LINE INDENT if ( len ( nums ) < 3 ) : NEW_LINE INDENT print ( "No such triplet found" , end = '' ) NEW_LINE return NEW_LINE DEDENT seq = 1 NEW_LINE min_num = nums [ 0 ] NEW_LINE max_seq = - sys . maxsize - 1 NEW_LINE store_min = min_num NEW_LINE for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT if ( nums [ i ] == min_num ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( nums [ i ] < min_num ) : NEW_LINE INDENT min_num = nums [ i ] NEW_LINE DEDENT continue NEW_LINE elif ( nums [ i ] < max_seq ) : max_seq = nums [ i ] NEW_LINE store_min = min_num NEW_LINE elif ( nums [ i ] > max_seq ) NEW_LINE : if seq == 1 : NEW_LINE INDENT store_min = min_num NEW_LINE DEDENT seq += 1 NEW_LINE if ( seq == 3 ) : NEW_LINE INDENT print ( "Triplet: " + str ( store_min ) + ", " + str ( max_seq ) + ", " + str ( nums [ i ] ) ) NEW_LINE return NEW_LINE DEDENT max_seq = nums [ i ] NEW_LINE print ( "No such triplet found" , end = '' ) NEW_LINE DEDENT DEDENT
def maxCircularSum ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT curr_max = a [ 0 ] NEW_LINE max_so_far = a [ 0 ] NEW_LINE curr_min = a [ 0 ] NEW_LINE min_so_far = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_max = max ( curr_max + a [ i ] , a [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE curr_min = min ( curr_min + a [ i ] , a [ i ] ) NEW_LINE min_so_far = min ( min_so_far , curr_min ) NEW_LINE DEDENT if ( min_so_far == sum ) : NEW_LINE INDENT return max_so_far NEW_LINE DEDENT return max ( max_so_far , sum - min_so_far ) NEW_LINE DEDENT
def GetCeilIndex ( arr , T , l , r , key ) : NEW_LINE INDENT while ( r - l > 1 ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if ( arr [ T [ m ] ] >= key ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT
def generateUtil ( A , B , C , i , j , m , n , len , flag ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT if ( len ) : NEW_LINE INDENT printArr ( C , len + 1 ) NEW_LINE DEDENT for k in range ( i , m ) : NEW_LINE INDENT if ( not len ) : NEW_LINE INDENT C [ len ] = A [ k ] NEW_LINE generateUtil ( A , B , C , k + 1 , j , m , n , len , not flag ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( A [ k ] > C [ len ] ) : NEW_LINE INDENT C [ len + 1 ] = A [ k ] NEW_LINE generateUtil ( A , B , C , k + 1 , j , m , n , len + 1 , not flag ) NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT for l in range ( j , n ) : NEW_LINE INDENT if ( B [ l ] > C [ len ] ) : NEW_LINE INDENT C [ len + 1 ] = B [ l ] NEW_LINE generateUtil ( A , B , C , i , l + 1 , m , n , len + 1 , not flag ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def generate ( A , B , m , n ) : NEW_LINE INDENT C = [ ] NEW_LINE for i in range ( m + n + 1 ) : NEW_LINE INDENT C . append ( 0 ) NEW_LINE DEDENT generateUtil ( A , B , C , 0 , 0 , m , n , 0 , True ) NEW_LINE DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , " " , end = "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def replace_elements ( arr , n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arr [ pos ] = arr [ i ] NEW_LINE pos = pos + 1 NEW_LINE while ( pos > 1 and arr [ pos - 2 ] == arr [ pos - 1 ] ) : NEW_LINE INDENT pos -= 1 NEW_LINE arr [ pos - 1 ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , pos ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def arrangeString ( str1 , x , y ) : NEW_LINE INDENT count_0 = 0 NEW_LINE count_1 = 0 NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str1 [ i ] == '0' : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT DEDENT while count_0 > 0 or count_1 > 0 : NEW_LINE INDENT for i in range ( 0 , x ) : NEW_LINE INDENT if count_0 > 0 : NEW_LINE INDENT print ( "0" , end = "" ) NEW_LINE count_0 -= 1 NEW_LINE DEDENT DEDENT for j in range ( 0 , y ) : NEW_LINE INDENT if count_1 > 0 : NEW_LINE INDENT print ( "1" , end = "" ) NEW_LINE count_1 -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def maxDiff ( arr , arr_size ) : NEW_LINE INDENT max_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT for j in range ( i + 1 , arr_size ) : NEW_LINE INDENT if ( arr [ j ] - arr [ i ] > max_diff ) : NEW_LINE INDENT max_diff = arr [ j ] - arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return max_diff NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT maxDiff = - 1 NEW_LINE maxRight = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > maxRight ) : NEW_LINE INDENT maxRight = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT diff = maxRight - arr [ i ] NEW_LINE if ( diff > maxDiff ) : NEW_LINE INDENT maxDiff = diff NEW_LINE DEDENT DEDENT DEDENT return maxDiff NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT diff = arr [ 1 ] - arr [ 0 ] NEW_LINE curr_sum = diff NEW_LINE max_sum = curr_sum NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if ( curr_sum > 0 ) : NEW_LINE INDENT curr_sum += diff NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum = diff NEW_LINE DEDENT if ( curr_sum > max_sum ) : NEW_LINE INDENT max_sum = curr_sum NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT
def maxIndexDiff ( arr , n ) : NEW_LINE INDENT maxDiff = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = n - 1 NEW_LINE while ( j > i ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] and maxDiff < ( j - i ) : NEW_LINE INDENT maxDiff = j - i NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT return maxDiff NEW_LINE DEDENT
def findMaximum ( arr , low , high ) : NEW_LINE INDENT max = arr [ low ] NEW_LINE i = low NEW_LINE for i in range ( high + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def findMaximum ( arr , low , high ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if high == low + 1 and arr [ low ] >= arr [ high ] : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if high == low + 1 and arr [ low ] < arr [ high ] : NEW_LINE INDENT return arr [ high ] NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return findMaximum ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findMaximum ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT
def constructLowerArray ( arr , countSmaller , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT countSmaller [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT countSmaller [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def findMissingPositive ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) - 1 < size and arr [ abs ( arr [ i ] ) - 1 ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return size + 1 NEW_LINE DEDENT
def findMissing ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size ) NEW_LINE return findMissingPositive ( arr [ shift : ] , size - shift ) NEW_LINE DEDENT
def fillDepth ( parent , i , depth ) : NEW_LINE INDENT if depth [ i ] != 0 : NEW_LINE INDENT return NEW_LINE DEDENT if parent [ i ] == - 1 : NEW_LINE INDENT depth [ i ] = 1 NEW_LINE return NEW_LINE DEDENT if depth [ parent [ i ] ] == 0 : NEW_LINE INDENT fillDepth ( parent , parent [ i ] , depth ) NEW_LINE DEDENT depth [ i ] = depth [ parent [ i ] ] + 1 NEW_LINE DEDENT
def maxRepeating ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ arr [ i ] % k ] += k NEW_LINE DEDENT max = arr [ 0 ] NEW_LINE result = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE result = i NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def maxPathSum ( ar1 , ar2 , m , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE result , sum1 , sum2 = 0 , 0 , 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ar1 [ i ] < ar2 [ j ] : NEW_LINE INDENT sum1 += ar1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT elif ar1 [ i ] > ar2 [ j ] : NEW_LINE INDENT sum2 += ar2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += max ( sum1 , sum2 ) + ar1 [ i ] NEW_LINE sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while i < m : NEW_LINE INDENT sum1 += ar1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while j < n : NEW_LINE INDENT sum2 += ar2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT result += max ( sum1 , sum2 ) NEW_LINE return result NEW_LINE DEDENT
def smallestGreater ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT diff = 1000 NEW_LINE closest = - 1 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] and arr [ j ] - arr [ i ] < diff ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] NEW_LINE closest = j NEW_LINE DEDENT DEDENT if ( closest == - 1 ) : NEW_LINE INDENT print ( "_ " , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "{} " . format ( arr [ closest ] ) , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def smallestGreater ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT newAr = [ ] NEW_LINE for p in s : NEW_LINE INDENT newAr . append ( p ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT temp = lowerBound ( newAr , 0 , len ( newAr ) , arr [ i ] ) NEW_LINE if ( temp < n ) : NEW_LINE INDENT print ( newAr [ temp ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "_ " , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def arraySum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def maxDiff ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE arraysum = arraySum ( arr , n ) NEW_LINE diff1 = abs ( arraysum - 2 * arraySum ( arr , k ) ) NEW_LINE arr . reverse ( ) NEW_LINE diff2 = abs ( arraysum - 2 * arraySum ( arr , k ) ) NEW_LINE return ( max ( diff1 , diff2 ) ) NEW_LINE DEDENT
def minNumber ( a , n , x ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE k = 0 NEW_LINE while ( a [ int ( ( n - 1 ) / 2 ) ] != x ) : NEW_LINE INDENT a [ n - 1 ] = x NEW_LINE n += 1 NEW_LINE a . sort ( reverse = False ) NEW_LINE k += 1 NEW_LINE DEDENT return k NEW_LINE DEDENT
def minNumber ( a , n , x ) : NEW_LINE INDENT l = 0 NEW_LINE h = 0 NEW_LINE e = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == x : NEW_LINE INDENT e += 1 NEW_LINE DEDENT elif a [ i ] > x : NEW_LINE INDENT h += 1 NEW_LINE DEDENT elif a [ i ] < x : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE if l > h : NEW_LINE INDENT ans = l - h NEW_LINE DEDENT elif l < h : NEW_LINE INDENT ans = h - l - 1 NEW_LINE DEDENT return ans + 1 - e NEW_LINE DEDENT
def fun ( x ) : NEW_LINE INDENT y = ( x // 4 ) * 4 NEW_LINE ans = 0 NEW_LINE for i in range ( y , x + 1 ) : NEW_LINE INDENT ans ^= i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def query ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = ( x + 1 ) // 2 NEW_LINE if x % 2 == 0 : NEW_LINE INDENT return ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * fun ( k ) ) NEW_LINE DEDENT DEDENT
def preprocess ( arr , N , left , right ) : NEW_LINE INDENT left [ 0 ] = 0 NEW_LINE lastIncr = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT lastIncr = i NEW_LINE DEDENT left [ i ] = lastIncr NEW_LINE DEDENT right [ N - 1 ] = N - 1 NEW_LINE firstDecr = N - 1 NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT firstDecr = i NEW_LINE DEDENT right [ i ] = firstDecr NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT
def isSubarrayMountainForm ( arr , left , right , L , R ) : NEW_LINE INDENT return ( right [ L ] >= left [ R ] ) NEW_LINE DEDENT
def sieveOfEratosthenes ( isPrime ) : NEW_LINE INDENT isPrime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if p * p > MAX : NEW_LINE INDENT break NEW_LINE DEDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def getMid ( s , e ) : NEW_LINE INDENT return s + ( e - s ) // 2 NEW_LINE DEDENT
def queryPrimesUtil ( st , ss , se , qs , qe , index ) : NEW_LINE INDENT if ( qs <= ss and qe >= se ) : NEW_LINE INDENT return st [ index ] NEW_LINE DEDENT if ( se < qs or ss > qe ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE return queryPrimesUtil ( st , ss , mid , qs , qe , 2 * index + 1 ) + queryPrimesUtil ( st , mid + 1 , se , qs , qe , 2 * index + 2 ) NEW_LINE DEDENT
def updateValueUtil ( st , ss , se , i , diff , si ) : NEW_LINE INDENT if ( i < ss or i > se ) : NEW_LINE INDENT return NEW_LINE DEDENT st [ si ] = st [ si ] + diff NEW_LINE if ( se != ss ) : NEW_LINE INDENT mid = getMid ( ss , se ) NEW_LINE updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) NEW_LINE updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) NEW_LINE DEDENT DEDENT
def updateValue ( arr , st , n , i , new_val , isPrime ) : NEW_LINE INDENT if ( i < 0 or i > n - 1 ) : NEW_LINE INDENT printf ( "Invalid Input" ) NEW_LINE return NEW_LINE DEDENT diff , oldValue = 0 , 0 NEW_LINE oldValue = arr [ i ] NEW_LINE arr [ i ] = new_val NEW_LINE if ( isPrime [ oldValue ] and isPrime [ new_val ] ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( ( not isPrime [ oldValue ] ) and ( not isPrime [ new_val ] ) ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( isPrime [ oldValue ] and not isPrime [ new_val ] ) : NEW_LINE INDENT diff = - 1 NEW_LINE DEDENT if ( not isPrime [ oldValue ] and isPrime [ new_val ] ) : NEW_LINE INDENT diff = 1 NEW_LINE DEDENT updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) NEW_LINE DEDENT
def constructSTUtil ( arr , ss , se , st , si , isPrime ) : NEW_LINE INDENT if ( ss == se ) : NEW_LINE INDENT if ( isPrime [ arr [ ss ] ] ) : NEW_LINE INDENT st [ si ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT st [ si ] = 0 NEW_LINE DEDENT return st [ si ] NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 , isPrime ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 , isPrime ) NEW_LINE return st [ si ] NEW_LINE DEDENT
def checkEVENodd ( arr , n , l , r ) : NEW_LINE INDENT if ( arr [ r ] == 1 ) : NEW_LINE INDENT print ( "odd" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "even" ) NEW_LINE DEDENT DEDENT
def findMean ( arr , l , r ) : NEW_LINE INDENT sum , count = 0 , 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT mean = math . floor ( sum / count ) NEW_LINE return mean NEW_LINE DEDENT
def calculatePrefixSum ( arr , n ) : NEW_LINE INDENT prefixSum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT
def findMean ( l , r ) : NEW_LINE INDENT if ( l == 0 ) : NEW_LINE INDENT return mt . floor ( prefixSum [ r ] / ( r + 1 ) ) NEW_LINE DEDENT return ( mt . floor ( ( prefixSum [ r ] - prefixSum [ l - 1 ] ) / ( r - l + 1 ) ) ) NEW_LINE DEDENT
def updateQuery ( arr , n , q , l , r , k ) : NEW_LINE INDENT if ( q == 0 ) : NEW_LINE INDENT arr [ l - 1 ] += k NEW_LINE arr [ r ] += - k NEW_LINE DEDENT else : NEW_LINE INDENT arr [ l - 1 ] += - k NEW_LINE arr [ r ] += k NEW_LINE DEDENT return NEW_LINE DEDENT
def generateArray ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE DEDENT return NEW_LINE DEDENT
def calculateProduct ( A , L , R , P ) : NEW_LINE INDENT L = L - 1 NEW_LINE R = R - 1 NEW_LINE ans = 1 NEW_LINE for i in range ( R + 1 ) : NEW_LINE INDENT ans = ans * A [ i ] NEW_LINE ans = ans % P NEW_LINE DEDENT return ans NEW_LINE DEDENT
def modInverse ( a , m ) : NEW_LINE INDENT m0 , x0 , x1 = m , 0 , 1 NEW_LINE if m == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT while a > 1 : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m , a = a % m , t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if x1 < 0 : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT
def calculate_Pre_Product ( A , N , P ) : NEW_LINE INDENT pre_product [ 0 ] = A [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT pre_product [ i ] = pre_product [ i - 1 ] * A [ i ] NEW_LINE pre_product [ i ] = pre_product [ i ] % P NEW_LINE DEDENT DEDENT
def calculate_inverse_product ( A , N , P ) : NEW_LINE INDENT inverse_product [ 0 ] = modInverse ( pre_product [ 0 ] , P ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT inverse_product [ i ] = modInverse ( pre_product [ i ] , P ) NEW_LINE DEDENT DEDENT
def calculateProduct ( A , L , R , P ) : NEW_LINE INDENT L = L - 1 NEW_LINE R = R - 1 NEW_LINE ans = 0 NEW_LINE if L == 0 : NEW_LINE INDENT ans = pre_product [ R ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = pre_product [ R ] * inverse_product [ L - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def buildPrefix ( ) : NEW_LINE INDENT prime = [ 1 ] * ( MAX + 1 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= MAX ) : NEW_LINE INDENT prime [ i ] = 0 NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT prefix [ p ] = prefix [ p - 1 ] NEW_LINE if ( prime [ p ] == 1 ) : NEW_LINE INDENT prefix [ p ] += 1 NEW_LINE DEDENT DEDENT DEDENT
def query ( L , R ) : NEW_LINE INDENT return prefix [ R ] - prefix [ L - 1 ] NEW_LINE DEDENT
def command ( brr , a , b ) : NEW_LINE INDENT arr [ a ] ^= 1 NEW_LINE arr [ b + 1 ] ^= 1 NEW_LINE DEDENT
def incrementByD ( arr , q_arr , n , m , d ) : NEW_LINE INDENT sum = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT sum [ q_arr [ i ] [ 0 ] ] += d NEW_LINE if ( ( q_arr [ i ] [ 1 ] + 1 ) < n ) : NEW_LINE INDENT sum [ q_arr [ i ] [ 1 ] + 1 ] -= d NEW_LINE DEDENT DEDENT arr [ 0 ] += sum [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum [ i ] += sum [ i - 1 ] NEW_LINE arr [ i ] += sum [ i ] NEW_LINE DEDENT DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in arr : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def probability ( a , b , size1 , size2 ) : NEW_LINE INDENT max1 = - ( sys . maxsize - 1 ) NEW_LINE count1 = 0 NEW_LINE for i in range ( size1 ) : NEW_LINE INDENT if a [ i ] > max1 : NEW_LINE INDENT count1 = 1 NEW_LINE DEDENT elif a [ i ] == max1 : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT DEDENT max2 = - ( sys . maxsize - 1 ) NEW_LINE count2 = 0 NEW_LINE for i in range ( size2 ) : NEW_LINE INDENT if b [ i ] > max2 : NEW_LINE INDENT max2 = b [ i ] NEW_LINE count2 = 1 NEW_LINE DEDENT elif b [ i ] == max2 : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT DEDENT return round ( ( count1 * count2 ) / ( size1 * size2 ) , 6 ) NEW_LINE DEDENT
def countDe ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE v = arr . copy ( ) NEW_LINE arr . sort ( ) NEW_LINE count1 = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] != v [ i ] ) : NEW_LINE INDENT count1 = count1 + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT arr . sort ( reverse = True ) NEW_LINE count2 = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] != v [ i ] ) : NEW_LINE INDENT count2 = count2 + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return ( min ( count1 , count2 ) ) NEW_LINE DEDENT
def printMinimumProduct ( arr , n ) : NEW_LINE INDENT first_min = min ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE second_min = max ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] < first_min ) : NEW_LINE INDENT second_min = first_min NEW_LINE first_min = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < second_min ) : NEW_LINE INDENT second_min = arr [ i ] NEW_LINE DEDENT DEDENT return first_min * second_min NEW_LINE DEDENT
def noOfTriples ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == arr [ 2 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if arr [ 0 ] == arr [ 2 ] : NEW_LINE INDENT return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 NEW_LINE DEDENT elif arr [ 1 ] == arr [ 2 ] : NEW_LINE INDENT return ( count - 1 ) * ( count ) / 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
def checkReverse ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp [ i ] = arr [ i ] NEW_LINE DEDENT temp . sort ( ) NEW_LINE for front in range ( n ) : NEW_LINE INDENT if temp [ front ] != arr [ front ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for back in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if temp [ back ] != arr [ back ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if front >= back : NEW_LINE INDENT return True NEW_LINE DEDENT while front != back : NEW_LINE INDENT front += 1 NEW_LINE if arr [ front - 1 ] < arr [ front ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def checkReverse ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i - 1 ] < arr [ i ] : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT j = i NEW_LINE while ( j < n and arr [ j ] < arr [ j - 1 ] ) : NEW_LINE INDENT if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT k = j NEW_LINE if ( arr [ k ] < arr [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( k > 1 and k < n ) : NEW_LINE INDENT if ( arr [ k ] < arr [ k - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT k += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def sortExceptUandL ( a , l , u , n ) : NEW_LINE INDENT b = [ 0 ] * ( n - ( u - l + 1 ) ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT b [ i ] = a [ i ] NEW_LINE DEDENT for i in range ( u + 1 , n ) : NEW_LINE INDENT b [ l + ( i - ( u + 1 ) ) ] = a [ i ] NEW_LINE DEDENT b . sort ( ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT a [ i ] = b [ i ] NEW_LINE DEDENT for i in range ( u + 1 , n ) : NEW_LINE INDENT a [ i ] = b [ l + ( i - ( u + 1 ) ) ] NEW_LINE DEDENT DEDENT
def findMinSwaps ( arr , n ) : NEW_LINE INDENT noOfZeroes = [ 0 ] * n NEW_LINE count = 0 NEW_LINE noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT noOfZeroes [ i ] = noOfZeroes [ i + 1 ] NEW_LINE if ( arr [ i ] == 0 ) : NEW_LINE INDENT noOfZeroes [ i ] = noOfZeroes [ i ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count = count + noOfZeroes [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = "->" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT
def sortlist ( arr , N , head ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT hash [ temp . data ] = hash . get ( temp . data , 0 ) + 1 NEW_LINE temp = temp . next NEW_LINE DEDENT temp = head NEW_LINE for i in range ( N ) : NEW_LINE INDENT frequency = hash . get ( arr [ i ] , 0 ) NEW_LINE while ( frequency > 0 ) : NEW_LINE INDENT frequency = frequency - 1 NEW_LINE temp . data = arr [ i ] NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def min_noOf_operation ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k NEW_LINE if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) : NEW_LINE INDENT noOfSubtraction += 1 NEW_LINE DEDENT arr [ i ] = arr [ i ] - k * noOfSubtraction NEW_LINE DEDENT res = res + noOfSubtraction NEW_LINE DEDENT return int ( res ) NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def countPairs ( a , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and a [ j ] - a [ i ] < k ) : NEW_LINE INDENT res += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def sortedMerge ( a , b , res , n , m ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE i , j , k = 0 , 0 , 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( a [ i ] <= b [ j ] ) : NEW_LINE INDENT res [ k ] = a [ i ] NEW_LINE i += 1 NEW_LINE k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res [ k ] = b [ j ] NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT res [ k ] = a [ i ] NEW_LINE i += 1 NEW_LINE k += 1 NEW_LINE DEDENT while ( j < m ) : NEW_LINE INDENT res [ k ] = b [ j ] NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT
def findMaxPairs ( a , b , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE flag = [ False ] * n NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( abs ( a [ i ] - b [ j ] ) <= k and flag [ j ] == False ) : NEW_LINE INDENT result += 1 NEW_LINE flag [ j ] = True NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def findMaxPairs ( a , b , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE result = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if j < n : NEW_LINE INDENT if abs ( a [ i ] - b [ j ] ) <= k : NEW_LINE INDENT result += 1 NEW_LINE j += 1 NEW_LINE DEDENT elif a [ i ] > b [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def sumOfMinAbsDifferences ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE sum += abs ( arr [ 0 ] - arr [ 1 ] ) NEW_LINE sum += abs ( arr [ n - 1 ] - arr [ n - 2 ] ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT sum += min ( abs ( arr [ i ] - arr [ i - 1 ] ) , abs ( arr [ i ] - arr [ i + 1 ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findSmallestDifference ( A , B , m , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE result = sys . maxsize NEW_LINE while ( a < m and b < n ) : NEW_LINE INDENT if ( abs ( A [ a ] - B [ b ] ) < result ) : NEW_LINE INDENT result = abs ( A [ a ] - B [ b ] ) NEW_LINE DEDENT if ( A [ a ] < B [ b ] ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def arraySortedOrNot ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findLarger ( arr , n ) : NEW_LINE INDENT x = sorted ( arr ) NEW_LINE for i in range ( n / 2 , n ) : NEW_LINE INDENT print ( x [ i ] ) , NEW_LINE DEDENT DEDENT
def minSwapsToSort ( arr , n ) : NEW_LINE INDENT arrPos = [ [ 0 for x in range ( 2 ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arrPos [ i ] [ 0 ] = arr [ i ] NEW_LINE arrPos [ i ] [ 1 ] = i NEW_LINE DEDENT arrPos . sort ( ) NEW_LINE vis = [ False ] * ( n ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] or arrPos [ i ] [ 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT cycle_size = 0 NEW_LINE j = i NEW_LINE while ( not vis [ j ] ) : NEW_LINE INDENT vis [ j ] = 1 NEW_LINE j = arrPos [ j ] [ 1 ] NEW_LINE cycle_size += 1 NEW_LINE DEDENT ans += ( cycle_size - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minSwapToMakeArraySame ( a , b , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ b [ i ] ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT b [ i ] = mp [ a [ i ] ] NEW_LINE DEDENT return minSwapsToSort ( b , n ) NEW_LINE DEDENT
def singleelement ( arr , n ) : NEW_LINE INDENT low = 0 NEW_LINE high = n - 2 NEW_LINE mid = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] == arr [ mid ^ 1 ] ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return arr [ low ] NEW_LINE DEDENT
def getMissingNo ( a , n ) : NEW_LINE INDENT n_elements_sum = n * ( n + 1 ) // 2 NEW_LINE return n_elements_sum - sum ( a ) NEW_LINE DEDENT
def countOccurrences ( arr , n , x ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x == arr [ i ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r < l ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( l + ( r - l ) / 2 ) NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ mid ] > x : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT
def countOccurrences ( arr , n , x ) : NEW_LINE INDENT ind = binarySearch ( arr , 0 , n - 1 , x ) NEW_LINE if ind == - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 1 NEW_LINE left = ind - 1 NEW_LINE while ( left >= 0 and arr [ left ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE left -= 1 NEW_LINE DEDENT right = ind + 1 NEW_LINE while ( right < n and arr [ right ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE right += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l , res_r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( 'The closest pair is {} and {}' . format ( arr [ res_l ] , arr [ res_r ] ) ) NEW_LINE DEDENT
def countOnes ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if arr [ mid ] == 1 : NEW_LINE INDENT return countOnes ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT return countOnes ( arr , low , mid - 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def findMissingUtil ( arr1 , arr2 , N ) : NEW_LINE INDENT if N == 1 : NEW_LINE INDENT return arr1 [ 0 ] NEW_LINE DEDENT if arr1 [ 0 ] != arr2 [ 0 ] : NEW_LINE INDENT return arr1 [ 0 ] NEW_LINE DEDENT lo = 0 NEW_LINE hi = N - 1 NEW_LINE while ( lo < hi ) : NEW_LINE INDENT mid = ( lo + hi ) / 2 NEW_LINE if arr1 [ mid ] == arr2 [ mid ] : NEW_LINE INDENT lo = mid NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid NEW_LINE DEDENT if lo == hi - 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return arr1 [ hi ] NEW_LINE DEDENT
def printTwoElements ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if arr [ abs ( arr [ i ] ) - 1 ] > 0 : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( "The repeating element is" , abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT print ( "and the missing element is" , i + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def findFourElements ( A , n , X ) : NEW_LINE INDENT for i in range ( 0 , n - 3 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 2 ) : NEW_LINE INDENT for k in range ( j + 1 , n - 1 ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if A [ i ] + A [ j ] + A [ k ] + A [ l ] == X : NEW_LINE INDENT print ( "%d, %d, %d, %d" % ( A [ i ] , A [ j ] , A [ k ] , A [ l ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
def findFourElements ( arr , n , X ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = [ i , j ] NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT summ = arr [ i ] + arr [ j ] NEW_LINE if ( X - summ ) in mp : NEW_LINE INDENT p = mp [ X - summ ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT print ( arr [ i ] , ", " , arr [ j ] , ", " , arr [ p [ 0 ] ] , ", " , arr [ p [ 1 ] ] , sep = "" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def findMajority ( arr , n ) : NEW_LINE INDENT return arr [ int ( n / 2 ) ] NEW_LINE DEDENT
def minAdjDifference ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT res = abs ( arr [ 1 ] - arr [ 0 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT res = min ( res , abs ( arr [ i ] - arr [ i - 1 ] ) ) NEW_LINE DEDENT res = min ( res , abs ( arr [ n - 1 ] - arr [ 0 ] ) ) NEW_LINE print ( "Min Difference = " , res ) NEW_LINE DEDENT
def getMin ( arr , n ) : NEW_LINE INDENT return min ( arr ) NEW_LINE DEDENT
def getMax ( arr , n ) : NEW_LINE INDENT return max ( arr ) NEW_LINE DEDENT
def deleteElement ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i < n ) : NEW_LINE INDENT n = n - 1 NEW_LINE for j in range ( i , n , 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def deleteElement ( arr , n , x ) : NEW_LINE INDENT if arr [ n - 1 ] == x : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT prev = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] != x : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev NEW_LINE prev = curr NEW_LINE DEDENT DEDENT if i < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr [ i ] = prev NEW_LINE return n - 1 NEW_LINE DEDENT
def maxWater ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT left = arr [ i ] NEW_LINE for j in range ( i ) : NEW_LINE INDENT left = max ( left , arr [ j ] ) NEW_LINE DEDENT right = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT right = max ( right , arr [ j ] ) NEW_LINE DEDENT res = res + ( min ( left , right ) - arr [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findWater ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE left_max = 0 NEW_LINE right_max = 0 NEW_LINE lo = 0 NEW_LINE hi = n - 1 NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT if ( arr [ lo ] < arr [ hi ] ) : NEW_LINE INDENT if ( arr [ lo ] > left_max ) : NEW_LINE INDENT left_max = arr [ lo ] NEW_LINE DEDENT else : NEW_LINE INDENT result += left_max - arr [ lo ] NEW_LINE DEDENT lo += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( arr [ hi ] > right_max ) : NEW_LINE INDENT right_max = arr [ hi ] NEW_LINE DEDENT else : NEW_LINE INDENT result += right_max - arr [ hi ] NEW_LINE DEDENT hi -= 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def maxWater ( arr , n ) : NEW_LINE INDENT size = n - 1 NEW_LINE prev = arr [ 0 ] NEW_LINE prev_index = 0 NEW_LINE water = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 1 , size + 1 ) : NEW_LINE INDENT if ( arr [ i ] >= prev ) : NEW_LINE INDENT prev = arr [ i ] NEW_LINE prev_index = i NEW_LINE temp = 0 NEW_LINE DEDENT else : NEW_LINE INDENT water += prev - arr [ i ] NEW_LINE temp += prev - arr [ i ] NEW_LINE DEDENT DEDENT if ( prev_index < size ) : NEW_LINE INDENT water -= temp NEW_LINE prev = arr [ size ] NEW_LINE for i in range ( size , prev_index - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= prev ) : NEW_LINE INDENT prev = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT water += prev - arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return water NEW_LINE DEDENT
def maxWater ( arr , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = n - 1 NEW_LINE l_max = 0 NEW_LINE r_max = 0 NEW_LINE result = 0 NEW_LINE while ( left <= right ) : NEW_LINE INDENT if r_max <= l_max : NEW_LINE INDENT result += max ( 0 , r_max - arr [ right ] ) NEW_LINE r_max = max ( r_max , arr [ right ] ) NEW_LINE right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += max ( 0 , l_max - arr [ left ] ) NEW_LINE l_max = max ( l_max , arr [ left ] ) NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def missingK ( a , k , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE count = k NEW_LINE flag = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT difference = 0 NEW_LINE if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) : NEW_LINE INDENT difference += ( a [ i + 1 ] - a [ i ] ) - 1 NEW_LINE if ( difference >= count ) : NEW_LINE INDENT ans = a [ i ] + count NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT count -= difference NEW_LINE DEDENT DEDENT DEDENT if ( flag ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def leastFrequent ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE min_count = n + 1 NEW_LINE res = - 1 NEW_LINE curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT curr_count = curr_count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( curr_count < min_count ) : NEW_LINE INDENT min_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT DEDENT if ( curr_count < min_count ) : NEW_LINE INDENT min_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def leastFrequent ( arr , n ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in Hash . keys ( ) : NEW_LINE INDENT Hash [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Hash [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT min_count = n + 1 NEW_LINE res = - 1 NEW_LINE for i in Hash : NEW_LINE INDENT if ( min_count >= Hash [ i ] ) : NEW_LINE INDENT res = i NEW_LINE min_count = Hash [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def maximumSum ( a , n ) : NEW_LINE INDENT global M NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a [ i ] . sort ( ) NEW_LINE DEDENT sum = a [ n - 1 ] [ M - 1 ] NEW_LINE prev = a [ n - 1 ] [ M - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] [ j ] < prev ) : NEW_LINE INDENT prev = a [ i ] [ j ] NEW_LINE sum += prev NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def maximumSum ( a , n ) : NEW_LINE INDENT prev = max ( max ( a ) ) NEW_LINE Sum = prev NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT max_smaller = - 10 ** 9 NEW_LINE for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] [ j ] < prev and a [ i ] [ j ] > max_smaller ) : NEW_LINE INDENT max_smaller = a [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( max_smaller == - 10 ** 9 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT prev = max_smaller NEW_LINE Sum += max_smaller NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def findValue ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == k ) : NEW_LINE INDENT k = k * 2 NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT
def findSmallest ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( a [ j ] % a [ i ] ) >= 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == n - 1 ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findSmallest ( a , n ) : NEW_LINE INDENT smallest = min_element ( a ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] % smallest >= 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return smallest NEW_LINE DEDENT
def CalculateMax ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE max_sum = arr [ n - 1 ] + arr [ n - 2 ] NEW_LINE return abs ( max_sum - min_sum ) NEW_LINE DEDENT
def printMinDiffPairs ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT arr . sort ( ) NEW_LINE minDiff = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT minDiff = min ( minDiff , arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] ) == minDiff : NEW_LINE INDENT print ( "(" + str ( arr [ i - 1 ] ) + ", " + str ( arr [ i ] ) + "), " , end = '' ) NEW_LINE DEDENT DEDENT DEDENT
def calculateDiff ( i , j , arr ) : NEW_LINE INDENT return abs ( arr [ i ] - arr [ j ] ) + abs ( i - j ) NEW_LINE DEDENT
def extrema ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT count += ( a [ i ] > a [ i - 1 ] and a [ i ] > a [ i + 1 ] ) NEW_LINE count += ( a [ i ] < a [ i - 1 ] and a [ i ] < a [ i + 1 ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def getClosest ( val1 , val2 , target ) : NEW_LINE INDENT if ( target - val1 >= val2 - target ) : NEW_LINE INDENT return val2 NEW_LINE DEDENT else : NEW_LINE INDENT return val1 NEW_LINE DEDENT DEDENT
def sum ( a , n ) : NEW_LINE INDENT maxVal = a [ 0 ] NEW_LINE maxCount = 1 NEW_LINE secondMax = sys . maxsize NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] == maxVal ) : NEW_LINE INDENT maxCount += 1 NEW_LINE DEDENT elif ( a [ i ] > maxVal ) : NEW_LINE INDENT secondMax = maxVal NEW_LINE secondMaxCount = maxCount NEW_LINE maxVal = a [ i ] NEW_LINE maxCount = 1 NEW_LINE DEDENT elif ( a [ i ] == secondMax ) : NEW_LINE INDENT secondMax = a [ i ] NEW_LINE secondMaxCount += 1 NEW_LINE DEDENT elif ( a [ i ] > secondMax ) : NEW_LINE INDENT secondMax = a [ i ] NEW_LINE secondMaxCount = 1 NEW_LINE DEDENT DEDENT if ( maxCount > 1 ) : NEW_LINE INDENT return maxCount * ( maxCount - 1 ) / 2 NEW_LINE DEDENT return secondMaxCount NEW_LINE DEDENT
def printSmall ( arr , asize , n ) : NEW_LINE INDENT copy_arr = arr . copy ( ) NEW_LINE copy_arr . sort ( ) NEW_LINE for i in range ( asize ) : NEW_LINE INDENT if binary_search ( copy_arr , low = 0 , high = n , ele = arr [ i ] ) > - 1 : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def printKMissing ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE while ( i < n and arr [ i ] <= 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT count = 0 NEW_LINE curr = 1 NEW_LINE while ( count < k and i < n ) : NEW_LINE INDENT if ( arr [ i ] != curr ) : NEW_LINE INDENT print ( str ( curr ) + " " , end = '' ) NEW_LINE count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT curr = curr + 1 NEW_LINE DEDENT while ( count < k ) : NEW_LINE INDENT print ( str ( curr ) + " " , end = '' ) NEW_LINE curr = curr + 1 NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT
def printmissingk ( arr , n , k ) : NEW_LINE INDENT d = { } NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT d [ arr [ i ] ] = arr [ i ] NEW_LINE DEDENT cnt = 1 NEW_LINE fl = 0 NEW_LINE for i in range ( n + k ) : NEW_LINE INDENT if cnt not in d : NEW_LINE INDENT fl += 1 NEW_LINE print ( cnt , end = " " ) NEW_LINE if fl == k : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT cnt += 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def minProductSubset ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT max_neg = float ( '-inf' ) NEW_LINE min_pos = float ( 'inf' ) NEW_LINE count_neg = 0 NEW_LINE count_zero = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count_zero = count_zero + 1 NEW_LINE continue NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT count_neg = count_neg + 1 NEW_LINE max_neg = max ( max_neg , a [ i ] ) NEW_LINE DEDENT if ( a [ i ] > 0 ) : NEW_LINE INDENT min_pos = min ( min_pos , a [ i ] ) NEW_LINE DEDENT prod = prod * a [ i ] NEW_LINE DEDENT if ( count_zero == n or ( count_neg == 0 and count_zero > 0 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( count_neg == 0 ) : NEW_LINE INDENT return min_pos NEW_LINE DEDENT if ( ( count_neg & 1 ) == 0 and count_neg != 0 ) : NEW_LINE INDENT prod = int ( prod / max_neg ) NEW_LINE DEDENT return prod NEW_LINE DEDENT
def countPairs ( a , n ) : NEW_LINE INDENT mn = + 2147483647 NEW_LINE mx = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mn = min ( mn , a [ i ] ) NEW_LINE mx = max ( mx , a [ i ] ) NEW_LINE DEDENT c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == mn ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if ( a [ i ] == mx ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT if ( mn == mx ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT return c1 * c2 NEW_LINE DEDENT DEDENT
def findElement ( a , n , b ) : NEW_LINE INDENT a . sort ( ) NEW_LINE mx = a [ n - 1 ] NEW_LINE while ( b < max ) : NEW_LINE INDENT if ( binary_search ( a , b , 0 , n ) != - 1 ) : NEW_LINE INDENT b *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT return b NEW_LINE DEDENT
def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = " " ) NEW_LINE node = node . next NEW_LINE DEDENT print ( "" ) NEW_LINE DEDENT
def rearrangeOddEven ( head ) : NEW_LINE INDENT odd = [ ] NEW_LINE even = [ ] NEW_LINE i = 1 NEW_LINE while ( head != None ) : NEW_LINE INDENT if ( head . data % 2 != 0 and i % 2 == 0 ) : NEW_LINE INDENT odd . append ( head ) NEW_LINE DEDENT elif ( head . data % 2 == 0 and i % 2 != 0 ) : NEW_LINE INDENT even . append ( head ) NEW_LINE DEDENT head = head . next NEW_LINE i = i + 1 NEW_LINE DEDENT while ( len ( odd ) != 0 and len ( even ) != 0 ) : NEW_LINE INDENT odd [ - 1 ] . data , even [ - 1 ] . data = even [ - 1 ] . data , odd [ - 1 ] . data NEW_LINE odd . pop ( ) NEW_LINE even . pop ( ) NEW_LINE DEDENT return head NEW_LINE DEDENT
def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = ' ' ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT
def display ( head ) : NEW_LINE INDENT curr = head NEW_LINE while ( curr != None ) : NEW_LINE INDENT print ( curr . data , end = " " ) NEW_LINE curr = curr . next NEW_LINE DEDENT DEDENT
def addWithCarry ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = head . data + addWithCarry ( head . next ) NEW_LINE head . data = int ( ( res ) % 10 ) NEW_LINE return int ( ( res ) / 10 ) NEW_LINE DEDENT
def populateArbit ( head ) : NEW_LINE INDENT global maxNode NEW_LINE if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( head . next == None ) : NEW_LINE INDENT maxNode = head NEW_LINE return NEW_LINE DEDENT populateArbit ( head . next ) NEW_LINE head . arbit = maxNode NEW_LINE if ( head . data > maxNode . data and maxNode . data != None ) : NEW_LINE INDENT maxNode = head NEW_LINE DEDENT return NEW_LINE DEDENT
def deleteLast ( head , x ) : NEW_LINE INDENT temp = head NEW_LINE ptr = None NEW_LINE while ( temp != None ) : NEW_LINE INDENT if ( temp . data == x ) : NEW_LINE INDENT ptr = temp NEW_LINE DEDENT temp = temp . next NEW_LINE DEDENT if ( ptr != None and ptr . next == None ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp . next != ptr ) : NEW_LINE INDENT temp = temp . next NEW_LINE DEDENT temp . next = None NEW_LINE DEDENT if ( ptr != None and ptr . next != None ) : NEW_LINE INDENT ptr . data = ptr . next . data NEW_LINE temp = ptr . next NEW_LINE ptr . next = ptr . next . next NEW_LINE DEDENT return head NEW_LINE DEDENT
def getLength ( Node ) : NEW_LINE INDENT size = 0 NEW_LINE while ( Node != None ) : NEW_LINE INDENT Node = Node . next NEW_LINE size = size + 1 NEW_LINE DEDENT return size NEW_LINE DEDENT
def isPalindromeUtil ( head , loop_start ) : NEW_LINE INDENT ptr = head NEW_LINE s = [ ] NEW_LINE count = 0 NEW_LINE while ( ptr != loop_start or count != 1 ) : NEW_LINE INDENT s . append ( ptr . data ) NEW_LINE if ( ptr == loop_start ) : NEW_LINE INDENT count = 1 NEW_LINE DEDENT ptr = ptr . next NEW_LINE DEDENT ptr = head NEW_LINE count = 0 NEW_LINE while ( ptr != loop_start or count != 1 ) : NEW_LINE INDENT if ( ptr . data == s [ - 1 ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ptr == loop_start ) : NEW_LINE INDENT count = 1 NEW_LINE DEDENT ptr = ptr . next NEW_LINE DEDENT return True NEW_LINE DEDENT
def isPalindrome ( head ) : NEW_LINE INDENT loop_start = detectAndgetLoopstarting ( head ) NEW_LINE return isPalindromeUtil ( head , loop_start ) NEW_LINE DEDENT
def countCommon ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a != None and b != None ) : NEW_LINE INDENT if ( a . data == b . data ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT a = a . next NEW_LINE b = b . next NEW_LINE DEDENT return count NEW_LINE DEDENT
def maxPalindrome ( head ) : NEW_LINE INDENT result = 0 NEW_LINE prev = None NEW_LINE curr = head NEW_LINE while ( curr != None ) : NEW_LINE INDENT next = curr . next NEW_LINE curr . next = prev NEW_LINE result = max ( result , 2 * countCommon ( prev , next ) + 1 ) NEW_LINE result = max ( result , 2 * countCommon ( curr , next ) ) NEW_LINE prev = curr NEW_LINE curr = next NEW_LINE DEDENT return result NEW_LINE DEDENT
def displayList ( head ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( temp . data , end = ' ' ) NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT
def LinkedListLength ( self ) : NEW_LINE INDENT while ( self . head != None and self . head . next != None ) : NEW_LINE INDENT self . head = self . head . next . next NEW_LINE DEDENT if ( self . head == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def push ( self , info ) : NEW_LINE INDENT node = Node ( info ) NEW_LINE node . next = ( self . head ) NEW_LINE ( self . head ) = node NEW_LINE DEDENT
def sumOfLastN_NodesUtil ( head , n ) : NEW_LINE INDENT global sum NEW_LINE if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT st = [ ] NEW_LINE sum = 0 NEW_LINE while ( head != None ) : NEW_LINE INDENT st . append ( head . data ) NEW_LINE head = head . next NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum += st [ 0 ] NEW_LINE st . pop ( 0 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def push ( head_ref , new_data ) : NEW_LINE INDENT new_Node = Node ( new_data ) NEW_LINE new_Node . data = new_data NEW_LINE new_Node . next = head_ref NEW_LINE head_ref = new_Node NEW_LINE head = head_ref NEW_LINE return head NEW_LINE DEDENT
def sumOfLastN_NodesUtil ( head , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = 0 NEW_LINE len = 0 NEW_LINE temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT len += 1 NEW_LINE temp = temp . next NEW_LINE DEDENT c = len - n NEW_LINE temp = head NEW_LINE while ( temp != None and c > 0 ) : NEW_LINE INDENT temp = temp . next NEW_LINE c -= 1 NEW_LINE DEDENT while ( temp != None ) : NEW_LINE INDENT sum += temp . data NEW_LINE temp = temp . next NEW_LINE DEDENT return sum NEW_LINE DEDENT
def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = " " ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT
def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = " " ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT
def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = " " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT
def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = " " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT
def insertAfterNthNode ( head , n , x ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT newNode = getNode ( x ) NEW_LINE slow_ptr = head NEW_LINE fast_ptr = head NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT fast_ptr = fast_ptr . next NEW_LINE DEDENT while ( fast_ptr . next != None ) : NEW_LINE INDENT slow_ptr = slow_ptr . next NEW_LINE fast_ptr = fast_ptr . next NEW_LINE DEDENT newNode . next = slow_ptr . next NEW_LINE slow_ptr . next = newNode NEW_LINE DEDENT
def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = ' ' ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT
def printList ( head ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp . next != head ) : NEW_LINE INDENT print ( temp . data , end = " " ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data , end = " " ) NEW_LINE DEDENT
def printList ( head ) : NEW_LINE INDENT while ( head . next != None ) : NEW_LINE INDENT print ( head . data , end = "<-->" ) NEW_LINE head = head . next NEW_LINE DEDENT print ( head . data ) NEW_LINE DEDENT
def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = " " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT
def isPalindrome ( left ) : NEW_LINE INDENT if left == None : NEW_LINE INDENT return True NEW_LINE DEDENT right = left NEW_LINE while right . next != None : NEW_LINE INDENT right = right . next NEW_LINE DEDENT while left != right : NEW_LINE INDENT if left . data != right . data : NEW_LINE INDENT return False NEW_LINE DEDENT left = left . next NEW_LINE right = right . prev NEW_LINE DEDENT return True NEW_LINE DEDENT
def printKDistant ( root , k ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT if k == 0 : NEW_LINE INDENT print root . data , NEW_LINE DEDENT else : NEW_LINE INDENT printKDistant ( root . left , k - 1 ) NEW_LINE printKDistant ( root . right , k - 1 ) NEW_LINE DEDENT DEDENT
def kDistantFromLeafUtil ( node , path , visited , pathLen , k ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT path [ pathLen ] = node . key NEW_LINE visited [ pathLen ] = False NEW_LINE pathLen += 1 NEW_LINE if ( node . left == None and node . right == None and pathLen - k - 1 >= 0 and visited [ pathLen - k - 1 ] == False ) : NEW_LINE INDENT print ( path [ pathLen - k - 1 ] , end = " " ) NEW_LINE visited [ pathLen - k - 1 ] = True NEW_LINE return NEW_LINE DEDENT kDistantFromLeafUtil ( node . left , path , visited , pathLen , k ) NEW_LINE kDistantFromLeafUtil ( node . right , path , visited , pathLen , k ) NEW_LINE DEDENT
def printKDistantfromLeaf ( node , k ) : NEW_LINE INDENT global MAX_HEIGHT NEW_LINE path = [ None ] * MAX_HEIGHT NEW_LINE visited = [ False ] * MAX_HEIGHT NEW_LINE kDistantFromLeafUtil ( node , path , visited , 0 , k ) NEW_LINE DEDENT
def rotate ( arr , N , X ) : NEW_LINE INDENT nextPower = 1 NEW_LINE while ( nextPower <= N ) : NEW_LINE INDENT nextPower *= 2 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT ans = nextPower - N NEW_LINE return ans NEW_LINE DEDENT prevPower = nextPower // 2 NEW_LINE return 2 * ( N - prevPower ) + 1 NEW_LINE DEDENT
def performSwap ( mat , i , j ) : NEW_LINE INDENT N = len ( mat ) NEW_LINE ei = N - 1 - i NEW_LINE ej = N - 1 - j NEW_LINE temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ ej ] [ i ] NEW_LINE mat [ ej ] [ i ] = mat [ ei ] [ ej ] NEW_LINE mat [ ei ] [ ej ] = mat [ j ] [ ei ] NEW_LINE mat [ j ] [ ei ] = temp NEW_LINE DEDENT
def rotate ( mat , N , K ) : NEW_LINE INDENT K = K % 4 NEW_LINE while ( K > 0 ) : NEW_LINE INDENT for i in range ( int ( N / 2 ) ) : NEW_LINE INDENT for j in range ( i , N - i - 1 ) : NEW_LINE INDENT if ( i != j and ( i + j ) != N - 1 ) : NEW_LINE INDENT performSwap ( mat , i , j ) NEW_LINE DEDENT DEDENT DEDENT K -= 1 NEW_LINE DEDENT printMat ( mat ) NEW_LINE DEDENT
def findMaximumZeros ( st , n ) : NEW_LINE INDENT c0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( st [ i ] == '0' ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT DEDENT if ( c0 == n ) : NEW_LINE INDENT print ( n ) NEW_LINE return NEW_LINE DEDENT s = st + st NEW_LINE mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cs = 0 NEW_LINE ce = 0 NEW_LINE for j in range ( i , i + n ) : NEW_LINE INDENT if ( s [ j ] == '0' ) : NEW_LINE INDENT cs += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( i + n - 1 , i - 1 , - 1 ) : NEW_LINE INDENT if ( s [ j ] == '0' ) : NEW_LINE INDENT ce += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT val = cs + ce NEW_LINE mx = max ( val , mx ) NEW_LINE DEDENT print ( mx ) NEW_LINE DEDENT
def findMaximumZeros ( string , n ) : NEW_LINE INDENT c0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT DEDENT if ( c0 == n ) : NEW_LINE INDENT print ( n , end = "" ) NEW_LINE return NEW_LINE DEDENT mx = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mx = max ( mx , cnt ) NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT mx = max ( mx , cnt ) NEW_LINE start = 0 NEW_LINE end = n - 1 NEW_LINE cnt = 0 NEW_LINE while ( string [ start ] != '1' and start < n ) : NEW_LINE INDENT cnt += 1 NEW_LINE start += 1 NEW_LINE DEDENT while ( string [ end ] != '1' and end >= 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE end -= 1 NEW_LINE DEDENT mx = max ( mx , cnt ) NEW_LINE print ( mx , end = "" ) NEW_LINE DEDENT
def getLeafCount ( node ) : NEW_LINE INDENT if ( not node ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT q = Queue ( ) NEW_LINE count = 0 NEW_LINE q . put ( node ) NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT temp = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . put ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . put ( temp . right ) NEW_LINE DEDENT if ( temp . left == None and temp . right == None ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def rotateArray ( arr , N ) : NEW_LINE INDENT v = arr NEW_LINE v . sort ( reverse = False ) NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT x = arr [ N - 1 ] NEW_LINE i = N - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE arr [ 0 ] = x NEW_LINE i -= 1 NEW_LINE DEDENT if ( arr == v ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "NO" ) NEW_LINE DEDENT
def numberOfDigit ( N ) : NEW_LINE INDENT digit = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT digit += 1 NEW_LINE N //= 10 NEW_LINE DEDENT return digit NEW_LINE DEDENT
def rotateNumberByK ( N , K ) : NEW_LINE INDENT X = numberOfDigit ( N ) NEW_LINE K = ( ( K % X ) + X ) % X NEW_LINE left_no = N // pow ( 10 , X - K ) NEW_LINE N = N % pow ( 10 , X - K ) NEW_LINE left_digit = numberOfDigit ( left_no ) NEW_LINE N = N * pow ( 10 , left_digit ) + left_no NEW_LINE print ( N ) NEW_LINE DEDENT
def minMovesToSort ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE index = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE index = i NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT elif ( count == N - 1 ) : NEW_LINE INDENT print ( N - 1 ) NEW_LINE DEDENT elif ( count == 1 and arr [ 0 ] <= arr [ N - 1 ] ) : NEW_LINE INDENT print ( index + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def findMaximumDiagonalSumOMatrixf ( A ) : NEW_LINE INDENT maxDiagonalSum = - sys . maxsize - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT curr += A [ j ] [ ( i + j ) % N ] NEW_LINE DEDENT maxDiagonalSum = max ( maxDiagonalSum , curr ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT curr = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT curr += A [ ( i + j ) % N ] [ j ] NEW_LINE DEDENT maxDiagonalSum = max ( maxDiagonalSum , curr ) NEW_LINE DEDENT return maxDiagonalSum NEW_LINE DEDENT
def countLeaves ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( node . left == None and node . right == None ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return countLeaves ( node . left ) + countLeaves ( node . right ) NEW_LINE DEDENT
def MaxSum ( arr , n , k ) : NEW_LINE INDENT i , max_sum = 0 , 0 NEW_LINE sum = 0 NEW_LINE while i < k : NEW_LINE INDENT sum += arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT max_sum = sum NEW_LINE while ( i < n ) : NEW_LINE INDENT sum = sum - arr [ i - k ] + arr [ i ] NEW_LINE if ( max_sum < sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return max_sum NEW_LINE DEDENT
def gcd ( n1 , n2 ) : NEW_LINE INDENT if ( n2 == 0 ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( n2 , n1 % n2 ) NEW_LINE DEDENT DEDENT
def RotateArr ( arr , n , d ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE d = d % n NEW_LINE no_of_sets = gcd ( d , n ) NEW_LINE for i in range ( no_of_sets ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE j = i NEW_LINE while ( True ) : NEW_LINE INDENT k = j + d NEW_LINE if ( k >= n ) : NEW_LINE INDENT k = k - n NEW_LINE DEDENT if ( k == i ) : NEW_LINE INDENT break NEW_LINE DEDENT arr [ j ] = arr [ k ] NEW_LINE j = k NEW_LINE DEDENT arr [ j ] = temp NEW_LINE DEDENT return arr NEW_LINE DEDENT
def getMinimumRemoval ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE ans = n NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT freqEven = { } NEW_LINE freqOdd = { } NEW_LINE for ch in range ( ord ( 'a' ) , ord ( 'z' ) + 1 ) : NEW_LINE INDENT freqEven [ chr ( ch ) ] = 0 NEW_LINE freqOdd [ chr ( ch ) ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT if str [ i ] in freqEven : NEW_LINE INDENT freqEven [ str [ i ] ] += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if str [ i ] in freqOdd : NEW_LINE INDENT freqOdd [ str [ i ] ] += 1 NEW_LINE DEDENT DEDENT DEDENT evenMax = 0 NEW_LINE oddMax = 0 NEW_LINE for ch in range ( ord ( 'a' ) , ord ( 'z' ) + 1 ) : NEW_LINE INDENT evenMax = max ( evenMax , freqEven [ chr ( ch ) ] ) NEW_LINE oddMax = max ( oddMax , freqOdd [ chr ( ch ) ] ) NEW_LINE DEDENT ans = ans - evenMax - oddMax NEW_LINE DEDENT else : NEW_LINE INDENT freq = { } NEW_LINE for ch in range ( 'a' , 'z' ) : NEW_LINE INDENT freq [ chr ( ch ) ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if str [ i ] in freq : NEW_LINE INDENT freq [ str [ i ] ] += 1 NEW_LINE DEDENT DEDENT strMax = 0 NEW_LINE for ch in range ( 'a' , 'z' ) : NEW_LINE INDENT strMax = max ( strMax , freq [ chr ( ch ) ] ) NEW_LINE DEDENT ans = ans - strMax NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findAltSubSeq ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = - sys . maxsize - 1 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT cur , f = 0 , 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if ( f == 0 and ord ( s [ k ] ) - ord ( '0' ) == i ) : NEW_LINE INDENT f = 1 NEW_LINE cur += 1 NEW_LINE DEDENT elif ( f == 1 and ord ( s [ k ] ) - ord ( '0' ) == j ) : NEW_LINE INDENT f = 0 NEW_LINE cur += 1 NEW_LINE DEDENT DEDENT if i != j and cur % 2 == 1 : NEW_LINE INDENT cur -= 1 NEW_LINE DEDENT ans = max ( cur , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def getFirstElement ( a , N , K , M ) : NEW_LINE INDENT K %= N NEW_LINE if ( K >= M ) : NEW_LINE INDENT index = ( N - K ) + ( M - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT index = ( M - K - 1 ) NEW_LINE DEDENT result = a [ index ] NEW_LINE return result NEW_LINE DEDENT
def getFirstElement ( a , N , K , M ) : NEW_LINE INDENT K %= N NEW_LINE index = ( K + M - 1 ) % N NEW_LINE result = a [ index ] NEW_LINE return result NEW_LINE DEDENT
def left_rotate ( arr ) : NEW_LINE INDENT last = arr [ 1 ] NEW_LINE for i in range ( 3 , len ( arr ) , 2 ) : NEW_LINE INDENT arr [ i - 2 ] = arr [ i ] NEW_LINE DEDENT arr [ len ( arr ) - 1 ] = last NEW_LINE DEDENT
def right_rotate ( arr ) : NEW_LINE INDENT start = arr [ len ( arr ) - 2 ] NEW_LINE for i in range ( len ( arr ) - 4 , - 1 , - 2 ) : NEW_LINE INDENT arr [ i + 2 ] = arr [ i ] NEW_LINE DEDENT arr [ 0 ] = start NEW_LINE DEDENT
def rotate ( arr ) : NEW_LINE INDENT left_rotate ( arr ) NEW_LINE right_rotate ( arr ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def maximumMatchingPairs ( perm1 , perm2 , n ) : NEW_LINE INDENT left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE mp1 = { } NEW_LINE mp2 = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp1 [ perm1 [ i ] ] = i NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT mp2 [ perm2 [ j ] ] = j NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT idx2 = mp2 [ perm1 [ i ] ] NEW_LINE idx1 = i NEW_LINE if ( idx1 == idx2 ) : NEW_LINE INDENT left [ i ] = 0 NEW_LINE right [ i ] = 0 NEW_LINE DEDENT elif ( idx1 < idx2 ) : NEW_LINE INDENT left [ i ] = ( n - ( idx2 - idx1 ) ) NEW_LINE right [ i ] = ( idx2 - idx1 ) NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] = ( idx1 - idx2 ) NEW_LINE right [ i ] = ( n - ( idx1 - idx2 ) ) NEW_LINE DEDENT DEDENT freq1 = defaultdict ( int ) NEW_LINE freq2 = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq1 [ left [ i ] ] += 1 NEW_LINE freq2 [ right [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , max ( freq1 [ left [ i ] ] , freq2 [ right [ i ] ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countRotation ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def query ( node , l , r , start , end , a ) : NEW_LINE INDENT if ( l > end or r < start ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( start <= l and r <= end ) : NEW_LINE INDENT return seg [ node ] NEW_LINE DEDENT mid = ( l + r ) // 2 NEW_LINE return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) NEW_LINE DEDENT
def isConversionPossible ( s1 , s2 , x ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE s1 = list ( s1 ) NEW_LINE s2 = list ( s2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT diff = ord ( s2 [ i ] ) - ord ( s1 [ i ] ) NEW_LINE if diff == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if diff < 0 : NEW_LINE INDENT diff = diff + 26 NEW_LINE DEDENT if diff > x : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countRotation ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( digit % 2 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = ' -> ' ) NEW_LINE node = node . next NEW_LINE DEDENT print ( "NULL" ) NEW_LINE DEDENT
def isPossible ( a , n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT flag = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( not ( a [ i ] > a [ i + 1 ] and a [ i + 1 ] > a [ i + 2 ] ) ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT flag = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( not ( a [ i ] < a [ i + 1 ] and a [ i + 1 ] < a [ i + 2 ] ) ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT val1 = sys . maxsize NEW_LINE mini = - 1 NEW_LINE val2 = - sys . maxsize NEW_LINE maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] < val1 ) : NEW_LINE INDENT mini = i NEW_LINE val1 = a [ i ] NEW_LINE DEDENT if ( a [ i ] > val2 ) : NEW_LINE INDENT maxi = i NEW_LINE val2 = a [ i ] NEW_LINE DEDENT DEDENT flag = 1 NEW_LINE for i in range ( maxi ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 and maxi + 1 == mini ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( mini , n - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT flag = 1 NEW_LINE for i in range ( mini ) : NEW_LINE INDENT if ( a [ i ] < a [ i + 1 ] ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 and maxi - 1 == mini ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( maxi , n - 1 ) : NEW_LINE INDENT if ( a [ i ] < a [ i + 1 ] ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def cntRotations ( s , n ) : NEW_LINE INDENT str = s + s NEW_LINE pre = [ 0 ] * ( 2 * n ) NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT if ( str [ i ] == 'a' or str [ i ] == 'e' or str [ i ] == 'i' or str [ i ] == 'o' or str [ i ] == 'u' ) : NEW_LINE INDENT pre [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 , 2 * n - 1 , 1 ) : NEW_LINE INDENT r = i NEW_LINE l = i - n NEW_LINE x1 = pre [ r ] NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT x1 -= pre [ l ] NEW_LINE DEDENT r = ( int ) ( i - n / 2 ) NEW_LINE left = pre [ r ] NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT left -= pre [ l ] NEW_LINE DEDENT right = x1 - left NEW_LINE if ( left > right ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def cntRotations ( s , n ) : NEW_LINE INDENT lh , rh , ans = 0 , 0 , 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT if ( s [ i ] == 'a' or s [ i ] == 'e' or s [ i ] == 'i' or s [ i ] == 'o' or s [ i ] == 'u' ) : NEW_LINE INDENT lh += 1 NEW_LINE DEDENT DEDENT for i in range ( n // 2 , n ) : NEW_LINE INDENT if ( s [ i ] == 'a' or s [ i ] == 'e' or s [ i ] == 'i' or s [ i ] == 'o' or s [ i ] == 'u' ) : NEW_LINE INDENT rh += 1 NEW_LINE DEDENT DEDENT if ( lh > rh ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i - 1 ] == 'a' or s [ i - 1 ] == 'e' or s [ i - 1 ] == 'i' or s [ i - 1 ] == 'o' or s [ i - 1 ] == 'u' ) : NEW_LINE INDENT rh += 1 NEW_LINE lh -= 1 NEW_LINE DEDENT if ( s [ ( i - 1 + n // 2 ) % n ] == 'a' or s [ ( i - 1 + n // 2 ) % n ] == 'e' or s [ ( i - 1 + n // 2 ) % n ] == 'i' or s [ ( i - 1 + n // 2 ) % n ] == 'o' or s [ ( i - 1 + n // 2 ) % n ] == 'u' ) : NEW_LINE INDENT rh -= 1 NEW_LINE lh += 1 NEW_LINE DEDENT if ( lh > rh ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def cal ( num ) : NEW_LINE INDENT digit = numberofDigits ( num ) NEW_LINE powTen = pow ( 10 , digit - 1 ) NEW_LINE for i in range ( digit - 1 ) : NEW_LINE INDENT firstDigit = num // powTen NEW_LINE left = ( num * 10 + firstDigit - ( firstDigit * powTen * 10 ) ) NEW_LINE print ( left , end = " " ) NEW_LINE num = left NEW_LINE DEDENT DEDENT
def CheckKCycles ( n , s ) : NEW_LINE INDENT ff = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT x = int ( s [ i : ] + s [ 0 : i ] ) NEW_LINE if ( x >= int ( s ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT ff = False NEW_LINE break NEW_LINE DEDENT if ( ff ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def populateNext ( p ) : NEW_LINE INDENT global next NEW_LINE if ( p != None ) : NEW_LINE INDENT populateNext ( p . right ) NEW_LINE p . next = next NEW_LINE next = p NEW_LINE populateNext ( p . left ) NEW_LINE DEDENT DEDENT
def occurredOnce ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE if arr [ 0 ] != arr [ 1 ] : NEW_LINE INDENT print ( arr [ 0 ] , end = " " ) NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if arr [ n - 2 ] != arr [ n - 1 ] : NEW_LINE INDENT print ( arr [ n - 1 ] , end = " " ) NEW_LINE DEDENT DEDENT
def occurredOnce ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for it in mp : NEW_LINE INDENT if mp [ it ] == 1 : NEW_LINE INDENT print ( it , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def occurredOnce ( arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE len = n NEW_LINE if arr [ 0 ] == arr [ len - 1 ] : NEW_LINE INDENT i = 2 NEW_LINE len -= 1 NEW_LINE DEDENT while i < n : NEW_LINE INDENT if arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i - 1 ] , end = " " ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( arr [ n - 1 ] != arr [ 0 ] and arr [ n - 1 ] != arr [ n - 2 ] ) : NEW_LINE INDENT print ( arr [ n - 1 ] ) NEW_LINE DEDENT DEDENT
def rvereseArray ( arr , start , end ) : NEW_LINE INDENT while start < end : NEW_LINE INDENT temp = arr [ start ] NEW_LINE arr [ start ] = arr [ end ] NEW_LINE arr [ end ] = temp NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def splitArr ( arr , k , n ) : NEW_LINE INDENT rvereseArray ( arr , 0 , n - 1 ) NEW_LINE rvereseArray ( arr , 0 , n - k - 1 ) NEW_LINE rvereseArray ( arr , n - k , n - 1 ) NEW_LINE DEDENT
def countRotationsDivBy8 ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE count = 0 NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = int ( n [ 0 ] ) NEW_LINE if ( oneDigit % 8 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( l == 2 ) : NEW_LINE INDENT first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) NEW_LINE second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] ) NEW_LINE if ( first % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( second % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT threeDigit = 0 NEW_LINE for i in range ( 0 , ( l - 2 ) ) : NEW_LINE INDENT threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def restoreSortedArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT reverse ( arr , 0 , i ) NEW_LINE reverse ( arr , i + 1 , n ) NEW_LINE reverse ( arr , 0 , n ) NEW_LINE DEDENT DEDENT DEDENT
def findStartIndexOfArray ( arr , low , high ) : NEW_LINE INDENT if ( low > high ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( low == high ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) / 2 NEW_LINE if ( arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if ( arr [ mid - 1 ] > arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ low ] > arr [ mid ] ) : NEW_LINE INDENT return findStartIndexOfArray ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findStartIndexOfArray ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT
def restoreSortedArray ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] < arr [ n - 1 ] ) : NEW_LINE INDENT return NEW_LINE DEDENT start = findStartIndexOfArray ( arr , 0 , n - 1 ) NEW_LINE reverse ( arr , 0 , start ) NEW_LINE reverse ( arr , start , n ) NEW_LINE reverse ( arr ) NEW_LINE DEDENT
def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ) NEW_LINE DEDENT DEDENT
def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = ' ' ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT
def isRotation ( x , y ) : NEW_LINE INDENT x64 = x | ( x << 32 ) NEW_LINE while ( x64 >= y ) : NEW_LINE INDENT if ( ( x64 ) == y ) : NEW_LINE INDENT return True NEW_LINE DEDENT x64 >>= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def countRotations ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = ( int ) ( n [ 0 ] ) NEW_LINE if ( oneDigit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def isRotated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( str1 ) < 2 ) : NEW_LINE INDENT return str1 == str2 NEW_LINE DEDENT clock_rot = "" NEW_LINE anticlock_rot = "" NEW_LINE l = len ( str2 ) NEW_LINE anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] ) NEW_LINE clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ] NEW_LINE return ( str1 == clock_rot or str1 == anticlock_rot ) NEW_LINE DEDENT
def printList ( head ) : NEW_LINE INDENT temp = head NEW_LINE if ( head != None ) : NEW_LINE INDENT while True : NEW_LINE INDENT print ( temp . data , end = ' ' ) NEW_LINE temp = temp . next NEW_LINE if ( temp == head ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT
def deleteNode ( head_ref , delt ) : NEW_LINE INDENT temp = head_ref NEW_LINE if ( head_ref == delt ) : NEW_LINE INDENT head_ref = delt . next NEW_LINE DEDENT while ( temp . next != delt ) : NEW_LINE INDENT temp = temp . next NEW_LINE DEDENT temp . next = delt . next NEW_LINE del ( delt ) NEW_LINE return NEW_LINE DEDENT
def largestElement ( head_ref ) : NEW_LINE INDENT current = None NEW_LINE current = head_ref NEW_LINE maxEle = - 10000000 NEW_LINE while ( True ) : NEW_LINE INDENT if ( current . data > maxEle ) : NEW_LINE INDENT maxEle = current . data NEW_LINE DEDENT current = current . next NEW_LINE if ( current == head_ref ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return maxEle NEW_LINE DEDENT
def deleteFibonacciNodes ( head ) : NEW_LINE INDENT maxEle = largestElement ( head ) NEW_LINE hashmap = set ( ) NEW_LINE createHash ( hashmap , maxEle ) NEW_LINE ptr = head NEW_LINE next = None NEW_LINE while ( True ) : NEW_LINE INDENT if ( ptr . data in hashmap ) : NEW_LINE INDENT deleteNode ( head , ptr ) NEW_LINE DEDENT next = ptr . next NEW_LINE ptr = next NEW_LINE if ( ptr == head ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def printList ( head ) : NEW_LINE INDENT temp = head NEW_LINE if ( head != None ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT print ( temp . data , end = ' ' ) NEW_LINE temp = temp . next NEW_LINE if ( temp == head ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT
def sumOfList ( head ) : NEW_LINE INDENT temp = head NEW_LINE tsum = temp . data NEW_LINE temp = temp . next NEW_LINE while ( temp is not head ) : NEW_LINE INDENT tsum += temp . data NEW_LINE temp = temp . next NEW_LINE DEDENT return tsum NEW_LINE DEDENT
def searchList ( start , search ) : NEW_LINE INDENT temp = start NEW_LINE count = 0 NEW_LINE flag = 0 NEW_LINE value = 0 NEW_LINE if ( temp == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp . next != start ) : NEW_LINE INDENT count = count + 1 NEW_LINE if ( temp . data == search ) : NEW_LINE INDENT flag = 1 NEW_LINE count = count - 1 NEW_LINE break NEW_LINE DEDENT temp = temp . next NEW_LINE DEDENT if ( temp . data == search ) : NEW_LINE INDENT count = count + 1 NEW_LINE flag = 1 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( search , "found at location " , count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( search , " not found" ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countList ( start ) : NEW_LINE INDENT temp = start NEW_LINE count = 0 NEW_LINE while ( temp . next != start ) : NEW_LINE INDENT temp = temp . next NEW_LINE count = count + 1 NEW_LINE DEDENT count = count + 1 NEW_LINE return count NEW_LINE DEDENT
def display ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE print ( "Forward direction: " , end = "" ) NEW_LINE while ( temp . next != head ) : NEW_LINE INDENT print ( temp . data , end = " " ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data ) NEW_LINE last = head . prev NEW_LINE temp = last NEW_LINE print ( "Backward direction: " , end = "" ) NEW_LINE while ( temp . prev != last ) : NEW_LINE INDENT print ( temp . data , end = " " ) NEW_LINE temp = temp . prev NEW_LINE DEDENT print ( temp . data ) NEW_LINE DEDENT
def displayList ( temp ) : NEW_LINE INDENT t = temp NEW_LINE if ( temp == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT print ( "The list is: " , end = " " ) NEW_LINE while ( temp . next != t ) : NEW_LINE INDENT print ( temp . data , end = " " ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data ) NEW_LINE return 1 NEW_LINE DEDENT DEDENT
def filter ( x , y , z ) : NEW_LINE INDENT if ( x != - 1 and y != - 1 ) : NEW_LINE INDENT return z NEW_LINE DEDENT return y if x == - 1 else x NEW_LINE DEDENT
def samePathUtil ( mtrx , vrtx , v1 , v2 , i ) : NEW_LINE INDENT ans = - 1 NEW_LINE if ( i == v1 or i == v2 ) : NEW_LINE INDENT return i NEW_LINE DEDENT for j in range ( 0 , vrtx ) : NEW_LINE INDENT if ( mtrx [ i ] [ j ] == 1 ) : NEW_LINE INDENT ans = filter ( ans , samePathUtil ( mtrx , vrtx , v1 , v2 , j ) , i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isVertexAtSamePath ( mtrx , vrtx , v1 , v2 , i ) : NEW_LINE INDENT lca = samePathUtil ( mtrx , vrtx , v1 - 1 , v2 - 1 , i ) NEW_LINE if ( lca == v1 - 1 or lca == v2 - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def dfs ( node , parent , h , cost ) : NEW_LINE INDENT lca [ node ] [ 0 ] = parent NEW_LINE level [ node ] = h NEW_LINE if ( parent != - 1 ) : NEW_LINE INDENT dist [ node ] [ 0 ] = cost NEW_LINE DEDENT for i in range ( 1 , lg ) : NEW_LINE INDENT if ( lca [ node ] [ i - 1 ] != - 1 ) : NEW_LINE INDENT lca [ node ] [ i ] = lca [ lca [ node ] [ i - 1 ] ] [ i - 1 ] NEW_LINE dist [ node ] [ i ] = ( dist [ node ] [ i - 1 ] + dist [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) NEW_LINE DEDENT DEDENT for i in graph [ node ] : NEW_LINE INDENT if ( i [ 0 ] == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( i [ 0 ] , node , h + 1 , i [ 1 ] ) NEW_LINE DEDENT DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if p * p > MAX + 1 : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def dfs ( node , parent , h ) : NEW_LINE INDENT par [ node ] = parent NEW_LINE level [ node ] = h NEW_LINE for child in graph [ node ] : NEW_LINE INDENT if ( child == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( child , node , h + 1 ) NEW_LINE DEDENT DEDENT
def findPrimeOnPath ( u , v ) : NEW_LINE INDENT count = 0 NEW_LINE if ( level [ u ] > level [ v ] ) : NEW_LINE INDENT u , v = v , u NEW_LINE DEDENT d = level [ v ] - level [ u ] NEW_LINE while ( d ) : NEW_LINE INDENT if ( prime [ weight [ v ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT v = par [ v ] NEW_LINE d -= 1 NEW_LINE DEDENT if ( v == u ) : NEW_LINE INDENT if ( prime [ weight [ v ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT while ( v != u ) : NEW_LINE INDENT if ( prime [ weight [ v ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( prime [ weight [ u ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT u = par [ u ] NEW_LINE v = par [ v ] NEW_LINE DEDENT if ( prime [ weight [ v ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def addEdge ( u , v ) : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE graph [ v ] . append ( u ) NEW_LINE DEDENT
def sumOddNodes ( root , n1 , n2 ) : NEW_LINE INDENT path1 = [ ] NEW_LINE path2 = [ ] NEW_LINE getPath ( root , path1 , n1 ) NEW_LINE getPath ( root , path2 , n2 ) NEW_LINE intersection = - 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i != len ( path1 ) or j != len ( path2 ) ) : NEW_LINE INDENT if ( i == j and path1 [ i ] == path2 [ j ] ) : NEW_LINE INDENT i = i + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT else : NEW_LINE INDENT intersection = j - 1 NEW_LINE break NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE i = len ( path1 ) - 1 NEW_LINE while ( i > intersection ) : NEW_LINE INDENT if ( path1 [ i ] % 2 != 0 ) : NEW_LINE INDENT sum += path1 [ i ] NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT i = intersection NEW_LINE while ( i < len ( path2 ) ) : NEW_LINE INDENT if ( path2 [ i ] % 2 != 0 ) : NEW_LINE INDENT sum += path2 [ i ] NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findLCA ( n1 , n2 , parent ) : NEW_LINE INDENT visited = [ False for i in range ( MAX ) ] NEW_LINE visited [ n1 ] = True NEW_LINE while ( parent [ n1 ] != - 1 ) : NEW_LINE INDENT visited [ n1 ] = True NEW_LINE n1 = parent [ n1 ] NEW_LINE DEDENT visited [ n1 ] = True NEW_LINE while ( visited [ n2 ] == False ) : NEW_LINE INDENT n2 = parent [ n2 ] NEW_LINE DEDENT return n2 NEW_LINE DEDENT
def insertAdj ( parent , i , j ) : NEW_LINE INDENT parent [ i ] = j NEW_LINE DEDENT
def addEdge ( u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT
def dfs ( cur , prev ) : NEW_LINE INDENT parent [ cur ] = prev NEW_LINE depth [ cur ] = depth [ prev ] + 1 NEW_LINE for i in range ( len ( adj [ cur ] ) ) : NEW_LINE INDENT if ( adj [ cur ] [ i ] != prev ) : NEW_LINE INDENT dfs ( adj [ cur ] [ i ] , cur ) NEW_LINE DEDENT DEDENT DEDENT
def preprocess ( ) : NEW_LINE INDENT depth [ 0 ] = - 1 NEW_LINE dfs ( 1 , 0 ) NEW_LINE DEDENT
def makeSet ( subsets , i ) : NEW_LINE INDENT if ( i < 1 or i > V ) : NEW_LINE INDENT return NEW_LINE DEDENT subsets [ i ] . color = WHITE NEW_LINE subsets [ i ] . parent = i NEW_LINE subsets [ i ] . rank = 0 NEW_LINE return NEW_LINE DEDENT
def findSet ( subsets , i ) : NEW_LINE INDENT if ( subsets [ i ] . parent != i ) : NEW_LINE INDENT subsets [ i ] . parent = findSet ( subsets , subsets [ i ] . parent ) NEW_LINE DEDENT return subsets [ i ] . parent NEW_LINE DEDENT
def unionSet ( subsets , x , y ) : NEW_LINE INDENT xroot = findSet ( subsets , x ) NEW_LINE yroot = findSet ( subsets , y ) NEW_LINE if ( subsets [ xroot ] . rank < subsets [ yroot ] . rank ) : NEW_LINE INDENT subsets [ xroot ] . parent = yroot NEW_LINE DEDENT elif ( subsets [ xroot ] . rank > subsets [ yroot ] . rank ) : NEW_LINE INDENT subsets [ yroot ] . parent = xroot NEW_LINE DEDENT else : NEW_LINE INDENT subsets [ yroot ] . parent = xroot NEW_LINE ( subsets [ xroot ] . rank ) += 1 NEW_LINE DEDENT DEDENT
def findPair ( a , n , z ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i != j and a [ i ] + a [ j ] == z ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def linearSearch ( a , n , key ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == key ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def maximumSum ( arr , N ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT Sum += ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT
def stoogesort ( arr , l , h ) : NEW_LINE INDENT if ( l >= h ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( arr [ l ] > arr [ h ] ) : NEW_LINE INDENT temp = arr [ l ] NEW_LINE arr [ l ] = arr [ h ] NEW_LINE arr [ h ] = temp NEW_LINE DEDENT if ( h - l + 1 > 2 ) : NEW_LINE INDENT t = ( h - l + 1 ) // 3 NEW_LINE stoogesort ( arr , l , h - t ) NEW_LINE stoogesort ( arr , l + t , h ) NEW_LINE stoogesort ( arr , l , h - t ) NEW_LINE DEDENT DEDENT
def findWinner ( n , m ) : NEW_LINE INDENT X = 0 NEW_LINE Y = 0 NEW_LINE if ( n >= m ) : NEW_LINE INDENT X = n - 1 NEW_LINE Y = m NEW_LINE DEDENT else : NEW_LINE INDENT X = m - 1 NEW_LINE Y = n NEW_LINE DEDENT if ( X > Y ) : NEW_LINE INDENT print ( "X" ) NEW_LINE DEDENT elif ( Y > X ) : NEW_LINE INDENT print ( "Y" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def checkPascaltriangle ( N ) : NEW_LINE INDENT x = ( math . sqrt ( 8 * N + 1 ) - 1 ) / 2 NEW_LINE if ( math . ceil ( x ) - x == 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def countSubarrays ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( ( j - i ) % 2 == 0 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT sum -= arr [ j ] NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def findCountRooks ( row , col , n , k ) : NEW_LINE INDENT res = n - k NEW_LINE print ( res ) NEW_LINE ri = 0 NEW_LINE ci = 0 NEW_LINE while ( res > 0 ) : NEW_LINE INDENT while ( ri < k and row [ ri ] == 1 ) : NEW_LINE INDENT ri += 1 NEW_LINE DEDENT while ( ci < k and col [ ci ] == 1 ) : NEW_LINE INDENT ci += 1 NEW_LINE DEDENT print ( ( ri + 1 ) , "" , ( ci + 1 ) ) NEW_LINE ri += 1 NEW_LINE ci += 1 NEW_LINE res -= 1 NEW_LINE DEDENT DEDENT
def checkIfDivisible ( string , num ) : NEW_LINE INDENT powerOf2 = int ( log2 ( num ) ) NEW_LINE if ( len ( string ) < powerOf2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( powerOf2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT number = 0 NEW_LINE length = len ( string ) NEW_LINE for i in range ( length - powerOf2 , length ) : NEW_LINE INDENT number += ( ( ord ( string [ i ] ) - ord ( '0' ) ) * ( 10 ** ( powerOf2 - 1 ) ) ) NEW_LINE powerOf2 -= 1 NEW_LINE DEDENT if ( number % num ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def countNo ( A , N , L , R ) : NEW_LINE INDENT ans = L - 1 + N + math . floor ( ( N - 1 ) / ( A - 1 ) ) NEW_LINE if ans % A == 0 : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def check_order ( arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i + 1 ] - arr [ i ] ) > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( abs ( arr [ 0 ] - arr [ len ( arr ) - 1 ] ) > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( cnt > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def getM ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n - 2 NEW_LINE DEDENT DEDENT
def maxProfit ( prices , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT rest = [ 0 ] * n NEW_LINE hold = [ 0 ] * n NEW_LINE sold = [ 0 ] * n NEW_LINE rest [ 0 ] = 0 NEW_LINE hold [ 0 ] = - prices [ 0 ] NEW_LINE sold [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT rest [ i ] = max ( rest [ i - 1 ] , sold [ i - 1 ] ) NEW_LINE hold [ i ] = max ( hold [ i - 1 ] , rest [ i - 1 ] - prices [ i ] ) NEW_LINE sold [ i ] = hold [ i - 1 ] + prices [ i ] NEW_LINE DEDENT return max ( rest [ n - 1 ] , sold [ n - 1 ] ) NEW_LINE DEDENT
def findSubarrays ( arr , N , K ) : NEW_LINE INDENT return N - K + 1 NEW_LINE DEDENT
def findCount ( s ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE dp = [ [ 0 ] * 26 ] * 26 NEW_LINE freq = numpy . zeros ( 26 ) NEW_LINE dp = numpy . zeros ( [ 26 , 26 ] ) NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT dp [ j ] [ ord ( s [ i ] ) - ord ( 'a' ) ] += freq [ j ] NEW_LINE DEDENT freq [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT ans = max ( freq [ i ] , ans ) NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT for j in range ( 0 , 26 ) : NEW_LINE INDENT ans = max ( dp [ i ] [ j ] , ans ) NEW_LINE DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT
def findCycles ( N ) : NEW_LINE INDENT res = 0 NEW_LINE finalResult = 0 NEW_LINE val = 2 * N - 1 NEW_LINE s = val NEW_LINE res = ( N - 1 ) * ( N - 2 ) NEW_LINE finalResult = res + s NEW_LINE return finalResult NEW_LINE DEDENT
def longest_subarray ( arr , d ) : NEW_LINE INDENT ( i , j , e ) = ( 0 , 1 , 0 ) NEW_LINE for i in range ( d - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j = 1 NEW_LINE DEDENT if e < j : NEW_LINE INDENT e = j NEW_LINE DEDENT DEDENT return e NEW_LINE DEDENT
def find ( a , n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT v . append ( a [ i - 1 ] - a [ i ] ) NEW_LINE DEDENT v . sort ( ) NEW_LINE res = a [ n - 1 ] - a [ 0 ] NEW_LINE for i in range ( k - 1 ) : NEW_LINE INDENT res += v [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def isStrong ( N ) : NEW_LINE INDENT num = str ( N ) NEW_LINE sum = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT sum += factorial [ ord ( num [ i ] ) - ord ( '0' ) ] NEW_LINE DEDENT if sum == N : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def printStrongNumbers ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( isStrong ( i ) ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def countPairs ( A , B ) : NEW_LINE INDENT countY = 0 NEW_LINE countX = ( B - A ) + 1 NEW_LINE next_val = 9 NEW_LINE while ( next_val <= B ) : NEW_LINE INDENT if ( next_val >= A ) : NEW_LINE INDENT countY += 1 NEW_LINE DEDENT next_val = next_val * 10 + 9 NEW_LINE DEDENT return ( countX * countY ) NEW_LINE DEDENT
def power ( a , b , c ) : NEW_LINE INDENT result = 1 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( ( b & 1 ) == 1 ) : NEW_LINE INDENT result = ( result * a ) % c NEW_LINE DEDENT b //= 2 NEW_LINE a = ( a * a ) % c NEW_LINE DEDENT return result NEW_LINE DEDENT
def calculate ( X , N ) : NEW_LINE INDENT a = 10 * [ 0 ] NEW_LINE cyclicity = 11 * [ 0 ] NEW_LINE cyclicity [ 1 ] = 1 NEW_LINE cyclicity [ 2 ] = 4 NEW_LINE cyclicity [ 3 ] = 4 NEW_LINE cyclicity [ 4 ] = 2 NEW_LINE cyclicity [ 5 ] = 1 NEW_LINE cyclicity [ 6 ] = 1 NEW_LINE cyclicity [ 7 ] = 4 NEW_LINE cyclicity [ 8 ] = 4 NEW_LINE cyclicity [ 9 ] = 2 NEW_LINE cyclicity [ 10 ] = 1 NEW_LINE if ( N == 0 or N == 1 ) : NEW_LINE INDENT return ( X % 10 ) NEW_LINE DEDENT elif ( N == 2 or N == 3 or N == 4 ) : NEW_LINE INDENT temp = 1e18 NEW_LINE a [ 2 ] = 2 NEW_LINE a [ 3 ] = 6 NEW_LINE a [ 4 ] = 4 NEW_LINE v = X % 10 NEW_LINE if ( v != 0 ) : NEW_LINE INDENT u = cyclicity [ v ] NEW_LINE r = a [ N ] % u NEW_LINE if ( r == 0 ) : NEW_LINE INDENT if ( v == 2 or v == 4 or v == 6 or v == 8 ) : NEW_LINE INDENT return 6 NEW_LINE DEDENT elif ( v == 5 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT elif ( v == 1 or v == 3 or v == 7 or v == 9 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return ( power ( v , r , temp ) % 10 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def precompute ( s , K ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT cnt [ i + 1 ] = cnt [ i ] NEW_LINE if s [ i : len ( K ) + i ] == K : NEW_LINE INDENT cnt [ i + 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT
def getXOR ( BITree , index ) : NEW_LINE INDENT ans = 0 NEW_LINE index += 1 NEW_LINE while ( index > 0 ) : NEW_LINE INDENT ans ^= BITree [ index ] NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def updateBIT ( BITree , n , index , val ) : NEW_LINE INDENT index = index + 1 NEW_LINE while ( index <= n ) : NEW_LINE INDENT BITree [ index ] ^= val NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT
def isPowerOfTwo ( x ) : NEW_LINE INDENT if ( x and ( not ( x & ( x - 1 ) ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def computePrefix ( n , a ) : NEW_LINE INDENT if ( isPowerOfTwo ( a [ 0 ] ) ) : NEW_LINE INDENT prefix [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] NEW_LINE if ( isPowerOfTwo ( a [ i ] ) ) : NEW_LINE INDENT prefix [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT
def formQuadruplets ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE pairs = 0 NEW_LINE pairs = n // 4 NEW_LINE arr . sort ( reverse = True ) NEW_LINE for i in range ( 0 , n - pairs , 3 ) : NEW_LINE INDENT ans += arr [ i + 2 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def count ( ) : NEW_LINE INDENT maxN = 1000000 NEW_LINE for i in range ( 0 , maxN ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT arr [ 0 ] = 0 NEW_LINE arr [ 1 ] = 0 NEW_LINE i = 2 NEW_LINE while ( i * i <= maxN ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT for j in range ( 2 * i , maxN + 1 , i ) : NEW_LINE INDENT arr [ j ] = 0 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 0 , maxN + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( arr [ cnt ] == 1 ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 0 , maxN + 1 ) : NEW_LINE INDENT dp [ i ] += dp [ i - 1 ] NEW_LINE DEDENT DEDENT
def findUngroupedElement ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE b = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = s [ i ] NEW_LINE b [ ord ( p ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( b [ i ] > k ) : NEW_LINE INDENT sum += b [ i ] - k NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE DEDENT
def AddEdge ( u , v ) : NEW_LINE INDENT global adj NEW_LINE adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT
def findFirstEnd ( u , p ) : NEW_LINE INDENT global lvl , adj , end1 , maxi NEW_LINE lvl [ u ] = 1 + lvl [ p ] NEW_LINE if ( lvl [ u ] > maxi ) : NEW_LINE INDENT maxi = lvl [ u ] NEW_LINE end1 = u NEW_LINE DEDENT for i in range ( len ( adj [ u ] ) ) : NEW_LINE INDENT if ( adj [ u ] [ i ] != p ) : NEW_LINE INDENT findFirstEnd ( adj [ u ] [ i ] , u ) NEW_LINE DEDENT DEDENT DEDENT
def findSecondEnd ( u , p ) : NEW_LINE INDENT global lvl , adj , maxi , end2 NEW_LINE lvl [ u ] = 1 + lvl [ p ] NEW_LINE if ( lvl [ u ] > maxi ) : NEW_LINE INDENT maxi = lvl [ u ] NEW_LINE end2 = u NEW_LINE DEDENT for i in range ( len ( adj [ u ] ) ) : NEW_LINE INDENT if ( adj [ u ] [ i ] != p ) : NEW_LINE INDENT findSecondEnd ( adj [ u ] [ i ] , u ) NEW_LINE DEDENT DEDENT DEDENT
def findDistancefromFirst ( u , p ) : NEW_LINE INDENT global dist1 , adj NEW_LINE dist1 [ u ] = 1 + dist1 [ p ] NEW_LINE for i in range ( len ( adj [ u ] ) ) : NEW_LINE INDENT if ( adj [ u ] [ i ] != p ) : NEW_LINE INDENT findDistancefromFirst ( adj [ u ] [ i ] , u ) NEW_LINE DEDENT DEDENT DEDENT
def findDistancefromSecond ( u , p ) : NEW_LINE INDENT global dist2 , adj NEW_LINE dist2 [ u ] = 1 + dist2 [ p ] NEW_LINE for i in range ( len ( adj [ u ] ) ) : NEW_LINE INDENT if ( adj [ u ] [ i ] != p ) : NEW_LINE INDENT findDistancefromSecond ( adj [ u ] [ i ] , u ) NEW_LINE DEDENT DEDENT DEDENT
def findNodes ( ) : NEW_LINE INDENT global adj , lvl , dist1 , dist2 , end1 , end2 , maxi NEW_LINE n = 5 NEW_LINE AddEdge ( 1 , 2 ) NEW_LINE AddEdge ( 1 , 3 ) NEW_LINE AddEdge ( 3 , 4 ) NEW_LINE AddEdge ( 3 , 5 ) NEW_LINE findFirstEnd ( 1 , 0 ) NEW_LINE clear ( n ) NEW_LINE findSecondEnd ( end1 , 0 ) NEW_LINE findDistancefromFirst ( end1 , 0 ) NEW_LINE findDistancefromSecond ( end2 , 0 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = dist1 [ i ] NEW_LINE y = dist2 [ i ] NEW_LINE if ( x >= y ) : NEW_LINE INDENT print ( end1 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end2 , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def findMaxSum ( arr , n ) : NEW_LINE INDENT a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT a . append ( arr [ i ] ) NEW_LINE DEDENT elif ( arr [ i ] < 0 ) : NEW_LINE INDENT b . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE p = len ( a ) - 1 NEW_LINE q = len ( b ) - 1 NEW_LINE s = 0 NEW_LINE while ( p >= 0 and q >= 0 ) : NEW_LINE INDENT if ( a [ p ] + b [ q ] > 0 ) : NEW_LINE INDENT s = s + a [ p ] + b [ q ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT p = p - 1 NEW_LINE q = q - 1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def countIntgralPoints ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) NEW_LINE DEDENT
def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= p_size ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def PrimeDegreeNodes ( prufer , n ) : NEW_LINE INDENT nodes = n + 2 NEW_LINE prime = [ True ] * ( nodes + 1 ) NEW_LINE SieveOfEratosthenes ( prime , nodes + 1 ) NEW_LINE degree = [ 0 ] * ( n + 2 + 1 ) NEW_LINE for i in range ( 1 , nodes + 1 ) : NEW_LINE INDENT degree [ i ] = 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT degree [ prufer [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , nodes + 1 ) : NEW_LINE INDENT if prime [ degree [ i ] ] : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT
def countSingle ( root ) : NEW_LINE INDENT count = [ 0 ] NEW_LINE countSingleRec ( root , count ) NEW_LINE return count [ 0 ] NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT i = 2 NEW_LINE Prime [ 0 ] = Prime [ 1 ] = False NEW_LINE while i * i <= 10005 : NEW_LINE INDENT if ( Prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , 10005 ) : NEW_LINE INDENT Prime [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def primeDegreeNodes ( N , M , edges ) : NEW_LINE INDENT Adj = [ [ ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT x = edges [ i ] [ 0 ] NEW_LINE y = edges [ i ] [ 1 ] NEW_LINE Adj [ x ] . append ( y ) NEW_LINE Adj [ y ] . append ( x ) NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT x = len ( Adj [ i ] ) NEW_LINE if ( Prime [ x ] ) : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT
def digitSum ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( num ) : NEW_LINE INDENT sum += ( num % 10 ) NEW_LINE num //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def countWays ( colored , count , n ) : NEW_LINE INDENT if ( count == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( colored [ i ] == 0 ) : NEW_LINE INDENT if ( colored [ i - 1 ] == 1 or colored [ i + 1 ] == 1 ) : NEW_LINE INDENT colored [ i ] = 1 NEW_LINE answer = ( ( answer + countWays ( colored , count + 1 , n ) ) % mod ) NEW_LINE colored [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT
def waysToColor ( arr , n , k ) : NEW_LINE INDENT colored = [ 0 ] * ( n + 2 ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT colored [ arr [ i ] ] = 1 NEW_LINE DEDENT return countWays ( colored , k , n ) NEW_LINE DEDENT
def waysToColor ( arr , n , k ) : NEW_LINE INDENT global mod NEW_LINE powOf2 = [ 0 for i in range ( 500 ) ] NEW_LINE c = [ [ 0 for i in range ( 500 ) ] for j in range ( 500 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT c [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT c [ i ] [ j ] = ( c [ i - 1 ] [ j ] + c [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE DEDENT DEDENT powOf2 [ 0 ] = 1 NEW_LINE powOf2 [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT powOf2 [ i ] = ( powOf2 [ i - 1 ] * 2 ) % mod NEW_LINE DEDENT rem = n - k NEW_LINE arr [ k ] = n + 1 NEW_LINE k += 1 NEW_LINE arr . sort ( ) NEW_LINE answer = 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT x = 0 NEW_LINE if i - 1 >= 0 : NEW_LINE INDENT x = arr [ i ] - arr [ i - 1 ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] - 1 NEW_LINE DEDENT answer = answer * ( c [ rem ] [ x ] % mod ) * ( ( powOf2 [ x ] if ( i != 0 and i != k - 1 ) else 1 ) ) % mod NEW_LINE rem -= x NEW_LINE DEDENT return answer NEW_LINE DEDENT
def ShortestPalindrome ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = min ( ans , s [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def SumGPUtil ( r , n , m ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return ( 1 + r ) % m NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT ans = ( 1 + r ) * SumGPUtil ( r * r % m , ( n - 1 ) // 2 , m ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 + r * ( 1 + r ) * SumGPUtil ( r * r % m , n // 2 - 1 , m ) NEW_LINE DEDENT return ans % m NEW_LINE DEDENT
def SumGP ( a , r , N , M ) : NEW_LINE INDENT answer = a * SumGPUtil ( r , N , M ) NEW_LINE answer = answer % M NEW_LINE print ( answer ) NEW_LINE DEDENT
def findLeafDown ( root , lev , minDist ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT if ( lev < ( minDist [ 0 ] ) ) : NEW_LINE INDENT minDist [ 0 ] = lev NEW_LINE DEDENT return NEW_LINE DEDENT findLeafDown ( root . left , lev + 1 , minDist ) NEW_LINE findLeafDown ( root . right , lev + 1 , minDist ) NEW_LINE DEDENT
def findThroughParent ( root , x , minDist ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( root == x ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = findThroughParent ( root . left , x , minDist ) NEW_LINE if ( l != - 1 ) : NEW_LINE INDENT findLeafDown ( root . right , l + 2 , minDist ) NEW_LINE return l + 1 NEW_LINE DEDENT r = findThroughParent ( root . right , x , minDist ) NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT findLeafDown ( root . left , r + 2 , minDist ) NEW_LINE return r + 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def minimumDistance ( root , x ) : NEW_LINE INDENT minDist = [ 999999999999 ] NEW_LINE findLeafDown ( x , 0 , minDist ) NEW_LINE findThroughParent ( root , x , minDist ) NEW_LINE return minDist [ 0 ] NEW_LINE DEDENT
def SmallestDiv ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return n NEW_LINE DEDENT
def countOfNum ( n , a , b ) : NEW_LINE INDENT cnt_of_a , cnt_of_b , cnt_of_ab , sum = 0 , 0 , 0 , 0 NEW_LINE cnt_of_a = n // a NEW_LINE cnt_of_b = n // b NEW_LINE sum = cnt_of_b + cnt_of_a NEW_LINE cnt_of_ab = n // ( a * b ) NEW_LINE sum = sum - cnt_of_ab NEW_LINE return sum NEW_LINE DEDENT
def sumOfNum ( n , a , b ) : NEW_LINE INDENT i = 0 NEW_LINE sum = 0 NEW_LINE ans = dict ( ) NEW_LINE for i in range ( a , n + 1 , a ) : NEW_LINE INDENT ans [ i ] = 1 NEW_LINE DEDENT for i in range ( b , n + 1 , b ) : NEW_LINE INDENT ans [ i ] = 1 NEW_LINE DEDENT for it in ans : NEW_LINE INDENT sum = sum + it NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isPalindrome ( r ) : NEW_LINE INDENT p = r NEW_LINE p = "" . join ( reversed ( p ) ) NEW_LINE return ( r == p ) NEW_LINE DEDENT
def minimumAdjacentDifference ( a , n , k ) : NEW_LINE INDENT minDiff = INT_MAX NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT cnt = bin ( i ) . count ( '1' ) NEW_LINE if ( cnt == n - k ) : NEW_LINE INDENT temp = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( i & ( 1 << j ) ) != 0 ) : NEW_LINE INDENT temp . append ( a [ j ] ) NEW_LINE DEDENT DEDENT maxDiff = INT_MIN NEW_LINE for j in range ( len ( temp ) - 1 ) : NEW_LINE INDENT maxDiff = max ( maxDiff , temp [ j + 1 ] - temp [ j ] ) NEW_LINE DEDENT minDiff = min ( minDiff , maxDiff ) NEW_LINE DEDENT DEDENT return minDiff NEW_LINE DEDENT
def gcdFunc ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcdFunc ( b , a % b ) NEW_LINE DEDENT
def findMinimumElements ( a , n ) : NEW_LINE INDENT b = [ 0 ] * ( n - 1 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT b [ i - 1 ] = a [ i ] - a [ i - 1 ] NEW_LINE DEDENT gcd = b [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT gcd = gcdFunc ( gcd , b [ i ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans += ( b [ i ] // gcd ) - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def checkPermutation ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT prefix = [ 0 ] * ( n + 1 ) NEW_LINE prefix [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + arr [ i ] NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT lsum = prefix [ i ] NEW_LINE rsum = sum - prefix [ i ] NEW_LINE l_len = i + 1 NEW_LINE r_len = n - i - 1 NEW_LINE if ( ( ( 2 * lsum ) == ( l_len * ( l_len + 1 ) ) ) and ( ( 2 * rsum ) == ( r_len * ( r_len + 1 ) ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left , right , above , below = 0 , 0 , 0 , 0 NEW_LINE left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE print ( max ( max ( left , right ) , max ( above , below ) ) ) NEW_LINE DEDENT
def precompute ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd [ i ] = 1 NEW_LINE DEDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT even [ i ] = even [ i ] + even [ i - 1 ] NEW_LINE odd [ i ] = odd [ i ] + odd [ i - 1 ] NEW_LINE DEDENT DEDENT
def isOdd ( L , R ) : NEW_LINE INDENT cnt = odd [ R ] NEW_LINE if ( L > 0 ) : NEW_LINE INDENT cnt -= odd [ L - 1 ] NEW_LINE DEDENT if ( cnt == R - L + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findTriplets ( x ) : NEW_LINE INDENT fact = [ ] NEW_LINE factors = set ( ) NEW_LINE for i in range ( 2 , int ( sqrt ( x ) ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT fact . append ( i ) NEW_LINE if ( x / i != i ) : NEW_LINE INDENT fact . append ( x // i ) NEW_LINE DEDENT factors . add ( i ) NEW_LINE factors . add ( x // i ) NEW_LINE DEDENT DEDENT found = False NEW_LINE k = len ( fact ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT a = fact [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT b = fact [ j ] NEW_LINE if ( ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) ) : NEW_LINE INDENT print ( a , b , x // ( a * b ) ) NEW_LINE found = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( not found ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def findArray ( n , k , s ) : NEW_LINE INDENT vis = [ 0 ] * n NEW_LINE cnt = 0 NEW_LINE arr = [ 0 ] * n NEW_LINE i = 0 NEW_LINE while ( i < n and cnt < k ) : NEW_LINE INDENT arr [ i ] = s NEW_LINE vis [ i ] = 1 NEW_LINE cnt += 1 NEW_LINE i += 2 NEW_LINE DEDENT val = s NEW_LINE if ( s % 2 == 0 ) : NEW_LINE INDENT val += 1 NEW_LINE DEDENT else : NEW_LINE INDENT val = val + 2 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] = val NEW_LINE DEDENT DEDENT printArr ( arr , n ) NEW_LINE DEDENT
def countPair ( a , b ) : NEW_LINE INDENT s = str ( b ) NEW_LINE i = 0 NEW_LINE while i < ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != '9' ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT result = 0 NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT result = a * len ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT result = a * ( len ( s ) - 1 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def getArea ( a ) : NEW_LINE INDENT area = ( math . pi * a * a ) / 4 NEW_LINE return area NEW_LINE DEDENT
def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] & 1 ) : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT DEDENT if ( count_odd % 2 and count_even % 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def sumEqualProduct ( a , n ) : NEW_LINE INDENT zero = 0 NEW_LINE two = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if a [ i ] == 2 : NEW_LINE INDENT two += 1 NEW_LINE DEDENT DEDENT cnt = ( zero * ( zero - 1 ) ) // 2 + ( two * ( two - 1 ) ) // 2 NEW_LINE return cnt NEW_LINE DEDENT
def minSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def initialize ( mul , div , size ) : NEW_LINE INDENT for i in range ( 1 , size ) : NEW_LINE INDENT mul [ i ] = ( mul [ i ] * mul [ i - 1 ] ) / div [ i ] NEW_LINE DEDENT DEDENT
def update ( l , r , x , mul , div ) : NEW_LINE INDENT mul [ l ] *= x NEW_LINE div [ r + 1 ] *= x NEW_LINE DEDENT
def printArray ( ar , mul , div , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT ar [ i ] = ar [ i ] * mul [ i ] NEW_LINE print ( int ( ar [ i ] ) , end = " " ) NEW_LINE DEDENT DEDENT
def findTriangle ( S ) : NEW_LINE INDENT X1 = 0 NEW_LINE Y1 = 0 NEW_LINE X2 = MAX NEW_LINE Y2 = 1 NEW_LINE X3 = ( MAX - S % MAX ) % MAX NEW_LINE Y3 = ( S + X3 ) / MAX NEW_LINE print ( "(" , X1 , "," , Y1 , ")" ) NEW_LINE print ( "(" , X2 , "," , Y2 , ")" ) NEW_LINE print ( "(" , X3 , "," , Y3 , ")" ) NEW_LINE DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def findArrangement ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( "-1" , end = "" ) NEW_LINE return NEW_LINE DEDENT minVal = min ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == minVal ) : NEW_LINE INDENT arr [ i ] , arr [ n - 1 ] = arr [ n - 1 ] , arr [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT andVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT andVal &= arr [ i ] NEW_LINE DEDENT if ( andVal == arr [ n - 1 ] ) : NEW_LINE INDENT printArr ( arr , n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def maxOperations ( X , Y ) : NEW_LINE INDENT if ( X > Y ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT diff = Y - X NEW_LINE if ( diff == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( diff % 2 == 0 ) : NEW_LINE INDENT return ( diff // 2 ) NEW_LINE DEDENT return ( 1 + ( ( diff - 3 ) // 2 ) ) NEW_LINE DEDENT
def precompute ( ) : NEW_LINE INDENT for i in range ( DIGITS ) : NEW_LINE INDENT dp [ 1 ] [ i ] = i NEW_LINE cnt [ 1 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT for j in range ( DIGITS ) : NEW_LINE INDENT for k in range ( DIGITS ) : NEW_LINE INDENT if ( j != k ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j ] + ( dp [ i - 1 ] [ k ] + ( cnt [ i - 1 ] [ k ] * j ) % MOD ) % MOD NEW_LINE dp [ i ] [ j ] %= MOD NEW_LINE cnt [ i ] [ j ] += cnt [ i - 1 ] [ k ] NEW_LINE cnt [ i ] [ j ] %= MOD NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def precompute ( ) : NEW_LINE INDENT F [ 1 ] = 2 NEW_LINE F [ 2 ] = 3 NEW_LINE F [ 3 ] = 4 NEW_LINE for i in range ( 4 , N ) : NEW_LINE INDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD NEW_LINE DEDENT DEDENT
def minimizedSum ( a , n , K ) : NEW_LINE INDENT sum = maxSubArraySum ( a , n ) NEW_LINE totalSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT totalSum += a [ i ] NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT return totalSum NEW_LINE DEDENT totalSum = totalSum - sum + sum / K NEW_LINE return totalSum NEW_LINE DEDENT
def get ( L , R ) : NEW_LINE INDENT x = 1.0 / L NEW_LINE y = 1.0 / ( R + 1.0 ) NEW_LINE return ( x - y ) NEW_LINE DEDENT
def DivisorCount ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT divi [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT
def pre ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( prime [ divi [ i ] ] == 1 ) : NEW_LINE INDENT sum [ i ] = i NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT sum [ i ] += sum [ i - 1 ] NEW_LINE DEDENT DEDENT
def consecutiveOnes ( x ) : NEW_LINE INDENT p = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 2 == 1 and p == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT p = x % 2 NEW_LINE x //= 2 NEW_LINE DEDENT return False NEW_LINE DEDENT
def preCompute ( ) : NEW_LINE INDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT if ( consecutiveOnes ( i ) == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT DEDENT
def nextValid ( n ) : NEW_LINE INDENT it = upper_bound ( v , n ) NEW_LINE val = v [ it ] NEW_LINE return val NEW_LINE DEDENT
def randomList ( m , n ) : NEW_LINE INDENT arr = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ randint ( 0 , n ) % m ] += 1 NEW_LINE DEDENT printArr ( arr , m ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def nCrModPFermat ( n , r , p ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT fac = [ 0 ] * ( n + 1 ) NEW_LINE fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p NEW_LINE DEDENT
def countOdd ( n ) : NEW_LINE INDENT x = n // 2 NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
def counteEven ( n ) : NEW_LINE INDENT x = n // 2 NEW_LINE return x NEW_LINE DEDENT
def sumPrime ( k ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE v = [ ] NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE skip = ( k * ( k - 1 ) ) // 2 NEW_LINE while ( k > 0 ) : NEW_LINE INDENT sum += v [ skip ] NEW_LINE skip += 1 NEW_LINE k -= 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def lcm ( x , y ) : NEW_LINE INDENT temp = ( x * y ) // gcd ( x , y ) NEW_LINE return temp NEW_LINE DEDENT
def findNumbers ( a , n , b , m ) : NEW_LINE INDENT lcmA = 1 NEW_LINE __gcdB = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lcmA = lcm ( lcmA , a [ i ] ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT __gcdB = gcd ( __gcdB , b [ i ] ) NEW_LINE DEDENT if ( __gcdB % lcmA != 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT num = lcmA NEW_LINE while ( num <= __gcdB ) : NEW_LINE INDENT if ( __gcdB % num == 0 ) : NEW_LINE INDENT print ( num , end = " " ) NEW_LINE DEDENT num += lcmA NEW_LINE DEDENT DEDENT
def countSubStr ( strr , n , ch ) : NEW_LINE INDENT cnt = 0 NEW_LINE j = nextOccurrence ( strr , n , 0 , ch ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j != - 1 and j < i ) : NEW_LINE INDENT j = nextOccurrence ( strr , n , j + 1 , ch ) NEW_LINE DEDENT if ( j == - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT cnt += ( n - j ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def checkEvenOdd ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT print ( "Even" , end = "" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "Odd" , end = "" ) NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT y = y // 2 NEW_LINE x = x * x NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxPartition ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE P = 0 NEW_LINE current = "" NEW_LINE previous = "" NEW_LINE for i in range ( n ) : NEW_LINE INDENT current += s [ i ] NEW_LINE if ( current != previous ) : NEW_LINE INDENT previous = current NEW_LINE current = "" NEW_LINE P += 1 NEW_LINE DEDENT DEDENT return P NEW_LINE DEDENT
def LongestSubarray ( a , n , k ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT pre [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + pre [ i ] NEW_LINE DEDENT Len = 0 NEW_LINE lo = 1 NEW_LINE hi = n NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE ok = False NEW_LINE for i in range ( mid - 1 , n ) : NEW_LINE INDENT x = pre [ i ] NEW_LINE if ( i - mid >= 0 ) : NEW_LINE INDENT x -= pre [ i - mid ] NEW_LINE DEDENT if ( x > 0 ) : NEW_LINE INDENT ok = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( ok == True ) : NEW_LINE INDENT Len = mid NEW_LINE lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT DEDENT return Len NEW_LINE DEDENT
def prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def Min_Sum ( n ) : NEW_LINE INDENT if ( prime ( n ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT if ( prime ( n - 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT DEDENT
def MinDeletion ( a , n ) : NEW_LINE INDENT map = dict . fromkeys ( a , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ a [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for key , value in map . items ( ) : NEW_LINE INDENT x = key NEW_LINE frequency = value NEW_LINE if ( x <= frequency ) : NEW_LINE INDENT ans += ( frequency - x ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += frequency NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def find_maximum_value ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE minimum = 10 ** 9 NEW_LINE pos = 0 NEW_LINE neg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT minimum = min ( minimum , abs ( a [ i ] ) ) NEW_LINE sum += abs ( a [ i ] ) NEW_LINE if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT neg += 1 NEW_LINE DEDENT DEDENT if ( pos > 0 and neg > 0 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT return ( sum - 2 * minimum ) NEW_LINE DEDENT
def maxCountAB ( s , n ) : NEW_LINE INDENT A = 0 NEW_LINE DEDENT B = 0 NEW_LINE BA = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = s [ i ] NEW_LINE L = len ( S ) NEW_LINE for j in range ( L - 1 ) : NEW_LINE INDENT if ( S [ j ] == 'A' and S [ j + 1 ] == 'B' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ( S [ 0 ] == 'B' and S [ L - 1 ] == 'A' ) : NEW_LINE INDENT BA += 1 NEW_LINE DEDENT DEDENT elif ( S [ 0 ] == 'B' ) : B += 1 NEW_LINE
def MinOperations ( n , x , arr ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > x ) : NEW_LINE INDENT difference = arr [ i ] - x NEW_LINE total = total + difference NEW_LINE arr [ i ] = x NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] NEW_LINE if ( LeftNeigbouringSum > x ) : NEW_LINE INDENT current_diff = LeftNeigbouringSum - x NEW_LINE arr [ i ] = max ( 0 , arr [ i ] - current_diff ) NEW_LINE total = total + current_diff NEW_LINE DEDENT DEDENT return total NEW_LINE DEDENT
def countPairs ( s ) : NEW_LINE INDENT st = set ( ) NEW_LINE st . add ( 'a' ) NEW_LINE st . add ( 'e' ) NEW_LINE st . add ( 'i' ) NEW_LINE st . add ( 'o' ) NEW_LINE st . add ( 'u' ) NEW_LINE count = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] not in st and s [ i + 1 ] in st ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maxSize ( v , n ) : NEW_LINE INDENT v . append ( 0 ) NEW_LINE v . append ( 100001 ) NEW_LINE n += 2 NEW_LINE v = sorted ( v ) NEW_LINE mx = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT L = v [ i - 1 ] + 1 NEW_LINE R = v [ i + 1 ] - 1 NEW_LINE cnt = R - L + 1 NEW_LINE mx = max ( mx , cnt ) NEW_LINE DEDENT return mx NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxLength ( a , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE Len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += a [ i ] NEW_LINE return n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT Len = max ( Len , max ( n - i - 1 , i ) ) NEW_LINE DEDENT DEDENT return Len NEW_LINE DEDENT
def countMaxLength ( N ) : NEW_LINE INDENT pre = [ 0 for i in range ( MAXN ) ] NEW_LINE p = 1 NEW_LINE pre [ 0 ] = 0 NEW_LINE for i in range ( 1 , MAXN , 1 ) : NEW_LINE INDENT p *= 2 NEW_LINE pre [ i ] = pre [ i - 1 ] + i * p NEW_LINE DEDENT for i in range ( 1 , MAXN , 1 ) : NEW_LINE INDENT if ( pre [ i ] >= N ) : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT x = N - pre [ ind - 1 ] NEW_LINE y = 2 * ind - 1 NEW_LINE if ( x >= y ) : NEW_LINE INDENT res = min ( x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( x , 2 * ( ind - 2 ) + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def getMinVal ( p , q ) : NEW_LINE INDENT if q % p == 0 : NEW_LINE INDENT return p NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findPoints ( l1 , r1 , l2 , r2 ) : NEW_LINE INDENT x = min ( l1 , l2 ) if ( l1 != l2 ) else - 1 NEW_LINE y = max ( r1 , r2 ) if ( r1 != r2 ) else - 1 NEW_LINE print ( x , y ) NEW_LINE DEDENT
def countPrimePalindrome ( str1 , Len ) : NEW_LINE INDENT prime = [ True for i in range ( Len + 1 ) ] NEW_LINE prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( Len + 1 ) ) ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , Len + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for j in range ( 2 , Len + 1 ) : NEW_LINE INDENT if ( prime [ j ] ) : NEW_LINE INDENT for i in range ( Len + 1 - j ) : NEW_LINE INDENT if ( isPalindrome ( str1 , i , i + j - 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def minOperations ( N ) : NEW_LINE INDENT x = log2 ( N ) NEW_LINE ans = ceil ( x ) NEW_LINE return ans NEW_LINE DEDENT
def find_greatest_divisor ( l , r ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT return l NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def findNumbers ( arr , n ) : NEW_LINE INDENT sumN = ( n * ( n + 1 ) ) / 2 NEW_LINE sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE sum = 0 NEW_LINE sumSq = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE sumSq = sumSq + ( math . pow ( arr [ i ] , 2 ) ) NEW_LINE DEDENT B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 NEW_LINE A = sum - sumN + B NEW_LINE print ( "A = " , int ( A ) ) NEW_LINE print ( "B = " , int ( B ) ) NEW_LINE DEDENT
def factorialUsingRecursion ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorialUsingRecursion ( n - 1 ) NEW_LINE DEDENT
def factorialUsingIteration ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT
def checkPerfectSquare ( n ) : NEW_LINE INDENT d = sqrt ( n ) NEW_LINE if d * d == n : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def largestPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkPerfectSquare ( a [ i ] ) ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT
def convert ( n , a ) : NEW_LINE INDENT z = max ( a ) + 1 NEW_LINE ff = [ 0 ] * z NEW_LINE for i in range ( n ) : NEW_LINE INDENT ff [ a [ i ] ] += 1 NEW_LINE DEDENT cc = 0 NEW_LINE for i in range ( z ) : NEW_LINE INDENT cc += ff [ i ] // 4 NEW_LINE ff [ i ] = ff [ i ] % 4 NEW_LINE DEDENT vv = 0 NEW_LINE for i in range ( z ) : NEW_LINE INDENT if ( ff [ i ] >= 2 ) : NEW_LINE INDENT vv += 1 NEW_LINE DEDENT DEDENT cc += vv // 2 NEW_LINE print ( cc ) NEW_LINE DEDENT
def getProbability ( p , q ) : NEW_LINE INDENT p /= 100 NEW_LINE q /= 100 NEW_LINE probability = ( p * p + q * q ) / ( p + q ) NEW_LINE return probability NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] & 1 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def find_LCM ( x , y ) : NEW_LINE INDENT return ( x * y ) // gcd ( x , y ) NEW_LINE DEDENT
def CountPairs ( n , m , A , B ) : NEW_LINE INDENT cnt = 0 NEW_LINE lcm = find_LCM ( A , B ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT cnt += ( m + ( i % lcm ) ) // lcm NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def sortArr ( arr , n , min_no , max_no ) : NEW_LINE INDENT m = max_no - min_no + 1 NEW_LINE c = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ arr [ i ] - min_no ] += 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( ( c [ i ] ) ) : NEW_LINE INDENT print ( ( i + min_no ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def revereseArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT arr [ i ] , arr [ n - i - 1 ] = arr [ n - i - 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT
def recursiveLogStar ( n , b ) : NEW_LINE INDENT if ( n > 1.0 ) : NEW_LINE INDENT return 1.0 + recursiveLogStar ( _log ( n , b ) , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT
def maxKth ( arr , N , C , K ) : NEW_LINE INDENT if ( N + C < K ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT iter = 300 NEW_LINE l = 0 NEW_LINE r = 1000000000.0 NEW_LINE while ( iter ) : NEW_LINE INDENT iter = iter - 1 NEW_LINE mid = ( l + r ) * 0.5 NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a += arr [ i ] // mid NEW_LINE if ( arr [ i ] >= mid ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT if ( a >= K and b + C >= K ) : NEW_LINE INDENT l = mid NEW_LINE DEDENT else : NEW_LINE INDENT r = mid NEW_LINE DEDENT DEDENT return int ( l ) NEW_LINE DEDENT
def isPossibleToSelect ( arr , N , dif , K ) : NEW_LINE INDENT count = 1 NEW_LINE prev = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] >= ( prev + dif ) ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count == K ) : NEW_LINE INDENT return True NEW_LINE DEDENT prev = arr [ i ] NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def binarySearch ( arr , left , right , K , N ) : NEW_LINE INDENT ans = 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT dif = left + ( right - left ) // 2 NEW_LINE if ( isPossibleToSelect ( arr , N , dif , K ) ) : NEW_LINE INDENT ans = max ( ans , dif ) NEW_LINE left = dif + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right = dif - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def cal ( arr , mid ) : NEW_LINE INDENT chocolate = 0 NEW_LINE for i in arr : NEW_LINE INDENT if i >= mid : NEW_LINE INDENT chocolate += i - mid NEW_LINE DEDENT DEDENT return chocolate NEW_LINE DEDENT
def check ( bananas , mid_val , H ) : NEW_LINE INDENT time = 0 NEW_LINE for i in range ( len ( bananas ) ) : NEW_LINE INDENT if ( bananas [ i ] % mid_val != 0 ) : NEW_LINE INDENT time += bananas [ i ] // mid_val + 1 NEW_LINE DEDENT else : NEW_LINE INDENT time += bananas [ i ] // mid_val NEW_LINE DEDENT if ( time <= H ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT
def minEatingSpeed ( piles , H ) : NEW_LINE INDENT start = 1 NEW_LINE end = sorted ( piles . copy ( ) , reverse = True ) [ 0 ] NEW_LINE while ( start < end ) : NEW_LINE INDENT mid = start + ( end - start ) // 2 NEW_LINE if ( check ( piles , mid , H ) == True ) : NEW_LINE INDENT end = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT return end NEW_LINE DEDENT DEDENT
def is_prefix ( temp , str ) : NEW_LINE INDENT if ( len ( temp ) < len ( str ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] != temp [ i ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT DEDENT
def lexicographicallyString ( input , n , str ) : NEW_LINE INDENT input . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = input [ i ] NEW_LINE if ( is_prefix ( temp , str ) ) : NEW_LINE INDENT return temp NEW_LINE DEDENT DEDENT return "-1" NEW_LINE DEDENT
def minSumPair ( arr , N ) : NEW_LINE INDENT if ( N < 5 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prefixMin = [ 0 for i in range ( N ) ] NEW_LINE prefixMin [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , N - 1 , 1 ) : NEW_LINE INDENT prefixMin [ i ] = min ( arr [ i ] , prefixMin [ i - 1 ] ) NEW_LINE DEDENT ans = sys . maxsize NEW_LINE for i in range ( 3 , N - 1 , 1 ) : NEW_LINE INDENT ans = min ( ans , arr [ i ] + prefixMin [ i - 2 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def check ( H , A , mid , N , M , L ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT speed = mid * A [ i ] + H [ i ] NEW_LINE if ( speed >= L ) : NEW_LINE INDENT sum += speed NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def buzzTime ( N , M , L , H , A ) : NEW_LINE INDENT low = 0 NEW_LINE high = 1e10 NEW_LINE ans = 0 NEW_LINE while ( high >= low ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( check ( H , A , mid , N , M , L ) >= M ) : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT
def findCount ( number ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( number ) ) : NEW_LINE INDENT sum += int ( number [ i ] ) - 48 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( number ) ) : NEW_LINE INDENT remaining_sum = sum - ( int ( number [ i ] ) - 48 ) NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT if ( ( remaining_sum + j ) % 3 == 0 and j != int ( number [ i ] ) - 48 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def is_possible ( teams , T , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( teams ) ) : NEW_LINE INDENT sum += min ( T , teams [ i ] ) NEW_LINE DEDENT return ( sum >= ( T * k ) ) NEW_LINE DEDENT
def countOfTeams ( teams_list , N , K ) : NEW_LINE INDENT lb = 0 NEW_LINE ub = 1000000000 NEW_LINE while ( lb <= ub ) : NEW_LINE INDENT mid = lb + ( ub - lb ) // 2 NEW_LINE if ( is_possible ( teams_list , mid , K ) ) : NEW_LINE INDENT if ( is_possible ( teams_list , mid + 1 , K ) == False ) : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT lb = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ub = mid - 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def balBracketSequence ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( str [ 0 ] == str [ n - 1 ] ) : NEW_LINE INDENT print ( "No" , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT cntForOpen = 0 NEW_LINE cntForClose = 0 NEW_LINE check = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == str [ 0 ] ) : NEW_LINE INDENT cntForOpen += 1 NEW_LINE DEDENT elif str [ i ] == str [ n - 1 ] : NEW_LINE INDENT cntForOpen -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntForOpen += 1 NEW_LINE DEDENT if ( cntForOpen < 0 ) : NEW_LINE INDENT check = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( check and cntForOpen == 0 ) : NEW_LINE INDENT print ( "Yes, " , end = "" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == str [ n - 1 ] ) : NEW_LINE INDENT print ( ')' , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '(' , end = "" ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == str [ 0 ] ) : NEW_LINE INDENT cntForClose += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntForClose -= 1 NEW_LINE DEDENT if ( cntForClose < 0 ) : NEW_LINE INDENT check = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( check and cntForClose == 0 ) : NEW_LINE INDENT print ( "Yes, " , end = "" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == str [ 0 ] ) : NEW_LINE INDENT print ( '(' , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ')' , end = "" ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT DEDENT print ( "NO" , end = "" ) NEW_LINE DEDENT DEDENT
def minimumOperations ( arr , N ) : NEW_LINE INDENT mx = 0 NEW_LINE pos = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] >= mx ) : NEW_LINE INDENT mx = arr [ i ] NEW_LINE pos = i NEW_LINE DEDENT DEDENT print ( ( mx - 1 ) * N + pos + 1 ) NEW_LINE DEDENT
def check ( v , a ) : NEW_LINE INDENT tec = 0 NEW_LINE ans = 0 NEW_LINE b = [ 0 for i in range ( n + k + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT tec -= b [ i ] NEW_LINE if ( a [ i ] + tec < v ) : NEW_LINE INDENT mov = v - a [ i ] - tec NEW_LINE ans = ans + mov NEW_LINE tec += mov NEW_LINE b [ i + k ] = mov NEW_LINE DEDENT DEDENT return ( ans <= m ) NEW_LINE DEDENT
def FindLargest ( a ) : NEW_LINE INDENT l = 1 NEW_LINE r = pow ( 10 , 10 ) NEW_LINE while ( r - l > 0 ) : NEW_LINE INDENT tm = ( l + r + 1 ) // 2 NEW_LINE if ( check ( tm , a ) ) : NEW_LINE INDENT l = tm NEW_LINE DEDENT else : NEW_LINE INDENT r = tm - 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT
def largestAltitude ( L , B ) : NEW_LINE INDENT if ( L > B ) : NEW_LINE INDENT temp = B NEW_LINE B = L NEW_LINE L = temp NEW_LINE DEDENT low = 0 NEW_LINE high = L NEW_LINE res = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid <= ( B / 2 ) ) : NEW_LINE INDENT res = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findLargestIndex ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == i ) : NEW_LINE INDENT print ( i ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def isMaximumMedian ( arr , N , K , mid ) : NEW_LINE INDENT Pre = [ [ 0 for x in range ( N + 5 ) ] for y in range ( N + 5 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT Pre [ i + 1 ] [ j + 1 ] = ( Pre [ i + 1 ] [ j ] + Pre [ i ] [ j + 1 ] - Pre [ i ] [ j ] ) NEW_LINE if ( arr [ i ] [ j ] <= mid ) : NEW_LINE INDENT Pre [ i + 1 ] [ j + 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT required = ( K * K + 1 ) // 2 NEW_LINE flag = 0 NEW_LINE for i in range ( K , N + 1 ) : NEW_LINE INDENT for j in range ( K , N + 1 ) : NEW_LINE INDENT X = ( Pre [ i ] [ j ] - Pre [ i - K ] [ j ] - Pre [ i ] [ j - K ] + Pre [ i - K ] [ j - K ] ) NEW_LINE if ( X < required ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT DEDENT return flag NEW_LINE DEDENT
def getPairsCount ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( a [ i ] * a [ j ] ) == abs ( i - j ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def getPairsCount ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s = arr [ i ] - ( i % arr [ i ] ) NEW_LINE for j in range ( s , n ) : NEW_LINE INDENT if ( i < j and ( arr [ i ] * arr [ j ] ) == abs ( i - j ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def numberofSubsequences ( a , L , R , X , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , ( 1 << n ) , 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE sum = 0 NEW_LINE minVal = sys . maxsize NEW_LINE maxVal = - sys . maxsize - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( i & ( 1 << j ) ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE sum += a [ j ] NEW_LINE maxVal = max ( maxVal , a [ j ] ) NEW_LINE minVal = min ( minVal , a [ j ] ) NEW_LINE DEDENT DEDENT if ( cnt >= 2 and sum >= L and sum <= R and ( maxVal - minVal >= X ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def numberofBoxes ( W , B , O ) : NEW_LINE INDENT low = 0 NEW_LINE high = min ( W , B ) NEW_LINE ans = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( ( W >= mid ) and ( B >= mid ) ) and ( ( W - mid ) + ( B - mid ) + O ) >= mid ) : NEW_LINE INDENT ans = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def minSwaps ( N , M , A , B ) : NEW_LINE INDENT count01 = 0 NEW_LINE count10 = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , M ) : NEW_LINE INDENT if ( A [ i ] [ j ] != B [ i ] [ j ] ) : NEW_LINE INDENT if ( A [ i ] [ j ] == 1 ) : NEW_LINE INDENT count10 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count01 += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( count01 == count10 ) : NEW_LINE INDENT return count01 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def Count ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE low = 1 NEW_LINE high = N NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE sum = ( mid * mid + mid ) // 2 NEW_LINE if ( sum <= K ) : NEW_LINE INDENT res = max ( res , mid ) NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def createLoops ( root ) : NEW_LINE INDENT preorderTraversal ( root ) NEW_LINE i = 1 NEW_LINE while i < len ( even_ptrs ) : NEW_LINE INDENT even_ptrs [ i - 1 ] . abtr = even_ptrs [ i ] NEW_LINE i += 1 NEW_LINE DEDENT even_ptrs [ i - 1 ] . abtr = even_ptrs [ 0 ] NEW_LINE i = 1 NEW_LINE while i < len ( odd_ptrs ) : NEW_LINE INDENT odd_ptrs [ i - 1 ] . abtr = odd_ptrs [ i ] NEW_LINE i += 1 NEW_LINE DEDENT odd_ptrs [ i - 1 ] . abtr = odd_ptrs [ 0 ] NEW_LINE DEDENT
def traverseLoop ( start ) : NEW_LINE INDENT curr = start NEW_LINE while True and curr : NEW_LINE INDENT print ( curr . data , end = " " ) NEW_LINE curr = curr . abtr NEW_LINE if curr == start : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
def repeatingElement ( arr , N ) : NEW_LINE INDENT M = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE M = max ( M , arr [ i ] ) NEW_LINE DEDENT sum1 = M * ( M + 1 ) // 2 NEW_LINE ans = ( sum - sum1 ) // ( N - M ) NEW_LINE return ans NEW_LINE DEDENT
def lexicographicallyMaximum ( S , N ) : NEW_LINE INDENT M = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if S [ i ] in M : NEW_LINE INDENT M [ S [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT M [ S [ i ] ] = 1 NEW_LINE DEDENT V = [ ] NEW_LINE for i in range ( ord ( 'a' ) , ord ( 'a' ) + min ( N , 25 ) ) : NEW_LINE INDENT if i not in M : NEW_LINE INDENT V . append ( chr ( i ) ) NEW_LINE DEDENT DEDENT j = len ( V ) - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( ord ( S [ i ] ) >= ( ord ( 'a' ) + min ( N , 25 ) ) or ( S [ i ] in M and M [ S [ i ] ] > 1 ) ) : NEW_LINE INDENT if ( ord ( V [ j ] ) < ord ( S [ i ] ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT M [ S [ i ] ] -= 1 NEW_LINE S = S [ 0 : i ] + V [ j ] + S [ ( i + 1 ) : ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( j < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( l > j ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( ord ( S [ i ] ) >= ( ord ( 'a' ) + min ( N , 25 ) ) or S [ i ] in M and M [ S [ i ] ] > 1 ) : NEW_LINE INDENT M [ S [ i ] ] -= 1 NEW_LINE S = S [ 0 : i ] + V [ l ] + S [ ( i + 1 ) : ] NEW_LINE l += 1 NEW_LINE DEDENT DEDENT s = list ( S ) NEW_LINE s [ len ( s ) - 1 ] = 'd' NEW_LINE S = "" . join ( s ) NEW_LINE return S NEW_LINE DEDENT DEDENT
def minimumK ( arr , M , N ) : NEW_LINE INDENT good = math . ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT K = i NEW_LINE candies = N NEW_LINE taken = 0 NEW_LINE while ( candies > 0 ) : NEW_LINE INDENT taken += min ( K , candies ) NEW_LINE candies -= min ( K , candies ) NEW_LINE for j in range ( M ) : NEW_LINE INDENT consume = ( arr [ j ] * candies ) / 100 NEW_LINE candies -= consume NEW_LINE DEDENT DEDENT if ( taken >= good ) : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT return NEW_LINE DEDENT DEDENT
def minTimeToColor ( node , parent , arrival_time ) : NEW_LINE INDENT global ans NEW_LINE current_time = 0 NEW_LINE for x in edges [ node ] : NEW_LINE INDENT if ( x != parent ) : NEW_LINE INDENT current_time += 1 NEW_LINE if ( current_time == arrival_time ) : NEW_LINE INDENT current_time += 1 NEW_LINE DEDENT ans = max ( ans , current_time ) NEW_LINE minTimeToColor ( x , node , current_time ) NEW_LINE DEDENT DEDENT DEDENT
def countElement ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE m = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT lg = int ( log2 ( arr [ i ] ) ) NEW_LINE p = pow ( 2 , lg ) NEW_LINE if ( p in m ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findLarger ( arr , n ) : NEW_LINE INDENT mid = ( n + 1 ) // 2 NEW_LINE mx = max ( arr ) NEW_LINE count = [ 0 ] * ( mx + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( mx , - 1 , - 1 ) : NEW_LINE INDENT while ( count [ i ] > 0 ) : NEW_LINE INDENT count [ i ] -= 1 NEW_LINE mid -= 1 NEW_LINE print ( i , end = " " ) NEW_LINE if ( mid == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( mid == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def maximizeMangoes ( n , m , x , y ) : NEW_LINE INDENT l = 0 NEW_LINE r = n NEW_LINE ans = 0 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if ( check ( n , m , x , y , mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def probability ( arr1 , arr2 ) : NEW_LINE INDENT N = len ( arr1 ) NEW_LINE M = len ( arr2 ) NEW_LINE res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT y = 0 NEW_LINE for j in range ( M ) : NEW_LINE INDENT if ( arr2 [ j ] > arr1 [ i ] ) : NEW_LINE INDENT y += 1 NEW_LINE DEDENT DEDENT res += y NEW_LINE DEDENT res = res / ( N * M ) NEW_LINE return res NEW_LINE DEDENT
def probability ( arr1 , arr2 ) : NEW_LINE INDENT n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE res = 0 NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT y = countGreater ( arr2 , arr1 [ i ] ) NEW_LINE res += y NEW_LINE DEDENT res /= ( n * m ) NEW_LINE return res NEW_LINE DEDENT
def countGreater ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE leftGreater = n NEW_LINE while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if ( arr [ m ] > k ) : NEW_LINE INDENT leftGreater = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return n - leftGreater NEW_LINE DEDENT
def findkthElement ( arr , n , K ) : NEW_LINE INDENT l = 0 NEW_LINE h = n - 1 NEW_LINE while l + 1 < h : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if arr [ l ] >= arr [ mid ] : NEW_LINE INDENT l = mid NEW_LINE DEDENT else : NEW_LINE INDENT h = mid NEW_LINE DEDENT DEDENT if arr [ l ] < arr [ h ] : NEW_LINE INDENT r = l NEW_LINE DEDENT else : NEW_LINE INDENT r = h NEW_LINE DEDENT if K <= r + 1 : NEW_LINE INDENT return arr [ r + 1 - K ] NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ n - ( K - ( r + 1 ) ) ] NEW_LINE DEDENT DEDENT
def find ( arr , N , key ) : NEW_LINE INDENT l = 0 NEW_LINE h = N - 1 NEW_LINE while l <= h : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if arr [ mid ] == key : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ l ] >= arr [ mid ] : NEW_LINE INDENT if arr [ l ] >= key >= arr [ mid ] : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if arr [ mid ] >= key >= arr [ h ] : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countInversions ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT itr = bisect_left ( v , arr [ i ] ) NEW_LINE ans += itr NEW_LINE v = v [ : itr ] + v [ itr + 1 : ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def countDistinct ( arr , L , R ) : NEW_LINE INDENT count = 0 NEW_LINE pref = [ 0 ] * ( len ( arr ) + 1 ) NEW_LINE for i in range ( 1 , len ( arr ) + 1 ) : NEW_LINE INDENT count += arr [ i - 1 ] NEW_LINE pref [ i ] = count NEW_LINE DEDENT left = binarysearch ( pref , len ( arr ) + 1 , L ) NEW_LINE right = binarysearch ( pref , len ( arr ) + 1 , R ) NEW_LINE print ( right - left + 1 ) NEW_LINE DEDENT
def ischar ( x ) : NEW_LINE INDENT if ( ( x >= 'A' and x <= 'Z' ) or ( x >= 'a' and x <= 'z' ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def isnum ( x ) : NEW_LINE INDENT if ( x >= '0' and x <= '9' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def maxItems ( n , m , a , b , K ) : NEW_LINE INDENT count = 0 NEW_LINE A = [ 0 for i in range ( n + 1 ) ] NEW_LINE B = [ 0 for i in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT A [ i ] = a [ i - 1 ] + A [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , m + 1 , 1 ) : NEW_LINE INDENT B [ i ] = b [ i - 1 ] + B [ i - 1 ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( A [ i ] > K ) : NEW_LINE INDENT break NEW_LINE DEDENT rem = K - A [ i ] NEW_LINE j = 0 NEW_LINE lo = 0 NEW_LINE hi = m NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE if ( B [ mid ] <= rem ) : NEW_LINE INDENT j = mid NEW_LINE lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT DEDENT count = max ( j + i , count ) NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def isValid ( weight , n , D , mx ) : NEW_LINE INDENT st = 1 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += weight [ i ] NEW_LINE if ( sum > mx ) : NEW_LINE INDENT st += 1 NEW_LINE sum = weight [ i ] NEW_LINE DEDENT if ( st > D ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def shipWithinDays ( weight , D , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += weight [ i ] NEW_LINE DEDENT s = weight [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s = max ( s , weight [ i ] ) NEW_LINE DEDENT e = sum NEW_LINE res = - 1 NEW_LINE while ( s <= e ) : NEW_LINE INDENT mid = s + ( e - s ) // 2 NEW_LINE if ( isValid ( weight , n , D , mid ) ) : NEW_LINE INDENT res = mid NEW_LINE e = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT s = mid + 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def countWays ( index , target ) : NEW_LINE INDENT if ( target == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( index < 0 or target < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT inc = countWays ( index , target - psquare [ index ] ) NEW_LINE exc = countWays ( index - 1 , target ) NEW_LINE return inc + exc NEW_LINE DEDENT
def findSum ( arr , N , pt ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += abs ( arr [ i ] - pt ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findArray ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = - 1 NEW_LINE old_c = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT curr_c = arr [ j : n + 1 ] . count ( arr [ j ] ) NEW_LINE if ( curr_c == old_c ) : NEW_LINE INDENT if ( arr [ j ] < ans ) : NEW_LINE INDENT ans = arr [ j ] NEW_LINE DEDENT DEDENT if ( curr_c > old_c ) : NEW_LINE INDENT ans = arr [ j ] NEW_LINE old_c = curr_c NEW_LINE DEDENT DEDENT DEDENT v . append ( ans ) NEW_LINE DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT print ( v [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def minDays ( P , arr ) : NEW_LINE INDENT for i in range ( 1 , len ( P ) ) : NEW_LINE INDENT P [ i ] += P [ i ] + P [ i - 1 ] NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT index = binarySeach ( P , arr [ i ] ) NEW_LINE if ( index != - 1 ) : NEW_LINE INDENT print ( index + 1 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def countTriplets ( D , arr ) : NEW_LINE INDENT freq = { } NEW_LINE ans = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( ( ( arr [ i ] - D ) in freq ) and ( arr [ i ] - 2 * D ) in freq ) : NEW_LINE INDENT ans += ( freq [ arr [ i ] - D ] * freq [ arr [ i ] - 2 * D ] ) NEW_LINE DEDENT freq [ arr [ i ] ] = freq . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def find_index ( arr , N ) : NEW_LINE INDENT max_value = - 10 ** 9 NEW_LINE for i in range ( N ) : NEW_LINE INDENT max_value = max ( max_value , arr [ i ] ) NEW_LINE DEDENT store = { } NEW_LINE for i in range ( 1 , max_value + 1 ) : NEW_LINE INDENT store [ i ] = store . get ( i , 0 ) + 1 NEW_LINE DEDENT if ( 1 in store ) : NEW_LINE INDENT del store [ 1 ] NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( max_value ) ) + 1 ) : NEW_LINE INDENT multiple = 2 NEW_LINE while ( ( i * multiple ) <= max_value ) : NEW_LINE INDENT if ( i * multiple in store ) : NEW_LINE INDENT del store [ i * multiple ] NEW_LINE DEDENT multiple += 1 NEW_LINE DEDENT DEDENT prime_sum_from_left = 0 NEW_LINE first_array = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT first_array [ i ] = prime_sum_from_left NEW_LINE if arr [ i ] in store : NEW_LINE INDENT prime_sum_from_left += arr [ i ] NEW_LINE DEDENT DEDENT prime_sum_from_right = 0 NEW_LINE second_array = [ 0 ] * N NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT second_array [ i ] = prime_sum_from_right NEW_LINE if ( arr [ i ] in store ) : NEW_LINE INDENT prime_sum_from_right += arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( first_array [ i ] == second_array [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def convert ( arr , n ) : NEW_LINE INDENT brr = [ i for i in arr ] NEW_LINE brr = sorted ( brr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r , mid = 0 , n - 1 , 0 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if ( brr [ mid ] == arr [ i ] ) : NEW_LINE INDENT print ( mid , end = " " ) NEW_LINE break NEW_LINE DEDENT elif ( brr [ mid ] < arr [ i ] ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findIndex ( arr , N ) : NEW_LINE INDENT maxValue = - sys . maxsize - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT maxValue = max ( maxValue , arr [ i ] ) NEW_LINE DEDENT St = defaultdict ( int ) NEW_LINE for i in range ( 1 , maxValue + 1 ) : NEW_LINE INDENT St [ i ] += 1 NEW_LINE DEDENT if ( 1 in St ) : NEW_LINE INDENT St . pop ( 1 ) NEW_LINE DEDENT for i in range ( 2 , int ( math . sqrt ( maxValue ) ) + 1 ) : NEW_LINE INDENT j = 2 NEW_LINE while ( ( i * j ) <= maxValue ) : NEW_LINE INDENT if ( i * j ) in St : NEW_LINE INDENT St . pop ( i * j ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT LeftCount = 0 NEW_LINE Prefix = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT Prefix [ i ] = LeftCount NEW_LINE if ( arr [ i ] in St ) : NEW_LINE INDENT LeftCount += 1 NEW_LINE DEDENT DEDENT RightCount = 0 NEW_LINE Suffix = [ 0 ] * N NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT Suffix [ i ] = RightCount NEW_LINE if arr [ i ] in St : NEW_LINE INDENT RightCount += 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( Prefix [ i ] == Suffix [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def getCountPairs ( arr , N , S ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( arr ) ) : NEW_LINE INDENT if ( ( arr [ i ] + arr [ j ] ) == S ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def isPrime ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT if ( N % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findCoPrime ( L , R ) : NEW_LINE INDENT coPrime , i = 0 , R + 1 NEW_LINE while True : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT coPrime = i NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return coPrime NEW_LINE DEDENT
def replaceCharacters ( s , p ) : NEW_LINE INDENT n , k = len ( s ) , len ( p ) NEW_LINE arr = [ 0 ] * 26 NEW_LINE brr = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - ord ( 'a' ) ] = s [ i ] NEW_LINE brr [ ord ( s [ i ] ) - ord ( 'a' ) ] = s [ i ] NEW_LINE DEDENT for j in range ( k ) : NEW_LINE INDENT a , b = p [ j ] [ 0 ] , p [ j ] [ 1 ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( arr [ i ] == a ) : NEW_LINE INDENT brr [ i ] = b NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( brr [ ord ( s [ i ] ) - ord ( 'a' ) ] , end = "" ) NEW_LINE DEDENT DEDENT
def maximumValue ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = max ( ans , arr [ i ] + arr [ j ] + i - j ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def maximumValue ( arr , n ) : NEW_LINE INDENT maxvalue = arr [ 0 ] NEW_LINE result = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result = max ( result , maxvalue + arr [ i ] - i ) NEW_LINE maxvalue = max ( maxvalue , arr [ i ] + i ) NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT
def smallestSemiPrime ( n ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE SieveOfEratosthenes ( prime ) NEW_LINE num1 = n + 1 NEW_LINE while ( prime [ num1 ] != True ) : NEW_LINE INDENT num1 += 1 NEW_LINE DEDENT num2 = num1 + n NEW_LINE while ( prime [ num2 ] != True ) : NEW_LINE INDENT num2 += 1 NEW_LINE DEDENT print ( num1 * num2 ) NEW_LINE DEDENT
def productOfTwoPerfectCubes ( N ) : NEW_LINE INDENT cubes = { } NEW_LINE i = 1 NEW_LINE while i * i * i <= N : NEW_LINE INDENT cubes [ i * i * i ] = i NEW_LINE i += 1 NEW_LINE DEDENT for itr in cubes : NEW_LINE INDENT firstNumber = itr NEW_LINE if ( N % itr == 0 ) : NEW_LINE INDENT secondNumber = N // itr NEW_LINE if ( secondNumber in cubes ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( "No" ) NEW_LINE DEDENT
def productOfTwoPerfectCubes ( N ) : NEW_LINE INDENT cube_root = round ( ( N ) ** ( 1 / 3 ) ) NEW_LINE print ( cube_root ) NEW_LINE if ( cube_root * cube_root * cube_root == N ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT DEDENT
def bound ( w , h , N , x ) : NEW_LINE INDENT val = ( x // w ) * ( x // h ) NEW_LINE if ( val >= N ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def FindSquare ( N , W , H ) : NEW_LINE INDENT i = 1 NEW_LINE j = W * H * N NEW_LINE while ( i < j ) : NEW_LINE INDENT mid = i + ( j - i ) // 2 NEW_LINE if ( bound ( W , H , N , mid ) ) : NEW_LINE INDENT j = mid NEW_LINE DEDENT else : NEW_LINE INDENT i = mid + 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT
def printNumberOfPairs ( N ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( 2 , int ( sqrt ( N ) ) + 1 , 1 ) : NEW_LINE INDENT x = i NEW_LINE while ( x <= N ) : NEW_LINE INDENT x *= i NEW_LINE if ( x <= N ) : NEW_LINE INDENT st . add ( x ) NEW_LINE DEDENT DEDENT DEDENT print ( len ( st ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def maximumProduct ( words ) : NEW_LINE INDENT bits = [ 0 for i in range ( len ( words ) ) ] NEW_LINE for i in range ( len ( words ) ) : NEW_LINE INDENT for j in range ( len ( words [ i ] ) ) : NEW_LINE INDENT bits [ i ] = bits [ i ] | 1 << ( ord ( words [ i ] [ j ] ) - 97 ) NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in range ( len ( bits ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( bits ) ) : NEW_LINE INDENT if ( ( bits [ i ] & bits [ j ] ) == 0 ) : NEW_LINE INDENT L = countSetBits ( bits [ i ] ) NEW_LINE R = countSetBits ( bits [ j ] ) NEW_LINE result = max ( L * R , result ) NEW_LINE DEDENT DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def closestValue ( A , k ) : NEW_LINE INDENT close = A [ - 1 ] NEW_LINE it = lower_bound ( A , k ) NEW_LINE if ( it != len ( A ) ) : NEW_LINE INDENT close = A [ it ] NEW_LINE if ( it != 0 ) : NEW_LINE INDENT if ( ( k - A [ it - 1 ] ) < ( close - k ) ) : NEW_LINE INDENT close = A [ it - 1 ] NEW_LINE DEDENT DEDENT DEDENT return close NEW_LINE DEDENT
def minPossible ( arr , brr , crr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE crr . sort ( ) NEW_LINE minimum = 10 ** 9 NEW_LINE for val in brr : NEW_LINE INDENT arr_close = closestValue ( arr , val ) NEW_LINE crr_close = closestValue ( crr , val ) NEW_LINE if ( abs ( val - arr_close ) + abs ( val - crr_close ) < minimum ) : NEW_LINE INDENT minimum = abs ( val - arr_close ) + abs ( val - crr_close ) NEW_LINE DEDENT DEDENT print ( minimum ) NEW_LINE DEDENT
def findCost ( A , N ) : NEW_LINE INDENT totalCost = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] == 0 ) : NEW_LINE INDENT A [ i ] = 1 NEW_LINE totalCost += i NEW_LINE DEDENT DEDENT return totalCost NEW_LINE DEDENT
def palindrome ( string ) : NEW_LINE INDENT if ( string == string [ : : - 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def possible ( A , N , mid , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT count += ( A [ i ] - 1 ) // mid NEW_LINE DEDENT return count <= K NEW_LINE DEDENT
def minimumMaximum ( A , N , K ) : NEW_LINE INDENT lo = 1 NEW_LINE hi = max ( A ) NEW_LINE while ( lo < hi ) : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE if ( possible ( A , N , mid , K ) ) : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT return hi NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def sumOfPrimeSquare ( n ) : NEW_LINE INDENT i = 0 NEW_LINE squares = [ ] NEW_LINE while ( i * i < n ) : NEW_LINE INDENT squares . append ( i * i ) NEW_LINE i += 1 NEW_LINE DEDENT flag = False NEW_LINE for i in range ( len ( squares ) ) : NEW_LINE INDENT difference = n - squares [ i ] NEW_LINE if ( isPrime ( difference ) ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def SieveOfEratosthenes ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( n ** ( 1 / 2 ) ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p ** 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def sumOfPrimeSquare ( n ) : NEW_LINE INDENT flag = False NEW_LINE prime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( prime , n ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT dif = n - i NEW_LINE if ( math . ceil ( dif ** ( 1 / 2 ) ) == math . floor ( dif ** ( 1 / 2 ) ) ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def minimum_swaps ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE max_el = max ( arr ) NEW_LINE min_el = min ( arr ) NEW_LINE if ( min_el == max_el ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT index_max = - 1 NEW_LINE index_min = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == max_el and index_max == - 1 ) : NEW_LINE INDENT index_max = i NEW_LINE DEDENT if ( arr [ i ] == min_el ) : NEW_LINE INDENT index_min = i NEW_LINE DEDENT DEDENT count += index_max NEW_LINE count += ( n - 1 - index_min ) NEW_LINE if ( index_min < index_max ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def check ( arr , M , K , ind ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( 1 , K , 1 ) : NEW_LINE INDENT if ( arr [ ind + i ] != arr [ ind + i + j * M ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def SubarrayRepeatsKorMore ( arr , N , M , K ) : NEW_LINE INDENT for ind in range ( N - M * K + 1 ) : NEW_LINE INDENT if ( check ( arr , M , K , ind ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def checkExists ( arr , N , M , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N - M ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + M ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT if ( count == M * ( K - 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def CommonDigits ( N , M ) : NEW_LINE INDENT count = 0 NEW_LINE freq1 = [ 0 ] * 10 NEW_LINE freq2 = [ 0 ] * 10 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT freq1 [ N % 10 ] += 1 NEW_LINE N = N // 10 NEW_LINE DEDENT while ( M > 0 ) : NEW_LINE INDENT freq2 [ M % 10 ] += 1 NEW_LINE M = M // 10 NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT if ( freq1 [ i ] > 0 and freq2 [ i ] > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def minimumNumber ( K , X ) : NEW_LINE INDENT if ( K > X ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT ans = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( K , X + 1 ) : NEW_LINE INDENT sum += i NEW_LINE if ( sum >= X ) : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def isGreaterEqual ( N , K , X ) : NEW_LINE INDENT return ( ( ( N * ( N + 1 ) // 2 ) - ( ( K - 1 ) * K // 2 ) ) >= X ) NEW_LINE DEDENT
def left_search ( A , num ) : NEW_LINE INDENT low , high = 0 , len ( A ) - 1 NEW_LINE ans = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( A [ mid ] >= num ) : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def totalCount ( A , N , M , queries , Q ) : NEW_LINE INDENT row_sum = [ 0 ] * N NEW_LINE col_sum = [ 0 ] * M NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT row_sum [ i ] += A [ i ] [ j ] NEW_LINE col_sum [ j ] += A [ i ] [ j ] NEW_LINE DEDENT DEDENT sum_list = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum_list . append ( row_sum [ i ] ) NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT sum_list . append ( col_sum [ i ] ) NEW_LINE DEDENT sum_list = sorted ( sum_list ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT L = queries [ i ] [ 0 ] NEW_LINE R = queries [ i ] [ 1 ] NEW_LINE l = left_search ( sum_list , L ) NEW_LINE r = right_search ( sum_list , R ) NEW_LINE print ( r - l + 1 , end = " " ) NEW_LINE DEDENT DEDENT
def search ( list , num ) : NEW_LINE INDENT low , high = 0 , len ( list ) - 1 NEW_LINE ans = - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( list [ mid ] <= num ) : NEW_LINE INDENT ans = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isPalindrome ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE temp = n NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rev = rev * 10 + n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return rev == temp NEW_LINE DEDENT
def countNumbers ( L , R , K ) : NEW_LINE INDENT list = [ ] NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isPalindrome ( i ) ) : NEW_LINE INDENT list . append ( i ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( len ( list ) ) : NEW_LINE INDENT right_index = search ( list , list [ i ] + K - 1 ) NEW_LINE if ( right_index != - 1 ) : NEW_LINE INDENT count = max ( count , right_index - i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maximumLength ( mat , V ) : NEW_LINE INDENT distance = 0 NEW_LINE N = len ( mat ) NEW_LINE Adj = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT Adj [ i ] . append ( j ) NEW_LINE DEDENT DEDENT DEDENT dfs ( V , Adj , 0 , distance ) NEW_LINE return distance + 2 NEW_LINE DEDENT
def getMaximumDifference ( Edges , arr , N , M ) : NEW_LINE INDENT global ans NEW_LINE Adj = [ [ ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT u = Edges [ i ] [ 0 ] NEW_LINE v = Edges [ i ] [ 1 ] NEW_LINE Adj [ u ] . append ( v ) NEW_LINE DEDENT DFS ( 1 , Adj , arr , arr [ 0 ] , arr [ 0 ] ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def minimumDeletions ( S ) : NEW_LINE INDENT len1 = 0 NEW_LINE n = len ( S ) NEW_LINE for i in range ( 0 , 26 , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , 26 , 1 ) : NEW_LINE INDENT newLen = findLength ( S , chr ( i + 97 ) , chr ( j + 97 ) ) NEW_LINE len1 = max ( len1 , newLen ) NEW_LINE DEDENT DEDENT return n - len1 NEW_LINE DEDENT
def findMinX ( A , B , N ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT prod *= A [ i ] NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT pp = prod // A [ i ] NEW_LINE result += B [ i ] * inv ( pp , A [ i ] ) * pp NEW_LINE DEDENT return result % prod NEW_LINE DEDENT
def findPairs ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT arr [ i ] = abs ( arr [ i ] ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE left = 0 NEW_LINE ans = 0 NEW_LINE for right in range ( N ) : NEW_LINE INDENT while ( 2 * arr [ left ] < arr [ right ] ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT ans += ( right - left ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def GetDiff ( A , N ) : NEW_LINE INDENT SuffMaxArr = [ 0 for i in range ( N ) ] NEW_LINE SuffMaxArr [ N - 1 ] = A [ N - 1 ] NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT SuffMaxArr [ i ] = max ( SuffMaxArr [ i + 1 ] , A [ i + 1 ] ) NEW_LINE i -= 1 NEW_LINE DEDENT MaximumSum = - sys . maxsize - 1 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i ] < SuffMaxArr [ i ] ) : NEW_LINE INDENT MaximumSum = max ( MaximumSum , A [ i ] + SuffMaxArr [ i ] ) NEW_LINE DEDENT DEDENT MinimumSum = sys . maxsize NEW_LINE SuffMinArr = [ 0 for i in range ( N ) ] NEW_LINE SuffMinArr [ N - 1 ] = sys . maxsize NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT SuffMinArr [ i ] = min ( SuffMinArr [ i + 1 ] , A [ i + 1 ] ) NEW_LINE i -= 1 NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i ] < SuffMinArr [ i ] ) : NEW_LINE INDENT MinimumSum = min ( MinimumSum , A [ i ] + SuffMinArr [ i ] ) NEW_LINE DEDENT DEDENT return abs ( MaximumSum - MinimumSum ) NEW_LINE DEDENT
def minimumSwaps ( arr , N ) : NEW_LINE INDENT even , odd = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 != i % 2 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT DEDENT if ( even != odd ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( even ) NEW_LINE DEDENT DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def primeFactorSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( k % arr [ i ] == 0 and isPrime ( arr [ i ] ) ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE DEDENT
def CalculateValues ( N ) : NEW_LINE INDENT for C in range ( 0 , N // 7 + 1 ) : NEW_LINE INDENT for B in range ( 0 , N // 5 + 1 ) : NEW_LINE INDENT A = N - 7 * C - 5 * B NEW_LINE if ( A >= 0 and A % 3 == 0 ) : NEW_LINE INDENT print ( "A =" , A / 3 , ", B =" , B , ", \ C =" , C , sep = " " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT
def mininsert ( arr , K , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT a = min ( arr [ i ] , arr [ i + 1 ] ) NEW_LINE b = max ( arr [ i ] , arr [ i + 1 ] ) NEW_LINE while ( K * a < b ) : NEW_LINE INDENT a *= K NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def makeLexicographically ( arr , N ) : NEW_LINE INDENT index = 0 NEW_LINE temp = 0 NEW_LINE check = 0 NEW_LINE condition = 0 NEW_LINE element = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( element == arr [ i ] ) : NEW_LINE INDENT check = i NEW_LINE break NEW_LINE DEDENT elif ( arr [ i ] != i + 1 and check == 0 ) : NEW_LINE INDENT index = i NEW_LINE check = 1 NEW_LINE condition = - 1 NEW_LINE element = i + 1 NEW_LINE DEDENT DEDENT if ( condition == - 1 ) : NEW_LINE INDENT temp = arr [ index ] NEW_LINE arr [ index ] = arr [ check ] NEW_LINE arr [ check ] = temp NEW_LINE DEDENT printt ( arr , N ) NEW_LINE DEDENT
def print_triplet ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT print ( i - 1 , i , i + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def findConcatenatedNumbers ( a , b ) : NEW_LINE INDENT ans = True NEW_LINE n1 = len ( a ) NEW_LINE n2 = len ( b ) NEW_LINE cnt = defaultdict ( int ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT cnt [ a [ i ] ] = 1 NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT left = b [ i ] NEW_LINE right = 0 NEW_LINE mul = 1 NEW_LINE while ( left > 9 ) : NEW_LINE INDENT right += ( left % 10 ) * mul NEW_LINE left //= 10 NEW_LINE mul *= 10 NEW_LINE if ( cnt [ left ] == 1 and cnt [ right ] == 1 ) : NEW_LINE INDENT ans = False NEW_LINE print ( b [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if ( ans ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def evenproduct ( arr , length ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( length + 1 ) : NEW_LINE INDENT product = 1 NEW_LINE for j in range ( i , length + 1 ) : NEW_LINE INDENT product *= arr [ j ] NEW_LINE DEDENT if ( product % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT DEDENT
def evenproduct ( arr , length ) : NEW_LINE INDENT total_subarray = length * ( length + 1 ) // 2 NEW_LINE total_odd = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_odd = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE total_odd += count_odd NEW_LINE DEDENT DEDENT print ( total_subarray - total_odd ) NEW_LINE DEDENT
def dfsUtil ( u , par , depth ) : NEW_LINE INDENT global adj , ans NEW_LINE for it in adj [ u ] : NEW_LINE INDENT if ( it != par ) : NEW_LINE INDENT dfsUtil ( it , u , depth + 1 ) NEW_LINE DEDENT DEDENT ans += depth NEW_LINE DEDENT
def isInGroupUtil ( mat ) : NEW_LINE INDENT for i in mat : NEW_LINE INDENT if not checkGroup ( i ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isInGroup ( mat ) : NEW_LINE INDENT ans = isInGroupUtil ( mat ) NEW_LINE if ans : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def convertBinaryToDecimal ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT ans = ( ans << 1 ) | i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def decimalEquilvalentAtEachLevel ( root ) : NEW_LINE INDENT ans = 0 NEW_LINE que = [ root ] NEW_LINE while True : NEW_LINE INDENT length = len ( que ) NEW_LINE if not length : NEW_LINE INDENT break NEW_LINE DEDENT eachLvl = [ ] NEW_LINE while length : NEW_LINE INDENT temp = que . pop ( 0 ) NEW_LINE eachLvl . append ( temp . val ) NEW_LINE if temp . left : NEW_LINE INDENT que . append ( temp . left ) NEW_LINE DEDENT if temp . right : NEW_LINE INDENT que . append ( temp . right ) NEW_LINE DEDENT length -= 1 NEW_LINE DEDENT ans += convertBinaryToDecimal ( eachLvl ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def countSubstrings ( s ) : NEW_LINE INDENT ans = 0 NEW_LINE subs = 1 NEW_LINE pre = '' NEW_LINE for i in s : NEW_LINE INDENT if pre == i : NEW_LINE INDENT subs += 1 NEW_LINE DEDENT else : NEW_LINE INDENT subs = 1 NEW_LINE DEDENT ans += subs NEW_LINE pre = i NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def longestSequence ( arr , N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT arr . sort ( ) NEW_LINE maxLen = 1 NEW_LINE len = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] or arr [ i ] == arr [ i - 1 ] + 1 ) : NEW_LINE INDENT len += 1 NEW_LINE maxLen = max ( maxLen , len ) NEW_LINE DEDENT else : NEW_LINE INDENT len = 1 NEW_LINE DEDENT DEDENT print ( maxLen ) NEW_LINE DEDENT
def minimumOperations ( arr , N ) : NEW_LINE INDENT oddCnt = 0 NEW_LINE evenCnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT evenCnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT oddCnt += 1 NEW_LINE DEDENT DEDENT print ( min ( oddCnt , evenCnt ) ) NEW_LINE DEDENT
def productOfDigits ( N ) : NEW_LINE INDENT product = 1 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT product = product * ( N % 10 ) NEW_LINE N = N // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT
def hasArrayTwoPairs ( nums , n , target ) : NEW_LINE INDENT nums = sorted ( nums ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = target - nums [ i ] NEW_LINE low , high = 0 , n - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( ( high - low ) // 2 ) NEW_LINE if ( nums [ mid ] > x ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT elif ( nums [ mid ] < x ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( mid == i ) : NEW_LINE INDENT if ( ( mid - 1 >= 0 ) and nums [ mid - 1 ] == x ) : NEW_LINE INDENT print ( nums [ i ] , end = ", " ) NEW_LINE print ( nums [ mid - 1 ] ) NEW_LINE return NEW_LINE DEDENT if ( ( mid + 1 < n ) and nums [ mid + 1 ] == x ) : NEW_LINE INDENT print ( nums [ i ] , end = ", " ) NEW_LINE print ( nums [ mid + 1 ] ) NEW_LINE return NEW_LINE DEDENT break NEW_LINE DEDENT else : NEW_LINE INDENT print ( nums [ i ] , end = ", " ) NEW_LINE print ( nums [ mid ] ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def minSum ( arr , N , Q , M ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT val = Q [ i ] NEW_LINE front , rear = 0 , 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT front += arr [ j ] NEW_LINE if ( arr [ j ] == val ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT rear += arr [ j ] NEW_LINE if ( arr [ j ] == val ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( min ( front , rear ) , end = " " ) NEW_LINE DEDENT DEDENT
def minOperations ( arr , N , Q , M ) : NEW_LINE INDENT m1 = { } NEW_LINE m2 = { } NEW_LINE front = 0 NEW_LINE rear = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT front += arr [ i ] NEW_LINE m1 [ arr [ i ] ] = front NEW_LINE DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT rear += arr [ i ] NEW_LINE m2 [ arr [ i ] ] = rear NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT print ( min ( m1 [ Q [ i ] ] , m2 [ Q [ i ] ] ) , end = " " ) NEW_LINE DEDENT DEDENT
def checkAnagram ( s1 , s2 ) : NEW_LINE INDENT s2hash = [ 0 for i in range ( 26 ) ] NEW_LINE s1hash = [ 0 for i in range ( 26 ) ] NEW_LINE s1len = len ( s1 ) NEW_LINE s2len = len ( s2 ) NEW_LINE if ( s1len > s2len ) : NEW_LINE INDENT return False NEW_LINE DEDENT left = 0 NEW_LINE right = 0 NEW_LINE while ( right < s1len ) : NEW_LINE INDENT s1hash [ ord ( s1 [ right ] ) - 97 ] += 1 NEW_LINE s2hash [ ord ( s2 [ right ] ) - 97 ] += 1 NEW_LINE right += 1 NEW_LINE DEDENT right -= 1 NEW_LINE while ( right < s2len ) : NEW_LINE INDENT if ( s1hash == s2hash ) : NEW_LINE INDENT return True NEW_LINE DEDENT right += 1 NEW_LINE if ( right != s2len ) : NEW_LINE INDENT s2hash [ ord ( s2 [ right ] ) - 97 ] += 1 NEW_LINE DEDENT s2hash [ ord ( s2 [ left ] ) - 97 ] -= 1 NEW_LINE left += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def findSubstring ( S ) : NEW_LINE INDENT T = "" NEW_LINE ans = "" NEW_LINE l = 0 NEW_LINE T += S [ 0 ] NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT if ( abs ( ord ( S [ i ] ) - ord ( S [ i - 1 ] ) ) == 1 ) : NEW_LINE INDENT l = len ( T ) NEW_LINE if ( l > len ( ans ) ) : NEW_LINE INDENT ans = T NEW_LINE DEDENT T = "" NEW_LINE T += S [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT T += S [ i ] NEW_LINE DEDENT DEDENT l = len ( T ) NEW_LINE if ( l > len ( ans ) ) : NEW_LINE INDENT ans = T NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def DFS ( row , col , grid , M , N ) : NEW_LINE INDENT global vis NEW_LINE DFSUtil ( 0 , 0 , grid , M , N ) NEW_LINE DEDENT
def DFS_iterative ( grid , M , N ) : NEW_LINE INDENT global vis NEW_LINE vis = [ ] NEW_LINE for i in range ( M + 5 ) : NEW_LINE INDENT vis . append ( [ ] ) NEW_LINE for j in range ( N + 5 ) : NEW_LINE INDENT vis [ i ] . append ( False ) NEW_LINE DEDENT DEDENT st = [ ] NEW_LINE st . append ( [ 0 , 0 ] ) NEW_LINE vis [ 0 ] [ 0 ] = True NEW_LINE while ( len ( st ) > 0 ) : NEW_LINE INDENT p = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE row = p [ 0 ] NEW_LINE col = p [ 1 ] NEW_LINE print ( grid [ row ] [ col ] , "" , end = "" ) NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT x = row + dRow [ i ] NEW_LINE y = col + dCol [ i ] NEW_LINE if ( isValid ( x , y , M , N ) ) : NEW_LINE INDENT st . append ( [ x , y ] ) NEW_LINE vis [ x ] [ y ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT
def suffixArr ( arr , suffix , N ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i == N - 1 ) : NEW_LINE INDENT suffix [ i ] [ 0 ] = arr [ i ] NEW_LINE suffix [ i ] [ 1 ] = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i ] [ 0 ] = max ( suffix [ i + 1 ] [ 0 ] , arr [ i ] ) NEW_LINE suffix [ i ] [ 1 ] = min ( suffix [ i + 1 ] [ 1 ] , arr [ i ] ) NEW_LINE DEDENT DEDENT return suffix NEW_LINE DEDENT
def MinMaxQueries ( a , queries ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE q = len ( queries ) NEW_LINE prefix = [ [ 0 for i in range ( 2 ) ] for i in range ( N ) ] NEW_LINE suffix = [ [ 0 for i in range ( 2 ) ] for i in range ( N ) ] NEW_LINE prefix = prefixArr ( arr , prefix , N ) NEW_LINE suffix = suffixArr ( arr , suffix , N ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT L = queries [ i ] [ 0 ] NEW_LINE R = queries [ i ] [ 1 ] NEW_LINE maxAndmin ( prefix , suffix , N , L , R ) NEW_LINE DEDENT DEDENT
def check ( a , n ) : NEW_LINE INDENT flag = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( a [ i + 1 ] > a [ i ] and a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT if ( flag != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def smallestNumber ( arr , lenn ) : NEW_LINE INDENT maxi = 0 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT maxi = max ( maxi , arr [ i ] ) NEW_LINE DEDENT ans = - 1 NEW_LINE for i in range ( 2 , maxi + 2 ) : NEW_LINE INDENT flag = True NEW_LINE for j in range ( lenn ) : NEW_LINE INDENT if ( arr [ j ] % i == 0 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def findDuplicate ( str1 , N ) : NEW_LINE INDENT first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( first & ( 1 << ( ord ( str1 [ i ] ) - 97 ) ) ) : NEW_LINE INDENT second = second | ( 1 << ( ord ( str1 [ i ] ) - 97 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT first = first | ( 1 << ( ord ( str1 [ i ] ) - 97 ) ) NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( ( first & ( 1 << i ) ) and ( second & ( 1 << i ) ) ) : NEW_LINE INDENT print ( chr ( i + 97 ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def minOperations ( S ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT if ( S [ i ] != S [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def check ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( ( N & ( N - 1 ) ) == 0 ) NEW_LINE DEDENT
def build_seg_tree ( ss , se , si , tree , arr ) : NEW_LINE INDENT if ( ss == se ) : NEW_LINE INDENT tree [ si ] = check ( arr [ ss ] ) NEW_LINE return NEW_LINE DEDENT mid = ( ss + se ) // 2 NEW_LINE build_seg_tree ( ss , mid , 2 * si + 1 , tree , arr ) NEW_LINE build_seg_tree ( mid + 1 , se , 2 * si + 2 , tree , arr ) NEW_LINE tree [ si ] = tree [ 2 * si + 1 ] + tree [ 2 * si + 2 ] NEW_LINE DEDENT
def query ( l , r , ss , se , si , tree ) : NEW_LINE INDENT if ( r < ss or l > se ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l <= ss and r >= se ) : NEW_LINE INDENT return tree [ si ] NEW_LINE DEDENT mid = ( ss + se ) // 2 NEW_LINE return ( query ( l , r , ss , mid , 2 * si + 1 , tree ) + query ( l , r , mid + 1 , se , 2 * si + 2 , tree ) ) NEW_LINE DEDENT
def numberOfPairs ( arr , N ) : NEW_LINE INDENT set_bits = [ 0 ] * 31 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE bitpos = - 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT bitpos += 1 NEW_LINE x //= 2 NEW_LINE DEDENT for j in range ( bitpos + 1 ) : NEW_LINE INDENT count += set_bits [ j ] NEW_LINE DEDENT set_bits [ bitpos ] += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def calculateQuery ( arr , N , query , M ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT X = query [ i ] NEW_LINE sum_start = 0 NEW_LINE sum_end = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT sum_start += arr [ j ] NEW_LINE if ( arr [ j ] == X ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum_end += arr [ j ] NEW_LINE if ( arr [ j ] == X ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( min ( sum_end , sum_start ) , end = " " ) NEW_LINE DEDENT DEDENT
def calculateQuery ( arr , N , query , M ) : NEW_LINE INDENT prefix = 0 NEW_LINE suffix = 0 NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT prefix += arr [ i ] NEW_LINE mp [ arr [ i ] ] = [ prefix , 0 ] NEW_LINE DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT suffix += arr [ i ] NEW_LINE mp [ arr [ i ] ] = [ mp [ arr [ i ] ] [ 0 ] , suffix ] NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT X = query [ i ] NEW_LINE print ( min ( mp [ X ] [ 0 ] , mp [ X ] [ 1 ] ) , end = " " ) NEW_LINE DEDENT DEDENT
def minOps ( s , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ( ans % 2 == 1 ) : NEW_LINE INDENT print ( ( ans - 1 ) // 2 ) NEW_LINE return NEW_LINE DEDENT print ( ans // 2 ) NEW_LINE DEDENT
def oddOneOut ( arr , N ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE lastOdd = 0 NEW_LINE lastEven = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE lastEven = i NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE lastOdd = i NEW_LINE DEDENT DEDENT if ( odd == 1 ) : NEW_LINE INDENT print ( lastOdd ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( lastEven ) NEW_LINE DEDENT DEDENT
def mulsum ( arr , n , N ) : NEW_LINE INDENT sums = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] % N == 0 : NEW_LINE INDENT sums = sums + arr [ i ] NEW_LINE DEDENT DEDENT print ( sums ) NEW_LINE DEDENT
def isGreaterEqual ( N , X ) : NEW_LINE INDENT return ( N * ( N + 1 ) // 2 ) >= X NEW_LINE DEDENT
def minimumPossible ( X ) : NEW_LINE INDENT for i in range ( 1 , X + 1 ) : NEW_LINE INDENT if ( isGreaterEqual ( i , X ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT
def isGreaterEqual ( N , X ) : NEW_LINE INDENT return ( N * ( N + 1 ) // 2 ) >= X NEW_LINE DEDENT
def minimumPossible ( X ) : NEW_LINE INDENT low = 1 NEW_LINE high = X NEW_LINE res = - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( isGreaterEqual ( mid , X ) ) : NEW_LINE INDENT res = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def CheckDivByAllDigits ( number ) : NEW_LINE INDENT n = number NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 ) : NEW_LINE INDENT if ( number % ( n % 10 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n //= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
def cntNumInRang ( arr , N ) : NEW_LINE INDENT global Max NEW_LINE prefCntDiv = [ 0 ] * Max NEW_LINE for i in range ( 1 , Max ) : NEW_LINE INDENT prefCntDiv [ i ] = prefCntDiv [ i - 1 ] + ( CheckDivByAllDigits ( i ) ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( prefCntDiv [ arr [ i ] [ 1 ] ] - prefCntDiv [ arr [ i ] [ 0 ] - 1 ] , end = " " ) NEW_LINE DEDENT DEDENT
def arrayNesting ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] == i : NEW_LINE INDENT res = max ( res , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE curr_index = i NEW_LINE while arr [ curr_index ] != curr_index : NEW_LINE INDENT next_index = arr [ curr_index ] NEW_LINE arr [ curr_index ] = curr_index NEW_LINE curr_index = next_index NEW_LINE count += 1 NEW_LINE DEDENT DEDENT res = max ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def count ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT pre = [ 0 ] * ( n - 1 ) NEW_LINE suf = [ 0 ] * ( n - 1 ) NEW_LINE max = a [ 0 ] NEW_LINE ans = 0 NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] > max ) : NEW_LINE INDENT max = a [ i ] NEW_LINE DEDENT pre [ i ] = max NEW_LINE DEDENT max = a [ n - 1 ] NEW_LINE suf [ n - 2 ] = a [ n - 1 ] NEW_LINE for i in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > max ) : NEW_LINE INDENT max = a [ i ] NEW_LINE DEDENT suf [ i - 1 ] = max NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( pre [ i ] < suf [ i ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def countNumbers ( L , R ) : NEW_LINE INDENT Count = 0 NEW_LINE for p in prime : NEW_LINE INDENT if ( p >= L and p <= R ) : NEW_LINE INDENT Count += 1 NEW_LINE DEDENT DEDENT print ( Count ) NEW_LINE DEDENT
def xorSubsequence ( a , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE map = { } NEW_LINE dp = [ 0 ] * n NEW_LINE map [ a [ 0 ] ] = 1 NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] ^ k in map ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , map [ a [ i ] ^ k ] + 1 ) NEW_LINE DEDENT ans = max ( ans , dp [ i ] ) NEW_LINE if a [ i ] in map : NEW_LINE INDENT map [ a [ i ] ] = max ( map [ a [ i ] ] , dp [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT map [ a [ i ] ] = max ( 1 , dp [ i ] ) NEW_LINE DEDENT DEDENT if ans >= 2 : NEW_LINE INDENT return ans NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def distance ( root , target , distancesum , n ) : NEW_LINE INDENT global sum NEW_LINE if ( root . data == target ) : NEW_LINE INDENT sum = distancesum NEW_LINE DEDENT if ( root . left ) : NEW_LINE INDENT tempsum = ( distancesum - root . left . size + ( n - root . left . size ) ) NEW_LINE distance ( root . left , target , tempsum , n ) NEW_LINE DEDENT if ( root . right ) : NEW_LINE INDENT tempsum = ( distancesum - root . right . size + ( n - root . right . size ) ) NEW_LINE distance ( root . right , target , tempsum , n ) NEW_LINE DEDENT DEDENT
def countRemainingElements ( L1 , L2 , n ) : NEW_LINE INDENT one = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( L1 [ i ] == 1 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT DEDENT ans = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( L2 [ i ] == 1 ) : NEW_LINE INDENT one -= 1 NEW_LINE if ( one < 0 ) : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT zero -= 1 NEW_LINE if ( zero < 0 ) : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( n - ans ) NEW_LINE DEDENT
def minTime ( arr , N , K ) : NEW_LINE INDENT q = [ ] NEW_LINE vis = [ False ] * ( N + 1 ) NEW_LINE time = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT q . append ( arr [ i ] ) NEW_LINE vis [ arr [ i ] ] = True NEW_LINE DEDENT while ( len ( q ) > 0 ) : NEW_LINE INDENT for i in range ( len ( q ) ) : NEW_LINE INDENT curr = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( curr - 1 >= 1 and vis [ curr - 1 ] == 0 ) : NEW_LINE INDENT vis [ curr - 1 ] = True NEW_LINE q . append ( curr - 1 ) NEW_LINE DEDENT if ( curr + 1 <= N and vis [ curr + 1 ] == 0 ) : NEW_LINE INDENT vis [ curr + 1 ] = True NEW_LINE q . append ( curr + 1 ) NEW_LINE DEDENT DEDENT time += 1 NEW_LINE DEDENT print ( time - 1 ) NEW_LINE DEDENT
def getCount ( rows , columns , A ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( rows ) : NEW_LINE INDENT for j in range ( i + 1 , rows , 1 ) : NEW_LINE INDENT if ( A [ i ] [ 0 ] * A [ j ] [ 1 ] == A [ i ] [ 1 ] * A [ j ] [ 0 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def Min_Score_Index ( N , A ) : NEW_LINE INDENT Score = [ 0 ] * N NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if A [ i ] + i < N : NEW_LINE INDENT Score [ i ] = A [ i ] * Score [ A [ i ] + i ] NEW_LINE DEDENT else : NEW_LINE INDENT Score [ i ] = A [ i ] NEW_LINE DEDENT DEDENT min_value = min ( Score ) NEW_LINE ind = Score . index ( min_value ) NEW_LINE print ( ind ) NEW_LINE DEDENT
def minLength ( S , T , N , M ) : NEW_LINE INDENT temp = "" NEW_LINE subtract = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp += S [ i ] NEW_LINE if ( len ( temp ) >= M ) : NEW_LINE INDENT if ( T == ( temp [ len ( temp ) - M : len ( temp ) ] ) ) : NEW_LINE INDENT subtract += M NEW_LINE cnt = 0 NEW_LINE while ( cnt != M ) : NEW_LINE INDENT temp = temp [ 0 : len ( temp ) - 1 ] NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ( N - subtract ) ) NEW_LINE DEDENT
def maximumCount ( arr1 , arr2 , s1 , s2 ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( s1 ) : NEW_LINE INDENT sum1 += arr1 [ i ] NEW_LINE DEDENT for j in range ( s2 ) : NEW_LINE INDENT sum2 += arr2 [ j ] NEW_LINE DEDENT len = 0 NEW_LINE if ( s1 >= s2 ) : NEW_LINE INDENT lenn = s2 NEW_LINE DEDENT else : NEW_LINE INDENT lenn = s1 NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE j = 0 NEW_LINE k = s2 - 1 NEW_LINE count = 0 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( sum1 <= sum2 ) : NEW_LINE INDENT if ( arr2 [ k ] >= arr1 [ i ] ) : NEW_LINE INDENT dif1 = arr1 [ j ] NEW_LINE dif2 = arr2 [ k ] NEW_LINE sum1 -= dif1 NEW_LINE sum1 += dif2 NEW_LINE sum2 -= dif2 NEW_LINE sum2 += dif1 NEW_LINE j += 1 NEW_LINE k -= 1 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def noOfValidKbers ( K , arr ) : NEW_LINE INDENT st = { } NEW_LINE while ( K != 0 ) : NEW_LINE INDENT if ( K % 10 in st ) : NEW_LINE INDENT st [ K % 10 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT st [ K % 10 ] = st . get ( K % 10 , 0 ) + 1 NEW_LINE DEDENT K = K // 10 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT no = arr [ i ] NEW_LINE flag = True NEW_LINE while ( no != 0 ) : NEW_LINE INDENT digit = no % 10 NEW_LINE if ( digit not in st ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT no = no // 10 NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def build ( arr , index , s , e ) : NEW_LINE INDENT global Tree NEW_LINE global max NEW_LINE if ( s == e ) : NEW_LINE INDENT Tree [ index ] = arr [ s ] NEW_LINE DEDENT else : NEW_LINE INDENT m = ( s + e ) // 2 NEW_LINE build ( arr , 2 * index , s , m ) NEW_LINE build ( arr , 2 * index + 1 , m + 1 , e ) NEW_LINE Tree [ index ] = max ( Tree [ 2 * index ] , Tree [ 2 * index + 1 ] ) NEW_LINE DEDENT DEDENT
def isSubarrayExistUtil ( arr , K , N ) : NEW_LINE INDENT totalXOR = 0 NEW_LINE SubarrayXOR = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT totalXOR ^= arr [ i ] NEW_LINE DEDENT for i in range ( K ) : NEW_LINE INDENT SubarrayXOR ^= arr [ i ] NEW_LINE DEDENT if ( SubarrayXOR == ( totalXOR ^ SubarrayXOR ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( K , N ) : NEW_LINE INDENT SubarrayXOR ^= arr [ i ] NEW_LINE SubarrayXOR ^= arr [ i - 1 ] NEW_LINE if ( SubarrayXOR == ( totalXOR ^ SubarrayXOR ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def countPairs ( L , R ) : NEW_LINE INDENT count_even = 0 NEW_LINE if ( L % 2 == 0 ) : NEW_LINE INDENT count_even = ( ( R // 2 ) - ( L // 2 ) + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count_even = ( ( R // 2 ) - ( L // 2 ) ) NEW_LINE DEDENT count_odd = 0 NEW_LINE if ( L % 2 == 0 ) : NEW_LINE INDENT count_odd = ( ( ( R + 1 ) // 2 ) - ( ( L + 1 ) // 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT count_odd = ( ( ( R + 1 ) // 2 ) - ( ( L + 1 ) // 2 ) + 1 ) NEW_LINE DEDENT count_even *= count_even NEW_LINE count_odd *= count_odd NEW_LINE print ( count_even + count_odd ) NEW_LINE DEDENT
def delCost ( s , cost ) : NEW_LINE INDENT ans = 0 NEW_LINE forMax = { } NEW_LINE forTot = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] not in forMax : NEW_LINE INDENT forMax [ s [ i ] ] = cost [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT forMax [ s [ i ] ] = max ( cost [ i ] , forMax [ s [ i ] ] ) NEW_LINE DEDENT if s [ i ] not in forTot : NEW_LINE INDENT forTot [ s [ i ] ] = cost [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT forTot [ s [ i ] ] += cost [ i ] NEW_LINE DEDENT DEDENT for i in forMax : NEW_LINE INDENT ans += forTot [ i ] - forMax [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findPeak ( arr ) : NEW_LINE INDENT left = 0 NEW_LINE right = len ( arr ) - 1 NEW_LINE while ( left < right ) : NEW_LINE INDENT mid = left + ( right - left ) // 2 NEW_LINE if ( arr [ mid ] < arr [ ( mid + 1 ) ] ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right = mid NEW_LINE DEDENT DEDENT return left NEW_LINE DEDENT
def BS ( X , left , right , arr ) : NEW_LINE INDENT while ( left <= right ) : NEW_LINE INDENT mid = left + ( right - left ) // 2 NEW_LINE if ( arr [ mid ] == X ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( X > arr [ mid ] ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def reverseBS ( X , left , right , arr ) : NEW_LINE INDENT while ( left <= right ) : NEW_LINE INDENT mid = left + ( right - left ) // 2 NEW_LINE if ( arr [ mid ] == X ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( X > arr [ mid ] ) : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def getDefiniteFinds ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE smallestRight = [ 0 ] * ( n + 1 ) NEW_LINE smallestRight [ n ] = sys . maxsize NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT smallestRight [ i ] = min ( smallestRight [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT mn = - sys . maxsize - 1 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mn < arr [ i ] and arr [ i ] < smallestRight [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT mn = max ( arr [ i ] , mn ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def Count_numbers ( L , R ) : NEW_LINE INDENT count = ( R - L ) // 2 NEW_LINE if ( R % 2 != 0 or L % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def findIndex ( arr , N ) : NEW_LINE INDENT rightSum = 0 NEW_LINE leftSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT rightSum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT rightSum -= arr [ i ] NEW_LINE if ( checkReverse ( leftSum , rightSum ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT leftSum += arr [ i ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def minimumTime ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE T = max ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( max ( 2 * T , sum ) ) NEW_LINE DEDENT
def findClosest ( N , target ) : NEW_LINE INDENT closest = - 1 NEW_LINE diff = 10 ** 18 NEW_LINE for i in range ( 1 , ceil ( sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( N // i == i ) : NEW_LINE INDENT if ( abs ( target - i ) < diff ) : NEW_LINE INDENT diff = abs ( target - i ) NEW_LINE closest = i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( abs ( target - i ) < diff ) : NEW_LINE INDENT diff = abs ( target - i ) NEW_LINE closest = i NEW_LINE DEDENT if ( abs ( target - N // i ) < diff ) : NEW_LINE INDENT diff = abs ( target - N // i ) NEW_LINE closest = N // i NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( closest ) NEW_LINE DEDENT
def computeDivisors ( ) : NEW_LINE INDENT global divisors NEW_LINE global MAX NEW_LINE for i in range ( 1 , MAX + 1 , 1 ) : NEW_LINE INDENT for j in range ( i , MAX + 1 , i ) : NEW_LINE INDENT divisors [ j ] . append ( i ) NEW_LINE DEDENT DEDENT DEDENT
def getClosest ( val1 , val2 , target ) : NEW_LINE INDENT if ( target - val1 >= val2 - target ) : NEW_LINE INDENT return val2 NEW_LINE DEDENT else : NEW_LINE INDENT return val1 NEW_LINE DEDENT DEDENT
def findClosest ( arr , n , target ) : NEW_LINE INDENT if ( target <= arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if ( target >= arr [ n - 1 ] ) : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT i = 0 NEW_LINE j = n NEW_LINE mid = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT mid = ( i + j ) // 2 NEW_LINE if ( arr [ mid ] == target ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if ( target < arr [ mid ] ) : NEW_LINE INDENT if ( mid > 0 and target > arr [ mid - 1 ] ) : NEW_LINE INDENT return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) NEW_LINE DEDENT j = mid NEW_LINE DEDENT else : NEW_LINE INDENT if ( mid < n - 1 and target < arr [ mid + 1 ] ) : NEW_LINE INDENT return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) NEW_LINE DEDENT i = mid + 1 NEW_LINE DEDENT DEDENT return arr [ mid ] NEW_LINE DEDENT
def printClosest ( N , X ) : NEW_LINE INDENT global divisors NEW_LINE computeDivisors ( ) NEW_LINE ans = findClosest ( divisors [ N ] , len ( divisors [ N ] ) , X ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def LCS ( firstArr , secondArr ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( len ( firstArr ) ) : NEW_LINE INDENT mp [ firstArr [ i ] ] = i + 1 NEW_LINE DEDENT tempArr = [ ] NEW_LINE for i in range ( len ( secondArr ) ) : NEW_LINE INDENT if ( secondArr [ i ] in mp ) : NEW_LINE INDENT tempArr . append ( mp [ secondArr [ i ] ] ) NEW_LINE DEDENT DEDENT tail = [ ] NEW_LINE tail . append ( tempArr [ 0 ] ) NEW_LINE for i in range ( 1 , len ( tempArr ) ) : NEW_LINE INDENT if ( tempArr [ i ] > tail [ - 1 ] ) : NEW_LINE INDENT tail . append ( tempArr [ i ] ) NEW_LINE DEDENT elif ( tempArr [ i ] < tail [ 0 ] ) : NEW_LINE INDENT tail [ 0 ] = tempArr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT it = bisect_left ( tail , tempArr [ i ] ) NEW_LINE it = tempArr [ i ] NEW_LINE DEDENT DEDENT return len ( tail ) NEW_LINE DEDENT
def maxSubarrayProduct ( arr , n ) : NEW_LINE INDENT max_ending_here = 1 NEW_LINE min_ending_here = 1 NEW_LINE max_so_far = 0 NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT max_ending_here = max_ending_here * arr [ i ] NEW_LINE min_ending_here = min ( min_ending_here * arr [ i ] , 1 ) NEW_LINE flag = 1 NEW_LINE DEDENT elif ( arr [ i ] == 0 ) : NEW_LINE INDENT max_ending_here = 1 NEW_LINE min_ending_here = 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp = max_ending_here NEW_LINE max_ending_here = max ( min_ending_here * arr [ i ] , 1 ) NEW_LINE min_ending_here = temp * arr [ i ] NEW_LINE DEDENT if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT DEDENT if ( flag == 0 and max_so_far == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT
def findMaxProduct ( a , n ) : NEW_LINE INDENT i = 0 NEW_LINE maxProd = - 10 ** 9 NEW_LINE while ( i < n ) : NEW_LINE INDENT v = [ ] NEW_LINE v . append ( a [ i ] ) NEW_LINE if i < n - 1 and a [ i ] < a [ i + 1 ] : NEW_LINE INDENT while ( i < n - 1 and a [ i ] < a [ i + 1 ] ) : NEW_LINE INDENT v . append ( a [ i + 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif ( i < n - 1 and a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT while ( i < n - 1 and a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT v . append ( a [ i + 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT prod = maxSubarrayProduct ( v , len ( v ) ) NEW_LINE maxProd = max ( maxProd , prod ) NEW_LINE i += 1 NEW_LINE DEDENT return maxProd NEW_LINE DEDENT
def PrimeFactors ( N ) : NEW_LINE INDENT st = [ ] NEW_LINE i = 2 NEW_LINE while ( N != 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT st . append ( i ) NEW_LINE while ( N % i == 0 ) : NEW_LINE INDENT N = N // i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT while ( len ( st ) != 0 ) : NEW_LINE INDENT print ( st [ - 1 ] ) NEW_LINE st . pop ( ) NEW_LINE DEDENT DEDENT
def power ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE if ( A == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( N > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE N //= A NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT
def LCM ( A , B ) : NEW_LINE INDENT return ( A * B // math . gcd ( A , B ) ) NEW_LINE DEDENT
def findSmallestNumber ( X ) : NEW_LINE INDENT lcm = 1 NEW_LINE temp = X NEW_LINE while ( temp ) : NEW_LINE INDENT last = temp % 10 NEW_LINE temp //= 10 NEW_LINE if ( not last ) : NEW_LINE INDENT continue NEW_LINE DEDENT lcm = LCM ( lcm , last ) NEW_LINE DEDENT answer = ( ( X + lcm - 1 ) // lcm ) * lcm NEW_LINE print ( answer ) NEW_LINE DEDENT
def findNonMultiples ( arr , n , k ) : NEW_LINE INDENT multiples = set ( [ ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in multiples ) : NEW_LINE INDENT for j in range ( 1 , k // arr [ i ] + 1 ) : NEW_LINE INDENT multiples . add ( arr [ i ] * j ) NEW_LINE DEDENT DEDENT DEDENT return k - len ( multiples ) NEW_LINE DEDENT
def countValues ( arr , N , L , R ) : NEW_LINE INDENT return ( findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ) NEW_LINE DEDENT
def minSum ( N ) : NEW_LINE INDENT low = 0 NEW_LINE high = 1000000000 NEW_LINE while ( low + 1 < high ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 NEW_LINE if ( mid * mid >= N ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid NEW_LINE DEDENT DEDENT first = high NEW_LINE low = 0 NEW_LINE high = 1000000000 NEW_LINE while ( low + 1 < high ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 NEW_LINE if ( first * mid > N ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid NEW_LINE DEDENT DEDENT second = high NEW_LINE print ( round ( first + second ) ) NEW_LINE DEDENT
def minSum ( N ) : NEW_LINE INDENT ans = math . ceil ( 2 * math . sqrt ( N + 1 ) ) NEW_LINE print ( math . trunc ( ans ) ) NEW_LINE DEDENT
def root ( a ) : NEW_LINE INDENT if ( a == parent [ a ] ) : NEW_LINE INDENT return a NEW_LINE DEDENT parent [ a ] = root ( parent [ a ] ) NEW_LINE return parent [ a ] NEW_LINE DEDENT
def connect ( a , b ) : NEW_LINE INDENT a = root ( a ) NEW_LINE b = root ( b ) NEW_LINE if ( a != b ) : NEW_LINE INDENT parent [ b ] = a NEW_LINE DEDENT DEDENT
def find_ht ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return max ( find_ht ( root . left ) , find_ht ( root . right ) ) + 1 NEW_LINE DEDENT
def countFreq ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 == K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT N = N // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findElementUtil ( arr , N , K ) : NEW_LINE INDENT c = 0 NEW_LINE max = 0 NEW_LINE ele = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT c = countFreq ( arr [ i ] , K ) NEW_LINE if ( c > max ) : NEW_LINE INDENT max = c NEW_LINE ele = arr [ i ] NEW_LINE DEDENT DEDENT if ( max == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ele NEW_LINE DEDENT DEDENT
def findOverlapSegement ( N , a , b ) : NEW_LINE INDENT tup = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = a [ i ] NEW_LINE y = b [ i ] NEW_LINE tup . append ( ( ( x , y ) , i ) ) NEW_LINE DEDENT tup . sort ( ) NEW_LINE curr = tup [ 0 ] [ 0 ] [ 1 ] NEW_LINE currPos = tup [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT Q = tup [ i - 1 ] [ 0 ] [ 0 ] NEW_LINE R = tup [ i ] [ 0 ] [ 0 ] NEW_LINE if Q == R : NEW_LINE INDENT if tup [ i - 1 ] [ 0 ] [ 1 ] < tup [ i ] [ 0 ] [ 1 ] : NEW_LINE INDENT print ( tup [ i - 1 ] [ 1 ] , tup [ i ] [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( tup [ i ] [ 1 ] , tup [ i - 1 ] [ 1 ] ) NEW_LINE DEDENT return NEW_LINE DEDENT T = tup [ i ] [ 0 ] [ 1 ] NEW_LINE if ( T <= curr ) : NEW_LINE INDENT print ( tup [ i ] [ 1 ] , currPos ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT curr = T NEW_LINE currPos = tup [ i ] [ 1 ] NEW_LINE DEDENT DEDENT print ( "-1" , "-1" , end = "" ) NEW_LINE DEDENT
def isSpiralSorted ( arr , n ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE while ( start < end ) : NEW_LINE INDENT if ( arr [ start ] > arr [ end ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT start += 1 NEW_LINE if ( arr [ end ] > arr [ start ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT end -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def findMinDeletions ( v , n ) : NEW_LINE INDENT minDel = 10 ** 18 NEW_LINE for i in range ( n ) : NEW_LINE INDENT L = v [ i ] [ 0 ] NEW_LINE R = v [ i ] [ 1 ] NEW_LINE Count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( v [ j ] [ 1 ] >= L and v [ j ] [ 0 ] <= R ) : NEW_LINE INDENT Count += 1 NEW_LINE DEDENT DEDENT minDel = min ( minDel , n - Count ) NEW_LINE DEDENT return minDel NEW_LINE DEDENT
def maxEvenIntegers ( arr , N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - K + 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( 0 , K ) : NEW_LINE INDENT if arr [ i + j ] % 2 == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ans = max ( cnt , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def MaxNonEmpSubSeq ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxm = max ( a ) NEW_LINE if ( maxm <= 0 ) : NEW_LINE INDENT return maxm NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > 0 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def findMaxLengthSequence ( N , arr ) : NEW_LINE INDENT rightmost_element = - 1 NEW_LINE i = 0 NEW_LINE j = N - 1 NEW_LINE sequence = [ ] NEW_LINE while ( i <= j ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT if ( arr [ j ] > rightmost_element ) : NEW_LINE INDENT sequence . append ( arr [ j ] ) NEW_LINE rightmost_element = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT elif ( arr [ i ] > rightmost_element ) : NEW_LINE INDENT sequence . append ( arr [ i ] ) NEW_LINE rightmost_element = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT elif ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT if ( arr [ i ] > rightmost_element ) : NEW_LINE INDENT sequence . append ( arr [ i ] ) NEW_LINE rightmost_element = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT elif ( arr [ j ] > rightmost_element ) : NEW_LINE INDENT sequence . append ( arr [ j ] ) NEW_LINE rightmost_element = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT elif ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT if ( arr [ i ] > rightmost_element ) : NEW_LINE INDENT sequence . append ( arr [ i ] ) NEW_LINE rightmost_element = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT break NEW_LINE DEDENT else : NEW_LINE INDENT sequence . append ( arr [ i ] ) NEW_LINE k = i + 1 NEW_LINE max_left = [ ] NEW_LINE while ( k < j and arr [ k ] > arr [ k - 1 ] ) : NEW_LINE INDENT max_left . append ( arr [ k ] ) NEW_LINE k += 1 NEW_LINE DEDENT l = j - 1 NEW_LINE max_right = [ ] NEW_LINE while ( l > i and arr [ l ] > arr [ l + 1 ] ) : NEW_LINE INDENT max_right . append ( arr [ l ] ) NEW_LINE l -= 1 NEW_LINE DEDENT if ( len ( max_left ) > len ( max_right ) ) : NEW_LINE INDENT for element in max_left : NEW_LINE INDENT sequence . append ( element ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for element in max_right : NEW_LINE INDENT sequence . append ( element ) NEW_LINE DEDENT DEDENT break NEW_LINE DEDENT DEDENT DEDENT for element in sequence : NEW_LINE INDENT print ( element , end = " " ) NEW_LINE DEDENT DEDENT
def getcount ( n , k ) : NEW_LINE INDENT res = ( n >> ( k + 1 ) ) << k NEW_LINE if ( ( n >> k ) & 1 ) : NEW_LINE INDENT res += n & ( ( 1 << k ) - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countDivisors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE divisor = [ ] NEW_LINE for i in range ( 2 , floor ( sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT divisor . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT divisor . append ( i ) NEW_LINE divisor . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT divisor . append ( n ) NEW_LINE for x in divisor : NEW_LINE INDENT x -= 1 NEW_LINE if ( ( n // x ) == ( n % x ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def smallestIndexArrayElementsFlip ( arr , N ) : NEW_LINE INDENT pos = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE sum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT pos = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT
def smallestIndexArrayElementsFlip ( arr , N ) : NEW_LINE INDENT pos = - 1 NEW_LINE ArrSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ArrSum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( 2 * arr [ i ] == ArrSum ) : NEW_LINE INDENT pos = i NEW_LINE break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT
def MaxAverage ( root ) : NEW_LINE INDENT global ans NEW_LINE if ( root != None and len ( root . children ) == 0 ) : NEW_LINE INDENT ans = max ( ans , ( root . val ) ) NEW_LINE return [ root . val , 1 ] NEW_LINE DEDENT childResult = [ 0 for i in range ( 2 ) ] NEW_LINE for child in root . children : NEW_LINE INDENT childTotal = MaxAverage ( child ) NEW_LINE childResult [ 0 ] = childResult [ 0 ] + childTotal [ 0 ] NEW_LINE childResult [ 1 ] = childResult [ 1 ] + childTotal [ 1 ] NEW_LINE DEDENT sum = childResult [ 0 ] + root . val NEW_LINE count = childResult [ 1 ] + 1 NEW_LINE ans = max ( ans , sum / count ) NEW_LINE return [ sum , count ] NEW_LINE DEDENT
def make_array_element_even ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE odd_cont_seg = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd_cont_seg += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( odd_cont_seg > 0 ) : NEW_LINE INDENT if ( odd_cont_seg % 2 == 0 ) : NEW_LINE INDENT res += odd_cont_seg // 2 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( odd_cont_seg // 2 ) + 2 NEW_LINE DEDENT odd_cont_seg = 0 NEW_LINE DEDENT DEDENT DEDENT if ( odd_cont_seg > 0 ) : NEW_LINE INDENT if ( odd_cont_seg % 2 == 0 ) : NEW_LINE INDENT res += odd_cont_seg // 2 NEW_LINE DEDENT else : NEW_LINE INDENT res += odd_cont_seg // 2 + 2 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findSum ( a ) : NEW_LINE INDENT ans = 0 NEW_LINE for low in range ( 0 , len ( a ) ) : NEW_LINE INDENT for high in range ( low , len ( a ) ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT maxNumber = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( a [ i ] == maxNumber ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif ( a [ i ] > maxNumber ) : NEW_LINE INDENT maxNumber = a [ i ] NEW_LINE DEDENT count = 1 NEW_LINE if count % 2 : NEW_LINE INDENT ans += maxNumber NEW_LINE DEDENT else : NEW_LINE INDENT ans += maxNumber * 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT mp1 = { } NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE mp1 [ sum ] = mp1 . get ( sum , 0 ) + 1 NEW_LINE DEDENT sum = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( sum in mp1 ) : NEW_LINE INDENT ans += mp1 [ sum ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def minCollectingSpeed ( piles , H ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = 1 NEW_LINE high = max ( piles ) NEW_LINE while ( low <= high ) : NEW_LINE INDENT K = low + ( high - low ) // 2 NEW_LINE time = 0 NEW_LINE for ai in piles : NEW_LINE INDENT time += ( ai + K - 1 ) // K NEW_LINE DEDENT if ( time <= H ) : NEW_LINE INDENT ans = K NEW_LINE high = K - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = K + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def isMagic ( num ) : NEW_LINE INDENT return ( num % 9 == 1 ) NEW_LINE DEDENT
def findSmallestInteger ( arr , N , K ) : NEW_LINE INDENT left = 1 NEW_LINE right = max ( arr ) NEW_LINE while ( left < right ) : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += ( arr [ i ] + mid - 1 ) // mid NEW_LINE DEDENT if ( sum > K ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right = mid NEW_LINE DEDENT DEDENT return left NEW_LINE DEDENT
def minimum_deci_binary_number ( s ) : NEW_LINE INDENT m = - 10 ** 19 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT temp = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( temp > m ) : NEW_LINE INDENT m = temp NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT
def minimumReverse ( s , n ) : NEW_LINE INDENT k = 0 NEW_LINE l = 0 NEW_LINE sum1 = 0 NEW_LINE sum0 = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT sum1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum0 += 1 NEW_LINE DEDENT if ( s [ i ] == s [ i - 1 ] and s [ i ] == '0' ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif ( s [ i ] == s [ i - 1 ] and s [ i ] == '1' ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT if ( s [ 0 ] == '1' ) : NEW_LINE INDENT sum1 += 1 NEW_LINE sum0 += 1 NEW_LINE DEDENT if ( abs ( sum1 - sum0 ) > 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return max ( k , l ) NEW_LINE DEDENT
def canTransformStrings ( A , B ) : NEW_LINE INDENT n1 = len ( A ) NEW_LINE n2 = len ( B ) NEW_LINE count1A = 0 NEW_LINE count1B = 0 NEW_LINE odd1A = 0 NEW_LINE odd1B = 0 NEW_LINE even1A = 0 NEW_LINE even1B = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( A [ i ] == '1' ) : NEW_LINE INDENT count1A += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( count1A & 1 ) == 1 ) : NEW_LINE INDENT odd1A += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1A += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n2 ) : NEW_LINE INDENT if ( B [ i ] == '1' ) : NEW_LINE INDENT count1B += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( count1B & 1 ) == 1 ) : NEW_LINE INDENT odd1B += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1B += 1 NEW_LINE DEDENT DEDENT DEDENT if ( count1A == count1B and odd1A == odd1B and even1A == even1B ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def maxPairs ( nums , k ) : NEW_LINE INDENT m = { } NEW_LINE result = 0 NEW_LINE for i in nums : NEW_LINE INDENT if ( ( i in m ) and m [ i ] > 0 ) : NEW_LINE INDENT m [ i ] = m [ i ] - 1 NEW_LINE result += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if k - i in m : NEW_LINE INDENT m [ k - i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ k - i ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def uniqueElements ( arr , start , K , mp ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( K ) : NEW_LINE INDENT st . add ( arr [ start + i ] ) NEW_LINE DEDENT for itr in st : NEW_LINE INDENT if itr in mp : NEW_LINE INDENT mp [ itr ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ itr ] = 1 NEW_LINE DEDENT DEDENT DEDENT
def smallestPresentNumber ( arr , N , K ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N - K + 1 ) : NEW_LINE INDENT uniqueElements ( arr , i , K , mp ) NEW_LINE DEDENT checkAnswer ( mp , N , K ) NEW_LINE DEDENT
def generateK ( arr , N ) : NEW_LINE INDENT for k in range ( 1 , N + 1 ) : NEW_LINE INDENT smallestPresentNumber ( arr , N , k ) NEW_LINE DEDENT DEDENT
def printAnswer ( answer , N ) : NEW_LINE INDENT for i in range ( N + 1 ) : NEW_LINE INDENT print ( answer [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def lengthOfSubarray ( indices , st , N ) : NEW_LINE INDENT answer = [ - 1 for i in range ( N + 1 ) ] NEW_LINE for itr in st : NEW_LINE INDENT start = - 1 NEW_LINE gap = - 1 NEW_LINE indices [ itr ] . append ( N ) NEW_LINE for i in range ( len ( indices [ itr ] ) ) : NEW_LINE INDENT gap = max ( gap , indices [ itr ] [ i ] - start ) NEW_LINE start = indices [ itr ] [ i ] NEW_LINE DEDENT if ( answer [ gap ] == - 1 ) : NEW_LINE INDENT answer [ gap ] = itr NEW_LINE DEDENT DEDENT updateAnswerArray ( answer , N ) NEW_LINE printAnswer ( answer , N ) NEW_LINE DEDENT
def smallestPresentNumber ( arr , N ) : NEW_LINE INDENT indices = [ [ ] for i in range ( N + 1 ) ] NEW_LINE elements = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT indices [ arr [ i ] ] . append ( i ) NEW_LINE elements . append ( arr [ i ] ) NEW_LINE DEDENT elements = list ( set ( elements ) ) NEW_LINE lengthOfSubarray ( indices , elements , N ) NEW_LINE DEDENT
def removeIndicesToMakeSumEqual ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE odd = [ 0 ] * N NEW_LINE even = [ 0 ] * N NEW_LINE even [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT odd [ i ] = odd [ i - 1 ] NEW_LINE even [ i ] = even [ i - 1 ] NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT even [ i ] += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT odd [ i ] += arr [ i ] NEW_LINE DEDENT DEDENT find = False NEW_LINE p = odd [ N - 1 ] NEW_LINE q = even [ N - 1 ] - arr [ 0 ] NEW_LINE if ( p == q ) : NEW_LINE INDENT print ( "0 " ) NEW_LINE find = True NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] NEW_LINE q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] NEW_LINE p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] NEW_LINE DEDENT if ( p == q ) : NEW_LINE INDENT find = True NEW_LINE print ( i , end = "" ) NEW_LINE DEDENT DEDENT if ( find == False ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def cntDisPairs ( arr , N , K ) : NEW_LINE INDENT cntPairs = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE i = 0 NEW_LINE j = N - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == K ) : NEW_LINE INDENT while ( i < j and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( i < j and arr [ j ] == arr [ j - 1 ] ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT cntPairs += 1 NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] < K ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return cntPairs NEW_LINE DEDENT
def maxLength ( a , b , n , c ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT max_length = int ( 0 ) NEW_LINE low = 0 NEW_LINE high = n NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = int ( low + int ( ( high - low ) / 2 ) ) NEW_LINE if ( possible ( a , b , n , c , mid ) != 0 ) : NEW_LINE INDENT max_length = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return max_length NEW_LINE DEDENT
def possible ( a , b , n , c , k ) : NEW_LINE INDENT sum = int ( 0 ) NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT total_cost = int ( sum * k + getMax ( b , 0 , n - 1 , 0 , k - 1 , 0 ) ) NEW_LINE if ( total_cost <= c ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE sum -= a [ i - k ] NEW_LINE total_cost = int ( sum * k + getMax ( b , 0 , n - 1 , i - k + 1 , i , 0 ) ) NEW_LINE if ( total_cost <= c ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def build ( b , index , s , e ) : NEW_LINE INDENT if ( s == e ) : NEW_LINE INDENT seg [ index ] = b [ s ] NEW_LINE return NEW_LINE DEDENT mid = int ( s + int ( ( e - s ) / 2 ) ) NEW_LINE build ( b , 2 * index + 1 , s , mid ) NEW_LINE build ( b , 2 * index + 2 , mid + 1 , e ) NEW_LINE seg [ index ] = max ( seg [ 2 * index + 1 ] , seg [ 2 * index + 2 ] ) NEW_LINE DEDENT
def getMax ( b , ss , se , qs , qe , index ) : NEW_LINE INDENT if ( se < qs or ss > qe ) : NEW_LINE INDENT return int ( INT_MIN / 2 ) NEW_LINE DEDENT if ( ss >= qs and se <= qe ) : NEW_LINE INDENT return seg [ index ] NEW_LINE DEDENT mid = int ( int ( ss ) + int ( ( se - ss ) / 2 ) ) NEW_LINE return max ( getMax ( b , ss , mid , qs , qe , 2 * index + 1 ) , getMax ( b , mid + 1 , se , qs , qe , 2 * index + 2 ) ) NEW_LINE DEDENT
def maxLength ( a , b , n , c ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT max_length = 0 NEW_LINE low = 0 NEW_LINE high = n NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = int ( low + ( high - low ) / 2 ) NEW_LINE if ( possible ( a , b , n , c , mid ) ) : NEW_LINE INDENT max_length = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return max_length NEW_LINE DEDENT
def possible ( a , b , n , c , k ) : NEW_LINE INDENT dq = [ ] NEW_LINE Sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT Sum += a [ i ] NEW_LINE while ( len ( dq ) > 0 and b [ i ] > b [ dq [ len ( dq ) - 1 ] ] ) : NEW_LINE INDENT dq . pop ( len ( dq ) - 1 ) NEW_LINE DEDENT dq . append ( i ) NEW_LINE DEDENT total_cost = Sum * k + b [ dq [ 0 ] ] NEW_LINE if ( total_cost <= c ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT Sum += a [ i ] NEW_LINE Sum -= a [ i - k ] NEW_LINE while ( len ( dq ) > 0 and dq [ 0 ] <= i - k ) : NEW_LINE INDENT dq . pop ( 0 ) NEW_LINE DEDENT while ( len ( dq ) > 0 and b [ i ] > b [ dq [ len ( dq ) - 1 ] ] ) : NEW_LINE INDENT dq . pop ( len ( dq ) - 1 ) NEW_LINE DEDENT dq . append ( i ) NEW_LINE total_cost = Sum * k + b [ dq [ 0 ] ] NEW_LINE if ( total_cost <= c ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findMaxLength ( N , arr ) : NEW_LINE INDENT dp = [ 1 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 2 * i , N + 1 , i ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ j - 1 ] ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , dp [ i ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max ( dp ) NEW_LINE DEDENT
def UtilSmallestElement ( arr , N ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT total += arr [ i ] NEW_LINE DEDENT dp = [ [ - 1 for y in range ( total ) ] for x in range ( N + 1 ) ] NEW_LINE print ( smallestLeft ( arr , total , 0 , N , dp ) ) NEW_LINE DEDENT
def SmallestElementLeft ( arr , N ) : NEW_LINE INDENT totalSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT totalSum += arr [ i ] NEW_LINE DEDENT req = totalSum // 2 NEW_LINE dp = [ False for i in range ( req + 1 ) ] NEW_LINE memset ( dp , false , sizeof ( dp ) ) NEW_LINE dp [ 0 ] = True NEW_LINE reach = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT j = req NEW_LINE while j >= arr [ i ] : NEW_LINE INDENT dp [ j ] = dp [ j ] or dp [ j - arr [ i ] ] NEW_LINE if ( dp [ j ] ) : NEW_LINE INDENT reach = max ( reach , j ) NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT return totalSum - ( 2 * reach ) NEW_LINE DEDENT
def countSubArraySignChange ( arr , N ) : NEW_LINE INDENT prefixCount = { } NEW_LINE suffixCount = { } NEW_LINE total = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT total += arr [ i ] NEW_LINE suffixCount [ arr [ i ] ] = suffixCount . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT prefixSum = 0 NEW_LINE suffixSum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT prefixSum += arr [ i ] NEW_LINE prefixCount [ arr [ i ] ] = prefixCount . get ( arr [ i ] , 0 ) + 1 NEW_LINE suffixSum = total - prefixSum NEW_LINE suffixCount [ arr [ i ] ] -= 1 NEW_LINE diff = prefixSum - suffixSum NEW_LINE if ( diff % 2 == 0 ) : NEW_LINE INDENT y , z = 0 , 0 NEW_LINE if - diff // 2 in suffixCount : NEW_LINE INDENT y = suffixCount [ - dff // 2 ] NEW_LINE DEDENT if diff // 2 in prefixCount : NEW_LINE INDENT z = prefixCount NEW_LINE DEDENT x = z + y NEW_LINE count = count + x NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countCommonChar ( ind , S ) : NEW_LINE INDENT cnt = 0 NEW_LINE ls = set ( ) NEW_LINE rs = set ( ) NEW_LINE for i in range ( ind ) : NEW_LINE INDENT ls . add ( S [ i ] ) NEW_LINE DEDENT for i in range ( ind , len ( S ) ) : NEW_LINE INDENT rs . add ( S [ i ] ) NEW_LINE DEDENT for v in ls : NEW_LINE INDENT if v in rs : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def longestSubarray ( s ) : NEW_LINE INDENT s += '0' NEW_LINE i = 0 NEW_LINE res = 0 NEW_LINE prev_one = 0 NEW_LINE curr_one = 0 NEW_LINE numberOfZeros = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT curr_one += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT numberOfZeros += 1 NEW_LINE DEDENT prev_one += curr_one NEW_LINE res = max ( res , prev_one ) NEW_LINE prev_one = curr_one NEW_LINE curr_one = 0 NEW_LINE if ( numberOfZeros == 1 ) : NEW_LINE INDENT res -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def LarUnEl ( arr , N ) : NEW_LINE INDENT map = dict . fromkeys ( arr , 0 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT map [ arr [ i ] ] += 1 NEW_LINE DEDENT LNRElem = - sys . maxsize NEW_LINE ind = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( map . get ( arr [ i ] ) == 1 and arr [ i ] > LNRElem ) : NEW_LINE INDENT ind = i NEW_LINE LNRElem = arr [ i ] NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( ind ) NEW_LINE return NEW_LINE DEDENT print ( arr [ ind ] ) NEW_LINE DEDENT
def isConsistingSubarrayUtil ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for it in mp : NEW_LINE INDENT if ( mp [ it ] > 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def isConsistingSubarray ( arr , N ) : NEW_LINE INDENT if ( isConsistingSubarrayUtil ( arr , N ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def countShifts ( str ) : NEW_LINE INDENT firstOne = - 1 NEW_LINE lastOne = - 1 NEW_LINE count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT if ( firstOne == - 1 ) : NEW_LINE INDENT firstOne = i NEW_LINE DEDENT lastOne = i NEW_LINE DEDENT DEDENT if ( ( firstOne == - 1 ) or ( firstOne == lastOne ) ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT for i in range ( firstOne , lastOne + 1 , 1 ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def checkSubsequenceUtil ( arr , L , R , N ) : NEW_LINE INDENT for i in range ( L ) : NEW_LINE INDENT if ( arr [ i ] == arr [ L ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT for i in range ( R + 1 , N , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ R ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def largestSubarray ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE length = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] < K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT length = max ( length , count ) NEW_LINE count = 0 NEW_LINE DEDENT if ( count ) : NEW_LINE INDENT length = max ( length , count ) NEW_LINE DEDENT print ( length , end = "" ) NEW_LINE DEDENT
def findNthNum ( N ) : NEW_LINE INDENT last_num = 0 NEW_LINE left = 1 NEW_LINE right = N NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = left + ( right - left ) // 2 NEW_LINE t = ( mid * ( mid + 1 ) ) // 2 NEW_LINE if ( t < N ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT elif ( t == N ) : NEW_LINE INDENT a = mid NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT a = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT DEDENT t = a - 1 NEW_LINE b = N - ( t * ( t + 1 ) ) // 2 - 1 NEW_LINE print ( ( 1 << a ) + ( 1 << b ) ) NEW_LINE DEDENT
def longestSubsequence ( N , Q , arr , Queries ) : NEW_LINE INDENT for i in range ( Q ) : NEW_LINE INDENT x = Queries [ i ] [ 0 ] NEW_LINE y = Queries [ i ] [ 1 ] NEW_LINE arr [ x - 1 ] = y NEW_LINE count = 1 NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ j ] != arr [ j - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = ' ' ) NEW_LINE DEDENT DEDENT
def longestSubsequence ( N , Q , arr , Queries ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( Q ) : NEW_LINE INDENT x = Queries [ i ] [ 0 ] NEW_LINE y = Queries [ i ] [ 1 ] NEW_LINE if ( x > 1 ) : NEW_LINE INDENT if ( arr [ x - 1 ] != arr [ x - 2 ] ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if ( arr [ x - 2 ] != y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( x < N ) : NEW_LINE INDENT if ( arr [ x ] != arr [ x - 1 ] ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if ( y != arr [ x ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = ' ' ) NEW_LINE arr [ x - 1 ] = y NEW_LINE DEDENT DEDENT
def longestSubWithMaxSum ( arr , N ) : NEW_LINE INDENT Max = max ( arr ) NEW_LINE if ( Max < 0 ) : NEW_LINE INDENT print ( Max ) NEW_LINE return NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def printNGE ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE nge = [ - 1 ] * n NEW_LINE i = 0 NEW_LINE while ( i < 2 * n ) : NEW_LINE INDENT while ( len ( s ) != 0 and arr [ i % n ] > arr [ s [ - 1 ] ] ) : NEW_LINE INDENT nge [ s [ - 1 ] ] = arr [ i % n ] NEW_LINE s . pop ( ) NEW_LINE DEDENT s . append ( i % n ) NEW_LINE i += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( nge [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT s = int ( math . sqrt ( x ) ) NEW_LINE return ( s * s == x ) NEW_LINE DEDENT
def isFibonacci ( n ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) NEW_LINE DEDENT
def ifgcdFibonacci ( a , n , k ) : NEW_LINE INDENT compositeset = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isComposite ( a [ i ] ) and a [ i ] % k == 0 ) : NEW_LINE INDENT compositeset . append ( a [ i ] ) NEW_LINE DEDENT DEDENT gcd = compositeset [ 0 ] NEW_LINE for i in range ( 1 , len ( compositeset ) , 1 ) : NEW_LINE INDENT gcd = math . gcd ( gcd , compositeset [ i ] ) NEW_LINE if gcd == 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( isFibonacci ( gcd ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE return NEW_LINE DEDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def findPair ( A , N ) : NEW_LINE INDENT right_prod = [ 0 ] * N NEW_LINE flag = 0 NEW_LINE right_prod [ N - 1 ] = A [ N - 1 ] NEW_LINE for i in range ( N - 2 , 0 , - 1 ) : NEW_LINE INDENT right_prod [ i ] = right_prod [ i + 1 ] * A [ i ] NEW_LINE DEDENT total_prod = right_prod [ 0 ] NEW_LINE product = 1 NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT product = 1 NEW_LINE for j in range ( i , N - 1 ) : NEW_LINE INDENT product *= A [ j ] NEW_LINE if ( gcd ( product , right_prod [ j + 1 ] ) == 1 or gcd ( product , total_prod / right_prod [ i ] ) == 1 ) : NEW_LINE INDENT flag = 1 NEW_LINE print ( "(" , ( i - 1 ) , ", " , ( j + 1 ) , ")" ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def countString ( S ) : NEW_LINE INDENT count = 0 NEW_LINE for i in S : NEW_LINE INDENT if ( i == '0' and count > 0 ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( ( 1 << count ) - 1 ) NEW_LINE DEDENT
def replaceDuplicates ( names ) : NEW_LINE INDENT hash = { } NEW_LINE for i in range ( 0 , len ( names ) ) : NEW_LINE INDENT if names [ i ] not in hash : NEW_LINE INDENT hash [ names [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = hash [ names [ i ] ] NEW_LINE hash [ names [ i ] ] += 1 NEW_LINE names [ i ] += str ( count ) NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( names ) ) : NEW_LINE INDENT print ( names [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT
def digitProduct ( number ) : NEW_LINE INDENT res = 1 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT res *= ( number % 10 ) NEW_LINE number //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT
def DistinctCompositeDigitProduct ( arr , n ) : NEW_LINE INDENT output = set ( ) NEW_LINE prime = [ True for i in range ( N + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , N ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = digitProduct ( arr [ i ] ) NEW_LINE if ( ans <= 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( prime [ ans ] == False ) : NEW_LINE INDENT output . add ( ans ) NEW_LINE DEDENT DEDENT print ( len ( output ) ) NEW_LINE DEDENT
def SegmentedSieveFn ( low , high ) : NEW_LINE INDENT lmt = int ( math . sqrt ( high ) ) + 1 NEW_LINE prime = [ ] NEW_LINE prime = simpleSieve ( lmt , prime ) NEW_LINE n = high - low + 1 NEW_LINE segmentedSieve = [ True ] * ( n + 1 ) NEW_LINE for i in range ( 0 , len ( prime ) ) : NEW_LINE INDENT lowLim = int ( low // prime [ i ] ) * prime [ i ] NEW_LINE if ( lowLim < low ) : NEW_LINE INDENT lowLim += prime [ i ] NEW_LINE for j in range ( lowLim , high + 1 , prime [ i ] ) : NEW_LINE INDENT if ( j != prime [ i ] ) : NEW_LINE INDENT segmentedSieve [ j - low ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT return segmentedSieve NEW_LINE DEDENT
def countPairsWhoseSumPrimeL_R ( L , R ) : NEW_LINE INDENT segmentedSieve = SegmentedSieveFn ( L , R ) NEW_LINE cntPairs = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( segmentedSieve [ i - L ] == True ) : NEW_LINE INDENT cntPairs += i / 2 NEW_LINE DEDENT DEDENT return cntPairs NEW_LINE DEDENT
def count_zeroes ( n , str ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT DEDENT
def kReducingString ( n , k , str ) : NEW_LINE INDENT no_of_zeroes = count_zeroes ( n , str ) NEW_LINE no_of_ones = n - no_of_zeroes NEW_LINE if ( no_of_zeroes == 0 or no_of_zeroes == n ) : NEW_LINE INDENT return str NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT if ( no_of_zeroes == 0 or no_of_zeroes == n ) : NEW_LINE INDENT return str NEW_LINE DEDENT else : NEW_LINE INDENT return "Not Possible" NEW_LINE DEDENT check = 0 NEW_LINE for i in range ( ( n // k ) , n , ( n // k ) ) : NEW_LINE INDENT if ( no_of_zeroes == i or no_of_ones == i ) : NEW_LINE INDENT check = 1 NEW_LINE DEDENT break NEW_LINE if ( check == 0 ) : NEW_LINE INDENT return "Not Possible" NEW_LINE DEDENT return kReducingStringUtil ( n , k , str , no_of_zeroes ) NEW_LINE DEDENT DEDENT DEDENT
def convert_to_allzeroes ( st , a , b ) : NEW_LINE INDENT length = len ( st ) NEW_LINE left_1 = 0 NEW_LINE i = 0 NEW_LINE while ( i < length and st [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT left_1 = i NEW_LINE right_1 = 0 NEW_LINE i = length - 1 NEW_LINE while ( i >= 0 and st [ i ] == '0' ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT right_1 = i NEW_LINE if ( left_1 == length and right_1 == - 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT cost = a NEW_LINE for i in range ( left_1 , right_1 + 1 ) : NEW_LINE INDENT zeroes = 0 NEW_LINE while ( i < length and st [ i ] == '0' ) : NEW_LINE INDENT zeroes += 1 NEW_LINE i += 1 NEW_LINE DEDENT if ( zeroes ) : NEW_LINE INDENT cost += min ( zeroes * b , a ) NEW_LINE DEDENT DEDENT print ( cost ) NEW_LINE DEDENT
def MinDistK ( arr , N , K ) : NEW_LINE INDENT res = sys . maxsize NEW_LINE dist = 0 NEW_LINE for i in range ( N - K + 1 ) : NEW_LINE INDENT if ( arr [ i ] >= 0 and arr [ i + K - 1 ] >= 0 ) : NEW_LINE INDENT dist = max ( arr [ i ] , arr [ i + K - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dist = ( abs ( arr [ i ] ) + abs ( arr [ i + K - 1 ] ) + min ( abs ( arr [ i ] ) , abs ( arr [ i + K - 1 ] ) ) ) NEW_LINE DEDENT res = min ( res , dist ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def maximizeMin ( A , N , S , M ) : NEW_LINE INDENT minIndex , left , right = 0 , 0 , 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT minIndex = min ( A , N ) NEW_LINE A [ minIndex ] += 1 NEW_LINE left = minIndex - 1 NEW_LINE right = minIndex + 1 NEW_LINE for j in range ( S - 1 ) : NEW_LINE INDENT if ( left == - 1 ) : NEW_LINE INDENT A [ right ] += 1 NEW_LINE right += 1 NEW_LINE DEDENT elif ( right == N ) : NEW_LINE INDENT A [ left ] += 1 NEW_LINE left -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( A [ left ] < A [ right ] ) : NEW_LINE INDENT A [ left ] += 1 NEW_LINE left -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT A [ right ] += 1 NEW_LINE right += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT minIndex = min ( A , N ) NEW_LINE return A [ minIndex ] NEW_LINE DEDENT
def sumOfPathNodes ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( N == 2 or N == 3 ) : NEW_LINE INDENT return N + 1 NEW_LINE DEDENT arr = [ ] NEW_LINE arr . append ( 1 ) NEW_LINE k = 1 NEW_LINE flag = True NEW_LINE while ( k < N ) : NEW_LINE INDENT if ( flag == True ) : NEW_LINE INDENT k *= 2 NEW_LINE flag = False NEW_LINE DEDENT else : NEW_LINE INDENT k *= 4 NEW_LINE flag = True NEW_LINE DEDENT if ( k > N ) : NEW_LINE INDENT break NEW_LINE DEDENT arr . append ( k ) NEW_LINE DEDENT lenn = len ( arr ) NEW_LINE prefix = [ 0 ] * ( lenn ) NEW_LINE prefix [ 0 ] = 1 NEW_LINE for i in range ( 1 , lenn ) : NEW_LINE INDENT prefix [ i ] = arr [ i ] + prefix [ i - 1 ] NEW_LINE DEDENT it = bisect_left ( prefix , N ) NEW_LINE ind = it NEW_LINE final_ans = 0 NEW_LINE temp = N NEW_LINE while ( ind > 1 ) : NEW_LINE INDENT val = temp - prefix [ ind - 1 ] NEW_LINE if ( ind % 2 != 0 ) : NEW_LINE INDENT temp = prefix [ ind - 2 ] + ( val + 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT temp = prefix [ ind - 2 ] + ( val + 3 ) // 4 NEW_LINE DEDENT ind -= 1 NEW_LINE final_ans += temp NEW_LINE DEDENT final_ans += ( N + 1 ) NEW_LINE return final_ans NEW_LINE DEDENT
def fill_counts ( a , n ) : NEW_LINE INDENT maxA = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > maxA ) : NEW_LINE INDENT maxA = a [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT lcount [ a [ i ] ] [ i ] = 1 NEW_LINE rcount [ a [ i ] ] [ i ] = 1 NEW_LINE DEDENT for i in range ( maxA + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT lcount [ i ] [ j ] = ( lcount [ i ] [ j - 1 ] + lcount [ i ] [ j ] ) NEW_LINE DEDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT rcount [ i ] [ j ] = ( rcount [ i ] [ j + 1 ] + rcount [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT
def checkPointRange ( arr , X , Y , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT dist = sqrt ( ( arr [ i ] [ 0 ] - X ) * ( arr [ i ] [ 0 ] - X ) + ( arr [ i ] [ 1 ] - Y ) * ( arr [ i ] [ 1 ] - Y ) ) NEW_LINE if ( dist <= arr [ i ] [ 2 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findWinner ( arr , N ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( even == 0 ) : NEW_LINE INDENT if ( odd % 2 == 0 ) : NEW_LINE INDENT print ( "Player 2" ) NEW_LINE DEDENT elif ( odd % 2 == 1 ) : NEW_LINE INDENT print ( "Player 1" ) NEW_LINE DEDENT DEDENT elif ( even == 1 and odd % 2 == 1 ) : NEW_LINE INDENT print ( "Player 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def createhashmap ( Max ) : NEW_LINE INDENT hashmap = { "" } NEW_LINE curr = 1 NEW_LINE prev = 0 NEW_LINE hashmap . add ( prev ) NEW_LINE while ( curr <= Max ) : NEW_LINE INDENT hashmap . add ( curr ) NEW_LINE temp = curr NEW_LINE curr = curr + prev NEW_LINE prev = temp NEW_LINE DEDENT return hashmap NEW_LINE DEDENT
def SieveOfEratosthenes ( Max ) : NEW_LINE INDENT isPrime = [ 1 for x in range ( Max + 1 ) ] NEW_LINE isPrime [ 0 ] = 0 NEW_LINE isPrime [ 1 ] = 0 NEW_LINE for p in range ( 0 , int ( math . sqrt ( Max ) ) ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , Max , p ) : NEW_LINE INDENT isPrime [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT return isPrime NEW_LINE DEDENT
def cntFibonacciPrime ( arr , N ) : NEW_LINE INDENT Max = arr [ 0 ] NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT Max = max ( Max , arr [ i ] ) NEW_LINE DEDENT isPrime = SieveOfEratosthenes ( Max ) NEW_LINE hashmap = createhashmap ( Max ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if ( ( arr [ i ] in hashmap ) and ( not ( isPrime [ arr [ i ] ] ) ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def minJumps ( seats ) : NEW_LINE INDENT position = [ ] NEW_LINE count = 0 NEW_LINE lenn = len ( seats ) NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( seats [ i ] == 'x' ) : NEW_LINE INDENT position . append ( i - count ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if ( count == lenn or count == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT med_index = ( count - 1 ) // 2 NEW_LINE med_val = position [ med_index ] NEW_LINE ans = 0 NEW_LINE for i in range ( len ( position ) ) : NEW_LINE INDENT ans = ( ans % MOD + abs ( position [ i ] - med_val ) % MOD ) % MOD NEW_LINE DEDENT return ans % MOD NEW_LINE DEDENT
def singlePrimeFactor ( N ) : NEW_LINE INDENT disPrimeFact = { } NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT while ( N % i == 0 ) : NEW_LINE INDENT disPrimeFact [ i ] = 1 NEW_LINE N //= i NEW_LINE DEDENT DEDENT if ( N != 1 ) : NEW_LINE INDENT disPrimeFact [ N ] = 1 NEW_LINE DEDENT if ( len ( disPrimeFact ) == 1 ) : NEW_LINE INDENT return list ( disPrimeFact . keys ( ) ) [ 0 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def cntsingleFactorPair ( arr , N ) : NEW_LINE INDENT countOf1 = 0 NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT countOf1 += 1 NEW_LINE continue NEW_LINE DEDENT factorValue = singlePrimeFactor ( arr [ i ] ) NEW_LINE if ( factorValue == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT mp [ factorValue ] = mp . get ( factorValue , 0 ) + 1 NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for it in mp : NEW_LINE INDENT X = mp [ it ] NEW_LINE res += countOf1 * X + ( X * ( X - 1 ) ) // 2 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countPairs ( v1 , v2 , n , m , k ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n <= m ) : NEW_LINE INDENT v1 = sorted ( v1 ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT index = bisect_left ( v1 , v2 [ j ] - k ) NEW_LINE count += index NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT v2 = sorted ( v2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT index = bisect_right ( v2 , v1 [ i ] + k ) NEW_LINE count += m - index NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maxSumSubarr ( A , N , K , X ) : NEW_LINE INDENT sum_K = 0 NEW_LINE for i in range ( 0 , K ) : NEW_LINE INDENT sum_K += A [ i ] NEW_LINE DEDENT Max_Sum = 0 NEW_LINE if ( sum_K < X ) : NEW_LINE INDENT Max_Sum = sum_K NEW_LINE DEDENT for i in range ( K , N ) : NEW_LINE INDENT sum_K -= ( A [ i - K ] - A [ i ] ) NEW_LINE if ( sum_K < X ) : NEW_LINE INDENT Max_Sum = max ( Max_Sum , sum_K ) NEW_LINE DEDENT DEDENT print ( Max_Sum ) NEW_LINE DEDENT
def removeSmallestSubarray ( arr , n , k ) : NEW_LINE INDENT mod_arr = [ 0 ] * n NEW_LINE total_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mod_arr [ i ] = ( arr [ i ] + k ) % k NEW_LINE total_sum += arr [ i ] NEW_LINE DEDENT target_remainder = total_sum % k NEW_LINE if ( target_remainder == 0 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE return NEW_LINE DEDENT map1 = { } NEW_LINE map1 [ 0 ] = - 1 NEW_LINE curr_remainder = 0 NEW_LINE res = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_remainder = ( curr_remainder + arr [ i ] + k ) % k NEW_LINE map1 [ curr_remainder ] = i NEW_LINE mod = ( curr_remainder - target_remainder + k ) % k NEW_LINE if ( mod in map1 . keys ( ) ) : NEW_LINE INDENT res = min ( res , i - map1 [ mod ] ) NEW_LINE DEDENT DEDENT if ( res == sys . maxsize or res == n ) : NEW_LINE INDENT res = - 1 NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def findMaxLen ( wood , N , K ) : NEW_LINE INDENT left = 1 NEW_LINE right = max ( wood ) NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = left + ( right - left ) // 2 NEW_LINE if ( isValid ( wood , N , mid , K ) ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT DEDENT return right NEW_LINE DEDENT
def countFactors ( spf , num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num > 1 ) : NEW_LINE INDENT count += 1 NEW_LINE num = num // spf [ num ] NEW_LINE DEDENT return count NEW_LINE DEDENT
def precalculateSum ( spf ) : NEW_LINE INDENT sum = [ 0 ] * MAX NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT prime_factor = countFactors ( spf , i ) NEW_LINE if ( spf [ prime_factor ] == prime_factor ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def countSum ( a , n , sum ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 3 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 2 ) : NEW_LINE INDENT for k in range ( j + 1 , n - 1 ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countSum ( a , n , sum ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 3 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 2 , 1 ) : NEW_LINE INDENT req = sum - a [ i ] - a [ j ] NEW_LINE m = { } NEW_LINE for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT m [ a [ k ] ] = m . get ( a [ k ] , 0 ) + 1 NEW_LINE DEDENT twice_count = 0 NEW_LINE for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT twice_count += m . get ( req - a [ k ] , 0 ) NEW_LINE if ( req - a [ k ] == a [ k ] ) : NEW_LINE INDENT twice_count -= 1 NEW_LINE DEDENT DEDENT count += twice_count // 2 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countSum ( a , n , sum ) : NEW_LINE INDENT count = 0 NEW_LINE m = defaultdict ( int ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT temp = a [ i ] + a [ j ] NEW_LINE if ( temp < sum ) : NEW_LINE INDENT count += m [ sum - temp ] NEW_LINE DEDENT DEDENT for j in range ( i ) : NEW_LINE INDENT temp = a [ i ] + a [ j ] NEW_LINE if ( temp < sum ) : NEW_LINE INDENT m [ temp ] += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def minSwaps ( S , n ) : NEW_LINE INDENT swaps = 0 NEW_LINE arr = [ [ ] for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT pos = ord ( S [ i ] ) - ord ( 'a' ) NEW_LINE arr [ pos ] . append ( i ) NEW_LINE DEDENT for ch in range ( ord ( 'a' ) , ord ( 'z' ) + 1 ) : NEW_LINE INDENT pos = ch - ord ( 'a' ) NEW_LINE for i in range ( 1 , len ( arr [ pos ] ) ) : NEW_LINE INDENT swaps += abs ( arr [ pos ] [ i ] - arr [ pos ] [ i - 1 ] - 1 ) NEW_LINE DEDENT DEDENT return swaps NEW_LINE DEDENT
def isValid ( arr , n , m , d ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT if ( abs ( arr [ n - m + i ] - arr [ i ] ) < d ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def max_distance ( a , temp , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT temp [ i ] = - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] not in mp ) : NEW_LINE INDENT temp [ a [ i ] ] = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ a [ i ] ] = max ( temp [ a [ i ] ] , i - mp [ a [ i ] ] ) NEW_LINE DEDENT mp [ a [ i ] ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( temp [ i ] != - 1 ) : NEW_LINE INDENT temp [ i ] = max ( temp [ i ] , n - mp [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
def min_comm_ele ( a , ans , temp , n ) : NEW_LINE INDENT max_distance ( a , temp , n ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans [ i ] = - 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ans [ temp [ i ] ] == - 1 ) : NEW_LINE INDENT ans [ temp [ i ] ] = i NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > 1 and ans [ i - 1 ] != - 1 ) : NEW_LINE INDENT if ( ans [ i ] == - 1 ) : NEW_LINE INDENT ans [ i ] = ans [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = min ( ans [ i ] , ans [ i - 1 ] ) NEW_LINE DEDENT DEDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def maxiConsecutiveSubarray ( arr , N ) : NEW_LINE INDENT maxi = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT cnt = 1 NEW_LINE for j in range ( i , N - 1 ) : NEW_LINE INDENT if ( arr [ j + 1 ] == arr [ j ] + 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT maxi = max ( maxi , cnt ) NEW_LINE i = j NEW_LINE DEDENT return maxi NEW_LINE DEDENT
def FindTrip ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N - 1 ) : NEW_LINE INDENT p = arr [ i - 1 ] NEW_LINE q = arr [ i ] NEW_LINE r = arr [ i + 1 ] NEW_LINE if ( p < q and q > r ) : NEW_LINE INDENT print ( i - 1 , i , i + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def cntSubarrays ( arr , N ) : NEW_LINE INDENT cntSub = 0 NEW_LINE cntUnique = 0 NEW_LINE cntFreq = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT cntFreq [ arr [ j ] ] += 1 NEW_LINE if ( cntFreq [ arr [ j ] ] == 1 ) : NEW_LINE INDENT cntUnique += 1 NEW_LINE DEDENT elif ( cntFreq [ arr [ j ] ] == 2 ) : NEW_LINE INDENT cntUnique -= 1 NEW_LINE DEDENT if ( cntUnique == 0 ) : NEW_LINE INDENT cntSub += 1 NEW_LINE DEDENT DEDENT cntFreq . clear ( ) NEW_LINE cntUnique = 0 NEW_LINE DEDENT return cntSub NEW_LINE DEDENT
def checkPalinK ( str , K ) : NEW_LINE INDENT N = len ( str ) NEW_LINE cntFreq = [ 0 ] * 256 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cntFreq [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT cntOddFreq = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT if ( cntFreq [ i ] % 2 == 1 ) : NEW_LINE INDENT cntOddFreq += 1 NEW_LINE DEDENT DEDENT if ( cntOddFreq <= ( K + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def printIndexes ( strr ) : NEW_LINE INDENT N = len ( strr ) NEW_LINE cntFreq = [ 0 ] * 256 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cntFreq [ ord ( strr [ i ] ) ] += 1 NEW_LINE DEDENT cntLeftFreq = [ 0 ] * 256 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cntLeft = 0 NEW_LINE cntRight = 0 NEW_LINE for j in range ( ord ( strr [ i ] ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT cntLeft += cntLeftFreq [ j ] NEW_LINE cntRight += ( cntFreq [ j ] - cntLeftFreq [ j ] ) NEW_LINE DEDENT cntLeftFreq [ ord ( strr [ i ] ) ] += 1 NEW_LINE if ( cntLeft == cntRight and cntLeft != 0 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def digiSum ( a ) : NEW_LINE INDENT sums = 0 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT sums += a % 10 NEW_LINE a = a // 10 NEW_LINE DEDENT return sums NEW_LINE DEDENT
def isPrime ( r ) : NEW_LINE INDENT s = True NEW_LINE for i in range ( 2 , int ( math . sqrt ( r ) ) + 1 ) : NEW_LINE INDENT if ( r % i == 0 ) : NEW_LINE INDENT s = False NEW_LINE break NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def Count_Number ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( x % 99 != 0 ) : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT diff = x / 99 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( 1 , 10 ) : NEW_LINE INDENT if ( ( i - j ) == diff ) : NEW_LINE INDENT ans += 10 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def find_index ( arr , n , K ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == K : NEW_LINE INDENT return i NEW_LINE DEDENT elif arr [ i ] > K : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def find_index ( arr , n , B ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE while start <= end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if arr [ mid ] == K : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < K : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return end + 1 NEW_LINE DEDENT
def isinRange ( board ) : NEW_LINE INDENT N = 9 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( board [ i ] [ j ] <= 0 ) or ( board [ i ] [ j ] > 9 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
def isValidSudoku ( board ) : NEW_LINE INDENT N = 9 NEW_LINE if ( isinRange ( board ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT unique = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for m in range ( 0 , N + 1 ) : NEW_LINE INDENT unique [ m ] = False NEW_LINE DEDENT for j in range ( 0 , N ) : NEW_LINE INDENT Z = board [ i ] [ j ] NEW_LINE DEDENT if ( unique [ Z ] == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT unique [ Z ] = True NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for m in range ( 0 , N + 1 ) : NEW_LINE INDENT unique [ m ] = False NEW_LINE DEDENT for j in range ( 0 , N ) : NEW_LINE INDENT Z = board [ j ] [ i ] NEW_LINE DEDENT if ( unique [ Z ] == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT unique [ Z ] = True NEW_LINE for i in range ( 0 , N - 2 , 3 ) : NEW_LINE INDENT for j in range ( 0 , N - 2 , 3 ) : NEW_LINE INDENT for m in range ( 0 , N + 1 ) : NEW_LINE INDENT unique [ m ] = False NEW_LINE DEDENT DEDENT for k in range ( 0 , 3 ) : NEW_LINE INDENT for l in range ( 0 , 3 ) : NEW_LINE INDENT X = i + k NEW_LINE DEDENT Y = j + l NEW_LINE Z = board [ X ] [ Y ] NEW_LINE if ( unique [ Z ] == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT unique [ Z ] = True NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT
def minSubarray ( arr , N ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT mini = 10 ** 9 NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT mini = min ( mini , arr [ j ] ) NEW_LINE m [ mini ] = m . get ( mini , 0 ) + 1 NEW_LINE DEDENT DEDENT for i in arr : NEW_LINE INDENT print ( m [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def minSubarray ( arr , N ) : NEW_LINE INDENT result = [ 0 ] * N NEW_LINE l = [ ] NEW_LINE r = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT count = 1 NEW_LINE while ( len ( l ) != 0 and l [ - 1 ] [ 0 ] > arr [ i ] ) : NEW_LINE INDENT count += l [ - 1 ] [ 1 ] NEW_LINE l . pop ( ) NEW_LINE DEDENT l . append ( [ arr [ i ] , count ] ) NEW_LINE result [ i ] = count NEW_LINE DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT count = 1 NEW_LINE while ( len ( r ) != 0 and r [ - 1 ] [ 0 ] >= arr [ i ] ) : NEW_LINE INDENT count += r [ - 1 ] [ 1 ] NEW_LINE r . pop ( ) NEW_LINE DEDENT r . append ( [ arr [ i ] , count ] ) NEW_LINE result [ i ] *= count NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( result [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def isPrime ( num ) : NEW_LINE INDENT if ( num <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , num + 1 ) : NEW_LINE INDENT if i * i > num : NEW_LINE INDENT break NEW_LINE DEDENT if ( num % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isFulPrime ( n ) : NEW_LINE INDENT if ( not isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT rem = n % 10 NEW_LINE if ( not ( rem == 2 or rem == 3 or rem == 5 or rem == 7 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countFulPrime ( L , R ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( ( i % 2 ) != 0 and isFulPrime ( i ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def computePos ( arr , n , value ) : NEW_LINE INDENT if ( value < arr [ 0 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( value > arr [ n - 1 ] ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT start = 0 NEW_LINE end = n - 1 NEW_LINE while ( start < end ) : NEW_LINE INDENT mid = ( start + end + 1 ) // 2 NEW_LINE if ( arr [ mid ] >= value ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT return start NEW_LINE DEDENT
def countShift ( arr , n , queries ) : NEW_LINE INDENT for q in queries : NEW_LINE INDENT index = q [ 0 ] NEW_LINE update = q [ 1 ] NEW_LINE newElement = arr [ index ] + update NEW_LINE newIndex = computePos ( arr , n , newElement ) NEW_LINE print ( abs ( newIndex - index ) , end = " " ) NEW_LINE DEDENT DEDENT
def printAlter ( arr , N ) : NEW_LINE INDENT for currIndex in range ( 0 , N ) : NEW_LINE INDENT if ( currIndex % 2 == 0 ) : NEW_LINE INDENT print ( arr [ currIndex ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def printAlter ( arr , N ) : NEW_LINE INDENT for currIndex in range ( 0 , N , 2 ) : NEW_LINE INDENT print ( arr [ currIndex ] , end = " " ) NEW_LINE DEDENT DEDENT
def findmin ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE maximum = 0 NEW_LINE incr = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT incr [ i + 1 ] = incr [ i ] NEW_LINE if ( s [ i ] == '0' ) : NEW_LINE INDENT incr [ i + 1 ] = incr [ i + 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maximum = max ( maximum , incr [ i ] + j - i + 1 - ( incr [ j + 1 ] - incr [ i ] ) + incr [ n ] - incr [ j + 1 ] ) NEW_LINE DEDENT DEDENT return n - maximum NEW_LINE DEDENT
def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def digitSum ( number ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT sum += ( number % 10 ) NEW_LINE number //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def longestCompositeDigitSumSubsequence ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE prime = [ True ] * ( N + 1 ) NEW_LINE SieveOfEratosthenes ( prime , N ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = digitSum ( arr [ i ] ) NEW_LINE if ( res == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( not prime [ res ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def isPower ( x ) : NEW_LINE INDENT if ( x != 0 and ( x & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def maximumlength ( arr , N ) : NEW_LINE INDENT max_length = 0 NEW_LINE max_len_subarray = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( isPower ( arr [ i ] ) ) : NEW_LINE INDENT max_length += 1 NEW_LINE max_len_subarray = max ( max_length , max_len_subarray ) NEW_LINE DEDENT else : NEW_LINE INDENT max_length = 0 NEW_LINE DEDENT DEDENT print ( max_len_subarray ) NEW_LINE DEDENT
def minSub ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N >= 0 ) : NEW_LINE INDENT num = N NEW_LINE rev = 0 NEW_LINE while ( num != 0 ) : NEW_LINE INDENT digit = num % 10 NEW_LINE rev = ( rev * 10 ) + digit NEW_LINE num = num // 10 NEW_LINE DEDENT if ( N == rev ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE N -= 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def isPalindrome ( st ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( st ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( st [ i ] != st [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isPerfect ( N ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i == N // i ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT else : NEW_LINE INDENT sum += i + N // i NEW_LINE DEDENT DEDENT DEDENT if ( sum == N and N != 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def maxSum ( arr , N , K ) : NEW_LINE INDENT if ( N < K ) : NEW_LINE INDENT print ( "Invalid" ) NEW_LINE return - 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE DEDENT curr_sum = res NEW_LINE for i in range ( K , N ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - K ] NEW_LINE res = max ( res , curr_sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def max_PerfectNumbers ( arr , N , K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if isPerfect ( arr [ i ] ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT return maxSum ( arr , N , K ) NEW_LINE DEDENT
def minElements ( A , B , N , M ) : NEW_LINE INDENT map = { } NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT map [ A [ i ] ] = i NEW_LINE DEDENT subseq = [ ] NEW_LINE l = 0 NEW_LINE r = - 1 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if B [ i ] in map : NEW_LINE INDENT e = map [ B [ i ] ] NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if ( subseq [ m ] < e ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT if ( r + 1 < len ( subseq ) ) : NEW_LINE INDENT subseq [ r + 1 ] = e NEW_LINE DEDENT else : NEW_LINE INDENT subseq . append ( e ) NEW_LINE DEDENT l = 0 NEW_LINE r = len ( subseq ) - 1 NEW_LINE DEDENT DEDENT return N - len ( subseq ) NEW_LINE DEDENT
def cntSubarr ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE prefixXor = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT prefixXor = arr [ i ] NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT prefixXor ^= arr [ j ] NEW_LINE if ( prefixXor == 0 and ( j - i + 1 ) % 2 == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def cntSubXor ( arr , N ) : NEW_LINE INDENT prefixXor = 0 NEW_LINE Even = [ 0 ] * M NEW_LINE Odd = [ 0 ] * M NEW_LINE cntSub = 0 NEW_LINE Odd [ 0 ] = 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT prefixXor ^= arr [ i ] NEW_LINE if ( i % 2 == 1 ) : NEW_LINE INDENT cntSub += Odd [ prefixXor ] NEW_LINE Odd [ prefixXor ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntSub += Even [ prefixXor ] NEW_LINE Even [ prefixXor ] += 1 NEW_LINE DEDENT DEDENT return cntSub NEW_LINE DEDENT
def zvalue ( nums ) : NEW_LINE INDENT m = max ( nums ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 0 , m + 1 , 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( 0 , len ( nums ) , 1 ) : NEW_LINE INDENT if ( nums [ j ] >= i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt == i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def isEvenOddBinaryTree ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return True NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE level = 0 NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT size = len ( q ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT node = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( level % 2 == 0 ) : NEW_LINE INDENT if ( node . val % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( level % 2 == 1 ) : NEW_LINE INDENT if ( node . val % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( node . left != None ) : NEW_LINE INDENT q . append ( node . left ) NEW_LINE DEDENT if ( node . right != None ) : NEW_LINE INDENT q . append ( node . right ) NEW_LINE DEDENT DEDENT level += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT
def is_prime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def countSmallerPrimes ( ar , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ar [ j ] <= ar [ i ] and is_prime ( ar [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " " ) NEW_LINE DEDENT DEDENT
def is_prime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def checkConcat ( str1 , str2 ) : NEW_LINE INDENT N = len ( str1 ) NEW_LINE M = len ( str2 ) NEW_LINE if ( N % M != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i % M ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def MinLen ( str , K ) : NEW_LINE INDENT N = len ( str ) NEW_LINE i = 0 NEW_LINE while ( i < N - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i == N - 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( 1 , N - K ) NEW_LINE DEDENT
def findSubArray ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT if ( palindrome ( arr , i , i + k - 1 ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def helper ( mid ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in mp : NEW_LINE INDENT temp = mp [ i ] NEW_LINE while ( temp >= mid ) : NEW_LINE INDENT temp -= mid NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT return cnt >= N NEW_LINE DEDENT
def findMaximumDays ( arr ) : NEW_LINE INDENT for i in range ( P ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT start = 0 NEW_LINE end = P NEW_LINE ans = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( ( end - start ) // 2 ) NEW_LINE if ( mid != 0 and helper ( mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE start = mid + 1 NEW_LINE DEDENT elif ( mid == 0 ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def temp ( n , x ) : NEW_LINE INDENT return pow ( x * 1 / n , n ) NEW_LINE DEDENT
def check ( n , y , x ) : NEW_LINE INDENT v = temp ( n , x ) NEW_LINE return ( v >= y ) NEW_LINE DEDENT
def speciallyBalancedNodes ( R , N , str , values ) : NEW_LINE INDENT root = build_tree ( R , N , str , values ) NEW_LINE sum = 0 NEW_LINE tmp , sum = SBTUtil ( root , sum ) NEW_LINE print ( sum , end = ' ' ) NEW_LINE DEDENT
def display ( countLeftGreater , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( countLeftGreater [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def minLength ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ 0 ] != arr [ i ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return N NEW_LINE DEDENT
def PrintIndexes ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT currSubSum = 0 NEW_LINE for j in range ( i , N , 1 ) : NEW_LINE INDENT currSubSum += arr [ j ] NEW_LINE sq = int ( math . sqrt ( currSubSum ) ) NEW_LINE if ( sq * sq == currSubSum ) : NEW_LINE INDENT print ( "(" , i , "," , j , ")" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def check ( pSum , lenn , k , a ) : NEW_LINE INDENT i = 0 NEW_LINE j = lenn NEW_LINE while ( j <= len ( a ) ) : NEW_LINE INDENT maxSize = a [ j - 1 ] NEW_LINE totalNumbers = maxSize * lenn NEW_LINE currNumbers = pSum [ j ] - pSum [ i ] NEW_LINE if ( currNumbers + k >= totalNumbers ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def countPosition ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE m = len ( mat [ 0 ] ) NEW_LINE row = [ 0 ] * n NEW_LINE col = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT col [ j ] += 1 NEW_LINE row [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( row [ i ] == col [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def position ( arr , N ) : NEW_LINE INDENT pos = - 1 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] and arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == N ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT DEDENT if ( pos == - 1 ) : NEW_LINE INDENT print ( pos ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( pos + 1 ) NEW_LINE DEDENT DEDENT
def maxAtLevel ( N , M , Value , Edges ) : NEW_LINE INDENT adj = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT u = Edges [ i ] [ 0 ] NEW_LINE v = Edges [ i ] [ 1 ] NEW_LINE adj [ u ] . append ( v ) NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( 0 ) NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT count = len ( q ) NEW_LINE maxVal = 0 NEW_LINE while ( count ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . remove ( q [ 0 ] ) NEW_LINE maxVal = max ( maxVal , Value [ temp ] ) NEW_LINE for i in range ( len ( adj [ temp ] ) ) : NEW_LINE INDENT q . append ( adj [ temp ] [ i ] ) NEW_LINE DEDENT count -= 1 NEW_LINE DEDENT print ( maxVal , end = " " ) NEW_LINE DEDENT DEDENT
def floyd_warshall ( graph , V ) : NEW_LINE INDENT dist = [ [ 0 for i in range ( V ) ] for i in range ( V ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT dist [ i ] [ j ] = graph [ i ] [ j ] NEW_LINE DEDENT DEDENT for k in range ( V ) : NEW_LINE INDENT for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) : NEW_LINE INDENT dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( i + 1 , V ) : NEW_LINE INDENT sum += dist [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def sumOfshortestPath ( N , E , edges ) : NEW_LINE INDENT g = [ [ INF for i in range ( N ) ] for i in range ( N ) ] NEW_LINE for i in range ( E ) : NEW_LINE INDENT u = edges [ i ] [ 0 ] NEW_LINE v = edges [ i ] [ 1 ] NEW_LINE w = edges [ i ] [ 2 ] NEW_LINE g [ u ] [ v ] = w NEW_LINE g [ v ] [ u ] = w NEW_LINE DEDENT return floyd_warshall ( g , N ) NEW_LINE DEDENT
def minCost ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE i = 0 NEW_LINE maxlen = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT length = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] == B [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE length += 1 NEW_LINE if ( i == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT maxlen = max ( maxlen , length ) NEW_LINE DEDENT return n - maxlen NEW_LINE DEDENT
def binarySearch ( arr , N , X ) : NEW_LINE INDENT start = 0 NEW_LINE end = N NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( end - start ) // 2 NEW_LINE if ( X == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( X < arr [ mid ] ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def check ( a , n ) : NEW_LINE INDENT b = [ None ] * n NEW_LINE minElement = sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT b [ i ] = a [ i ] NEW_LINE minElement = min ( minElement , a [ i ] ) NEW_LINE DEDENT b . sort ( ) NEW_LINE k = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( a [ i ] != b [ i ] ) and ( a [ i ] % minElement != 0 ) ) : NEW_LINE INDENT k = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if k == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def check_both_present ( arr , N , a , b ) : NEW_LINE INDENT f1 = False NEW_LINE f2 = False NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if arr [ i ] == a : NEW_LINE INDENT f1 = True NEW_LINE DEDENT if arr [ i ] == b : NEW_LINE INDENT f2 = True NEW_LINE DEDENT DEDENT if f1 and f2 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def print_array ( ans , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def build_AP ( N , a , b ) : NEW_LINE INDENT INT_MAX = sys . maxsize NEW_LINE arr = [ None for i in range ( N ) ] NEW_LINE ans = [ INT_MAX for i in range ( N ) ] NEW_LINE flag = 0 NEW_LINE if a > b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT diff = b - a NEW_LINE for start in range ( 1 , a + 1 ) : NEW_LINE INDENT for d in range ( 1 , diff + 1 ) : NEW_LINE INDENT arr [ 0 ] = start NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + d NEW_LINE DEDENT if ( ( check_both_present ( arr , N , a , b ) and arr [ N - 1 ] < ans [ N - 1 ] ) ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT ans [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print_array ( ans , N ) NEW_LINE DEDENT
def numSpecial ( mat ) : NEW_LINE INDENT m = len ( mat ) NEW_LINE n = len ( mat [ 0 ] ) NEW_LINE rows = [ 0 ] * m NEW_LINE cols = [ 0 ] * n NEW_LINE i , j = 0 , 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT rows [ i ] = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT rows [ i ] += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT cols [ i ] = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT cols [ i ] += mat [ j ] [ i ] NEW_LINE DEDENT DEDENT cnt = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 and rows [ i ] == 1 and cols [ j ] == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def ctMinEdits ( str1 , str2 ) : NEW_LINE INDENT N1 = len ( str1 ) NEW_LINE N2 = len ( str2 ) NEW_LINE freq1 = [ 0 ] * 256 NEW_LINE for i in range ( N1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) ] += 1 NEW_LINE DEDENT freq2 = [ 0 ] * 256 NEW_LINE for i in range ( N2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 256 ) : NEW_LINE INDENT if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT freq1 [ i ] = freq1 [ i ] - freq2 [ i ] NEW_LINE freq2 [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT freq2 [ i ] = freq2 [ i ] - freq1 [ i ] NEW_LINE freq1 [ i ] = 0 NEW_LINE DEDENT DEDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT sum1 += freq1 [ i ] NEW_LINE sum2 += freq2 [ i ] NEW_LINE DEDENT return max ( sum1 , sum2 ) NEW_LINE DEDENT
def create_graph ( ) : NEW_LINE INDENT g [ 1 ] . append ( 2 ) NEW_LINE g [ 2 ] . append ( 1 ) NEW_LINE g [ 1 ] . append ( 3 ) NEW_LINE g [ 3 ] . append ( 1 ) NEW_LINE g [ 1 ] . append ( 4 ) NEW_LINE g [ 4 ] . append ( 1 ) NEW_LINE g [ 2 ] . append ( 5 ) NEW_LINE g [ 5 ] . append ( 2 ) NEW_LINE g [ 2 ] . append ( 6 ) NEW_LINE g [ 6 ] . append ( 2 ) NEW_LINE DEDENT
def dfs ( Node , parent ) : NEW_LINE INDENT size [ Node ] = 1 NEW_LINE mx = 0 NEW_LINE global mini NEW_LINE global ans NEW_LINE for y in g [ Node ] : NEW_LINE INDENT if ( y == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( y , Node ) NEW_LINE size [ Node ] += size [ y ] NEW_LINE mx = max ( mx , size [ y ] ) NEW_LINE DEDENT mx = max ( mx , n - size [ Node ] ) NEW_LINE if ( mx < mini ) : NEW_LINE INDENT mini = mx NEW_LINE ans = Node NEW_LINE DEDENT DEDENT
def countPrecedingK ( a , n , K ) : NEW_LINE INDENT prefix = [ 0 ] * n NEW_LINE prefix [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + a [ i ] NEW_LINE DEDENT ctr = 0 NEW_LINE if ( prefix [ K - 1 ] < a [ K ] ) : NEW_LINE INDENT ctr += 1 NEW_LINE DEDENT for i in range ( K + 1 , n ) : NEW_LINE INDENT if ( prefix [ i - 1 ] - prefix [ i - K - 1 ] < a [ i ] ) : NEW_LINE INDENT ctr += 1 NEW_LINE DEDENT DEDENT return ctr NEW_LINE DEDENT
def minDigits ( N , K ) : NEW_LINE INDENT
def CountPairs ( a , b , n ) : NEW_LINE INDENT C = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT C [ i ] = a [ i ] + b [ i ] NEW_LINE DEDENT freqCount = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if C [ i ] in freqCount . keys ( ) : NEW_LINE INDENT freqCount [ C [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freqCount [ C [ i ] ] = 1 NEW_LINE DEDENT DEDENT NoOfPairs = 0 NEW_LINE for x in freqCount : NEW_LINE INDENT y = freqCount [ x ] NEW_LINE NoOfPairs = ( NoOfPairs + y * ( y - 1 ) // 2 ) NEW_LINE DEDENT print ( NoOfPairs ) NEW_LINE DEDENT
def convertBfromA ( a , b ) : NEW_LINE INDENT moves = 0 NEW_LINE x = abs ( a - b ) NEW_LINE for i in range ( 10 , 0 , - 1 ) : NEW_LINE INDENT moves += x // i NEW_LINE x = x % i NEW_LINE DEDENT print ( moves , end = " " ) NEW_LINE DEDENT
def smallestNth ( A , B , N ) : NEW_LINE INDENT res = sys . maxsize NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( N , i , - 1 ) : NEW_LINE INDENT if ( ( B - A ) % ( j - i ) == 0 ) : NEW_LINE INDENT D = ( B - A ) // ( j - i ) NEW_LINE FirstTerm = A - ( i - 1 ) * D NEW_LINE NthTerm = FirstTerm + ( N - 1 ) * D NEW_LINE if ( FirstTerm > 0 ) : NEW_LINE INDENT res = min ( res , NthTerm ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def sieve ( prime ) : NEW_LINE INDENT for i in range ( 1000000 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 0 ] = prime [ 1 ] = False NEW_LINE for i in range ( 2 , 1000 + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , 1000000 , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return prime NEW_LINE DEDENT
def subPrimeSum ( N , K , arr , prime ) : NEW_LINE INDENT currSum = 0 NEW_LINE for i in range ( 0 , K ) : NEW_LINE INDENT currSum += arr [ i ] NEW_LINE DEDENT if ( prime [ currSum ] ) : NEW_LINE INDENT for i in range ( K ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT st = 1 NEW_LINE en = K NEW_LINE while ( en < N ) : NEW_LINE INDENT currSum += arr [ en ] - arr [ st - 1 ] NEW_LINE if ( prime [ currSum ] ) : NEW_LINE INDENT for i in range ( st , en + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT en += 1 NEW_LINE st += 1 NEW_LINE DEDENT DEDENT
def minDeletion ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE firstIdx1 = - 1 NEW_LINE lastIdx0 = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT firstIdx1 = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT lastIdx0 = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( firstIdx1 == - 1 or lastIdx0 == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count1 = 0 NEW_LINE count0 = 0 NEW_LINE for i in range ( 0 , lastIdx0 ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT DEDENT for i in range ( firstIdx1 + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT DEDENT return min ( count0 , count1 ) NEW_LINE DEDENT
def maximumSum ( a , b , n , index , lastpicked ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT option1 = 0 NEW_LINE option2 = 0 NEW_LINE if ( lastpicked == - 1 or a [ lastpicked ] != a [ index ] ) : NEW_LINE INDENT option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) NEW_LINE DEDENT option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) NEW_LINE return max ( option1 , option2 ) NEW_LINE DEDENT
def maximumSum ( a , b , n , index , lastpicked , dp ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ index ] [ lastpicked + 1 ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ lastpicked + 1 ] NEW_LINE DEDENT option1 , option2 = 0 , 0 NEW_LINE if ( lastpicked == - 1 or a [ lastpicked ] != a [ index ] ) : NEW_LINE INDENT option1 = ( b [ index ] + maximumSum ( a , b , n , index + 1 , index , dp ) ) NEW_LINE DEDENT option2 = maximumSum ( a , b , n , index + 1 , lastpicked , dp ) NEW_LINE dp [ index ] [ lastpicked + 1 ] = max ( option1 , option2 ) NEW_LINE return dp [ index ] [ lastpicked + 1 ] NEW_LINE DEDENT
def sumOfKElements ( arr , n , k ) : NEW_LINE INDENT rev = False NEW_LINE if ( k < 0 ) : NEW_LINE INDENT rev = True NEW_LINE k *= - 1 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT tmp = arr [ l ] NEW_LINE arr [ l ] = arr [ r ] NEW_LINE arr [ r ] = tmp NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] += dp [ i - 1 ] + arr [ i ] NEW_LINE DEDENT ans = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i + k < n ) : NEW_LINE INDENT ans [ i ] = dp [ i + k ] - dp [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT x = k - ( n - 1 - i ) NEW_LINE y = x // n NEW_LINE rem = x % n NEW_LINE ans [ i ] = ( dp [ n - 1 ] - dp [ i ] + y * dp [ n - 1 ] + ( dp [ rem - 1 ] if rem - 1 >= 0 else 0 ) ) NEW_LINE DEDENT DEDENT if ( rev ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def countingSubarray ( arr , n ) : NEW_LINE INDENT a = [ 0 for i in range ( n ) ] NEW_LINE nsml = [ - 1 for i in range ( n ) ] NEW_LINE nsmr = [ n for i in range ( n ) ] NEW_LINE st = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( len ( st ) > 0 and arr [ st [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT del st [ - 1 ] NEW_LINE DEDENT if ( len ( st ) > 0 ) : NEW_LINE INDENT nsmr [ i ] = st [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nsmr [ i ] = n NEW_LINE DEDENT st . append ( i ) NEW_LINE DEDENT while ( len ( st ) > 0 ) : NEW_LINE INDENT del st [ - 1 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT while ( len ( st ) > 0 and arr [ st [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT del st [ - 1 ] NEW_LINE DEDENT if ( len ( st ) > 0 ) : NEW_LINE INDENT nsml [ i ] = st [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nsml [ i ] = - 1 NEW_LINE DEDENT st . append ( i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT nsml [ i ] += 1 NEW_LINE nsmr [ i ] -= 1 NEW_LINE r = nsmr [ i ] - i + 1 NEW_LINE l = i - nsml [ i ] + 1 NEW_LINE a [ i ] = r * l NEW_LINE DEDENT return a NEW_LINE DEDENT
def countTuples ( arr , N ) : NEW_LINE INDENT ans = 0 NEW_LINE val = 0 NEW_LINE freq = { } NEW_LINE for j in range ( N - 2 ) : NEW_LINE INDENT val = 0 NEW_LINE for l in range ( j + 1 , N ) : NEW_LINE INDENT if ( arr [ j ] == arr [ l ] ) : NEW_LINE INDENT ans += val NEW_LINE DEDENT if arr [ l ] in freq : NEW_LINE INDENT val += freq [ arr [ l ] ] NEW_LINE DEDENT DEDENT freq [ arr [ j ] ] = freq . get ( arr [ j ] , 0 ) + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isCrossed ( path ) : NEW_LINE INDENT if ( len ( path ) == 0 ) : NEW_LINE INDENT return bool ( False ) NEW_LINE DEDENT ans = bool ( False ) NEW_LINE Set = set ( ) NEW_LINE x , y = 0 , 0 NEW_LINE Set . add ( ( x , y ) ) NEW_LINE for i in range ( len ( path ) ) : NEW_LINE INDENT if ( path [ i ] == 'N' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE y = y + 1 NEW_LINE DEDENT if ( path [ i ] == 'S' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE y = y - 1 NEW_LINE DEDENT if ( path [ i ] == 'E' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE x = x + 1 NEW_LINE DEDENT if ( path [ i ] == 'W' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE x = x - 1 NEW_LINE DEDENT if ( x , y ) in Set : NEW_LINE INDENT ans = bool ( True ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( ans ) : NEW_LINE INDENT print ( "Crossed" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Not Crossed" ) NEW_LINE DEDENT DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT
def GcdPair ( arr , k ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = len ( arr ) - 1 NEW_LINE ans = [ - 1 , 0 ] NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = lo + ( hi - lo ) // 2 NEW_LINE if ( GCD ( arr [ mid ] [ 0 ] , arr [ mid ] [ 1 ] ) > k ) : NEW_LINE INDENT ans = arr [ mid ] NEW_LINE hi = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT if ( len ( ans ) == - 1 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "(" , ans [ 0 ] , "," , ans [ 1 ] , ")" ) NEW_LINE DEDENT DEDENT
def isPossible ( arr , N ) : NEW_LINE INDENT mn = sys . maxsize NEW_LINE B = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT mn = min ( mn , arr [ i ] ) NEW_LINE B [ i ] = arr [ i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] != B [ i ] ) : NEW_LINE INDENT if ( B [ i ] % mn != 0 ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( "Yes" ) NEW_LINE return NEW_LINE DEDENT
def func ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if n == 2 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT count = 1 + func ( n // 2 ) NEW_LINE DEDENT if n % 2 != 0 : NEW_LINE INDENT count = 1 + func ( n * 3 + 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def findKthElement ( l , r , k ) : NEW_LINE INDENT arr = list ( range ( l , r + 1 ) ) NEW_LINE result = [ ] NEW_LINE for i in arr : NEW_LINE INDENT result . append ( [ i , func ( i ) ] ) NEW_LINE DEDENT result . sort ( ) NEW_LINE print ( result [ k - 1 ] [ 0 ] ) NEW_LINE DEDENT
def checkHex ( s ) : NEW_LINE INDENT for ch in s : NEW_LINE INDENT if ( ( ch < '0' or ch > '9' ) and ( ch < 'A' or ch > 'F' ) ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "Yes" ) NEW_LINE DEDENT
def maxWidth ( N , M , cost , s ) : NEW_LINE INDENT adj = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT adj [ s [ i ] [ 0 ] ] . append ( s [ i ] [ 1 ] ) NEW_LINE DEDENT result = 0 NEW_LINE q = deque ( ) NEW_LINE q . append ( 0 ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT count = len ( q ) NEW_LINE result = max ( count , result ) NEW_LINE while ( count > 0 ) : NEW_LINE INDENT temp = q . popleft ( ) NEW_LINE for i in adj [ temp ] : NEW_LINE INDENT q . append ( i ) NEW_LINE DEDENT count -= 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def addEdge ( adj , u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE return adj NEW_LINE DEDENT
def DFSUtil ( u , adj , visited , componentMin , componentMax ) : NEW_LINE INDENT visited [ u ] = True NEW_LINE componentMax = max ( componentMax , u ) NEW_LINE componentMin = min ( componentMin , u ) NEW_LINE for i in range ( len ( adj [ u ] ) ) : NEW_LINE INDENT if ( visited [ adj [ u ] [ i ] ] == False ) : NEW_LINE INDENT visited , componentMax , componentMin = DFSUtil ( adj [ u ] [ i ] , adj , visited , componentMin , componentMax ) NEW_LINE DEDENT DEDENT return visited , componentMax , componentMin NEW_LINE DEDENT
def isValid ( v ) : NEW_LINE INDENT MAX = - 1 NEW_LINE ans = False NEW_LINE for i in v : NEW_LINE INDENT if len ( i ) != 2 : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i [ 0 ] <= MAX ) : NEW_LINE INDENT ans = True NEW_LINE DEDENT MAX = max ( MAX , i [ 1 ] ) NEW_LINE DEDENT return ( True if ans == False else False ) NEW_LINE DEDENT
def DFS ( adj , V ) : NEW_LINE INDENT v = [ [ ] ] NEW_LINE visited = [ False for i in range ( V + 1 ) ] NEW_LINE for u in range ( 1 , V + 1 ) : NEW_LINE INDENT if ( visited [ u ] == False ) : NEW_LINE INDENT componentMax = u NEW_LINE componentMin = u NEW_LINE visited , componentMax , componentMin = DFSUtil ( u , adj , visited , componentMin , componentMax ) NEW_LINE v . append ( [ componentMin , componentMax ] ) NEW_LINE DEDENT DEDENT check = isValid ( v ) NEW_LINE if ( check ) : NEW_LINE INDENT print ( 'Yes' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 'No' ) NEW_LINE DEDENT return NEW_LINE DEDENT
def checkEqual ( arr , N ) : NEW_LINE INDENT hash = [ 0 ] * 256 NEW_LINE M = len ( arr [ 0 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT hash [ ord ( arr [ i ] [ j ] ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 256 ) : NEW_LINE INDENT if ( hash [ i ] % N != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def print_substring ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE str = "" NEW_LINE ans = [ ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT last_pos = [ - 1 ] * 26 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( last_pos [ ord ( s [ i ] ) - ord ( 'a' ) ] == - 1 ) : NEW_LINE INDENT last_pos [ ord ( s [ i ] ) - ord ( 'a' ) ] = i NEW_LINE DEDENT DEDENT minp = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lp = last_pos [ ord ( s [ i ] ) - ord ( 'a' ) ] NEW_LINE minp = max ( minp , lp ) NEW_LINE if ( i == minp ) : NEW_LINE INDENT str += s [ i ] NEW_LINE print ( str , end = " " ) NEW_LINE minp = - 1 NEW_LINE str = "" NEW_LINE DEDENT else : NEW_LINE INDENT str += s [ i ] NEW_LINE DEDENT DEDENT DEDENT
def partitionString ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = [ ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT last_pos = [ - 1 ] * 26 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( last_pos [ ord ( s [ i ] ) - ord ( 'a' ) ] == - 1 ) : NEW_LINE INDENT last_pos [ ord ( s [ i ] ) - ord ( 'a' ) ] = i NEW_LINE DEDENT DEDENT minp = - 1 NEW_LINE plen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lp = last_pos [ ord ( s [ i ] ) - ord ( 'a' ) ] NEW_LINE minp = max ( minp , lp ) NEW_LINE plen += 1 NEW_LINE if ( i == minp ) : NEW_LINE INDENT ans . append ( plen ) NEW_LINE minp = - 1 NEW_LINE plen = 0 NEW_LINE DEDENT DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def lenghtOfLongestAP ( A , n ) : NEW_LINE INDENT dp = { } NEW_LINE res = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d = A [ j ] - A [ i ] NEW_LINE if d in dp : NEW_LINE INDENT if i in dp [ d ] : NEW_LINE INDENT dp [ d ] [ j ] = dp [ d ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ d ] [ j ] = 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ d ] = { } NEW_LINE dp [ d ] [ j ] = 2 NEW_LINE DEDENT if d in dp : NEW_LINE INDENT if j in dp [ d ] : NEW_LINE INDENT res = max ( res , dp [ d ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def numDifferenceUtil ( N , K ) : NEW_LINE INDENT res = [ ] NEW_LINE res = numDifference ( N , K ) NEW_LINE for i in range ( 1 , len ( res ) ) : NEW_LINE INDENT print ( res [ i ] + 40 , end = " " ) NEW_LINE break NEW_LINE DEDENT DEDENT
def minFirstTerm ( X , diff , N ) : NEW_LINE INDENT first_term_1 = sys . maxsize NEW_LINE low = 0 NEW_LINE high = N NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( X - mid * diff > 0 ) : NEW_LINE INDENT first_term_1 = X - mid * diff NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return first_term_1 NEW_LINE DEDENT
def isCubeSum ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( pow ( n , 1 / 3 ) ) + 1 ) : NEW_LINE INDENT if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def isSumCube ( N ) : NEW_LINE INDENT a = int ( pow ( N , 1 / 3 ) ) NEW_LINE b = a - 1 NEW_LINE ans = ( ( a * a * a + b * b * b ) == N ) NEW_LINE return ans NEW_LINE DEDENT
def maxweight ( s , e , pre ) : NEW_LINE INDENT if s == e : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( s , e ) : NEW_LINE INDENT left = pre [ i ] - pre [ s - 1 ] NEW_LINE right = pre [ e ] - pre [ i ] NEW_LINE if left < right : NEW_LINE INDENT ans = max ( ans , left + maxweight ( s , i , pre ) ) NEW_LINE DEDENT if left == right : NEW_LINE INDENT ans = max ( ans , left + maxweight ( s , i , pre ) , right + maxweight ( i + 1 , e , pre ) ) NEW_LINE DEDENT if left > right : NEW_LINE INDENT ans = max ( ans , right + maxweight ( i + 1 , e , pre ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maxSum ( arr ) : NEW_LINE INDENT pre = { - 1 : 0 , 0 : arr [ 0 ] } NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + arr [ i ] NEW_LINE DEDENT print ( maxweight ( 0 , len ( arr ) - 1 , pre ) ) NEW_LINE DEDENT
def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE p += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def LISPrime ( arr , n ) : NEW_LINE INDENT lisp = [ 0 ] * n NEW_LINE prime = [ True ] * ( N + 1 ) NEW_LINE SieveOfEratosthenes ( prime , N ) NEW_LINE if prime [ arr [ 0 ] ] : NEW_LINE INDENT lisp [ 0 ] = 1 NEW_LINE else : lisp [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( not prime [ arr [ i ] ] ) : NEW_LINE INDENT lisp [ i ] = 0 NEW_LINE DEDENT continue NEW_LINE lisp [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( prime [ arr [ j ] ] and arr [ i ] > arr [ j ] and lisp [ i ] < lisp [ j ] + 1 ) : NEW_LINE INDENT lisp [ i ] = lisp [ j ] + 1 NEW_LINE DEDENT return max ( lisp ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def checkSumOfNatural ( n ) : NEW_LINE INDENT i = 1 NEW_LINE flag = False NEW_LINE while i * ( i + 1 ) < n * 2 : NEW_LINE INDENT X = i * ( i + 1 ) NEW_LINE t = n * 2 - X NEW_LINE k = int ( math . sqrt ( t ) ) NEW_LINE if k * ( k + 1 ) == t : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if flag : NEW_LINE INDENT print ( 'YES' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 'NO' ) NEW_LINE DEDENT DEDENT
def countNumEnds ( A , L , R ) : NEW_LINE INDENT count = 0 NEW_LINE digits = int ( log10 ( A ) + 1 ) NEW_LINE temp = int ( pow ( 10 , digits ) ) NEW_LINE cycle = temp NEW_LINE while ( temp <= R ) : NEW_LINE INDENT if ( temp >= L ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT temp += cycle NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def minOperations ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE result = 0 NEW_LINE for i in range ( length // 2 ) : NEW_LINE INDENT D1 = ( ord ( max ( s [ i ] , s [ length - 1 - i ] ) ) - ord ( min ( s [ i ] , s [ length - 1 - i ] ) ) ) NEW_LINE D2 = 26 - D1 NEW_LINE result += min ( D1 , D2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def countMaximum ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE count = 0 NEW_LINE mark = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] + n >= mark ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT mark = max ( mark , a [ i ] + i + 1 ) NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def allCoprime ( A , n ) : NEW_LINE INDENT all_coprime = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if gcd ( A [ i ] , A [ j ] ) != 1 : NEW_LINE INDENT all_coprime = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return all_coprime NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res // ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return c // ( n + 1 ) NEW_LINE DEDENT
def findWays ( n ) : NEW_LINE INDENT if ( ( n & 1 ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return catalan ( n // 2 ) NEW_LINE DEDENT
def countNonNPeriodic ( N ) : NEW_LINE INDENT print ( findWays ( 2 * N ) - findWays ( N ) ) NEW_LINE DEDENT
def isValid ( n , m , k ) : NEW_LINE INDENT step2 = n - m NEW_LINE cnt = ( step2 * ( step2 + 1 ) ) // 2 NEW_LINE if ( cnt - m == k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( cnt - m > k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def countOfOperations ( n , k ) : NEW_LINE INDENT start = 0 NEW_LINE end = n NEW_LINE ok = 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE temp = isValid ( n , mid , k ) NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT ok = 0 NEW_LINE print ( mid ) NEW_LINE break NEW_LINE DEDENT elif ( temp == 1 ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT if ( ok ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def nonLower ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if not s [ i ] . islower ( ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def getChar ( n ) : NEW_LINE INDENT return chr ( n + 96 ) NEW_LINE DEDENT
def getCode ( str ) : NEW_LINE INDENT if ( len ( str ) == 0 ) : NEW_LINE INDENT ans = [ "" ] NEW_LINE return ans NEW_LINE DEDENT output1 = getCode ( str [ 1 : ] ) NEW_LINE output2 = [ ] NEW_LINE firstDigit = ( ord ( str [ 0 ] ) - ord ( '0' ) ) NEW_LINE firstTwoDigit = 0 NEW_LINE if ( len ( str ) >= 2 ) : NEW_LINE INDENT firstTwoDigit = ( ( ord ( str [ 0 ] ) - ord ( '0' ) ) * 10 + ( ord ( str [ 1 ] ) - ord ( '0' ) ) ) NEW_LINE DEDENT if ( firstTwoDigit >= 10 and firstTwoDigit <= 26 ) : NEW_LINE INDENT output2 = getCode ( str [ 2 : ] ) NEW_LINE DEDENT output = [ '' for i in range ( len ( output1 ) + len ( output2 ) ) ] NEW_LINE k = 0 NEW_LINE for i in range ( len ( output1 ) ) : NEW_LINE INDENT ch = getChar ( firstDigit ) NEW_LINE output [ i ] = ch + output1 [ i ] NEW_LINE k += 1 NEW_LINE DEDENT for i in range ( len ( output2 ) ) : NEW_LINE INDENT ch = getChar ( firstTwoDigit ) NEW_LINE output [ k ] = ch + output2 [ i ] NEW_LINE k += 1 NEW_LINE DEDENT return output NEW_LINE DEDENT
def smallestNum ( n ) : NEW_LINE INDENT power = log2 ( 10 ) NEW_LINE print ( power ) NEW_LINE return ceil ( ( n - 1 ) * power ) NEW_LINE DEDENT
def countSubSequence ( arr , n ) : NEW_LINE INDENT maximum = max ( arr ) NEW_LINE minimum = min ( arr ) NEW_LINE if maximum == minimum : NEW_LINE INDENT return pow ( 2 , n ) - 1 NEW_LINE DEDENT i = arr . count ( maximum ) NEW_LINE j = arr . count ( minimum ) NEW_LINE res = ( pow ( 2 , i ) - 1 ) * ( pow ( 2 , j ) - 1 ) * pow ( 2 , n - i - j ) NEW_LINE return res NEW_LINE DEDENT
def transformSubsequence ( n , m , A , B ) : NEW_LINE INDENT if B is None or len ( B ) == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT dp = [ [ 0 for col in range ( m + 1 ) ] for row in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT elif A [ i - 1 ] == B [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return n - dp [ n ] [ m ] NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT global isPrime NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT DEDENT
def prime_search ( primes , diff ) : NEW_LINE INDENT low = 0 NEW_LINE high = len ( primes ) - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( primes [ mid ] == diff ) : NEW_LINE INDENT return primes [ mid ] NEW_LINE DEDENT elif ( primes [ mid ] < diff ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT res = primes [ mid ] NEW_LINE high = mid - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def minCost ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT diff = arr [ i - 1 ] - arr [ i ] NEW_LINE closest_prime = prime_search ( primes , diff ) NEW_LINE res += closest_prime NEW_LINE arr [ i ] += closest_prime NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def isprm ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def countprime ( n ) : NEW_LINE INDENT count = 0 NEW_LINE primevector = [ ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isprm ( i ) == 1 ) : NEW_LINE INDENT primevector . append ( i ) NEW_LINE DEDENT DEDENT sum = primevector [ 0 ] NEW_LINE for i in range ( 1 , len ( primevector ) ) : NEW_LINE INDENT sum += primevector [ i ] NEW_LINE if ( sum > n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( isprm ( sum ) == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def addEdge ( v , x , y ) : NEW_LINE INDENT v [ x ] . append ( y ) NEW_LINE v [ y ] . append ( x ) NEW_LINE DEDENT
def dfs ( tree , temp , ancestor , u , parent , k ) : NEW_LINE INDENT temp . append ( u ) NEW_LINE for i in tree [ u ] : NEW_LINE INDENT if ( i == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( tree , temp , ancestor , i , u , k ) NEW_LINE DEDENT temp . pop ( ) NEW_LINE if ( len ( temp ) < k ) : NEW_LINE INDENT ancestor [ u ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ancestor [ u ] = temp [ len ( temp ) - k ] NEW_LINE DEDENT DEDENT
def KthAncestor ( N , K , E , edges ) : NEW_LINE INDENT tree = [ [ ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( E ) : NEW_LINE INDENT addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) NEW_LINE DEDENT temp = [ ] NEW_LINE ancestor = [ 0 ] * ( N + 1 ) NEW_LINE dfs ( tree , temp , ancestor , 1 , 0 , K ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( ancestor [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def dfs ( root , distance ) : NEW_LINE INDENT global result NEW_LINE if ( root == None ) : NEW_LINE INDENT res = [ 0 for i in range ( distance + 1 ) ] NEW_LINE return res NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT res = [ 0 for i in range ( distance + 1 ) ] NEW_LINE res [ 1 ] += 1 NEW_LINE return res NEW_LINE DEDENT left = dfs ( root . left , distance ) NEW_LINE right = dfs ( root . right , distance ) NEW_LINE res = [ 0 for i in range ( distance + 1 ) ] NEW_LINE i = len ( res ) - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT res [ i + 1 ] = left [ i ] + right [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT for l in range ( 1 , len ( left ) ) : NEW_LINE INDENT for r in range ( len ( right ) ) : NEW_LINE INDENT if ( l + r <= distance ) : NEW_LINE INDENT result += left [ l ] * right [ r ] NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def build ( sum , a , l , r , rt ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT sum [ rt ] = a [ l - 1 ] NEW_LINE return NEW_LINE DEDENT m = ( l + r ) >> 1 NEW_LINE build ( sum , a , l , m , rt << 1 ) NEW_LINE build ( sum , a , m + 1 , r , rt << 1 1 ) NEW_LINE DEDENT
def pushDown ( sum , add , rt , ln , rn ) : NEW_LINE INDENT if ( add [ rt ] ) : NEW_LINE INDENT add [ rt << 1 ] += add [ rt ] NEW_LINE add [ rt << 1 1 ] += add [ rt ] NEW_LINE sum [ rt << 1 ] += add [ rt ] * ln NEW_LINE sum [ rt << 1 1 ] += add [ rt ] * rn NEW_LINE add [ rt ] = 0 NEW_LINE DEDENT DEDENT
def update ( sum , add , L , R , C , l , r , rt ) : NEW_LINE INDENT if ( L <= l and r <= R ) : NEW_LINE INDENT sum [ rt ] += C * ( r - l + 1 ) NEW_LINE add [ rt ] += C NEW_LINE return NEW_LINE DEDENT m = ( l + r ) >> 1 NEW_LINE pushDown ( sum , add , rt , m - l + 1 , r - m ) NEW_LINE if ( L <= m ) : NEW_LINE INDENT update ( sum , add , L , R , C , l , m , rt << 1 ) NEW_LINE DEDENT if ( R > m ) : NEW_LINE INDENT update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) NEW_LINE DEDENT DEDENT
def sequenceMaintenance ( n , q , a , b , m ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE sum = [ 0 ] * ( 4 * n ) NEW_LINE add = [ 0 ] * ( 4 * n ) NEW_LINE ans = [ ] NEW_LINE build ( sum , a , 1 , n , 1 ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l = 1 NEW_LINE r = n NEW_LINE pos = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) >> 1 NEW_LINE if ( queryy ( sum , add , m , m , 1 , n , 1 ) >= b [ i ] ) : NEW_LINE INDENT r = m - 1 NEW_LINE pos = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( pos == - 1 ) : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( n - pos + 1 ) NEW_LINE update ( sum , add , pos , n , - m , 1 , n , 1 ) NEW_LINE DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def MaximumPath ( grid ) : NEW_LINE INDENT N = len ( grid ) NEW_LINE M = len ( grid [ 0 ] ) NEW_LINE sum = [ [ 0 for i in range ( M + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT sum [ i ] [ j ] = ( max ( sum [ i - 1 ] [ j ] , sum [ i ] [ j - 1 ] ) + grid [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return sum [ N ] [ M ] NEW_LINE DEDENT
def SubarrayHavingPerfectSquare ( arr , k ) : NEW_LINE INDENT ans = [ 0 , 0 ] NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE while i < k : NEW_LINE INDENT sum += arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT found = False NEW_LINE if ( isPerfectSquare ( sum ) ) : NEW_LINE INDENT ans [ 0 ] = 0 NEW_LINE ans [ 1 ] = i - 1 NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( i , len ( arr ) ) : NEW_LINE INDENT sum = sum + arr [ j ] - arr [ j - k ] NEW_LINE if ( isPerfectSquare ( sum ) ) : NEW_LINE INDENT found = True NEW_LINE ans [ 0 ] = j - k + 1 NEW_LINE ans [ 1 ] = j NEW_LINE DEDENT DEDENT for k in range ( ans [ 0 ] , ans [ 1 ] + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " " ) NEW_LINE DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def calcSubarray ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT flag = True NEW_LINE comm_diff = A [ i + 1 ] - A [ i ] NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT if ( A [ k + 1 ] - A [ k ] == comm_diff ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findKthChar ( n , k ) : NEW_LINE INDENT prev = "A" NEW_LINE cur = "" NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 'A' NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT cur = prev + "B" NEW_LINE temp1 = [ y for y in prev ] NEW_LINE for i in range ( len ( prev ) ) : NEW_LINE INDENT if ( temp1 [ i ] == 'A' ) : NEW_LINE INDENT temp1 [ i ] = 'B' NEW_LINE DEDENT else : NEW_LINE INDENT temp1 [ i ] = 'A' NEW_LINE DEDENT DEDENT temp1 = temp1 [ : : - 1 ] NEW_LINE prev = "" . join ( temp1 ) NEW_LINE cur += prev NEW_LINE prev = cur NEW_LINE DEDENT return cur [ k - 1 ] NEW_LINE DEDENT
def areAnagrams ( a , b ) : NEW_LINE INDENT freqA = [ 0 ] * ( TEN ) NEW_LINE freqB = [ 0 ] * ( TEN ) NEW_LINE updateFreq ( a , freqA ) NEW_LINE updateFreq ( b , freqB ) NEW_LINE for i in range ( TEN ) : NEW_LINE INDENT if ( freqA [ i ] != freqB [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isPowerOf2 ( N ) : NEW_LINE INDENT for i in range ( 32 ) : NEW_LINE INDENT if ( areAnagrams ( 1 << i , N ) ) : NEW_LINE INDENT print ( 1 << i ) NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def right_angled ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for z in range ( 1 , n + 1 ) : NEW_LINE INDENT for y in range ( 1 , z + 1 ) : NEW_LINE INDENT for x in range ( 1 , y + 1 ) : NEW_LINE INDENT if ( ( x * x ) + ( y * y ) == ( z * z ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def mirrorMatrix ( mat1 , mat2 , N ) : NEW_LINE INDENT row = 0 NEW_LINE col = 0 NEW_LINE isMirrorImage = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat2 [ row ] [ col ] != mat1 [ i ] [ j ] ) : NEW_LINE INDENT isMirrorImage = False NEW_LINE DEDENT col += 1 NEW_LINE DEDENT col = 0 NEW_LINE row += 1 NEW_LINE DEDENT if ( isMirrorImage ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def maxAbsDiffLevelSum ( N , M , cost , Edges ) : NEW_LINE INDENT adj = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT u = Edges [ i ] [ 0 ] NEW_LINE v = Edges [ i ] [ 1 ] NEW_LINE adj [ u ] . append ( v ) NEW_LINE DEDENT maxSum = cost [ 0 ] NEW_LINE minSum = cost [ 0 ] NEW_LINE q = deque ( ) NEW_LINE q . append ( 0 ) NEW_LINE while len ( q ) > 0 : NEW_LINE INDENT count = len ( q ) NEW_LINE sum = 0 NEW_LINE while ( count ) : NEW_LINE INDENT temp = q . popleft ( ) NEW_LINE q . pop ( ) NEW_LINE sum = sum + cost [ temp ] NEW_LINE for i in adj [ temp ] : NEW_LINE INDENT q . append ( i ) NEW_LINE DEDENT count -= 1 NEW_LINE DEDENT maxSum = max ( sum , maxSum ) NEW_LINE minSum = min ( sum , minSum ) NEW_LINE DEDENT print ( abs ( maxSum - minSum ) ) NEW_LINE DEDENT
def dfs ( src , dest , vis , adj ) : NEW_LINE INDENT vis [ src ] = 1 NEW_LINE if ( src == dest ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for u in adj [ src ] : NEW_LINE INDENT if not vis [ u ] : NEW_LINE INDENT temp = dfs ( u , dest , vis , adj ) NEW_LINE if ( temp != 0 ) : NEW_LINE INDENT return temp + 1 NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT
def countMagicNumbers ( idx , sum , a , n , m , l , r ) : NEW_LINE INDENT if ( idx == n ) : NEW_LINE INDENT temp = sum % m NEW_LINE if ( temp == l or temp == r or ( temp > l and temp < r ) ) : NEW_LINE INDENT dp [ ( idx , sum ) ] = 1 NEW_LINE return dp [ ( idx , sum ) ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ( idx , sum ) ] = 0 NEW_LINE return dp [ ( idx , sum ) ] NEW_LINE DEDENT DEDENT curr = ( idx , sum ) NEW_LINE if ( curr in dp ) : NEW_LINE INDENT return dp [ curr ] NEW_LINE DEDENT ls = countMagicNumbers ( idx + 1 , sum + a [ idx ] , a , n , m , l , r ) NEW_LINE rs = countMagicNumbers ( idx + 1 , sum + ( a [ idx ] - 1 ) , a , n , m , l , r ) NEW_LINE temp1 = max ( ls , rs ) NEW_LINE temp = sum % m NEW_LINE if ( ( temp == l or temp == r or ( temp > l and temp < r ) ) and idx != 0 ) : NEW_LINE INDENT temp1 += 1 NEW_LINE DEDENT dp [ ( idx , sum ) ] = temp1 NEW_LINE return dp [ ( idx , sum ) ] NEW_LINE DEDENT
def count_numbers ( L , R ) : NEW_LINE INDENT ans = 0 NEW_LINE for n in range ( L , R + 1 ) : NEW_LINE INDENT no_of_bits = int ( log2 ( n ) + 1 ) NEW_LINE no_of_set_bits = bin ( n ) . count ( '1' ) NEW_LINE if ( no_of_bits - no_of_set_bits == 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def check ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT for j in range ( i , n , k ) : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT c = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT DEDENT if ( c == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def findSum ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT sum += ( j - i ) NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def countElements ( a , n ) : NEW_LINE INDENT cnt = [ 0 ] * ( n + 1 ) NEW_LINE ans = 0 NEW_LINE for k in a : NEW_LINE INDENT cnt [ k ] += 1 NEW_LINE DEDENT for l in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for r in range ( l , n ) : NEW_LINE INDENT sum += a [ r ] NEW_LINE if ( l == r ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( sum <= n ) : NEW_LINE INDENT ans += cnt [ sum ] NEW_LINE cnt [ sum ] = 0 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def maxGCD ( n ) : NEW_LINE INDENT maxHcf = - 2391734235435 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT maxHcf = max ( maxHcf , __gcd ( i , j ) ) NEW_LINE DEDENT DEDENT return maxHcf NEW_LINE DEDENT
def addEdge ( a , b ) : NEW_LINE INDENT global tree NEW_LINE tree [ a ] . append ( b ) NEW_LINE tree [ b ] . append ( a ) NEW_LINE DEDENT
def dfs ( x ) : NEW_LINE INDENT global vis NEW_LINE global subtreeSize NEW_LINE global tree NEW_LINE vis [ x ] = True NEW_LINE subtreeSize [ x ] = 1 NEW_LINE for i in tree [ x ] : NEW_LINE INDENT if ( vis [ i ] == False ) : NEW_LINE INDENT dfs ( i ) NEW_LINE subtreeSize [ x ] += subtreeSize [ i ] NEW_LINE DEDENT DEDENT DEDENT
def matrixMinimum ( nums , K ) : NEW_LINE INDENT N = len ( nums ) NEW_LINE M = len ( nums [ 0 ] ) NEW_LINE res = [ [ 0 for x in range ( M - K + 1 ) ] for y in range ( N - K + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M - K + 1 ) : NEW_LINE INDENT mn = sys . maxsize NEW_LINE for k in range ( j , j + K ) : NEW_LINE INDENT mn = min ( mn , nums [ i ] [ k ] ) NEW_LINE DEDENT nums [ i ] [ j ] = mn NEW_LINE DEDENT DEDENT for j in range ( M ) : NEW_LINE INDENT for i in range ( N - K + 1 ) : NEW_LINE INDENT mn = sys . maxsize NEW_LINE for k in range ( i , i + K ) : NEW_LINE INDENT mn = min ( mn , nums [ k ] [ j ] ) NEW_LINE DEDENT nums [ i ] [ j ] = mn NEW_LINE DEDENT DEDENT for i in range ( N - K + 1 ) : NEW_LINE INDENT for j in range ( M - K + 1 ) : NEW_LINE INDENT res [ i ] [ j ] = nums [ i ] [ j ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def uncrossedLines ( a , b , n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
def find_kth_largest ( strr , k ) : NEW_LINE INDENT strr = sorted ( strr ) NEW_LINE strr = strr [ : : - 1 ] NEW_LINE return strr [ k - 1 ] NEW_LINE DEDENT
def updateString ( strr , pos , s ) : NEW_LINE INDENT index = pos - 1 NEW_LINE c = s NEW_LINE strr [ index ] = c NEW_LINE DEDENT
def update_BITree ( index , C , val ) : NEW_LINE INDENT while ( index <= N ) : NEW_LINE INDENT BITree [ ord ( C ) - ord ( 'a' ) ] [ index ] += val NEW_LINE index += ( index & - index ) NEW_LINE DEDENT DEDENT
def sum_BITree ( index , C ) : NEW_LINE INDENT s = 0 NEW_LINE while ( index ) : NEW_LINE INDENT s += BITree [ ord ( C ) - ord ( 'a' ) ] [ index ] NEW_LINE index -= ( index & - index ) NEW_LINE DEDENT return s NEW_LINE DEDENT
def revNum ( N ) : NEW_LINE INDENT x = 0 NEW_LINE while ( N ) : NEW_LINE INDENT x = x * 10 + N % 10 NEW_LINE N = N // 10 NEW_LINE DEDENT return x NEW_LINE DEDENT
def ctNonPalin ( arr , N ) : NEW_LINE INDENT Res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = revNum ( arr [ i ] ) NEW_LINE if ( x == arr [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT Res += ( arr [ i ] % 10 == N % 10 ) NEW_LINE DEDENT DEDENT return Res NEW_LINE DEDENT
def smallSumSubset ( data , target , maxVal ) : NEW_LINE INDENT if target <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif sum ( data ) < target : NEW_LINE INDENT return maxVal NEW_LINE DEDENT elif sum ( data ) == target : NEW_LINE INDENT return len ( data ) NEW_LINE DEDENT elif data [ 0 ] >= target : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif data [ 0 ] < target : NEW_LINE INDENT return min ( smallSumSubset ( data [ 1 : ] , target , maxVal ) , 1 + smallSumSubset ( data [ 1 : ] , target - data [ 0 ] , maxVal ) ) NEW_LINE DEDENT DEDENT
def minlt ( arr , target , n ) : NEW_LINE INDENT dp = [ [ - 1 for _ in range ( target + 1 ) ] for _ in range ( len ( arr ) + 1 ) ] NEW_LINE for i in range ( len ( arr ) + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( target + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = sys . maxsize NEW_LINE DEDENT for i in range ( 1 , len ( arr ) + 1 ) : NEW_LINE INDENT for j in range ( 1 , target + 1 ) : NEW_LINE INDENT if arr [ i - 1 ] > j : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , 1 + dp [ i ] [ j - arr [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ - 1 ] [ - 1 ] NEW_LINE if dp [ - 1 ] [ - 1 ] == sys . maxsize : NEW_LINE INDENT return ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ - 1 ] [ - 1 ] NEW_LINE DEDENT DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return GCD ( b % a , a ) NEW_LINE DEDENT
def LCM ( a , b ) : NEW_LINE INDENT return ( a * b ) // GCD ( a , b ) NEW_LINE DEDENT
def checkPairwiseCoPrime ( A , n ) : NEW_LINE INDENT prod = 1 NEW_LINE lcm = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod *= A [ i ] NEW_LINE lcm = LCM ( A [ i ] , lcm ) NEW_LINE DEDENT if ( prod == lcm ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def minDiffSubArray ( arr , n ) : NEW_LINE INDENT prefix_sum = [ 0 ] * n NEW_LINE prefix_sum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum [ i ] = ( prefix_sum [ i - 1 ] + arr [ i ] ) NEW_LINE DEDENT suffix_sum = [ 0 ] * n NEW_LINE suffix_sum [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffix_sum [ i ] = ( suffix_sum [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT minDiff = sys . maxsize NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( prefix_sum [ i ] - suffix_sum [ i + 1 ] ) NEW_LINE if ( diff < minDiff ) : NEW_LINE INDENT minDiff = diff NEW_LINE DEDENT DEDENT return minDiff NEW_LINE DEDENT
def minDiffSubArray ( arr , n ) : NEW_LINE INDENT total_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT total_sum += arr [ i ] NEW_LINE DEDENT prefix_sum = 0 NEW_LINE minDiff = sys . maxsize NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT prefix_sum += arr [ i ] NEW_LINE diff = abs ( ( total_sum - prefix_sum ) - prefix_sum ) NEW_LINE if ( diff < minDiff ) : NEW_LINE INDENT minDiff = diff NEW_LINE DEDENT DEDENT return minDiff NEW_LINE DEDENT
def maxLenSub ( arr , N ) : NEW_LINE INDENT Pos = 0 NEW_LINE Neg = 0 NEW_LINE res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT Pos = Neg = 0 NEW_LINE DEDENT elif ( arr [ i ] > 0 ) : NEW_LINE INDENT Pos += 1 NEW_LINE if ( Neg != 0 ) : NEW_LINE INDENT Neg += 1 NEW_LINE DEDENT res = max ( res , Pos ) NEW_LINE DEDENT else : NEW_LINE INDENT Pos , Neg = Neg , Pos NEW_LINE Neg += 1 NEW_LINE if ( Pos != 0 ) : NEW_LINE INDENT Pos += 1 NEW_LINE DEDENT res = max ( res , Pos ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def maxStrings ( arr , lenn ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE ans = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( lenn == len ( arr [ i ] ) ) : NEW_LINE INDENT ans . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def printStrings ( arr ) : NEW_LINE INDENT max = maxLength ( arr ) NEW_LINE maxStrings ( arr , max ) NEW_LINE DEDENT
def addEdge ( u , v ) : NEW_LINE INDENT vec [ u ] . append ( v ) NEW_LINE vec [ v ] . append ( u ) NEW_LINE DEDENT
def swapXandY ( str , X , Y ) : N = len ( str ) NEW_LINE X , Y = Y , X NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( str [ i ] == 'p' ) : NEW_LINE INDENT str [ i ] = 'r' NEW_LINE DEDENT DEDENT elif ( str [ i ] == 'r' ) : NEW_LINE INDENT str [ i ] = 'p' NEW_LINE DEDENT
def canTransform ( str1 , str2 ) : NEW_LINE INDENT s1 = "" NEW_LINE s2 = "" NEW_LINE for c in str1 : NEW_LINE INDENT if ( c != 'C' ) : NEW_LINE INDENT s1 += c NEW_LINE DEDENT DEDENT for c in str2 : NEW_LINE INDENT if ( c != 'C' ) : NEW_LINE INDENT s2 += c NEW_LINE DEDENT DEDENT if ( s1 != s2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE n = len ( str1 ) NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( str1 [ i ] == 'C' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( str2 [ j ] == 'C' ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( str1 [ i ] == 'A' and i < j ) or ( str1 [ i ] == 'B' and i > j ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def dailyTemperatures ( T ) : NEW_LINE INDENT n = len ( T ) NEW_LINE daysOfWait = [ - 1 ] * n NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( s ) != 0 and T [ s [ - 1 ] ] < T [ i ] ) : NEW_LINE INDENT daysOfWait [ s [ - 1 ] ] = i - s [ - 1 ] NEW_LINE s . pop ( - 1 ) NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( daysOfWait [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def CtSubarr ( arr , N , K ) : NEW_LINE INDENT st = set ( ) NEW_LINE prefixSum = 0 NEW_LINE st . add ( prefixSum ) NEW_LINE res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT prefixSum += arr [ i ] NEW_LINE if ( ( prefixSum - K ) in st ) : NEW_LINE INDENT res += 1 NEW_LINE prefixSum = 0 NEW_LINE st . clear ( ) NEW_LINE st . add ( 0 ) NEW_LINE DEDENT st . add ( prefixSum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def getMaxLength ( arr , N ) : NEW_LINE INDENT res = 2 NEW_LINE dist = 2 NEW_LINE curradj = ( arr [ 1 ] - arr [ 0 ] ) NEW_LINE prevadj = ( arr [ 1 ] - arr [ 0 ] ) NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT curradj = arr [ i ] - arr [ i - 1 ] NEW_LINE if ( curradj == prevadj ) : NEW_LINE INDENT dist += 1 NEW_LINE DEDENT else : NEW_LINE INDENT prevadj = curradj NEW_LINE res = max ( res , dist ) NEW_LINE dist = 2 NEW_LINE DEDENT DEDENT res = max ( res , dist ) NEW_LINE return res NEW_LINE DEDENT
def func ( a , b , c , x ) : NEW_LINE INDENT return a * x * x + b * x + c NEW_LINE DEDENT
def findRoot ( a , b , c , low , high ) : NEW_LINE INDENT x = - 1 NEW_LINE while abs ( high - low ) > eps : NEW_LINE INDENT x = ( low + high ) / 2 NEW_LINE if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) : NEW_LINE INDENT high = x NEW_LINE DEDENT else : NEW_LINE INDENT low = x NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def minSteps ( str , N ) : NEW_LINE INDENT cost = 0 NEW_LINE f = [ 0 ] * 26 NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr_ele = ord ( str [ i ] ) - ord ( 'a' ) NEW_LINE smaller = 0 NEW_LINE for j in range ( curr_ele + 1 ) : NEW_LINE INDENT if ( f [ j ] ) : NEW_LINE INDENT smaller += f [ j ] NEW_LINE DEDENT DEDENT if ( smaller == 0 ) : NEW_LINE INDENT cost += ( i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT cost += ( i - smaller + 1 ) NEW_LINE DEDENT f [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT return cost NEW_LINE DEDENT
def dfs ( u , p , dis , vis , distance , parent , preTime , postTime , Adj ) : NEW_LINE INDENT global timeT NEW_LINE distance [ u ] = dis NEW_LINE parent [ u ] = p NEW_LINE vis [ u ] = 1 NEW_LINE timeT += 1 NEW_LINE preTime [ u ] = timeT NEW_LINE for i in range ( len ( Adj [ u ] ) ) : NEW_LINE INDENT if ( vis [ Adj [ u ] [ i ] ] == 0 ) : NEW_LINE INDENT dfs ( Adj [ u ] [ i ] , u , dis + 1 , vis , distance , parent , preTime , postTime , Adj ) NEW_LINE DEDENT DEDENT timeT += 1 NEW_LINE postTime [ u ] = timeT NEW_LINE DEDENT
def addEdge ( Adj , u , v ) : NEW_LINE INDENT Adj [ u ] . append ( v ) NEW_LINE Adj [ v ] . append ( u ) NEW_LINE DEDENT
def findNodeU ( N , V , Vertices , Edges ) : NEW_LINE INDENT vis = [ 0 for i in range ( N + 1 ) ] NEW_LINE distance = [ 0 for i in range ( N + 1 ) ] NEW_LINE parent = [ 0 for i in range ( N + 1 ) ] NEW_LINE preTime = [ 0 for i in range ( N + 1 ) ] NEW_LINE postTime = [ 0 for i in range ( N + 1 ) ] NEW_LINE Adj = [ [ ] for i in range ( N + 1 ) ] NEW_LINE u = 0 NEW_LINE v = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT addEdge ( Adj , Edges [ i ] [ 0 ] , Edges [ i ] [ 1 ] ) NEW_LINE DEDENT dfs ( 1 , 0 , 0 , vis , distance , parent , preTime , postTime , Adj ) NEW_LINE maximumDistance = 0 NEW_LINE maximumDistance = 0 NEW_LINE for k in range ( V ) : NEW_LINE INDENT if ( maximumDistance < distance [ Vertices [ k ] ] ) : NEW_LINE INDENT maximumDistance = distance [ Vertices [ k ] ] NEW_LINE u = Vertices [ k ] NEW_LINE DEDENT if ( parent [ Vertices [ k ] ] != 0 ) : NEW_LINE INDENT Vertices [ k ] = parent [ Vertices [ k ] ] NEW_LINE DEDENT DEDENT ans = True NEW_LINE flag = False NEW_LINE for k in range ( V ) : NEW_LINE INDENT if ( preTime [ Vertices [ k ] ] <= preTime [ u ] and postTime [ Vertices [ k ] ] >= postTime [ u ] ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE DEDENT ans = ans & flag NEW_LINE DEDENT if ( ans ) : NEW_LINE INDENT print ( u ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 'No' ) NEW_LINE DEDENT DEDENT
def countRectangles ( a , b , K ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE subA = [ ] NEW_LINE subA = findSubarrays ( a ) NEW_LINE subB = [ ] NEW_LINE subB = findSubarrays ( b ) NEW_LINE total = 0 NEW_LINE for i in range ( 1 , len ( subA ) ) : NEW_LINE INDENT if ( K % i == 0 and ( K // i ) <= m ) : NEW_LINE INDENT total = total + subA [ i ] * subB [ K // i ] NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE DEDENT
def addedge ( a , b ) : NEW_LINE INDENT global edges NEW_LINE edges [ a ] . append ( b ) NEW_LINE edges [ b ] . append ( a ) NEW_LINE DEDENT
def findCost ( r , p , arr ) : NEW_LINE INDENT global edges NEW_LINE global ans NEW_LINE global allsum NEW_LINE i = 0 NEW_LINE for i in range ( len ( edges [ r ] ) ) : NEW_LINE INDENT cur = edges [ r ] [ i ] NEW_LINE if ( cur == p ) : NEW_LINE INDENT continue NEW_LINE DEDENT findCost ( cur , r , arr ) NEW_LINE arr [ r ] += arr [ cur ] NEW_LINE DEDENT t1 = arr [ r ] NEW_LINE t2 = allsum - t1 NEW_LINE if ( t1 * t2 > ans ) : NEW_LINE INDENT ans = t1 * t2 NEW_LINE DEDENT DEDENT
def maximumCost ( r , p , N , M , arr , Edges ) : NEW_LINE INDENT global allsum NEW_LINE for i in range ( N ) : NEW_LINE INDENT allsum += arr [ i ] NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT addedge ( Edges [ i ] [ 0 ] , Edges [ i ] [ 1 ] ) NEW_LINE DEDENT findCost ( r , p , arr ) NEW_LINE DEDENT
def printRes ( res ) : NEW_LINE INDENT n = len ( res ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( res [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def printLBS ( arr , N ) : NEW_LINE INDENT lis = [ 0 ] * N NEW_LINE lds = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT lis [ i ] = lds [ i ] = 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if arr [ j ] < arr [ i ] : NEW_LINE INDENT if lis [ i ] < lis [ j ] + 1 : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 1 , i , - 1 ) : NEW_LINE INDENT if arr [ j ] < arr [ i ] : NEW_LINE INDENT if lds [ i ] < lds [ j ] + 1 : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT MaxVal = arr [ 0 ] NEW_LINE inx = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if MaxVal < lis [ i ] + lds [ i ] - 1 : NEW_LINE INDENT MaxVal = lis [ i ] + lds [ i ] - 1 NEW_LINE inx = i NEW_LINE DEDENT DEDENT ct1 = lis [ inx ] NEW_LINE res = [ ] NEW_LINE i = inx NEW_LINE while i >= 0 and ct1 > 0 : NEW_LINE INDENT if lis [ i ] == ct1 : NEW_LINE INDENT res . append ( arr [ i ] ) NEW_LINE ct1 -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT res . reverse ( ) NEW_LINE ct2 = lds [ inx ] - 1 NEW_LINE i = inx NEW_LINE while i < N and ct2 > 0 : NEW_LINE INDENT if lds [ i ] == ct2 : NEW_LINE INDENT res . append ( arr [ i ] ) NEW_LINE ct2 -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT printRes ( res ) NEW_LINE DEDENT
def dfs ( current_node , prev_node , len , add_to_map , adj ) : NEW_LINE INDENT global diameter , X NEW_LINE if len > diameter : NEW_LINE INDENT diameter = len NEW_LINE X = current_node NEW_LINE DEDENT if add_to_map and len == diameter : NEW_LINE INDENT mp [ current_node ] = 1 NEW_LINE DEDENT for it in adj [ current_node ] : NEW_LINE INDENT if it != prev_node : NEW_LINE INDENT dfs ( it , current_node , len + 1 , add_to_map , adj ) NEW_LINE DEDENT DEDENT DEDENT
def dfsUtility ( adj ) : NEW_LINE INDENT dfs ( 1 , - 1 , 0 , 0 , adj ) NEW_LINE farthest_node = X NEW_LINE dfs ( farthest_node , - 1 , 0 , 0 , adj ) NEW_LINE dfs ( farthest_node , - 1 , 0 , 1 , adj ) NEW_LINE dfs ( X , - 1 , 0 , 1 , adj ) NEW_LINE DEDENT
def printDiameters ( adj ) : NEW_LINE INDENT global diameter NEW_LINE dfsUtility ( adj ) NEW_LINE for i in range ( 1 , 6 + 1 ) : NEW_LINE INDENT if mp [ i ] == 1 : NEW_LINE INDENT print ( diameter + 1 , end = ", " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( diameter , end = ", " ) NEW_LINE DEDENT DEDENT DEDENT
def is_prime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def count_prime_subarrays ( ar , n ) : NEW_LINE INDENT ans = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( is_prime ( ar [ i ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count ) : NEW_LINE INDENT ans += count * ( count + 1 ) // 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT DEDENT if ( count ) : NEW_LINE INDENT ans += count * ( count + 1 ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def hasCoprimePair ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( math . gcd ( arr [ i ] , arr [ j ] ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def check ( ans , s , n , m ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( ans [ j ] != s [ i ] [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def possible ( T , arr , n , d ) : NEW_LINE INDENT partition = 1 NEW_LINE total = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT total = total + arr [ i ] NEW_LINE if ( total > T ) : NEW_LINE INDENT partition = partition + 1 NEW_LINE total = arr [ i ] NEW_LINE if ( partition > d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def calcT ( n , d , arr ) : NEW_LINE INDENT mx = - 1 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , arr [ i ] ) NEW_LINE sum = sum + arr [ i ] NEW_LINE DEDENT lb = mx NEW_LINE ub = sum NEW_LINE while ( lb < ub ) : NEW_LINE INDENT T_mid = lb + ( ub - lb ) // 2 NEW_LINE if ( possible ( T_mid , arr , n , d ) == True ) : NEW_LINE INDENT ub = T_mid NEW_LINE DEDENT else : NEW_LINE INDENT lb = T_mid + 1 NEW_LINE DEDENT DEDENT print ( lb ) NEW_LINE DEDENT
def minReqSubstring ( s , n ) : NEW_LINE INDENT ongoing = 'N' NEW_LINE count , l = 0 , len ( s ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ongoing == 'N' : NEW_LINE INDENT if s [ i ] < s [ i - 1 ] : NEW_LINE INDENT ongoing = 'D' NEW_LINE DEDENT elif s [ i ] == s [ i - 1 ] : NEW_LINE INDENT ongoing = 'N' NEW_LINE DEDENT else : NEW_LINE INDENT ongoing = 'I' NEW_LINE DEDENT DEDENT elif ongoing == 'I' : NEW_LINE INDENT if s [ i ] > s [ i - 1 ] : NEW_LINE INDENT ongoing = 'I' NEW_LINE DEDENT elif s [ i ] == s [ i - 1 ] : NEW_LINE INDENT ongoing = 'I' NEW_LINE DEDENT else : NEW_LINE INDENT ongoing = 'N' NEW_LINE count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if s [ i ] < s [ i - 1 ] : NEW_LINE INDENT ongoing = 'D' NEW_LINE DEDENT elif s [ i ] == s [ i - 1 ] : NEW_LINE INDENT ongoing = 'D' NEW_LINE DEDENT else : NEW_LINE INDENT ongoing = 'N' NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT return count + 1 NEW_LINE DEDENT
def findPermutation ( arr , N ) : NEW_LINE INDENT pos = len ( arr ) + 1 NEW_LINE if ( pos > N ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i not in arr ) : NEW_LINE INDENT if ( i % pos == 0 or pos % i == 0 ) : NEW_LINE INDENT arr . add ( i ) NEW_LINE res += findPermutation ( arr , N ) NEW_LINE arr . remove ( i ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def minimum_required_operations ( arr , n , k ) : NEW_LINE INDENT answer = 0 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] + arr [ i + 1 ] > k : NEW_LINE INDENT if arr [ i ] > k : NEW_LINE INDENT answer += ( arr [ i ] - k ) NEW_LINE arr [ i ] = k NEW_LINE DEDENT answer += ( arr [ i ] + arr [ i + 1 ] ) - k NEW_LINE arr [ i + 1 ] = ( k - arr [ i ] ) NEW_LINE answer %= mod NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def minSteps ( arr , n , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE if ( k == 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == flag ) : NEW_LINE INDENT cnt += 1 NEW_LINE flag = ( flag + 1 ) % 2 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def solve ( arr , n , X , Y ) : NEW_LINE INDENT diff = Y - X NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 1 ) : NEW_LINE INDENT diff = diff % ( arr [ i ] - 1 ) NEW_LINE DEDENT DEDENT if ( diff == 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def minSum ( a , n , k ) : NEW_LINE INDENT
def determineWinner ( str ) : NEW_LINE INDENT A = [ 0 for i in range ( 9 ) ] NEW_LINE sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT A [ int ( str [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , 9 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT sum1 = sum1 + A [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum2 = sum2 + A [ i ] NEW_LINE DEDENT DEDENT if ( sum1 == sum2 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT elif ( sum1 > sum2 ) : NEW_LINE INDENT print ( "Player 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Player 2" ) NEW_LINE DEDENT DEDENT
def manipulateStrings ( P , Q ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( len ( P ) ) : NEW_LINE INDENT freq [ ord ( P [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( Q ) ) : NEW_LINE INDENT freq [ ord ( Q [ i ] ) - ord ( 'a' ) ] -= 1 NEW_LINE DEDENT sb = "" NEW_LINE pos = ord ( Q [ 0 ] ) - ord ( 'a' ) NEW_LINE for i in range ( pos + 1 ) : NEW_LINE INDENT while freq [ i ] > 0 : NEW_LINE INDENT sb += chr ( ord ( 'a' ) + i ) NEW_LINE freq [ i ] -= 1 NEW_LINE DEDENT DEDENT sb += Q NEW_LINE for i in range ( pos + 1 , 26 ) : NEW_LINE INDENT while freq [ i ] > 0 : NEW_LINE INDENT sb += chr ( ord ( 'a' ) + i ) NEW_LINE freq [ i ] -= 1 NEW_LINE DEDENT DEDENT print ( sb ) NEW_LINE DEDENT
def deleted ( seg , l , r , start , end , current ) : NEW_LINE INDENT if ( end < l or start > r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( start >= l and end <= r ) : NEW_LINE INDENT return seg [ current ] NEW_LINE DEDENT mid = int ( ( start + end ) / 2 ) NEW_LINE return deleted ( seg , l , r , start , mid , 2 * current + 1 ) + deleted ( seg , l , r , mid + 1 , end , 2 * current + 2 ) NEW_LINE DEDENT
def deleteNode ( nodeVal ) : NEW_LINE INDENT if nodeVal in mp : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def printInorderTree ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT printInorderTree ( root . left ) NEW_LINE print ( root . key , end = ' ' ) NEW_LINE printInorderTree ( root . right ) NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT for i in range ( 2 , 100005 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT i = 2 NEW_LINE while i * i < 100005 : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , 100005 , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def smallestPrimeFactors ( ) : NEW_LINE INDENT for i in range ( 10005 ) : NEW_LINE INDENT spf [ i ] = - 1 NEW_LINE DEDENT i = 2 NEW_LINE while i * i < 100005 : NEW_LINE INDENT for j in range ( i , 100005 , i ) : NEW_LINE INDENT if ( spf [ j ] == - 1 ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def sumOfPrimeFactors ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( n > 1 ) : NEW_LINE INDENT ans += spf [ n ] NEW_LINE n //= spf [ n ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findLength ( n ) : NEW_LINE INDENT if ( prime [ n ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ n ] ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT sum = sumOfPrimeFactors ( n ) NEW_LINE dp [ n ] = 1 + findLength ( sum ) NEW_LINE return dp [ n ] NEW_LINE DEDENT
def solve ( n , arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT left = max ( i - 1 , 0 ) NEW_LINE right = min ( n - 1 , i + 1 ) NEW_LINE while left >= 0 : NEW_LINE INDENT if arr [ left ] > arr [ i ] : NEW_LINE INDENT left += 1 NEW_LINE break NEW_LINE DEDENT left -= 1 NEW_LINE DEDENT if left < 0 : NEW_LINE INDENT left += 1 NEW_LINE DEDENT while right < n : NEW_LINE INDENT if arr [ right ] > arr [ i ] : NEW_LINE INDENT right -= 1 NEW_LINE break NEW_LINE DEDENT right += 1 NEW_LINE DEDENT if right >= n : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT ans = 1 + right - left NEW_LINE print ( ans , end = " " ) NEW_LINE DEDENT DEDENT
def countofPairs ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE freq = [ 0 ] * ( n + 1 ) NEW_LINE maxi = - 1 NEW_LINE mini = n + 1 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT maxi = max ( maxi , a [ i ] ) NEW_LINE mini = min ( mini , a [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT return maxCount ( freq , maxi , mini ) NEW_LINE DEDENT
def largest_subarray ( a , n ) : NEW_LINE INDENT index = defaultdict ( lambda : 0 ) NEW_LINE ans = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = max ( index [ a [ i ] ] , j ) NEW_LINE ans = max ( ans , i - j + 1 ) NEW_LINE index [ a [ i ] ] = i + 1 NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def getMaxSum ( a , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( 2 ) ] for y in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = a [ 0 ] NEW_LINE dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 0 ] NEW_LINE max_sum = max ( dp [ 0 ] [ 0 ] , dp [ 0 ] [ 1 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( a [ i ] , dp [ i - 1 ] [ 0 ] + a [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 1 ] + a [ i ] , a [ i ] * a [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 0 ] + a [ i ] * a [ i ] ) NEW_LINE max_sum = max ( max_sum , dp [ i ] [ 1 ] ) NEW_LINE max_sum = max ( max_sum , dp [ i ] [ 0 ] ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT
def getMid ( s , e ) : NEW_LINE INDENT return ( s + ( e - s ) // 2 ) NEW_LINE DEDENT
def MaxUtil ( st , ss , se , l , r , node ) : NEW_LINE INDENT if ( l <= ss and r >= se ) : NEW_LINE INDENT return st [ node ] NEW_LINE DEDENT if ( se < l or ss > r ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE return max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) NEW_LINE DEDENT
def constructSTUtil ( arr , ss , se , st , si ) : NEW_LINE INDENT if ( ss == se ) : NEW_LINE INDENT st [ si ] = arr [ ss ] NEW_LINE return arr [ ss ] NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE st [ si ] = max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) NEW_LINE return st [ si ] NEW_LINE DEDENT
def findPrevious ( a , n ) : NEW_LINE INDENT ps = [ 0 ] * n NEW_LINE ps [ 0 ] = - 1 NEW_LINE stack = [ ] NEW_LINE stack . append ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while len ( stack ) > 0 and a [ stack [ - 1 ] ] >= a [ i ] : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT ps [ i ] = stack [ - 1 ] if len ( stack ) > 0 else - 1 NEW_LINE stack . append ( i ) NEW_LINE DEDENT return ps NEW_LINE DEDENT
def findNext ( a , n ) : NEW_LINE INDENT ns = [ 0 ] * n NEW_LINE ns [ n - 1 ] = n NEW_LINE stack = [ ] NEW_LINE stack . append ( n - 1 ) NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT while ( len ( stack ) > 0 and a [ stack [ - 1 ] ] >= a [ i ] ) : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT ns [ i ] = stack [ - 1 ] if len ( stack ) > 0 else n NEW_LINE stack . append ( i ) NEW_LINE DEDENT return ns NEW_LINE DEDENT
def findMaximumSum ( a , n ) : NEW_LINE INDENT prev_smaller = findPrevious ( a , n ) NEW_LINE next_smaller = findNext ( a , n ) NEW_LINE max_value = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_value = max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) NEW_LINE DEDENT return max_value NEW_LINE DEDENT
def findCount ( arr , n ) : NEW_LINE INDENT prefix_sum = [ 0 for x in range ( n ) ] NEW_LINE prefix_sum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT suffix_sum = [ 0 for x in range ( n ) ] NEW_LINE suffix_sum [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] NEW_LINE DEDENT s = 1 NEW_LINE e = 1 NEW_LINE curr_subarray_sum = 0 NEW_LINE count = 0 NEW_LINE while ( s < n - 1 and e < n - 1 ) : NEW_LINE INDENT while ( e < n - 1 and curr_subarray_sum < prefix_sum [ s - 1 ] ) : NEW_LINE INDENT curr_subarray_sum += arr [ e ] NEW_LINE e += 1 NEW_LINE DEDENT if ( curr_subarray_sum <= suffix_sum [ e ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT curr_subarray_sum -= arr [ s ] NEW_LINE s += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def minOperation ( s , n ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( s [ i ] == '0' and s [ j ] == '1' ) : NEW_LINE INDENT ans += 1 NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE continue NEW_LINE DEDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( s [ j ] == '0' ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE y = n + 1 NEW_LINE while ( y <= n * n + n ) : NEW_LINE INDENT if ( ( n * n ) % ( y - n ) == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT y += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def power ( x , y , mod ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % mod NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) == 1 ) : NEW_LINE INDENT res = ( res * x ) % mod NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT
def count ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( 10 ) NEW_LINE return NEW_LINE DEDENT print ( power ( 9 , N , 1000000007 ) ) NEW_LINE DEDENT
def possible ( mid , a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE total = ( n * ( n - 1 ) ) // 2 NEW_LINE need = ( total + 1 ) // 2 NEW_LINE count = 0 NEW_LINE start = 0 NEW_LINE end = 1 NEW_LINE while ( end < n ) : NEW_LINE INDENT if ( a [ end ] - a [ start ] <= mid ) : NEW_LINE INDENT end += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( end - start - 1 ) NEW_LINE start += 1 NEW_LINE DEDENT DEDENT if ( end == n and start < end and a [ end - 1 ] - a [ start ] <= mid ) : NEW_LINE INDENT t = end - start - 1 NEW_LINE count += ( t * ( t + 1 ) // 2 ) NEW_LINE DEDENT if ( count >= need ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def findMedian ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE low = 0 NEW_LINE high = a [ n - 1 ] - a [ 0 ] NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( possible ( mid , a ) ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return high + 1 NEW_LINE DEDENT
def computeDistance ( root , value ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT left = computeDistance ( root . left , value ) NEW_LINE right = computeDistance ( root . right , value ) NEW_LINE if ( left == - 1 and right == - 1 ) : NEW_LINE INDENT if ( root . key == value ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if ( left == - 1 ) : NEW_LINE INDENT return right + 1 NEW_LINE DEDENT if ( right == - 1 ) : NEW_LINE INDENT return left + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + max ( left , right ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def dfs ( node , count , m , arr , k ) : NEW_LINE INDENT global ans NEW_LINE visited [ node ] = 1 NEW_LINE if ( arr [ node - 1 ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT if ( count > m ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( len ( adj [ node ] ) == 1 and node != 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT for x in adj [ node ] : NEW_LINE INDENT if ( not visited [ x ] ) : NEW_LINE INDENT dfs ( x , count , m , arr , k ) NEW_LINE DEDENT DEDENT DEDENT
def find ( parent , x ) : NEW_LINE INDENT if ( parent [ x ] == x ) : NEW_LINE INDENT return x NEW_LINE DEDENT parent [ x ] = find ( parent , parent [ x ] ) NEW_LINE return parent [ x ] NEW_LINE DEDENT
def setUnion ( parent , rank , x , y ) : NEW_LINE INDENT global ctr NEW_LINE parentx = find ( parent , x ) NEW_LINE parenty = find ( parent , y ) NEW_LINE if ( parenty == parentx ) : NEW_LINE INDENT return NEW_LINE DEDENT ctr -= 1 NEW_LINE if ( rank [ parentx ] < rank [ parenty ] ) : NEW_LINE INDENT parent [ parentx ] = parenty NEW_LINE DEDENT elif ( rank [ parentx ] > rank [ parenty ] ) : NEW_LINE INDENT parent [ parenty ] = parentx NEW_LINE DEDENT else : NEW_LINE INDENT parent [ parentx ] = parenty NEW_LINE rank [ parenty ] += 1 NEW_LINE DEDENT DEDENT
def solve ( n , m , query ) : NEW_LINE INDENT global ctr NEW_LINE result = [ 0 ] * len ( query ) NEW_LINE parent = [ 0 ] * ( n * m ) NEW_LINE for i in range ( n * m ) : NEW_LINE INDENT parent [ i ] = i NEW_LINE DEDENT rank = [ 1 ] * ( n * m ) NEW_LINE grid = [ 0 ] * ( n * m ) NEW_LINE for i in range ( len ( query ) ) : NEW_LINE INDENT x = query [ i ] [ 0 ] NEW_LINE y = query [ i ] [ 1 ] NEW_LINE if ( grid [ m * x + y ] == 1 ) : NEW_LINE INDENT result [ i ] = ctr NEW_LINE continue NEW_LINE DEDENT grid [ m * x + y ] = 1 NEW_LINE ctr += 1 NEW_LINE if ( x > 0 and grid [ m * ( x - 1 ) + y ] == 1 ) : NEW_LINE INDENT setUnion ( parent , rank , m * x + y , m * ( x - 1 ) + y ) NEW_LINE DEDENT if ( y > 0 and grid [ m * ( x ) + y - 1 ] == 1 ) : NEW_LINE INDENT setUnion ( parent , rank , m * x + y , m * ( x ) + y - 1 ) NEW_LINE DEDENT if ( x < n - 1 and grid [ m * ( x + 1 ) + y ] == 1 ) : NEW_LINE INDENT setUnion ( parent , rank , m * x + y , m * ( x + 1 ) + y ) NEW_LINE DEDENT if ( y < m - 1 and grid [ m * ( x ) + y + 1 ] == 1 ) : NEW_LINE INDENT setUnion ( parent , rank , m * x + y , m * ( x ) + y + 1 ) NEW_LINE DEDENT result [ i ] = ctr NEW_LINE DEDENT return result NEW_LINE DEDENT
def FindMinimumDistance ( ) : NEW_LINE INDENT global x , y , r , c NEW_LINE q = [ ] NEW_LINE q . append ( [ x , y ] ) NEW_LINE mat [ x ] [ y ] = 0 NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT x = q [ 0 ] [ 0 ] NEW_LINE y = q [ 0 ] [ 1 ] NEW_LINE q . pop ( 0 ) NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT a = x + dx [ i ] NEW_LINE b = y + dy [ i ] NEW_LINE if ( a < 0 or a >= r or b >= c or b < 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( mat [ a ] [ b ] == 0 ) : NEW_LINE INDENT mat [ a ] [ b ] = mat [ x ] [ y ] + 1 NEW_LINE q . append ( [ a , b ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def make_set ( v ) : NEW_LINE INDENT parent [ v ] = v NEW_LINE size_set [ v ] = 1 NEW_LINE DEDENT
def find_set ( v ) : NEW_LINE INDENT if ( v == parent [ v ] ) : NEW_LINE INDENT return v NEW_LINE DEDENT parent [ v ] = find_set ( parent [ v ] ) NEW_LINE return parent [ v ] NEW_LINE DEDENT
def union_set ( a , b ) : NEW_LINE INDENT a = find_set ( a ) NEW_LINE b = find_set ( b ) NEW_LINE if ( a != b ) : NEW_LINE INDENT if ( size_set [ a ] < size_set [ b ] ) : NEW_LINE INDENT swap ( a , b ) NEW_LINE DEDENT parent [ b ] = a NEW_LINE size_set [ a ] += size_set [ b ] NEW_LINE DEDENT DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= 100000 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , 100001 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def fibonacciOfPrime ( n1 , n2 ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE initial = [ ] NEW_LINE for i in range ( n1 , n2 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT initial . append ( i ) NEW_LINE DEDENT DEDENT now = [ ] NEW_LINE for a in initial : NEW_LINE INDENT for b in initial : NEW_LINE INDENT if a != b : NEW_LINE INDENT c = str ( a ) + str ( b ) NEW_LINE now . append ( int ( c ) ) NEW_LINE DEDENT DEDENT DEDENT current = [ ] NEW_LINE for x in now : NEW_LINE INDENT if prime [ x ] : NEW_LINE INDENT current . append ( x ) NEW_LINE DEDENT DEDENT current = set ( current ) NEW_LINE first = min ( current ) NEW_LINE second = max ( current ) NEW_LINE count = len ( current ) - 1 NEW_LINE curr = 1 NEW_LINE while curr < count : NEW_LINE INDENT c = first + second NEW_LINE first = second NEW_LINE second = c NEW_LINE curr += 1 NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT
def reverse ( num ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT r = int ( num % 10 ) NEW_LINE rev = rev * 10 + r NEW_LINE num = num // 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT
def count ( N , A , B ) : NEW_LINE INDENT l = int ( pow ( 10 , N - 1 ) ) NEW_LINE r = int ( pow ( 10 , N ) - 1 ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT l = 0 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT even_sum = 0 NEW_LINE odd_sum = 0 NEW_LINE itr = 0 NEW_LINE num = reverse ( i ) NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( itr % 2 == 0 ) : NEW_LINE INDENT odd_sum += num % 10 NEW_LINE DEDENT else : NEW_LINE INDENT even_sum += num % 10 NEW_LINE DEDENT num = num // 10 NEW_LINE itr += 1 NEW_LINE DEDENT if ( even_sum % A == 0 and odd_sum % B == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def count ( N , A , B ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 9 // B + 1 NEW_LINE DEDENT max_sum = 9 * N NEW_LINE odd_count = N // 2 + N % 2 NEW_LINE even_count = N - odd_count NEW_LINE dp = [ [ 0 for x in range ( max_sum + 1 ) ] for y in range ( even_count ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT dp [ 0 ] [ i % A ] += 1 NEW_LINE DEDENT for i in range ( 1 , even_count ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT for k in range ( max_sum + 1 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ k ] > 0 ) : NEW_LINE INDENT dp [ i ] [ ( j + k ) % A ] += dp [ i - 1 ] [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT dp1 = [ [ 0 for x in range ( max_sum ) ] for y in range ( odd_count ) ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT dp1 [ 0 ] [ i % B ] += 1 NEW_LINE DEDENT for i in range ( 1 , odd_count ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT for k in range ( max_sum + 1 ) : NEW_LINE INDENT if ( dp1 [ i - 1 ] [ k ] > 0 ) : NEW_LINE INDENT dp1 [ i ] [ ( j + k ) % B ] += dp1 [ i - 1 ] [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ even_count - 1 ] [ 0 ] * dp1 [ odd_count - 1 ] [ 0 ] NEW_LINE DEDENT
def calc_distance ( A , B , n ) : NEW_LINE INDENT distance_traveled_A = 0 NEW_LINE distance_traveled_B = 0 NEW_LINE answer = 0 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT distance_traveled_A += A [ i ] NEW_LINE distance_traveled_B += B [ i ] NEW_LINE if ( ( distance_traveled_A == distance_traveled_B ) and ( A [ i ] == B [ i ] ) ) : NEW_LINE INDENT answer += A [ i ] NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def dfs ( node , A , subtree_size , visited , check_subtree ) : NEW_LINE INDENT visited [ node ] = True NEW_LINE subtree_size [ node ] = 1 NEW_LINE if ( node == A ) : NEW_LINE INDENT check_subtree [ node ] = True NEW_LINE DEDENT else : NEW_LINE INDENT check_subtree [ node ] = False NEW_LINE DEDENT for v in G [ node ] : NEW_LINE INDENT if ( not visited [ v ] ) : NEW_LINE INDENT subtree_size [ node ] += dfs ( v , A , subtree_size , visited , check_subtree ) NEW_LINE check_subtree [ node ] = ( check_subtree [ node ] check_subtree [ v ] ) NEW_LINE DEDENT DEDENT return subtree_size [ node ] NEW_LINE DEDENT
def numberOfPairs ( N , B , A ) : NEW_LINE INDENT subtree_size = [ 0 ] * ( N + 1 ) NEW_LINE visited = [ 0 ] * ( N + 1 ) NEW_LINE check_subtree = [ 0 ] * ( N + 1 ) NEW_LINE dfs ( B , A , subtree_size , visited , check_subtree ) NEW_LINE difference = 0 NEW_LINE for v in G [ B ] : NEW_LINE INDENT if ( check_subtree [ v ] ) : NEW_LINE INDENT difference = N - subtree_size [ v ] NEW_LINE break NEW_LINE DEDENT DEDENT return ( ( N * ( N - 1 ) ) - difference * ( subtree_size [ A ] ) ) NEW_LINE DEDENT
def equalXORandOR ( n ) : NEW_LINE INDENT m = 0 NEW_LINE MSB = int ( log2 ( n ) ) NEW_LINE for i in range ( MSB + 1 ) : NEW_LINE INDENT if ( not ( n & ( 1 << i ) ) ) : NEW_LINE INDENT m += ( 1 << i ) NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT
def findMinSoln ( n , k ) : NEW_LINE INDENT minSoln = sys . maxsize NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT minSoln = min ( minSoln , ( n // i ) * k + i ) NEW_LINE DEDENT DEDENT return minSoln NEW_LINE DEDENT
def getSum ( BITree , index ) : NEW_LINE INDENT ans = 0 NEW_LINE index += 1 NEW_LINE while ( index > 0 ) : NEW_LINE INDENT ans += BITree [ index ] NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def updateBIT ( BITree , n , index , val ) : NEW_LINE INDENT index = index + 1 NEW_LINE while ( index <= n ) : NEW_LINE INDENT BITree [ index ] += val NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT
def getLowerBound ( BITree , arr , n , k ) : NEW_LINE INDENT lb = - 1 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if ( getSum ( BITree , mid ) >= k ) : NEW_LINE INDENT r = mid - 1 NEW_LINE lb = mid NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return lb NEW_LINE DEDENT
def dfs ( val , cost , tr , u , s ) : NEW_LINE INDENT global cnt NEW_LINE s = s + cost [ u ] NEW_LINE if ( s < 0 ) : NEW_LINE INDENT s = 0 NEW_LINE DEDENT if ( s > val [ u ] ) : NEW_LINE INDENT return NEW_LINE DEDENT cnt += 1 NEW_LINE for i in range ( 0 , len ( tr [ u ] ) ) : NEW_LINE INDENT dfs ( val , cost , tr , tr [ u ] [ i ] , s ) NEW_LINE DEDENT DEDENT
def dfs1 ( cur , par ) : NEW_LINE INDENT for u in adj [ cur ] : NEW_LINE INDENT if ( u != par ) : NEW_LINE INDENT dfs1 ( u , cur ) NEW_LINE height [ cur ] = max ( height [ cur ] , height [ u ] ) NEW_LINE DEDENT DEDENT height [ cur ] += 1 NEW_LINE DEDENT
def dfs2 ( cur , par ) : NEW_LINE INDENT max1 = 0 NEW_LINE max2 = 0 NEW_LINE for u in adj [ cur ] : NEW_LINE INDENT if ( u != par ) : NEW_LINE INDENT if ( height [ u ] >= max1 ) : NEW_LINE INDENT max2 = max1 NEW_LINE max1 = height [ u ] NEW_LINE DEDENT elif ( height [ u ] > max2 ) : NEW_LINE INDENT max2 = height [ u ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for u in adj [ cur ] : NEW_LINE INDENT if ( u != par ) : NEW_LINE INDENT sum = ( max2 if ( max1 == height [ u ] ) else max1 ) NEW_LINE if ( max1 == height [ u ] ) : NEW_LINE INDENT dist [ u ] = 1 + max ( 1 + max2 , dist [ cur ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dist [ u ] = 1 + max ( 1 + max1 , dist [ cur ] ) NEW_LINE DEDENT dfs2 ( u , cur ) NEW_LINE DEDENT DEDENT DEDENT
def displaySteppingNumbers ( n , m ) : NEW_LINE INDENT for i in range ( n , m + 1 ) : NEW_LINE INDENT if ( isStepNum ( i ) ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def BFS ( mat , row , col ) : NEW_LINE INDENT area = 0 NEW_LINE Q = deque ( ) NEW_LINE Q . append ( [ row , col ] ) NEW_LINE while ( len ( Q ) > 0 ) : NEW_LINE INDENT it = Q . popleft ( ) NEW_LINE r , c = it [ 0 ] , it [ 1 ] NEW_LINE if ( r < 0 or c < 0 or r > 4 or c > 4 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( mat [ r ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( mat [ r ] == 1 ) : NEW_LINE INDENT mat [ r ] = 0 NEW_LINE area += 1 NEW_LINE DEDENT Q . append ( [ r + 1 , c ] ) NEW_LINE Q . append ( [ r - 1 , c ] ) NEW_LINE Q . append ( [ r , c + 1 ] ) NEW_LINE Q . append ( [ r , c - 1 ] ) NEW_LINE DEDENT return area NEW_LINE DEDENT
def sizeOfConnections ( mat ) : NEW_LINE INDENT result = [ ] NEW_LINE for row in range ( 5 ) : NEW_LINE INDENT for col in range ( 5 ) : NEW_LINE INDENT if ( mat [ row ] [ col ] == 1 ) : NEW_LINE INDENT area = BFS ( mat , row , col ) NEW_LINE result . append ( area ) NEW_LINE DEDENT DEDENT DEDENT for val in result : NEW_LINE INDENT print ( val , end = " " ) NEW_LINE DEDENT DEDENT
def DFS ( adjl , parent , u , p ) : NEW_LINE INDENT parent [ u ] = p NEW_LINE for v in adjl [ u ] : NEW_LINE INDENT if ( v != p ) : NEW_LINE INDENT DFS ( adjl , parent , v , u ) NEW_LINE DEDENT DEDENT DEDENT
def valuesFromChildren ( parent , values ) : NEW_LINE INDENT valuesChildren = [ 0 ] * ( len ( parent ) ) NEW_LINE for i in range ( len ( parent ) ) : NEW_LINE INDENT if ( parent [ i ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT p = parent [ i ] NEW_LINE valuesChildren [ p ] += values [ i ] NEW_LINE DEDENT DEDENT return valuesChildren NEW_LINE DEDENT
def maxProduct ( arr , N ) : NEW_LINE INDENT if ( N < 3 ) : NEW_LINE INDENT return NEW_LINE DEDENT a = arr [ 0 ] NEW_LINE b = arr [ 1 ] NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE for i in range ( 0 , N , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N - 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] > a * b ) : NEW_LINE INDENT c = a NEW_LINE d = b NEW_LINE a = arr [ i ] NEW_LINE b = arr [ j ] NEW_LINE DEDENT if ( arr [ i ] * arr [ j ] < a * b and arr [ i ] * arr [ j ] > c * d ) : NEW_LINE INDENT c = arr [ i ] NEW_LINE DEDENT d = arr [ j ] NEW_LINE DEDENT DEDENT print ( c , " " , d ) NEW_LINE DEDENT
def maxProduct ( arr , N ) : NEW_LINE INDENT if ( N < 3 ) : NEW_LINE INDENT return NEW_LINE DEDENT arr . sort ( ) NEW_LINE smallest1 = arr [ 0 ] NEW_LINE smallest3 = arr [ 2 ] NEW_LINE largest1 = arr [ N - 1 ] NEW_LINE largest3 = arr [ N - 3 ] NEW_LINE if ( smallest1 * smallest3 >= largest1 * largest3 ) : NEW_LINE INDENT print ( smallest1 , " " , smallest3 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( largest1 , " " , largest3 ) NEW_LINE DEDENT DEDENT
def maxLen ( A , N ) : NEW_LINE INDENT v = [ ] NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT if ( A [ i ] == 1 ) : NEW_LINE INDENT s = i NEW_LINE while ( i < N and A [ i ] == 1 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT le = i - s NEW_LINE v . append ( [ le , s , i - 1 ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( v ) - 1 ) : NEW_LINE INDENT ans = max ( ans , v [ i ] [ 0 ] ) NEW_LINE if ( v [ i + 1 ] [ 1 ] - v [ i ] [ 2 ] - 1 == 2 ) : NEW_LINE INDENT ans = max ( ans , v [ i ] [ 0 ] + v [ i + 1 ] [ 0 ] ) NEW_LINE DEDENT if ( v [ i + 1 ] [ 1 ] - v [ i ] [ 2 ] - 1 == 1 ) : NEW_LINE INDENT ans = max ( ans , v [ i ] [ 0 ] + v [ i + 1 ] [ 0 ] - 1 ) NEW_LINE DEDENT DEDENT ans = max ( v [ len ( v ) - 1 ] [ 0 ] , ans ) NEW_LINE return ans NEW_LINE DEDENT
def maxLengthOf1s ( arr , n ) : NEW_LINE INDENT prefix = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i - 2 ] == 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = 0 NEW_LINE DEDENT DEDENT suffix = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i + 2 ] == 1 ) : NEW_LINE INDENT suffix [ i ] = suffix [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i ] = 0 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans = max ( ans , prefix [ i + 1 ] + suffix [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def dfs ( u ) : NEW_LINE INDENT visited [ u ] = 1 NEW_LINE for it in adj [ u ] : NEW_LINE INDENT if ( visited [ it ] == 0 ) : NEW_LINE INDENT dfs ( it ) NEW_LINE DEDENT DEDENT s . append ( u ) NEW_LINE DEDENT
def check_cycle ( ) : NEW_LINE INDENT pos = dict ( ) NEW_LINE ind = 0 NEW_LINE while ( len ( s ) != 0 ) : NEW_LINE INDENT pos [ s [ - 1 ] ] = ind NEW_LINE tsort . append ( s [ - 1 ] ) NEW_LINE ind += 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for it in adj [ i ] : NEW_LINE INDENT first = 0 if i not in pos else pos [ i ] NEW_LINE second = 0 if it not in pos else pos [ it ] NEW_LINE if ( first > second ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def addEdge ( u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE DEDENT
def printNewArray ( a , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v . append ( ( a [ i ] , i ) ) NEW_LINE DEDENT v . sort ( ) NEW_LINE ans = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans [ v [ ( i + 1 ) % n ] [ 1 ] ] = v [ i ] [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def bfs ( n , m , num ) : NEW_LINE INDENT q = [ ] NEW_LINE q . append ( num ) NEW_LINE while len ( q ) > 0 : NEW_LINE INDENT stepNum = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( stepNum <= m and stepNum >= n ) : NEW_LINE INDENT print ( stepNum , end = " " ) NEW_LINE DEDENT if ( num == 0 or stepNum > m ) : NEW_LINE INDENT continue NEW_LINE DEDENT lastDigit = stepNum % 10 NEW_LINE stepNumA = stepNum * 10 + ( lastDigit - 1 ) NEW_LINE stepNumB = stepNum * 10 + ( lastDigit + 1 ) NEW_LINE if ( lastDigit == 0 ) : NEW_LINE INDENT q . append ( stepNumB ) NEW_LINE DEDENT elif ( lastDigit == 9 ) : NEW_LINE INDENT q . append ( stepNumA ) NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( stepNumA ) NEW_LINE q . append ( stepNumB ) NEW_LINE DEDENT DEDENT DEDENT
def displaySteppingNumbers ( n , m ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT bfs ( n , m , i ) NEW_LINE DEDENT DEDENT
def solve ( arr , n ) : NEW_LINE INDENT countzeroes = 0 NEW_LINE countones = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT countzeroes += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countones += 1 NEW_LINE DEDENT DEDENT if ( abs ( countzeroes - countones ) == 1 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def bs ( a , n , ele ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE ch = '@' NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( end - start ) // 2 NEW_LINE if ( ar [ mid ] == ele ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT elif ( ar [ mid ] < ele ) : NEW_LINE INDENT ch = ar [ mid ] NEW_LINE start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ch NEW_LINE DEDENT
def countPairs ( N , arr ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == arr [ arr [ i ] - 1 ] - 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count // 2 ) NEW_LINE DEDENT
def findMaxLen ( a , k ) : NEW_LINE INDENT n = len ( a ) NEW_LINE a . sort ( ) NEW_LINE vis = [ 0 ] * n NEW_LINE mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] = i NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] == False ) : NEW_LINE INDENT check = a [ i ] * k NEW_LINE if ( check in mp . keys ( ) ) : NEW_LINE INDENT c += 1 NEW_LINE vis [ mp [ check ] ] = True NEW_LINE DEDENT DEDENT DEDENT return n - c NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT if ( c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def countSubstrings ( s , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( isVowel ( s [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def addEdge ( u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT
def minimumCost ( V , cost ) : NEW_LINE INDENT vis = [ False for i in range ( V + 1 ) ] NEW_LINE min_cost = 0 NEW_LINE for i in range ( 1 , V + 1 ) : NEW_LINE INDENT if ( not vis [ i ] ) : NEW_LINE INDENT min_cost_node = sys . maxsize NEW_LINE min_cost_node = dfs ( i , cost , vis , min_cost_node ) NEW_LINE min_cost += min_cost_node NEW_LINE DEDENT DEDENT return min_cost NEW_LINE DEDENT
def check ( st , mid , a ) : NEW_LINE INDENT n = len ( st ) NEW_LINE previous = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( st [ i ] == chr ( a ) ) : NEW_LINE INDENT if ( i - previous > mid ) : NEW_LINE INDENT return False NEW_LINE DEDENT previous = i NEW_LINE DEDENT DEDENT if ( i - previous > mid ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def possible ( st , mid ) : NEW_LINE INDENT for i in range ( 26 ) : NEW_LINE INDENT if ( check ( st , mid , i + ord ( 'a' ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findMinLength ( st ) : NEW_LINE INDENT low = 1 NEW_LINE high = len ( st ) NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( possible ( st , mid ) ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return high + 1 NEW_LINE DEDENT
def solve ( A , N ) : NEW_LINE INDENT i = 0 NEW_LINE k = 0 NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT tempK = ( min ( A [ i ] , A [ j ] ) // ( j - i ) ) NEW_LINE if ( tempK > k ) : NEW_LINE INDENT k = tempK NEW_LINE DEDENT if ( A [ j ] >= A [ i ] // ( j - i ) ) : NEW_LINE INDENT i = j NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT
def possible ( arr , N , mid , K ) : NEW_LINE INDENT add = 0 NEW_LINE for i in range ( N // 2 - ( N + 1 ) % 2 , N ) : NEW_LINE INDENT if ( mid - arr [ i ] > 0 ) : NEW_LINE INDENT add += ( mid - arr [ i ] ) NEW_LINE if ( add > K ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT if ( add <= K ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def findMaxMedian ( arr , N , K ) : NEW_LINE INDENT low = 1 NEW_LINE mx = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT mx = max ( mx , arr [ i ] ) NEW_LINE DEDENT high = K + mx NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( high + low ) // 2 NEW_LINE if ( possible ( arr , N , mid , K ) ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT if ( low - 1 < arr [ N // 2 ] ) : NEW_LINE INDENT return ( arr [ N // 2 ] + low - 1 ) // 2 NEW_LINE DEDENT DEDENT return low - 1 NEW_LINE DEDENT
def split ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] == 1 ) : NEW_LINE INDENT count = 2 NEW_LINE break NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def check ( str1 , str2 ) : NEW_LINE INDENT mark = [ False for i in range ( 26 ) ] NEW_LINE n = len ( str1 ) NEW_LINE m = len ( str2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mark [ ord ( str1 [ i ] ) - ord ( 'a' ) ] = True NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( mark [ ord ( str2 [ i ] ) - ord ( 'a' ) ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def countLessThanMid ( mid , N , M , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , min ( N , mid ) + 1 ) : NEW_LINE INDENT count = count + min ( mid // i , M ) NEW_LINE DEDENT if ( count >= K ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def findKthElement ( N , M , K ) : NEW_LINE INDENT low = 1 NEW_LINE high = N * M NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( countLessThanMid ( mid , N , M , K ) ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return high + 1 NEW_LINE DEDENT
def PermuteTheArray ( A , n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ A [ i ] - 1 ] = i NEW_LINE DEDENT mini = n NEW_LINE maxi = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mini = min ( mini , arr [ i ] ) NEW_LINE maxi = max ( maxi , arr [ i ] ) NEW_LINE if ( maxi - mini == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findLargest ( beg , end , arr , n ) : NEW_LINE INDENT if ( beg == end ) : NEW_LINE INDENT compared = [ 0 ] * n NEW_LINE compared [ 0 ] = 1 NEW_LINE compared [ 1 ] = arr [ beg ] NEW_LINE return compared NEW_LINE DEDENT compared1 = findLargest ( beg , ( beg + end ) // 2 , arr , n ) NEW_LINE compared2 = findLargest ( ( beg + end ) // 2 + 1 , end , arr , n ) NEW_LINE if ( compared1 [ 1 ] > compared2 [ 1 ] ) : NEW_LINE INDENT k = compared1 [ 0 ] + 1 NEW_LINE compared1 [ 0 ] = k NEW_LINE compared1 [ k ] = compared2 [ 1 ] NEW_LINE return compared1 NEW_LINE DEDENT else : NEW_LINE INDENT k = compared2 [ 0 ] + 1 NEW_LINE compared2 [ 0 ] = k NEW_LINE compared2 [ k ] = compared1 [ 1 ] NEW_LINE return compared2 NEW_LINE DEDENT DEDENT
def findSecondLargest ( end , arr ) : NEW_LINE INDENT compared1 = findLargest ( 0 , end - 1 , arr , end ) NEW_LINE compared2 = findLargest ( 2 , compared1 [ 0 ] + 2 , compared1 , compared1 [ 0 ] ) NEW_LINE print ( compared2 [ 1 ] ) NEW_LINE DEDENT
def CountsubString ( strr , n ) : NEW_LINE INDENT c = 0 NEW_LINE for len in range ( n + 1 ) : NEW_LINE INDENT for i in range ( n - len ) : NEW_LINE INDENT j = i + len - 1 NEW_LINE temp = strr [ i ] NEW_LINE f = 0 NEW_LINE if ( j == i ) : NEW_LINE INDENT c += 1 NEW_LINE continue NEW_LINE DEDENT k = i + 1 NEW_LINE while ( k <= j and temp > strr [ k ] ) : NEW_LINE INDENT temp = strr [ k ] NEW_LINE k += 1 NEW_LINE DEDENT if ( k > j ) : NEW_LINE INDENT c += 1 NEW_LINE f = 2 NEW_LINE DEDENT while ( k <= j and f != 2 and temp < strr [ k ] ) : NEW_LINE INDENT temp = strr [ k ] NEW_LINE k += 1 NEW_LINE DEDENT if ( k > j and f != 2 ) : NEW_LINE INDENT c += 1 NEW_LINE f = 0 NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT
def countSubString ( S , C ) : NEW_LINE INDENT count = 0 NEW_LINE conCount = 0 NEW_LINE for ch in S : NEW_LINE INDENT if ( ch == C ) : NEW_LINE INDENT conCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( ( conCount * ( conCount + 1 ) ) // 2 ) NEW_LINE conCount = 0 NEW_LINE DEDENT DEDENT count += ( ( conCount * ( conCount + 1 ) ) // 2 ) NEW_LINE print ( count ) NEW_LINE DEDENT
def checkPalindrome ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE first_half = True NEW_LINE second_half = True NEW_LINE cnt = ( n // 2 ) - 1 NEW_LINE for i in range ( 0 , int ( ( n / 2 ) / 2 ) ) : NEW_LINE INDENT if ( S [ i ] != S [ cnt ] ) : NEW_LINE INDENT first_half = False NEW_LINE break NEW_LINE DEDENT if ( S [ n // 2 + i ] != S [ n // 2 + cnt ] ) : NEW_LINE INDENT second_half = False NEW_LINE break NEW_LINE DEDENT cnt -= 1 NEW_LINE DEDENT if ( first_half and second_half ) : NEW_LINE INDENT print ( 'Yes' , end = '' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 'No' , end = '' ) NEW_LINE DEDENT DEDENT
def isSubsetSum ( arr , n , sum ) : NEW_LINE INDENT subset = [ [ True for x in range ( sum + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if ( j < arr [ i - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT if ( j >= arr [ i - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - arr [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT return subset [ n ] [ sum ] NEW_LINE DEDENT
def findSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT val = int ( math . sqrt ( sum ) ) NEW_LINE for i in range ( val , - 1 , - 1 ) : NEW_LINE INDENT if ( isSubsetSum ( arr , n , i * i ) ) : NEW_LINE INDENT return i * i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def findsubArray ( arr , N , K ) : NEW_LINE INDENT res = N + 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT curr_prad = 1 NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT curr_prad = curr_prad * arr [ j ] NEW_LINE if ( curr_prad % N == K and res > ( j - i + 1 ) ) : NEW_LINE INDENT res = min ( res , j - i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if res == N + 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT
def check ( arr ) : NEW_LINE INDENT f = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( not checkBitonic ( arr [ i ] , M ) ) : NEW_LINE INDENT print ( "NO" ) NEW_LINE return NEW_LINE DEDENT DEDENT i = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = [ 0 ] * N NEW_LINE for j in range ( N ) : NEW_LINE INDENT temp [ j ] = arr [ j ] [ i ] NEW_LINE DEDENT if ( not checkBitonic ( temp , N ) ) : NEW_LINE INDENT print ( "NO" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "YES" ) NEW_LINE DEDENT
def getMaxGcd ( N ) : NEW_LINE INDENT maxGcd = - sys . maxsize - 1 NEW_LINE for i in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT A = i NEW_LINE B = N // i NEW_LINE maxGcd = max ( maxGcd , math . gcd ( A , B ) ) NEW_LINE DEDENT DEDENT return maxGcd NEW_LINE DEDENT
def can_place ( A , n , B , mid ) : NEW_LINE INDENT count = 1 NEW_LINE last_position = A [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( A [ i ] - last_position >= mid ) : NEW_LINE INDENT last_position = A [ i ] NEW_LINE count = count + 1 NEW_LINE if ( count == B ) : NEW_LINE INDENT return bool ( True ) NEW_LINE DEDENT DEDENT DEDENT return bool ( False ) NEW_LINE DEDENT
def find_min_difference ( A , n , B ) : NEW_LINE INDENT A . sort ( ) NEW_LINE s = 0 NEW_LINE e = A [ n - 1 ] - A [ 0 ] NEW_LINE ans = 0 NEW_LINE while ( s <= e ) : NEW_LINE INDENT mid = ( int ) ( ( s + e ) / 2 ) NEW_LINE if ( can_place ( A , n , B , mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE s = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT e = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def UniversalSubset ( A , B ) : NEW_LINE INDENT n1 = len ( A ) NEW_LINE n2 = len ( B ) NEW_LINE res = [ ] NEW_LINE A_freq = [ [ 0 for x in range ( 26 ) ] for y in range ( n1 ) ] NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT for j in range ( len ( A [ i ] ) ) : NEW_LINE INDENT A_freq [ i ] [ ord ( A [ i ] [ j ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT DEDENT B_freq = [ 0 ] * 26 NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT arr = [ 0 ] * 26 NEW_LINE for j in range ( len ( B [ i ] ) ) : NEW_LINE INDENT arr [ ord ( B [ i ] [ j ] ) - ord ( 'a' ) ] += 1 NEW_LINE B_freq [ ord ( B [ i ] [ j ] ) - ord ( 'a' ) ] = max ( B_freq [ ord ( B [ i ] [ j ] ) - ord ( 'a' ) ] , arr [ ord ( B [ i ] [ j ] ) - ord ( 'a' ) ] ) NEW_LINE DEDENT DEDENT for i in range ( n1 ) : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT if ( A_freq [ i ] [ j ] < B_freq [ j ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT res . append ( A [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( res ) ) : NEW_LINE INDENT for i in range ( len ( res ) ) : NEW_LINE INDENT for j in range ( len ( res [ i ] ) ) : NEW_LINE INDENT print ( res [ i ] [ j ] , end = "" ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 , end = "" ) NEW_LINE DEDENT DEDENT
def countTriplets ( A , N ) : NEW_LINE INDENT ans = 0 NEW_LINE map = defaultdict ( lambda : 0 ) NEW_LINE for j in range ( N - 2 , 0 , - 1 ) : NEW_LINE INDENT map [ A [ j + 1 ] ] += 1 NEW_LINE for i in range ( j ) : NEW_LINE INDENT target = A [ i ] * A [ j ] NEW_LINE if ( target in map . keys ( ) ) : NEW_LINE INDENT ans += map [ target ] NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def minDistance ( a , n ) : NEW_LINE INDENT maximum = - 1 NEW_LINE minimum = sys . maxsize NEW_LINE min_index = - 1 NEW_LINE max_index = - 1 NEW_LINE min_dist = n + 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > maximum ) : NEW_LINE INDENT maximum = a [ i ] NEW_LINE DEDENT if ( a [ i ] < minimum ) : NEW_LINE INDENT minimum = a [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == minimum ) : NEW_LINE INDENT min_index = i NEW_LINE DEDENT if ( a [ i ] == maximum ) : NEW_LINE INDENT max_index = i NEW_LINE DEDENT if ( min_index != - 1 and max_index != - 1 ) : NEW_LINE INDENT min_dist = ( min ( min_dist , abs ( min_index - max_index ) ) ) NEW_LINE DEDENT DEDENT return min_dist NEW_LINE DEDENT
def sign ( x ) : NEW_LINE INDENT if ( x > 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def findMaxSum ( arr , size ) : NEW_LINE INDENT max_sum = 0 NEW_LINE i = 0 NEW_LINE while i < size : NEW_LINE INDENT pres = arr [ i ] NEW_LINE j = i NEW_LINE while ( j < size and ( sign ( arr [ i ] ) == sign ( arr [ j ] ) ) ) : NEW_LINE INDENT pres = max ( pres , arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT max_sum = max_sum + pres NEW_LINE i = j - 1 NEW_LINE i += 1 NEW_LINE DEDENT return max_sum NEW_LINE DEDENT
def groupInKConsecutive ( arr , K ) : NEW_LINE INDENT count = defaultdict ( int ) NEW_LINE for h in arr : NEW_LINE INDENT count [ h ] += 1 NEW_LINE DEDENT for key , value in count . items ( ) : NEW_LINE INDENT cur = key NEW_LINE n = value NEW_LINE if ( n > 0 ) : NEW_LINE INDENT for i in range ( 1 , K ) : NEW_LINE INDENT if ( ( cur + i ) not in count ) : NEW_LINE INDENT return False NEW_LINE DEDENT count [ cur + i ] -= n NEW_LINE if ( count [ cur + i ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def checkrules ( s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if s [ 0 ] != '1' : NEW_LINE INDENT return False NEW_LINE DEDENT if len ( s ) > 2 : NEW_LINE INDENT if s [ 1 ] == '0' and s [ 2 ] == '0' : NEW_LINE INDENT return checkrules ( s [ 3 : ] ) NEW_LINE DEDENT DEDENT return checkrules ( s [ 1 : ] ) NEW_LINE DEDENT
def countSubAllOnes ( s ) : NEW_LINE INDENT l , r , ans = 0 , 0 , 0 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( r == len ( s ) ) : NEW_LINE INDENT ans += ( ( r - l ) * ( r - l + 1 ) ) // 2 NEW_LINE break NEW_LINE DEDENT if ( s [ r ] == '1' ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( ( r - l ) * ( r - l + 1 ) ) // 2 NEW_LINE l = r + 1 NEW_LINE r += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countOfPrimes ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isprime ( i ) ) : NEW_LINE INDENT if sumsquare ( i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT DEDENT
def Maxlen ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findPair ( a , n ) : NEW_LINE INDENT min_dist = sys . maxsize NEW_LINE index_a = - 1 NEW_LINE index_b = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i < min_dist ) : NEW_LINE INDENT if ( ( a [ i ] % a [ j ] == 0 ) or ( a [ j ] % a [ i ] == 0 ) ) : NEW_LINE INDENT min_dist = j - i NEW_LINE index_a = i NEW_LINE index_b = j NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( index_a == - 1 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "(" , a [ index_a ] , ", " , a [ index_b ] , ")" ) NEW_LINE DEDENT DEDENT
def findNumberDivByPowerofTwo ( ar , k , n ) : NEW_LINE INDENT found = - 1 NEW_LINE m = k NEW_LINE while ( m > 0 ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if ( ar [ mid ] == m ) : NEW_LINE INDENT found = m NEW_LINE break NEW_LINE DEDENT elif ( ar [ mid ] > m ) : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT elif ( ar [ mid ] < m ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT if ( found != - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT m = m // 2 NEW_LINE DEDENT return found NEW_LINE DEDENT
def longestNudeSubseq ( arr , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isNudeNum ( arr [ i ] ) ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def findSubset ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE cnt = 0 NEW_LINE v = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] - i <= 0 ) : NEW_LINE INDENT sum += a [ i - 1 ] - i NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( a [ i - 1 ] - i ) NEW_LINE DEDENT DEDENT v . sort ( ) NEW_LINE ptr = 0 NEW_LINE while ( ptr < len ( v ) and sum + v [ ptr ] <= 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE ptr += 1 NEW_LINE sum += v [ ptr ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def get_submaxarr ( arr , n , y ) : NEW_LINE INDENT j = 0 NEW_LINE stk = [ ] NEW_LINE maxarr = [ 0 ] * n NEW_LINE stk . append ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( stk ) > 0 and arr [ i ] > arr [ stk [ - 1 ] ] ) : NEW_LINE INDENT maxarr [ stk [ - 1 ] ] = i - 1 NEW_LINE stk . pop ( ) NEW_LINE DEDENT stk . append ( i ) NEW_LINE DEDENT while ( stk ) : NEW_LINE INDENT maxarr [ stk [ - 1 ] ] = n - 1 NEW_LINE stk . pop ( ) NEW_LINE DEDENT submax = [ ] NEW_LINE for i in range ( n - y + 1 ) : NEW_LINE INDENT while ( maxarr [ j ] < i + y - 1 or j < i ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT submax . append ( arr [ j ] ) NEW_LINE DEDENT return submax NEW_LINE DEDENT
def findMinx ( A , B , C , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = math . ceil ( math . sqrt ( K ) ) NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( end - start ) // 2 NEW_LINE x = func ( A , B , C , mid ) NEW_LINE Y = func ( A , B , C , mid - 1 ) NEW_LINE if ( x >= K and Y < K ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( x < K ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def longestSubarray ( arr , n , k ) : NEW_LINE INDENT Max = 1 NEW_LINE s = set ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) == 0 or abs ( arr [ i ] - arr [ j ] ) == k ) : NEW_LINE INDENT if ( not arr [ j ] in s ) : NEW_LINE INDENT if ( len ( s ) == 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( len ( s ) == 2 ) : NEW_LINE INDENT Max = max ( Max , j - i ) NEW_LINE s . clear ( ) NEW_LINE DEDENT else : NEW_LINE INDENT s . clear ( ) NEW_LINE DEDENT DEDENT return Max NEW_LINE DEDENT
def printDiagonal ( K , N , M ) : NEW_LINE INDENT startrow , startcol = 0 , 0 NEW_LINE if K - 1 < N : NEW_LINE INDENT startrow = K - 1 NEW_LINE startcol = 0 NEW_LINE DEDENT else : NEW_LINE INDENT startrow = N - 1 NEW_LINE startcol = K - N NEW_LINE DEDENT while startrow >= 0 and startcol < N : NEW_LINE INDENT print ( M [ startrow ] [ startcol ] , end = " " ) NEW_LINE startrow -= 1 NEW_LINE startcol += 1 NEW_LINE DEDENT DEDENT
def generateSequence ( freq , n ) : NEW_LINE INDENT m = { } NEW_LINE total = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ i ] = freq [ i ] NEW_LINE total += freq [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( m [ i ] ) : NEW_LINE INDENT sequence = [ ] NEW_LINE mcopy = { } NEW_LINE for j in m : NEW_LINE INDENT mcopy [ j ] = m [ j ] NEW_LINE DEDENT mcopy [ i ] -= 1 NEW_LINE sequence . append ( i ) NEW_LINE last = i NEW_LINE for j in range ( total - 1 ) : NEW_LINE INDENT if ( ( last - 1 ) in mcopy and mcopy [ last - 1 ] > 0 ) : NEW_LINE INDENT mcopy [ last - 1 ] -= 1 NEW_LINE sequence . append ( last - 1 ) NEW_LINE last -= 1 NEW_LINE DEDENT elif ( mcopy [ last + 1 ] ) : NEW_LINE INDENT mcopy [ last + 1 ] -= 1 NEW_LINE sequence . append ( last + 1 ) NEW_LINE last += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( len ( sequence ) == total ) : NEW_LINE INDENT return sequence NEW_LINE DEDENT DEDENT DEDENT return [ ] NEW_LINE DEDENT
def getMinimumDistance ( a , n ) : NEW_LINE INDENT min_set = { } NEW_LINE max_set = { } NEW_LINE max , min = 0 , sys . maxsize + 1 NEW_LINE frequency = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT frequency [ a [ i ] ] = frequency . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count = frequency [ a [ i ] ] NEW_LINE if ( count == max ) : NEW_LINE INDENT max_set [ a [ i ] ] = 1 NEW_LINE DEDENT elif ( count > max ) : NEW_LINE INDENT max_set . clear ( ) NEW_LINE max = count NEW_LINE max_set [ a [ i ] ] = 1 NEW_LINE DEDENT if ( count == min ) : NEW_LINE INDENT min_set [ a [ i ] ] = 1 NEW_LINE DEDENT elif ( count < min ) : NEW_LINE INDENT min_set . clear ( ) NEW_LINE min = count NEW_LINE min_set [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT min_dist = sys . maxsize + 1 NEW_LINE last_min_found = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] in min_set ) : NEW_LINE INDENT last_min_found = i NEW_LINE DEDENT if ( ( a [ i ] in max_set ) and last_min_found != - 1 ) : NEW_LINE INDENT if i - last_min_found < min_dist : NEW_LINE INDENT min_dist = i - last_min_found NEW_LINE DEDENT DEDENT DEDENT last_min_found = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] in min_set ) : NEW_LINE INDENT last_min_found = i NEW_LINE DEDENT if ( ( a [ i ] in max_set ) and last_min_found != - 1 ) : NEW_LINE INDENT if min_dist > last_min_found - i : NEW_LINE INDENT min_dist = last_min_found - i NEW_LINE DEDENT DEDENT DEDENT print ( min_dist ) NEW_LINE DEDENT
def printNum ( L , R ) : NEW_LINE INDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT temp = i NEW_LINE c = 10 NEW_LINE flag = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 10 >= c ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT c = temp % 10 NEW_LINE temp //= 10 NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def findPair ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT hashMap = [ ] NEW_LINE for k in arr : NEW_LINE INDENT hashMap . append ( k ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] NEW_LINE if sum not in hashMap : NEW_LINE INDENT print ( "(" , arr [ i ] , ", " , arr [ j ] , ")" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findLengthOfMaxSubset ( arr , n , m ) : NEW_LINE INDENT s = [ ] NEW_LINE answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = arr [ i ] NEW_LINE if ( tmp != m ) : NEW_LINE INDENT s . append ( tmp ) NEW_LINE answer += 1 NEW_LINE DEDENT DEDENT min = 1 NEW_LINE while ( s . count ( min ) ) : NEW_LINE INDENT min += 1 NEW_LINE DEDENT if ( min != m ) : NEW_LINE INDENT answer = - 1 NEW_LINE DEDENT return answer NEW_LINE DEDENT
def getDiameterPath ( vertex , targetVertex , parent , path ) : NEW_LINE INDENT if ( vertex == targetVertex ) : NEW_LINE INDENT path . append ( vertex ) NEW_LINE return True NEW_LINE DEDENT for i in range ( len ( tree [ vertex ] ) ) : NEW_LINE INDENT if ( tree [ vertex ] [ i ] == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( getDiameterPath ( tree [ vertex ] [ i ] , targetVertex , vertex , path ) ) : NEW_LINE INDENT path . append ( vertex ) NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def addedge ( a , b ) : NEW_LINE INDENT if ( a not in tree ) : NEW_LINE INDENT tree [ a ] = [ ] NEW_LINE DEDENT tree [ a ] . append ( b ) NEW_LINE if ( b not in tree ) : NEW_LINE INDENT tree [ b ] = [ ] NEW_LINE DEDENT tree [ b ] . append ( a ) NEW_LINE DEDENT
def FindCenter ( n ) : NEW_LINE INDENT maxHeight = - 1 NEW_LINE maxHeightNode = - 1 NEW_LINE farthestNode ( 0 , - 1 , 0 ) NEW_LINE leaf1 = maxHeightNode NEW_LINE maxHeight = - 1 NEW_LINE farthestNode ( maxHeightNode , - 1 , 0 ) NEW_LINE leaf2 = maxHeightNode NEW_LINE path = [ ] NEW_LINE getDiameterPath ( leaf1 , leaf2 , - 1 , path ) NEW_LINE pathSize = len ( path ) NEW_LINE if ( pathSize % 2 == 1 ) : NEW_LINE INDENT print ( path [ int ( pathSize / 2 ) ] * - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( path [ int ( pathSize / 2 ) ] , ", " , path [ int ( ( pathSize - 1 ) / 2 ) ] , sep = "" , end = "" ) NEW_LINE DEDENT DEDENT
def countSubsquare ( arr , n , X ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] += ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT cnt = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT lo = 1 NEW_LINE hi = min ( n - i , m - j ) + 1 NEW_LINE found = False NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE ni = i + mid - 1 NEW_LINE nj = j + mid - 1 NEW_LINE sum = ( dp [ ni ] [ nj ] - dp [ ni ] [ j - 1 ] - dp [ i - 1 ] [ nj ] + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE if ( sum >= X ) : NEW_LINE INDENT if ( sum == X ) : NEW_LINE INDENT found = True NEW_LINE DEDENT hi = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT if ( found == True ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def countSub ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE ans = 0 NEW_LINE cnt = 26 * [ 0 ] NEW_LINE i , j = 0 , 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( j < n and ( cnt [ ord ( Str [ j ] ) - ord ( 'a' ) ] == 0 ) ) : NEW_LINE INDENT cnt [ ord ( Str [ j ] ) - ord ( 'a' ) ] += 1 NEW_LINE ans += ( j - i + 1 ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ ord ( Str [ i ] ) - ord ( 'a' ) ] -= 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findMaxValue ( N , K ) : NEW_LINE INDENT packages = 0 NEW_LINE maxi = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT maxi = max ( maxi , i ) NEW_LINE DEDENT DEDENT packages = N // maxi NEW_LINE print ( packages ) NEW_LINE DEDENT
def max_sum_subarray ( arr , L , R ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE pre = n * [ 0 ] NEW_LINE pre [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + arr [ i ] NEW_LINE DEDENT s1 = [ ] NEW_LINE s1 . append ( 0 ) NEW_LINE ans = - sys . maxsize - 1 NEW_LINE ans = max ( ans , pre [ L - 1 ] ) NEW_LINE flag = 0 NEW_LINE for i in range ( L , n ) : NEW_LINE INDENT if ( i - R >= 0 ) : NEW_LINE INDENT if ( flag == 0 ) : NEW_LINE INDENT s1 . remove ( 0 ) NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if ( i - L >= 0 ) : NEW_LINE INDENT s1 . append ( pre [ i - L ] ) NEW_LINE DEDENT ans = max ( ans , pre [ i ] - s1 [ 0 ] ) NEW_LINE if ( i - R >= 0 ) : NEW_LINE INDENT s1 . remove ( pre [ i - R ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def rowWise ( v , n , m , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT countcons = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( v [ i ] [ j ] == '1' ) : NEW_LINE INDENT countcons = 0 NEW_LINE DEDENT else : NEW_LINE INDENT countcons += 1 NEW_LINE DEDENT if ( countcons >= k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def colWise ( v , n , m , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT countcons = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( v [ j ] [ i ] == '1' ) : NEW_LINE INDENT countcons = 0 NEW_LINE DEDENT else : NEW_LINE INDENT countcons += 1 NEW_LINE DEDENT if ( countcons >= k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def solve ( a , n ) : NEW_LINE INDENT mx = - sys . maxsize - 1 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( mx > a [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT mx = max ( mx , a [ j - 1 ] ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def count ( v , n ) : NEW_LINE INDENT odd , even = 0 , 0 NEW_LINE t = 1 << len ( v ) NEW_LINE size = len ( v ) NEW_LINE for i in range ( 1 , t ) : NEW_LINE INDENT d , count = 1 , 0 NEW_LINE for j in range ( 0 , size ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT d *= v [ j ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if ( count & 1 ) : NEW_LINE INDENT odd += n // d NEW_LINE DEDENT else : NEW_LINE INDENT even += n // d NEW_LINE DEDENT DEDENT return ( odd - even ) NEW_LINE DEDENT
def BinarySearch ( l , r , v , key ) : NEW_LINE INDENT while ( r - l > 1 ) : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if ( key <= count ( v , mid ) ) : NEW_LINE INDENT r = mid NEW_LINE DEDENT else : NEW_LINE INDENT l = mid NEW_LINE DEDENT DEDENT if ( key == count ( v , l ) ) : NEW_LINE INDENT return l NEW_LINE DEDENT else : NEW_LINE INDENT return r NEW_LINE DEDENT DEDENT
def sieve ( ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= 100006 ) : NEW_LINE INDENT for j in range ( i , 100006 , i ) : NEW_LINE INDENT if ( spf [ j ] == - 1 ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def findPrimeFactors ( s , n ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT s . add ( spf [ n ] ) NEW_LINE n //= spf [ n ] NEW_LINE DEDENT return s NEW_LINE DEDENT
def MinimumSteps ( n , m ) : NEW_LINE INDENT q = [ ] NEW_LINE s = set ( ) NEW_LINE q . append ( [ n , 0 ] ) NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT newNum = q [ 0 ] [ 0 ] NEW_LINE distance = q [ 0 ] [ 1 ] NEW_LINE q . pop ( 0 ) NEW_LINE k = findPrimeFactors ( s , newNum ) NEW_LINE for i in k : NEW_LINE INDENT if ( newNum == m ) : NEW_LINE INDENT return distance NEW_LINE DEDENT elif ( newNum > m ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( [ newNum + i , distance + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def maxSide ( a , n ) : NEW_LINE INDENT sideLength = 0 NEW_LINE a . sort NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > sideLength ) : NEW_LINE INDENT sideLength += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( sideLength ) NEW_LINE DEDENT
def medianChange ( arr1 , arr2 ) : NEW_LINE INDENT N = len ( arr1 ) NEW_LINE median = [ ] NEW_LINE if ( N & 1 ) : NEW_LINE INDENT median . append ( arr1 [ N // 2 ] * 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT median . append ( ( arr1 [ N // 2 ] + arr1 [ ( N - 1 ) // 2 ] ) // 2 ) NEW_LINE DEDENT for x in arr2 : NEW_LINE INDENT it = arr1 . index ( x ) NEW_LINE arr1 . pop ( it ) NEW_LINE N -= 1 NEW_LINE if ( N & 1 ) : NEW_LINE INDENT median . append ( arr1 [ N // 2 ] * 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT median . append ( ( arr1 [ N // 2 ] + arr1 [ ( N - 1 ) // 2 ] ) // 2 ) NEW_LINE DEDENT DEDENT for i in range ( len ( median ) - 1 ) : NEW_LINE INDENT print ( median [ i + 1 ] - median [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT
def countPairs ( X , Y , m , n ) : NEW_LINE INDENT suffix = [ 0 ] * 1005 NEW_LINE total_pairs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT suffix [ Y [ i ] ] += 1 NEW_LINE DEDENT for i in range ( int ( 1e3 ) , 2 , - 1 ) : NEW_LINE INDENT suffix [ i ] += suffix [ i + 1 ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( X [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( X [ i ] == 1 ) : NEW_LINE INDENT total_pairs += suffix [ 0 ] NEW_LINE continue NEW_LINE DEDENT elif ( X [ i ] == 2 ) : NEW_LINE INDENT total_pairs += suffix [ 5 ] NEW_LINE DEDENT elif ( X [ i ] == 3 ) : NEW_LINE INDENT total_pairs += ( suffix [ 2 ] + suffix [ 4 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT total_pairs += suffix [ X [ i ] + 1 ] NEW_LINE DEDENT total_pairs += suffix [ 0 ] + suffix [ 1 ] NEW_LINE DEDENT return total_pairs NEW_LINE DEDENT
def solve ( A , N , M ) : NEW_LINE INDENT B = [ ] NEW_LINE c = 1 NEW_LINE s = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT new = [ ] NEW_LINE for j in range ( M ) : NEW_LINE INDENT new . append ( c ) NEW_LINE c = c + 1 NEW_LINE DEDENT B . append ( new ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT if A [ i - 1 ] [ j ] == A [ i ] [ j ] : NEW_LINE INDENT B [ i - 1 ] [ j ] = B [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( i != N - 1 ) : NEW_LINE INDENT if A [ i + 1 ] [ j ] == A [ i ] [ j ] : NEW_LINE INDENT B [ i + 1 ] [ j ] = B [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( j != 0 ) : NEW_LINE INDENT if A [ i ] [ j - 1 ] == A [ i ] [ j ] : NEW_LINE INDENT B [ i ] [ j - 1 ] = B [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( j != M - 1 ) : NEW_LINE INDENT if ( A [ i ] [ j + 1 ] == A [ i ] [ j ] ) : NEW_LINE INDENT B [ i ] [ j + 1 ] = B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT s . add ( B [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT
def splitArray ( start , end , arr , prefix_sum ) : NEW_LINE INDENT if ( start >= end ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for k in range ( start , end ) : NEW_LINE INDENT if ( ( prefix_sum [ k ] - prefix_sum [ start - 1 ] ) == ( prefix_sum [ end ] - prefix_sum [ k ] ) ) : NEW_LINE INDENT return ( 1 + splitArray ( start , k , arr , prefix_sum ) + splitArray ( k + 1 , end , arr , prefix_sum ) ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def solve ( arr , n ) : NEW_LINE INDENT prefix_sum = [ 0 ] * ( n + 1 ) NEW_LINE prefix_sum [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prefix_sum [ i ] = ( prefix_sum [ i - 1 ] + arr [ i - 1 ] ) NEW_LINE DEDENT print ( splitArray ( 1 , n , arr , prefix_sum ) ) NEW_LINE DEDENT
def minDiff ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT a . append ( a [ i ] * 2 ) NEW_LINE DEDENT DEDENT a = sorted ( a ) NEW_LINE mindifference = a [ 1 ] - a [ 0 ] NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT mindifference = min ( mindifference , a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT print ( mindifference ) NEW_LINE DEDENT
def countFac ( n ) : NEW_LINE INDENT m = n NEW_LINE count = 0 NEW_LINE i = 2 NEW_LINE while ( ( i * i ) <= m ) : NEW_LINE INDENT total = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n /= i NEW_LINE total += 1 NEW_LINE DEDENT temp = 0 NEW_LINE j = 1 NEW_LINE while ( ( temp + j ) <= total ) : NEW_LINE INDENT temp += j NEW_LINE count += 1 NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( n != 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findMissing ( arr , left , right , diff ) : NEW_LINE INDENT if ( right <= left ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT mid = left + ( right - left ) // 2 NEW_LINE if ( arr [ mid + 1 ] - arr [ mid ] != diff ) : NEW_LINE INDENT return ( arr [ mid ] + diff ) NEW_LINE DEDENT if ( mid > 0 and arr [ mid ] - arr [ mid - 1 ] != diff ) : NEW_LINE INDENT return ( arr [ mid - 1 ] + diff ) NEW_LINE DEDENT if ( arr [ mid ] == arr [ 0 ] + mid * diff ) : NEW_LINE INDENT return findMissing ( arr , mid + 1 , right , diff ) NEW_LINE DEDENT return findMissing ( arr , left , mid - 1 , diff ) NEW_LINE DEDENT
def missingElement ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE diff = ( arr [ n - 1 ] - arr [ 0 ] ) // n NEW_LINE return findMissing ( arr , 0 , n - 1 , diff ) NEW_LINE DEDENT
def check ( A , B , C , D , x ) : NEW_LINE INDENT ans = 0 NEW_LINE ans = ( A * x * x * x + B * x * x + C * x + D ) NEW_LINE return ans NEW_LINE DEDENT
def findSolution ( A , B , C , D , E ) : NEW_LINE INDENT start = 0 NEW_LINE end = 100000 NEW_LINE mid = 0 NEW_LINE ans = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( end - start ) // 2 NEW_LINE ans = check ( A , B , C , D , mid ) NEW_LINE if ( ans == E ) : NEW_LINE INDENT print ( mid ) NEW_LINE return NEW_LINE DEDENT if ( ans < E ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT print ( "NA" ) NEW_LINE DEDENT
def findParent ( height , node ) : NEW_LINE INDENT start = 1 NEW_LINE end = pow ( 2 , height ) - 1 NEW_LINE if ( end == node ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT while ( node >= 1 ) : NEW_LINE INDENT end = end - 1 NEW_LINE mid = start + ( end - start ) // 2 NEW_LINE if ( mid == node or end == node ) : NEW_LINE INDENT return ( end + 1 ) NEW_LINE DEDENT elif ( node < mid ) : NEW_LINE INDENT end = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT DEDENT
def findValue ( R , C ) : NEW_LINE INDENT k = ( R * ( R - 1 ) ) // 2 + 1 NEW_LINE diff = R + 1 NEW_LINE for i in range ( 1 , C ) : NEW_LINE INDENT k = ( k + diff ) NEW_LINE diff += 1 NEW_LINE DEDENT return k NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = power ( x , y // 2 ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return x * temp * temp NEW_LINE DEDENT DEDENT
def nthRootSearch ( low , high , N , K ) : NEW_LINE INDENT if ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( ( power ( mid , K ) <= N ) and ( power ( mid + 1 , K ) > N ) ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( power ( mid , K ) < N ) : NEW_LINE INDENT return nthRootSearch ( mid + 1 , high , N , K ) NEW_LINE DEDENT else : NEW_LINE INDENT return nthRootSearch ( low , mid - 1 , N , K ) NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT
def get_subset_count ( arr , K , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE left = 0 NEW_LINE right = N - 1 NEW_LINE ans = 0 NEW_LINE while ( left <= right ) : NEW_LINE INDENT if ( arr [ left ] + arr [ right ] < K ) : NEW_LINE INDENT ans += 1 << ( right - left ) NEW_LINE left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def naive_find_x ( N ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT c += i * i * i NEW_LINE if c >= N : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT
def binary_searched_find_x ( k ) : NEW_LINE INDENT l = 0 NEW_LINE r = k NEW_LINE ans = 0 NEW_LINE while l <= r : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if ( ( mid * ( mid + 1 ) ) // 2 ) ** 2 >= k : NEW_LINE INDENT ans = mid NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def checkPerfectSquare ( N , start , last ) : NEW_LINE INDENT mid = int ( ( start + last ) / 2 ) NEW_LINE if ( start > last ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( mid * mid == N ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( mid * mid > N ) : NEW_LINE INDENT return checkPerfectSquare ( N , start , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return checkPerfectSquare ( N , mid + 1 , last ) NEW_LINE DEDENT DEDENT
def minDistancePoints ( A , K , n ) : NEW_LINE INDENT m = { } NEW_LINE q = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ A [ i ] ] = 1 NEW_LINE q . append ( A [ i ] ) NEW_LINE DEDENT ans = [ ] NEW_LINE while ( K > 0 ) : NEW_LINE INDENT x = q [ 0 ] NEW_LINE q = q [ 1 : : ] NEW_LINE if ( ( x - 1 ) not in m and K > 0 ) : NEW_LINE INDENT m [ x - 1 ] = m . get ( x - 1 , 0 ) + 1 NEW_LINE q . append ( x - 1 ) NEW_LINE ans . append ( x - 1 ) NEW_LINE K -= 1 NEW_LINE DEDENT if ( ( x + 1 ) not in m and K > 0 ) : NEW_LINE INDENT m [ x + 1 ] = m . get ( x + 1 , 0 ) + 1 NEW_LINE q . append ( x + 1 ) NEW_LINE ans . append ( x + 1 ) NEW_LINE K -= 1 NEW_LINE DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def search ( mat , n , m ) : NEW_LINE INDENT a = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT low = 0 NEW_LINE high = m - 1 NEW_LINE ans = sys . maxsize NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( mat [ i ] [ mid ] == 1 ) : NEW_LINE INDENT if ( mid == 0 ) : NEW_LINE INDENT ans = 0 NEW_LINE break NEW_LINE DEDENT elif ( mat [ i ] [ mid - 1 ] == 0 ) : NEW_LINE INDENT ans = mid NEW_LINE break NEW_LINE DEDENT DEDENT if ( mat [ i ] [ mid ] == 1 ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT if ( ans < a ) : NEW_LINE INDENT a = ans NEW_LINE DEDENT DEDENT if ( a == sys . maxsize ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return a + 1 NEW_LINE DEDENT
def findNumbers ( N , M ) : NEW_LINE INDENT m = M NEW_LINE remLen = { } NEW_LINE for len1 in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT remainder = M % N NEW_LINE if ( remLen . get ( remainder ) == None ) : NEW_LINE INDENT remLen [ remainder ] = len1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT M = M * 10 + m NEW_LINE M = M % N NEW_LINE DEDENT LenA = len1 NEW_LINE LenB = remLen [ remainder ] NEW_LINE for i in range ( LenB ) : NEW_LINE INDENT print ( m , end = "" ) NEW_LINE DEDENT print ( " " , end = "" ) NEW_LINE for i in range ( LenA ) : NEW_LINE INDENT print ( m , end = "" ) NEW_LINE DEDENT return NEW_LINE DEDENT
def subMatrixSum ( i , j , length ) : NEW_LINE INDENT return ( prefix_2D [ i ] [ j ] - prefix_2D [ i ] [ j - length ] - prefix_2D [ i - length ] [ j ] + prefix_2D [ i - length ] [ j - length ] ) NEW_LINE DEDENT
def numberOfWays ( a , b , n , m , k ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT prefix_2D [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prefix_2D [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT prefix_2D [ i ] [ j ] += prefix_2D [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT prefix_2D [ i ] [ j ] += prefix_2D [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT answer = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT low = 1 NEW_LINE high = min ( i , j ) NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( subMatrixSum ( i , j , mid ) >= k ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT if ( subMatrixSum ( i , j , low ) >= k ) : NEW_LINE INDENT answer += ( min ( i , j ) - low + 1 ) NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT
def minpoint ( arr , n , k ) : NEW_LINE INDENT min_point = 0 NEW_LINE for i in range ( 1 , k - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT min_point += 1 NEW_LINE DEDENT DEDENT final_point = min_point NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if ( arr [ i - ( k - 1 ) ] < arr [ i - ( k - 1 ) + 1 ] and arr [ i - ( k - 1 ) ] < arr [ i - ( k - 1 ) - 1 ] ) : NEW_LINE INDENT min_point -= 1 NEW_LINE DEDENT if ( arr [ i - 1 ] < arr [ i ] and arr [ i - 1 ] < arr [ i - 2 ] ) : NEW_LINE INDENT min_point += 1 NEW_LINE DEDENT if ( min_point > final_point ) : NEW_LINE INDENT final_point = min_point NEW_LINE DEDENT DEDENT print ( final_point ) NEW_LINE DEDENT
def checkMin ( arr , n ) : NEW_LINE INDENT smallest = math . inf NEW_LINE secondSmallest = math . inf NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < smallest ) : NEW_LINE INDENT secondSmallest = smallest NEW_LINE smallest = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < secondSmallest ) : NEW_LINE INDENT secondSmallest = arr [ i ] NEW_LINE DEDENT DEDENT if ( 2 * smallest <= secondSmallest ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def find ( dividend , divisor , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return ( 0 , dividend ) NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE n = dividend - divisor * mid NEW_LINE if ( n > divisor ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT elif ( n < 0 ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n == divisor ) : NEW_LINE INDENT mid += 1 NEW_LINE n = 0 NEW_LINE DEDENT return ( mid , n ) NEW_LINE DEDENT return find ( dividend , divisor , start , end ) NEW_LINE DEDENT
def divide ( dividend , divisor ) : NEW_LINE INDENT return find ( dividend , divisor , 1 , dividend ) NEW_LINE DEDENT
def get ( a , b , n ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = 1e6 NEW_LINE ans = 0 NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE dig = ceil ( ( mid * log ( mid , b ) + log ( a , b ) ) ) NEW_LINE if ( dig > n ) : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE lo = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def FindRank ( arr , length ) : NEW_LINE INDENT print ( 1 , end = " " ) NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT rank = 1 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT rank = rank + 1 NEW_LINE DEDENT DEDENT print ( rank , end = " " ) NEW_LINE DEDENT DEDENT
def findFibonacci ( N ) : NEW_LINE INDENT global fib NEW_LINE i = N // 2 NEW_LINE while ( i > 1 ) : NEW_LINE INDENT if ( i in fib and ( N - i ) in fib ) : NEW_LINE INDENT print ( i , ( N - i ) ) NEW_LINE return NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( "-1" ) NEW_LINE DEDENT
def createHash ( ) : NEW_LINE INDENT global fibonacci NEW_LINE prev , curr = 0 , 1 NEW_LINE fibonacci . add ( prev ) NEW_LINE fibonacci . add ( curr ) NEW_LINE while ( curr <= MAX ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if temp <= MAX : NEW_LINE INDENT fibonacci . add ( temp ) NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT
def checkArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in fibonacci ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum in fibonacci ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def compute ( sz ) : NEW_LINE INDENT isFib = [ False ] * ( sz + 1 ) NEW_LINE prev = 0 NEW_LINE curr = 1 NEW_LINE isFib [ prev ] = True NEW_LINE isFib [ curr ] = True NEW_LINE while ( curr <= sz ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if ( temp <= sz ) : NEW_LINE INDENT isFib [ temp ] = True NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT fibUpto [ 0 ] = 1 NEW_LINE for i in range ( 1 , sz + 1 ) : NEW_LINE INDENT fibUpto [ i ] = fibUpto [ i - 1 ] NEW_LINE if ( isFib [ i ] ) : NEW_LINE INDENT fibUpto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT
def countOfNumbers ( N , K ) : NEW_LINE INDENT compute ( N ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid - fibUpto [ mid ] >= K ) : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT if ( ans ) : NEW_LINE INDENT return ( N - ans + 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def precompute ( s , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT f [ ord ( s [ i ] ) - ord ( 'a' ) ] [ i ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT f [ i ] [ j ] += f [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT
def palindromicSubsequencesUtil ( L , R ) : NEW_LINE INDENT ok = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT cnt = f [ i ] [ R ] NEW_LINE if ( L > 0 ) : NEW_LINE INDENT cnt -= f [ i ] [ L - 1 ] NEW_LINE DEDENT if ( cnt > 1 ) : NEW_LINE INDENT ok = 1 NEW_LINE c = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ok == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT
def longestFibSubarray ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE hash = { int } NEW_LINE createHash ( hash , max_val ) NEW_LINE left = [ 0 for i in range ( n ) ] NEW_LINE right = [ 0 for i in range ( n ) ] NEW_LINE fibcount = 0 NEW_LINE res = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT left [ i ] = fibcount NEW_LINE if ( arr [ i ] in hash ) : NEW_LINE INDENT fibcount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT fibcount = 0 NEW_LINE DEDENT DEDENT fibcount = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT right [ i ] = fibcount NEW_LINE if ( arr [ i ] in hash ) : NEW_LINE INDENT fibcount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT fibcount = 0 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT res = max ( res , left [ i ] + right [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def isPrime ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N < 4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( N & 1 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr = 5 NEW_LINE s = sqrt ( N ) NEW_LINE while ( curr <= s ) : NEW_LINE INDENT if ( N % curr == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr += 2 NEW_LINE if ( N % curr == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr += 4 NEW_LINE DEDENT return True NEW_LINE DEDENT
def check ( s , p , prefix_sum , n ) : NEW_LINE INDENT satisfies = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i + s - 1 >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( i - 1 >= 0 ) : NEW_LINE INDENT x = prefix_sum [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT x = 0 NEW_LINE DEDENT if ( prefix_sum [ i + s - 1 ] - x < p ) : NEW_LINE INDENT satisfies = False NEW_LINE DEDENT DEDENT return satisfies NEW_LINE DEDENT
def minimumWindowSize ( x , y , p ) : NEW_LINE INDENT prefix_sum = [ 0 ] * ( y - x + 1 ) NEW_LINE for i in range ( x , y + 1 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT prefix_sum [ i - x ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , y - x + 1 ) : NEW_LINE INDENT prefix_sum [ i ] += prefix_sum [ i - 1 ] NEW_LINE DEDENT low = 1 NEW_LINE high = y - x + 1 NEW_LINE while ( high - low > 1 ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( check ( mid , p , prefix_sum , y - x + 1 ) ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid NEW_LINE DEDENT DEDENT if ( check ( low , p , prefix_sum , y - x + 1 ) ) : NEW_LINE INDENT return low NEW_LINE DEDENT return high NEW_LINE DEDENT
def preProcess ( mat , aux ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT aux [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT aux [ i ] [ j ] = ( mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , M ) : NEW_LINE INDENT aux [ i ] [ j ] += aux [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT
def sumQuery ( aux , tli , tlj , rbi , rbj ) : NEW_LINE INDENT res = aux [ rbi ] [ rbj ] NEW_LINE if ( tli > 0 ) : NEW_LINE INDENT res = res - aux [ tli - 1 ] [ rbj ] NEW_LINE DEDENT if ( tlj > 0 ) : NEW_LINE INDENT res = res - aux [ rbi ] [ tlj - 1 ] NEW_LINE DEDENT if ( tli > 0 and tlj > 0 ) : NEW_LINE INDENT res = ( res + aux [ tli - 1 ] [ tlj - 1 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def maximumSquareSize ( mat , K ) : NEW_LINE INDENT aux = [ [ 0 for x in range ( M ) ] for y in range ( N ) ] NEW_LINE preProcess ( mat , aux ) NEW_LINE for i in range ( min ( N , M ) , 0 , - 1 ) : NEW_LINE INDENT satisfies = True NEW_LINE for x in range ( N ) : NEW_LINE INDENT for y in range ( M ) : NEW_LINE INDENT if ( x + i - 1 <= N - 1 and y + i - 1 <= M - 1 ) : NEW_LINE INDENT if ( sumQuery ( aux , x , y , x + i - 1 , y + i - 1 ) > K ) : NEW_LINE INDENT satisfies = False NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( satisfies == True ) : NEW_LINE INDENT return ( i ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def preProcess ( mat , aux ) : NEW_LINE INDENT for i in range ( 5 ) : NEW_LINE INDENT aux [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE DEDENT for i in range ( 1 , 4 ) : NEW_LINE INDENT for j in range ( 5 ) : NEW_LINE INDENT aux [ i ] [ j ] = ( mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 1 , 5 ) : NEW_LINE INDENT aux [ i ] [ j ] += aux [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return aux NEW_LINE DEDENT
def sumQuery ( aux , tli , tlj , rbi , rbj ) : NEW_LINE INDENT res = aux [ rbi ] [ rbj ] NEW_LINE if ( tli > 0 ) : NEW_LINE INDENT res = res - aux [ tli - 1 ] [ rbj ] NEW_LINE DEDENT if ( tlj > 0 ) : NEW_LINE INDENT res = res - aux [ rbi ] [ tlj - 1 ] NEW_LINE DEDENT if ( tli > 0 and tlj > 0 ) : NEW_LINE INDENT res = res + aux [ tli - 1 ] [ tlj - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def check ( mid , aux , K ) : NEW_LINE INDENT satisfies = True NEW_LINE for x in range ( 4 ) : NEW_LINE INDENT for y in range ( 5 ) : NEW_LINE INDENT if ( x + mid - 1 <= 4 - 1 and y + mid - 1 <= 5 - 1 ) : NEW_LINE INDENT if ( sumQuery ( aux , x , y , x + mid - 1 , y + mid - 1 ) > K ) : NEW_LINE INDENT satisfies = False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True if satisfies == True else False NEW_LINE DEDENT
def maximumSquareSize ( mat , K ) : NEW_LINE INDENT aux = [ [ 0 for i in range ( 5 ) ] for i in range ( 4 ) ] NEW_LINE aux = preProcess ( mat , aux ) NEW_LINE low , high = 1 , min ( 4 , 5 ) NEW_LINE mid = 0 NEW_LINE while ( high - low > 1 ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( check ( mid , aux , K ) ) : NEW_LINE INDENT low = mid NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT if ( check ( high , aux , K ) ) : NEW_LINE INDENT return high NEW_LINE DEDENT return low NEW_LINE DEDENT
def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT
def add_factors ( n , mp ) : NEW_LINE INDENT for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 , ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE mp [ n // i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def removeDuplicates ( arr , n ) : NEW_LINE INDENT st = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 2 and arr [ i ] == arr [ i + 1 ] and arr [ i ] == arr [ i + 2 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT arr [ st ] = arr [ i ] NEW_LINE st += 1 NEW_LINE DEDENT DEDENT print ( "{" , end = "" ) NEW_LINE for i in range ( st ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ) NEW_LINE if ( i != st - 1 ) : NEW_LINE INDENT print ( ", " , end = "" ) NEW_LINE DEDENT DEDENT print ( "}" , end = "" ) NEW_LINE DEDENT
def permutation ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE maxEle = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT if ( maxEle != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( s ) == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findPivot ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( arr [ low ] > arr [ mid ] ) : NEW_LINE INDENT return findPivot ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findPivot ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT
def isRotated ( arr , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE pivot = - 1 NEW_LINE if ( arr [ l ] > arr [ r ] ) : NEW_LINE INDENT pivot = findPivot ( arr , l , r ) NEW_LINE temp = pivot NEW_LINE if ( l < pivot ) : NEW_LINE INDENT while ( pivot > l ) : NEW_LINE INDENT if ( arr [ pivot ] < arr [ pivot - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT pivot -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT pivot = temp NEW_LINE pivot += 1 NEW_LINE while ( pivot < r ) : NEW_LINE INDENT if ( arr [ pivot ] > arr [ pivot + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT pivot + + 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def state1 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == 'a' ) : NEW_LINE INDENT nfa = 2 NEW_LINE DEDENT elif ( c == 'b' or c == 'c' ) : NEW_LINE INDENT nfa = 1 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT
def state2 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == 'a' ) : NEW_LINE INDENT nfa = 3 NEW_LINE DEDENT elif ( c == 'b' or c == 'c' ) : NEW_LINE INDENT nfa = 2 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT
def state3 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == 'a' ) : NEW_LINE INDENT nfa = 1 NEW_LINE DEDENT elif ( c == 'b' or c == 'c' ) : NEW_LINE INDENT nfa = 3 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT
def state4 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == 'b' ) : NEW_LINE INDENT nfa = 5 NEW_LINE DEDENT elif ( c == 'a' or c == 'c' ) : NEW_LINE INDENT nfa = 4 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT
def state5 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == 'b' ) : NEW_LINE INDENT nfa = 6 NEW_LINE DEDENT elif ( c == 'a' or c == 'c' ) : NEW_LINE INDENT nfa = 5 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT
def state6 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == 'b' ) : NEW_LINE INDENT nfa = 4 NEW_LINE DEDENT elif ( c == 'a' or c == 'c' ) : NEW_LINE INDENT nfa = 6 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT
def state7 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == 'c' ) : NEW_LINE INDENT nfa = 8 NEW_LINE DEDENT elif ( c == 'b' or c == 'a' ) : NEW_LINE INDENT nfa = 7 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT
def state9 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == 'c' ) : NEW_LINE INDENT nfa = 7 NEW_LINE DEDENT elif ( c == 'b' or c == 'a' ) : NEW_LINE INDENT nfa = 9 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT
def checkA ( s , x ) : NEW_LINE INDENT global nfa , flag NEW_LINE for i in range ( x ) : NEW_LINE INDENT if ( nfa == 1 ) : NEW_LINE INDENT state1 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 2 ) : NEW_LINE INDENT state2 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 3 ) : NEW_LINE INDENT state3 ( s [ i ] ) NEW_LINE DEDENT DEDENT if ( nfa == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT nfa = 4 NEW_LINE DEDENT DEDENT
def checkB ( s , x ) : NEW_LINE INDENT global nfa , flag NEW_LINE for i in range ( x ) : NEW_LINE INDENT if ( nfa == 4 ) : NEW_LINE INDENT state4 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 5 ) : NEW_LINE INDENT state5 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 6 ) : NEW_LINE INDENT state6 ( s [ i ] ) NEW_LINE DEDENT DEDENT if ( nfa == 4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT nfa = 7 NEW_LINE DEDENT DEDENT
def checkC ( s , x ) : NEW_LINE INDENT global nfa , flag NEW_LINE for i in range ( x ) : NEW_LINE INDENT if ( nfa == 7 ) : NEW_LINE INDENT state7 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 8 ) : NEW_LINE INDENT state8 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 9 ) : NEW_LINE INDENT state9 ( s [ i ] ) NEW_LINE DEDENT DEDENT if ( nfa == 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def getPositionCount ( a , n ) : NEW_LINE INDENT count = 1 NEW_LINE min = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] <= min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def CountSubSet ( arr , n , X ) : NEW_LINE INDENT N = 2 ** n NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT if ( arr [ j ] == X ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def calculatePower ( b , e ) : NEW_LINE INDENT ans = 1 NEW_LINE while ( e > 0 ) : NEW_LINE INDENT if ( e % 2 == 1 ) : NEW_LINE INDENT ans = ans * b NEW_LINE DEDENT e = e // 2 NEW_LINE b = b * b NEW_LINE DEDENT return ans NEW_LINE DEDENT
def CountSubSet ( arr , n , X ) : NEW_LINE INDENT count = 0 NEW_LINE checkX = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == X ) : NEW_LINE INDENT checkX = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( checkX == 1 ) : NEW_LINE INDENT count = calculatePower ( 2 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT return count NEW_LINE DEDENT
def build ( A , start , end , node ) : NEW_LINE INDENT if ( start == end ) : NEW_LINE INDENT segment_tree [ node ] = A [ start ] NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE segment_tree [ node ] = max ( build ( A , start , mid , 2 * node + 1 ) , build ( A , mid + 1 , end , 2 * node + 2 ) ) NEW_LINE DEDENT return segment_tree [ node ] NEW_LINE DEDENT
def query ( start , end , l , r , node ) : NEW_LINE INDENT if ( start > r or end < l ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( start >= l and end <= r ) : NEW_LINE INDENT return segment_tree [ node ] NEW_LINE DEDENT mid = ( start + end ) // 2 NEW_LINE return max ( query ( start , mid , l , r , 2 * node + 1 ) , query ( mid + 1 , end , l , r , 2 * node + 2 ) ) NEW_LINE DEDENT
def longestSubArray ( A , N , K ) : NEW_LINE INDENT res = 1 NEW_LINE preSum = [ 0 ] * ( N + 1 ) NEW_LINE preSum [ 0 ] = A [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT preSum [ i + 1 ] = preSum [ i ] + A [ i ] NEW_LINE DEDENT build ( A , 0 , N - 1 , 0 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT start = i NEW_LINE end = N - 1 NEW_LINE max_index = i NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE max_element = query ( 0 , N - 1 , i , mid , 0 ) NEW_LINE expected_sum = ( mid - i + 1 ) * max_element NEW_LINE actual_sum = preSum [ mid + 1 ] - preSum [ i ] NEW_LINE if ( expected_sum - actual_sum <= K ) : NEW_LINE INDENT start = mid + 1 NEW_LINE max_index = max ( max_index , mid ) NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT res = max ( res , max_index - i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def solve ( arr , n , k ) : NEW_LINE INDENT max_len = 0 NEW_LINE l = 0 NEW_LINE r = n NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if ( maxSum ( arr , n , m ) > k ) : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE max_len = m NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT
def countNums ( l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT lastDigit = ( i % 10 ) NEW_LINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def findMinimumK ( a , n , s ) : NEW_LINE INDENT maximum = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT maximum = max ( maximum , a [ i ] ) NEW_LINE DEDENT low = 1 NEW_LINE high = maximum + 1 NEW_LINE ans = high NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( a [ i ] // mid ) NEW_LINE DEDENT if ( sum > s ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , mid ) NEW_LINE high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def allDigits ( st , le ) : NEW_LINE INDENT present = [ False for i in range ( MAX ) ] NEW_LINE for i in range ( le ) : NEW_LINE INDENT if ( isDigit ( st [ i ] ) ) : NEW_LINE INDENT digit = ord ( st [ i ] ) - ord ( '0' ) NEW_LINE present [ digit ] = True NEW_LINE DEDENT DEDENT for i in range ( MAX ) : NEW_LINE INDENT if ( present [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isPlusPossible ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT foundModOne = False NEW_LINE for x in mp : NEW_LINE INDENT element = x NEW_LINE frequency = mp [ x ] NEW_LINE if ( frequency % 4 == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( frequency % 4 == 1 ) : NEW_LINE INDENT if ( foundModOne == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT foundModOne = True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def merge ( v1 , v2 ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE v = [ ] NEW_LINE while ( i < len ( v1 ) and j < len ( v2 ) ) : NEW_LINE INDENT if ( v1 [ i ] <= v2 [ j ] ) : NEW_LINE INDENT v . append ( v1 [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( v2 [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for k in range ( i , len ( v1 ) ) : NEW_LINE INDENT v . append ( v1 [ k ] ) NEW_LINE DEDENT for k in range ( j , len ( v2 ) ) : NEW_LINE INDENT v . append ( v2 [ k ] ) NEW_LINE DEDENT return v NEW_LINE DEDENT
def buildTree ( tree , arr , index , s , e ) : NEW_LINE INDENT if ( s == e ) : NEW_LINE INDENT tree [ index ] . append ( arr [ s ] ) NEW_LINE return NEW_LINE DEDENT mid = ( s + e ) // 2 NEW_LINE buildTree ( tree , arr , 2 * index , s , mid ) NEW_LINE buildTree ( tree , arr , 2 * index + 1 , mid + 1 , e ) NEW_LINE tree [ index ] = merge ( tree [ 2 * index ] , tree [ 2 * index + 1 ] ) NEW_LINE DEDENT
def query ( tree , index , s , e , l , r , k ) : NEW_LINE INDENT if ( r < s or l > e ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( s >= l and e <= r ) : NEW_LINE INDENT return len ( tree [ index ] ) - ( lower_bound ( tree [ index ] , k ) ) NEW_LINE DEDENT mid = ( s + e ) // 2 NEW_LINE return ( query ( tree , 2 * index , s , mid , l , r , k ) + query ( tree , 2 * index + 1 , mid + 1 , e , l , r , k ) ) NEW_LINE DEDENT
def findGCDSum ( n , a ) : NEW_LINE INDENT GCDSum = 0 NEW_LINE tempGCD = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT tempGCD = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT tempGCD = __gcd ( tempGCD , a [ k ] ) NEW_LINE DEDENT GCDSum += tempGCD NEW_LINE DEDENT DEDENT return GCDSum NEW_LINE DEDENT
def buildSparseTable ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT SparseTable [ i ] [ 0 ] = a [ i ] NEW_LINE DEDENT for j in range ( 1 , 20 ) : NEW_LINE INDENT for i in range ( n - ( 1 << j ) + 1 ) : NEW_LINE INDENT SparseTable [ i ] [ j ] = __gcd ( SparseTable [ i ] [ j - 1 ] , SparseTable [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT
def queryForGCD ( L , R ) : NEW_LINE INDENT j = floor ( log ( R - L + 1 , 2 ) ) NEW_LINE returnValue = __gcd ( SparseTable [ L ] [ j ] , SparseTable [ R - ( 1 << j ) + 1 ] [ j ] ) NEW_LINE return returnValue NEW_LINE DEDENT
def calculateSum ( a , n ) : NEW_LINE INDENT buildSparseTable ( a , n ) NEW_LINE tempAns = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT endPointer = i NEW_LINE startPointer = i NEW_LINE prevEndPointer = i NEW_LINE tempGCD = a [ i ] NEW_LINE while ( endPointer < n ) : NEW_LINE INDENT endPointer = nextPosition ( tempGCD , startPointer , prevEndPointer , n ) NEW_LINE tempAns += ( ( endPointer - prevEndPointer ) * tempGCD ) NEW_LINE prevEndPointer = endPointer NEW_LINE if ( endPointer < n ) : NEW_LINE INDENT tempGCD = __gcd ( tempGCD , a [ endPointer ] ) NEW_LINE DEDENT DEDENT DEDENT return tempAns NEW_LINE DEDENT
def isSquarePossible ( arr , n , l ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] >= l : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if cnt >= l : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def maxArea ( arr , n ) : NEW_LINE INDENT l , r = 0 , n NEW_LINE len = 0 NEW_LINE while l <= r : NEW_LINE INDENT m = l + ( ( r - l ) // 2 ) NEW_LINE if isSquarePossible ( arr , n , m ) : NEW_LINE INDENT len = m NEW_LINE l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return ( len * len ) NEW_LINE DEDENT
def find_triplet ( array , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT indices [ i ] = [ ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT indices [ array [ i ] ] . append ( i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT y = array [ i ] NEW_LINE for j in range ( ROW ) : NEW_LINE INDENT s = test [ j ] [ 1 ] * y NEW_LINE if s % test [ j ] [ 0 ] != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if s % test [ j ] [ 2 ] != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT x = s // test [ j ] [ 0 ] NEW_LINE z = s // test [ j ] [ 2 ] NEW_LINE if x > MAX or z > MAX : NEW_LINE INDENT continue NEW_LINE DEDENT l = 0 NEW_LINE r = len ( indices [ x ] ) - 1 NEW_LINE first = - 1 NEW_LINE while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if indices [ x ] [ m ] < i : NEW_LINE INDENT first = m NEW_LINE l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT l = 0 NEW_LINE r = len ( indices [ z ] ) - 1 NEW_LINE third = - 1 NEW_LINE while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if indices [ z ] [ m ] > i : NEW_LINE INDENT third = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if first != - 1 and third != - 1 : NEW_LINE INDENT answer += ( first + 1 ) * ( len ( indices [ z ] ) - third ) NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT
def lcm ( A , B ) : NEW_LINE INDENT return ( A * B ) // gcd ( A , B ) NEW_LINE DEDENT
def checkA ( A , B , C , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = K NEW_LINE ans = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE value = A * mid NEW_LINE divA = mid - 1 NEW_LINE divB = value // B - 1 if ( value % B == 0 ) else value // B NEW_LINE divC = value // C - 1 if ( value % C == 0 ) else value // C NEW_LINE divAB = value // lcm ( A , B ) - 1 if ( value % lcm ( A , B ) == 0 ) else value // lcm ( A , B ) NEW_LINE divBC = value // lcm ( C , B ) - 1 if ( value % lcm ( C , B ) == 0 ) else value // lcm ( C , B ) NEW_LINE divAC = value // lcm ( A , C ) - 1 if ( value % lcm ( A , C ) == 0 ) else value // lcm ( A , C ) NEW_LINE divABC = value // lcm ( A , lcm ( B , C ) ) - 1 if ( value % lcm ( A , lcm ( B , C ) ) == 0 ) else value // lcm ( A , lcm ( B , C ) ) NEW_LINE elem = divA + divB + divC - divAC - divBC - divAB + divABC NEW_LINE if ( elem == ( K - 1 ) ) : NEW_LINE INDENT ans = value NEW_LINE break NEW_LINE DEDENT elif ( elem > ( K - 1 ) ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def checkB ( A , B , C , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = K NEW_LINE ans = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE value = B * mid NEW_LINE divB = mid - 1 NEW_LINE if ( value % A == 0 ) : NEW_LINE INDENT divA = value // A - 1 NEW_LINE DEDENT else : NEW_LINE INDENT value // A NEW_LINE DEDENT if ( value % C == 0 ) : NEW_LINE INDENT divC = value // C - 1 NEW_LINE DEDENT else : NEW_LINE INDENT value // C NEW_LINE DEDENT if ( value % lcm ( A , B ) == 0 ) : NEW_LINE INDENT divAB = value // lcm ( A , B ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT value // lcm ( A , B ) NEW_LINE DEDENT if ( value % lcm ( C , B ) == 0 ) : NEW_LINE INDENT divBC = value // lcm ( C , B ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT value // lcm ( C , B ) NEW_LINE DEDENT if ( value % lcm ( A , C ) == 0 ) : NEW_LINE INDENT divAC = value // lcm ( A , C ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT value // lcm ( A , C ) NEW_LINE DEDENT if ( value % lcm ( A , lcm ( B , C ) ) == 0 ) : NEW_LINE INDENT divABC = value // lcm ( A , lcm ( B , C ) ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT value // lcm ( A , lcm ( B , C ) ) NEW_LINE DEDENT elem = divA + divB + divC - divAC - divBC - divAB + divABC NEW_LINE if ( elem == ( K - 1 ) ) : NEW_LINE INDENT ans = value NEW_LINE break NEW_LINE DEDENT elif ( elem > ( K - 1 ) ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def checkC ( A , B , C , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = K NEW_LINE ans = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE value = C * mid NEW_LINE divC = mid - 1 NEW_LINE if ( value % B == 0 ) : NEW_LINE INDENT divB = value // B - 1 NEW_LINE DEDENT else : NEW_LINE INDENT value // B NEW_LINE DEDENT if ( value % A == 0 ) : NEW_LINE INDENT divA = value // A - 1 NEW_LINE DEDENT else : NEW_LINE INDENT value // A NEW_LINE DEDENT if ( value % lcm ( A , B ) == 0 ) : NEW_LINE INDENT divAB = value // lcm ( A , B ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT value // lcm ( A , B ) NEW_LINE DEDENT if ( value % lcm ( C , B ) == 0 ) : NEW_LINE INDENT divBC = value // lcm ( C , B ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT value // lcm ( C , B ) NEW_LINE DEDENT if ( value % lcm ( A , C ) == 0 ) : NEW_LINE INDENT divAC = value // lcm ( A , C ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT value // lcm ( A , C ) NEW_LINE DEDENT if ( value % lcm ( A , lcm ( B , C ) ) == 0 ) : NEW_LINE INDENT divABC = value // lcm ( A , lcm ( B , C ) ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT value // lcm ( A , lcm ( B , C ) ) NEW_LINE DEDENT elem = divA + divB + divC - divAC - divBC - divAB + divABC NEW_LINE if ( elem == ( K - 1 ) ) : NEW_LINE INDENT ans = value NEW_LINE break NEW_LINE DEDENT elif ( elem > ( K - 1 ) ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findKthMultiple ( A , B , C , K ) : NEW_LINE INDENT res = checkA ( A , B , C , K ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT res = checkB ( A , B , C , K ) NEW_LINE DEDENT if ( res == - 1 ) : NEW_LINE INDENT res = checkC ( A , B , C , K ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def kthSmallest ( a , left , right , k ) : NEW_LINE INDENT while left <= right : NEW_LINE INDENT pivotIndex = partition ( a , left , right ) NEW_LINE if pivotIndex == k - 1 : NEW_LINE INDENT return a [ pivotIndex ] NEW_LINE DEDENT elif pivotIndex > k - 1 : NEW_LINE INDENT right = pivotIndex - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = pivotIndex + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def calculateDifference ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , max_val + 1 ) : NEW_LINE INDENT if p * p > max_val + 1 : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT X1 = 1 NEW_LINE X2 = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT X1 ^= arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] != 1 ) : NEW_LINE INDENT X2 ^= arr [ i ] NEW_LINE DEDENT DEDENT return abs ( X1 - X2 ) NEW_LINE DEDENT
def containsElement ( arr , n ) : NEW_LINE INDENT xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = xorArr ^ arr [ i ] NEW_LINE if ( arr [ i ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def Square ( n , i , j ) : NEW_LINE INDENT mid = ( i + j ) / 2 NEW_LINE mul = mid * mid NEW_LINE if ( ( mul == n ) or ( abs ( mul - n ) < 0.00001 ) ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( mul < n ) : NEW_LINE INDENT return Square ( n , mid , j ) NEW_LINE DEDENT else : NEW_LINE INDENT return Square ( n , i , mid ) NEW_LINE DEDENT DEDENT
def length_substring ( S , K ) : NEW_LINE INDENT curr_cnt = 0 NEW_LINE prev_cnt = 0 NEW_LINE max_len = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if ( S [ i ] == K ) : NEW_LINE INDENT curr_cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT prev_cnt = max ( prev_cnt , curr_cnt ) NEW_LINE curr_cnt = 0 NEW_LINE DEDENT DEDENT prev_cnt = max ( prev_cnt , curr_cnt ) NEW_LINE max_len = prev_cnt NEW_LINE return max_len NEW_LINE DEDENT
def Xor_Sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE index , left_xor = 0 , 0 NEW_LINE right_xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT left_xor = left_xor ^ arr [ i ] NEW_LINE right_xor = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT right_xor = right_xor ^ arr [ j ] NEW_LINE DEDENT if ( left_xor + right_xor > sum ) : NEW_LINE INDENT sum = left_xor + right_xor NEW_LINE index = i NEW_LINE DEDENT DEDENT return index + 1 NEW_LINE DEDENT
def ComputePrefixXor ( arr , PrefixXor , n ) : NEW_LINE INDENT PrefixXor [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT PrefixXor [ i ] = PrefixXor [ i - 1 ] ^ arr [ i ] NEW_LINE DEDENT DEDENT
def Xor_Sum ( arr , n ) : NEW_LINE INDENT PrefixXor = [ 0 ] * n NEW_LINE ComputePrefixXor ( arr , PrefixXor , n ) NEW_LINE sum , index = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( PrefixXor [ i ] + ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) > sum ) : NEW_LINE INDENT sum = PrefixXor [ i ] + ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) NEW_LINE index = i NEW_LINE DEDENT DEDENT return index + 1 NEW_LINE DEDENT
def buildMapWithColor ( arr , n ) : NEW_LINE INDENT mapWithColor = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mapWithColor [ arr [ i ] ] = i + 1 NEW_LINE DEDENT return mapWithColor NEW_LINE DEDENT
def isPalindrome ( str , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def maxLenPalindrome ( str , n , ch ) : NEW_LINE INDENT maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == ch ) : NEW_LINE INDENT for j in range ( n - 1 , i + 1 , - 1 ) : NEW_LINE INDENT if ( str [ j ] == ch ) : NEW_LINE INDENT if ( isPalindrome ( str , i , j ) ) : NEW_LINE INDENT maxLen = max ( maxLen , j - i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
def findCount ( a , b , n , m ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE smallestFreq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = a [ i ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT freq [ i ] = 0 NEW_LINE DEDENT for j in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ j ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for j in range ( MAX ) : NEW_LINE INDENT if ( freq [ j ] ) : NEW_LINE INDENT smallestFreq . append ( freq [ j ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT smallestFreq = sorted ( smallestFreq ) NEW_LINE ans = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT s = b [ i ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT freq [ i ] = 0 NEW_LINE DEDENT for j in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ j ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT frequency = 0 NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT if ( freq [ j ] ) : NEW_LINE INDENT frequency = freq [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT ind = lower_bound ( smallestFreq , frequency ) NEW_LINE ans . append ( ind ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def printAnswer ( a , b , n , m ) : NEW_LINE INDENT ans = findCount ( a , b , n , m ) NEW_LINE for it in ans : NEW_LINE INDENT print ( it , end = " " ) NEW_LINE DEDENT DEDENT
def linearCheck ( ar , arr ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT matched = True NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ar [ i ] [ j ] != arr [ j ] ) : NEW_LINE INDENT matched = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( matched ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def compareRow ( a1 , a2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a1 [ i ] < a2 [ i ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( a1 [ i ] > a2 [ i ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def binaryCheck ( ar , arr ) : NEW_LINE INDENT l = 0 NEW_LINE r = m - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE temp = compareRow ( ar [ mid ] , arr ) NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT elif ( temp == 1 ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findCnt ( arr , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE if ( arr [ i ] > k or arr [ i ] < - 1 * k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ( arr [ 0 ] > k or arr [ 0 ] < - 1 * k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT arr = sorted ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += n - upper_bound ( arr , arr [ i ] + k ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def FindIntersection ( type1 , n , type2 , m ) : NEW_LINE INDENT ans = n * m NEW_LINE start = [ ] NEW_LINE end = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT start . append ( type1 [ i ] [ 0 ] ) NEW_LINE end . append ( type1 [ i ] [ 1 ] ) NEW_LINE DEDENT start = sorted ( start ) NEW_LINE start = sorted ( end ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT L = type2 [ i ] [ 0 ] NEW_LINE R = type2 [ i ] [ 1 ] NEW_LINE ans -= ( len ( start ) - upper_bound ( start , R ) ) NEW_LINE ans -= ( upper_bound ( end , L - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def lcm ( a , b ) : NEW_LINE INDENT return ( ( a * b ) // gcd ( a , b ) ) NEW_LINE DEDENT
def divTermCount ( a , b , c , num ) : NEW_LINE INDENT return ( ( num // a ) + ( num // b ) + ( num // c ) - ( num // lcm ( a , b ) ) - ( num // lcm ( b , c ) ) - ( num // lcm ( a , c ) ) + ( num // lcm ( a , lcm ( b , c ) ) ) ) NEW_LINE DEDENT
def findNthTerm ( a , b , c , n ) : NEW_LINE INDENT low = 1 NEW_LINE high = 10 ** 9 NEW_LINE mid = 0 NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( divTermCount ( a , b , c , mid ) < n ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT
def setZero ( freq ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT freq [ i ] = 0 NEW_LINE DEDENT DEDENT
def preCalculate ( string , n ) : NEW_LINE INDENT freq [ ord ( string [ 0 ] ) ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT charToUpdate = chr ( j ) NEW_LINE if charToUpdate == ch : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def getFrequency ( ch , l , r ) : NEW_LINE INDENT if l == 0 : NEW_LINE INDENT return freq [ ord ( ch ) ] [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( freq [ ord ( ch ) ] [ r ] - freq [ ord ( ch ) ] [ l - 1 ] ) NEW_LINE DEDENT DEDENT
def firstNonRepeating ( string , n , l , r ) : NEW_LINE INDENT t = [ "" ] * 2 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if getFrequency ( ch , l , r ) == 1 : NEW_LINE INDENT t [ 0 ] = ch NEW_LINE return t [ 0 ] NEW_LINE DEDENT DEDENT return "-1" NEW_LINE DEDENT
def maxLength ( s , n ) : NEW_LINE INDENT ans = - ( sys . maxsize + 1 ) NEW_LINE A , L , R = [ ] , [ ] , [ ] NEW_LINE freq = [ 0 ] * ( n + 5 ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ord ( s [ j ] ) - ord ( 'a' ) == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT freq [ j ] = count NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT L . append ( ( 2 * freq [ j - 1 ] ) - j ) NEW_LINE R . append ( ( 2 * freq [ j ] ) - j ) NEW_LINE DEDENT max_len = - ( sys . maxsize + 1 ) NEW_LINE min_val = sys . maxsize NEW_LINE for j in range ( n ) : NEW_LINE INDENT min_val = min ( min_val , L [ j ] ) NEW_LINE A . append ( min_val ) NEW_LINE l = 0 NEW_LINE r = j NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE if ( A [ mid ] <= R [ j ] ) : NEW_LINE INDENT max_len = max ( max_len , j - mid + 1 ) NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT DEDENT ans = max ( ans , max_len ) NEW_LINE A . clear ( ) NEW_LINE R . clear ( ) NEW_LINE L . clear ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minOperations ( arr , n ) : NEW_LINE INDENT start = arr [ n - 1 ] NEW_LINE end = max ( arr ) + n NEW_LINE max_arr = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( check ( mid , n , arr ) ) : NEW_LINE INDENT max_arr = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT desired = [ 0 ] * n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT desired [ i ] = max_arr NEW_LINE max_arr -= 1 NEW_LINE DEDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT operations += ( desired [ i ] - arr [ i ] ) NEW_LINE DEDENT return operations NEW_LINE DEDENT
def countNode ( head ) : NEW_LINE INDENT count = 0 NEW_LINE while ( head . next != None ) : NEW_LINE INDENT ptr = head . next NEW_LINE while ( ptr != None ) : NEW_LINE INDENT if ( head . data == ptr . data ) : NEW_LINE INDENT count = count + 1 NEW_LINE break NEW_LINE DEDENT ptr = ptr . next NEW_LINE DEDENT head = head . next NEW_LINE DEDENT return count NEW_LINE DEDENT
def insert ( ref_head , item ) : NEW_LINE INDENT global head NEW_LINE temp = Node ( ) NEW_LINE temp . data = item NEW_LINE temp . next = ref_head NEW_LINE head = temp NEW_LINE DEDENT
def countNode ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = set ( ) NEW_LINE s . add ( head . data ) NEW_LINE count = 0 NEW_LINE curr = head . next NEW_LINE while ( curr != None ) : NEW_LINE INDENT if ( curr . data in s ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT s . add ( curr . data ) NEW_LINE curr = curr . next NEW_LINE DEDENT return count NEW_LINE DEDENT
def countLessThan ( arr , n , key ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE index = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if ( arr [ m ] < key ) : NEW_LINE INDENT l = m + 1 NEW_LINE index = m NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return ( index + 1 ) NEW_LINE DEDENT
def countGreaterThan ( arr , n , key ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE index = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if ( arr [ m ] <= key ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE index = m NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( n - index ) NEW_LINE DEDENT
def countTriplets ( n , a , b , c ) : NEW_LINE INDENT a . sort NEW_LINE b . sort ( ) NEW_LINE c . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current = b [ i ] NEW_LINE a_index = - 1 NEW_LINE c_index = - 1 NEW_LINE low = countLessThan ( a , n , current ) NEW_LINE high = countGreaterThan ( c , n , current ) NEW_LINE count += ( low * high ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) // 2 NEW_LINE high = ( n + 1 - k ) // 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def firstRepeating ( string ) : NEW_LINE INDENT visited = [ False ] * NO_OF_CHARS NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT res = - 1 NEW_LINE for i in range ( len ( string ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( visited [ string . index ( string [ i ] ) ] == False ) : NEW_LINE INDENT visited [ string . index ( string [ i ] ) ] = True NEW_LINE DEDENT else : NEW_LINE INDENT res = i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def minSteps ( arr ) : NEW_LINE INDENT v = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE q = [ [ 0 , 0 ] ] NEW_LINE depth = 0 NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT x = len ( q ) NEW_LINE while ( x > 0 ) : NEW_LINE INDENT y = q [ 0 ] NEW_LINE i = y [ 0 ] NEW_LINE j = y [ 1 ] NEW_LINE q . remove ( q [ 0 ] ) NEW_LINE x -= 1 NEW_LINE if ( v [ i ] [ j ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return depth NEW_LINE DEDENT v [ i ] [ j ] = 1 NEW_LINE if ( i + arr [ i ] [ j ] < n ) : NEW_LINE INDENT q . append ( [ i + arr [ i ] [ j ] , j ] ) NEW_LINE DEDENT if ( j + arr [ i ] [ j ] < n ) : NEW_LINE INDENT q . append ( [ i , j + arr [ i ] [ j ] ] ) NEW_LINE DEDENT DEDENT depth += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def minSteps ( arr , n ) : NEW_LINE INDENT v = [ 0 for i in range ( n ) ] NEW_LINE q = [ ] NEW_LINE q . append ( 0 ) NEW_LINE depth = 0 NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT x = len ( q ) NEW_LINE while ( x >= 1 ) : NEW_LINE INDENT i = q [ 0 ] NEW_LINE q . remove ( i ) NEW_LINE x -= 1 NEW_LINE if ( v [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == n - 1 ) : NEW_LINE INDENT return depth NEW_LINE DEDENT v [ i ] = 1 NEW_LINE if ( i + arr [ i ] < n ) : NEW_LINE INDENT q . append ( i + arr [ i ] ) NEW_LINE DEDENT if ( i - arr [ i ] >= 0 ) : NEW_LINE INDENT q . append ( i - arr [ i ] ) NEW_LINE DEDENT DEDENT depth += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def divisorcount ( elem ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( elem ) ) + 1 ) : NEW_LINE INDENT if ( elem % i == 0 ) : NEW_LINE INDENT if ( i * i == elem ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def findwinner ( A , B , N , M ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT A [ i ] = divisorcount ( A [ i ] ) NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT B [ i ] = divisorcount ( B [ i ] ) NEW_LINE DEDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE winA = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT val = A [ i ] NEW_LINE start = 0 NEW_LINE end = M - 1 NEW_LINE index = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( B [ mid ] <= val ) : NEW_LINE INDENT index = mid NEW_LINE start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT winA += ( index + 1 ) NEW_LINE DEDENT winB = N * M - winA NEW_LINE if ( winA > winB ) : NEW_LINE INDENT return "A" NEW_LINE DEDENT elif ( winB > winA ) : NEW_LINE INDENT return "B" NEW_LINE DEDENT return "Draw" NEW_LINE DEDENT
def minTime ( box , truck , n , m ) : NEW_LINE INDENT box . sort ( ) NEW_LINE truck . sort ( ) NEW_LINE l = 0 NEW_LINE h = 2 * n NEW_LINE min_time = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if ( isPossible ( box , truck , n , m , mid ) ) : NEW_LINE INDENT min_time = mid NEW_LINE h = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return min_time NEW_LINE DEDENT
def isPossible ( arr , n , dist , k ) : NEW_LINE INDENT req = 0 NEW_LINE curr = 0 NEW_LINE prev = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( curr != n and ( arr [ curr ] - arr [ prev ] ) <= dist ) : NEW_LINE INDENT curr = curr + 1 NEW_LINE DEDENT req = req + 1 NEW_LINE if ( curr == n ) : NEW_LINE INDENT break NEW_LINE DEDENT prev = curr - 1 NEW_LINE DEDENT if ( curr != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( req <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def minDistance ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE h = arr [ n - 1 ] NEW_LINE ans = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 NEW_LINE if ( isPossible ( arr , n , m , k ) ) : NEW_LINE INDENT ans = m NEW_LINE h = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def getKthElement ( n , k , L , R ) : NEW_LINE INDENT l = 1 NEW_LINE h = n NEW_LINE total = [ 0 for i in range ( n + 1 ) ] NEW_LINE total [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT total [ i + 1 ] = total [ i ] + ( R [ i ] - L [ i ] ) + 1 NEW_LINE DEDENT index = - 1 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 NEW_LINE if ( total [ m ] > k ) : NEW_LINE INDENT index = m NEW_LINE h = m - 1 NEW_LINE DEDENT elif ( total [ m ] < k ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT index = m NEW_LINE break NEW_LINE DEDENT DEDENT l = L [ index - 1 ] NEW_LINE h = R [ index - 1 ] NEW_LINE x = k - total [ index - 1 ] NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 NEW_LINE if ( ( m - L [ index - 1 ] ) + 1 == x ) : NEW_LINE INDENT return m NEW_LINE DEDENT elif ( ( m - L [ index - 1 ] ) + 1 > x ) : NEW_LINE INDENT h = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT DEDENT
def MinimumX ( a , b , c , k ) : NEW_LINE INDENT x = 10 ** 9 NEW_LINE if ( k <= c ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT h = k - c NEW_LINE l = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 NEW_LINE if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) : NEW_LINE INDENT x = min ( x , m ) NEW_LINE h = m - 1 NEW_LINE DEDENT elif ( ( a * m * m ) + ( b * m ) < ( k - c ) ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def preCalculate ( binary , n , left ) : NEW_LINE INDENT count1 , count0 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT left [ i ] [ 0 ] = count1 NEW_LINE left [ i ] [ 1 ] = count0 NEW_LINE if ( binary [ i ] ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT DEDENT DEDENT
def findMissing ( arr , n ) : NEW_LINE INDENT l , h = 0 , n - 1 NEW_LINE mid = 0 NEW_LINE while ( h > l ) : NEW_LINE INDENT mid = l + ( h - l ) // 2 NEW_LINE if ( arr [ mid ] - mid == arr [ 0 ] ) : NEW_LINE INDENT if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) : NEW_LINE INDENT return arr [ mid ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) : NEW_LINE INDENT return arr [ mid ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def maxSum ( arr , n , K ) : NEW_LINE INDENT maximum = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sumk = 0 NEW_LINE for j in range ( i , n , K ) : NEW_LINE INDENT sumk = sumk + arr [ j ] NEW_LINE DEDENT maximum = max ( maximum , sumk ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
def operations ( op , n , k ) : NEW_LINE INDENT i , count = 0 , 0 NEW_LINE nVal = 0 NEW_LINE minimum = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT nVal += op [ i ] NEW_LINE minimum = min ( minimum , nVal ) NEW_LINE if ( ( k + nVal ) <= 0 ) : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT DEDENT if ( nVal >= 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT times = ( k - abs ( minimum ) ) // abs ( nVal ) NEW_LINE k = ( k - ( times * abs ( nVal ) ) ) NEW_LINE count = ( times * n ) NEW_LINE while ( k > 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT k = k + op [ i ] NEW_LINE count += 1 NEW_LINE if ( k <= 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findMax ( arr , low , high ) : NEW_LINE INDENT if ( high == low ) : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid == 0 and arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if ( mid < high and arr [ mid + 1 ] < arr [ mid ] and mid > 0 and arr [ mid ] > arr [ mid - 1 ] ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if ( arr [ low ] > arr [ mid ] ) : NEW_LINE INDENT return findMax ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findMax ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT
def cal_prefix ( n , arr ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT ar [ i + 1 ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , 1001 , 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT prefix [ i ] [ j ] = 0 NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ar [ j ] <= i : NEW_LINE INDENT k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 0 NEW_LINE DEDENT prefix [ i ] [ j ] = prefix [ i ] [ j - 1 ] + k NEW_LINE DEDENT DEDENT DEDENT
def ksub ( l , r , n , k ) : NEW_LINE INDENT lo = 1 NEW_LINE hi = 1000 NEW_LINE while ( lo + 1 < hi ) : NEW_LINE INDENT mid = int ( ( lo + hi ) / 2 ) NEW_LINE if ( prefix [ mid ] [ r ] - prefix [ mid ] [ l - 1 ] >= k ) : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT if ( prefix [ lo ] [ r ] - prefix [ lo ] [ l - 1 ] >= k ) : NEW_LINE INDENT hi = lo NEW_LINE DEDENT return hi NEW_LINE DEDENT
def binary ( arr , v ) : NEW_LINE INDENT index = lookup_table [ 0 ] - 1 NEW_LINE co = 0 NEW_LINE while lookup_table [ co ] != 0 : NEW_LINE INDENT if v == arr [ index ] : NEW_LINE INDENT return index NEW_LINE DEDENT elif v < arr [ index ] : NEW_LINE INDENT co += 1 NEW_LINE index -= lookup_table [ co ] NEW_LINE DEDENT else : NEW_LINE INDENT co += 1 NEW_LINE index += lookup_table [ co ] NEW_LINE DEDENT DEDENT DEDENT
def countPairs ( s1 , n1 , s2 , n2 ) : NEW_LINE INDENT freq1 = [ 0 ] * 26 NEW_LINE freq2 = [ 0 ] * 26 NEW_LINE count = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT freq1 [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT freq2 [ ord ( s2 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT count += min ( freq1 [ i ] , freq2 [ i ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def findSmallestX ( Y ) : NEW_LINE INDENT low = 0 NEW_LINE high = 5 * Y NEW_LINE N = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( high + low ) // 2 NEW_LINE if ( countFactor ( 5 , mid ) < Y ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT N = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT DEDENT return N NEW_LINE DEDENT
def findpair ( l , r ) : NEW_LINE INDENT ans1 = l NEW_LINE ans2 = 2 * l NEW_LINE print ( ans1 , ", " , ans2 ) NEW_LINE DEDENT
def check ( arr , N , K ) : NEW_LINE INDENT unique = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT unique [ arr [ i ] ] = 1 NEW_LINE DEDENT if len ( unique ) == K : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def squareSum ( N ) : NEW_LINE INDENT sum = ( N * ( N + 1 ) * ( 2 * N + 1 ) ) // 6 NEW_LINE return sum NEW_LINE DEDENT
def findMaxN ( X ) : NEW_LINE INDENT N = ( int ) ( math . sqrt ( X ) ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( squareSum ( i ) > X ) : NEW_LINE INDENT return i - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findMaxN ( X ) : NEW_LINE INDENT low , high , N = 1 , 100000 , 0 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( high + low ) // 2 NEW_LINE if squareSum ( mid ) <= X : NEW_LINE INDENT N = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return N NEW_LINE DEDENT
def findNumber ( a , n , K ) : NEW_LINE INDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( K >= a [ i ] [ 0 ] and K <= a [ i ] [ 1 ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findNumber ( a , n , K ) : NEW_LINE INDENT low = 0 NEW_LINE high = n - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( K >= a [ mid ] [ 0 ] and K <= a [ mid ] [ 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( K < a [ mid ] [ 0 ] ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def prefixSum ( p_arr , arr , n ) : NEW_LINE INDENT p_arr [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT p_arr [ i ] = arr [ i ] + p_arr [ i - 1 ] NEW_LINE DEDENT DEDENT
def canDivide ( p_arr , n , q , l , r ) : NEW_LINE INDENT Sum = 0 NEW_LINE if ( l == 0 ) : NEW_LINE INDENT Sum = p_arr [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT Sum = p_arr [ r ] - p_arr [ l - 1 ] NEW_LINE DEDENT if ( Sum % 2 == 1 ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT beg = 0 NEW_LINE if ( l != 0 ) : NEW_LINE INDENT beg = p_arr [ l - 1 ] NEW_LINE DEDENT if ( beg + Sum // 2 in q . keys ( ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def findRing ( arr , x ) : NEW_LINE INDENT if arr [ 0 ] [ 0 ] > x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT l , r = 0 , ( n + 1 ) // 2 - 1 NEW_LINE if n % 2 == 1 and arr [ r ] [ r ] < x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if n % 2 == 0 and arr [ r + 1 ] [ r ] < x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT while l < r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if arr [ mid ] [ mid ] <= x : NEW_LINE INDENT if ( mid == ( n + 1 ) // 2 - 1 or arr [ mid + 1 ] [ mid + 1 ] > x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT
def binarySearchRowInc ( arr , row , l , r , x ) : NEW_LINE INDENT while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if arr [ row ] [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ row ] [ mid ] < x : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def binarySearchColumnInc ( arr , col , t , b , x ) : NEW_LINE INDENT while t <= b : NEW_LINE INDENT mid = ( t + b ) // 2 NEW_LINE if arr [ mid ] [ col ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] [ col ] < x : NEW_LINE INDENT t = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT b = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def binarySearchRowDec ( arr , row , l , r , x ) : NEW_LINE INDENT while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if arr [ row ] [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ row ] [ mid ] < x : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def binarySearchColumnDec ( arr , col , t , b , x ) : NEW_LINE INDENT while t <= b : NEW_LINE INDENT mid = ( t + b ) // 2 NEW_LINE if arr [ mid ] [ col ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] [ col ] < x : NEW_LINE INDENT b = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT t = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minIndex ( arr , n , pos ) : NEW_LINE INDENT num = arr [ pos ] NEW_LINE i = pos - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( arr [ i ] != num ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return i + 1 NEW_LINE DEDENT
def minIndex ( arr , pos ) : NEW_LINE INDENT low = 0 NEW_LINE high = pos NEW_LINE i = pos NEW_LINE while low < high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] != arr [ pos ] : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE i = mid NEW_LINE if mid > 0 and arr [ mid - 1 ] != arr [ pos ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return low if arr [ low ] == arr [ pos ] else i NEW_LINE DEDENT
def findAnswer ( str1 , str2 , n ) : NEW_LINE INDENT l , r = 0 , 0 NEW_LINE ans = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT l = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def ternarySearch ( l , r , key , ar ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE INDENT mid1 = l + ( r - l ) // 3 NEW_LINE mid2 = r - ( r - l ) // 3 NEW_LINE if ( ar [ mid1 ] == key ) : NEW_LINE INDENT return mid1 NEW_LINE DEDENT if ( ar [ mid2 ] == key ) : NEW_LINE INDENT return mid2 NEW_LINE DEDENT if ( key < ar [ mid1 ] ) : NEW_LINE INDENT return ternarySearch ( l , mid1 - 1 , key , ar ) NEW_LINE DEDENT elif ( key > ar [ mid2 ] ) : NEW_LINE INDENT return ternarySearch ( mid2 + 1 , r , key , ar ) NEW_LINE DEDENT else : NEW_LINE INDENT return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def ternarySearch ( l , r , key , ar ) : NEW_LINE INDENT while r >= l : NEW_LINE INDENT mid1 = l + ( r - l ) // 3 NEW_LINE mid2 = r - ( r - l ) // 3 NEW_LINE if key == ar [ mid1 ] : NEW_LINE INDENT return mid1 NEW_LINE DEDENT if key == mid2 : NEW_LINE INDENT return mid2 NEW_LINE DEDENT if key < ar [ mid1 ] : NEW_LINE INDENT r = mid1 - 1 NEW_LINE DEDENT elif key > ar [ mid2 ] : NEW_LINE INDENT l = mid2 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid1 + 1 NEW_LINE r = mid2 - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def build ( arr , node , start , end ) : NEW_LINE INDENT if start == end : NEW_LINE INDENT tree [ node ] = arr [ start ] NEW_LINE return NEW_LINE DEDENT mid = ( start + end ) >> 1 NEW_LINE build ( arr , 2 * node , start , mid ) NEW_LINE build ( arr , 2 * node + 1 , mid + 1 , end ) NEW_LINE tree [ node ] = tree [ 2 * node ] | tree [ 2 * node + 1 ] NEW_LINE DEDENT
def query ( node , start , end , l , r ) : NEW_LINE INDENT if start > end or start > r or end < l : NEW_LINE INDENT return 0 NEW_LINE DEDENT if start >= l and end <= r : NEW_LINE INDENT return tree [ node ] NEW_LINE DEDENT mid = ( start + end ) >> 1 NEW_LINE q1 = query ( 2 * node , start , mid , l , r ) NEW_LINE q2 = query ( 2 * node + 1 , mid + 1 , end , l , r ) NEW_LINE return q1 or q2 NEW_LINE DEDENT
def countSubArrays ( arr , n , K ) : NEW_LINE INDENT build ( arr , 1 , 0 , n - 1 ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT bitwise_or = query ( 1 , 0 , n - 1 , i , j ) NEW_LINE if bitwise_or >= K : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def build ( arr , node , start , end ) : NEW_LINE INDENT if ( start == end ) : NEW_LINE INDENT tree [ node ] = arr [ start ] NEW_LINE return NEW_LINE DEDENT mid = ( start + end ) >> 1 NEW_LINE build ( arr , 2 * node , start , mid ) NEW_LINE build ( arr , 2 * node + 1 , mid + 1 , end ) NEW_LINE tree [ node ] = tree [ 2 * node ] | tree [ 2 * node + 1 ] NEW_LINE DEDENT
def query ( node , start , end , l , r ) : NEW_LINE INDENT if ( start > end or start > r or end < l ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( start >= l and end <= r ) : NEW_LINE INDENT return tree [ node ] NEW_LINE DEDENT mid = ( start + end ) >> 1 NEW_LINE q1 = query ( 2 * node , start , mid , l , r ) NEW_LINE q2 = query ( 2 * node + 1 , mid + 1 , end , l , r ) NEW_LINE return q1 | q2 NEW_LINE DEDENT
def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT low = i NEW_LINE high = n - 1 NEW_LINE index = 1000000000 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( query ( 1 , 0 , n - 1 , i , mid ) >= K ) : NEW_LINE INDENT index = min ( index , mid ) NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT if ( index != 1000000000 ) : NEW_LINE INDENT count += n - index NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def max_min ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) NEW_LINE DEDENT
def max_min ( a , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT f_min = a [ 0 ] NEW_LINE s_min = sys . maxsize NEW_LINE f_max = a [ 0 ] NEW_LINE s_max = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] <= f_min ) : NEW_LINE INDENT s_min = f_min NEW_LINE f_min = a [ i ] NEW_LINE DEDENT elif ( a [ i ] < s_min ) : NEW_LINE INDENT s_min = a [ i ] NEW_LINE DEDENT if ( a [ i ] >= f_max ) : NEW_LINE INDENT s_max = f_max NEW_LINE f_max = a [ i ] NEW_LINE DEDENT elif ( a [ i ] > s_max ) : NEW_LINE INDENT s_max = a [ i ] NEW_LINE DEDENT DEDENT return min ( ( f_max - s_min ) , ( s_max - f_min ) ) NEW_LINE DEDENT
def findMinDifference ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE diff1 = arr [ n - 1 ] - arr [ 1 ] NEW_LINE diff2 = arr [ n - 2 ] - arr [ 0 ] NEW_LINE return min ( diff1 , diff2 ) NEW_LINE DEDENT
def findMinDifference ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] < arr [ 1 ] ) : NEW_LINE INDENT min__ = secondMax = arr [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT min__ = secondMax = arr [ 1 ] NEW_LINE DEDENT if ( arr [ 0 ] < arr [ 1 ] ) : NEW_LINE INDENT max__ = secondMin = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT max__ = secondMin = arr [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max__ ) : NEW_LINE INDENT secondMax = max__ NEW_LINE max__ = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < min__ ) : NEW_LINE INDENT secondMin = min__ NEW_LINE min__ = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < secondMin ) : NEW_LINE INDENT secondMin = arr [ i ] NEW_LINE DEDENT DEDENT diff = min ( max__ - secondMin , secondMax - min__ ) NEW_LINE return diff NEW_LINE DEDENT
def minimal ( a , n ) : NEW_LINE INDENT lo , hi = 0 , n - 1 NEW_LINE while lo < hi : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE if a [ mid ] < a [ mid + 1 ] : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT return lo NEW_LINE return lo NEW_LINE DEDENT DEDENT
def findCount ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( checkDistinct ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countDigits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n //= 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findCount ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE countDigitsL = countDigits ( L ) NEW_LINE countDigitsR = countDigits ( R ) NEW_LINE firstDigitL = ( L // pow ( 10 , countDigitsL - 1 ) ) NEW_LINE firstDigitR = ( R // pow ( 10 , countDigitsR - 1 ) ) NEW_LINE if ( countDigitsL < countDigitsR ) : NEW_LINE INDENT count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) NEW_LINE if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count += firstDigitR NEW_LINE DEDENT else : NEW_LINE INDENT count += ( firstDigitR - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count -= ( 9 - firstDigitR ) NEW_LINE DEDENT else : NEW_LINE INDENT count -= ( 9 - firstDigitR + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def LowerInsertionPoint ( arr , n , X ) : NEW_LINE INDENT if ( X < arr [ 0 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( X > arr [ n - 1 ] ) : NEW_LINE INDENT return n NEW_LINE DEDENT lowerPnt = 0 NEW_LINE i = 1 NEW_LINE while ( i < n and arr [ i ] < X ) : NEW_LINE INDENT lowerPnt = i NEW_LINE i = i * 2 NEW_LINE DEDENT while ( lowerPnt < n and arr [ lowerPnt ] < X ) : NEW_LINE INDENT lowerPnt += 1 NEW_LINE DEDENT return lowerPnt NEW_LINE DEDENT
def getRightMin ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE rightMin = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == min ) : NEW_LINE INDENT rightMin = i NEW_LINE DEDENT i *= 2 NEW_LINE DEDENT i = rightMin + 1 NEW_LINE while ( i < n and arr [ i ] == min ) : NEW_LINE INDENT rightMin = i NEW_LINE i += 1 NEW_LINE DEDENT return rightMin NEW_LINE DEDENT
def getLeftMax ( arr , n ) : NEW_LINE INDENT max = arr [ n - 1 ] NEW_LINE leftMax = n - 1 NEW_LINE i = n - 2 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( arr [ i ] == max ) : NEW_LINE INDENT leftMax = i NEW_LINE DEDENT i = int ( i / 2 ) NEW_LINE DEDENT i = leftMax - 1 NEW_LINE while ( i >= 0 and arr [ i ] == max ) : NEW_LINE INDENT leftMax = i NEW_LINE i -= 1 NEW_LINE DEDENT return leftMax NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime = [ 1 ] * ( MAX ) NEW_LINE isPrime [ 0 ] , isPrime [ 1 ] = 0 , 0 NEW_LINE for i in range ( 2 , int ( MAX_sqrt ) ) : NEW_LINE INDENT if isPrime [ i ] == 1 : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT primeUpto [ i ] = primeUpto [ i - 1 ] NEW_LINE if isPrime [ i ] == 1 : NEW_LINE INDENT primeUpto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT
def countOfNumbers ( N , K ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if mid - primeUpto [ mid ] >= K : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return ( N - ans + 1 ) if ans else 0 NEW_LINE DEDENT
def minIndex ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( 2 * arr [ i ] == sum ) : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def smallest_pair ( a , n ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE secondMin = sys . maxsize NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( a [ j ] < min ) : NEW_LINE INDENT secondMin = min NEW_LINE min = a [ j ] NEW_LINE DEDENT elif ( ( a [ j ] < secondMin ) and a [ j ] != min ) : NEW_LINE INDENT secondMin = a [ j ] NEW_LINE DEDENT DEDENT return ( secondMin + min ) NEW_LINE DEDENT
def checkSorted ( n , arr ) : NEW_LINE INDENT first , second = 0 , 0 NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE if first == 0 : NEW_LINE INDENT first = i NEW_LINE DEDENT else : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT DEDENT if count > 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if count == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if count == 2 : NEW_LINE INDENT ( arr [ first - 1 ] , arr [ second ] ) = ( arr [ second ] , arr [ first - 1 ] ) NEW_LINE DEDENT elif count == 1 : NEW_LINE INDENT ( arr [ first - 1 ] , arr [ first ] ) = ( arr [ first ] , arr [ first - 1 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countWays ( arr , n ) : NEW_LINE INDENT max_val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_val = max ( max_val , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 for i in range ( max_val + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT ans += ( freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) // 6 ) NEW_LINE for i in range ( 1 , max_val + 1 ) : NEW_LINE INDENT ans += ( freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) // 2 ) NEW_LINE DEDENT for i in range ( 1 , ( max_val + 1 ) // 2 ) : NEW_LINE INDENT ans += ( freq [ i ] * ( freq [ i ] - 1 ) // 2 * freq [ 2 * i ] ) NEW_LINE DEDENT for i in range ( 1 , max_val + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , max_val - i + 1 ) : NEW_LINE INDENT ans += freq [ i ] * freq [ j ] * freq [ i + j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def checkIndices ( Arr , N ) : NEW_LINE INDENT for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( Arr [ i ] != Arr [ j ] ) : NEW_LINE INDENT if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def LongestSubarray ( arr , n , k ) : NEW_LINE INDENT count = 1 NEW_LINE max_lenght = 1 NEW_LINE prev_mod = arr [ 0 ] % k NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_mod = arr [ i ] % k NEW_LINE if curr_mod == prev_mod : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_lenght = max ( max_lenght , count ) NEW_LINE count = 1 NEW_LINE prev_mod = curr_mod NEW_LINE DEDENT DEDENT return max ( max_lenght , count ) NEW_LINE DEDENT
def getCount ( v , n ) : NEW_LINE INDENT v = sorted ( v ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = n - 1 - upper_bound ( v , v [ i ] - 1 ) NEW_LINE if ( tmp == v [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def binarySearch1D ( arr , K ) : NEW_LINE INDENT low = 0 NEW_LINE high = N - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + int ( ( high - low ) / 2 ) NEW_LINE if ( arr [ mid ] == K ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ mid ] < K ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def searchMatrix ( matrix , K ) : NEW_LINE INDENT low = 0 NEW_LINE high = M - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + int ( ( high - low ) / 2 ) NEW_LINE if ( K >= matrix [ mid ] [ 0 ] and K <= matrix [ mid ] [ N - 1 ] ) : NEW_LINE INDENT return binarySearch1D ( matrix [ mid ] , K ) NEW_LINE DEDENT if ( K < matrix [ mid ] [ 0 ] ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def longestsubarray ( arr , n , k ) : NEW_LINE INDENT current_count = 0 NEW_LINE max_count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT current_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT current_count = 0 NEW_LINE DEDENT max_count = max ( current_count , max_count ) NEW_LINE DEDENT return max_count NEW_LINE DEDENT
def countSegments ( a , n , x ) : NEW_LINE INDENT flag = False NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT else : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT flag = False NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findElements ( arr , n , l , r ) : NEW_LINE INDENT mp = { i : 0 for i in range ( len ( arr ) ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( l <= mp [ arr [ i ] ] and mp [ arr [ i ] <= r ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def findElementsAfterDel ( arr , m , dell , n , k ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if dell [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ dell [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ dell [ i ] ] = 1 NEW_LINE DEDENT DEDENT heap = list ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( arr [ i ] in mp . keys ( ) ) : NEW_LINE INDENT mp [ arr [ i ] ] -= 1 NEW_LINE if ( mp [ arr [ i ] ] == 0 ) : NEW_LINE INDENT mp . pop ( arr [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT heap . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT heap . sort ( ) NEW_LINE return heap [ : k ] NEW_LINE DEDENT
def removeElements ( arr , n , k ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in mp and mp [ arr [ i ] ] >= k ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def check ( s ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def RemoveElements ( arr , n , k ) : NEW_LINE INDENT mp = { i : 0 for i in range ( len ( arr ) ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] <= k ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def findSmallestAfterDel ( arr , m , dell , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if dell [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ dell [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ dell [ i ] ] = 1 NEW_LINE DEDENT DEDENT SmallestElement = 10 ** 9 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( arr [ i ] in mp . keys ( ) ) : NEW_LINE INDENT mp [ arr [ i ] ] -= 1 NEW_LINE if ( mp [ arr [ i ] ] == 0 ) : NEW_LINE INDENT mp . pop ( arr [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT SmallestElement = min ( SmallestElement , arr [ i ] ) NEW_LINE DEDENT DEDENT return SmallestElement NEW_LINE DEDENT
def findlargestAfterDel ( arr , m , dell , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if dell [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ dell [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ dell [ i ] ] = 1 NEW_LINE DEDENT DEDENT largestElement = - 10 ** 9 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( arr [ i ] in mp . keys ( ) ) : NEW_LINE INDENT mp [ arr [ i ] ] -= 1 NEW_LINE if ( mp [ arr [ i ] ] == 0 ) : NEW_LINE INDENT mp . pop ( arr [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT largestElement = max ( largestElement , arr [ i ] ) NEW_LINE DEDENT DEDENT return largestElement NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def divTermCount ( a , b , lcm , num ) : NEW_LINE INDENT return num // a + num // b - num // lcm NEW_LINE DEDENT
def findNthTerm ( a , b , n ) : NEW_LINE INDENT low = 1 NEW_LINE high = sys . maxsize NEW_LINE lcm = ( a * b ) // gcd ( a , b ) NEW_LINE while low < high : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if divTermCount ( a , b , lcm , mid ) < n : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT
def LongestFibSubseq ( A , n ) : NEW_LINE INDENT S = set ( A ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = A [ j ] NEW_LINE y = A [ i ] + A [ j ] NEW_LINE length = 2 NEW_LINE while y in S : NEW_LINE INDENT z = x + y NEW_LINE x = y NEW_LINE y = z NEW_LINE length += 1 NEW_LINE maxLen = max ( maxLen , length ) NEW_LINE DEDENT DEDENT DEDENT return maxLen if maxLen >= 3 else 0 NEW_LINE DEDENT
def numberOfElements ( height , n ) : NEW_LINE INDENT max_so_far = 0 NEW_LINE coun = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if height [ i ] > max_so_far : NEW_LINE INDENT max_so_far = height [ i ] NEW_LINE coun = coun + 1 NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT
def isPossible ( A , n , H , K ) : NEW_LINE INDENT time = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT time += ( A [ i ] - 1 ) // K + 1 NEW_LINE DEDENT return time <= H NEW_LINE DEDENT
def minJobSpeed ( A , n , H ) : NEW_LINE INDENT if H < n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT Max = max ( A ) NEW_LINE lo , hi = 1 , Max NEW_LINE while lo < hi : NEW_LINE INDENT mi = lo + ( hi - lo ) // 2 NEW_LINE if not isPossible ( A , n , H , mi ) : NEW_LINE INDENT lo = mi + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mi NEW_LINE DEDENT DEDENT return lo NEW_LINE DEDENT
def kthSmallestLargest ( arr , n , k ) : NEW_LINE INDENT max_val = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > max_val ) : NEW_LINE INDENT max_val = arr [ i ] NEW_LINE DEDENT DEDENT hash = [ 0 for i in range ( max_val + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( max_val + 1 ) : NEW_LINE INDENT while ( hash [ i ] > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT hash [ i ] -= 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countAnomalies ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if i != j and abs ( arr [ i ] - arr [ j ] ) <= k : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == n : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countAnomalies ( a , n , k ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT u = upper_bound ( a , 0 , n , a [ i ] ) NEW_LINE if ( u < n and a [ u ] - a [ i ] <= k ) : NEW_LINE INDENT continue NEW_LINE DEDENT s = lower_bound ( a , 0 , n , a [ i ] ) NEW_LINE if ( u - s > 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s > 0 and a [ s - 1 ] - a [ i ] <= k ) : NEW_LINE INDENT continue NEW_LINE DEDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def solve ( arr , n , k ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] in m . keys ( ) ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT max = sys . maxsize NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( m [ arr [ i ] ] == k and max == sys . maxsize ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT elif ( m [ arr [ i ] ] == k and max < arr [ i ] ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( max == sys . maxsize ) : NEW_LINE INDENT print ( "No such element" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ) NEW_LINE DEDENT DEDENT
def majorityInMatrix ( arr ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 7 ) } NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( len ( arr ) ) : NEW_LINE INDENT mp [ arr [ i ] [ j ] ] += 1 NEW_LINE DEDENT DEDENT countMajority = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if ( value >= ( int ( ( N * M ) / 2 ) ) ) : NEW_LINE INDENT countMajority += 1 NEW_LINE DEDENT DEDENT return countMajority NEW_LINE DEDENT
def getMin ( arr , n ) : NEW_LINE INDENT res = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res = min ( res , arr [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findSum ( arr , n ) : NEW_LINE INDENT min = getMin ( arr , n ) NEW_LINE max = getMax ( arr , n ) NEW_LINE return min + max NEW_LINE DEDENT
def findProduct ( arr , n ) : NEW_LINE INDENT min = getMin ( arr , n ) NEW_LINE max = getMax ( arr , n ) NEW_LINE return min * max NEW_LINE DEDENT
def countEle ( s , a , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT num = a [ i ] NEW_LINE if num in mp : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 0 NEW_LINE while s [ - 1 ] != num : NEW_LINE INDENT mp [ s . pop ( ) ] = True NEW_LINE cnt += 1 NEW_LINE DEDENT s . pop ( ) NEW_LINE cnt += 1 NEW_LINE print ( cnt , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def bsearch ( A , key_to_search ) : NEW_LINE INDENT n = len ( A ) NEW_LINE lg = int ( math . log2 ( n - 1 ) ) + 1 NEW_LINE pos = 0 NEW_LINE for i in range ( lg - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( A [ pos ] == key_to_search ) : NEW_LINE INDENT return pos NEW_LINE DEDENT new_pos = pos | ( 1 << i ) NEW_LINE if ( ( new_pos < n ) and ( A [ new_pos ] <= key_to_search ) ) : NEW_LINE INDENT pos = new_pos NEW_LINE DEDENT DEDENT return ( pos if ( A [ pos ] == key_to_search ) else - 1 ) NEW_LINE DEDENT
def colMaxDiff ( mat ) : NEW_LINE INDENT max_diff = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT max_val = mat [ 0 ] [ i ] NEW_LINE min_val = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT max_val = max ( max_val , mat [ j ] [ i ] ) NEW_LINE min_val = min ( min_val , mat [ j ] [ i ] ) NEW_LINE DEDENT max_diff = max ( max_diff , max_val - min_val ) NEW_LINE DEDENT return max_diff NEW_LINE DEDENT
def countChar ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT count = 2 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findmedian ( a , n1 , b , n2 ) : NEW_LINE INDENT j = 0 NEW_LINE m1 = - 1 NEW_LINE m2 = - 1 NEW_LINE for k in range ( ( ( n1 + n2 ) // 2 ) + 1 ) : NEW_LINE INDENT if ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( a [ i ] < b [ j ] ) : NEW_LINE INDENT m2 = m1 NEW_LINE m1 = a [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m2 = m1 NEW_LINE m1 = b [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT elif ( i == n1 ) : NEW_LINE INDENT m2 = m1 NEW_LINE m1 = b [ j ] NEW_LINE j += 1 NEW_LINE DEDENT elif ( j == n2 ) : NEW_LINE INDENT m2 = m1 NEW_LINE m1 = a [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if ( ( n1 + n2 ) % 2 == 0 ) : NEW_LINE INDENT return ( m1 + m2 ) * 1.0 / 2 NEW_LINE DEDENT return m1 NEW_LINE DEDENT
def search ( ar , size ) : NEW_LINE INDENT a = 0 NEW_LINE b = size - 1 NEW_LINE mid = 0 NEW_LINE while b > a + 1 : NEW_LINE INDENT mid = ( a + b ) // 2 NEW_LINE if ( ar [ a ] - a ) != ( ar [ mid ] - mid ) : NEW_LINE INDENT b = mid NEW_LINE DEDENT elif ( ar [ b ] - b ) != ( ar [ mid ] - mid ) : NEW_LINE INDENT a = mid NEW_LINE DEDENT DEDENT return ar [ a ] + 1 NEW_LINE DEDENT
def deleteElement ( A , L , R , N ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i <= L or i >= R : NEW_LINE INDENT A [ j ] = A [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( x == arr [ i ] ) : NEW_LINE INDENT res = i NEW_LINE DEDENT DEDENT if ( res == - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = arr [ res ] NEW_LINE i = res NEW_LINE while ( i > 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ 0 ] = temp NEW_LINE return True NEW_LINE DEDENT
def kPresentProbability ( a , n , k ) : NEW_LINE INDENT count = a . count ( k ) NEW_LINE return round ( count / n , 2 ) NEW_LINE DEDENT
def binarySearch ( searchSpace , s , e , num ) : NEW_LINE INDENT while ( s <= e ) : NEW_LINE INDENT mid = ( s + e ) // 2 NEW_LINE if searchSpace [ mid ] >= num : NEW_LINE INDENT ans = mid NEW_LINE e = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT s = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def longestSubArr ( arr , n ) : NEW_LINE INDENT searchSpace = [ None ] * n NEW_LINE index = [ None ] * n NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( j == 0 or searchSpace [ j - 1 ] < arr [ i ] ) : NEW_LINE INDENT searchSpace [ j ] = arr [ i ] NEW_LINE index [ j ] = i NEW_LINE j += 1 NEW_LINE DEDENT idx = binarySearch ( searchSpace , 0 , j - 1 , arr [ i ] ) NEW_LINE ans = max ( ans , i - index [ idx ] + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findmissing ( ar , N ) : NEW_LINE INDENT l = 0 NEW_LINE r = N - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) / 2 NEW_LINE mid = int ( mid ) NEW_LINE if ( ar [ mid ] != mid + 1 and ar [ mid - 1 ] == mid ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT elif ( ar [ mid ] != mid + 1 ) : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return ( - 1 ) NEW_LINE DEDENT
def findFirst ( arr , n , x ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ptr = lowerBound ( arr , 0 , n , x ) NEW_LINE return 1 if ( ptr != x ) else ( ptr - arr ) NEW_LINE DEDENT
def findFirst ( arr , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE isX = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT isX = True NEW_LINE DEDENT elif ( arr [ i ] < x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return - 1 if ( isX == False ) else count NEW_LINE DEDENT
def findDuplicate ( arr ) : NEW_LINE INDENT slow = arr [ 0 ] NEW_LINE fast = arr [ 0 ] NEW_LINE while True : NEW_LINE INDENT slow = arr [ slow ] NEW_LINE fast = arr [ arr [ fast ] ] NEW_LINE if slow == fast : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT ptr1 = arr [ 0 ] NEW_LINE ptr2 = slow NEW_LINE while ptr1 != ptr2 : NEW_LINE INDENT ptr1 = arr [ ptr1 ] NEW_LINE ptr2 = arr [ ptr2 ] NEW_LINE DEDENT return ptr1 NEW_LINE DEDENT
def isSafe ( x , y , board ) : NEW_LINE INDENT if ( x >= 0 and y >= 0 and x < n and y < n and board [ x ] [ y ] == - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def prevGreater ( arr , n ) : NEW_LINE INDENT print ( "-1" , end = ", " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT print ( arr [ j ] , end = ", " ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if j == 0 and flag == 0 : NEW_LINE INDENT print ( "-1" , end = ", " ) NEW_LINE DEDENT DEDENT DEDENT
def prevGreater ( arr , n ) : NEW_LINE INDENT s = list ( ) NEW_LINE s . append ( arr [ 0 ] ) NEW_LINE print ( "-1, " , end = "" ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( s ) > 0 and s [ - 1 ] < arr [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if len ( s ) == 0 : NEW_LINE INDENT print ( "-1, " , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ - 1 ] , ", " , end = "" ) NEW_LINE DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def printGreaterCount ( str ) : NEW_LINE INDENT len__ = len ( str ) NEW_LINE right = [ 0 for i in range ( len__ ) ] NEW_LINE for i in range ( len__ ) : NEW_LINE INDENT for j in range ( i + 1 , len__ , 1 ) : NEW_LINE INDENT if ( str [ i ] < str [ j ] ) : NEW_LINE INDENT right [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( len__ ) : NEW_LINE INDENT print ( right [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def printGreaterCount ( str1 ) : NEW_LINE INDENT len1 = len ( str1 ) NEW_LINE ans = [ 0 ] * len1 NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE for j in range ( ord ( str1 [ i ] ) - ord ( 'a' ) + 1 , MAX_CHAR ) : NEW_LINE INDENT ans [ i ] += count [ j ] NEW_LINE DEDENT DEDENT for i in range ( len1 ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def findMissingNo ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= 0 or arr [ i ] > n ) : NEW_LINE INDENT continue NEW_LINE DEDENT val = arr [ i ] NEW_LINE while ( arr [ val - 1 ] != val ) : NEW_LINE INDENT nextval = arr [ val - 1 ] NEW_LINE arr [ val - 1 ] = val NEW_LINE val = nextval NEW_LINE if ( val <= 0 or val > n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return n + 1 NEW_LINE DEDENT
def solve ( a , n ) : NEW_LINE INDENT max1 = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT for j in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( abs ( a [ i ] - a [ j ] ) > max1 ) : NEW_LINE INDENT max1 = abs ( a [ i ] - a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return max1 NEW_LINE DEDENT
def solve ( a , n ) : NEW_LINE INDENT min1 = a [ 0 ] NEW_LINE max1 = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > max1 ) : NEW_LINE INDENT max1 = a [ i ] NEW_LINE DEDENT if ( a [ i ] < min1 ) : NEW_LINE INDENT min1 = a [ i ] NEW_LINE DEDENT DEDENT return abs ( min1 - max1 ) NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - sys . maxsize NEW_LINE for i in range ( n - 3 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 2 ) : NEW_LINE INDENT for k in range ( j + 1 , n - 1 ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 , 1 ) : NEW_LINE INDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def getCount ( M , N ) : NEW_LINE INDENT count = 0 NEW_LINE if ( M == 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return M NEW_LINE DEDENT if ( N > M ) : NEW_LINE INDENT for i in range ( 1 , M + 1 ) : NEW_LINE INDENT numerator = N * i - N + M - i NEW_LINE denominator = M - 1 NEW_LINE if ( numerator % denominator == 0 ) : NEW_LINE INDENT j = numerator / denominator NEW_LINE if ( j >= 1 and j <= N ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT numerator = M * j - M + N - j NEW_LINE denominator = N - 1 NEW_LINE if ( numerator % denominator == 0 ) : NEW_LINE INDENT i = numerator / denominator NEW_LINE if ( i >= 1 and i <= M ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countTripletsLessThanL ( n , L , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ways = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT mostDistantDistance = arr [ k ] - arr [ i ] NEW_LINE if ( mostDistantDistance <= L ) : NEW_LINE INDENT ways += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ways NEW_LINE DEDENT
def appearsNBy3 ( arr , n ) : NEW_LINE INDENT count1 = 0 NEW_LINE count2 = 0 NEW_LINE first = sys . maxsize NEW_LINE second = sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( first == arr [ i ] ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT elif ( second == arr [ i ] ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT elif ( count1 == 0 ) : NEW_LINE INDENT count1 += 1 NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( count2 == 0 ) : NEW_LINE INDENT count2 += 1 NEW_LINE second = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT count1 -= 1 NEW_LINE count2 -= 1 NEW_LINE DEDENT DEDENT count1 = 0 NEW_LINE count2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == first ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT elif ( arr [ i ] == second ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT DEDENT if ( count1 > n / 3 ) : NEW_LINE INDENT return first NEW_LINE DEDENT if ( count2 > n / 3 ) : NEW_LINE INDENT return second NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def binary_lower ( value , arr , n ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE ans = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( arr [ mid ] >= value ) : NEW_LINE INDENT end = mid - 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countTriplet ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT cur = ( binary_lower ( arr [ i ] - k , arr , n ) ) NEW_LINE if ( cur <= i - 2 ) : NEW_LINE INDENT count += ( ( i - cur ) * ( i - cur - 1 ) ) // 2 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def isSuffix ( s1 , s2 ) : NEW_LINE INDENT n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE if ( n1 > n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def replaceOriginal ( s , n ) : NEW_LINE INDENT r = [ ' ' ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT r [ i ] = s [ n - 1 - i ] NEW_LINE if ( s [ i ] != 'a' and s [ i ] != 'e' and s [ i ] != 'i' and s [ i ] != 'o' and s [ i ] != 'u' ) : NEW_LINE INDENT print ( r [ i ] , end = "" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
def swapElement ( arr1 , arr2 , n ) : NEW_LINE INDENT wrongIdx = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr1 [ i - 1 ] ) : NEW_LINE INDENT wrongIdx = i NEW_LINE DEDENT DEDENT maximum = - ( sys . maxsize - 1 ) NEW_LINE maxIdx = - 1 NEW_LINE res = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr2 [ i ] > maximum and arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) : NEW_LINE INDENT if ( wrongIdx + 1 <= n - 1 and arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) : NEW_LINE INDENT maximum = arr2 [ i ] NEW_LINE maxIdx = i NEW_LINE res = True NEW_LINE DEDENT DEDENT DEDENT if ( res ) : NEW_LINE INDENT ( arr1 [ wrongIdx ] , arr2 [ maxIdx ] ) = ( arr2 [ maxIdx ] , arr1 [ wrongIdx ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def ElementsCalculationFunc ( pre , maxx , x , k , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = x NEW_LINE while j <= n : NEW_LINE INDENT if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def costToBalance ( s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT ans = 0 NEW_LINE o = 0 NEW_LINE c = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '(' ) : NEW_LINE INDENT o += 1 NEW_LINE DEDENT if ( s [ i ] == ')' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( o != c ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = [ 0 for i in range ( len ( s ) ) ] NEW_LINE if ( s [ 0 ] == '(' ) : NEW_LINE INDENT a [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ 0 ] = - 1 NEW_LINE DEDENT if ( a [ 0 ] < 0 ) : NEW_LINE INDENT ans += abs ( a [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '(' ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = a [ i - 1 ] - 1 NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT ans += abs ( a [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def checkIfAllTogether ( s , c ) : NEW_LINE INDENT oneSeen = False NEW_LINE i = 0 NEW_LINE n = len ( s ) NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT if ( oneSeen == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( i < n and s [ i ] == c ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT oneSeen = True NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def f ( n ) : NEW_LINE INDENT return n * ( 2 * n * n - 1 ) NEW_LINE DEDENT
def binarySearch ( low , high , x ) : NEW_LINE INDENT while ( low <= high ) : NEW_LINE INDENT mid = int ( ( low + high ) // 2 ) NEW_LINE if ( f ( mid ) < x ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT elif ( f ( mid ) > x ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def isStellaOctangula ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 1 NEW_LINE while ( f ( i ) < x ) : NEW_LINE INDENT i = i * 2 NEW_LINE DEDENT if ( f ( i ) == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT return binarySearch ( i / 2 , i , x ) NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT front = 0 NEW_LINE back = n - 1 NEW_LINE while ( front <= back ) : NEW_LINE INDENT if ( arr [ front ] == x or arr [ back ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT front += 1 NEW_LINE back -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def isSafe ( graph , color ) : NEW_LINE INDENT for i in range ( 4 ) : NEW_LINE INDENT for j in range ( i + 1 , 4 ) : NEW_LINE INDENT if ( graph [ i ] [ j ] and color [ j ] == color [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def graphColoring ( graph , m , i , color ) : NEW_LINE INDENT if ( i == 4 ) : NEW_LINE INDENT if ( isSafe ( graph , color ) ) : NEW_LINE INDENT printSolution ( color ) NEW_LINE return True NEW_LINE DEDENT return False NEW_LINE DEDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT color [ i ] = j NEW_LINE if ( graphColoring ( graph , m , i + 1 , color ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT color [ i ] = 0 NEW_LINE DEDENT return False NEW_LINE DEDENT
def getGreatestSum ( a ) : NEW_LINE INDENT prev_max = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( prev_max < a [ N - 1 ] [ j ] ) : NEW_LINE INDENT prev_max = a [ N - 1 ] [ j ] NEW_LINE DEDENT DEDENT sum = prev_max NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT curr_max = - 2147483648 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( prev_max > a [ i ] [ j ] and a [ i ] [ j ] > curr_max ) : NEW_LINE INDENT curr_max = a [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( curr_max == - 2147483648 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prev_max = curr_max NEW_LINE sum = sum + prev_max NEW_LINE DEDENT return sum NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT sum = arr [ 0 ] NEW_LINE prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] <= prev : NEW_LINE INDENT prev = prev + 1 NEW_LINE sum = sum + prev NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE prev = arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def missingNum ( arr , n ) : NEW_LINE INDENT minvalue = min ( arr ) NEW_LINE xornum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT xornum ^= ( minvalue ) ^ arr [ i ] NEW_LINE minvalue = minvalue + 1 NEW_LINE DEDENT return xornum ^ minvalue NEW_LINE DEDENT
def findElement ( n , k ) : NEW_LINE INDENT left = 1 NEW_LINE right = math . pow ( 2 , n ) - 1 NEW_LINE while 1 : NEW_LINE INDENT mid = int ( ( left + right ) / 2 ) NEW_LINE if k == mid : NEW_LINE INDENT print ( ans ) NEW_LINE break NEW_LINE DEDENT ans -= 1 NEW_LINE if k < mid : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT DEDENT DEDENT
def firstCommon ( head1 , head2 ) : NEW_LINE INDENT while ( head1 != None ) : NEW_LINE INDENT p = head2 NEW_LINE while ( p != None ) : NEW_LINE INDENT if ( p . data == head1 . data ) : NEW_LINE INDENT return head1 . data NEW_LINE DEDENT p = p . next NEW_LINE DEDENT head1 = head1 . next NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def findmin ( p , n ) : NEW_LINE INDENT a , b , c , d = 0 , 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] [ 0 ] <= 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif ( p [ i ] [ 0 ] >= 0 ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if ( p [ i ] [ 1 ] >= 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( p [ i ] [ 1 ] <= 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT return min ( [ a , b , c , d ] ) NEW_LINE DEDENT
def findLastIndex ( str , x ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if str [ i ] == x : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def findLastIndex ( str , x ) : NEW_LINE INDENT for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def checkBit ( pattern , arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( pattern & arr [ i ] ) == pattern ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countMaxSumPairs ( a , n ) : NEW_LINE INDENT first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = a [ i ] NEW_LINE DEDENT elif ( a [ i ] > second and a [ i ] != first ) : NEW_LINE INDENT second = a [ i ] NEW_LINE DEDENT DEDENT cnt1 = 0 NEW_LINE cnt2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == first ) : NEW_LINE INDENT if ( a [ i ] == second ) : NEW_LINE INDENT  if ( cnt1 == 1 ) : NEW_LINE INDENT return cnt2 NEW_LINE DEDENT DEDENT if ( cnt1 > 1 ) : NEW_LINE INDENT return cnt1 * ( cnt1 - 1 ) / 2 NEW_LINE DEDENT DEDENT DEDENT
def middleOfThree ( a , b , c ) : NEW_LINE INDENT def middleOfThree ( a , b , c ) : NEW_LINE INDENT if ( ( a < b and b < c ) or ( c < b and b < a ) ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( ( b < a and a < c ) or ( c < a and a < b ) ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return c NEW_LINE DEDENT DEDENT DEDENT
def middleOfThree ( a , b , c ) : NEW_LINE INDENT if a > b : NEW_LINE INDENT if ( b > c ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( a > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( a > c ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( b > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT DEDENT
def findValue ( X , Y , P ) : NEW_LINE INDENT if P % 2 == 0 : NEW_LINE INDENT return int ( max ( X , Y ) / min ( X , Y ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return int ( max ( 2 * X , Y ) / min ( 2 * X , Y ) ) NEW_LINE DEDENT DEDENT
def countMaxSetBits ( left , right ) : NEW_LINE INDENT max_count = - 1 NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT temp = i NEW_LINE cnt = 0 NEW_LINE while temp : NEW_LINE INDENT if temp & 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT temp = temp >> 1 NEW_LINE DEDENT if cnt > max_count : NEW_LINE INDENT max_count = cnt NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT
def sum ( arr , start , to ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( start , to + 1 ) : NEW_LINE INDENT total += arr [ i ] NEW_LINE DEDENT return total NEW_LINE DEDENT
def findMax ( arr , n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = sum ( arr , 0 , i - 1 ) NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = arr [ 0 ] NEW_LINE for j in range ( 2 , n + 1 ) : NEW_LINE INDENT best = 100000000 NEW_LINE for p in range ( 1 , j + 1 ) : NEW_LINE INDENT best = min ( best , max ( dp [ i - 1 ] [ p ] , sum ( arr , p , j - 1 ) ) ) NEW_LINE DEDENT dp [ i ] [ j ] = best NEW_LINE DEDENT DEDENT return dp [ k ] [ n ] NEW_LINE DEDENT
def findFloor ( root , key ) : NEW_LINE INDENT curr = root NEW_LINE ans = None NEW_LINE while ( curr ) : NEW_LINE INDENT if ( curr . key <= key ) : NEW_LINE INDENT ans = curr NEW_LINE curr = curr . right NEW_LINE DEDENT else : NEW_LINE INDENT curr = curr . left NEW_LINE DEDENT DEDENT if ( ans ) : NEW_LINE INDENT return ans . key NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT _sum = 0 NEW_LINE n = 1 NEW_LINE while ( _sum < s ) : NEW_LINE INDENT _sum += n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def isvalid ( s ) : NEW_LINE INDENT k = ( - 1 + math . sqrt ( 1 + 8 * s ) ) / 2 NEW_LINE if ( math . ceil ( k ) == math . floor ( k ) ) : NEW_LINE INDENT return int ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def calcSafe ( pos ) : NEW_LINE INDENT j = pos % 10 NEW_LINE i = pos / 10 NEW_LINE dis_11 = min ( abs ( 1 - i ) , abs ( 1 - j ) ) NEW_LINE dis_18 = min ( abs ( 1 - i ) , abs ( 8 - j ) ) NEW_LINE dis_81 = min ( abs ( 8 - i ) , abs ( 1 - j ) ) NEW_LINE dis_88 = min ( abs ( 8 - i ) , abs ( 8 - j ) ) NEW_LINE sum = ( dis_11 + dis_18 + dis_81 + dis_88 + 1 ) NEW_LINE return ( 64 - sum ) NEW_LINE DEDENT
def countCrossLine ( arr , n ) : NEW_LINE INDENT count_crossline = 0 NEW_LINE i , key , j = 0 , 0 , 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE j = i - 1 NEW_LINE while ( j >= 0 and arr [ j ] > key ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE count_crossline += 1 NEW_LINE DEDENT arr [ j + 1 ] = key NEW_LINE DEDENT return count_crossline NEW_LINE DEDENT
def getCount ( arr , n , num1 , num2 ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == num1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for j in range ( n - 1 , i + 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] == num2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( j - i - 1 ) NEW_LINE DEDENT
def check_elements ( arr , n , A , B ) : NEW_LINE INDENT rangeV = B - A NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) >= A and abs ( arr [ i ] ) <= B ) : NEW_LINE INDENT z = abs ( arr [ i ] ) - A NEW_LINE if ( arr [ z ] > 0 ) : NEW_LINE INDENT arr [ z ] = arr [ z ] * - 1 NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 0 , rangeV + 1 ) : NEW_LINE INDENT if i >= n : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if ( count != ( rangeV + 1 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def sumOfDigit ( K ) : NEW_LINE INDENT sod = 0 NEW_LINE while ( K ) : NEW_LINE INDENT sod = sod + K % 10 NEW_LINE K = K // 10 NEW_LINE DEDENT return sod NEW_LINE DEDENT
def findMinRec ( A , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return A [ 0 ] NEW_LINE DEDENT return min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) NEW_LINE DEDENT
def findMaxRec ( A , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return A [ 0 ] NEW_LINE DEDENT return max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) NEW_LINE DEDENT
def getRandom ( x , y ) : NEW_LINE INDENT return randint ( x , y ) NEW_LINE DEDENT
def randomizedBinarySearch ( arr , l , r , x ) : NEW_LINE INDENT while ( l <= r ) : NEW_LINE INDENT m = getRandom ( l , r ) NEW_LINE if ( arr [ m ] == x ) : NEW_LINE INDENT return m NEW_LINE DEDENT if ( arr [ m ] < x ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countBuildings ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE curr_max = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > curr_max or arr [ i ] == curr_max ) : NEW_LINE INDENT count += 1 NEW_LINE curr_max = arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = n - 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( int ) ( ( left + right ) / 2 ) NEW_LINE if ( arr2 [ mid ] == arr1 [ mid ] ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT index = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def findPages ( arr , n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( n < m ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT start , end = 0 , sum NEW_LINE result = 10 ** 9 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( isPossible ( arr , n , m , mid ) ) : NEW_LINE INDENT result = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def minCostToMakeElementEqual ( arr , N ) : NEW_LINE INDENT low = high = arr [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( low > arr [ i ] ) : NEW_LINE INDENT low = arr [ i ] NEW_LINE DEDENT if ( high < arr [ i ] ) : NEW_LINE INDENT high = arr [ i ] NEW_LINE DEDENT DEDENT while ( ( high - low ) > 2 ) : NEW_LINE INDENT mid1 = low + ( high - low ) // 3 NEW_LINE mid2 = high - ( high - low ) // 3 NEW_LINE cost1 = computeCost ( arr , N , mid1 ) NEW_LINE cost2 = computeCost ( arr , N , mid2 ) NEW_LINE if ( cost1 < cost2 ) : NEW_LINE INDENT high = mid2 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid1 NEW_LINE DEDENT DEDENT return computeCost ( arr , N , ( low + high ) // 2 ) NEW_LINE DEDENT
def minJumps ( w , l , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT ans = 0 NEW_LINE pos = { } NEW_LINE jump = { } NEW_LINE filled = { } NEW_LINE a = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT pos [ w [ i ] ] = i NEW_LINE filled [ i ] = True NEW_LINE jump [ w [ i ] ] = l [ i ] NEW_LINE a [ i ] = w [ i ] NEW_LINE DEDENT a . sort ( ) NEW_LINE for curr in range ( 1 , n , 1 ) : NEW_LINE INDENT currElementPos = pos [ a [ curr ] ] NEW_LINE prevElementPos = pos [ a [ curr - 1 ] ] NEW_LINE if ( currElementPos > prevElementPos ) : NEW_LINE INDENT continue NEW_LINE DEDENT while ( currElementPos <= prevElementPos or ( currElementPos in filled and filled [ currElementPos ] ) ) : NEW_LINE INDENT currElementPos += jump [ a [ curr ] ] NEW_LINE ans += 1 NEW_LINE DEDENT pos [ a [ curr ] ] = currElementPos NEW_LINE filled [ currElementPos ] = True NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] >= ( i - 1 ) ) : NEW_LINE INDENT p = arr [ i - 1 ] - ( i - 1 ) NEW_LINE arr [ i ] += p NEW_LINE arr [ i - 1 ] -= p NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ i - 1 ] ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "Yes" ) NEW_LINE DEDENT
def minimumSize ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE arr . reverse ( ) NEW_LINE zero = arr . count ( 0 ) NEW_LINE if zero == N : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif K >= N : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ K ] ) NEW_LINE DEDENT DEDENT
def isPossibleToSort ( arr , N ) : NEW_LINE INDENT idx = - 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] == 1 and arr [ i - 1 ] == 1 ) : NEW_LINE INDENT idx = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( idx == - 1 ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE return NEW_LINE DEDENT for i in range ( idx + 1 , N , 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 and arr [ i - 1 ] == 0 ) : NEW_LINE INDENT print ( "NO" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "YES" ) NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE index = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] >= arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE index = i NEW_LINE DEDENT DEDENT if ( count > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( count == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( index == n - 1 or index == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ index - 1 ] < arr [ index + 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ index - 2 ] < arr [ index ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isPossibleToSort ( arr , N ) : NEW_LINE INDENT group = arr [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] [ 1 ] != group ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT DEDENT if ( isSorted ( arr , N ) ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT else : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT
def maximumSum ( arr , S , N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = sorted ( arr ) [ : : - 1 ] NEW_LINE for i in range ( K ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT S = sorted ( S ) NEW_LINE for i in range ( K ) : NEW_LINE INDENT if ( S [ i ] == 1 ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT S [ i ] -= 1 NEW_LINE DEDENT counter = K - 1 NEW_LINE for i in range ( K ) : NEW_LINE INDENT counter = counter + S [ i ] NEW_LINE if ( S [ i ] != 0 ) : NEW_LINE INDENT ans += arr [ counter ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minimumDeletion ( s , n ) : NEW_LINE INDENT countMap = { } NEW_LINE for i in s : NEW_LINE INDENT countMap [ i ] = countMap . get ( i , 0 ) + 1 NEW_LINE DEDENT countMultiset = [ ] NEW_LINE for it in countMap : NEW_LINE INDENT countMultiset . append ( countMap [ it ] ) NEW_LINE DEDENT ans = sys . maxsize + 1 NEW_LINE i = 0 NEW_LINE m = len ( countMultiset ) NEW_LINE for j in sorted ( countMultiset ) : NEW_LINE INDENT ans = min ( ans , n - ( m - i ) * j ) NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxLenSubset ( a , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE index = 0 NEW_LINE maxlen = - 1 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i NEW_LINE len1 = 1 NEW_LINE while ( j < n - 1 ) : NEW_LINE INDENT if ( 2 * a [ j ] >= a [ j + 1 ] ) : NEW_LINE INDENT len1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( maxlen < len1 ) : NEW_LINE INDENT maxlen = len1 NEW_LINE index = i NEW_LINE DEDENT j += 1 NEW_LINE i = j NEW_LINE DEDENT i = index NEW_LINE while ( maxlen > 0 ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE maxlen -= 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def maximumMex ( arr , N ) : NEW_LINE INDENT ans = [ ] NEW_LINE arr = sorted ( arr ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == 0 or arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT ans . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( i > 0 and arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT ans . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def canReduceArray ( arr , N , K ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i + 1 ] > K ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "Yes" ) NEW_LINE DEDENT
def mergeStrings ( s1 , s2 ) : NEW_LINE INDENT len1 = len ( s1 ) NEW_LINE len2 = len ( s2 ) NEW_LINE pntr1 = 0 NEW_LINE pntr2 = 0 NEW_LINE ans = "" NEW_LINE while ( pntr1 < len1 and pntr2 < len2 ) : NEW_LINE INDENT if ( s1 [ pntr1 ] < s2 [ pntr2 ] ) : NEW_LINE INDENT ans += s1 [ pntr1 ] NEW_LINE pntr1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += s2 [ pntr2 ] NEW_LINE pntr2 += 1 NEW_LINE DEDENT DEDENT if ( pntr1 < len1 ) : NEW_LINE INDENT ans += s1 [ pntr1 : pntr1 + len1 ] NEW_LINE DEDENT if ( pntr2 < len2 ) : NEW_LINE INDENT ans += s2 [ pntr2 : pntr2 + len2 ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def bubble_sort ( ar ) : NEW_LINE INDENT if len ( ar ) <= 1 : NEW_LINE INDENT return ar NEW_LINE DEDENT if len ( ar ) == 2 : NEW_LINE INDENT return ar if ar [ 0 ] < ar [ 1 ] else [ ar [ 1 ] , ar [ 0 ] ] NEW_LINE DEDENT a , b = ar [ 0 ] , ar [ 1 ] NEW_LINE bs = ar [ 2 : ] NEW_LINE res = [ ] NEW_LINE if a < b : NEW_LINE INDENT res = [ a ] + bubble_sort ( [ b ] + bs ) NEW_LINE DEDENT else : NEW_LINE INDENT res = [ b ] + bubble_sort ( [ a ] + bs ) NEW_LINE DEDENT return bubble_sort ( res [ : - 1 ] ) + res [ - 1 : ] NEW_LINE DEDENT
def sortBoundaryWise ( a ) : NEW_LINE INDENT k = 0 NEW_LINE l = 0 NEW_LINE m = len ( a ) NEW_LINE n = len ( a [ 0 ] ) NEW_LINE n_k = 0 NEW_LINE n_l = 0 NEW_LINE n_m = m NEW_LINE n_n = n NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT boundary = [ ] NEW_LINE for i in range ( l , n ) : NEW_LINE INDENT boundary . append ( a [ k ] [ i ] ) NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT boundary . append ( a [ i ] [ n - 1 ] ) NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT boundary . append ( a [ m - 1 ] [ i ] ) NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT boundary . append ( a [ i ] [ l ] ) NEW_LINE DEDENT l += 1 NEW_LINE DEDENT boundary . sort ( ) NEW_LINE ind = 0 NEW_LINE for i in range ( n_l , n_n ) : NEW_LINE INDENT a [ n_k ] [ i ] = boundary [ ind ] NEW_LINE ind += 1 NEW_LINE DEDENT n_k += 1 NEW_LINE for i in range ( n_k , n_m ) : NEW_LINE INDENT a [ i ] [ n_n - 1 ] = boundary [ ind ] NEW_LINE ind += 1 NEW_LINE DEDENT n_n -= 1 NEW_LINE if ( n_k < n_m ) : NEW_LINE INDENT for i in range ( n_n - 1 , n_l - 1 , - 1 ) : NEW_LINE INDENT a [ n_m - 1 ] [ i ] = boundary [ ind ] NEW_LINE ind += 1 NEW_LINE DEDENT n_m -= 1 NEW_LINE DEDENT if ( n_l < n_n ) : NEW_LINE INDENT for i in range ( n_m - 1 , n_k - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ n_l ] = boundary [ ind ] NEW_LINE ind += 1 NEW_LINE DEDENT n_l += 1 NEW_LINE DEDENT DEDENT printMatrix ( a ) NEW_LINE DEDENT
def countPairs ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT high = bisect_right ( arr , k * arr [ i ] ) NEW_LINE ans += high - i - 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def findXOR ( mat , K ) : NEW_LINE INDENT N = len ( mat ) NEW_LINE M = len ( mat [ 0 ] ) NEW_LINE digXOR = [ ] NEW_LINE for l in range ( 1 , N + M , 1 ) : NEW_LINE INDENT s_col = max ( 0 , l - N ) NEW_LINE count = min ( [ l , ( M - s_col ) , N ] ) NEW_LINE currXOR = 0 NEW_LINE for j in range ( count ) : NEW_LINE INDENT currXOR = ( currXOR ^ mat [ min ( N , l ) - j - 1 ] [ s_col + j ] ) NEW_LINE DEDENT digXOR . append ( currXOR ) NEW_LINE DEDENT digXOR . sort ( reverse = False ) NEW_LINE print ( digXOR [ N + M - 1 - K ] ) NEW_LINE DEDENT
def countArraysUtil ( arr , X , K , xorVal ) : NEW_LINE INDENT global ans NEW_LINE if ( X == 0 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > xorVal ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return NEW_LINE DEDENT temp = arr [ 0 ] NEW_LINE arr . pop ( 0 ) NEW_LINE countArraysUtil ( arr , X - 1 , K , xorVal ) NEW_LINE arr . insert ( 0 , temp ) NEW_LINE temp = arr [ - 1 ] NEW_LINE arr . pop ( ) NEW_LINE countArraysUtil ( arr , X - 1 , K , xorVal ) NEW_LINE arr . append ( temp ) NEW_LINE arr [ 0 ] += 1 NEW_LINE countArraysUtil ( arr , X - 1 , K , xorVal ) NEW_LINE arr [ 0 ] -= 1 NEW_LINE arr [ len ( arr ) - 1 ] += 1 NEW_LINE countArraysUtil ( arr , X - 1 , K , xorVal ) NEW_LINE arr [ len ( arr ) - 1 ] -= 1 NEW_LINE DEDENT
def countArrays ( arr , X , K ) : NEW_LINE INDENT xorVal = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT xorVal = xorVal ^ arr [ i ] NEW_LINE DEDENT countArraysUtil ( arr , X , K , xorVal ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def maximumSum ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE arr . sort ( ) NEW_LINE sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) NEW_LINE print ( sum ) NEW_LINE DEDENT
def getBuckets ( arr , N ) : NEW_LINE INDENT availableWater = N * ( N - 1 ) // 2 NEW_LINE arr . sort ( ) NEW_LINE i , Sum = 0 , 0 NEW_LINE while ( Sum <= availableWater ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT print ( i - 1 , end = "" ) NEW_LINE DEDENT
def minimum_sum ( A , N ) : NEW_LINE INDENT A . sort ( reverse = False ) NEW_LINE sum = sys . maxsize NEW_LINE for i in range ( N - 2 ) : NEW_LINE INDENT sum = min ( sum , abs ( A [ i ] - A [ i + 1 ] ) + abs ( A [ i + 1 ] - A [ i + 2 ] ) ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def minimumIncreasingSubsequences ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freqX = 0 NEW_LINE while ( i < N and arr [ i ] == x ) : NEW_LINE INDENT freqX += 1 NEW_LINE i += 1 NEW_LINE DEDENT count = max ( count , freqX ) NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def maxOps ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE count = 0 NEW_LINE while True : NEW_LINE INDENT arr . sort ( ) NEW_LINE if not arr [ 0 ] and not arr [ 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT arr [ 1 ] -= 1 NEW_LINE arr [ 2 ] -= 1 NEW_LINE count += 1 NEW_LINE print ( count ) NEW_LINE DEDENT DEDENT
def hashFunction ( N ) : NEW_LINE INDENT prime = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 ] NEW_LINE value = 1 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT r = N % 10 NEW_LINE value = value * prime [ r ] NEW_LINE N = N // 10 NEW_LINE DEDENT return value NEW_LINE DEDENT
def findDiff ( arr , n ) : NEW_LINE INDENT m = defaultdict ( lambda : [ ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT h = hashFunction ( arr [ i ] ) NEW_LINE m [ h ] . append ( arr [ i ] ) NEW_LINE DEDENT i = 0 NEW_LINE while ( i != len ( m ) ) : NEW_LINE INDENT if ( len ( m [ i ] ) > 1 ) : NEW_LINE INDENT minn = min ( m [ i ] ) NEW_LINE maxx = max ( m [ i ] ) NEW_LINE print ( maxx - minn ) NEW_LINE break NEW_LINE DEDENT elif ( i == ( len ( m ) - 1 ) ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
def maxScore ( i , A , K , N , dp ) : NEW_LINE INDENT if ( i >= N - 1 ) : NEW_LINE INDENT return A [ N - 1 ] NEW_LINE DEDENT if ( dp [ i ] != - 1 ) : NEW_LINE INDENT return dp [ i ] NEW_LINE DEDENT score = 1 - sys . maxsize NEW_LINE for j in range ( 1 , K + 1 ) : NEW_LINE INDENT score = max ( score , maxScore ( i + j , A , K , N , dp ) ) NEW_LINE DEDENT dp [ i ] = score + A [ i ] NEW_LINE return dp [ i ] NEW_LINE DEDENT
def getScore ( A , N , K ) : NEW_LINE INDENT dp = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT print ( maxScore ( 0 , A , K , N , dp ) ) NEW_LINE DEDENT
def checkifSorted ( A , B , N ) : NEW_LINE INDENT flag = False NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i ] > A [ i + 1 ] ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT break NEW_LINE if ( not flag ) : NEW_LINE INDENT return True NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( B [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT break NEW_LINE for i in range ( N ) : NEW_LINE INDENT if B [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT break NEW_LINE if ( count == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def minOperation ( a , N ) : NEW_LINE INDENT totOps = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT totOps += abs ( a [ i ] - a [ i + 1 ] ) NEW_LINE DEDENT maxOps = max ( abs ( a [ 0 ] - a [ 1 ] ) , abs ( a [ N - 1 ] - a [ N - 2 ] ) ) NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT maxOps = max ( maxOps , abs ( a [ i ] - a [ i - 1 ] ) + abs ( a [ i ] - a [ i + 1 ] ) - abs ( a [ i - 1 ] - a [ i + 1 ] ) ) NEW_LINE DEDENT print ( totOps - maxOps ) NEW_LINE DEDENT
def maxPossibleSum ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE j = N - 3 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE j -= 3 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def findMaxDifference ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE Leftsum = 0 NEW_LINE Totalsum = 0 NEW_LINE Min , Max = 10 ** 8 , - 10 ** 8 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Totalsum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT leftNumbers = i NEW_LINE rightNumbers = n - i - 1 NEW_LINE Totalsum = Totalsum - arr [ i ] NEW_LINE sum = ( leftNumbers * arr [ i ] ) - Leftsum + Totalsum - ( rightNumbers * arr [ i ] ) NEW_LINE Min = min ( Min , sum ) NEW_LINE Max = max ( Max , sum ) NEW_LINE Leftsum += arr [ i ] NEW_LINE DEDENT print ( Max - Min ) NEW_LINE DEDENT
def sameStrings ( str1 , str2 ) : NEW_LINE INDENT N = len ( str1 ) NEW_LINE M = len ( str2 ) NEW_LINE if ( N != M ) : NEW_LINE INDENT return False NEW_LINE DEDENT a , b = [ 0 ] * 256 , [ 0 ] * 256 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE b [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT i = 0 NEW_LINE while ( i < 256 ) : NEW_LINE INDENT if ( ( a [ i ] == 0 and b [ i ] == 0 ) or ( a [ i ] != 0 and b [ i ] != 0 ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = sorted ( a ) NEW_LINE b = sorted ( b ) NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def minSteps ( A , B , M , N ) : NEW_LINE INDENT if ( A [ 0 ] > B [ 0 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B [ 0 ] > A [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( M <= N and A [ 0 ] == B [ 0 ] and A . count ( A [ 0 ] ) == M and B . count ( B [ 0 ] ) == N ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( B [ i ] > B [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT if ( A [ i ] < A [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT if ( A [ i ] > A [ 0 ] ) : NEW_LINE INDENT A [ 0 ] , B [ i ] = B [ i ] , A [ 0 ] NEW_LINE A [ 0 ] , B [ 0 ] = B [ 0 ] , A [ 0 ] NEW_LINE return 2 NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( B [ i ] < B [ 0 ] ) : NEW_LINE INDENT A [ 0 ] , B [ i ] = B [ i ] , A [ 0 ] NEW_LINE A [ 0 ] , B [ 0 ] = B [ 0 ] , A [ 0 ] NEW_LINE return 2 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def merge ( A , left , mid , right ) : NEW_LINE INDENT swaps = 0 NEW_LINE i , j , k = left , mid , left NEW_LINE while ( i < mid and j <= right ) : NEW_LINE INDENT if ( A [ i ] <= A [ j ] ) : NEW_LINE INDENT temp [ k ] = A [ i ] NEW_LINE k , i = k + 1 , i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = A [ j ] NEW_LINE k , j = k + 1 , j + 1 NEW_LINE swaps += mid - i NEW_LINE DEDENT DEDENT while ( i < mid ) : NEW_LINE INDENT temp [ k ] = A [ i ] NEW_LINE k , i = k + 1 , i + 1 NEW_LINE DEDENT while ( j <= right ) : NEW_LINE INDENT temp [ k ] = A [ j ] NEW_LINE k , j = k + 1 , j + 1 NEW_LINE DEDENT while ( left <= right ) : NEW_LINE INDENT A [ left ] = temp [ left ] NEW_LINE left += 1 NEW_LINE DEDENT return swaps NEW_LINE DEDENT
def mergeInsertionSwap ( A , left , right ) : NEW_LINE INDENT swaps = 0 NEW_LINE if ( left < right ) : NEW_LINE INDENT mid = left + ( right - left ) // 2 NEW_LINE swaps += mergeInsertionSwap ( A , left , mid ) NEW_LINE swaps += mergeInsertionSwap ( A , mid + 1 , right ) NEW_LINE swaps += merge ( A , left , mid + 1 , right ) NEW_LINE DEDENT return swaps NEW_LINE DEDENT
def findAns ( A , N , X ) : NEW_LINE INDENT if ( check ( A , X ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT gcd = GCD ( A [ i ] , A [ j ] ) NEW_LINE DEDENT if ( gcd != 1 ) : NEW_LINE INDENT if ( gcd <= X ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
def check ( a , b , Na , Nb , k , m ) : NEW_LINE INDENT if ( Na < k or Nb < m ) : NEW_LINE INDENT return "No" NEW_LINE DEDENT a . sort ( ) NEW_LINE a . sort ( ) NEW_LINE if ( a [ k - 1 ] < b [ Nb - m ] ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT return "No" NEW_LINE DEDENT
def splitArray ( arr , N ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE result = 10 ** 9 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT result = min ( result , arr [ i ] ^ arr [ i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def maxCntRemovedfromArray ( arr , N , brr , M ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE i = 0 NEW_LINE sumArr = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sumArr += arr [ i ] NEW_LINE DEDENT sumBrr = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT sumBrr += brr [ i ] NEW_LINE DEDENT cntRemElem = 0 NEW_LINE while ( i < N and sumArr >= sumBrr ) : NEW_LINE INDENT sumArr -= arr [ i ] NEW_LINE i += 1 NEW_LINE if ( sumArr >= sumBrr ) : NEW_LINE INDENT cntRemElem += 1 NEW_LINE DEDENT DEDENT return cntRemElem NEW_LINE DEDENT
def findPair ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT a , b = arr [ i ] [ 0 ] , arr [ i ] [ 1 ] NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT c , d = arr [ j ] [ 0 ] , arr [ j ] [ 1 ] NEW_LINE if ( a < c and b > d ) : NEW_LINE INDENT print ( "(" , a , b , "), (" , c , d , ")" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( "NO SUCH PAIR EXIST" ) NEW_LINE DEDENT
def printOrder ( order , N , X ) : NEW_LINE INDENT vect = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( order [ i ] % X == 0 ) : NEW_LINE INDENT vect . append ( [ order [ i ] // X , i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT vect . append ( [ order [ i ] // X + 1 , i + 1 ] ) NEW_LINE DEDENT DEDENT vect = sorted ( vect ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( vect [ i ] [ 1 ] , end = " " ) NEW_LINE DEDENT DEDENT
def CountMaximum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def CountMaximum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def numOperation ( arr , N , D ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( ( arr [ i + 1 ] - arr [ i ] ) % D != 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT DEDENT count = 0 NEW_LINE mid = arr [ N // 2 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT count += abs ( mid - arr [ i ] ) // D NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def findSum ( A , N , K ) : NEW_LINE INDENT A . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( N // K , N , K - 1 ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def maxcntPairsSumKRemoved ( arr , k ) : NEW_LINE INDENT cntPairs = 0 NEW_LINE if not arr or len ( arr ) == 1 : NEW_LINE INDENT return cntPairs NEW_LINE DEDENT arr . sort ( ) NEW_LINE left = 0 NEW_LINE right = len ( arr ) - 1 NEW_LINE while left < right : NEW_LINE INDENT s = arr [ left ] + arr [ right ] NEW_LINE if s == k : NEW_LINE INDENT cntPairs += 1 NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT elif s > k : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT left += 1 NEW_LINE DEDENT DEDENT return cntPairs NEW_LINE DEDENT
def selectionSort ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT min_idx = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] < arr [ min_idx ] ) : NEW_LINE INDENT min_idx = j NEW_LINE DEDENT DEDENT arr [ min_idx ] , arr [ i ] = arr [ i ] , arr [ min_idx ] NEW_LINE DEDENT DEDENT
def findSmallestNumLeft ( arr , N ) : NEW_LINE INDENT PQ = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT PQ . append ( arr [ i ] ) NEW_LINE DEDENT PQ = sorted ( PQ ) NEW_LINE while ( len ( PQ ) > 1 ) : NEW_LINE INDENT top1 = PQ [ - 1 ] NEW_LINE del PQ [ - 1 ] NEW_LINE top2 = PQ [ - 1 ] NEW_LINE del PQ [ - 1 ] NEW_LINE PQ . append ( ( top1 + top2 + 1 ) // 2 ) NEW_LINE PQ = sorted ( PQ ) NEW_LINE DEDENT return PQ [ - 1 ] NEW_LINE DEDENT
def digitProduct ( number ) : NEW_LINE INDENT product = 1 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT product *= ( number % 10 ) NEW_LINE number //= 10 NEW_LINE DEDENT return product NEW_LINE DEDENT
def compositedigitProduct ( num ) : NEW_LINE INDENT res = digitProduct ( num ) NEW_LINE if ( res == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( isComposite ( res ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def largestCompositeDigitProduct ( a , n , k ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( i % k ) == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( compositedigitProduct ( a [ i ] ) ) : NEW_LINE INDENT b = digitProduct ( a [ i ] ) NEW_LINE pq . append ( [ b , a [ i ] ] ) NEW_LINE DEDENT DEDENT pq = sorted ( pq ) NEW_LINE return pq [ - 1 ] [ 1 ] NEW_LINE DEDENT
def maxSum ( arr , brr , N , K ) : NEW_LINE INDENT crr = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT crr . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( K ) : NEW_LINE INDENT crr . append ( brr [ i ] ) NEW_LINE DEDENT crr = sorted ( crr ) [ : : - 1 ] NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( crr [ i ] > 0 ) : NEW_LINE INDENT sum += crr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE DEDENT
def findMinimum ( arr , N , K ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , 2 * ( N // K ) , 2 ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def findSubarrays ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "NO" ) NEW_LINE DEDENT
def maxFreqElements ( arr , N , K ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT while ( K > 0 ) : NEW_LINE INDENT Max = 0 NEW_LINE for i in mp : NEW_LINE INDENT if ( mp [ i ] > Max ) : NEW_LINE INDENT Max = mp [ i ] NEW_LINE element = i NEW_LINE DEDENT DEDENT print ( element , end = " " ) NEW_LINE if element in mp : NEW_LINE INDENT mp [ element ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ element ] = - 1 NEW_LINE DEDENT K -= 1 NEW_LINE DEDENT DEDENT
def getPairs ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ i ] > K * arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def merge ( arr , temp , l , m , r , K ) : NEW_LINE INDENT i = l NEW_LINE j = m + 1 NEW_LINE cnt = 0 NEW_LINE for l in range ( m + 1 ) : NEW_LINE INDENT found = False NEW_LINE while ( j <= r ) : NEW_LINE INDENT if ( arr [ i ] >= K * arr [ j ] ) : NEW_LINE INDENT found = True NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT cnt += j - ( m + 1 ) NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT k = l NEW_LINE i = l NEW_LINE j = m + 1 NEW_LINE while ( i <= m and j <= r ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ j ] ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i <= m ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT while ( j <= r ) : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def mergeSort ( arr , N , K ) : NEW_LINE INDENT temp = [ 0 ] * N NEW_LINE print ( mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ) NEW_LINE DEDENT
def Selection_Sort ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT min_index = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] < arr [ min_index ] ) : NEW_LINE INDENT min_index = j NEW_LINE DEDENT DEDENT arr [ i ] , arr [ min_index ] = arr [ min_index ] , arr [ i ] NEW_LINE DEDENT DEDENT
def Bubble_Sort ( arr , n ) : NEW_LINE INDENT flag = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( n - i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ j + 1 ] ) : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE flag = True NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def NDivKWithFreq ( arr , N , K ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT cnt = 1 NEW_LINE while ( ( i + 1 ) < N and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE i += 1 NEW_LINE DEDENT if ( cnt > ( N // K ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
def upperBound ( arr , N , K ) : NEW_LINE INDENT l = 0 NEW_LINE r = N NEW_LINE while ( l < r ) : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if ( arr [ mid ] <= K ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT
def NDivKWithFreq ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT X = upperBound ( arr , N , arr [ i ] ) NEW_LINE if ( ( X - i ) > N // 4 ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ) NEW_LINE DEDENT i = X NEW_LINE DEDENT DEDENT
def checkSubsetSum ( A , B , N , K ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( reverse = True ) NEW_LINE sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT sum1 += A [ i ] NEW_LINE sum2 += B [ i ] NEW_LINE DEDENT if ( sum1 > sum2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def printCircularArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def sortCircularArray ( arr , n , k , m ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( k , k + m - 1 ) : NEW_LINE INDENT if ( arr [ j % n ] > arr [ ( j + 1 ) % n ] ) : NEW_LINE INDENT arr [ j % n ] , arr [ ( j + 1 ) % n ] = ( arr [ ( j + 1 ) % n ] , arr [ j % n ] ) NEW_LINE DEDENT DEDENT DEDENT printCircularArray ( arr , n ) NEW_LINE DEDENT
def rearrangeArray ( a , n ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] == i + 1 ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE DEDENT DEDENT if ( a [ n - 1 ] == n ) : NEW_LINE INDENT a [ n - 1 ] , a [ n - 2 ] = a [ n - 2 ] , a [ n - 1 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def maximumKthLargestsumPart ( arr , N , M , K ) : NEW_LINE INDENT maxSum = 0 NEW_LINE if ( N % M != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sz = ( N / M ) NEW_LINE if ( K > sz ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr = sorted ( arr ) NEW_LINE for i in range ( 0 , N // 2 ) : NEW_LINE INDENT t = arr [ i ] NEW_LINE arr [ i ] = arr [ N - i - 1 ] NEW_LINE arr [ N - i - 1 ] = t NEW_LINE DEDENT for i in range ( 1 , M + 1 ) : NEW_LINE INDENT maxSum += arr [ i * K - 1 ] NEW_LINE DEDENT return maxSum NEW_LINE DEDENT
def splitArray ( arr , n , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = n - 1 NEW_LINE result = 0 NEW_LINE while ( K > 0 ) : NEW_LINE INDENT result += arr [ i - 1 ] NEW_LINE i -= 2 NEW_LINE K -= 1 NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT
def merge ( indices , a , l , mid , r ) : NEW_LINE INDENT temp_ind = [ 0 ] * ( r - l + 1 ) NEW_LINE j = mid + 1 NEW_LINE i = 0 NEW_LINE temp_l = l NEW_LINE while ( l <= mid and j <= r ) : NEW_LINE INDENT if ( a [ indices [ l ] ] < a [ indices [ j ] ] ) : NEW_LINE INDENT temp_ind [ i ] = indices [ l ] NEW_LINE i += 1 NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp_ind [ i ] = indices [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( l <= mid ) : NEW_LINE INDENT temp_ind [ i ] = indices [ l ] NEW_LINE i += 1 NEW_LINE l += 1 NEW_LINE DEDENT while ( j <= r ) : NEW_LINE INDENT temp_ind [ i ] = indices [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT for k in range ( i ) : NEW_LINE INDENT indices [ temp_l ] = temp_ind [ k ] NEW_LINE temp_l += 1 NEW_LINE DEDENT DEDENT
def divide ( indices , a , l , r ) : NEW_LINE INDENT if ( l >= r ) : NEW_LINE INDENT return NEW_LINE DEDENT mid = l // 2 + r // 2 NEW_LINE divide ( indices , a , l , mid ) NEW_LINE divide ( indices , a , mid + 1 , r ) NEW_LINE merge ( indices , a , l , mid , r ) NEW_LINE DEDENT
def noOfSubsequences ( arr , N ) : NEW_LINE INDENT indices = N * [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT indices [ i ] = i NEW_LINE DEDENT divide ( indices , arr , 0 , N - 1 ) NEW_LINE B = [ 0 ] * N NEW_LINE subseq = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT B [ indices [ i ] ] = subseq NEW_LINE subseq *= 2 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def checkStr1CanConStr2 ( str1 , str2 ) : NEW_LINE INDENT N = len ( str1 ) NEW_LINE M = len ( str2 ) NEW_LINE st1 = set ( [ ] ) NEW_LINE st2 = set ( [ ] ) NEW_LINE hash1 = [ 0 ] * 256 NEW_LINE for i in range ( N ) : NEW_LINE INDENT hash1 [ ord ( str1 [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT st1 . add ( str1 [ i ] ) NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT st2 . add ( str2 [ i ] ) NEW_LINE DEDENT if ( st1 != st2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT hash2 = [ 0 ] * 256 NEW_LINE for i in range ( M ) : NEW_LINE INDENT hash2 [ ord ( str2 [ i ] ) ] += 1 NEW_LINE DEDENT hash1 . sort ( ) NEW_LINE hash2 . sort ( ) NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT if ( hash1 [ i ] != hash2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def sortArrayInDescAsc ( arr , N , K ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE arr = arr [ : : - 1 ] NEW_LINE for i in arr [ : K ] : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT for i in reversed ( arr [ K : ] ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def maxCostToRemove ( arr , N , K ) : NEW_LINE INDENT maxCost = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE for i in range ( 0 , N , K ) : NEW_LINE INDENT maxCost += arr [ i + 1 ] NEW_LINE DEDENT return maxCost NEW_LINE DEDENT
def lexNumbers ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s . append ( convert_to_words ( i ) ) NEW_LINE DEDENT s . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans . append ( s [ i ] ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT print ( ans [ i ] , end = ", " ) NEW_LINE DEDENT print ( ans [ n - 1 ] , end = "" ) NEW_LINE DEDENT
def minimumCost ( binary , n , a , b ) : NEW_LINE INDENT groupOfZeros = [ ] NEW_LINE length = 0 NEW_LINE i = 0 NEW_LINE increment_need = True NEW_LINE while ( i < n ) : NEW_LINE INDENT increment_need = True NEW_LINE while ( i < n and binary [ i ] == 0 ) : NEW_LINE INDENT length += 1 NEW_LINE i += 1 NEW_LINE increment_need = False NEW_LINE DEDENT if ( increment_need == True ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( length != 0 ) : NEW_LINE INDENT groupOfZeros . append ( length ) NEW_LINE DEDENT length = 0 NEW_LINE DEDENT groupOfZeros . sort ( ) NEW_LINE i = 0 NEW_LINE found_ones = False NEW_LINE NumOfOnes = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT found_ones = False NEW_LINE while ( i < n and binary [ i ] == 1 ) : NEW_LINE INDENT i += 1 NEW_LINE found_ones = True NEW_LINE DEDENT if ( found_ones == False ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT NumOfOnes += 1 NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = 0 NEW_LINE totalOnes = NumOfOnes NEW_LINE if ( i == 0 ) : NEW_LINE INDENT curr = totalOnes * a NEW_LINE DEDENT else : NEW_LINE INDENT mark = i NEW_LINE num_of_changes = 0 NEW_LINE for x in groupOfZeros : NEW_LINE INDENT if ( mark >= x ) : NEW_LINE INDENT totalOnes -= 1 NEW_LINE mark -= x NEW_LINE num_of_changes += x NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT curr = ( ( num_of_changes * b ) + ( totalOnes * a ) ) NEW_LINE DEDENT ans = min ( ans , curr ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def isSortedparitions ( arr , i , j ) : NEW_LINE INDENT for k in range ( i + 1 , j + 1 ) : NEW_LINE INDENT if ( arr [ k ] < arr [ k - 1 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def partitionsArr ( arr , i , j ) : NEW_LINE INDENT if ( i >= j ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT flag = int ( isSortedparitions ( arr , i , j ) ) NEW_LINE if ( flag != 0 ) : NEW_LINE INDENT return ( j - i + 1 ) NEW_LINE DEDENT mid = ( i + j ) // 2 NEW_LINE X = partitionsArr ( arr , i , mid ) NEW_LINE Y = partitionsArr ( arr , mid + 1 , j ) NEW_LINE return max ( X , Y ) NEW_LINE DEDENT
def checkIfPossibleMerge ( A , B , N ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE prev = - 1 NEW_LINE flag = 1 NEW_LINE while ( i < N and j < N ) : NEW_LINE INDENT if ( A [ i ] < B [ j ] and prev != 0 ) : NEW_LINE INDENT prev = 0 NEW_LINE i += 1 NEW_LINE DEDENT elif ( B [ j ] < A [ i ] and prev != 1 ) : NEW_LINE INDENT prev = 1 NEW_LINE j += 1 NEW_LINE DEDENT elif ( A [ i ] == B [ j ] ) : NEW_LINE INDENT if ( prev != 1 ) : NEW_LINE INDENT prev = 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT prev = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT
def maxSum ( n , a , l , q ) : NEW_LINE INDENT v = [ ] NEW_LINE d = [ 0 ] * n NEW_LINE for i in range ( q ) : NEW_LINE INDENT for x in range ( l [ i ] [ 0 ] , l [ i ] [ 1 ] + 1 ) : NEW_LINE INDENT if ( d [ x ] == 0 ) : NEW_LINE INDENT d [ x ] = 1 NEW_LINE DEDENT DEDENT DEDENT st = set ( [ ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( d [ i ] == 0 ) : NEW_LINE INDENT v . append ( a [ i ] ) NEW_LINE st . add ( i ) NEW_LINE DEDENT DEDENT v . sort ( reverse = True ) NEW_LINE c = 0 NEW_LINE for it in st : NEW_LINE INDENT a [ it ] = v NEW_LINE c += 1 NEW_LINE DEDENT pref_sum = 0 NEW_LINE temp_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp_sum += a [ i ] NEW_LINE pref_sum += temp_sum NEW_LINE DEDENT return pref_sum NEW_LINE DEDENT
def countPairs ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT xo = ( A [ i ] ^ A [ j ] ) NEW_LINE mx = max ( A [ i ] , A [ j ] ) NEW_LINE if ( xo > mx ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def findMedianOfsubSum ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT arr . sort ( reverse = False ) NEW_LINE dp = [ [ 0 for i in range ( sum + 1 ) ] for j in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT dp [ 0 ] [ arr [ 0 ] ] = 1 NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 , 1 ) : NEW_LINE INDENT if ( j >= arr [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - arr [ i ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sumSub = [ ] NEW_LINE for j in range ( 1 , sum + 1 , 1 ) : NEW_LINE INDENT M = dp [ N - 1 ] [ j ] NEW_LINE for i in range ( 1 , M + 1 , 1 ) : NEW_LINE INDENT sumSub . append ( j ) NEW_LINE DEDENT DEDENT mid = sumSub [ len ( sumSub ) // 2 ] NEW_LINE return mid NEW_LINE DEDENT
def maxDiffLargSmallOper ( arr , N , K ) : NEW_LINE INDENT maxDiff = 0 NEW_LINE arr . sort ( reverse = True ) NEW_LINE for i in range ( min ( K + 1 , N ) ) : NEW_LINE INDENT maxDiff += arr [ i ] NEW_LINE DEDENT return maxDiff NEW_LINE DEDENT
def findTheOrder ( arr , s , N ) : NEW_LINE INDENT ans = [ ] NEW_LINE A = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT A [ i ] = [ arr [ i ] , i + 1 ] NEW_LINE DEDENT A = sorted ( A ) NEW_LINE q = [ ] NEW_LINE index = 0 NEW_LINE for i in range ( 2 * N ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ans . append ( A [ index ] [ 1 ] ) NEW_LINE q . append ( A [ index ] ) NEW_LINE index += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( q [ - 1 ] [ 1 ] ) NEW_LINE del q [ - 1 ] NEW_LINE DEDENT q = sorted ( q ) NEW_LINE DEDENT for i in ans : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def checkArrangement ( A1 , A2 , n , k ) : NEW_LINE INDENT A1 = sorted ( A1 ) NEW_LINE A2 = sorted ( A2 ) NEW_LINE A2 = A2 [ : : - 1 ] NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( A1 [ i ] + A2 [ i ] > k ) or ( A1 [ i ] + A2 [ i ] < k // 2 ) ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT DEDENT
def MaxRearrngeSum ( A , B , N ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( reverse = True ) NEW_LINE maxSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT maxSum += abs ( A [ i ] - B [ i ] ) NEW_LINE DEDENT return maxSum NEW_LINE DEDENT
def largestArea ( arr1 , n , arr2 , m ) : NEW_LINE INDENT end = 0 NEW_LINE start = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE arr1 . sort ( reverse = False ) NEW_LINE arr2 . sort ( reverse = False ) NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( start == 0 ) : NEW_LINE INDENT start = arr1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT end = arr1 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if ( end == 0 or start == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( end - start ) NEW_LINE DEDENT DEDENT
def count_pairs ( arr , brr , N , M , K ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE cntPairs = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE brr = sorted ( brr ) NEW_LINE while ( i < N and j < M ) : NEW_LINE INDENT if ( brr [ j ] - arr [ i ] > K ) : NEW_LINE INDENT cntPairs += ( M - j ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT return cntPairs NEW_LINE DEDENT
def firstSubsequence ( s ) : NEW_LINE INDENT allsubseq = [ ] NEW_LINE k = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT k = [ i for i in s ] NEW_LINE del k [ i ] NEW_LINE allsubseq . append ( "" . join ( k ) ) NEW_LINE DEDENT allsubseq = sorted ( allsubseq ) NEW_LINE print ( allsubseq [ 0 ] ) NEW_LINE DEDENT
def firstSubsequence ( s ) : NEW_LINE INDENT isMax = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT isMax = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( isMax >= 0 ) : NEW_LINE INDENT s = s [ 0 : isMax ] + s [ isMax + 1 : len ( s ) ] NEW_LINE DEDENT s . rerase ( isMax , 1 ) NEW_LINE else : s . erase ( s . length ( ) - 1 , 1 ) NEW_LINE s = s [ 0 : s . length ( ) - 1 ] NEW_LINE print ( s ) NEW_LINE DEDENT
def minHeapify ( brr , i , M ) : NEW_LINE INDENT left = 2 * i + 1 NEW_LINE right = 2 * i + 2 NEW_LINE smallest = i NEW_LINE if ( left < M and brr [ left ] < brr [ smallest ] ) : NEW_LINE INDENT smallest = left NEW_LINE DEDENT if ( right < M and brr [ right ] < brr [ smallest ] ) : NEW_LINE INDENT smallest = right NEW_LINE DEDENT if ( smallest != i ) : NEW_LINE INDENT brr [ i ] , brr [ smallest ] = brr [ smallest ] , brr [ i ] NEW_LINE minHeapify ( brr , smallest , M ) NEW_LINE DEDENT DEDENT
def merge ( arr , brr , N , M ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] > brr [ 0 ] ) : NEW_LINE INDENT arr [ i ] , brr [ 0 ] = brr [ 0 ] , arr [ i ] NEW_LINE minHeapify ( brr , 0 , M ) NEW_LINE DEDENT DEDENT brr . sort ( ) NEW_LINE DEDENT
def printArray ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def rankLessThanK ( arr , k , n ) : NEW_LINE INDENT rank = 1 NEW_LINE position = 1 NEW_LINE arr = sorted ( arr ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i == n - 1 or arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT rank = position NEW_LINE if ( rank > k ) : NEW_LINE INDENT return position - 1 NEW_LINE DEDENT DEDENT position += 1 NEW_LINE DEDENT return n NEW_LINE DEDENT
def calculateFib ( fib , n ) : NEW_LINE INDENT fib [ 0 ] = fib [ 1 ] = 1 NEW_LINE for x in range ( 2 , n ) : NEW_LINE INDENT fib [ x ] = ( fib [ x - 1 ] + fib [ x - 2 ] ) NEW_LINE DEDENT DEDENT
def find_mth_bit ( n , m , fib ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT len_left = fib [ n - 2 ] NEW_LINE len_right = fib [ n - 1 ] NEW_LINE if ( m <= len_left ) : NEW_LINE INDENT return find_mth_bit ( n - 2 , len_left + 1 - m , fib ) NEW_LINE DEDENT else : NEW_LINE INDENT return find_mth_bit ( n - 1 , len_right + 1 - ( m - len_left ) , fib ) NEW_LINE DEDENT DEDENT
def KthSmallestNum ( arr , n , k ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT pq . append ( [ arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ] ) NEW_LINE DEDENT cnt = 1 NEW_LINE while ( cnt < k ) : NEW_LINE INDENT pq . sort ( reverse = True ) NEW_LINE interval = pq [ 0 ] NEW_LINE pq . remove ( pq [ 0 ] ) NEW_LINE if ( interval [ 0 ] < interval [ 1 ] ) : NEW_LINE INDENT pq . append ( [ interval [ 0 ] + 1 , interval [ 1 ] ] ) NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT pq . sort ( reverse = True ) NEW_LINE return pq [ 0 ] [ 0 ] + 1 NEW_LINE DEDENT
def maxArea ( point_x , point_y , n , length , width ) : NEW_LINE INDENT point_x . sort ( ) NEW_LINE point_y . sort ( ) NEW_LINE dx = point_x [ 0 ] NEW_LINE dy = point_y [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dx = max ( dx , point_x [ i ] - point_x [ i - 1 ] ) NEW_LINE dy = max ( dy , point_y [ i ] - point_y [ i - 1 ] ) NEW_LINE DEDENT dx = max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) NEW_LINE dy = max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) NEW_LINE print ( ( dx - 1 ) * ( dy - 1 ) ) NEW_LINE DEDENT
def LongestSequence ( a , n ) : NEW_LINE INDENT m = { i : 0 for i in range ( 100 ) } NEW_LINE ar = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ar [ i ] = a [ i - 1 ] NEW_LINE DEDENT a . sort ( reverse = False ) NEW_LINE c = 1 NEW_LINE m [ a [ 0 ] ] = c NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] != a [ i - 1 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT m [ a [ i ] ] = c NEW_LINE cnt = { i : 0 for i in range ( 100 ) } NEW_LINE dp = [ [ 0 for i in range ( 3 ) ] for j in range ( n + 1 ) ] NEW_LINE cnt [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ar [ i ] = m [ ar [ i ] ] NEW_LINE cnt [ ar [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = ar [ i ] NEW_LINE if ( dp [ x ] [ 0 ] == 0 ) : NEW_LINE INDENT if ( dp [ x - 1 ] [ 0 ] == cnt [ x - 1 ] ) : NEW_LINE INDENT dp [ x ] [ 1 ] = dp [ x - 1 ] [ 1 ] NEW_LINE dp [ x ] [ 2 ] = dp [ x - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ x ] [ 1 ] = dp [ x - 1 ] [ 0 ] NEW_LINE DEDENT dp [ x ] [ 2 ] = max ( dp [ x - 1 ] [ 0 ] , dp [ x ] [ 2 ] ) NEW_LINE if ( dp [ x - 1 ] [ 0 ] == cnt [ x - 1 ] ) : NEW_LINE INDENT dp [ x ] [ 2 ] = max ( dp [ x ] [ 2 ] , dp [ x - 1 ] [ 1 ] ) NEW_LINE DEDENT for j in range ( 3 ) : NEW_LINE INDENT dp [ x ] [ j ] += 1 NEW_LINE ans = max ( ans , dp [ x ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT DEDENT
def solve ( values , salary ) : NEW_LINE INDENT ret = 1 NEW_LINE amt = 0 NEW_LINE values = sorted ( values ) NEW_LINE salary = sorted ( salary ) NEW_LINE while ( len ( salary ) > 0 ) : NEW_LINE INDENT while ( ( len ( values ) and values [ - 1 ] >= salary [ - 1 ] ) ) : NEW_LINE INDENT amt += 1 NEW_LINE del values [ - 1 ] NEW_LINE DEDENT if ( amt == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ret *= amt NEW_LINE amt -= 1 NEW_LINE ret %= MOD NEW_LINE del salary [ - 1 ] NEW_LINE DEDENT return ret NEW_LINE DEDENT
def precompute_sum ( arr , brr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT arr [ i ] = arr [ i ] + arr [ i - 1 ] NEW_LINE brr [ i ] = brr [ i ] + brr [ i - 1 ] NEW_LINE DEDENT DEDENT
def find_sum ( arr , q , Queries ) : NEW_LINE INDENT brr = arr . copy ( ) NEW_LINE N = len ( arr ) NEW_LINE brr . sort ( ) NEW_LINE precompute_sum ( arr , brr ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT m = Queries [ i ] [ 0 ] NEW_LINE a = Queries [ i ] [ 1 ] NEW_LINE b = Queries [ i ] [ 2 ] NEW_LINE if ( m == 1 ) : NEW_LINE INDENT print ( range_sum ( arr , a , b ) , end = ' ' ) NEW_LINE DEDENT elif ( m == 2 ) : NEW_LINE INDENT print ( range_sum ( brr , a , b ) , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT
def minsteps ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += abs ( arr [ i ] - pow ( 2 , i ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findCost ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT p = a [ j ] - j NEW_LINE a [ j ] = 0 NEW_LINE if ( p < 0 ) : NEW_LINE INDENT p = 0 NEW_LINE continue NEW_LINE DEDENT count += p NEW_LINE DEDENT return count NEW_LINE DEDENT
def make_cuts ( arr , n , K ) : NEW_LINE INDENT ans = 0 NEW_LINE poss = [ ] NEW_LINE ce = 0 NEW_LINE co = 0 NEW_LINE for x in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ x ] % 2 == 0 ) : NEW_LINE INDENT ce += 1 NEW_LINE DEDENT else : NEW_LINE INDENT co += 1 NEW_LINE DEDENT if ( ce == co and co > 0 and ce > 0 ) : NEW_LINE INDENT poss . append ( abs ( arr [ x ] - arr [ x + 1 ] ) ) NEW_LINE DEDENT DEDENT poss . sort ( ) NEW_LINE for x in poss : NEW_LINE INDENT if ( K >= x ) : NEW_LINE INDENT ans += 1 NEW_LINE K -= x NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def Arrange ( arr , n ) : NEW_LINE INDENT cost = 0 NEW_LINE index = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT index [ arr [ i ] ] = i NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] + arr [ - 1 ] ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT cost += abs ( index [ arr [ i ] ] - i ) NEW_LINE DEDENT DEDENT elif ( i == n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] + arr [ 0 ] ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT cost += abs ( index [ arr [ i ] ] - i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] + arr [ i + 1 ] ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT cost += abs ( index [ arr [ i ] ] - i ) NEW_LINE DEDENT DEDENT DEDENT print ( cost ) NEW_LINE return NEW_LINE DEDENT
def maxDistinctChar ( s , n , k ) : NEW_LINE INDENT freq = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ s [ i ] ] += 1 NEW_LINE DEDENT v = [ ] NEW_LINE for it in freq . values ( ) : NEW_LINE INDENT v . append ( it ) NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT mn = min ( v [ i ] - 1 , k ) NEW_LINE v [ i ] -= mn NEW_LINE k -= mn NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT for i in range ( len ( v ) ) : NEW_LINE INDENT mn = min ( v [ i ] , k ) NEW_LINE v [ i ] -= mn NEW_LINE k -= mn NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( v [ i ] == 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def getMaxSum ( i , j , k , arr1 , arr2 , arr3 ) : NEW_LINE INDENT cnt = 0 NEW_LINE if ( i >= n1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( j >= n2 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( k >= n3 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( cnt >= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( i < n1 and j < n2 ) : NEW_LINE INDENT ans = max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) NEW_LINE DEDENT if ( i < n1 and k < n3 ) : NEW_LINE INDENT ans = max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) NEW_LINE DEDENT if ( j < n2 and k < n3 ) : NEW_LINE INDENT ans = max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) NEW_LINE DEDENT dp [ i ] [ j ] [ k ] = ans NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT
def maxProductSum ( arr1 , arr2 , arr3 ) : NEW_LINE INDENT for i in range ( len ( dp ) ) : NEW_LINE INDENT for j in range ( len ( dp [ 0 ] ) ) : NEW_LINE INDENT for k in range ( len ( dp [ j ] [ 0 ] ) ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = - 1 NEW_LINE DEDENT DEDENT DEDENT arr1 . sort ( ) NEW_LINE reverse ( arr1 ) NEW_LINE arr2 . sort ( ) NEW_LINE reverse ( arr2 ) NEW_LINE arr3 . sort ( ) NEW_LINE reverse ( arr3 ) NEW_LINE return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * 10005 NEW_LINE p = 2 NEW_LINE while p * p <= 1000 : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , 1001 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , 1001 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT DEDENT
def findMaxValue ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] NEW_LINE maxPossible = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxPossible > 0 ) : NEW_LINE INDENT if ( arr [ i ] >= maxPossible ) : NEW_LINE INDENT ans += ( maxPossible - 1 ) NEW_LINE maxPossible = maxPossible - 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxPossible = arr [ i ] NEW_LINE ans += maxPossible NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE arr . sort ( ) NEW_LINE left = 0 NEW_LINE right = 1 NEW_LINE while ( right < n ) : NEW_LINE INDENT if ( arr [ left ] == arr [ right ] ) : NEW_LINE INDENT ans += right - left NEW_LINE DEDENT else : NEW_LINE INDENT left = right NEW_LINE DEDENT right += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maximizeFinalElement ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE if ( arr [ 0 ] != 1 ) : NEW_LINE INDENT arr [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] > 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT return arr [ n - 1 ] NEW_LINE DEDENT
def findLeastDist ( A , N ) : NEW_LINE INDENT A . sort ( ) NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT return A [ ( N - 1 ) // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT return A [ N // 2 ] NEW_LINE DEDENT DEDENT
def maxSubMatSum ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE m = len ( mat [ 0 ] ) NEW_LINE dp = [ [ 0 ] * m for _ in range ( n ) ] NEW_LINE dp [ n - 1 ] [ m - 1 ] = mat [ n - 1 ] [ m - 1 ] NEW_LINE res = dp [ n - 1 ] [ m - 1 ] NEW_LINE for i in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ n - 1 ] [ i ] = ( mat [ n - 1 ] [ i ] + dp [ n - 1 ] [ i + 1 ] ) NEW_LINE res = max ( res , dp [ n - 1 ] [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ m - 1 ] = ( mat [ i ] [ m - 1 ] + dp [ i + 1 ] [ m - 1 ] ) NEW_LINE res = max ( res , dp [ i ] [ m - 1 ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( mat [ i ] [ j ] + dp [ i ] [ j + 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j + 1 ] ) NEW_LINE res = max ( res , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def solution ( A , B , C ) : NEW_LINE INDENT arr = [ 0 ] * 3 NEW_LINE arr [ 0 ] = A NEW_LINE arr [ 1 ] = B NEW_LINE arr [ 2 ] = C NEW_LINE arr = sorted ( arr ) NEW_LINE if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) : NEW_LINE INDENT return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT
def removeElements ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] * pow ( 2 , i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def canMadeEqual ( A , B , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] != B [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT
def maxMinDifference ( arr , n , k ) : NEW_LINE INDENT if ( k >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE i = k NEW_LINE j = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT ans = min ( arr [ j ] - arr [ i ] , ans ) NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def inversionCount ( s ) : NEW_LINE INDENT freq = [ 0 for _ in range ( 26 ) ] NEW_LINE inv = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT temp = 0 NEW_LINE for j in range ( ord ( s [ i ] ) - ord ( 'a' ) ) : NEW_LINE INDENT temp += freq [ j ] NEW_LINE DEDENT inv += ( i - temp ) NEW_LINE freq [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT return inv NEW_LINE DEDENT
def numberofpairs ( arr , N ) : NEW_LINE INDENT answer = 0 NEW_LINE arr . sort ( ) NEW_LINE minDiff = 10000000 NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT minDiff = min ( minDiff , arr [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] - arr [ i ] == minDiff : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def dist ( p1 , p2 ) : NEW_LINE INDENT x0 = p1 [ 0 ] - p2 [ 0 ] NEW_LINE y0 = p1 [ 1 ] - p2 [ 1 ] NEW_LINE return x0 * x0 + y0 * y0 NEW_LINE DEDENT
def maximumSum ( arr , n , k ) : NEW_LINE INDENT elt = n // k NEW_LINE sum = 0 NEW_LINE arr . sort ( ) NEW_LINE count = 0 NEW_LINE i = n - 1 NEW_LINE while ( count < k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE i -= 1 NEW_LINE count += 1 NEW_LINE DEDENT count = 0 NEW_LINE i = 0 NEW_LINE while ( count < k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE i += elt - 1 NEW_LINE count += 1 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def countMinSteps ( arr , target , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minimumSteps = 0 NEW_LINE i , j = 0 , n - 1 NEW_LINE while i <= j : NEW_LINE INDENT if arr [ i ] + arr [ j ] <= target : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT minimumSteps += 1 NEW_LINE DEDENT return minimumSteps NEW_LINE DEDENT
def build_num ( bit ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( bit [ i ] ) : NEW_LINE INDENT ans += ( 1 << i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maximumOR ( arr , n , k ) : NEW_LINE INDENT bit = [ 0 ] * 32 NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if ( bit [ i ] == 0 and k > 0 ) : NEW_LINE INDENT temp = build_num ( bit ) NEW_LINE temp1 = temp NEW_LINE val = - 1 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( temp1 < ( temp arr [ j ] ) ) : NEW_LINE INDENT temp1 = temp | arr [ j ] NEW_LINE val = arr [ j ] NEW_LINE DEDENT DEDENT if ( val != - 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE for j in range ( 0 , 32 ) : NEW_LINE INDENT if ( val & ( 1 << j ) ) : NEW_LINE INDENT bit [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return build_num ( bit ) NEW_LINE DEDENT
def findMinSum ( arr , K , L , size ) : NEW_LINE INDENT if ( K * L > size ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minsum = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( K ) : NEW_LINE INDENT minsum += arr [ i ] NEW_LINE DEDENT return minsum NEW_LINE DEDENT
def find_max_length ( arr , index , sum , k ) : NEW_LINE INDENT global max_length NEW_LINE sum = sum + arr [ index ] NEW_LINE store . append ( arr [ index ] ) NEW_LINE if ( sum == k ) : NEW_LINE INDENT if ( max_length < len ( store ) ) : NEW_LINE INDENT max_length = len ( store ) NEW_LINE ans = store NEW_LINE DEDENT DEDENT for i in range ( index + 1 , len ( arr ) ) : NEW_LINE INDENT if ( sum + arr [ i ] <= k ) : NEW_LINE INDENT find_max_length ( arr , i , sum , k ) NEW_LINE store . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def longestSubsequence ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max_length >= n - i ) : NEW_LINE INDENT break NEW_LINE DEDENT store . clear ( ) NEW_LINE find_max_length ( arr , i , 0 , k ) NEW_LINE DEDENT return max_length NEW_LINE DEDENT
def minBox ( arr , n ) : NEW_LINE INDENT box = n NEW_LINE arr . sort ( ) NEW_LINE curr_box , next_box = 0 , 1 NEW_LINE while ( curr_box < n and next_box < n ) : NEW_LINE INDENT if ( arr [ curr_box ] < arr [ next_box ] ) : NEW_LINE INDENT box = box - 1 NEW_LINE curr_box = curr_box + 1 NEW_LINE next_box = next_box + 1 NEW_LINE DEDENT elif ( arr [ curr_box ] == arr [ next_box ] ) : NEW_LINE INDENT next_box = next_box + 1 NEW_LINE DEDENT DEDENT print ( box ) NEW_LINE DEDENT
def setData ( head ) : NEW_LINE INDENT tmp = head NEW_LINE while ( tmp != None ) : NEW_LINE INDENT print ( tmp . data , end = " -> " ) NEW_LINE tmp = tmp . next NEW_LINE DEDENT DEDENT
def findMedian ( a , n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return a [ int ( n / 2 ) ] NEW_LINE DEDENT return ( a [ int ( ( n - 1 ) / 2 ) ] + a [ int ( n / 2 ) ] ) / 2.0 NEW_LINE DEDENT
def kStrongest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE median = findMedian ( arr , n ) NEW_LINE diff = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT diff [ i ] = abs ( median - arr [ i ] ) NEW_LINE DEDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( k > 0 ) : NEW_LINE INDENT if ( diff [ i ] > diff [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ j ] , end = " " ) NEW_LINE j -= 1 NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT DEDENT
def sorting_possible ( a , b , n ) : NEW_LINE INDENT sorted = True NEW_LINE type1 = 0 NEW_LINE type0 = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT sorted = False NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] == 0 ) : NEW_LINE INDENT type0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT type1 += 1 NEW_LINE DEDENT DEDENT if ( sorted != False ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( type1 == n or type0 == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def lexNumbers ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s . append ( str ( i ) ) NEW_LINE DEDENT s . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans . append ( int ( s [ i ] ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT
def dfs ( temp , n , sol ) : NEW_LINE INDENT if ( temp > n ) : NEW_LINE INDENT return NEW_LINE DEDENT sol . append ( temp ) NEW_LINE dfs ( temp * 10 , n , sol ) NEW_LINE if ( temp % 10 != 9 ) : NEW_LINE INDENT dfs ( temp + 1 , n , sol ) NEW_LINE DEDENT DEDENT
def findMinDif ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return ( arr [ N - 1 ] - arr [ N - 2 ] ) NEW_LINE DEDENT
def partition ( arr , l , h ) : NEW_LINE INDENT pivot = arr [ l ] NEW_LINE i = l + 1 NEW_LINE j = h NEW_LINE while ( i <= j ) : NEW_LINE INDENT while ( i <= h and arr [ i ] < pivot ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( j > l and arr [ j ] > pivot ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i < j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT arr [ l ] = arr [ j ] NEW_LINE arr [ j ] = pivot NEW_LINE return j NEW_LINE DEDENT
def sortArray ( arr , l , h ) : NEW_LINE INDENT if ( l >= h ) : NEW_LINE INDENT return NEW_LINE DEDENT pivot = partition ( arr , l , h ) NEW_LINE sortArray ( arr , l , pivot - 1 ) NEW_LINE sortArray ( arr , pivot + 1 , h ) NEW_LINE DEDENT
def findMaxIntervals ( start , end , n , R ) : NEW_LINE INDENT ans = 0 NEW_LINE prev = 0 NEW_LINE currActive = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE if ( start [ 0 ] > 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT while ( i < n and j < n ) : NEW_LINE INDENT if ( start [ i ] < end [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE currActive += 1 NEW_LINE DEDENT elif ( start [ i ] > end [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE currActive -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( currActive == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ( end [ n - 1 ] < R ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sortArray ( A , N ) : NEW_LINE INDENT if ( N % 4 == 0 or N % 4 == 1 ) : NEW_LINE INDENT for i in range ( N // 2 ) : NEW_LINE INDENT x = i NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT y = N - i - 2 NEW_LINE z = N - i - 1 NEW_LINE DEDENT A [ z ] = A [ y ] NEW_LINE A [ y ] = A [ x ] NEW_LINE A [ x ] = x + 1 NEW_LINE DEDENT print ( "Sorted Array: " , end = "" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( A [ i ] , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def check_vector ( A , n , p ) : NEW_LINE INDENT pos = [ 0 for i in range ( len ( A ) ) ] NEW_LINE for i in range ( len ( p ) ) : NEW_LINE INDENT pos [ p [ i ] - 1 ] = 1 NEW_LINE DEDENT flag = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( pos [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT j = i NEW_LINE while ( j < n and pos [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT p = A [ : i ] NEW_LINE q = A [ i : i + j + 1 ] NEW_LINE r = A [ i + j + 1 : len ( A ) ] NEW_LINE q . sort ( reverse = False ) NEW_LINE A = p + q + r NEW_LINE i = j NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i ] > A [ i + 1 ] ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def dfs ( x ) : NEW_LINE INDENT global s , g , ns NEW_LINE v = [ ] NEW_LINE v . clear ( ) NEW_LINE ns . clear ( ) NEW_LINE for it in s : NEW_LINE INDENT if ( x in g and not g [ x ] [ it ] ) : NEW_LINE INDENT v . append ( it ) NEW_LINE DEDENT else : NEW_LINE INDENT ns . add ( it ) NEW_LINE DEDENT DEDENT s = ns NEW_LINE for i in v : NEW_LINE INDENT dfs ( i ) NEW_LINE DEDENT DEDENT
def weightOfMST ( N ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE t = list ( s ) [ 0 ] NEW_LINE s . discard ( t ) NEW_LINE dfs ( t ) NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT
def sortDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE out = [ ] NEW_LINE while n : NEW_LINE INDENT out . append ( arr . pop ( n // 2 ) ) NEW_LINE n = n - 1 NEW_LINE DEDENT print ( * out ) NEW_LINE return out NEW_LINE DEDENT
def minimumCost ( arr , N , M ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE pref = [ ] NEW_LINE pref . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT pref . append ( arr [ i ] + pref [ i - 1 ] ) NEW_LINE DEDENT for i in range ( M , N ) : NEW_LINE INDENT pref [ i ] += pref [ i - M ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( pref [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT
def countPairs ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] > B [ ans ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def uniqueSum ( A , R , N , M ) : NEW_LINE INDENT for i in range ( 0 , M ) : NEW_LINE INDENT l = R [ i ] [ 0 ] NEW_LINE r = R [ i ] [ 1 ] + 1 NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE A [ l ] += 1 NEW_LINE if ( r < N ) : NEW_LINE INDENT A [ r ] -= 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT A [ i ] += A [ i - 1 ] NEW_LINE DEDENT ans = 0 NEW_LINE s = { chr } NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] not in s ) : NEW_LINE INDENT ans += A [ i ] NEW_LINE DEDENT s . add ( A [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def kthpair ( n , k , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE k -= 1 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT t = 1 NEW_LINE while ( arr [ i ] == arr [ i + t ] ) : NEW_LINE INDENT t += 1 NEW_LINE DEDENT if ( t * n > k ) : NEW_LINE INDENT break NEW_LINE DEDENT k = k - t * n NEW_LINE i += t NEW_LINE DEDENT print ( arr [ i ] , " " , arr [ k // t ] ) NEW_LINE DEDENT
def minOperations ( s ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( 'A' ) ] += 1 NEW_LINE DEDENT freq . sort ( reverse = True ) NEW_LINE answer = n NEW_LINE for i in range ( 1 , 27 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT x = n // i NEW_LINE y = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT y += min ( freq [ j ] , x ) NEW_LINE DEDENT answer = min ( answer , n - y ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def printArray ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT
def sortArray ( arr , N ) : NEW_LINE INDENT i = 0 NEW_LINE while i < N : NEW_LINE INDENT if arr [ i ] == i + 1 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp1 = arr [ i ] NEW_LINE temp2 = arr [ arr [ i ] - 1 ] NEW_LINE arr [ i ] = temp2 NEW_LINE arr [ temp1 - 1 ] = temp1 NEW_LINE DEDENT DEDENT DEDENT
def fun ( arr , n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT for j in range ( i , n , k ) : NEW_LINE INDENT v . append ( arr [ j ] ) NEW_LINE DEDENT v . sort ( ) NEW_LINE x = 0 NEW_LINE for j in range ( i , n , k ) : NEW_LINE INDENT arr [ j ] = v [ x ] NEW_LINE x += 1 NEW_LINE DEDENT v = [ ] NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def CheckSort ( arr , k , n ) : NEW_LINE INDENT sortarr = sorted ( arr ) NEW_LINE if ( k == 1 ) : NEW_LINE INDENT print ( "yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( i , n , k ) : NEW_LINE INDENT if ( sortarr [ i ] == arr [ j ] ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT if ( j + k >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( "Not possible to sort" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Possible to sort" ) NEW_LINE DEDENT DEDENT DEDENT
def sortedAdjacentDifferences ( arr , n ) : NEW_LINE INDENT ans = [ 0 ] * n NEW_LINE arr = sorted ( arr ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i % 2 ) : NEW_LINE INDENT ans [ i ] = arr [ l ] NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = arr [ r ] NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def get_permutation ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += abs ( arr [ i ] - ( i + 1 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def minimumIncDec ( arr , N , maxE , minE ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ N ] [ maxE ] ) : NEW_LINE INDENT return dp [ N ] [ maxE ] NEW_LINE DEDENT ans = sys . maxsize NEW_LINE for k in range ( minE , maxE + 1 ) : NEW_LINE INDENT x = minimumIncDec ( arr , N - 1 , k , minE ) NEW_LINE ans = min ( ans , x + abs ( arr [ N - 1 ] - k ) ) NEW_LINE DEDENT dp [ N ] [ maxE ] = ans NEW_LINE return dp [ N ] [ maxE ] NEW_LINE DEDENT
def maxSumArrangement ( A , R , N , M ) : NEW_LINE INDENT count = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT l = R [ i ] [ 0 ] NEW_LINE r = R [ i ] [ 1 ] + 1 NEW_LINE l = l - 1 NEW_LINE r = r - 1 NEW_LINE count [ l ] = count [ l ] + 1 NEW_LINE if ( r < N ) : NEW_LINE INDENT count [ r ] = count [ r ] - 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT count [ i ] = count [ i ] + count [ i - 1 ] NEW_LINE DEDENT ans = 0 NEW_LINE count . sort ( ) NEW_LINE A . sort ( ) NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans = ans + A [ i ] * count [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def make_permutation ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += abs ( i + 1 - arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxSum ( V , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT aux = [ ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT aux . append ( [ V [ i + 1 ] [ j ] , j ] ) NEW_LINE DEDENT aux = sorted ( aux ) NEW_LINE aux = aux [ : : - 1 ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT for k in range ( m ) : NEW_LINE INDENT if ( aux [ k ] [ 1 ] - j == 0 or abs ( aux [ k ] [ 1 ] - j ) > 1 ) : NEW_LINE INDENT V [ i ] [ j ] += aux [ k ] [ 0 ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT ans = max ( ans , V [ 0 ] [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minimumProduct ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE product = 1 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT product *= ( arr [ i ] + arr [ i + 1 ] ) NEW_LINE DEDENT return product NEW_LINE DEDENT
def isVowel ( ch ) : NEW_LINE INDENT ch = ch . upper ( ) NEW_LINE return ( ch == 'A' or ch == 'E' or ch == 'I' or ch == 'O' or ch == 'U' ) NEW_LINE DEDENT
def sortArr ( arr , n ) : NEW_LINE INDENT vp = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT vp . append ( ( countVowels ( arr [ i ] ) , arr [ i ] ) ) NEW_LINE DEDENT vp . sort ( ) NEW_LINE for i in range ( len ( vp ) ) : NEW_LINE INDENT print ( vp [ i ] [ 1 ] , end = " " ) NEW_LINE DEDENT DEDENT
def checkIsGP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . sort ( ) NEW_LINE r = arr [ 1 ] / arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] / arr [ i - 1 ] != r ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def checkIsHP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT rec = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT rec . append ( ( 1 / arr [ i ] ) ) NEW_LINE DEDENT if ( checkIsAP ( rec , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def reversDigits ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT
def sortArr ( arr , n ) : NEW_LINE INDENT vp = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT vp . append ( ( reversDigits ( arr [ i ] ) , arr [ i ] ) ) NEW_LINE DEDENT vp . sort ( ) NEW_LINE for i in range ( len ( vp ) ) : NEW_LINE INDENT print ( vp [ i ] [ 1 ] , end = " " ) NEW_LINE DEDENT DEDENT
def sortMat ( data , row , col ) : NEW_LINE INDENT size = row * col NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( 0 , size - 1 ) : NEW_LINE INDENT if ( data [ j // col ] [ j % col ] > data [ ( j + 1 ) // col ] [ ( j + 1 ) % col ] ) : NEW_LINE INDENT temp = data [ j // col ] [ j % col ] NEW_LINE data [ j // col ] [ j % col ] = data [ ( j + 1 ) // col ] [ ( j + 1 ) % col ] NEW_LINE data [ ( j + 1 ) // col ] [ ( j + 1 ) % col ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT
def minimiseMedian ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = abs ( arr [ n // 2 ] - arr [ ( n // 2 ) - 1 ] ) NEW_LINE return ans NEW_LINE DEDENT
def sortByFreq ( arr , n ) : NEW_LINE INDENT maxE = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxE = max ( maxE , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 ] * ( maxE + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( maxE + 1 ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT value = 100000 - i NEW_LINE arr [ cnt ] = 100000 * freq [ i ] + value NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def printSortedArray ( arr , cnt ) : NEW_LINE INDENT for i in range ( cnt ) : NEW_LINE INDENT frequency = arr [ i ] / 100000 NEW_LINE value = 100000 - ( arr [ i ] % 100000 ) NEW_LINE for j in range ( int ( frequency ) ) : NEW_LINE INDENT print ( value , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def canBeEqual ( a , b , c , k ) : NEW_LINE INDENT arr = [ 0 ] * 3 NEW_LINE arr [ 0 ] = a NEW_LINE arr [ 1 ] = b NEW_LINE arr [ 2 ] = c NEW_LINE arr . sort ( ) NEW_LINE diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] NEW_LINE k = k - diff NEW_LINE if ( k < 0 or k % 3 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def search ( arr , l , h , key ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) // 2 NEW_LINE if ( arr [ mid ] == key ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( ( arr [ l ] == arr [ mid ] ) and ( arr [ h ] == arr [ mid ] ) ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE return search ( arr , l , h , key ) NEW_LINE DEDENT if ( arr [ l ] <= arr [ mid ] ) : NEW_LINE INDENT if ( key >= arr [ l ] and key <= arr [ mid ] ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if ( key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT
def orgazineInOrder ( vec , op , n ) : NEW_LINE INDENT result = [ 0 ] * n NEW_LINE vec . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE k = 0 NEW_LINE while ( i <= j and k <= n - 2 ) : NEW_LINE INDENT if ( op [ k ] == '<' ) : NEW_LINE INDENT result [ k ] = vec [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result [ k ] = vec [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT result [ n - 1 ] = vec [ i ] NEW_LINE return result NEW_LINE DEDENT
def minimumCost ( price , n ) : NEW_LINE INDENT price = sorted ( price ) NEW_LINE totalCost = 0 NEW_LINE for i in range ( n - 1 , 1 , - 2 ) : NEW_LINE INDENT if ( i == 2 ) : NEW_LINE INDENT totalCost += price [ 2 ] + price [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT price_first = price [ i ] + price [ 0 ] + 2 * price [ 1 ] NEW_LINE price_second = price [ i ] + price [ i - 1 ] + 2 * price [ 0 ] NEW_LINE totalCost += min ( price_first , price_second ) NEW_LINE DEDENT DEDENT if ( n == 1 ) : NEW_LINE INDENT totalCost += price [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT totalCost += price [ 1 ] NEW_LINE DEDENT return totalCost NEW_LINE DEDENT
def checkRectangles ( arr , n ) : NEW_LINE INDENT ans = True NEW_LINE arr . sort ( ) NEW_LINE area = arr [ 0 ] * arr [ 4 * n - 1 ] NEW_LINE for i in range ( 0 , 2 * n , 2 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] or arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] or arr [ i ] * arr [ 4 * n - i - 1 ] != area ) : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( ans ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findMin ( arr , n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , j - i ) NEW_LINE i = j - 1 NEW_LINE DEDENT return n - ans NEW_LINE DEDENT
def countSubSeq ( a , n , k ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE arr = [ ] NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT count = 1 NEW_LINE x = a [ i ] NEW_LINE i += 1 NEW_LINE while ( i < n and a [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT arr . append ( count ) NEW_LINE DEDENT m = len ( arr ) NEW_LINE n = min ( m , k ) NEW_LINE count = 1 NEW_LINE dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT j = m NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( j > m - i ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j + 1 ] + arr [ j ] * dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT count = count + dp [ i ] [ 0 ] NEW_LINE DEDENT return count NEW_LINE DEDENT
def maxMod ( arr , n ) : NEW_LINE INDENT maxVal = max ( arr ) NEW_LINE secondMax = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < maxVal and arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT DEDENT return secondMax NEW_LINE DEDENT
def partOdd ( s ) : NEW_LINE INDENT odd = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i % 2 != 0 : NEW_LINE INDENT odd . append ( s [ i ] ) NEW_LINE DEDENT DEDENT return odd NEW_LINE DEDENT
def partEven ( s ) : NEW_LINE INDENT even = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT even . append ( s [ i ] ) NEW_LINE DEDENT DEDENT return even NEW_LINE DEDENT
def sortStack ( input1 , k ) : NEW_LINE INDENT tmpStack = [ ] NEW_LINE while ( len ( input1 ) != 0 ) : NEW_LINE INDENT tmp = input1 [ - 1 ] NEW_LINE input1 . pop ( ) NEW_LINE while ( len ( tmpStack ) != 0 ) : NEW_LINE INDENT tmpStackMod = tmpStack [ - 1 ] % k NEW_LINE tmpMod = tmp % k NEW_LINE if ( ( tmpStackMod > tmpMod ) or ( tmpStackMod == tmpMod and tmpStack [ - 1 ] > tmp ) ) : NEW_LINE INDENT input1 . append ( tmpStack [ - 1 ] ) NEW_LINE tmpStack . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT tmpStack . append ( tmp ) NEW_LINE DEDENT while ( len ( tmpStack ) != 0 ) : NEW_LINE INDENT input1 . append ( tmpStack [ - 1 ] ) NEW_LINE tmpStack . pop ( ) NEW_LINE DEDENT while ( len ( input1 ) != 0 ) : NEW_LINE INDENT print ( input1 [ - 1 ] , end = " " ) NEW_LINE input1 . pop ( ) NEW_LINE DEDENT DEDENT
def maxLen ( arr , n ) : NEW_LINE INDENT c_sum = 0 NEW_LINE arr . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT c_sum += arr [ i ] NEW_LINE if ( c_sum < 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def isPossible ( rangee , N ) : NEW_LINE INDENT test = [ [ 0 for x in range ( 3 ) ] for x in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT test [ i ] [ 0 ] = rangee [ i ] [ 0 ] NEW_LINE test [ i ] [ 1 ] = rangee [ i ] [ 1 ] NEW_LINE test [ i ] [ 2 ] = rangee [ i ] [ 2 ] NEW_LINE DEDENT test . sort ( key = lambda x : x [ 2 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT count = [ 0 ] * MAX NEW_LINE current_velocity = test [ i ] [ 2 ] NEW_LINE j = i NEW_LINE while ( j < N and test [ j ] [ 2 ] == current_velocity ) : NEW_LINE INDENT for k in range ( test [ j ] [ 0 ] , test [ j ] [ 1 ] + 1 ) : NEW_LINE INDENT count [ k ] += 1 NEW_LINE if ( count [ k ] >= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT i = j - 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def maxSum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def minSteps ( arr , n ) : NEW_LINE INDENT maxVal = max ( arr ) NEW_LINE return maxVal NEW_LINE DEDENT
def isPossible ( A , B , n , m , x , y ) : NEW_LINE INDENT if ( x > n or y > m ) : NEW_LINE INDENT return False NEW_LINE DEDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE if ( A [ x - 1 ] < B [ m - y ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def sortWithRemainder ( arr , n , k ) : NEW_LINE INDENT v = [ [ ] for i in range ( k ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ arr [ i ] % k ] . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT v [ i ] . sort ( ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT for it in v [ i ] : NEW_LINE INDENT arr [ j ] = it NEW_LINE j += 1 NEW_LINE DEDENT DEDENT printArr ( arr , n ) NEW_LINE DEDENT
def minOperations ( ar , k ) : NEW_LINE INDENT ar = sorted ( ar ) NEW_LINE opsNeeded = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT opsNeeded += ar [ k - 1 ] - ar [ i ] NEW_LINE DEDENT ans = opsNeeded NEW_LINE for i in range ( k , len ( ar ) ) : NEW_LINE INDENT opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) NEW_LINE opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) NEW_LINE ans = min ( ans , opsNeeded ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def getNumber ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE i = 0 NEW_LINE odd = 1 NEW_LINE while ( odd <= n ) : NEW_LINE INDENT arr [ i ] = odd NEW_LINE i += 1 NEW_LINE odd += 2 NEW_LINE DEDENT even = 2 NEW_LINE while ( even <= n ) : NEW_LINE INDENT arr [ i ] = even NEW_LINE i += 1 NEW_LINE even += 2 NEW_LINE DEDENT return arr [ k - 1 ] NEW_LINE DEDENT
def getNumber ( n , k ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT pos = n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT pos = ( n // 2 ) + 1 NEW_LINE DEDENT if ( k <= pos ) : NEW_LINE INDENT return ( k * 2 - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( k - pos ) * 2 ) NEW_LINE DEDENT DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def CountPermutation ( a , n ) : NEW_LINE INDENT ways = 1 NEW_LINE a . sort ( ) NEW_LINE size = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] ) : NEW_LINE INDENT size += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ways *= fact [ size ] NEW_LINE size = 1 NEW_LINE DEDENT DEDENT ways *= fact [ size ] NEW_LINE return ways NEW_LINE DEDENT
def dfs ( n , left , ct ) : NEW_LINE INDENT if ( ct >= 15 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( left == 0 ) : NEW_LINE INDENT ans [ n ] = 1 NEW_LINE DEDENT for i in range ( min ( left , 9 ) + 1 ) : NEW_LINE INDENT dfs ( n * 10 + i , left - i , ct + 1 ) NEW_LINE DEDENT DEDENT
def getKthNum ( m , k ) : NEW_LINE INDENT dfs ( 0 , m , 0 ) NEW_LINE c = 0 NEW_LINE for it in sorted ( ans . keys ( ) ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c == k ) : NEW_LINE INDENT return it NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE freq = [ 0 for i in range ( MAX ) ] NEW_LINE p = 0 NEW_LINE freq [ p ] = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE freq [ p ] += 1 NEW_LINE DEDENT DEDENT freq . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( k , p + 1 , 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minCost ( cost ) : NEW_LINE INDENT dist = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE DEDENT dist [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : NEW_LINE INDENT dist [ j ] = dist [ i ] + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dist [ N - 1 ] NEW_LINE DEDENT
def Segment ( x , l , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 2 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( x [ i ] - l [ i ] > x [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif ( x [ i ] + l [ i ] < x [ i + 1 ] ) : NEW_LINE INDENT x [ i ] = x [ i ] + l [ i ] NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def Next_greater ( a , n , x ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE low , high , ans = 0 , n - 1 , x + 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( a [ mid ] <= ans ) : NEW_LINE INDENT if ( a [ mid ] == ans ) : NEW_LINE INDENT ans += 1 NEW_LINE high = n - 1 NEW_LINE DEDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def Combination ( A , K ) : NEW_LINE INDENT A . sort ( reverse = False ) NEW_LINE DEDENT
def xorOnSortedArray ( arr , n , k , x ) : NEW_LINE INDENT arr1 = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE arr2 = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE xor_val = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr1 [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT xor_val [ i ] = i ^ x NEW_LINE DEDENT while ( k > 0 ) : NEW_LINE INDENT k -= 1 NEW_LINE count = 0 NEW_LINE for i in range ( MAX + 1 ) : NEW_LINE INDENT store = arr1 [ i ] NEW_LINE if ( arr1 [ i ] > 0 ) : NEW_LINE INDENT if ( count % 2 == 0 ) : NEW_LINE INDENT div = arr1 [ i ] // 2 + 1 NEW_LINE arr1 [ i ] = arr1 [ i ] - div NEW_LINE arr2 [ xor_val [ i ] ] += div NEW_LINE DEDENT elif ( count % 2 != 0 ) : NEW_LINE INDENT div = arr1 [ i ] // 2 NEW_LINE arr1 [ i ] = arr1 [ i ] - div NEW_LINE arr2 [ xor_val [ i ] ] += div NEW_LINE DEDENT DEDENT count = count + store NEW_LINE DEDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT arr1 [ i ] = arr1 [ i ] + arr2 [ i ] NEW_LINE arr2 [ i ] = 0 NEW_LINE DEDENT DEDENT mn = sys . maxsize NEW_LINE mx = - sys . maxsize - 1 NEW_LINE for i in range ( MAX + 1 ) : NEW_LINE INDENT if ( arr1 [ i ] > 0 ) : NEW_LINE INDENT if ( mn > i ) : NEW_LINE INDENT mn = i NEW_LINE DEDENT if ( mx < i ) : NEW_LINE INDENT mx = i NEW_LINE DEDENT DEDENT DEDENT print ( mn , mx ) NEW_LINE DEDENT
def pairs_count ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE i , j = 0 , n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] > sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] NEW_LINE xx = i NEW_LINE while ( i < j and arr [ i ] == x ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT y = arr [ j ] NEW_LINE yy = j NEW_LINE while ( j >= i and arr [ j ] == y ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT temp = i - xx + yy - j - 1 NEW_LINE ans += ( temp * ( temp + 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - xx ) * ( yy - j ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def findSubarray ( a , k , n ) : NEW_LINE INDENT vec = [ ] NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT temp = [ ] NEW_LINE for j in range ( i , i + k ) : NEW_LINE INDENT temp . append ( a [ j ] ) NEW_LINE DEDENT vec . append ( temp ) NEW_LINE DEDENT vec = sorted ( vec ) NEW_LINE return vec [ len ( vec ) - 1 ] NEW_LINE DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT maxratio = - sys . maxsize - 1 NEW_LINE maxindex = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( val [ i ] / wt [ i ] ) > maxratio ) : NEW_LINE INDENT maxratio = ( val [ i ] / wt [ i ] ) NEW_LINE maxindex = i NEW_LINE DEDENT DEDENT return ( W * maxratio ) NEW_LINE DEDENT
def sortArray ( a , n ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE DEDENT DEDENT ans = sorted ( ans ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT a [ i ] = ans [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def solution ( arr , x ) : NEW_LINE INDENT closestSum = sys . maxsize NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( arr ) ) : NEW_LINE INDENT for k in range ( j + 1 , len ( arr ) ) : NEW_LINE INDENT if ( abs ( x - closestSum ) > abs ( x - ( arr [ i ] + arr [ j ] + arr [ k ] ) ) ) : NEW_LINE INDENT closestSum = ( arr [ i ] + arr [ j ] + arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return closestSum NEW_LINE DEDENT
def solution ( arr , x ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE closestSum = sys . maxsize NEW_LINE for i in range ( len ( arr ) - 2 ) : NEW_LINE INDENT ptr1 = i + 1 NEW_LINE ptr2 = len ( arr ) - 1 NEW_LINE while ( ptr1 < ptr2 ) : NEW_LINE INDENT sum = arr [ i ] + arr [ ptr1 ] + arr [ ptr2 ] NEW_LINE if ( abs ( x - sum ) < abs ( x - closestSum ) ) : NEW_LINE INDENT closestSum = sum NEW_LINE DEDENT if ( sum > x ) : NEW_LINE INDENT ptr2 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ptr1 += 1 NEW_LINE DEDENT DEDENT DEDENT return closestSum NEW_LINE DEDENT
def makearray ( v , V ) : NEW_LINE INDENT for i in range ( len ( v ) ) : NEW_LINE INDENT for j in range ( len ( v [ i ] ) - 1 ) : NEW_LINE INDENT addEdge ( v [ i ] [ j ] , v [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT indeg = [ 0 for i in range ( V ) ] NEW_LINE getindeg ( V , indeg ) NEW_LINE res = topo ( V , indeg ) NEW_LINE return res NEW_LINE DEDENT
def existsTriplet ( a , b , c , x , l1 , l2 , l3 ) : NEW_LINE INDENT if ( l2 <= l1 and l2 <= l3 ) : NEW_LINE INDENT l1 , l2 = l2 , l1 NEW_LINE a , b = b , a NEW_LINE DEDENT elif ( l3 <= l1 and l3 <= l2 ) : NEW_LINE INDENT l1 , l3 = l3 , l1 NEW_LINE a , c = c , a NEW_LINE DEDENT for i in range ( l1 ) : NEW_LINE INDENT j = 0 NEW_LINE k = l3 - 1 NEW_LINE while ( j < l2 and k >= 0 ) : NEW_LINE INDENT if ( a [ i ] + b [ j ] + c [ k ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( a [ i ] + b [ j ] + c [ k ] < x ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def compressArr ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE arr . sort ( ) NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i NEW_LINE while ( ( j + 1 < n ) and ( arr [ j + 1 ] == arr [ j ] + 1 ) ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] , "-" , arr [ j ] , end = " " ) NEW_LINE i = j + 1 NEW_LINE DEDENT DEDENT DEDENT
def partition ( arr , low , high , mod ) : NEW_LINE INDENT pivot = ord ( arr [ high ] ) NEW_LINE i = ( low - 1 ) NEW_LINE piv = pivot % mod NEW_LINE for j in range ( low , high ) : NEW_LINE INDENT a = ord ( arr [ j ] ) % mod NEW_LINE if ( a <= piv ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ high ] = arr [ high ] , arr [ i + 1 ] NEW_LINE return ( i + 1 ) NEW_LINE DEDENT
def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def check ( arr , n ) : NEW_LINE INDENT modify = 0 NEW_LINE if ( arr [ n - 1 ] >= arr [ n - 2 ] ) : NEW_LINE INDENT arr [ n - 1 ] = arr [ n - 2 ] - 1 NEW_LINE modify += 1 NEW_LINE DEDENT if ( arr [ 0 ] <= arr [ 1 ] ) : NEW_LINE INDENT arr [ 0 ] = arr [ 1 ] + 1 NEW_LINE modify += 1 NEW_LINE DEDENT for i in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] <= arr [ i ] and arr [ i + 1 ] <= arr [ i ] ) or ( arr [ i - 1 ] >= arr [ i ] and arr [ i + 1 ] >= arr [ i ] ) : NEW_LINE INDENT arr [ i ] = ( arr [ i - 1 ] + arr [ i + 1 ] ) // 2 NEW_LINE modify += 1 NEW_LINE if ( arr [ i ] == arr [ i - 1 ] or arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT if ( modify > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def inorder ( root ) : NEW_LINE INDENT if ( root != None ) : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . data , end = " " ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT
def merge ( root1 , root2 ) : NEW_LINE INDENT if ( not root1 and not root2 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( not root1 ) : NEW_LINE INDENT inorder ( root2 ) NEW_LINE return NEW_LINE DEDENT if ( not root2 ) : NEW_LINE INDENT inorder ( root1 ) NEW_LINE return NEW_LINE DEDENT temp1 = root1 NEW_LINE prev1 = None NEW_LINE while ( temp1 . left ) : NEW_LINE INDENT prev1 = temp1 NEW_LINE temp1 = temp1 . left NEW_LINE DEDENT temp2 = root2 NEW_LINE prev2 = None NEW_LINE while ( temp2 . left ) : NEW_LINE INDENT prev2 = temp2 NEW_LINE temp2 = temp2 . left NEW_LINE DEDENT if ( temp1 . data <= temp2 . data ) : NEW_LINE INDENT print ( temp1 . data , end = " " ) NEW_LINE if ( prev1 == None ) : NEW_LINE INDENT merge ( root1 . right , root2 ) NEW_LINE DEDENT else : NEW_LINE INDENT prev1 . left = temp1 . right NEW_LINE merge ( root1 , root2 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( temp2 . data , end = " " ) NEW_LINE if ( prev2 == None ) : NEW_LINE INDENT merge ( root1 , root2 . right ) NEW_LINE DEDENT else : NEW_LINE INDENT prev2 . left = temp2 . right NEW_LINE merge ( root1 , root2 ) NEW_LINE DEDENT DEDENT DEDENT
def IsSorted ( A , B , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT x = max ( A [ i ] , B [ i ] ) NEW_LINE y = min ( A [ i ] , B [ i ] ) NEW_LINE A [ i ] = x NEW_LINE B [ i ] = y NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( A [ i ] <= A [ i - 1 ] or B [ i ] <= B [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def removeElements ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * n NEW_LINE l = 1 NEW_LINE brr [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( brr [ l - 1 ] <= arr [ i ] ) : NEW_LINE INDENT brr [ l ] = arr [ i ] NEW_LINE l += 1 NEW_LINE DEDENT DEDENT for i in range ( l ) : NEW_LINE INDENT print ( brr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def maxWater ( height , n ) : NEW_LINE INDENT maximum = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT current = min ( height [ i ] , height [ j ] ) * ( j - i - 1 ) NEW_LINE maximum = max ( maximum , current ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT
def maxSelectionCount ( a , n ) : NEW_LINE INDENT res = 0 NEW_LINE a . sort ( ) NEW_LINE select = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= select ) : NEW_LINE INDENT  DEDENT DEDENT
def findCombinations ( n ) : NEW_LINE INDENT a = [ 0 for i in range ( n + 1 ) ] NEW_LINE findCombinationsUtil ( a , 0 , n , n ) NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT modify = 0 NEW_LINE if ( arr [ 0 ] > arr [ 1 ] ) : NEW_LINE INDENT arr [ 0 ] = arr [ 1 ] // 2 NEW_LINE modify += 1 NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( ( arr [ i - 1 ] < arr [ i ] and arr [ i + 1 ] < arr [ i ] ) or ( arr [ i - 1 ] > arr [ i ] and arr [ i + 1 ] > arr [ i ] ) ) : NEW_LINE INDENT arr [ i ] = ( arr [ i - 1 ] + arr [ i + 1 ] ) // 2 NEW_LINE if ( arr [ i ] == arr [ i - 1 ] or arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT modify += 1 NEW_LINE DEDENT DEDENT if ( arr [ n - 1 ] < arr [ n - 2 ] ) : NEW_LINE INDENT modify += 1 NEW_LINE DEDENT if ( modify > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def checkDivisors ( a , n ) : NEW_LINE INDENT X = max ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , int ( sqrt ( X ) ) + 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( X // i != i ) : NEW_LINE INDENT b . append ( X // i ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( b ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != a [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findX ( list , int ) : NEW_LINE INDENT list . sort ( ) NEW_LINE x = list [ 0 ] * list [ int - 1 ] NEW_LINE vec = [ ] NEW_LINE i = 2 NEW_LINE while ( i * i <= x ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT vec . append ( i ) NEW_LINE if ( ( x // i ) != i ) : NEW_LINE INDENT vec . append ( x // i ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT vec . sort ( ) NEW_LINE if ( len ( vec ) != int ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT j = 0 NEW_LINE for it in range ( int ) : NEW_LINE INDENT if ( a [ j ] != vec [ it ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return x NEW_LINE DEDENT
def seive ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT if not prime [ i ] : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT prime [ j ] = True NEW_LINE DEDENT DEDENT DEDENT prime [ 1 ] = True NEW_LINE DEDENT
def maxSizeArr ( arr , n , k ) : NEW_LINE INDENT v , diff = [ ] , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( 1 , len ( v ) ) : NEW_LINE INDENT diff . append ( v [ i ] - v [ i - 1 ] - 1 ) NEW_LINE DEDENT diff . sort ( ) NEW_LINE for i in range ( 1 , len ( diff ) ) : NEW_LINE INDENT diff [ i ] += diff [ i - 1 ] NEW_LINE DEDENT if k > n or ( k == 0 and len ( v ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif len ( v ) <= k : NEW_LINE INDENT return ( n - k ) NEW_LINE DEDENT elif len ( v ) > k : NEW_LINE INDENT tt = len ( v ) - k NEW_LINE s = 0 NEW_LINE s += diff [ tt - 1 ] NEW_LINE res = n - ( len ( v ) + s ) NEW_LINE return res NEW_LINE DEDENT DEDENT
def pendulumArrangement ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE pos = n - 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT odd = n - 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = n - 2 NEW_LINE DEDENT while ( odd > 0 ) : NEW_LINE INDENT temp = arr [ odd ] NEW_LINE in1 = odd NEW_LINE while ( in1 != pos ) : NEW_LINE INDENT arr [ in1 ] = arr [ in1 + 1 ] NEW_LINE in1 += 1 NEW_LINE DEDENT arr [ in1 ] = temp NEW_LINE odd = odd - 2 NEW_LINE pos = pos - 1 NEW_LINE DEDENT start = 0 NEW_LINE end = int ( ( n - 1 ) / 2 ) NEW_LINE while ( start < end ) : NEW_LINE INDENT temp = arr [ start ] NEW_LINE arr [ start ] = arr [ end ] NEW_LINE arr [ end ] = temp NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return int ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) NEW_LINE DEDENT
def CountSubset ( arr , n ) : NEW_LINE INDENT ans = powmod ( 2 , n - 1 ) NEW_LINE arr . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT r = n - 1 - j NEW_LINE l = i NEW_LINE ans = ( ans + nCr ( l + r , l ) ) % mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def Preprocess ( ) : NEW_LINE INDENT arr [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT arr [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i ) : NEW_LINE INDENT arr [ i ] [ j ] = ( arr [ i - 1 ] [ j - 1 ] + arr [ i - 1 ] [ j ] ) % mod NEW_LINE DEDENT arr [ i ] [ i ] = 1 NEW_LINE DEDENT DEDENT
def powmod ( a , n ) : NEW_LINE INDENT if not n : NEW_LINE INDENT return 1 NEW_LINE DEDENT pt = powmod ( a , n // 2 ) NEW_LINE pt = ( pt * pt ) % mod NEW_LINE if n % 2 : NEW_LINE INDENT return ( pt * a ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return pt NEW_LINE DEDENT DEDENT
def CountSubset ( val , n ) : NEW_LINE INDENT ans = powmod ( 2 , n - 1 ) NEW_LINE val . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while j < n and val [ j ] == val [ i ] : NEW_LINE INDENT r = n - 1 - j NEW_LINE l = i NEW_LINE ans = ( ans + arr [ l + r ] [ l ] ) % mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def reArrange ( words , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ words [ i ] ] = i + 1 NEW_LINE DEDENT words . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( mp [ words [ i ] ] , end = " " ) NEW_LINE DEDENT DEDENT
def findNumber ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE Max = arr [ n - 1 ] NEW_LINE table = [ 10 ** 9 for i in range ( ( 2 * Max ) + 1 ) ] NEW_LINE table [ 0 ] = 0 NEW_LINE ans = - 1 NEW_LINE for i in range ( 1 , 2 * Max + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] <= i ) : NEW_LINE INDENT res = table [ i - arr [ j ] ] NEW_LINE if ( res != 10 ** 9 and res + 1 < table [ i ] ) : NEW_LINE INDENT table [ i ] = res + 1 NEW_LINE DEDENT DEDENT DEDENT if ( i > arr [ n - 1 ] and table [ i ] == 10 ** 9 ) : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % MOD NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % MOD NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % MOD NEW_LINE DEDENT return res % MOD NEW_LINE DEDENT
def combi ( n , k ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] % MOD + C [ i - 1 ] [ j ] % MOD ) % MOD NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findSumofEle ( arr1 , m , arr2 , n ) : NEW_LINE INDENT hash = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr2 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , MAX , 1 ) : NEW_LINE INDENT hash [ i ] = hash [ i ] + hash [ i - 1 ] NEW_LINE DEDENT maximumFreq = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT maximumFreq = max ( maximumFreq , hash [ arr1 [ i ] ] ) NEW_LINE DEDENT sumOfElements = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( maximumFreq == hash [ arr1 [ i ] ] ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT DEDENT return sumOfElements NEW_LINE DEDENT
def MinimizeleftOverSum ( a , n ) : NEW_LINE INDENT v1 , v2 = [ ] , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 ) : NEW_LINE INDENT v1 . append ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( a [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( v1 ) > len ( v2 ) ) : NEW_LINE INDENT v1 . sort ( ) NEW_LINE v2 . sort ( ) NEW_LINE x = len ( v1 ) - len ( v2 ) - 1 NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE while ( i < x ) : NEW_LINE INDENT sum += v1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT elif ( len ( v2 ) > len ( v1 ) ) : NEW_LINE INDENT v1 . sort ( ) NEW_LINE v2 . sort ( ) NEW_LINE x = len ( v2 ) - len ( v1 ) - 1 NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE while ( i < x ) : NEW_LINE INDENT sum += v2 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def printList ( head ) : NEW_LINE INDENT while head : NEW_LINE INDENT print ( head . data , end = " " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ) NEW_LINE DEDENT DEDENT
def compare ( num1 , num2 ) : NEW_LINE INDENT A = str ( num1 ) NEW_LINE B = str ( num2 ) NEW_LINE return int ( A + B ) <= int ( B + A ) NEW_LINE DEDENT
def printSmallest ( N , arr ) : NEW_LINE INDENT sort ( arr ) NEW_LINE printArr ( arr , N ) NEW_LINE DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def isUgly ( n ) : NEW_LINE INDENT while n % 2 == 0 : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT while n % 3 == 0 : NEW_LINE INDENT n = n // 3 NEW_LINE DEDENT while n % 5 == 0 : NEW_LINE INDENT n = n // 5 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def sortUglyNumbers ( arr , n ) : NEW_LINE INDENT list = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if isUgly ( arr [ i ] ) : NEW_LINE INDENT list . append ( arr [ i ] ) NEW_LINE arr [ i ] = - 1 NEW_LINE DEDENT DEDENT list . sort ( ) NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] == - 1 : NEW_LINE INDENT print ( list [ j ] , end = " " ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def getMaxMedian ( arr , n , k ) : NEW_LINE INDENT size = n + k NEW_LINE arr . sort ( reverse = False ) NEW_LINE if ( size % 2 == 0 ) : NEW_LINE INDENT median = ( arr [ int ( size / 2 ) - 1 ] + arr [ int ( size / 2 ) ] ) / 2 NEW_LINE return median NEW_LINE DEDENT median = arr [ int ( size / 2 ) ] NEW_LINE return median NEW_LINE DEDENT
def sortArr ( arr , n , k ) : NEW_LINE INDENT prev = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT if ( prev != - 1 ) : NEW_LINE INDENT temp = arr [ prev + 1 : i ] NEW_LINE temp . sort ( ) NEW_LINE arr = arr [ : prev + 1 ] + temp + arr [ i : ] NEW_LINE DEDENT prev = i NEW_LINE DEDENT DEDENT printArr ( arr , n ) NEW_LINE DEDENT
def findSquare ( n ) : NEW_LINE INDENT points = [ [ 1 , 2 ] , [ - 3 , 4 ] , [ 1 , 78 ] , [ - 3 , - 7 ] ] NEW_LINE a = [ None ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT x = points [ i ] [ 0 ] NEW_LINE y = points [ i ] [ 1 ] NEW_LINE a [ i ] = max ( abs ( x ) , abs ( y ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE index = n // 2 - 1 NEW_LINE print ( "Minimum M required is:" , a [ index ] ) NEW_LINE DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def removeMin ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minVal NEW_LINE DEDENT DEDENT
def removeFromMax ( arr , n ) : NEW_LINE INDENT maxVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i ] NEW_LINE DEDENT DEDENT
def modifyArray ( arr , n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT removeMin ( arr , n ) NEW_LINE DEDENT else : NEW_LINE INDENT removeFromMax ( arr , n ) NEW_LINE DEDENT printArray ( arr , n ) NEW_LINE DEDENT
def findKth ( arr , n , k ) : NEW_LINE INDENT missing = dict ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT missing [ arr [ i ] ] = 1 NEW_LINE DEDENT maxm = max ( arr ) NEW_LINE minm = min ( arr ) NEW_LINE for i in range ( minm + 1 , maxm ) : NEW_LINE INDENT if ( i not in missing . keys ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minOperation ( S , N , K ) : NEW_LINE INDENT if N % K : NEW_LINE INDENT print ( "Not Possible" ) NEW_LINE return NEW_LINE DEDENT count = [ 0 ] * 26 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT count [ ord ( S [ i ] ) - 97 ] += 1 NEW_LINE DEDENT E = N // K NEW_LINE greaterE = [ ] NEW_LINE lessE = [ ] NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT if count [ i ] < E : NEW_LINE INDENT lessE . append ( E - count [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT greaterE . append ( count [ i ] - E ) NEW_LINE DEDENT DEDENT greaterE . sort ( ) NEW_LINE lessE . sort ( ) NEW_LINE mi = float ( 'inf' ) NEW_LINE for i in range ( 0 , K + 1 ) : NEW_LINE INDENT set1 , set2 = i , K - i NEW_LINE if ( len ( greaterE ) >= set1 and len ( lessE ) >= set2 ) : NEW_LINE INDENT step1 , step2 = 0 , 0 NEW_LINE for j in range ( 0 , set1 ) : NEW_LINE INDENT step1 += greaterE [ j ] NEW_LINE DEDENT for j in range ( 0 , set2 ) : NEW_LINE INDENT step2 += lessE [ j ] NEW_LINE DEDENT mi = min ( mi , max ( step1 , step2 ) ) NEW_LINE DEDENT DEDENT print ( mi ) NEW_LINE DEDENT
def printPermutations ( n , a , k ) : NEW_LINE INDENT arr = [ [ 0 , 0 ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] [ 0 ] = a [ i ] NEW_LINE arr [ i ] [ 1 ] = i NEW_LINE DEDENT arr . sort ( reverse = False ) NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] == arr [ i - 1 ] [ 0 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count < k ) : NEW_LINE INDENT print ( "-1" , end = "" ) NEW_LINE return NEW_LINE DEDENT next_pos = 1 NEW_LINE for i in range ( k - 1 ) : NEW_LINE INDENT printIndices ( n , arr ) NEW_LINE for j in range ( next_pos , n ) : NEW_LINE INDENT if ( arr [ j ] [ 0 ] == arr [ j - 1 ] [ 0 ] ) : NEW_LINE INDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ j - 1 ] NEW_LINE arr [ j - 1 ] = temp NEW_LINE next_pos = j + 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT printIndices ( n , arr ) NEW_LINE DEDENT
def findAnswer ( n , arr ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE sum = 0 NEW_LINE for i in range ( int ( n / 2 ) ) : NEW_LINE INDENT sum += ( ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def merge ( l , r , output ) : NEW_LINE INDENT l_in = l * n NEW_LINE r_in = ( ( l + r ) // 2 + 1 ) * n NEW_LINE l_c = ( ( l + r ) // 2 - l + 1 ) * n NEW_LINE r_c = ( r - ( l + r ) // 2 ) * n NEW_LINE l_arr = [ 0 ] * l_c NEW_LINE r_arr = [ 0 ] * r_c NEW_LINE for i in range ( l_c ) : NEW_LINE INDENT l_arr [ i ] = output [ l_in + i ] NEW_LINE DEDENT for i in range ( r_c ) : NEW_LINE INDENT r_arr [ i ] = output [ r_in + i ] NEW_LINE DEDENT l_curr = 0 NEW_LINE r_curr = 0 NEW_LINE in1 = l_in NEW_LINE while ( l_curr + r_curr < l_c + r_c ) : NEW_LINE INDENT if ( r_curr == r_c or ( l_curr != l_c and l_arr [ l_curr ] < r_arr [ r_curr ] ) ) : NEW_LINE INDENT output [ in1 ] = l_arr [ l_curr ] NEW_LINE l_curr += 1 NEW_LINE in1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT output [ in1 ] = r_arr [ r_curr ] NEW_LINE r_curr += 1 NEW_LINE in1 += 1 NEW_LINE DEDENT DEDENT DEDENT
def divide ( l , r , output , arr ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT output [ l * n + i ] = arr [ l ] [ i ] NEW_LINE DEDENT return NEW_LINE DEDENT divide ( l , ( l + r ) // 2 , output , arr ) NEW_LINE divide ( ( l + r ) // 2 + 1 , r , output , arr ) NEW_LINE merge ( l , r , output ) NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE x = arr [ n // 2 ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += abs ( arr [ i ] - x ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def minOperations ( n , m , k , matrix ) : NEW_LINE INDENT arr = [ 0 ] * ( n * m ) NEW_LINE mod = matrix [ 0 ] [ 0 ] % k NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT arr [ i * m + j ] = matrix [ i ] [ j ] NEW_LINE if matrix [ i ] [ j ] % k != mod : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT arr . sort ( ) NEW_LINE median = arr [ ( n * m ) // 2 ] NEW_LINE minOperations = 0 NEW_LINE for i in range ( 0 , n * m ) : NEW_LINE INDENT minOperations += abs ( arr [ i ] - median ) // k NEW_LINE DEDENT if ( n * m ) % 2 == 0 : NEW_LINE INDENT median2 = arr [ ( ( n * m ) // 2 ) - 1 ] NEW_LINE minOperations2 = 0 NEW_LINE for i in range ( 0 , n * m ) : NEW_LINE INDENT minOperations2 += abs ( arr [ i ] - median2 ) // k NEW_LINE DEDENT minOperations = min ( minOperations , minOperations2 ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT
def minOperations ( n , m , k , matrix ) : NEW_LINE INDENT arr = [ ] NEW_LINE if ( matrix [ 0 ] [ 0 ] < 0 ) : NEW_LINE INDENT mod = k - ( abs ( matrix [ 0 ] [ 0 ] ) % k ) NEW_LINE DEDENT else : NEW_LINE INDENT mod = matrix [ 0 ] [ 0 ] % k NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT arr . append ( matrix [ i ] [ j ] ) NEW_LINE val = matrix [ i ] [ j ] NEW_LINE if ( val < 0 ) : NEW_LINE INDENT res = k - ( abs ( val ) % k ) NEW_LINE if ( res != mod ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT foo = matrix [ i ] [ j ] NEW_LINE if ( foo % k != mod ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT arr . sort ( ) NEW_LINE median = arr [ ( n * m ) // 2 ] NEW_LINE minOperations = 0 NEW_LINE for i in range ( n * m ) : NEW_LINE INDENT minOperations += abs ( arr [ i ] - median ) // k NEW_LINE DEDENT if ( ( n * m ) % 2 == 0 ) : NEW_LINE INDENT median2 = arr [ ( ( n * m ) // 2 ) - 1 ] NEW_LINE minOperations2 = 0 NEW_LINE for i in range ( n * m ) : NEW_LINE INDENT minOperations2 += abs ( arr [ i ] - median2 ) / k NEW_LINE DEDENT minOperations = min ( minOperations , minOperations2 ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT
def countDistinct ( arr , n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == j + 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countDistinct ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in s ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def printMaxMean ( arr , n ) : NEW_LINE INDENT newArr = [ 0 ] * n NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT newArr [ i ] = arr [ i + n ] NEW_LINE DEDENT printArray ( newArr , n ) NEW_LINE DEDENT
def Minimum_Cells ( v ) : NEW_LINE INDENT col = [ 0 ] * 3 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT column_number = v [ i ] [ 1 ] NEW_LINE col [ i ] = column_number NEW_LINE DEDENT col . sort ( ) NEW_LINE v . sort ( ) NEW_LINE MidRow = v [ 1 ] [ 0 ] NEW_LINE s = set ( ) NEW_LINE Maxcol = col [ 2 ] NEW_LINE MinCol = col [ 0 ] NEW_LINE for i in range ( MinCol , int ( Maxcol ) + 1 ) : NEW_LINE INDENT s . add ( ( MidRow , i ) ) NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT if ( v [ i ] [ 0 ] == MidRow ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( min ( v [ i ] [ 0 ] , MidRow ) , max ( v [ i ] [ 0 ] , MidRow ) + 1 ) : NEW_LINE INDENT s . add ( ( j , v [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT
def countPairs ( a , n ) : NEW_LINE INDENT mp = dict . fromkeys ( a , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT a . sort ( reverse = True ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mp [ a [ i ] ] < 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT cur = 1 NEW_LINE while ( cur <= a [ i ] ) : NEW_LINE INDENT cur = cur << 1 NEW_LINE DEDENT if ( cur - a [ i ] in mp . keys ( ) ) : NEW_LINE INDENT if ( cur - a [ i ] == a [ i ] and mp [ a [ i ] ] == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT count += 1 NEW_LINE mp [ cur - a [ i ] ] -= 1 NEW_LINE mp [ a [ i ] ] -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countSequences ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] + 1 != arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def average ( arr , n , k ) : NEW_LINE INDENT total = 0 NEW_LINE if ( 2 * k >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE start , end = k , n - k - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT total += arr [ i ] NEW_LINE DEDENT return ( total / ( n - 2 * k ) ) NEW_LINE DEDENT
def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ 0 for i in range ( r - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( reverse = False ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE arr = ( arr [ 0 : l ] + sorted ( arr [ l : r + 1 ] ) + arr [ r : N ] ) NEW_LINE for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def minMovesToSort ( arr , n ) : NEW_LINE INDENT moves = 0 NEW_LINE mn = arr [ n - 1 ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > mn ) : NEW_LINE INDENT moves += arr [ i ] - mn NEW_LINE DEDENT DEDENT return moves NEW_LINE DEDENT
def transpose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mat [ i ] [ j ] , mat [ j ] [ i ] = mat [ j ] [ i ] , mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
def sortMatRowAndColWise ( mat , n ) : NEW_LINE INDENT sortByRow ( mat , n , True ) NEW_LINE transpose ( mat , n ) NEW_LINE sortByRow ( mat , n , False ) NEW_LINE transpose ( mat , n ) NEW_LINE DEDENT
def minimumMoves ( a , n ) : NEW_LINE INDENT operations = 0 NEW_LINE a . sort ( reverse = False ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT operations = operations + abs ( a [ i ] - ( i + 1 ) ) NEW_LINE DEDENT return operations NEW_LINE DEDENT
def min_sum ( n , k , a ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE if ( a [ 0 ] < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT if ( a [ 0 ] == a [ n - 1 ] ) : NEW_LINE INDENT return ( n * a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT p = a [ i ] - a [ 0 ] NEW_LINE if ( p % k == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( f ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( a [ 0 ] % k ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def printCase ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def merge ( arr , start , mid , end ) : NEW_LINE INDENT start2 = mid + 1 NEW_LINE if ( arr [ mid ] <= arr [ start2 ] ) : NEW_LINE INDENT return NEW_LINE DEDENT while ( start <= mid and start2 <= end ) : NEW_LINE INDENT if ( arr [ start ] <= arr [ start2 ] ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT else : NEW_LINE INDENT value = arr [ start2 ] NEW_LINE index = start2 NEW_LINE while ( index != start ) : NEW_LINE INDENT arr [ index ] = arr [ index - 1 ] NEW_LINE index -= 1 NEW_LINE DEDENT arr [ start ] = value NEW_LINE start += 1 NEW_LINE mid += 1 NEW_LINE start2 += 1 NEW_LINE DEDENT DEDENT DEDENT
def mergeSort ( arr , l , r ) : NEW_LINE INDENT if ( l < r ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE mergeSort ( arr , l , m ) NEW_LINE mergeSort ( arr , m + 1 , r ) NEW_LINE merge ( arr , l , m , r ) NEW_LINE DEDENT DEDENT
def minCost ( A , n ) : NEW_LINE INDENT cost = 0 NEW_LINE A . sort ( ) NEW_LINE K = A [ int ( n / 2 ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cost = cost + abs ( A [ i ] - K ) NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT tempCost = 0 NEW_LINE K = A [ int ( n / 2 ) - 1 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tempCost = tempCost + abs ( A [ i ] - K ) NEW_LINE DEDENT cost = min ( cost , tempCost ) NEW_LINE DEDENT return cost NEW_LINE DEDENT
def check ( n , k , a , b ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE fl = False NEW_LINE ind = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT if ( fl == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT fl = True NEW_LINE ind = i NEW_LINE DEDENT DEDENT if ( ind == - 1 or abs ( a [ ind ] - b [ ind ] ) <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def items ( n , a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE z = a [ n - 1 ] NEW_LINE x = 1 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT s += a [ i ] NEW_LINE if ( s <= z ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def sortWithSetbits ( arr , n , k ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == k ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v2 . sort ( reverse = False ) NEW_LINE for i in range ( 0 , len ( v1 ) , 1 ) : NEW_LINE INDENT arr [ v1 [ i ] ] = v2 [ i ] NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def findOptimalSolution ( a , N ) : NEW_LINE INDENT a . sort ( ) NEW_LINE points = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT points += a [ i ] * i NEW_LINE DEDENT return points NEW_LINE DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE flag = 0 NEW_LINE k = 2 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( flag == 0 ) : NEW_LINE INDENT i = l NEW_LINE while i < l + k and i <= r : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE i += 1 NEW_LINE DEDENT flag = 1 NEW_LINE l = i NEW_LINE i = r NEW_LINE while i > r - k and i >= l : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE i -= 1 NEW_LINE DEDENT flag = 0 NEW_LINE r = i NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT
def sortMultiples ( arr , n , x ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v . sort ( reverse = False ) NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT arr [ i ] = v [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT
def kThLexString ( st , k , n ) : NEW_LINE INDENT z = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pp = "" NEW_LINE for j in range ( i , i + k ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT pp += s [ j ] NEW_LINE z . add ( pp ) NEW_LINE DEDENT DEDENT fin = list ( z ) NEW_LINE fin . sort ( ) NEW_LINE print ( fin [ k - 1 ] ) NEW_LINE DEDENT
def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def sortPrimes ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( 100005 ) NEW_LINE v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v . sort ( reverse = True ) NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT arr [ i ] = v [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT
def number_of_tower ( house , r , n ) : NEW_LINE INDENT house . sort ( ) NEW_LINE numOfTower = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT numOfTower += 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return numOfTower NEW_LINE DEDENT
def countPairs ( first , second , value ) : NEW_LINE INDENT count = 0 NEW_LINE while ( first != None and second != None and first != second and second . next != first ) : NEW_LINE INDENT if ( ( first . data * second . data ) == value ) : NEW_LINE INDENT count += 1 NEW_LINE first = first . next NEW_LINE second = second . prev NEW_LINE DEDENT elif ( ( first . data * second . data ) > value ) : NEW_LINE INDENT second = second . prev NEW_LINE DEDENT else : NEW_LINE INDENT first = first . next NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countTriplets ( head , x ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE last = head NEW_LINE while ( last . next != None ) : NEW_LINE INDENT last = last . next NEW_LINE DEDENT current = head NEW_LINE while current != None : NEW_LINE INDENT first = current . next NEW_LINE count += countPairs ( first , last , x // current . data ) NEW_LINE current = current . next NEW_LINE DEDENT return count NEW_LINE DEDENT
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ s [ i ] for i in range ( len ( s ) ) ] NEW_LINE c . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] < s [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def SieveOfEratosthenes ( n ) : NEW_LINE INDENT for i in range ( len ( prime ) ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def sortedArray ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( 100005 ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == 0 : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v . sort ( ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == True : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v [ j ] , end = " " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT
def findProduct ( arr , n ) : NEW_LINE INDENT sorted ( arr ) NEW_LINE prod = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] != arr [ i ] ) : NEW_LINE INDENT prod = prod * arr [ i ] NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT
def rotateRec ( n , L , B ) : NEW_LINE INDENT m = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max ( L [ i ] , B [ i ] ) <= m ) : NEW_LINE INDENT m = max ( L [ i ] , B [ i ] ) NEW_LINE DEDENT elif ( min ( L [ i ] , B [ i ] ) <= m ) : NEW_LINE INDENT m = min ( L [ i ] , B [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def minimumIncrease ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE arr . sort ( ) NEW_LINE if arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT
def sortList ( head ) : NEW_LINE INDENT startVal = 1 NEW_LINE while ( head != None ) : NEW_LINE INDENT head . data = startVal NEW_LINE startVal = startVal + 1 NEW_LINE head = head . next NEW_LINE DEDENT DEDENT
def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT
def push ( head_ref , new_data ) : NEW_LINE INDENT global start NEW_LINE new_node = Node ( 0 ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE start = head_ref NEW_LINE DEDENT
def minDistance ( n , k , point ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT point [ i ] . sort ( ) NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( point [ i ] [ ( ( n + 1 ) // 2 ) - 1 ] , end = " " ) NEW_LINE DEDENT DEDENT
def solve ( N , M , cp , sp ) : NEW_LINE INDENT profit = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT profit . append ( sp [ i ] - cp [ i ] ) NEW_LINE DEDENT profit . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if profit [ i ] > 0 : NEW_LINE INDENT sum += profit [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def printOrder ( arr , n , k ) : NEW_LINE INDENT len1 = k NEW_LINE len2 = n - k NEW_LINE arr1 = [ 0 ] * k NEW_LINE arr2 = [ 0 ] * ( n - k ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT arr1 [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT arr2 [ i - k ] = arr [ i ] NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE INDENT arr [ i ] = arr1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr2 [ len2 - 1 ] NEW_LINE len2 -= 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def findMaxNum ( arr , n ) : NEW_LINE INDENT hash = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( hash [ i ] ) : NEW_LINE INDENT print ( i , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def sortK ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE DEDENT
def minimumSets ( arr , n , key ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , j + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= key ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return i + 1 NEW_LINE DEDENT
def distribution ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return min ( count , n / 2 ) NEW_LINE DEDENT
def distribution ( arr , n ) : NEW_LINE INDENT resources = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT resources . add ( arr [ i ] ) NEW_LINE DEDENT return min ( len ( resources ) , n // 2 ) NEW_LINE DEDENT
def merge ( arr , beg , mid , end , maxele ) : NEW_LINE INDENT i = beg NEW_LINE j = mid + 1 NEW_LINE k = beg NEW_LINE while ( i <= mid and j <= end ) : NEW_LINE INDENT if ( arr [ i ] % maxele <= arr [ j ] % maxele ) : NEW_LINE INDENT arr [ k ] = arr [ k ] + ( arr [ i ] % maxele ) * maxele NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] = arr [ k ] + ( arr [ j ] % maxele ) * maxele NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i <= mid ) : NEW_LINE INDENT arr [ k ] = arr [ k ] + ( arr [ i ] % maxele ) * maxele NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT while ( j <= end ) : NEW_LINE INDENT arr [ k ] = arr [ k ] + ( arr [ j ] % maxele ) * maxele NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( beg , end + 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] // maxele NEW_LINE DEDENT DEDENT
def mergeSortRec ( arr , beg , end , maxele ) : NEW_LINE INDENT if ( beg < end ) : NEW_LINE INDENT mid = ( beg + end ) // 2 NEW_LINE mergeSortRec ( arr , beg , mid , maxele ) NEW_LINE mergeSortRec ( arr , mid + 1 , end , maxele ) NEW_LINE merge ( arr , beg , mid , end , maxele ) NEW_LINE DEDENT DEDENT
def mergeSort ( arr , n ) : NEW_LINE INDENT maxele = max ( arr ) + 1 NEW_LINE mergeSortRec ( arr , 0 , n - 1 , maxele ) NEW_LINE DEDENT
def printSorted ( s , l ) : NEW_LINE INDENT stack = [ ] NEW_LINE tempstack = [ ] NEW_LINE stack . append ( s [ 0 ] ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT a = ord ( s [ i ] ) NEW_LINE b = ord ( stack [ - 1 ] ) NEW_LINE if ( ( a - b ) >= 1 or ( a == b ) ) : NEW_LINE INDENT stack . append ( s [ i ] ) NEW_LINE DEDENT elif ( ( b - a ) >= 1 ) : NEW_LINE INDENT while ( ( b - a ) >= 1 ) : NEW_LINE INDENT tempstack . append ( stack . pop ( ) ) NEW_LINE if ( len ( stack ) > 0 ) : NEW_LINE INDENT b = ord ( stack [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT stack . append ( s [ i ] ) NEW_LINE while ( len ( tempstack ) > 0 ) : NEW_LINE INDENT stack . append ( tempstack . pop ( ) ) NEW_LINE DEDENT DEDENT DEDENT print ( '' . join ( stack ) ) NEW_LINE DEDENT
def countTriplets ( arr , n , a , b ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] + arr [ j ] + arr [ k ] >= a ) and ( arr [ i ] + arr [ j ] + arr [ k ] <= b ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countTriplets ( arr , n , a , b ) : NEW_LINE INDENT res = 0 NEW_LINE res = ( countTripletsLessThan ( arr , n , b ) - countTripletsLessThan ( arr , n , a - 1 ) ) NEW_LINE return res NEW_LINE DEDENT
def checkFittingArrays ( A , B , N ) : NEW_LINE INDENT A = sorted ( A ) NEW_LINE B = sorted ( B ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] > B [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def maximum_toys ( cost , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE cost . sort ( reverse = False ) NEW_LINE for i in range ( 0 , N , 1 ) : NEW_LINE INDENT if ( sum + cost [ i ] <= K ) : NEW_LINE INDENT sum = sum + cost [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findMinimumSwaps ( arr , n , k ) : NEW_LINE INDENT num_min = num_max = need_minimum = 0 NEW_LINE need_maximum = swaps = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < k ) : NEW_LINE INDENT num_min += 1 NEW_LINE DEDENT elif ( arr [ i ] > k ) : NEW_LINE INDENT num_max += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == k ) : NEW_LINE INDENT pos = i NEW_LINE break NEW_LINE DEDENT DEDENT left = 0 NEW_LINE right = n - 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE if ( arr [ mid ] == k ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( arr [ mid ] > k ) : NEW_LINE INDENT if ( pos > mid ) : NEW_LINE INDENT need_minimum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT num_min -= 1 NEW_LINE DEDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( pos < mid ) : NEW_LINE INDENT need_maximum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT num_max -= 1 NEW_LINE DEDENT right = mid - 1 NEW_LINE DEDENT DEDENT if ( need_minimum > need_maximum ) : NEW_LINE INDENT swaps = swaps + need_maximum NEW_LINE num_min = num_min - need_maximum NEW_LINE need_minimum = ( need_minimum - need_maximum ) NEW_LINE need_maximum = 0 NEW_LINE DEDENT else : NEW_LINE INDENT swaps = swaps + need_minimum NEW_LINE num_max = num_max - need_minimum NEW_LINE need_maximum = ( need_maximum - need_minimum ) NEW_LINE need_minimum = 0 NEW_LINE DEDENT if ( need_maximum > num_max or need_minimum > num_min ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( swaps + need_maximum + need_minimum ) NEW_LINE DEDENT DEDENT
def findOptimalPairs ( arr , N ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE i = 0 NEW_LINE j = N - 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT print ( "(" , arr [ i ] , "," , arr [ j ] , ")" , end = " " ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT
def sortStack ( Input ) : NEW_LINE INDENT tmpStack = [ ] NEW_LINE while len ( Input ) != 0 : NEW_LINE INDENT tmp = Input [ - 1 ] NEW_LINE Input . pop ( ) NEW_LINE while len ( tmpStack ) != 0 and tmpStack [ - 1 ] > tmp : NEW_LINE INDENT Input . append ( tmpStack [ - 1 ] ) NEW_LINE tmpStack . pop ( ) NEW_LINE DEDENT tmpStack . append ( tmp ) NEW_LINE DEDENT return tmpStack NEW_LINE DEDENT
def sortedMerge ( s1 , s2 ) : NEW_LINE INDENT res = [ ] NEW_LINE while len ( s1 ) != 0 : NEW_LINE INDENT res . append ( s1 [ - 1 ] ) NEW_LINE s1 . pop ( ) NEW_LINE DEDENT while len ( s2 ) != 0 : NEW_LINE INDENT res . append ( s2 [ - 1 ] ) NEW_LINE s2 . pop ( ) NEW_LINE DEDENT return sortStack ( res ) NEW_LINE DEDENT
def MaxTotalRectangleArea ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE len = 0 NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ) : NEW_LINE INDENT flag = True NEW_LINE len = a [ i + 1 ] NEW_LINE i = i + 1 NEW_LINE DEDENT elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == True ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE flag = False NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def isSortedDesc ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return True NEW_LINE DEDENT while ( head . next != None ) : NEW_LINE INDENT t = head NEW_LINE if ( t . data <= t . next . data ) : NEW_LINE INDENT return False NEW_LINE DEDENT head = head . next NEW_LINE DEDENT return True NEW_LINE DEDENT
def evenOddInsertionSort ( arr , n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT j = i - 2 NEW_LINE temp = arr [ i ] NEW_LINE if ( ( i + 1 ) & 1 == 1 ) : NEW_LINE INDENT while ( temp >= arr [ j ] and j >= 0 ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp <= arr [ j ] and j >= 0 ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT DEDENT DEDENT
def sort ( a , n ) : NEW_LINE INDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT for j in range ( n , n - i , - 1 ) : NEW_LINE INDENT if ( a [ j ] > a [ j - 1 ] ) : NEW_LINE INDENT a [ j ] , a [ j - 1 ] = a [ j - 1 ] , a [ j ] NEW_LINE DEDENT DEDENT DEDENT print1 ( a , n ) NEW_LINE DEDENT
def insertionSort ( V ) : NEW_LINE INDENT N = len ( V ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT j = i NEW_LINE DEDENT while ( j > 0 and V [ j ] < V [ j - 1 ] ) : NEW_LINE INDENT temp = V [ j ] NEW_LINE V [ j ] = V [ j - 1 ] NEW_LINE V [ j - 1 ] = temp NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT
def insertionSortRecursive ( V , N ) : NEW_LINE INDENT if ( N <= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT insertionSortRecursive ( V , N - 1 ) NEW_LINE j = N - 1 NEW_LINE while ( j > 0 and V [ j ] < V [ j - 1 ] ) : NEW_LINE INDENT temp = V [ j ] NEW_LINE V [ j ] = V [ j - 1 ] NEW_LINE V [ j - 1 ] = temp NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT
def sort012 ( arr , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT count0 = count0 + 1 NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count1 = count1 + 1 NEW_LINE DEDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT count2 = count2 + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , count0 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT for i in range ( count0 , ( count0 + count1 ) ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT for i in range ( ( count0 + count1 ) , n ) : NEW_LINE INDENT arr [ i ] = 2 NEW_LINE DEDENT return NEW_LINE DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = int ( halfSum / 2 ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if curr_sum > halfSum : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def distancesum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( arr [ i ] * i - sum ) NEW_LINE sum += arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def totaldistancesum ( x , y , n ) : NEW_LINE INDENT return distancesum ( x , n ) + distancesum ( y , n ) NEW_LINE DEDENT
def minimumBox ( arr , n ) : NEW_LINE INDENT q = collections . deque ( [ ] ) NEW_LINE arr . sort ( ) NEW_LINE q . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT now = q [ 0 ] NEW_LINE if ( arr [ i ] >= 2 * now ) : NEW_LINE INDENT q . popleft ( ) NEW_LINE DEDENT q . append ( arr [ i ] ) NEW_LINE DEDENT return len ( q ) NEW_LINE DEDENT
def sortRec ( arr , index , k , n ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT print ( 999 , end = "" ) NEW_LINE DEDENT elif ( k > 0 and index == 0 ) : NEW_LINE INDENT index = n - 2 NEW_LINE for i in range ( 1 , index + 1 ) : NEW_LINE INDENT arr [ i - 1 ] = arr [ i ] NEW_LINE DEDENT arr [ index ] = 999 NEW_LINE DEDENT if ( index - 1 >= 0 and index + 1 < n and arr [ index - 1 ] > arr [ index + 1 ] ) : NEW_LINE INDENT arr [ index ] , arr [ index + 1 ] = arr [ index + 1 ] , arr [ index ] NEW_LINE arr [ index - 1 ] , arr [ index + 1 ] = arr [ index + 1 ] , arr [ index - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( index - 1 < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ] NEW_LINE DEDENT sortRec ( arr , index - 1 , k - 1 , n ) NEW_LINE DEDENT
def sortString ( str ) : NEW_LINE INDENT charCount = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT charCount [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( charCount [ i ] ) : NEW_LINE INDENT print ( chr ( 97 + i ) , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def printMedian ( arr , n , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE print ( arr [ int ( ( n + K ) / 2 ) ] ) NEW_LINE DEDENT
def stableSelectionSort ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT min_idx = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ min_idx ] > a [ j ] : NEW_LINE INDENT min_idx = j NEW_LINE DEDENT DEDENT key = a [ min_idx ] NEW_LINE while min_idx > i : NEW_LINE INDENT a [ min_idx ] = a [ min_idx - 1 ] NEW_LINE min_idx -= 1 NEW_LINE DEDENT a [ i ] = key NEW_LINE DEDENT DEDENT
def sortBinaryArray ( a , n ) : NEW_LINE INDENT j = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < 1 : NEW_LINE INDENT j = j + 1 NEW_LINE a [ i ] , a [ j ] = a [ j ] , a [ i ] NEW_LINE DEDENT DEDENT DEDENT
def almostSort ( A , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if A [ i ] > A [ i + 1 ] : NEW_LINE INDENT A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if A [ i ] > A [ i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def minMaxSelectionSort ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE max = arr [ i ] NEW_LINE min_i = i NEW_LINE max_i = i NEW_LINE for k in range ( i , j + 1 , 1 ) : NEW_LINE INDENT if ( arr [ k ] > max ) : NEW_LINE INDENT max = arr [ k ] NEW_LINE max_i = k NEW_LINE DEDENT elif ( arr [ k ] < min ) : NEW_LINE INDENT min = arr [ k ] NEW_LINE min_i = k NEW_LINE DEDENT DEDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ min_i ] NEW_LINE arr [ min_i ] = temp NEW_LINE if ( arr [ min_i ] == max ) : NEW_LINE INDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ min_i ] NEW_LINE arr [ min_i ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ max_i ] NEW_LINE arr [ max_i ] = temp NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT print ( "Sorted array:" , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def nextGap ( gap ) : NEW_LINE INDENT if ( gap <= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( gap // 2 ) + ( gap % 2 ) NEW_LINE DEDENT
def arrange ( arr , n , x ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( arr [ i ] - x ) NEW_LINE j = i - 1 NEW_LINE if ( abs ( arr [ j ] - x ) > diff ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE while ( abs ( arr [ j ] - x ) > diff and j >= 0 ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT arr [ j + 1 ] = temp NEW_LINE DEDENT DEDENT DEDENT
def printOrder ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT for j in range ( n - 1 , n // 2 - 1 , - 1 ) : NEW_LINE INDENT print ( arr [ j ] , end = " " ) NEW_LINE DEDENT DEDENT
def findDuplicate ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j , count = i + 1 , 1 NEW_LINE while ( j < n and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT i = j NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findDuplicate ( arr , n , k ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 1 and arr [ i ] > MAX ) : NEW_LINE INDENT print "Out of range" NEW_LINE return - 1 NEW_LINE DEDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def maxProductSubarrayOfSizeK ( A , n , k ) : NEW_LINE INDENT A . sort ( ) NEW_LINE product = 1 NEW_LINE if ( A [ n - 1 ] == 0 and ( k & 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( A [ n - 1 ] <= 0 and ( k & 1 ) ) : NEW_LINE INDENT for i in range ( n - 1 , n - k + 1 , - 1 ) : NEW_LINE INDENT product *= A [ i ] NEW_LINE DEDENT return product NEW_LINE DEDENT i = 0 NEW_LINE j = n - 1 NEW_LINE if ( k & 1 ) : NEW_LINE INDENT product *= A [ j ] NEW_LINE j -= 1 NEW_LINE k -= 1 NEW_LINE DEDENT k >>= 1 NEW_LINE for itr in range ( k ) : NEW_LINE INDENT left_product = A [ i ] * A [ i + 1 ] NEW_LINE right_product = A [ j ] * A [ j - 1 ] NEW_LINE if ( left_product > right_product ) : NEW_LINE INDENT product *= left_product NEW_LINE i += 2 NEW_LINE DEDENT else : NEW_LINE INDENT product *= right_product NEW_LINE j -= 2 NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT
def findMaximum ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE index = 0 NEW_LINE i = n - 1 NEW_LINE while ( i >= index ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE index += k NEW_LINE i -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def insertionSort ( arr , left , right ) : NEW_LINE INDENT for i in range ( left + 1 , right + 1 ) : NEW_LINE INDENT j = i NEW_LINE while j > left and arr [ j ] < arr [ j - 1 ] : NEW_LINE INDENT arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT
def merge ( arr , l , m , r ) : NEW_LINE INDENT len1 , len2 = m - l + 1 , r - m NEW_LINE left , right = [ ] , [ ] NEW_LINE for i in range ( 0 , len1 ) : NEW_LINE INDENT left . append ( arr [ l + i ] ) NEW_LINE DEDENT for i in range ( 0 , len2 ) : NEW_LINE INDENT right . append ( arr [ m + 1 + i ] ) NEW_LINE DEDENT i , j , k = 0 , 0 , l NEW_LINE while i < len1 and j < len2 : NEW_LINE INDENT if left [ i ] <= right [ j ] : NEW_LINE INDENT arr [ k ] = left [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] = right [ j ] NEW_LINE j += 1 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT while i < len1 : NEW_LINE INDENT arr [ k ] = left [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT while j < len2 : NEW_LINE INDENT arr [ k ] = right [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT
def checkForSorting ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i + 1 ] == 1 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def sort ( s , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT temp = s [ i ] NEW_LINE j = i - 1 NEW_LINE while j >= 0 and len ( temp ) < len ( s [ j ] ) : NEW_LINE INDENT s [ j + 1 ] = s [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT s [ j + 1 ] = temp NEW_LINE DEDENT DEDENT
def printArraystring ( string , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def maxLevel ( boxes , n ) : NEW_LINE INDENT boxes . sort ( ) NEW_LINE prev_width = boxes [ 0 ] NEW_LINE prev_count = 1 NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_width += boxes [ i ] NEW_LINE curr_count += 1 NEW_LINE if ( curr_width > prev_width and curr_count > prev_count ) : NEW_LINE INDENT prev_width = curr_width NEW_LINE prev_count = curr_count NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def stoogesort ( arr , l , h ) : NEW_LINE INDENT if l >= h : NEW_LINE INDENT return NEW_LINE DEDENT if arr [ l ] > arr [ h ] : NEW_LINE INDENT t = arr [ l ] NEW_LINE arr [ l ] = arr [ h ] NEW_LINE arr [ h ] = t NEW_LINE DEDENT if h - l + 1 > 2 : NEW_LINE INDENT t = ( int ) ( ( h - l + 1 ) / 3 ) NEW_LINE stoogesort ( arr , l , ( h - t ) ) NEW_LINE stoogesort ( arr , l + t , ( h ) ) NEW_LINE stoogesort ( arr , l , ( h - t ) ) NEW_LINE DEDENT DEDENT
def merge ( arr , temp , left , mid , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE DEDENT
def mergeSort ( arr , array_size ) : NEW_LINE INDENT temp = [ None ] * array_size NEW_LINE return _mergeSort ( arr , temp , 0 , array_size - 1 ) NEW_LINE DEDENT
def minDifferenceAmongMaxMin ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 2147483647 NEW_LINE for i in range ( ( N - K ) + 1 ) : NEW_LINE INDENT curSeqDiff = arr [ i + K - 1 ] - arr [ i ] NEW_LINE res = min ( res , curSeqDiff ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def insertionSortRecursive ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT insertionSortRecursive ( arr , n - 1 ) NEW_LINE last = arr [ n - 1 ] NEW_LINE j = n - 2 NEW_LINE while ( j >= 0 and arr [ j ] > last ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = last NEW_LINE DEDENT
def twoWaySort ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT DEDENT
def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ low ] NEW_LINE i = low - 1 NEW_LINE j = high + 1 NEW_LINE while ( True ) : NEW_LINE INDENT i += 1 NEW_LINE while ( arr [ i ] < pivot ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT j -= 1 NEW_LINE while ( arr [ j ] > pivot ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i >= j ) : NEW_LINE INDENT return j NEW_LINE DEDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT
def quickSort ( arr , low , high ) : NEW_LINE INDENT if ( low < high ) : NEW_LINE INDENT pi = partition ( arr , low , high ) NEW_LINE quickSort ( arr , low , pi ) NEW_LINE quickSort ( arr , pi + 1 , high ) NEW_LINE DEDENT DEDENT
def ksmallest ( arr , n , k ) : NEW_LINE INDENT b = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 NEW_LINE DEDENT for j in range ( 1 , MAX ) : NEW_LINE INDENT if ( b [ j ] != 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k is not 1 ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT DEDENT
def ksmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE if ( k < arr [ 0 ] ) : NEW_LINE INDENT return k NEW_LINE DEDENT if ( k == arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] + 1 NEW_LINE DEDENT if ( k > arr [ n - 1 ] ) : NEW_LINE INDENT return k + n NEW_LINE DEDENT if ( arr [ 0 ] == 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= ( arr [ 0 ] - 1 ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT c = arr [ i ] - arr [ i - 1 ] - 1 NEW_LINE if ( k <= c ) : NEW_LINE INDENT return arr [ i - 1 ] + k NEW_LINE DEDENT else : NEW_LINE INDENT k -= c NEW_LINE DEDENT DEDENT return arr [ n - 1 ] + k NEW_LINE DEDENT
def multiply ( A , B , C ) : NEW_LINE INDENT global V NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT C [ i ] [ j ] = 0 NEW_LINE for k in range ( V ) : NEW_LINE INDENT C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def getTrace ( graph ) : NEW_LINE INDENT global V NEW_LINE trace = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT trace += graph [ i ] [ i ] NEW_LINE DEDENT return trace NEW_LINE DEDENT
def triangleInGraph ( graph ) : NEW_LINE INDENT global V NEW_LINE aux2 = [ [ None ] * V for i in range ( V ) ] NEW_LINE aux3 = [ [ None ] * V for i in range ( V ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT aux2 [ i ] [ j ] = aux3 [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT multiply ( graph , graph , aux2 ) NEW_LINE multiply ( graph , aux2 , aux3 ) NEW_LINE trace = getTrace ( aux3 ) NEW_LINE return trace // 6 NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr . sort ( reverse = True ) NEW_LINE i = 0 NEW_LINE sum = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE sum += evenArr [ j ] * oddArr [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def mergeTwoHalf ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE DEDENT
def minDiff ( arr , n , k ) : NEW_LINE INDENT result = + 2147483647 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def isPossible ( a , b , n , k ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] + b [ i ] < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( i % 2 ) == 0 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr = sorted ( evenArr ) NEW_LINE oddArr = sorted ( oddArr ) NEW_LINE oddArr = oddArr [ : : - 1 ] NEW_LINE i = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def findMinDiff ( arr , n , m ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE if ( n < m ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT min_diff = arr [ n - 1 ] - arr [ 0 ] NEW_LINE for i in range ( len ( arr ) - m + 1 ) : NEW_LINE INDENT min_diff = min ( min_diff , arr [ i + m - 1 ] - arr [ i ] ) NEW_LINE DEDENT return min_diff NEW_LINE DEDENT
def minValue ( A , B , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += ( A [ i ] * B [ n - i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def merge ( arr , temp , left , mid , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE DEDENT
def _mergeSort ( arr , temp , left , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if ( right > left ) : NEW_LINE INDENT mid = int ( ( right + left ) / 2 ) NEW_LINE inv_count = _mergeSort ( arr , temp , left , mid ) NEW_LINE inv_count += _mergeSort ( arr , temp , mid + 1 , right ) NEW_LINE inv_count += merge ( arr , temp , left , mid + 1 , right ) NEW_LINE DEDENT return inv_count NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return ( n % 2 == 0 ) NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return ( not ( n & 1 ) ) NEW_LINE DEDENT
def findSubsequenceCount ( S , T ) : NEW_LINE INDENT m = len ( T ) NEW_LINE n = len ( S ) NEW_LINE if m > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT mat [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( n + 1 ) : NEW_LINE INDENT mat [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if T [ i - 1 ] != S [ j - 1 ] : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return mat [ m ] [ n ] NEW_LINE DEDENT
def countBits ( a ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT a = a >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def insertionSort ( arr , aux , n ) : NEW_LINE INDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT key1 = aux [ i ] NEW_LINE key2 = arr [ i ] NEW_LINE j = i - 1 NEW_LINE while ( j >= 0 and aux [ j ] < key1 ) : NEW_LINE INDENT aux [ j + 1 ] = aux [ j ] NEW_LINE arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT aux [ j + 1 ] = key1 NEW_LINE arr [ j + 1 ] = key2 NEW_LINE DEDENT DEDENT
def sortBySetBitCount ( arr , n ) : NEW_LINE INDENT aux = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT aux [ i ] = countBits ( arr [ i ] ) NEW_LINE DEDENT insertionSort ( arr , aux , n ) NEW_LINE DEDENT
def countBits ( a ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT a = a >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def sortBySetBitCount ( arr , n ) : NEW_LINE INDENT count = [ [ ] for i in range ( 32 ) ] NEW_LINE setbitcount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT setbitcount = countBits ( arr [ i ] ) NEW_LINE count [ setbitcount ] . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT v1 = count [ i ] NEW_LINE for i in range ( len ( v1 ) ) : NEW_LINE INDENT arr [ j ] = v1 [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT print ( * arr ) NEW_LINE DEDENT
def findSurpasser ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " " ) NEW_LINE DEDENT DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def solve ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT a = a * 10 + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b = b * 10 + arr [ i ] NEW_LINE DEDENT DEDENT return a + b NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT leftMin = [ - 1 for i in range ( n ) ] NEW_LINE rightMin = [ - 1 for i in range ( n ) ] NEW_LINE leftMax = [ - 1 for i in range ( n ) ] NEW_LINE rightMax = [ - 1 for i in range ( n ) ] NEW_LINE max_product = - sys . maxsize - 1 NEW_LINE max_sum = arr [ 0 ] NEW_LINE min_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT leftMax [ i ] = max_sum NEW_LINE if ( arr [ i ] > max_sum ) : NEW_LINE INDENT max_sum = arr [ i ] NEW_LINE DEDENT leftMin [ i ] = min_sum NEW_LINE if ( arr [ i ] < min_sum ) : NEW_LINE INDENT min_sum = arr [ i ] NEW_LINE DEDENT DEDENT max_sum = arr [ n - 1 ] NEW_LINE min_sum = arr [ n - 1 ] NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT rightMax [ j ] = max_sum NEW_LINE if ( arr [ j ] > max_sum ) : NEW_LINE INDENT max_sum = arr [ j ] NEW_LINE DEDENT rightMin [ j ] = min_sum NEW_LINE if ( arr [ j ] < min_sum ) : NEW_LINE INDENT min_sum = arr [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT max1 = max ( arr [ i ] * leftMax [ i ] * rightMax [ i ] , arr [ i ] * leftMin [ i ] * rightMin [ i ] ) NEW_LINE max2 = max ( arr [ i ] * leftMax [ i ] * rightMin [ i ] , arr [ i ] * leftMin [ i ] * rightMax [ i ] ) NEW_LINE max_product = max ( max_product , max ( max1 , max2 ) ) NEW_LINE DEDENT return max_product NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT maxA = - sys . maxsize - 1 NEW_LINE maxB = - sys . maxsize - 1 NEW_LINE maxC = - sys . maxsize - 1 NEW_LINE minA = sys . maxsize NEW_LINE minB = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > maxA ) : NEW_LINE INDENT maxC = maxB NEW_LINE maxB = maxA NEW_LINE maxA = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxB ) : NEW_LINE INDENT maxC = maxB NEW_LINE maxB = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxC ) : NEW_LINE INDENT maxC = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < minA ) : NEW_LINE INDENT minB = minA NEW_LINE minA = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < minB ) : NEW_LINE INDENT minB = arr [ i ] NEW_LINE DEDENT DEDENT return max ( minA * minB * maxA , maxA * maxB * maxC ) NEW_LINE DEDENT
def distinctCount ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( abs ( arr [ i ] ) ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT
def distinctCount ( arr , n ) : NEW_LINE INDENT count = n NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE sum = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT while ( i != j and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT count = count - 1 NEW_LINE i = i + 1 NEW_LINE DEDENT while ( i != j and arr [ j ] == arr [ j - 1 ] ) : NEW_LINE INDENT count = count - 1 NEW_LINE j = j - 1 NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT break NEW_LINE DEDENT sum = arr [ i ] + arr [ j ] NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT count = count - 1 NEW_LINE i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT elif ( sum < 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT j = j - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findMaxGuests ( arrl , exit , n ) : NEW_LINE INDENT arrl . sort ( ) NEW_LINE exit . sort ( ) NEW_LINE guests_in = 1 NEW_LINE max_guests = 1 NEW_LINE time = arrl [ 0 ] NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( arrl [ i ] <= exit [ j ] ) : NEW_LINE INDENT guests_in = guests_in + 1 NEW_LINE if ( guests_in > max_guests ) : NEW_LINE INDENT max_guests = guests_in NEW_LINE time = arrl [ i ] NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT guests_in = guests_in - 1 NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT print ( "Maximum Number of Guests =" , max_guests , "at time" , time ) NEW_LINE DEDENT
def binarySearch ( a , item , low , high ) : NEW_LINE INDENT while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( item == a [ mid ] ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT elif ( item > a [ mid ] ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT
def insertionSort ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT j = i - 1 NEW_LINE selected = a [ i ] NEW_LINE loc = binarySearch ( a , selected , 0 , j ) NEW_LINE while ( j >= loc ) : NEW_LINE INDENT a [ j + 1 ] = a [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT a [ j + 1 ] = selected NEW_LINE DEDENT DEDENT
def findMax ( arr , n ) : NEW_LINE INDENT mi = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] > arr [ mi ] : NEW_LINE INDENT mi = i NEW_LINE DEDENT DEDENT return mi NEW_LINE DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( "%d" % ( arr [ i ] ) , end = " " ) NEW_LINE DEDENT DEDENT
def minMoves ( a , b , K ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( a [ 0 ] ) NEW_LINE cntOperations = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( a [ i ] [ j ] != b [ i ] [ j ] ) : NEW_LINE INDENT cntOperations += 1 NEW_LINE if ( i + K - 1 >= n or j + K - 1 >= m ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for p in range ( 0 , K ) : NEW_LINE INDENT for q in range ( 0 , K ) : NEW_LINE INDENT if ( a [ i + p ] [ j + q ] == '0' ) : NEW_LINE INDENT a [ i + p ] [ j + q ] = '1' NEW_LINE DEDENT else : NEW_LINE INDENT a [ i + p ] [ j + q ] = '0' NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return cntOperations NEW_LINE DEDENT
def maxConsecutiveCnt ( arr ) : NEW_LINE INDENT X = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] <= ( X + 1 ) ) : NEW_LINE INDENT X = X + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return X + 1 NEW_LINE DEDENT
def findPermutation ( N , L , R , S ) : NEW_LINE INDENT x = R - L + 1 NEW_LINE if ( not possible ( x , S , N ) ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT if ( ( S - i ) >= 0 and possible ( x - 1 , S - i , i - 1 ) ) : NEW_LINE INDENT S = S - i NEW_LINE x -= 1 NEW_LINE v . append ( i ) NEW_LINE DEDENT if ( S == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( S != 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT v1 = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT it = i in v NEW_LINE if ( not it ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE DEDENT DEDENT j = 0 NEW_LINE f = 0 NEW_LINE for i in range ( 1 , L ) : NEW_LINE INDENT print ( v1 [ j ] , end = " " ) NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT print ( v [ f ] , end = " " ) NEW_LINE f += 1 NEW_LINE DEDENT for i in range ( R + 1 , N + 1 ) : NEW_LINE INDENT print ( v1 [ j ] , end = " " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def maxShiftArrayValue ( arr , cap , N ) : NEW_LINE INDENT sumVals = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sumVals += arr [ i ] NEW_LINE DEDENT maxCapacity = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT maxCapacity = max ( cap [ i ] , maxCapacity ) NEW_LINE DEDENT return min ( maxCapacity , sumVals ) NEW_LINE DEDENT
def minimumSizeArray ( S , P ) : NEW_LINE INDENT if ( S == P ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 2 , S + 1 ) : NEW_LINE INDENT d = i NEW_LINE if ( ( S / d ) >= pow ( P , 1.0 / d ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countPoints ( D ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , int ( sqrt ( D * D ) ) , 1 ) : NEW_LINE INDENT y = int ( sqrt ( ( D * D - x * x ) ) ) NEW_LINE if ( x * x + y * y == D * D ) : NEW_LINE INDENT count += 4 NEW_LINE DEDENT DEDENT count += 4 NEW_LINE return count NEW_LINE DEDENT
def minimizeCost ( A , B , C ) : NEW_LINE INDENT ans = A + B + C NEW_LINE for i in range ( 1 , 2 * C + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( i * j <= 2 * C ) : NEW_LINE INDENT ans = min ( ans , abs ( A - i ) + abs ( B - j ) + abs ( i * j - C ) ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def averageSetBits ( N , K , arr ) : NEW_LINE INDENT p = N NEW_LINE q = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT _p = p NEW_LINE _q = q NEW_LINE p = _p - _p * arr [ i ] / N + _q * arr [ i ] / N NEW_LINE q = _q - _q * arr [ i ] / N + _p * arr [ i ] / N NEW_LINE DEDENT return p NEW_LINE DEDENT
def KthSolution ( X , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , 64 ) : NEW_LINE INDENT if ( not ( X & ( 1 << i ) ) ) : NEW_LINE INDENT if ( K & 1 ) : NEW_LINE INDENT ans |= ( 1 << i ) NEW_LINE DEDENT K >>= 1 NEW_LINE if ( not K ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def minimumcoins ( arr , N ) : NEW_LINE INDENT coins = 0 NEW_LINE j = 0 NEW_LINE if ( arr [ 0 ] == 1 ) : NEW_LINE INDENT coins += 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT continue NEW_LINE DEDENT j = i NEW_LINE while ( j < N and arr [ j ] == 1 ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT x = ( j - i ) NEW_LINE coins += x // 3 NEW_LINE i = j - 1 NEW_LINE DEDENT return coins NEW_LINE DEDENT
def maximumUniqueSquares ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE if N < 4 : NEW_LINE INDENT return 0 NEW_LINE DEDENT len = int ( math . sqrt ( N ) ) NEW_LINE N -= len * len NEW_LINE for i in range ( 1 , len ) : NEW_LINE INDENT ans += i * i NEW_LINE DEDENT if ( N >= len ) : NEW_LINE INDENT N -= len NEW_LINE for i in range ( 1 , len ) : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT ans += i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def rearrange ( arr , N ) : NEW_LINE INDENT if ( N & 1 ) : NEW_LINE INDENT N -= 1 NEW_LINE DEDENT odd_idx = 1 NEW_LINE even_idx = 0 NEW_LINE max_elem = arr [ N - 1 ] + 1 NEW_LINE for i in range ( N // 2 ) : NEW_LINE INDENT arr [ i ] += ( arr [ odd_idx ] % max_elem ) * max_elem NEW_LINE odd_idx += 2 NEW_LINE DEDENT for i in range ( N // 2 , N ) : NEW_LINE INDENT arr [ i ] += ( arr [ even_idx ] % max_elem ) * max_elem NEW_LINE even_idx += 2 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT arr [ i ] = arr [ i ] // max_elem NEW_LINE DEDENT DEDENT
def generateString ( k1 , k2 , s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE C1s = 0 NEW_LINE C0s = 0 NEW_LINE flag = 0 NEW_LINE pos = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT C0s += 1 NEW_LINE if ( ( i + 1 ) % k1 != 0 and ( i + 1 ) % k2 != 0 ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT C1s += 1 NEW_LINE DEDENT if ( C0s >= C1s ) : NEW_LINE INDENT if ( len ( pos ) == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT k = pos [ len ( pos ) - 1 ] NEW_LINE s [ k ] = '1' NEW_LINE C0s -= 1 NEW_LINE C1s += 1 NEW_LINE pos = pos [ : - 1 ] NEW_LINE DEDENT DEDENT DEDENT s = '' . join ( s ) NEW_LINE if ( flag == 0 ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT
def findRange ( arr , N , K ) : NEW_LINE INDENT L = - sys . maxsize - 1 NEW_LINE R = sys . maxsize NEW_LINE for i in range ( N ) : NEW_LINE INDENT l = ceil ( 1.0 * arr [ i ] * K / ( i + 1 ) ) NEW_LINE r = ceil ( ( 1.0 + arr [ i ] ) * K / ( i + 1 ) - 1 ) NEW_LINE L = max ( L , l ) NEW_LINE R = min ( R , r ) NEW_LINE DEDENT print ( L , R ) NEW_LINE DEDENT
def findAnagram ( s ) : NEW_LINE INDENT check = s NEW_LINE st = list ( s ) NEW_LINE i = 0 NEW_LINE j = len ( st ) - 1 NEW_LINE while ( i < len ( st ) and j >= 0 ) : NEW_LINE INDENT if ( st [ i ] != st [ j ] and check [ i ] != st [ j ] and check [ j ] != st [ i ] ) : NEW_LINE INDENT st [ i ] , st [ j ] = st [ j ] , st [ i ] NEW_LINE i += 1 NEW_LINE j = len ( st ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT if ( len ( st ) % 2 != 0 ) : NEW_LINE INDENT mid = len ( st ) / 2 NEW_LINE if ( check [ mid ] == st [ mid ] ) : NEW_LINE INDENT for i in range ( len ( st ) ) : NEW_LINE INDENT if ( check [ i ] != st [ mid ] and st [ i ] != st [ mid ] ) : NEW_LINE INDENT st [ i ] , st [ mid ] = st [ mid ] , st [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT ok = True NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT if ( check [ i ] == st [ i ] ) : NEW_LINE INDENT ok = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( ok ) : NEW_LINE INDENT print ( "" . join ( st ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def maximizeProduct ( N ) : NEW_LINE INDENT MSB = ( int ) ( math . log2 ( N ) ) NEW_LINE X = 1 << MSB NEW_LINE Y = N - ( 1 << MSB ) NEW_LINE for i in range ( MSB ) : NEW_LINE INDENT if ( not ( N & ( 1 << i ) ) ) : NEW_LINE INDENT X += 1 << i NEW_LINE Y += 1 << i NEW_LINE DEDENT DEDENT print ( X , Y ) NEW_LINE DEDENT
def constructPermutation ( S , N ) : NEW_LINE INDENT ans = [ 0 ] * N NEW_LINE ans [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( S [ i - 1 ] == '0' ) : NEW_LINE INDENT ans [ i ] = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = ans [ i - 1 ] NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT if ( ans [ j ] >= ans [ i ] ) : NEW_LINE INDENT ans [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( ans [ i ] , end = "" ) NEW_LINE if ( i != N - 1 ) : NEW_LINE INDENT print ( " " , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def findRemainingIndex ( N ) : NEW_LINE INDENT ans = N NEW_LINE while ( N > 1 ) : NEW_LINE INDENT discard = int ( sqrt ( N ) ) NEW_LINE if ( discard * discard == N ) : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT N -= discard NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findRemainingElement ( arr , N ) : NEW_LINE INDENT remainingIndex = findRemainingIndex ( N ) NEW_LINE print ( arr [ remainingIndex - 1 ] ) NEW_LINE DEDENT
def check ( num ) : NEW_LINE INDENT sm = 0 NEW_LINE num2 = num * num NEW_LINE while ( num ) : NEW_LINE INDENT sm += num % 10 NEW_LINE num //= 10 NEW_LINE DEDENT sm2 = 0 NEW_LINE while ( num2 ) : NEW_LINE INDENT sm2 += num2 % 10 NEW_LINE num2 //= 10 NEW_LINE DEDENT return ( ( sm * sm ) == sm2 ) NEW_LINE DEDENT
def generate ( s , len1 , uniq ) : NEW_LINE INDENT if ( len ( s ) == len1 ) : NEW_LINE INDENT if ( check ( convert ( s ) ) ) : NEW_LINE INDENT uniq . add ( convert ( s ) ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( 4 ) : NEW_LINE INDENT generate ( s + chr ( i + ord ( '0' ) ) , len1 , uniq ) NEW_LINE DEDENT DEDENT
def totalNumbers ( L , R ) : NEW_LINE INDENT ans = 0 NEW_LINE max_len = int ( log10 ( R ) ) + 1 NEW_LINE uniq = set ( ) NEW_LINE for i in range ( 1 , max_len + 1 , 1 ) : NEW_LINE INDENT generate ( "" , i , uniq ) NEW_LINE DEDENT for x in uniq : NEW_LINE INDENT if ( x >= L and x <= R ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findMaximumSumWithMflips ( arr , N , M ) : NEW_LINE INDENT pq = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT pq . append ( arr [ i ] ) NEW_LINE sum += arr [ i ] NEW_LINE pq . sort ( ) NEW_LINE DEDENT while ( M > 0 ) : NEW_LINE INDENT sum -= pq [ 0 ] NEW_LINE temp = - 1 * pq [ 0 ] NEW_LINE pq = pq [ 1 : ] NEW_LINE sum += temp NEW_LINE pq . append ( temp ) NEW_LINE pq . sort ( ) NEW_LINE M -= 1 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def check ( x , N ) : NEW_LINE INDENT while True : NEW_LINE INDENT N -= x NEW_LINE if len ( str ( x ) ) == 1 : NEW_LINE INDENT break NEW_LINE DEDENT x = sum ( list ( map ( int , str ( x ) ) ) ) NEW_LINE DEDENT if len ( str ( x ) ) == 1 and N == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def minimumMoves ( A , B , N ) : NEW_LINE INDENT ans = 0 NEW_LINE sum_A = 0 NEW_LINE sum_B = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum_A += A [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT sum_B += B [ i ] NEW_LINE DEDENT if ( sum_A != sum_B ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT if ( A [ i ] > B [ i ] ) : NEW_LINE INDENT temp = A [ i ] - B [ i ] NEW_LINE j = i - 1 NEW_LINE while ( j >= 0 and temp > 0 ) : NEW_LINE INDENT if ( B [ j ] > A [ j ] ) : NEW_LINE INDENT cnt = min ( temp , ( B [ j ] - A [ j ] ) ) NEW_LINE A [ j ] += cnt NEW_LINE temp -= cnt NEW_LINE ans += ( cnt * abs ( j - i ) ) NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT if ( temp > 0 ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < N and temp > 0 ) : NEW_LINE INDENT if ( B [ j ] > A [ j ] ) : NEW_LINE INDENT cnt = min ( temp , ( B [ j ] - A [ j ] ) ) NEW_LINE A [ j ] += cnt NEW_LINE temp -= cnt NEW_LINE ans += ( cnt * abs ( j - i ) ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def possibleReachingSequence ( X , D , T ) : NEW_LINE INDENT if X < T : NEW_LINE INDENT return "NO" NEW_LINE DEDENT if T * D < X : NEW_LINE INDENT return "NO" NEW_LINE DEDENT if ( X - T ) % ( D - 1 ) == 0 : NEW_LINE INDENT return "YES" NEW_LINE DEDENT return "NO" NEW_LINE DEDENT
def maxSumAfterPartition ( arr , n ) : NEW_LINE INDENT pos = [ ] NEW_LINE neg = [ ] NEW_LINE zero = 0 NEW_LINE pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos . append ( arr [ i ] ) NEW_LINE pos_sum += arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < 0 ) : NEW_LINE INDENT neg . append ( arr [ i ] ) NEW_LINE neg_sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE pos . sort ( ) NEW_LINE neg . sort ( reverse = True ) NEW_LINE if ( len ( pos ) > 0 and len ( neg ) > 0 ) : NEW_LINE INDENT ans = ( pos_sum - neg_sum ) NEW_LINE DEDENT elif ( len ( pos ) > 0 ) : NEW_LINE INDENT if ( zero > 0 ) : NEW_LINE INDENT ans = ( pos_sum ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( pos_sum - 2 * pos [ 0 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( zero > 0 ) : NEW_LINE INDENT ans = ( - 1 * neg_sum ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( neg [ 0 ] - ( neg_sum - neg [ 0 ] ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def arrayDivisionByTwo ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] // 2 NEW_LINE cnt += 1 NEW_LINE DEDENT ans = min ( ans , cnt ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minPushes ( N , K , arr ) : NEW_LINE INDENT dp = [ - 1 ] * 100000 NEW_LINE dp [ N ] = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT for xx in range ( 100000 ) : NEW_LINE INDENT x = xx NEW_LINE if ( dp [ x ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT next = ( x + arr [ i ] ) % 100000 NEW_LINE while ( dp [ next ] == - 1 or dp [ next ] > dp [ x ] + 1 ) : NEW_LINE INDENT dp [ next ] = dp [ x ] + 1 NEW_LINE x = next NEW_LINE next = ( next + arr [ i ] ) % 100000 NEW_LINE DEDENT DEDENT DEDENT return dp [ K ] NEW_LINE DEDENT
def minimumOperations ( A , N ) : NEW_LINE INDENT cur_prefix_1 = 0 NEW_LINE parity = - 1 NEW_LINE minOperationsCase1 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cur_prefix_1 += A [ i ] NEW_LINE if ( cur_prefix_1 == 0 or parity * cur_prefix_1 < 0 ) : NEW_LINE INDENT minOperationsCase1 += abs ( parity - cur_prefix_1 ) NEW_LINE cur_prefix_1 = parity NEW_LINE DEDENT parity *= - 1 NEW_LINE DEDENT cur_prefix_2 = 0 NEW_LINE parity = 1 NEW_LINE minOperationsCase2 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cur_prefix_2 += A [ i ] NEW_LINE if ( cur_prefix_2 == 0 or parity * cur_prefix_2 < 0 ) : NEW_LINE INDENT minOperationsCase2 += abs ( parity - cur_prefix_2 ) NEW_LINE cur_prefix_2 = parity NEW_LINE DEDENT parity *= - 1 NEW_LINE DEDENT return min ( minOperationsCase1 , minOperationsCase2 ) NEW_LINE DEDENT
def maximumSumArray ( arr , N ) : NEW_LINE INDENT arrA = [ 0 ] * N NEW_LINE ans = [ 0 ] * N NEW_LINE maxSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT arrA [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT arrB = [ 0 ] * N NEW_LINE maximum = arrA [ i ] NEW_LINE arrB [ i ] = maximum NEW_LINE temp = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT arrB [ j ] = min ( maximum , arrA [ j ] ) NEW_LINE maximum = arrB [ j ] NEW_LINE temp = j NEW_LINE DEDENT maximum = arrA [ i ] NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT arrB [ j ] = min ( maximum , arrA [ j ] ) NEW_LINE maximum = arrB [ j ] NEW_LINE DEDENT sum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT sum += arrB [ j ] NEW_LINE DEDENT if ( sum > maxSum ) : NEW_LINE INDENT maxSum = sum NEW_LINE ans = arrB NEW_LINE DEDENT DEDENT for val in ans : NEW_LINE INDENT print ( val ) NEW_LINE DEDENT DEDENT
def minProductUtil ( R1 , B1 , R2 , B2 , M ) : NEW_LINE INDENT x = min ( R1 - B1 , M ) NEW_LINE M -= x NEW_LINE R1 -= x NEW_LINE if M > 0 : NEW_LINE INDENT y = min ( R2 - B2 , M ) NEW_LINE M -= y NEW_LINE R2 -= y NEW_LINE DEDENT return R1 * R2 NEW_LINE DEDENT
def minProduct ( R1 , B1 , R2 , B2 , M ) : NEW_LINE INDENT res1 = minProductUtil ( R1 , B1 , R2 , B2 , M ) NEW_LINE res2 = minProductUtil ( R2 , B2 , R1 , B1 , M ) NEW_LINE return min ( res1 , res2 ) NEW_LINE DEDENT
def maxAmount ( n , k , arr ) : NEW_LINE INDENT A = [ 0 for i in range ( 1000001 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT A [ arr [ i ] ] += 1 NEW_LINE DEDENT j = 0 NEW_LINE for j in range ( 1000001 ) : NEW_LINE INDENT while ( A [ i ] != 0 ) : NEW_LINE INDENT arr [ j ] = i NEW_LINE j += 1 NEW_LINE A [ i ] -= 1 NEW_LINE DEDENT DEDENT ans = 6 NEW_LINE mod = 1000000007 NEW_LINE i = n - 1 NEW_LINE j = n - 2 NEW_LINE while ( k > 0 and j >= 0 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT ans = ans + min ( k , ( i - j ) ) * arr [ i ] NEW_LINE k = k - ( i - j ) NEW_LINE arr [ i ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT while ( j >= 0 and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( j < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = ans + min ( k , ( i - j ) ) * arr [ i ] NEW_LINE k = k - ( i - j ) NEW_LINE arr [ i ] -= 1 NEW_LINE DEDENT DEDENT while ( k > 0 and arr [ i ] != 0 ) : NEW_LINE INDENT ans = ans + min ( n , k ) * arr [ i ] NEW_LINE k -= n NEW_LINE arr [ i ] -= 1 NEW_LINE DEDENT ans = ans % mod NEW_LINE x = ans NEW_LINE return x NEW_LINE DEDENT
def validPermutations ( str ) : NEW_LINE INDENT m = { } NEW_LINE count = len ( str ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] in m ) : NEW_LINE INDENT m [ str [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ str [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT ans += count - m [ str [ i ] ] NEW_LINE m [ str [ i ] ] -= 1 NEW_LINE count -= 1 NEW_LINE DEDENT return ans + 1 NEW_LINE DEDENT
def maxAverage ( A , N , X , Y ) : NEW_LINE INDENT A . sort ( ) NEW_LINE sum = 0 NEW_LINE res = 0 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE count += 1 NEW_LINE if ( count == X ) : NEW_LINE INDENT if ( N - i - 1 < X ) : NEW_LINE INDENT i += 1 NEW_LINE cnt = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT cnt += 1 NEW_LINE sum += A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT X = X + cnt NEW_LINE res += sum / X NEW_LINE break NEW_LINE DEDENT res += sum / X NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def maxSum ( arr ) : NEW_LINE INDENT m = len ( arr ) NEW_LINE n = len ( arr [ 0 ] ) - 1 NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m ) ] NEW_LINE for i in range ( 1 , m , 1 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = arr [ i ] [ 1 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( 1 , m , 1 ) : NEW_LINE INDENT mx = 0 NEW_LINE for k in range ( 1 , m , 1 ) : NEW_LINE INDENT if ( k != j ) : NEW_LINE INDENT if ( dp [ k ] [ i - 1 ] > mx ) : NEW_LINE INDENT mx = dp [ k ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT if ( mx and arr [ j ] [ i ] ) : NEW_LINE INDENT dp [ j ] [ i ] = arr [ j ] [ i ] + mx NEW_LINE DEDENT DEDENT DEDENT ans = - 1 NEW_LINE for i in range ( 1 , m , 1 ) : NEW_LINE INDENT if ( dp [ i ] [ n ] ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findMaximumPoints ( N , X , H ) : NEW_LINE INDENT ans = 0 NEW_LINE prev = - sys . maxsize - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( prev < ( X [ i ] - H [ i ] ) ) : NEW_LINE INDENT ans += 1 NEW_LINE prev = X [ i ] NEW_LINE DEDENT elif ( i == N - 1 or ( X [ i ] + H [ i ] ) < X [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE prev = X [ i ] + H [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT prev = X [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maxGcd ( a , b ) : NEW_LINE INDENT print ( abs ( a - b ) ) NEW_LINE DEDENT
def sumOfCombinationOf4OR5 ( arr , N ) : NEW_LINE INDENT ans = [ - 1 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] < 4 ) : NEW_LINE INDENT continue NEW_LINE DEDENT sum = 10 ** 9 NEW_LINE cnt = 0 NEW_LINE for j in range ( 0 , arr [ i ] + 1 , 4 ) : NEW_LINE INDENT if ( ( arr [ i ] - j ) % 5 == 0 ) : NEW_LINE INDENT sum = min ( sum , cnt + ( arr [ i ] - j ) // 5 ) NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT if ( sum != 10 ** 9 ) : NEW_LINE INDENT ans [ i ] = sum NEW_LINE DEDENT DEDENT for num in ans : NEW_LINE INDENT print ( num , end = " " ) NEW_LINE DEDENT DEDENT
def power ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 2 * power ( n - 1 ) NEW_LINE DEDENT
def printBinaryString ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 ) : NEW_LINE INDENT print ( 0 , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def MinCost ( days , cost , N ) : NEW_LINE INDENT size = days [ N - 1 ] + 1 NEW_LINE dp = [ 0 for i in range ( size ) ] NEW_LINE dp [ size - 1 ] = min ( cost [ 0 ] , min ( cost [ 1 ] , cost [ 2 ] ) ) NEW_LINE ptr = N - 2 NEW_LINE for i in range ( size - 2 , 0 , - 1 ) : NEW_LINE INDENT if ( ptr >= 0 and days [ ptr ] == i ) : NEW_LINE INDENT val1 = dp [ i + 1 ] + cost [ 0 ] NEW_LINE val2 = cost [ 1 ] + ( 0 if ( i + 7 >= size ) else dp [ i + 7 ] ) NEW_LINE val3 = cost [ 2 ] + ( 0 if ( i + 30 >= size ) else dp [ i + 30 ] ) NEW_LINE dp [ i ] = min ( val1 , min ( val2 , val3 ) ) NEW_LINE ptr -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i + 1 ] NEW_LINE DEDENT DEDENT return dp [ 1 ] NEW_LINE DEDENT
def minElements ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE requiredNum = 1 NEW_LINE i = 0 NEW_LINE while ( requiredNum <= K ) : NEW_LINE INDENT if ( i < N and requiredNum >= arr [ i ] ) : NEW_LINE INDENT requiredNum += arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE requiredNum += requiredNum NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def minimumSteps ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE a = abs ( a - b ) NEW_LINE cnt = ( a // 5 ) + ( a % 5 ) // 2 + ( a % 5 ) % 2 NEW_LINE return cnt NEW_LINE DEDENT
def maximumCount ( arr , N ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( odd and even ) : NEW_LINE INDENT return N - 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N - 1 NEW_LINE DEDENT DEDENT
def miniOperToMakeAllEleEqual ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % n ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT valueAfterDivision = sum // n NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( abs ( valueAfterDivision - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT count += abs ( valueAfterDivision - arr [ i ] ) // k NEW_LINE DEDENT print ( count // 2 ) NEW_LINE DEDENT
def countOpenDoors ( N ) : NEW_LINE INDENT doorsOpen = int ( math . sqrt ( N ) ) NEW_LINE return doorsOpen NEW_LINE DEDENT
def minPossibleValue ( N , K , X ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( X <= K ) : NEW_LINE INDENT X = X * 2 NEW_LINE DEDENT else : NEW_LINE INDENT X = X + K NEW_LINE DEDENT DEDENT return X NEW_LINE DEDENT
def findMissingValue ( arr , N ) : NEW_LINE INDENT minE = sys . maxsize NEW_LINE maxE = - sys . maxsize - 1 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( arr [ i ] == - 1 and arr [ i + 1 ] != - 1 ) : NEW_LINE INDENT minE = min ( minE , arr [ i + 1 ] ) NEW_LINE maxE = max ( maxE , arr [ i + 1 ] ) NEW_LINE DEDENT if ( arr [ i ] != - 1 and arr [ i + 1 ] == - 1 ) : NEW_LINE INDENT minE = min ( minE , arr [ i ] ) NEW_LINE maxE = max ( maxE , arr [ i ] ) NEW_LINE DEDENT DEDENT if ( minE == sys . maxsize and maxE == - sys . maxsize - 1 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( minE + maxE ) // 2 ) NEW_LINE DEDENT DEDENT
def findLastElement ( N , A ) : NEW_LINE INDENT l = len ( A ) NEW_LINE j = 0 NEW_LINE while ( N > l * ( 2 ** j ) ) : NEW_LINE INDENT N = N - l * 2 ** j NEW_LINE j += 1 NEW_LINE DEDENT k = 1 NEW_LINE r = 2 ** j NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if N > r * i : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( A ) ) : NEW_LINE INDENT if ( i + 1 == k ) : NEW_LINE INDENT print ( A [ i ] ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT
def findMaxD ( arr , N , K ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT arr [ i ] = abs ( arr [ i ] - K ) NEW_LINE DEDENT D = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT D = gcd ( D , arr [ i ] ) NEW_LINE DEDENT return D NEW_LINE DEDENT
def minOperations ( a ) : NEW_LINE INDENT res = 100000000000 NEW_LINE N = len ( a ) NEW_LINE for r in range ( 0 , 2 ) : NEW_LINE INDENT sum = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE if ( ( i + r ) % 2 ) : NEW_LINE INDENT if ( sum <= 0 ) : NEW_LINE INDENT ans += - sum + 1 NEW_LINE sum = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( sum >= 0 ) : NEW_LINE INDENT ans += sum + 1 NEW_LINE sum = - 1 NEW_LINE DEDENT DEDENT DEDENT res = min ( res , ans ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def maxOperations ( S , N ) : NEW_LINE INDENT X = 0 NEW_LINE Y = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT break NEW_LINE DEDENT Y += 1 NEW_LINE DEDENT i = N - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( S [ i ] == '1' ) : NEW_LINE INDENT break NEW_LINE DEDENT X += 1 NEW_LINE DEDENT if ( N == X + Y ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return N - ( X + Y ) - 1 NEW_LINE DEDENT
def maximumSum ( S , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE freq = [ 0 ] * 256 NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq [ ord ( S [ i ] ) ] += 1 NEW_LINE DEDENT freq = sorted ( freq ) [ : : - 1 ] NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT if ( K > freq [ i ] ) : NEW_LINE INDENT sum += freq [ i ] * freq [ i ] NEW_LINE K -= freq [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += freq [ i ] * K NEW_LINE break NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def possibleNumbers ( numbers , N , M , A , B ) : NEW_LINE INDENT if ( M == 0 ) : NEW_LINE INDENT numbers . add ( N ) NEW_LINE return NEW_LINE DEDENT possibleNumbers ( numbers , N + A , M - 1 , A , B ) NEW_LINE possibleNumbers ( numbers , N + B , M - 1 , A , B ) NEW_LINE DEDENT
def possibleNumbers ( N , M , A , B ) : NEW_LINE INDENT if ( A > B ) : NEW_LINE INDENT temp = A NEW_LINE A = B NEW_LINE B = temp NEW_LINE DEDENT number = N + M * A NEW_LINE print ( number , end = " " ) NEW_LINE if ( A != B ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT number = number - A + B NEW_LINE print ( number , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE max_neg = sys . maxsize NEW_LINE tempsum = 0 NEW_LINE small = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE small = min ( small , arr [ i ] ) NEW_LINE if ( arr [ i ] > 0 ) : NEW_LINE INDENT tempsum = 0 NEW_LINE DEDENT else : NEW_LINE INDENT tempsum += arr [ i ] NEW_LINE DEDENT max_neg = min ( max_neg , tempsum ) NEW_LINE DEDENT if ( max_neg == 0 ) : NEW_LINE INDENT max_neg = small NEW_LINE DEDENT print ( sum - max_neg ) NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT
def findVertices ( n ) : NEW_LINE INDENT return fib ( n + 2 ) NEW_LINE DEDENT
def MaxBuildingsCovered ( arr , N , L ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE start = 0 NEW_LINE curr_count = 0 NEW_LINE max_count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr_sum = curr_sum + ( arr [ i ] * Pi ) NEW_LINE if ( i != 0 ) : NEW_LINE INDENT curr_sum += 1 NEW_LINE DEDENT if ( curr_sum <= L ) : NEW_LINE INDENT curr_count += 1 NEW_LINE DEDENT elif ( curr_sum > L ) : NEW_LINE INDENT curr_sum = curr_sum - ( arr [ start ] * Pi ) NEW_LINE curr_sum -= 1 NEW_LINE start += 1 NEW_LINE curr_count -= 1 NEW_LINE DEDENT max_count = max ( curr_count , max_count ) NEW_LINE DEDENT return max_count NEW_LINE DEDENT
def num_candyTypes ( candies ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( len ( candies ) ) : NEW_LINE INDENT s . add ( candies [ i ] ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT
def distribute_candies ( candies ) : NEW_LINE INDENT allowed = len ( candies ) / 2 NEW_LINE types = num_candyTypes ( candies ) NEW_LINE if ( types < allowed ) : NEW_LINE INDENT print ( int ( types ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( allowed ) ) NEW_LINE DEDENT DEDENT
def countUnsetBits ( N ) : NEW_LINE INDENT c = 0 NEW_LINE while ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT N = N >> 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
def countBitwiseZero ( N ) : NEW_LINE INDENT unsetBits = countUnsetBits ( N ) NEW_LINE print ( ( 1 << unsetBits ) ) NEW_LINE DEDENT
def isPossible ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count_0 , count_1 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT if ( count_1 > count_0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( count_0 != ( 2 * count_1 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT count_0 , count_1 = 0 , 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT if ( count_1 > count_0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def minimumOperation ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE i = 0 NEW_LINE minoperation = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( a [ i ] == b [ i ] ) : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT elif ( a [ i ] == b [ i + 1 ] and a [ i + 1 ] == b [ i ] and i < n - 1 ) : NEW_LINE INDENT minoperation += 1 NEW_LINE i = i + 2 NEW_LINE DEDENT elif ( a [ i ] != b [ i ] ) : NEW_LINE INDENT minoperation += 1 NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( minoperation ) NEW_LINE DEDENT
def leastBricks ( wall ) : NEW_LINE INDENT map = defaultdict ( int ) NEW_LINE res = 0 NEW_LINE for list in wall : NEW_LINE INDENT width = 0 NEW_LINE for i in range ( len ( list ) - 1 ) : NEW_LINE INDENT width += list [ i ] NEW_LINE map [ width ] += 1 NEW_LINE res = max ( res , map [ width ] ) NEW_LINE DEDENT DEDENT print ( len ( wall ) - res ) NEW_LINE DEDENT
def minimumProdArray ( a , b , l ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT total += a [ i ] * b [ i ] NEW_LINE DEDENT Min = 2147483647 NEW_LINE first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT left = i - 1 NEW_LINE right = i + 1 NEW_LINE total1 = total NEW_LINE while ( left >= 0 and right < len ( a ) ) : NEW_LINE INDENT total1 -= a [ left ] * b [ left ] + a [ right ] * b [ right ] NEW_LINE total1 += a [ left ] * b [ right ] + a [ right ] * b [ left ] NEW_LINE if ( Min >= total1 ) : NEW_LINE INDENT Min = total1 NEW_LINE first = left NEW_LINE second = right NEW_LINE DEDENT left -= 1 NEW_LINE right += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( a ) ) : NEW_LINE INDENT left = i NEW_LINE right = i + 1 NEW_LINE total1 = total NEW_LINE while ( left >= 0 and right < len ( a ) ) : NEW_LINE INDENT total1 -= a [ left ] * b [ left ] + a [ right ] * b [ right ] NEW_LINE total1 += a [ left ] * b [ right ] + a [ right ] * b [ left ] NEW_LINE if ( Min >= total1 ) : NEW_LINE INDENT Min = total1 NEW_LINE first = left NEW_LINE second = right NEW_LINE DEDENT left -= 1 NEW_LINE right += 1 NEW_LINE DEDENT DEDENT if ( Min < total ) : NEW_LINE INDENT reverse ( first , second , a ) NEW_LINE Print ( a , b ) NEW_LINE DEDENT else : NEW_LINE INDENT Print ( a , b ) NEW_LINE DEDENT DEDENT
def numberOfWays ( N , X , Y ) : NEW_LINE INDENT S1 = ( N - 1 ) * X + Y NEW_LINE S2 = ( N - 1 ) * Y + X NEW_LINE return ( S2 - S1 + 1 ) NEW_LINE DEDENT
def countPermutations ( N ) : NEW_LINE INDENT adj = [ [ ] for i in range ( 105 ) ] NEW_LINE indeg = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT sum = i + j NEW_LINE if ( ceil ( sqrt ( sum ) ) == floor ( sqrt ( sum ) ) ) : NEW_LINE INDENT adj [ i ] . append ( j ) NEW_LINE DEDENT DEDENT if ( len ( adj [ i ] ) == 1 ) : NEW_LINE INDENT indeg += 1 NEW_LINE DEDENT DEDENT if ( indeg == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT elif ( indeg <= 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def reduceToOne ( N ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( N != 1 ) : NEW_LINE INDENT if ( N == 2 or ( N % 2 == 1 ) ) : NEW_LINE INDENT N = N - 1 NEW_LINE cnt += 1 NEW_LINE DEDENT elif ( N % 2 == 0 ) : NEW_LINE INDENT N = N / ( N / 2 ) NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def getDate ( d , m ) : NEW_LINE INDENT days = [ 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE month = [ 'January' , 'February' , 'March' , 'April' , 'May' , 'June' , 'July' , 'August' , 'September' , 'October' , 'November' , 'December' ] NEW_LINE cnt = 183 NEW_LINE cur_month = month . index ( m ) NEW_LINE cur_date = d NEW_LINE while ( 1 ) : NEW_LINE INDENT while ( cnt > 0 and cur_date <= days [ cur_month ] ) : NEW_LINE INDENT cnt -= 1 NEW_LINE cur_date += 1 NEW_LINE DEDENT if ( cnt == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT cur_month = ( cur_month + 1 ) % 12 NEW_LINE cur_date = 1 NEW_LINE DEDENT print ( cur_date , month [ cur_month ] ) NEW_LINE DEDENT
def maxDiamonds ( A , N , K ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT pq . append ( A [ i ] ) NEW_LINE DEDENT pq . sort ( ) NEW_LINE ans = 0 NEW_LINE while ( len ( pq ) > 0 and K > 0 ) : NEW_LINE INDENT pq . sort ( ) NEW_LINE top = pq [ len ( pq ) - 1 ] NEW_LINE pq = pq [ 0 : len ( pq ) - 1 ] NEW_LINE ans += top NEW_LINE top = top // 2 NEW_LINE pq . append ( top ) NEW_LINE K -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def findMaximumProfit ( arr , M , N ) : NEW_LINE INDENT max_heap = [ ] NEW_LINE maxProfit = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT max_heap . append ( arr [ i ] ) NEW_LINE DEDENT max_heap . sort ( ) NEW_LINE max_heap . reverse ( ) NEW_LINE while ( M > 0 ) : NEW_LINE INDENT M -= 1 NEW_LINE X = max_heap [ 0 ] NEW_LINE max_heap . pop ( 0 ) NEW_LINE maxProfit += X NEW_LINE max_heap . append ( X - 1 ) NEW_LINE max_heap . sort ( ) NEW_LINE max_heap . reverse ( ) NEW_LINE DEDENT print ( maxProfit ) NEW_LINE DEDENT
def largestNumber ( N ) : NEW_LINE INDENT if ( N > 45 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT num = 0 NEW_LINE digit = 9 NEW_LINE while ( N > 0 and digit > 0 ) : NEW_LINE INDENT if ( digit <= N ) : NEW_LINE INDENT num *= 10 NEW_LINE num += digit NEW_LINE N -= digit NEW_LINE DEDENT digit -= 1 NEW_LINE DEDENT return num * 10 NEW_LINE DEDENT
def minimumSum ( A , N , S ) : NEW_LINE INDENT mul = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if ( S [ i ] == "*" ) : NEW_LINE INDENT mul += 1 NEW_LINE DEDENT DEDENT ans = 1000000 NEW_LINE for i in range ( 1 << ( N - 1 ) ) : NEW_LINE INDENT cnt = 0 NEW_LINE v = [ ] NEW_LINE for j in range ( N - 1 ) : NEW_LINE INDENT if ( ( 1 << j ) & i ) : NEW_LINE INDENT cnt += 1 NEW_LINE v . append ( "*" ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( "+" ) NEW_LINE DEDENT DEDENT if ( cnt == mul ) : NEW_LINE INDENT d = [ ] NEW_LINE d . append ( A [ 0 ] ) NEW_LINE for j in range ( N - 1 ) : NEW_LINE INDENT if ( v [ j ] == "*" ) : NEW_LINE INDENT x = d [ len ( d ) - 1 ] NEW_LINE d . pop ( ) NEW_LINE x = x * A [ j + 1 ] NEW_LINE d . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT d . append ( A [ j + 1 ] ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE while ( len ( d ) > 0 ) : NEW_LINE INDENT x = d [ 0 ] NEW_LINE sum += x NEW_LINE d . pop ( 0 ) NEW_LINE DEDENT ans = min ( ans , sum ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def MinimumOperations ( A , N , K ) : NEW_LINE INDENT Count = 0 NEW_LINE i = 0 NEW_LINE while ( i < N - 1 ) : NEW_LINE INDENT i = i + K - 1 NEW_LINE Count += 1 NEW_LINE DEDENT return Count NEW_LINE DEDENT
def findSequence ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE sumPos = 0 NEW_LINE sumNeg = 0 NEW_LINE for i in range ( 0 , n - k ) : NEW_LINE INDENT arr [ i ] = - ( i + 1 ) NEW_LINE sumNeg += arr [ i ] NEW_LINE DEDENT for i in range ( n - k , n ) : NEW_LINE INDENT arr [ i ] = i + 1 NEW_LINE sumPos += arr [ i ] NEW_LINE DEDENT if ( abs ( sumNeg ) >= sumPos ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def sumOfMedians ( arr , N , K ) : NEW_LINE INDENT selectMedian = ( K + 1 ) // 2 NEW_LINE totalArrays = N // K NEW_LINE minSum = 0 NEW_LINE i = selectMedian - 1 NEW_LINE while ( i < N and totalArrays != 0 ) : NEW_LINE INDENT minSum = minSum + arr [ i ] NEW_LINE i = i + selectMedian NEW_LINE totalArrays -= 1 NEW_LINE DEDENT print ( minSum ) NEW_LINE DEDENT
def generateString ( K ) : NEW_LINE INDENT s = "" NEW_LINE for i in range ( 97 , 97 + K , 1 ) : NEW_LINE INDENT s = s + chr ( i ) NEW_LINE for j in range ( i + 1 , 97 + K , 1 ) : NEW_LINE INDENT s += chr ( i ) NEW_LINE s += chr ( j ) NEW_LINE DEDENT DEDENT s += chr ( 97 ) NEW_LINE print ( s ) NEW_LINE DEDENT
def countEqual ( A , B , N ) : NEW_LINE INDENT first = 0 NEW_LINE second = N - 1 NEW_LINE count = 0 NEW_LINE while ( first < N and second >= 0 ) : NEW_LINE INDENT if ( A [ first ] < B [ second ] ) : NEW_LINE INDENT first += 1 NEW_LINE DEDENT elif ( B [ second ] < A [ first ] ) : NEW_LINE INDENT second -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE first += 1 NEW_LINE second -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def minimumValue ( N , K ) : NEW_LINE INDENT return math . ceil ( K / N ) NEW_LINE DEDENT
def minSizeArr ( A , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT if ( K > sum ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT if ( K == sum ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( A [ i ] , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT tar = sum - K NEW_LINE um = { } NEW_LINE um [ 0 ] = - 1 NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE cur = 0 NEW_LINE maxi = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cur += A [ i ] NEW_LINE if ( ( cur - tar ) in um and ( i - um [ cur - tar ] ) > maxi ) : NEW_LINE INDENT maxi = i - um [ cur - tar ] NEW_LINE right = i NEW_LINE left = um [ cur - tar ] NEW_LINE DEDENT if ( cur not in um ) : NEW_LINE INDENT um [ cur ] = i NEW_LINE DEDENT DEDENT if ( maxi == - 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( left + 1 ) : NEW_LINE INDENT print ( A [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( right ) : NEW_LINE INDENT print ( A [ N - i - 1 ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def findPath ( arr , M , N ) : NEW_LINE INDENT for row in range ( M ) : NEW_LINE INDENT dir = 'L' NEW_LINE i = row NEW_LINE j = 0 NEW_LINE while ( j < N ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 1 ) : NEW_LINE INDENT if ( dir == 'L' ) : NEW_LINE INDENT i -= 1 NEW_LINE dir = 'D' NEW_LINE DEDENT elif ( dir == 'U' ) : NEW_LINE INDENT j -= 1 NEW_LINE dir = 'R' NEW_LINE DEDENT elif ( dir == 'R' ) : NEW_LINE INDENT i += 1 NEW_LINE dir = 'U' NEW_LINE DEDENT elif ( dir == 'D' ) : NEW_LINE INDENT j += 1 NEW_LINE dir = 'L' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( dir == 'L' ) : NEW_LINE INDENT i += 1 NEW_LINE dir = 'U' NEW_LINE DEDENT elif ( dir == 'U' ) : NEW_LINE INDENT j += 1 NEW_LINE dir = 'L' NEW_LINE DEDENT elif ( dir == 'R' ) : NEW_LINE INDENT i -= 1 NEW_LINE dir = 'D' NEW_LINE DEDENT elif ( dir == 'D' ) : NEW_LINE INDENT j -= 1 NEW_LINE dir = 'R' NEW_LINE DEDENT DEDENT if ( i < 0 or i == M or j < 0 or j == N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == N ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def getSum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in str ( n ) : NEW_LINE INDENT ans += int ( i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minModulo ( L , R , N ) : NEW_LINE INDENT if ( R - L < N ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT for j in range ( L , R + 1 ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) % N ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
def countNumbers ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT if ( N % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE if ( N // i != i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findEquation ( A , B , C , K ) : NEW_LINE INDENT print ( A , K * B , K * K * C ) NEW_LINE DEDENT
def calc ( a , b ) : NEW_LINE INDENT return a * b + ( b - a ) NEW_LINE DEDENT
def findMaximum ( arr , N ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE ans = - 10 ** 9 NEW_LINE ans = max ( ans , calc ( arr [ 0 ] , arr [ 1 ] ) ) NEW_LINE ans = max ( ans , calc ( arr [ N - 2 ] , arr [ N - 1 ] ) ) NEW_LINE return ans NEW_LINE DEDENT
def findMin ( arr , N , k ) : NEW_LINE INDENT pairs = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT pairs += arr [ i ] / 2 NEW_LINE DEDENT if ( k > pairs ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * k + N - 1 NEW_LINE DEDENT DEDENT
def minOperations ( arr , n ) : NEW_LINE INDENT oddcount , evencount = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT oddcount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT evencount += 1 NEW_LINE DEDENT DEDENT return min ( oddcount , evencount ) NEW_LINE DEDENT
def minimumFlips ( A , B , C ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT x , y , z = 0 , 0 , 0 NEW_LINE if ( A & ( 1 << i ) ) : NEW_LINE INDENT x = 1 NEW_LINE DEDENT if ( B & ( 1 << i ) ) : NEW_LINE INDENT y = 1 NEW_LINE DEDENT if ( C & ( 1 << i ) ) : NEW_LINE INDENT z = 1 NEW_LINE DEDENT if ( z == 0 ) : NEW_LINE INDENT if ( x ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( y ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT if ( z == 1 ) : NEW_LINE INDENT if ( x == 0 and y == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def countDistinctNumbers ( A , B , C ) : NEW_LINE INDENT g = gcd ( A , B ) NEW_LINE count = C // g NEW_LINE print ( count ) NEW_LINE DEDENT
def printLastElement ( arr , N ) : NEW_LINE INDENT leftTurn = True NEW_LINE remainElements = N NEW_LINE step = 1 NEW_LINE head = 1 NEW_LINE while ( remainElements > 1 ) : NEW_LINE INDENT if ( leftTurn ) : NEW_LINE INDENT head = head + step NEW_LINE DEDENT else : NEW_LINE INDENT if ( remainElements % 2 == 1 ) : NEW_LINE INDENT head = head + step NEW_LINE DEDENT DEDENT remainElements = remainElements // 2 NEW_LINE step = step * 2 NEW_LINE leftTurn = not leftTurn NEW_LINE DEDENT print ( arr [ head - 1 ] ) NEW_LINE DEDENT
def findPrefixCount ( arr , size ) : NEW_LINE INDENT for i in range ( 32 ) : NEW_LINE INDENT prefixCount [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) NEW_LINE for j in range ( 1 , size ) : NEW_LINE INDENT prefixCount [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) NEW_LINE prefixCount [ i ] [ j ] += prefixCount [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT
def applyQuery ( currentVal , newVal , size ) : NEW_LINE INDENT for i in range ( 32 ) : NEW_LINE INDENT bit1 = ( ( currentVal >> i ) & 1 ) NEW_LINE bit2 = ( ( newVal >> i ) & 1 ) NEW_LINE if ( bit2 > 0 and bit1 == 0 ) : NEW_LINE INDENT prefixCount [ i ] [ size - 1 ] += 1 NEW_LINE DEDENT elif ( bit1 > 0 and bit2 == 0 ) : NEW_LINE INDENT prefixCount [ i ] [ size - 1 ] -= 1 NEW_LINE DEDENT DEDENT DEDENT
def shortestSubarray ( A , N ) : NEW_LINE INDENT i = 0 NEW_LINE left_index = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i ] + 1 != A [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT left_index = i NEW_LINE right_index = 0 NEW_LINE i = N - 1 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( A [ i ] != A [ i - 1 ] + 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT right_index = i NEW_LINE updated_right = 0 NEW_LINE minLength = min ( N - left_index - 1 , right_index ) NEW_LINE if ( A [ right_index ] <= A [ left_index ] + 1 ) : NEW_LINE INDENT updated_right = ( right_index + A [ left_index ] - A [ right_index ] + 1 ) NEW_LINE if ( updated_right < N ) : NEW_LINE INDENT minLength = min ( minLength , updated_right - left_index - 1 ) NEW_LINE DEDENT DEDENT print ( minLength ) NEW_LINE DEDENT
def freqCheck ( S , N ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( N ) : NEW_LINE INDENT hash [ ord ( S [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( hash [ i ] > 2 ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT DEDENT return "No" NEW_LINE DEDENT
def countTriplets ( N , K ) : NEW_LINE INDENT if ( K % 2 == 0 ) : NEW_LINE INDENT x = N // K NEW_LINE y = ( N + ( K // 2 ) ) // K NEW_LINE return x * x * x + y * y * y NEW_LINE DEDENT else : NEW_LINE INDENT x = N // K NEW_LINE return x * x * x NEW_LINE DEDENT DEDENT
def minLength ( s ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( s ) - 1 NEW_LINE while ( i < j and s [ i ] == s [ j ] ) : NEW_LINE INDENT d = s [ i ] NEW_LINE while ( i <= j and s [ i ] == d ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( i <= j and s [ j ] == d ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return j - i + 1 NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT mod = 1000000007 NEW_LINE res = 1 NEW_LINE x = x % mod NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % mod NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT
def CountBST ( H ) : NEW_LINE INDENT return power ( 2 , H ) NEW_LINE DEDENT
def canBeEmptied ( A , B ) : NEW_LINE INDENT if ( max ( A , B ) > 2 * min ( A , B ) ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT if ( ( A + B ) % 3 == 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def Check ( A , B , M , N , X ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N - X + 1 ) : NEW_LINE INDENT if ( A [ i ] [ j ] != B [ i ] [ j ] ) : NEW_LINE INDENT diff = B [ i ] [ j ] - A [ i ] [ j ] NEW_LINE for k in range ( X ) : NEW_LINE INDENT A [ i ] [ j + k ] = A [ i ] [ j + k ] + diff NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( M - X + 1 ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( A [ i ] [ j ] != B [ i ] [ j ] ) : NEW_LINE INDENT diff = B [ i ] [ j ] - A [ i ] [ j ] NEW_LINE for k in range ( X ) : NEW_LINE INDENT A [ i + k ] [ j ] = A [ i + k ] [ j ] + diff NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( A [ i ] [ j ] != B [ i ] [ j ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 1 NEW_LINE DEDENT
def check ( X , Y ) : NEW_LINE INDENT if ( X > 3 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT elif ( X == 1 and Y == 1 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT elif ( X == 2 and Y <= 3 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT elif ( X == 3 and Y <= 3 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , ( n // 2 ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def precompute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 , 1 ) : NEW_LINE INDENT if ( isPalindrome ( i ) ) : NEW_LINE INDENT sum = sumOfDigits ( i ) NEW_LINE if ( isPrime ( sum ) ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , 100001 , 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] + arr [ i - 1 ] NEW_LINE DEDENT DEDENT
def minimumOperations ( A , K ) : NEW_LINE INDENT isflipped = [ 0 ] * ( len ( A ) + 1 ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT isflipped [ i ] += isflipped [ i - 1 ] NEW_LINE isflipped [ i ] %= 2 NEW_LINE DEDENT if ( A [ i ] == 0 and not isflipped [ i ] ) : NEW_LINE INDENT if ( ( len ( A ) - i + 1 ) <= K ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT ans += 1 NEW_LINE isflipped [ i ] += 1 NEW_LINE isflipped [ i + K ] -= 1 NEW_LINE DEDENT elif ( A [ i ] == 1 and isflipped [ i ] ) : NEW_LINE INDENT if ( ( len ( A ) - i + 1 ) <= K ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT ans += 1 NEW_LINE isflipped [ i ] += 1 NEW_LINE isflipped [ i + K ] -= 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def findScoreSum ( n ) : NEW_LINE INDENT total = 0 NEW_LINE prev_monday , curr_day = 0 , 0 NEW_LINE for day in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( day % 7 == 1 ) : NEW_LINE INDENT prev_monday += 1 NEW_LINE curr_day = prev_monday NEW_LINE DEDENT total += curr_day NEW_LINE curr_day += 1 NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT
def findScoreSum ( n ) : NEW_LINE INDENT F = n // 7 NEW_LINE D = n % 7 NEW_LINE fullWeekScore = ( 49 + 7 * F ) * F // 2 NEW_LINE lastNonFullWeekScore = ( 2 * F + D + 1 ) * D // 2 NEW_LINE print ( fullWeekScore + lastNonFullWeekScore ) NEW_LINE DEDENT
def evenXorSubarray ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT XOR = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT XOR = XOR ^ arr [ j ] NEW_LINE if ( ( XOR & 1 ) == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def evenXorSubarray ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE freq = [ 0 ] * n NEW_LINE XOR = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT XOR = XOR ^ arr [ i ] NEW_LINE if ( XOR % 2 == 0 ) : NEW_LINE INDENT ans += freq [ 0 ] + 1 NEW_LINE freq [ 0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += freq [ 1 ] NEW_LINE freq [ 1 ] += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def getArea ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2 ) NEW_LINE DEDENT
def isInside ( triangle , point ) : NEW_LINE INDENT A , B , C = triangle NEW_LINE x , y = point NEW_LINE ABC = getArea ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] , C [ 0 ] , C [ 1 ] ) NEW_LINE BPC = getArea ( x , y , B [ 0 ] , B [ 1 ] , C [ 0 ] , C [ 1 ] ) NEW_LINE APC = getArea ( A [ 0 ] , A [ 1 ] , x , y , C [ 0 ] , C [ 1 ] ) NEW_LINE APB = getArea ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] , x , y ) NEW_LINE return ABC == ( APC + APB + BPC ) NEW_LINE DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if not b : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT
def GCDArr ( a ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in a : NEW_LINE INDENT ans = GCD ( ans , i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findSubseqUtil ( a , b , ans , k , i ) : NEW_LINE INDENT if len ( ans ) == len ( a ) : NEW_LINE INDENT if GCDArr ( ans ) == k : NEW_LINE INDENT print ( ans ) NEW_LINE return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT ans . append ( a [ i ] ) NEW_LINE temp = findSubseqUtil ( a , b , ans , k , i + 1 ) NEW_LINE if temp == True : NEW_LINE INDENT return True NEW_LINE DEDENT ans . pop ( ) NEW_LINE ans . append ( b [ i ] ) NEW_LINE temp = findSubseqUtil ( a , b , ans , k , i + 1 ) NEW_LINE if temp == True : NEW_LINE INDENT return True NEW_LINE DEDENT ans . pop ( ) NEW_LINE DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if not b : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT
def GCDArr ( a ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in a : NEW_LINE INDENT ans = GCD ( ans , i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findString ( S , N ) : NEW_LINE INDENT strLen = 4 * N NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT S [ strLen - 1 ] = '1' NEW_LINE strLen -= 2 NEW_LINE DEDENT for i in range ( 4 * N ) : NEW_LINE INDENT print ( S [ i ] , end = "" ) NEW_LINE DEDENT DEDENT
def minimumOperations ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( A [ i ] != ( i + 1 ) ) : NEW_LINE INDENT if ( ( ( i - 1 ) >= 0 ) and A [ i - 1 ] == ( i + 1 ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE A [ i ] , A [ i - 1 ] = A [ i - 1 ] , A [ i ] NEW_LINE DEDENT elif ( ( ( i - 2 ) >= 0 ) and A [ i - 2 ] == ( i + 1 ) ) : NEW_LINE INDENT cnt += 2 NEW_LINE A [ i - 2 ] = A [ i - 1 ] NEW_LINE A [ i - 1 ] = A [ i ] NEW_LINE A [ i ] = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( cnt ) NEW_LINE DEDENT
def countOccurrences ( n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT if ( x // i <= n ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def countOccurrences ( N , X ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( X ) ) + 1 ) : NEW_LINE INDENT if X % i == 0 : NEW_LINE INDENT a = i NEW_LINE b = X // i NEW_LINE if a <= N and b <= N : NEW_LINE INDENT if a == b : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countOfPrimefactors ( CountDistinct ) : NEW_LINE INDENT global MAX NEW_LINE prime = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( MAX + 1 ) : NEW_LINE INDENT CountDistinct [ i ] = 0 NEW_LINE prime [ i ] = True NEW_LINE DEDENT for i in range ( 2 , MAX + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT CountDistinct [ i ] = 1 NEW_LINE for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT CountDistinct [ j ] += 1 NEW_LINE prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def CountEvenPair ( A , B , N , M ) : NEW_LINE INDENT global MAX NEW_LINE countDistinct = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE countOfPrimefactors ( countDistinct ) NEW_LINE evenCount = 0 NEW_LINE oddCount = 0 NEW_LINE evenPairs = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if ( countDistinct [ B [ i ] ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( countDistinct [ B [ i ] ] & 1 ) : NEW_LINE INDENT oddCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT evenCount += 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( countDistinct [ A [ i ] ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( countDistinct [ A [ i ] ] & 1 ) : NEW_LINE INDENT evenPairs += ( evenCount ) NEW_LINE DEDENT else : NEW_LINE INDENT evenPairs += evenCount + oddCount NEW_LINE DEDENT DEDENT return evenPairs NEW_LINE DEDENT
def maxOccuringCharacter ( s ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT elif ( s [ i ] == '0' ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT prev = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT prev = i NEW_LINE DEDENT break NEW_LINE for i in range ( prev + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != 'X' ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count1 += i - prev - 1 NEW_LINE prev = i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT flag = True NEW_LINE for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ j ] == '1' ) : NEW_LINE INDENT flag = False NEW_LINE prev = j NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT i = prev NEW_LINE DEDENT else : NEW_LINE INDENT i = len ( s ) NEW_LINE DEDENT prev = - 1 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT prev = i NEW_LINE DEDENT break NEW_LINE for i in range ( prev + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != 'X' ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT count0 += i - prev - 1 NEW_LINE prev = i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT flag = True NEW_LINE for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ j ] == '0' ) : NEW_LINE INDENT prev = j NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT i = prev NEW_LINE DEDENT else : NEW_LINE INDENT i = len ( s ) NEW_LINE DEDENT if ( s [ 0 ] == 'X' ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while ( s [ i ] == 'X' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE if ( s [ i ] == '1' ) : NEW_LINE INDENT count1 += count NEW_LINE DEDENT if ( s [ ( len ( s ) - 1 ) ] == 'X' ) : NEW_LINE INDENT count = 0 NEW_LINE i = len ( s ) - 1 NEW_LINE while ( s [ i ] == 'X' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i -= 1 NEW_LINE if ( s [ i ] == '0' ) : NEW_LINE INDENT count0 += count NEW_LINE DEDENT if ( count0 == count1 ) : NEW_LINE INDENT print ( "X" ) NEW_LINE DEDENT elif ( count0 > count1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
def minRequiredOperation ( arr , N , K ) : NEW_LINE INDENT TotalSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT TotalSum += arr [ i ] NEW_LINE DEDENT maxLen = longestSubarray ( arr , N , TotalSum - K ) NEW_LINE if ( maxLen == - 1 ) : NEW_LINE INDENT print ( - 1 , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N - maxLen , end = "" ) NEW_LINE DEDENT DEDENT
def minimumDeletions ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT t = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( t % 2 == 0 ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT num = ( ord ( s [ j ] ) - ord ( '0' ) ) * 10 + t NEW_LINE if ( num % 4 == 0 ) : NEW_LINE INDENT k1 = i - j - 1 NEW_LINE k2 = n - i - 1 NEW_LINE ans = min ( ans , k1 + k2 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( ans == n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT num = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( num % 4 == 0 ) : NEW_LINE INDENT ans = n - 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def isVowel ( ch ) : NEW_LINE INDENT if ( ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ch == 'A' or ch == 'E' or ch == 'I' or ch == 'O' or ch == 'U' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def winner ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT print ( "A" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "B" ) NEW_LINE DEDENT DEDENT
def LCMPairs ( arr , N ) : NEW_LINE INDENT total_pairs = ( N * ( N - 1 ) ) / 2 NEW_LINE odd = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT odd = ( odd * ( odd - 1 ) ) // 2 NEW_LINE print ( "Even =" , int ( total_pairs - odd ) , "," , " Odd =" , odd ) NEW_LINE DEDENT
def getMaxSum ( A , M , N ) : NEW_LINE INDENT sum = 0 NEW_LINE negative = 0 NEW_LINE minVal = sys . maxsize NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT sum += abs ( A [ i ] [ j ] ) NEW_LINE if ( A [ i ] [ j ] < 0 ) : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT minVal = min ( minVal , abs ( A [ i ] [ j ] ) ) NEW_LINE DEDENT DEDENT if ( negative % 2 ) : NEW_LINE INDENT sum -= 2 * minVal NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def printNumber ( N , K , M ) : NEW_LINE INDENT sum = K * ( M * ( M + 1 ) / 2 ) NEW_LINE return sum - N NEW_LINE DEDENT
def countEvenOdd ( L , R ) : NEW_LINE INDENT range = R - L + 1 NEW_LINE even = ( range // 4 ) * 2 NEW_LINE if ( ( L & 1 ) != 0 and ( range % 4 == 3 ) ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT elif ( ( L & 1 ) == 0 and ( range % 4 != 0 ) ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT print ( "Even = " , even , ", Odd = " , ( range - even ) ) NEW_LINE DEDENT
def findPerfectIndex ( N , K ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT print ( ( N - K + 1 ) + i , end = " " ) NEW_LINE DEDENT for i in range ( 3 , N ) : NEW_LINE INDENT print ( i - K + 1 , end = " " ) NEW_LINE DEDENT DEDENT
def isPrime ( N ) : NEW_LINE INDENT if ( N <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( math . sqrt ( N ) + 1 ) ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countPrimeTuples ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( isPrime ( i ) and isPrime ( i - 2 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def countPairs ( A , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( A [ i ] A [ j ] ) > ( A [ i ] & A [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def checkArrays ( arr1 , arr2 , N ) : NEW_LINE INDENT count = 0 NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT if ( arr1 [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE if ( count < 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( flag and count == 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def construct_Array ( N , K ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( K * i , end = " " ) NEW_LINE DEDENT DEDENT
def maxSumOfDistinctPrimeFactors ( arr , N , K ) : NEW_LINE INDENT CountDistinct = [ 0 ] * ( MAX + 1 ) NEW_LINE prime = [ False ] * ( MAX + 1 ) NEW_LINE for i in range ( MAX + 1 ) : NEW_LINE INDENT CountDistinct [ i ] = 0 NEW_LINE prime [ i ] = True NEW_LINE DEDENT for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT CountDistinct [ i ] = 1 NEW_LINE for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT CountDistinct [ j ] += 1 NEW_LINE prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE PrimeFactor = [ 0 ] * 20 NEW_LINE for i in range ( N ) : NEW_LINE INDENT PrimeFactor [ CountDistinct [ arr [ i ] ] ] += 1 NEW_LINE DEDENT for i in range ( 19 , 0 , - 1 ) : NEW_LINE INDENT while ( PrimeFactor [ i ] > 0 ) : NEW_LINE INDENT sum += i NEW_LINE PrimeFactor [ i ] -= 1 NEW_LINE K -= 1 NEW_LINE if ( K == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( K == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE DEDENT
def Print ( N ) : NEW_LINE INDENT if ( ( N / 2 ) % 2 or ( N % 2 ) ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT CurEven = 2 NEW_LINE CurOdd = 1 NEW_LINE SumOdd = 0 NEW_LINE SumEven = 0 NEW_LINE for i in range ( N // 2 ) : NEW_LINE INDENT print ( CurEven , end = " " ) NEW_LINE SumEven += CurEven NEW_LINE CurEven += 2 NEW_LINE DEDENT for i in range ( ( N // 2 ) - 1 ) : NEW_LINE INDENT print ( CurOdd , end = " " ) NEW_LINE SumOdd += CurOdd NEW_LINE CurOdd += 2 NEW_LINE DEDENT CurOdd = SumEven - SumOdd NEW_LINE print ( CurOdd ) NEW_LINE DEDENT
def minimize ( n ) : NEW_LINE INDENT optEle = n NEW_LINE strEle = str ( n ) NEW_LINE for idx in range ( len ( strEle ) ) : NEW_LINE INDENT temp = int ( strEle [ idx : ] + strEle [ : idx ] ) NEW_LINE optEle = min ( optEle , temp ) NEW_LINE DEDENT return optEle NEW_LINE DEDENT
def maximize ( n ) : NEW_LINE INDENT optEle = n NEW_LINE strEle = str ( n ) NEW_LINE for idx in range ( len ( strEle ) ) : NEW_LINE INDENT temp = int ( strEle [ idx : ] + strEle [ : idx ] ) NEW_LINE optEle = max ( optEle , temp ) NEW_LINE DEDENT return optEle NEW_LINE DEDENT
def minOperations ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT res = arr [ i ] NEW_LINE while ( res ) : NEW_LINE INDENT if res in mp : NEW_LINE INDENT mp [ res ] += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT mp [ res ] = 1 NEW_LINE DEDENT res //= 2 NEW_LINE mx = 1 NEW_LINE for it in mp : NEW_LINE INDENT if ( mp [ it ] == N ) : NEW_LINE INDENT mx = it NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT res = arr [ i ] NEW_LINE while ( res != mx ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT res //= 2 NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def MinimumMoves ( A , B , N ) : NEW_LINE INDENT totalOperations = 0 NEW_LINE carry = 0 NEW_LINE K = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT nearestMultiple = ceil ( ( A [ i ] + carry ) / B [ i ] ) * B [ i ] NEW_LINE K = nearestMultiple - ( A [ i ] + carry ) NEW_LINE totalOperations += K NEW_LINE carry += K NEW_LINE DEDENT return totalOperations NEW_LINE DEDENT
def maxSheets ( A , B ) : NEW_LINE INDENT area = A * B NEW_LINE count = 1 NEW_LINE while ( area % 2 == 0 ) : NEW_LINE INDENT area //= 2 NEW_LINE count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
def minimumDeviation ( A , N ) : NEW_LINE INDENT s = set ( [ ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT s . add ( A [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( 2 * A [ i ] ) NEW_LINE DEDENT DEDENT s = list ( s ) NEW_LINE diff = s [ - 1 ] - s [ 0 ] NEW_LINE while ( len ( s ) and s [ - 1 ] % 2 == 0 ) : NEW_LINE INDENT maxEl = s [ - 1 ] NEW_LINE s . remove ( maxEl ) NEW_LINE s . append ( maxEl // 2 ) NEW_LINE diff = min ( diff , s [ - 1 ] - s [ 0 ] ) NEW_LINE DEDENT print ( diff ) NEW_LINE DEDENT
def findMaxNum ( num ) : NEW_LINE INDENT binaryNumber = bin ( num ) [ 2 : ] NEW_LINE maxBinaryNumber = "" NEW_LINE count0 , count1 = 0 , 0 NEW_LINE N = len ( binaryNumber ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( binaryNumber [ i ] == '1' ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT DEDENT for i in range ( count1 ) : NEW_LINE INDENT maxBinaryNumber += '1' NEW_LINE DEDENT for i in range ( count0 ) : NEW_LINE INDENT maxBinaryNumber += '0' NEW_LINE DEDENT return int ( maxBinaryNumber , 2 ) NEW_LINE DEDENT
def findMinMoves ( a , b ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( a == b or abs ( a - b ) == 1 ) : NEW_LINE INDENT ans = a + b NEW_LINE DEDENT else : NEW_LINE INDENT k = min ( a , b ) NEW_LINE j = max ( a , b ) NEW_LINE ans = 2 * k + 2 * ( j - k ) - 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def FindwinnerOfGame ( S ) : NEW_LINE INDENT cntZero = 0 NEW_LINE cntConOne = 0 NEW_LINE nimSum = 0 NEW_LINE N = len ( S ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == '1' ) : NEW_LINE INDENT cntConOne += 1 NEW_LINE DEDENT else : NEW_LINE INDENT nimSum ^= cntConOne NEW_LINE cntConOne = 0 NEW_LINE cntZero += 1 NEW_LINE DEDENT DEDENT nimSum ^= cntConOne NEW_LINE if ( cntZero % 2 == 0 ) : NEW_LINE INDENT print ( "Tie" ) NEW_LINE DEDENT elif ( nimSum ) : NEW_LINE INDENT print ( "player 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "player 2" ) NEW_LINE DEDENT DEDENT
def check ( current_row , current_col , destination_row , destination_col ) : NEW_LINE INDENT if ( current_row == destination_row ) : NEW_LINE INDENT return ( "POSSIBLE" ) NEW_LINE DEDENT elif ( current_col == destination_col ) : NEW_LINE INDENT return ( "POSSIBLE" ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( "NOT POSSIBLE" ) NEW_LINE DEDENT DEDENT
def maxChange ( str ) : NEW_LINE INDENT str = [ i for i in str ] NEW_LINE DEDENT
def generatepermutation ( N ) : NEW_LINE INDENT answer = [ ] NEW_LINE answer . append ( N ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT answer . append ( i ) NEW_LINE DEDENT print ( * answer ) NEW_LINE DEDENT
def maxNumPalindrome ( S ) : NEW_LINE INDENT i = 0 NEW_LINE freq = [ 0 ] * 26 NEW_LINE freqPair = 0 NEW_LINE ln = len ( S ) // 3 NEW_LINE while ( i < len ( S ) ) : NEW_LINE INDENT freq [ ord ( S [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT freqPair += ( freq [ i ] // 2 ) NEW_LINE DEDENT return min ( freqPair , ln ) NEW_LINE DEDENT
def cntEvenSumPairs ( X , Y ) : NEW_LINE INDENT cntXEvenNums = X / 2 NEW_LINE cntXOddNums = ( X + 1 ) / 2 NEW_LINE cntYEvenNums = Y / 2 NEW_LINE cntYOddNums = ( Y + 1 ) / 2 NEW_LINE cntPairs = ( ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ) NEW_LINE return cntPairs NEW_LINE DEDENT
def farthestCellDistance ( N , M , R , C ) : NEW_LINE INDENT d1 = N + M - R - C NEW_LINE d2 = R + C - 2 NEW_LINE d3 = N - R + C - 1 NEW_LINE d4 = M - C + R - 1 NEW_LINE maxDistance = max ( d1 , max ( d2 , max ( d3 , d4 ) ) ) NEW_LINE print ( maxDistance ) NEW_LINE DEDENT
def maxSum ( arr , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT t = i NEW_LINE if ( t + arr [ i ] < N ) : NEW_LINE INDENT arr [ i ] += arr [ t + arr [ i ] ] NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def constructArray ( arr , N ) : NEW_LINE INDENT brr = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT K = int ( log ( arr [ i ] ) / log ( 2 ) ) NEW_LINE R = pow ( 2 , K ) NEW_LINE brr [ i ] = R NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( brr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def findMinKToMakeAllEqual ( N , A ) : NEW_LINE INDENT B = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT B [ A [ i ] ] = 1 NEW_LINE DEDENT M = len ( B ) NEW_LINE itr , i = list ( B . keys ( ) ) , 0 NEW_LINE if ( M > 3 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT elif ( M == 3 ) : NEW_LINE INDENT B_1 , i = itr [ i ] , i + 1 NEW_LINE B_2 , i = itr [ i ] , i + 1 NEW_LINE B_3 , i = itr [ i ] , i + 1 NEW_LINE if ( B_2 - B_1 == B_3 - B_2 ) : NEW_LINE INDENT print ( B_2 - B_1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT elif ( M == 2 ) : NEW_LINE INDENT B_1 , i = itr [ i ] , i + 1 NEW_LINE B_2 , i = itr [ i ] , i + 1 NEW_LINE if ( ( B_2 - B_1 ) % 2 == 0 ) : NEW_LINE INDENT print ( ( B_2 - B_1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( B_2 - B_1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
def minOpsToTurnArrToZero ( arr , N ) : NEW_LINE INDENT st = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i in st . keys ( ) or arr [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT st [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT print ( len ( st ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def splitArray ( arr , N ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT G = 0 NEW_LINE for i in mp : NEW_LINE INDENT G = gcd ( G , mp [ i ] ) NEW_LINE DEDENT if ( G > 1 ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def minMoves ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE if ( N <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = sys . maxsize NEW_LINE for i in range ( - 1 , 2 ) : NEW_LINE INDENT for j in range ( - 1 , 2 ) : NEW_LINE INDENT num1 = arr [ 0 ] + i NEW_LINE num2 = arr [ 1 ] + j NEW_LINE flag = 1 NEW_LINE moves = abs ( i ) + abs ( j ) NEW_LINE for idx in range ( 2 , N ) : NEW_LINE INDENT num = num1 + num2 NEW_LINE if ( abs ( arr [ idx ] - num ) > 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT moves += abs ( arr [ idx ] - num ) NEW_LINE DEDENT num1 = num2 NEW_LINE num2 = num NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT ans = min ( ans , moves ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == sys . maxsize ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def querySum ( arr , N , Q , M ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT x = Q [ i ] [ 0 ] NEW_LINE y = Q [ i ] [ 1 ] NEW_LINE sum = 0 NEW_LINE while ( x < N ) : NEW_LINE INDENT sum += arr [ x ] NEW_LINE x += y NEW_LINE DEDENT print ( sum , end = " " ) NEW_LINE DEDENT DEDENT
def CheckAllEqual ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ 0 ] != arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def minCntOperations ( arr , N ) : NEW_LINE INDENT Max = max ( arr ) NEW_LINE isPower2 = not ( Max and ( Max & ( Max - 1 ) ) ) NEW_LINE if ( isPower2 and CheckAllEqual ( arr , N ) ) : NEW_LINE INDENT return log2 ( Max ) NEW_LINE DEDENT else : NEW_LINE INDENT return math . ceil ( math . log2 ( Max ) ) + 1 NEW_LINE DEDENT DEDENT
def greatestReducedNumber ( num , s ) : NEW_LINE INDENT vis_s = [ False ] * 10 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT vis_s [ ( ord ) ( s [ i ] ) - 48 ] = True NEW_LINE DEDENT n = len ( num ) NEW_LINE In = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vis_s [ ord ( num [ i ] ) - ord ( '0' ) ] ) : NEW_LINE INDENT In = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( In == - 1 ) : NEW_LINE INDENT return num NEW_LINE DEDENT for dig in range ( ord ( num [ In ] ) , ord ( '0' ) - 1 , - 1 ) : NEW_LINE INDENT if ( vis_s [ dig - ord ( '0' ) ] == False ) : NEW_LINE INDENT num = num [ 0 : In ] + chr ( dig ) + num [ In + 1 : n - In - 1 ] NEW_LINE break NEW_LINE DEDENT DEDENT LargestDig = '0' NEW_LINE for dig in range ( ord ( '9' ) , ord ( '0' ) - 1 , - 1 ) : NEW_LINE INDENT if ( vis_s [ dig - ord ( '0' ) ] == False ) : NEW_LINE INDENT LargestDig = dig NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( In + 1 , n ) : NEW_LINE INDENT num = num [ 0 : i ] + chr ( LargestDig ) NEW_LINE DEDENT Count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( num [ i ] == '0' ) : NEW_LINE INDENT Count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT num = num [ Count : n ] NEW_LINE if ( int ( len ( num ) ) == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT return num NEW_LINE DEDENT
def minXOR ( Arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( Arr [ i ] == 2 ) : NEW_LINE INDENT print ( Arr [ i ] ^ 3 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( Arr [ i ] ^ 2 , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def findArray ( n ) : NEW_LINE INDENT Arr = [ 0 ] * ( n + 1 ) NEW_LINE Arr [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT Arr [ i ] = Arr [ i // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT Arr [ i ] = ( Arr [ ( i - 1 ) // 2 ] + Arr [ ( i - 1 ) // 2 + 1 ] ) NEW_LINE DEDENT DEDENT return Arr NEW_LINE DEDENT
def maxElement ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT Arr = findArray ( n ) NEW_LINE return max ( Arr ) NEW_LINE DEDENT
def findMaxValByRearrArr ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE res = ( N * ( N + 1 ) ) // 2 NEW_LINE return res NEW_LINE DEDENT
def min_steps_required ( n , m , r , c ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE corner_steps_req = INT_MAX NEW_LINE i = 1 NEW_LINE j = 1 NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) NEW_LINE i = n NEW_LINE j = 1 NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) NEW_LINE i = 1 NEW_LINE j = m NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) NEW_LINE i = n NEW_LINE j = m NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) NEW_LINE minimum_steps = min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) NEW_LINE return minimum_steps + corner_steps_req NEW_LINE DEDENT
def min_elements ( arr , N , K ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT Freq = [ ] NEW_LINE for it in mp : NEW_LINE INDENT i = it NEW_LINE Freq . append ( mp [ i ] ) NEW_LINE DEDENT Freq . sort ( ) NEW_LINE Freq . reverse ( ) NEW_LINE Len = len ( Freq ) NEW_LINE if ( Len <= K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT cntMin = 0 NEW_LINE for i in range ( K , Len ) : NEW_LINE INDENT cntMin += Freq [ i ] NEW_LINE DEDENT return cntMin NEW_LINE DEDENT
def sumzero ( arr , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT elif ( sum > 0 ) : NEW_LINE INDENT if ( sum % K == 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def cntOnesArrWithGivenOp ( arr , N ) : NEW_LINE INDENT cntOnes = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( i - 1 , N , i ) : NEW_LINE INDENT arr [ j ] = 1 if arr [ j ] == 0 else 0 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT cntOnes += 1 NEW_LINE DEDENT DEDENT return cntOnes NEW_LINE DEDENT
def cntOnesArrWithGivenOp ( arr , N ) : NEW_LINE INDENT cntOnes = 0 NEW_LINE cntOnes = int ( N ** ( 1 / 2 ) ) NEW_LINE return cntOnes NEW_LINE DEDENT
def minimumMoves ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE maxelement = - 1 NEW_LINE if ( N == 2 ) : NEW_LINE INDENT print ( 0 , end = "" ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE maxelement = max ( maxelement , arr [ i ] ) NEW_LINE DEDENT K = ( sum + N - 2 ) // ( N - 1 ) NEW_LINE K = max ( maxelement , K ) NEW_LINE ans = K * ( N - 1 ) - sum NEW_LINE print ( ans ) NEW_LINE DEDENT
def minimumSwaps ( arr1 , arr2 , n ) : NEW_LINE INDENT sumArr1 = 0 NEW_LINE sumArr2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sumArr1 += arr1 [ i ] NEW_LINE sumArr2 += arr2 [ i ] NEW_LINE DEDENT if ( sumArr1 % 2 == 0 and sumArr2 % 2 == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT if ( sumArr1 % 2 != 0 and sumArr2 % 2 != 0 ) : NEW_LINE INDENT flag = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr1 [ i ] + arr2 [ i ] ) % 2 == 1 ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( flag ) NEW_LINE return NEW_LINE DEDENT print ( - 1 ) NEW_LINE DEDENT
def corpFlightBookings ( Bookings , N ) : NEW_LINE INDENT res = [ 0 ] * N NEW_LINE for i in range ( len ( Bookings ) ) : NEW_LINE INDENT l = Bookings [ i ] [ 0 ] NEW_LINE r = Bookings [ i ] [ 1 ] NEW_LINE K = Bookings [ i ] [ 2 ] NEW_LINE res [ l - 1 ] = res [ l - 1 ] + K NEW_LINE if ( r <= len ( res ) - 1 ) : NEW_LINE INDENT res [ r ] = ( - K ) + res [ r ] NEW_LINE DEDENT DEDENT for i in range ( 1 , len ( res ) ) : NEW_LINE INDENT res [ i ] = res [ i ] + res [ i - 1 ] NEW_LINE DEDENT for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def findOddXOR ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( ( ( findXOR ( n ) ) ^ ( 2 * findXOR ( n // 2 ) ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ( findXOR ( n ) ) ^ ( 2 * findXOR ( ( n - 1 ) // 2 ) ) ) ) NEW_LINE DEDENT DEDENT
def findSmallestNumber ( n ) : NEW_LINE INDENT for i in range ( n , n + 2521 ) : NEW_LINE INDENT possible = 1 NEW_LINE temp = i NEW_LINE while ( temp ) : NEW_LINE INDENT if ( temp % 10 != 0 ) : NEW_LINE INDENT digit = temp % 10 NEW_LINE if ( i % digit != 0 ) : NEW_LINE INDENT possible = 0 NEW_LINE break NEW_LINE DEDENT DEDENT temp //= 10 NEW_LINE DEDENT if ( possible == 1 ) : NEW_LINE INDENT print ( i , end = "" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT
def path_to_root ( node ) : NEW_LINE INDENT while ( node >= 1 ) : NEW_LINE INDENT print ( node , end = " " ) NEW_LINE node //= 2 NEW_LINE DEDENT DEDENT
def minValue ( arr , n ) : NEW_LINE INDENT minimum = min ( arr ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( arr [ i ] - minimum ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def computeLPSArray ( pat , M , lps ) : NEW_LINE INDENT lenn = 0 NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while ( i < M ) : NEW_LINE INDENT if ( pat [ i ] == pat [ lenn ] ) : NEW_LINE INDENT lenn += 1 NEW_LINE lps [ i ] = lenn NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( lenn != 0 ) : NEW_LINE INDENT lenn = lps [ lenn - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def lastRemovedCharacter ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return ord ( str [ 0 ] ) NEW_LINE DEDENT if ( str [ n - 2 ] == '0' ) : NEW_LINE INDENT return ( ord ( '1' ) - ord ( str [ n - 1 ] ) + ord ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ord ( str [ n - 1 ] ) NEW_LINE DEDENT DEDENT
def findNumbers ( aXORb , aANDb , aXORc , aANDc , bXORc , bANDc ) : NEW_LINE INDENT a , b , c = 0 , 0 , 0 NEW_LINE aSUMb = 0 NEW_LINE aSUMc = 0 NEW_LINE bSUMc = 0 NEW_LINE aSUMb = aXORb + aANDb * 2 NEW_LINE aSUMc = aXORc + aANDc * 2 NEW_LINE bSUMc = bXORc + bANDc * 2 NEW_LINE a = ( aSUMb - bSUMc + aSUMc ) // 2 NEW_LINE b = aSUMb - a NEW_LINE c = aSUMc - a NEW_LINE print ( "a = " , a , end = "" ) NEW_LINE print ( ", b = " , b , end = "" ) NEW_LINE print ( ", c = " , c , end = "" ) NEW_LINE DEDENT
def findArray ( N , K ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( K , end = " " ) NEW_LINE return NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE print ( K , end = " " ) NEW_LINE return NEW_LINE DEDENT P = N - 2 NEW_LINE Q = N - 1 NEW_LINE VAL = 0 NEW_LINE for i in range ( 1 , N - 2 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE VAL ^= i NEW_LINE DEDENT if ( VAL == K ) : NEW_LINE INDENT print ( P , end = " " ) NEW_LINE print ( Q , end = " " ) NEW_LINE print ( P ^ Q , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE print ( P , end = " " ) NEW_LINE print ( P ^ K ^ VAL , end = " " ) NEW_LINE DEDENT DEDENT
def findNumber ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( ( N & 1 ) == 1 ) : NEW_LINE INDENT N = N >> 1 NEW_LINE count += 1 NEW_LINE DEDENT return N << count NEW_LINE DEDENT
def findNumber ( N ) : NEW_LINE INDENT return N & ( N + 1 ) NEW_LINE DEDENT
def array_divisbleby_k ( N , K ) : NEW_LINE INDENT flag = False NEW_LINE d1 , d2 = 0 , 0 NEW_LINE for i in range ( 2 , int ( K ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( K % i == 0 ) : NEW_LINE INDENT flag = True NEW_LINE d1 = i NEW_LINE d2 = K // i NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT print ( d2 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d1 , end = " " ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def min_elements ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT cntMinRem = 0 NEW_LINE for it in mp : NEW_LINE INDENT i = it NEW_LINE if ( mp [ i ] < i ) : NEW_LINE INDENT cntMinRem += mp [ i ] NEW_LINE DEDENT elif ( mp [ i ] > i ) : NEW_LINE INDENT cntMinRem += ( mp [ i ] - i ) NEW_LINE DEDENT DEDENT return cntMinRem NEW_LINE DEDENT
def CheckAllarrayEqual ( arr , N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT totalSum = arr [ 0 ] NEW_LINE secMax = - 10 ** 19 NEW_LINE Max = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] >= Max ) : NEW_LINE INDENT secMax = Max NEW_LINE Max = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secMax ) : NEW_LINE INDENT secMax = arr [ i ] NEW_LINE DEDENT totalSum += arr [ i ] NEW_LINE DEDENT if ( ( secMax * ( N - 1 ) ) > totalSum ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( totalSum % ( N - 1 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def getSum ( ar ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in ar : NEW_LINE INDENT sum += i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getMinSum ( pos , arr , primePow ) : NEW_LINE INDENT if ( pos == len ( primePow ) ) : NEW_LINE INDENT return getSum ( arr ) NEW_LINE DEDENT res = 10 ** 9 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT arr [ i ] *= primePow [ pos ] NEW_LINE res = min ( res , getMinSum ( pos + 1 , arr , primePow ) ) NEW_LINE arr [ i ] //= primePow [ pos ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def minimumSumWithGivenLCM ( k , x ) : NEW_LINE INDENT primePow = primePower ( x ) NEW_LINE n = len ( primePow ) NEW_LINE sum = 0 NEW_LINE if ( n <= k ) : NEW_LINE INDENT for i in primePow : NEW_LINE INDENT sum += i NEW_LINE DEDENT sum += k - n NEW_LINE DEDENT else : NEW_LINE INDENT arr = [ 1 ] * ( k ) NEW_LINE sum = getMinSum ( 0 , arr , primePow ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def IsPresent ( str , target ) : NEW_LINE INDENT if ( target in str ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findBitwiseORGivenXORAND ( X , Y ) : NEW_LINE INDENT return X + Y NEW_LINE DEDENT
def minOperation ( X , Y , n ) : NEW_LINE INDENT C = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT if ( X [ i ] != Y [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT C += 1 NEW_LINE DEDENT count = 0 NEW_LINE DEDENT DEDENT if ( count != 0 ) : NEW_LINE INDENT C += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if ( X [ i ] != Y [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT C += 1 NEW_LINE DEDENT count = 0 NEW_LINE DEDENT DEDENT if ( count != 0 ) : NEW_LINE INDENT C += 1 NEW_LINE DEDENT print ( C ) NEW_LINE DEDENT
def minimumcntOperationReq ( arr , N ) : NEW_LINE INDENT cntOp = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT cntOp += 1 NEW_LINE DEDENT DEDENT return ( cntOp + 1 ) // 2 NEW_LINE DEDENT
def ConstArrayAdjacentCoprime ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def cntIndexesToMakeBalance ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sumEven = 0 NEW_LINE sumOdd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT sumEven += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sumOdd += arr [ i ] NEW_LINE DEDENT DEDENT currOdd = 0 NEW_LINE currEven = arr [ 0 ] NEW_LINE res = 0 NEW_LINE newEvenSum = 0 NEW_LINE newOddSum = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( i % 2 ) : NEW_LINE INDENT currOdd += arr [ i ] NEW_LINE newEvenSum = ( currEven + sumOdd - currOdd ) NEW_LINE newOddSum = ( currOdd + sumEven - currEven - arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT currEven += arr [ i ] NEW_LINE newOddSum = ( currOdd + sumEven - currEven ) NEW_LINE newEvenSum = ( currEven + sumOdd - currOdd - arr [ i ] ) NEW_LINE DEDENT if ( newEvenSum == newOddSum ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT if ( sumOdd == sumEven - arr [ 0 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT if ( sumOdd == sumEven - arr [ n - 1 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( sumEven == sumOdd - arr [ n - 1 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findMinOperationsReqEmpStr ( str ) : NEW_LINE INDENT cntOne = 0 NEW_LINE cntZero = 0 NEW_LINE for element in str : NEW_LINE INDENT if element == '0' : NEW_LINE INDENT if cntOne > 0 : NEW_LINE INDENT cntOne = cntOne - 1 NEW_LINE DEDENT cntZero = cntZero + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if cntZero > 0 : NEW_LINE INDENT cntZero = cntZero - 1 NEW_LINE DEDENT cntOne = cntOne + 1 NEW_LINE DEDENT DEDENT return cntOne + cntZero NEW_LINE DEDENT
def minimumOperations ( S , m ) : NEW_LINE INDENT global adj , visited , cnt NEW_LINE total , N = 0 , len ( S ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT addEdge ( i , N - i - 1 ) NEW_LINE addEdge ( N - i - 1 , i ) NEW_LINE DEDENT for i in range ( N - m ) : NEW_LINE INDENT addEdge ( i , i + m ) NEW_LINE addEdge ( i + m , i ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( not visited [ i ] ) : NEW_LINE INDENT fre = [ 0 ] * 26 NEW_LINE cnt , maxx = 0 , - 1 NEW_LINE DFS ( i , fre , S ) NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT maxx = max ( maxx , fre [ j ] ) NEW_LINE DEDENT total += cnt - maxx NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE DEDENT
def countChanges ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE m = len ( mat [ 0 ] ) NEW_LINE ans = 0 NEW_LINE for j in range ( m - 1 ) : NEW_LINE INDENT if ( mat [ n - 1 ] [ j ] != 'R' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ m - 1 ] != 'D' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findMaxSumByAlternatingSign ( arr , N ) : NEW_LINE INDENT cntNeg = 0 NEW_LINE MaxAltSum = 0 NEW_LINE SmValue = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT cntNeg += 1 NEW_LINE DEDENT sum += abs ( arr [ i ] ) NEW_LINE SmValue = min ( SmValue , abs ( arr [ i ] ) ) NEW_LINE DEDENT MaxAltSum = sum NEW_LINE if ( cntNeg & 1 ) : NEW_LINE INDENT MaxAltSum -= 2 * SmValue NEW_LINE DEDENT return MaxAltSum NEW_LINE DEDENT
def minCntCharDeletionsfrequency ( str , N ) : NEW_LINE INDENT mp = { } NEW_LINE pq = [ ] NEW_LINE cntChar = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ str [ i ] ] = mp . get ( str [ i ] , 0 ) + 1 NEW_LINE DEDENT for it in mp : NEW_LINE INDENT pq . append ( mp [ it ] ) NEW_LINE DEDENT pq = sorted ( pq ) NEW_LINE while ( len ( pq ) > 0 ) : NEW_LINE INDENT frequent = pq [ - 1 ] NEW_LINE del pq [ - 1 ] NEW_LINE if ( len ( pq ) == 0 ) : NEW_LINE INDENT return cntChar NEW_LINE DEDENT if ( frequent == pq [ - 1 ] ) : NEW_LINE INDENT if ( frequent > 1 ) : NEW_LINE INDENT pq . append ( frequent - 1 ) NEW_LINE DEDENT cntChar += 1 NEW_LINE DEDENT pq = sorted ( pq ) NEW_LINE DEDENT return cntChar NEW_LINE DEDENT
def constructNewArraySumZero ( arr , N ) : NEW_LINE INDENT newArr = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT newArr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT newArr [ i ] = - arr [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( newArr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def minimumCntOfFlipsRequired ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE zeros = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT DEDENT if ( zeros == 0 or zeros == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT minFlips = 10000001 NEW_LINE currOnes = 0 NEW_LINE flips = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT currOnes += 1 NEW_LINE DEDENT flips = currOnes + ( zeros - ( i + 1 - currOnes ) ) NEW_LINE minFlips = min ( minFlips , flips ) NEW_LINE DEDENT return minFlips NEW_LINE DEDENT
def constructMEX ( arr , N ) : NEW_LINE INDENT hash = [ 0 ] * MAXN NEW_LINE for i in range ( N ) : NEW_LINE INDENT hash [ arr [ i ] ] = 1 NEW_LINE DEDENT MexOfArr = 0 NEW_LINE for i in range ( 1 , MAXN ) : NEW_LINE INDENT if ( hash [ i ] == 0 ) : NEW_LINE INDENT MexOfArr = i NEW_LINE break NEW_LINE DEDENT DEDENT B = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] < MexOfArr ) : NEW_LINE INDENT B [ i ] = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT B [ i ] = MexOfArr NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def smallestNumberLeftInPQ ( arr , N ) : NEW_LINE INDENT pq = [ ] NEW_LINE pairsArr = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT pq . append ( arr [ i ] ) NEW_LINE DEDENT pq = sorted ( pq ) NEW_LINE while ( len ( pq ) > 1 ) : NEW_LINE INDENT X = pq [ - 1 ] NEW_LINE del pq [ - 1 ] NEW_LINE Y = pq [ - 1 ] NEW_LINE del pq [ - 1 ] NEW_LINE pq . append ( ( X + Y + 1 ) // 2 ) NEW_LINE pairsArr . append ( [ X , Y ] ) NEW_LINE pq = sorted ( pq ) NEW_LINE DEDENT print ( "{" , pq [ - 1 ] , "}, " , end = "" ) NEW_LINE sz = len ( pairsArr ) NEW_LINE for i in range ( sz ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( "{ " , end = "" ) NEW_LINE DEDENT print ( "(" , pairsArr [ i ] [ 0 ] , "," , pairsArr [ i ] [ 1 ] , ")" , end = "" ) NEW_LINE if ( i != sz - 1 ) : NEW_LINE INDENT print ( end = ", " ) NEW_LINE DEDENT if ( i == sz - 1 ) : NEW_LINE INDENT print ( end = " }" ) NEW_LINE DEDENT DEDENT DEDENT
def findPairs ( N ) : NEW_LINE INDENT for i in range ( 0 , N + 1 ) : NEW_LINE INDENT print ( "(" , i , "," , N - i , "), " , end = "" ) NEW_LINE DEDENT DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT
def canReach ( N , A , B , K ) : NEW_LINE INDENT gcd = GCD ( N , K ) NEW_LINE if ( abs ( A - B ) % gcd == 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def sum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sm += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sm NEW_LINE DEDENT
def smallestNumber ( n , s ) : NEW_LINE INDENT if ( sum ( n ) <= s ) : NEW_LINE INDENT return n NEW_LINE DEDENT ans , k = n , 1 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT digit = ( ans // k ) % 10 NEW_LINE add = k * ( ( 10 - digit ) % 10 ) NEW_LINE ans += add NEW_LINE if ( sum ( ans ) <= s ) : NEW_LINE INDENT break NEW_LINE DEDENT k *= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def separate ( arr , n , parity ) : NEW_LINE INDENT count = 1 NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( ( ( arr [ i ] + parity ) & 1 ) and ( ( arr [ i - 1 ] + parity ) & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count > 1 ) : NEW_LINE INDENT res += count - 1 NEW_LINE DEDENT count = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def requiredOps ( arr , N ) : NEW_LINE INDENT res1 = separate ( arr , N , 0 ) NEW_LINE res2 = separate ( arr , N , 1 ) NEW_LINE print ( max ( res1 , res2 ) ) NEW_LINE DEDENT
def SieveOfEratosthenes ( N ) : NEW_LINE INDENT isPrime = [ True for i in range ( N + 1 ) ] NEW_LINE isPrime [ 0 ] = False NEW_LINE isPrime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( N ) ) + 1 , 1 ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT for i in range ( p * p , N + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT return isPrime NEW_LINE DEDENT
def cntPairsdiffOfPrimeisPrime ( N ) : NEW_LINE INDENT cntPairs = 0 NEW_LINE isPrime = SieveOfEratosthenes ( N ) NEW_LINE for i in range ( 2 , N + 1 , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] and isPrime [ i - 2 ] ) : NEW_LINE INDENT cntPairs += 2 NEW_LINE DEDENT DEDENT return cntPairs NEW_LINE DEDENT
def longestSubsequence ( arr , N ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def substringCount ( s ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE maxfreq = - sys . maxsize - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE if ( maxfreq < freq [ ord ( s [ i ] ) - ord ( 'a' ) ] ) : NEW_LINE INDENT maxfreq = freq [ ord ( s [ i ] ) - ord ( 'a' ) ] NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( maxfreq == freq [ i ] ) : NEW_LINE INDENT max_char = chr ( i + ord ( 'a' ) ) NEW_LINE break NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ch = s [ i ] NEW_LINE if ( max_char == ch ) : NEW_LINE INDENT ans += ( len ( s ) - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findSum ( S , n , x ) : NEW_LINE INDENT table = [ [ 0 for x in range ( x + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT table [ 0 ] [ i ] = sys . maxsize - 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , x + 1 ) : NEW_LINE INDENT if ( S [ i - 1 ] > j ) : NEW_LINE INDENT table [ i ] [ j ] = table [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT table [ i ] [ j ] = min ( table [ i - 1 ] [ j ] , table [ i ] [ j - S [ i - 1 ] ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT if ( table [ n ] [ x ] > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return table [ n ] [ x ] NEW_LINE DEDENT
def minRemovals ( arr , n , m , x ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT requied_Sum = 0 NEW_LINE if ( sum % m < x ) : NEW_LINE INDENT requied_Sum = m + sum % m - x NEW_LINE DEDENT else : NEW_LINE INDENT requied_Sum = sum % m - x NEW_LINE DEDENT print ( findSum ( arr , n , requied_Sum ) ) NEW_LINE DEDENT
def findXandYwithminABSX_Y ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT print ( ( N // 2 ) , ( N // 2 + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( N // 2 - 1 ) , ( N // 2 + 1 ) ) NEW_LINE DEDENT DEDENT
def removeDuplicateLetters ( s ) : NEW_LINE INDENT cnt = [ 0 ] * 26 NEW_LINE vis = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in s : NEW_LINE INDENT cnt [ ord ( i ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT res = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( 'a' ) ] -= 1 NEW_LINE if ( not vis [ ord ( s [ i ] ) - ord ( 'a' ) ] ) : NEW_LINE INDENT while ( len ( res ) > 0 and res [ - 1 ] > s [ i ] and cnt [ ord ( res [ - 1 ] ) - ord ( 'a' ) ] > 0 ) : NEW_LINE INDENT vis [ ord ( res [ - 1 ] ) - ord ( 'a' ) ] = 0 NEW_LINE del res [ - 1 ] NEW_LINE DEDENT res += s [ i ] NEW_LINE vis [ ord ( s [ i ] ) - ord ( 'a' ) ] = 1 NEW_LINE DEDENT DEDENT return "" . join ( res ) NEW_LINE DEDENT
def minChange ( s , n ) : NEW_LINE INDENT L = [ 0 ] * 26 NEW_LINE R = [ 0 ] * 26 NEW_LINE for i in range ( 0 , n // 2 ) : NEW_LINE INDENT ch = s [ i ] NEW_LINE L [ ord ( ch ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( n // 2 , n ) : NEW_LINE INDENT ch = s [ i ] NEW_LINE R [ ord ( ch ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT count = n NEW_LINE for ch in range ( ord ( 'a' ) , ord ( 'z' ) ) : NEW_LINE INDENT count = min ( count , n - L [ ch - ord ( 'a' ) ] - R [ ch - ord ( 'a' ) ] ) NEW_LINE DEDENT change = n / 2 NEW_LINE for d in range ( 0 , 25 ) : NEW_LINE INDENT change -= L [ d ] NEW_LINE change += R [ d ] NEW_LINE count = min ( count , change ) NEW_LINE DEDENT change = n / 2 NEW_LINE for d in range ( 0 , 25 ) : NEW_LINE INDENT change -= R [ d ] NEW_LINE change += L [ d ] NEW_LINE count = min ( change , count ) NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT
def minSteps ( S ) : NEW_LINE INDENT new_str = "" NEW_LINE N = len ( S ) NEW_LINE i = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT new_str += S [ i ] NEW_LINE j = i NEW_LINE while ( i < N and S [ i ] == S [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( ceil ( ( len ( new_str ) + 1 ) / 2 ) ) NEW_LINE DEDENT
def MaximumSides ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def minimumMoves ( n ) : NEW_LINE INDENT cnt2 = 0 NEW_LINE cnt5 = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n //= 2 NEW_LINE cnt2 += 1 NEW_LINE DEDENT while ( n % 5 == 0 ) : NEW_LINE INDENT n //= 5 NEW_LINE cnt5 += 1 NEW_LINE DEDENT if ( n == 1 and cnt2 <= cnt5 ) : NEW_LINE INDENT return 2 * cnt5 - cnt2 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def check ( n ) : NEW_LINE INDENT if ( ( n & n - 1 ) != 0 ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def rearrangeArrayUtil ( A , B , N ) : NEW_LINE INDENT ans = rearrangeArray ( A , B , N ) NEW_LINE if ( len ( ans ) > 0 ) : NEW_LINE INDENT for x in ans : NEW_LINE INDENT print ( x , end = ' ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def countOfSubarray ( arr , N ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE answer = 0 NEW_LINE sum = 0 NEW_LINE mp [ 1 ] += 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE answer += mp [ sum - i ] NEW_LINE mp [ sum - i ] += 1 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT
def countInverse ( arr , N , M ) : NEW_LINE INDENT XOR = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT gcdOfMandelement = gcd ( M , arr [ i ] ) NEW_LINE if ( gcdOfMandelement == 1 ) : NEW_LINE INDENT XOR = XOR ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( XOR ) NEW_LINE DEDENT
def Moves_Calculator ( x , y , row , col ) : NEW_LINE INDENT total_moves = 0 NEW_LINE if ( row - x ) > 0 and ( col - y ) > 0 : NEW_LINE INDENT total_moves += min ( ( row - x ) , ( col - y ) ) NEW_LINE DEDENT if ( y - 1 ) > 0 and ( x - 1 ) > 0 : NEW_LINE INDENT total_moves += min ( ( y - 1 ) , ( x - 1 ) ) NEW_LINE DEDENT if ( x - 1 ) > 0 and ( col - y ) > 0 : NEW_LINE INDENT total_moves += min ( ( x - 1 ) , ( col - y ) ) NEW_LINE DEDENT if ( row - x ) > 0 and ( y - 1 ) > 0 : NEW_LINE INDENT total_moves += min ( ( row - x ) , ( y - 1 ) ) NEW_LINE DEDENT total_moves += ( row - 1 ) + ( col - 1 ) NEW_LINE king_moves = 0 NEW_LINE if x + 1 <= m : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if x - 1 > 0 : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if y + 1 <= n : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if y - 1 > 0 : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if x + 1 <= m and y + 1 <= n : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if x + 1 <= m and y - 1 > 0 : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if x - 1 > 0 and y - 1 > 0 : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if x - 1 > 0 and y + 1 <= n : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT return total_moves - king_moves NEW_LINE DEDENT
def clstNum ( N ) : NEW_LINE INDENT return ( N - 1 ) NEW_LINE DEDENT
def findMax ( a , dp , i , flag ) : NEW_LINE INDENT if ( i == len ( a ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ flag ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ flag ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( flag == 0 ) : NEW_LINE INDENT ans = max ( findMax ( a , dp , i + 1 , 0 ) , a [ i ] + findMax ( a , dp , i + 1 , 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( findMax ( a , dp , i + 1 , 1 ) , - 1 * a [ i ] + findMax ( a , dp , i + 1 , 0 ) ) NEW_LINE DEDENT dp [ i ] [ flag ] = ans NEW_LINE return ans NEW_LINE DEDENT
def findMaxSumUtil ( arr , N ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( 2 ) ] for i in range ( N ) ] NEW_LINE print ( findMax ( arr , dp , 0 , 0 ) ) NEW_LINE DEDENT
def equvInverse ( arr , N , P ) : NEW_LINE INDENT cntElem = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( ( arr [ i ] * arr [ i ] ) % P == 1 ) : NEW_LINE INDENT cntElem = cntElem + 1 NEW_LINE DEDENT DEDENT return cntElem NEW_LINE DEDENT
def power ( K , M ) : NEW_LINE INDENT res = 1 NEW_LINE while ( M > 0 ) : NEW_LINE INDENT if ( ( M & 1 ) == 1 ) : NEW_LINE INDENT res = ( res * K ) NEW_LINE DEDENT M = M >> 1 NEW_LINE K = ( K * K ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def cntWays ( arr , N , K ) : NEW_LINE INDENT cntways = 0 NEW_LINE M = 0 NEW_LINE st = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT st . add ( arr [ i ] ) NEW_LINE DEDENT M = len ( st ) NEW_LINE cntways = power ( K , M ) NEW_LINE return cntways NEW_LINE DEDENT
def minCost ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT a = [ 0 ] * 26 NEW_LINE for j in range ( i , n , k ) : NEW_LINE INDENT a [ ord ( s [ j ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT min_cost = sys . maxsize - 1 NEW_LINE for ch in range ( 26 ) : NEW_LINE INDENT cost = 0 NEW_LINE for tr in range ( 26 ) : NEW_LINE INDENT cost += abs ( ch - tr ) * a [ tr ] NEW_LINE DEDENT min_cost = min ( min_cost , cost ) NEW_LINE DEDENT ans += min_cost NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def pairProductMean ( arr , N ) : NEW_LINE INDENT pairArray = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT pairProduct = arr [ i ] * arr [ j ] NEW_LINE pairArray . append ( pairProduct ) NEW_LINE DEDENT DEDENT length = len ( pairArray ) NEW_LINE sum = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT sum += pairArray [ i ] NEW_LINE DEDENT mean = 0 NEW_LINE if ( length != 0 ) : NEW_LINE INDENT mean = sum / length NEW_LINE DEDENT else : NEW_LINE INDENT mean = 0 NEW_LINE DEDENT return mean NEW_LINE DEDENT
def pairProductMean ( arr , N ) : NEW_LINE INDENT suffixSumArray = [ 0 ] * N NEW_LINE suffixSumArray [ N - 1 ] = arr [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] NEW_LINE DEDENT length = ( N * ( N - 1 ) ) // 2 NEW_LINE res = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT res += arr [ i ] * suffixSumArray [ i + 1 ] NEW_LINE DEDENT mean = 0 NEW_LINE if ( length != 0 ) : NEW_LINE INDENT mean = res / length NEW_LINE DEDENT else : NEW_LINE INDENT mean = 0 NEW_LINE DEDENT return mean NEW_LINE DEDENT
def TotalXorPair ( arr , N ) : NEW_LINE INDENT totalXOR = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT totalXOR ^= arr [ i ] ^ arr [ j ] NEW_LINE DEDENT DEDENT return totalXOR NEW_LINE DEDENT
def minAbsDiff ( N ) : NEW_LINE INDENT if ( N % 4 == 0 or N % 4 == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def findWinner ( s ) : NEW_LINE INDENT vowels_count = 0 NEW_LINE consonants_count = 0 NEW_LINE p = len ( s ) NEW_LINE for i in range ( 0 , p ) : NEW_LINE INDENT if ( s [ i ] == 'a' or s [ i ] == 'e' or s [ i ] == 'i' or s [ i ] == 'o' or s [ i ] == 'u' ) : NEW_LINE INDENT vowels_count = vowels_count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonants_count = consonants_count + 1 NEW_LINE DEDENT DEDENT if ( vowels_count == 0 ) : NEW_LINE INDENT if ( consonants_count % 2 == 0 ) : NEW_LINE INDENT print ( "Player B" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Player A" ) NEW_LINE DEDENT DEDENT elif ( vowels_count == 1 and consonants_count % 2 != 0 ) : NEW_LINE INDENT print ( "Player A" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "D" ) NEW_LINE DEDENT DEDENT
def possibleAcyclicGraph ( N ) : NEW_LINE INDENT print ( pow ( 2 , N - 1 ) ) NEW_LINE return NEW_LINE DEDENT
def minProd ( X , Y , N ) : NEW_LINE INDENT if ( X <= Y ) : NEW_LINE INDENT if ( N < X ) : NEW_LINE INDENT return ( X - N ) * Y NEW_LINE DEDENT else : NEW_LINE INDENT return max ( Y - ( N - X + 1 ) , 1 ) NEW_LINE DEDENT DEDENT if ( Y >= N ) : NEW_LINE INDENT return ( Y - N ) * X NEW_LINE DEDENT return max ( X - ( N - Y + 1 ) , 1 ) NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT for i in range ( 3 , MAXN , 2 ) : NEW_LINE INDENT is_prime [ i ] = 1 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( MAXN ) ) , 2 ) : NEW_LINE INDENT if is_prime [ i ] : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT is_prime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT is_prime [ 2 ] = 1 NEW_LINE for i in range ( 1 , MAXN ) : NEW_LINE INDENT count_of_primes [ i ] = ( count_of_primes [ i - 1 ] + is_prime [ i ] ) NEW_LINE DEDENT DEDENT
def power ( x , y , p ) : NEW_LINE INDENT result = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if y & 1 == 1 : NEW_LINE INDENT result = ( result * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE y >>= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
def maxSumOfSquares ( N , S ) : NEW_LINE INDENT res = 0 NEW_LINE if ( S < N or S > 9 * N ) : NEW_LINE INDENT cout << - 1 NEW_LINE return NEW_LINE DEDENT S = S - N NEW_LINE c = 0 NEW_LINE while ( S > 0 ) : NEW_LINE INDENT c += 1 NEW_LINE if ( S // 8 > 0 ) : NEW_LINE INDENT res += 9 * 9 NEW_LINE S -= 8 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( S + 1 ) * ( S + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT res = res + ( N - c ) NEW_LINE print ( res ) NEW_LINE DEDENT
def cntMinSub ( arr , N , K ) : NEW_LINE INDENT res = 0 NEW_LINE start = 0 NEW_LINE end = N - 1 NEW_LINE arr = sorted ( arr ) NEW_LINE while ( end - start > 1 ) : NEW_LINE INDENT if ( arr [ start ] + arr [ end ] <= K ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += 1 NEW_LINE end -= 1 NEW_LINE DEDENT DEDENT if ( end - start == 1 ) : NEW_LINE INDENT if ( arr [ start ] + arr [ end ] <= K ) : NEW_LINE INDENT res += 1 NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += 1 NEW_LINE end -= 1 NEW_LINE DEDENT DEDENT if ( start == end ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def condition ( a , b ) : NEW_LINE INDENT d = abs ( a - b ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT if i * i > d : NEW_LINE INDENT break NEW_LINE DEDENT if ( d % i == 0 ) : NEW_LINE INDENT if ( d // i == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 2 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def isComposite ( N ) : NEW_LINE INDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT if ( N % i == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def compositePair ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT prod = arr [ i ] * arr [ j ] NEW_LINE if ( isComposite ( prod ) ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def getPrimeNum ( ) : NEW_LINE INDENT isPrime = [ True ] * ( X ) NEW_LINE isPrime [ 0 ] = False NEW_LINE isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i <= X : NEW_LINE INDENT if ( isPrime [ i ] == True ) : NEW_LINE INDENT for j in range ( i * i , X , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return isPrime NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( x , y // 2 ) % mod NEW_LINE p = ( p * p ) % mod NEW_LINE if ( y & 1 ) : NEW_LINE INDENT p = ( x * p ) % mod NEW_LINE DEDENT return p NEW_LINE DEDENT
def checkDigits ( n ) : NEW_LINE INDENT while True : NEW_LINE INDENT r = n % 10 NEW_LINE if ( r == 3 or r == 4 or r == 6 or r == 7 or r == 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n //= 10 NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isAllPrime ( n ) : NEW_LINE INDENT return isPrime ( n ) and checkDigits ( n ) NEW_LINE DEDENT
def generateArray ( arr , n ) : NEW_LINE INDENT ans = deque ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i & 1 != 0 ) : NEW_LINE INDENT ans . appendleft ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT if ( n & 1 != 0 ) : NEW_LINE INDENT ans . reverse ( ) NEW_LINE DEDENT for x in ans : NEW_LINE INDENT print ( x , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def No_Of_subsequences ( mp ) : NEW_LINE INDENT count = 0 NEW_LINE left = 0 NEW_LINE for x in mp : NEW_LINE INDENT mp [ x ] += left NEW_LINE count += ( mp [ x ] // x ) NEW_LINE left = mp [ x ] % x NEW_LINE DEDENT return count NEW_LINE DEDENT
def maximumsubsequences ( arr , n ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( No_Of_subsequences ( mp ) ) NEW_LINE DEDENT
def power ( X , n ) : NEW_LINE INDENT res = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( n & 1 != 0 ) : NEW_LINE INDENT res = res * X NEW_LINE DEDENT X = X * X NEW_LINE n = n >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def closestgtNum ( N ) : NEW_LINE INDENT n = int ( math . log10 ( N ) + 1 ) NEW_LINE P = power ( 10 , n - 1 ) NEW_LINE Y = N % P NEW_LINE res = N + ( P - Y ) NEW_LINE return res NEW_LINE DEDENT
def closestgtNum ( str ) : NEW_LINE INDENT res = "" NEW_LINE n = len ( str ) NEW_LINE if ( str [ 0 ] < '9' ) : NEW_LINE INDENT res += ( chr ) ( ord ( str [ 0 ] ) + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT res += ( chr ) ( '1' ) NEW_LINE res += ( chr ) ( '0' ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT res += ( '0' ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def find_next ( n , k ) : NEW_LINE INDENT M = n + 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( ( M & ( 1 << k ) ) > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT M += 1 NEW_LINE DEDENT return M NEW_LINE DEDENT
def check ( arr , pieces ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT m [ arr [ i ] ] = i + 1 NEW_LINE DEDENT for i in range ( 0 , len ( pieces ) ) : NEW_LINE INDENT if ( len ( pieces [ i ] ) == 1 and m [ pieces [ i ] [ 0 ] ] != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( len ( pieces [ i ] ) > 1 and m [ pieces [ i ] [ 0 ] ] != 0 ) : NEW_LINE INDENT idx = m [ pieces [ i ] [ 0 ] ] - 1 NEW_LINE idx = idx + 1 NEW_LINE if idx >= len ( arr ) : NEW_LINE INDENT return False NEW_LINE DEDENT for j in range ( 1 , len ( pieces [ i ] ) ) : NEW_LINE INDENT if arr [ idx ] == pieces [ i ] [ j ] : NEW_LINE INDENT idx = idx + 1 NEW_LINE if ( idx >= len ( arr ) and j < len ( pieces [ i ] ) - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def maximumSubarrays ( arr , N , target ) : NEW_LINE INDENT ans = 0 NEW_LINE availIdx = - 1 NEW_LINE cur_sum = 0 NEW_LINE mp = { } NEW_LINE mp [ 0 ] = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cur_sum += arr [ i ] NEW_LINE if ( ( cur_sum - target ) in mp and mp [ cur_sum - target ] >= availIdx ) : NEW_LINE INDENT ans += 1 NEW_LINE availIdx = i NEW_LINE DEDENT mp [ cur_sum ] = i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = power ( x , y // 2 ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return x * temp * temp NEW_LINE DEDENT DEDENT
def maximumPossibleSum ( N , X ) : NEW_LINE INDENT print ( X * ( power ( 2 , N ) - 1 ) ) NEW_LINE DEDENT
def countOfPairs ( x , y ) : NEW_LINE INDENT counter = 1 NEW_LINE while ( x or y ) : NEW_LINE INDENT bit1 = x % 2 NEW_LINE bit2 = y % 2 NEW_LINE x >>= 1 NEW_LINE y >>= 1 NEW_LINE if ( bit1 == 1 and bit2 == 0 ) : NEW_LINE INDENT counter *= 2 NEW_LINE continue NEW_LINE DEDENT if ( bit1 & bit2 ) : NEW_LINE INDENT counter = 0 NEW_LINE break NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def findGCD ( arr , N ) : NEW_LINE INDENT result = 0 NEW_LINE for element in arr : NEW_LINE INDENT result = gcd ( result , element ) NEW_LINE if ( result == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def check_digits ( N ) : NEW_LINE INDENT while ( N > 0 ) : NEW_LINE INDENT n = N % 10 NEW_LINE if ( ( n != 0 ) and ( n != 1 ) and ( n != 4 ) and ( n != 9 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT N = N // 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def isFullSquare ( N ) : NEW_LINE INDENT if ( is_perfect ( N ) and check_digits ( N ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def maxBottles ( n , e ) : NEW_LINE INDENT s = 0 NEW_LINE b = 0 NEW_LINE a = n NEW_LINE while ( a != 0 ) : NEW_LINE INDENT s = s + a NEW_LINE a = ( a + b ) // e NEW_LINE b = n - ( a * e ) NEW_LINE n = a + b NEW_LINE DEDENT return s NEW_LINE DEDENT
def power ( x , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = power ( x , n // 2 ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return x * temp * temp NEW_LINE DEDENT DEDENT
def count_Total_Numbers ( n , x ) : NEW_LINE INDENT total , multiples = 0 , 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( i % x == 0 ) : NEW_LINE INDENT multiples += 1 NEW_LINE DEDENT DEDENT if ( n == 1 ) : NEW_LINE INDENT return multiples NEW_LINE DEDENT total = ( ( multiples - 1 ) * power ( multiples , n - 1 ) ) NEW_LINE return total NEW_LINE DEDENT
def getPosition ( N , M ) : NEW_LINE INDENT if ( M > ( N // 2 ) ) : NEW_LINE INDENT return ( M - ( N // 2 ) ) NEW_LINE DEDENT return ( M + ( N // 2 ) ) NEW_LINE DEDENT
def number_of_strings ( N , M ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( N > 0 and M > 0 ) : NEW_LINE INDENT if ( N > M ) : NEW_LINE INDENT if ( N >= 2 ) : NEW_LINE INDENT N -= 2 NEW_LINE M -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if M >= 2 : NEW_LINE INDENT M -= 2 NEW_LINE N -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def clearLastBit ( N , K ) : NEW_LINE INDENT mask = ( - 1 << K + 1 ) NEW_LINE N = N & mask NEW_LINE return N NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , ( int ( maxm ** 1 / 2 ) ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , maxm , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE DEDENT
def num_prime ( ) : NEW_LINE INDENT prime_number [ 0 ] = 0 NEW_LINE for i in range ( 1 , maxm + 1 ) : NEW_LINE INDENT tmp = - 1 NEW_LINE if ( prime [ i ] == True ) : NEW_LINE INDENT tmp = 1 NEW_LINE DEDENT else : NEW_LINE INDENT tmp = 0 NEW_LINE DEDENT prime_number [ i ] = prime_number [ i - 1 ] + tmp NEW_LINE DEDENT DEDENT
def min_steps ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE num_prime ( ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prime_number [ n ] - 1 + ( n - 2 ) ) NEW_LINE DEDENT DEDENT
def findWinner ( a , n ) : NEW_LINE INDENT win = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT win = 1 NEW_LINE DEDENT else : NEW_LINE INDENT win = 0 NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT if ( win == 0 and a [ i ] > 1 ) : NEW_LINE INDENT win = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( win == 1 and a [ i ] > 1 ) : NEW_LINE INDENT win = 0 NEW_LINE DEDENT DEDENT DEDENT if ( win == 0 ) : NEW_LINE INDENT print ( "A" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "B" ) NEW_LINE DEDENT DEDENT
def isPossible ( r , b , g ) : NEW_LINE INDENT r = r % 3 NEW_LINE b = b % 3 NEW_LINE g = g % 3 NEW_LINE if ( r == b or b == g or g == r ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def checkWinner ( N , K ) : NEW_LINE INDENT if ( N % ( K + 1 ) ) : NEW_LINE INDENT print ( "A" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "B" ) NEW_LINE DEDENT DEDENT
def ncr ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countPath ( N , M , K ) : NEW_LINE INDENT answer = 0 NEW_LINE if ( K >= 2 ) : NEW_LINE INDENT answer = 0 NEW_LINE DEDENT elif ( K == 0 ) : NEW_LINE INDENT answer = ncr ( N + M - 2 , N - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT answer = ncr ( N + M - 2 , N - 1 ) NEW_LINE X = ( N - 1 ) // 2 + ( M - 1 ) // 2 NEW_LINE Y = ( N - 1 ) // 2 NEW_LINE midCount = ncr ( X , Y ) NEW_LINE X = ( ( N - 1 ) - ( N - 1 ) // 2 ) + ( ( M - 1 ) - ( M - 1 ) // 2 ) NEW_LINE Y = ( ( N - 1 ) - ( N - 1 ) // 2 ) NEW_LINE midCount *= ncr ( X , Y ) NEW_LINE answer -= midCount NEW_LINE DEDENT return answer NEW_LINE DEDENT
def calculate_steps ( arr , n , minimum ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = arr [ i ] NEW_LINE if ( arr [ i ] > minimum ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minimum NEW_LINE count += arr [ i ] // 5 NEW_LINE arr [ i ] = arr [ i ] % 5 NEW_LINE count += arr [ i ] // 2 NEW_LINE arr [ i ] = arr [ i ] % 2 NEW_LINE if ( arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT arr [ i ] = val NEW_LINE DEDENT return count NEW_LINE DEDENT
def solve ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE arr = arr [ : : - 1 ] NEW_LINE minimum = arr [ n - 1 ] NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE count3 = 0 NEW_LINE count1 = calculate_steps ( arr , n , minimum ) NEW_LINE count2 = calculate_steps ( arr , n , minimum - 1 ) NEW_LINE count3 = calculate_steps ( arr , n , minimum - 2 ) NEW_LINE return min ( count1 , min ( count2 , count3 ) ) NEW_LINE DEDENT
def maxSubset ( arr , N , X ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE counter = 0 NEW_LINE sz = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sz += 1 NEW_LINE if ( arr [ i ] * sz >= X ) : NEW_LINE INDENT counter += 1 NEW_LINE sz = 0 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT
def getCount ( N , M ) : NEW_LINE INDENT total_count = 0 NEW_LINE total_count += N // 10 NEW_LINE x = ( N // 10 ) * 10 NEW_LINE if ( ( N - x ) >= M ) : NEW_LINE INDENT total_count = total_count + 1 NEW_LINE DEDENT return total_count NEW_LINE DEDENT
def maximumModuloValue ( A , n ) : NEW_LINE INDENT mn = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT mn = min ( A [ i ] , mn ) NEW_LINE DEDENT return mn NEW_LINE DEDENT
def RightAngled ( a , n ) : NEW_LINE INDENT xpoints = defaultdict ( lambda : 0 ) NEW_LINE ypoints = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT xpoints [ a [ i ] [ 0 ] ] += 1 NEW_LINE ypoints [ a [ i ] [ 1 ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( xpoints [ a [ i ] [ 0 ] ] >= 1 and ypoints [ a [ i ] [ 1 ] ] >= 1 ) : NEW_LINE INDENT count += ( ( xpoints [ a [ i ] [ 0 ] ] - 1 ) * ( ypoints [ a [ i ] [ 1 ] ] - 1 ) ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def updateQuery ( from_x , from_y , to_x , to_y , k , aux ) : NEW_LINE INDENT aux [ from_x ] [ from_y ] += k NEW_LINE if ( to_x + 1 < 3 ) : NEW_LINE INDENT aux [ to_x + 1 ] [ from_y ] -= k NEW_LINE DEDENT if ( to_x + 1 < 3 and to_y + 1 < 4 ) : NEW_LINE INDENT aux [ to_x + 1 ] [ to_y + 1 ] += k NEW_LINE DEDENT if ( to_y + 1 < 4 ) : NEW_LINE INDENT aux [ from_x ] [ to_y + 1 ] -= k NEW_LINE DEDENT return aux NEW_LINE DEDENT
def RepeatingSubarray ( arr , N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT brr = [ ] NEW_LINE brr . append ( arr [ 0 ] ) NEW_LINE brr . append ( arr [ 1 ] ) NEW_LINE for i in range ( 2 , N // 2 + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT a = False NEW_LINE n = len ( brr ) NEW_LINE j = i NEW_LINE while ( j < N ) : NEW_LINE INDENT K = j % i NEW_LINE if ( arr [ j ] == brr [ K ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT a = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not a and j == N ) : NEW_LINE INDENT printArray ( brr ) NEW_LINE return NEW_LINE DEDENT DEDENT brr . append ( arr [ i ] ) NEW_LINE DEDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT
def SieveOfEratosthenes ( n ) : NEW_LINE INDENT isprime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isprime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT isprime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def KDistinctPrime ( arr , n , k ) : NEW_LINE INDENT SieveOfEratosthenes ( 2000000 ) NEW_LINE cnt = defaultdict ( lambda : 0 ) NEW_LINE result = - 1 NEW_LINE j = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE if ( isprime [ x ] ) : NEW_LINE INDENT cnt [ x ] += 1 NEW_LINE if ( cnt [ x ] == 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT DEDENT while ( k < 0 ) : NEW_LINE INDENT j += 1 NEW_LINE x = arr [ j ] NEW_LINE if ( isprime [ x ] ) : NEW_LINE INDENT cnt [ x ] -= 1 NEW_LINE if ( cnt [ x ] == 0 ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT if ( k == 0 ) : NEW_LINE INDENT result = max ( result , i - j ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def printMissingElements ( arr , N ) : NEW_LINE INDENT b = [ 0 ] * ( arr [ N - 1 ] + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 NEW_LINE DEDENT for i in range ( arr [ 0 ] , arr [ N - 1 ] + 1 ) : NEW_LINE INDENT if ( b [ i ] == 0 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def SieveOfEratosthenes ( StorePrimes ) : NEW_LINE INDENT IsPrime = [ True for i in range ( MAX_SIZE ) ] NEW_LINE p = 2 NEW_LINE while ( p * p < MAX_SIZE ) : NEW_LINE INDENT if ( IsPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX_SIZE , p ) : NEW_LINE INDENT IsPrime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX_SIZE ) : NEW_LINE INDENT if ( IsPrime [ p ] ) : NEW_LINE INDENT StorePrimes . append ( p ) NEW_LINE DEDENT DEDENT DEDENT
def Smallest_non_Prime ( StorePrimes , N ) : NEW_LINE INDENT x = StorePrimes [ N ] NEW_LINE return x * x NEW_LINE DEDENT
def countNestedPolygons ( sides ) : NEW_LINE INDENT count = 0 NEW_LINE while ( sides > 5 ) : NEW_LINE INDENT sides //= 2 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def smallestCommon ( a , b , c , d ) : NEW_LINE INDENT if ( a == c ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > c ) : NEW_LINE INDENT swap ( a , c ) NEW_LINE swap ( b , d ) NEW_LINE DEDENT first_term_diff = ( c - a ) NEW_LINE possible_y = 0 NEW_LINE for possible_y in range ( b ) : NEW_LINE INDENT if ( ( first_term_diff % b + possible_y * d ) % b == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( possible_y != b ) : NEW_LINE INDENT return c + possible_y * d NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def isprm ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def NumberOfTrees ( arr , N ) : NEW_LINE INDENT maxElement = max ( arr ) NEW_LINE level = [ 0 ] * ( maxElement + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT level [ arr [ i ] ] += 1 NEW_LINE DEDENT if ( arr [ 0 ] != 0 or level [ 0 ] != 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( maxElement ) : NEW_LINE INDENT for j in range ( level [ i + 1 ] ) : NEW_LINE INDENT ans = ( ans * level [ i ] ) % mod NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( x , y // 2 ) % mod NEW_LINE p = ( p * p ) % mod NEW_LINE if ( y & 1 ) : NEW_LINE INDENT p = ( x * p ) % mod NEW_LINE DEDENT return p NEW_LINE DEDENT
def NumberOfTrees ( arr , N ) : NEW_LINE INDENT maxElement = max ( arr ) NEW_LINE level = [ 0 ] * ( maxElement + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT level [ arr [ i ] ] += 1 NEW_LINE DEDENT if ( arr [ 0 ] != 0 or level [ 0 ] != 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( maxElement ) : NEW_LINE INDENT ans = ( ans * power ( level [ i ] , level [ i + 1 ] ) ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT
def carryCount ( num1 , num2 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num2 != 0 ) : NEW_LINE INDENT carry = num1 & num2 NEW_LINE num1 = num1 ^ num2 NEW_LINE num2 = carry << 1 NEW_LINE count += bin ( num2 ) . count ( '1' ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def power ( X , Y , Mod ) : NEW_LINE INDENT if Y == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( X , Y // 2 , Mod ) % Mod NEW_LINE p = ( p * p ) % Mod NEW_LINE if Y & 1 : NEW_LINE INDENT p = ( X * p ) % Mod NEW_LINE DEDENT return p NEW_LINE DEDENT
def Inversefactorial ( N ) : NEW_LINE INDENT if N <= 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = ( fact * i ) % Mod NEW_LINE DEDENT return power ( fact , Mod - 2 , Mod ) NEW_LINE DEDENT
def nck ( N , K ) : NEW_LINE INDENT factN = factorial ( N ) NEW_LINE inv = Inversefactorial ( K ) NEW_LINE invFact = Inversefactorial ( N - K ) NEW_LINE return ( ( ( factN * inv ) % Mod ) * invFact ) % Mod NEW_LINE DEDENT
def checkEvenSum ( arr , N , size ) : NEW_LINE INDENT even_freq , odd_freq = 0 , 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd_freq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_freq += 1 NEW_LINE DEDENT DEDENT if ( even_freq >= N ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT if ( odd_freq & 1 ) : NEW_LINE INDENT taken = odd_freq - 1 NEW_LINE req = N - taken NEW_LINE if ( even_freq < req ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT taken = odd_freq NEW_LINE req = N - taken NEW_LINE if ( even_freq < req ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def digitsOf ( num ) : NEW_LINE INDENT return len ( str ( num ) ) NEW_LINE DEDENT
def count ( a , tn ) : NEW_LINE INDENT diff = int ( pow ( 10 , digitsOf ( a ) ) ) NEW_LINE return ( ( tn - a ) / diff ) + 1 NEW_LINE DEDENT
def countOfSubarray ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT arr [ i ] -= 1 NEW_LINE DEDENT pref = [ 0 ] * N NEW_LINE pref [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + arr [ i ] NEW_LINE DEDENT mp = defaultdict ( lambda : 0 ) NEW_LINE answer = 0 NEW_LINE mp [ 0 ] += 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT answer += mp [ pref [ i ] ] NEW_LINE mp [ pref [ i ] ] += 1 NEW_LINE DEDENT return answer NEW_LINE DEDENT
def minOperations ( a , N ) : NEW_LINE INDENT num_of_ops1 = num_of_ops2 = sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE if ( i % 2 == 0 and sum >= 0 ) : NEW_LINE INDENT num_of_ops1 += ( 1 + abs ( sum ) ) NEW_LINE sum = - 1 NEW_LINE DEDENT elif ( i % 2 == 1 and sum <= 0 ) : NEW_LINE INDENT num_of_ops1 += ( 1 + abs ( sum ) ) NEW_LINE sum = 1 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE if ( i % 2 == 1 and sum >= 0 ) : NEW_LINE INDENT num_of_ops2 += ( 1 + abs ( sum ) ) NEW_LINE sum = - 1 NEW_LINE DEDENT elif ( i % 2 == 0 and sum <= 0 ) : NEW_LINE INDENT num_of_ops2 += ( 1 + abs ( sum ) ) NEW_LINE sum = 1 NEW_LINE DEDENT DEDENT return min ( num_of_ops1 , num_of_ops2 ) NEW_LINE DEDENT
def printSubset ( N , K ) : NEW_LINE INDENT answer = "" NEW_LINE while ( N > 0 ) : NEW_LINE INDENT p = int ( math . log ( N , 2 ) ) NEW_LINE answer = str ( K ** p ) + " " + answer NEW_LINE N = N % ( 2 ** p ) NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT
def printsubset ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE x = 0 NEW_LINE vec = [ ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT x = n & 1 NEW_LINE if ( x ) : NEW_LINE INDENT vec . append ( pow ( k , count ) ) NEW_LINE DEDENT n = n >> 1 NEW_LINE count += 1 NEW_LINE DEDENT for item in vec : NEW_LINE INDENT print ( item , end = " " ) NEW_LINE DEDENT DEDENT
def checkEquall ( arr , N ) : NEW_LINE INDENT sumEven , sumOdd = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT sumOdd += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sumEven += arr [ i ] NEW_LINE DEDENT DEDENT if ( sumEven == sumOdd ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def isSumOfPower ( n ) : NEW_LINE INDENT isSum = [ 0 ] * ( n + 1 ) NEW_LINE perfectPowers = [ ] NEW_LINE perfectPowers . append ( 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT isSum [ i ] = False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isSum [ i ] == True ) : NEW_LINE INDENT perfectPowers . append ( i ) NEW_LINE continue NEW_LINE DEDENT j = i * i NEW_LINE while ( j > 0 and j < ( n + 1 ) ) : NEW_LINE INDENT isSum [ j ] = True NEW_LINE j *= i NEW_LINE DEDENT DEDENT for i in range ( len ( perfectPowers ) ) : NEW_LINE INDENT isSum [ perfectPowers [ i ] ] = False NEW_LINE DEDENT for i in range ( len ( perfectPowers ) ) : NEW_LINE INDENT for j in range ( len ( perfectPowers ) ) : NEW_LINE INDENT sum = ( perfectPowers [ i ] + perfectPowers [ j ] ) NEW_LINE if ( sum < ( n + 1 ) ) : NEW_LINE INDENT isSum [ sum ] = True NEW_LINE DEDENT DEDENT DEDENT return isSum [ n ] NEW_LINE DEDENT
def countEvenSum ( low , high , k ) : NEW_LINE INDENT even_count = high / 2 - ( low - 1 ) / 2 NEW_LINE odd_count = ( high + 1 ) / 2 - low / 2 NEW_LINE even_sum = 1 NEW_LINE odd_sum = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT prev_even = even_sum NEW_LINE prev_odd = odd_sum NEW_LINE even_sum = ( ( prev_even * even_count ) + ( prev_odd * odd_count ) ) NEW_LINE odd_sum = ( ( prev_even * odd_count ) + ( prev_odd * even_count ) ) NEW_LINE DEDENT print ( int ( even_sum ) ) NEW_LINE DEDENT
def update ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT arr [ i ] += ( i + 1 ) NEW_LINE DEDENT DEDENT
def incrementCount ( arr , N ) : NEW_LINE INDENT min = 0 NEW_LINE while ( check ( arr , N ) != True ) : NEW_LINE INDENT update ( arr , N ) NEW_LINE min += 1 NEW_LINE DEDENT print ( min ) NEW_LINE DEDENT
def incrementCount ( arr , N ) : NEW_LINE INDENT mini = arr [ 0 ] - arr [ 1 ] NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT mini = min ( mini , arr [ i - 1 ] - arr [ i ] ) NEW_LINE DEDENT print ( mini ) NEW_LINE DEDENT
def Length_Diagonals ( a , theta ) : NEW_LINE INDENT p = a * math . sqrt ( 2 + ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE q = a * math . sqrt ( 2 - ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE return [ p , q ] NEW_LINE DEDENT
def solve ( s , x , y ) : NEW_LINE INDENT res = 0 NEW_LINE for c in s : NEW_LINE INDENT if ( ord ( c ) - ord ( '0' ) == x ) : NEW_LINE INDENT res += 1 NEW_LINE x , y = y , x NEW_LINE DEDENT DEDENT if ( x != y and res % 2 == 1 ) : NEW_LINE INDENT res -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def find_min ( s ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT count = max ( count , solve ( s , i , j ) ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maxORminusXOR ( N ) : NEW_LINE INDENT MSB = int ( math . log2 ( N ) ) NEW_LINE M = 0 NEW_LINE for i in range ( MSB + 1 ) : NEW_LINE INDENT M += ( 1 << i ) NEW_LINE DEDENT return M NEW_LINE DEDENT
def No_of_Triangle ( N , K ) : NEW_LINE INDENT if ( N < K ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT Tri_up = 0 NEW_LINE Tri_up = ( ( N - K + 1 ) * ( N - K + 2 ) ) // 2 NEW_LINE Tri_down = 0 NEW_LINE Tri_down = ( ( N - 2 * K + 1 ) * ( N - 2 * K + 2 ) ) // 2 NEW_LINE return Tri_up + Tri_down NEW_LINE DEDENT DEDENT
def AddEdge ( u , v ) : NEW_LINE INDENT if u not in adj : NEW_LINE INDENT adj [ u ] = [ ] NEW_LINE DEDENT if v not in adj : NEW_LINE INDENT adj [ v ] = [ ] NEW_LINE DEDENT adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT
def Matching_dfs ( u , p ) : NEW_LINE INDENT global max_matching NEW_LINE for i in range ( len ( adj [ u ] ) ) : NEW_LINE INDENT if ( adj [ u ] [ i ] != p ) : NEW_LINE INDENT Matching_dfs ( adj [ u ] [ i ] , u ) NEW_LINE DEDENT DEDENT if ( not used [ u ] and not used [ p ] and p != 0 ) : NEW_LINE INDENT max_matching += 1 NEW_LINE used [ u ] = 1 NEW_LINE used [ p ] = 1 NEW_LINE DEDENT DEDENT
def canMake ( n , ar ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT if ( ar [ 0 ] < ar [ 1 ] ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i < n and ar [ i - 1 ] < ar [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( i + 1 < n and ar [ i ] > ar [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( i >= n - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( ar [ 0 ] > ar [ 1 ] ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i < n and ar [ i - 1 ] > ar [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( i + 1 < n and ar [ i ] < ar [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( i >= n - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( ar [ i - 1 ] <= ar [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT DEDENT
def check_length ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n = n >> 1 NEW_LINE ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def check_ith_bit ( n , i ) : NEW_LINE INDENT if ( n & ( 1 << ( i - 1 ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def findPair ( A , B , N ) : NEW_LINE INDENT X = N - B + A NEW_LINE if ( X % 2 != 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT else : NEW_LINE INDENT X = X // 2 NEW_LINE Y = N - X NEW_LINE print ( X , Y ) NEW_LINE DEDENT DEDENT
def countSetBitsUtil ( x ) : NEW_LINE INDENT if ( x < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( x % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + ( countSetBitsUtil ( x / 2 ) ) NEW_LINE DEDENT DEDENT
def countSetBits ( L , R ) : NEW_LINE INDENT bitCount = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT bitCount += countSetBitsUtil ( i ) NEW_LINE DEDENT return bitCount NEW_LINE DEDENT
def countSetBit ( n ) : NEW_LINE INDENT i = 0 NEW_LINE ans = 0 NEW_LINE while ( ( 1 << i ) <= n ) : NEW_LINE INDENT k = True NEW_LINE change = 1 << i NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT ans += 0 if k == True else 1 NEW_LINE if ( change == 1 ) : NEW_LINE INDENT k = False if k == True else True NEW_LINE change = 1 << i NEW_LINE DEDENT else : NEW_LINE INDENT change -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countSetBits ( L , R ) : NEW_LINE INDENT return abs ( countSetBit ( R ) - countSetBit ( L - 1 ) ) NEW_LINE DEDENT
def countSetBits ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT n = i NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += ( n & 1 ) NEW_LINE n = n >> 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countElement ( A , N , B , M , K ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT currentElement = B [ i ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT diff = abs ( currentElement - A [ j ] ) NEW_LINE if ( diff <= K ) : NEW_LINE INDENT cnt += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( cnt ) NEW_LINE DEDENT
def AreaofRectangle ( L , W ) : NEW_LINE INDENT area = ( W + L ) * ( W + L ) / 2 NEW_LINE return area NEW_LINE DEDENT
def downToZero ( n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT return n NEW_LINE DEDENT dp = [ - 1 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 2 NEW_LINE dp [ 3 ] = 3 NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT sqr = ( int ) ( math . sqrt ( i ) ) NEW_LINE best = sys . maxsize NEW_LINE while ( sqr > 1 ) : NEW_LINE INDENT if ( i % sqr == 0 ) : NEW_LINE INDENT best = min ( best , 1 + dp [ sqr ] ) NEW_LINE DEDENT sqr -= 1 NEW_LINE DEDENT best = min ( best , 1 + dp [ i - 1 ] ) NEW_LINE dp [ i ] = best NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def downToZero ( n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT else : NEW_LINE INDENT return 4 NEW_LINE DEDENT DEDENT
def maxSubset ( A , flag ) : NEW_LINE INDENT n = len ( A ) NEW_LINE sum = 0 NEW_LINE if ( flag ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT A [ i ] = - A [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( A [ i ] > 0 ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def findBest ( A ) : NEW_LINE INDENT x = maxSubset ( A , 0 ) NEW_LINE y = maxSubset ( A , 1 ) NEW_LINE y = - y NEW_LINE y += A [ 0 ] NEW_LINE y = - y NEW_LINE return max ( x , y ) NEW_LINE DEDENT
def getMinCost ( A , B , N ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( N ) : NEW_LINE INDENT mini = min ( mini , min ( A [ i ] , B [ i ] ) ) NEW_LINE DEDENT return mini * ( 2 * N - 1 ) NEW_LINE DEDENT
def countSwaps ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE ind , res = 1 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( ind < n and A [ ind ] == A [ i ] ) : NEW_LINE INDENT ind += 1 NEW_LINE DEDENT if ( ind < n and A [ ind ] > A [ i ] ) : NEW_LINE INDENT res += 1 NEW_LINE ind += 1 NEW_LINE DEDENT if ( ind >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countSwaps ( A , n ) : NEW_LINE INDENT mp = { } NEW_LINE max_frequency = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ i ] in mp : NEW_LINE INDENT mp [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT max_frequency = max ( max_frequency , mp [ A [ i ] ] ) NEW_LINE DEDENT return n - max_frequency NEW_LINE DEDENT
def min_operation ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT ans += abs ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += abs ( a [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minimumrequired ( A , N ) : NEW_LINE INDENT K = N NEW_LINE while ( K > 0 ) : NEW_LINE INDENT if ( K % 2 ) == 1 : NEW_LINE INDENT ans = K NEW_LINE break NEW_LINE DEDENT ispalindrome = 1 NEW_LINE for i in range ( 0 , K // 2 ) : NEW_LINE INDENT if ( A [ i ] != A [ K - 1 - i ] ) : NEW_LINE INDENT ispalindrome = 0 NEW_LINE DEDENT DEDENT if ( ispalindrome == 1 ) : NEW_LINE INDENT ans = K // 2 NEW_LINE K = K // 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = K NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def count ( n , k ) : NEW_LINE INDENT count = ( pow ( 10 , k ) - pow ( 10 , k - 1 ) ) NEW_LINE print ( count ) NEW_LINE DEDENT
def maxSelections ( A , n , k ) : NEW_LINE INDENT A . sort ( ) NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + A [ i ] NEW_LINE if ( sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE return count NEW_LINE DEDENT DEDENT
def getMaxDifference ( N ) : NEW_LINE INDENT M = - 1 NEW_LINE maxDiff = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT diff = ( N ^ i ) - ( N & i ) NEW_LINE if ( diff >= maxDiff ) : NEW_LINE INDENT maxDiff = diff NEW_LINE M = i NEW_LINE DEDENT DEDENT return M NEW_LINE DEDENT
def findM ( N ) : NEW_LINE INDENT M = 0 NEW_LINE MSB = int ( math . log ( N ) ) NEW_LINE for i in range ( MSB ) : NEW_LINE INDENT if ( ( N & ( 1 << i ) ) == 0 ) : NEW_LINE INDENT M += ( 1 << i ) NEW_LINE DEDENT DEDENT return M NEW_LINE DEDENT
def func ( N , P ) : NEW_LINE INDENT sumUptoN = ( N * ( N + 1 ) / 2 ) NEW_LINE sumOfMultiplesOfP = 0 NEW_LINE if ( N < P ) : NEW_LINE INDENT return sumUptoN NEW_LINE DEDENT elif ( ( N / P ) == 1 ) : NEW_LINE INDENT return sumUptoN - P + 1 NEW_LINE DEDENT sumOfMultiplesOfP = ( ( ( N / P ) * ( 2 * P + ( N / P - 1 ) * P ) ) / 2 ) NEW_LINE return ( sumUptoN + func ( N / P , P ) - sumOfMultiplesOfP ) NEW_LINE DEDENT
def countStrings ( A , B , K ) : NEW_LINE INDENT X = ( A + B ) // ( K + 1 ) NEW_LINE return ( min ( A , min ( B , X ) ) * ( K + 1 ) ) NEW_LINE DEDENT
def countPairs ( a , n , k ) : NEW_LINE INDENT l = [ 0 ] * n NEW_LINE p = [ 0 ] * ( 11 ) NEW_LINE p [ 0 ] = 1 NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT p [ i ] = ( p [ i - 1 ] * 10 ) % k NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE while ( x > 0 ) : NEW_LINE INDENT l [ i ] += 1 NEW_LINE x //= 10 NEW_LINE DEDENT rem [ l [ i ] ] [ a [ i ] % k ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , 11 ) : NEW_LINE INDENT r = ( a [ i ] * p [ j ] ) % k NEW_LINE xr = ( k - r ) % k NEW_LINE ans += rem [ j ] [ xr ] NEW_LINE if ( l [ i ] == j and ( r + a [ i ] % k ) % k == 0 ) : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def isDivisible ( N ) : NEW_LINE INDENT return ( N - 1 ) % 3 != 0 NEW_LINE DEDENT
def maxLengthSubArray ( A , N ) : NEW_LINE INDENT forward = [ 0 ] * N NEW_LINE backward = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i == 0 or A [ i ] != A [ i - 1 ] : NEW_LINE INDENT forward [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT forward [ i ] = forward [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if i == N - 1 or A [ i ] != A [ i + 1 ] : NEW_LINE INDENT backward [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT backward [ i ] = backward [ i + 1 ] + 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i ] != A [ i + 1 ] ) : NEW_LINE INDENT ans = max ( ans , min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def countDigitSum ( N , K ) : NEW_LINE INDENT l = pow ( 10 , N - 1 ) NEW_LINE r = pow ( 10 , N ) - 1 NEW_LINE count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT num = i NEW_LINE digits = [ 0 ] * N NEW_LINE for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT digits [ j ] = num % 10 NEW_LINE num //= 10 NEW_LINE DEDENT sum = 0 NEW_LINE flag = 0 NEW_LINE for j in range ( 0 , K ) : NEW_LINE INDENT sum += digits [ j ] NEW_LINE DEDENT for j in range ( 1 , N - K + 1 ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for m in range ( j , j + K ) : NEW_LINE INDENT curr_sum += digits [ m ] NEW_LINE DEDENT if ( sum != curr_sum ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countDigitSum ( N , K ) : NEW_LINE INDENT l = pow ( 10 , N - 1 ) NEW_LINE r = pow ( 10 , N ) - 1 NEW_LINE count = 0 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT num = i NEW_LINE digits = [ 0 ] * ( N ) NEW_LINE for j in range ( N - 1 , 0 , - 1 ) : NEW_LINE INDENT digits [ j ] = num % 10 NEW_LINE num //= 10 NEW_LINE DEDENT sum = 0 NEW_LINE flag = 0 NEW_LINE for j in range ( 0 , K ) : NEW_LINE INDENT sum += digits [ j ] NEW_LINE DEDENT for j in range ( K , N ) : NEW_LINE INDENT if ( sum - digits [ j - K ] + digits [ j ] != sum ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def nth_angle ( N , a , b , n ) : NEW_LINE INDENT nth = 0 NEW_LINE nth = a + ( n - 1 ) * b NEW_LINE return nth NEW_LINE DEDENT
def findTriplet ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE st = [ ] NEW_LINE h3 = - sys . maxsize - 1 NEW_LINE h1 = sys . maxsize NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT h1 = arr [ i ] NEW_LINE while ( len ( st ) > 0 and st [ - 1 ] < arr [ i ] ) : NEW_LINE INDENT h3 = st [ - 1 ] NEW_LINE del st [ - 1 ] NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE if ( h1 < h3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findWays ( arr , i , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT printVector ( arr ) NEW_LINE DEDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT arr . append ( j ) NEW_LINE findWays ( arr , j , n - j ) NEW_LINE del arr [ - 1 ] NEW_LINE DEDENT DEDENT
def distinctNumbers ( arr , m , n ) : NEW_LINE INDENT count = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] = count . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT fre_arr = [ 0 ] * ( n + 1 ) NEW_LINE for it in count : NEW_LINE INDENT fre_arr [ count [ it ] ] += 1 NEW_LINE DEDENT ans = len ( count ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = fre_arr [ i ] NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT t = min ( temp , m // i ) NEW_LINE ans -= t NEW_LINE m -= i * t NEW_LINE DEDENT return ans NEW_LINE DEDENT
def no_of_moves ( Matrix , x , y ) : NEW_LINE INDENT moves = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( Matrix [ i ] [ j ] != 0 ) : NEW_LINE INDENT moves += abs ( x - i ) NEW_LINE moves += abs ( y - j ) NEW_LINE DEDENT DEDENT DEDENT print ( moves ) NEW_LINE DEDENT
def is_linear ( s ) : NEW_LINE INDENT tmp = 0 NEW_LINE first = s [ 0 ] NEW_LINE pos = 0 NEW_LINE while pos < len ( s ) : NEW_LINE INDENT if ( s [ pos ] != first ) : NEW_LINE INDENT return False NEW_LINE DEDENT tmp += 1 NEW_LINE pos += tmp NEW_LINE DEDENT return True NEW_LINE DEDENT
def DFS ( U , vis , adj ) : NEW_LINE INDENT vis [ U ] = 1 NEW_LINE for V in adj [ U ] : NEW_LINE INDENT if ( vis [ V ] == 0 ) : NEW_LINE INDENT DFS ( V , vis , adj ) NEW_LINE DEDENT DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def find_gcd ( arr ) : NEW_LINE INDENT if ( len ( arr ) == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT g = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT g = gcd ( g , arr [ i ] ) NEW_LINE DEDENT return g NEW_LINE DEDENT
def maxm_gcd ( root , ans ) : NEW_LINE INDENT global maxm NEW_LINE if ( not root ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT ans . append ( root . val ) NEW_LINE maxm = max ( find_gcd ( ans ) , maxm ) NEW_LINE return NEW_LINE DEDENT ans . append ( root . val ) NEW_LINE maxm_gcd ( root . left , ans ) NEW_LINE maxm_gcd ( root . right , ans ) NEW_LINE DEDENT
def checkInfinite ( s ) : NEW_LINE INDENT flag = 1 NEW_LINE N = len ( s ) NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( s [ i ] == chr ( ord ( s [ i + 1 ] ) + 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( s [ i ] == 'a' and s [ i + 1 ] == 'z' ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT DEDENT
def calculateWays ( arr1 , arr2 , N ) : NEW_LINE INDENT A = arr2 [ 0 ] NEW_LINE B = arr2 [ 1 ] NEW_LINE C = arr2 [ 2 ] NEW_LINE D = arr2 [ 3 ] NEW_LINE ans , b , c , d = 0 , 0 , 0 , 0 NEW_LINE while b <= B and b * 5 <= ( N ) : NEW_LINE INDENT c = 0 NEW_LINE while ( c <= C and b * 5 + c * 10 <= ( N ) ) : NEW_LINE INDENT d = 0 NEW_LINE while ( d <= D and b * 5 + c * 10 + d * 20 <= ( N ) ) : NEW_LINE INDENT if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT d += 1 NEW_LINE DEDENT c += 1 NEW_LINE DEDENT b += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def calculateWays ( arr1 , arr2 , N ) : NEW_LINE INDENT A = arr2 [ 0 ] NEW_LINE B = arr2 [ 1 ] NEW_LINE C = arr2 [ 2 ] NEW_LINE D = arr2 [ 3 ] NEW_LINE ans = 0 NEW_LINE for b in range ( 0 , B + 1 ) : NEW_LINE INDENT if ( b * 5 > N ) : NEW_LINE INDENT break NEW_LINE DEDENT for a in range ( 0 , A + 1 ) : NEW_LINE INDENT if ( a + b * 5 > N ) : NEW_LINE INDENT break NEW_LINE DEDENT ways [ a + b * 5 ] += 5 NEW_LINE DEDENT DEDENT for c in range ( 0 , C ) : NEW_LINE INDENT if ( c * 10 > N ) : NEW_LINE INDENT break NEW_LINE DEDENT for d in range ( 0 , D ) : NEW_LINE INDENT if ( c * 10 + d * 20 > N ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += ways [ N - c * 10 - d * 20 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def removeAll ( arr , n ) : NEW_LINE INDENT if arr [ 0 ] < arr [ n - 1 ] : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def minNum ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 210 * ( 10 ** ( n - 1 ) // 210 + 1 ) ) NEW_LINE DEDENT DEDENT
def findMinimum ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE x = [ 0 ] * ( n + 1 ) NEW_LINE s = s [ : : - 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT if ( x [ i ] == 1 ) : NEW_LINE INDENT x [ i + 1 ] = 1 NEW_LINE x [ i ] = 0 NEW_LINE DEDENT elif ( i and x [ i - 1 ] == 1 ) : NEW_LINE INDENT x [ i + 1 ] = 1 NEW_LINE x [ i - 1 ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT c = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( x [ i ] != 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def splitIntoFibonacci ( S ) : NEW_LINE INDENT seq = [ ] NEW_LINE splitIntoFibonacciHelper ( 0 , S , seq ) NEW_LINE if ( len ( seq ) >= 3 ) : NEW_LINE INDENT for i in seq : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 , end = '' ) NEW_LINE DEDENT DEDENT
def countChanges ( matrix , n , m ) : NEW_LINE INDENT dist = n + m - 1 NEW_LINE freq = [ [ 0 ] * 10 for i in range ( dist ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT freq [ i + j ] [ matrix [ i ] [ j ] ] += 1 NEW_LINE DEDENT DEDENT min_changes_sum = 0 NEW_LINE for i in range ( dist // 2 ) : NEW_LINE INDENT maximum = 0 NEW_LINE total_values = 0 NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT maximum = max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE DEDENT min_changes_sum += ( total_values - maximum ) NEW_LINE DEDENT return min_changes_sum NEW_LINE DEDENT
def numberOfPairs ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return n // 2 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT DEDENT
def good_pair ( st , N ) : NEW_LINE INDENT countStr = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT res = st [ i ] + st [ j ] NEW_LINE vowel = [ 0 ] * 5 NEW_LINE for k in range ( len ( res ) ) : NEW_LINE INDENT if ( res [ k ] == 'a' ) : NEW_LINE INDENT vowel [ 0 ] = 1 NEW_LINE DEDENT elif ( res [ k ] == 'e' ) : NEW_LINE INDENT vowel [ 1 ] = 1 NEW_LINE DEDENT elif ( res [ k ] == 'i' ) : NEW_LINE INDENT vowel [ 2 ] = 1 NEW_LINE DEDENT elif ( res [ k ] == 'o' ) : NEW_LINE INDENT vowel [ 3 ] = 1 NEW_LINE DEDENT elif ( res [ k ] == 'u' ) : NEW_LINE INDENT vowel [ 4 ] = 1 NEW_LINE DEDENT DEDENT temp = 0 NEW_LINE for ind in range ( 5 ) : NEW_LINE INDENT if ( vowel [ ind ] == 1 ) : NEW_LINE INDENT temp += 1 NEW_LINE DEDENT DEDENT if ( temp == 5 ) : NEW_LINE INDENT countStr += 1 NEW_LINE DEDENT DEDENT DEDENT return countStr NEW_LINE DEDENT
def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE j = i NEW_LINE while ( j * i <= N ) : NEW_LINE INDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT j += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def generatePrimeFactors ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE sum = 0 NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while ( N > 1 ) : NEW_LINE INDENT N //= s [ N ] NEW_LINE if ( curr == s [ N ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT sum = sum + cnt NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def LCM ( a , b ) : NEW_LINE INDENT lcm = a if a > b else b NEW_LINE while ( True ) : NEW_LINE INDENT if ( lcm % a == 0 and lcm % b == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT lcm += 1 NEW_LINE DEDENT DEDENT return lcm NEW_LINE DEDENT
def countSubstrings ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = ( n * ( n - 1 ) ) // 2 NEW_LINE cnt = 1 NEW_LINE v = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( cnt ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT if ( cnt > 0 ) : NEW_LINE INDENT v . append ( cnt ) NEW_LINE DEDENT for i in range ( len ( v ) - 1 ) : NEW_LINE INDENT answer -= ( v [ i ] + v [ i + 1 ] - 1 ) NEW_LINE DEDENT return answer NEW_LINE DEDENT
def find_max ( n , k ) : NEW_LINE INDENT X = [ 0 ] * 32 NEW_LINE cnt = 0 NEW_LINE i = 31 NEW_LINE while ( i >= 0 and cnt != k ) : NEW_LINE INDENT if ( ( n & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT X [ i ] = 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT s = "" NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if X [ i ] == 0 : NEW_LINE INDENT s += '0' NEW_LINE DEDENT else : NEW_LINE INDENT s += '1' NEW_LINE DEDENT DEDENT return int ( s , 2 ) NEW_LINE DEDENT
def get_palindrome_time ( str ) : NEW_LINE INDENT hh = ( ( ord ( str [ 0 ] ) - 48 ) * 10 + ( ord ( str [ 1 ] ) - 48 ) ) NEW_LINE mm = ( ( ord ( str [ 3 ] ) - 48 ) * 10 + ( ord ( str [ 4 ] ) - 48 ) ) NEW_LINE requiredTime = 0 NEW_LINE while ( hh % 10 != mm // 10 or hh // 10 != mm % 10 ) : NEW_LINE INDENT mm += 1 NEW_LINE if ( mm == 60 ) : NEW_LINE INDENT mm = 0 NEW_LINE hh += 1 NEW_LINE DEDENT if ( hh == 24 ) : NEW_LINE INDENT hh = 0 NEW_LINE DEDENT requiredTime += 1 NEW_LINE DEDENT return requiredTime NEW_LINE DEDENT
def maximumSubarraySum ( a , n , subarrays ) : NEW_LINE INDENT maxsum = 0 NEW_LINE prefixArray = [ 0 ] * n NEW_LINE for i in range ( len ( subarrays ) ) : NEW_LINE INDENT prefixArray [ subarrays [ i ] [ 0 ] - 1 ] += 1 NEW_LINE prefixArray [ subarrays [ i ] [ 1 ] ] -= 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT prefixArray [ i ] += prefixArray [ i - 1 ] NEW_LINE DEDENT prefixArray . sort ( ) NEW_LINE prefixArray . reverse ( ) NEW_LINE a . sort ( ) NEW_LINE a . reverse ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxsum += a [ i ] * prefixArray [ i ] NEW_LINE DEDENT return maxsum NEW_LINE DEDENT
def maxProfit ( value , N , K ) : NEW_LINE INDENT value . sort ( ) NEW_LINE maxval = value [ N - 1 ] NEW_LINE maxProfit = 0 NEW_LINE while True : NEW_LINE INDENT curr_val = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr_val += value [ i ] NEW_LINE if ( curr_val <= K ) : NEW_LINE INDENT maxProfit = max ( curr_val + maxval * ( i + 1 ) , maxProfit ) NEW_LINE DEDENT DEDENT if not next_permutation ( value ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return maxProfit NEW_LINE DEDENT
def findways ( s , x ) : NEW_LINE INDENT if ( x > len ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = len ( s ) NEW_LINE freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT se = set ( ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT se . add ( freq [ i ] ) NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE for i in range ( x // 2 ) : NEW_LINE INDENT count = 0 NEW_LINE for u in se : NEW_LINE INDENT if ( u >= 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans *= count NEW_LINE DEDENT p = list ( se ) NEW_LINE val = p [ - 1 ] NEW_LINE p . pop ( - 1 ) NEW_LINE se = set ( p ) NEW_LINE if ( val > 2 ) : NEW_LINE INDENT se . add ( val - 2 ) NEW_LINE DEDENT DEDENT if ( x % 2 != 0 ) : NEW_LINE INDENT count = 0 NEW_LINE for u in se : NEW_LINE INDENT if ( u > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = ans * count NEW_LINE DEDENT return ans NEW_LINE DEDENT
def checkUniqueFrequency ( arr , n ) : NEW_LINE INDENT freq = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT uniqueFreq = set ( [ ] ) NEW_LINE for i in freq : NEW_LINE INDENT if ( freq [ i ] in uniqueFreq ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT uniqueFreq . add ( freq [ i ] ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def specialSum ( n ) : NEW_LINE INDENT sum = n * ( n + 1 ) // 2 NEW_LINE a = Log2 ( n ) NEW_LINE sum = sum + power ( 2 , a + 1 ) - 1 NEW_LINE return sum NEW_LINE DEDENT
def findMin ( x , Y ) : NEW_LINE INDENT y = str ( Y ) NEW_LINE n = len ( y ) NEW_LINE p = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT p [ i ] = ( ord ( y [ i ] ) - ord ( '0' ) ) NEW_LINE if ( i > 0 ) : NEW_LINE INDENT p [ i ] += p [ i - 1 ] NEW_LINE DEDENT DEDENT n - 1 NEW_LINE k = 0 NEW_LINE while True : NEW_LINE INDENT d = 0 NEW_LINE if ( i >= 0 ) : NEW_LINE INDENT d = ( ord ( y [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT for j in range ( d + 1 , 10 ) : NEW_LINE INDENT r = ( ( i > 0 ) * p [ i - 1 ] + j ) NEW_LINE if ( x - r >= 0 and x - r <= 9 * k ) : NEW_LINE INDENT suf = helper ( k , x - r ) NEW_LINE pre = "" NEW_LINE if ( i > 0 ) : NEW_LINE INDENT pre = y [ 0 : i ] NEW_LINE DEDENT cur = chr ( j + ord ( '0' ) ) NEW_LINE pre += cur NEW_LINE return pre + suf NEW_LINE DEDENT DEDENT i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT
def largestNumber ( n , X , Y ) : NEW_LINE INDENT maxm = max ( X , Y ) NEW_LINE Y = X + Y - maxm NEW_LINE X = maxm NEW_LINE Xs = 0 NEW_LINE Ys = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % Y == 0 ) : NEW_LINE INDENT Xs += n NEW_LINE n = 0 NEW_LINE DEDENT else : NEW_LINE INDENT n -= X NEW_LINE Ys += X NEW_LINE DEDENT DEDENT if ( n == 0 ) : NEW_LINE INDENT while ( Xs > 0 ) : NEW_LINE INDENT Xs -= 1 NEW_LINE print ( X , end = '' ) NEW_LINE DEDENT while ( Ys > 0 ) : NEW_LINE INDENT Ys -= 1 NEW_LINE print ( Y , end = '' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def check ( unit_digit , X ) : NEW_LINE INDENT for times in range ( 1 , 11 ) : NEW_LINE INDENT digit = ( X * times ) % 10 NEW_LINE if ( digit == unit_digit ) : NEW_LINE INDENT return times NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def getNum ( N , X ) : NEW_LINE INDENT unit_digit = N % 10 NEW_LINE times = check ( unit_digit , X ) NEW_LINE if ( times == - 1 ) : NEW_LINE INDENT return times NEW_LINE DEDENT else : NEW_LINE INDENT if ( N >= ( times * X ) ) : NEW_LINE INDENT return times NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT
def dfs ( g , cost , u , pre ) : NEW_LINE INDENT global canTake , best NEW_LINE vis [ u ] = True NEW_LINE dp [ u ] = cost [ u ] NEW_LINE check = 1 NEW_LINE cur = cost [ u ] NEW_LINE for x in g [ u ] : NEW_LINE INDENT if ( vis [ x ] and x != pre ) : NEW_LINE INDENT check = 0 NEW_LINE DEDENT elif ( not vis [ x ] ) : NEW_LINE INDENT check &= dfs ( g , cost , x , u ) NEW_LINE cur = max ( cur , cost [ u ] + dp [ x ] ) NEW_LINE DEDENT DEDENT dp [ u ] = cur NEW_LINE if ( not check ) : NEW_LINE INDENT canTake += cost [ u ] NEW_LINE DEDENT else : NEW_LINE INDENT best = max ( best , dp [ u ] ) NEW_LINE DEDENT return check NEW_LINE DEDENT
def FindMaxCost ( g , cost , source ) : NEW_LINE INDENT dfs ( g , cost , source , - 1 ) NEW_LINE print ( canTake + best ) NEW_LINE DEDENT
def after_rev ( v ) : NEW_LINE INDENT mini = 0 NEW_LINE count = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT count += v [ i ] NEW_LINE if ( count > 0 ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT if ( mini > count ) : NEW_LINE INDENT mini = count NEW_LINE DEDENT DEDENT return mini NEW_LINE DEDENT
def moduloEquality ( A , B , n , m ) : NEW_LINE INDENT mapA = defaultdict ( int ) NEW_LINE mapB = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mapA [ A [ i ] ] += 1 NEW_LINE mapB [ B [ i ] ] += 1 NEW_LINE DEDENT possibleValues = set ( ) NEW_LINE FirstElement = B [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cur = A [ i ] NEW_LINE if cur > FirstElement : NEW_LINE INDENT possibleValues . add ( m - cur + FirstElement ) NEW_LINE DEDENT else : NEW_LINE INDENT possibleValues . add ( FirstElement - cur ) NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE for it in possibleValues : NEW_LINE INDENT possible = True NEW_LINE for it2 in mapA : NEW_LINE INDENT if ( mapA [ it2 ] != mapB [ ( it2 + it ) % m ] ) : NEW_LINE INDENT possible = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( possible ) : NEW_LINE INDENT ans = min ( ans , it ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countCyclicShifts ( S , n ) : NEW_LINE INDENT aux = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( S [ i ] == '(' ) : NEW_LINE INDENT aux [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT aux [ i ] = - 1 NEW_LINE DEDENT DEDENT mn = aux [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT aux [ i ] += aux [ i - 1 ] NEW_LINE mn = min ( mn , aux [ i ] ) NEW_LINE DEDENT if ( aux [ n - 1 ] != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( aux [ i ] == mn ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def count ( k , s ) : NEW_LINE INDENT ar = [ 0 ] * len ( s ) NEW_LINE end = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT for j in range ( i , len ( s ) ) : NEW_LINE INDENT if ( j <= i + k ) : NEW_LINE INDENT ar [ j ] = - 1 NEW_LINE end = j NEW_LINE DEDENT DEDENT i = end NEW_LINE DEDENT DEDENT end = 0 NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT if ( j >= i - k ) : NEW_LINE INDENT ar [ j ] = - 1 NEW_LINE end = j NEW_LINE DEDENT DEDENT i = end NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE end = 0 NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if ( ar [ j ] == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE for g in range ( j , len ( s ) ) : NEW_LINE INDENT if ( g <= j + k ) : NEW_LINE INDENT ar [ g ] = - 1 NEW_LINE end = g NEW_LINE DEDENT DEDENT j = end - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def find_set ( a ) : NEW_LINE INDENT global N , v , g , vis , In , low , parent , rnk , bridges , n , m , timer , diameter NEW_LINE if parent [ a ] == a : NEW_LINE INDENT return a NEW_LINE DEDENT parent [ a ] = find_set ( parent [ a ] ) NEW_LINE return parent [ a ] NEW_LINE DEDENT
def union_set ( a , b ) : NEW_LINE INDENT global N , v , g , vis , In , low , parent , rnk , bridges , n , m , timer , diameter NEW_LINE x , y = find_set ( a ) , find_set ( b ) NEW_LINE if x == y : NEW_LINE INDENT return NEW_LINE DEDENT if rnk [ x ] == rnk [ y ] : NEW_LINE INDENT rnk [ x ] += 1 NEW_LINE DEDENT if rnk [ y ] > rnk [ x ] : NEW_LINE INDENT swap ( x , y ) NEW_LINE DEDENT parent [ y ] = x NEW_LINE DEDENT
def dfsBridges ( a , par ) : NEW_LINE INDENT global N , v , g , vis , In , low , parent , rnk , bridges , n , m , timer , diameter NEW_LINE vis [ a ] = True NEW_LINE timer += 1 NEW_LINE In [ a ] , low [ a ] = timer , timer NEW_LINE for i in range ( len ( v [ a ] ) ) : NEW_LINE INDENT if v [ a ] [ i ] == par : NEW_LINE INDENT continue NEW_LINE DEDENT if vis [ v [ a ] [ i ] ] : NEW_LINE INDENT low [ a ] = min ( low [ a ] , In [ v [ a ] [ i ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dfsBridges ( v [ a ] [ i ] , a ) NEW_LINE DEDENT low [ a ] = min ( low [ a ] , low [ v [ a ] [ i ] ] ) NEW_LINE if In [ a ] < low [ v [ a ] [ i ] ] : NEW_LINE INDENT bridges . append ( [ v [ a ] [ i ] , a ] ) NEW_LINE DEDENT else : NEW_LINE INDENT union_set ( v [ a ] [ i ] , a ) NEW_LINE DEDENT DEDENT DEDENT
def isPalindrome ( l , r , s ) : NEW_LINE INDENT while ( l <= r ) : NEW_LINE INDENT if ( s [ l ] != s [ r ] ) : NEW_LINE INDENT return bool ( False ) NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return bool ( True ) NEW_LINE DEDENT
def numWays ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( isPalindrome ( 0 , i , s ) and isPalindrome ( i + 1 , n - 1 , s ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maxProfit ( prices , n ) : NEW_LINE INDENT profit = 0 NEW_LINE currentDay = n - 1 NEW_LINE while ( currentDay > 0 ) : NEW_LINE INDENT day = currentDay - 1 NEW_LINE while ( day >= 0 and ( prices [ currentDay ] > prices [ day ] ) ) : NEW_LINE INDENT profit += ( prices [ currentDay ] - prices [ day ] ) NEW_LINE day -= 1 NEW_LINE DEDENT currentDay = day NEW_LINE DEDENT return profit NEW_LINE DEDENT
def numberofsubstrings ( str , k , charArray ) : NEW_LINE INDENT N = len ( str ) NEW_LINE available = [ 0 ] * 26 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT available [ ord ( charArray [ i ] ) - ord ( 'a' ) ] = 1 NEW_LINE DEDENT lastPos = - 1 NEW_LINE ans = ( N * ( N + 1 ) ) / 2 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( available [ ord ( str [ i ] ) - ord ( 'a' ) ] == 0 ) : NEW_LINE INDENT ans -= ( ( i - lastPos ) * ( N - i ) ) NEW_LINE lastPos = i NEW_LINE DEDENT DEDENT print ( int ( ans ) ) NEW_LINE DEDENT
def isOddStringPalindrome ( str , n ) : NEW_LINE INDENT oddStringSize = n // 2 NEW_LINE lengthOdd = True if ( oddStringSize % 2 == 1 ) else False NEW_LINE s = [ ] NEW_LINE i = 1 NEW_LINE c = 0 NEW_LINE while ( i < n and c < oddStringSize // 2 ) : NEW_LINE INDENT s . append ( str [ i ] ) NEW_LINE i += 2 NEW_LINE c += 1 NEW_LINE DEDENT if ( lengthOdd ) : NEW_LINE INDENT i = i + 2 NEW_LINE DEDENT while ( i < n and len ( s ) > 0 ) : NEW_LINE INDENT if ( s [ len ( s ) - 1 ] == str [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isOddStringPalindrome ( Str , n ) : NEW_LINE INDENT left , right = 0 , 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT left = 1 NEW_LINE right = n - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = 1 NEW_LINE right = n - 2 NEW_LINE DEDENT while ( left < n and right >= 0 and left < right ) : NEW_LINE INDENT if ( Str [ left ] != Str [ right ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT left += 2 NEW_LINE right -= 2 NEW_LINE DEDENT return True NEW_LINE DEDENT
def min_remove ( st ) : NEW_LINE INDENT N = len ( st ) NEW_LINE prefix_a = [ 0 ] * ( N + 1 ) NEW_LINE prefix_b = [ 0 ] * ( N + 1 ) NEW_LINE prefix_c = [ 0 ] * ( N + 1 ) NEW_LINE prefix_a [ 0 ] = 0 NEW_LINE prefix_b [ 0 ] = 0 NEW_LINE prefix_c [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( st [ i - 1 ] == 'a' ) : NEW_LINE INDENT prefix_a [ i ] = ( prefix_a [ i - 1 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix_a [ i ] = prefix_a [ i - 1 ] NEW_LINE DEDENT if ( st [ i - 1 ] == 'b' ) : NEW_LINE INDENT prefix_b [ i ] = ( prefix_b [ i - 1 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix_b [ i ] = prefix_b [ i - 1 ] NEW_LINE DEDENT if ( st [ i - 1 ] == 'c' ) : NEW_LINE INDENT prefix_c [ i ] = ( prefix_c [ i - 1 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix_c [ i ] = prefix_c [ i - 1 ] NEW_LINE DEDENT DEDENT maxi = - sys . maxsize - 1 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( i , N + 1 ) : NEW_LINE INDENT maxi = max ( maxi , ( prefix_a [ i ] + ( prefix_b [ j ] - prefix_b [ i ] ) + ( prefix_c [ N ] - prefix_c [ j ] ) ) ) NEW_LINE DEDENT DEDENT print ( ( N - maxi ) ) NEW_LINE DEDENT
def maximum_partition ( strr ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE c = 0 NEW_LINE r = 0 NEW_LINE m = { } NEW_LINE for i in range ( len ( strr ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( strr [ i ] not in m ) : NEW_LINE INDENT m [ strr [ i ] ] = i NEW_LINE DEDENT DEDENT i = 0 NEW_LINE k = m [ strr [ i ] ] NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT if ( i <= k ) : NEW_LINE INDENT c = c + 1 NEW_LINE k = max ( k , m [ strr [ i ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT r = r + 1 NEW_LINE c = 1 NEW_LINE k = max ( k , m [ strr [ i ] ] ) NEW_LINE DEDENT DEDENT if ( c != 0 ) : NEW_LINE INDENT r = r + 1 NEW_LINE DEDENT return r NEW_LINE DEDENT
def findAns ( mat , x , y , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT ans += ( abs ( x - i ) + abs ( y - j ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def solve ( P , n ) : NEW_LINE INDENT arr = [ ] NEW_LINE arr . append ( 0 ) NEW_LINE for x in P : NEW_LINE INDENT arr . append ( x ) NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == i ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT if ( arr [ n ] == n ) : NEW_LINE INDENT arr [ n - 1 ] , arr [ n ] = arr [ n ] , arr [ n - 1 ] NEW_LINE cnt += 1 NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT
def longestSequence ( n , arr ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE prev = - sys . maxsize - 1 NEW_LINE ans = 0 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( arr [ l ] > prev and arr [ r ] > prev ) : NEW_LINE INDENT if ( arr [ l ] < arr [ r ] ) : NEW_LINE INDENT ans += 1 NEW_LINE prev = arr [ l ] NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE prev = arr [ r ] NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT elif ( arr [ l ] > prev ) : NEW_LINE INDENT ans += 1 NEW_LINE prev = arr [ l ] NEW_LINE l += 1 NEW_LINE DEDENT elif ( arr [ r ] > prev ) : NEW_LINE INDENT ans += 1 NEW_LINE prev = arr [ r ] NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def solve ( n , m , x , y , d ) : NEW_LINE INDENT top = min ( d , x - 1 ) NEW_LINE down = min ( d , n - x ) NEW_LINE left = min ( d , y - 1 ) NEW_LINE right = min ( d , m - y ) NEW_LINE quad1 = top * left NEW_LINE quad2 = left * down NEW_LINE quad3 = down * right NEW_LINE quad4 = right * top NEW_LINE totalsq = ( quad1 + quad2 + quad3 + quad4 ) NEW_LINE singleBlocks = ( top + down + left + right + 1 ) NEW_LINE return totalsq + singleBlocks NEW_LINE DEDENT
def minchanges ( mat ) : NEW_LINE INDENT count = 0 NEW_LINE left = 0 NEW_LINE right = N + M - 2 NEW_LINE while ( left < right ) : NEW_LINE INDENT mp = { } NEW_LINE totalsize = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( i + j == left ) : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = mp . get ( mat [ i ] [ j ] , 0 ) + 1 NEW_LINE totalsize += 1 NEW_LINE DEDENT elif ( i + j == right ) : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = mp . get ( mat [ i ] [ j ] , 0 ) + 1 NEW_LINE totalsize += 1 NEW_LINE DEDENT DEDENT DEDENT changes = 0 NEW_LINE for itr in mp : NEW_LINE INDENT changes = max ( changes , mp [ itr ] ) NEW_LINE DEDENT count += totalsize - changes NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def CountLongestSubarrays ( arr , n , k ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT if ( s % k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT ini = 0 NEW_LINE while ( ini < n and arr [ ini ] % k == 0 ) : NEW_LINE INDENT ini += 1 NEW_LINE DEDENT final = n - 1 NEW_LINE while ( final >= 0 and arr [ final ] % k == 0 ) : NEW_LINE INDENT final -= 1 NEW_LINE DEDENT sum , count = 0 , 0 NEW_LINE if ( ini == n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT length = max ( n - 1 - ini , final ) NEW_LINE DEDENT for i in range ( length ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % k != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for i in range ( length , n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE sum = sum + arr [ i - length ] NEW_LINE if ( sum % k != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT DEDENT
def nC3 ( n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( n * ( n - 1 ) * ( n - 2 ) ) / 6 NEW_LINE DEDENT
def count_triplet ( arr , N , K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , 1000000 + 1 ) : NEW_LINE INDENT for j in range ( i , 1000000 + 1 , i ) : NEW_LINE INDENT mul [ i ] += freq [ j ] NEW_LINE DEDENT cnt [ i ] = nC3 ( mul [ i ] ) NEW_LINE DEDENT for i in range ( 1000000 , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 2 * i , 1000000 + 1 , i ) : NEW_LINE INDENT cnt [ i ] -= cnt [ j ] NEW_LINE DEDENT DEDENT print ( "Number of triplets with GCD" " {0} are {1}" . format ( K , int ( cnt [ K ] ) ) ) NEW_LINE DEDENT
def getMinJumps ( s ) : NEW_LINE INDENT ones = [ ] NEW_LINE jumps , median , ind = 0 , 0 , 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT ones . append ( i ) NEW_LINE DEDENT DEDENT if ( len ( ones ) == 0 ) : NEW_LINE INDENT return jumps NEW_LINE DEDENT median = ones [ len ( ones ) // 2 ] NEW_LINE ind = median NEW_LINE for i in range ( ind , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT jumps += ind - i NEW_LINE ind -= 1 NEW_LINE DEDENT DEDENT ind = median NEW_LINE for i in range ( ind , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT jumps += i - ind NEW_LINE ind += 1 NEW_LINE DEDENT DEDENT return jumps NEW_LINE DEDENT
def getSubsequence ( ar ) : NEW_LINE INDENT N = len ( ar ) NEW_LINE ans = [ ] NEW_LINE ans . append ( ar [ 0 ] ) NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT if ( ar [ i ] > ar [ i - 1 ] ) : NEW_LINE INDENT if ( i < N - 1 and ar [ i ] <= ar [ i + 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( ar [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i < N - 1 and ar [ i + 1 ] < ar [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( ar [ i ] ) NEW_LINE DEDENT DEDENT DEDENT ans . append ( ar [ N - 1 ] ) NEW_LINE for it in ans : NEW_LINE INDENT print ( it , end = " " ) NEW_LINE DEDENT DEDENT
def isSubseqPossible ( arr , N , K ) : NEW_LINE INDENT i = 0 NEW_LINE odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( odd == 0 or ( even == 0 and K % 2 == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def print_path ( N , jump , coin ) : NEW_LINE INDENT if ( jump > coin or jump * ( N - 1 ) < coin ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT else : NEW_LINE INDENT pos = 1 NEW_LINE while ( jump > 0 ) : NEW_LINE INDENT tmp = min ( N - 1 , coin - ( jump - 1 ) ) NEW_LINE if ( pos + tmp <= N ) : NEW_LINE INDENT pos += tmp NEW_LINE DEDENT else : NEW_LINE INDENT pos -= tmp NEW_LINE DEDENT print ( pos , end = " " ) NEW_LINE coin -= tmp NEW_LINE jump -= 1 NEW_LINE DEDENT DEDENT DEDENT
def countEvenOdd ( arr , n , K ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = bin ( arr [ i ] ) . count ( '1' ) NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT y = bin ( K ) . count ( '1' ) NEW_LINE if ( y & 1 ) : NEW_LINE INDENT print ( "Even =" , odd , ", Odd =" , even ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Even =" , even , ", Odd =" , odd ) NEW_LINE DEDENT DEDENT
def findMinHike ( arr , n ) : NEW_LINE INDENT arr . insert ( 0 , INF ) NEW_LINE arr . append ( INF ) NEW_LINE hike = [ 0 ] * ( n + 2 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] >= arr [ i ] and arr [ i ] <= arr [ i + 1 ] ) : NEW_LINE INDENT hike [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] and arr [ i ] <= arr [ i + 1 ] ) : NEW_LINE INDENT hike [ i ] = hike [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] >= arr [ i ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT hike [ i ] = hike [ i + 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT hike [ i ] = max ( hike [ i - 1 ] , hike [ i + 1 ] ) + 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( hike [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def preprocess ( ) : NEW_LINE INDENT DFS ( 1 , - 1 ) NEW_LINE DEDENT
def maximumSumSubarray ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= 0 and arr [ i ] not in mp ) : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT first = 0 NEW_LINE last = 0 NEW_LINE ans = 0 NEW_LINE INF = 1e6 NEW_LINE for i in mp : NEW_LINE INDENT mx = i NEW_LINE curr = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( curr == 0 ) : NEW_LINE INDENT curr_start = j NEW_LINE DEDENT if arr [ j ] > mx : NEW_LINE INDENT val = - INF NEW_LINE DEDENT else : NEW_LINE INDENT val = arr [ j ] NEW_LINE DEDENT curr += val NEW_LINE if ( curr < 0 ) : NEW_LINE INDENT curr = 0 NEW_LINE DEDENT if ( curr > ans ) : NEW_LINE INDENT ans = curr NEW_LINE first = curr_start NEW_LINE last = j NEW_LINE DEDENT DEDENT DEDENT print ( first + 1 , last + 1 ) NEW_LINE DEDENT
def make_xor_half ( arr ) : NEW_LINE INDENT sum = 0 NEW_LINE xr = 0 NEW_LINE for a in arr : NEW_LINE INDENT sum += a NEW_LINE xr ^= a NEW_LINE DEDENT if ( 2 * xr == sum ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( xr == 0 ) : NEW_LINE INDENT arr . append ( sum ) NEW_LINE return 1 NEW_LINE DEDENT arr . append ( xr ) NEW_LINE arr . append ( sum + xr ) NEW_LINE return 2 NEW_LINE DEDENT
def makeZero ( x , y , a , b ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT tot_cost = ( y - x ) * a NEW_LINE cost1 = 2 * x * a NEW_LINE cost2 = x * b NEW_LINE tot_cost += min ( cost1 , cost2 ) NEW_LINE print ( tot_cost ) NEW_LINE DEDENT
def splitFraction ( n , d ) : NEW_LINE INDENT ar = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ar . append ( 0 ) NEW_LINE DEDENT first = d + n - 1 NEW_LINE ar [ 0 ] = first NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT temp = first - 1 NEW_LINE ar [ i ] = first * temp NEW_LINE first -= 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ar [ i ] % n == 0 : NEW_LINE INDENT print ( "1/" , int ( ar [ i ] / n ) , "," , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , "/" , ar [ i ] , "," , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def numPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ j ] % arr [ i ] == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def minOperations ( s , len ) : NEW_LINE INDENT operationCnt = 0 NEW_LINE st = LifoQueue ( ) NEW_LINE cntClosing = 0 NEW_LINE for i in range ( 0 , len ) : NEW_LINE INDENT if ( s [ i ] == '{' ) : NEW_LINE INDENT if ( cntClosing > 0 ) : NEW_LINE INDENT operationCnt += 1 NEW_LINE st . pop ( ) NEW_LINE DEDENT st . put ( s [ i ] ) NEW_LINE cntClosing = 0 NEW_LINE DEDENT elif ( st . empty ( ) ) : NEW_LINE INDENT st . put ( '{' ) NEW_LINE operationCnt += 1 NEW_LINE cntClosing = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntClosing = ( cntClosing + 1 ) % 2 NEW_LINE if ( cntClosing == 0 ) : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT DEDENT DEDENT operationCnt += st . qsize ( ) * 2 - cntClosing + 1 NEW_LINE return operationCnt NEW_LINE DEDENT
def longestSubsequence ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = 0 NEW_LINE prev = '-' NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( prev != s [ i ] ) : NEW_LINE INDENT prev = s [ i ] NEW_LINE answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def calculate ( pos , prev , s ) : NEW_LINE INDENT if ( pos == len ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT val = 0 NEW_LINE if ( ord ( s [ pos ] ) - ord ( 'a' ) + 1 != prev ) : NEW_LINE INDENT val = max ( val , 1 + calculate ( pos + 1 , ord ( s [ pos ] ) - ord ( 'a' ) + 1 , s ) ) NEW_LINE DEDENT val = max ( val , calculate ( pos + 1 , prev , s ) ) NEW_LINE dp [ pos ] [ prev ] = val NEW_LINE return dp [ pos ] [ prev ] NEW_LINE DEDENT
def longestSubsequence ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE return calculate ( 0 , 0 , s ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def MinDiff ( n ) : NEW_LINE INDENT val = 2 ** n NEW_LINE sep = n // 2 NEW_LINE grp1 = 0 NEW_LINE grp2 = 0 NEW_LINE grp1 = grp1 + val NEW_LINE for i in range ( 1 , sep ) : NEW_LINE INDENT grp1 = grp1 + 2 ** i NEW_LINE DEDENT for i in range ( sep , n ) : NEW_LINE INDENT grp2 = grp2 + 2 ** i NEW_LINE DEDENT print ( abs ( grp1 - grp2 ) ) NEW_LINE DEDENT
def minOccupiedPosition ( A , n ) : NEW_LINE INDENT minPos = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( A [ i ] > 0 ) : NEW_LINE INDENT minPos += 1 NEW_LINE i += 2 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return minPos NEW_LINE DEDENT
def missingnumber ( n , arr ) -> int : NEW_LINE INDENT mn = sys . maxsize NEW_LINE mx = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i > 0 and arr [ i ] == - 1 and arr [ i - 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i - 1 ] ) NEW_LINE mx = max ( mx , arr [ i - 1 ] ) NEW_LINE DEDENT if ( i < ( n - 1 ) and arr [ i ] == - 1 and arr [ i + 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i + 1 ] ) NEW_LINE mx = max ( mx , arr [ i + 1 ] ) NEW_LINE DEDENT DEDENT res = ( mx + mn ) / 2 NEW_LINE return res NEW_LINE DEDENT
def Minsteps ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( n > 1 ) : NEW_LINE INDENT if ( n % 5 == 0 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE n = n / 5 NEW_LINE continue NEW_LINE DEDENT elif ( n % 4 == 0 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE n = n / 4 NEW_LINE continue NEW_LINE DEDENT elif ( n % 3 == 0 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE n = n / 3 NEW_LINE continue NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE n = n / 2 NEW_LINE continue NEW_LINE DEDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countDist ( arr1 , n , arr2 , m , k ) : NEW_LINE INDENT count = 0 NEW_LINE smallest = arr2 [ 0 ] NEW_LINE largest = arr2 [ 0 ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT smallest = max ( smallest , arr2 [ i ] ) NEW_LINE largest = min ( largest , arr1 [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( abs ( arr1 [ i ] - smallest ) > k or abs ( arr1 [ i ] - largest ) > k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def palindromeWinner ( S ) : NEW_LINE INDENT freq = [ 0 for i in range ( 0 , 26 ) ] NEW_LINE count = 0 NEW_LINE for i in range ( 0 , len ( S ) ) : NEW_LINE INDENT if ( freq [ ord ( S [ i ] ) - 97 ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT freq [ ord ( S [ i ] ) - 97 ] += 1 NEW_LINE DEDENT unique = 0 NEW_LINE duplicate = 0 NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT if ( freq [ i ] == 1 ) : NEW_LINE INDENT unique += 1 NEW_LINE DEDENT elif ( freq [ i ] >= 2 ) : NEW_LINE INDENT duplicate += 1 NEW_LINE DEDENT DEDENT if ( unique == 1 and ( unique + duplicate ) == count ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def findMinimumK ( a , n , S ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return math . ceil ( ( ( S + 1 ) * 1.0 ) / ( sum * 1.0 ) ) NEW_LINE DEDENT
def MinimumValue ( a , n ) : NEW_LINE INDENT answer = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT answer = min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def MinimumValue ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minXor = sys . maxsize NEW_LINE val = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] NEW_LINE minXor = min ( minXor , val ) NEW_LINE DEDENT return minXor NEW_LINE DEDENT
def count_element ( N , K , arr ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT answer = 0 NEW_LINE for i in mp : NEW_LINE INDENT if i + K in mp : NEW_LINE INDENT answer += mp [ i ] NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def largestNum ( n ) : NEW_LINE INDENT num = 0 NEW_LINE max_setBits = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT setBits = bin ( i ) . count ( '1' ) NEW_LINE if ( setBits >= max_setBits ) : NEW_LINE INDENT num = i NEW_LINE max_setBits = setBits NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT
def find_count ( n ) : NEW_LINE INDENT mpp = { } NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if digit_xor ( i ) in mpp : NEW_LINE INDENT mpp [ digit_xor ( i ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ digit_xor ( i ) ] = 1 NEW_LINE DEDENT DEDENT maxm = 0 NEW_LINE for x in mpp : NEW_LINE INDENT if ( mpp [ x ] > maxm ) : NEW_LINE INDENT maxm = mpp [ x ] NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT
def findString ( N , K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( chr ( ord ( 'A' ) + i % K ) , end = "" ) NEW_LINE DEDENT DEDENT
def digit_prod ( x ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( x ) : NEW_LINE INDENT prod = prod * ( x % 10 ) NEW_LINE x = x // 10 NEW_LINE DEDENT return prod NEW_LINE DEDENT
def find_count ( n ) : NEW_LINE INDENT mpp = { } NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = digit_prod ( i ) NEW_LINE if x in mpp : NEW_LINE INDENT mpp [ x ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ x ] = 1 NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE maxm = 0 NEW_LINE for value in mpp . values ( ) : NEW_LINE INDENT if ( value > maxm ) : NEW_LINE INDENT maxm = value NEW_LINE ans = 1 NEW_LINE DEDENT elif ( value == maxm ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findSubarraySum ( arr , n , K ) : NEW_LINE INDENT prevSum = { i : 0 for i in range ( 100 ) } NEW_LINE res = 0 NEW_LINE currsum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT currsum += arr [ i ] NEW_LINE if ( currsum == K ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( currsum - K ) in prevSum : NEW_LINE INDENT res += ( prevSum [ currsum - K ] ) NEW_LINE DEDENT prevSum [ currsum ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countSubarray ( arr , n , K ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( isPrime ( arr [ i ] ) ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT print ( findSubarraySum ( arr , n , K ) ) NEW_LINE DEDENT
def find_maxm ( arr , n ) : NEW_LINE INDENT mpp = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] in mpp : NEW_LINE INDENT mpp [ arr [ i ] ] = mpp [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for key in mpp : NEW_LINE INDENT value = key NEW_LINE freq = mpp [ key ] NEW_LINE if value == freq : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def pow ( x , y ) : NEW_LINE INDENT if ( y == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = pow ( x , y // 2 ) NEW_LINE temp *= temp NEW_LINE if ( y & 1 ) : NEW_LINE INDENT temp *= x NEW_LINE DEDENT return temp NEW_LINE DEDENT
def getLargestSum ( N ) : NEW_LINE INDENT max_sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N + 1 , 1 ) : NEW_LINE INDENT if ( i * j % ( i + j ) == 0 ) : NEW_LINE INDENT max_sum = max ( max_sum , i + j ) NEW_LINE DEDENT DEDENT DEDENT return max_sum NEW_LINE DEDENT
def getLargestSum ( N ) : NEW_LINE INDENT for i in range ( 1 , int ( N ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , int ( N ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT k = N // j NEW_LINE a = k * i NEW_LINE b = k * j NEW_LINE if ( a <= N and b <= N and a * b % ( a + b ) == 0 ) : NEW_LINE INDENT max_sum = max ( max_sum , a + b ) NEW_LINE DEDENT DEDENT DEDENT return max_sum NEW_LINE DEDENT
def findSum ( L , R ) : NEW_LINE INDENT arr = [ ] NEW_LINE i = 0 NEW_LINE x = 2 NEW_LINE k = 0 NEW_LINE while ( i <= R ) : NEW_LINE INDENT arr . insert ( k , i + x ) NEW_LINE k += 1 NEW_LINE if ( i + 1 <= R ) : NEW_LINE INDENT arr . insert ( k , i + 1 + x ) NEW_LINE DEDENT k += 1 NEW_LINE x *= - 1 NEW_LINE i += 2 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def GetMinSubarrayLength ( a , n ) : NEW_LINE INDENT ans = max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE lo = 0 NEW_LINE hi = n - 1 NEW_LINE while ( lo < n and a [ lo ] % ans == 0 ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT while ( hi > lo and a [ hi ] % ans == 0 ) : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT return ( hi - lo + 1 ) NEW_LINE DEDENT
def count ( s ) : NEW_LINE INDENT cnt , ans = 0 , 0 NEW_LINE N = len ( s ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( s [ i ] == 'R' ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( s [ i ] == 'L' ) : NEW_LINE INDENT ans += cnt NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - 10 ** 9 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def minimumValue ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE answer = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT answer += arr [ i ] * arr [ i ] NEW_LINE DEDENT return answer * ( 2 * k - 2 ) NEW_LINE DEDENT
def sumOfDigits ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum += ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def height ( s , adj , visited ) : NEW_LINE INDENT visited [ s ] = 1 NEW_LINE h = 0 NEW_LINE for child in adj [ s ] : NEW_LINE INDENT if ( visited [ child ] == 0 ) : NEW_LINE INDENT h = max ( h , 1 + height ( child , adj , visited ) ) NEW_LINE DEDENT DEDENT return h NEW_LINE DEDENT
def minimumGroups ( adj , N ) : NEW_LINE INDENT visited = [ 0 for i in range ( N + 1 ) ] NEW_LINE groups = - sys . maxsize NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT comHeight = height ( i , adj , visited ) NEW_LINE groups = max ( groups , comHeight ) NEW_LINE DEDENT DEDENT return groups NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT flag = 1 NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if flag == 1 else False ) NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT
def countInterestingPrimes ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT j = 1 NEW_LINE while ( j * j * j * j <= i ) : NEW_LINE INDENT if ( isPerfectSquare ( i - j * j * j * j ) ) : NEW_LINE INDENT answer += 1 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT
def sumDivisibles ( A , B , M ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( i % M == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def findSmallNum ( N , K ) : NEW_LINE INDENT rem = N % K NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return N - rem NEW_LINE DEDENT DEDENT
def findLargeNum ( N , K ) : NEW_LINE INDENT rem = ( N + K ) % K NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return N + K - rem NEW_LINE DEDENT DEDENT
def sumDivisibles ( A , B , M ) : NEW_LINE INDENT sum = 0 NEW_LINE first = findSmallNum ( A , M ) NEW_LINE last = findLargeNum ( B , M ) NEW_LINE if ( first < A ) : NEW_LINE INDENT first += M NEW_LINE DEDENT if ( last > B ) : NEW_LINE INDENT first -= M NEW_LINE DEDENT n = ( B // M ) - ( A - 1 ) // M NEW_LINE return n * ( first + last ) // 2 NEW_LINE DEDENT
def check ( A , B , N ) : NEW_LINE INDENT pq1 = [ ] NEW_LINE pq2 = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT heapq . heappush ( pq1 , - A [ i ] ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT heapq . heappush ( pq2 , - B [ i ] ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if - pq1 [ 0 ] > - pq2 [ 0 ] : NEW_LINE INDENT c += 1 NEW_LINE heapq . heappop ( pq1 ) NEW_LINE heapq . heappop ( pq2 ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( pq2 ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT heapq . heappop ( pq2 ) NEW_LINE DEDENT DEDENT return ( c ) NEW_LINE DEDENT
def calcSum ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , k + i ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT print ( sum , end = " " ) NEW_LINE DEDENT DEDENT
def calcSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( sum , end = " " ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = ( sum - arr [ i - k ] ) + arr [ i ] NEW_LINE print ( sum , end = " " ) NEW_LINE DEDENT DEDENT
def getPairs ( A , B , n ) : NEW_LINE INDENT D = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT D [ i ] = A [ i ] - B [ i ] NEW_LINE DEDENT D . sort ( ) NEW_LINE total = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( D [ i ] > 0 ) : NEW_LINE INDENT total += n - i - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = bisect . bisect_right ( D , - D [ i ] , 0 , len ( D ) ) NEW_LINE total += n - k NEW_LINE DEDENT DEDENT return total NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) / gcd ( a , b ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countPairs ( a , n ) : NEW_LINE INDENT frequency = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT frequency [ a [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for x in frequency . keys ( ) : NEW_LINE INDENT f = frequency [ x ] NEW_LINE count += f * ( f - 1 ) // 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
def preCompute ( N ) : NEW_LINE INDENT global size NEW_LINE fact [ 0 ] = 1 NEW_LINE i = 1 NEW_LINE while fact [ i - 1 ] <= N : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE size += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def findLCS ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return len ( mp ) NEW_LINE DEDENT
def segments ( n ) : NEW_LINE INDENT if ( n == 1 or n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( "1" , end = "" ) NEW_LINE segments ( n - 2 ) NEW_LINE DEDENT elif ( n % 2 == 1 ) : NEW_LINE INDENT print ( "7" , end = "" ) NEW_LINE segments ( n - 3 ) NEW_LINE DEDENT DEDENT
def countOperations ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] += 1 NEW_LINE arr [ i + 1 ] += 1 NEW_LINE count += 2 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findMinimumSubsequences ( A , B ) : NEW_LINE INDENT numberOfSubsequences = 1 NEW_LINE sizeOfB = len ( B ) NEW_LINE sizeOfA = len ( A ) NEW_LINE inf = 1000000 NEW_LINE next = [ [ inf for i in range ( sizeOfB ) ] for i in range ( 26 ) ] NEW_LINE for i in range ( sizeOfB ) : NEW_LINE INDENT next [ ord ( B [ i ] ) - ord ( 'a' ) ] [ i ] = i NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( sizeOfB - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( next [ i ] [ j ] == inf ) : NEW_LINE INDENT next [ i ] [ j ] = next [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT pos = 0 NEW_LINE i = 0 NEW_LINE while ( i < sizeOfA ) : NEW_LINE INDENT if ( pos == 0 and next [ ord ( A [ i ] ) - ord ( 'a' ) ] [ pos ] == inf ) : NEW_LINE INDENT numberOfSubsequences = - 1 NEW_LINE break NEW_LINE DEDENT elif ( pos < sizeOfB and next [ ord ( A [ i ] ) - ord ( 'a' ) ] [ pos ] < inf ) : NEW_LINE INDENT nextIndex = next [ ord ( A [ i ] ) - ord ( 'a' ) ] [ pos ] + 1 NEW_LINE pos = nextIndex NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT numberOfSubsequences += 1 NEW_LINE pos = 0 NEW_LINE DEDENT DEDENT return numberOfSubsequences NEW_LINE DEDENT
def convolution ( x , h , n , m ) : NEW_LINE INDENT row_vec = [ 0 ] * MAX_SIZE NEW_LINE col_vec = [ 0 ] * MAX_SIZE NEW_LINE out = [ 0 ] * MAX_SIZE NEW_LINE circular_shift_mat = [ [ 0 for i in range ( MAX_SIZE ) ] for j in range ( MAX_SIZE ) ] NEW_LINE if ( n > m ) : NEW_LINE INDENT maxSize = n NEW_LINE DEDENT else : NEW_LINE INDENT maxSize = m NEW_LINE DEDENT for i in range ( maxSize ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT row_vec [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT row_vec [ i ] = x [ i ] NEW_LINE DEDENT DEDENT for i in range ( maxSize ) : NEW_LINE INDENT if ( i >= m ) : NEW_LINE INDENT col_vec [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT col_vec [ i ] = h [ i ] NEW_LINE DEDENT DEDENT k = 0 NEW_LINE d = 0 NEW_LINE for i in range ( maxSize ) : NEW_LINE INDENT curIndex = k - d NEW_LINE for j in range ( maxSize ) : NEW_LINE INDENT circular_shift_mat [ j ] [ i ] = row_vec [ curIndex % maxSize ] NEW_LINE curIndex += 1 NEW_LINE DEDENT k = maxSize NEW_LINE d += 1 NEW_LINE DEDENT for i in range ( maxSize ) : NEW_LINE INDENT for j in range ( maxSize ) : NEW_LINE INDENT out [ i ] += circular_shift_mat [ i ] [ j ] * col_vec [ j ] NEW_LINE DEDENT print ( out [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def maxLength ( str , len ) : NEW_LINE INDENT res = 0 NEW_LINE lastPos = [ 0 ] * MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT lastPos [ i ] = - 1 NEW_LINE DEDENT for i in range ( len ) : NEW_LINE INDENT C = ord ( str [ i ] ) - ord ( 'a' ) NEW_LINE if ( lastPos [ C ] != - 1 ) : NEW_LINE INDENT res = max ( len - ( i - lastPos [ C ] - 1 ) - 1 , res ) NEW_LINE DEDENT lastPos [ C ] = i NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxProfit ( profitA , profitB , n ) : NEW_LINE INDENT preSum = [ 0 ] * n NEW_LINE preSum [ 0 ] = profitA [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT preSum [ i ] = preSum [ i - 1 ] + profitA [ i ] NEW_LINE DEDENT suffSum = [ 0 ] * n NEW_LINE suffSum [ n - 1 ] = profitB [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffSum [ i ] = suffSum [ i + 1 ] + profitB [ i ] NEW_LINE DEDENT res = preSum [ n - 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT res = max ( res , preSum [ i ] + suffSum [ i + 1 ] ) NEW_LINE DEDENT res = max ( res , suffSum [ 0 ] ) NEW_LINE return res NEW_LINE DEDENT
def countPartitions ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT min_elem = min ( A ) NEW_LINE if ( min_elem == INT_MAX ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] % min_elem == 0 ) : NEW_LINE INDENT A [ i ] = INT_MAX NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def max_palindrome ( s , n ) : NEW_LINE INDENT flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( s [ i ] ) % 2 != 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT z = 0 NEW_LINE o = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( s [ i ] ) ) : NEW_LINE INDENT if ( s [ i ] [ j ] == '0' ) : NEW_LINE INDENT z += 1 NEW_LINE DEDENT else : NEW_LINE INDENT o += 1 NEW_LINE DEDENT DEDENT DEDENT if ( o % 2 == 0 and z % 2 == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT DEDENT
def minChanges ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT maxElem = 0 NEW_LINE for x in mp : NEW_LINE INDENT maxElem = max ( maxElem , mp [ x ] ) NEW_LINE DEDENT return n - maxElem NEW_LINE DEDENT
def minOperations ( n , m ) : NEW_LINE INDENT a = 0 NEW_LINE k = 1 NEW_LINE p = max ( n , m ) NEW_LINE while ( n != m ) : NEW_LINE INDENT s = float ( p - n + p - m ) NEW_LINE q = ( - 1 + sqrt ( 8 * s + 1 ) ) / 2 NEW_LINE if ( q - floor ( q ) == 0 ) : NEW_LINE INDENT a = q NEW_LINE n = m NEW_LINE DEDENT p = p + 1 NEW_LINE DEDENT return a NEW_LINE DEDENT
def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n // 2 NEW_LINE DEDENT DEDENT
def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxNum ( n , k ) : NEW_LINE INDENT l = int ( math . log2 ( n ) ) + 1 NEW_LINE a = [ 0 for i in range ( 0 , l ) ] NEW_LINE decBinary ( a , n ) NEW_LINE cn = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( a [ i ] == 0 and cn < k ) : NEW_LINE INDENT a [ i ] = 1 NEW_LINE cn = cn + 1 NEW_LINE DEDENT DEDENT return binaryDec ( a , l ) NEW_LINE DEDENT
def minFlipsSub ( mat , i , j ) : NEW_LINE INDENT cnt0 = 0 NEW_LINE cnt1 = 0 NEW_LINE if ( mat [ i ] [ j ] == '1' ) : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt0 += 1 NEW_LINE DEDENT if ( mat [ i ] [ j + 1 ] == '1' ) : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt0 += 1 NEW_LINE DEDENT if ( mat [ i + 1 ] [ j ] == '1' ) : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt0 += 1 NEW_LINE DEDENT if ( mat [ i + 1 ] [ j + 1 ] == '1' ) : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt0 += 1 NEW_LINE DEDENT return min ( cnt0 , cnt1 ) NEW_LINE DEDENT
def minFlips ( mat , r , c ) : NEW_LINE INDENT res = sys . maxsize NEW_LINE for i in range ( r - 1 ) : NEW_LINE INDENT for j in range ( c - 1 ) : NEW_LINE INDENT res = min ( res , minFlipsSub ( mat , i , j ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findSubSeq ( arr , n , sum ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sum < arr [ i ] ) : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def k_sum ( a , n , k ) : NEW_LINE INDENT r , sum = 0 , 0 NEW_LINE ans = 0 NEW_LINE for l in range ( n ) : NEW_LINE INDENT while ( sum < k ) : NEW_LINE INDENT if ( r == n ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT sum += a [ r ] NEW_LINE r += 1 NEW_LINE DEDENT DEDENT if ( sum < k ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += n - r + 1 NEW_LINE sum -= a [ l ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def balBracketSequence ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( str [ 0 ] == str [ n - 1 ] ) : NEW_LINE INDENT print ( "No" , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT cntForOpen = 0 NEW_LINE cntForClose = 0 NEW_LINE check = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == str [ 0 ] ) : NEW_LINE INDENT cntForOpen += 1 NEW_LINE DEDENT elif str [ i ] == str [ n - 1 ] : NEW_LINE INDENT cntForOpen -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntForOpen += 1 NEW_LINE DEDENT if ( cntForOpen < 0 ) : NEW_LINE INDENT check = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( check and cntForOpen == 0 ) : NEW_LINE INDENT print ( "Yes, " , end = "" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == str [ n - 1 ] ) : NEW_LINE INDENT print ( ')' , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '(' , end = "" ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == str [ 0 ] ) : NEW_LINE INDENT cntForClose += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntForClose -= 1 NEW_LINE DEDENT if ( cntForClose < 0 ) : NEW_LINE INDENT check = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( check and cntForClose == 0 ) : NEW_LINE INDENT print ( "Yes, " , end = "" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == str [ 0 ] ) : NEW_LINE INDENT print ( '(' , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ')' , end = "" ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT DEDENT print ( "NO" , end = "" ) NEW_LINE DEDENT DEDENT
def countSetBits ( n , k ) : NEW_LINE INDENT kth = findK ( n , k ) NEW_LINE return bin ( kth ) . count ( '1' ) NEW_LINE DEDENT
def maxAlpha ( str , len ) : NEW_LINE INDENT first = [ - 1 for x in range ( MAX ) ] NEW_LINE last = [ - 1 for x in range ( MAX ) ] NEW_LINE for i in range ( 0 , len ) : NEW_LINE INDENT index = ord ( str [ i ] ) - 97 NEW_LINE if ( first [ index ] == - 1 ) : NEW_LINE INDENT first [ index ] = i NEW_LINE DEDENT last [ index ] = i NEW_LINE DEDENT ans = - 1 NEW_LINE maxVal = - 1 NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT if ( first [ i ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( ( last [ i ] - first [ i ] ) > maxVal ) : NEW_LINE INDENT maxVal = last [ i ] - first [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return chr ( ans + 97 ) NEW_LINE DEDENT
def maxSum ( arr1 , arr2 , n ) : NEW_LINE INDENT initialParity , finalParity = 0 , 0 NEW_LINE sum = 0 NEW_LINE minPositive = sys . maxsize NEW_LINE maxNegative = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT initialParity += arr2 [ i ] NEW_LINE if ( arr1 [ i ] >= 0 ) : NEW_LINE INDENT finalParity += 1 NEW_LINE sum += arr1 [ i ] NEW_LINE minPositive = min ( minPositive , arr1 [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT maxNegative = max ( maxNegative , arr1 [ i ] ) NEW_LINE DEDENT DEDENT if ( initialParity % 2 == finalParity % 2 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT else : NEW_LINE INDENT if ( minPositive + maxNegative >= 0 ) : NEW_LINE INDENT return sum + maxNegative NEW_LINE DEDENT else : NEW_LINE INDENT return sum - minPositive NEW_LINE DEDENT DEDENT DEDENT
def IsLarger ( X , Y , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( X [ i ] < Y [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def solve ( X , Y , n ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( IsLarger ( X , Y , n ) ) : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT else : NEW_LINE INDENT d = Y [ 0 ] - X [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT X [ i ] += d NEW_LINE DEDENT if ( IsLarger ( X , Y , n ) ) : NEW_LINE INDENT ans = d NEW_LINE DEDENT else : NEW_LINE INDENT ans = d + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def valueofX ( ar , n ) : NEW_LINE INDENT summ = sum ( ar ) NEW_LINE if ( summ % n == 0 ) : NEW_LINE INDENT return summ // n NEW_LINE DEDENT else : NEW_LINE INDENT A = summ // n NEW_LINE B = summ // n + 1 NEW_LINE ValueA = 0 NEW_LINE ValueB = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) NEW_LINE ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) NEW_LINE DEDENT if ( ValueA < ValueB ) : NEW_LINE INDENT return A NEW_LINE DEDENT else : NEW_LINE INDENT return B NEW_LINE DEDENT DEDENT DEDENT
def minLength ( n ) : NEW_LINE INDENT ans = n // 26 NEW_LINE if ( n % 26 != 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minHalls ( lectures , n ) : NEW_LINE INDENT prefix_sum = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix_sum [ lectures [ i ] [ 0 ] ] += 1 NEW_LINE prefix_sum [ lectures [ i ] [ 1 ] + 1 ] -= 1 NEW_LINE DEDENT ans = prefix_sum [ 0 ] NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT prefix_sum [ i ] += prefix_sum [ i - 1 ] NEW_LINE ans = max ( ans , prefix_sum [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minCapacity ( enter , exit , n ) : NEW_LINE INDENT minCap = 0 NEW_LINE currCap = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT currCap = currCap + enter [ i ] - exit [ i ] NEW_LINE minCap = max ( minCap , currCap ) NEW_LINE DEDENT return minCap NEW_LINE DEDENT
def generate ( ) : NEW_LINE INDENT q = deque ( ) NEW_LINE q . append ( "1" ) NEW_LINE q . append ( "2" ) NEW_LINE q . append ( "3" ) NEW_LINE q . append ( "4" ) NEW_LINE q . append ( "5" ) NEW_LINE flag = True NEW_LINE ans . append ( "0" ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT x = q . popleft ( ) NEW_LINE if ( isValidNum ( x ) ) : NEW_LINE INDENT ans . append ( x ) NEW_LINE DEDENT if ( len ( x ) == 6 ) : NEW_LINE INDENT continue NEW_LINE DEDENT for i in range ( 6 ) : NEW_LINE INDENT z = str ( i ) NEW_LINE temp = x + z NEW_LINE q . append ( temp ) NEW_LINE DEDENT DEDENT DEDENT
def comp ( a , b ) : NEW_LINE INDENT if ( len ( a ) == len ( b ) ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return len ( a ) < len ( b ) NEW_LINE DEDENT DEDENT
def findcount ( l , r ) : NEW_LINE INDENT generate ( ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT a = ans [ i ] NEW_LINE if ( comp ( l , a ) and comp ( a , r ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif ( a == l or a == r ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def Findpermutation ( n ) : NEW_LINE INDENT a = [ 0 ] * ( n + 1 ) NEW_LINE a [ 1 ] = n NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT a [ i ] = i - 1 NEW_LINE DEDENT return a NEW_LINE DEDENT
def Balanced_Substring ( s , n ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = [ 0 ] * ( int ( n / 2 ) + 1 ) NEW_LINE d = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '(' ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( d == 1 ) : NEW_LINE INDENT j = 2 NEW_LINE while ( j <= n // 2 + 1 and arr [ j ] != 0 ) : NEW_LINE INDENT arr [ j ] = 0 NEW_LINE DEDENT DEDENT ans += 1 NEW_LINE ans += arr [ d ] NEW_LINE arr [ d ] += 1 NEW_LINE d -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def power ( x , y , mod ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % mod NEW_LINE DEDENT x = ( x * x ) % mod NEW_LINE y = ( y >> 1 ) NEW_LINE DEDENT return ( res % mod ) NEW_LINE DEDENT
def NoOfChords ( A ) : NEW_LINE INDENT mod = 10 ** 9 + 7 NEW_LINE ans = ncr ( 2 * A , A , mod ) NEW_LINE inv = power ( A + 1 , mod - 2 , mod ) NEW_LINE ans = ( ans * inv ) % mod NEW_LINE return ( ans % mod ) NEW_LINE DEDENT
def StrictlyPositiveXor ( A , N ) : NEW_LINE INDENT allxor = 0 NEW_LINE checkallzero = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT allxor ^= A [ i ] NEW_LINE if ( A [ i ] > 0 ) : NEW_LINE INDENT checkallzero = False NEW_LINE DEDENT DEDENT if ( allxor != 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT if ( checkallzero ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT l = N NEW_LINE r = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] > 0 ) : NEW_LINE INDENT l = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( A [ i ] > 0 ) : NEW_LINE INDENT r = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT return max ( N - l , r - 1 ) NEW_LINE DEDENT
def FindMinOperation ( a , n , k ) : NEW_LINE INDENT Q = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Q . append ( a [ i ] ) NEW_LINE DEDENT Q . sort ( ) NEW_LINE ans = 0 NEW_LINE while ( True ) : NEW_LINE INDENT if ( Q [ 0 ] >= k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( len ( Q ) < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = Q [ 0 ] NEW_LINE Q . pop ( 0 ) NEW_LINE y = Q [ 0 ] NEW_LINE Q . pop ( 0 ) NEW_LINE z = ( x * y ) // gcd ( x , y ) NEW_LINE Q . append ( z ) NEW_LINE Q . sort ( ) NEW_LINE ans += 1 NEW_LINE return ans NEW_LINE DEDENT
def findWeights ( X ) : NEW_LINE INDENT sum = 0 NEW_LINE power = 0 NEW_LINE while ( sum < X ) : NEW_LINE INDENT sum = pow ( 3 , power + 1 ) - 1 NEW_LINE sum //= 2 NEW_LINE power += 1 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 1 , power + 1 ) : NEW_LINE INDENT print ( ans , end = " " ) NEW_LINE ans = ans * 3 NEW_LINE DEDENT DEDENT
def solve ( Array , N , K ) : NEW_LINE INDENT count_Arr = [ 0 ] * ( N + 2 ) NEW_LINE factor = 1 NEW_LINE size = N NEW_LINE while ( size ) : NEW_LINE INDENT start = 1 NEW_LINE end = size NEW_LINE count_Arr [ 1 ] += factor * N NEW_LINE count_Arr [ end + 1 ] -= factor * N NEW_LINE factor += 1 NEW_LINE size //= 2 NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT count_Arr [ i ] += count_Arr [ i - 1 ] NEW_LINE DEDENT element = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT element . append ( ( Array [ i ] , count_Arr [ i + 1 ] ) ) NEW_LINE DEDENT element . sort ( ) NEW_LINE start = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT end = start + element [ i ] [ 1 ] - 1 NEW_LINE if ( K >= start and K <= end ) : NEW_LINE INDENT return element [ i ] [ 0 ] NEW_LINE DEDENT start += element [ i ] [ 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def find_distinct ( a , n , q , queries ) : NEW_LINE INDENT check = [ 0 ] * MAX NEW_LINE idx = [ 0 ] * MAX NEW_LINE cnt = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( check [ a [ i ] ] == 0 ) : NEW_LINE INDENT idx [ i ] = cnt NEW_LINE check [ a [ i ] ] = 1 NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT idx [ i ] = cnt - 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , q ) : NEW_LINE INDENT m = queries [ i ] NEW_LINE print ( idx [ m ] , end = " " ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def lcm ( n , m ) : NEW_LINE INDENT return ( n * m ) // gcd ( n , m ) NEW_LINE DEDENT
def matrix_exist ( row , column , r , c ) : NEW_LINE INDENT row_sum = 0 NEW_LINE column_sum = 0 NEW_LINE row_max = - 1 NEW_LINE column_max = - 1 NEW_LINE row_non_zero = 0 NEW_LINE column_non_zero = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT row_sum += row [ i ] NEW_LINE row_max = max ( row_max , row [ i ] ) NEW_LINE if ( row [ i ] ) : NEW_LINE INDENT row_non_zero = row_non_zero + 1 NEW_LINE DEDENT DEDENT for i in range ( c ) : NEW_LINE INDENT column_sum = column_sum + column [ i ] NEW_LINE column_max = max ( column_max , column [ i ] ) NEW_LINE if ( column [ i ] ) : NEW_LINE INDENT column_non_zero = column_non_zero + 1 NEW_LINE DEDENT DEDENT if ( ( row_sum != column_sum ) or ( row_max > column_non_zero ) or ( column_max > row_non_zero ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def longestSubarray ( arr , n ) : NEW_LINE INDENT maxMean = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxMean = max ( maxMean , ( arr [ i ] + arr [ i - 1 ] ) // 2 ) NEW_LINE DEDENT ans = 0 NEW_LINE subarrayLength = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= maxMean ) : NEW_LINE INDENT subarrayLength += 1 NEW_LINE ans = max ( ans , subarrayLength ) NEW_LINE DEDENT else : NEW_LINE INDENT subarrayLength = 0 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maxDistance ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] != arr [ n - 1 ] ) : NEW_LINE INDENT return ( n - 1 ) NEW_LINE DEDENT i = n - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ 0 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT distFirst = - 1 if ( i == 0 ) else i NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ n - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT distLast = - 1 if ( i == n - 1 ) else ( n - 1 - i ) NEW_LINE maxDist = max ( distFirst , distLast ) NEW_LINE return maxDist NEW_LINE DEDENT
def SubarraySum ( a , n , x ) : NEW_LINE INDENT ans = - 10000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT curans = 0 NEW_LINE pq = [ ] NEW_LINE pq2 = [ ] NEW_LINE for k in range ( n ) : NEW_LINE INDENT if ( k >= i and k <= j ) : NEW_LINE INDENT curans += a [ k ] NEW_LINE pq2 . append ( a [ k ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT pq . append ( a [ k ] ) NEW_LINE DEDENT pq . sort ( ) NEW_LINE pq . reverse ( ) NEW_LINE pq2 . sort ( ) NEW_LINE ans = max ( ans , curans ) NEW_LINE for k in range ( 1 , x + 1 ) : NEW_LINE INDENT if ( len ( pq ) == 0 or len ( pq2 ) == 0 or pq2 [ 0 ] >= pq [ 0 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT curans -= pq2 [ 0 ] NEW_LINE pq2 . pop ( 0 ) NEW_LINE curans += pq [ 0 ] NEW_LINE pq . pop ( 0 ) NEW_LINE ans = max ( ans , curans ) NEW_LINE return ans NEW_LINE DEDENT DEDENT DEDENT
def solve ( n , k ) : NEW_LINE INDENT mini = 0 NEW_LINE x1 = 1 NEW_LINE a = [ 0 for i in range ( k ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT mini += x1 NEW_LINE a [ i - 1 ] = x1 NEW_LINE x1 += 1 NEW_LINE DEDENT if ( n < mini ) : NEW_LINE INDENT print ( "-1" , end = "" ) NEW_LINE return NEW_LINE DEDENT rem = n - mini NEW_LINE cnt = int ( rem / k ) NEW_LINE rem = rem % k NEW_LINE for i in range ( k ) : NEW_LINE INDENT a [ i ] += cnt NEW_LINE DEDENT i = k - 1 NEW_LINE while ( i > 0 and rem > 0 ) : NEW_LINE INDENT xx = a [ i - 1 ] * 2 NEW_LINE left = xx - a [ i ] NEW_LINE if ( rem >= left ) : NEW_LINE INDENT a [ i ] = xx NEW_LINE rem -= left NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] += rem NEW_LINE rem = 0 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT sum = a [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT if ( a [ i ] > 2 * a [ i - 1 ] ) : NEW_LINE INDENT print ( "-1" , end = "" ) NEW_LINE return NEW_LINE DEDENT sum += a [ i ] NEW_LINE DEDENT if ( sum != n ) : NEW_LINE INDENT print ( "-1" , end = "" ) NEW_LINE return NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def printMaxNumber ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT print ( "7" , end = "" ) NEW_LINE for i in range ( int ( ( n - 3 ) / 2 ) ) : NEW_LINE INDENT print ( "1" , end = "" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n / 2 ) : NEW_LINE INDENT print ( "1" , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def minOperations ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE freq = [ 0 ] * 1000001 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT maxi = max ( arr ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT for j in range ( i * 2 , maxi + 1 , i ) : NEW_LINE INDENT freq [ j ] = 0 NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def maxCoins ( X , Y ) : NEW_LINE INDENT if ( X < Y ) : NEW_LINE INDENT X , Y = Y , X NEW_LINE DEDENT coins = X NEW_LINE X -= 1 NEW_LINE coins += max ( X , Y ) NEW_LINE return coins NEW_LINE DEDENT
def findElementsCrossed ( arr , a , b , n ) : NEW_LINE INDENT aa = a NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( a == 0 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT b -= 1 NEW_LINE a = min ( aa , a + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b -= 1 NEW_LINE DEDENT DEDENT elif ( b == 0 ) : NEW_LINE INDENT a -= 1 NEW_LINE DEDENT elif ( arr [ i ] == 1 and a < aa ) : NEW_LINE INDENT b -= 1 NEW_LINE a = min ( aa , a + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT a -= 1 NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def pushBinaryToBorder ( arr , n ) : NEW_LINE INDENT count1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 1 ) : NEW_LINE INDENT arr [ count1 ] = arr [ i ] NEW_LINE count1 += 1 NEW_LINE DEDENT DEDENT while ( count1 < n ) : NEW_LINE INDENT arr [ count1 ] = 1 NEW_LINE count1 += 1 NEW_LINE DEDENT lastNonOne = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( not lastNonOne ) : NEW_LINE INDENT lastNonOne = i NEW_LINE DEDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ lastNonOne ] = arr [ i ] NEW_LINE lastNonOne -= 1 NEW_LINE DEDENT DEDENT while ( lastNonOne >= 0 ) : NEW_LINE INDENT arr [ lastNonOne ] = 0 NEW_LINE lastNonOne -= 1 NEW_LINE DEDENT DEDENT
def getMaxValue ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT first = - sys . maxsize - 1 NEW_LINE second = - sys . maxsize - 1 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT if ( second == - sys . maxsize - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return second NEW_LINE DEDENT DEDENT
def isVowel ( ch ) : NEW_LINE INDENT if ch in [ 'a' , 'e' , 'i' , 'o' , 'u' ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def vowelPairs ( s , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) and isVowel ( s [ i + 1 ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def solve ( health , n ) : NEW_LINE INDENT currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT currentgcd = gcd ( currentgcd , health [ i ] ) NEW_LINE DEDENT return currentgcd NEW_LINE DEDENT
def smallestString ( N , A ) : NEW_LINE INDENT ch = 'a' NEW_LINE S = "" NEW_LINE if ( N < 1 or A [ 0 ] != 1 ) : NEW_LINE INDENT S = "-1" NEW_LINE return S NEW_LINE DEDENT S += str ( ch ) NEW_LINE ch = chr ( ord ( ch ) + 1 ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT diff = A [ i ] - A [ i - 1 ] NEW_LINE if ( diff > 1 or diff < 0 or A [ i ] > 26 ) : NEW_LINE INDENT S = "-1" NEW_LINE return S NEW_LINE DEDENT elif ( diff == 0 ) : NEW_LINE INDENT S += 'a' NEW_LINE DEDENT else : NEW_LINE INDENT S += ch NEW_LINE ch = chr ( ord ( ch ) + 1 ) NEW_LINE DEDENT DEDENT return S NEW_LINE DEDENT
def bankNotes ( A , B , S , N ) : NEW_LINE INDENT numerator = S - ( B * N ) NEW_LINE denominator = A - B NEW_LINE if ( numerator % denominator == 0 ) : NEW_LINE INDENT return ( numerator // denominator ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def countSteps ( n ) : NEW_LINE INDENT steps = 0 NEW_LINE while ( n ) : NEW_LINE INDENT largest = int ( sqrt ( n ) ) NEW_LINE n -= ( largest * largest ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT
def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 NEW_LINE maxi = 1 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) NEW_LINE return maxi NEW_LINE DEDENT
def Minimum_Operations ( a , n ) : NEW_LINE INDENT np = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT np [ i ] = np [ i + 1 ] NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT np [ i ] += 1 NEW_LINE DEDENT DEDENT pos = 0 NEW_LINE ans = n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT ans = min ( ans , pos + np [ i + 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findSumofEle ( arr1 , m , arr2 , n , k ) : NEW_LINE INDENT arraySum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arraySum += arr2 [ i ] NEW_LINE DEDENT mean = arraySum / n NEW_LINE sumOfElements = 0 NEW_LINE difference = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT difference = arr1 [ i ] - mean NEW_LINE if ( ( difference < 0 ) and ( k > ( - 1 ) * difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT if ( ( difference >= 0 ) and ( k > difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT DEDENT return sumOfElements NEW_LINE DEDENT
def findIntegers ( n , x , y ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT if ( y - ( n - 1 ) <= 0 ) : NEW_LINE INDENT print ( "-1" , end = "" ) NEW_LINE return NEW_LINE DEDENT ans . append ( y - ( n - 1 ) ) NEW_LINE store = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT store += ans [ i ] * ans [ i ] NEW_LINE DEDENT if ( store < x ) : NEW_LINE INDENT print ( "-1" , end = "" ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def Minsteps ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( m > n ) : NEW_LINE INDENT if ( m & 1 ) : NEW_LINE INDENT m += 1 NEW_LINE ans += 1 NEW_LINE DEDENT m //= 2 NEW_LINE ans += 1 NEW_LINE DEDENT return ans + n - m NEW_LINE DEDENT
def getsum ( x ) : NEW_LINE INDENT return int ( ( x * ( x + 1 ) ) / 2 ) NEW_LINE DEDENT
def maxCandies ( arr , n ) : NEW_LINE INDENT prevBought = arr [ n - 1 ] NEW_LINE candies = prevBought NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT x = min ( prevBought - 1 , arr [ i ] ) NEW_LINE if ( x >= 0 ) : NEW_LINE INDENT candies += x NEW_LINE prevBought = x NEW_LINE DEDENT DEDENT return candies NEW_LINE DEDENT
def sumArr ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def maxSum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE i = 0 NEW_LINE while ( i < n and k > 0 and arr [ i ] < 0 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE k -= 1 NEW_LINE i += 1 NEW_LINE DEDENT if ( k % 2 == 1 ) : NEW_LINE INDENT min = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ min ] > arr [ i ] ) : NEW_LINE INDENT min = i NEW_LINE DEDENT DEDENT arr [ min ] *= - 1 NEW_LINE DEDENT return sumArr ( arr , n ) NEW_LINE DEDENT
def Maxsum ( c1 , c2 , c3 , c4 ) : NEW_LINE INDENT sum = 0 NEW_LINE two34 = min ( c2 , min ( c3 , c4 ) ) NEW_LINE sum = two34 * 234 NEW_LINE c2 -= two34 NEW_LINE sum += min ( c2 , c1 ) * 12 NEW_LINE return sum NEW_LINE DEDENT
def replacedArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE for j in range ( i + 1 , N , 1 ) : NEW_LINE INDENT if ( arr [ j ] > 0 ) : NEW_LINE INDENT pos_sum += arr [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ j ] NEW_LINE DEDENT DEDENT diff = abs ( pos_sum ) - abs ( neg_sum ) NEW_LINE arr [ i ] = abs ( diff ) NEW_LINE DEDENT DEDENT
def maximumResult ( a , b , c ) : NEW_LINE INDENT countOfNegative = 0 NEW_LINE Sum = a + b + c NEW_LINE product = a * b * c NEW_LINE largest = max ( a , b , c ) NEW_LINE smallest = min ( a , b , c ) NEW_LINE if a < 0 : NEW_LINE INDENT countOfNegative += 1 NEW_LINE DEDENT if b < 0 : NEW_LINE INDENT countOfNegative += 1 NEW_LINE DEDENT if c < 0 : NEW_LINE INDENT countOfNegative += 1 NEW_LINE DEDENT if countOfNegative == 0 : NEW_LINE INDENT return ( Sum - largest ) * largest NEW_LINE DEDENT elif countOfNegative == 1 : NEW_LINE INDENT return ( product // smallest ) + smallest NEW_LINE DEDENT elif countOfNegative == 2 : NEW_LINE INDENT return ( product // largest ) + largest NEW_LINE DEDENT elif countOfNegative == 3 : NEW_LINE INDENT return ( Sum - smallest ) * smallest NEW_LINE DEDENT DEDENT
def isPalindrome ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ len ( s ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return true NEW_LINE DEDENT
def ans ( s ) : NEW_LINE INDENT s2 = s NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s2 = s2 [ len ( s2 ) - 1 ] + s2 NEW_LINE s2 = s2 [ 0 : len ( s2 ) - 1 ] NEW_LINE if ( s != s2 and isPalindrome ( s2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def solve ( s ) : NEW_LINE INDENT if ( len ( s ) <= 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT cnt = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT max = cnt [ 0 ] NEW_LINE for i in range ( len ( cnt ) ) : NEW_LINE INDENT if cnt [ i ] > max : NEW_LINE INDENT max = cnt [ i ] NEW_LINE DEDENT DEDENT if ( max >= len ( s ) - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ans ( s ) == True : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT DEDENT
def solveEven ( s ) : NEW_LINE INDENT if len ( s ) % 2 == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT ls = s [ 0 : len ( s ) // 2 ] NEW_LINE rs = s [ len ( s ) // 2 : len ( s ) ] NEW_LINE if ls != rs : NEW_LINE INDENT return 1 NEW_LINE DEDENT return solveEven ( ls ) NEW_LINE DEDENT
def solveOdd ( s ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT
def solve ( s ) : NEW_LINE INDENT if len ( s ) <= 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT cnt = [ 0 ] * 25 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT if max ( cnt ) >= len ( s ) - 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if len ( s ) % 2 == 0 : NEW_LINE INDENT return solveEven ( s ) NEW_LINE DEDENT if len ( s ) % 2 == 1 : NEW_LINE INDENT return solveOdd ( s ) NEW_LINE DEDENT DEDENT
def minChanges ( str , n ) : NEW_LINE INDENT count , zeros , ones = 0 , 0 , 0 NEW_LINE if ( ord ( str [ 0 ] ) != ord ( '1' ) ) : NEW_LINE INDENT count += 1 NEW_LINE ones += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( ord ( str [ i ] ) == ord ( '0' ) ) : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT if ( zeros > ones ) : NEW_LINE INDENT zeros -= 1 NEW_LINE ones += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT ans += b // n NEW_LINE ans += 1 if ( i % n + b % n ) >= n else 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT if ( a > b ) : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT temp = 1 NEW_LINE count = 0 NEW_LINE i = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( a >= i ) : NEW_LINE INDENT temp = i - 1 NEW_LINE DEDENT elif ( b >= i ) : NEW_LINE INDENT temp = a NEW_LINE DEDENT elif ( i > b ) : NEW_LINE INDENT temp = a - ( i - b ) + 1 NEW_LINE DEDENT if ( temp > 0 ) : NEW_LINE INDENT count += temp NEW_LINE DEDENT i += n NEW_LINE DEDENT return count NEW_LINE DEDENT
def minGCD ( arr , n ) : NEW_LINE INDENT minGCD = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT minGCD = gcd ( minGCD , arr [ i ] ) NEW_LINE DEDENT return minGCD NEW_LINE DEDENT
def minLCM ( arr , n ) : NEW_LINE INDENT minLCM = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minLCM = min ( minLCM , arr [ i ] ) NEW_LINE DEDENT return minLCM NEW_LINE DEDENT
def countSteps ( curx , cury , n , m , moves ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( moves ) NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT x = moves [ i ] [ 0 ] NEW_LINE y = moves [ i ] [ 1 ] NEW_LINE stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) NEW_LINE count += stepct NEW_LINE curx += stepct * x NEW_LINE cury += stepct * y NEW_LINE DEDENT return count NEW_LINE DEDENT
def min_elimination ( n , arr ) : NEW_LINE INDENT count = 0 NEW_LINE prev_val = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_val = arr [ i ] NEW_LINE if ( curr_val % 2 == prev_val % 2 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT prev_val = curr_val NEW_LINE DEDENT return count NEW_LINE DEDENT
def getCount ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = "9" NEW_LINE for i in range ( 1 , N // 2 ) : NEW_LINE INDENT result = result + "0" NEW_LINE DEDENT return result NEW_LINE DEDENT
def cmp ( a , b ) : NEW_LINE INDENT return ( a > b ) - ( a < b ) NEW_LINE DEDENT
def maxSubStrings ( s , k ) : NEW_LINE INDENT maxSubStr = 0 NEW_LINE n = len ( s ) NEW_LINE for c in range ( 27 ) : NEW_LINE INDENT ch = chr ( ord ( 'a' ) + c ) NEW_LINE curr = 0 NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT if ( s [ i ] != ch ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = 0 NEW_LINE while ( i < n and s [ i ] == ch and cnt != k ) : NEW_LINE INDENT i += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i -= 1 NEW_LINE if ( cnt == k ) : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT DEDENT maxSubStr = max ( maxSubStr , curr ) NEW_LINE DEDENT return maxSubStr NEW_LINE DEDENT
def canFormTeam ( n , m ) : NEW_LINE INDENT if ( n >= 1 and m >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( m >= 1 and n >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def maxTeams ( n , m ) : NEW_LINE INDENT count = 0 NEW_LINE while ( canFormTeam ( n , m ) ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT n -= 2 NEW_LINE m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT m -= 2 NEW_LINE n -= 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def canBePicked ( digits , num ) : NEW_LINE INDENT copyDigits = [ ] NEW_LINE for i in range ( len ( digits ) ) : NEW_LINE INDENT copyDigits . append ( digits [ i ] ) NEW_LINE DEDENT while ( num > 0 ) : NEW_LINE INDENT digit = num % 10 NEW_LINE if ( copyDigits [ digit ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT copyDigits [ digit ] -= 1 NEW_LINE DEDENT num = math . floor ( num / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def max ( a , b ) : NEW_LINE INDENT if ( a > b ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT
def smallestSide ( a ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE side1 = a [ 0 ] + a [ 3 ] NEW_LINE side2 = a [ 1 ] + a [ 2 ] NEW_LINE side3 = a [ 0 ] + a [ 1 ] NEW_LINE side4 = a [ 2 ] + a [ 3 ] NEW_LINE side11 = max ( side1 , side2 ) NEW_LINE side12 = max ( side3 , side4 ) NEW_LINE sideOfSquare = max ( side11 , side12 ) NEW_LINE return sideOfSquare NEW_LINE DEDENT
def find_rectangle ( area ) : NEW_LINE INDENT for i in range ( int ( math . ceil ( math . sqrt ( area ) ) ) , area + 1 ) : NEW_LINE INDENT if ( ( int ( area / i ) * i ) == area ) : NEW_LINE INDENT print ( i , int ( area / i ) ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT
def sizeSubSet ( a , k , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % k != 0 or a [ i ] // k not in s ) : NEW_LINE INDENT s . add ( a [ i ] ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT
def minimumSets ( s , y ) : NEW_LINE INDENT cnt = 0 NEW_LINE num = 0 NEW_LINE l = len ( s ) NEW_LINE f = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT num = num * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE if ( num <= y ) : NEW_LINE INDENT f = 1 NEW_LINE if ( f ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT num = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE f = 0 NEW_LINE if ( num <= y ) : NEW_LINE INDENT f = 1 NEW_LINE DEDENT else : NEW_LINE INDENT num = 0 NEW_LINE DEDENT DEDENT DEDENT if ( f ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def ModifiedArray ( a , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = sys . maxsize NEW_LINE b = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , int ( n / 2 ) , 1 ) : NEW_LINE INDENT b [ i ] = max ( l , a [ i ] - r ) NEW_LINE b [ n - i - 1 ] = a [ i ] - b [ i ] NEW_LINE l = b [ i ] NEW_LINE r = b [ n - i - 1 ] NEW_LINE DEDENT printArr ( b , n ) NEW_LINE DEDENT
def greatestKBits ( X , K ) : NEW_LINE INDENT set_bit_count = bin ( X ) . count ( '1' ) NEW_LINE if ( set_bit_count <= K ) : NEW_LINE INDENT return X NEW_LINE DEDENT diff = set_bit_count - K NEW_LINE for i in range ( 0 , diff , 1 ) : NEW_LINE INDENT X &= ( X - 1 ) NEW_LINE DEDENT return X NEW_LINE DEDENT
def minItems ( k , r ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( ( i * k - r ) % 10 == 0 or ( i * k ) % 10 == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 10 NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( sys . maxsize - 1 ) NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def maxSum ( a , n ) : NEW_LINE INDENT S = 0 NEW_LINE S1 = maxSubArraySum ( a , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += a [ i ] NEW_LINE DEDENT return ( 2 * S1 - S ) NEW_LINE DEDENT
def check_distribution ( n , k , age , candy ) : NEW_LINE INDENT mxage = max ( age ) + 1 NEW_LINE mxcandy = max ( candy ) + 1 NEW_LINE fr1 = [ 0 ] * mxage NEW_LINE fr2 = [ 0 ] * mxcandy NEW_LINE for j in range ( n ) : NEW_LINE INDENT fr1 [ age [ j ] ] += 1 NEW_LINE DEDENT for j in range ( k ) : NEW_LINE INDENT fr2 [ candy [ j ] ] += 1 NEW_LINE DEDENT k = 0 NEW_LINE Tf = True NEW_LINE for j in range ( mxage ) : NEW_LINE INDENT if ( fr1 [ j ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT flag = False NEW_LINE while ( k < mxcandy ) : NEW_LINE INDENT if ( fr1 [ j ] <= fr2 [ k ] ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT k += 1 NEW_LINE DEDENT k = k + 1 NEW_LINE if ( flag == False ) : NEW_LINE INDENT Tf = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( Tf ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def check ( n , marks ) : NEW_LINE INDENT x = max ( marks ) NEW_LINE bonus = 100 - x NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( marks [ i ] + bonus >= 50 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT
def find_sum ( n , k ) : NEW_LINE INDENT total_sum = ( n * ( n + 1 ) ) // 2 NEW_LINE power = k NEW_LINE while power <= n : NEW_LINE INDENT total_sum -= power NEW_LINE power *= k NEW_LINE DEDENT return total_sum NEW_LINE DEDENT
def findTwoNumbers ( sum , gcd ) : NEW_LINE INDENT if ( __gcd ( gcd , sum - gcd ) == gcd and sum != gcd ) : NEW_LINE INDENT print ( "a =" , min ( gcd , sum - gcd ) , ", b =" , sum - min ( gcd , sum - gcd ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def maxLitres ( budget , plastic , glass , refund ) : NEW_LINE INDENT if glass - refund < plastic : NEW_LINE INDENT ans = max ( ( budget - refund ) // ( glass - refund ) , 0 ) NEW_LINE budget -= ans * ( glass - refund ) NEW_LINE ans += budget // plastic NEW_LINE print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( budget // plastic ) NEW_LINE DEDENT DEDENT
def smallestPermute ( n ) : NEW_LINE INDENT res = [ "" ] * ( n + 1 ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) NEW_LINE DEDENT DEDENT res [ n - 1 ] = chr ( 48 + n - 2 ) NEW_LINE res [ n - 2 ] = chr ( 48 + n ) NEW_LINE res [ n - 3 ] = chr ( 48 + n - 1 ) NEW_LINE DEDENT res = '' . join ( res ) NEW_LINE return res NEW_LINE DEDENT
def leastValue ( P , A , N , a ) : NEW_LINE INDENT ans = - 1 NEW_LINE tmp = float ( 'inf' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = P - a [ i ] * 0.006 NEW_LINE if abs ( t - A ) < tmp : NEW_LINE INDENT tmp = abs ( t - A ) NEW_LINE ans = i NEW_LINE DEDENT DEDENT return a [ ans ] NEW_LINE DEDENT
def minOperations ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hashTable [ arr [ i ] ] ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT hashTable [ arr [ j ] ] = 0 NEW_LINE DEDENT DEDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def minInsertions ( H , n , K ) : NEW_LINE INDENT inser = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) NEW_LINE if ( diff <= K ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT inser += math . ceil ( diff / K ) - 1 NEW_LINE DEDENT DEDENT return inser NEW_LINE DEDENT
def minCost ( N , P , Q ) : NEW_LINE INDENT cost = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N & 1 ) : NEW_LINE INDENT cost += P NEW_LINE N -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp = N // 2 NEW_LINE if ( temp * P > Q ) : NEW_LINE INDENT cost += Q NEW_LINE DEDENT else : NEW_LINE INDENT cost += P * temp NEW_LINE DEDENT N //= 2 NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT
def count_minimum_operations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 1 ) : NEW_LINE INDENT if ( n % 3 == 0 ) : NEW_LINE INDENT n //= 3 NEW_LINE DEDENT elif ( n % 3 == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT n += 1 NEW_LINE DEDENT DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def count_minimum_operations ( n ) : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 3 == 0 ) : NEW_LINE INDENT return 1 + count_minimum_operations ( n / 3 ) NEW_LINE DEDENT elif ( n % 3 == 1 ) : NEW_LINE INDENT return 1 + count_minimum_operations ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + count_minimum_operations ( n + 1 ) NEW_LINE DEDENT DEDENT
def findPermutation ( n ) : NEW_LINE INDENT len = ceil ( log10 ( n ) ) NEW_LINE for i in range ( 0 , len , 1 ) : NEW_LINE INDENT if n % 2 != 0 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT n = ( ( n / 10 ) + ( n % 10 ) * pow ( 10 , len - i - 1 ) ) NEW_LINE continue NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def maxMatrixScore ( A , K ) : NEW_LINE INDENT update = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if A [ i ] [ 0 ] == 0 : NEW_LINE INDENT ans = 0 NEW_LINE for j in range ( 1 , m ) : NEW_LINE INDENT ans = ans + A [ i ] [ j ] * 2 ** ( m - j - 1 ) NEW_LINE DEDENT update [ ans ] = i NEW_LINE DEDENT DEDENT for idx in update . values ( ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT A [ idx ] [ j ] = ( A [ idx ] [ j ] + 1 ) % 2 NEW_LINE DEDENT K -= 1 NEW_LINE if K <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for j in range ( 0 , m ) : NEW_LINE INDENT zero , one = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if A [ i ] [ j ] == 0 : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT if K > 0 and zero > one : NEW_LINE INDENT ans += zero * 2 ** ( m - j - 1 ) NEW_LINE K -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += one * 2 ** ( m - j - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isSellingPossible ( n , a ) : NEW_LINE INDENT c25 = 0 NEW_LINE c50 = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( a [ i ] == 25 ) : NEW_LINE INDENT c25 += 1 NEW_LINE DEDENT elif ( a [ i ] == 50 ) : NEW_LINE INDENT c50 += 1 NEW_LINE if ( c25 == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT c25 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( c50 > 0 and c25 > 0 ) : NEW_LINE INDENT c50 -= 1 NEW_LINE c25 -= 1 NEW_LINE DEDENT elif ( c25 >= 3 ) : NEW_LINE INDENT c25 -= 3 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def cal_minimum_time ( X ) : NEW_LINE INDENT t = 0 NEW_LINE sum = 0 NEW_LINE while ( sum < X ) : NEW_LINE INDENT t = t + 1 NEW_LINE sum = sum + t NEW_LINE DEDENT return t NEW_LINE DEDENT
def countMinSwaps ( s ) : NEW_LINE INDENT N = len ( s ) NEW_LINE one = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT DEDENT if ( one > zero + 1 or zero > one + 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( N % 2 ) : NEW_LINE INDENT num = ( N + 1 ) / 2 NEW_LINE one_even = 0 NEW_LINE zero_even = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT one_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_even += 1 NEW_LINE DEDENT DEDENT DEDENT if ( one > zero ) : NEW_LINE INDENT return num - one_even NEW_LINE DEDENT else : NEW_LINE INDENT return num - zero_even NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT one_odd = 0 NEW_LINE one_even = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT if ( i % 2 ) : NEW_LINE INDENT one_odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT one_even += 1 NEW_LINE DEDENT DEDENT DEDENT return min ( N // 2 - one_odd , N // 2 - one_even ) NEW_LINE DEDENT DEDENT
def minDiff ( n , x , A ) : NEW_LINE INDENT mn = A [ 0 ] NEW_LINE mx = A [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mn = min ( mn , A [ i ] ) NEW_LINE mx = max ( mx , A [ i ] ) NEW_LINE DEDENT return max ( 0 , mx - mn - 2 * x ) NEW_LINE DEDENT
def LengthLCP ( x , y ) : NEW_LINE INDENT fr = [ 0 ] * 26 NEW_LINE for i in range ( b ) : NEW_LINE INDENT fr [ ord ( y [ i ] ) - 97 ] += 1 NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT if ( fr [ ord ( x [ i ] ) - 97 ] > 0 ) : NEW_LINE INDENT c += 1 NEW_LINE fr [ ord ( x [ i ] ) - 97 ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def checkIfOverlap ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE visited = [ 0 ] * ( length + 1 ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT if str [ i ] == "." : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( max ( 0 , i - ord ( str [ i ] ) , min ( length , i + ord ( str [ i ] ) ) + 1 ) ) : NEW_LINE INDENT visited [ j ] += 1 NEW_LINE DEDENT DEDENT for i in range ( length ) : NEW_LINE INDENT if visited [ i ] > 1 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def isWaveArray ( arr , n ) : NEW_LINE INDENT result = True NEW_LINE if ( arr [ 1 ] > arr [ 0 ] and arr [ 1 ] > arr [ 2 ] ) : NEW_LINE INDENT for i in range ( 1 , n - 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT result = True NEW_LINE DEDENT else : NEW_LINE INDENT result = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( result == True and n % 2 == 0 ) : NEW_LINE INDENT if ( arr [ n - 1 ] <= arr [ n - 2 ] ) : NEW_LINE INDENT result = False NEW_LINE DEDENT DEDENT DEDENT elif ( arr [ 1 ] < arr [ 0 ] and arr [ 1 ] < arr [ 2 ] ) : NEW_LINE INDENT for i in range ( 1 , n - 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT result = True NEW_LINE DEDENT else : NEW_LINE INDENT result = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( result == True and n % 2 == 0 ) : NEW_LINE INDENT if ( arr [ n - 1 ] >= arr [ n - 2 ] ) : NEW_LINE INDENT result = False NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def printCoins ( arr , n ) : NEW_LINE INDENT oddSum = 0 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT oddSum += arr [ i ] NEW_LINE DEDENT evenSum = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT evenSum += arr [ i ] NEW_LINE DEDENT if oddSum > evenSum : NEW_LINE INDENT start = 0 NEW_LINE DEDENT else : NEW_LINE INDENT start = 1 NEW_LINE DEDENT for i in range ( start , n , 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def countSubstrings ( s ) : NEW_LINE INDENT ans = 0 NEW_LINE subs = 1 NEW_LINE pre = '' NEW_LINE for i in s : NEW_LINE INDENT if pre == i : NEW_LINE INDENT subs += 1 NEW_LINE DEDENT else : NEW_LINE INDENT subs = 1 NEW_LINE DEDENT ans += subs NEW_LINE pre = i NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def find ( i ) : NEW_LINE INDENT while parent [ i ] != i : NEW_LINE INDENT i = parent [ i ] NEW_LINE DEDENT return i NEW_LINE DEDENT
def isValidEdge ( u , v , inMST ) : NEW_LINE INDENT if u == v : NEW_LINE INDENT return False NEW_LINE DEDENT if inMST [ u ] == False and inMST [ v ] == False : NEW_LINE INDENT return False NEW_LINE DEDENT elif inMST [ u ] == True and inMST [ v ] == True : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = - arr [ i ] NEW_LINE DEDENT sum_here = arr [ 0 ] NEW_LINE max_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum_here = max ( sum_here + arr [ i ] , arr [ i ] ) NEW_LINE max_sum = max ( max_sum , sum_here ) NEW_LINE DEDENT return ( - 1 ) * max_sum NEW_LINE DEDENT
def solve ( arr , n ) : NEW_LINE INDENT ans = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT ans [ i ] [ j ] = arr [ j ] [ ( i + j ) % n ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def makeArray ( n ) : NEW_LINE INDENT arr = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE c = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = c NEW_LINE c += 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT
def printLargest ( a , n ) : NEW_LINE INDENT max = - 1 NEW_LINE ind = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num ) : NEW_LINE INDENT r = num % 10 NEW_LINE num = num / 10 NEW_LINE if ( num == 0 ) : NEW_LINE INDENT if ( max < r ) : NEW_LINE INDENT max = r NEW_LINE ind = i NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( ind , n ) : NEW_LINE INDENT print ( a [ i ] , end = '' ) , NEW_LINE DEDENT for i in range ( 0 , ind ) : NEW_LINE INDENT print ( a [ i ] , end = '' ) NEW_LINE DEDENT DEDENT
def findMinimumAdjacentSwaps ( arr , N ) : NEW_LINE INDENT visited = [ False ] * ( N + 1 ) NEW_LINE minimumSwaps = 0 NEW_LINE for i in range ( 2 * N ) : NEW_LINE INDENT if ( visited [ arr [ i ] ] == False ) : NEW_LINE INDENT visited [ arr [ i ] ] = True NEW_LINE count = 0 NEW_LINE for j in range ( i + 1 , 2 * N ) : NEW_LINE INDENT if ( visited [ arr [ j ] ] == False ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT minimumSwaps += count NEW_LINE DEDENT DEDENT DEDENT DEDENT return minimumSwaps NEW_LINE DEDENT
def DecreasingArray ( a , n ) : NEW_LINE INDENT ss , dif = ( 0 , 0 ) NEW_LINE pq = PriorityQueue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = 0 NEW_LINE if not pq . empty ( ) : NEW_LINE INDENT tmp = pq . get ( ) NEW_LINE pq . put ( tmp ) NEW_LINE DEDENT if not pq . empty ( ) and tmp < a [ i ] : NEW_LINE INDENT dif = a [ i ] - tmp NEW_LINE ss += dif NEW_LINE pq . get ( ) NEW_LINE DEDENT pq . put ( a [ i ] ) NEW_LINE DEDENT return ss NEW_LINE DEDENT
def ifPossible ( arr , n ) : NEW_LINE INDENT cp = [ 0 ] * n NEW_LINE cp = arr NEW_LINE cp . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( not ( arr [ i ] == cp [ i ] ) and not ( arr [ n - 1 - i ] == cp [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findMinRooms ( slots , n , m ) : NEW_LINE INDENT counts = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( slots [ i ] [ j ] == '1' ) : NEW_LINE INDENT counts [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT return max ( counts ) NEW_LINE DEDENT
def MinOperation ( a , n , k ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 1 and a [ i ] > k ) : NEW_LINE INDENT result = ( result + min ( a [ i ] % k , k - a [ i ] % k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result + k - a [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def maxProductSubset ( a , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT max_neg = - 999999999999 NEW_LINE count_neg = 0 NEW_LINE count_zero = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT count_zero += 1 NEW_LINE continue NEW_LINE DEDENT if a [ i ] < 0 : NEW_LINE INDENT count_neg += 1 NEW_LINE max_neg = max ( max_neg , a [ i ] ) NEW_LINE DEDENT prod = prod * a [ i ] NEW_LINE DEDENT if count_zero == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if count_neg & 1 : NEW_LINE INDENT if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT prod = int ( prod / max_neg ) NEW_LINE DEDENT return prod NEW_LINE DEDENT
def preProcess ( n ) : NEW_LINE INDENT preProcessedCubes = list ( ) NEW_LINE for i in range ( 1 , mt . ceil ( n ** ( 1. / 3. ) ) ) : NEW_LINE INDENT iThCube = i ** 3 NEW_LINE cubeString = str ( iThCube ) NEW_LINE preProcessedCubes . append ( cubeString ) NEW_LINE DEDENT return preProcessedCubes NEW_LINE DEDENT
def solve ( a , b , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s += a [ i ] + b [ i ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] + b [ 0 ] NEW_LINE DEDENT if s % n != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = s // n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT a [ i ] += b [ i - 1 ] NEW_LINE b [ i - 1 ] = 0 NEW_LINE DEDENT if a [ i ] == x : NEW_LINE INDENT continue NEW_LINE DEDENT y = a [ i ] + b [ i ] NEW_LINE if i + 1 < n : NEW_LINE INDENT y += b [ i + 1 ] NEW_LINE DEDENT if y == x : NEW_LINE INDENT a [ i ] = y NEW_LINE b [ i ] = 0 NEW_LINE if i + 1 < n : NEW_LINE INDENT b [ i + 1 ] = 0 NEW_LINE DEDENT continue NEW_LINE DEDENT if a [ i ] + b [ i ] == x : NEW_LINE INDENT a [ i ] += b [ i ] NEW_LINE b [ i ] = 0 NEW_LINE continue NEW_LINE DEDENT if i + 1 < n and a [ i ] + b [ i + 1 ] == x : NEW_LINE INDENT a [ i ] += b [ i + 1 ] NEW_LINE b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT return - 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if b [ i ] != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def calcFiboTerms ( fiboTerms , K ) : NEW_LINE INDENT i = 3 NEW_LINE fiboTerms . append ( 0 ) NEW_LINE fiboTerms . append ( 1 ) NEW_LINE fiboTerms . append ( 1 ) NEW_LINE while True : NEW_LINE INDENT nextTerm = ( fiboTerms [ i - 1 ] + fiboTerms [ i - 2 ] ) NEW_LINE if nextTerm > K : NEW_LINE INDENT return NEW_LINE DEDENT fiboTerms . append ( nextTerm ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def survival ( S , N , M ) : NEW_LINE INDENT if ( ( ( N * 6 ) < ( M * 7 ) and S > 6 ) or M > N ) : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT else : NEW_LINE INDENT days = ( M * S ) / N NEW_LINE if ( ( ( M * S ) % N ) != 0 ) : NEW_LINE INDENT days += 1 NEW_LINE DEDENT print ( "Yes " ) , NEW_LINE print ( days ) NEW_LINE DEDENT DEDENT
def findTwoGroup ( n ) : NEW_LINE INDENT sum = n * ( n + 1 ) / 2 NEW_LINE group1Sum = sum / 2 NEW_LINE group1 = [ ] NEW_LINE group2 = [ ] NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( group1Sum - i >= 0 ) : NEW_LINE INDENT group1 . append ( i ) NEW_LINE group1Sum -= i NEW_LINE DEDENT else : NEW_LINE INDENT group2 . append ( i ) NEW_LINE DEDENT DEDENT printVector ( group1 ) NEW_LINE printVector ( group2 ) NEW_LINE DEDENT
def cost ( a , n ) : NEW_LINE INDENT return ( ( n - 1 ) * min ( a ) ) NEW_LINE DEDENT
def winner ( a , n , k ) : NEW_LINE INDENT if k >= n - 1 : NEW_LINE INDENT return n NEW_LINE DEDENT best = 0 NEW_LINE times = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > best : NEW_LINE INDENT best = a [ i ] NEW_LINE if i == True : NEW_LINE INDENT times = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if times >= k : NEW_LINE INDENT return best NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT DEDENT
def minproduct ( a , b , n , k ) : NEW_LINE INDENT diff = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pro = a [ i ] * b [ i ] NEW_LINE res = res + pro NEW_LINE if ( pro < 0 and b [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro < 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] > 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT d = abs ( pro - temp ) NEW_LINE if ( d > diff ) : NEW_LINE INDENT diff = d NEW_LINE DEDENT DEDENT return res - diff NEW_LINE DEDENT
def minRotation ( input , unlock_code ) : NEW_LINE INDENT rotation = 0 NEW_LINE while ( input > 0 or unlock_code > 0 ) : NEW_LINE INDENT input_digit = input % 10 NEW_LINE code_digit = unlock_code % 10 NEW_LINE rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) NEW_LINE input = int ( input / 10 ) NEW_LINE unlock_code = int ( unlock_code / 10 ) NEW_LINE DEDENT return rotation NEW_LINE DEDENT
def findWaitingTime ( processes , n , wt ) : NEW_LINE INDENT rt = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT rt [ i ] = processes [ i ] [ 1 ] NEW_LINE DEDENT complete = 0 NEW_LINE t = 0 NEW_LINE minm = 999999999 NEW_LINE short = 0 NEW_LINE check = False NEW_LINE while ( complete != n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( processes [ j ] [ 2 ] <= t ) and ( rt [ j ] < minm ) and rt [ j ] > 0 ) : NEW_LINE INDENT minm = rt [ j ] NEW_LINE short = j NEW_LINE check = True NEW_LINE DEDENT DEDENT if ( check == False ) : NEW_LINE INDENT t += 1 NEW_LINE continue NEW_LINE DEDENT rt [ short ] -= 1 NEW_LINE minm = rt [ short ] NEW_LINE if ( minm == 0 ) : NEW_LINE INDENT minm = 999999999 NEW_LINE DEDENT if ( rt [ short ] == 0 ) : NEW_LINE INDENT complete += 1 NEW_LINE check = False NEW_LINE fint = t + 1 NEW_LINE wt [ short ] = ( fint - proc [ short ] [ 1 ] - proc [ short ] [ 2 ] ) NEW_LINE if ( wt [ short ] < 0 ) : NEW_LINE INDENT wt [ short ] = 0 NEW_LINE DEDENT DEDENT t += 1 NEW_LINE DEDENT DEDENT
def findTurnAroundTime ( processes , n , wt , tat ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT tat [ i ] = processes [ i ] [ 1 ] + wt [ i ] NEW_LINE DEDENT DEDENT
def minCost ( coin , n , k ) : NEW_LINE INDENT coin . sort ( ) NEW_LINE coins_needed = math . ceil ( 1.0 * n // ( k + 1 ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( coins_needed - 1 + 1 ) : NEW_LINE INDENT ans += coin [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def preprocess ( coin , n ) : NEW_LINE INDENT coin . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT coin [ i ] += coin [ i - 1 ] NEW_LINE DEDENT DEDENT
def minCost ( coin , n , k ) : NEW_LINE INDENT coins_needed = mt . ceil ( 1.0 * n / ( k + 1 ) ) NEW_LINE return coin [ coins_needed - 1 ] NEW_LINE DEDENT
def minimizeWithKSwaps ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT pos = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] < arr [ pos ] ) : NEW_LINE INDENT pos = j NEW_LINE DEDENT DEDENT for j in range ( pos , i , - 1 ) : NEW_LINE INDENT arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] NEW_LINE DEDENT k -= pos - i NEW_LINE DEDENT DEDENT
def minimumSquare ( a , b ) : NEW_LINE INDENT result = 0 NEW_LINE rem = 0 NEW_LINE if ( a < b ) : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT while ( b > 0 ) : NEW_LINE INDENT result += int ( a / b ) NEW_LINE rem = int ( a % b ) NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT return result NEW_LINE DEDENT
def minimumCostOfBreaking ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE X . sort ( reverse = True ) NEW_LINE Y . sort ( reverse = True ) NEW_LINE hzntl = 1 NEW_LINE vert = 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( X [ i ] > Y [ j ] ) : NEW_LINE INDENT res += X [ i ] * vert NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT total += X [ i ] NEW_LINE i += 1 NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT total += Y [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE DEDENT
def maximumSum ( arr , n , k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT min = + 2147483647 NEW_LINE index = - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] < min ) : NEW_LINE INDENT min = arr [ j ] NEW_LINE index = j NEW_LINE DEDENT DEDENT if ( min == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT arr [ index ] = - arr [ index ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def maximizeSum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( k and arr [ i ] < 0 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE k -= 1 NEW_LINE continue NEW_LINE DEDENT break NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( k == 0 or k % 2 == 0 ) : NEW_LINE INDENT return sumArray ( arr , n ) NEW_LINE DEDENT if ( i != 0 and abs ( arr [ i ] ) >= abs ( arr [ i - 1 ] ) ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT arr [ i ] *= - 1 NEW_LINE return sumArray ( arr , n ) NEW_LINE DEDENT
def findLargest ( m , s ) : NEW_LINE INDENT if ( s == 0 ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT print ( "Largest number is " , "0" , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Not possible" , end = "" ) NEW_LINE DEDENT return NEW_LINE DEDENT if ( s > 9 * m ) : NEW_LINE INDENT print ( "Not possible" , end = "" ) NEW_LINE return NEW_LINE DEDENT res = [ 0 ] * m NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( s >= 9 ) : NEW_LINE INDENT res [ i ] = 9 NEW_LINE s = s - 9 NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = s NEW_LINE s = 0 NEW_LINE DEDENT DEDENT print ( "Largest number is " , end = "" ) NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT print ( res [ i ] , end = "" ) NEW_LINE DEDENT DEDENT
def getMax ( arr , n ) : NEW_LINE INDENT result = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > result : NEW_LINE INDENT result = arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def isPossible ( time , K , job , n ) : NEW_LINE INDENT cnt = 1 NEW_LINE curr_time = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if curr_time + job [ i ] > time : NEW_LINE INDENT curr_time = 0 NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT curr_time += job [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return cnt <= K NEW_LINE DEDENT
def findMinTime ( K , T , job , n ) : NEW_LINE INDENT end = 0 NEW_LINE start = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT end += job [ i ] NEW_LINE DEDENT job_max = getMax ( job , n ) NEW_LINE while start <= end : NEW_LINE INDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if mid >= job_max and isPossible ( mid , K , job , n ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return ans * T NEW_LINE DEDENT
def findMin ( V ) : NEW_LINE INDENT deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] NEW_LINE n = len ( deno ) NEW_LINE ans = [ ] NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def maxDiffSum ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxVal = arr [ i ] NEW_LINE minVal = arr [ i ] NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT minVal = min ( minVal , arr [ j ] ) NEW_LINE maxVal = max ( maxVal , arr [ j ] ) NEW_LINE if ( j - 1 >= 0 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , maxVal - minVal + dp [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , maxVal - minVal ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def modPow ( x , y ) : NEW_LINE INDENT r = 1 NEW_LINE a = x NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) == 1 ) : NEW_LINE INDENT r = ( r * a ) % MOD NEW_LINE DEDENT a = ( a * a ) % MOD NEW_LINE y /= 2 NEW_LINE DEDENT return r NEW_LINE DEDENT
def modInverse ( x ) : NEW_LINE INDENT return modPow ( x , MOD - 2 ) NEW_LINE DEDENT
def modDivision ( p , q ) : NEW_LINE INDENT return ( p * modInverse ( q ) ) % MOD NEW_LINE DEDENT
def C ( n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT p = 1 NEW_LINE q = 1 NEW_LINE for i in range ( 1 , k + 1 , 1 ) : NEW_LINE INDENT q = ( q * i ) % MOD NEW_LINE p = ( p * ( n - i + 1 ) ) % MOD NEW_LINE DEDENT return modDivision ( p , q ) NEW_LINE DEDENT
def countArrays ( N , K ) : NEW_LINE INDENT res = 1 NEW_LINE for p in range ( 2 , int ( sqrt ( K ) ) , 1 ) : NEW_LINE INDENT c = 0 NEW_LINE while ( K % p == 0 ) : NEW_LINE INDENT K /= p NEW_LINE c += 1 NEW_LINE DEDENT res = ( res * C ( N - 1 + c , c ) ) % MOD NEW_LINE DEDENT if ( N > 1 ) : NEW_LINE INDENT res = ( res * N ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT
def minSessions ( codeTime , dp , ones , n , mask , currTime , WorkingSessionTime ) : NEW_LINE INDENT if ( currTime > WorkingSessionTime ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( mask == ones ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ mask ] [ currTime ] != - 1 ) : NEW_LINE INDENT return dp [ mask ] [ currTime ] NEW_LINE DEDENT ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( mask & ( 1 << i ) ) == 0 ) : NEW_LINE INDENT inc = minSessions ( codeTime , dp , ones , n , mask | ( 1 << i ) , currTime + codeTime [ i ] , WorkingSessionTime ) NEW_LINE inc_next = 1 + minSessions ( codeTime , dp , ones , n , mask | ( 1 << i ) , codeTime [ i ] , WorkingSessionTime ) NEW_LINE ans = min ( [ ans , inc , inc_next ] ) NEW_LINE DEDENT DEDENT dp [ mask ] [ currTime ] = ans NEW_LINE return ans NEW_LINE DEDENT
def solve ( codeTime , n , WorkingSessionTime ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( 15 ) ] for j in range ( 1 << 14 ) ] NEW_LINE ones = ( 1 << n ) - 1 NEW_LINE ans = minSessions ( codeTime , dp , ones , n , 0 , 0 , WorkingSessionTime ) NEW_LINE if ( WorkingSessionTime < 6 ) : NEW_LINE INDENT if ( ans % 2 == 0 ) : NEW_LINE INDENT ans = ans // 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( ans / 2 ) + 1 NEW_LINE DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT
def solve ( len , gap ) : NEW_LINE INDENT if ( dp [ len ] [ gap ] != - 1 ) : NEW_LINE INDENT return dp [ len ] [ gap ] NEW_LINE DEDENT if ( len == 0 or gap == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( gap < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( gap + 1 ) : NEW_LINE INDENT ans += solve ( len - 1 , gap - i ) NEW_LINE DEDENT dp [ len ] [ gap ] = ans NEW_LINE return dp [ len ] [ gap ] NEW_LINE DEDENT
def countValidStrings ( S ) : NEW_LINE INDENT global dp NEW_LINE N = len ( S ) NEW_LINE L , R = 1 , 9 NEW_LINE cnt = 0 NEW_LINE ans = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] != '?' ) : NEW_LINE INDENT R = ord ( S [ i ] ) - ord ( '0' ) NEW_LINE ans *= solve ( cnt , R - L ) NEW_LINE L = R NEW_LINE R = 9 NEW_LINE cnt = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ans *= solve ( cnt , R - L ) NEW_LINE return ans NEW_LINE DEDENT
def recBananaCnt ( A , B , C ) : NEW_LINE INDENT if ( B <= A ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B <= C ) : NEW_LINE INDENT return B - A NEW_LINE DEDENT if ( A == 0 ) : NEW_LINE INDENT return B NEW_LINE DEDENT if ( dp [ A ] [ B ] != - 1 ) : NEW_LINE INDENT return dp [ A ] [ B ] NEW_LINE DEDENT maxCount = - 2 ** 32 NEW_LINE tripCount = ( ( 2 * B ) // C ) - 1 if ( B % C == 0 ) else ( ( 2 * B ) // C ) + 1 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT curCount = recBananaCnt ( A - i , B - tripCount * i , C ) NEW_LINE if ( curCount > maxCount ) : NEW_LINE INDENT maxCount = curCount NEW_LINE dp [ A ] [ B ] = maxCount NEW_LINE DEDENT DEDENT return maxCount NEW_LINE DEDENT
def maxBananaCnt ( A , B , C ) : NEW_LINE INDENT return recBananaCnt ( A , B , C ) NEW_LINE DEDENT
def combinationsPossible ( N , idx , prev , val , K , dp ) : NEW_LINE INDENT if ( val > K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ val ] [ idx ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ val ] [ idx ] [ prev ] NEW_LINE DEDENT if ( idx == N - 1 ) : NEW_LINE INDENT if ( val == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE if ( prev == 1 ) : NEW_LINE INDENT ans += combinationsPossible ( N , idx + 1 , 1 , val + 1 , K , dp ) NEW_LINE ans += combinationsPossible ( N , idx + 1 , 0 , val , K , dp ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += combinationsPossible ( N , idx + 1 , 1 , val , K , dp ) NEW_LINE ans += combinationsPossible ( N , idx + 1 , 0 , val , K , dp ) NEW_LINE DEDENT dp [ val ] [ idx ] [ prev ] = ans NEW_LINE return ans NEW_LINE DEDENT
def countArray ( arr , N , M ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( M + 2 ) ] for j in range ( N ) ] NEW_LINE if ( arr [ 0 ] == - 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 , 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ 0 ] [ arr [ 0 ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , N , 1 ) : NEW_LINE INDENT if ( arr [ i ] != - 1 ) : NEW_LINE INDENT j = arr [ i ] NEW_LINE dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT if ( arr [ i ] == - 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 , 1 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT arrCount = 0 NEW_LINE for j in range ( 1 , M + 1 , 1 ) : NEW_LINE INDENT arrCount += dp [ N - 1 ] [ j ] NEW_LINE DEDENT return arrCount NEW_LINE DEDENT
def minChangeInLane ( barrier , n ) : NEW_LINE INDENT dp = [ 1 , 0 , 1 ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT val = barrier [ j ] NEW_LINE if ( val > 0 ) : NEW_LINE INDENT dp [ val - 1 ] = 1000000 NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT if ( val != i + 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT return min ( dp [ 0 ] , min ( dp [ 1 ] , dp [ 2 ] ) ) NEW_LINE DEDENT
def calculate ( position , used , unused , P , M , dp ) : NEW_LINE INDENT if ( position == P ) : NEW_LINE INDENT if unused == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ position ] [ used ] [ unused ] != - 1 ) : NEW_LINE INDENT return dp [ position ] [ used ] [ unused ] NEW_LINE DEDENT result = 0 NEW_LINE if ( unused > 0 ) : NEW_LINE INDENT result += calculate ( position + 1 , used + 1 , unused - 1 , P , M , dp ) * unused NEW_LINE DEDENT if ( used > M ) : NEW_LINE INDENT result += calculate ( position + 1 , used , unused , P , M , dp ) * ( used - M ) NEW_LINE DEDENT dp [ position ] [ used ] [ unused ] = result NEW_LINE return dp [ position ] [ used ] [ unused ] NEW_LINE DEDENT DEDENT
def solve ( N , P , M ) : NEW_LINE INDENT dp = [ [ [ - 1 for i in range ( 101 ) ] for i in range ( 101 ) ] for j in range ( 101 ) ] NEW_LINE return calculate ( 0 , 0 , N , P , M , dp ) NEW_LINE DEDENT
def maxMergingScore ( A , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 101 ) ] for j in range ( 101 ) ] NEW_LINE for len1 in range ( 1 , N , 1 ) : NEW_LINE INDENT for i in range ( 0 , N - len1 , 1 ) : NEW_LINE INDENT j = i + len1 NEW_LINE dp [ i ] [ j ] = 0 NEW_LINE for k in range ( i + 1 , j , 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k ] [ j ] + A [ i ] * A [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ N - 1 ] NEW_LINE DEDENT
def getMin ( x , y , z ) : NEW_LINE INDENT return min ( min ( x , y ) , z ) NEW_LINE DEDENT
def editDistance ( str1 , str2 , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( 0 , m + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + getMin ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
def minimumSteps ( S , N ) : NEW_LINE INDENT ans = 10 ** 10 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT S1 = S [ : i ] NEW_LINE S2 = S [ i : ] NEW_LINE count = editDistance ( S1 , S2 , len ( S1 ) , len ( S2 ) ) NEW_LINE ans = min ( ans , count ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def countOfWays ( arr , N ) : NEW_LINE INDENT pre = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT pre [ i + 1 ] = pre [ i ] + arr [ i ] NEW_LINE DEDENT dp = np . zeros ( ( N + 2 , N + 2 ) ) NEW_LINE dp [ 1 ] [ 0 ] += 1 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N , 0 , - 1 ) : NEW_LINE INDENT dp [ j + 1 ] [ pre [ i + 1 ] % ( j + 1 ) ] += dp [ j ] [ pre [ i + 1 ] % j ] NEW_LINE if ( i == N - 1 ) : NEW_LINE INDENT ans += dp [ j ] [ pre [ i + 1 ] % j ] NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def minimumDifference ( arr , q , N , m ) : NEW_LINE INDENT diff = [ 0 ] * N NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT diff [ i ] = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE DEDENT minDifference ( diff , N - 1 , q , m ) NEW_LINE DEDENT
def LongestOddEvenSubarray ( A , N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE ans = 1 NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT if ( ( A [ i ] % 2 == 0 and A [ i - 1 ] % 2 == 0 ) or ( A [ i ] % 2 != 0 and A [ i - 1 ] % 2 != 0 ) ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minimumOperations ( N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT dp [ i ] = 1000000000 NEW_LINE DEDENT dp [ 2 ] = 0 NEW_LINE for i in range ( 2 , N + 1 , 1 ) : NEW_LINE INDENT if ( dp [ i ] == 1000000000 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i * 5 <= N ) : NEW_LINE INDENT dp [ i * 5 ] = min ( dp [ i * 5 ] , dp [ i ] + 1 ) NEW_LINE DEDENT if ( i + 3 <= N ) : NEW_LINE INDENT dp [ i + 3 ] = min ( dp [ i + 3 ] , dp [ i ] + 1 ) NEW_LINE DEDENT DEDENT if ( dp [ N ] == 1000000000 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return dp [ N ] NEW_LINE DEDENT
def numTilings ( N ) : NEW_LINE INDENT if ( N < 3 ) : NEW_LINE INDENT return N NEW_LINE DEDENT dp = [ [ 0 ] * 3 for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = dp [ 1 ] [ 2 ] = 1 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 2 ] [ 0 ] + dp [ i - 2 ] [ 1 ] + dp [ i - 2 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ 2 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) % MOD NEW_LINE DEDENT return int ( dp [ N ] [ 0 ] ) NEW_LINE DEDENT
def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def countOfNumbers ( index , sum , N ) : NEW_LINE INDENT if ( index == N + 1 ) : NEW_LINE INDENT if ( prime [ sum ] == True ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT val = dp [ index ] [ sum ] NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT return val NEW_LINE DEDENT val = 0 NEW_LINE if ( index == 1 ) : NEW_LINE INDENT for digit in range ( ( ( 0 , 1 ) [ N == 1 ] ) + 1 , 10 , 1 ) : NEW_LINE INDENT val += countOfNumbers ( index + 1 , sum + digit , N ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for digit in range ( 0 , 10 , 1 ) : NEW_LINE INDENT val += countOfNumbers ( index + 1 , sum + digit , N ) NEW_LINE DEDENT DEDENT return val NEW_LINE DEDENT
def countStrings ( N ) : NEW_LINE INDENT if N == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp . get ( N , - 1 ) != - 1 : NEW_LINE INDENT return dp [ N ] NEW_LINE DEDENT ret = 0 NEW_LINE for div in range ( 1 , int ( N ** .5 ) + 1 ) : NEW_LINE INDENT if N % div == 0 : NEW_LINE INDENT ret += ( 1 << div ) - countStrings ( div ) NEW_LINE div2 = N // div NEW_LINE if div2 != div and div != 1 : NEW_LINE INDENT ret += ( 1 << div2 ) - countStrings ( div2 ) NEW_LINE DEDENT DEDENT DEDENT dp [ N ] = ret NEW_LINE return ret NEW_LINE DEDENT
def countOfNumbers ( N ) : NEW_LINE INDENT ans = 1 NEW_LINE for index in range ( 1 , N + 1 ) : NEW_LINE INDENT choices = 0 NEW_LINE for digit in range ( 1 , 10 ) : NEW_LINE INDENT if ( index % digit == 0 ) : NEW_LINE INDENT choices += 1 NEW_LINE DEDENT DEDENT ans = ( ans * choices ) % mod NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def MaxProfit ( arr , n , transactionFee ) : NEW_LINE INDENT buy = - arr [ 0 ] NEW_LINE sell = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT temp = buy NEW_LINE buy = max ( buy , sell - arr [ i ] ) NEW_LINE sell = max ( sell , temp + arr [ i ] - transactionFee ) NEW_LINE DEDENT return max ( sell , buy ) NEW_LINE DEDENT
def dfs ( arr , left , K ) : NEW_LINE INDENT q = 0 NEW_LINE if ( left == 0 ) : NEW_LINE INDENT for i in range ( 1 , K , 1 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] -= 1 NEW_LINE q = max ( q , 1 + dfs ( arr , K - i , K ) ) NEW_LINE arr [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , K , 1 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] -= 1 NEW_LINE nleft = left - i if i <= left else K + left - i NEW_LINE q = max ( q , dfs ( arr , nleft , K ) ) NEW_LINE arr [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT return q NEW_LINE DEDENT
def dfs ( V , left , K ) : NEW_LINE INDENT q = 0 NEW_LINE v = [ str ( int ) for int in V ] NEW_LINE key = "," . join ( v ) NEW_LINE key += str ( left ) NEW_LINE if key in memo : NEW_LINE INDENT return memo [ key ] NEW_LINE DEDENT elif left == 0 : NEW_LINE INDENT for i in range ( 1 , K ) : NEW_LINE INDENT if V [ i ] > 0 : NEW_LINE INDENT V [ i ] -= 1 NEW_LINE q = max ( q , 1 + dfs ( V , K - i , K ) ) NEW_LINE V [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , K ) : NEW_LINE INDENT if V [ i ] > 0 : NEW_LINE INDENT V [ i ] -= 1 NEW_LINE if i <= left : NEW_LINE INDENT nleft = left - i NEW_LINE DEDENT else : NEW_LINE INDENT nleft = K + left - i NEW_LINE DEDENT q = max ( q , dfs ( V , nleft , K ) ) NEW_LINE V [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT if key in memo : NEW_LINE INDENT memo [ key ] = q NEW_LINE DEDENT else : NEW_LINE INDENT memo [ key ] = q NEW_LINE DEDENT return q NEW_LINE DEDENT
def maxGroups ( K , arr ) : NEW_LINE INDENT V = [ 0 ] * ( K ) NEW_LINE for x in range ( len ( arr ) ) : NEW_LINE INDENT V [ arr [ x ] % K ] += 1 NEW_LINE DEDENT memo = { } NEW_LINE ans = V [ 0 ] + dfs ( V , 0 , K ) NEW_LINE return ans NEW_LINE DEDENT
def countMinSteps ( A , B , N ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( A [ i - 1 ] == B [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + 1 NEW_LINE DEDENT if ( i >= 2 and A [ i - 2 ] == B [ i - 1 ] and A [ i - 1 ] == B [ i - 2 ] ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ i - 2 ] + 1 ) NEW_LINE DEDENT DEDENT return dp [ N ] NEW_LINE DEDENT
def findMaxJumps ( arr , N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE ans = 0 NEW_LINE i = N - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE j = i + arr [ i ] NEW_LINE if ( j < N ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + dp [ j ] NEW_LINE DEDENT ans = max ( ans , dp [ i ] ) NEW_LINE i -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def countNDigitNumber ( N ) : NEW_LINE INDENT print ( countOfNumbers ( 1 , 0 , 0 , N ) ) NEW_LINE DEDENT
def getMaximum ( S , T ) : NEW_LINE INDENT if ( S . count ( "0" ) > 0 ) : NEW_LINE INDENT return T NEW_LINE DEDENT if ( T . count ( "0" ) > 0 ) : NEW_LINE INDENT return S NEW_LINE DEDENT return S if len ( S ) > len ( T ) else T NEW_LINE DEDENT
def recursion ( arr , idx , N , K , dp ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return "" NEW_LINE DEDENT if ( K < 0 or idx == N ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT if ( dp [ idx ] [ K ] != "-1" ) : NEW_LINE INDENT return dp [ idx ] [ K ] NEW_LINE DEDENT include = str ( idx + 1 ) + recursion ( arr , 0 , N , K - arr [ idx ] , dp ) NEW_LINE exclude = recursion ( arr , idx + 1 , N , K , dp ) NEW_LINE dp [ idx ] [ K ] = getMaximum ( include , exclude ) NEW_LINE return ( dp [ idx ] [ K ] ) NEW_LINE DEDENT
def longestSubsequence ( arr , N ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( N + 1 ) ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT dp [ 0 ] [ 1 ] = arr [ 0 ] if arr [ 0 ] >= 0 else - 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , i + 2 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] != - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT if ( dp [ i - 1 ] [ j - 1 ] >= 0 and dp [ i - 1 ] [ j - 1 ] + arr [ i ] >= 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for j in range ( N + 1 ) : NEW_LINE INDENT if ( dp [ N - 1 ] [ j ] >= 0 ) : NEW_LINE INDENT ans = j NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def Count ( N , L , R ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( R - L + 1 ) ] for i in range ( N ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , len ( dp [ 0 ] ) ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 1 NEW_LINE DEDENT ans = dp [ 0 ] [ R - L ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , len ( dp [ 0 ] ) ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] NEW_LINE DEDENT ans += dp [ i ] [ R - L ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def largestCommonSubarray ( arr , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT dp [ i ] [ arr [ i ] [ j ] ] = j NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE len1 = 1 NEW_LINE for i in range ( 1 , m , 1 ) : NEW_LINE INDENT check = True NEW_LINE for j in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( dp [ j ] [ arr [ 0 ] [ i - 1 ] ] + 1 != dp [ j ] [ arr [ 0 ] [ i ] ] ) : NEW_LINE INDENT check = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( check ) : NEW_LINE INDENT len1 += 1 NEW_LINE ans = max ( ans , len1 ) NEW_LINE DEDENT else : NEW_LINE INDENT len1 = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countOfNumbers ( digit , prev1 , prev2 , n ) : NEW_LINE INDENT if ( digit == n + 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT val = dp [ digit ] [ prev1 ] [ prev2 ] NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT return val NEW_LINE DEDENT val = 0 NEW_LINE if ( digit == 1 ) : NEW_LINE INDENT start = 1 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT start = 0 NEW_LINE DEDENT for i in range ( start , 10 ) : NEW_LINE INDENT val += countOfNumbers ( digit + 1 , i , prev1 , n ) NEW_LINE DEDENT DEDENT elif ( digit == 2 ) : NEW_LINE INDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT val += countOfNumbers ( digit + 1 , i , prev1 , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT mean = prev1 NEW_LINE current = ( 2 * mean ) - prev2 NEW_LINE if ( current >= 0 and current <= 9 ) : NEW_LINE INDENT val += countOfNumbers ( digit + 1 , current , prev1 , n ) NEW_LINE DEDENT if ( ( current + 1 ) >= 0 and ( current + 1 ) <= 9 ) : NEW_LINE INDENT val += countOfNumbers ( digit + 1 , current + 1 , prev1 , n ) NEW_LINE DEDENT DEDENT return val NEW_LINE DEDENT
def countOfNumbers ( digit , prev , n ) : NEW_LINE INDENT global val NEW_LINE global dp NEW_LINE if ( digit == n + 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT val = dp [ digit ] [ prev ] NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT return val NEW_LINE DEDENT val = 0 NEW_LINE if ( digit == 1 ) : NEW_LINE INDENT i = 0 if n == 1 else 1 NEW_LINE while ( i <= 9 ) : NEW_LINE INDENT val += countOfNumbers ( digit + 1 , i , n ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT if ( ( i & prev ) == 0 ) : NEW_LINE INDENT val += countOfNumbers ( digit + 1 , i , n ) NEW_LINE DEDENT DEDENT DEDENT return val NEW_LINE DEDENT
def totalSubarrays ( arr , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT count = 0 NEW_LINE while ( i < n and arr [ i ] <= k ) : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE DEDENT ans += ( ( count * ( count + 1 ) ) // 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countSubarrays ( arr , n , k ) : NEW_LINE INDENT count1 = totalSubarrays ( arr , n , k - 1 ) NEW_LINE count2 = totalSubarrays ( arr , n , k ) NEW_LINE ans = count2 - count1 NEW_LINE return ans NEW_LINE DEDENT
def MaximumSum ( a , b , n ) : NEW_LINE INDENT dp = [ [ - 1 for j in range ( 2 ) ] for i in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = a [ 0 ] NEW_LINE dp [ 0 ] [ 1 ] = b [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i ] NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) NEW_LINE if ( i - 2 >= 0 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , max ( dp [ i - 2 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + b [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , b [ i ] ) NEW_LINE DEDENT DEDENT return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) NEW_LINE DEDENT
def numberOfArrays ( n , l ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( l + 1 ) ] NEW_LINE dp [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for k in range ( j , n + 1 , j ) : NEW_LINE INDENT dp [ i + 1 ] [ k ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ l ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def waysOfDecoding ( s ) : NEW_LINE INDENT dp = [ 0 ] * ( len ( s ) + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE if s [ 0 ] == '*' : NEW_LINE INDENT dp [ 1 ] = 9 NEW_LINE DEDENT elif s [ 0 ] == '0' : NEW_LINE INDENT dp [ 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] = 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '*' ) : NEW_LINE INDENT dp [ i + 1 ] = 9 * dp [ i ] NEW_LINE if ( s [ i - 1 ] == '1' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == '2' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == '*' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if s [ i ] != '0' : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] = 0 NEW_LINE DEDENT if ( s [ i - 1 ] == '1' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == '2' and s [ i ] <= '6' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == '*' ) : NEW_LINE INDENT if ( s [ i ] <= '6' ) : NEW_LINE INDENT dp [ i + 1 ] = dp [ i + 1 ] + 2 * dp [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] = dp [ i + 1 ] + 1 * dp [ i - 1 ] NEW_LINE DEDENT dp [ i + 1 ] = dp [ i + 1 ] % M NEW_LINE DEDENT DEDENT DEDENT return dp [ len ( s ) ] NEW_LINE DEDENT
def KvisibleFromLeft ( N , K ) : NEW_LINE INDENT if ( dp [ N ] [ K ] != - 1 ) : NEW_LINE INDENT return dp [ N ] [ K ] NEW_LINE DEDENT if ( N == K ) : NEW_LINE INDENT dp [ N ] [ K ] = 1 NEW_LINE return dp [ N ] [ K ] NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT dp [ N ] [ K ] = ans NEW_LINE return dp [ N ] [ K ] NEW_LINE DEDENT dp [ N ] [ K ] = KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) NEW_LINE return dp [ N ] [ K ] NEW_LINE DEDENT
def minimumDeletions ( A , N ) : NEW_LINE INDENT ans = 10 ** 8 NEW_LINE for i in range ( 1 , ( 1 << N ) ) : NEW_LINE INDENT temp = [ ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( ( i & ( 1 << j ) ) != 0 ) : NEW_LINE INDENT temp . append ( A [ j ] ) NEW_LINE DEDENT DEDENT flag = 0 NEW_LINE for j in range ( 1 , len ( temp ) ) : NEW_LINE INDENT if ( temp [ j ] < temp [ j - 1 ] ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT for j in range ( 1 , len ( temp ) - 1 ) : NEW_LINE INDENT if ( temp [ j ] - temp [ j - 1 ] > temp [ j + 1 ] - temp [ j ] ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT ans = min ( ans , N - len ( temp ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def kvowelwords ( N , K ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE MOD = 1000000007 NEW_LINE dp = [ [ 0 for i in range ( K + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE sum = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = sum * 21 NEW_LINE dp [ i ] [ 0 ] %= MOD NEW_LINE sum = dp [ i ] [ 0 ] NEW_LINE for j in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( j > i ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( j == i ) : NEW_LINE INDENT dp [ i ] [ j ] = power ( 5 , i , MOD ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] * 5 NEW_LINE DEDENT dp [ i ] [ j ] %= MOD NEW_LINE sum += dp [ i ] [ j ] NEW_LINE sum %= MOD NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def maximumSum ( A , N , K , D ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( ( 1 << N ) ) : NEW_LINE INDENT sum = 0 NEW_LINE c = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( i >> j & 1 ) : NEW_LINE INDENT sum += A [ j ] NEW_LINE c += 1 NEW_LINE DEDENT DEDENT if ( sum % D == 0 and c <= K ) : NEW_LINE INDENT ans = max ( ans , sum ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maxSumWO3Consec ( A , N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return A [ 0 ] NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return A [ 0 ] + A [ 1 ] NEW_LINE DEDENT third = A [ 0 ] NEW_LINE second = third + A [ 1 ] NEW_LINE first = max ( second , A [ 1 ] + A [ 2 ] ) NEW_LINE sum = max ( max ( third , second ) , first ) NEW_LINE for i in range ( 3 , N , 1 ) : NEW_LINE INDENT sum = max ( max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) NEW_LINE third = second NEW_LINE second = first NEW_LINE first = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT
def longestSubsequence ( X , Y ) : NEW_LINE INDENT n = len ( X ) NEW_LINE m = len ( Y ) NEW_LINE mat = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , m + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT mat [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT mat [ i ] [ j ] = 1 + mat [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT len1 = 0 NEW_LINE col = 0 NEW_LINE for i in range ( 0 , m + 1 ) : NEW_LINE INDENT if ( mat [ n ] [ i ] > len1 ) : NEW_LINE INDENT len1 = mat [ n ] [ i ] NEW_LINE col = i NEW_LINE DEDENT DEDENT res = "" NEW_LINE i = n NEW_LINE j = col NEW_LINE while ( len1 > 0 ) : NEW_LINE INDENT if ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT res = X [ i - 1 ] + res NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE len1 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def calculateStart ( n , m ) : NEW_LINE INDENT for i in range ( 1 , m , 1 ) : NEW_LINE INDENT start [ 0 ] [ i ] += start [ 0 ] [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT start [ i ] [ 0 ] += start [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT for j in range ( 1 , m , 1 ) : NEW_LINE INDENT start [ i ] [ j ] += max ( start [ i - 1 ] [ j ] , start [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT
def calculateEnd ( n , m ) : NEW_LINE INDENT i = n - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT ending [ i ] [ m - 1 ] += ending [ i + 1 ] [ m - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT i = m - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT ending [ n - 1 ] [ i ] += ending [ n - 1 ] [ i + 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT i = n - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT j = m - 2 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT ending [ i ] [ j ] += max ( ending [ i + 1 ] [ j ] , ending [ i ] [ j + 1 ] ) NEW_LINE j -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT
def maximumPathSum ( mat , n , m , q , coordinates ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT start [ i ] [ j ] = mat [ i ] [ j ] NEW_LINE ending [ i ] [ j ] = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT calculateStart ( n , m ) NEW_LINE calculateEnd ( n , m ) NEW_LINE ans = 0 NEW_LINE for i in range ( q ) : NEW_LINE INDENT X = coordinates [ i ] [ 0 ] - 1 NEW_LINE Y = coordinates [ i ] [ 1 ] - 1 NEW_LINE ans = max ( ans , start [ X ] [ Y ] + ending [ X ] [ Y ] - mat [ X ] [ Y ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def countAlternatingSubstrings ( S , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for i in range ( 2 ) ] NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i == N - 1 ) : NEW_LINE INDENT if ( S [ i ] == '1' ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 + dp [ 1 ] [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 + dp [ 0 ] [ i + 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans += max ( dp [ 0 ] [ i ] , dp [ 1 ] [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countSubset ( arr , n , diff ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT sum += diff NEW_LINE sum = sum // 2 NEW_LINE t = [ [ 0 for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for j in range ( sum + 1 ) : NEW_LINE INDENT t [ 0 ] [ j ] = 0 NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT t [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] > j ) : NEW_LINE INDENT t [ i ] [ j ] = t [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] NEW_LINE DEDENT DEDENT DEDENT return t [ n ] [ sum ] NEW_LINE DEDENT
def maximizeAnd ( i , mask , A , B , N , dp ) : NEW_LINE INDENT if ( i == N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ mask ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ mask ] NEW_LINE DEDENT for j in range ( N ) : NEW_LINE INDENT if ( ( mask & ( 1 << j ) ) == 0 ) : NEW_LINE INDENT dp [ i ] [ mask ] = max ( dp [ i ] [ mask ] , ( A [ i ] & B [ j ] ) + maximizeAnd ( i + 1 , mask | ( 1 << j ) , A , B , N , dp ) ) NEW_LINE DEDENT DEDENT return dp [ i ] [ mask ] NEW_LINE DEDENT
def maximizeAndUtil ( A , B , N ) : NEW_LINE INDENT temp = [ - 1 for i in range ( 1 << N + 1 ) ] NEW_LINE dp = [ temp for i in range ( N ) ] NEW_LINE return maximizeAnd ( 0 , 0 , A , B , N , dp ) NEW_LINE DEDENT
def countOfNumbers ( digit , prev1 , prev2 , N ) : NEW_LINE INDENT if ( digit == N + 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ digit ] [ prev1 ] [ prev2 ] != - 1 ) : NEW_LINE INDENT return dp [ digit ] [ prev1 ] [ prev2 ] NEW_LINE DEDENT dp [ digit ] [ prev1 ] [ prev2 ] = 0 NEW_LINE if ( digit == 1 ) : NEW_LINE INDENT term = 0 if N == 1 else 1 NEW_LINE for j in range ( term , 10 , 1 ) : NEW_LINE INDENT dp [ digit ] [ prev1 ] [ prev2 ] += countOfNumbers ( digit + 1 , j , prev1 , N ) NEW_LINE DEDENT DEDENT elif ( digit == 2 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT dp [ digit ] [ prev1 ] [ prev2 ] += countOfNumbers ( digit + 1 , j , prev1 , N ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( abs ( prev1 - prev2 ) + 1 ) : NEW_LINE INDENT dp [ digit ] [ prev1 ] [ prev2 ] += countOfNumbers ( digit + 1 , j , prev1 , N ) NEW_LINE DEDENT DEDENT return dp [ digit ] [ prev1 ] [ prev2 ] NEW_LINE DEDENT
def findNthNum ( N ) : NEW_LINE INDENT last_num = 0 NEW_LINE left = 1 NEW_LINE right = N NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = left + ( right - left ) // 2 NEW_LINE t = ( mid * ( mid + 1 ) ) // 2 NEW_LINE if ( t < N ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT elif ( t == N ) : NEW_LINE INDENT a = mid NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT a = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT DEDENT t = a - 1 NEW_LINE b = N - ( t * ( t + 1 ) ) // 2 - 1 NEW_LINE print ( ( 1 << a ) + ( 1 << b ) ) NEW_LINE DEDENT
def longestSubWithMaxSum ( arr , N ) : NEW_LINE INDENT Max = max ( arr ) NEW_LINE if ( Max < 0 ) : NEW_LINE INDENT print ( Max ) NEW_LINE return NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def maxSumUtil ( arr , n ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( 3 ) ] for j in range ( 100 ) ] NEW_LINE print ( maxSum ( arr , 0 , n , 2 , 0 , dp ) ) NEW_LINE DEDENT
def maximumSum ( arr , n ) : NEW_LINE INDENT preSum = [ 0 ] * n NEW_LINE sum = 0 NEW_LINE maxSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = max ( arr [ i ] , sum + arr [ i ] ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE preSum [ i ] = maxSum NEW_LINE DEDENT sum = 0 NEW_LINE maxSum = 0 NEW_LINE postSum = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = max ( arr [ i ] , sum + arr [ i ] ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE postSum [ i ] = maxSum NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , preSum [ i ] + postSum [ i + 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def NumberOfways ( N , K ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for row in range ( 1 , K + 1 ) : NEW_LINE INDENT for col in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( col >= row ) : NEW_LINE INDENT dp [ col ] = dp [ col ] + dp [ col - row ] NEW_LINE DEDENT DEDENT DEDENT return ( dp [ N ] ) NEW_LINE DEDENT
def findAPSequence ( arr , N , Q , M ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 5 ) NEW_LINE i = 0 NEW_LINE while i + 1 < N : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j + 1 < N and arr [ j + 1 ] - arr [ j ] == arr [ i + 1 ] - arr [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ k ] = j - k NEW_LINE DEDENT i = j NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT if ( dp [ Q [ i ] [ 0 ] ] >= Q [ i ] [ 1 ] - Q [ i ] [ 0 ] ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT DEDENT
def isUnique ( s ) : NEW_LINE INDENT return True if len ( set ( s ) ) == 1 else False NEW_LINE DEDENT
def maxScore ( s , a ) : NEW_LINE INDENT n = len ( s ) NEW_LINE if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT mx = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT sub = s [ i : j + 1 ] NEW_LINE if isUnique ( sub ) : NEW_LINE INDENT mx = max ( mx , a [ len ( sub ) - 1 ] + maxScore ( s [ : i ] + s [ j + 1 : ] , a ) ) NEW_LINE DEDENT DEDENT DEDENT return mx NEW_LINE DEDENT
def numberOfUniqueOutcomes ( N , S ) : NEW_LINE INDENT if ( S < N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 1 or N == S ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( numberOfUniqueOutcomes ( N - 1 , S - 1 ) + numberOfUniqueOutcomes ( N - 1 , S - 2 ) ) NEW_LINE DEDENT
def numberOfUniqueOutcomes ( n , s ) : NEW_LINE INDENT if ( s < n ) : NEW_LINE INDENT ans [ n ] [ s ] = 0 NEW_LINE DEDENT elif ( n == 1 or n == s ) : NEW_LINE INDENT ans [ n ] [ s ] = 1 NEW_LINE DEDENT elif ( ans [ n ] [ s ] == 0 ) : NEW_LINE INDENT ans [ n ] [ s ] = ( numberOfUniqueOutcomes ( n - 1 , s - 1 ) + numberOfUniqueOutcomes ( n - 1 , s - 2 ) ) NEW_LINE DEDENT return ans [ n ] [ s ] NEW_LINE DEDENT
def MinimumLength ( A , N , K ) : NEW_LINE INDENT A . sort ( ) NEW_LINE suffix = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT suffix [ i ] = suffix [ i + 1 ] + A [ i ] NEW_LINE DEDENT dp = [ [ 0 ] * ( K + 1 ) ] * ( N + 1 ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( K + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = MAX NEW_LINE DEDENT DEDENT dp [ N ] [ 0 ] = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( K , - 1 , - 1 ) : NEW_LINE INDENT if ( j <= A [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = A [ i ] NEW_LINE continue NEW_LINE DEDENT if ( dp [ i + 1 ] [ j - A [ i ] ] == MAX ) : NEW_LINE INDENT dp [ i ] [ j ] = MAX NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i + 1 ] [ j ] , dp [ i + 1 ] [ j - A [ i ] ] + A [ i ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( suffix [ i ] - dp [ i ] [ K ] >= K ) : NEW_LINE INDENT return N - i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countXOR ( arr , comb , start , end , index , r ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT new_xor = 0 NEW_LINE for j in range ( r ) : NEW_LINE INDENT new_xor ^= comb [ j ] NEW_LINE DEDENT s . add ( new_xor ) NEW_LINE return NEW_LINE DEDENT i = start NEW_LINE while i <= end and ( end - i + 1 ) >= ( r - index ) : NEW_LINE INDENT comb [ index ] = arr [ i ] NEW_LINE countXOR ( arr , comb , i + 1 , end , index + 1 , r ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def maxSizeSet ( arr , N ) : NEW_LINE INDENT for r in range ( 2 , N + 1 ) : NEW_LINE INDENT comb = [ 0 ] * ( r + 1 ) NEW_LINE countXOR ( arr , comb , 0 , N - 1 , 0 , r ) NEW_LINE DEDENT print ( len ( s ) ) NEW_LINE DEDENT
def maxSizeSet ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT insertVector ( arr [ i ] ) NEW_LINE DEDENT print ( ( 1 << ans ) ) NEW_LINE DEDENT
def waysToPaint ( n ) : NEW_LINE INDENT same = 6 NEW_LINE diff = 6 NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT sameTmp = 3 * same + 2 * diff NEW_LINE diffTmp = 2 * same + 2 * diff NEW_LINE same = sameTmp NEW_LINE diff = diffTmp NEW_LINE DEDENT print ( same + diff ) NEW_LINE DEDENT
def printMinimumRemovals ( s , X ) : NEW_LINE INDENT N = len ( s ) NEW_LINE M = len ( X ) NEW_LINE dp = [ [ 0 for x in range ( M ) ] for y in range ( N ) ] NEW_LINE for j in range ( M ) : NEW_LINE INDENT if ( s [ 0 ] == X [ j ] ) : NEW_LINE INDENT dp [ 0 ] [ j ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( s [ i ] == X [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + 1 NEW_LINE if ( j != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N - 1 ] [ M - 1 ] ) NEW_LINE DEDENT
def maxSubarraySum ( sum , k , row ) : NEW_LINE INDENT curSum , curMax = 0 , - sys . maxsize - 1 NEW_LINE sumSet = { } NEW_LINE sumSet [ 0 ] = 1 NEW_LINE for r in range ( row ) : NEW_LINE INDENT curSum += sum [ r ] NEW_LINE arr = list ( sumSet . keys ( ) ) NEW_LINE it = bisect_left ( arr , curSum - k ) NEW_LINE if ( it != len ( arr ) ) : NEW_LINE INDENT curMax = max ( curMax , curSum - it ) NEW_LINE DEDENT sumSet [ curSum ] = 1 NEW_LINE DEDENT return curMax NEW_LINE DEDENT
def maxSumSubmatrix ( matrix , k ) : NEW_LINE INDENT row = len ( matrix ) NEW_LINE col = len ( matrix [ 0 ] ) NEW_LINE ret = - sys . maxsize - 1 NEW_LINE for i in range ( col ) : NEW_LINE INDENT sum = [ 0 ] * ( row ) NEW_LINE for j in range ( i , col ) : NEW_LINE INDENT for r in range ( row ) : NEW_LINE INDENT sum [ r ] += matrix [ r ] [ j ] NEW_LINE DEDENT curMax = maxSubarraySum ( sum , k , row ) NEW_LINE ret = max ( ret , curMax ) NEW_LINE DEDENT DEDENT print ( ret ) NEW_LINE DEDENT
def minCost ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = arr [ 0 ] NEW_LINE dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] NEW_LINE for i in range ( 2 , n - 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) NEW_LINE DEDENT dp [ n - 1 ] = min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) NEW_LINE print ( dp [ n - 1 ] ) NEW_LINE DEDENT
def maxSum ( arr , N , K ) : NEW_LINE INDENT dp = [ 0 for i in range ( N + 2 ) ] NEW_LINE maxval = 0 NEW_LINE i = N - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( ( i + K * arr [ i ] ) >= N ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i + K * arr [ i ] ] + arr [ i ] NEW_LINE DEDENT maxval = max ( maxval , dp [ i ] ) NEW_LINE i -= 1 NEW_LINE DEDENT print ( maxval ) NEW_LINE DEDENT
def maxSubmatrixSum ( matrix ) : NEW_LINE INDENT r = len ( matrix ) NEW_LINE c = len ( matrix [ 0 ] ) NEW_LINE maxSubmatrix = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT for k in range ( i , r ) : NEW_LINE INDENT for l in range ( j , c ) : NEW_LINE INDENT sumSubmatrix = 0 NEW_LINE for m in range ( i , k + 1 ) : NEW_LINE INDENT for n in range ( j , l + 1 ) : NEW_LINE INDENT sumSubmatrix += matrix [ m ] [ n ] NEW_LINE DEDENT DEDENT maxSubmatrix = max ( maxSubmatrix , sumSubmatrix ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( maxSubmatrix ) NEW_LINE DEDENT
def kadane ( v ) : NEW_LINE INDENT currSum = 0 NEW_LINE maxSum = - sys . maxsize - 1 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT currSum += v [ i ] NEW_LINE if ( currSum > maxSum ) : NEW_LINE INDENT maxSum = currSum NEW_LINE DEDENT if ( currSum < 0 ) : NEW_LINE INDENT currSum = 0 NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT
def minCost ( costs , N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] NEW_LINE dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] NEW_LINE dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] NEW_LINE dp [ i ] [ 2 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] NEW_LINE DEDENT print ( min ( dp [ N - 1 ] [ 0 ] , min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ) NEW_LINE DEDENT
def findCnt ( arr , i , required_sum , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( required_sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( v [ i ] [ required_sum + Base ] ) : NEW_LINE INDENT return dp [ i ] [ required_sum + Base ] NEW_LINE DEDENT v [ i ] [ required_sum + Base ] = True NEW_LINE dp [ i ] [ required_sum + Base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) NEW_LINE return dp [ i ] [ required_sum + Base ] NEW_LINE DEDENT
def countSubsets ( arr , K , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT S1 = ( sum + K ) // 2 NEW_LINE print ( findCnt ( arr , 0 , S1 , n ) ) NEW_LINE DEDENT
def solve ( A , i , sum , N ) : NEW_LINE INDENT res = 2001 NEW_LINE if ( sum < 0 or ( i == N and sum != 0 ) ) : NEW_LINE INDENT return 2001 NEW_LINE DEDENT if ( sum == 0 or i >= N ) : NEW_LINE INDENT dp [ i ] [ sum ] = 0 NEW_LINE return 0 NEW_LINE DEDENT if ( dp [ i ] [ sum ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ sum ] NEW_LINE DEDENT res = min ( solve ( A , i + 1 , sum - A [ i ] , N ) + 1 , solve ( A , i + 1 , sum , N ) ) NEW_LINE dp [ i ] [ sum ] = res NEW_LINE return res NEW_LINE DEDENT
def daysToCure ( arr , N , P ) : NEW_LINE INDENT risk = 0 NEW_LINE normal_risk = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] >= 60 or arr [ i ] <= 10 ) : NEW_LINE INDENT risk += 1 NEW_LINE DEDENT else : NEW_LINE INDENT normal_risk += 1 NEW_LINE DEDENT DEDENT days = ( risk // P ) + ( risk % P > 0 ) + ( normal_risk // P ) + ( normal_risk % P > 0 ) NEW_LINE print ( days ) NEW_LINE DEDENT
def countAverage ( n , K , arr ) : NEW_LINE INDENT global dp NEW_LINE dp [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT for s in range ( 100 ) : NEW_LINE INDENT dp [ i + 1 ] [ k + 1 ] [ s + arr [ i ] ] += dp [ i ] [ k ] [ s ] NEW_LINE dp [ i + 1 ] [ k ] [ s ] += dp [ i ] [ k ] [ s ] NEW_LINE DEDENT DEDENT DEDENT cnt = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT cnt += dp [ n ] [ j ] [ K * j ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def maximumSubsetSum ( arr1 , arr2 , length ) : NEW_LINE INDENT dp = [ 0 ] * ( length + 1 ) NEW_LINE if ( length == 1 ) : NEW_LINE INDENT print ( max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) NEW_LINE return NEW_LINE DEDENT if ( length == 2 ) : NEW_LINE INDENT print ( max ( max ( arr1 [ 1 ] , arr2 [ 1 ] ) , max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] = max ( arr1 [ 0 ] , arr2 [ 0 ] ) NEW_LINE dp [ 1 ] = max ( max ( arr1 [ 1 ] , arr2 [ 1 ] ) , max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) NEW_LINE index = 2 NEW_LINE while ( index < length ) : NEW_LINE INDENT dp [ index ] = max ( max ( arr1 [ index ] , arr2 [ index ] ) , max ( max ( arr1 [ index ] + dp [ index - 2 ] , arr2 [ index ] + dp [ index - 2 ] ) , dp [ index - 1 ] ) ) NEW_LINE index += 1 NEW_LINE DEDENT print ( dp [ length - 1 ] ) NEW_LINE DEDENT DEDENT
def FindMaxS ( X , Y , Z , n , A , B , C ) : NEW_LINE INDENT if ( X < 0 or Y < 0 or Z < 0 ) : NEW_LINE INDENT return - sys . maxsize - 1 NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ X ] [ Y ] [ Z ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ X ] [ Y ] [ Z ] NEW_LINE DEDENT ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) NEW_LINE ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) NEW_LINE co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) NEW_LINE no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) NEW_LINE maximum = max ( ch , max ( ca , max ( co , no ) ) ) NEW_LINE dp [ n ] [ X ] [ Y ] [ Z ] = maximum NEW_LINE return dp [ n ] [ X ] [ Y ] [ Z ] NEW_LINE DEDENT
def findCount ( N , maxDigit ) : NEW_LINE INDENT ans = findCountUtil ( N , maxDigit , 0 , 0 , 1 ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def find ( N , sum ) : NEW_LINE INDENT if ( sum > 6 * N or sum < N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT if ( sum >= 1 and sum <= 6 ) : NEW_LINE INDENT return 1.0 / 6 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT s = s + find ( N - 1 , sum - i ) / 6 NEW_LINE DEDENT return s NEW_LINE DEDENT
def find ( N , sum ) : NEW_LINE INDENT if ( N < 0 sum < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ N ] [ sum ] > 0 ) : NEW_LINE INDENT return dp [ N ] [ sum ] NEW_LINE DEDENT if ( sum > 6 * N or sum < N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT if ( sum >= 1 and sum <= 6 ) : NEW_LINE INDENT return ( float ) ( 1.0 / 6 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , 7 ) : NEW_LINE INDENT dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 NEW_LINE DEDENT return dp [ N ] [ sum ] NEW_LINE DEDENT
def find ( N , a , b ) : NEW_LINE INDENT probability = 0.0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1.0 / 6 NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT for j in range ( i , ( 6 * i ) + 1 ) : NEW_LINE INDENT for k in range ( 1 , 7 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 NEW_LINE DEDENT DEDENT DEDENT for Sum in range ( a , b + 1 ) : NEW_LINE INDENT probability = probability + dp [ N ] [ Sum ] NEW_LINE DEDENT return probability NEW_LINE DEDENT
def minAtEachIndex ( n , arr ) : NEW_LINE INDENT dp1 = [ 0 ] * n NEW_LINE dp2 = [ 0 ] * n NEW_LINE i = 0 NEW_LINE dp1 [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp1 [ i ] = min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) NEW_LINE DEDENT dp2 [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp2 [ i ] = min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) NEW_LINE DEDENT v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT v . append ( min ( dp1 [ i ] , dp2 [ i ] ) ) NEW_LINE DEDENT for x in v : NEW_LINE INDENT print ( x , end = " " ) NEW_LINE DEDENT DEDENT
def totalArrays ( N , M ) : NEW_LINE INDENT end_with_one = [ 0 ] * ( N + 1 ) NEW_LINE end_not_with_one = [ 0 ] * ( N + 1 ) NEW_LINE end_with_one [ 0 ] = 1 NEW_LINE end_not_with_one [ 0 ] = 0 NEW_LINE end_with_one [ 1 ] = 0 NEW_LINE end_not_with_one [ 1 ] = M - 1 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT end_with_one [ i ] = end_not_with_one [ i - 1 ] NEW_LINE end_not_with_one [ i ] = end_with_one [ i - 1 ] * ( M - 1 ) + end_not_with_one [ i - 1 ] * ( M - 2 ) NEW_LINE DEDENT return end_with_one [ N - 1 ] NEW_LINE DEDENT
def prodOfDigit ( N ) : NEW_LINE INDENT res = 1 NEW_LINE while ( N ) : NEW_LINE INDENT res = res * ( N % 10 ) NEW_LINE N //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT
def cntNum ( X , i , prod , K , st , tight , dp ) : NEW_LINE INDENT end = 0 NEW_LINE if ( i >= len ( X ) or prod > K ) : NEW_LINE INDENT if ( prod == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ prod ] [ i ] [ tight ] [ st ] != - 1 ) : NEW_LINE INDENT return dp [ prod ] [ i ] [ tight ] [ st ] NEW_LINE DEDENT res = 0 NEW_LINE if ( tight != 0 ) : NEW_LINE INDENT end = ord ( X [ i ] ) - ord ( '0' ) NEW_LINE DEDENT for j in range ( end + 1 ) : NEW_LINE INDENT if ( j == 0 and st == 0 ) : NEW_LINE INDENT res += cntNum ( X , i + 1 , prod , K , False , ( tight & ( j == end ) ) , dp ) NEW_LINE DEDENT else : NEW_LINE INDENT res += cntNum ( X , i + 1 , prod * j , K , True , ( tight & ( j == end ) ) , dp ) NEW_LINE DEDENT DEDENT dp [ prod ] [ i ] [ tight ] [ st ] = res NEW_LINE return res NEW_LINE DEDENT DEDENT
def power ( X , Y ) : NEW_LINE INDENT res = 1 NEW_LINE X = X % M NEW_LINE if ( X == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( Y > 0 ) : NEW_LINE INDENT if ( Y & 1 ) : NEW_LINE INDENT res = ( res * X ) % M NEW_LINE DEDENT Y = Y >> 1 NEW_LINE X = ( X * X ) % M NEW_LINE DEDENT return res NEW_LINE DEDENT
def findValue ( n ) : NEW_LINE INDENT X = 0 NEW_LINE pow_10 = 1 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT X += pow_10 NEW_LINE DEDENT pow_10 *= 10 NEW_LINE n //= 2 NEW_LINE DEDENT X = ( X * 2 ) % M NEW_LINE res = power ( 2 , X ) NEW_LINE return res NEW_LINE DEDENT
def mod_pow2 ( n ) : NEW_LINE INDENT while n >= len ( MEM ) : NEW_LINE INDENT MEM . append ( ( MEM [ - 1 ] * 2 ) % MOD ) NEW_LINE DEDENT return MEM [ n ] NEW_LINE DEDENT
def inversions ( bstr ) : NEW_LINE INDENT total , zeros , questions = ( 0 , ) * 3 NEW_LINE for x in reversed ( bstr ) : NEW_LINE INDENT if x == '1' : NEW_LINE INDENT z = zeros * mod_pow2 ( questions ) NEW_LINE if questions == 0 : NEW_LINE INDENT q = 0 NEW_LINE DEDENT else : NEW_LINE INDENT q = questions * mod_pow2 ( questions - 1 ) NEW_LINE DEDENT total = ( total + z + q ) % MOD NEW_LINE DEDENT elif x == '0' : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT total *= 2 NEW_LINE z = zeros * mod_pow2 ( questions ) NEW_LINE if questions == 0 : NEW_LINE INDENT q = 0 NEW_LINE DEDENT else : NEW_LINE INDENT q = questions * mod_pow2 ( questions - 1 ) NEW_LINE DEDENT total = ( total + z + q ) % MOD NEW_LINE questions += 1 NEW_LINE DEDENT DEDENT return total NEW_LINE DEDENT
def findMedXOR ( mat , N , M ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( M ) ] for j in range ( N ) ] NEW_LINE med = [ 0 ] * ( N * M ) NEW_LINE dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] NEW_LINE med [ 0 ] = dp [ 0 ] [ 0 ] NEW_LINE len = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ^ mat [ i ] [ 0 ] NEW_LINE med [ len ] = dp [ i ] [ 0 ] NEW_LINE len += 1 NEW_LINE DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ^ mat [ 0 ] [ i ] NEW_LINE med [ len ] = dp [ 0 ] [ i ] NEW_LINE len += 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , M ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ^ dp [ i ] [ j - 1 ] ^ dp [ i - 1 ] [ j - 1 ] ^ mat [ i ] [ j ] NEW_LINE med [ len ] = dp [ i ] [ j ] NEW_LINE len += 1 NEW_LINE DEDENT DEDENT med . sort ( ) NEW_LINE if ( len % 2 == 0 ) : NEW_LINE INDENT return ( med [ ( len // 2 ) ] + med [ ( len // 2 ) - 1 ] ) / 2.0 NEW_LINE DEDENT return med [ len // 2 ] NEW_LINE DEDENT
def countTriplets ( A ) : NEW_LINE INDENT cnt = 0 NEW_LINE tuples = { } NEW_LINE for a in A : NEW_LINE INDENT for b in A : NEW_LINE INDENT if ( a & b ) in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 NEW_LINE DEDENT DEDENT DEDENT for a in A : NEW_LINE INDENT for t in tuples : NEW_LINE INDENT if ( ( t & a ) == 0 ) : NEW_LINE INDENT cnt += tuples [ t ] NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def countVowelPermutation ( n ) : NEW_LINE INDENT MOD = 1e9 + 7 NEW_LINE dp = [ [ 0 for i in range ( 5 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT relation = [ [ 1 ] , [ 0 , 2 ] , [ 0 , 1 , 3 , 4 ] , [ 2 , 4 ] , [ 0 ] ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT for u in range ( 5 ) : NEW_LINE INDENT dp [ i + 1 ] [ u ] = 0 NEW_LINE for v in relation [ u ] : NEW_LINE INDENT dp [ i + 1 ] [ u ] += dp [ i ] [ v ] % MOD NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans = ( ans + dp [ n ] [ i ] ) % MOD NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT
def MaximumSubarraySum ( n , arr , k ) : NEW_LINE INDENT mxSubSum ( n - 1 , arr , k ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT res = max ( res , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT if ( max ( arr ) < 0 ) : NEW_LINE INDENT res = max ( arr ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countWaysToTileBoard ( N ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 2 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) NEW_LINE DEDENT print ( dp [ N ] ) NEW_LINE DEDENT
def DFS ( node , parent , Val ) : NEW_LINE INDENT answer [ node ] = Val [ node ] NEW_LINE for child in adj [ node ] : NEW_LINE INDENT if ( child == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT DFS ( child , node , Val ) NEW_LINE answer [ node ] = ( answer [ node ] answer [ child ] ) NEW_LINE DEDENT DEDENT
def preprocess ( Val ) : NEW_LINE INDENT DFS ( 1 , - 1 , Val ) NEW_LINE DEDENT
def findSubtreeOR ( Queries , Q , Val ) : NEW_LINE INDENT preprocess ( Val ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT print ( answer [ Queries [ i ] ] , end = ' ' ) NEW_LINE DEDENT DEDENT
def minCost ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE m = 2 * n NEW_LINE cost = [ [ INF for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE cost [ 0 ] [ 0 ] = 0 NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prev = cost [ i - 1 ] [ 0 ] NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT cost [ i ] [ j ] = min ( cost [ i ] [ j ] , prev + abs ( j - arr [ i - 1 ] ) ) NEW_LINE prev = min ( prev , cost [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT minCost = INF NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT minCost = min ( minCost , cost [ n ] [ j ] ) NEW_LINE DEDENT print ( minCost ) NEW_LINE DEDENT
def FindSub ( string , res , i ) : NEW_LINE INDENT if ( i == len ( string ) ) : NEW_LINE INDENT if ( len ( res ) > 0 ) : NEW_LINE INDENT print ( res , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT ch = string [ i ] NEW_LINE FindSub ( string , res , i + 1 ) NEW_LINE FindSub ( string , res + ch , i + 1 ) NEW_LINE FindSub ( string , res + str ( ord ( ch ) ) , i + 1 ) NEW_LINE DEDENT
def MinOp ( N ) : NEW_LINE INDENT if ( N <= 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT bit = ( int ) ( math . log ( N ) / math . log ( 2 ) ) + 1 NEW_LINE return ( ( 1 << bit ) - 1 ) - MinOp ( N - ( 1 << ( bit - 1 ) ) ) NEW_LINE DEDENT
def max ( a , b ) : NEW_LINE INDENT if ( a > b ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT
def maximumsum ( arr , K , N , M ) : NEW_LINE INDENT sum = 0 NEW_LINE maxSum = 0 NEW_LINE dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( K + 1 ) ] NEW_LINE for i in range ( 0 , N + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( 0 , K + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT sum = 0 NEW_LINE maxSum = dp [ i ] [ j ] NEW_LINE for k in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( k > M ) : NEW_LINE INDENT break NEW_LINE DEDENT sum += arr [ j ] [ k - 1 ] NEW_LINE maxSum = max ( maxSum , sum + dp [ i - k ] [ j ] ) NEW_LINE DEDENT dp [ i ] [ j + 1 ] = maxSum NEW_LINE DEDENT DEDENT return dp [ K ] [ N ] NEW_LINE DEDENT
def check ( memo , i , j , A ) : NEW_LINE INDENT if ( i == N - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( memo [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return memo [ i ] [ j ] NEW_LINE DEDENT flag = 0 NEW_LINE for k in range ( i + 1 , N ) : NEW_LINE INDENT if ( A [ k ] - A [ i ] > j + 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( A [ k ] - A [ i ] >= j - 1 and A [ k ] - A [ i ] <= j + 1 ) : NEW_LINE INDENT flag = check ( memo , k , A [ k ] - A [ i ] , A ) NEW_LINE DEDENT if ( flag != 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT memo [ i ] [ j ] = flag NEW_LINE return memo [ i ] [ j ] NEW_LINE DEDENT DEDENT
def checkEndReach ( A , K ) : NEW_LINE INDENT memo = [ [ 0 ] * N ] * N NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT memo [ i ] [ j ] = - 1 NEW_LINE DEDENT startIndex = 1 NEW_LINE if ( check ( memo , startIndex , K , A ) != 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT DEDENT
def maxProductPath ( grid ) : NEW_LINE INDENT n , m = len ( grid ) , len ( grid [ 0 ] ) NEW_LINE maxPath = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] NEW_LINE minPath = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT mn = float ( "inf" ) NEW_LINE mx = float ( "-inf" ) NEW_LINE if ( i == 0 and j == 0 ) : NEW_LINE INDENT mx = grid [ i ] [ j ] NEW_LINE mn = grid [ i ] [ j ] NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT tempmx = max ( ( maxPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) , ( minPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) ) NEW_LINE mx = max ( mx , tempmx ) NEW_LINE tempmn = min ( ( maxPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) , ( minPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) ) NEW_LINE mn = min ( mn , tempmn ) NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT tempmx = max ( ( maxPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) , ( minPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) ) NEW_LINE mx = max ( mx , tempmx ) NEW_LINE tempmn = min ( ( maxPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) , ( minPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) ) NEW_LINE mn = min ( mn , tempmn ) NEW_LINE DEDENT maxPath [ i ] [ j ] = mx NEW_LINE minPath [ i ] [ j ] = mn NEW_LINE DEDENT DEDENT if ( maxPath [ n - 1 ] [ m - 1 ] < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( maxPath [ n - 1 ] [ m - 1 ] ) NEW_LINE DEDENT DEDENT
def waysToArrangeKLengthStrings ( N , K ) : NEW_LINE INDENT column_sum = [ 0 for i in range ( N + 1 ) ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( K + 1 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE column_sum [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] += column_sum [ j - 1 ] NEW_LINE column_sum [ j ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( dp [ K ] [ N ] ) NEW_LINE DEDENT
def findNumberOfLIS ( nums ) : NEW_LINE INDENT if not nums : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = len ( nums ) NEW_LINE dp_l = [ 1 ] * n NEW_LINE dp_c = [ 1 ] * n NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if nums [ i ] <= nums [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT if dp_l [ j ] + 1 > dp_l [ i ] : NEW_LINE INDENT dp_l [ i ] = dp_l [ j ] + 1 NEW_LINE dp_c [ i ] = dp_c [ j ] NEW_LINE DEDENT elif dp_l [ j ] + 1 == dp_l [ i ] : NEW_LINE INDENT dp_c [ i ] += dp_c [ j ] NEW_LINE DEDENT DEDENT DEDENT max_length = max ( x for x in dp_l ) NEW_LINE count = 0 NEW_LINE for l , c in zip ( dp_l , dp_c ) : NEW_LINE INDENT if l == max_length : NEW_LINE INDENT count += c NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countPenality ( arr , N ) : NEW_LINE INDENT pos = 0 NEW_LINE turn = False NEW_LINE return findMinimum ( arr , N , pos , turn ) + 1 NEW_LINE DEDENT
def printAnswer ( arr , N ) : NEW_LINE INDENT a = countPenality ( arr , N ) NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( a ) NEW_LINE DEDENT
def removeSmallestSubarray ( arr , S , n , k ) : NEW_LINE INDENT target_remainder = S % k NEW_LINE map1 = { } NEW_LINE map1 [ 0 ] = - 1 NEW_LINE curr_remainder = 0 NEW_LINE res = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_remainder = ( curr_remainder + arr [ i ] + k ) % k NEW_LINE map1 [ curr_remainder ] = i NEW_LINE mod = ( curr_remainder - target_remainder + k ) % k NEW_LINE if ( mod in map1 ) : NEW_LINE INDENT res = min ( res , i - map1 [ mod ] ) NEW_LINE DEDENT DEDENT if ( res == sys . maxsize or res == n ) : NEW_LINE INDENT res = - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def smstSubmatDeleted ( mat , N , M , K ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT S += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT min_area = N * M NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE width = 0 NEW_LINE area = 0 NEW_LINE prefixRowSm = [ 0 ] * N NEW_LINE for left in range ( M ) : NEW_LINE INDENT prefixRowSum = [ 0 ] * N NEW_LINE for right in range ( left , M ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT prefixRowSum [ i ] += mat [ i ] [ right ] NEW_LINE DEDENT width = removeSmallestSubarray ( prefixRowSum , S , N , K ) NEW_LINE if ( width != - 1 ) : NEW_LINE INDENT area = ( right - left + 1 ) * ( width ) NEW_LINE if ( area < min_area ) : NEW_LINE INDENT min_area = area NEW_LINE DEDENT DEDENT DEDENT DEDENT return min_area NEW_LINE DEDENT
def countstrings ( n , start ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( start , 5 ) : NEW_LINE INDENT cnt += countstrings ( n - 1 , i ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def findNumberOfStrings ( n ) : NEW_LINE INDENT DP = [ [ 0 for i in range ( 6 ) ] for i in range ( n + 1 ) ] NEW_LINE DP [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 6 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + DP [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return DP [ n ] [ 5 ] NEW_LINE DEDENT
def findNumberOfStrings ( n ) : NEW_LINE INDENT return int ( ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ) NEW_LINE DEDENT
def check ( sum , x , y ) : NEW_LINE INDENT while ( sum > 0 ) : NEW_LINE INDENT ln = sum % 10 NEW_LINE if ( ln != x and ln != y ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum //= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def countNumbers ( n , x , y , sum ) : NEW_LINE INDENT global dp NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return check ( sum , x , y ) NEW_LINE DEDENT if ( dp [ n ] [ sum ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ sum ] % mod NEW_LINE DEDENT option1 = countNumbers ( n - 1 , x , y , sum + x ) % mod NEW_LINE option2 = countNumbers ( n - 1 , x , y , sum + y ) % mod NEW_LINE dp [ n ] [ sum ] = ( option1 + option2 ) % mod NEW_LINE return dp [ n ] [ sum ] NEW_LINE DEDENT
def findTotalPath ( X , n , dp ) : NEW_LINE INDENT if ( X == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE if ( dp [ X ] != - 1 ) : NEW_LINE INDENT return dp [ X ] NEW_LINE DEDENT for i in range ( 1 , min ( X , n ) + 1 ) : NEW_LINE INDENT ans = ans + findTotalPath ( X - i , n , dp ) % mod NEW_LINE ans %= mod NEW_LINE DEDENT dp [ X ] = ans NEW_LINE return ans NEW_LINE DEDENT
def printAnswer ( n , edges , vals ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT u = edges [ i ] [ 0 ] - 1 NEW_LINE v = edges [ i ] [ 1 ] - 1 NEW_LINE adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT dfs ( 0 , - 1 ) NEW_LINE for x in ans : NEW_LINE INDENT print ( x , end = " " ) NEW_LINE DEDENT DEDENT
def checkEvenOddLevel ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return True NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE level = 0 NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT l = [ ] NEW_LINE size = len ( q ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT node = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( node . left != None ) : NEW_LINE INDENT q . append ( node . left ) NEW_LINE DEDENT if ( node . right != None ) : NEW_LINE INDENT q . append ( node . right ) NEW_LINE DEDENT if ( level % 2 == 0 ) : NEW_LINE INDENT for i in range ( len ( l ) - 1 ) : NEW_LINE INDENT if ( l [ i + 1 ] > l [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT elif ( level % 2 == 1 ) : NEW_LINE INDENT for i in range ( len ( l ) - 1 ) : NEW_LINE INDENT if ( l [ i + 1 ] < l [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT level += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT
def build ( dp , arr , N ) : NEW_LINE INDENT dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 0 NEW_LINE prime = SieveOfEratosthenes ( ) NEW_LINE pref = [ 0 for i in range ( N + 1 ) ] NEW_LINE pref [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] NEW_LINE for j in range ( len ( prime ) + 1 ) : NEW_LINE INDENT r = i - 1 NEW_LINE l = r - prime [ j ] + 1 NEW_LINE if ( l < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT temp = 0 NEW_LINE temp = pref [ r + 1 ] - pref [ l ] NEW_LINE if ( l - 2 >= 0 ) : NEW_LINE INDENT temp += dp [ l - 2 + 1 ] NEW_LINE DEDENT dp [ i ] = max ( dp [ i ] , temp ) NEW_LINE DEDENT DEDENT DEDENT
def maxSumSubseq ( arr , N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N + 1 ) ] NEW_LINE build ( dp , arr , N ) NEW_LINE print ( dp [ N ] ) NEW_LINE DEDENT
def MinRunLengthEncoding ( s , n , k ) : NEW_LINE INDENT for i in range ( maxN ) : NEW_LINE INDENT for j in range ( 27 ) : NEW_LINE INDENT for k in range ( 27 ) : NEW_LINE INDENT for l in range ( maxN ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return solve ( s , n , 0 , k , chr ( 123 ) , 0 ) - 1 NEW_LINE DEDENT
def minimumCost ( A , B , M , N , C ) : NEW_LINE INDENT nums = [ 0 ] * 100000 NEW_LINE index = [ - 1 ] * 100000 NEW_LINE for i in range ( N ) : NEW_LINE INDENT index [ B [ i ] ] = i NEW_LINE DEDENT k = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if ( index [ A [ i ] ] != - 1 ) : NEW_LINE INDENT k += 1 NEW_LINE nums [ k ] = index [ A [ i ] ] NEW_LINE DEDENT DEDENT lcs_length = findLCS ( nums , k ) NEW_LINE elements_to_be_added = N - lcs_length NEW_LINE min_cost = elements_to_be_added * C NEW_LINE print ( min_cost ) NEW_LINE DEDENT
def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT dp = [ [ 0 ] * ( K + 1 ) ] * 2 NEW_LINE mod = 1000000007 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 0 , K + 1 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 1 if ( j == 0 ) else 0 NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT var = ( 0 if ( max ( j - ( i - 1 ) , 0 ) == 0 ) else dp [ 1 - i % 2 ] [ max ( j - ( i - 1 ) , 0 ) - 1 ] ) NEW_LINE dp [ i % 2 ] [ j ] = ( ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( var ) + mod ) % mod ) % mod ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N % 2 ] [ K ] ) NEW_LINE DEDENT
def maxScore ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE N += 1 NEW_LINE dp = [ [ - 100000 for i in range ( 2 * N ) ] for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for s in range ( 1 , 2 * ( N - 1 ) + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while j <= N - 1 and j <= s : NEW_LINE INDENT dp [ i ] [ s ] = max ( dp [ i ] [ s ] , arr [ j - 1 ] + dp [ i - 1 ] [ s - j ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT return dp [ N ] [ 2 * ( N - 1 ) ] NEW_LINE DEDENT
def minimumCost ( cost , n , x ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 2 ) NEW_LINE dp [ 0 ] = cost [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT dp [ i ] = cost [ i ] + dp [ i - 1 ] NEW_LINE DEDENT if ( i == 2 ) : NEW_LINE INDENT dp [ i ] = cost [ i ] + min ( dp [ i - 1 ] , x + dp [ i - 2 ] ) NEW_LINE DEDENT if ( i >= 3 ) : NEW_LINE INDENT dp [ i ] = ( cost [ i ] + min ( dp [ i - 1 ] , min ( x + dp [ i - 2 ] , 2 * x + dp [ i - 3 ] ) ) ) NEW_LINE DEDENT DEDENT print ( dp [ n - 1 ] ) NEW_LINE DEDENT
def maxSum ( a , n , k ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT option = maxSum ( a , n - 1 , k ) NEW_LINE if ( k >= a [ n - 1 ] ) : NEW_LINE INDENT option = max ( option , a [ n - 1 ] + maxSum ( a , n - 2 , k - a [ n - 1 ] ) ) NEW_LINE DEDENT return option NEW_LINE DEDENT
def checkStr ( str , P , Q ) : NEW_LINE INDENT N = len ( str ) NEW_LINE prev = str [ 0 ] NEW_LINE cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( str [ i ] == prev ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( prev == '1' and cnt >= Q ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( prev == '0' and cnt >= P ) : NEW_LINE INDENT return False NEW_LINE DEDENT cnt = 1 NEW_LINE DEDENT prev = str [ i ] NEW_LINE DEDENT if ( prev == '1' and cnt >= Q ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( prev == '0' and cnt >= P ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def cntBinStr ( str , N , P , Q ) : NEW_LINE INDENT lenn = len ( str ) NEW_LINE if ( lenn == N ) : NEW_LINE INDENT if ( checkStr ( str , P , Q ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT X = cntBinStr ( str + '0' , N , P , Q ) NEW_LINE Y = cntBinStr ( str + '1' , N , P , Q ) NEW_LINE return X + Y NEW_LINE DEDENT
def maxCount ( arr , m , V ) : NEW_LINE INDENT table = [ 0 for i in range ( V + 1 ) ] NEW_LINE table [ 0 ] = 0 NEW_LINE for i in range ( 1 , V + 1 , 1 ) : NEW_LINE INDENT table [ i ] = - 1 NEW_LINE for i in range ( 1 , V + 1 , 1 ) : NEW_LINE INDENT for j in range ( 0 , m , 1 ) : NEW_LINE INDENT if ( arr [ j ] <= i ) : NEW_LINE INDENT sub_res = table [ i - arr [ j ] ] NEW_LINE if ( sub_res != - 1 and sub_res + 1 > table [ i ] ) : NEW_LINE INDENT table [ i ] = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return table [ V ] NEW_LINE DEDENT
def binCoff ( N , R ) : NEW_LINE INDENT res = 1 NEW_LINE if ( R > ( N - R ) ) : NEW_LINE INDENT R = ( N - R ) NEW_LINE DEDENT for i in range ( R ) : NEW_LINE INDENT res *= ( N - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def cntPermutation ( N ) : NEW_LINE INDENT C_2N_N = binCoff ( 2 * N , N ) NEW_LINE cntPerm = C_2N_N // ( N + 1 ) NEW_LINE return cntPerm NEW_LINE DEDENT
def solve ( a , s , n , prev , mask , dp ) : NEW_LINE INDENT if ( mask == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ mask ] [ prev + 1 ] != - 1 ) : NEW_LINE INDENT return dp [ mask ] [ prev + 1 ] NEW_LINE DEDENT ans = 10000 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT id = ord ( s [ i ] ) - ord ( 'a' ) NEW_LINE if ( check ( mask , id ) ) : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT ans = min ( ans , solve ( a , s , n , id , mask ^ ( 1 << id ) , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , a [ prev ] [ id ] + solve ( a , s , n , id , mask ^ ( 1 << id ) , dp ) ) NEW_LINE DEDENT DEDENT DEDENT dp [ mask ] [ prev + 1 ] = ans NEW_LINE return ans NEW_LINE DEDENT
def longestPalSubstr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxLength = 1 NEW_LINE start = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT for j in range ( i , len ( str ) , 1 ) : NEW_LINE INDENT flag = 1 NEW_LINE for k in range ( ( j - i + 1 ) // 2 ) : NEW_LINE INDENT if ( str [ i + k ] != str [ j - k ] ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag != 0 and ( j - i + 1 ) > maxLength ) : NEW_LINE INDENT start = i NEW_LINE maxLength = j - i + 1 NEW_LINE DEDENT DEDENT DEDENT return maxLength NEW_LINE DEDENT
def mElementsWithMaxSum ( matrix , M , block , dp ) : NEW_LINE INDENT if block == len ( matrix ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ block ] [ M ] != - 1 ) : NEW_LINE INDENT return dp [ block ] [ M ] NEW_LINE DEDENT ans = mElementsWithMaxSum ( matrix , M , block + 1 , dp ) NEW_LINE for i in range ( len ( matrix [ block ] ) ) : NEW_LINE INDENT for j in range ( i , len ( matrix [ block ] ) ) : NEW_LINE INDENT if ( j - i + 1 <= M ) : NEW_LINE INDENT x = 0 NEW_LINE if i - 1 >= 0 : NEW_LINE INDENT x = matrix [ block ] [ i - 1 ] NEW_LINE DEDENT ans = max ( ans , matrix [ block ] [ j ] - x + mElementsWithMaxSum ( matrix , M - j + i - 1 , block + 1 , dp ) ) NEW_LINE DEDENT DEDENT DEDENT dp [ block ] [ M ] = ans NEW_LINE return ans NEW_LINE DEDENT
def preComputing ( matrix , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( len ( matrix [ i ] ) ) : NEW_LINE INDENT if j > 0 : NEW_LINE INDENT matrix [ i ] [ j ] = matrix [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return matrix NEW_LINE DEDENT
def mElementsWithMaxSumUtil ( matrix , M , N ) : NEW_LINE INDENT matrix = preComputing ( matrix , N ) NEW_LINE sum = 20 NEW_LINE dp = [ [ - 1 for i in range ( M + 5 ) ] for i in range ( N + 5 ) ] NEW_LINE sum += mElementsWithMaxSum ( matrix , M , 0 , dp ) NEW_LINE print ( sum ) NEW_LINE DEDENT
def lastRemaining ( n , dp ) : NEW_LINE INDENT if n in dp : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ n ] = 2 * ( 1 + n // 2 - lastRemaining ( n // 2 , dp ) ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def Max_Sum ( arr , K , N ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE prefix = [ None ] * ( N + 1 ) NEW_LINE prefix [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT dp [ i ] = prefix [ i ] NEW_LINE DEDENT for i in range ( K , N + 1 ) : NEW_LINE INDENT for j in range ( i , i - K , - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j - 1 ] + prefix [ i ] - prefix [ j ] ) NEW_LINE DEDENT DEDENT return dp [ N ] NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT
def waysToSplitN ( k , n , P ) : NEW_LINE INDENT new_N = n - k * P NEW_LINE return binomialCoeff ( new_N + k - 1 , new_N ) NEW_LINE DEDENT
def maximumSumUtil ( a , index , count , n ) : NEW_LINE INDENT if ( index > n or count > n + 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ index ] [ count ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ count ] NEW_LINE DEDENT ans1 = ( maximumSumUtil ( a , index + 1 , count + 1 , n ) + a [ index ] * count ) NEW_LINE ans2 = maximumSumUtil ( a , index + 1 , count , n ) NEW_LINE dp [ index ] [ count ] = max ( ans1 , ans2 ) NEW_LINE return dp [ index ] [ count ] NEW_LINE DEDENT
def maximumSum ( arr , N ) : NEW_LINE INDENT print ( maximumSumUtil ( arr , 0 , 1 , N - 1 ) ) NEW_LINE DEDENT
def Calculate_factorial ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , mx + 1 ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE fact [ i ] %= mod NEW_LINE DEDENT DEDENT
def UniModal_per ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE while ( b != 0 ) : NEW_LINE INDENT if ( b % 2 != 0 ) : NEW_LINE INDENT res = res * a NEW_LINE DEDENT res %= mod NEW_LINE a = a * a NEW_LINE a %= mod NEW_LINE b //= 2 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countPermutations ( n ) : NEW_LINE INDENT Calculate_factorial ( ) NEW_LINE uni_modal = UniModal_per ( 2 , n - 1 ) NEW_LINE nonuni_modal = fact [ n ] - uni_modal NEW_LINE print ( int ( uni_modal ) , "" , int ( nonuni_modal ) ) NEW_LINE return NEW_LINE DEDENT
def countMinCoinsUtil ( X , C , N ) : NEW_LINE INDENT isPossible = countMinCoins ( X , C , N ) NEW_LINE if ( isPossible == sys . maxsize ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT else : NEW_LINE INDENT findSolution ( X , C , N ) NEW_LINE DEDENT DEDENT
def helper ( arr , left , right , count , m ) : NEW_LINE INDENT if ( left > right ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ left ] [ right ] [ count ] != - 1 ) : NEW_LINE INDENT return dp [ left ] [ right ] [ count ] NEW_LINE DEDENT ans = ( ( count + 1 ) * m + helper ( arr , left + 1 , right , 0 , m ) ) NEW_LINE for i in range ( left + 1 , right + 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ left ] ) : NEW_LINE INDENT ans = ( max ( ans , helper ( arr , left + 1 , i - 1 , 0 , m ) + helper ( arr , i , right , count + 1 , m ) ) ) NEW_LINE DEDENT dp [ left ] [ right ] [ count ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT
def maxPoints ( arr , n , m ) : NEW_LINE INDENT length = n NEW_LINE global dp NEW_LINE return helper ( arr , 0 , length - 1 , 0 , m ) NEW_LINE DEDENT
def findWays ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT if ( N - i >= 0 ) : NEW_LINE INDENT cnt = cnt + findWays ( N - i ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def findWays ( N , dp ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ N ] != - 1 ) : NEW_LINE INDENT return dp [ N ] NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT if ( N - i >= 0 ) : NEW_LINE INDENT cnt = ( cnt + findWays ( N - i , dp ) ) NEW_LINE DEDENT DEDENT dp [ N ] = cnt NEW_LINE return dp [ N ] NEW_LINE DEDENT
def findWays ( N ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = 0 NEW_LINE for j in range ( 1 , 7 ) : NEW_LINE INDENT if ( i - j >= 0 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + dp [ i - j ] NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N ] ) NEW_LINE DEDENT
def findWays ( n ) : NEW_LINE INDENT n = n - 1 NEW_LINE a = binCoff ( 2 * n , n ) NEW_LINE b = a // ( n + 1 ) NEW_LINE ans = b NEW_LINE return ans NEW_LINE DEDENT
def find_sequence ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 , - 1 NEW_LINE DEDENT ans = ( find_sequence ( n - 1 ) [ 0 ] + 1 , n - 1 ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT div_by_2 = find_sequence ( n // 2 ) NEW_LINE if div_by_2 [ 0 ] < ans [ 0 ] : NEW_LINE INDENT ans = ( div_by_2 [ 0 ] + 1 , n // 2 ) NEW_LINE DEDENT DEDENT if n % 3 == 0 : NEW_LINE INDENT div_by_3 = find_sequence ( n // 3 ) NEW_LINE if div_by_3 [ 0 ] < ans [ 0 ] : NEW_LINE INDENT ans = ( div_by_3 [ 0 ] + 1 , n // 3 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def FindNoOfFullVessels ( n , t ) : NEW_LINE INDENT Matrix = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE Matrix [ 0 ] [ 0 ] = t * 1.0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT exceededwater = Matrix [ i ] [ j ] - 1.0 NEW_LINE if ( exceededwater < 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT ans += 1 NEW_LINE if ( i + 1 < n ) : NEW_LINE INDENT Matrix [ i + 1 ] [ j ] += exceededwater / 2 NEW_LINE DEDENT if ( i + 1 < n and j + 1 < n ) : NEW_LINE INDENT Matrix [ i + 1 ] [ j + 1 ] += exceededwater / 2 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def minCountOfNumbers ( N ) : NEW_LINE INDENT k = N % 10 NEW_LINE z = N - ( 9 * ( 9 - k ) ) NEW_LINE if ( z >= 9 and z % 10 == 9 ) : NEW_LINE INDENT return 10 - k NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 , j ) : NEW_LINE INDENT if j == N : NEW_LINE INDENT if sm1 == sm2 and sm2 == sm3 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) NEW_LINE m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) NEW_LINE r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) NEW_LINE return max ( l , m , r ) NEW_LINE DEDENT DEDENT
def checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 , j ) : NEW_LINE INDENT s = str ( sm1 ) + "_" + str ( sm2 ) + str ( j ) NEW_LINE if j == N : NEW_LINE INDENT if sm1 == sm2 and sm2 == sm3 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if s in dp : NEW_LINE INDENT return dp [ s ] NEW_LINE DEDENT l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) NEW_LINE m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) NEW_LINE r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) NEW_LINE dp [ s ] = max ( l , m , r ) NEW_LINE return dp [ s ] NEW_LINE DEDENT
def checkEqualSum ( arr , N ) : NEW_LINE INDENT sum1 = sum2 = sum3 = 0 NEW_LINE if checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def manipulation ( matrix , q ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = q NEW_LINE for i in range ( x1 - 1 , x2 ) : NEW_LINE INDENT for j in range ( y1 - 1 , y2 ) : NEW_LINE INDENT if matrix [ i ] [ j ] : NEW_LINE INDENT matrix [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT matrix [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def solve ( s , t ) : NEW_LINE INDENT n = len ( s ) NEW_LINE r = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE if ( i > 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT if ( s [ i ] == t [ j ] ) : NEW_LINE INDENT ans = 1 NEW_LINE if ( i > 0 and j > 0 ) : NEW_LINE INDENT ans = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , ans ) NEW_LINE r = max ( r , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ( n - r ) NEW_LINE DEDENT
def min_op ( cur , M ) : NEW_LINE INDENT if ( cur > M ) : NEW_LINE INDENT return INF NEW_LINE DEDENT if ( cur == M ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT op = int ( INF ) NEW_LINE for i in range ( 2 , int ( cur ** 1 / 2 ) + 1 ) : NEW_LINE INDENT if ( cur % i == 0 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT op = min ( op , 1 + min_op ( cur + i , M ) ) NEW_LINE DEDENT if ( ( cur / i ) != i and ( cur / i ) % 2 == 0 ) : NEW_LINE INDENT op = min ( op , 1 + min_op ( cur + ( cur // i ) , M ) ) NEW_LINE DEDENT DEDENT DEDENT return op NEW_LINE DEDENT
def min_op ( cur , M ) : NEW_LINE INDENT if ( cur > M ) : NEW_LINE INDENT return INF NEW_LINE DEDENT if ( cur == M ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ cur ] != - 1 ) : NEW_LINE INDENT return dp [ cur ] NEW_LINE DEDENT op = INF NEW_LINE i = 2 NEW_LINE while ( i * i <= cur ) : NEW_LINE INDENT if ( cur % i == 0 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT op = min ( op , 1 + min_op ( cur + i , M ) ) NEW_LINE DEDENT if ( ( cur // i ) != i and ( cur // i ) % 2 == 0 ) : NEW_LINE INDENT op = min ( op , 1 + min_op ( cur + ( cur // i ) , M ) ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT dp [ cur ] = op NEW_LINE return op NEW_LINE DEDENT
def min_operations ( N , M ) : NEW_LINE INDENT for i in range ( N , M + 1 ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT return min_op ( N , M ) NEW_LINE DEDENT
def solve ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE val = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = a [ i ] NEW_LINE j = i NEW_LINE while ( j + 1 < n and sum < val [ j + 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE sum += a [ j ] NEW_LINE DEDENT dp [ i ] = ( j - i ) + dp [ j + 1 ] NEW_LINE val [ i ] = sum NEW_LINE DEDENT return dp [ 0 ] NEW_LINE DEDENT
def findPrimeFactors ( n ) : NEW_LINE INDENT primeFactors = [ 0 for i in range ( 9 ) ] NEW_LINE j = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT primeFactors [ j ] = 2 NEW_LINE j += 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE DEDENT DEDENT i = 3 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT primeFactors [ j ] = i NEW_LINE j += 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n //= i NEW_LINE DEDENT DEDENT i += 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT primeFactors [ j ] = n NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( 0 , j + 1 ) : NEW_LINE INDENT primeFactors [ i ] = 0 NEW_LINE DEDENT return primeFactors NEW_LINE DEDENT
def findShortestSubsequence ( dp , a , index , primeFactors ) : NEW_LINE INDENT n = len ( a ) NEW_LINE for j in range ( index , n ) : NEW_LINE INDENT bitmask = 0 NEW_LINE for p in range ( len ( primeFactors ) ) : NEW_LINE INDENT if ( primeFactors [ p ] != 0 and a [ j ] % primeFactors [ p ] == 0 ) : NEW_LINE INDENT bitmask ^= ( 1 << p ) NEW_LINE DEDENT DEDENT for i in range ( len ( dp ) ) : NEW_LINE INDENT if ( dp [ i ] == n + 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ bitmask & i ] = min ( dp [ bitmask & i ] , dp [ i ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def minDays ( n ) : NEW_LINE INDENT if n < 1 : NEW_LINE INDENT return n NEW_LINE DEDENT cnt = 1 + min ( n % 2 + minDays ( n // 2 ) , n % 3 + minDays ( n // 3 ) ) NEW_LINE return cnt NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT dp = dict ( ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE if n not in dp : NEW_LINE INDENT dp [ n ] = 1 + min ( n % 2 + count ( n // 2 ) , n % 3 + count ( n // 3 ) ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def findMaxTimes ( S ) : NEW_LINE INDENT arr = [ 0 ] * 26 NEW_LINE dp = [ [ 0 for x in range ( 26 ) ] for y in range ( 26 ) ] NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT now = ord ( S [ i ] ) - ord ( 'a' ) NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT dp [ j ] [ now ] += arr [ j ] NEW_LINE DEDENT arr [ now ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT ans = max ( ans , arr [ i ] ) NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def xorSum ( a , n , mask , dp ) : NEW_LINE INDENT if ( dp [ mask ] != - 1 ) : NEW_LINE INDENT return dp [ mask ] NEW_LINE DEDENT max_value = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( i != j and ( mask & ( 1 << i ) ) == 0 and ( mask & ( 1 << j ) ) == 0 ) : NEW_LINE INDENT max_value = max ( max_value , ( a [ i ] ^ a [ j ] ) + xorSum ( a , n , ( mask | ( 1 << i ) | ( 1 << j ) ) , dp ) ) NEW_LINE DEDENT DEDENT DEDENT dp [ mask ] = max_value NEW_LINE return dp [ mask ] NEW_LINE DEDENT
def maxValue ( a , n , pos , moves , left , dp ) : NEW_LINE INDENT if ( moves == 0 or ( pos > n - 1 or pos < 0 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ pos ] [ left ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ left ] NEW_LINE DEDENT value = 0 NEW_LINE if ( left > 0 and pos >= 1 ) : NEW_LINE INDENT value = max ( value , a [ pos ] + maxValue ( a , n , pos - 1 , moves - 1 , left - 1 , dp ) ) NEW_LINE DEDENT if ( pos <= n - 1 ) : NEW_LINE INDENT value = max ( value , a [ pos ] + maxValue ( a , n , pos + 1 , moves - 1 , left , dp ) ) NEW_LINE DEDENT dp [ pos ] [ left ] = value NEW_LINE return dp [ pos ] [ left ] NEW_LINE DEDENT
def maximumSum ( a , count , index , n , dp ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ index ] [ count ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ count ] NEW_LINE DEDENT take_element = ( a [ index ] * count + maximumSum ( a , count + 1 , index + 1 , n , dp ) ) NEW_LINE dont_take = maximumSum ( a , count , index + 1 , n , dp ) NEW_LINE dp [ index ] [ count ] = max ( take_element , dont_take ) NEW_LINE return dp [ index ] [ count ] NEW_LINE DEDENT
def fibonacci ( ) : NEW_LINE INDENT fib [ 1 ] = 1 NEW_LINE fib [ 2 ] = 2 NEW_LINE for i in range ( 3 , 87 + 1 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DEDENT
def find ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 87 , 0 , - 1 ) : NEW_LINE INDENT if ( num >= fib [ i ] ) : NEW_LINE INDENT v [ cnt ] = i NEW_LINE cnt += 1 NEW_LINE num -= fib [ i ] NEW_LINE DEDENT DEDENT v [ : : - 1 ] NEW_LINE dp1 [ 0 ] = 1 NEW_LINE dp2 [ 0 ] = ( v [ 0 ] - 1 ) // 2 NEW_LINE for i in range ( 1 , cnt ) : NEW_LINE INDENT dp1 [ i ] = dp1 [ i - 1 ] + dp2 [ i - 1 ] NEW_LINE dp2 [ i ] = ( ( ( v [ i ] - v [ i - 1 ] ) // 2 ) * dp2 [ i - 1 ] + ( ( v [ i ] - v [ i - 1 ] - 1 ) // 2 ) * dp1 [ i - 1 ] ) NEW_LINE DEDENT return dp1 [ cnt - 1 ] + dp2 [ cnt - 1 ] NEW_LINE DEDENT
def preprocess ( a , n ) : NEW_LINE INDENT p = [ 0 ] * n NEW_LINE p [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT p [ i ] = p [ i - 1 ] + a [ i ] NEW_LINE DEDENT return p NEW_LINE DEDENT
def Combine ( p , i , j ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT return p [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT return p [ j ] - p [ i - 1 ] NEW_LINE DEDENT DEDENT
def minCost ( a , i , j , k , prefix , dp ) : NEW_LINE INDENT if ( i >= j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT best_cost = inf NEW_LINE for pos in range ( i , j ) : NEW_LINE INDENT left = minCost ( a , i , pos , k , prefix , dp ) NEW_LINE right = minCost ( a , pos + 1 , j , k , prefix , dp ) NEW_LINE best_cost = min ( best_cost , left + right + ( k * Combine ( prefix , i , j ) ) ) NEW_LINE DEDENT dp [ i ] [ j ] = best_cost NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT
def countNums ( N ) : NEW_LINE INDENT l = pow ( 10 , N - 1 ) NEW_LINE r = pow ( 10 , N ) - 1 NEW_LINE count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT xorr = 0 NEW_LINE temp = i NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT xorr = xorr ^ ( temp % 10 ) NEW_LINE temp //= 10 NEW_LINE DEDENT if ( xorr <= 9 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def distinctSimilarSubstrings ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE substrings = set ( ) NEW_LINE for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for i in range ( j - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i + 1 ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] >= j - i ) : NEW_LINE INDENT substrings . add ( str [ i : j - i ] ) NEW_LINE DEDENT DEDENT DEDENT return len ( substrings ) NEW_LINE DEDENT
def SubarrayWithMaxSum ( nums ) : NEW_LINE INDENT currMax = nums [ 0 ] NEW_LINE globalMax = nums [ 0 ] NEW_LINE for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT currMax = max ( nums [ i ] , nums [ i ] + currMax ) NEW_LINE if ( currMax > globalMax ) : NEW_LINE INDENT globalMax = currMax NEW_LINE endIndex = i NEW_LINE DEDENT DEDENT startIndex = endIndex NEW_LINE while ( startIndex >= 0 ) : NEW_LINE INDENT globalMax -= nums [ startIndex ] NEW_LINE if ( globalMax == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT startIndex -= 1 NEW_LINE DEDENT for i in range ( startIndex , endIndex + 1 ) : NEW_LINE INDENT print ( nums [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def count ( a , M , N ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , M + 1 ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( i % a [ j ] == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT mark = [ False ] * M NEW_LINE for i in range ( 2 , M ) : NEW_LINE INDENT mark [ i ] = True NEW_LINE DEDENT i = 2 NEW_LINE while i * i < M : NEW_LINE INDENT if ( mark [ i ] ) : NEW_LINE INDENT j = i * i NEW_LINE while j < M : NEW_LINE INDENT mark [ j ] = False NEW_LINE j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( 2 , M ) : NEW_LINE INDENT if ( mark [ i ] ) : NEW_LINE INDENT primes . append ( i ) NEW_LINE DEDENT DEDENT DEDENT
def countPrimonacci ( l , r ) : NEW_LINE INDENT dp = [ ] NEW_LINE dp . append ( 1 ) NEW_LINE dp . append ( 1 ) NEW_LINE i = 2 NEW_LINE s = set ( ) NEW_LINE while ( True ) : NEW_LINE INDENT x = 0 NEW_LINE for j in range ( len ( primes ) ) : NEW_LINE INDENT p = primes [ j ] NEW_LINE if ( p >= i ) : NEW_LINE INDENT break NEW_LINE DEDENT x += dp [ i - p ] NEW_LINE DEDENT if ( x >= l and x <= r ) : NEW_LINE INDENT s . add ( x ) NEW_LINE DEDENT if ( x > r ) : NEW_LINE INDENT break NEW_LINE DEDENT dp . append ( x ) NEW_LINE i += 1 NEW_LINE DEDENT print ( len ( s ) ) NEW_LINE DEDENT
def minSum ( n , num , price ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = sys . maxsize NEW_LINE DEDENT ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( num [ j ] > num [ i ] ) : NEW_LINE INDENT dp [ j ] = min ( dp [ j ] , price [ i ] + price [ j ] ) NEW_LINE ans = min ( ans , dp [ i ] + price [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ans is not sys . maxsize : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def getMid ( s , e ) : NEW_LINE INDENT return s + ( e - s ) // 2 NEW_LINE DEDENT
def getSumUtil ( st , ss , se , qs , qe , si ) : NEW_LINE INDENT if qs <= ss and qe >= se : NEW_LINE INDENT return st [ si ] NEW_LINE DEDENT if se < qs or ss > qe : NEW_LINE INDENT return 0 NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE return ( getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ) NEW_LINE DEDENT
def updateValueUtil ( st , ss , se , i , diff , si ) : NEW_LINE INDENT if i < ss or i > se : NEW_LINE INDENT return NEW_LINE DEDENT st [ si ] = st [ si ] + diff NEW_LINE if se != ss : NEW_LINE INDENT mid = getMid ( ss , se ) NEW_LINE updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) NEW_LINE updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) NEW_LINE DEDENT DEDENT
def updateValue ( arr , st , n , i , new_val ) : NEW_LINE INDENT if i < 0 or i > n - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT diff = new_val - arr [ i ] NEW_LINE prev_val = arr [ i ] NEW_LINE arr [ i ] = new_val NEW_LINE if prime [ new_val ] or prime [ prev_val ] : NEW_LINE INDENT if not prime [ prev_val ] : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) NEW_LINE DEDENT elif not prime [ new_val ] : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) NEW_LINE DEDENT DEDENT DEDENT
def getSum ( st , n , qs , qe ) : NEW_LINE INDENT if qs < 0 or qe > n - 1 or qs > qe : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) NEW_LINE DEDENT
def countStrings ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT N //= 2 NEW_LINE c = binomialCoeff ( 2 * N , N ) NEW_LINE return c // ( N + 1 ) NEW_LINE DEDENT DEDENT
def solve ( n , k , mod , dp ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 2 , k + 1 , 2 ) : NEW_LINE INDENT cnt = ( ( cnt % mod + solve ( n - i , k , mod , dp ) % mod ) % mod ) NEW_LINE DEDENT dp [ n ] = cnt NEW_LINE return int ( cnt ) NEW_LINE DEDENT
def fact ( ) : NEW_LINE INDENT f [ 0 ] = f [ 1 ] = 1 NEW_LINE for i in range ( 2 , 11 ) : NEW_LINE INDENT f [ i ] = i * 1 * f [ i - 1 ] NEW_LINE DEDENT DEDENT
def dfs2 ( a , par ) : NEW_LINE INDENT for i in v [ a ] : NEW_LINE INDENT if ( i [ 0 ] == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT leafOutside = leaves [ a ] - leaves [ i [ 0 ] ] NEW_LINE dp [ i [ 0 ] ] += ( dp [ a ] - dp [ i [ 0 ] ] ) NEW_LINE dp [ i [ 0 ] ] += i [ 1 ] * ( leafOutside - leaves [ i [ 0 ] ] ) NEW_LINE leaves [ i [ 0 ] ] += leafOutside NEW_LINE dfs2 ( i [ 0 ] , a ) NEW_LINE DEDENT DEDENT
def countPairs ( first , second , value ) : NEW_LINE INDENT count = 0 NEW_LINE while ( first != None and second != None and first != second and second . next != first ) : NEW_LINE INDENT if ( ( first . data + second . data ) == value ) : NEW_LINE INDENT count += 1 NEW_LINE first = first . next NEW_LINE second = second . prev NEW_LINE DEDENT elif ( ( first . data + second . data ) > value ) : NEW_LINE INDENT second = second . prev NEW_LINE DEDENT else : NEW_LINE INDENT first = first . next NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countTriplets ( head , x ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT current , first , last = head , None , None NEW_LINE count = 0 NEW_LINE last = head NEW_LINE while ( last . next != None ) : NEW_LINE INDENT last = last . next NEW_LINE DEDENT while current != None : NEW_LINE INDENT first = current . next NEW_LINE count , current = count + countPairs ( first , last , x - current . data ) , current . next NEW_LINE DEDENT return count NEW_LINE DEDENT
def countChanges ( matrix , n , m ) : NEW_LINE INDENT dist = n + m - 1 NEW_LINE Max_element = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT Max_element = max ( Max_element , matrix [ i ] [ j ] ) NEW_LINE DEDENT DEDENT freq = [ [ 0 for i in range ( Max_element + 1 ) ] for j in range ( dist ) ] NEW_LINE for i in range ( dist ) : NEW_LINE INDENT for j in range ( Max_element + 1 ) : NEW_LINE INDENT freq [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT freq [ i + j ] [ matrix [ i ] [ j ] ] += 1 NEW_LINE DEDENT DEDENT min_changes_sum = 0 NEW_LINE for i in range ( dist // 2 ) : NEW_LINE INDENT maximum = 0 NEW_LINE total_values = 0 NEW_LINE for j in range ( Max_element + 1 ) : NEW_LINE INDENT maximum = max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE DEDENT min_changes_sum += total_values - maximum NEW_LINE DEDENT return min_changes_sum NEW_LINE DEDENT
def maxLength ( arr , n ) : NEW_LINE INDENT dp = [ 1 ] * n NEW_LINE for i in range ( n - 1 , 1 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , int ( sqrt ( i ) ) + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT s = i // j NEW_LINE if ( s == j ) : NEW_LINE INDENT if ( arr [ i ] > arr [ s ] ) : NEW_LINE INDENT dp [ s ] = max ( dp [ i ] + 1 , dp [ s ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s != i and arr [ i ] > arr [ s ] ) : NEW_LINE INDENT dp [ s ] = max ( dp [ i ] + 1 , dp [ s ] ) NEW_LINE DEDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT dp [ j ] = max ( dp [ i ] + 1 , dp [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT Max = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( dp [ i ] > Max ) : NEW_LINE INDENT Max = dp [ i ] NEW_LINE DEDENT DEDENT print ( Max ) NEW_LINE DEDENT
def maxProfit ( price , n ) : NEW_LINE INDENT buy1 , buy2 = sys . maxsize , sys . maxsize NEW_LINE profit1 , profit2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT buy1 = min ( buy1 , price [ i ] ) NEW_LINE profit1 = max ( profit1 , price [ i ] - buy1 ) NEW_LINE buy2 = min ( buy2 , price [ i ] - profit1 ) NEW_LINE profit2 = max ( profit2 , price [ i ] - buy2 ) NEW_LINE DEDENT return profit2 NEW_LINE DEDENT
def validsubsequences ( arr , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] % 2 ) : NEW_LINE INDENT dp [ i ] [ 1 ] += 1 NEW_LINE dp [ i ] [ 1 ] += dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] += 1 NEW_LINE dp [ i ] [ 0 ] += dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] NEW_LINE DEDENT
def getCount ( n , k ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 10 NEW_LINE DEDENT dp = [ [ 0 for x in range ( 11 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT l = max ( 0 , j - k ) NEW_LINE r = min ( 9 , j + k ) NEW_LINE dp [ i ] [ l ] = dp [ i ] [ l ] + dp [ i - 1 ] [ j ] NEW_LINE dp [ i ] [ r + 1 ] = dp [ i ] [ r + 1 ] - dp [ i - 1 ] [ j ] NEW_LINE DEDENT for j in range ( 1 , 10 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT count = count + dp [ n ] [ i ] NEW_LINE DEDENT return count NEW_LINE DEDENT
def existPath ( V , edges , u , v ) : NEW_LINE INDENT mat = [ [ False for i in range ( V ) ] for j in range ( V ) ] NEW_LINE for i in range ( X ) : NEW_LINE INDENT mat [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = True NEW_LINE DEDENT for k in range ( V ) : NEW_LINE INDENT for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT mat [ i ] [ j ] = ( mat [ i ] [ j ] or mat [ i ] [ k ] and mat [ k ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ( u >= V or v >= V ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( mat [ u ] [ v ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def calculate_maximum_splits ( arr , N ) : NEW_LINE INDENT pre = [ 0 , - 1 , - 1 ] NEW_LINE dp = [ 0 for i in range ( N ) ] NEW_LINE C = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT C = C + arr [ i ] NEW_LINE C = C % 3 NEW_LINE if pre [ C ] == - 1 : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , dp [ pre [ C ] ] + 1 ) NEW_LINE DEDENT pre [ C ] = i NEW_LINE DEDENT return dp [ N - 1 ] NEW_LINE DEDENT
def solve ( n , last , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT if ( last == k ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( dp [ n ] [ last ] ) : NEW_LINE INDENT return dp [ n ] [ last ] NEW_LINE DEDENT if ( last == k ) : NEW_LINE INDENT dp [ n ] [ last ] = ( ( k - 1 ) * solve ( n - 1 , k , k ) + ( k - 1 ) * solve ( n - 1 , 1 , k ) ) NEW_LINE return dp [ n ] [ last ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ n ] [ last ] = solve ( n - 1 , k , k ) NEW_LINE return dp [ n ] [ last ] NEW_LINE DEDENT DEDENT
def mergeTwoNumbers ( numbers ) : NEW_LINE INDENT n = len ( numbers ) NEW_LINE if ( len ( numbers ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT prefixSum = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prefixSum [ i ] = ( prefixSum [ i - 1 ] + numbers [ i - 1 ] ) NEW_LINE DEDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ i ] = 0 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 1 , n - p + 2 ) : NEW_LINE INDENT j = i + p - 1 NEW_LINE sum = prefixSum [ j ] - prefixSum [ i - 1 ] NEW_LINE dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , ( dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum ) ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 1 ] [ n ] NEW_LINE DEDENT
def seiveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( 2 , 1000001 ) : NEW_LINE INDENT prime [ i ] = 1 NEW_LINE DEDENT i = 2 NEW_LINE while ( i * i < 1000001 ) : NEW_LINE INDENT if ( prime [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i * i , 1000001 , i ) : NEW_LINE INDENT prime [ j ] = 0 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def constructPath ( u , v ) : NEW_LINE INDENT global graph , Next NEW_LINE if ( Next [ u ] [ v ] == - 1 ) : NEW_LINE INDENT return { } NEW_LINE DEDENT path = [ u ] NEW_LINE while ( u != v ) : NEW_LINE INDENT u = Next [ u ] [ v ] NEW_LINE path . append ( u ) NEW_LINE DEDENT return path NEW_LINE DEDENT
def floydWarshall ( V ) : NEW_LINE INDENT global dist , Next NEW_LINE for k in range ( V ) : NEW_LINE INDENT for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT if ( dis [ i ] [ k ] == INF or dis [ k ] [ j ] == INF ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( dis [ i ] [ j ] > dis [ i ] [ k ] + dis [ k ] [ j ] ) : NEW_LINE INDENT dis [ i ] [ j ] = dis [ i ] [ k ] + dis [ k ] [ j ] NEW_LINE Next [ i ] [ j ] = Next [ i ] [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def maximumSum ( A , B , length , X , Y ) : NEW_LINE INDENT l = length NEW_LINE l1 = min ( length , X ) NEW_LINE l2 = min ( length , Y ) NEW_LINE dp = [ [ 0 for i in range ( l2 + 1 ) ] for i in range ( l1 + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE max_sum = - 10 * 9 NEW_LINE for i in range ( 1 , l1 + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + A [ i - 1 ] NEW_LINE max_sum = max ( max_sum , dp [ i ] [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , l2 + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + B [ i - 1 ] NEW_LINE max_sum = max ( max_sum , dp [ 0 ] [ i ] ) NEW_LINE DEDENT for i in range ( 1 , l1 + 1 ) : NEW_LINE INDENT for j in range ( 1 , l2 + 1 ) : NEW_LINE INDENT if ( i + j <= l ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] + A [ i + j - 1 ] , dp [ i ] [ j - 1 ] + B [ i + j - 1 ] ) NEW_LINE DEDENT max_sum = max ( dp [ i ] [ j ] , max_sum ) NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT
def finding_factors ( n ) : NEW_LINE INDENT i = 1 NEW_LINE a = 0 NEW_LINE global vp NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i * i == n ) : NEW_LINE INDENT vp [ n ] . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT vp [ n ] . append ( i ) NEW_LINE vp [ n ] . append ( int ( n / i ) ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def countSeq ( N , K ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE dp = [ [ 0 for i in range ( 109 ) ] for j in range ( 109 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT finding_factors ( i ) NEW_LINE dp [ 0 ] [ i ] = 0 NEW_LINE dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , K + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT Sum = 0 NEW_LINE for k in range ( len ( vp [ j ] ) ) : NEW_LINE INDENT Sum += dp [ i - 1 ] [ vp [ j ] [ k ] ] NEW_LINE DEDENT dp [ i ] [ j ] = Sum NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for j in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += dp [ K ] [ j ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def find_minimum_operations ( n , b , k ) : NEW_LINE INDENT d = [ 0 for i in range ( n + 1 ) ] NEW_LINE operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ i ] += d [ i - 1 ] NEW_LINE if b [ i ] > d [ i ] : NEW_LINE INDENT operations += ( b [ i ] - d [ i ] ) NEW_LINE need = ( b [ i ] - d [ i ] ) NEW_LINE d [ i ] += need NEW_LINE if i + k <= n : NEW_LINE INDENT d [ i + k ] -= need NEW_LINE DEDENT DEDENT DEDENT return operations NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT primes [ 0 ] = primes [ 1 ] = 0 NEW_LINE i = 2 NEW_LINE while i * i <= maxn : NEW_LINE INDENT if ( primes [ i ] ) : NEW_LINE INDENT for j in range ( i * i , maxn + 1 , i ) : NEW_LINE INDENT primes [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def printpentaRec ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 or n == 2 or n == 3 or n == 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( n == 5 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( printpentaRec ( n - 1 ) + printpentaRec ( n - 2 ) + printpentaRec ( n - 3 ) + printpentaRec ( n - 4 ) + printpentaRec ( n - 5 ) ) NEW_LINE DEDENT DEDENT
def possibleBinaries ( pos , ones , sum , k ) : NEW_LINE INDENT if ( ones == k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( pos == 0 ) : NEW_LINE INDENT return 1 if ( sum == 0 ) else 0 NEW_LINE DEDENT if ( dp [ pos ] [ ones ] [ sum ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ ones ] [ sum ] NEW_LINE DEDENT ret = ( possibleBinaries ( pos - 1 , ones + 1 , ( sum + 1 ) % 2 , k ) + possibleBinaries ( pos - 1 , 0 , sum , k ) ) NEW_LINE dp [ pos ] [ ones ] [ sum ] = ret NEW_LINE return dp [ pos ] [ ones ] [ sum ] NEW_LINE DEDENT
def MAX_value ( arr ) : NEW_LINE INDENT row = len ( arr ) NEW_LINE col = len ( arr ) NEW_LINE dp = [ [ 0 for i in range ( col ) ] for j in range ( row ) ] NEW_LINE i , j = 0 , 0 NEW_LINE c , p = arr [ 0 ] [ 0 ] , 0 NEW_LINE d = row NEW_LINE for i in range ( d ) : NEW_LINE INDENT for j in range ( d ) : NEW_LINE INDENT if ( c < arr [ i ] [ j ] ) : NEW_LINE INDENT c = arr [ i ] [ j ] NEW_LINE DEDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( arr [ i - 1 ] [ j - 1 ] == arr [ i ] [ j ] and arr [ i - 1 ] [ j ] == arr [ i ] [ j ] and arr [ i ] [ j - 1 ] == arr [ i ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j - 1 ] , min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( d ) : NEW_LINE INDENT for j in range ( d ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == c ) : NEW_LINE INDENT if ( p < dp [ i ] [ j ] ) : NEW_LINE INDENT p = dp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return p * p NEW_LINE DEDENT
def printList ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT print ( "Doubly Linked list empty" ) NEW_LINE DEDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = " " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT
def countStableNum ( Str , N ) : NEW_LINE INDENT count1 = [ [ 0 for j in range ( 10 ) ] for i in range ( N ) ] NEW_LINE count2 = [ [ 0 for j in range ( 10 ) ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT count1 [ i ] [ j ] , count2 [ i ] [ j ] = 0 , 0 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT count1 [ i ] [ j ] = ( count1 [ i ] [ j ] + count1 [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT count1 [ i ] [ ord ( Str [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i != N - 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT count2 [ i ] [ j ] += count2 [ i + 1 ] [ j ] NEW_LINE DEDENT DEDENT count2 [ i ] [ ord ( Str [ i ] ) - ord ( '0' ) ] = count2 [ i ] [ ord ( Str [ i ] ) - ord ( '0' ) ] + 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT if ( Str [ i ] == '9' ) : NEW_LINE INDENT continue NEW_LINE DEDENT c1 = count1 [ i - 1 ] [ ord ( Str [ i ] ) - ord ( '0' ) ] NEW_LINE c2 = count2 [ i + 1 ] [ ord ( Str [ i ] ) - ord ( '0' ) + 1 ] NEW_LINE if ( c2 == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT ans = ( ans + ( c1 * ( ( c2 * ( c2 - 1 ) // 2 ) ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countWays ( s , t , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = s [ i : n - i + 1 ] + s [ : i + 1 ] NEW_LINE if ( p == t ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT dp1 = [ 0 ] * ( k + 1 ) NEW_LINE dp2 = [ 0 ] * ( k + 1 ) NEW_LINE if ( s == t ) : NEW_LINE INDENT dp1 [ 0 ] = 1 NEW_LINE dp2 [ 0 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp1 [ 0 ] = 0 NEW_LINE dp2 [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod NEW_LINE dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod NEW_LINE DEDENT return ( dp1 [ k ] ) NEW_LINE DEDENT
def dfs1 ( u , par , g , weight ) : NEW_LINE INDENT dp1 [ u ] = weight [ u ] NEW_LINE for c in g [ u ] : NEW_LINE INDENT if ( c != par ) : NEW_LINE INDENT dfs1 ( c , u , g , weight ) NEW_LINE dp1 [ u ] += max ( 0 , dp1 ) NEW_LINE DEDENT DEDENT DEDENT
def dfs2 ( u , par , g , weight ) : NEW_LINE INDENT if ( par != 0 ) : NEW_LINE INDENT maxSumAncestors = dp2 [ par ] - max ( 0 , dp1 [ u ] ) NEW_LINE dp2 [ u ] = dp1 [ u ] + max ( 0 , maxSumAncestors ) NEW_LINE DEDENT for c in g [ u ] : NEW_LINE INDENT if ( c != par ) : NEW_LINE INDENT dfs2 ( c , u , g , weight ) NEW_LINE DEDENT DEDENT DEDENT
def addEdge ( u , v , g ) : NEW_LINE INDENT g [ u ] . append ( v ) NEW_LINE g [ v ] . append ( u ) NEW_LINE DEDENT
def maxSumSegments ( g , weight , n ) : NEW_LINE INDENT dfs1 ( 1 , 0 , g , weight ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp2 [ i ] = dp1 [ i ] NEW_LINE DEDENT dfs2 ( 1 , 0 , g , weight ) NEW_LINE DEDENT
def printAns ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( dp2 [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT
def countMaximum ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE count = 0 NEW_LINE mark = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] + n >= mark ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT mark = max ( mark , a [ i ] + i + 1 ) NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def CountWays ( i , j , k ) : NEW_LINE INDENT if ( i >= N or i < 0 or j >= M or j < 0 or k < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i == 0 and j == 0 and k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = ( CountWays ( i + 1 , j , k - 1 ) % MOD + CountWays ( i - 1 , j , k - 1 ) % MOD + CountWays ( i , j - 1 , k - 1 ) % MOD + CountWays ( i , j + 1 , k - 1 ) % MOD + CountWays ( i , j , k - 1 ) % MOD ) % MOD NEW_LINE DEDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT
def smallestNum ( n ) : NEW_LINE INDENT res = 1 NEW_LINE i = 2 NEW_LINE while ( True ) : NEW_LINE INDENT length = int ( log10 ( i ) + 1 ) NEW_LINE if ( length == n ) : NEW_LINE INDENT return int ( log ( i ) // log ( 2 ) ) NEW_LINE DEDENT i *= 2 NEW_LINE DEDENT DEDENT
def findResultUtil ( arr , L , R ) : NEW_LINE INDENT result = 0 NEW_LINE flag = False NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( flag == False ) : NEW_LINE INDENT result = result + arr [ i ] NEW_LINE flag = True NEW_LINE DEDENT else : NEW_LINE INDENT result = result - arr [ i ] NEW_LINE flag = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def isKPartitionPossible ( arr , N , K ) : NEW_LINE INDENT if ( K == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( N < K ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % K != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT target = sum / K NEW_LINE dp = [ 0 for i in range ( 1 << 15 ) ] NEW_LINE for i in range ( ( 1 << N ) ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT dp [ 0 ] = 0 NEW_LINE for mask in range ( ( 1 << N ) ) : NEW_LINE INDENT if ( dp [ mask ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ( mask & ( 1 << i ) == 0 ) and dp [ mask ] + arr [ i ] <= target ) : NEW_LINE INDENT dp [ mask ( 1 << i ) ] = ( ( dp [ mask ] + arr [ i ] ) % target ) NEW_LINE DEDENT DEDENT DEDENT if ( dp [ ( 1 << N ) - 1 ] == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def min_operation ( i , j , val , x ) : NEW_LINE INDENT if ( i == n - 1 and j == m - 1 ) : NEW_LINE INDENT if ( val > v [ i ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = MAX NEW_LINE return MAX NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = v [ i ] [ j ] - val NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( i == n or j == m ) : NEW_LINE INDENT dp [ i ] [ j ] = MAX NEW_LINE return MAX NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( val > v [ i ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = MAX NEW_LINE return MAX NEW_LINE DEDENT tmp = v [ i ] [ j ] - val NEW_LINE tmp += min ( min_operation ( i + 1 , j , val + x , x ) , min_operation ( i , j + 1 , val + x , x ) ) NEW_LINE dp [ i ] [ j ] = tmp NEW_LINE return tmp NEW_LINE DEDENT
def solve ( x ) : NEW_LINE INDENT ans = 10 ** 19 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT val = v [ i ] [ j ] - x * ( i + j ) NEW_LINE for ii in range ( 151 ) : NEW_LINE INDENT for jj in range ( 151 ) : NEW_LINE INDENT dp [ ii ] [ jj ] = - 1 NEW_LINE DEDENT DEDENT val = min_operation ( 0 , 0 , val , x ) NEW_LINE ans = min ( ans , val ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def printList ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT print ( "Doubly Linked list empty" ) NEW_LINE DEDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = " " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT
def Count ( S , m , n ) : NEW_LINE INDENT table = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT table [ 0 ] [ i ] = 10 ** 9 - 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( S [ i - 1 ] > j ) : NEW_LINE INDENT table [ i ] [ j ] = table [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT table [ i ] [ j ] = min ( table [ i - 1 ] [ j ] , table [ i ] [ j - S [ i - 1 ] ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return table [ m ] [ n ] NEW_LINE DEDENT
def maxProductUtil ( X , Y , A , B , dp ) : NEW_LINE INDENT if ( X < 0 or Y < 0 ) : NEW_LINE INDENT return - INF NEW_LINE DEDENT if ( dp [ X ] [ Y ] != - 1 ) : NEW_LINE INDENT return dp [ X ] [ Y ] NEW_LINE DEDENT dp [ X ] [ Y ] = maximum ( A [ X ] * B [ Y ] + maxProductUtil ( X - 1 , Y - 1 , A , B , dp ) , A [ X ] * B [ Y ] , maxProductUtil ( X - 1 , Y , A , B , dp ) , maxProductUtil ( X , Y - 1 , A , B , dp ) ) NEW_LINE return dp [ X ] [ Y ] NEW_LINE DEDENT
def maxProduct ( A , N , B , M ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( m ) ] for i in range ( n ) ] NEW_LINE return maxProductUtil ( N - 1 , M - 1 , A , B , dp ) NEW_LINE DEDENT
def minOperation ( k ) : NEW_LINE INDENT dp = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + 1 NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ i // 2 ] + 1 ) NEW_LINE DEDENT DEDENT return dp [ k ] NEW_LINE DEDENT
def maximumSum ( S , M , N , stacks ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( S + 1 ) ] NEW_LINE for i in range ( S ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT for k in range ( min ( j , M ) + 1 ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j ] , stacks [ i ] [ k ] + dp [ i ] [ j - k ] ) NEW_LINE DEDENT DEDENT DEDENT result = - sys . maxsize - 1 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT result = max ( result , dp [ S ] [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def findSum ( arr , n ) : NEW_LINE INDENT totalSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT totalSum += arr [ i ] NEW_LINE DEDENT dp = [ [ 0 ] * n for i in range ( 2 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE dp [ 1 ] [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT if ( dp [ 0 ] [ i ] < dp [ 0 ] [ j ] + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ j ] + 1 NEW_LINE dp [ 1 ] [ i ] = dp [ 1 ] [ j ] + arr [ i ] NEW_LINE DEDENT elif ( dp [ 0 ] [ i ] == dp [ 0 ] [ j ] + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = min ( dp [ 1 ] [ i ] , dp [ 1 ] [ j ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT maxm = 0 NEW_LINE subtractSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( dp [ 0 ] [ i ] > maxm ) : NEW_LINE INDENT maxm = dp [ 0 ] [ i ] NEW_LINE subtractSum = dp [ 1 ] [ i ] NEW_LINE DEDENT elif ( dp [ 0 ] [ i ] == maxm ) : NEW_LINE INDENT subtractSum = min ( subtractSum , dp [ 1 ] [ i ] ) NEW_LINE DEDENT DEDENT return totalSum - subtractSum NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == 4 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif ( n == 6 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT table = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT table [ i ] = 0 NEW_LINE DEDENT table [ 0 ] = 0 NEW_LINE table [ 2 ] = 1 NEW_LINE table [ 4 ] = 2 NEW_LINE table [ 6 ] = 4 NEW_LINE for i in range ( 8 , n + 1 , 2 ) : NEW_LINE INDENT table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT
def isPrime ( number ) : NEW_LINE INDENT num = int ( number ) NEW_LINE i = 2 NEW_LINE while i * i <= num : NEW_LINE INDENT if ( ( num % i ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if num > 1 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def countPrimeStrings ( number , i ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for j in range ( 1 , 7 ) : NEW_LINE INDENT if ( i - j >= 0 and number [ i - j ] != '0' and isPrime ( number [ i - j : i ] ) ) : NEW_LINE INDENT cnt += countPrimeStrings ( number , i - j ) NEW_LINE cnt %= MOD NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def buildSieve ( ) : NEW_LINE INDENT for i in range ( len ( sieve ) ) : NEW_LINE INDENT sieve [ i ] = True NEW_LINE DEDENT sieve [ 0 ] = False NEW_LINE sieve [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= 1000000 : NEW_LINE INDENT if sieve [ p ] == True : NEW_LINE INDENT for i in range ( p * p , 1000000 , p ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def isPrime ( number ) : NEW_LINE INDENT num = int ( number ) NEW_LINE return sieve [ num ] NEW_LINE DEDENT
def rec ( number , i , dp ) : NEW_LINE INDENT if dp [ i ] != - 1 : NEW_LINE INDENT return dp [ i ] NEW_LINE DEDENT cnt = 0 NEW_LINE for j in range ( 1 , 7 ) : NEW_LINE INDENT if ( i - j ) >= 0 and number [ i - j ] != '0' and isPrime ( number [ i - j : i ] ) : NEW_LINE INDENT cnt += rec ( number , i - j , dp ) NEW_LINE cnt %= MOD NEW_LINE DEDENT DEDENT dp [ i ] = cnt NEW_LINE return dp [ i ] NEW_LINE DEDENT
def countPrimeStrings ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT dp [ 0 ] = 1 NEW_LINE return rec ( number , n , dp ) NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT global prime NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= 100000 : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , 100001 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def distinctPrimeSubSeq ( a , n , k ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE primes = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ a [ i ] ] ) : NEW_LINE INDENT primes . append ( a [ i ] ) NEW_LINE DEDENT DEDENT l = len ( primes ) NEW_LINE primes . sort ( ) NEW_LINE b = [ ] NEW_LINE dp = [ ] NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE while i < l : NEW_LINE INDENT count = 1 NEW_LINE x = a [ i ] NEW_LINE i += 1 NEW_LINE while ( i < l and a [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT b . append ( count ) NEW_LINE dp . append ( count ) NEW_LINE sum += count NEW_LINE DEDENT of_length = 2 NEW_LINE leng = len ( dp ) NEW_LINE ans = 0 NEW_LINE while ( of_length <= k ) : NEW_LINE INDENT freq = 0 NEW_LINE prev = 0 NEW_LINE for i in range ( leng - 1 ) : NEW_LINE INDENT freq += dp [ i ] NEW_LINE j = sum - freq NEW_LINE subseq = b [ i ] * j NEW_LINE ans += subseq NEW_LINE dp [ i ] = subseq NEW_LINE prev += dp [ i ] NEW_LINE DEDENT leng -= 1 NEW_LINE sum = prev NEW_LINE of_length += 1 NEW_LINE DEDENT ans += ( l + 1 ) NEW_LINE return ans NEW_LINE DEDENT
def ways ( arr , k ) : NEW_LINE INDENT R = len ( arr ) NEW_LINE C = len ( arr [ 0 ] ) NEW_LINE K = k NEW_LINE preSum = [ [ 0 for _ in range ( C ) ] for _ in range ( R ) ] NEW_LINE for r in range ( R - 1 , - 1 , - 1 ) : NEW_LINE INDENT for c in range ( C - 1 , - 1 , - 1 ) : NEW_LINE INDENT preSum [ r ] = arr [ r ] NEW_LINE if r + 1 < R : NEW_LINE INDENT preSum [ r ] += preSum [ r + 1 ] NEW_LINE DEDENT if c + 1 < C : NEW_LINE INDENT preSum [ r ] += preSum [ r ] NEW_LINE DEDENT if r + 1 < R and c + 1 < C : NEW_LINE INDENT preSum [ r ] -= preSum [ r + 1 ] NEW_LINE DEDENT DEDENT DEDENT dp = [ [ [ 0 for _ in range ( C ) ] for _ in range ( R ) ] for _ in range ( K + 1 ) ] NEW_LINE for k in range ( 1 , K + 1 ) : NEW_LINE INDENT for r in range ( R - 1 , - 1 , - 1 ) : NEW_LINE INDENT for c in range ( C - 1 , - 1 , - 1 ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT dp [ k ] [ r ] = 1 if preSum [ r ] > 0 else 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ k ] [ r ] = 0 NEW_LINE for r1 in range ( r + 1 , R ) : NEW_LINE INDENT if preSum [ r ] - preSum [ r1 ] > 0 : NEW_LINE INDENT dp [ k ] [ r ] += dp [ k - 1 ] [ r1 ] NEW_LINE DEDENT DEDENT for c1 in range ( c + 1 , C ) : NEW_LINE INDENT if preSum [ r ] - preSum [ r ] [ c1 ] > 0 : NEW_LINE INDENT dp [ k ] [ r ] += dp [ k - 1 ] [ r ] [ c1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return dp [ K ] [ 0 ] [ 0 ] NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def sumPathCost ( grid , m , n ) : NEW_LINE INDENT sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , m + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT count = ( nCr ( i + j , i ) * nCr ( m + n - i - j , m - i ) ) NEW_LINE sum += count * grid [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def init ( x ) : NEW_LINE INDENT global K NEW_LINE global N NEW_LINE global v NEW_LINE v = [ ] NEW_LINE while ( x > 0 ) : NEW_LINE INDENT v . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT v = v [ : : - 1 ] NEW_LINE N = len ( v ) NEW_LINE DEDENT
def findCount ( L , R , K ) : NEW_LINE INDENT init ( R ) NEW_LINE r_ans = fun ( 0 , 0 , 0 , 0 , 0 ) NEW_LINE init ( L - 1 ) NEW_LINE r_ans = 0 NEW_LINE l_ans = fun ( 0 , 0 , 0 , 0 , 0 ) NEW_LINE print ( l_ans - r_ans ) NEW_LINE DEDENT
def dfs_lca ( a , par , lev ) : NEW_LINE INDENT dp [ 0 ] [ a ] = par NEW_LINE level [ a ] = lev NEW_LINE for i in v [ a ] : NEW_LINE INDENT if ( i [ 0 ] == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT mx [ 0 ] [ i [ 0 ] ] = i [ 1 ] NEW_LINE dfs_lca ( i [ 0 ] , a , lev + 1 ) NEW_LINE DEDENT DEDENT
def find_ancestor ( ) : NEW_LINE INDENT for i in range ( 1 , 16 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ dp [ i - 1 ] [ j ] ] NEW_LINE mx [ i ] [ j ] = max ( mx [ i - 1 ] [ j ] , mx [ i - 1 ] [ dp [ i - 1 ] [ j ] ] ) NEW_LINE DEDENT DEDENT DEDENT
def getMax ( a , b ) : NEW_LINE INDENT if ( level [ b ] < level [ a ] ) : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT ans = 0 NEW_LINE diff = level [ b ] - level [ a ] NEW_LINE while ( diff > 0 ) : NEW_LINE INDENT log = int ( math . log2 ( diff ) ) NEW_LINE ans = max ( ans , mx [ log ] [ b ] ) NEW_LINE b = dp [ log ] [ b ] NEW_LINE diff -= ( 1 << log ) NEW_LINE DEDENT while ( a != b ) : NEW_LINE INDENT i = int ( math . log2 ( level [ a ] ) ) NEW_LINE while ( i > 0 and dp [ i ] [ a ] == dp [ i ] [ b ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT ans = max ( ans , mx [ i ] [ a ] ) NEW_LINE ans = max ( ans , mx [ i ] [ b ] ) NEW_LINE a = dp [ i ] [ a ] NEW_LINE b = dp [ i ] [ b ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def compute_lca ( ) : NEW_LINE INDENT dfs_lca ( 1 , 0 , 0 ) NEW_LINE find_ancestor ( ) NEW_LINE DEDENT
def dfs ( adj , order , bridge_detect , mark , v , l ) : NEW_LINE INDENT global flag NEW_LINE mark [ v ] = 1 NEW_LINE order [ v ] = order [ l ] + 1 NEW_LINE bridge_detect [ v ] = order [ v ] NEW_LINE for i in range ( len ( adj [ v ] ) ) : NEW_LINE INDENT u = adj [ v ] [ i ] NEW_LINE if ( u == l ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( order [ v ] < order [ u ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( mark [ u ] ) : NEW_LINE INDENT bridge_detect [ v ] = min ( order [ u ] , bridge_detect [ v ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dfs ( adj , order , bridge_detect , mark , u , v ) NEW_LINE DEDENT bridge_detect [ v ] = min ( bridge_detect [ u ] , bridge_detect [ v ] ) NEW_LINE ans . append ( [ v , u ] ) NEW_LINE DEDENT if ( bridge_detect [ v ] == order [ v ] and l != 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT return flag NEW_LINE DEDENT
def createGraph ( Edges , adj , M ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT u = Edges [ i ] [ 0 ] NEW_LINE v = Edges [ i ] [ 1 ] NEW_LINE adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT DEDENT
def depthFirst ( v , graph , visited , storeChain ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE storeChain . append ( v ) NEW_LINE for i in graph [ v ] : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT depthFirst ( i , graph , visited , storeChain ) NEW_LINE DEDENT DEDENT DEDENT
def subarraySum ( arr , n ) : NEW_LINE INDENT maxSubarraySum = arr [ 0 ] NEW_LINE currentMax = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currentMax = max ( arr [ i ] , arr [ i ] + currentMax ) NEW_LINE maxSubarraySum = max ( maxSubarraySum , currentMax ) NEW_LINE DEDENT return maxSubarraySum NEW_LINE DEDENT
def get_max_sum ( arr , n ) : NEW_LINE INDENT freq = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT dp = [ 0 ] * 100001 NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = freq [ 0 ] NEW_LINE for i in range ( 2 , 100000 + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] + i * freq [ i ] ) NEW_LINE DEDENT return dp [ 100000 ] NEW_LINE DEDENT
def minFlip ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE dp = [ [ 0 , 0 ] for i in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = int ( a [ 0 ] == '1' ) NEW_LINE dp [ 0 ] [ 1 ] = int ( a [ 0 ] == '0' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + int ( a [ i ] == '1' ) NEW_LINE dp [ i ] [ 1 ] = min ( dp [ i - 1 ] ) + int ( a [ i ] == '0' ) NEW_LINE DEDENT answer = 10 ** 18 NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer = min ( answer , dp [ i ] [ 1 ] + dp [ n - 1 ] [ 0 ] - dp [ i ] [ 0 ] ) NEW_LINE DEDENT return min ( answer , dp [ n - 1 ] [ 0 ] ) NEW_LINE DEDENT
def LIIDS ( arr , N ) : NEW_LINE INDENT dp = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT dp . append ( 1 ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT j = i + i NEW_LINE while j <= N : NEW_LINE INDENT if j < N and i < N and arr [ j ] > arr [ i ] : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , dp [ i ] + 1 ) NEW_LINE DEDENT j += i NEW_LINE DEDENT if i < N : NEW_LINE INDENT ans = max ( ans , dp [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT
def findSubarraySum ( arr , n , K ) : NEW_LINE INDENT prevSum = defaultdict ( int ) NEW_LINE res = 0 NEW_LINE currsum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT currsum += arr [ i ] NEW_LINE if ( currsum == K ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( ( currsum - K ) in prevSum ) : NEW_LINE INDENT res += ( prevSum [ currsum - K ] ) NEW_LINE DEDENT prevSum [ currsum ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countSubarray ( arr , n , K ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( arr [ i ] ) ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT print ( findSubarraySum ( arr , n , K ) ) NEW_LINE DEDENT
def calculate ( pos , left , k , L , R ) : NEW_LINE INDENT if ( pos == k ) : NEW_LINE INDENT if ( left == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( left == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( i > left ) : NEW_LINE INDENT break NEW_LINE DEDENT answer = ( answer + calculate ( pos + 1 , left - i , k , L , R ) ) % mod NEW_LINE DEDENT return answer NEW_LINE DEDENT
def countWaystoDivide ( n , k , L , R ) : NEW_LINE INDENT return calculate ( 0 , n , k , L , R ) NEW_LINE DEDENT
def calculate ( pos , left , k , L , R ) : NEW_LINE INDENT if ( pos == k ) : NEW_LINE INDENT if ( left == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( left == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ pos ] [ left ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ left ] NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( i > left ) : NEW_LINE INDENT break NEW_LINE DEDENT answer = ( answer + calculate ( pos + 1 , left - i , k , L , R ) ) % mod NEW_LINE DEDENT dp [ pos ] [ left ] = answer NEW_LINE return answer NEW_LINE DEDENT
def countWaystoDivide ( n , k , L , R ) : NEW_LINE INDENT return calculate ( 0 , n , k , L , R ) NEW_LINE DEDENT
def PossibleSum ( n , m , v , k ) : NEW_LINE INDENT dp = [ [ 0 ] * ( k + 1 ) for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT if dp [ i ] [ j ] == 1 : NEW_LINE INDENT for d in range ( m ) : NEW_LINE INDENT if ( j + v [ i ] [ d ] ) <= k : NEW_LINE INDENT dp [ i + 1 ] [ j + v [ i ] [ d ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if dp [ n ] [ k ] == 1 : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def printList ( temp ) : NEW_LINE INDENT while ( temp != None ) : NEW_LINE INDENT print ( temp . info , end = " " ) NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT
def solve ( arr , curr , mask , n ) : NEW_LINE INDENT if ( isprime ( curr ) ) : NEW_LINE INDENT if ( mask == ( 1 << n ) - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT curr = 0 NEW_LINE DEDENT if ( mask == ( 1 << n ) - 1 ) : NEW_LINE INDENT if ( isprime ( curr ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( dp [ mask ] != False ) : NEW_LINE INDENT return dp [ mask ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( ( mask & 1 << i ) == False ) : NEW_LINE INDENT if ( solve ( arr , curr + arr [ i ] , mask 1 << i , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return ( dp [ mask ] == False ) NEW_LINE DEDENT
def minSqrNum ( n ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) NEW_LINE sqrNum = [ 0 ] * ( n + 1 ) NEW_LINE v = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + 1 NEW_LINE sqrNum [ i ] = 1 NEW_LINE k = 1 NEW_LINE while ( k * k <= i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - k * k ] + 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - k * k ] + 1 NEW_LINE sqrNum [ i ] = k * k NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT while ( n > 0 ) : NEW_LINE INDENT v . append ( sqrNum [ n ] ) NEW_LINE n -= sqrNum [ n ] NEW_LINE DEDENT return v NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def nCr ( n , p , f , m ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT if ( j > i ) : NEW_LINE INDENT f [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( j == 0 or j == i ) : NEW_LINE INDENT f [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p NEW_LINE DEDENT DEDENT DEDENT DEDENT
def sieve ( ) : NEW_LINE INDENT for i in range ( 2 , 1000 ) : NEW_LINE INDENT if ( isprime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , 1000 , i ) : NEW_LINE INDENT isprime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , 1000 ) : NEW_LINE INDENT if ( isprime [ i ] ) : NEW_LINE INDENT prime . append ( i ) NEW_LINE DEDENT DEDENT DEDENT
def CountWays ( i , j , sums , n , k ) : NEW_LINE INDENT if ( i >= len ( prime ) or sums > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( sums == n ) : NEW_LINE INDENT if ( j == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if j == k : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ i ] [ j ] [ sums ] == 0 : NEW_LINE INDENT return dp [ i ] [ j ] [ sums ] NEW_LINE DEDENT inc = 0 NEW_LINE exc = 0 NEW_LINE inc = CountWays ( i + 1 , j + 1 , sums + prime [ i ] , n , k ) NEW_LINE exc = CountWays ( i + 1 , j , sums , n , k ) NEW_LINE dp [ i ] [ j ] [ sums ] = inc + exc NEW_LINE return dp [ i ] [ j ] [ sums ] NEW_LINE DEDENT
def createTable ( mtrx , k , p , dp ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = mtrx [ 0 ] [ 0 ] NEW_LINE for j in range ( 1 , dim ) : NEW_LINE INDENT dp [ 0 ] [ j ] = mtrx [ 0 ] [ j ] + dp [ 0 ] [ j - 1 ] NEW_LINE DEDENT for i in range ( 1 , dim ) : NEW_LINE INDENT dp [ i ] [ 0 ] = mtrx [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , dim ) : NEW_LINE INDENT for j in range ( 1 , dim ) : NEW_LINE INDENT dp [ i ] [ j ] = ( mtrx [ i ] [ j ] + dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT
def countSubMatrixUtil ( dp , k , p ) : NEW_LINE INDENT count = 0 NEW_LINE subMatSum = 0 NEW_LINE for i in range ( k - 1 , dim ) : NEW_LINE INDENT for j in range ( k - 1 , dim , 1 ) : NEW_LINE INDENT if ( i == ( k - 1 ) or j == ( k - 1 ) ) : NEW_LINE INDENT if ( i == ( k - 1 ) and j == ( k - 1 ) ) : NEW_LINE INDENT subMatSum = dp [ i ] [ j ] NEW_LINE DEDENT elif ( i == ( k - 1 ) ) : NEW_LINE INDENT subMatSum = dp [ i ] [ j ] - dp [ i ] [ j - k ] NEW_LINE DEDENT else : NEW_LINE INDENT subMatSum = dp [ i ] [ j ] - dp [ i - k ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT subMatSum = ( dp [ i ] [ j ] - dp [ i - k ] [ j ] - dp [ i ] [ j - k ] + dp [ i - k ] [ j - k ] ) NEW_LINE DEDENT if ( subMatSum >= p ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def solve ( arr , i , len , prev , n , k ) : NEW_LINE INDENT if len == k : NEW_LINE INDENT return 0 NEW_LINE DEDENT if i == n : NEW_LINE INDENT return - sys . maxsize - 1 NEW_LINE DEDENT if dp [ i ] [ len ] [ prev ] : NEW_LINE INDENT return dp [ i ] [ len ] [ prev ] NEW_LINE DEDENT if len & 1 : NEW_LINE INDENT inc = ( productDigitSum ( arr [ prev ] , arr [ i ] ) + solve ( arr , i + 1 , len + 1 , i , n , k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT inc = solve ( arr , i + 1 , len + 1 , i , n , k ) NEW_LINE DEDENT exc = solve ( arr , i + 1 , len , prev , n , k ) NEW_LINE dp [ i ] [ len ] [ prev ] = max ( inc , exc ) NEW_LINE return dp [ i ] [ len ] [ prev ] NEW_LINE DEDENT
def precompute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT for j in range ( i , 100001 , i ) : NEW_LINE INDENT factors [ j ] . append ( i ) NEW_LINE DEDENT DEDENT DEDENT
def solve ( arr , k , n ) : NEW_LINE INDENT if ( k == n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k >= n ) : NEW_LINE INDENT return 1000000000 NEW_LINE DEDENT if ( dp [ k ] ) : NEW_LINE INDENT return dp [ k ] NEW_LINE DEDENT ans = 1000000000 NEW_LINE for j in factors [ arr [ k ] ] : NEW_LINE INDENT res = solve ( arr , k + j , n ) NEW_LINE if ( res != 1000000000 ) : NEW_LINE INDENT ans = min ( ans , res + 1 ) NEW_LINE DEDENT DEDENT dp [ k ] = ans NEW_LINE return ans NEW_LINE DEDENT
def precompute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT for j in range ( i , 100001 , i ) : NEW_LINE INDENT factors [ j ] . append ( i ) NEW_LINE DEDENT DEDENT DEDENT
def solve ( arr , n ) : NEW_LINE INDENT dp [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in factors [ arr [ i ] ] : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT dp [ i + j ] = min ( dp [ i + j ] , 1 + dp [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def operation ( n ) : NEW_LINE INDENT global dp NEW_LINE ans = 0 NEW_LINE fac = 1 NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT fac *= k NEW_LINE ans = ( ans + ( fac * f ( n , k ) ) % mod ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countWays ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 2 , m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( j + 1 ) : NEW_LINE INDENT sum += dp [ i - 1 ] [ k ] NEW_LINE DEDENT dp [ i ] [ j ] = sum NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
def countWays ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE if ( i != 0 ) : NEW_LINE INDENT dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 2 , m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE if ( i == m and j == n ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] += dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def ConvertIntoDigit ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT dig = n % 10 NEW_LINE digits . append ( dig ) NEW_LINE n //= 10 NEW_LINE DEDENT digits . reverse ( ) NEW_LINE DEDENT
def solve ( idx , k , tight , sum ) : NEW_LINE INDENT if ( idx == len ( digits ) and k == 0 and sum % 2 == 1 ) : NEW_LINE INDENT if ( not vis [ sum ] ) : NEW_LINE INDENT vis [ sum ] = True NEW_LINE return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( idx > len ( digits ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ k ] [ tight ] [ sum ] ) : NEW_LINE INDENT return dp [ idx ] [ k ] [ tight ] [ sum ] NEW_LINE DEDENT j = 0 NEW_LINE if ( idx < len ( digits ) and tight == 0 ) : NEW_LINE INDENT j = digits [ idx ] NEW_LINE DEDENT else : NEW_LINE INDENT j = 9 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 0 if k else 1 , j + 1 ) : NEW_LINE INDENT newtight = tight NEW_LINE if ( i < j ) : NEW_LINE INDENT newtight = 1 NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT cnt += solve ( idx + 1 , k - 1 , newtight , sum ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += solve ( idx + 1 , k , newtight , sum + i ) NEW_LINE DEDENT DEDENT dp [ idx ] [ k ] [ tight ] [ sum ] = cnt NEW_LINE return cnt NEW_LINE DEDENT
def minDominatingSet ( root , covered , compulsory ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( not root . left and not root . right and not covered ) : NEW_LINE INDENT compulsory = True NEW_LINE DEDENT if ( dp [ root . data ] [ covered ] [ compulsory ] != - 1 ) : NEW_LINE INDENT return dp [ root . data ] [ covered ] [ compulsory ] NEW_LINE DEDENT if ( compulsory ) : NEW_LINE INDENT dp [ root . data ] [ covered ] [ compulsory ] = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) NEW_LINE return dp [ root . data ] [ covered ] [ compulsory ] NEW_LINE DEDENT if ( covered ) : NEW_LINE INDENT dp [ root . data ] [ covered ] [ compulsory ] = min ( 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 0 ) ) NEW_LINE return dp [ root . data ] [ covered ] [ compulsory ] NEW_LINE DEDENT ans = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) NEW_LINE if ( root . left ) : NEW_LINE INDENT ans = min ( ans , minDominatingSet ( root . left , 0 , 1 ) + minDominatingSet ( root . right , 0 , 0 ) ) NEW_LINE DEDENT if ( root . right ) : NEW_LINE INDENT ans = min ( ans , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 1 ) ) NEW_LINE DEDENT dp [ root . data ] [ covered ] [ compulsory ] = ans NEW_LINE return ans NEW_LINE DEDENT
def getmask ( val ) : NEW_LINE INDENT mask = 0 NEW_LINE prime = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 ] NEW_LINE for i in range ( 1 , 15 ) : NEW_LINE INDENT if val % prime [ i ] == 0 : NEW_LINE INDENT mask = mask | ( 1 << i ) NEW_LINE DEDENT DEDENT return mask NEW_LINE DEDENT
def calculate ( pos , mask , a , n ) : NEW_LINE INDENT if ( ( pos == n ) or ( mask == ( 1 << n - 1 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ pos ] [ mask ] != - 1 : NEW_LINE INDENT return dp [ pos ] [ mask ] NEW_LINE DEDENT size = 0 NEW_LINE size = max ( size , calculate ( pos + 1 , mask , a , n ) ) NEW_LINE if ( getmask ( a [ pos ] ) & mask ) == 0 : NEW_LINE INDENT new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) NEW_LINE size = max ( size , 1 + calculate ( pos + 1 , new_mask , a , n ) ) NEW_LINE DEDENT dp [ pos ] [ mask ] = size NEW_LINE return dp [ pos ] [ mask ] NEW_LINE DEDENT
def largestSubset ( A , n ) : NEW_LINE INDENT return calculate ( 0 , 0 , A , n ) NEW_LINE DEDENT
def countSubsets ( N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT return N NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT DP = [ 0 ] * ( N + 1 ) NEW_LINE DP [ 0 ] = 0 NEW_LINE DP [ 1 ] = 1 NEW_LINE DP [ 2 ] = 2 NEW_LINE DP [ 3 ] = 2 NEW_LINE for i in range ( 4 , N + 1 ) : NEW_LINE INDENT DP [ i ] = DP [ i - 2 ] + DP [ i - 3 ] NEW_LINE DEDENT return DP [ N ] NEW_LINE DEDENT
def CountSets ( x , pos ) : NEW_LINE INDENT if ( x <= 0 ) : NEW_LINE INDENT if ( pos == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( pos == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT answer = ( CountSets ( x - 1 , pos ) + CountSets ( x - 2 , pos - 1 ) ) NEW_LINE return answer NEW_LINE DEDENT
def CountOrderedSets ( n ) : NEW_LINE INDENT factorial = [ 1 for i in range ( 10000 ) ] NEW_LINE factorial [ 0 ] = 1 NEW_LINE for i in range ( 1 , 10000 , 1 ) : NEW_LINE INDENT factorial [ i ] = factorial [ i - 1 ] * i NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT sets = CountSets ( n , i ) * factorial [ i ] NEW_LINE answer = answer + sets NEW_LINE DEDENT return answer NEW_LINE DEDENT
def CountOrderedSets ( n ) : NEW_LINE INDENT factorial = [ 0 for i in range ( 10000 ) ] NEW_LINE factorial [ 0 ] = 1 NEW_LINE for i in range ( 1 , 10000 ) : NEW_LINE INDENT factorial [ i ] = factorial [ i - 1 ] * i NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sets = CountSets ( n , i ) * factorial [ i ] NEW_LINE answer = answer + sets NEW_LINE DEDENT return answer NEW_LINE DEDENT
def numberOfArithmeticSequences ( L , N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( ( L [ i ] - L [ i - 1 ] ) == ( L [ i - 1 ] - L [ i - 2 ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT res += count NEW_LINE DEDENT return res NEW_LINE DEDENT
def count_special ( n ) : NEW_LINE INDENT fib = [ 0 for i in range ( n + 1 ) ] NEW_LINE fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod NEW_LINE DEDENT return fib [ n ] NEW_LINE DEDENT
def CountOfTriplets ( a , n ) : NEW_LINE INDENT answer = 0 NEW_LINE x = 0 NEW_LINE count = [ 0 for i in range ( 100005 ) ] NEW_LINE ways = [ 0 for i in range ( 100005 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x ^= a [ i ] NEW_LINE answer += count [ x ] * i - ways [ x ] NEW_LINE count [ x ] += 1 NEW_LINE ways [ x ] += ( i + 1 ) NEW_LINE DEDENT return answer NEW_LINE DEDENT
def MaximumSum ( a , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = - sys . maxsize - 1 NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 , 1 ) : NEW_LINE INDENT val = - sys . maxsize - 1 NEW_LINE if ( ( i - 2 >= 0 and dp [ i - 2 ] [ j - 1 ] != - sys . maxsize - 1 ) or i - 2 < 0 ) : NEW_LINE INDENT if ( i - 2 >= 0 ) : NEW_LINE INDENT val = a [ i - 1 ] + dp [ i - 2 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT val = a [ i - 1 ] NEW_LINE DEDENT DEDENT if ( i - 1 >= j ) : NEW_LINE INDENT val = max ( val , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT dp [ i ] [ j ] = val NEW_LINE DEDENT DEDENT return dp [ n ] [ n // 2 ] NEW_LINE DEDENT
def MaximumSum ( a , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( 2 ) ] for y in range ( n + 1 ) ] NEW_LINE dp [ 2 ] [ 1 ] = a [ 1 ] NEW_LINE dp [ 2 ] [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT temp = max ( [ dp [ i - 3 ] [ 1 ] , dp [ i - 3 ] [ 0 ] , dp [ i - 2 ] [ 1 ] , dp [ i - 2 ] [ 0 ] ] ) NEW_LINE dp [ i ] [ 1 ] = a [ i - 1 ] + temp NEW_LINE dp [ i ] [ 0 ] = max ( [ a [ i - 2 ] + dp [ i - 2 ] [ 0 ] , a [ i - 2 ] + dp [ i - 3 ] [ 1 ] , a [ i - 2 ] + dp [ i - 3 ] [ 0 ] , a [ i - 3 ] + dp [ i - 3 ] [ 0 ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 1 ] = ( a [ i - 1 ] + max ( [ dp [ i - 2 ] [ 1 ] , dp [ i - 2 ] [ 0 ] , dp [ i - 1 ] [ 0 ] ] ) ) NEW_LINE dp [ i ] [ 0 ] = a [ i - 2 ] + dp [ i - 2 ] [ 0 ] NEW_LINE DEDENT DEDENT return max ( dp [ n ] [ 1 ] , dp [ n ] [ 0 ] ) NEW_LINE DEDENT
def func ( n ) : NEW_LINE INDENT global kPowKform NEW_LINE if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n in kPowKform ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT answer = 0 NEW_LINE x = n NEW_LINE while ( x > 0 ) : NEW_LINE INDENT d = x % 10 NEW_LINE if ( d != 0 ) : NEW_LINE INDENT if ( func ( n - d * d ) ) : NEW_LINE INDENT answer = 1 NEW_LINE break NEW_LINE DEDENT DEDENT x //= 10 NEW_LINE DEDENT return answer NEW_LINE DEDENT
def canBeConverted ( n ) : NEW_LINE INDENT if ( func ( n ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def divisorGame ( N , A , dp ) : NEW_LINE INDENT if ( N == 1 or N == 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dp [ N ] [ A ] != - 1 ) : NEW_LINE INDENT return dp [ N ] [ A ] NEW_LINE DEDENT if ( A == 1 ) : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT for i in range ( 1 , int ( sqrt ( N ) ) + 1 , 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( A ) : NEW_LINE INDENT ans |= divisorGame ( N - i , 0 , dp ) NEW_LINE DEDENT else : NEW_LINE INDENT ans &= divisorGame ( N - i , 1 , dp ) NEW_LINE DEDENT DEDENT DEDENT dp [ N ] [ A ] = ans NEW_LINE return dp [ N ] [ A ] NEW_LINE DEDENT
def check ( v ) : NEW_LINE INDENT digits = set ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT d = set ( ) NEW_LINE while ( v [ i ] != 0 ) : NEW_LINE INDENT d . add ( v [ i ] % 10 ) NEW_LINE v [ i ] //= 10 NEW_LINE DEDENT for it in d : NEW_LINE INDENT if it in digits : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for it in d : NEW_LINE INDENT digits . add ( it ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def numberOfSubarrays ( a , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 1 , 1 << n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT temp . append ( a [ j ] ) NEW_LINE DEDENT DEDENT if ( check ( temp ) ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def countWays ( pos , mask , a , n ) : NEW_LINE INDENT if pos == n : NEW_LINE INDENT if mask > 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if dp [ pos ] [ mask ] != - 1 : NEW_LINE INDENT return dp [ pos ] [ mask ] NEW_LINE DEDENT count = 0 NEW_LINE count = ( count + countWays ( pos + 1 , mask , a , n ) ) NEW_LINE if ( getmask ( a [ pos ] ) & mask ) == 0 : NEW_LINE INDENT new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) NEW_LINE count = ( count + countWays ( pos + 1 , new_mask , a , n ) ) NEW_LINE DEDENT dp [ pos ] [ mask ] = count NEW_LINE return count NEW_LINE DEDENT
def numberOfSubarrays ( a , n ) : NEW_LINE INDENT return countWays ( 0 , 0 , a , n ) NEW_LINE DEDENT
def change ( p , x ) : NEW_LINE INDENT if ( p [ 1 ] > x ) : NEW_LINE INDENT p [ 1 ] = x NEW_LINE DEDENT if ( p [ 0 ] > p [ 1 ] ) : NEW_LINE INDENT tmp = p [ 0 ] NEW_LINE DEDENT p [ 0 ] = p [ 1 ] NEW_LINE p [ 1 ] = tmp NEW_LINE DEDENT
def minNodetoRemove ( n , edges ) : NEW_LINE INDENT for i in range ( len ( edges ) ) : NEW_LINE INDENT adj [ edges [ i ] [ 0 ] ] . append ( edges [ i ] [ 1 ] ) NEW_LINE adj [ edges [ i ] [ 1 ] ] . append ( edges [ i ] [ 0 ] ) NEW_LINE DEDENT global vis , totBackEdges NEW_LINE vis = [ 0 for i in range ( len ( vis ) ) ] NEW_LINE totBackEdges = 0 NEW_LINE for v in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( vis [ v ] == 0 ) : NEW_LINE INDENT dfs ( v ) NEW_LINE DEDENT DEDENT if ( totBackEdges == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT node = - 1 NEW_LINE for v in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( countAdj [ v ] + small [ v ] == totBackEdges ) and isPossible [ v ] != 0 ) : NEW_LINE INDENT node = v NEW_LINE DEDENT if ( node != - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return node NEW_LINE DEDENT
def height ( root ) : NEW_LINE INDENT ht = 0 NEW_LINE if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( max ( height ( root . left ) , height ( root . right ) ) + 1 ) NEW_LINE DEDENT
def FibonacciSeries ( n ) : NEW_LINE INDENT fib . append ( 0 ) NEW_LINE fib . append ( 1 ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT fib . append ( fib [ i - 1 ] + fib [ i - 2 ] ) NEW_LINE DEDENT DEDENT
def CountPathUtil ( root , i , count ) : NEW_LINE INDENT if ( root == None or not ( fib [ i ] == root . data ) ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( not root . left and not root . right ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT count = CountPathUtil ( root . left , i + 1 , count ) NEW_LINE return CountPathUtil ( root . right , i + 1 , count ) NEW_LINE DEDENT
def CountPath ( root ) : NEW_LINE INDENT ht = height ( root ) NEW_LINE FibonacciSeries ( ht ) NEW_LINE print ( CountPathUtil ( root , 0 , 0 ) ) NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime = [ True ] * ( Large + 1 ) NEW_LINE for p in range ( 2 , int ( Large ** ( 1 / 2 ) ) ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , Large + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , Large + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT prime . append ( p ) NEW_LINE DEDENT DEDENT DEDENT
def Display ( arr , row ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT print ( arr [ row ] [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def countDivisorsMult ( arr ) : NEW_LINE INDENT mp = { } NEW_LINE row_no = 0 NEW_LINE max_factor = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT no = arr [ i ] [ j ] NEW_LINE for k in range ( len ( prime ) ) : NEW_LINE INDENT while ( no > 1 and no % prime [ k ] == 0 ) : NEW_LINE INDENT no //= prime [ k ] NEW_LINE if prime [ k ] not in mp : NEW_LINE INDENT mp [ prime [ k ] ] = 0 NEW_LINE DEDENT mp [ prime [ k ] ] += 1 NEW_LINE DEDENT if ( no == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT res = 1 NEW_LINE for it in mp : NEW_LINE INDENT res *= mp [ it ] NEW_LINE DEDENT if ( max_factor < res ) : NEW_LINE INDENT row_no = i NEW_LINE max_factor = res NEW_LINE DEDENT mp . clear ( ) NEW_LINE DEDENT Display ( arr , row_no ) NEW_LINE DEDENT
def isSquare ( n ) : NEW_LINE INDENT k = int ( sqrt ( n ) ) NEW_LINE return ( k * k == n ) NEW_LINE DEDENT
def calculate ( pos , prev , sum , v ) : NEW_LINE INDENT if ( pos == len ( v ) ) : NEW_LINE INDENT return isSquare ( sum ) NEW_LINE DEDENT for i in range ( prev , 9 + 1 ) : NEW_LINE INDENT v [ pos ] = i NEW_LINE sum += i * i NEW_LINE if ( calculate ( pos + 1 , i , sum , v ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum -= i * i NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def countMountains ( a , n ) : NEW_LINE INDENT A = [ [ 0 for i in range ( n + 2 ) ] for i in range ( n + 2 ) ] NEW_LINE count = 0 NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT for j in range ( n + 2 ) : NEW_LINE INDENT if ( ( i == 0 ) or ( j == 0 ) or ( i == n + 1 ) or ( j == n + 1 ) ) : NEW_LINE INDENT A [ i ] [ j ] = float ( '-inf' ) NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j ] ) and ( A [ i ] [ j ] > A [ i ] [ j - 1 ] ) and ( A [ i ] [ j ] > A [ i ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j - 1 ] ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def calculate ( pos , g , n , k ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT return g NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT answer = ( answer % MOD + calculate ( pos + 1 , gcd ( g , i ) , n , k ) % MOD ) NEW_LINE answer %= MOD NEW_LINE DEDENT return answer NEW_LINE DEDENT
def sumofGCD ( n , k ) : NEW_LINE INDENT return calculate ( 0 , 0 , n , k ) NEW_LINE DEDENT
def fastexpo ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE a = a % MOD NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( ( b & 1 ) != 0 ) : NEW_LINE INDENT res = ( res * a ) % MOD NEW_LINE DEDENT a = a * a NEW_LINE a = a % MOD NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def sumofGCD ( n , k ) : NEW_LINE INDENT count = [ 0 ] * ( k + 1 ) NEW_LINE for g in range ( k , 0 , - 1 ) : NEW_LINE INDENT count_multiples = k // g NEW_LINE temp = fastexpo ( count_multiples , n ) NEW_LINE temp = temp % MOD NEW_LINE extra = 0 NEW_LINE for j in range ( g * 2 , k + 1 , g ) : NEW_LINE INDENT extra = extra + count [ j ] NEW_LINE extra = extra % MOD NEW_LINE DEDENT count [ g ] = temp - extra + MOD NEW_LINE count [ g ] = count [ g ] % MOD NEW_LINE DEDENT Sum = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT add = count [ i ] % MOD * i % MOD NEW_LINE add = add % MOD NEW_LINE Sum = Sum + add NEW_LINE Sum = Sum % MOD NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def findCost ( cost_mat , N , M ) : NEW_LINE INDENT dp = [ [ 0 ] * M for _ in range ( M ) ] NEW_LINE dp [ 0 ] = cost_mat [ 0 ] NEW_LINE for row in range ( 1 , N ) : NEW_LINE INDENT for curr_col in range ( M ) : NEW_LINE INDENT val = 999999999 NEW_LINE for prev_col in range ( M ) : NEW_LINE INDENT if curr_col != prev_col : NEW_LINE INDENT val = min ( val , dp [ row - 1 ] [ prev_col ] ) NEW_LINE DEDENT DEDENT dp [ row ] [ curr_col ] = val + cost_mat [ row ] [ curr_col ] NEW_LINE DEDENT DEDENT return min ( dp [ - 1 ] ) NEW_LINE DEDENT
def checkOdd ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE num = ord ( number [ n - 1 ] ) - 48 NEW_LINE return ( num & 1 ) NEW_LINE DEDENT
def getPrimesFromSeive ( primes ) : NEW_LINE INDENT prime = [ True ] * ( 1000001 ) NEW_LINE prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE i = 2 NEW_LINE while ( i * i <= 1000000 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT for j in range ( i * i , 1000001 , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( 2 , 1000001 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT primes . append ( str ( i ) ) NEW_LINE DEDENT DEDENT DEDENT
def splitIntoPrimes ( number ) : NEW_LINE INDENT numLen = len ( number ) NEW_LINE splitDP = [ - 1 ] * ( numLen + 1 ) NEW_LINE primes = [ ] NEW_LINE getPrimesFromSeive ( primes ) NEW_LINE for i in range ( 1 , numLen + 1 ) : NEW_LINE INDENT if ( i <= 6 and ( number [ 0 : i ] in primes ) ) : NEW_LINE INDENT splitDP [ i ] = 1 NEW_LINE DEDENT if ( splitDP [ i ] != - 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while ( j <= 6 and ( i + j <= numLen ) ) : NEW_LINE INDENT if ( number [ i : i + j ] in primes ) : NEW_LINE INDENT if ( splitDP [ i + j ] == - 1 ) : NEW_LINE INDENT splitDP [ i + j ] = 1 + splitDP [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT splitDP [ i + j ] = min ( splitDP [ i + j ] , 1 + splitDP [ i ] ) NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return splitDP [ numLen ] NEW_LINE DEDENT
def k_nonzero_numbers ( s , n , k ) : NEW_LINE INDENT dp = [ [ [ 0 for i in range ( k + 2 ) ] for i in range ( 2 ) ] for i in range ( n + 2 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT for x in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ x ] = 0 NEW_LINE DEDENT DEDENT DEDENT dp [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE while ( sm < 2 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE if sm : NEW_LINE INDENT y = 9 NEW_LINE DEDENT else : NEW_LINE INDENT y = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT while ( x <= y ) : NEW_LINE INDENT dp [ i + 1 ] [ ( sm or x < ( ord ( s [ i ] ) - ord ( '0' ) ) ) ] [ j + ( x > 0 ) ] += dp [ i ] [ sm ] [ j ] NEW_LINE x += 1 NEW_LINE DEDENT DEDENT sm += 1 NEW_LINE DEDENT DEDENT return dp [ n ] [ 0 ] [ k ] + dp [ n ] [ 1 ] [ k ] NEW_LINE DEDENT
def maximumOccurrence ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE freq = { } NEW_LINE for i in s : NEW_LINE INDENT temp = "" NEW_LINE temp += i NEW_LINE freq [ temp ] = freq . get ( temp , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT temp = "" NEW_LINE temp += s [ i ] NEW_LINE temp += s [ j ] NEW_LINE freq [ temp ] = freq . get ( temp , 0 ) + 1 NEW_LINE DEDENT DEDENT answer = - 10 ** 9 NEW_LINE for it in freq : NEW_LINE INDENT answer = max ( answer , freq [ it ] ) NEW_LINE DEDENT return answer NEW_LINE DEDENT
def maximumOccurrence ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE freq = [ 0 ] * ( 26 ) NEW_LINE dp = [ [ 0 for i in range ( 26 ) ] for j in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = ( ord ( s [ i ] ) - ord ( 'a' ) ) NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT dp [ j ] += freq [ j ] NEW_LINE DEDENT freq += 1 NEW_LINE DEDENT answer = - sys . maxsize NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT answer = max ( answer , freq [ i ] ) NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT answer = max ( answer , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def calculate ( pos , rem , z , k , n ) : NEW_LINE INDENT if ( rem == 0 and z ) : NEW_LINE INDENT if ( pos != n ) : NEW_LINE INDENT return ( powers [ n - pos - 1 ] * 9 ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( pos == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ pos ] [ rem ] [ z ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ rem ] [ z ] NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , z , k , n ) ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , 1 , k , n ) ) ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ rem ] [ z ] = count NEW_LINE return count NEW_LINE DEDENT
def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT left = s [ 0 : i ] NEW_LINE right = s [ i : n ] NEW_LINE if ( distinctChars ( left ) == distinctChars ( right ) ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = 0 NEW_LINE prefix = [ 0 ] * n NEW_LINE suffix = [ 0 ] * n NEW_LINE seen = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = prefix [ i - 1 ] if ( i - 1 >= 0 ) else 0 NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( 'a' ) ] == 0 ) : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( 'a' ) ] = 1 NEW_LINE DEDENT seen = [ 0 ] * len ( seen ) NEW_LINE suffix [ n - 1 ] = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT prev = suffix [ i ] NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( 'a' ) ] == 0 ) : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( 'a' ) ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prefix [ i ] == suffix [ i ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def calculate ( pos , tight , D , sz , num ) : NEW_LINE INDENT if ( pos == len ( num ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ tight ] NEW_LINE DEDENT val = 0 NEW_LINE if ( tight == 0 ) : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT if ( D [ i ] < ( ord ( num [ pos ] ) - ord ( '0' ) ) ) : NEW_LINE INDENT val += calculate ( pos + 1 , 1 , D , sz , num ) NEW_LINE DEDENT elif ( D [ i ] == ord ( num [ pos ] ) - ord ( '0' ) ) : NEW_LINE INDENT val += calculate ( pos + 1 , tight , D , sz , num ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT val += calculate ( pos + 1 , tight , D , sz , num ) NEW_LINE DEDENT DEDENT dp [ pos ] [ tight ] = val NEW_LINE return dp [ pos ] [ tight ] NEW_LINE DEDENT
def countNumbers ( D , N , sz ) : NEW_LINE INDENT num = convertToString ( N ) NEW_LINE length = len ( num ) NEW_LINE ans = calculate ( 0 , 0 , D , sz , num ) NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT ans += calculate ( i , 1 , D , sz , num ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def fibonacci ( ) : NEW_LINE INDENT fib [ 0 ] = 0 NEW_LINE fib [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX_SIZE + 1 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DEDENT
def printLevel ( level ) : NEW_LINE INDENT left_index = pow ( 2 , level - 1 ) NEW_LINE right_index = pow ( 2 , level ) - 1 NEW_LINE for i in range ( left_index , right_index + 1 ) : NEW_LINE INDENT print ( fib [ i - 1 ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def calculate ( pos , prev , left , k ) : NEW_LINE INDENT if ( pos == k ) : NEW_LINE INDENT if ( left == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( left == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( prev , left + 1 ) : NEW_LINE INDENT answer += calculate ( pos + 1 , i , left - i , k ) NEW_LINE DEDENT return answer NEW_LINE DEDENT
def countWaystoDivide ( n , k ) : NEW_LINE INDENT return calculate ( 0 , 1 , n , k ) NEW_LINE DEDENT
def calculate ( pos , prev , left , k ) : NEW_LINE INDENT if ( pos == k ) : NEW_LINE INDENT if ( left == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( left == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ pos ] [ prev ] [ left ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] [ left ] NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( prev , left + 1 ) : NEW_LINE INDENT answer += calculate ( pos + 1 , i , left - i , k ) NEW_LINE DEDENT dp [ pos ] [ prev ] [ left ] = answer NEW_LINE return dp [ pos ] [ prev ] [ left ] NEW_LINE DEDENT
def countWaystoDivide ( n , k ) : NEW_LINE INDENT for i in range ( 50 ) : NEW_LINE INDENT for j in range ( 50 ) : NEW_LINE INDENT for l in range ( 50 ) : NEW_LINE INDENT dp [ i ] [ j ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT return calculate ( 0 , 1 , n , k ) NEW_LINE DEDENT
def countWays ( a , s ) : NEW_LINE INDENT n = len ( a ) NEW_LINE index = [ [ ] for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( a [ i ] ) ) : NEW_LINE INDENT index [ ord ( a [ i ] [ j ] ) - ord ( 'a' ) ] . append ( j + 1 ) NEW_LINE DEDENT DEDENT return calculate ( 0 , 0 , s , index [ 0 ] ) NEW_LINE DEDENT
def minimalLength ( a , n ) : NEW_LINE INDENT dp = np . ones ( ( n + 1 , n + 1 ) ) * - 1 NEW_LINE dp1 = [ 0 ] * n NEW_LINE for size in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - size + 1 ) : NEW_LINE INDENT j = i + size - 1 NEW_LINE if ( i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT for k in range ( i , j ) : NEW_LINE INDENT if ( dp [ i ] [ k ] != - 1 and dp [ i ] [ k ] == dp [ k + 1 ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ k ] + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT dp1 [ i ] = int ( 1e7 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( dp [ j ] [ i ] != - 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp1 [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp1 [ i ] = min ( dp1 [ i ] , dp1 [ j - 1 ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp1 [ n - 1 ] NEW_LINE DEDENT
def maxScore ( l , r , prefix_sum , num ) : NEW_LINE INDENT if ( l > r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( l - 1 ) >= 0 ) : NEW_LINE INDENT current_sum = ( prefix_sum [ r ] - prefix_sum [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT current_sum = prefix_sum [ r ] - 0 NEW_LINE DEDENT if ( num % 2 == 0 ) : NEW_LINE INDENT current_sum *= - 1 NEW_LINE DEDENT return current_sum + max ( maxScore ( l + 1 , r , prefix_sum , num + 1 ) , maxScore ( l , r - 1 , prefix_sum , num + 1 ) ) NEW_LINE DEDENT
def findMaxScore ( a , n ) : NEW_LINE INDENT prefix_sum = [ 0 ] * n NEW_LINE prefix_sum [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum [ i ] = prefix_sum [ i - 1 ] + a [ i ] NEW_LINE DEDENT return maxScore ( 0 , n - 1 , prefix_sum , 1 ) NEW_LINE DEDENT
def MaximumScoreDP ( l , r , prefix_sum , num ) : NEW_LINE INDENT if ( l > r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ l ] [ r ] [ num ] != - 1 ) : NEW_LINE INDENT return dp [ l ] [ r ] [ num ] NEW_LINE DEDENT current_sum = prefix_sum [ r ] NEW_LINE if ( l - 1 >= 0 ) : NEW_LINE INDENT current_sum -= prefix_sum [ l - 1 ] NEW_LINE DEDENT if ( num % 2 == 0 ) : NEW_LINE INDENT current_sum *= - 1 NEW_LINE DEDENT dp [ l ] [ r ] [ num ] = ( current_sum + max ( MaximumScoreDP ( l + 1 , r , prefix_sum , num + 1 ) , MaximumScoreDP ( l , r - 1 , prefix_sum , num + 1 ) ) ) NEW_LINE return dp [ l ] [ r ] [ num ] NEW_LINE DEDENT
def findMaxScore ( a , n ) : NEW_LINE INDENT prefix_sum = [ 0 ] * n NEW_LINE prefix_sum [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum [ i ] = prefix_sum [ i - 1 ] + a [ i ] NEW_LINE DEDENT global dp NEW_LINE return MaximumScoreDP ( 0 , n - 1 , prefix_sum , 1 ) NEW_LINE DEDENT
def computeFibonacci ( ) : NEW_LINE INDENT fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 1 NEW_LINE for i in range ( 2 , 100005 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DEDENT
def countString ( string ) : NEW_LINE INDENT ans = 1 NEW_LINE cnt = 1 NEW_LINE for i in range ( 1 , len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == string [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans * fib [ cnt ] NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT ans = ans * fib [ cnt ] NEW_LINE return ans NEW_LINE DEDENT
def find_max ( i , sum , v , k ) : NEW_LINE INDENT if ( i == len ( v ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ sum ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ sum ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( ( sum + find_max ( i + 1 , sum , v , k ) ) % k == 0 ) : NEW_LINE INDENT ans = find_max ( i + 1 , sum , v , k ) NEW_LINE DEDENT if ( ( sum + v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) % k == 0 ) : NEW_LINE INDENT ans = max ( ans , v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) NEW_LINE DEDENT dp [ i ] [ sum ] = ans NEW_LINE return dp [ i ] [ sum ] NEW_LINE DEDENT
def maxLength ( a , n ) : NEW_LINE INDENT maximum = 1 NEW_LINE left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT left [ i ] = 1 NEW_LINE right [ i ] = 1 NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 NEW_LINE DEDENT maximum = max ( maximum , right [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] > a [ i + 1 ] ) : NEW_LINE INDENT maximum = max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return maximum NEW_LINE DEDENT
def printGolombSequence ( N ) : NEW_LINE INDENT arr = [ 0 ] * MAX NEW_LINE cnt = 0 NEW_LINE arr [ 0 ] = 0 NEW_LINE arr [ 1 ] = 1 NEW_LINE M = dict ( ) NEW_LINE M [ 2 ] = 2 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( cnt == 0 ) : NEW_LINE INDENT arr [ i ] = 1 + arr [ i - 1 ] NEW_LINE cnt = M [ arr [ i ] ] NEW_LINE cnt -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE cnt -= 1 NEW_LINE DEDENT M [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def number_of_ways ( n ) : NEW_LINE INDENT includes_3 = [ 0 ] * ( n + 1 ) NEW_LINE not_includes_3 = [ 0 ] * ( n + 1 ) NEW_LINE includes_3 [ 3 ] = 1 NEW_LINE not_includes_3 [ 1 ] = 1 NEW_LINE not_includes_3 [ 2 ] = 2 NEW_LINE not_includes_3 [ 3 ] = 3 NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] NEW_LINE not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] NEW_LINE DEDENT return includes_3 [ n ] NEW_LINE DEDENT
def cntSubSeq ( arr , n ) : NEW_LINE INDENT pos_count = 0 NEW_LINE neg_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_count += 1 NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT neg_count += 1 NEW_LINE DEDENT DEDENT result = int ( math . pow ( 2 , pos_count ) ) NEW_LINE if ( neg_count > 0 ) : NEW_LINE INDENT result *= int ( math . pow ( 2 , neg_count - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE DEDENT return result NEW_LINE DEDENT
def generateDivisors ( n ) : NEW_LINE INDENT for i in range ( 1 , ceil ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT divisors [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT divisors [ i ] += 1 NEW_LINE divisors [ n // i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findMaxMultiples ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( divisors [ arr [ i ] ] , ans ) NEW_LINE generateDivisors ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def max_sum ( arr , n , k ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = max ( 0 , arr [ 0 ] ) NEW_LINE i = 1 NEW_LINE while ( i < k ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT i = k NEW_LINE while ( i < n ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , arr [ i ] + dp [ i - k ] ) NEW_LINE i += 1 NEW_LINE DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def maxIncSubarr ( a , n ) : NEW_LINE INDENT pre = [ 0 ] * n NEW_LINE pos = [ 0 ] * n NEW_LINE pre [ 0 ] = 1 NEW_LINE pos [ n - 1 ] = 1 NEW_LINE l = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] > a [ i - 1 ] ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre [ i ] = 1 NEW_LINE DEDENT DEDENT l = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] < a [ i + 1 ] ) : NEW_LINE INDENT pos [ i ] = pos [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos [ i ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE l = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] > a [ i - 1 ] ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = 1 NEW_LINE DEDENT ans = max ( ans , l ) NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] < a [ i + 1 ] ) : NEW_LINE INDENT ans = max ( pre [ i - 1 ] + pos [ i + 1 ] , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT f0 = 1 NEW_LINE f1 = 1 NEW_LINE f2 = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT ans = f0 + f1 + f2 NEW_LINE f0 = f1 NEW_LINE f1 = f2 NEW_LINE f2 = ans NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countStr ( N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 3 ) ] for i in range ( N + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 2 ] = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD NEW_LINE DEDENT ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD NEW_LINE return ans NEW_LINE DEDENT
def update ( In , l , r , up_In , val ) : NEW_LINE INDENT if ( r < up_In or l > up_In ) : NEW_LINE INDENT return seg [ In ] NEW_LINE DEDENT if ( l == up_In and r == up_In ) : NEW_LINE INDENT seg [ In ] = val NEW_LINE return val NEW_LINE DEDENT m = ( l + r ) // 2 NEW_LINE seg [ In ] = update ( 2 * In + 1 , l , m , up_In , val ) + update ( 2 * In + 2 , m + 1 , r , up_In , val ) NEW_LINE return seg [ In ] NEW_LINE DEDENT
def maxLengthSquare ( row , column , arr , k ) : NEW_LINE INDENT sum = np . zeros ( ( row + 1 , column + 1 ) ) NEW_LINE cur_max = 1 NEW_LINE max = 0 NEW_LINE for i in range ( 1 , row + 1 ) : NEW_LINE INDENT for j in range ( 1 , column + 1 ) : NEW_LINE INDENT sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] + arr [ i - 1 ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] NEW_LINE if ( i >= cur_max and j >= cur_max and sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) : NEW_LINE INDENT max = cur_max NEW_LINE cur_max += 1 NEW_LINE DEDENT DEDENT DEDENT return max NEW_LINE DEDENT
def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 NEW_LINE exactnum [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT for k in range ( z + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod NEW_LINE DEDENT ans += exactsum [ i ] [ j ] [ k ] % mod NEW_LINE ans %= mod NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def maximum_set ( a , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE for i in a : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( N - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( dp [ i ] != 0 ) : NEW_LINE INDENT for j in range ( 2 * i , N , i ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , 1 + dp [ j ] ) NEW_LINE ans = max ( ans , dp [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def findMaxCount ( root ) : NEW_LINE INDENT global res NEW_LINE res = - 999999 NEW_LINE countUntil ( root ) NEW_LINE return res NEW_LINE DEDENT
def findLargestString ( s , i , r ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return INT_MIN NEW_LINE DEDENT DEDENT if ( v [ i ] [ r ] ) : NEW_LINE INDENT return dp [ i ] [ r ] NEW_LINE DEDENT v [ i ] [ r ] = 1 NEW_LINE dp [ i ] [ r ] = max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( ord ( s [ i ] ) - ord ( '0' ) ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) NEW_LINE return dp [ i ] [ r ] NEW_LINE DEDENT
def findCnt ( s , i , r ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( v [ i ] [ r ] ) : NEW_LINE INDENT return dp [ i ] [ r ] NEW_LINE DEDENT v [ i ] [ r ] = 1 NEW_LINE dp [ i ] [ r ] = findCnt ( s , i + 1 , ( r * 2 + ( ord ( s [ i ] ) - ord ( '0' ) ) ) % 3 ) + findCnt ( s , i + 1 , r ) NEW_LINE return dp [ i ] [ r ] NEW_LINE DEDENT
def modInv ( a , p = MOD - 2 ) : NEW_LINE INDENT s = 1 NEW_LINE while ( p != 1 ) : NEW_LINE INDENT if ( p % 2 ) : NEW_LINE INDENT s = ( s * a ) % MOD NEW_LINE DEDENT a = ( a * a ) % MOD NEW_LINE p //= 2 NEW_LINE DEDENT return ( a * s ) % MOD NEW_LINE DEDENT
def findCnt ( x , y ) : NEW_LINE INDENT ans = 0 NEW_LINE fact = [ 1 ] * ( len ( y ) + 1 ) NEW_LINE for i in range ( 1 , len ( y ) ) : NEW_LINE INDENT fact [ i ] = ( fact [ i - 1 ] * i ) % MOD NEW_LINE DEDENT for i in range ( len ( y ) ) : NEW_LINE INDENT if ( y [ i ] == x ) : NEW_LINE INDENT ans += ( modInv ( fact [ i ] ) * modInv ( fact [ len ( y ) - i - 1 ] ) ) % MOD NEW_LINE ans %= MOD NEW_LINE DEDENT DEDENT ans *= fact [ ( len ( y ) - 1 ) ] NEW_LINE ans %= MOD NEW_LINE return ans NEW_LINE DEDENT
def minCount ( arr , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT sum -= k NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE tot = 0 NEW_LINE while ( l < n ) : NEW_LINE INDENT if ( tot <= sum ) : NEW_LINE INDENT ans = max ( ans , r - l ) NEW_LINE if ( r == n ) : NEW_LINE INDENT break NEW_LINE DEDENT tot += arr [ r ] NEW_LINE r += 1 NEW_LINE DEDENT else : NEW_LINE INDENT tot -= arr [ l ] NEW_LINE l += 1 NEW_LINE DEDENT DEDENT return ( n - ans ) NEW_LINE DEDENT
def findSubSeq ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = [ 1 ] * n NEW_LINE prev = [ - 1 ] * n NEW_LINE max = 0 NEW_LINE maxprev = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 and count [ j ] + 1 > count [ i ] ) : NEW_LINE INDENT count [ i ] = count [ j ] + 1 NEW_LINE prev [ i ] = j NEW_LINE DEDENT DEDENT if ( max < count [ i ] ) : NEW_LINE INDENT max = count [ i ] NEW_LINE maxprev = i NEW_LINE DEDENT DEDENT i = maxprev NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( arr [ i ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT i = prev [ i ] NEW_LINE DEDENT DEDENT
def solve ( arr , l , r , k ) : NEW_LINE INDENT if ( r - l + 1 <= k ) : NEW_LINE INDENT return Sum ( arr , l , r ) NEW_LINE DEDENT if ( dp [ l ] [ r ] [ k ] ) : NEW_LINE INDENT return dp [ l ] [ r ] [ k ] NEW_LINE DEDENT sum_ = Sum ( arr , l , r ) NEW_LINE len_r = ( r - l + 1 ) - k NEW_LINE length = ( r - l + 1 ) NEW_LINE ans = 0 NEW_LINE for i in range ( length - len_r + 1 ) : NEW_LINE INDENT sum_sub = Sum ( arr , i + l , i + l + len_r - 1 ) NEW_LINE ans = max ( ans , ( sum_ - sum_sub ) + ( sum_sub - solve ( arr , i + l , i + l + len_r - 1 , k ) ) ) NEW_LINE DEDENT dp [ l ] [ r ] [ k ] = ans NEW_LINE return ans NEW_LINE DEDENT
def minDifference ( x , y , k , b , c ) : NEW_LINE INDENT if ( x >= n or y >= m ) : NEW_LINE INDENT return INT_MAX NEW_LINE DEDENT if ( x == n - 1 and y == m - 1 ) : NEW_LINE INDENT diff = b [ x ] [ y ] - c [ x ] [ y ] NEW_LINE return min ( abs ( k - diff ) , abs ( k + diff ) ) NEW_LINE DEDENT ans = dp [ x ] [ y ] [ k ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = INT_MAX NEW_LINE diff = b [ x ] [ y ] - c [ x ] [ y ] NEW_LINE ans = min ( ans , minDifference ( x + 1 , y , abs ( k + diff ) , b , c ) ) NEW_LINE ans = min ( ans , minDifference ( x , y + 1 , abs ( k + diff ) , b , c ) ) NEW_LINE ans = min ( ans , minDifference ( x + 1 , y , abs ( k - diff ) , b , c ) ) NEW_LINE ans = min ( ans , minDifference ( x , y + 1 , abs ( k - diff ) , b , c ) ) NEW_LINE return ans NEW_LINE DEDENT
def countSubSeq ( strr , lenn ) : NEW_LINE INDENT ans = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] == '0' ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def solveDp ( r , i , w , val , n ) : NEW_LINE INDENT if ( r <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return W_MAX NEW_LINE DEDENT if ( v [ r ] [ i ] ) : NEW_LINE INDENT return dp [ r ] [ i ] NEW_LINE DEDENT v [ r ] [ i ] = 1 NEW_LINE dp [ r ] [ i ] = min ( solveDp ( r , i + 1 , w , val , n ) , w [ i ] + solveDp ( r - val [ i ] , i + 1 , w , val , n ) ) NEW_LINE return dp [ r ] [ i ] NEW_LINE DEDENT
def maxWeight ( w , val , n , c ) : NEW_LINE INDENT for i in range ( V_SUM_MAX , - 1 , - 1 ) : NEW_LINE INDENT if ( solveDp ( i , 0 , w , val , n ) <= c ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def dfs ( node ) : NEW_LINE INDENT leaf = True NEW_LINE vis [ node ] = 1 NEW_LINE for child in tree [ node ] : NEW_LINE INDENT if ( vis [ child ] == 0 ) : NEW_LINE INDENT leaf = False NEW_LINE dfs ( child ) NEW_LINE subtree_size [ node ] += subtree_size [ child ] NEW_LINE DEDENT DEDENT if leaf : NEW_LINE INDENT subtree_size [ node ] = 1 NEW_LINE DEDENT DEDENT
def contribution ( node , ans ) : NEW_LINE INDENT global an NEW_LINE vis [ node ] = 1 NEW_LINE for child in tree [ node ] : NEW_LINE INDENT if ( vis [ child ] == 0 ) : NEW_LINE INDENT an += ( subtree_size [ child ] * ( n - subtree_size [ child ] ) ) NEW_LINE contribution ( child , ans ) NEW_LINE DEDENT DEDENT DEDENT
def getSum ( ) : NEW_LINE INDENT for i in range ( sz ) : NEW_LINE INDENT vis [ i ] = 0 NEW_LINE DEDENT dfs ( 0 ) NEW_LINE ans = 0 NEW_LINE for i in range ( sz ) : NEW_LINE INDENT vis [ i ] = 0 NEW_LINE DEDENT contribution ( 0 , ans ) NEW_LINE return an NEW_LINE DEDENT
def longest_subseq ( n , k , s ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE max_length = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = ord ( s [ i ] ) - ord ( 'a' ) NEW_LINE lower = max ( 0 , curr - k ) NEW_LINE upper = min ( 25 , curr + k ) NEW_LINE for j in range ( lower , upper + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , max_length [ j ] + 1 ) NEW_LINE DEDENT max_length [ curr ] = max ( dp [ i ] , max_length [ curr ] ) NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT
def countNum ( idx , sum , tight , num , len1 , k ) : NEW_LINE INDENT if ( len1 == idx ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ sum ] [ tight ] NEW_LINE DEDENT res = 0 NEW_LINE if ( tight == 0 ) : NEW_LINE INDENT limit = num [ idx ] NEW_LINE DEDENT else : NEW_LINE INDENT limit = 9 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT new_tight = tight NEW_LINE if ( tight == 0 and i < limit ) : NEW_LINE INDENT new_tight = 1 NEW_LINE DEDENT res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len1 , k ) NEW_LINE res %= MOD NEW_LINE DEDENT if ( res < 0 ) : NEW_LINE INDENT res += MOD NEW_LINE DEDENT dp [ idx ] [ sum ] [ tight ] = res NEW_LINE return dp [ idx ] [ sum ] [ tight ] NEW_LINE DEDENT
def process ( s ) : NEW_LINE INDENT num = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT num . append ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return num NEW_LINE DEDENT
def maxLengthOf1s ( arr , n ) : NEW_LINE INDENT prefix = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i - 2 ] == 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = 0 NEW_LINE DEDENT DEDENT suffix = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i + 2 ] == 1 ) : NEW_LINE INDENT suffix [ i ] = suffix [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i ] = 0 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans = max ( ans , prefix [ i + 1 ] + suffix [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def MaxGCD ( a , n ) : NEW_LINE INDENT Prefix = [ 0 ] * ( n + 2 ) NEW_LINE Suffix = [ 0 ] * ( n + 2 ) NEW_LINE Prefix [ 1 ] = a [ 0 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT Prefix [ i ] = __gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) NEW_LINE DEDENT Suffix [ n ] = a [ n - 1 ] NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT Suffix [ i ] = __gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) NEW_LINE DEDENT ans = max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT ans = max ( ans , __gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def max_sum ( a , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE dp [ 0 ] [ 1 ] = - 999999 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) NEW_LINE DEDENT return dp [ n ] [ 0 ] NEW_LINE DEDENT
def sumOfProduct ( arr , n , k ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE cur_sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = arr [ i - 1 ] NEW_LINE cur_sum += arr [ i - 1 ] NEW_LINE DEDENT for i in range ( 2 , k + 1 ) : NEW_LINE INDENT temp_sum = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT cur_sum -= dp [ i - 1 ] [ j ] NEW_LINE dp [ i ] [ j ] = arr [ j - 1 ] * cur_sum NEW_LINE temp_sum += dp [ i ] [ j ] NEW_LINE DEDENT cur_sum = temp_sum NEW_LINE DEDENT return cur_sum NEW_LINE DEDENT
def number_of_ways ( arr , n , k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ - 1 ] * ( k + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ arr [ i ] ] = 0 NEW_LINE DEDENT dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 1 if ( dp [ 1 ] == - 1 ) else dp [ 1 ] NEW_LINE for i in range ( 2 , k + 1 ) : NEW_LINE INDENT if ( dp [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] NEW_LINE dp [ i ] %= MOD NEW_LINE DEDENT return dp [ k ] NEW_LINE DEDENT
def MinCost ( arr , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 5 ) ] for i in range ( n + 5 ) ] NEW_LINE sum = [ [ 0 for i in range ( n + 5 ) ] for i in range ( n + 5 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = arr [ i ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT sum [ i ] [ j ] = k NEW_LINE DEDENT else : NEW_LINE INDENT k += arr [ j ] NEW_LINE sum [ i ] [ j ] = k NEW_LINE DEDENT DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT dp [ i ] [ j ] = 10 ** 9 NEW_LINE if ( i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def findCount ( N ) : NEW_LINE INDENT list = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , 20 ) : NEW_LINE INDENT sum += 2 ** i NEW_LINE list . append ( sum ) NEW_LINE DEDENT for value in list : NEW_LINE INDENT if ( value >= N ) : NEW_LINE INDENT return ( list . index ( value ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def findMax ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if arr [ j ] % arr [ i ] == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT res = max ( count , res ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findMax ( arr , n ) : NEW_LINE INDENT divisible = [ False ] * n NEW_LINE res = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( divisible [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( ( arr [ j ] % arr [ i ] ) == 0 ) : NEW_LINE INDENT divisible [ j ] = True NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT res = max ( res , cnt ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findSetBits ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( count ( i ) , end = " " ) NEW_LINE DEDENT DEDENT
def findSetBits ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE print ( dp [ 0 ] , end = " " ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT dp [ i ] = dp [ i // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i // 2 ] + 1 NEW_LINE DEDENT print ( dp [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( not curr ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) NEW_LINE r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) NEW_LINE dp [ i ] [ curr ] = l NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) NEW_LINE DEDENT return dp [ i ] [ curr ] NEW_LINE DEDENT
def findCnt ( arr , i , required_sum , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( required_sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( v [ i ] [ required_sum + base ] ) : NEW_LINE INDENT return dp [ i ] [ required_sum + base ] NEW_LINE DEDENT v [ i ] [ required_sum + base ] = 1 NEW_LINE dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) NEW_LINE return dp [ i ] [ required_sum + base ] NEW_LINE DEDENT
def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return ( curr == m ) NEW_LINE DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr arr [ i ] ) , n , m ) NEW_LINE return dp [ i ] [ curr ] NEW_LINE DEDENT
def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return ( curr == m ) NEW_LINE DEDENT if ( v1 [ i ] [ curr ] ) : NEW_LINE INDENT return dp1 [ i ] [ curr ] NEW_LINE DEDENT v1 [ i ] [ curr ] = 1 NEW_LINE dp1 [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) NEW_LINE return dp1 [ i ] [ curr ] NEW_LINE DEDENT
def modulo_13 ( s , n ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , 13 ) ) NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT nxt = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( s [ i ] == '?' ) : NEW_LINE INDENT nxt = j NEW_LINE DEDENT for k in range ( 13 ) : NEW_LINE INDENT rem = ( 10 * k + nxt ) % 13 NEW_LINE dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] NEW_LINE dp [ i + 1 ] [ rem ] %= MOD NEW_LINE DEDENT if ( s [ i ] != '?' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return int ( dp [ n ] [ 5 ] ) NEW_LINE DEDENT
def f ( i , state , A , dp , N ) : NEW_LINE INDENT if i >= N : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif dp [ i ] [ state ] != - 1 : NEW_LINE INDENT return dp [ i ] [ state ] NEW_LINE DEDENT else : NEW_LINE INDENT if i == N - 1 : NEW_LINE INDENT dp [ i ] [ state ] = 1 NEW_LINE DEDENT elif state == 1 and A [ i ] > A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 NEW_LINE DEDENT elif state == 2 and A [ i ] < A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 NEW_LINE DEDENT elif state == 1 and A [ i ] <= A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 + f ( i + 1 , 2 , A , dp , N ) NEW_LINE DEDENT elif state == 2 and A [ i ] >= A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 + f ( i + 1 , 1 , A , dp , N ) NEW_LINE DEDENT return dp [ i ] [ state ] NEW_LINE DEDENT DEDENT
def maxLenSeq ( A , N ) : NEW_LINE INDENT dp = [ [ - 1 , - 1 , - 1 ] for i in range ( 1000 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT tmp = f ( i , 1 , A , dp , N ) NEW_LINE tmp = f ( i , 2 , A , dp , N ) NEW_LINE DEDENT ans = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT y = dp [ i ] [ 1 ] NEW_LINE if ( i + y ) >= N : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ 1 ] + 1 ) NEW_LINE DEDENT elif y % 2 == 0 : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 2 ] ) NEW_LINE DEDENT elif y % 2 == 1 : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 1 ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT a = [ ] NEW_LINE i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT a . append ( i ) NEW_LINE i += 1 NEW_LINE DEDENT ways = 0 NEW_LINE flag = 1 if ( per [ 0 ] == 1 ) else 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( abs ( per [ i ] - per [ i - 1 ] ) > 2 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT ways += 1 NEW_LINE DEDENT return ways NEW_LINE for per in list ( permutations ( a ) ) : NEW_LINE INDENT  DEDENT
def LISusingLCS ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE sortedseq = sorted ( seq ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ n ] [ n ] NEW_LINE DEDENT
def count_numbers ( k , n , flag ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT return ( k - 1 ) * ( count_numbers ( k , n - 1 , 0 ) + count_numbers ( k , n - 1 , 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return count_numbers ( k , n - 1 , 1 ) NEW_LINE DEDENT DEDENT
def count_numbers ( k , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = k - 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) NEW_LINE DEDENT return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] NEW_LINE DEDENT
def divideArray ( arr , n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 500 ) ] for i in range ( 500 ) ] NEW_LINE k -= 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 10 ** 9 NEW_LINE max_ = - 1 NEW_LINE summ = 0 NEW_LINE for l in range ( i , n ) : NEW_LINE INDENT max_ = max ( max_ , arr [ l ] ) NEW_LINE summ += arr [ l ] NEW_LINE diff = ( l - i + 1 ) * max_ - summ NEW_LINE if ( j > 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , diff + dp [ l + 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = diff NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ 0 ] [ k ] NEW_LINE DEDENT
def cntSubsets ( arr , n ) : NEW_LINE INDENT max = pow ( 2 , n ) NEW_LINE result = 0 NEW_LINE for i in range ( max ) : NEW_LINE INDENT counter = i NEW_LINE if ( counter & ( counter >> 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT result += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
def cntSubsets ( arr , n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE b = [ 0 ] * n NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT result = a [ n - 1 ] + b [ n - 1 ] NEW_LINE return result NEW_LINE DEDENT
def perfix_calculate ( A , row , col ) : NEW_LINE INDENT n = len ( A ) NEW_LINE m = len ( A [ 0 ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT row [ i ] [ 0 ] = A [ i ] [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , m ) : NEW_LINE INDENT row [ i ] [ j ] = row [ i ] [ j - 1 ] + A [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT col [ 0 ] [ i ] = A [ 0 ] [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( 1 , m ) : NEW_LINE INDENT col [ j ] [ i ] = A [ j ] [ i ] + col [ j - 1 ] [ i ] NEW_LINE DEDENT DEDENT DEDENT
def perimeter ( i , j , k , row , col , A ) : NEW_LINE INDENT row_s , col_s = 0 , 0 NEW_LINE if ( j == 0 ) : NEW_LINE INDENT row_s = 0 NEW_LINE DEDENT else : NEW_LINE INDENT row_s = row [ i ] [ j - 1 ] NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT col_s = 0 NEW_LINE DEDENT else : NEW_LINE INDENT col_s = col [ i - 1 ] [ j ] NEW_LINE DEDENT upper_row = row [ i ] [ j + k ] - row_s NEW_LINE left_col = col [ i + k ] [ j ] - col_s NEW_LINE if ( j == 0 ) : NEW_LINE INDENT row_s = 0 NEW_LINE DEDENT else : NEW_LINE INDENT row_s = row [ i + k ] [ j - 1 ] NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT col_s = 0 NEW_LINE DEDENT else : NEW_LINE INDENT col_s = col [ i - 1 ] [ j + k ] NEW_LINE DEDENT lower_row = row [ i + k ] [ j + k ] - row_s NEW_LINE right_col = col [ i + k ] [ j + k ] - col_s NEW_LINE sum = upper_row + lower_row + left_col + right_col NEW_LINE sum -= ( A [ i ] [ j ] + A [ i + k ] [ j ] + A [ i ] [ j + k ] + A [ i + k ] [ j + k ] ) NEW_LINE return sum NEW_LINE DEDENT
def maxPerimeter ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE m = len ( A [ 0 ] ) NEW_LINE row = [ [ 0 for i in range ( m ) ] for i in range ( n ) ] NEW_LINE col = [ [ 0 for i in range ( m ) ] for i in range ( n ) ] NEW_LINE perfix_calculate ( A , row , col ) NEW_LINE maxPer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT for k in range ( min ( n - i , m - j ) ) : NEW_LINE INDENT perimtr = perimeter ( i , j , k , row , col , A ) NEW_LINE maxPer = max ( maxPer , perimtr ) NEW_LINE DEDENT DEDENT DEDENT return maxPer NEW_LINE DEDENT
def mazeProb ( maze , xpos , ypos ) : NEW_LINE INDENT key = True NEW_LINE if findPath ( maze , xpos , ypos , key ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def ways ( i , arr , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT sum += ( ways ( i + j , arr , n ) ) % mod NEW_LINE sum %= mod NEW_LINE DEDENT DEDENT return int ( sum % mod ) NEW_LINE DEDENT
def minJumps ( arr , N ) : NEW_LINE INDENT fib = [ 0 for i in range ( 30 ) ] NEW_LINE fib [ 0 ] = 0 NEW_LINE fib [ 1 ] = 1 NEW_LINE for i in range ( 2 , 30 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DP = [ 0 for i in range ( N + 2 ) ] NEW_LINE DP [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 2 ) : NEW_LINE INDENT DP [ i ] = MAX NEW_LINE DEDENT for i in range ( 1 , N + 2 ) : NEW_LINE INDENT for j in range ( 1 , 30 ) : NEW_LINE INDENT if ( ( arr [ i - 1 ] == 1 or i == N + 1 ) and i - fib [ j ] >= 0 ) : NEW_LINE INDENT DP [ i ] = min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) NEW_LINE DEDENT DEDENT DEDENT if ( DP [ N + 1 ] != MAX ) : NEW_LINE INDENT return DP [ N + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def CountOfOddSum ( a , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( n ) ] NEW_LINE cnt = [ [ 0 for i in range ( 2 ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT if ( a [ i ] [ j ] % 2 == 0 ) : NEW_LINE INDENT cnt [ i ] [ 0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ i ] [ 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT dp [ 0 ] [ 0 ] = cnt [ 0 ] [ 0 ] NEW_LINE dp [ 0 ] [ 1 ] = cnt [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] * cnt [ i ] [ 0 ] + dp [ i - 1 ] [ 1 ] * cnt [ i ] [ 1 ] ) NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] * cnt [ i ] [ 1 ] + dp [ i - 1 ] [ 1 ] * cnt [ i ] [ 0 ] ) NEW_LINE DEDENT return dp [ n - 1 ] [ 1 ] NEW_LINE DEDENT
def recur ( ind , cnt , last , a , n , k , dp ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ind == n ) : NEW_LINE INDENT return - 10 ** 9 NEW_LINE DEDENT if ( dp [ ind ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( ind , n ) : NEW_LINE INDENT if ( cnt % 2 == 0 ) : NEW_LINE INDENT ans = max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , __gcd ( a [ last ] , a [ i ] ) + recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) NEW_LINE DEDENT DEDENT dp [ ind ] [ cnt ] = ans NEW_LINE return ans NEW_LINE DEDENT
def Max_Sum ( arr1 , arr2 , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = arr1 [ i ] NEW_LINE dp [ i ] [ 1 ] = arr2 [ i ] NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) NEW_LINE DEDENT DEDENT return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) NEW_LINE DEDENT
def maximizeSum ( a , n , ind , k , dp ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT if ( ind == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1e9 NEW_LINE DEDENT DEDENT elif ( ind == n ) : NEW_LINE INDENT return - 1e9 NEW_LINE DEDENT elif ( dp [ ind ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE mini = a [ ind ] NEW_LINE for i in range ( ind , n , 1 ) : NEW_LINE INDENT mini = min ( mini , a [ i ] ) NEW_LINE ans = max ( ans , maximizeSum ( a , n , i + 1 , k - 1 , dp ) + mini ) NEW_LINE DEDENT dp [ ind ] [ k ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT
def Partition ( arr , n , k ) : NEW_LINE INDENT prefix = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + arr [ i ] NEW_LINE DEDENT LOGS = 20 NEW_LINE ans = 0 NEW_LINE for i in range ( LOGS , - 1 , - 1 ) : NEW_LINE INDENT if ( checkpossible ( ans | ( 1 << i ) , arr , prefix , n , k ) ) : NEW_LINE INDENT ans = ans | ( 1 << i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def SieveOfEratosthenes ( MAX , primes ) : NEW_LINE INDENT prime = [ True ] * ( MAX + 1 ) NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p ** 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT primes . append ( i ) NEW_LINE DEDENT DEDENT DEDENT
def findLongest ( A , n ) : NEW_LINE INDENT mpp = { } NEW_LINE primes = [ ] NEW_LINE SieveOfEratosthenes ( A [ n - 1 ] , primes ) NEW_LINE dp = [ 0 ] * n NEW_LINE dp [ n - 1 ] = 1 NEW_LINE mpp [ A [ n - 1 ] ] = n - 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT num = A [ i ] NEW_LINE dp [ i ] = 1 NEW_LINE maxi = 0 NEW_LINE for it in primes : NEW_LINE INDENT xx = num * it NEW_LINE if ( xx > A [ n - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT elif xx in mpp : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , 1 + dp [ mpp [ xx ] ] ) NEW_LINE DEDENT DEDENT mpp [ A [ i ] ] = i NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def initialize ( ) : NEW_LINE INDENT for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( 1 , RODS + 1 ) : NEW_LINE INDENT for k in range ( 1 , RODS + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = sys . maxsize NEW_LINE DEDENT DEDENT DEDENT DEDENT
def mincost ( idx , src , dest , costs ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ src ] [ dest ] != sys . maxsize ) : NEW_LINE INDENT return dp [ idx ] [ src ] [ dest ] NEW_LINE DEDENT rem = 6 - ( src + dest ) NEW_LINE ans = sys . maxsize NEW_LINE case1 = costs [ src - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , rem , costs ) + mincost ( idx + 1 , rem , dest , costs ) NEW_LINE case2 = ( costs [ src - 1 ] [ rem - 1 ] + mincost ( idx + 1 , src , dest , costs ) + mincost ( idx + 1 , dest , src , costs ) + costs [ rem - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , dest , costs ) ) NEW_LINE ans = min ( case1 , case2 ) NEW_LINE dp [ idx ] [ src ] [ dest ] = ans NEW_LINE return ans NEW_LINE DEDENT
def MaxGCD ( a , n ) : NEW_LINE INDENT Prefix = [ 0 for i in range ( n + 2 ) ] NEW_LINE Suffix = [ 0 for i in range ( n + 2 ) ] NEW_LINE Prefix [ 1 ] = a [ 0 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT Prefix [ i ] = mt . gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) NEW_LINE DEDENT Suffix [ n ] = a [ n - 1 ] NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT Suffix [ i ] = mt . gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) NEW_LINE DEDENT ans = max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT ans = max ( ans , mt . gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def numToVec ( N ) : NEW_LINE INDENT digit = [ ] NEW_LINE while ( N != 0 ) : NEW_LINE INDENT digit . append ( N % 10 ) NEW_LINE N = N // 10 NEW_LINE DEDENT if ( len ( digit ) == 0 ) : NEW_LINE INDENT digit . append ( 0 ) NEW_LINE DEDENT digit = digit [ : : - 1 ] NEW_LINE return digit NEW_LINE DEDENT
def solve ( A , B , C ) : NEW_LINE INDENT d , d2 = 0 , 0 NEW_LINE digit = numToVec ( C ) NEW_LINE d = len ( A ) NEW_LINE if ( B > len ( digit ) or d == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( B < len ( digit ) ) : NEW_LINE INDENT if ( A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT return ( d - 1 ) * pow ( d , B - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( d , B ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp = [ 0 for i in range ( B + 1 ) ] NEW_LINE lower = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT lower [ A [ i ] + 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT lower [ i ] = lower [ i - 1 ] + lower [ i ] NEW_LINE DEDENT flag = True NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , B + 1 ) : NEW_LINE INDENT d2 = lower [ digit [ i - 1 ] ] NEW_LINE dp [ i ] = dp [ i - 1 ] * d NEW_LINE if ( i == 1 and A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT d2 = d2 - 1 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT dp [ i ] += d2 NEW_LINE DEDENT flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) NEW_LINE DEDENT return dp [ B ] NEW_LINE DEDENT DEDENT
def LongestConsSeq ( arr , N ) : NEW_LINE INDENT maxval = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT maxval = max ( maxval , arr [ i ] ) NEW_LINE DEDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( maxval + 1 ) ] NEW_LINE ans = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ arr [ i ] ] [ 0 ] = 1 + dp [ arr [ i ] - 1 ] [ 0 ] NEW_LINE if ( arr [ i ] >= 2 ) : NEW_LINE INDENT dp [ arr [ i ] ] [ 1 ] = max ( 1 + dp [ arr [ i ] - 1 ] [ 1 ] , 2 + dp [ arr [ i ] - 2 ] [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ arr [ i ] ] [ 1 ] = 1 NEW_LINE DEDENT ans = max ( ans , dp [ arr [ i ] ] [ 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def min ( p , q , r , s ) : NEW_LINE INDENT if ( p < q ) : NEW_LINE INDENT temp1 = p NEW_LINE DEDENT else : NEW_LINE INDENT temp1 = q NEW_LINE DEDENT if ( r < s ) : NEW_LINE INDENT temp2 = r NEW_LINE DEDENT else : NEW_LINE INDENT temp2 = s NEW_LINE DEDENT if ( temp1 < temp2 ) : NEW_LINE INDENT return temp1 NEW_LINE DEDENT return temp2 NEW_LINE DEDENT
def Distance ( arr , i , j ) : NEW_LINE INDENT if ( i >= R or j >= C or i < 0 or j < 0 ) : NEW_LINE INDENT return INT_MAX NEW_LINE DEDENT elif ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT table [ i ] [ j ] = INT_MAX NEW_LINE return INT_MAX NEW_LINE DEDENT elif ( arr [ i ] [ j ] == 2 ) : NEW_LINE INDENT table [ i ] [ j ] = 0 NEW_LINE return 0 NEW_LINE DEDENT elif ( visited [ i ] [ j ] ) : NEW_LINE INDENT return INT_MAX NEW_LINE DEDENT else : NEW_LINE INDENT visited [ i ] [ j ] = 1 NEW_LINE temp1 = Distance ( arr , i + 1 , j ) NEW_LINE temp2 = Distance ( arr , i - 1 , j ) NEW_LINE temp3 = Distance ( arr , i , j + 1 ) NEW_LINE temp4 = Distance ( arr , i , j - 1 ) NEW_LINE min_value = 1 + min ( temp1 , temp2 , temp3 , temp4 ) NEW_LINE if table [ i ] [ j ] > 0 and table [ i ] [ j ] < INT_MAX : NEW_LINE INDENT if min_value < table [ i ] [ j ] : NEW_LINE INDENT table [ i ] [ j ] = min_value NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT table [ i ] [ j ] = min_value NEW_LINE DEDENT visited [ i ] [ j ] = 0 NEW_LINE DEDENT return table [ i ] [ j ] NEW_LINE DEDENT
def minTime ( arr ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 1 ) : NEW_LINE INDENT Distance ( arr , i , j ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 1 and table [ i ] [ j ] > max ) : NEW_LINE INDENT max = table [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT if ( max < INT_MAX ) : NEW_LINE INDENT return max NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findDepthRec ( tree , n , index ) : NEW_LINE INDENT if ( index [ 0 ] >= n or tree [ index [ 0 ] ] == 'l' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT index [ 0 ] += 1 NEW_LINE left = findDepthRec ( tree , n , index ) NEW_LINE index [ 0 ] += 1 NEW_LINE right = findDepthRec ( tree , n , index ) NEW_LINE return ( max ( left , right ) + 1 ) NEW_LINE DEDENT
def findDepth ( tree , n ) : NEW_LINE INDENT index = [ 0 ] NEW_LINE return findDepthRec ( tree , n , index ) NEW_LINE DEDENT
def solve ( str1 , K ) : NEW_LINE INDENT N = len ( str1 ) NEW_LINE dp = [ [ - 1 for i in range ( K ) ] for i in range ( N ) ] NEW_LINE ans = solveUtil ( 0 , 0 , str1 , K , dp ) NEW_LINE if ans == 10 ** 9 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT
def solve ( Str , K ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE dp = [ [ 0 for i in range ( n ) ] for j in range ( K ) ] NEW_LINE if ( n < K ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( n == K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT zeroes = 0 NEW_LINE ones = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str [ i ] == '0' ) : NEW_LINE INDENT zeroes += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT dp [ 0 ] [ i ] = ones * zeroes NEW_LINE DEDENT for s in range ( 1 , K ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT dp [ s ] [ i ] = sys . maxsize NEW_LINE ones = 0 NEW_LINE zeroes = 0 NEW_LINE for k in range ( i , - 1 , - 1 ) : NEW_LINE INDENT if ( Str [ k ] == '0' ) : NEW_LINE INDENT zeroes += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT temp = 0 NEW_LINE if ( k - 1 >= 0 ) : NEW_LINE INDENT temp = ones * zeroes + dp [ s - 1 ] [ k - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT temp = sys . maxsize NEW_LINE DEDENT dp [ s ] [ i ] = min ( dp [ s ] [ i ] , temp ) NEW_LINE DEDENT DEDENT DEDENT if ( dp [ K - 1 ] [ n - 1 ] == sys . maxsize ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ K - 1 ] [ n - 1 ] NEW_LINE DEDENT DEDENT
def max_sum ( a , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE if ( n == 1 ) : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) NEW_LINE dp [ 1 ] = max ( a [ 1 ] , dp [ 0 ] ) NEW_LINE DEDENT elif ( n >= 3 ) : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) NEW_LINE dp [ 1 ] = max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) NEW_LINE dp [ 2 ] = max ( a [ 2 ] , max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) ) NEW_LINE i = 3 NEW_LINE while ( i < n ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def minCount ( K ) : NEW_LINE INDENT memo = [ 10 ** 9 for i in range ( 100 ) ] NEW_LINE memo [ 0 ] = 0 NEW_LINE for i in range ( 1 , 100 ) : NEW_LINE INDENT memo [ i ] = min ( memo [ i - 1 ] + 1 , memo [ i ] ) NEW_LINE DEDENT for i in range ( 10 , 100 ) : NEW_LINE INDENT memo [ i ] = min ( memo [ i - 10 ] + 1 , memo [ i ] ) NEW_LINE DEDENT for i in range ( 25 , 100 ) : NEW_LINE INDENT memo [ i ] = min ( memo [ i - 25 ] + 1 , memo [ i ] ) NEW_LINE DEDENT min_count = 0 NEW_LINE while ( K > 0 ) : NEW_LINE INDENT min_count += memo [ K % 100 ] NEW_LINE K //= 100 NEW_LINE DEDENT return min_count NEW_LINE DEDENT
def NoofWays ( face , throws , sum ) : NEW_LINE INDENT if ( sum == 0 and throws == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( sum < 0 or throws == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ throws ] [ sum ] != - 1 ) : NEW_LINE INDENT return dp [ throws ] [ sum ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , face + 1 ) : NEW_LINE INDENT ans += NoofWays ( face , throws - 1 , sum - i ) NEW_LINE DEDENT dp [ throws ] [ sum ] = ans NEW_LINE return ans NEW_LINE DEDENT
def solve ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for Len in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if i + Len >= n : NEW_LINE INDENT break NEW_LINE DEDENT j = i + Len NEW_LINE if ( i == 0 and j == n - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( s [ i ] != s [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT if ( i - 1 >= 0 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT if ( j + 1 <= n - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i ] [ j + 1 ] NEW_LINE DEDENT if ( i - 1 < 0 or j + 1 >= n ) : NEW_LINE INDENT dp [ i ] [ j ] += 1 NEW_LINE DEDENT DEDENT elif ( s [ i ] != s [ j ] ) : NEW_LINE INDENT if ( i - 1 >= 0 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT if ( j + 1 <= n - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i ] [ j + 1 ] NEW_LINE DEDENT if ( i - 1 >= 0 and j + 1 <= n - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] -= dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT ways = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 or i == n - 1 ) : NEW_LINE INDENT ways . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT total = dp [ i - 1 ] [ i + 1 ] NEW_LINE ways . append ( total ) NEW_LINE DEDENT DEDENT for i in ways : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def maxSum ( arr , i , n , k ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( visit [ i ] ) : NEW_LINE INDENT return dp [ i ] NEW_LINE DEDENT visit [ i ] = 1 NEW_LINE tot = 0 NEW_LINE dp [ i ] = maxSum ( arr , i + 1 , n , k ) NEW_LINE j = i NEW_LINE while ( j < i + k and j < n ) : NEW_LINE INDENT tot += arr [ j ] NEW_LINE dp [ i ] = max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) NEW_LINE j += 1 NEW_LINE DEDENT return dp [ i ] NEW_LINE DEDENT
def get_binary ( u ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( u ) : NEW_LINE INDENT rem = u % 10 NEW_LINE ans |= ( 1 << rem ) NEW_LINE u //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def waysutil ( index , sum , count , arr , K ) : NEW_LINE INDENT if ( index < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( index == 0 ) : NEW_LINE INDENT if ( count == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT remainder = sum % count NEW_LINE if ( remainder != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT average = sum // count NEW_LINE if ( average == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( dp [ index ] [ sum ] [ count ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ sum ] [ count ] NEW_LINE DEDENT dontpick = waysutil ( index - 1 , sum , count , arr , K ) NEW_LINE pick = waysutil ( index - 1 , sum + arr [ index ] , count + 1 , arr , K ) NEW_LINE total = pick + dontpick NEW_LINE dp [ index ] [ sum ] [ count ] = total NEW_LINE return total NEW_LINE DEDENT
def ways ( N , K , arr ) : NEW_LINE INDENT Arr = [ ] NEW_LINE Arr . append ( - 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT Arr . append ( arr [ i ] ) NEW_LINE DEDENT answer = waysutil ( N , 0 , 0 , Arr , K ) NEW_LINE return answer NEW_LINE DEDENT
def RetClose ( a , b , s ) : NEW_LINE INDENT if ( abs ( a - s ) < abs ( b - s ) ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT
def FindClose ( arr , n ) : NEW_LINE INDENT ans = inf NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = RetClose ( arr [ i - 1 ] + MinDiff ( i , arr [ i - 1 ] , arr , n ) , ans , 0 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def FindMax ( i , r , w , n , c , k ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ r ] ) : NEW_LINE INDENT return dp [ i ] [ r ] NEW_LINE DEDENT v [ i ] [ r ] = 1 NEW_LINE dp [ i ] [ r ] = FindMax ( i + 1 , r , w , n , c , k ) NEW_LINE for j in range ( k ) : NEW_LINE INDENT x = ( r // exp_c [ j ] ) % ( c + 1 ) NEW_LINE if ( x - w [ i ] >= 0 ) : NEW_LINE INDENT dp [ i ] [ r ] = max ( dp [ i ] [ r ] , w [ i ] + FindMax ( i + 1 , r - w [ i ] * exp_c [ j ] , w , n , c , k ) ) NEW_LINE DEDENT DEDENT return dp [ i ] [ r ] NEW_LINE DEDENT
def PreCompute ( n , c , k ) : NEW_LINE INDENT exp_c . append ( 1 ) NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT exp_c [ i ] = ( exp_c [ i - 1 ] * ( c + 1 ) ) NEW_LINE DEDENT R = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT R += exp_c [ i ] * c NEW_LINE DEDENT return R NEW_LINE DEDENT
def findMax ( i , r , w , n ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return INT_MIN NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ r ] ) : NEW_LINE INDENT return dp [ i ] [ r ] NEW_LINE DEDENT v [ i ] [ r ] = 1 NEW_LINE dp [ i ] [ r ] = max ( w [ i ] + findMax ( i + 1 , r - w [ i ] , w , n ) , findMax ( i + 1 , r , w , n ) ) NEW_LINE return dp [ i ] [ r ] NEW_LINE DEDENT
def preCompute ( w , n ) : NEW_LINE INDENT for i in range ( C_MAX , - 1 , - 1 ) : NEW_LINE INDENT findMax ( 0 , i , w , n ) NEW_LINE DEDENT DEDENT
def ansQuery ( w ) : NEW_LINE INDENT return dp [ 0 ] [ w ] NEW_LINE DEDENT
def minSum ( A , B , C , i , n , curr , dp ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ curr ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ curr ] NEW_LINE DEDENT if ( curr == 0 ) : NEW_LINE INDENT dp [ n ] [ curr ] = min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) NEW_LINE return dp [ n ] [ curr ] NEW_LINE DEDENT if ( curr == 1 ) : NEW_LINE INDENT dp [ n ] [ curr ] = min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) NEW_LINE return dp [ n ] [ curr ] NEW_LINE DEDENT dp [ n ] [ curr ] = min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) NEW_LINE return dp [ n ] [ curr ] NEW_LINE DEDENT
def findPrefixSum ( arr , n ) : NEW_LINE INDENT prefix_sum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix_sum [ i ] = arr [ i ] + prefix_sum [ i - 1 ] NEW_LINE DEDENT DEDENT
def maxSum ( arr , i , n , k ) : NEW_LINE INDENT if ( i + k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] ) : NEW_LINE INDENT return dp [ i ] NEW_LINE DEDENT v [ i ] = 1 NEW_LINE if ( i == 0 ) : NEW_LINE INDENT x = prefix_sum [ k - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT x = prefix_sum [ i + k - 1 ] - prefix_sum [ i - 1 ] NEW_LINE DEDENT dp [ i ] = max ( maxSum ( arr , i + 1 , n , k ) , x + maxSum ( arr , i + k + 1 , n , k ) ) NEW_LINE return dp [ i ] NEW_LINE DEDENT
def getChicks ( n ) : NEW_LINE INDENT size = max ( n , 7 ) NEW_LINE dp = [ 0 ] * size NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , 7 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] * 3 NEW_LINE DEDENT dp [ 6 ] = 726 NEW_LINE for i in range ( 8 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] - ( 2 * dp [ i - 6 ] // 3 ) ) * 3 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def getChicks ( n ) : NEW_LINE INDENT chicks = pow ( 3 , n - 1 ) NEW_LINE return chicks NEW_LINE DEDENT
def MaximumMarks ( marksarr , timearr , h , n , p ) : NEW_LINE INDENT no_of_topics = n + 1 NEW_LINE total_time = h + 1 NEW_LINE T = np . zeros ( ( no_of_topics , total_time ) ) NEW_LINE for i in range ( no_of_topics ) : NEW_LINE INDENT T [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( total_time ) : NEW_LINE INDENT T [ 0 ] [ j ] = 0 NEW_LINE DEDENT for i in range ( 1 , no_of_topics ) : NEW_LINE INDENT for j in range ( 1 , total_time ) : NEW_LINE INDENT if ( j < timearr [ i ] ) : NEW_LINE INDENT T [ i ] [ j ] = T [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ j ] = max ( marksarr [ i ] + T [ i - 1 ] [ j - timearr [ i ] ] , T [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT i = no_of_topics - 1 NEW_LINE j = total_time - 1 NEW_LINE sum = 0 NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( T [ i ] [ j ] == T [ i - 1 ] [ j ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += timearr [ i ] NEW_LINE j -= timearr [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT marks = T [ no_of_topics - 1 ] [ total_time - 1 ] NEW_LINE if ( marks < p ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findSum ( arr , n ) : NEW_LINE INDENT global sum NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT
def cntWays ( arr , i , ck , k , n , curr_sum ) : NEW_LINE INDENT if ( sum % k != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i != n and ck == k + 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT if ( ck == k + 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( v [ i ] [ ck ] ) : NEW_LINE INDENT return dp [ i ] [ ck ] NEW_LINE DEDENT curr_sum += arr [ i ] NEW_LINE v [ i ] [ ck ] = 1 NEW_LINE dp [ i ] [ ck ] = cntWays ( arr , i + 1 , ck , k , n , curr_sum ) NEW_LINE if ( curr_sum == ( sum / k ) * ck ) : NEW_LINE INDENT dp [ i ] [ ck ] += cntWays ( arr , i + 1 , ck + 1 , k , n , curr_sum ) NEW_LINE DEDENT return dp [ i ] [ ck ] NEW_LINE DEDENT
def SubsetCnt ( i , s , arr , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( s == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( visit [ i ] [ s + arrSize ] ) : NEW_LINE INDENT return dp [ i ] [ s + arrSize ] NEW_LINE DEDENT visit [ i ] [ s + arrSize ] = 1 NEW_LINE dp [ i ] [ s + arrSize ] = ( SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ) NEW_LINE return dp [ i ] [ s + arrSize ] NEW_LINE DEDENT
def sumMax ( i , arr , n ) : NEW_LINE INDENT if ( i >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] ) : NEW_LINE INDENT return dp [ i ] NEW_LINE DEDENT v [ i ] = True NEW_LINE dp [ i ] = max ( arr [ i ] + arr [ i + 1 ] + sumMax ( i + 3 , arr , n ) , sumMax ( i + 1 , arr , n ) ) NEW_LINE return dp [ i ] NEW_LINE DEDENT
def MaxIncreasingSub ( arr , n , k ) : NEW_LINE INDENT dp = [ - 1 ] * n NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = [ - 1 ] * ( k + 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT dp [ i ] [ 1 ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if arr [ j ] < arr [ i ] : NEW_LINE INDENT for l in range ( 1 , k ) : NEW_LINE INDENT if dp [ j ] [ l ] != - 1 : NEW_LINE INDENT dp [ i ] [ l + 1 ] = max ( dp [ i ] [ l + 1 ] , dp [ j ] [ l ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ans < dp [ i ] [ k ] : NEW_LINE INDENT ans = dp [ i ] [ k ] NEW_LINE DEDENT DEDENT return ( 0 if ans == - 1 else ans ) NEW_LINE DEDENT
def solve ( remSum , maxVal , idx , count ) : NEW_LINE INDENT if ( remSum == 0 ) : NEW_LINE INDENT print1 ( idx ) NEW_LINE count += 1 NEW_LINE return NEW_LINE DEDENT i = maxVal NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i > remSum ) : NEW_LINE INDENT i -= 1 NEW_LINE continue NEW_LINE DEDENT elif ( i <= remSum ) : NEW_LINE INDENT dp [ idx ] = i NEW_LINE solve ( remSum - i , i , idx + 1 , count ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT DEDENT
def findPrefixCount ( arr ) : NEW_LINE INDENT for i in range ( bitscount ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT prefix_count [ i ] [ j ] [ 0 ] = ( ( arr [ j ] [ 0 ] >> i ) & 1 ) NEW_LINE for k in range ( 1 , n ) : NEW_LINE INDENT prefix_count [ i ] [ j ] [ k ] = ( ( arr [ j ] [ k ] >> i ) & 1 ) NEW_LINE prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( bitscount ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j - 1 ] [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def rangeOr ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( bitscount ) : NEW_LINE INDENT if ( x1 == 0 and y1 == 0 ) : NEW_LINE INDENT p = prefix_count [ i ] [ x2 ] [ y2 ] NEW_LINE DEDENT elif ( x1 == 0 ) : NEW_LINE INDENT p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x2 ] [ y1 - 1 ] NEW_LINE DEDENT elif ( y1 == 0 ) : NEW_LINE INDENT p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x1 - 1 ] [ y2 ] NEW_LINE DEDENT else : NEW_LINE INDENT p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x1 - 1 ] [ y2 ] - prefix_count [ i ] [ x2 ] [ y1 - 1 ] + prefix_count [ i ] [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT if ( p != 0 ) : NEW_LINE INDENT ans = ( ans | ( 1 << i ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findPrefixCount ( arr ) : NEW_LINE INDENT for i in range ( bitscount ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT prefix_count [ i ] [ j ] [ 0 ] = ( ( arr [ j ] [ 0 ] >> i ) & 1 ) NEW_LINE for k in range ( 1 , n ) : NEW_LINE INDENT prefix_count [ i ] [ j ] [ k ] = ( ( arr [ j ] [ k ] >> i ) & 1 ) NEW_LINE prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( bitscount ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j - 1 ] [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findPrefixCount ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , bitscount ) : NEW_LINE INDENT prefix_count [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT prefix_count [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) NEW_LINE prefix_count [ i ] [ j ] += prefix_count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT
def rangeOr ( l , r ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( bitscount ) : NEW_LINE INDENT x = 0 NEW_LINE if ( l == 0 ) : NEW_LINE INDENT x = prefix_count [ i ] [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT x = prefix_count [ i ] [ r ] - prefix_count [ i ] [ l - 1 ] NEW_LINE DEDENT if ( x != 0 ) : NEW_LINE INDENT ans = ( ans | ( 1 << i ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def palindromeSubStrs ( s ) : NEW_LINE INDENT dp = np . zeros ( ( len ( s ) , len ( s ) ) ) NEW_LINE m = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT dp [ i ] [ i ] = 1 NEW_LINE m [ s [ i : i + 1 ] ] = 1 NEW_LINE DEDENT for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 1 NEW_LINE m [ s [ i : i + 2 ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 0 NEW_LINE DEDENT DEDENT for length in range ( 3 , len ( s ) + 1 ) : NEW_LINE INDENT for st in range ( len ( s ) - length + 1 ) : NEW_LINE INDENT end = st + length - 1 NEW_LINE if ( s [ st ] == s [ end ] and dp [ st + 1 ] [ end - 1 ] ) : NEW_LINE INDENT dp [ st ] [ end ] = 1 NEW_LINE m [ s [ st : end + 1 ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ st ] [ end ] = 0 NEW_LINE DEDENT DEDENT DEDENT return len ( m ) NEW_LINE DEDENT
def maxSum ( arr , i , n ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] ) : NEW_LINE INDENT return dp [ i ] NEW_LINE DEDENT v [ i ] = 1 NEW_LINE dp [ i ] = max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) NEW_LINE return dp [ i ] NEW_LINE DEDENT
def countWays ( i , j , x , arr ) : NEW_LINE INDENT if ( i == n or j == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x = ( x & arr [ i ] [ j ] ) NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( v [ i ] [ j ] [ x ] ) : NEW_LINE INDENT return dp [ i ] [ j ] [ x ] NEW_LINE DEDENT v [ i ] [ j ] [ x ] = 1 NEW_LINE dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) NEW_LINE return dp [ i ] [ j ] [ x ] NEW_LINE DEDENT
def minSteps ( i , j , arr ) : NEW_LINE INDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i > n - 1 or j > n - 1 ) : NEW_LINE INDENT return 9999999 NEW_LINE DEDENT if ( v [ i ] [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT v [ i ] [ j ] = 1 NEW_LINE dp [ i ] [ j ] = 9999999 NEW_LINE for k in range ( max ( 0 , arr [ i ] [ j ] + j - n + 1 ) , min ( n - i - 1 , arr [ i ] [ j ] ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) NEW_LINE DEDENT dp [ i ] [ j ] += 1 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT
def minSteps ( i , j , arr ) : NEW_LINE INDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i > n - 1 or j > n - 1 ) : NEW_LINE INDENT return 9999999 NEW_LINE DEDENT if ( v [ i ] [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT v [ i ] [ j ] = 1 NEW_LINE dp [ i ] [ j ] = 1 + min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT
def oSRec ( arr , i , j , Sum ) : NEW_LINE INDENT if ( j == i + 1 ) : NEW_LINE INDENT return max ( arr [ i ] , arr [ j ] ) NEW_LINE DEDENT return max ( ( Sum - oSRec ( arr , i + 1 , j , Sum - arr [ i ] ) ) , ( Sum - oSRec ( arr , i , j - 1 , Sum - arr [ j ] ) ) ) NEW_LINE DEDENT
def optimalStrategyOfGame ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE Sum = sum ( arr ) NEW_LINE return oSRec ( arr , 0 , n - 1 , Sum ) NEW_LINE DEDENT
def oSRec ( arr , i , j , Sum ) : NEW_LINE INDENT if ( j == i + 1 ) : NEW_LINE INDENT return max ( arr [ i ] , arr [ j ] ) NEW_LINE DEDENT if ( memo [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return memo [ i ] [ j ] NEW_LINE DEDENT memo [ i ] [ j ] = max ( ( Sum - oSRec ( arr , i + 1 , j , Sum - arr [ i ] ) ) , ( Sum - oSRec ( arr , i , j - 1 , Sum - arr [ j ] ) ) ) NEW_LINE return memo [ i ] [ j ] NEW_LINE DEDENT
def optimalStrategyOfGame ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE Sum = sum ( arr ) NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT for k in range ( MAX ) : NEW_LINE INDENT memo [ j ] [ k ] = - 1 NEW_LINE DEDENT DEDENT return oSRec ( arr , 0 , n - 1 , Sum ) NEW_LINE DEDENT
def number ( s , i , j ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( i , j ) : NEW_LINE INDENT ans = ans * 2 + ( ord ( s [ x ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minCuts ( s , n ) : NEW_LINE INDENT dp = [ n + 1 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT if ( s [ j ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT num = number ( s , j , i ) NEW_LINE if ( not ispower ( num ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i ] = min ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT if dp [ n ] < n + 1 : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def sum ( i1 , j1 , i2 , j2 ) : NEW_LINE INDENT if ( i1 == i2 and j1 == j2 ) : NEW_LINE INDENT return arr [ i1 ] [ j1 ] NEW_LINE DEDENT return arr [ i1 ] [ j1 ] + arr [ i2 ] [ j2 ] NEW_LINE DEDENT
def MinOfCubed ( k ) : NEW_LINE INDENT if ( k < 8 ) : NEW_LINE INDENT return k NEW_LINE DEDENT res = k NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ( i * i * i ) > k ) : NEW_LINE INDENT return res NEW_LINE DEDENT res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def MinOfCubedDP ( k ) : NEW_LINE INDENT DP = [ 0 ] * ( k + 1 ) NEW_LINE j = 1 NEW_LINE t = 1 NEW_LINE DP [ 0 ] = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT DP [ i ] = sys . maxsize NEW_LINE while ( j <= i ) : NEW_LINE INDENT if ( j == i ) : NEW_LINE INDENT DP [ i ] = 1 NEW_LINE DEDENT elif ( DP [ i ] > DP [ i - j ] ) : NEW_LINE INDENT DP [ i ] = DP [ i - j ] + 1 NEW_LINE DEDENT t += 1 NEW_LINE j = t * t * t NEW_LINE DEDENT t = j = 1 NEW_LINE DEDENT return DP [ k ] NEW_LINE DEDENT
def getMaximumSum ( a , n , x ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( 3 ) ] for j in range ( n ) ] NEW_LINE maxi = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT maxi = max ( maxi , func ( i , 0 , a , dp , n , x ) ) NEW_LINE DEDENT return maxi NEW_LINE DEDENT
def pre_process ( dp , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = False NEW_LINE DEDENT DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - j + 1 ) : NEW_LINE INDENT if ( j <= 2 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ i + j - 1 ] = True NEW_LINE DEDENT DEDENT elif ( s [ i ] == s [ i + j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countPairs ( s ) : NEW_LINE INDENT dp = [ [ False for i in range ( N ) ] for j in range ( N ) ] NEW_LINE pre_process ( dp , s ) NEW_LINE n = len ( s ) NEW_LINE left = [ 0 for i in range ( n ) ] NEW_LINE right = [ 0 for i in range ( n ) ] NEW_LINE left [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( dp [ j ] [ i ] == 1 ) : NEW_LINE INDENT left [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT right [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] NEW_LINE for j in range ( n - 1 , i - 1 , - 1 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] == 1 ) : NEW_LINE INDENT right [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans += left [ i ] * right [ i + 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def answerQuery ( l , r , dp ) : NEW_LINE INDENT if ( dp [ l ] [ r ] ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def LIS ( a , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE d = [ 0 for i in range ( N ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ a [ i ] ] = 1 NEW_LINE for j in range ( 2 , a [ i ] ) : NEW_LINE INDENT if j * j > a [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT if ( a [ i ] % j == 0 ) : NEW_LINE INDENT dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) NEW_LINE dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ a [ i ] // j ] ] + 1 ) NEW_LINE d [ j ] = a [ i ] NEW_LINE d [ a [ i ] // j ] = a [ i ] NEW_LINE DEDENT DEDENT ans = max ( ans , dp [ a [ i ] ] ) NEW_LINE d [ a [ i ] ] = a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' and s [ i - 1 ] == '1' and s [ i - 2 ] == '1' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT
def solve ( i , x , dp ) : NEW_LINE INDENT if ( i < 0 ) : NEW_LINE INDENT return x == 3 NEW_LINE DEDENT if ( dp [ i ] [ x ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ x ] NEW_LINE DEDENT dp [ i ] [ x ] = solve ( i - 1 , 0 , dp ) NEW_LINE dp [ i ] [ x ] += solve ( i - 1 , x + 1 , dp ) NEW_LINE return dp [ i ] [ x ] NEW_LINE DEDENT
def dfs ( u , p ) : NEW_LINE INDENT global ans NEW_LINE for i in range ( 0 , len ( g [ u ] ) ) : NEW_LINE INDENT v = g [ u ] [ i ] NEW_LINE if v != p : NEW_LINE INDENT dfs ( v , u ) NEW_LINE for i in range ( 0 , 22 ) : NEW_LINE INDENT a [ u ] [ i ] += a [ v ] [ i ] NEW_LINE DEDENT DEDENT DEDENT pp = 0 NEW_LINE for i in range ( 0 , 22 ) : NEW_LINE INDENT if ( not ( ( a [ u ] [ i ] > 0 and x [ i ] - a [ u ] [ i ] > 0 ) or ( a [ u ] [ i ] == 0 and x [ i ] == 0 ) ) ) : NEW_LINE INDENT pp = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if pp == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT
def findCount ( mat , i , j , m ) : NEW_LINE INDENT if ( i == 0 and j == 0 ) : NEW_LINE INDENT if ( m == mat [ 0 ] [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i < 0 or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ j ] [ m ] > 0 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT v [ i ] [ j ] [ m ] = True NEW_LINE dp [ i ] [ j ] [ m ] = ( findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ) NEW_LINE return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT
def maxSum ( arr , k , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return max ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE DEDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] = max ( arr [ i ] , dp [ i - 1 ] ) NEW_LINE DEDENT for i in range ( k + 1 , n ) : NEW_LINE INDENT dp [ i ] = max ( arr [ i ] , dp [ i - ( k + 1 ) ] + arr [ i ] ) NEW_LINE DEDENT max_element = max ( dp ) NEW_LINE return max_element NEW_LINE DEDENT
def precompute ( ) : NEW_LINE INDENT dp = [ - 1 for i in range ( maxn ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE v = [ 4 , 6 , 9 ] NEW_LINE for i in range ( 1 , maxn , 1 ) : NEW_LINE INDENT for k in range ( 3 ) : NEW_LINE INDENT j = v [ k ] NEW_LINE if ( i >= j and dp [ i - j ] != - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp NEW_LINE DEDENT
def CountWays ( r , b , l , R , B , W , dp ) : NEW_LINE INDENT if ( l > W ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( r > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( b == B and r == R ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( b == B ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ r ] [ b ] [ l ] != - 1 ) : NEW_LINE INDENT return dp [ r ] [ b ] [ l ] NEW_LINE DEDENT ans = 0 NEW_LINE ans += CountWays ( r , b + 1 , l , R , B , W , dp ) NEW_LINE ans = ans % mod NEW_LINE ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) NEW_LINE ans = ans % mod NEW_LINE ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) NEW_LINE ans = ans % mod NEW_LINE ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) NEW_LINE ans = ans % mod NEW_LINE ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) NEW_LINE ans = ans % mod NEW_LINE ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) NEW_LINE ans = ans % mod NEW_LINE ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) NEW_LINE ans = ans % mod NEW_LINE dp [ r ] [ b ] [ l ] = ans NEW_LINE return ans NEW_LINE DEDENT
def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ ind ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT
def minCostJumpsDP ( A , k ) : NEW_LINE INDENT size = len ( A ) NEW_LINE x = [ sys . maxsize ] * ( size ) NEW_LINE x [ 0 ] = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT j = i + 1 NEW_LINE while j < i + k + 1 and j < size : NEW_LINE INDENT x [ j ] = min ( x [ j ] , x [ i ] + abs ( A [ i ] - A [ j ] ) ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return x [ size - 1 ] NEW_LINE DEDENT
def FindMaximumSum ( ind , kon , a , b , c , n , dp ) : NEW_LINE INDENT if ind == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ ind ] [ kon ] != - 1 : NEW_LINE INDENT return dp [ ind ] [ kon ] NEW_LINE DEDENT ans = - 10 ** 9 + 5 NEW_LINE if kon == 0 : NEW_LINE INDENT ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) NEW_LINE ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) NEW_LINE DEDENT elif kon == 1 : NEW_LINE INDENT ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) NEW_LINE ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) NEW_LINE DEDENT elif kon == 2 : NEW_LINE INDENT ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) NEW_LINE ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) NEW_LINE DEDENT dp [ ind ] [ kon ] = ans NEW_LINE return ans NEW_LINE DEDENT
def isVowel ( x ) : NEW_LINE INDENT return ( x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' or x == 'A' or x == 'E' or x == 'I' or x == 'O' or x == 'U' ) NEW_LINE DEDENT
def findMinimumDeletion ( l , r , dp , s ) : NEW_LINE INDENT if l > r : NEW_LINE INDENT return 0 NEW_LINE DEDENT if l == r : NEW_LINE INDENT return 1 NEW_LINE DEDENT if dp [ l ] [ r ] != - 1 : NEW_LINE INDENT return dp [ l ] [ r ] NEW_LINE DEDENT res = 1 + findMinimumDeletion ( l + 1 , r , dp , s ) NEW_LINE for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if s [ l ] == s [ i ] : NEW_LINE INDENT res = min ( res , findMinimumDeletion ( l + 1 , i - 1 , dp , s ) + findMinimumDeletion ( i , r , dp , s ) ) NEW_LINE DEDENT DEDENT dp [ l ] [ r ] = res NEW_LINE return res NEW_LINE DEDENT
def noOfBinaryStrings ( N , k ) : NEW_LINE INDENT dp = [ 0 ] * 100002 NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT dp [ k ] = 2 NEW_LINE for i in range ( k + 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod NEW_LINE DEDENT return dp [ N ] NEW_LINE DEDENT
def answer ( n ) : NEW_LINE INDENT dp = [ 0 ] * 10 NEW_LINE prev = [ 0 ] * 10 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT dp [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT prev [ j ] = dp [ j ] NEW_LINE DEDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ j ] = prev [ j + 1 ] NEW_LINE DEDENT elif ( j == 9 ) : NEW_LINE INDENT dp [ j ] = prev [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT sum = sum + dp [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def MinimumCost ( a , n , x ) : NEW_LINE INDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT a [ i ] = min ( a [ i ] , 2 * a [ i - 1 ] ) NEW_LINE DEDENT ind = 0 NEW_LINE sum = 0 NEW_LINE while ( x ) : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT sum += a [ ind ] NEW_LINE DEDENT ind += 1 NEW_LINE x = x >> 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def dfs ( node , adj , dp , vis ) : NEW_LINE INDENT vis [ node ] = True NEW_LINE for i in range ( 0 , len ( adj [ node ] ) ) : NEW_LINE INDENT if not vis [ adj [ node ] [ i ] ] : NEW_LINE INDENT dfs ( adj [ node ] [ i ] , adj , dp , vis ) NEW_LINE DEDENT dp [ node ] = max ( dp [ node ] , 1 + dp [ adj [ node ] [ i ] ] ) NEW_LINE DEDENT DEDENT
def sieve_modified ( ) : NEW_LINE INDENT for i in range ( 2 , MAX , 2 ) : NEW_LINE INDENT for j in range ( i , MAX , i ) : NEW_LINE INDENT prefix [ j ] += i NEW_LINE DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT prefix [ i ] += prefix [ i - 1 ] NEW_LINE DEDENT DEDENT
def binomialCoeff ( n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findSubarraySum ( ind , flips , n , a , k ) : NEW_LINE INDENT if ( flips > k ) : NEW_LINE INDENT return - 1e9 NEW_LINE DEDENT if ( ind == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ ind ] [ flips ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] [ flips ] NEW_LINE DEDENT ans = 0 NEW_LINE ans = max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) NEW_LINE ans = max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) NEW_LINE dp [ ind ] [ flips ] = ans NEW_LINE return dp [ ind ] [ flips ] NEW_LINE DEDENT
def catalanDP ( n ) : NEW_LINE INDENT catalan [ 0 ] = catalan [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT
def CatalanSequence ( arr , n ) : NEW_LINE INDENT catalanDP ( n ) NEW_LINE s = set ( ) NEW_LINE a = 1 NEW_LINE b = 1 NEW_LINE s . add ( a ) NEW_LINE if ( n >= 2 ) : NEW_LINE INDENT s . add ( b ) NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT s . add ( catalan [ i ] ) NEW_LINE DEDENT temp = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in s : NEW_LINE INDENT temp . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT s = s - temp NEW_LINE return len ( s ) NEW_LINE DEDENT
def findSubsequence ( arr , n ) : NEW_LINE INDENT Len = 1 NEW_LINE tmp = 0 NEW_LINE i , j , d = 0 , 0 , 0 NEW_LINE dp = [ [ 0 for i in range ( 10 ) ] for i in range ( n ) ] NEW_LINE cnt = [ 0 for i in range ( 10 ) ] NEW_LINE locMax = 0 NEW_LINE tmp = arr [ 0 ] NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT dp [ 0 ] [ tmp % 10 ] = 1 NEW_LINE tmp //= 10 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] NEW_LINE locMax = 1 NEW_LINE cnt = [ 0 for i in range ( 10 ) ] NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 NEW_LINE tmp //= 10 NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ i ] [ d ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT dp [ i ] [ d ] = max ( dp [ i ] [ d ] , dp [ j ] [ d ] + 1 ) NEW_LINE locMax = max ( dp [ i ] [ d ] , locMax ) NEW_LINE DEDENT DEDENT DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ i ] [ d ] = locMax NEW_LINE DEDENT DEDENT Len = max ( Len , locMax ) NEW_LINE DEDENT return Len NEW_LINE DEDENT
def solve ( x ) : NEW_LINE INDENT global dp NEW_LINE num = [ ] NEW_LINE while x : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT num . reverse ( ) NEW_LINE dp = [ [ [ [ - 1 , - 1 ] for i in range ( 90 ) ] for j in range ( 90 ) ] for k in range ( M ) ] NEW_LINE return count ( 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT
def Add_edge ( x , y ) : NEW_LINE INDENT gr [ x ] . append ( y ) NEW_LINE gr [ y ] . append ( x ) NEW_LINE DEDENT
def dfs ( v , par ) : NEW_LINE INDENT global ans NEW_LINE d [ v ] [ 0 ] = 1 NEW_LINE for i in gr [ v ] : NEW_LINE INDENT if ( i != par ) : NEW_LINE INDENT dfs ( i , v ) NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT d [ v ] [ j ] += d [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def count ( pos , Sum , rem , tight , nonz , num ) : NEW_LINE INDENT if pos == len ( num ) : NEW_LINE INDENT if rem == 0 and Sum == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if dp [ pos ] [ Sum ] [ rem ] [ tight ] != - 1 : NEW_LINE INDENT return dp [ pos ] [ Sum ] [ rem ] [ tight ] NEW_LINE DEDENT ans = 0 NEW_LINE if tight : NEW_LINE INDENT limit = 9 NEW_LINE DEDENT else : NEW_LINE INDENT limit = num [ pos ] NEW_LINE DEDENT for d in range ( 0 , limit + 1 ) : NEW_LINE INDENT if d == 0 and nonz : NEW_LINE INDENT continue NEW_LINE DEDENT currSum = Sum + d NEW_LINE currRem = ( rem * 10 + d ) % m NEW_LINE currF = int ( tight or ( d < num [ pos ] ) ) NEW_LINE ans += count ( pos + 1 , currSum , currRem , currF , nonz or d , num ) NEW_LINE DEDENT dp [ pos ] [ Sum ] [ rem ] [ tight ] = ans NEW_LINE return ans NEW_LINE DEDENT
def findXorSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT c_odd = 0 NEW_LINE odd = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT odd = ( ~ odd ) NEW_LINE DEDENT if ( odd ) : NEW_LINE INDENT c_odd += 1 NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT Sum += ( mul * c_odd ) NEW_LINE if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT c_odd = ( n - j - c_odd ) NEW_LINE DEDENT DEDENT mul *= 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def preCompute ( ) : NEW_LINE INDENT lpd [ 0 ] , lpd [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , mt . ceil ( mt . sqrt ( MAX ) ) ) : NEW_LINE INDENT for j in range ( 2 * i , MAX , i ) : NEW_LINE INDENT if ( lpd [ j ] == 0 ) : NEW_LINE INDENT lpd [ j ] = i NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( lpd [ i ] == 0 ) : NEW_LINE INDENT lpd [ i ] = i NEW_LINE DEDENT DEDENT DEDENT
def maxLengthSubsequence ( arr , n ) : NEW_LINE INDENT dp = [ 1 for i in range ( N + 1 ) ] NEW_LINE pos = dict ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( arr [ i ] > 1 ) : NEW_LINE INDENT p = lpd [ arr [ i ] ] NEW_LINE if ( p in pos . keys ( ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , 1 + dp [ pos [ p ] ] ) NEW_LINE DEDENT pos [ p ] = i NEW_LINE while ( arr [ i ] % p == 0 ) : NEW_LINE INDENT arr [ i ] //= p NEW_LINE DEDENT DEDENT DEDENT ans = 1 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def charVal ( s , i ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( s [ i ] == '1' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT
def getSum ( r1 , r2 , c1 , c2 , dp ) : NEW_LINE INDENT return dp [ r2 ] [ c2 ] - dp [ r2 ] [ c1 ] - dp [ r1 ] [ c2 ] + dp [ r1 ] [ c1 ] NEW_LINE DEDENT
def sumFound ( K , S , grid ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = dp [ i + 1 ] [ j ] + dp [ i ] [ j + 1 ] - dp [ i ] [ j ] + grid [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT sum = getSum ( i , i + K , j , j + K , dp ) NEW_LINE if ( sum == S ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def totalSubSets ( n , l , r ) : NEW_LINE INDENT MOD = 1000000007 NEW_LINE zero = ( math . floor ( r / 3 ) - math . ceil ( l / 3 ) + 1 ) NEW_LINE one = ( math . floor ( ( r - 1 ) / 3 ) - math . ceil ( ( l - 1 ) / 3 ) + 1 ) NEW_LINE two = ( math . floor ( ( r - 2 ) / 3 ) - math . ceil ( ( l - 2 ) / 3 ) + 1 ) NEW_LINE dp = [ [ 0 for x in range ( 3 ) ] for y in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = zero NEW_LINE dp [ 0 ] [ 1 ] = one NEW_LINE dp [ 0 ] [ 2 ] = two NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( ( dp [ i - 1 ] [ 0 ] * zero ) + ( dp [ i - 1 ] [ 1 ] * two ) + ( dp [ i - 1 ] [ 2 ] * one ) ) % MOD NEW_LINE dp [ i ] [ 1 ] = ( ( dp [ i - 1 ] [ 0 ] * one ) + ( dp [ i - 1 ] [ 1 ] * zero ) + ( dp [ i - 1 ] [ 2 ] * two ) ) % MOD NEW_LINE dp [ i ] [ 2 ] = ( ( dp [ i - 1 ] [ 0 ] * two ) + ( dp [ i - 1 ] [ 1 ] * one ) + ( dp [ i - 1 ] [ 2 ] * zero ) ) % MOD NEW_LINE DEDENT return dp [ n - 1 ] [ 0 ] NEW_LINE DEDENT
def solve ( idx , diff , N , M , K ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT if ( diff == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ diff ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] NEW_LINE DEDENT ans = solve ( idx + 1 , diff , N , M , K ) NEW_LINE ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) NEW_LINE dp [ idx ] [ diff ] = ans % MOD NEW_LINE return dp [ idx ] [ diff ] NEW_LINE DEDENT
def maxPathSum ( tri ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , N - i ) : NEW_LINE INDENT if ( j - 1 >= 0 ) : NEW_LINE INDENT tri [ i ] [ j ] += max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT ans = max ( ans , tri [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << int ( log2 ( max_ele ) + 1 ) ) - 1 NEW_LINE dp = [ [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] for k in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def calcProbability ( M , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( m ) ] NEW_LINE Sum = [ 0 for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ j ] = M [ 0 ] [ j ] NEW_LINE Sum [ 0 ] += dp [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += ( dp [ i - 1 ] [ j ] / Sum [ i - 1 ] + M [ i ] [ j ] ) NEW_LINE Sum [ i ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ k - 1 ] / Sum [ n - 1 ] NEW_LINE DEDENT
def MaximumNumbers ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE remIndex = [ - 1 for i in range ( 3 ) ] NEW_LINE remIndex [ 0 ] = 0 NEW_LINE res = [ - 1 for i in range ( n + 1 ) ] NEW_LINE r = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT r = ( r + ord ( string [ i - 1 ] ) - ord ( '0' ) ) % 3 NEW_LINE res [ i ] = res [ i - 1 ] NEW_LINE if ( remIndex [ r ] != - 1 ) : NEW_LINE INDENT res [ i ] = max ( res [ i ] , res [ remIndex [ r ] ] + 1 ) NEW_LINE DEDENT remIndex [ r ] = i + 1 NEW_LINE DEDENT return res [ n ] NEW_LINE DEDENT
def get_max_splits ( num_string ) : NEW_LINE INDENT count = 0 NEW_LINE running_sum = 0 NEW_LINE for i in range ( len ( num_string ) ) : NEW_LINE INDENT current_num = int ( num_string [ i ] ) NEW_LINE running_sum += current_num NEW_LINE if current_num % 3 == 0 or ( running_sum != 0 and running_sum % 3 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE running_sum = 0 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findMinimumSteps ( mat , x , y , n ) : NEW_LINE INDENT dist = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE i , j , k = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 0 ) : NEW_LINE INDENT dist [ i ] [ j ] = INF NEW_LINE DEDENT else : NEW_LINE INDENT dist [ i ] [ j ] = 1 NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT dist [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for k in range ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) : NEW_LINE INDENT dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( dist [ x ] [ y ] < INF ) : NEW_LINE INDENT return dist [ x ] [ y ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def findmatch ( mat , pat , x , y , nrow , ncol , level ) : NEW_LINE INDENT l = len ( pat ) NEW_LINE if ( level == l ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( x < 0 or y < 0 or x >= nrow or y >= ncol ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( mat [ x ] [ y ] == pat [ level ] ) : NEW_LINE INDENT temp = mat [ x ] [ y ] NEW_LINE mat [ x ] . replace ( mat [ x ] [ y ] , '#' ) NEW_LINE res = ( findmatch ( mat , pat , x - 1 , y , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x + 1 , y , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x , y - 1 , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x , y + 1 , nrow , ncol , level + 1 ) ) NEW_LINE mat [ x ] . replace ( mat [ x ] [ y ] , temp ) NEW_LINE return res NEW_LINE return False NEW_LINE DEDENT DEDENT
def checkMatch ( mat , pat , nrow , ncol ) : NEW_LINE INDENT l = len ( pat ) NEW_LINE if ( l > nrow * ncol ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( nrow ) : NEW_LINE INDENT for j in range ( ncol ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == pat [ 0 ] ) : NEW_LINE INDENT if ( findmatch ( mat , pat , i , j , nrow , ncol , 0 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def countPaths ( Sum , get , m , n , dp ) : NEW_LINE INDENT if ( Sum < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( Sum == 0 ) : NEW_LINE INDENT return get NEW_LINE DEDENT if ( dp [ Sum ] [ get ] != - 1 ) : NEW_LINE INDENT return dp [ Sum ] [ get ] NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i == m ) : NEW_LINE INDENT res += countPaths ( Sum - i , 1 , m , n , dp ) NEW_LINE res += countPaths ( Sum - i , get , m , n , dp ) NEW_LINE DEDENT DEDENT dp [ Sum ] [ get ] = res NEW_LINE return dp [ Sum ] [ get ] NEW_LINE DEDENT
def countInRange ( x ) : NEW_LINE INDENT global dp , K , M NEW_LINE num = [ ] NEW_LINE while x : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT num . reverse ( ) NEW_LINE dp = [ [ [ - 1 , - 1 ] for i in range ( M ) ] for j in range ( M ) ] NEW_LINE return countInRangeUtil ( 0 , 0 , 0 , num ) NEW_LINE DEDENT
def solve ( x ) : NEW_LINE INDENT global dp , K , d NEW_LINE num = [ ] NEW_LINE while x : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT num . reverse ( ) NEW_LINE dp = [ [ [ [ - 1 , - 1 ] for i in range ( 2 ) ] for j in range ( M ) ] for k in range ( M ) ] NEW_LINE return count ( 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT
def bin ( a , b ) : NEW_LINE INDENT ans = fac [ a ] // ( fac [ a - b ] * fac [ b ] ) NEW_LINE return ans NEW_LINE DEDENT
def sumofn ( n , k ) : NEW_LINE INDENT p = 0 NEW_LINE num1 , temp = 1 , 1 NEW_LINE arr = [ 1 for i in range ( 1000 ) ] NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if j == 1 : NEW_LINE INDENT num1 = ( n * ( n + 1 ) ) // 2 NEW_LINE arr [ p ] = num1 NEW_LINE p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp = pow ( n + 1 , j + 1 ) - 1 - n NEW_LINE for s in range ( 1 , j ) : NEW_LINE INDENT temp = temp - ( arr [ j - s - 1 ] * bin ( j + 1 , s + 1 ) ) NEW_LINE DEDENT temp = temp // ( j + 1 ) NEW_LINE arr [ p ] = temp NEW_LINE p += 1 NEW_LINE DEDENT DEDENT temp = arr [ p - 1 ] NEW_LINE return temp NEW_LINE DEDENT
def findMinOperations ( S ) : NEW_LINE INDENT S = S [ : : - 1 ] NEW_LINE n = len ( S ) NEW_LINE dp = [ [ 0 ] * 2 ] * ( n + 1 ) NEW_LINE if ( S [ 0 ] == '0' ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT dp [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = 1 + min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 0 ] = 1 + min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ 0 ] NEW_LINE DEDENT
def solve ( x ) : NEW_LINE INDENT ans , temp = 0 , x NEW_LINE if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT last = x % 10 NEW_LINE while ( x ) : NEW_LINE INDENT first = x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT if ( first <= last ) : NEW_LINE INDENT ans = 9 + temp // 10 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 8 + temp // 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findMinimumCost ( n , x , y ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] = x NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i & 1 : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) // 2 ] + y + x ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + x , dp [ i // 2 ] + y ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def countWays ( index , cnt , dp , n , m , k ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ index ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE ans += countWays ( index + 1 , cnt , dp , n , m , k ) NEW_LINE ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) NEW_LINE dp [ index ] [ cnt ] = ans NEW_LINE return dp [ index ] [ cnt ] NEW_LINE DEDENT
def findMinSteps ( mat , n , m , dp , vis ) : NEW_LINE INDENT if ( n == 0 or m == 0 or n == ( r - 1 ) or m == ( col - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ m ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ m ] NEW_LINE DEDENT vis [ n ] [ m ] = True NEW_LINE ans1 , ans2 , ans3 , ans4 = 10 ** 9 , 10 ** 9 , 10 ** 9 , 10 ** 9 NEW_LINE if ( mat [ n - 1 ] [ m ] == 0 ) : NEW_LINE INDENT if ( vis [ n - 1 ] [ m ] == False ) : NEW_LINE INDENT ans1 = 1 + findMinSteps ( mat , n - 1 , m , dp , vis ) NEW_LINE DEDENT DEDENT if ( mat [ n ] [ m + 1 ] == 0 ) : NEW_LINE INDENT if ( vis [ n ] [ m + 1 ] == False ) : NEW_LINE INDENT ans2 = 1 + findMinSteps ( mat , n , m + 1 , dp , vis ) NEW_LINE DEDENT DEDENT if ( mat [ n ] [ m - 1 ] == 0 ) : NEW_LINE INDENT if ( vis [ n ] [ m - 1 ] == False ) : NEW_LINE INDENT ans3 = 1 + findMinSteps ( mat , n , m - 1 , dp , vis ) NEW_LINE DEDENT DEDENT if ( mat [ n + 1 ] [ m ] == 0 ) : NEW_LINE INDENT if ( vis [ n + 1 ] [ m ] == False ) : NEW_LINE INDENT ans4 = 1 + findMinSteps ( mat , n + 1 , m , dp , vis ) NEW_LINE DEDENT DEDENT dp [ n ] [ m ] = min ( ans1 , min ( ans2 , min ( ans3 , ans4 ) ) ) NEW_LINE return dp [ n ] [ m ] NEW_LINE DEDENT
def minimumSteps ( mat , n , m ) : NEW_LINE INDENT twox = - 1 NEW_LINE twoy = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 2 ) : NEW_LINE INDENT twox = i NEW_LINE twoy = j NEW_LINE break NEW_LINE DEDENT DEDENT if ( twox != - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp = [ [ - 1 for i in range ( col ) ] for i in range ( r ) ] NEW_LINE vis = [ [ False for i in range ( col ) ] for i in range ( r ) ] NEW_LINE res = findMinSteps ( mat , twox , twoy , dp , vis ) NEW_LINE if ( res >= 10 ** 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT
def nCr ( n , r ) : NEW_LINE INDENT ans = 1 NEW_LINE if r > n - r : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT ans *= ( n - i ) NEW_LINE ans /= ( i + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countDerangements ( n ) : NEW_LINE INDENT der = [ 0 for i in range ( n + 3 ) ] NEW_LINE der [ 0 ] = 1 NEW_LINE der [ 1 ] = 0 NEW_LINE der [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) NEW_LINE DEDENT return der [ n ] NEW_LINE DEDENT
def countPermutations ( n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - k , n + 1 ) : NEW_LINE INDENT ways = nCr ( n , i ) NEW_LINE ans += ways * countDerangements ( n - i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def solve ( dp , wt , K , M , used ) : NEW_LINE INDENT if ( wt < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt == 0 ) : NEW_LINE INDENT if ( used ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ wt ] [ used ] != - 1 ) : NEW_LINE INDENT return dp [ wt ] [ used ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( i >= M ) : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used ) NEW_LINE DEDENT DEDENT dp [ wt ] [ used ] = ans NEW_LINE return ans NEW_LINE DEDENT
def squares ( i ) : NEW_LINE INDENT if ( ( i & 1 ) == 1 ) : NEW_LINE INDENT return int ( i / 4 ) * 2 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return int ( ( i - 1 ) / 4 ) * 2 + 2 NEW_LINE DEDENT DEDENT
def bishop_placements ( n , k ) : NEW_LINE INDENT if ( k > 2 * n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n * 2 ) ] NEW_LINE for i in range ( n * 2 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT dp [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n * 2 , 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 , 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 2 ] [ j ] + dp [ i - 2 ] [ j - 1 ] * ( squares ( i ) - j + 1 ) ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 0 , k + 1 , 1 ) : NEW_LINE INDENT ans += ( dp [ n * 2 - 1 ] [ i ] * dp [ n * 2 - 2 ] [ k - i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sumOddFibonacci ( n ) : NEW_LINE INDENT Sum = [ 0 ] * ( n + 1 ) NEW_LINE Sum [ 0 ] = 0 NEW_LINE Sum [ 1 ] = 1 NEW_LINE Sum [ 2 ] = 2 NEW_LINE Sum [ 3 ] = 5 NEW_LINE Sum [ 4 ] = 10 NEW_LINE Sum [ 5 ] = 23 NEW_LINE for i in range ( 6 , n + 1 ) : NEW_LINE INDENT Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod NEW_LINE DEDENT return Sum [ n ] NEW_LINE DEDENT
def noOfAssignments ( S , n , i , c_x , c_y ) : NEW_LINE INDENT if F [ i ] [ c_x ] [ c_y ] != - 1 : NEW_LINE INDENT return F [ i ] [ c_x ] [ c_y ] NEW_LINE DEDENT if i == n : NEW_LINE INDENT F [ i ] [ c_x ] [ c_y ] = not c_x and not c_y NEW_LINE return F [ i ] [ c_x ] [ c_y ] NEW_LINE DEDENT if S [ i ] == '(' : NEW_LINE INDENT F [ i ] [ c_x ] [ c_y ] = noOfAssignments ( S , n , i + 1 , c_x + 1 , c_y ) + noOfAssignments ( S , n , i + 1 , c_x , c_y + 1 ) NEW_LINE return F [ i ] [ c_x ] [ c_y ] NEW_LINE DEDENT F [ i ] [ c_x ] [ c_y ] = 0 NEW_LINE if c_x : NEW_LINE INDENT F [ i ] [ c_x ] [ c_y ] += noOfAssignments ( S , n , i + 1 , c_x - 1 , c_y ) NEW_LINE DEDENT if c_y : NEW_LINE INDENT F [ i ] [ c_x ] [ c_y ] += noOfAssignments ( S , n , i + 1 , c_x , c_y - 1 ) NEW_LINE DEDENT return F [ i ] [ c_x ] [ c_y ] NEW_LINE DEDENT
def noOfAssignments ( S , n , i , c_x ) : NEW_LINE INDENT if F [ i ] [ c_x ] != - 1 : NEW_LINE INDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if i == n : NEW_LINE INDENT F [ i ] [ c_x ] = not c_x NEW_LINE return F [ i ] [ c_x ] NEW_LINE DEDENT c_y = C [ i ] - c_x NEW_LINE if S [ i ] == '(' : NEW_LINE INDENT F [ i ] [ c_x ] = noOfAssignments ( S , n , i + 1 , c_x + 1 ) + noOfAssignments ( S , n , i + 1 , c_x ) NEW_LINE return F [ i ] [ c_x ] NEW_LINE DEDENT F [ i ] [ c_x ] = 0 NEW_LINE if c_x : NEW_LINE INDENT F [ i ] [ c_x ] += noOfAssignments ( S , n , i + 1 , c_x - 1 ) NEW_LINE DEDENT if c_y : NEW_LINE INDENT F [ i ] [ c_x ] += noOfAssignments ( S , n , i + 1 , c_x ) NEW_LINE DEDENT return F [ i ] [ c_x ] NEW_LINE DEDENT
def MaxProfit ( treasure , color , n , k , col , A , B ) : NEW_LINE INDENT sum = 0 NEW_LINE if k == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if col == color [ k ] : NEW_LINE INDENT sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def calculateEvenSum ( n ) : NEW_LINE INDENT if n <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( 2 * n + 1 ) NEW_LINE fibo [ 0 ] , fibo [ 1 ] = 0 , 1 NEW_LINE sum = 0 NEW_LINE for i in range ( 2 , 2 * n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT sum += fibo [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return f [ n ] NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = ( n + 1 ) // 2 if ( n % 2 == 1 ) else n // 2 NEW_LINE f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) if ( n % 2 == 1 ) else ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE return f [ n ] NEW_LINE DEDENT
def calculateEvenSum ( n ) : NEW_LINE INDENT return ( fib ( 2 * n + 1 ) - 1 ) NEW_LINE DEDENT
def find ( index , openbrk , n , adj ) : NEW_LINE INDENT if ( openbrk < 0 ) : NEW_LINE INDENT return MAX_VAL NEW_LINE DEDENT if ( index == n ) : NEW_LINE INDENT if ( openbrk == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return MAX_VAL NEW_LINE DEDENT DEDENT if ( dp [ index ] [ openbrk ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ openbrk ] NEW_LINE DEDENT dp [ index ] [ openbrk ] = min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) NEW_LINE return dp [ index ] [ openbrk ] NEW_LINE DEDENT
def gouldSequence ( n ) : NEW_LINE INDENT for row_num in range ( 1 , n ) : NEW_LINE INDENT count = 1 NEW_LINE c = 1 NEW_LINE for i in range ( 1 , row_num ) : NEW_LINE INDENT c = c * ( row_num - i ) / i NEW_LINE if ( c % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " " ) NEW_LINE DEDENT DEDENT
def gouldSequence ( ) : NEW_LINE INDENT arr [ 0 ] = 1 NEW_LINE i = 1 NEW_LINE p = 1 NEW_LINE while i <= MAX : NEW_LINE INDENT j = 0 NEW_LINE while j < i : NEW_LINE INDENT arr [ i + j ] = 2 * arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT i = ( 1 << p ) NEW_LINE p += 1 NEW_LINE DEDENT DEDENT
def printSequence ( n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def minFallingPathSum ( A ) : NEW_LINE INDENT for R in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for C in range ( n ) : NEW_LINE INDENT best = A [ R + 1 ] [ C ] NEW_LINE if C > 0 : NEW_LINE INDENT best = min ( best , A [ R + 1 ] [ C - 1 ] ) NEW_LINE DEDENT if C + 1 < n : NEW_LINE INDENT best = min ( best , A [ R + 1 ] [ C + 1 ] ) NEW_LINE DEDENT A [ R ] [ C ] = A [ R ] [ C ] + best NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = min ( ans , A [ 0 ] [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxPlus ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE left = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE right = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE up = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE down = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT left [ i ] [ j ] = ( max ( 0 , ( left [ i ] [ j - 1 ] if j else 0 ) ) + arr [ i ] [ j ] ) NEW_LINE up [ i ] [ j ] = ( max ( 0 , ( up [ i - 1 ] [ j ] if i else 0 ) ) + arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT right [ i ] [ j ] = max ( 0 , ( 0 if ( j + 1 == m ) else right [ i ] [ j + 1 ] ) ) + arr [ i ] [ j ] NEW_LINE down [ i ] [ j ] = max ( 0 , ( 0 if ( i + 1 == n ) else down [ i + 1 ] [ j ] ) ) + arr [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT for j in range ( 1 , m - 1 ) : NEW_LINE INDENT ans = max ( ans , up [ i - 1 ] [ j ] + down [ i + 1 ] [ j ] + left [ i ] [ j - 1 ] + right [ i ] [ j + 1 ] + arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def fun ( marks , n ) : NEW_LINE INDENT dp = [ 1 for i in range ( 0 , n ) ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if marks [ i ] > marks [ i + 1 ] : NEW_LINE INDENT temp = i NEW_LINE while True : NEW_LINE INDENT if marks [ temp ] > marks [ temp + 1 ] and temp >= 0 : NEW_LINE INDENT if dp [ temp ] > dp [ temp + 1 ] : NEW_LINE INDENT temp -= 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT dp [ temp ] = dp [ temp + 1 ] + 1 NEW_LINE temp -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT elif marks [ i ] < marks [ i + 1 ] : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] + 1 NEW_LINE DEDENT DEDENT return ( sum ( dp ) ) NEW_LINE DEDENT
def getNumberOfWays ( N , Coins ) : NEW_LINE INDENT ways = [ 0 ] * ( N + 1 ) NEW_LINE ways [ 0 ] = 1 NEW_LINE for i in range ( len ( Coins ) ) : NEW_LINE INDENT for j in range ( len ( ways ) ) : NEW_LINE INDENT if ( Coins [ i ] <= j ) : NEW_LINE INDENT ways [ j ] += ways [ ( int ) ( j - Coins [ i ] ) ] NEW_LINE DEDENT DEDENT DEDENT return ways [ N ] NEW_LINE DEDENT
def countStaircases ( N ) : NEW_LINE INDENT memo = [ [ 0 for x in range ( N + 5 ) ] for y in range ( N + 5 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT memo [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT memo [ 3 ] [ 2 ] = memo [ 4 ] [ 2 ] = 1 NEW_LINE for i in range ( 5 , N + 1 ) : NEW_LINE INDENT for j in range ( 2 , i + 1 ) : NEW_LINE INDENT if ( j == 2 ) : NEW_LINE INDENT memo [ i ] [ j ] = memo [ i - j ] [ j ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT memo [ i ] [ j ] = ( memo [ i - j ] [ j ] + memo [ i - j ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT answer = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT answer = answer + memo [ N ] [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT
def partitions ( n ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE p [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) : NEW_LINE INDENT p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) // 2 ] ) NEW_LINE if ( k > 0 ) : NEW_LINE INDENT k *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 - k NEW_LINE DEDENT DEDENT DEDENT return p [ n ] NEW_LINE DEDENT
def find ( m , n , adj ) : NEW_LINE INDENT sweet = [ 0 ] * ( n + 1 ) NEW_LINE dp = [ [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE sweet [ 0 ] = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT sweet [ i ] = adj [ i - 1 ] NEW_LINE DEDENT for i in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] [ k ] = 0 NEW_LINE DEDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ k ] [ 0 ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = - 1 NEW_LINE if ( i > 0 and j >= k and sweet [ k ] > 0 and dp [ i - 1 ] [ j - k ] [ k ] != - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j - k ] [ k ] + sweet [ k ] NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] == - 1 or ( dp [ i ] [ j ] [ k - 1 ] != - 1 and dp [ i ] [ j ] [ k ] > dp [ i ] [ j ] [ k - 1 ] ) ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i ] [ j ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( dp [ m ] [ n ] [ n ] == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ m ] [ n ] [ n ] NEW_LINE DEDENT DEDENT
def find_min_odd_cost ( given , m , n ) : NEW_LINE INDENT floor = [ [ 0 for i in range ( M ) ] for i in range ( N ) ] NEW_LINE min_odd_cost = 0 NEW_LINE i , j , temp = 0 , 0 , 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT floor [ 0 ] [ j ] = given [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT floor [ i ] [ j ] = given [ i ] [ j ] NEW_LINE floor [ i ] [ j ] += min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT elif ( j == n - 1 ) : NEW_LINE INDENT floor [ i ] [ j ] = given [ i ] [ j ] NEW_LINE floor [ i ] [ j ] += min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) NEW_LINE temp = min ( temp , floor [ i - 1 ] [ j + 1 ] ) NEW_LINE floor [ i ] [ j ] = given [ i ] [ j ] + temp NEW_LINE DEDENT DEDENT DEDENT min_odd_cost = 10 ** 9 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( floor [ n - 1 ] [ j ] % 2 == 1 ) : NEW_LINE INDENT if ( min_odd_cost > floor [ n - 1 ] [ j ] ) : NEW_LINE INDENT min_odd_cost = floor [ n - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT if ( min_odd_cost == - 10 ** 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return min_odd_cost NEW_LINE DEDENT
def countPaths ( m , n ) : NEW_LINE INDENT if m == 1 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ) NEW_LINE DEDENT
def countPaths ( m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i == 1 or j == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT
def countWays ( m , n ) : NEW_LINE INDENT m = m - 1 NEW_LINE n = n - 1 NEW_LINE return ( factorial ( m + n ) // ( factorial ( m ) * factorial ( n ) ) ) NEW_LINE DEDENT
def MatrixChainOrder ( p , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 1 , n - 1 ) : NEW_LINE INDENT for i in range ( n - L ) : NEW_LINE INDENT dp [ i ] [ i + L ] = min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) NEW_LINE DEDENT DEDENT return dp [ 1 ] [ n - 1 ] NEW_LINE DEDENT
def createPalindrome ( _input , isOdd ) : NEW_LINE INDENT n = palin = _input NEW_LINE if isOdd : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT while n > 0 : NEW_LINE INDENT palin = palin * 10 + ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT return palin NEW_LINE DEDENT
def generatePalindromes ( N ) : NEW_LINE INDENT palindromes = [ ] NEW_LINE for j in range ( 0 , 2 ) : NEW_LINE INDENT i = 1 NEW_LINE number = createPalindrome ( i , j ) NEW_LINE while number <= N : NEW_LINE INDENT palindromes . append ( number ) NEW_LINE i += 1 NEW_LINE number = createPalindrome ( i , j ) NEW_LINE DEDENT DEDENT return palindromes NEW_LINE DEDENT
def minimumNoOfPalindromes ( N ) : NEW_LINE INDENT b = a = str ( N ) NEW_LINE b = b [ : : - 1 ] NEW_LINE if a == b : NEW_LINE INDENT return 1 NEW_LINE DEDENT palindromes = generatePalindromes ( N ) NEW_LINE palindromes . sort ( ) NEW_LINE l , r = 0 , len ( palindromes ) - 1 NEW_LINE while l < r : NEW_LINE INDENT if palindromes [ l ] + palindromes [ r ] == N : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif palindromes [ l ] + palindromes [ r ] < N : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return 3 NEW_LINE DEDENT
def costOfString ( s ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cost += ( ord ( s [ i ] ) - 48 ) NEW_LINE DEDENT return cost NEW_LINE DEDENT
def lds ( arr , n ) : NEW_LINE INDENT lds = [ 0 for i in range ( n ) ] NEW_LINE lds [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lds [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( lds [ j ] != 0 and arr [ i ] % arr [ j ] == 0 ) : NEW_LINE INDENT lds [ i ] = max ( lds [ i ] , lds [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max ( lds ) NEW_LINE DEDENT
def find ( start , adj , n , dp ) : NEW_LINE INDENT if ( start == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ start ] != - 1 ) : NEW_LINE INDENT return dp [ start ] NEW_LINE DEDENT dp [ start ] = 0 NEW_LINE one = 0 NEW_LINE zero = 0 NEW_LINE for k in range ( start , n , 1 ) : NEW_LINE INDENT if ( adj [ k ] == '1' ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( one > zero ) : NEW_LINE INDENT dp [ start ] = max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ start ] = max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) NEW_LINE DEDENT DEDENT return dp [ start ] NEW_LINE DEDENT
def isVowel ( ch ) : NEW_LINE INDENT if ( ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE i , j = 0 , 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( ( X [ i - 1 ] == Y [ j - 1 ] ) and isVowel ( X [ i - 1 ] ) ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT
def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return int ( c / ( n + 1 ) ) NEW_LINE DEDENT
def makePairs ( pairs , a , b ) : NEW_LINE INDENT for i in range ( a , b + 1 , 1 ) : NEW_LINE INDENT sumOfDigits = 0 NEW_LINE k = i NEW_LINE while ( k > 0 ) : NEW_LINE INDENT sumOfDigits += k % 10 NEW_LINE k = int ( k / 10 ) NEW_LINE DEDENT if ( sumOfDigits <= 162 ) : NEW_LINE INDENT pairs . append ( sumOfDigits ) NEW_LINE DEDENT DEDENT DEDENT
def countCoPrime ( a , b ) : NEW_LINE INDENT pairs = [ ] NEW_LINE makePairs ( pairs , a , b ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , len ( pairs ) , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , len ( pairs ) , 1 ) : NEW_LINE INDENT if ( gcd ( pairs [ i ] , pairs [ j ] ) == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def recursive ( idx , sum , tight , st , dp , num ) : NEW_LINE INDENT if ( idx == num ) : NEW_LINE INDENT return sum == 0 NEW_LINE DEDENT if ( dp [ idx ] [ tight ] [ sum ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ tight ] [ sum ] NEW_LINE DEDENT ans = 0 NEW_LINE for d in range ( 10 ) : NEW_LINE INDENT newTight = False NEW_LINE if ( tight and ord ( st [ idx ] ) - ord ( '0' ) < d ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( tight and ord ( st [ idx ] ) - ord ( '0' ) == d ) : NEW_LINE INDENT newTight = True NEW_LINE DEDENT if ( sum >= d ) : NEW_LINE INDENT ans += recursive ( idx + 1 , sum - d , newTight , st , dp , num ) NEW_LINE DEDENT DEDENT dp [ idx ] [ tight ] [ sum ] = ans NEW_LINE return dp [ idx ] [ tight ] [ sum ] NEW_LINE DEDENT
def formArray ( N ) : NEW_LINE INDENT dp = [ [ [ - 1 for x in range ( 166 ) ] for y in range ( 2 ) ] for z in range ( 20 ) ] NEW_LINE st = str ( N ) NEW_LINE num = len ( st ) NEW_LINE arr = [ ] NEW_LINE for i in range ( 1 , 163 ) : NEW_LINE INDENT arr . append ( recursive ( 0 , i , 1 , st , dp , num ) ) NEW_LINE DEDENT return arr NEW_LINE DEDENT
def findPair ( a , b ) : NEW_LINE INDENT arr_smaller = formArray ( a - 1 ) NEW_LINE arr_greater = formArray ( b ) NEW_LINE for i in range ( len ( arr_greater ) ) : NEW_LINE INDENT arr_greater [ i ] -= arr_smaller [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , 163 ) : NEW_LINE INDENT for j in range ( i + 1 , 163 ) : NEW_LINE INDENT if ( math . gcd ( i , j ) == 1 ) : NEW_LINE INDENT ans = ( ans + arr_greater [ i - 1 ] * arr_greater [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def printTetraRec ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( printTetraRec ( n - 1 ) + printTetraRec ( n - 2 ) + printTetraRec ( n - 3 ) + printTetraRec ( n - 4 ) ) NEW_LINE DEDENT DEDENT
def printTetra ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 5 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 1 NEW_LINE dp [ 3 ] = 2 NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ) NEW_LINE DEDENT print ( dp [ n ] ) NEW_LINE DEDENT
def printTetra ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT first = 0 NEW_LINE second = 1 NEW_LINE third = 1 NEW_LINE fourth = 2 NEW_LINE curr = 0 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT print ( first ) NEW_LINE DEDENT elif ( n == 1 or n == 2 ) : NEW_LINE INDENT print ( second ) NEW_LINE DEDENT elif ( n == 3 ) : NEW_LINE INDENT print ( fourth ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 4 , n + 1 ) : NEW_LINE INDENT curr = first + second + third + fourth NEW_LINE first = second NEW_LINE second = third NEW_LINE third = fourth NEW_LINE fourth = curr NEW_LINE DEDENT DEDENT print ( curr ) NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE v = factors ( n ) NEW_LINE v . sort ( ) NEW_LINE r = len ( v ) NEW_LINE subset = [ [ 0 for i in range ( n + 1 ) ] for j in range ( r + 1 ) ] NEW_LINE for i in range ( r + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , r + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( j < v [ i - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - v [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT if ( ( subset [ r ] [ n ] ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def maxSum1 ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE maxi = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE if ( maxi < arr [ i ] ) : NEW_LINE INDENT maxi = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 2 , n - 1 ) : NEW_LINE INDENT for j in range ( i - 1 ) : NEW_LINE INDENT if ( dp [ i ] < dp [ j ] + arr [ i ] ) : NEW_LINE INDENT dp [ i ] = dp [ j ] + arr [ i ] NEW_LINE if ( maxi < dp [ i ] ) : NEW_LINE INDENT maxi = dp [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxi NEW_LINE DEDENT
def maxSum2 ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE maxi = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE if ( maxi < arr [ i ] ) : NEW_LINE INDENT maxi = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT for j in range ( 1 , i - 1 ) : NEW_LINE INDENT if ( dp [ i ] < arr [ i ] + dp [ j ] ) : NEW_LINE INDENT dp [ i ] = arr [ i ] + dp [ j ] NEW_LINE if ( maxi < dp [ i ] ) : NEW_LINE INDENT maxi = dp [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxi NEW_LINE DEDENT
def findMaxSum ( arr , n ) : NEW_LINE INDENT return max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) ) NEW_LINE DEDENT
def solve ( N , K ) : NEW_LINE INDENT combo = [ 0 ] * ( N + 1 ) NEW_LINE combo [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 0 , N + 1 ) : NEW_LINE INDENT if j >= i : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo [ N ] NEW_LINE DEDENT
def fibonacci ( ) : NEW_LINE INDENT fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , 43 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DEDENT
def rec ( x , y , last ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT Sum , i = 0 , last NEW_LINE while i >= 0 and fib [ i ] * y >= x : NEW_LINE INDENT if fib [ i ] > x : NEW_LINE INDENT i -= 1 NEW_LINE continue NEW_LINE DEDENT Sum += rec ( x - fib [ i ] , y - 1 , i ) NEW_LINE i -= 1 NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def MinimumPrimes ( n ) : NEW_LINE INDENT dp = [ 10 ** 9 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = dp [ 2 ] = dp [ 3 ] = dp [ 5 ] = dp [ 7 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if check ( i , 2 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 2 ] ) NEW_LINE DEDENT if check ( i , 3 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 3 ] ) NEW_LINE DEDENT if check ( i , 5 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 5 ] ) NEW_LINE DEDENT if check ( i , 7 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 7 ] ) NEW_LINE DEDENT DEDENT if dp [ n ] == 10 ** 9 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT DEDENT
def minimumCost ( cost , n ) : NEW_LINE INDENT dp = [ None ] * n NEW_LINE if n == 1 : NEW_LINE INDENT return cost [ 0 ] NEW_LINE DEDENT dp [ 0 ] = cost [ 0 ] NEW_LINE dp [ 1 ] = cost [ 1 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] NEW_LINE DEDENT return min ( dp [ n - 2 ] , dp [ n - 1 ] ) NEW_LINE DEDENT
def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT
def subsetSum ( arr , n , maxSum ) : NEW_LINE INDENT dp = [ False for i in range ( maxSum + 1 ) ] NEW_LINE dp [ arr [ 0 ] ] = True NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT j = maxSum NEW_LINE while ( j >= 1 ) : NEW_LINE INDENT if ( arr [ i ] <= j ) : NEW_LINE INDENT if ( arr [ i ] == j or dp [ j ] or dp [ ( j - arr [ i ] ) ] ) : NEW_LINE INDENT dp [ j ] = True NEW_LINE DEDENT else : NEW_LINE INDENT dp [ j ] = False NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE DEDENT DEDENT print ( 0 , end = " " ) NEW_LINE for j in range ( maxSum + 1 ) : NEW_LINE INDENT if ( dp [ j ] == True ) : NEW_LINE INDENT print ( j , end = " " ) NEW_LINE DEDENT DEDENT print ( "21" ) NEW_LINE DEDENT
def printDistinct ( a , n ) : NEW_LINE INDENT maxSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxSum += a [ i ] NEW_LINE DEDENT subsetSum ( a , n , maxSum ) NEW_LINE DEDENT
def maxCost ( a , m , n , dp ) : NEW_LINE INDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return int ( - 1e9 ) NEW_LINE DEDENT elif ( m == 0 and n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT num = m + n NEW_LINE if ( ( num & ( num - 1 ) ) == 0 ) : NEW_LINE INDENT dp [ m ] [ n ] = a [ m ] [ n ] + maxCost ( a , m - 1 , n - 1 , dp ) NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ m ] [ n ] = ( a [ m ] [ n ] + max ( maxCost ( a , m - 1 , n , dp ) , maxCost ( a , m , n - 1 , dp ) ) ) NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT DEDENT DEDENT
def answer ( a , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( size ) ] for j in range ( size ) ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT for j in range ( size ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT return maxCost ( a , n - 1 , n - 1 , dp ) NEW_LINE DEDENT
def editDistanceWith2Ops ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE L = [ [ 0 for x in range ( n + 1 ) ] for y in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT lcs = L [ m ] [ n ] NEW_LINE return ( m - lcs ) + ( n - lcs ) NEW_LINE DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + lcs ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) NEW_LINE DEDENT DEDENT
def lcs ( X , Y , m , n , dp ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ m - 1 ] [ n - 1 ] != - 1 ) : NEW_LINE INDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = 1 + lcs ( X , Y , m - 1 , n - 1 , dp ) NEW_LINE return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = max ( lcs ( X , Y , m , n - 1 , dp ) , lcs ( X , Y , m - 1 , n , dp ) ) NEW_LINE return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT DEDENT
def countPaths ( n ) : NEW_LINE INDENT zB = 1 NEW_LINE zADC = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT nzB = zADC * 3 NEW_LINE nzADC = ( zADC * 2 + zB ) NEW_LINE zB = nzB NEW_LINE zADC = nzADC NEW_LINE DEDENT return zB NEW_LINE DEDENT
def sumSubSequence ( arr , length , m ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in arr : NEW_LINE INDENT summ += i NEW_LINE DEDENT dp = [ [ 0 for i in range ( summ + 1 ) ] for j in range ( length + 1 ) ] NEW_LINE for i in range ( length + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] += 1 NEW_LINE DEDENT for i in range ( 1 , length + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] += 1 NEW_LINE for j in range ( 1 , summ + 1 ) : NEW_LINE INDENT if dp [ i - 1 ] [ j ] > 0 : NEW_LINE INDENT dp [ i ] [ j ] += 1 NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] += 1 NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 1 , summ + 1 ) : NEW_LINE INDENT if dp [ length ] [ i ] > 0 : NEW_LINE INDENT if i % m == 0 : NEW_LINE INDENT count += dp [ length ] [ i ] NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 0 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT if term [ n ] != 0 : NEW_LINE INDENT return term [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE return term [ n ] NEW_LINE DEDENT DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + lcs ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) NEW_LINE DEDENT DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT global arr NEW_LINE if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ m - 1 ] [ n - 1 ] != - 1 ) : NEW_LINE INDENT return arr [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT arr [ m - 1 ] [ n - 1 ] = 1 + lcs ( X , Y , m - 1 , n - 1 ) NEW_LINE return arr [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ m - 1 ] [ n - 1 ] = max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) NEW_LINE return arr [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT DEDENT
def lcs ( X , Y , Z , m , n , o ) : NEW_LINE INDENT global arr NEW_LINE if ( m == 0 or n == 0 or o == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ m - 1 ] [ n - 1 ] [ o - 1 ] != - 1 ) : NEW_LINE INDENT return arr [ m - 1 ] [ n - 1 ] [ o - 1 ] NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] and Y [ n - 1 ] == Z [ o - 1 ] ) : NEW_LINE INDENT arr [ m - 1 ] [ n - 1 ] [ o - 1 ] = 1 + lcs ( X , Y , Z , m - 1 , n - 1 , o - 1 ) NEW_LINE return arr [ m - 1 ] [ n - 1 ] [ o - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ m - 1 ] [ n - 1 ] [ o - 1 ] = max ( lcs ( X , Y , Z , m , n - 1 , o ) , max ( lcs ( X , Y , Z , m - 1 , n , o ) , lcs ( X , Y , Z , m , n , o - 1 ) ) ) NEW_LINE return arr [ m - 1 ] [ n - 1 ] [ o - 1 ] NEW_LINE DEDENT DEDENT
def minStepsNeeded ( k , d1 , d2 , x ) : NEW_LINE INDENT gcd = __gcd ( d1 , d2 ) NEW_LINE if ( ( k - x ) % gcd != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT q = queue ( ) NEW_LINE visited = dict ( ) NEW_LINE q . appendleft ( [ k , 0 ] ) NEW_LINE visited [ k ] = 1 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT sr = q . pop ( ) NEW_LINE s , stp = sr [ 0 ] , sr [ 1 ] NEW_LINE if ( s == x ) : NEW_LINE INDENT return stp NEW_LINE DEDENT if ( s + d1 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s + d1 ) , stp + 1 ] ) NEW_LINE visited [ ( s + d1 ) ] = 1 NEW_LINE DEDENT if ( s + d2 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s + d2 ) , stp + 1 ] ) NEW_LINE visited [ ( s + d2 ) ] = 1 NEW_LINE DEDENT if ( s - d1 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s - d1 ) , stp + 1 ] ) NEW_LINE visited [ ( s - d1 ) ] = 1 NEW_LINE DEDENT if ( s - d2 not in visited ) : NEW_LINE INDENT q . appendleft ( [ ( s - d2 ) , stp + 1 ] ) NEW_LINE visited [ ( s - d2 ) ] = 1 NEW_LINE DEDENT DEDENT DEDENT
def lds ( arr , n ) : NEW_LINE INDENT lds = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lds [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < lds [ i ] ) : NEW_LINE INDENT max = lds [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def minimumNumberOfDigits ( a , b ) : NEW_LINE INDENT if ( a > b or a < 0 or b < 0 or a > 900 or b > 8100 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ a ] [ b ] != - 1 ) : NEW_LINE INDENT return dp [ a ] [ b ] NEW_LINE DEDENT ans = 101 NEW_LINE for i in range ( 9 , 0 , - 1 ) : NEW_LINE INDENT k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) NEW_LINE if ( k != - 1 ) : NEW_LINE INDENT ans = min ( ans , k + 1 ) NEW_LINE DEDENT DEDENT dp [ a ] [ b ] = ans NEW_LINE return ans NEW_LINE DEDENT
def printSmallestNumber ( a , b ) : NEW_LINE INDENT for i in range ( 901 ) : NEW_LINE INDENT for j in range ( 8101 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE k = minimumNumberOfDigits ( a , b ) NEW_LINE if ( k == - 1 or k > 100 ) : NEW_LINE INDENT print ( - 1 , end = '' ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( a > 0 and b > 0 ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( a >= i and b >= i * i and 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] ) : NEW_LINE INDENT print ( i , end = '' ) NEW_LINE a -= i NEW_LINE b -= i * i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def binomialCoeff ( C , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT return C NEW_LINE DEDENT
def sumOfproduct ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE C = [ 0 ] * MAX NEW_LINE C = binomialCoeff ( C , n ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sum += C [ i ] * C [ i + 1 ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT
def sumOfproduct ( n ) : NEW_LINE INDENT return binomialCoeff ( 2 * n , n - 1 ) NEW_LINE DEDENT
def check ( i , add , n , k , a , dp ) : NEW_LINE INDENT if add <= 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if i >= n : NEW_LINE INDENT if add == k : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if dp [ i ] [ add ] != - 1 : NEW_LINE INDENT return dp [ i ] [ add ] NEW_LINE DEDENT dp [ i ] [ add ] = ( check ( i + 1 , add - 2 * a [ i ] , n , k , a , dp ) or check ( i + 1 , add , n , k , a , dp ) ) NEW_LINE dp [ i ] [ add ] = ( check ( i + 1 , add - ( i + 1 ) , n , k , a , dp ) or dp [ i ] [ add ] ) NEW_LINE dp [ i ] [ add ] = ( check ( i + 1 , add + i + 1 , n , k , a , dp ) or dp [ i ] [ add ] ) NEW_LINE return dp [ i ] [ add ] NEW_LINE DEDENT
def wrapper ( n , k , a ) : NEW_LINE INDENT add = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT add += a [ i ] NEW_LINE DEDENT dp = [ - 1 ] * MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT dp [ i ] = [ - 1 ] * MAX NEW_LINE DEDENT return check ( 0 , add , n , k , a , dp ) NEW_LINE DEDENT
def isPowerOf ( val , base ) : NEW_LINE INDENT while ( val > 1 ) : NEW_LINE INDENT if ( val % base != 0 ) : NEW_LINE INDENT val //= base NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT
def numberOfPartitions ( binaryNo ) : NEW_LINE INDENT n = len ( binaryNo ) NEW_LINE dp = [ 0 ] * n NEW_LINE if ( ( ord ( binaryNo [ n - 1 ] ) - ord ( '0' ) ) == 0 ) : NEW_LINE INDENT dp [ n - 1 ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ n - 1 ] = 1 NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT val = 0 NEW_LINE if ( ( ord ( binaryNo [ i ] ) - ord ( '0' ) ) == 0 ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE continue NEW_LINE DEDENT dp [ i ] = sys . maxsize NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT val = ( val * 2 ) + ( ord ( binaryNo [ j ] ) - ord ( '0' ) ) NEW_LINE if ( isPowerOf ( val , 4 ) or isPowerOf ( val , 6 ) ) : NEW_LINE INDENT if ( j == n - 1 ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( dp [ j + 1 ] != - 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ j + 1 ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( dp [ i ] == sys . maxsize ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] NEW_LINE DEDENT
def binomialCoeff ( n , C ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n ) , - 1 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT
def summation ( n ) : NEW_LINE INDENT C = [ 0 ] * MAX NEW_LINE binomialCoeff ( n , C ) NEW_LINE sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sum += ( i * C [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def summation ( n ) : NEW_LINE INDENT return n << ( n - 1 ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT
def countArray ( N , K ) : NEW_LINE INDENT return binomialCoeff ( K - 1 , N - 1 ) NEW_LINE DEDENT
def count ( n , c , a , b ) : NEW_LINE INDENT need = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT a [ i + n ] = a [ i ] NEW_LINE b [ i + n ] = b [ i ] NEW_LINE DEDENT s = 0 NEW_LINE tank = 0 NEW_LINE for i in range ( 0 , 2 * n , 1 ) : NEW_LINE INDENT tank += a [ i ] NEW_LINE tank = min ( tank , c ) NEW_LINE tank -= b [ i ] NEW_LINE if ( tank < 0 ) : NEW_LINE INDENT tank = 0 NEW_LINE s = i + 1 NEW_LINE DEDENT DEDENT if ( s >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE need [ s + n ] = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT id = s + n - i NEW_LINE need [ id ] = max ( 0 , need [ id + 1 ] + b [ id ] - min ( a [ id ] , c ) ) NEW_LINE if ( need [ id ] == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = ' ' ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = ' ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE print ( c , end = ' ' ) NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT DEDENT
def countDigits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n //= 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findCount ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE countDigitsL = countDigits ( L ) NEW_LINE countDigitsR = countDigits ( R ) NEW_LINE firstDigitL = ( L // pow ( 10 , countDigitsL - 1 ) ) NEW_LINE firstDigitR = ( R // pow ( 10 , countDigitsR - 1 ) ) NEW_LINE if ( countDigitsL < countDigitsR ) : NEW_LINE INDENT count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) NEW_LINE if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count += firstDigitR NEW_LINE DEDENT else : NEW_LINE INDENT count += ( firstDigitR - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count -= ( 9 - firstDigitR ) NEW_LINE DEDENT else : NEW_LINE INDENT count -= ( 9 - firstDigitR + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def score ( n , A , k ) : NEW_LINE INDENT if ( memo [ n ] [ k ] > 0 ) : NEW_LINE INDENT return memo [ n ] [ k ] NEW_LINE DEDENT sum = 0 NEW_LINE i = n - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE memo [ n ] [ k ] = max ( memo [ n ] [ k ] , score ( i , A , k - 1 ) + int ( sum / ( n - i ) ) ) NEW_LINE i -= 1 NEW_LINE DEDENT return memo [ n ] [ k ] NEW_LINE DEDENT
def pre_compute ( a , n , index , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > a [ 0 ] : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ j ] > a [ i ] and j > i : NEW_LINE INDENT if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dp [ index ] [ k ] NEW_LINE DEDENT
def gen ( n ) : NEW_LINE INDENT S = [ 0 , 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT S . append ( 4 * S [ int ( i / 2 ) ] ) NEW_LINE DEDENT else : NEW_LINE INDENT S . append ( 4 * S [ int ( i / 2 ) ] + 1 ) NEW_LINE DEDENT DEDENT z = S [ n ] NEW_LINE return z NEW_LINE DEDENT
def moserDeBruijn ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( gen ( i ) , end = " " ) NEW_LINE DEDENT DEDENT
def LCSubStr ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE result = 0 NEW_LINE len_mat = np . zeros ( ( 2 , n ) ) NEW_LINE currRow = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == 0 j == 0 ) : NEW_LINE INDENT len_mat [ currRow ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT len_mat [ currRow ] [ j ] = len_mat [ 1 - currRow ] [ j - 1 ] + 1 NEW_LINE result = max ( result , len_mat [ currRow ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT len_mat [ currRow ] [ j ] = 0 NEW_LINE DEDENT DEDENT currRow = 1 - currRow NEW_LINE DEDENT return result NEW_LINE DEDENT
def isPartitionPoss ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT set1 = [ ] NEW_LINE set2 = [ ] NEW_LINE return findSets ( arr , n , set1 , set2 , 0 , 0 , 0 ) NEW_LINE DEDENT
def func ( n , m , A ) : NEW_LINE INDENT ModArray = [ 0 ] * n NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ModArray [ i ] = A [ i ] % m NEW_LINE Sum += ModArray [ i ] NEW_LINE DEDENT Sum = Sum % m NEW_LINE if ( Sum % m == 0 ) : NEW_LINE INDENT print ( "True" ) NEW_LINE return NEW_LINE DEDENT if ( Sum % 2 != 0 ) : NEW_LINE INDENT print ( "False" ) NEW_LINE DEDENT else : NEW_LINE INDENT ModArray . pop ( 0 ) NEW_LINE i = 0 NEW_LINE j = len ( ModArray ) - 1 NEW_LINE ModArray . sort ( ) NEW_LINE Sum = Sum // 2 NEW_LINE while ( i <= j ) : NEW_LINE INDENT s = ModArray [ i ] + ModArray [ j ] NEW_LINE if ( s == Sum ) : NEW_LINE INDENT i1 = i NEW_LINE i2 = j NEW_LINE print ( "True" ) NEW_LINE break NEW_LINE DEDENT elif ( s > Sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def dfs1 ( v , u , parent ) : NEW_LINE INDENT global inn , out NEW_LINE inn [ u ] = 0 NEW_LINE for child in v [ u ] : NEW_LINE INDENT if ( child == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs1 ( v , child , u ) NEW_LINE inn [ u ] = max ( inn [ u ] , 1 + inn [ child ] ) NEW_LINE DEDENT DEDENT
def dfs2 ( v , u , parent ) : NEW_LINE INDENT global inn , out NEW_LINE mx1 , mx2 = - 1 , - 1 NEW_LINE for child in v [ u ] : NEW_LINE INDENT if ( child == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( inn [ child ] >= mx1 ) : NEW_LINE INDENT mx2 = mx1 NEW_LINE mx1 = inn [ child ] NEW_LINE DEDENT elif ( inn [ child ] > mx2 ) : NEW_LINE INDENT mx2 = inn [ child ] NEW_LINE DEDENT DEDENT for child in v [ u ] : NEW_LINE INDENT if ( child == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT longest = mx1 NEW_LINE if ( mx1 == inn [ child ] ) : NEW_LINE INDENT longest = mx2 NEW_LINE DEDENT out [ child ] = 1 + max ( out [ u ] , 1 + longest ) NEW_LINE dfs2 ( v , child , u ) NEW_LINE DEDENT DEDENT
def printGolomb ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( findGolomb ( i ) , end = " " ) NEW_LINE DEDENT DEDENT
def dfs ( a , v , u , parent ) : NEW_LINE INDENT dp [ u ] = a [ u - 1 ] NEW_LINE maximum = 0 NEW_LINE for child in v [ u ] : NEW_LINE INDENT if child == parent : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( a , v , child , u ) NEW_LINE maximum = max ( maximum , dp [ child ] ) NEW_LINE DEDENT dp [ u ] += maximum NEW_LINE DEDENT
def maximumValue ( a , v ) : NEW_LINE INDENT dfs ( a , v , 1 , 0 ) NEW_LINE return dp [ 1 ] NEW_LINE DEDENT
def countRemovals ( a , i , j , k ) : NEW_LINE INDENT global dp NEW_LINE if ( i >= j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( a [ j ] - a [ i ] ) <= k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT elif ( ( a [ j ] - a [ i ] ) > k ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( countRemovals ( a , i + 1 , j , k ) , countRemovals ( a , i , j - 1 , k ) ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT
def removals ( a , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return countRemovals ( a , 0 , n - 1 , k ) NEW_LINE DEDENT DEDENT
def removals ( arr , n , k ) : NEW_LINE INDENT ans = n - 1 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = findInd ( arr [ i ] , i , n , k , arr ) NEW_LINE if ( j != - 1 ) : NEW_LINE INDENT ans = min ( ans , n - ( j - i + 1 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def removals ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT ans = n - 1 NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] = i NEW_LINE j = dp [ i - 1 ] NEW_LINE while ( j != i and arr [ i ] - arr [ j ] > k ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT dp [ i ] = min ( dp [ i ] , j ) NEW_LINE ans = min ( ans , ( n - ( i - j + 1 ) ) ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
def maximumSegments ( n , a , b , c ) : NEW_LINE INDENT dp = [ - 1 ] * ( n + 10 ) NEW_LINE DEDENT
def postfix ( a , n ) : NEW_LINE INDENT for i in range ( n - 1 , 1 , - 1 ) : NEW_LINE INDENT a [ i - 1 ] = a [ i - 1 ] + a [ i ] NEW_LINE DEDENT DEDENT
def modify ( a , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT a [ i - 1 ] = i * a [ i ] NEW_LINE DEDENT DEDENT
def sequence ( n ) : NEW_LINE INDENT f = [ 0 , 1 , 1 ] NEW_LINE print ( f [ 1 ] , end = " " ) , NEW_LINE print ( f [ 2 ] , end = " " ) , NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f . append ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) NEW_LINE print ( f [ i ] , end = " " ) , NEW_LINE DEDENT DEDENT
def sum ( a , i , j ) : NEW_LINE INDENT ans = 0 NEW_LINE for m in range ( i , j + 1 ) : NEW_LINE INDENT ans = ( ans + a [ m ] ) % 100 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def solve ( a , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT
def initialize ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT
def reverseFibonacci ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 2 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def longestSubsequenceCommonSegment ( k , s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) NEW_LINE if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : NEW_LINE INDENT cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT if ( cnt [ i ] [ j ] >= k ) : NEW_LINE INDENT for a in range ( k , cnt [ i ] [ j ] + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return lcs [ n ] [ m ] NEW_LINE DEDENT
def arrangeBraces ( n , pos , k ) : NEW_LINE INDENT h = [ False for i in range ( N ) ] NEW_LINE dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT h [ pos [ i ] ] = 1 NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT for j in range ( 2 * n + 1 ) : NEW_LINE INDENT if ( h [ i ] ) : NEW_LINE INDENT if ( j != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( j != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ 2 * n ] [ 0 ] NEW_LINE DEDENT
def check ( s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE dp = ( [ [ False for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] ) NEW_LINE dp [ 0 ] [ 0 ] = True NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT for j in range ( len ( s2 ) + 1 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] ) : NEW_LINE INDENT if ( ( j < len ( s2 ) and ( s1 [ i ] . upper ( ) == s2 [ j ] ) ) ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = True NEW_LINE DEDENT if ( s1 [ i ] . isupper ( ) == False ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT return ( dp [ n ] [ m ] ) NEW_LINE DEDENT
def findLength ( string , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_sum += ( 1 if string [ i ] == '0' else - 1 ) NEW_LINE if current_sum < 0 : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return max_sum if max_sum else 0 NEW_LINE DEDENT
def find_prob ( N , P ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 0 NEW_LINE dp [ 2 ] = P NEW_LINE dp [ 3 ] = 1 - P NEW_LINE for i in range ( 4 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] NEW_LINE DEDENT return dp [ N ] NEW_LINE DEDENT
def maxSubArraySumRepeated ( a , n , k ) : NEW_LINE INDENT max_so_far = - 2147483648 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( n * k ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i % n ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def chordCnt ( A ) : NEW_LINE INDENT n = 2 * A NEW_LINE dpArray = [ 0 ] * ( n + 1 ) NEW_LINE dpArray [ 0 ] = 1 NEW_LINE dpArray [ 2 ] = 1 NEW_LINE for i in range ( 4 , n + 1 , 2 ) : NEW_LINE INDENT for j in range ( 0 , i - 1 , 2 ) : NEW_LINE INDENT dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) NEW_LINE DEDENT DEDENT return int ( dpArray [ n ] ) NEW_LINE DEDENT
def maximumSumSubarray ( arr , n ) : NEW_LINE INDENT min_prefix_sum = 0 NEW_LINE res = - math . inf NEW_LINE prefix_sum = [ ] NEW_LINE prefix_sum . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum . append ( prefix_sum [ i - 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT res = max ( res , prefix_sum [ i ] - min_prefix_sum ) NEW_LINE min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def isPath ( arr ) : NEW_LINE INDENT Dir = [ [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] ] NEW_LINE q = [ ] NEW_LINE q . append ( ( 0 , 0 ) ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT p = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE arr [ p [ 0 ] ] [ p [ 1 ] ] = - 1 NEW_LINE if ( p == ( row - 1 , col - 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 4 ) : NEW_LINE INDENT a = p [ 0 ] + Dir [ i ] [ 0 ] NEW_LINE b = p [ 1 ] + Dir [ i ] [ 1 ] NEW_LINE if ( a >= 0 and b >= 0 and a < row and b < col and arr [ a ] [ b ] != - 1 ) : NEW_LINE INDENT q . append ( ( a , b ) ) NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def isPath ( arr ) : NEW_LINE INDENT arr [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , row ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ 0 ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , row ) : NEW_LINE INDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ( arr [ row - 1 ] [ col - 1 ] == 1 ) NEW_LINE DEDENT
def Jacobsthal ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def Jacobsthal_Lucas ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 2 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def findStep ( n ) : NEW_LINE INDENT if ( n == 1 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) NEW_LINE DEDENT DEDENT
def countWays ( n ) : NEW_LINE INDENT res = [ 0 ] * ( n + 2 ) NEW_LINE res [ 0 ] = 1 NEW_LINE res [ 1 ] = 1 NEW_LINE res [ 2 ] = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] NEW_LINE DEDENT return res [ n ] NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 4 NEW_LINE if ( n == 0 or n == 1 or n == 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return c NEW_LINE DEDENT for i in range ( 4 , n + 1 ) : NEW_LINE INDENT d = c + b + a NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE DEDENT return d NEW_LINE DEDENT
def sequence ( n ) : NEW_LINE INDENT if n == 1 or n == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) NEW_LINE DEDENT DEDENT
def sequence ( n ) : NEW_LINE INDENT f = array . array ( 'i' , [ 0 , 1 , 1 ] ) NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] NEW_LINE f . append ( r ) NEW_LINE DEDENT return r NEW_LINE DEDENT
def choose ( n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( nck [ n ] [ k ] != - 1 ) : NEW_LINE INDENT return nck [ n ] [ k ] NEW_LINE DEDENT answer = choose ( n - 1 , k - 1 ) + choose ( n - 1 , k ) NEW_LINE nck [ n ] [ k ] = answer NEW_LINE return answer NEW_LINE DEDENT
def getLeft ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT h = log2 [ n ] NEW_LINE last = n - ( ( 1 << h ) - 1 ) NEW_LINE if ( last >= ( numh // 2 ) ) : NEW_LINE INDENT else : return ( 1 << h ) - 1 - ( ( numh // 2 ) - last ) NEW_LINE DEDENT DEDENT
def numberOfHeaps ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT left = getLeft ( n ) NEW_LINE ans = ( choose ( n - 1 , left ) * numberOfHeaps ( left ) ) * ( numberOfHeaps ( n - 1 - left ) ) NEW_LINE dp [ n ] = ans NEW_LINE return ans NEW_LINE DEDENT
def Hosoya ( n , m ) : NEW_LINE INDENT if ( ( n == 0 and m == 0 ) or ( n == 1 and m == 0 ) or ( n == 1 and m == 1 ) or ( n == 2 and m == 1 ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n > m : NEW_LINE INDENT return Hosoya ( n - 1 , m ) NEW_LINE + Hosoya ( n - 2 , m ) NEW_LINE DEDENT elif m == n : NEW_LINE INDENT return Hosoya ( n - 1 , m - 1 ) NEW_LINE + Hosoya ( n - 2 , m - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def numberofways ( n , m ) : NEW_LINE INDENT dp = np . zeros ( ( n + 2 , n + 2 ) ) NEW_LINE dp [ 0 ] [ n + 1 ] = 1 NEW_LINE for k in range ( n , m - 1 , - 1 ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ k ] = dp [ i ] [ k + 1 ] NEW_LINE if ( i - k >= 0 ) : NEW_LINE INDENT dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
def zigzag ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
def eulerian ( n , m ) : NEW_LINE INDENT if ( m >= n or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ) NEW_LINE DEDENT
def eulerian ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , m + 1 ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
def nswp ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for j in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT
def longOddEvenIncSeq ( arr , n ) : NEW_LINE INDENT lioes = list ( ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lioes . append ( 1 ) NEW_LINE DEDENT i = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) : NEW_LINE INDENT lioes [ i ] = lioes [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if maxLen < lioes [ i ] : NEW_LINE INDENT maxLen = lioes [ i ] NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT
def dealnnoy ( n , m ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) NEW_LINE DEDENT
def dealnnoy ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
def longestAlternating ( arr , n ) : NEW_LINE INDENT count = [ None ] * n NEW_LINE count [ n - 1 ] = 1 NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( arr [ i ] * arr [ i + 1 ] < 0 ) : NEW_LINE INDENT count [ i ] = count [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT print ( count [ i ] , end = " " ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT
def maxDP ( n ) : NEW_LINE INDENT res = list ( ) NEW_LINE res . append ( 0 ) NEW_LINE res . append ( 1 ) NEW_LINE i = 2 NEW_LINE while i < n + 1 : NEW_LINE INDENT res . append ( max ( i , ( res [ int ( i / 2 ) ] + res [ int ( i / 3 ) ] + res [ int ( i / 4 ) ] + res [ int ( i / 5 ) ] ) ) ) NEW_LINE i = i + 1 NEW_LINE DEDENT return res [ n ] NEW_LINE DEDENT
def findlength ( arr , s , n , ind , st , dp ) : NEW_LINE INDENT if ind >= n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ ind ] [ st ] != - 1 : NEW_LINE INDENT return dp [ ind ] [ st ] NEW_LINE DEDENT if not st : NEW_LINE INDENT dp [ ind ] [ st ] = max ( arr [ ind ] + findlength ( arr , s , n , ind + 1 , 1 , dp ) , ( findlength ( arr , s , n , ind + 1 , 0 , dp ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ind ] [ st ] = max ( arr [ ind ] + findlength ( arr , s , n , ind + 1 , 1 , dp ) , 0 ) NEW_LINE DEDENT return dp [ ind ] [ st ] NEW_LINE DEDENT
def maxLen ( s , n ) : NEW_LINE INDENT if allones ( s , n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = 1 if s [ i ] == '0' else - 1 NEW_LINE DEDENT dp = [ [ - 1 ] * 3 for _ in range ( MAX ) ] NEW_LINE return findlength ( arr , s , n , 0 , 0 , dp ) NEW_LINE DEDENT
def countarray ( n , k , x ) : NEW_LINE INDENT dp = list ( ) NEW_LINE dp . append ( 0 ) NEW_LINE dp . append ( 1 ) NEW_LINE i = 2 NEW_LINE while i < n : NEW_LINE INDENT dp . append ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT return ( ( k - 1 ) * dp [ n - 2 ] if x == 1 else dp [ n - 1 ] ) NEW_LINE DEDENT
def countPalindromes ( k , n , l , r ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( k == 1 ) : NEW_LINE INDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT ans += l [ i ] [ n - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if ( k == 2 ) : NEW_LINE INDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT ans += ( ( l [ i ] [ n - 1 ] * ( l [ i ] [ n - 1 ] - 1 ) ) / 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT for j in range ( MAX_CHAR ) : NEW_LINE INDENT ans += l [ j ] [ i - 1 ] * r [ j ] [ i + 1 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 2 * ( ord ( X [ i - 1 ] ) - 48 ) NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT
def findMinCost ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE cost = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT cost += ord ( X [ i ] ) - 48 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT cost += ord ( Y [ i ] ) - 48 NEW_LINE DEDENT ans = cost - lcs ( X , Y , m , n ) NEW_LINE return ans NEW_LINE DEDENT
def isSubsetSum ( arr , n , sum ) : NEW_LINE INDENT subset = [ [ False for x in range ( n + 1 ) ] for y in range ( sum + 1 ) ] NEW_LINE count = [ [ 0 for x in range ( n + 1 ) ] for y in range ( sum + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = True NEW_LINE count [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = False NEW_LINE count [ i ] [ 0 ] = - 1 NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i ] [ j - 1 ] NEW_LINE count [ i ] [ j ] = count [ i ] [ j - 1 ] NEW_LINE if ( i >= arr [ j - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i ] [ j ] or subset [ i - arr [ j - 1 ] ] [ j - 1 ] ) NEW_LINE if ( subset [ i ] [ j ] ) : NEW_LINE INDENT count [ i ] [ j ] = ( max ( count [ i ] [ j - 1 ] , count [ i - arr [ j - 1 ] ] [ j - 1 ] + 1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return count [ sum ] [ n ] NEW_LINE DEDENT
def answer ( n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT for j in range ( 10 ) : NEW_LINE INDENT dp [ 1 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT elif ( j == 9 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT sum = sum + dp [ n ] [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isSubSeqDivisible ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE arr = [ int ( ch ) for ch in st ] NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def maxLength ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 2 NEW_LINE DEDENT DEDENT for l in range ( 2 , n ) : NEW_LINE INDENT i = - 1 NEW_LINE for j in range ( l , n ) : NEW_LINE INDENT i += 1 NEW_LINE if ( s [ i ] == '(' and s [ j ] == ')' ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def maxLength ( s , n ) : NEW_LINE INDENT invalidOpenBraces = 0 NEW_LINE invalidCloseBraces = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '(' ) : NEW_LINE INDENT invalidOpenBraces += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( invalidOpenBraces == 0 ) : NEW_LINE INDENT invalidCloseBraces += 1 NEW_LINE DEDENT else : NEW_LINE INDENT invalidOpenBraces -= 1 NEW_LINE DEDENT DEDENT DEDENT return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) NEW_LINE DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ ] NEW_LINE dp . append ( 1 ) NEW_LINE dp . append ( 1 ) NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp . append ( dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return ( dp [ x ] ) NEW_LINE DEDENT
def dfs ( node , parent , tree , colour , answer ) : NEW_LINE INDENT answer [ node ] = colour [ node ] NEW_LINE for u in tree [ node ] : NEW_LINE INDENT if ( u == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( u , node , tree , colour , answer ) NEW_LINE answer [ node ] += max ( answer [ u ] , 0 ) NEW_LINE DEDENT DEDENT
def maxDiff ( tree , colour , N ) : NEW_LINE INDENT answer = [ 0 for _ in range ( N + 1 ) ] NEW_LINE dfs ( 1 , 0 , tree , colour , answer ) NEW_LINE high = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT high = max ( high , answer [ i ] ) NEW_LINE answer [ i ] = 0 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if colour [ i ] == - 1 : NEW_LINE INDENT colour [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT colour [ i ] = - 1 NEW_LINE DEDENT DEDENT dfs ( 1 , 0 , tree , colour , answer ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT high = max ( high , answer [ i ] ) NEW_LINE DEDENT return high NEW_LINE DEDENT
def alternateSubarray ( arr , n ) : NEW_LINE INDENT len = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT len . append ( 0 ) NEW_LINE DEDENT len [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] ^ arr [ i + 1 ] == True ) : NEW_LINE INDENT len [ i ] = len [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT len [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( len [ i ] , " " , end = "" ) NEW_LINE DEDENT DEDENT
def alternateSubarray ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ prev ) == 0 ) : NEW_LINE INDENT while ( count ) : NEW_LINE INDENT print ( count , end = " " ) NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT count += 1 NEW_LINE prev = arr [ i ] NEW_LINE DEDENT while ( count ) : NEW_LINE INDENT print ( count , end = " " ) NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT
def lcs ( dp , arr1 , n , arr2 , m , k ) : NEW_LINE INDENT if k < 0 : NEW_LINE INDENT return - ( 10 ** 7 ) NEW_LINE DEDENT if n < 0 or m < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ans != - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) NEW_LINE if arr1 [ n - 1 ] == arr2 [ m - 1 ] : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT ans = max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE return ans NEW_LINE DEDENT
def productSubSeqCount ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE if arr [ j - 1 ] <= i and arr [ j - 1 ] > 0 : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i // arr [ j - 1 ] ] [ j - 1 ] + 1 NEW_LINE DEDENT DEDENT DEDENT return dp [ k ] [ n ] NEW_LINE DEDENT
def waysToArrange ( N , K , k ) : NEW_LINE INDENT C = np . zeros ( ( N + 1 , N + 1 ) ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT dp = np . zeros ( ( K + 1 ) ) NEW_LINE count = 0 NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( K ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) NEW_LINE count += k [ i ] NEW_LINE DEDENT return dp [ K ] NEW_LINE DEDENT
def LIP ( dp , mat , n , m , x , y ) : NEW_LINE INDENT if ( dp [ x ] [ y ] < 0 ) : NEW_LINE INDENT result = 0 NEW_LINE if ( x == n - 1 and y == m - 1 ) : NEW_LINE INDENT dp [ x ] [ y ] = 1 NEW_LINE return dp [ x ] [ y ] NEW_LINE DEDENT if ( x == n - 1 or y == m - 1 ) : NEW_LINE INDENT result = 1 NEW_LINE DEDENT if ( x + 1 < n and mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) : NEW_LINE INDENT result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) NEW_LINE DEDENT if ( y + 1 < m and mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) : NEW_LINE INDENT result = max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) NEW_LINE DEDENT dp [ x ] [ y ] = result NEW_LINE DEDENT return dp [ x ] [ y ] NEW_LINE DEDENT
def wrapper ( mat , n , m ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE return LIP ( dp , mat , n , m , 0 , 0 ) NEW_LINE DEDENT
def minCells ( mat , m , n ) : NEW_LINE INDENT dp = [ [ MAX for i in range ( n ) ] for i in range ( m ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( dp [ i ] [ j ] != MAX and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) : NEW_LINE INDENT dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT if ( dp [ i ] [ j ] != MAX and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) : NEW_LINE INDENT dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT if ( dp [ m - 1 ] [ n - 1 ] != MAX ) : NEW_LINE INDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def GetCeilIndex ( arr , T , l , r , key ) : NEW_LINE INDENT while ( r - l > 1 ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if ( arr [ T [ m ] ] >= key ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT
def LIS ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ tailIndices [ 0 ] ] ) : NEW_LINE INDENT tailIndices [ 0 ] = i NEW_LINE DEDENT elif ( arr [ i ] > arr [ tailIndices [ leN - 1 ] ] ) : NEW_LINE INDENT prevIndices [ i ] = tailIndices [ leN - 1 ] NEW_LINE tailIndices [ leN ] = i NEW_LINE leN += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = GetCeilIndex ( arr , tailIndices , - 1 , leN - 1 , arr [ i ] ) NEW_LINE prevIndices [ i ] = tailIndices [ pos - 1 ] NEW_LINE tailIndices [ pos ] = i NEW_LINE DEDENT DEDENT i = tailIndices [ leN - 1 ] NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT res . append ( arr [ i ] ) NEW_LINE i = prevIndices [ i ] NEW_LINE DEDENT DEDENT
def longestBitonic ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT global res NEW_LINE LIS ( arr1 , n1 ) NEW_LINE res = res [ : : - 1 ] NEW_LINE arr2 = arr2 [ : : - 1 ] NEW_LINE LIS ( arr2 , n2 ) NEW_LINE for i in res : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def ElementsCalculationFunc ( pre , maxx , x , k , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = x NEW_LINE while j <= n : NEW_LINE INDENT if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def solve ( dp , a , low , high , turn ) : NEW_LINE INDENT if ( low == high ) : NEW_LINE INDENT return a [ low ] * turn NEW_LINE DEDENT if ( dp [ low ] [ high ] != 0 ) : NEW_LINE INDENT return dp [ low ] [ high ] NEW_LINE DEDENT dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) NEW_LINE return dp [ low ] [ high ] NEW_LINE DEDENT
def cal ( ones , x , y , k ) : NEW_LINE INDENT return ( ones [ x + k - 1 ] [ y + k - 1 ] - ones [ x - 1 ] [ y + k - 1 ] - ones [ x + k - 1 ] [ y - 1 ] + ones [ x - 1 ] [ y - 1 ] ) NEW_LINE DEDENT
def sol ( mat ) : NEW_LINE INDENT ans = 0 NEW_LINE ones = [ [ 0 for i in range ( C + 1 ) ] for i in range ( R + 1 ) ] NEW_LINE for i in range ( 1 , R + 1 , 1 ) : NEW_LINE INDENT for j in range ( 1 , C + 1 , 1 ) : NEW_LINE INDENT ones [ i ] [ j ] = ( ones [ i - 1 ] [ j ] + ones [ i ] [ j - 1 ] - ones [ i - 1 ] [ j - 1 ] + ( mat [ i - 1 ] [ j - 1 ] == 1 ) ) NEW_LINE DEDENT DEDENT for k in range ( 1 , min ( R , C ) + 1 , 1 ) : NEW_LINE INDENT for i in range ( 1 , R - k + 2 , 1 ) : NEW_LINE INDENT for j in range ( 1 , C - k + 2 , 1 ) : NEW_LINE INDENT ans = max ( ans , ( ones [ R ] [ C ] + k * k - 2 * cal ( ones , i , j , k ) ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT msis = [ None ] * n NEW_LINE msds = [ None ] * n NEW_LINE max_sum = 0 NEW_LINE msis [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT msis [ i ] = msis [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT msds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT msds [ i ] = msds [ i + 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : NEW_LINE INDENT max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT
def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT max_sum = - 10 ** 9 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i NEW_LINE while ( j + 1 < n and arr [ j ] < arr [ j + 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT while ( i < j and arr [ i ] <= 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT k = j NEW_LINE while ( k + 1 < n and arr [ k ] > arr [ k + 1 ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT last = k NEW_LINE while ( k > j and arr [ k ] <= 0 ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT nn = arr [ i : j + 1 ] NEW_LINE sum_inc = sum ( nn ) NEW_LINE nn = arr [ j : k + 1 ] NEW_LINE sum_dec = sum ( nn ) NEW_LINE sum_all = sum_inc + sum_dec - arr [ j ] NEW_LINE max_sum = max ( [ max_sum , sum_inc , sum_dec , sum_all ] ) NEW_LINE i = max ( last , i + 1 ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT dp = [ [ 0 ] * ( n + 1 ) for i in range ( 2 ) ] NEW_LINE dp [ 0 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] NEW_LINE dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) NEW_LINE DEDENT return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] NEW_LINE DEDENT
def countways ( n ) : NEW_LINE INDENT A = [ 0 for i in range ( n + 2 ) ] NEW_LINE A [ 0 ] = 1 NEW_LINE A [ 1 ] = 3 NEW_LINE A [ 2 ] = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] NEW_LINE DEDENT return A [ n ] NEW_LINE DEDENT
def findWinner ( x , y , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = False NEW_LINE dp [ 1 ] = True NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i - 1 >= 0 and not dp [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT elif ( i - x >= 0 and not dp [ i - x ] ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT elif ( i - y >= 0 and not dp [ i - y ] ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = False NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def printSuperSeq ( a , b ) : NEW_LINE INDENT m = len ( a ) NEW_LINE n = len ( b ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] NEW_LINE for i in range ( 0 , m + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT if not i : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif not j : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT index = dp [ m ] [ n ] NEW_LINE res = [ "" ] * ( index ) NEW_LINE i = m NEW_LINE j = n NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT res [ index - 1 ] = a [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT elif ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) : NEW_LINE INDENT res [ index - 1 ] = a [ i - 1 ] NEW_LINE i -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res [ index - 1 ] = b [ j - 1 ] NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT while ( i > 0 ) : NEW_LINE INDENT res [ index - 1 ] = a [ i - 1 ] NEW_LINE i -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT while ( j > 0 ) : NEW_LINE INDENT res [ index - 1 ] = b [ j - 1 ] NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT print ( "" . join ( res ) ) NEW_LINE DEDENT
def maxGameByWinner ( N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 2 NEW_LINE i = 1 NEW_LINE while dp [ i ] <= N : NEW_LINE INDENT i = i + 1 NEW_LINE dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] NEW_LINE DEDENT return ( i - 1 ) NEW_LINE DEDENT
def isSubsetSum ( arr , n , sum ) : NEW_LINE INDENT subset = [ [ False for j in range ( sum + 1 ) ] for i in range ( 3 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( sum + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = True NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = False NEW_LINE DEDENT elif ( arr [ i - 1 ] <= j ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return subset [ n % 2 ] [ sum ] NEW_LINE DEDENT
def countTransformation ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if m == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ [ 0 ] * ( n ) for _ in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT if a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT elif a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
def getSpecialNumber ( N ) : NEW_LINE INDENT return ans ( N ) NEW_LINE DEDENT
def minimumSquare ( m , n ) : NEW_LINE INDENT vertical_min = 10000000000 NEW_LINE horizontal_min = 10000000000 NEW_LINE if n == 13 and m == 11 : NEW_LINE INDENT return 6 NEW_LINE DEDENT if m == 13 and n == 11 : NEW_LINE INDENT return 6 NEW_LINE DEDENT if m == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if dp [ m ] [ n ] != 0 : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT for i in range ( 1 , m // 2 + 1 ) : NEW_LINE INDENT horizontal_min = min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) NEW_LINE DEDENT for j in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT vertical_min = min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) NEW_LINE DEDENT dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) // ( ( fact ( r ) * fact ( n - r ) ) ) NEW_LINE DEDENT
def countWays ( n , k ) : NEW_LINE INDENT total = k NEW_LINE mod = 1000000007 NEW_LINE same , diff = 0 , k NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT same = diff NEW_LINE diff = total * ( k - 1 ) NEW_LINE diff = diff % mod NEW_LINE total = ( same + diff ) % mod NEW_LINE DEDENT return total NEW_LINE DEDENT
def computeLIS ( circBuff , start , end , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( end ) ] NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( start + 1 , end ) : NEW_LINE INDENT for j in range ( start , i ) : NEW_LINE INDENT if ( circBuff [ i ] > circBuff [ j ] and LIS [ i ] < LIS [ j ] + 1 ) : NEW_LINE INDENT LIS [ i ] = LIS [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT res = - 100000 NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT res = max ( res , LIS [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def LICS ( arr , n ) : NEW_LINE INDENT circBuff = [ 0 for i in range ( 2 * n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT circBuff [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n , 2 * n ) : NEW_LINE INDENT circBuff [ i ] = arr [ i - n ] NEW_LINE DEDENT res = - 100000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = max ( computeLIS ( circBuff , i , i + n , n ) , res ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countBT ( h ) : NEW_LINE INDENT MOD = 1000000007 NEW_LINE dp = [ 0 for i in range ( h + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , h + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD NEW_LINE DEDENT return dp [ h ] NEW_LINE DEDENT
def minTimeForWritingChars ( N , insert , remov , cpy ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if N == 1 : NEW_LINE INDENT return insert NEW_LINE DEDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE dp [ 1 ] = insert NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i // 2 ] + cpy ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) // 2 ] + cpy + remov ) NEW_LINE DEDENT DEDENT return dp [ N ] NEW_LINE DEDENT
def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT
def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = min ( i , k ) NEW_LINE while ( j > 0 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT
def sumOfSubstrings ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE mf = 1 NEW_LINE for i in range ( len ( num ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( int ( num [ i ] ) ) * ( i + 1 ) * mf NEW_LINE mf = mf * 10 + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def countWays ( n , m ) : NEW_LINE INDENT count = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT count . append ( 0 ) NEW_LINE DEDENT count [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > m ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] NEW_LINE DEDENT elif ( i < m or i == 1 ) : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT
def maxSum ( grid , n ) : NEW_LINE INDENT incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT excl_new = max ( excl , incl ) NEW_LINE incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) NEW_LINE excl = excl_new NEW_LINE DEDENT return max ( excl , incl ) NEW_LINE DEDENT
def maxSumWithK ( a , n , k ) : NEW_LINE INDENT maxSum = [ 0 for i in range ( n ) ] NEW_LINE maxSum [ 0 ] = a [ 0 ] NEW_LINE curr_max = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_max = max ( a [ i ] , curr_max + a [ i ] ) NEW_LINE maxSum [ i ] = curr_max NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT result = sum NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + a [ i ] - a [ i - k ] NEW_LINE result = max ( result , sum ) NEW_LINE result = max ( result , sum + maxSum [ i - k ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT if m < n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) ) NEW_LINE return res NEW_LINE DEDENT
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif i < j : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif j == 1 : NEW_LINE INDENT T [ i ] [ j ] = i NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return T [ m ] [ n ] NEW_LINE DEDENT
def minInsertionStepToSortArray ( arr , N ) : NEW_LINE INDENT lis = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT max = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( max < lis [ i ] ) : NEW_LINE INDENT max = lis [ i ] NEW_LINE DEDENT DEDENT return ( N - max ) NEW_LINE DEDENT
def printDistinct ( str ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] != ' ' ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT n = i NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( count [ ord ( str [ i ] ) ] == 1 ) : NEW_LINE INDENT print ( str [ i ] , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def lcs ( str1 , str2 , m , n ) : NEW_LINE INDENT L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT
def countWaysToJump ( arr , n ) : NEW_LINE INDENT count_jump = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_jump [ i ] += 1 NEW_LINE DEDENT j = i + 1 NEW_LINE while ( j < n - 1 and j <= arr [ i ] + i ) : NEW_LINE INDENT if ( count_jump [ j ] != - 1 ) : NEW_LINE INDENT count_jump [ i ] += count_jump [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( count_jump [ i ] == 0 ) : NEW_LINE INDENT count_jump [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( count_jump [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def lis ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE lis = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( result < lis [ i ] ) : NEW_LINE INDENT result = lis [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def minStepToDeleteString ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ] NEW_LINE for l in range ( 1 , N + 1 ) : NEW_LINE INDENT i = 0 NEW_LINE j = l - 1 NEW_LINE while j < N : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] NEW_LINE if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT for K in range ( i + 2 , j + 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ K ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] [ N - 1 ] NEW_LINE DEDENT
def solve ( i , par , a , n , k , current_ans ) : NEW_LINE INDENT if ( par > k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT global ans NEW_LINE if ( par == k and i == n - 1 ) : NEW_LINE INDENT ans = min ( ans , current_ans ) NEW_LINE return 0 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) NEW_LINE DEDENT DEDENT
def minCost ( a , n , k ) : NEW_LINE INDENT dp = [ [ inf for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT for m in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
def getMinSteps ( n ) : NEW_LINE INDENT table = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT table [ i ] = n - i NEW_LINE DEDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( not ( i % 2 ) ) : NEW_LINE INDENT table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] ) NEW_LINE DEDENT if ( not ( i % 3 ) ) : NEW_LINE INDENT table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] ) NEW_LINE DEDENT DEDENT return table [ 1 ] NEW_LINE DEDENT
def minimumNumberOfDeletions ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE l = lps ( str ) NEW_LINE return ( n - l ) NEW_LINE DEDENT
def utility_fun_for_del ( Str , i , j ) : NEW_LINE INDENT if ( i >= j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( Str [ i ] == Str [ j ] ) : NEW_LINE INDENT return utility_fun_for_del ( Str , i + 1 , j - 1 ) NEW_LINE DEDENT return ( 1 + min ( utility_fun_for_del ( Str , i + 1 , j ) , utility_fun_for_del ( Str , i , j - 1 ) ) ) NEW_LINE DEDENT
def min_ele_del ( Str ) : NEW_LINE INDENT return utility_fun_for_del ( Str , 0 , len ( Str ) - 1 ) NEW_LINE DEDENT
def numofArray ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE di = [ [ ] for i in range ( MAX ) ] NEW_LINE mu = [ [ ] for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 2 * i , m + 1 , i ) : NEW_LINE INDENT di [ j ] . append ( i ) NEW_LINE mu [ i ] . append ( j ) NEW_LINE DEDENT di [ i ] . append ( i ) NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE for x in di [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT for x in mu [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] NEW_LINE di [ i ] . clear ( ) NEW_LINE mu [ i ] . clear ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def offeringNumber ( n , templeHeight ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT left = 0 NEW_LINE right = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) : NEW_LINE INDENT right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT sum += max ( right , left ) + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def stringReduction ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * 3 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT if ( count [ 0 ] == n or count [ 1 ] == n or count [ 2 ] == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def modularSum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ False for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( DP [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = [ False for i in range ( m ) ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT if ( DP [ ( j + arr [ i ] ) % m ] == False ) : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if ( temp [ j ] ) : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT return DP [ 0 ] NEW_LINE DEDENT
def maxSum ( tri , n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT tri [ 1 ] [ 1 ] = tri [ 1 ] [ 1 ] + tri [ 0 ] [ 0 ] NEW_LINE tri [ 1 ] [ 0 ] = tri [ 1 ] [ 0 ] + tri [ 0 ] [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT tri [ i ] [ 0 ] = tri [ i ] [ 0 ] + tri [ i - 1 ] [ 0 ] NEW_LINE tri [ i ] [ i ] = tri [ i ] [ i ] + tri [ i - 1 ] [ i - 1 ] NEW_LINE for j in range ( 1 , i ) : NEW_LINE INDENT if tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] >= tri [ i ] [ j ] + tri [ i - 1 ] [ j ] : NEW_LINE INDENT tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print max ( tri [ n - 1 ] ) NEW_LINE DEDENT
def largestZigZagSumRec ( mat , i , j , n ) : NEW_LINE INDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( i == n - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = mat [ i ] [ j ] NEW_LINE return ( dp [ i ] [ j ] ) NEW_LINE DEDENT zzs = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if ( k != j ) : NEW_LINE INDENT zzs = max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) NEW_LINE DEDENT DEDENT dp [ i ] [ j ] = ( zzs + mat [ i ] [ j ] ) NEW_LINE return ( dp [ i ] [ j ] ) NEW_LINE DEDENT
def largestZigZag ( mat , n ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT for k in range ( MAX ) : NEW_LINE INDENT dp [ i ] [ k ] = - 1 NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT res = max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countEndless ( input_mat , n ) : NEW_LINE INDENT row = np . zeros ( ( n , n ) ) NEW_LINE col = np . zeros ( ( n , n ) ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT isEndless = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( input_mat [ i ] [ j ] == 0 ) : NEW_LINE INDENT isEndless = 0 NEW_LINE DEDENT col [ i ] [ j ] = isEndless NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT isEndless = 1 NEW_LINE for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( input_mat [ i ] [ j ] == 0 ) : NEW_LINE INDENT isEndless = 0 NEW_LINE DEDENT row [ i ] [ j ] = isEndless NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( row [ i ] [ j ] and col [ i ] [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countSubsequences ( s ) : NEW_LINE INDENT aCount = 0 NEW_LINE bCount = 0 NEW_LINE cCount = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == 'a' ) : NEW_LINE INDENT aCount = ( 1 + 2 * aCount ) NEW_LINE DEDENT elif ( s [ i ] == 'b' ) : NEW_LINE INDENT bCount = ( aCount + 2 * bCount ) NEW_LINE DEDENT elif ( s [ i ] == 'c' ) : NEW_LINE INDENT cCount = ( bCount + 2 * cCount ) NEW_LINE DEDENT DEDENT return cCount NEW_LINE DEDENT
def maximumDifferenceSum ( arr , N ) : NEW_LINE INDENT dp = [ [ 0 , 0 ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) NEW_LINE DEDENT
def countStr ( n , bCount , cCount ) : NEW_LINE INDENT if ( bCount < 0 or cCount < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( bCount == 0 and cCount == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = countStr ( n - 1 , bCount , cCount ) NEW_LINE res += countStr ( n - 1 , bCount - 1 , cCount ) NEW_LINE res += countStr ( n - 1 , bCount , cCount - 1 ) NEW_LINE return res NEW_LINE DEDENT
def maxRevenue ( m , x , revenue , n , t ) : NEW_LINE INDENT maxRev = [ 0 ] * ( m + 1 ) NEW_LINE nxtbb = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( nxtbb < n ) : NEW_LINE INDENT if ( x [ nxtbb ] != i ) : NEW_LINE INDENT maxRev [ i ] = maxRev [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( i <= t ) : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) NEW_LINE DEDENT else : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) NEW_LINE DEDENT nxtbb += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxRev [ i ] = maxRev [ i - 1 ] NEW_LINE DEDENT DEDENT return maxRev [ m ] NEW_LINE DEDENT
def getMaxGold ( gold , m , n ) : NEW_LINE INDENT goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for row in range ( m ) : NEW_LINE INDENT if ( col == n - 1 ) : NEW_LINE INDENT right = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right = goldTable [ row ] [ col + 1 ] NEW_LINE DEDENT if ( row == 0 or col == n - 1 ) : NEW_LINE INDENT right_up = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_up = goldTable [ row - 1 ] [ col + 1 ] NEW_LINE DEDENT if ( row == m - 1 or col == n - 1 ) : NEW_LINE INDENT right_down = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_down = goldTable [ row + 1 ] [ col + 1 ] NEW_LINE DEDENT goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) NEW_LINE DEDENT DEDENT res = goldTable [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , goldTable [ i ] [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def largestKSubmatrix ( a ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( Row ) ] for y in range ( Col ) ] NEW_LINE result = 0 NEW_LINE for i in range ( Row ) : NEW_LINE INDENT for j in range ( Col ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT result = max ( result , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def countDivisibleSubseq ( str , n ) : NEW_LINE INDENT l = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ] NEW_LINE dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return dp [ l - 1 ] [ 0 ] NEW_LINE DEDENT
def MaximumPath ( Mat ) : NEW_LINE INDENT result = 0 NEW_LINE dp = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N ) ] NEW_LINE DEDENT
def probability ( k , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( k , n + 1 ) : NEW_LINE INDENT ans += fact [ n ] / ( fact [ i ] * fact [ n - i ] ) NEW_LINE DEDENT ans = ans / ( 1 << n ) NEW_LINE return ans NEW_LINE DEDENT
def precompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE fact [ 1 ] = 1 NEW_LINE for i in range ( 2 , 20 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT DEDENT
def probability ( k , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( k , n + 1 ) : NEW_LINE INDENT res = dp [ n ] - dp [ i ] - dp [ n - i ] - n NEW_LINE ans = ans + pow ( 2.0 , res ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def precompute ( ) : NEW_LINE INDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT dp [ i ] = log2 ( i ) + dp [ i - 1 ] NEW_LINE DEDENT DEDENT
def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) NEW_LINE dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] NEW_LINE if j >= 1 : NEW_LINE INDENT dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT
def canVote ( a , n , x ) : NEW_LINE INDENT dp = [ [ 0 ] * ( x + 1 ) for _ in range ( n + 1 ) ] NEW_LINE a = a [ : ] NEW_LINE a . append ( 0 ) NEW_LINE sm = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sm += a [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , x + 1 ) : NEW_LINE INDENT if a [ i ] <= j : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , a [ i ] + dp [ i - 1 ] [ j - a [ i ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return ( sm - dp [ n ] [ x ] ) <= x NEW_LINE DEDENT
def countFriendsPairings ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i <= 2 ) : NEW_LINE INDENT dp [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def countFriendsPairings ( n ) : NEW_LINE INDENT global dp NEW_LINE if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ) NEW_LINE return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ n ] = n NEW_LINE return dp [ n ] NEW_LINE DEDENT DEDENT
def countFriendsPairings ( n ) : NEW_LINE INDENT a , b , c = 1 , 2 , 0 NEW_LINE if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT for i in range ( 3 , n + 1 ) : NEW_LINE INDENT c = b + ( i - 1 ) * a NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return c NEW_LINE DEDENT
def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT
def findMaxPoints ( A ) : NEW_LINE INDENT P1S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P1E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P2S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P2E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT for j in range ( 2 , M ) : NEW_LINE INDENT op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] NEW_LINE op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] NEW_LINE ans = max ( ans , max ( op1 , op2 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def inside ( x , y ) : NEW_LINE INDENT return ( x >= 0 and x < N and y >= 0 and y < N ) NEW_LINE DEDENT
def findProb ( start_x , start_y , steps ) : NEW_LINE INDENT dp1 = [ [ [ 0 for i in range ( N + 5 ) ] for j in range ( N + 5 ) ] for k in range ( steps + 5 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT dp1 [ i ] [ j ] [ 0 ] = 1 NEW_LINE DEDENT DEDENT for s in range ( 1 , steps + 1 ) : NEW_LINE INDENT for x in range ( N ) : NEW_LINE INDENT for y in range ( N ) : NEW_LINE INDENT prob = 0.0 NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT nx = x + dx [ i ] NEW_LINE ny = y + dy [ i ] NEW_LINE if ( inside ( nx , ny ) ) : NEW_LINE INDENT prob += dp1 [ nx ] [ ny ] [ s - 1 ] / 8.0 NEW_LINE DEDENT DEDENT dp1 [ x ] [ y ] [ s ] = prob NEW_LINE DEDENT DEDENT DEDENT return dp1 [ start_x ] [ start_y ] [ steps ] NEW_LINE DEDENT
def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT
def lcsOf3 ( i , j , k ) : NEW_LINE INDENT if ( i == - 1 or j == - 1 or k == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT DEDENT
def distSumRec ( arr , n , sum , currindex , s ) : NEW_LINE INDENT if ( currindex > n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( currindex == n ) : NEW_LINE INDENT s . add ( sum ) NEW_LINE return NEW_LINE DEDENT distSumRec ( arr , n , sum + arr [ currindex ] , currindex + 1 , s ) NEW_LINE distSumRec ( arr , n , sum , currindex + 1 , s ) NEW_LINE DEDENT
def printDistSum ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE distSumRec ( arr , n , 0 , 0 , s ) NEW_LINE for i in s : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def printDistSum ( arr , n ) : NEW_LINE INDENT Sum = sum ( arr ) NEW_LINE dp = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = True NEW_LINE for j in range ( 1 , Sum + 1 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( Sum + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ j ] == True ) : NEW_LINE INDENT print ( j , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def printMaxSum ( arr , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE maxi = 0 NEW_LINE for j in range ( 1 , int ( ( i + 1 ) ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( ( i + 1 ) % j == 0 and ( i + 1 ) != j ) : NEW_LINE INDENT if ( dp [ j - 1 ] > maxi ) : NEW_LINE INDENT maxi = dp [ j - 1 ] NEW_LINE DEDENT if ( dp [ ( i + 1 ) // j - 1 ] > maxi and j != 1 ) : NEW_LINE INDENT maxi = dp [ ( i + 1 ) // j - 1 ] NEW_LINE DEDENT DEDENT DEDENT dp [ i ] += maxi NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( dp [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT
def countPaths ( maze ) : NEW_LINE INDENT if ( maze [ 0 ] [ 0 ] == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( R ) : NEW_LINE INDENT if ( maze [ i ] [ 0 ] == 0 ) : NEW_LINE INDENT maze [ i ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , C , 1 ) : NEW_LINE INDENT if ( maze [ 0 ] [ i ] == 0 ) : NEW_LINE INDENT maze [ 0 ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , R , 1 ) : NEW_LINE INDENT for j in range ( 1 , C , 1 ) : NEW_LINE INDENT if ( maze [ i ] [ j ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( maze [ i - 1 ] [ j ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) NEW_LINE DEDENT if ( maze [ i ] [ j - 1 ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if ( maze [ R - 1 ] [ C - 1 ] > 0 ) : NEW_LINE INDENT return maze [ R - 1 ] [ C - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return min ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ] ) ) NEW_LINE DEDENT if ( n == 4 ) : NEW_LINE INDENT return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) ) NEW_LINE DEDENT dp [ 0 ] = arr [ 0 ] NEW_LINE dp [ 1 ] = arr [ 1 ] NEW_LINE dp [ 2 ] = arr [ 2 ] NEW_LINE dp [ 3 ] = arr [ 3 ] NEW_LINE for i in range ( 4 , n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) NEW_LINE DEDENT return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) NEW_LINE DEDENT
def minSum ( ar , n ) : NEW_LINE INDENT if ( n <= 4 ) : NEW_LINE INDENT return min ( ar ) NEW_LINE DEDENT sum = [ 0 for i in range ( n ) ] NEW_LINE sum [ 0 ] = ar [ 0 ] NEW_LINE sum [ 1 ] = ar [ 1 ] NEW_LINE sum [ 2 ] = ar [ 2 ] NEW_LINE sum [ 3 ] = ar [ 3 ] NEW_LINE for i in range ( 4 , n ) : NEW_LINE INDENT sum [ i ] = ar [ i ] + min ( sum [ i - 4 : i ] ) NEW_LINE DEDENT return min ( sum [ n - 4 : n ] ) NEW_LINE DEDENT
def printMinAndMaxValueOfExp ( exp ) : NEW_LINE INDENT num = [ ] NEW_LINE opr = [ ] NEW_LINE tmp = "" NEW_LINE for i in range ( len ( exp ) ) : NEW_LINE INDENT if ( isOperator ( exp [ i ] ) ) : NEW_LINE INDENT opr . append ( exp [ i ] ) NEW_LINE num . append ( int ( tmp ) ) NEW_LINE tmp = "" NEW_LINE DEDENT else : NEW_LINE INDENT tmp += exp [ i ] NEW_LINE DEDENT DEDENT num . append ( int ( tmp ) ) NEW_LINE llen = len ( num ) NEW_LINE minVal = [ [ 0 for i in range ( llen ) ] for i in range ( llen ) ] NEW_LINE maxVal = [ [ 0 for i in range ( llen ) ] for i in range ( llen ) ] NEW_LINE for i in range ( llen ) : NEW_LINE INDENT for j in range ( llen ) : NEW_LINE INDENT minVal [ i ] [ j ] = 10 ** 9 NEW_LINE maxVal [ i ] [ j ] = 0 NEW_LINE if ( i == j ) : NEW_LINE INDENT minVal [ i ] [ j ] = maxVal [ i ] [ j ] = num [ i ] NEW_LINE DEDENT DEDENT DEDENT for L in range ( 2 , llen + 1 ) : NEW_LINE INDENT for i in range ( llen - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT minTmp = 0 NEW_LINE maxTmp = 0 NEW_LINE if ( opr [ k ] == '+' ) : NEW_LINE INDENT minTmp = minVal [ i ] [ k ] + minVal [ k + 1 ] [ j ] NEW_LINE maxTmp = maxVal [ i ] [ k ] + maxVal [ k + 1 ] [ j ] NEW_LINE DEDENT elif ( opr [ k ] == '*' ) : NEW_LINE INDENT minTmp = minVal [ i ] [ k ] * minVal [ k + 1 ] [ j ] NEW_LINE maxTmp = maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] NEW_LINE DEDENT if ( minTmp < minVal [ i ] [ j ] ) : NEW_LINE INDENT minVal [ i ] [ j ] = minTmp NEW_LINE DEDENT if ( maxTmp > maxVal [ i ] [ j ] ) : NEW_LINE INDENT maxVal [ i ] [ j ] = maxTmp NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( "Minimum value : " , minVal [ 0 ] [ llen - 1 ] , ", \ Maximum value : " , maxVal [ 0 ] [ llen - 1 ] ) NEW_LINE DEDENT
def maxDecimalValue ( mat , i , j , p ) : NEW_LINE INDENT if i >= N or j >= N : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) NEW_LINE if mat [ i ] [ j ] == 1 : NEW_LINE INDENT return pow ( 2 , p ) + result NEW_LINE DEDENT else : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT
def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 ** ( i + j ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT
def longestSubseqWithDiffOne ( arr , n ) : NEW_LINE INDENT dp = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT result = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < dp [ i ] ) : NEW_LINE INDENT result = dp [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def nCr ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT
def resultOfAllSubsets ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for n in range ( 1 , N + 1 ) : NEW_LINE INDENT result += ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n NEW_LINE DEDENT return result NEW_LINE DEDENT
def maxSumWO3Consec ( arr , n ) : NEW_LINE INDENT sum = [ 0 for k in range ( n ) ] NEW_LINE if n >= 1 : NEW_LINE INDENT sum [ 0 ] = arr [ 0 ] NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT sum [ 1 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE DEDENT if n > 2 : NEW_LINE INDENT sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) NEW_LINE DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) NEW_LINE DEDENT return sum [ n - 1 ] NEW_LINE DEDENT
def maxSumWO3Consec ( n ) : NEW_LINE INDENT if ( sum [ n ] != - 1 ) : NEW_LINE INDENT return sum [ n ] NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT sum [ n ] = 0 NEW_LINE return sum [ n ] NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT sum [ n ] = arr [ 0 ] NEW_LINE return sum [ n ] NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT sum [ n ] = arr [ 1 ] + arr [ 0 ] NEW_LINE return sum [ n ] NEW_LINE DEDENT sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) NEW_LINE return sum [ n ] NEW_LINE DEDENT
def maxAlternateSum ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT min = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT if ( arr [ 0 ] == min ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT dec = [ 0 for i in range ( n + 1 ) ] NEW_LINE inc = [ 0 for i in range ( n + 1 ) ] NEW_LINE dec [ 0 ] = inc [ 0 ] = arr [ 0 ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif ( arr [ j ] < arr [ i ] and flag == 1 ) : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT result = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < inc [ i ] ) : NEW_LINE INDENT result = inc [ i ] NEW_LINE DEDENT if ( result < dec [ i ] ) : NEW_LINE INDENT result = dec [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def maxSumPairWithDifferenceLessThanK ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dp = [ 0 ] * N NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] NEW_LINE if ( arr [ i ] - arr [ i - 1 ] < K ) : NEW_LINE INDENT if ( i >= 2 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ N - 1 ] NEW_LINE DEDENT
def printInorder ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT printInorder ( node . left ) NEW_LINE print ( node . val , end = " " ) NEW_LINE printInorder ( node . right ) NEW_LINE DEDENT
def lucas ( n ) : NEW_LINE INDENT a = 2 NEW_LINE b = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE DEDENT
def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) NEW_LINE DEDENT
def breakSum ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def countPS ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT cps [ i ] [ i ] = 1 NEW_LINE DEDENT for L in range ( 2 , N + 1 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT k = L + i - 1 NEW_LINE if ( k < N ) : NEW_LINE INDENT if ( str [ i ] == str [ k ] ) : NEW_LINE INDENT cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return cps [ 0 ] [ N - 1 ] NEW_LINE DEDENT
def countPS ( i , j ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT DEDENT
def lcs ( str1 , str2 , len1 , len2 , i , j ) : NEW_LINE INDENT if ( i == len1 or j == len2 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT ret = 0 NEW_LINE if ( str1 [ i ] == str2 [ j ] ) : NEW_LINE INDENT ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ret = max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) NEW_LINE DEDENT dp [ i ] [ j ] = ret NEW_LINE return ret NEW_LINE DEDENT
def prinlAllLCSSorted ( str1 , str2 ) : NEW_LINE INDENT global lcslen NEW_LINE len1 , len2 = len ( str1 ) , len ( str2 ) NEW_LINE lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) NEW_LINE data = [ 'a' for i in range ( MAX ) ] NEW_LINE printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) NEW_LINE DEDENT
def maxCost ( mat , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , min ( i + 1 , N ) ) : NEW_LINE INDENT dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( result < dp [ N - 1 ] [ i ] ) : NEW_LINE INDENT result = dp [ N - 1 ] [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( K == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( memo [ N ] [ K ] != 0 ) : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermWithKInversion ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT
def countSub ( arr , n ) : NEW_LINE INDENT count = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( arr [ i ] - 1 , - 1 , - 1 ) : NEW_LINE INDENT count [ arr [ i ] ] += count [ j ] NEW_LINE DEDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT result += count [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def minimum ( a , b , c ) : NEW_LINE INDENT return min ( min ( a , b ) , c ) NEW_LINE DEDENT
def countSub ( s ) : NEW_LINE INDENT Map = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT Map [ s [ i ] ] = - 1 NEW_LINE DEDENT allCount = 0 NEW_LINE levelCount = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT c = s [ i ] NEW_LINE if ( i == 0 ) : NEW_LINE INDENT allCount = 1 NEW_LINE Map = 1 NEW_LINE levelCount = 1 NEW_LINE continue NEW_LINE DEDENT levelCount = allCount + 1 NEW_LINE if ( Map < 0 ) : NEW_LINE INDENT allCount = allCount + levelCount NEW_LINE DEDENT else : NEW_LINE INDENT allCount = allCount + levelCount - Map NEW_LINE DEDENT Map = levelCount NEW_LINE DEDENT return allCount NEW_LINE DEDENT
def catalanDP ( n ) : NEW_LINE INDENT catalan = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - 1 ] ) NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT print ( "Invalid" ) NEW_LINE return 0 NEW_LINE DEDENT return catalanDP ( n // 2 ) NEW_LINE DEDENT
def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ position ] [ previous_sum ] != - 1 ) : NEW_LINE INDENT return dp [ position ] [ previous_sum ] NEW_LINE DEDENT dp [ position ] [ previous_sum ] = 0 NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum += ( ord ( num [ i ] ) - ord ( '0' ) ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res += countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT dp [ position ] [ previous_sum ] = res NEW_LINE return res NEW_LINE DEDENT
def MinimumCost ( cost , n , W ) : NEW_LINE INDENT val = list ( ) NEW_LINE wt = list ( ) NEW_LINE size = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( cost [ i ] != - 1 ) : NEW_LINE INDENT val . append ( cost [ i ] ) NEW_LINE wt . append ( i + 1 ) NEW_LINE size += 1 NEW_LINE DEDENT DEDENT n = size NEW_LINE min_cost = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( W + 1 ) : NEW_LINE INDENT min_cost [ 0 ] [ i ] = INF NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT min_cost [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , W + 1 ) : NEW_LINE INDENT if ( wt [ i - 1 ] > j ) : NEW_LINE INDENT min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if ( min_cost [ n ] [ W ] == INF ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return min_cost [ n ] [ W ] NEW_LINE DEDENT DEDENT
def minCost ( cost , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT min_cost = sys . maxsize NEW_LINE for j in range ( i ) : NEW_LINE INDENT if j < len ( cost ) and cost [ j ] != - 1 : NEW_LINE INDENT min_cost = min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) NEW_LINE DEDENT DEDENT dp [ i ] = min_cost NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT dp = [ 0 ] * ( W + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( W , wt [ i ] , - 1 ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) NEW_LINE DEDENT DEDENT return dp [ W ] NEW_LINE DEDENT
def count ( a , b , m , n ) : NEW_LINE INDENT if ( ( m == 0 and n == 0 ) or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a [ m - 1 ] == b [ n - 1 ] ) : NEW_LINE INDENT return ( count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( a , b , m - 1 , n ) NEW_LINE DEDENT DEDENT
def count ( a , b ) : NEW_LINE INDENT m = len ( a ) NEW_LINE n = len ( b ) NEW_LINE lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT lookup [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( m + 1 ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if a [ i - 1 ] == b [ j - 1 ] : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return lookup [ m ] [ n ] NEW_LINE DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif X [ i - 1 ] == Y [ j - 1 ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT
def findMinCost ( X , Y , costX , costY ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE len_LCS = lcs ( X , Y , m , n ) NEW_LINE return ( costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ) NEW_LINE DEDENT
def findSum ( arr ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in arr : NEW_LINE INDENT summ += i NEW_LINE DEDENT return summ NEW_LINE DEDENT
def maxTasks ( high , low , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) NEW_LINE DEDENT
def maxTasks ( high , low , n ) : NEW_LINE INDENT task_dp = [ 0 ] * ( n + 1 ) NEW_LINE task_dp [ 0 ] = 0 NEW_LINE task_dp [ 1 ] = high [ 0 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT task_dp [ i ] = max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) NEW_LINE DEDENT return task_dp [ n ] NEW_LINE DEDENT
def findLCS ( x , y , m , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE if m == 0 or n == 0 : NEW_LINE INDENT s . add ( "" ) NEW_LINE return s NEW_LINE DEDENT if x [ m - 1 ] == y [ n - 1 ] : NEW_LINE INDENT tmp = findLCS ( x , y , m - 1 , n - 1 ) NEW_LINE for string in tmp : NEW_LINE INDENT s . add ( string + x [ m - 1 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if L [ m - 1 ] [ n ] >= L [ m ] [ n - 1 ] : NEW_LINE INDENT s = findLCS ( x , y , m - 1 , n ) NEW_LINE DEDENT if L [ m ] [ n - 1 ] >= L [ m - 1 ] [ n ] : NEW_LINE INDENT tmp = findLCS ( x , y , m , n - 1 ) NEW_LINE for i in tmp : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT DEDENT DEDENT return s NEW_LINE DEDENT
def LCS ( x , y , m , n ) : NEW_LINE INDENT for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif x [ i - 1 ] == y [ j - 1 ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT if i + j + k == n : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def countIntegralSolutions ( n ) : NEW_LINE INDENT return int ( ( ( n + 1 ) * ( n + 2 ) ) / 2 ) NEW_LINE DEDENT
def LCIS ( arr1 , n , arr2 , m ) : NEW_LINE INDENT table = [ 0 ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT table [ j ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT current = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( current + 1 > table [ j ] ) : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT DEDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT if ( table [ j ] > current ) : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( table [ i ] > result ) : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def minTime ( arr , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def lcs ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ] NEW_LINE bi = bool NEW_LINE for i in range ( m ) : NEW_LINE INDENT bi = i & 1 NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ bi ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ bi ] [ n ] NEW_LINE DEDENT
def countUtil ( p , q , r ) : NEW_LINE INDENT return ( countWays ( p , q , r , 0 ) + countWays ( p , q , r , 1 ) + countWays ( p , q , r , 2 ) ) NEW_LINE DEDENT
def countWays ( p , q , r , last ) : NEW_LINE INDENT if ( p < 0 or q < 0 or r < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( p == 1 and q == 0 and r == 0 and last == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( p == 0 and q == 1 and r == 0 and last == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( p == 0 and q == 0 and r == 1 and last == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ p ] [ q ] [ r ] [ last ] != - 1 ) : NEW_LINE INDENT return dp [ p ] [ q ] [ r ] [ last ] NEW_LINE DEDENT if ( last == 0 ) : NEW_LINE INDENT dp [ p ] [ q ] [ r ] [ last ] = ( countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ) NEW_LINE DEDENT elif ( last == 1 ) : NEW_LINE INDENT dp [ p ] [ q ] [ r ] [ last ] = ( countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ p ] [ q ] [ r ] [ last ] = ( countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ) NEW_LINE DEDENT return dp [ p ] [ q ] [ r ] [ last ] NEW_LINE DEDENT
def countUtil ( p , q , r ) : NEW_LINE INDENT return ( countWays ( p , q , r , 0 ) + countWays ( p , q , r , 1 ) + countWays ( p , q , r , 2 ) ) NEW_LINE DEDENT
def multiply ( a , b ) : NEW_LINE INDENT mul = [ [ 0 for x in range ( 3 ) ] for y in range ( 3 ) ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] = 0 NEW_LINE for k in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT a [ i ] [ j ] = mul [ i ] [ j ] NEW_LINE DEDENT return a NEW_LINE DEDENT DEDENT
def power ( F , n ) : NEW_LINE INDENT M = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] NEW_LINE DEDENT power ( F , int ( n / 2 ) ) NEW_LINE F = multiply ( F , F ) NEW_LINE if ( n % 2 != 0 ) : NEW_LINE INDENT F = multiply ( F , M ) NEW_LINE DEDENT return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] NEW_LINE return power ( F , n - 2 ) NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i <= 3 : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT elif i == 4 : NEW_LINE INDENT dp [ i ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def KSmallestUsingMorris ( root , k ) : NEW_LINE INDENT count = 0 NEW_LINE ksmall = - 9999999999 NEW_LINE curr = root NEW_LINE while curr != None : NEW_LINE INDENT if curr . left == None : NEW_LINE INDENT count += 1 NEW_LINE if count == k : NEW_LINE INDENT ksmall = curr . key NEW_LINE DEDENT curr = curr . right NEW_LINE DEDENT else : NEW_LINE INDENT pre = curr . left NEW_LINE while ( pre . right != None and pre . right != curr ) : NEW_LINE INDENT pre = pre . right NEW_LINE DEDENT if pre . right == None : NEW_LINE INDENT pre . right = curr NEW_LINE curr = curr . left NEW_LINE DEDENT else : NEW_LINE INDENT pre . right = None NEW_LINE count += 1 NEW_LINE if count == k : NEW_LINE INDENT ksmall = curr . key NEW_LINE DEDENT curr = curr . right NEW_LINE DEDENT DEDENT DEDENT return ksmall NEW_LINE DEDENT
def subsetXOR ( arr , n , k ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max_ele : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << ( int ) ( math . log2 ( max_ele ) + 1 ) ) - 1 NEW_LINE if ( k > m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ [ 0 for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
def permutationCoeff ( n , k ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT return int ( fact [ n ] / fact [ n - k ] ) NEW_LINE DEDENT
def findMin ( arr , n ) : NEW_LINE INDENT sumTotal = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sumTotal += arr [ i ] NEW_LINE DEDENT return findMinRec ( arr , n , 0 , sumTotal ) NEW_LINE DEDENT
def countDer ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) NEW_LINE DEDENT
def countDer ( n ) : NEW_LINE INDENT der = [ 0 for i in range ( n + 1 ) ] NEW_LINE der [ 1 ] = 0 NEW_LINE der [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) NEW_LINE DEDENT return der [ n ] NEW_LINE DEDENT
def countDer ( n ) : NEW_LINE INDENT if n == 1 or n == 2 : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT cur = ( i - 1 ) * ( a + b ) NEW_LINE a = b NEW_LINE b = cur NEW_LINE DEDENT return b NEW_LINE DEDENT
def bellNumber ( n ) : NEW_LINE INDENT bell = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE bell [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return bell [ n ] [ 0 ] NEW_LINE DEDENT
def minSizeRec ( arr , low , high , k ) : NEW_LINE INDENT if dp [ low ] [ high ] != - 1 : NEW_LINE INDENT return dp [ low ] [ high ] NEW_LINE DEDENT if ( high - low + 1 ) < 3 : NEW_LINE INDENT return ( high - low + 1 ) NEW_LINE DEDENT res = 1 + minSizeRec ( arr , low + 1 , high , k ) NEW_LINE for i in range ( low + 1 , high ) : NEW_LINE INDENT for j in range ( i + 1 , high + 1 ) : NEW_LINE INDENT if ( arr [ i ] == ( arr [ low ] + k ) and arr [ j ] == ( arr [ low ] + 2 * k ) and minSizeRec ( arr , low + 1 , i - 1 , k ) == 0 and minSizeRec ( arr , i + 1 , j - 1 , k ) == 0 ) : NEW_LINE INDENT res = min ( res , minSizeRec ( arr , j + 1 , high , k ) ) NEW_LINE DEDENT DEDENT DEDENT dp [ low ] [ high ] = res NEW_LINE return res NEW_LINE DEDENT
def countSol ( coeff , start , end , rhs ) : NEW_LINE INDENT if ( rhs == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( coeff [ i ] <= rhs ) : NEW_LINE INDENT result += countSol ( coeff , i , end , rhs - coeff [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def countSol ( coeff , n , rhs ) : NEW_LINE INDENT dp = [ 0 for i in range ( rhs + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( coeff [ i ] , rhs + 1 ) : NEW_LINE INDENT dp [ j ] += dp [ j - coeff [ i ] ] NEW_LINE DEDENT DEDENT return dp [ rhs ] NEW_LINE DEDENT
def printCountRec ( dist ) : NEW_LINE INDENT if dist < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dist == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ) NEW_LINE DEDENT
def printCountDP ( dist ) : NEW_LINE INDENT count = [ 0 ] * ( dist + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE if dist >= 1 : NEW_LINE INDENT count [ 1 ] = 1 NEW_LINE DEDENT if dist >= 2 : NEW_LINE INDENT count [ 2 ] = 2 NEW_LINE DEDENT for i in range ( 3 , dist + 1 ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ) NEW_LINE DEDENT return count [ dist ] NEW_LINE DEDENT
def countSeq ( n ) : NEW_LINE INDENT nCr = 1 NEW_LINE res = 1 NEW_LINE for r in range ( 1 , n + 1 ) : NEW_LINE INDENT nCr = ( nCr * ( n + 1 - r ) ) / r NEW_LINE res += nCr * nCr NEW_LINE DEDENT return res NEW_LINE DEDENT
def findLongestRepeatingSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT
def isInorder ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def getMaxRec ( string , i , n , lookup ) : NEW_LINE INDENT if i >= n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if lookup [ i ] != - 1 : NEW_LINE INDENT return lookup [ i ] NEW_LINE DEDENT ans = 1 + getMaxRec ( string , i + 1 , n , lookup ) NEW_LINE if i + 1 < n : NEW_LINE INDENT if string [ i ] != string [ i + 1 ] : NEW_LINE INDENT ans = max ( 4 + getMaxRec ( string , i + 2 , n , lookup ) , ans ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( 3 + getMaxRec ( string , i + 2 , n , lookup ) , ans ) NEW_LINE DEDENT DEDENT lookup [ i ] = ans NEW_LINE return ans NEW_LINE DEDENT
def getMaxWeight ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE lookup = [ - 1 ] * ( n ) NEW_LINE return getMaxRec ( string , 0 , len ( string ) , lookup ) NEW_LINE DEDENT
def countRec ( digits , esum , osum , isOdd , n ) : NEW_LINE INDENT if digits == n : NEW_LINE INDENT return ( esum - osum == 1 ) NEW_LINE DEDENT if lookup [ digits ] [ esum ] [ osum ] [ isOdd ] != - 1 : NEW_LINE INDENT return lookup [ digits ] [ esum ] [ osum ] [ isOdd ] NEW_LINE DEDENT ans = 0 NEW_LINE if isOdd : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum , osum + i , False , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , True , n ) NEW_LINE DEDENT DEDENT lookup [ digits ] [ esum ] [ osum ] [ isOdd ] = ans NEW_LINE return ans NEW_LINE DEDENT
def finalCount ( n ) : NEW_LINE INDENT global lookup NEW_LINE digits = 0 NEW_LINE lookup = [ [ [ [ - 1 , - 1 ] for i in range ( 500 ) ] for j in range ( 500 ) ] for k in range ( 50 ) ] NEW_LINE ans = 0 NEW_LINE esum = 0 NEW_LINE osum = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , True , n ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def steps ( source , step , dest ) : NEW_LINE INDENT if ( abs ( source ) > ( dest ) ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( source == dest ) : NEW_LINE INDENT return step NEW_LINE DEDENT pos = steps ( source + step + 1 , step + 1 , dest ) NEW_LINE neg = steps ( source - step - 1 , step + 1 , dest ) NEW_LINE return min ( pos , neg ) NEW_LINE DEDENT
def countNumbersWith4 ( n ) : NEW_LINE INDENT for x in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( has4 ( x ) == True ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = int ( mt . log10 ( n ) ) NEW_LINE a = [ 1 for i in range ( d + 1 ) ] NEW_LINE a [ 0 ] = 0 NEW_LINE if len ( a ) > 1 : NEW_LINE INDENT a [ 1 ] = 1 NEW_LINE DEDENT for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + mt . ceil ( pow ( 10 , i - 1 ) ) NEW_LINE DEDENT p = mt . ceil ( pow ( 10 , d ) ) NEW_LINE msd = n // p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ) NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT
def max ( arr , l , h ) : NEW_LINE INDENT mx = arr [ l ] NEW_LINE for i in range ( l + 1 , h + 1 ) : NEW_LINE INDENT if ( mx < arr [ i ] ) : NEW_LINE INDENT mx = arr [ i ] NEW_LINE DEDENT DEDENT return mx NEW_LINE DEDENT
def minRemovalsDP ( arr , n ) : NEW_LINE INDENT table = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for gap in range ( n ) : NEW_LINE INDENT i = 0 NEW_LINE for j in range ( gap , n ) : NEW_LINE INDENT mn = min1 ( arr , i , j ) NEW_LINE mx = max1 ( arr , i , j ) NEW_LINE table [ i ] [ j ] = 0 if ( 2 * mn > mx ) else min ( table [ i ] [ j - 1 ] + 1 , table [ i + 1 ] [ j ] + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return table [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def minRemovalsDP ( arr , n ) : NEW_LINE INDENT longest_start = - 1 NEW_LINE longest_end = 0 NEW_LINE for start in range ( n ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE max = - sys . maxsize NEW_LINE for end in range ( start , n ) : NEW_LINE INDENT val = arr [ end ] NEW_LINE if ( val < min ) : NEW_LINE INDENT min = val NEW_LINE DEDENT if ( val > max ) : NEW_LINE INDENT max = val NEW_LINE DEDENT if ( 2 * min <= max ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( end - start > longest_end - longest_start or longest_start == - 1 ) : NEW_LINE INDENT longest_start = start NEW_LINE longest_end = end NEW_LINE DEDENT DEDENT DEDENT if ( longest_start == - 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n - ( longest_end - longest_start + 1 ) ) NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for x in range ( n ) ] for y in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
def numberOfPaths ( p , q ) : NEW_LINE INDENT dp = [ 1 for i in range ( q ) ] NEW_LINE for i in range ( p - 1 ) : NEW_LINE INDENT for j in range ( 1 , q ) : NEW_LINE INDENT dp [ j ] += dp [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ q - 1 ] NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT for i in range ( n , ( m + n - 1 ) ) : NEW_LINE INDENT path *= i NEW_LINE path //= ( i - n + 1 ) NEW_LINE DEDENT return path NEW_LINE DEDENT
def checkBSTs ( root1 , root2 ) : NEW_LINE INDENT if ( root1 != None and root2 != None ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( root1 == None and root2 != None ) or ( root1 != None and root2 == None ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE v = v1 NEW_LINE storeInorder ( root1 ) NEW_LINE v1 = v NEW_LINE v = v2 NEW_LINE storeInorder ( root2 ) NEW_LINE v2 = v NEW_LINE return ( v1 == v2 ) NEW_LINE DEDENT
def lenghtOfLongestAP ( set , n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE llap = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE DEDENT for j in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1 NEW_LINE llap = max ( llap , L [ i ] [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return llap NEW_LINE DEDENT
def carAssembly ( a , t , e , x ) : NEW_LINE INDENT NUM_STATION = len ( a [ 0 ] ) NEW_LINE T1 = [ 0 for i in range ( NUM_STATION ) ] NEW_LINE T2 = [ 0 for i in range ( NUM_STATION ) ] NEW_LINE DEDENT
def findWays ( m , n , x ) : NEW_LINE INDENT table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ] NEW_LINE for j in range ( 1 , min ( m + 1 , x + 1 ) ) : NEW_LINE INDENT table [ 1 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , x + 1 ) : NEW_LINE INDENT for k in range ( 1 , min ( m + 1 , j ) ) : NEW_LINE INDENT table [ i ] [ j ] += table [ i - 1 ] [ j - k ] NEW_LINE DEDENT DEDENT DEDENT return table [ - 1 ] [ - 1 ] NEW_LINE DEDENT
def findWays ( f , d , s ) : NEW_LINE INDENT mem = [ [ 0 for i in range ( s + 1 ) ] for j in range ( d + 1 ) ] NEW_LINE mem [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT for j in range ( 1 , s + 1 ) : NEW_LINE INDENT mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] NEW_LINE if j - f - 1 >= 0 : NEW_LINE INDENT mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] NEW_LINE DEDENT DEDENT DEDENT return mem [ d ] [ s ] NEW_LINE DEDENT
def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCSuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def LCSubStr ( s , t , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( 2 ) ] NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == t [ j - 1 ] ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 NEW_LINE if ( dp [ i % 2 ] [ j ] > res ) : NEW_LINE INDENT res = dp [ i % 2 ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def lcs ( i , j , count ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT count = lcs ( i - 1 , j - 1 , count + 1 ) NEW_LINE DEDENT count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) NEW_LINE return count NEW_LINE DEDENT
def findMinInsertions ( str , l , h ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( l == h ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == h - 1 ) : NEW_LINE INDENT return 0 if ( str [ l ] == str [ h ] ) else 1 NEW_LINE DEDENT if ( str [ l ] == str [ h ] ) : NEW_LINE INDENT return findMinInsertions ( str , l + 1 , h - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) NEW_LINE DEDENT DEDENT
def maxCrossingSum ( arr , l , m , h ) : NEW_LINE INDENT sm = 0 NEW_LINE left_sum = - 10000 NEW_LINE for i in range ( m , l - 1 , - 1 ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE if ( sm > left_sum ) : NEW_LINE INDENT left_sum = sm NEW_LINE DEDENT DEDENT sm = 0 NEW_LINE right_sum = - 1000 NEW_LINE for i in range ( m + 1 , h + 1 ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE if ( sm > right_sum ) : NEW_LINE INDENT right_sum = sm NEW_LINE DEDENT DEDENT return max ( left_sum + right_sum , left_sum , right_sum ) NEW_LINE DEDENT
def maxSubArraySum ( arr , l , h ) : NEW_LINE INDENT if ( l == h ) : NEW_LINE INDENT return arr [ l ] NEW_LINE DEDENT m = ( l + h ) // 2 NEW_LINE return max ( maxSubArraySum ( arr , l , m ) , maxSubArraySum ( arr , m + 1 , h ) , maxCrossingSum ( arr , l , m , h ) ) NEW_LINE DEDENT
def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( set [ n - 1 ] > sum ) : NEW_LINE INDENT return isSubsetSum ( set , n - 1 , sum ) NEW_LINE DEDENT return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) NEW_LINE DEDENT
def subsetSum ( a , n , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( tab [ n - 1 ] [ sum ] != - 1 ) : NEW_LINE INDENT return tab [ n - 1 ] [ sum ] NEW_LINE DEDENT if ( a [ n - 1 ] > sum ) : NEW_LINE INDENT tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) NEW_LINE return tab [ n - 1 ] [ sum ] NEW_LINE DEDENT else : NEW_LINE INDENT tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) NEW_LINE return tab [ n - 1 ] [ sum ] or subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) NEW_LINE DEDENT DEDENT
def findWater ( i , j , X ) : NEW_LINE INDENT if ( j > i ) : NEW_LINE INDENT print ( "Incorrect Input" ) NEW_LINE return NEW_LINE DEDENT glass = [ 0 ] * int ( i * ( i + 1 ) / 2 ) NEW_LINE index = 0 NEW_LINE glass [ index ] = X NEW_LINE for row in range ( 1 , i ) : NEW_LINE INDENT for col in range ( 1 , row + 1 ) : NEW_LINE INDENT X = glass [ index ] NEW_LINE glass [ index ] = 1.0 if ( X >= 1.0 ) else X NEW_LINE X = ( X - 1 ) if ( X >= 1.0 ) else 0.0 NEW_LINE glass [ index + row ] += ( X / 2 ) NEW_LINE glass [ index + row + 1 ] += ( X / 2 ) NEW_LINE index += 1 NEW_LINE DEDENT DEDENT return glass [ int ( i * ( i - 1 ) / 2 + j - 1 ) ] NEW_LINE DEDENT
def maxChainLength ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE mcl = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] . a > arr [ j ] . b and mcl [ i ] < mcl [ j ] + 1 ) : NEW_LINE INDENT mcl [ i ] = mcl [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < mcl [ i ] ) : NEW_LINE INDENT max = mcl [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def solveWordWrap ( l , n , M ) : NEW_LINE INDENT extras = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE lc = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE c = [ 0 for i in range ( n + 1 ) ] NEW_LINE p = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT extras [ i ] [ i ] = M - l [ i - 1 ] NEW_LINE for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT extras [ i ] [ j ] = ( extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ) NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT if extras [ i ] [ j ] < 0 : NEW_LINE INDENT lc [ i ] [ j ] = INF NEW_LINE DEDENT elif j == n and extras [ i ] [ j ] >= 0 : NEW_LINE INDENT lc [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT lc [ i ] [ j ] = ( extras [ i ] [ j ] * extras [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT c [ 0 ] = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT c [ j ] = INF NEW_LINE for i in range ( 1 , j + 1 ) : NEW_LINE INDENT if ( c [ i - 1 ] != INF and lc [ i ] [ j ] != INF and ( ( c [ i - 1 ] + lc [ i ] [ j ] ) < c [ j ] ) ) : NEW_LINE INDENT c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] NEW_LINE p [ j ] = i NEW_LINE DEDENT DEDENT DEDENT printSolution ( p , n ) NEW_LINE DEDENT
def distanceFromRoot ( root , x ) : NEW_LINE INDENT if root . key == x : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif root . key > x : NEW_LINE INDENT return 1 + distanceFromRoot ( root . left , x ) NEW_LINE DEDENT return 1 + distanceFromRoot ( root . right , x ) NEW_LINE DEDENT
def findDistWrapper ( root , a , b ) : NEW_LINE INDENT if a > b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT return distanceBetween2 ( root , a , b ) NEW_LINE DEDENT
def isSubsetSum ( arr , n , sum ) : NEW_LINE INDENT if sum == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 0 and sum != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if arr [ n - 1 ] > sum : NEW_LINE INDENT return isSubsetSum ( arr , n - 1 , sum ) NEW_LINE DEDENT return isSubsetSum ( arr , n - 1 , sum ) or isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) NEW_LINE DEDENT
def findPartiion ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT if ( Sum % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT part = [ 0 ] * ( ( Sum // 2 ) + 1 ) NEW_LINE for i in range ( ( Sum // 2 ) + 1 ) : NEW_LINE INDENT part [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( Sum // 2 , arr [ i ] - 1 , - 1 ) : NEW_LINE INDENT if ( part [ j - arr [ i ] ] == 1 or j == arr [ i ] ) : NEW_LINE INDENT part [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT return part [ Sum // 2 ] NEW_LINE DEDENT
def minPalPartion ( string , i , j ) : NEW_LINE INDENT if i >= j or isPalindrome ( string [ i : j + 1 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = float ( 'inf' ) NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT count = ( 1 + minPalPartion ( string , i , k ) + minPalPartion ( string , k + 1 , j ) ) NEW_LINE ans = min ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minCut ( a ) : NEW_LINE INDENT cut = [ 0 for i in range ( len ( a ) ) ] NEW_LINE palindrome = [ [ False for i in range ( len ( a ) ) ] for j in range ( len ( a ) ) ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT minCut = i NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT if ( a [ i ] == a [ j ] and ( i - j < 2 or palindrome [ j + 1 ] [ i - 1 ] ) ) : NEW_LINE INDENT palindrome [ j ] [ i ] = True NEW_LINE minCut = min ( minCut , 0 if j == 0 else ( cut [ j - 1 ] + 1 ) ) NEW_LINE DEDENT DEDENT cut [ i ] = minCut NEW_LINE DEDENT return cut [ len ( a ) - 1 ] NEW_LINE DEDENT
def maxSumIS ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE msis = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) : NEW_LINE INDENT msis [ i ] = msis [ j ] + arr [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if max < msis [ i ] : NEW_LINE INDENT max = msis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def cutRod ( price , n ) : NEW_LINE INDENT val = [ 0 for x in range ( n + 1 ) ] NEW_LINE val [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_val = INT_MIN NEW_LINE for j in range ( i ) : NEW_LINE INDENT max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) NEW_LINE DEDENT val [ i ] = max_val NEW_LINE DEDENT return val [ n ] NEW_LINE DEDENT
def max ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return x NEW_LINE DEDENT return y NEW_LINE DEDENT
def binomialCoeff ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT m = 1000000007 NEW_LINE inv = [ 0 for i in range ( r + 1 ) ] NEW_LINE inv [ 0 ] = 1 NEW_LINE if ( r + 1 >= 2 ) inv [ 1 ] = 1 for i in range ( 2 , r + 1 ) : NEW_LINE INDENT inv [ i ] = m - ( m // i ) * inv [ m % i ] % m NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 2 , r + 1 ) : NEW_LINE INDENT ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m NEW_LINE DEDENT for i in range ( n , n - r , - 1 ) : NEW_LINE INDENT ans = ( ( ans % m ) * ( i % m ) ) % m NEW_LINE DEDENT return ans NEW_LINE DEDENT
def matrixChainMemoised ( p , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT
def MatrixChainOrder ( p , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE return matrixChainMemoised ( p , i , j ) NEW_LINE DEDENT
def count ( S , m , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m <= 0 and n >= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT
def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return c // ( n + 1 ) NEW_LINE DEDENT
def countBST ( n ) : NEW_LINE INDENT count = catalan ( n ) NEW_LINE return count NEW_LINE DEDENT
def countBT ( n ) : NEW_LINE INDENT count = catalan ( n ) NEW_LINE return count * factorial ( n ) NEW_LINE DEDENT
def checkArray ( arr , N , k ) : NEW_LINE INDENT if ( N < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT Sum = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT R = ( k * k + k + 1 ) NEW_LINE if ( Sum % R != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT Mid = k * ( Sum // R ) NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT temp += arr [ i - 1 ] NEW_LINE if ( arr [ i ] == Mid ) : NEW_LINE INDENT if ( temp == Mid // k ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT
def encodeString ( str ) : NEW_LINE INDENT res = "" NEW_LINE small = [ 0 for i in range ( 26 ) ] NEW_LINE capital = [ 0 for i in range ( 26 ) ] NEW_LINE num = [ 0 for i in range ( 10 ) ] NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] >= '0' and str [ i ] <= '9' ) : NEW_LINE INDENT num [ ord ( str [ i ] ) - 48 ] = i NEW_LINE DEDENT elif ( str [ i ] >= 'a' and str [ i ] <= 'z' ) : NEW_LINE INDENT small [ ord ( str [ i ] ) - 97 ] = i NEW_LINE DEDENT elif ( str [ i ] >= 'A' and str [ i ] <= 'Z' ) : NEW_LINE INDENT capital [ ord ( str [ i ] ) - 65 ] = i NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( ( str [ i ] >= 'a' and str [ i ] <= 'z' ) and small [ ord ( str [ i ] ) - 97 ] == i ) : NEW_LINE INDENT occ = ord ( str [ i ] ) - 96 NEW_LINE while ( occ > 0 ) : NEW_LINE INDENT res += str [ i ] NEW_LINE occ -= 1 NEW_LINE DEDENT DEDENT elif ( ( str [ i ] >= 'A' and str [ i ] <= 'Z' ) and capital [ ord ( str [ i ] ) - 65 ] == i ) : NEW_LINE INDENT occ = ord ( str [ i ] ) - 64 NEW_LINE while ( occ > 0 ) : NEW_LINE INDENT res += str [ i ] NEW_LINE occ -= 1 NEW_LINE DEDENT DEDENT elif ( ( str [ i ] >= '0' and str [ i ] <= '9' ) and num [ ord ( str [ i ] ) - 48 ] == i ) : NEW_LINE INDENT occ = ord ( str [ i ] ) - 48 NEW_LINE while ( occ > 0 ) : NEW_LINE INDENT res += str [ i ] NEW_LINE occ -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT res += str [ i ] NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def possibleEqualArray ( A , N ) : NEW_LINE INDENT pref = [ 0 for i in range ( N ) ] NEW_LINE pref [ 0 ] = A [ 0 ] NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] ^ A [ i ] NEW_LINE DEDENT if ( pref [ N - 1 ] == 0 ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE return NEW_LINE DEDENT cur_xor = 0 NEW_LINE i = N - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT cur_xor ^= A [ i ] NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( j ) : NEW_LINE INDENT middle_xor = pref [ j - 1 ] ^ pref [ i - 1 ] NEW_LINE left_xor = pref [ j - 1 ] NEW_LINE right_xor = cur_xor NEW_LINE if ( left_xor == middle_xor and middle_xor == right_xor ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT i -= 1 NEW_LINE DEDENT print ( "NO" ) NEW_LINE DEDENT
def RangeTraversal ( root , n1 , n2 ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT curr = root NEW_LINE while curr : NEW_LINE INDENT if curr . left == None : NEW_LINE INDENT if curr . data <= n2 and curr . data >= n1 : NEW_LINE INDENT print ( curr . data , end = " " ) NEW_LINE DEDENT curr = curr . right NEW_LINE DEDENT else : NEW_LINE INDENT pre = curr . left NEW_LINE while ( pre . right != None and pre . right != curr ) : NEW_LINE INDENT pre = pre . right NEW_LINE DEDENT if pre . right == None : NEW_LINE INDENT pre . right = curr NEW_LINE curr = curr . left NEW_LINE DEDENT else : NEW_LINE INDENT pre . right = None NEW_LINE if curr . data <= n2 and curr . data >= n1 : NEW_LINE INDENT print ( curr . data , end = " " ) NEW_LINE DEDENT curr = curr . right NEW_LINE DEDENT DEDENT DEDENT DEDENT
def possibleEqualArray ( A , N ) : NEW_LINE INDENT tot_XOR = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT tot_XOR ^= A [ i ] NEW_LINE DEDENT if ( tot_XOR == 0 ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE return NEW_LINE DEDENT cur_XOR = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cur_XOR ^= A [ i ] NEW_LINE if ( cur_XOR == tot_XOR ) : NEW_LINE INDENT cnt += 1 NEW_LINE cur_XOR = 0 NEW_LINE DEDENT DEDENT if ( cnt > 2 ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def GenerateArray ( N , X ) : NEW_LINE INDENT prev_xor = X NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT print ( i ^ prev_xor , end = "" ) NEW_LINE if ( i != N ) : NEW_LINE INDENT print ( " " , end = "" ) NEW_LINE DEDENT prev_xor = i NEW_LINE DEDENT DEDENT
def createGrid ( grid , is1 , N , M ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( is1 ) : NEW_LINE INDENT grid [ i ] [ j ] = '0' NEW_LINE is1 = False NEW_LINE DEDENT else : NEW_LINE INDENT grid [ i ] [ j ] = '1' NEW_LINE is1 = True NEW_LINE DEDENT DEDENT if ( M % 2 == 0 ) : NEW_LINE INDENT is1 = True if is1 == False else False NEW_LINE DEDENT DEDENT DEDENT
def testGrid ( testGrid , Grid , N , M ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( Grid [ i ] [ j ] != '*' ) : NEW_LINE INDENT if ( Grid [ i ] [ j ] != testGrid [ i ] [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def findPossibleGrid ( N , M , grid ) : NEW_LINE INDENT gridTest1 = [ [ '' for i in range ( 1001 ) ] for j in range ( N ) ] NEW_LINE gridTest2 = [ [ '' for i in range ( 1001 ) ] for j in range ( N ) ] NEW_LINE createGrid ( gridTest1 , True , N , M ) NEW_LINE createGrid ( gridTest2 , False , N , M ) NEW_LINE if ( testGrid ( gridTest1 , grid , N , M ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE printGrid ( gridTest1 , N , M ) NEW_LINE DEDENT elif ( testGrid ( gridTest2 , grid , N , M ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE printGrid ( gridTest2 , N , M ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def brute ( ind , l , r ) : NEW_LINE INDENT if ( ind == n / 2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( brr [ i ] , end = " " ) NEW_LINE DEDENT sys . exit ( ) NEW_LINE DEDENT for i in range ( l , arr [ ind ] // 2 + 1 , 1 ) : NEW_LINE INDENT if ( arr [ ind ] - i <= r ) : NEW_LINE INDENT brr [ ind ] = i NEW_LINE brr [ n - ind - 1 ] = arr [ ind ] - i NEW_LINE brute ( ind + 1 , i , arr [ ind ] - i ) NEW_LINE DEDENT DEDENT DEDENT
def minCount ( N , K ) : NEW_LINE INDENT SmallestNumber = [ 0 for i in range ( 10 ) ] NEW_LINE MinimumSteps = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT SmallestNumber [ i ] = sys . maxsize NEW_LINE MinimumSteps [ i ] = sys . maxsize NEW_LINE DEDENT for i in range ( 1 , 11 , 1 ) : NEW_LINE INDENT num = K * i NEW_LINE SmallestNumber [ num % 10 ] = min ( SmallestNumber [ num % 10 ] , num ) NEW_LINE MinimumSteps [ num % 10 ] = min ( MinimumSteps [ num % 10 ] , i ) NEW_LINE DEDENT if ( N < SmallestNumber [ N % 10 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return MinimumSteps [ N % 10 ] NEW_LINE DEDENT DEDENT
def inRange ( root , low , high ) : NEW_LINE INDENT return root . data >= low and root . data <= high NEW_LINE DEDENT
def countMinSteps ( arr , N ) : NEW_LINE INDENT val = 0 NEW_LINE mx = - 10 ** 9 NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE mx = max ( mx , curr ) NEW_LINE val = max ( val , mx - curr ) NEW_LINE DEDENT res = 0 NEW_LINE while ( ( 1 << res ) - 1 < val ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def func2 ( L , R , K ) : NEW_LINE INDENT if ( R - L >= 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return min ( L , L ^ R ) NEW_LINE DEDENT
def func3 ( L , R , K ) : NEW_LINE INDENT if ( ( R ^ L ) > L and ( R ^ L ) < R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return func2 ( L , R , K ) NEW_LINE DEDENT
def func4 ( L , R , K ) : NEW_LINE INDENT if ( R - L >= 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT minval = L ^ ( L + 1 ) ^ ( L + 2 ) ^ ( L + 3 ) NEW_LINE return min ( minval , func3 ( L , R , K ) ) NEW_LINE DEDENT
def minimumXor ( L , R , K ) : NEW_LINE INDENT if ( K > 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( K == 4 ) : NEW_LINE INDENT return func4 ( L , R , K ) NEW_LINE DEDENT elif ( K == 3 ) : NEW_LINE INDENT return func3 ( L , R , K ) NEW_LINE DEDENT elif ( K == 2 ) : NEW_LINE INDENT return func2 ( L , R , K ) NEW_LINE DEDENT else : NEW_LINE INDENT return L NEW_LINE DEDENT DEDENT
def setBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n & ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findNthTerm ( N ) : NEW_LINE INDENT x = setBits ( N ^ ( N - 1 ) ) NEW_LINE print ( x ) NEW_LINE DEDENT
def findEquation ( A , B , C ) : NEW_LINE INDENT print ( "(" + str ( C ) + ")" + "x^2 +(" + str ( B ) + ")x + (" + str ( A ) + ") = 0" ) NEW_LINE DEDENT
def findMinMoves ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % N != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT avg = sum // N NEW_LINE total = 0 NEW_LINE needCount = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT needCount += ( arr [ i ] - avg ) NEW_LINE total = max ( max ( abs ( needCount ) , arr [ i ] - avg ) , total ) NEW_LINE DEDENT return total NEW_LINE DEDENT
def checkPro ( n , k ) : NEW_LINE INDENT KthRoot = int ( n ** ( 1 / k ) ) NEW_LINE product = 1 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT product = product * i NEW_LINE DEDENT print ( product ) NEW_LINE if ( product == N ) : NEW_LINE INDENT return ( "Yes" ) NEW_LINE DEDENT for i in range ( 2 , KthRoot + 1 ) : NEW_LINE INDENT product = product * ( i + k - 1 ) NEW_LINE product = product / ( i - 1 ) NEW_LINE print ( product ) NEW_LINE if ( product == N ) : NEW_LINE INDENT return ( "Yes" ) NEW_LINE DEDENT DEDENT return ( "No" ) NEW_LINE DEDENT
def totalCombination ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE K = R - L NEW_LINE if ( K < L ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = K - L NEW_LINE count = ( ( ans + 1 ) * ( ans + 2 ) ) // 2 NEW_LINE return count NEW_LINE DEDENT
def inorder ( root ) : NEW_LINE INDENT if root != None : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . data , end = " " ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT
def getZarr ( st , Z ) : NEW_LINE INDENT n = len ( st ) NEW_LINE k = 0 NEW_LINE L = 0 NEW_LINE R = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( i > R ) : NEW_LINE INDENT L = R = i NEW_LINE while ( R < n and st [ R - L ] == st [ R ] ) : NEW_LINE INDENT R += 1 NEW_LINE DEDENT Z [ i ] = R - L NEW_LINE R -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = i - L NEW_LINE if ( Z [ k ] < R - i + 1 ) : NEW_LINE INDENT Z [ i ] = Z [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT L = i NEW_LINE while ( R < n and st [ R - L ] == st [ R ] ) : NEW_LINE INDENT R += 1 NEW_LINE DEDENT Z [ i ] = R - L NEW_LINE R -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def goodStr ( st , word ) : NEW_LINE INDENT concat = word + "$" + st NEW_LINE l = len ( concat ) NEW_LINE Z = [ 0 ] * l NEW_LINE getZarr ( concat , Z ) NEW_LINE res = "" NEW_LINE pSize = len ( word ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( i + pSize < l - 1 and Z [ i + pSize + 1 ] == pSize ) : NEW_LINE INDENT i += pSize - 1 NEW_LINE DEDENT elif ( i < len ( st ) ) : NEW_LINE INDENT res += st [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findCount0th ( arr , N , K ) : NEW_LINE INDENT oddsum = 0 NEW_LINE evensum = 0 NEW_LINE for i in range ( 1 , N , 2 ) : NEW_LINE INDENT oddsum += arr [ i ] NEW_LINE DEDENT for i in range ( 2 , N , 2 ) : NEW_LINE INDENT evensum += arr [ i ] NEW_LINE DEDENT if ( abs ( oddsum - evensum ) == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def findCount1st ( arr , N , K ) : NEW_LINE INDENT evensum = arr [ 0 ] NEW_LINE oddsum = 0 NEW_LINE for i in range ( 3 , N , 2 ) : NEW_LINE INDENT evensum += arr [ i ] NEW_LINE DEDENT for i in range ( 2 , N , 2 ) : NEW_LINE INDENT oddsum += arr [ i ] NEW_LINE DEDENT if ( abs ( oddsum - evensum ) == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def printDiagonalTraversal ( nums ) : NEW_LINE INDENT max_size = len ( nums ) NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT if ( max_size < len ( nums [ i ] ) ) : NEW_LINE INDENT max_size = len ( nums [ i ] ) NEW_LINE DEDENT DEDENT v = [ [ ] for i in range ( 2 * max_size - 1 ) ] NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT for j in range ( len ( nums [ i ] ) ) : NEW_LINE INDENT v [ i + j ] . append ( nums [ i ] [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT v [ i ] = v [ i ] [ : : - 1 ] NEW_LINE for j in range ( len ( v [ i ] ) ) : NEW_LINE INDENT print ( v [ i ] [ j ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def printDiagonalTraversal ( nums ) : NEW_LINE INDENT m = len ( nums ) NEW_LINE q = [ ] NEW_LINE q . append ( [ 0 , 0 ] ) NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT p = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE print ( nums [ p [ 0 ] ] [ p [ 1 ] ] , end = " " ) NEW_LINE if ( p [ 1 ] == 0 and p [ 0 ] + 1 < m ) : NEW_LINE INDENT q . append ( [ p [ 0 ] + 1 , p [ 1 ] ] ) NEW_LINE DEDENT if ( p [ 1 ] + 1 < len ( nums [ p [ 0 ] ] ) ) : NEW_LINE INDENT q . append ( [ p [ 0 ] , p [ 1 ] + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT
def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( A & ( 1 << i ) ) and ( B & ( 1 << i ) ) ) : NEW_LINE INDENT A = A ^ ( 1 << i ) NEW_LINE B = B ^ ( 1 << i ) NEW_LINE DEDENT DEDENT print ( A , B ) NEW_LINE DEDENT
def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT A = A ^ ( A & B ) NEW_LINE B = B ^ ( A & B ) NEW_LINE print ( A , B ) NEW_LINE DEDENT
def isValid ( s ) : NEW_LINE INDENT n = int ( math . sqrt ( len ( s ) ) ) NEW_LINE check = s [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = i NEW_LINE y = i NEW_LINE while ( x >= 0 and y < n ) : NEW_LINE INDENT if ( s [ n * x + y ] != check or s [ n * x + x ] != check ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT x -= 1 NEW_LINE y += 1 NEW_LINE DEDENT DEDENT print ( "Yes" ) NEW_LINE DEDENT
def minimumOperations ( orig_str , m , n ) : NEW_LINE INDENT orig = orig_str NEW_LINE turn = 1 NEW_LINE j = 1 NEW_LINE for i in orig_str : NEW_LINE INDENT m_cut = orig_str [ - m : ] NEW_LINE orig_str = orig_str . replace ( ' ' , '' ) [ : - m ] NEW_LINE orig_str = m_cut + orig_str NEW_LINE j = j + 1 NEW_LINE if orig != orig_str : NEW_LINE INDENT turn = turn + 1 NEW_LINE n_cut = orig_str [ - n : ] NEW_LINE orig_str = orig_str . replace ( ' ' , '' ) [ : - n ] NEW_LINE orig_str = n_cut + orig_str NEW_LINE j = j + 1 NEW_LINE DEDENT if orig == orig_str : NEW_LINE INDENT break NEW_LINE DEDENT turn = turn + 1 NEW_LINE DEDENT print ( turn ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT t = a NEW_LINE a = b NEW_LINE b = t NEW_LINE DEDENT if ( a % b == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def printAnswer ( x , y ) : NEW_LINE INDENT val = gcd ( x , y ) NEW_LINE if ( ( val & ( val - 1 ) ) == 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def toDigit ( ch ) : NEW_LINE INDENT return ( ord ( ch ) - ord ( '0' ) ) NEW_LINE DEDENT
def powerOf10 ( ) : NEW_LINE INDENT power [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT power [ i ] = power [ i - 1 ] * 10 NEW_LINE DEDENT DEDENT
def precomputePrefix ( st , n ) : NEW_LINE INDENT pref [ 0 ] = ( ord ( st [ 0 ] ) - ord ( '0' ) ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pref [ i ] = ( pref [ i - 1 ] + toDigit ( st [ i ] ) ) NEW_LINE DEDENT DEDENT
def triangularNumber ( i ) : NEW_LINE INDENT res = i * ( i + 1 ) // 2 NEW_LINE return res NEW_LINE DEDENT
def sumOfSubarrayProd ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE res = 0 NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT incr = arr [ i ] * ( 1 + res ) NEW_LINE ans += incr NEW_LINE res = incr NEW_LINE i -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def OddLengthSum ( arr ) : NEW_LINE INDENT sum = 0 NEW_LINE l = len ( arr ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( i , l , 2 ) : NEW_LINE INDENT for k in range ( i , j + 1 , 1 ) : NEW_LINE INDENT sum += arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def phi ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for p in range ( 2 , n ) : NEW_LINE INDENT if ( __gcd ( p , n ) == 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def sameEulerTotient ( n ) : NEW_LINE INDENT return phi ( n ) == phi ( 2 * n ) NEW_LINE DEDENT
def sameEulerTotient ( N ) : NEW_LINE INDENT return ( N & 1 ) NEW_LINE DEDENT
def restore ( arr , N ) : NEW_LINE INDENT result = [ ] NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if not arr [ i ] in mp : NEW_LINE INDENT result . append ( arr [ i ] ) NEW_LINE mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def print_result ( result ) : NEW_LINE INDENT for i in range ( len ( result ) ) : NEW_LINE INDENT print ( result [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def restore ( arr , N ) : NEW_LINE INDENT result = [ ] NEW_LINE count1 = 1 NEW_LINE s = set ( [ ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE if ( len ( s ) == count1 ) : NEW_LINE INDENT result . append ( arr [ i ] ) NEW_LINE count1 += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def print_result ( result ) : NEW_LINE INDENT for i in range ( len ( result ) ) : NEW_LINE INDENT print ( result [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def checkReverseBitonic ( arr , n ) : NEW_LINE INDENT f = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ j - 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT if ( f == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT
def getFirstSetBitPos ( n ) : NEW_LINE INDENT return log ( n & - n , 2 ) + 1 NEW_LINE DEDENT
def oddFirst ( a , b ) : NEW_LINE INDENT steps_a = getFirstSetBitPos ( a ) NEW_LINE steps_b = getFirstSetBitPos ( b ) NEW_LINE if ( steps_a == steps_b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( steps_a > steps_b ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( steps_a < steps_b ) : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT
def nCycle ( N ) : NEW_LINE INDENT return ( N ) * ( N - 1 ) + 1 NEW_LINE DEDENT
def checkReverseBitonic ( s ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] < s [ i - 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] >= s [ i - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == len ( s ) - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ j ] > s [ j - 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ j ] <= s [ j - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = j NEW_LINE if ( i != len ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT s = 0 NEW_LINE l = 1 NEW_LINE while ( l < n + 1 ) : NEW_LINE INDENT r = ( int ) ( n / math . floor ( n / l ) ) NEW_LINE x = ( ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ) NEW_LINE y = ( ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ) NEW_LINE p = ( int ) ( ( n / l ) % m ) NEW_LINE s = ( ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ) NEW_LINE s %= m NEW_LINE l = r + 1 NEW_LINE DEDENT print ( int ( ( s + m ) % m ) ) NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT i = int ( math . log2 ( n ) ) NEW_LINE n = n - pow ( 2 , i ) NEW_LINE sum = sum + ( i + 1 ) + Count ( i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def smallestNum ( N ) : NEW_LINE INDENT x = pow ( 10.0 , ( N - 1 ) / 2.0 ) NEW_LINE return math . ceil ( x ) NEW_LINE DEDENT
def checkBitonic ( s ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] > s [ i - 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] <= s [ i - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == ( len ( s ) - 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ j ] < s [ j - 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ j ] >= s [ j - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = j NEW_LINE if ( i != len ( s ) - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def findArray ( a , n , P ) : NEW_LINE INDENT mi = min ( a ) NEW_LINE ctr = 0 NEW_LINE mi = max ( 0 , mi - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] -= mi NEW_LINE ctr += mi NEW_LINE DEDENT i = P - 1 NEW_LINE start = - 1 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT start = i NEW_LINE break NEW_LINE DEDENT a [ i ] -= 1 NEW_LINE ctr += 1 NEW_LINE i = ( i - 1 + n ) % n NEW_LINE DEDENT a [ start ] = ctr NEW_LINE print ( * a , sep = ', ' ) NEW_LINE DEDENT
def checkstateA ( n ) : NEW_LINE INDENT if ( n [ 0 ] == '0' ) : NEW_LINE INDENT stateB ( n [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stateD ( n [ 1 : ] ) NEW_LINE DEDENT DEDENT
def stateB ( n ) : NEW_LINE INDENT if ( len ( n ) == 0 ) : NEW_LINE INDENT print ( "string not accepted" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n [ 0 ] == '1' ) : NEW_LINE INDENT stateC ( n [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stateD ( n [ 1 : ] ) NEW_LINE DEDENT DEDENT DEDENT
def stateD ( n ) : NEW_LINE INDENT if ( len ( n ) == 0 ) : NEW_LINE INDENT print ( "string not accepted" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n [ 0 ] == '1' ) : NEW_LINE INDENT stateD ( n [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stateE ( n [ 1 : ] ) NEW_LINE DEDENT DEDENT DEDENT
def stateE ( n ) : NEW_LINE INDENT if ( len ( n ) == 0 ) : NEW_LINE INDENT print ( "string not accepted" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n [ 0 ] == '0' ) : NEW_LINE INDENT stateE ( n [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stateF ( n [ 1 : ] ) NEW_LINE DEDENT DEDENT DEDENT
def stateF ( n ) : NEW_LINE INDENT if ( len ( n ) == 0 ) : NEW_LINE INDENT print ( "string accepred" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n [ 0 ] == '1' ) : NEW_LINE INDENT stateD ( n [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stateE ( n [ 1 : ] ) NEW_LINE DEDENT DEDENT DEDENT
def HogbenNumber ( a ) : NEW_LINE INDENT p = ( pow ( a , 2 ) - a + 1 ) NEW_LINE return p NEW_LINE DEDENT
def countKCountdown ( arr , N , K ) : NEW_LINE INDENT flag = - 1 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT flag = K NEW_LINE DEDENT if ( arr [ i ] == flag ) : NEW_LINE INDENT flag -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT flag = - 1 NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findDistinctSums ( N ) : NEW_LINE INDENT return ( 2 * N - 1 ) NEW_LINE DEDENT
def count_ht ( s , N ) : NEW_LINE INDENT if s == "H" : NEW_LINE INDENT h = math . floor ( N / 2 ) NEW_LINE t = math . ceil ( N / 2 ) NEW_LINE DEDENT elif s == "T" : NEW_LINE INDENT h = math . ceil ( N / 2 ) NEW_LINE t = math . floor ( N / 2 ) NEW_LINE DEDENT return [ h , t ] NEW_LINE DEDENT
def getProduct ( n ) : NEW_LINE INDENT product = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT product = product * ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return product NEW_LINE DEDENT
def productinRange ( l , r ) : NEW_LINE INDENT if ( r - l > 9 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT p = 1 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT p = p * getProduct ( i ) NEW_LINE DEDENT return p NEW_LINE DEDENT DEDENT
def checkQwertyRow ( x ) : NEW_LINE INDENT first_row = [ '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '0' , '-' , '=' ] NEW_LINE second_row = [ 'Q' , 'W' , 'E' , 'R' , 'T' , 'Y' , 'U' , 'I' , 'O' , 'P' , '[' , ']' , 'q' , 'w' , 'e' , 'r' , 't' , 'y' , 'u' , 'i' , 'o' , 'p' ] NEW_LINE third_row = [ 'A' , 'S' , 'D' , 'F' , 'G' , 'H' , 'J' , 'K' , 'L' , ';' , ':' , 'a' , 's' , 'd' , 'f' , 'g' , 'h' , 'j' , 'k' , 'l' ] NEW_LINE fourth_row = [ 'Z' , 'X' , 'C' , 'V' , 'B' , 'N' , 'M' , ',' , '.' , '/' , 'z' , 'x' , 'c' , 'v' , 'b' , 'n' , 'm' ] NEW_LINE if ( first_row . count ( x ) > 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( second_row . count ( x ) > 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif ( third_row . count ( x ) > 0 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT elif ( fourth_row . count ( x ) > 0 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def checkValidity ( str ) : NEW_LINE INDENT x = str [ 0 ] NEW_LINE row = checkQwertyRow ( x ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT x = str [ i ] NEW_LINE if ( row != checkQwertyRow ( x ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT f0 = 0 NEW_LINE f1 = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT rem = n % 60 NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 2 , rem + 3 ) : NEW_LINE INDENT f = ( f0 + f1 ) % 60 NEW_LINE f0 = f1 NEW_LINE f1 = f NEW_LINE DEDENT s = f1 - 1 NEW_LINE return ( s ) NEW_LINE DEDENT DEDENT
def sumBetweenZero ( arr , N ) : NEW_LINE INDENT i = 0 NEW_LINE A = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT i += 1 NEW_LINE break NEW_LINE DEDENT DEDENT k = i NEW_LINE for i in range ( k , N , 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT A . append ( sum ) NEW_LINE sum = 0 NEW_LINE DEDENT else : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( len ( A ) ) : NEW_LINE INDENT print ( A [ i ] , end = ' ' ) NEW_LINE DEDENT if ( len ( A ) == 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def nthTerm ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( N - 1 ) * 13 ) + nthTerm ( N - 1 ) NEW_LINE DEDENT
def maximumSubsequence ( arr , N ) : NEW_LINE INDENT M = { i : 0 for i in range ( 100 ) } NEW_LINE for i in range ( N ) : NEW_LINE INDENT M [ arr [ i ] ] += 1 NEW_LINE DEDENT distinct_size = len ( M ) NEW_LINE maxFreq = 1 NEW_LINE for value in M . values ( ) : NEW_LINE INDENT maxFreq = max ( maxFreq , value ) NEW_LINE DEDENT print ( max ( min ( distinct_size , maxFreq - 1 ) , min ( distinct_size - 1 , maxFreq ) ) ) NEW_LINE DEDENT
def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ '0' ] * 100 NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 NEW_LINE temp = n % 16 NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) NEW_LINE i = i + 1 NEW_LINE DEDENT n = int ( n / 16 ) NEW_LINE DEDENT hexCode = "" NEW_LINE if ( i == 2 ) : NEW_LINE INDENT hexCode = hexCode + hexaDeciNum [ 0 ] NEW_LINE hexCode = hexCode + hexaDeciNum [ 1 ] NEW_LINE DEDENT elif ( i == 1 ) : NEW_LINE INDENT hexCode = "0" NEW_LINE hexCode = hexCode + hexaDeciNum [ 0 ] NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT hexCode = "00" NEW_LINE DEDENT return hexCode NEW_LINE DEDENT
def convertRGBtoHex ( R , G , B ) : NEW_LINE INDENT if ( ( R >= 0 and R <= 255 ) and ( G >= 0 and G <= 255 ) and ( B >= 0 and B <= 255 ) ) : NEW_LINE INDENT hexCode = hexCode + decToHexa ( R ) NEW_LINE hexCode = hexCode + decToHexa ( G ) NEW_LINE hexCode = hexCode + decToHexa ( B ) NEW_LINE return hexCode NEW_LINE DEDENT else : NEW_LINE INDENT return "-1" NEW_LINE DEDENT DEDENT
def isKAlternating ( s , k ) : NEW_LINE INDENT if ( len ( s ) < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT bitAtIndex = ord ( s [ i ] ) - ord ( 'a' ) NEW_LINE if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = checker | ( 1 << bitAtIndex ) NEW_LINE DEDENT for i in range ( k , len ( s ) ) : NEW_LINE INDENT if ( s [ i - k ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findFactors ( N ) : NEW_LINE INDENT temp = int ( math . sqrt ( N ) ) NEW_LINE factor = [ 1 ] * MAX NEW_LINE len1 = 1 NEW_LINE while ( temp % 2 == 0 ) : NEW_LINE INDENT factor [ len1 ] = 2 NEW_LINE len1 += 1 NEW_LINE factor [ len1 ] = 2 NEW_LINE len1 += 1 NEW_LINE temp //= 2 NEW_LINE DEDENT sqt = math . sqrt ( temp ) NEW_LINE for j in range ( 3 , math . ceil ( sqt ) , 2 ) : NEW_LINE INDENT while ( temp % j == 0 ) : NEW_LINE INDENT factor [ len1 ] = j NEW_LINE len1 += 1 NEW_LINE factor [ len1 ] = j NEW_LINE len1 += 1 NEW_LINE temp //= j NEW_LINE DEDENT DEDENT if ( temp > 2 ) : NEW_LINE INDENT factor [ len1 ] = temp NEW_LINE len1 += 1 NEW_LINE factor [ len1 ] = temp NEW_LINE len1 += 1 NEW_LINE DEDENT M = [ [ 0 for x in range ( MAX ) ] for y in range ( len1 ) ] NEW_LINE tpc , tpr = 0 , 0 NEW_LINE M [ 0 ] [ 0 ] = 1 NEW_LINE j = 1 NEW_LINE while ( j < len1 ) : NEW_LINE INDENT if ( factor [ j ] != factor [ j - 1 ] ) : NEW_LINE INDENT tpr += 1 NEW_LINE M [ tpr ] [ 0 ] = factor [ j ] NEW_LINE j += 1 NEW_LINE tpc = 1 NEW_LINE DEDENT else : NEW_LINE INDENT M [ tpr ] [ tpc ] = M [ tpr ] [ tpc - 1 ] * factor [ j ] NEW_LINE j += 1 NEW_LINE tpc += 1 NEW_LINE DEDENT DEDENT arr1 = [ 0 ] * MAX NEW_LINE arr2 = [ 0 ] * MAX NEW_LINE l1 = l2 = 1 NEW_LINE arr1 [ 0 ] = 1 NEW_LINE arr2 [ 0 ] = 1 NEW_LINE for i in range ( 1 , tpr + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while M [ i ] [ j ] != 0 : NEW_LINE INDENT for k in range ( l1 ) : NEW_LINE INDENT arr2 [ l2 ] = arr1 [ k ] * M [ i ] [ j ] NEW_LINE l2 += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT for j in range ( l1 , l2 ) : NEW_LINE INDENT arr1 [ j ] = arr2 [ j ] NEW_LINE DEDENT l1 = l2 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT print ( arr2 [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def countSubstring ( S , n ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT cnt0 = 0 NEW_LINE cnt1 = 0 NEW_LINE if ( S [ i ] == '0' ) : NEW_LINE INDENT while ( i < n and S [ i ] == '0' ) : NEW_LINE INDENT cnt0 += 1 NEW_LINE i += 1 NEW_LINE DEDENT j = i NEW_LINE while ( j < n and S [ j ] == '1' ) : NEW_LINE INDENT cnt1 += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while ( i < n and S [ i ] == '1' ) : NEW_LINE INDENT cnt1 += 1 NEW_LINE i += 1 NEW_LINE DEDENT j = i NEW_LINE while ( j < n and S [ j ] == '0' ) : NEW_LINE INDENT cnt0 += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT ans += min ( cnt0 , cnt1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findNumbers ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT print ( ( 3 * i * ( i - 1 ) + 1 ) , end = " " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def zArray ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE z = [ 0 ] * n NEW_LINE r = 0 NEW_LINE l = 0 NEW_LINE for k in range ( 1 , n ) : NEW_LINE INDENT if ( k > r ) : NEW_LINE INDENT r = l = k NEW_LINE while ( r < n and arr [ r ] == arr [ r - l ] ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT z [ k ] = r - l NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k1 = k - l NEW_LINE if ( z [ k1 ] < r - k + 1 ) : NEW_LINE INDENT z [ k ] = z [ k1 ] NEW_LINE DEDENT else : NEW_LINE INDENT l = k NEW_LINE while ( r < n and arr [ r ] == arr [ r - l ] ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT z [ k ] = r - l NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT DEDENT return z NEW_LINE DEDENT
def mergeArray ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE m = len ( B ) NEW_LINE c = [ 0 ] * ( n + m + 1 ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT c [ i ] = B [ i ] NEW_LINE DEDENT c [ m ] = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ m + i + 1 ] = A [ i ] NEW_LINE DEDENT z = zArray ( c ) NEW_LINE return z NEW_LINE DEDENT
def findZArray ( A , B , n ) : NEW_LINE INDENT flag = 0 NEW_LINE z = mergeArray ( A , B ) NEW_LINE for i in range ( len ( z ) ) : NEW_LINE INDENT if ( z [ i ] == n ) : NEW_LINE INDENT print ( i - n - 1 , end = " " ) NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( "Not Found" ) NEW_LINE DEDENT DEDENT
def insertNode ( root , x ) : NEW_LINE INDENT p , q = root , None NEW_LINE while p != None : NEW_LINE INDENT q = p NEW_LINE if p . data < x : NEW_LINE INDENT p = p . right NEW_LINE DEDENT else : NEW_LINE INDENT p = p . left NEW_LINE DEDENT DEDENT if q == None : NEW_LINE INDENT p = createNode ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT if q . data < x : NEW_LINE INDENT q . right = createNode ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT q . left = createNode ( x ) NEW_LINE DEDENT DEDENT DEDENT
def maxelpath ( q , x ) : NEW_LINE INDENT p = q NEW_LINE mx = - 999999999999 NEW_LINE while p . data != x : NEW_LINE INDENT if p . data > x : NEW_LINE INDENT mx = max ( mx , p . data ) NEW_LINE p = p . left NEW_LINE DEDENT else : NEW_LINE INDENT mx = max ( mx , p . data ) NEW_LINE p = p . right NEW_LINE DEDENT DEDENT return max ( mx , x ) NEW_LINE DEDENT
def maximumElement ( root , x , y ) : NEW_LINE INDENT p = root NEW_LINE while ( ( x < p . data and y < p . data ) or ( x > p . data and y > p . data ) ) : NEW_LINE INDENT if x < p . data and y < p . data : NEW_LINE INDENT p = p . left NEW_LINE DEDENT elif x > p . data and y > p . data : NEW_LINE INDENT p = p . right NEW_LINE DEDENT DEDENT return max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) NEW_LINE DEDENT
def q1 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE return NEW_LINE DEDENT if ( s [ i ] == 'a' ) : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) NEW_LINE DEDENT DEDENT
def q2 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT if ( s [ i ] == 'a' ) : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) NEW_LINE DEDENT DEDENT
def q4 ( s , i ) : NEW_LINE INDENT if ( i == s . length ( ) ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT if ( s [ i ] == 'a' ) : NEW_LINE INDENT q4 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) NEW_LINE DEDENT DEDENT
def q0 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT if ( s [ i ] == 'a' ) : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) NEW_LINE DEDENT DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE first_term = 4 NEW_LINE pi = 1 NEW_LINE po = 1 NEW_LINE n = N NEW_LINE while ( n > 1 ) : NEW_LINE INDENT pi *= n - 1 NEW_LINE n -= 1 NEW_LINE po *= 2 NEW_LINE DEDENT nth = ( first_term * pi ) // po NEW_LINE return nth NEW_LINE DEDENT
def q1 ( s , i ) : NEW_LINE INDENT print ( "q1->" , end = "" ) NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT print ( "NO" ) NEW_LINE return NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) NEW_LINE DEDENT DEDENT
def q2 ( s , i ) : NEW_LINE INDENT print ( "q2->" , end = "" ) NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT print ( "NO" ) NEW_LINE return NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT q4 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) NEW_LINE DEDENT DEDENT
def q3 ( s , i ) : NEW_LINE INDENT print ( "q3->" , end = "" ) NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE return NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT q4 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) NEW_LINE DEDENT DEDENT
def q4 ( s , i ) : NEW_LINE INDENT print ( "q4->" , end = "" ) NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE return NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) NEW_LINE DEDENT DEDENT
def q0 ( s , i ) : NEW_LINE INDENT print ( "q0->" , end = "" ) NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT print ( "NO" ) NEW_LINE return NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) NEW_LINE DEDENT DEDENT
def findSum ( arr , n , k ) : NEW_LINE INDENT if ( k <= n - 2 ) : NEW_LINE INDENT return ( arr [ n - 1 ] - arr [ 0 ] ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def finalNum ( arr , n ) : NEW_LINE INDENT result = arr [ 0 ] NEW_LINE for i in arr : NEW_LINE INDENT result = __gcd ( result , i ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def maxSubStr ( str , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT if count0 == count1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def isSatisfied ( st , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) == False and isVowel ( st [ i - 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) and isVowel ( st [ i - 1 ] ) == False and isVowel ( st [ i + 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def squareDigitSum ( num ) : NEW_LINE INDENT lengthN = len ( num ) NEW_LINE result = ( lengthN // 9 ) * 81 + ( lengthN % 9 ) ** 2 NEW_LINE return result NEW_LINE DEDENT
def getElement ( N , r , c ) : NEW_LINE INDENT if ( r > c ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( r == 1 ) : NEW_LINE INDENT return c NEW_LINE DEDENT a = ( r + 1 ) * pow ( 2 , r - 2 ) NEW_LINE d = pow ( 2 , r - 1 ) NEW_LINE c = c - r NEW_LINE element = a + d * c NEW_LINE return element NEW_LINE DEDENT
def computeLPSArray ( pat , M , lps ) : NEW_LINE INDENT _len = 0 NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while i < M : NEW_LINE INDENT if pat [ i ] == pat [ _len ] : NEW_LINE INDENT _len += 1 NEW_LINE lps [ i ] = _len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if _len != 0 : NEW_LINE INDENT _len = lps [ _len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def CntSubstr ( s , l ) : NEW_LINE INDENT hash = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT hash = ( hash * x + ( ord ( s [ i ] ) - 97 ) ) % mod NEW_LINE DEDENT pow_l = 1 NEW_LINE for i in range ( l - 1 ) : NEW_LINE INDENT pow_l = ( pow_l * x ) % mod NEW_LINE DEDENT result = set ( ) NEW_LINE result . add ( hash ) NEW_LINE for i in range ( l , len ( s ) ) : NEW_LINE INDENT hash = ( ( hash - pow_l * ( ord ( s [ i - l ] ) - 97 ) + 2 * mod ) * x + ( ord ( s [ i ] ) - 97 ) ) % mod NEW_LINE result . add ( hash ) NEW_LINE DEDENT print ( len ( result ) ) NEW_LINE DEDENT
def LengthlongestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 for i in range ( n ) ] NEW_LINE len1 = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ len1 ] ) : NEW_LINE INDENT len1 += 1 NEW_LINE lps [ i ] = len1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len1 != 0 ) : NEW_LINE INDENT len1 = lps [ len1 - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE if ( res > int ( n / 2 ) ) : NEW_LINE INDENT return int ( n / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT
def no_of_characters ( M ) : NEW_LINE INDENT k = 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( pow ( 2 , k + 1 ) - 2 < M ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT
def updateString ( S , A , B ) : NEW_LINE INDENT l = len ( A ) NEW_LINE i = 0 NEW_LINE while i + l <= len ( S ) : NEW_LINE INDENT curr = S [ i : i + l ] NEW_LINE if curr == A : NEW_LINE INDENT new_string = S [ 0 : i ] + B + S [ i + l : len ( S ) ] NEW_LINE S = new_string NEW_LINE i += l - 1 NEW_LINE DEDENT else : NEW_LINE INDENT new_string = S [ 0 : i ] + A + S [ i + l : len ( S ) ] NEW_LINE S = new_string NEW_LINE i += l - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return S NEW_LINE DEDENT
def findCount ( str1 , str2 ) : NEW_LINE INDENT len1 = len ( str1 ) NEW_LINE len2 = len ( str2 ) NEW_LINE ans = sys . maxsize NEW_LINE hash1 = [ 0 ] * 26 NEW_LINE hash2 = [ 0 ] * 26 NEW_LINE for i in range ( 0 , len1 ) : NEW_LINE INDENT hash1 [ ord ( str1 [ i ] ) - 97 ] = hash1 [ ord ( str1 [ i ] ) - 97 ] + 1 NEW_LINE DEDENT for i in range ( 0 , len2 ) : NEW_LINE INDENT hash2 [ ord ( str2 [ i ] ) - 97 ] = hash2 [ ord ( str2 [ i ] ) - 97 ] + 1 NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if ( hash2 [ i ] != 0 ) : NEW_LINE INDENT ans = min ( ans , hash1 [ i ] // hash2 [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def getEndingIndex ( str1 , n , i ) : NEW_LINE INDENT i += 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT curr = str1 [ i ] NEW_LINE prev = str1 [ i - 1 ] NEW_LINE if ( ( curr == 'a' and prev == 'z' ) or ( ord ( curr ) - ord ( prev ) == 1 ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i - 1 NEW_LINE DEDENT
def printPattern ( n , m ) : NEW_LINE INDENT if ( m > 2 * ( n + 1 ) or m < n - 1 ) : NEW_LINE INDENT print ( "-1" , end = "" ) NEW_LINE DEDENT elif ( abs ( n - m ) <= 1 ) : NEW_LINE INDENT while ( n > 0 and m > 0 ) : NEW_LINE INDENT print ( "01" , end = "" ) NEW_LINE n -= 1 NEW_LINE m -= 1 NEW_LINE DEDENT if ( n != 0 ) : NEW_LINE INDENT print ( "0" , end = "" ) NEW_LINE DEDENT if ( m != 0 ) : NEW_LINE INDENT print ( "1" , end = "" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while ( m - n > 1 and n > 0 ) : NEW_LINE INDENT print ( "110" , end = "" ) NEW_LINE m = m - 2 NEW_LINE n = n - 1 NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT print ( "10" , end = "" ) NEW_LINE n -= 1 NEW_LINE m -= 1 NEW_LINE DEDENT while ( m > 0 ) : NEW_LINE INDENT print ( "1" , end = "" ) NEW_LINE m -= 1 NEW_LINE DEDENT DEDENT DEDENT
def printPermutation ( N , K ) : NEW_LINE INDENT res = list ( ) NEW_LINE l , r , flag = 1 , N , 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT if flag == False : NEW_LINE INDENT res . append ( l ) NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( r ) NEW_LINE r -= 1 NEW_LINE DEDENT flag = flag ^ 1 NEW_LINE DEDENT if flag == False : NEW_LINE INDENT for i in range ( r , 2 , - 1 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( l , r ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT for i in res : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def hasDigit ( hashMap , digit ) : NEW_LINE INDENT if hashMap [ digit ] > 0 : NEW_LINE INDENT hashMap [ digit ] -= 1 NEW_LINE return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def compute_z ( s , z ) : NEW_LINE INDENT l = 0 NEW_LINE r = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( i > r ) : NEW_LINE INDENT l = i NEW_LINE r = i NEW_LINE while ( r < n and s [ r - l ] == s [ r ] ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT z [ i ] = r - l NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = i - l NEW_LINE if ( z [ k ] < r - i + 1 ) : NEW_LINE INDENT z [ i ] = z [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT l = i NEW_LINE while ( r < n and s [ r - l ] == s [ r ] ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT z [ i ] = r - l NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countPermutation ( a , b ) : NEW_LINE INDENT b = b + b NEW_LINE b = b [ 0 : len ( b ) - 1 ] NEW_LINE ans = 0 NEW_LINE s = a + "$" + b NEW_LINE n = len ( s ) NEW_LINE z = [ 0 for i in range ( n ) ] NEW_LINE compute_z ( s , z ) NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( z [ i ] == len ( a ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countDecreasing ( A , n ) : NEW_LINE INDENT len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] < A [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) // 2 ) NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) // 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def doMatch ( A , B ) : NEW_LINE INDENT for i in range ( len ( A ) ) : NEW_LINE INDENT if A [ i ] != '*' and B [ i ] != '*' : NEW_LINE INDENT if A [ i ] != B [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def printRLE ( str , typed ) : NEW_LINE INDENT n = len ( str ) NEW_LINE m = len ( typed ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] != typed [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT if isVowel ( str [ i ] ) == False : NEW_LINE INDENT j = j + 1 NEW_LINE continue NEW_LINE DEDENT count1 = 1 NEW_LINE while ( i < n - 1 and ( str [ i ] == str [ i + 1 ] ) ) : NEW_LINE INDENT count1 = count1 + 1 NEW_LINE i = i + 1 NEW_LINE DEDENT count2 = 1 NEW_LINE while ( j < m - 1 and typed [ j ] == str [ i ] ) : NEW_LINE INDENT count2 = count2 + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT if count1 > count2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def minimumChar ( S1 , S2 ) : NEW_LINE INDENT n , m = len ( S1 ) , len ( S2 ) NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( m - n + 1 ) : NEW_LINE INDENT minRemovedChar = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( S1 [ j ] != S2 [ i + j ] ) : NEW_LINE INDENT minRemovedChar += 1 NEW_LINE DEDENT DEDENT ans = min ( minRemovedChar , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def fact ( N ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = product * i NEW_LINE DEDENT return product NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT return ( N * N ) * fact ( N ) NEW_LINE DEDENT
def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N ) * ( N + 2 ) // 2 ) NEW_LINE DEDENT
def factorial ( N ) : NEW_LINE INDENT if N == 0 or N == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return N * factorial ( N - 1 ) NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N ) * ( N + 2 ) // 2 ) NEW_LINE DEDENT
def check ( S1 , S2 ) : NEW_LINE INDENT n1 = len ( S1 ) NEW_LINE n2 = len ( S2 ) NEW_LINE mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT mp [ S1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 0 , n2 ) : NEW_LINE INDENT if mp [ S2 [ i ] ] : NEW_LINE INDENT mp [ S2 [ i ] ] -= 1 NEW_LINE DEDENT elif ( mp [ chr ( ord ( S2 [ i ] ) - 1 ) ] and mp [ chr ( ord ( S2 [ i ] ) - 2 ) ] ) : NEW_LINE INDENT mp [ chr ( ord ( S2 [ i ] ) - 1 ) ] -= 1 NEW_LINE mp [ chr ( ord ( S2 [ i ] ) - 2 ) ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def state1 ( c ) : NEW_LINE INDENT if ( c == 't' or c == 'T' ) : NEW_LINE INDENT dfa = 1 NEW_LINE DEDENT elif ( c == 'h' or c == 'H' ) : NEW_LINE INDENT dfa = 2 NEW_LINE DEDENT else : NEW_LINE INDENT dfa = 0 NEW_LINE DEDENT DEDENT
def state2 ( c ) : NEW_LINE INDENT if ( c == 'e' or c == 'E' ) : NEW_LINE INDENT dfa = 3 NEW_LINE DEDENT else : NEW_LINE INDENT dfa = 0 NEW_LINE DEDENT DEDENT
def state3 ( c ) : NEW_LINE INDENT if ( c == 't' or c == 'T' ) : NEW_LINE INDENT dfa = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dfa = 0 NEW_LINE DEDENT DEDENT
def isAccepted ( string ) : NEW_LINE INDENT length = len ( string ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( dfa == 0 ) : NEW_LINE INDENT start ( string [ i ] ) NEW_LINE DEDENT elif ( dfa == 1 ) : NEW_LINE INDENT state1 ( string [ i ] ) NEW_LINE DEDENT elif ( dfa == 2 ) : NEW_LINE INDENT state2 ( string [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT state3 ( string [ i ] ) NEW_LINE DEDENT DEDENT return ( dfa != 3 ) NEW_LINE DEDENT
def isSubstring ( s1 , s2 ) : NEW_LINE INDENT M = len ( s1 ) NEW_LINE N = len ( s2 ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( s2 [ i + j ] != s1 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j + 1 == M : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countFreq ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE res = 0 NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while j < M : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == M ) : NEW_LINE INDENT res += 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countPattern ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE oneSeen = False NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( s [ i ] == '1' and oneSeen ) : NEW_LINE INDENT if ( s [ i - 1 ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( s [ i ] == '1' and oneSeen == 0 ) : NEW_LINE INDENT oneSeen = True NEW_LINE DEDENT if ( s [ i ] != '0' and s [ i ] != '1' ) : NEW_LINE INDENT oneSeen = False NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def patternCount ( str ) : NEW_LINE INDENT last = str [ 0 ] NEW_LINE i = 1 NEW_LINE counter = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' and last == '1' ) : NEW_LINE INDENT while ( str [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE if ( str [ i ] == '1' ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT last = str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return counter NEW_LINE DEDENT
def maxPrefix ( s , t ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , len ( t ) ) : NEW_LINE INDENT if ( count == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( t [ i ] == s [ count ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def translate ( st ) : NEW_LINE INDENT for i in range ( 1 , len ( st ) ) : NEW_LINE INDENT if ( st [ i - 1 ] == 'A' and st [ i ] == 'B' ) : NEW_LINE INDENT st [ i - 1 ] = 'C' NEW_LINE for j in range ( i , len ( st ) - 1 ) : NEW_LINE INDENT st [ j ] = st [ j + 1 ] NEW_LINE DEDENT st [ len ( st ) - 1 ] = ' ' NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def isvalid ( row , col , prevRow , prevCol ) : NEW_LINE INDENT return ( row >= 0 ) and ( row < ROW ) and ( col >= 0 ) and ( col < COL ) and not ( row == prevRow and col == prevCol ) NEW_LINE DEDENT
def getNextState ( pat , M , state , x ) : NEW_LINE INDENT if state < M and x == ord ( pat [ state ] ) : NEW_LINE INDENT return state + 1 NEW_LINE DEDENT i = 0 NEW_LINE for ns in range ( state , 0 , - 1 ) : NEW_LINE INDENT if ord ( pat [ ns - 1 ] ) == x : NEW_LINE INDENT while ( i < ns - 1 ) : NEW_LINE INDENT if pat [ i ] != pat [ state - ns + 1 + i ] : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if i == ns - 1 : NEW_LINE INDENT return ns NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT
def calculate ( ans ) : NEW_LINE INDENT global maxi , ans1 NEW_LINE dp = [ 0 ] * 26 NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT dp [ ord ( ans [ i ] ) - ord ( 'A' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( dp [ i ] % 2 == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT if ( maxi < len ( ans ) ) : NEW_LINE INDENT maxi = len ( ans ) NEW_LINE ans1 = ans NEW_LINE DEDENT DEDENT
def longestString ( arr , index , string ) : NEW_LINE INDENT if ( index == len ( arr ) ) : NEW_LINE INDENT return NEW_LINE DEDENT longestString ( arr , index + 1 , string ) NEW_LINE string += arr [ index ] NEW_LINE calculate ( string ) NEW_LINE longestString ( arr , index + 1 , string ) NEW_LINE DEDENT
def countSubstrings ( str ) : NEW_LINE INDENT freq = [ 0 ] * 3 NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE for j in range ( 0 , len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ j ] ) - ord ( '0' ) ] += 1 NEW_LINE while ( freq [ 0 ] > 0 and freq [ 1 ] > 0 and freq [ 2 ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE freq [ ord ( str [ i ] ) - ord ( '0' ) ] -= 1 NEW_LINE DEDENT count += i NEW_LINE DEDENT return count NEW_LINE DEDENT
def minSwaps ( s ) : NEW_LINE INDENT ones = 0 NEW_LINE zeros = 0 NEW_LINE N = len ( s ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT DEDENT if ( ( N % 2 == 0 and ones != zeros ) or ( N % 2 == 1 and abs ( ones - zeros ) != 1 ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans_1 = 0 NEW_LINE j = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT ans_1 += abs ( j - i ) NEW_LINE j += 2 NEW_LINE DEDENT DEDENT ans_0 = 0 NEW_LINE k = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ans_0 += abs ( k - i ) NEW_LINE k += 2 NEW_LINE DEDENT DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return min ( ans_1 , ans_0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( ones > zeros ) : NEW_LINE INDENT return ans_1 NEW_LINE DEDENT else : NEW_LINE INDENT return ans_0 NEW_LINE DEDENT DEDENT DEDENT
def isOnesGreater ( S , N ) : NEW_LINE INDENT S = list ( S ) NEW_LINE cnt0 = 0 NEW_LINE cnt1 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == '1' ) : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt0 += 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == '1' ) : NEW_LINE INDENT if ( i > 0 and S [ i - 1 ] == '0' ) : NEW_LINE INDENT S [ i - 1 ] = '_' NEW_LINE cnt0 -= 1 NEW_LINE DEDENT elif ( i < N and S [ i + 1 ] == '0' ) : NEW_LINE INDENT S [ i + 1 ] = '_' NEW_LINE cnt0 -= 1 NEW_LINE DEDENT DEDENT DEDENT if ( cnt1 > cnt0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def findString ( arr , N ) : NEW_LINE INDENT ans = "" NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans += '1' if arr [ i ] [ i ] == '0' else '0' NEW_LINE DEDENT return ans NEW_LINE DEDENT
def waysToClearString ( S ) : NEW_LINE INDENT for i in range ( 505 ) : NEW_LINE INDENT for j in range ( 505 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT n = len ( S ) NEW_LINE choose [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , ( n // 2 ) + 1 ) : NEW_LINE INDENT choose [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT choose [ i ] [ j ] = choose [ i - 1 ] [ j ] + choose [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT return calc ( 0 , n - 1 , S ) NEW_LINE DEDENT
def minFlips ( st ) : NEW_LINE INDENT count = 0 NEW_LINE if ( len ( st ) <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( len ( st ) - 2 ) : NEW_LINE INDENT if ( st [ i ] == st [ i + 1 ] and st [ i + 2 ] == st [ i + 1 ] ) : NEW_LINE INDENT i = i + 3 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findMissingDigit ( a , b , c ) : NEW_LINE INDENT w = 1 NEW_LINE a_mod_11 = 0 NEW_LINE for i in range ( len ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT a_mod_11 = ( a_mod_11 + w * ( ord ( a [ i ] ) - ord ( '0' ) ) ) % 11 NEW_LINE w = w * - 1 NEW_LINE DEDENT b_mod_11 = 0 NEW_LINE w = 1 NEW_LINE for i in range ( len ( b ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT b_mod_11 = ( b_mod_11 + w * ( ord ( b [ i ] ) - ord ( '0' ) ) ) % 11 NEW_LINE w = w * - 1 NEW_LINE DEDENT c_mod_11 = 0 NEW_LINE xSignIsPositive = True NEW_LINE w = 1 NEW_LINE for i in range ( len ( c ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( c [ i ] == 'x' ) : NEW_LINE INDENT xSignIsPositive = ( w == 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT c_mod_11 = ( c_mod_11 + w * ( ord ( c [ i ] ) - ord ( '0' ) ) ) % 11 NEW_LINE DEDENT w = w * - 1 NEW_LINE DEDENT x = ( ( a_mod_11 * b_mod_11 ) - c_mod_11 ) % 11 NEW_LINE if ( not xSignIsPositive ) : NEW_LINE INDENT x = - x NEW_LINE DEDENT return ( x % 11 + 11 ) % 11 NEW_LINE DEDENT
def validInsertionstring ( S1 , S2 ) : NEW_LINE INDENT N = len ( S1 ) NEW_LINE M = len ( S2 ) NEW_LINE st = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT st . append ( S1 [ i ] ) NEW_LINE if ( S1 [ i ] == S2 [ M - 1 ] ) : NEW_LINE INDENT idx = M - 1 NEW_LINE while ( idx >= 0 ) : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE if ( c != S2 [ idx ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT idx -= 1 NEW_LINE DEDENT DEDENT DEDENT if ( len ( st ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def lengthNPalindrome ( N , K ) : NEW_LINE INDENT half = N // 2 NEW_LINE if ( N & 1 ) : NEW_LINE INDENT half += 1 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 1 , half + 1 ) : NEW_LINE INDENT ans *= K NEW_LINE K -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def palindromicStrings ( N , K ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return K NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return 2 * K NEW_LINE DEDENT ans = 0 NEW_LINE ans += ( 2 * K ) NEW_LINE for i in range ( 3 , N + 1 ) : NEW_LINE INDENT ans += lengthNPalindrome ( i , K ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def LCS ( S , N , T , M , dp ) : NEW_LINE INDENT if ( N == 0 or M == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ N ] [ M ] != 0 ) : NEW_LINE INDENT return dp [ N ] [ M ] NEW_LINE DEDENT if ( S [ N - 1 ] == T [ M - 1 ] ) : NEW_LINE INDENT dp [ N ] [ M ] = 1 + LCS ( S , N - 1 , T , M - 1 , dp ) NEW_LINE return dp [ N ] [ M ] NEW_LINE DEDENT dp [ N ] [ M ] = max ( LCS ( S , N - 1 , T , M , dp ) , LCS ( S , N , T , M - 1 , dp ) ) NEW_LINE return dp [ N ] [ M ] NEW_LINE DEDENT
def maxlength ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count = 1 NEW_LINE j = i + 1 NEW_LINE while ( j <= n - 1 and s [ j ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE DEDENT ans = max ( ans , count ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maximumK ( S ) : NEW_LINE INDENT N = len ( S ) NEW_LINE ans = N NEW_LINE flag = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( S [ i ] != S [ i + 1 ] ) : NEW_LINE INDENT flag = 1 NEW_LINE ans = min ( ans , max ( i + 1 , N - i - 1 ) ) NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findIfPossible ( N , str_ ) : NEW_LINE INDENT countG = 0 NEW_LINE countF = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if str_ [ i ] == 'G' : NEW_LINE INDENT countG += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countF += 1 NEW_LINE DEDENT DEDENT if 2 * countF != countG : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT else : NEW_LINE INDENT id = 0 NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if str_ [ i ] == 'G' : NEW_LINE INDENT countG -= 1 NEW_LINE id += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countF -= 1 NEW_LINE id -= 1 NEW_LINE DEDENT if id < 0 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT if countG < countF : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT DEDENT
def findComb ( N , M ) : NEW_LINE INDENT x = fact ( N + 1 ) NEW_LINE y = fact ( M ) NEW_LINE return ( x * y ) NEW_LINE DEDENT
def isPossible ( str1 , str2 ) : NEW_LINE INDENT arr = { } NEW_LINE l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE possible = True NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT arr [ str1 [ i ] ] = 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT if str2 [ i ] != ' ' : NEW_LINE INDENT if arr [ str2 [ i ] ] == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT possible = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if possible : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def check ( S ) : NEW_LINE INDENT for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT if ( S [ i - 1 ] == S [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findMinimumSwaps ( S ) : NEW_LINE INDENT global ansSwaps NEW_LINE ansSwaps = sys . maxsize NEW_LINE minimumSwaps ( S , 0 , 0 ) NEW_LINE if ( ansSwaps == sys . maxsize ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ansSwaps ) NEW_LINE DEDENT DEDENT
def FindKthChar ( Str , K , X ) : NEW_LINE INDENT ans = ' ' NEW_LINE Sum = 0 NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT digit = ord ( Str [ i ] ) - 48 NEW_LINE Range = int ( math . pow ( digit , X ) ) NEW_LINE Sum += Range NEW_LINE if ( K <= Sum ) : NEW_LINE INDENT ans = Str [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def convertToHex ( num ) : NEW_LINE INDENT temp = "" NEW_LINE while ( num != 0 ) : NEW_LINE INDENT rem = num % 16 NEW_LINE c = 0 NEW_LINE if ( rem < 10 ) : NEW_LINE INDENT c = rem + 48 NEW_LINE DEDENT else : NEW_LINE INDENT c = rem + 87 NEW_LINE DEDENT temp += chr ( c ) NEW_LINE num = num // 16 NEW_LINE DEDENT return temp NEW_LINE DEDENT
def minimumHammingDistance ( S , K ) : NEW_LINE INDENT n = len ( S ) NEW_LINE pref = [ 0 ] * n NEW_LINE pref [ 0 ] = ord ( S [ 0 ] ) - ord ( '0' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + ( ord ( S [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT cnt = pref [ n - 1 ] NEW_LINE ans = cnt NEW_LINE for i in range ( n - K ) : NEW_LINE INDENT value = pref [ i + K - 1 ] - ( pref [ i - 1 ] if ( i - 1 ) >= 0 else 0 ) NEW_LINE ans = min ( ans , cnt - value + ( K - value ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def checkPermutation ( s1 , s2 ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for ch in s1 : NEW_LINE INDENT if ord ( ch ) - 97 in freq : NEW_LINE INDENT freq [ ord ( ch ) - 97 ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ ord ( ch ) - 97 ] = 1 NEW_LINE DEDENT DEDENT for ch in s2 : NEW_LINE INDENT if ord ( ch ) - 97 in freq : NEW_LINE INDENT freq [ ord ( ch ) - 97 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ ord ( ch ) - 97 ] = 1 NEW_LINE DEDENT DEDENT isAllChangesPrime = True NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( isPrime ( abs ( freq [ i ] ) ) == False ) : NEW_LINE INDENT isAllChangesPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( isAllChangesPrime == False ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def minimumOperations ( S , N ) : NEW_LINE INDENT ans = 0 NEW_LINE cntOne = 0 NEW_LINE i = N - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT ans += cntOne NEW_LINE cntOne *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT cntOne += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def differentBitwiseOR ( s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE t00 = 0 NEW_LINE t10 = 0 NEW_LINE t01 = 0 NEW_LINE t11 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s1 [ i ] == '0' and s2 [ i ] == '0' ) : NEW_LINE INDENT t00 += 1 NEW_LINE DEDENT if ( s1 [ i ] == '1' and s2 [ i ] == '0' ) : NEW_LINE INDENT t10 += 1 NEW_LINE DEDENT if ( s1 [ i ] == '1' and s2 [ i ] == '1' ) : NEW_LINE INDENT t11 += 1 NEW_LINE DEDENT if ( s1 [ i ] == '0' and s2 [ i ] == '1' ) : NEW_LINE INDENT t01 += 1 NEW_LINE DEDENT DEDENT ans = t00 * t10 + t01 * t10 + t00 * t11 NEW_LINE print ( ans ) NEW_LINE DEDENT
def RemoveCharacters ( s ) : NEW_LINE INDENT ans = "" NEW_LINE c = [ 0 for i in range ( 26 ) ] NEW_LINE pos = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( c [ ord ( s [ i ] ) - 97 ] == 0 ) : NEW_LINE INDENT c [ ord ( s [ i ] ) - 97 ] = 1 NEW_LINE pos = i NEW_LINE ans += s [ i ] NEW_LINE DEDENT DEDENT for i in range ( pos + 1 , len ( s ) , 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ 0 ] ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def changeCharacters ( S , N , K ) : NEW_LINE INDENT flag = 1 NEW_LINE count = 0 NEW_LINE st = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if len ( st ) == 0 : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT count = 0 NEW_LINE st . append ( S [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count == K ) : NEW_LINE INDENT del st [ - 1 ] NEW_LINE count = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def findSubsequence ( S , ch ) : NEW_LINE INDENT N = len ( S ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == ch ) : NEW_LINE INDENT ans += 1 NEW_LINE ch = chr ( ord ( ch ) + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findMaxSubsequence ( S ) : NEW_LINE INDENT ans = 0 NEW_LINE for ch in range ( ord ( 'a' ) , ord ( 'z' ) + 1 ) : NEW_LINE INDENT ans = max ( ans , findSubsequence ( S , chr ( ch ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minOpsToEmptyString ( s ) : NEW_LINE INDENT ans = - 10 ** 9 NEW_LINE cn0 = 0 NEW_LINE cn1 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT if ( cn1 > 0 ) : NEW_LINE INDENT cn1 -= 1 NEW_LINE DEDENT cn0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( cn0 > 0 ) : NEW_LINE INDENT cn0 -= 1 NEW_LINE DEDENT cn1 += 1 NEW_LINE DEDENT ans = max ( [ ans , cn0 , cn1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def prefixDivisble ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if n % i != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isPrime ( num ) : NEW_LINE INDENT flag = False NEW_LINE if num > 1 : NEW_LINE INDENT for i in range ( 2 , num ) : NEW_LINE INDENT if ( num % i ) == 0 : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if flag : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def order ( x ) : NEW_LINE INDENT n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT n = n + 1 NEW_LINE x = x // 10 NEW_LINE DEDENT return n NEW_LINE DEDENT
def isArmstrong ( x ) : NEW_LINE INDENT n = order ( x ) NEW_LINE temp = x NEW_LINE sum1 = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT r = temp % 10 NEW_LINE sum1 = sum1 + r ** n NEW_LINE temp = temp // 10 NEW_LINE DEDENT return ( sum1 == x ) NEW_LINE DEDENT
def count_armstrong ( li ) : NEW_LINE INDENT c = 0 NEW_LINE for ele in li : NEW_LINE INDENT val = 0 NEW_LINE for che in ele : NEW_LINE INDENT val += ord ( che ) NEW_LINE DEDENT if isArmstrong ( val ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT
def count_prime ( li ) : NEW_LINE INDENT c = 0 NEW_LINE for ele in li : NEW_LINE INDENT val = 0 NEW_LINE for che in ele : NEW_LINE INDENT val += ord ( che ) NEW_LINE DEDENT if isPrime ( val ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT
def findMinimumCost ( s , N ) : NEW_LINE INDENT count_1 , count_0 = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT DEDENT k = abs ( count_0 - count_1 ) NEW_LINE if ( count_1 == N or count_0 == N ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k // 2 ) NEW_LINE DEDENT DEDENT
def countOccurrences ( S , X , Y ) : NEW_LINE INDENT count = 0 NEW_LINE N = len ( S ) NEW_LINE A = len ( X ) NEW_LINE B = len ( Y ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( S [ i : i + B ] == Y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( S [ i : i + A ] == X ) : NEW_LINE INDENT print ( count , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def findLength ( str , n ) : NEW_LINE INDENT pre = [ 0 ] * n NEW_LINE post = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT pre [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i != ( n - 1 ) ) : NEW_LINE INDENT post [ i ] += post [ i + 1 ] NEW_LINE DEDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT post [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , pre [ i ] + post [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countSubstring ( S , N ) : NEW_LINE INDENT prevSum = { } NEW_LINE res = 0 NEW_LINE currentSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] >= 'A' and S [ i ] <= 'Z' ) : NEW_LINE INDENT currentSum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT currentSum -= 1 NEW_LINE DEDENT if ( currentSum == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( currentSum in prevSum ) : NEW_LINE INDENT res += ( prevSum [ currentSum ] ) NEW_LINE DEDENT if currentSum in prevSum : NEW_LINE INDENT prevSum [ currentSum ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT prevSum [ currentSum ] = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def checkforSubsequence ( S , target ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( len ( target ) ) : NEW_LINE INDENT s . append ( target [ i ] ) NEW_LINE DEDENT for i in range ( len ( S ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE return NEW_LINE DEDENT if ( S [ i ] == s [ - 1 ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT DEDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def makeDFA ( ) : NEW_LINE INDENT global dfa NEW_LINE dfa [ 0 ] [ 0 ] = 1 NEW_LINE dfa [ 1 ] [ 0 ] = 1 NEW_LINE dfa [ 1 ] [ 2 ] = 3 NEW_LINE dfa [ 1 ] [ 3 ] = 2 NEW_LINE dfa [ 1 ] [ 4 ] = 6 NEW_LINE dfa [ 3 ] [ 0 ] = 4 NEW_LINE dfa [ 4 ] [ 0 ] = 4 NEW_LINE dfa [ 4 ] [ 3 ] = 5 NEW_LINE dfa [ 4 ] [ 4 ] = 6 NEW_LINE dfa [ 6 ] [ 0 ] = 8 NEW_LINE dfa [ 6 ] [ 1 ] = 7 NEW_LINE dfa [ 7 ] [ 0 ] = 8 NEW_LINE dfa [ 8 ] [ 0 ] = 8 NEW_LINE dfa [ 8 ] [ 3 ] = 9 NEW_LINE DEDENT
def buildDFA ( ) : NEW_LINE INDENT global dfa NEW_LINE for i in range ( 11 ) : NEW_LINE INDENT for j in range ( 5 ) : NEW_LINE INDENT dfa [ i ] [ j ] = 10 NEW_LINE DEDENT DEDENT makeDFA ( ) NEW_LINE DEDENT
def checkDFA ( s ) : NEW_LINE INDENT buildDFA ( ) NEW_LINE currentstate = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] in digits ) : NEW_LINE INDENT currentstate = dfa [ currentstate ] [ 0 ] NEW_LINE DEDENT elif ( s [ i ] in sign ) : NEW_LINE INDENT currentstate = dfa [ currentstate ] [ 1 ] NEW_LINE DEDENT elif ( s [ i ] in dot ) : NEW_LINE INDENT currentstate = dfa [ currentstate ] [ 2 ] NEW_LINE DEDENT elif ( s [ i ] in ex ) : NEW_LINE INDENT currentstate = dfa [ currentstate ] [ 4 ] NEW_LINE DEDENT else : NEW_LINE INDENT currentstate = dfa [ currentstate ] [ 3 ] NEW_LINE DEDENT DEDENT if ( currentstate == 1 or currentstate == 4 or currentstate == 8 ) : NEW_LINE INDENT print ( "Unsigned integer" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Not an unsigned integer" ) NEW_LINE DEDENT DEDENT
def getString ( N ) : NEW_LINE INDENT ans = "" NEW_LINE while ( N >= 26 ) : NEW_LINE INDENT ans += 'z' NEW_LINE N -= 26 NEW_LINE DEDENT ans += chr ( N + ord ( 'a' ) - 1 ) NEW_LINE return ans NEW_LINE DEDENT
def subString ( s , n ) : NEW_LINE INDENT hash = { 0 : 1 } NEW_LINE pre = 0 NEW_LINE count = 0 NEW_LINE for i in s : NEW_LINE INDENT pre ^= ( 1 << ord ( i ) - 97 ) NEW_LINE count += hash . get ( pre , 0 ) NEW_LINE hash [ pre ] = hash . get ( pre , 0 ) + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countSamePrefixSuffix ( s , n ) : NEW_LINE INDENT prefix = "" NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT prefix += s [ i ] NEW_LINE suffix = s [ n - 1 - i : 2 * n - 2 - i ] NEW_LINE if ( prefix == suffix ) : NEW_LINE INDENT print ( len ( prefix ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def atleastkDistinctChars ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE mp = defaultdict ( int ) NEW_LINE begin = 0 NEW_LINE end = 0 NEW_LINE ans = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT c = s [ end ] NEW_LINE mp += 1 NEW_LINE end += 1 NEW_LINE while ( len ( mp ) >= k ) : NEW_LINE INDENT pre = s [ begin ] NEW_LINE mp [ pre ] -= 1 NEW_LINE if ( mp [ pre ] == 0 ) : NEW_LINE INDENT del mp [ pre ] NEW_LINE DEDENT ans += len ( s ) - end + 1 NEW_LINE begin += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def minimumMoves ( s , n , k ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT countOpen = s . count ( '(' ) NEW_LINE countClose = s . count ( ')' ) NEW_LINE if ( countOpen != countClose ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT ans = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '(' ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt -= 1 NEW_LINE if ( cnt < 0 ) : NEW_LINE INDENT cnt = 0 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT DEDENT if ( ans <= k ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def inOrder ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT cur = leftMost ( root ) NEW_LINE while cur != None : NEW_LINE INDENT print ( cur . key , end = " " ) NEW_LINE if cur . isThreaded : NEW_LINE INDENT cur = cur . right NEW_LINE DEDENT else : NEW_LINE INDENT cur = leftMost ( cur . right ) NEW_LINE DEDENT DEDENT DEDENT
def countFrequency ( S , N ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq [ ord ( S [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT lg = int ( log2 ( freq [ i ] ) ) NEW_LINE a = pow ( 2 , lg ) NEW_LINE if ( a == freq [ i ] ) : NEW_LINE INDENT while ( freq [ i ] ) : NEW_LINE INDENT print ( chr ( i + ord ( 'a' ) ) , end = "" ) NEW_LINE freq [ i ] -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def buildTree ( s , tree , start , end , treeNode ) : NEW_LINE INDENT if ( start == end ) : NEW_LINE INDENT tree [ treeNode ] . square_sum = pow ( ord ( s [ start ] ) - ord ( 'a' ) + 1 , 2 ) NEW_LINE return NEW_LINE DEDENT mid = start + ( ( end - start ) // 2 ) NEW_LINE buildTree ( s , tree , start , mid , 2 * treeNode ) NEW_LINE buildTree ( s , tree , mid + 1 , end , 1 + 2 * treeNode ) NEW_LINE tree [ treeNode ] . square_sum = ( tree [ ( 2 * treeNode ) ] . square_sum + tree [ ( 2 * treeNode ) + 1 ] . square_sum ) NEW_LINE DEDENT
def querySquareSum ( tree , start , end , treeNode , l , r ) : NEW_LINE INDENT if ( ( l > end ) or ( r < start ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( l <= start ) and ( r >= end ) ) : NEW_LINE INDENT return tree [ treeNode ] . square_sum NEW_LINE DEDENT mid = start + ( ( end - start ) // 2 ) NEW_LINE X = querySquareSum ( tree , start , mid , 2 * treeNode , l , r ) NEW_LINE Y = + querySquareSum ( tree , mid + 1 , end , 1 + 2 * treeNode , l , r ) NEW_LINE return X + Y NEW_LINE DEDENT
def canSplit ( S ) : NEW_LINE INDENT frequency = [ 0 ] * 26 NEW_LINE cnt_singles = 0 NEW_LINE k = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT frequency [ ord ( S [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT odd = 0 NEW_LINE eve = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( frequency [ i ] ) : NEW_LINE INDENT odd += ( frequency [ i ] & 1 ) NEW_LINE eve += frequency [ i ] // 2 NEW_LINE DEDENT DEDENT if ( eve >= odd ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def isPossible ( S , R , N ) : NEW_LINE INDENT cntl = 0 NEW_LINE cntr = 0 NEW_LINE cntu = 0 NEW_LINE cntd = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == 'L' ) : NEW_LINE INDENT cntl += 1 NEW_LINE DEDENT elif ( S [ i ] == 'R' ) : NEW_LINE INDENT cntr += 1 NEW_LINE DEDENT elif ( S [ i ] == 'U' ) : NEW_LINE INDENT cntu += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntd += 1 NEW_LINE DEDENT DEDENT if ( max ( max ( cntl , cntr ) , max ( cntu , cntd ) ) >= R ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT mp = { } NEW_LINE r_square = R * R NEW_LINE i = 1 NEW_LINE while i * i <= r_square : NEW_LINE INDENT mp [ i * i ] = i NEW_LINE if ( ( r_square - i * i ) in mp ) : NEW_LINE INDENT if ( max ( cntl , cntr ) >= mp [ r_square - i * i ] and max ( cntu , cntd ) >= i ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT if ( max ( cntl , cntr ) >= i and max ( cntu , cntd ) >= mp [ r_square - i * i ] ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return "No" NEW_LINE DEDENT
def inorder ( root ) : NEW_LINE INDENT leftdone = False NEW_LINE while root : NEW_LINE INDENT if leftdone == False : NEW_LINE INDENT while root . left : NEW_LINE INDENT root = root . left NEW_LINE DEDENT DEDENT print ( root . key , end = " " ) NEW_LINE leftdone = True NEW_LINE if root . right : NEW_LINE INDENT leftdone = False NEW_LINE root = root . right NEW_LINE DEDENT elif root . parent : NEW_LINE INDENT while root . parent and root == root . parent . right : NEW_LINE INDENT root = root . parent NEW_LINE DEDENT if root . parent == None : NEW_LINE INDENT break NEW_LINE DEDENT root = root . parent NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def findDuplicate ( arr , n , k ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 1 and arr [ i ] > MAX ) : NEW_LINE INDENT print "Out of range" NEW_LINE return - 1 NEW_LINE DEDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def nearestPowerOfTwo ( S ) : NEW_LINE INDENT N = len ( S ) NEW_LINE freq = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] in freq ) : NEW_LINE INDENT freq [ S [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ S [ i ] ] = 1 NEW_LINE DEDENT DEDENT nearestPowerOfTwoUtil ( freq ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def lcm ( a , b ) : NEW_LINE INDENT return ( a // gcd ( a , b ) ) * b NEW_LINE DEDENT
def canMakeSame ( s1 , s2 ) : NEW_LINE INDENT ans = - 1 NEW_LINE if ( len ( s1 ) != len ( s2 ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT N = len ( s1 ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( s1 [ i ] != s2 [ i ] ) : NEW_LINE INDENT while ( i < len ( s1 ) and s1 [ i ] != s2 [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def printSorted ( arr , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return NEW_LINE DEDENT printSorted ( arr , start * 2 + 1 , end ) NEW_LINE print ( arr [ start ] , end = " " ) NEW_LINE printSorted ( arr , start * 2 + 2 , end ) NEW_LINE DEDENT
def minDeletions ( str ) : NEW_LINE INDENT fre = [ 0 ] * 26 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT fre [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( fre [ i ] % 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == 0 or count == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return count - 1 NEW_LINE DEDENT DEDENT
def countTotalFrequencies ( S1 , S2 ) : NEW_LINE INDENT bset = set ( S1 ) NEW_LINE count = 0 NEW_LINE for x in S2 : NEW_LINE INDENT if x in bset : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def min_length ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE total_zeros = 0 NEW_LINE total_ones = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT total_zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT total_ones += 1 NEW_LINE DEDENT DEDENT ans = min ( total_zeros , total_ones ) NEW_LINE cur_zeros = 0 NEW_LINE cur_ones = 0 NEW_LINE for x in str : NEW_LINE INDENT if ( x == '0' ) : NEW_LINE INDENT cur_zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cur_ones += 1 NEW_LINE DEDENT ans = min ( ans , cur_ones + ( total_zeros - cur_zeros ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def findWinner ( a , n ) : NEW_LINE INDENT v = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( c != 0 ) : NEW_LINE INDENT v . append ( c ) NEW_LINE DEDENT c = 0 NEW_LINE DEDENT DEDENT if ( c != 0 ) : NEW_LINE INDENT v . append ( c ) NEW_LINE DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT print ( "Player B" , end = "" ) NEW_LINE return NEW_LINE DEDENT if ( len ( v ) == 1 ) : NEW_LINE INDENT if ( ( v [ 0 ] & 1 ) != 0 ) : NEW_LINE INDENT print ( "Player A" , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Player B" , end = "" ) NEW_LINE DEDENT return NEW_LINE DEDENT first = sys . minsize NEW_LINE second = sys . minsize NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( a [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = a [ i ] NEW_LINE DEDENT elif ( a [ i ] > second and a [ i ] != first ) : NEW_LINE INDENT second = a [ i ] NEW_LINE DEDENT DEDENT if ( ( ( first & 1 ) != 0 ) and ( first + 1 ) // 2 > second ) : NEW_LINE INDENT print ( "Player A" , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Player B" , end = "" ) NEW_LINE DEDENT DEDENT
def minimumSwaps ( s , l , r , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE tot_ones , tot_zeros = 0 , 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT tot_ones += 1 NEW_LINE DEDENT else : NEW_LINE INDENT tot_zeros += 1 NEW_LINE DEDENT DEDENT ones , zeros , Sum = 0 , 0 , 0 NEW_LINE for i in range ( l - 1 , r ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT ones += 1 NEW_LINE Sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT DEDENT rem_ones = tot_ones - ones NEW_LINE rem_zeros = tot_zeros - zeros NEW_LINE if ( k >= Sum ) : NEW_LINE INDENT rem = k - Sum NEW_LINE if ( zeros >= rem and rem_ones >= rem ) : NEW_LINE INDENT return rem NEW_LINE DEDENT DEDENT elif ( k < Sum ) : NEW_LINE INDENT rem = Sum - k NEW_LINE if ( ones >= rem and rem_zeros >= rem ) : NEW_LINE INDENT return rem NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def longHelper ( freq1 , freq2 ) : NEW_LINE INDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq1 [ i ] != freq2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def longCommomPrefixAnagram ( s1 , s2 , n1 , n2 ) : NEW_LINE INDENT freq1 = [ 0 ] * 26 NEW_LINE freq2 = [ 0 ] * 26 NEW_LINE ans = 0 NEW_LINE mini_len = min ( n1 , n2 ) NEW_LINE for i in range ( mini_len ) : NEW_LINE INDENT freq1 [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE freq2 [ ord ( s2 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE if ( longHelper ( freq1 , freq2 ) ) : NEW_LINE INDENT ans = i + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def getMin ( arr ) : NEW_LINE INDENT minSum = float ( 'inf' ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT curSum = 0 NEW_LINE for num in arr : NEW_LINE INDENT curSum += remove ( num , i ) NEW_LINE DEDENT minSum = min ( minSum , curSum ) NEW_LINE DEDENT print ( minSum ) NEW_LINE DEDENT
def isReducible ( Str ) : N = len ( Str ) NEW_LINE s = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( Str [ i ] == '1' ) : NEW_LINE INDENT s . append ( Str [ i ] ) NEW_LINE DEDENT DEDENT elif ( len ( s ) > 0 ) : NEW_LINE INDENT del s [ len ( s ) - 1 ] NEW_LINE DEDENT else : return False NEW_LINE if ( len ( s ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT
def checkPalindrome ( s ) : NEW_LINE INDENT low , high = 0 , len ( s ) - 1 NEW_LINE while ( low < high ) : NEW_LINE INDENT if ( s [ low ] != s [ high ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def populateNumber ( ) : NEW_LINE INDENT Ans . append ( 2 ) NEW_LINE Ans . append ( 5 ) NEW_LINE x = 5 NEW_LINE while ( x < 1000000000001 ) : NEW_LINE INDENT x *= 2 NEW_LINE Ans . append ( x ) NEW_LINE x = x * 2 + 1 NEW_LINE Ans . append ( x ) NEW_LINE DEDENT DEDENT
def checkString ( N ) : NEW_LINE INDENT populateNumber ( ) NEW_LINE for it in Ans : NEW_LINE INDENT if ( it == N ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT DEDENT return "No" NEW_LINE DEDENT
def DFA ( str , N ) : NEW_LINE INDENT if ( N <= 1 ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE if ( str [ 0 ] == 'C' ) : NEW_LINE INDENT count += 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( str [ i ] == 'A' or str [ i ] == 'B' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT if ( count == N ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def balanced ( small , caps ) : NEW_LINE INDENT for i in range ( 26 ) : NEW_LINE INDENT if ( small [ i ] != 0 and ( caps [ i ] == 0 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( small [ i ] == 0 ) and ( caps [ i ] != 0 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def GCD ( lena , lenb ) : NEW_LINE INDENT if ( lena == 0 ) : NEW_LINE INDENT return lenb NEW_LINE DEDENT if ( lenb == 0 ) : NEW_LINE INDENT return lena NEW_LINE DEDENT if ( lena == lenb ) : NEW_LINE INDENT return lena NEW_LINE DEDENT if ( lena > lenb ) : NEW_LINE INDENT return GCD ( lena - lenb , lenb ) NEW_LINE DEDENT return GCD ( lena , lenb - lena ) NEW_LINE DEDENT
def cntBalancedParenthesis ( s , N ) : NEW_LINE INDENT cntPairs = 0 NEW_LINE cntCurly = 0 NEW_LINE cntSml = 0 NEW_LINE cntSqr = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( ord ( s [ i ] ) == ord ( '{' ) ) : NEW_LINE INDENT cntCurly += 1 NEW_LINE DEDENT elif ( ord ( s [ i ] ) == ord ( '(' ) ) : NEW_LINE INDENT cntSml += 1 NEW_LINE DEDENT elif ( ord ( s [ i ] ) == ord ( '[' ) ) : NEW_LINE INDENT cntSqr += 1 NEW_LINE DEDENT elif ( ord ( s [ i ] ) == ord ( '}' ) and cntCurly > 0 ) : NEW_LINE INDENT cntCurly -= 1 NEW_LINE cntPairs += 1 NEW_LINE DEDENT elif ( ord ( s [ i ] ) == ord ( ')' ) and cntSml > 0 ) : NEW_LINE INDENT cntSml -= 1 NEW_LINE cntPairs += 1 NEW_LINE DEDENT elif ( ord ( s [ i ] ) == ord ( ']' ) and cntSqr > 0 ) : NEW_LINE INDENT cntSqr -= 1 NEW_LINE cntPairs += 1 NEW_LINE DEDENT DEDENT print ( cntPairs ) NEW_LINE DEDENT
def canBeBalanced ( sequence ) : NEW_LINE INDENT if ( len ( sequence ) % 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT stack_ , stack2_ = [ ] , [ ] NEW_LINE countOpen , countClosed = 0 , 0 NEW_LINE countSymbol = 0 NEW_LINE for i in range ( len ( sequence ) ) : NEW_LINE INDENT if ( sequence [ i ] == ')' ) : NEW_LINE INDENT countClosed += 1 NEW_LINE if ( len ( stack_ ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT del stack_ [ - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( sequence [ i ] == '$' ) : NEW_LINE INDENT countSymbol += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countOpen += 1 NEW_LINE DEDENT stack_ . append ( sequence [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( sequence ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ i ] == '(' ) : NEW_LINE INDENT if ( len ( stack2_ ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT del stack2_ [ - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT stack2_ . append ( sequence [ i ] ) NEW_LINE DEDENT DEDENT extra = abs ( countClosed - countOpen ) NEW_LINE if ( countSymbol < extra ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT countSymbol -= extra NEW_LINE if ( countSymbol % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def maximum_pallindromic ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT res += arr [ i ] // 3 NEW_LINE arr [ i ] = arr [ i ] % 3 NEW_LINE if ( arr [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT elif ( arr [ i ] == 2 ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT res += min ( c1 , c2 ) NEW_LINE t = min ( c1 , c2 ) NEW_LINE c1 -= t NEW_LINE c2 -= t NEW_LINE res += 2 * ( c2 // 3 ) NEW_LINE c2 %= 3 NEW_LINE res += c2 // 2 NEW_LINE print ( res ) NEW_LINE DEDENT
def inorder ( root ) : NEW_LINE INDENT if root != None : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . key , "(" , root . count , ")" , end = " " ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT
def query ( BIT , idx , i ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT ans += BIT [ idx ] [ i ] NEW_LINE DEDENT i = i - ( i & ( - i ) ) NEW_LINE return ans NEW_LINE DEDENT
def minOperation ( arr , N ) : NEW_LINE INDENT cntMinOP = 0 NEW_LINE M = len ( arr [ 0 ] ) NEW_LINE hash = [ [ 0 for i in range ( M ) ] for j in range ( 256 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT hash [ ord ( arr [ i ] [ j ] ) ] [ j ] += 1 NEW_LINE DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT Sum = 0 NEW_LINE Max = 0 NEW_LINE for j in range ( 256 ) : NEW_LINE INDENT Sum += hash [ j ] [ i ] NEW_LINE Max = max ( Max , hash [ j ] [ i ] ) NEW_LINE DEDENT cntMinOP += ( Sum - Max ) NEW_LINE DEDENT return cntMinOP NEW_LINE DEDENT
def find_Winner ( arr , N ) : NEW_LINE INDENT Q = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT Q [ i ] = [ ] NEW_LINE DEDENT M = len ( arr ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT Len = len ( arr [ i ] ) NEW_LINE for j in range ( Len ) : NEW_LINE INDENT Q [ i ] . append ( ord ( arr [ i ] [ j ] ) - 1 ) NEW_LINE DEDENT DEDENT player = 0 NEW_LINE while ( len ( Q [ player ] ) > 0 ) : NEW_LINE INDENT nextPlayer = Q [ player ] [ 0 ] - ord ( '0' ) NEW_LINE del Q [ player ] [ 0 ] NEW_LINE player = nextPlayer NEW_LINE DEDENT print ( "Player" , ( player + 1 ) ) NEW_LINE DEDENT
def longestSubstring ( s ) : NEW_LINE INDENT dp = [ 1024 for i in range ( 1024 ) ] NEW_LINE res , mask = 0 , 0 NEW_LINE dp [ 0 ] = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT mask ^= 1 << ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE res = max ( res , i - dp [ mask ] ) NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT res = max ( res , i - dp [ mask ^ ( 1 << j ) ] ) NEW_LINE DEDENT dp [ mask ] = min ( dp [ mask ] , i ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countStrings ( S , list ) : NEW_LINE INDENT valid = { } NEW_LINE for x in S : NEW_LINE INDENT valid [ x ] = 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( len ( list ) ) : NEW_LINE INDENT j = 0 NEW_LINE while j < len ( list [ i ] ) : NEW_LINE INDENT if ( list [ i ] [ j ] in valid ) : NEW_LINE INDENT j += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == len ( list [ i ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def inorder ( root ) : NEW_LINE INDENT if root != None : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . key , end = " " ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT
def countStrings ( s , k ) : NEW_LINE INDENT ans = 1 NEW_LINE lenn = len ( s ) NEW_LINE flag = 0 NEW_LINE DEDENT
def minLength ( Str , N , K , M ) : NEW_LINE INDENT stackOfChar = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT stackOfChar . append ( Str [ i ] ) NEW_LINE if ( len ( stackOfChar ) >= M ) : NEW_LINE INDENT l = "" NEW_LINE for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( K [ j ] != stackOfChar [ - 1 ] ) : NEW_LINE INDENT f = 0 NEW_LINE while ( f != len ( l ) ) : NEW_LINE INDENT stackOfChar . append ( l [ f ] ) NEW_LINE f += 1 NEW_LINE DEDENT break NEW_LINE DEDENT else : NEW_LINE INDENT l = stackOfChar [ - 1 ] + l NEW_LINE stackOfChar . pop ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( stackOfChar ) NEW_LINE DEDENT
def printSequences ( combinations ) : NEW_LINE INDENT for s in ( combinations ) : NEW_LINE INDENT print ( s , end = ' ' ) NEW_LINE DEDENT DEDENT
def generateCombinations ( s , n ) : NEW_LINE INDENT global combination NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT combination += s [ i ] NEW_LINE x = int ( combination ) NEW_LINE if ( x <= n ) : NEW_LINE INDENT combinations . append ( combination ) NEW_LINE generateCombinations ( s , n ) NEW_LINE DEDENT combination = combination [ : - 1 ] NEW_LINE DEDENT DEDENT
def compute_hash ( str ) : NEW_LINE INDENT p = 31 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE hash_val = 0 NEW_LINE mul = 1 NEW_LINE for ch in str : NEW_LINE INDENT hash_val = ( hash_val + ( ord ( ch ) - ord ( 'a' ) + 1 ) * mul ) % MOD NEW_LINE mul = ( mul * p ) % MOD NEW_LINE DEDENT return hash_val NEW_LINE DEDENT
def distinct_str ( arr , n ) : NEW_LINE INDENT hash = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ i ] = compute_hash ( arr [ i ] ) NEW_LINE DEDENT hash = sorted ( hash ) NEW_LINE cntElem = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( hash [ i ] != hash [ i - 1 ] ) : NEW_LINE INDENT cntElem += 1 NEW_LINE DEDENT DEDENT return cntElem NEW_LINE DEDENT
def isEqualStrings ( arr , N ) : NEW_LINE INDENT M = len ( arr [ 0 ] ) NEW_LINE cntFreq = [ 0 ] * 256 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT cntFreq [ ord ( arr [ i ] [ j ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 256 ) : NEW_LINE INDENT if ( cntFreq [ i ] % N != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def minimumOperations ( s , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] in mp : NEW_LINE INDENT mp [ s [ i ] ] . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT mp [ s [ i ] ] = [ i ] NEW_LINE DEDENT DEDENT ans = INT_MAX NEW_LINE for x in mp : NEW_LINE INDENT curr = 0 NEW_LINE prev = 0 NEW_LINE first = True NEW_LINE for index in mp [ x ] : NEW_LINE INDENT if ( first ) : NEW_LINE INDENT if ( index > 0 ) : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT prev = index NEW_LINE first = False NEW_LINE DEDENT else : NEW_LINE INDENT if ( index != prev + 1 ) : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT prev = index NEW_LINE DEDENT DEDENT if ( prev != n - 1 ) : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT ans = min ( ans , curr ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def PrintStack ( s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT x = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE PrintStack ( s ) NEW_LINE print ( x , end = "" ) NEW_LINE s . append ( x ) NEW_LINE DEDENT
def minString ( s ) : NEW_LINE INDENT Stack = [ ] NEW_LINE Stack . append ( s [ 0 ] ) NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( len ( Stack ) == 0 ) : NEW_LINE INDENT Stack . append ( s [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( Stack [ - 1 ] == s [ i ] ) : NEW_LINE INDENT Stack . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT Stack . append ( s [ i ] ) NEW_LINE DEDENT DEDENT DEDENT PrintStack ( Stack ) NEW_LINE DEDENT
def SieveOfEratosthenes ( prime , n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 0 ] = prime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT j = 2 NEW_LINE while i * j <= n : NEW_LINE INDENT prime [ i * j ] = False NEW_LINE j += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def removePrimeFrequencies ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE prime = [ False ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( prime , n ) NEW_LINE m = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in m : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT new_String = "" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( prime [ m [ s [ i ] ] ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT new_String += s [ i ] NEW_LINE DEDENT print ( new_String , end = "" ) NEW_LINE DEDENT
def minMaxDigits ( str , N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT arr [ i ] = ( ord ( str [ i ] ) - ord ( '0' ) ) % 3 NEW_LINE DEDENT zero = 0 NEW_LINE one = 0 NEW_LINE two = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT two += 1 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = ( sum + arr [ i ] ) % 3 NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT if ( one and N > 1 ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT elif ( two > 1 and N > 2 ) : NEW_LINE INDENT print ( "2" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "-1" , end = " " ) NEW_LINE DEDENT DEDENT if ( sum == 2 ) : NEW_LINE INDENT if ( two and N > 1 ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT elif ( one > 1 and N > 2 ) : NEW_LINE INDENT print ( "2" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "-1" , end = " " ) NEW_LINE DEDENT DEDENT if ( zero > 0 ) : NEW_LINE INDENT print ( N - 1 , end = " " ) NEW_LINE DEDENT elif ( one > 0 and two > 0 ) : NEW_LINE INDENT print ( N - 2 , end = " " ) NEW_LINE DEDENT elif ( one > 2 or two > 2 ) : NEW_LINE INDENT print ( N - 3 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "-1" , end = " " ) NEW_LINE DEDENT DEDENT
def findDisStr ( arr , N ) : NEW_LINE INDENT DistString = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] not in DistString ) : NEW_LINE INDENT DistString . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for string in DistString : NEW_LINE INDENT print ( string , end = " " ) NEW_LINE DEDENT DEDENT
def count_of_accident ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if ( n > m ) : NEW_LINE INDENT return ( m * ( m + 1 ) ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n * ( n + 1 ) ) / 2 + ( m - n ) * n ) NEW_LINE DEDENT DEDENT
def count_of_collision ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE answer = 0 NEW_LINE count_of_truck_in_lane_b = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( b [ i ] == 'T' ) : NEW_LINE INDENT count_of_truck_in_lane_b += 1 NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i < m and i < n ) : NEW_LINE INDENT if ( a [ i ] == 'T' ) : NEW_LINE INDENT answer += count_of_truck_in_lane_b NEW_LINE DEDENT if ( b [ i ] == 'T' ) : NEW_LINE INDENT count_of_truck_in_lane_b -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return answer NEW_LINE DEDENT
def arcIntersection ( S , lenn ) : NEW_LINE INDENT stk = [ ] NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT stk . append ( S [ i ] ) NEW_LINE if ( len ( stk ) >= 2 ) : NEW_LINE INDENT temp = stk [ - 1 ] NEW_LINE del stk [ - 1 ] NEW_LINE if ( stk [ - 1 ] == temp ) : NEW_LINE INDENT del stk [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( temp ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( stk ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def findMinimumChanges ( N , K , S ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( ( K + 1 ) // 2 ) : NEW_LINE INDENT mp = { } NEW_LINE for j in range ( i , N , K ) : NEW_LINE INDENT mp [ S [ j ] ] = mp . get ( S [ j ] , 0 ) + 1 NEW_LINE DEDENT j = N - i - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( ( K & 1 ) and ( i == K // 2 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT mp [ S [ j ] ] = mp . get ( S [ j ] , 0 ) + 1 NEW_LINE j -= K NEW_LINE DEDENT curr_max = - sys . maxsize - 1 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT curr_max = max ( curr_max , value ) NEW_LINE DEDENT if ( ( K & 1 ) and ( i == K // 2 ) ) : NEW_LINE INDENT ans += ( N // K - curr_max ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( N // K * 2 - curr_max ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def checkValidDFA ( s ) : NEW_LINE INDENT initial_state = 0 NEW_LINE final_state = 0 NEW_LINE previous_state = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ( s [ i ] == '0' and previous_state == 0 ) or ( s [ i ] == '1' and previous_state == 3 ) ) : NEW_LINE INDENT final_state = 1 NEW_LINE DEDENT elif ( ( s [ i ] == '0' and previous_state == 3 ) or ( s [ i ] == '1' and previous_state == 0 ) ) : NEW_LINE INDENT final_state = 2 NEW_LINE DEDENT elif ( ( s [ i ] == '0' and previous_state == 1 ) or ( s [ i ] == '1' and previous_state == 2 ) ) : NEW_LINE INDENT final_state = 0 NEW_LINE DEDENT elif ( ( s [ i ] == '0' and previous_state == 2 ) or ( s [ i ] == '1' and previous_state == 1 ) ) : NEW_LINE INDENT final_state = 3 NEW_LINE DEDENT previous_state = final_state NEW_LINE DEDENT if ( final_state == 3 ) : NEW_LINE INDENT print ( "Accepted" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Not Accepted" ) NEW_LINE DEDENT DEDENT
def findFraction ( s ) : NEW_LINE INDENT be_deci = "" NEW_LINE af_deci = "" NEW_LINE reccu = "" NEW_LINE x = True NEW_LINE y = False NEW_LINE z = False NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '.' ) : NEW_LINE INDENT x = False NEW_LINE y = True NEW_LINE continue NEW_LINE DEDENT if ( s [ i ] == '(' ) : NEW_LINE INDENT z = True NEW_LINE y = False NEW_LINE continue NEW_LINE DEDENT if ( x ) : NEW_LINE INDENT be_deci += s [ i ] NEW_LINE DEDENT if ( y ) : NEW_LINE INDENT af_deci += s [ i ] NEW_LINE DEDENT if ( z ) : NEW_LINE INDENT while i < len ( s ) and s [ i ] != ')' : NEW_LINE INDENT reccu += s [ i ] NEW_LINE i += 1 NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT num_be_deci = int ( be_deci ) NEW_LINE num_af_deci = 0 NEW_LINE if len ( af_deci ) != 0 : NEW_LINE INDENT num_af_deci = int ( af_deci ) NEW_LINE DEDENT numr = ( num_be_deci * pow ( 10 , len ( af_deci ) ) + num_af_deci ) NEW_LINE deno = pow ( 10 , len ( af_deci ) ) NEW_LINE if len ( reccu ) == 0 : NEW_LINE INDENT gd = gcd ( numr , deno ) NEW_LINE print ( numr // gd , "/" , deno // gd ) NEW_LINE DEDENT else : NEW_LINE INDENT reccu_num = int ( reccu ) NEW_LINE numr1 = ( numr * pow ( 10 , len ( reccu ) ) + reccu_num ) NEW_LINE deno1 = deno * pow ( 10 , len ( reccu ) ) NEW_LINE res_numr = numr1 - numr NEW_LINE res_deno = deno1 - deno NEW_LINE gd = gcd ( res_numr , res_deno ) NEW_LINE print ( res_numr // gd , " / " , res_deno // gd ) NEW_LINE DEDENT DEDENT
def minCost ( s , n ) : NEW_LINE INDENT minValue = 100000000 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT cnt += min ( abs ( i - ( ord ( s [ j ] ) - ord ( 'a' ) ) ) , 26 - abs ( i - ( ord ( s [ j ] ) - ord ( 'a' ) ) ) ) NEW_LINE DEDENT minValue = min ( minValue , cnt ) NEW_LINE DEDENT return minValue NEW_LINE DEDENT
def longComPre ( arr , N ) : NEW_LINE INDENT freq = [ [ 0 for i in range ( 256 ) ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT M = len ( arr [ i ] ) NEW_LINE for j in range ( M ) : NEW_LINE INDENT freq [ i ] [ ord ( arr [ i ] [ j ] ) ] += 1 NEW_LINE DEDENT DEDENT maxLen = 0 NEW_LINE for j in range ( 256 ) : NEW_LINE INDENT minRowVal = sys . maxsize NEW_LINE for i in range ( N ) : NEW_LINE INDENT minRowVal = min ( minRowVal , freq [ i ] [ j ] ) NEW_LINE DEDENT maxLen += minRowVal NEW_LINE DEDENT return maxLen NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def distinctWays ( str1 , str2 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE m = len ( str2 ) NEW_LINE if ( n == m ) : NEW_LINE INDENT return 2 * fact ( n ) * fact ( m ) NEW_LINE DEDENT return fact ( n ) * fact ( m ) NEW_LINE DEDENT
def printResult ( result ) : NEW_LINE INDENT result = result [ : : - 1 ] NEW_LINE i = 0 NEW_LINE while ( i < len ( result ) ) : NEW_LINE INDENT print ( result [ i ] , end = "" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def sumOfLargeNumbers ( v , k , N ) : NEW_LINE INDENT x = [ [ ] for i in range ( 1000 ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT x [ i ] . append ( ord ( v [ i ] [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT carry = 0 NEW_LINE result = [ ] NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT sum += x [ j ] [ i ] NEW_LINE DEDENT sum += carry NEW_LINE temp = sum NEW_LINE count = 0 NEW_LINE while ( temp > 9 ) : NEW_LINE INDENT temp = temp % 10 NEW_LINE count += 1 NEW_LINE DEDENT l = pow ( 10 , count ) NEW_LINE if ( l != 1 ) : NEW_LINE INDENT carry = sum / l NEW_LINE DEDENT sum = sum % 10 NEW_LINE result . append ( sum ) NEW_LINE DEDENT while ( carry != 0 ) : NEW_LINE INDENT a = carry % 10 NEW_LINE result . append ( a ) NEW_LINE carry = carry // 10 NEW_LINE DEDENT printResult ( result ) NEW_LINE DEDENT
def printRev ( strr ) : NEW_LINE INDENT strr = strr . split ( " " ) NEW_LINE st = [ ] NEW_LINE for i in strr : NEW_LINE INDENT st . append ( i ) NEW_LINE DEDENT while len ( st ) > 0 : NEW_LINE INDENT print ( st [ - 1 ] , end = " " ) NEW_LINE del st [ - 1 ] NEW_LINE DEDENT DEDENT
def printLeaves ( preorder , n ) : NEW_LINE INDENT i = [ 0 ] NEW_LINE INT_MIN , INT_MAX = - 999999999999 , 999999999999 NEW_LINE isLeaf ( preorder , i , n , INT_MIN , INT_MAX ) NEW_LINE DEDENT
def min_cost ( S ) : NEW_LINE INDENT cost = 0 NEW_LINE F = 0 NEW_LINE B = 0 NEW_LINE n = len ( S ) - S . count ( ' ' ) NEW_LINE if n == 1 : NEW_LINE INDENT return cost NEW_LINE DEDENT for char in S : NEW_LINE INDENT if char != ' ' : NEW_LINE INDENT if B != 0 : NEW_LINE INDENT cost += min ( n - F , F ) * B NEW_LINE B = 0 NEW_LINE DEDENT F += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B += 1 NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT
def findPermutations ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for r in range ( 1 , n + 1 ) : NEW_LINE INDENT P = permute ( n , r ) NEW_LINE sum = sum + P NEW_LINE DEDENT return sum NEW_LINE DEDENT
def countOfString ( N ) : NEW_LINE INDENT Stotal = pow ( 2 , N ) NEW_LINE Sequal = 0 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT Sequal = binomialCoeff ( N , N // 2 ) NEW_LINE DEDENT S1 = ( Stotal - Sequal ) // 2 NEW_LINE return S1 NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT a = set ( ) NEW_LINE for i in s : NEW_LINE INDENT if i in a : NEW_LINE INDENT return False NEW_LINE DEDENT a . add ( i ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def binExp ( base , power ) : NEW_LINE INDENT x = 1 NEW_LINE while ( power ) : NEW_LINE INDENT if ( power % 2 == 1 ) : NEW_LINE INDENT x = ( ( ( x % mod ) * ( base % mod ) ) % mod ) NEW_LINE DEDENT base = ( ( ( base % mod ) * ( base % mod ) ) % mod ) NEW_LINE power = power // 2 NEW_LINE DEDENT return x NEW_LINE DEDENT
def fact ( num ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT result = ( ( ( result % mod ) * ( i % mod ) ) % mod ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def calculate_nCi ( N , i ) : NEW_LINE INDENT nfact = fact ( N ) NEW_LINE ifact = fact ( i ) NEW_LINE dfact = fact ( N - i ) NEW_LINE inv_ifact = binExp ( ifact , mod - 2 ) NEW_LINE inv_dfact = binExp ( dfact , mod - 2 ) NEW_LINE denm = ( ( ( inv_ifact % mod ) * ( inv_dfact % mod ) ) % mod ) NEW_LINE answer = ( ( ( nfact % mod ) * ( denm % mod ) ) % mod ) NEW_LINE return answer NEW_LINE DEDENT
def countSubstring ( N , s , k ) : NEW_LINE INDENT allWays = binExp ( 26 , N ) NEW_LINE noWays = 0 NEW_LINE for i in range ( s ) : NEW_LINE INDENT nCi = calculate_nCi ( N , i ) NEW_LINE remaining = binExp ( 25 , N - i ) NEW_LINE multiply = ( ( ( nCi % mod ) * ( remaining % mod ) ) % mod ) NEW_LINE noWays = ( ( ( noWays % mod ) + ( multiply % mod ) ) % mod ) NEW_LINE DEDENT answer = ( ( ( allWays % mod ) - ( noWays % mod ) ) % mod ) NEW_LINE if ( answer < 0 ) : NEW_LINE INDENT answer += mod NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT
def is_rtol ( s ) : NEW_LINE INDENT tmp = floor ( sqrt ( len ( s ) ) ) - 1 NEW_LINE first = s [ tmp ] NEW_LINE for pos in range ( tmp , len ( s ) - 1 , tmp ) : NEW_LINE INDENT if ( s [ pos ] != first ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isSpecial ( c , special ) : NEW_LINE INDENT for i in special : NEW_LINE INDENT if ( i == c ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def countRatio ( s , special ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix [ i ] = int ( isSpecial ( s [ i ] , special ) ) NEW_LINE if ( i > 0 ) : NEW_LINE INDENT prefix [ i ] += prefix [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT sum [ i ] = prefix [ i ] NEW_LINE if ( i > 0 ) : NEW_LINE INDENT sum [ i ] += sum [ i - 1 ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i > 1 : NEW_LINE INDENT count = sum [ n - 1 ] - sum [ i - 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT count = sum [ n - 1 ] NEW_LINE DEDENT if i < n : NEW_LINE INDENT count -= sum [ n - i - 1 ] NEW_LINE DEDENT ans += count / i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isVowel ( ch ) : NEW_LINE INDENT if ( ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def minCost ( S ) : NEW_LINE INDENT cA = 0 NEW_LINE cE = 0 NEW_LINE cI = 0 NEW_LINE cO = 0 NEW_LINE cU = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if ( isVowel ( S [ i ] ) ) : NEW_LINE INDENT cA += abs ( ord ( S [ i ] ) - ord ( 'a' ) ) NEW_LINE cE += abs ( ord ( S [ i ] ) - ord ( 'e' ) ) NEW_LINE cI += abs ( ord ( S [ i ] ) - ord ( 'i' ) ) NEW_LINE cO += abs ( ord ( S [ i ] ) - ord ( 'o' ) ) NEW_LINE cU += abs ( ord ( S [ i ] ) - ord ( 'u' ) ) NEW_LINE DEDENT DEDENT return min ( min ( min ( min ( cA , cE ) , cI ) , cO ) , cU ) NEW_LINE DEDENT
def isPalindrome ( Str ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( Str ) - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( Str [ l ] != Str [ h ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def makeOddString ( Str ) : NEW_LINE INDENT odd = "" NEW_LINE for i in range ( 1 , len ( Str ) , 2 ) : NEW_LINE INDENT odd += Str [ i ] NEW_LINE DEDENT return odd NEW_LINE DEDENT
def makeevenString ( Str ) : NEW_LINE INDENT even = "" NEW_LINE for i in range ( 0 , len ( Str ) , 2 ) : NEW_LINE INDENT even += Str [ i ] NEW_LINE DEDENT return even NEW_LINE DEDENT
def checkevenOddPalindrome ( Str ) : NEW_LINE INDENT odd = makeOddString ( Str ) NEW_LINE even = makeevenString ( Str ) NEW_LINE if ( isPalindrome ( odd ) and isPalindrome ( even ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def inRange ( hh , mm , L , R ) : NEW_LINE INDENT a = abs ( hh - mm ) NEW_LINE if ( a < L or a > R ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def firstNonRepElement ( str ) : NEW_LINE INDENT list . append ( str [ 0 ] ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] in list : NEW_LINE INDENT list . remove ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT list . append ( str [ i ] ) NEW_LINE DEDENT DEDENT print ( list [ 0 ] ) NEW_LINE DEDENT
def makeOddString ( str ) : NEW_LINE INDENT odd = "" NEW_LINE for i in range ( 1 , len ( str ) , 2 ) : NEW_LINE INDENT odd += str [ i ] NEW_LINE DEDENT return odd NEW_LINE DEDENT
def checkOddlyPalindrome ( str ) : NEW_LINE INDENT odd = makeOddString ( str ) NEW_LINE if ( isPalindrome ( odd ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def decrypt ( Str , Start , End ) : NEW_LINE INDENT if ( Start > End ) : NEW_LINE INDENT return NEW_LINE DEDENT mid = ( Start + End ) >> 1 NEW_LINE print ( Str [ mid ] , end = "" ) NEW_LINE decrypt ( Str , mid + 1 , End ) NEW_LINE decrypt ( Str , Start , mid - 1 ) NEW_LINE DEDENT
def isSuffix ( s1 , s2 ) : NEW_LINE INDENT n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE if ( n1 > n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def CheckBinaryEquivalent ( N , s ) : NEW_LINE INDENT B_Number = 0 NEW_LINE cnt = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT rem = N % 2 NEW_LINE c = pow ( 10 , cnt ) NEW_LINE B_Number += rem * c NEW_LINE N //= 2 NEW_LINE cnt += 1 NEW_LINE DEDENT bin = str ( B_Number ) NEW_LINE return isSuffix ( s , bin ) NEW_LINE DEDENT
def decode_String ( st , K ) : NEW_LINE INDENT ans = "" NEW_LINE for i in range ( 0 , len ( st ) , K ) : NEW_LINE INDENT ans += st [ i ] NEW_LINE DEDENT for i in range ( len ( st ) - ( K - 1 ) , len ( st ) ) : NEW_LINE INDENT ans += st [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def check ( str , K ) : NEW_LINE INDENT if ( len ( str ) % K == 0 ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT sum += ord ( str [ i ] ) NEW_LINE DEDENT for j in range ( K , len ( str ) , K ) : NEW_LINE INDENT s_comp = 0 NEW_LINE for p in range ( j , j + K ) : NEW_LINE INDENT s_comp += ord ( str [ p ] ) NEW_LINE DEDENT if ( s_comp != sum ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def check ( s , n ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( st ) != 0 and st [ len ( st ) - 1 ] == s [ i ] ) : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( s [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def isPalindrome ( Str ) : NEW_LINE INDENT Len = len ( Str ) NEW_LINE for i in range ( Len ) : NEW_LINE INDENT if ( Str [ i ] != Str [ Len - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isCompressablePalindrome ( Str ) : NEW_LINE INDENT Len = len ( Str ) NEW_LINE compressed = "" NEW_LINE compressed += Str [ 0 ] NEW_LINE for i in range ( 1 , Len ) : NEW_LINE INDENT if ( Str [ i ] != Str [ i - 1 ] ) : NEW_LINE INDENT compressed += Str [ i ] NEW_LINE DEDENT DEDENT return isPalindrome ( compressed ) NEW_LINE DEDENT
def CountTotal ( s ) : NEW_LINE INDENT ans = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = "" NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE if ( isvalid ( temp ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def isvowel ( ch ) : NEW_LINE INDENT return ( ch in "aeiou" ) NEW_LINE DEDENT
def getTotCount ( num ) : NEW_LINE INDENT totCount = 1 NEW_LINE firstCount = 1 NEW_LINE temp = 1 NEW_LINE while ( not ( num & temp ) ) : NEW_LINE INDENT temp = temp << 1 NEW_LINE totCount += 1 NEW_LINE DEDENT firstCount = totCount NEW_LINE temp = num >> totCount NEW_LINE while ( temp ) : NEW_LINE INDENT totCount += 1 NEW_LINE temp = temp >> 1 NEW_LINE DEDENT return totCount , firstCount NEW_LINE DEDENT
def flipBitsFromRightMostSetBit ( num ) : NEW_LINE INDENT totbit , firstbit = getTotCount ( num ) NEW_LINE num1 = num ^ ( ( 1 << totbit ) - 1 ) NEW_LINE num1 = num1 ^ ( ( 1 << firstbit ) - 1 ) NEW_LINE return num1 NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' ) NEW_LINE DEDENT
def isValid ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return ( isVowel ( s [ 0 ] ) ) NEW_LINE DEDENT if ( isVowel ( s [ 0 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] or not isVowel ( s [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findMaxLen ( s ) : NEW_LINE INDENT maxLen = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = "" NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp = temp + s [ j ] NEW_LINE if ( isValid ( temp ) ) : NEW_LINE INDENT maxLen = ( max ( maxLen , ( j - i + 1 ) ) ) NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
def findMaxLen ( s ) : NEW_LINE INDENT maxLen = 0 NEW_LINE cur = 0 NEW_LINE if ( isVowel ( s [ 0 ] ) ) : NEW_LINE INDENT maxLen = 1 NEW_LINE DEDENT cur = maxLen NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cur += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cur = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT cur = 0 NEW_LINE DEDENT maxLen = max ( cur , maxLen ) NEW_LINE DEDENT return maxLen NEW_LINE DEDENT
def power ( base , pwr ) : NEW_LINE INDENT res = 1 NEW_LINE while ( pwr > 0 ) : NEW_LINE INDENT if ( pwr & 1 ) : NEW_LINE INDENT res = res * base NEW_LINE DEDENT base = base * base NEW_LINE pwr >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countNonPalindromicString ( n , m ) : NEW_LINE INDENT total = power ( n , m ) NEW_LINE palindrome = power ( n , m // 2 + m % 2 ) NEW_LINE count = total - palindrome NEW_LINE return count NEW_LINE DEDENT
def BalancedNumber ( s ) : NEW_LINE INDENT Leftsum = 0 NEW_LINE Rightsum = 0 NEW_LINE for i in range ( 0 , int ( len ( s ) / 2 ) ) : NEW_LINE INDENT Leftsum = Leftsum + int ( s [ i ] ) NEW_LINE Rightsum = ( Rightsum + int ( s [ len ( s ) - 1 - i ] ) ) NEW_LINE DEDENT if ( Leftsum == Rightsum ) : NEW_LINE INDENT print ( "Balanced" , end = '' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Not Balanced" , end = '' ) NEW_LINE DEDENT DEDENT
def expo ( base , exponent ) : NEW_LINE INDENT ans = 1 NEW_LINE while ( exponent != 0 ) : NEW_LINE INDENT if ( ( exponent & 1 ) == 1 ) : NEW_LINE INDENT ans = ans * base NEW_LINE ans = ans % mod NEW_LINE DEDENT base = base * base NEW_LINE base %= mod NEW_LINE exponent >>= 1 NEW_LINE DEDENT return ans % mod NEW_LINE DEDENT
def findCount ( N ) : NEW_LINE INDENT ans = ( ( expo ( 26 , N ) - expo ( 5 , N ) - expo ( 21 , N ) ) % mod ) NEW_LINE ans += mod NEW_LINE ans %= mod NEW_LINE return ans NEW_LINE DEDENT
def countPalindromePermutation ( s , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE if ( checkPalindrome ( ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT i = 0 NEW_LINE j = k NEW_LINE while ( j < len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 97 ] -= 1 NEW_LINE i += 1 NEW_LINE freq [ ord ( s [ j ] ) - 97 ] += 1 NEW_LINE j += 1 NEW_LINE if ( checkPalindrome ( ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minFlips ( target ) : NEW_LINE INDENT curr = '1' NEW_LINE count = 0 NEW_LINE for i in range ( len ( target ) ) : NEW_LINE INDENT if ( target [ i ] == curr ) : NEW_LINE INDENT count += 1 NEW_LINE curr = chr ( 48 + ( ord ( curr ) + 1 ) % 2 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def decompose ( S ) : NEW_LINE INDENT s = [ ] NEW_LINE N = len ( S ) NEW_LINE ans = 0 NEW_LINE nix = sys . maxsize NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT s . append ( S [ i ] ) NEW_LINE nix = S [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( S [ i ] < s [ - 1 ] ) : NEW_LINE INDENT s . append ( S [ i ] ) NEW_LINE nix = min ( nix , S [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT val = S [ i ] NEW_LINE while ( len ( s ) != 0 and val >= s [ - 1 ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT nix = min ( nix , S [ i ] ) NEW_LINE s . append ( nix ) NEW_LINE DEDENT DEDENT ans += len ( s ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxSetBitCount ( s , k ) : NEW_LINE INDENT maxCount = 0 NEW_LINE n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT maxCount = count NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if ( s [ i - k ] == '1' ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT maxCount = max ( maxCount , count ) NEW_LINE DEDENT return maxCount NEW_LINE DEDENT
def maxVowelSubString ( str1 , K ) : NEW_LINE INDENT N = len ( str1 ) NEW_LINE pref = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( str1 [ i ] == 'a' or str1 [ i ] == 'e' or str1 [ i ] == 'i' or str1 [ i ] == 'o' or str1 [ i ] == 'u' ) : NEW_LINE INDENT pref [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT pref [ i ] = 0 NEW_LINE DEDENT if ( i ) : NEW_LINE INDENT pref [ i ] += pref [ i - 1 ] NEW_LINE DEDENT DEDENT maxCount = pref [ K - 1 ] NEW_LINE res = str1 [ 0 : K ] NEW_LINE for i in range ( K , N ) : NEW_LINE INDENT currCount = pref [ i ] - pref [ i - K ] NEW_LINE if ( currCount > maxCount ) : NEW_LINE INDENT maxCount = currCount NEW_LINE res = str1 [ i - K + 1 : i + 1 ] NEW_LINE DEDENT elif ( currCount == maxCount ) : NEW_LINE INDENT temp = str1 [ i - K + 1 : i + 1 ] NEW_LINE if ( temp < res ) : NEW_LINE INDENT res = temp NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def miniOperToMakeAllEleEqual ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % n ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT valueAfterDivision = sum // n NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( abs ( valueAfterDivision - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT count += abs ( valueAfterDivision - arr [ i ] ) // k NEW_LINE DEDENT print ( count // 2 ) NEW_LINE DEDENT
def minOperations ( a ) : NEW_LINE INDENT res = 100000000000 NEW_LINE N = len ( a ) NEW_LINE for r in range ( 0 , 2 ) : NEW_LINE INDENT sum = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE if ( ( i + r ) % 2 ) : NEW_LINE INDENT if ( sum <= 0 ) : NEW_LINE INDENT ans += - sum + 1 NEW_LINE sum = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( sum >= 0 ) : NEW_LINE INDENT ans += sum + 1 NEW_LINE sum = - 1 NEW_LINE DEDENT DEDENT DEDENT res = min ( res , ans ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def checkWord ( board , word , index , row , col ) : NEW_LINE INDENT if ( row < 0 or col < 0 or row >= len ( board ) or col >= len ( board [ 0 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( board [ row ] [ col ] != word [ index ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( index == len ( word ) - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = board [ row ] [ col ] NEW_LINE board [ row ] [ col ] = '*' NEW_LINE if ( checkWord ( board , word , index + 1 , row + 1 , col ) or checkWord ( board , word , index + 1 , row - 1 , col ) or checkWord ( board , word , index + 1 , row , col + 1 ) or checkWord ( board , word , index + 1 , row , col - 1 ) ) : NEW_LINE INDENT board [ row ] [ col ] = temp NEW_LINE return True NEW_LINE DEDENT board [ row ] [ col ] = temp NEW_LINE return False NEW_LINE DEDENT
def count ( N , X , subStr , index , n ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = subStr + N [ index ] NEW_LINE b = 0 NEW_LINE if ( int ( a ) % X == 0 ) : NEW_LINE INDENT b = 1 NEW_LINE DEDENT m1 = count ( N , X , a , index + 1 , n ) NEW_LINE m2 = b + count ( N , X , "" , index + 1 , n ) NEW_LINE return max ( m1 , m2 ) NEW_LINE DEDENT
def checkSuffix ( A , B ) : NEW_LINE INDENT s1 = str ( A ) NEW_LINE s2 = str ( B ) NEW_LINE n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE if ( n1 < n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def checkSuffix ( A , B ) : NEW_LINE INDENT s1 = str ( A ) NEW_LINE s2 = str ( B ) NEW_LINE result = s1 . endswith ( s2 ) NEW_LINE if ( result ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def checkSuffix ( A , B ) : NEW_LINE INDENT digit_B = int ( math . log10 ( B ) ) + 1 NEW_LINE A -= B NEW_LINE return ( A % int ( math . pow ( 10 , digit_B ) ) ) NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT ok = True NEW_LINE for i in range ( 0 , len ( s ) - 1 , 1 ) : NEW_LINE INDENT ok = ( ok & ( abs ( ord ( s [ i ] ) - ord ( s [ i + 1 ] ) ) != 1 ) ) NEW_LINE DEDENT return ok NEW_LINE DEDENT
def findMinLength ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE counts = defaultdict ( int ) NEW_LINE indices = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == 'a' or s [ i ] == 'e' or s [ i ] == 'o' or s [ i ] == 'i' or s [ i ] == 'u' ) : NEW_LINE INDENT counts [ s [ i ] ] += 1 NEW_LINE indices . append ( i ) NEW_LINE DEDENT DEDENT if len ( counts ) < 5 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT flag1 = 0 NEW_LINE flag2 = 0 NEW_LINE i = 0 NEW_LINE j = len ( indices ) - 1 NEW_LINE while ( j - i ) >= 4 : NEW_LINE INDENT if ( ~ flag1 and counts [ s [ indices [ i ] ] ] > 1 ) : NEW_LINE INDENT counts [ s [ indices [ i ] ] ] -= 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT flag1 = 1 NEW_LINE DEDENT if ( ~ flag2 and counts [ s [ indices [ j ] ] ] > 1 ) : NEW_LINE INDENT counts [ s [ indices [ j ] ] ] -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT flag2 = 1 NEW_LINE DEDENT if ( flag1 and flag2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ( indices [ j ] - indices [ i ] + 1 ) NEW_LINE DEDENT
def get_index ( ch ) : NEW_LINE INDENT if ( ch == 'a' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ch == 'e' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( ch == 'i' ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif ( ch == 'o' ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT elif ( ch == 'u' ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def findMinLength ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = n + 1 NEW_LINE start = 0 NEW_LINE count = [ 0 ] * 5 NEW_LINE for x in range ( n ) : NEW_LINE INDENT idx = get_index ( s [ x ] ) NEW_LINE if ( idx != - 1 ) : NEW_LINE INDENT count [ idx ] += 1 NEW_LINE DEDENT idx_start = get_index ( s [ start ] ) NEW_LINE while ( idx_start == - 1 or count [ idx_start ] > 1 ) : NEW_LINE INDENT if ( idx_start != - 1 ) : NEW_LINE INDENT count [ idx_start ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE if ( start < n ) : NEW_LINE INDENT idx_start = get_index ( s [ start ] ) NEW_LINE DEDENT DEDENT if ( count [ 0 ] > 0 and count [ 1 ] > 0 and count [ 2 ] > 0 and count [ 3 ] > 0 and count [ 4 ] > 0 ) : NEW_LINE INDENT ans = min ( ans , x - start + 1 ) NEW_LINE DEDENT DEDENT if ( ans == n + 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def count_min_length ( s ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT hash [ i ] = - 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( 'a' ) ] == - 1 ) : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( 'a' ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( 'a' ) ] == i - 1 or hash [ ord ( s [ i ] ) - ord ( 'a' ) ] == i - 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = min ( ans , i - hash [ ord ( s [ i ] ) - ord ( 'a' ) ] - 1 ) NEW_LINE hash [ ord ( s [ i ] ) - ord ( 'a' ) ] = i NEW_LINE DEDENT DEDENT if ( ans == INT_MAX ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countStrings ( s ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def RemoveHTMLTags ( strr ) : NEW_LINE INDENT print ( re . compile ( r '<[^>]+>' ) . sub ( '' , strr ) ) NEW_LINE DEDENT
def checkValidString ( str ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT if ( freq [ i ] != i + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def checkSemiprime ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 2 NEW_LINE while cnt < 2 and i * i <= num : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT num //= i NEW_LINE cnt += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt == 2 NEW_LINE DEDENT
def makeCypherString ( N ) : NEW_LINE INDENT semiPrime = "" NEW_LINE sumOfPrime = "" NEW_LINE st = str ( N ) NEW_LINE if ( checkSemiprime ( N ) ) : NEW_LINE INDENT for i in range ( len ( st ) ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT semiPrime += st [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT semiPrime += chr ( ord ( st [ i ] ) - ord ( '0' ) + 65 ) NEW_LINE DEDENT DEDENT DEDENT if ( isPossibleSum ( N ) ) : NEW_LINE INDENT for i in range ( len ( st ) ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT sumOfPrime += chr ( ord ( st [ i ] ) - ord ( '0' ) + 65 ) NEW_LINE DEDENT else : NEW_LINE INDENT sumOfPrime += st [ i ] NEW_LINE DEDENT DEDENT DEDENT if ( semiPrime + sumOfPrime == "" ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( semiPrime + sumOfPrime ) NEW_LINE DEDENT DEDENT
def modulo_by_26 ( num ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT res = ( ( res * 10 + ord ( num [ i ] ) - ord ( '0' ) ) % MOD ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def longestConsonantsSubsequence ( s ) : NEW_LINE INDENT answer = '' NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if isComsomamts ( s [ i ] ) : NEW_LINE INDENT answer += s [ i ] NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def generateTheString ( n ) : NEW_LINE INDENT ans = "" NEW_LINE if ( n % 2 ) : NEW_LINE INDENT for i in range ( min ( n , 24 ) ) : NEW_LINE INDENT ans += chr ( ord ( 'b' ) + i ) NEW_LINE DEDENT if ( n > 24 ) : NEW_LINE INDENT for i in range ( ( n - 24 ) ) : NEW_LINE INDENT ans += 'a' NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( min ( n , 25 ) ) : NEW_LINE INDENT ans += chr ( ord ( 'b' ) + i ) NEW_LINE DEDENT if ( n > 25 ) : NEW_LINE INDENT for i in range ( ( n - 25 ) ) : NEW_LINE INDENT ans += 'a' NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def finalCoordinates ( SX , SY , D ) : NEW_LINE INDENT for i in range ( len ( D ) ) : NEW_LINE INDENT if ( D [ i ] == 'N' ) : NEW_LINE INDENT SY += 1 NEW_LINE DEDENT elif ( D [ i ] == 'S' ) : NEW_LINE INDENT SY -= 1 NEW_LINE DEDENT elif ( D [ i ] == 'E' ) : NEW_LINE INDENT SX += 1 NEW_LINE DEDENT else : NEW_LINE INDENT SX -= 1 NEW_LINE DEDENT DEDENT ans = '(' + str ( SX ) + ',' + str ( SY ) + ')' NEW_LINE print ( ans ) NEW_LINE DEDENT
def shortestPalindrome ( s ) : NEW_LINE INDENT abcd = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT abcd [ ord ( s [ i ] ) - 97 ] = 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if abcd [ i ] == 1 : NEW_LINE INDENT print ( chr ( i + 97 ) , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT
def contain ( L , U , M ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( L , U + 1 ) : NEW_LINE INDENT num = set ( str ( j ) ) NEW_LINE if ( j % M == 0 and str ( M ) not in num ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def MaxLength ( v , i , m ) : NEW_LINE INDENT global max1 NEW_LINE if ( i >= m ) : NEW_LINE INDENT return m - 1 NEW_LINE DEDENT for k in range ( 26 ) : NEW_LINE INDENT c = chr ( ord ( 'a' ) + k ) NEW_LINE v1 = [ ] NEW_LINE for j in range ( len ( v ) ) : NEW_LINE INDENT if ( v [ j ] [ i ] == c ) : NEW_LINE INDENT v1 . append ( v [ j ] ) NEW_LINE DEDENT DEDENT if ( len ( v1 ) >= 2 ) : NEW_LINE INDENT max1 = max ( max1 , MaxLength ( v1 , i + 1 , m ) ) NEW_LINE DEDENT else : NEW_LINE INDENT max1 = max ( max1 , i - 1 ) NEW_LINE DEDENT DEDENT return max1 NEW_LINE DEDENT
def group_formed ( S ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( len ( S ) - 1 ) : NEW_LINE INDENT a = S [ i ] NEW_LINE b = S [ i + 1 ] NEW_LINE if ( a != b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def value ( x ) : NEW_LINE INDENT return ( ord ( x ) - ord ( 'a' ) ) NEW_LINE DEDENT
def finalString ( st ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE n = len ( st ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT y += 1 NEW_LINE DEDENT DEDENT if ( x > y ) : NEW_LINE INDENT left = 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = 0 NEW_LINE DEDENT length = n - 2 * min ( x , y ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT print ( left , end = "" ) NEW_LINE DEDENT DEDENT
def noOfDeletions ( string , k ) : NEW_LINE INDENT ans = 0 NEW_LINE cnt = 0 NEW_LINE pos = 0 NEW_LINE while ( pos < len ( string ) and string [ pos ] != k ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT i = pos NEW_LINE while ( i < len ( string ) ) : NEW_LINE INDENT while ( i < len ( string ) and string [ i ] == k ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT ans = ans + cnt NEW_LINE cnt = 0 NEW_LINE while ( i < len ( string ) and string [ i ] != k ) : NEW_LINE INDENT i = i + 1 NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def GetDigitalRoot ( str1 ) : NEW_LINE INDENT if ( len ( str1 ) == 1 ) : NEW_LINE INDENT return ord ( str1 [ 0 ] ) - ord ( '0' ) NEW_LINE DEDENT str1 = GetIndividulaDigitSum ( str1 , len ( str1 ) ) NEW_LINE return GetDigitalRoot ( str1 ) NEW_LINE DEDENT
def val ( c ) : NEW_LINE INDENT if ( c >= '0' and c <= '9' ) : NEW_LINE INDENT return int ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT return c - 'A' + 10 NEW_LINE DEDENT DEDENT
def toDeci ( strr , base ) : NEW_LINE INDENT lenn = len ( strr ) NEW_LINE power = 1 NEW_LINE num = 0 NEW_LINE for i in range ( lenn - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( val ( strr [ i ] ) >= base ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT num += val ( strr [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT
def repeatingString ( s , n , k ) : NEW_LINE INDENT if ( n % k != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT frequency = [ 0 for i in range ( 123 ) ] NEW_LINE for i in range ( 123 ) : NEW_LINE INDENT frequency [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT frequency [ s [ i ] ] += 1 NEW_LINE DEDENT repeat = n // k NEW_LINE for i in range ( 123 ) : NEW_LINE INDENT if ( frequency [ i ] % repeat != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def longestPalindromic ( strn , i , j , count ) : NEW_LINE INDENT if i > j : NEW_LINE INDENT return count NEW_LINE DEDENT if i == j : NEW_LINE INDENT return ( count + 1 ) NEW_LINE DEDENT if strn [ i ] == strn [ j ] : NEW_LINE INDENT count = longestPalindromic ( strn , i + 1 , j - 1 , count + 2 ) NEW_LINE return maxi ( count , maxi ( longestPalindromic ( strn , i + 1 , j , 0 ) , longestPalindromic ( strn , i , j - 1 , 0 ) ) ) NEW_LINE DEDENT return maxi ( longestPalindromic ( strn , i + 1 , j , 0 ) , longestPalindromic ( strn , i , j - 1 , 0 ) ) NEW_LINE DEDENT
def longest_palindromic_substr ( strn ) : NEW_LINE INDENT k = len ( strn ) - 1 NEW_LINE return longestPalindromic ( strn , 0 , k , 0 ) NEW_LINE DEDENT
def removeOddFrequencyCharacters ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in s : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT new_s = "" NEW_LINE for i in s : NEW_LINE INDENT if ( m [ i ] & 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT new_s += i NEW_LINE DEDENT return new_s NEW_LINE DEDENT
def LexicoLesserStrings ( s ) : NEW_LINE INDENT count = 0 NEW_LINE length = len ( s ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT count += ( ( ord ( s [ i ] ) - ord ( 'a' ) ) * pow ( 26 , length - i - 1 ) ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def countString ( S1 , S2 ) : NEW_LINE INDENT countS1 = LexicoLesserStrings ( S1 ) NEW_LINE countS2 = LexicoLesserStrings ( S2 ) NEW_LINE totalString = countS2 - countS1 - 1 NEW_LINE return ( 0 if totalString < 0 else totalString ) NEW_LINE DEDENT
def isVowel ( x ) : NEW_LINE INDENT return ( x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' ) NEW_LINE DEDENT
def MaxPrefix ( string ) : NEW_LINE INDENT Dict = { } NEW_LINE maxprefix = 0 NEW_LINE for i in string : NEW_LINE INDENT Dict [ i ] = Dict . get ( i , 0 ) + 1 NEW_LINE DEDENT minfrequency = min ( Dict . values ( ) ) NEW_LINE countminFrequency = 0 NEW_LINE for x in Dict : NEW_LINE INDENT if ( Dict [ x ] == minfrequency ) : NEW_LINE INDENT countminFrequency += 1 NEW_LINE DEDENT DEDENT mapper = { } NEW_LINE indi = 0 NEW_LINE for i in string : NEW_LINE INDENT mapper [ i ] = mapper . get ( i , 0 ) + 1 NEW_LINE if ( mapper [ i ] > countminFrequency ) : NEW_LINE INDENT break NEW_LINE DEDENT indi += 1 NEW_LINE DEDENT print ( string [ : indi ] ) NEW_LINE DEDENT
def countSubstr ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE l = n - 1 NEW_LINE r = n - 1 NEW_LINE arr = [ 0 ] * n NEW_LINE last_indexof1 = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT arr [ i ] = i NEW_LINE last_indexof1 = i NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = last_indexof1 NEW_LINE DEDENT DEDENT no_of_substr = 0 NEW_LINE for r in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT l = r NEW_LINE while ( l >= 0 and ( r - l + 1 ) <= 64 and int ( s [ l : r + 1 ] , 2 ) < k ) : NEW_LINE INDENT l -= 1 NEW_LINE DEDENT if ( r - l + 1 <= 64 ) : NEW_LINE INDENT no_of_substr += l + 1 NEW_LINE DEDENT else : NEW_LINE INDENT no_of_substr += arr [ l + 1 ] + 1 NEW_LINE DEDENT DEDENT return no_of_substr NEW_LINE DEDENT
def isPerfectCubeString ( str1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT sum += ord ( str1 [ i ] ) NEW_LINE DEDENT cr = ceil ( ( sum ) ** ( 1 / 3 ) ) NEW_LINE return ( cr * cr * cr == sum ) NEW_LINE DEDENT
def XorAscii ( str1 , len1 ) : NEW_LINE INDENT ans = ord ( str1 [ 0 ] ) NEW_LINE for i in range ( 1 , len1 ) : NEW_LINE INDENT ans = ( ans ^ ( ord ( str1 [ i ] ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countSticks ( string ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if ( ch >= 'A' and ch <= 'Z' ) : NEW_LINE INDENT cnt += sticks [ ord ( ch ) - ord ( 'A' ) ] NEW_LINE DEDENT else : NEW_LINE INDENT cnt += number [ ord ( ch ) - ord ( '0' ) ] NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def count ( str1 , str2 ) : NEW_LINE INDENT c = 0 NEW_LINE j = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if str1 [ i ] in str2 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print ( "No. of matching characters are: " , c ) NEW_LINE DEDENT
def checkIfStartsWithCapital ( string ) : NEW_LINE INDENT if ( string [ 0 ] >= 'A' and string [ 0 ] <= 'Z' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def checkIfAllVowels ( string ) : NEW_LINE INDENT hash = [ 0 ] * 5 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == 'A' or string [ i ] == 'a' ) : NEW_LINE INDENT hash [ 0 ] = 1 NEW_LINE DEDENT elif ( string [ i ] == 'E' or string [ i ] == 'e' ) : NEW_LINE INDENT hash [ 1 ] = 1 NEW_LINE DEDENT elif ( string [ i ] == 'I' or string [ i ] == 'i' ) : NEW_LINE INDENT hash [ 2 ] = 1 NEW_LINE DEDENT elif ( string [ i ] == 'O' or string [ i ] == 'o' ) : NEW_LINE INDENT hash [ 3 ] = 1 NEW_LINE DEDENT elif ( string [ i ] == 'U' or string [ i ] == 'u' ) : NEW_LINE INDENT hash [ 4 ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 5 ) : NEW_LINE INDENT if ( hash [ i ] == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def countOfLetters ( string ) : NEW_LINE INDENT letter = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( ( string [ i ] >= 'A' and string [ i ] <= 'Z' ) or ( string [ i ] >= 'a' and string [ i ] <= 'z' ) ) : NEW_LINE INDENT letter += 1 NEW_LINE DEDENT DEDENT return letter NEW_LINE DEDENT
def countOfNumbers ( string ) : NEW_LINE INDENT number = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] >= '0' and string [ i ] <= '9' ) : NEW_LINE INDENT number += 1 NEW_LINE DEDENT DEDENT return number NEW_LINE DEDENT
def findNthOccur ( string , ch , N ) : NEW_LINE INDENT occur = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ch ) : NEW_LINE INDENT occur += 1 NEW_LINE DEDENT if ( occur == N ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countSmaller ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE arr = [ 0 ] * 26 NEW_LINE ans = [ 0 ] * n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT arr [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE ct = 0 NEW_LINE for j in range ( ord ( str [ i ] ) - ord ( 'a' ) ) : NEW_LINE INDENT ct += arr [ j ] NEW_LINE DEDENT ans [ i ] = ct NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def printValue ( digit ) : NEW_LINE INDENT if digit == '0' : NEW_LINE INDENT print ( "Zero " , end = " " ) NEW_LINE DEDENT elif digit == '1' : NEW_LINE INDENT print ( "One " , end = " " ) NEW_LINE DEDENT elif digit == '2' : NEW_LINE INDENT print ( "Two " , end = " " ) NEW_LINE DEDENT elif digit == '3' : NEW_LINE INDENT print ( "Three" , end = " " ) NEW_LINE DEDENT elif digit == '4' : NEW_LINE INDENT print ( "Four " , end = " " ) NEW_LINE DEDENT elif digit == '5' : NEW_LINE INDENT print ( "Five " , end = " " ) NEW_LINE DEDENT elif digit == '6' : NEW_LINE INDENT print ( "Six " , end = " " ) NEW_LINE DEDENT elif digit == '7' : NEW_LINE INDENT print ( "Seven" , end = " " ) NEW_LINE DEDENT elif digit == '8' : NEW_LINE INDENT print ( "Eight" , end = " " ) NEW_LINE DEDENT elif digit == '9' : NEW_LINE INDENT print ( "Nine " , end = " " ) NEW_LINE DEDENT DEDENT
def printWord ( N ) : NEW_LINE INDENT i = 0 NEW_LINE length = len ( N ) NEW_LINE while i < length : NEW_LINE INDENT printValue ( N [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) NEW_LINE sol = 0 NEW_LINE count [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + abs ( ord ( X [ i - 1 ] ) - ord ( Y [ i - 1 ] ) ) ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( ( count [ i ] - count [ j ] ) > K ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT sol = max ( sol , i - j ) NEW_LINE DEDENT return sol NEW_LINE DEDENT
def find ( x ) : NEW_LINE INDENT if ( x != parent [ x ] ) : NEW_LINE INDENT parent [ x ] = find ( parent [ x ] ) NEW_LINE return parent [ x ] NEW_LINE DEDENT return x NEW_LINE DEDENT
def join ( x , y ) : NEW_LINE INDENT px = find ( x ) NEW_LINE pz = find ( y ) NEW_LINE if ( px != pz ) : NEW_LINE INDENT parent [ pz ] = px NEW_LINE DEDENT DEDENT
def convertible ( s1 , s2 ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] in mp ) : NEW_LINE INDENT mp [ s1 [ i ] ] = s2 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT if s1 [ i ] in mp and mp [ s1 [ i ] ] != s2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT for it in mp : NEW_LINE INDENT if ( it == mp [ it ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( find ( ord ( it ) ) == find ( ord ( it ) ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT join ( ord ( it ) , ord ( it ) ) NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def initialize ( ) : NEW_LINE INDENT for i in range ( 256 ) : NEW_LINE INDENT parent [ i ] = i NEW_LINE DEDENT DEDENT
def jaro_distance ( s1 , s2 ) : NEW_LINE INDENT if ( s1 == s2 ) : NEW_LINE INDENT return 1.0 NEW_LINE DEDENT len1 = len ( s1 ) NEW_LINE len2 = len ( s2 ) NEW_LINE max_dist = floor ( max ( len1 , len2 ) / 2 ) - 1 NEW_LINE match = 0 NEW_LINE hash_s1 = [ 0 ] * len ( s1 ) NEW_LINE hash_s2 = [ 0 ] * len ( s2 ) NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT for j in range ( max ( 0 , i - max_dist ) , min ( len2 , i + max_dist + 1 ) ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ j ] and hash_s2 [ j ] == 0 ) : NEW_LINE INDENT hash_s1 [ i ] = 1 NEW_LINE hash_s2 [ j ] = 1 NEW_LINE match += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( match == 0 ) : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT t = 0 NEW_LINE point = 0 NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT if ( hash_s1 [ i ] ) : NEW_LINE INDENT while ( hash_s2 [ point ] == 0 ) : NEW_LINE INDENT point += 1 NEW_LINE DEDENT if ( s1 [ i ] != s2 [ point ] ) : NEW_LINE INDENT point += 1 NEW_LINE t += 1 NEW_LINE DEDENT DEDENT DEDENT t = t // 2 NEW_LINE return ( match / len1 + match / len2 + ( match - t + 1 ) / match ) / 3.0 NEW_LINE DEDENT
def jaro_distance ( s1 , s2 ) : NEW_LINE INDENT if ( s1 == s2 ) : NEW_LINE INDENT return 1.0 NEW_LINE DEDENT len1 = len ( s1 ) NEW_LINE len2 = len ( s2 ) NEW_LINE if ( len1 == 0 or len2 == 0 ) : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT max_dist = ( max ( len ( s1 ) , len ( s2 ) ) // 2 ) - 1 NEW_LINE match = 0 NEW_LINE hash_s1 = [ 0 ] * len ( s1 ) NEW_LINE hash_s2 = [ 0 ] * len ( s2 ) NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT for j in range ( max ( 0 , i - max_dist ) , min ( len2 , i + max_dist + 1 ) ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ j ] and hash_s2 [ j ] == 0 ) : NEW_LINE INDENT hash_s1 [ i ] = 1 NEW_LINE hash_s2 [ j ] = 1 NEW_LINE match += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( match == 0 ) : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT t = 0 NEW_LINE point = 0 NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT if ( hash_s1 [ i ] ) : NEW_LINE INDENT while ( hash_s2 [ point ] == 0 ) : NEW_LINE INDENT point += 1 NEW_LINE DEDENT if ( s1 [ i ] != s2 [ point ] ) : NEW_LINE INDENT point += 1 NEW_LINE t += 1 NEW_LINE DEDENT else : NEW_LINE INDENT point += 1 NEW_LINE DEDENT DEDENT t /= 2 NEW_LINE DEDENT return ( ( match / len1 + match / len2 + ( match - t ) / match ) / 3.0 ) NEW_LINE DEDENT
def jaro_Winkler ( s1 , s2 ) : NEW_LINE INDENT jaro_dist = jaro_distance ( s1 , s2 ) NEW_LINE if ( jaro_dist > 0.7 ) : NEW_LINE INDENT prefix = 0 NEW_LINE for i in range ( min ( len ( s1 ) , len ( s2 ) ) ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT prefix += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT prefix = min ( 4 , prefix ) NEW_LINE jaro_dist += 0.1 * prefix * ( 1 - jaro_dist ) NEW_LINE DEDENT return jaro_dist NEW_LINE DEDENT
def isWordPresent ( sentence , word ) : NEW_LINE INDENT s = sentence . split ( " " ) NEW_LINE for i in s : NEW_LINE INDENT if ( i == word ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def canMake ( s ) : NEW_LINE INDENT o = 0 NEW_LINE z = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) == 1 ) : NEW_LINE INDENT o += 1 NEW_LINE DEDENT else : NEW_LINE INDENT z += 1 NEW_LINE DEDENT DEDENT if ( o % 2 == 1 and z % 2 == 1 ) : NEW_LINE INDENT return "NO" NEW_LINE DEDENT else : NEW_LINE INDENT return "YES" NEW_LINE DEDENT DEDENT
def countChars ( string , n ) : NEW_LINE INDENT i = 0 NEW_LINE cnt = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 2 NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def findMinSwaps ( s , k ) : NEW_LINE INDENT ans = 0 NEW_LINE c_one = 0 NEW_LINE c_zero = 0 NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT c_one += 1 NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c_zero += 1 NEW_LINE ans += c_one NEW_LINE DEDENT if ( c_zero == k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( c_zero < k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def checkvowel ( ch ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE if ( ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n // 2 NEW_LINE DEDENT DEDENT
def concat ( m , n ) : NEW_LINE INDENT k = int ( math . log2 ( m ) ) + 1 NEW_LINE l = int ( math . log2 ( n ) ) + 1 NEW_LINE a = [ 0 for i in range ( 0 , k ) ] NEW_LINE b = [ 0 for i in range ( 0 , l ) ] NEW_LINE c = [ 0 for i in range ( 0 , k + l ) ] NEW_LINE decBinary ( a , m ) NEW_LINE decBinary ( b , n ) NEW_LINE iin = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT c [ iin ] = a [ i ] NEW_LINE iin = iin + 1 NEW_LINE DEDENT for i in range ( 0 , l ) : NEW_LINE INDENT c [ iin ] = b [ i ] NEW_LINE iin = iin + 1 NEW_LINE DEDENT return ( binaryDec ( c , k + l ) ) NEW_LINE DEDENT
def getBinaryLength ( n ) : NEW_LINE INDENT length = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT length += 1 NEW_LINE n //= 2 NEW_LINE DEDENT return length NEW_LINE DEDENT
def concat ( m , n ) : NEW_LINE INDENT length = getBinaryLength ( n ) NEW_LINE return ( m << length ) + n NEW_LINE DEDENT
def countSubStr ( strr , lenn ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] == '0' ) : NEW_LINE INDENT ans += ( i + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def largestSubStr ( s ) : NEW_LINE INDENT while ( len ( s ) and s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT s = s [ : len ( s ) - 1 ] NEW_LINE DEDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return "-1" NEW_LINE DEDENT else : NEW_LINE INDENT return s NEW_LINE DEDENT DEDENT
def areEqual ( a , b ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def reverseParentheses ( strr , lenn ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] == '(' ) : NEW_LINE INDENT st . append ( i ) NEW_LINE DEDENT elif ( strr [ i ] == ')' ) : NEW_LINE INDENT temp = strr [ st [ - 1 ] : i + 1 ] NEW_LINE strr = strr [ : st [ - 1 ] ] + temp [ : : - 1 ] + strr [ i + 1 : ] NEW_LINE del st [ - 1 ] NEW_LINE DEDENT DEDENT res = "" NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] != ')' and strr [ i ] != '(' ) : NEW_LINE INDENT res += ( strr [ i ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def maxCount ( strr , patt ) : NEW_LINE INDENT strrFreq = [ 0 for i in range ( MAX ) ] NEW_LINE updateFreq ( strr , strrFreq ) NEW_LINE pattFreq = [ 0 for i in range ( MAX ) ] NEW_LINE updateFreq ( patt , pattFreq ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( pattFreq [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT ans = min ( ans , strrFreq [ i ] // pattFreq [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minNum ( str , len1 ) : NEW_LINE INDENT res = sys . maxsize NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT if ( str [ i ] == '4' or str [ i ] == '8' ) : NEW_LINE INDENT res = min ( res , ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT for i in range ( len1 - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , len1 , 1 ) : NEW_LINE INDENT num = ( ord ( str [ i ] ) - ord ( '0' ) ) * TEN + ( ord ( str [ j ] ) - ord ( '0' ) ) NEW_LINE if ( num % 4 == 0 ) : NEW_LINE INDENT res = min ( res , num ) NEW_LINE DEDENT DEDENT DEDENT if ( res == sys . maxsize ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT
def minOperation ( str , len ) : NEW_LINE INDENT first , last = [ 0 ] * MAX , [ 0 ] * MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT first [ i ] = - 1 NEW_LINE last [ i ] = - 1 NEW_LINE DEDENT for i in range ( len ) : NEW_LINE INDENT index = ( ord ( str [ i ] ) - ord ( 'a' ) ) NEW_LINE if ( first [ index ] == - 1 ) : NEW_LINE INDENT first [ index ] = i NEW_LINE DEDENT last [ index ] = i NEW_LINE DEDENT minOp = - 1 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( first [ i ] == - 1 or first [ i ] == last [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = len - ( last [ i ] - first [ i ] + 1 ) NEW_LINE if ( minOp == - 1 or cnt < minOp ) : NEW_LINE INDENT minOp = cnt NEW_LINE DEDENT DEDENT return minOp NEW_LINE DEDENT
def findMidAlphabet ( s1 , s2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT mid = ( ord ( s1 [ i ] ) + ord ( s2 [ i ] ) ) // 2 NEW_LINE print ( chr ( mid ) , end = "" ) NEW_LINE DEDENT DEDENT
def countVowels ( string , l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def sumDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE sum += digit NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isDivBySix ( string , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( ord ( string [ i ] ) - ord ( 'a' ) + 1 ) NEW_LINE DEDENT if ( sum % 3 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT lastDigit = ( ord ( string [ n - 1 ] ) - ord ( 'a' ) + 1 ) % 10 NEW_LINE if ( lastDigit % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def minLength ( string , l ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT s . append ( string [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ - 1 ] NEW_LINE if ( c != string [ i ] and c . upper ( ) == string [ i ] . upper ( ) ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( string [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return len ( s ) NEW_LINE DEDENT
def cntSplits ( s ) : NEW_LINE INDENT if ( s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT c_zero = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT c_zero += ( s [ i ] == '0' ) NEW_LINE DEDENT return int ( pow ( 2 , c_zero - 1 ) ) NEW_LINE DEDENT
def isDivisible ( s , m ) : NEW_LINE INDENT mp = dict . fromkeys ( CHARS , 0 ) NEW_LINE for i in range ( DIGITS ) : NEW_LINE INDENT mp [ CHARS [ i ] ] = i NEW_LINE DEDENT r = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT r = ( r * 16 + mp [ s [ i ] ] ) % m NEW_LINE DEDENT if ( not r ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isPalindrome ( num ) : NEW_LINE INDENT s = str ( num ) NEW_LINE low = 0 NEW_LINE high = len ( s ) - 1 NEW_LINE while ( low < high ) : NEW_LINE INDENT if ( s [ low ] != s [ high ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def maxSubStr ( str1 , len1 , str2 , len2 ) : NEW_LINE INDENT if ( len1 > len2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT freq1 = [ 0 ] * MAX NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT freq2 = [ 0 ] * MAX NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT minPoss = sys . maxsize NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq1 [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT minPoss = min ( minPoss , freq2 [ i ] / freq1 [ i ] ) NEW_LINE DEDENT return int ( minPoss ) NEW_LINE DEDENT
def Count ( s , pos ) : NEW_LINE INDENT c = s [ pos - 1 ] NEW_LINE counter = 0 NEW_LINE for i in range ( pos - 1 ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT
def findSubStr ( string , cnt , start ) : NEW_LINE INDENT global minCnt NEW_LINE if ( start == len ( string ) ) : NEW_LINE INDENT minCnt = min ( cnt , minCnt ) NEW_LINE DEDENT for length in range ( 1 , len ( string ) - start + 1 ) : NEW_LINE INDENT subStr = string [ start : start + length ] NEW_LINE if subStr in uSet : NEW_LINE INDENT findSubStr ( string , cnt + 1 , start + length ) NEW_LINE DEDENT DEDENT DEDENT
def getMod ( _str , n , k ) : NEW_LINE INDENT pwrTwo = [ 0 ] * n NEW_LINE pwrTwo [ 0 ] = 1 % k NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pwrTwo [ i ] = pwrTwo [ i - 1 ] * ( 2 % k ) NEW_LINE pwrTwo [ i ] %= k NEW_LINE DEDENT res = 0 NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( _str [ j ] == '1' ) : NEW_LINE INDENT res += ( pwrTwo [ i ] ) NEW_LINE res %= k NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countStrings ( N ) : NEW_LINE INDENT dp = [ [ 0 ] * 3 for i in range ( N + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 2 ] = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD NEW_LINE DEDENT ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD NEW_LINE return ans NEW_LINE DEDENT
def getCount ( str1 , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 0 NEW_LINE while ( i < n - 2 ) : NEW_LINE INDENT if ( str1 [ i ] == str1 [ i + 1 ] and str1 [ i ] == str1 [ i + 2 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE i = i + 2 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def maxNumber ( string , n ) : NEW_LINE INDENT freq = [ 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( string [ i ] == 'z' ) : NEW_LINE INDENT freq [ 0 ] += 1 NEW_LINE DEDENT elif ( string [ i ] == 'n' ) : NEW_LINE INDENT freq [ 1 ] += 1 NEW_LINE DEDENT DEDENT num = "" NEW_LINE for i in range ( freq [ 1 ] ) : NEW_LINE INDENT num += '1' NEW_LINE DEDENT for i in range ( freq [ 0 ] ) : NEW_LINE INDENT num += '0' NEW_LINE DEDENT return num NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT
def countStrings ( string , n ) : NEW_LINE INDENT distinct_char = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT distinct_char . add ( string [ i ] ) NEW_LINE DEDENT return fact ( len ( distinct_char ) ) NEW_LINE DEDENT
def getChar ( strr ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT summ += ( ord ( strr [ i ] ) - ord ( 'a' ) + 1 ) NEW_LINE DEDENT if ( summ % 26 == 0 ) : NEW_LINE INDENT return ord ( 'z' ) NEW_LINE DEDENT else : NEW_LINE INDENT summ = summ % 26 NEW_LINE return chr ( ord ( 'a' ) + summ - 1 ) NEW_LINE DEDENT DEDENT
def countFreq ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE res = 0 NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < M ) : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == M ) : NEW_LINE INDENT res += 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findOccurrence ( arr , n , pattern ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT binary = decToBinary ( arr [ i ] ) NEW_LINE print ( countFreq ( pattern , binary ) , end = " " ) NEW_LINE DEDENT DEDENT
def findNumbers ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 1 NEW_LINE result = 0 NEW_LINE left = 0 NEW_LINE right = 1 NEW_LINE while ( right < n ) : NEW_LINE INDENT if ( s [ left ] == s [ right ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += count * ( count + 1 ) // 2 NEW_LINE left = right NEW_LINE count = 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT result += count * ( count + 1 ) // 2 NEW_LINE print ( result ) NEW_LINE DEDENT
def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def canBeBalanced ( s , n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT k = "(" k = k + s + ")" NEW_LINE d = [ ] NEW_LINE count = 0 NEW_LINE for i in range ( len ( k ) ) : NEW_LINE INDENT if k [ i ] == "(" : NEW_LINE INDENT d . append ( "(" ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( d ) != 0 : NEW_LINE INDENT d . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT if len ( d ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def maxLenSubStr ( s ) : NEW_LINE INDENT if ( len ( s ) < 3 ) : NEW_LINE INDENT return len ( s ) NEW_LINE DEDENT temp = 2 NEW_LINE ans = 2 NEW_LINE for i in range ( 2 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] or s [ i ] != s [ i - 2 ] ) : NEW_LINE INDENT temp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( temp , ans ) NEW_LINE temp = 2 NEW_LINE DEDENT DEDENT ans = max ( temp , ans ) NEW_LINE return ans NEW_LINE DEDENT
def CompareAlphanumeric ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE len1 = len ( str1 ) NEW_LINE len2 = len ( str2 ) NEW_LINE while ( i <= len1 and j <= len2 ) : NEW_LINE INDENT while ( i < len1 and ( ( ( str1 [ i ] >= 'a' and str1 [ i ] <= 'z' ) or ( str1 [ i ] >= 'A' and str1 [ i ] <= 'Z' ) or ( str1 [ i ] >= '0' and str1 [ i ] <= '9' ) ) == False ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( j < len2 and ( ( ( str2 [ j ] >= 'a' and str2 [ j ] <= 'z' ) or ( str2 [ j ] >= 'A' and str2 [ j ] <= 'Z' ) or ( str2 [ j ] >= '0' and str2 [ j ] <= '9' ) ) == False ) ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if ( i == len1 and j == len2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def expandString ( strin ) : NEW_LINE INDENT temp = "" NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( strin ) ) : NEW_LINE INDENT if ( strin [ i ] >= "0" ) : NEW_LINE INDENT num = ord ( strin [ i ] ) - ord ( "0" ) NEW_LINE if ( strin [ i + 1 ] == '(' ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( strin [ j ] != ')' ) : NEW_LINE INDENT if ( ( strin [ j ] >= 'a' and strin [ j ] <= 'z' ) or ( strin [ j ] >= 'A' and strin [ j ] <= 'Z' ) ) : NEW_LINE INDENT temp += strin [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT for k in range ( 1 , num + 1 ) : NEW_LINE INDENT print ( temp , end = "" ) NEW_LINE DEDENT num = 0 NEW_LINE temp = "" NEW_LINE if ( j < len ( strin ) ) : NEW_LINE INDENT i = j NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def countSubStr ( s , n ) : NEW_LINE INDENT c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i : i + 5 ] == "geeks" ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if ( s [ i : i + 3 ] == "for" ) : NEW_LINE INDENT c2 = c2 + c1 NEW_LINE DEDENT DEDENT return c2 NEW_LINE DEDENT
def isVowel ( ch ) : NEW_LINE INDENT ch = ch . upper ( ) NEW_LINE if ( ch == 'A' or ch == 'E' or ch == 'I' or ch == 'O' or ch == 'U' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def balancedBrackets ( Str ) : NEW_LINE INDENT dep = 0 NEW_LINE minDep = 0 NEW_LINE for i in Str : NEW_LINE INDENT if ( i == '(' ) : NEW_LINE INDENT dep += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dep -= 1 NEW_LINE DEDENT if ( minDep > dep ) : NEW_LINE INDENT minDep = dep NEW_LINE DEDENT DEDENT if ( minDep < 0 ) : NEW_LINE INDENT for i in range ( abs ( minDep ) ) : NEW_LINE INDENT Str = '(' + Str NEW_LINE DEDENT DEDENT dep = 0 NEW_LINE for i in Str : NEW_LINE INDENT if ( i == '(' ) : NEW_LINE INDENT dep += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dep -= 1 NEW_LINE DEDENT DEDENT if ( dep != 0 ) : NEW_LINE INDENT for i in range ( dep ) : NEW_LINE INDENT Str = Str + ')' NEW_LINE DEDENT DEDENT return Str NEW_LINE DEDENT
def minOperations ( str , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count + 1 ) // 2 NEW_LINE DEDENT
def stringToInt ( str ) : NEW_LINE INDENT if ( len ( str ) == 1 ) : NEW_LINE INDENT return ord ( str [ 0 ] ) - ord ( '0' ) NEW_LINE DEDENT y = stringToInt ( str [ 1 : ] ) NEW_LINE x = ord ( str [ 0 ] ) - ord ( '0' ) NEW_LINE x = x * ( 10 ** ( len ( str ) - 1 ) ) + y NEW_LINE return int ( x ) NEW_LINE DEDENT
def largestSubSeq ( arr , n ) : NEW_LINE INDENT count = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT string = arr [ i ] NEW_LINE _hash = [ False ] * MAX NEW_LINE for j in range ( len ( string ) ) : NEW_LINE INDENT _hash [ ord ( string [ j ] ) - ord ( 'a' ) ] = True NEW_LINE DEDENT for j in range ( MAX ) : NEW_LINE INDENT if _hash [ j ] == True : NEW_LINE INDENT count [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT return max ( count ) NEW_LINE DEDENT
def longest_substring ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE if ( k > 1 ) : NEW_LINE INDENT s += s NEW_LINE n *= 2 NEW_LINE DEDENT ans = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT x = 0 NEW_LINE while ( i < n and s [ i ] == '0' ) : NEW_LINE INDENT x , i = x + 1 , i + 1 NEW_LINE DEDENT ans = max ( ans , x ) NEW_LINE i += 1 NEW_LINE DEDENT if ( k == 1 or ans != n ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return ( ans // 2 ) * k NEW_LINE DEDENT DEDENT
def Occurrence ( s , position ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( position - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ position - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countOccurrence ( s , position ) : NEW_LINE INDENT alpha = [ 0 ] * 26 NEW_LINE b = [ 0 ] * len ( s ) NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT b [ i ] = alpha [ ord ( s [ i ] ) - 97 ] NEW_LINE alpha [ ord ( s [ i ] ) - 97 ] = alpha [ ord ( s [ i ] ) - 97 ] + 1 NEW_LINE DEDENT return b [ position - 1 ] NEW_LINE DEDENT
def find_permutation ( str1 , str2 , len1 , len2 , i , j , res ) : NEW_LINE INDENT if ( len ( res ) == len1 + len2 ) : NEW_LINE INDENT stringSet [ res ] = 1 NEW_LINE return NEW_LINE DEDENT if ( i < len1 ) : NEW_LINE INDENT find_permutation ( str1 , str2 , len1 , len2 , i + 1 , j , res + str1 [ i ] ) NEW_LINE DEDENT if ( j < len2 ) : NEW_LINE INDENT find_permutation ( str1 , str2 , len1 , len2 , i , j + 1 , res + str2 [ j ] ) NEW_LINE DEDENT DEDENT
def canConvert ( str1 , str2 ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while ( i < len ( str1 ) and j < len ( str2 ) ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT if ( str1 [ i ] == '0' and str2 [ j ] == '1' and i + 1 < len ( str1 ) and str1 [ i + 1 ] == '0' ) : NEW_LINE INDENT i += 2 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( i == len ( str1 ) and j == len ( str2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def reverse ( s ) : NEW_LINE INDENT stc = [ ] NEW_LINE temp = "" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' ' : NEW_LINE INDENT stc . append ( temp ) NEW_LINE DEDENT temp = "" NEW_LINE else : temp = temp + s [ i ] NEW_LINE stc . append ( temp ) NEW_LINE while len ( stc ) != 0 : NEW_LINE INDENT temp = stc [ len ( stc ) - 1 ] NEW_LINE print ( temp , end = " " ) NEW_LINE stc . pop ( ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def countPairs ( string , k ) : NEW_LINE INDENT n = len ( string ) NEW_LINE freq = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] > 1 ) : NEW_LINE INDENT cnt += ( ( freq [ i ] * ( freq [ i ] - 1 ) ) // 2 ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] > 0 and i + k < MAX and freq [ i + k ] > 0 ) : NEW_LINE INDENT cnt += ( freq [ i ] * freq [ i + k ] ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def printUncommon ( str1 , str2 ) : NEW_LINE INDENT a1 = 0 NEW_LINE a2 = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT ch = ord ( str1 [ i ] ) - ord ( 'a' ) NEW_LINE a1 = a1 | ( 1 << ch ) NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT ch = ord ( str2 [ i ] ) - ord ( 'a' ) NEW_LINE a2 = a2 | ( 1 << ch ) NEW_LINE DEDENT ans = a1 ^ a2 NEW_LINE i = 0 NEW_LINE while ( i < 26 ) : NEW_LINE INDENT if ( ans % 2 == 1 ) : NEW_LINE INDENT print ( chr ( ord ( 'a' ) + i ) , end = "" ) NEW_LINE DEDENT ans = ans // 2 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def isPalin ( i , j , k , l , p , q , s ) : NEW_LINE INDENT start = i NEW_LINE end = q NEW_LINE while ( start < end ) : NEW_LINE INDENT if ( s [ start ] != s [ end ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT start += 1 NEW_LINE if ( start == j + 1 ) : NEW_LINE INDENT start = k NEW_LINE DEDENT end -= 1 NEW_LINE if ( end == p - 1 ) : NEW_LINE INDENT end = l NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countSubStr ( s ) : NEW_LINE INDENT count = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i , n - 2 ) : NEW_LINE INDENT for k in range ( j + 1 , n - 1 ) : NEW_LINE INDENT for l in range ( k , n - 1 ) : NEW_LINE INDENT for p in range ( l + 1 , n ) : NEW_LINE INDENT for q in range ( p , n ) : NEW_LINE INDENT if ( isPalin ( i , j , k , l , p , q , s ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def sumAscii ( string , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPrime ( i + 1 ) ) : NEW_LINE INDENT sum += ord ( string [ i ] ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def Pangram ( x ) : NEW_LINE INDENT mp = { } NEW_LINE n = len ( x ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x [ i ] not in mp : NEW_LINE INDENT mp [ x [ i ] ] = 0 NEW_LINE DEDENT mp [ x [ i ] ] += 1 NEW_LINE DEDENT if ( len ( mp ) == 26 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def countTotalPangram ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( Pangram ( weight [ i ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def dfs ( node , parent ) : NEW_LINE INDENT for to in graph [ node ] : NEW_LINE INDENT if ( to == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( to , node ) NEW_LINE weight [ node ] += weight [ to ] NEW_LINE DEDENT DEDENT
def uniqueChars ( x ) : NEW_LINE INDENT mp = { } NEW_LINE n = len ( x ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x [ i ] not in mp : NEW_LINE INDENT mp [ x [ i ] ] = 0 NEW_LINE DEDENT mp [ x [ i ] ] += 1 NEW_LINE DEDENT if ( len ( mp ) == len ( x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def dfs ( node , parent ) : NEW_LINE INDENT global cnt , x NEW_LINE if ( uniqueChars ( weight [ node ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT for to in graph [ node ] : NEW_LINE INDENT if ( to == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( to , node ) NEW_LINE DEDENT DEDENT
def preCalculate ( string , n ) : NEW_LINE INDENT freq [ ord ( string [ 0 ] ) ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT charToUpdate = chr ( j ) NEW_LINE if charToUpdate == ch : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def getFrequency ( ch , l , r ) : NEW_LINE INDENT if l == 0 : NEW_LINE INDENT return freq [ ord ( ch ) ] [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( freq [ ord ( ch ) ] [ r ] - freq [ ord ( ch ) ] [ l - 1 ] ) NEW_LINE DEDENT DEDENT
def isValid ( s ) : NEW_LINE INDENT p = "" NEW_LINE p = s . find ( "geek" ) NEW_LINE if ( s . find ( "keeg" , p + 4 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isTwoAlter ( s ) : NEW_LINE INDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if ( s [ i ] != s [ i + 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def findCount ( s , n , a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( b ) : NEW_LINE INDENT if ( i == a ) : NEW_LINE INDENT res += ( s [ n - i - 1 ] != '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT res += ( s [ n - i - 1 ] != '0' ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def lenoflongestnonpalindrome ( s ) : NEW_LINE INDENT max1 , length = 1 , 0 NEW_LINE for i in range ( 0 , len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT length = 0 NEW_LINE DEDENT elif s [ i + 1 ] == s [ i - 1 ] and i > 0 : NEW_LINE INDENT length = 1 NEW_LINE length += 1 NEW_LINE DEDENT DEDENT if max1 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max1 NEW_LINE DEDENT DEDENT
def calcScore ( str ) : NEW_LINE INDENT score = 0 NEW_LINE len1 = len ( str ) NEW_LINE i = 0 NEW_LINE while ( i < len1 ) : NEW_LINE INDENT chunkSize = 1 NEW_LINE currentChar = str [ i ] NEW_LINE i += 1 NEW_LINE while ( i < len1 and str [ i ] == currentChar ) : NEW_LINE INDENT chunkSize += 1 NEW_LINE i += 1 NEW_LINE DEDENT if ( currentChar == '1' ) : NEW_LINE INDENT score += pow ( chunkSize , 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT score -= pow ( chunkSize , 2 ) NEW_LINE DEDENT DEDENT return score NEW_LINE DEDENT
def pre_process ( substrings , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT dup = "" NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT dup += s [ j ] NEW_LINE substrings . append ( dup ) NEW_LINE DEDENT DEDENT substrings . sort ( ) NEW_LINE return substrings NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def countSubString ( s , c , k ) : NEW_LINE INDENT leftCount = 0 NEW_LINE rightCount = 0 NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE freq = 0 NEW_LINE result = 0 NEW_LINE len1 = len ( s ) NEW_LINE while ( s [ left ] != c and left < len1 ) : NEW_LINE INDENT left += 1 NEW_LINE leftCount += 1 NEW_LINE DEDENT right = left + 1 NEW_LINE while ( freq != ( k - 1 ) and ( right - 1 ) < len1 ) : NEW_LINE INDENT if ( s [ right ] == c ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT while ( left < len1 and ( right - 1 ) < len1 ) : NEW_LINE INDENT while ( s [ left ] != c and left < len1 ) : NEW_LINE INDENT left += 1 NEW_LINE leftCount += 1 NEW_LINE DEDENT while ( right < len1 and s [ right ] != c ) : NEW_LINE INDENT if ( s [ right ] == c ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT right += 1 NEW_LINE rightCount += 1 NEW_LINE DEDENT result = ( result + ( leftCount + 1 ) * ( rightCount + 1 ) ) NEW_LINE freq = k - 1 NEW_LINE leftCount = 0 NEW_LINE rightCount = 0 NEW_LINE left += 1 NEW_LINE right += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
def performQueries ( l , r , prefix ) : NEW_LINE INDENT l -= 1 NEW_LINE r -= 1 NEW_LINE flag = False NEW_LINE count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT cnt = prefix [ r ] [ i ] NEW_LINE if ( l > 0 ) : NEW_LINE INDENT cnt -= prefix [ l - 1 ] [ i ] NEW_LINE DEDENT if ( cnt % 2 == 1 ) : NEW_LINE INDENT flag = True NEW_LINE count += cnt - 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += cnt NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def printSmallSub ( arr , N ) : NEW_LINE INDENT gcdArr = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT gcdArr = math . gcd ( gcdArr , arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] == gcdArr ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( math . gcd ( arr [ i ] , arr [ j ] ) == gcdArr ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE print ( arr [ j ] , end = " " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def countSubStr ( str , n , x ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT res += ( ( count + 1 ) * ( n - i ) ) NEW_LINE count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def isValid ( str1 , n ) : NEW_LINE INDENT if ( ( ( ord ( str1 [ 0 ] ) >= ord ( 'a' ) and ord ( str1 [ 0 ] ) <= ord ( 'z' ) ) or ( ord ( str1 [ 0 ] ) >= ord ( 'A' ) and ord ( str1 [ 0 ] ) <= ord ( 'Z' ) ) or ord ( str1 [ 0 ] ) == ord ( '_' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 1 , len ( str1 ) ) : NEW_LINE INDENT if ( ( ( ord ( str1 [ i ] ) >= ord ( 'a' ) and ord ( str1 [ i ] ) <= ord ( 'z' ) ) or ( ord ( str1 [ i ] ) >= ord ( 'A' ) and ord ( str1 [ i ] ) <= ord ( 'Z' ) ) or ( ord ( str1 [ i ] ) >= ord ( '0' ) and ord ( str1 [ i ] ) <= ord ( '9' ) ) or ord ( str1 [ i ] ) == ord ( '_' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countSubStr ( string , n ) : NEW_LINE INDENT length = len ( string ) NEW_LINE return ( length - n + 1 ) NEW_LINE DEDENT
def countSubstrings ( s , c ) : NEW_LINE INDENT n = len ( s ) NEW_LINE cnt = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] != c ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Sum += ( cnt * ( cnt + 1 ) ) // 2 NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT Sum += ( cnt * ( cnt + 1 ) ) // 2 NEW_LINE return Sum NEW_LINE DEDENT
def equalIgnoreCase ( str1 , str2 ) : NEW_LINE INDENT str1 = str1 . upper ( ) NEW_LINE str2 = str2 . upper ( ) NEW_LINE x = str1 == str2 NEW_LINE return x NEW_LINE DEDENT
def equalIgnoreCaseUtil ( str1 , str2 ) : NEW_LINE INDENT res = equalIgnoreCase ( str1 , str2 ) NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( "Same" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Not Same" ) NEW_LINE DEDENT DEDENT
def equalIgnoreCase ( str1 , str2 ) : NEW_LINE INDENT str1 = str1 . lower ( ) NEW_LINE str2 = str2 . lower ( ) NEW_LINE x = str1 == str2 NEW_LINE return x NEW_LINE DEDENT
def equalIgnoreCaseUtil ( str1 , str2 ) : NEW_LINE INDENT res = equalIgnoreCase ( str1 , str2 ) NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( "Same" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Not Same" ) NEW_LINE DEDENT DEDENT
def findM ( s , x ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) != x ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def FirstAndLast ( string ) : NEW_LINE INDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT print ( string [ i ] , end = "" ) NEW_LINE DEDENT if i == len ( string ) - 1 : NEW_LINE INDENT print ( string [ i ] , end = "" ) NEW_LINE DEDENT if string [ i ] == " " : NEW_LINE INDENT print ( string [ i - 1 ] , string [ i + 1 ] , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def Longestsubstring ( s ) : NEW_LINE INDENT lps = compute_lps ( s ) NEW_LINE n = len ( s ) NEW_LINE if ( lps [ n - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( lps [ i ] == lps [ n - 1 ] ) : NEW_LINE INDENT print ( s [ 0 : lps [ i ] ] ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ 0 : lps [ lps [ n - 1 ] - 1 ] ] ) NEW_LINE DEDENT DEDENT
def getBitmask ( s ) : NEW_LINE INDENT temp = 0 NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ j ] == 's' ) : NEW_LINE INDENT temp = temp | 1 NEW_LINE DEDENT elif ( s [ j ] == 't' ) : NEW_LINE INDENT temp = temp | 2 NEW_LINE DEDENT elif ( s [ j ] == 'r' ) : NEW_LINE INDENT temp = temp | 4 NEW_LINE DEDENT elif ( s [ j ] == 'i' ) : NEW_LINE INDENT temp = temp | 8 NEW_LINE DEDENT elif ( s [ j ] == 'n' ) : NEW_LINE INDENT temp = temp | 16 NEW_LINE DEDENT elif ( s [ j ] == 'g' ) : NEW_LINE INDENT temp = temp | 32 NEW_LINE DEDENT DEDENT return temp NEW_LINE DEDENT
def calculateWays ( s , n , l , r ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < l or i > r ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT DEDENT ways = 1 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT if ( freq [ ord ( s [ i ] ) - ord ( 'a' ) ] ) : NEW_LINE INDENT ways = ways * freq [ ord ( s [ i ] ) - ord ( 'a' ) ] NEW_LINE freq [ ord ( s [ i ] ) - ord ( 'a' ) ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ways = 0 NEW_LINE break NEW_LINE DEDENT DEDENT return ways NEW_LINE DEDENT
def asciiToSentence ( string , length ) : NEW_LINE INDENT num = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT num = num * 10 + ( ord ( string [ i ] ) - ord ( '0' ) ) NEW_LINE if ( num >= 32 and num <= 122 ) : NEW_LINE INDENT ch = chr ( num ) NEW_LINE print ( ch , end = "" ) NEW_LINE num = 0 NEW_LINE DEDENT DEDENT DEDENT
def countDistinctCode ( string ) : NEW_LINE INDENT codes = set ( ) NEW_LINE for i in range ( 0 , len ( string ) - 1 ) : NEW_LINE INDENT codes . add ( string [ i : i + 2 ] ) NEW_LINE DEDENT return len ( codes ) NEW_LINE DEDENT
def isReverseEqual ( s1 , s2 ) : NEW_LINE INDENT if len ( s1 ) != len ( s2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT l = len ( s1 ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if s1 [ i ] != s2 [ l - i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isPrefix ( string , length , i , k ) : NEW_LINE INDENT if i + k > length : NEW_LINE INDENT return False NEW_LINE DEDENT for j in range ( 0 , k ) : NEW_LINE INDENT if string [ i ] != string [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isKPeriodic ( string , length , k ) : NEW_LINE INDENT for i in range ( k , length , k ) : NEW_LINE INDENT if isPrefix ( string , length , i , k ) == False : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isFrequencyEqual ( string , length ) : NEW_LINE INDENT if length % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if freq [ i ] == length // 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def minLettersNeeded ( n ) : NEW_LINE INDENT if n % 26 == 0 : NEW_LINE INDENT return ( n // 26 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n // 26 ) + 1 ) NEW_LINE DEDENT DEDENT
def countMinReversals ( expr ) : NEW_LINE INDENT length = len ( expr ) NEW_LINE if length % 2 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = 0 NEW_LINE open = 0 NEW_LINE close = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if expr [ i ] == "" : NEW_LINE INDENT open += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if not open : NEW_LINE INDENT close += 1 NEW_LINE DEDENT else : NEW_LINE INDENT open -= 1 NEW_LINE DEDENT DEDENT DEDENT ans = ( close // 2 ) + ( open // 2 ) NEW_LINE close %= 2 NEW_LINE open %= 2 NEW_LINE if close > 0 : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minReplacement ( s , length ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if i % 2 == 0 and s [ i ] == '1' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if i % 2 == 1 and s [ i ] == '0' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return min ( ans , length - ans ) NEW_LINE DEDENT
def maxBalancedStr ( s ) : NEW_LINE INDENT open1 = 0 NEW_LINE close1 = 0 NEW_LINE open2 = 0 NEW_LINE close2 = 0 NEW_LINE open3 = 0 NEW_LINE close3 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '(' ) : open1 += 1 continue if s [ i ] == ')' : NEW_LINE INDENT close1 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == '{' : NEW_LINE INDENT open2 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == '}' : NEW_LINE INDENT close2 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == '[' : NEW_LINE INDENT open3 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ']' : NEW_LINE INDENT close3 += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT maxLen = ( 2 * min ( open1 , close1 ) + 2 * min ( open2 , close2 ) + 2 * min ( open3 , close3 ) ) NEW_LINE return maxLen NEW_LINE DEDENT
def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE arr1 = [ 0 ] * 7 NEW_LINE arr2 = [ 0 ] * 7 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s1 [ i ] ) ) NEW_LINE arr1 [ set_bits ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s2 [ i ] ) ) NEW_LINE arr2 [ set_bits ] += 1 NEW_LINE DEDENT for i in range ( 1 , 7 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def findCost ( s1 , s2 , a , b , c , d , n ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( s1 [ i ] == '1' and s2 [ i ] == '2' ) or ( s2 [ i ] == '1' and s1 [ i ] == '2' ) ) : NEW_LINE INDENT cost += min ( d , min ( a , b + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '2' and s2 [ i ] == '3' ) or ( s2 [ i ] == '2' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( b , a + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '1' and s2 [ i ] == '3' ) or ( s2 [ i ] == '1' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( c , a + b ) ) NEW_LINE DEDENT DEDENT DEDENT return cost NEW_LINE DEDENT
def totalPairs ( s1 , s2 ) : NEW_LINE INDENT a1 = 0 NEW_LINE b1 = 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( ord ( s1 [ i ] ) % 2 != 0 ) : NEW_LINE INDENT a1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b1 += 1 NEW_LINE DEDENT DEDENT a2 = 0 NEW_LINE b2 = 0 NEW_LINE for i in range ( len ( s2 ) ) : NEW_LINE INDENT if ( ord ( s2 [ i ] ) % 2 != 0 ) : NEW_LINE INDENT a2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b2 += 1 NEW_LINE DEDENT DEDENT return ( ( a1 * a2 ) + ( b1 * b2 ) ) NEW_LINE DEDENT
def replaceConsonants ( string ) : NEW_LINE INDENT res = "" NEW_LINE i = 0 NEW_LINE count = 0 NEW_LINE while ( i < len ( string ) ) : NEW_LINE INDENT if ( string [ i ] != 'a' and string [ i ] != 'e' and string [ i ] != 'i' and string [ i ] != 'o' and string [ i ] != 'u' ) : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) NEW_LINE DEDENT res += string [ i ] NEW_LINE i += 1 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def prefixOccurrences ( str1 ) : NEW_LINE INDENT c = str1 [ 0 ] NEW_LINE countc = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] == c ) : NEW_LINE INDENT countc += 1 NEW_LINE DEDENT DEDENT return countc NEW_LINE DEDENT
def Preprocess ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE mp [ A [ i ] ] = 1 NEW_LINE if A [ i ] == A [ n - i - 1 ] : NEW_LINE INDENT mp [ A [ n - i - 1 ] ] += 1 NEW_LINE DEDENT if B [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ B [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ B [ i ] ] = 1 NEW_LINE DEDENT if B [ n - i - 1 ] in mp . keys ( ) : NEW_LINE INDENT mp [ B [ n - 1 - i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ B [ n - 1 - i ] ] = 1 NEW_LINE DEDENT sz = len ( mp ) NEW_LINE if ( sz == 4 ) : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT elif ( sz == 3 ) : NEW_LINE INDENT ans += 1 + ( A [ i ] == A [ n - i - 1 ] ) NEW_LINE DEDENT elif ( sz == 2 ) : NEW_LINE INDENT ans += mp [ A [ i ] ] != 2 NEW_LINE DEDENT DEDENT if ( n % 2 == 1 and A [ n // 2 ] != B [ n // 2 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isPalindrome ( s ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( s ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( s [ i ] is not s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def getIndex ( S1 , S2 , n ) : NEW_LINE INDENT S = "" NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + S1 [ i ] NEW_LINE Temp = "" NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT Temp += S2 [ j ] NEW_LINE DEDENT if ( isPalindrome ( S + Temp ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def isPalindrome ( s , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT if ( c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def checkPossibility ( s1 , s2 ) : NEW_LINE INDENT l1 = len ( s1 ) NEW_LINE l2 = len ( s2 ) NEW_LINE if ( l1 != l2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( l1 ) : NEW_LINE INDENT if ( isVowel ( s1 [ i ] ) and isVowel ( s2 [ i ] ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( ( isVowel ( s1 [ i ] ) ) == False and ( isVowel ( s2 [ i ] ) == False ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def generateString ( A , B ) : NEW_LINE INDENT rt = "" NEW_LINE while ( 0 < A or 0 < B ) : NEW_LINE INDENT if ( A < B ) : NEW_LINE INDENT if ( 0 < B ) : NEW_LINE INDENT rt = rt + 'b' NEW_LINE B -= 1 NEW_LINE DEDENT if ( 0 < B ) : NEW_LINE INDENT rt += 'b' NEW_LINE B -= 1 NEW_LINE DEDENT if ( 0 < A ) : NEW_LINE INDENT rt += 'a' NEW_LINE A -= 1 NEW_LINE DEDENT DEDENT elif ( B < A ) : NEW_LINE INDENT if ( 0 < A ) : NEW_LINE INDENT rt += 'a' NEW_LINE A -= 1 NEW_LINE DEDENT if ( 0 < A ) : NEW_LINE INDENT rt += 'a' NEW_LINE A -= 1 NEW_LINE DEDENT if ( 0 < B ) : NEW_LINE INDENT rt += 'b' NEW_LINE B -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( 0 < A ) : NEW_LINE INDENT rt += 'a' NEW_LINE A -= 1 NEW_LINE DEDENT if ( 0 < B ) : NEW_LINE INDENT rt += 'b' NEW_LINE B -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( rt ) NEW_LINE DEDENT
def countStrings ( n , m , s ) : NEW_LINE INDENT ind = dict ( ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT mx = 0 NEW_LINE str1 = s [ j ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , int ( str1 [ i ] ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if int ( str1 [ i ] ) == mx : NEW_LINE INDENT ind [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT return len ( ind ) NEW_LINE DEDENT
def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 = 0 NEW_LINE ct1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == t [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ct0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ct1 += 1 NEW_LINE DEDENT DEDENT return max ( ct0 , ct1 ) NEW_LINE DEDENT
def count_acronym ( n , arr ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( arr [ i ] [ 0 ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT st = arr [ i ] NEW_LINE num = [ 0 ] * 26 NEW_LINE for j in range ( len ( st ) ) : NEW_LINE INDENT num [ ord ( st [ j ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT flag = True NEW_LINE for j in range ( 1 , 26 ) : NEW_LINE INDENT if num [ j ] > freq [ j ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT x = ord ( st [ 0 ] ) - ord ( 'a' ) NEW_LINE if freq [ x ] - 1 < num [ x ] : NEW_LINE INDENT flag = False NEW_LINE DEDENT if flag : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def minOperations ( str , n ) : NEW_LINE INDENT lastUpper = - 1 NEW_LINE firstLower = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT lastUpper = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] . islower ( ) ) : NEW_LINE INDENT firstLower = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( lastUpper == - 1 or firstLower == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT countUpper = 0 NEW_LINE for i in range ( firstLower , n ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT countUpper += 1 NEW_LINE DEDENT DEDENT countLower = 0 NEW_LINE for i in range ( lastUpper ) : NEW_LINE INDENT if ( str [ i ] . islower ( ) ) : NEW_LINE INDENT countLower += 1 NEW_LINE DEDENT DEDENT return min ( countLower , countUpper ) NEW_LINE DEDENT
def check ( s , k ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i % k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( a [ 0 : i ] == b [ 0 : i ] ) : NEW_LINE INDENT if ( check ( a , i ) and check ( b , i ) ) : NEW_LINE INDENT ct = ct + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT
def valid ( cnt ) : NEW_LINE INDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if cnt [ i ] >= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT c = c . lower ( ) NEW_LINE if ( c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def largestPalinSub ( s ) : NEW_LINE INDENT res = "" NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == mx : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def isValid ( string , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if string [ i ] == string [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def decryptString ( str , n ) : NEW_LINE INDENT i = 0 NEW_LINE jump = 1 NEW_LINE decryptedStr = "" NEW_LINE while ( i < n ) : NEW_LINE INDENT decryptedStr += str [ i ] NEW_LINE i += jump NEW_LINE jump += 1 NEW_LINE DEDENT return decryptedStr NEW_LINE DEDENT
def countSubStr ( str , l , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT n = 0 NEW_LINE for j in range ( i , l , 1 ) : NEW_LINE INDENT n = n * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) NEW_LINE if ( n % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def nextZero ( i , occurrences ) : NEW_LINE INDENT while i < 26 : NEW_LINE INDENT if occurrences [ i ] == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findPermutation ( string , k ) : NEW_LINE INDENT has = [ False for i in range ( 26 ) ] NEW_LINE cnt = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( has [ ord ( string [ i ] ) - ord ( 'a' ) ] == False ) : NEW_LINE INDENT cnt += 1 NEW_LINE has [ ord ( string [ i ] ) - ord ( 'a' ) ] = True NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE for i in range ( 2 , cnt + 1 ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT for i in range ( cnt - k , 1 , - 1 ) : NEW_LINE INDENT ans //= i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countPairs ( bracks , num ) : NEW_LINE INDENT openn = dict ( ) NEW_LINE close = dict ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( num ) : NEW_LINE INDENT s = bracks [ i ] NEW_LINE l = len ( s ) NEW_LINE op , cl = 0 , 0 NEW_LINE for j in range ( l ) : NEW_LINE INDENT if ( s [ j ] == '(' ) : NEW_LINE INDENT op += 1 NEW_LINE if ( op ) : NEW_LINE INDENT op -= 1 NEW_LINE cl += 1 NEW_LINE DEDENT DEDENT DEDENT if ( op and cl == 0 ) : NEW_LINE INDENT if op in openn . keys ( ) : NEW_LINE INDENT openn [ op ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT openn [ op ] = 1 NEW_LINE DEDENT DEDENT if ( cl and op == 0 ) : NEW_LINE INDENT if cl in openn . keys ( ) : NEW_LINE INDENT close [ cl ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT close [ cl ] = 1 NEW_LINE DEDENT DEDENT if ( op == 0 and cl == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT cnt = cnt // 2 NEW_LINE for it in openn : NEW_LINE INDENT cnt += min ( openn [ it ] , close [ it ] ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def no_of_ways ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count_left = 0 NEW_LINE count_right = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ 0 ] ) : NEW_LINE INDENT count_left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( s [ i ] == s [ n - 1 ] ) : NEW_LINE INDENT count_right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( s [ 0 ] == s [ n - 1 ] ) : NEW_LINE INDENT return ( ( count_left + 1 ) * ( count_right + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( count_left + count_right + 1 ) NEW_LINE DEDENT DEDENT
def isPalindrome ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l // 2 ) : NEW_LINE INDENT if ( s [ i ] != s [ l - 1 - i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def createStringAndCheckPalindrome ( N ) : NEW_LINE INDENT sub = "" + chr ( N ) NEW_LINE res_str = "" NEW_LINE sum = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT digit = N % 10 NEW_LINE sum += digit NEW_LINE N = N // 10 NEW_LINE DEDENT while ( len ( res_str ) < sum ) : NEW_LINE INDENT res_str += sub NEW_LINE DEDENT if ( len ( res_str ) > sum ) : NEW_LINE INDENT res_str = res_str [ 0 : sum ] NEW_LINE DEDENT if ( isPalindrome ( res_str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def product ( x ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( x ) : NEW_LINE INDENT prod *= ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT return prod NEW_LINE DEDENT
def removeChars ( s ) : NEW_LINE INDENT modifiedStr = "" NEW_LINE modifiedStr += s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] . isupper ( ) and s [ i - 1 ] . islower ( ) or s [ i ] . islower ( ) and s [ i - 1 ] . isupper ( ) ) : NEW_LINE INDENT modifiedStr += s [ i ] NEW_LINE DEDENT DEDENT return modifiedStr NEW_LINE DEDENT
def pangramCost ( arr , string ) : NEW_LINE INDENT cost = 0 NEW_LINE occurred = [ False ] * 26 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT occurred [ ord ( string [ i ] ) - ord ( 'a' ) ] = True NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( not occurred [ i ] ) : NEW_LINE INDENT cost += arr [ i ] NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT
def pairStar ( Input , Output , i = 0 ) : NEW_LINE INDENT Output = Output + Input [ i ] NEW_LINE if ( i == len ( Input ) - 1 ) : NEW_LINE INDENT print ( Output ) NEW_LINE return NEW_LINE DEDENT if ( Input [ i ] == Input [ i + 1 ] ) : NEW_LINE INDENT Output = Output + '*' NEW_LINE DEDENT pairStar ( Input , Output , i + 1 ) NEW_LINE DEDENT
def countMinParts ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE freq = getFrequencies ( string ) NEW_LINE oddFreq = [ ] NEW_LINE evenFreq = [ ] NEW_LINE sumEven = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if freq [ i ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if freq [ i ] % 2 == 0 : NEW_LINE INDENT evenFreq . append ( freq [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddFreq . append ( freq [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( evenFreq ) ) : NEW_LINE INDENT sumEven += evenFreq [ i ] NEW_LINE DEDENT if len ( oddFreq ) == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if sumEven == 0 : NEW_LINE INDENT if len ( oddFreq ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT i = 0 NEW_LINE while ( i < len ( oddFreq ) ) : NEW_LINE INDENT if ( ( sumEven / 2 ) % len ( oddFreq ) == 0 ) : NEW_LINE INDENT return len ( oddFreq ) NEW_LINE DEDENT if ( oddFreq [ i ] == 1 ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT sumEven += 2 NEW_LINE oddFreq [ i ] = oddFreq [ i ] - 2 NEW_LINE DEDENT return n NEW_LINE DEDENT
def check ( s , K ) : NEW_LINE INDENT for ch in range ( 0 , 26 ) : NEW_LINE INDENT c = chr ( 97 + ch ) NEW_LINE last = - 1 NEW_LINE found = True NEW_LINE for i in range ( 0 , K ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT last = i NEW_LINE DEDENT DEDENT if last == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT for i in range ( K , len ( s ) ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT last = i NEW_LINE DEDENT if last <= ( i - K ) : NEW_LINE INDENT found = False NEW_LINE break NEW_LINE DEDENT DEDENT if found : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def binarySearch ( s ) : NEW_LINE INDENT low , high , ans = 1 , len ( s ) , None NEW_LINE while low <= high : NEW_LINE INDENT mid = ( high + low ) >> 1 NEW_LINE if check ( s , mid ) : NEW_LINE INDENT ans , high = mid , mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def subStringsStartingHere ( string , n , startIndex ) : NEW_LINE INDENT count = 0 NEW_LINE i = startIndex + 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT if string . startswith ( string [ startIndex : i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def printExpansion ( str ) : NEW_LINE INDENT for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i , len ( str ) ) : NEW_LINE INDENT print ( str [ j ] , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def printExpansion ( str ) : NEW_LINE INDENT suff = "" NEW_LINE for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT suff = suff + str [ i ] NEW_LINE print ( suff , end = "" ) NEW_LINE DEDENT DEDENT
def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE countP = [ 0 ] * ALL_CHARS NEW_LINE countTW = [ 0 ] * ALL_CHARS NEW_LINE for i in range ( M ) : NEW_LINE INDENT countP [ ord ( pat [ i ] ) ] += 1 NEW_LINE countTW [ ord ( txt [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( M , N ) : NEW_LINE INDENT if compare ( countP , countTW ) : NEW_LINE INDENT return True NEW_LINE DEDENT countTW [ ord ( txt [ i ] ) ] += 1 NEW_LINE countTW [ ord ( txt [ i - M ] ) ] -= 1 NEW_LINE DEDENT if compare ( countP , countTW ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def logicalExpressionEvaluation ( string ) : NEW_LINE INDENT arr = list ( ) NEW_LINE n = len ( string ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( string [ i ] == "[" ) : NEW_LINE INDENT s = list ( ) NEW_LINE while ( arr [ - 1 ] != "]" ) : NEW_LINE INDENT s . append ( arr [ - 1 ] ) NEW_LINE arr . pop ( ) NEW_LINE DEDENT arr . pop ( ) NEW_LINE if ( len ( s ) == 3 ) : NEW_LINE INDENT if s [ 2 ] == "1" : NEW_LINE INDENT arr . append ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT arr . append ( "1" ) NEW_LINE DEDENT DEDENT elif ( len ( s ) == 5 ) : NEW_LINE INDENT a = int ( s [ 0 ] ) - 48 NEW_LINE b = int ( s [ 4 ] ) - 48 NEW_LINE c = 0 NEW_LINE if s [ 2 ] == "&" : NEW_LINE INDENT c = a & b NEW_LINE DEDENT else : NEW_LINE INDENT c = a | b NEW_LINE DEDENT arr . append ( ( c ) + 48 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT arr . append ( string [ i ] ) NEW_LINE DEDENT DEDENT return arr [ - 1 ] NEW_LINE DEDENT
def count ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE d , count = 0 , 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT d += ord ( s [ i ] ) NEW_LINE if ( d % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT prev = ord ( s [ i - k ] ) NEW_LINE d -= prev NEW_LINE d += ord ( s [ i ] ) NEW_LINE if ( d % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE return count NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def MaxFreq ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT string = '' NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT string += s [ j ] NEW_LINE if string in m . keys ( ) : NEW_LINE INDENT m [ string ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ string ] = 1 NEW_LINE DEDENT DEDENT DEDENT maxi = 0 NEW_LINE maxi_str = '' NEW_LINE for i in m : NEW_LINE INDENT if m [ i ] > maxi : NEW_LINE INDENT maxi = m [ i ] NEW_LINE maxi_str = i NEW_LINE DEDENT elif m [ i ] == maxi : NEW_LINE INDENT ss = i NEW_LINE if len ( ss ) > len ( maxi_str ) : NEW_LINE INDENT maxi_str = ss NEW_LINE DEDENT DEDENT DEDENT return maxi_str NEW_LINE DEDENT
def preCompute ( n , s , pref ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] NEW_LINE if s [ i - 1 ] == s [ i ] : NEW_LINE INDENT pref [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT
def query ( pref , l , r ) : NEW_LINE INDENT return pref [ r ] - pref [ l ] NEW_LINE DEDENT
def countWays ( s1 , s2 , n ) : NEW_LINE INDENT a = b = c = d = 0 NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( s2 [ i ] == '0' ) : NEW_LINE INDENT if ( s1 [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s1 [ i ] == '0' ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT DEDENT result = a * d + b * c + c * d NEW_LINE return result NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , mt . ceil ( mt . sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def check_frequency ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in m . keys ( ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT for ch in m : NEW_LINE INDENT if m [ ch ] > 0 and isPrime ( m [ ch ] ) == False : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def returnWinner ( s , l ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( 0 , l , 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt == 0 or cnt & 1 == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT
def check ( s ) : NEW_LINE INDENT fr = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = ord ( s [ i ] ) NEW_LINE fr [ x - 97 ] += 1 NEW_LINE DEDENT minimum = 99999999999 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( i + 1 , 26 ) : NEW_LINE INDENT z = fr [ i ] + fr [ j ] NEW_LINE minimum = min ( minimum , n - z ) NEW_LINE DEDENT DEDENT return minimum NEW_LINE DEDENT
def findSubstringCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ord ( str [ i ] ) + 1 == ord ( str [ i + 1 ] ) ) : NEW_LINE INDENT result += 1 NEW_LINE while ( ord ( str [ i ] ) + 1 == ord ( str [ i + 1 ] ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def CountCharacters ( str , l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE m = { } NEW_LINE length = len ( str ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if ( not ( l <= ord ( str [ i ] ) and ord ( str [ i ] ) <= r ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE if ord ( str [ i ] ) not in m : NEW_LINE INDENT m [ ord ( str [ i ] ) ] = 0 NEW_LINE print ( str [ i ] , end = " " ) NEW_LINE DEDENT m [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def strScore ( str , s , n ) : NEW_LINE INDENT score = 0 NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == s ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT score += ( ord ( s [ j ] ) - ord ( 'a' ) + 1 ) NEW_LINE DEDENT index = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT score = score * index NEW_LINE return score NEW_LINE DEDENT
def countChar ( str , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE repetitions = n // len ( str ) NEW_LINE count = count * repetitions NEW_LINE l = n % len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countConsecutive ( s ) : NEW_LINE INDENT count = - 1 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( i <= len ( s ) ) : NEW_LINE INDENT if ( s [ i ] is s [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def check_digits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def smallest_number ( n ) : NEW_LINE INDENT i = n NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( check_digits ( i ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
def minSteps ( str ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str ) - 2 : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT if ( str [ i + 1 ] == '1' ) : NEW_LINE INDENT if ( str [ i + 2 ] == '0' ) : NEW_LINE INDENT count = count + 1 NEW_LINE i = i + 2 NEW_LINE DEDENT DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def xorOfPrime ( s ) : NEW_LINE INDENT prime = [ True ] * 100005 NEW_LINE SieveOfEratosthenes ( prime , 10005 ) NEW_LINE m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT result = flag = 0 NEW_LINE for it in m : NEW_LINE INDENT if prime [ m [ it ] ] : NEW_LINE INDENT result ^= m [ it ] NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
def CountCharacters ( str , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ord ( str [ i ] ) < k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def dfs ( node , k , A ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT str = node + A [ i ] NEW_LINE if ( str not in seen ) : NEW_LINE INDENT seen . add ( str ) NEW_LINE dfs ( str [ 1 : ] , k , A ) NEW_LINE edges . append ( i ) NEW_LINE DEDENT DEDENT DEDENT
def fact ( n ) : NEW_LINE INDENT f = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f = f * i NEW_LINE DEDENT return f NEW_LINE DEDENT
def npr ( n , r ) : NEW_LINE INDENT return fact ( n ) / fact ( n - r ) NEW_LINE DEDENT
def checkIfUnequal ( n , q ) : NEW_LINE INDENT s1 = str ( n ) NEW_LINE a = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( 0 , len ( s1 ) , 1 ) : NEW_LINE INDENT a [ ord ( s1 [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT prod = n * q NEW_LINE s2 = str ( prod ) NEW_LINE for i in range ( 0 , len ( s2 ) , 1 ) : NEW_LINE INDENT if ( a [ ord ( s2 [ i ] ) - ord ( '0' ) ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countInRange ( l , r , q ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT if ( checkIfUnequal ( i , q ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def search ( arr , strt , end , value ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( strt , end + 1 ) : NEW_LINE INDENT if ( arr [ i ] == value ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT
def preOrder ( node ) : NEW_LINE INDENT if node == None : NEW_LINE INDENT return NEW_LINE DEDENT print ( node . data , end = " " ) NEW_LINE preOrder ( node . left ) NEW_LINE preOrder ( node . right ) NEW_LINE DEDENT
def countOnOff ( n ) : NEW_LINE INDENT Led = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 5 ] NEW_LINE leng = len ( n ) NEW_LINE sum = Led [ int ( n [ 0 ] ) - int ( '0' ) ] NEW_LINE for i in range ( 1 , leng ) : NEW_LINE INDENT sum = ( sum + abs ( Led [ int ( n [ i ] ) - int ( '0' ) ] - Led [ int ( n [ i - 1 ] ) - int ( '0' ) ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def checkMarkov ( m ) : NEW_LINE INDENT for i in range ( 0 , len ( m ) ) : NEW_LINE INDENT sm = 0 NEW_LINE for j in range ( 0 , len ( m [ i ] ) ) : NEW_LINE INDENT sm = sm + m [ i ] [ j ] NEW_LINE DEDENT if ( sm != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isBinary ( n ) : NEW_LINE INDENT while n != 0 : NEW_LINE INDENT temp = n % 10 NEW_LINE if temp != 0 and temp != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
def checkPalindrome ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ len ( s ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def CheckOdd ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = "" NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT x += s [ j ] NEW_LINE if ( len ( x ) % 2 == 0 and checkPalindrome ( x ) == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def areVowelsInOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = chr ( 64 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == 'a' or s [ i ] == 'e' or s [ i ] == 'i' or s [ i ] == 'o' or s [ i ] == 'u' ) : NEW_LINE INDENT if s [ i ] < c : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def solve ( s , k ) : NEW_LINE INDENT count , length , pos = 0 , 0 , 0 NEW_LINE m = dict . fromkeys ( s , 0 ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE length += 1 NEW_LINE if length > k : NEW_LINE INDENT m [ s [ pos ] ] -= 1 NEW_LINE pos += 1 NEW_LINE length -= 1 NEW_LINE DEDENT if length == k and m [ s [ i ] ] == length : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def solve ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in m : NEW_LINE INDENT m [ s [ i ] ] = m [ s [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT new_string = "" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if m [ s [ i ] ] % 2 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT new_string = new_string + s [ i ] NEW_LINE DEDENT print ( new_string ) NEW_LINE DEDENT
def isDiagonalMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def minParentheses ( p ) : NEW_LINE INDENT bal = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , len ( p ) ) : NEW_LINE INDENT if ( p [ i ] == '(' ) : NEW_LINE INDENT bal += 1 NEW_LINE DEDENT else : NEW_LINE INDENT bal += - 1 NEW_LINE DEDENT if ( bal == - 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE bal += 1 NEW_LINE DEDENT DEDENT return bal + ans NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result *= i NEW_LINE DEDENT return result NEW_LINE DEDENT
def getResult ( string , ch ) : NEW_LINE INDENT has = [ 0 ] * 26 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT has [ ord ( string [ i ] ) - ord ( 'A' ) ] += 1 NEW_LINE DEDENT particular = has [ ord ( ch ) - ord ( 'A' ) ] NEW_LINE if particular == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT has [ ord ( ch ) - ord ( 'A' ) ] = 0 NEW_LINE total = len ( string ) NEW_LINE total = total - particular + 1 NEW_LINE result = fact ( total ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if has [ i ] > 1 : NEW_LINE INDENT result /= fact ( has [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def isAnyNotPalindrome ( s ) : NEW_LINE INDENT unique = set ( ) NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT unique . add ( s [ i ] ) NEW_LINE DEDENT if ( len ( unique ) > 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def isScalarMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def Remainder ( str , R ) : NEW_LINE INDENT l = len ( str ) NEW_LINE Rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT Num = Rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE Rem = Num % R NEW_LINE DEDENT return Rem NEW_LINE DEDENT
def Solve ( N , M ) : NEW_LINE INDENT temp = ( N - 1 ) * ( M - 1 ) NEW_LINE ans = pow ( 2 , temp ) NEW_LINE if ( ( N + M ) % 2 != 0 ) : NEW_LINE INDENT print ( ans ) NEW_LINE else : print ( 2 * ans ) NEW_LINE if __name__ == '__main__' : NEW_LINE INDENT N , M = 3 , 3 NEW_LINE Solve ( N , M ) NEW_LINE DEDENT DEDENT DEDENT
def countWays ( a , n ) : NEW_LINE INDENT suff = [ 0 ] * n NEW_LINE if ( a [ n - 1 ] == 2 ) : NEW_LINE INDENT suff [ n - 1 ] = 1 NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] == 2 ) : NEW_LINE INDENT suff [ i ] = suff [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT suff [ i ] = suff [ i + 1 ] NEW_LINE DEDENT DEDENT ss = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT ss += suff [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ i ] == 1 and a [ j ] == 1 and suff [ j ] >= 2 ) : NEW_LINE INDENT ss += ( suff [ j ] ) * ( suff [ j ] - 1 ) // 2 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ i ] == 1 and a [ j ] == 1 and ( suff [ i ] - suff [ j ] ) >= 1 and suff [ j ] >= 1 ) : NEW_LINE INDENT ss += ( suff [ i ] - suff [ j ] ) * suff [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( ss ) NEW_LINE DEDENT
def productAscii ( str ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT prod = prod * ord ( str [ i ] ) NEW_LINE DEDENT return prod NEW_LINE DEDENT
def sortByRow ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT if mat [ i ] [ j ] > mat [ i ] [ j + 1 ] : NEW_LINE INDENT temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ i ] [ j + 1 ] NEW_LINE mat [ i ] [ j + 1 ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT
def transpose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT t = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE mat [ j ] [ i ] = t NEW_LINE DEDENT DEDENT DEDENT
def sortMatRowAndColWise ( mat , n ) : NEW_LINE INDENT sortByRow ( mat , n ) NEW_LINE transpose ( mat , n ) NEW_LINE sortByRow ( mat , n ) NEW_LINE transpose ( mat , n ) NEW_LINE DEDENT
def minimumLength ( s ) : NEW_LINE INDENT maxOcc = 0 NEW_LINE n = len ( s ) NEW_LINE arr = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if arr [ i ] > maxOcc : NEW_LINE INDENT maxOcc = arr [ i ] NEW_LINE DEDENT DEDENT return n - maxOcc NEW_LINE DEDENT
def balancedString ( str ) : NEW_LINE INDENT count , i = 0 , 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == '(' ) : NEW_LINE INDENT print ( str [ i ] , end = "" ) NEW_LINE count += 1 NEW_LINE DEDENT elif ( str [ i ] == ')' and count != 0 ) : NEW_LINE INDENT print ( str [ i ] , end = "" ) NEW_LINE count -= 1 NEW_LINE DEDENT elif ( str [ i ] != ')' ) : NEW_LINE INDENT print ( str [ i ] , end = "" ) NEW_LINE DEDENT DEDENT if ( count != 0 ) : NEW_LINE INDENT for i in range ( count ) : NEW_LINE INDENT print ( ")" , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def minOperation ( s , i , j , count ) : NEW_LINE INDENT if ( ( i >= len ( s ) and j < 0 ) or ( i == j ) ) : NEW_LINE INDENT return MAX NEW_LINE DEDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( i >= len ( s ) ) : NEW_LINE INDENT return minOperation ( s , i , j - 1 , count + 1 ) NEW_LINE DEDENT elif ( j < 0 ) : NEW_LINE INDENT return minOperation ( s , i + 1 , j , count + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) NEW_LINE DEDENT DEDENT
def minOperation ( s , i , j , count ) : NEW_LINE INDENT global Min , MAX NEW_LINE if ( ( i >= len ( s ) and j < 0 ) or ( i == j ) ) : NEW_LINE INDENT return MAX NEW_LINE DEDENT if ( s [ i ] == s [ j ] or count >= Min ) : NEW_LINE INDENT return count NEW_LINE DEDENT Str = str ( i ) + "|" + str ( j ) NEW_LINE if Str not in m : NEW_LINE INDENT if ( i >= len ( s ) ) : NEW_LINE INDENT m [ Str ] = minOperation ( s , i , j - 1 , count + 1 ) NEW_LINE DEDENT elif ( j < 0 ) : NEW_LINE INDENT m [ Str ] = minOperation ( s , i + 1 , j , count + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT m [ Str ] = min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) NEW_LINE DEDENT DEDENT if ( m [ Str ] < Min ) : NEW_LINE INDENT Min = m [ Str ] NEW_LINE DEDENT return m [ Str ] NEW_LINE DEDENT
def countStrings ( s ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( i % 2 == 0 and s [ i ] == '$' ) : NEW_LINE INDENT sum *= 21 NEW_LINE DEDENT elif ( s [ i ] == '$' ) : NEW_LINE INDENT sum *= 5 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def firstPos ( str , start , end ) : NEW_LINE INDENT firstChar = - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( str [ i ] >= 'a' and str [ i ] <= 'z' ) : NEW_LINE INDENT firstChar = i NEW_LINE break NEW_LINE DEDENT DEDENT return firstChar NEW_LINE DEDENT
def lastPos ( str , start , end ) : NEW_LINE INDENT lastChar = - 1 NEW_LINE for i in range ( start , end - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] >= 'a' and str [ i ] <= 'z' ) : NEW_LINE INDENT lastChar = i NEW_LINE break NEW_LINE DEDENT DEDENT return lastChar NEW_LINE DEDENT
def isInGivenBase ( Str , base ) : NEW_LINE INDENT if ( base > 16 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( base <= 10 ) : NEW_LINE INDENT for i in range ( len ( Str ) ) : NEW_LINE INDENT if ( Str [ i ] . isnumeric ( ) and ( ord ( Str [ i ] ) >= ord ( '0' ) and ord ( Str [ i ] ) < ( ord ( '0' ) + base ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( len ( Str ) ) : NEW_LINE INDENT if ( Str [ i ] . isnumeric ( ) and ( ( ord ( Str [ i ] ) >= ord ( '0' ) and ord ( Str [ i ] ) < ( ord ( '0' ) + base ) ) or ( ord ( Str [ i ] ) >= ord ( 'A' ) and ord ( Str [ i ] ) < ( ord ( 'A' ) + base - 10 ) ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def frequency ( fre , s , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT string = s [ i ] NEW_LINE for j in range ( 0 , len ( string ) ) : NEW_LINE INDENT fre [ i ] [ ord ( string [ j ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT DEDENT DEDENT
def printIndex ( str , s ) : NEW_LINE INDENT flag = False NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i : i + len ( s ) ] == s ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE flag = True NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT print ( "NONE" ) NEW_LINE DEDENT DEDENT
def powerOfJump ( s ) : NEW_LINE INDENT count = 1 NEW_LINE max_so_far = 0 NEW_LINE ch = s [ - 1 ] NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == ch : NEW_LINE INDENT if count > max_so_far : NEW_LINE INDENT max_so_far = count NEW_LINE DEDENT count = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def findLongestSub ( bin1 ) : NEW_LINE INDENT n = len ( bin1 ) NEW_LINE sum = 0 NEW_LINE prevSum = { i : 0 for i in range ( n ) } NEW_LINE maxlen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( bin1 [ i ] == '1' ) : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= 1 NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT maxlen = i + 1 NEW_LINE DEDENT elif ( sum <= 0 ) : NEW_LINE INDENT if ( ( sum - 1 ) in prevSum ) : NEW_LINE INDENT currlen = i - prevSum [ sum - 1 ] NEW_LINE maxlen = max ( maxlen , currlen ) NEW_LINE DEDENT DEDENT if ( ( sum ) not in prevSum ) : NEW_LINE INDENT prevSum [ sum ] = i NEW_LINE DEDENT DEDENT return maxlen NEW_LINE DEDENT
def countEvenOdd ( arr , n , K ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = bin ( arr [ i ] ) . count ( '1' ) NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT y = bin ( K ) . count ( '1' ) NEW_LINE if ( y & 1 ) : NEW_LINE INDENT print ( "Even =" , odd , ", Odd =" , even ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Even =" , even , ", Odd =" , odd ) NEW_LINE DEDENT DEDENT
def averageValue ( s ) : NEW_LINE INDENT sum_char = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum_char += ord ( s [ i ] ) NEW_LINE DEDENT return sum_char // len ( s ) NEW_LINE DEDENT
def findNumberOfTimes ( str1 , str2 ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE l1 = len ( str1 ) NEW_LINE freq2 = [ 0 ] * 26 NEW_LINE l2 = len ( str2 ) NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( "a" ) ] += 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( "a" ) ] += 1 NEW_LINE DEDENT count = sys . maxsize NEW_LINE for i in range ( l2 ) : NEW_LINE INDENT count = min ( count , freq [ ord ( str2 [ i ] ) - ord ( 'a' ) ] / freq2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def solve ( s1 , s2 ) : NEW_LINE INDENT flag1 = 0 NEW_LINE flag2 = 0 NEW_LINE if ( len ( s1 ) != len ( s2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT l = len ( s1 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( s1 [ i ] == '1' ) : NEW_LINE INDENT flag1 = 1 NEW_LINE DEDENT if ( s2 [ i ] == '1' ) : NEW_LINE INDENT flag2 = 1 NEW_LINE DEDENT if ( flag1 & flag2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ! flag1 & ! flag2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def check ( s , l ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def isPalindrome ( str , l , r ) : NEW_LINE INDENT while ( l < r ) : NEW_LINE INDENT if ( str [ l ] != str [ r ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def CyclicShifts ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE left = 0 NEW_LINE right = n - 1 NEW_LINE str = str + str NEW_LINE cnt = 0 NEW_LINE while ( right < 2 * n - 1 ) : NEW_LINE INDENT if ( isPalindrome ( str , left , right ) ) : NEW_LINE INDENT break NEW_LINE DEDENT cnt += 1 NEW_LINE left += 1 NEW_LINE right += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def printNum ( s ) : NEW_LINE INDENT i , j , val = 0 , 0 , 0 NEW_LINE mp = { } NEW_LINE val = ( ( ord ( s [ 0 ] ) - ord ( '0' ) ) * 100 + ( ord ( s [ 1 ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ 2 ] ) - ord ( '0' ) ) ) NEW_LINE mp [ val ] = 1 NEW_LINE for i in range ( 3 , len ( s ) ) : NEW_LINE INDENT val = ( val % 100 ) * 10 + ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( val in mp ) : NEW_LINE INDENT mp [ val ] = mp [ val ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ val ] = 1 NEW_LINE DEDENT DEDENT for m in mp : NEW_LINE INDENT key = m NEW_LINE value = mp [ m ] NEW_LINE if ( value > 1 ) : NEW_LINE INDENT print ( key , " - " , value , " times" ) NEW_LINE DEDENT DEDENT DEDENT
def countSubstrig ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 == 0 or n1 < n2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( str1 [ 0 : n2 ] == str2 ) : NEW_LINE INDENT return countSubstrig ( str1 [ n2 - 1 : ] , str2 ) + 1 NEW_LINE DEDENT return countSubstrig ( str1 [ n2 - 1 : ] , str2 ) NEW_LINE DEDENT
def check ( s , m ) : NEW_LINE INDENT l = len ( s ) NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c2 = 0 NEW_LINE c1 = c1 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT c1 = 0 NEW_LINE c2 = c2 + 1 NEW_LINE DEDENT if ( c1 == m or c2 == m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def nextGreatestAlphabet ( alphabets , K ) : NEW_LINE INDENT n = len ( alphabets ) NEW_LINE if ( K >= alphabets [ n - 1 ] ) : NEW_LINE INDENT return alphabets [ 0 ] NEW_LINE DEDENT l = 0 NEW_LINE r = len ( alphabets ) - 1 NEW_LINE ans = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = int ( ( l + r ) / 2 ) NEW_LINE if ( alphabets [ mid ] > K ) : NEW_LINE INDENT r = mid - 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT if ( alphabets [ ans ] < K ) : NEW_LINE INDENT return alphabets [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return alphabets [ ans ] NEW_LINE DEDENT DEDENT
def reverse ( string , start , end ) : NEW_LINE INDENT temp = '' NEW_LINE while start <= end : NEW_LINE INDENT temp = string [ start ] NEW_LINE string [ start ] = string [ end ] NEW_LINE string [ end ] = temp NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT DEDENT
def reverseletter ( string , start , end ) : NEW_LINE INDENT wstart , wend = start , start NEW_LINE while wend < end : NEW_LINE INDENT if string [ wend ] == " " : NEW_LINE INDENT wend += 1 NEW_LINE continue NEW_LINE DEDENT while wend <= end and string [ wend ] != " " : NEW_LINE INDENT wend += 1 NEW_LINE DEDENT wend -= 1 NEW_LINE reverse ( string , wstart , wend ) NEW_LINE wend += 1 NEW_LINE DEDENT DEDENT
def subCount ( arr , n , k ) : NEW_LINE INDENT mod = [ 0 ] * k NEW_LINE cumSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cumSum = cumSum + arr [ i ] NEW_LINE mod [ ( ( cumSum % k ) + k ) % k ] = mod [ ( ( cumSum % k ) + k ) % k ] + 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT if ( mod [ i ] > 1 ) : NEW_LINE INDENT result = result + int ( ( mod [ i ] * ( mod [ i ] - 1 ) ) / 2 ) NEW_LINE DEDENT DEDENT result = result + mod [ 0 ] NEW_LINE return result NEW_LINE DEDENT
def countSubmatrix ( mat , n , k ) : NEW_LINE INDENT tot_count = 0 NEW_LINE temp = [ 0 ] * n NEW_LINE for left in range ( 0 , n - 1 ) : NEW_LINE INDENT for right in range ( left , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT temp [ i ] = ( temp [ i ] + mat [ i ] [ right ] ) NEW_LINE DEDENT tot_count = ( tot_count + subCount ( temp , n , k ) ) NEW_LINE DEDENT DEDENT return tot_count NEW_LINE DEDENT
def matchClosing ( X , start , end , open , close ) : NEW_LINE INDENT c = 1 NEW_LINE i = start + 1 NEW_LINE while ( i <= end ) : NEW_LINE INDENT if ( X [ i ] == open ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( X [ i ] == close ) : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT if ( c == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return i NEW_LINE DEDENT
def matchingOpening ( X , start , end , open , close ) : NEW_LINE INDENT c = - 1 NEW_LINE i = end - 1 NEW_LINE while ( i >= start ) : NEW_LINE INDENT if ( X [ i ] == open ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( X [ i ] == close ) : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT if ( c == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def isBalanced ( X , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( X [ i ] == '(' ) : NEW_LINE INDENT j = matchClosing ( X , i , n - 1 , '(' , ')' ) NEW_LINE DEDENT elif ( X [ i ] == '{' ) : NEW_LINE INDENT j = matchClosing ( X , i , n - 1 , '{' , '}' ) NEW_LINE DEDENT elif ( X [ i ] == '[' ) : NEW_LINE INDENT j = matchClosing ( X , i , n - 1 , '[' , ']' ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( X [ i ] == ')' ) : NEW_LINE INDENT j = matchingOpening ( X , 0 , i , '(' , ')' ) NEW_LINE DEDENT elif ( X [ i ] == '}' ) : NEW_LINE INDENT j = matchingOpening ( X , 0 , i , '{' , '}' ) NEW_LINE DEDENT elif ( X [ i ] == ']' ) : NEW_LINE INDENT j = matchingOpening ( X , 0 , i , '[' , ']' ) NEW_LINE DEDENT if ( j < 0 or j >= i ) : NEW_LINE INDENT return False NEW_LINE DEDENT continue NEW_LINE DEDENT if ( j >= n or j < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT start = i NEW_LINE end = j NEW_LINE for k in range ( start + 1 , end ) : NEW_LINE INDENT if ( X [ k ] == '(' ) : NEW_LINE INDENT x = matchClosing ( X , k , end , '(' , ')' ) NEW_LINE if ( not ( k < x and x < end ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( X [ k ] == ')' ) : NEW_LINE INDENT x = matchingOpening ( X , start , k , '(' , ')' ) NEW_LINE if ( not ( start < x and x < k ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( X [ k ] == '{' ) : NEW_LINE INDENT x = matchClosing ( X , k , end , '{' , '}' ) NEW_LINE if ( not ( k < x and x < end ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( X [ k ] == '}' ) : NEW_LINE INDENT x = matchingOpening ( X , start , k , '{' , '}' ) NEW_LINE if ( not ( start < x and x < k ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( X [ k ] == '[' ) : NEW_LINE INDENT x = matchClosing ( X , k , end , '[' , ']' ) NEW_LINE if ( not ( k < x and x < end ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( X [ k ] == ']' ) : NEW_LINE INDENT x = matchingOpening ( X , start , k , '[' , ']' ) NEW_LINE if ( not ( start < x and x < k ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def possibleToSort ( arr , n , str ) : NEW_LINE INDENT max_element = - 1 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT max_element = max ( max_element , arr [ i ] ) NEW_LINE if ( str [ i ] == '0' ) : NEW_LINE INDENT if ( max_element > i + 1 ) : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT DEDENT return "Yes" NEW_LINE DEDENT
def largestNum ( n ) : NEW_LINE INDENT num = 0 NEW_LINE max_setBits = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT setBits = bin ( i ) . count ( '1' ) NEW_LINE if ( setBits >= max_setBits ) : NEW_LINE INDENT num = i NEW_LINE max_setBits = setBits NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT
def findMinOpeartion ( matrix , n ) : NEW_LINE INDENT sumRow = [ 0 ] * n NEW_LINE sumCol = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sumRow [ i ] += matrix [ i ] [ j ] NEW_LINE sumCol [ j ] += matrix [ i ] [ j ] NEW_LINE DEDENT DEDENT maxSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxSum = max ( maxSum , sumRow [ i ] ) NEW_LINE maxSum = max ( maxSum , sumCol [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < n and j < n : NEW_LINE INDENT diff = min ( maxSum - sumRow [ i ] , maxSum - sumCol [ j ] ) NEW_LINE matrix [ i ] [ j ] += diff NEW_LINE sumRow [ i ] += diff NEW_LINE sumCol [ j ] += diff NEW_LINE count += diff NEW_LINE if ( sumRow [ i ] == maxSum ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( sumCol [ j ] == maxSum ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countPair ( st , n ) : NEW_LINE INDENT cnt = [ 0 ] * ( 1 << 10 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mask = 0 NEW_LINE for j in range ( len ( st [ i ] ) ) : NEW_LINE INDENT mask |= ( 1 << ( ord ( st [ i ] [ j ] ) - ord ( '0' ) ) ) NEW_LINE DEDENT cnt [ mask ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for m1 in range ( 1024 ) : NEW_LINE INDENT for m2 in range ( 1024 ) : NEW_LINE INDENT if ( ( m1 m2 ) == 1023 ) : NEW_LINE INDENT if ( m1 == m2 ) : NEW_LINE INDENT ans += ( cnt [ m1 ] * ( cnt [ m1 ] - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( cnt [ m1 ] * cnt [ m2 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans // 2 NEW_LINE DEDENT
def computeStringCount ( N ) : NEW_LINE INDENT n = N // 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT ans = ( ans + ( ( nCr [ n ] [ i ] * nCr [ n ] [ i // 2 ] ) % mod ) ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 NEW_LINE cntF = 0 NEW_LINE result = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == 'G' ) : NEW_LINE INDENT cntG += 1 NEW_LINE result += C NEW_LINE continue NEW_LINE DEDENT if ( s [ i ] == 'F' ) : NEW_LINE INDENT cntF += 1 NEW_LINE C += cntG NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def find ( n , k ) : NEW_LINE INDENT if ( n + 1 >= k ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * n + 1 - k ) NEW_LINE DEDENT DEDENT
def LexicographicalMaxString ( st ) : NEW_LINE INDENT maxchar = 'a' NEW_LINE index = [ ] NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT if ( st [ i ] >= maxchar ) : NEW_LINE INDENT maxchar = st [ i ] NEW_LINE index . append ( i ) NEW_LINE DEDENT DEDENT maxstring = "" NEW_LINE for i in range ( len ( index ) ) : NEW_LINE INDENT if ( st [ index [ i ] : len ( st ) ] > maxstring ) : NEW_LINE INDENT maxstring = st [ index [ i ] : len ( st ) ] NEW_LINE DEDENT DEDENT return maxstring NEW_LINE DEDENT
def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT
def longestPalin ( str ) : NEW_LINE INDENT str = str + " " NEW_LINE longestword = "" NEW_LINE word = "" NEW_LINE length1 = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ch != ' ' ) : NEW_LINE INDENT word = word + ch NEW_LINE DEDENT else : NEW_LINE INDENT length = len ( word ) NEW_LINE if ( checkPalin ( word ) and length > length1 ) : NEW_LINE INDENT length1 = length NEW_LINE longestword = word NEW_LINE DEDENT word = "" NEW_LINE DEDENT DEDENT return longestword NEW_LINE DEDENT
def isCommonBase ( base , s1 , s2 ) : NEW_LINE INDENT for j in range ( len ( s1 ) ) : NEW_LINE INDENT if ( base [ j % len ( base ) ] != s1 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for j in range ( len ( s2 ) ) : NEW_LINE INDENT if ( base [ j % len ( base ) ] != s2 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countCommonBases ( s1 , s2 ) : NEW_LINE INDENT n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , min ( n1 , n2 ) + 1 ) : NEW_LINE INDENT base = s1 [ 0 : i ] NEW_LINE if ( isCommonBase ( base , s1 , s2 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def isPrimeString ( str1 ) : NEW_LINE INDENT len1 = len ( str1 ) NEW_LINE n = 0 NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT n += ord ( str1 [ i ] ) NEW_LINE DEDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT while ( i * i <= n ) : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def countPalin ( str ) : NEW_LINE INDENT count = 0 NEW_LINE listOfWords = str . split ( " " ) NEW_LINE for elements in listOfWords : NEW_LINE INDENT if ( checkPalin ( elements ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def targetstring ( str1 , str2 ) : NEW_LINE INDENT l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE if ( l1 != l2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT map = [ 0 ] * MAX NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT map [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT map [ ord ( str2 [ i ] ) - ord ( 'a' ) ] -= 1 NEW_LINE if ( map [ ord ( str2 [ i ] ) - ord ( 'a' ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isDigitPresent ( x , d ) : NEW_LINE INDENT while ( x > 0 ) : NEW_LINE INDENT if ( x % 10 == d ) : NEW_LINE INDENT break NEW_LINE DEDENT x = x / 10 NEW_LINE DEDENT return ( x > 0 ) NEW_LINE DEDENT
def printNumbers ( n , d ) : NEW_LINE INDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( i == d or isDigitPresent ( i , d ) ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def printNumbers ( n , d ) : NEW_LINE INDENT st = "" + str ( d ) NEW_LINE ch = st [ 0 ] NEW_LINE for i in range ( 0 , n + 1 , 1 ) : NEW_LINE INDENT st = "" NEW_LINE st = st + str ( i ) NEW_LINE if ( i == d or index ( st , ch ) >= 0 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def findExtraCharcter ( strA , strB ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , len ( strA ) ) : NEW_LINE INDENT res = res ^ ( ord ) ( strA [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( strB ) ) : NEW_LINE INDENT res = res ^ ( ord ) ( strB [ i ] ) NEW_LINE DEDENT return ( ( chr ) ( res ) ) NEW_LINE DEDENT
def findExtraCharacter ( s1 , s2 ) : NEW_LINE INDENT smallStr = "" NEW_LINE largeStr = "" NEW_LINE if ( len ( s1 ) > len ( s2 ) ) : NEW_LINE INDENT smallStr = s2 NEW_LINE largeStr = s1 NEW_LINE DEDENT else : NEW_LINE INDENT smallStr = s1 NEW_LINE largeStr = s2 NEW_LINE DEDENT smallStrCodeTotal = 0 NEW_LINE largeStrCodeTotal = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( smallStr ) ) : NEW_LINE INDENT smallStrCodeTotal += ord ( smallStr [ i ] ) NEW_LINE largeStrCodeTotal += ord ( largeStr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT largeStrCodeTotal += ord ( largeStr [ i ] ) NEW_LINE intChar = largeStrCodeTotal - smallStrCodeTotal NEW_LINE return chr ( intChar ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def countPalinPermutations ( str ) : NEW_LINE INDENT global MAX NEW_LINE n = len ( str ) NEW_LINE freq = [ 0 ] * MAX NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) ] = freq [ ord ( str [ i ] ) ] + 1 NEW_LINE DEDENT res = fact ( int ( n / 2 ) ) NEW_LINE oddFreq = False NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT half = int ( freq [ i ] / 2 ) NEW_LINE if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT if ( oddFreq == True ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT oddFreq = True NEW_LINE DEDENT res = int ( res / fact ( half ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def minChanges ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n > MAX_CHAR [ 0 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE count = [ 0 ] * MAX_CHAR [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( count [ ord ( str [ i ] ) - ord ( 'a' ) ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT count [ ( ord ( str [ i ] ) - ord ( 'a' ) ) ] += 1 NEW_LINE DEDENT return ( n - dist_count ) NEW_LINE DEDENT
def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . c , end = " " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT
def strToBinary ( s ) : NEW_LINE INDENT bin_conv = [ ] NEW_LINE for c in s : NEW_LINE INDENT ascii_val = ord ( c ) NEW_LINE binary_val = bin ( ascii_val ) NEW_LINE bin_conv . append ( binary_val [ 2 : ] ) NEW_LINE DEDENT return ( ' ' . join ( bin_conv ) ) NEW_LINE DEDENT
def numofstring ( n , m ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return m NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return m * ( m - 1 ) NEW_LINE DEDENT return m * ( m - 1 ) * pow ( m - 2 , n - 2 ) NEW_LINE DEDENT
def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = int ( s ) NEW_LINE sum = value NEW_LINE for i in range ( 2 , n , 2 ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == '+' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def FindMaxProduct ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 and ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 and ( j - 1 ) <= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT DEDENT DEDENT return max NEW_LINE DEDENT
def CountSpecialPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE result = 0 NEW_LINE sameChar = [ 0 ] * n NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT sameCharCount = 1 NEW_LINE j = i + 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT sameCharCount += 1 NEW_LINE j += 1 NEW_LINE DEDENT result += int ( sameCharCount * ( sameCharCount + 1 ) / 2 ) NEW_LINE sameChar [ i ] = sameCharCount NEW_LINE i = j NEW_LINE DEDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] ) : NEW_LINE INDENT sameChar [ j ] = sameChar [ j - 1 ] NEW_LINE DEDENT if ( j > 0 and j < ( n - 1 ) and ( str [ j - 1 ] == str [ j + 1 ] and str [ j ] != str [ j - 1 ] ) ) : NEW_LINE INDENT result += ( sameChar [ j - 1 ] if ( sameChar [ j - 1 ] < sameChar [ j + 1 ] ) else sameChar [ j + 1 ] ) NEW_LINE DEDENT DEDENT return result - n NEW_LINE DEDENT
def productAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( tree [ i ] == '(' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ')' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT product *= ( int ( tree [ i ] ) - int ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT return product NEW_LINE DEDENT
def isCornerPresent ( str , corner ) : NEW_LINE INDENT n = len ( str ) NEW_LINE cl = len ( corner ) NEW_LINE if ( n < cl ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( str [ : cl ] == corner ) and ( str [ n - cl : ] == corner ) ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT f = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT f = f * i NEW_LINE DEDENT return f NEW_LINE DEDENT
def calculateTotal ( temp , n ) : NEW_LINE INDENT f = factorial ( n ) NEW_LINE hm = defaultdict ( int ) NEW_LINE for i in range ( len ( temp ) ) : NEW_LINE INDENT hm [ temp [ i ] ] += 1 NEW_LINE DEDENT for e in hm : NEW_LINE INDENT x = hm [ e ] NEW_LINE if ( x > 1 ) : NEW_LINE INDENT temp5 = factorial ( x ) NEW_LINE f //= temp5 NEW_LINE DEDENT return f NEW_LINE DEDENT DEDENT
def nextPermutation ( temp ) : NEW_LINE INDENT for i in range ( len ( temp ) - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( temp [ i ] > temp [ i - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT min = i NEW_LINE x = temp [ i - 1 ] NEW_LINE for j in range ( i + 1 , len ( temp ) ) : NEW_LINE INDENT if ( ( temp [ j ] < temp [ min ] ) and ( temp [ j ] > x ) ) : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT temp [ i - 1 ] , temp [ min ] = ( temp [ min ] , temp [ i - 1 ] ) NEW_LINE temp [ i : ] . sort ( ) NEW_LINE print ( '' . join ( temp ) ) NEW_LINE DEDENT
def countSpecial ( str ) : NEW_LINE INDENT lent = len ( str ) NEW_LINE if lent == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT co = [ ] NEW_LINE vo = [ ] NEW_LINE for i in range ( 0 , lent + 1 ) : NEW_LINE INDENT co . append ( 0 ) NEW_LINE DEDENT for i in range ( 0 , lent + 1 ) : NEW_LINE INDENT vo . append ( 0 ) NEW_LINE DEDENT if isCons ( str [ lent - 1 ] ) == 1 : NEW_LINE INDENT co [ lent - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT vo [ lent - 1 ] = 1 NEW_LINE DEDENT for i in range ( lent - 2 , - 1 , - 1 ) : NEW_LINE INDENT if isCons ( str [ i ] ) == 1 : NEW_LINE INDENT co [ i ] = co [ i + 1 ] + 1 NEW_LINE vo [ i ] = vo [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT co [ i ] = co [ i + 1 ] NEW_LINE vo [ i ] = vo [ i + 1 ] + 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( lent ) : NEW_LINE INDENT if isVowel ( str [ i ] ) : NEW_LINE INDENT ans = ans + co [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + vo [ i + 1 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findSubSequence ( s , num ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while ( num ) : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT res += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT i += 1 NEW_LINE num = num >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def findSubsequence ( stri , k ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len ( stri ) ) : NEW_LINE INDENT a [ ord ( stri [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( stri ) ) : NEW_LINE INDENT if a [ ord ( stri [ i ] ) - ord ( 'a' ) ] >= k : NEW_LINE INDENT print ( stri [ i ] , end = '' ) NEW_LINE DEDENT DEDENT DEDENT
def isConvertible ( str1 , str2 , k ) : NEW_LINE INDENT if ( ( len ( str1 ) + len ( str2 ) ) < k ) : NEW_LINE INDENT return True NEW_LINE DEDENT commonLength = 0 NEW_LINE for i in range ( 0 , min ( len ( str1 ) , len ( str2 ) ) , 1 ) : NEW_LINE INDENT if ( str1 [ i ] == str2 [ i ] ) : NEW_LINE INDENT commonLength += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( ( k - len ( str1 ) - len ( str2 ) + 2 * commonLength ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def maxLower ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] >= 'A' and str [ i ] <= 'Z' : NEW_LINE INDENT i += 1 NEW_LINE break NEW_LINE DEDENT DEDENT maxCount = 0 NEW_LINE count = [ ] NEW_LINE for j in range ( MAX_CHAR ) : NEW_LINE INDENT count . append ( 0 ) NEW_LINE DEDENT for j in range ( i , n ) : NEW_LINE INDENT if str [ j ] >= 'A' and str [ j ] <= 'Z' : NEW_LINE INDENT currCount = 0 NEW_LINE for k in range ( MAX_CHAR ) : NEW_LINE INDENT if count [ k ] > 0 : NEW_LINE INDENT currCount += 1 NEW_LINE DEDENT DEDENT maxCount = max ( maxCount , currCount ) NEW_LINE for y in count : NEW_LINE INDENT y = 0 NEW_LINE DEDENT DEDENT if str [ j ] >= 'a' and str [ j ] <= 'z' : NEW_LINE INDENT count [ ord ( str [ j ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT DEDENT return maxCount NEW_LINE DEDENT
def maxLower ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] >= 'A' and str [ i ] <= 'Z' ) : NEW_LINE INDENT i += 1 NEW_LINE break NEW_LINE DEDENT DEDENT maxCount = 3 NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] >= 'A' and str [ i ] <= 'Z' ) : NEW_LINE INDENT maxCount = max ( maxCount , len ( s ) ) NEW_LINE s . clear ( ) NEW_LINE DEDENT if ( str [ i ] >= 'a' and str [ i ] <= 'z' ) : NEW_LINE INDENT s . add ( str [ i ] ) NEW_LINE return maxCount NEW_LINE DEDENT DEDENT DEDENT
def checkPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT if ( str [ i ] != str [ n - i - 1 ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if ( count <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def minimumflip ( mat , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if mat [ i ] [ j ] != mat [ j ] [ i ] : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return flip NEW_LINE DEDENT
def findLUSlength ( a , b ) : NEW_LINE INDENT map = dict ( ) NEW_LINE strArr = [ ] NEW_LINE strArr . append ( a ) NEW_LINE strArr . append ( b ) NEW_LINE for s in strArr : NEW_LINE INDENT for i in range ( 1 << len ( s ) ) : NEW_LINE INDENT t = "" NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if ( ( ( i >> j ) & 1 ) != 0 ) : NEW_LINE INDENT t += s [ j ] NEW_LINE DEDENT DEDENT if ( t in map . keys ( ) ) : NEW_LINE INDENT map [ t ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT map [ t ] = 1 NEW_LINE DEDENT DEDENT DEDENT res = 0 NEW_LINE for a in map : NEW_LINE INDENT if ( map [ a ] == 1 ) : NEW_LINE INDENT res = max ( res , len ( a ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findLUSlength ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max ( len ( a ) , len ( b ) ) NEW_LINE DEDENT
def convert ( str ) : NEW_LINE INDENT w = "" NEW_LINE z = "" NEW_LINE str = str . upper ( ) + " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ch != ' ' ) : NEW_LINE INDENT w = w + ch NEW_LINE DEDENT else : NEW_LINE INDENT z = ( z + ( w [ 0 ] ) . lower ( ) + w [ 1 : len ( w ) ] + " " ) NEW_LINE w = "" NEW_LINE DEDENT DEDENT return z NEW_LINE DEDENT
def first ( str ) : NEW_LINE INDENT for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . istitle ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * i NEW_LINE DEDENT return ( ans ) NEW_LINE DEDENT
def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 NEW_LINE powerOf2 = 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( ( int ( str [ k ] ) - 0 ) * powerOf2 ) NEW_LINE powerOf2 *= 2 NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def solve ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE x = l // 2 NEW_LINE y = l NEW_LINE p = "" NEW_LINE while ( x > 0 and y > l / 2 ) : NEW_LINE INDENT p = p + s [ x - 1 ] NEW_LINE x = x - 1 NEW_LINE p = p + s [ y - 1 ] NEW_LINE y = y - 1 NEW_LINE DEDENT if ( y > l // 2 ) : NEW_LINE INDENT p = p + s [ y - 1 ] NEW_LINE y = y - 1 NEW_LINE DEDENT print ( p ) NEW_LINE DEDENT
def isConsonant ( ch ) : NEW_LINE INDENT ch = ch . upper ( ) NEW_LINE return not ( ch == 'A' or ch == 'E' or ch == 'I' or ch == 'O' or ch == 'U' ) and ord ( ch ) >= 65 and ord ( ch ) <= 90 NEW_LINE DEDENT
def totalConsonants ( string , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return isConsonant ( string [ 0 ] ) NEW_LINE DEDENT return totalConsonants ( string , n - 1 ) + isConsonant ( string [ n - 1 ] ) NEW_LINE DEDENT
def countSubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE auxArr = [ 0 for i in range ( n ) ] NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT auxArr [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += auxArr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def calSumUtil ( a , b , n , m ) : NEW_LINE INDENT sum = [ 0 ] * n NEW_LINE i = n - 1 NEW_LINE j = m - 1 NEW_LINE k = n - 1 NEW_LINE carry = 0 NEW_LINE s = 0 NEW_LINE while j >= 0 : NEW_LINE INDENT s = a [ i ] + b [ j ] + carry NEW_LINE sum [ k ] = ( s % 10 ) NEW_LINE carry = s // 10 NEW_LINE k -= 1 NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT while i >= 0 : NEW_LINE INDENT s = a [ i ] + carry NEW_LINE sum [ k ] = ( s % 10 ) NEW_LINE carry = s // 10 NEW_LINE i -= 1 NEW_LINE k -= 1 NEW_LINE DEDENT ans = 0 NEW_LINE if carry : NEW_LINE INDENT ans = 10 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT ans += sum [ i ] NEW_LINE ans *= 10 NEW_LINE DEDENT return ans // 10 NEW_LINE DEDENT
def calSum ( a , b , n , m ) : NEW_LINE INDENT if n >= m : NEW_LINE INDENT return calSumUtil ( a , b , n , m ) NEW_LINE DEDENT else : NEW_LINE INDENT return calSumUtil ( b , a , m , n ) NEW_LINE DEDENT DEDENT
def longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) : NEW_LINE INDENT freq1 = [ 0 ] * SIZE NEW_LINE freq2 = [ 0 ] * SIZE NEW_LINE l = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( SIZE ) : NEW_LINE INDENT l += min ( freq1 [ i ] , freq2 [ i ] ) NEW_LINE DEDENT return l NEW_LINE DEDENT
def isPanalphabeticWindow ( s , n ) : NEW_LINE INDENT ch = 'a' NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == ch ) : NEW_LINE INDENT ch = chr ( ord ( ch ) + 1 ) NEW_LINE DEDENT if ( ch == 'z' ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def round ( n ) : NEW_LINE INDENT a = ( n // 10 ) * 10 NEW_LINE b = a + 10 NEW_LINE return ( b if n - a > b - n else a ) NEW_LINE DEDENT
def HalfDiagonalSums ( mat , n ) : NEW_LINE INDENT diag1_left = 0 NEW_LINE diag1_right = 0 NEW_LINE diag2_left = 0 NEW_LINE diag2_right = 0 NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while i < n : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT diag1_left += mat [ i ] [ i ] NEW_LINE diag2_left += mat [ j ] [ i ] NEW_LINE DEDENT elif ( i > n // 2 ) : NEW_LINE INDENT diag1_right += mat [ i ] [ i ] NEW_LINE diag2_right += mat [ j ] [ i ] NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def prime_index ( input ) : NEW_LINE INDENT p = list ( input ) NEW_LINE s = "" NEW_LINE for i in range ( 2 , len ( p ) + 1 ) : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT s = s + input [ i - 1 ] NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT
def isHeterogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != ' ' : NEW_LINE INDENT if hash [ ord ( s [ i ] ) - ord ( 'a' ) ] == 0 : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( 'a' ) ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def ASCIISentence ( str ) : NEW_LINE INDENT for i in str : NEW_LINE INDENT print ( ord ( i ) , end = '' ) NEW_LINE DEDENT print ( '' ,   end   =   '' ) NEW_LINE DEDENT
def preProcess ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE j = 0 NEW_LINE for i in range ( 1 , len ( a ) + 1 ) : NEW_LINE INDENT if j < len ( b ) and a [ i - 1 ] == b [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT fwd [ i ] = j NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( len ( a ) , 0 , - 1 ) : NEW_LINE INDENT if ( j < len ( b ) and a [ i - 1 ] == b [ len ( b ) - j - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT bwd [ i ] = j NEW_LINE DEDENT DEDENT
def findOccurrences ( str , substr ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == substr [ 0 ] ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ j ] == substr [ 1 ] ) : NEW_LINE INDENT for k in range ( j + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ k ] == substr [ 2 ] ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT
def findOccurrences ( str1 , substr ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE preLeft = [ 0 for i in range ( n ) ] NEW_LINE preRight = [ 0 for i in range ( n ) ] NEW_LINE if ( str1 [ 0 ] == substr [ 0 ] ) : NEW_LINE INDENT preLeft [ 0 ] += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( str1 [ i ] == substr [ 0 ] ) : NEW_LINE INDENT preLeft [ i ] = preLeft [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT preLeft [ i ] = preLeft [ i - 1 ] NEW_LINE DEDENT DEDENT if ( str1 [ n - 1 ] == substr [ 2 ] ) : NEW_LINE INDENT preRight [ n - 1 ] += 1 NEW_LINE DEDENT i = n - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( str1 [ i ] == substr [ 2 ] ) : NEW_LINE INDENT preRight [ i ] = preRight [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT preRight [ i ] = preRight [ i + 1 ] NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT counter = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( str1 [ i ] == str1 [ 1 ] ) : NEW_LINE INDENT total = preLeft [ i - 1 ] * preRight [ i + 1 ] NEW_LINE counter += total NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT
def canMakeStr2 ( s1 , s2 ) : NEW_LINE INDENT count = { s1 [ i ] : 0 for i in range ( len ( s1 ) ) } NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT count [ s1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT if ( count . get ( s2 [ i ] ) == None or count [ s2 [ i ] ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT count [ s2 [ i ] ] -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' ) NEW_LINE DEDENT
def finalPosition ( move ) : NEW_LINE INDENT l = len ( move ) NEW_LINE countUp , countDown = 0 , 0 NEW_LINE countLeft , countRight = 0 , 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( move [ i ] == 'U' ) : NEW_LINE INDENT countUp += 1 NEW_LINE DEDENT elif ( move [ i ] == 'D' ) : NEW_LINE INDENT countDown += 1 NEW_LINE DEDENT elif ( move [ i ] == 'L' ) : NEW_LINE INDENT countLeft += 1 NEW_LINE DEDENT elif ( move [ i ] == 'R' ) : NEW_LINE INDENT countRight += 1 NEW_LINE DEDENT DEDENT print ( "Final Position: (" , ( countRight - countLeft ) , ", " , ( countUp - countDown ) , ")" ) NEW_LINE DEDENT
def isIdentity ( mat , N ) : NEW_LINE INDENT for row in range ( N ) : NEW_LINE INDENT for col in range ( N ) : NEW_LINE INDENT if ( row == col and mat [ row ] [ col ] != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( row != col and mat [ row ] [ col ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def maxbalancedprefix ( str , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE maxi = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == '(' : NEW_LINE INDENT _sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT _sum -= 1 NEW_LINE DEDENT if _sum < 0 : NEW_LINE INDENT break NEW_LINE DEDENT if _sum == 0 : NEW_LINE INDENT maxi = i + 1 NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT
def countOccurrences ( str , word ) : NEW_LINE INDENT a = str . split ( " " ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT if ( word == a [ i ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT
def minCost ( s ) : NEW_LINE INDENT alphabets = [ False for i in range ( 26 ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT alphabets [ ord ( s [ i ] ) - 97 ] = True NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( alphabets [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def numberOfDifferentSubstrings ( s , a , b ) : NEW_LINE INDENT ans = 0 NEW_LINE ls = len ( s ) NEW_LINE la = len ( a ) NEW_LINE lb = len ( b ) NEW_LINE x = [ 0 ] * ls NEW_LINE y = [ 0 ] * ls NEW_LINE for i in range ( ls ) : NEW_LINE INDENT if ( s [ i : la + i ] == a ) : NEW_LINE INDENT x [ i ] = 1 NEW_LINE DEDENT if ( s [ i : lb + i ] == b ) : NEW_LINE INDENT y [ i ] = 1 NEW_LINE DEDENT DEDENT hash = [ ] NEW_LINE curr_substr = "" NEW_LINE for i in range ( ls ) : NEW_LINE INDENT if ( x [ i ] ) : NEW_LINE INDENT for j in range ( i , ls ) : NEW_LINE INDENT if ( not y [ j ] ) : NEW_LINE INDENT curr_substr += s [ j ] NEW_LINE DEDENT if ( y [ j ] ) : NEW_LINE INDENT curr_substr += s [ j : lb + j ] NEW_LINE if curr_substr not in hash : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT hash . append ( curr_substr ) NEW_LINE DEDENT DEDENT curr_substr = "" NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countWays ( n , m , k ) : NEW_LINE INDENT mod = 100000007 NEW_LINE if ( k == - 1 and ( ( n + m ) % 2 == 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or m == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( modPower ( modPower ( 2 , n - 1 ) , m - 1 ) % mod ) NEW_LINE DEDENT
def cost ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE res = 0 NEW_LINE j = l - 1 NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( st [ i ] != st [ j ] ) : NEW_LINE INDENT res += ( min ( ord ( st [ i ] ) , ord ( st [ j ] ) ) - ord ( 'a' ) + 1 ) NEW_LINE DEDENT i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def pigLatin ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE index = - 1 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return "-1" NEW_LINE DEDENT return s [ index : ] + s [ 0 : index ] + "ay" NEW_LINE DEDENT
def isValidISBN ( isbn ) : NEW_LINE INDENT if len ( isbn ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT _sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if 0 <= int ( isbn [ i ] ) <= 9 : NEW_LINE INDENT _sum += int ( isbn [ i ] ) * ( 10 - i ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( isbn [ 9 ] != 'X' and 0 <= int ( isbn [ 9 ] ) <= 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT _sum += 10 if isbn [ 9 ] == 'X' else int ( isbn [ 9 ] ) NEW_LINE return ( _sum % 11 == 0 ) NEW_LINE DEDENT
def remainder ( st ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE rem = 0 NEW_LINE for i in range ( 0 , ln ) : NEW_LINE INDENT num = rem * 10 + ( int ) ( st [ i ] ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT
def longestSubseq ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE pre_count_0 = [ 0 for i in range ( n + 2 ) ] NEW_LINE pre_count_1 = [ 0 for i in range ( n + 1 ) ] NEW_LINE post_count_0 = [ 0 for i in range ( n + 2 ) ] NEW_LINE pre_count_0 [ 0 ] = 0 NEW_LINE post_count_0 [ n + 1 ] = 0 NEW_LINE pre_count_1 [ 0 ] = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT pre_count_0 [ j ] = pre_count_0 [ j - 1 ] NEW_LINE pre_count_1 [ j ] = pre_count_1 [ j - 1 ] NEW_LINE post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] NEW_LINE if ( s [ j - 1 ] == '0' ) : NEW_LINE INDENT pre_count_0 [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre_count_1 [ j ] += 1 NEW_LINE DEDENT if ( s [ n - j ] == '0' ) : NEW_LINE INDENT post_count_0 [ n - j + 1 ] += 1 NEW_LINE DEDENT DEDENT if ( pre_count_0 [ n ] == n or pre_count_0 [ n ] == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 , 1 ) : NEW_LINE INDENT ans = max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def removeSpecialCharacter ( s ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if ( ord ( s [ i ] ) < ord ( 'A' ) or ord ( s [ i ] ) > ord ( 'Z' ) and ord ( s [ i ] ) < ord ( 'a' ) or ord ( s [ i ] ) > ord ( 'z' ) ) : NEW_LINE INDENT del s [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( "" . join ( s ) ) NEW_LINE DEDENT
def imageSwap ( mat , n ) : NEW_LINE INDENT row = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE i = row NEW_LINE k = j NEW_LINE while ( i < n and k >= 0 ) : NEW_LINE INDENT s . append ( mat [ i ] [ k ] ) NEW_LINE i += 1 NEW_LINE k -= 1 NEW_LINE DEDENT i = row NEW_LINE k = j NEW_LINE while ( i < n and k >= 0 ) : NEW_LINE INDENT mat [ i ] [ k ] = s [ - 1 ] NEW_LINE k -= 1 NEW_LINE i += 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT column = n - 1 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT s = [ ] NEW_LINE i = j NEW_LINE k = column NEW_LINE while ( i < n and k >= 0 ) : NEW_LINE INDENT s . append ( mat [ i ] [ k ] ) NEW_LINE i += 1 NEW_LINE k -= 1 NEW_LINE DEDENT i = j NEW_LINE k = column NEW_LINE while ( i < n and k >= 0 ) : NEW_LINE INDENT mat [ i ] [ k ] = s [ - 1 ] NEW_LINE i += 1 NEW_LINE k -= 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT DEDENT
def shouldSwap ( string , start , curr ) : NEW_LINE INDENT for i in range ( start , curr ) : NEW_LINE INDENT if string [ i ] == string [ curr ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def decodeMedianString ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s1 = "" NEW_LINE if ( l % 2 == 0 ) : NEW_LINE INDENT isEven = True NEW_LINE DEDENT else : NEW_LINE INDENT isEven = False NEW_LINE DEDENT for i in range ( 0 , l , 2 ) : NEW_LINE INDENT if ( isEven ) : NEW_LINE INDENT s1 = s [ i ] + s1 NEW_LINE s1 += s [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( l - i > 1 ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s1 = s [ i + 1 ] + s1 NEW_LINE DEDENT else : NEW_LINE INDENT s1 += s [ i ] NEW_LINE DEDENT DEDENT DEDENT return s1 NEW_LINE DEDENT
def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def maximumChars ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = - 1 NEW_LINE firstInd = [ - 1 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT first_ind = firstInd [ ord ( str1 [ i ] ) ] NEW_LINE if ( first_ind == - 1 ) : NEW_LINE INDENT firstInd [ ord ( str1 [ i ] ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - first_ind - 1 ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def isUnique ( a , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum += n - 1 NEW_LINE return ( sum == k ) NEW_LINE DEDENT
def imageSwap ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT t = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE mat [ j ] [ i ] = t NEW_LINE DEDENT DEDENT DEDENT
def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ ord ( q [ i ] ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findString ( n , k ) : NEW_LINE INDENT res = "" NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = res + chr ( ord ( 'a' ) + i ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT res = res + chr ( ord ( 'a' ) + count ) NEW_LINE count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def isValid ( p ) : NEW_LINE INDENT n = len ( p ) NEW_LINE c1 = 0 NEW_LINE c0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] == '0' ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT if ( p [ i ] == '1' ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT if ( c0 == c1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def longestSub ( s ) : NEW_LINE INDENT max_len = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( isValid ( s [ i : j - i + 1 ] ) and max_len < j - i + 1 ) : NEW_LINE INDENT max_len = j - i + 1 NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT
def isPalindrome ( s , i , j ) : NEW_LINE INDENT p = j NEW_LINE for k in range ( i , p + 1 ) : NEW_LINE INDENT if ( s [ k ] != s [ p ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT p -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def countWays ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE if ( isPalindrome ( s , 0 , n - 1 ) ) : NEW_LINE INDENT for i in range ( n // 2 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT else : for i in range ( n // 2 ) : if ( s [ i ] != s [ n - 1 - i ] ) : j = n - 1 - i NEW_LINE if ( isPalindrome ( s , i , n - 2 - i ) ) : NEW_LINE INDENT for k in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ k ] != s [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT if ( isPalindrome ( s , i + 1 , n - 1 - i ) ) : NEW_LINE INDENT for k in range ( n - i , n ) : NEW_LINE INDENT if ( s [ k ] != s [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT break NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT
def makeAndCheckString ( words , str ) : NEW_LINE INDENT n = len ( words ) NEW_LINE first = second = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if words [ i ] == str : NEW_LINE INDENT return True NEW_LINE DEDENT if str [ 0 ] == words [ i ] [ 1 ] : NEW_LINE INDENT first = True NEW_LINE DEDENT if str [ 1 ] == words [ i ] [ 0 ] : NEW_LINE INDENT second = True NEW_LINE DEDENT if first and second : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def countOfSubstringWithKOnes ( s , K ) : NEW_LINE INDENT N = len ( s ) NEW_LINE res = 0 NEW_LINE countOfOne = 0 NEW_LINE freq = [ 0 for i in range ( N + 1 ) ] NEW_LINE freq [ 0 ] = 1 NEW_LINE for i in range ( 0 , N , 1 ) : NEW_LINE INDENT countOfOne += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( countOfOne >= K ) : NEW_LINE INDENT res += freq [ countOfOne - K ] NEW_LINE DEDENT freq [ countOfOne ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def printRec ( number , extraOnes , remainingPlaces ) : NEW_LINE INDENT if ( 0 == remainingPlaces ) : NEW_LINE INDENT print ( number , end = " " ) NEW_LINE return NEW_LINE DEDENT printRec ( number + "1" , extraOnes + 1 , remainingPlaces - 1 ) NEW_LINE if ( 0 < extraOnes ) : NEW_LINE INDENT printRec ( number + "0" , extraOnes - 1 , remainingPlaces - 1 ) NEW_LINE DEDENT DEDENT
def printNums ( n ) : NEW_LINE INDENT str = "" NEW_LINE printRec ( str , 0 , n ) NEW_LINE DEDENT
def getBinaryRep ( N , num_of_bits ) : NEW_LINE INDENT r = "" NEW_LINE num_of_bits -= 1 NEW_LINE while ( num_of_bits >= 0 ) : NEW_LINE INDENT if ( N & ( 1 << num_of_bits ) ) : NEW_LINE INDENT r += ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT r += ( "0" ) NEW_LINE DEDENT num_of_bits -= 1 NEW_LINE DEDENT return r NEW_LINE DEDENT
def NBitBinary ( N ) : NEW_LINE INDENT r = [ ] NEW_LINE first = 1 << ( N - 1 ) NEW_LINE last = first * 2 NEW_LINE for i in range ( last - 1 , first - 1 , - 1 ) : NEW_LINE INDENT zero_cnt = 0 NEW_LINE one_cnt = 0 NEW_LINE t = i NEW_LINE num_of_bits = 0 NEW_LINE while ( t ) : NEW_LINE INDENT if ( t & 1 ) : NEW_LINE INDENT one_cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_cnt += 1 NEW_LINE DEDENT num_of_bits += 1 NEW_LINE t = t >> 1 NEW_LINE DEDENT if ( one_cnt >= zero_cnt ) : NEW_LINE INDENT all_prefix_match = True NEW_LINE msk = ( 1 << num_of_bits ) - 2 NEW_LINE prefix_shift = 1 NEW_LINE while ( msk ) : NEW_LINE INDENT prefix = ( ( msk & i ) >> prefix_shift ) NEW_LINE prefix_one_cnt = 0 NEW_LINE prefix_zero_cnt = 0 NEW_LINE while ( prefix ) : NEW_LINE INDENT if ( prefix & 1 ) : NEW_LINE INDENT prefix_one_cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT prefix_zero_cnt += 1 NEW_LINE DEDENT prefix = prefix >> 1 NEW_LINE DEDENT if ( prefix_zero_cnt > prefix_one_cnt ) : NEW_LINE INDENT all_prefix_match = False NEW_LINE break NEW_LINE DEDENT prefix_shift += 1 NEW_LINE msk = msk & ( msk << 1 ) NEW_LINE DEDENT if ( all_prefix_match ) : NEW_LINE INDENT r . append ( getBinaryRep ( i , num_of_bits ) ) NEW_LINE DEDENT DEDENT DEDENT return r NEW_LINE DEDENT
def isPossible ( s1 , s2 ) : NEW_LINE INDENT count = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len ( s2 ) ) : NEW_LINE INDENT count [ ord ( s2 [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( count [ ord ( s1 [ i ] ) ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT count [ ord ( s1 [ i ] ) ] -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def checkLuhn ( cardNo ) : NEW_LINE INDENT nDigits = len ( cardNo ) NEW_LINE nSum = 0 NEW_LINE isSecond = False NEW_LINE for i in range ( nDigits - 1 , - 1 , - 1 ) : NEW_LINE INDENT d = ord ( cardNo [ i ] ) - ord ( '0' ) NEW_LINE if ( isSecond == True ) : NEW_LINE INDENT d = d * 2 NEW_LINE DEDENT nSum += d // 10 NEW_LINE nSum += d % 10 NEW_LINE isSecond = not isSecond NEW_LINE DEDENT if ( nSum % 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def isVowel ( ch ) : NEW_LINE INDENT if ( ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findRepeatFirstN2 ( s ) : NEW_LINE INDENT p = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT p = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( p != - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return p NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' ) NEW_LINE DEDENT
def isVowel ( x ) : NEW_LINE INDENT if ( x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isVowel ( x ) : NEW_LINE INDENT return ( x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' ) NEW_LINE DEDENT
def substrings ( s , k ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for j in range ( i , len ( s ) ) : NEW_LINE INDENT index = ord ( s [ j ] ) - ord ( 'a' ) NEW_LINE freq [ index ] += 1 NEW_LINE if ( freq [ index ] > k ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( freq [ index ] == k and check ( freq , k ) == True ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def longestSubseqWithK ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE freq = [ 0 ] * MAX_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( 'a' ) ] >= k ) : NEW_LINE INDENT print ( str [ i ] , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def canFormPalindrome ( string ) : NEW_LINE INDENT count = [ 0 for i in range ( NO_OF_CHARS ) ] NEW_LINE for i in string : NEW_LINE INDENT count [ ord ( i ) ] += 1 NEW_LINE DEDENT odd = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT if ( odd > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def generate ( st , s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT if s not in st : NEW_LINE INDENT st . add ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT t = list ( s ) . copy ( ) NEW_LINE t . remove ( s [ i ] ) NEW_LINE t = '' . join ( t ) NEW_LINE generate ( st , t ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def countSubstrs ( str , i , j , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ) NEW_LINE if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countManipulations ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE char_count = [ 0 ] * 26 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT char_count [ i ] = 0 NEW_LINE DEDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT char_count [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] -= 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if char_count [ i ] != 0 : NEW_LINE INDENT count += abs ( char_count [ i ] ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def stringPalindrome ( A , B ) : NEW_LINE INDENT countA = [ 0 ] * MAX_CHAR NEW_LINE countB = [ 0 ] * MAX_CHAR NEW_LINE l1 = len ( A ) NEW_LINE l2 = len ( B ) NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT countA [ ord ( A [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT countB [ ord ( B [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( ( countA [ i ] > 1 and countB [ i ] == 0 ) ) : NEW_LINE INDENT return 'A' NEW_LINE DEDENT DEDENT return 'B' NEW_LINE DEDENT
def check ( list , s ) : NEW_LINE INDENT n = len ( list ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( len ( list [ i ] ) != len ( s ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT diff = False NEW_LINE for j in range ( 0 , len ( list [ i ] ) , 1 ) : NEW_LINE INDENT if ( list [ i ] [ j ] != s [ j ] ) : NEW_LINE INDENT if ( diff == False ) : NEW_LINE INDENT diff = True NEW_LINE DEDENT else : NEW_LINE INDENT diff = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( diff ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def FirstRepeated ( string ) : NEW_LINE INDENT checker = 0 NEW_LINE pos = 0 NEW_LINE for i in string : NEW_LINE INDENT val = ord ( i ) - ord ( 'a' ) NEW_LINE if ( ( checker & ( 1 << val ) ) > 0 ) : NEW_LINE INDENT return pos NEW_LINE DEDENT checker |= ( 1 << val ) NEW_LINE pos += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def search ( mat , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < n and j >= 0 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == x ) : NEW_LINE INDENT print ( "n Found at " , i , ", " , j ) NEW_LINE return 1 NEW_LINE DEDENT if ( mat [ i ] [ j ] > x ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( "Element not found" ) NEW_LINE return 0 NEW_LINE DEDENT
def nPermute ( string , n ) : NEW_LINE INDENT precomputeFactorials ( ) NEW_LINE length = len ( string ) NEW_LINE freq = [ 0 ] * ( MAX_CHAR ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT out = [ None ] * ( MAX_CHAR ) NEW_LINE Sum , k = 0 , 0 NEW_LINE while Sum != n : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if freq [ i ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT freq [ i ] -= 1 NEW_LINE xsum = fact [ length - 1 - k ] NEW_LINE for j in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT xsum = xsum // fact [ freq [ j ] ] NEW_LINE DEDENT Sum += xsum NEW_LINE if Sum >= n : NEW_LINE INDENT out [ k ] = chr ( i + ord ( 'a' ) ) NEW_LINE n -= Sum - xsum NEW_LINE k += 1 NEW_LINE break NEW_LINE DEDENT if Sum < n : NEW_LINE INDENT freq [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT i = MAX_CHAR - 1 NEW_LINE while k < length and i >= 0 : NEW_LINE INDENT if freq [ i ] : NEW_LINE INDENT out [ k ] = chr ( i + ord ( 'a' ) ) NEW_LINE freq [ i ] -= 1 NEW_LINE i += 1 NEW_LINE k += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( '' . join ( out [ : k ] ) ) NEW_LINE DEDENT
def sentencePalindrome ( s ) : NEW_LINE INDENT l , h = 0 , len ( s ) - 1 NEW_LINE s = s . lower ( ) NEW_LINE while ( l <= h ) : NEW_LINE INDENT if ( not ( s [ l ] >= 'a' and s [ l ] <= 'z' ) ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif ( not ( s [ h ] >= 'a' and s [ h ] <= 'z' ) ) : NEW_LINE INDENT h -= 1 NEW_LINE DEDENT elif ( s [ l ] == s [ h ] ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def substringConversions ( s , k , b ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ( i + k ) < l + 1 ) : NEW_LINE INDENT sub = s [ i : i + k ] NEW_LINE sum , counter = 0 , 0 NEW_LINE for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) NEW_LINE counter += 1 NEW_LINE DEDENT print ( sum , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def countBalance ( string ) : NEW_LINE INDENT leftVisited = [ 0 ] * ( MAX_CHAR ) NEW_LINE rightVisited = [ 0 ] * ( MAX_CHAR ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT rightVisited [ ord ( string [ i ] ) ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT leftVisited [ ord ( string [ i ] ) ] += 1 NEW_LINE rightVisited [ ord ( string [ i ] ) ] -= 1 NEW_LINE j = 0 NEW_LINE while j < MAX_CHAR : NEW_LINE INDENT if ( ( leftVisited [ j ] == 0 and rightVisited [ j ] != 0 ) or ( leftVisited [ j ] != 0 and rightVisited [ j ] == 0 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == MAX_CHAR : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countWords ( stri , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ stri [ i ] ] = m . get ( stri [ i ] , 0 ) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in m . values ( ) : NEW_LINE INDENT if i == 2 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findFlips ( str , n ) : NEW_LINE INDENT last = ' ' NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( last != str [ i ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT last = str [ i ] NEW_LINE DEDENT return res // 2 NEW_LINE DEDENT
def findLen ( A , n , k , ch ) : NEW_LINE INDENT maxlen = 1 NEW_LINE cnt = 0 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while r < n : NEW_LINE INDENT if A [ r ] != ch : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT while cnt > k : NEW_LINE INDENT if A [ l ] != ch : NEW_LINE INDENT cnt -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT maxlen = max ( maxlen , r - l + 1 ) NEW_LINE r += 1 NEW_LINE DEDENT return maxlen NEW_LINE DEDENT
def answer ( A , n , k ) : NEW_LINE INDENT maxlen = 1 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT maxlen = max ( maxlen , findLen ( A , n , k , chr ( i + ord ( 'A' ) ) ) ) NEW_LINE maxlen = max ( maxlen , findLen ( A , n , k , chr ( i + ord ( 'a' ) ) ) ) NEW_LINE DEDENT return maxlen NEW_LINE DEDENT
def printString ( str , ch , count ) : NEW_LINE INDENT occ , i = 0 , 0 NEW_LINE if ( count == 0 ) : NEW_LINE INDENT print ( str ) NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ch ) : NEW_LINE INDENT occ += 1 NEW_LINE DEDENT if ( occ == count ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i < len ( str ) - 1 ) : NEW_LINE INDENT print ( str [ i + 1 : len ( str ) - i + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Empty string" ) NEW_LINE DEDENT DEDENT
def checkCorrectOrNot ( s ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE n = len ( s ) NEW_LINE if n == 1 : NEW_LINE INDENT return true NEW_LINE DEDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT count1 [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE count2 [ ord ( s [ j ] ) - ord ( 'a' ) ] += 1 NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if count1 [ i ] != count2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def checkCorrectOrNot ( s ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE n = len ( s ) NEW_LINE if n == 1 : NEW_LINE INDENT return true NEW_LINE DEDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while i < j : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE count [ ord ( s [ j ] ) - ord ( 'a' ) ] -= 1 NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if count [ i ] != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def possibleStrings ( n , r , b , g ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT left = n - ( r + g + b ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , left + 1 , 1 ) : NEW_LINE INDENT for j in range ( 0 , left - i + 1 , 1 ) : NEW_LINE INDENT k = left - ( i + j ) NEW_LINE sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def checkString ( s ) : NEW_LINE INDENT Len = len ( s ) NEW_LINE first = len ( s ) + 1 NEW_LINE for i in range ( Len ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT first = i NEW_LINE break NEW_LINE DEDENT DEDENT last = 0 NEW_LINE for i in range ( Len - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT last = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( first , last + 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT if ( c == 'a' or c == 'A' or c == 'e' or c == 'E' or c == 'i' or c == 'I' or c == 'o' or c == 'O' or c == 'u' or c == 'U' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isUnique ( mat , i , j , n , m ) : NEW_LINE INDENT sumrow = 0 NEW_LINE for k in range ( m ) : NEW_LINE INDENT sumrow += mat [ i ] [ k ] NEW_LINE if ( sumrow > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT sumcol = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT sumcol += mat [ k ] [ j ] NEW_LINE if ( sumcol > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findAndPrintUncommonChars ( str1 , str2 ) : NEW_LINE INDENT present = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT present [ i ] = 0 NEW_LINE DEDENT l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE for i in range ( 0 , l1 ) : NEW_LINE INDENT present [ ord ( str1 [ i ] ) - ord ( 'a' ) ] = 1 NEW_LINE DEDENT for i in range ( 0 , l2 ) : NEW_LINE INDENT if ( present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == - 1 ) : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] = 2 NEW_LINE DEDENT DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( present [ i ] == 1 or present [ i ] == 2 ) : NEW_LINE INDENT print ( chr ( i + ord ( 'a' ) ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def countUnique ( mat , n , m ) : NEW_LINE INDENT rowsum = [ 0 ] * n NEW_LINE colsum = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != 0 ) : NEW_LINE INDENT rowsum [ i ] += 1 NEW_LINE colsum [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT uniquecount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 ) : NEW_LINE INDENT uniquecount += 1 NEW_LINE DEDENT DEDENT DEDENT return uniquecount NEW_LINE DEDENT
def lengthOfLastWord ( a ) : NEW_LINE INDENT l = 0 NEW_LINE x = a . strip ( ) NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if x [ i ] == " " : NEW_LINE INDENT l = 0 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT
def isVowel ( ch ) : NEW_LINE INDENT return ch . upper ( ) in [ 'A' , 'E' , 'I' , 'O' , 'U' ] NEW_LINE DEDENT
def countVowels ( str ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if isVowel ( str [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT
def countDistinctPermutations ( st ) : NEW_LINE INDENT length = len ( st ) NEW_LINE freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if ( st [ i ] >= 'a' ) : NEW_LINE INDENT freq [ ( ord ) ( st [ i ] ) - 97 ] = freq [ ( ord ) ( st [ i ] ) - 97 ] + 1 NEW_LINE DEDENT DEDENT fact = 1 NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT fact = fact * factorial ( freq [ i ] ) NEW_LINE DEDENT return factorial ( length ) / fact NEW_LINE DEDENT
def uniqueCharacters ( str ) : NEW_LINE INDENT checker = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT bitAtIndex = ord ( str [ i ] ) - ord ( 'a' ) NEW_LINE if ( ( bitAtIndex ) > 0 ) : NEW_LINE INDENT if ( ( checker & ( ( 1 << bitAtIndex ) ) ) > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = checker | ( 1 << bitAtIndex ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def solve ( i , X , Y , a , b , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( X <= 0 ) : NEW_LINE INDENT return ( b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ) NEW_LINE DEDENT if ( Y <= 0 ) : NEW_LINE INDENT return ( a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) , b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ) NEW_LINE DEDENT DEDENT
def smallest_alphabet ( a , n ) : NEW_LINE INDENT min = 'z' NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] < min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT
def isPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT if ( str [ i ] != str [ n - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def moveSpaceInFront ( s ) : NEW_LINE INDENT i = len ( s ) - 1 NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ j ] != ' ' ) : NEW_LINE INDENT s = swap ( s , i , j ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def moveSpaceInFront ( s ) : NEW_LINE INDENT i = len ( s ) - 1 NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ j ] != ' ' ) : NEW_LINE INDENT s = s [ : i ] + s [ j ] + s [ i + 1 : ] NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT while ( i >= 0 ) : NEW_LINE INDENT s = s [ : i ] + ' ' + s [ i + 1 : ] NEW_LINE i -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def titleToNumber ( s ) : NEW_LINE INDENT result = 0 NEW_LINE for B in range ( len ( s ) ) : NEW_LINE INDENT result *= 26 NEW_LINE result += ord ( s [ B ] ) - ord ( 'A' ) + 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
def isKthBitSet ( n , k ) : NEW_LINE INDENT if n & ( 1 << ( k - 1 ) ) : NEW_LINE INDENT print ( "SET" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NOT SET" ) NEW_LINE DEDENT DEDENT
def isKthBitSet ( n , k ) : NEW_LINE INDENT if ( ( n >> ( k - 1 ) ) and 1 ) : NEW_LINE INDENT print ( "SET" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NOT SET" ) NEW_LINE DEDENT DEDENT
def isPalindrome ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isPalRec ( st , 0 , n - 1 ) NEW_LINE DEDENT
def areSumSame ( a , n , m ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( 0 , m ) : NEW_LINE INDENT sum1 += a [ i ] [ j ] NEW_LINE sum2 += a [ j ] [ i ] NEW_LINE DEDENT if ( sum1 == sum2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def getIdx ( ch ) : NEW_LINE INDENT return ( ord ( ch ) - ord ( 'a' ) ) NEW_LINE DEDENT
def allSame ( freq , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT same = freq [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( freq [ j ] > 0 and freq [ j ] != same ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def possibleSameCharFreqByOneRemoval ( str1 ) : NEW_LINE INDENT l = len ( str1 ) NEW_LINE freq = [ 0 ] * M NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT freq [ getIdx ( str1 [ i ] ) ] += 1 NEW_LINE DEDENT if ( allSame ( freq , M ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT freq [ i ] -= 1 NEW_LINE if ( allSame ( freq , M ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT freq [ i ] += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findIndex ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE open = [ 0 ] * ( l + 1 ) NEW_LINE close = [ 0 ] * ( l + 1 ) NEW_LINE index = - 1 NEW_LINE open [ 0 ] = 0 NEW_LINE close [ l ] = 0 NEW_LINE if ( str [ 0 ] == '(' ) : NEW_LINE INDENT open [ 1 ] = 1 NEW_LINE DEDENT if ( str [ l - 1 ] == ')' ) : NEW_LINE INDENT close [ l - 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , l ) : NEW_LINE INDENT if ( str [ i ] == '(' ) : NEW_LINE INDENT open [ i + 1 ] = open [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT open [ i + 1 ] = open [ i ] NEW_LINE DEDENT DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == ')' ) : NEW_LINE INDENT close [ i ] = close [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT close [ i ] = close [ i + 1 ] NEW_LINE DEDENT DEDENT if ( open [ l ] == 0 ) : NEW_LINE INDENT return len NEW_LINE DEDENT if ( close [ 0 ] == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( l + 1 ) : NEW_LINE INDENT if ( open [ i ] == close [ i ] ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def checkEquality ( s ) : NEW_LINE INDENT return ( ord ( s [ 0 ] ) == ord ( s [ len ( s ) - 1 ] ) ) NEW_LINE DEDENT
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def getValue ( Str , i , m ) : NEW_LINE INDENT if ( i + m > len ( Str ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT value = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT c = ( ord ( Str [ i + j ] ) - ord ( '0' ) ) NEW_LINE if ( c < 0 or c > 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT value = value * 10 + c NEW_LINE DEDENT return value NEW_LINE DEDENT
def findMissingNumber ( Str ) : NEW_LINE INDENT for m in range ( 1 , MAX_DIGITS + 1 ) : NEW_LINE INDENT n = getValue ( Str , 0 , m ) NEW_LINE if ( n == - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT missingNo = - 1 NEW_LINE fail = False NEW_LINE i = m NEW_LINE while ( i != len ( Str ) ) : NEW_LINE INDENT if ( ( missingNo == - 1 ) and ( getValue ( Str , i , 1 + int ( math . log10 ( n + 2 ) ) ) == n + 2 ) ) : NEW_LINE INDENT missingNo = n + 1 NEW_LINE n += 2 NEW_LINE DEDENT elif ( ( getValue ( Str , i , 1 + int ( math . log10 ( n + 1 ) ) ) == n + 1 ) ) : NEW_LINE INDENT n += 1 NEW_LINE DEDENT else : NEW_LINE INDENT fail = True NEW_LINE break NEW_LINE DEDENT i += 1 + int ( math . log10 ( n ) ) NEW_LINE DEDENT if ( not fail ) : NEW_LINE INDENT return missingNo NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def isSmaller ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 < n2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n2 < n1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if ( str1 [ i ] < str2 [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( str1 [ i ] > str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def maxRepeating ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT cur_count = 1 NEW_LINE for j in range ( i + 1 , l ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT cur_count += 1 NEW_LINE DEDENT if cur_count > count : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def isSymmetric ( mat , N ) : NEW_LINE INDENT tr = [ [ 0 for j in range ( len ( mat [ 0 ] ) ) ] for i in range ( len ( mat ) ) ] NEW_LINE transpose ( mat , tr , N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != tr [ i ] [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def maxRepeating ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE cur_count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT cur_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if cur_count > count : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT cur_count = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE oddDigSum = 0 NEW_LINE evenDigSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT evenDigSum = evenDigSum + ( ( int ) ( st [ i ] ) ) NEW_LINE DEDENT DEDENT return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) NEW_LINE DEDENT
def isSubSequence ( str1 , str2 ) : NEW_LINE INDENT m = len ( str1 ) NEW_LINE n = len ( str2 ) NEW_LINE i = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( str1 [ j ] == str2 [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( j == m ) NEW_LINE DEDENT
def isSymmetric ( mat , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def countWords ( str , l ) : NEW_LINE INDENT count = 1 NEW_LINE if ( l == 1 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str [ 0 ] == str [ 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT for j in range ( 1 , l - 1 ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str [ l - 1 ] == str [ l - 2 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
def hammingDist ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE count = 0 NEW_LINE while ( i < len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def replaceDig ( x , from1 , to ) : NEW_LINE INDENT result = 0 NEW_LINE multiply = 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT reminder = x % 10 NEW_LINE if ( reminder == from1 ) : NEW_LINE INDENT result = result + to * multiply NEW_LINE DEDENT else : NEW_LINE INDENT result = result + reminder * multiply NEW_LINE DEDENT multiply *= 10 NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def calculateMinMaxSum ( x1 , x2 ) : NEW_LINE INDENT minSum = replaceDig ( x1 , 6 , 5 ) + replaceDig ( x2 , 6 , 5 ) NEW_LINE maxSum = replaceDig ( x1 , 5 , 6 ) + replaceDig ( x2 , 5 , 6 ) NEW_LINE print ( "Minimum sum =" , minSum ) NEW_LINE print ( "Maximum sum =" , maxSum , end = " " ) NEW_LINE DEDENT
def qType2 ( l , r , str1 ) : NEW_LINE INDENT freq = [ 0 for i in range ( 27 ) ] NEW_LINE for i in range ( l - 1 , r ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT if ( freq [ j ] % 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count <= 1 : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def update ( tree , idx , val , i ) : NEW_LINE INDENT while ( idx <= max ) : NEW_LINE INDENT tree [ idx ] [ i ] += val NEW_LINE idx += ( idx & - idx ) NEW_LINE DEDENT DEDENT
def buildBIT ( tree , str1 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT update ( tree , i + 1 , 1 , ord ( str1 [ i ] ) - 97 + 1 ) NEW_LINE DEDENT DEDENT
def precompute ( mat , str , Len ) : NEW_LINE INDENT for i in range ( CHAR_SIZE ) : NEW_LINE INDENT mat [ Len ] [ i ] = Len NEW_LINE DEDENT for i in range ( Len - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( CHAR_SIZE ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i + 1 ] [ j ] NEW_LINE DEDENT mat [ i ] [ ord ( str [ i ] ) - ord ( 'a' ) ] = i NEW_LINE DEDENT DEDENT
def query ( mat , str , Len ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( mat [ pos ] [ ord ( str [ i ] ) - ord ( 'a' ) ] >= Len ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT pos = mat [ pos ] [ ord ( str [ i ] ) - ord ( 'a' ) ] + 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findTwoscomplement ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT return '1' + str NEW_LINE DEDENT k = i - 1 NEW_LINE while ( k >= 0 ) : NEW_LINE INDENT if ( str [ k ] == '1' ) : NEW_LINE INDENT str = list ( str ) NEW_LINE str [ k ] = '0' NEW_LINE str = '' . join ( str ) NEW_LINE DEDENT else : NEW_LINE INDENT str = list ( str ) NEW_LINE str [ k ] = '1' NEW_LINE str = '' . join ( str ) NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT
def isequal ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE num = 0 NEW_LINE x = 1 NEW_LINE i = n - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( '0' <= str [ i ] and str [ i ] <= '9' ) : NEW_LINE INDENT num = ( ord ( str [ i ] ) - ord ( '0' ) ) * x + num NEW_LINE x = x * 10 NEW_LINE if ( num >= n ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return num == i + 1 NEW_LINE DEDENT
def arekAnagrams ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( len ( str2 ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( count1 [ i ] > count2 [ i ] ) : NEW_LINE INDENT count = count + abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT DEDENT return ( count <= k ) NEW_LINE DEDENT
def areKAnagrams ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( len ( str2 ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT hash_str1 = [ 0 ] * ( MAX_CHAR ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash_str1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash_str1 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] > 0 ) : NEW_LINE INDENT hash_str1 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countToMake0lternate ( s ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT DEDENT
def getDigit ( N , d ) : NEW_LINE INDENT string = str ( N ) NEW_LINE return string [ d - 1 ] NEW_LINE DEDENT
def getNthChar ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE nine = 9 NEW_LINE dist = 0 NEW_LINE for len in range ( 1 , N ) : NEW_LINE INDENT sum += nine * len NEW_LINE dist += nine NEW_LINE if ( sum >= N ) : NEW_LINE INDENT sum -= nine * len NEW_LINE dist -= nine NEW_LINE N -= sum NEW_LINE break NEW_LINE DEDENT nine *= 10 NEW_LINE DEDENT diff = ( N / len ) + 1 NEW_LINE d = N % len NEW_LINE if ( d == 0 ) : NEW_LINE INDENT d = len NEW_LINE DEDENT return getDigit ( dist + diff , d ) NEW_LINE DEDENT
def ispalindrome ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE j = l - 1 NEW_LINE while i <= j : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def findCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ( i == ord ( str [ i ] ) - ord ( 'a' ) ) or ( i == ord ( str [ i ] ) - ord ( 'A' ) ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def sortByPattern ( str , pat ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) - 97 ] += 1 NEW_LINE DEDENT index = 0 NEW_LINE str = "" NEW_LINE for i in range ( 0 , len ( pat ) ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < count [ ord ( pat [ i ] ) - ord ( 'a' ) ] ) : NEW_LINE INDENT str += pat [ i ] NEW_LINE j = j + 1 NEW_LINE index += 1 NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT
def flip ( ch ) : NEW_LINE INDENT return '1' if ( ch == '0' ) else '0' NEW_LINE DEDENT
def getFlipWithStartingCharcter ( str , expected ) : NEW_LINE INDENT flipCount = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] != expected ) : NEW_LINE INDENT flipCount += 1 NEW_LINE DEDENT expected = flip ( expected ) NEW_LINE DEDENT return flipCount NEW_LINE DEDENT
def minFlipToMakeStringAlternate ( str ) : NEW_LINE INDENT return min ( getFlipWithStartingCharcter ( str , '0' ) , getFlipWithStartingCharcter ( str , '1' ) ) NEW_LINE DEDENT
def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * CHARS NEW_LINE count2 = [ 0 ] * CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( str2 ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def isPalin ( str ) : NEW_LINE INDENT l = len ( str ) // 2 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] != str [ len ( str ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def remainderWith7 ( num ) : NEW_LINE INDENT series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] NEW_LINE series_index = 0 NEW_LINE result = 0 NEW_LINE for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT digit = ord ( num [ i ] ) - 48 NEW_LINE result += digit * series [ series_index ] NEW_LINE series_index = ( series_index + 1 ) % 6 NEW_LINE result %= 7 NEW_LINE DEDENT if ( result < 0 ) : NEW_LINE INDENT result = ( result + 7 ) % 7 NEW_LINE DEDENT return result NEW_LINE DEDENT
def checkForVariation ( strr ) : NEW_LINE INDENT if ( len ( strr ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT mapp = { } NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT if strr [ i ] in mapp : NEW_LINE INDENT mapp [ strr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mapp [ strr [ i ] ] = 1 NEW_LINE DEDENT DEDENT first = True NEW_LINE second = True NEW_LINE val1 = 0 NEW_LINE val2 = 0 NEW_LINE countOfVal1 = 0 NEW_LINE countOfVal2 = 0 NEW_LINE for itr in mapp : NEW_LINE INDENT i = itr NEW_LINE if ( first ) : NEW_LINE INDENT val1 = i NEW_LINE first = False NEW_LINE countOfVal1 += 1 NEW_LINE continue NEW_LINE DEDENT if ( i == val1 ) : NEW_LINE INDENT countOfVal1 += 1 NEW_LINE continue NEW_LINE DEDENT if ( second ) : NEW_LINE INDENT val2 = i NEW_LINE countOfVal2 += 1 NEW_LINE second = False NEW_LINE continue NEW_LINE DEDENT if ( i == val2 ) : NEW_LINE INDENT countOfVal2 += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT if ( countOfVal1 > 1 and countOfVal2 > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def waysToPaint ( n ) : NEW_LINE INDENT same = 6 NEW_LINE diff = 6 NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT sameTmp = 3 * same + 2 * diff NEW_LINE diffTmp = 2 * same + 2 * diff NEW_LINE same = sameTmp NEW_LINE diff = diffTmp NEW_LINE DEDENT print ( same + diff ) NEW_LINE DEDENT
def isReversible ( str ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( str ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def findPossibleMoves ( mat , p , q ) : NEW_LINE INDENT global n , m NEW_LINE X = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] NEW_LINE Y = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] NEW_LINE count = 0 NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT x = p + X [ i ] NEW_LINE y = q + Y [ i ] NEW_LINE if ( x >= 0 and y >= 0 and x < n and y < m and mat [ x ] [ y ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countCompletePairs ( set1 , set2 , n , m ) : NEW_LINE INDENT result = 0 NEW_LINE con_s1 , con_s2 = [ 0 ] * n , [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT con_s1 [ i ] = 0 NEW_LINE for j in range ( len ( set1 [ i ] ) ) : NEW_LINE INDENT con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( ord ( set1 [ i ] [ j ] ) - ord ( 'a' ) ) ) NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT con_s2 [ i ] = 0 NEW_LINE for j in range ( len ( set2 [ i ] ) ) : NEW_LINE INDENT con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( ord ( set2 [ i ] [ j ] ) - ord ( 'a' ) ) ) NEW_LINE DEDENT DEDENT complete = ( 1 << 26 ) - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def checkPattern ( Str , pat ) : NEW_LINE INDENT label = [ - 1 ] * CHAR_SIZE NEW_LINE order = 1 NEW_LINE for i in range ( len ( pat ) ) : NEW_LINE INDENT label [ ord ( pat [ i ] ) ] = order NEW_LINE order += 1 NEW_LINE DEDENT last_order = - 1 NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT if ( label [ ord ( Str [ i ] ) ] != - 1 ) : NEW_LINE INDENT if ( label [ ord ( Str [ i ] ) ] < last_order ) : NEW_LINE INDENT return False NEW_LINE DEDENT last_order = label [ ord ( Str [ i ] ) ] NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def encodedChar ( str , k ) : NEW_LINE INDENT expand = "" NEW_LINE i = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( 'a' ) and ord ( str [ i ] ) <= ord ( 'z' ) ) : NEW_LINE INDENT temp += str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( '1' ) and ord ( str [ i ] ) <= ord ( '9' ) ) : NEW_LINE INDENT freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 , 1 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT DEDENT if ( freq == 0 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT
def findMatchedWords ( dict , pattern ) : NEW_LINE INDENT Len = len ( pattern ) NEW_LINE hash = encodeString ( pattern ) NEW_LINE for word in dict : NEW_LINE INDENT if ( len ( word ) == Len and encodeString ( word ) == hash ) : NEW_LINE INDENT print ( word , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def check ( pattern , word ) : NEW_LINE INDENT if ( len ( pattern ) != len ( word ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT ch = [ 0 for i in range ( 128 ) ] NEW_LINE Len = len ( word ) NEW_LINE for i in range ( Len ) : NEW_LINE INDENT if ( ch [ ord ( pattern [ i ] ) ] == 0 ) : NEW_LINE INDENT ch [ ord ( pattern [ i ] ) ] = word [ i ] NEW_LINE DEDENT elif ( ch [ ord ( pattern [ i ] ) ] != word [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findSum ( str1 ) : NEW_LINE INDENT temp = "0" NEW_LINE Sum = 0 NEW_LINE for ch in str1 : NEW_LINE INDENT if ( ch . isdigit ( ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT Sum += int ( temp ) NEW_LINE temp = "0" NEW_LINE DEDENT DEDENT return Sum + int ( temp ) NEW_LINE DEDENT
def countkDist ( str1 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dist_count = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT cnt [ ord ( str1 [ j ] ) - 97 ] += 1 NEW_LINE if ( dist_count == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( dist_count > k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT result = "" NEW_LINE n1 , n2 = len ( str1 ) , len ( str2 ) NEW_LINE i , j = 0 , 0 NEW_LINE while i <= n1 - 1 and j <= n2 - 1 : NEW_LINE INDENT if str1 [ i ] != str2 [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT result += str1 [ i ] NEW_LINE i , j = i + 1 , j + 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
def commonPrefix ( arr , low , high ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if high > low : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE str1 = commonPrefix ( arr , low , mid ) NEW_LINE str2 = commonPrefix ( arr , mid + 1 , high ) NEW_LINE return commonPrefixUtil ( str1 , str2 ) NEW_LINE DEDENT DEDENT
def countTriplets ( A ) : NEW_LINE INDENT cnt = 0 NEW_LINE tuples = { } NEW_LINE for a in A : NEW_LINE INDENT for b in A : NEW_LINE INDENT if ( a & b ) in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 NEW_LINE DEDENT DEDENT DEDENT for a in A : NEW_LINE INDENT for t in tuples : NEW_LINE INDENT if ( ( t & a ) == 0 ) : NEW_LINE INDENT cnt += tuples [ t ] NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def isPalindrome ( str ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( str ) - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ h ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = l + 1 NEW_LINE h = h - 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def flip ( c ) : NEW_LINE INDENT return '1' if ( c == '0' ) else '0' NEW_LINE DEDENT
def zigZagConcat ( s , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return s NEW_LINE DEDENT result = "" NEW_LINE for rowNum in range ( n ) : NEW_LINE INDENT i = rowNum NEW_LINE up = True NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT result += s [ i ] NEW_LINE if ( rowNum == 0 or rowNum == n - 1 ) : NEW_LINE INDENT i += ( 2 * n - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( up ) : NEW_LINE INDENT i += ( 2 * ( n - rowNum ) - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT i += rowNum * 2 NEW_LINE DEDENT up ^= True NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def isEditDistanceOne ( s1 , s2 ) : NEW_LINE INDENT m = len ( s1 ) NEW_LINE n = len ( s2 ) NEW_LINE if abs ( m - n ) > 1 : NEW_LINE INDENT return false NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if s1 [ i ] != s2 [ j ] : NEW_LINE INDENT if count == 1 : NEW_LINE INDENT return false NEW_LINE DEDENT if m > n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif m < n : NEW_LINE INDENT j += 1 NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT count += 1 NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if i < m or j < n : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count == 1 NEW_LINE DEDENT
def countOccurrences ( x , d ) : NEW_LINE INDENT while ( x ) : NEW_LINE INDENT if ( x % 10 == d ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT x = int ( x / 10 ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def maxOccurring ( x ) : NEW_LINE INDENT if ( x < 0 ) : NEW_LINE INDENT x = - x NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT count = countOccurrences ( x , d ) NEW_LINE if ( count >= max_count ) : NEW_LINE INDENT max_count = count NEW_LINE result = d NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def maxSubarrayXOR ( arr , n ) : NEW_LINE INDENT ans = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_xor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_xor = curr_xor ^ arr [ j ] NEW_LINE ans = max ( ans , curr_xor ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def cntNum ( X , i , sum , tight , dp ) : NEW_LINE INDENT if ( i >= len ( X ) or sum < 0 ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ sum ] [ i ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ sum ] [ i ] [ tight ] NEW_LINE DEDENT res , end = 0 , 9 NEW_LINE if tight : NEW_LINE INDENT end = ord ( X [ i ] ) - ord ( '0' ) NEW_LINE DEDENT for j in range ( end + 1 ) : NEW_LINE INDENT res += cntNum ( X , i + 1 , sum - j , ( tight & ( j == end ) ) , dp ) NEW_LINE DEDENT dp [ sum ] [ i ] [ tight ] = res NEW_LINE return res NEW_LINE DEDENT
def UtilCntNumRange ( L , R , Y ) : NEW_LINE INDENT if ( R == 0 and Y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT strr = str ( R ) NEW_LINE dp = [ [ [ - 1 for i in range ( 2 ) ] for i in range ( M ) ] for i in range ( M ) ] NEW_LINE cntR = cntNum ( strr , 0 , Y , True , dp ) NEW_LINE strr = str ( L - 1 ) NEW_LINE cntL = cntNum ( strr , 0 , Y , True , dp ) NEW_LINE return ( cntR - cntL ) NEW_LINE DEDENT
def areIsomorphic ( string1 , string2 ) : NEW_LINE INDENT m = len ( string1 ) NEW_LINE n = len ( string2 ) NEW_LINE if m != n : NEW_LINE INDENT return False NEW_LINE DEDENT marked = [ False ] * MAX_CHARS NEW_LINE map = [ - 1 ] * MAX_CHARS NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT if map [ ord ( string1 [ i ] ) ] == - 1 : NEW_LINE INDENT if marked [ ord ( string2 [ i ] ) ] == True : NEW_LINE INDENT return False NEW_LINE DEDENT marked [ ord ( string2 [ i ] ) ] = True NEW_LINE map [ ord ( string1 [ i ] ) ] = string2 [ i ] NEW_LINE DEDENT elif map [ ord ( string1 [ i ] ) ] != string2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isPalin ( str , st , end ) : NEW_LINE INDENT while ( st < end ) : NEW_LINE INDENT if ( str [ st ] != str [ end ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT st += 1 NEW_LINE end - - 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def findMinInsert ( str , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isPalin ( str , 0 , i ) ) : NEW_LINE INDENT return ( n - i - 1 ) NEW_LINE DEDENT DEDENT DEDENT
def removeRecur ( n ) : NEW_LINE INDENT prev_digit = n % 10 NEW_LINE pow = 10 NEW_LINE res = prev_digit NEW_LINE while ( n ) : NEW_LINE INDENT curr_digit = n % 10 NEW_LINE if ( curr_digit != prev_digit ) : NEW_LINE INDENT res += curr_digit * pow NEW_LINE prev_digit = curr_digit NEW_LINE pow *= 10 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def removeSpaces ( string ) : NEW_LINE INDENT count = 0 NEW_LINE list = [ ] NEW_LINE for i in xrange ( len ( string ) ) : NEW_LINE INDENT if string [ i ] != ' ' : NEW_LINE INDENT list . append ( string [ i ] ) NEW_LINE DEDENT DEDENT return toString ( list ) NEW_LINE DEDENT
def isValid ( count , k ) : NEW_LINE INDENT val = 0 NEW_LINE for i in range ( MAX_CHARS ) : NEW_LINE INDENT if count [ i ] > 0 : NEW_LINE INDENT val += 1 NEW_LINE DEDENT DEDENT return ( k >= val ) NEW_LINE DEDENT
def kUniques ( s , k ) : NEW_LINE INDENT count = [ 0 ] * MAX_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count [ ord ( s [ i ] ) - ord ( 'a' ) ] == 0 : NEW_LINE INDENT u += 1 NEW_LINE DEDENT count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT if u < k : NEW_LINE INDENT print ( "Not enough unique characters" ) NEW_LINE return NEW_LINE DEDENT curr_start = 0 NEW_LINE curr_end = 0 NEW_LINE max_window_size = 1 NEW_LINE max_window_start = 0 NEW_LINE count = [ 0 ] * len ( count ) NEW_LINE count [ ord ( s [ 0 ] ) - ord ( 'a' ) ] += 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE curr_end += 1 NEW_LINE while not isValid ( count , k ) : NEW_LINE INDENT count [ ord ( s [ curr_start ] ) - ord ( 'a' ) ] -= 1 NEW_LINE curr_start += 1 NEW_LINE DEDENT if curr_end - curr_start + 1 > max_window_size : NEW_LINE INDENT max_window_size = curr_end - curr_start + 1 NEW_LINE max_window_start = curr_start NEW_LINE DEDENT DEDENT print ( "Max substring is : " + s [ max_window_start : max_window_start + max_window_size ] + " with length " + str ( max_window_size ) ) NEW_LINE DEDENT
def canFormPalindrome ( st ) : NEW_LINE INDENT count = [ 0 ] * ( NO_OF_CHARS ) NEW_LINE for i in range ( 0 , len ( st ) ) : NEW_LINE INDENT count [ ord ( st [ i ] ) ] = count [ ord ( st [ i ] ) ] + 1 NEW_LINE DEDENT odd = 0 NEW_LINE for i in range ( 0 , NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] & 1 ) : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT if ( odd > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = ord ( number [ i ] ) - ord ( '0' ) NEW_LINE if ( number [ i ] == '9' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = ( sum + ord ( number [ j ] ) - ord ( '0' ) ) % 9 NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT d1 = d1 + arr [ i ] [ i ] NEW_LINE d2 = d2 + arr [ i ] [ n - i - 1 ] NEW_LINE DEDENT return abs ( d1 - d2 ) NEW_LINE DEDENT
def generateGray ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return [ "0" ] NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return [ "0" , "1" ] NEW_LINE DEDENT recAns = generateGray ( n - 1 ) NEW_LINE mainAns = [ ] NEW_LINE for i in range ( len ( recAns ) ) : NEW_LINE INDENT s = recAns [ i ] NEW_LINE mainAns . append ( "0" + s ) NEW_LINE DEDENT for i in range ( len ( recAns ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT s = recAns [ i ] NEW_LINE mainAns . append ( "1" + s ) NEW_LINE DEDENT return mainAns NEW_LINE DEDENT
def areAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * NO_OF_CHARS NEW_LINE count2 = [ 0 ] * NO_OF_CHARS NEW_LINE for i in str1 : NEW_LINE INDENT count1 [ ord ( i ) ] += 1 NEW_LINE DEDENT for i in str2 : NEW_LINE INDENT count2 [ ord ( i ) ] += 1 NEW_LINE DEDENT if len ( str1 ) != len ( str2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in xrange ( NO_OF_CHARS ) : NEW_LINE INDENT if count1 [ i ] != count2 [ i ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def areAnagram ( str1 , str2 ) : NEW_LINE INDENT count = [ 0 for i in range ( NO_OF_CHARS ) ] NEW_LINE i = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE count [ ord ( str2 [ i ] ) - ord ( 'a' ) ] -= 1 NEW_LINE DEDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def longestUniqueSubsttr ( strr ) : NEW_LINE INDENT n = len ( strr ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( areDistinct ( strr , i , j ) ) : NEW_LINE INDENT res = max ( res , j - i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def longestUniqueSubsttr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited = [ 0 ] * 256 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( visited [ ord ( str [ j ] ) ] == True ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , j - i + 1 ) NEW_LINE visited [ ord ( str [ j ] ) ] = True NEW_LINE DEDENT DEDENT visited [ ord ( str [ i ] ) ] = False NEW_LINE DEDENT return res NEW_LINE DEDENT
def spiralFill ( m , n , a ) : NEW_LINE INDENT val = 1 NEW_LINE k , l = 0 , 0 NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT a [ k ] [ i ] = val NEW_LINE val += 1 NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT a [ i ] [ n - 1 ] = val NEW_LINE val += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT a [ m - 1 ] [ i ] = val NEW_LINE val += 1 NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ l ] = val NEW_LINE val += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT
def isValid ( board , i , j , K ) : NEW_LINE INDENT if ( board [ i ] [ j ] <= K ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findPath ( board , X , Y , M , N , K ) : NEW_LINE INDENT if ( X < 0 or X == M or Y < 0 or Y == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( isValid ( board , X , Y , K ) ) : NEW_LINE INDENT board_XY = board [ X ] [ Y ] NEW_LINE board [ X ] [ Y ] = INT_MAX NEW_LINE if ( findPath ( board , X + 1 , Y , M , N , K - board_XY ) or findPath ( board , X - 1 , Y , M , N , K - board_XY ) or findPath ( board , X , Y + 1 , M , N , K - board_XY ) or findPath ( board , X , Y - 1 , M , N , K - board_XY ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT board [ X ] [ Y ] = board_XY NEW_LINE DEDENT return False NEW_LINE DEDENT
def pathMoves ( mat , src , dest ) : NEW_LINE INDENT d = [ [ - 1 for i in range ( 4 ) ] for i in range ( 4 ) ] NEW_LINE d [ src . x ] [ src . y ] = 0 NEW_LINE visited = [ [ False for i in range ( 4 ) ] for i in range ( 4 ) ] NEW_LINE visited [ src . x ] [ src . y ] = True NEW_LINE q = deque ( ) NEW_LINE s = Node ( src , 0 ) NEW_LINE q . append ( s ) NEW_LINE ok = False NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT curr = q . popleft ( ) NEW_LINE pt = curr . pt NEW_LINE if ( pt . x == dest . x and pt . y == dest . y ) : NEW_LINE INDENT xx , yy = pt . x , pt . y NEW_LINE dist = curr . dist NEW_LINE d [ pt . x ] [ pt . y ] = dist NEW_LINE pathmoves = "" NEW_LINE while ( xx != src . x or yy != src . y ) : NEW_LINE INDENT if ( xx > 0 and d [ xx - 1 ] [ yy ] == dist - 1 ) : NEW_LINE INDENT pathmoves += 'D' NEW_LINE xx -= 1 NEW_LINE DEDENT if ( xx < 4 - 1 and d [ xx + 1 ] [ yy ] == dist - 1 ) : NEW_LINE INDENT pathmoves += 'U' NEW_LINE xx += 1 NEW_LINE DEDENT if ( yy > 0 and d [ xx ] [ yy - 1 ] == dist - 1 ) : NEW_LINE INDENT pathmoves += 'R' NEW_LINE yy -= 1 NEW_LINE DEDENT if ( yy < 4 - 1 and d [ xx ] [ yy + 1 ] == dist - 1 ) : NEW_LINE INDENT pathmoves += 'L' NEW_LINE yy += 1 NEW_LINE DEDENT dist -= 1 NEW_LINE DEDENT pathmoves = pathmoves [ : : - 1 ] NEW_LINE print ( pathmoves , end = "" ) NEW_LINE ok = True NEW_LINE break NEW_LINE DEDENT for i in range ( 4 ) : NEW_LINE INDENT row = pt . x + dRow [ i ] NEW_LINE col = pt . y + dCol [ i ] NEW_LINE if ( isValid ( row , col ) and ( mat [ row ] [ col ] == '1' or mat [ row ] [ col ] == 's' or mat [ row ] [ col ] == 'd' ) and ( not visited [ row ] [ col ] ) ) : NEW_LINE INDENT visited [ row ] [ col ] = True NEW_LINE adjCell = Node ( Point ( row , col ) , curr . dist + 1 ) NEW_LINE q . append ( adjCell ) NEW_LINE d [ row ] [ col ] = curr . dist + 1 NEW_LINE DEDENT DEDENT DEDENT if ( not ok ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def isPerfect ( x ) : NEW_LINE INDENT sum_div = 1 NEW_LINE for i in range ( 2 , ( x // 2 ) + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT sum_div += i NEW_LINE DEDENT DEDENT if ( sum_div == x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def isPerfect ( x ) : NEW_LINE INDENT sum_div = 1 NEW_LINE for i in range ( 2 , int ( x / 2 + 1 ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT sum_div = sum_div + i NEW_LINE DEDENT DEDENT if ( sum_div == x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def subsetSum ( arr , n ) : NEW_LINE INDENT total = 1 << n NEW_LINE for i in range ( total ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) != 0 ) : NEW_LINE INDENT sum = sum + arr [ j ] NEW_LINE DEDENT DEDENT if ( isPerfect ( sum ) ) : NEW_LINE INDENT print ( sum , " " ) NEW_LINE DEDENT DEDENT DEDENT
def factorial ( N ) : NEW_LINE INDENT global box1 , box2 , fact NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT DEDENT
def printLevelOrder ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE print ( temp . data , end = " " ) NEW_LINE q = q [ 1 : ] NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT elif ( temp . right != None ) : NEW_LINE INDENT print ( "NULL" , end = " " ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT elif ( temp . left != None ) : NEW_LINE INDENT print ( "NULL" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def PenGame ( N ) : NEW_LINE INDENT P1 = 0 NEW_LINE P2 = 0 NEW_LINE X = 0 NEW_LINE Move = False NEW_LINE QuitP1 = False NEW_LINE QuitP2 = False NEW_LINE solve ( N , P1 , P2 , X , Move , QuitP1 , QuitP2 ) NEW_LINE DEDENT
def findTrace ( mat , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += mat [ i ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def checkUntil ( num , K , N , ans ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT ans . append ( num ) NEW_LINE return NEW_LINE DEDENT if ( ( num % 10 + K ) <= 9 ) : NEW_LINE INDENT checkUntil ( 10 * num + ( num % 10 + K ) , K , N - 1 , ans ) NEW_LINE DEDENT if ( K ) : NEW_LINE INDENT if ( ( num % 10 - K ) >= 0 ) : NEW_LINE INDENT checkUntil ( 10 * num + num % 10 - K , K , N - 1 , ans ) NEW_LINE DEDENT DEDENT DEDENT
def check ( K , N , ans ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT checkUntil ( i , K , N , ans ) NEW_LINE DEDENT DEDENT
def comb ( arr , Len , r , ipos , op , opos , Sum ) : NEW_LINE INDENT if ( opos == r ) : NEW_LINE INDENT sum2 = 0 NEW_LINE for i in range ( opos ) : NEW_LINE INDENT sum2 = sum2 + op [ i ] NEW_LINE DEDENT if ( Sum == sum2 ) : NEW_LINE INDENT for i in range ( opos ) : NEW_LINE INDENT print ( op [ i ] , end = ", " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT return NEW_LINE DEDENT if ( ipos < Len ) : NEW_LINE INDENT comb ( arr , Len , r , ipos + 1 , op , opos , Sum ) NEW_LINE op [ opos ] = arr [ ipos ] NEW_LINE comb ( arr , Len , r , ipos + 1 , op , opos + 1 , Sum ) NEW_LINE DEDENT DEDENT
def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= p_size ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def primeCliques ( i , l , prime ) : NEW_LINE INDENT global ans NEW_LINE for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT store [ l ] = j NEW_LINE if ( is_clique ( l + 1 ) ) : NEW_LINE INDENT if ( prime [ l ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT primeCliques ( j , l + 1 , prime ) NEW_LINE DEDENT DEDENT DEDENT
def countWays ( mtrx , vrtx , i , dest , visited ) : NEW_LINE INDENT if ( i == dest ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT total = 0 NEW_LINE for j in range ( vrtx ) : NEW_LINE INDENT if ( mtrx [ i ] [ j ] == 1 and not visited [ j ] ) : NEW_LINE INDENT visited [ j ] = True NEW_LINE total += countWays ( mtrx , vrtx , j , dest , visited ) NEW_LINE visited [ j ] = False NEW_LINE DEDENT DEDENT return total NEW_LINE DEDENT
def totalWays ( mtrx , vrtx , src , dest ) : NEW_LINE INDENT visited = [ False ] * vrtx NEW_LINE for i in range ( vrtx ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT visited [ src ] = True NEW_LINE return countWays ( mtrx , vrtx , src , dest , visited ) NEW_LINE DEDENT
def minOperation ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE for k in range ( i + 1 ) : NEW_LINE INDENT for h in range ( j + 1 ) : NEW_LINE INDENT if ( arr [ k ] [ h ] == 1 ) : NEW_LINE INDENT arr [ k ] [ h ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] [ h ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def find_x ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT num = math . log10 ( n ) NEW_LINE x , no = 0 , 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT den = math . log10 ( i ) NEW_LINE p = num / den NEW_LINE no = int ( pow ( i , int ( p ) ) ) NEW_LINE if abs ( no - n ) < 1e-6 : NEW_LINE INDENT x = i NEW_LINE break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def is_key ( n , x ) : NEW_LINE INDENT p = math . log10 ( n ) / math . log10 ( x ) NEW_LINE no = int ( pow ( x , int ( p ) ) ) NEW_LINE if n == no : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def evenPaths ( node , count , x ) : NEW_LINE INDENT if node == None or not is_key ( node . key , x ) : NEW_LINE INDENT return count NEW_LINE DEDENT if node . left == None and node . right == None : NEW_LINE INDENT count += 1 NEW_LINE DEDENT count = evenPaths ( node . left , count , x ) NEW_LINE return evenPaths ( node . right , count , x ) NEW_LINE DEDENT
def dfs ( a , b , v , vis ) : NEW_LINE INDENT global c NEW_LINE vis [ a ] = 1 NEW_LINE c += 1 NEW_LINE for i in v [ a ] : NEW_LINE INDENT if ( vis [ i ] == 0 and i != b ) : NEW_LINE INDENT dfs ( i , b , v , vis ) NEW_LINE DEDENT DEDENT DEDENT
def printExistPath ( sx , sy , last ) : NEW_LINE INDENT if ( len ( sx ) == 0 or len ( sy ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT x = sx [ - 1 ] NEW_LINE y = sy [ - 1 ] NEW_LINE sx . pop ( ) NEW_LINE sy . pop ( ) NEW_LINE printExistPath ( sx , sy , last ) NEW_LINE if ( len ( sx ) == last - 1 ) : NEW_LINE INDENT print ( "(" + str ( x ) + ", " + str ( y ) + ")" , end = '' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "(" + str ( x ) + ", " + str ( y ) + ") -> " , end = '' ) NEW_LINE DEDENT DEDENT
def storePath ( srcX , srcY , destX , destY , sx , sy ) : NEW_LINE INDENT if ( srcX > destX or srcY > destY ) : NEW_LINE INDENT return False NEW_LINE DEDENT sx . append ( srcX ) NEW_LINE sy . append ( srcY ) NEW_LINE if ( srcX == destX and srcY == destY ) : NEW_LINE INDENT printExistPath ( sx , sy , len ( sx ) ) NEW_LINE return True NEW_LINE DEDENT if ( storePath ( ( 2 * srcX ) + srcY , srcY , destX , destY , sx , sy ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( storePath ( srcX , ( 2 * srcY ) + srcX , destX , destY , sx , sy ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT sx . pop ( ) NEW_LINE sy . pop ( ) NEW_LINE return False NEW_LINE DEDENT
def isPathExist ( srcX , srcY , destX , destY ) : NEW_LINE INDENT sx = [ ] NEW_LINE sy = [ ] NEW_LINE return storePath ( srcX , srcY , destX , destY , sx , sy ) NEW_LINE DEDENT
def printPath ( srcX , srcY , destX , destY ) : NEW_LINE INDENT if ( not isPathExist ( srcX , srcY , destX , destY ) ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def dfs ( v ) : NEW_LINE INDENT col [ v ] = 1 NEW_LINE for p in g [ v ] : NEW_LINE INDENT to = p [ 0 ] NEW_LINE id = p [ 1 ] NEW_LINE if ( col [ to ] == 0 ) : NEW_LINE INDENT dfs ( to ) NEW_LINE res [ id ] = 1 NEW_LINE DEDENT elif ( col [ to ] == 2 ) : NEW_LINE INDENT res [ id ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT res [ id ] = 2 NEW_LINE cyc = True NEW_LINE DEDENT DEDENT col [ v ] = 2 NEW_LINE DEDENT
def sumSubsets ( sets , n , target ) : NEW_LINE INDENT x = [ 0 ] * len ( sets ) NEW_LINE j = len ( sets ) - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT x [ j ] = n % 2 NEW_LINE n = n // 2 NEW_LINE j -= 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( len ( sets ) ) : NEW_LINE INDENT if ( x [ i ] == 1 ) : NEW_LINE INDENT sum += sets [ i ] NEW_LINE DEDENT DEDENT if ( sum == target ) : NEW_LINE INDENT print ( "{" , end = "" ) NEW_LINE for i in range ( len ( sets ) ) : NEW_LINE INDENT if ( x [ i ] == 1 ) : NEW_LINE INDENT print ( sets [ i ] , end = ", " ) NEW_LINE DEDENT DEDENT print ( "}, " , end = "" ) NEW_LINE DEDENT DEDENT
def findSubsets ( arr , K ) : NEW_LINE INDENT x = pow ( 2 , len ( arr ) ) NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT sumSubsets ( arr , i , K ) NEW_LINE DEDENT DEDENT
def ncr ( n , r ) : NEW_LINE INDENT return ( fact [ n ] // fact [ r ] ) // fact [ n - r ] NEW_LINE DEDENT
def findSum ( arr , n ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT mul = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mul += ( 2 ** i ) * ncr ( n - 1 , i ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += mul * arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT path = 1 NEW_LINE for i in range ( n , m + n - 1 ) : NEW_LINE INDENT path *= i NEW_LINE path //= ( i - n + 1 ) NEW_LINE DEDENT return path NEW_LINE DEDENT
def solve ( maze ) : NEW_LINE INDENT ans = ( numberOfPaths ( R , C ) - countPaths ( maze ) ) NEW_LINE return ans NEW_LINE DEDENT
def dfs1 ( u , count ) : NEW_LINE INDENT visited [ u ] = True NEW_LINE temp = 0 NEW_LINE global endnode , maxi NEW_LINE for i in range ( 0 , len ( adjacent [ u ] ) ) : NEW_LINE INDENT if not visited [ adjacent [ u ] [ i ] ] : NEW_LINE INDENT temp += 1 NEW_LINE parent [ adjacent [ u ] [ i ] ] = u NEW_LINE dfs1 ( adjacent [ u ] [ i ] , count + 1 ) NEW_LINE DEDENT DEDENT if temp == 0 : NEW_LINE INDENT if maxi < count : NEW_LINE INDENT maxi = count NEW_LINE endnode = u NEW_LINE DEDENT DEDENT DEDENT
def dfs2 ( u , count ) : NEW_LINE INDENT visited [ u ] = True NEW_LINE temp = 0 NEW_LINE global thirdnode , maxi NEW_LINE for i in range ( 0 , len ( adjacent [ u ] ) ) : NEW_LINE INDENT if ( not visited [ adjacent [ u ] [ i ] ] and not vis [ adjacent [ u ] [ i ] ] ) : NEW_LINE INDENT temp += 1 NEW_LINE dfs2 ( adjacent [ u ] [ i ] , count + 1 ) NEW_LINE DEDENT DEDENT if temp == 0 : NEW_LINE INDENT if maxi < count : NEW_LINE INDENT maxi = count NEW_LINE thirdnode = u NEW_LINE DEDENT DEDENT DEDENT
def findNodes ( ) : NEW_LINE INDENT dfs ( 1 , 0 ) NEW_LINE global maxi NEW_LINE for i in range ( 0 , N + 1 ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT maxi = - 1 NEW_LINE dfs1 ( startnode , 0 ) NEW_LINE for i in range ( 0 , N + 1 ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT x = endnode NEW_LINE vis [ startnode ] = True NEW_LINE while x != startnode : NEW_LINE INDENT vis [ x ] = True NEW_LINE x = parent [ x ] NEW_LINE DEDENT maxi = - 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if vis [ i ] : NEW_LINE INDENT dfs2 ( i , 0 ) NEW_LINE DEDENT DEDENT DEDENT
def dfsUtil ( u , node , visited , road_used , parent , it ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( node ) : NEW_LINE INDENT if ( visited [ i ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( c == node ) : NEW_LINE INDENT return NEW_LINE DEDENT visited [ u ] = True NEW_LINE road_used . append ( [ parent , u ] ) NEW_LINE print ( u , end = " " ) NEW_LINE for x in adj [ u ] : NEW_LINE INDENT if ( not visited [ x ] ) : NEW_LINE INDENT dfsUtil ( x , node , visited , road_used , u , it + 1 ) NEW_LINE DEDENT DEDENT for y in road_used : NEW_LINE INDENT if ( y [ 1 ] == u ) : NEW_LINE INDENT dfsUtil ( y [ 0 ] , node , visited , road_used , u , it + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def dfs ( node ) : NEW_LINE INDENT visited = [ False for i in range ( node ) ] NEW_LINE road_used = [ ] NEW_LINE for i in range ( node ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT dfsUtil ( 0 , node , visited , road_used , - 1 , 0 ) NEW_LINE DEDENT
def primeSum ( total , N , S , index ) : NEW_LINE INDENT global set , prime NEW_LINE if ( total == S and len ( set ) == N ) : NEW_LINE INDENT display ( ) NEW_LINE return NEW_LINE DEDENT if ( total > S or index == len ( prime ) ) : NEW_LINE INDENT return NEW_LINE DEDENT set . append ( prime [ index ] ) NEW_LINE primeSum ( total + prime [ index ] , N , S , index + 1 ) NEW_LINE set . pop ( ) NEW_LINE primeSum ( total , N , S , index + 1 ) NEW_LINE DEDENT
def allPrime ( N , S , P ) : NEW_LINE INDENT global set , prime NEW_LINE for i in range ( P + 1 , S + 1 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT prime . append ( i ) NEW_LINE DEDENT DEDENT if ( len ( prime ) < N ) : NEW_LINE INDENT return NEW_LINE DEDENT primeSum ( 0 , N , S , 0 ) NEW_LINE DEDENT
def grayCodes ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE num = [ 0 ] NEW_LINE grayCodeUtil ( res , n , num ) NEW_LINE return res NEW_LINE DEDENT
def isParenthesis ( c ) : NEW_LINE INDENT return ( ( c == '(' ) or ( c == ')' ) ) NEW_LINE DEDENT
def isValidString ( str ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '(' ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif ( str [ i ] == ')' ) : NEW_LINE INDENT cnt -= 1 NEW_LINE DEDENT if ( cnt < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return ( cnt == 0 ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if temp < n : NEW_LINE INDENT temp = i - 1 NEW_LINE num = 1 NEW_LINE while temp < n : NEW_LINE INDENT if temp + i <= n : NEW_LINE INDENT ans += i * num NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( n - temp ) * num NEW_LINE DEDENT temp += i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def isSafe ( grid , row , col , num ) : NEW_LINE INDENT for x in range ( 9 ) : NEW_LINE INDENT if grid [ row ] [ x ] == num : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for x in range ( 9 ) : NEW_LINE INDENT if grid [ x ] [ col ] == num : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT startRow = row - row % 3 NEW_LINE startCol = col - col % 3 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if grid [ i + startRow ] [ j + startCol ] == num : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def solveSuduko ( grid , row , col ) : NEW_LINE INDENT if ( row == N - 1 and col == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT if col == N : NEW_LINE INDENT row += 1 NEW_LINE col = 0 NEW_LINE DEDENT if grid [ row ] [ col ] > 0 : NEW_LINE INDENT return solveSuduko ( grid , row , col + 1 ) NEW_LINE DEDENT for num in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT if isSafe ( grid , row , col , num ) : NEW_LINE INDENT grid [ row ] [ col ] = num NEW_LINE if solveSuduko ( grid , row , col + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT grid [ row ] [ col ] = 0 NEW_LINE DEDENT return False NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def remainder ( n , a , p ) : NEW_LINE INDENT len1 = fact ( n ) NEW_LINE ans = 1 NEW_LINE for i in range ( 1 , len1 + 1 , 1 ) : NEW_LINE INDENT ans = ( ans * a ) % p NEW_LINE DEDENT return ans NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def remainder ( n , a , p ) : NEW_LINE INDENT ans = a % p NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = power ( ans , i , p ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def check ( n , w ) : NEW_LINE INDENT a = [ 0 for i in range ( 105 ) ] NEW_LINE p = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a [ p ] = n % w NEW_LINE p += 1 NEW_LINE n //= w NEW_LINE DEDENT flag = True NEW_LINE for i in range ( 101 ) : NEW_LINE INDENT if ( a [ i ] == 0 or a [ i ] == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( a [ i ] == w or a [ i ] == w - 1 ) : NEW_LINE INDENT a [ i + 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT
def numPairs ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT index = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( 2 * a [ i ] >= a [ j - 1 ] and 2 * a [ i ] < a [ j ] ) : NEW_LINE INDENT index = j NEW_LINE DEDENT DEDENT if index == 0 : NEW_LINE INDENT index = n NEW_LINE DEDENT ans += index - i - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def exponentMod ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT y = 0 NEW_LINE if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponentMod ( A , B // 2 ) NEW_LINE y = ( y * y ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT y = A % mod NEW_LINE y = ( y * exponentMod ( A , B - 1 ) % mod ) % mod NEW_LINE DEDENT return ( ( y + mod ) % mod ) NEW_LINE DEDENT
def countWays ( N ) : NEW_LINE INDENT select = exponentMod ( 2 , N - 1 ) NEW_LINE ways = ( ( N % mod ) * ( select % mod ) ) NEW_LINE ways %= mod NEW_LINE print ( ways ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def MaxUtil ( st , ss , se , l , r , node ) : NEW_LINE INDENT if ( l <= ss and r >= se ) : NEW_LINE INDENT return st [ node ] NEW_LINE DEDENT if ( se < l or ss > r ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE return max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) NEW_LINE DEDENT
def count ( arr , low , high , x ) : NEW_LINE INDENT if ( ( low > high ) or ( low == high and arr [ low ] != x ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( low == high and arr [ low ] == x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return count ( arr , low , ( low + high ) // 2 , x ) + count ( arr , 1 + ( low + high ) // 2 , high , x ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT
def matrix_product ( a , b ) : NEW_LINE INDENT c = np . zeros ( ( 7 , 7 ) ) NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT for j in range ( 7 ) : NEW_LINE INDENT for k in range ( 7 ) : NEW_LINE INDENT c [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT
def mul_expo ( mul , p ) : NEW_LINE INDENT s = [ [ 1 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 1 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 1 ] ] NEW_LINE while ( p != 1 ) : NEW_LINE INDENT if ( p % 2 == 1 ) : NEW_LINE INDENT s = matrix_product ( s , mul ) NEW_LINE DEDENT mul = matrix_product ( mul , mul ) NEW_LINE p //= 2 NEW_LINE DEDENT return matrix_product ( mul , s ) NEW_LINE DEDENT
def expectedSteps ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( x <= 6 ) : NEW_LINE INDENT return 6 NEW_LINE DEDENT mul = [ [ 7 / 6 , 1 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 1 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 1 ] , [ - 1 / 6 , 0 , 0 , 0 , 0 , 0 , 0 ] ] NEW_LINE mul = mul_expo ( mul , x - 6 ) NEW_LINE return ( mul [ 0 ] [ 0 ] + mul [ 1 ] [ 0 ] + mul [ 2 ] [ 0 ] + mul [ 3 ] [ 0 ] + mul [ 4 ] [ 0 ] + mul [ 5 ] [ 0 ] ) * 6 NEW_LINE DEDENT
def maxDistance ( cell , n , p ) : NEW_LINE INDENT cell = sorted ( cell ) NEW_LINE start = 0 NEW_LINE end = cell [ n - 1 ] - cell [ 0 ] NEW_LINE ans = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( ( end - start ) // 2 ) NEW_LINE if ( canPlace ( cell , n , p , mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT low = 1 NEW_LINE high = 10 ** 4 NEW_LINE x , p = n , 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE sum = ( mid * ( mid + 1 ) ) // 2 NEW_LINE if ( x - sum >= 1 ) : NEW_LINE INDENT p = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT start , end , y , q = 1 , 10 ** 4 , 1 , 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE sum = ( mid * ( mid + 1 ) ) // 2 NEW_LINE if ( y + sum <= n ) : NEW_LINE INDENT q = mid NEW_LINE start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT x = x - ( p * ( p + 1 ) ) // 2 NEW_LINE y = y + ( q * ( q + 1 ) ) // 2 NEW_LINE r = x NEW_LINE c = q + 1 - n + y NEW_LINE return r , c NEW_LINE DEDENT
def build ( l , r , inn , arr ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT seg [ inn ] = arr [ l ] NEW_LINE return seg [ inn ] NEW_LINE DEDENT mid = ( l + r ) // 2 NEW_LINE seg [ inn ] = __gcd ( build ( l , mid , 2 * inn + 1 , arr ) , build ( mid + 1 , r , 2 * inn + 2 , arr ) ) NEW_LINE return seg [ inn ] NEW_LINE DEDENT
def query ( l , r , l1 , r1 , inn ) : NEW_LINE INDENT if ( l1 <= l and r <= r1 ) : NEW_LINE INDENT return seg [ inn ] NEW_LINE DEDENT if ( l > r1 or r < l1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT mid = ( l + r ) // 2 NEW_LINE x = __gcd ( query ( l , mid , l1 , r1 , 2 * inn + 1 ) , query ( mid + 1 , r , l1 , r1 , 2 * inn + 2 ) ) NEW_LINE return x NEW_LINE DEDENT
def findLen ( arr , n ) : NEW_LINE INDENT build ( 0 , n - 1 , 0 , arr ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE ans = 10 ** 9 NEW_LINE while ( i < n ) : NEW_LINE INDENT while ( j < n and query ( 0 , n - 1 , i , j , 0 ) != 1 ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = minn ( ( j - i + 1 ) , ans ) NEW_LINE i += 1 NEW_LINE j = max ( j , i ) NEW_LINE DEDENT if ( ans == 10 ** 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT
def mergeSort ( arr , array_size ) : NEW_LINE INDENT temp = [ 0 for i in range ( array_size ) ] NEW_LINE return _mergeSort ( arr , temp , 0 , array_size - 1 ) NEW_LINE DEDENT
def merge ( arr , temp , left , mid , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE i = left NEW_LINE j = mid NEW_LINE k = left NEW_LINE while ( ( i <= mid - 1 ) and ( j <= right ) ) : NEW_LINE INDENT if ( arr [ i ] > 2 * arr [ j ] ) : NEW_LINE INDENT inv_count += ( mid - i ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT i = left NEW_LINE j = mid NEW_LINE k = left NEW_LINE while ( ( i <= mid - 1 ) and ( j <= right ) ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ j ] ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE i , k = i + 1 , k + 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k , j = k + 1 , j + 1 NEW_LINE DEDENT DEDENT while ( i <= mid - 1 ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE i , k = i + 1 , k + 1 NEW_LINE DEDENT while ( j <= right ) : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE j , k = j + 1 , k + 1 NEW_LINE DEDENT for i in range ( left , right + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return inv_count NEW_LINE DEDENT
def findGrid ( n ) : NEW_LINE INDENT arr = [ [ 0 for k in range ( n ) ] for l in range ( n ) ] NEW_LINE x = 0 NEW_LINE for i in range ( n // 4 ) : NEW_LINE INDENT for j in range ( n // 4 ) : NEW_LINE INDENT for k in range ( 4 ) : NEW_LINE INDENT for l in range ( 4 ) : NEW_LINE INDENT arr [ i * 4 + k ] [ j * 4 + l ] = x NEW_LINE x += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def buildTree ( l , r , i , arr ) : NEW_LINE INDENT global segtree NEW_LINE global maxLen NEW_LINE if ( l == r ) : NEW_LINE INDENT segtree [ i ] = l NEW_LINE return l NEW_LINE DEDENT l1 = buildTree ( l , int ( ( l + r ) / 2 ) , 2 * i + 1 , arr ) NEW_LINE r1 = buildTree ( int ( ( l + r ) / 2 ) + 1 , r , 2 * i + 2 , arr ) NEW_LINE if ( arr [ l1 ] > arr [ r1 ] ) : NEW_LINE INDENT segtree [ i ] = l1 NEW_LINE DEDENT else : NEW_LINE INDENT segtree [ i ] = r1 NEW_LINE DEDENT return segtree [ i ] NEW_LINE DEDENT
def rangeMax ( l , r , rl , rr , i , arr ) : NEW_LINE INDENT global segtree NEW_LINE global maxLen NEW_LINE if ( r < rl or l > rr ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( l >= rl and r <= rr ) : NEW_LINE INDENT return segtree [ i ] NEW_LINE DEDENT l1 = rangeMax ( l , int ( ( l + r ) / 2 ) , rl , rr , 2 * i + 1 , arr ) NEW_LINE r1 = rangeMax ( int ( ( l + r ) / 2 ) + 1 , r , rl , rr , 2 * i + 2 , arr ) NEW_LINE if ( l1 == - 1 ) : NEW_LINE INDENT return r1 NEW_LINE DEDENT if ( r1 == - 1 ) : NEW_LINE INDENT return l1 NEW_LINE DEDENT if ( arr [ l1 ] > arr [ r1 ] ) : NEW_LINE INDENT return l1 NEW_LINE DEDENT else : NEW_LINE INDENT return r1 NEW_LINE DEDENT DEDENT
def inorder ( curr ) : NEW_LINE INDENT if ( curr == None ) : NEW_LINE INDENT return NEW_LINE DEDENT inorder ( curr . left ) NEW_LINE print ( curr . data , end = " " ) NEW_LINE inorder ( curr . right ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return int ( sum ) NEW_LINE DEDENT
def kthSmallest ( arr , k , n ) : NEW_LINE INDENT low = min ( arr ) NEW_LINE high = max ( arr ) NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE countless = 0 NEW_LINE countequal = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < mid ) : NEW_LINE INDENT countless += 1 NEW_LINE DEDENT elif ( arr [ i ] == mid ) : NEW_LINE INDENT countequal += 1 NEW_LINE DEDENT DEDENT if ( countless < k and ( countless + countequal ) >= k ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( countless >= k ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT elif ( countless < k and countless + countequal < k ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT DEDENT
def update ( x , y , value , id , l , r ) : NEW_LINE INDENT if ( x >= r or l >= y ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( x <= l and r <= y ) : NEW_LINE INDENT lazy [ id ] = value NEW_LINE return NEW_LINE DEDENT mid = ( l + r ) // 2 NEW_LINE if ( lazy [ id ] ) : NEW_LINE INDENT lazy [ 2 * id ] = lazy [ 2 * id + 1 ] = lazy [ id ] NEW_LINE DEDENT lazy [ id ] = 0 NEW_LINE update ( x , y , value , 2 * id , l , mid ) NEW_LINE update ( x , y , value , 2 * id + 1 , mid , r ) NEW_LINE DEDENT
def query ( id , l , r ) : NEW_LINE INDENT if ( lazy [ id ] ) : NEW_LINE INDENT se . add ( lazy [ id ] ) NEW_LINE return NEW_LINE DEDENT if ( r - l < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT mid = ( l + r ) // 2 NEW_LINE query ( 2 * id , l , mid ) NEW_LINE query ( 2 * id + 1 , mid , r ) NEW_LINE DEDENT
def updateRangeUtil ( si , ss , se , us , ue , diff ) : NEW_LINE INDENT if ( lazy [ si ] != 0 ) : NEW_LINE INDENT tree [ si ] += lazy [ si ] NEW_LINE if ( ss != se ) : NEW_LINE INDENT lazy [ si * 2 + 1 ] += lazy [ si ] NEW_LINE lazy [ si * 2 + 2 ] += lazy [ si ] NEW_LINE DEDENT lazy [ si ] = 0 NEW_LINE DEDENT if ( ss > se or ss > ue or se < us ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( ss >= us and se <= ue ) : NEW_LINE INDENT tree [ si ] += diff NEW_LINE if ( ss != se ) : NEW_LINE INDENT lazy [ si * 2 + 1 ] += diff NEW_LINE lazy [ si * 2 + 2 ] += diff NEW_LINE DEDENT return NEW_LINE DEDENT mid = ( ss + se ) // 2 NEW_LINE updateRangeUtil ( si * 2 + 1 , ss , mid , us , ue , diff ) NEW_LINE updateRangeUtil ( si * 2 + 2 , mid + 1 , se , us , ue , diff ) NEW_LINE tree [ si ] = max ( tree [ si * 2 + 1 ] , tree [ si * 2 + 2 ] ) NEW_LINE DEDENT
def updateRange ( n , us , ue , diff ) : NEW_LINE INDENT updateRangeUtil ( 0 , 0 , n - 1 , us , ue , diff ) NEW_LINE DEDENT
def constructSTUtil ( arr , ss , se , si ) : NEW_LINE INDENT if ( ss > se ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( ss == se ) : NEW_LINE INDENT tree [ si ] = arr [ ss ] NEW_LINE return NEW_LINE DEDENT mid = ( ss + se ) // 2 NEW_LINE constructSTUtil ( arr , ss , mid , si * 2 + 1 ) NEW_LINE constructSTUtil ( arr , mid + 1 , se , si * 2 + 2 ) NEW_LINE tree [ si ] = max ( tree [ si * 2 + 1 ] , tree [ si * 2 + 2 ] ) NEW_LINE DEDENT
def constructST ( arr , n ) : NEW_LINE INDENT constructSTUtil ( arr , 0 , n - 1 , 0 ) NEW_LINE DEDENT
def getCount ( n ) : NEW_LINE INDENT count = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT leadDigit = firstDigit ( n ) NEW_LINE n -= leadDigit NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def getLargestNumber ( k ) : NEW_LINE INDENT left = k NEW_LINE right = k * 10 NEW_LINE mid = ( left + right ) // 2 NEW_LINE length = getCount ( mid ) NEW_LINE while ( length != k ) : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE length = getCount ( mid ) NEW_LINE if ( length > k ) : NEW_LINE INDENT right = mid NEW_LINE DEDENT else : NEW_LINE INDENT left = mid NEW_LINE DEDENT DEDENT while ( length == k ) : NEW_LINE INDENT if ( length != getCount ( mid + 1 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT mid += 1 NEW_LINE DEDENT return mid NEW_LINE DEDENT
def F ( A , B ) : NEW_LINE INDENT if ( A == 1 ) : NEW_LINE INDENT return ( 4 % B ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = F ( A - 1 , B ) NEW_LINE return ( temp * temp ) % B NEW_LINE DEDENT DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y and 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def checkHV ( arr , N , M ) : NEW_LINE INDENT horizontal = True NEW_LINE vertical = True NEW_LINE i = 0 NEW_LINE k = N - 1 NEW_LINE while ( i < N // 2 ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) : NEW_LINE INDENT horizontal = False NEW_LINE break NEW_LINE DEDENT DEDENT i += 1 NEW_LINE k -= 1 NEW_LINE DEDENT i = 0 NEW_LINE k = M - 1 NEW_LINE while ( i < M // 2 ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) : NEW_LINE INDENT vertical = False NEW_LINE break NEW_LINE DEDENT DEDENT i += 1 NEW_LINE k -= 1 NEW_LINE DEDENT if ( not horizontal and not vertical ) : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT elif ( horizontal and not vertical ) : NEW_LINE INDENT print ( "HORIZONTAL" ) NEW_LINE DEDENT elif ( vertical and not horizontal ) : NEW_LINE INDENT print ( "VERTICAL" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "BOTH" ) NEW_LINE DEDENT DEDENT
def rangeSum ( l , r ) : NEW_LINE INDENT a = 1 NEW_LINE b = 9 NEW_LINE res = 0 NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT L = max ( l , a ) NEW_LINE R = min ( r , b ) NEW_LINE if ( L <= R ) : NEW_LINE INDENT sum = ( L + R ) * ( R - L + 1 ) // 2 NEW_LINE res += ( i * i ) * ( sum % MOD ) NEW_LINE res %= MOD NEW_LINE DEDENT a *= 10 NEW_LINE b = b * 10 + 9 NEW_LINE DEDENT return res NEW_LINE DEDENT
def getSetBitsFromOneToN ( N ) : NEW_LINE INDENT two , ans = 2 , 0 NEW_LINE n = N NEW_LINE while ( n > 0 ) : NEW_LINE INDENT ans += ( N // two ) * ( two >> 1 ) NEW_LINE if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) : NEW_LINE INDENT ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 NEW_LINE DEDENT two <<= 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findMinimum ( x ) : NEW_LINE INDENT low = 0 NEW_LINE high = 100000 NEW_LINE ans = high NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( getSetBitsFromOneToN ( mid ) >= x ) : NEW_LINE INDENT ans = min ( ans , mid ) NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def exponentMod ( A , B , C ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT y = 0 NEW_LINE if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponentMod ( A , B / 2 , C ) NEW_LINE y = ( y * y ) % C NEW_LINE DEDENT else : NEW_LINE INDENT y = A % C NEW_LINE y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C NEW_LINE DEDENT return ( ( y + C ) % C ) NEW_LINE DEDENT
def trailingZeroes ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n = int ( n / 5 ) NEW_LINE cnt += n NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def binarySearch ( n ) : NEW_LINE INDENT low = 0 NEW_LINE while low < high : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE count = trailingZeroes ( mid ) NEW_LINE if count < n : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT result = list ( ) NEW_LINE while trailingZeroes ( low ) == n : NEW_LINE INDENT result . append ( low ) NEW_LINE low += 1 NEW_LINE DEDENT for i in range ( len ( result ) ) : NEW_LINE INDENT print ( result [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def maxDet ( n ) : NEW_LINE INDENT return 2 * n * n * n NEW_LINE DEDENT
def resMatrix ( n ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if i == 0 and j == 2 : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT elif i == 1 and j == 0 : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT elif i == 2 and j == 1 : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , end = " " ) NEW_LINE DEDENT DEDENT print ( "" ) NEW_LINE DEDENT DEDENT
def getCumulateSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) ) / 2 ) NEW_LINE DEDENT
def minDaysToEmpty ( C , l ) : NEW_LINE INDENT if ( C <= l ) : NEW_LINE INDENT return C NEW_LINE DEDENT lo , hi = 0 , 1e4 NEW_LINE while ( lo < hi ) : NEW_LINE INDENT mid = int ( ( lo + hi ) / 2 ) NEW_LINE if ( getCumulateSum ( mid ) >= ( C - l ) ) : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT return ( l + lo ) NEW_LINE DEDENT
def minDaysToEmpty ( C , l ) : NEW_LINE INDENT if ( l >= C ) : NEW_LINE INDENT return C NEW_LINE DEDENT eq_root = ( math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 NEW_LINE return math . ceil ( eq_root ) + l NEW_LINE DEDENT
def shuffleArray ( a , n ) : NEW_LINE INDENT i , q , k = 0 , 1 , n NEW_LINE while ( i < n ) : NEW_LINE INDENT j = k NEW_LINE while ( j > i + q ) : NEW_LINE INDENT a [ j - 1 ] , a [ j ] = a [ j ] , a [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE k += 1 NEW_LINE q += 1 NEW_LINE DEDENT DEDENT
def kth ( arr1 , arr2 , m , n , k ) : NEW_LINE INDENT sorted1 = [ 0 ] * ( m + n ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE d = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT d += 1 NEW_LINE DEDENT while ( i < m ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE d += 1 NEW_LINE i += 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE d += 1 NEW_LINE j += 1 NEW_LINE DEDENT return sorted1 [ k - 1 ] NEW_LINE DEDENT
def spiralDiaSum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) NEW_LINE DEDENT
def binarySearch ( mat , i , j_low , j_high , x ) : NEW_LINE INDENT while ( j_low <= j_high ) : NEW_LINE INDENT j_mid = ( j_low + j_high ) // 2 NEW_LINE if ( mat [ i ] [ j_mid ] == x ) : NEW_LINE INDENT print ( "Found at (" , i , ", " , j_mid , ")" ) NEW_LINE return NEW_LINE DEDENT elif ( mat [ i ] [ j_mid ] > x ) : NEW_LINE INDENT j_high = j_mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT j_low = j_mid + 1 NEW_LINE DEDENT DEDENT print ( "Element no found" ) NEW_LINE DEDENT
def sortedMatrixSearch ( mat , n , m , x ) : if ( n == 1 ) : NEW_LINE INDENT binarySearch ( mat , 0 , 0 , m - 1 , x ) NEW_LINE return NEW_LINE DEDENT i_low = 0 NEW_LINE i_high = n - 1 NEW_LINE j_mid = m // 2 NEW_LINE while ( ( i_low + 1 ) < i_high ) : NEW_LINE INDENT i_mid = ( i_low + i_high ) // 2 NEW_LINE if ( mat [ i_mid ] [ j_mid ] == x ) : NEW_LINE INDENT print ( "Found at (" , i_mid , ", " , j_mid , ")" ) NEW_LINE return NEW_LINE DEDENT elif ( mat [ i_mid ] [ j_mid ] > x ) : NEW_LINE INDENT i_high = i_mid NEW_LINE DEDENT else : NEW_LINE INDENT i_low = i_mid NEW_LINE DEDENT DEDENT if ( mat [ i_low ] [ j_mid ] == x ) : NEW_LINE INDENT print ( "Found at (" , i_low , "," , j_mid , ")" ) NEW_LINE DEDENT elif ( mat [ i_low + 1 ] [ j_mid ] == x ) : NEW_LINE INDENT print ( "Found at (" , ( i_low + 1 ) , ", " , j_mid , ")" ) NEW_LINE DEDENT elif ( x <= mat [ i_low ] [ j_mid - 1 ] ) : NEW_LINE INDENT binarySearch ( mat , i_low , 0 , j_mid - 1 , x ) NEW_LINE DEDENT elif ( x >= mat [ i_low ] [ j_mid + 1 ] and x <= mat [ i_low ] [ m - 1 ] ) : NEW_LINE INDENT binarySearch ( mat , i_low , j_mid + 1 , m - 1 , x ) NEW_LINE DEDENT elif ( x <= mat [ i_low + 1 ] [ j_mid - 1 ] ) : NEW_LINE INDENT binarySearch ( mat , i_low + 1 , 0 , j_mid - 1 , x ) NEW_LINE DEDENT
def isFeasible ( mid , arr , n , k ) : NEW_LINE INDENT pos = arr [ 0 ] NEW_LINE elements = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] - pos >= mid ) : NEW_LINE INDENT pos = arr [ i ] NEW_LINE elements += 1 NEW_LINE if ( elements == k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT
def largestMinDist ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE res = - 1 NEW_LINE left = 1 NEW_LINE right = arr [ n - 1 ] NEW_LINE while ( left < right ) : NEW_LINE INDENT mid = ( left + right ) / 2 NEW_LINE if ( isFeasible ( mid , arr , n , k ) ) : NEW_LINE INDENT res = max ( res , mid ) NEW_LINE left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right = mid NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def bsearch ( low , high , n , arr ) : NEW_LINE INDENT mid = ( low + high ) / 2 NEW_LINE if ( low <= high ) : NEW_LINE INDENT if ( arr [ mid ] < n ) : NEW_LINE INDENT return bsearch ( mid + 1 , high , n , arr ) NEW_LINE DEDENT return bsearch ( low , mid - 1 , n , arr ) NEW_LINE DEDENT return low NEW_LINE DEDENT
def mindiff ( arr , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sorted ( arr ) NEW_LINE DEDENT ans = 2147483647 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT p = bsearch ( 0 , m - 1 , arr [ i ] [ j ] , arr [ i + 1 ] ) NEW_LINE ans = min ( ans , abs ( arr [ i + 1 ] [ p ] - arr [ i ] [ j ] ) ) NEW_LINE if ( p - 1 >= 0 ) : NEW_LINE INDENT ans = min ( ans , abs ( arr [ i + 1 ] [ p - 1 ] - arr [ i ] [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def binarySearch ( arr , left , right ) : NEW_LINE INDENT if ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE if ( arr [ mid - 1 ] < arr [ mid ] and arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ mid ] < arr [ mid + 1 ] ) : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , right ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , left , mid - 1 ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findRepeatingElement ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if ( arr [ mid ] != mid + 1 ) : NEW_LINE INDENT if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT return findRepeatingElement ( arr , low , mid - 1 ) NEW_LINE DEDENT return findRepeatingElement ( arr , mid + 1 , high ) NEW_LINE DEDENT
def diff ( n , mid ) : NEW_LINE INDENT if ( n > ( mid * mid * mid ) ) : NEW_LINE INDENT return ( n - ( mid * mid * mid ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( mid * mid * mid ) - n ) NEW_LINE DEDENT DEDENT
def cubicRoot ( n ) : NEW_LINE INDENT start = 0 NEW_LINE end = n NEW_LINE e = 0.0000001 NEW_LINE while ( True ) : NEW_LINE INDENT mid = ( start + end ) / 2 NEW_LINE error = diff ( n , mid ) NEW_LINE if ( error <= e ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( ( mid * mid * mid ) > n ) : NEW_LINE INDENT end = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT DEDENT
def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE findFrequencyUtil ( arr , low , mid , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , high , freq ) NEW_LINE DEDENT DEDENT
def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( n - 1 + 1 ) ] NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) NEW_LINE for i in range ( 0 , arr [ n - 1 ] + 1 , 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT print ( "Element" , i , "occurs" , freq [ i ] , "times" ) NEW_LINE DEDENT DEDENT DEDENT
def floorSqrt ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT i = 1 NEW_LINE result = 1 NEW_LINE while ( result <= x ) : NEW_LINE INDENT i += 1 NEW_LINE result = i * i NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT
def countDirectPath ( N ) : NEW_LINE INDENT return N + ( N * ( N - 3 ) ) // 2 NEW_LINE DEDENT
def isPossibleToReach ( A , N , X , Y ) : NEW_LINE INDENT distance = math . sqrt ( X * X + Y * Y ) NEW_LINE mx = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT mx += A [ i ] NEW_LINE DEDENT if ( mx < distance ) : NEW_LINE INDENT print ( "NO" ) NEW_LINE return 0 NEW_LINE DEDENT if ( ( mx - distance ) < 0.000001 ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE return 0 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( distance + mx < ( 2 ) * ( A [ i ] ) ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT print ( "Yes" ) NEW_LINE return 0 NEW_LINE DEDENT
def canReach ( X , Y ) : NEW_LINE INDENT steps = 0 NEW_LINE while ( X != 0 or Y != 0 ) : NEW_LINE INDENT pos1 = X % 3 NEW_LINE pos2 = Y % 3 NEW_LINE if ( pos1 == 2 or pos2 == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( pos1 == 1 and pos2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( pos1 == 0 and pos2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT X /= 3 NEW_LINE Y /= 3 NEW_LINE steps += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def numofneighbour ( mat , i , j ) : NEW_LINE INDENT count = 0 NEW_LINE if ( i > 0 and mat [ i - 1 ] [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( j > 0 and mat [ i ] [ j - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( i < R - 1 and mat [ i + 1 ] [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( j < C - 1 and mat [ i ] [ j + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findperimeter ( mat ) : NEW_LINE INDENT perimeter = 0 NEW_LINE for i in range ( 0 , R ) : NEW_LINE INDENT for j in range ( 0 , C ) : NEW_LINE INDENT if ( mat [ i ] [ j ] ) : NEW_LINE INDENT perimeter += ( 4 - numofneighbour ( mat , i , j ) ) NEW_LINE DEDENT DEDENT DEDENT return perimeter NEW_LINE DEDENT
def findRadius ( r1 , r2 , r3 ) : NEW_LINE INDENT r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) NEW_LINE return r4 NEW_LINE DEDENT
def findSides ( A , C , c ) : NEW_LINE INDENT B = 180 - ( A + C ) NEW_LINE A = A * ( 3.14159 / 180 ) NEW_LINE C = C * ( 3.14159 / 180 ) NEW_LINE B = B * ( 3.14159 / 180 ) NEW_LINE a = ( c / math . sin ( C ) ) * math . sin ( A ) NEW_LINE b = ( c / math . sin ( C ) ) * math . sin ( B ) NEW_LINE print ( "{0:.2f}" . format ( a ) ) NEW_LINE print ( "{0:.2f}" . format ( b ) ) NEW_LINE DEDENT
def closestsAngle ( N , A ) : NEW_LINE INDENT mi = sys . maxsize NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT angle = 180.0 * i / N NEW_LINE if ( math . fabs ( angle - A ) < math . fabs ( mi - A ) ) : NEW_LINE INDENT mi = angle NEW_LINE i += 1 NEW_LINE ans = i NEW_LINE DEDENT DEDENT print ( 2 , 1 , 2 + ans ) NEW_LINE DEDENT
def lengthOfLatusRectum ( A , B ) : NEW_LINE INDENT major = 2.0 * A NEW_LINE minor = 2.0 * B NEW_LINE latus_rectum = ( minor * minor ) / major NEW_LINE return latus_rectum NEW_LINE DEDENT
def radius ( a , b , c ) : NEW_LINE INDENT g = a / 2 NEW_LINE f = b / 2 NEW_LINE if ( g * g + f * f - c < 0 ) : NEW_LINE INDENT return ( - 1 ) NEW_LINE DEDENT return ( math . sqrt ( g * g + f * f - c ) ) NEW_LINE DEDENT
def centerDistanceFromLine ( a , b , i , j , k ) : NEW_LINE INDENT g = a / 2 NEW_LINE f = b / 2 NEW_LINE distance = ( abs ( i * g + j * f + k ) / ( math . sqrt ( i * i + j * j ) ) ) NEW_LINE if ( distance < 0 ) : NEW_LINE INDENT return ( - 1 ) NEW_LINE DEDENT return distance NEW_LINE DEDENT
def check_position ( a , b , c , d , x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT value_1 = a * x1 + b * y1 + c * z1 + d NEW_LINE value_2 = a * x2 + b * y2 + c * z2 + d NEW_LINE if ( ( value_1 > 0 and value_2 > 0 ) or ( value_1 < 0 and value_2 < 0 ) ) : NEW_LINE INDENT print ( "On same side" ) NEW_LINE DEDENT if ( ( value_1 > 0 and value_2 < 0 ) or ( value_1 < 0 and value_2 > 0 ) ) : NEW_LINE INDENT print ( "On different sides" ) NEW_LINE DEDENT if ( value_1 == 0 and value_2 == 0 ) : NEW_LINE INDENT print ( "Both on the plane" ) NEW_LINE DEDENT if ( value_1 == 0 and value_2 != 0 ) : NEW_LINE INDENT print ( "Point 1 on the plane" ) NEW_LINE DEDENT if ( value_1 != 0 and value_2 == 0 ) : NEW_LINE INDENT print ( "Point 2 on the plane" ) NEW_LINE DEDENT DEDENT
def normal_equation ( a , b , x1 , y1 ) : NEW_LINE INDENT slope = normal_slope ( a , b , x1 , y1 ) NEW_LINE if ( slope == - 1 ) : NEW_LINE INDENT print ( "x = " , x1 ) NEW_LINE DEDENT if ( slope == - 2 ) : NEW_LINE INDENT print ( "y = " , y1 ) NEW_LINE DEDENT if ( slope != - 1 and slope != - 2 ) : NEW_LINE INDENT x1 *= - slope NEW_LINE x1 += y1 NEW_LINE if ( x1 > 0 ) : NEW_LINE INDENT print ( "y = " , slope , "x + " , x1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "y = " , slope , "x " , x1 ) NEW_LINE DEDENT DEDENT DEDENT
def point_distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT p = ( x2 - x1 ) NEW_LINE q = ( y2 - y1 ) NEW_LINE distance = math . sqrt ( p * p + q * q ) NEW_LINE return distance NEW_LINE DEDENT
def check ( C ) : NEW_LINE INDENT C1C2 = sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) NEW_LINE flag = 0 NEW_LINE if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) : NEW_LINE INDENT if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x and ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT
def IsFairTriplet ( c ) : NEW_LINE INDENT f = False NEW_LINE f |= check ( c ) NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT c [ 0 ] , c [ 2 ] = c [ 2 ] , c [ 0 ] NEW_LINE f |= check ( c ) NEW_LINE DEDENT return f NEW_LINE DEDENT
def eccHyperbola ( A , B ) : NEW_LINE INDENT r = B * B / A * A NEW_LINE r += 1 NEW_LINE return math . sqrt ( r ) NEW_LINE DEDENT
def findInteriorAngle ( n ) : NEW_LINE INDENT return ( n - 2 ) * PI / n NEW_LINE DEDENT
def findAngle ( M1 , M2 ) : NEW_LINE INDENT PI = 3.14159265 NEW_LINE angle = abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) NEW_LINE ret = atan ( angle ) NEW_LINE val = ( ret * 180 ) / PI NEW_LINE print ( round ( val , 4 ) ) NEW_LINE DEDENT
def calculateArea ( A , B , C , D ) : NEW_LINE INDENT S = ( A + B + C + D ) // 2 NEW_LINE area = sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) NEW_LINE return area NEW_LINE DEDENT
def angle ( R1 , R2 , D ) : NEW_LINE INDENT ans = ( ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) ) NEW_LINE return ans NEW_LINE DEDENT
def triangleArea ( a , b ) : NEW_LINE INDENT ratio = b / a NEW_LINE print ( ratio ) NEW_LINE DEDENT
def countInscribed ( R1 , R2 ) : NEW_LINE INDENT if ( R2 > R1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT angle = 0 NEW_LINE ratio = 0 NEW_LINE number_of_circles = 0 NEW_LINE ratio = R2 / ( R1 - R2 ) NEW_LINE if ( R1 < 2 * R2 ) : NEW_LINE INDENT number_of_circles = 1 NEW_LINE DEDENT else : NEW_LINE INDENT angle = ( abs ( math . asin ( ratio ) * 180 ) / 3.14159265 ) NEW_LINE number_of_circles = ( 360 / ( 2 * math . floor ( angle ) ) ) NEW_LINE DEDENT return number_of_circles NEW_LINE DEDENT
def distance ( m , n , p , q ) : NEW_LINE INDENT return ( sqrt ( pow ( n - m , 2 ) + pow ( q - p , 2 ) * 1.0 ) ) NEW_LINE DEDENT
def magnitude ( arr , N ) : NEW_LINE INDENT magnitude = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT magnitude += arr [ i ] * arr [ i ] NEW_LINE DEDENT return math . sqrt ( magnitude ) NEW_LINE DEDENT
def dotProduct ( arr , brr , N ) : NEW_LINE INDENT product = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT product = product + arr [ i ] * brr [ i ] NEW_LINE DEDENT return product NEW_LINE DEDENT
def angleBetweenVectors ( arr , brr , N ) : NEW_LINE INDENT dotProductOfVectors = dotProduct ( arr , brr , N ) NEW_LINE magnitudeOfA = magnitude ( arr , N ) NEW_LINE magnitudeOfB = magnitude ( brr , N ) NEW_LINE angle = ( dotProductOfVectors / ( magnitudeOfA * magnitudeOfB ) ) NEW_LINE print ( '%.5f' % angle ) NEW_LINE DEDENT
def lengthOfLatusRectum ( A , B ) : NEW_LINE INDENT major = 2.0 * A NEW_LINE minor = 2.0 * B NEW_LINE latus_rectum = ( minor * minor ) / major NEW_LINE return latus_rectum NEW_LINE DEDENT
def totalCircles ( L , B ) : NEW_LINE INDENT if ( L > B ) : NEW_LINE INDENT temp = L NEW_LINE L = B NEW_LINE B = temp NEW_LINE DEDENT return B // L NEW_LINE DEDENT
def findSquareSum ( Coordinates , N ) : NEW_LINE INDENT xq , yq = 0 , 0 NEW_LINE xs , ys = 0 , 0 NEW_LINE res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = Coordinates [ i ] [ 0 ] NEW_LINE b = Coordinates [ i ] [ 1 ] NEW_LINE res += xq NEW_LINE res -= 2 * xs * a NEW_LINE res += i * ( a * a ) NEW_LINE xq += a * a NEW_LINE xs += a NEW_LINE res += yq NEW_LINE res -= 2 * ys * b NEW_LINE res += i * b * b NEW_LINE yq += b * b NEW_LINE ys += b NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def findDiagonal ( s ) : NEW_LINE INDENT return math . sqrt ( 2 ) * s NEW_LINE DEDENT
def triangleArea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT area = ( 3 * sqrt ( 3 ) * a * b ) / ( 4 ) NEW_LINE print ( "{:.5f}" . format ( area ) ) NEW_LINE DEDENT
def maxRowDiff ( mat , m , n ) : NEW_LINE INDENT rowSum = [ 0 ] * m NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT rowSum [ i ] = sum NEW_LINE DEDENT max_diff = rowSum [ 1 ] - rowSum [ 0 ] NEW_LINE min_element = rowSum [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT if ( rowSum [ i ] - min_element > max_diff ) : NEW_LINE INDENT max_diff = rowSum [ i ] - min_element NEW_LINE DEDENT if ( rowSum [ i ] < min_element ) : NEW_LINE INDENT min_element = rowSum [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT
def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return sqrt ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) NEW_LINE DEDENT
def lengthOfLatusRectum ( a , b , c ) : NEW_LINE INDENT vertex = [ ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) ] NEW_LINE focus = [ ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) ] NEW_LINE print ( "{:.6f}" . format ( 4 * distance ( focus [ 0 ] , focus [ 1 ] , vertex [ 0 ] , vertex [ 1 ] ) ) ) NEW_LINE DEDENT
def doIntersect ( X , Y ) : NEW_LINE INDENT if ( X [ 0 ] > X [ 3 ] or X [ 2 ] > X [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( Y [ 0 ] > Y [ 3 ] or Y [ 2 ] > Y [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def getUnionPerimeter ( X , Y ) : NEW_LINE INDENT perimeter = 0 NEW_LINE if ( not doIntersect ( X , Y ) ) : NEW_LINE INDENT perimeter += 2 * ( abs ( X [ 1 ] - X [ 0 ] ) + abs ( Y [ 1 ] - Y [ 0 ] ) ) NEW_LINE perimeter += 2 * ( abs ( X [ 3 ] - X [ 2 ] ) + abs ( Y [ 3 ] - Y [ 2 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT w = max ( X ) - min ( X ) NEW_LINE l = max ( Y ) - min ( Y ) NEW_LINE perimeter = 2 * ( l + w ) NEW_LINE DEDENT return perimeter NEW_LINE DEDENT
def getPointsIns ( x1 , y1 , radius , x2 , y2 , points ) : NEW_LINE INDENT for point in points : NEW_LINE INDENT condOne = ( point [ 1 ] - y2 ) * ( x2 - x1 ) - ( y2 - y1 ) * ( point [ 0 ] - x2 ) >= 0 NEW_LINE condTwo = radius >= ( ( y1 - point [ 1 ] ) ** 2 + ( x1 - point [ 0 ] ) ** 2 ) ** ( 0.5 ) NEW_LINE if condOne and condTwo : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def Convert ( degree ) : NEW_LINE INDENT pi = 3.14159265359 NEW_LINE return ( degree * ( pi / 180 ) ) NEW_LINE DEDENT
def findRadius ( r1 , r2 ) : NEW_LINE INDENT a1 , a2 , a3 , r3 = 0 , 0 , 0 , 0 NEW_LINE a1 = 3.14 * r1 * r1 NEW_LINE a2 = 3.14 * r2 * r2 NEW_LINE a3 = a1 + a2 NEW_LINE r3 = ( ( a3 / 3.14 ) ** ( 1 / 2 ) ) NEW_LINE return r3 NEW_LINE DEDENT
def find_lcm ( a , b , c ) : NEW_LINE INDENT g = __gcd ( a , b ) NEW_LINE LCM1 = ( a * b ) // g NEW_LINE g = __gcd ( LCM1 , c ) NEW_LINE LCM = ( LCM1 * c ) // g NEW_LINE return LCM NEW_LINE DEDENT
def minimumCuboids ( L , B , H ) : NEW_LINE INDENT lcm = find_lcm ( L , B , H ) NEW_LINE volume_cube = lcm * lcm * lcm NEW_LINE volume_cuboid = L * B * H NEW_LINE print ( ( volume_cube // volume_cuboid ) ) NEW_LINE DEDENT
def distance ( p1 , p2 ) : NEW_LINE INDENT x1 , x2 = p1 [ 0 ] , p2 [ 0 ] NEW_LINE y1 , y2 = p1 [ 1 ] , p2 [ 1 ] NEW_LINE return int ( math . sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) ) ) NEW_LINE DEDENT
def CrossProduct ( A ) : NEW_LINE INDENT X1 = ( A [ 1 ] [ 0 ] - A [ 0 ] [ 0 ] ) NEW_LINE Y1 = ( A [ 1 ] [ 1 ] - A [ 0 ] [ 1 ] ) NEW_LINE X2 = ( A [ 2 ] [ 0 ] - A [ 0 ] [ 0 ] ) NEW_LINE Y2 = ( A [ 2 ] [ 1 ] - A [ 0 ] [ 1 ] ) NEW_LINE return ( X1 * Y2 - Y1 * X2 ) NEW_LINE DEDENT
def isConvex ( points ) : NEW_LINE INDENT N = len ( points ) NEW_LINE prev = 0 NEW_LINE curr = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = [ points [ i ] , points [ ( i + 1 ) % N ] , points [ ( i + 2 ) % N ] ] NEW_LINE curr = CrossProduct ( temp ) NEW_LINE if ( curr != 0 ) : NEW_LINE INDENT if ( curr * prev < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT prev = curr NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def cntRect ( points , N , rectangle ) : NEW_LINE INDENT cntHor = set ( [ ] ) NEW_LINE cntVer = set ( [ ] ) NEW_LINE cntHor . add ( 0 ) NEW_LINE cntVer . add ( 0 ) NEW_LINE cntHor . add ( rectangle [ 3 ] [ 0 ] ) NEW_LINE cntVer . add ( rectangle [ 3 ] [ 1 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT cntHor . add ( points [ i ] [ 0 ] ) NEW_LINE cntVer . add ( points [ i ] [ 1 ] ) NEW_LINE DEDENT return ( ( len ( cntHor ) - 1 ) * ( len ( cntVer ) - 1 ) ) NEW_LINE DEDENT
def numberOfSquares ( X , Y , N , M ) : NEW_LINE INDENT m1 = { } NEW_LINE m2 = { } NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT dist = abs ( X [ i ] - X [ j ] ) NEW_LINE if dist in m1 : NEW_LINE INDENT m1 [ dist ] = m1 [ dist ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 [ dist ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( i + 1 , M ) : NEW_LINE INDENT dist = abs ( Y [ i ] - Y [ j ] ) NEW_LINE if dist in m2 : NEW_LINE INDENT m2 [ dist ] = m2 [ dist ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m2 [ dist ] = 1 NEW_LINE DEDENT DEDENT DEDENT for key in m1 : NEW_LINE INDENT if key in m2 : NEW_LINE INDENT ans = ans + ( m1 [ key ] * m2 [ key ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def Area_Parallelogram1 ( a , b , theta ) : NEW_LINE INDENT area = ( abs ( math . tan ( math . radians ( theta ) ) ) / 2 ) * abs ( a ** 2 - b ** 2 ) NEW_LINE return area NEW_LINE DEDENT
def Area_Parallelogram3 ( d1 , d2 , theta ) : NEW_LINE INDENT area = ( abs ( math . sin ( math . radians ( theta ) ) ) / 2 ) * abs ( d1 * d2 ) NEW_LINE return area NEW_LINE DEDENT
def noOfTriangles ( n ) : NEW_LINE INDENT return n * ( n + 2 ) * ( 2 * n + 1 ) // 8 NEW_LINE DEDENT
def No_of_squares ( N , K ) : NEW_LINE INDENT no_of_squares = 0 NEW_LINE no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) NEW_LINE return no_of_squares NEW_LINE DEDENT
def checkTriangle ( x , y , z ) : NEW_LINE INDENT if x == y == z : NEW_LINE INDENT print ( "Equilateral Triangle" ) NEW_LINE DEDENT elif x == y or y == z or z == x : NEW_LINE INDENT print ( "Isosceles Triangle" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Scalene Triangle" ) NEW_LINE DEDENT DEDENT
def getTotalCoverageOfMatrix ( mat ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT isOne = False NEW_LINE for j in range ( C ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT isOne = True NEW_LINE DEDENT elif ( isOne ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT isOne = False NEW_LINE for j in range ( C - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT isOne = True NEW_LINE DEDENT elif ( isOne ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT for j in range ( C ) : NEW_LINE INDENT isOne = False NEW_LINE for i in range ( R ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT isOne = True NEW_LINE DEDENT elif ( isOne ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT isOne = False NEW_LINE for i in range ( R - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT isOne = True NEW_LINE DEDENT elif ( isOne ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def Circumradius ( a , b , c , d ) : NEW_LINE INDENT s = ( a + b + c + d ) / 2 NEW_LINE radius = ( 1 / 4 ) * math . sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) NEW_LINE return radius NEW_LINE DEDENT
def calculateTriangles ( sides ) : NEW_LINE INDENT count = pow ( sides [ 0 ] + sides [ 1 ] + sides [ 2 ] , 2 ) NEW_LINE count -= pow ( sides [ 0 ] , 2 ) NEW_LINE count -= pow ( sides [ 2 ] , 2 ) NEW_LINE count -= pow ( sides [ 4 ] , 2 ) NEW_LINE return int ( count ) NEW_LINE DEDENT
def Length_Diagonal ( a , b , theta ) : NEW_LINE INDENT diagonal = math . sqrt ( ( ( a ** 2 ) + ( b ** 2 ) ) - 2 * a * b * math . cos ( math . radians ( theta ) ) ) NEW_LINE return diagonal NEW_LINE DEDENT
def maximumTiles ( n , m ) : NEW_LINE INDENT print ( int ( ( m * n ) / 2 ) ) NEW_LINE DEDENT
def Length_Diagonal ( a , b , d ) : NEW_LINE INDENT diagonal = math . sqrt ( 2 * ( ( a ** 2 ) + ( b ** 2 ) ) - ( d ** 2 ) ) NEW_LINE return diagonal NEW_LINE DEDENT
def Diagonals ( a , b , c , d ) : NEW_LINE INDENT p = math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) NEW_LINE q = math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) NEW_LINE return [ p , q ] NEW_LINE DEDENT
def find ( x , y , p ) : NEW_LINE INDENT mind = 0 NEW_LINE for i in range ( len ( p ) ) : NEW_LINE INDENT a = p [ i ] [ 0 ] NEW_LINE b = p [ i ] [ 1 ] NEW_LINE mind += sqrt ( ( x - a ) * ( x - a ) + ( y - b ) * ( y - b ) ) NEW_LINE DEDENT return mind NEW_LINE DEDENT
def getMinDistSum ( p ) : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( len ( p ) ) : NEW_LINE INDENT x += p [ i ] [ 0 ] NEW_LINE y += p [ i ] [ 1 ] NEW_LINE DEDENT x = x // len ( p ) NEW_LINE y = y // len ( p ) NEW_LINE mind = find ( x , y , p ) NEW_LINE return mind NEW_LINE DEDENT
def det ( d ) : NEW_LINE INDENT Sum = d [ 0 ] [ 0 ] * ( ( d [ 1 ] [ 1 ] * d [ 2 ] [ 2 ] ) - ( d [ 2 ] [ 1 ] * d [ 1 ] [ 2 ] ) ) NEW_LINE Sum -= d [ 0 ] [ 1 ] * ( ( d [ 1 ] [ 0 ] * d [ 2 ] [ 2 ] ) - ( d [ 1 ] [ 2 ] * d [ 2 ] [ 0 ] ) ) NEW_LINE Sum += d [ 0 ] [ 2 ] * ( ( d [ 0 ] [ 1 ] * d [ 1 ] [ 2 ] ) - ( d [ 0 ] [ 2 ] * d [ 1 ] [ 1 ] ) ) NEW_LINE return Sum NEW_LINE DEDENT
def distance ( r , R ) : NEW_LINE INDENT d = math . sqrt ( ( R ** 2 ) - ( 2 * r * R ) ) NEW_LINE return d NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def replacematrix ( mat , n , m ) : NEW_LINE INDENT rgcd = [ 0 ] * R NEW_LINE cgcd = [ 0 ] * C NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] ) NEW_LINE cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT mat [ i ] [ j ] = max ( rgcd [ i ] , cgcd [ j ] ) NEW_LINE DEDENT DEDENT DEDENT
def areaOfSquare ( S ) : NEW_LINE INDENT area = S * S NEW_LINE return area NEW_LINE DEDENT
def isAllKs ( n , b , k ) : NEW_LINE INDENT len = findNumberOfDigits ( n , b ) NEW_LINE sum = k * ( 1 - pow ( b , len ) ) / ( 1 - b ) NEW_LINE return sum == N NEW_LINE DEDENT
def checkRightAngled ( X1 , Y1 , X2 , Y2 , X3 , Y3 ) : NEW_LINE INDENT A = ( int ( pow ( ( X2 - X1 ) , 2 ) ) + int ( pow ( ( Y2 - Y1 ) , 2 ) ) ) NEW_LINE B = ( int ( pow ( ( X3 - X2 ) , 2 ) ) + int ( pow ( ( Y3 - Y2 ) , 2 ) ) ) NEW_LINE C = ( int ( pow ( ( X3 - X1 ) , 2 ) ) + int ( pow ( ( Y3 - Y1 ) , 2 ) ) ) NEW_LINE if ( ( A > 0 and B > 0 and C > 0 ) and ( A == ( B + C ) or B == ( A + C ) or C == ( A + B ) ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def checkValidPolygon ( arr , N ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT if Sum == 180 * ( N - 2 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def minAnglRot ( N ) : NEW_LINE INDENT res = 360 // N NEW_LINE return res NEW_LINE DEDENT
def maxPointOfIntersection ( x , y ) : NEW_LINE INDENT k = y * ( y - 1 ) // 2 NEW_LINE k = k + x * ( 2 * y + x - 1 ) NEW_LINE return k NEW_LINE DEDENT
def sortedCount ( mat , r , c ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( c - 1 ) : NEW_LINE INDENT if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == c - 2 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , r ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( c - 1 , 0 , - 1 ) : NEW_LINE INDENT if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if c > 1 and j == 1 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def Area_of_Triangle ( a , b , c ) : NEW_LINE INDENT s = ( a + b + c ) // 2 NEW_LINE x = s * ( s - a ) NEW_LINE x = x * ( s - b ) NEW_LINE x = x * ( s - c ) NEW_LINE area = ( 4 / 3 ) * math . sqrt ( x ) NEW_LINE return area NEW_LINE DEDENT
def Area_of_Triangle ( a , b , k ) : NEW_LINE INDENT area = ( 1 / 2 ) * a * b * math . sin ( k ) NEW_LINE return area NEW_LINE DEDENT
def findAreaCovered ( ) : NEW_LINE INDENT area = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE INDENT if arr [ i ] [ j ] : NEW_LINE INDENT area += 1 NEW_LINE DEDENT DEDENT DEDENT return area NEW_LINE DEDENT
def findEquation ( x1 , y1 , z1 , x2 , y2 , z2 , d , e , f ) : NEW_LINE INDENT a = x2 - x1 NEW_LINE b = y2 - y1 NEW_LINE c = z2 - z1 NEW_LINE A = ( b * f - c * e ) NEW_LINE B = ( a * f - c * d ) NEW_LINE C = ( a * e - b * d ) NEW_LINE D = - ( A * d - B * e + C * f ) NEW_LINE print ( A , "x + " , B , "y + " , C , "z + " , D , "= 0" ) NEW_LINE DEDENT
def createPrefixArray ( n , arr , prefSize , pref ) : NEW_LINE INDENT for i in range ( prefSize ) : NEW_LINE INDENT pref [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] + 1000000 NEW_LINE pref [ x ] += 1 NEW_LINE DEDENT for i in range ( 1 , prefSize ) : NEW_LINE INDENT pref [ i ] += pref [ i - 1 ] NEW_LINE DEDENT DEDENT
def count_rectangles ( N , M ) : NEW_LINE INDENT p_x = ( N * ( N - 1 ) ) // 2 NEW_LINE p_y = ( M * ( M - 1 ) ) // 2 NEW_LINE return p_x * p_y NEW_LINE DEDENT
def median ( a , b , c ) : NEW_LINE INDENT n = ( 1 / 2 ) * math . sqrt ( 2 * ( b ** 2 ) + 2 * ( c ** 2 ) - a ** 2 ) NEW_LINE return n NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def circleArea ( r ) : NEW_LINE INDENT print ( round ( pi * r * r , 4 ) ) NEW_LINE DEDENT
def findCircleAreaByMedian ( m ) : NEW_LINE INDENT r = 2 * m / 3 NEW_LINE circleArea ( r ) NEW_LINE DEDENT
def areaSquare ( L , B ) : NEW_LINE INDENT large = max ( L , B ) NEW_LINE small = min ( L , B ) NEW_LINE if ( large >= 2 * small ) : NEW_LINE INDENT return large * large NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * small ) * ( 2 * small ) NEW_LINE DEDENT DEDENT
def nGon ( N ) : NEW_LINE INDENT proAngleVar = 0 NEW_LINE if ( N % 4 == 0 ) : NEW_LINE INDENT proAngleVar = ( pi * ( 180.0 / N ) / 180 ) NEW_LINE DEDENT else : NEW_LINE INDENT proAngleVar = ( pi * ( 180.0 / ( 2 * N ) ) / 180 ) NEW_LINE DEDENT negX = 1.0e+99 NEW_LINE posX = - 1.0e+99 NEW_LINE negY = 1.0e+99 NEW_LINE posY = - 1.0e+99 NEW_LINE for j in range ( N ) : NEW_LINE INDENT px = math . cos ( 2 * pi * j / N + proAngleVar ) NEW_LINE py = math . sin ( 2 * pi * j / N + proAngleVar ) NEW_LINE negX = min ( negX , px ) NEW_LINE posX = max ( posX , px ) NEW_LINE negY = min ( negY , py ) NEW_LINE posY = max ( posY , py ) NEW_LINE DEDENT opt2 = max ( posX - negX , posY - negY ) NEW_LINE return ( opt2 / math . sin ( pi / N ) / 2 ) NEW_LINE DEDENT
def cal_cos ( n ) : NEW_LINE INDENT accuracy = 0.0001 NEW_LINE n = n * ( 3.142 / 180.0 ) NEW_LINE x1 = 1 NEW_LINE cosx = x1 NEW_LINE cosval = math . cos ( n ) NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT denominator = 2 * i * ( 2 * i - 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE cosx = cosx + x1 NEW_LINE i = i + 1 NEW_LINE if accuracy > math . fabs ( cosval - cosx ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return cosx NEW_LINE DEDENT
def triacontagonalNum ( n ) : NEW_LINE INDENT return ( 28 * n * n - 26 * n ) // 2 NEW_LINE DEDENT
def hexacontagonNum ( n ) : NEW_LINE INDENT return ( 58 * n * n - 56 * n ) // 2 NEW_LINE DEDENT
def isicositetragonal ( N ) : NEW_LINE INDENT n = ( 10 + math . sqrt ( 44 * N + 100 ) ) / 22 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def enneacontagonNum ( n ) : NEW_LINE INDENT return ( 88 * n * n - 86 * n ) // 2 NEW_LINE DEDENT
def triacontakaidigonNum ( n ) : NEW_LINE INDENT return ( 30 * n * n - 28 * n ) // 2 NEW_LINE DEDENT
def maxXOR ( mat , N ) : NEW_LINE INDENT max_xor = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT r_xor = 0 NEW_LINE c_xor = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT r_xor = r_xor ^ mat [ i ] [ j ] NEW_LINE c_xor = c_xor ^ mat [ j ] [ i ] NEW_LINE DEDENT if ( max_xor < max ( r_xor , c_xor ) ) : NEW_LINE INDENT max_xor = max ( r_xor , c_xor ) NEW_LINE DEDENT DEDENT return max_xor NEW_LINE DEDENT
def isTridecagon ( N ) : NEW_LINE INDENT n = ( 9 + math . sqrt ( 88 * N + 81 ) ) / 22 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isicosihenagonal ( N ) : NEW_LINE INDENT n = ( 17 + math . sqrt ( 152 * N + 289 ) ) / 38 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isicositrigonal ( N ) : NEW_LINE INDENT n = ( 19 + math . sqrt ( 168 * N + 361 ) ) / 42 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def IcosihexagonalNum ( n ) : NEW_LINE INDENT return ( 24 * n * n - 22 * n ) // 2 NEW_LINE DEDENT
def icosikaioctagonalNum ( n ) : NEW_LINE INDENT return ( 26 * n * n - 24 * n ) // 2 NEW_LINE DEDENT
def hectagonNum ( n ) : NEW_LINE INDENT return ( 98 * n * n - 96 * n ) // 2 NEW_LINE DEDENT
def tetracontagonNum ( n ) : NEW_LINE INDENT return ( 38 * n * n - 36 * n ) // 2 NEW_LINE DEDENT
def Tridecagonal_num ( n ) : NEW_LINE INDENT return ( 11 * n * n - 9 * n ) / 2 NEW_LINE DEDENT
def Octadecagonal_num ( n ) : NEW_LINE INDENT return ( 16 * n * n - 14 * n ) / 2 NEW_LINE DEDENT
def Icositetragonal_num ( n ) : NEW_LINE INDENT return ( 22 * n * n - 20 * n ) / 2 NEW_LINE DEDENT
def Icosihenagonal_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 17 * n ) / 2 NEW_LINE DEDENT
def checkTriangle ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT a = ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) NEW_LINE if a == 0 : NEW_LINE INDENT print ( 'No' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 'Yes' ) NEW_LINE DEDENT DEDENT
def numTrip ( points ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( points ) ) : NEW_LINE INDENT map = { } NEW_LINE for j in range ( len ( points ) ) : NEW_LINE INDENT if ( j == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT dy = points [ i ] [ 1 ] - points [ j ] [ 1 ] NEW_LINE dx = points [ i ] [ 0 ] - points [ j ] [ 0 ] NEW_LINE key = dy * dy NEW_LINE key += dx * dx NEW_LINE map [ key ] = map . get ( key , 0 ) + 1 NEW_LINE DEDENT for p in map : NEW_LINE INDENT res += map [ p ] * ( map [ p ] - 1 ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def checkOverlap ( R , Xc , Yc , X1 , Y1 , X2 , Y2 ) : NEW_LINE INDENT Xn = max ( X1 , min ( Xc , X2 ) ) NEW_LINE Yn = max ( Y1 , min ( Yc , Y2 ) ) NEW_LINE Dx = Xn - Xc NEW_LINE Dy = Yn - Yc NEW_LINE return ( Dx ** 2 + Dy ** 2 ) <= R ** 2 NEW_LINE DEDENT
def area_of_circle ( m , n ) : NEW_LINE INDENT square_of_radius = ( m * n ) / 4 NEW_LINE area = ( 3.141 * square_of_radius ) NEW_LINE return area NEW_LINE DEDENT
def direction ( R , C ) : NEW_LINE INDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( "Left" ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( "Up" ) NEW_LINE return NEW_LINE DEDENT if R == C and R % 2 != 0 and C % 2 != 0 : NEW_LINE INDENT print ( "Right" ) NEW_LINE return NEW_LINE DEDENT if R == C and R % 2 == 0 and C % 2 == 0 : NEW_LINE INDENT print ( "Left" ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( "Right" ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : NEW_LINE INDENT print ( "Down" ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( "Left" ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( "Up" ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : NEW_LINE INDENT print ( "Down" ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( "Right" ) NEW_LINE return NEW_LINE DEDENT DEDENT
def checkIntersection ( p1 , p2 , p ) : NEW_LINE INDENT if ( p1 [ 1 ] == p2 [ 1 ] and p1 [ 1 ] == p [ 1 ] ) : NEW_LINE INDENT if ( p [ 0 ] <= max ( p1 [ 0 ] , p2 [ 0 ] ) and ( p [ 0 ] >= min ( p1 [ 0 ] , p2 [ 0 ] ) ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( p1 [ 0 ] == p2 [ 0 ] and p1 [ 0 ] == p [ 0 ] ) : NEW_LINE INDENT if ( p [ 1 ] <= max ( p1 [ 1 ] , p2 [ 1 ] ) and ( p [ 1 ] >= min ( p1 [ 1 ] , p2 [ 1 ] ) ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT val = ( ( p [ 1 ] - p1 [ 1 ] ) * ( p2 [ 0 ] - p1 [ 0 ] ) - ( p [ 0 ] - p1 [ 0 ] ) * ( p2 [ 1 ] - p1 [ 1 ] ) ) NEW_LINE if ( val == 0 ) : NEW_LINE INDENT if ( ( p [ 0 ] <= max ( p1 [ 0 ] , p2 [ 0 ] ) and ( p [ 0 ] >= min ( p1 [ 0 ] , p2 [ 0 ] ) ) ) and ( p [ 1 ] <= max ( p1 [ 1 ] , p2 [ 1 ] ) and ( p [ 1 ] >= min ( p1 [ 1 ] , p2 [ 1 ] ) ) ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT
def towerOfSight ( a , b , c , d ) : NEW_LINE INDENT flag = 0 NEW_LINE if ( checkIntersection ( a , c , b ) ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( checkIntersection ( a , c , d ) ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( checkIntersection ( b , d , a ) ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( checkIntersection ( b , d , c ) ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def NotParallel ( p , n ) : NEW_LINE INDENT x_axis = { } NEW_LINE y_axis = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] [ 0 ] not in x_axis : NEW_LINE INDENT x_axis [ p [ i ] [ 0 ] ] = 0 NEW_LINE DEDENT x_axis [ p [ i ] [ 0 ] ] += 1 NEW_LINE if p [ i ] [ 1 ] not in y_axis : NEW_LINE INDENT y_axis [ p [ i ] [ 1 ] ] = 0 NEW_LINE DEDENT y_axis [ p [ i ] [ 1 ] ] += 1 NEW_LINE DEDENT total = ( n * ( n - 1 ) ) // 2 NEW_LINE for i in x_axis : NEW_LINE INDENT c = x_axis [ i ] NEW_LINE total -= ( c * ( c - 1 ) ) // 2 NEW_LINE DEDENT for i in y_axis : NEW_LINE INDENT c = y_axis [ i ] NEW_LINE total -= ( c * ( c - 1 ) ) // 2 NEW_LINE DEDENT return total NEW_LINE DEDENT
def checkTypeOfTriangle ( a , b , c ) : NEW_LINE INDENT sqa = pow ( a , 2 ) NEW_LINE sqb = pow ( b , 2 ) NEW_LINE sqc = pow ( c , 2 ) NEW_LINE if ( sqa == sqa + sqb or sqb == sqa + sqc or sqc == sqa + sqb ) : NEW_LINE INDENT print ( "Right-angled Triangle" ) NEW_LINE DEDENT elif ( sqa > sqc + sqb or sqb > sqa + sqc or sqc > sqa + sqb ) : NEW_LINE INDENT print ( "Obtuse-angled Triangle" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Acute-angled Triangle" ) NEW_LINE DEDENT DEDENT
def lineFromPoints ( P , Q , a , b , c ) : NEW_LINE INDENT a = Q [ 1 ] - P [ 1 ] NEW_LINE b = P [ 0 ] - Q [ 0 ] NEW_LINE c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) NEW_LINE return a , b , c NEW_LINE DEDENT
def LineInterX ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT determ = a1 * b2 - a2 * b1 NEW_LINE x = ( b2 * c1 - b1 * c2 ) NEW_LINE x /= determ NEW_LINE return x NEW_LINE DEDENT
def LineInterY ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT determ = a1 * b2 - a2 * b1 NEW_LINE y = ( a1 * c2 - a2 * c1 ) NEW_LINE print ( y ) NEW_LINE y /= determ NEW_LINE return y NEW_LINE DEDENT
def findPosition ( P , Q , R , D ) : NEW_LINE INDENT r = [ 0 , 0 ] NEW_LINE a , b , c = lineFromPoints ( P , Q , 0 , 0 , 0 ) NEW_LINE e , f , g = lineFromPoints ( Q , R , 0 , 0 , 0 ) NEW_LINE a , b , c = perpenBisectorFromLine ( P , Q , a , b , c ) NEW_LINE e , f , g = perpenBisectorFromLine ( Q , R , e , f , g ) NEW_LINE r [ 0 ] = LineInterX ( a , b , c , e , f , g ) NEW_LINE r [ 1 ] = LineInterY ( a , b , c , e , f , g ) NEW_LINE q = ( ( r [ 0 ] - P [ 0 ] ) * ( r [ 0 ] - P [ 0 ] ) + ( r [ 1 ] - P [ 1 ] ) * ( r [ 1 ] - P [ 1 ] ) ) NEW_LINE dis = ( ( r [ 0 ] - D [ 0 ] ) * ( r [ 0 ] - D [ 0 ] ) + ( r [ 1 ] - D [ 1 ] ) * ( r [ 1 ] - D [ 1 ] ) ) NEW_LINE if ( dis < q ) : NEW_LINE INDENT print ( "Point (" , D [ 0 ] , "," , D [ 1 ] , ") is inside the circumcircle" ) NEW_LINE DEDENT elif ( dis == q ) : NEW_LINE INDENT print ( "Point (" , D [ 0 ] , "," , D [ 1 ] , ") lies on the circumcircle" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Point (" , D [ 0 ] , "," , D [ 1 ] , ") lies outside the circumcircle" ) NEW_LINE DEDENT DEDENT
def disp ( row_no , block ) : NEW_LINE INDENT print ( row_no * block ) NEW_LINE DEDENT
def row ( ht , h ) : NEW_LINE INDENT return ht // h NEW_LINE DEDENT
def calculate ( l , w , h , a , ht ) : NEW_LINE INDENT no_block = ( 4 * a ) // l NEW_LINE if ( h < w ) : NEW_LINE INDENT row_no = row ( ht , w ) NEW_LINE DEDENT else : NEW_LINE INDENT row_no = row ( ht , h ) NEW_LINE DEDENT disp ( row_no , no_block ) NEW_LINE DEDENT
def solve ( s ) : NEW_LINE INDENT area = ( 1.732 * s ** 2 ) / 8 NEW_LINE return area NEW_LINE DEDENT
def area ( R ) : NEW_LINE INDENT base = 1.732 * R NEW_LINE height = ( 3 / 2 ) * R NEW_LINE area = ( ( 1 / 2 ) * base * height ) NEW_LINE return area NEW_LINE DEDENT
def spiralPrint ( m , n , a , c ) : NEW_LINE INDENT k = 0 NEW_LINE l = 0 NEW_LINE count = 0 NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count == c ) : NEW_LINE INDENT print ( a [ k ] [ i ] , end = " " ) NEW_LINE DEDENT DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count == c ) : NEW_LINE INDENT print ( a [ i ] [ n - 1 ] , end = " " ) NEW_LINE DEDENT DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count == c ) : NEW_LINE INDENT print ( a [ m - 1 ] [ i ] , end = " " ) NEW_LINE DEDENT DEDENT m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count == c ) : NEW_LINE INDENT print ( a [ i ] [ l ] , end = " " ) NEW_LINE DEDENT DEDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT
def find_Area ( a ) : NEW_LINE INDENT R = a * ( 2.0 - sqrt ( 2 ) ) NEW_LINE area = 3.14 * R * R / 2.0 NEW_LINE return area NEW_LINE DEDENT
def times ( steps , n ) : NEW_LINE INDENT current_level = 0 NEW_LINE previous_level = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT previous_level = current_level NEW_LINE current_level = current_level + steps [ i ] NEW_LINE if ( ( previous_level < 0 and current_level >= 0 ) or ( previous_level > 0 and current_level <= 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def solve ( n , m , obstacles , rangee ) : NEW_LINE INDENT val = min ( n , m ) NEW_LINE rangee = sorted ( rangee ) NEW_LINE c = 1 NEW_LINE for i in range ( obstacles - 1 , - 1 , - 1 ) : NEW_LINE INDENT rangee [ i ] = 2 * rangee [ i ] NEW_LINE val -= rangee [ i ] NEW_LINE if ( val <= 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( val > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def equation_plane ( p , q , r ) : NEW_LINE INDENT x1 = p [ 0 ] NEW_LINE y1 = p [ 1 ] NEW_LINE z1 = p [ 2 ] NEW_LINE x2 = q [ 0 ] NEW_LINE y2 = q [ 1 ] NEW_LINE z2 = q [ 2 ] NEW_LINE x3 = r [ 0 ] NEW_LINE y3 = r [ 1 ] NEW_LINE z3 = r [ 2 ] NEW_LINE a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE A = b1 * c2 - b2 * c1 NEW_LINE B = a2 * c1 - a1 * c2 NEW_LINE C = a1 * b2 - b1 * a2 NEW_LINE D = ( - A * x1 - B * y1 - C * z1 ) NEW_LINE print ( XandYandZintercept ( A , B , C , D ) ) NEW_LINE DEDENT
def countPairs ( P , Q , N , M ) : NEW_LINE INDENT A = [ 0 ] * 2 NEW_LINE B = [ 0 ] * 2 NEW_LINE for i in range ( N ) : NEW_LINE INDENT A [ P [ i ] % 2 ] += 1 NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT B [ Q [ i ] % 2 ] += 1 NEW_LINE DEDENT return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) NEW_LINE DEDENT
def find_angle ( x , y , z ) : NEW_LINE INDENT volume = x * x * y NEW_LINE ans = 0 NEW_LINE if ( z < volume // 2 ) : NEW_LINE INDENT d = ( x * y * y ) / ( 2.0 * z ) NEW_LINE ans = atan ( d ) NEW_LINE DEDENT else : NEW_LINE INDENT z = volume - z NEW_LINE d = ( 2 * z ) / ( float ) ( x * x * x ) NEW_LINE ans = atan ( d ) NEW_LINE DEDENT ans = ( ans * 180 ) / 3.14159265 NEW_LINE return round ( ans , 4 ) NEW_LINE DEDENT
def FindPoints ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE v . append ( [ 0 , 0 ] ) NEW_LINE v . append ( [ 0 , n ] ) NEW_LINE v . append ( [ n , 0 ] ) NEW_LINE v . append ( [ n , n ] ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT v . append ( [ n // 2 , n // 2 ] ) NEW_LINE DEDENT return v NEW_LINE DEDENT
def findsolution ( d , h , m , n ) : NEW_LINE INDENT k = ( 4 * m ) / ( pie * d * d ) NEW_LINE if ( n > k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = ( h / ( k - n ) ) NEW_LINE return round ( ans , 5 ) NEW_LINE DEDENT
def find_Centroid ( v ) : NEW_LINE INDENT ans = [ 0 , 0 ] NEW_LINE n = len ( v ) NEW_LINE signedArea = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT x0 = v [ i ] [ 0 ] NEW_LINE y0 = v [ i ] [ 1 ] NEW_LINE x1 = v [ ( i + 1 ) % n ] [ 0 ] NEW_LINE y1 = v [ ( i + 1 ) % n ] [ 1 ] NEW_LINE A = ( x0 * y1 ) - ( x1 * y0 ) NEW_LINE signedArea += A NEW_LINE ans [ 0 ] += ( x0 + x1 ) * A NEW_LINE ans [ 1 ] += ( y0 + y1 ) * A NEW_LINE DEDENT signedArea *= 0.5 NEW_LINE ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) NEW_LINE ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) NEW_LINE return ans NEW_LINE DEDENT
def sumOfInternalAngles ( n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( ( n - 2 ) * 180 ) NEW_LINE DEDENT
def cntWays ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n - 2 ) // 4 NEW_LINE DEDENT DEDENT
def noOfTriangles ( n ) : NEW_LINE INDENT y = 4 * n NEW_LINE return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) // 6 NEW_LINE DEDENT
def angle ( n ) : NEW_LINE INDENT return 2 * n NEW_LINE DEDENT
def checkDiagonal ( mat , i , j ) : NEW_LINE INDENT res = mat [ i ] [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE while ( i < N and j < M ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != res ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def ifRight ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT a = ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE b = ( ( x1 - x3 ) * ( x1 - x3 ) ) + ( ( y1 - y3 ) * ( y1 - y3 ) ) NEW_LINE c = ( ( x2 - x3 ) * ( x2 - x3 ) ) + ( ( y2 - y3 ) * ( y2 - y3 ) ) NEW_LINE if ( ( a == ( b + c ) and a != 0 and b != 0 and c != 0 ) or ( b == ( a + c ) and a != 0 and b != 0 and c != 0 ) or ( c == ( a + b ) and a != 0 and b != 0 and c != 0 ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT
def isValidCombination ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE possible = 0 NEW_LINE if ( ifRight ( x1 , y1 , x2 , y2 , x3 , y3 ) ) : NEW_LINE INDENT print ( "ALREADY RIGHT ANGLED" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 4 ) : NEW_LINE INDENT x = dx [ i ] + x1 NEW_LINE y = dy [ i ] + y1 NEW_LINE if ( ifRight ( x , y , x2 , y2 , x3 , y3 ) ) : NEW_LINE INDENT print ( "POSSIBLE" ) NEW_LINE return NEW_LINE DEDENT x = dx [ i ] + x2 NEW_LINE y = dy [ i ] + y2 NEW_LINE if ( ifRight ( x1 , y1 , x , y , x3 , y3 ) ) : NEW_LINE INDENT print ( "POSSIBLE" ) NEW_LINE return NEW_LINE DEDENT x = dx [ i ] + x3 NEW_LINE y = dy [ i ] + y3 NEW_LINE if ( ifRight ( x1 , y1 , x2 , y2 , x , y ) ) : NEW_LINE INDENT print ( "POSSIBLE" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if ( possible == 0 ) : NEW_LINE INDENT print ( "NOT POSSIBLE" ) NEW_LINE DEDENT DEDENT
def area_of_regular_polygon ( n , len ) : NEW_LINE INDENT P = ( len * n ) NEW_LINE A = len / ( 2 * math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE area = ( P * A ) / 2 NEW_LINE return area NEW_LINE DEDENT
def area_of_triangle_inscribed ( n , len ) : NEW_LINE INDENT area = area_of_regular_polygon ( n , len ) NEW_LINE triangle = area / n NEW_LINE ins_tri = ( triangle * 3 ) NEW_LINE return ins_tri NEW_LINE DEDENT
def maxRegions ( n ) : NEW_LINE INDENT num = n * ( n + 1 ) // 2 + 1 NEW_LINE print ( num ) NEW_LINE DEDENT
def pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT fx1 = a * x1 + b * y1 - c NEW_LINE fx2 = a * x2 + b * y2 - c NEW_LINE if ( ( fx1 * fx2 ) > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def Area ( d , h1 , h2 ) : NEW_LINE INDENT area = 0.5 * d * ( h1 + h2 ) NEW_LINE return area NEW_LINE DEDENT
def diagonal_length ( a ) : NEW_LINE INDENT L = 0 NEW_LINE L = a * sqrt ( 3 ) NEW_LINE return L NEW_LINE DEDENT
def find_area ( r , d ) : NEW_LINE INDENT R = d / PI NEW_LINE R += pow ( r , 2 ) NEW_LINE R = sqrt ( R ) NEW_LINE area = PI * pow ( R , 2 ) NEW_LINE return area NEW_LINE DEDENT
def Valid ( a , b , c , d ) : NEW_LINE INDENT if ( a + b + c + d == 360 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def Valid ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c == 180 ) and a != 0 and b != 0 and c != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def calculate_angle ( n ) : NEW_LINE INDENT total_angle = 360 NEW_LINE return ( total_angle // n ) NEW_LINE DEDENT
def areaOfKite ( a , b , angle ) : NEW_LINE INDENT angle = angle * PI NEW_LINE area = a * b * math . sin ( angle ) NEW_LINE return area NEW_LINE DEDENT
def angleOncirCumference ( z ) : NEW_LINE INDENT return ( z / 2 ) NEW_LINE DEDENT
def newvol ( x ) : NEW_LINE INDENT print ( "percentage increase" "in the volume of the cube is " , ( ( x ** ( 3 ) ) / 10000 + 3 * x + ( 3 * ( x ** ( 2 ) ) ) / 100 ) , "%" ) NEW_LINE DEDENT
def newvol ( x ) : NEW_LINE INDENT
def countZeroes ( mat ) : NEW_LINE INDENT row = N - 1 NEW_LINE col = 0 NEW_LINE count = 0 NEW_LINE while ( col < N ) : NEW_LINE INDENT while ( mat [ row ] [ col ] ) : NEW_LINE INDENT if ( row < 0 ) : NEW_LINE INDENT return count NEW_LINE DEDENT row = row - 1 NEW_LINE DEDENT count = count + ( row + 1 ) NEW_LINE col = col + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def newvol ( x ) : NEW_LINE INDENT print ( "percentage increase in the volume of the cylinder is " , x , "%" ) NEW_LINE DEDENT
def radius ( n , d ) : NEW_LINE INDENT print ( "The side of each square is " , d / ( ( n - 1 ) * ( 2 ** ( 1 / 2 ) ) ) ) NEW_LINE DEDENT
def findTriangles ( n ) : NEW_LINE INDENT num = n NEW_LINE print ( num , end = " " ) NEW_LINE print ( num * ( num - 4 ) * ( num - 5 ) // 6 ) NEW_LINE DEDENT
def radius ( n , d ) : NEW_LINE INDENT print ( "The radius of each circle is " , d / ( 2 * n - 2 ) ) NEW_LINE DEDENT
def radius ( n , d ) : NEW_LINE INDENT print ( "The side of each square is " , d / ( n - 1 ) ) NEW_LINE DEDENT
def innerCirclearea ( radius ) : NEW_LINE INDENT if ( radius < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = radius / 2 NEW_LINE Area = ( 3.14 * pow ( r , 2 ) ) NEW_LINE return Area NEW_LINE DEDENT
def areaOfTriangle ( d ) : NEW_LINE INDENT c = 1.618 * d NEW_LINE s = ( d + c + c ) / 2 NEW_LINE area = math . sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) NEW_LINE return 5 * area NEW_LINE DEDENT
def areaOfRegPentagon ( d ) : NEW_LINE INDENT global PI NEW_LINE cal = 4 * math . tan ( PI / 5 ) NEW_LINE area = ( 5 * d * d ) / cal NEW_LINE return area NEW_LINE DEDENT
def areaOfPentagram ( d ) : NEW_LINE INDENT return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) NEW_LINE DEDENT
def lengperpbisect ( r1 , r2 ) : NEW_LINE INDENT z = 2 * ( ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ** ( 1 / 2 ) ) NEW_LINE print ( "The length of the perpendicular bisector is " , z ) NEW_LINE DEDENT
def anglequichord ( z ) : NEW_LINE INDENT print ( "The angle is " , z , " degrees" ) NEW_LINE DEDENT
def lengchord ( z ) : NEW_LINE INDENT print ( "The length is " , end = "" ) NEW_LINE print ( z ) NEW_LINE DEDENT
def angleextcycquad ( z ) : NEW_LINE INDENT print ( "The exterior angle of the" , end = "" ) NEW_LINE print ( "cyclic quadrilateral is " , end = "" ) NEW_LINE print ( z , " degrees" ) NEW_LINE DEDENT
def anglechordtang ( z ) : NEW_LINE INDENT print ( "The angle between tangent" , "and the chord is" , z , "degrees" ) NEW_LINE DEDENT
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ** ( .5 ) NEW_LINE if ( distSq + r2 == r1 ) : NEW_LINE INDENT print ( "The smaller circle lies completely" " inside the bigger circle with " "touching each other " "at a point of circumference. " ) NEW_LINE DEDENT elif ( distSq + r2 < r1 ) : NEW_LINE INDENT print ( "The smaller circle lies completely" " inside the bigger circle without" " touching each other " "at a point of circumference. " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "The smaller does not lies inside" " the bigger circle completely." ) NEW_LINE DEDENT DEDENT
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) NEW_LINE radSumSq = ( r1 + r2 ) * ( r1 + r2 ) NEW_LINE if ( distSq == radSumSq ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( distSq > radSumSq ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def countOdd ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE i = n - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT m = int ( ( n - i ) / 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) / 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = int ( ( ( n - 1 ) - i ) / 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) / 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return coun NEW_LINE DEDENT
def countEven ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE i = n - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT m = int ( ( ( n - 1 ) - i ) / 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) / 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = int ( ( n - i ) / 2 ) NEW_LINE j = ( i * ( i + 1 ) ) // 2 NEW_LINE coun += j * m NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE j = m - 1 NEW_LINE while j >= 0 and i < n : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE INDENT count += ( j + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if ( b != 0 ) : NEW_LINE INDENT return GCD ( b , a % b ) NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT
def ratiotang ( r1 , r2 ) : NEW_LINE INDENT print ( "The ratio is" , r1 // GCD ( r1 , r2 ) , ":" , r2 // GCD ( r1 , r2 ) ) NEW_LINE DEDENT
def Regions ( Vertices , Edges ) : NEW_LINE INDENT R = Edges + 2 - Vertices NEW_LINE return R NEW_LINE DEDENT
def ratiotang ( r1 , r2 ) : NEW_LINE INDENT print ( "The ratio is" , int ( r1 / gcd ( r1 , r2 ) ) , ":" , int ( r2 / gcd ( r1 , r2 ) ) ) NEW_LINE DEDENT
def lengthOfTangent ( r1 , r2 , d ) : NEW_LINE INDENT print ( "The length of the transverse" , "common tangent is" , '{0:.6g}' . format ( sqrt ( pow ( d , 2 ) - pow ( ( r1 + r2 ) , 2 ) ) ) ) NEW_LINE DEDENT
def remainingArea ( N , M , K ) : NEW_LINE INDENT while ( K > 0 and N > 0 and M > 0 ) : NEW_LINE INDENT if ( N > M ) : NEW_LINE INDENT N = N - M NEW_LINE DEDENT else : NEW_LINE INDENT M = M - N NEW_LINE DEDENT K = K - 1 NEW_LINE DEDENT if ( N > 0 and M > 0 ) : NEW_LINE INDENT return N * M NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def lengtang ( r1 , r2 , d ) : NEW_LINE INDENT print ( "The length of the direct common tangent is " , ( ( d ** 2 ) - ( ( r1 - r2 ) ** 2 ) ) ** ( 1 / 2 ) ) NEW_LINE DEDENT
def rad ( d , h ) : NEW_LINE INDENT print ( "The radius of the circle is" , ( ( d * d ) / ( 8 * h ) + h / 2 ) ) NEW_LINE DEDENT
def lengtang ( r1 , r2 ) : NEW_LINE INDENT print ( "The length of the direct" , "common tangent is" , 2 * ( r1 * r2 ) ** ( 1 / 2 ) ) NEW_LINE DEDENT
def diameter ( r ) : NEW_LINE INDENT print ( "The length of the longest chord" , " or diameter of the circle is " , 2 * r ) NEW_LINE DEDENT
def dist ( m , b1 , b2 ) : NEW_LINE INDENT d = abs ( b2 - b1 ) / ( ( m * m ) - 1 ) NEW_LINE return d NEW_LINE DEDENT
def getSlope ( m ) : NEW_LINE INDENT return m NEW_LINE DEDENT
def totalTriangles ( h , v ) : NEW_LINE INDENT if ( h == 0 and v == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( h == 0 ) : NEW_LINE INDENT return ( ( v + 1 ) * ( v + 2 ) / 2 ) NEW_LINE DEDENT if ( v == 0 ) : NEW_LINE INDENT return ( h + 1 ) NEW_LINE DEDENT total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) NEW_LINE return total NEW_LINE DEDENT
def findLargestPlus ( mat ) : NEW_LINE INDENT left = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE right = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE top = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE bottom = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT top [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] NEW_LINE left [ i ] [ 0 ] = mat [ i ] [ 0 ] NEW_LINE right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] [ j ] = 0 NEW_LINE DEDENT if ( mat [ j ] [ i ] == 1 ) : NEW_LINE INDENT top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT top [ j ] [ i ] = 0 NEW_LINE DEDENT j = N - 1 - j NEW_LINE if ( mat [ j ] [ i ] == 1 ) : NEW_LINE INDENT bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT bottom [ j ] [ i ] = 0 NEW_LINE DEDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] [ j ] = 0 NEW_LINE DEDENT j = N - 1 - j NEW_LINE DEDENT DEDENT n = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT l = min ( min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) NEW_LINE if ( l > n ) : NEW_LINE INDENT n = l NEW_LINE DEDENT DEDENT DEDENT if ( n ) : NEW_LINE INDENT return 4 * ( n - 1 ) + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def noOfSquares ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT dx = abs ( x2 - x1 ) NEW_LINE dy = abs ( y2 - y1 ) NEW_LINE ans = dx + dy - gcd ( dx , dy ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def countSteps ( x , y ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT return x + y + 2 * ( ( y - x ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return x + y + 2 * ( ( ( x - y ) + 1 ) // 2 ) NEW_LINE DEDENT DEDENT
def isSlopeGood ( slope , arr , n ) : NEW_LINE INDENT setOfLines = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT setOfLines [ arr [ i ] - slope * ( i ) ] = 1 NEW_LINE DEDENT return len ( setOfLines ) == 2 NEW_LINE DEDENT
def checkForParallel ( arr , n ) : NEW_LINE INDENT slope1 = isSlopeGood ( arr [ 1 ] - arr [ 0 ] , arr , n ) NEW_LINE slope2 = isSlopeGood ( arr [ 2 ] - arr [ 1 ] , arr , n ) NEW_LINE slope3 = isSlopeGood ( ( arr [ 2 ] - arr [ 0 ] ) // 2 , arr , n ) NEW_LINE return ( slope1 or slope2 or slope3 ) NEW_LINE DEDENT
def countPaths ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m = abs ( x1 - x2 ) NEW_LINE n = abs ( y1 - y2 ) NEW_LINE return ( binomialCoeff ( m + n , n ) ) NEW_LINE DEDENT
def findFourthVertex ( n , m , s ) : NEW_LINE INDENT row = dict . fromkeys ( range ( n ) , 0 ) NEW_LINE col = dict . fromkeys ( range ( m ) , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( s [ i ] [ j ] == '*' ) : NEW_LINE INDENT row [ i ] += 1 NEW_LINE col [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for keys , values in row . items ( ) : NEW_LINE INDENT if ( values == 1 ) : NEW_LINE INDENT x = keys NEW_LINE DEDENT DEDENT for keys , values in col . items ( ) : NEW_LINE INDENT if ( values == 1 ) : NEW_LINE INDENT y = keys NEW_LINE DEDENT DEDENT return ( x + 1 , y + 1 ) NEW_LINE DEDENT
def sph ( r , R , h ) : NEW_LINE INDENT if ( r < 0 and R < 0 and h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = r NEW_LINE V = ( 4 * 3.14 * pow ( r , 3 ) ) / 3 NEW_LINE return V NEW_LINE DEDENT
def Area ( a , b ) : NEW_LINE INDENT if ( a < 0 and b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = math . sqrt ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) NEW_LINE A = 0.70477 * pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT
def maxRectangles ( L , B , l , b ) : NEW_LINE INDENT horizontal , vertical = 0 , 0 NEW_LINE if l <= L and b <= B : NEW_LINE INDENT columns = B // b NEW_LINE rows = L // l NEW_LINE horizontal = rows * columns NEW_LINE DEDENT if l <= B and b <= L : NEW_LINE INDENT columns = L // b NEW_LINE rows = B // l NEW_LINE vertical = rows * columns NEW_LINE DEDENT return max ( horizontal , vertical ) NEW_LINE DEDENT
def cone ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = ( a * math . sqrt ( 2 ) ) / 3 NEW_LINE h = ( 2 * a ) / 3 NEW_LINE V = 3.14 * math . pow ( r , 2 ) * h NEW_LINE return V NEW_LINE DEDENT
def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.268 * a NEW_LINE A = 0.70477 * math . pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT
def Area ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( 2 * r ) / mt . sqrt ( 5 ) NEW_LINE A = 0.70477 * pow ( x , 2 ) NEW_LINE return A NEW_LINE DEDENT
def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.464 * a NEW_LINE A = 0.70477 * pow ( x , 2 ) NEW_LINE return A NEW_LINE DEDENT
def areaCircle ( b ) : NEW_LINE INDENT area = math . pi * b * b NEW_LINE return area NEW_LINE DEDENT
def areaSquare ( side , fold ) : NEW_LINE INDENT area = side * side NEW_LINE ans = area / pow ( 2 , fold ) NEW_LINE return ans NEW_LINE DEDENT
def checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT if ( x2 - x1 == 0 and x4 - x3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( x2 - x1 == 0 ) : NEW_LINE INDENT m2 = ( y4 - y3 ) / ( x4 - x3 ) NEW_LINE if ( m2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( x4 - x3 == 0 ) : NEW_LINE INDENT m1 = ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE if ( m1 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT m1 = ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE m2 = ( y4 - y3 ) / ( x4 - x3 ) NEW_LINE if ( m1 * m2 == - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT
def square ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.464 * a NEW_LINE return x NEW_LINE DEDENT
def ReuleauxArea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = 0.70477 * 2 * pow ( r , 2 ) NEW_LINE return A NEW_LINE DEDENT
def cyl ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = ( 2 * a * mt . sqrt ( 2 ) ) / 3 NEW_LINE h = ( 2 * a ) / 3 NEW_LINE V = 3.14 * pow ( r , 2 ) * h NEW_LINE return V NEW_LINE DEDENT
def Area ( l , b , h ) : NEW_LINE INDENT if ( l < 0 or b < 0 or h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( l * b ) / ( l + b ) NEW_LINE A = 0.70477 * pow ( x , 2 ) NEW_LINE return A NEW_LINE DEDENT
def isPossible ( x , y , z ) : NEW_LINE INDENT a = x * x + y * y + z * z NEW_LINE a = round ( a , 8 ) NEW_LINE if ( ceil ( a ) == 1 & floor ( a ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def polyapothem ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE DEDENT
def polydiagonal ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( 2 * a * mt . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) NEW_LINE DEDENT
def polyarea ( n , r ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ) NEW_LINE return round ( A , 3 ) NEW_LINE DEDENT
def decdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.902 * a NEW_LINE return d NEW_LINE DEDENT
def hexagonside ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.5176 * a NEW_LINE return x NEW_LINE DEDENT
def hexagonside ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = a // 3 NEW_LINE return x NEW_LINE DEDENT
def hexDiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.73 * a NEW_LINE return d NEW_LINE DEDENT
def pentdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT
def ReuleauxArea ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0.70477 * pow ( a , 2 ) NEW_LINE DEDENT
def calculateSide ( n , r ) : NEW_LINE INDENT theta = 360 / n NEW_LINE theta_in_radians = theta * 3.14 / 180 NEW_LINE return 2 * r * sin ( theta_in_radians / 2 ) NEW_LINE DEDENT
def squareArea ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = ( 1.268 ** 2 ) * ( a ** 2 ) NEW_LINE return area NEW_LINE DEDENT
def hexagonArea ( d ) : NEW_LINE INDENT return ( 3 * sqrt ( 3 ) * pow ( d , 2 ) ) / 8 NEW_LINE DEDENT
def cyl ( r , R , h ) : NEW_LINE INDENT if ( h < 0 and r < 0 and R < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r1 = r NEW_LINE h1 = h NEW_LINE V = 3.14 * pow ( r1 , 2 ) * h1 NEW_LINE return round ( V , 2 ) NEW_LINE DEDENT
def findVolume ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = a / 2 NEW_LINE h = a NEW_LINE V = 3.14 * pow ( r , 2 ) * h NEW_LINE return V NEW_LINE DEDENT
def length_rope ( r ) : NEW_LINE INDENT return ( ( 2 * PI * r ) + 6 * r ) NEW_LINE DEDENT
def cube ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = math . pow ( h , 3 ) NEW_LINE return a NEW_LINE DEDENT
def sph ( r , h ) : NEW_LINE INDENT if ( r < 0 and h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT R = r NEW_LINE return float ( R ) NEW_LINE DEDENT
def cyl ( R ) : NEW_LINE INDENT if ( R < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT V = ( ( 2 * 3.14 * math . pow ( R , 3 ) ) / ( 3 * math . sqrt ( 3 ) ) ) NEW_LINE return float ( V ) NEW_LINE DEDENT
def rod ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT l = ( math . sqrt ( math . pow ( h , 2 ) + 4 * math . pow ( r , 2 ) ) ) NEW_LINE return float ( l ) NEW_LINE DEDENT
def coner ( R ) : NEW_LINE INDENT if ( R < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = ( 2 * math . sqrt ( 2 ) * R ) / 3 NEW_LINE return float ( r ) NEW_LINE DEDENT
def coneh ( R ) : NEW_LINE INDENT if ( R < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = ( 4 * R ) / 3 NEW_LINE return float ( h ) NEW_LINE DEDENT
def coneRadius ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = a / math . sqrt ( 2 ) NEW_LINE return r NEW_LINE DEDENT
def coneHeight ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = a NEW_LINE return h NEW_LINE DEDENT
def largestCube ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 2 * r ) / sqrt ( 3 ) NEW_LINE return a NEW_LINE DEDENT
def sphere ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = a / 2 NEW_LINE return r NEW_LINE DEDENT
def numberOfCuts ( M , N ) : NEW_LINE INDENT result = 0 NEW_LINE result = ( M - 1 ) * ( N - 1 ) NEW_LINE return result NEW_LINE DEDENT
def maxVol ( P , A ) : NEW_LINE INDENT l = ( P - sqrt ( P * P - 24 * A ) ) / 12 NEW_LINE V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) NEW_LINE return V NEW_LINE DEDENT
def maxArea ( perimeter ) : NEW_LINE INDENT length = int ( ceil ( perimeter / 4 ) ) NEW_LINE breadth = int ( floor ( perimeter / 4 ) ) NEW_LINE return length * breadth NEW_LINE DEDENT
def findSegment ( n , m , segment_length ) : NEW_LINE INDENT meet_point = ( 1.0 * n ) / 2.0 NEW_LINE sum = 0 NEW_LINE segment_number = 0 NEW_LINE for i in range ( 0 , m , 1 ) : NEW_LINE INDENT sum += segment_length [ i ] NEW_LINE if ( sum == meet_point ) : NEW_LINE INDENT segment_number = - 1 NEW_LINE break NEW_LINE DEDENT if ( sum > meet_point ) : NEW_LINE INDENT segment_number = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT return segment_number NEW_LINE DEDENT
def countMaxIntersect ( n ) : NEW_LINE INDENT return int ( n * ( n - 1 ) / 2 ) NEW_LINE DEDENT
def equation_parabola ( x1 , y1 , a , b , c ) : NEW_LINE INDENT t = a * a + b * b NEW_LINE a1 = t - ( a * a ) NEW_LINE b1 = t - ( b * b ) NEW_LINE c1 = ( - 2 * t * x1 ) - ( 2 * c * a ) NEW_LINE d1 = ( - 2 * t * y1 ) - ( 2 * c * b ) NEW_LINE e1 = - 2 * a * b NEW_LINE f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) NEW_LINE print ( "equation of parabola is" , a1 , "x^2 +" , b1 , "y^2 +" , c1 , "x +" , d1 , "y + " , e1 , "xy +" , f1 , "= 0." ) NEW_LINE DEDENT
def countRectangles ( l , w ) : NEW_LINE INDENT squareSide = math . gcd ( l , w ) NEW_LINE return ( l * w ) / ( squareSide * squareSide ) NEW_LINE DEDENT
def section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) : NEW_LINE INDENT x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) NEW_LINE y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) NEW_LINE z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) NEW_LINE print ( "(" , x , "," , y , "," , z , ")" ) NEW_LINE DEDENT
def Squares ( n , m , a ) : NEW_LINE INDENT return ( ( ( m + a - 1 ) // a ) * ( ( n + a - 1 ) // a ) ) NEW_LINE DEDENT
def area ( r ) : NEW_LINE INDENT return ( 0.5 ) * ( 3.14 ) * ( r * r ) NEW_LINE DEDENT
def checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) : NEW_LINE INDENT resx = x1 + x2 + x3 NEW_LINE resy = y1 + y2 + y3 NEW_LINE resz = z1 + z2 + z3 NEW_LINE if ( resx == 0 and resy == 0 and resz == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def hexadiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a NEW_LINE DEDENT
def octadiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return a * math . sqrt ( 4 + ( 2 * math . sqrt ( 2 ) ) ) NEW_LINE DEDENT
def CalPeri ( ) : NEW_LINE INDENT s = 5 NEW_LINE Perimeter = 10 * s NEW_LINE print ( "The Perimeter of Decagon is : " , Perimeter ) NEW_LINE DEDENT
def octaside ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT s = a / ( sqrt ( 2 ) + 1 ) NEW_LINE return s NEW_LINE DEDENT
def findEdges ( s1 , s2 , s3 ) : NEW_LINE INDENT a = math . sqrt ( s1 * s2 / s3 ) NEW_LINE b = math . sqrt ( s3 * s1 / s2 ) NEW_LINE c = math . sqrt ( s3 * s2 / s1 ) NEW_LINE sum = a + b + c NEW_LINE return 4 * sum NEW_LINE DEDENT
def findRadiusOfcircumcircle ( n , a ) : NEW_LINE INDENT if n < 0 or a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT radius = a / sqrt ( 2 - ( 2 * cos ( 360 / n ) ) ) NEW_LINE return radius NEW_LINE DEDENT
def rhombusarea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( l * b ) / 2 NEW_LINE DEDENT
def Arrive ( a , b , n ) : NEW_LINE INDENT if ( n >= abs ( a ) + abs ( b ) and ( n - ( abs ( a ) + abs ( b ) ) ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def Move ( a , x , b ) : NEW_LINE INDENT if ( ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 ) and a + 1 != b ) and b >= a ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def area ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = a * b NEW_LINE return A NEW_LINE DEDENT
def circle_inscribed ( a ) : NEW_LINE INDENT return pi * ( a * a ) / 12 NEW_LINE DEDENT
def surfaceArea ( a , b , h ) : NEW_LINE INDENT return 5 * a * b + 5 * b * h NEW_LINE DEDENT
def volume ( b , h ) : NEW_LINE INDENT return ( 5 * b * h ) / 2 NEW_LINE DEDENT
def findRadiusOfcircumcircle ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT radius = ( math . sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ) NEW_LINE return radius NEW_LINE DEDENT
def circlearea ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT p = ( a + b + c ) / 2 NEW_LINE At = math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) NEW_LINE A = 3.14 * pow ( ( ( a * b * c ) / ( 4 * At ) ) , 2 ) NEW_LINE return A NEW_LINE DEDENT
def altitude ( a , b ) : NEW_LINE INDENT return math . sqrt ( pow ( a , 2 ) - ( pow ( b , 2 ) / 4 ) ) NEW_LINE DEDENT
def surfaceArea ( b , s ) : NEW_LINE INDENT return 2 * b * s + pow ( b , 2 ) NEW_LINE DEDENT
def trianglearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = ( l * b ) / 2 NEW_LINE return area NEW_LINE DEDENT
def area ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = sqrt ( a ) / 6 NEW_LINE return area NEW_LINE DEDENT
def halfsquare ( n , x , y ) : NEW_LINE INDENT half = n // 2 NEW_LINE if ( ( half == x or half == x - 1 ) and ( half == y or half == y - 1 ) ) : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT DEDENT
def checkpoint ( h , k , x , y , a ) : NEW_LINE INDENT p = pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) NEW_LINE return p NEW_LINE DEDENT
def checkpoint ( h , k , x , y , a , b ) : NEW_LINE INDENT p = ( ( math . pow ( ( x - h ) , 2 ) // math . pow ( a , 2 ) ) + ( math . pow ( ( y - k ) , 2 ) // math . pow ( b , 2 ) ) ) NEW_LINE return p NEW_LINE DEDENT
def area ( x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT area = math . sqrt ( ( y1 * z2 - y2 * z1 ) ** 2 + ( x1 * z2 - x2 * z1 ) ** 2 + ( x1 * y2 - x2 * y1 ) ** 2 ) NEW_LINE area = area / 2 NEW_LINE return area NEW_LINE DEDENT
def trianglearea ( a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = ( 3 * sqrt ( 3 ) * pow ( a , 2 ) ) / ( 4 * b ) NEW_LINE return area NEW_LINE DEDENT
def squarearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = 4 * ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) NEW_LINE return area NEW_LINE DEDENT
def longestRodInCuboid ( length , breadth , height ) : NEW_LINE INDENT temp = length * length + breadth * breadth + height * height NEW_LINE result = sqrt ( temp ) NEW_LINE return result NEW_LINE DEDENT
def trianglearea ( r ) : NEW_LINE INDENT if r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return r * r NEW_LINE DEDENT
def squarearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = 4 * ( pow ( r , 2 ) / 5 ) NEW_LINE return a NEW_LINE DEDENT
def rectanglearea ( a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a * b NEW_LINE DEDENT
def trapezoidarea ( r ) : NEW_LINE INDENT if r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 3 * sqrt ( 3 ) * pow ( r , 2 ) ) / 4 NEW_LINE return a NEW_LINE DEDENT
def squareArea ( l , b , h ) : NEW_LINE INDENT if l < 0 or b < 0 or h < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( l * b ) / ( l + b ) NEW_LINE return a * a NEW_LINE DEDENT
def circlearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ) NEW_LINE return A NEW_LINE DEDENT
def circlearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( l < b ) : NEW_LINE INDENT return 3.14 * pow ( l // 2 , 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 3.14 * pow ( b // 2 , 2 ) NEW_LINE DEDENT DEDENT
def maxLines ( n , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT s = [ ] NEW_LINE slope = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( x1 [ i ] == x2 [ i ] ) : NEW_LINE INDENT slope = sys . maxsize NEW_LINE DEDENT else : NEW_LINE INDENT slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 NEW_LINE DEDENT s . append ( slope ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT
def squares ( l , b , a ) : NEW_LINE INDENT return math . ceil ( l / a ) * math . ceil ( b / a ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT
def squarearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT n = ( l * b ) / gcd ( l , b ) NEW_LINE return n * n NEW_LINE DEDENT
def angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) : NEW_LINE INDENT num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) NEW_LINE den = math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) * math . sqrt ( ( x3 - x1 ) ** 2 + ( y3 - y1 ) ** 2 + ( z3 - z1 ) ** 2 ) NEW_LINE angle = math . degrees ( math . acos ( num / den ) ) NEW_LINE return round ( angle , 3 ) NEW_LINE DEDENT
def is_partition_possible ( n , x , y , w ) : NEW_LINE INDENT weight_at_x = defaultdict ( int ) NEW_LINE max_x = - 2e3 NEW_LINE min_x = 2e3 NEW_LINE for i in range ( n ) : NEW_LINE INDENT new_x = x [ i ] - y [ i ] NEW_LINE max_x = max ( max_x , new_x ) NEW_LINE min_x = min ( min_x , new_x ) NEW_LINE weight_at_x [ new_x ] += w [ i ] NEW_LINE DEDENT sum_till = [ ] NEW_LINE sum_till . append ( 0 ) NEW_LINE for x in range ( min_x , max_x + 1 ) : NEW_LINE INDENT sum_till . append ( sum_till [ - 1 ] + weight_at_x [ x ] ) NEW_LINE DEDENT total_sum = sum_till [ - 1 ] NEW_LINE partition_possible = False NEW_LINE for i in range ( 1 , len ( sum_till ) ) : NEW_LINE INDENT if ( sum_till [ i ] == total_sum - sum_till [ i ] ) : NEW_LINE INDENT partition_possible = True NEW_LINE DEDENT if ( sum_till [ i - 1 ] == total_sum - sum_till [ i ] ) : NEW_LINE INDENT partition_possible = True NEW_LINE DEDENT DEDENT if partition_possible : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def makePolygon ( a ) : NEW_LINE INDENT n = 360 / ( 180 - a ) NEW_LINE if n == int ( n ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT if ( x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def area ( x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT area = math . sqrt ( ( y1 * z2 - y2 * z1 ) ** 2 + ( x1 * z2 - x2 * z1 ) ** 2 + ( x1 * y2 - x2 * y1 ) ** 2 ) NEW_LINE return area NEW_LINE DEDENT
def equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) : NEW_LINE INDENT a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE a = b1 * c2 - b2 * c1 NEW_LINE b = a2 * c1 - a1 * c2 NEW_LINE c = a1 * b2 - b1 * a2 NEW_LINE d = ( - a * x1 - b * y1 - c * z1 ) NEW_LINE if ( a * x + b * y + c * z + d == 0 ) : NEW_LINE INDENT print ( "Coplanar" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Not Coplanar" ) NEW_LINE DEDENT DEDENT
def solve ( M , N , s ) : NEW_LINE INDENT if ( N % s == 0 ) : NEW_LINE INDENT N = N // s NEW_LINE DEDENT else : NEW_LINE INDENT N = ( N // s ) + 1 NEW_LINE DEDENT if ( M % s == 0 ) : NEW_LINE INDENT M = M // s NEW_LINE DEDENT else : NEW_LINE INDENT M = ( M // s ) + 1 NEW_LINE DEDENT return M * N NEW_LINE DEDENT
def max_intersection ( center , length , k ) : NEW_LINE INDENT center . sort ( ) NEW_LINE if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( center [ 2 ] - center [ 0 ] >= 2 * k ) : NEW_LINE INDENT return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return length NEW_LINE DEDENT DEDENT
def FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT x5 = max ( x1 , x3 ) NEW_LINE y5 = max ( y1 , y3 ) NEW_LINE x6 = min ( x2 , x4 ) NEW_LINE y6 = min ( y2 , y4 ) NEW_LINE if ( x5 > x6 or y5 > y6 ) : NEW_LINE INDENT print ( "No intersection" ) NEW_LINE return NEW_LINE DEDENT print ( "(" , x5 , ", " , y5 , ") " , end = " " ) NEW_LINE print ( "(" , x6 , ", " , y6 , ") " , end = " " ) NEW_LINE x7 = x5 NEW_LINE y7 = y6 NEW_LINE print ( "(" , x7 , ", " , y7 , ") " , end = " " ) NEW_LINE x8 = x6 NEW_LINE y8 = y5 NEW_LINE print ( "(" , x8 , ", " , y8 , ") " ) NEW_LINE DEDENT
def FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT if ( x > x1 and x < x2 and y > y1 and y < y2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) : NEW_LINE INDENT if ( a1 / a2 == b1 / b2 and b1 / b2 == c1 / c2 ) : NEW_LINE INDENT x1 = y1 = 0 NEW_LINE z1 = - d1 / c1 NEW_LINE d = abs ( ( c2 * z1 + d2 ) ) / ( math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) NEW_LINE print ( "Perpendicular distance is" ) , d NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Planes are not parallel" ) NEW_LINE DEDENT DEDENT
def distance ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT d = ( a1 * a2 + b1 * b2 + c1 * c2 ) NEW_LINE e1 = math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) NEW_LINE e2 = math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) NEW_LINE d = d / ( e1 * e2 ) NEW_LINE A = math . degrees ( math . acos ( d ) ) NEW_LINE print ( "Angle is" ) , A , ( "degree" ) NEW_LINE DEDENT
def haversine ( lat1 , lon1 , lat2 , lon2 ) : NEW_LINE INDENT dLat = ( lat2 - lat1 ) * math . pi / 180.0 NEW_LINE dLon = ( lon2 - lon1 ) * math . pi / 180.0 NEW_LINE lat1 = ( lat1 ) * math . pi / 180.0 NEW_LINE lat2 = ( lat2 ) * math . pi / 180.0 NEW_LINE a = ( pow ( math . sin ( dLat / 2 ) , 2 ) + pow ( math . sin ( dLon / 2 ) , 2 ) * math . cos ( lat1 ) * math . cos ( lat2 ) ) NEW_LINE rad = 6371 NEW_LINE c = 2 * math . asin ( math . sqrt ( a ) ) NEW_LINE return rad * c NEW_LINE DEDENT
def equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) : NEW_LINE INDENT a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE a = b1 * c2 - b2 * c1 NEW_LINE b = a2 * c1 - a1 * c2 NEW_LINE c = a1 * b2 - b1 * a2 NEW_LINE d = ( - a * x1 - b * y1 - c * z1 ) NEW_LINE print "equation of plane is " , NEW_LINE print a , "x +" , NEW_LINE print b , "y +" , NEW_LINE print c , "z +" , NEW_LINE print d , "= 0." NEW_LINE DEDENT
def findVolume ( l , b , h ) : NEW_LINE INDENT return ( ( l * b * h ) / 2 ) NEW_LINE DEDENT
def countNumberOfTriangles ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) * ( n - 2 ) // 6 ) NEW_LINE DEDENT
def countRectangles ( radius ) : NEW_LINE INDENT rectangles = 0 NEW_LINE diameter = 2 * radius NEW_LINE diameterSquare = diameter * diameter NEW_LINE for a in range ( 1 , 2 * radius ) : NEW_LINE INDENT for b in range ( 1 , 2 * radius ) : NEW_LINE INDENT diagonalLengthSquare = ( a * a + b * b ) NEW_LINE if ( diagonalLengthSquare <= diameterSquare ) : NEW_LINE INDENT rectangles += 1 NEW_LINE DEDENT DEDENT DEDENT return rectangles NEW_LINE DEDENT
def simi_aaa ( a1 , a2 ) : NEW_LINE INDENT a1 = [ float ( i ) for i in a1 ] NEW_LINE a2 = [ float ( i ) for i in a2 ] NEW_LINE a1 . sort ( ) NEW_LINE a2 . sort ( ) NEW_LINE if a1 [ 0 ] == a2 [ 0 ] and a1 [ 1 ] == a2 [ 1 ] and a1 [ 2 ] == a2 [ 2 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def simi_sas ( s1 , s2 , a1 , a2 ) : NEW_LINE INDENT s1 = [ float ( i ) for i in s1 ] NEW_LINE s2 = [ float ( i ) for i in s2 ] NEW_LINE a1 = [ float ( i ) for i in a1 ] NEW_LINE a2 = [ float ( i ) for i in a2 ] NEW_LINE s1 . sort ( ) NEW_LINE s2 . sort ( ) NEW_LINE a1 . sort ( ) NEW_LINE a2 . sort ( ) NEW_LINE if s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] : NEW_LINE INDENT if a1 [ 2 ] == a2 [ 2 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] : NEW_LINE INDENT if a1 [ 0 ] == a2 [ 0 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] : NEW_LINE INDENT if a1 [ 1 ] == a2 [ 1 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def simi_sss ( s1 , s2 ) : NEW_LINE INDENT s1 = [ float ( i ) for i in s1 ] NEW_LINE s2 = [ float ( i ) for i in s2 ] NEW_LINE s1 . sort ( ) NEW_LINE s2 . sort ( ) NEW_LINE if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] and s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] and s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def centeredDodecagonal ( n ) : NEW_LINE INDENT return 6 * n * ( n - 1 ) + 1 NEW_LINE DEDENT
def heptagonalNumber ( n ) : NEW_LINE INDENT return ( ( 5 * n * n ) - ( 3 * n ) ) // 2 NEW_LINE DEDENT
def centeredTridecagonalNum ( n ) : NEW_LINE INDENT return ( 13 * n * ( n - 1 ) + 2 ) // 2 NEW_LINE DEDENT
def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) / 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT
def pentagon_pyramidal ( n ) : NEW_LINE INDENT return n * n * ( n + 1 ) / 2 NEW_LINE DEDENT
def checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) : NEW_LINE INDENT return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) NEW_LINE DEDENT
def getQuadrant ( X , Y , R , PX , PY ) : NEW_LINE INDENT if ( PX == X and PY == Y ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT val = ( math . pow ( ( PX - X ) , 2 ) + math . pow ( ( PY - Y ) , 2 ) ) NEW_LINE if ( val > pow ( R , 2 ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( PX > X and PY >= Y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( PX <= X and PY > Y ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( PX < X and PY <= Y ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( PX >= X and PY < Y ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT DEDENT
def center_pentadecagonal_num ( n ) : NEW_LINE INDENT return ( 15 * n * n - 15 * n + 2 ) // 2 NEW_LINE DEDENT
def icosidigonal_num ( n ) : NEW_LINE INDENT return ( 20 * n * n - 18 * n ) // 2 NEW_LINE DEDENT
def center_nonadecagon_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 19 * n + 2 ) // 2 NEW_LINE DEDENT
def center_octadecagon_num ( n ) : NEW_LINE INDENT return ( 9 * n * n - 9 * n + 1 ) NEW_LINE DEDENT
def hendecagonal_num ( n ) : NEW_LINE INDENT return ( 9 * n * n - 7 * n ) // 2 NEW_LINE DEDENT
def centereddecagonalnum ( n ) : NEW_LINE INDENT return ( 5 * n * n + 5 * n + 1 ) NEW_LINE DEDENT
def Ksmallest ( x , y , k ) : NEW_LINE INDENT if x == 0 and y == 0 : NEW_LINE INDENT return NEW_LINE DEDENT elif x == 0 : NEW_LINE INDENT y -= 1 NEW_LINE print ( "V" , end = "" ) NEW_LINE Ksmallest ( x , y , k ) NEW_LINE DEDENT elif y == 0 : NEW_LINE INDENT x -= 1 NEW_LINE print ( "H" , end = "" ) NEW_LINE Ksmallest ( x , y , k ) NEW_LINE DEDENT else : NEW_LINE INDENT if factorial ( x - 1 , y ) > k : NEW_LINE INDENT print ( "H" , end = "" ) NEW_LINE Ksmallest ( x - 1 , y , k ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "V" , end = "" ) NEW_LINE Ksmallest ( x , y - 1 , k - factorial ( x - 1 , y ) ) NEW_LINE DEDENT DEDENT DEDENT
def nthEnneadecagonal ( n ) : NEW_LINE INDENT return ( 17 * n * n - 15 * n ) // 2 NEW_LINE DEDENT
def inorder ( root ) : NEW_LINE INDENT if root is not None : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print "TABSYMBOL%d" % ( root . data ) , NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT
def centered_pentagonal_Num ( n ) : NEW_LINE INDENT return ( 5 * n * n - 5 * n + 2 ) // 2 NEW_LINE DEDENT
def findPoint ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( "(" , 2 * x2 - x1 , "," , 2 * y2 - y1 , ")" ) NEW_LINE DEDENT
def pivotDis ( x0 , y0 , x1 , y1 ) : NEW_LINE INDENT return math . sqrt ( ( x1 - x0 ) * ( x1 - x0 ) + ( y1 - y0 ) * ( y1 - y0 ) ) NEW_LINE DEDENT
def minDis ( D , r1 , r2 ) : NEW_LINE INDENT return max ( ( D - r1 - r2 ) , 0 ) NEW_LINE DEDENT
def maxDis ( D , r1 , r2 ) : NEW_LINE INDENT return D + r1 + r2 NEW_LINE DEDENT
def findPCSlope ( m ) : NEW_LINE INDENT return - 1.0 / m NEW_LINE DEDENT
def otherEndPoint ( x1 , y1 , m1 , m2 ) : NEW_LINE INDENT x2 = ( 2 * m1 - x1 ) NEW_LINE y2 = ( 2 * m2 - y1 ) NEW_LINE print ( "x2 = {}, y2 = {}" . format ( x2 , y2 ) ) NEW_LINE DEDENT
def isValid ( arr , i , j , m , c ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return False NEW_LINE DEDENT lhs = arr [ j ] NEW_LINE rhs = m * arr [ i ] + c NEW_LINE return ( lhs == rhs ) NEW_LINE DEDENT
def findOrderedPoints ( arr , n , m , c ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT firstIndex = i NEW_LINE secondIndex = j NEW_LINE if ( isValid ( arr , firstIndex , secondIndex , m , c ) ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT
def numberOfSticks ( x ) : NEW_LINE INDENT return ( 3 * x * ( x + 1 ) ) / 2 NEW_LINE DEDENT
def overlappingArea ( l1 , r1 , l2 , r2 ) : NEW_LINE INDENT x = 0 NEW_LINE y = 1 NEW_LINE area1 = abs ( l1 [ x ] - r1 [ x ] ) * abs ( l1 [ y ] - r1 [ y ] ) NEW_LINE area2 = abs ( l2 [ x ] - r2 [ x ] ) * abs ( l2 [ y ] - r2 [ y ] ) NEW_LINE x_dist = ( min ( r1 [ x ] , r2 [ x ] ) - max ( l1 [ x ] , l2 [ x ] ) ) NEW_LINE y_dist = ( min ( r1 [ y ] , r2 [ y ] ) - max ( l1 [ y ] , l2 [ y ] ) ) NEW_LINE areaI = 0 NEW_LINE if x_dist > 0 and y_dist > 0 : NEW_LINE INDENT areaI = x_dist * y_dist NEW_LINE DEDENT return ( area1 + area2 - areaI ) NEW_LINE DEDENT
def checkOrigin ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) NEW_LINE DEDENT
def checkcircle ( r , R , r1 , x1 , y1 ) : NEW_LINE INDENT dis = int ( math . sqrt ( x1 * x1 + y1 * y1 ) ) NEW_LINE return ( dis - r1 >= R and dis + r1 <= r ) NEW_LINE DEDENT
def areacircumscribed ( a ) : NEW_LINE INDENT return ( a * a * ( PI / 2 ) ) NEW_LINE DEDENT
def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT
def find_Area ( r ) : NEW_LINE INDENT return ( 2 * r * r ) NEW_LINE DEDENT
def checkValidity ( a , b , c ) : NEW_LINE INDENT if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if ( a == b and d == c ) or ( a == c and b == d ) or ( a == d and b == c ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def nCk ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = min ( i , k ) NEW_LINE while ( j > 0 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE j = j - 1 NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT
def count_Straightlines ( n , m ) : NEW_LINE INDENT return ( nCk ( n , 2 ) - nCk ( m , 2 ) + 1 ) NEW_LINE DEDENT
def isBetween ( a , b , c ) : NEW_LINE INDENT return min ( a , b ) <= c and c <= max ( a , b ) NEW_LINE DEDENT
def canJoin ( x , y , i , j , k ) : NEW_LINE INDENT return ( x [ k ] == x [ i ] or x [ k ] == x [ j ] ) and isBetween ( y [ i ] , y [ j ] , y [ k ] ) or ( y [ k ] == y [ i ] or y [ k ] == y [ j ] ) and isBetween ( x [ i ] , x [ j ] , x [ k ] ) NEW_LINE DEDENT
def countLineSegments ( x , y ) : NEW_LINE INDENT if ( ( x [ 0 ] == x [ 1 ] and x [ 1 ] == x [ 2 ] ) or ( y [ 0 ] == y [ 1 ] and y [ 1 ] == y [ 2 ] ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( canJoin ( x , y , 0 , 1 , 2 ) or canJoin ( x , y , 0 , 2 , 1 ) or canJoin ( x , y , 1 , 2 , 0 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT
def vol_of_dodecahedron ( side ) : NEW_LINE INDENT return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) ) / 4 ) * ( math . pow ( side , 3 ) ) ) NEW_LINE DEDENT
def perimeter ( diameter , height ) : NEW_LINE INDENT return 2 * ( diameter + height ) NEW_LINE DEDENT
def area_of_segment ( radius , angle ) : NEW_LINE INDENT area_of_sector = pi * ( radius * radius ) NEW_LINE * ( angle / 360 ) area_of_triangle = 1 / 2 * ( radius * radius ) * math . sin ( ( angle * pi ) / 180 ) NEW_LINE return area_of_sector - area_of_triangle NEW_LINE DEDENT
def midpoint ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( x1 + x2 ) // 2 , " , " , ( y1 + y2 ) // 2 ) NEW_LINE DEDENT
def contribution_height ( current , previous ) : NEW_LINE INDENT return abs ( current - previous ) NEW_LINE DEDENT
def surfaceArea ( A ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT up = 0 NEW_LINE left = 0 NEW_LINE if ( i > 0 ) : NEW_LINE INDENT up = A [ i - 1 ] [ j ] NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT left = A [ i ] [ j - 1 ] NEW_LINE DEDENT ans += contribution_height ( A [ i ] [ j ] , up ) + contribution_height ( A [ i ] [ j ] , left ) NEW_LINE if ( i == N - 1 ) : NEW_LINE INDENT ans += A [ i ] [ j ] NEW_LINE DEDENT if ( j == M - 1 ) : NEW_LINE INDENT ans += A [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT ans += N * M * 2 NEW_LINE return ans NEW_LINE DEDENT
def area_of_tetrahedron ( side ) : NEW_LINE INDENT return ( math . sqrt ( 3 ) * ( side * side ) ) NEW_LINE DEDENT
def vol_tetra ( side ) : NEW_LINE INDENT volume = ( side ** 3 / ( 6 * math . sqrt ( 2 ) ) ) NEW_LINE return round ( volume , 2 ) NEW_LINE DEDENT
def overflow ( H , r , h , N , R ) : NEW_LINE INDENT tank_cap = 3.14 * r * r * H NEW_LINE water_vol = 3.14 * r * r * h NEW_LINE balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R NEW_LINE vol = water_vol + balls_vol NEW_LINE if vol > tank_cap : NEW_LINE INDENT print ( "Overflow" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Not in overflow state" ) NEW_LINE DEDENT DEDENT
def volume ( radius , height ) : NEW_LINE INDENT return ( ( 22 / 7 ) * radius * radius * height ) NEW_LINE DEDENT
def maxvolume ( s ) : NEW_LINE INDENT maxvalue = 0 NEW_LINE i = 1 NEW_LINE for i in range ( s - 1 ) : NEW_LINE INDENT j = 1 NEW_LINE for j in range ( s ) : NEW_LINE INDENT k = s - i - j NEW_LINE maxvalue = max ( maxvalue , i * j * k ) NEW_LINE DEDENT DEDENT return maxvalue NEW_LINE DEDENT
def maxvolume ( s ) : NEW_LINE INDENT length = int ( s / 3 ) NEW_LINE s -= length NEW_LINE breadth = s / 2 NEW_LINE height = s - breadth NEW_LINE return int ( length * breadth * height ) NEW_LINE DEDENT
def volumeOfEllipsoid ( r1 , r2 , r3 ) : NEW_LINE INDENT return 1.33 * math . pi * r1 * r2 * r3 NEW_LINE DEDENT
def slope ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT if x1 == x2 : NEW_LINE INDENT return ( sys . maxsize ) NEW_LINE DEDENT return ( ( y2 - y1 ) / ( x2 - x1 ) ) NEW_LINE DEDENT
def cal_cos ( n ) : NEW_LINE INDENT accuracy = 0.0001 NEW_LINE x1 , denominator , cosx , cosval = 0 , 0 , 0 , 0 NEW_LINE n = n * ( 3.142 / 180.0 ) NEW_LINE x1 = 1 NEW_LINE cosx = x1 NEW_LINE cosval = mt . cos ( n ) NEW_LINE i = 1 NEW_LINE while ( accuracy <= abs ( cosval - cosx ) ) : NEW_LINE INDENT denominator = 2 * i * ( 2 * i - 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE cosx = cosx + x1 NEW_LINE i = i + 1 NEW_LINE DEDENT return cosx NEW_LINE DEDENT
def third_side ( a , b , c ) : NEW_LINE INDENT angle = cal_cos ( c ) NEW_LINE return mt . sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) NEW_LINE DEDENT
def volumeTriangular ( a , b , h ) : NEW_LINE INDENT return ( 0.1666 ) * a * b * h NEW_LINE DEDENT
def volumeSquare ( b , h ) : NEW_LINE INDENT return ( 0.33 ) * b * b * h NEW_LINE DEDENT
def volumePentagonal ( a , b , h ) : NEW_LINE INDENT return ( 0.83 ) * a * b * h NEW_LINE DEDENT
def volumeHexagonal ( a , b , h ) : NEW_LINE INDENT return a * b * h NEW_LINE DEDENT
def areaOctagon ( side ) : NEW_LINE INDENT return ( 2 * ( 1 + ( math . sqrt ( 2 ) ) ) * side * side ) NEW_LINE DEDENT
def Area ( b1 , b2 , h ) : NEW_LINE INDENT return ( ( b1 + b2 ) / 2 ) * h NEW_LINE DEDENT
def hexagonArea ( s ) : NEW_LINE INDENT return ( ( 3 * math . sqrt ( 3 ) * ( s * s ) ) / 2 ) NEW_LINE DEDENT
def findCommon ( mat ) : NEW_LINE INDENT column = [ N - 1 ] * M NEW_LINE min_row = 0 NEW_LINE while ( column [ min_row ] >= 0 ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) : NEW_LINE INDENT min_row = i NEW_LINE DEDENT DEDENT eq_count = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) : NEW_LINE INDENT if ( column [ i ] == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT column [ i ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT eq_count += 1 NEW_LINE DEDENT DEDENT if ( eq_count == M ) : NEW_LINE INDENT return mat [ min_row ] [ column [ min_row ] ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def Circumference ( a ) : NEW_LINE INDENT return ( 4 * a ) NEW_LINE DEDENT
def arcLength ( diameter , angle ) : NEW_LINE INDENT if angle >= 360 : NEW_LINE INDENT print ( "Angle cannot be formed" ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) NEW_LINE return arc NEW_LINE DEDENT DEDENT
def SectorArea ( radius , angle ) : NEW_LINE INDENT pi = 22 / 7 NEW_LINE if angle >= 360 : NEW_LINE INDENT print ( "Angle not possible" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT sector = ( pi * radius ** 2 ) * ( angle / 360 ) NEW_LINE print ( sector ) NEW_LINE return NEW_LINE DEDENT DEDENT
def findCommon ( mat ) : NEW_LINE INDENT global M NEW_LINE global N NEW_LINE cnt = dict ( ) NEW_LINE cnt = defaultdict ( lambda : 0 , cnt ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < M ) : NEW_LINE INDENT cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 NEW_LINE j = 1 NEW_LINE while ( j < N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) : NEW_LINE INDENT cnt [ mat [ i ] [ j ] ] = cnt [ mat [ i ] [ j ] ] + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT for ele in cnt : NEW_LINE INDENT if ( cnt [ ele ] == M ) : NEW_LINE INDENT return ele NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def surfaceAreaCuboid ( l , h , w ) : NEW_LINE INDENT return ( 2 * l * w + 2 * w * h + 2 * l * h ) NEW_LINE DEDENT
def surfaceCube ( a ) : NEW_LINE INDENT return ( 6 * a * a ) NEW_LINE DEDENT
def minRadius ( k , x , y , n ) : NEW_LINE INDENT dis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] NEW_LINE DEDENT dis . sort ( ) NEW_LINE return dis [ k - 1 ] NEW_LINE DEDENT
def areaRectangle ( a , b ) : NEW_LINE INDENT return ( a * b ) NEW_LINE DEDENT
def perimeterRectangle ( a , b ) : NEW_LINE INDENT return ( 2 * ( a + b ) ) NEW_LINE DEDENT
def areaSquare ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT
def maxSquare ( b , m ) : NEW_LINE INDENT return ( b / m - 1 ) * ( b / m ) / 2 NEW_LINE DEDENT
def minPerimeter ( n ) : NEW_LINE INDENT l = math . sqrt ( n ) NEW_LINE sq = l * l NEW_LINE if ( sq == n ) : NEW_LINE INDENT return l * 4 NEW_LINE DEDENT else : NEW_LINE INDENT row = n / l NEW_LINE perimeter = 2 * ( l + row ) NEW_LINE if ( n % l != 0 ) : NEW_LINE INDENT perimeter += 2 NEW_LINE DEDENT return perimeter NEW_LINE DEDENT DEDENT
def checkCollision ( a , b , c , x , y , radius ) : NEW_LINE INDENT dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ) NEW_LINE if ( radius == dist ) : NEW_LINE INDENT print ( "Touch" ) NEW_LINE DEDENT elif ( radius > dist ) : NEW_LINE INDENT print ( "Intersect" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Outside" ) NEW_LINE DEDENT DEDENT
def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) : NEW_LINE INDENT dis1 = ( pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ) NEW_LINE dis2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ) NEW_LINE if ( dis1 != dis2 ) : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT elif ( b1 == ( ( a1 + c1 ) // 2.0 ) and b2 == ( ( a2 + c2 ) // 2.0 ) ) : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT DEDENT
def replaceSurrounded ( mat ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 'O' ) : NEW_LINE INDENT mat [ i ] [ j ] = '-' NEW_LINE DEDENT DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == '-' ) : NEW_LINE INDENT floodFillUtil ( mat , i , 0 , '-' , 'O' ) NEW_LINE DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ N - 1 ] == '-' ) : NEW_LINE INDENT floodFillUtil ( mat , i , N - 1 , '-' , 'O' ) NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == '-' ) : NEW_LINE INDENT floodFillUtil ( mat , 0 , i , '-' , 'O' ) NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( mat [ M - 1 ] [ i ] == '-' ) : NEW_LINE INDENT floodFillUtil ( mat , M - 1 , i , '-' , 'O' ) NEW_LINE DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == '-' ) : NEW_LINE INDENT mat [ i ] [ j ] = 'X' NEW_LINE DEDENT DEDENT DEDENT DEDENT
def fitOrNotFit ( R , r , x , y , rad ) : NEW_LINE INDENT val = math . sqrt ( math . pow ( x , 2 ) + math . pow ( y , 2 ) ) NEW_LINE if ( val + rad <= R and val - rad >= R - r ) : NEW_LINE INDENT print ( "Fits" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Doesn't Fit" ) NEW_LINE DEDENT DEDENT
def check ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 , x , y ) : NEW_LINE INDENT A = ( area ( x1 , y1 , x2 , y2 , x3 , y3 ) + area ( x1 , y1 , x4 , y4 , x3 , y3 ) ) NEW_LINE A1 = area ( x , y , x1 , y1 , x2 , y2 ) NEW_LINE A2 = area ( x , y , x2 , y2 , x3 , y3 ) NEW_LINE A3 = area ( x , y , x3 , y3 , x4 , y4 ) NEW_LINE A4 = area ( x , y , x1 , y1 , x4 , y4 ) NEW_LINE return ( A == A1 + A2 + A3 + A4 ) NEW_LINE DEDENT
def rectCount ( n , m ) : NEW_LINE INDENT return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4 NEW_LINE DEDENT
def countObtuseAngles ( a , b , k ) : NEW_LINE INDENT c1 = ( b - a ) - 1 NEW_LINE c2 = ( k - b ) + ( a - 1 ) NEW_LINE if ( c1 == c2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( c1 , c2 ) NEW_LINE DEDENT
def countRect ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for length in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT height = length NEW_LINE while ( height * length <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE height += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isPolygonPossible ( arr , N ) : NEW_LINE INDENT limit = sqrt ( N ) NEW_LINE for i in range ( 1 , int ( limit ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( checkPolygonWithMidpoints ( arr , N , i ) or checkPolygonWithMidpoints ( arr , N , ( N // i ) ) ) : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT DEDENT print ( "Not possiblen" ) NEW_LINE DEDENT
def minRevolutions ( r , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE return math . ceil ( d / ( 2 * r ) ) NEW_LINE DEDENT
def inside ( a , p ) : NEW_LINE INDENT mid = [ 0 , 0 ] NEW_LINE n = len ( a ) NEW_LINE p [ 0 ] *= n NEW_LINE p [ 1 ] *= n NEW_LINE for i in range ( n ) : NEW_LINE INDENT mid [ 0 ] += a [ i ] [ 0 ] NEW_LINE mid [ 1 ] += a [ i ] [ 1 ] NEW_LINE a [ i ] [ 0 ] *= n NEW_LINE a [ i ] [ 1 ] *= n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT j = ( i + 1 ) % n NEW_LINE x1 = a [ i ] [ 0 ] NEW_LINE x2 = a [ j ] [ 0 ] NEW_LINE y1 = a [ i ] [ 1 ] NEW_LINE y2 = a [ j ] [ 1 ] NEW_LINE a1 = y1 - y2 NEW_LINE b1 = x2 - x1 NEW_LINE c1 = x1 * y2 - y1 * x2 NEW_LINE for_mid = a1 * mid [ 0 ] + b1 * mid [ 1 ] + c1 NEW_LINE for_p = a1 * p [ 0 ] + b1 * p [ 1 ] + c1 NEW_LINE if ( for_mid * for_p < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def addPoint ( a , p ) : NEW_LINE INDENT arr = copy . deepcopy ( a ) NEW_LINE prr = p . copy ( ) NEW_LINE if ( inside ( arr , prr ) ) : NEW_LINE INDENT return NEW_LINE DEDENT ind = 0 NEW_LINE n = len ( a ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( sqDist ( p , a [ i ] ) < sqDist ( p , a [ ind ] ) ) : NEW_LINE INDENT ind = i NEW_LINE DEDENT DEDENT up = ind NEW_LINE while ( orientation ( p , a [ up ] , a [ ( up + 1 ) % n ] ) >= 0 ) : NEW_LINE INDENT up = ( up + 1 ) % n NEW_LINE DEDENT low = ind NEW_LINE while ( orientation ( p , a [ low ] , a [ ( n + low - 1 ) % n ] ) <= 0 ) : NEW_LINE INDENT low = ( n + low - 1 ) % n NEW_LINE DEDENT ret = [ ] NEW_LINE curr = up NEW_LINE ret . append ( a [ curr ] ) NEW_LINE while ( curr != low ) : NEW_LINE INDENT curr = ( curr + 1 ) % n NEW_LINE ret . append ( a [ curr ] ) NEW_LINE DEDENT ret . append ( p ) NEW_LINE a . clear ( ) NEW_LINE for i in range ( len ( ret ) ) : NEW_LINE INDENT a . append ( ret [ i ] ) NEW_LINE DEDENT DEDENT
def getDistance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) NEW_LINE DEDENT
def numberOfSquares ( base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = base // 2 NEW_LINE return base * ( base + 1 ) / 2 NEW_LINE DEDENT
def findMaximumPieces ( n ) : NEW_LINE INDENT return int ( 1 + n * ( n + 1 ) / 2 ) NEW_LINE DEDENT
def preprocess ( p , x , y , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT p [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] NEW_LINE DEDENT p . sort ( ) NEW_LINE DEDENT
def query ( p , n , rad ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE while ( ( end - start ) > 1 ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE tp = math . sqrt ( p [ mid ] ) NEW_LINE if ( tp > ( rad * 1.0 ) ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT tp1 = math . sqrt ( p [ start ] ) NEW_LINE tp2 = math . sqrt ( p [ end ] ) NEW_LINE if ( tp1 > ( rad * 1.0 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( tp2 <= ( rad * 1.0 ) ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return start + 1 NEW_LINE DEDENT DEDENT
def getArea ( base , hypotenuse ) : NEW_LINE INDENT height = math . sqrt ( hypotenuse * hypotenuse - base * base ) NEW_LINE return 0.5 * base * height NEW_LINE DEDENT
def printRightAngleTriangle ( hypotenuse , area ) : NEW_LINE INDENT hsquare = hypotenuse * hypotenuse NEW_LINE sideForMaxArea = math . sqrt ( hsquare / 2.0 ) NEW_LINE maxArea = getArea ( sideForMaxArea , hypotenuse ) NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( "Not possiblen" ) NEW_LINE return NEW_LINE DEDENT low = 0.0 NEW_LINE high = sideForMaxArea NEW_LINE while ( abs ( high - low ) > 1e-6 ) : NEW_LINE INDENT base = ( low + high ) / 2.0 NEW_LINE if ( getArea ( base , hypotenuse ) >= area ) : NEW_LINE INDENT high = base NEW_LINE DEDENT else : NEW_LINE INDENT low = base NEW_LINE DEDENT DEDENT height = math . ceil ( math . sqrt ( hsquare - base * base ) ) NEW_LINE base = math . floor ( base ) NEW_LINE print ( base , height ) NEW_LINE DEDENT
def squareRoot ( n ) : NEW_LINE INDENT x = n NEW_LINE y = 1 NEW_LINE while ( x - y > e ) : NEW_LINE INDENT x = ( x + y ) / 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE DEDENT
def findMaximumHeight ( N ) : NEW_LINE INDENT n = 1 + 8 * N NEW_LINE maxH = ( - 1 + squareRoot ( n ) ) / 2 NEW_LINE return int ( maxH ) NEW_LINE DEDENT
def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE DEDENT return int ( abs ( area / 2.0 ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def getCount ( p , q ) : NEW_LINE INDENT if p . x == q . x : NEW_LINE INDENT return abs ( p . y - q . y ) - 1 NEW_LINE DEDENT if p . y == q . y : NEW_LINE INDENT return abs ( p . x - q . x ) - 1 NEW_LINE DEDENT return gcd ( abs ( p . x - q . x ) , abs ( p . y - q . y ) ) - 1 NEW_LINE DEDENT
def getMinSteps ( n ) : NEW_LINE INDENT table = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT table [ i ] = n - i NEW_LINE DEDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( not ( i % 2 ) ) : NEW_LINE INDENT table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] ) NEW_LINE DEDENT if ( not ( i % 3 ) ) : NEW_LINE INDENT table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] ) NEW_LINE DEDENT DEDENT return table [ 1 ] NEW_LINE DEDENT
def distSq ( p , q ) : NEW_LINE INDENT return ( p . x - q . x ) * ( p . x - q . x ) + ( p . y - q . y ) * ( p . y - q . y ) NEW_LINE DEDENT
def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE DEDENT return abs ( area // 2.0 ) NEW_LINE DEDENT
def youngify ( mat , i , j ) : NEW_LINE INDENT downVal = mat [ i + 1 ] [ j ] if ( i + 1 < N ) else INF NEW_LINE rightVal = mat [ i ] [ j + 1 ] if ( j + 1 < N ) else INF NEW_LINE if ( downVal == INF and rightVal == INF ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( downVal < rightVal ) : NEW_LINE INDENT mat [ i ] [ j ] = downVal NEW_LINE mat [ i + 1 ] [ j ] = INF NEW_LINE youngify ( mat , i + 1 , j ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = rightVal NEW_LINE mat [ i ] [ j + 1 ] = INF NEW_LINE youngify ( mat , i , j + 1 ) NEW_LINE DEDENT DEDENT
def extractMin ( mat ) : NEW_LINE INDENT ret = mat [ 0 ] [ 0 ] NEW_LINE mat [ 0 ] [ 0 ] = INF NEW_LINE youngify ( mat , 0 , 0 ) NEW_LINE return ret NEW_LINE DEDENT
def printSorted ( mat ) : NEW_LINE INDENT print ( "Elements of matrix in sorted order n" ) NEW_LINE i = 0 NEW_LINE while i < N * N : NEW_LINE INDENT print ( extractMin ( mat ) , end = " " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def f ( x , p , num ) : NEW_LINE INDENT return pow ( x , p ) - num NEW_LINE DEDENT
def f_prime ( x , p ) : NEW_LINE INDENT return p * pow ( x , p - 1 ) NEW_LINE DEDENT
def minimumAdditionOperation ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N ) : NEW_LINE INDENT if ( N & 1 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT N = N >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def minimumOperations ( arr , N ) : NEW_LINE INDENT mini = INT_MAX NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] // 2 NEW_LINE count += 1 NEW_LINE DEDENT if ( mini > count ) : NEW_LINE INDENT mini = count NEW_LINE DEDENT DEDENT return mini NEW_LINE DEDENT
def minimumSizeArr ( A , B ) : NEW_LINE INDENT currXor = 0 NEW_LINE reminder = ( A - 1 ) % 4 NEW_LINE if ( reminder == 0 ) : NEW_LINE INDENT currXor = A - 1 NEW_LINE DEDENT elif ( reminder == 1 ) : NEW_LINE INDENT currXor = 1 NEW_LINE DEDENT elif ( reminder == 2 ) : NEW_LINE INDENT currXor = A NEW_LINE DEDENT minSize = A NEW_LINE if ( currXor == B ) : NEW_LINE INDENT return minSize NEW_LINE DEDENT elif ( currXor ^ B == A ) : NEW_LINE INDENT return minSize + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return minSize + 1 NEW_LINE DEDENT DEDENT
def modifiedSieve ( ) : NEW_LINE INDENT gpf [ 0 ] = 0 NEW_LINE gpf [ 1 ] = 1 NEW_LINE for i in range ( 2 , maxn ) : NEW_LINE INDENT if ( gpf [ i ] > 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i , maxn , i ) : NEW_LINE INDENT gpf [ j ] = max ( i , gpf [ j ] ) NEW_LINE DEDENT DEDENT DEDENT
def greatestValidInt ( N ) : NEW_LINE INDENT modifiedSieve ( ) NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT if ( gpf [ i ] > math . sqrt ( i ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT global prime NEW_LINE for p in range ( 2 , int ( math . sqrt ( mxn ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , mxn + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countMin ( arr , n ) : NEW_LINE INDENT cMinSwaps = 0 NEW_LINE cPrimeIndices = 0 NEW_LINE cPrimeNos = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( prime [ i + 1 ] ) : NEW_LINE INDENT cPrimeIndices += 1 NEW_LINE if ( not prime [ arr [ i ] ] ) : NEW_LINE INDENT cMinSwaps += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cPrimeNos += 1 NEW_LINE DEDENT DEDENT elif ( prime [ arr [ i ] ] ) : NEW_LINE INDENT cPrimeNos += 1 NEW_LINE DEDENT DEDENT if ( cPrimeNos >= cPrimeIndices ) : NEW_LINE INDENT return cMinSwaps NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def subfactorial ( N ) : NEW_LINE INDENT res = 0 NEW_LINE fact = 1 NEW_LINE count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( count % 2 == 0 ) : NEW_LINE INDENT res = res - ( 1 / fact ) NEW_LINE DEDENT else : NEW_LINE INDENT res = res + ( 1 / fact ) NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return fact * ( 1 + res ) NEW_LINE DEDENT
def minOperations ( A , B , N ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < N and i < N ) : NEW_LINE INDENT if ( B [ i ] == A [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def countPairs ( N ) : NEW_LINE INDENT res = 0 NEW_LINE for q in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT maxP = min ( 2 * N - q , N // q ) NEW_LINE if ( maxP < q ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = maxP - q + 1 NEW_LINE res += ( cnt // 2 + ( cnt & 1 ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def largestSubset ( a , N ) : NEW_LINE INDENT bit = [ 0 for i in range ( 32 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = 31 NEW_LINE while ( a [ i ] > 0 ) : NEW_LINE INDENT if ( a [ i ] & 1 == 1 ) : NEW_LINE INDENT bit [ x ] += 1 NEW_LINE DEDENT a [ i ] = a [ i ] >> 1 NEW_LINE x -= 1 NEW_LINE DEDENT DEDENT print ( max ( bit ) ) NEW_LINE DEDENT
def countDistinctSums ( N , L , R ) : NEW_LINE INDENT minSum = L * N NEW_LINE maxSum = R * N NEW_LINE return maxSum - minSum + 1 NEW_LINE DEDENT
def setSumtoZero ( arr , N ) : NEW_LINE INDENT A = [ 0 for i in range ( N ) ] NEW_LINE sum = 0 NEW_LINE m = - sys . maxsize - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += ceil ( arr [ i ] ) NEW_LINE A [ i ] = ceil ( arr [ i ] ) NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT m = min ( sum , N ) NEW_LINE i = 0 NEW_LINE while ( i < N and m > 0 ) : NEW_LINE INDENT A [ i ] = floor ( arr [ i ] ) NEW_LINE if ( A [ i ] != floor ( arr [ i ] ) ) : NEW_LINE INDENT m -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( A [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def countDivisors ( n ) : NEW_LINE INDENT divisors = 0 NEW_LINE for i in range ( 1 , math . ceil ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT divisors = divisors + 1 NEW_LINE DEDENT if ( i - ( n / i ) == 1 ) : NEW_LINE INDENT i = i - 1 NEW_LINE DEDENT DEDENT for i in range ( math . ceil ( math . sqrt ( n ) ) + 1 , 1 , - 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT divisors = divisors + 1 NEW_LINE DEDENT DEDENT return divisors NEW_LINE DEDENT
def possibleTriplets ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT count = count + countDivisors ( N - i ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def convertToBase9 ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE a = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT ans += ( a * ( n % 9 ) ) NEW_LINE a *= 10 NEW_LINE n //= 9 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def getNthnumber ( base9 , K ) : NEW_LINE INDENT ans = 0 NEW_LINE a = 1 NEW_LINE while ( base9 > 0 ) : NEW_LINE INDENT cur = base9 % 10 NEW_LINE if ( cur >= K ) : NEW_LINE INDENT ans += a * ( cur + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += a * cur NEW_LINE DEDENT base9 //= 10 NEW_LINE a *= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def UniqueGeometricTerms ( N , a1 , r1 , a2 , r2 ) : NEW_LINE INDENT S = set ( ) NEW_LINE p1 = a1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT S . add ( p1 ) NEW_LINE p1 = ( p1 * r1 ) NEW_LINE DEDENT p2 = a2 NEW_LINE for i in range ( N ) : NEW_LINE INDENT S . add ( p2 ) NEW_LINE p2 = ( p2 * r2 ) NEW_LINE DEDENT return len ( S ) NEW_LINE DEDENT
def nearestLeft ( arr , N , steps ) : NEW_LINE INDENT L = - N NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT L = - ( N - i ) NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT L = i NEW_LINE DEDENT steps [ i ] = i - L NEW_LINE DEDENT DEDENT
def findSum ( arr , N , M , K ) : NEW_LINE INDENT steps = [ 0 ] * N NEW_LINE s = sum ( arr ) NEW_LINE if ( s == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT nearestLeft ( arr , N , steps ) NEW_LINE nearestRight ( arr , N , steps ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT s += 2 * K * max ( 0 , M - steps [ i ] ) NEW_LINE DEDENT return s NEW_LINE DEDENT
def countPairs ( L , R ) : NEW_LINE INDENT cntPair = 0 NEW_LINE for a in range ( L , R + 1 , 1 ) : NEW_LINE INDENT for b in range ( a + 1 , R + 1 , 1 ) : NEW_LINE INDENT x = getProduct ( a ) NEW_LINE y = getProduct ( b ) NEW_LINE if ( x and y and ( a * y ) == ( b * x ) ) : NEW_LINE INDENT cntPair += 1 NEW_LINE DEDENT DEDENT DEDENT return cntPair NEW_LINE DEDENT
def maxSum ( matrix ) : NEW_LINE INDENT r = len ( matrix ) NEW_LINE c = len ( matrix [ 0 ] ) NEW_LINE sum = 0 NEW_LINE mini = sys . maxsize NEW_LINE count = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT k = matrix [ i ] [ j ] NEW_LINE mini = min ( mini , abs ( k ) ) NEW_LINE if ( k < 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT sum += abs ( k ) NEW_LINE DEDENT DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT else : NEW_LINE INDENT return ( sum - 2 * mini ) NEW_LINE DEDENT DEDENT
def highestPowerof2 ( n ) : NEW_LINE INDENT p = int ( math . log ( n , 2 ) ) NEW_LINE if p % 2 == 0 : NEW_LINE INDENT p -= 1 NEW_LINE DEDENT return int ( pow ( 2 , p ) ) NEW_LINE DEDENT
def minStep ( N , X ) : NEW_LINE INDENT if N % 2 and X == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT size = 0 NEW_LINE while X < N : NEW_LINE INDENT N -= highestPowerof2 ( N ) NEW_LINE size += 1 NEW_LINE DEDENT if N : NEW_LINE INDENT size += 1 NEW_LINE DEDENT return size NEW_LINE DEDENT
def transpose ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT B [ i ] [ j ] = A [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT
def canPossibleReplacement ( N , arr ) : NEW_LINE INDENT S = sum ( arr ) NEW_LINE DEDENT
def positionAfterKJumps ( X , Y , K ) : NEW_LINE INDENT addY = Y * ( K // 2 ) NEW_LINE reduceX = - 1 * X * ( K // 2 + K % 2 ) NEW_LINE return addY + reduceX NEW_LINE DEDENT
def predictTheWinner ( K , N ) : NEW_LINE INDENT if ( N % ( K + 1 ) == 0 ) : NEW_LINE INDENT print ( "Bob" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Alice" ) NEW_LINE DEDENT DEDENT
def countTriplets ( size , queries , arr , Q ) : NEW_LINE INDENT arr_even = [ 0 for i in range ( size + 1 ) ] NEW_LINE arr_odd = [ 0 for i in range ( size + 1 ) ] NEW_LINE even = 0 NEW_LINE odd = 0 NEW_LINE arr_even [ 0 ] = 0 NEW_LINE arr_odd [ 0 ] = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT arr_even [ i + 1 ] = even NEW_LINE arr_odd [ i + 1 ] = odd NEW_LINE DEDENT for i in range ( queries ) : NEW_LINE INDENT l = Q [ i ] [ 0 ] NEW_LINE r = Q [ i ] [ 1 ] NEW_LINE odd = arr_odd [ r ] - arr_odd [ l - 1 ] NEW_LINE even = arr_even [ r ] - arr_even [ l - 1 ] NEW_LINE ans = ( even * ( even - 1 ) * ( even - 2 ) ) // 6 + ( odd * ( odd - 1 ) // 2 ) * even NEW_LINE print ( ans , end = " " ) NEW_LINE DEDENT DEDENT
def transpose ( A ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
def findMaxK ( N ) : NEW_LINE INDENT K = N NEW_LINE i = N - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT K &= i NEW_LINE if ( K == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ j ] % arr [ i ] == 0 ) and ( j + 1 ) % ( i + 1 ) == 0 and ( arr [ j ] // arr [ i ] == ( j + 1 ) // ( i + 1 ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def smallestMaximum ( N , K ) : NEW_LINE INDENT sum = ( ( N + K - 1 ) // K ) * K NEW_LINE if ( sum % N != 0 ) : NEW_LINE INDENT return ( sum // N ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return sum // N NEW_LINE DEDENT DEDENT
def findMinMax ( a ) : NEW_LINE INDENT min_val = 1000000000 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT min_val = min ( min_val , a [ i ] * a [ i - 1 ] ) NEW_LINE DEDENT return min_val NEW_LINE DEDENT
def add ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
def nCr ( n , r , f ) : NEW_LINE INDENT if ( n < r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return f [ n ] / ( f [ r ] * f [ n - r ] ) NEW_LINE DEDENT
def Min_sum ( arr , N ) : NEW_LINE INDENT min_sum = 1000000 NEW_LINE maxgcd1 = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT gcd1 = 1 NEW_LINE if ( i == 0 ) : NEW_LINE INDENT gcd1 = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT gcd1 = arr [ i - 1 ] NEW_LINE DEDENT for j in range ( N ) : NEW_LINE INDENT if ( j != i ) : NEW_LINE INDENT gcd1 = gcd1OfTwoNos ( gcd1 , arr [ j ] ) NEW_LINE DEDENT DEDENT c = arr [ i ] NEW_LINE if ( gcd1 > maxgcd1 ) : NEW_LINE INDENT maxgcd1 = gcd1 NEW_LINE DEDENT DEDENT return maxgcd1 NEW_LINE DEDENT
def performQuery ( arr , Q ) : NEW_LINE INDENT for i in range ( 0 , len ( Q ) ) : NEW_LINE INDENT orr = 0 NEW_LINE x = Q [ i ] [ 0 ] NEW_LINE arr [ x - 1 ] = Q [ i ] [ 1 ] NEW_LINE for j in range ( 0 , len ( arr ) ) : NEW_LINE INDENT orr = orr | arr [ j ] NEW_LINE DEDENT print ( orr , end = " " ) NEW_LINE DEDENT DEDENT
def subtract ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
def countOddIntegers ( arr , N ) : NEW_LINE INDENT Fact = [ 0 ] * N NEW_LINE Fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT Fact [ i ] = i * Fact [ i - 1 ] NEW_LINE DEDENT freq = [ 0 ] * 10 NEW_LINE for i in range ( len ( freq ) ) : NEW_LINE INDENT freq [ i ] = 0 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq [ arr [ i ] ] + 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , 10 , 2 ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT freq [ i ] = freq [ i ] - 1 NEW_LINE for j in range ( 1 , 10 , 1 ) : NEW_LINE INDENT cur_ans = 0 NEW_LINE if ( freq [ j ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT freq [ j ] = freq [ j ] - 1 NEW_LINE cur_ans = Fact [ N - 2 ] NEW_LINE for k in range ( 10 ) : NEW_LINE INDENT cur_ans = cur_ans / Fact [ freq [ k ] ] NEW_LINE DEDENT ans += cur_ans NEW_LINE freq [ j ] = freq [ j ] + 1 NEW_LINE DEDENT freq [ i ] = freq [ i ] + 1 NEW_LINE DEDENT return ceil ( ans ) NEW_LINE DEDENT
def intCount ( X , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for z in range ( 0 , int ( pow ( 10 , K ) ) , int ( ( pow ( 10 , K ) - 1 ) / 9 ) ) : NEW_LINE INDENT if ( z > X ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += int ( ( X - z ) / int ( pow ( 10 , K ) ) + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def intCountInRange ( L , R , K ) : NEW_LINE INDENT return ( intCount ( R , K ) - intCount ( L - 1 , K ) ) NEW_LINE DEDENT
def findSum ( root , target , K ) : NEW_LINE INDENT kDistanceSum ( root , target , K ) NEW_LINE print ( sum ) NEW_LINE DEDENT
def CountPair ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = arr [ i ] + sumOfDigits ( arr [ i ] ) NEW_LINE if val in mp : NEW_LINE INDENT mp [ val ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ val ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT val = key NEW_LINE times = value NEW_LINE count += ( ( times * ( times - 1 ) ) // 2 ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def isValid ( x , y1 , y2 ) : NEW_LINE INDENT return ( ( x >= 0 and x < R and y1 >= 0 and y1 < C and y2 >= 0 and y2 < C ) ) NEW_LINE DEDENT
def getMaxUtil ( arr , mem , x , y1 , y2 ) : NEW_LINE INDENT if isValid ( x , y1 , y2 ) == False : NEW_LINE INDENT return intmin NEW_LINE DEDENT if x == R - 1 and y1 == 0 and y2 == C - 1 : NEW_LINE INDENT if y1 == y2 : NEW_LINE INDENT return arr [ x ] [ y1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ x ] [ y1 ] + arr [ x ] [ y2 ] NEW_LINE DEDENT DEDENT if x == R - 1 : NEW_LINE INDENT return intmin NEW_LINE DEDENT if mem [ x ] [ y1 ] [ y2 ] != - 1 : NEW_LINE INDENT return mem [ x ] [ y1 ] [ y2 ] NEW_LINE DEDENT ans = intmin NEW_LINE temp = 0 NEW_LINE if y1 == y2 : NEW_LINE INDENT temp = arr [ x ] [ y1 ] NEW_LINE DEDENT else : NEW_LINE INDENT temp = arr [ x ] [ y1 ] + arr [ x ] [ y2 ] NEW_LINE DEDENT ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 - 1 ) ) NEW_LINE ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 + 1 ) ) NEW_LINE ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 ) ) NEW_LINE ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 ) ) NEW_LINE ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 - 1 ) ) NEW_LINE ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 + 1 ) ) NEW_LINE ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 ) ) NEW_LINE ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 - 1 ) ) NEW_LINE ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 + 1 ) ) NEW_LINE mem [ x ] [ y1 ] [ y2 ] = ans NEW_LINE return ans NEW_LINE DEDENT
def geMaxCollection ( arr ) : NEW_LINE INDENT mem = [ [ [ - 1 for i in range ( C ) ] for i in range ( C ) ] for i in range ( R ) ] NEW_LINE return getMaxUtil ( arr , mem , 0 , 0 , C - 1 ) NEW_LINE DEDENT
def printFactors ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT d1 = i NEW_LINE d2 = n NEW_LINE while ( d2 % d1 == 0 ) : NEW_LINE INDENT d2 = d2 // d1 NEW_LINE DEDENT if ( d1 > 1 and d2 > 1 ) : NEW_LINE INDENT print ( d1 , d2 , sep = ", " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def countTriplets ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT c1 = odd * ( even * ( even - 1 ) ) // 2 NEW_LINE c2 = ( odd * ( odd - 1 ) * ( odd - 2 ) ) // 6 NEW_LINE return c1 + c2 NEW_LINE DEDENT
def maxUniqueElements ( A , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] in mp : NEW_LINE INDENT mp [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT DEDENT cnt = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if ( value % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ans = len ( mp ) NEW_LINE if ( cnt % 2 == 1 ) : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countCells ( n , m , s ) : NEW_LINE INDENT mx1 = - 1 NEW_LINE cont1 = 0 NEW_LINE i = 0 NEW_LINE while ( i < s and i < n ) : NEW_LINE INDENT aux = ( n - ( i + 1 ) ) // s + 1 NEW_LINE if ( aux > mx1 ) : NEW_LINE INDENT mx1 = cont1 = aux NEW_LINE DEDENT elif ( aux == mx1 ) : NEW_LINE INDENT cont1 += aux NEW_LINE DEDENT i += 1 NEW_LINE DEDENT mx2 = - 1 NEW_LINE cont2 = 0 NEW_LINE i = 0 NEW_LINE while ( i < s and i < m ) : NEW_LINE INDENT aux = ( m - ( i + 1 ) ) // s + 1 NEW_LINE if ( aux > mx2 ) : NEW_LINE INDENT mx2 = cont2 = aux NEW_LINE DEDENT elif ( aux == mx2 ) : NEW_LINE INDENT cont2 += aux NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return cont1 * cont2 NEW_LINE DEDENT
def build_tree ( b , seg_tree , l , r , vertex ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT seg_tree [ vertex ] = b [ l ] NEW_LINE return NEW_LINE DEDENT mid = int ( ( l + r ) / 2 ) NEW_LINE build_tree ( b , seg_tree , l , mid , 2 * vertex ) NEW_LINE build_tree ( b , seg_tree , mid + 1 , r , 2 * vertex + 1 ) NEW_LINE seg_tree [ vertex ] = __gcd ( seg_tree [ 2 * vertex ] , seg_tree [ 2 * vertex + 1 ] ) NEW_LINE DEDENT
def range_gcd ( seg_tree , v , tl , tr , l , r ) : NEW_LINE INDENT if ( l > r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == tl and r == tr ) : NEW_LINE INDENT return seg_tree [ v ] NEW_LINE DEDENT tm = int ( ( tl + tr ) / 2 ) NEW_LINE return __gcd ( range_gcd ( seg_tree , 2 * v , tl , tm , l , min ( tm , r ) ) , range_gcd ( seg_tree , 2 * v + 1 , tm + 1 , tr , max ( tm + 1 , l ) , r ) ) NEW_LINE DEDENT
def maxSubarrayLen ( arr , n ) : NEW_LINE INDENT seg_tree = [ 0 ] * ( 4 * n + 1 ) NEW_LINE build_tree ( arr , seg_tree , 0 , n - 1 , 1 ) NEW_LINE maxLen = 0 NEW_LINE l , r = 0 , 0 NEW_LINE while ( r < n and l < n ) : NEW_LINE INDENT if ( range_gcd ( seg_tree , 1 , 0 , n - 1 , l , r ) == 1 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT maxLen = max ( maxLen , r - l - 1 ) NEW_LINE r += 1 NEW_LINE DEDENT print ( maxLen , end = "" ) NEW_LINE DEDENT
def can_empty ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c ) % 4 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT m = min ( a , min ( b , c ) ) NEW_LINE if ( m < ( a + b + c ) // 4 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countTotalPairs ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return N * N NEW_LINE DEDENT ans = 0 NEW_LINE for b in range ( K + 1 , N + 1 ) : NEW_LINE INDENT ans += ( N // b ) * ( b - K ) NEW_LINE ans += max ( N % b - K + 1 , 0 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxFrequencySubarrayUtil ( A , N , M ) : NEW_LINE INDENT i = 0 NEW_LINE m = { } NEW_LINE val = 0 NEW_LINE while ( i < M ) : NEW_LINE INDENT if A [ i ] in m : NEW_LINE INDENT m [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ A [ i ] ] = 1 NEW_LINE DEDENT val = max ( val , m [ A [ i ] ] ) NEW_LINE i += 1 NEW_LINE DEDENT print ( val , end = " " ) NEW_LINE for i in range ( M , N , 1 ) : NEW_LINE INDENT if A [ i - M ] in m : NEW_LINE INDENT m [ A [ i - M ] ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ A [ i - M ] ] = 0 NEW_LINE DEDENT if A [ i ] in m : NEW_LINE INDENT m [ A [ i ] ] += 1 NEW_LINE DEDENT val = 0 NEW_LINE for key , value in m . items ( ) : NEW_LINE INDENT val = max ( val , value ) NEW_LINE DEDENT print ( val , end = " " ) NEW_LINE DEDENT DEDENT
def smallest ( k , d ) : NEW_LINE INDENT cnt = 1 NEW_LINE m = d % k NEW_LINE v = [ 0 for i in range ( k ) ] NEW_LINE v [ m ] = 1 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return cnt NEW_LINE DEDENT m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k NEW_LINE if ( v [ m ] == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT v [ m ] = 1 NEW_LINE cnt += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def getPairsCount ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( arr [ i ] - ( i % arr [ i ] ) , n , arr [ i ] ) : NEW_LINE INDENT if ( i < j and abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def minSteps ( N ) : NEW_LINE INDENT count = 1 NEW_LINE res = 0 NEW_LINE for i in range ( 1 , N + 1 , count ) : NEW_LINE INDENT res = max ( res , count ) NEW_LINE count += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countReachablePoints ( X , Y , L , R ) : NEW_LINE INDENT diff_arr = [ 0 for i in range ( 100000 ) ] NEW_LINE count = 0 NEW_LINE diff_arr [ X ] = 1 NEW_LINE diff_arr [ X + 1 ] = - 1 NEW_LINE for i in range ( X , Y + 1 , 1 ) : NEW_LINE INDENT diff_arr [ i ] += diff_arr [ i - 1 ] NEW_LINE if ( diff_arr [ i ] >= 1 ) : NEW_LINE INDENT diff_arr [ i + L ] += 1 NEW_LINE diff_arr [ i + R + 1 ] -= 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def minimumSubarray ( arr , n , m ) : NEW_LINE INDENT mapu = [ 0 for i in range ( m + 1 ) ] NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mapu [ arr [ i ] ] += 1 NEW_LINE if ( mapu [ arr [ i ] ] == ( n // m ) + 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( c == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = n NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while ( r < n ) : NEW_LINE INDENT mapu [ arr [ r ] ] -= 1 NEW_LINE if ( mapu [ arr [ r ] ] == ( n // m ) ) : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT if ( c == 0 ) : NEW_LINE INDENT while ( l <= r and c == 0 ) : NEW_LINE INDENT ans = min ( ans , r - l + 1 ) NEW_LINE mapu [ arr [ l ] ] += 1 NEW_LINE if ( mapu [ arr [ l ] ] > ( n // m ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT r += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findAandB ( N ) : NEW_LINE INDENT K = int ( log2 ( N ) ) NEW_LINE B = ( 1 << K ) NEW_LINE A = B ^ N NEW_LINE print ( A , B ) NEW_LINE DEDENT
def pathCountRec ( mat , m , n , k ) : NEW_LINE INDENT if m < 0 or n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif m == 0 and n == 0 : NEW_LINE INDENT return k == mat [ m ] [ n ] NEW_LINE DEDENT return ( pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ) NEW_LINE DEDENT
def pathCount ( mat , k ) : NEW_LINE INDENT return pathCountRec ( mat , R - 1 , C - 1 , k ) NEW_LINE DEDENT
def minDistance ( start , end , n , d ) : NEW_LINE INDENT left = - sys . maxsize NEW_LINE right = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT left = max ( left , start [ i ] ) NEW_LINE right = min ( right , end [ i ] ) NEW_LINE DEDENT if ( left > right ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( d >= left and d <= right ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( d < left ) : NEW_LINE INDENT return ( left - d ) NEW_LINE DEDENT if ( d > right ) : NEW_LINE INDENT return ( d - right ) NEW_LINE DEDENT DEDENT
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( y % 2 == 0 ) : NEW_LINE INDENT return power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE DEDENT return x * power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE DEDENT
def order ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num ) : NEW_LINE INDENT count += 1 NEW_LINE num = num // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def isArmstrong ( N ) : NEW_LINE INDENT r = order ( N ) NEW_LINE temp = N NEW_LINE sum = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT d = temp % 10 NEW_LINE sum += power ( d , r ) NEW_LINE temp = temp // 10 NEW_LINE DEDENT return ( sum == N ) NEW_LINE DEDENT
def maxSum ( arr , N , K ) : NEW_LINE INDENT if ( N < K ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE DEDENT curr_sum = res NEW_LINE for i in range ( K , N , 1 ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - K ] NEW_LINE res = max ( res , curr_sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxArmstrong ( arr , N , K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT arr [ i ] = isArmstrong ( arr [ i ] ) NEW_LINE DEDENT return maxSum ( arr , N , K ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minDifference = sys . maxsize NEW_LINE minIndex = - 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( minDifference > abs ( arr [ i ] - arr [ i - 1 ] ) ) : NEW_LINE INDENT minDifference = abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE minIndex = i - 1 NEW_LINE DEDENT DEDENT Arr = [ 0 for i in range ( n ) ] NEW_LINE Arr [ 0 ] = arr [ minIndex ] NEW_LINE Arr [ n - 1 ] = arr [ minIndex + 1 ] NEW_LINE pos = 1 NEW_LINE for i in range ( minIndex + 2 , n , 1 ) : NEW_LINE INDENT Arr [ pos ] = arr [ i ] NEW_LINE pos += 1 NEW_LINE DEDENT for i in range ( minIndex ) : NEW_LINE INDENT Arr [ pos ] = arr [ i ] NEW_LINE pos += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( Arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def findValuesOfK ( g ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( g ) ) + 1 , 1 ) : NEW_LINE INDENT if ( g % i == 0 ) : NEW_LINE INDENT if ( i != g // i ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( ( g // i ) & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT elif ( i & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) // ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] == i + j : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT print ( answer ) NEW_LINE DEDENT
def pathCountDPRecDP ( mat , m , n , k ) : NEW_LINE INDENT if m < 0 or n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif m == 0 and n == 0 : NEW_LINE INDENT return k == mat [ m ] [ n ] NEW_LINE DEDENT if ( dp [ m ] [ n ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] [ k ] NEW_LINE DEDENT dp [ m ] [ n ] [ k ] = ( pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ) NEW_LINE return dp [ m ] [ n ] [ k ] NEW_LINE DEDENT
def checkDistribution ( R , B , D ) : NEW_LINE INDENT if ( max ( R , B ) <= min ( R , B ) * ( D + 1 ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def itemType ( n ) : NEW_LINE INDENT count = 0 NEW_LINE day = 1 NEW_LINE while ( True ) : NEW_LINE INDENT for type in range ( day , 0 , - 1 ) : NEW_LINE INDENT count += type NEW_LINE if ( count >= n ) : NEW_LINE INDENT return type NEW_LINE DEDENT DEDENT DEDENT DEDENT
def primeFactor ( N ) : NEW_LINE INDENT v = [ ] NEW_LINE count = 0 NEW_LINE while ( ( N % 2 ) == 0 ) : NEW_LINE INDENT N >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT if ( count ) : NEW_LINE INDENT v . append ( [ 2 , count ] ) NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( N ) ) + 1 , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE N = N / i NEW_LINE DEDENT if ( count ) : NEW_LINE INDENT v . append ( [ i , count ] ) NEW_LINE DEDENT DEDENT if ( N > 2 ) : NEW_LINE INDENT v . append ( [ N , 1 ] ) NEW_LINE DEDENT return v NEW_LINE DEDENT
def ABS ( x ) : NEW_LINE INDENT return max ( x , - x ) NEW_LINE DEDENT
def isvalid ( i , j ) : NEW_LINE INDENT if ( i < 0 or j < 0 or i >= R or j >= C ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def getLenUtil ( mat , i , j , prev ) : NEW_LINE INDENT if ( isvalid ( i , j ) == False or isadjacent ( prev , mat [ i ] [ j ] ) == False ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT ans = 0 NEW_LINE for k in range ( 8 ) : NEW_LINE INDENT ans = max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , mat [ i ] [ j ] ) ) NEW_LINE DEDENT dp [ i ] [ j ] = ans NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT
def BaseConversion ( N ) : NEW_LINE INDENT s = "" NEW_LINE while ( N != 0 ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT s = "0" + s NEW_LINE DEDENT else : NEW_LINE INDENT s = "1" + s NEW_LINE N -= 1 NEW_LINE DEDENT N /= - 2 NEW_LINE DEDENT if ( s == "" ) : NEW_LINE INDENT s = "0" NEW_LINE DEDENT return s NEW_LINE DEDENT
def check ( N ) : NEW_LINE INDENT twos = 0 NEW_LINE fives = 0 NEW_LINE while ( N % 2 == 0 ) : NEW_LINE INDENT N /= 2 NEW_LINE twos += 1 NEW_LINE DEDENT while ( N % 5 == 0 ) : NEW_LINE INDENT N /= 5 NEW_LINE fives += 1 NEW_LINE DEDENT if ( N == 1 and twos <= fives ) : NEW_LINE INDENT print ( 2 * fives - twos ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def isMakeZero ( arr , N , K ) : NEW_LINE INDENT MP = { } NEW_LINE V = [ ] NEW_LINE X = 1 NEW_LINE while ( X > 0 and X < 10 ** 20 ) : NEW_LINE INDENT V . append ( X ) NEW_LINE X *= K NEW_LINE DEDENT for i in range ( 0 , N , 1 ) : NEW_LINE INDENT for j in range ( len ( V ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( V [ j ] not in MP and V [ j ] <= arr [ i ] ) : NEW_LINE INDENT arr [ i ] -= V [ j ] NEW_LINE MP [ V [ j ] ] = 1 NEW_LINE DEDENT DEDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i < N - 1 ) : NEW_LINE INDENT return "No" NEW_LINE DEDENT else : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT DEDENT
def countOperations ( N , M ) : NEW_LINE INDENT visited = [ False ] * ( 100001 ) NEW_LINE Q = [ ] NEW_LINE Q . append ( [ N , 0 ] ) NEW_LINE visited [ N ] = True NEW_LINE while ( len ( Q ) > 0 ) : NEW_LINE INDENT aux = Q [ 0 ] [ 0 ] NEW_LINE cont = Q [ 0 ] [ 1 ] NEW_LINE Q . pop ( 0 ) NEW_LINE if ( aux == M ) : NEW_LINE INDENT return cont NEW_LINE DEDENT i = 2 NEW_LINE while i * i <= aux : NEW_LINE INDENT if ( aux % i == 0 ) : NEW_LINE INDENT if ( aux + i <= M and not visited [ aux + i ] ) : NEW_LINE INDENT Q . append ( [ aux + i , cont + 1 ] ) NEW_LINE visited [ aux + i ] = True NEW_LINE DEDENT if ( aux + int ( aux / i ) <= M and not visited [ aux + int ( aux / i ) ] ) : NEW_LINE INDENT Q . append ( [ aux + int ( aux / i ) , cont + 1 ] ) NEW_LINE visited [ aux + int ( aux / i ) ] = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def Avgdifference ( arr , N , K ) : NEW_LINE INDENT min = 1000000 NEW_LINE max = - 1 NEW_LINE for i in range ( N - K + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( K ) : NEW_LINE INDENT sum += arr [ i + j ] NEW_LINE DEDENT if ( min > sum ) : NEW_LINE INDENT min = sum NEW_LINE DEDENT if ( max < sum ) : NEW_LINE INDENT max = sum NEW_LINE DEDENT DEDENT return ( max - min ) / K NEW_LINE DEDENT
def Avgdifference ( arr , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT min = sum NEW_LINE max = sum NEW_LINE for i in range ( K , N - K + 2 , 1 ) : NEW_LINE INDENT sum += arr [ i ] - arr [ i - K ] NEW_LINE if ( min > sum ) : NEW_LINE INDENT min = sum NEW_LINE DEDENT if ( max < sum ) : NEW_LINE INDENT max = sum NEW_LINE DEDENT DEDENT return ( max - min ) / K NEW_LINE DEDENT
def minimumElement ( arr , N , K ) : NEW_LINE INDENT minElement = arr [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT minElement = min ( minElement , arr [ i ] ) NEW_LINE DEDENT reqOperations = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT reqOperations += arr [ i ] - minElement NEW_LINE DEDENT if ( reqOperations < K ) : NEW_LINE INDENT K -= reqOperations NEW_LINE minElement -= ( K + N - 1 ) // N NEW_LINE DEDENT return minElement NEW_LINE DEDENT
def FractionSplit ( n , d ) : NEW_LINE INDENT UnitFactions = [ ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT x = ( d + n - 1 ) // n NEW_LINE s = "1/" + str ( x ) NEW_LINE UnitFactions . append ( s ) NEW_LINE n = n * x - d NEW_LINE d = d * x NEW_LINE DEDENT return UnitFactions NEW_LINE DEDENT
def findPermutation ( N ) : NEW_LINE INDENT arr = [ i + 1 for i in range ( N ) ] NEW_LINE for i in range ( 1 , N , 2 ) : NEW_LINE INDENT arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] , arr [ i ] NEW_LINE DEDENT if N % 2 and N > 1 : NEW_LINE INDENT arr [ - 1 ] , arr [ - 2 ] = arr [ - 2 ] , arr [ - 1 ] NEW_LINE DEDENT for i in arr : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def rangeSum ( arr , N , L , R ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( L - 1 , R , 1 ) : NEW_LINE INDENT sum += arr [ i % N ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def rangeSum ( arr , N , L , R ) : NEW_LINE INDENT prefix = [ 0 for i in range ( N + 1 ) ] NEW_LINE prefix [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT leftsum = ( ( L - 1 ) // N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] NEW_LINE rightsum = ( R // N ) * prefix [ N ] + prefix [ R % N ] NEW_LINE print ( rightsum - leftsum ) NEW_LINE DEDENT
def addAP ( A , Q , operations ) : NEW_LINE INDENT for L , R , a , d in operations : NEW_LINE INDENT curr = a NEW_LINE for i in range ( L - 1 , R ) : NEW_LINE INDENT A [ i ] += curr NEW_LINE curr += d NEW_LINE DEDENT DEDENT for i in A : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE DEDENT DEDENT
def maximizeNumber ( N , K ) : NEW_LINE INDENT s = str ( N ) NEW_LINE L = len ( s ) NEW_LINE result = "" NEW_LINE i = 0 NEW_LINE while ( ( i < L ) and ( K <= ( ord ( s [ i ] ) - ord ( '0' ) ) ) ) : NEW_LINE INDENT result += ( s [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT result += ( chr ( K + ord ( '0' ) ) ) NEW_LINE while ( i < L ) : NEW_LINE INDENT result += ( s [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT
def countArrays ( N , K ) : NEW_LINE INDENT print ( power ( N , K ) ) NEW_LINE DEDENT
def minimumDistance ( arr , N ) : NEW_LINE INDENT ind = 0 NEW_LINE prev = arr [ ind ] NEW_LINE s = len ( arr ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT distance = 10 ** 9 NEW_LINE if ( i < arr [ 0 ] ) : NEW_LINE INDENT distance = arr [ 0 ] - i NEW_LINE DEDENT elif ( i >= prev and ind + 1 < s and i <= arr [ ind + 1 ] ) : NEW_LINE INDENT distance = min ( i - prev , arr [ ind + 1 ] - i ) NEW_LINE if ( i == arr [ ind + 1 ] ) : NEW_LINE INDENT distance = 0 NEW_LINE prev = arr [ ind + 1 ] NEW_LINE ind += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT distance = i - prev NEW_LINE DEDENT print ( distance , end = " " ) NEW_LINE DEDENT DEDENT
def countOfPairs ( arr , N , X ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( ( arr [ i ] ^ arr [ j ] ) & X ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countOfPairs ( arr , N , X ) : NEW_LINE INDENT count = 0 NEW_LINE M = dict ( ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT k = arr [ i ] & X NEW_LINE if k in M : NEW_LINE INDENT M [ k ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT M [ k ] = 1 NEW_LINE DEDENT DEDENT for m in M . keys ( ) : NEW_LINE INDENT p = M [ m ] NEW_LINE count += p * ( p - 1 ) // 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
def ConcatenateArr ( arr , N ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT l = math . floor ( math . log10 ( arr [ i ] ) + 1 ) NEW_LINE ans = ans * math . pow ( 10 , l ) NEW_LINE ans += arr [ i ] NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT
def countXor ( N ) : NEW_LINE INDENT cnt = N // 2 + 1 NEW_LINE return cnt NEW_LINE DEDENT
def DistRecursion ( S , i , dist ) : NEW_LINE INDENT if i == len ( S ) : NEW_LINE INDENT return abs ( dist ) NEW_LINE DEDENT if S [ i ] == 'L' : NEW_LINE INDENT return DistRecursion ( S , i + 1 , dist - 1 ) NEW_LINE DEDENT if S [ i ] == 'R' : NEW_LINE INDENT return DistRecursion ( S , i + 1 , dist + 1 ) NEW_LINE DEDENT return max ( DistRecursion ( S , i + 1 , dist - 1 ) , DistRecursion ( S , i + 1 , dist + 1 ) ) NEW_LINE DEDENT
def maxDistance ( S ) : NEW_LINE INDENT return DistRecursion ( S , 0 , 0 ) NEW_LINE DEDENT
def isPerfect ( N ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( N ) ) + 1 , 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i * i != N ) : NEW_LINE INDENT sum = sum + i + N // i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT DEDENT if ( sum == N and N != 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def Query ( arr , N ) : NEW_LINE INDENT prefix = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( 2 , MAX + 1 , 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + isPerfect ( i ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( prefix [ arr [ i ] [ 1 ] ] - prefix [ arr [ i ] [ 0 ] - 1 ] , end = " " ) NEW_LINE DEDENT DEDENT
def ExpoFactorial ( N ) : NEW_LINE INDENT res = 1 NEW_LINE mod = ( int ) ( 1000000007 ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT res = pow ( i , res , mod ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxSubArraySumRepeated ( arr , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT curr = arr [ 0 ] NEW_LINE ans = arr [ 0 ] NEW_LINE if ( K == 1 ) : NEW_LINE INDENT for i in range ( 1 , N , 1 ) : NEW_LINE INDENT curr = max ( arr [ i ] , curr + arr [ i ] ) NEW_LINE ans = max ( ans , curr ) NEW_LINE DEDENT return ans NEW_LINE DEDENT V = [ ] NEW_LINE for i in range ( 2 * N ) : NEW_LINE INDENT V . append ( arr [ i % N ] ) NEW_LINE DEDENT maxSuf = V [ 0 ] NEW_LINE maxPref = V [ 2 * N - 1 ] NEW_LINE curr = V [ 0 ] NEW_LINE for i in range ( 1 , 2 * N , 1 ) : NEW_LINE INDENT curr += V [ i ] NEW_LINE maxPref = max ( maxPref , curr ) NEW_LINE DEDENT curr = V [ 2 * N - 1 ] NEW_LINE i = 2 * N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT curr += V [ i ] NEW_LINE maxSuf = max ( maxSuf , curr ) NEW_LINE i -= 1 NEW_LINE DEDENT curr = V [ 0 ] NEW_LINE for i in range ( 1 , 2 * N , 1 ) : NEW_LINE INDENT curr = max ( V [ i ] , curr + V [ i ] ) NEW_LINE ans = max ( ans , curr ) NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT temp = sum * ( K - 2 ) NEW_LINE ans = max ( ans , max ( temp + maxPref , temp + maxSuf ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT
def numOfNecklace ( N ) : NEW_LINE INDENT ans = factorial ( N ) // ( factorial ( N // 2 ) * factorial ( N // 2 ) ) NEW_LINE ans = ans * factorial ( N // 2 - 1 ) NEW_LINE ans = ans * factorial ( N // 2 - 1 ) NEW_LINE ans //= 2 NEW_LINE return ans NEW_LINE DEDENT
def nthNumber ( n ) : NEW_LINE INDENT divs = [ 0 for i in range ( 1000000 ) ] NEW_LINE vis = [ 0 for i in range ( 1000000 ) ] NEW_LINE cnt = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( divs [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , 1000000 ) : NEW_LINE INDENT if ( vis [ j ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT vis [ j ] = 1 NEW_LINE currNum = j NEW_LINE count = 0 NEW_LINE while ( currNum % i == 0 ) : NEW_LINE INDENT divs [ j ] += 1 NEW_LINE currNum = currNum // i NEW_LINE count += 1 NEW_LINE DEDENT if ( currNum == 1 and count == 3 and divs [ j ] == 3 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif ( currNum != 1 and divs [ currNum ] == 0 and count == 1 and divs [ j ] == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( cnt == n ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findkey ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE cur = 1 NEW_LINE while ( A > 0 ) : NEW_LINE INDENT a = A % 10 NEW_LINE b = B % 10 NEW_LINE c = C % 10 NEW_LINE A = A // 10 NEW_LINE B = B // 10 NEW_LINE C = C // 10 NEW_LINE m = max ( a , max ( c , b ) ) NEW_LINE ans += cur * m NEW_LINE cur = cur * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT sum += 2 NEW_LINE DEDENT while n % 2 == 0 : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT k = int ( math . sqrt ( n ) ) NEW_LINE for i in range ( 3 , k + 1 , 2 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum += i NEW_LINE DEDENT while n % i == 0 : NEW_LINE INDENT n //= i NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT sum += n NEW_LINE DEDENT return sum NEW_LINE DEDENT
def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( ( i & 1 ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countNumbers ( l , r ) : NEW_LINE INDENT return ( ( r // 2 ) - ( l - 1 ) // 2 ) NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT s = int ( math . sqrt ( x ) ) NEW_LINE if s * s == x : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def isFibonacci ( n ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) NEW_LINE DEDENT
def contiguousFibonacciNumber ( arr , n ) : NEW_LINE INDENT current_length = 0 NEW_LINE max_length = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if isFibonacci ( arr [ i ] ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT current_length = 0 NEW_LINE DEDENT max_length = max ( max_length , current_length ) NEW_LINE DEDENT return max_length NEW_LINE DEDENT
def Kadane ( arr , n ) : NEW_LINE INDENT largestSum = 0 NEW_LINE currMax = 0 NEW_LINE currSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT currSum += arr [ i ] NEW_LINE currMax = max ( currMax , arr [ i ] ) NEW_LINE largestSum = max ( largestSum , currMax * currSum ) NEW_LINE if ( currSum < 0 ) : NEW_LINE INDENT currMax = 0 NEW_LINE currSum = 0 NEW_LINE DEDENT DEDENT return largestSum NEW_LINE DEDENT
def maximumWeight ( arr , n ) : NEW_LINE INDENT largestSum = Kadane ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = - arr [ i ] NEW_LINE DEDENT largestSum = max ( largestSum , Kadane ( arr , n ) ) NEW_LINE return largestSum NEW_LINE DEDENT
def evenOdd ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT even_digits = 0 NEW_LINE odd_digits = 0 NEW_LINE temp = arr [ i ] NEW_LINE while ( temp ) : NEW_LINE INDENT if ( ( temp % 10 ) & 1 ) : NEW_LINE INDENT odd_digits += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_digits += 1 NEW_LINE DEDENT temp = temp // 10 NEW_LINE DEDENT if ( even_digits > odd_digits ) : NEW_LINE INDENT res = 0 NEW_LINE while ( arr [ i ] ) : NEW_LINE INDENT res += arr [ i ] % 10 NEW_LINE arr [ i ] = arr [ i ] // 10 NEW_LINE DEDENT print ( res , end = " " ) NEW_LINE DEDENT elif ( odd_digits > even_digits ) : NEW_LINE INDENT res = 1 NEW_LINE while ( arr [ i ] ) : NEW_LINE INDENT res *= arr [ i ] % 10 NEW_LINE arr [ i ] = arr [ i ] // 10 NEW_LINE DEDENT print ( res , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def sumOfFirstM ( A , N , M ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT sum = sum + A [ i % N ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findSmallestNumK ( n ) : NEW_LINE INDENT cummAnd = n NEW_LINE i = n - 1 NEW_LINE while ( cummAnd != 0 ) : NEW_LINE INDENT cummAnd = cummAnd & i NEW_LINE if ( cummAnd == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findMinInsertions ( str , l , h ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( l == h ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == h - 1 ) : NEW_LINE INDENT return 0 if ( str [ l ] == str [ h ] ) else 1 NEW_LINE DEDENT if ( str [ l ] == str [ h ] ) : NEW_LINE INDENT return findMinInsertions ( str , l + 1 , h - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) NEW_LINE DEDENT DEDENT
def canReach0toM ( a , n , m ) : NEW_LINE INDENT rightMost = [ 0 for i in range ( m + 1 ) ] NEW_LINE dp = [ 0 for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT rightMost [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT a1 = a [ i ] [ 0 ] NEW_LINE b1 = a [ i ] [ 1 ] NEW_LINE rightMost [ a1 ] = max ( rightMost [ a1 ] , b1 ) NEW_LINE DEDENT i = m NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT dp [ i ] = i NEW_LINE j = min ( m , rightMost [ i ] ) NEW_LINE while ( j > i ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] ) NEW_LINE j -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( dp [ 0 ] >= m ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT for y in range ( x , arr [ i ] + 1 ) : NEW_LINE INDENT if gcd ( x , y ) > 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count , end = " " ) NEW_LINE DEDENT DEDENT
def maximumTurns ( arr , N ) : NEW_LINE INDENT Count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT while ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT Count += 1 NEW_LINE arr [ i ] = arr [ i ] // 2 NEW_LINE DEDENT DEDENT return Count NEW_LINE DEDENT
def findSet ( N , K ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i != K ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT MaxDistinct = ( N - K ) + ( K // 2 ) NEW_LINE a = a [ : : - 1 ] NEW_LINE for i in range ( MaxDistinct ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def linearCongruence ( A , B , N ) : NEW_LINE INDENT A = A % N NEW_LINE B = B % N NEW_LINE u = 0 NEW_LINE v = 0 NEW_LINE d , u , v = ExtendedEuclidAlgo ( A , N ) NEW_LINE if ( B % d != 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT x0 = ( u * ( B // d ) ) % N NEW_LINE if ( x0 < 0 ) : NEW_LINE INDENT x0 += N NEW_LINE DEDENT for i in range ( d ) : NEW_LINE INDENT print ( ( x0 + i * ( N // d ) ) % N , end = " " ) NEW_LINE DEDENT DEDENT
def distinctGCDs ( arr , N ) : NEW_LINE INDENT M = - 1 NEW_LINE ans = 0 NEW_LINE Mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT M = max ( M , arr [ i ] ) NEW_LINE Mp [ arr [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , M + 1 , 1 ) : NEW_LINE INDENT currGcd = 0 NEW_LINE for j in range ( i , M + 1 , i ) : NEW_LINE INDENT if ( j in Mp ) : NEW_LINE INDENT currGcd = gcd ( currGcd , j ) NEW_LINE if ( currGcd == i ) : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT
def countSubarray ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n , 1 ) : NEW_LINE INDENT mxSubarray = 0 NEW_LINE mxOther = 0 NEW_LINE for k in range ( i , j + 1 , 1 ) : NEW_LINE INDENT mxSubarray = max ( mxSubarray , arr [ k ] ) NEW_LINE DEDENT for k in range ( 0 , i , 1 ) : NEW_LINE INDENT mxOther = max ( mxOther , arr [ k ] ) NEW_LINE DEDENT for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT mxOther = max ( mxOther , arr [ k ] ) NEW_LINE DEDENT if ( mxSubarray > ( 2 * mxOther ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def countSubarray ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE L = 0 NEW_LINE R = 0 NEW_LINE mx = max ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] * 2 > mx ) : NEW_LINE INDENT L = i NEW_LINE break NEW_LINE DEDENT DEDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( arr [ i ] * 2 > mx ) : NEW_LINE INDENT R = i NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( ( L + 1 ) * ( n - R ) ) NEW_LINE DEDENT
def factorialWithoutMul ( N ) : NEW_LINE INDENT ans = N NEW_LINE i = N - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT sum += ans NEW_LINE DEDENT ans = sum NEW_LINE i -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isPrime ( X ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( X ) ) + 1 , 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n = n & ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def minOperations ( A , B ) : NEW_LINE INDENT cnt1 = 0 NEW_LINE cnt2 = 0 NEW_LINE cnt1 += countSetBits ( A ) NEW_LINE cnt2 += countSetBits ( B ) NEW_LINE if ( ( cnt1 + cnt2 ) % 2 != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT oneZero = 0 NEW_LINE zeroOne = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( max ( cnt1 , cnt2 ) ) : NEW_LINE INDENT bitpos = 1 << i NEW_LINE if ( ( not ( bitpos & A ) ) and ( bitpos & B ) ) : NEW_LINE INDENT zeroOne += 1 NEW_LINE DEDENT if ( ( bitpos & A ) and ( not ( bitpos & B ) ) ) : NEW_LINE INDENT oneZero += 1 NEW_LINE DEDENT DEDENT ans = ( zeroOne // 2 ) + ( oneZero // 2 ) NEW_LINE if ( zeroOne % 2 != 0 ) : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sieveSundaram ( ) : NEW_LINE INDENT marked = [ 0 for i in range ( MAX // 2 + 100 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( 1 , int ( ( sqrt ( MAX ) - 1 ) / 2 ) + 1 , 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , MAX // 2 + 1 , j + 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True NEW_LINE DEDENT DEDENT primes . append ( 2 ) NEW_LINE for i in range ( 1 , MAX // 2 + 1 , 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def isSmithBrotherPair ( X , Y ) : NEW_LINE INDENT return ( isSmith ( X ) and isSmith ( Y ) and abs ( X - Y ) == 1 ) NEW_LINE DEDENT
def countSmithBrotherPairs ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N , 1 ) : NEW_LINE INDENT if ( isSmithBrotherPair ( A [ i ] , A [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def tripletAndSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT ans += arr [ i ] & arr [ j ] & arr [ k ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE totalSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT totalSum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N , 1 ) : NEW_LINE INDENT if ( totalSum % ( arr [ i ] + arr [ j ] ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def countOfBase ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT highestPower = int ( math . log ( N ) / math . log ( i ) ) NEW_LINE firstDigit = int ( N / int ( math . pow ( i , highestPower ) ) ) NEW_LINE if ( firstDigit == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT
def PermuteAndFind ( power , idx , SumSoFar , target ) : NEW_LINE INDENT if ( idx == len ( power ) ) : NEW_LINE INDENT if ( SumSoFar == target ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT select = PermuteAndFind ( power , idx + 1 , SumSoFar , target ) NEW_LINE notselect = PermuteAndFind ( power , idx + 1 , SumSoFar + power [ idx ] , target ) NEW_LINE return ( select or notselect ) NEW_LINE DEDENT
def DistinctPowersOf3 ( N ) : NEW_LINE INDENT power = [ 0 for x in range ( 16 ) ] NEW_LINE power [ 0 ] = 1 NEW_LINE for i in range ( 1 , 16 ) : NEW_LINE INDENT power [ i ] = 3 * power [ i - 1 ] NEW_LINE DEDENT found = PermuteAndFind ( power , 0 , 0 , N ) NEW_LINE if ( found == True ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def PrimeFactor ( N ) : NEW_LINE INDENT ANS = dict ( ) NEW_LINE while N % 2 == 0 : NEW_LINE INDENT if 2 in ANS : NEW_LINE INDENT ANS [ 2 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ANS [ 2 ] = 1 NEW_LINE DEDENT N = N // 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( N ) ) + 1 , 2 ) : NEW_LINE INDENT while N % i == 0 : NEW_LINE INDENT if i in ANS : NEW_LINE INDENT ANS [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ANS [ i ] = 1 NEW_LINE DEDENT N = N // i NEW_LINE DEDENT DEDENT if 2 < N : NEW_LINE INDENT ANS [ N ] = 1 NEW_LINE DEDENT return ANS NEW_LINE DEDENT
def CountToMakeEqual ( X , Y ) : NEW_LINE INDENT GCD = math . gcd ( X , Y ) NEW_LINE newY = X // GCD NEW_LINE newX = Y // GCD NEW_LINE primeX = PrimeFactor ( newX ) NEW_LINE primeY = PrimeFactor ( newY ) NEW_LINE ans = 0 NEW_LINE for factor in primeX : NEW_LINE INDENT if X % factor != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans += primeX [ factor ] NEW_LINE DEDENT for factor in primeY : NEW_LINE INDENT if Y % factor != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans += primeY [ factor ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maximumSubsequenceSum ( A , N ) : NEW_LINE INDENT ans = 0 NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] - i in mp ) : NEW_LINE INDENT mp [ A [ i ] - i ] += A [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] - i ] = A [ i ] NEW_LINE DEDENT ans = max ( ans , mp [ A [ i ] - i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def getPermutation ( N ) : NEW_LINE INDENT if ( N <= 3 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT i = N NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT while ( i >= 1 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE i -= 2 NEW_LINE DEDENT print ( 4 , 2 , end = " " ) NEW_LINE i = 6 NEW_LINE while ( i <= N ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE i += 2 NEW_LINE DEDENT DEDENT
def gcd ( A , B ) : NEW_LINE INDENT if ( B == 0 ) : NEW_LINE INDENT return A NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( B , A % B ) NEW_LINE DEDENT DEDENT
def getDistinctValues ( A , B , C ) : NEW_LINE INDENT g = gcd ( A , B ) NEW_LINE num_values = C / g NEW_LINE return int ( num_values ) NEW_LINE DEDENT
def nearestPerfectSquare ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT sr = math . floor ( math . sqrt ( arr [ i ] ) ) NEW_LINE a = sr * sr NEW_LINE b = ( sr + 1 ) * ( sr + 1 ) NEW_LINE if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) : NEW_LINE INDENT print ( a , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def currSubArrayScore ( a , b , l , r ) : NEW_LINE INDENT straightScore = 0 NEW_LINE reverseScore = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT straightScore += a [ i ] * b [ i ] NEW_LINE reverseScore += a [ r - ( i - l ) ] * b [ i ] NEW_LINE DEDENT return max ( straightScore , reverseScore ) NEW_LINE DEDENT
def maxScoreSubArray ( a , b , n ) : NEW_LINE INDENT res = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT currScore = currSubArrayScore ( a , b , i , j ) NEW_LINE if ( currScore > res ) : NEW_LINE INDENT res = currScore NEW_LINE start = i NEW_LINE end = j NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def maxScoreSubArray ( a , b , n ) : NEW_LINE INDENT res = 0 NEW_LINE for mid in range ( n ) : NEW_LINE INDENT straightScore = a [ mid ] * b [ mid ] NEW_LINE reverseScore = a [ mid ] * a [ mid ] NEW_LINE prev = mid - 1 NEW_LINE next = mid + 1 NEW_LINE res = max ( res , max ( straightScore , reverseScore ) ) NEW_LINE while ( prev >= 0 and next < n ) : NEW_LINE INDENT straightScore += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) NEW_LINE reverseScore += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) NEW_LINE res = max ( res , max ( straightScore , reverseScore ) ) NEW_LINE prev -= 1 NEW_LINE next += 1 NEW_LINE DEDENT straightScore = 0 NEW_LINE reverseScore = 0 NEW_LINE prev = mid - 1 NEW_LINE next = mid NEW_LINE while ( prev >= 0 and next < n ) : NEW_LINE INDENT straightScore += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) NEW_LINE reverseScore += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) NEW_LINE res = max ( res , max ( straightScore , reverseScore ) ) NEW_LINE prev -= 1 NEW_LINE next += 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def minimumSizeSubarray ( arr , N ) : NEW_LINE INDENT i , j = 0 , N - 1 NEW_LINE while ( i < N and arr [ i ] == 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( i == N ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( j >= 0 and arr [ j ] == 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT return ( j - i + 1 ) NEW_LINE DEDENT
def countXorPartition ( N ) : NEW_LINE INDENT a = 2 ** floor ( N - log ( N + 1 ) / log ( 2 ) ) NEW_LINE print ( int ( a ) ) NEW_LINE DEDENT
def countValues ( A , B , C ) : NEW_LINE INDENT if ( B >= A ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT print ( C // A ) NEW_LINE return NEW_LINE DEDENT ans = C // A NEW_LINE if ( ans * A + B <= C ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def SieveOfEratosthenes ( n ) : NEW_LINE INDENT global prime NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def floorDifference ( A , N , X ) : NEW_LINE INDENT totalSum = 0 NEW_LINE perElementSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT totalSum += A [ i ] NEW_LINE perElementSum += A [ i ] // X NEW_LINE DEDENT totalFloorSum = totalSum // X NEW_LINE return abs ( totalFloorSum - perElementSum ) NEW_LINE DEDENT
def maximumSum ( arr , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for bit in range ( 32 ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] & ( 1 << bit ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT ans = max ( ans , sum ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxCount ( arr , N , K ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT st . add ( arr [ i ] ) NEW_LINE DEDENT if ( N - len ( st ) <= K ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def kthDigitFromLast ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT while ( ( k - 1 ) > 0 and n > 0 ) : NEW_LINE INDENT n = n / 10 NEW_LINE k -= 1 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( n % 10 ) ) NEW_LINE DEDENT DEDENT
def findWinner ( X , Y ) : NEW_LINE INDENT playerA = ( X ^ Y ) NEW_LINE flag = False NEW_LINE for i in range ( 1 , X + 1 , 1 ) : NEW_LINE INDENT for j in range ( 1 , Y + 1 , 1 ) : NEW_LINE INDENT val = ( i ^ j ) NEW_LINE if ( val > playerA ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def findWinner ( X , Y ) : NEW_LINE INDENT first = ( X ^ Y ) NEW_LINE second = ( X + Y ) NEW_LINE if ( first == second ) : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT DEDENT
def countWays ( arr , N ) : NEW_LINE INDENT arr_xor = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT arr_xor ^= arr [ i ] NEW_LINE DEDENT pref_xor , suff_xor = 0 , 0 NEW_LINE pref_ind = [ ] NEW_LINE suff_inds = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT pref_xor ^= arr [ i ] NEW_LINE if ( pref_xor == arr_xor ) : NEW_LINE INDENT pref_ind . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT suff_xor ^= arr [ i ] NEW_LINE suff_inds [ i ] += suff_inds [ i + 1 ] NEW_LINE if ( suff_xor == arr_xor ) : NEW_LINE INDENT suff_inds [ i ] += 1 NEW_LINE DEDENT DEDENT tot_ways = 0 NEW_LINE for idx in pref_ind : NEW_LINE INDENT if ( idx < N - 1 ) : NEW_LINE INDENT tot_ways += suff_inds [ idx + 2 ] NEW_LINE DEDENT DEDENT return tot_ways NEW_LINE DEDENT
def KthSmallest ( A , B , N , K ) : NEW_LINE INDENT M = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT M = max ( A [ i ] , M ) NEW_LINE DEDENT freq = [ 0 ] * ( M + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq [ A [ i ] ] += B [ i ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( M + 1 ) : NEW_LINE INDENT sum += freq [ i ] NEW_LINE if ( sum >= K ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def xorSumOfArray ( arr , n , k , count ) : NEW_LINE INDENT sum = 0 NEW_LINE p = 1 NEW_LINE for i in range ( 31 ) : NEW_LINE INDENT val = 0 NEW_LINE if ( ( k & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT not_set = n - count [ i ] NEW_LINE val = ( ( not_set ) * p ) NEW_LINE DEDENT else : NEW_LINE INDENT val = ( count [ i ] * p ) NEW_LINE DEDENT sum += val NEW_LINE p = ( p * 2 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumOfXors ( arr , n , queries , q ) : NEW_LINE INDENT count = [ 0 for i in range ( 32 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 31 ) : NEW_LINE INDENT if ( arr [ i ] & ( 1 << j ) ) : NEW_LINE INDENT count [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( q ) : NEW_LINE INDENT k = queries [ i ] NEW_LINE print ( xorSumOfArray ( arr , n , k , count ) , end = " " ) NEW_LINE DEDENT DEDENT
def IsSumEqualsXor ( i , n , bound , s ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ i ] [ bound ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ bound ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( bound and s [ i ] == '0' ) : NEW_LINE INDENT ans = IsSumEqualsXor ( i + 1 , n , 1 , s ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 2 * IsSumEqualsXor ( i + 1 , n , bound & ( s [ i ] == '1' ) , s ) NEW_LINE ans += IsSumEqualsXor ( i + 1 , n , 0 , s ) NEW_LINE DEDENT dp [ i ] [ bound ] = ans NEW_LINE return ans NEW_LINE DEDENT
def findNum ( N , K ) : NEW_LINE INDENT rem = ( N + K ) % K NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return N + K - rem NEW_LINE DEDENT DEDENT
def findSmallest ( M , N ) : NEW_LINE INDENT x = findNum ( M , N ) NEW_LINE return x - M NEW_LINE DEDENT
def toDeci ( strr , base ) : NEW_LINE INDENT lenn = len ( strr ) NEW_LINE power = 1 NEW_LINE num = 0 NEW_LINE for i in range ( lenn - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( val ( strr [ i ] ) >= base ) : NEW_LINE INDENT print ( "Invalid Number" ) NEW_LINE return - 1 NEW_LINE DEDENT num += val ( strr [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT
def fact ( N ) : NEW_LINE INDENT if ( N == 1 or N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return N * fact ( N - 1 ) NEW_LINE DEDENT
def prefixFactorialArray ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT arr [ i ] = fact ( arr [ i ] ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def prefixFactorialArray ( A , N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT A [ i ] += A [ i - 1 ] NEW_LINE DEDENT fact = [ 0 for x in range ( A [ N - 1 ] + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , A [ N - 1 ] + 1 ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT A [ i ] = fact [ A [ i ] ] NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT print ( A [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] - x * i ) in mp ) : NEW_LINE INDENT mp [ arr [ i ] - x * i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] - x * i ] = 1 NEW_LINE DEDENT DEDENT for key , value in mp . items ( ) : NEW_LINE INDENT n = value NEW_LINE count += ( n * ( n - 1 ) ) // 2 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def findAverage ( N ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT S += i * i * i * i NEW_LINE DEDENT return round ( S / N , 4 ) NEW_LINE DEDENT
def findAverage ( N ) : NEW_LINE INDENT avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30 NEW_LINE return avg NEW_LINE DEDENT
def ToCheckPowerofX ( n , x ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT rem = n % x NEW_LINE if ( rem >= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // x NEW_LINE DEDENT return True NEW_LINE DEDENT
def maximumOfTwo ( N ) : NEW_LINE INDENT M = reverseBin ( N ) NEW_LINE return max ( N , M ) NEW_LINE DEDENT
def findbitwiseOR ( a , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sub_array = a [ i ] NEW_LINE res = res | curr_sub_array NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_sub_array = curr_sub_array & a [ j ] NEW_LINE res = res | curr_sub_array NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def findbitwiseOR ( a , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = res | a [ i ] NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def findDecimal ( arr , N ) : NEW_LINE INDENT power = 0 NEW_LINE result = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT bit = abs ( int ( arr [ i ] ) - round ( arr [ i ] ) ) NEW_LINE if ( bit ) : NEW_LINE INDENT result += pow ( 2 , power ) NEW_LINE DEDENT power += 1 NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT
def totalMoney ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT ans += i / 7 NEW_LINE ans += ( i % 7 + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minTime ( A , n , K ) : NEW_LINE INDENT max_ability = A [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT max_ability = max ( max_ability , A [ i ] ) NEW_LINE DEDENT tmp = [ 0 for i in range ( max_ability + 1 ) ] NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp [ A [ i ] ] += 1 NEW_LINE DEDENT i = max_ability NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( tmp [ i ] != 0 ) : NEW_LINE INDENT if ( tmp [ i ] * i < K ) : NEW_LINE INDENT K -= ( i * tmp [ i ] ) NEW_LINE tmp [ i // 2 ] += tmp [ i ] NEW_LINE count += tmp [ i ] NEW_LINE if ( K <= 0 ) : NEW_LINE INDENT return count NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( K % i != 0 ) : NEW_LINE INDENT count += ( K // i ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( K // i ) NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT i -= 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def minimumRod ( A , N ) : NEW_LINE INDENT print ( int ( N * findlcm ( A , N ) ) ) NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT sumOfDigit = 0 NEW_LINE prodOfDigit = 1 NEW_LINE while n > 0 : NEW_LINE INDENT rem = n % 10 NEW_LINE sumOfDigit += rem NEW_LINE prodOfDigit *= rem NEW_LINE n = n // 10 NEW_LINE DEDENT if sumOfDigit > prodOfDigit : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def check ( N , D ) : NEW_LINE INDENT while ( N > 0 ) : NEW_LINE INDENT if ( findDigit ( N , D ) == True ) : NEW_LINE INDENT return True NEW_LINE DEDENT N -= D NEW_LINE DEDENT return False NEW_LINE DEDENT
def FindSum ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT power = int ( log2 ( arr [ i ] ) ) NEW_LINE LesserValue = pow ( 2 , power ) NEW_LINE LargerValue = pow ( 2 , power + 1 ) NEW_LINE if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % mod NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) % mod NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT
def countRelations ( N ) : NEW_LINE INDENT print ( ( power ( 2 , N ) - 2 ) * power ( 2 , N * N - N ) ) NEW_LINE DEDENT
def minOperations ( N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT arr [ i ] = ( 2 * i ) + 1 NEW_LINE sum = sum + arr [ i ] NEW_LINE DEDENT mid = 0 NEW_LINE if N % 2 == 0 : NEW_LINE INDENT mid = sum / N NEW_LINE DEDENT else : NEW_LINE INDENT mid = arr [ int ( N / 2 ) ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( int ( N / 2 ) ) : NEW_LINE INDENT ans += mid - arr [ i ] NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT
def minOperation ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return ( N / 2 ) * ( N / 2 ) NEW_LINE DEDENT k = ( N - 1 ) / 2 NEW_LINE return ( k * ( k + 1 ) ) NEW_LINE DEDENT
def findXORS ( arr1 , arr2 , N , M ) : NEW_LINE INDENT XORS1 = 0 NEW_LINE XORS2 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT XORS1 ^= arr1 [ i ] NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT XORS2 ^= arr2 [ i ] NEW_LINE DEDENT return XORS1 and XORS2 NEW_LINE DEDENT
def findPermutation ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 and arr [ i ] <= arr [ i + 1 ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT j = N - 1 NEW_LINE while ( j > i and arr [ j ] >= arr [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT while ( j > i and arr [ j ] == arr [ j - 1 ] ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE for it in arr : NEW_LINE INDENT print ( it , end = " " ) NEW_LINE DEDENT DEDENT
def isPowerof2 ( n ) : NEW_LINE INDENT return ( ( n & ( n - 1 ) ) and n ) NEW_LINE DEDENT
def countNum ( N ) : NEW_LINE INDENT ans = int ( math . log2 ( N ) ) + 1 NEW_LINE print ( ans ) NEW_LINE DEDENT
def nearestPow ( x , base ) : NEW_LINE INDENT k = int ( math . log ( x , base ) ) NEW_LINE if abs ( base ** k - x ) < abs ( base ** ( k + 1 ) - x ) : NEW_LINE INDENT return base ** k NEW_LINE DEDENT else : NEW_LINE INDENT return base ** ( k + 1 ) NEW_LINE DEDENT DEDENT
def ceilDifference ( arr , n , x ) : NEW_LINE INDENT totalSum = 0 NEW_LINE perElementSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT totalSum += arr [ i ] NEW_LINE perElementSum += ceil ( arr [ i ] / x ) NEW_LINE DEDENT totalCeilSum = ceil ( totalSum / x ) NEW_LINE return abs ( perElementSum - totalCeilSum ) NEW_LINE DEDENT
def computeTotient ( N , phi ) : NEW_LINE INDENT for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if phi [ p ] == p : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , N + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countPairs ( N ) : NEW_LINE INDENT cnt_type1 = 0 NEW_LINE cnt_type2 = 0 NEW_LINE half_N = N // 2 NEW_LINE cnt_type1 = ( half_N * ( half_N - 1 ) ) // 2 NEW_LINE phi = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT computeTotient ( N , phi ) NEW_LINE for i in range ( ( N // 2 ) + 1 , N + 1 ) : NEW_LINE INDENT cnt_type2 += ( i - phi [ i ] - 1 ) NEW_LINE DEDENT print ( cnt_type1 + cnt_type2 ) NEW_LINE DEDENT
def countTriplets ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i * j > N ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += N // ( i * j ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findSumOfGP ( a , r ) : NEW_LINE INDENT if ( abs ( r ) >= 1 ) : NEW_LINE INDENT print ( "Infinite" ) NEW_LINE return NEW_LINE DEDENT sum = a / ( 1 - r ) NEW_LINE print ( int ( sum ) ) NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % mod NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % mod NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT
def numberOfRelations ( N ) : NEW_LINE INDENT return power ( 3 , ( N * N - N ) // 2 ) NEW_LINE DEDENT
def countNumbers ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( math . gcd ( i , N ) != 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def phi ( N ) : NEW_LINE INDENT result = N NEW_LINE for p in range ( 2 , int ( pow ( N , 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( N % p == 0 ) : NEW_LINE INDENT while ( N % p == 0 ) : NEW_LINE INDENT N = N / p NEW_LINE DEDENT result -= result // p NEW_LINE DEDENT DEDENT if ( N > 1 ) : NEW_LINE INDENT result -= result // N NEW_LINE DEDENT return result NEW_LINE DEDENT
def countNumbers ( N ) : NEW_LINE INDENT count = N - phi ( N ) NEW_LINE print ( count ) NEW_LINE DEDENT
def Query ( arr , N , Q ) : NEW_LINE INDENT mul = 1 NEW_LINE add = 0 NEW_LINE for i in range ( len ( Q ) ) : NEW_LINE INDENT if ( Q [ i ] [ 0 ] == 0 ) : NEW_LINE INDENT add = add + Q [ i ] [ 1 ] NEW_LINE DEDENT elif ( Q [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT mul = mul * Q [ i ] [ 1 ] NEW_LINE add = add * Q [ i ] [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = arr [ Q [ i ] [ 1 ] ] * mul + add NEW_LINE print ( ans , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def nearFibo ( X ) : NEW_LINE INDENT a = ( 5 ** ( 1 / 2 ) + 1 ) / 2 NEW_LINE n = int ( math . log ( ( 5 ** ( 1 / 2 ) ) * X ) / math . log ( a ) ) NEW_LINE nth = nthFibo ( n ) NEW_LINE nplus = nthFibo ( n + 1 ) NEW_LINE if abs ( X - nth ) < abs ( X - nplus ) : NEW_LINE INDENT return nth NEW_LINE DEDENT else : NEW_LINE INDENT return nplus NEW_LINE DEDENT DEDENT
def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , N , 2 ) : NEW_LINE INDENT if j * i > N : NEW_LINE INDENT break NEW_LINE DEDENT if ( not prime [ i * j ] ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def getMaxPairSum ( arr , N , K ) : NEW_LINE INDENT preMax = [ 0 ] * N NEW_LINE preMax [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT preMax [ i ] = max ( preMax [ i - 1 ] , arr [ i ] ) NEW_LINE DEDENT res = - 10 ** 8 NEW_LINE for i in range ( K , N ) : NEW_LINE INDENT res = max ( res , arr [ i ] + preMax [ i - K ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def sumOfInfiniteAGP ( a , d , r ) : NEW_LINE INDENT ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) NEW_LINE print ( round ( ans , 6 ) ) NEW_LINE DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def CountPairs ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] in mp ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for key , value in mp . items ( ) : NEW_LINE INDENT x = key NEW_LINE y = value NEW_LINE if ( x == 1 ) : NEW_LINE INDENT res += N - 1 NEW_LINE continue NEW_LINE DEDENT res += ( y * ( y - 1 ) ) // 2 NEW_LINE for j in range ( 2 , int ( sqrt ( x ) ) + 1 , 1 ) : NEW_LINE INDENT if ( x % j == 0 ) : NEW_LINE INDENT res += mp [ j ] NEW_LINE if ( j != x // j ) : NEW_LINE INDENT res += mp [ x // j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def findClosestTarget ( i , curr , B , M , K ) : NEW_LINE INDENT global ans , mini NEW_LINE if ( abs ( curr - K ) < mini ) : NEW_LINE INDENT mini = abs ( curr - K ) NEW_LINE ans = curr NEW_LINE DEDENT if ( abs ( curr - K ) == mini ) : NEW_LINE INDENT ans = min ( ans , curr ) NEW_LINE DEDENT if ( i >= M ) : NEW_LINE INDENT return NEW_LINE DEDENT findClosestTarget ( i + 1 , curr + B [ i ] , B , M , K ) NEW_LINE findClosestTarget ( i + 1 , curr + 2 * B [ i ] , B , M , K ) NEW_LINE findClosestTarget ( i + 1 , curr , B , M , K ) NEW_LINE DEDENT
def findClosest ( A , B , N , M , K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT findClosestTarget ( 0 , A [ i ] , B , M , K ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countbits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n = n // 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
def BitProduct ( arr , N ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT bits = countbits ( arr [ i ] ) NEW_LINE product *= bits NEW_LINE DEDENT return product NEW_LINE DEDENT
def removeEveryKth ( l , k ) : NEW_LINE INDENT for i in range ( 0 , len ( l ) ) : NEW_LINE INDENT if i % k == 0 : NEW_LINE INDENT l [ i ] = 0 NEW_LINE DEDENT DEDENT arr = [ 0 ] NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT if l [ i ] != 0 : NEW_LINE INDENT arr . append ( l [ i ] ) NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT
def printArray ( l ) : NEW_LINE INDENT for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT print ( l [ i ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def printSequence ( n , k ) : NEW_LINE INDENT l = [ int ( i ) for i in range ( 0 , n + 1 ) ] NEW_LINE x = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT p = l [ x ] + l [ x + 1 ] NEW_LINE l = removeEveryKth ( l , p ) NEW_LINE x += 1 NEW_LINE DEDENT printArray ( l ) NEW_LINE DEDENT
def OddDivisorsSum ( n , q , a , Query ) : NEW_LINE INDENT DP = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = sqrt ( a [ i ] ) NEW_LINE if ( x * x == a [ i ] ) : NEW_LINE INDENT DP [ i ] = a [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT DP [ i ] = DP [ i - 1 ] + DP [ i ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT l = Query [ i ] [ 0 ] NEW_LINE r = Query [ i ] [ 1 ] NEW_LINE if ( l == 0 ) : NEW_LINE INDENT print ( DP [ r ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( DP [ r ] - DP [ l - 1 ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def findSubset ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE mp = defaultdict ( int ) NEW_LINE totSum = 0 NEW_LINE s = 0 NEW_LINE flag = 0 NEW_LINE ans = [ ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT totSum += arr [ i ] NEW_LINE mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE i = N - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT frq = mp [ arr [ i ] ] NEW_LINE if ( ( frq + len ( ans ) ) < ( N - ( frq + len ( ans ) ) ) ) : NEW_LINE INDENT for k in range ( frq ) : NEW_LINE INDENT ans . append ( arr [ i ] ) NEW_LINE totSum -= arr [ i ] NEW_LINE s += arr [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i -= frq NEW_LINE DEDENT if ( s > totSum ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT for i in range ( len ( ans ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def minStepK ( arr , N , K ) : NEW_LINE INDENT E = 0 NEW_LINE S = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT E += 1 NEW_LINE DEDENT DEDENT if ( S >= K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( S + E < K ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return K - S NEW_LINE DEDENT DEDENT
def Rotate ( n , f ) : NEW_LINE INDENT temp = n NEW_LINE maxi = n NEW_LINE mini = n NEW_LINE for idx in range ( 7 ) : NEW_LINE INDENT if temp & 1 : NEW_LINE INDENT temp >>= 1 NEW_LINE temp += 2 ** 7 NEW_LINE DEDENT else : NEW_LINE INDENT temp >>= 1 NEW_LINE DEDENT mini = min ( mini , temp ) NEW_LINE maxi = max ( maxi , temp ) NEW_LINE DEDENT if ( f ) : NEW_LINE INDENT return ( maxi ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( mini ) NEW_LINE DEDENT DEDENT
def minimumDiff ( arr , N ) : NEW_LINE INDENT res = arr [ 0 ] NEW_LINE sum1 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum1 += arr [ i ] NEW_LINE DEDENT min_diff = sum1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( abs ( sum1 - ( arr [ i ] * N ) ) < min_diff ) : NEW_LINE INDENT min_diff = abs ( sum1 - ( arr [ i ] * N ) ) NEW_LINE res = arr [ i ] NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def makeEqual ( arr , n ) : NEW_LINE INDENT fre0 = [ 0 ] * 33 NEW_LINE fre1 = [ 0 ] * 33 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE for j in range ( 33 ) : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT fre1 [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT fre0 [ j ] += 1 NEW_LINE DEDENT x = x >> 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 33 ) : NEW_LINE INDENT ans += min ( fre0 [ i ] , fre1 [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def check ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def primeDivisors ( arr , N ) : NEW_LINE INDENT K = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT K = max ( K , arr [ i ] ) NEW_LINE DEDENT prime = [ 0 ] * ( K + 1 ) NEW_LINE prime [ 0 ] = 1 NEW_LINE prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , K + 1 ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , K + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT factor = [ 0 ] * ( K + 1 ) NEW_LINE factor [ 0 ] = 0 NEW_LINE factor [ 1 ] = 1 NEW_LINE for i in range ( 2 , K + 1 ) : NEW_LINE INDENT factor [ i ] += 1 NEW_LINE for j in range ( i , K + 1 , i ) : NEW_LINE INDENT factor [ j ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( prime [ factor [ arr [ i ] ] ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def isPresent ( n , x ) : NEW_LINE INDENT num = str ( n ) NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT if ( ( ord ( num [ i ] ) - ord ( '0' ) ) == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def removeDigit ( n , index ) : NEW_LINE INDENT num = str ( n ) NEW_LINE ans = "" NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT if ( i != index ) : NEW_LINE INDENT ans += num [ i ] NEW_LINE DEDENT DEDENT if ( ans == "" or ( len ( ans ) == 1 and ans [ 0 ] == '0' ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = int ( ans ) NEW_LINE return x NEW_LINE DEDENT
def reduceNtoX ( a , b , d , n ) : NEW_LINE INDENT q = deque ( ) NEW_LINE q . append ( a ) NEW_LINE visited = { } NEW_LINE visited [ a ] = True NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT top = q . popleft ( ) NEW_LINE if ( top < 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( top == b ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( d [ i ] != 0 and top % d [ i ] == 0 and ( top // d [ i ] not in visited ) ) : NEW_LINE INDENT q . append ( top // d [ i ] ) NEW_LINE visited [ top // d [ i ] ] = True NEW_LINE DEDENT index = isPresent ( top , d [ i ] ) NEW_LINE if ( index != - 1 ) : NEW_LINE INDENT newElement = removeDigit ( top , index ) NEW_LINE if ( newElement != - 1 and ( newElement not in visited ) ) : NEW_LINE INDENT q . append ( newElement ) NEW_LINE visited [ newElement ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def SieveOfEratosthenes ( n , prime ) : NEW_LINE INDENT prime [ 0 ] = 0 NEW_LINE prime [ 1 ] = 0 NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def fact ( n ) : NEW_LINE INDENT if n == 1 or n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n * fact ( n - 1 ) NEW_LINE DEDENT DEDENT
def findValue ( n , r , a ) : NEW_LINE INDENT k = ( a - 1 ) // fact ( n ) NEW_LINE answer = k NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT answer = answer * ( n + r - i ) NEW_LINE DEDENT DEDENT
def expectedValue ( P , a , b , N ) : NEW_LINE INDENT expValue = P + ( N * 0.5 * ( a + b ) ) NEW_LINE print ( int ( expValue ) ) NEW_LINE DEDENT
def startingPoint ( A , N ) : NEW_LINE INDENT sum = 0 NEW_LINE startingindex = 0 NEW_LINE min = sys . maxsize NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE if ( sum < min ) : NEW_LINE INDENT min = sum NEW_LINE startingindex = i + 1 NEW_LINE DEDENT DEDENT if ( sum < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return startingindex % N NEW_LINE DEDENT
def findMinSum ( mat , N ) : NEW_LINE INDENT sum1 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT res = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT res |= mat [ i ] [ j ] NEW_LINE DEDENT DEDENT sum1 += res NEW_LINE DEDENT return sum1 NEW_LINE DEDENT
def findMedian ( Mean , Mode ) : NEW_LINE INDENT Median = ( 2 * Mean + Mode ) // 3 NEW_LINE print ( Median ) NEW_LINE DEDENT
def sumOfBinaryNumbers ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE one = 1 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT ans = ( ans + n ) % MOD NEW_LINE break NEW_LINE DEDENT x = int ( log2 ( n ) ) NEW_LINE cur = 0 NEW_LINE add = ( one << ( x - 1 ) ) NEW_LINE for i in range ( 1 , x + 1 , 1 ) : NEW_LINE INDENT cur = ( cur + add ) % MOD NEW_LINE add = ( add * 10 % MOD ) NEW_LINE DEDENT ans = ( ans + cur ) % MOD NEW_LINE rem = n - ( one << x ) + 1 NEW_LINE p = pow ( 10 , x ) NEW_LINE p = ( p * ( rem % MOD ) ) % MOD NEW_LINE ans = ( ans + p ) % MOD NEW_LINE n = rem - 1 NEW_LINE DEDENT print ( int ( ans ) ) NEW_LINE DEDENT
def uniqueElementsLCM ( arr , N ) : NEW_LINE INDENT freq = defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT lcm = 1 NEW_LINE for i in freq : NEW_LINE INDENT if ( freq [ i ] == 1 ) : NEW_LINE INDENT lcm = findLCM ( lcm , i ) NEW_LINE DEDENT DEDENT if ( lcm == 1 ) : NEW_LINE INDENT lcm = - 1 NEW_LINE DEDENT print ( lcm ) NEW_LINE DEDENT
def maxAdjacentDifference ( A ) : NEW_LINE INDENT diff = 0 NEW_LINE for i in range ( 1 , len ( A ) , 1 ) : NEW_LINE INDENT diff = max ( diff , A [ i ] - A [ i - 1 ] ) NEW_LINE DEDENT return diff NEW_LINE DEDENT
def MinimumValue ( arr , N ) : NEW_LINE INDENT MinValue = sys . maxsize NEW_LINE for i in range ( N ) : NEW_LINE INDENT new_arr = [ ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT new_arr . append ( arr [ j ] ) NEW_LINE DEDENT MinValue = min ( MinValue , maxAdjacentDifference ( new_arr ) ) NEW_LINE DEDENT return MinValue NEW_LINE DEDENT
def findNode ( mp , n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = mp [ i + 1 ] NEW_LINE DEDENT count0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT DEDENT count0 -= 1 NEW_LINE if ( count0 <= ( n ) / ( 2 ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def count ( num ) : NEW_LINE INDENT ans = 0 NEW_LINE while num : NEW_LINE INDENT ans += num & 1 NEW_LINE num >>= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def checkGoodMatrix ( mat ) : NEW_LINE INDENT P = [ ] NEW_LINE S = [ ] NEW_LINE MR = [ ] NEW_LINE MC = [ ] NEW_LINE for i in range ( len ( mat ) ) : NEW_LINE INDENT for j in range ( len ( mat [ 0 ] ) ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT P . append ( mat [ i ] [ j ] ) NEW_LINE DEDENT if i + j == len ( mat ) - 1 : NEW_LINE INDENT S . append ( mat [ i ] [ j ] ) NEW_LINE DEDENT if i == ( len ( mat ) - 1 ) // 2 : NEW_LINE INDENT MR . append ( mat [ i ] [ j ] ) NEW_LINE DEDENT if j == ( len ( mat ) - 1 ) // 2 : NEW_LINE INDENT MC . append ( mat [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT S . reverse ( ) NEW_LINE P = convert ( P ) NEW_LINE S = convert ( S ) NEW_LINE MR = convert ( MR ) NEW_LINE MC = convert ( MC ) NEW_LINE setBitsPS = count ( P & S ) NEW_LINE setBitsMM = count ( MR & MC ) NEW_LINE if setBitsPS > setBitsMM : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % mod NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % mod NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT
def antisymmetricRelation ( N ) : NEW_LINE INDENT return ( power ( 2 , N ) * power ( 3 , ( N * N - N ) // 2 ) ) % mod NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % mod NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % mod NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT
def asymmetricRelation ( N ) : NEW_LINE INDENT return power ( 3 , ( N * N - N ) // 2 ) NEW_LINE DEDENT
def crossProduct ( vect_A , vect_B , cross_P ) : NEW_LINE INDENT cross_P [ 0 ] = ( vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ) NEW_LINE cross_P [ 1 ] = ( vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ) NEW_LINE cross_P [ 2 ] = ( vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ) NEW_LINE DEDENT
def checkCollinearity ( x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT A = [ x1 , y1 , z1 ] NEW_LINE B = [ x2 , y2 , z2 ] NEW_LINE cross_P = [ 0 for i in range ( 3 ) ] NEW_LINE crossProduct ( A , B , cross_P ) NEW_LINE if ( cross_P [ 0 ] == 0 and cross_P [ 1 ] == 0 and cross_P [ 2 ] == 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def vectorMagnitude ( x , y , z ) : NEW_LINE INDENT sum = x * x + y * y + z * z NEW_LINE return sqrt ( sum ) NEW_LINE DEDENT
def kineticEnergy ( M , V ) : NEW_LINE INDENT KineticEnergy = 0.5 * M * V * V NEW_LINE return KineticEnergy NEW_LINE DEDENT
def potentialEnergy ( M , H ) : NEW_LINE INDENT PotentialEnergy = M * 9.8 * H NEW_LINE return PotentialEnergy NEW_LINE DEDENT
def nearestPow ( x , y ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT k = int ( math . log ( x , y ) ) NEW_LINE if abs ( y ** k - x ) < abs ( y ** ( k + 1 ) - x ) : NEW_LINE INDENT return y ** k NEW_LINE DEDENT return y ** ( k + 1 ) NEW_LINE DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT even = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( N - even >= 1 ) : NEW_LINE INDENT print ( even ) NEW_LINE return NEW_LINE DEDENT print ( 0 ) NEW_LINE DEDENT
def nearestFibonacci ( num ) : NEW_LINE INDENT if ( num == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT first = 0 NEW_LINE second = 1 NEW_LINE third = first + second NEW_LINE while ( third <= num ) : NEW_LINE INDENT first = second NEW_LINE second = third NEW_LINE third = first + second NEW_LINE DEDENT if ( abs ( third - num ) >= abs ( second - num ) ) : NEW_LINE INDENT ans = second NEW_LINE DEDENT else : NEW_LINE INDENT ans = third NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def checkPermutation ( ans , a , n ) : NEW_LINE INDENT Max = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Max = max ( Max , ans [ i ] ) NEW_LINE if ( Max != a [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findPermutation ( a , n ) : NEW_LINE INDENT ans = [ 0 ] * n NEW_LINE um = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] not in um ) : NEW_LINE INDENT ans [ i ] = a [ i ] NEW_LINE um [ a [ i ] ] = i NEW_LINE DEDENT DEDENT v = [ ] NEW_LINE j = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i not in um ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( ans [ i ] == 0 ) : NEW_LINE INDENT ans [ i ] = v [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( checkPermutation ( ans , a , n ) ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def isPower ( m , y ) : NEW_LINE INDENT res1 = log ( y ) // log ( m ) NEW_LINE res2 = log ( y ) // log ( m ) NEW_LINE return ( res1 == res2 ) NEW_LINE DEDENT
def numSub ( arr , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPower ( m , arr [ i ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE ans += ( cnt * ( cnt - 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 0 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def SieveOfEratosthenes ( n ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def assignValues ( Edges , n ) : NEW_LINE INDENT tree = [ [ ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT u = Edges [ i ] [ 0 ] NEW_LINE v = Edges [ i ] [ 1 ] NEW_LINE tree [ u ] . append ( v ) NEW_LINE tree [ v ] . append ( u ) NEW_LINE DEDENT visited = [ False ] * ( n + 1 ) NEW_LINE answer = [ 0 ] * ( n + 1 ) NEW_LINE K = 1 NEW_LINE q = deque ( ) NEW_LINE q . append ( 1 ) NEW_LINE answer [ 1 ] = K NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT node = q . popleft ( ) NEW_LINE visited [ node ] = True NEW_LINE K = 2 if ( answer [ node ] == 1 ) else 1 NEW_LINE for child in tree [ node ] : NEW_LINE INDENT if ( not visited [ child ] ) : NEW_LINE INDENT q . append ( child ) NEW_LINE answer [ child ] = K NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( answer [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def distribute ( N , K , M , arr ) : NEW_LINE INDENT distribution = [ 0 ] * N NEW_LINE ptr = K - 1 NEW_LINE rem = M NEW_LINE while ( rem > 0 ) : NEW_LINE INDENT if ( rem >= arr [ ptr ] ) : NEW_LINE INDENT distribution [ ptr ] += arr [ ptr ] NEW_LINE rem -= arr [ ptr ] NEW_LINE DEDENT else : NEW_LINE INDENT distribution [ ptr ] += rem NEW_LINE rem = 0 NEW_LINE DEDENT ptr = ( ptr + 1 ) % N NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( distribution [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def sumOfSquaredDifferences ( arr , N ) : NEW_LINE INDENT ans = 0 NEW_LINE sumA , sumB = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sumA += ( arr [ i ] * arr [ i ] ) NEW_LINE sumB += arr [ i ] NEW_LINE DEDENT sumA = N * sumA NEW_LINE sumB = ( sumB * sumB ) NEW_LINE ans = sumA - sumB NEW_LINE print ( ans ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findMinimumNumber ( arr , N ) : NEW_LINE INDENT primes = [ ] NEW_LINE findPrime ( primes ) NEW_LINE ans = sys . maxsize NEW_LINE n = len ( primes ) NEW_LINE for i in range ( 1 , ( 1 << n ) , 1 ) : NEW_LINE INDENT temp = 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT temp *= primes [ j ] NEW_LINE DEDENT DEDENT check = True NEW_LINE for k in range ( N ) : NEW_LINE INDENT if ( gcd ( temp , arr [ k ] ) == 1 ) : NEW_LINE INDENT check = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( check ) : NEW_LINE INDENT ans = min ( ans , temp ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def waysToRemove ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT print ( n ) NEW_LINE return NEW_LINE DEDENT d = 0 NEW_LINE while d >= 0 : NEW_LINE INDENT length = m + ( m - 1 ) * d NEW_LINE if ( length > n ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += ( n - length ) + 1 NEW_LINE d += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def countStairs ( n , x , a , b ) : NEW_LINE INDENT vis = [ 0 ] * ( n + 1 ) NEW_LINE moves = [ + a , - a , + b , - b ] NEW_LINE q = deque ( ) NEW_LINE q . append ( x ) NEW_LINE vis [ x ] = 1 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT currentStair = q . popleft ( ) NEW_LINE for j in range ( 4 ) : NEW_LINE INDENT newStair = currentStair + moves [ j ] NEW_LINE if ( newStair > 0 and newStair <= n and ( not vis [ newStair ] ) ) : NEW_LINE INDENT q . append ( newStair ) NEW_LINE vis [ newStair ] = 1 NEW_LINE DEDENT DEDENT DEDENT cnt = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( vis [ i ] == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE DEDENT
def minimumSteps ( x , y ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( x != 0 and y != 0 ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT cnt += x / y NEW_LINE x %= y NEW_LINE DEDENT else : NEW_LINE INDENT cnt += y / x NEW_LINE y %= x NEW_LINE DEDENT DEDENT cnt -= 1 NEW_LINE if ( x > 1 or y > 1 ) : NEW_LINE INDENT cnt = - 1 NEW_LINE DEDENT print ( int ( cnt ) ) NEW_LINE DEDENT
def cntPairs ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE bit = [ 0 ] * 32 NEW_LINE for i in range ( N ) : NEW_LINE INDENT pos = ( int ) ( math . log2 ( arr [ i ] ) ) NEW_LINE bit [ pos ] += 1 NEW_LINE DEDENT for i in range ( 32 ) : NEW_LINE INDENT res += ( bit [ i ] * ( bit [ i ] - 1 ) ) // 2 NEW_LINE DEDENT return res NEW_LINE DEDENT
def minimumMEX ( arr , N , K ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 1 , N + 2 , 1 ) : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT for i in range ( K ) : NEW_LINE INDENT s . remove ( arr [ i ] ) NEW_LINE DEDENT mex = list ( s ) [ 0 ] NEW_LINE for i in range ( K , N , 1 ) : NEW_LINE INDENT s . remove ( arr [ i ] ) NEW_LINE s . add ( arr [ i - K ] ) NEW_LINE firstElem = list ( s ) [ 0 ] NEW_LINE mex = min ( mex , firstElem ) NEW_LINE DEDENT print ( mex ) NEW_LINE DEDENT
def smallerNumbers ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " " ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def minimumOperations ( X , Y ) : NEW_LINE INDENT GCD = gcd ( X , Y ) NEW_LINE X = X // GCD NEW_LINE Y = Y // GCD NEW_LINE count = 0 NEW_LINE while ( X != Y ) : NEW_LINE INDENT if ( Y > X ) : NEW_LINE INDENT X , Y = Y , X NEW_LINE DEDENT if ( X % 2 == 0 ) : NEW_LINE INDENT X = X // 2 NEW_LINE DEDENT elif ( X % 3 == 0 ) : NEW_LINE INDENT X = X // 3 NEW_LINE DEDENT elif ( X % 5 == 0 ) : NEW_LINE INDENT X = X // 5 NEW_LINE DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def minOperations ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT ans -= n NEW_LINE x = 1 NEW_LINE while ( 1 ) : NEW_LINE INDENT curPow = 1 NEW_LINE curCost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curCost += abs ( a [ i ] - curPow ) NEW_LINE curPow *= x NEW_LINE DEDENT if ( curPow / x > ans + a [ n - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = min ( ans , curCost ) NEW_LINE x += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def truncMod ( a , n ) : NEW_LINE INDENT q = a // n NEW_LINE return a - n * q NEW_LINE DEDENT
def addEdge ( Adj , u , v ) : NEW_LINE INDENT Adj [ u ] . append ( v ) NEW_LINE Adj [ v ] . append ( u ) NEW_LINE return Adj NEW_LINE DEDENT
def isPossible ( Arr , N ) : NEW_LINE INDENT Adj = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( Arr [ i ] [ 0 ] < Arr [ j ] [ 1 ] or Arr [ i ] [ 1 ] > Arr [ j ] [ 0 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( Arr [ i ] [ 2 ] == Arr [ j ] [ 2 ] ) : NEW_LINE INDENT Adj = addEdge ( Adj , i , j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT visited = [ False ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( visited [ i ] == False and len ( Adj [ i ] ) > 0 ) : NEW_LINE INDENT if ( check ( Adj , i , N , visited ) == False ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( "Yes" ) NEW_LINE DEDENT
def printArray ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def bitOr ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE length = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( length != 0 ) : NEW_LINE INDENT count += ( ( length ) * ( length + 1 ) ) // 2 NEW_LINE DEDENT length = 0 NEW_LINE DEDENT DEDENT count += ( ( length ) * ( length + 1 ) ) // 2 NEW_LINE return count NEW_LINE DEDENT
def mean ( arr , N ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT avg += ( arr [ i ] - avg ) / ( i + 1 ) NEW_LINE DEDENT return round ( avg , 7 ) NEW_LINE DEDENT
def maximumAND ( arr , n , m ) : NEW_LINE INDENT tot = 1 << n NEW_LINE mx = 0 NEW_LINE for bm in range ( tot ) : NEW_LINE INDENT andans = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( bm >> i ) & 1 ) : NEW_LINE INDENT if ( count == 0 ) : NEW_LINE INDENT andans = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT andans = andans & arr [ i ] NEW_LINE DEDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == ( m + 1 ) ) : NEW_LINE INDENT mx = max ( mx , andans ) NEW_LINE DEDENT DEDENT return mx NEW_LINE DEDENT
def findTotalSum ( ops ) : NEW_LINE INDENT if ( len ( ops ) == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT pts = [ ] NEW_LINE ans = 0 NEW_LINE for i in range ( len ( ops ) ) : NEW_LINE INDENT if ( ops [ i ] == "C" ) : NEW_LINE INDENT ans -= pts [ - 1 ] NEW_LINE pts . pop ( ) NEW_LINE DEDENT elif ( ops [ i ] == "D" ) : NEW_LINE INDENT pts . append ( pts [ - 1 ] * 2 ) NEW_LINE ans += pts [ - 1 ] NEW_LINE DEDENT elif ( ops [ i ] == "+" ) : NEW_LINE INDENT a = pts [ - 1 ] NEW_LINE pts . pop ( ) NEW_LINE b = pts [ - 1 ] NEW_LINE pts . append ( a ) NEW_LINE ans += ( a + b ) NEW_LINE pts . append ( a + b ) NEW_LINE DEDENT else : NEW_LINE INDENT n = int ( ops [ i ] ) NEW_LINE ans += n NEW_LINE pts . append ( n ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def findXOR ( mat , N ) : NEW_LINE INDENT XOR = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT for k in range ( N ) : NEW_LINE INDENT if ( ( i == j and j == k ) ) : NEW_LINE INDENT XOR ^= mat [ i ] [ j ] [ k ] NEW_LINE XOR ^= mat [ i ] [ j ] [ N - k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( XOR ) NEW_LINE DEDENT
def findXOR ( mat , N ) : NEW_LINE INDENT XOR = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT XOR ^= mat [ i ] [ i ] [ i ] NEW_LINE XOR ^= mat [ i ] [ i ] [ N - i - 1 ] NEW_LINE DEDENT print ( XOR ) NEW_LINE DEDENT
def countSubtreesUtil ( cur , par ) : NEW_LINE INDENT global mod , ans NEW_LINE res = 1 NEW_LINE for i in range ( len ( graph [ cur ] ) ) : NEW_LINE INDENT v = graph [ cur ] [ i ] NEW_LINE if ( v == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT res = ( res * ( countSubtreesUtil ( v , cur ) + 1 ) ) % mod NEW_LINE DEDENT ans = ( ans + res ) % mod NEW_LINE return res NEW_LINE DEDENT
def countSubtrees ( N , adj ) : NEW_LINE INDENT for i in range ( N - 1 ) : NEW_LINE INDENT a = adj [ i ] [ 0 ] NEW_LINE b = adj [ i ] [ 1 ] NEW_LINE graph [ a ] . append ( b ) NEW_LINE graph [ b ] . append ( a ) NEW_LINE DEDENT countSubtreesUtil ( 1 , 1 ) NEW_LINE print ( ans + 1 ) NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= limit ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , limit , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def findOperations ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE minm = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT minm = min ( minm , arr [ i ] ) NEW_LINE DEDENT val = minm NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == minm + 1 ) : NEW_LINE INDENT val = minm - 2 NEW_LINE break NEW_LINE DEDENT DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT D = arr [ i ] - val NEW_LINE if ( D == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( prime [ D ] == True ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif ( D % 2 == 0 ) : NEW_LINE INDENT cnt += 2 NEW_LINE DEDENT else : NEW_LINE INDENT if ( prime [ D - 2 ] == True ) : NEW_LINE INDENT cnt += 2 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 3 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def maximumRowValue ( n , m ) : NEW_LINE INDENT return gcd ( n , m ) NEW_LINE DEDENT
def checkCommonDivisor ( arr , N , X ) : NEW_LINE INDENT G = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT G = math . gcd ( G , arr [ i ] ) NEW_LINE DEDENT copy_G = G NEW_LINE for divisor in range ( 2 , X + 1 ) : NEW_LINE INDENT while ( G % divisor == 0 ) : NEW_LINE INDENT G = G // divisor NEW_LINE DEDENT DEDENT if ( G <= X ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] // copy_G , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE mp = defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT val = 1.0 * arr [ i ] NEW_LINE idx = 1.0 * ( i + 1 ) NEW_LINE count += mp [ val / idx ] NEW_LINE mp [ val / idx ] += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def findConvolution ( a , b ) : NEW_LINE INDENT global MOD NEW_LINE n , m = len ( a ) , len ( b ) NEW_LINE c = [ 0 ] * ( n + m - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT c [ i + j ] += ( a [ i ] * b [ j ] ) % MOD NEW_LINE DEDENT DEDENT for k in range ( len ( c ) ) : NEW_LINE INDENT c [ k ] %= MOD NEW_LINE print ( c [ k ] , end = " " ) NEW_LINE DEDENT DEDENT
def count1s ( start_i , start_j , end_i , end_j , mat ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( start_i , end_i ) : NEW_LINE INDENT for y in range ( start_j , end_j ) : NEW_LINE INDENT if ( mat [ x ] [ y ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findMinimumCount ( N , M , A , B , mat ) : NEW_LINE INDENT minimum = 1e9 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( i + A <= N and j + B <= M ) : NEW_LINE INDENT count = count1s ( i , j , i + A , j + B , mat ) NEW_LINE minimum = min ( count , minimum ) NEW_LINE DEDENT if ( i + B <= N and j + A <= M ) : NEW_LINE INDENT count = count1s ( i , j , i + B , j + A , mat ) NEW_LINE minimum = min ( count , minimum ) NEW_LINE DEDENT DEDENT DEDENT return minimum NEW_LINE DEDENT
def checkEvenPower ( n ) : NEW_LINE INDENT x = 0 NEW_LINE while ( x < n ) : NEW_LINE INDENT value = pow ( 2 , x ) NEW_LINE if ( value == n ) : NEW_LINE INDENT if ( x % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT x += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def getMaxUtil ( p , arr , ans , chosen , N ) : NEW_LINE INDENT if len ( p ) == N : NEW_LINE INDENT ans = max ( ans , calcScore ( p , arr ) ) NEW_LINE return ans NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if chosen [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT chosen [ i ] = True NEW_LINE p . append ( i ) NEW_LINE ans = getMaxUtil ( p , arr , ans , chosen , N ) NEW_LINE chosen [ i ] = False NEW_LINE p . pop ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def getMax ( arr , N ) : NEW_LINE INDENT ans = 0 NEW_LINE chosen = [ False for i in range ( N ) ] NEW_LINE p = [ ] NEW_LINE res = getMaxUtil ( p , arr , ans , chosen , N ) NEW_LINE print ( res ) NEW_LINE DEDENT
def multiplyByMersenne ( N , M ) : NEW_LINE INDENT x = int ( math . log2 ( M + 1 ) ) NEW_LINE return ( ( N << x ) - N ) NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 1 NEW_LINE while ( i <= N ) : NEW_LINE INDENT ans += N // i NEW_LINE i = i * K NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def minimumInsertions ( arr , N , K ) : NEW_LINE INDENT possible = 1 NEW_LINE res = 0 NEW_LINE last = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] >= K ) : NEW_LINE INDENT possible = 0 NEW_LINE break NEW_LINE DEDENT if ( last + arr [ i ] > K ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT last = arr [ i ] NEW_LINE DEDENT if ( possible ) : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def maxSubSum ( arr , n , k , totalDistinct ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT maxm = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE st = set ( ) NEW_LINE for j in range ( i , i + k , 1 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE st . add ( arr [ j ] ) NEW_LINE DEDENT if ( len ( st ) == totalDistinct ) : NEW_LINE INDENT maxm = max ( sum , maxm ) NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT
def distinct ( arr , N ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT st . add ( arr [ i ] ) NEW_LINE DEDENT return len ( st ) NEW_LINE DEDENT
def maxSubarraySumUtil ( arr , N , K , totalDistinct ) : NEW_LINE INDENT if ( K > N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT mx = 0 NEW_LINE sum = 0 NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] in mp ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT sum += arr [ i ] NEW_LINE if ( i >= K ) : NEW_LINE INDENT if ( arr [ i - K ] in mp ) : NEW_LINE INDENT mp [ arr [ i - K ] ] -= 1 NEW_LINE sum -= arr [ i - K ] NEW_LINE DEDENT if ( arr [ i - K ] in mp and mp [ arr [ i - K ] ] == 0 ) : NEW_LINE INDENT mp . remove ( arr [ i - K ] ) NEW_LINE DEDENT DEDENT if ( len ( mp ) == totalDistinct ) : NEW_LINE INDENT mx = max ( mx , sum ) NEW_LINE DEDENT DEDENT return mx NEW_LINE DEDENT
def maxSubarraySum ( arr , K ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE totalDistinct = distinct ( arr , N ) NEW_LINE print ( maxSubarraySumUtil ( arr , N , K , totalDistinct ) ) NEW_LINE DEDENT
def irreflexiveRelation ( N ) : NEW_LINE INDENT return power ( 2 , N * N - N ) NEW_LINE DEDENT
def countAPs ( N ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while ( i * i <= 2 * N ) : NEW_LINE INDENT res = 2 * N NEW_LINE if ( res % i == 0 ) : NEW_LINE INDENT op = res / i - i + 1 NEW_LINE if ( op % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( i * i != res and ( i - res / i + 1 ) % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( count - 1 ) NEW_LINE DEDENT
def perfectSquare ( num ) : NEW_LINE INDENT sr = int ( sqrt ( num ) ) NEW_LINE a = sr * sr NEW_LINE b = ( sr + 1 ) * ( sr + 1 ) NEW_LINE if ( ( num - a ) < ( b - num ) ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT
def powerOfTwo ( num ) : NEW_LINE INDENT lg = int ( log2 ( num ) ) NEW_LINE p = int ( pow ( 2 , lg ) ) NEW_LINE return p NEW_LINE DEDENT
def uniqueElement ( arr , N ) : NEW_LINE INDENT ans = True NEW_LINE freq = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] in freq ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT res = [ ] NEW_LINE for key , value in freq . items ( ) : NEW_LINE INDENT if ( value == 1 ) : NEW_LINE INDENT ans = False NEW_LINE ps = perfectSquare ( key ) NEW_LINE res . append ( powerOfTwo ( ps ) ) NEW_LINE DEDENT DEDENT res . sort ( reverse = False ) NEW_LINE for x in res : NEW_LINE INDENT print ( x , end = " " ) NEW_LINE DEDENT if ( ans ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def canExpress ( N ) : NEW_LINE INDENT temp = N NEW_LINE n = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT N //= 10 NEW_LINE n += 1 NEW_LINE DEDENT N = temp NEW_LINE sum = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT sum += pow ( N % 10 , n ) NEW_LINE N //= 10 NEW_LINE DEDENT return ( sum == temp ) NEW_LINE DEDENT
def precompute ( ) : NEW_LINE INDENT for i in range ( 1 , R , 1 ) : NEW_LINE INDENT if ( canExpress ( i ) ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , R , 1 ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE DEDENT DEDENT
def countNumbers ( queries , N ) : NEW_LINE INDENT precompute ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT L1 = queries [ i ] [ 0 ] NEW_LINE R1 = queries [ i ] [ 1 ] NEW_LINE print ( ( arr [ R1 ] - arr [ L1 - 1 ] ) , end = " " ) NEW_LINE DEDENT DEDENT
def isAnyPrime ( first , last ) : NEW_LINE INDENT global sieve NEW_LINE num1 = first * 10 + last NEW_LINE num2 = last * 10 + first NEW_LINE if ( sieve [ num1 ] == 1 or sieve [ num2 ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def sumOfNodeInAPath ( node_value ) : NEW_LINE INDENT sum_of_node = 0 NEW_LINE while ( node_value ) : NEW_LINE INDENT sum_of_node += node_value NEW_LINE node_value //= 2 NEW_LINE DEDENT print ( sum_of_node , end = " " ) NEW_LINE DEDENT
def findSum ( Q ) : NEW_LINE INDENT for i in range ( len ( Q ) ) : NEW_LINE INDENT node_value = Q [ i ] NEW_LINE sumOfNodeInAPath ( node_value ) NEW_LINE print ( end = "" ) NEW_LINE DEDENT DEDENT
def oddDivisor ( N ) : NEW_LINE INDENT X = N NEW_LINE while ( N % 2 == 0 ) : NEW_LINE INDENT N //= 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i <= X ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT i += 2 NEW_LINE DEDENT if ( N != X ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT return "No" NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT
def preprocess ( ) : NEW_LINE INDENT for i in range ( 1 , 1000001 ) : NEW_LINE INDENT primes [ i ] = i NEW_LINE DEDENT i = 2 NEW_LINE while ( i * i <= 1000000 ) : NEW_LINE INDENT if ( primes [ i ] == i ) : NEW_LINE INDENT for j in range ( 2 * i , 1000001 , i ) : NEW_LINE INDENT if ( primes [ j ] == j ) : NEW_LINE INDENT primes [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def Steps ( x , m ) : NEW_LINE INDENT steps = 0 NEW_LINE flag = False NEW_LINE while ( x > 1 ) : NEW_LINE INDENT if ( primes [ x ] > m ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT x //= primes [ x ] NEW_LINE steps += 1 NEW_LINE DEDENT if ( flag != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT
def minimumSteps ( x , y , m ) : NEW_LINE INDENT preprocess ( ) NEW_LINE g = gcd ( x , y ) NEW_LINE x = x // g NEW_LINE y = y // g NEW_LINE x_steps = Steps ( x , m ) NEW_LINE y_steps = Steps ( y , m ) NEW_LINE if ( x_steps == - 1 or y_steps == - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return x_steps + y_steps NEW_LINE DEDENT
def LongestNonDeficientSubsequence ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isNonDeficient ( arr [ i ] ) ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE num = 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT if ( countPrimeFactors ( num ) == 2 ) : NEW_LINE INDENT sum += num NEW_LINE i += 1 NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def check ( n , k ) : NEW_LINE INDENT s = findSum ( k - 1 ) NEW_LINE if ( s >= n ) : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT DEDENT
def setBitCount ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE while n : NEW_LINE INDENT ans += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isPronic ( n ) : NEW_LINE INDENT for i in range ( int ( n ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if i * ( i + 1 ) == n : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def LOG ( x , base ) : NEW_LINE INDENT return int ( math . log ( x ) / math . log ( base ) ) NEW_LINE DEDENT
def countSubsequences ( A ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for el in A : NEW_LINE INDENT if ( el % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( odd == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 << len ( A ) - 1 ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT while ( b > 0 ) : NEW_LINE INDENT rem = a % b NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT return a NEW_LINE DEDENT
def countNumberOfWays ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT g = 0 NEW_LINE power = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT power += 1 NEW_LINE n //= 2 NEW_LINE DEDENT g = gcd ( g , power ) NEW_LINE for i in range ( 3 , int ( math . sqrt ( g ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT power += 1 NEW_LINE n //= i NEW_LINE DEDENT g = gcd ( g , power ) NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT g = gcd ( g , 1 ) NEW_LINE DEDENT ways = 1 NEW_LINE power = 0 NEW_LINE while ( g % 2 == 0 ) : NEW_LINE INDENT g //= 2 NEW_LINE power += 1 NEW_LINE DEDENT ways *= ( power + 1 ) NEW_LINE for i in range ( 3 , int ( math . sqrt ( g ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( g % i == 0 ) : NEW_LINE INDENT power += 1 NEW_LINE g /= i NEW_LINE DEDENT ways *= ( power + 1 ) NEW_LINE DEDENT if ( g > 2 ) : NEW_LINE INDENT ways *= 2 NEW_LINE DEDENT return ways NEW_LINE DEDENT
def coprime ( a , b ) : NEW_LINE INDENT return ( math . gcd ( a , b ) ) == 1 NEW_LINE DEDENT
def noOfCoPrimePairs ( N , d1 , d2 ) : NEW_LINE INDENT l = [ ] NEW_LINE l . append ( str ( d1 ) ) NEW_LINE l . append ( str ( d2 ) ) NEW_LINE l . sort ( ) NEW_LINE if int ( N ) < int ( l [ 1 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT total = temp2 = deepcopy ( l ) NEW_LINE flag = 0 NEW_LINE temp3 = [ ] NEW_LINE while len ( l [ 0 ] ) < 10 : NEW_LINE INDENT for i in range ( len ( l ) ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT if int ( l [ i ] + temp2 [ j ] ) > int ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT total . append ( l [ i ] + temp2 [ j ] ) NEW_LINE temp3 . append ( l [ i ] + temp2 [ j ] ) NEW_LINE DEDENT if flag == 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT break NEW_LINE DEDENT l = deepcopy ( temp3 ) NEW_LINE temp3 = [ ] NEW_LINE DEDENT lenOfTotal = len ( total ) NEW_LINE ans = numOfPairs ( total , lenOfTotal ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def countEqualElementPairs ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT total += ( value * ( value - 1 ) ) / 2 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( int ( total - ( mp [ arr [ i ] ] - 1 ) ) , end = " " ) NEW_LINE DEDENT DEDENT
def minDeletions ( arr , N ) : NEW_LINE INDENT freq = defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT v = [ ] NEW_LINE for z in freq . keys ( ) : NEW_LINE INDENT v . append ( freq [ z ] ) NEW_LINE DEDENT v . sort ( ) NEW_LINE size = len ( v ) NEW_LINE ans = N - ( v [ 0 ] * size ) NEW_LINE for i in range ( 1 , len ( v ) ) : NEW_LINE INDENT if ( v [ i ] != v [ i - 1 ] ) : NEW_LINE INDENT safe = v [ i ] * ( size - i ) NEW_LINE ans = min ( ans , N - safe ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT odd = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT ans = ( N - odd + odd // 2 - 1 ) + odd // 2 NEW_LINE return ans NEW_LINE DEDENT
def countBit ( n ) : NEW_LINE INDENT return int ( math . log ( n , 2 ) ) + 1 NEW_LINE DEDENT
def countSetBit ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE while n : NEW_LINE INDENT ans += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maximize ( n ) : NEW_LINE INDENT bits = countBit ( n ) NEW_LINE setBits = countSetBit ( n ) NEW_LINE ans = 0 NEW_LINE for i in range ( bits ) : NEW_LINE INDENT if i < setBits : NEW_LINE INDENT ans |= 1 NEW_LINE DEDENT if i != setBits - 1 : NEW_LINE INDENT ans <<= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minimize ( n ) : NEW_LINE INDENT setBits = countSetBit ( n ) NEW_LINE ans = 0 NEW_LINE for i in range ( setBits ) : NEW_LINE INDENT ans |= 1 NEW_LINE if i != setBits - 1 : NEW_LINE INDENT ans <<= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maxDiff ( arr ) : NEW_LINE INDENT caseOne = 0 NEW_LINE SumOfOdd = 0 NEW_LINE SumOfeven = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if i % 2 : NEW_LINE INDENT SumOfOdd += minimize ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT SumOfeven += maximize ( arr [ i ] ) NEW_LINE DEDENT DEDENT caseOne = abs ( SumOfOdd - SumOfeven ) NEW_LINE caseTwo = 0 NEW_LINE SumOfOdd = 0 NEW_LINE SumOfeven = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if i % 2 : NEW_LINE INDENT SumOfOdd += maximize ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT SumOfeven += minimize ( arr [ i ] ) NEW_LINE DEDENT DEDENT caseTwo = abs ( SumOfOdd - SumOfeven ) NEW_LINE return max ( caseOne , caseTwo ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT vowel = "aeiou" NEW_LINE for i in range ( len ( vowel ) ) : NEW_LINE INDENT if ( vowel [ i ] == c ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def printRLE ( str , typed ) : NEW_LINE INDENT n = len ( str ) NEW_LINE m = len ( typed ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] != typed [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT if isVowel ( str [ i ] ) == False : NEW_LINE INDENT j = j + 1 NEW_LINE continue NEW_LINE DEDENT count1 = 1 NEW_LINE while ( i < n - 1 and ( str [ i ] == str [ i + 1 ] ) ) : NEW_LINE INDENT count1 = count1 + 1 NEW_LINE i = i + 1 NEW_LINE DEDENT count2 = 1 NEW_LINE while ( j < m - 1 and typed [ j ] == str [ i ] ) : NEW_LINE INDENT count2 = count2 + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT if count1 > count2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findSplit ( arr , N ) : NEW_LINE INDENT l = 1 NEW_LINE r = N - 2 NEW_LINE sum = [ 0 ] * N NEW_LINE sum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT while ( l < r ) : NEW_LINE INDENT lsum = sum [ l - 1 ] NEW_LINE msum = sum [ r - 1 ] - sum [ l ] NEW_LINE rsum = sum [ N - 1 ] - sum [ r ] NEW_LINE if ( lsum == msum and msum == rsum ) : NEW_LINE INDENT print ( l , r ) NEW_LINE return NEW_LINE DEDENT if ( lsum < rsum ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif ( lsum > rsum ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def solve ( A , n , Q , q ) : NEW_LINE INDENT one = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] == 1 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT glows = 0 NEW_LINE count = 0 NEW_LINE if ( one >= int ( math . ceil ( n / 2 ) ) ) : NEW_LINE INDENT glows = 1 NEW_LINE DEDENT for i in range ( 0 , q ) : NEW_LINE INDENT prev = glows NEW_LINE if ( A [ Q [ i ] - 1 ] == 1 ) : NEW_LINE INDENT one -= 1 NEW_LINE DEDENT if ( A [ Q [ i ] - 1 ] == 0 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT A [ Q [ i ] - 1 ] ^= 1 NEW_LINE if ( one >= int ( math . ceil ( n / 2.0 ) ) ) : NEW_LINE INDENT glows = 1 NEW_LINE DEDENT else : NEW_LINE INDENT glows = 0 NEW_LINE DEDENT if ( prev != glows ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def elementsHavingDigitSumK ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( sumOfDigits ( arr [ i ] ) == K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def processDiagonal ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE getBit = 1 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT S = 0 NEW_LINE NS = 0 NEW_LINE for j in arr : NEW_LINE INDENT if getBit & j : NEW_LINE INDENT S += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT NS += 1 NEW_LINE DEDENT if S > NS : NEW_LINE INDENT ans += 2 ** i NEW_LINE DEDENT getBit <<= 1 NEW_LINE return ans NEW_LINE DEDENT DEDENT
def findSum ( mat ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE priDiag = [ ] NEW_LINE while i < len ( mat ) : NEW_LINE INDENT priDiag . append ( mat [ i ] [ j ] ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT i = 0 NEW_LINE j = len ( mat ) - 1 NEW_LINE secDiag = [ ] NEW_LINE while i < len ( mat ) : NEW_LINE INDENT secDiag . append ( mat [ i ] [ j ] ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return processDiagonal ( priDiag ) + processDiagonal ( secDiag ) NEW_LINE DEDENT
def minimumDifference ( N ) : NEW_LINE INDENT sum1 = ( 1 << N ) NEW_LINE sum2 = 0 NEW_LINE for i in range ( 1 , N // 2 ) : NEW_LINE INDENT sum1 += ( 1 << i ) NEW_LINE DEDENT for i in range ( N // 2 , N ) : NEW_LINE INDENT sum2 += ( 1 << i ) NEW_LINE DEDENT print ( sum1 - sum2 ) NEW_LINE DEDENT
