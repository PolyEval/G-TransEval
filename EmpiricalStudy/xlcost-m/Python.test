def sumOfTwoCubes ( n ) : NEW_LINE INDENT lo = 1 NEW_LINE hi = round ( math . pow ( n , 1 / 3 ) ) NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT curr = ( lo * lo * lo + hi * hi * hi ) NEW_LINE if ( curr == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( curr < n ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def countPairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ j ] != 0 and a [ i ] % a [ j ] == 0 ) : NEW_LINE INDENT if ( ( a [ i ] + a [ j ] ) == ( a [ i ] // a [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def check ( A , B ) : NEW_LINE INDENT if ( A == B ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dig1 = math . floor ( math . log10 ( A ) + 1 ) NEW_LINE dig2 = math . floor ( math . log10 ( B ) + 1 ) NEW_LINE if ( dig1 != dig2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT temp = A NEW_LINE while ( True ) : NEW_LINE INDENT power = pow ( 10 , dig1 - 1 ) NEW_LINE firstdigit = A // power NEW_LINE A = A - firstdigit * power NEW_LINE A = A * 10 + firstdigit NEW_LINE if ( A == B ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( A == temp ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT
def checkPronic ( x ) : NEW_LINE INDENT for i in range ( int ( math . sqrt ( x ) ) + 1 ) : NEW_LINE INDENT if ( x == i * ( i + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def oddDivisors ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT powerOfTwo = 2 NEW_LINE count = 0 NEW_LINE while ( powerOfTwo <= arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE powerOfTwo = 2 * powerOfTwo NEW_LINE DEDENT print ( count , end = " " ) NEW_LINE DEDENT DEDENT
def calcScr ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT ans += ( i ^ arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxAdjacent ( arr , N ) : NEW_LINE INDENT res = [ ] NEW_LINE arr_max = - sys . maxsize - 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT arr_max = max ( arr_max , abs ( arr [ i - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT for i in range ( 1 , N - 1 ) : NEW_LINE INDENT curr_max = abs ( arr [ i - 1 ] - arr [ i + 1 ] ) NEW_LINE ans = max ( curr_max , arr_max ) NEW_LINE res . append ( ans ) NEW_LINE DEDENT for x in res : NEW_LINE INDENT print ( x , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def flippingBits ( N , K ) : NEW_LINE INDENT X = ( 1 << ( K - 1 ) ) - 1 NEW_LINE N = X - N NEW_LINE print ( N ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def minMoves ( arr , N ) : NEW_LINE INDENT odd_element_cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT odd_element_cnt += 1 NEW_LINE DEDENT DEDENT moves = ( odd_element_cnt ) // 2 NEW_LINE if ( odd_element_cnt % 2 != 0 ) : NEW_LINE INDENT moves += 2 NEW_LINE DEDENT print ( moves ) NEW_LINE DEDENT
def findSum ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT sum_odd , sum_even = 0 , 0 NEW_LINE for itr in mp : NEW_LINE INDENT if ( mp [ itr ] % 2 != 0 ) : NEW_LINE INDENT sum_odd += ( itr ) * ( mp [ itr ] ) NEW_LINE DEDENT if ( mp [ itr ] % 2 == 0 ) : NEW_LINE INDENT sum_even += ( itr ) * ( mp [ itr ] ) NEW_LINE DEDENT DEDENT diff = sum_even - sum_odd NEW_LINE return diff NEW_LINE DEDENT
def findNumber ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE maxElement = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE if ( maxElement < arr [ i ] ) : NEW_LINE INDENT maxElement = arr [ i ] NEW_LINE DEDENT DEDENT res = onesComplement ( res , maxElement ) NEW_LINE return ( res ) NEW_LINE DEDENT
def findValOfNWithOperat ( N , K ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT N += K * 2 NEW_LINE DEDENT else : NEW_LINE INDENT N += smallestDivisorGr1 ( N ) + ( K - 1 ) * 2 NEW_LINE DEDENT return N NEW_LINE DEDENT
def CntOfSubsetsByPartitioning ( arr , N ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT freqGCD = 0 NEW_LINE for i in freq : NEW_LINE INDENT freqGCD = gcd ( freqGCD , freq [ i ] ) NEW_LINE DEDENT return ( N ) // freqGCD NEW_LINE DEDENT
def alternatingSumOfFirst_N ( N ) : NEW_LINE INDENT alternateSum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT alternateSum += - i NEW_LINE DEDENT else : NEW_LINE INDENT alternateSum += i NEW_LINE DEDENT DEDENT return alternateSum NEW_LINE DEDENT
def countOperations ( arr , N ) : NEW_LINE INDENT count_zeros = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT count_zeros += 1 NEW_LINE DEDENT DEDENT sum = array_sum ( arr , N ) NEW_LINE if ( count_zeros ) : NEW_LINE INDENT return count_zeros NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def power ( x , N ) : NEW_LINE INDENT res = 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) NEW_LINE DEDENT x = ( x * x ) NEW_LINE N = N >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def F_1 ( N , F_N ) : NEW_LINE INDENT P_2 = power ( 2 , N - 1 ) NEW_LINE modInv = moduloInverse ( P_2 ) NEW_LINE res = 0 NEW_LINE res = ( ( modInv % M ) * ( F_N % M ) ) % M NEW_LINE return res NEW_LINE DEDENT
def findNumbers ( n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i <= n ) : NEW_LINE INDENT print ( 2 * i * i + 4 * i + 1 + i % 2 , end = " " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def isPower ( x , y ) : NEW_LINE INDENT res1 = math . log ( y ) // math . log ( x ) NEW_LINE res2 = math . log ( y ) // math . log ( x ) NEW_LINE return ( res1 == res2 ) NEW_LINE DEDENT
def countPairs ( A , B , N , M , List ) : NEW_LINE INDENT count = 0 NEW_LINE par = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT par [ i ] = i NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT index1 = find ( par , List [ i ] [ 0 ] - 1 ) NEW_LINE index2 = find ( par , List [ i ] [ 1 ] - 1 ) NEW_LINE if ( index1 != index2 ) : NEW_LINE INDENT union ( par , index1 , index2 ) NEW_LINE DEDENT DEDENT map = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT map [ A [ i ] ] = i NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] != B [ i ] ) : NEW_LINE INDENT if ( B [ i ] not in map . keys ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT j = map [ B [ i ] ] NEW_LINE if ( find ( par , i ) != find ( par , j ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def minDivisior ( n ) : NEW_LINE INDENT if ( prime ( n ) ) : NEW_LINE INDENT print ( 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( n // i , n // i * ( i - 1 ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def Find_min ( diff_mod , count_mod , k ) : NEW_LINE INDENT min_oprn = sys . maxsize NEW_LINE oprn = 0 NEW_LINE for x in range ( k ) : NEW_LINE INDENT oprn = 0 NEW_LINE for w in diff_mod : NEW_LINE INDENT if ( w != x ) : NEW_LINE INDENT if ( w == 0 ) : NEW_LINE INDENT oprn += ( min ( x , k - x ) * count_mod [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oprn += ( min ( abs ( x - w ) , k + x - w ) * count_mod [ w ] ) NEW_LINE DEDENT DEDENT DEDENT if ( oprn < min_oprn ) : NEW_LINE INDENT min_oprn = oprn NEW_LINE DEDENT DEDENT return min_oprn NEW_LINE DEDENT
def maxSubarrayRatio ( arr , n ) : NEW_LINE INDENT maxRatio = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT ratio = arr [ i ] NEW_LINE for k in range ( i + 1 , j + 1 ) : NEW_LINE INDENT ratio = ratio // arr [ k ] NEW_LINE DEDENT maxRatio = maximum ( maxRatio , ratio ) NEW_LINE DEDENT DEDENT return int ( maxRatio ) NEW_LINE DEDENT
def is_possible ( x , y ) : NEW_LINE INDENT if ( x < 2 and y != 0 ) : NEW_LINE INDENT return false NEW_LINE DEDENT y = y - x + 1 NEW_LINE if ( y % 2 == 0 and y >= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def sum_of_differences ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE while ( i < N - 1 ) : NEW_LINE INDENT if arr [ i ] < arr [ i + 1 ] : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( i + 1 , N - 1 ) : NEW_LINE INDENT if arr [ j ] >= arr [ j + 1 ] : NEW_LINE INDENT sum += ( arr [ j ] - arr [ i ] ) NEW_LINE i = j NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 and arr [ i ] < arr [ N - 1 ] : NEW_LINE INDENT sum += ( arr [ N - 1 ] - arr [ i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getLastTwoPerson ( n ) : NEW_LINE INDENT total = n NEW_LINE head = newNode ( 1 ) NEW_LINE temp = head NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT temp . next = newNode ( i ) NEW_LINE temp = temp . next NEW_LINE DEDENT temp . next = head NEW_LINE temp = head NEW_LINE de = None NEW_LINE while ( total != 2 ) : NEW_LINE INDENT de = temp . next . next NEW_LINE temp . next . next = temp . next . next . next NEW_LINE temp = temp . next NEW_LINE del de NEW_LINE total -= 1 NEW_LINE DEDENT print ( temp . val , temp . next . val ) NEW_LINE DEDENT
def gcd ( x , y ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return y NEW_LINE DEDENT return gcd ( y % x , x ) NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT last_digit = temp % 10 NEW_LINE if ( last_digit == 0 or last_digit == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % last_digit == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = temp // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
def costOfSubsequence ( N , arr , costArray ) : NEW_LINE INDENT i , temp , cost = 0 , 0 , 0 NEW_LINE removedElements = { '' } NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE if ( ( ( arr [ i - 1 ] < temp ) and ( temp < arr [ i + 1 ] ) ) or ( ( arr [ i - 1 ] > temp ) and ( temp > arr [ i + 1 ] ) ) ) : NEW_LINE INDENT removedElements . add ( temp ) NEW_LINE DEDENT DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE if ( temp not in removedElements ) : NEW_LINE INDENT ans = ans + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT cost += costArray [ i ] NEW_LINE DEDENT DEDENT print ( ans , end = ", " ) NEW_LINE print ( cost ) NEW_LINE DEDENT
def findRatio ( arr , n ) : NEW_LINE INDENT gcd = findGCD ( arr , n ) NEW_LINE lcm = findLCM ( arr , n ) NEW_LINE print ( int ( lcm / gcd ) , ":" , "1" ) NEW_LINE DEDENT
def PentacontahenagonNum ( N ) : NEW_LINE INDENT return ( 49 * N * N - 47 * N ) // 2 NEW_LINE DEDENT
def isRepdigit ( num , b ) : NEW_LINE INDENT prev = - 1 NEW_LINE while ( num ) : NEW_LINE INDENT digit = num % b NEW_LINE num //= b NEW_LINE if ( prev != - 1 and digit != prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = digit NEW_LINE DEDENT return True NEW_LINE DEDENT
def isHonakerPrime ( n ) : NEW_LINE INDENT pos = position [ n ] NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return bool ( getSum ( n ) == getSum ( pos ) ) NEW_LINE DEDENT
def checkDivisibility ( n , digit ) : NEW_LINE INDENT return ( ( digit != 0 ) and ( ( n % digit ) == 0 ) ) NEW_LINE DEDENT
def lastDigit ( n ) : NEW_LINE INDENT return ( n % 10 ) NEW_LINE DEDENT
def count ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if check ( arr [ i ] & arr [ j ] ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def calculate_SPF ( ) : NEW_LINE INDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAX + 1 , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i <= MAX ) : NEW_LINE INDENT if ( spf [ i ] == i ) j = i * i while ( j <= MAX ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT j += i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
def isBrilliant ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE isPrime = [ 0 ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( 2 , n , 1 ) : NEW_LINE INDENT x = n // i NEW_LINE if ( isPrime [ i ] and isPrime [ x ] and x * i == n ) : NEW_LINE INDENT if ( countDigit ( i ) == countDigit ( x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def icosikaienneagonalNum ( n ) : NEW_LINE INDENT return ( 27 * n * n - 25 * n ) // 2 NEW_LINE DEDENT
def isPerfectTotientNum ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( n > 1 ) : NEW_LINE INDENT sum = sum + phi ( n ) NEW_LINE n = phi ( n ) NEW_LINE DEDENT if ( sum == temp ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return ( fact ( n ) // ( fact ( r ) * fact ( n - r ) ) ) NEW_LINE DEDENT
def solve ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT ans += N NEW_LINE N //= 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def smallestNumber ( N ) : NEW_LINE INDENT L = pow ( 10 , N ) - 1 NEW_LINE S = pow ( 10 , N - 1 ) NEW_LINE for i in range ( S , L ) : NEW_LINE INDENT if ( i % N == 0 ) : NEW_LINE INDENT print ( i ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT
def maxAdjacentDifference ( N , K ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return K NEW_LINE DEDENT return 2 * K NEW_LINE DEDENT
def CountPairs ( arr , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT return ( ( even * ( even - 1 ) ) // 2 + ( even * odd ) ) NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum1 = sum1 + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum1 NEW_LINE DEDENT
def smallestNumber ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( getSum ( i ) == N ) : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
def isZuckerman ( n ) : NEW_LINE INDENT return n % getProduct ( n ) == 0 NEW_LINE DEDENT
def isGiugaNum ( n ) : NEW_LINE INDENT if ( not ( isComposite ( n ) ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT N = n NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT if ( ( int ( N / 2 ) - 1 ) % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( n / 2 ) NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT if ( ( int ( N / i ) - 1 ) % i != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( n / i ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT if ( ( int ( N / n ) - 1 ) % n != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def updateFreq ( n , freq ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT digit = n % TEN NEW_LINE freq [ digit ] += 1 NEW_LINE n = n // TEN NEW_LINE DEDENT DEDENT
def OrmistonPrime ( n1 , n2 ) : NEW_LINE INDENT return ( isPrime ( n1 ) and isPrime ( n2 ) and areAnagrams ( n1 , n2 ) ) NEW_LINE DEDENT
def calculateKummer ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = result * primes [ i ] NEW_LINE DEDENT return ( - 1 + result ) NEW_LINE DEDENT
def SieveOfEratosthenes ( maxm ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = True NEW_LINE for i in range ( 2 , maxm + 1 ) : NEW_LINE INDENT if i * i > maxm : NEW_LINE INDENT break NEW_LINE DEDENT if ( not prime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , maxm + 1 , i ) : NEW_LINE INDENT prime [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT
def func ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxx = 0 NEW_LINE freq = [ 0 ] * 100005 NEW_LINE temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE freq [ temp ] += 1 NEW_LINE maxx = max ( maxx , temp ) NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT freq [ i ] += freq [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT if ( freq [ i ] ) : NEW_LINE INDENT value = 0 NEW_LINE cur = ceil ( 0.5 * i ) - 1.0 NEW_LINE j = 1.5 NEW_LINE while ( 1 ) : NEW_LINE INDENT val = min ( maxx , ( ceil ( i * j ) - 1.0 ) ) NEW_LINE times = ( freq [ i ] - freq [ i - 1 ] ) NEW_LINE con = j - 0.5 NEW_LINE ans += times * con * ( freq [ int ( val ) ] - freq [ int ( cur ) ] ) NEW_LINE cur = val NEW_LINE if ( val == maxx ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT
def findAverageOfCube ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * i * i NEW_LINE DEDENT return round ( sum / n , 6 ) NEW_LINE DEDENT
def find ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT p = log ( x ) / log ( 2 ) NEW_LINE return binpow ( 2 , p + 1 ) - 1 NEW_LINE DEDENT
def totalCountDifference ( n ) : NEW_LINE INDENT ans = getBinary ( n ) NEW_LINE req = 0 NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT if ( ans [ i ] == '1' ) : NEW_LINE INDENT req += find ( binpow ( 2 , i ) ) NEW_LINE DEDENT DEDENT return req NEW_LINE DEDENT
def findIndex ( n ) : NEW_LINE INDENT x = math . sqrt ( 2 * math . pow ( 10 , ( n - 1 ) ) ) NEW_LINE return round ( x ) NEW_LINE DEDENT
def getParity ( n , A ) : NEW_LINE INDENT for x in A : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT print ( "Even" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "Odd" ) NEW_LINE DEDENT
def lastTwoDigits ( N ) : NEW_LINE INDENT if ( N >= 10 ) : NEW_LINE INDENT print ( "00" , end = "" ) NEW_LINE return NEW_LINE DEDENT fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = ( fac * i ) % 100 NEW_LINE DEDENT print ( fac ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def findArrangement ( N ) : NEW_LINE INDENT if ( N < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) // 3 NEW_LINE DEDENT
def sumOfProductOfDigits ( n1 , n2 ) : NEW_LINE INDENT sum1 = 0 NEW_LINE while ( n1 > 0 and n2 > 0 ) : NEW_LINE INDENT sum1 += ( ( n1 % 10 ) * ( n2 % 10 ) ) NEW_LINE n1 = n1 // 10 NEW_LINE n2 = n2 // 10 NEW_LINE DEDENT return sum1 NEW_LINE DEDENT
def divisorsSame ( n ) : NEW_LINE INDENT return ( n - 2 ) % 4 == 0 NEW_LINE DEDENT
def countSubsequences ( arr , n ) : NEW_LINE INDENT totalSubsequence = ( int ) ( pow ( 2 , n ) - 1 ) NEW_LINE countPrime = 0 NEW_LINE countOnes = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT countOnes += 1 NEW_LINE DEDENT elif ( isPrime ( arr [ i ] ) ) : NEW_LINE INDENT countPrime += 1 NEW_LINE DEDENT DEDENT compositeSubsequence = 0 NEW_LINE onesSequence = ( int ) ( pow ( 2 , countOnes ) - 1 ) NEW_LINE compositeSubsequence = ( totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ) NEW_LINE return compositeSubsequence NEW_LINE DEDENT
def Centered_Hexadecagonal_num ( n ) : NEW_LINE INDENT return ( 8 * n * n - 8 * n + 1 ) NEW_LINE DEDENT
def isdecagonal ( N ) : NEW_LINE INDENT n = ( 3 + math . sqrt ( 16 * N + 9 ) ) / 8 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def ishendecagonal ( N ) : NEW_LINE INDENT n = ( 7 + math . sqrt ( 72 * N + 49 ) ) // 18 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isenneadecagonal ( N ) : NEW_LINE INDENT n = ( 15 + math . sqrt ( 136 * N + 225 ) ) / 34 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( math . ceil ( math . log ( n ) // math . log ( 2 ) ) == math . floor ( math . log ( n ) // math . log ( 2 ) ) ) NEW_LINE DEDENT
def cntArray ( A , N ) : NEW_LINE INDENT result = 0 NEW_LINE frequency = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT frequency [ A [ i ] ] = frequency [ A [ i ] ] + 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT frequency_of_i = frequency [ i ] NEW_LINE result = result + ( ( frequency_of_i ) * ( frequency_of_i + 1 ) ) / 2 NEW_LINE DEDENT print ( int ( result ) ) NEW_LINE print ( "" ) NEW_LINE DEDENT
def solve ( A ) : NEW_LINE INDENT ctr = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if A [ i ] % 2 == 1 : NEW_LINE INDENT ctr += 1 NEW_LINE DEDENT DEDENT if ctr % 2 == 1 : NEW_LINE INDENT return 'No' NEW_LINE DEDENT else : NEW_LINE INDENT return 'Yes' NEW_LINE DEDENT DEDENT
def findNumbers ( N ) : NEW_LINE INDENT for i in range ( 1 , N // 2 + 1 ) : NEW_LINE INDENT print ( i , end = ', ' ) NEW_LINE print ( - i , end = ', ' ) NEW_LINE DEDENT if N % 2 == 1 : NEW_LINE INDENT print ( 0 , end = '' ) NEW_LINE DEDENT DEDENT
def previousPerfectSquare ( N ) : NEW_LINE INDENT prevN = math . floor ( math . sqrt ( N ) ) NEW_LINE if ( prevN * prevN == N ) : NEW_LINE INDENT prevN -= 1 NEW_LINE DEDENT return prevN * prevN NEW_LINE DEDENT
def digit_sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT m = n % 10 NEW_LINE sum = sum + m NEW_LINE n = n // 10 NEW_LINE DEDENT return ( sum ) NEW_LINE DEDENT
def dfs ( Node , parent ) : NEW_LINE INDENT global ans NEW_LINE if ( isPerfect ( weight [ Node ] ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT for to in graph [ Node ] : NEW_LINE INDENT if ( to == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( to , Node ) NEW_LINE DEDENT DEDENT
def MinimumGCD ( arr , n ) : NEW_LINE INDENT g = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT g = gcd ( g , arr [ i ] ) NEW_LINE DEDENT return g NEW_LINE DEDENT
def fibonacciSubarrays ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE if ( isFibonacci ( sum ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def Gill ( x0 , y0 , x , h ) : NEW_LINE INDENT n = ( ( x - x0 ) / h ) NEW_LINE y = y0 NEW_LINE for i in range ( 1 , int ( n + 1 ) , 1 ) : NEW_LINE INDENT k1 = h * dydx ( x0 , y ) NEW_LINE k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) NEW_LINE k3 = h * dydx ( x0 + 0.5 * h , y + 0.5 * ( - 1 + sqrt ( 2 ) ) * k1 + k2 * ( 1 - 0.5 * sqrt ( 2 ) ) ) NEW_LINE k4 = h * dydx ( x0 + h , y - ( 0.5 * sqrt ( 2 ) ) * k2 + k3 * ( 1 + 0.5 * sqrt ( 2 ) ) ) NEW_LINE y = y + ( 1 / 6 ) * ( k1 + ( 2 - sqrt ( 2 ) ) * k2 + ( 2 + sqrt ( 2 ) ) * k3 + k4 ) NEW_LINE x0 = x0 + h NEW_LINE DEDENT return y NEW_LINE DEDENT
def PythagoreanTriplet ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE for a in range ( 1 , n , 1 ) : NEW_LINE INDENT b = ( n * n - 2 * n * a ) // ( 2 * n - 2 * a ) NEW_LINE c = n - a - b NEW_LINE if ( a * a + b * b == c * c and b > 0 and c > 0 ) : NEW_LINE INDENT print ( a , b , c ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT return NEW_LINE DEDENT
def Display ( arr , Expo_Prime , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( Expo_Prime [ arr [ i ] ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def operations ( N ) : NEW_LINE INDENT x = probability ( N ) NEW_LINE y = math . pow ( 2 , N ) NEW_LINE return round ( x / y , 2 ) NEW_LINE DEDENT
def pairs ( n ) : NEW_LINE INDENT c = [ [ 0 for i in range ( 10 ) ] for i in range ( 10 ) ] NEW_LINE tmp = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i >= tmp * 10 ) : NEW_LINE INDENT tmp *= 10 NEW_LINE DEDENT c [ i // tmp ] [ i % 10 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( 1 , 10 ) : NEW_LINE INDENT ans += c [ i ] [ j ] * c [ j ] [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def gcdFibonacciFreq ( arr , n ) : NEW_LINE INDENT hash1 = set ( ) NEW_LINE createHash ( hash1 , max ( arr ) ) NEW_LINE m = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT gcd = 0 NEW_LINE for it in m . keys ( ) : NEW_LINE INDENT if ( m [ it ] in hash1 ) : NEW_LINE INDENT gcd = math . gcd ( gcd , it ) NEW_LINE DEDENT DEDENT return gcd NEW_LINE DEDENT
def sumBaseB ( a , b , base ) : NEW_LINE INDENT len_a = len ( a ) NEW_LINE len_b = len ( b ) NEW_LINE s = "" NEW_LINE sum = "" NEW_LINE diff = abs ( len_a - len_b ) NEW_LINE for i in range ( 1 , diff + 1 ) : NEW_LINE INDENT s += "0" NEW_LINE DEDENT if ( len_a < len_b ) : NEW_LINE INDENT a = s + a NEW_LINE DEDENT else : NEW_LINE INDENT b = s + b NEW_LINE DEDENT carry = 0 NEW_LINE for i in range ( max ( len_a , len_b ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr = carry + ( ord ( a [ i ] ) - ord ( '0' ) ) + ( ord ( b [ i ] ) - ord ( '0' ) ) NEW_LINE carry = curr // base NEW_LINE curr = curr % base NEW_LINE sum = chr ( curr + ord ( '0' ) ) + sum NEW_LINE DEDENT if ( carry > 0 ) : NEW_LINE INDENT sum = chr ( carry + ord ( '0' ) ) + sum NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isPerfectCube ( x ) : NEW_LINE INDENT x = abs ( x ) NEW_LINE return int ( round ( x ** ( 1. / 3 ) ) ) ** 3 == x NEW_LINE DEDENT
def countPairsWithProdK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def genArray ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N - 1 , 1 ) : NEW_LINE INDENT if ( search ( arr , i , arr [ i ] ) == - 1 ) : NEW_LINE INDENT arr [ i + 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT
def getPerfectcubes ( n ) : NEW_LINE INDENT perfectcubes = [ ] NEW_LINE current = 1 NEW_LINE i = 1 NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectcubes . append ( current ) NEW_LINE i += 1 NEW_LINE current = int ( pow ( i , 3 ) ) NEW_LINE DEDENT return perfectcubes NEW_LINE DEDENT
def insertPF ( primeFact , fact ) : NEW_LINE INDENT if ( fact in primeFact ) : NEW_LINE INDENT primeFact [ fact ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT primeFact [ fact ] = 1 NEW_LINE DEDENT return primeFact NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = int ( sqrt ( x ) ) NEW_LINE if ( sr * sr == x ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def canBePerfectCube ( N , K ) : NEW_LINE INDENT if ( isPerfectCube ( N + K ) or isPerfectCube ( N - K ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def summation ( n ) : NEW_LINE INDENT abs_sum = n * ( n + 1 ) // 2 NEW_LINE sign = 1 if ( ( n + 1 ) % 2 == 0 ) else - 1 NEW_LINE result_sum = sign * abs_sum NEW_LINE return result_sum NEW_LINE DEDENT
def findArray ( xorr , n ) : NEW_LINE INDENT arr = [ ] NEW_LINE xor_all = xor_all_elements ( n ) NEW_LINE xor_adjacent = 0 NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT xor_adjacent = xor_adjacent ^ xorr [ i ] NEW_LINE DEDENT last_element = xor_all ^ xor_adjacent NEW_LINE arr . append ( last_element ) NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT last_element = xorr [ i ] ^ last_element NEW_LINE arr . append ( last_element ) NEW_LINE DEDENT return arr NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i ) NEW_LINE DEDENT DEDENT
def calNum ( year ) : NEW_LINE INDENT return ( year // 4 ) - ( year // 100 ) + ( year // 400 ) NEW_LINE DEDENT
def maxValue ( n ) : NEW_LINE INDENT return n NEW_LINE DEDENT
def findSum ( arr , n ) : NEW_LINE INDENT sieve ( MAX ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = min_prime [ arr [ i ] ] + max_prime [ arr [ i ] ] NEW_LINE print ( sum , end = " " ) NEW_LINE DEDENT DEDENT
def squareRoot ( n , l ) : NEW_LINE INDENT x = n NEW_LINE count = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT count += 1 NEW_LINE root = 0.5 * ( x + ( n / x ) ) NEW_LINE if ( abs ( root - x ) < l ) : NEW_LINE INDENT break NEW_LINE DEDENT x = root NEW_LINE DEDENT return root NEW_LINE DEDENT
def countNumber ( N , S ) : NEW_LINE INDENT countElements = 0 NEW_LINE currSum = 0 NEW_LINE while ( currSum <= S ) : NEW_LINE INDENT currSum += N NEW_LINE N = N - 1 NEW_LINE countElements = countElements + 1 NEW_LINE DEDENT return countElements NEW_LINE DEDENT
def countDistinct ( n ) : NEW_LINE INDENT arr = [ 0 ] * 10 NEW_LINE count = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = int ( n % 10 ) NEW_LINE arr [ r ] = 1 NEW_LINE n //= 10 NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def lcm ( a , b ) : NEW_LINE INDENT return ( a // __gcd ( a , b ) * b ) NEW_LINE DEDENT
def checkZeroArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maximum = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT if ( sum % 2 == 0 and maximum <= sum // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT start = int ( math . pow ( 10 , n - 1 ) ) NEW_LINE end = int ( math . pow ( 10 , n ) ) - 1 NEW_LINE sum = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT s = str ( i ) NEW_LINE if ( isPalindrome ( s ) ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def findMinDel ( arr , n ) : NEW_LINE INDENT min_num = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT min_num = min ( arr [ i ] , min_num ) NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_num ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return n - cnt NEW_LINE DEDENT
def isPossible ( x , y ) : NEW_LINE INDENT if ( ( x - y ) == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def numSeq ( n ) : NEW_LINE INDENT return ( pow ( 3 , n ) + 3 * pow ( - 1 , n ) ) // 4 NEW_LINE DEDENT
def digitDividesK ( num , k ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT d = num % 10 NEW_LINE if ( d != 0 and k % d == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT num = num // 10 NEW_LINE DEDENT return False NEW_LINE DEDENT
def xorK ( n , k ) : NEW_LINE INDENT res = n NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT res = ( res ^ n ) NEW_LINE DEDENT return n NEW_LINE DEDENT
def distinctDigits ( x ) : NEW_LINE INDENT present = [ False for i in range ( MAX ) ] NEW_LINE while ( x > 0 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE if ( present [ digit ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT present [ digit ] = True NEW_LINE x = x // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isPossible ( arr , n , p ) : NEW_LINE INDENT gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( gcd , arr [ i ] ) NEW_LINE DEDENT if ( p % gcd == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def cntCakes ( n , m ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) ) // 2 NEW_LINE quo , rem = m // sum , m % sum NEW_LINE ans = m - quo * sum NEW_LINE x = int ( ( - 1 + ( 8 * rem + 1 ) ** 0.5 ) / 2 ) NEW_LINE ans = ans - x * ( x + 1 ) // 2 NEW_LINE return ans NEW_LINE DEDENT
def factMod ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact *= ( i % MOD ) NEW_LINE fact %= MOD NEW_LINE DEDENT return fact NEW_LINE DEDENT
def isEulerPseudoprime ( N , A ) : NEW_LINE INDENT if ( A <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N % 2 == 0 or not isComposite ( N ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( gcd ( A , N ) != 1 ) : NEW_LINE INDENT return false NEW_LINE DEDENT mod = Power ( A , ( N - 1 ) // 2 , N ) NEW_LINE if ( mod != 1 and mod != N - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def minDifference ( L , R ) : NEW_LINE INDENT fst = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT fst = i NEW_LINE break NEW_LINE DEDENT DEDENT snd = 0 NEW_LINE for i in range ( fst + 1 , R + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT snd = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( snd == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT diff = snd - fst NEW_LINE left = snd + 1 NEW_LINE right = R NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT if ( i - snd <= diff ) : NEW_LINE INDENT fst = snd NEW_LINE snd = i NEW_LINE diff = snd - fst NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT
def no_of_ways ( a , n ) : NEW_LINE INDENT count_0 = 0 NEW_LINE count_1 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT DEDENT if ( count_1 % 2 == 0 ) : NEW_LINE INDENT return count_0 NEW_LINE DEDENT else : NEW_LINE INDENT return count_1 NEW_LINE DEDENT DEDENT
def longest_gap ( N ) : NEW_LINE INDENT distance = 0 NEW_LINE count = 0 NEW_LINE first_1 = - 1 NEW_LINE last_1 = - 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE r = N & 1 NEW_LINE if ( r == 1 ) : NEW_LINE INDENT if first_1 == - 1 : NEW_LINE INDENT first_1 = count NEW_LINE DEDENT else : NEW_LINE INDENT first_1 = first_1 NEW_LINE DEDENT last_1 = count NEW_LINE DEDENT N = N // 2 NEW_LINE DEDENT if ( last_1 <= first_1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT distance = last_1 - first_1 - 1 NEW_LINE return distance NEW_LINE DEDENT DEDENT
def isPossible ( n ) : NEW_LINE INDENT cnt = bin ( n ) . count ( '1' ) NEW_LINE if ( cnt == TOTAL_BITS // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def total_ways ( N , X ) : NEW_LINE INDENT return ( nCr ( N - 1 , X - 1 ) + nCr ( N - 1 , X ) ) NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE k = ( n ) ** ( .5 ) NEW_LINE for i in range ( 1 , floor ( k ) + 1 ) : NEW_LINE INDENT summ += floor ( n / i ) NEW_LINE DEDENT summ *= 2 NEW_LINE summ -= pow ( floor ( k ) , 2 ) NEW_LINE return summ NEW_LINE DEDENT
def getCount ( l , r , p ) : NEW_LINE INDENT cnt = 0 NEW_LINE val = p NEW_LINE while ( True ) : NEW_LINE INDENT a = r // val NEW_LINE b = ( l - 1 ) // val NEW_LINE val *= p NEW_LINE if ( a - b ) : NEW_LINE INDENT cnt += ( a - b ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return int ( cnt ) NEW_LINE DEDENT
def heapify ( arr , n , i ) : NEW_LINE INDENT smallest = i NEW_LINE l = 2 * i + 1 NEW_LINE r = 2 * i + 2 NEW_LINE if l < n and arr [ l ] < arr [ smallest ] : NEW_LINE INDENT smallest = l NEW_LINE DEDENT if r < n and arr [ r ] < arr [ smallest ] : NEW_LINE INDENT smallest = r NEW_LINE DEDENT if smallest != i : NEW_LINE INDENT ( arr [ i ] , arr [ smallest ] ) = ( arr [ smallest ] , arr [ i ] ) NEW_LINE heapify ( arr , n , smallest ) NEW_LINE DEDENT DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( math . sqrt ( n ) + 1 ) , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def nextPrime ( N ) : NEW_LINE INDENT if ( N <= 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT prime = N NEW_LINE found = False NEW_LINE while ( not found ) : NEW_LINE INDENT prime = prime + 1 NEW_LINE if ( isPrime ( prime ) == True ) : NEW_LINE INDENT found = True NEW_LINE DEDENT DEDENT return prime NEW_LINE DEDENT
def find_Solution ( x , n ) : NEW_LINE INDENT Sum = x NEW_LINE e = 2 NEW_LINE o = 1 NEW_LINE p = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT p += 2 NEW_LINE Sum += ( o / e ) * ( pow ( x , p ) / p ) NEW_LINE o = o * ( o + 2 ) NEW_LINE e = e * ( e + 2 ) NEW_LINE DEDENT print ( round ( Sum , 10 ) ) NEW_LINE DEDENT
def solveOdd ( n , arr , b ) : NEW_LINE INDENT left = n - 1 NEW_LINE for i in range ( n // 2 + 1 ) : NEW_LINE INDENT b [ i ] = arr [ left ] NEW_LINE left = left - 2 NEW_LINE if ( left < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT right = 1 NEW_LINE for i in range ( n // 2 + 1 , n , 1 ) : NEW_LINE INDENT b [ i ] = arr [ right ] NEW_LINE right = right + 2 NEW_LINE if ( right > n - 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def countSetBits ( n ) : NEW_LINE INDENT n += 1 NEW_LINE powerOf2 = 2 NEW_LINE cnt = n // 2 NEW_LINE while ( powerOf2 <= n ) : NEW_LINE INDENT totalPairs = n // powerOf2 NEW_LINE cnt += ( totalPairs // 2 ) * powerOf2 NEW_LINE if ( totalPairs & 1 ) : NEW_LINE INDENT cnt += ( n % powerOf2 ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 0 NEW_LINE DEDENT powerOf2 <<= 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def nCr ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT answer = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) NEW_LINE answer //= 24 NEW_LINE return answer NEW_LINE DEDENT
def ncr ( n , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans *= ( n - r + i ) NEW_LINE ans //= i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT
def findReachable ( arr , D , A , B , n ) : NEW_LINE INDENT gcd_AB = GCD ( A , B ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] - D ) % gcd_AB == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def getSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 and arr [ i ] == sumOfFactors ( arr [ i ] ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def isPossible ( k ) : NEW_LINE INDENT if ( not exists_zero ) : NEW_LINE INDENT if ( k >= cnt_neg and ( k - cnt_neg ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( k >= cnt_neg ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT
def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) NEW_LINE DEDENT y = int ( y ) >> 1 NEW_LINE x = ( x * x ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def solve ( L ) : NEW_LINE INDENT n = L / 2 + 1 NEW_LINE ans = power ( n , n - 2 ) NEW_LINE return int ( ans ) NEW_LINE DEDENT
def total_permutations ( freq ) : NEW_LINE INDENT cnt = 0 NEW_LINE denom = 1 NEW_LINE for itr in freq : NEW_LINE INDENT denom *= fact ( freq [ itr ] ) NEW_LINE cnt += freq [ itr ] NEW_LINE DEDENT return fact ( cnt ) // denom NEW_LINE DEDENT
def solveQuery ( L , X ) : NEW_LINE INDENT res = 0 NEW_LINE a = [ 0 for i in range ( MAXN ) ] NEW_LINE b = [ 0 for i in range ( MAXN ) ] NEW_LINE ref = X NEW_LINE size_a = 0 NEW_LINE while ( ref > 0 ) : NEW_LINE INDENT a [ size_a ] = ref % 2 NEW_LINE ref //= 2 NEW_LINE size_a += 1 NEW_LINE DEDENT for i in range ( min ( size_a , L ) ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT b [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( min ( size_a , L ) , L ) : NEW_LINE INDENT b [ i ] = 1 NEW_LINE DEDENT b [ L - 1 ] = 1 NEW_LINE temp = 0 NEW_LINE p = 1 NEW_LINE for i in range ( L ) : NEW_LINE INDENT temp += b [ i ] * p NEW_LINE p *= 2 NEW_LINE DEDENT res = temp ^ X NEW_LINE return res NEW_LINE DEDENT
def closetAND ( arr , n , k ) : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT X = arr [ i ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT X &= arr [ j ] NEW_LINE ans = min ( ans , abs ( k - X ) ) NEW_LINE if ( X <= k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countQuadruplets ( l , r , k ) : NEW_LINE INDENT frequency = [ 0 ] * ( r + 1 ) NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( l , r + 1 ) : NEW_LINE INDENT frequency [ gcd ( i , j ) ] += 1 NEW_LINE DEDENT DEDENT answer = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( l , r + 1 ) : NEW_LINE INDENT if ( gcd ( i , j ) == k ) : NEW_LINE INDENT answer += ( frequency [ i ] * frequency [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT
def maxBitElement ( arr , n ) : NEW_LINE INDENT num = 0 NEW_LINE max = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = bin ( arr [ i ] ) . count ( '1' ) NEW_LINE if ( cnt > max ) : NEW_LINE INDENT max = cnt NEW_LINE num = arr [ i ] NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT
def Add_Edge ( u , v ) : NEW_LINE INDENT gr [ u ] . append ( v ) NEW_LINE gr [ v ] . append ( u ) NEW_LINE DEDENT
def factorial ( n , p ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = ( res * i ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def getValueOfF ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT cnt = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n /= 2 NEW_LINE DEDENT return 2 * cnt NEW_LINE DEDENT
def printNumbers ( a , n , x ) : NEW_LINE INDENT flag = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE g = gcd ( num , x ) NEW_LINE while ( g != 1 ) : NEW_LINE INDENT num //= g NEW_LINE g = gcd ( num , x ) NEW_LINE DEDENT if ( num == 1 ) : NEW_LINE INDENT flag = True NEW_LINE print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if ( not flag ) : NEW_LINE INDENT print ( "There are no such numbers" ) NEW_LINE DEDENT DEDENT
def line ( x0 , y0 ) : NEW_LINE INDENT c = 2 * y0 * x0 NEW_LINE print ( y0 , "x" , "+" , x0 , "y=" , c ) NEW_LINE DEDENT
def isDudeney ( n ) : NEW_LINE INDENT cube_rt = int ( round ( ( pow ( n , 1.0 / 3.0 ) ) ) ) NEW_LINE if cube_rt * cube_rt * cube_rt != n : NEW_LINE INDENT return False NEW_LINE DEDENT dig_sum = 0 NEW_LINE temp = n NEW_LINE while temp > 0 : NEW_LINE INDENT rem = temp % 10 NEW_LINE dig_sum += rem NEW_LINE temp //= 10 NEW_LINE DEDENT if cube_rt != dig_sum : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def Positive_Divisors ( ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , int ( sqrt ( i ) ) + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT pre [ i ] = ans NEW_LINE DEDENT DEDENT
def oddDays ( N ) : NEW_LINE INDENT hund1 = N // 100 NEW_LINE hund4 = N // 400 NEW_LINE leap = N >> 2 NEW_LINE ordd = N - leap NEW_LINE if ( hund1 ) : NEW_LINE INDENT ordd += hund1 NEW_LINE leap -= hund1 NEW_LINE DEDENT if ( hund4 ) : NEW_LINE INDENT ordd -= hund4 NEW_LINE leap += hund4 NEW_LINE DEDENT days = ordd + leap * 2 NEW_LINE odd = days % 7 NEW_LINE return odd NEW_LINE DEDENT
def ellipsearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 3.14 * r * r ) / 4 NEW_LINE return a NEW_LINE DEDENT
def recamanGenerator ( arr , n ) : NEW_LINE INDENT arr [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT temp = arr [ i - 1 ] - i NEW_LINE j = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( ( arr [ j ] == temp ) or temp < 0 ) : NEW_LINE INDENT temp = arr [ i - 1 ] + i NEW_LINE break NEW_LINE DEDENT DEDENT arr [ i ] = temp NEW_LINE DEDENT DEDENT
def power ( a , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , n // 2 ) NEW_LINE p = p * p NEW_LINE if n & 1 : NEW_LINE INDENT p = p * a NEW_LINE DEDENT return p NEW_LINE DEDENT
def findPairCount ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE rem = [ 0 ] * K NEW_LINE rem [ 0 ] = N // K NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT rem [ i ] = ( N - i ) // K + 1 NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 NEW_LINE for i in range ( 1 , K // 2 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] NEW_LINE DEDENT count += ( rem [ K // 2 ] * ( rem [ K // 2 ] - 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 NEW_LINE for i in rage ( 1 , K // 2 + 1 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def doesContainB ( a , b , c ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( b - a ) * c > 0 and ( b - a ) % c == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT for j in range ( i * 2 , N , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def lastDigit ( a , b ) : NEW_LINE INDENT lastDig = ( ( int ( a [ len ( a ) - 1 ] ) - int ( '0' ) ) * ( int ( b [ len ( b ) - 1 ] ) - int ( '0' ) ) ) NEW_LINE print ( lastDig % 10 ) NEW_LINE DEDENT
def printPalindrome ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( "Smallest Palindrome: 0" ) NEW_LINE print ( "Largest Palindrome: 9" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Smallest Palindrome:" , int ( pow ( 10 , n - 1 ) ) + 1 ) NEW_LINE print ( "Largest Palindrome:" , int ( pow ( 10 , n ) ) - 1 ) NEW_LINE DEDENT DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a // b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def nDigitPerfectCubes ( n ) : NEW_LINE INDENT print ( pow ( ceil ( ( pow ( 10 , ( n - 1 ) ) ) ** ( 1 / 3 ) ) , 3 ) , end = " " ) NEW_LINE print ( pow ( ceil ( ( pow ( 10 , ( n ) ) ) ** ( 1 / 3 ) ) - 1 , 3 ) ) NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT ans = pow ( n % MOD , 2 ) NEW_LINE return ( ans % MOD ) NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 9 * pow ( 10 , n // 2 - 1 ) ) NEW_LINE DEDENT
def KthMinValAfterMconcatenate ( A , N , M , K ) : NEW_LINE INDENT V = [ ] NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT V . append ( A [ j ] ) NEW_LINE DEDENT DEDENT V . sort ( ) NEW_LINE return V [ K - 1 ] NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT if n == 1 or n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorial ( n - 1 ) * n NEW_LINE DEDENT DEDENT
def gcdOfFactorial ( arr , n ) : NEW_LINE INDENT minm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if minm > arr [ i ] : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = minm NEW_LINE DEDENT DEDENT return factorial ( minm ) NEW_LINE DEDENT
def findMinimum ( n , m ) : NEW_LINE INDENT mini , i = m , 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sec = n // i NEW_LINE if math . gcd ( m , i ) > 1 : NEW_LINE INDENT return i NEW_LINE DEDENT elif math . gcd ( sec , m ) > 1 : NEW_LINE INDENT mini = min ( sec , mini ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if mini == m : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return mini NEW_LINE DEDENT DEDENT
def getProbability ( a , b , c , d ) : NEW_LINE INDENT p = a / b NEW_LINE q = c / d NEW_LINE ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) NEW_LINE return round ( ans , 5 ) NEW_LINE DEDENT
def findMinSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] * ( n - i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getPosition ( n , m ) : NEW_LINE INDENT if ( m > ( n // 2 ) ) : NEW_LINE INDENT return ( m - ( n // 2 ) ) NEW_LINE DEDENT return ( m + ( n // 2 ) ) NEW_LINE DEDENT
def matrixOrValueOne ( arr ) : NEW_LINE INDENT p_arr = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE findPrefixCount ( p_arr , arr ) NEW_LINE count_zero_submatrices = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE q = [ ] NEW_LINE to_sum = 0 NEW_LINE while i >= 0 : NEW_LINE INDENT c = 0 NEW_LINE while ( len ( q ) != 0 and q [ - 1 ] [ 0 ] > p_arr [ i ] [ j ] ) : NEW_LINE INDENT to_sum -= ( ( q [ - 1 ] [ 1 ] + 1 ) * ( q [ - 1 ] [ 0 ] - p_arr [ i ] [ j ] ) ) NEW_LINE c += q . pop ( ) [ 1 ] + 1 NEW_LINE DEDENT to_sum += p_arr [ i ] [ j ] NEW_LINE count_zero_submatrices += to_sum NEW_LINE q . append ( ( p_arr [ i ] [ j ] , c ) ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT return ( ( n * ( n + 1 ) * n * ( n + 1 ) ) // 4 - count_zero_submatrices ) NEW_LINE DEDENT
def count ( N , K , R ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % K == R ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def isSpiltPossible ( n , a ) : NEW_LINE INDENT Sum = 0 NEW_LINE c1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += a [ i ] NEW_LINE if ( a [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT if ( Sum % 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( Sum // 2 ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( c1 > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def isSunnyNum ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( n + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def Cycles ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE result = N - 1 NEW_LINE i = result NEW_LINE while ( i > 0 ) : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact // 2 NEW_LINE DEDENT
def getMaxNum ( a , b , c ) : NEW_LINE INDENT if ( b % c == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT x = ( ( b // c ) * c ) NEW_LINE if ( x >= a and x <= b ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def findAndSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT count_on = 0 NEW_LINE l = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT if ( count_on ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_on = 1 NEW_LINE l += 1 NEW_LINE DEDENT DEDENT elif ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) // 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT DEDENT if ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) // 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def calcNodes ( N , I ) : NEW_LINE INDENT result = 0 NEW_LINE result = I * ( N - 1 ) + 1 NEW_LINE return result NEW_LINE DEDENT
def findPrimeFactors ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT if ( primeFactors [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT primeFactors [ j ] = primeFactors [ j // i ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT primeFactors [ i ] += primeFactors [ i - 1 ] NEW_LINE DEDENT DEDENT
def mixtureConcentration ( n , p ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += p [ i ] NEW_LINE DEDENT res /= n NEW_LINE return res NEW_LINE DEDENT
def check ( num , a , b ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT rem = num % 10 NEW_LINE num = int ( num / 10 ) NEW_LINE if ( rem != a and rem != b ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def max_gcd ( n , p ) : NEW_LINE INDENT count = 0 NEW_LINE gcd = 1 NEW_LINE while ( p % 2 == 0 ) : NEW_LINE INDENT p >>= 1 NEW_LINE count = count + 1 NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT gcd = gcd * pow ( 2 , count // n ) NEW_LINE DEDENT for i in range ( 3 , ( int ) ( math . sqrt ( p ) ) , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( p % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // i NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT gcd = gcd * pow ( i , count // n ) NEW_LINE DEDENT DEDENT if ( p > 2 ) : NEW_LINE INDENT gcd = gcd * pow ( p , 1 // n ) NEW_LINE DEDENT return gcd NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return f [ n ] NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = ( n + 1 ) // 2 if ( n & 1 ) else n // 2 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT
def printSequence ( n ) : NEW_LINE INDENT Sieve ( ) NEW_LINE v = [ ] NEW_LINE u = [ ] NEW_LINE for i in range ( 13 , MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT if ( n == 3 ) : NEW_LINE INDENT print ( 6 , 10 , 15 ) NEW_LINE return NEW_LINE DEDENT k = 0 NEW_LINE for k in range ( n - 2 ) : NEW_LINE INDENT if ( k % 3 == 0 ) : NEW_LINE INDENT u . append ( v [ k ] * 6 ) NEW_LINE DEDENT elif ( k % 3 == 1 ) : NEW_LINE INDENT u . append ( v [ k ] * 15 ) NEW_LINE DEDENT else : NEW_LINE INDENT u . append ( v [ k ] * 10 ) NEW_LINE DEDENT DEDENT u . append ( v [ k ] * 7 ) NEW_LINE u . append ( 7 * 11 ) NEW_LINE u [ 0 ] = u [ 0 ] * 11 NEW_LINE print ( * u ) NEW_LINE DEDENT
def checkSub ( sub , s ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( sub [ j ] == s [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT if j == int ( len ( sub ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def minPerfectCube ( arr , n ) : NEW_LINE INDENT lcm = lcmOfArray ( arr , n ) NEW_LINE minPerfectCube = lcm NEW_LINE cnt = 0 NEW_LINE while ( lcm > 1 and lcm % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= 2 NEW_LINE DEDENT if ( cnt % 3 == 2 ) : NEW_LINE INDENT minPerfectCube *= 2 NEW_LINE DEDENT elif ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube *= 4 NEW_LINE DEDENT i = 3 NEW_LINE while ( lcm > 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( lcm % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= i NEW_LINE DEDENT if ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube *= i * i NEW_LINE DEDENT elif ( cnt % 3 == 2 ) : NEW_LINE INDENT minPerfectCube *= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return minPerfectCube NEW_LINE DEDENT
def powerfulIntegers ( x , y , bound ) : NEW_LINE INDENT s = set ( ) NEW_LINE powersOfY = [ ] NEW_LINE powersOfY . append ( 1 ) NEW_LINE i = y NEW_LINE while i < bound and y != 1 : NEW_LINE INDENT powersOfY . append ( i ) NEW_LINE i *= y NEW_LINE DEDENT i = 0 NEW_LINE while ( True ) : NEW_LINE INDENT xPowI = pow ( x , i ) NEW_LINE for j in powersOfY : NEW_LINE INDENT num = xPowI + j NEW_LINE if ( num <= bound ) : NEW_LINE INDENT s . add ( num ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( xPowI >= bound or x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for itr in s : NEW_LINE INDENT print ( itr , end = " " ) NEW_LINE DEDENT DEDENT
def find_probability ( p , q , r , s ) : NEW_LINE INDENT t = ( 1 - p / q ) * ( 1 - r / s ) NEW_LINE ans = ( p / q ) / ( 1 - t ) NEW_LINE return round ( ans , 9 ) NEW_LINE DEDENT
def distinctDigitSum ( n ) : NEW_LINE INDENT used = [ False ] * 10 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( not used [ digit ] ) : NEW_LINE INDENT used [ digit ] = True NEW_LINE sum += digit NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getDifference ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( isPrime ( N ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT aboveN = - 1 NEW_LINE belowN = - 1 NEW_LINE n1 = N + 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPrime ( n1 ) ) : NEW_LINE INDENT aboveN = n1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT n1 += 1 NEW_LINE DEDENT DEDENT n1 = N - 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPrime ( n1 ) ) : NEW_LINE INDENT belowN = n1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT n1 -= 1 NEW_LINE DEDENT DEDENT diff1 = aboveN - N NEW_LINE diff2 = N - belowN NEW_LINE return min ( diff1 , diff2 ) NEW_LINE DEDENT
def maxPrimeFactors ( n ) : NEW_LINE INDENT num = n NEW_LINE maxPrime = - 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT maxPrime = 2 NEW_LINE n = n / 2 NEW_LINE DEDENT p = int ( sqrt ( n ) + 1 ) NEW_LINE for i in range ( 3 , p , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT maxPrime = i NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT maxPrime = n NEW_LINE DEDENT sum = maxPrime + num NEW_LINE return sum NEW_LINE DEDENT
def sumOfDigits ( n ) : NEW_LINE INDENT res = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT res += n % 10 NEW_LINE n /= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countIntervals ( arr , V , N ) : NEW_LINE INDENT minimum = float ( "inf" ) NEW_LINE maximum = 0 NEW_LINE freq = [ 0 ] * ( MAX_VAL ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT li = arr [ i ] [ 0 ] NEW_LINE freq [ li ] = freq [ li ] + 1 NEW_LINE ri = arr [ i ] [ 1 ] NEW_LINE freq [ ri + 1 ] = freq [ ri + 1 ] - 1 NEW_LINE if li < minimum : NEW_LINE INDENT minimum = li NEW_LINE DEDENT if ri > maximum : NEW_LINE INDENT maximum = ri NEW_LINE DEDENT DEDENT for i in range ( minimum , maximum + 1 ) : NEW_LINE INDENT freq [ i ] = freq [ i ] + freq [ i - 1 ] NEW_LINE DEDENT return freq [ V ] NEW_LINE DEDENT
def sumEven ( l , r ) : NEW_LINE INDENT return ( sumNatural ( int ( r / 2 ) ) - sumNatural ( int ( ( l - 1 ) / 2 ) ) ) NEW_LINE DEDENT
def isPalindrome ( num ) : NEW_LINE INDENT reverse_num = 0 NEW_LINE temp = num NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT remainder = temp % 10 NEW_LINE reverse_num = reverse_num * 10 + remainder NEW_LINE temp = int ( temp / 10 ) NEW_LINE DEDENT if ( reverse_num == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y * x ) % ( y + x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def getResult ( n ) : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def sumAP ( n , d ) : NEW_LINE INDENT n = int ( n / d ) NEW_LINE return ( n ) * ( 1 + n ) * ( d / 2 ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def minimum ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT n = n / i NEW_LINE DEDENT product = product * i NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT product = product * n NEW_LINE DEDENT return product NEW_LINE DEDENT
def productDivisible ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE position = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if position % 2 == 0 : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT n = n / 10 NEW_LINE position += 1 NEW_LINE DEDENT if product % k == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def sumAP ( n , d ) : NEW_LINE INDENT n = int ( n / d ) NEW_LINE return ( n ) * ( 1 + n ) * ( d / 2 ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT
def isTriangleExists ( a , b , c ) : NEW_LINE INDENT if ( a != 0 and b != 0 and c != 0 and ( a + b + c ) == 180 ) : NEW_LINE INDENT if ( ( a + b ) >= c or ( b + c ) >= a or ( a + c ) >= b ) : NEW_LINE INDENT return "YES" NEW_LINE DEDENT else : NEW_LINE INDENT return "NO" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return "NO" NEW_LINE DEDENT DEDENT
def fact ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT
def ways ( m , w , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( m >= k ) : NEW_LINE INDENT ans += ncr ( m , k ) * ncr ( w , n - k ) NEW_LINE k += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def square ( n ) : NEW_LINE INDENT return n * n NEW_LINE DEDENT
def sum ( N ) : NEW_LINE INDENT S1 = ( ( N // 2 ) ) * ( 2 * 2 + ( N // 2 - 1 ) * 2 ) // 2 NEW_LINE S2 = ( ( N // 7 ) ) * ( 2 * 7 + ( N // 7 - 1 ) * 7 ) // 2 NEW_LINE S3 = ( ( N // 14 ) ) * ( 2 * 14 + ( N // 14 - 1 ) * 14 ) // 2 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT
def largestPrimeFactor ( n ) : NEW_LINE INDENT max = - 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT max = 2 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT max = i NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT max = n NEW_LINE DEDENT return max NEW_LINE DEDENT
def isStrongNumber ( n ) : NEW_LINE INDENT count = { i : 0 for i in range ( n ) } NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n = n // 2 NEW_LINE count [ 2 ] += 1 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT n = n // i NEW_LINE count [ i ] += 1 NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT count [ n ] += 1 NEW_LINE DEDENT flag = 0 NEW_LINE for key , value in count . items ( ) : NEW_LINE INDENT if value == 1 : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def isChenPrime ( n ) : NEW_LINE INDENT if ( isPrime ( n ) and ( isSemiPrime ( n + 2 ) or isPrime ( n + 2 ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def Divisible ( str , n ) : NEW_LINE INDENT if ( ( SumOfDigits ( str , n ) % 3 == 0 and str [ n - 1 ] == '0' ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def NumberOfRectangles ( n , m ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return ( n / 2 ) * m NEW_LINE DEDENT elif ( m % 2 == 0 ) : NEW_LINE INDENT return ( m // 2 ) * n NEW_LINE DEDENT return ( n * m - 1 ) // 2 NEW_LINE DEDENT
def isPrime ( p ) : NEW_LINE INDENT if ( p == 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( fact ( p >> 1 ) % p ) NEW_LINE DEDENT
def findNumUtil ( res , a , aCount , b , bCount , n ) : NEW_LINE INDENT if ( res > 1e11 ) : NEW_LINE INDENT return 1e11 NEW_LINE DEDENT if ( aCount == bCount and res >= n ) : NEW_LINE INDENT return res NEW_LINE DEDENT return min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) ) NEW_LINE DEDENT
def isSumDivides ( N ) : NEW_LINE INDENT temp = N NEW_LINE sum = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE DEDENT if ( N % sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def GoodNumber ( n ) : NEW_LINE INDENT v = PrimeFactors ( n ) NEW_LINE ans = 1 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT ans *= v [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def checkSpecialPrime ( sieve , num ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT if ( not sieve [ num ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT num //= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def nthHarmonic ( N ) : NEW_LINE INDENT harmonic = 1.00 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT harmonic += 1 / i NEW_LINE DEDENT return harmonic NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + n - 2 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 4 * n - 2 NEW_LINE DEDENT
def printAngles ( a , b , c ) : NEW_LINE INDENT x = a NEW_LINE y = b NEW_LINE z = c NEW_LINE A = findAnglesA ( x , y , z ) NEW_LINE B = findAnglesB ( x , y , z ) NEW_LINE print ( "Angles are A = " , A , ", B = " , B , ", C = " , "90 " ) NEW_LINE DEDENT
def Bits ( kilobytes ) : NEW_LINE INDENT Bits = kilobytes * 8192 NEW_LINE return Bits NEW_LINE DEDENT
def binomial ( ) : NEW_LINE INDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , ceil ( sqrt ( n ) ) , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def closest ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( ans * 10 + 9 <= x ) : NEW_LINE INDENT ans = ans * 10 + 9 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT return ( N * ( ( N // 2 ) + ( ( N % 2 ) * 2 ) + N ) ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) ** 2 NEW_LINE DEDENT
def digSum ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n % 9 == 0 : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return n % 9 NEW_LINE DEDENT DEDENT
def totEdge ( n ) : NEW_LINE INDENT result = ( n * ( n - 1 ) ) // 2 NEW_LINE return result NEW_LINE DEDENT
def findFactors ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( ( n / i ) == i ) : NEW_LINE INDENT factors . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT factors . append ( n / i ) NEW_LINE factors . append ( i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def checkPairs ( l , r ) : NEW_LINE INDENT if ( l - r ) % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def calTime ( arr , n ) : NEW_LINE INDENT work = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT work += 1 / arr [ i ] NEW_LINE DEDENT return 1 / work NEW_LINE DEDENT
def calculate_ways ( m , n ) : NEW_LINE INDENT if m < n : NEW_LINE INDENT return 0 NEW_LINE DEDENT ways = binomial_coefficient ( n + m - 1 , n - 1 ) NEW_LINE return int ( ways ) NEW_LINE DEDENT
def powerLL ( x , n ) : NEW_LINE INDENT result = 1 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT result = result * x % MOD NEW_LINE DEDENT n = int ( n / 2 ) NEW_LINE x = x * x % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT
def powerStrings ( sa , sb ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( len ( sa ) ) : NEW_LINE INDENT a = ( a * 10 + ( ord ( sa [ i ] ) - ord ( '0' ) ) ) % MOD NEW_LINE DEDENT for i in range ( len ( sb ) ) : NEW_LINE INDENT b = ( b * 10 + ( ord ( sb [ i ] ) - ord ( '0' ) ) ) % ( MOD - 1 ) NEW_LINE DEDENT return powerLL ( a , b ) NEW_LINE DEDENT
def findNumbers ( n , w ) : NEW_LINE INDENT x = 0 NEW_LINE sum = 0 NEW_LINE if ( w >= 0 and w <= 8 ) : NEW_LINE INDENT x = 9 - w NEW_LINE DEDENT elif ( w >= - 9 and w <= - 1 ) : NEW_LINE INDENT x = 10 + w NEW_LINE DEDENT sum = pow ( 10 , n - 2 ) NEW_LINE sum = ( x * sum ) NEW_LINE return sum NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT n = n - 1 NEW_LINE ans = n * n NEW_LINE if ( ans >= mod ) : NEW_LINE INDENT ans %= mod NEW_LINE DEDENT ans += n + 2 NEW_LINE if ( ans >= mod ) : NEW_LINE INDENT ans %= mod NEW_LINE DEDENT ans = ( pow ( 2 , n , mod ) % mod * ans % mod ) % mod NEW_LINE ans = ( ans - 1 + mod ) % mod NEW_LINE return ans NEW_LINE DEDENT
def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N - 1 ) : NEW_LINE INDENT if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair = oddPair + 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT
def numberOfDigits ( x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x //= 10 NEW_LINE i += 1 NEW_LINE DEDENT return i NEW_LINE DEDENT
def twoEggDrop ( k ) : NEW_LINE INDENT return mt . ceil ( ( - 1.0 + mt . sqrt ( 1 + 8 * k ) ) / 2 ) NEW_LINE DEDENT
def findArea ( a , b ) : NEW_LINE INDENT Area = 3.142 * a * b NEW_LINE print ( "Area:" , round ( Area , 2 ) ) NEW_LINE DEDENT
def calculate ( x , k , m ) : NEW_LINE INDENT result = x NEW_LINE k = k - 1 NEW_LINE while ( k ) : NEW_LINE INDENT result = math . pow ( result , x ) NEW_LINE if ( result > m ) : NEW_LINE INDENT result = result % m NEW_LINE DEDENT k = k - 1 NEW_LINE DEDENT return int ( result ) NEW_LINE DEDENT
def largestNum ( a , b ) : NEW_LINE INDENT return a * ( bool ) ( a // b ) + b * ( bool ) ( b // a ) NEW_LINE DEDENT
def minimumSquareFreeDivisors ( N ) : NEW_LINE INDENT prime = [ ] NEW_LINE primes = [ ] NEW_LINE primes = SieveOfEratosthenes ( prime ) NEW_LINE max_count = 0 NEW_LINE i = 0 NEW_LINE while ( len ( primes ) and primes [ i ] * primes [ i ] <= N ) : NEW_LINE INDENT if ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp += 1 NEW_LINE N /= primes [ i ] NEW_LINE DEDENT max_count = max ( max_count , tmp ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT return max_count NEW_LINE DEDENT
def smar_wln ( n ) : NEW_LINE INDENT arr = primes ( n ) NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT print ( arr [ j ] , end = '' ) NEW_LINE DEDENT print ( end = ' ' ) NEW_LINE DEDENT DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 NEW_LINE DEDENT
def mulmod ( a , b , mod ) : NEW_LINE INDENT a = a % mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b //= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT
def findProduct ( N ) : NEW_LINE INDENT product = 1 NEW_LINE fact = 1 NEW_LINE MOD = 1e9 + 7 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = mulmod ( fact , i , MOD ) NEW_LINE product = mulmod ( product , fact , MOD ) NEW_LINE if not product : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return int ( product ) NEW_LINE DEDENT
def endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) : NEW_LINE INDENT print ( "x2 =" , ( 2 * c1 - x1 ) , end = " " ) NEW_LINE print ( "y2 =" , ( 2 * c2 - y1 ) ) NEW_LINE DEDENT
def divSum ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sum = ( sum + i + math . floor ( n / i ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def centeredTetrahedralNumber ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 3 ) // 3 NEW_LINE DEDENT
def bit ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x /= 2 NEW_LINE ans = ans + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def bs ( n ) : NEW_LINE INDENT l = 1 NEW_LINE r = int ( math . sqrt ( n ) ) NEW_LINE while ( l < r ) : NEW_LINE INDENT m = int ( ( l + r ) / 2 ) NEW_LINE if ( check ( m , n ) ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( check ( l , n ) == False ) : NEW_LINE INDENT return math . floor ( l + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return math . floor ( l ) NEW_LINE DEDENT DEDENT
def find_Square_369 ( num ) : NEW_LINE INDENT if ( num [ 0 ] == '3' ) : NEW_LINE INDENT a = '1' NEW_LINE b = '0' NEW_LINE c = '8' NEW_LINE d = '9' NEW_LINE DEDENT elif ( num [ 0 ] == '6' ) : NEW_LINE INDENT a = '4' NEW_LINE b = '3' NEW_LINE c = '5' NEW_LINE d = '6' NEW_LINE DEDENT else : NEW_LINE INDENT a = '9' NEW_LINE b = '8' NEW_LINE c = '0' NEW_LINE d = '1' NEW_LINE DEDENT result = "" NEW_LINE size = len ( num ) NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT result += a NEW_LINE DEDENT result += b NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT result += c NEW_LINE DEDENT result += d NEW_LINE return result NEW_LINE DEDENT
def everMeet ( x1 , x2 , v1 , v2 ) : NEW_LINE INDENT if ( x1 < x2 and v1 <= v2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( x1 > x2 and v1 >= v2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( x1 < x2 ) : NEW_LINE INDENT x1 , x2 = x2 , x1 NEW_LINE v1 , v2 = v2 , v1 NEW_LINE DEDENT while ( x1 >= x2 ) : NEW_LINE INDENT if ( x1 == x2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT x1 = x1 + v1 NEW_LINE x2 = x2 + v2 NEW_LINE DEDENT return False NEW_LINE DEDENT
def findpos ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in n : NEW_LINE INDENT if i == '2' : NEW_LINE INDENT pos = pos * 4 + 1 NEW_LINE DEDENT elif i == '3' : NEW_LINE INDENT pos = pos * 4 + 2 NEW_LINE DEDENT elif i == '5' : NEW_LINE INDENT pos = pos * 4 + 3 NEW_LINE DEDENT elif i == '7' : NEW_LINE INDENT pos = pos * 4 + 4 NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT
def isPossibleToZero ( a , n ) : NEW_LINE INDENT num = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = num * 10 + a [ i ] NEW_LINE DEDENT return ( num % 11 == 0 ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def solve ( n , base ) : NEW_LINE INDENT result = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT remainder = n % base NEW_LINE result = result + remainder NEW_LINE n = int ( n / base ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def checkSemiprime ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 2 NEW_LINE while ( cnt < 2 and ( i * i ) <= num ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT num /= i NEW_LINE cnt += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt == 2 NEW_LINE DEDENT
def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False NEW_LINE possibleA = 0 NEW_LINE possibleB = 0 NEW_LINE possibleC = 0 NEW_LINE numbersInRange = ( R - L + 1 ) NEW_LINE if ( numbersInRange < 3 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT elif ( numbersInRange > 3 ) : NEW_LINE INDENT flag = True NEW_LINE if ( ( L % 2 ) > 0 ) : NEW_LINE INDENT L += 1 NEW_LINE DEDENT possibleA = L NEW_LINE possibleB = L + 1 NEW_LINE possibleC = L + 2 NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( L % 2 ) == 0 ) : NEW_LINE INDENT flag = True NEW_LINE possibleA = L NEW_LINE possibleB = L + 1 NEW_LINE possibleC = L + 2 NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT print ( "(" , possibleA , "," , possibleB , "," , possibleC , ") is one such" , "possible triplet between" , L , "and" , R ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No Such Triplet exists between" , L , "and" , R ) NEW_LINE DEDENT DEDENT
def isFullTree ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return True NEW_LINE DEDENT if root . left is None and root . right is None : NEW_LINE INDENT return True NEW_LINE DEDENT if root . left is not None and root . right is not None : NEW_LINE INDENT return ( isFullTree ( root . left ) and isFullTree ( root . right ) ) NEW_LINE DEDENT return False NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT _sum = 0 NEW_LINE n = 1 NEW_LINE while ( _sum < s ) : NEW_LINE INDENT _sum += n * n * n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findKthGoodNo ( n ) : NEW_LINE INDENT lastDig = n % 10 NEW_LINE if ( lastDig >= 0 and lastDig <= 4 ) : NEW_LINE INDENT return n << 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n << 1 ) + 1 NEW_LINE DEDENT DEDENT
def findGreatest ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT arr = sorted ( arr ) NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < i and arr [ j ] <= sqrt ( arr [ i ] ) ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 ) : NEW_LINE INDENT result = arr [ i ] // arr [ j ] NEW_LINE if ( result != arr [ j ] and ( result in m . keys ( ) ) and m [ result ] > 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT elif ( result == arr [ j ] and ( result in m . keys ( ) ) and m [ result ] > 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def LCMOfNeighbourFact ( n ) : NEW_LINE INDENT return factorial ( n + 1 ) NEW_LINE DEDENT
def fortunateNumber ( n ) : NEW_LINE INDENT p = primorial ( n ) NEW_LINE return findNextPrime ( p ) - p NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sm = sm + i * j NEW_LINE DEDENT DEDENT return sm NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT f = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f *= i NEW_LINE DEDENT return f NEW_LINE DEDENT
def findNthNumber ( n , k ) : NEW_LINE INDENT i = k + 1 NEW_LINE count = 1 NEW_LINE while ( count < n ) : NEW_LINE INDENT if ( checkdigit ( i , k ) or ( i % k == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def isPrime ( p ) : NEW_LINE INDENT checkNumber = 2 ** p - 1 NEW_LINE nextval = 4 % checkNumber NEW_LINE for i in range ( 1 , p - 1 ) : NEW_LINE INDENT nextval = ( nextval * nextval - 2 ) % checkNumber NEW_LINE DEDENT if ( nextval == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def multiply ( x , res , res_size ) : NEW_LINE INDENT carry = 0 NEW_LINE for i in range ( res_size ) : NEW_LINE INDENT prod = res [ i ] * x + carry NEW_LINE res [ i ] = prod % 10 NEW_LINE carry = prod // 10 NEW_LINE DEDENT while ( carry ) : NEW_LINE INDENT res [ res_size ] = carry % 10 NEW_LINE carry = carry // 10 NEW_LINE res_size += 1 NEW_LINE DEDENT return res_size NEW_LINE DEDENT
def power ( x , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE return NEW_LINE DEDENT res = [ 0 for i in range ( MAX ) ] NEW_LINE res_size = 0 NEW_LINE temp = x NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT res [ res_size ] = temp % 10 NEW_LINE res_size += 1 NEW_LINE temp = temp // 10 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res_size = multiply ( x , res , res_size ) NEW_LINE DEDENT print ( x , "^" , n , " = " , end = "" ) NEW_LINE for i in range ( res_size - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( res [ i ] , end = "" ) NEW_LINE DEDENT DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ) NEW_LINE DEDENT
def seriesFunc ( n ) : NEW_LINE INDENT sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE sumNatural = ( n * ( n + 1 ) / 2 ) NEW_LINE return ( sumSquare + sumNatural + 1 ) NEW_LINE DEDENT
def day_of_the_week ( y , m , d ) : NEW_LINE INDENT t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] NEW_LINE if ( m < 3 ) : NEW_LINE INDENT y = y - 1 NEW_LINE DEDENT return ( y + y // 4 - y // 100 + y // 400 + t [ m - 1 ] + d ) % 7 NEW_LINE DEDENT
def subsetCount ( arr , n ) : NEW_LINE INDENT return 1 << n NEW_LINE DEDENT
def isSquareFree ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT n = n / i NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def avg_of_even_num ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + 2 * i NEW_LINE DEDENT return sum / n NEW_LINE DEDENT
def reachTarget ( target ) : NEW_LINE INDENT target = abs ( target ) NEW_LINE sum = 0 NEW_LINE step = 0 NEW_LINE while ( sum < target or ( sum - target ) % 2 != 0 ) : NEW_LINE INDENT step = step + 1 NEW_LINE sum = sum + step NEW_LINE DEDENT return step NEW_LINE DEDENT
def fourthPowerSum ( n ) : NEW_LINE INDENT return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 NEW_LINE DEDENT
def aliquotSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sm = sm + i NEW_LINE DEDENT DEDENT return sm NEW_LINE DEDENT
def focal_length_concave ( R ) : NEW_LINE INDENT return R / 2 NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE us = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT us . add ( arr1 [ i ] ) NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if x - arr2 [ j ] in us : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return sum ( [ i * ( i + 1 ) / 2 for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT
def isEmirp ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if isPrime ( n ) == False : NEW_LINE INDENT return False NEW_LINE DEDENT rev = 0 NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE rev = rev * 10 + d NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return isPrime ( rev ) NEW_LINE DEDENT
def squaresum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def oddSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE curr = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + curr NEW_LINE curr = curr + 2 NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def Convert ( radian ) : NEW_LINE INDENT pi = 3.14159 NEW_LINE degree = radian * ( 180 / pi ) NEW_LINE return degree NEW_LINE DEDENT
def sn ( n , an ) : NEW_LINE INDENT return ( n * ( 1 + an ) ) / 2 NEW_LINE DEDENT
def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) * 1.0 ) NEW_LINE DEDENT
def count0s ( mat , Q , sizeQ ) : NEW_LINE INDENT prefixCnt = [ [ 0 for i in range ( N ) ] for i in range ( M ) ] NEW_LINE prefixCnt = preCompute ( mat , prefixCnt ) NEW_LINE for i in range ( sizeQ ) : NEW_LINE INDENT print ( countQuery ( prefixCnt , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , Q [ i ] [ 3 ] ) , end = " " ) NEW_LINE DEDENT DEDENT
def max_area ( n , m , k ) : NEW_LINE INDENT if ( k > ( n + m - 2 ) ) : NEW_LINE INDENT print ( "Not possible" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k < max ( m , n ) - 1 ) : NEW_LINE INDENT result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT DEDENT
def totalNumber ( n ) : NEW_LINE INDENT return 8 * pow ( 9 , n - 1 ) NEW_LINE DEDENT
def recDigSum ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT if n % 9 == 0 : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return n % 9 NEW_LINE DEDENT DEDENT DEDENT
def check ( n ) : NEW_LINE INDENT n = recDigSum ( n ) NEW_LINE if n == 2 or n == 3 or n == 5 or n == 7 : NEW_LINE INDENT print "Yes" NEW_LINE DEDENT else : NEW_LINE INDENT print "No" NEW_LINE DEDENT DEDENT
def isDivisible ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE if ( s [ n - 1 ] != '5' and s [ n - 1 ] != '0' ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = accumulate ( s ) NEW_LINE return ( sum % 3 == 0 ) NEW_LINE DEDENT
def findArmstrong ( low , high ) : NEW_LINE INDENT for i in range ( low + 1 , high ) : NEW_LINE INDENT x = i NEW_LINE n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x / 10 NEW_LINE n = n + 1 NEW_LINE DEDENT pow_sum = 0 NEW_LINE x = i NEW_LINE while ( x != 0 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE pow_sum = pow_sum + math . pow ( digit , n ) NEW_LINE x = x / 10 NEW_LINE DEDENT if ( pow_sum == i ) : NEW_LINE INDENT print ( str ( i ) + " " ) , NEW_LINE DEDENT DEDENT DEDENT
def complement ( number ) : NEW_LINE INDENT for i in range ( 0 , len ( number ) ) : NEW_LINE INDENT if ( number [ i ] != '.' ) : NEW_LINE INDENT a = 9 - int ( number [ i ] ) NEW_LINE number = ( number [ : i ] + str ( a ) + number [ i + 1 : ] ) NEW_LINE DEDENT DEDENT print ( "9's complement is : " , number ) NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while ( ( i * i ) < n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def sumDigitSquare ( n ) : NEW_LINE INDENT sq = 0 NEW_LINE while ( n ) : NEW_LINE INDENT digit = n % 10 NEW_LINE sq = sq + digit * digit NEW_LINE n = n // 10 NEW_LINE DEDENT return sq NEW_LINE DEDENT
def isHappy ( n ) : NEW_LINE INDENT while ( 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT n = sumDigitSquare ( n ) NEW_LINE if ( n == 4 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def sumOfSeries ( a , num ) : NEW_LINE INDENT res = 0 NEW_LINE prev = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prev *= ( a / i ) NEW_LINE res = res + prev NEW_LINE DEDENT return res NEW_LINE DEDENT
def convert ( arr , n ) : NEW_LINE INDENT temp = [ arr [ i ] for i in range ( n ) ] NEW_LINE temp . sort ( ) NEW_LINE umap = { } NEW_LINE val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT umap [ temp [ i ] ] = val NEW_LINE val += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = umap [ arr [ i ] ] NEW_LINE DEDENT DEDENT
def printTrib ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE third = 1 NEW_LINE print ( first , " " , end = "" ) NEW_LINE if ( n > 1 ) : NEW_LINE INDENT print ( second , " " , end = "" ) NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( second , " " , end = "" ) NEW_LINE DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT curr = first + second + third NEW_LINE first = second NEW_LINE second = third NEW_LINE third = curr NEW_LINE print ( curr , " " , end = "" ) NEW_LINE DEDENT DEDENT
def multiply ( T , M ) : NEW_LINE INDENT a = ( T [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 0 ] ) NEW_LINE b = ( T [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 1 ] ) NEW_LINE c = ( T [ 0 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 2 ] ) NEW_LINE d = ( T [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 0 ] ) NEW_LINE e = ( T [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 1 ] ) NEW_LINE f = ( T [ 1 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 2 ] ) NEW_LINE g = ( T [ 2 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 0 ] ) NEW_LINE h = ( T [ 2 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 1 ] ) NEW_LINE i = ( T [ 2 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 2 ] ) NEW_LINE T [ 0 ] [ 0 ] = a NEW_LINE T [ 0 ] [ 1 ] = b NEW_LINE T [ 0 ] [ 2 ] = c NEW_LINE T [ 1 ] [ 0 ] = d NEW_LINE T [ 1 ] [ 1 ] = e NEW_LINE T [ 1 ] [ 2 ] = f NEW_LINE T [ 2 ] [ 0 ] = g NEW_LINE T [ 2 ] [ 1 ] = h NEW_LINE T [ 2 ] [ 2 ] = i NEW_LINE DEDENT
def sackRace ( p1 , s1 , p2 , s2 ) : NEW_LINE INDENT return ( ( s1 > s2 and ( p2 - p1 ) % ( s1 - s2 ) == 0 ) or ( s2 > s1 and ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) NEW_LINE DEDENT
def xorCalc ( k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( ( k + 1 ) & k ) == 0 ) : NEW_LINE INDENT return k / 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def multiple ( a , b , x ) : NEW_LINE INDENT if ( b < 0 ) : NEW_LINE INDENT if ( a == 1 and x == 1 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT DEDENT mul = int ( pow ( a , b ) ) NEW_LINE ans = int ( mul / x ) NEW_LINE ans1 = x * ans NEW_LINE ans2 = x * ( ans + 1 ) NEW_LINE if ( ( mul - ans1 ) <= ( ans2 - mul ) ) : NEW_LINE INDENT print ( ans1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans2 ) NEW_LINE DEDENT DEDENT
def checkJumbled ( num ) : NEW_LINE INDENT if ( num / 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT while ( num != 0 ) : NEW_LINE INDENT if ( num / 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT digit1 = num % 10 NEW_LINE digit2 = ( num / 10 ) % 10 NEW_LINE if ( abs ( digit2 - digit1 ) > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = num / 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
def binomialProbability ( n , k , p ) : NEW_LINE INDENT return ( nCr ( n , k ) * pow ( p , k ) * pow ( 1 - p , n - k ) ) NEW_LINE DEDENT
def flipSign ( a ) : NEW_LINE INDENT neg = 0 NEW_LINE tmp = 1 if a < 0 else - 1 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT neg += tmp NEW_LINE a += tmp NEW_LINE DEDENT return neg NEW_LINE DEDENT
def areDifferentSign ( a , b ) : NEW_LINE INDENT return ( ( a < 0 and b > 0 ) or ( a > 0 and b < 0 ) ) NEW_LINE DEDENT
def FirstDigit ( arr , n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + math . log10 ( arr [ i ] * 1.0 ) NEW_LINE DEDENT fract_S = S - math . floor ( S ) NEW_LINE ans = math . pow ( 10 , fract_S ) NEW_LINE return ans NEW_LINE DEDENT
def cal_cos ( n ) : NEW_LINE INDENT accuracy = 0.0001 NEW_LINE n = n * ( 3.142 / 180.0 ) NEW_LINE x1 = 1 NEW_LINE cosx = x1 NEW_LINE cosval = cos ( n ) NEW_LINE i = 1 NEW_LINE denominator = 2 * i * ( 2 * i - 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE cosx = cosx + x1 NEW_LINE i = i + 1 NEW_LINE while ( accuracy <= fabs ( cosval - cosx ) ) : NEW_LINE INDENT denominator = 2 * i * ( 2 * i - 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE cosx = cosx + x1 NEW_LINE i = i + 1 NEW_LINE DEDENT print ( '{0:.6}' . format ( cosx ) ) NEW_LINE DEDENT
def sumFactDiv ( n ) : NEW_LINE INDENT return div ( fact ( n ) ) NEW_LINE DEDENT
def printNthElement ( n ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) NEW_LINE arr [ 1 ] = 4 NEW_LINE arr [ 2 ] = 7 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i // 2 ] * 10 + 4 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ ( i // 2 ) - 1 ] * 10 + 7 NEW_LINE DEDENT DEDENT return arr [ n ] NEW_LINE DEDENT
def maxSumLCM ( n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT max_sum = max_sum + i NEW_LINE if ( n // i != i ) : NEW_LINE INDENT max_sum = max_sum + ( n // i ) NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return max_sum NEW_LINE DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 and n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( int ) ( st [ n - 2 ] ) * 10 + ( ( int ) ( st [ n - 1 ] ) % 16 == 0 ) ) NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return ( ( ( int ) ( st [ n - 3 ] ) * 100 + ( int ) ( st [ n - 2 ] ) * 10 + ( int ) ( st [ n - 1 ] ) ) % 16 == 0 ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE third_last = ( int ) ( st [ n - 3 ] ) NEW_LINE fourth_last = ( int ) ( st [ n - 4 ] ) NEW_LINE return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) NEW_LINE DEDENT
def checkPandigital ( b , n ) : NEW_LINE INDENT if ( len ( n ) < b ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT hash = [ 0 ] * b NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT if ( n [ i ] >= '0' and n [ i ] <= '9' ) : NEW_LINE INDENT hash [ ord ( n [ i ] ) - ord ( '0' ) ] = 1 NEW_LINE DEDENT elif ( ord ( n [ i ] ) - ord ( 'A' ) <= b - 11 ) : NEW_LINE INDENT hash [ ord ( n [ i ] ) - ord ( 'A' ) + 10 ] = 1 NEW_LINE DEDENT DEDENT for i in range ( b ) : NEW_LINE INDENT if ( hash [ i ] == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def findStarNum ( n ) : NEW_LINE INDENT return ( 6 * n * ( n - 1 ) + 1 ) NEW_LINE DEDENT
def squareFree ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 1 NEW_LINE while ( True ) : NEW_LINE INDENT isSqFree = True NEW_LINE j = 2 NEW_LINE while ( j * j <= i ) : NEW_LINE INDENT if ( i % ( j * j ) == 0 ) : NEW_LINE INDENT isSqFree = False NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( isSqFree == True ) : NEW_LINE INDENT cnt += 1 NEW_LINE if ( cnt == n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( int ) ( st [ 0 ] ) % 8 == 0 ) NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( int ) ( st [ n - 2 ] ) * 10 + ( ( int ) ( str [ n - 1 ] ) % 8 == 0 ) ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE third_last = ( int ) ( st [ n - 3 ] ) NEW_LINE return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) NEW_LINE DEDENT
def isRefactorableNumber ( n ) : NEW_LINE INDENT divCount = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT divCount += 1 NEW_LINE divCount += 2 NEW_LINE DEDENT DEDENT DEDENT return n % divCount == 0 NEW_LINE DEDENT
def nearestGcd ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT closest = - 1 NEW_LINE j = i - 1 NEW_LINE k = i + 1 NEW_LINE while j > 0 or k <= n : NEW_LINE INDENT if ( j >= 0 and math . gcd ( arr [ i ] , arr [ j ] ) > 1 ) : NEW_LINE INDENT closest = j + 1 NEW_LINE break NEW_LINE DEDENT if ( k < n and math . gcd ( arr [ i ] , arr [ k ] ) > 1 ) : NEW_LINE INDENT closest = k + 1 NEW_LINE break NEW_LINE DEDENT k += 1 NEW_LINE j -= 1 NEW_LINE DEDENT print ( closest , end = " " ) NEW_LINE DEDENT DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT
def lastNon0Digit ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return dig [ n ] NEW_LINE DEDENT if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) : NEW_LINE INDENT return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def Special_Factorial_Number ( k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( fact ( i ) % k == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def findnum ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count_after_dot = 0 NEW_LINE dot_seen = 0 NEW_LINE num = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] != '.' ) : NEW_LINE INDENT num = num * 10 + int ( str [ i ] ) NEW_LINE if ( dot_seen == 1 ) : NEW_LINE INDENT count_after_dot += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dot_seen = 1 NEW_LINE DEDENT DEDENT if ( dot_seen == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dem = int ( math . pow ( 10 , count_after_dot ) ) NEW_LINE return ( dem / gcd ( num , dem ) ) NEW_LINE DEDENT
def iskaprekar ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT sq_n = n * n NEW_LINE count_digits = 1 NEW_LINE while not sq_n == 0 : NEW_LINE INDENT count_digits = count_digits + 1 NEW_LINE sq_n = sq_n / 10 NEW_LINE DEDENT r_digits = 0 NEW_LINE while r_digits < count_digits : NEW_LINE INDENT r_digits = r_digits + 1 NEW_LINE eq_parts = ( int ) ( math . pow ( 10 , r_digits ) ) NEW_LINE if eq_parts == n : NEW_LINE INDENT continue NEW_LINE DEDENT sum = sq_n / eq_parts + sq_n % eq_parts NEW_LINE if sum == n : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def kDivisors ( a , b , k ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT if ( isPerfect ( i ) ) : NEW_LINE INDENT if ( divisorsCount ( i ) == k ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def buildDivisorsArray ( ) : NEW_LINE INDENT for i in range ( 1 , maxn ) : NEW_LINE INDENT divisors [ i ] = 1 NEW_LINE n = i NEW_LINE p = smallest_prime [ i ] NEW_LINE k = 0 NEW_LINE while ( n > 1 ) : NEW_LINE INDENT n = n // p NEW_LINE k += 1 NEW_LINE if ( smallest_prime [ n ] != p ) : NEW_LINE INDENT divisors [ i ] = divisors [ i ] * ( k + 1 ) NEW_LINE k = 0 NEW_LINE DEDENT p = smallest_prime [ n ] NEW_LINE DEDENT DEDENT DEDENT
def commDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE result = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT result += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += 2 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def findCountOfSolutions ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( 1 , p ) : NEW_LINE INDENT if ( ( x * x ) % p == 1 ) : NEW_LINE INDENT last = x + p * ( n / p ) NEW_LINE if ( last > n ) : NEW_LINE INDENT last -= p NEW_LINE DEDENT ans += ( ( last - x ) / p + 1 ) NEW_LINE DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT
def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = ( - 2 * num ) NEW_LINE b , a = 1 , 1 NEW_LINE d = ( b * b ) - ( 4 * a * c ) NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT root1 = ( - b + math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE root2 = ( - b - math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE if ( root1 > 0 and math . floor ( root1 ) == root1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( root2 > 0 and math . floor ( root2 ) == root2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def flip ( c ) : NEW_LINE INDENT return '1' if ( c == '0' ) else '0' NEW_LINE DEDENT
def areElementsContiguous ( arr , n ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE min1 = min ( arr ) NEW_LINE m = max1 - min1 + 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ arr [ i ] - min1 ] = True NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def SieveOfAtkin ( limit ) : NEW_LINE INDENT if ( limit > 2 ) : NEW_LINE INDENT print ( 2 , end = " " ) NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT print ( 3 , end = " " ) NEW_LINE DEDENT sieve = [ False ] * limit NEW_LINE for i in range ( 0 , limit ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT x = 1 NEW_LINE while ( x * x < limit ) : NEW_LINE INDENT y = 1 NEW_LINE while ( y * y < limit ) : NEW_LINE INDENT n = ( 4 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and n % 12 == 7 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) - ( y * y ) NEW_LINE if ( x > y and n <= limit and n % 12 == 11 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT r = 5 NEW_LINE while ( r * r < limit ) : NEW_LINE INDENT if ( sieve [ r ] ) : NEW_LINE INDENT for i in range ( r * r , limit , r * r ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for a in range ( 5 , limit ) : NEW_LINE INDENT if ( sieve [ a ] ) : NEW_LINE INDENT print ( a , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = int ( ( n - 1 ) / 2 ) NEW_LINE marked = [ 0 ] * ( nNew + 1 ) NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = " " ) NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def squareRootExists ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p , 1 ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def modFact ( n , p ) : NEW_LINE INDENT if ( p <= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = ( p - 1 ) NEW_LINE for i in range ( n + 1 , p ) : NEW_LINE INDENT res = ( res * modInverse ( i , p ) ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT
def isInside ( circle_x , circle_y , rad , x , y ) : NEW_LINE INDENT if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def checkUtil ( num , dig , base ) : NEW_LINE INDENT if ( dig == 1 and num < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and num >= base ) : NEW_LINE INDENT return checkUtil ( num / base , - - dig , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT
def countLeapYears ( d ) : NEW_LINE INDENT years = d . y NEW_LINE if ( d . m <= 2 ) : NEW_LINE INDENT years -= 1 NEW_LINE DEDENT ans = int ( years / 4 ) NEW_LINE ans -= int ( years / 100 ) NEW_LINE ans += int ( years / 400 ) NEW_LINE return ans NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return int ( res ) NEW_LINE DEDENT
def findWays ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return catalan ( int ( n / 2 ) ) NEW_LINE DEDENT
def XorSum ( A , B , N , M ) : NEW_LINE INDENT ans1 = 0 NEW_LINE ans2 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans1 = ans1 ^ A [ i ] NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT ans2 = ans2 ^ B [ i ] NEW_LINE DEDENT return ( ans1 & ans2 ) NEW_LINE DEDENT
def check ( x ) : NEW_LINE INDENT if ( ( ( x ) & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def maxAndXor ( arr , n ) : NEW_LINE INDENT ans = float ( 'inf' ) NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans = min ( ans , arr [ i ] ^ arr [ i + 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def FlipBits ( n ) : NEW_LINE INDENT for bit in range ( 32 ) : NEW_LINE INDENT if ( ( n >> bit ) & 1 ) : NEW_LINE INDENT n = n ^ ( 1 << bit ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( "The number after unsetting the" , end = " " ) NEW_LINE print ( "rightmost set bit" , n ) NEW_LINE DEDENT
def minRange ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE if ( len ( s ) == k ) : NEW_LINE INDENT if ( ( j - i ) < ( r - l ) ) : NEW_LINE INDENT r = j NEW_LINE l = i NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( l == 0 and r == n ) : NEW_LINE INDENT print ( "Invalid k" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l , r ) NEW_LINE DEDENT DEDENT
def construct_Xor_Tree ( arr , n ) : NEW_LINE INDENT construct_Xor_Tree_Util ( arr , 0 , n - 1 , 0 ) NEW_LINE DEDENT
def maximizeExpression ( a , b ) : NEW_LINE INDENT result = a NEW_LINE for bit in range ( MAX - 1 , - 1 , - 1 ) : NEW_LINE INDENT bitOfD = 1 << bit NEW_LINE x = b & bitOfD NEW_LINE if ( x == bitOfD ) : NEW_LINE INDENT y = result & bitOfD NEW_LINE if ( y == 0 ) : NEW_LINE INDENT result = result ^ bitOfD NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def hasEqualBlockFrequency ( N ) : NEW_LINE INDENT S = bin ( N ) . replace ( "0b" , "" ) NEW_LINE p = set ( ) NEW_LINE c = 1 NEW_LINE for i in range ( len ( S ) - 1 ) : NEW_LINE INDENT if ( S [ i ] == S [ i + 1 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p . add ( c ) NEW_LINE c = 1 NEW_LINE DEDENT p . add ( c ) NEW_LINE DEDENT if ( len ( p ) == 1 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def isEqualBlock ( n ) : NEW_LINE INDENT first_bit = n % 2 NEW_LINE first_count = 1 NEW_LINE n = n // 2 NEW_LINE while n % 2 == first_bit and n > 0 : NEW_LINE INDENT n = n // 2 NEW_LINE first_count += 1 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT while n > 0 : NEW_LINE INDENT first_bit = n % 2 NEW_LINE curr_count = 1 NEW_LINE n = n // 2 NEW_LINE while n % 2 == first_bit : NEW_LINE INDENT n = n // 2 NEW_LINE curr_count += 1 NEW_LINE DEDENT if curr_count != first_count : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def printMaxAfterRemoval ( s ) : NEW_LINE INDENT flag = False NEW_LINE n = len ( s ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if s [ i ] == '0' and flag == False : NEW_LINE INDENT flag = True NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def bitPos ( n1 , n2 ) : NEW_LINE INDENT if n1 == n2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT bitCount1 = floor ( log2 ( n1 ) ) + 1 NEW_LINE bitCount2 = floor ( log2 ( n2 ) ) + 1 NEW_LINE bitDiff = abs ( bitCount1 - bitCount2 ) NEW_LINE maxBitCount = max ( bitCount1 , bitCount2 ) NEW_LINE if ( bitCount1 > bitCount2 ) : NEW_LINE INDENT n2 *= pow ( 2 , bitDiff ) NEW_LINE DEDENT else : NEW_LINE INDENT n1 *= pow ( 2 , bitDiff ) NEW_LINE DEDENT xorValue = n1 ^ n2 NEW_LINE bitCountXorValue = floor ( log2 ( xorValue ) ) + 1 NEW_LINE disSimilarBitPosition = ( maxBitCount - bitCountXorValue + 1 ) NEW_LINE return disSimilarBitPosition NEW_LINE DEDENT
def findevenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT oddCount = count * ( count - 1 ) / 2 NEW_LINE return ( int ) ( ( N * ( N - 1 ) / 2 ) - oddCount ) NEW_LINE DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev ^ arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE DEDENT
def highestPowerOf2 ( n ) : NEW_LINE INDENT return ( n & ( ~ ( n - 1 ) ) ) NEW_LINE DEDENT
def maxTriplet ( a , n ) : NEW_LINE INDENT f = [ True for i in range ( n ) ] NEW_LINE bits = [ [ 0 for i in range ( 33 ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE j = 32 NEW_LINE while ( num ) : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT bits [ i ] [ j ] = 1 NEW_LINE DEDENT j -= 1 NEW_LINE num >>= 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 33 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( bits [ j ] [ i ] and f [ j ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= 3 ) : NEW_LINE INDENT ans += pow ( 2 , 32 - i ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( bits [ j ] [ i ] == False ) : NEW_LINE INDENT f [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( f [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT NumberOfTriplets = ( cnt * ( cnt - 1 ) * ( cnt - 2 ) ) // 6 NEW_LINE print ( NumberOfTriplets , ans ) NEW_LINE DEDENT
def AND ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans &= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findEvenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( not ( A [ i ] & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( count - 1 ) // 2 NEW_LINE DEDENT
def printOdds ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT set_bit = res & ( ~ ( res - 1 ) ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & set_bit ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( x , y , end = "" ) NEW_LINE DEDENT
def printKthBit ( n , k ) : NEW_LINE INDENT print ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) NEW_LINE DEDENT
def decimalToBinaryNumber ( x , n ) : NEW_LINE INDENT binaryNumber = [ 0 ] * x NEW_LINE i = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT binaryNumber [ i ] = x % 2 NEW_LINE x = x // 2 NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 0 , n - i ) : NEW_LINE INDENT print ( '0' , end = "" ) NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNumber [ j ] , end = "" ) NEW_LINE DEDENT DEDENT
def XOR ( a , b ) : NEW_LINE INDENT c = min ( a , b ) NEW_LINE d = max ( a , b ) NEW_LINE if ( count ( c ) < count ( d ) ) : NEW_LINE INDENT c = c << ( count ( d ) - count ( c ) ) NEW_LINE DEDENT return ( c ^ d ) NEW_LINE DEDENT
def toggleBits ( n1 , n2 ) : NEW_LINE INDENT return ( n1 ^ n2 ) NEW_LINE DEDENT
def evenbittogglenumber ( n ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( count % 2 == 1 ) : NEW_LINE INDENT res = res | ( 1 << count ) NEW_LINE DEDENT count = count + 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return n ^ res NEW_LINE DEDENT
def maxXorSum ( n , k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT res = 1 NEW_LINE while res <= n : NEW_LINE INDENT res <<= 1 NEW_LINE DEDENT return res - 1 NEW_LINE DEDENT
def evenbittogglenumber ( n ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( count % 2 == 0 ) : NEW_LINE INDENT res = res | ( 1 << count ) NEW_LINE DEDENT count = count + 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return n ^ res NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def maxAND ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for bit in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT count = checkBit ( res | ( 1 << bit ) , arr , n ) NEW_LINE if ( count >= 2 ) : NEW_LINE INDENT res = res | ( 1 << bit ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countUnsetBits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE t = math . log ( x ^ n , 2 ) NEW_LINE return math . floor ( t ) NEW_LINE DEDENT
def setBitNumber ( n ) : NEW_LINE INDENT k = int ( math . log ( n , 2 ) ) NEW_LINE return 1 << k NEW_LINE DEDENT
def toggle ( n ) : NEW_LINE INDENT temp = 1 NEW_LINE while ( temp <= n ) : NEW_LINE INDENT n = n ^ temp NEW_LINE temp = temp << 1 NEW_LINE DEDENT return n NEW_LINE DEDENT
def getFirstSetBitPos ( n ) : NEW_LINE INDENT return ( int ) ( math . log ( n & - n ) / math . log ( 2 ) ) + 1 NEW_LINE DEDENT
def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def CountZeroBit ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x ) : NEW_LINE INDENT if ( ( x & 1 ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT x >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def bitCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def sumoflength ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and ( arr [ j ] not in s ) ) : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) // 2 NEW_LINE s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def areSetBitsIncreasing ( n ) : NEW_LINE INDENT prev_count = sys . maxsize NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( n > 0 and n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT curr_count = 1 NEW_LINE while ( n > 0 and n % 2 == 1 ) : NEW_LINE INDENT n = n / 2 NEW_LINE curr_count += 1 NEW_LINE DEDENT if ( curr_count >= prev_count ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_count = curr_count NEW_LINE DEDENT return True NEW_LINE DEDENT
def findPattern ( n ) : NEW_LINE INDENT prev = n % 2 NEW_LINE n = n // 2 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT curr = n % 2 NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isMultipleOf4 ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT XOR = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT XOR = XOR ^ i NEW_LINE DEDENT return ( XOR == n ) NEW_LINE DEDENT
def findProffesion ( level , pos ) : NEW_LINE INDENT if ( level == 1 ) : NEW_LINE INDENT return 'e' NEW_LINE DEDENT if ( findProffesion ( level - 1 , ( pos + 1 ) // 2 ) == 'd' ) : NEW_LINE INDENT if ( pos % 2 ) : NEW_LINE INDENT return 'd' NEW_LINE DEDENT else : NEW_LINE INDENT return 'e' NEW_LINE DEDENT DEDENT if ( pos % 2 ) : NEW_LINE INDENT return 'e' NEW_LINE DEDENT else : NEW_LINE INDENT return 'd' NEW_LINE DEDENT DEDENT
def swapBits ( n , p1 , p2 ) : NEW_LINE INDENT bit1 = ( n >> p1 ) & 1 NEW_LINE bit2 = ( n >> p2 ) & 1 NEW_LINE x = ( bit1 ^ bit2 ) NEW_LINE x = ( x << p1 ) | ( x << p2 ) NEW_LINE result = n ^ x NEW_LINE return result NEW_LINE DEDENT
def getElements ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( getElements ( root . left ) + getElements ( root . right ) + 1 ) NEW_LINE DEDENT
def sumOfDiv ( x ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( x ) ) ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT sum += i NEW_LINE if i != x / i : NEW_LINE INDENT sum += x / i NEW_LINE DEDENT DEDENT DEDENT return int ( sum ) NEW_LINE DEDENT
def leftRotate ( arr , d , n ) : NEW_LINE INDENT for i in range ( d ) : NEW_LINE INDENT leftRotatebyOne ( arr , n ) NEW_LINE DEDENT DEDENT
def merge ( arr , l , m , r ) : NEW_LINE INDENT i = l NEW_LINE j = m + 1 NEW_LINE while i <= m and arr [ i ] < 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while j <= r and arr [ j ] < 0 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT reverse ( arr , i , m ) NEW_LINE reverse ( arr , m + 1 , j - 1 ) NEW_LINE reverse ( arr , i , j - 1 ) NEW_LINE DEDENT
def arrayEvenAndOdd ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE j = 0 NEW_LINE while ( j != n ) : NEW_LINE INDENT if ( arr [ j ] % 2 == 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT for i in arr : NEW_LINE INDENT print ( str ( i ) + " " , end = '' ) NEW_LINE DEDENT DEDENT
def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) : NEW_LINE INDENT if ( k > n1 * n2 ) : NEW_LINE INDENT print ( "k pairs don't exist" ) NEW_LINE return NEW_LINE DEDENT index2 = [ 0 for i in range ( n1 ) ] NEW_LINE while ( k > 0 ) : NEW_LINE INDENT min_sum = sys . maxsize NEW_LINE min_index = 0 NEW_LINE for i1 in range ( 0 , n1 , 1 ) : NEW_LINE INDENT if ( index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) : NEW_LINE INDENT min_index = i1 NEW_LINE min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] NEW_LINE DEDENT DEDENT print ( "(" , arr1 [ min_index ] , "," , arr2 [ index2 [ min_index ] ] , ")" , end = " " ) NEW_LINE index2 [ min_index ] += 1 NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT
def Solve ( L , R ) : NEW_LINE INDENT global one , MAX NEW_LINE l = L NEW_LINE r = R NEW_LINE tot_bits = r - l + 1 NEW_LINE X = MAX NEW_LINE for i in range ( 0 , 31 ) : NEW_LINE INDENT x = one [ r ] [ i ] - one [ l - 1 ] [ i ] NEW_LINE if ( x >= ( tot_bits - x ) ) : NEW_LINE INDENT ith_bit = pow ( 2 , i ) NEW_LINE X = X ^ ith_bit NEW_LINE DEDENT DEDENT return X NEW_LINE DEDENT
def swap ( arr , i , j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT
def findNumberOfTriangles ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] > arr [ k ] and arr [ i ] + arr [ k ] > arr [ j ] and arr [ k ] + arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def CountTriangles ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT l = 0 NEW_LINE r = i - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ l ] + A [ r ] > A [ i ] ) : NEW_LINE INDENT count += r - l NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT print ( "No of possible solutions: " , count ) NEW_LINE DEDENT
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while r < n : NEW_LINE INDENT if arr [ r ] - arr [ l ] == k : NEW_LINE INDENT count += 1 NEW_LINE l += 1 NEW_LINE r += 1 NEW_LINE DEDENT elif arr [ r ] - arr [ l ] > k : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def getSumAlternate ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = root . data NEW_LINE if ( root . left != None ) : NEW_LINE INDENT sum += getSum ( root . left . left ) NEW_LINE sum += getSum ( root . left . right ) NEW_LINE DEDENT if ( root . right != None ) : NEW_LINE INDENT sum += getSum ( root . right . left ) NEW_LINE sum += getSum ( root . right . right ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getSum ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max ( getSumAlternate ( root ) , ( getSumAlternate ( root . left ) + getSumAlternate ( root . right ) ) ) NEW_LINE DEDENT
def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT mid = ( low + high ) / 2 NEW_LINE if ( key == arr [ int ( mid ) ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ int ( mid ) ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT if ( key < arr [ int ( mid ) ] ) : NEW_LINE INDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def getHeight ( Node ) : NEW_LINE INDENT if ( Node == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT lHeight = getHeight ( Node . left ) NEW_LINE rHeight = getHeight ( Node . right ) NEW_LINE if ( lHeight > rHeight ) : NEW_LINE INDENT return ( lHeight + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( rHeight + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def printLeaders ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if arr [ i ] <= arr [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == size - 1 : NEW_LINE INDENT print arr [ i ] , NEW_LINE DEDENT DEDENT DEDENT
def binarySearch ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE DEDENT if mid is arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , low , ( mid - 1 ) ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def getMin ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < min ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT
def interpolationSearch ( arr , lo , hi , x ) : NEW_LINE INDENT if ( lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] ) : NEW_LINE INDENT pos = lo + ( ( hi - lo ) // ( arr [ hi ] - arr [ lo ] ) * ( x - arr [ lo ] ) ) NEW_LINE if arr [ pos ] == x : NEW_LINE INDENT return pos NEW_LINE DEDENT if arr [ pos ] < x : NEW_LINE INDENT return interpolationSearch ( arr , pos + 1 , hi , x ) NEW_LINE DEDENT if arr [ pos ] > x : NEW_LINE INDENT return interpolationSearch ( arr , lo , pos - 1 , x ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def sort ( arr , n ) : NEW_LINE INDENT countSort ( arr , n , 1 ) NEW_LINE countSort ( arr , n , n ) NEW_LINE DEDENT
def countOnes ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if arr [ mid ] == 1 : NEW_LINE INDENT return countOnes ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT return countOnes ( arr , low , mid - 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def isUgly ( no ) : NEW_LINE INDENT no = maxDivide ( no , 2 ) NEW_LINE no = maxDivide ( no , 3 ) NEW_LINE no = maxDivide ( no , 5 ) NEW_LINE return 1 if no == 1 else 0 NEW_LINE DEDENT
def countRec ( n , sum ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( sum == 0 ) NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans = ans + countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countRec ( n , Sum ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return Sum == 0 NEW_LINE DEDENT if ( lookup [ n ] [ Sum ] != - 1 ) : NEW_LINE INDENT return lookup [ n ] [ Sum ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( Sum - i >= 0 ) : NEW_LINE INDENT ans += countRec ( n - 1 , Sum - i ) NEW_LINE DEDENT DEDENT lookup [ n ] [ Sum ] = ans NEW_LINE return lookup [ n ] [ Sum ] NEW_LINE DEDENT
def sumOfDigitsFrom1ToNUtil ( n , a ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT d = int ( math . log ( n , 10 ) ) NEW_LINE p = int ( math . ceil ( pow ( 10 , d ) ) ) NEW_LINE msd = n // p NEW_LINE return ( msd * a [ d ] + ( msd * ( msd - 1 ) // 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToNUtil ( n % p , a ) ) NEW_LINE DEDENT
def findoptimal ( N ) : NEW_LINE INDENT if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT screen = [ 0 ] * N NEW_LINE for n in range ( 1 , 7 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT for n in range ( 7 , N + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) NEW_LINE DEDENT return screen [ N - 1 ] NEW_LINE DEDENT
def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r NEW_LINE combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) NEW_LINE DEDENT
def findCeil ( arr , r , l , h ) : NEW_LINE INDENT while ( l < h ) : NEW_LINE INDENT mid = l + ( ( h - l ) >> 1 ) NEW_LINE if r > arr [ mid ] : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid NEW_LINE DEDENT DEDENT if arr [ l ] >= r : NEW_LINE INDENT return l NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( math . floor ( logn ( n , 4 ) ) == math . ceil ( logn ( n , 4 ) ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) NEW_LINE DEDENT
def countSetBitsRec ( num ) : NEW_LINE INDENT nibble = 0 NEW_LINE if ( 0 == num ) : NEW_LINE INDENT return num_to_bits [ 0 ] NEW_LINE DEDENT nibble = num & 0xf NEW_LINE return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) NEW_LINE DEDENT
def PositionRightmostSetbit ( n ) : NEW_LINE INDENT position = 1 NEW_LINE m = 1 NEW_LINE while ( not ( n & m ) ) : NEW_LINE INDENT m = m << 1 NEW_LINE position += 1 NEW_LINE DEDENT return position NEW_LINE DEDENT
def swapBits ( x ) : NEW_LINE INDENT even_bits = x & 0xAAAAAAAA NEW_LINE odd_bits = x & 0x55555555 NEW_LINE even_bits >>= 1 NEW_LINE odd_bits <<= 1 NEW_LINE return ( even_bits odd_bits ) NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( True if ( n > 0 and ( ( n & ( n - 1 ) ) > 0 ) ) else False ) NEW_LINE DEDENT
def segregate0and1 ( arr , size ) : NEW_LINE INDENT left , right = 0 , size - 1 NEW_LINE while left < right : NEW_LINE INDENT while arr [ left ] == 0 and left < right : NEW_LINE INDENT left += 1 NEW_LINE DEDENT while arr [ right ] == 1 and left < right : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT if left < right : NEW_LINE INDENT arr [ left ] = 0 NEW_LINE arr [ right ] = 1 NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT sum -= ( 2 * arr [ i ] ) NEW_LINE sum += ( 2 * arr [ n - i - 1 ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def updateindex ( index , a , ai , b , bi ) : NEW_LINE INDENT index [ a ] = ai NEW_LINE index [ b ] = bi NEW_LINE DEDENT
def minSwapsUtil ( arr , pairs , index , i , n ) : NEW_LINE INDENT if ( i > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( pairs [ arr [ i ] ] == arr [ i + 1 ] ) : NEW_LINE INDENT return minSwapsUtil ( arr , pairs , index , i + 2 , n ) NEW_LINE DEDENT one = arr [ i + 1 ] NEW_LINE indextwo = i + 1 NEW_LINE indexone = index [ pairs [ arr [ i ] ] ] NEW_LINE two = arr [ index [ pairs [ arr [ i ] ] ] ] NEW_LINE arr [ i + 1 ] , arr [ indexone ] = arr [ indexone ] , arr [ i + 1 ] NEW_LINE updateindex ( index , one , indexone , two , indextwo ) NEW_LINE a = minSwapsUtil ( arr , pairs , index , i + 2 , n ) NEW_LINE arr [ i + 1 ] , arr [ indexone ] = arr [ indexone ] , arr [ i + 1 ] NEW_LINE updateindex ( index , one , indextwo , two , indexone ) NEW_LINE one = arr [ i ] NEW_LINE indexone = index [ pairs [ arr [ i + 1 ] ] ] NEW_LINE two = arr [ index [ pairs [ arr [ i + 1 ] ] ] ] NEW_LINE indextwo = i NEW_LINE arr [ i ] , arr [ indexone ] = arr [ indexone ] , arr [ i ] NEW_LINE updateindex ( index , one , indexone , two , indextwo ) NEW_LINE b = minSwapsUtil ( arr , pairs , index , i + 2 , n ) NEW_LINE arr [ i ] , arr [ indexone ] = arr [ indexone ] , arr [ i ] NEW_LINE updateindex ( index , one , indextwo , two , indexone ) NEW_LINE return 1 + min ( a , b ) NEW_LINE DEDENT
def process ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE DEDENT DEDENT
def prefixXOR ( arr , preXOR , n ) : NEW_LINE INDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT while ( arr [ i ] % 2 != 1 ) : NEW_LINE INDENT arr [ i ] = int ( arr [ i ] / 2 ) NEW_LINE DEDENT preXOR [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] NEW_LINE DEDENT DEDENT
def query ( preXOR , l , r ) : NEW_LINE INDENT if ( l == 0 ) : NEW_LINE INDENT return preXOR [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return preXOR [ r ] ^ preXOR [ l - 1 ] NEW_LINE DEDENT DEDENT
def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countPairs ( a , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( a [ j ] - a [ i ] ) < k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT small = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT small += 1 NEW_LINE DEDENT DEDENT great = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT great += 1 NEW_LINE DEDENT DEDENT invcount += great * small NEW_LINE DEDENT return invcount NEW_LINE DEDENT
def countPairs ( A , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE A . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = 0 NEW_LINE while ( ( A [ i ] * math . pow ( k , x ) ) <= A [ j ] ) : NEW_LINE INDENT if ( ( A [ i ] * math . pow ( k , x ) ) == A [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def printMax ( arr , k , n ) : NEW_LINE INDENT brr = arr . copy ( ) NEW_LINE brr . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in brr [ 0 : k ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def find_consecutive_steps ( arr , len ) : NEW_LINE INDENT count = 0 NEW_LINE maximum = 0 NEW_LINE for index in range ( 1 , len ) : NEW_LINE INDENT if ( arr [ index ] > arr [ index - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maximum = max ( maximum , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return max ( maximum , count ) NEW_LINE DEDENT
def findSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE arr . sort ( ) NEW_LINE i = 0 NEW_LINE while i < n and arr [ i ] < 0 : NEW_LINE INDENT if i != n - 1 and arr [ i + 1 ] <= 0 : NEW_LINE INDENT sum = ( sum + ( arr [ i ] * arr [ i + 1 ] ) % Mod ) % Mod NEW_LINE i += 2 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT j = n - 1 NEW_LINE while j >= 0 and arr [ j ] > 0 : NEW_LINE INDENT if j != 0 and arr [ j - 1 ] > 0 : NEW_LINE INDENT sum = ( sum + ( arr [ j ] * arr [ j - 1 ] ) % Mod ) % Mod NEW_LINE j -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j > i : NEW_LINE INDENT sum = ( sum + ( arr [ i ] * arr [ j ] ) % Mod ) % Mod NEW_LINE DEDENT elif i == j : NEW_LINE INDENT sum = ( sum + arr [ i ] ) % Mod NEW_LINE DEDENT return sum NEW_LINE DEDENT
def printList ( head ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( temp . data , end = " " ) NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT
def insertAfterNthNode ( head , n , x ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT newNode = getNode ( x ) NEW_LINE ptr = head NEW_LINE len = 0 NEW_LINE i = 0 NEW_LINE while ( ptr != None ) : NEW_LINE INDENT len = len + 1 NEW_LINE ptr = ptr . next NEW_LINE DEDENT ptr = head NEW_LINE i = 1 NEW_LINE while ( i <= ( len - n ) ) : NEW_LINE INDENT ptr = ptr . next NEW_LINE i = i + 1 NEW_LINE DEDENT newNode . next = ptr . next NEW_LINE ptr . next = newNode NEW_LINE DEDENT
def findLargestRotation ( num ) : NEW_LINE INDENT ans = num NEW_LINE length = len ( str ( num ) ) NEW_LINE x = 10 ** ( length - 1 ) NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT lastDigit = num % 10 NEW_LINE num = num // 10 NEW_LINE num += ( lastDigit * x ) NEW_LINE if ( num > ans ) : NEW_LINE INDENT ans = num NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def reverse ( arr , s , e ) : NEW_LINE INDENT while s < e : NEW_LINE INDENT tem = arr [ s ] NEW_LINE arr [ s ] = arr [ e ] NEW_LINE arr [ e ] = tem NEW_LINE s = s + 1 NEW_LINE e = e - 1 NEW_LINE DEDENT DEDENT
def countRotation ( arr , low , high ) : NEW_LINE INDENT if ( low > high ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid < high and arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ mid ] > arr [ low ] ) : NEW_LINE INDENT return countRotation ( arr , mid + 1 , high ) NEW_LINE DEDENT if ( arr [ mid ] < arr [ high ] ) : NEW_LINE INDENT return countRotation ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT rightIndex = countRotation ( arr , mid + 1 , high ) NEW_LINE leftIndex = countRotation ( arr , low , mid - 1 ) NEW_LINE if ( rightIndex == 0 ) : NEW_LINE INDENT return leftIndex NEW_LINE DEDENT return rightIndex NEW_LINE DEDENT DEDENT
def build ( node , l , r , a ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT seg [ node ] = a [ l ] NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE build ( 2 * node , l , mid , a ) NEW_LINE build ( 2 * node + 1 , mid + 1 , r , a ) NEW_LINE seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) NEW_LINE DEDENT DEDENT
def rightRotationDivisor ( N ) : NEW_LINE INDENT lastDigit = N % 10 NEW_LINE rightRotation = ( lastDigit * 10 ** int ( log10 ( N ) ) + N // 10 ) NEW_LINE return rightRotation % N == 0 NEW_LINE DEDENT
def digitSum ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( num != 0 ) : NEW_LINE INDENT sum += ( num % 10 ) NEW_LINE num //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def printList ( start ) : NEW_LINE INDENT temp = 0 NEW_LINE if ( start != None ) : NEW_LINE INDENT temp = start NEW_LINE while True : NEW_LINE INDENT print ( temp . data , end = ' ' ) NEW_LINE temp = temp . next NEW_LINE if ( temp == start ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT
def displayList ( start ) : NEW_LINE INDENT temp = start NEW_LINE while ( temp . next != start ) : NEW_LINE INDENT print ( temp . data , end = " " ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data ) NEW_LINE DEDENT
def alivesol ( Num ) : NEW_LINE INDENT if ( Num == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT last = newNode ( 1 ) NEW_LINE last . next = last NEW_LINE for i in range ( 2 , Num + 1 ) : NEW_LINE INDENT temp = newNode ( i ) NEW_LINE temp . next = last . next NEW_LINE last . next = temp NEW_LINE last = temp NEW_LINE DEDENT curr = last . next NEW_LINE temp = None NEW_LINE while ( curr . next != curr ) : NEW_LINE INDENT temp = curr NEW_LINE curr = curr . next NEW_LINE temp . next = curr . next NEW_LINE del curr NEW_LINE temp = temp . next NEW_LINE curr = temp NEW_LINE DEDENT res = temp . data NEW_LINE del temp NEW_LINE return res NEW_LINE DEDENT
def addEdge ( u , v , cost ) : NEW_LINE INDENT global graph NEW_LINE graph [ u ] . append ( [ v , cost ] ) NEW_LINE graph [ v ] . append ( [ u , cost ] ) NEW_LINE DEDENT
def dfs ( node , parent , h ) : NEW_LINE INDENT lca [ node ] [ 0 ] = parent NEW_LINE level [ node ] = h NEW_LINE if ( parent != - 1 ) : NEW_LINE INDENT minWeight [ node ] [ 0 ] = ( min ( weight [ node ] , weight [ parent ] ) ) NEW_LINE maxWeight [ node ] [ 0 ] = ( max ( weight [ node ] , weight [ parent ] ) ) NEW_LINE DEDENT for i in range ( 1 , log ) : NEW_LINE INDENT if ( lca [ node ] [ i - 1 ] != - 1 ) : NEW_LINE INDENT lca [ node ] [ i ] = lca [ lca [ node ] [ i - 1 ] ] [ i - 1 ] NEW_LINE minWeight [ node ] [ i ] = min ( minWeight [ node ] [ i - 1 ] , minWeight [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) NEW_LINE maxWeight [ node ] [ i ] = max ( maxWeight [ node ] [ i - 1 ] , maxWeight [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) NEW_LINE DEDENT DEDENT for i in graph [ node ] : NEW_LINE INDENT if ( i == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( i , node , h + 1 ) NEW_LINE DEDENT DEDENT
def LCANaive ( u , v ) : NEW_LINE INDENT if ( u == v ) : NEW_LINE INDENT return u NEW_LINE DEDENT if ( depth [ u ] > depth [ v ] ) : NEW_LINE INDENT u , v = v , u NEW_LINE DEDENT v = parent [ v ] NEW_LINE return LCANaive ( u , v ) NEW_LINE DEDENT
def solve ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE parent = [ - 1 ] * n NEW_LINE vis = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i NEW_LINE if ( parent [ j ] == - 1 ) : NEW_LINE INDENT while ( parent [ j ] == - 1 ) : NEW_LINE INDENT parent [ j ] = i NEW_LINE j = math . gcd ( j , A [ j ] ) % n NEW_LINE DEDENT if ( parent [ j ] == i ) : NEW_LINE INDENT while ( vis [ j ] == 0 ) : NEW_LINE INDENT vis [ j ] = 1 NEW_LINE cnt += 1 NEW_LINE j = math . gcd ( j , A [ j ] ) % n NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def clear ( n ) : NEW_LINE INDENT global lvl , dist1 , dist2 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT lvl [ i ] = 0 NEW_LINE DEDENT maxi = 0 NEW_LINE dist1 [ 0 ] = dist2 [ 0 ] = - 1 NEW_LINE DEDENT
def possiblePositions ( n ) : NEW_LINE INDENT term1 = pow ( n , 4 ) NEW_LINE term2 = pow ( n , 3 ) NEW_LINE term3 = pow ( n , 2 ) NEW_LINE term4 = n / 3 NEW_LINE ans = ( ( math . ceil ( term1 ) ) / 2 - ( math . ceil ( 5 * term2 ) ) / 3 + ( math . ceil ( 3 * term3 ) ) / 2 - term4 ) NEW_LINE return ans NEW_LINE DEDENT
def countSingleRec ( root , count ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return True NEW_LINE DEDENT left = countSingleRec ( root . left , count ) NEW_LINE right = countSingleRec ( root . right , count ) NEW_LINE if left == False or right == False : NEW_LINE INDENT return False NEW_LINE DEDENT if root . left and root . data != root . left . data : NEW_LINE INDENT return False NEW_LINE DEDENT if root . right and root . data != root . right . data : NEW_LINE INDENT return False NEW_LINE DEDENT count [ 0 ] += 1 NEW_LINE return True NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( sys . maxsize - 1 ) NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def modInverse ( n , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT
def CountEvenSumSequences ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT even = i NEW_LINE odd = n - i NEW_LINE if ( odd % 2 == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT tot = ( power ( countOdd ( n ) , odd , M ) * nCrModPFermat ( n , odd , M ) ) % M NEW_LINE tot = ( tot * power ( counteEven ( n ) , i , M ) ) % M NEW_LINE count += tot NEW_LINE count %= M NEW_LINE DEDENT return count NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT  DEDENT
def nextOccurrence ( strr , n , start , ch ) : NEW_LINE INDENT for i in range ( start , n ) : NEW_LINE INDENT if ( strr [ i ] == ch ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def changeToOnes ( string ) : NEW_LINE INDENT ctr = 0 NEW_LINE l = len ( string ) NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( string [ i ] == '1' ) : NEW_LINE INDENT ctr += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return l - ctr NEW_LINE DEDENT
def getCount ( a , n ) : NEW_LINE INDENT gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( gcd , a [ i ] ) NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 1 , gcd + 1 ) : NEW_LINE INDENT if i * i > gcd : NEW_LINE INDENT break NEW_LINE DEDENT if ( gcd % i == 0 ) : NEW_LINE INDENT if ( i * i == gcd ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 2 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def findMissingPositive ( arr , n ) : NEW_LINE INDENT m = 1 NEW_LINE x = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( m < arr [ i ] ) : NEW_LINE INDENT x . append ( arr [ i ] ) NEW_LINE DEDENT elif ( m == arr [ i ] ) : NEW_LINE INDENT m = m + 1 NEW_LINE while ( x . count ( m ) ) : NEW_LINE INDENT x . remove ( m ) NEW_LINE m = m + 1 NEW_LINE DEDENT DEDENT DEDENT return m NEW_LINE DEDENT
def isPalindrome ( str1 , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT if ( str1 [ i ] != str1 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def revereseArray ( arr , n ) : NEW_LINE INDENT rev = n * [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT rev [ n - i - 1 ] = arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = rev [ i ] NEW_LINE DEDENT DEDENT
def _log ( x , base ) : NEW_LINE INDENT return ( int ) ( math . log ( x ) / math . log ( base ) ) NEW_LINE DEDENT
def maximumCut ( arr , K ) : NEW_LINE INDENT low = 0 NEW_LINE high = max ( arr ) NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE chocolate = cal ( arr , mid ) NEW_LINE if chocolate == K : NEW_LINE INDENT return mid NEW_LINE DEDENT elif chocolate < K : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE if mid > high : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT DEDENT return high NEW_LINE DEDENT
def findMissingBinaryString ( nums , N ) : NEW_LINE INDENT s = set ( ) NEW_LINE counter = 0 NEW_LINE for x in nums : NEW_LINE INDENT s . add ( x ) NEW_LINE DEDENT total = int ( pow ( 2 , N ) ) NEW_LINE ans = "" NEW_LINE for i in range ( total ) : NEW_LINE INDENT num = "" NEW_LINE j = N - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT num += '1' NEW_LINE DEDENT else : NEW_LINE INDENT num += '0' NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT if ( num in s ) : NEW_LINE INDENT continue NEW_LINE counter += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( num , end = ", " ) NEW_LINE DEDENT DEDENT if ( counter == total ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def Minimum ( N , K ) : NEW_LINE INDENT sum = N * ( N + 1 ) // 2 NEW_LINE if ( K > sum ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( K <= N ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE count = 0 NEW_LINE while ( N >= 1 and sum < K ) : NEW_LINE INDENT count += 1 NEW_LINE sum += N NEW_LINE N -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def Count ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT sum += i NEW_LINE if ( sum <= K ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def mostFrequent ( arr , N ) : NEW_LINE INDENT ans = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT count = [ 0 ] * N NEW_LINE best = 0 NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT count [ arr [ j ] - 1 ] += 1 NEW_LINE if ( count [ arr [ j ] - 1 ] > count [ best - 1 ] or ( count [ arr [ j ] - 1 ] == count [ best - 1 ] and arr [ j ] < best ) ) : NEW_LINE INDENT best = arr [ j ] NEW_LINE DEDENT ans [ best - 1 ] += 1 NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE DEDENT
def Add_edge ( u , v ) : NEW_LINE INDENT global edges NEW_LINE edges [ u ] . append ( v ) NEW_LINE edges [ v ] . append ( u ) NEW_LINE DEDENT
def minCost ( arr , A , B ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE m = len ( arr [ 0 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < m : NEW_LINE INDENT if ( arr [ i ] [ j ] == '*' ) : NEW_LINE INDENT j += 1 NEW_LINE continue NEW_LINE DEDENT if ( j == m - 1 ) : NEW_LINE INDENT ans += A NEW_LINE DEDENT else : NEW_LINE INDENT if ( arr [ i ] [ j + 1 ] == '.' ) : NEW_LINE INDENT ans += min ( 2 * A , B ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += A NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def binarySeach ( P , N ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( P ) - 1 NEW_LINE index = - 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT mid = i + ( j - i ) // 2 NEW_LINE if ( P [ mid ] >= N ) : NEW_LINE INDENT index = mid NEW_LINE j = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = mid + 1 NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE S = set ( [ ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT S . add ( arr [ i ] ) NEW_LINE DEDENT for ele in S : NEW_LINE INDENT sum = 2 * ele NEW_LINE count += getCountPairs ( arr , N , sum ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def SieveOfEratosthenes ( prime ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT
def printReverse ( sentence ) : NEW_LINE INDENT newlist = [ ] NEW_LINE lis = list ( sentence . split ( ) ) NEW_LINE for i in lis : NEW_LINE INDENT if ( palindrome ( i ) ) : NEW_LINE INDENT newlist . append ( i ) NEW_LINE DEDENT DEDENT newlist . reverse ( ) NEW_LINE j = 0 NEW_LINE for i in range ( len ( lis ) ) : NEW_LINE INDENT if ( palindrome ( lis [ i ] ) ) : NEW_LINE INDENT lis [ i ] = newlist [ j ] NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT for i in lis : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def maximumNumber ( arr , N , K ) : NEW_LINE INDENT minimum = min ( arr ) NEW_LINE ans = minimum + K NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( abs ( arr [ i ] - ans ) > K ) : NEW_LINE INDENT ans = - 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def CountPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( i * j ) == ( arr [ i ] * arr [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def checkGroup ( arr ) : NEW_LINE INDENT if len ( arr ) <= 2 : NEW_LINE INDENT return True NEW_LINE DEDENT corner = arr [ 0 ] + arr [ - 1 ] NEW_LINE xorSum = 0 NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT xorSum += ( arr [ i ] ^ arr [ i + 1 ] ) NEW_LINE DEDENT if not corner : NEW_LINE INDENT if xorSum > 2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif corner == 1 : NEW_LINE INDENT if xorSum > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if xorSum > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isPalindrome ( S , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT if ( S [ i ] != S [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE return True NEW_LINE DEDENT DEDENT
def printLongestPalindrome ( S , N ) : NEW_LINE INDENT palLength = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT maxlength = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( S [ j ] == S [ i ] ) : NEW_LINE INDENT if ( isPalindrome ( S , j , i ) ) : NEW_LINE INDENT maxlength = i - j + 1 NEW_LINE DEDENT break NEW_LINE j = N - 1 NEW_LINE while ( j > i ) : NEW_LINE INDENT if ( S [ j ] == S [ i ] ) : NEW_LINE INDENT if ( isPalindrome ( S , i , j ) ) : NEW_LINE INDENT maxlength = max ( j - i + 1 , maxlength ) NEW_LINE DEDENT break NEW_LINE j -= 1 NEW_LINE palLength [ i ] = maxlength NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( palLength [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def findMaxIntervals ( v , n ) : NEW_LINE INDENT maxi = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = n NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( v [ i ] [ 1 ] < v [ j ] [ 0 ] or v [ i ] [ 0 ] > v [ j ] [ 1 ] ) : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT DEDENT maxi = max ( c , maxi ) NEW_LINE DEDENT print ( maxi ) NEW_LINE DEDENT
def update ( ss , se , si , X , V , tree , arr ) : NEW_LINE INDENT if ( ss == se ) : NEW_LINE INDENT if ( ss == X ) : NEW_LINE INDENT arr [ X ] = V NEW_LINE tree [ si ] = check ( V ) NEW_LINE DEDENT return NEW_LINE DEDENT mid = ( ss + se ) // 2 NEW_LINE if ( X <= mid ) : NEW_LINE INDENT update ( ss , mid , 2 * si + 1 , X , V , tree , arr ) NEW_LINE DEDENT else : NEW_LINE INDENT update ( mid + 1 , se , 2 * si + 2 , X , V , tree , arr ) NEW_LINE DEDENT tree [ si ] = tree [ 2 * si + 1 ] + tree [ 2 * si + 2 ] NEW_LINE DEDENT
def atleast_x ( index , s , e , ql , qr , x ) : NEW_LINE INDENT global Tree NEW_LINE global max NEW_LINE if ( ql > e or qr < s ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( s <= ql and e <= qr ) : NEW_LINE INDENT if ( Tree [ index ] < x ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT while ( s != e ) : NEW_LINE INDENT m = ( s + e ) // 2 NEW_LINE if ( Tree [ 2 * index ] >= x ) : NEW_LINE INDENT e = m NEW_LINE index = 2 * index NEW_LINE DEDENT else : NEW_LINE INDENT s = m + 1 NEW_LINE index = 2 * index + 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT m = ( s + e ) // 2 NEW_LINE val = atleast_x ( 2 * index , s , m , ql , qr , x ) NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT return val NEW_LINE DEDENT return atleast_x ( 2 * index + 1 , m + 1 , e , ql , qr , x ) NEW_LINE DEDENT
def rearrange ( a , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT a = sorted ( a ) NEW_LINE x = n - x NEW_LINE z = a . count ( 0 ) NEW_LINE if ( x > n - z ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if x <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT a [ i ] = - a [ i ] NEW_LINE x -= 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if x <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT if ( a [ i ] > 0 ) : NEW_LINE INDENT a [ i ] = - a [ i ] NEW_LINE x -= 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def countTriplets ( arr , N ) : NEW_LINE INDENT zero_i = [ ] NEW_LINE one_i = [ ] NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT zero_i . append ( i + 1 ) NEW_LINE DEDENT elif ( arr [ i ] == 1 ) : NEW_LINE INDENT one_i . append ( i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i + 1 ] = 1 NEW_LINE DEDENT DEDENT total = len ( zero_i ) * len ( one_i ) * len ( mp ) NEW_LINE for i in range ( len ( zero_i ) ) : NEW_LINE INDENT for j in range ( len ( one_i ) ) : NEW_LINE INDENT p = zero_i [ i ] NEW_LINE q = one_i [ j ] NEW_LINE r = 2 * p - q NEW_LINE if ( r in mp ) : NEW_LINE INDENT total -= 1 NEW_LINE DEDENT r = 2 * q - p NEW_LINE if ( r in mp ) : NEW_LINE INDENT total -= 1 NEW_LINE DEDENT r = ( p + q ) // 2 NEW_LINE if ( ( r in mp ) and abs ( r - p ) == abs ( r - q ) ) : NEW_LINE INDENT total -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( total ) NEW_LINE DEDENT
def Pairs ( N , A , B ) : NEW_LINE INDENT powerA , powerB = 0 , 0 NEW_LINE powerA = power ( A , N ) NEW_LINE powerB = power ( B , N ) NEW_LINE intialB = B NEW_LINE intialA = A NEW_LINE A = 1 NEW_LINE for i in range ( powerA + 1 ) : NEW_LINE INDENT B = 1 NEW_LINE for j in range ( powerB + 1 ) : NEW_LINE INDENT if ( B == N - A ) : NEW_LINE INDENT print ( i , " " , j ) NEW_LINE return NEW_LINE DEDENT B *= intialB NEW_LINE DEDENT A *= intialA NEW_LINE DEDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT
def CountSubarray ( arr , n , k ) : NEW_LINE INDENT temp = k NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == temp ) : NEW_LINE INDENT if ( temp == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE temp = k NEW_LINE DEDENT else : NEW_LINE INDENT temp -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp = k NEW_LINE if ( arr [ i ] == k ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findElement ( arr , N , K ) : NEW_LINE INDENT ele = findElementUtil ( arr , N , K ) NEW_LINE if ( ele == - 1 ) : NEW_LINE INDENT print ( "-1" , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ele ) NEW_LINE DEDENT DEDENT
def findCntTriplet ( N ) : NEW_LINE INDENT cntTriplet = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( N % i != 0 ) : NEW_LINE INDENT cntTriplet += N // i NEW_LINE DEDENT else : NEW_LINE INDENT cntTriplet += ( N // i ) - 1 NEW_LINE DEDENT DEDENT return cntTriplet NEW_LINE DEDENT
def splitString ( S , N ) : NEW_LINE INDENT c = S [ N - 1 ] NEW_LINE f = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( S [ i ] == c ) : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( f ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def minOperations ( arr , n ) : NEW_LINE INDENT flips = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT i += 2 NEW_LINE continue NEW_LINE DEDENT while ( i < n and arr [ i ] % 2 == 0 ) : NEW_LINE INDENT i += 2 NEW_LINE DEDENT flips += 1 NEW_LINE i += 2 NEW_LINE DEDENT i = 1 NEW_LINE while i < n : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT i += 2 NEW_LINE continue NEW_LINE DEDENT while ( i < n and arr [ i ] % 2 == 0 ) : NEW_LINE INDENT i += 2 NEW_LINE DEDENT flips += 1 NEW_LINE i += 2 NEW_LINE DEDENT print ( flips ) NEW_LINE DEDENT
def checkAnswer ( mp , N , K ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if i in mp : NEW_LINE INDENT if ( mp [ i ] == ( N - K + 1 ) ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( - 1 , end = " " ) NEW_LINE DEDENT
def updateAnswerArray ( answer , N ) : NEW_LINE INDENT i = 0 NEW_LINE while ( answer [ i ] == - 1 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT minimum = answer [ i ] NEW_LINE while ( i <= N ) : NEW_LINE INDENT if ( answer [ i ] == - 1 ) : NEW_LINE INDENT answer [ i ] = minimum NEW_LINE DEDENT else : NEW_LINE INDENT answer [ i ] = min ( minimum , answer [ i ] ) NEW_LINE DEDENT minimum = min ( minimum , answer [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def checkString ( X , Y ) : NEW_LINE INDENT L = - 1 NEW_LINE R = - 1 NEW_LINE for i in range ( len ( X ) ) : NEW_LINE INDENT if ( X [ i ] != Y [ i ] ) : NEW_LINE INDENT L = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( len ( X ) - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( X [ i ] != Y [ i ] ) : NEW_LINE INDENT R = i NEW_LINE break NEW_LINE DEDENT DEDENT X = list ( X ) NEW_LINE X = X [ : L ] + X [ R : L - 1 : - 1 ] + X [ R + 1 : ] NEW_LINE if ( X == list ( Y ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def longestLastingBulb ( onTime , s ) : NEW_LINE INDENT n = len ( onTime ) NEW_LINE maxDur = INT_MIN NEW_LINE maxPos = INT_MIN NEW_LINE currentDiff = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT currentDiff = onTime [ i ] NEW_LINE maxDur = currentDiff NEW_LINE maxPos = i NEW_LINE DEDENT else : NEW_LINE INDENT currentDiff = onTime [ i ] - onTime [ i - 1 ] NEW_LINE if ( maxDur < currentDiff ) : NEW_LINE INDENT maxDur = currentDiff NEW_LINE maxPos = i NEW_LINE DEDENT else : NEW_LINE INDENT if ( maxDur == currentDiff ) : NEW_LINE INDENT one = s [ i ] NEW_LINE two = s [ maxPos ] NEW_LINE if ( one > two ) : NEW_LINE INDENT maxDur = currentDiff NEW_LINE maxPos = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT ans = s [ maxPos ] NEW_LINE return ans NEW_LINE DEDENT
def max_freq ( arr , N ) : NEW_LINE INDENT Max = max ( arr ) NEW_LINE Min = min ( arr ) NEW_LINE freq = [ 0 ] * ( Max - Min + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq [ arr [ i ] - Min ] += 1 NEW_LINE DEDENT maxSum = 0 NEW_LINE for i in range ( Max - Min - 1 ) : NEW_LINE INDENT val = freq [ i ] + freq [ i + 1 ] + freq [ i + 2 ] NEW_LINE maxSum = max ( maxSum , val ) NEW_LINE DEDENT print ( maxSum ) NEW_LINE DEDENT
def find_longest_subarray ( A , N , K ) : NEW_LINE INDENT MaxLen = 0 NEW_LINE Len = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( K % A [ i ] == 0 ) : NEW_LINE INDENT Len += 1 NEW_LINE MaxLen = max ( MaxLen , Len ) NEW_LINE DEDENT else : NEW_LINE INDENT Len = 0 NEW_LINE DEDENT DEDENT return MaxLen NEW_LINE DEDENT
def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def kReducingStringUtil ( n , k , str , no_of_zeroes ) : NEW_LINE INDENT zeroes_in_2k = ( ( ( no_of_zeroes ) * ( 2 * k ) ) // n ) NEW_LINE ones_in_2k = 2 * k - zeroes_in_2k NEW_LINE temp_str = "" NEW_LINE for i in range ( 0 , ( zeroes_in_2k ) // 2 ) : NEW_LINE INDENT temp_str += '0' NEW_LINE DEDENT for i in range ( 0 , ( ones_in_2k ) ) : NEW_LINE INDENT temp_str += '1' NEW_LINE DEDENT for i in range ( 0 , ( zeroes_in_2k ) // 2 ) : NEW_LINE INDENT temp_str += '0' NEW_LINE DEDENT final_str = "" NEW_LINE for i in range ( 0 , n // ( 2 * k ) ) : NEW_LINE INDENT final_str += ( temp_str ) NEW_LINE DEDENT for i in range ( 0 , n % ( 2 * k ) ) : NEW_LINE INDENT final_str += ( temp_str [ i ] ) NEW_LINE DEDENT return final_str NEW_LINE DEDENT
def power ( x , N ) : NEW_LINE INDENT res = 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N & 1 ) : NEW_LINE INDENT res = ( res * x ) NEW_LINE DEDENT x = ( x * x ) NEW_LINE N = N >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countRemovableElem ( arr , N ) : NEW_LINE INDENT hash = [ 0 ] * ( N + 1 ) NEW_LINE mex = N + 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] <= N ) : NEW_LINE INDENT hash [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( hash [ i ] == 0 ) : NEW_LINE INDENT mex = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( N - ( mex - 1 ) ) NEW_LINE DEDENT
def findMaxPoints ( arr , n ) : NEW_LINE INDENT ans = findMaxPoint ( arr , 0 , n ) NEW_LINE if ( ans [ 0 ] == INF ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "(" , ans [ 0 ] , " " , ans [ 1 ] , ")" ) NEW_LINE DEDENT DEDENT
def numberOfGP ( L , N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT res += count NEW_LINE DEDENT return res NEW_LINE DEDENT
def palindrome ( a , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT if ( a [ i ] != a [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def countGreater ( arr , N ) : NEW_LINE INDENT St = set ( ) NEW_LINE countLeftGreater = [ 0 ] * ( N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT St . add ( arr [ i ] ) NEW_LINE it = 0 NEW_LINE for st in St : NEW_LINE INDENT if ( arr [ i ] < st ) : NEW_LINE INDENT break NEW_LINE DEDENT it += 1 NEW_LINE DEDENT countLeftGreater [ i ] = abs ( it - len ( St ) ) NEW_LINE DEDENT display ( countLeftGreater , N ) NEW_LINE DEDENT
def key ( N ) : NEW_LINE INDENT num = "" + str ( N ) NEW_LINE ans = 0 NEW_LINE j = 0 NEW_LINE while j < len ( num ) : NEW_LINE INDENT if ( ( ord ( num [ j ] ) - 48 ) % 2 == 0 ) : NEW_LINE INDENT add = 0 NEW_LINE i = j NEW_LINE while j < len ( num ) : NEW_LINE INDENT add += ord ( num [ j ] ) - 48 NEW_LINE if ( add % 2 == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( add == 0 ) : NEW_LINE INDENT ans *= 10 NEW_LINE DEDENT else : NEW_LINE INDENT digit = int ( math . floor ( math . log10 ( add ) + 1 ) ) NEW_LINE ans *= ( pow ( 10 , digit ) ) NEW_LINE ans += add NEW_LINE DEDENT i = j NEW_LINE DEDENT else : NEW_LINE INDENT add = 0 NEW_LINE i = j NEW_LINE while j < len ( num ) : NEW_LINE INDENT add += ord ( num [ j ] ) - 48 NEW_LINE if ( add % 2 == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( add == 0 ) : NEW_LINE INDENT ans *= 10 NEW_LINE DEDENT else : NEW_LINE INDENT digit = int ( math . floor ( math . log10 ( add ) + 1 ) ) NEW_LINE ans *= ( pow ( 10 , digit ) ) NEW_LINE ans += add NEW_LINE DEDENT i = j NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j + 1 ) >= len ( num ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT ans += ord ( num [ len ( num ) - 1 ] ) - 48 NEW_LINE return ans NEW_LINE DEDENT DEDENT
def longDelSub ( str1 , str2 ) : NEW_LINE INDENT N = len ( str1 ) NEW_LINE M = len ( str2 ) NEW_LINE prev_pos = 0 NEW_LINE pos = [ 0 ] * M NEW_LINE for i in range ( M ) : NEW_LINE INDENT index = prev_pos NEW_LINE while ( index < N and str1 [ index ] != str2 [ i ] ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT pos [ i ] = index NEW_LINE prev_pos = index + 1 NEW_LINE DEDENT res = N - prev_pos NEW_LINE prev_pos = N - 1 NEW_LINE for i in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT index = prev_pos NEW_LINE while ( index >= 0 and str1 [ index ] != str2 [ i ] ) : NEW_LINE INDENT index -= 1 NEW_LINE DEDENT if ( i != 0 ) : NEW_LINE INDENT res = max ( res , index - pos [ i - 1 ] - 1 ) NEW_LINE DEDENT prev_pos = index - 1 NEW_LINE DEDENT res = max ( res , prev_pos + 1 ) NEW_LINE return res NEW_LINE DEDENT
def countSubArray ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT i = max_element ( arr ) NEW_LINE j = min_element ( arr ) NEW_LINE if ( i > j ) : NEW_LINE INDENT tmp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = tmp NEW_LINE DEDENT return ( i + 1 ) * ( n - j ) NEW_LINE DEDENT
def isPerfectSquare ( n ) : NEW_LINE INDENT sr = sqrt ( n ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT
def updateFreq ( n , freq ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT digit = n % TEN NEW_LINE freq [ digit ] += 1 NEW_LINE n //= TEN NEW_LINE DEDENT DEDENT
def count_numbers ( L , R ) : NEW_LINE INDENT ans = 0 NEW_LINE LogR = ( int ) ( math . log ( R ) + 1 ) NEW_LINE for zero_bit in range ( LogR ) : NEW_LINE INDENT cur = 0 NEW_LINE for j in range ( zero_bit ) : NEW_LINE INDENT cur |= ( 1 << j ) NEW_LINE DEDENT for j in range ( zero_bit + 1 , LogR ) : NEW_LINE INDENT cur |= ( 1 << j ) NEW_LINE if ( cur >= L and cur <= R ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def maxGCD ( n ) : NEW_LINE INDENT return ( n // 2 ) NEW_LINE DEDENT
def updateTree ( st , pos , s ) : NEW_LINE INDENT index = pos NEW_LINE update_BITree ( index , st [ index ] , - 1 ) NEW_LINE st . replace ( st [ index ] , s , 1 ) NEW_LINE update_BITree ( index , s , 1 ) NEW_LINE DEDENT
def minServerLoads ( n , servers ) : NEW_LINE INDENT totalLoad = sum ( servers ) NEW_LINE requiredLoad = totalLoad // 2 NEW_LINE dp = [ [ 0 for col in range ( requiredLoad + 1 ) ] for row in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , requiredLoad + 1 ) : NEW_LINE INDENT if servers [ i - 1 ] > j : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , servers [ i - 1 ] + dp [ i - 1 ] [ j - servers [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT return totalLoad - 2 * dp [ n ] [ requiredLoad ] NEW_LINE DEDENT
def maxLength ( arr ) : NEW_LINE INDENT lenn = - sys . maxsize - 1 NEW_LINE N = len ( arr ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT l = len ( arr [ i ] ) NEW_LINE if ( lenn < l ) : NEW_LINE INDENT lenn = l NEW_LINE DEDENT DEDENT return lenn NEW_LINE DEDENT
def dfs ( node ) : NEW_LINE INDENT global cc NEW_LINE vis [ node ] = True NEW_LINE for x in vec [ node ] : NEW_LINE INDENT if ( vis [ x ] == 0 ) : NEW_LINE INDENT cc += 1 NEW_LINE dfs ( x ) NEW_LINE DEDENT DEDENT DEDENT
def solve ( D , N , X , Y ) : NEW_LINE INDENT T = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = D [ i ] [ 0 ] NEW_LINE y = D [ i ] [ 1 ] NEW_LINE speed = D [ i ] [ 2 ] NEW_LINE time = ( ( x * x - X * X ) + ( y * y - Y * Y ) ) / ( speed * speed ) NEW_LINE T . append ( time ) NEW_LINE DEDENT T . sort ( ) NEW_LINE i = 0 NEW_LINE total = 0 NEW_LINE while i < len ( T ) - 1 : NEW_LINE INDENT count = 1 NEW_LINE while i < len ( T ) - 1 and T [ i ] == T [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT total += ( count * ( count - 1 ) ) / 2 NEW_LINE i += 1 NEW_LINE DEDENT return total NEW_LINE DEDENT
def findSubarrays ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE freq = [ 0 ] * ( n + 1 ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT if ( count == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT value = count NEW_LINE for j in range ( 1 , count + 1 ) : NEW_LINE INDENT freq [ j ] += value NEW_LINE value -= 1 NEW_LINE DEDENT count = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > 0 ) : NEW_LINE INDENT value = count NEW_LINE for j in range ( 1 , count + 1 ) : NEW_LINE INDENT freq [ j ] += value NEW_LINE value -= 1 NEW_LINE DEDENT DEDENT return freq NEW_LINE DEDENT
def sumOfIndices ( s ) : NEW_LINE INDENT N = len ( s ) NEW_LINE x = ( int ) ( math . ceil ( math . log ( N ) / math . log ( 2 ) ) ) NEW_LINE seg_size = 2 * pow ( 2 , x ) - 1 NEW_LINE segment = [ 0 ] * ( seg_size ) NEW_LINE count = 4 NEW_LINE fre = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT key = ( ord ) ( s [ i ] ) NEW_LINE if key in fre : NEW_LINE INDENT que = fre [ key ] NEW_LINE DEDENT else : NEW_LINE INDENT que = collections . deque ( [ ] ) NEW_LINE DEDENT que . append ( i ) NEW_LINE fre [ key ] = que NEW_LINE DEDENT while len ( fre ) > 0 : NEW_LINE INDENT it = list ( fre . keys ( ) ) [ 0 ] NEW_LINE if len ( fre [ it ] ) == 0 : NEW_LINE INDENT del fre [ it ] NEW_LINE DEDENT else : NEW_LINE INDENT que = fre [ it ] NEW_LINE original_index = que [ 0 ] NEW_LINE curr_index = deleted ( segment , 0 , original_index - 1 , 0 , N - 1 , 0 ) NEW_LINE new_index = original_index - curr_index NEW_LINE count += new_index + 1 NEW_LINE add_seg ( segment , 0 , N - 1 , 0 , original_index ) NEW_LINE que . popleft ( ) NEW_LINE fre [ it ] = que NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def maxLength ( n , m ) : NEW_LINE INDENT sieve ( ) NEW_LINE smallestPrimeFactors ( ) NEW_LINE ans = - sys . maxsize - 1 NEW_LINE for i in range ( n , m + 1 ) : NEW_LINE INDENT if ( i == 4 ) : NEW_LINE INDENT continue NEW_LINE DEDENT ans = max ( ans , findLength ( i ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def getMax ( st , n , l , r ) : NEW_LINE INDENT if ( l < 0 or r > n - 1 or l > r ) : NEW_LINE INDENT print ( "Invalid Input" ) NEW_LINE return - 1 NEW_LINE DEDENT return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) NEW_LINE DEDENT
def subArraylen ( arr , n , K ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE mp [ arr [ 0 ] ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] + arr [ i - 1 ] NEW_LINE mp [ arr [ i ] ] = i NEW_LINE DEDENT ln = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < K ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT x = K - arr [ i ] NEW_LINE if ( x == 0 ) : NEW_LINE INDENT ln = min ( ln , i ) NEW_LINE DEDENT if ( x in mp . keys ( ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT ln = min ( ln , i - mp [ x ] ) NEW_LINE DEDENT DEDENT DEDENT return ln NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT g = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] > 0 and g == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( arr [ i ] - arr [ i ] < 0 ) : NEW_LINE INDENT g = 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def addedge ( node1 , node2 ) : NEW_LINE INDENT G [ node1 ] += [ node2 ] NEW_LINE G [ node2 ] += [ node1 ] NEW_LINE DEDENT
def countElements ( arr , n , k ) : NEW_LINE INDENT s = [ ] NEW_LINE next_greater = [ n ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT s . append ( i ) NEW_LINE continue NEW_LINE DEDENT while ( len ( s ) != 0 and arr [ s [ - 1 ] ] < arr [ i ] ) : NEW_LINE INDENT next_greater [ s [ - 1 ] ] = i NEW_LINE s . pop ( - 1 ) NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT count = 0 NEW_LINE maxi = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( next_greater [ i ] - i > k and maxi < arr [ i ] ) : NEW_LINE INDENT maxi = max ( maxi , arr [ i ] ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def addEdge ( u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT
def constructTree ( n , edges ) : NEW_LINE INDENT adjl = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT adjl . append ( [ ] ) NEW_LINE DEDENT for i in range ( len ( edges ) ) : NEW_LINE INDENT u = edges [ i ] [ 0 ] NEW_LINE v = edges [ i ] [ 1 ] NEW_LINE adjl [ u ] . append ( v ) NEW_LINE adjl [ v ] . append ( u ) NEW_LINE DEDENT return adjl NEW_LINE DEDENT
def min_remove ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ j ] - arr [ i ] <= k ) : NEW_LINE INDENT ans = min ( ans , n - j + i - 1 ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // __gcd ( a , b ) NEW_LINE DEDENT
def countPair ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( __gcd ( i , j ) + lcm ( i , j ) == N ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT if ( c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def countSubstrings ( s , n ) : NEW_LINE INDENT temp = [ 1 , 0 ] NEW_LINE result = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += ( 1 if isVowel ( s [ i ] ) else 0 ) NEW_LINE sum %= 2 NEW_LINE temp [ sum ] += 1 NEW_LINE DEDENT result += ( ( temp [ 0 ] * ( temp [ 0 ] - 1 ) ) // 2 ) NEW_LINE result += ( ( temp [ 1 ] * ( temp [ 1 ] - 1 ) ) // 2 ) NEW_LINE print ( result ) NEW_LINE DEDENT
def minOperations ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE pos = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT pos = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( pos == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT last = 1 NEW_LINE ans = 1 NEW_LINE for i in range ( pos + 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT if ( last == 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE last = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( last == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE last = 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def checkBitonic ( arr , n ) : NEW_LINE INDENT i , j , f = 0 , 0 , 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] < arr [ j - 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT if ( f == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def isNudeNum ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE copy = n NEW_LINE temp = str ( copy ) NEW_LINE length = len ( temp ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT num = ord ( temp [ i ] ) - ord ( '0' ) NEW_LINE if ( ( num == 0 ) or ( n % num != 0 ) ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def get_subminarr ( arr , n , y ) : NEW_LINE INDENT j = 0 NEW_LINE stk = [ ] NEW_LINE minarr = [ 0 ] * n NEW_LINE stk . append ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( stk and arr [ i ] < arr [ stk [ - 1 ] ] ) : NEW_LINE INDENT minarr [ stk [ - 1 ] ] = i NEW_LINE stk . pop ( ) NEW_LINE DEDENT stk . append ( i ) NEW_LINE DEDENT while ( stk ) : NEW_LINE INDENT minarr [ stk [ - 1 ] ] = n NEW_LINE stk . pop ( ) NEW_LINE DEDENT submin = [ ] NEW_LINE for i in range ( n - y + 1 ) : NEW_LINE INDENT while ( minarr [ j ] <= i + y - 1 or j < i ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT submin . append ( arr [ j ] ) NEW_LINE DEDENT return submin NEW_LINE DEDENT
def PrintSequence ( freq , n ) : NEW_LINE INDENT sequence = generateSequence ( freq , n ) NEW_LINE if ( len ( sequence ) == 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( len ( sequence ) ) : NEW_LINE INDENT print ( sequence [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def checkArray ( A , B , N ) : NEW_LINE INDENT start = 0 NEW_LINE end = N - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] != B [ i ] ) : NEW_LINE INDENT start = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( A [ i ] != B [ i ] ) : NEW_LINE INDENT end = i NEW_LINE break NEW_LINE DEDENT DEDENT A [ start : end + 1 ] = reversed ( A [ start : end + 1 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] != B [ i ] ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "Yes" ) NEW_LINE DEDENT
def longestSubarray ( a , n ) : NEW_LINE INDENT l = [ 0 ] * ( n ) NEW_LINE r = [ 0 ] * ( n ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT l [ i ] = count NEW_LINE count = 0 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r [ i ] = count NEW_LINE count = 0 NEW_LINE DEDENT DEDENT ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT ans = max ( ans , l [ i ] + r [ i ] ) NEW_LINE DEDENT DEDENT return ans < 0 and n or ans NEW_LINE DEDENT
def solve ( n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( j * j > n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % j == 0 ) : NEW_LINE INDENT if ( j <= k ) : NEW_LINE INDENT ans = max ( ans , j ) NEW_LINE DEDENT if ( n // j <= k ) : NEW_LINE INDENT ans = max ( ans , n // j ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def splitArray ( arr , N ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE result = 10 ** 9 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT result = min ( result , arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def countTriplets ( a , n , x ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE temp . append ( a [ i ] ) NEW_LINE temp . append ( a [ j ] ) NEW_LINE temp . append ( a [ k ] ) NEW_LINE temp . sort ( ) NEW_LINE if ( temp [ 0 ] < temp [ 1 ] and temp [ 1 ] < temp [ 2 ] and temp [ 0 ] * temp [ 1 ] * temp [ 2 ] <= x ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT
def fibonacci ( ) : NEW_LINE INDENT global fib NEW_LINE global MAX NEW_LINE prev = 0 NEW_LINE curr = 1 NEW_LINE l = 2 NEW_LINE fib . add ( prev ) NEW_LINE fib . add ( curr ) NEW_LINE while ( l <= MAX ) : NEW_LINE INDENT temp = curr + prev NEW_LINE fib . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE l += 1 NEW_LINE DEDENT DEDENT
def xorOfSum ( a , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT answer ^= ( a [ i ] + a [ j ] ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def createHash ( hash1 , maxElement ) : NEW_LINE INDENT prev , curr = 0 , 1 NEW_LINE hash1 . add ( prev ) NEW_LINE hash1 . add ( curr ) NEW_LINE while ( curr < maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash1 . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT
def state8 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == 'c' ) : NEW_LINE INDENT nfa = 9 NEW_LINE DEDENT elif ( c == 'b' or c == 'a' ) : NEW_LINE INDENT nfa = 8 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT
def maxSum ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE DEDENT curr_sum = res NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - k ] NEW_LINE res = max ( res , curr_sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def isDigit ( ch ) : NEW_LINE INDENT ch = ord ( ch ) NEW_LINE if ( ch >= ord ( '0' ) and ch <= ord ( '9' ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def nextPosition ( tempGCD , startPointer , prevEndPointer , n ) : NEW_LINE INDENT high = n - 1 NEW_LINE low = prevEndPointer NEW_LINE mid = prevEndPointer NEW_LINE nextPos = prevEndPointer NEW_LINE while ( high >= low ) : NEW_LINE INDENT mid = ( ( high + low ) >> 1 ) NEW_LINE if ( queryForGCD ( startPointer , mid ) == tempGCD ) : NEW_LINE INDENT nextPos = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return nextPos + 1 NEW_LINE DEDENT
def gcd ( A , B ) : NEW_LINE INDENT if ( B == 0 ) : NEW_LINE INDENT return A NEW_LINE DEDENT return gcd ( B , A % B ) NEW_LINE DEDENT
def farthest_min ( a , n ) : NEW_LINE INDENT suffix_min = [ 0 for i in range ( n ) ] NEW_LINE suffix_min [ n - 1 ] = a [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffix_min [ i ] = min ( suffix_min [ i + 1 ] , a [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT low = i + 1 NEW_LINE high = n - 1 NEW_LINE ans = - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( suffix_min [ mid ] < a [ i ] ) : NEW_LINE INDENT ans = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT print ( ans , end = " " ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def solve ( array , n , K ) : NEW_LINE INDENT end = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE DEDENT while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( check ( mid , array , n , K ) ) : NEW_LINE INDENT answer = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def isPossible ( box , truck , n , m , min_time ) : NEW_LINE INDENT temp = 0 NEW_LINE count = 0 NEW_LINE while ( count < m ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < min_time and temp < n and truck [ count ] >= box [ temp ] ) : NEW_LINE INDENT temp += 1 NEW_LINE j += 2 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT if ( temp == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def solve ( interval , N , Q ) : NEW_LINE INDENT Mark = [ 0 for i in range ( Q ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT l = interval [ i ] [ 0 ] - 1 NEW_LINE r = interval [ i ] [ 1 ] - 1 NEW_LINE for j in range ( l , r + 1 ) : NEW_LINE INDENT Mark [ j ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( Q ) : NEW_LINE INDENT if ( Mark [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT count1 = [ 0 for i in range ( Q ) ] NEW_LINE if ( Mark [ 0 ] == 1 ) : NEW_LINE INDENT count1 [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , Q ) : NEW_LINE INDENT if ( Mark [ i ] == 1 ) : NEW_LINE INDENT count1 [ i ] = count1 [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 [ i ] = count1 [ i - 1 ] NEW_LINE DEDENT DEDENT maxindex = 0 NEW_LINE maxcoverage = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT l = interval [ i ] [ 0 ] - 1 NEW_LINE r = interval [ i ] [ 1 ] - 1 NEW_LINE elem1 = 0 NEW_LINE if ( l != 0 ) : NEW_LINE INDENT elem1 = count1 [ r ] - count1 [ l - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT elem1 = count1 [ r ] NEW_LINE DEDENT if ( count - elem1 >= maxcoverage ) : NEW_LINE INDENT maxcoverage = count - elem1 NEW_LINE maxindex = i NEW_LINE DEDENT DEDENT print ( "Maximum Coverage is" , maxcoverage , "after removing interval at index" , maxindex ) NEW_LINE DEDENT
def maxSum ( arr , n , K ) : NEW_LINE INDENT maximum = - 2 ** 32 NEW_LINE sum = [ 0 ] * n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i + K < n ) : NEW_LINE INDENT sum [ i ] = sum [ i + K ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum [ i ] = arr [ i ] NEW_LINE DEDENT maximum = max ( maximum , sum [ i ] ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
def countGreater ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE leftGreater = n NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = int ( l + ( r - l ) / 2 ) NEW_LINE if ( arr [ m ] > k ) : NEW_LINE INDENT leftGreater = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return ( n - leftGreater ) NEW_LINE DEDENT
def countFactor ( P , X ) : NEW_LINE INDENT if ( X < P ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( X // P + countFactor ( P , X // P ) ) NEW_LINE DEDENT
def squareSum ( N ) : NEW_LINE INDENT Sum = ( N * ( N + 1 ) * ( 2 * N + 1 ) ) // 6 NEW_LINE return Sum NEW_LINE DEDENT
def countPattern ( n , pat ) : NEW_LINE INDENT pattern_int = 0 NEW_LINE power_two = 1 NEW_LINE all_ones = 0 NEW_LINE i = len ( pat ) - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT current_bit = ord ( pat [ i ] ) - ord ( '0' ) NEW_LINE pattern_int += ( power_two * current_bit ) NEW_LINE all_ones = all_ones + power_two NEW_LINE power_two = power_two * 2 NEW_LINE i -= 1 NEW_LINE DEDENT count = 0 NEW_LINE while ( n != 0 and n >= pattern_int ) : NEW_LINE INDENT if ( ( n & all_ones ) == pattern_int ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def getMax ( arr , n ) : NEW_LINE INDENT res = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res = max ( res , arr [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def printDuplicates ( arr , n ) : NEW_LINE INDENT fl = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] >= n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] < 2 * n ) : NEW_LINE INDENT print ( arr [ i ] % n , end = " " ) NEW_LINE fl = 1 NEW_LINE DEDENT DEDENT arr [ arr [ i ] % n ] += n NEW_LINE DEDENT if ( fl == 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE x = ( arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ) NEW_LINE y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] NEW_LINE z = ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ) NEW_LINE return max ( x , max ( y , z ) ) NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT maxA = - sys . maxsize - 1 NEW_LINE maxB = - sys . maxsize - 1 NEW_LINE maxC = - sys . maxsize - 1 NEW_LINE maxD = - sys . maxsize - 1 NEW_LINE minA = sys . maxsize NEW_LINE minB = sys . maxsize NEW_LINE minC = sys . maxsize NEW_LINE minD = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > maxA ) : NEW_LINE INDENT maxD = maxC NEW_LINE maxC = maxB NEW_LINE maxB = maxA NEW_LINE maxA = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxB ) : NEW_LINE INDENT maxD = maxC NEW_LINE maxC = maxB NEW_LINE maxB = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxC ) : NEW_LINE INDENT maxD = maxC NEW_LINE maxC = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxD ) : NEW_LINE INDENT maxD = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < minA ) : NEW_LINE INDENT minD = minC NEW_LINE minC = minB NEW_LINE minB = minA NEW_LINE minA = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < minB ) : NEW_LINE INDENT minD = minC NEW_LINE minC = minB NEW_LINE minB = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < minC ) : NEW_LINE INDENT minD = minC NEW_LINE minC = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < minD ) : NEW_LINE INDENT minD = arr [ i ] NEW_LINE DEDENT DEDENT x = maxA * maxB * maxC * maxD NEW_LINE y = minA * minB * minC * minD NEW_LINE z = minA * minB * maxA * maxB NEW_LINE return max ( x , max ( y , z ) ) NEW_LINE DEDENT
def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT
def isPossible ( arr , n , m , curr_min ) : NEW_LINE INDENT studentsRequired = 1 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > curr_min ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( curr_sum + arr [ i ] > curr_min ) : NEW_LINE INDENT studentsRequired += 1 NEW_LINE curr_sum = arr [ i ] NEW_LINE if ( studentsRequired > m ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def sortArray ( arr , N ) : NEW_LINE INDENT i = 0 NEW_LINE j = N - 1 NEW_LINE mid = 0 NEW_LINE while ( mid <= j ) : NEW_LINE INDENT if ( arr [ mid ] == 0 ) : NEW_LINE INDENT arr [ i ] , arr [ mid ] = arr [ mid ] , arr [ i ] NEW_LINE i += 1 NEW_LINE mid += 1 NEW_LINE DEDENT elif ( arr [ mid ] == 3 ) : NEW_LINE INDENT arr [ mid ] , arr [ j ] = arr [ j ] , arr [ mid ] NEW_LINE j -= 1 NEW_LINE DEDENT elif ( arr [ mid ] == 1 or arr [ mid ] == 2 ) : NEW_LINE INDENT mid += 1 NEW_LINE DEDENT DEDENT while ( i <= j ) : NEW_LINE INDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def isSorted ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] > arr [ i - 1 ] [ 0 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isSortedArray ( arr , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = ( n - 1 ) NEW_LINE while ( ( l + 1 ) < r ) : NEW_LINE INDENT if ( arr [ l ] >= max ( arr [ l + 1 ] , arr [ r - 1 ] ) and arr [ r ] >= max ( arr [ r - 1 ] , arr [ l + 1 ] ) ) : NEW_LINE INDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findMaxNumbers ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT opr = math . ceil ( math . log2 ( arr [ i ] ) ) NEW_LINE k -= opr NEW_LINE if ( k < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT
def rearrange ( A , B , N , X ) : NEW_LINE INDENT flag = True NEW_LINE A = sorted ( A ) NEW_LINE B = sorted ( B ) [ : : - 1 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] + B [ i ] > X ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def getMinCost ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE min_cost = 0 NEW_LINE X = 0 NEW_LINE for i in range ( 0 , n , k ) : NEW_LINE INDENT for j in range ( i , n , 1 ) : NEW_LINE INDENT if ( j < i + k ) : NEW_LINE INDENT min_cost += arr [ j ] * ( X + 1 ) NEW_LINE DEDENT DEDENT X += 1 NEW_LINE DEDENT return min_cost NEW_LINE DEDENT
def mergeSortUtil ( arr , temp , l , r , K ) : NEW_LINE INDENT cnt = 0 NEW_LINE if ( l < r ) : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE cnt += mergeSortUtil ( arr , temp , l , m , K ) NEW_LINE cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) NEW_LINE cnt += merge ( arr , temp , l , m , r , K ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def Bubble_Sort ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , n - i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ j + 1 ] ) : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE DEDENT DEDENT DEDENT return arr NEW_LINE DEDENT
def mostvisitedsector ( N , A ) : NEW_LINE INDENT maxVisited = 0 NEW_LINE mp = { } NEW_LINE for i in range ( 0 , len ( A ) - 1 ) : NEW_LINE INDENT start = A [ i ] % N NEW_LINE end = A [ i + 1 ] % N NEW_LINE while ( start != end ) : NEW_LINE INDENT if ( start == 0 ) : NEW_LINE INDENT if N in mp : NEW_LINE INDENT mp [ N ] = mp [ N ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ N ] = 1 NEW_LINE DEDENT if ( mp [ N ] > maxVisited ) : NEW_LINE INDENT maxVisited = mp [ N ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if start in mp : NEW_LINE INDENT mp [ start ] = mp [ start ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ start ] = 1 NEW_LINE DEDENT if ( mp [ start ] > maxVisited ) : NEW_LINE INDENT maxVisited = mp [ start ] NEW_LINE DEDENT DEDENT start = ( start + 1 ) % N NEW_LINE DEDENT DEDENT if A [ - 1 ] in mp : NEW_LINE INDENT mp [ A [ - 1 ] ] = mp [ A [ - 1 ] ] + 1 NEW_LINE DEDENT if ( mp [ A [ - 1 ] ] > maxVisited ) : NEW_LINE INDENT maxVisited = mp [ A [ - 1 ] ] NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] == maxVisited ) : NEW_LINE INDENT print ( x , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT
def maxRectangle ( sequence , size ) : NEW_LINE INDENT X_Cord = [ 0 ] * size NEW_LINE Y_Cord = [ 0 ] * size NEW_LINE for i in range ( size ) : NEW_LINE INDENT X_Cord [ i ] = sequence [ i ] [ 0 ] NEW_LINE Y_Cord [ i ] = sequence [ i ] [ 1 ] NEW_LINE DEDENT X_Cord . sort ( ) NEW_LINE Y_Cord . sort ( ) NEW_LINE X_Max = 0 NEW_LINE Y_Max = 0 NEW_LINE for i in range ( size - 1 ) : NEW_LINE INDENT X_Max = max ( X_Max , X_Cord [ i + 1 ] - X_Cord [ i ] ) NEW_LINE Y_Max = max ( Y_Max , Y_Cord [ i + 1 ] - Y_Cord [ i ] ) NEW_LINE DEDENT return X_Max * Y_Max NEW_LINE DEDENT
def evenSumK ( arr , N , K ) : NEW_LINE INDENT if ( K > N ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT maxSum = 0 NEW_LINE Even = [ ] NEW_LINE Odd = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT Odd . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT Even . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT Odd . sort ( reverse = False ) NEW_LINE Even . sort ( reverse = False ) NEW_LINE i = len ( Even ) - 1 NEW_LINE j = len ( Odd ) - 1 NEW_LINE while ( K > 0 ) : NEW_LINE INDENT if ( K % 2 == 1 ) : NEW_LINE INDENT if ( i >= 0 ) : NEW_LINE INDENT maxSum += Even [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT K -= 1 NEW_LINE DEDENT elif ( i >= 1 and j >= 1 ) : NEW_LINE INDENT if ( Even [ i ] + Even [ i - 1 ] <= Odd [ j ] + Odd [ j - 1 ] ) : NEW_LINE INDENT maxSum += Odd [ j ] + Odd [ j - 1 ] NEW_LINE j -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT maxSum += Even [ i ] + Even [ i - 1 ] NEW_LINE i -= 2 NEW_LINE DEDENT K -= 2 NEW_LINE DEDENT elif ( i >= 1 ) : NEW_LINE INDENT maxSum += Even [ i ] + Even [ i - 1 ] NEW_LINE i -= 2 NEW_LINE K -= 2 NEW_LINE DEDENT elif ( j >= 1 ) : NEW_LINE INDENT maxSum += Odd [ j ] + Odd [ j - 1 ] NEW_LINE j -= 2 NEW_LINE K -= 2 NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT
def find_mth_bitUtil ( n , m ) : NEW_LINE INDENT fib = [ 0 for i in range ( maxN ) ] NEW_LINE calculateFib ( fib , maxN ) NEW_LINE ans = find_mth_bit ( n , m , fib ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def range_sum ( arr , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( a - 2 < 0 ) : NEW_LINE INDENT sum = arr [ b - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT sum = ( arr [ b - 1 ] - arr [ a - 2 ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def XorSum ( A , B , N ) : NEW_LINE INDENT maxBit = 29 NEW_LINE ans = 0 NEW_LINE for k in range ( maxBit ) : NEW_LINE INDENT C = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT C [ i ] = B [ i ] % ( 1 << ( k + 1 ) ) NEW_LINE DEDENT C = sorted ( C ) NEW_LINE count = 0 NEW_LINE l , r = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = A [ i ] % ( 1 << ( k + 1 ) ) NEW_LINE l = bisect_left ( C , ( 1 << k ) - x ) NEW_LINE r = bisect_left ( C , ( 1 << k ) * 2 - x ) NEW_LINE count += ( r - l ) NEW_LINE l = bisect_left ( C , ( 1 << k ) * 3 - x ) NEW_LINE r = bisect_left ( C , ( 1 << k ) * 4 - x ) NEW_LINE count += ( r - l ) NEW_LINE DEDENT if ( count & 1 ) : NEW_LINE INDENT ans += ( 1 << k ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE count = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in count : NEW_LINE INDENT ans += count [ arr [ i ] ] NEW_LINE DEDENT if arr [ i ] in count : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def getAlphaScore ( node ) : NEW_LINE INDENT global sum NEW_LINE global total_sum NEW_LINE if node . left != None : NEW_LINE INDENT getAlphaScore ( node . left ) NEW_LINE DEDENT sum = ( sum + node . data ) % mod NEW_LINE total_sum = ( total_sum + sum ) % mod NEW_LINE if node . right != None : NEW_LINE INDENT getAlphaScore ( node . right ) NEW_LINE DEDENT return total_sum NEW_LINE DEDENT
def sortArr ( a , n ) : NEW_LINE INDENT k = int ( math . log ( n , 2 ) ) NEW_LINE k = int ( pow ( 2 , k ) ) NEW_LINE while ( k > 0 ) : NEW_LINE INDENT i = 0 NEW_LINE while i + k < n : NEW_LINE INDENT if a [ i ] > a [ i + k ] : NEW_LINE INDENT a [ i ] , a [ i + k ] = a [ i + k ] , a [ i ] NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT k = k // 2 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def maximizeval10 ( a , n , k ) : NEW_LINE INDENT increments = 0 NEW_LINE ans = 0 NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += ( a [ i ] // 10 ) NEW_LINE if ( a [ i ] == 1000 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( 10 - a [ i ] % 10 ) NEW_LINE increments += ( 100 - ( ( a [ i ] ) // 10 ) - 1 ) NEW_LINE DEDENT DEDENT v . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT sum += v [ i ] NEW_LINE if ( sum <= k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( sum < k ) : NEW_LINE INDENT remaining = k - sum NEW_LINE ans += min ( increments , remaining // 10 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def number ( a , n , p , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE pre = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre . append ( 0 ) NEW_LINE DEDENT ans = 0 NEW_LINE val = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE if pre [ 0 ] <= p : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT for i in range ( 1 , k - 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i ] NEW_LINE if pre [ i ] <= p : NEW_LINE INDENT ans = i + 1 NEW_LINE DEDENT DEDENT pre [ k - 1 ] = a [ k - 1 ] NEW_LINE for i in range ( k - 1 , n ) : NEW_LINE INDENT if i >= k : NEW_LINE INDENT pre [ i ] += pre [ i - k ] + a [ i ] NEW_LINE DEDENT if pre [ i ] <= p : NEW_LINE INDENT ans = i + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findK ( arr , size , N ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE temp_sum = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT temp_sum += arr [ i ] NEW_LINE if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findSum ( arr , n , k , l , r ) : NEW_LINE INDENT if ( ( l ) + ( n - 1 - r ) == k ) : NEW_LINE INDENT return arr [ r ] - arr [ l ] NEW_LINE DEDENT if ( vis [ l ] [ r ] ) : NEW_LINE INDENT return dp [ l ] [ r ] NEW_LINE DEDENT vis [ l ] [ r ] = 1 NEW_LINE dp [ l ] [ r ] = min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) NEW_LINE return dp [ l ] [ r ] NEW_LINE DEDENT
def printList ( node ) : NEW_LINE INDENT last = None NEW_LINE while ( node != None ) : NEW_LINE INDENT print ( node . data , end = " " ) NEW_LINE last = node NEW_LINE node = node . next NEW_LINE DEDENT DEDENT
def Removal ( v , n ) : NEW_LINE INDENT v = sorted ( v ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT j = upper_bound ( v , ( 2 * ( a [ i ] ) ) ) NEW_LINE ans = min ( ans , n - ( j - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def printArrangement ( a , n ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE b = [ 0 for i in range ( n ) ] NEW_LINE low = 0 NEW_LINE high = n - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT b [ low ] = a [ i ] NEW_LINE low += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ high ] = a [ i ] NEW_LINE high -= 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( b [ n - 1 ] + b [ 1 ] <= b [ i ] ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT DEDENT elif ( i == ( n - 1 ) ) : NEW_LINE INDENT if ( b [ n - 2 ] + b [ 0 ] <= b [ i ] ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b [ i - 1 ] + b [ i + 1 ] <= b [ i ] ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def K_multiple ( a , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] % k == 0 and a [ i ] // k not in s ) or a [ i ] % k != 0 ) : NEW_LINE INDENT s . add ( a [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def powmod ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT pt = powmod ( a , int ( n / 2 ) ) NEW_LINE pt = ( pt * pt ) % mod NEW_LINE if ( n % 2 ) : NEW_LINE INDENT return ( pt * a ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return pt NEW_LINE DEDENT DEDENT
def product ( a , n , k ) : NEW_LINE INDENT ans = 1 NEW_LINE a . sort ( reverse = False ) NEW_LINE powa = C [ n - 1 ] [ k - 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT powla = C [ i ] [ k - 1 ] NEW_LINE powfa = C [ n - i - 1 ] [ k - 1 ] NEW_LINE powe = ( ( powa % MOD ) - ( powla + powfa ) % MOD + MOD ) % MOD NEW_LINE mul = power ( a [ i ] , powe ) % MOD NEW_LINE ans = ( ( ans % MOD ) * ( mul % MOD ) ) % MOD NEW_LINE DEDENT return ans % MOD NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s = '' . join ( sorted ( s ) ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ord ( s [ i ] ) - ord ( s [ i - 1 ] ) != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def printNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE A , B = arr [ n - 1 ] , - 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if A % arr [ i ] != 0 : NEW_LINE INDENT B = arr [ i ] NEW_LINE break NEW_LINE DEDENT if i - 1 >= 0 and arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT B = arr [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( "A =" , A , ", B =" , B ) NEW_LINE DEDENT
def findNonPalinString ( s ) : NEW_LINE INDENT freq = [ 0 ] * ( 26 ) NEW_LINE flag = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ 0 ] : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT freq [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT if not flag : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT for j in range ( 0 , freq [ i ] ) : NEW_LINE INDENT print ( chr ( ord ( 'a' ) + i ) , end = "" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT res += 1 NEW_LINE i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def minSubarray ( A , n ) : NEW_LINE INDENT minValue = min ( A ) NEW_LINE maxValue = max ( A ) NEW_LINE pos_min , pos_max , ans = - 1 , - 1 , sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if A [ i ] == minValue : NEW_LINE INDENT pos_min = i NEW_LINE DEDENT if A [ i ] == maxValue : NEW_LINE INDENT pos_max = i NEW_LINE DEDENT if pos_max != - 1 and pos_min != - 1 : NEW_LINE INDENT ans = min ( ans , abs ( pos_min - pos_max ) + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countTriplets ( head , x ) : NEW_LINE INDENT ptr , ptr1 , ptr2 = None , None , None NEW_LINE count = 0 NEW_LINE um = { } NEW_LINE ptr = head NEW_LINE while ptr != None : NEW_LINE INDENT um [ ptr . data ] = ptr NEW_LINE ptr = ptr . next NEW_LINE DEDENT ptr1 = head NEW_LINE while ptr1 != None : NEW_LINE INDENT ptr2 = ptr1 . next NEW_LINE while ptr2 != None : NEW_LINE INDENT p_product = ( ptr1 . data * ptr2 . data ) NEW_LINE if ( ( x / p_product ) in um and ( x / p_product ) != ptr1 and um [ x / p_product ] != ptr2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT ptr2 = ptr2 . next NEW_LINE DEDENT ptr1 = ptr1 . next NEW_LINE DEDENT return ( count // 3 ) NEW_LINE DEDENT
def countTriplets ( arr , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for end in range ( n - 1 , 1 , - 1 ) : NEW_LINE INDENT start = 0 NEW_LINE mid = end - 1 NEW_LINE while ( start < mid ) : NEW_LINE INDENT prod = ( arr [ end ] * arr [ start ] * arr [ mid ] ) NEW_LINE if ( prod > m ) : NEW_LINE INDENT mid -= 1 NEW_LINE DEDENT elif ( prod < m ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT elif ( prod == m ) : NEW_LINE INDENT count += 1 NEW_LINE mid -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countTripletsLessThan ( arr , n , val ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT j = i + 1 NEW_LINE k = n - 1 NEW_LINE while j != k : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] + arr [ k ] NEW_LINE if sum > val : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( k - j ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def MaxSumDifference ( a , n ) : NEW_LINE INDENT np . sort ( a ) NEW_LINE j = 0 NEW_LINE finalSequence = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT finalSequence [ j ] = a [ i ] NEW_LINE finalSequence [ j + 1 ] = a [ n - i - 1 ] NEW_LINE j = j + 2 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT finalSequence [ n - 1 ] = a [ n // 2 + 1 ] NEW_LINE DEDENT MaximumSum = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT MaximumSum = ( MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ) NEW_LINE DEDENT MaximumSum = ( MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ) NEW_LINE print ( MaximumSum ) NEW_LINE DEDENT
def findMinimum ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while ( n ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE n = n - k NEW_LINE i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def minSwapToReachArr ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] - 1 ) - i > 2 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT numOfInversion = mergeSort ( arr , N ) NEW_LINE return numOfInversion NEW_LINE DEDENT
def getIndexInSortedArray ( arr , n , idx ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ idx ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT if ( arr [ i ] == arr [ idx ] and i < idx ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def gnomeSort ( arr , n ) : NEW_LINE INDENT index = 0 NEW_LINE while index < n : NEW_LINE INDENT if index == 0 : NEW_LINE INDENT index = index + 1 NEW_LINE DEDENT if arr [ index ] >= arr [ index - 1 ] : NEW_LINE INDENT index = index + 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ] NEW_LINE index = index - 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT
def flip ( arr , i ) : NEW_LINE INDENT start = 0 NEW_LINE while start < i : NEW_LINE INDENT temp = arr [ start ] NEW_LINE arr [ start ] = arr [ i ] NEW_LINE arr [ i ] = temp NEW_LINE start += 1 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT
def possible ( x , S , N ) : NEW_LINE INDENT minSum = ( x * ( x + 1 ) ) // 2 NEW_LINE maxSum = ( x * ( ( 2 * N ) - x + 1 ) ) // 2 NEW_LINE if ( S < minSum or S > maxSum ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def TotalPerfectPowerSum ( L , R ) : NEW_LINE INDENT pows = [ ] NEW_LINE pows . append ( 0 ) NEW_LINE pows . append ( 1 ) NEW_LINE for p in range ( 2 , 25 ) : NEW_LINE INDENT num = 2 NEW_LINE while ( ( int ) ( pow ( num , p ) + 0.5 ) <= R ) : NEW_LINE INDENT pows . append ( ( int ) ( pow ( num , p ) + 0.5 ) ) NEW_LINE num = num + 1 NEW_LINE DEDENT DEDENT ok = [ 0 for _ in range ( R + 1 ) ] NEW_LINE for i in range ( 0 , int ( len ( pows ) ) ) : NEW_LINE INDENT for j in range ( 0 , len ( pows ) ) : NEW_LINE INDENT if ( pows [ i ] + pows [ j ] <= R and pows [ i ] + pows [ j ] >= L ) : NEW_LINE INDENT ok [ pows [ i ] + pows [ j ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , R + 1 ) : NEW_LINE INDENT ok [ i ] += ok [ i - 1 ] NEW_LINE DEDENT return ok [ R ] - ok [ L - 1 ] NEW_LINE DEDENT
def KthSolution ( X , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if not ( X & ( 1 << i ) ) : NEW_LINE INDENT if ( K & 1 ) : NEW_LINE INDENT ans |= ( 1 << i ) NEW_LINE DEDENT K >>= 1 NEW_LINE if not K : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countNoOfsuchX ( N ) : NEW_LINE INDENT k = len ( str ( N ) ) NEW_LINE count = 0 NEW_LINE for x in range ( N - k * ( k + 1 ) * 5 , N + 1 ) : NEW_LINE INDENT if check ( x , N ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countArrays ( n , k ) : NEW_LINE INDENT divisors = [ [ ] for i in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 , 1 ) : NEW_LINE INDENT for j in range ( 2 * i , k + 1 , i ) : NEW_LINE INDENT divisors [ j ] . append ( i ) NEW_LINE DEDENT DEDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for j in range ( 1 , k + 1 , 1 ) : NEW_LINE INDENT dp [ 1 ] [ j ] = 1 NEW_LINE DEDENT for x in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( 1 , k + 1 , 1 ) : NEW_LINE INDENT sum += dp [ x - 1 ] [ j ] NEW_LINE DEDENT for y in range ( 1 , k + 1 , 1 ) : NEW_LINE INDENT dp [ x ] [ y ] = sum NEW_LINE for d in divisors [ y ] : NEW_LINE INDENT dp [ x ] [ y ] = ( dp [ x ] [ y ] - dp [ x - 1 ] [ d ] ) NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for j in range ( 1 , k + 1 , 1 ) : NEW_LINE INDENT sum += dp [ n ] [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def checkStar ( mat ) : NEW_LINE INDENT global size NEW_LINE vertexD1 = 0 NEW_LINE vertexDn_1 = 0 NEW_LINE if ( size == 1 ) : NEW_LINE INDENT return ( mat [ 0 ] [ 0 ] == 0 ) NEW_LINE DEDENT if ( size == 2 ) : NEW_LINE INDENT return ( mat [ 0 ] [ 0 ] == 0 and mat [ 0 ] [ 1 ] == 1 and mat [ 1 ] [ 0 ] == 1 and mat [ 1 ] [ 1 ] == 0 ) NEW_LINE DEDENT for i in range ( 0 , size ) : NEW_LINE INDENT degreeI = 0 NEW_LINE for j in range ( 0 , size ) : NEW_LINE INDENT if ( mat [ i ] [ j ] ) : NEW_LINE INDENT degreeI = degreeI + 1 NEW_LINE DEDENT DEDENT if ( degreeI == 1 ) : NEW_LINE INDENT vertexD1 = vertexD1 + 1 NEW_LINE DEDENT elif ( degreeI == size - 1 ) : NEW_LINE INDENT vertexDn_1 = vertexDn_1 + 1 NEW_LINE DEDENT DEDENT return ( vertexD1 == ( size - 1 ) and vertexDn_1 == 1 ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def convertXintoY ( X , Y ) : NEW_LINE INDENT while ( Y > X ) : NEW_LINE INDENT if ( Y % 2 == 0 ) : NEW_LINE INDENT Y //= 2 NEW_LINE DEDENT elif ( Y % 10 == 1 ) : NEW_LINE INDENT Y //= 10 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( X == Y ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def MaxXOR ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT res |= arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def countCandies ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE ans = [ 1 ] * n NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] > arr [ i ] and ans [ i + 1 ] <= ans [ i ] ) : NEW_LINE INDENT ans [ i + 1 ] = ans [ i ] + 1 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] and ans [ i ] <= ans [ i + 1 ] ) : NEW_LINE INDENT ans [ i ] = ans [ i + 1 ] + 1 NEW_LINE DEDENT elif ( arr [ i ] == arr [ i + 1 ] and ans [ i ] < ans [ i + 1 ] ) : NEW_LINE INDENT ans [ i ] = ans [ i + 1 ] + 1 NEW_LINE DEDENT sum += ans [ i ] NEW_LINE DEDENT sum += ans [ n - 1 ] NEW_LINE return sum NEW_LINE DEDENT
def findMinOperations ( arr , N , K ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT freq = { } NEW_LINE for j in range ( i , N , K ) : NEW_LINE INDENT if arr [ j ] in freq : NEW_LINE INDENT freq [ arr [ j ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ arr [ j ] ] = 1 NEW_LINE DEDENT DEDENT max1 = 0 NEW_LINE num = 0 NEW_LINE for key , value in freq . items ( ) : NEW_LINE INDENT if ( value > max1 ) : NEW_LINE INDENT max1 = value NEW_LINE num = key NEW_LINE DEDENT DEDENT for key , value in freq . items ( ) : NEW_LINE INDENT if ( key != num ) : NEW_LINE INDENT operations += value NEW_LINE DEDENT DEDENT DEDENT print ( operations ) NEW_LINE DEDENT
def minSizeArr ( A , N , K ) : NEW_LINE INDENT leftTaken = N NEW_LINE rightTaken = N NEW_LINE leftSum = 0 NEW_LINE rightSum = 0 NEW_LINE for left in range ( - 1 , N ) : NEW_LINE INDENT if ( left != - 1 ) : NEW_LINE INDENT leftSum += A [ left ] NEW_LINE DEDENT rightSum = 0 NEW_LINE for right in range ( N - 1 , left , - 1 ) : NEW_LINE INDENT rightSum += A [ right ] NEW_LINE if ( leftSum + rightSum == K ) : NEW_LINE INDENT if ( leftTaken + rightTaken > ( left + 1 ) + ( N - right ) ) : NEW_LINE INDENT leftTaken = left + 1 NEW_LINE rightTaken = N - right NEW_LINE DEDENT break NEW_LINE DEDENT if ( leftSum + rightSum > K ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( leftTaken + rightTaken <= N ) : NEW_LINE INDENT for i in range ( leftTaken ) : NEW_LINE INDENT print ( A [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( rightTaken ) : NEW_LINE INDENT print ( A [ N - i - 1 ] , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def is_prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def consecutive_primes ( n ) : NEW_LINE INDENT first = - 1 NEW_LINE second = - 1 NEW_LINE i = int ( sqrt ( n ) ) NEW_LINE while ( i >= 2 ) : NEW_LINE INDENT if ( is_prime ( i ) ) : NEW_LINE INDENT first = i NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( int ( sqrt ( n ) ) + 1 , n // 2 + 1 , 1 ) : NEW_LINE INDENT if ( is_prime ( i ) ) : NEW_LINE INDENT second = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( first * second >= n ) : NEW_LINE INDENT print ( first , second ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( second + 1 , n + 1 , 1 ) : NEW_LINE INDENT if ( is_prime ( i ) ) : NEW_LINE INDENT print ( second , i ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT
def arrayBitwiseAND ( size ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT temp = prefixCount [ i ] [ size - 1 ] NEW_LINE if ( temp == size ) : NEW_LINE INDENT result = ( result | ( 1 << i ) ) NEW_LINE DEDENT DEDENT print ( result , end = " " ) NEW_LINE DEDENT
def findbitwiseAND ( queries , arr , N , M ) : NEW_LINE INDENT findPrefixCount ( arr , N ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT id = queries [ i ] [ 0 ] NEW_LINE newVal = queries [ i ] [ 1 ] NEW_LINE currentVal = arr [ id ] NEW_LINE arr [ id ] = newVal NEW_LINE applyQuery ( currentVal , newVal , N ) NEW_LINE arrayBitwiseAND ( N ) NEW_LINE DEDENT DEDENT
def stepscount ( a , b ) : NEW_LINE INDENT chance_A = 2 * a - 1 NEW_LINE chance_B = 2 * b NEW_LINE if ( chance_A < chance_B ) : NEW_LINE INDENT return 'B' NEW_LINE DEDENT else : NEW_LINE INDENT return "A" NEW_LINE DEDENT DEDENT
def checkpoint ( h , k , x , y , a , b ) : NEW_LINE INDENT p = ( ( pow ( ( x - h ) , 2 ) // pow ( a , 2 ) ) - ( pow ( ( y - k ) , 2 ) // pow ( b , 2 ) ) ) NEW_LINE if ( p > 1 ) : NEW_LINE INDENT print ( "Outside" ) NEW_LINE DEDENT elif ( p == 1 ) : NEW_LINE INDENT print ( "On the Hyperbola" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Inside" ) NEW_LINE DEDENT DEDENT
def rotateString ( n , m , s ) : NEW_LINE INDENT v = [ ] NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( 1 , len ( v ) ) : NEW_LINE INDENT if ( ( v [ i ] - v [ i - 1 ] - 1 ) > m ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( len ( v ) >= 2 and ( n - ( v [ - 1 ] - v [ 0 ] ) - 1 ) > m ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( cnt <= 1 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def findNumber ( N ) : NEW_LINE INDENT ans = [ 1 , 2 , 4 , 8 , 7 , 5 ] NEW_LINE return ans [ N % 6 ] NEW_LINE DEDENT
def countDecrements ( arr ) : NEW_LINE INDENT count_1 = 0 NEW_LINE count_2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT if ( 1 - ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) : NEW_LINE INDENT count_2 += 1 NEW_LINE DEDENT DEDENT DEDENT print ( min ( count_1 , count_2 ) ) NEW_LINE DEDENT
def maximumIndex ( N , B ) : NEW_LINE INDENT i , j = 0 , 1 NEW_LINE cnt = 0 NEW_LINE sum = N * ( N + 1 ) // 2 NEW_LINE flag = False NEW_LINE while ( cnt < N ) : NEW_LINE INDENT i += j NEW_LINE j += 1 NEW_LINE cnt += 1 NEW_LINE if ( i == B ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not flag ) : NEW_LINE INDENT print ( sum ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sum - 1 ) NEW_LINE DEDENT DEDENT
def sumOfDigits ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT sum += N % 10 NEW_LINE N //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def distIntegers ( L , R ) : NEW_LINE INDENT return 2 * R - 2 * L + 1 NEW_LINE DEDENT
def maximumNum ( X , Y , N ) : NEW_LINE INDENT num = 0 NEW_LINE if ( N - N % X + Y <= N ) : NEW_LINE INDENT num = N - N % X + Y NEW_LINE DEDENT else : NEW_LINE INDENT num = N - N % X - ( X - Y ) NEW_LINE DEDENT return num NEW_LINE DEDENT
def findKthElement ( N , K ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT print ( v [ K - 1 ] ) NEW_LINE DEDENT
def printLargestDivisible ( arr , N ) : NEW_LINE INDENT count0 = 0 NEW_LINE count7 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count7 += 1 NEW_LINE DEDENT DEDENT if ( count7 % 50 == 0 ) : NEW_LINE INDENT while ( count7 ) : NEW_LINE INDENT count7 -= 1 NEW_LINE print ( 7 , end = "" ) NEW_LINE DEDENT while ( count0 ) : NEW_LINE INDENT count0 -= 1 NEW_LINE print ( count0 , end = "" ) NEW_LINE DEDENT DEDENT elif ( count7 < 5 ) : NEW_LINE INDENT if ( count0 == 0 ) : NEW_LINE INDENT print ( "No" , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = "" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT count7 = count7 - count7 % 5 NEW_LINE while ( count7 ) : NEW_LINE INDENT count7 -= 1 NEW_LINE print ( 7 , end = "" ) NEW_LINE DEDENT while ( count0 ) : NEW_LINE INDENT count0 -= 1 NEW_LINE print ( 0 , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def minimumStepReqArr ( arr , N ) : NEW_LINE INDENT cntStep = 0 NEW_LINE N += 1 NEW_LINE i = 31 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( N & ( 1 << i ) ) : NEW_LINE INDENT cntStep += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return cntStep NEW_LINE DEDENT
def minOpsToEmptyString ( S , N ) : NEW_LINE INDENT one = 0 NEW_LINE zero = 0 NEW_LINE x0 = 0 NEW_LINE x1 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT x0 += 1 NEW_LINE x1 = 0 NEW_LINE DEDENT else : NEW_LINE INDENT x1 += 1 NEW_LINE x0 = 0 NEW_LINE DEDENT zero = max ( x0 , zero ) NEW_LINE one = max ( x1 , one ) NEW_LINE DEDENT print ( max ( one , zero ) ) NEW_LINE DEDENT
def findMaxValByRearrArr ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 0 NEW_LINE while ( True ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT Sum += __gcd ( i + 1 , arr [ i ] ) NEW_LINE DEDENT res = max ( res , Sum ) NEW_LINE if ( not next_permutation ( arr ) ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def cntKnightsAttackPawn ( knights , pawn , M ) : NEW_LINE INDENT cntKnights = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT X = abs ( knights [ i ] [ 0 ] - pawn [ 0 ] ) NEW_LINE Y = abs ( knights [ i ] [ 1 ] - pawn [ 1 ] ) NEW_LINE if ( ( X == 1 and Y == 2 ) or ( X == 2 and Y == 1 ) ) : NEW_LINE INDENT cntKnights += 1 NEW_LINE DEDENT DEDENT return cntKnights NEW_LINE DEDENT
def findXOR ( n ) : NEW_LINE INDENT if ( n % 4 == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT elif ( n % 4 == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n % 4 == 2 ) : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT elif ( n % 4 == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def findMinimumTime ( p , n , target ) : NEW_LINE INDENT um = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT um [ p [ i ] ] = um . get ( p [ i ] , 0 ) + 1 NEW_LINE DEDENT time = 0 NEW_LINE sum = 0 NEW_LINE while ( sum < target ) : NEW_LINE INDENT sum = 0 NEW_LINE time += 1 NEW_LINE for it in um : NEW_LINE INDENT sum += um [ it ] * ( time // it ) NEW_LINE DEDENT DEDENT print ( time ) NEW_LINE DEDENT
def isSequenceValid ( B , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( ( i + 1 ) % B [ i ] != 0 ) : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "Yes" ) NEW_LINE DEDENT
def Remove_one_element ( arr , n ) : NEW_LINE INDENT post_odd = 0 NEW_LINE post_even = 0 NEW_LINE curr_odd = 0 NEW_LINE curr_even = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i % 2 ) : NEW_LINE INDENT post_odd ^= arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT post_even ^= arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i % 2 ) : NEW_LINE INDENT post_odd ^= arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT post_even ^= arr [ i ] NEW_LINE DEDENT X = curr_odd ^ post_even NEW_LINE Y = curr_even ^ post_odd NEW_LINE if ( X == Y ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( i % 2 ) : NEW_LINE INDENT curr_odd ^= arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT curr_even ^= arr [ i ] NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def findLongestNonDecreasing ( A , N ) : NEW_LINE INDENT res = 0 NEW_LINE start = 0 NEW_LINE end = N - 1 NEW_LINE prev = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT if ( A [ start ] <= A [ end ] ) : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT prev = A [ start ] NEW_LINE res += 1 NEW_LINE start += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( A [ start ] >= prev ) : NEW_LINE INDENT res += 1 NEW_LINE prev = A [ start ] NEW_LINE start += 1 NEW_LINE DEDENT elif ( A [ end ] >= prev ) : NEW_LINE INDENT res += 1 NEW_LINE prev = A [ end ] NEW_LINE end -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT prev = A [ end ] NEW_LINE res += 1 NEW_LINE end -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( A [ end ] >= prev ) : NEW_LINE INDENT res += 1 NEW_LINE prev = A [ end ] NEW_LINE end -= 1 NEW_LINE DEDENT elif ( A [ start ] >= prev ) : NEW_LINE INDENT res += 1 NEW_LINE prev = A [ start ] NEW_LINE start += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT cntPairs = 0 NEW_LINE mp = { } NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for freq in mp : NEW_LINE INDENT cntPairs += int ( ( mp [ freq ] * ( mp [ freq ] - 1 ) ) / 2 ) NEW_LINE DEDENT return cntPairs NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def minAbsDiff ( N ) : NEW_LINE INDENT sumSet1 = 0 NEW_LINE sumSet2 = 0 NEW_LINE for i in reversed ( range ( N + 1 ) ) : NEW_LINE INDENT if sumSet1 <= sumSet2 : NEW_LINE INDENT sumSet1 = sumSet1 + i NEW_LINE DEDENT else : NEW_LINE INDENT sumSet2 = sumSet2 + i NEW_LINE DEDENT return abs ( sumSet1 - sumSet2 ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT oneCount = 0 NEW_LINE desiredPair = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT oneCount += 1 NEW_LINE DEDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT desiredPair += oneCount NEW_LINE DEDENT DEDENT return desiredPair NEW_LINE DEDENT
def TotalNumber ( N ) : NEW_LINE INDENT ans = ( power ( 10 , N ) - 2 * power ( 9 , N ) + power ( 8 , N ) + 2 * mod ) % mod NEW_LINE return ans NEW_LINE DEDENT
def minLength ( A , N ) : NEW_LINE INDENT elem = A [ 0 ] NEW_LINE count = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( A [ i ] == elem ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( count == N ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT
def NegEqu ( N , X , Y ) : NEW_LINE INDENT while ( X and N > N // 2 + 10 ) : NEW_LINE INDENT N = N // 2 + 10 NEW_LINE X -= 1 NEW_LINE DEDENT while ( Y ) : NEW_LINE INDENT N = N - 10 NEW_LINE Y -= 1 NEW_LINE DEDENT if ( N <= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def minSubarrays ( arr , n ) : NEW_LINE INDENT right = n - 1 NEW_LINE left = 0 NEW_LINE subarrays = 0 NEW_LINE while ( right >= 0 ) : NEW_LINE INDENT for left in range ( right + 1 ) : NEW_LINE INDENT if ( gcd ( arr [ left ] , arr [ right ] ) > 1 ) : NEW_LINE INDENT subarrays += 1 NEW_LINE right = left - 1 NEW_LINE break NEW_LINE DEDENT if ( left == right and __gcd ( arr [ left ] , arr [ right ] ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return subarrays NEW_LINE DEDENT
def check ( arr , N ) : NEW_LINE INDENT f = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( f == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def no_of_flips ( n ) : NEW_LINE INDENT ln = check_length ( n ) NEW_LINE ans = 0 NEW_LINE right = 1 NEW_LINE left = ln NEW_LINE while ( right < left ) : NEW_LINE INDENT if ( check_ith_bit ( n , right ) != check_ith_bit ( n , left ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT left -= 1 NEW_LINE right += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def find_max ( v , n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n >= 2 ) : NEW_LINE INDENT count = 2 NEW_LINE DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( v [ i - 1 ] [ 0 ] > ( v [ i ] [ 0 ] + v [ i ] [ 1 ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif ( v [ i + 1 ] [ 0 ] > ( v [ i ] [ 0 ] + v [ i ] [ 1 ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE v [ i ] [ 0 ] = v [ i ] [ 0 ] + v [ i ] [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def createString ( N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( 'a' , end = '' ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( 'b' , end = '' ) NEW_LINE DEDENT DEDENT
def maxSubsequences ( arr , n ) -> int : NEW_LINE INDENT m = defaultdict ( int ) NEW_LINE maxCount = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] in m . keys ( ) : NEW_LINE INDENT count = m [ arr [ i ] ] NEW_LINE if count > 1 : NEW_LINE INDENT m [ arr [ i ] ] = count - 1 NEW_LINE DEDENT else : NEW_LINE INDENT m . pop ( arr [ i ] ) NEW_LINE DEDENT if arr [ i ] - 1 > 0 : NEW_LINE INDENT m [ arr [ i ] - 1 ] += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxCount += 1 NEW_LINE DEDENT maxCount += 1 NEW_LINE if arr [ i ] - 1 > 0 : NEW_LINE INDENT m [ arr [ i ] - 1 ] += 1 NEW_LINE DEDENT DEDENT return maxCount NEW_LINE DEDENT
def sumOfFactors ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT first = i NEW_LINE last = ( N // i ) * i NEW_LINE factors = ( last - first ) // i + 1 NEW_LINE totalContribution = ( ( ( factors * ( factors + 1 ) ) // 2 ) * i ) NEW_LINE ans += totalContribution NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findShifts ( A , N ) : NEW_LINE INDENT shift = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == A [ i ] - 1 ) : NEW_LINE INDENT shift [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT shift [ i ] = ( A [ i ] - 1 - i + N ) % N NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( shift [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def possible ( N , a , b , n ) : NEW_LINE INDENT sum_of_angle = 180 * ( N - 2 ) NEW_LINE Total_angle = ( N * ( ( 2 * a ) + ( N - 1 ) * b ) ) / 2 NEW_LINE if ( sum_of_angle != Total_angle ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def splitIntoFibonacciHelper ( pos , S , seq ) : NEW_LINE INDENT if ( pos == len ( S ) and ( len ( seq ) >= 3 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT num = 0 NEW_LINE for i in range ( pos , len ( S ) ) : NEW_LINE INDENT num = num * 10 + ( ord ( S [ i ] ) - ord ( '0' ) ) NEW_LINE if ( num > sys . maxsize ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( ord ( S [ pos ] ) == ord ( '0' ) and i > pos ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( len ( seq ) > 2 and ( num > ( seq [ - 1 ] + seq [ len ( seq ) - 2 ] ) ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( len ( seq ) < 2 or ( num == ( seq [ - 1 ] + seq [ len ( seq ) - 2 ] ) ) ) : NEW_LINE INDENT seq . append ( num ) NEW_LINE if ( splitIntoFibonacciHelper ( i + 1 , S , seq ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT seq . pop ( ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def good_pairs ( Str , N ) : NEW_LINE INDENT arr = [ 0 for i in range ( 32 ) ] NEW_LINE strCount = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT Weight = 0 NEW_LINE for j in range ( len ( Str [ i ] ) ) : NEW_LINE INDENT switcher = { 'a' : 1 , 'e' : 2 , 'i' : 4 , 'o' : 8 , 'u' : 16 , } NEW_LINE Weight = Weight | switcher . get ( Str [ i ] [ j ] , 0 ) NEW_LINE DEDENT arr [ Weight ] += 1 NEW_LINE DEDENT for i in range ( 32 ) : NEW_LINE INDENT for j in range ( i + 1 , 32 ) : NEW_LINE INDENT if ( ( i j ) == 31 ) : NEW_LINE INDENT strCount += arr [ i ] * arr [ j ] NEW_LINE DEDENT DEDENT DEDENT strCount += int ( ( arr [ 31 ] * ( arr [ 31 ] - 1 ) ) / 2 ) NEW_LINE return strCount NEW_LINE DEDENT
def countUniqueDigits ( N ) : NEW_LINE INDENT res = 0 NEW_LINE cnt = [ 0 ] * 10 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT rem = N % 10 NEW_LINE cnt [ rem ] += 1 NEW_LINE N = N // 10 NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT if ( cnt [ i ] == 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def DFS ( node , parent ) : NEW_LINE INDENT answer [ node ] = val [ node ] NEW_LINE for child in v [ node ] : NEW_LINE INDENT if ( child == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT DFS ( child , node ) NEW_LINE answer [ node ] = gcd ( answer [ node ] , answer [ child ] ) NEW_LINE DEDENT DEDENT
def count_triangles ( a , b , c , d ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( a , b + 1 ) : NEW_LINE INDENT num_greater_than_d = ( max ( d , c + x ) - max ( d , b + x - 1 ) ) NEW_LINE ans = ( ans + num_greater_than_d * ( d - c + 1 ) ) NEW_LINE r = min ( max ( c , c + x ) , d ) - c NEW_LINE l = min ( max ( c , b + x - 1 ) , d ) - c NEW_LINE x1 = int ( ( r * ( r + 1 ) ) / 2 ) NEW_LINE x2 = int ( ( l * ( l + 1 ) ) / 2 ) NEW_LINE ans = ans + ( x1 - x2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxRemainingSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT i = 0 NEW_LINE j = n - 1 NEW_LINE result = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT sum -= arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT result += sum NEW_LINE DEDENT return result NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < n - i ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def minOperations ( a , b , n ) : NEW_LINE INDENT minA = min ( a ) NEW_LINE for x in range ( minA , - 1 , - 1 ) : NEW_LINE INDENT check = True NEW_LINE operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( x % b [ i ] == a [ i ] % b [ i ] ) : NEW_LINE INDENT operations += ( a [ i ] - x ) / b [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT check = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( check ) : NEW_LINE INDENT return operations NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def largestNum ( n ) : NEW_LINE INDENT num = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT x = ( 1 << i ) NEW_LINE if ( ( x - 1 ) <= n ) : NEW_LINE INDENT num = ( 1 << i ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT
def digit_xor ( x ) : NEW_LINE INDENT xorr = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT xorr ^= x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return xorr NEW_LINE DEDENT
def maxSum ( a , n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += a [ i ] NEW_LINE DEDENT X = maxSubArraySum ( a , n ) NEW_LINE return 2 * X - S NEW_LINE DEDENT
def Transform ( n , d , steps ) : NEW_LINE INDENT global min_val NEW_LINE global min_steps NEW_LINE if ( n < min_val ) : NEW_LINE INDENT min_val = n NEW_LINE min_steps = steps NEW_LINE DEDENT elif ( n == min_val ) : NEW_LINE INDENT min_steps = min ( min_steps , steps ) NEW_LINE DEDENT if ( steps < 15 ) : NEW_LINE INDENT Transform ( sumOfDigits ( n ) , d , steps + 1 ) NEW_LINE Transform ( n + d , d , steps + 1 ) NEW_LINE DEDENT DEDENT
def addEdge ( adj , u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT
def minCost ( cost , n ) : NEW_LINE INDENT totalCost = 0 NEW_LINE boardingBus = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( cost [ boardingBus ] > cost [ i ] ) : NEW_LINE INDENT totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) NEW_LINE boardingBus = i NEW_LINE DEDENT DEDENT totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) NEW_LINE return totalCost NEW_LINE DEDENT
def findK ( n , k ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT pos = n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT pos = ( n // 2 ) + 1 NEW_LINE DEDENT if ( k <= pos ) : NEW_LINE INDENT return ( k * 2 - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( k - pos ) * 2 ) NEW_LINE DEDENT DEDENT
def max_bitwise_or ( L , R ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE v3 = [ ] NEW_LINE z = 0 NEW_LINE i = 0 NEW_LINE ans = 0 NEW_LINE cnt = 1 NEW_LINE while ( L > 0 ) : NEW_LINE INDENT v1 . append ( L % 2 ) NEW_LINE L = L // 2 NEW_LINE DEDENT while ( R > 0 ) : NEW_LINE INDENT v2 . append ( R % 2 ) NEW_LINE R = R // 2 NEW_LINE DEDENT while ( len ( v1 ) != len ( v2 ) ) : NEW_LINE INDENT v1 . append ( 0 ) NEW_LINE DEDENT for i in range ( len ( v2 ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( v2 [ i ] == 1 and v1 [ i ] == 0 and z == 0 ) : NEW_LINE INDENT z = 1 NEW_LINE continue NEW_LINE DEDENT if ( z == 1 ) : NEW_LINE INDENT v1 [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( len ( v2 ) ) : NEW_LINE INDENT v3 . append ( v2 [ i ] v1 [ i ] ) NEW_LINE DEDENT for i in range ( len ( v2 ) ) : NEW_LINE INDENT if ( v3 [ i ] == 1 ) : NEW_LINE INDENT ans += cnt NEW_LINE DEDENT cnt *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def ncr ( n , r , mod ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT res = ( res * ( n - i + 1 ) ) % mod NEW_LINE inv = power ( i , mod - 2 , mod ) NEW_LINE res = ( res * inv ) % mod NEW_LINE DEDENT return ( res % mod ) NEW_LINE DEDENT
def solve ( Array , N ) : NEW_LINE INDENT pos = [ [ ] for i in range ( 5 ) ] NEW_LINE pref = [ 0 for i in range ( 5 ) ] NEW_LINE if ( Array [ 0 ] == 0 ) : NEW_LINE INDENT pref [ 0 ] = 1 NEW_LINE pos [ 0 ] . append ( 0 ) NEW_LINE DEDENT ans = MAX_INT NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( Array [ i ] == 0 ) : NEW_LINE INDENT pref [ 0 ] += 1 NEW_LINE pos [ 0 ] . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( pref [ Array [ i ] - 1 ] > 0 ) : NEW_LINE INDENT pref [ Array [ i ] ] += 1 NEW_LINE pos [ Array [ i ] ] . append ( i ) NEW_LINE if ( Array [ i ] == 4 ) : NEW_LINE INDENT end = i NEW_LINE start = i NEW_LINE for j in range ( 3 , - 1 , - 1 ) : NEW_LINE INDENT s = 0 NEW_LINE e = len ( pos [ j ] ) - 1 NEW_LINE temp = - 1 NEW_LINE while ( s <= e ) : NEW_LINE INDENT m = ( s + e ) // 2 NEW_LINE if ( pos [ j ] [ m ] <= start ) : NEW_LINE INDENT temp = pos [ j ] [ m ] NEW_LINE s = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT e = m - 1 NEW_LINE DEDENT DEDENT start = temp NEW_LINE DEDENT ans = min ( ans , end - start + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def solve ( X , A ) : NEW_LINE INDENT minimum = sys . maxsize NEW_LINE ind = - 1 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] < minimum ) : NEW_LINE INDENT minimum = A [ i ] NEW_LINE ind = i NEW_LINE DEDENT DEDENT maxIndChosen = X // minimum NEW_LINE ans = [ ] NEW_LINE if ( maxIndChosen == 0 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT for i in range ( maxIndChosen ) : NEW_LINE INDENT ans . append ( ind ) NEW_LINE DEDENT temp = maxIndChosen NEW_LINE sum = maxIndChosen * A [ ind ] NEW_LINE for i in range ( ind ) : NEW_LINE INDENT if ( sum - X == 0 or temp == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT while ( ( sum - A [ ind ] + A [ i ] ) <= X and temp != 0 ) : NEW_LINE INDENT del ( ans [ 0 ] ) NEW_LINE ans . append ( i ) NEW_LINE temp -= 1 NEW_LINE sum += ( A [ i ] - A [ ind ] ) NEW_LINE DEDENT DEDENT ans . sort ( ) NEW_LINE return ans NEW_LINE DEDENT
def CheckForSequence ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( k >= arr [ i ] ) : NEW_LINE INDENT k -= arr [ i ] NEW_LINE DEDENT DEDENT if ( k != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def reverse ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT
def countJumps ( n ) : NEW_LINE INDENT n = abs ( n ) NEW_LINE ans = 0 NEW_LINE while ( getsum ( ans ) < n or ( getsum ( ans ) - n ) & 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def steps ( cur , x , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return float ( 'inf' ) NEW_LINE DEDENT elif x > 0 : NEW_LINE INDENT return abs ( ( n - cur ) // x ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( int ( ( cur - 1 ) / x ) ) NEW_LINE DEDENT DEDENT
def find_rectangle ( area ) : NEW_LINE INDENT l , b = 0 , 0 NEW_LINE M = mt . ceil ( mt . sqrt ( area ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( M , 0 , - 1 ) : NEW_LINE INDENT if ( area % i == 0 ) : NEW_LINE INDENT l = ( area // i ) NEW_LINE b = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( "l =" , l , ", b =" , b ) NEW_LINE DEDENT
def countMinSwaps ( st ) : NEW_LINE INDENT min_swaps = 0 NEW_LINE odd_0 , even_0 = 0 , 0 NEW_LINE odd_1 , even_1 = 0 , 0 NEW_LINE n = len ( st ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT if st [ i ] == "1" : NEW_LINE INDENT even_1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_0 += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if st [ i ] == "1" : NEW_LINE INDENT odd_1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_0 += 1 NEW_LINE DEDENT DEDENT DEDENT cnt_swaps_1 = min ( even_0 , odd_1 ) NEW_LINE cnt_swaps_2 = min ( even_1 , odd_0 ) NEW_LINE return min ( cnt_swaps_1 , cnt_swaps_2 ) NEW_LINE DEDENT
def problemsLeft ( K , P , N ) : NEW_LINE INDENT if ( K <= P ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( K - P ) * N ) NEW_LINE DEDENT DEDENT
def isCorrectOrder ( n ) : NEW_LINE INDENT flag = True NEW_LINE prev = - 1 NEW_LINE type = - 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( type == - 1 ) : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT prev = n % 10 NEW_LINE n = int ( n / 10 ) NEW_LINE continue NEW_LINE DEDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT if ( prev > n % 10 ) : NEW_LINE INDENT type = 1 NEW_LINE prev = n % 10 NEW_LINE n = int ( n / 10 ) NEW_LINE continue NEW_LINE DEDENT prev = n % 10 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT if ( prev < n % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT prev = n % 10 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT
def maxDifference ( arr , N , k ) : NEW_LINE INDENT S = 0 NEW_LINE S1 = 0 NEW_LINE max_difference = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT arr . sort ( reverse = True ) NEW_LINE M = max ( k , N - k ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT max_difference = S1 - ( S - S1 ) NEW_LINE return max_difference NEW_LINE DEDENT
def MinimumRemovals ( a , N , K ) : NEW_LINE INDENT b = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT b [ i + 1 ] = a [ i ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE dp [ i + 1 ] [ j + 1 ] = max ( dp [ i + 1 ] [ j + 1 ] , dp [ i ] [ j ] + ( 1 if ( b [ i + 1 ] == j + 1 ) else 0 ) ) NEW_LINE DEDENT DEDENT j = N NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( dp [ N ] [ j ] >= K ) : NEW_LINE INDENT return ( N - j ) NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def countOfNumbers ( digit , mask , repeated , n ) : NEW_LINE INDENT global dp NEW_LINE if ( digit == n + 1 ) : NEW_LINE INDENT if ( repeated == True ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( repeated == True ) : NEW_LINE INDENT return pow ( 10 , n - digit + 1 ) NEW_LINE DEDENT val = dp [ digit ] [ mask ] [ repeated ] NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT return val NEW_LINE DEDENT val = 4 NEW_LINE if ( digit == 1 ) : NEW_LINE INDENT for i in range ( ( 0 if ( n == 1 ) else 1 ) , 10 ) : NEW_LINE INDENT if ( mask & ( 1 << i ) ) : NEW_LINE INDENT val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 1 , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 0 , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT if ( mask & ( 1 << i ) ) : NEW_LINE INDENT val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 1 , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT val += countOfNumbers ( digit + 1 , mask | ( 1 << i ) , 0 , n ) NEW_LINE DEDENT DEDENT dp [ digit ] [ mask ] [ repeated ] = val NEW_LINE return dp [ digit ] [ mask ] [ repeated ] NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxBoundary ( N , V ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = V [ 0 ] [ 0 ] NEW_LINE dp [ 0 ] [ 1 ] = V [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = V [ i ] [ 0 ] NEW_LINE height1 = abs ( V [ i - 1 ] [ 1 ] - V [ i ] [ 1 ] ) NEW_LINE height2 = abs ( V [ i - 1 ] [ 0 ] - V [ i ] [ 1 ] ) NEW_LINE dp [ i ] [ 0 ] += max ( height1 + dp [ i - 1 ] [ 0 ] , height2 + dp [ i - 1 ] [ 1 ] ) NEW_LINE dp [ i ] [ 1 ] = V [ i ] [ 1 ] NEW_LINE vertical1 = abs ( V [ i ] [ 0 ] - V [ i - 1 ] [ 1 ] ) NEW_LINE vertical2 = abs ( V [ i ] [ 0 ] - V [ i - 1 ] [ 1 ] ) NEW_LINE dp [ i ] [ 1 ] += max ( vertical1 + dp [ i - 1 ] [ 0 ] , vertical2 + dp [ i - 1 ] [ 1 ] ) NEW_LINE DEDENT print ( max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) - 1 ) NEW_LINE DEDENT
def findMinOperations ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] = 999999 NEW_LINE DEDENT dp [ 2 ] = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i * 5 <= n ) : NEW_LINE INDENT dp [ i * 5 ] = min ( dp [ i * 5 ] , dp [ i ] + 1 ) NEW_LINE DEDENT if ( i + 3 <= n ) : NEW_LINE INDENT dp [ i + 3 ] = min ( dp [ i + 3 ] , dp [ i ] + 1 ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def solve ( A , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE c = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE if ( A [ i ] == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( K > sum or ( sum + K ) % 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = ( sum + K ) // 2 NEW_LINE dp = [ [ 0 for i in range ( sum + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE for i in range ( sum + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 , 1 ) : NEW_LINE INDENT if ( A [ i - 1 ] <= j and A [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - A [ i - 1 ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dp [ N ] [ sum ] + pow ( 2 , c ) NEW_LINE DEDENT
def countSortedArrays ( start , m , size , n ) : NEW_LINE INDENT if ( size == m ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( start > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT notTaken , taken = 0 , 0 NEW_LINE taken = countSortedArrays ( start , m , size + 1 , n ) NEW_LINE notTaken = countSortedArrays ( start + 1 , m , size , n ) NEW_LINE return taken + notTaken NEW_LINE DEDENT
def getValue ( arr , N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT minn = arr [ i ] NEW_LINE maxx = arr [ i ] NEW_LINE j = i NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT minn = min ( arr [ j ] , minn ) NEW_LINE maxx = max ( arr [ j ] , maxx ) NEW_LINE dp [ i ] = max ( dp [ i ] , maxx - minn + ( dp [ j - 1 ] if ( j >= 1 ) else 0 ) ) NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return dp [ N - 1 ] NEW_LINE DEDENT
def maxScore ( s , a ) : NEW_LINE INDENT if s in dp : NEW_LINE INDENT return dp [ s ] NEW_LINE DEDENT n = len ( s ) NEW_LINE if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT head = 0 NEW_LINE mx = - 1 NEW_LINE while head < n : NEW_LINE INDENT tail = head NEW_LINE while tail < n : NEW_LINE INDENT if s [ tail ] != s [ head ] : NEW_LINE INDENT head = tail NEW_LINE break NEW_LINE DEDENT sub = s [ head : tail + 1 ] NEW_LINE mx = max ( mx , a [ len ( sub ) - 1 ] + maxScore ( s [ : head ] + s [ tail + 1 : ] , a ) ) NEW_LINE tail += 1 NEW_LINE DEDENT if tail == n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ s ] = mx NEW_LINE return mx NEW_LINE DEDENT
def minSumDifference ( arr , n , k1 , k2 , sum1 , sum2 ) : NEW_LINE INDENT global dp NEW_LINE if ( n < 0 ) : NEW_LINE INDENT if ( k1 == 0 and k2 == 0 ) : NEW_LINE INDENT return abs ( sum1 - sum2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return sys . maxsize + 1 NEW_LINE DEDENT DEDENT if ( dp [ n ] [ sum1 ] [ sum2 ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ sum1 ] [ sum2 ] NEW_LINE DEDENT op1 = sys . maxsize + 1 NEW_LINE op2 = sys . maxsize + 1 NEW_LINE op3 = sys . maxsize + 1 NEW_LINE if ( k1 > 0 ) : NEW_LINE INDENT op1 = minSumDifference ( arr , n - 1 , k1 - 1 , k2 , sum1 + arr [ n ] , sum2 ) NEW_LINE DEDENT if ( k2 > 0 ) : NEW_LINE INDENT op2 = minSumDifference ( arr , n - 1 , k1 , k2 - 1 , sum1 , sum2 + arr [ n ] ) NEW_LINE DEDENT op3 = minSumDifference ( arr , n - 1 , k1 , k2 , sum1 , sum2 ) NEW_LINE dp [ n ] [ sum1 ] [ sum2 ] = min ( op1 , min ( op2 , op3 ) ) NEW_LINE return dp [ n ] [ sum1 ] [ sum2 ] NEW_LINE DEDENT
def insertVector ( mask ) : NEW_LINE INDENT global dp , ans NEW_LINE for i in range ( 20 ) : NEW_LINE INDENT if ( ( mask & 1 << i ) == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( not dp [ i ] ) : NEW_LINE INDENT dp [ i ] = mask NEW_LINE ans += 1 NEW_LINE return NEW_LINE DEDENT mask ^= dp [ i ] NEW_LINE DEDENT DEDENT
def cntNumRange ( L , R , K ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( prodOfDigit ( i ) == K ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def findSubtreeORUtil ( N , Edges , Val , Queries , Q ) : NEW_LINE INDENT addEdgesToGraph ( Edges , N ) NEW_LINE findSubtreeOR ( Queries , Q , Val ) NEW_LINE DEDENT
def findMinimum ( a , n , pos , myturn ) : NEW_LINE INDENT if ( pos , myturn ) in m : NEW_LINE INDENT return m [ ( pos , myturn ) ] NEW_LINE DEDENT if ( pos >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( not myturn ) : NEW_LINE INDENT ans = min ( findMinimum ( a , n , pos + 1 , not myturn ) + a [ pos ] , findMinimum ( a , n , pos + 2 , not myturn ) + a [ pos ] + a [ pos + 1 ] ) NEW_LINE m [ ( pos , myturn ) ] = ans NEW_LINE return ans NEW_LINE DEDENT if ( myturn ) : NEW_LINE INDENT ans = min ( findMinimum ( a , n , pos + 1 , not myturn ) , findMinimum ( a , n , pos + 2 , not myturn ) ) NEW_LINE m [ ( pos , myturn ) ] = ans NEW_LINE return ans NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def countVowelStrings ( n ) : NEW_LINE INDENT return countstrings ( n , 0 ) NEW_LINE DEDENT
def maxSum ( arr , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for i in range ( 2 ) ] NEW_LINE dp [ 0 ] [ m - 1 ] = arr [ 0 ] [ m - 1 ] NEW_LINE dp [ 1 ] [ m - 1 ] = arr [ 1 ] [ m - 1 ] NEW_LINE for j in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT for i in range ( 2 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 0 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 0 ] [ j + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 1 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 1 ] [ j + 2 ] ) NEW_LINE DEDENT DEDENT DEDENT print ( max ( dp [ 0 ] [ 0 ] , dp [ 1 ] [ 0 ] ) ) NEW_LINE DEDENT
def findMaxGCD ( arr , N ) : NEW_LINE INDENT high = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT counter = 0 NEW_LINE for i in range ( high , 0 , - 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( j <= high ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT counter += count [ j ] NEW_LINE DEDENT j += i NEW_LINE if ( counter == 2 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT counter = 0 NEW_LINE DEDENT DEDENT
def findLCS ( nums , N ) : NEW_LINE INDENT k = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT pos = LowerBound ( nums , k , nums [ i ] ) NEW_LINE nums [ pos ] = nums [ i ] NEW_LINE if ( k == pos ) : NEW_LINE INDENT k = pos + 1 NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT
def check ( mask , i ) : NEW_LINE INDENT c = ( mask & ( 1 << i ) ) NEW_LINE return c != 0 NEW_LINE DEDENT
def minSteps ( m , n ) : NEW_LINE INDENT if ( n == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return inf NEW_LINE DEDENT min_cost = inf NEW_LINE for i in range ( 2 , m , 2 ) : NEW_LINE INDENT if ( m % i == 0 ) : NEW_LINE INDENT min_cost = min ( min_cost , m / i + minSteps ( m + i , n ) ) NEW_LINE DEDENT DEDENT return min_cost NEW_LINE DEDENT
def checkEqualSum ( arr , N ) : NEW_LINE INDENT sum1 = sum2 = sum3 = 0 NEW_LINE if checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def queries_fxn ( matrix , queries ) : NEW_LINE INDENT for q in queries : NEW_LINE INDENT manipulation ( matrix , q ) NEW_LINE DEDENT DEDENT
def countNums ( N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 16 ) ] for j in range ( N ) ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT for k in range ( 0 , 16 ) : NEW_LINE INDENT xor = j ^ k NEW_LINE dp [ i ] [ xor ] += dp [ i - 1 ] [ k ] NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT count += dp [ N - 1 ] [ i ] NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def constructSTUtil ( arr , ss , se , st , si ) : NEW_LINE INDENT if ss == se : NEW_LINE INDENT if prime [ arr [ ss ] ] : NEW_LINE INDENT st [ si ] = arr [ ss ] NEW_LINE DEDENT else : NEW_LINE INDENT st [ si ] = 0 NEW_LINE DEDENT return st [ si ] NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE st [ si ] = ( constructSTUtil ( arr , ss , mid , st , 2 * si + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , 2 * si + 2 ) ) NEW_LINE return st [ si ] NEW_LINE DEDENT
def dfs ( a , par ) : NEW_LINE INDENT leaf = 1 NEW_LINE for i in v [ a ] : NEW_LINE INDENT if ( i [ 0 ] == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT leaf = 0 NEW_LINE dfs ( i [ 0 ] , a ) NEW_LINE DEDENT if ( leaf == 1 ) : NEW_LINE INDENT leaves [ a ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT for i in v [ a ] : NEW_LINE INDENT if ( i [ 0 ] == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT leaves [ a ] += leaves [ i [ 0 ] ] NEW_LINE dp [ a ] = ( dp [ a ] + dp [ i [ 0 ] ] + leaves [ i [ 0 ] ] * i [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT
def getCount ( n , K ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT dp = [ 0 ] * 11 NEW_LINE next = [ 0 ] * 11 NEW_LINE for i in range ( 1 , 9 + 1 ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 9 + 1 ) : NEW_LINE INDENT l = max ( 0 , j - k ) NEW_LINE r = min ( 9 , j + k ) NEW_LINE next [ l ] += dp [ j ] NEW_LINE next [ r + 1 ] -= dp [ j ] NEW_LINE DEDENT for j in range ( 1 , 9 + 1 ) : NEW_LINE INDENT next [ j ] += next [ j - 1 ] NEW_LINE DEDENT for j in range ( 10 ) : NEW_LINE INDENT dp [ j ] = next [ j ] NEW_LINE next [ j ] = 0 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( 9 + 1 ) : NEW_LINE INDENT count += dp [ i ] NEW_LINE DEDENT return count NEW_LINE DEDENT
def nCrModp ( n , r ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT C = [ 0 ] * ( r + 1 ) NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , r ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = ( C [ j ] + C [ j - 1 ] ) % MOD NEW_LINE DEDENT DEDENT return C [ r ] NEW_LINE DEDENT
def findResult ( arr , n , q , m ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT print ( findResultUtil ( arr , q [ i ] [ 0 ] , q [ i ] [ 1 ] ) , end = " " ) NEW_LINE DEDENT DEDENT
def insert ( idx , s , root ) : NEW_LINE INDENT temp = root NEW_LINE for i in range ( idx , len ( s ) ) : NEW_LINE INDENT if temp . child [ ord ( s [ i ] ) - ord ( 'a' ) ] == None : NEW_LINE INDENT temp . child [ ord ( s [ i ] ) - ord ( 'a' ) ] = TrieNode ( ) NEW_LINE DEDENT temp = temp . child [ ord ( s [ i ] ) - ord ( 'a' ) ] NEW_LINE DEDENT DEDENT
def minCuts ( S1 , S2 ) : NEW_LINE INDENT n1 = len ( S1 ) NEW_LINE n2 = len ( S2 ) NEW_LINE root = TrieNode ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT insert ( i , S2 , root ) NEW_LINE DEDENT dp = [ INF ] * ( n1 + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT temp = root NEW_LINE for j in range ( i + 1 , n1 + 1 ) : NEW_LINE INDENT if temp . child [ ord ( S1 [ j - 1 ] ) - ord ( 'a' ) ] == None : NEW_LINE INDENT break NEW_LINE DEDENT dp [ j ] = min ( dp [ j ] , dp [ i ] + 1 ) NEW_LINE temp = temp . child [ ord ( S1 [ j - 1 ] ) - ord ( 'a' ) ] NEW_LINE DEDENT DEDENT if dp [ n1 ] >= INF : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ n1 ] NEW_LINE DEDENT DEDENT
def maximum ( A , B , C , D ) : NEW_LINE INDENT return max ( max ( A , B ) , max ( C , D ) ) NEW_LINE DEDENT
def maxSubarraySum ( graph , vertices , values ) : NEW_LINE INDENT visited = [ False for i in range ( 1001 ) ] NEW_LINE maxSum = - sys . maxsize NEW_LINE for i in range ( 1 , vertices + 1 ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT sizeChain = 0 NEW_LINE tempSum = 0 NEW_LINE storeChain = [ ] NEW_LINE depthFirst ( i , graph , visited , storeChain ) NEW_LINE sizeChain = len ( storeChain ) NEW_LINE chainValues = [ 0 for i in range ( sizeChain + 1 ) ] NEW_LINE for i in range ( sizeChain ) : NEW_LINE INDENT temp = values [ storeChain [ i ] - 1 ] NEW_LINE chainValues [ i ] = temp NEW_LINE DEDENT tempSum = subarraySum ( chainValues , sizeChain ) NEW_LINE if ( tempSum > maxSum ) : NEW_LINE INDENT maxSum = tempSum NEW_LINE DEDENT DEDENT DEDENT print ( "Maximum subarray sum among all " , end = '' ) NEW_LINE print ( "connected components = " , end = '' ) NEW_LINE print ( maxSum ) NEW_LINE DEDENT
def countDecodingDP ( digits , n ) : NEW_LINE INDENT if ( digits [ 0 ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count0 = 1 NEW_LINE count1 = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dig1 = 0 NEW_LINE dig3 = 0 NEW_LINE if ( digits [ i - 1 ] != '0' ) : NEW_LINE INDENT dig1 = 1 NEW_LINE DEDENT if ( digits [ i - 2 ] == '1' ) : NEW_LINE INDENT dig2 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dig2 = 0 NEW_LINE DEDENT if ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) : NEW_LINE INDENT dig3 = 1 NEW_LINE DEDENT count2 = dig1 * count1 + dig2 + dig3 * count0 NEW_LINE count0 = count1 NEW_LINE count1 = count2 NEW_LINE DEDENT return count1 NEW_LINE DEDENT
def countSubMatrix ( mtrx , k , p ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( dim ) ] for j in range ( dim ) ] NEW_LINE for i in range ( dim ) : NEW_LINE INDENT for j in range ( dim ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT createTable ( mtrx , k , p , dp ) NEW_LINE return countSubMatrixUtil ( dp , k , p ) NEW_LINE DEDENT
def f ( n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ n ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ k ] NEW_LINE DEDENT dp [ n ] [ k ] = ( ( ( ( k * f ( n - 1 , k ) ) % mod + ( f ( n - 1 , k - 1 ) ) % mod ) % mod ) ) NEW_LINE return dp [ n ] [ k ] NEW_LINE DEDENT
def checkPrime ( number ) : NEW_LINE INDENT num = int ( number ) NEW_LINE for i in range ( 2 , int ( num ** 0.5 ) ) : NEW_LINE INDENT if ( ( num % i ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countNumbers ( n , k ) : NEW_LINE INDENT st = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT powers [ i ] = st NEW_LINE st *= 10 NEW_LINE st %= mod NEW_LINE DEDENT st = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT powersModk [ i ] = st NEW_LINE st *= 10 NEW_LINE st %= mod NEW_LINE DEDENT return calculate ( 0 , 0 , 0 , k , n ) NEW_LINE DEDENT
def maxSum ( p0 , p1 , a , pos , n ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT if ( p0 == p1 ) : NEW_LINE INDENT return p0 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = maxSum ( p0 , p1 , a , pos + 1 , n ) NEW_LINE ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) NEW_LINE ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) NEW_LINE return ans NEW_LINE DEDENT
def maxSum ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT limit = 2 * sum + 1 NEW_LINE dp = np . zeros ( ( n + 1 , limit ) ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( limit ) : NEW_LINE INDENT dp [ i ] [ j ] = INT_MIN NEW_LINE DEDENT DEDENT dp [ 0 ] [ sum ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( limit ) : NEW_LINE INDENT if ( ( j - a [ i - 1 ] ) >= 0 and dp [ i - 1 ] [ j - a [ i - 1 ] ] != INT_MIN ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) NEW_LINE DEDENT if ( ( j + a [ i - 1 ] ) < limit and dp [ i - 1 ] [ j + a [ i - 1 ] ] != INT_MIN ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) NEW_LINE DEDENT if ( dp [ i - 1 ] [ j ] != INT_MIN ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ sum ] NEW_LINE DEDENT
def minSteps ( string , n , k ) : NEW_LINE INDENT if ( string [ n - 1 ] == '0' ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n < 4 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ 0 ] * n NEW_LINE dp [ n - 1 ] = 0 NEW_LINE dp [ n - 2 ] = 1 NEW_LINE dp [ n - 3 ] = 1 NEW_LINE for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT steps = INT_MAX NEW_LINE if ( i + k < n and string [ i + k ] == '1' ) : NEW_LINE INDENT steps = min ( steps , dp [ i + k ] ) NEW_LINE DEDENT if ( string [ i + 1 ] == '1' ) : NEW_LINE INDENT steps = min ( steps , dp [ i + 1 ] ) NEW_LINE DEDENT if ( string [ i + 2 ] == '1' ) : NEW_LINE INDENT steps = min ( steps , dp [ i + 2 ] ) NEW_LINE DEDENT dp [ i ] = steps if ( steps == INT_MAX ) else ( 1 + steps ) NEW_LINE DEDENT if ( dp [ 0 ] == INT_MAX ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return dp [ 0 ] NEW_LINE DEDENT
def eggDrop ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE x = 0 NEW_LINE while ( dp [ x ] [ n ] < k ) : NEW_LINE INDENT x += 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def findMax ( a , n ) : NEW_LINE INDENT dp = np . zeros ( ( n , 2 ) ) NEW_LINE dp [ 0 ] [ 0 ] = a [ 0 ] + a [ 1 ] NEW_LINE dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i + 1 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] NEW_LINE DEDENT print ( max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] ) , end = "" ) NEW_LINE DEDENT
def expectedSteps ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( x <= 5 ) : NEW_LINE INDENT return 6 NEW_LINE DEDENT if ( v [ x ] ) : NEW_LINE INDENT return dp [ x ] NEW_LINE DEDENT v [ x ] = 1 NEW_LINE dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 NEW_LINE return dp [ x ] NEW_LINE DEDENT
def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) NEW_LINE return dp [ i ] [ curr ] NEW_LINE DEDENT
def ways ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] = 0 NEW_LINE j = 1 NEW_LINE while ( ( j + i ) < n and j <= arr [ i ] ) : NEW_LINE INDENT dp [ i ] += dp [ i + j ] NEW_LINE dp [ i ] %= mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] % mod NEW_LINE DEDENT
def Probability ( p , n ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , n + 1 ) ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0.0 NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 1.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 ] [ j - 1 ] * p [ i ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0.0 NEW_LINE for i in range ( ( n + 1 ) // 2 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def count_required_sequence ( n , arr ) : NEW_LINE INDENT total_required_subsequence = 0 NEW_LINE total_n_required_subsequence = 0 NEW_LINE dp = np . zeros ( ( N , 2 ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT turn_required = 0 NEW_LINE for j in range ( - 1 , 2 , 1 ) : NEW_LINE INDENT turn_required += dp [ arr [ i ] + j ] [ 0 ] NEW_LINE DEDENT required_end_i = ( total_required_subsequence + turn_required ) NEW_LINE n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) NEW_LINE total_required_subsequence += required_end_i NEW_LINE total_n_required_subsequence += n_required_end_i NEW_LINE dp [ arr [ i ] ] [ 1 ] += required_end_i NEW_LINE dp [ arr [ i ] ] [ 0 ] += n_required_end_i NEW_LINE DEDENT return total_required_subsequence NEW_LINE DEDENT
def recur ( u , array , n ) : NEW_LINE INDENT if ( u == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ u ] != - 1 ) : NEW_LINE INDENT return dp [ u ] NEW_LINE DEDENT temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mask = get_binary ( array [ i ] ) NEW_LINE if ( ( mask u ) == u ) : NEW_LINE INDENT dp [ u ] = max ( max ( 0 , dp [ u ^ mask ] ) + array [ i ] , dp [ u ] ) NEW_LINE DEDENT DEDENT return dp [ u ] NEW_LINE DEDENT
def solve ( array , n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < ( 1 << 10 ) ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE i += 1 NEW_LINE DEDENT ans = 0 NEW_LINE i = 0 NEW_LINE while ( i < ( 1 << 10 ) ) : NEW_LINE INDENT ans = max ( ans , recur ( i , array , n ) ) NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def MinDiff ( i , sum , arr , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( visit [ i ] [ sum + MAX ] ) : NEW_LINE INDENT return dp [ i ] [ sum + MAX ] NEW_LINE DEDENT visit [ i ] [ sum + MAX ] = 1 NEW_LINE dp [ i ] [ sum + MAX ] = RetClose ( arr [ i ] + MinDiff ( i + 1 , sum + arr [ i ] , arr , n ) , MinDiff ( i + 1 , sum , arr , n ) , - 1 * sum ) NEW_LINE return dp [ i ] [ sum + MAX ] NEW_LINE DEDENT
def minSteps ( arr , i , mask , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i > n - 1 or i < 0 ) : NEW_LINE INDENT return 9999999 NEW_LINE DEDENT if ( ( mask >> i ) & 1 ) : NEW_LINE INDENT return 9999999 NEW_LINE DEDENT if ( v [ i ] [ mask ] == True ) : NEW_LINE INDENT return dp [ i ] [ mask ] NEW_LINE DEDENT v [ i ] [ mask ] = True NEW_LINE dp [ i ] [ mask ] = 1 + min ( minSteps ( arr , i - arr [ i ] , ( mask | ( 1 << i ) ) , n ) , minSteps ( arr , i + arr [ i ] , ( mask | ( 1 << i ) ) , n ) ) NEW_LINE return dp [ i ] [ mask ] NEW_LINE DEDENT
def maxSumPath ( i1 , j1 , i2 ) : NEW_LINE INDENT j2 = i1 + j1 - i2 NEW_LINE if ( i1 >= n or i2 >= n or j1 >= m or j2 >= m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( cache [ i1 ] [ j1 ] [ i2 ] != - 1 ) : NEW_LINE INDENT return cache [ i1 ] [ j1 ] [ i2 ] NEW_LINE DEDENT ans = - sys . maxsize - 1 NEW_LINE ans = max ( ans , maxSumPath ( i1 + 1 , j1 , i2 + 1 ) + sum ( i1 , j1 , i2 , j2 ) ) NEW_LINE ans = max ( ans , maxSumPath ( i1 , j1 + 1 , i2 ) + sum ( i1 , j1 , i2 , j2 ) ) NEW_LINE ans = max ( ans , maxSumPath ( i1 , j1 + 1 , i2 + 1 ) + sum ( i1 , j1 , i2 , j2 ) ) NEW_LINE ans = max ( ans , maxSumPath ( i1 + 1 , j1 , i2 ) + sum ( i1 , j1 , i2 , j2 ) ) NEW_LINE cache [ i1 ] [ j1 ] [ i2 ] = ans NEW_LINE return ans NEW_LINE DEDENT
def pre_process ( dp , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = False NEW_LINE DEDENT DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - j + 1 ) : NEW_LINE INDENT if ( j <= 2 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ i + j - 1 ] = True NEW_LINE DEDENT DEDENT elif ( s [ i ] == s [ i + j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def maxSum ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] = a [ i - 1 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( 3 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] NEW_LINE if i >= 2 : NEW_LINE INDENT dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) NEW_LINE DEDENT if i >= 2 : NEW_LINE INDENT dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] NEW_LINE DEDENT if i >= 3 : NEW_LINE INDENT dp [ i ] [ 2 ] = max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) NEW_LINE DEDENT ans = max ( ans , dp [ i ] [ 0 ] ) NEW_LINE ans = max ( ans , dp [ i ] [ 1 ] ) NEW_LINE ans = max ( ans , dp [ i ] [ 2 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sumEvenFactors ( L , R ) : NEW_LINE INDENT return ( prefix [ R ] - prefix [ L - 1 ] ) NEW_LINE DEDENT
def numberOfWays ( x , y , z ) : NEW_LINE INDENT binomialCoeff ( max ( x , max ( y , z ) ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , z + 1 ) : NEW_LINE INDENT sum = ( sum + C [ z ] [ i ] ) NEW_LINE DEDENT sum1 = 0 NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , x + 1 ) : NEW_LINE INDENT sum1 = ( sum1 + ( C [ y ] [ i ] * C [ x ] [ j ] ) ) NEW_LINE DEDENT DEDENT sum1 = ( sum * sum1 ) NEW_LINE return sum1 NEW_LINE DEDENT
def findMaxSubarraySum ( a , n , k ) : NEW_LINE INDENT ans = - 1e9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) NEW_LINE DEDENT if ans == 0 and k == 0 : NEW_LINE INDENT return max ( a ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def count ( pos , even , odd , tight , num ) : NEW_LINE INDENT if pos == len ( num ) : NEW_LINE INDENT if len ( num ) & 1 : NEW_LINE INDENT odd , even = even , odd NEW_LINE DEDENT d = even - odd NEW_LINE for i in range ( 24 ) : NEW_LINE INDENT if d == prime [ i ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if dp [ pos ] [ even ] [ odd ] [ tight ] != - 1 : NEW_LINE INDENT return dp [ pos ] [ even ] [ odd ] [ tight ] NEW_LINE DEDENT ans = 0 NEW_LINE limit = 9 if tight else num [ pos ] NEW_LINE for d in range ( limit + 1 ) : NEW_LINE INDENT currF = tight NEW_LINE currEven = even NEW_LINE currOdd = odd NEW_LINE if d < num [ pos ] : NEW_LINE INDENT currF = 1 NEW_LINE DEDENT if pos & 1 : NEW_LINE INDENT currOdd += d NEW_LINE DEDENT else : NEW_LINE INDENT currEven += d NEW_LINE DEDENT ans += count ( pos + 1 , currEven , currOdd , currF , num ) NEW_LINE DEDENT dp [ pos ] [ even ] [ odd ] [ tight ] = ans NEW_LINE return dp [ pos ] [ even ] [ odd ] [ tight ] NEW_LINE DEDENT
def maxWeight ( arr , n , w1_r , w2_r , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ i ] [ w1_r ] [ w2_r ] != - 1 : NEW_LINE INDENT return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT fill_w1 , fill_w2 , fill_none = 0 , 0 , 0 NEW_LINE if w1_r >= arr [ i ] : NEW_LINE INDENT fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) NEW_LINE DEDENT if w2_r >= arr [ i ] : NEW_LINE INDENT fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) NEW_LINE DEDENT fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) NEW_LINE dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) NEW_LINE return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT
def solve ( x ) : NEW_LINE INDENT num = [ ] NEW_LINE global dp NEW_LINE while x > 0 : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT num . reverse ( ) NEW_LINE dp = [ [ [ [ - 1 , - 1 ] for i in range ( M ) ] for j in range ( 165 ) ] for k in range ( M ) ] NEW_LINE return count ( 0 , 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT
def factorial ( k ) : NEW_LINE INDENT fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , k + 2 ) : NEW_LINE INDENT fac [ i ] = ( i * fac [ i - 1 ] ) NEW_LINE DEDENT DEDENT
def MaxProfit ( treasure , color , n , k , col , A , B ) : NEW_LINE INDENT if ( k == n ) : NEW_LINE INDENT dp [ k ] [ col ] = 0 NEW_LINE return dp [ k ] [ col ] NEW_LINE DEDENT if ( dp [ k ] [ col ] != - 1 ) : NEW_LINE INDENT return dp [ k ] [ col ] NEW_LINE DEDENT summ = 0 NEW_LINE if ( col == color [ k ] ) : NEW_LINE INDENT summ += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT else : NEW_LINE INDENT summ += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT dp [ k ] [ col ] = summ NEW_LINE return dp [ k ] [ col ] NEW_LINE DEDENT
def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( mx + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * ( mx + 1 ) NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT
def alternateFib ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE print ( f1 , end = " " ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f3 = f2 + f1 NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT print ( f3 , end = " " ) NEW_LINE DEDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE DEDENT DEDENT
def findSDSFunc ( n ) : NEW_LINE INDENT DP = [ 0 ] * ( n + 1 ) NEW_LINE DP [ 0 ] = 0 NEW_LINE DP [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( int ( i % 2 ) == 0 ) : NEW_LINE INDENT DP [ i ] = DP [ int ( i / 2 ) ] NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [ int ( ( i + 1 ) / 2 ) ] ) NEW_LINE DEDENT DEDENT return DP [ n ] NEW_LINE DEDENT
def findInd ( key , i , n , k , arr ) : NEW_LINE INDENT ind = - 1 NEW_LINE start = i + 1 NEW_LINE end = n - 1 NEW_LINE while ( start < end ) : NEW_LINE INDENT mid = int ( start + ( end - start ) / 2 ) NEW_LINE if ( arr [ mid ] - key <= k ) : NEW_LINE INDENT ind = mid NEW_LINE start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid NEW_LINE DEDENT DEDENT return ind NEW_LINE DEDENT
def Combination ( a , combi , n , r , depth , index ) : NEW_LINE INDENT global Sum NEW_LINE if index == r : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( r ) : NEW_LINE INDENT product = product * combi [ i ] NEW_LINE DEDENT Sum += product NEW_LINE return NEW_LINE DEDENT for i in range ( depth , n ) : NEW_LINE INDENT combi [ index ] = a [ i ] NEW_LINE Combination ( a , combi , n , r , i + 1 , index + 1 ) NEW_LINE DEDENT DEDENT
def zigzag ( n , k ) : NEW_LINE INDENT if ( n == 0 and k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) NEW_LINE DEDENT
def lobb ( n , m ) : NEW_LINE INDENT return ( ( ( 2 * m + 1 ) * binomialCoeff ( 2 * n , m + n ) ) / ( m + n + 1 ) ) NEW_LINE DEDENT
def numberofways ( A , B , N , M ) : NEW_LINE INDENT pos = [ [ ] for _ in range ( MAX ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT pos [ ord ( B [ i ] ) ] . append ( i + 1 ) NEW_LINE DEDENT dpl = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT if A [ i - 1 ] == B [ j - 1 ] : NEW_LINE INDENT dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT LCS = dpl [ N ] [ M ] NEW_LINE dpr = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT if A [ i - 1 ] == B [ j - 1 ] : NEW_LINE INDENT dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE INDENT for x in pos [ j ] : NEW_LINE INDENT if dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def precompute ( s , n , l , r ) : NEW_LINE INDENT l [ ord ( s [ 0 ] ) - ord ( 'a' ) ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( MAX_CHAR ) : NEW_LINE INDENT l [ j ] [ i ] += l [ j ] [ i - 1 ] NEW_LINE DEDENT l [ ord ( s [ i ] ) - ord ( 'a' ) ] [ i ] += 1 NEW_LINE DEDENT r [ ord ( s [ n - 1 ] ) - ord ( 'a' ) ] [ n - 1 ] = 1 NEW_LINE k = n - 2 NEW_LINE while ( k >= 0 ) : NEW_LINE INDENT for j in range ( MAX_CHAR ) : NEW_LINE INDENT r [ j ] [ k ] += r [ j ] [ k + 1 ] NEW_LINE DEDENT r [ ord ( s [ k ] ) - ord ( 'a' ) ] [ k ] += 1 NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT
def maxSum ( mat , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return mat [ 0 ] [ 0 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE maxSum = INT_MIN NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT maxi = INT_MIN NEW_LINE if ( ( ( ( j - 1 ) >= 0 ) and ( maxi < dp [ i + 1 ] [ j - 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT if ( ( ( ( j + 1 ) < n ) and ( maxi < dp [ i + 1 ] [ j + 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT dp [ i ] [ j ] = mat [ i ] [ j ] + maxi NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT if ( maxSum < dp [ 0 ] [ j ] ) : NEW_LINE INDENT maxSum = dp [ 0 ] [ j ] NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT
def minJump ( height , x , y ) : NEW_LINE INDENT if ( x == R - 1 and y == C - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT diag = 10 ** 9 NEW_LINE if ( isSafe ( x + 1 , y + 1 ) ) : NEW_LINE INDENT diag = ( minJump ( height , x + 1 , y + 1 ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ) NEW_LINE DEDENT down = 10 ** 9 NEW_LINE if ( isSafe ( x + 1 , y ) ) : NEW_LINE INDENT down = ( minJump ( height , x + 1 , y ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ) NEW_LINE DEDENT right = 10 ** 9 NEW_LINE if ( isSafe ( x , y + 1 ) ) : NEW_LINE INDENT right = ( minJump ( height , x , y + 1 ) + abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ) NEW_LINE DEDENT return min ( [ down , right , diag ] ) NEW_LINE DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) NEW_LINE DEDENT DEDENT
def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( n ) ] NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return ( n - len ) NEW_LINE DEDENT
def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT min_ending_here = sys . maxsize NEW_LINE min_so_far = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( min_ending_here > 0 ) : NEW_LINE INDENT min_ending_here = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT min_ending_here += arr [ i ] NEW_LINE DEDENT min_so_far = min ( min_so_far , min_ending_here ) NEW_LINE DEDENT return min_so_far NEW_LINE DEDENT
def baseconversion ( arr , num , base ) : NEW_LINE INDENT i = 0 NEW_LINE if ( num == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( num > 0 ) : NEW_LINE INDENT rem = num % base NEW_LINE i = i + 1 NEW_LINE arr [ i ] = rem NEW_LINE num = num // base NEW_LINE DEDENT return i NEW_LINE DEDENT
def ans ( n ) : NEW_LINE INDENT if ( n < 6 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return n % 6 + 10 * ( ans ( n // 6 ) ) - 1 NEW_LINE DEDENT
def nonDecNums ( n ) : NEW_LINE INDENT a = np . zeros ( ( n + 1 , 10 ) ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT a [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 9 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT return int ( a [ n ] [ 0 ] ) NEW_LINE DEDENT
def LAS ( arr , n ) : NEW_LINE INDENT inc = 1 NEW_LINE dec = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT inc = dec + 1 NEW_LINE DEDENT elif ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT dec = inc + 1 NEW_LINE DEDENT DEDENT return max ( inc , dec ) NEW_LINE DEDENT
def lps ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if ( str [ i ] == str [ j ] and cl == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def largestZigZagSumRec ( mat , i , j , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return mat [ i ] [ j ] NEW_LINE DEDENT zzs = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if ( k != j ) : NEW_LINE INDENT zzs = max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) NEW_LINE DEDENT DEDENT return zzs + mat [ i ] [ j ] NEW_LINE DEDENT
def largestZigZag ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT res = max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def MaxDotProduct ( A , B , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( i , m + 1 , 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
def unboundedKnapsack ( W , n , val , wt ) : NEW_LINE INDENT dp = [ 0 for i in range ( W + 1 ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( W + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( wt [ j ] <= i ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ W ] NEW_LINE DEDENT
def countSubarray ( arr , n , k ) : NEW_LINE INDENT s = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT count = 0 NEW_LINE while ( i < n and arr [ i ] <= k ) : NEW_LINE INDENT i = i + 1 NEW_LINE count = count + 1 NEW_LINE DEDENT s = s + ( ( count * ( count + 1 ) ) // 2 ) NEW_LINE DEDENT return ( n * ( n + 1 ) // 2 - s ) NEW_LINE DEDENT
def CountPS ( str , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE P = [ [ False for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT P [ i ] [ i + 1 ] = True NEW_LINE dp [ i ] [ i + 1 ] = 1 NEW_LINE DEDENT DEDENT for gap in range ( 2 , n ) : NEW_LINE INDENT for i in range ( n - gap ) : NEW_LINE INDENT j = gap + i NEW_LINE if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) : NEW_LINE INDENT P [ i ] [ j ] = True NEW_LINE DEDENT if ( P [ i ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def breakSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ) ) , n ) NEW_LINE DEDENT
def findMinSum ( arr , n ) : NEW_LINE INDENT sum = [ ] NEW_LINE sum . append ( arr [ 0 ] ) NEW_LINE sum . append ( arr [ 1 ] ) NEW_LINE sum . append ( arr [ 2 ] ) NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT sum . append ( arr [ i ] + minimum ( sum [ i - 3 ] , sum [ i - 2 ] , sum [ i - 1 ] ) ) NEW_LINE DEDENT return minimum ( sum [ n - 1 ] , sum [ n - 2 ] , sum [ n - 3 ] ) NEW_LINE DEDENT
def minAdjustmentCost ( A , n , target ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 100000000 NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT DEDENT DEDENT res = 10000000 NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countWays ( p , q , r , last ) : NEW_LINE INDENT if ( p < 0 or q < 0 or r < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( p == 1 and q == 0 and r == 0 and last == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( p == 0 and q == 1 and r == 0 and last == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( p == 0 and q == 0 and r == 1 and last == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( last == 0 ) : NEW_LINE INDENT return ( countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ) NEW_LINE DEDENT if ( last == 1 ) : NEW_LINE INDENT return ( countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ) NEW_LINE DEDENT if ( last == 2 ) : NEW_LINE INDENT return ( countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ) NEW_LINE DEDENT DEDENT
def countP ( n , k ) : NEW_LINE INDENT if ( n == 0 or k == 0 or k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) NEW_LINE DEDENT
def countP ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( k + 1 ) : NEW_LINE INDENT dp [ 0 ] [ k ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( j == 1 or i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
def has4 ( x ) : NEW_LINE INDENT while ( x != 0 ) : NEW_LINE INDENT if ( x % 10 == 4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT return False NEW_LINE DEDENT
def findMaxforN ( root , N ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if root . key == N : NEW_LINE INDENT return N NEW_LINE DEDENT elif root . key < N : NEW_LINE INDENT k = findMaxforN ( root . right , N ) NEW_LINE if k == - 1 : NEW_LINE INDENT return root . key NEW_LINE DEDENT else : NEW_LINE INDENT return k NEW_LINE DEDENT DEDENT elif root . key > N : NEW_LINE INDENT return findMaxforN ( root . left , N ) NEW_LINE DEDENT DEDENT
def findMinInsertionsDP ( str1 , n ) : NEW_LINE INDENT table = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE l , h , gap = 0 , 0 , 0 NEW_LINE for gap in range ( 1 , n ) : NEW_LINE INDENT l = 0 NEW_LINE for h in range ( gap , n ) : NEW_LINE INDENT if str1 [ l ] == str1 [ h ] : NEW_LINE INDENT table [ l ] [ h ] = table [ l + 1 ] [ h - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT table [ l ] [ h ] = ( Min ( table [ l ] [ h - 1 ] , table [ l + 1 ] [ h ] ) + 1 ) NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT return table [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def distanceBetween2 ( root , a , b ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT if root . key > a and root . key > b : NEW_LINE INDENT return distanceBetween2 ( root . left , a , b ) NEW_LINE DEDENT if root . key < a and root . key < b : NEW_LINE INDENT return distanceBetween2 ( root . right , a , b ) NEW_LINE DEDENT if root . key >= a and root . key <= b : NEW_LINE INDENT return ( distanceFromRoot ( root , a ) + distanceFromRoot ( root , b ) ) NEW_LINE DEDENT DEDENT
def eggDrop ( n , k ) : NEW_LINE INDENT eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ 1 ] = 1 NEW_LINE eggFloor [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT eggFloor [ 1 ] [ j ] = j NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 2 , k + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ j ] = INT_MAX NEW_LINE for x in range ( 1 , j + 1 ) : NEW_LINE INDENT res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) NEW_LINE if res < eggFloor [ i ] [ j ] : NEW_LINE INDENT eggFloor [ i ] [ j ] = res NEW_LINE DEDENT DEDENT DEDENT DEDENT return eggFloor [ n ] [ k ] NEW_LINE DEDENT
def getCountUtil ( root , low , high , count ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return True NEW_LINE DEDENT l = getCountUtil ( root . left , low , high , count ) NEW_LINE r = getCountUtil ( root . right , low , high , count ) NEW_LINE if l and r and inRange ( root , low , high ) : NEW_LINE INDENT count [ 0 ] += 1 NEW_LINE return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def ksmallestElementSum ( root , k ) : NEW_LINE INDENT count = [ 0 ] NEW_LINE return ksmallestElementSumRec ( root , k , count ) NEW_LINE DEDENT
def findOccurrences ( S , T ) : NEW_LINE INDENT n1 = len ( S ) NEW_LINE n2 = len ( T ) NEW_LINE ans = 0 NEW_LINE last = 0 NEW_LINE for i in range ( n1 - n2 + 1 ) : NEW_LINE INDENT chk = True NEW_LINE for j in range ( n2 ) : NEW_LINE INDENT if ( T [ j ] != S [ i + j ] ) : NEW_LINE INDENT chk = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( chk ) : NEW_LINE INDENT ans += ( i + 1 - last ) * ( n1 - ( i + n2 - 1 ) ) NEW_LINE last = i + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def countTimes ( arr , K ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT cnt = 0 NEW_LINE if abs ( arr [ 0 ] - arr [ 1 ] ) == K : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if abs ( arr [ 2 ] - arr [ 1 ] ) == K : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if abs ( arr [ 0 ] - arr [ 2 ] ) == K : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT prefix = [ 0 ] * ( N + 2 ) NEW_LINE suffix = [ 0 ] * ( N + 2 ) NEW_LINE prefix [ 0 ] = arr [ 0 ] NEW_LINE prefix [ 1 ] = arr [ 1 ] NEW_LINE suffix [ N - 1 ] = arr [ N - 1 ] NEW_LINE suffix [ N - 2 ] = arr [ N - 2 ] NEW_LINE for i in range ( 2 , N , 2 ) : NEW_LINE INDENT prefix [ i ] = arr [ i ] + prefix [ i - 2 ] NEW_LINE DEDENT for i in range ( 3 , N , 2 ) : NEW_LINE INDENT prefix [ i ] = arr [ i ] + prefix [ i - 2 ] NEW_LINE DEDENT for i in range ( N - 3 , - 1 , - 2 ) : NEW_LINE INDENT suffix [ i ] = arr [ i ] + suffix [ i + 2 ] NEW_LINE DEDENT for i in range ( N - 4 , - 1 , - 2 ) : NEW_LINE INDENT suffix [ i ] = arr [ i ] + suffix [ i + 2 ] NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( abs ( prefix [ i - 1 ] + suffix [ i + 2 ] - prefix [ i - 2 ] - suffix [ i + 1 ] ) == K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT count += findCount0th ( arr , N , K ) NEW_LINE count += findCount1st ( arr , N , K ) NEW_LINE return count NEW_LINE DEDENT
def LargestArray ( N , low , high ) : NEW_LINE INDENT high_index = N - ( high - low + 1 ) NEW_LINE if ( high_index > ( N - 1 ) // 2 ) : NEW_LINE INDENT print ( "Not Possible" ) NEW_LINE return NEW_LINE DEDENT if ( high_index <= 0 ) : NEW_LINE INDENT high_index = 1 NEW_LINE DEDENT A = [ 0 ] * N NEW_LINE temp = high NEW_LINE for i in range ( high_index , - 1 , - 1 ) : NEW_LINE INDENT A [ i ] = temp NEW_LINE temp = temp - 1 NEW_LINE DEDENT high -= 1 NEW_LINE for i in range ( high_index + 1 , N ) : NEW_LINE INDENT A [ i ] = high NEW_LINE high = high - 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( A [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def OddLengthSum ( arr ) : NEW_LINE INDENT Sum = 0 NEW_LINE l = len ( arr ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT Sum += ( ( ( ( i + 1 ) * ( l - i ) + 1 ) // 2 ) * arr [ i ] ) NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def SpiralElement ( x , y ) : NEW_LINE INDENT r = 0 NEW_LINE if ( x < y ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT r = y * y NEW_LINE return ( r - x + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT r = ( y - 1 ) * ( y - 1 ) NEW_LINE return ( r + x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( x % 2 == 0 ) : NEW_LINE INDENT r = x * x NEW_LINE return ( r - y + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT r = ( x - 1 ) * ( x - 1 ) NEW_LINE return ( r + y ) NEW_LINE DEDENT DEDENT DEDENT
def checkprefix ( A , B ) : NEW_LINE INDENT s1 = str ( A ) NEW_LINE s2 = str ( B ) NEW_LINE n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE if n1 < n2 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , n2 ) : NEW_LINE INDENT if s1 [ i ] != s2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def Count ( i ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( i < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT a [ i ] = ( i + 1 ) + 2 * Count ( i - 1 ) NEW_LINE return a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT
def printOddFactorNumber ( n , m ) : NEW_LINE INDENT for i in range ( n , m + 1 ) : NEW_LINE INDENT if ( ( i > 0 ) and ( ( i & ( i - 1 ) ) != 0 ) ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def stateC ( n ) : NEW_LINE INDENT print ( "String accepted" ) NEW_LINE DEDENT
def findDistinctSums ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT s . add ( i + j ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT
def check_string_exist ( S ) : NEW_LINE INDENT size = len ( S ) NEW_LINE check = True NEW_LINE for i in range ( size ) : NEW_LINE INDENT if S [ i ] != S [ ( i + 2 ) % size ] : NEW_LINE INDENT check = False NEW_LINE break NEW_LINE DEDENT DEDENT if check : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE first_term = 12 NEW_LINE nth = ( first_term * ( pow ( 2 , N - 1 ) ) ) + 11 * ( ( pow ( 2 , N - 1 ) ) - 1 ) NEW_LINE return nth NEW_LINE DEDENT
def isVowel ( ch ) : NEW_LINE INDENT if ch in [ 'i' , 'a' , 'e' , 'o' , 'u' ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def KMPSearch ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE lps = [ 0 ] * M NEW_LINE computeLPSArray ( pat , M , lps ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < N : NEW_LINE INDENT if pat [ j ] == txt [ i ] : NEW_LINE INDENT j += 1 NEW_LINE i += 1 NEW_LINE DEDENT if j == M : NEW_LINE INDENT return i - j NEW_LINE j = lps [ j - 1 ] NEW_LINE DEDENT elif i < N and pat [ j ] != txt [ i ] : NEW_LINE INDENT if j != 0 : NEW_LINE INDENT j = lps [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def checkSequence ( a , b ) : NEW_LINE INDENT if len ( b ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if len ( a ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( a [ 0 ] == b [ 0 ] ) : NEW_LINE INDENT return checkSequence ( a [ 1 : ] , b [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return checkSequence ( a [ 1 : ] , b ) NEW_LINE DEDENT DEDENT
def getCount ( a , b ) : NEW_LINE INDENT if ( len ( b ) % len ( a ) != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = int ( len ( b ) / len ( a ) ) NEW_LINE a = a * count NEW_LINE if ( a == b ) : NEW_LINE INDENT return count NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT vowel = "aeiou" NEW_LINE for i in range ( len ( vowel ) ) : NEW_LINE INDENT if ( vowel [ i ] == c ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def calc ( l , r , s ) : NEW_LINE INDENT if ( abs ( r - l ) % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l > r ) : NEW_LINE INDENT dp [ l ] [ r ] = 1 NEW_LINE return dp [ l ] [ r ] NEW_LINE DEDENT if ( dp [ l ] [ r ] != - 1 ) : NEW_LINE INDENT return dp [ l ] [ r ] NEW_LINE DEDENT if ( ( r - l ) == 1 ) : NEW_LINE INDENT if ( s [ l ] == s [ r ] ) : NEW_LINE INDENT dp [ l ] [ r ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ l ] [ r ] = 0 NEW_LINE DEDENT return dp [ l ] [ r ] NEW_LINE DEDENT ans = 0 NEW_LINE for k in range ( l + 1 , r + 1 , 2 ) : NEW_LINE INDENT temp = 1 NEW_LINE if ( s [ l ] == s [ k ] ) : NEW_LINE INDENT temp = calc ( l + 1 , k - 1 , s ) * calc ( k + 1 , r , s ) * choose [ ( r - l + 1 ) // 2 ] [ ( r - k ) // 2 ] NEW_LINE ans += temp NEW_LINE DEDENT DEDENT dp [ l ] [ r ] = ans NEW_LINE return dp [ l ] [ r ] NEW_LINE DEDENT
def number_of_tower ( house , r , n ) : NEW_LINE INDENT house . sort ( ) NEW_LINE numOfTower = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT numOfTower += 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return numOfTower NEW_LINE DEDENT
def minimumFlips ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE cnt0 = s . count ( '0' ) NEW_LINE cnt1 = 0 NEW_LINE res = n - cnt0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT cnt0 -= 1 NEW_LINE DEDENT elif s [ i ] == '1' : NEW_LINE INDENT res = min ( res , cnt1 + cnt0 ) NEW_LINE cnt1 += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def KthCharacter ( s , t , k ) : NEW_LINE INDENT f = 1 NEW_LINE ss = 2 NEW_LINE tmp = "" NEW_LINE lenn = len ( tmp ) NEW_LINE while ( lenn < k ) : NEW_LINE INDENT tf = f NEW_LINE ts = ss NEW_LINE while ( tf != 0 ) : NEW_LINE INDENT tf -= 1 NEW_LINE tmp += s NEW_LINE DEDENT while ( ts != 0 ) : NEW_LINE INDENT ts -= 1 NEW_LINE tmp += t NEW_LINE DEDENT f += 2 NEW_LINE ss += 2 NEW_LINE lenn = len ( tmp ) NEW_LINE DEDENT output = tmp [ k - 1 ] NEW_LINE return output NEW_LINE DEDENT
def fact ( a ) : NEW_LINE INDENT return math . factorial ( a ) NEW_LINE DEDENT
def checkIfPossible ( N , arr , T ) : NEW_LINE INDENT freqS = [ 0 ] * 256 NEW_LINE freqT = [ 0 ] * 256 NEW_LINE for ch in T : NEW_LINE INDENT freqT [ ord ( ch ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for ch in arr [ i ] : NEW_LINE INDENT freqS [ ord ( ch ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 256 ) : NEW_LINE INDENT if ( freqT [ i ] == 0 and freqS [ i ] != 0 ) : NEW_LINE INDENT return "No" NEW_LINE DEDENT elif ( freqS [ i ] == 0 and freqT [ i ] != 0 ) : NEW_LINE INDENT return "No" NEW_LINE DEDENT elif ( freqT [ i ] != 0 and freqS [ i ] != ( freqT [ i ] * N ) ) : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT return "Yes" NEW_LINE DEDENT
def findSubstringInWraproundString ( p ) : NEW_LINE INDENT ans = 0 NEW_LINE curLen = 0 NEW_LINE arr = [ 0 ] * 26 NEW_LINE for i in range ( 0 , len ( p ) ) : NEW_LINE INDENT curr = ord ( p [ i ] ) - ord ( 'a' ) NEW_LINE if ( i > 0 and ( ord ( p [ i - 1 ] ) != ( ( curr + 26 - 1 ) % 26 + ord ( 'a' ) ) ) ) : NEW_LINE INDENT curLen = 0 NEW_LINE DEDENT curLen += 1 NEW_LINE if ( curLen > arr [ curr ] ) : NEW_LINE INDENT ans += ( curLen - arr [ curr ] ) NEW_LINE arr [ curr ] = curLen NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def update ( BIT , idx , i , val ) : NEW_LINE INDENT while ( i < 10005 ) : NEW_LINE INDENT BIT [ idx ] [ i ] += val NEW_LINE DEDENT i = i + ( i & ( - i ) ) NEW_LINE DEDENT
def fact ( a ) : NEW_LINE INDENT f = 1 NEW_LINE for i in range ( 2 , a + 1 ) : NEW_LINE INDENT f = f * i NEW_LINE DEDENT return f NEW_LINE DEDENT
def maxLength ( arr ) : NEW_LINE INDENT tmp = helper ( arr , 0 ) NEW_LINE l = 0 NEW_LINE for i in tmp : NEW_LINE INDENT l = l if l > len ( i ) else len ( i ) NEW_LINE DEDENT return l NEW_LINE DEDENT
def polynomialRollingHash ( str ) : NEW_LINE INDENT p = 31 NEW_LINE m = 1e9 + 9 NEW_LINE power_of_p = 1 NEW_LINE hash_val = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT hash_val = ( ( hash_val + ( ord ( str [ i ] ) - ord ( 'a' ) + 1 ) * power_of_p ) % m ) NEW_LINE power_of_p = ( power_of_p * p ) % m NEW_LINE DEDENT return int ( hash_val ) NEW_LINE DEDENT
def isPalindrome ( str ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( str ) - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ h ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def checkPalindrome ( ) : NEW_LINE INDENT oddCnt = 0 NEW_LINE for x in freq : NEW_LINE INDENT if ( x % 2 == 1 ) : NEW_LINE INDENT oddCnt += 1 NEW_LINE DEDENT DEDENT return oddCnt <= 1 NEW_LINE DEDENT
def countSubstrings ( str , K ) : NEW_LINE INDENT N = len ( str ) NEW_LINE answer = 0 NEW_LINE map = { } NEW_LINE for i in range ( K ) : NEW_LINE INDENT map [ str [ i ] ] = map . get ( str [ i ] , 0 ) + 1 NEW_LINE DEDENT if ( len ( map ) == K ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT for i in range ( K , N ) : NEW_LINE INDENT map [ str [ i ] ] = map . get ( str [ i ] , 0 ) + 1 NEW_LINE map [ str [ i - K ] ] -= 1 NEW_LINE if ( map [ str [ i - K ] ] == 0 ) : NEW_LINE INDENT del map [ str [ i - K ] ] NEW_LINE DEDENT if ( len ( map ) == K ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sqt = ( int ) ( math . sqrt ( n ) ) NEW_LINE for i in range ( 2 , sqt ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def moveAtEnd ( s , i , l ) : NEW_LINE INDENT if ( i >= l ) : NEW_LINE INDENT return NEW_LINE DEDENT curr = s [ i ] NEW_LINE if ( curr != 'x' ) : NEW_LINE INDENT print ( curr , end = "" ) NEW_LINE DEDENT moveAtEnd ( s , i + 1 , l ) NEW_LINE if ( curr == 'x' ) : NEW_LINE INDENT print ( curr , end = "" ) NEW_LINE DEDENT return NEW_LINE DEDENT
def kthString ( n , k ) : NEW_LINE INDENT total = 0 NEW_LINE i = 1 NEW_LINE while ( total < k ) : NEW_LINE INDENT total = total + n - i NEW_LINE i += 1 NEW_LINE DEDENT first_y_position = i - 1 NEW_LINE second_y_position = k - ( total - n + first_y_position ) NEW_LINE for j in range ( 1 , first_y_position , 1 ) : NEW_LINE INDENT print ( "x" , end = "" ) NEW_LINE DEDENT print ( "y" , end = "" ) NEW_LINE j = first_y_position + 1 NEW_LINE while ( second_y_position > 1 ) : NEW_LINE INDENT print ( "x" , end = "" ) NEW_LINE second_y_position -= 1 NEW_LINE j += 1 NEW_LINE DEDENT print ( "y" , end = "" ) NEW_LINE while ( j < n ) : NEW_LINE INDENT print ( "x" ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT
def check ( string ) : NEW_LINE INDENT if ( checkIfStartsWithCapital ( string ) ) : NEW_LINE INDENT print ( "Accepted" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Not Accepted" ) NEW_LINE DEDENT DEDENT
def compressString ( s , n ) : NEW_LINE INDENT freq = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT print ( ( chr ) ( i + ord ( 'a' ) ) , freq [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findLength ( s , k ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE cnt_zero = 0 NEW_LINE cnt_one = 0 NEW_LINE while ( l < len ( s ) and r <= len ( s ) ) : NEW_LINE INDENT if ( cnt_zero >= k and cnt_one >= 1 ) : NEW_LINE INDENT ans = min ( ans , r - l ) NEW_LINE l += 1 NEW_LINE if ( s [ l - 1 ] == '0' ) : NEW_LINE INDENT cnt_zero -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( r == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( s [ r ] == '0' ) : NEW_LINE INDENT cnt_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one += 1 NEW_LINE DEDENT r += 1 NEW_LINE DEDENT DEDENT if ( ans == 10 ** 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def cntSplits ( s ) : NEW_LINE INDENT if ( s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ans += ( s [ i ] == '0' ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findMinSubStr ( arr , n , string ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT uSet . add ( arr [ i ] ) NEW_LINE DEDENT findSubStr ( string , 0 , 0 ) NEW_LINE DEDENT
def printChar ( string , n ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( freq [ ord ( string [ i ] ) - ord ( 'a' ) ] % 2 == 0 ) : NEW_LINE INDENT print ( string [ i ] , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def find_digit ( s , n ) : NEW_LINE INDENT first_digit = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] < '0' or s [ i ] > '9' : NEW_LINE INDENT first_digit = i NEW_LINE break NEW_LINE DEDENT DEDENT first_digit += 1 NEW_LINE s_len = first_digit NEW_LINE num = 0 NEW_LINE pw = 1 NEW_LINE i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if s [ i ] >= '0' and s [ i ] <= '9' : NEW_LINE INDENT digit = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE num = num + ( pw * digit ) NEW_LINE if num >= s_len : NEW_LINE INDENT return - 1 NEW_LINE DEDENT pw = pw * 10 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT num = num * 10 NEW_LINE req = s_len - num NEW_LINE if req > 9 or req < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return req NEW_LINE DEDENT
def countSubString ( s , c , k ) : NEW_LINE INDENT leftCount = 0 NEW_LINE rightCount = 0 NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE freq = 0 NEW_LINE result = 0 NEW_LINE Len = len ( s ) NEW_LINE while ( s [ left ] != c and left < Len ) : NEW_LINE INDENT left += 1 NEW_LINE leftCount += 1 NEW_LINE DEDENT right = left + 1 NEW_LINE while ( freq != ( k - 1 ) and ( right - 1 ) < Len ) : NEW_LINE INDENT if ( s [ right ] == c ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT while ( left < Len and ( right - 1 ) < Len ) : NEW_LINE INDENT while ( s [ left ] != c and left < Len ) : NEW_LINE INDENT left += 1 NEW_LINE leftCount += 1 NEW_LINE DEDENT while ( right < Len and s [ right ] != c ) : NEW_LINE INDENT if ( s [ right ] == c ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT right += 1 NEW_LINE rightCount += 1 NEW_LINE DEDENT result = ( result + ( leftCount + 1 ) * ( rightCount + 1 ) ) NEW_LINE freq = k - 1 NEW_LINE leftCount = 0 NEW_LINE rightCount = 0 NEW_LINE left += 1 NEW_LINE right += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
def minOperations ( n , a , b , c ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE y = b [ i ] NEW_LINE z = c [ i ] NEW_LINE if ( x == y and y == z ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( x == y or y == z or x == z ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def preCalculate ( s , prefix ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix [ i ] [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT prefix [ i ] [ j ] += prefix [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
def check ( s , l ) : NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT DEDENT t = len ( pos ) NEW_LINE for i in range ( 1 , t ) : NEW_LINE INDENT if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def compute_lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 for i in range ( n ) ] NEW_LINE Len = 0 NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ Len ] ) : NEW_LINE INDENT Len += 1 NEW_LINE lps [ i ] = Len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( Len != 0 ) : NEW_LINE INDENT Len = lps [ Len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return lps NEW_LINE DEDENT
def printLastChar ( string ) : NEW_LINE INDENT string = string + " " NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] == ' ' : NEW_LINE INDENT print ( string [ i - 1 ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def getMinimizedSum ( string , length ) : NEW_LINE INDENT maxVal = - ( sys . maxsize - 1 ) NEW_LINE sum = 0 NEW_LINE occurrences = [ 0 ] * 26 NEW_LINE for i in range ( length ) : NEW_LINE INDENT occurrences [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE sum += ord ( string [ i ] ) NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT count = occurrences [ i ] * ( i + ord ( 'a' ) ) NEW_LINE maxVal = max ( maxVal , count ) NEW_LINE DEDENT return ( sum - maxVal ) NEW_LINE DEDENT
def substrDeletion ( string , length ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT DEDENT return min ( count0 , count1 ) NEW_LINE DEDENT
def printString ( Str1 , n ) : NEW_LINE INDENT ones = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str1 [ i ] == '1' ) : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT DEDENT used = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str1 [ i ] == '2' and used == False ) : NEW_LINE INDENT used = 1 NEW_LINE for j in range ( ones ) : NEW_LINE INDENT print ( "1" , end = "" ) NEW_LINE DEDENT DEDENT if ( Str1 [ i ] != '1' ) : NEW_LINE INDENT print ( Str1 [ i ] , end = "" ) NEW_LINE DEDENT DEDENT if ( used == False ) : NEW_LINE INDENT for j in range ( ones ) : NEW_LINE INDENT print ( "1" , end = "" ) NEW_LINE DEDENT DEDENT DEDENT
def Colour_Combination ( s ) : NEW_LINE INDENT temp = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) , 1 ) : NEW_LINE INDENT if ( temp != s [ i ] ) : NEW_LINE INDENT if ( ( temp == 'B' or temp == 'G' ) and ( s [ i ] == 'G' or s [ i ] == 'B' ) ) : NEW_LINE INDENT temp = 'Y' NEW_LINE DEDENT elif ( ( temp == 'B' or temp == 'Y' ) and ( s [ i ] == 'Y' or s [ i ] == 'B' ) ) : NEW_LINE INDENT temp = 'G' NEW_LINE DEDENT else : NEW_LINE INDENT temp = 'B' NEW_LINE DEDENT DEDENT DEDENT return temp NEW_LINE DEDENT
def reverse ( str1 , x ) : NEW_LINE INDENT n = ( len ( str1 ) - x ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( str1 [ i ] , end = "" ) NEW_LINE DEDENT for i in range ( n + x - 1 , n - 1 , - 1 ) : NEW_LINE INDENT print ( str1 [ i ] , end = "" ) NEW_LINE DEDENT for i in range ( n + x , len ( str1 ) ) : NEW_LINE INDENT print ( str1 [ i ] , end = "" ) NEW_LINE DEDENT DEDENT
def countSubStrings ( string , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if string [ i ] == string [ 0 ] : NEW_LINE INDENT count += subStringsStartingHere ( string , n , i ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maxFreq ( s , a , b ) : NEW_LINE INDENT fre = [ 0 for i in range ( 10 ) ] NEW_LINE n = len ( s ) NEW_LINE if ( a > b ) : NEW_LINE INDENT swap ( a , b ) NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT a = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE fre [ a ] += 1 NEW_LINE DEDENT if ( fre [ a ] == 0 and fre [ b ] == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( fre [ a ] >= fre [ b ] ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT
def sumProdOfPrimeFreq ( s ) : NEW_LINE INDENT prime = [ True ] * ( len ( s ) + 2 ) NEW_LINE SieveofEratosthenes ( prime , len ( s ) + 1 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] = ( m [ s [ i ] ] + 1 ) if s [ i ] in m else 1 NEW_LINE DEDENT s = 0 NEW_LINE product = 1 NEW_LINE for it in m : NEW_LINE INDENT if prime [ m [ it ] ] : NEW_LINE INDENT s += m [ it ] NEW_LINE product *= m [ it ] NEW_LINE DEDENT DEDENT print ( "Sum =" , s ) NEW_LINE print ( "Product =" , product ) NEW_LINE DEDENT
def StringMatch ( S ) : NEW_LINE INDENT lo , hi = 0 , len ( S ) NEW_LINE ans = [ ] NEW_LINE for x in S : NEW_LINE INDENT if x == 'I' : NEW_LINE INDENT ans . append ( lo ) NEW_LINE lo += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( hi ) NEW_LINE hi -= 1 NEW_LINE DEDENT DEDENT return ans + [ lo ] NEW_LINE DEDENT
def CountCharacters ( str1 , l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE len1 = len ( str1 ) NEW_LINE for i in str1 : NEW_LINE INDENT if ( l <= ord ( i ) and ord ( i ) <= r ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE print ( i , end = " " ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def countPermutations ( str ) : NEW_LINE INDENT even = math . floor ( len ( str ) / 2 ) NEW_LINE odd = len ( str ) - even NEW_LINE ways = 0 NEW_LINE freq = [ 0 ] * 26 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT nvowels = ( freq [ 0 ] + freq [ 4 ] + freq [ 8 ] + freq [ 14 ] + freq [ 20 ] ) NEW_LINE nconsonants = len ( str ) - nvowels NEW_LINE ways = ( npr ( odd , nvowels ) * npr ( nconsonants , nconsonants ) ) NEW_LINE return int ( ways ) NEW_LINE DEDENT
def isVowel ( ch ) : NEW_LINE INDENT if ( ch != 'a' and ch != 'e' and ch != 'i' and ch != 'o' and ch != 'u' ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def maxLength ( s , n ) : NEW_LINE INDENT right = 0 NEW_LINE left = 0 NEW_LINE coun = 0 NEW_LINE max_length = - ( sys . maxsize - 1 ) NEW_LINE s = s + '1' NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if s [ i ] == 'o' : NEW_LINE INDENT coun += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if coun > max_length : NEW_LINE INDENT right = 0 NEW_LINE left = 0 NEW_LINE if s [ i ] == 'x' : NEW_LINE INDENT right = 1 NEW_LINE DEDENT if i - coun > 0 and s [ i - coun - 1 ] == 'x' : NEW_LINE INDENT left = 1 NEW_LINE DEDENT coun = math . ceil ( float ( coun / ( right + left ) ) ) NEW_LINE max_length = max ( max_length , coun ) NEW_LINE DEDENT coun = 0 NEW_LINE DEDENT DEDENT return max_length NEW_LINE DEDENT
def is_possible ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE one = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT if ( l % 2 == 0 ) : NEW_LINE INDENT return ( one == zero ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( abs ( one - zero ) == 1 ) NEW_LINE DEDENT DEDENT
def oddEquivalent ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def isPalindrome ( str ) : NEW_LINE INDENT firstChar = 0 NEW_LINE lastChar = len ( str ) - 1 NEW_LINE ch = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT firstChar = firstPos ( str , firstChar , lastChar ) NEW_LINE lastChar = lastPos ( str , lastChar , firstChar ) NEW_LINE if ( lastChar < 0 or firstChar < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( str [ firstChar ] == str [ lastChar ] ) : NEW_LINE INDENT firstChar += 1 NEW_LINE lastChar -= 1 NEW_LINE continue NEW_LINE DEDENT ch = False NEW_LINE break NEW_LINE DEDENT return ( ch ) NEW_LINE DEDENT
def find ( s ) : NEW_LINE INDENT Max = j = countk = countr = 0 NEW_LINE table = [ [ 0 , 0 ] for i in range ( len ( s ) ) ] NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == 'R' : NEW_LINE INDENT countr += 1 NEW_LINE DEDENT else : NEW_LINE INDENT table [ j ] [ 0 ] = countr NEW_LINE j += 1 NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == 'K' : NEW_LINE INDENT countk += 1 NEW_LINE table [ j ] [ 1 ] = countk NEW_LINE j -= 1 NEW_LINE DEDENT if min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) > Max : NEW_LINE INDENT Max = min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) NEW_LINE DEDENT DEDENT return Max NEW_LINE DEDENT
def LongestSequence ( fre , n ) : NEW_LINE INDENT for i in range ( MAX_CHAR - 1 , - 1 , - 1 ) : NEW_LINE INDENT mi = fre [ 0 ] [ i ] NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT mi = min ( fre [ j ] [ i ] , mi ) NEW_LINE DEDENT while mi : NEW_LINE INDENT print ( chr ( ord ( 'a' ) + i ) , end = "" ) NEW_LINE mi -= 1 NEW_LINE DEDENT DEDENT DEDENT
def firstNonRepeating ( string ) : NEW_LINE INDENT arr = [ - 1 for i in range ( NO_OF_CHARS ) ] NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if arr [ ord ( string [ i ] ) ] == - 1 : NEW_LINE INDENT arr [ ord ( string [ i ] ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT arr [ ord ( string [ i ] ) ] = - 2 NEW_LINE DEDENT DEDENT res = 10 ** 18 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if arr [ i ] >= 0 : NEW_LINE INDENT res = min ( res , arr [ i ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def preComputeCoeff ( ) : NEW_LINE INDENT for i in range ( Max ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT nCr [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT nCr [ i ] [ j ] = ( nCr [ i - 1 ] [ j - 1 ] + nCr [ i - 1 ] [ j ] ) % mod NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countNonEmptySubstr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE return int ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT
def countWays ( s ) : NEW_LINE INDENT count = [ 0 ] * 26 NEW_LINE for x in s : NEW_LINE INDENT count [ ord ( x ) - ord ( 'a' ) ] = ( count [ ord ( x ) - ord ( 'a' ) ] ) + 1 NEW_LINE DEDENT count [ ord ( s [ 0 ] ) - ord ( 'a' ) ] = 1 NEW_LINE ans = 1 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT ans *= count [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isPerfectSquareString ( str ) : NEW_LINE INDENT sum = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT sum = sum + ord ( str [ i ] ) NEW_LINE DEDENT squareRoot = math . sqrt ( sum ) NEW_LINE return ( ( squareRoot - math . floor ( squareRoot ) ) == 0 ) NEW_LINE DEDENT
def findSubstrings ( s , k ) : NEW_LINE INDENT ans = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = [ 0 ] * 26 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT cnt [ ord ( s [ j ] ) - ord ( 'a' ) ] += 1 NEW_LINE if ( cnt [ ord ( s [ j ] ) - ord ( 'a' ) ] <= k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def isPanDigital ( s ) : NEW_LINE INDENT digits = [ False ] * 10 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT digits [ int ( s [ i ] ) - int ( '0' ) ] = True NEW_LINE DEDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT if ( digits [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def combinedSum ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c_sum = 0 NEW_LINE ran = ( 1 << n ) - 1 NEW_LINE for i in range ( ran + 1 ) : NEW_LINE INDENT c_sum += findSubSequence ( s , i ) NEW_LINE DEDENT return c_sum NEW_LINE DEDENT
def numberOfPossiblePallindrome ( string , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if string [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ string [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ string [ i ] ] = 1 NEW_LINE DEDENT DEDENT fi = 0 NEW_LINE for it in mp : NEW_LINE INDENT if ( mp [ it ] % 2 == 0 ) : NEW_LINE INDENT fi = mp [ it ] // 2 NEW_LINE DEDENT else : NEW_LINE INDENT fi = ( mp [ it ] - 1 ) // 2 NEW_LINE k += 1 NEW_LINE DEDENT num = num + fi NEW_LINE den = den * fact ( fi ) NEW_LINE DEDENT if ( num != 0 ) : NEW_LINE INDENT num = fact ( num ) NEW_LINE DEDENT ans = num // den NEW_LINE if ( k != 0 ) : NEW_LINE INDENT ans = ans * k NEW_LINE DEDENT return ( ans ) NEW_LINE DEDENT
def totalConsonants ( string ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( isConsonant ( string [ i ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def convert ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE string = list ( string ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( string [ i ] == ' ' ) : NEW_LINE INDENT string [ i ] = '_' NEW_LINE DEDENT else : NEW_LINE INDENT string [ i ] = string [ i ] . lower ( ) NEW_LINE DEDENT DEDENT string = "" . join ( string ) NEW_LINE print ( string ) NEW_LINE DEDENT
def isEven ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE dotSeen = False NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' and dotSeen == False ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == '.' ) : NEW_LINE INDENT dotSeen = True NEW_LINE continue NEW_LINE DEDENT if ( ( int ) ( s [ i ] ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == 'A' or c == 'E' or c == 'I' or c == 'O' or c == 'U' or c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' ) NEW_LINE DEDENT
def countReduce ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT res += abs ( int ( ord ( str [ i ] ) ) - int ( ord ( str [ n - i - 1 ] ) ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def reverse ( num , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT temp = num [ i ] NEW_LINE num [ i ] = num [ j ] NEW_LINE num [ j ] = temp NEW_LINE i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT DEDENT
def findWinner ( votes ) : NEW_LINE INDENT mapObj = defaultdict ( int ) NEW_LINE for st in votes : NEW_LINE INDENT mapObj [ st ] += 1 NEW_LINE DEDENT maxValueInMap = 0 NEW_LINE winner = "" NEW_LINE for entry in mapObj : NEW_LINE INDENT key = entry NEW_LINE val = mapObj [ entry ] NEW_LINE if ( val > maxValueInMap ) : NEW_LINE INDENT maxValueInMap = val NEW_LINE winner = key NEW_LINE DEDENT elif ( val == maxValueInMap and winner > key ) : NEW_LINE INDENT winner = key NEW_LINE DEDENT DEDENT print ( winner ) NEW_LINE DEDENT
def distributingBalls ( k , n , string ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def check ( freq , k ) : NEW_LINE INDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] and freq [ i ] != k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countSets ( a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT u = 0 NEW_LINE v = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if a [ i ] [ j ] : NEW_LINE INDENT u += 1 NEW_LINE DEDENT else : NEW_LINE INDENT v += 1 NEW_LINE DEDENT DEDENT res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT u = 0 NEW_LINE v = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] [ i ] : NEW_LINE INDENT u += 1 NEW_LINE DEDENT else : NEW_LINE INDENT v += 1 NEW_LINE DEDENT DEDENT res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 NEW_LINE DEDENT return res - ( n * m ) NEW_LINE DEDENT
def traverseTree ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT while ( root ) : NEW_LINE INDENT print ( root . data , end = " " ) NEW_LINE if ( root . child ) : NEW_LINE INDENT traverseTree ( root . child ) NEW_LINE DEDENT root = root . Next NEW_LINE DEDENT DEDENT
def calculateEnergy ( mat , n ) : NEW_LINE INDENT tot_energy = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT q = mat [ i ] [ j ] // n NEW_LINE i_des = q NEW_LINE j_des = mat [ i ] [ j ] - ( n * q ) NEW_LINE tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) ) NEW_LINE DEDENT DEDENT return tot_energy NEW_LINE DEDENT
def countUnique ( mat , n , m ) : NEW_LINE INDENT uniquecount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] and isUnique ( mat , i , j , n , m ) ) : NEW_LINE INDENT uniquecount += 1 NEW_LINE DEDENT DEDENT DEDENT return uniquecount NEW_LINE DEDENT
def uniqueCharacters ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def largest_alphabet ( a , n ) : NEW_LINE INDENT max = 'A' NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > max ) : NEW_LINE INDENT max = a [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def isPalRec ( st , s , e ) : NEW_LINE INDENT if ( s == e ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( st [ s ] != st [ e ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( s < e + 1 ) : NEW_LINE INDENT return isPalRec ( st , s + 1 , e - 1 ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def evenNumSubstring ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , length , 1 ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n - i + 1 ) : NEW_LINE INDENT if ( checkEquality ( s [ i : i + j ] ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def unique ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE s . sort ( ) NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE break NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def qType1 ( tree , l , x , str1 ) : NEW_LINE INDENT update ( tree , l , - 1 , ord ( str1 [ l - 1 ] ) - 97 + 1 ) NEW_LINE list1 = list ( str1 ) NEW_LINE list1 [ l - 1 ] = x NEW_LINE str1 = '' . join ( list1 ) NEW_LINE update ( tree , l , 1 , ord ( str1 [ l - 1 ] ) - 97 + 1 ) NEW_LINE DEDENT
def countPairs ( str1 ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def findMinLength ( arr , n ) : NEW_LINE INDENT min = len ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( len ( arr [ i ] ) < min ) : NEW_LINE INDENT min = len ( arr [ i ] ) NEW_LINE DEDENT DEDENT return ( min ) NEW_LINE DEDENT
def areDistinct ( strr , i , j ) : NEW_LINE INDENT visited = [ 0 ] * ( 26 ) NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT if ( visited [ ord ( strr [ k ] ) - ord ( 'a' ) ] == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited [ ord ( strr [ k ] ) - ord ( 'a' ) ] = True NEW_LINE DEDENT return True NEW_LINE DEDENT
def printRLE ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT count = 1 NEW_LINE while ( i < n - 1 and st [ i ] == st [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE print ( st [ i - 1 ] + str ( count ) , end = "" ) NEW_LINE DEDENT DEDENT
def antiSpiralTraversal ( m , n , a ) : NEW_LINE INDENT k = 0 NEW_LINE l = 0 NEW_LINE stk = [ ] NEW_LINE while ( k <= m and l <= n ) : NEW_LINE INDENT for i in range ( l , n + 1 ) : NEW_LINE INDENT stk . append ( a [ k ] [ i ] ) NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m + 1 ) : NEW_LINE INDENT stk . append ( a [ i ] [ n ] ) NEW_LINE DEDENT n -= 1 NEW_LINE if ( k <= m ) : NEW_LINE INDENT for i in range ( n , l - 1 , - 1 ) : NEW_LINE INDENT stk . append ( a [ m ] [ i ] ) NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l <= n ) : NEW_LINE INDENT for i in range ( m , k - 1 , - 1 ) : NEW_LINE INDENT stk . append ( a [ i ] [ l ] ) NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT while len ( stk ) != 0 : NEW_LINE INDENT print ( str ( stk [ - 1 ] ) , end = " " ) NEW_LINE stk . pop ( ) NEW_LINE DEDENT DEDENT
def findNormal ( mat , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += mat [ i ] [ j ] * mat [ i ] [ j ] NEW_LINE DEDENT DEDENT return math . floor ( math . sqrt ( sum ) ) NEW_LINE DEDENT
def countExpPaths ( node , x ) : NEW_LINE INDENT return evenPaths ( node , 0 , x ) NEW_LINE DEDENT
def evenPaths ( node , count ) : NEW_LINE INDENT if ( node == None or ( node . key % 2 != 0 ) ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( not node . left and not node . right ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT count = evenPaths ( node . left , count ) NEW_LINE return evenPaths ( node . right , count ) NEW_LINE DEDENT
def countEvenPaths ( node ) : NEW_LINE INDENT return evenPaths ( node , 0 ) NEW_LINE DEDENT
def dfs ( u , count ) : NEW_LINE INDENT visited [ u ] = True NEW_LINE temp = 0 NEW_LINE global startnode , maxi NEW_LINE for i in range ( 0 , len ( adjacent [ u ] ) ) : NEW_LINE INDENT if not visited [ adjacent [ u ] [ i ] ] : NEW_LINE INDENT temp += 1 NEW_LINE dfs ( adjacent [ u ] [ i ] , count + 1 ) NEW_LINE DEDENT DEDENT if temp == 0 : NEW_LINE INDENT if maxi < count : NEW_LINE INDENT maxi = count NEW_LINE startnode = u NEW_LINE DEDENT DEDENT DEDENT
def insertEdge ( u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT
def canPaint ( nodes , n , m ) : NEW_LINE INDENT visited = [ 0 for _ in range ( n + 1 ) ] NEW_LINE maxColors = 1 NEW_LINE for _ in range ( 1 , n + 1 ) : NEW_LINE INDENT if visited [ _ ] : NEW_LINE INDENT continue NEW_LINE DEDENT visited [ _ ] = 1 NEW_LINE q = Queue ( ) NEW_LINE q . put ( _ ) NEW_LINE while not q . empty ( ) : NEW_LINE INDENT top = q . get ( ) NEW_LINE for _ in nodes [ top ] . edges : NEW_LINE INDENT if nodes [ top ] . color == nodes [ _ ] . color : NEW_LINE INDENT nodes [ _ ] . color += 1 NEW_LINE DEDENT maxColors = max ( maxColors , max ( nodes [ top ] . color , nodes [ _ ] . color ) ) NEW_LINE if maxColors > m : NEW_LINE INDENT print ( maxColors ) NEW_LINE return 0 NEW_LINE DEDENT if not visited [ _ ] : NEW_LINE INDENT visited [ _ ] = 1 NEW_LINE q . put ( _ ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return 1 NEW_LINE DEDENT
def FastDoubling ( n , res ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT res [ 0 ] = 0 NEW_LINE res [ 1 ] = 1 NEW_LINE return NEW_LINE DEDENT FastDoubling ( ( n // 2 ) , res ) NEW_LINE a = res [ 0 ] NEW_LINE b = res [ 1 ] NEW_LINE c = 2 * b - a NEW_LINE if ( c < 0 ) : NEW_LINE INDENT c += MOD NEW_LINE DEDENT c = ( a * c ) % MOD NEW_LINE d = ( a * a + b * b ) % MOD NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT res [ 0 ] = c NEW_LINE res [ 1 ] = d NEW_LINE DEDENT else : NEW_LINE INDENT res [ 0 ] = d NEW_LINE res [ 1 ] = c + d NEW_LINE DEDENT DEDENT
def canPlace ( a , n , p , sep ) : NEW_LINE INDENT prisoners_placed = 1 NEW_LINE last_prisoner_placed = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT current_cell = a [ i ] NEW_LINE if ( current_cell - last_prisoner_placed >= sep ) : NEW_LINE INDENT prisoners_placed += 1 NEW_LINE last_prisoner_placed = current_cell NEW_LINE if ( prisoners_placed == p ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def _mergeSort ( arr , temp , left , right ) : NEW_LINE INDENT mid , inv_count = 0 , 0 NEW_LINE if ( right > left ) : NEW_LINE INDENT mid = ( right + left ) // 2 NEW_LINE inv_count = _mergeSort ( arr , temp , left , mid ) NEW_LINE inv_count += _mergeSort ( arr , temp , mid + 1 , right ) NEW_LINE inv_count += merge ( arr , temp , left , mid + 1 , right ) NEW_LINE DEDENT return inv_count NEW_LINE DEDENT
def minSteps ( height , N ) : NEW_LINE INDENT return minStepsRecur ( height , 0 , N , 0 ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE y = y / 2 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def minimumRectangleArea ( A , N ) : NEW_LINE INDENT ans = 0 NEW_LINE A . sort ( ) NEW_LINE ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT ans = min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def areaOftriangle ( side ) : NEW_LINE INDENT a = sqrt ( pow ( side / 2 , 2 ) + pow ( side / 2 , 2 ) ) NEW_LINE b = sqrt ( pow ( side , 2 ) + pow ( side / 2 , 2 ) ) NEW_LINE c = sqrt ( pow ( side , 2 ) + pow ( side / 2 , 2 ) ) NEW_LINE s = ( a + b + c ) / 2 NEW_LINE area = sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE return round ( area , 1 ) NEW_LINE DEDENT
def interceptLength ( a , b , c , i , j , k ) : NEW_LINE INDENT rad = radius ( a , b , c ) NEW_LINE dist = centerDistanceFromLine ( a , b , i , j , k ) NEW_LINE if ( rad < 0 or dist < 0 ) : NEW_LINE INDENT print ( "circle not possible" ) NEW_LINE return NEW_LINE DEDENT if ( dist > rad ) : NEW_LINE INDENT print ( "Line not cutting circle" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 * math . sqrt ( rad * rad - dist * dist ) ) NEW_LINE DEDENT DEDENT
def centralPoints ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT c1 = 0 NEW_LINE c2 = 0 NEW_LINE c3 = 0 NEW_LINE c4 = 0 NEW_LINE x = arr [ i ] [ 0 ] NEW_LINE y = arr [ i ] [ 1 ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( arr [ j ] [ 0 ] > x and arr [ j ] [ 1 ] == y ) : NEW_LINE INDENT c1 = 1 NEW_LINE DEDENT if ( arr [ j ] [ 1 ] > y and arr [ j ] [ 0 ] == x ) : NEW_LINE INDENT c2 = 1 NEW_LINE DEDENT if ( arr [ j ] [ 0 ] < x and arr [ j ] [ 1 ] == y ) : NEW_LINE INDENT c3 = 1 NEW_LINE DEDENT if ( arr [ j ] [ 1 ] < y and arr [ j ] [ 0 ] == x ) : NEW_LINE INDENT c4 = 1 NEW_LINE DEDENT DEDENT if ( c1 + c2 + c3 + c4 == 4 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def printMatrixDiagonal ( mat , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE isUp = True NEW_LINE while k < n * n : NEW_LINE INDENT if isUp : NEW_LINE INDENT while i >= 0 and j < n : NEW_LINE INDENT print ( str ( mat [ i ] [ j ] ) , end = " " ) NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE i -= 1 NEW_LINE DEDENT if i < 0 and j <= n - 1 : NEW_LINE INDENT i = 0 NEW_LINE DEDENT if j == n : NEW_LINE INDENT i = i + 2 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while j >= 0 and i < n : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " " ) NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT if j < 0 and i <= n - 1 : NEW_LINE INDENT j = 0 NEW_LINE DEDENT if i == n : NEW_LINE INDENT j = j + 2 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT isUp = not isUp NEW_LINE DEDENT DEDENT
def calculateSideLength ( L , N , K ) : NEW_LINE INDENT angle = findInteriorAngle ( N ) NEW_LINE length = L * pow ( math . sin ( angle / 2 ) , ( K - 1 ) ) NEW_LINE return length NEW_LINE DEDENT
def minimumTriangleArea ( a , b ) : NEW_LINE INDENT area = a * b NEW_LINE print ( area ) NEW_LINE DEDENT
def finalPosition ( a , b , M ) : NEW_LINE INDENT n = 0 NEW_LINE s = 0 NEW_LINE e = 0 NEW_LINE w = 0 NEW_LINE p = 'N' NEW_LINE for i in range ( M ) : NEW_LINE INDENT if ( p == 'N' ) : NEW_LINE INDENT if ( a [ i ] == 'U' ) : NEW_LINE INDENT p = 'N' NEW_LINE n = n + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == 'D' ) : NEW_LINE INDENT p = 'S' NEW_LINE s = s + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == 'R' ) : NEW_LINE INDENT p = 'E' NEW_LINE e = e + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == 'L' ) : NEW_LINE INDENT p = 'W' NEW_LINE w = w + b [ i ] NEW_LINE DEDENT DEDENT elif ( p == 'S' ) : NEW_LINE INDENT if ( a [ i ] == 'U' ) : NEW_LINE INDENT p = 'S' NEW_LINE s = s + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == 'D' ) : NEW_LINE INDENT p = 'N' NEW_LINE n = n + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == 'R' ) : NEW_LINE INDENT p = 'W' NEW_LINE w = w + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == 'L' ) : NEW_LINE INDENT p = 'E' NEW_LINE e = e + b [ i ] NEW_LINE DEDENT DEDENT elif ( p == 'E' ) : NEW_LINE INDENT if ( a [ i ] == 'U' ) : NEW_LINE INDENT p = 'E' NEW_LINE e = e + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == 'D' ) : NEW_LINE INDENT p = 'W' NEW_LINE w = w + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == 'R' ) : NEW_LINE INDENT p = 'S' NEW_LINE s = s + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == 'L' ) : NEW_LINE INDENT p = 'N' NEW_LINE n = n + b [ i ] NEW_LINE DEDENT DEDENT elif ( p == 'W' ) : NEW_LINE INDENT if ( a [ i ] == 'U' ) : NEW_LINE INDENT p = 'W' NEW_LINE w = w + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == 'D' ) : NEW_LINE INDENT p = 'E' NEW_LINE e = e + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == 'R' ) : NEW_LINE INDENT p = 'N' NEW_LINE n = n + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == 'L' ) : NEW_LINE INDENT p = 'S' NEW_LINE s = s + b [ i ] NEW_LINE DEDENT DEDENT DEDENT ver_disp = n - s NEW_LINE hor_disp = e - w NEW_LINE displacement = floor ( sqrt ( ( ver_disp * ver_disp ) + ( hor_disp * hor_disp ) ) + 1 ) NEW_LINE print ( displacement , p ) NEW_LINE DEDENT
def findPairs ( x , y , K ) : NEW_LINE INDENT n = len ( x ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( K * abs ( x [ i ] - x [ j ] ) >= abs ( y [ i ] - y [ j ] ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def pyramidSlantHeight ( pyramid_h , pyramid_s ) : NEW_LINE INDENT slant_height_pyramid = sqrt ( pow ( pyramid_s / 2 , 2 ) + pow ( pyramid_h , 2 ) ) NEW_LINE print ( "Slant height of pyramid is:" , "{:.5f}" . format ( slant_height_pyramid ) ) NEW_LINE DEDENT
def Area_Parallelogram2 ( a , b , gamma ) : NEW_LINE INDENT area = ( abs ( math . sin ( math . radians ( gamma ) ) ) ) * abs ( a * b ) NEW_LINE return area NEW_LINE DEDENT
def No_of_rectangles ( L , B , l , b ) : NEW_LINE INDENT if ( l > L ) or ( b > B ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( L - l + 1 ) * ( B - b + 1 ) NEW_LINE DEDENT DEDENT
def Area_of_Rhombus ( a , theta ) : NEW_LINE INDENT area = ( a ** 2 ) * math . sin ( math . radians ( theta ) ) NEW_LINE return area NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) NEW_LINE DEDENT
def distanceEndpoints ( a , b , c ) : NEW_LINE INDENT angle = cal_cos ( c ) NEW_LINE return math . sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) NEW_LINE DEDENT
def perpenBisectorFromLine ( P , Q , a , b , c ) : NEW_LINE INDENT mid_point = [ 0 , 0 ] NEW_LINE mid_point [ 0 ] = ( P [ 0 ] + Q [ 0 ] ) / 2 NEW_LINE mid_point [ 1 ] = ( P [ 1 ] + Q [ 1 ] ) / 2 NEW_LINE c = ( - b * ( mid_point [ 0 ] ) + a * ( mid_point [ 1 ] ) ) NEW_LINE temp = a NEW_LINE a = - b NEW_LINE b = temp NEW_LINE return a , b , c NEW_LINE DEDENT
def circlearea ( R ) : NEW_LINE INDENT if ( R < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 3.14 * R * R ) / 4 NEW_LINE return a NEW_LINE DEDENT
def countIntersections ( n ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT
def area ( d1 , a ) : NEW_LINE INDENT d2 = ( 4 * ( a ** 2 ) - d1 ** 2 ) ** 0.5 NEW_LINE area = 0.5 * d1 * d2 NEW_LINE return ( area ) NEW_LINE DEDENT
def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 NEW_LINE return area NEW_LINE DEDENT
def findTriangles ( n ) : NEW_LINE INDENT num = n * ( n - 4 ) NEW_LINE print ( num ) NEW_LINE DEDENT
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def normal ( m , n ) : NEW_LINE INDENT N = ( ( abs ( m ) * abs ( n ) ) / math . sqrt ( ( abs ( m ) * abs ( m ) ) + ( abs ( n ) * abs ( n ) ) ) ) NEW_LINE return N NEW_LINE DEDENT
def isPossible ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxS = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE maxS = max ( a [ i ] , maxS ) NEW_LINE DEDENT if ( ( sum - maxS ) > maxS ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def pointIsOnLine ( m , c , x , y ) : NEW_LINE INDENT if ( y == ( ( m * x ) + c ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def polyarea ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE return A NEW_LINE DEDENT
def heptdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.802 * a NEW_LINE return round ( d , 3 ) NEW_LINE DEDENT
def trianglearea ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = ( 3 * math . sqrt ( 3 ) * math . pow ( a , 2 ) ) / 4 NEW_LINE return area NEW_LINE DEDENT
def circle_equation ( x1 , y1 , r ) : NEW_LINE INDENT a = - 2 * x1 NEW_LINE b = - 2 * y1 NEW_LINE c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) NEW_LINE print ( "x^2 + (" , a , "x) + " , end = "" ) NEW_LINE print ( "y^2 + (" , b , "y) = " , end = "" ) NEW_LINE print ( c , "." ) NEW_LINE DEDENT
def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE perimeter = n * s NEW_LINE return perimeter NEW_LINE DEDENT
def dis ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE DEDENT
def area ( b , h ) : NEW_LINE INDENT return ( 1 * b * h ) / 2 NEW_LINE DEDENT
def findRadiusOfIncircle ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT p = ( a + b + c ) / 2 NEW_LINE area = sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) NEW_LINE radius = area / p NEW_LINE return radius NEW_LINE DEDENT
def findVolume ( u , v , w , U , V , W , b ) : NEW_LINE INDENT uPow = pow ( u , 2 ) NEW_LINE vPow = pow ( v , 2 ) NEW_LINE wPow = pow ( w , 2 ) NEW_LINE UPow = pow ( U , 2 ) NEW_LINE VPow = pow ( V , 2 ) NEW_LINE WPow = pow ( W , 2 ) NEW_LINE a = ( 4 * ( uPow * vPow * wPow ) - uPow * pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ) NEW_LINE vol = sqrt ( a ) NEW_LINE vol /= b NEW_LINE print ( round ( vol , 4 ) ) NEW_LINE DEDENT
def rectanglearea ( r ) : NEW_LINE INDENT if r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = r * r NEW_LINE return a NEW_LINE DEDENT
def findMaximumPieces ( n ) : NEW_LINE INDENT x = n // 2 NEW_LINE return ( ( x + 1 ) * ( n - x + 1 ) ) NEW_LINE DEDENT
def solve ( M , N , s ) : NEW_LINE INDENT ans = ( ( math . ceil ( M / s ) ) * ( math . ceil ( N / s ) ) ) NEW_LINE return ans NEW_LINE DEDENT
def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT
def center ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( int ( ( x1 + x2 ) / 2 ) , end = "" ) NEW_LINE print ( "," , int ( ( y1 + y2 ) / 2 ) ) NEW_LINE DEDENT
def vol_of_octahedron ( side ) : NEW_LINE INDENT return ( ( side * side * side ) * ( math . sqrt ( 2 ) / 3 ) ) NEW_LINE DEDENT
def circumference ( r ) : NEW_LINE INDENT return ( 2 * PI * r ) NEW_LINE DEDENT
def floodFillUtil ( mat , x , y , prevV , newV ) : NEW_LINE INDENT if ( x < 0 or x >= M or y < 0 or y >= N ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( mat [ x ] [ y ] != prevV ) : NEW_LINE INDENT return NEW_LINE DEDENT mat [ x ] [ y ] = newV NEW_LINE floodFillUtil ( mat , x + 1 , y , prevV , newV ) NEW_LINE floodFillUtil ( mat , x - 1 , y , prevV , newV ) NEW_LINE floodFillUtil ( mat , x , y + 1 , prevV , newV ) NEW_LINE floodFillUtil ( mat , x , y - 1 , prevV , newV ) NEW_LINE DEDENT
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) NEW_LINE radSumSq = ( r1 + r2 ) * ( r1 + r2 ) NEW_LINE if ( distSq == radSumSq ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( distSq > radSumSq ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def area ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) NEW_LINE DEDENT
def numberOfDiagonals ( n ) : NEW_LINE INDENT return n * ( n - 3 ) / 2 NEW_LINE DEDENT
def orientation ( a , b , c ) : NEW_LINE INDENT res = ( ( b [ 1 ] - a [ 1 ] ) * ( c [ 0 ] - b [ 0 ] ) - ( c [ 1 ] - b [ 1 ] ) * ( b [ 0 ] - a [ 0 ] ) ) NEW_LINE if ( res == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( res > 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def countLattice ( r ) : NEW_LINE INDENT if ( r <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = 4 NEW_LINE for x in range ( 1 , r ) : NEW_LINE INDENT ySquare = r * r - x * x NEW_LINE y = int ( math . sqrt ( ySquare ) ) NEW_LINE if ( y * y == ySquare ) : NEW_LINE INDENT result += 4 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def minimumCost ( arr , N , X , Y ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( ( arr [ i ] & 1 ) and ( i % 2 == 0 ) ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( ( arr [ i ] % 2 ) == 0 and ( i & 1 ) ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT DEDENT cost1 = X * min ( odd_count , even_count ) NEW_LINE cost2 = Y * ( max ( odd_count , even_count ) - min ( odd_count , even_count ) ) NEW_LINE cost3 = ( odd_count + even_count ) * Y NEW_LINE return min ( cost1 + cost2 , cost3 ) NEW_LINE DEDENT
def root ( num , p ) : NEW_LINE INDENT left = - num NEW_LINE right = num NEW_LINE x = 0 NEW_LINE while ( True ) : NEW_LINE INDENT x = ( left + right ) / 2.0 NEW_LINE value = f ( x , p , num ) NEW_LINE prime = f_prime ( x , p ) NEW_LINE if ( value * prime <= 0 ) : NEW_LINE INDENT left = x NEW_LINE DEDENT else : NEW_LINE INDENT right = x NEW_LINE DEDENT if ( value < 0.000001 and value >= 0 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT DEDENT
def countTriplets ( N ) : NEW_LINE INDENT cnt = 0 NEW_LINE for A in range ( 1 , N + 1 ) : NEW_LINE INDENT for B in range ( 1 , N // A + 1 ) : NEW_LINE INDENT cnt += N // ( A * B ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def nearestRight ( arr , N , steps ) : NEW_LINE INDENT R = 2 * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT R = N + i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT R = i NEW_LINE DEDENT steps [ i ] = min ( steps [ i ] , R - i ) NEW_LINE DEDENT DEDENT
def updateArray ( arr , K ) : NEW_LINE INDENT sum = 0 NEW_LINE res = [ ] NEW_LINE for i in range ( 0 , int ( len ( arr ) ) ) : NEW_LINE INDENT if ( arr [ i ] < K ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( sum != 0 ) : NEW_LINE INDENT res . append ( sum ) NEW_LINE DEDENT sum = 0 NEW_LINE res . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT if ( sum != 0 ) : NEW_LINE INDENT res . append ( sum ) NEW_LINE DEDENT for it in res : NEW_LINE INDENT print ( it , end = " " ) NEW_LINE DEDENT DEDENT
def checkSameDigits ( N ) : NEW_LINE INDENT digit = N % 10 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT current_digit = N % 10 NEW_LINE N = N // 10 NEW_LINE if ( current_digit != digit ) : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT return "Yes" NEW_LINE DEDENT
def maxPossibleMoves ( X , Y , A , B ) : NEW_LINE INDENT ans = 0 NEW_LINE L = 1 NEW_LINE R = MAXN NEW_LINE while ( L <= R ) : NEW_LINE INDENT Mid = ( L + R ) // 2 NEW_LINE if ( can ( Mid , X , Y , A , B ) ) : NEW_LINE INDENT L = Mid + 1 NEW_LINE ans = max ( ans , Mid ) NEW_LINE DEDENT else : NEW_LINE INDENT R = Mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def possiblePair ( X , Y ) : NEW_LINE INDENT Z = Y - X NEW_LINE if ( Z < 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return 0 NEW_LINE DEDENT for k in range ( MaxBit ) : NEW_LINE INDENT bit1 = ( Z >> k ) & 1 NEW_LINE bit2 = ( Z >> k ) & 1 NEW_LINE if ( bit1 == 1 and bit2 == 0 ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT print ( Z , X ) NEW_LINE return 0 NEW_LINE DEDENT
def minSumDifference ( ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ar [ i ] NEW_LINE DEDENT rem = sum % n NEW_LINE return rem * ( n - rem ) NEW_LINE DEDENT
def minSteps ( N ) : NEW_LINE INDENT res = int ( ( sqrt ( 1 + 8 * N ) - 1 ) // 2 ) NEW_LINE return res NEW_LINE DEDENT
def oppositeFaceOfDice ( N ) : NEW_LINE INDENT ans = 7 - N NEW_LINE print ( ans ) NEW_LINE DEDENT
def IsEvenPath ( Source , Destination ) : NEW_LINE INDENT x_dif = abs ( Source [ 0 ] - Destination [ 0 ] ) NEW_LINE y_dif = abs ( Source [ 1 ] - Destination [ 1 ] ) NEW_LINE minsteps = x_dif + y_dif NEW_LINE if ( minsteps % 2 == 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def findFraction ( x , y , n ) : NEW_LINE INDENT A = - 1 NEW_LINE B = - 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT d = ( i * x ) // y NEW_LINE if ( d >= 0 and ( A == - 1 or ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) : NEW_LINE INDENT A = d NEW_LINE B = i NEW_LINE DEDENT d += 1 NEW_LINE if ( d >= 0 and ( A == - 1 or ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) : NEW_LINE INDENT A = d NEW_LINE B = i NEW_LINE DEDENT DEDENT print ( str ( A ) + "/" + str ( B ) ) NEW_LINE DEDENT
def countKAverageSubarrays ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for L in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for R in range ( L , n , 1 ) : NEW_LINE INDENT sum += arr [ R ] NEW_LINE len1 = ( R - L + 1 ) NEW_LINE if ( sum % len1 == 0 ) : NEW_LINE INDENT avg = sum // len1 NEW_LINE if ( avg == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT y = y >> 1 NEW_LINE x = x * x NEW_LINE DEDENT return res NEW_LINE DEDENT
def numberOfPairs ( N , arr ) : NEW_LINE INDENT global adj , visited , num NEW_LINE adj = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT adj . append ( [ ] ) NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT adj [ arr [ i ] [ 0 ] ] . append ( arr [ i ] [ 1 ] ) NEW_LINE adj [ arr [ i ] [ 1 ] ] . append ( arr [ i ] [ 0 ] ) NEW_LINE DEDENT visited = [ False ] * ( N ) NEW_LINE v = [ ] NEW_LINE num = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( not visited [ i ] ) : NEW_LINE INDENT dfs ( i ) NEW_LINE v . append ( num ) NEW_LINE num = 0 NEW_LINE DEDENT DEDENT ans = N * int ( ( N - 1 ) / 2 ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT ans -= ( v [ i ] * int ( ( v [ i ] - 1 ) / 2 ) ) NEW_LINE DEDENT ans += 1 NEW_LINE print ( ans ) NEW_LINE DEDENT
def isPossible ( W , B , D ) : NEW_LINE INDENT if ( W > B ) : NEW_LINE INDENT temp = W NEW_LINE W = B NEW_LINE B = temp NEW_LINE DEDENT if ( B > W * ( D + 1 ) ) : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT DEDENT
def tripletAndSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for bit in range ( 32 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & ( 1 << bit ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) // 6 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def largestK ( A , N ) : NEW_LINE INDENT l , r , flag = 0 , N - 1 , 0 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ l ] != A [ r ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT K = abs ( A [ 0 ] - A [ N - 1 ] ) NEW_LINE for i in range ( 1 , N // 2 ) : NEW_LINE INDENT K = gcd ( K , abs ( A [ i ] - A [ N - i - 1 ] ) ) NEW_LINE DEDENT return K NEW_LINE DEDENT
def NumberofSets ( N ) : NEW_LINE INDENT SieveOfEratosthenes ( N ) NEW_LINE if ( N == 2 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif ( N == 3 ) : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( N // 2 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def sumOfDivisors ( N ) : NEW_LINE INDENT return N NEW_LINE DEDENT
def findDigit ( N , D ) : NEW_LINE INDENT while ( N > 0 ) : NEW_LINE INDENT a = N % 10 NEW_LINE if ( a == D ) : NEW_LINE INDENT return True NEW_LINE DEDENT N /= 10 NEW_LINE DEDENT return False NEW_LINE DEDENT
def findXORS ( arr1 , arr2 , N , M ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT temp = arr1 [ i ] & arr2 [ j ] NEW_LINE res ^= temp NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findMedian ( root , node1 , node2 ) : NEW_LINE INDENT getIntermediateNodes ( root , node1 , node2 ) NEW_LINE nSize = len ( interNodes ) NEW_LINE if nSize % 2 == 1 : NEW_LINE INDENT return interNodes [ int ( nSize / 2 ) ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( interNodes [ int ( ( nSize - 1 ) / 2 ) ] + interNodes [ nSize / 2 ] ) / 2 NEW_LINE DEDENT DEDENT
def findDifference ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE total , odd , even = 1 , 1 , 0 NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while ( N > 1 ) : NEW_LINE INDENT N //= s [ N ] NEW_LINE if ( curr == s [ N ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT if ( curr == 2 ) : NEW_LINE INDENT total = total * ( cnt + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT total = total * ( cnt + 1 ) NEW_LINE odd = odd * ( cnt + 1 ) NEW_LINE DEDENT curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT even = total - odd NEW_LINE print ( abs ( even - odd ) ) NEW_LINE DEDENT
def countPrime ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , prime ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 1 ] = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] += dp [ i - 1 ] NEW_LINE if ( prime [ i ] == 1 and prime [ i - 2 ] == 1 ) : NEW_LINE INDENT dp [ i ] += 1 NEW_LINE DEDENT DEDENT print ( dp [ n ] ) NEW_LINE DEDENT
def findGCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return findGCD ( b , a % b ) NEW_LINE DEDENT
def findLCM ( a , b ) : NEW_LINE INDENT return ( a * b ) // findGCD ( a , b ) NEW_LINE DEDENT
def convert ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT ans = ( ans << 1 ) | i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def check ( Adj , Src , N , visited ) : NEW_LINE INDENT color = [ 0 ] * N NEW_LINE visited = [ True ] * Src NEW_LINE q = deque ( ) NEW_LINE q . append ( Src ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT u = q . popleft ( ) NEW_LINE Col = color [ u ] NEW_LINE for x in Adj [ u ] : NEW_LINE INDENT if ( visited [ x ] == True and color [ x ] == Col ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( visited [ x ] == False ) : NEW_LINE INDENT visited [ x ] = True NEW_LINE q . append ( x ) NEW_LINE color [ x ] = 1 - Col NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def average ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum // N * 1.0 - 1 NEW_LINE DEDENT
def checkWinner ( arr , N ) : NEW_LINE INDENT diff = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT diff -= arr [ i ] NEW_LINE DEDENT if ( diff % 2 == 0 ) : NEW_LINE INDENT print ( "A" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "B" ) NEW_LINE DEDENT DEDENT
def countAPs ( S , D ) : NEW_LINE INDENT S = S * 2 NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , S ) : NEW_LINE INDENT if i * i > S : NEW_LINE INDENT break NEW_LINE DEDENT if ( S % i == 0 ) : NEW_LINE INDENT if ( ( ( S // i ) - D * i + D ) % 2 == 0 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT if ( ( D * i - ( S // i ) + D ) % 2 == 0 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT
def buildSieve ( ) : NEW_LINE INDENT global sieve NEW_LINE for i in range ( 2 , 100 ) : NEW_LINE INDENT sieve [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( sieve [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i * i , 100 , i ) : NEW_LINE INDENT sieve [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) + 1 ) , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return ( count ) NEW_LINE DEDENT
def numOfPairs ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( coprime ( int ( arr [ i ] ) , int ( arr [ j ] ) ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = int ( log2 ( arr [ i ] ) ) NEW_LINE freq [ x ] = freq . get ( x , 0 ) + 1 NEW_LINE DEDENT pairs = 0 NEW_LINE for i in freq : NEW_LINE INDENT pairs += freq [ i ] - 1 NEW_LINE DEDENT return pairs NEW_LINE DEDENT
def sumOfDigits ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT sum += N % 10 NEW_LINE N //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
