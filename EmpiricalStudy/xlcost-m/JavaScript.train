function isPerfect ( N ) { let sumOfDivisors = 1 ; for ( let i = 2 ; i <= Math . floor ( N / 2 ) ; ++ i ) { if ( N % i === 0 ) { sumOfDivisors += i ; } } if ( sumOfDivisors === N ) { return 1 ; } else return 0 ; }
function countPerfectNumbers ( arr , N ) { for ( let i = 0 ; i < N ; ++ i ) { if ( isPerfect ( arr [ i ] ) ) { let sum = sumOfDigits ( arr [ i ] ) ; if ( isPerfect ( sum ) ) { document . write ( arr [ i ] + "▁" ) ; } } } }
function issafe ( m , n , i , j ) { if ( i < 0 ) return false ; if ( j < 0 ) return false ; if ( i >= m ) return false ; if ( j >= n ) return false ; return true ; }
function endpoints ( arr , m , n ) { let i = 0 ; let j = 0 ; let current_i = 0 ; let current_j = 0 ; let current_d = "r" ; let rcd = new Map ( ) ; rcd . set ( "l" , "u" ) ; rcd . set ( "u" , "r" ) ; rcd . set ( "r" , "d" ) ; rcd . set ( "d" , "l" ) ; while ( issafe ( m , n , i , j ) ) { current_i = i ; current_j = j ; if ( arr [ i ] [ j ] == 1 ) { let move_in = rcd . get ( current_d ) ; arr [ i ] [ j ] = 0 ; if ( move_in == "u" ) i -= 1 ; else if ( move_in == "d" ) i += 1 ; else if ( move_in == "l" ) j -= 1 ; else if ( move_in == "r" ) j += 1 ; current_d = move_in ; } else { if ( current_d == "u" ) i -= 1 ; else if ( current_d == "d" ) i += 1 ; else if ( current_d == "l" ) j -= 1 ; else if ( current_d == "r" ) j += 1 ; } } return [ current_i , current_j ] ; }
function maxPresum ( a , b ) { let X = Math . max ( a [ 0 ] , 0 ) ; for ( let i = 1 ; i < a . length ; i ++ ) { a [ i ] += a [ i - 1 ] ; X = Math . max ( X , a [ i ] ) ; } let Y = Math . max ( b [ 0 ] , 0 ) ; for ( let i = 1 ; i < b . length ; i ++ ) { b [ i ] += b [ i - 1 ] ; Y = Math . max ( Y , b [ i ] ) ; } return X + Y ; }
function findSum ( root ) { let que = [ ] ; que . push ( root ) ; let ans = 0 ; while ( que . length > 0 ) { let leaf = 0 ; let nonleaf = 0 ; let length = que . length ; while ( length > 0 ) { let temp = que . shift ( ) ; if ( temp . left == null && temp . right == null ) leaf += temp . val ; else nonleaf += temp . val ; if ( temp . left != null ) que . push ( temp . left ) ; if ( temp . right != null ) que . push ( temp . right ) ; length -= 1 ; } ans += leaf & nonleaf ; } return ans ; }
function fizzBuzz ( N ) { let count3 = 0 ; let count5 = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { count3 ++ ; count5 ++ ; let flag = false ; if ( count3 == 3 ) { document . write ( "Fizz" ) ; count3 = 0 ; flag = true ; } if ( count5 == 5 ) { document . write ( "Buzz" ) ; count5 = 0 ; flag = true ; } if ( ! flag ) { document . write ( i ) ; } document . write ( "▁" ) ; } }
function checkElementsOnDiagonal ( M , N ) { var flag = 1 ; SieveOfEratosthenes ( 1000000 ) ; for ( var i = 0 ; i < N ; i ++ ) { flag &= ( prime [ M [ i ] [ i ] ] && prime [ M [ i ] [ N - 1 - i ] ] ) ; } if ( flag ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function circularPermutation ( n , start ) { var res = [ 0 ] ; var ret = [ ] ; var index = - 1 ; for ( var k = 0 , add = 1 << k ; k < n ; k ++ , add = 1 << k ) { for ( var i = res . length - 1 ; i >= 0 ; i -- ) { if ( res [ i ] + add == start ) index = res . length ; res . push ( res [ i ] + add ) ; } } if ( start == 0 ) return res ; while ( ret . length < res . length ) { ret . push ( res [ index ] ) ; index = ( index + 1 ) % res . length ; } return ret ; }
function countPairs ( a , n ) { let count = 0 ; let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let y = a [ i ] ; if ( y != 0 && y != 1 ) { let x = ( ( y * 1.0 ) / ( 1 - y ) ) * y ; if ( mp . has ( x ) ) count += mp . get ( x ) ; } if ( mp . has ( y ) ) { mp . set ( y , mp . get ( y ) + 1 ) ; } else { mp . set ( y , 1 ) ; } } return count ; }
function sieveOfPrimes ( ) { sieve = Array ( 1000000 ) . fill ( 1 ) ; var N = 1000000 ; for ( var i = 2 ; i * i <= N ; i ++ ) { if ( sieve [ i ] == 0 ) continue ; for ( var j = i * i ; j <= N ; j += i ) sieve [ j ] = 0 ; } }
function getArray ( arr , N ) { var A = Array ( N ) . fill ( 0 ) ; var v = [ ] ; sieveOfPrimes ( ) ; for ( var i = 2 ; i <= 1e5 ; i ++ ) if ( sieve [ i ] ) v . push ( i ) ; var j = 0 ; for ( var i = 0 ; i < N ; i ++ ) { var ind = arr [ i ] ; if ( A [ i ] != 0 ) continue ; else if ( A [ ind ] != 0 ) A [ i ] = A [ ind ] ; else { var prime = v [ j ++ ] ; A [ i ] = prime ; A [ ind ] = A [ i ] ; } } for ( var i = 0 ; i < N ; i ++ ) { document . write ( A [ i ] + "▁" ) ; } }
function contains ( num , K , base ) { var isThere = 0 ; while ( num ) { var remainder = num % base ; if ( remainder == K ) { isThere = 1 ; } num /= base ; } return isThere ; }
function numberOfTiles ( n , m ) { if ( n % 2 == 1 ) { return - 1 ; } return ( m * n ) / 2 ; }
function canMakeEqual ( arr1 , arr2 , N ) { var count = 0 ; var arr1_one = 0 , arr1_zero = 0 ; var arr2_one = 0 , arr2_zero = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] == 1 ) { arr1_one ++ ; } else if ( arr1 [ i ] == 0 ) { arr1_zero ++ ; } if ( arr2 [ i ] == 1 ) { arr2_one ++ ; } else if ( arr2 [ i ] == 0 ) { arr2_zero ++ ; } } if ( arr1_one != arr2_one arr1_zero != arr2_zero ) { document . write ( "No" ) ; return ; } for ( var i = 0 ; i < N ; i ++ ) { count = count + ( arr1 [ i ] - arr2 [ i ] ) ; if ( count < 0 ) { document . write ( "No" ) ; return ; } } document . write ( "Yes" ) ; }
function findNthNumber ( N ) { let result = 0 ; let p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = parseInt ( N / 9 , 10 ) ; p = p * 10 ; } return result ; }
function cntMaxOperationToMakeN_1_0 ( arr , N ) { let cntOp = 0 ; let PQ = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { PQ . push ( arr [ i ] ) ; } PQ . sort ( function ( a , b ) { return a - b } ) ; PQ . reverse ( ) ; while ( PQ . length > 1 ) { let X = PQ [ 0 ] ; PQ . shift ( ) ; let Y = PQ [ 0 ] ; PQ . shift ( ) ; X -- ; Y -- ; if ( X != 0 ) { PQ . push ( X ) ; PQ . sort ( function ( a , b ) { return a - b } ) ; PQ . reverse ( ) ; } if ( Y != 0 ) { PQ . push ( Y ) ; PQ . sort ( function ( a , b ) { return a - b } ) ; PQ . reverse ( ) ; } cntOp += 1 ; } return cntOp ; }
function checkSamePosition ( arr , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { var temp = ( ( i + arr [ i ] ) % n + n ) % n ; if ( mp . has ( temp ) ) { document . write ( "Yes" ) ; return ; } if ( mp . has ( temp ) ) { mp . set ( temp , mp . get ( temp ) + 1 ) } else mp . set ( temp , 1 ) } document . write ( "No" ) ; }
function sumFib ( N ) { var num = Math . round ( Math . pow ( ( Math . sqrt ( 5 ) + 1 ) / 2.0 , N + 2 ) / Math . sqrt ( 5 ) ) ; document . write ( num - 1 ) ; }
function sumFib ( N ) { var num = ( ( 1 - Math . sqrt ( 5 ) ) / 2 ) ; var val = Math . round ( Math . abs ( 1 / ( Math . pow ( num , N + 2 ) + Math . pow ( num , N + 1 ) + Math . pow ( num , N ) + Math . pow ( num , N - 1 ) ) ) - 1 ) ; document . write ( val ) ; }
function poorPigs ( buckets , minutesToDie , minutesToTest ) { document . write ( Math . ceil ( Math . log ( buckets ) / Math . log ( ( minutesToTest / minutesToDie ) + 1 ) ) ) ; }
function countTrailingZeroes ( N ) { let res = parseInt ( Math . log ( N ^ ( N - 1 ) ) / Math . log ( 2 ) ) ; return res >= 0 ? res : 0 ; }
function maxProduct ( arr , N ) { var max_product = Number . MIN_VALUE ; var prefix_sum = 0 ; var sum = 0 ; for ( i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( i = 0 ; i < N - 1 ; i ++ ) { prefix_sum += arr [ i ] ; var X = prefix_sum ; var Y = sum - prefix_sum ; max_product = Math . max ( max_product , X * Y ) ; } document . write ( max_product ) ; }
function findMask ( K ) { let mask = 1 ; while ( ( K & mask ) == 0 ) { mask = mask << 1 ; } return mask ; }
function sameRightSetBitPos ( arr , N , K ) { let mask = findMask ( K ) ; let pos = ( K & mask ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & mask ) == pos ) document . write ( arr [ i ] + "▁" ) ; } }
function countPronic ( A , B ) { let count = 0 ; for ( let i = A ; i <= B ; i ++ ) { if ( checkPronic ( i ) ) { count ++ ; } } document . write ( count ) ; }
function pronic ( num ) { var N = parseInt ( Math . sqrt ( num ) ) ; if ( N * ( N + 1 ) <= num ) { return N ; } return N - 1 ; }
function countPronic ( A , B ) { return pronic ( B ) - pronic ( A - 1 ) ; }
function sameProductQuadruples ( nums , N ) { var umap = new Array ( 10000 ) . fill ( 0 ) ; var res = 0 ; for ( var i = 0 ; i < N ; ++ i ) { for ( var j = i + 1 ; j < N ; ++ j ) { var prod = nums [ i ] * nums [ j ] ; res += 8 * umap [ prod ] ; ++ umap [ prod ] ; } } document . write ( res ) ; }
function productExceptSelf ( arr , N ) { let product = 1 ; let z = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != 0 ) product *= arr [ i ] ; if ( arr [ i ] == 0 ) z += 1 ; } let a = Math . abs ( product ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( z == 1 ) { if ( arr [ i ] != 0 ) arr [ i ] = 0 ; else arr [ i ] = product ; continue ; } else if ( z > 1 ) { arr [ i ] = 0 ; continue ; } let b = Math . abs ( arr [ i ] ) ; let curr = Math . round ( Math . exp ( Math . log ( a ) - Math . log ( b ) ) ) ; if ( arr [ i ] < 0 && product < 0 ) arr [ i ] = curr ; else if ( arr [ i ] > 0 && product > 0 ) arr [ i ] = curr ; else arr [ i ] = - 1 * curr ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function getMax ( arr , ans , chosen , N ) { if ( arr . length == N ) { ans = Math . max ( ans , calcScr ( arr ) ) ; return ans ; } for ( let i = 0 ; i < N ; i ++ ) { if ( chosen [ i ] ) continue ; chosen [ i ] = true ; arr . push ( i ) ; ans = getMax ( arr , ans , chosen , N ) ; chosen [ i ] = false ; arr . pop ( ) ; } return ans ; }
function singleDigitSubarrayCount ( arr , N ) { let res = 0 ; let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } document . write ( res ) ; }
function maxSumAfterKReverse ( arr , K , N ) { let sum = Number . MIN_VALUE ; if ( K % 2 != 0 ) arr . reverse ( ) ; let currsum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { currsum += arr [ i ] ; sum = Math . max ( sum , currsum ) ; } document . write ( sum ) ; }
function isPossible ( N ) { return ( ( ( N & ( N - 1 ) ) & N ) ) ; }
function countElements ( N ) { var count = 0 ; for ( i = 1 ; i <= N ; i ++ ) { if ( isPossible ( i ) != 0 ) count ++ ; } document . write ( count ) ; }
function countElements ( N ) { var Cur_Ele = 1 ; var Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } document . write ( N - Count ) ; }
function SubMasks ( N ) { for ( let S = N ; S > 0 ; S = ( S - 1 ) & N ) { document . write ( S + "▁" ) ; } }
function power ( x , y ) { var res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % MOD ; y = y >> 1 ; x = ( x * x ) % MOD ; } return res ; }
function countPairs ( N ) { var high = power ( 2 , N ) ; var count = 0 ; for ( i = 0 ; i < high ; i ++ ) { for ( j = 0 ; j < high ; j ++ ) { var X = ( i ^ j ) ; var Y = ( i j ) ; if ( X == Y ) { count ++ ; } } } document . write ( count % MOD ) ; }
function power ( x , y ) { var res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % MOD ; y = y >> 1 ; x = ( x * x ) % MOD ; } return res ; }
function countPairs ( N ) { document . write ( power ( 3 , N ) ) ; }
function minSum ( A , N ) { let mp = new Map ( ) ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; mp [ A [ i ] ] ++ ; if ( mp . has ( A [ i ] ) ) { mp . set ( A [ i ] , mp . get ( A [ i ] ) + 1 ) } else { mp . set ( A [ i ] , 1 ) } } let minSum = Number . MAX_SAFE_INTEGER ; for ( let it of mp ) { minSum = Math . min ( minSum , sum - ( it [ 0 ] * it [ 1 ] ) ) ; } return minSum ; }
function minimumMoves ( a , n ) { let min_element = Number . MAX_VALUE ; let max_element = Number . MIN_VALUE ; let min_ind = - 1 ; let max_ind = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] <= min_element ) { min_element = a [ i ] ; min_ind = i ; } if ( a [ i ] > max_element ) { max_element = a [ i ] ; max_ind = i ; } } if ( max_ind == min_ind ) { return 0 ; } else if ( max_ind > min_ind ) { return max_ind + ( n - min_ind - 2 ) ; } else { return max_ind + n - min_ind - 1 ; } }
function isCycleExists ( arr , N ) { for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { document . write ( "Yes" ) ; return ; } } document . write ( "No" ) ; }
function findIndex ( arr , n , K ) { let sum = 0 ; let res = - 1 ; let mini = parseInt ( 1e9 ) ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( let i = 0 ; i < n ; i ++ ) { let temp = sum - arr [ i ] ; if ( temp % K == 0 ) { if ( res == - 1 mini > arr [ i ] ) { res = i + 1 ; mini = arr [ i ] ; } } } return res ; }
function minimumIncrement ( arr , N ) { if ( N % 2 != 0 ) { document . write ( "-1" ) ; System . exit ( 0 ) ; } var cntEven = 0 ; var cntOdd = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { cntEven += 1 ; } } cntOdd = N - cntEven ; return Math . abs ( cntEven - cntOdd ) / 2 ; }
function divisionalArrays ( arr , N ) { var sum = N ; var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } mp . forEach ( ( value , key ) => { if ( value > 1 ) { sum += value - 1 ; } } ) ; document . write ( sum ) ; }
function totalInversions ( arr , K , N ) { let inv = 0 ; let X = 0 ; let i , j ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { if ( arr [ i ] > arr [ j ] && i < j ) inv ++ ; if ( arr [ i ] > arr [ j ] ) X ++ ; } } let totalInv = X * K * ( K - 1 ) / 2 + inv * K ; document . write ( totalInv ) ; }
function findSize ( N ) { if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; let Size = 2 * findSize ( parseInt ( N / 2 , 10 ) ) + 1 ; return Size ; }
function CountOnes ( N , L , R ) { if ( L > R ) { return 0 ; } if ( N <= 1 ) { return N ; } let ret = 0 ; let M = parseInt ( N / 2 , 10 ) ; let Siz_M = findSize ( M ) ; if ( L <= Siz_M ) { ret += CountOnes ( parseInt ( N / 2 , 10 ) , L , Math . min ( Siz_M , R ) ) ; } if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; } if ( Siz_M + 1 < R ) { ret += CountOnes ( parseInt ( N / 2 , 10 ) , Math . max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; }
function Fact ( N ) { let result = 1 ; for ( let i = 1 ; i <= N ; i ++ ) { result = ( result * i ) ; } return result ; }
function numberOfWays ( M , arr , N ) { let B = new Array ( M ) . fill ( 0 ) ; let counter = new Array ( M + 1 ) . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != 0 ) { if ( B [ i % M ] == 0 ) { B [ i % M ] = arr [ i ] ; counter [ arr [ i ] ] ++ ; if ( counter [ arr [ i ] ] > 1 ) { document . write ( 0 ) ; return ; } } else if ( B [ i % M ] != arr [ i ] ) { document . write ( 0 ) ; return ; } } } let cnt = 0 ; for ( let i = 0 ; i < M ; i ++ ) { if ( B [ i ] == 0 ) { cnt ++ ; } } document . write ( Fact ( cnt ) ) ; }
function getMax ( arr , N , K ) { for ( i = 1 ; i < N ; i ++ ) { var cur_val = arr [ i ] ; while ( K >= i ) { if ( cur_val > 0 ) { arr [ 0 ] = arr [ 0 ] + 1 ; cur_val = cur_val - 1 ; K = K - i ; } else break ; } } document . write ( arr [ 0 ] ) ; }
function MaximumSum ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let x = 0 , y = i , sum = 0 ; for ( let j = i ; j < n ; j ++ ) { sum += arr [ x ++ ] [ y ++ ] ; } if ( sum > ans ) ans = sum ; } for ( let i = 1 ; i < n ; i ++ ) { let x = i , y = 0 , sum = 0 ; for ( let j = i ; j < n ; j ++ ) { sum += arr [ x ++ ] [ y ++ ] ; } if ( sum > ans ) ans = sum ; } return ans ; }
function numberOfIntegers ( arr , N ) { let cur_max = 0 , count = 0 ; if ( N == 1 ) { count = 1 ; } else { for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] > cur_max ) { cur_max = arr [ i ] ; if ( arr [ i ] > arr [ i + 1 ] ) { count ++ ; } } } if ( arr [ N - 1 ] > cur_max ) count ++ ; } document . write ( count ) ; }
function numberOfWays ( n , k ) { if ( n == 0 ) return 1 ; if ( k == 0 ) return 1 ; if ( n >= Math . pow ( 2 , k ) ) { let curr_val = Math . pow ( 2 , k ) ; return numberOfWays ( n - curr_val , k ) + numberOfWays ( n , k - 1 ) ; } else return numberOfWays ( n , k - 1 ) ; }
function possibleTriplets ( arr , N ) { var freq = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { freq ++ ; } } return ( freq * 1 * ( freq - 1 ) * ( freq - 2 ) ) / 6 ; }
function build ( tree , arr , start , end , index ) { if ( start == end ) { if ( start % 2 == 0 ) { tree [ index ] = arr [ start ] ; } else { tree [ index ] = - arr [ start ] ; } return ; } var mid = start + parseInt ( ( end - start ) / 2 ) ; build ( tree , arr , start , mid , 2 * index + 1 ) ; build ( tree , arr , mid + 1 , end , 2 * index + 2 ) ; tree [ index ] = tree [ 2 * index + 1 ] + tree [ 2 * index + 2 ] ; }
function update ( tree , index , start , end , pos , val ) { if ( start == end ) { if ( start % 2 == 0 ) { tree [ index ] = val ; } else { tree [ index ] = - val ; } return ; } var mid = start + parseInt ( ( end - start ) / 2 ) ; if ( mid >= pos ) { update ( tree , 2 * index + 1 , start , mid , pos , val ) ; } else { update ( tree , 2 * index + 2 , mid + 1 , end , pos , val ) ; } tree [ index ] = tree [ 2 * index + 1 ] + tree [ 2 * index + 2 ] ; }
function FindSum ( tree , start , end , L , R , index ) { if ( L > end R < start ) { return 0 ; } if ( L <= start && R >= end ) { return tree [ index ] ; } var mid = start + parseInt ( ( end - start ) / 2 ) ; var X = FindSum ( tree , start , mid , L , R , 2 * index + 1 ) ; var Y = FindSum ( tree , mid + 1 , end , L , R , 2 * index + 2 ) ; return X + Y ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function DistinctValues ( arr , N ) { var max_value = Number . MIN_VALUE ; for ( i = 0 ; i < N ; ++ i ) { max_value = Math . max ( max_value , arr [ i ] ) ; } var GCDArr = arr [ 0 ] ; for ( i = 1 ; i < N ; ++ i ) { GCDArr = gcd ( GCDArr , arr [ i ] ) ; } var answer = ( max_value / GCDArr ) + 1 ; return answer ; }
function findDay ( Y , B ) { let lyear , rest , totaldays , day ; Y = ( Y - 1 ) - B ; lyear = Math . floor ( Y / 4 ) ; rest = Y - lyear ; totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; day = ( totaldays % 7 ) ; if ( day == 0 ) document . write ( "Monday" ) ; else if ( day == 1 ) document . write ( "Tuesday" ) ; else if ( day == 2 ) document . write ( "Wednesday" ) ; else if ( day == 3 ) document . write ( "Thursday" ) ; else if ( day == 4 ) document . write ( "Friday" ) ; else if ( day == 5 ) document . write ( "Saturday" ) ; else if ( day == 6 ) document . write ( "Sunday" ) ; else document . write ( "INPUT▁YEAR▁IS▁WRONG!" ) ; }
function maxPossibleDiff ( arr , N ) { arr . push ( - 1 ) ; arr . reverse ( ) ; arr . push ( - 1 ) ; arr . reverse ( ) ; var maxDiff = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { maxDiff += arr [ i ] ; } if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { maxDiff -= arr [ i ] ; } } document . write ( maxDiff ) ; }
function printArray ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function modifyArray ( arr , N , Q , cntQuery ) { let arr1 = new Array ( N + 2 ) . fill ( 0 ) ; let arr2 = new Array ( N + 2 ) . fill ( 0 ) ; for ( let i = 0 ; i < cntQuery ; i ++ ) { let L = Q [ i ] [ 0 ] + 1 , R = Q [ i ] [ 1 ] + 1 ; arr1 [ L ] ++ ; arr1 [ R + 1 ] -- ; arr2 [ R + 1 ] -= R - L + 1 ; } for ( let i = 1 ; i <= N ; i ++ ) arr1 [ i ] += arr1 [ i - 1 ] ; for ( let i = 1 ; i <= N ; i ++ ) arr2 [ i ] += arr2 [ i - 1 ] + arr1 [ i ] ; for ( let i = 1 ; i <= N ; i ++ ) arr [ i - 1 ] = arr2 [ i ] ; prletArray ( arr , N ) ; }
function gcd ( x , y ) { if ( y == 0 ) return x ; return gcd ( y , x % y ) ; }
function lcm ( x , y ) { return ( x * y ) / gcd ( x , y ) ; }
function minimumCost ( x , y ) { var lcm_ = lcm ( x , y ) ; var costx = ( lcm_ - x ) / x ; var costy = ( lcm_ - y ) / y ; return costx + costy ; }
function findProduct ( number_1 , number_2 ) { if ( number_1 == Number . MIN_VALUE number_2 == Number . MIN_VALUE ) { return 0 ; } else return number_1 * number_2 ; }
function calculateProduct ( List , index ) { let highest = Math . max ( ... List [ index ] ) ; let lowest = Math . min ( ... List [ index ] ) ; if ( index + 1 == List . length ) { if ( lowest < 0 && highest >= 0 ) { return ( [ highest , lowest ] ) ; } else if ( lowest <= 0 && highest <= 0 ) { return ( [ Number . MIN_VALUE , lowest ] ) ; } else if ( lowest >= 0 && highest >= 0 ) { return ( [ highest , Number . MIN_VALUE ] ) ; } } let temp = calculateProduct ( List , index + 1 ) ; let positive = temp [ 0 ] ; let negative = temp [ 1 ] ; let highPos = findProduct ( highest , positive ) ; let highNeg = findProduct ( highest , negative ) ; let lowPos = findProduct ( lowest , positive ) ; let lowNeg = findProduct ( lowest , negative ) ; if ( lowest < 0 && highest >= 0 ) { return ( [ Math . max ( highPos , lowNeg ) , Math . min ( highNeg , lowPos ) ] ) ; } else if ( lowest <= 0 && highest <= 0 ) { return ( [ lowNeg , lowPos ] ) ; } else if ( lowest >= 0 && highest >= 0 ) { return ( [ Math . max ( lowPos , highPos ) , Math . min ( lowNeg , highNeg ) ] ) ; } return ( [ 0 , 0 ] ) ; }
function calculateSpan ( price , n , S ) { S [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( let j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } }
function power ( a , n , d ) { var res = 1 ; while ( n != 0 ) { if ( ( n % 2 ) != 0 ) { res = ( ( res % d ) * ( a % d ) ) % d ; } a = ( ( a % d ) * ( a % d ) ) % d ; n /= 2 ; } return res ; }
function gcd ( p , q , n ) { if ( p == q ) { return ( power ( p , n , mod ) + power ( q , n , mod ) ) % mod ; } var candidate = 1 ; var num = p - q ; var sq = parseInt ( Math . sqrt ( num ) ) ; for ( i = 1 ; i <= sq ; ++ i ) { if ( num % i == 0 ) { var X = power ( p , n , i ) ; var Y = power ( q , n , i ) ; var temp = ( X + Y ) % i ; if ( temp == 0 ) { candidate = Math . max ( candidate , i ) ; } temp = ( power ( p , n , num / i ) + power ( q , n , num / i ) ) % ( num / i ) ; if ( temp == 0 ) { candidate = Math . max ( candidate , num / i ) ; } } } return candidate % mod ; }
function minimumSubarrays ( arr , n ) { let current = "N" ; let answer = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( current == "N" ) { if ( arr [ i ] < arr [ i - 1 ] ) { current = "D" ; } else if ( arr [ i ] == arr [ i - 1 ] ) { current = "N" ; } else { current = "I" ; } } else if ( current == "I" ) { if ( arr [ i ] >= arr [ i - 1 ] ) { current = "I" ; } else { current = "N" ; answer += 1 ; } } else { if ( arr [ i ] <= arr [ i - 1 ] ) { current = "D" ; } else { current = "N" ; answer += 1 ; } } } document . write ( answer ) ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function calculateK ( x , y ) { var g = gcd ( x , y ) ; var n = y / g ; var res = n ; for ( i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { res -= ( res / i ) ; while ( n % i == 0 ) n /= i ; } } if ( n != 1 ) res -= ( res / n ) ; return res ; }
function nearestPowerOfTwo ( arr , N ) { for ( i = 0 ; i < N ; i ++ ) { var lg = parseInt ( ( Math . log ( arr [ i ] ) / Math . log ( 2 ) ) ) ; var a = parseInt ( ( Math . pow ( 2 , lg ) ) ) ; var b = parseInt ( ( Math . pow ( 2 , lg + 1 ) ) ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) document . write ( a + "▁" ) ; else document . write ( b + "▁" ) ; } }
function Conversion ( centi ) { let pixels = ( 96 * centi ) / 2.54 ; document . write ( pixels ) ; return 0 ; }
function minSwaps ( b ) { var n = b . length ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( ( b [ 0 ] [ 0 ] ^ b [ 0 ] [ j ] ^ b [ i ] [ 0 ] ^ b [ i ] [ j ] ) == 1 ) { return - 1 ; } } } var rowSum = 0 ; var colSum = 0 ; var rowSwap = 0 ; var colSwap = 0 ; for ( i = 0 ; i < n ; i ++ ) { rowSum += b [ i ] [ 0 ] ; colSum += b [ 0 ] [ i ] ; var cond1 = 0 ; var cond2 = 0 ; if ( b [ i ] [ 0 ] == i % 2 ) cond1 = 1 ; if ( b [ 0 ] [ i ] == i % 2 ) cond2 = 1 ; rowSwap += cond1 ; colSwap += cond2 ; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return - 1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return - 1 ; if ( n % 2 == 1 ) { if ( ( colSwap % 2 ) == 1 ) colSwap = n - colSwap ; if ( ( rowSwap % 2 ) == 1 ) rowSwap = n - rowSwap ; } else { colSwap = Math . min ( colSwap , n - colSwap ) ; rowSwap = Math . min ( rowSwap , n - rowSwap ) ; } return ( rowSwap + colSwap ) / 2 ; }
function maxNumTrailNine ( n , d ) { let res = n ; let cntDigits = parseInt ( Math . log ( n ) / Math . log ( 10 ) ) + 1 ; let p10 = 10 ; for ( let i = 1 ; i <= cntDigits ; i ++ ) { if ( n % p10 >= d ) { break ; } else { res = n - n % p10 - 1 ; } p10 = p10 * 10 ; } document . write ( res ) ; }
function MinimumNoOfWays ( arr , n ) { var mini_no_of_ways ; if ( n % 2 == 0 ) { mini_no_of_ways = n / 2 ; } else { mini_no_of_ways = n / 2 + 1 ; } return parseInt ( mini_no_of_ways ) ; }
function count_setbit ( N ) { let result = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) { if ( ( ( 1 << i ) & N ) > 0 ) { result ++ ; } } document . write ( result ) ; }
function cntWaysConsArray ( A , N ) { var total = 1 ; var oddArray = 1 ; for ( i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } document . write ( total - oddArray ) ; }
function invertBits ( n ) { var x = parseInt ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ; var m = 1 << x ; m = m | m - 1 ; n = n ^ m ; return n ; }
function invertSum ( A , B ) { var temp = countSetBits ( A ) + countSetBits ( B ) ; document . write ( invertBits ( temp ) ) ; }
function ValOfTheExpression ( n ) { let factorial = new Array ( n + 1 ) ; factorial [ 0 ] = factorial [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { factorial [ i ] = ( ( factorial [ i - 1 ] % mod ) * ( i % mod ) ) % mod ; } let dp = new Array ( n + 1 ) ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ i ] = ( ( dp [ i - 1 ] % mod ) * ( factorial [ i ] % mod ) ) % mod ; } return dp [ n ] ; }
function minChocolates ( a , n ) { let i = 0 , j = 0 ; let res = 0 , val = 1 ; while ( j < n - 1 ) { if ( a [ j ] > a [ j + 1 ] ) { j += 1 ; continue ; } if ( i == j ) res += val ; else { res += get_sum ( val , i , j ) ; } if ( a [ j ] < a [ j + 1 ] ) val += 1 ; else val = 1 ; j += 1 ; i = j ; } if ( i == j ) res += val ; else res += get_sum ( val , i , j ) ; return res ; }
function get_sum ( peak , start , end ) { let count = end - start + 1 ; peak = ( peak > count ) ? peak : count ; let s = peak + ( ( ( count - 1 ) * count ) >> 1 ) ; return s ; }
function RemoveElemArr ( arr , n , k ) { if ( n == 0 n == 1 ) return arr ; var j = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( j < k arr [ i ] > arr [ j - k ] ) { arr [ j ++ ] = arr [ i ] ; } } while ( arr . length > j ) { arr . pop ( ) ; } return arr ; }
function printArray ( arr ) { for ( var i = 0 ; i < arr . length ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function UtilRemov ( arr , n , k ) { arr = RemoveElemArr ( arr , n , k ) ; printArray ( arr ) ; }
function countNumberHavingKthBitSet ( N , K ) { let numbers_rightmost_setbit_K = 0 ; for ( let i = 1 ; i <= K ; i ++ ) { let numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } document . write ( numbers_rightmost_setbit_K ) ; }
function pairs_after_removing ( arr , N ) { var cntPairs = 0 ; var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } mp . forEach ( ( value , key ) => { var i = key ; cntPairs += mp . get ( i ) * ( mp . get ( i ) - 1 ) / 2 ; } ) ; for ( var i = 0 ; i < N ; i ++ ) { var pairs_after_arr_i_removed = cntPairs + 1 - mp . get ( arr [ i ] ) ; document . write ( pairs_after_arr_i_removed + "▁" ) ; } return ; }
function minimumMaxDiff ( nums ) { var s = new Set ( ) ; for ( var i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] % 2 == 0 ) s . add ( nums [ i ] ) ; else s . add ( nums [ i ] * 2 ) ; } var tmp = [ ... s ] . sort ( ( a , b ) => a - b )  var res = tmp [ tmp . length - 1 ] - tmp [ 0 ] ; while ( tmp [ tmp . length - 1 ] % 2 == 0 ) { var x = tmp [ tmp . length - 1 ] ; s . delete ( x ) ; s . add ( parseInt ( x / 2 ) ) ; tmp = [ ... s ] . sort ( ( a , b ) => a - b )  res = Math . min ( res , tmp [ tmp . length - 1 ] - tmp [ 0 ] ) ; } return res ; }
function bitwiseXorRange ( n ) { if ( n % 4 == 0 ) return n ; if ( n % 4 == 1 ) return 1 ; if ( n % 4 == 2 ) return n + 1 ; return 0 ; }
function evenXorRange ( l , r ) { let xor_l ; let xor_r ; xor_r = 2 * bitwiseXorRange ( Math . floor ( r / 2 ) ) ; xor_l = 2 * bitwiseXorRange ( Math . floor ( ( l - 1 ) / 2 ) ) ; return xor_l ^ xor_r ; }
function find_Variance ( n ) { var numerator = n * n - 1  var ans = ( numerator * 1.0 ) / 12  return ans }
function noOfArraysPossible ( N , M ) { var ans = 1 ; for ( i = 0 ; i < N ; ++ i ) { ans = ans * ( M - i ) ; } document . write ( ans ) ; }
function findSum ( a , b , n ) { var sum = 0 ; var x = a ^ b ; if ( n % 3 == 0 ) { sum = parseInt ( n / 3 ) * ( a + b + x ) ; } else if ( n % 3 == 1 ) { sum = parseInt ( n / 3 ) * ( a + b + x ) + a ; } else { sum = parseInt ( n / 3 ) * ( a + b + x ) + a + b ; } document . write ( sum ) ; }
function constructArrayWithGivenLCM ( N ) { let newArr = new Array ( N ) ; newArr . fill ( 0 ) ; let j = 0 ; for ( let i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { newArr [ j ] = i ; j ++ ; if ( parseInt ( N / i , 10 ) != i ) { newArr [ j ] = parseInt ( N / i , 10 ) ; j ++ ; } } } newArr . sort ( function ( a , b ) { return a - b } ) ; for ( let i = j ; i < N ; i ++ ) { document . write ( newArr [ i ] + "▁" ) ; } }
function onesComplement ( n , maxElement ) { let bits = Math . floor ( ( Math . log ( maxElement ) / Math . log ( 2 ) ) ) + 1 ; return ( ( 1 << bits ) - 1 ) ^ n ; }
function calculateFactorial ( N ) { var fact = Array ( N + 1 ) ; fact [ 0 ] = 1 ; for ( var i = 1 ; i <= N ; i ++ ) { fact [ i ] = fact [ i - 1 ] * i ; } return fact ; }
function cntWaysSelection ( arr , N , K , L , R ) { var cntWays = 0 ; var cntNum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= L && arr [ i ] <= R ) { cntNum ++ ; } } var fact = calculateFactorial ( cntNum ) ; for ( var i = K ; i <= cntNum ; i ++ ) { cntWays += fact [ cntNum ] / ( fact [ i ] * fact [ cntNum - i ] ) ; } return cntWays ; }
function TotalAndPair ( arr , N ) { let totalAND = ( 1 << 30 ) - 1 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { totalAND &= arr [ i ] & arr [ j ] ; } } return totalAND ; }
function getPower ( p ) { var res = 1 ; while ( p -- ) { res *= 5 ; } return res ; }
function printFinalPrices ( arr ) { var minStk = [ ] var n = arr . length ; var i ; var reduce = Array ( n ) . fill ( 0 ) ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( minStk . length > 0 ) { if ( minStk [ minStk . length - 1 ] <= arr [ i ] ) { reduce [ i ] = minStk [ minStk . length - 1 ] ; } else { while ( minStk . length > 0 && ( minStk [ minStk . length - 1 ] > arr [ i ] ) ) { minStk . pop ( ) ; } if ( minStk . length > 0 ) { reduce [ i ] = minStk [ minStk . length - 1 ] ; } } } minStk . push ( arr [ i ] ) ; } for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] - reduce [ i ] + "▁" ) ; }
function smallestDivisorGr1 ( N ) { for ( let i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { return i ; } } return N ; }
function findValOfNWithOperat ( N , K ) { for ( let i = 1 ; i <= K ; i ++ ) { N += smallestDivisorGr1 ( N ) ; } return N ; }
function smallestDivisorGr1 ( N ) { for ( var i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { return i ; } } return N ; }
function findTripleSum ( A , B , C ) { let sum = 0 ; for ( let i = 1 ; i <= A ; i ++ ) { for ( let j = 1 ; j <= B ; j ++ ) { for ( let k = 1 ; k <= C ; k ++ ) { let prod = ( ( ( i % M ) * ( j % M ) ) % M * ( k % M ) ) % M ; sum = ( sum + prod ) % M ; } } } return sum ; }
function getMaximum ( N , M , mat ) { let global_max = Number . MIN_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { let row_min = Number . MAX_VALUE ; for ( let k = 0 ; k < M ; k ++ ) { let m = Math . max ( mat [ i ] [ k ] , mat [ j ] [ k ] ) ; row_min = Math . min ( row_min , m ) ; } global_max = Math . max ( global_max , row_min ) ; } } return global_max ; }
function makeTree ( tree , edges , N ) { for ( var i = 0 ; i < N - 1 ; i ++ ) { var u = edges [ i ] [ 0 ] ; var v = edges [ i ] [ 1 ] ; tree [ u ] . push ( v ) ; } }
function findTheGreatestX ( P , Q ) { var divisiors = new Map ( ) ; for ( var i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 && Q > 1 ) { Q = parseInt ( Q / i ) ; if ( divisiors . has ( i ) ) divisiors . set ( i , divisiors . get ( i ) + 1 ) else divisiors . set ( i , 1 ) } } if ( Q > 1 ) if ( divisiors . has ( Q ) ) divisiors . set ( Q , divisiors . get ( Q ) + 1 ) else divisiors . set ( Q , 1 )  var ans = 0 ; divisiors . forEach ( ( value , key ) => { var frequency = value ; var temp = P ; var cur = 0 ; while ( temp % key == 0 ) { temp = parseInt ( temp / key ) ; cur ++ ; } if ( cur < frequency ) { ans = P ; } temp = P ; for ( var j = cur ; j >= frequency ; j -- ) { temp = parseInt ( temp / key ) ; } ans = Math . max ( temp , ans ) ; } ) ; document . write ( ans ) ; }
function divisorCount ( n ) { let x = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == n / i ) x ++ ; else x += 2 ; } } return x ; }
function minvalue_y ( x ) { let a = divisorCount ( x ) ; let y = x + 1 ; while ( ( a & 1 ) == ( divisorCount ( y ) & 1 ) ) y ++ ; return y ; }
function minvalue_y ( x ) { let n = Math . floor ( Math . sqrt ( x ) ) ; if ( n * n == x ) return x + 1 ; return Math . floor ( Math . pow ( n + 1 , 2 ) ) ; }
function alternatingSumOfFirst_N ( N ) { var alternateSum = 0 ; if ( N % 2 == 0 ) { alternateSum = ( - N ) / 2 ; } else { alternateSum = ( N + 1 ) / 2 ; } return alternateSum ; }
function minStartValue ( nums ) { let minValue = 0 ; let sum = 0 ; for ( let n = 0 ; n < nums . length ; n ++ ) { sum += nums [ n ] ; minValue = Math . min ( minValue , sum ) ; } let startValue = 1 - minValue ; return startValue ; }
function countSubArrayRemove ( arr , N ) { let prefix_element_count = new Map ( ) ; let suffix_element_count = new Map ( ) ; let total_sum_of_elements = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { total_sum_of_elements += arr [ i ] ; if ( ! suffix_element_count . has ( arr [ i ] ) ) suffix_element_count . set ( arr [ i ] , 1 ) ; else suffix_element_count . set ( arr [ i ] , suffix_element_count . get ( arr [ i ] ) + 1 ) ; } let prefix_sum = 0 ; let suffix_sum = 0 ; let count_subarray_equal_sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { prefix_sum += arr [ i ] ; if ( ! prefix_element_count . has ( arr [ i ] ) ) prefix_element_count . set ( arr [ i ] , 1 ) ; else prefix_element_count . set ( arr [ i ] , prefix_element_count . get ( arr [ i ] ) + 1 ) ; suffix_sum = total_sum_of_elements - prefix_sum ; if ( ! suffix_element_count . has ( arr [ i ] ) ) suffix_element_count . set ( arr [ i ] , 0 ) ; else suffix_element_count . set ( arr [ i ] , suffix_element_count . get ( arr [ i ] ) - 1 ) ; let difference = prefix_sum - suffix_sum ; let number_of_subarray_at_i_split = 0 ; if ( prefix_element_count . has ( difference ) ) number_of_subarray_at_i_split = prefix_element_count . get ( difference ) ; if ( suffix_element_count . has ( - difference ) ) number_of_subarray_at_i_split += suffix_element_count . get ( - difference ) ; count_subarray_equal_sum += number_of_subarray_at_i_split ; } return count_subarray_equal_sum ; }
function countXORSetBitsAdjElemRange1_N ( N ) { let total_set_bits = 0 ; let bit_Position = 1 ; while ( N ) { total_set_bits += ( Math . floor ( ( N + 1 ) / 2 ) * bit_Position ) ; N -= Math . floor ( ( N + 1 ) / 2 ) ; bit_Position ++ ; } return total_set_bits ; }
function checkPerfectSquare ( N ) { if ( N <= 0 ) { return 0 ; } let sq = Math . sqrt ( N ) ; if ( Math . floor ( sq ) == Math . ceil ( sq ) ) { return 1 ; } return 0 ; }
function checktwoSidesareRighTriangle ( A , B ) { let checkTriangle = false ; if ( checkPerfectSquare ( A * A + B * B ) != 0 ) { checkTriangle = true ; } if ( checkPerfectSquare ( A * A - B * B ) != 0 ) { checkTriangle = true ; } if ( checkPerfectSquare ( B * B - A * A ) != 0 ) { checkTriangle = true ; } return checkTriangle ; }
function valid ( i , j ) { if ( i >= 0 && j >= 0 && i < r && j < c ) return true ; return false ; }
function find ( i , j , v ) { let s = 0 ; for ( let k = 0 ; k < 8 ; k ++ ) { let ni = i + dir [ k ] [ 0 ] , nj = j + dir [ k ] [ 1 ] ; if ( valid ( ni , nj ) ) s += v [ ni ] [ nj ] ; } return s ; }
function findsumofneighbors ( M ) { let v = new Array ( r ) ; for ( var i = 0 ; i < v . length ; i ++ ) { v [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < r ; i ++ ) { for ( let j = 0 ; j < c ; j ++ ) { v [ i ] [ j ] = find ( i , j , M ) ; document . write ( v [ i ] [ j ] + "▁" ) ; } document . write ( "" ) ; } }
function TotalBitwiseORPair ( arr , N ) { let totalOR = 0 ; for ( let i = 0 ; i < N ; i ++ ) { totalOR |= arr [ i ] ; } return totalOR ; }
function checkSolveable ( n , m ) { if ( n == 1 m == 1 ) document . write ( "YES" ) ; else if ( m == 2 && n == 2 ) document . write ( "YES" ) ; else document . write ( "NO" ) ; }
function printFinalArray ( a , n , operations , p , capacity ) { var i , curr = 0 ; var picked = false ; for ( i = 0 ; i < p ; i ++ ) { var s = operations [ i ] ; var flag = false ; switch ( s ) { case 1 : if ( curr != 0 ) curr -- ; break ; case 2 : if ( curr != n - 1 ) curr ++ ; break ; case 3 : if ( picked == false && a [ curr ] != 0 ) { picked = true ; a [ curr ] -- ; } break ; case 4 : if ( picked == true && a [ curr ] != capacity ) { picked = false ; a [ curr ] ++ ; } break ; default : flag = true ; } if ( flag == true ) break ; } for ( i = 0 ; i < n ; i ++ ) { document . write ( a [ i ] + "▁" ) ; } }
function constructArray ( A , N ) { let left = [ ] ; let right = [ ] ; let X = [ ] ; let Y = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { X [ i ] = 0 ; left [ i ] = 0 ; right [ i ] = 0 ; Y [ i ] = 0 ; } for ( let i = 0 ; i < N ; i ++ ) { X [ i ] = left [ A [ i ] ] ; left [ A [ i ] ] ++ ; } for ( let i = N - 1 ; i >= 0 ; i -- ) { Y [ i ] = right [ A [ i ] ] ; right [ A [ i ] ] ++ ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( Y [ i ] - X [ i ] + "▁" ) ; } }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function largestElement ( head_ref ) { var Max = - 1000000000 ; var head = head_ref ; while ( head != null ) { if ( Max < head . data ) { Max = head . data ; } head = head . next ; } return Max ; }
function probablityPrimeprod ( N ) { let N_E = 3 * N ; let N_S = power ( 6 , N ) ; document . write ( N_E + "▁/▁" + N_S ) ; }
function checkPalindrome ( N ) { let rev = 0 ; let temp = N ; while ( N != 0 ) { rev = Math . floor ( rev * 10 + N % 10 ) ; N = Math . floor ( N / 10 ) ; } N = temp ; if ( N == rev ) { return true ; } return false ; }
function closestSmallerPalindrome ( N ) { do { N -- ; } while ( N >= 0 && ! checkPalindrome ( N ) ) ; return N ; }
function MinimumOperationReq ( N ) { let cntDecr = 0 ; let temp = N ; while ( temp > 0 ) { let X = Math . floor ( Math . sqrt ( temp ) ) ; if ( X * X == temp ) { break ; } temp = temp - 2 ; cntDecr += 1 ; } let cntIncr = 0 ; while ( true ) { let X = Math . floor ( Math . sqrt ( N ) ) ; if ( X * X == N ) { break ; } N = N + 2 ; cntIncr += 1 ; } return Math . min ( cntIncr , cntDecr ) ; }
function power ( x , N ) { var res = 1 ; while ( N > 0 ) { if ( N % 2 == 1 ) { res = ( res * x ) % M ; } x = ( x * x ) % M ; N = N >> 1 ; } return res ; }
function moduloInverse ( X ) { return power ( X , M - 2 ) ; }
function GCD ( a , b ) { if ( b == 0 ) return a ; else return GCD ( b , a % b ) ; }
function check ( x , y ) { if ( GCD ( x , y ) == 1 ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function findSubArray ( arr , k ) { var ans = [ ] ; var i , sum = 0 ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } var found = 0 ; if ( sum % 3 == 0 ) { ans = [ 0 , i - 1 ] ; found = 1 ; } for ( var j = i ; j < arr . length ; j ++ ) { if ( found == 1 ) break ; sum = sum + arr [ j ] - arr [ j - k ] ; if ( sum % 3 == 0 ) { ans = [ j - k + 1 , j ] ; found = 1 ; } } if ( found == 0 ) ans = [ - 1 , 0 ] ; if ( ans . first == - 1 ) { cout << - 1 ; } else { for ( i = ans [ 0 ] ; i <= ans [ 1 ] ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } } }
function sumOfProd ( arr , N ) { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } return sum * sum ; }
function rev ( num ) { var rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = parseInt ( num / 10 ) ; } return rev_num ; }
function check ( n ) { let x = ( n + 7 ) / 8 ; if ( ( n + 7 ) % 8 == 0 && isPower ( 10 , x ) ) return true ; else return false ; }
function mul_2 ( K ) { let temp = new Array ( K + 1 ) ; for ( let i = 0 ; i <= K ; i ++ ) { temp [ i ] = new Array ( K + 1 ) ; for ( let j = 0 ; j <= K ; j ++ ) { temp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= K ; i ++ ) { for ( let j = 1 ; j <= K ; j ++ ) { for ( let k = 1 ; k <= K ; k ++ ) { temp [ i ] [ j ] = ( temp [ i ] [ j ] + ( T [ i ] [ k ] * T [ k ] [ j ] ) % mod ) % mod ; } } } for ( let i = 1 ; i <= K ; i ++ ) { for ( let j = 1 ; j <= K ; j ++ ) { T [ i ] [ j ] = temp [ i ] [ j ] ; } } }
function mul_1 ( K ) { let temp = new Array ( K + 1 ) ; for ( let i = 0 ; i <= K ; i ++ ) { temp [ i ] = new Array ( K + 1 ) ; for ( let j = 0 ; j <= K ; j ++ ) { temp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= K ; i ++ ) { for ( let j = 1 ; j <= K ; j ++ ) { for ( let k = 1 ; k <= K ; k ++ ) { temp [ i ] [ j ] = ( temp [ i ] [ j ] + ( result [ i ] [ k ] * T [ k ] [ j ] ) % mod ) % mod ; } } } for ( let i = 1 ; i <= K ; i ++ ) { for ( let j = 1 ; j <= K ; j ++ ) { result [ i ] [ j ] = temp [ i ] [ j ] ; } } }
function matrix_pow ( K , n ) { for ( let i = 1 ; i <= K ; i ++ ) { for ( let j = 1 ; j <= K ; j ++ ) { if ( i == j ) result [ i ] [ j ] = 1 ; } } while ( n > 0 ) { if ( n % 2 == 1 ) mul_1 ( K ) ; mul_2 ( K ) ; n = parseInt ( n / 2 , 10 ) ; } }
function countFreq ( arr , n ) { let mp1 = new Map ( ) ; for ( let i = 0 ; i < n ; ++ i ) { if ( mp1 . has ( arr [ i ] ) ) { mp1 . set ( arr [ i ] , mp1 . get ( arr [ i ] ) + 1 ) ; } else { mp1 . set ( arr [ i ] , 1 ) ; } } let mp2 = new Map ( ) ; for ( let [ key , value ] of mp1 . entries ( ) ) { if ( mp2 . has ( value ) ) { mp2 . set ( value , mp2 . get ( value ) + 1 ) ; } else { mp2 . set ( value , 1 ) ; } } let M = Number . MIN_VALUE ; for ( let [ key , value ] of mp2 . entries ( ) ) { M = Math . max ( M , value ) ; } for ( let [ key , value ] of mp2 . entries ( ) ) { if ( M == value ) { return key ; } } return 0 ; }
function computeSalary ( basic , grade ) { let allowance ; let hra , da , pf ; hra = 0.2 * basic ; da = 0.5 * basic ; pf = 0.11 * basic ; if ( grade == "A" ) { allowance = 1700.0 ; } else if ( grade == "B" ) { allowance = 1500.0 ; } else { allowance = 1300.0 ; } let gross ; gross = Math . round ( basic + hra + da + allowance - pf ) ; return gross ; }
function maxDisconnected ( N , E ) { let curr = 1 ; let rem = E ; while ( rem > 0 ) { rem = rem - Math . min ( curr , rem ) ; curr ++ ; } if ( curr > 1 ) { return N - curr ; } else { return N ; } }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function findSum ( N ) { var sum = 0 ; for ( var i = 1 ; i < N ; i ++ ) { if ( gcd ( i , N ) == 1 ) { sum += i ; } } return sum ; }
function solve ( arr , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) else mp . set ( arr [ i ] , 1 ) ; } var cnt = 0 ; mp . forEach ( ( value , key ) => { cnt += ( ( value ) * ( value - 1 ) / 2 ) ; } ) ; var ans = Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { ans [ i ] = cnt - ( mp . get ( arr [ i ] ) - 1 ) ; } for ( var i = 0 ; i < n ; i ++ ) { document . write ( ans [ i ] + "▁" ) ; } }
function nthRoot ( A , N ) { var xPre = ( Math . random ( ) * 10 ) % 10 ; var eps = 1e-3 ; var delX = Number . MAX_VALUE ; var xK = 0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + A / Math . pow ( xPre , N - 1 ) ) / N ; delX = Math . abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
function RMNValue ( arr , n , k ) { var Nth = 0 ; var mean = 0 , root = 0 ; for ( var i = 0 ; i < n ; i ++ ) { Nth += Math . pow ( arr [ i ] , k ) ; } mean = ( Nth / ( n ) ) ; root = nthRoot ( mean , k ) ; return root ; }
function xor_operations ( N , arr , M , K ) { if ( M < 0 M >= N ) return - 1 ; if ( K < 0 K >= N - M ) return - 1 ; for ( let p = 0 ; p < M ; p ++ ) { let temp = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { let value = arr [ i ] ^ arr [ i + 1 ] ; temp . push ( value ) ; arr [ i ] = temp [ i ] ; } } let ans = arr [ K ] ; return ans ; }
function checkPalindromeB ( N , B ) { var rev = 0 ; var N1 = N ; while ( N1 ) { rev = rev * B + N1 % B ; N1 = parseInt ( N1 / B ) ; } return N == rev ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function findProduct ( N ) { var result = 1 ; for ( var i = 2 ; i < N ; i ++ ) { if ( gcd ( i , N ) == 1 ) { result *= i ; } } return result ; }
function countEqual ( n ) { return parseInt ( ( n + 1 ) / 2 ) ; }
function smallSubarray ( arr , n , total_sum ) { let m = new Map ( ) ; let length = Number . MAX_VALUE ; let prefixSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { prefixSum += arr [ i ] ; if ( prefixSum == total_sum ) { length = Math . min ( length , i + 1 ) ; } m . set ( prefixSum , i ) ; if ( m . has ( prefixSum - total_sum ) ) { length = Math . min ( length , i - m . get ( prefixSum - total_sum ) ) ; } } return length ; }
function smallestSubarrayremoved ( arr , n , k ) { let total_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > k ) { arr [ i ] = 1 ; } else if ( arr [ i ] < k ) { arr [ i ] = - 1 ; } else { arr [ i ] = 0 ; } total_sum += arr [ i ] ; } if ( total_sum == 0 ) { return 0 ; } else { return smallSubarray ( arr , n , total_sum ) ; } }
function find ( par , x ) { if ( par [ x ] == x ) return x ; else return par [ x ] = find ( par , par [ x ] ) ; }
function functionMax ( arr , n ) { var setBit = Array . from ( Array ( 32 ) , ( ) => new Array ( ) ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < size_int ; j ++ ) { if ( arr [ i ] & ( 1 << j ) ) setBit [ j ] . push ( i ) ; } } for ( var i = size_int - 1 ; i >= 0 ; i -- ) { if ( setBit [ i ] . length == 1 ) { [ arr [ 0 ] , arr [ setBit [ i ] [ 0 ] ] ] = [ arr [ setBit [ i ] [ 0 ] ] , arr [ 0 ] ] ; break ; } } var maxAnd = arr [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { maxAnd = maxAnd & ( ~ arr [ i ] ) ; } return maxAnd ; }
function modexp ( x , n , m ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , parseInt ( n / 2 , 10 ) , m ) ; } else { return ( x * modexp ( ( x * x ) % m , parseInt ( ( n - 1 ) / 2 , 10 ) , m ) % m ) ; } }
function modInverse ( x , m ) { return modexp ( x , m - 2 , m ) ; }
function countNumbers ( N ) { let m = 1000000007 ; let factorial = new Array ( 100001 ) ; factorial [ 0 ] = 1 ; for ( let i = 1 ; i < 100001 ; i ++ ) { factorial [ i ] = ( factorial [ i - 1 ] * i ) % m ; } let count = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { count [ i ] = 0 ; } let length = N . length ; for ( let i = 0 ; i < length ; i ++ ) count [ N [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ] ++ ; let result = factorial [ length ] ; for ( let i = 0 ; i < 10 ; i ++ ) { result = 0 * ( result * modInverse ( factorial [ count [ i ] ] , m ) ) % m + 12 ; } document . write ( result ) ; }
function max_valid_triplet ( A , n ) { let ans = - 1 ; for ( let i = 0 ; i < n - 2 ; i ++ ) { for ( let j = i + 1 ; j < n - 1 ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { if ( A [ i ] < A [ j ] && A [ j ] < A [ k ] ) { let value = A [ i ] + A [ j ] * A [ k ] ; if ( value > ans ) { ans = value ; } } } } } document . write ( ans ) ; }
function productOfProperDivi ( num ) { return ans [ num ] ; }
function findlcm ( n ) { let ans = 1 ; for ( let i = 1 ; i <= n ; i ++ ) ans = ( ( ( i * ans ) ) / ( __gcd ( i , ans ) ) ) ; return ans ; }
function highestPower ( n ) { let lcm = findlcm ( n ) ; let ans = 0 ; for ( let i = 1 ; ; i ++ ) { let x = Math . pow ( 2 , i ) ; if ( lcm % x == 0 ) { ans = i ; } if ( x > n ) break ; } return ans ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function countofPermutations ( N ) { return parseInt ( 3 * Math . pow ( 2 , N - 1 ) ) ; }
function answer ( L , R ) { if ( 2 * L <= R ) document . write ( L + ",▁" + 2 * L + "-1" ) ; else document . write ( - 1 ) ; }
function spf_array ( spf ) { spf [ 1 ] = 1 ; for ( var i = 2 ; i < 1000 ; i ++ ) spf [ i ] = i ; for ( var i = 4 ; i < 1000 ; i += 2 ) spf [ i ] = 2 ; for ( var i = 3 ; i * i < 1000 ; i ++ ) { if ( spf [ i ] == i ) { for ( var j = i * i ; j < 1000 ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
function frequent_prime ( arr , N , K ) { spf_array ( spf ) ; var Hmap = new Map ( ) ; var result = [ ] ; var i = 0 ; var c = 0 ; for ( i = 0 ; i < N ; i ++ ) { var x = arr [ i ] ; while ( x != 1 ) { if ( Hmap . has ( spf [ x ] ) ) Hmap . set ( spf [ x ] , Hmap . get ( spf [ x ] ) + 1 ) else Hmap . set ( spf [ x ] , 1 ) ; x = parseInt ( x / spf [ x ] ) ; } } Hmap . delete ( 1 ) ; Hmap . forEach ( ( value , key ) => { var primeNum = key ; var frequency = value ; if ( frequency % K == 0 ) { result . push ( primeNum ) ; } } ) ; if ( result . length > 0 ) { result . forEach ( it => { document . write ( it + "▁" ) ; } ) ; } else { document . write ( "{}" ) ; } }
function initialize_xor ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { total_xor = total_xor ^ arr [ i ] ; } }
function gcd ( x , y ) { if ( x % y == 0 ) return y ; else return gcd ( y , x % y ) ; }
function countPairwiseCoprime ( N , M ) { let answer = 1 ; let g = gcd ( N , M ) ; let temp = g ; for ( let i = 2 ; i * i <= g ; i ++ ) { if ( temp % i == 0 ) { answer ++ ; while ( temp % i == 0 ) temp /= i ; } } if ( temp != 1 ) answer ++ ; return answer ; }
function countCoprimePair ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { document . write ( countPairwiseCoprime ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) + "▁" ) ; } }
function prime ( n ) { if ( n == 1 ) return false ; for ( i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
function getProduct ( a , n ) { var p = 1 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { p *= Math . abs ( a [ i ] - a [ j ] ) ; } } return p ; }
function isPerfectSquare ( x ) { let sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
function diffCube ( N ) { return isPerfectSquare ( 12 * N - 3 ) ; }
function totalCountDifference ( n ) { if ( n == 1 ) return 1 ; return n + totalCountDifference ( Math . floor ( n / 2 ) ) ; }
function lcm ( a , b ) { return ( a * b ) / gcd ( a , b ) ; }
function findLCM ( arr ) { var nth_lcm = arr [ 0 ] ; for ( var i = 1 ; i < arr . length ; i ++ ) nth_lcm = lcm ( nth_lcm , arr [ i ] ) ; Landau = Math . max ( Landau , nth_lcm ) ; }
function findWays ( arr , i , n ) { if ( n == 0 ) findLCM ( arr ) ; for ( var j = i ; j <= n ; j ++ ) { arr . push ( j ) ; findWays ( arr , j , n - j ) ; arr . pop ( ) ; } }
function Landau_function ( n ) { arr = [ ] ; findWays ( arr , 1 , n ) ; document . write ( Landau ) ; }
function findSum ( arr , n , left , right ) { let k = right - left + 1 ; let d = arr [ 1 ] / arr [ 0 ] ; let ans = arr [ left - 1 ] ; if ( d == 1 ) ans = ans * d * k ; else ans = ans * ( Math . pow ( d , k ) - 1 / ( d - 1 ) ) ; return ans ; }
function countRepeatingDigits ( N ) { var res = 0 ; var cnt = Array ( 10 ) . fill ( 0 ) ; while ( N > 0 ) { var rem = N % 10 ; cnt [ rem ] ++ ; N = N / 10 ; } for ( var i = 0 ; i < 10 ; i ++ ) { if ( cnt [ i ] > 1 ) { res ++ ; } } return res ; }
function nCr ( n , r ) { let res = 1 ; if ( r > n - r ) r = n - r ; for ( let i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
function solve ( n , m , k ) { let sum = 0 ; for ( let i = 0 ; i <= k ; i ++ ) sum += nCr ( n , i ) * nCr ( m , k - i ) ; return sum ; }
function nCr ( n , r ) { let res = 1 ; if ( r > n - r ) r = n - r ; for ( let i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
function modPower ( a , b , M ) { var res = 1 ; while ( b ) { if ( b & 1 ) res = res * a % M ; a = a * a % M ; b >>= 1 ; } return res ; }
function Cal_min ( arr , n , k ) { let diff_mod = new Set ( ) ; let count_mod = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { diff_mod . add ( arr [ i ] % k ) ; if ( count_mod . has ( ( arr [ i ] % k ) ) ) count_mod . set ( arr [ i ] % k , count_mod . get ( arr [ i ] % k ) + 1 ) ; else count_mod . set ( arr [ i ] % k , 1 ) ; } return Find_min ( diff_mod , count_mod , k ) ; }
function canBreakN ( n ) { for ( let i = 2 ; ; i ++ ) { let m = parseInt ( i * ( i + 1 ) / 2 , 10 ) ; if ( m > n ) break ; let k = n - m ; if ( k % i != 0 ) continue ; document . write ( i ) ; return ; } document . write ( "-1" ) ; }
function minimumSteps ( arr , n ) { let i ; let dat = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; for ( i = 1 ; i <= n ; i ++ ) dat [ arr [ i - 1 ] ] = i ; let b = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; let j = 0 , c ; for ( i = 1 ; i <= n ; i ++ ) { c = 1 ; j = dat [ i ] ; while ( j != i ) { c ++ ; j = dat [ j ] ; } b [ i ] = c ; } document . write ( findlcm ( b , n ) ) ; }
function maximum ( a , b ) { if ( a > b ) return a ; return b ; }
function check ( num ) { let root = Math . floor ( Math . sqrt ( num ) ) ; let pow = Math . floor ( Math . log ( root ) / Math . log ( 2 ) ) ; if ( num == Math . floor ( Math . pow ( 2 , pow ) * ( Math . pow ( 2 , pow + 1 ) - 1 ) ) ) { if ( isPrime ( pow + 1 ) ) { if ( isPrime ( Math . floor ( Math . pow ( 2 , pow + 1 ) ) - 1 ) ) document . write ( "Yes" ) ; else document . write ( "No" ) ; } else document . write ( "No" ) ; } else document . write ( "No" ) ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; else if ( n == 2 n == 3 ) return true ; else { if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i <= Math . floor ( Math . sqrt ( n ) ) ; i += 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; } return true ; } }
function isTriplet ( ar , n ) { for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { for ( var k = j + 1 ; k < n ; k ++ ) { if ( Math . abs ( ar [ i ] - ar [ j ] ) == 1 || Math . abs ( ar [ j ] - ar [ k ] ) == 1 || Math . abs ( ar [ i ] - ar [ k ] ) == 1 ) { var x = ar [ i ] * ar [ i ] , y = ar [ j ] * ar [ j ] , z = ar [ k ] * ar [ k ] ; if ( x == y + z y == x + z z == x + y ) return true ; } } } } return false ; }
function closestDivisors ( n ) { for ( var i = parseInt ( Math . sqrt ( n + 2 ) ) ; i > 0 ; i -- ) { if ( ( n + 1 ) % i == 0 ) { document . write ( i + ",▁" + parseInt ( ( n + 1 ) / i ) ) ; break ; } if ( ( n + 2 ) % i == 0 ) { document . write ( i + ",▁" + parseInt ( ( n + 2 ) / i ) ) ; break ; } } }
function count ( n ) { let phi = [ ] ; let divs = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) { phi [ i ] = 0 ; divs [ i ] = 0 ; } for ( let i = 1 ; i <= n ; i ++ ) { phi [ i ] += i ; for ( let j = i * 2 ; j <= n ; j += i ) phi [ j ] -= phi [ i ] ; for ( let j = i ; j <= n ; j += i ) divs [ j ] ++ ; } return ( n - phi [ n ] - divs [ n ] + 1 ) ; }
function inorder ( node ) { if ( node == null ) return ; inorder ( node . left ) ; document . write ( node . data + "▁" ) ; inorder ( node . right ) ; }
function MinimumString ( x ) { let b = 1 ; let left_lim = Math . sqrt ( x ) + 1.0 ; let right_lim = Math . sqrt ( x ) + 2.0 ; let r = 0 ; for ( let i = Math . floor ( left_lim ) ; i <= Math . floor ( right_lim ) ; i ++ ) { if ( i > left_lim && i < right_lim ) { r = i ; break ; } } return b + r ; }
function isPerfectSquare ( N ) { let floorSqrt = Math . floor ( Math . sqrt ( N ) ) ; return ( N == floorSqrt * floorSqrt ) ; }
function legendreFunction ( N ) { while ( N % 4 == 0 ) N = Math . floor ( N / 4 ) ; if ( N % 8 != 7 ) return true ; else return false ; }
function minSquares ( N ) { if ( isPerfectSquare ( N ) ) return 1 ; for ( let i = 1 ; i * i < N ; i ++ ) { if ( isPerfectSquare ( N - i * i ) ) return 2 ; } if ( legendreFunction ( N ) ) return 3 ; return 4 ; }
function is_distinct ( n , k ) { let s = new Set ( ) ; for ( let i = 1 ; i <= k ; i ++ ) { let tmp = n % i ; if ( s . has ( tmp ) ) { return false ; } s . add ( tmp ) ; } return true ; }
function getDivisors ( min , n ) { var total = 0 ; for ( var i = min ; i < n ; ++ i ) { if ( n % i == 0 && n / i >= i ) { ++ total ; if ( n / i > i ) total += getDivisors ( i , n / i ) ; } } return total ; }
function findWays ( arr , i , n ) { if ( n == 0 ) printVector ( arr ) ; for ( var j = i ; j <= n ; j ++ ) { arr . push ( j ) ; findWays ( arr , j , n - j ) ; arr . pop ( ) ; } }
function spt_function ( n ) { var arr = [ ] ; findWays ( arr , 1 , n ) ; document . write ( spt ) ; }
function isUgly ( n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; if ( n % 2 == 0 ) { return ( isUgly ( n / 2 ) ) ; } if ( n % 3 == 0 ) { return ( isUgly ( n / 3 ) ) ; } if ( n % 5 == 0 ) { return ( isUgly ( n / 5 ) ) ; } return 0 ; }
function findMinDenomin ( n ) { return ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ) ; }
function calculate ( P , Q ) { let mod = 998244353 , expo ; expo = mod - 2 ; p = 748683265 ; while ( expo != 0 ) { if ( ( expo & 1 ) == 1 ) { P = ( P * Q ) % mod ; } Q = ( Q * Q ) % mod ; expo >>= 1 ; } return p ; }
function powerOptimised ( a , n ) { let ans = 1 ; while ( n > 0 ) { let last_bit = ( n & 1 ) ; if ( last_bit > 0 ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; }
function maxGCD ( N ) { for ( var i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return N / i ; } } return 1 ; }
function findMaximumGcd ( n ) { let max_gcd = 1 ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; }
function findContent ( arr , n ) { var content = arr [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { content = __gcd ( content , arr [ i ] ) ; } return content ; }
function inverseEqual ( arr , n ) { var brr = Array ( n ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { var present_index = arr [ i ] - 1 ; brr [ present_index ] = i + 1 ; } for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != brr [ i ] ) { document . write ( "No" ) ; return ; } } document . write ( "Yes" ) ; }
function linearCongruentialMethod ( Xo , m , a , c , randomNums , noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( let i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m ; } }
function multiplicativeCongruentialMethod ( Xo , m , a , randomNums , noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( let i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m ; } }
function additiveCongruentialMethod ( Xo , m , c , randomNums , noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( let i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] + c ) % m ; } }
function power ( a , b , m ) { a %= m ; var res = 1 ; while ( b > 0 ) { if ( b & 1 ) res = ( ( res % m ) * ( a % m ) ) % m ; a = ( ( a % m ) * ( a % m ) ) % m ; b >>= 1 ; } return res % m ; }
function productOfDivisors ( p , n ) { var prime = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( prime . has ( p [ i ] ) ) prime . set ( p [ i ] , prime . get ( p [ i ] ) + 1 ) else prime . set ( p [ i ] , 1 ) } var product = 1 , d = 1 ; prime . forEach ( ( value , key ) => { var val = power ( key , ( value ) * ( value + 1 ) / 2 , MOD ) ; product = ( power ( product , value + 1 , MOD ) * power ( val , d , MOD ) ) % MOD ; d = ( d * ( value + 1 ) ) % ( MOD - 1 ) ; } ) ; return product ; }
function numberOfObjects ( N , M ) { let initial = Math . min ( N , M ) ; let final = Math . floor ( ( N + M ) / 3 ) ; return Math . min ( initial , final ) ; }
function MaxSubarrayLength ( arr , n , k ) { let left = - 1 ; let right = 0 ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % k ) != 0 ) { if ( left == - 1 ) { left = i ; } right = i ; } sum += arr [ i ] ; } if ( ( sum % k ) != 0 ) { return n ; } else if ( left == - 1 ) { return - 1 ; } else { let prefix_length = left + 1 ; let suffix_length = n - right ; return n - Math . min ( prefix_length , suffix_length ) ; } }
function findDistinct ( arr , n ) { let maximum = Math . max ( ... arr ) ; if ( n == 1 ) return 1 ; if ( n == 2 ) { return ( maximum / gcd ( arr [ 0 ] , arr [ 1 ] ) ) ; } let k = gcd ( arr [ 0 ] , arr [ 1 ] ) ; for ( let i = 2 ; i < n ; i ++ ) { k = gcd ( k , arr [ i ] ) ; } return ( maximum / k ) ; }
function power ( a , b ) { if ( b == 0 ) return 1 ; if ( b == 1 ) return a ; let tmp = power ( a , Math . floor ( b / 2 ) ) ; let result = tmp * tmp ; if ( b % 2 == 1 ) result *= a ; return result ; }
function solve ( X , Y ) { if ( X > Y ) { let temp = X ; X = Y ; Y = temp ; } if ( X == Y ) document . write ( 0 ) ; else if ( Y % X == 0 ) document . write ( 1 ) ; else document . write ( 2 ) ; }
function findWinner ( n , k ) { let cnt = 0 ; if ( n == 1 ) document . write ( "No" ) ; else if ( ( n & 1 ) != 0 n == 2 ) document . write ( "Yes" ) ; else { let tmp = n ; let val = 1 ; while ( tmp > k && tmp % 2 == 0 ) { tmp /= 2 ; val *= 2 ; } for ( let i = 3 ; i <= Math . sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp /= i ; } } if ( tmp > 1 ) cnt ++ ; if ( val == n ) document . write ( "No" ) ; else if ( n / tmp == 2 && cnt == 1 ) document . write ( "No" ) ; else document . write ( "Yes" ) ; } }
function countQuadraples ( N ) { var cnt = 0 ; var m = new Map ( ) ; for ( var a = 1 ; a <= N ; a ++ ) { for ( var b = 1 ; b <= N ; b ++ ) { var x = a * a + b * b ; if ( m . has ( x ) ) m . set ( x , m . get ( x ) + 1 ) else m . set ( x , 1 ) } } for ( var c = 1 ; c <= N ; c ++ ) { for ( var d = 1 ; d <= N ; d ++ ) { var x = c * c + d * d ; if ( m . has ( x ) ) cnt += m . get ( x ) ; } } return cnt ; }
function numberOfPairs ( a , b , n ) { let c = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { c [ i ] = a [ i ] - b [ i ] ; } c . sort ( function ( a , b ) { return a - b } ) ; let answer = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( c [ i ] <= 0 ) continue ; let pos = - 1 ; for ( let j = 0 ; j < n ; j ++ ) { if ( c [ i ] + c [ j ] > 0 ) { pos = j ; break ; } } answer += ( i - pos ) ; } return answer ; }
function isEqualFactors ( N ) { if ( ( N % 2 == 0 ) && ( N % 4 != 0 ) ) document . write ( "YES" ) ; else document . write ( "NO" ) ; }
function count_crazy_primes ( L , R ) { let prime = Array . from ( { length : R + 1 } , ( _ , i ) => 0 ) ; let countPrime = Array . from ( { length : R + 1 } , ( _ , i ) => - 1 ) ; let freqPrime = Array . from ( { length : R + 1 } , ( _ , i ) => 0 ) ; prime [ 0 ] = 1 ; prime [ 1 ] = 1 ; for ( let p = 2 ; p * p <= R ; p ++ ) { if ( prime [ p ] == 0 ) { for ( let i = p * p ; i <= R ; i += p ) prime [ i ] = 1 ; } } for ( let i = 1 ; i <= R ; i ++ ) { countPrime [ i ] = countPrime [ i - 1 ] ; if ( prime [ i ] != 0 ) { countPrime [ i ] ++ ; } } for ( let i = 1 ; i <= R ; i ++ ) { freqPrime [ i ] = freqPrime [ i - 1 ] ; if ( ! prime [ countPrime [ i ] ] ) { freqPrime [ i ] ++ ; } } return ( freqPrime [ R ] - freqPrime [ L - 1 ] ) ; }
function findNumbers ( n , b ) { let largest = Math . pow ( b , n ) - 1 ; document . write ( largest ) ; }
function maximizedArray ( arr , N ) { let num , i = 0 ; for ( let l = N ; l > 0 ; l -- ) { num = arr [ i ] ; let one = 0 ; let zero = 0 ; while ( num != 0 ) { if ( num % 2 == 0 ) { zero ++ ; } else { one ++ ; } num = num >> 1 ; } for ( let j = zero ; j < ( one + zero ) ; j ++ ) { num += ( 1 << j ) ; } document . write ( num ) ; i ++ ; if ( N > 0 ) document . write ( ",▁" ) ; } }
function sieve ( ) { v [ 1 ] = 1 ; for ( let i = 2 ; i < x ; i ++ ) v [ i ] = i ; for ( let i = 4 ; i < x ; i += 2 ) v [ i ] = 2 ; for ( let i = 3 ; i * i < x ; i ++ ) { if ( v [ i ] == i ) { for ( let j = i * i ; j < x ; j += i ) { if ( v [ j ] == j ) { v [ j ] = i ; } } } } }
function prime_factors ( n ) { let s = new Set ( ) ; while ( n != 1 ) { s . add ( v [ n ] ) ; n = n / v [ n ] ; } return s . size ; }
function distinctPrimes ( m , k ) { let result = new Array ( ) ; for ( let i = 14 ; i < m + k ; i ++ ) { let count = prime_factors ( i ) ; if ( count == k ) { result . push ( i ) ; } } let p = result . length ; for ( let index = 0 ; index < p - 1 ; index ++ ) { let element = result [ index ] ; let count = 1 , z = index ; while ( z < p - 1 && count <= k && result [ z ] + 1 == result [ z + 1 ] ) { count ++ ; z ++ ; } if ( count >= k ) document . write ( element + "▁" ) ; } }
function findGCD ( arr , n ) { var gcd = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) { gcd = __gcd ( arr [ i ] , gcd ) ; if ( gcd == 1 ) { return 1 ; } } return gcd ; }
function findLCM ( arr , n ) { var lcm = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) { lcm = ( ( ( arr [ i ] * lcm ) ) / ( __gcd ( arr [ i ] , lcm ) ) ) ; } return lcm ; }
function compute ( a , N , K ) { let eqVal = new Map ( ) ; let maxX = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let val = a [ i ] % K ; val = ( val == 0 ? 0 : K - val ) ; if ( val == 0 ) continue ; if ( eqVal . has ( val ) ) { let numVal = eqVal . get ( val ) ; maxX = Math . max ( maxX , val + ( K * numVal ) ) ; eqVal . set ( val , eqVal . get ( val ) + 1 ) ; } else { eqVal . set ( val , 1 ) ; maxX = Math . max ( maxX , val ) ; } } document . write ( maxX == 0 ? 0 : maxX + 1 ) ; }
function print_h_index ( arr , N ) { var ms = [ ] ; for ( var i = 0 ; i < N ; i ++ ) { ms . push ( arr [ i ] ) ; ms . sort ( ( a , b ) => a - b )  if ( ms [ 0 ] < ms . length ) { ms . shift ( ) ; } document . write ( ms . length + "▁" ) ; } }
function pen_hex ( n ) { var pn = 1 ; for ( i = 1 ; i < n ; i ++ ) { pn = parseInt ( i * ( 3 * i - 1 ) / 2 ) ; if ( pn > n ) break ; var seqNum = ( 1 + Math . sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == parseInt ( seqNum ) ) document . write ( pn + ",▁" ) ; } }
function min_value ( arr , N ) { let x , X , K ; let S = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { S . push ( arr [ i ] ) ; } let count = 0 ; for ( let i = 1 ; i <= 1024 ; i ++ ) { count = 0 ; for ( let it in S ) { X = ( ( i it ) - ( i & it ) ) ; for ( let j in S ) { if ( S [ j ] == X ) { count ++ ; } } } if ( count == S . length ) { K = i ; return K ; } } return - 1 ; }
function prefixProduct ( a , n ) { for ( let i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i ] * a [ i - 1 ] ; } for ( let j = 0 ; j < n ; j ++ ) { document . write ( a [ j ] + ",▁" ) ; } return 0 ; }
function sumOfTheArrayForQuery ( A , N , X , Y , Q ) { var sum = 0 ; var count = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( count . has ( A [ i ] ) ) count . set ( A [ i ] , count . get ( A [ i ] ) + 1 ) else count . set ( A [ i ] , 1 ) } for ( var i = 0 ; i < Q ; i ++ ) { var x = X [ i ] , y = Y [ i ] ; if ( count . has ( X [ i ] ) ) { sum -= count . get ( X [ i ] ) * X [ i ] ; sum += count . get ( X [ i ] ) * Y [ i ] ; } if ( count . has ( Y [ i ] ) ) { count . set ( Y [ i ] , count . get ( Y [ i ] ) + count . get ( X [ i ] ) ) ; } count . set ( X [ i ] , 0 ) ; document . write ( sum + "▁" ) ; } }
function maxOR ( arr , n ) { let max_value = Math . max ( ... arr ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , ( max_value arr [ i ] ) ) ; } return ans ; }
function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function generateArr ( A , n ) { let B = new Array ( n ) ; let maxi = Math . max ( ... A ) ; let count = new Array ( maxi + 1 ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { B [ i ] = count [ A [ i ] ] ; IncrementFactors ( count , A [ i ] ) ; } printArr ( B , n ) ; }
function SieveOfEratosthenes ( n ) { let prime = new Array ( 2 * n + 1 ) ; prime . fill ( true )  for ( let p = 2 ; p * p <= 2 * n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= 2 * n ; i += p ) prime [ i ] = false ; } } let primes = new Array ( ) ; for ( let p = 2 ; p <= 2 * n ; p ++ ) if ( prime [ p ] ) primes . push ( p ) ; return primes ; }
function minChanges ( arr ) { let n = arr . length ; let ans = 0 ; let maxi = arr . sort ( ( a , b ) => b - a ) [ 0 ] ; let primes = SieveOfEratosthenes ( maxi ) ; for ( let i = 0 ; i < n ; i ++ ) { let x = - 1  for ( let j = 0 ; j < primes . length ; j ++ ) { if ( arr [ i ] == primes [ j ] ) { x = j break } else if ( arr [ i ] < primes [ j ] ) { x = j break } } let minm = Math . abs ( primes [ x ] - arr [ i ] ) ; if ( x > 1 ) { minm = Math . min ( minm , Math . abs ( primes [ x - 1 ] - arr [ i ] ) ) ; } ans += minm ; } return ans ; }
function findSum ( a , n , L , R ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( L % a [ i ] == 0 && L != 0 ) { sum += calcSum ( a [ i ] , Math . floor ( R / a [ i ] ) ) - calcSum ( a [ i ] , Math . floor ( ( L - 1 ) / a [ i ] ) ) ; } else { sum += calcSum ( a [ i ] , Math . floor ( R / a [ i ] ) ) - calcSum ( a [ i ] , Math . floor ( L / a [ i ] ) ) ; } } return sum ; }
function findPrimes ( ) { for ( let i = 1 ; i <= maxN ; i ++ ) arr [ i ] = 1 ; arr [ 0 ] = 0 ; arr [ 1 ] = 0 ; for ( let i = 2 ; i * i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) { for ( let j = i * i ; j <= maxN ; j += i ) { arr [ j ] = 0 ; } } } let sum = 0 ; prefix [ 0 ] = 0 ; for ( let i = 1 ; i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) { let temp = i ; sum = 0 ; while ( temp > 0 ) { let x = temp % 10 ; sum += x ; temp = Math . floor ( temp / 10 ) ; if ( arr [ sum ] == 1 ) { prefix [ i ] = 1 ; } else { prefix [ i ] = 0 ; } } } } for ( let i = 1 ; i <= maxN ; i ++ ) { prefix [ i ] += prefix [ i - 1 ] ; } }
function print_product ( a , b , c , d ) { let prod1 = a * c ; let prod2 = b * d ; let prod3 = ( a + b ) * ( c + d ) ; let real = prod1 - prod2 ; let imag = prod3 - ( prod1 + prod2 ) ; document . write ( real + "▁+▁" + imag + "i" ) ; }
function countWays ( N ) { if ( N < 4 ) return 0 ; let ans = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; let s = 0 ; for ( let i = 2 ; i <= N - 3 ; i ++ ) { for ( let j = 1 ; j < i ; j ++ ) { if ( N == 2 * i + j ) s ++ ; } } if ( N % 3 == 0 ) s = 3 * s + 1 ; else s = 3 * s ; return ans - s ; }
function get_concentration ( mass , volume ) { if ( volume == 0 ) return - 1 ; else return ( mass / volume ) * 1000 ; }
function isSubsetSum ( set , n , sum ) { var subset = Array . from ( Array ( n + 1 ) , ( ) => Array ( sum + 1 ) ) ; for ( var i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( var i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } return subset [ n ] [ sum ] ; }
function isPractical ( N ) { div = [ ] ; storeDivisors ( N , div ) ; for ( var i = 1 ; i < N ; i ++ ) { if ( ! isSubsetSum ( div , div . length , i ) ) return false ; } return true ; }
function isJunction ( n ) { let count = 0 ; for ( i = 1 ; i <= n ; i ++ ) { if ( i + sum ( i ) == n ) count ++ ; } return count >= 2 ; }
function isDivBySubsetSums ( arr , num ) { var n = arr . length ; var total = 1 << n ; for ( var i = 0 ; i < total ; i ++ ) { var sum = 0 ; for ( var j = 0 ; j < n ; j ++ ) if ( i & ( 1 << j ) ) sum += arr [ j ] ; if ( sum != 0 && num % sum != 0 ) return false ; } return true ; }
function isSuperNivenNum ( n ) { var temp = n ; var digits = [ ] ; while ( n != 0 ) { var digit = n % 10 ; digits . push ( digit ) ; n = parseInt ( n / 10 ) ; } return isDivBySubsetSums ( digits , temp ) ; }
function divCount ( n ) { let hash = Array ( n + 1 ) . fill ( true ) ; for ( let p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; let total = 1 ; for ( p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { let count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
function isHighlyCompositeNumber ( N ) { let NdivCount = divCount ( N ) ; for ( let i = 1 ; i < N ; i ++ ) { let idivCount = divCount ( i ) ; if ( idivCount >= NdivCount ) return false ; } return true ; }
function isInsolite ( n ) { let N = n ; let sum = 0 ; let product = 1 ; while ( n != 0 ) { let r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = parseInt ( n / 10 ) ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; }
function isSaintExuperyNum ( n ) { for ( i = 1 ; i <= n / 3 ; i ++ ) { for ( j = i + 1 ; j <= n / 2 ; j ++ ) { let k = n / i / j ; if ( i * i + j * j == k * k ) { if ( i * j * k == n ) return true ; } } } return false ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function isMagnanimous ( N ) { let s = N . toString ( ) ; let l = s . length ; if ( l < 2 ) return false ; for ( let i = 0 ; i < l - 1 ; i ++ ) { let left = s . substring ( 0 , i + 1 ) ; let right = s . substring ( i + 1 ) ; let x = parseInt ( left ) ; let y = parseInt ( right ) ; if ( ! isPrime ( x + y ) ) return false ; } return true ; }
function digProduct ( n ) { var product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = parseInt ( n / 10 ) ; } return product ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function nextPrime ( N ) { if ( N <= 1 ) return 2 ; var prime = N ; var found = false ; while ( ! found ) { prime ++ ; if ( isPrime ( prime ) ) found = true ; } return prime ; }
function isPointerPrime ( n ) { if ( isPrime ( n ) && ( n + digProduct ( n ) == nextPrime ( n ) ) ) return true ; else return false ; }
function sieve ( ) { position [ 0 ] = - 1 ; position [ 1 ] = - 1 ; let pos = 0 ; for ( let i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( let j = i * 2 ; j <= limit ; j += i ) position [ j ] = - 1 ; } } }
function getSum ( n ) { let sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = parseInt ( n / 10 ) ; } return sum ; }
function power ( x , y ) { if ( y == 0 ) { return 1 ; } if ( y % 2 == 0 ) { return ( power ( x , Math . floor ( y / 2 ) ) * power ( x , Math . floor ( y / 2 ) ) ) ; } return ( x * power ( x , Math . floor ( y / 2 ) ) * power ( x , Math . floor ( y / 2 ) ) ) ; }
function isPerfectDigitalInvariant ( x ) { for ( var fixed_power = 1 ; ; fixed_power ++ ) { var temp = x , sum = 0 ; while ( temp ) { var r = temp % 10 ; sum += power ( r , fixed_power ) ; temp = Math . floor ( temp / 10 ) ; } if ( sum == x ) { return true ; } if ( sum > x ) { return false ; } } }
function isWasteful ( n ) { if ( n == 1 ) return false ; let original_no = n ; let sumDigits = 0 ; while ( original_no > 0 ) { sumDigits ++ ; original_no = Math . floor ( original_no / 10 ) ; } let pDigit = 0 , count_exp = 0 , p = 0 ; for ( let i = 0 ; primes [ i ] <= Math . floor ( n / 2 ) ; i ++ ) { while ( n % primes [ i ] == 0 ) { p = primes [ i ] ; n = Math . floor ( n / p ) ; count_exp ++ ; } while ( p > 0 ) { pDigit ++ ; p = Math . floor ( p / 10 ) ; } while ( count_exp > 1 ) { pDigit ++ ; count_exp = Math . floor ( count_exp / 10 ) ; } } if ( n != 1 ) { while ( n > 0 ) { pDigit ++ ; n = Math . floor ( n / 10 ) ; } } return ( pDigit > sumDigits ) ; }
function Solve ( N ) { for ( let i = 1 ; i < N ; i ++ ) { if ( isWasteful ( i ) ) { document . write ( i + "▁" ) ; } } }
function isDNum ( n ) { if ( n < 4 ) return false ; let numerator = 0 , hcf = 0 ; for ( k = 2 ; k <= n ; k ++ ) { numerator = parseInt ( ( Math . pow ( k , n - 2 ) - k ) ) ; hcf = __gcd ( n , k ) ; } if ( hcf == 1 && ( numerator % n ) != 0 ) return false ; return true ; }
function isComposite ( n ) { if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
function isEnlightened ( N ) { if ( ! isComposite ( N ) ) return false ; var num = ( N . toString ( ) ) ; var prefixConc = concatenatePrimeFactors ( N ) ; return ( prefixConc ) ; }
function isIdoneal ( n ) { for ( var a = 1 ; a <= n ; a ++ ) { for ( var b = a + 1 ; b <= n ; b ++ ) { for ( var c = b + 1 ; c <= n ; c ++ ) { if ( a * b + b * c + c * a == n ) return false ; } } } return true ; }
function isAllDigitsDivide ( n ) { let temp = n ; while ( temp > 0 ) { let digit = temp % 10 ; if ( ! ( checkDivisibility ( n , digit ) ) ) return false ; temp = parseInt ( temp / 10 ) ; } return true ; }
function isAllDigitsDistinct ( n ) { let arr = Array ( 10 ) . fill ( 0 ) ; while ( n > 0 ) { let digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = parseInt ( n / 10 ) ; } return true ; }
function isLynchBell ( n ) { return isAllDigitsDivide ( n ) && isAllDigitsDistinct ( n ) ; }
function printhexaRec ( n ) { if ( n == 0 n == 1 n == 2 n == 3 n == 4 n == 5 ) return 0 ; else if ( n == 6 ) return 1 ; else return ( printhexaRec ( n - 1 ) + printhexaRec ( n - 2 ) + printhexaRec ( n - 3 ) + printhexaRec ( n - 4 ) + printhexaRec ( n - 5 ) + printhexaRec ( n - 6 ) ) ; }
function printhexa ( n ) { if ( n < 0 ) return ; let first = 0 ; let second = 0 ; let third = 0 ; let fourth = 0 ; let fifth = 0 ; let sixth = 1 ; let curr = 0 ; if ( n < 6 ) document . write ( first ) ; else if ( n == 6 ) document . write ( sixth ) ; else { for ( let i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } document . write ( curr ) ; }
function isGapful ( n ) { let first_dig = firstDigit ( n ) ; let last_dig = lastDigit ( n ) ; let concatenation = first_dig * 10 + last_dig ; return ( n % concatenation == 0 ) ; }
function check ( x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
function isPossible ( A , B , N , K , L ) { let needa , needb ; if ( A % K == 0 ) needa = Math . floor ( A / K ) ; else needa = Math . floor ( A / K ) + 1 ; if ( B % L == 0 ) needb = Math . floor ( B / L ) ; else needb = Math . floor ( B / L ) + 1 ; let total = needa + needb ; if ( total > N ) return false ; else return true ; }
function CountTotalfactors ( ) { tfactor [ 1 ] = pre [ 1 ] = 1 ; for ( var i = 2 ; i <= MAX ; i ++ ) { var mspf = spf [ i ] ; var prim = mspf ; var temp = i ; var cnt = 0 ; while ( temp % mspf == 0 ) { temp = parseInt ( temp / mspf ) ; cnt += 1 ; prim = prim * mspf ; } tfactor [ i ] = ( cnt + 1 ) * tfactor [ temp ] ; pre [ i ] = pre [ i - 1 ] + tfactor [ i ] ; } }
function BinarySearch ( X ) { var start = 1 ; var end = MAX - 1 ; while ( start < end ) { var mid = parseInt ( ( start + end ) / 2 ) ; if ( pre [ mid ] == X ) return mid ; else if ( pre [ mid ] < X ) start = mid + 1 ; else end = mid ; } return start ; }
function buildSieve ( sum ) { prime = Array ( sum + 1 ) . fill ( true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( var p = 2 ; p * p < ( sum + 1 ) ; p ++ ) { if ( prime [ p ] == true ) { for ( var i = p * 2 ; i < ( sum + 1 ) ; i += p ) prime [ i ] = false ; } } }
function getSum ( a ) { var s = 0 ; for ( var i = 0 ; i < 4 ; i ++ ) for ( var j = 0 ; j < 5 ; j ++ ) s += a [ i ] [ j ] ; return s ; }
function checkIndex ( n , m , a ) { for ( var i = 0 ; i < n ; i ++ ) for ( var j = 0 ; j < m ; j ++ ) { if ( prime [ i + j ] && ! prime [ a [ i ] [ j ] ] ) { return false ; } } return true ; }
function takeSum ( a ) { let s = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < M ; j ++ ) s += a [ i ] [ j ] ; return s ; }
function sumOfSumSeries ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum = sum + ( i * ( i + 1 ) ) / 2 ; } return sum ; }
function isPrime ( n ) { if ( n == 1 ) return true ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function checkExpression ( n ) { if ( isPrime ( n ) ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function placeValue ( N , num ) { var total = 1 , value = 0 , rem = 0 ; while ( true ) { rem = N % 10 ; N = parseInt ( N / 10 ) ; if ( rem == num ) { value = total * rem ; break ; } total = total * 10 ; } return value ; }
function isContaindigit ( n ) { while ( n > 0 ) { if ( ! ( n % 10 == 0 n % 10 == 1 n % 10 == 8 ) ) return false ; n = parseInt ( n / 10 , 10 ) ; } return true ; }
function ispalindrome ( n ) { let temp = n . toString ( ) ; let l = temp . length ; for ( let i = 0 ; i < parseInt ( l / 2 , 10 ) ; i ++ ) { if ( temp [ i ] != temp [ l - i - 1 ] ) return false ; } return true ; }
function printTetradicPrimesLessThanN ( n ) { let prime = new Array ( n + 1 ) ; prime . fill ( true ) ; let p = 2 ; while ( p * p <= n ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i < n + 1 ; i += p ) prime [ i ] = false ; } p += 1 ; } for ( p = 2 ; p < n + 1 ; p ++ ) { if ( prime [ p ] && isTetradic ( p ) ) document . write ( p + "▁" ) ; } }
function BeattySequence ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { let ans = parseInt ( Math . floor ( i * Math . sqrt ( 2 ) ) ) ; document . write ( ans + ",▁" ) ; } }
function concat ( a , b ) { var s1 = a . toString ( ) ; var s2 = b . toString ( ) ; var s = s1 + s2 ; var c = s ; return c ; }
function isAstonishing ( n ) { for ( var i = 1 ; i < n ; i ++ ) { var sum = 0 ; for ( var j = i ; j < n ; j ++ ) { sum += j ; if ( sum == n ) { var concatenation = concat ( i , j ) ; if ( concatenation == n ) { return true ; } } } } return false ; }
function getSum ( n ) { let sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = parseInt ( n / 10 ) ; } return sum ; }
function isSelfNum ( n ) { for ( let m = 1 ; m <= n ; m ++ ) { if ( m + getSum ( m ) == n ) return false ; } return true ; }
function Sum ( N ) { let SumOfPrimeDivisors = Array ( N + 1 ) . fill ( 0 ) ; for ( let i = 2 ; i <= N ; ++ i ) { if ( SumOfPrimeDivisors [ i ] == 1 ) { for ( let j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; }
function RuthAaronNumber ( n ) { if ( Sum ( n ) == Sum ( n + 1 ) ) return true ; else return false ; }
function binomialCoeff ( n , k ) { var C = Array . from ( Array ( n + 1 ) , ( ) => Array ( k + 1 ) ) ; var i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
function SieveOfEratosthenes ( n , isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( let i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
function countDigit ( n ) { let count = 0 ; while ( n != 0 ) { n = parseInt ( n / 10 ) ; ++ count ; } return count ; }
function sortStack ( input ) { var tmpStack = [ ] ; while ( input . length != 0 ) { var tmp = input [ input . length - 1 ] ; input . pop ( ) ; while ( tmpStack . length != 0 && tmpStack [ tmpStack . length - 1 ] < tmp ) { input . push ( tmpStack [ tmpStack . length - 1 ] ) ; tmpStack . pop ( ) ; } tmpStack . push ( tmp ) ; } return tmpStack ; }
function sortArrayUsingStacks ( arr , n ) { var input = [ ] ; for ( var i = 0 ; i < n ; i ++ ) input . push ( arr [ i ] ) ; var tmpStack = sortStack ( input ) ; for ( var i = 0 ; i < n ; i ++ ) { arr [ i ] = tmpStack [ tmpStack . length - 1 ] ; tmpStack . pop ( ) ; } }
function getSum ( n ) { let sum = 0 ; for ( i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; }
function MultiplyPerfectNumber ( n ) { if ( getSum ( n ) % n == 0 ) return true ; else return false ; }
function phi ( n ) { let result = n ; for ( let p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) { n = parseInt ( n / p ) ; } result -= parseInt ( result / p ) ; } } if ( n > 1 ) result -= parseInt ( result / n ) ; return result ; }
function isPower ( a ) { if ( a == 1 ) return true ; for ( let i = 2 ; i * i <= a ; i ++ ) { let val = Math . log ( a ) / Math . log ( i ) ; if ( ( val - parseInt ( val ) < 0.00000001 ) ) return true ; } return false ; }
function isCunningham ( n ) { return isPower ( n - 1 ) || isPower ( n + 1 ) ; }
function checkSame ( n , b ) { var m = { } ; while ( n != 0 ) { var r = n % b ; n = n / b ; if ( r in m ) m [ r ] += 1 else m [ r ] = 1 } var last = - 1 ; for ( var i in m ) { if ( last != - 1 && m [ i ] != last ) { return false ; } else { last = m [ i ] ; } } return true ; }
function SubArrayProdct ( arr , n ) { let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) result *= Math . pow ( arr [ i ] , ( i + 1 ) * ( n - i ) ) ; return result ; }
function fact ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
function countWays ( m , n , x , y ) { return nCr ( m + n , m ) - nCr ( x + y , x ) * nCr ( m + n - x - y , m - x ) ; }
function averageRuns ( runs , matches , notout ) { let out1 ; out1 = matches - notout ; if ( out1 == 0 ) return - 1 ; let avg = parseInt ( ( runs ) / out1 , 10 ) ; return avg ; }
function seriesSum ( n ) { let sum = 0 ; let currProd = 1 ; let currSum = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { currProd *= i ; currSum += i ; sum += currProd - currSum ; } return sum ; }
function seriesSumUtil ( k , n , prevSum , multi , add ) { if ( k == n + 1 ) { return prevSum ; } multi = multi * k ; add = add + k ; prevSum = prevSum + multi - add ; return seriesSumUtil ( k + 1 , n , prevSum , multi , add ) ; }
function seriesSum ( n ) { if ( n == 1 ) return 0 ; let prevSum = 0 ; let multi = 1 ; let add = 1 ; return seriesSumUtil ( 2 , n , prevSum , multi , add ) ; }
function Is_possible ( N ) { let C = 0 ; let D = 0 ; while ( N % 10 == 0 ) { N = N / 10 ; C += 1 ; } if ( Math . pow ( 2 , ( Math . log ( N ) / ( Math . log ( 2 ) ) ) ) == N ) { D = ( Math . log ( N ) / ( Math . log ( 2 ) ) ) ; if ( C >= D ) document . write ( "YES" ) ; else document . write ( "NO" ) ; } else document . write ( "NO" ) ; }
function maximumAND ( L , R ) { return R ; }
function count ( a , n ) { let countElements = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let flag = true ; for ( let j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( a [ i ] % a [ j ] == 0 ) { flag = false ; break ; } } if ( flag == true ) ++ countElements ; } return countElements ; }
function countEle ( a , n ) { let len = 0 ; let hmap = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { len = Math . max ( len , a [ i ] ) ; if ( hmap . has ( a [ i ] ) ) { hmap . set ( a [ i ] , hmap . get ( a [ i ] ) + 1 ) ; } else { hmap . set ( a [ i ] , 1 ) ; } } let v = Array . from ( { length : len + 1 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i <= len ; i ++ ) { v [ i ] = true ; } for ( let i = 0 ; i < n ; i ++ ) { if ( v [ a [ i ] ] == false ) continue ; for ( let j = 2 * a [ i ] ; j <= len ; j += a [ i ] ) { v [ j ] = false ; } } let count = 0 ; for ( let i = 1 ; i <= len ; i ++ ) { if ( v [ i ] == true && hmap . has ( i ) && hmap . get ( i ) == 1 && hmap . get ( i ) == 1 ) { count += 1 ; } } return count ; }
function find_min_sum ( a , b , c ) { let x = 0 , y = 0 , g = 0 ; if ( possible_solution ( a , b , c ) == 0 ) return - 1 ; if ( g != 0 ) { a = parseInt ( a / g , 10 ) ; b = parseInt ( b / g , 10 ) ; } let sign_a = a > 0 ? + 1 : - 1 ; let sign_b = b > 0 ? + 1 : - 1 ; shift_solution ( a , b , parseInt ( - x / b , 10 ) ) ; if ( x < 0 ) shift_solution ( a , b , sign_b ) ; let minx1 = x ; shift_solution ( a , b , parseInt ( y / a , 10 ) ) ; if ( y < 0 ) shift_solution ( a , b , - sign_a ) ; let minx2 = x ; if ( minx2 > x ) { let temp = minx2 ; minx2 = x ; x = temp ; } let minx = Math . max ( minx1 , minx2 ) ; if ( minx > x ) return - 1 ; let miny = parseInt ( ( c - a * x ) / b , 10 ) ; return ( miny + minx ) ; }
function countPairs ( A , n ) { let count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( A [ i ] % 2 == 0 && A [ j ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ j ] % 2 != 0 ) ) count ++ ; } } return count ; }
function smallestNumber ( N ) { return N * Math . ceil ( Math . pow ( 10 , ( N - 1 ) ) / N ) ; }
function maxPrimefactorNum ( N ) { let arr = Array ( N + 1 ) . fill ( 1 ) ; for ( let i = 2 ; i <= N ; i ++ ) { if ( arr [ i ] == 1 ) { for ( let j = i ; j <= N ; j += i ) { arr [ j ] *= i ; } } } let maxValue = 1 ; for ( let i = 2 ; i <= N ; i ++ ) { if ( arr [ i ] > maxValue ) { maxValue = i ; } } return maxValue ; }
function linearSum ( n ) { return ( n * ( n + 1 ) / 2 ) % mod ; }
function rangeSum ( b , a ) { return ( linearSum ( b ) - linearSum ( a ) ) % mod ; }
function totalSum ( n ) { let result = 0 ; let i = 1 ; while ( true ) { result += rangeSum ( Math . floor ( n / i ) , Math . floor ( n / ( i + 1 ) ) ) * ( i % mod ) % mod ; result %= mod ; if ( i == n ) break ; i = Math . floor ( n / ( n / ( i + 1 ) ) ) ; } return result ; }
function CountPairs ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; }
function isPal ( a , n , m ) { for ( let i = 0 ; i < n / 2 ; i ++ ) { for ( let j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; }
function smallestNum ( n ) { return parseInt ( n * n % 9 + 1 ) * Math . pow ( 10 , parseInt ( n * n / 9 ) ) - 1 ; }
function smallestNumber ( N ) { document . write ( ( N % 9 + 1 ) * Math . pow ( 10 , parseInt ( N / 9 , 10 ) ) - 1 ) ; }
function findNthTerm ( n ) { document . write ( parseInt ( ( n * ( 5 * n + 3 ) ) / 2 ) ) ; }
function findNthTerm ( n ) { document . write ( n * ( 2 * n + 1 ) ) ; }
function reversDigits ( num ) { let rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = parseInt ( num / 10 ) ; } return rev_num ; }
function isPerfectSquare ( x ) { let sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
function isRare ( N ) { let reverseN = reversDigits ( N ) ; if ( reverseN == N ) return false ; return isPerfectSquare ( N + reverseN ) && isPerfectSquare ( N - reverseN ) ; }
function getProduct ( n ) { let product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = parseInt ( n / 10 ) ; } return product ; }
function isDouble ( num ) { let s = num . toString ( ) ; let l = s . length ; if ( s [ 0 ] == s . charAt [ 1 ] ) return false ; if ( l % 2 == 1 ) { s = s + s [ 1 ] ; l ++ ; } let s1 = s . substr ( 0 , l / 2 ) ; let s2 = s . substr ( l / 2 ) ; return ( s1 == s2 ) ; }
function isNontrivialUndulant ( N ) { return N > 100 && isDouble ( N ) ; }
function findNthTerm ( n ) { document . write ( n * ( 4 * n + 3 ) ) ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function getSum ( n ) { let sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
function isAdditivePrime ( n ) { if ( ! isPrime ( n ) ) return false ; return isPrime ( getSum ( n ) ) ; }
function isStraighLineNum ( N ) { if ( N <= 99 ) return false ; let s = N . toString ( ) ; let d = s [ 1 ] - s [ 0 ] ; for ( let i = 2 ; i < s . length ; i ++ ) if ( s [ i ] - s [ i - 1 ] != d ) return false ; return true ; }
function findNthTerm ( n ) { document . write ( ( Math . pow ( 2 , n ) ) - ( 2 * n ) ) ; }
function isEvenOddForm ( s ) { let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 && s [ i ] % 2 != 0 ) return false ; if ( i % 2 == 1 && s [ i ] % 2 != 1 ) return false ; } return true ; }
function isOddEvenForm ( s ) { let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 && s [ i ] % 2 != 1 ) return false ; if ( i % 2 == 1 && s [ i ] % 2 != 0 ) return false ; } return true ; }
function isAlternating ( n ) { let str = n . toString ( ) ; return ( isEvenOddForm ( str ) || isOddEvenForm ( str ) ) ; }
function findNthTerm ( n ) { document . write ( n * n - n + 1 ) ; }
function isDroll ( n ) { if ( n == 1 ) return false ; let sum_even = 0 ; let sum_odd = 0 ; while ( n % 2 == 0 ) { sum_even += 2 ; n = n / 2 ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { sum_odd += i ; n = n / i ; } } if ( n > 2 ) sum_odd += n ; return sum_even == sum_odd ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function areAnagrams ( a , b ) { let freqA = Array ( TEN ) . fill ( 0 ) ; let freqB = Array ( TEN ) . fill ( 0 ) ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; }
function DecakismyriagonNum ( N ) { return ( 99998 * N * N - 99996 * N ) / 2 ; }
function iszygodromeNum ( N ) { let s = N . toString ( ) ; s = "▁" + s + "▁" ; for ( i = 1 ; i < s . length - 1 ; i ++ ) { if ( s [ i ] != s [ i - 1 ] && s [ i ] != s [ i + 1 ] ) { return false ; } } return true ; }
function isLoeschian ( n ) { for ( let x = 1 ; x <= Math . sqrt ( n ) ; x ++ ) { for ( let y = 1 ; y <= Math . sqrt ( n ) ; y ++ ) { if ( x * x + x * y + y * y == n ) return true ; } } return false ; }
function printSeries ( N ) { let ith_term = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { ith_term = ( 13 * i * ( i - 1 ) ) / 2 + 2 ; document . write ( ith_term + ",▁" ) ; } }
function printSeries ( n , a , b , c ) { let d ; if ( n == 1 ) { document . write ( a + "▁" ) ; return ; } if ( n == 2 ) { document . write ( a + "▁" + b + "▁" ) ; return ; } document . write ( a + "▁" + b + "▁" + c + "▁" ) ; for ( let i = 4 ; i <= n ; i ++ ) { d = a + b + c ; document . write ( d + "▁" ) ; a = b ; b = c ; c = d ; } }
function sieveSundaram ( ) { let marked = Array . from ( { length : MAX / 2 + 1 } , ( _ , i ) => 0 ) ; for ( let i = 1 ; i <= ( Math . sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( let j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j += 2 * i + 1 ) marked [ j ] = true ; primes . push ( 2 ) ; for ( let i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push ( 2 * i + 1 ) ; }
function Pairs ( C ) { var ans = [ ] ; for ( var i = 1 ; i < C ; i ++ ) { for ( var j = i + 1 ; j < C ; j ++ ) { if ( ( i * i ) + ( j * j ) == ( C * C ) ) { ans . push ( [ i , j ] ) ; } } } return ans ; }
function strikerate ( bowls , runs ) { let z ; z = ( runs / bowls ) * 100 ; return z . toFixed ( 3 ) ; }
function factorize ( N ) { var count = 0 ; var cnt = 0 ; while ( ( N % 2 ) == 0 ) { N = N / 2 ; count ++ ; } cnt = cnt + count ; for ( i = 3 ; i <= Math . sqrt ( N ) ; i += 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } cnt = cnt + count ; } if ( N > 2 ) cnt = cnt + 1 ; return cnt ; }
function ifNumberExists ( X , Y ) { var C , dsum ; C = X - Y - 1 ; dsum = factorize ( X ) ; if ( dsum >= C ) document . write ( "YES" ) ; else document . write ( "NO" ) ; }
function checkArray ( n , k , arr ) { var cnt = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; }
function print_nearest_prime ( arr , N ) { let maxm = Math . max ( ... arr ) ; SieveOfEratosthenes ( maxm ) ; let primes = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { if ( ! prime [ arr [ i ] ] ) primes . push ( i ) ; } if ( primes . length == 0 ) { for ( let i = 0 ; i < N ; i ++ ) { document . write ( - 1 + "▁" ) ; } return ; } let curr = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( curr == primes . length - 1 || i <= primes [ curr ] ) { document . write ( arr [ primes [ curr ] ] + "▁" ) ; continue ; } if ( Math . abs ( primes [ curr ] - i ) < Math . abs ( primes [ curr + 1 ] - i ) ) { document . write ( arr [ primes [ curr ] ] + "▁" ) ; } else { curr ++ ; document . write ( arr [ primes [ curr ] ] + "▁" ) ; } } }
function CountPairs ( n ) { let cnt = 0 ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { let div1 = i ; let div2 = Math . floor ( n / i ) ; let sum = div1 + div2 ; if ( gcd ( sum , n ) == 1 ) cnt += 1 ; } } return cnt ; }
function allQuotients ( N ) { var s = new Set ( ) ; for ( var k = 1 ; k <= N + 1 ; k ++ ) { s . add ( parseInt ( N / k ) ) ; } var ls = Array . from ( s ) . reverse ( ) ; ls . forEach ( v => document . write ( v + "▁" ) ) }
function findPosition ( n ) { var i = 0 ; var pos = 0 ; while ( n > 0 ) { if ( n % 10 == 7 ) { pos = pos + parseInt ( Math . pow ( 2 , i + 1 ) ) ; } else { pos = pos + parseInt ( Math . pow ( 2 , i ) ) ; } i ++ ; n = parseInt ( n / 10 ) ; } document . write ( pos ) ; }
function greatestOddFactor ( n ) { let pow_2 = ( Math . log ( n ) ) ; let i = 1 ; while ( i <= pow_2 ) { let fac_2 = ( 2 * i ) ; if ( n % fac_2 == 0 ) { if ( ( n / fac_2 ) % 2 == 1 ) { return ( n / fac_2 ) ; } } i += 1 ; } return 0 ; }
function countSmaller ( str ) { var n = str . length ; for ( var i = 0 ; i < n ; i ++ ) { var cnt = 0 ; for ( var j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] < str [ i ] ) { cnt += 1 ; } } document . write ( cnt + "▁" ) ; } }
function sum_star_num ( n ) { let summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n ; return summ ; }
function solve ( n , vec ) { let a = [ ] ; let b = [ ] ; for ( let pr = 0 ; pr < vec . length ; pr ++ ) { a . push ( vec [ pr ] [ 0 ] ) ; b . push ( vec [ pr ] [ 1 ] ) ; } a . sort ( function ( c , d ) { return c - d ; } ) ; b . sort ( function ( c , d ) { return c - d ; } ) ; let left , right , ans ; if ( ( n & 1 ) != 0 ) { left = a [ Math . floor ( n / 2 ) ] ; right = b [ Math . floor ( n / 2 ) ] ; ans = right - left + 1 ; } else { left = ( a [ Math . floor ( n / 2 ) ] + a [ Math . floor ( n / 2 ) - 1 ] ) ; right = ( b [ Math . floor ( n / 2 ) ] + b [ Math . floor ( n / 2 ) - 1 ] ) ; ans = right - left + 1 ; } document . write ( ans ) ; }
function find_pairs ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } for ( let [ key , value ] of mp . entries ( ) ) { let count = value ; if ( count > 1 ) { ans += ( ( count * ( count - 1 ) ) / 2 ) ; } } return ans ; }
function Majority_in_linklist ( head ) { var s = "" ; var t = "" ; var p = 0 , q = 0 ; var ptr = null ; while ( head != null ) { if ( s == head . i ) { p = p + 1 ; } else { if ( t == head . i ) { q = q + 1 ; } else { if ( p == 0 ) { s = head . i ; p = 1 ; } else { if ( q == 0 ) { t = head . i ; q = 1 ; } else { p = p - 1 ; q = q - 1 ; } } } } head = head . next ; } head = ptr ; p = 0 ; q = 0 ; while ( head != null ) { if ( s == head . i ) { p = 1 ; } else { if ( t == head . i ) { q = 1 ; } } head = head . next ; } if ( p > q ) { return s ; } else { return t ; } }
function gonNum65537 ( n ) { return ( 65535 * n * n - 65533 * n ) / 2 ; }
function MegagonNum ( n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; }
function gonNum120 ( n ) { return ( 118 * n * n - 116 * n ) / 2 ; }
function TetracontaoctagonalNum ( n ) { return ( 46 * n * n - 44 * n ) / 2 ; }
function TetracontadigonalNum ( n ) { return ( 40 * n * n - 38 * n ) / 2 ; }
function HexacontatetragonNum ( n ) { return ( 62 * n * n - 60 * n ) / 2 ; }
function binpow ( a , b ) { let res = 1 ; while ( b ) { if ( b & 1 ) res = res * a ; a = a * a ; b = Math . floor ( b / 2 ) ; } return res ; }
function checkOverlapping ( a , b ) { if ( a [ 0 ] < b [ 0 ] ) { var temp = a [ 0 ] ; a [ 0 ] = b [ 0 ] ; b [ 0 ] = temp ; temp = a [ 1 ] ; a [ 1 ] = b [ 1 ] ; b [ 1 ] = temp ; } if ( b [ 0 ] <= a [ 0 ] && a [ 0 ] <= b [ 1 ] ) return true ; return false ; }
function find ( a , i ) { if ( a [ i ] == i ) { return i ; } a [ i ] = find ( a , a [ i ] ) ; return a [ i ] ; }
function checkNonOverlapping ( arr , n ) { var dsu = [ ] ; for ( var i = 0 ; i < n + 1 ; i ++ ) { dsu . push ( i ) ; } for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { if ( checkOverlapping ( arr [ i ] , arr [ j ] ) ) { if ( union ( dsu , i , j ) ) { return false ; } } } } return true ; }
function isPossible ( A , B ) { return ( A - B > 1 ) ; }
function minDivisorDifference ( n ) { let num1 = 0 ; let num2 = 0 ; for ( let i = parseInt ( Math . sqrt ( n ) , 10 ) ; i <= n ; i ++ ) { if ( n % i == 0 ) { num1 = i ; num2 = parseInt ( n / i , 10 ) ; break ; } } return Math . abs ( num1 - num2 ) ; }
function dfs ( g , u , par ) { sub [ u ] = minDivisorDifference ( u ) ; let mx = 0 ; for ( let c = 0 ; c < g [ u ] . length ; c ++ ) { if ( g [ u ] != par ) { let ans = dfs ( g , g [ u ] , u ) ; mx = Math . max ( mx , ans ) ; } } sub [ u ] += mx ; return sub [ u ] ; }
function findLCMPrime ( a , b ) { if ( a == b ) { return a ; } return a * b ; }
function smallestNumber ( N ) { document . write ( N * parseInt ( Math . ceil ( Math . pow ( 2 , ( N - 1 ) ) / N ) ) ) ; }
function smallestNumber ( N ) { document . write ( N * Math . floor ( ( Math . pow ( 10 , N ) - 1 ) / N ) ) ; }
function istriacontagonal ( N ) { let n = ( ( 26 + Math . sqrt ( 224 * N + 676 ) ) / 56 ) ; return ( n - parseInt ( n ) ) == 0 ; }
function checkSolution ( a , b , c ) { if ( a == c ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function isComposite ( n ) { if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; let i = 5 ; while ( i * i <= n ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; i = i + 6 ; } return false ; }
function Compositorial_list ( n ) { let l = 0 ; for ( let i = 4 ; i < 1000000 ; i ++ ) { if ( l < n ) { if ( isComposite ( i ) ) { compo . push ( i ) ; l += 1 ; } } } }
function calculateCompositorial ( n ) { let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) result = result * compo [ i ] ; return result ; }
function numberOfDigits ( N ) { let nod = Math . floor ( Math . log10 ( N ) + 1 ) ; let toDecrease = ( Math . pow ( 10 , nod ) - 1 ) / 9 ; document . write ( ( N + 1 ) * nod - toDecrease ) ; }
function Maxlength ( arr , N ) { let zeroindex = Array . from ( { length : 20000 } , ( _ , i ) => 0 ) ; let maxlen ; let size = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zeroindex [ size ++ ] = i ; } if ( size == 0 ) { maxlen = N ; } else { maxlen = zeroindex [ 0 ] ; for ( let i = 0 ; i < size ; i ++ ) { if ( zeroindex [ i + 1 ] - zeroindex [ i ] - 1 > maxlen ) { maxlen = zeroindex [ i + 1 ] - zeroindex [ i ] - 1 ; } } if ( N - zeroindex [ size - 1 ] - 1 > maxlen ) { maxlen = N - zeroindex [ size - 1 ] - 1 ; } } document . write ( maxlen ) ; }
function isPossible ( arr , N , K ) { let oddCount = 0 , evenCount = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCount ++ ; } else { oddCount ++ ; } } if ( evenCount == N || ( oddCount == N && K % 2 == 0 ) || ( K == N && oddCount % 2 == 0 ) ) { return false ; } else { return true ; } }
function productOfGP ( a , r , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; }
function productOfGP ( a , r , n ) { return Math . pow ( a , n ) * Math . pow ( r , n * ( n - 1 ) / 2 ) ; }
function productOfGP ( a , r , n ) { let an = a * Math . pow ( r , n - 1 ) ; return Math . sqrt ( Math . pow ( a * an , n ) ) ; }
function is_Chiliagon ( N ) { let n = ( 996 + Math . sqrt ( 7984 * N + 992016 ) ) / 1996 ; return ( n - Math . floor ( n ) ) == 0 ; }
function commonSubarrays ( A , B , N ) { let Map = Array . from ( { length : N + 1 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) Map [ A [ i ] ] = i ; for ( let i = 0 ; i < N ; i ++ ) { B [ i ] = Map [ B [ i ] ] ; } let count = 0 ; let i = 0 , K ; while ( i < N ) { K = 1 ; i += 1 ; while ( i < N && B [ i ] == B [ i - 1 ] + 1 ) { i += 1 ; K += 1 ; } count = count + ( ( K ) * ( K + 1 ) ) / 2 ; } return count ; }
function getArrayOfSizeK ( n , k ) { let ans = [ ] ; let odd = n - ( ( k - 1 ) * 1 ) ; if ( odd > 0 && odd % 2 != 0 ) { for ( let i = 0 ; i < k - 1 ; i ++ ) { ans . push ( 1 ) ; } ans . push ( odd ) ; } let even = n - ( ( k - 1 ) * 2 ) ; if ( even > 0 && even % 2 == 0 && ans . length == 0 ) { for ( let i = 0 ; i < k - 1 ; i ++ ) { ans . push ( 2 ) ; } ans . push ( even ) ; } if ( ans . length > 0 ) { for ( let i = 0 ; i < k ; i ++ ) { document . write ( ans [ i ] + "▁" ) ; } } else { document . write ( "NO" ) ; } }
function checkDivisbility ( num ) { let digit ; let N = num ; while ( num != 0 ) { digit = num % 10 ; num = Math . floor ( num / 10 ) ; if ( digit == 0 N % digit != 0 ) return false ; } return true ; }
function inv ( a , m ) { let m0 = m , t , q ; let x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = Math . floor ( a / m ) ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
function derivative ( x ) { return 3 * x * x ; }
function Image ( x , k ) { return x * x * x - k ; }
function next_power ( a_t , t , a1 , prime , k ) { let power_p = Math . floor ( Math . pow ( prime , t + 1 ) ) ; let next_a = ( a_t - Image ( a_t , k ) * inv ( derivative ( a1 ) , prime ) ) % power_p ; if ( next_a < 0 ) return next_a += power_p ; return next_a ; }
function powerOfPrime ( prime , power , k , a1 ) { if ( derivative ( a1 ) != 0 ) { let a_t = a1 ; for ( let p = 1 ; p < power ; p ++ ) { a_t = next_power ( a_t , p , a1 , prime , k ) ; } return a_t ; } return - 1 ; }
function findlcm ( arr , n ) { var ans = arr [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; } return ans ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function minLCM ( arr , n ) { let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { let g = gcd ( arr [ i ] , arr [ j ] ) ; let lcm = arr [ i ] / g * arr [ j ] ; ans = Math . min ( ans , lcm ) ; } } return ans ; }
function minLCM ( arr , n ) { var mx = 0 ; for ( var i = 0 ; i < n ; i ++ ) { mx = Math . max ( mx , arr [ i ] ) ; } var mul = Array . from ( Array ( mx + 1 ) , ( ) => Array ( ) ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( mul [ arr [ i ] ] . length > 1 ) { continue ; } mul [ arr [ i ] ] . push ( arr [ i ] ) ; } for ( var i = 1 ; i <= mx ; i ++ ) { for ( var j = i + i ; j <= mx ; j += i ) { if ( mul [ i ] . length > 1 ) { break ; } mul [ j ] . forEach ( k => { if ( mul [ i ] . length <= 1 ) { mul [ i ] . push ( k ) ; } } ) ; } } var ans = 1000000000 ; for ( var i = 1 ; i <= mx ; i ++ ) { if ( mul [ i ] . length <= 1 ) continue ; var a = mul [ i ] [ 0 ] , b = mul [ i ] [ 1 ] ; var lcm = ( a * b ) / i ; ans = Math . min ( ans , lcm ) ; } return ans ; }
function isSuffix ( s1 , s2 ) { var n1 = s1 . length ; var n2 = s2 . length ; if ( n1 > n2 ) return false ; for ( var i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
function CheckBinaryEquivalent ( N ) { var B_Number = 0 ; var cnt = 0 ; while ( N != 0 ) { var rem = N % 2 ; var c = Math . pow ( 10 , cnt ) ; B_Number += rem * c ; N = Math . floor ( N / 2 ) ; cnt ++ ; } console . log ( B_Number ) ; var bin = B_Number . toString ( ) ; return isSuffix ( "001" , bin ) ; }
function CheckBinaryEquivalent ( N ) { return ( N - 1 ) % 8 == 0 ; }
function print_practica_No ( A , B ) { for ( var i = A ; i <= B ; i ++ ) { if ( Is_Practical ( i ) == true ) { document . write ( i + "▁" ) ; } } }
function maxDivision ( arr , n ) { arr . sort ( ( a , b ) => b - a ) ; let mxdiv = arr [ 1 ] ; for ( let i = 2 ; i < n ; ++ i ) mxdiv = mxdiv / arr [ i ] ; return arr [ 0 ] / mxdiv ; }
function solve ( n ) { let upper_limit = Math . ceil ( Math . pow ( n , 1.0 / 4 ) ) ; for ( let x = 0 ; x <= upper_limit ; x ++ ) { for ( let y = 0 ; y <= upper_limit ; y ++ ) { let num1 = x * x * x * x ; let num2 = y * y * y * y ; if ( num1 - num2 == n ) { document . write ( "x▁=▁" + x + ",▁y▁=▁" + y ) ; return ; } } } document . write ( - 1 ) ; }
function productPairs ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; }
function power ( x , y ) { let p = 1000000007 ; let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
function productPairs ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { product = ( product % mod * power ( arr [ i ] , ( 2 * n ) ) % mod ) % mod ; } return product % mod ; }
function numPairsWithPrimeSum ( arr , n ) { let N = 2 * 1000000 ; let isPrime = sieveOfEratosthenes ( N ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { let sum = arr [ i ] + arr [ j ] ; if ( isPrime [ sum ] ) { count ++ ; } } } return count ; }
function constructArray ( N ) { let arr = new Array ( N ) ; for ( let i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + ",▁" ) ; } }
function digitsPresent ( n ) { let lastDigit ; while ( n != 0 ) { lastDigit = n % 10 ; digit [ lastDigit ] = true ; n = Math . floor ( n / 10 ) ; } }
function checkLastDigit ( num ) { let count = 0 ; let lastDigit ; lastDigit = num % 10 ; if ( digit [ lastDigit ] == true ) count ++ ; return count ; }
function divisorsSame ( n ) { let even_div = 0 , odd_div = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( Math . floor ( n / i ) == i ) { if ( i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } } else { if ( i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } if ( Math . floor ( n / i ) % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } } } } return ( even_div == odd_div ) ; }
function sieveoferanthones ( ) { let prime = Array . from ( { length : n + 1 } , ( _ , i ) => true ) ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( prime [ i ] ) for ( let j = i * i ; j <= n ; j += i ) { prime [ j ] = false ; } } for ( let i = 2 ; i < n ; i ++ ) { if ( prime [ i ] ) v . push ( i ) ; } }
function find ( K , N ) { N -- ; while ( N -- ) { let curr_term = K ; let min_d = 9 ; let max_d = 0 ; while ( curr_term > 0 ) { let r = curr_term % 10 ; min_d = Math . min ( min_d , r ) ; max_d = Math . max ( max_d , r ) ; curr_term = Math . floor ( curr_term / 10 ) ; } if ( min_d == 0 ) { break ; } K = K + min_d * max_d ; } return K ; }
function Convert ( degree ) { let pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; }
function countSubarrays ( arr , n ) { let mp = new Map ( ) ; let prefixSum = Array . from ( { length : n } , ( _ , i ) => 0 ) ; let prefixMin = 0 ; prefixSum [ 0 ] = arr [ 0 ] ; prefixMin = Math . min ( prefixMin , prefixSum [ 0 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ; prefixMin = Math . min ( prefixMin , prefixSum [ i ] ) ; } let countSubs = 0 ; mp . set ( 0 , 1 ) ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; prefixSum [ i ] - j * j >= prefixMin ; j ++ ) { if ( mp . has ( prefixSum [ i ] - j * j ) ) countSubs += mp . get ( prefixSum [ i ] - j * j ) ; } if ( mp . has ( prefixSum [ i ] ) ) { mp . set ( prefixSum [ i ] , mp . get ( prefixSum [ i ] ) + 1 ) ; } else { mp . set ( prefixSum [ i ] , 1 ) ; } } return countSubs ; }
function checkSolution ( a1 , b1 , c1 , a2 , b2 , c2 ) { return ( a1 / a2 ) == ( b1 / b2 ) && ( b1 / b2 ) == ( c1 / c2 ) ; }
function chiliagonNum ( n ) { return ( 998 * n * n - 996 * n ) / 2 ; }
function checkSolution ( a , b , c ) { if ( b == 0 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function isBalancedPrime ( n ) { if ( ! isPrime ( n ) n == 2 ) return false ; let previous_prime = n - 1 ; let next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; let mean = ( previous_prime + next_prime ) / 2 ; if ( n == mean ) return true ; else return false ; }
function pentacontagonNum ( n ) { return ( 48 * n * n - 46 * n ) / 2 ; }
function positiveProduct ( arr , n ) { let even_count = 0 ; let odd_count = 0 ; let total_count = 0 ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( total_count % 2 == 0 ) { even_count ++ ; } else { odd_count ++ ; } if ( arr [ i ] < 0 ) { total_count ++ ; } if ( total_count % 2 == 0 ) ans += even_count ; else ans += odd_count ; } document . write ( ans ) ; }
function sumOfGCDofPairs ( n ) { let res = 0 ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { let d1 = i ; let d2 = Math . floor ( n / i ) ; res += d1 * getCount ( d1 , n ) ; if ( d1 != d2 ) res += d2 * getCount ( d2 , n ) ; } } return res ; }
function checkIsFibonacci ( arr , n ) { if ( n == 1 n == 2 ) return true ; arr . sort ( ( a , b ) => a - b ) ; for ( i = 2 ; i < n ; i ++ ) { if ( ( arr [ i - 1 ] + arr [ i - 2 ] ) != arr [ i ] ) return false ; } return true ; }
function lastDigitFactorial ( n ) { if ( n == 0 ) return 1 ; else if ( n <= 2 ) return n ; else if ( n == 3 ) return 6 ; else if ( n == 4 ) return 4 ; else return 0 ; }
function lastDigit2PowerN ( n ) { if ( n == 0 ) return 1 ; else if ( n % 4 == 1 ) return 2 ; else if ( n % 4 == 2 ) return 4 ; else if ( n % 4 == 3 ) return 8 ; else }
function nCr ( n , r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
function fact ( n ) { var res = 1 ; for ( var i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
function sumSubsequences ( arr , n , k ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } var kLengthSubSequence ; kLengthSubSequence = nCr ( n , k ) ; var ans = sum * ( ( k * kLengthSubSequence ) / n ) ; return ans ; }
function hasOddNumberOfDivisors ( n ) { if ( Math . sqrt ( n ) == parseInt ( Math . sqrt ( n ) , 10 ) ) return true ; return false ; }
function dfs ( node , parent ) { let count = 0 ; for ( let i = 0 ; i < adj [ node ] . length ; i ++ ) { if ( adj [ node ] [ i ] != parent ) { count += dfs ( adj [ node ] [ i ] , node ) ; } } if ( hasOddNumberOfDivisors ( a [ node ] ) ) ++ count ; ans [ node ] = count ; return count ; }
function costCalculation ( current , arr , n , pref , a , r , minimum ) { var index = lowerBound ( arr , arr . length , current ) ; var left = index * current - pref [ index ] ; var right = pref [ n ] - pref [ index ] - ( n - index ) * current ; var res = Math . min ( left , right ) ; left -= res ; right -= res ; var total = res * minimum ; total += left * a ; total += right * r ; return total ; }
function solve ( arr , n , a , r , m ) { arr . sort ( ) ; var minimum = Math . min ( a + r , m ) ; var pref = Array ( n + 1 ) . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) pref [ i + 1 ] = pref [ i ] + arr [ i ] ; var ans = 10000 ; for ( i = 0 ; i < n ; i ++ ) ans = Math . min ( ans , costCalculation ( arr [ i ] , arr , n , pref , a , r , minimum ) ) ; ans = Math . min ( ans , costCalculation ( pref [ n ] / n , arr , n , pref , a , r , minimum ) ) ; ans = Math . min ( ans , costCalculation ( pref [ n ] / n + 1 , arr , n , pref , a , r , minimum ) ) ; document . write ( ans ) ; }
function findSum ( n , k ) { var val = parseInt ( k / ( n - 1 ) ) * n ; var rem = k % ( n - 1 ) ; if ( rem == 0 ) { val = val - 1 ; } else { val = val + rem ; } var sum = parseInt ( ( val * ( val + 1 ) ) / 2 ) ; var x = parseInt ( k / ( n - 1 ) ) ; var sum_of_multiples = parseInt ( ( x * ( x + 1 ) * n ) / 2 ) ; sum -= sum_of_multiples ; return sum ; }
function getFactorization ( x ) { let count = 0 ; let v = [ ] ; while ( x % 2 == 0 ) { count ++ ; x = Math . floor ( x / 2 ) ; } if ( count != 0 ) v . push ( count ) ; for ( let i = 3 ; i <= Math . floor ( Math . sqrt ( x ) ) ; i += 2 ) { count = 0 ; while ( x % i == 0 ) { count ++ ; x = Math . floor ( x / i ) ; } if ( count != 0 ) v . push ( count ) ; } if ( x > 1 ) { v . push ( 1 ) ; } return v ; }
function nonPrimeDivisors ( N ) { let v = getFactorization ( N ) ; let ret = 1 ; for ( let i = 0 ; i < v . length ; i ++ ) ret = ret * ( v [ i ] + 1 ) ; ret = ret - v . length ; return ret ; }
function isPerfectSquare ( x ) { var s = parseInt ( Math . sqrt ( x ) ) ; return ( s * s == x ) ; }
function isFibonacci ( n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
function checkDigits ( n ) { while ( n != 0 ) { var dig = n % 10 ; if ( dig == 4 && dig == 6 && dig == 7 && dig == 9 ) return false ; n /= 10 ; } return true ; }
function isFullfibonacci ( n ) { return ( checkDigits ( n ) && isFibonacci ( n ) ) ; }
function checksilverRatio ( a , b ) { if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } let ratio1 = ( ( a / b ) * 1000 ) / 1000 ; let ratio2 = Math . floor ( ( ( 2 * a + b ) / a ) * 1000 ) ; ratio2 = ratio2 / 1000 ; if ( ratio1 == ratio2 && ( ratio1 - 2.414 ) == 0 ) { document . write ( "Yes" ) ; return true ; } else { document . write ( "No" ) ; return false ; } }
function MIN ( n ) { let ans = 11 ; while ( n ) { ans = parseInt ( Math . min ( ans , n % 10 ) ) ; n = parseInt ( n / 10 ) ; } return ans ; }
function MAX ( n ) { let ans = - 1 ; while ( n ) { ans = parseInt ( Math . max ( ans , n % 10 ) ) ; n = parseInt ( n / 10 ) ; } return ans ; }
function Find_value ( n , k ) { k -- ; let x = 0 ; let y = 0 ; while ( k -- ) { x = parseInt ( MIN ( n ) ) ; y = parseInt ( MAX ( n ) ) ; if ( y - x == 0 ) break ; n *= ( y - x ) ; } document . write ( n ) ; }
function countBinaries ( N ) { let ctr = 1 ; let ans = 0 ; while ( N > 0 ) { if ( N % 10 == 1 ) { ans += Math . pow ( 2 , ctr - 1 ) ; } else if ( N % 10 > 1 ) { ans = Math . pow ( 2 , ctr ) - 1 ; } ctr ++ ; N /= 10 ; } return ans ; }
function countBinaries ( N ) { let powersOfTwo = [ ] ; powersOfTwo . push ( 1 ) ; for ( let i = 1 ; i < 11 ; i ++ ) { powersOfTwo . push ( powersOfTwo [ i - 1 ] * 2 ) ; } let ctr = 1 ; let ans = 0 ; while ( N > 0 ) { if ( N % 10 == 1 ) { ans += powersOfTwo [ ctr - 1 ] ; } else if ( N % 10 > 1 ) { ans = powersOfTwo [ ctr ] - 1 ; } ctr ++ ; N /= 10 ; } return ans ; }
function sum_Centered_Hexadecagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Hexadecagonal_num ( i ) ; } return summ ; }
function heptadecagonal_num ( n ) { return ( ( 15 * n * n ) - 13 * n ) / 2 ; }
function sum_heptadecagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += heptadecagonal_num ( i ) ; } return summ ; }
function center_heptagonal_num ( n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
function sum_center_heptagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += center_heptagonal_num ( i ) ; } return summ ; }
function Centered_Dodecagonal_num ( n ) { return 6 * n * ( n - 1 ) + 1 ; }
function sum_Centered_Dodecagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Dodecagonal_num ( i ) ; } return summ ; }
function center_Octagonal_num ( n ) { return ( 4 * n * n - 4 * n + 1 ) ; }
function sum_center_Octagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += center_Octagonal_num ( i ) ; } return summ ; }
function Centered_decagonal_num ( n ) { return ( 5 * n * n - 5 * n + 1 ) ; }
function sum_Centered_decagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_decagonal_num ( i ) ; } return summ ; }
function center_octadecagon_num ( n ) { return ( 9 * n * n - 9 * n + 1 ) ; }
function sum_center_octadecagon_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += center_octadecagon_num ( i ) ; } return summ ; }
function Centered_Pentadecagonal_num ( n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
function sum_Centered_Pentadecagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Pentadecagonal_num ( i ) ; } return summ ; }
function isMyriagon ( N ) { n = ( 9996 + Math . sqrt ( 79984 * N + 99920016 ) ) / 19996 ; return ( n - parseInt ( n ) ) == 0 ; }
function isOctadecagon ( N ) { let n = ( 14 + Math . sqrt ( 128 * N + 196 ) ) / 32 ; return ( n - parseInt ( n ) ) == 0 ; }
function isoctagonal ( N ) { var n = ( 2 + Math . sqrt ( 12 * N + 4 ) ) / 6 ; return ( n - parseInt ( n ) == 0 ) ; }
function isheptagonal ( N ) { var n = ( 3 + Math . sqrt ( 40 * N + 9 ) ) / 10 ; return ( n - parseInt ( n ) ) == 0 ; }
function isPentadecagon ( N ) { var n = ( 11 + Math . sqrt ( 104 * N + 121 ) ) / 26 ; return ( n - parseInt ( n ) ) == 0 ; }
function nCr ( n , r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( var i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
function countSubsequences ( arr , n , k ) { var countPrime = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } if ( countPrime < k ) return 0 ; return nCr ( countPrime , k ) * Math . pow ( 2 , ( n - countPrime ) ) ; }
function longestEvenOddSubarray ( a , n ) { let longest = 1 ; let cnt = 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] + a [ i + 1 ] ) % 2 == 1 ) { cnt ++ ; } else { longest = Math . max ( longest , cnt ) ; cnt = 1 ; } } if ( longest == 1 ) return 0 ; return Math . max ( cnt , longest ) ; }
function digSum ( a ) { let sum = 0 ; while ( a ) { sum += a % 10 ; a = Math . floor ( a / 10 ) ; } return sum ; }
function isPrime ( r ) { let s = true ; for ( let i = 2 ; i * i <= r ; i ++ ) { if ( r % i == 0 ) { s = false ; break ; } } return s ; }
function istetradecagonal ( N ) { n = ( 10 + Math . sqrt ( 96 * N + 100 ) ) / 24 ; return ( n - parseInt ( n ) ) == 0 ; }
function ishexadecagonal ( N ) { let n = ( 12 + Math . sqrt ( 112 * N + 144 ) ) / 28 ; return ( n - parseInt ( n ) ) == 0 ; }
function isnonagonal ( N ) { let n = ( 5 + Math . sqrt ( 56 * N + 25 ) ) / 14 ; return ( n - parseInt ( n ) ) == 0 ; }
function nCr ( n , r ) { if ( r > n ) return 0 ; return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
function fact ( n ) { var res = 1 ; for ( var i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
function countSubsequences ( arr , n , k ) { var countOdd = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) countOdd ++ ; } var ans = nCr ( n , k ) - nCr ( countOdd , k ) ; return ans ; }
function divParts ( N ) { if ( N % 2 == 0 ) document . write ( ( N / 2 ) - 1 ) ; else document . write ( ( N / 2 ) ) ; }
function solve ( s , n ) { let left = 0 , right = 0 , maxlength = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == "(" ) left ++ ; else right ++ ; if ( left == right ) maxlength = max ( maxlength , 2 * right ) ; else if ( right > left ) left = right = 0 ; } left = right = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == "(" ) left ++ ; else right ++ ; if ( left == right ) maxlength = Math . max ( maxlength , 2 * left ) ; else if ( left > right ) left = right = 0 ; } return maxlength ; }
function Icosagonal_num ( n ) { return ( 18 * n * n - 16 * n ) / 2 ; }
function sum_Icosagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { summ += Icosagonal_num ( i ) ; } return summ ; }
function Centered_Pentagonal_num ( n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
function sum_Centered_Pentagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Pentagonal_num ( i ) ; } return summ ; }
function Centered_tridecagonal_num ( n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; }
function sum_Centered_tridecagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { summ += Centered_tridecagonal_num ( i ) ; } return summ ; }
function getMinSteps ( n , jump ) { let quotient = Math . floor ( n / jump ) ; let remainder = n % jump ; let steps = quotient + remainder ; return steps ; }
function Betrothed_Sum ( n ) { let Set = [ ] ; for ( let number_1 = 1 ; number_1 < n ; number_1 ++ ) { let sum_divisor_1 = 1 ; let i = 2 ; while ( i * i <= number_1 ) { if ( number_1 % i == 0 ) { sum_divisor_1 = sum_divisor_1 + i ; if ( i * i != number_1 ) sum_divisor_1 += parseInt ( number_1 / i ) ; } i ++ ; } if ( sum_divisor_1 > number_1 ) { let number_2 = sum_divisor_1 - 1 ; let sum_divisor_2 = 1 ; let j = 2 ; while ( j * j <= number_2 ) { if ( number_2 % j == 0 ) { sum_divisor_2 += j ; if ( j * j != number_2 ) sum_divisor_2 += parseInt ( number_2 / j ) ; } j = j + 1 ; } if ( ( sum_divisor_2 == number_1 + 1 ) && number_1 <= n && number_2 <= n ) { Set . push ( number_1 ) ; Set . push ( number_2 ) ; } } } let Summ = 0 ; for ( let i = 0 ; i < Set . length ; i ++ ) { if ( Set [ i ] <= n ) Summ += Set [ i ] ; } return Summ ; }
function constructArray ( N ) { for ( let i = 1 ; i <= N ; i ++ ) { document . write ( i + "▁" ) ; } }
function prod_of_max_min ( n ) { var largest = 0 ; var smallest = 10 ; while ( n ) { var r = n % 10 ; largest = Math . max ( r , largest ) ; smallest = Math . min ( r , smallest ) ; n = parseInt ( n / 10 ) ; } return largest * smallest ; }
function formed_no ( N , K ) { if ( K == 1 ) { return N ; } var answer = N ; while ( K -- ) { var a_current = prod_of_max_min ( answer ) ; if ( a_current == 0 ) break ; answer += a_current ; } return answer ; }
function isCenteredtridecagonal ( N ) { let n = ( 13 + Math . sqrt ( 104 * N + 65 ) ) / 26 ; return ( n - parseInt ( n ) ) == 0 ; }
function isCenteredpentagonal ( N ) { var n = ( ( 5 + Math . sqrt ( 40 * N - 15 ) ) / 10 ) ; return ( n - parseInt ( n ) == 0 ) ; }
function isCentereddecagonal ( N ) { let n = ( 5 + Math . sqrt ( 20 * N + 5 ) ) / 10 ; return ( n - parseInt ( n ) ) == 0 ; }
function isdodecagonal ( N ) { let n = ( 4 + Math . sqrt ( 20 * N + 16 ) ) / 10 ; return ( n - parseInt ( n ) ) == 0 ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i += 6 ) { if ( n % i == 0 || n % ( i + 6 ) == 0 ) { return false ; } } return true ; }
function SexyPrime ( n1 , n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && Math . abs ( n1 - n2 ) == 6 ) ; }
function countSexyPairs ( arr , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { if ( SexyPrime ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
function computePrime ( N ) { var i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= N ; i ++ ) { if ( Prime [ i ] ) { for ( j = i * i ; j < N ; j += i ) { Prime [ j ] = false ; } } } }
function countSexyPairs ( arr , n ) { var maxE = Math . max . apply ( Math , arr ) ; computePrime ( maxE ) ; var count = 0 ; var freq = Array ( maxE + 1 ) . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } arr . sort ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( Prime [ arr [ i ] ] ) { if ( freq [ arr [ i ] + 6 ] > 0 && Prime [ arr [ i ] + 6 ] ) { count ++ ; } } } return count ; }
function nDigitPerfectSquares ( n , b ) { var largest = Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( b , n ) ) ) - 1 , 2 ) ; document . write ( largest ) ; }
function findNum ( n , k ) { let q = parseInt ( k / ( n - 1 ) ) ; let r = k % ( n - 1 ) ; let a ; if ( r != 0 ) a = ( n * q ) + r ; else a = ( n * q ) - 1 ; document . write ( a ) ; }
function cubeRoot ( n ) { let ans = Math . pow ( 3 , ( 1.0 / 3 ) * ( Math . log ( n ) / Math . log ( 3 ) ) ) ; return ans ; }
function floorMax ( A , B , N ) { let x = Math . min ( B - 1 , N ) ; return Math . floor ( ( A * x ) / B ) ; }
function calculateMoves ( n ) { var count = 0 ; var layers = parseInt ( n / 2 ) ; for ( var k = 1 ; k < layers + 1 ; k ++ ) { count += 8 * k * k ; } return count ; }
function countWays ( n ) { if ( n <= 2 ) document . write ( "-1" ) ; else { var ans = ( n - 1 ) * ( n - 2 ) / 2 ; document . write ( ans ) ; } }
function isSumSquare ( N ) { var n = ( 2 + Math . sqrt ( 8 * N - 4 ) ) / 2 ; return ( n - parseInt ( n ) ) == 0 ; }
function isCenteredheptagonal ( N ) { let n = ( 7 + Math . sqrt ( 56 * N - 7 ) ) / 14 ; return ( n - parseInt ( n ) ) == 0 ; }
function isCenterednonadecagonal ( N ) { var n = ( 19 + Math . sqrt ( 152 * N + 209 ) ) / 38 ; return ( n - parseInt ( n ) ) == 0 ; }
function isCenteredOctadecagonal ( N ) { let n = parseInt ( ( 9 + Math . sqrt ( 36 * N + 45 ) ) / 18 ) ; return ( n - parseInt ( n ) ) == 0 ; }
function countDigit ( n ) { return Math . floor ( Math . log10 ( n ) + 1 ) ; }
function isPower ( N , K ) { var res1 = Math . floor ( Math . log ( N ) / Math . log ( K ) ) ; var res2 = Math . log ( N ) / Math . log ( K ) ; return ( res1 == res2 ) ; }
function prevPowerofK ( n , k ) { let p = parseInt ( Math . log ( n ) / Math . log ( k ) , 10 ) ; return Math . pow ( k , p ) ; }
function nextPowerOfK ( n , k ) { return prevPowerofK ( n , k ) * k ; }
function subarray ( arr , n ) { var ans = 1 , temp = 1 ; for ( var i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; }
function findMaxMinSubArray ( arr , k , n ) { let min = n ; let max = 0 ; let left ; let right ; let tmp ; for ( let i = 0 ; i < n ; i ++ ) { tmp = 1 ; left = i ; while ( left - 1 >= 0 && Math . abs ( arr [ left ] - arr [ left - 1 ] ) <= K ) { left -- ; tmp ++ ; } right = i ; while ( right + 1 <= n - 1 && Math . abs ( arr [ right ] - arr [ right + 1 ] ) <= K ) { right ++ ; tmp ++ ; } if ( min > tmp ) min = tmp ; if ( max < tmp ) max = tmp ; } document . write ( min ) ; document . write ( ",▁" ) ; document . write ( max ) ; }
function countElement ( arr , n ) { let freq = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( let i = 0 ; i < n - 1 ; i ++ ) { let tmpsum = arr [ i ] ; for ( let j = i + 1 ; j < n ; j ++ ) { tmpsum += arr [ j ] ; if ( tmpsum <= n ) { ans += freq [ tmpsum ] ; freq [ tmpsum ] = 0 ; } } } return ans ; }
function first_digit ( x , y ) { var length = parseInt ( Math . log ( x ) / Math . log ( y ) ) + 1 ; var first_digit = parseInt ( x / Math . pow ( y , length - 1 ) ) ; document . write ( first_digit ) ; }
function kthRoot ( n , k ) { return Math . pow ( k , ( ( 1.0 / k ) * ( Math . log ( n ) / Math . log ( k ) ) ) ) ; }
function checksum ( n , k ) { var first_term = ( ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ) ; if ( first_term - parseInt ( ( first_term ) ) == 0 ) { for ( i = parseInt ( first_term ) ; i <= first_term + k - 1 ; i ++ ) { document . write ( i + "▁" ) ; } } else document . write ( "-1" ) ; }
function distributeN ( A , B , C , n ) { let max1 = Math . max ( A , B ) ; let max2 = Math . max ( B , C ) ; let maximum = Math . max ( max1 , max2 ) ; let sum = A + B + C ; let p = ( 3 * maximum ) - sum ; let diff = n - p ; if ( diff < 0 diff % 3 ) document . write ( "No" ) ; else document . write ( "Yes" ) ; }
function minimumSteps ( a , b , c ) { if ( a < 1 b < 1 ) return - 1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimumSteps ( a - b , b , c + 1 ) ; }
function count_pairs ( x ) { var ans = 1 ; while ( x > 0 ) { if ( x % 2 == 1 ) ans = ans * 3 ; x = parseInt ( x / 2 ) ; } return ans ; }
function isPerfectSquare ( x ) { let sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
function countSquares ( n ) { let cnt = 0 ; for ( let i = Math . pow ( 10 , ( n - 1 ) ) ; i < Math . pow ( 10 , n ) ; i ++ ) { if ( i != 0 && isPerfectSquare ( i ) ) cnt ++ ; } return cnt ; }
function countSquares ( n ) { let r = Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) ; let l = Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) ; return r - l ; }
function summation ( N ) { var co = parseInt ( ( N + 1 ) / 2 ) ; var ce = parseInt ( ( N ) / 2 ) ; var se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) ; var so = ( co * co ) * ( 2 * ( ( co * co ) ) - 1 ) ; return so - se ; }
function isStar ( N ) { let n = ( 6 + Math . sqrt ( 24 * N + 12 ) ) / 6 ; return ( n - parseInt ( n ) ) == 0 ; }
function sumEvenNumbers ( N , K ) { let check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( let i = 0 ; i < K - 1 ; i ++ ) { document . write ( "2▁" ) ; } document . write ( check ) ; } else { document . write ( "-1" ) ; } }
function findMinDivisor ( arr , n , limit ) { let low = 0 , high = 1000000000 ; while ( low < high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += Math . ceil ( arr [ i ] / mid ) ; } if ( sum <= limit ) high = mid ; else low = mid + 1 ; } return low ; }
function getCount ( arr , n ) { var count = 0 ; for ( var j = 1 ; j < n - 1 ; j ++ ) { var p = 0 , q = 0 ; for ( var i = 0 ; i < j ; i ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) p ++ ; } for ( var k = j + 1 ; k < n ; k ++ ) { if ( arr [ k ] % arr [ j ] == 0 ) q ++ ; } count += p * q ; } return count ; }
function computeMaxValue ( arr , n ) { var ans = 0 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { var val = Math . max ( arr [ i ] / arr [ j ] , arr [ j ] / arr [ i ] ) ; ans = Math . max ( ans , val ) ; } } return ans ; }
function kthNonDivisible ( N , K ) { let L = 1 ; let H = 2147483647 ; let ans = 0 ; while ( L <= H ) { let mid = parseInt ( ( L + H ) / 2 , 10 ) ; let sol = mid - parseInt ( mid / N , 10 ) ; if ( sol > K ) { H = mid - 1 ; } else if ( sol < K ) { L = mid + 1 ; } else { ans = mid ; H = mid - 1 ; } } document . write ( ans ) ; }
function kthNonDivisible ( N , K ) { return K + parseInt ( Math . floor ( ( K - 1 ) / ( N - 1 ) ) , 10 ) ; }
function isPerfectSquare ( x ) { var sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
function checkSunnyNumber ( N ) { if ( isPerfectSquare ( N + 1 ) ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function findPairEvenParity ( arr , len ) { let firstMaximum = Number . MIN_VALUE ; let secondMaximum = Number . MIN_VALUE ; for ( let i = 0 ; i < len ; i ++ ) { if ( isEvenParity ( arr [ i ] ) ) { if ( arr [ i ] >= firstMaximum ) { secondMaximum = firstMaximum ; firstMaximum = arr [ i ] ; } else if ( arr [ i ] >= secondMaximum ) { secondMaximum = arr [ i ] ; } } } document . write ( firstMaximum + "▁" + secondMaximum ) ; }
function isHexagonal ( N ) { let val = 8 * N + 1 ; let x = 1 + Math . sqrt ( val ) ; let n = ( x ) / 4 ; if ( ( n - parseInt ( n ) ) == 0 ) { return true ; } else { return false ; } }
function NumbertoCharacter ( n ) { let rev = 0 , r = 0 ; while ( n > 0 ) { r = n % 10 ; rev = rev * 10 + r ; n = Math . floor ( n / 10 ) ; } while ( rev > 0 ) { r = rev % 10 ; switch ( r ) { case 1 : document . write ( "one▁" ) ; break ; case 2 : document . write ( "two▁" ) ; break ; case 3 : document . write ( "three▁" ) ; break ; case 4 : document . write ( "four▁" ) ; break ; case 5 : document . write ( "five▁" ) ; break ; case 6 : document . write ( "six▁" ) ; break ; case 7 : document . write ( "seven▁" ) ; break ; case 8 : document . write ( "eight▁" ) ; break ; case 9 : document . write ( "nine▁" ) ; break ; case 0 : document . write ( "zero▁" ) ; break ; default : document . write ( "UnValid▁" ) ; break ; } rev = Math . floor ( rev / 10 ) ; } }
function Solve ( arr , n ) { let temp = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( let j = i ; j < n ; j ++ ) { temp += arr [ j ] ; if ( ( temp + 2 ) % 4 != 0 ) count ++ ; } } return count ; }
function nCr ( n , p , f ) { for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= m ; j ++ ) { if ( j > i ) f [ i ] [ j ] = 0 ; else if ( j == 0 j == i ) f [ i ] [ j ] = 1 ; else f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p ; } } }
function prodSquare ( n ) { for ( i = 2 ; i * i <= n ; i ++ ) for ( j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; }
function prodSquare ( n ) { var s = new Map ( ) ; for ( var i = 2 ; i * i <= n ; ++ i ) { s . set ( i * i , 1 ) ; if ( s . has ( n / ( i * i ) ) ) return true ; } return false ; }
function printPair ( n ) { document . write ( 1 + "▁" + ( n - 1 ) ) ; }
function isAutoBiographyNum ( number ) { let count = 0 , position , size , digit ; let NUM ; NUM = number . toString ( ) ; size = NUM . length ; for ( let i = 0 ; i < size ; i ++ ) { position = NUM [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ; count = 0 ; for ( let j = 0 ; j < size ; j ++ ) { digit = NUM [ j ] . charCodeAt ( ) - "0" . charCodeAt ( ) ; if ( digit == i ) count ++ ; } if ( position != count ) return false ; } return true ; }
function checkArray ( arr , n ) { let current_length = 0 ; let max_length = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isAutoBiographyNum ( arr [ i ] ) ) current_length ++ ; else current_length = 0 ; max_length = Math . max ( max_length , current_length ) ; } return max_length ; }
function GetSum ( n ) { var divisors = [ ] ; for ( var i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { divisors . push ( i ) ; if ( i != n / i ) { divisors . push ( n / i ) ; } } } var ans = 1 ; for ( var i = 0 ; i < divisors . length ; i ++ ) { ans *= ( divisors [ i ] + 1 ) ; } ans = ans - 1 ; return ans ; }
function calculateWays ( n ) { let x = 0 ; let v = Array . from ( { length : n } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; i ++ ) v [ i ] = 0 ; for ( let i = 0 ; i < n / 2 ; i ++ ) { if ( n % 2 == 0 && i == n / 2 ) break ; x = n * ( i + 1 ) - ( i + 1 ) * i ; v [ i ] = x ; v [ n - i - 1 ] = x ; } return v ; }
function isPowerful ( n ) { while ( n % 2 == 0 ) { let power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( let factor = 3 ; factor <= Math . sqrt ( n ) ; factor += 2 ) { let power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
function longestPowerfulSubsequence ( arr , n ) { let answer = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isPowerful ( arr [ i ] ) ) answer ++ ; } return answer ; }
function maxOR ( arr , n ) { var max_value = Math . max . apply ( Math , arr ) ; var number_of_bits = parseInt ( ( ( Math . log ( max_value ) ) ) ) + 2 ; var complement = ( ( 1 << number_of_bits ) - 1 ) ^ max_value ; var c = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != max_value ) { c = Math . max ( c , ( complement & arr [ i ] ) ) ; } } return ( max_value + c ) ; }
function update ( res , L , R , K ) { L -= 1 ; R -= 1 ; res [ L ] ^= K ; res [ R + 1 ] ^= K ; }
function check ( a , n , k ) { let m = new Map ( ) ; let extra = 0 ; for ( let i = k ; i < n ; i ++ ) m . set ( a [ i ] , m . get ( a [ i ] ) == null ? 1 : m . get ( a [ i ] ) + 1 ) ; for ( let x of m . values ( ) ) extra += x - 1 ; if ( extra == 0 ) return true ; for ( let i = 1 ; i + k - 1 < n ; i ++ ) { if ( m . get ( a [ i + k - 1 ] ) > 1 ) extra -- ; m . set ( a [ i + k - 1 ] , m . get ( a [ i + k - 1 ] ) - 1 ) ; m . set ( a [ i - 1 ] , m . get ( a [ i - 1 ] ) + 1 ) ; if ( m . get ( a [ i - 1 ] ) > 1 ) extra ++ ; if ( extra == 0 ) return true ; } return false ; }
function minlength ( a , n ) { let lo = 0 , hi = n + 1 ; let ans = 0 ; while ( lo < hi ) { let mid = Math . floor ( ( lo + hi ) / 2 ) ; if ( check ( a , n , mid ) ) { ans = mid ; hi = mid ; } else lo = mid + 1 ; } return ans ; }
function SieveOfEratosthenes ( ) { let i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= MAX ; i ++ ) { if ( Prime [ i ] ) { for ( j = 2 * i ; j < MAX ; j += i ) { Prime [ j ] = false ; } } } }
function dfs ( node , parent , h ) { height [ node ] = h ; for ( let to of graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node , h + 1 ) ; } }
function primeHeightNode ( N ) { SieveOfEratosthenes ( ) ; for ( let i = 1 ; i <= N ; i ++ ) { if ( Prime [ height [ i ] ] ) { document . write ( i + "▁" ) ; } } }
function sumOfDigits ( n ) { var sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n = parseInt ( n / 10 ) ; } return sum ; }
function smallestNum ( X , Y ) { var res = - 1 ; for ( i = X ; i < MAXN ; i ++ ) { var sum_of_digit = sumOfDigits ( i ) ; if ( sum_of_digit % Y == 0 ) { res = i ; break ; } } return res ; }
function calculateBill ( units ) { if ( units <= 100 ) { return units * 10 ; } else if ( units <= 200 ) { return ( 100 * 10 ) + ( units - 100 ) * 15 ; } else if ( units <= 300 ) { return ( 100 * 10 ) + ( 100 * 15 ) + ( units - 200 ) * 20 ; } else if ( units > 300 ) { return ( 100 * 10 ) + ( 100 * 15 ) + ( 100 * 20 ) + ( units - 300 ) * 25 ; } return 0 ; }
function countValues ( n ) { let answer = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { let k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; }
function countValues ( N ) { var div = [ ] ; for ( var i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { div . push ( i ) ; if ( N != i * i ) { div . push ( N / i ) ; } } } var answer = 0 ; for ( var i = 1 ; i * i <= N - 1 ; i ++ ) { if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } } div . forEach ( d => { var K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } ) ; return answer ; }
function reverse ( a ) { let rev = 0 ; while ( a != 0 ) { let r = a % 10 ; rev = rev * 10 + r ; a = parseInt ( a / 10 , 10 ) ; } return ( rev ) ; }
function prime ( a ) { let k = 0 ; for ( let i = 2 ; i < a ; i ++ ) { if ( a % i == 0 ) { k = 1 ; break ; } } if ( k == 1 ) { return ( 0 ) ; } else { return ( 1 ) ; } }
function adam ( a ) { let r1 = reverse ( a ) ; let s1 = a * a ; let s2 = r1 * r1 ; let r2 = reverse ( s2 ) ; if ( s1 == r2 ) { return ( 1 ) ; } else { return ( 0 ) ; } }
function sieve ( ) { for ( var i = 1 ; i <= MAX ; ++ i ) { for ( var j = i ; j <= MAX ; j += i ) divisor [ j ] . push ( i ) ; } }
function countPrimeFactors ( n ) { if ( n == 1 ) return 0 ; let cnt = 0 ; while ( n % 2 == 0 ) { cnt ++ ; n = parseInt ( n / 2 ) ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { cnt ++ ; n = parseInt ( n / i ) ; } } if ( n > 2 ) cnt ++ ; return cnt ; }
function isComposite ( n ) { if ( n <= 1 ) return 0 ; if ( n <= 3 ) return 0 ; if ( n % 2 == 0 n % 3 == 0 ) return n ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return n ; return 0 ; }
function preCompute ( ) { for ( var i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isComposite ( i ) ; } }
function countPalindromic ( n ) { var count ; if ( n % 2 == 1 ) { count = Math . pow ( 9 , ( n - 1 ) / 2 ) ; } else { count = Math . pow ( 9 , ( n - 2 ) / 2 ) ; } return count ; }
function countSubArrayWithOddProduct ( A , N ) { var count = 0 ; var last = - 1 ; var K = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { K = ( i - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; last = i ; } } K = ( N - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; return count ; }
function CgpaCalc ( marks , n ) { let grade = Array . from ( { length : n } , ( _ , i ) => 0 ) ; let cgpa , sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { grade [ i ] = ( marks [ i ] / 10 ) ; } for ( let i = 0 ; i < n ; i ++ ) { sum += grade [ i ] ; } cgpa = sum / n ; return cgpa ; }
function printMaxPair ( arr , n ) { var largest = - 100000000 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) { var number = parseInt ( getNumber ( arr [ i ] , arr [ j ] ) ) ; largest = Math . max ( largest , number ) ; } document . write ( largest ) ; }
function printKNumbers ( N , K ) { for ( let i = 0 ; i < K - 1 ; i ++ ) document . write ( 1 + "▁" ) ; document . write ( N - K + 1 ) ; }
function minNum ( n , k ) { var x = parseInt ( Math . log ( n ) / Math . log ( k ) ) + 1 ; var mn = Math . pow ( k , x ) - n ; return mn ; }
function previousPerfectCube ( N ) { let prevN = Math . floor ( Math . cbrt ( N ) ) ; if ( prevN * prevN * prevN == N ) prevN -= 1 ; return prevN * prevN * prevN ; }
function findCount ( arr , n ) { let res = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] % 2 == 0 ) && ( arr [ j ] % 2 == 1 ) ) { res ++ ; } return res ; }
function findCount ( arr , n ) { let count = 0 , ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count ++ ; else ans = ans + count ; } return ans ; }
function sumDig ( n ) { var s = 0 ; while ( n != 0 ) { s = s + ( n % 10 ) ; n = parseInt ( n / 10 ) ; } return s ; }
function Pec ( n ) { var dup = n ; var dig = sumDig ( n ) ; if ( dig * 3 == dup ) return true ; else return false ; }
function power ( a , b ) { if ( b == 0 ) return 1 ; let temp = power ( a , b / 2 ) ; temp = ( temp * temp ) % MOD ; if ( b % 2 != 0 ) { temp = ( temp * a ) % MOD ; } return temp ; }
function joinNumbers ( numA , numB ) { var revB = 0 ; while ( numB > 0 ) { revB = revB * 10 + ( numB % 10 ) ; numB = parseInt ( numB / 10 ) ; } while ( revB > 0 ) { numA = numA * 10 + ( revB % 10 ) ; revB = parseInt ( revB / 10 ) ; } return numA ; }
function reverse ( n ) { let r = 0 ; while ( n != 0 ) { r = r * 10 ; r = r + n % 10 ; n = parseInt ( n / 10 , 10 ) ; } return ( r ) ; }
function operation ( n ) { let i = 1 , a , count = 0 , r ; while ( count < n ) { a = digit_sum ( i ) ; r = reverse ( i ) ; if ( i % a == 0 && r % a == 0 ) { document . write ( i + "▁" ) ; count ++ ; i ++ ; } else i ++ ; } }
function calcCount ( arr , n , k ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( k % arr [ i ] == 0 ) count ++ ; } return count ; }
function isPerfect ( n ) { let sum = 1 ; let i ; for ( i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
function contiguousPerfectNumber ( arr , n ) { let current_length = 0 ; let max_length = 0 ; let i ; for ( i = 0 ; i < n ; i ++ ) { if ( isPerfect ( arr [ i ] ) ) current_length ++ ; else current_length = 0 ; max_length = Math . max ( max_length , current_length ) ; } return max_length ; }
function isPerfect ( n ) { var sum = 1 ; for ( var i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
function isPowerful ( n ) { while ( n % 2 == 0 ) { var power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( var factor = 3 ; factor <= Math . sqrt ( n ) ; factor += 2 ) { var power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
function dfs ( node , parent ) { if ( isPowerful ( weight [ node ] ) ) ans += 1 ; graph [ node ] . forEach ( to => { if ( to != parent ) dfs ( to , node ) ; } ) ; }
function isPowerful ( n ) { while ( n % 2 == 0 ) { let power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( let factor = 3 ; factor <= Math . sqrt ( n ) ; factor += 2 ) { let power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
function contiguousPowerfulNumber ( arr , n ) { let current_length = 0 ; let max_length = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isPowerful ( arr [ i ] ) ) current_length ++ ; else current_length = 0 ; max_length = Math . max ( max_length , current_length ) ; } return max_length ; }
function maxSum ( arr , K , start , end , max_sum ) { if ( K == 0 ) return max_sum ; let max_sum_start = max_sum + arr [ start ] ; let max_sum_end = max_sum + arr [ end ] ; let ans = Math . max ( maxSum ( arr , K - 1 , start + 1 , end , max_sum_start ) , maxSum ( arr , K - 1 , start , end - 1 , max_sum_end ) ) ; return ans ; }
function maximizeSum ( arr , K , n ) { let max_sum = 0 ; let start = 0 ; let end = n - 1 ; document . write ( maxSum ( arr , K , start , end , max_sum ) ) ; }
function maxPointCount ( arr , k , size ) { let curr_points = 0 ; let max_points = 0 ; for ( let i = 0 ; i < K ; i ++ ) curr_points += arr [ i ] ; max_points = curr_points ; let j = size - 1 ; for ( let i = K - 1 ; i >= 0 ; i -- ) { curr_points = curr_points + arr [ j ] - arr [ i ] ; max_points = Math . max ( curr_points , max_points ) ; j -- ; } return max_points ; }
function count ( N , B ) { var sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { sum += ( B - 1 ) * Math . pow ( B , i - 1 ) ; } return sum ; }
function GetMinCost ( N ) { let pq = [ ] ; for ( let i = 1 ; i <= N ; i ++ ) { pq . push ( i ) ; } pq . sort ( function ( a , b ) { return a - b } ) ; let cost = 0 ; while ( pq . length > 1 ) { let mini = pq [ 0 ] ; pq . shift ( ) ; let secondmini = pq [ 0 ] ; pq . shift ( ) ; let current = mini * secondmini ; cost += current ; pq . push ( current ) ; pq . sort ( function ( a , b ) { return a - b } ) ; } return cost ; }
function CountWays ( N , M ) { var count = 1 ; count = Math . pow ( 3 , M + N ) ; count *= Math . pow ( 2 , M * N ) ; return count ; }
function minCost ( arr , n , circumference ) { arr . sort ( ( a , b ) => a - b )  var arr2 = Array ( 2 * n ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { arr2 [ i ] = arr [ i ] ; arr2 [ i + n ] = arr [ i ] + circumference ; } var res = 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) res = Math . min ( res , arr2 [ i + ( n - 1 ) ] - arr2 [ i ] ) ; return res ; }
function CountWays ( n ) { let ans = Math . floor ( ( n - 1 ) / 2 ) ; return ans ; }
function findUniqueElements ( arr , N , K ) { var s = new Set ( arr ) ; var arr_sum = arr . reduce ( ( a , b ) => a + b , 0 ) ; var set_sum = 0 ; s . forEach ( function ( value ) { set_sum += value ; } ) document . write ( Math . floor ( ( K * set_sum - arr_sum ) / ( K - 1 ) ) ) ; }
function findunique ( a , k ) { var res = 0 ; for ( var i = 0 ; i < 32 ; i ++ ) { var p = 0 ; for ( var j = 0 ; j < a . length ; j ++ ) { p += ( Math . abs ( a [ j ] ) & ( 1 << i ) ) != 0 ? 1 : 0 ; } p %= k ; res += Math . pow ( 2 , i ) * p ; } var c = 0 ; for ( var i = 0 ; i < a . length ; i ++ ) if ( a [ i ] == res ) { c = 1 ; break ; } return c == 1 ? res : - res ; }
function stepRequired ( N ) { let cnt = 0 ; while ( N ) { N = N & ( N - 1 ) ; cnt ++ ; } return cnt ; }
function isPerfectSquare ( x ) { var s = parseInt ( Math . sqrt ( x ) ) ; return ( s * s == x ) ; }
function isFibonacci ( n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
function findEquation ( a , b , c ) { let X = ( a + b + c ) ; let Y = ( a * b ) + ( b * c ) + ( c * a ) ; let Z = a * b * c ; document . write ( "x^3▁-▁" + X + "x^2▁+▁" + Y + "x▁-▁" + Z + "▁=▁0" ) ; }
function dydx ( x , y ) { return ( x - y ) / 2 ; }
function numPrimeArrangements ( n ) { var prime = Array . from ( { length : n + 1 } , ( _ , i ) => true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( var i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( prime [ i ] ) for ( factor = 2 ; factor * i <= n ; factor ++ ) prime [ factor * i ] = false ; } var primeIndices = 0 ; for ( var i = 1 ; i <= n ; i ++ ) if ( prime [ i ] ) primeIndices ++ ; var mod = parseInt ( ( 1e9 + 7 ) ) , res = 1 ; for ( var i = 1 ; i <= primeIndices ; i ++ ) res = ( ( 1 * res * i ) % mod ) ; for ( var i = 1 ; i <= ( n - primeIndices ) ; i ++ ) res = ( ( 1 * res * i ) % mod ) ; return res ; }
function fact ( n ) { var res = 1 ; for ( var i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
function count_heads ( n , r ) { var output ; output = fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; output = output / ( Math . pow ( 2 , n ) ) ; return output ; }
function PrintReverseOrder ( N ) { if ( N <= 0 ) { return ; } else { document . write ( N + "▁" ) ; PrintReverseOrder ( N - 1 ) ; } }
function findAns ( a , b , n ) { var lcm = ( a * b ) / __gcd ( a , b ) ; var multiples = ( n / lcm ) + 1 ; var answer = Math . max ( a , b ) * multiples ; var lastvalue = lcm * ( n / lcm ) + Math . max ( a , b ) ; if ( lastvalue > n ) answer = answer - ( lastvalue - n - 1 ) ; return answer ; }
function modInverse ( n , p ) { return power ( n , p - 2 , p ) ; }
function nCrModPFermat ( n , r , p ) { if ( r == 0 ) return 1 ; if ( n < r ) return 0 ; let fac = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; fac [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; }
function SumOfXor ( a , n ) { let mod = 10037 ; let answer = 0 ; for ( let k = 0 ; k < 32 ; k ++ ) { let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & ( 1 << k ) ) != 0 ) x ++ ; else y ++ ; } answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod ; } return answer ; }
function movesRequired ( a , b ) { let total_moves = a % b ; document . write ( total_moves ) ; }
function Volume_of_cone ( R ) { let V = ( ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ) ; return V ; }
function maximumComponentSize ( a , n ) { let adj = new Array ( n ) ; for ( var i = 0 ; i < adj . length ; i ++ ) { adj [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < adj . length ; i ++ ) { for ( var j = 0 ; j < adj . length ; j ++ ) { adj [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( __gcd ( a [ i ] , a [ j ] ) > 1 ) adj [ i ] . push ( j ) ; adj [ j ] . push ( i ) ; } } let answer = 0 ; let vis = Array . from ( { length : n } , ( _ , i ) => 0 ) ; for ( let k = 0 ; k < n ; k ++ ) { vis [ k ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { if ( vis [ i ] == 0 ) { answer = Math . max ( answer , dfs ( i , adj , vis ) ) ; } } return answer ; }
function sieve ( ) { for ( var i = 2 ; i < 100005 ; i ++ ) { if ( spf [ i ] == 0 ) { spf [ i ] = i ; for ( var j = 2 * i ; j < 100005 ; j += i ) { if ( spf [ j ] == 0 ) spf [ j ] = i ; } } } }
function factorize ( n , s ) { while ( n > 1 ) { var z = spf [ n ] ; s . add ( z ) ; while ( n % z == 0 ) n = parseInt ( n / z ) ; } return s ; }
function root ( i ) { if ( par [ i ] == i ) return i ; else return par [ i ] = root ( par [ i ] ) ; }
function merge ( a , b ) { var p = root ( a ) ; var q = root ( b ) ; if ( p == q ) return ; if ( sizeContainer [ p ] > sizeContainer [ q ] ) { [ p , q ] = [ q , p ] } par [ p ] = q ; sizeContainer [ q ] += sizeContainer [ p ] ; }
function maximumComponentsizeContainer ( a , n ) { for ( var i = 0 ; i < 100005 ; i ++ ) { par [ i ] = i ; sizeContainer [ i ] = 1 ; } sieve ( ) ; for ( var i = 0 ; i < n ; i ++ ) { var s = new Set ( ) ; s = factorize ( a [ i ] , s ) ; s . forEach ( it => { if ( id [ it ] == 0 ) id [ it ] = i + 1 ; else merge ( i + 1 , id [ it ] ) ; } ) ; } var answer = 0 ; for ( var i = 0 ; i < n ; i ++ ) answer = Math . max ( answer , sizeContainer [ i ] ) ; return answer ; }
function check ( X , K ) { var prime , temp , sqr , i ; prime = 0 ; temp = X ; sqr = parseInt ( Math . sqrt ( X ) ) ; for ( i = 2 ; i <= sqr ; i ++ ) { while ( temp % i == 0 ) { temp = parseInt ( temp / i ) ; prime ++ ; } } if ( temp > 2 ) prime ++ ; if ( X == 1 ) return false ; if ( prime == 1 && K == 1 ) return true ; else if ( prime >= K ) return true ; else return false ; }
function precompute ( ) { phi [ 1 ] = 0 ; for ( i = 2 ; i < N ; i ++ ) phi [ i ] = i ; for ( p = 2 ; p < N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( i = 2 * p ; i < N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function maxAlternatingSum ( arr , n ) { var max_sum = 0 ; var i = 0 ; while ( i < n ) { var current_max = arr [ i ] ; var k = i ; while ( k < n && ( ( arr [ i ] > 0 && arr [ k ] > 0 ) || ( arr [ i ] < 0 && arr [ k ] < 0 ) ) ) { current_max = Math . max ( current_max , arr [ k ] ) ; k += 1 ; } max_sum += current_max ; i = k ; } return max_sum ; }
function subarrayLength ( A , R , N , M ) { for ( let i = 0 ; i < M ; ++ i ) { let l = R [ i ] [ 0 ] , r = R [ i ] [ 1 ] + 1 ; l -- ; r -- ; A [ l ] ++ ; if ( r < N ) A [ r ] -- ; } for ( let i = 1 ; i < N ; ++ i ) { A [ i ] += A [ i - 1 ] ; } let count = 0 ; let s = new Set ( ) ; for ( let i = 0 ; i < N ; ++ i ) { if ( ! s . has ( A [ i ] ) ) count ++ ; s . add ( A [ i ] ) ; } let repeat = Array . from ( { length : count + 1 } , ( _ , i ) => 0 ) ; let ans = N ; let counter = 0 , left = 0 , right = 0 ; while ( right < N ) { let cur_element = A [ right ] ; repeat [ cur_element ] += 1 ; if ( repeat [ cur_element ] == 1 ) ++ counter ; while ( counter == count ) { ans = Math . min ( ans , right - left + 1 ) ; cur_element = A [ left ] ; repeat [ cur_element ] -= 1 ; ++ left ; if ( repeat [ cur_element ] == 0 ) -- counter ; } ++ right ; } return ans ; }
function ModifiedSieveOfEratosthenes ( N , Expo_Prime ) { let primes = new Array ( N ) ; primes . fill ( true )  for ( let i = 2 ; i < N ; i ++ ) { if ( primes [ i ] ) { let no = i ; while ( no <= N ) { Expo_Prime [ no ] = true ; no *= i ; } for ( let j = i * i ; j < N ; j += i ) primes [ j ] = false ; } } }
function FindExpoPrime ( arr , n ) { let max = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) max = arr [ i ] ; } let Expo_Prime = new Array ( max + 1 ) ; Expo_Prime . fill ( false )  ModifiedSieveOfEratosthenes ( max + 1 , Expo_Prime ) ; Display ( arr , Expo_Prime , n ) ; }
function nthRoot ( A , N ) { let xPre = 7 ; let eps = 1e-3 ; let delX = Number . MAX_VALUE ; let xK = 0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + A / Math . pow ( xPre , N - 1 ) ) / N ; delX = Math . abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
function check ( no , k ) { let kth_root = nthRoot ( no , k ) ; let num = Math . floor ( kth_root ) ; if ( Math . abs ( num - kth_root ) < 1e-4 ) return true ; return false ; }
function printExpo ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) { if ( check ( arr [ i ] , k ) ) document . write ( arr [ i ] + "▁" ) ; } }
function SieveOfEratosthenes ( ) { let check = new Array ( N + 1 ) ; check . fill ( true ) ; for ( let p = 2 ; p * p <= N ; p ++ ) { if ( check [ p ] == true ) { prime . push ( p ) ; for ( let i = p * p ; i <= N ; i += p ) check [ i ] = false ; } } }
function isPathCo_Prime ( path ) { let max = 0 ; for ( let x = 0 ; x < path . length ; x ++ ) { if ( max < path [ x ] ) max = path [ x ] ; } for ( let i = 0 ; i * prime [ i ] <= parseInt ( max / 2 , 10 ) ; i ++ ) { let ct = 0 ; for ( let x = 0 ; x < path . length ; x ++ ) { if ( path [ x ] % prime [ i ] == 0 ) ct ++ ; } if ( ct > 1 ) { return false ; } } return true ; }
function CntcontSubs ( a , n ) { let c = 0 , d = 0 , i , sum = 1 , j ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 a [ i ] % 4 == 0 ) d ++ ; sum = a [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { sum = sum * a [ j ] ; if ( sum % 2 != 0 sum % 4 == 0 ) c ++ ; } sum = 1 ; } return c + d ; }
function CntcontSubs ( a , n ) { let prod = 1 ; let vect = [ ] ; vect . push ( [ 0 , 2 ] ) ; let two = [ ] ; let zero = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i ] % 4 ; if ( a [ i ] < 0 ) a [ i ] = a [ i ] + 4 ; if ( a [ i ] == 2 ) two . push ( i + 1 ) ; if ( a [ i ] == 0 ) zero . push ( i + 1 ) ; if ( a [ i ] == 0 a [ i ] == 2 ) vect . push ( [ i + 1 , a [ i ] ] ) ; } vect . push ( [ n + 1 , 2 ] ) ; let total = Math . floor ( ( n * ( n + 1 ) ) / 2 ) ; if ( two . length == 0 ) return total ; else { let sum = 0 ; let pos1 = - 1 , pos2 = - 1 , pos3 = - 1 ; let sz = vect . length ; for ( let i = 1 ; i + 1 < sz ; i ++ ) { if ( vect [ i ] [ 1 ] == 2 ) { sum += ( vect [ i ] [ 0 ] - vect [ i - 1 ] [ 0 ] ) * ( vect [ i + 1 ] [ 0 ] - vect [ i ] [ 0 ] ) - 1 ; } } return total - sum - two . length ; } }
function countSubarray ( n ) { return ( ( n ) * ( n + 1 ) ) / 2 ; }
function countSubsequence ( n ) { return Math . pow ( 2 , n ) ; }
function y ( x ) { return ( 1 / ( 1 + x ) ) ; }
function BooleRule ( a , b ) { let n = 4 ; let h ; h = ( ( b - a ) / n ) ; let sum = 0 ; let bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 ; sum = sum + bl ; return sum ; }
function countSubsets ( a , n ) { let answer = 0 ; for ( let i = 0 ; i < ( 1 << n ) ; i ++ ) { let bitwiseAND = - 1 ; let bitwiseOR = 0 ; let bitwiseXOR = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) { if ( bitwiseAND == - 1 ) bitwiseAND = a [ j ] ; else bitwiseAND &= a [ j ] ; bitwiseOR |= a [ j ] ; bitwiseXOR ^= a [ j ] ; } } if ( bitwiseAND == bitwiseOR && bitwiseOR == bitwiseXOR ) answer = ( answer + 1 ) % mod ; } return answer ; }
function countSubsets ( a , n ) { var answer = 0 ; var powerOfTwo = Array ( 100005 ) . fill ( 0 ) ; powerOfTwo [ 0 ] = 1 ; for ( var i = 1 ; i < 100005 ; i ++ ) powerOfTwo [ i ] = ( powerOfTwo [ i - 1 ] * 2 ) % mod ; var frequency = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) if ( frequency . has ( a [ i ] ) ) { frequency . set ( a [ i ] , frequency . get ( a [ i ] ) + 1 ) ; } else { frequency . set ( a [ i ] , 1 ) ; } frequency . forEach ( ( value , key ) => { if ( key != 0 ) answer = ( answer % mod + powerOfTwo [ value - 1 ] ) % mod ; else answer = ( answer % mod + powerOfTwo [ value ] - 1 + mod ) % mod ; } ) ; return answer ; }
function count ( arr , N , K ) { let count = 0 , ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) { count = count + 1 ; } else { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } ans = ans + ( count * ( count + 1 ) ) / 2 ; return ans ; }
function precomputation ( ) { for ( var i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfect ( i ) ; } }
function convertToTernary ( N ) { if ( N == 0 ) return ; let x = N % 3 ; N = parseInt ( N / 3 , 10 ) ; if ( x < 0 ) N += 1 ; convertToTernary ( N ) ; if ( x < 0 ) document . write ( x + ( 3 * - 1 ) ) ; else document . write ( x ) ; }
function isPerfectSquare ( N ) { let sr = Math . sqrt ( N ) ; return ( sr - Math . floor ( sr ) ) == 0 ; }
function EulerTotientFunction ( limit ) { let copy = limit ; let primes = [ ] ; for ( let i = 2 ; i * i <= limit ; i ++ ) { if ( limit % i == 0 ) { while ( limit % i == 0 ) { limit /= i ; } primes . push ( i ) ; } } if ( limit >= 2 ) { primes . push ( limit ) ; } let ans = copy ; for ( let it in primes ) { ans = ( ans / primes [ it ] ) * ( primes [ it ] - 1 ) ; } return ans ; }
function product ( mat , n ) { let d1 = 0 , d2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { d1 += mat [ i ] [ i ] ; d2 += mat [ i ] [ n - i - 1 ] ; } return d1 * d2 ; }
function getPercentile ( rank , students ) { var result = ( students - rank ) / students * 100 ; return result ; }
function fib ( n ) { var phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return parseInt ( Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ) ; }
function calculateSum ( l , r ) { var sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; }
function sumFibonacci ( k ) { var l = ( k * ( k - 1 ) ) / 2 ; var r = l + k ; var sum = calculateSum ( l , r - 1 ) ; return sum ; }
function NthSmallest ( K ) { var Q = [ ] ; var x ; for ( var i = 1 ; i < 10 ; i ++ ) Q . push ( i ) ; for ( var i = 1 ; i <= K ; i ++ ) { x = Q [ 0 ] ; Q . shift ( ) ; if ( x % 10 != 0 ) { Q . push ( x * 10 + x % 10 - 1 ) ; } Q . push ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . push ( x * 10 + x % 10 + 1 ) ; } } return x ; }
function sumOfPrevK ( N , K ) { let arr = new Array ( N ) ; arr [ 0 ] = 1 ; for ( let i = 1 ; i < N ; i ++ ) { let j = i - 1 , count = 0 , sum = 0 ; while ( j >= 0 && count < K ) { sum += arr [ j ] ; j -- ; count ++ ; } arr [ i ] = sum ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function gcd ( a , b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }
function findSum ( arr , n , left , right ) { let k = right - left ; let d = arr [ 1 ] - arr [ 0 ] ; let ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; }
function get ( x , y , z ) { if ( x > z ) return - 1 ; let val = z - x ; let div = Math . floor ( ( z - x ) / y ) ; let ans = div * y + x ; return ans ; }
function subarrayPossible ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum <= 0 ) return true ; } sum = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; if ( sum <= 0 ) return true ; } return false ; }
function probability ( N ) { var a = 2 ; var b = 3 ; if ( N == 1 ) { return a ; } else if ( N == 2 ) { return b ; } else { for ( i = 3 ; i <= N ; i ++ ) { var c = a + b ; a = b ; b = c ; } return b ; } }
function y ( x ) { let num = 1 ; let denom = 1.0 + x * x ; return num / denom ; }
function WeedleRule ( a , b ) { let h = ( b - a ) / 6 ; let sum = 0 ; sum = sum + ( ( ( 3 * h ) / 10 ) * ( y ( a ) + y ( a + 2 * h ) + 5 * y ( a + h ) + 6 * y ( a + 3 * h ) + y ( a + 4 * h ) + 5 * y ( a + 5 * h ) + y ( a + 6 * h ) ) ) ; return sum . toFixed ( 6 ) ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function findSmallest ( N ) { if ( N == 0 ) return 2 ; if ( N == 1 ) return 1 ; var prime = N , counter = 0 ; var found = false ; while ( ! found ) { if ( isPrime ( prime ) ) found = true ; else { prime ++ ; counter ++ ; } } return counter ; }
function maxSubArraySum ( a , size ) { var max_so_far = - 1000000000 , max_ending_here = 0 ; for ( var i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
function findRemainder ( n ) { let x = n & 3 ; return x ; }
function reverse ( num ) { var rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = parseInt ( num / 10 ) ; } return rev_num ; }
function countReverse ( arr , n ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) if ( reverse ( arr [ i ] ) == arr [ j ] ) { res ++ ; } return res ; }
function reverse ( num ) { let rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = Math . floor ( num / 10 ) ; } return rev_num ; }
function countReverse ( arr , n ) { let freq = new Map ( ) ; for ( let i = 0 ; i < n ; ++ i ) { if ( freq . has ( arr [ i ] ) ) { freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . set ( arr [ i ] , 1 ) ; } } let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq . has ( arr [ i ] ) ) { freq . set ( arr [ i ] , freq . get ( arr [ i ] ) - 1 ) ; } else { freq . set ( arr [ i ] , - 1 ) ; } if ( freq . has ( reverse ( arr [ i ] ) ) ) { res += freq . get ( reverse ( arr [ i ] ) ) ; } } return res ; }
function rangeSum ( l , r ) { var a = 1 , b = 9 , res = 0 ; for ( var i = 1 ; i <= 10 ; i ++ ) { var L = Math . max ( l , a ) ; var R = Math . min ( r , b ) ; if ( L <= R ) { var sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += Math . pow ( i , i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
function TrialDivision ( N ) { let i = 2 ; let k = Math . ceil ( Math . sqrt ( N ) ) ; while ( i <= k ) { if ( N % i == 0 ) return 0 ; i += 1 ; } return 1 ; }
function isPossible ( A , n , k ) { var countOfTwo = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( A [ i ] % 2 == 0 ) { countOfTwo ++ ; } } if ( k == 0 && countOfTwo == n ) document . write ( "NO" ) ; else if ( countOfTwo >= k ) { document . write ( "Yes" ) ; } else document . write ( "No" ) ; }
function countWays ( A , B , C ) { var minAddA = Math . max ( 0 , parseInt ( ( C + B - A + 2 ) / 2 ) ) ; var count_ways = Math . max ( C - minAddA + 1 , 0 ) ; return count_ways ; }
function createHash ( hash , maxElement ) { let prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { let temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } }
function printSeries ( N ) { let ith_term = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { ith_term = i % 2 == 0 ? 2 * i * i + 1 : 2 * i * i - 1 ; document . write ( ith_term + ",▁" ) ; } }
function sieve ( a , b ) { prime [ 1 ] = 1 ; for ( var i = 2 ; i * i < size ; i ++ ) { if ( prime [ i ] == 0 ) { for ( var j = i * 2 ; j < size ; j += i ) prime [ j ] = 1 ; } } for ( var p = 1 ; p < size ; p ++ ) { for ( var q = 1 ; q < size ; q ++ ) { if ( prime [ p ] == 0 && prime [ q ] == 0 && a * p + b * q < size ) { freq [ a * p + b * q ] ++ ; } } } }
function SieveOfEratosthenes ( ) { let check = new Array ( N + 1 ) ; check . fill ( true ) ; for ( let p = 2 ; p * p <= N ; p ++ ) { if ( check [ p ] == true ) { prime . push ( p ) ; for ( let i = p * p ; i <= N ; i += p ) check [ i ] = false ; } } }
function printSumSeries ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum += 1.0 / ( 2 * i - 1 ) ; } document . write ( sum . toFixed ( 5 ) ) ; }
function printSeriesSum ( N ) { let sum = 0 ; let a = 1 ; let cnt = 0 ; let flag = true ; sum += a ; while ( cnt < N ) { let nextElement ; if ( flag ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * 3 / 2 ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } document . write ( sum ) ; }
function MinimumSwapOperations ( s ) { let zero_exist = false ; let multiple_of_2 = false ; let sum = 0 ; let index_of_zero = 0 ; let more_zero = false ; for ( let i = 0 ; i < s . length ; i ++ ) { let val = s [ i ] - "0" ; if ( zero_exist == true ) more_zero = true ; if ( val == 0 ) { zero_exist = true ; index_of_zero = i ; } sum += val ; } if ( zero_exist == false sum % 3 != 0 ) { document . write ( "-1" ) ; return ; } for ( let i = 0 ; i < s . length ; i ++ ) { let val = s [ i ] - "0" ; if ( val % 2 == 0 && i != index_of_zero ) multiple_of_2 = true ; } if ( multiple_of_2 == false ) { document . write ( "-1" ) ; return ; } let last_val = s . charAt [ s . length - 1 ] - "0" ; let second_last_val = s [ ( s . length - 2 ) ] - "0" ; if ( last_val == 0 && second_last_val % 2 == 0 ) document . write ( 0 ) ; else if ( ( last_val == 0 && second_last_val % 2 != 0 ) || ( last_val % 2 == 0 && second_last_val == 0 ) ) document . write ( 1 ) ; else if ( more_zero == true && ( last_val == 0 && second_last_val % 2 != 0 ) ) document . write ( 1 ) ; else document . write ( 2 ) ; }
function sieve ( n ) { for ( let i = 2 ; i < n ; ++ i ) { if ( min_prime [ i ] > 0 ) { continue ; } min_prime [ i ] = i ; max_prime [ i ] = i ; let j = i + i ; while ( j < n ) { if ( min_prime [ j ] == 0 ) { min_prime [ j ] = i ; } max_prime [ j ] = i ; j += i ; } } }
function findCost ( A , B , C , X ) { sieve ( MAX ) ; let N , M ; if ( X == 1 ) { return - 1 ; } let min_cost = C + X ; let cost_for_prime = A ; N = max_prime [ X ] ; if ( N != X ) { M = X / N ; cost_for_prime += M ; min_cost = Math . min ( min_cost , cost_for_prime ) ; } M = min_prime [ X ] ; N = X / M ; if ( N != min_prime [ N ] ) { let cost_for_comp = B + M ; min_cost = Math . min ( min_cost , cost_for_comp ) ; } return min_cost ; }
function minOperations ( A , B ) { if ( A > B ) { A = A + B ; B = A - B ; A = A - B ; } B = B / __gcd ( A , B ) ; return B - 1 ; }
function quadrant ( s ) { var l = s . length ; var i = 0 ; if ( s . indexOf ( "+" ) != - 1 ) { i = s . indexOf ( "+" ) ; } else { i = s . indexOf ( "-" ) ; } var real = s . substr ( 0 , i ) ; var imaginary = s . substr ( i + 1 , l - 1 ) ; var x = parseInt ( real ) ; var y = parseInt ( imaginary ) ; if ( x > 0 && y > 0 ) document . write ( "Quadrant▁1" ) ; else if ( x < 0 && y > 0 ) document . write ( "Quadrant▁2" ) ; else if ( x < 0 && y < 0 ) document . write ( "Quadrant▁3" ) ; else if ( x > 0 && y < 0 ) document . write ( "Quadrant▁4" ) ; else if ( x == 0 && y > 0 ) document . write ( "Lies▁on▁positive" + "▁Imaginary▁axis" ) ; else if ( x == 0 && y < 0 ) document . write ( "Lies▁on▁negative" + "▁Imaginary▁axis" ) ; else if ( y == 0 && x < 0 ) document . write ( "Lies▁on▁negative" + "▁X-axis" ) ; else if ( y == 0 && x > 0 ) document . write ( "Lies▁on▁positive" + "▁X-axis" ) ; else document . write ( "Lies▁on▁the▁Origin" ) ; }
function highestPower ( n , k ) { let i = 0 ; let a = Math . pow ( n , i ) ; while ( a <= k ) { i += 1 ; a = Math . pow ( n , i ) ; } return i - 1 ; }
function PowerArray ( n , k ) { while ( k > 0 ) { let t = highestPower ( n , k ) ; if ( b [ t ] > 0 ) { document . write ( - 1 ) ; return 0 ; } else b [ t ] = 1 ; k -= Math . pow ( n , t ) ; } for ( let i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] > 0 ) { document . write ( i + ",▁" ) ; } } return 0 ; }
function PowerArray ( n , k ) { let count = 0 ; while ( k > 0 ) { if ( k % n == 0 ) { k = parseInt ( k / n , 10 ) ; count ++ ; } else if ( k % n == 1 ) { k -= 1 ; b [ count ] ++ ; if ( b [ count ] > 1 ) { document . write ( - 1 ) ; return 0 ; } } else { document . write ( - 1 ) ; return 0 ; } } for ( let i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] != 0 ) { document . write ( i + ",▁" ) ; } } return Number . MIN_VALUE ; }
function countdigits ( n , k ) { if ( n == 0 ) return 0 ; var digit = n % 10 ; if ( digit == k ) return 1 + countdigits ( n / 10 , k ) ; return countdigits ( n / 10 , k ) ; }
function largestElement ( head_ref ) { var max = Number . MIN_VALUE ; var head = head_ref ; while ( head != null ) { if ( max < head . data ) max = head . data ; head = head . next ; } return max ; }
function createHash ( hash , maxElement ) { var prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { var temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } }
function printModulus ( X , Y ) { var n = Math . max ( X , Y ) ; for ( var i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) document . write ( i + "▁" ) ; } }
function printModulus ( X , Y ) { var d = Math . abs ( X - Y ) ; var i = 1 ; while ( i * i <= d ) { if ( d % i == 0 ) { document . write ( i + "▁" ) ; if ( d / i != i ) document . write ( parseInt ( d / i ) + "▁" ) ; } i ++ ; } }
function difSquare ( n ) { if ( n % 4 != 2 ) { return true ; } return false ; }
function countFibonacciDivisors ( n ) { let hash = new Set ( ) ; createHash ( hash , n ) ; let cnt = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( ( n / i == i ) && ( hash . has ( n / i ) ) ) cnt ++ ; else { if ( hash . has ( n / i ) ) cnt ++ ; if ( hash . has ( n / ( n / i ) ) ) cnt ++ ; } } } return cnt ; }
function findCount ( root , K ) { res = 0 ; k = K ; rec ( root ) ; return res ; }
function makearrayequal ( arr , n ) { var x = 0 ; for ( i = 0 ; i < n ; i ++ ) { x += ( arr [ i ] & 1 ) ; } document . write ( Math . min ( x , n - x ) ) ; }
function SieveOfEratosthenes ( composite ) { for ( let i = 0 ; i < N ; i ++ ) composite [ i ] = false ; for ( let p = 2 ; p * p < N ; p ++ ) { if ( ! composite [ p ] ) { for ( let i = p * 2 ; i < N ; i += p ) composite [ i ] = true ; } } }
function sumOfElements ( arr , n ) { let composite = new Array ( N ) ; SieveOfEratosthenes ( composite ) ; let m = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) if ( m . has ( arr [ i ] ) ) { m [ arr [ i ] ] = m [ arr [ i ] ] + 1 ; } else { m . set ( arr [ i ] , 1 ) ; } let sum = 0 ; m . forEach ( ( value , key ) => { if ( composite [ key ] ) { sum += value ; } } )  return sum ; }
function val ( c ) { if ( c >= "0" && c <= "9" ) return c . charCodeAt ( ) - "0" . charCodeAt ( ) ; else return c . charCodeAt ( ) - "A" . charCodeAt ( ) + 10 ; }
function toDeci ( str , base ) { let len = str . length ; let power = 1 ; let num = 0 ; let i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= base ) { document . write ( "Invalid▁Number" ) ; return - 1 ; } num += val ( str [ i ] ) * power ; power = power * base ; } return num ; }
function isEven ( num , N ) { let deci = toDeci ( num , N ) ; return ( deci % 2 == 0 ) ; }
function countDigit ( n ) { let temp = n , count = 0 ; while ( temp != 0 ) { let d = temp % 10 ; temp = Math . floor ( temp / 10 ) ; if ( d == 2 d == 3 d == 5 d == 7 ) count ++ ; } return count ; }
function remove ( arr , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( ( mp . has ( arr [ i ] ) && mp . get ( arr [ i ] ) % 2 == 1 ) ) continue ; document . write ( arr [ i ] + ",▁" ) ; } }
function SieveOfEratosthenes ( prime , p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
function longestPrimeSubsequence ( arr , n ) { let prime = new Array ( N + 1 ) ; prime . fill ( true )  SieveOfEratosthenes ( prime , N ) ; let answer = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { answer ++ ; } } return answer ; }
function checkPalindrome ( num ) { let str = num . toString ( ) ; let l = 0 , r = str . length - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { document . write ( "No" ) ; return ; } l ++ ; r -- ; } document . write ( "Yes" ) ; return ; }
function dydx ( x , y ) { return ( x + y - 2 ) ; }
function rungeKutta ( x0 , y0 , x , h ) { let n = ( ( x - x0 ) / h ) ; let k1 , k2 ; let y = y0 ; for ( let i = 1 ; i <= n ; i ++ ) { k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; y = y + ( 1.0 / 6.0 ) * ( k1 + 2 * k2 ) ; x0 = x0 + h ; } return y ; }
function isPerfectSquare ( x ) { var s = parseInt ( Math . sqrt ( x ) ) ; return ( s * s == x ) ; }
function isFibonacci ( n ) { if ( isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ) return 1 ; return 0 ; }
function compute ( a , b ) { for ( var i = 1 ; i < 100010 ; i ++ ) { fib [ i ] = isFibonacci ( i ) ; } for ( var x = 1 ; x < 100010 ; x ++ ) { for ( var y = 1 ; y < size ; y ++ ) { if ( fib [ x ] == 1 && fib [ y ] == 1 && a * x + b * y < 100010 ) { freq [ a * x + b * y ] ++ ; } } } }
function findMaxSum ( n1 , n2 ) { let arr1 = Array . from ( { length : MAX } , ( _ , i ) => 0 ) ; let arr2 = Array . from ( { length : MAX } , ( _ , i ) => 0 ) ; let l1 = 0 , l2 = 0 ; let max1 = Math . max ( n1 , n2 ) ; let min1 = Math . min ( n1 , n2 ) ; for ( let i = max1 ; i > 0 ; i = Math . floor ( i / 10 ) ) arr1 [ l1 ++ ] = ( i % 10 ) ; for ( let i = min1 ; i > 0 ; i = Math . floor ( i / 10 ) ) arr2 [ l2 ++ ] = ( i % 10 ) ; let f = 0 ; if ( l1 != l2 ) { let index = ( max_element ( arr2 , l2 ) ) ; for ( let i = l1 - 1 ; i > ( l2 - 1 ) ; i -- ) { if ( arr1 [ i ] < arr2 [ index ] ) { let tmp = arr1 [ i ] ; arr1 [ i ] = arr2 [ index ] ; arr2 [ index ] = tmp ; f = 1 ; break ; } } } if ( f != 1 ) { let index1 = 0 , index2 = 0 ; let diff1 = 0 , diff2 = 0 ; for ( let i = l2 - 1 ; i >= 0 ; i -- ) { index1 = ( max_element ( arr1 , i ) ) ; index2 = ( max_element ( arr2 , i ) ) ; diff1 = ( arr2 [ index2 ] - arr1 [ i ] ) ; diff2 = ( arr1 [ index1 ] - arr2 [ i ] ) ; if ( diff1 > 0 diff2 > 0 ) { if ( diff1 > diff2 ) { let tmp = arr1 [ i ] ; arr1 [ i ] = arr2 [ index2 ] ; arr2 [ index2 ] = tmp ; break ; } else if ( diff2 > diff1 ) { let tmp = arr1 [ index1 ] ; arr1 [ index1 ] = arr2 [ i ] ; arr2 [ i ] = tmp ; break ; } else if ( diff1 == diff2 ) { if ( index1 <= index2 ) { let tmp = arr1 [ index1 ] ; arr1 [ index1 ] = arr2 [ i ] ; arr2 [ i ] = tmp ; break ; } else if ( index2 <= index1 ) { let tmp = arr1 [ i ] ; arr1 [ i ] = arr2 [ index2 ] ; arr2 [ index2 ] = tmp ; break ; } } } } } let f_n1 = 0 , f_n2 = 0 ; for ( let i = l1 - 1 ; i >= 0 ; i -- ) { f_n1 = ( f_n1 * 10 ) + arr1 [ i ] ; f_n2 = ( f_n2 * 10 ) + arr2 [ i ] ; } document . write ( f_n1 + f_n2 ) ; }
function checkCube ( a , b ) { s1 = a . toString ( ) ; s2 = b . toString ( ) ; var c = parseInt ( s1 + s2 ) ; if ( isPerfectCube ( c ) ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function isDivisible ( n ) { let d ; while ( Math . floor ( n / 100 ) > 0 ) { d = n % 10 ; n = Math . floor ( n / 10 ) ; n = Math . abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; }
function even_or_odd ( N ) { let len = N . length ; if ( N [ len - 1 ] == "0" N [ len - 1 ] == "2" N [ len - 1 ] == "4" N [ len - 1 ] == "6" N [ len - 1 ] == "8" N [ len - 1 ] == "A" N [ len - 1 ] == "C" N [ len - 1 ] == "E" ) return ( "Even" ) ; else return ( "Odd" ) ; }
function isDivisible ( n ) { let d ; while ( Math . floor ( n / 100 ) > 0 ) { d = n % 10 ; n = Math . floor ( n / 10 ) ; n = Math . abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; }
function isPerfectSquare ( x ) { var s = parseInt ( Math . sqrt ( x ) ) ; return ( s * s == x ) ; }
function isFibonacci ( N ) { return isPerfectSquare ( 5 * N * N + 4 ) || isPerfectSquare ( 5 * N * N - 4 ) ; }
function nextNonFibonacci ( N ) { if ( N <= 3 ) return 4 ; if ( isFibonacci ( N + 1 ) ) return N + 2 ; else return N + 1 ; }
function isDivisible ( n ) { let d ; while ( Math . floor ( n / 100 ) <= 0 ) { d = n % 10 ; n = Math . floor ( n / 10 ) ; n = Math . abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; }
function findDigits ( n ) { let count = 0 ; while ( n != 0 ) { digit [ count ] = n % 10 ; n = n / 10 ; ++ count ; } return count ; }
function OR_of_Digits ( n , count ) { let ans = 0 ; for ( let i = 0 ; i < count ; i ++ ) { ans = ans | digit [ i ] ; } return ans ; }
function AND_of_Digits ( n , count ) { let ans = 0 ; for ( let i = 0 ; i < count ; i ++ ) { ans = ans & digit [ i ] ; } return ans ; }
function XOR_of_Digits ( n , count ) { let ans = 0 ; for ( let i = 0 ; i < count ; i ++ ) { ans = ans ^ digit [ i ] ; } return ans ; }
function preCompute ( ) { fact [ 0 ] = 1 ; for ( var i = 1 ; i < 18 ; i ++ ) fact [ i ] = ( fact [ i - 1 ] * i ) ; }
function nextFactorial ( N ) { for ( var i = 0 ; i < 21 ; i ++ ) { if ( N < fact [ i ] ) { document . write ( fact [ i ] ) ; break ; } } }
function largest_sum ( arr , n ) { let maximum = - 1 ; let m = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( m . has ( arr [ i ] ) ) { m . set ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . set ( arr [ i ] , 1 ) ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( m . get ( arr [ i ] ) > 1 ) { if ( m . has ( 2 * arr [ i ] ) ) { m . set ( 2 * arr [ i ] , m . get ( 2 * arr [ i ] ) + m . get ( arr [ i ] ) / 2 ) ; } else { m . set ( 2 * arr [ i ] , m . get ( arr [ i ] ) / 2 ) ; } if ( 2 * arr [ i ] > maximum ) maximum = 2 * arr [ i ] ; } } return maximum ; }
function maxLength ( arr , N ) { var product = 1 , len = 0 ; for ( var i = 0 ; i < N ; i ++ ) { product *= arr [ i ] ; } if ( product >= 0 ) { return N ; } for ( var i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { len = Math . max ( len , Math . max ( N - i - 1 , i ) ) ; } } return len ; }
function findNumbers ( N ) { let i = 1 ; while ( i <= N ) { document . write ( ( i * i * i ) + "▁" ) ; i ++ ; } }
function properDivisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; }
function properDivisorSum ( n ) { var sum = 0 ; for ( var i = 1 ; i <= n ; ++ i ) sum += parseInt ( n / i ) * i ; return sum - n * ( ( n + 1 ) / 2 ) ; }
function findMinimumOperation ( n , d , arrays ) { var cnt = 0 ; var first = Number . MIN_VALUE , end = Number . MAX_VALUE ; while ( n > 0 ) { var arr = [ arrays [ cnt ] [ 0 ] , arrays [ cnt ] [ 1 ] ] ; arr . sort ( ( a , b ) => a - b ) ; first = Math . max ( first , arr [ 0 ] ) ; end = Math . min ( end , arr [ 1 ] ) ; cnt ++ ; n -- ; } if ( first > end ) document . write ( "-1" ) ; else { if ( d >= first && d <= end ) { document . write ( "0" ) ; } else document . write ( Math . min ( Math . abs ( first - d ) , Math . abs ( d - end ) ) ) ; } }
function mult ( a , b ) { return ( ( a % mod ) * ( b % mod ) ) % mod ; }
function calculate_factors ( n ) { var ans , cnt ; cnt = 0 ; ans = 1 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } if ( cnt % 2 == 1 ) { ans = mult ( ans , ( cnt + 1 ) ) ; } for ( i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } if ( cnt % 2 == 1 ) { ans = mult ( ans , ( cnt + 1 ) ) ; } } if ( n > 2 ) { ans = mult ( ans , ( 2 ) ) ; } return ans % mod ; }
function getmax ( arr , n , x ) { let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } document . write ( Math . min ( s , x ) ) ; }
function generatePrime ( ) { let i , j ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
function Pair_of_PrimeXor ( A , n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( isPrime [ ( A [ i ] ^ A [ j ] ) ] ) { document . write ( "(" + A [ i ] + ",▁" + A [ j ] + ")▁" ) ; } } } }
function primeFactors ( n ) { let i , j ; let Prime = new Array ( ) ; if ( n % 2 == 0 ) { Prime . push ( 2 ) ; } while ( n % 2 == 0 ) { n = n / 2 ; } for ( i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { Prime . push ( i ) ; } while ( n % i == 0 ) { n = n / i ; } } if ( n > 2 ) { Prime . push ( n ) ; } return Prime ; }
function checkDistinctPrime ( n ) { let Prime = primeFactors ( n ) ; let product = 1 ; for ( let i of Prime ) { product *= i ; } if ( product == n ) document . write ( "YES" ) ; else document . write ( "NO" ) ; }
function nthRoot ( A , N ) { var xPre = Math . random ( ) % 10 ; var eps = 0.001 ; var delX = 1000000000 ; var xK ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + A / Math . pow ( xPre , N - 1 ) ) / N ; delX = Math . abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
function countPowers ( a , b , k ) { return ( Math . floor ( nthRoot ( b , k ) ) - Math . ceil ( nthRoot ( a , k ) ) + 1 ) ; }
function findDigits ( n , b ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; var M_PI = 3.141592 ; var M_E = 2.7182 ; var x = ( ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( Math . log10 ( b ) ) ; return Math . floor ( x ) + 1 ; }
function isPrime ( n ) { for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
function findSum ( N , k ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum += Math . pow ( i , k ) ; } return sum ; }
function isPerfectSquare ( x ) { var s = parseInt ( Math . sqrt ( x ) ) ; return ( s * s == x ) ; }
function isNonFibonacci ( n ) { if ( isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ) return 0 ; else return n ; }
function compute ( ) { for ( var i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isNonFibonacci ( i ) ; } }
function printSum ( L , R ) { var sum = pref [ R ] - pref [ L - 1 ] ; document . write ( sum + "▁" ) ; }
function checkArray ( a , b , n ) { var operations = 0 ; var i = 0 ; while ( i < n ) { if ( a [ i ] - b [ i ] == 0 ) { i ++ ; continue ; } var diff = a [ i ] - b [ i ] ; i ++ ; while ( i < n && a [ i ] - b [ i ] == diff ) { i ++ ; } operations ++ ; } document . write ( operations ) ; }
function isPerfectSquare ( x ) { var s = Math . sqrt ( x ) ; return ( s * s == x ) ; }
function isFibonacci ( n ) { return ( isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ) ; }
function countFibonacciPairs ( arr , n ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) if ( isFibonacci ( arr [ i ] ) && isFibonacci ( arr [ j ] ) ) { var prevFib = previousFibonacci ( arr [ i ] ) ; var nextFib = nextFibonacci ( arr [ i ] ) ; if ( prevFib == arr [ j ] nextFib == arr [ j ] ) { res ++ ; } } return res ; }
function countPairsWithProductK ( arr , n , k ) { let count = 0 ; let i ; let hashmap = new Array ( MAX ) ; for ( i = 0 ; i < n ; i ++ ) hashmap [ arr [ i ] ] = true ; for ( i = 0 ; i < n ; i ++ ) { let x = arr [ i ] ; let index = 1.0 * k / arr [ i ] ; if ( index >= 0 && ( ( index - Math . floor ( index ) ) == 0 ) && hashmap [ k / x ] ) count ++ ; hashmap [ x ] = false ; } return count ; }
function simpleSieve ( limit , prime ) { let mark = Array . from ( { length : limit + 1 } , ( _ , i ) => 0 ) ; for ( let i = 2 ; i <= limit ; ++ i ) { if ( mark [ i ] == false ) { prime . push ( i ) ; for ( let j = i ; j <= limit ; j += i ) { mark [ j ] = true ; } } } }
function primesInRange ( low , high ) { let limit = Math . floor ( Math . sqrt ( high ) ) + 1 ; let prime = [ ] ; simpleSieve ( limit , prime ) ; let n = high - low + 1 ; let mark = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < prime . length ; i ++ ) { let loLim = Math . floor ( low / prime [ i ] ) ; loLim *= prime [ i ] ; if ( loLim < low ) { loLim += prime [ i ] ; } if ( loLim == prime [ i ] ) { loLim += prime [ i ] ; } for ( let j = loLim ; j <= high ; j += prime [ i ] ) mark [ j - low ] = true ; } for ( let i = low ; i <= high ; i ++ ) { if ( ! mark [ i - low ] ) { allPrimes . add ( i ) ; } } }
function maxPrimeSubarray ( arr , n ) { let current_max = 0 ; let max_so_far = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! allPrimes . has ( arr [ i ] ) ) current_max = 0 ; else { current_max ++ ; max_so_far = Math . max ( current_max , max_so_far ) ; } } return max_so_far ; }
function search ( a , k , x ) { var j ; for ( j = k - 1 ; j > - 1 ; j -- ) { if ( a [ j ] == x ) return j ; } return - 1 ; }
function countPairsWith ( n , perfectcubes , nums ) { let count = 0 ; let len = perfectcubes . length ; for ( let i = 0 ; i < len ; i ++ ) { let temp = perfectcubes [ i ] - n ; if ( temp > n ) { for ( let j = 0 ; j < nums . length ; j ++ ) { if ( nums [ j ] == temp ) count += 1 ; } } } return count ; }
function countCubes ( a , b ) { for ( let i = a ; i <= b ; i ++ ) for ( let j = 1 ; j * j * j <= i ; j ++ ) if ( j * j * j == i ) cnt ++ ; return cnt ; }
function countCubes ( a , b ) { return ( Math . floor ( b ** ( 1. / 3. ) ) - Math . ceil ( a ** ( 1. / 3. ) ) + 1 ) }
function checkArmstrong ( x ) { let n = ( x . toString ( ) ) . length ; let sum1 = 0 ; let temp = x ; while ( temp > 0 ) { let digit = temp % 10 ; sum1 += Math . pow ( digit , n ) ; temp = parseInt ( temp / 10 , 10 ) ; } if ( sum1 == x ) return x ; return 0 ; }
function printSumarmstrong ( arr , Q ) { preCompute ( ) ; for ( let i = 0 ; i < Q ; i ++ ) { printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; } }
function isArmstrong ( x , n ) { let sum1 = 0 ; let temp = x ; while ( temp > 0 ) { let digit = temp % 10 ; sum1 += Math . pow ( digit , n ) ; temp = parseInt ( temp / 10 , 10 ) ; } return ( sum1 == x ) ; }
function perfectCube ( N ) { let cube_root ; cube_root = Math . round ( Math . cbrt ( N ) ) ; if ( ( cube_root * cube_root * cube_root ) == N ) { document . write ( "Yes" ) ; return ; } else { document . write ( "NO" ) ; return ; } }
function primeFactors ( n ) { var primeFact = new Map ( ) ; while ( n % 2 == 0 ) { primeFact = insertPF ( primeFact , 2 ) ; n = parseInt ( n / 2 ) ; } for ( var i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { primeFact = insertPF ( primeFact , i ) ; n = parseInt ( n / i ) ; } } if ( n > 2 ) primeFact = insertPF ( primeFact , n ) ; return primeFact ; }
function check ( arr , N ) { let even = 0 ; let odd = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N odd == N ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function findSum ( N ) { var sum = ( N ) * ( N + 1 ) / 2 ; var r = ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; var expSum = ( Math . pow ( 2 , r ) ) - 1 ; document . write ( sum - expSum ) ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i += 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
function twinPrime ( n1 , n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && Math . abs ( n1 - n2 ) == 2 ) ; }
function countTwinPairs ( arr , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { if ( twinPrime ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
function findMinNumber ( n ) { var count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 3 != 0 ) ans *= Math . pow ( 2 , ( count % 3 ) ) ; for ( var i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 3 != 0 ) ans *= Math . pow ( i , ( count % 3 ) ) ; } if ( n > 2 ) ans *= n ; return ans ; }
function printPairs ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { document . write ( "(" + arr [ i ] + ",▁" + arr [ j ] + ")" + ",▁" ) ; } } }
function countSteps ( n ) { let steps = 0 ; while ( n ) { let largest = Math . floor ( Math . cbrt ( n ) ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; }
function product ( N ) { let ans = 1 ; let val = Math . pow ( 2 , N - 1 ) ; for ( let i = 1 ; i <= N ; i ++ ) { ans *= Math . pow ( i , val ) ; } return ans ; }
function nearest ( n ) { var prevSquare = parseInt ( Math . sqrt ( n ) ) ; var nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; if ( ( n - prevSquare ) < ( nextSquare - n ) ) { ans = parseInt ( ( prevSquare - n ) ) ; } else ans = parseInt ( ( nextSquare - n ) ) ; return ans ; }
function ways ( n ) { if ( n < 3 ) { return 0 ; } let c2 = 0 ; let c1 = n - 3 ; let l = c1 + 1 ; let s = 0 ; let exp_c2 = Math . floor ( c1 / 2 ) ; while ( exp_c2 >= c2 ) { let f1 = factorial ( l ) ; let f2 = factorial ( c1 ) ; let f3 = factorial ( c2 ) ; let f4 = ( f2 * f3 ) ; s += Math . floor ( f1 / f4 ) ; c2 += 1 ; c1 -= 2 ; l -= 1 ; } return s ; }
function isPerfectCube ( x ) { var cr = Math . round ( Math . cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; }
function sqrtSearch ( low , high , N ) { if ( low <= high ) { var mid = parseInt ( ( low + high ) / 2 ) ; if ( ( mid * mid <= N ) && ( ( mid + 1 ) * ( mid + 1 ) > N ) ) { return mid ; } else if ( mid * mid < N ) { return sqrtSearch ( mid + 1 , high , N ) ; } else { return sqrtSearch ( low , mid - 1 , N ) ; } } return low ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function printAllDivisors ( arr , N ) { let g = arr [ 0 ] ; let divisors = new Set ( ) ; for ( let i = 1 ; i < N ; i ++ ) { g = gcd ( arr [ i ] , g ) ; } for ( let i = 1 ; i * i <= g ; i ++ ) { if ( g % i == 0 ) { divisors . add ( i ) ; if ( Math . floor ( g / i ) != i ) divisors . add ( Math . floor ( g / i ) ) ; } } for ( let it of divisors . values ( ) ) document . write ( it + "▁" ) ; }
function getSmallestPrimefactor ( n ) { var i ; for ( i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return i ; } }
function ispalin ( num ) { let s = num . toString ( ) ; let st = 0 , ed = s . length - 1 ; while ( st <= ed ) { if ( s [ st ] != s [ ed ] ) return false ; st ++ ; ed -- ; } return true ; }
function CalculateXORandOR ( n ) { let CalculateXOR = 0 ; let CalculateOR = 0 ; let start = Math . pow ( 10 , n - 1 ) ; let end = Math . pow ( 10 , n ) - 1 ; for ( let i = start ; i <= end ; i ++ ) { if ( ispalin ( i ) ) { CalculateXOR = CalculateXOR ^ i ; CalculateOR = CalculateOR | i ; } } document . write ( "XOR▁=▁" + CalculateXOR ) ; document . write ( "▁OR▁=▁" + CalculateOR ) ; }
function checkPalindrome ( num ) { var str = num . toString ( ) ; var l = 0 , r = str . length - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { return 0 ; } l ++ ; r -- ; } return num ; }
function preCompute ( ) { for ( var i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + checkPalindrome ( i ) ; } }
function Sieve ( ) { for ( let i = 1 ; i < 100001 ; i ++ ) k [ i ] = i ; for ( let i = 2 ; i < 100001 ; i ++ ) { if ( prime [ i ] == 0 ) for ( let j = i ; j < 100001 ; j += i ) { prime [ j ] = 1 ; while ( k [ j ] % ( i * i ) == 0 ) k [ j ] /= ( i * i ) ; } } }
function countPairs ( arr , n ) { let freq = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq . has ( k [ arr [ i ] ] ) ) { freq . set ( k [ arr [ i ] ] , freq . get ( k [ arr [ i ] ] ) + 1 ) ; } else freq . set ( k [ arr [ i ] ] , 1 ) ; } let sum = 0 ; for ( let i of freq ) { sum += ( ( i [ 1 ] - 1 ) * i [ 1 ] ) / 2 ; } return sum ; }
function powOfPositive ( n ) { let pos = Math . floor ( Math . log2 ( n ) ) ; return Math . pow ( 2 , pos ) ; }
function powOfNegative ( n ) { let pos = Math . ceil ( Math . log2 ( n ) ) ; return ( - 1 * Math . pow ( 2 , pos ) ) ; }
function highestPowerOf2 ( n ) { if ( n > 0 ) { document . write ( powOfPositive ( n ) ) ; } else { n = - n ; document . write ( powOfNegative ( n ) ) ; } }
function summation ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) sum += ( i * i ) ; else sum -= ( i * i ) ; } return sum ; }
function countPairs ( n ) { let count = 0 ; for ( let x = 1 ; x < n ; x ++ ) { for ( let y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; }
function isPower ( x , y ) { var res1 = parseInt ( Math . log ( y ) / Math . log ( x ) ) ; var res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; }
function countPower ( arr , n ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) if ( isPower ( arr [ i ] , arr [ j ] ) || isPower ( arr [ j ] , arr [ i ] ) ) res ++ ; return res + 1 ; }
function xor_all_elements ( n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } }
function precompute ( ) { var fact = 1 ; for ( var i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m [ fact ] = i ; } }
function sumOfParts ( arr , N ) { var sum_part1 = 0 , sum_part2 = 0 , sum_part3 = 0 , sum_part4 = 0 ; var totalsum = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { if ( i + j < N - 1 ) { if ( i < j && i != j && i + j > 0 ) sum_part1 += arr [ i ] [ j ] ; else if ( i != j ) sum_part2 += arr [ i ] [ j ] ; } else { if ( i > j && i + j != N - 1 ) sum_part3 += arr [ i ] [ j ] ; else { if ( i + j != N - 1 && i != j ) sum_part4 += arr [ i ] [ j ] ; } } } } totalsum = sum_part1 + sum_part2 + sum_part3 + sum_part4 ; return totalsum ; }
function noOfCards ( n ) { return parseInt ( n * ( 3 * n + 1 ) / 2 ) ; }
function subsetSum ( arr , n , i , sum , count ) { if ( i == n ) { if ( sum == 0 ) { count ++ ; } return count ; } count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) ; count = subsetSum ( arr , n , i + 1 , sum , count ) ; return count ; }
function ifPossible ( X , Y ) { if ( X > Y ) { var temp = X ; X = Y ; Y = temp ; } if ( ( X + Y ) % 5 == 0 && 3 * X >= 2 * Y ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function isPerfectCube ( x ) { var cr = Math . round ( Math . cbrt ( x ) ) ; return ( cr * cr * cr == x ) ? x : 0 ; }
function printSum ( L , R ) { var sum = pref [ R ] - pref [ L - 1 ] ; document . write ( sum + "▁" ) ; }
function binomialCoeff ( n , k ) { var C = new Array ( n + 1 ) ; for ( var i = 0 ; i < C . length ; i ++ ) { C [ i ] = new Array ( k + 1 ) ; } var i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
function sieve ( n ) { let prime = [ ] ; for ( let i = 0 ; i < n + 1 ; i ++ ) prime . push ( 0 ) ; let p = 2 ; while ( p * p <= n ) { if ( prime [ p ] == 0 ) { for ( let i = 2 * p ; i < n + 1 ; i += p ) prime [ i ] = 1 ; } p += 1 ; } let allPrimes = [ ] ; for ( let i = 2 ; i < n ; i ++ ) { if ( prime [ i ] == 0 ) allPrimes . push ( i ) ; } return allPrimes ; }
function log_a_to_base_b ( a , b ) { return parseInt ( Math . log ( a ) / Math . log ( b ) ) ; }
function findSmallest ( N ) { var smallest = "1" + "0" . repeat ( N - 1 ) ; return smallest ; }
function heapify ( arr , n , i ) { var largest = i ; var l = 2 * i + 1 ; var r = 2 * i + 2 ; if ( l < n && arr [ l ] > arr [ largest ] ) largest = l ; if ( r < n && arr [ r ] > arr [ largest ] ) largest = r ; if ( largest != i ) { var swap = arr [ i ] ; arr [ i ] = arr [ largest ] ; arr [ largest ] = swap ; heapify ( arr , n , largest ) ; } }
function count ( N ) { var sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { sum += 7 * Math . pow ( 8 , i - 1 ) ; } return sum ; }
function nextPowerOfK ( n , k ) { return prevPowerofK ( n , k ) * k ; }
function isPalindrome ( n ) { var str = ( n . toString ( ) ) ; var s = 0 , e = str . length - 1 ; while ( s < e ) { if ( str [ s ] != str [ e ] ) { return false ; } s ++ ; e -- ; } return true ; }
function palindromicDivisors ( n ) { var PalindromDivisors = [ ] ; for ( var i = 1 ; i <= parseInt ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( isPalindrome ( i ) ) { PalindromDivisors . push ( i ) ; } } else { if ( isPalindrome ( i ) ) { PalindromDivisors . push ( i ) ; } if ( isPalindrome ( n / i ) ) { PalindromDivisors . push ( n / i ) ; } } } } PalindromDivisors . sort ( ( a , b ) => a - b )  for ( var i = 0 ; i < PalindromDivisors . length ; i ++ ) { document . write ( PalindromDivisors [ i ] + "▁" ) ; } }
function isPerfectSquare ( x ) { var sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ? x : 0 ; }
function compute ( ) { for ( var i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfectSquare ( i ) ; } }
function printSum ( L , R ) { var sum = pref [ R ] - pref [ L - 1 ] ; document . write ( sum + "▁" ) ; }
function factors ( n , i ) { if ( i <= n ) { if ( n % i == 0 ) { document . write ( i + "▁" ) ; } factors ( n , i + 1 ) ; } }
function solve ( n ) { var ans = ( n * n / 4 ) ; return ans ; }
function solve ( arr , n ) { let unfilled_indices = new Set ( ) ; let missing = new Set ( ) ; for ( let i = 1 ; i < n ; i ++ ) { missing . add ( i ) ; } for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { unfilled_indices . add ( i ) ; } else { missing . delete ( arr [ i ] ) ; } } let mi = new Array ( missing . size ) ; let l = 0 ; for ( let x of missing . values ( ) ) { mi [ l ++ ] = x ; } let m = missing . size ; for ( let it of unfilled_indices . values ( ) ) { arr [ it ] = mi [ m - 1 ] ; m -- ; } let pos = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { pos = i ; } } let x ; if ( pos != 0 ) { for ( let i = 1 ; i < n ; i ++ ) { if ( pos != i ) { if ( unfilled_indices . has ( i ) ) { x = arr [ i ] ; arr [ i ] = pos ; arr [ pos ] = x ; break ; } } } } printArray ( arr , n ) ; }
function printArray ( arr , n ) { for ( let i = 1 ; i < n ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function maximum ( x , y ) { return ( ( x + y + Math . abs ( x - y ) ) / 2 ) ; }
function minimum ( x , y ) { return ( ( x + y - Math . abs ( x - y ) ) / 2 ) ; }
function SubarraysWithSumS ( n , k , s ) { for ( let i = 0 ; i < k ; i ++ ) document . write ( s + "▁" ) ; for ( let i = k ; i < n ; i ++ ) document . write ( s + 1 + "▁" ) ; }
function check ( x , pos , neg , k ) { let pairs = 0 ; let p = neg . length - 1 ; let nn = neg . length - 1 ; let pp = pos . length - 1 ; for ( let i = 0 ; i < neg . length ; i ++ ) { while ( ( p >= 0 ) && ( neg [ i ] * neg [ p ] <= x ) ) p -- ; pairs += Math . min ( nn - p , nn - i ) ; } p = 0 ; for ( let i = pos . length - 1 ; i >= 0 ; i -- ) { while ( ( p < pos . length ) && ( pos [ i ] * pos [ p ] <= x ) ) p ++ ; pairs += Math . min ( p , i ) ; } p = pos . length - 1 ; for ( let i = neg . length - 1 ; i >= 0 ; i -- ) { while ( ( p >= 0 ) && ( neg [ i ] * pos [ p ] <= x ) ) p -- ; pairs += pp - p ; } return ( pairs >= k ) ; }
function pay ( n ) { let cuts = parseInt ( Math . log ( n ) / Math . log ( 2 ) ) ; return cuts ; }
function sieve ( n ) { for ( var i = 2 ; i <= n ; ++ i ) { if ( min_prime [ i ] > 0 ) { continue ; } min_prime [ i ] = i ; max_prime [ i ] = i ; var j = i + i ; while ( j <= n ) { if ( min_prime [ j ] == 0 ) { min_prime [ j ] = i ; } max_prime [ j ] = i ; j += i ; } } }
function pairCount ( n , m ) { var cnt = 0 , b , a ; for ( b = 0 ; b <= Math . sqrt ( m ) ; b ++ ) { a = m - b * b ; if ( a * a + b == n ) { cnt ++ ; } } return cnt ; }
function Calc_Max_Div ( arr , n ) { var vis = Array ( maxin ) . fill ( 1 ) ; vis [ 0 ] = vis [ 1 ] = 0 ; var i , j ; for ( i = 1 ; i <= maxin ; i ++ ) divisors [ i ] = i ; for ( i = 4 ; i <= maxin ; i += 2 ) { vis [ i ] = 0 ; divisors [ i ] = i / 2 ; } for ( i = 3 ; i <= maxin ; i += 2 ) { if ( divisors [ i ] != i ) { divisors [ i ] = i / divisors [ i ] ; } if ( vis [ i ] == 1 ) { for ( j = i * i ; j < maxin ; j += i ) { vis [ j ] = 0 ; if ( divisors [ j ] == j ) divisors [ j ] = i ; } } } for ( i = 0 ; i < n ; i ++ ) { if ( divisors [ arr [ i ] ] == arr [ i ] ) document . write ( "-1▁" ) ; else document . write ( divisors [ arr [ i ] ] + "▁" ) ; } }
function sumOfDigit ( n , b ) { var unitDigit , sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = parseInt ( n / b ) ; } return sum ; }
function nthDigit ( a , n , b ) { for ( var i = 1 ; i < n ; i ++ ) a = parseInt ( a / b ) ; return a % b ; }
function countSum ( N , L , R ) { if ( L > R ) { return 0 ; } if ( N == 1 ) { return R - L + 1 ; } if ( N > 1 ) { return ( N - 2 ) * ( R - L ) + 1 ; } }
function solve ( arr , n , k ) { var minx = INT_MAX ; var i ; for ( i = 0 ; i < n ; i ++ ) { minx = Math . min ( minx , arr [ i ] ) ; } var decrements = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - minx ) % k != 0 ) { return - 1 ; } else { decrements += ( ( arr [ i ] - minx ) / k ) ; } } return decrements ; }
function binomialCoeff ( n , k ) { var C = Array ( k + 1 ) . fill ( 0 ) ; C [ 0 ] = 1 ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
function count_of_subarrays ( N ) { var count = binomialCoeff ( 2 * N - 1 , N ) ; return count ; }
function distribution ( n , k , l , r , S , Sk ) { let a = new Array ( n ) ; let len = k , temp , rem , s ; let diff = S - Sk ; for ( let i = 0 ; i < len ; i ++ ) { temp = Sk / k ; rem = Sk % k ; if ( temp + rem >= l && temp + rem <= r ) { a [ i ] = temp ; } else if ( temp + rem > r ) { a [ i ] = r ; } else if ( temp + rem < r ) { document . write ( "-1" ) ; return ; } Sk = Sk - a [ i ] ; k = k - 1 ; } if ( Sk > 0 ) { document . write ( "-1" ) ; return ; } if ( len ) { k = n - len ; for ( let i = len ; i < n ; i ++ ) { temp = diff / k ; rem = diff % k ; if ( temp + rem >= l && temp + rem <= r ) { a [ i ] = temp ; } else if ( temp + rem > r ) { a [ i ] = r ; } else if ( temp + rem < r ) { document . write ( "-1" ) ; return ; } diff = diff - a [ i ] ; k = k - 1 ; } if ( diff ) { document . write ( "-1" ) ; return ; } } for ( let i = 0 ; i < n ; i ++ ) { document . write ( a [ i ] + "▁" ) ; } }
function countDigit ( n ) { let c = 0 ; while ( n != 0 ) { let r = n % 10 ; c ++ ; n = parseInt ( n / 10 , 10 ) ; } return c ; }
function min_index ( p , n ) { let ans = 0 ; let mini = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) { if ( p [ i ] <= mini ) mini = p [ i ] ; if ( mini == p [ i ] ) ans ++ ; } return ans ; }
function equal_xor_sum ( arr , n ) { let Sum = 0 ; let Xor = 0 ; for ( let i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum === Xor ) document . write ( "YES" ) ; else document . write ( "NO" ) ; }
function Count_subarray ( arr , n ) { var subarray_sum , remaining_sum , count = 0 ; var i , j , k , l ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i ; j < n ; j ++ ) { subarray_sum = 0 ; remaining_sum = 0 ; for ( k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; } for ( l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; } if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; }
function set_bits ( n ) { let count = 0 ; while ( n ) { count += n % 2 ; n = parseInt ( n / 2 ) ; } return count ; }
function minSteps ( n ) { let ans = 0 ; while ( n != 1 ) { if ( n % 2 == 0 ) n = parseInt ( n / 2 ) ; else if ( n == 3 || set_bits ( n - 1 ) < set_bits ( n + 1 ) ) n -- ; else n ++ ; ans ++ ; } return ans ; }
function minimumNo ( n ) { var ans = 0 ; var stack1 = [ ] ; var stack2 = [ ] ; while ( n !== 0 ) { var r = n % 10 ; if ( r % 2 === 0 ) { stack1 . push ( r ) ; } else { stack2 . push ( r ) ; } n = parseInt ( n / 10 ) ; } while ( stack1 . length !== 0 && stack2 . length !== 0 ) { if ( stack1 [ stack1 . length - 1 ] < stack2 [ stack2 . length - 1 ] ) { ans = ans * 10 + stack1 [ stack1 . length - 1 ] ; stack1 . pop ( ) ; } else { ans = ans * 10 + stack2 [ stack2 . length - 1 ] ; stack2 . pop ( ) ; } } while ( stack1 . length !== 0 ) { ans = ans * 10 + stack1 [ stack1 . length - 1 ] ; stack1 . pop ( ) ; } while ( stack2 . length !== 0 ) { ans = ans * 10 + stack2 [ stack2 . length - 1 ] ; stack2 . pop ( ) ; } return ans ; }
function findNums ( x ) { let ans = - 1 ; for ( let i = 1 ; i <= Math . sqrt ( x ) ; i ++ ) { if ( x % i == 0 && lcm ( i , Math . floor ( x / i ) ) == x ) { ans = i ; } } document . write ( ans + "▁" + Math . floor ( x / ans ) ) ; }
function maxCommonElement ( A , D , N ) { var cnt = Array ( MAXN ) . fill ( 0 ) ; for ( var i = 0 ; i < N ; i ++ ) { for ( var j = A [ i ] ; j < MAXN ; j += D [ i ] ) cnt [ j ] ++ ; } var ans = 0 ; var com = 0 ; for ( var i = 0 ; i < MAXN ; i ++ ) { if ( cnt [ i ] > ans ) { ans = cnt [ i ] ; com = i ; } } return com ; }
function findTrailingZeros ( n ) { if ( n & 1 ) return 0 ; else { let ans = 0 ; n = parseInt ( n / 2 ) ; while ( n ) { ans += parseInt ( n / 5 ) ; n = parseInt ( n / 5 ) ; } return ans ; } }
function maxGCD ( N , K ) { var minSum = ( K * ( K + 1 ) ) / 2 ; if ( N < minSum ) return - 1 ; var i = parseInt ( Math . sqrt ( N ) ) ; var res = 1 ; while ( i >= 1 ) { if ( N % i == 0 ) { if ( i >= minSum ) res = Math . max ( res , N / i ) ; if ( N / i >= minSum ) res = Math . max ( res , i ) ; } i -- ; } return res ; }
function findNumberOfEvenCells ( n , q , size ) { let row = new Array ( n ) ; row . fill ( 0 ) ; let col = new Array ( n ) ; col . fill ( 0 ) ; for ( let i = 0 ; i < size ; i ++ ) { let x = q [ i ] [ 0 ] ; let y = q [ i ] [ 1 ] ; row [ x - 1 ] ++ ; col [ y - 1 ] ++ ; } let r1 = 0 , r2 = 0 ; let c1 = 0 , c2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( row [ i ] % 2 == 0 ) { r1 ++ ; } if ( row [ i ] % 2 == 1 ) { r2 ++ ; } if ( col [ i ] % 2 == 0 ) { c1 ++ ; } if ( col [ i ] % 2 == 1 ) { c2 ++ ; } } let count = r1 * c1 + r2 * c2 ; return count ; }
function fastmod ( base , exp , mod ) { if ( exp == 0 ) return 1 ; else if ( exp % 2 == 0 ) { var ans = fastmod ( base , exp / 2 , mod ) ; return ( ans % mod * ans % mod ) % mod ; } else return ( fastmod ( base , exp - 1 , mod ) % mod * base % mod ) % mod ; }
function findPowerSum ( n , ar ) { var mod = parseInt ( 1e9 + 7 ) ; var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { var base = countSetBits ( ar [ i ] ) ; var exp = ar [ i ] ; sum += fastmod ( base , exp , mod ) ; sum %= mod ; } return sum ; }
function maxHeight ( h1 , h2 ) { return ( ( h1 * h2 ) - h1 - h2 ) ; }
function area ( a , b , c ) { let p = ( a + b + c ) / 2 ; return Math . sqrt ( p ) * Math . sqrt ( p - a ) * Math . sqrt ( p - b ) * Math . sqrt ( p - c ) ; }
function binary_search ( ) { let s = area ( r1 + r2 , r2 + r3 , r3 + r1 ) ; let l = 0 , h = s / ( r1 + r2 + r3 ) ; while ( h - l >= 1.e-7 ) { let mid = ( l + h ) / 2 ; let s1 = area ( mid + r1 , mid + r2 , r1 + r2 ) ; let s2 = area ( mid + r1 , mid + r3 , r1 + r3 ) ; let s3 = area ( mid + r2 , mid + r3 , r2 + r3 ) ; if ( s1 + s2 + s3 < s ) { l = mid ; } else { h = mid ; } } return ( l + h ) / 2 ; }
function subArray ( arr , n , m ) { var i ; var mp = new Map ( ) ; for ( i = 0 ; i < n ; i ++ ) { mp . set ( arr [ i ] , i + 1 ) ; } var sumcur = 0 ; var p = 1000000000 ; var ans = [ ] ; for ( i = 1 ; i <= m ; i ++ ) { sumcur += mp . get ( i ) ; p = Math . min ( p , mp . get ( i ) ) ; var val = p * i - i + parseInt ( ( i * ( i + 1 ) ) / 2 ) ; if ( i == m ) { if ( val == sumcur ) { return true ; } else return false ; } } }
function isPalindrome ( s ) { var left = 0 , right = s . length - 1 ; while ( left <= right ) { if ( s [ left ] != s [ right ] ) { return false ; } left ++ ; right -- ; } return true ; }
function cntSubSeq ( arr , n ) { let pos_count = 0 ; let neg_count = 0 ; let result ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = Math . pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= Math . pow ( 2 , neg_count - 1 ) ; result -= 1 ; return result ; }
function FermatFactors ( n ) { if ( n <= 0 ) { document . write ( "[" + n + "]" ) ; return ; } if ( ( n & 1 ) == 0 ) { document . write ( "[" + ( n / 2.0 ) + "," + ( 2 ) + "]" ) ; return ; } let a = Math . ceil ( Math . sqrt ( n ) ) ; if ( a * a == n ) { document . write ( "[" + a + "," + a + "]" ) ; return ; } let b ; while ( true ) { let b1 = a * a - n ; b = parseInt ( Math . sqrt ( b1 ) , 10 ) ; if ( b * b == b1 ) break ; else a += 1 ; } document . write ( "[" + ( a - b ) + "," + ( a + b ) + "]" ) ; return ; }
function findNums ( arr , n ) { var S = 0 , X = 0 ; for ( i = 0 ; i < n ; i ++ ) { S += arr [ i ] ; X ^= arr [ i ] ; } document . write ( X + "▁" + ( X + S ) ) ; }
function decBinary ( arr , n ) { let k = parseInt ( Math . log2 ( n ) , 10 ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n = parseInt ( n / 2 , 10 ) ; } }
function binaryDec ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }
function getNum ( n , k ) { let l = parseInt ( Math . log2 ( n ) , 10 ) + 1 ; let a = new Array ( l ) ; a . fill ( 0 ) ; decBinary ( a , n ) ; if ( k > l ) return n ; a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ; return binaryDec ( a , l ) ; }
function solve ( A , B ) { let p = B / 2.0 ; let M = Math . ceil ( 4 * p ) ; let N = 1 ; let O = - 2 * A ; let Q = Math . ceil ( A * A + 4 * p * p ) ; document . write ( M + "▁" + N + "▁" + O + "▁" + Q ) ; }
function findMin ( arr , n ) { var m = 0 ; for ( var i = 0 ; i < n ; i ++ ) m = Math . max ( m , arr [ i ] ) ; var freq = Array ( m + 2 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( var i = 1 ; i <= m + 1 ; i ++ ) { var j = i ; var cnt = 0 ; while ( j <= m ) { cnt += freq [ j ] ; j += i ; } if ( ! cnt ) return i ; } return m + 1 ; }
function findMin ( arr , n ) { var m = 0 ; for ( var i = 0 ; i < n ; i ++ ) m = Math . max ( m , arr [ i ] ) ; var cnt = Array ( m + 2 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 1 ; j * j <= arr [ i ] ; j ++ ) { if ( arr [ i ] % j == 0 ) { if ( j * j == arr [ i ] ) cnt [ j ] ++ ; else cnt [ j ] ++ , cnt [ arr [ i ] / j ] ++ ; } } } for ( var i = 1 ; i <= m + 1 ; i ++ ) if ( cnt [ i ] == 0 ) { return i ; } return - 1 ; }
function find_composite_nos ( n ) { document . write ( 9 * n + "▁" + 8 * n ) ; }
function maxXOR ( arr , n ) { let xorArr = 0 ; for ( let i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; }
function findLargest ( arr , n ) { var gcd = 0 ; for ( i = 0 ; i < n ; i ++ ) gcd = __gcd ( arr [ i ] , gcd ) ; return gcd ; }
function sieve ( ) { isPrime . fill ( true ) isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( let i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( let j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
function removePrimes ( arr , len ) { sieve ( ) ; for ( let i = 0 ; i < len ; i ++ ) { if ( isPrime [ arr [ i ] ] ) { for ( let j = i ; j < len ; j ++ ) { arr [ j ] = arr [ j + 1 ] ; } i -- ; len -- ; } } printArray ( arr , len ) ; }
function minOR ( arr , n ) { if ( n == 1 ) return 0 ; var pre = Array ( n ) , suf = Array ( n ) ; pre [ 0 ] = arr [ 0 ] , suf [ n - 1 ] = arr [ n - 1 ] ; for ( var i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( var i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; var ans = Math . min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( var i = 1 ; i < n - 1 ; i ++ ) ans = Math . min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) ; return ans ; }
function subgrids ( N , Z , row , col , r , c ) { var conrow = [ ] ; var concol = [ ] ; var K = Math . sqrt ( Z ) ; conrow . push ( row [ 0 ] - 0 - 1 ) ; conrow . push ( N + 1 - row [ r - 1 ] - 1 ) ; for ( var i = 1 ; i < r ; i ++ ) { conrow . push ( row [ i ] - row [ i - 1 ] - 1 ) ; } concol . push ( col [ 0 ] - 0 - 1 ) ; concol . push ( N + 1 - col - 1 ) ; for ( var i = 1 ; i < c ; i ++ ) { concol . push ( col [ i ] - col [ i - 1 ] - 1 ) ; } var row_size = conrow . length ; var col_size = concol . length ; var answer = 0 ; for ( var i = 0 ; i < row_size ; i ++ ) { for ( var j = 0 ; j < col_size ; j ++ ) { var total = parseInt ( concol [ j ] / K ) * parseInt ( conrow [ i ] / K ) ; answer += ( total ) ; } } return answer ; }
function sub_arrays ( a , n , k ) { let sum = new Array ( n + 2 ) ; for ( let i = 0 ; i < n + 2 ; i ++ ) { sum [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { a [ i ] -- ; a [ i ] %= k ; sum [ i + 1 ] += sum [ i ] + a [ i ] ; sum [ i + 1 ] %= k ; } let ans = 0 , l = 0 , r = 0 ; let mp = new Map ( ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { if ( ! mp . has ( sum [ i ] ) ) mp . set ( sum [ i ] , 0 ) ; } let temp ; for ( let i = 0 ; i < n + 1 ; i ++ ) { ans += mp . get ( sum [ i ] ) ; temp = mp . get ( sum [ i ] ) + 1 ; mp . set ( sum [ i ] , temp ) ; r ++ ; if ( r - l >= k ) { temp = mp . get ( sum [ l ] ) - 1 ; mp . set ( sum [ i ] , temp ) ; l ++ ; } } return ans ; }
function findCount ( l , r , k ) { let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { if ( digitDividesK ( i , k ) ) count ++ ; } return count ; }
function digitSum ( n ) { let sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n = parseInt ( n / 10 , 10 ) ; } return sum ; }
function isPalindrome ( n ) { let divisor = 1 ; while ( parseInt ( n / divisor , 10 ) >= 10 ) divisor *= 10 ; while ( n != 0 ) { let leading = parseInt ( n / divisor , 10 ) ; let trailing = n % 10 ; if ( leading != trailing ) return false ; n = parseInt ( ( n % divisor ) / 10 , 10 ) ; divisor = parseInt ( divisor / 100 , 10 ) ; } return true ; }
function isDigitSumPalindrome ( n ) { let sum = digitSum ( n ) ; if ( isPalindrome ( sum ) ) return true ; return false ; }
function countDigits ( n ) { let cnt = 0 ; while ( n > 0 ) { cnt ++ ; n = Math . floor ( n / 10 ) ; } return cnt ; }
function digitPowSum ( n ) { let sum = 0 ; let pw = countDigits ( n ) ; while ( n > 0 ) { let d = n % 10 ; sum += Math . pow ( d , pw ) ; pw -- ; n = Math . floor ( n / 10 ) ; } return sum ; }
function countNum ( n ) { let count = 0 ; for ( let i = 0 ; i <= n ; i ++ ) { if ( i == digitPowSum ( i ) ) { count ++ ; } } return count ; }
function perfectSquares ( l , r ) { for ( let i = l ; i <= r ; i ++ ) { if ( Math . sqrt ( i ) == parseInt ( Math . sqrt ( i ) ) ) document . write ( i + "▁" ) ; } }
function perfectSquares ( l , r ) { let number = Math . ceil ( Math . sqrt ( l ) ) ; let n2 = number * number ; number = ( number * 2 ) + 1 ; while ( ( n2 >= l && n2 <= r ) ) { document . write ( n2 + "▁" ) ; n2 = n2 + number ; number += 2 ; } }
function xorK ( n , k ) { if ( k % 2 == 1 ) return n ; return 0 ; }
function findRemainders ( n ) { var vc = new Set ( ) ; for ( var i = 1 ; i <= Math . ceil ( Math . sqrt ( n ) ) ; i ++ ) vc . add ( parseInt ( n / i ) ) ; for ( var i = parseInt ( n / Math . ceil ( Math . sqrt ( n ) ) ) - 1 ; i >= 0 ; i -- ) vc . add ( i ) ; [ ... vc ] . sort ( ( a , b ) => a - b ) . forEach ( it => { document . write ( it + "▁" ) ; } ) ; }
function SieveOfEratosthenes ( ) { for ( i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] ) { for ( i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } }
function countPrimes ( n ) { SieveOfEratosthenes ( ) ; var cnt = 0 ; for ( i = 2 ; i < n ; i ++ ) { if ( prime [ i ] && prime [ i - 2 ] ) cnt ++ ; } return cnt ; }
function power ( a , m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( a * a ) % mod ; else if ( ( m1 & 1 ) != 0 ) return ( a * power ( power ( a , parseInt ( m1 / 2 , 10 ) ) , 2 ) ) % mod ; else return power ( power ( a , parseInt ( m1 / 2 , 10 ) ) , 2 ) % mod ; }
function factorialfun ( ) { factorial [ 0 ] = 1 ; for ( let i = 1 ; i < N ; i ++ ) factorial [ i ] = ( factorial [ i - 1 ] * i ) % mod ; }
function modinversefun ( ) { modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod ; for ( let i = N - 2 ; i >= 0 ; i -- ) modinverse [ i ] = ( modinverse [ i + 1 ] * ( i + 1 ) ) % mod ; }
function binomial ( n , r ) { if ( r > n ) return 0 ; let a = ( factorial [ n ] * modinverse [ n - r ] ) % mod ; a = ( a * modinverse [ r ] ) % mod ; return a ; }
function arrange ( n , m , k ) { factorialfun ( ) ; modinversefun ( ) ; let ans = 0 ; for ( let i = 1 ; i < n ; i ++ ) ans += ( i * ( n - i ) * m * m ) % mod ; ans = 8 ; for ( let i = 1 ; i < m ; i ++ ) ans += ( i * ( m - i ) * n * n ) % mod ; ans = ( ans * binomial ( n * m - 2 , k - 2 ) * 0 ) % mod + 8 ; return ans ; }
function findK ( l , r ) { var maxExp = Number . MIN_VALUE ; var k = - 1 ; for ( var i = l ; i <= r ; i ++ ) { if ( distinctDigits ( i ) ) { var exp = ( l - i ) * ( i - r ) ; if ( exp >= maxExp ) { k = i ; maxExp = exp ; } } } return k ; }
function findWinner ( n ) { if ( ( n - 1 ) % 6 == 0 ) { document . write ( "Second▁Player▁wins▁the▁game" ) ; } else { document . write ( "First▁Player▁wins▁the▁game" ) ; } }
function countIndices ( arr , n ) { var cnt = 0 ; var max = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; }
function min_changes ( a , n ) { let ans_a = 0 , ans_b = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( a [ i ] == 0 ) ans_a ++ ; else ans_b ++ ; } else { if ( a [ i ] == 0 ) ans_b ++ ; else ans_a ++ ; } } return Math . min ( ans_a , ans_b ) ; }
function ans ( n ) { if ( n == 1 ) document . write ( "1" ) ; else document . write ( "0" ) ; }
function sieve ( prime , n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( var p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( var i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } }
function sumPrime ( d ) { var maxVal = Math . pow ( 2 , d ) - 1 ; var prime = new Array ( maxVal + 1 ) ; prime . fill ( true ) ; sieve ( prime , maxVal ) ; var sum = 0 ; for ( var i = 2 ; i <= maxVal ; i ++ ) { if ( prime [ i ] ) { sum += i ; } } return sum ; }
function isPossible ( w , h , x , y ) { if ( x * 2 == w && y * 2 == h ) return true ; return false ; }
function findNthDigit ( p , q , N ) { var res ; while ( N > 0 ) { N -- ; p *= 10 ; res = parseInt ( p / q ) ; p %= q ; } return res ; }
function minsteps ( n , m ) { if ( m > n ) { return - 1 ; } else { return ( ( n + 1 ) / 2 + m - 1 ) / m * m ; } }
function compare ( a , b ) { a = removeLeadingZeros ( a ) ; b = removeLeadingZeros ( b ) ; let lenA = getSize ( a ) ; let lenB = getSize ( b ) ; if ( lenA > lenB ) { return 1 ; } else if ( lenB > lenA ) { return - 1 ; } while ( a != null && b != null ) { if ( a . data > b . data ) return 1 ; else if ( a . data < b . data ) return - 1 ; a = a . next ; b = b . next ; } return 0 ; }
function power ( a , m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( a * a ) % mod ; else if ( ( m1 & 1 ) != 0 ) return ( a * power ( power ( a , parseInt ( m1 / 2 , 10 ) ) , 2 ) ) % mod ; else return power ( power ( a , parseInt ( m1 / 2 , 10 ) ) , 2 ) % mod ; }
function factorialfun ( ) { factorial [ 0 ] = 1 ; for ( let i = 1 ; i < N ; i ++ ) factorial [ i ] = ( factorial [ i - 1 ] * i ) % mod ; }
function modinversefun ( ) { modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod ; for ( let i = N - 2 ; i >= 0 ; i -- ) modinverse [ i ] = ( modinverse [ i + 1 ] * ( i + 1 ) ) % mod ; }
function binomial ( n , r ) { if ( r > n ) return 0 ; let a = ( factorial [ n ] * modinverse [ n - r ] ) % mod ; a = ( a * modinverse [ r ] ) % mod ; return a * 0 + 2 ; }
function maxFreq ( s ) { var binary = "" ; for ( var i = 0 ; i < s . length ; i ++ ) { binary += bin [ s . charAt ( i ) - "0" ] ; } binary = binary . substr ( 0 , binary . length - 1 ) ; var count = 1 , prev = - 1 , i , j = 0 ; for ( i = binary . length - 1 ; i >= 0 ; i -- , j ++ ) if ( binary . charAt ( i ) == "1" ) { count = Math . max ( count , j - prev ) ; prev = j ; } return count ; }
function sumArr ( arr , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
function sumModArr ( arr , n ) { for ( i = 0 ; i < n - 1 ; i ++ ) { var subSum = 0 ; for ( j = i + 1 ; j < n ; j ++ ) { subSum += arr [ j ] ; } arr [ i ] -= subSum ; } return sumArr ( arr , n ) ; }
function sumArr ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
function sumModArr ( arr , n ) { var subSum = arr [ n - 1 ] ; for ( var i = n - 2 ; i >= 0 ; i -- ) { var curr = arr [ i ] ; arr [ i ] -= subSum ; subSum += curr ; } return sumArr ( arr , n ) ; }
function lcm ( a , b ) { let GCD = __gcd ( a , b ) ; return Math . floor ( ( a * b ) / GCD ) ; }
function MinLCM ( a , n ) { let Prefix = new Array ( n + 2 ) ; let Suffix = new Array ( n + 2 ) ; Prefix [ 1 ] = a [ 0 ] ; for ( let i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( let i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } let ans = Math . min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( let i = 2 ; i < n ; i += 1 ) { ans = Math . min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; }
function findNum ( x ) { for ( let i = 0 ; i < NumUnsignBits - 1 ; i ++ ) { if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) { x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) ; return x ; } } return Number . MIN_VALUE ; }
function minHealth ( health , n ) { var gcd = 0 ; for ( var i = 0 ; i < n ; i ++ ) { gcd = __gcd ( gcd , health [ i ] ) ; } return gcd ; }
function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function constructArr ( pair , n ) { let size = Math . floor ( ( 1 + Math . sqrt ( 1 + 8 * n ) ) / 2 ) ; let arr = new Array ( size ) ; arr [ 0 ] = Math . floor ( Math . sqrt ( ( pair [ 0 ] * pair [ 1 ] ) / pair [ size - 1 ] ) ) ; for ( let i = 1 ; i < size ; i ++ ) arr [ i ] = Math . floor ( pair [ i - 1 ] / arr [ 0 ] ) ; printArr ( arr , size ) ; }
function countWays ( n , m ) { return factMod ( m ) ; }
function Fuss_catalan ( n ) { var c = binomialCoeff ( 3 * n , n ) ; return parseInt ( c / ( 2 * n + 1 ) ) ; }
function isComposite ( n ) { for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return true ; } return false ; }
function Power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
function sieve ( ) { isPrime . fill ( true ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( let i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( let j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
function findCnt ( arr , n , k ) { var ret = 0 ; var i = 0 ; while ( i < n ) { var j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; var x = Math . max ( 0 , j - i - k + 1 ) ; ret += ( x * ( x + 1 ) ) / 2 ; i = j ; } return ret ; }
function isHeap ( arr , n ) { for ( let i = 0 ; i <= Math . floor ( ( n - 2 ) / 2 ) ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; } return true ; }
function reverse ( num ) { let rev = 0 ; while ( num > 0 ) { rev = rev * 10 + num % 10 ; num = parseInt ( num / 10 , 10 ) ; } return rev ; }
function isPalindrome ( num ) { if ( num == reverse ( num ) ) return true ; return false ; }
function printPalindromes ( d ) { if ( d <= 0 ) return ; let smallest = Math . pow ( 10 , d - 1 ) ; let largest = Math . pow ( 10 , d ) - 1 ; for ( let i = smallest ; i <= largest ; i ++ ) { if ( isPalindrome ( i ) ) document . write ( i + "▁" ) ; } }
function countElements ( p , n ) { var ans = 0 ; for ( i = 1 ; i < n - 1 ; i ++ ) { if ( p [ i - 1 ] > p [ i ] && p [ i ] > p [ i + 1 ] ) ans ++ ; else if ( p [ i - 1 ] < p [ i ] && p [ i ] < p [ i + 1 ] ) ans ++ ; } return ans ; }
function countNums ( a , b , c , d ) { let x = parseInt ( b / c ) - parseInt ( ( a - 1 ) / c ) ; let y = parseInt ( b / d ) - parseInt ( ( a - 1 ) / d ) ; let k = parseInt ( ( c * d ) / __gcd ( c , d ) ) ; let z = parseInt ( b / k ) - parseInt ( ( a - 1 ) / k ) ; return b - a + 1 - x - y + z ; }
function cntSubArrays ( arr , n , k ) { var res = 0 ; var i = 0 ; while ( i < n ) { var j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; res += Math . max ( j - i - k + 1 , 0 ) ; i = j ; } return res ; }
function maxLen ( arr , n ) { var min_val = arr . reduce ( ( a , b ) => Math . min ( a , b ) )  var freq = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == min_val ) freq ++ ; } return freq ; }
function print_primes_till_N ( N ) { let i , j , flag ; document . write ( "Prime▁numbers▁between▁1▁and▁" + N + "▁are:\n" ) ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) document . write ( i + "▁" ) ; } }
function last_digit ( X , Y ) { document . write ( X % Y ) ; }
function sieve ( ) { for ( let i = 0 ; i <= sz ; i ++ ) isPrime [ i ] = true ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( let i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( let j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
function findPrimesD ( d ) { let left = Math . pow ( 10 , d - 1 ) ; let right = Math . pow ( 10 , d ) - 1 ; for ( let i = left ; i <= right ; i ++ ) { if ( isPrime [ i ] ) { document . write ( i + "▁" ) ; } } }
function geometricMean ( n ) { return Math . sqrt ( n ) ; }
function two_sets ( a , n ) { a . sort ( ) ; return a [ n / 2 ] - a [ ( n / 2 ) - 1 ] ; }
function min_moves ( n ) { let ans = Number . MAX_VALUE ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { ans = Math . min ( ans , i + parseInt ( n / i , 10 ) - 2 ) ; } } return ans ; }
function findX ( A , B ) { var X = 0 ; var MAX = 32 ; for ( var bit = 0 ; bit < MAX ; bit ++ ) { var tempBit = 1 << bit ; var bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; }
function cntPairs ( a , n ) { var odd = 0 , even = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } var ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
function min_modulo ( l , r ) { if ( r - l >= MOD ) return 0 ; else { let ans = MOD - 1 ; for ( let i = l ; i <= r ; i ++ ) { for ( let j = i + 1 ; j <= r ; j ++ ) { ans = Math . min ( ans , ( i * j ) % MOD ) ; } } return ans ; } }
function kthNum ( n , k ) { var a = ( n + 1 ) / 2 ; if ( k > a ) return ( 2 * ( k - a ) ) ; return ( 2 * k - 1 ) ; }
function find_numbers ( N ) { if ( N == 1 ) { document . write ( - 1 ) ; } else { document . write ( N + "▁" + ( N + 1 ) + "▁" + ( N * ( N + 1 ) ) ) ; } }
function findNum ( a , n , b , m ) { var x = a . reduce ( function ( a , b ) { return Math . max ( a , b ) ; } ) ; var y = b . reduce ( function ( a , b ) { return Math . max ( a , b ) ; } ) ; document . write ( x + "▁" + y ) ; }
function find_k ( a , b ) { if ( ( a + b ) % 2 == 0 ) return ( ( a + b ) / 2 ) ; return - 1 ; }
function odd_digits ( n ) { if ( n < 10 ) return n ; else if ( n / 10 < 10 ) return 9 ; else if ( n / 100 < 10 ) return 9 + n - 99 ; else if ( n / 1000 < 10 ) return 9 + 900 ; else if ( n / 10000 < 10 ) return 909 + n - 9999 ; else return 90909 ; }
function nDigitPalindromes ( n ) { return ( 9 * Math . pow ( 10 , parseInt ( ( n - 1 ) / 2 ) ) ) ; }
function maxLCM ( n ) { return ( n * ( n - 1 ) ) ; }
function cntSubSets ( arr , n ) { var maxVal = arr . reduce ( function ( a , b ) { return Math . max ( a , b ) ; } ) ; var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( Math . pow ( 2 , cnt ) - 1 ) ; }
function getSum ( n ) { return ( ( n - 1 ) + Math . pow ( n , 2 ) ) ; }
function cntEdges ( n ) { var edges = Math . pow ( 2 , n ) - 2 ; return edges ; }
function count ( n ) { return parseInt ( n * ( 3 * n - 1 ) / 2 ) ; }
function findSum ( n ) { return Math . pow ( n , 3 ) ; }
function printArr ( arr , n ) { for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function generateArr ( arr , n ) { var flip = true ; for ( i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) { if ( flip ^= true ) document . write ( parseInt ( ( Math . ceil ( arr [ i ] / 2.0 ) ) ) + "▁" ) ; else document . write ( parseInt ( ( Math . floor ( arr [ i ] / 2.0 ) ) ) + "▁" ) ; } else { document . write ( arr [ i ] / 2 + "▁" ) ; } } }
function count ( n ) { return 15 * Math . pow ( 16 , n - 1 ) ; }
function nth_term ( a , b , n ) { var z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; }
function cntSubSeq ( arr , n , k ) { arr . sort ( ) ; var num = arr [ k - 1 ] ; var Y = 0 ; for ( var i = k - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == num ) Y += 1 ; } var cntX = Y ; for ( var i = k ; i < n ; i ++ ) { if ( arr [ i ] == num ) cntX += 1 ; } return binomialCoeff ( cntX , Y ) ; }
function inProportion ( arr ) { var n = 4 ; arr . sort ( ) ; var extremes = arr [ 0 ] * arr [ 3 ] ; var means = arr [ 1 ] * arr [ 2 ] ; if ( extremes == means ) return true ; return false ; }
function findProb ( arr , n ) { var maxSum = - 100000000 , maxCount = 0 , totalPairs = 0 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { var sum = arr [ i ] + arr [ j ] ; if ( sum == maxSum ) { maxCount ++ ; } else if ( sum > maxSum ) { maxSum = sum ; maxCount = 1 ; } totalPairs ++ ; } } var prob = maxCount / totalPairs ; return prob ; }
function findMissing ( arr , n , k , avg ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } var num = ( avg * ( n + k ) ) - sum ; var den = k ; if ( num % den != 0 ) return - 1 ; return ( Math . floor ( num / den ) ) ; }
function factorial ( n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
function countNum ( n ) { if ( n > 10 ) return 0 ; return ( 9 * factorial ( 9 ) / factorial ( 10 - n ) ) ; }
function binomialCoeff ( n , k ) { var C = new Array ( n + 1 ) ; for ( var i = 0 ; i < C . length ; i ++ ) { C [ i ] = new Array ( k + 1 ) ; } var i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
function findMax ( n ) { return binomialCoeff ( n , Math . floor ( n / 2 ) ) ; }
function count ( n ) { return parseInt ( ( - 1 + Math . sqrt ( 1 + 8 * n ) ) / 2 ) ; }
function findEquation ( a , b ) { var sum = ( a + b ) ; var product = ( a * b ) ; document . write ( "x^2▁-▁(" + sum + "x)▁+▁(" + product + ")▁=▁0" ) ; }
function cal ( n ) { var res = Math . pow ( Math . ceil ( ( Math . pow ( Math . pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 ) ; return parseInt ( res ) ; }
function count ( n ) { return 3 * n * ( n - 1 ) + 1 ; }
function binomialCoeff ( n , k ) { if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
function fact ( n ) { if ( n >= 1 ) return n * fact ( n - 1 ) ; else return 1 ; }
function isVowel ( ch ) { if ( ch == "a" ch == "e" ch == "i" ch == "o" ch == "u" ) { return true ; } return false ; }
function countWords ( s , p , q ) { var countc = 0 , countv = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( isVowel ( s [ i ] ) ) countv ++ ; else countc ++ ; } var a = binomialCoeff ( countc , p ) ; var b = binomialCoeff ( countv , q ) ; var c = fact ( p + q ) ; var ans = ( a * b ) * c ; return ans ; }
function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function generateArr ( A , n ) { let B = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { let cnt = 0 ; for ( let j = 0 ; j < i ; j ++ ) { if ( A [ j ] % A [ i ] == 0 ) cnt ++ ; } B [ i ] = cnt ; } printArr ( B , n ) ; }
function count ( n ) { return Math . pow ( 2 , n - 1 ) ; }
function nextFibonacci ( n ) { let a = n * ( 1 + Math . sqrt ( 5 ) ) / 2.0 ; return Math . round ( a ) ; }
function product ( a , n ) { var ans = 1 ; var val = Math . pow ( 2 , n - 1 ) ; for ( var i = 0 ; i < n ; i ++ ) { ans *= Math . pow ( a [ i ] , val ) ; } return ans ; }
function max_distinct_char ( str , n ) { let count = new Array ( NO_OF_CHARS ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { count [ str [ i ] . charCodeAt ( 0 ) ] ++ ; } let max_distinct = 0 ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] != 0 ) { max_distinct ++ ; } } return max_distinct ; }
function smallesteSubstr_maxDistictChar ( str ) { let n = str . length ; let max_distinct = max_distinct_char ( str , n ) ; let minl = n ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { let subs = null ; if ( i < j ) subs = str . substring ( i , j ) ; else subs = str . substring ( j , i ) ; let subs_lenght = subs . length ; let sub_distinct_char = max_distinct_char ( subs , subs_lenght ) ; if ( subs_lenght < minl && max_distinct == sub_distinct_char ) { minl = subs_lenght ; } } } return minl ; }
function findPair ( arr , n ) { if ( n < 2 ) { document . write ( "-1" ) ; return ; } let i , first , second ; first = second = - 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { second = arr [ i ] ; } } document . write ( "n▁=▁" + first + "▁and▁r▁=▁" + second ) ; }
function sum ( arr , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * parseInt ( Math . pow ( 2 , n - 1 ) ) ; return sum ; }
function maxHeight ( n ) { return parseInt ( ( ( parseInt ( Math . sqrt ( 1 + 8.0 * n ) ) ) - 1 ) / 2 ) ; }
function ways ( n ) { return parseInt ( n / 2 ) ; }
function prevPowerof2 ( n ) { var p = parseInt ( Math . log ( n ) / Math . log ( 2 ) ) ; return parseInt ( Math . pow ( 2 , p ) ) ; }
function nextPowerOf2 ( n ) { var p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
function minDiff ( n ) { var low = prevPowerof2 ( n ) ; var high = nextPowerOf2 ( n ) ; return Math . min ( n - low , high - n ) ; }
function isPossible ( x , y , k ) { var minMoves = Math . abs ( x ) + Math . abs ( y ) ; if ( k >= minMoves && ( k - minMoves ) % 2 == 0 ) return true ; return false ; }
function countPairs ( arr , n ) { var map = { } ; for ( var i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] = 0 ; for ( var i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] ++ ; var res = 0 ; for ( const [ key , value ] of Object . entries ( map ) ) { var cnt = value ; res += ( cnt * ( cnt - 1 ) ) / 2 ; } return res ; }
function findMinValue ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( parseInt ( sum / n ) + 1 ) ; }
function isFactorion ( n ) { let fact = new Array ( MAX ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i < MAX ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; let org = n ; let sum = 0 ; while ( n > 0 ) { let d = n % 10 ; sum += fact [ d ] ; n = parseInt ( n / 10 ) ; } if ( sum == org ) return true ; return false ; }
function modFact ( n , m ) { let result = 1 ; for ( let i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; }
function minOperations ( n ) { var count = 0 ; var d = 0 ; if ( n == 1 ) return 0 ; while ( n > 9 ) { d = Math . max ( n % 10 , d ) ; n /= 10 ; count += 10 ; } d = Math . max ( d , n - 1 ) ; count += Math . abs ( d ) ; return count - 1 ; }
function maxCommonFactors ( a , b ) { let gcd = GCD ( a , b ) ; let ans = 1 ; for ( let i = 2 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { ans ++ ; while ( gcd % i == 0 ) gcd = parseInt ( gcd / i ) ; } } if ( gcd != 1 ) ans ++ ; return ans ; }
function updateFreq ( n , freq ) { while ( n ) { let digit = n % TEN ; freq [ digit ] ++ ; n = parseInt ( n / TEN ) ; } }
function areAnagrams ( a , b ) { let freqA = new Array ( TEN ) . fill ( 0 ) ; let freqB = new Array ( TEN ) . fill ( 0 ) ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( let i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; }
function dayOfYear ( date ) { var year = parseInt ( date . substring ( 0 , 4 ) ) ; var month = parseInt ( date . substring ( 5 , 6 ) ) ; var day = parseInt ( date . substring ( 8 ) ) ; if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 year % 400 == 0 ) ) { ++ day ; } while ( month -- > 0 ) { day = day + days [ month - 1 ] ; } return day ; }
function Max_Sum ( n ) { return parseInt ( ( n * ( n - 1 ) ) / 2 ) ; }
function convertToBinary ( num , a , n ) { let pointer = n - 1 ; while ( num > 0 ) { a [ pointer ] = num % 2 ; num = parseInt ( num / 2 ) ; pointer -- ; } }
function print_seq ( m ) { let n = ( 2 * m ) ; let a = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { a [ j ] = 0 ; } for ( let i = 0 ; i < Math . pow ( 2 , n ) ; i ++ ) { convertToBinary ( i , a , n ) ; checkforsum ( a , n ) ; } }
function isDivisible ( arr , n ) { let lastDigit = arr [ n - 1 ] % 10 ; if ( lastDigit == 0 ) return true ; return false ; }
function solve ( ang , n ) { if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) { return 0 ; } else if ( ( ang * n ) % 180 != 0 ) { return 0 ; } var ans = 1 ; var freq = ( ang * n ) / 180 ; ans = ans * ( n - 1 - freq ) ; ans = ans * n ; return ans ; }
function preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( let i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } }
function prime ( n ) { for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
function thirdNumber ( a , b ) { let sum = 0 , temp = 0 ; sum = a + b ; temp = 1 ; if ( ( sum & 1 ) != 0 ) { temp = 2 ; } while ( ! prime ( sum + temp ) ) { temp += 2 ; } document . write ( temp ) ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function divTermCount ( a , b , c , num ) { return parseInt ( ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( ( ( a * b ) / gcd ( a , b ) ) * c ) / gcd ( ( ( a * b ) / gcd ( a , b ) ) , c ) ) ) ) ) ; }
function findNthTerm ( a , b , c , n ) { var low = 1 , high = Number . MAX_SAFE_INTEGER , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , c , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; }
function nCr ( n , r ) { let ans = 1 ; for ( let i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function divTermCount ( a , b , c , num ) { return Math . ceil ( ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ) ; }
function calculate_angle ( n , i , j , k ) { var x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; var ang1 = ( 180 * x ) / n ; var ang2 = ( 180 * y ) / n ; var ans = 180 - ang1 - ang2 ; return ans ; }
function getIndex ( n , shuffle ) { for ( i = 0 ; i < 3 ; i ++ ) { if ( shuffle [ i ] [ 0 ] == n ) n = shuffle [ i ] [ 1 ] ; else if ( shuffle [ i ] [ 1 ] == n ) n = shuffle [ i ] [ 0 ] ; } document . write ( n ) ; }
function calculate ( n , k , m , power ) { if ( n > m ) { if ( power == 0 ) return 0 ; else return power - 1 ; } else if ( n == m ) return power ; else return calculate ( n * k , k , m , power + 1 ) ; }
function printNumber ( holes ) { if ( holes == 0 ) document . write ( "1" ) ; else if ( holes == 1 ) document . write ( "0" ) ; else { let rem = 0 , quo = 0 ; rem = holes % 2 ; quo = parseInt ( holes / 2 , 10 ) ; if ( rem == 1 ) document . write ( "4" ) ; for ( let i = 0 ; i < quo ; i ++ ) document . write ( "8" ) ; } }
function power ( p ) { let res = 1 ; for ( let i = 1 ; i <= p ; ++ i ) { res *= 2 ; res %= mod ; } return res % mod ; }
function subset_square_sum ( A ) { let n = A . length ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { ans += ( A [ i ] * A [ i ] ) % mod ; ans %= mod ; } return ( ans * power ( n - 1 ) ) % mod ; }
function fact ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
function nCr ( n , r ) { return fact ( n ) / ( 1 * fact ( r ) * fact ( n - r ) ) ; }
function number_of_subsequences ( arr , k , n ) { let s = 0 ; let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } for ( let [ key , value ] of mp . entries ( ) ) { s = s + 1 * nCr ( value , k ) ; } return s ; }
function minCost ( arr , n ) { var count_even = 0 ; var count_odd = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return Math . min ( count_even , count_odd ) ; }
function coprime ( a , b ) { if ( __gcd ( a , b ) == 1 ) return true ; else return false ; }
function findNumbers ( a , b , n ) { let possible = true ; if ( ! coprime ( a , b ) ) possible = false ; let c1 = 1 ; let c2 = 1 ; let num1 , num2 ; let st = new Set ( ) ; if ( possible ) { while ( st . size != n ) { num1 = a + ( c1 * b ) ; if ( isPrime ( num1 ) ) { st . add ( num1 ) ; } c1 ++ ; num2 = b + ( c2 * a ) ; if ( isPrime ( num2 ) ) { st . add ( num2 ) ; } c2 ++ ; } st = [ ... st ] . sort ( ( a , b ) => a - b )  for ( let i of st ) document . write ( i + "▁" ) ; } else document . write ( "-1" ) ; }
function sumPairs ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; }
function minSum ( arr , n ) { let sum = 0 ; arr . sort ( function ( a , b ) { return b - a } ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; }
function getCount ( A , B2 , C ) { let count = 0 ; for ( let i = 1 ; i <= A ; i ++ ) { let j = parseInt ( B2 / i ) + 1 ; if ( C >= j ) count = ( count + C - j + 1 ) ; if ( A >= j && C >= i ) count = ( count + ( C - i + 1 ) * ( A - j + 1 ) ) ; if ( A >= j ) A = j - 1 ; } return count ; }
function negProdSubArr ( arr , n ) { let positive = 1 , negative = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
function posProdSubArr ( arr , n ) { let total = parseInt ( ( n * ( n + 1 ) ) / 2 ) ; let cntNeg = negProdSubArr ( arr , n ) ; return ( total - cntNeg ) ; }
function distinctRemainders ( n ) { if ( n % 2 == 0 ) return parseInt ( n / 2 ) ; return ( 1 + parseInt ( n / 2 ) ) ; }
function countUnsetBits ( n ) { var cnt = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { var temp = i ; while ( temp ) { if ( temp % 2 == 0 ) cnt ++ ; temp = parseInt ( temp / 2 ) ; } } return cnt ; }
function least_prime_factor ( ) { for ( i = 2 ; i < N ; i ++ ) if ( lpf [ i ] == 0 ) for ( j = i ; j < N ; j += i ) if ( lpf [ j ] == 0 ) lpf [ j ] = i ; }
function Mobius ( ) { for ( i = 1 ; i < N ; i ++ ) { if ( i == 1 ) mobius [ i ] = 1 ; else { if ( lpf [ i / lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ; else mobius [ i ] = - 1 * mobius [ i / lpf [ i ] ] ; } } }
function gcd_pairs ( a , n ) { var maxi = 0 ; var fre = Array ( n + 1 ) . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { fre [ a [ i ] ] ++ ; maxi = Math . max ( a [ i ] , maxi ) ; } least_prime_factor ( ) ; Mobius ( ) ; var ans = 0 ; for ( i = 1 ; i <= maxi ; i ++ ) { if ( mobius [ i ] == 0 ) continue ; var temp = 0 ; for ( j = i ; j <= maxi ; j += i ) temp = parseInt ( temp + fre [ j ] ) ; ans += parseInt ( temp * ( temp - 1 ) / 2 * mobius [ i ] ) ; } return ans ; }
function SieveOfEratosthenes ( ) { let i ; for ( i = 0 ; i < MAX + 1 ; i ++ ) { prime [ i ] = true ; } prime [ 1 ] = false ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
function xorFirstNPrime ( n ) { let count = 0 , num = 1 ; let xorVal = 0 ; while ( count < n ) { if ( prime [ num ] ) { xorVal ^= num ; count ++ ; } num ++ ; } return xorVal ; }
function negProdSubArr ( arr , n ) { let positive = 1 , negative = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
function sum ( n ) { var sum = ( n * ( n + 1 ) ) / 2 ; return sum ; }
function repeatedSum ( n , k ) { for ( i = 0 ; i < k ; i ++ ) { n = sum ( n ) ; } return n ; }
function isDivisible ( n ) { var temp = n ; var sum = 0 ; while ( n != 0 ) { var digit = parseInt ( n % 10 ) ; sum += digit ; n = parseInt ( n / 10 ) ; } n = temp ; while ( n != 0 ) { var digit = parseInt ( n % 10 ) ; if ( sum % digit != 0 ) return false ; n = parseInt ( n / 10 ) ; } return true ; }
function least_prime_factor ( ) { for ( let i = 2 ; i < N ; i ++ ) if ( ! lpf [ i ] ) for ( let j = i ; j < N ; j += i ) if ( ! lpf [ j ] ) lpf [ j ] = i ; }
function Mobius ( n ) { let mobius = new Array ( N ) ; for ( let i = 1 ; i < N ; i ++ ) { if ( i == 1 ) mobius [ i ] = 1 ; else { if ( lpf [ parseInt ( i / lpf [ i ] ) ] == lpf [ i ] ) mobius [ i ] = 0 ; else mobius [ i ] = - 1 * mobius [ parseInt ( i / lpf [ i ] ) ] ; } } for ( let i = 1 ; i <= n ; i ++ ) document . write ( mobius [ i ] + "▁" ) ; }
function getBest ( prev , cur ) { var maximum = Math . max ( MIN , prev ) ; for ( var i = maximum ; i <= MAX ; i ++ ) { var cnt = 0 ; var a = i ; var b = cur ; for ( var k = 0 ; k < DIGITS ; k ++ ) { if ( a % 10 != b % 10 ) cnt += 1 ; a = parseInt ( a / 10 ) ; b = parseInt ( b / 10 ) ; } if ( cnt <= 1 ) return i ; } return - 1 ; }
function getList ( arr , n ) { var myList = [ ] ; var i , cur ; var possible = true ; myList . push ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { cur = arr [ i ] ; myList . push ( getBest ( myList [ myList . length - 1 ] , cur ) ) ; if ( myList [ myList . length - 1 ] == - 1 ) { possible = false ; break ; } } if ( possible ) { for ( i = 1 ; i < myList . length ; i ++ ) document . write ( myList [ i ] + "▁" ) ; } else document . write ( "-1" ) ; }
function maxItems ( x , y , z ) { let type1 = parseInt ( x / COST ) ; x %= COST ; let type2 = parseInt ( y / COST ) ; y %= COST ; let type3 = parseInt ( z / COST ) ; z %= COST ; let type4 = Math . min ( x , Math . min ( y , z ) ) ; let maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }
function countFactors ( n , p ) { let pwr = 0 ; while ( n > 0 && n % p == 0 ) { n /= p ; pwr ++ ; } return pwr ; }
function getCount ( l , r , p ) { let cnt = 0 ; for ( let i = l ; i <= r ; i ++ ) { cnt += countFactors ( i , p ) ; } return cnt ; }
function topsyTurvy ( str ) { for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == "2" str [ i ] == "4" str [ i ] == "5" str [ i ] == "6" str [ i ] == "7" str [ i ] == "9" ) { return false ; } } return true ; }
function countSubSeq ( arr , n , k ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { count ++ ; } } return ( Math . pow ( 2 , count ) - 1 ) ; }
function countNum ( N , K ) { let sumPF = new Array ( MAX ) . fill ( 0 ) ; for ( let i = 2 ; i < N ; i ++ ) { if ( sumPF [ i ] == 0 ) { for ( let j = i ; j < N ; j += i ) { sumPF [ j ] += i ; } } } let count = 0 ; for ( let i = 2 ; i < N ; i ++ ) { if ( sumPF [ i ] == K ) count ++ ; } return count ; }
function SieveOfEratosthenes ( ) { for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
function smallestPrime ( d ) { let l = Math . pow ( 10 , d - 1 ) ; let r = Math . pow ( 10 , d ) - 1 ; for ( let i = l ; i <= r ; i ++ ) { if ( prime [ i ] ) { return i ; } } return - 1 ; }
function largestPrime ( d ) { let l = Math . pow ( 10 , d - 1 ) ; let r = Math . pow ( 10 , d ) - 1 ; for ( let i = r ; i >= l ; i -- ) { if ( prime [ i ] ) { return i ; } } return - 1 ; }
function findNumbers ( a , b ) { var gcd = findGCD ( a , b ) ; document . write ( ( a / gcd ) + "▁" + ( b / gcd ) ) ; }
function possible ( n ) { if ( n > 3 ) { let sum = parseInt ( ( n * ( n + 1 ) ) / 2 ) ; if ( sum % 3 == 0 ) { return true ; } } return false ; }
function findNthNumber ( A , B , N ) { var sum = 0 ; for ( i = 2 ; i < N ; i ++ ) { sum = A + B ; A = B ; B = sum ; } return sum ; }
function modulo ( num ) { let res = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) res = ( res * 10 + num [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ) % mod ; return res ; }
function findSum ( L , R ) { let a , b , l , r , ret ; a = modulo ( L ) ; b = modulo ( R ) ; l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod ; r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod ; ret = ( r % mod - l % mod ) ; if ( ret < 0 ) ret = ret + mod ; else ret = ret % mod - 6 ; return ret ; }
function heapSort ( arr , n ) { for ( var i = parseInt ( n / 2 - 1 ) ; i >= 0 ; i -- ) heapify ( arr , n , i ) ; for ( var i = n - 1 ; i >= 0 ; i -- ) { [ arr [ 0 ] , arr [ i ] ] = [ arr [ i ] , arr [ 0 ] ] heapify ( arr , i , 0 ) ; } }
function checkType ( arr , n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) document . write ( "Increasing" ) ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) document . write ( "Decreasing" ) ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) document . write ( "Increasing▁then▁decreasing" ) ; else document . write ( "Decreasing▁then▁increasing" ) ; }
function cal_IST ( h , r ) { let IST = ( h * r * 1.0 ) / 360 ; let int_IST = parseInt ( IST ) ; let float_IST = Math . ceil ( parseInt ( ( IST - int_IST ) * 60 ) ) ; document . write ( int_IST + ":" + float_IST ) ; }
function isPossible ( arr , p , n , m ) { var sum = 0 ; for ( var i = 0 ; i < p ; i ++ ) sum += arr [ i ] ; if ( sum == ( n * m ) ) return true ; return false ; }
function maxSubArraySum ( a , n , k , i ) { let max_so_far = Number . MIN_VALUE , max_ending_here = 0 ; while ( i < n ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; i += k ; } return max_so_far ; }
function find ( arr , n , k ) { let maxSum = 0 ; for ( let i = 0 ; i <= Math . min ( n , k ) ; i ++ ) { let sum = 0 ; maxSum = Math . max ( maxSum , maxSubArraySum ( arr , n , k , i ) ) ; } return maxSum ; }
function SieveOfEratosthenes ( ) { prime [ 1 ] = false ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
function solve ( n ) { let count = 0 ; for ( let i = 3 ; count < n ; i ++ ) { if ( prime [ i ] ) { document . write ( i + "▁" ) ; count ++ ; } } }
function sum ( n ) { var sum = 0 ; while ( n > 0 ) { sum = sum + n % 10 ; n = parseInt ( n / 10 ) ; } return sum ; }
function firstN ( n ) { var num = 19 , cnt = 1 ; while ( cnt != n ) { if ( sum ( num ) == 10 ) { document . write ( num + "▁" ) ; cnt ++ ; } num += 9 ; } }
function compareVal ( x , y ) { let a = y * Math . log ( x ) ; let b = x * Math . log ( y ) ; if ( a > b ) document . write ( x + "^" + y + "▁>▁" + y + "^" + x ) ; else if ( a < b ) document . write ( x + "^" + y + "▁<▁" + y + "^" + x ) ; else if ( a == b ) document . write ( x + "^" + y + "▁=▁" + y + "^" + x ) ; }
function countWays ( n ) { var ans = 1 ; for ( i = 0 ; i < n ; i ++ ) { ans *= 2 ; ans %= MOD ; } return ( ( ans - 1 + MOD ) % MOD ) ; }
function findIntegers ( n , a , x , t1 , t2 ) { let flag = true ; for ( let i = 0 ; i < n ; i ++ ) { let temp = Math . pow ( a [ i ] , 2 ) + x ; if ( temp % 10 != t1 && temp % 10 != t2 ) { document . write ( temp + "▁" ) ; flag = false ; } } if ( flag ) document . write ( "-1" ) ; }
function findMin ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; arr . sort ( ) ; let min = arr [ 0 ] ; let max = 0 ; for ( let i = n - 1 ; i >= 1 ; i -- ) { let num = arr [ i ] ; let total = num + min ; let j ; for ( j = 2 ; j <= num ; j ++ ) { if ( num % j == 0 ) { let d = j ; let now = parseInt ( num / d ) + ( min * d ) ; let reduce = total - now ; if ( reduce > max ) max = reduce ; } } } document . write ( sum - max ) ; }
function Survives ( n ) { let i ; for ( let i = 2 ; ; i ++ ) { if ( i > n ) return true ; if ( n % i == 0 ) return false ; n -= parseInt ( n / i ) ; } }
function digitSum ( n ) { let sum = 0 ; while ( n > 0 ) { sum += n % TEN ; n = Math . floor ( n / TEN ) ; } return sum ; }
function getNthTerm ( n ) { let sum = digitSum ( n ) ; if ( sum % TEN == 0 ) return ( n * TEN ) ; let extra = TEN - ( sum % TEN ) ; return ( ( n * TEN ) + extra ) ; }
function firstNTerms ( n ) { for ( let i = 1 ; i <= n ; i ++ ) document . write ( getNthTerm ( i ) + "▁" ) ; }
function nthXorFib ( n , a , b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return ( a ^ b ) ; return nthXorFib ( n % 3 , a , b ) ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function flip ( a , b ) { let lcm = parseInt ( ( a * b ) / gcd ( a , b ) ) ; a = parseInt ( lcm / a ) ; b = parseInt ( lcm / b ) ; document . write ( ( a - 1 ) + "▁" + ( b - 1 ) ) ; }
function findRemainder ( n ) { let l = n % 10 ; while ( n >= 10 ) n /= 10 ; let f = n ; let remainder = f % l ; document . write ( Math . floor ( remainder ) ) ; }
function increaseInVol ( l , b , h ) { let percentInc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ; percentInc -= 1 ; percentInc *= 100 ; return percentInc ; }
function countOccurrances ( n , d ) { let count = 0 ; while ( n > 0 ) { count = ( n % 10 == d ) ? count + 1 : count ; n = parseInt ( n / 10 ) ; } return count ; }
function findFactors ( a , b ) { let c ; c = a + b - 1 ; document . write ( c ) ; }
function countKdivPairs ( A , n , K ) { var freq = Array ( K ) . fill ( 0 ) ; var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var rem = A [ i ] % K ; ans += freq [ ( K - rem ) % K ] ; freq [ rem ] ++ ; } return ans ; }
function expressDigit ( arr , n ) { var min = 9 , index = 0 , temp = 0 ; temp = arr [ 0 ] ; for ( i = 1 ; i < 10 ; i ++ ) { if ( arr [ i ] < min ) { min = arr [ i ] ; index = i ; } } if ( temp < min ) { document . write ( 1 ) ; for ( i = 1 ; i <= temp + 1 ; i ++ ) document . write ( 0 ) ; } else { for ( i = 0 ; i < min ; i ++ ) document . write ( index ) ; document . write ( index ) ; } }
function countDigits ( num ) { var cnt = 0 ; while ( num > 0 ) { cnt ++ ; num = parseInt ( num / 10 ) ; } return cnt ; }
function sumFromStart ( num , n , rem ) { num = ( parseInt ( num / Math . pow ( 10 , rem ) ) ) ; var sum = 0 ; while ( num > 0 ) { sum += ( num % 10 ) ; num = parseInt ( num / 10 ) ; } return sum ; }
function sumFromEnd ( num , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += ( num % 10 ) ; num = parseInt ( num / 10 ) ; } return sum ; }
function getAverage ( n , k , l ) { var totalDigits = countDigits ( n ) ; if ( totalDigits < ( k + l ) ) return - 1 ; var sum1 = sumFromEnd ( n , l ) ; var sum2 = sumFromStart ( n , k , totalDigits - k ) ; return ( ( sum1 + sum2 ) / ( k + l ) ) ; }
function totalways ( arr , n ) { var cnt = { } ; for ( var i = 0 ; i < n ; i ++ ) { if ( cnt . hasOwnProperty ( arr [ i ] ) ) { cnt [ arr [ i ] ] = cnt [ arr [ i ] ] + 1 ; } else { cnt [ arr [ i ] ] = 1 ; } } if ( n % 2 === 1 ) { var start = 0 , endd = n - 1 ; for ( var i = start ; i <= endd ; i = i + 2 ) { if ( i === 0 ) { if ( cnt [ i ] !== 1 ) { return 0 ; } } else { if ( cnt [ i ] !== 2 ) { return 0 ; } } } var ways = 1 ; start = 2 ; endd = n - 1 ; for ( var i = start ; i <= endd ; i = i + 2 ) { ways = ways * 2 ; } return ways ; } else if ( n % 2 === 0 ) { var start = 1 , endd = n - 1 ; for ( var i = 1 ; i <= endd ; i = i + 2 ) { if ( cnt [ i ] !== 2 ) return 0 ; } var ways = 1 ; for ( var i = start ; i <= endd ; i = i + 2 ) { ways = ways * 2 ; } return ways ; } return - 2147483648 ; }
function proizvolov ( a , b , n ) { return n * n ; }
function compareValues ( a , b , c , d ) { let log1 = Math . log ( a ) / Math . log ( 10 ) ; let num1 = log1 * b ; let log2 = Math . log ( c ) / Math . log ( 10 ) ; let num2 = log2 * d ; if ( num1 > num2 ) document . write ( a + "^" + b ) ; else document . write ( c + "^" + d ) ; }
function sum ( a , b , c , d , x ) { var ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; }
function calculateLnx ( n ) { let num , mul , cal , sum = 0 ; num = ( n - 1 ) / ( n + 1 ) ; for ( let i = 1 ; i <= 1000 ; i ++ ) { mul = ( 2 * i ) - 1 ; cal = Math . pow ( num , mul ) ; cal = cal / mul ; sum = sum + cal ; } sum = 2 * sum ; return sum ; }
function calculateLogx ( lnx ) { return ( lnx / 2.303 ) ; }
function printRoots ( a , b , c ) { document . write ( 1 + ",▁" + c / ( a * 1.0 ) ) ; }
function permutation ( str1 , i , n , p ) { if ( i == n ) { let q = parseInt ( str1 ) ; if ( q - p > 0 && q < min1 ) { min1 = q ; count = 1 ; } } else { for ( let j = i ; j <= n ; j ++ ) { str1 = swap ( str1 , i , j ) ; permutation ( str1 , i + 1 , n , p ) ; str1 = swap ( str1 , i , j ) ; } } return min1 ; }
function longestAlternativeSequence ( a , n ) { let maxi1 = 0 ; let f1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! f1 ) { if ( a [ i ] % 2 ) { f1 = 1 ; maxi1 ++ ; } } else { if ( a [ i ] % 2 == 0 ) { maxi1 ++ ; f1 = 0 ; } } } let maxi2 = 0 ; let f2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( f2 ) { if ( a [ i ] % 2 ) { f2 = 1 ; maxi2 ++ ; } } else { if ( a [ i ] % 2 == 0 ) { maxi2 ++ ; f2 = 0 ; } } } return Math . max ( maxi1 , maxi2 ) ; }
function Cells ( n , x ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && parseInt ( x / i ) <= n ) ans ++ ; return ans ; }
function Cells ( n , x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; var i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; }
function ZigZag ( n ) { var fact = Array ( n + 1 ) . fill ( 0 ) ; var zig = Array ( n + 1 ) . fill ( 0 ) ; fact [ 0 ] = 1 ; for ( var i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; zig [ 0 ] = 1 ; zig [ 1 ] = 1 ; document . write ( "zig▁zag▁numbers:▁" ) ; document . write ( zig [ 0 ] + "▁" + zig [ 1 ] + "▁" ) ; for ( var i = 2 ; i < n ; i ++ ) { var sum = 0 ; for ( var k = 0 ; k <= i - 1 ; k ++ ) { sum += parseInt ( fact [ i - 1 ] / ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ; } zig [ i ] = parseInt ( sum / 2 ) ; document . write ( parseInt ( sum / 2 ) + "▁" ) ; } }
function evenNumSubstring ( str ) { let len = str . length ; let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let temp = str [ i ] - "0" ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
function Depreciation ( v , r , t ) { var D = v * Math . pow ( ( 1 - r / 100 ) , t )  return D ; }
function nextPowerOfFour ( n ) { let x = Math . floor ( Math . sqrt ( Math . sqrt ( n ) ) ) ; if ( Math . pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return Math . pow ( x , 4 ) ; } }
function Alcuin ( n ) { let _n = n , ans ; ans = Math . round ( ( _n * _n ) / 12 ) - Math . floor ( _n / 4 ) * Math . floor ( ( _n + 2 ) / 4 ) ; return ans ; }
function solve ( n ) { let i = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { document . write ( Alcuin ( i ) + ",▁" ) ; } }
function find_count ( ele ) { let count = 0 ; for ( let i = 0 ; i < ele . length ; i ++ ) { let p = [ ] ; let c = 0 ; for ( let j = ele . length - 1 ; j >= ( ele . length - 1 - i ) && j >= 0 ; j -- ) p . push ( ele [ j ] ) ; let j = ele . length - 1 , k = 0 ; while ( j >= 0 ) { if ( ele [ j ] != p [ k ] ) break ; j -- ; k ++ ; if ( k == p . length ) { c ++ ; k = 0 ; } } count = Math . max ( count , c ) ; } return count ; }
function solve ( n ) { let count = 1 ; let ele = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { document . write ( count + ",▁" ) ; ele . push ( count ) ; count = find_count ( ele ) ; } }
function speedOfTrain ( X , Y ) { var Speed ; Speed = 1188 * ( ( X - Y ) / Y ) ; return Speed ; }
function Division ( a , n ) { let maxi = Number . MIN_VALUE , mini = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { maxi = Math . max ( a [ i ] , maxi ) ; mini = Math . min ( a [ i ] , mini ) ; } return parseInt ( maxi / mini ) ; }
function addPrimes ( ) { let n = MAX ; let prime = new Array ( n + 1 ) . fill ( true ) ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } let ans = [ ] ; for ( let p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . push ( p ) ; return ans ; }
function find_Sum ( n ) { let sum = 0 ; let v = addPrimes ( ) ; for ( let i = 0 ; i < v . length && n > 0 ; i ++ ) { let flag = 1 ; let a = v [ i ] ; while ( a != 0 ) { let d = a % 10 ; a = parseInt ( a / 10 ) ; if ( is_prime ( d ) ) { flag = 0 ; break ; } } if ( flag == 1 ) { n -- ; sum = sum + v [ i ] ; } } return sum ; }
function addPrimes ( ) { let n = MAX ; let prime = new Array ( n + 1 ) . fill ( true ) ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } let ans = [ ] ; for ( let p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . push ( p ) ; return ans ; }
function pi ( x , v ) { let l = 0 , r = v . length - 1 , m , inn = - 1 ; while ( l <= r ) { m = parseInt ( ( l + r ) / 2 ) ; if ( v [ m ] <= x ) { inn = m ; l = m + 1 ; } else { r = m - 1 ; } } return inn + 1 ; }
function Ramanujan ( n , v ) { let upperbound = 4 * n * parseInt ( ( Math . log ( 4 * n ) / Math . log ( 2 ) ) ) ; for ( let i = upperbound ; ; i -- ) { if ( pi ( i , v ) - pi ( parseInt ( i / 2 ) , v ) < n ) return 1 + i ; } }
function Ramanujan_Numbers ( n ) { let c = 1 ; let v = addPrimes ( ) ; for ( let i = 1 ; i <= n ; i ++ ) { document . write ( Ramanujan ( i , v ) ) ; if ( i != n ) document . write ( ",▁" ) ; } }
function solveEven ( n , arr , b ) { let left = n - 1 ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; ++ i ) { b [ i ] = arr [ left ] ; left = left - 2 ; if ( left < 0 ) break ; } let right = 0 ; for ( let i = parseInt ( n / 2 , 10 ) ; i <= n - 1 ; ++ i ) { b [ i ] = arr [ right ] ; right = right + 2 ; if ( right > n - 2 ) break ; } }
function solve ( n , arr ) { let b = new Array ( n ) ; if ( n % 2 == 0 ) solveEven ( n , arr , b ) ; else solveOdd ( n , arr , b ) ; for ( let i = 0 ; i <= n - 1 ; ++ i ) { document . write ( b [ i ] + "▁" ) ; } }
function fact ( n ) { var res = 1 ; for ( var i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
function nCr ( n , r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
function NumberOfWays ( X , Y , M , N ) { return fact ( X + Y ) * nCr ( M , X ) * nCr ( N , Y ) ; }
function Wedderburn ( n ) { if ( n <= 2 ) return store [ n ] ; else if ( n % 2 == 0 ) { var x = parseInt ( n / 2 ) , ans = 0 ; for ( var i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } ans += ( store [ x ] * ( store [ x ] + 1 ) ) / 2 ; store [ n ] = ans ; return ans ; } else { var x = ( n + 1 ) / 2 , ans = 0 ; for ( var i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } store [ n ] = ans ; return ans ; } }
function Wedderburn_Etherington ( n ) { store [ 0 ] = 0 ; store [ 1 ] = 1 ; store [ 2 ] = 1 ; for ( var i = 0 ; i < n ; i ++ ) { document . write ( Wedderburn ( i ) ) ; if ( i != n - 1 ) document . write ( "▁" ) ; } }
function factorial ( n ) { if ( n <= 1 ) return 1 ; return n * factorial ( n - 1 ) ; }
function nCr ( n , r ) { return factorial ( n ) / ( factorial ( n - r ) * factorial ( r ) ) ; }
function NumberOfWays ( n , x , y ) { return nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) ; }
function fact ( n ) { let i = 1 , fac = 1 ; for ( i = 1 ; i <= n ; i ++ ) fac = fac * i ; return fac ; }
function log_Expansion ( x , n ) { let sum = 0 ; let i = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum = sum + Math . pow ( x , 2 * i ) / fact ( 2 * i ) ; } return sum ; }
function prime_range ( start , end , a ) { for ( let i = start ; i < end ; i ++ ) { if ( prime ( a [ i ] ) ) document . write ( a [ i ] + "▁" ) ; } }
function countElements ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; let mean = sum / n ; let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let newMean = ( sum - arr [ i ] ) / ( n - 1 ) ; if ( newMean == mean ) cnt ++ ; } return cnt ; }
function Prime ( n ) { for ( let j = 2 ; j <= Math . sqrt ( n ) ; j ++ ) if ( n % j == 0 ) return false ; return true ; }
function find_prime ( x , xsqmodp , y , ysqmodp ) { let n = x * x - xsqmodp ; let n1 = y * y - ysqmodp ; for ( let j = 2 ; j <= Math . max ( Math . sqrt ( n ) , Math . sqrt ( n1 ) ) ; j ++ ) { if ( n % j == 0 && ( x * x ) % j == xsqmodp && n1 % j == 0 && ( y * y ) % j == ysqmodp ) if ( Prime ( j ) ) return j ; let j1 = parseInt ( n / j ) ; if ( n % j1 == 0 && ( x * x ) % j1 == xsqmodp && n1 % j1 == 0 && ( y * y ) % j1 == ysqmodp ) if ( Prime ( j1 ) ) return j1 ; j1 = n1 / j ; if ( n % j1 == 0 && ( x * x ) % j1 == xsqmodp && n1 % j1 == 0 && ( y * y ) % j1 == ysqmodp ) if ( Prime ( j1 ) ) return j1 ; } if ( n == n1 ) return n ; }
function numberOfMinutes ( S , S1 ) { let Min = 0 ; Min = ( ( S - S1 ) / Math . floor ( S ) ) * 60 ; return Min ; }
function FindElement ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + a [ i ] ; if ( sum % n == 0 ) { let m = parseInt ( sum / n ) ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] == m ) return m ; } return - 1 ; }
function fac ( num ) { if ( num == 0 ) return 1 ; let fact = 1 ; for ( let i = 1 ; i <= num ; i ++ ) fact = fact * i ; return fact ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function Max_sum ( a , n ) { let pos = 0 , neg = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) pos = 1 ; else if ( a [ i ] < 0 ) neg = 1 ; if ( pos == 1 && neg == 1 ) break ; } let sum = 0 ; if ( pos == 1 && neg == 1 ) { for ( let i = 0 ; i < n ; i ++ ) sum += Math . abs ( a [ i ] ) ; } else if ( pos == 1 ) { let mini = a [ 0 ] ; sum = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } else if ( neg == 1 ) { for ( let i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; let mini = a [ 0 ] ; sum = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } return sum ; }
function checkcomposite ( n ) { for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return 1 ; } return 0 ; }
function power ( x , y , mod ) { let res = 1 ; while ( y ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
function Check ( n , a ) { if ( a > 1 && checkcomposite ( n ) && power ( a , n - 1 , n ) == 1 ) return 1 ; return 0 ; }
function count ( arr , n , k ) { arr . sort ( ) ; var cnt = 0 ; var i = 0 ; var j = 1 ; while ( i < n && j < n ) { if ( j <= i ) j = i + 1 else j = j while ( j < n && ( arr [ j ] - arr [ i ] ) < k ) j += 1 ; cnt += ( n - j ) ; i += 1 ; } return cnt ; }
function factorial ( n ) { if ( n <= 1 ) return 1 ; return n * factorial ( n - 1 ) ; }
function nCr ( n , r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
function Probability ( M , N , X ) { return parseFloat ( nCr ( M - N - 1 , X - 2 ) / ( nCr ( M - 1 , X - 1 ) * 1.0 ) ) ; }
function fact ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
function Count_number ( N ) { return ( N * fact ( N ) ) ; }
function fact ( n ) { if ( n <= 1 ) return 1 ; return n * fact ( n - 1 ) ; }
function nPr ( n , r ) { return fact ( n ) / fact ( n - r ) ; }
function decimalToBinary ( n ) { if ( n == 0 ) { document . write ( "0" ) ; return ; } decimalToBinary ( parseInt ( n / 2 ) ) ; document . write ( n % 2 ) ; }
function MinimumValue ( x , y ) { if ( x > y ) { var temp = x ; x = y ; y = temp ; } var a = 1 ; var b = x - 1 ; var c = y - b ; document . write ( a + "▁" + b + "▁" + c ) ; }
function getHeight ( X ) { return ( 2 * X ) ; }
function volumeRec ( a , b , e , h ) { return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; }
function firstSetBit ( n ) { let x = n & ( n - 1 ) ; return ( n ^ x ) ; }
function NoofSequences ( N , M ) { let prime = new Map ( ) ; for ( let i = 2 ; i <= Math . sqrt ( M ) ; i ++ ) { while ( M % i == 0 ) { if ( prime . get ( i ) == null ) prime . set ( i , 1 ) ; else { let x = prime . get ( i ) ; prime . set ( i , ++ x ) ; } M = Math . floor ( M / i ) ; } } if ( M > 1 ) { if ( prime . get ( M ) != null ) { let x = prime . get ( M ) ; prime . set ( M , ++ x ) ; } else prime . set ( M , 1 ) ; } let ans = 1 ; for ( let [ key , value ] of prime . entries ( ) ) { ans *= ( nCr ( N + value - 1 , N - 1 ) ) ; } return ans ; }
function findHours ( a , b , k ) { if ( a >= b ) return - 1 ; let time = k / ( b - a ) ; time = time + 1 ; return time ; }
function countQuadruples ( N , K ) { let M = parseInt ( N / K ) ; let answer = nCr ( M ) ; for ( let i = 2 ; i < M ; i ++ ) { let j = i ; let temp2 = parseInt ( M / i ) ; let count = 0 ; let check = 0 ; let temp = j ; while ( j % 2 == 0 ) { count ++ ; j = parseInt ( j / 2 ) ; if ( count >= 2 ) break ; } if ( count >= 2 ) { check = 1 ; } for ( let k = 3 ; k <= Math . sqrt ( temp ) ; k += 2 ) { let cnt = 0 ; while ( j % k == 0 ) { cnt ++ ; j = parseInt ( j / k ) ; if ( cnt >= 2 ) break ; } if ( cnt >= 2 ) { check = 1 ; break ; } else if ( cnt == 1 ) count ++ ; } if ( j > 2 ) { count ++ ; } if ( check ) continue ; else { if ( count % 2 == 1 ) { answer -= nCr ( temp2 ) ; } else { answer += nCr ( temp2 ) ; } } } return answer ; }
function minimum_sum ( n , k ) { if ( k % n == 0 ) return 0 ; return 1 ; }
function ncr ( n , r ) { let ans = 1 ; for ( let i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans = parseInt ( ans / i ) ; } return ans ; }
function NoOfDistributions ( N , R ) { return ncr ( N - 1 , R - 1 ) ; }
function ncr ( n , r ) { let ans = 1 ; for ( let i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans = parseInt ( ans / i ) ; } return ans ; }
function NoOfDistributions ( N , R ) { return ncr ( N + R - 1 , R - 1 ) ; }
function maxElement ( a , n ) { if ( n < 3 ) return - 1 ; let maxElement = a [ 0 ] ; let maxProd = a [ n - 1 ] * a [ 1 ] ; for ( let i = 1 ; i < n ; i ++ ) { let currProd = a [ i - 1 ] * a [ ( i + 1 ) % n ] ; if ( currProd > maxProd ) { maxProd = currProd ; maxElement = a [ i ] ; } else if ( currProd == maxProd ) { maxElement = Math . max ( maxElement , a [ i ] ) ; } } return maxElement ; }
function totalWays ( X , Y , M , W ) { return ( ncr ( M , X ) * ncr ( W , Y ) ) ; }
function checkPerfectcube ( n ) { let d = parseInt ( Math . cbrt ( n ) ) ; if ( d * d * d == n ) return true ; return false ; }
function smallestPerfectCube ( a , n ) { let mini = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( checkPerfectcube ( a [ i ] ) ) { mini = Math . min ( a [ i ] , mini ) ; } } return mini ; }
function Vertices ( x , y ) { let val = Math . abs ( x ) + Math . abs ( y ) ; document . write ( val * ( x < 0 ? - 1 : 1 ) + "▁0▁" ) ; document . write ( "0▁" + val * ( y < 0 ? - 1 : 1 ) ) ; }
function SumofInverseDivisors ( N , Sum ) { let ans = ( Sum ) * 1.0 / ( N ) ; return ans ; }
function CheckSubarray ( arr , N ) { let presum = new Array ( N + 1 ) . fill ( 0 ) ; for ( let i = 1 ; i <= N ; i += 1 ) { presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] ; } for ( let i = 1 ; i <= N ; i += 1 ) { for ( let j = i ; j <= N ; j += 1 ) { if ( ( presum [ j ] - presum [ i - 1 ] ) % N == 0 ) { document . write ( ( i - 1 ) + "▁" + ( j - 1 ) ) ; return ; } } } document . write ( - 1 ) ; }
function CheckSubarray ( arr , N ) { let presum = new Array ( N + 1 ) ; for ( let i = 0 ; i < ( N + 1 ) ; i ++ ) presum [ i ] = 0 ; for ( let i = 1 ; i <= N ; i += 1 ) { presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] ; } let moduloclass = new Array ( N ) ; for ( let i = 0 ; i < N ; i += 1 ) { moduloclass [ i ] = [ ] ; } for ( let i = 1 ; i <= N ; i += 1 ) { moduloclass [ presum [ i ] % N ] . push ( i - 1 ) ; } if ( moduloclass [ 0 ] . length > 0 ) { document . write ( 0 + "▁" + moduloclass [ 0 ] [ 0 ] ) ; return ; } for ( let i = 1 ; i < N ; i += 1 ) { if ( moduloclass [ i ] . length >= 2 ) { document . write ( moduloclass [ i ] [ 0 ] + 1 + "▁" + moduloclass [ i ] [ 1 ] ) ; return ; } } }
function findNearestNumber ( n ) { let cnt = countBits ( n ) ; cnt -= 1 ; if ( cnt % 2 ) { return 1 << ( cnt + 1 ) ; } else { let tempnum = 0 ; for ( let i = 0 ; i <= cnt ; i += 2 ) tempnum += 1 << i ; if ( tempnum < n ) { return ( 1 << ( cnt + 2 ) ) ; } else if ( tempnum == n ) return n ; for ( let i = 0 ; i <= cnt ; i += 2 ) { tempnum -= ( 1 << i ) ; if ( tempnum < n ) return tempnum += ( 1 << i ) ; } } }
function getX ( a , b , c , d ) { var X = ( b * c - a * d ) / ( d - c ) ; return X ; }
function NoofTriplets ( N , K ) { let cnt = Array ( K ) ; for ( let i = 0 ; i < K ; i ++ ) cnt [ i ] = 0 ; for ( let i = 1 ; i <= N ; i += 1 ) { cnt [ i % K ] += 1 ; } if ( K & 1 ) return cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; else { return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K / 2 ] * cnt [ K / 2 ] * cnt [ K / 2 ] ) ; } }
function countNum ( n ) { if ( n == 1 ) return 1 ; let count = Math . pow ( 2 , n - 2 ) ; return count ; }
function binaryToDecimal ( n ) { var num = n ; var dec_value = 0 ; var base = 1 ; var len = num . length ; for ( var i = len - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == "1" ) dec_value += base ; base = base * 2 ; } return dec_value ; }
function findNumber ( n ) { var s = constructString ( n - 1 ) ; var num = binaryToDecimal ( s ) ; return num ; }
function findNumber ( n ) { let num = n - 1 ; num = 2 * Math . pow ( 4 , num ) ; num = Math . floor ( num / 3.0 ) ; return num ; }
function bitonic_point ( node ) { if ( node == null ) return - 1 ; if ( node . next == null ) return - 1 ; if ( node . data > node . next . data ) return - 1 ; while ( node . next != null ) { if ( node . data > node . next . data ) break ; node = node . next ; } let bitonicPoint = node . data ; while ( node . next != null ) { if ( node . data < node . next . data ) return - 1 ; node = node . next ; } return bitonicPoint ; }
function minSum ( a , n ) { a . sort ( ) ; let num1 = 0 ; let num2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
function canConvert ( a , b ) { while ( b > a ) { if ( b % 10 == 1 ) { b = parseInt ( b / 10 ) ; continue ; } if ( b % 2 == 0 ) { b = parseInt ( b / 2 ) ; continue ; } return false ; } if ( b == a ) return true ; return false ; }
function MinRemove ( a , n , k ) { let cnt = new Array ( k ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) cnt [ 0 ] ++ ; else if ( cnt [ a [ i ] - 1 ] > 0 ) { cnt [ a [ i ] - 1 ] -- ; cnt [ a [ i ] ] ++ ; } } return n - ( k * cnt [ k - 1 ] ) ; }
function mosaic ( n ) { var i , ans = 1 ; for ( i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 && n > 0 ) { var count = 0 ; while ( n % i == 0 ) { n /= i ; count ++ ; } ans *= count * i ; } } return ans ; }
function nMosaicNumbers ( n ) { for ( var i = 1 ; i <= n ; i ++ ) document . write ( mosaic ( i ) + "▁" ) ; }
function mosaic ( n ) { let i , ans = 1 ; for ( i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 && n > 0 ) { let count = 0 ; while ( n % i == 0 ) { n = parseInt ( n / i , 10 ) ; count ++ ; } ans *= count * i ; } } return ans ; }
function lowerWythoff ( n ) { var phi = ( 1 + Math . sqrt ( 5 ) ) / 2.0 ; for ( var i = 1 ; i <= n ; i ++ ) { var ans = Math . floor ( i * phi ) ; document . write ( ans ) ; if ( i != n ) document . write ( "▁,▁" ) ; } }
function Total_Ways ( n ) { var fac = 1 ; for ( i = 2 ; i <= n - 1 ; i ++ ) { fac = fac * i ; } return ( fac * 2 ) ; }
function MaxNumbers ( a , n ) { let fre = new Array ( 3 ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { a [ i ] %= 3 ; fre [ a [ i ] ] ++ ; } let ans = fre [ 0 ] ; let k = Math . min ( fre [ 1 ] , fre [ 2 ] ) ; ans += k ; fre [ 1 ] -= k ; fre [ 2 ] -= k ; ans += parseInt ( fre [ 1 ] / 3 ) + parseInt ( fre [ 2 ] / 3 ) ; return ans ; }
function countSetBits ( n ) { var count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
function pairs ( arr , n , k ) { var count = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { var sum = countSetBits ( arr [ i ] ) + countSetBits ( arr [ j ] ) ; if ( sum == k ) count ++ ; } } return count ; }
function countSetBits ( n ) { var count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
function pairs ( arr , n , k ) { var count = 0 ; var f = Array . from ( { length : MAX + 1 } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < n ; i ++ ) f [ countSetBits ( arr [ i ] ) ] ++ ; for ( i = 0 ; i <= MAX ; i ++ ) { for ( j = i ; j <= MAX ; j ++ ) { if ( i + j == k ) { if ( i == j ) count += ( ( f [ i ] * ( f [ i ] - 1 ) ) / 2 ) ; else count += ( f [ i ] * f [ j ] ) ; } } } return count ; }
function composite_factors ( n ) { var count = 0 ; var i , j ; var a = Array ( n + 1 ) . fill ( 0 ) ; for ( i = 1 ; i <= n ; ++ i ) { if ( n % i == 0 ) { a [ i ] = i ; } } for ( i = 2 ; i <= n ; i ++ ) { j = 2 ; var p = 1 ; while ( j < a [ i ] ) { if ( a [ i ] % j == 0 ) { p = 0 ; break ; } j ++ ; } if ( p == 0 && a [ i ] != 0 ) { count ++ ; } } return count ; }
function count ( N ) { var a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; }
function specialSieve ( n ) { let cnt = 0 ; let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) prime [ i ] = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( ! prime [ i ] ) { cnt ++ ; for ( let j = i ; j <= n ; j += i ) prime [ j ] = cnt ; } } for ( let i = 2 ; i <= n ; i ++ ) document . write ( prime [ i ] + "▁" ) ; }
function sumOfMersenne ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 && isMersenne ( arr [ i ] ) ) { sum += arr [ i ] ; } } return sum ; }
function sumOfFactors ( n ) { let sum = 0 ; for ( let f = 1 ; f <= n / 2 ; f ++ ) { if ( n % f == 0 ) { sum += f ; } } return sum ; }
function sameLength ( A , B ) { while ( A > 0 && B > 0 ) { A = parseInt ( A / 10 ) ; B = parseInt ( B / 10 ) ; } if ( A == 0 && B == 0 ) return true ; return false ; }
function preProcess ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) cnt_neg ++ ; if ( arr [ i ] == 0 ) exists_zero = true ; } }
function FindXorSum ( arr , k , n ) { if ( n < k ) return 0 ; let x = new Array ( n ) . fill ( 0 ) ; let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i > 0 ) x [ i ] = x [ i - 1 ] ^ arr [ i ] ; else x [ i ] = arr [ i ] ; if ( i >= k - 1 ) { let sum = 0 ; sum = x [ i ] ; if ( i - k > - 1 ) sum ^= x [ i - k ] ; result += sum ; } } return result ; }
function reverse ( n ) { let rev = 0 ; while ( n > 0 ) { let d = n % 10 ; rev = rev * 10 + d ; n = parseInt ( n / 10 ) ; } return rev ; }
function isPalin ( n ) { return ( n == reverse ( n ) ) ; }
function countDigits ( n ) { let c = 0 ; while ( n > 0 ) { n = parseInt ( n / 10 ) ; c ++ ; } return c ; }
function countPalinDigits ( arr , n ) { let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 10 || isPalin ( arr [ i ] ) ) { s += countDigits ( arr [ i ] ) ; } } return s ; }
function reverse ( n ) { let d = 0 , s = 0 ; while ( n > 0 ) { d = n % 10 ; s = s * 10 + d ; n = Math . floor ( n / 10 ) ; } return s ; }
function isPalin ( n ) { return n == reverse ( n ) ; }
function sumOfArray ( arr , n ) { let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] > 10 ) && isPalin ( arr [ i ] ) ) { s += arr [ i ] ; } } return s ; }
function isVowel ( ch ) { if ( ch == "a" ch == "e" ch == "i" ch == "o" ch == "u" ) return true ; else return false ; }
function fact ( n ) { if ( n < 2 ) { return 1 ; } return n * fact ( n - 1 ) ; }
function only_vowels ( freq ) { let denom = 1 ; let cnt_vwl = 0 ; for ( let [ key , value ] of freq . entries ( ) ) { if ( isVowel ( key ) ) { denom *= fact ( value ) ; cnt_vwl += value ; } } return Math . floor ( fact ( cnt_vwl ) / denom ) ; }
function all_vowels_together ( freq ) { let vow = only_vowels ( freq ) ; let denom = 1 ; let cnt_cnst = 0 ; for ( let [ key , value ] of freq . entries ( ) ) { if ( ! isVowel ( key ) ) { denom *= fact ( value ) ; cnt_cnst += value ; } } let ans = Math . floor ( fact ( cnt_cnst + 1 ) / denom ) ; return ( ans * vow ) ; }
function no_vowels_together ( word ) { let freq = new Map ( ) ; for ( let i = 0 ; i < word . length ; i ++ ) { let ch = word [ i ] . toLowerCase ( ) ; if ( freq . has ( ch ) ) { freq . set ( ch , freq . get ( ch ) + 1 ) ; } else { freq . set ( ch , 1 ) ; } } let total = total_permutations ( freq ) ; let vwl_tgthr = all_vowels_together ( freq ) ; let res = total - vwl_tgthr ; return res ; }
function updatePrimes ( ) { for ( let i = 2 ; i <= MAX ; i ++ ) { prime [ i ] = 1 ; } prime [ 0 ] = prime [ 1 ] = 0 ; for ( let i = 2 ; i * i <= MAX ; i ++ ) { if ( prime [ i ] == 1 ) { for ( let j = i * i ; j <= MAX ; j += i ) { prime [ j ] = 0 ; } } } for ( let i = 1 ; i <= MAX ; i ++ ) { prime [ i ] += prime [ i - 1 ] ; } }
function getDifference ( l , r ) { let total = r - l + 1 ; let primes = prime [ r ] - prime [ l - 1 ] ; let composites = total - primes ; return ( Math . abs ( primes - composites ) ) ; }
function e ( x , n ) { var r ; if ( n == 0 ) return 1 ; r = e ( x , n - 1 ) ; p = p * x ; f = f * n ; return ( r + p / f ) ; }
function constructSieve ( ) { for ( let i = 2 ; i <= MAX ; i ++ ) { if ( Sieve [ i ] == 0 ) { for ( let j = 2 * i ; j <= MAX ; j += i ) { let temp = j ; while ( temp > 1 && temp % i == 0 ) { Sieve [ j ] ++ ; temp = parseInt ( temp / i ) ; } } } } }
function checkElements ( A , n , k ) { for ( let i = 0 ; i < n ; i ++ ) { if ( Sieve [ A [ i ] ] == k ) { document . write ( "YES" ) ; } else { document . write ( "No" ) ; } } }
function modularexpo ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
function multiply ( F , M , m ) { let x = ( ( F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] ) % m + ( F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ) % m ) % m ; let y = ( ( F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] ) % m + ( F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ) % m ) % m ; let z = ( ( F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] ) % m + ( F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ) % m ) % m ; let w = ( ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] ) % m + ( F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) % m ) % m ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; }
function power ( F , n , m ) { if ( n == 0 n == 1 ) return ; let M = [ [ 1 , 1 ] , [ 1 , 0 ] ] ; power ( F , Math . floor ( n / 2 ) , m ) ; multiply ( F , F , m ) ; if ( n % 2 != 0 ) multiply ( F , M , m ) ; }
function fib ( n , m ) { let F = [ [ 1 , 1 ] , [ 1 , 0 ] ] ; if ( n == 0 ) return 0 ; power ( F , n - 1 , m ) ; return F [ 0 ] [ 0 ] ; }
function cntWays ( arr , n ) { if ( n == 1 ) return 0 ; var tot_sum = 0 , sum = 0 , ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) tot_sum += arr [ i ] ; for ( var i = 0 ; i < n - 1 ; i ++ ) { sum += arr [ i ] ; if ( sum == tot_sum / 2 ) ans ++ ; } return ans ; }
function power_2 ( ) { let ans = 1 ; for ( let i = 0 ; i < MAX ; i ++ ) { pow2 [ i ] = ans ; ans *= 2 ; } }
function countSetBits ( x ) { let setBits = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; setBits ++ ; } return setBits ; }
function add ( num ) { let point = 0 ; let value = 0 ; for ( let i = 0 ; i < MAX ; i ++ ) { if ( visited [ i ] ) continue ; else { if ( num & 1 ) { value += ( 1 << i ) ; } num = parseInt ( num / 2 ) ; } } ans . push ( value ) ; }
function solve ( n , k ) { ans . push ( k ) ; let countk = countSetBits ( k ) ; if ( pow2 [ countk ] < n ) { document . write ( - 1 ) ; return ; } let count = 0 ; for ( let i = 0 ; i < pow2 [ countk ] - 1 ; i ++ ) { add ( i ) ; count ++ ; if ( count == n ) break ; } for ( let i = 0 ; i < n ; i ++ ) { document . write ( ans [ i ] + "▁" ) ; } }
function numberOfMen ( D , m , d ) { var Men = ( m * ( D - d ) ) / d ; return Men ; }
function sumPowersK ( n , k ) { var sum = 0 , num = 1 ; while ( num <= n ) { sum += num ; num *= k ; } return sum ; }
function getSum ( n , k ) { var pwrK = sumPowersK ( n , k ) ; var sumAll = ( n * ( n + 1 ) ) / 2 ; return ( sumAll - pwrK ) ; }
function maxPeople ( p ) { var tmp = 0 , count = 0 ; for ( var i = 1 ; i * i <= p ; i ++ ) { tmp = tmp + ( i * i ) ; if ( tmp <= p ) count ++ ; else break ; } return count ; }
function maxPeople ( p ) { let sums = new Array ( kN ) ; sums [ 0 ] = 0 ; for ( let i = 1 ; i < kN ; i ++ ) sums [ i ] = ( i * i ) + sums [ i - 1 ] ; let it = lower_bound ( sums , 0 , kN , p ) ; if ( it > p ) { -- it ; } return it ; }
function squareSeries ( n ) { return Math . floor ( ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ) ; }
function maxPeople ( n ) { let low = 0 ; let high = 1000000 ; let ans = 0 ; while ( low <= high ) { let mid = low + Math . floor ( ( high - low ) / 2 ) ; let value = squareSeries ( mid ) ; if ( value <= n ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; }
function getAverage ( x , y ) { var avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }
function getfactor ( n , p ) { let pw = 0 ; while ( n != 0 ) { n = parseInt ( n / p , 10 ) ; pw += n ; } return pw ; }
function isDivisible ( n , r , p ) { let x1 = getfactor ( n , p ) ; let x2 = getfactor ( r , p ) ; let x3 = getfactor ( n - r , p ) ; if ( x1 > x2 + x3 ) return 1 ; return 0 ; }
function findIndex ( a , n , k ) { var index = - 1 , max_ceil = Number . MIN_VALUE ; for ( i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] + k - 1 ) / k ; } for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= max_ceil ) { max_ceil = a [ i ] ; index = i ; } } return index ; }
function Count_Segment ( p , n ) { var count = 0 ; var upto = Array ( n + 1 ) . fill ( 0 ) ; for ( i = 0 ; i < n + 1 ; i ++ ) upto [ i ] = 0 ; var j = 0 , curr = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( p [ i ] > p [ i - 1 ] && p [ i ] > p [ i + 1 ] ) { curr = p [ i ] ; j = i - 1 ; while ( j >= 0 && p [ j ] < curr ) { upto [ p [ j ] ] = curr ; j -= 1 ; } j = i + 1 ; while ( j < n && p [ j ] < curr ) { if ( upto [ curr - p [ j ] ] == curr ) count += 1 ; j += 1 ; } } } return count ; }
function dfs ( node , parent ) { let a = __builtin_popcount ( weight [ node ] + x ) ; if ( maximum < a ) { maximum = a ; ans = node ; } else if ( maximum == a ) ans = Math . min ( ans , node ) ; for ( let i = 0 ; i < graph [ node ] . length ; i ++ ) { if ( graph [ node ] [ i ] == parent ) continue ; dfs ( graph [ node ] [ i ] , node ) ; } }
function solve ( n , k ) { if ( n >= ( k * ( k + 1 ) ) / 2 ) { return true ; } return false ; }
function solve ( a , b ) { if ( a > 0 && b > 0 ) { document . write ( "Positive" ) ; } else if ( a <= 0 && b >= 0 ) { document . write ( "Zero" ) ; } else { let n = Math . abs ( a - b ) + 1 ; if ( n % 2 == 0 ) { document . write ( "Positive" ) ; } else { document . write ( "Negative" ) ; } } }
function isEven ( arr , n , r ) { if ( r % 2 == 0 ) { if ( arr [ n - 1 ] % 2 == 0 ) return true ; } else { let oddCount = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( arr [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount % 2 == 0 ) return true ; } return false ; }
function closetAND ( arr , n , k ) { let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let X = arr [ i ] ; for ( let j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; } } return ans ; }
function countQuadruplets ( l , r , k ) { var count = 0 ; for ( u = l ; u <= r ; u ++ ) { for ( v = l ; v <= r ; v ++ ) { for ( w = l ; w <= r ; w ++ ) { for ( x = l ; x <= r ; x ++ ) { if ( gcd ( gcd ( u , v ) , gcd ( w , x ) ) == k ) count ++ ; } } } } return count ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function count_square ( n ) { let count = 0 ; for ( let i = 1 ; i <= n ; i = i + 2 ) { let k = n - i + 1 ; count += ( k * k ) ; } return count ; }
function Rate ( N1 , N2 ) { var rate = ( N2 - N1 ) * 100 / N1 ; return parseInt ( rate ) ; }
function solve ( a , n ) { let ones = 0 , twos = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } let ind = 0 ; if ( twos > 0 ) a [ ind ++ ] = 2 ; let evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( let i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( let i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) document . write ( a [ i ] + "▁" ) ; }
function count_pairs ( a , b , n , m ) { var odd1 = 0 , even1 = 0 ; var odd2 = 0 , even2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd1 ++ ; else even1 ++ ; } for ( i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) odd2 ++ ; else even2 ++ ; } var pairs = Math . min ( odd1 , odd2 ) + Math . min ( even1 , even2 ) ; return pairs ; }
function primeCount ( arr , n ) { let max_val = Math . max ( ... arr ) ; let prime = new Array ( max_val + 1 ) . fill ( true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; }
function getPrefixArray ( arr , n , pre ) { pre [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } }
function getPrime ( arr , n ) { let max_val = Math . max ( ... arr ) ; let prime = new Array ( max_val + 1 ) . fill ( true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } let maximum = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) maximum = Math . max ( maximum , arr [ i ] ) ; } return maximum ; }
function CreateArray ( N , even , odd ) { let EvenPreSums = 1 ; let temp = - 1 ; let OddPreSums = 0 ; for ( let i = 0 ; i <= N + 1 ; i ++ ) { if ( i * ( ( N + 1 ) - i ) == odd ) { temp = 0 ; OddPreSums = i ; break ; } } if ( temp == - 1 ) { document . write ( temp ) ; } else { EvenPreSums = ( ( N + 1 ) - OddPreSums ) ; let e = 1 ; let o = 0 ; let CurrSum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( CurrSum % 2 == 0 ) { if ( e < EvenPreSums ) { e ++ ; document . write ( "0▁" ) ; } else { o ++ ; document . write ( "1▁" ) ; CurrSum ++ ; } } else { if ( e < EvenPreSums ) { e ++ ; document . write ( "1▁" ) ; CurrSum ++ ; } else { o ++ ; document . write ( "0▁" ) ; } } } document . write ( ) ; } }
function changeTheArray ( arr , n ) { let minEle = Math . min ( ... arr ) ; let maxEle = Math . max ( ... arr ) ; let minOperations = Number . MAX_VALUE ; for ( let num = minEle ; num <= maxEle ; num ++ ) { let operations = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( Math . abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = Math . min ( minOperations , operations ) ; } return minOperations ; }
function getMinNum ( N ) { var lcm = 1 ; for ( var i = 2 ; i <= N ; i ++ ) lcm = ( ( i * lcm ) / ( __gcd ( i , lcm ) ) ) ; return ( lcm + 1 ) ; }
function maxEdges ( N ) { var edges = 0 ; edges = Math . floor ( ( N * N ) / 4 ) ; return edges ; }
function findX ( A , B ) { let j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; }
function findX ( A , B ) { return A & B ; }
function findSum ( A , B ) { return A ^ B ; }
function isSumEqual ( ar , n ) { let sum = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; }
function findIndex ( a , n ) { let res = 0 ; let min_diff = Number . MAX_VALUE ; let prod = new Array ( n ) ; prod [ 0 ] = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let curr_diff = Math . abs ( parseInt ( prod [ n - 1 ] / prod [ i ] , 10 ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; }
function Permutation ( n , k ) { let p = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( let i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( let i = 1 ; i <= n ; i ++ ) document . write ( p [ i ] + "▁" ) ; }
function perfectSquares ( a , b ) { return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ; }
function countOnes ( arr , n ) { return perfectSquares ( 1 , n ) ; }
function validPosition ( arr , N , K ) { var count = 0 , sum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( var i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) count ++ ; } return count ; }
function count_unique ( s , n ) { if ( s . has ( n ) ) return ; s . add ( n ) ; n += 1 ; while ( n % 10 == 0 ) { n = Math . floor ( n / 10 ) ; } count_unique ( s , n ) ; }
function countPairs ( arr , n ) { var size = ( 2 * N ) + 1 ; var freq = Array ( size ) . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { var x = arr [ i ] ; freq [ x + N ] ++ ; } var ans = 0 ; for ( i = 0 ; i < size ; i ++ ) { if ( freq [ i ] > 0 ) { ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ; for ( j = i + 2 ; j < 2001 ; j += 2 ) { if ( freq [ j ] > 0 && ( freq [ ( i + j ) / 2 ] > 0 ) ) { ans += ( freq [ i ] * freq [ j ] ) ; } } } } return ans ; }
function smallestSum ( n ) { if ( n == 1 ) return 0 ; return ( 2 * Math . pow ( 10 , n - 1 ) ) ; }
function largestSum ( n ) { return ( 2 * ( Math . pow ( 10 , n ) - 1 ) ) ; }
function count_pairs ( a , b , n , m ) { let odd1 = 0 , even1 = 0 ; let odd2 = 0 , even2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 ) odd1 ++ ; else even1 ++ ; } for ( let i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 ) odd2 ++ ; else even2 ++ ; } let pairs = Math . min ( odd1 , even2 ) + Math . min ( odd2 , even1 ) ; return pairs ; }
function find_leftmost_unsetbit ( n ) { let ind = - 1 ; let i = 1 ; while ( n ) { if ( ! ( n & 1 ) ) ind = i ; i ++ ; n >>= 1 ; } return ind ; }
function vertices ( N , A , B ) { var position = 0 ; var minisum = Number . MAX_VALUE ; var sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( i == A i == B ) continue ; else { var x = Math . abs ( i - A ) ; var y = Math . abs ( i - B ) ; sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; }
function factorial ( n ) { let f = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { f *= i ; } return f ; }
function sumFactorial ( arr , n ) { let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s += factorial ( arr [ i ] ) ; } return s ; }
function dfs ( child , par , color ) { if ( color [ child ] != color [ par ] ) ans ++ ; for ( let i = 0 ; i < gr [ child ] . length ; i ++ ) { if ( gr [ child ] [ i ] == par ) continue ; dfs ( gr [ child ] [ i ] , child , color ) ; } }
function highestPower ( str , len ) { let ans = 0 ; for ( let i = len - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == "0" ) ans ++ ; else break ; } return ans ; }
function modInverse ( n , p ) { return power ( n , p - 2 , p ) ; }
function nCrModP ( n , r , p ) { if ( r == 0 ) return 1 ; var fac = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; ; fac [ 0 ] = 1 ; for ( var i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ parseInt ( n ) ] * modInverse ( fac [ parseInt ( r ) ] , p ) % p * modInverse ( fac [ parseInt ( n ) - parseInt ( r ) ] , p ) % p ) % p ; }
function countArrangements ( n , k , p ) { return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p ; }
function maxProd ( N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . max ( maxProd ( parseInt ( N / 10 ) ) * ( N % 10 ) , maxProd ( parseInt ( N / 10 ) - 1 ) * 9 ) ; }
function primeFactors ( n , freq ) { var cnt = 0 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } freq [ 2 ] = cnt ; var i ; for ( i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } freq [ i ] = cnt ; } if ( n > 2 ) freq [ n ] = 1 ; }
function getMaximumPower ( n , m ) { var freq1 = new Array ( n + 1 ) ; var freq2 = new Array ( m + 1 ) ; primeFactors ( n , freq1 ) ; primeFactors ( m , freq2 ) ; var maxi = 0 ; for ( i = 2 ; i <= m ; i ++ ) { if ( freq1 [ i ] == 0 && freq2 [ i ] == 0 ) continue ; if ( freq2 [ i ] > freq1 [ i ] ) return 0 ; if ( freq2 [ i ] ) { maxi = Math . max ( maxi , freq1 [ i ] / freq2 [ i ] ) ; } } return maxi ; }
function check ( mat ) { let xorr = 0 ; for ( let i = 0 ; i < N ; i ++ ) { xorr ^= mat [ i ] [ 0 ] ; } if ( xorr != 0 ) return true ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 1 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ 0 ] ) return true ; } } return false ; }
function sumodd ( n ) { return ( n * n ) ; }
function sumeven ( n ) { return ( n * ( n + 1 ) ) ; }
function radiated_Station ( station , n ) { var rStation = [ ] ; rStation . length = 6 ; rStation . fill ( 0 )  for ( var i = 1 ; i <= n ; i ++ ) { var li = i - 1 , ri = i + 1 ; var lRad = station [ i ] - 1 , rRad = station [ i ] - 1 ; rStation [ i ] += station [ i ] ; while ( li >= 1 && lRad >= 1 ) { rStation [ li -- ] += lRad -- ; } while ( ri <= n && rRad >= 1 ) { rStation [ ri ++ ] += rRad -- ; } } print ( rStation , n ) ; }
function oddTriangularNumber ( N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; }
function idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) document . write ( "The▁given▁straight" + "▁lines▁are▁identical" ) ; else document . write ( "The▁given▁straight" + "▁lines▁are▁not▁identical" ) ; }
function area ( a , b , c ) { var d = Math . abs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; }
function percent ( n , x ) { let p = n * x ; p = Math . floor ( p / 100 ) ; return p ; }
function getLoss ( price , quantity , X , n ) { let loss = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let originalPrice = price [ i ] ; let sellingPrice = originalPrice + percent ( originalPrice , X [ i ] ) ; let afterDiscount = sellingPrice - percent ( sellingPrice , X [ i ] ) ; loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) ; } return loss ; }
function maxAbsDiff ( arr , n ) { let minEle = arr [ 0 ] ; let maxEle = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }
function maxSubArraySum ( a , size ) { let max_so_far = Number . MIN_VALUE , max_ending_here = 0 ; for ( let i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
function maximizeSum ( a , n ) { let cnt = 0 ; let mini = Number . MAX_VALUE ; let minSubarray = Number . MAX_VALUE ; let sum = maxSubArraySum ( a , n ) ; let max_so_far = Number . MIN_VALUE , max_ending_here = 0 ; for ( let i = 0 ; i < n ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; cnt ++ ; minSubarray = Math . min ( a [ i ] , minSubarray ) ; if ( sum == max_ending_here ) { if ( cnt == 1 ) mini = Math . min ( mini , 0 ) ; else mini = Math . min ( mini , minSubarray ) ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; cnt = 0 ; minSubarray = Integer . MAX_VALUE ; } } return sum - mini ; }
function isOsiris ( n ) { let a = n % 10 ; let b = parseInt ( ( n / 10 ) % 10 ) ; let c = parseInt ( n / 100 ) ; let digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
function countTriangles ( a , n ) { var cnt = 0 ; var pairs = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += parseInt ( ( 2 * pairs ) / 3 ) ; return cnt ; }
function smallestMultiple ( n ) { if ( n == 1 ) return 5 ; return Math . pow ( 10 , n - 1 ) ; }
function countAnomalies ( arr , n , k ) { var cnt = 0 ; var i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( Math . abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; }
function Divisors ( ) { for ( let i = 1 ; i < N ; i ++ ) { for ( let j = 1 ; j * i < N ; j ++ ) { cnt [ i * j ] ++ ; } } }
function Sumofdivisors ( A , B , C ) { let sum = 0 ; Divisors ( ) ; for ( let i = 1 ; i <= A ; i ++ ) { for ( let j = 1 ; j <= B ; j ++ ) { for ( let k = 1 ; k <= C ; k ++ ) { let x = i * j * k ; sum += cnt [ x ] ; if ( sum >= mod ) { sum -= mod ; } } } } return sum ; }
function getHCF ( x , y ) { var minimum = Math . min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( var i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function isDivisible ( n ) { if ( isPrime ( n + 1 ) ) return false ; return true ; }
function findDivisors ( n ) { let div = new Array ( n + 1 ) . fill ( 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( let i = 1 ; i <= n ; i ++ ) document . write ( div [ i ] + "▁" ) ; }
function findMaxCock ( ar ) { if ( R < 3 C < 3 ) return - 1 ; var max_sum = - 1000000000 ; for ( var i = 0 ; i < R - 2 ; i ++ ) { for ( var j = 0 ; j < C - 2 ; j ++ ) { var sum = ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ; max_sum = Math . max ( max_sum , sum ) ; } } return max_sum ; }
function segments ( n , p , m ) { var c = new Map ( ) ; c . set ( 0 , 1 ) ; var hs = false ; var sum = 0 ; var ans = 0 ; var r ; for ( r = 0 ; r < n ; r ++ ) { if ( p [ r ] < m ) sum -- ; else if ( p [ r ] > m ) sum ++ ; if ( p [ r ] == m ) hs = true ; if ( hs ) { if ( c . has ( sum ) && c . has ( sum - 1 ) ) ans += c . get ( sum ) + c . get ( sum - 1 ) ; else if ( c . has ( sum ) ) ans += c . get ( sum ) ; else if ( c . has ( sum - 1 ) ) ans += c . get ( sum - 1 ) ; } else { if ( c . has ( sum ) ) c . set ( sum , c . get ( sum ) + 1 ) ; else c . set ( sum , 1 ) ; } } return ans ; }
function findMaximumDiff ( a , n ) { var ind1 = 0 ; for ( i = n - 1 ; i > 0 ; i -- ) { if ( a [ 0 ] != a [ i ] ) { ind1 = i ; break ; } } var ind2 = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( a [ n - 1 ] != a [ i ] ) { ind2 = ( n - 1 - i ) ; break ; } } return Math . max ( ind1 , ind2 ) ; }
function decideWinner ( a , n ) { var count0 = 0 ; var count1 = 0 ; var count2 = 0 ; var count3 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }
function minOperations ( arr , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) } else { mp . set ( arr [ i ] , 1 ) } } let maxFreq = Number . MIN_SAFE_INTEGER ; for ( let x of mp ) maxFreq = Math . max ( maxFreq , x [ 1 ] ) ; return ( n - maxFreq ) ; }
function Add_edge ( u , v ) { tree [ u ] . push ( v ) ; tree [ v ] . push ( u ) ; }
function intisalise ( ) { startIdx = new Array ( n + 1 ) ; endIdx = new Array ( n + 1 ) ; p = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { startIdx [ i ] = 0 ; endIdx [ i ] = 0 ; p [ i ] = 0 ; } }
function Dfs ( ch , par ) { p [ currentIdx ] = ch ; startIdx [ ch ] = currentIdx ++ ; for ( let c = 0 ; c < tree [ ch ] . length ; c ++ ) { if ( tree [ ch ] != par ) Dfs ( tree [ ch ] , ch ) ; } endIdx [ ch ] = currentIdx - 1 ; }
function findNode ( v , k ) { k += startIdx [ v ] - 1 ; if ( k <= endIdx [ v ] ) return p [ k ] ; return - 1 ; }
function CntDivbyX ( arr , n , x ) { let number = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count += 1 ; } return count ; }
function CntDivbyX ( arr , n , x ) { let number = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; }
function smallestIndex ( a , n ) { let right1 = 0 , right0 = 0 ; let i ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return Math . min ( right1 , right0 ) ; }
function A_mod_B ( N , a ) { var len = N . length ; var ans = 0 ; for ( var i = 0 ; i < len ; i ++ ) ans = ( ans * 10 + parseInt ( N . charAt ( i ) - "0" ) ) % a ; return ans % a ; }
function findMod ( N ) { var mod = A_mod_B ( N , 4 ) ; var ans = ( 1 + parseInt ( Math . pow ( 2 , mod ) + Math . pow ( 3 , mod ) + Math . pow ( 4 , mod ) ) ) ; return ( ans % 5 ) ; }
function countCon ( ar , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
function printElements ( arr , n ) { for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) document . write ( arr [ i ] + "▁" ) ; } }
function reduceFraction ( x , y ) { let d ; d = __gcd ( x , y ) ; x = parseInt ( x / d ) ; y = parseInt ( y / d ) ; document . write ( "x▁=▁" + x + ",▁y▁=▁" + y ) ; }
function generateSubStrings ( s , mpp ) { let l = s . length ; for ( let i = 0 ; i < l ; i ++ ) { let temp = "" ; for ( let j = i ; j < l ; j ++ ) { temp += s [ j ] ; if ( mpp . has ( temp ) ) { let x = mpp . get ( temp ) ; mpp . set ( temp , ++ x ) ; } else mpp . set ( temp , 1 ) ; } } }
function binomialCoeff ( C ) { let i , j ; for ( i = 1 ; i < 100 ; i ++ ) { for ( j = 0 ; j < 100 ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } }
function answerQuery ( mpp , C , k ) { let ans = 0 ; for ( let [ key , value ] of mpp . entries ( ) ) { if ( value >= k ) ans += C [ value ] [ k ] ; } return ans ; }
function numLen ( K ) { if ( K % 2 == 0 K % 5 == 0 ) { return - 1 ; } var number = 0 ; var len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = number * 10 + 1 ; if ( ( number % K == 0 ) ) { return len ; } } return - 1 ; }
function numLen ( K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; var number = 0 ; var len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; }
function precomputation ( arr , n ) { for ( var i = 1 ; i < max_Element ; i ++ ) for ( var j = i ; j < max_Element ; j += i ) sum1 [ j ] += i ; for ( var i = 1 ; i < max_Element ; i ++ ) for ( var j = i ; j < max_Element ; j += i ) sum2 [ j ] += ( sum1 [ j ] - i ) * i ; for ( var i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ; for ( var i = 1 ; i < max_Element ; i ++ ) for ( var j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ; for ( var i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ; for ( var i = 0 ; i < n ; i ++ ) document . write ( sum3 [ arr [ i ] ] + "▁" ) ; }
function sum ( k , n ) { let sum = 0 ; for ( let i = 0 ; i <= n ; i ++ ) { let p = 1 ; for ( let j = 0 ; j < n - i ; j ++ ) { p = p * k ; } for ( let j = 0 ; j < i ; j ++ ) { p = p * ( k - 1 ) ; } sum = sum + p ; } return sum ; }
function exponent ( A , B ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; let y ; if ( B % 2 == 0 ) { y = exponent ( A , parseInt ( B / 2 , 10 ) ) ; y = ( y * y ) ; } else { y = A ; y = ( y * exponent ( A , B - 1 ) ) ; } return y ; }
function sum ( k , n ) { let sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; return sum ; }
function freqPairs ( arr , n ) { let max = Math . max ( ... arr ) ; let freq = new Array ( max + 1 ) . fill ( 0 ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 2 * arr [ i ] ; j <= max ; j += arr [ i ] ) { if ( freq [ j ] >= 1 ) count += freq [ j ] ; } if ( freq [ arr [ i ] ] > 1 ) { count += freq [ arr [ i ] ] - 1 ; freq [ arr [ i ] ] -- ; } } return count ; }
function is_prime ( num ) { var count = 0 ; for ( i = 1 ; i * i <= ( num ) ; i ++ ) { if ( ( num ) % i == 0 ) { if ( i * i != ( num ) ) count += 2 ; else count ++ ; } } if ( count == 2 ) return true ; else return false ; }
function is_divisible ( n ) { if ( n == 1 ) { return "YES" ; } else { if ( is_prime ( n + 1 ) ) return "NO" ; else return "YES" ; } }
function power ( x , y , p ) { var res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function findCount ( N ) { var count = power ( 2 , N , mod ) ; return count ; }
function msb ( x ) { let ret = 0 ; while ( ( x >> ( ret + 1 ) ) != 0 ) ret ++ ; return ret ; }
function xorRange ( l , r ) { let max_bit = msb ( r ) ; let mul = 2 ; let ans = 0 ; for ( let i = 1 ; i <= max_bit ; i ++ ) { if ( ( parseInt ( l / mul ) * mul ) == ( parseInt ( r / mul ) * mul ) ) { if ( ( ( l & ( 1 << i ) ) != 0 ) && ( r - l + 1 ) % 2 == 1 ) ans += mul ; mul *= 2 ; continue ; } let odd_c = 0 ; if ( ( ( l & ( 1 << i ) ) != 0 ) && l % 2 == 1 ) odd_c = ( odd_c ^ 1 ) ; if ( ( ( r & ( 1 << i ) ) != 0 ) && r % 2 == 0 ) odd_c = ( odd_c ^ 1 ) ; if ( odd_c ) ans += mul ; mul *= 2 ; } let zero_bit_cnt = parseInt ( ( r - l + 1 ) / 2 ) ; if ( l % 2 == 1 && r % 2 == 1 ) zero_bit_cnt ++ ; if ( zero_bit_cnt % 2 == 1 ) ans ++ ; return ans ; }
function computeXOR ( n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } }
function countNumbers ( x , n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; }
function checkfact ( N , countprime , prime ) { var countfact = 0 ; if ( prime == 2 prime == 3 ) countfact ++ ; var divide = prime ; while ( N / divide != 0 ) { countfact += N / divide ; divide = divide * divide ; } if ( countfact >= countprime ) return true ; else return false ; }
function check ( N ) { var sumsquares = ( N + 1 ) * ( 2 * N + 1 ) ; var countprime = 0 ; for ( i = 2 ; i <= Math . sqrt ( sumsquares ) ; i ++ ) { var flag = 0 ; while ( sumsquares % i == 0 ) { flag = 1 ; countprime ++ ; sumsquares /= i ; } if ( flag == 1 ) { if ( ! checkfact ( N - 1 , countprime , i ) ) return false ; countprime = 0 ; } } if ( sumsquares != 1 ) if ( ! checkfact ( N - 1 , 1 , sumsquares ) ) return false ; return true ; }
function countNonIncreasing ( arr , n ) { var cnt = 0 ; var len = 1 ; for ( var i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += parseInt ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += parseInt ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; }
function recamanArray ( arr , n ) { var s = [ ] ; var recaman = Array ( n ) . fill ( 0 ) ; recamanGenerator ( recaman , n ) ; for ( var i = 0 ; i < n ; i ++ ) s . push ( recaman [ i ] ) ; s . sort ( ( a , b ) => b - a )  for ( var i = 0 ; i < n ; i ++ ) { if ( s . includes ( arr [ i ] ) ) { s . splice ( s . indexOf ( arr [ i ] ) , 1 ) ; } } return s . length ; }
function countSubarrays ( arr , n , k ) { let prefix_sum = new Array ( MAX ) ; prefix_sum [ 0 ] = 0 ; prefix_sum = partial_sum ( prefix_sum , arr , n ) ; let sum ; if ( k == 1 ) { sum = 0 ; let m = new Map ( ) ; for ( let i = n ; i >= 0 ; i -- ) { if ( m . has ( prefix_sum [ i ] + 1 ) ) sum += m . get ( prefix_sum [ i ] + 1 ) ; if ( m . has ( prefix_sum [ i ] ) ) m . set ( prefix_sum [ i ] , m . get ( prefix_sum [ i ] ) + 1 ) ; else m . set ( prefix_sum [ i ] , 1 ) ; } return sum ; } if ( k == - 1 ) { sum = 0 ; let m = new Map ( ) ; for ( let i = n ; i >= 0 ; i -- ) { if ( m . has ( prefix_sum [ i ] + 1 ) ) sum += m . get ( prefix_sum [ i ] + 1 ) ; if ( m . has ( prefix_sum [ i ] - 1 ) ) sum += m . get ( prefix_sum [ i ] - 1 ) ; if ( m . has ( prefix_sum [ i ] ) ) m . set ( prefix_sum [ i ] , m . get ( prefix_sum [ i ] ) + 1 ) ; else m . set ( prefix_sum [ i ] , 1 ) ; } return sum ; } sum = 0 ; let b , l = 100000000000000 ; let m = new Map ( ) ; for ( let i = n ; i >= 0 ; i -- ) { b = 1 ; while ( true ) { if ( b > l ) break ; if ( m . has ( prefix_sum [ i ] + b ) ) sum += m . get ( prefix_sum [ i ] + b ) ; b *= k ; } if ( m . has ( prefix_sum [ i ] ) ) m . set ( ( prefix_sum [ i ] ) , m . get ( prefix_sum [ i ] ) + 1 ) ; else m . set ( ( prefix_sum [ i ] ) , 1 ) ; } return sum ; }
function kadaneAlgorithm ( ar , n ) { let sum = 0 , maxSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += ar [ i ] ; if ( sum < 0 ) sum = 0 ; maxSum = Math . max ( maxSum , sum ) ; } return maxSum ; }
function maxFunction ( arr , n ) { let b = new Array ( MAX ) , c = new Array ( MAX ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( i & 1 ) { b [ i ] = Math . abs ( arr [ i + 1 ] - arr [ i ] ) ; c [ i ] = - b [ i ] ; } else { c [ i ] = Math . abs ( arr [ i + 1 ] - arr [ i ] ) ; b [ i ] = - c [ i ] ; } } let ans = kadaneAlgorithm ( b , n - 1 ) ; ans = Math . max ( ans , kadaneAlgorithm ( c , n - 1 ) ) ; return ans ; }
function isPerfectSquare ( arr , n ) { let umap = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { umap [ arr [ i ] ] ++ ; if ( umap . has ( arr [ i ] ) ) { umap . set ( arr [ i ] , umap . get ( arr [ i ] ) + 1 ) } else { umap . set ( arr [ i ] , 1 ) } } for ( let itr of umap ) if ( ( itr [ 1 ] ) % 2 == 1 ) return false ; return true ; }
function minimumSteps ( n , m , a , b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return Math . min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; }
function isPrime ( x ) { for ( let i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) return 0 ; } return 1 ; }
function minimumCost ( n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 1 && isPrime ( n - 2 ) ) return 2 ; if ( n % 2 == 0 ) return 2 ; return 3 ; }
function fib ( n ) { var phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return parseInt ( Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ) ; }
function calculateSum ( l , r ) { var sum = 0 ; for ( i = l ; i <= r ; i ++ ) sum += fib ( i ) ; return sum ; }
function fib ( n ) { var phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return parseInt ( Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ) ; }
function calculateSum ( l , r ) { var sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; }
function wastedWater ( V , M , N ) { let wasted_amt , amt_per_min , time_to_fill ; amt_per_min = M - N ; time_to_fill = V / amt_per_min ; wasted_amt = N * time_to_fill ; return wasted_amt ; }
function sphereSide ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var R = ( ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ) / 2 ; return R ; }
function Loss ( SP , P ) { var loss = 0 ; loss = ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; document . write ( "Loss▁=▁" + loss . toFixed ( 3 ) ) ; }
function possibleways ( n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }
function countSubarrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let product = 1 ; for ( let x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }
function build ( node , start , end , arr , k ) { if ( start == end ) { tree [ node ] = ( 1 * arr [ start ] ) % k ; return ; } let mid = ( start + end ) >> 1 ; build ( 2 * node , start , mid , arr , k ) ; build ( 2 * node + 1 , mid + 1 , end , arr , k ) ; tree [ node ] = ( tree [ 2 * node ] * tree [ 2 * node + 1 ] ) % k ; }
function query ( node , start , end , l , r , k ) { if ( start > end start > r end < l ) { return 1 ; } if ( start >= l && end <= r ) { return tree [ node ] % k ; } let mid = ( start + end ) >> 1 ; let q1 = query ( 2 * node , start , mid , l , r , k ) ; let q2 = query ( 2 * node + 1 , mid + 1 , end , l , r , k ) ; return ( q1 * q2 ) % k ; }
function countSubarrays ( arr , n , k ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let product_mod_k = query ( 1 , 0 , n - 1 , i , j , k ) ; if ( product_mod_k == 0 ) { count ++ ; } } } return count ; }
function printMaxValPair ( v , n ) { v . sort ( ( a , b ) => a - b )  var N = v [ n - 1 ] ; if ( N % 2 == 1 ) { var first_maxima = N / 2 ; var second_maxima = first_maxima + 1 ; var ans1 = 3000000000000000000 , ans2 = 3000000000000000000 ; var from_left = - 1 , from_right = - 1 ; var from = - 1 ; for ( var i = 0 ; i < n ; ++ i ) { if ( v [ i ] > first_maxima ) { from = i ; break ; } else { var diff = first_maxima - v [ i ] ; if ( diff < ans1 ) { ans1 = diff ; from_left = v [ i ] ; } } } from_right = v [ from ] ; var diff1 = first_maxima - from_left ; var diff2 = from_right - second_maxima ; if ( diff1 < diff2 ) document . write ( N + "▁" + from_left ) ; else document . write ( N + "▁" + from_right ) ; } else { var maxima = parseInt ( N / 2 ) ; var ans1 = 3000000000000000000 ; var R = - 1 ; for ( var i = 0 ; i < n - 1 ; ++ i ) { var diff = Math . abs ( v [ i ] - maxima ) ; if ( diff < ans1 ) { ans1 = diff ; R = v [ i ] ; } } document . write ( N + "▁" + R ) ; } }
function Permutations ( n , k ) { var ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; }
function countIntegers ( l , r ) { var ans = 0 , i = 1 ; var v = power ( 2 , i ) ; while ( v <= r ) { while ( v <= r ) { if ( v >= l ) ans ++ ; v = v * 3 ; } i ++ ; v = power ( 2 , i ) ; } if ( l == 1 ) ans ++ ; return parseInt ( ans ) ; }
function sumTruncatablePrimes ( n ) { let sum = 0 ; for ( let i = 2 ; i < n ; i ++ ) { let num = i ; let flag = true ; while ( num > 0 ) { if ( ! prime [ num ] ) { flag = false ; break ; } num = Math . floor ( num / 10 ) ; } num = i ; let power = 10 ; while ( num / power > 0 ) { if ( ! prime [ num % power ] ) { flag = false ; break ; } power *= 10 ; } if ( flag ) { sum += i ; } } return sum ; }
function nDigitPerfectSquares ( n ) { document . write ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) , 2 ) + "▁" ) ; document . write ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 , 2 ) ) ; }
function MaxTraceSub ( mat ) { var max_trace = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { var r = i , s = j , trace = 0 ; while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; max_trace = Math . max ( trace , max_trace ) ; } } } return max_trace ; }
function printSum ( a , b ) { var res = 0 ; var temp1 = 0 , temp2 = 0 ; while ( a ) { temp1 = temp1 * 10 + ( a % 10 ) ; a = parseInt ( a / 10 ) ; } a = temp1 ; while ( b ) { temp2 = temp2 * 10 + ( b % 10 ) ; b = parseInt ( b / 10 ) ; } b = temp2 ; while ( a ) { var sum = ( a % 10 + b % 10 ) ; if ( parseInt ( sum / 10 ) == 0 ) res = res * 10 + sum ; else { temp1 = 0 ; while ( sum ) { temp1 = temp1 * 10 + ( sum % 10 ) ; sum = parseInt ( sum / 10 ) ; } sum = temp1 ; while ( sum ) { res = res * 10 + ( sum % 10 ) ; sum = parseInt ( sum / 10 ) ; } } a = parseInt ( a / 10 ) ; b = parseInt ( b / 10 ) ; } return res ; }
function countDigits ( a , b ) { return Math . floor ( ( Math . log ( Math . abs ( a ) ) / Math . log ( 10 ) ) - ( Math . log ( Math . abs ( b ) ) / Math . log ( 10 ) ) ) + 1 ; }
function smallestOdd ( n ) { if ( n == 1 ) return 1 ; return Math . pow ( 10 , n - 1 ) + 1 ; }
function longestSubArray ( arr , n ) { var isZeroPresent = false ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
function smallestEven ( n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) ; }
function printBalancedExpression ( a , b , c , d ) { if ( ( ( a == d ) && ( a != 0 ) ) || ( ( a == 0 ) && ( c == 0 ) && ( d == 0 ) ) ) { for ( i = 1 ; i <= a ; i ++ ) document . write ( "((" ) ; for ( i = 1 ; i <= c ; i ++ ) document . write ( ")(" ) ; for ( i = 1 ; i <= d ; i ++ ) document . write ( "))" ) ; for ( i = 1 ; i <= b ; i ++ ) document . write ( "()" ) ; } else document . write ( - 1 ) ; }
function maxProfit ( n , a , b , x , y ) { let res = x * Math . floor ( n / a ) ; res += y * Math . floor ( n / b ) ; res -= Math . min ( x , y ) * ( n / ( ( a * b ) / __gcd ( a , b ) ) ) ; return res ; }
function factorial ( f ) { var fact = 1 ; for ( var i = 2 ; i <= f ; i ++ ) fact *= i ; return fact ; }
function kthOdd ( arr , n , k ) { for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) k -- ; if ( k == 0 ) return arr [ i ] ; } return - 1 ; }
function lastFiveDigits ( n ) { n = ( Math . floor ( n / 10000 ) ) * 10000 + ( Math . floor ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( Math . floor ( n / 10 ) % 10 ) * 10 + Math . floor ( n / 1000 ) % 10 ; let ans = 1 ; for ( let i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } document . write ( ans ) ; }
function power ( a , n ) { if ( n == 0 ) { return 1 ; } let p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( n == 1 ) { p = ( p * a ) % mod ; } return p ; }
function computeSum ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let maxs = ( power ( 2 , i ) - 1 + mod ) % mod ; maxs = ( maxs * arr [ i ] ) % mod ; let mins = ( power ( 2 , n - 1 - i ) - 1 + mod ) % mod ; mins = ( mins * arr [ i ] ) % mod ; let V = ( maxs - mins + mod ) % mod ; sum = ( sum + V ) % mod ; } return sum ; }
function maxValue ( n ) { if ( n == 1 ) return 0 ; return ( parseInt ( n * n / 2 ) - 1 ) ; }
function count ( n ) { var cnt = 0 ; var p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
function countNumbers ( n ) { return n - parseInt ( n / 2 , 10 ) - parseInt ( n / 3 , 10 ) - parseInt ( n / 5 , 10 ) - parseInt ( n / 7 , 10 ) + parseInt ( n / 6 , 10 ) + parseInt ( n / 10 , 10 ) + parseInt ( n / 14 , 10 ) + parseInt ( n / 15 , 10 ) + parseInt ( n / 21 , 10 ) + parseInt ( n / 35 , 10 ) - parseInt ( n / 30 , 10 ) - parseInt ( n / 42 , 10 ) - parseInt ( n / 70 , 10 ) - parseInt ( n / 105 , 10 ) + parseInt ( n / 210 , 10 ) ; }
function sum ( n ) { if ( n == 1 ) return 1 ; else return ( Math . pow ( n , n ) + sum ( n - 1 ) ) ; }
function power ( a , n ) { if ( n == 0 ) return 1 ; let p = power ( a , parseInt ( n / 2 , 10 ) ) % mod ; p = ( p * p ) % mod ; if ( ( n & 1 ) == 1 ) p = ( p * a ) % mod ; return p ; }
function countPermutations ( n ) { if ( n == 1 ) { return 0 ; } return ( power ( 2 , n - 1 ) - 2 ) % mod ; }
function numbers ( n ) { return ( Math . pow ( 2 , n + 1 ) ) - 2 ; }
function countNumbers ( n ) { return ( n / 2520 ) ; }
function nthTerm ( N ) { let nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; }
function nthTerm ( N ) { let nth = 0 ; nth = parseInt ( ( N * N * ( N + 1 ) ) / 2 ) ; return nth ; }
function kthSmallest ( n , k ) { return ( 2 * k ) ; }
function isSumOfPowersOfTwo ( n ) { if ( n % 2 == 1 ) return false ; else return true ; }
function sieve_modified ( ) { for ( var i = 1 ; i < MAX ; i += 2 ) { for ( var j = i ; j < MAX ; j += i ) prefix [ j ] += i ; } for ( var i = 1 ; i < MAX ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; }
function sumOddFactors ( L , R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; }
function sieve ( ) { spf [ 1 ] = 1 ; for ( let i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( let i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( let i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( let j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
function getFactorization ( x ) { let temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) { hash1 [ spf [ x ] ] ++ ; x = x / spf [ x ] ; } while ( x % temp == 0 ) x = x / temp ; } }
function check ( x ) { let temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x / temp ; } return true ; }
function hasValidNum ( arr , n ) { sieve ( ) ; for ( let i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; }
function findMinRemoval ( arr , n ) { var temp , value = 0 ; var maximum = 0 ; if ( n == 1 ) return 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( i != 0 && i != n - 1 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) + Math . abs ( arr [ i ] - arr [ i - 1 ] ) - Math . abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; } else if ( i == 0 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; } else temp = Math . abs ( arr [ i ] - arr [ i - 1 ] ) ; maximum = Math . max ( maximum , temp ) ; } return ( value - maximum ) ; }
function countQuadruples ( a , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) if ( mp . has ( a [ i ] ) ) { mp . set ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . set ( a [ i ] , 1 ) ; } let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) { for ( let k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; mp . set ( a [ j ] , mp . get ( a [ j ] ) - 1 ) ; mp . set ( a [ k ] , mp . get ( a [ k ] ) - 1 ) ; let first = a [ j ] - ( a [ k ] - a [ j ] ) ; let fourth = ( a [ k ] * a [ k ] ) / a [ j ] ; if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) { if ( a [ j ] != a [ k ] ) { if ( mp . has ( first ) && mp . has ( fourth ) ) count += mp . get ( first ) * mp . get ( fourth ) ; } else if ( mp . has ( first ) && mp . has ( fourth ) ) count += mp . get ( first ) * ( mp . get ( fourth ) - 1 ) ; } if ( mp . has ( a [ j ] ) ) { mp . set ( a [ j ] , mp . get ( a [ j ] ) + 1 ) ; } else { mp . set ( a [ j ] , 1 ) ; } if ( mp . has ( a [ k ] ) ) { mp . set ( a [ k ] , mp . get ( a [ k ] ) + 1 ) ; } else { mp . set ( a [ k ] , 1 ) ; } } } return count ; }
function getTime ( u , v , x ) { let speed = u + v ; let time = x / speed ; return time ; }
function number_of_teams ( M ) { var N1 , N2 , sqr ; sqr = parseInt ( Math . sqrt ( 1 + ( 8 * M ) ) ) ; N1 = ( 1 + sqr ) / 2 ; N2 = ( 1 - sqr ) / 2 ; if ( N1 > 0 ) return N1 ; return N2 ; }
function power ( x , y ) { let p = mod ; let res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
function solve ( n , k ) { if ( n == 1 ) return 0 ; return ( power ( ( k - 1 ) , n - 1 ) % mod - solve ( n - 1 , k ) + mod ) % mod ; }
function findMinimum ( x , y ) { let low = 0 , high = y ; while ( low <= high ) { let mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }
function LucasSum ( N ) { var sum = 0 ; var a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; var c = a + b ; a = b ; b = c ; } return sum ; }
function sumOfDigits ( x ) { let sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = Math . floor ( x / 10 ) ; } return sum ; }
function countNumbers ( l , r ) { let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { if ( i % 2 == 0 && sumOfDigits ( i ) % 3 === 0 ) count ++ ; } return count ; }
function countNumbers ( l , r ) { return ( parseInt ( r / 6 ) - parseInt ( ( l - 1 ) / 6 ) ) ; }
function countNumbers ( L , R , K ) { if ( K == 9 ) { K = 0 ; } var totalnumbers = R - L + 1 ; var factor9 = totalnumbers / 9 ; var rem = totalnumbers % 9 ; var ans = factor9 ; for ( var i = R ; i > R - rem ; i -- ) { var rem1 = i % 9 ; if ( rem1 == K ) { ans ++ ; } } return ans ; }
function countWays ( N ) { let E = parseInt ( ( N * ( N - 1 ) ) / 2 , 10 ) ; if ( N == 1 ) return 0 ; return Math . pow ( 2 , E - 1 ) ; }
function BalanceArray ( A , Q ) { var ANS = [ ] ; var i , sum = 0 ; for ( i = 0 ; i < A . length ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . length ; i ++ ) { var index = Q [ i ] [ 0 ] ; var value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS . push ( sum ) ; } for ( i = 0 ; i < ANS . length ; i ++ ) document . write ( ANS [ i ] + "▁" ) ; }
function findMinSum ( arr , n ) { var occ = n - 1 , sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * Math . pow ( 2 , occ ) ; occ -- ; } return sum ; }
function findPowerOfP ( N , p ) { var count = 0 ; var r = p ; while ( r <= N ) { count += ( N / r ) ; r = r * p ; } return count ; }
function primeFactorsofB ( B ) { var ans = [ ] ; for ( var i = 2 ; B != 1 ; i ++ ) { if ( B % i == 0 ) { var count = 0 ; while ( B % i == 0 ) { B = B / i ; count ++ ; } ans . push ( [ i , count ] ) ; } } return ans ; }
function largestPowerOfB ( N , B ) { var vec = [ ] ; vec = primeFactorsofB ( B ) ; var ans = Number . MAX_VALUE ; for ( var i = 0 ; i < vec . length ; i ++ ) ans = Math . min ( ans , Math . floor ( findPowerOfP ( N , vec [ i ] [ 0 ] ) / vec [ i ] [ 1 ] ) ) ; return ans ; }
function maxLenSubArr ( a , n ) { let count , j ; let cm = 1 , max = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; } for ( let i = 0 ; i < n - 1 ; ) { count = 1 ; if ( a [ i ] == a [ i + 1 ] && a [ i ] == max ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] == max ) { count ++ ; i ++ ; } else break ; } if ( count > cm ) cm = count ; } else i ++ ; } return cm ; }
function minSum ( arr , n , x ) { var sum = 0 ; var largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; var sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . min ( sum , sumAfterOperation ) ; }
function parity ( a ) { return a % 3 ; }
function solve ( array , size ) { var operations = 0 ; for ( var i = 0 ; i < size - 1 ; i ++ ) { if ( parity ( array [ i ] ) == parity ( array [ i + 1 ] ) ) { operations ++ ; if ( i + 2 < size ) { var pari1 = parity ( array [ i ] ) ; var pari2 = parity ( array [ i + 2 ] ) ; if ( pari1 == pari2 ) { if ( pari1 == 0 ) array [ i + 1 ] = 1 ; else if ( pari1 == 1 ) array [ i + 1 ] = 0 ; else array [ i + 1 ] = 1 ; } else { if ( ( pari1 == 0 && pari2 == 1 ) || ( pari1 == 1 && pari2 == 0 ) ) array [ i + 1 ] = 2 ; if ( ( pari1 == 1 && pari2 == 2 ) || ( pari1 == 2 && pari2 == 1 ) ) array [ i + 1 ] = 0 ; if ( ( pari1 == 2 && pari2 == 0 ) || ( pari1 == 0 && pari2 == 2 ) ) array [ i + 1 ] = 1 ; } } } } return operations ; }
function findDigitalRoot ( num ) { var sum = Number . MAX_VALUE , tempNum = num ; while ( sum >= 10 ) { sum = 0 ; while ( tempNum > 0 ) { sum += tempNum % 10 ; tempNum = parseInt ( tempNum / 10 ) ; } tempNum = sum ; } return sum ; }
function findAnswer ( X , N ) { var counter = 0 ; for ( var i = 1 ; counter < N ; ++ i ) { var digitalRoot = findDigitalRoot ( i ) ; if ( digitalRoot == X ) { counter += 1 ; } if ( counter == N ) { document . write ( i ) ; break ; } } }
function findAnswer ( X , N ) { return ( N - 1 ) * 9 + X ; }
function preComputeXor ( arr , prefix_xor ) { for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < n ; j ++ ) { if ( j == 0 ) prefix_xor [ i ] [ j ] = arr [ i ] [ j ] ; else prefix_xor [ i ] [ j ] = ( prefix_xor [ i ] [ j - 1 ] ^ arr [ i ] [ j ] ) ; } for ( i = 0 ; i < n ; i ++ ) for ( j = 1 ; j < n ; j ++ ) prefix_xor [ j ] [ i ] = ( prefix_xor [ j - 1 ] [ i ] ^ prefix_xor [ j ] [ i ] ) ; }
function ansQuerie ( prefix_xor , x1 , y1 , x2 , y2 ) { var xor_1 = 0 , xor_2 = 0 , xor_3 = 0 ; if ( x1 != 0 ) xor_1 = prefix_xor [ x1 - 1 ] [ y2 ] ; if ( y1 != 0 ) xor_2 = prefix_xor [ x2 ] [ y1 - 1 ] ; if ( x1 != 0 && y1 != 0 ) xor_3 = prefix_xor [ x1 - 1 ] [ y1 - 1 ] ; return ( ( prefix_xor [ x2 ] [ y2 ] ^ xor_1 ) ^ ( xor_2 ^ xor_3 ) ) ; }
function LucasSequence ( arr , n ) { var max = arr . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var s = [ ] ; var a = 2 , b = 1 , c ; s . push ( a ) ; s . push ( b ) ; while ( b < max ) { var c = a + b ; a = b ; b = c ; s . push ( b ) ; } s . sort ( ( a , b ) => a - b )  var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s . includes ( arr [ i ] ) ) { s . pop ( arr [ i ] ) ; count ++ ; } } return count ; }
function matrixSum ( arr ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) { let top_left = ( i + 1 ) * ( j + 1 ) ; let bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } return sum ; }
function maxAND ( L , R ) { var maximum = L & R ; for ( var i = L ; i < R ; i ++ ) for ( var j = i + 1 ; j <= R ; j ++ ) maximum = Math . max ( maximum , ( i & j ) ) ; return maximum ; }
function maxAND ( L , R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }
function checkArray ( arr , n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; }
function findCount ( arr , n ) { var countOdd = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }
function isPerfectSquare ( x ) { let sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
function Prime_Numbers ( n ) { let primes = SieveOfEratosthenes ( ) ; for ( let i = 0 ; i < primes . length - 1 ; i ++ ) if ( primes [ i ] + primes [ i + 1 ] + 1 < N ) can [ primes [ i ] + primes [ i + 1 ] + 1 ] = true ; let ans = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( can [ i ] && isprime [ i ] ) { ans ++ ; } } return ans ; }
function printPermutation ( n , k ) { for ( var i = 1 ; i <= n ; i ++ ) { var x = 2 * i - 1 ; var y = 2 * i ; if ( i <= k ) document . write ( y + "▁" + x + "▁" ) ; else document . write ( x + "▁" + y + "▁" ) ; } }
function isPossible ( Sx , Sy , Dx , Dy , x , y ) { if ( Math . abs ( Sx - Dx ) % x == 0 && Math . abs ( Sy - Dy ) % y == 0 && ( Math . abs ( Sx - Dx ) / x ) % 2 == ( Math . abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; }
function getPairs ( a ) { let n = a . length ; let count = parseInt ( ( n * ( n - 1 ) ) / 2 , 10 ) ; return count ; }
function isDigitSumOne ( nm ) { if ( nm % 9 == 1 ) return true ; else return false ; }
function printValidNums ( n ) { let cbrt_n = Math . ceil ( Math . pow ( n , 1 / 3 ) ) ; for ( let i = 1 ; i <= cbrt_n ; i ++ ) { let cube = Math . pow ( i , 3 ) ; if ( cube >= 1 && cube <= n && isDigitSumOne ( cube ) ) document . write ( cube + "▁" ) ; } }
function isDigitSumOne ( nm ) { while ( nm > 9 ) { let sum_digit = 0 ; while ( nm > 0 ) { let digit = nm % 10 ; sum_digit = sum_digit + digit ; nm = Math . floor ( nm / 10 ) ; } nm = sum_digit ; } if ( nm == 1 ) return true ; else return false ; }
function printValidNums ( l , r ) { for ( let i = l ; i <= r ; i ++ ) { if ( isComposite ( i ) && isDigitSumOne ( i ) ) document . write ( i + "▁" ) ; } }
function initialize ( ) { l [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i < 1001 ; i ++ ) { l [ i ] [ 0 ] = 1 ; for ( let j = 1 ; j < i + 1 ; j ++ ) { l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } }
function nCr ( n , r ) { return l [ n ] [ r ] ; }
function countRhombi ( h , w ) { let ct = 0 ; for ( let i = 2 ; i <= h ; i += 2 ) for ( let j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; }
function maxSum ( N ) { var ans = 0 ; for ( var u = 1 ; u <= N ; u ++ ) { for ( var v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; var degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; var degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; }
function countSquares ( row , column ) { var topLeft = Math . min ( row , column ) - 1 ; var bottomRight = 8 - Math . max ( row , column ) ; var topRight = Math . min ( row , 9 - column ) - 1 ; var bottomLeft = 8 - Math . max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; }
function cal_factorial ( ) { arr [ 0 ] = 1 ; for ( let i = 1 ; i <= 1000000 ; i ++ ) { arr [ i ] = ( ( arr [ i - 1 ] * i ) % mod ) ; } }
function mod_exponent ( num , p ) { if ( p != 0 ) return 1 ; if ( ( p & 1 ) != 0 ) { return ( ( num % mod ) * ( mod_exponent ( ( num * num ) % mod , parseInt ( p / 2 , 10 ) ) ) % mod ) % mod ; } else return ( mod_exponent ( ( num * num ) % mod , parseInt ( p / 2 , 10 ) ) ) % mod ; }
function getCount ( x , y ) { let ans = arr [ x + y - 1 ] ; ans *= 0 * mod_exponent ( arr [ x ] , mod - 2 ) ; ans ++ ; ans %= mod ; ans *= mod_exponent ( arr [ y ] , mod - 2 ) ; ans %= mod ; ans *= ( x - y ) ; ans %= mod ; return ans ; }
function calculateArea ( x , y ) { var pi = 3.1415926536 ; var arx = pi * x * x ; var ary = pi * y * y ; return arx - ary ; }
function findValues ( a , b ) { if ( ( a - b ) % 2 == 1 ) { document . write ( "-1" ) ; return ; } document . write ( ( a - b ) / 2 + "▁" + ( a + b ) / 2 ) ; }
function minValue ( n , x , y ) { let val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( Math . ceil ( val ) - x ) ; }
function countTriplets ( n , points ) { var pts = new Set ( ) ; var ct = 0 ; for ( var i = 0 ; i < n ; i ++ ) pts . add ( points [ i ] . toString ( ) ) ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) { var x = points [ i ] [ 0 ] + points [ j ] [ 0 ] ; var y = points [ i ] [ 1 ] + points [ j ] [ 1 ] ; if ( x % 2 == 0 && y % 2 == 0 ) if ( pts . has ( [ ( x / 2 ) , ( y / 2 ) ] . toString ( ) ) ) ct ++ ; } return ct ; }
function getWinner ( arr , n ) { let gcd = arr [ 0 ] ; let maxEle = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { gcd = __gcd ( gcd , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } let totalMoves = parseInt ( maxEle / gcd , 10 ) - n ; if ( totalMoves % 2 == 1 ) return "A" ; return "B" ; }
function maximumFactor ( arr ) { var n = arr . length ; var rank = [ ] ; var factors = [ ] ; var max = arr . reduce ( ( a , b ) => Math . max ( a , b ) ) ; for ( var i = 2 ; i <= max ; i ++ ) { var count = 0 ; for ( var j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % i == 0 ) count += 1 ; rank . push ( count ) ; factors . push ( i ) ; } } var m = rank . reduce ( ( a , b ) => Math . max ( a , b ) ) ; for ( var i = 0 ; i < rank . length ; i ++ ) { if ( rank [ i ] == m ) document . write ( factors [ i ] + "▁" ) ; } }
function digitSum ( n ) { var ans = 0 ; while ( n ) { ans += n % 10 ; n = parseInt ( n / 10 ) ; } return ans ; }
function findInt ( n , m ) { var minDigit = Math . floor ( m / 9 ) ; var start = Math . pow ( 10 , minDigit ) - Math . pow ( 10 , minDigit ) % n ; while ( start < 1000000000 ) { if ( digitSum ( start ) == m ) return start ; else start += n ; } return - 1 ; }
function smallestDivisor ( n ) { var mx = Math . sqrt ( n ) ; for ( i = 2 ; i <= mx ; i ++ ) if ( n % i == 0 ) return i ; return n ; }
function maxSum ( n ) { var res = n ; while ( n > 1 ) { var divi = smallestDivisor ( n ) ; n /= divi ; res += n ; } return res ; }
function power ( x , y ) { var ans = 1 ; while ( y > 0 ) { if ( ( y & 1 ) > 0 ) ans = ( ans * x ) % MOD ; y >>= 1 ; x = ( x * x ) % MOD ; } return ans % MOD ; }
function modInverse ( x ) { return power ( x , MOD - 2 ) ; }
function countNumbers ( n , a , b ) { var fact = Array ( MAX ) . fill ( 0 ) ; var inv = Array ( MAX ) . fill ( 0 ) ; var ans = 0 ; fact [ 0 ] = 1 ; for ( var i = 1 ; i < MAX ; i ++ ) { fact [ i ] = ( 1 * fact [ i - 1 ] * i ) ; fact [ i ] %= MOD ; } inv [ MAX - 1 ] = modInverse ( fact [ MAX - 1 ] ) ; for ( i = MAX - 2 ; i >= 0 ; i -- ) { inv [ i ] = ( inv [ i + 1 ] * ( i + 1 ) ) ; inv [ i ] %= MOD ; } if ( a < b ) { var x = a ; a = b ; b = x ; } for ( s = n ; s <= 9 * n ; s ++ ) { if ( ! check ( s , a , b ) ) continue ; if ( s < n * b || ( s - n * b ) % ( a - b ) != 0 ) continue ; var numDig = parseInt ( ( ( s - n * b ) / ( a - b ) ) ) ; if ( numDig > n ) continue ; var curr = fact [ parseInt ( n ) ] ; curr = ( curr * inv [ numDig ] ) % MOD ; curr = ( curr * inv [ parseInt ( n - numDig ) ] ) % MOD ; ans = ( ans + curr ) % MOD ; } return ans ; }
function countOddSquares ( n , m ) { return Math . pow ( m , 0.5 ) - Math . pow ( n - 1 , 0.5 ) ; }
function Square ( row , column , moves ) { var a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }
function findNumber ( n , m ) { var num = ( m - 1 ) * 9 + n ; return num ; }
function count ( node ) { if ( node == null ) return 0 ; return count ( node . left ) + count ( node . right ) + 1 ; }
function checkRec ( node , n ) { if ( node == null ) return false ; if ( count ( node ) == n - count ( node ) ) return true ; return checkRec ( node . left , n ) || checkRec ( node . right , n ) ; }
function check ( node ) { let n = count ( node ) ; return checkRec ( node , n ) ; }
function maxResult ( n , a , b , c ) { let maxVal = 0 ; for ( let i = 0 ; i <= n ; i += a ) for ( let j = 0 ; j <= n - i ; j += b ) { let z = ( n - ( i + j ) ) / c ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { let x = i / a ; let y = j / b ; maxVal = Math . max ( maxVal , x + y + z ) ; } } return maxVal ; }
function digitsCount ( n ) { let len = 0 ; while ( n > 0 ) { len ++ ; n = Math . floor ( n / 10 ) ; } return len ; }
function absoluteFirstLast ( n , x ) { let i = 0 , mod = 1 ; while ( i < x ) { mod *= 10 ; i ++ ; } let last = n % mod ; let len = digitsCount ( n ) ; while ( len != x ) { n = Math . floor ( n / 10 ) ; len -- ; } let first = n ; return Math . abs ( first - last ) ; }
function EqualNumbers ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] = parseInt ( a [ i ] / 2 , 10 ) ; } while ( a [ i ] % 3 == 0 ) { a [ i ] = parseInt ( a [ i ] / 3 , 10 ) ; } if ( a [ i ] != a [ 0 ] ) { return false ; } } return true ; }
function make_sequence ( N ) { var arr = Array ( N + 1 ) , sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) arr [ i ] = 1 ; else arr [ i ] = 2 ; sum += arr [ i ] ; } if ( sum % 2 == 1 ) arr [ 2 ] = 3 ; for ( var i = 1 ; i <= N ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function countOdd ( L , R ) { let N = Math . floor ( ( R - L ) / 2 ) ; if ( R % 2 != 0 L % 2 != 0 ) N += 1 ; return N ; }
function getMinCost ( n , m ) { let cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; }
function minOperation ( n , k , a ) { for ( i = k ; i < n ; i ++ ) { if ( a [ i ] != a [ k - 1 ] ) document . write ( - 1 ) ; } for ( i = k - 2 ; i > - 1 ; i -- ) { if ( a [ i ] != a [ k - 1 ] ) document . write ( i + 1 ) ; } }
function digitWell ( n , m , k ) { var cnt = 0 ; while ( n > 0 ) { if ( n % 10 == m ) ++ cnt ; n = Math . floor ( n / 10 ) ; } if ( cnt == k ) return true ; else return false ; }
function findInt ( n , m , k ) { var i = n + 1 ; while ( true ) { if ( digitWell ( i , m , k ) ) return i ; i ++ ; } }
function minAbsDiff ( n ) { let mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; }
function generateSequence ( n , g ) { for ( var i = 1 ; i <= n ; i ++ ) { document . write ( i * g + "▁" ) ; } }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function findLCMFibonacci ( a , b ) { return ( fib ( a ) * fib ( b ) ) / fib ( gcd ( a , b ) ) ; }
function getMinNum ( a , b , c ) { if ( c < a c > b ) return c ; let x = ( parseInt ( b / c ) * c ) + c ; return x ; }
function isEvenOrOdd ( L , R ) { let oddCount = Math . floor ( ( R - L ) / 2 ) ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return "Even" ; else return "Odd" ; }
function trailing_zeros ( N ) { let count_of_two = 0 , count_of_five = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { let val = i ; while ( val % 2 == 0 && val > 0 ) { val = parseInt ( val / 2 ) ; count_of_two += i ; } while ( val % 5 == 0 && val > 0 ) { val = parseInt ( val / 5 ) ; count_of_five += i ; } } let ans = Math . min ( count_of_two , count_of_five ) ; return ans ; }
function SieveOfEratosthenes ( n ) { prime . fill ( true ) ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( let p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { b [ j ++ ] = p ; } } }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function Sieve ( ) { for ( let i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( let j = 2 * i ; j < MAX ; j += i ) { prime [ j ] = 1 ; } } } }
function countPairs ( n ) { let num = ( parseInt ( n / 2 , 10 ) + 1 ) ; let max = n % num ; let count = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { let val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; }
function countPairs ( n ) { if ( n == 2 ) return 4 ; let num = ( parseInt ( n / 2 , 10 ) + 1 ) ; let max = n % num ; let count = n - max ; return count ; }
function countOdd ( arr , n ) { var odd = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; } return odd ; }
function countValidPairs ( arr , n ) { var odd = countOdd ( arr , n ) ; return ( odd * ( odd - 1 ) ) / 2 ; }
function getMultiple ( s ) { for ( let i = 0 ; i < 1e3 ; i += 8 ) { if ( checkSub ( i . toString ( ) , s ) ) return i ; } return - 1 ; }
function alter ( x , y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } document . write ( "X▁=▁" + x + ",▁" + "Y▁=▁" + y ) ; }
function digitProduct ( n ) { let prod = 1 ; while ( n > 0 ) { prod = prod * ( n % 10 ) ; n = Math . floor ( n / 10 ) ; } return prod ; }
function printMultiplicativePrimes ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( let i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] && prime [ digitProduct ( i ) ] ) document . write ( i + "▁" ) ; } }
function gcd ( a , b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
function coPrime ( n1 , n2 ) { if ( gcd ( n1 , n2 ) == 1 ) return true ; else return false ; }
function largestCoprime ( N ) { let half = Math . floor ( N / 2 ) ; while ( coPrime ( N , half ) == false ) half -- ; return half ; }
function largestCoprime ( N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
function sieve ( maxEle , prime ) { prime [ 0 ] = prime [ 1 ] = 1 ; for ( var i = 2 ; i * i <= maxEle ; i ++ ) { if ( ! prime [ i ] ) { for ( var j = 2 * i ; j <= maxEle ; j += i ) prime [ j ] = 1 ; } } }
function digitSum ( n ) { var sum = 0 ; while ( n ) { sum += n % 10 ; n = parseInt ( n / 10 ) ; } return sum ; }
function printAdditivePrime ( arr , n ) { var maxEle = arr . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var prime = Array ( maxEle + 1 ) . fill ( 0 ) ; sieve ( maxEle , prime ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == 0 ) { var sum = digitSum ( arr [ i ] ) ; if ( prime [ sum ] == 0 ) document . write ( arr [ i ] + "▁" ) ; } } }
function printSafePrimes ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 2 ; i <= n ; i ++ ) prime [ i ] = 1 ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == 1 ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = 0 ; } } for ( let i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] != 0 ) { let temp = ( 2 * i ) + 1 ; if ( temp <= n && prime [ temp ] != 0 ) prime [ temp ] = 2 ; } } for ( let i = 5 ; i <= n ; i ++ ) if ( prime [ i ] == 2 ) document . write ( i + "▁" ) ; }
function sum ( n ) { let i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }
function sum ( n ) { if ( n < 2 ) { return 1 } else { return 1 / n + ( sum ( n - 1 ) ) } }
function findSum ( m , n , mth , nth , p ) { let ad = findingValues ( m , n , mth , nth ) ; let a = ad [ 0 ] ; let d = ad [ 1 ] ; let sum = parseInt ( ( p * ( 2 * a + ( p - 1 ) * d ) ) / 2 , 10 ) ; return sum ; }
function ABUNDANT ( ) { var v = new Set ( ) ; var i , j ; for ( i = 1 ; i < N ; i ++ ) { var sum = 1 ; for ( j = 2 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { sum += j ; if ( parseInt ( i / j ) != j ) sum += parseInt ( i / j ) ; } } if ( sum > i ) v . add ( i ) ; } return v ; }
function SumOfAbundant ( n ) { var v = new Set ( ) ; v = ABUNDANT ( ) ; var i ; for ( i = 1 ; i <= n ; i ++ ) { if ( v . has ( i ) && v . has ( n - i ) ) { document . write ( i + "▁" + ( n - i ) ) return ; } } document . write ( - 1 ) ; }
function nthTermOfTheSeries ( n ) { let nthTerm ; if ( n % 2 == 0 ) nthTerm = Math . pow ( n - 1 , 2 ) + n ; else nthTerm = Math . pow ( n + 1 , 2 ) + n ; return nthTerm ; }
function Divisors ( x ) { var c = 0 ; var v = [ ] ; while ( x % 2 == 0 ) { c ++ ; x /= 2 ; } v . push ( c ) ; c = 0 ; while ( x % 3 == 0 ) { c ++ ; x /= 3 ; } v . push ( c ) ; c = 0 ; while ( x % 7 == 0 ) { c ++ ; x /= 7 ; } v . push ( c ) ; v . push ( x ) ; return v ; }
function MinOperations ( a , b ) { var va = Divisors ( a ) ; var vb = Divisors ( b ) ; if ( va [ 3 ] != vb [ 3 ] ) { return - 1 ; } var minOperations = Math . abs ( va [ 0 ] - vb [ 0 ] ) + Math . abs ( va [ 1 ] - vb [ 1 ] ) + Math . abs ( va [ 2 ] - vb [ 2 ] ) ; return minOperations ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
function lcmOfArray ( arr , n ) { if ( n < 1 ) return 0 ; let lcm = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) lcm = parseInt ( ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ) ; return lcm ; }
function candies ( n , k ) { var count = 0 ; var ind = 1 ; var arr = Array ( k ) . fill ( 0 ) ; for ( i = 0 ; i < k ; i ++ ) arr [ i ] = 0 ; var low = 0 , high = n ; while ( low <= high ) { var mid = parseInt ( ( low + high ) / 2 ) ; var sum = parseInt ( ( mid * ( mid + 1 ) ) / 2 ) ; if ( sum <= n ) { count = parseInt ( mid / k ) ; low = mid + 1 ; } else { high = mid - 1 ; } } var last = ( count * k ) ; n -= ( last * ( last + 1 ) ) / 2 ; var j = 0 ; var term = ( count * k ) + 1 ; while ( n > 0 ) { if ( term <= n ) { arr [ j ++ ] = term ; n -= term ; term ++ ; } else { arr [ j ] += n ; n = 0 ; } } for ( i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( i = 0 ; i < k ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function CPwithLoss ( sellingPrice , loss ) { var costPrice ; costPrice = ( sellingPrice * 100 ) / ( 100 - loss ) ; return costPrice ; }
function printArr ( arr , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) document . write ( arr [ i ] + "▁" ) ; document . write ( arr [ n - 1 ] . toFixed ( 6 ) ) ; }
function replaceMax ( arr , n ) { let max = arr [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } let min = arr [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } let range = max - min ; let coeffOfRange = range / ( max + min ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max ) { arr [ i ] = coeffOfRange ; break ; } } printArr ( arr , n ) ; }
function largestOddDigit ( n ) { var maxOdd = - 1 ; while ( n > 0 ) { var digit = n % 10 ; if ( digit % 2 == 1 && digit > maxOdd ) maxOdd = digit ; n = n / 10 ; } return maxOdd ; }
function getProduct ( n ) { var maxOdd = largestOddDigit ( n ) ; if ( maxOdd == - 1 ) return - 1 ; return ( n * maxOdd ) ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function commDiv ( a , b ) { let n = gcd ( a , b ) ; a = parseInt ( a / n , 10 ) ; b = parseInt ( b / n , 10 ) ; document . write ( "A▁=▁" + a + ",▁B▁=▁" + b ) ; }
function minAbsDiff ( n ) { let left = 1 << ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; let right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; }
function FindAllElements ( n , k ) { let sum = k ; let A = new Array ( k ) . fill ( 1 ) ; for ( let i = k - 1 ; i >= 0 ; -- i ) { while ( sum + A [ i ] <= n ) { sum += A [ i ] ; A [ i ] *= 2 ; } } if ( sum != n ) { document . write ( "Impossible" ) ; } else { for ( let i = 0 ; i < k ; ++ i ) document . write ( A [ i ] + "▁" ) ; } }
function isEqual ( a , b ) { if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) return true ; return false ; }
function isPerfectSquare ( x ) { let left = 1 , right = x ; while ( left <= right ) { let mid = parseInt ( ( left + right ) / 2 ) ; if ( mid * mid == x ) { return true ; } if ( mid * mid < x ) { left = mid + 1 ; } else { right = mid - 1 ; } } return false ; }
function isStrongPrime ( n ) { if ( ! isPrime ( n ) n == 2 ) return false ; let previous_prime = n - 1 ; let next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; let mean = parseInt ( ( previous_prime + next_prime ) / 2 ) ; if ( n > mean ) return true ; else return false ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function isFactorialPrime ( n ) { if ( ! isPrime ( n ) ) return false ; let fact = 1 ; let i = 1 ; while ( fact <= n + 1 ) { fact = fact * i ; if ( n + 1 == fact n - 1 == fact ) return true ; i ++ ; } return false ; }
function sumArray ( arr , n ) { let leftSum = new Array ( n ) ; let rightSum = new Array ( n ) ; let Sum = new Array ( n ) ; let i = 0 , j = 0 ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) document . write ( Sum [ i ] + "▁" ) ; }
function LcmSum ( m ) { ETF ( ) ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = i ; j <= n ; j += i ) { ans [ j ] += ( i * phi [ i ] ) ; } } var answer = ans [ m ] ; answer = ( answer + 1 ) * m ; answer = answer / 2 ; return answer ; }
function factorial ( n ) { let fact = 1 ; for ( let i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
function ncr ( n , r ) { return Math . floor ( factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ) ; }
function countWays ( str ) { let freq = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { freq [ i ] = 0 ; } let nvowels = 0 , nconsonants = 0 ; let vplaces , cways , vways ; for ( let i = 0 ; i < str . length ; i ++ ) ++ freq [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) nvowels += freq [ i ] ; else nconsonants += freq [ i ] ; } vplaces = nconsonants + 1 ; cways = factorial ( nconsonants ) ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 && freq [ i ] > 1 ) { cways = Math . floor ( cways / factorial ( freq [ i ] ) ) ; } } vways = ncr ( vplaces , nvowels ) * factorial ( nvowels ) ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 && freq [ i ] > 1 ) { vways = Math . floor ( vways / factorial ( freq [ i ] ) ) ; } } return cways * vways ; }
function setBits ( n ) { let count = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; }
function countPairs ( a , n ) { let count = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let setbits_x = setBits ( a [ i ] ) ; for ( let j = i + 1 ; j < n ; j ++ ) { let setbits_y = setBits ( a [ j ] ) ; let setbits_xor_xy = setBits ( a [ i ] ^ a [ j ] ) ; if ( setbits_x + setbits_y == setbits_xor_xy ) count ++ ; } } return count ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function findPossibleDerivables ( arr , n , D , A , B ) { var gcdAB = gcd ( A , B ) ; var counter = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( ( Math . abs ( arr [ i ] - D ) % gcdAB ) == 0 ) { counter ++ ; } } return counter ; }
function calSum ( n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; }
function maxOfMin ( a , n , S ) { let mi = Number . MAX_VALUE ; let s1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s1 += a [ i ] ; mi = Math . min ( a [ i ] , mi ) ; } if ( s1 < S ) return - 1 ; if ( s1 == S ) return 0 ; let low = 0 ; let high = mi ; let ans = 0 ; while ( low <= high ) { let mid = parseInt ( ( low + high ) / 2 , 10 ) ; if ( s1 - ( mid * n ) >= S ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
function getElements ( a , arr , n ) { let elements = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { elements [ i ] = 0 ; } elements [ 0 ] = a ; for ( let i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( let i = 0 ; i < n + 1 ; i ++ ) document . write ( elements [ i ] + "▁" ) ; }
function minimumX ( n , k ) { let mini = Number . MAX_VALUE ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { let fir = i ; let sec = parseInt ( n / i , 10 ) ; let num1 = fir * k + sec ; let res = parseInt ( ( num1 / k ) , 10 ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; let num2 = sec * k + fir ; res = parseInt ( ( num2 / k ) , 10 ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } return mini ; }
function minimumX ( n , k ) { let ans = Number . MAX_VALUE ; for ( let rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . min ( ans , rem + ( n / rem ) * k ) ; } return ans ; }
function maxGCD ( N , P ) { let ans = 1 ; let prime_factors = new Map ( ) ; for ( let i = 2 ; i * i <= P ; i ++ ) { while ( P % i == 0 ) { if ( prime_factors . get ( i ) == null ) prime_factors . set ( i , 1 ) ; else prime_factors . set ( i , ( prime_factors . get ( i ) + 1 ) ) ; P = Math . floor ( P / i ) ; } } if ( P != 1 ) prime_factors [ P ] ++ ; console . log ( prime_factors )  for ( let v of prime_factors ) { console . log ( v )  ans *= Math . pow ( v [ 0 ] , Math . floor ( v [ 1 ] / N ) ) ; } return ans ; }
function getSum ( arr , p ) { return arr . length ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function countPairs ( a , n ) { let count = 0 ; let m = new Map ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( isPrime ( a [ i ] ^ a [ j ] ) && ! m . has ( a [ i ] ^ a [ j ] ) ) { m . set ( ( a [ i ] ^ a [ j ] ) , 1 ) ; count ++ ; } } } return count ; }
function count ( node ) { if ( node == null ) return 0 ; return count ( node . left ) + count ( node . right ) + 1 ; }
function check ( root ) { var n = count ( root ) ; res = new Res ( ) ; checkRec ( root , n , res ) ; return res . res ; }
function countDivisors ( n ) { var x = 0 , ans = 1 ; while ( n % 2 == 0 ) { x ++ ; n = n / 2 ; } ans = ans * ( x + 1 ) ; for ( var i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { x = 0 ; while ( n % i == 0 ) { x ++ ; n = n / i ; } ans = ans * ( x + 1 ) ; } if ( n > 2 ) ans = ans * 2 ; return ans ; }
function getTotalCount ( n , k ) { var k_count = countDivisors ( k ) ; var count = 0 ; for ( var i = 1 ; i < n ; i ++ ) if ( k_count == countDivisors ( i ) ) count ++ ; if ( k < n ) count = count - 1 ; return count ; }
function getHermiteNumber ( n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
function doubleFactorial ( n ) { var fact = 1 ; for ( var i = 1 ; i <= n ; i = i + 2 ) { fact = fact * i ; } return fact ; }
function hermiteNumber ( n ) { if ( n % 2 == 1 ) return 0 ; else { var number = ( Math . pow ( 2 , n / 2 ) ) * doubleFactorial ( n - 1 ) ; if ( ( n / 2 ) % 2 == 1 ) number = number * - 1 ; return number ; } }
function find ( n ) { let b = n ; let a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { document . write ( "a▁=▁" + a + ",▁b▁=▁" + b ) ; } else document . write ( - 1 ) ; }
function SquareCube ( N ) { let cnt = 0 , i = 1 ; while ( Math . floor ( Math . pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }
function getSum ( n , d ) { let sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; }
function isPerfect ( N ) { if ( ( Math . sqrt ( N ) - Math . floor ( Math . sqrt ( N ) ) ) != 0 ) return false ; return true ; }
function printThreeParts ( N ) { if ( N % 3 == 0 ) document . write ( "▁x▁=▁1,▁y▁=▁1,▁z▁=▁" + ( N - 2 ) ) ; else document . write ( "▁x▁=▁1,▁y▁=▁2,▁z▁=▁" + ( N - 3 ) ) ; }
function sumX ( N , M , K ) { let MOD = 1000000007 ; for ( let i = 0 ; i < M ; i ++ ) { N = sum ( K + N ) ; } N = N % MOD ; return N ; }
function countDigitsToBeRemoved ( N , K ) { var s = N . toString ( ) ; var res = 0 ; var f_zero = 0 ; for ( var i = s . length - 1 ; i >= 0 ; i -- ) { if ( K === 0 ) return res ; if ( s [ i ] === "0" ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( K === 0 ) return res ; else if ( f_zero === 1 ) return s . length - 1 ; return - 1 ; }
function isPalindrome ( n ) { var divisor = 1 ; while ( parseInt ( n / divisor ) >= 10 ) divisor *= 10 ; while ( n != 0 ) { var leading = parseInt ( n / divisor ) ; var trailing = n % 10 ; if ( leading != trailing ) return false ; n = parseInt ( ( n % divisor ) / 10 ) ; divisor = parseInt ( divisor / 100 ) ; } return true ; }
function largestPalindrome ( A , n ) { ssort ( A , A . length ) ; for ( var i = n - 1 ; i >= 0 ; -- i ) { if ( isPalindrome ( A [ i ] ) ) return A [ i ] ; } return - 1 ; }
function isPalindrome ( n ) { var divisor = 1 ; while ( parseInt ( n / divisor ) >= 10 ) divisor *= 10 ; while ( n != 0 ) { var leading = parseInt ( n / divisor ) ; var trailing = n % 10 ; if ( leading != trailing ) return false ; n = parseInt ( ( n % divisor ) / 10 ) ; divisor = parseInt ( divisor / 100 ) ; } return true ; }
function largestPalindrome ( A , n ) { var currentMax = - 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( A [ i ] > currentMax && isPalindrome ( A [ i ] ) ) currentMax = A [ i ] ; } return currentMax ; }
function findSum ( n ) { let sum = 0 ; for ( x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
function isPrime ( N ) { for ( let i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; }
function findSum ( n , a , b ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; }
function gcd ( a , b ) { if ( a === 0 ) return b ; return gcd ( b % a , a ) ; }
function printMode ( a , n ) { let max = Number . MIN_VALUE ; for ( let i = 0 ; i < a . length ; i ++ ) { max = Math . max ( max , a [ i ] ) ; } let t = max + 1 ; let count = new Array ( t ) ; for ( let i = 0 ; i < t ; i ++ ) count [ i ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; let mode = 0 ; let k = count [ 0 ] ; for ( let i = 1 ; i < t ; i ++ ) { if ( count [ i ] > k ) { k = count [ i ] ; mode = i ; } } document . write ( "mode▁=▁" + mode ) ; }
function checkTypeOfTriangle ( a , b , c ) { let sqa = Math . floor ( Math . pow ( a , 2 ) ) ; let sqb = Math . floor ( Math . pow ( b , 2 ) ) ; let sqc = Math . floor ( Math . pow ( c , 2 ) ) ; if ( sqa == sqa + sqb sqb == sqa + sqc sqc == sqa + sqb ) { document . write ( "Right-angled▁Triangle" ) ; } else if ( sqa > sqc + sqb sqb > sqa + sqc sqc > sqa + sqb ) { document . write ( "Obtuse-angled▁Triangle" ) ; } else { document . write ( "Acute-angled▁Triangle" ) ; } }
function findLargestDivisor ( n ) { let m = n ; let s = new Set ( ) ; s . add ( 1 ) ; s . add ( n ) ; for ( let i = 2 ; i < Math . floor ( Math . sqrt ( n ) ) + 1 ; i ++ ) { if ( n % i == 0 ) { s . add ( Math . floor ( n / i ) ) ; s . add ( i ) ; while ( m % i == 0 ) m = Math . floor ( m / i ) ; } } if ( m > 1 ) s . add ( m ) ; let l = Array . from ( s ) ; l . sort ( function ( a , b ) { return a - b ; } ) ; l . reverse ( ) ; let vec = [ ] ; for ( let i = 2 ; i <= MAX ; i ++ ) vec . push ( i * i ) ; for ( let d = 0 ; d < l . length ; d ++ ) { let divi = 0 ; for ( let j = 0 ; j < vec . length && vec [ j ] <= l [ d ] ; j ++ ) { if ( l [ d ] % vec [ j ] == 0 ) { divi = 1 ; break ; } } if ( divi == 0 ) return l [ d ] ; } return 0 ; }
function findLargestDivisor ( n ) { for ( let i = 2 ; i < Math . sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; }
function findMedian ( a , n ) { a . sort ( ) ; if ( n % 2 != 0 ) return a [ parseInt ( n / 2 ) ] ; return ( a [ parseInt ( ( n - 1 ) / 2 ) ] + a [ parseInt ( n / 2 ) ] ) / 2.0 ; }
function printAMeans ( A , B , N ) { let d = ( B - A ) / ( N + 1 ) ; for ( let i = 1 ; i <= N ; i ++ ) document . write ( ( A + i * d ) + "▁" ) ; }
function getFinalElement ( n ) { let finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }
function checkIsAP ( arr , n ) { if ( n == 1 ) return true ; arr . sort ( compare ) ; let d = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
function isTriPerfect ( n ) { let sum = 1 + n ; let i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( parseInt ( n / i , 10 ) == i ) sum = sum + i ; else sum = sum + i + parseInt ( n / i , 10 ) ; } i += 1 ; } if ( sum == 3 * n & n != 1 ) return true ; else return false ; }
function findGreater ( a , b ) { var x = a * ( Math . log ( ( b ) ) ) ; var y = b * ( Math . log ( ( a ) ) ) ; if ( y > x ) { document . write ( "a^b▁is▁greater" ) ; } else if ( y < x ) { document . write ( "b^a▁is▁greater" ) ; } else { document . write ( "Both▁are▁equal" ) ; } }
function sum ( N , X , Y ) { var S1 , S2 , S3 ; S1 = ( parseInt ( N / X ) ) * ( 2 * X + parseInt ( N / X - 1 ) * X ) / 2 ; S2 = ( parseInt ( N / Y ) ) * ( 2 * Y + parseInt ( N / Y - 1 ) * Y ) / 2 ; S3 = ( parseInt ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + parseInt ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function modexp ( x , n ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , n / 2 ) ; } else { return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 ) % m ) ; } }
function getFractionModulo ( a , b ) { var c = gcd ( a , b ) ; a = a / c ; b = b / c ; var d = modexp ( b , m - 2 ) ; var ans = ( ( a % m ) * ( d % m ) ) % m ; return ans ; }
function startingPoint ( Length , Speed1 , Speed2 ) { var result1 = 0 , result2 = 0 ; var time1 = Length / Speed1 ; var time2 = Length / Speed2 ; result1 = __gcd ( time1 , time2 ) ; result2 = time1 * time2 / ( result1 ) ; return result2 ; }
function firstTime ( Length , Speed1 , Speed2 ) { var result = 0 ; var relativeSpeed = Math . abs ( Speed1 - Speed2 ) ; result = ( Length / relativeSpeed ) ; return result ; }
function findNumber ( n ) { var i = n - 1 ; while ( i > 0 ) { if ( sumOfDigits ( i ) > sumOfDigits ( n ) ) return i ; i -- ; } return - 1 ; }
function findTwoThreePrime ( l , r ) { if ( l == 1 ) l ++ ; let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { let num = i ; while ( num % 2 == 0 ) num = parseInt ( num / 2 , 10 ) ; while ( num % 3 == 0 ) num = parseInt ( num / 3 , 10 ) ; if ( num == 1 ) count ++ ; } return count ; }
function findNth ( N ) { let b = 14 ; for ( let i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; }
function icanobifNumbers ( N ) { let first = 0 , second = 1 ; if ( N == 1 ) document . write ( first ) ; else if ( N == 2 ) document . write ( first + "▁" + second ) ; else { document . write ( first + "▁" + second + "▁" ) ; for ( let i = 3 ; i <= N ; i ++ ) { let x = reversDigits ( first ) ; let y = reversDigits ( second ) ; document . write ( x + y + "▁" ) ; let temp = second ; second = x + y ; first = temp ; } } }
function addNDigits ( a , b , n ) { let num = a ; for ( let i = 0 ; i <= 9 ; i ++ ) { let tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return - 1 ; for ( let j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; }
function predictMatrix ( arr , range1a , range1b , range0a , range0b , K , b ) { let c = 0 ; while ( K != 0 ) { K -- ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { c = 0 ; if ( i > 0 && arr [ i - 1 ] [ j ] == 1 ) c ++ ; if ( j > 0 && arr [ i ] [ j - 1 ] == 1 ) c ++ ; if ( i > 0 && j > 0 && arr [ i - 1 ] [ j - 1 ] == 1 ) c ++ ; if ( i < N - 1 && arr [ i + 1 ] [ j ] == 1 ) c ++ ; if ( j < N - 1 && arr [ i ] [ j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j < N - 1 && arr [ i + 1 ] [ j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j > 0 && arr [ i + 1 ] [ j - 1 ] == 1 ) c ++ ; if ( i > 0 && j < N - 1 && arr [ i - 1 ] [ j + 1 ] == 1 ) c ++ ; if ( arr [ i ] [ j ] == 1 ) { if ( c >= range1a && c <= range1b ) b [ i ] [ j ] = 1 ; else b [ i ] [ j ] = 0 ; } if ( arr [ i ] [ j ] == 0 ) { if ( c >= range0a && c <= range0b ) b [ i ] [ j ] = 1 ; else b [ i ] [ j ] = 0 ; } } } for ( let k = 0 ; k < N ; k ++ ) for ( let m = 0 ; m < N ; m ++ ) arr [ k ] [ m ] = b [ k ] [ m ] ; } }
function countMoves ( n ) { let ct = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; }
function Triplets ( n ) { var ans = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = i ; j <= n ; ++ j ) { var x = i * i + j * j ; var y = parseInt ( Math . sqrt ( x ) ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; }
function countTriplets ( n ) { var perfectSquares = getPerfectSquares ( Math . pow ( n , 2 ) ) ; var count = 0 ; for ( var a = 1 ; a <= n ; a ++ ) { var aSquare = Math . pow ( a , 2 ) ; for ( var i = 0 ; i < perfectSquares . length ; i ++ ) { var cSquare = perfectSquares [ i ] ; var bSquare = Math . abs ( cSquare - aSquare ) ; var b = Math . sqrt ( bSquare ) ; var c = Math . sqrt ( cSquare ) ; if ( c < a || ! perfectSquares . includes ( bSquare ) ) continue ; if ( ( b >= a ) && ( b <= c ) && ( aSquare + bSquare == cSquare ) ) count ++ ; } } return count ; }
function SumsOfDigits ( n ) { var sum = 0 ; for ( base = 2 ; base <= n / 2 ; ++ base ) sum += solve ( n , base ) ; document . write ( sum ) ; }
function minimumMoves ( k , l , r ) { let count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; }
function checkPerfectcube ( n ) { let d = Math . cbrt ( n ) ; if ( d * d * d == n ) return true ; return false ; }
function largestNonPerfectcubeNumber ( a , n ) { let maxi = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! checkPerfectcube ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; }
function sumNatural ( n ) { let sum = Math . floor ( n * ( n + 1 ) ) ; return sum ; }
function checkIfPossibleRec ( x , a , b , isPossible , n ) { if ( x > n ) return ; if ( isPossible [ x ] ) return ; isPossible [ x ] = true ; checkIfPossibleRec ( x + a , a , b , isPossible , n ) ; checkIfPossibleRec ( x + b , a , b , isPossible , n ) ; }
function checkPossible ( n , a , b ) { var isPossible = Array ( n + 1 ) . fill ( false ) ; checkIfPossibleRec ( 0 , a , b , isPossible , n ) ; return isPossible [ n ] ; }
function isDivisibleRec ( x , a , b , n ) { if ( x > n ) return false ; if ( n % x == 0 ) return true ; return ( isDivisibleRec ( x * 10 + a , a , b , n ) || isDivisibleRec ( x * 10 + b , a , b , n ) ) ; }
function isDivisible ( a , b , n ) { return isDivisibleRec ( a , a , b , n ) || isDivisibleRec ( b , a , b , n ) ; }
function sumOdd ( n ) { terms = ( n + 1 ) / 2 ; sum = terms * terms ; return sum ; }
function suminRange ( l , r ) { return sumOdd ( r ) - sumOdd ( l - 1 ) ; }
function sumNatural ( n ) { sum = ( n * ( n + 1 ) ) / 2 ; return sum ; }
function suminRange ( l , r ) { return sumNatural ( r ) - sumNatural ( l - 1 ) ; }
function CheckArray ( arr , n ) { let prod = 1 ; for ( let i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( let i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; }
function CheckArray ( arr , n ) { let prod = 1 ; let freq = [ ] ; for ( let i = 0 ; i < n ; ++ i ) { freq . push ( arr [ i ] ) ; prod *= arr [ i ] ; } let root = Math . floor ( Math . sqrt ( prod ) ) ; if ( root * root == prod ) { if ( freq . includes ( root ) & freq . lastIndexOf ( root ) != ( freq . length ) ) { return true ; } } return false ; }
function sumOfAllPalindrome ( L , R ) { let sum = 0 ; if ( L <= R ) for ( let i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) && isOddLength ( i ) ) { sum += i ; } } return sum ; }
function divisibleBy25 ( number ) { if ( number . length < 2 ) return false ; let length = number . length ; let lastTwo = ( number [ length - 2 ] - "0" ) * 10 + ( number [ length - 1 ] - "0" ) ; if ( lastTwo % 25 == 0 ) return true ; return false ; }
function divisibleBy75 ( number ) { if ( divisibleBy3 ( number ) && divisibleBy25 ( number ) ) return true ; return false ; }
function breakEvenPoint ( exp , S , M ) { var earn = S - M ; var res = Math . ceil ( exp / earn ) ; return res ; }
function otherNumber ( A , Lcm , Hcf ) { return ( Lcm * Hcf ) / A ; }
function sum ( a , b ) { var sum = 0 ; for ( var i = 1 ; i <= Math . min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; }
function sumcommDiv ( a , b ) { var n = gcd ( a , b ) ; var sum = 0 ; for ( var i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum += i ; else sum += ( n / i ) + i ; } } return sum ; }
function minimumNumbers ( n , s ) { if ( s % n ) return parseInt ( s / n ) + 1 ; else return parseInt ( s / n ) ; }
function search ( arr , strt , end , value ) { for ( let i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) return i ; } return - 1 ; }
function checkPostorder ( node , postOrder , index ) { if ( node == null ) return index ; index = checkPostorder ( node . left , postOrder , index ) ; index = checkPostorder ( node . right , postOrder , index ) ; if ( node . data == postOrder [ index ] ) index ++ ; else return - 1 ; return index ; }
function sumAP ( n , d ) { n = parseInt ( n / d ) ; return ( n ) * ( 1 + n ) * d / 2 ; }
function sumMultiples ( A , B , n ) { n -- ; common = parseInt ( ( A * B ) / __gcd ( A , B ) ) ; return sumAP ( n , A ) + sumAP ( n , B ) - sumAP ( n , common ) ; }
function isPossible ( N ) { if ( isPrime ( N ) && isPrime ( N - 2 ) ) return true ; else return false ; }
function totalPairs ( arr1 , arr2 , K , n , m ) { var s = new Set ( ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] > arr2 [ j ] ) { if ( arr1 [ i ] % arr2 [ j ] == K ) s . add ( [ arr1 [ i ] , arr2 [ j ] ] ) ; } else { if ( arr2 [ j ] % arr1 [ i ] == K ) s . add ( [ arr2 [ j ] , arr1 [ i ] ] ) ; } } } return s . size ; }
function contiguousPerfectSquare ( arr , n ) { var a ; var b ; var current_length = 0 ; var max_length = 0 ; for ( var i = 0 ; i < n ; i ++ ) { b = ( Math . sqrt ( arr [ i ] ) ) ; a = parseInt ( b ) ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = Math . max ( max_length , current_length ) ; } return max_length ; }
function getSum ( a , n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { sum += ( i / Math . pow ( a , i ) ) ; } return sum ; }
function getIndex ( a , n ) { if ( n == 1 ) return 0 ; let ptrL = 0 , ptrR = n - 1 , sumL = a [ 0 ] , sumR = a [ n - 1 ] ; while ( ptrR - ptrL > 1 ) { if ( sumL < sumR ) { ptrL ++ ; sumL += a [ ptrL ] ; } else if ( sumL > sumR ) { ptrR -- ; sumR += a [ ptrR ] ; } else { break ; } } return ptrL ; }
function getPosition ( a , n , m ) { for ( let i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] / m + ( a [ i ] % m ) ) ; } let ans = - 1 , max = - 1 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( max < a [ i ] ) { max = a [ i ] ; ans = i ; } } return ans + 1 ; }
function calcFunction ( n , r ) { var finalDenominator = 1 ; var mx = Math . max ( r , n - r ) ; for ( var i = mx + 1 ; i <= n ; i ++ ) { var denominator = Math . pow ( i , i ) ; var numerator = Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
function generateNumbers ( n , num , a , b ) { if ( num > 0 && num < n ) st . add ( num ) ; if ( num >= n ) return ; if ( num * 10 + a > num ) generateNumbers ( n , num * 10 + a , a , b ) ; generateNumbers ( n , num * 10 + b , a , b ) ; }
function findSmallest ( arr , n ) { let MAX = arr . sort ( ( A , B ) => A - B ) . reverse ( ) [ 0 ] ; let prime = findPrime ( MAX ) ; let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) s . add ( arr [ i ] ) ; let ans = - 1 ; for ( let i = 0 ; i < prime . length ; i ++ ) { if ( ! s . has ( prime [ i ] ) ) { ans = prime [ i ] ; break ; } } return ans ; }
function minOperations ( A , n ) { if ( ( n & 1 ) > 0 ) return - 1 ; let zeros = 0 , consZeros = 0 , ones = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; }
function minimumCuts ( a , n ) { a . sort ( ) ; var gcd = a [ 1 ] - a [ 0 ] ; var s = gcd ; for ( i = 2 ; i < n ; i ++ ) { gcd = findgcd ( gcd , a [ i ] - a [ i - 1 ] ) ; s += a [ i ] - a [ i - 1 ] ; } if ( 360 - s > 0 ) gcd = findgcd ( gcd , 360 - s ) ; return ( 360 / gcd ) - n ; }
function countdig ( m ) { if ( m == 0 ) return 0 ; else return 1 + countdig ( parseInt ( m / 10 ) ) ; }
function countSteps ( x ) { var c = 0 ; var last = x ; while ( last > 0 ) { var digits = countdig ( last ) ; digits -= 1 ; var divisor = parseInt ( Math . pow ( 10 , digits ) ) ; var first = parseInt ( last / divisor ) ; var lastnumber = first * divisor ; var skipped = parseInt ( ( last - lastnumber ) / first ) ; skipped += 1 ; c += skipped ; last = last - ( first * skipped ) ; } return c ; }
function findNum ( div , rem , N ) { var num = rem [ N - 1 ] ; for ( var i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }
function profitLoss ( N , M ) { if ( N == M ) document . write ( "No▁Profit▁nor▁Loss" ) ; else { var result = 0.0 ; result = ( Math . abs ( N - M ) ) / M ; if ( N - M < 0 ) document . write ( "Loss▁=▁-" + result . toFixed ( 6 ) * 100 + "%" ) ; else document . write ( "Profit▁=▁" + result . toFixed ( 6 ) * 100 + "%" ) ; } }
function niceIndices ( A , n ) { var sum = 0 ; var m = new Map ( ) ; for ( var i = 0 ; i < n ; ++ i ) { if ( m . has ( A [ i ] ) ) m . set ( A [ i ] , m . get ( A [ i ] ) + 1 ) else m . set ( A [ i ] , 1 )  sum += A [ i ] ; } for ( var i = 0 ; i < n ; ++ i ) { var k = sum - A [ i ] ; if ( k % 2 == 0 ) { k = k >> 1 ; if ( m . has ( k ) ) { if ( ( A [ i ] == k && m . get ( k ) > 1 ) || ( A [ i ] != k ) ) document . write ( i + 1 + "▁" ) ; } } } }
function sieve ( ) { spf [ 1 ] = 1 ; for ( let i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( let i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( let i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( let j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
function getFactorization ( x ) { let ret = [ ] ; while ( x != 1 ) { let temp = spf [ x ] ; ret . push ( temp ) ; while ( x % temp == 0 ) x = Math . floor ( x / temp ) ; } return ret ; }
function maxElement ( A , n ) { sieve ( ) ; let m = new Map ( ) ; for ( let j = 0 ; j < n ; ++ j ) { let p = getFactorization ( A [ j ] ) ; for ( let i = 0 ; i < p . length ; i ++ ) m . set ( p [ i ] , m . get ( p [ i ] ) == null ? 0 : m . get ( p [ i ] ) + 1 ) ; } let cnt = 0 , ans = 10000000 ; for ( let [ key , value ] of m . entries ( ) ) { if ( value >= cnt ) { cnt = value ; if ( ans > key ) ans = key ; else ans = ans ; } } return ans ; }
function countPieces ( N ) { return 2 * N ; }
function SellingPrice ( CP , PP ) { var P_decimal = 1 + ( PP / 100 ) ; var res = P_decimal * CP ; return res . toFixed ( 1 ) ; }
function sumMultiples ( n ) { n -- ; return sumAP ( n , 3 ) + sumAP ( n , 7 ) - sumAP ( n , 21 ) ; }
function productSumDivisible ( n , size ) { var sum = 0 , product = 1 ; while ( n > 0 ) { if ( size % 2 == 0 ) { product *= n % 10 ; } else { sum += n % 10 ; } n = parseInt ( n / 10 ) ; size -- ; } if ( product % sum == 0 ) return true ; return false ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function powGCD ( a , n , b ) { for ( i = 0 ; i < n ; i ++ ) a = a * a ; return gcd ( a , b ) ; }
function power ( x , y , p ) { while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function powerGCD ( a , b , n ) { var e = power ( a , n , b ) ; return gcd ( e , b ) ; }
function lastCoordinate ( n , a , b ) { return ( parseInt ( n + 1 ) / 2 ) * a - parseInt ( n / 2 ) * b ; }
function allOddDigits ( n ) { while ( n != 0 ) { if ( ( n % 10 ) % 2 == 0 ) return false ; n = parseInt ( n / 10 ) ; } return true ; }
function largestNumber ( n ) { if ( parseInt ( n % 2 ) == 0 ) n -- ; for ( i = n ; i > 0 ; i -= 2 ) if ( allOddDigits ( i ) ) return i ; }
function findNum ( N , K ) { var rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
function countDigit ( n ) { let temp = n ; let sum = 0 ; let product = 1 ; while ( temp != 0 ) { let d = temp % 10 ; temp = parseInt ( temp / 10 ) ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } document . write ( "Sum▁=▁" + sum ) ; document . write ( "Product=" + product ) ; }
function findNum ( N , K ) { var rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
function isDivisiblePalindrome ( n ) { var hash = Array ( 10 ) . fill ( 0 ) ; var digitSum = 0 ; while ( n ) { digitSum += n % 10 ; hash [ n % 10 ] ++ ; n = parseInt ( n / 10 ) ; } if ( digitSum % 3 != 0 ) return false ; var oddCount = 0 ; for ( var i = 0 ; i < 10 ; i ++ ) { if ( hash [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount > 1 ) return false ; else return true ; }
function countNumbers ( N ) { return parseInt ( Math . sqrt ( N ) , 10 ) - 1 ; }
function countOrderedPairs ( N ) { var count_pairs = 0 ; for ( var i = 1 ; i <= Math . sqrt ( N - 1 ) ; ++ i ) { for ( var j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= parseInt ( Math . sqrt ( N - 1 ) ) ; return count_pairs ; }
function toK ( N , K ) { let w = 1 ; let s = 0 ; while ( N != 0 ) { let r = N % K ; N = parseInt ( N / K ) ; s = r * w + s ; w *= 10 ; } return s ; }
function hasConsecutiveZeroes ( N , K ) { let z = toK ( N , K ) ; if ( check ( z ) ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function check ( s ) { let freq = new Array ( 10 ) . fill ( 0 ) , r ; while ( s != 0 ) { r = s % 10 ; s = parseInt ( s / 10 ) ; freq [ r ] += 1 ; } let xor__ = 0 ; for ( let i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } }
function lcm ( a , b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; }
function dfs ( src , adj , visited ) { visited [ src ] = true ; let count = 1 ; for ( let i = 0 ; i < adj [ src ] . length ; i ++ ) if ( ! visited [ adj [ src ] [ i ] ] ) count += dfs ( adj [ src ] [ i ] , adj , visited ) ; return count ; }
function findMinTime ( arr , P , n ) { let adj = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) adj [ i ] = new Array ( ) ; for ( let i = 0 ; i < n ; i ++ ) { adj [ arr [ i ] ] . push ( P [ i ] ) ; } let visited = new Array ( n + 1 ) ; let ans = 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { ans = lcm ( ans , dfs ( i , adj , visited ) ) ; } } return ans ; }
function SieveOfEratosthenes ( ) { prime [ 1 ] = false ; prime [ 0 ] = false ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
function SieveOfEratosthenes ( ) { for ( var p = 2 ; p * p <= MAX ; p ++ ) if ( prime [ p ] == true ) for ( var i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; }
function superpower ( n ) { SieveOfEratosthenes ( ) ; var superPower = 0 , factor = 0 ; var i = 2 ; while ( n > 1 && i <= MAX ) { if ( prime [ i ] ) { factor = 0 ; while ( n % i == 0 && n > 1 ) { factor ++ ; n = n / i ; } if ( superPower < factor ) superPower = factor ; } i ++ ; } return superPower ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function countPrime ( head_ref ) { var count = 0 ; var ptr = head_ref ; while ( ptr != null ) { if ( isPrime ( ptr . data ) ) { count ++ ; } ptr = ptr . next ; } return count ; }
function pairwiseDifference ( arr , n ) { var diff ; for ( i = 0 ; i < n - 1 ; i ++ ) { diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; document . write ( diff + "▁" ) ; } }
function factorial ( n ) { let fact = 1 ; for ( let i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
function npr ( n , r ) { let pnr = Math . floor ( factorial ( n ) / factorial ( n - r ) ) ; return pnr ; }
function countPermutations ( n , r , k ) { return factorial ( k ) * ( r - k + 1 ) * npr ( n - k , r - k ) ; }
function sumMultiples ( n ) { n -- ; return sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ; }
function GIF ( n ) { return Math . floor ( n ) ; }
function ncr ( n , r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
function smallestDivisor ( n ) { if ( n % 2 == 0 ) return 2 ; for ( var i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }
function countRabbits ( Heads , Legs ) { var count = 0 ; count = ( Legs ) - 2 * ( Heads ) ; count = count / 2 ; return count ; }
function compositeProduct ( arr , n ) { let max_val = arr . sort ( ( A , B ) => B - A ) [ 0 ] ; let prime = new Array ( max_val + 1 ) . fill ( true ) ; prime [ 0 ] = true ; prime [ 1 ] = true ; for ( let p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( ! prime [ arr [ i ] ] ) { product *= arr [ i ] ; } return product ; }
function markingScheme ( N , answerKey , studentAnswer ) { var positive = 0 , negative = 0 , notattempt = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( studentAnswer [ i ] == 0 ) notattempt ++ ; else if ( answerKey [ i ] == studentAnswer [ i ] ) positive ++ ; else if ( answerKey [ i ] != studentAnswer [ i ] ) negative ++ ; } return ( positive * 3 ) + ( negative * - 1 ) ; }
function SumDivisible ( n , k ) { let sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = Math . floor ( n / 10 ) ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; }
function fact ( n ) { let f = 1 ; for ( let i = 2 ; i <= n ; i ++ ) f = f * i ; return f ; }
function waysOfConsonants ( size1 , freq ) { let ans = fact ( size1 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) continue ; else ans = Math . floor ( ans / fact ( freq [ i ] ) ) ; } return ans ; }
function waysOfVowels ( size2 , freq ) { return Math . floor ( fact ( size2 ) / ( fact ( freq [ 0 ] ) * fact ( freq [ 4 ] ) * fact ( freq [ 8 ] ) * fact ( freq [ 14 ] ) * fact ( freq [ 20 ] ) ) ) ; }
function countWays ( str ) { let freq = new Array ( 200 ) ; for ( let i = 0 ; i < 200 ; i ++ ) freq [ i ] = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) freq [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; let vowel = 0 , consonant = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] != "a" && str [ i ] != "e" && str [ i ] != "i" && str [ i ] != "o" && str [ i ] != "u" ) consonant ++ ; else vowel ++ ; } return waysOfConsonants ( consonant + 1 , freq ) * waysOfVowels ( vowel , freq ) ; }
function findX ( n , k ) { let r = n ; let v = 0 ; let u = 0 ; let m = Math . floor ( Math . sqrt ( k ) + 1 ) ; for ( let i = 2 ; i <= m && k > 1 ; i ++ ) { if ( i == m ) { i = k ; } for ( let u = v = 0 ; k % i == 0 ; v ++ ) { k = Math . floor ( k / i ) ; } if ( v > 0 ) { let t = n ; while ( t > 0 ) { t = Math . floor ( t / i ) ; u += t ; } r = Math . min ( r , Math . floor ( u / v ) ) ; } } return r ; }
function ncr ( n , r ) { var ncr = fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; return parseInt ( ncr ) ; }
function maxSum ( a , n ) { var maxAnd = Math . max ( ... a ) ; var maxOR = 0 ; for ( var i = 0 ; i < n ; i ++ ) { maxOR |= a [ i ] ; } document . write ( ( maxAnd + maxOR ) ) ; }
function sum_odd ( n ) { let sum = 0 , pos = 1 ; while ( n ) { if ( pos % 2 == 1 ) sum += n % 10 ; n = Math . floor ( n / 10 ) ; pos ++ ; } return sum ; }
function check_prime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function calculateSum ( n ) { return 2 * ( Math . pow ( n , 6 ) + 15 * Math . pow ( n , 4 ) + 15 * Math . pow ( n , 2 ) + 1 ) ; }
function solve ( n ) { let count = 0 ; let num = 1 ; let prod = 1 ; while ( count < n ) { if ( prime [ num ] == true ) { prod *= num ; count ++ ; } num ++ ; } return prod ; }
function ReplaceElements ( arr , n ) { let prod = 1 ; for ( let i = 0 ; i < n ; ++ i ) { prod *= arr [ i ] ; } for ( let i = 0 ; i < n ; ++ i ) { arr [ i ] = parseInt ( prod / arr [ i ] , 10 ) ; } }
function sum ( n ) { if ( n == 0 ) return 0 ; if ( n % 2 == 1 ) { return square ( ( n + 1 ) / 2 ) + sum ( n / 2 ) ; } else { return square ( n / 2 ) + sum ( n / 2 ) ; } }
function oddDivSum ( a , b ) { return sum ( b ) - sum ( a - 1 ) ; }
function countBits ( n ) { var count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; }
function isPowerful ( n ) { while ( n % 2 == 0 ) { let power = 0 ; while ( n % 2 == 0 ) { n = parseInt ( n / 2 , 10 ) ; power ++ ; } if ( power == 1 ) return false ; } for ( let factor = 3 ; factor <= Math . sqrt ( n ) ; factor += 2 ) { let power = 0 ; while ( n % factor == 0 ) { n = parseInt ( n / factor , 10 ) ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
function isPower ( a ) { if ( a == 1 ) return true ; for ( let i = 2 ; i * i <= a ; i ++ ) { let val = Math . log ( a ) / Math . log ( i ) ; if ( ( val - parseInt ( val , 10 ) ) < 0.00000001 ) return true ; } return false ; }
function isAchillesNumber ( n ) { if ( isPowerful ( n ) && ! isPower ( n ) ) return true ; else return false ; }
function OddDivCount ( a , b ) { let res = 0 ; for ( let i = a ; i <= b ; ++ i ) { let divCount = 0 ; for ( let j = 1 ; j <= i ; ++ j ) { if ( i % j == 0 ) { ++ divCount ; } } if ( ( divCount % 2 ) != 0 ) { ++ res ; } } return res ; }
function divisor ( a ) { let div = 1 , count = 0 ; for ( let i = 2 ; i <= Math . sqrt ( a ) ; i ++ ) { while ( a % i == 0 ) { count ++ ; a = parseInt ( a / i , 10 ) ; } div = div * ( count + 1 ) ; count = 0 ; } if ( a > 1 ) { div = div * ( 2 ) ; } return div ; }
function OddDivCount ( a , b ) { let res = 0 ; for ( let i = a ; i <= b ; ++ i ) { let divCount = divisor ( i ) ; if ( divCount % 2 == 1 ) { ++ res ; } } return res ; }
function Check_is_possible ( l , r , k ) { var div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; }
function isValid ( N , K ) { let m1 = new Set ( ) ; let m2 = new Set ( ) ; while ( N > 0 ) { m1 . add ( N % 10 ) ; N = Math . floor ( N / 10 ) ; } while ( K > 0 ) { m2 . add ( K % 10 ) ; K = Math . floor ( K / 10 ) ; } let s = new Set ( [ ... m1 , ... m2 ] )  return s . size == m1 . size && s . size == m2 . size }
function largestSquareFactor ( num ) { let answer = 1 ; for ( let i = 2 ; i < Math . sqrt ( num ) ; ++ i ) { let cnt = 0 ; let j = i ; while ( num % j == 0 ) { cnt ++ ; j *= i ; } if ( cnt & 1 ) { cnt -- ; answer *= Math . pow ( i , cnt ) ; } else { answer *= Math . pow ( i , cnt ) ; } } return answer ; }
function nth_group ( n ) { return n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; }
function checkUnusual ( n ) { var factor = largestPrimeFactor ( n ) ; if ( factor > Math . sqrt ( n ) ) { return true ; } else { return false ; } }
function printPossible ( a , b , c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) document . write ( "NO" ) ; else document . write ( "YES" ) ; }
function isChangeable ( notes , n ) { let fiveCount = 0 ; let tenCount = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) fiveCount ++ ; else if ( notes [ i ] == 10 ) { if ( fiveCount > 0 ) { fiveCount -- ; tenCount ++ ; } else return 0 ; } else { if ( fiveCount > 0 && tenCount > 0 ) { fiveCount -- ; tenCount -- ; } else if ( fiveCount >= 3 ) { fiveCount -= 3 ; } else return 0 ; } } return 1 ; }
function sumSubarrayMins ( A , n ) { var left = Array ( n ) , right = Array ( n ) ; var s1 = [ ] , s2 = [ ] ; for ( var i = 0 ; i < n ; ++ i ) { var cnt = 1 ; while ( s1 . length != 0 && ( s1 [ s1 . length - 1 ] [ 0 ] ) > A [ i ] ) { cnt += s1 [ s1 . length - 1 ] [ 1 ] ; s1 . pop ( ) ; } s1 . push ( [ A [ i ] , cnt ] ) ; left [ i ] = cnt ; } for ( var i = n - 1 ; i >= 0 ; -- i ) { var cnt = 1 ; while ( s2 . length != 0 && ( s2 [ s2 . length - 1 ] [ 0 ] ) >= A [ i ] ) { cnt += s2 [ s2 . length - 1 ] [ 1 ] ; s2 . pop ( ) ; } s2 . push ( [ A [ i ] , cnt ] ) ; right [ i ] = cnt ; } var result = 0 ; for ( var i = 0 ; i < n ; ++ i ) result = ( result + A [ i ] * left [ i ] * right [ i ] ) ; return result ; }
function isPerfectPower ( n ) { if ( n == 1 ) { return true ; } for ( var x = 2 ; x <= Math . sqrt ( n ) ; x ++ ) { var y = 2 ; var p = parseInt ( Math . pow ( x , y ) ) ; while ( p <= n && p > 0 ) { if ( p == n ) { return true ; } y ++ ; p = parseInt ( Math . pow ( x , y ) ) ; } } return false ; }
function isTrojan ( n ) { if ( ! isPerfectPower ( n ) && isStrongNumber ( n ) ) { return true ; } else { return false ; } }
function Nth_Term ( n ) { return ( 2 * Math . pow ( n , 3 ) - 3 * Math . pow ( n , 2 ) + n + 6 ) / 6 ; }
function Sum_upto_nth_Term ( n ) { return ( 1 - parseInt ( Math . pow ( - 2 , n ) ) ) ; }
function Nth_Term ( n ) { return ( 3 * Math . pow ( n , 2 ) - n + 2 ) / ( 2 ) ; }
function countPermutations ( N , B ) { var x = Math . pow ( B , N ) ; var y = Math . pow ( B , N - 1 ) ; document . write ( x - y ) ; }
function calculateDifference ( arr , n ) { var max_val = Math . max . apply ( Math , arr ) ; var prime = Array ( max_val + 1 ) . fill ( true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } var P1 = 1 , P2 = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { P1 *= arr [ i ] ; } else if ( arr [ i ] != 1 ) { P2 *= arr [ i ] ; } } return Math . abs ( P2 - P1 ) ; }
function CalculateDifference ( arr , n ) { var max_val = Number . MIN_VALUE ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_val ) max_val = arr [ i ] ; } var prime = Array ( max_val + 1 ) ; for ( i = 0 ; i <= max_val ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } var S1 = 0 , S2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { S1 += arr [ i ] ; } else if ( arr [ i ] != 1 ) { S2 += arr [ i ] ; } } return Math . abs ( S2 - S1 ) ; }
function EqualNumbers ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n ) return n - 1 ; return n ; }
function getMin ( arr , n , k ) { let res = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) res = Math . min ( res , arr [ i ] ) ; } return res ; }
function getMax ( arr , n , k ) { let res = Number . MIN_VALUE ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) res = Math . max ( res , arr [ i ] ) ; } return res ; }
function printNumberWithDR ( k , d ) { if ( d == 0 && k != 1 ) document . write ( "-1" ) ; else { document . write ( d ) ; k -- ; while ( k -- > 0 ) document . write ( "0" ) ; } }
function count_odd_pair ( n , a ) { var odd = 0 , even = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } var ans = odd * even * 2 ; return ans ; }
function count_even_pair ( odd_sum_pairs , n ) { var total_pairs = ( n * ( n - 1 ) ) ; var ans = total_pairs - odd_sum_pairs ; return ans ; }
function findSteps ( n , m , a ) { var cur = 1 ; var steps = 0 ; for ( var i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; }
function xorEqualsOrCount ( N ) { let count = 0 ; let bit ; while ( N > 0 ) { bit = N % 2 ; if ( bit == 0 ) count ++ ; N = parseInt ( N / 2 ) ; } return Math . pow ( 2 , count ) ; }
function fact ( n ) { if ( n == 1 ) return 1 ; return n * fact ( n - 1 ) ; }
function sum ( x , n ) { let total = 1.0 ; for ( let i = 1 ; i <= n ; i ++ ) { total = total + ( Math . pow ( x , i ) / fact ( i + 1 ) ) ; } return total . toFixed ( 4 ) ; }
function sum ( x , n ) { let total = 1.0 ; let previous = 1.0 ; for ( let i = 1 ; i <= n ; i ++ ) { previous = ( ( previous * x ) / ( i + 1 ) ) ; total = total + previous ; } return total ; }
function isPowerOfTwo ( x ) { return ( x > 0 && ( ! ( ( x & ( x - 1 ) ) > 0 ) ) ) ; }
function Count_pairs ( a , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) ) count ++ ; } let ans = ( count * ( count - 1 ) ) / 2 ; document . write ( ans ) ; }
function numberOfDivisors ( num ) { let c = 0 ; for ( let i = 1 ; i <= num ; i ++ ) { if ( num % i == 0 ) { c += 1 ; } } return c ; }
function countNumbers ( n ) { let c = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( numberOfDivisors ( i ) == 9 ) c += 1 ; } return c ; }
function countNumbers ( n ) { let c = 0 ; let limit = parseInt ( Math . sqrt ( n ) , 10 ) ; let prime = new Array ( limit + 1 ) ; prime . fill ( 0 ) ; for ( let i = 1 ; i <= limit ; i ++ ) { prime [ i ] = i ; } for ( let i = 2 ; i * i <= limit ; i ++ ) { if ( prime [ i ] == i ) { for ( let j = i * i ; j <= limit ; j += i ) { if ( prime [ j ] == j ) { prime [ j ] = i ; } } } } for ( let i = 2 ; i <= limit ; i ++ ) { let p = prime [ i ] ; let q = prime [ parseInt ( i / prime [ i ] , 10 ) ] ; if ( p * q == i && q != 1 && p != q ) { c += 1 ; } else if ( prime [ i ] == i ) { if ( Math . pow ( i , 8 ) <= n ) { c += 1 ; } } } return c ; }
function sumNth ( A , B , m , n ) { var res = 0 ; if ( n == 1 ) { for ( let i = 0 ; i < m ; i ++ ) res = res + A [ i ] ; } else if ( n == 2 ) { for ( let i = 0 ; i < m ; i ++ ) res = res + B [ i ] * m ; } else { var f = Array ( n ) . fill ( 0 ) ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( let i = 2 ; i < n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; for ( i = 0 ; i < m ; i ++ ) { res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ; } } return res ; }
function factorial ( n ) { let result = 1 ; for ( let i = 1 ; i <= n ; i ++ ) result = result * i ; return result ; }
function nCr ( n , r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
function calculate_result ( n ) { let result = 2 * nCr ( ( n - 2 ) , ( n / 2 - 1 ) ) ; return result ; }
function isHalfReducible ( arr , n , m ) { var frequencyHash = Array ( m + 1 ) . fill ( 0 ) ; var i ; for ( i = 0 ; i < n ; i ++ ) { frequencyHash [ arr [ i ] % ( m + 1 ) ] ++ ; } for ( i = 0 ; i <= m ; i ++ ) { if ( frequencyHash [ i ] >= n / 2 ) break ; } if ( i <= m ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function generateDivisors ( n ) { for ( var i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) arr . push ( i ) ; { arr . push ( i ) ; arr . push ( n / i ) ; } } } }
function harmonicMean ( n ) { generateDivisors ( n ) ; var sum = 0.0 ; var len = arr . length ; for ( var i = 0 ; i < len ; i ++ ) sum = sum + ( n / arr [ i ] ) ; sum = ( sum / n ) ; return ( arr . length / sum ) ; }
function isOreNumber ( n ) { var mean = harmonicMean ( n ) ; if ( mean - parseInt ( mean ) == 0 ) return true ; else return false ; }
function sum_of_series ( n ) { var result = 0 ; for ( i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - parseInt ( Math . pow ( i , 2 ) ) ; else result = result + parseInt ( Math . pow ( i , 2 ) ) ; } return result ; }
function sum_of_series ( n ) { let result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }
function digitProduct ( digits , start , end ) { let pro = 1 ; for ( let i = start ; i <= end ; i ++ ) { pro *= digits [ i ] ; } return pro ; }
function numberOfDistinct ( n ) { var ans = 0 ; for ( i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
function SieveOfEratosthenes ( ) { prime [ 1 ] = false ; for ( var p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] ) { for ( var i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( var i = 1 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) sum [ i ] = 1 ; sum [ i ] += sum [ i - 1 ] ; } }
function calculateAlternateSum ( n ) { if ( n <= 0 ) return 0 ; var fibo = Array ( n + 1 ) . fill ( 0 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; var sum = Math . pow ( fibo [ 0 ] , 2 ) + Math . pow ( fibo [ 1 ] , 2 ) ; for ( i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; }
function getValue ( n ) { let i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return parseInt ( k / 2 ) ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
function ulam ( ) { arr . push ( 1 ) ; arr . push ( 2 ) ; for ( var i = 3 ; i < MAX ; i ++ ) { var count = 0 ; for ( var j = 0 ; j < arr . length - 1 ; j ++ ) { for ( var k = j + 1 ; k < arr . length ; k ++ ) { if ( arr [ j ] + arr [ k ] == i ) { count ++ ; } if ( count > 1 ) break ; } if ( count > 1 ) break ; } if ( count == 1 ) { arr . push ( i ) ; } } }
function nthKyneaNumber ( n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; }
function nthKyneaNumber ( n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; }
function isProthNumber ( n ) { let k = 1 ; while ( k < parseInt ( n / k ) ) { if ( n % k == 0 ) { if ( isPowerOfTwo ( parseInt ( n / k ) ) ) return true ; } k = k + 2 ; } return false ; }
function isInterprime ( n ) { if ( n < 4 ) return false ; var prev_prime = n ; var next_prime = n ; while ( ! isPrime ( prev_prime ) ) { prev_prime -- ; } while ( ! isPrime ( next_prime ) ) { next_prime ++ ; } if ( ( prev_prime + next_prime ) == 2 * n ) return true ; else return false ; }
function isPowerOfTwo ( n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; }
function isThabitNumber ( n ) { n = n + 1 ; if ( n % 3 == 0 ) n = n / 3 ; else return false ; if ( isPowerOfTwo ( n ) ) return true ; else return false ; }
function get_last_two_digit ( N ) { if ( N <= 10 ) { let ans = 0 , fac = 1 ; for ( let i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ans % 100 ; } return 13 ; }
function isProductEven ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; }
function calculateSquareSum ( n ) { if ( n <= 0 ) return 0 ; var fibo = Array ( n + 1 ) . fill ( 0 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; var sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; }
function fib ( n ) { if ( n == 0 ) { return 0 ; } if ( n == 1 n == 2 ) { return ( f [ n ] = 1 ) ; } if ( f [ n ] > 0 ) { return f [ n ] ; } let k = ( ( n & 1 ) > 0 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( ( n & 1 ) > 0 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
function calculateSumOfSquares ( n ) { return fib ( n ) * fib ( n + 1 ) ; }
function sieve ( ) { let arr = new Array ( N + 1 ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = 0 ; } arr [ 0 ] = 1 ; arr [ 1 ] = 1 ; for ( let i = 2 ; i <= Math . ceil ( Math . sqrt ( N ) + 1 ) ; i ++ ) if ( arr [ i ] == 0 ) for ( let j = i * i ; j <= N ; j += i ) arr [ j ] = 1 ; let runningPrimeSum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] == 0 ) runningPrimeSum += i ; dp [ i ] = runningPrimeSum ; } }
function fnMod ( n ) { var rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; }
function MinimumMoves ( a , n , x ) { var ans = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { var p = parseInt ( ( a [ i - 1 ] - a [ i ] ) / x + 1 ) ; ans += p ; a [ i ] += p * x ; } } return ans ; }
function SumOfDigits ( str , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += ( str . charAt ( i ) - "0" ) ; return sum ; }
function isPrime ( k ) { if ( k <= 1 ) return false ; for ( let i = 2 ; i < k ; i ++ ) if ( k % i == 0 ) return false ; return true ; }
function check ( num , k ) { let flag = 1 ; for ( let i = 2 ; i < k ; i ++ ) { if ( num % i == 0 ) flag = 0 ; } if ( flag == 1 ) { if ( num % k == 0 ) return 1 ; else return 0 ; } else return 0 ; }
function findCount ( a , b , k ) { let count = 0 ; if ( ! isPrime ( k ) ) return 0 ; else { let ans ; for ( let i = a ; i <= b ; i ++ ) { ans = check ( i , k ) ; if ( ans == 1 ) count ++ ; else continue ; } } return count ; }
function findMinEqualSums ( a , N ) { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; } let sum1 = 0 , sum2 = 0 ; let min = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { sum1 += a [ i ] ; sum2 = sum - sum1 ; if ( Math . abs ( sum1 - sum2 ) < min ) { min = Math . abs ( sum1 - sum2 ) ; } if ( min == 0 ) { break ; } } return min ; }
function SieveOfEratosthenes ( ) { var prime = Array ( MAX ) . fill ( true ) ; ; for ( var p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( var i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( var p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . push ( p ) ; }
function isEuclid ( n ) { var product = 1 ; var i = 0 ; while ( product < n ) { product = product * arr [ i ] ; if ( product + 1 == n ) return true ; i ++ ; } return false ; }
function isPowerOfTwo ( n ) { return ( n != 0 ) && ( ( n & ( n - 1 ) ) == 0 ) ; }
function NumberOfSolutions ( x , y , z , n ) { var ans = 0 ; for ( var i = 0 ; i <= x ; i ++ ) { for ( var j = 0 ; j <= y ; j ++ ) { var temp = n - i - j ; if ( temp >= 0 ) { temp = Math . min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; }
function solve ( n ) { var count = 0 , num = 1 ; var sum = 0 ; while ( count < n ) { if ( prime [ num ] ) { sum += num ; count ++ ; } num ++ ; } return parseInt ( sum ) ; }
function fact ( p ) { if ( p <= 1 ) return 1 ; return p * fact ( p - 1 ) ; }
function findNum ( n , a , b ) { let result = 0 ; let aCount = 0 ; let bCount = 0 ; return findNumUtil ( result , a , aCount , b , bCount , n ) ; }
function findkth ( n , k ) { let v1 = [ ] ; let v2 = [ ] ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v1 . push ( i ) ; if ( i != Math . sqrt ( n ) ) v2 . push ( n / i ) ; } } v2 . reverse ( ) ; if ( k > ( v1 . length + v2 . length ) ) document . write ( "Doesn't▁Exist" ) ; else { if ( k <= v1 . length ) document . write ( v1 [ k - 1 ] ) ; else document . write ( v2 [ k - v1 . length - 1 ] ) ; } }
function NumberOfSolutions ( a , b , c , d ) { let ans = 0 ; for ( let i = a ; i <= b ; i ++ ) if ( d >= Math . max ( c , i + 1 ) ) ans += d - Math . max ( c , i + 1 ) + 1 ; return ans ; }
function CountDigits ( n ) { if ( n == 1 ) return 1 ; var sum = 0 ; for ( i = 2 ; i <= n ; ++ i ) { sum += ( Math . log ( i ) / Math . log ( 10 ) ) ; } sum *= n ; return Math . ceil ( sum ) ; }
function findNumber ( n , d ) { let ans = "" ; if ( d != 10 ) { ans += ( d ) . toString ( ) ; for ( let i = 1 ; i < n ; i ++ ) ans += "0" ; } else { if ( n == 1 ) ans += "Impossible" ; else { ans += "1" ; for ( let i = 1 ; i < n ; i ++ ) ans += "0" ; } } return ans ; }
function countDigits ( val , arr ) { while ( val > 0 ) { let digit = val % 10 ; arr [ digit ] ++ ; val = Math . floor ( val / 10 ) ; } return ; }
function countFrequency ( x , n ) { let freq_count = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { freq_count [ i ] = 0 ; } for ( let i = 1 ; i <= n ; i ++ ) { let val = Math . pow ( x , i ) ; countDigits ( val , freq_count ) ; } for ( let i = 0 ; i <= 9 ; i ++ ) { document . write ( freq_count [ i ] + "▁" ) ; } }
function form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }
function nthTerm ( n ) { return Math . pow ( n , 2 ) + 4 * n ; }
function NthTerm ( n ) { let x = ( 3 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; }
function PowerOfTwo ( ) { var x = 1 ; for ( i = 0 ; i < 31 ; i ++ ) { power [ i ] = x ; x *= 2 ; } pre [ 0 ] = 1 ; for ( i = 1 ; i < 31 ; i ++ ) pre [ i ] = pre [ i - 1 ] + power [ i ] ; }
function Sum ( n ) { var ans = n * ( n + 1 ) / 2 ; for ( i = 0 ; i < 31 ; i ++ ) { if ( power [ i ] > n ) { ans -= 2 * pre [ i - 1 ] ; break ; } } return ans ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
function checkSemiPrime ( n ) { var i = 0 ; while ( arr [ i ] <= parseInt ( n / 2 ) ) { if ( sprime [ n - arr [ i ] ] ) { return true ; } i ++ ; } return false ; }
function sum ( N ) { var S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; }
function nextGreater ( N ) { var power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; }
function area ( r ) { if ( r < 0 ) return - 1 ; var area = ( 3.14 * Math . pow ( r / ( 2 * Math . sqrt ( 2 ) ) , 2 ) ) ; return area ; }
function area ( a ) { if ( a < 0 ) return - 1 ; var area = Math . pow ( ( a * Math . sqrt ( 3 ) ) / ( Math . sqrt ( 2 ) ) , 2 ) ; return area ; }
function SieveOfEratosthenes ( ) { prime [ 1 ] = false ; for ( let p = 2 ; p < Math . floor ( Math . sqrt ( N ) ) ; p ++ ) { if ( prime [ p ] == true ) for ( let i = 2 * p ; i < N ; i += p ) prime [ i ] = false ; } }
function almostPrimes ( n ) { let ans = 0 ; for ( let i = 6 ; i < n + 1 ; i ++ ) { let c = 0 ; for ( let j = 2 ; i >= j * j ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) { if ( prime [ j ] ) c += 1 ; } else { if ( prime [ j ] ) c += 1 ; if ( prime [ ( i / j ) ] ) c += 1 ; } } } if ( c == 2 ) ans += 1 ; } return ans ; }
function heightCalculate ( H , n , m ) { let N = n * 1.0 ; let M = m * 1.0 ; let h = H * Math . sqrt ( N / ( N + M ) ) ; return h ; }
function numberOfSolutions ( n ) { let c = 0 ; for ( let x = 0 ; x <= n ; ++ x ) if ( n == x + n ^ x ) ++ c ; return c ; }
function findNumber ( n ) { for ( i = n - 1 ; i >= 0 ; i -- ) { var count = Array . from ( { length : 10 } , ( _ , i ) => 0 ) ; var x = i ; var count1 = 0 , count2 = 0 ; while ( x > 0 ) { count [ x % 10 ] ++ ; x = parseInt ( x / 10 ) ; count1 ++ ; } for ( j = 0 ; j < 10 ; j ++ ) { if ( count [ j ] == 1 ) count2 ++ ; } if ( count1 == count2 ) return i ; } return - 1 ; }
function isprime ( x ) { for ( var i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; }
function isNSqMinusnMSqPrime ( m , n ) { if ( n - m == 1 && isprime ( m + n ) ) return true ; else return false ; }
function countNumbers ( N ) { return parseInt ( ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 , 10 ) ; }
function buildPrefix ( ) { prime = new Array ( MAX + 1 ) ; prime . fill ( true ) ; for ( var p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( var i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( var p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] ) prefix [ p ] += p ; } }
function sumPrimeRange ( L , R ) { buildPrefix ( ) ; return prefix [ R ] - prefix [ L - 1 ] ; }
function findPosition ( n , f , b ) { return n - Math . max ( f + 1 , n - b ) + 1 ; }
function nthOdd ( n ) { return ( 2 * n - 1 ) ; }
function countSolutions ( a ) { let count = 0 ; for ( let i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
function countSolutions ( a ) { let count = bitCount ( a ) ; count = Math . pow ( 2 , count ) ; return count ; }
function isPermutation ( first , second ) { var sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; var temp1 = first ; while ( temp1 != null ) { sum1 += temp1 . data ; mul1 *= temp1 . data ; temp1 = temp1 . next ; } var temp2 = second ; while ( temp2 != null ) { sum2 += temp2 . data ; mul2 *= temp2 . data ; temp2 = temp2 . next ; } return sum1 == sum2 && mul1 == mul2 ; }
function SieveOfEratosthenes ( n , isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( var i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( var p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( var i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
function findPrimePair ( n ) { var flag = 0 ; var isPrime = [ ] SieveOfEratosthenes ( n , isPrime ) ; for ( var i = 2 ; i < n ; i ++ ) { var x = n / i ; if ( isPrime [ i ] && isPrime [ x ] && x != i && x * i == n ) { document . write ( i + "▁" + x ) ; flag = 1 ; return ; } } if ( flag == 0 ) document . write ( "No▁such▁pair▁found" ) ; }
function solveProportion ( a , b1 , b2 , c ) { let A = a * b2 ; let B = b1 * b2 ; let C = b1 * c ; let gcd = __gcd ( __gcd ( A , B ) , C ) ; document . write ( A / gcd + ":" + B / gcd + ":" + C / gcd ) ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + n - 3 ; }
function nthTerm ( n ) { return 5 * Math . pow ( n , 2 ) - 5 * n ; }
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) + 2 * n - 5 ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + 3 * n - 5 ; }
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) - 4 * n + 2 ; }
function nthTerm ( n ) { return 4 * Math . pow ( n , 2 ) - 3 * n + 2 ; }
function isProduct ( num ) { var cnt = 0 ; for ( var i = 2 ; cnt < 2 && ( i * i ) <= num ; ++ i ) { while ( num % i == 0 ) { num = parseInt ( num / i ) ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; }
function findNumbers ( N ) { vec = [ ] ; for ( var i = 1 ; i <= N ; i ++ ) { if ( isProduct ( i ) && ! isPerfectSquare ( i ) ) { vec . push ( i ) ; } } for ( var i = 0 ; i < vec . length ; i ++ ) { document . write ( vec [ i ] + "▁" ) ; } }
function countDivisors ( n , k ) { var count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 3 ) + Math . pow ( n , 2 ) ; }
function calculateSum ( n ) { return n * ( n + 1 ) / 2 + Math . pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; }
function volume ( r , h ) { return ( ( 1 ) / ( 3 ) ) * pi * r * r * h ; }
function calculateSum ( n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
function maxDistance ( arr , n ) { let map = new Map ( ) ; let max_dist = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! map . has ( arr [ i ] ) ) map . set ( arr [ i ] , i ) ; else max_dist = Math . max ( max_dist , i - map . get ( arr [ i ] ) ) ; } return max_dist ; }
function calculateSum ( n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) - n - 1 ; }
function nthTerm ( n ) { return 6 * Math . pow ( n , 2 ) - 4 * n - 2 ; }
function nthTerm ( n ) { return 4 * Math . pow ( n , 2 ) - 7 * n + 3 ; }
function nthTerm ( n ) { return Math . pow ( n , 2 ) + 2 * n + 2 ; }
function checkSolution ( a , b , c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) document . write ( "2▁solutions" ) ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) document . write ( "1▁solution" ) ; else document . write ( "No▁solutions" ) ; }
function Bytes ( kilobytes ) { var Bytes = 0 ; Bytes = kilobytes * 1024 ; return Bytes ; }
function NthTerm ( n ) { var x = ( 2 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; }
function sum ( n ) { let ans = parseInt ( ( n * ( n - 1 ) ) / 2 ) ; return ans ; }
function getNthTerm ( N ) { return ( Math . pow ( N , 2 ) + N + 1 ) ; }
function findSum ( N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; }
function getNthTerm ( N ) { return 4 * Math . pow ( N , 2 ) - 3 * N + 2 ; }
function findCosNTheta ( sinTheta , n ) { var cosTheta = Math . sqrt ( 1 - sinTheta * sinTheta ) ; var ans = 0 ; var toggle = 1 ; for ( var i = 1 ; i <= n ; i += 2 ) { ans = ans + nCr [ n ] [ i ] * Math . pow ( cosTheta , n - i ) * Math . pow ( sinTheta , i ) * toggle ; toggle = toggle * - 1 ; } return ans . toFixed ( 6 ) ; }
function findSum ( n ) { var sum2 , sum5 , sum10 ; sum2 = parseInt ( ( parseInt ( n / 2 ) * ( 4 + ( parseInt ( n / 2 ) - 1 ) * 2 ) ) / 2 ) ; sum5 = parseInt ( ( parseInt ( n / 5 ) * ( 10 + ( parseInt ( n / 5 ) - 1 ) * 5 ) ) / 2 ) ; sum10 = parseInt ( ( parseInt ( n / 10 ) * ( 20 + ( parseInt ( n / 10 ) - 1 ) * 10 ) ) / 2 ) ; return sum2 + sum5 - sum10 ; }
function nthTerm ( N ) { return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; }
function nthTerm ( N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; }
function binomial ( ) { for ( var i = 0 ; i < MAX ; i ++ ) { for ( var j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } }
function findTanNTheta ( tanTheta , n ) { ans = 0 , numerator = 0 , denominator = 0 ; toggle = 1 ; for ( var i = 1 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n ] [ i ] * Math . pow ( tanTheta , i ) * toggle ; toggle = toggle * - 1 ; } denominator = 1 ; toggle = - 1 ; for ( var i = 2 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n ] [ i ] * Math . pow ( tanTheta , i ) * toggle ; toggle = toggle * - 1 ; } ans = numerator / denominator ; return ans . toFixed ( 5 ) ; }
function product ( n ) { let v = new Array ( ) ; for ( let i = 0 ; i < n + 100 ; i ++ ) { v . push ( new Array ( ) ) } factors ( n + 100 , v ) ; if ( n % 4 == 0 ) { let x = n / 4 ; x *= x ; return x * x ; } else { if ( isPrime [ n ] ) return - 1 ; else { let ans = - 1 ; if ( v [ n ] . length > 2 ) { let fac = v [ n ] [ v [ n ] . length - 3 ] ; for ( let i = v [ n ] . length - 1 ; i >= 0 ; i -- ) { for ( let j = v [ n ] . length - 1 ; j >= 0 ; j -- ) { if ( ( fac * 2 ) + ( v [ n ] [ j ] + v [ n ] [ i ] ) == n ) ans = Math . max ( ans , fac * fac * v [ n ] [ j ] * v [ n ] [ i ] ) ; } } return ans ; } } } }
function arePermutations ( a , b , n , m ) { let sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( let i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( let i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; }
function binomial ( ) { for ( var i = 0 ; i < MAX ; i ++ ) { for ( var j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } }
function findCosnTheta ( cosTheta , n ) { var sinTheta = Math . sqrt ( 1 - cosTheta * cosTheta ) ; var ans = 0 ; var toggle = 1 ; for ( var i = 0 ; i <= n ; i += 2 ) { ans = ans + nCr [ n ] [ i ] * Math . pow ( cosTheta , n - i ) * Math . pow ( sinTheta , i ) * toggle ; toggle = toggle * - 1 ; } return ans . toFixed ( 1 ) ; }
function CalculateRatio ( m , n ) { return ( 2 * m - 1 ) / ( 2 * n - 1 ) ; }
function power ( x , y , p ) { var res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function sumProd ( n , t ) { var dino = power ( t + 1 , MOD - 2 , MOD ) ; var ans = 1 ; for ( var i = n + t + 1 ; i > n ; -- i ) ans = ( ans % MOD * i % MOD ) % MOD ; var tfact = 1 ; for ( var i = 1 ; i <= t ; ++ i ) tfact = ( tfact * i ) % MOD ; ans = ans * dino - tfact + MOD ; return ans % MOD ; }
function sumOfDigitsSingle ( x ) { let ans = 0 ; while ( x ) { ans += x % 10 ; x = Math . floor ( x / 10 ) ; } return ans ; }
function sumOfDigitsTwoParts ( N ) { let A = closest ( N ) ; return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) ; }
function nextPerfectCube ( N ) { let nextN = Math . floor ( Math . cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; }
function findSum ( n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }
function sum ( x , y , n ) { sum1 = ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ; sum2 = ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ; return sum1 + sum2 ; }
function powerDigitSum ( a , n ) { let res = 1 ; while ( n ) { if ( n % 2 == 1 ) { res = res * digSum ( a ) ; res = digSum ( res ) ; } a = digSum ( digSum ( a ) * digSum ( a ) ) ; n /= 2 ; } return res ; }
function printPair ( g , l ) { document . write ( g + "▁" + l ) ; }
function mostFrequent ( arr , n ) { arr . sort ( ) ; let max_count = 1 , res = arr [ 0 ] ; let curr_count = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; }
function findMaximumPieces ( n ) { return 1 + n * ( n + 1 ) / 2 ; }
function power ( a , b ) { var res = 1 ; while ( b != 0 ) { if ( ( b & 1 ) != 0 ) { res *= a ; res = res % mod ; } b = parseInt ( b / 2 ) ; a *= a ; a %= mod ; } return res ; }
function minPlayer ( n , k ) { var num = ( ( power ( k , n ) - 1 ) + mod ) % mod ; var den = ( power ( k - 1 , mod - 2 ) + mod ) % mod ; var ans = ( ( ( num * den ) % mod ) * k ) % mod ; return ans ; }
function sieve ( N ) { prime [ 0 ] = prime [ 1 ] = false ; for ( var i = 2 ; i <= N ; i ++ ) { if ( prime [ i ] ) { for ( var j = 2 ; i * j <= N ; j ++ ) prime [ i * j ] = false ; } } }
function countLogNeeded ( N ) { var count = 0 ; sieve ( N ) ; for ( var i = 1 ; i <= N ; i ++ ) { if ( prime [ i ] ) count ++ ; } return count ; }
function rmsValue ( arr , n ) { var square = 0 ; var mean = 0 ; var root = 0 ; for ( i = 0 ; i < n ; i ++ ) { square += Math . pow ( arr [ i ] , 2 ) ; } mean = ( square / ( n ) ) ; root = Math . sqrt ( mean ) ; return root ; }
function Mixture ( X , Y , Z ) { var result = 0.0 , result1 = 0.0 ; result1 = ( ( X - Y ) / X ) ; result = Math . pow ( result1 , Z ) ; result = result * X ; return result ; }
function coin ( totalRupees , X , Y , Z ) { var one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2.0 ) ; twentyfive = ( ( Z * 1 ) / 4.0 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return result ; }
function sumOfSeries ( x , k ) { var y = ( ( ( x ) / 81 ) * ( 9 * k - 1 + Math . pow ( 10 , ( - 1 ) * k ) ) ) ; return y ; }
function calculateSum ( n ) { let a1 = 1 , a2 = 2 ; let r = 2 ; let d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( Math . pow ( r , n ) - 1 ) / ( r - 1 ) ; }
function findProduct ( n ) { let product = - 1 ; let si = factors . length ; for ( let i = 0 ; i < si ; i ++ ) { for ( let j = 0 ; j < si ; j ++ ) { for ( let k = 0 ; k < si ; k ++ ) { for ( let l = 0 ; l < si ; l ++ ) { let s = factors [ i ] + factors [ j ] + factors [ k ] + factors [ l ] ; if ( s == n ) { let p = factors [ i ] * factors [ j ] * factors [ k ] * factors [ l ] ; if ( p > product ) { product = p ; } } } } } } return product ; }
function modExp ( a , b ) { let result = 1 ; while ( b > 0 ) { if ( b == 1 ) result = result * a ; a = a * a ; b = Math . floor ( b / 2 ) ; } return result ; }
function check ( num ) { if ( num == 1 num < 3 ) return - 1 ; else if ( num % 4 == 0 ) return modExp ( Math . floor ( num / 4 ) , 4 ) ; else if ( num % 6 == 0 ) return modExp ( Math . floor ( num / 3 ) , 2 ) * modExp ( Math . floor ( num / 6 ) , 2 ) ; else if ( num % 10 == 0 ) return modExp ( Math . floor ( num / 5 ) , 2 ) * Math . floor ( num / 10 ) * Math . floor ( num / 2 ) ; else return - 1 ; }
function sieveOfEratosthenes ( N , s ) { let prime = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) prime [ i ] = false ; for ( let i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( let i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( let j = i ; j * i <= N ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
function findSum ( N ) { let s = new Array ( N + 1 ) ; let ans = 1 ; sieveOfEratosthenes ( N , s ) ; let currFactor = s [ N ] ; let power = 1 ; while ( N > 1 ) { N = Math . floor ( N / s [ N ] ) ; if ( currFactor == s [ N ] ) { power ++ ; continue ; } let sum = 0 ; for ( let i = 0 ; i <= power ; i ++ ) sum += Math . pow ( currFactor , i ) ; ans *= sum ; currFactor = s [ N ] ; power = 1 ; } return ans ; }
function countMultiples ( n ) { var multiple = [ 2 , 3 , 5 ] ; var count = 0 , mask = parseInt ( Math . pow ( 2 , 3 ) ) ; for ( i = 1 ; i < mask ; i ++ ) { var prod = 1 ; for ( j = 0 ; j < 3 ; j ++ ) { if ( ( i & 1 << j ) > 0 ) prod = prod * multiple [ j ] ; } if ( count_setbits ( i ) % 2 == 1 ) count = count + parseInt ( n / prod ) ; else count = count - parseInt ( n / prod ) ; } return count ; }
function Race ( B , C ) { var result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }
function isDivisible ( n ) { while ( Math . floor ( n / 100 ) > 0 ) { let d = n % 10 ; n = Math . floor ( n / 10 ) ; n -= d * 5 ; } return ( n % 17 == 0 ) ; }
function calculateSum ( n ) { return ( Math . pow ( 2 , n + 1 ) + n - 2 ) ; }
function nextPowerOf2 ( n ) { let count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
function removeElement ( n ) { if ( n == 1 n == 2 ) return 0 ; let a = nextPowerOf2 ( n ) ; if ( n == a n == a - 1 ) return 1 ; else if ( n == a - 2 ) return 0 ; else if ( n % 2 == 0 ) return 1 ; else return 2 ; }
function calculateSum ( n ) { return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; }
function bridge_length ( trainLength , Speed , Time ) { return ( ( Time * Speed ) - trainLength ) ; }
function findN ( k ) { var ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; }
function repeatedSum ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
function repeatedProduct ( n ) { var prod = 1 ; while ( n > 0 prod > 9 ) { if ( n == 0 ) { n = prod ; prod = 1 ; } prod *= n % 10 ; n = parseInt ( n / 10 ) ; } return prod ; }
function maxSumProduct ( N ) { if ( N < 10 ) return N ; return Math . max ( repeatedSum ( N ) , repeatedProduct ( N ) ) ; }
function Circular ( n ) { var Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; }
function Time ( arr , n , Emptypipe ) { var fill = 0 ; for ( var i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / Emptypipe ) ; return 1 / fill ; }
function smallestSubsegment ( a , n ) { let left = new Map ( ) ; let count = new Map ( ) ; let mx = 0 ; let mn = - 1 , strindex = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { let x = a [ i ] ; if ( count . get ( x ) == null ) { left . set ( x , i ) ; count . set ( x , 1 ) ; } else count . set ( x , count . get ( x ) + 1 ) ; if ( count . get ( x ) > mx ) { mx = count . get ( x ) ; mn = i - left . get ( x ) + 1 ; strindex = left . get ( x ) ; } else if ( ( count . get ( x ) == mx ) && ( i - left . get ( x ) + 1 < mn ) ) { mn = i - left . get ( x ) + 1 ; strindex = left . get ( x ) ; } } for ( let i = strindex ; i < strindex + mn ; i ++ ) document . write ( a [ i ] + "▁" ) ; }
function modInv ( x ) { var n = MOD - 2 ; var result = 1 ; while ( n ) { if ( n & 1 ) result = result * x % MOD ; x = x * x % MOD ; n = n / 2 ; } return result ; }
function getSum ( n , k ) { var ans = 1 ; for ( var i = n + 1 ; i > n - k ; i -- ) ans = ans * i % MOD ; ans = ans * modInv ( k + 1 ) % MOD ; return ans ; }
function calculateAreaSum ( l , b ) { var size = 1 ; var maxSize = Math . min ( l , b ) ; var totalArea = 0 ; for ( var i = 1 ; i <= maxSize ; i ++ ) { var totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; var area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; }
function printCombination ( n ) { for ( let i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( let j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( let k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { document . write ( i + "▁" + j + "▁" + k ) ; return ; } } } } } } }
function printCombination ( n ) { document . write ( 1 + "▁" ) ; if ( ( n - 2 ) % 3 == 0 ) document . write ( 2 + "▁" + ( n - 3 ) ) ; else document . write ( 1 + "▁" + ( n - 2 ) ) ; }
function Loss ( costPrice , ellingPrice ) { let Loss = ( costPrice - sellingPrice ) ; return Loss ; }
function isPalindrome ( n ) { if ( n % 11 == 0 ) { return true ; } return false ; }
function percent ( a , b ) { var result = 0 ; result = ( ( b - a ) * 100 ) / a ; return result ; }
function nextPerfectSquare ( N ) { let nextN = Math . floor ( Math . sqrt ( N ) ) + 1 ; return nextN * nextN ; }
function Smallest_prime_factor ( ) { for ( i = 1 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( i = 3 ; i * i <= MAXN ; i += 2 ) if ( spf [ i ] == i ) for ( j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; }
function Digit_Sum ( copy ) { var d = 0 ; while ( copy > 0 ) { d += copy % 10 ; copy = parseInt ( copy / 10 ) ; } return d ; }
function Sum_Of_All_Digits ( ) { for ( n = 2 ; n < MAXN ; n ++ ) { sum_digits [ n ] = sum_digits [ parseInt ( n / spf [ n ] ) ] + Digit_Sum ( spf [ n ] ) ; if ( Digit_Sum ( n ) == sum_digits [ n ] ) isValid [ n ] = true ; } for ( n = 2 ; n < MAXN ; n ++ ) { if ( isValid [ n ] ) ans [ n ] = 1 ; ans [ n ] += ans [ n - 1 ] ; } }
function binomialCoeff ( n , k ) { var res = 1 ; if ( k > n - k ) k = n - k ; for ( var i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
function catalan ( n ) { var c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
function isPrime ( n ) { var i , c = 0 ; for ( i = 1 ; i < n / 2 ; i ++ ) { if ( n % i == 0 ) c ++ ; } if ( c == 1 ) return 1 ; else return 0 ; }
function prevComplement ( n , b ) { var maxDigit , maxNum = 0 , digits = 0 , num = n ; while ( n != 0 ) { digits ++ ; n = parseInt ( n / 10 ) ; } maxDigit = b - 1 ; while ( ( digits -- ) > 0 ) { maxNum = maxNum * 10 + maxDigit ; } return maxNum - num ; }
function complement ( n , b ) { return prevComplement ( n , b ) + 1 ; }
function isFascinating ( num ) { let freq = new Array ( 10 ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } let val = "" + num + num * 2 + num * 3 ; for ( let i = 0 ; i < val . length ; i ++ ) { let digit = val [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ; if ( freq [ digit ] > 0 && digit != 0 ) return false ; else freq [ digit ] ++ ; } for ( let i = 1 ; i < freq . length ; i ++ ) { if ( freq [ i ] == 0 ) return false ; } return true ; }
function binomial_coefficient ( n , m ) { let res = 1 ; if ( m > n - m ) m = n - m ; for ( let i = 0 ; i < m ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
function computeTotient ( ) { for ( let i = 1 ; i < N ; i ++ ) phi [ i ] = i ; for ( let p = 2 ; p < N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( let i = 2 * p ; i < N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
function CoPrimes ( ) { computeTotient ( ) ; for ( let i = 1 ; i < N ; i ++ ) S [ i ] = S [ i - 1 ] + phi [ i ] ; }
function isPowerOfTwo ( n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; }
function previousPowerOfTwo ( n ) { while ( ( n & n - 1 ) > 1 ) { n = n & n - 1 ; } return n ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function MaximumDivisors ( X , Y ) { let arr = new Array ( Y - X + 1 ) ; for ( let i = 0 ; i < arr . length ; i ++ ) arr [ i ] = 0 ; let mx = 0 ; let cnt = 0 ; for ( let i = 1 ; i * i <= Y ; i ++ ) { let sq = i * i ; let first_divisible ; if ( Math . floor ( X / i ) * i >= X ) first_divisible = Math . floor ( X / i ) * i ; else first_divisible = ( Math . floor ( X / i ) + 1 ) * i ; for ( let j = first_divisible ; j <= Y ; j += i ) { if ( j < sq ) continue ; else if ( j == sq ) arr [ j - X ] ++ ; else arr [ j - X ] += 2 ; } } for ( let i = X ; i <= Y ; i ++ ) { if ( arr [ i - X ] > mx ) { cnt = 1 ; mx = arr [ i - X ] ; } else if ( arr [ i - X ] == mx ) cnt ++ ; } return cnt ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function NearestElement ( A , D , P ) { if ( A == 0 ) return 0 ; else if ( D == 0 ) return - 1 ; else { let X = power ( D , P - 2 , P ) ; return ( X * ( P - A ) ) % P ; } }
function binaryToDecimal ( n ) { let num = n ; let dec_value = 0 ; let base = 1 ; let len = num . length ; for ( let i = len - 1 ; i >= 0 ; i -- ) { if ( num [ i ] == "1" ) dec_value += base ; base = base * 2 ; } return dec_value ; }
function numberSequence ( n ) { if ( n == 1 ) return 1 ; let s = "" ; for ( let i = 1 ; i < n ; i ++ ) s += "1" ; s += "0" ; for ( let i = 1 ; i <= n ; i ++ ) s += "1" ; let num = binaryToDecimal ( s ) ; return num ; }
function numberSequence ( n ) { let num = Math . pow ( 4 , n ) - Math . pow ( 2 , n ) - 1 ; return num ; }
function complement ( num ) { var i , len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = parseInt ( num / 10 ) ; if ( Math . abs ( num ) == 0 ) break ; } num = temp ; comp = parseInt ( Math . pow ( 10 , len ) - num ) ; return comp ; }
function calculate ( ar , size ) { var count = 0 ; for ( i = 0 ; i < size ; i ++ ) if ( ar [ i ] % 2 == 0 && ar [ i ] != 0 && ar [ i ] != 2 ) count ++ ; return count ; }
function prime ( num ) { var i , flag = 0 ; for ( i = 2 ; i <= num / 2 ; i ++ ) { if ( num % i == 0 ) { flag = 1 ; break ; } } if ( flag == 0 ) return 1 ; else return 0 ; }
function print_alternate_prime ( n ) { var counter = 0 ; for ( num = 2 ; num < n ; num ++ ) { if ( prime ( num ) == 1 ) { if ( counter % 2 == 0 ) document . write ( num + "▁" ) ; counter ++ ; } } }
function SieveOfEratosthenes ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } let flag = true ; for ( let p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { if ( flag ) { document . write ( p + "▁" ) ; flag = false ; } else { flag = true ; } } } }
function findGreater ( x , y ) { if ( x > y ) { return false ; } else { return true ; } }
function max_profit ( a , b , n , fee ) { var i , j , profit ; var l , r , diff_day = 1 , sum = 0 ; b [ 0 ] = 0 ; b [ 1 ] = diff_day ; for ( i = 1 ; i < n ; i ++ ) { l = 0 ; r = diff_day ; sum = 0 ; for ( j = n - 1 ; j >= i ; j -- ) { profit = ( a [ r ] - a [ l ] ) - fee ; if ( profit > 0 ) { sum = sum + profit ; } l ++ ; r ++ ; } if ( b [ 0 ] < sum ) { b [ 0 ] = sum ; b [ 1 ] = diff_day ; } diff_day ++ ; } return 0 ; }
function binomialCoeff ( x , n , k ) { var sum = 0 , term = 1 ; for ( var i = 1 ; i <= n && sum < k ; ++ i ) { term *= x - i + 1 ; term /= i ; sum += term ; } return sum ; }
function minTrials ( n , k ) { var low = 1 , high = k ; while ( low < high ) { var mid = parseInt ( ( low + high ) / 2 ) ; if ( binomialCoeff ( mid , n , k ) < k ) low = mid + 1 ; else high = mid ; } return low ; }
function preprocess ( ) { for ( let i = 1 ; i < N ; i ++ ) { let num = i ; for ( let j = 2 ; j <= Math . sqrt ( num ) ; j ++ ) { if ( num % j == 0 ) { v [ i ] . push ( j ) ; while ( num % j == 0 ) { num = num / j ; } } } if ( num > 2 ) v [ i ] . push ( num ) ; } }
function query ( number , n ) { return v [ number ] [ n - 1 ] ; }
function getsum ( a ) { let r = 0 , sum = 0 ; while ( a > 0 ) { r = a % 10 ; sum = sum + r ; a = Math . floor ( a / 10 ) ; } return sum ; }
function boost_hyperfactorial ( num ) { let val = 1 ; for ( let i = 1 ; i <= num ; i ++ ) { val = val * Math . pow ( i , i ) ; } return val ; }
function boost_hyperfactorial ( num ) { var val = 1 ; for ( var i = 1 ; i <= num ; i ++ ) { for ( var j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; }
function power ( x , y , p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function findOddPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
function summ ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
function printDigitalRoot ( n ) { var maxi = 1 ; var dig = 1 ; for ( i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { var d1 = summ ( n / i ) ; var d2 = summ ( i ) ; if ( d1 > maxi ) { dig = n / i ; maxi = d1 ; } if ( d2 > maxi ) { dig = i ; maxi = d2 ; } if ( d1 == maxi ) { if ( dig < ( n / i ) ) { dig = n / i ; maxi = d1 ; } } if ( d2 == maxi ) { if ( dig < i ) { dig = i ; maxi = d2 ; } } } } document . write ( dig + "▁" + maxi ) ; }
function gcd ( a , b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function isSurd ( n ) { for ( let i = 2 ; i * i <= n ; i ++ ) { let j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; }
function LastTwoDigit ( num ) { let one = num % 10 ; num = Math . floor ( num / 10 ) ; let tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; }
function power ( x , y , p ) { while ( y > 0 ) { let r = y & 1 ; if ( r == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function modPower ( x , y , p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function gcdPow ( a , n , c ) { if ( a % c == 0 ) return c ; let modexpo = modPower ( a , n , c ) ; return gcd ( modexpo , c ) ; }
function countOddSum ( ar , n ) { let temp = [ 1 , 0 ] ; let result = 0 , val = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { val = ( ( val + ar [ i ] ) % 2 + 2 ) % 2 ; temp [ val ] ++ ; } result = temp [ 0 ] * temp [ 1 ] ; return ( result ) ; }
function countOddSum ( a , n ) { let c_odd = 0 , result = 0 ; let odd = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { odd = ! odd ; } if ( odd ) { c_odd ++ ; } } for ( let i = 0 ; i < n ; i ++ ) { result += c_odd ; if ( a [ i ] % 2 == 1 ) { c_odd = ( n - i - c_odd ) ; } } return result ; }
function findNthRoot ( x , n ) { let low , high ; if ( x >= 0 && x <= 1 ) { low = x ; high = 1 ; } else { low = 1 ; high = x ; } let epsilon = 0.00000001 ; let guess = parseInt ( ( low + high ) / 2 , 10 ) ; while ( Math . abs ( ( Math . pow ( guess , n ) ) - x ) >= epsilon ) { if ( Math . pow ( guess , n ) > x ) { high = guess ; } else { low = guess ; } guess = ( low + high ) / 2 ; } document . write ( guess ) ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function SumOfPrimeDivisors ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) { if ( isPrime ( i ) ) sum += i ; } } return sum ; }
function Sum ( N ) { let SumOfPrimeDivisors = new Array ( N + 1 ) ; for ( let i = 0 ; i < SumOfPrimeDivisors . length ; i ++ ) { SumOfPrimeDivisors [ i ] = 0 ; } for ( let i = 2 ; i <= N ; ++ i ) { if ( SumOfPrimeDivisors [ i ] == 0 ) { for ( let j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function SumOfPrimeDivisors ( n ) { let sum = 0 ; let root_n = parseInt ( Math . sqrt ( n ) , 10 ) ; for ( let i = 1 ; i <= root_n ; i ++ ) { if ( n % i == 0 ) { if ( i == parseInt ( n / i , 10 ) && isPrime ( i ) ) { sum += i ; } else { if ( isPrime ( i ) ) { sum += i ; } if ( isPrime ( parseInt ( n / i , 10 ) ) ) { sum += ( parseInt ( n / i , 10 ) ) ; } } } } return sum ; }
function rangesum ( n , l , r ) { let arr = new Array ( n ) ; let c = 1 , i = 0 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } c = 2 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } let sum = 0 ; for ( i = l - 1 ; i < r ; i ++ ) { sum += arr [ i ] ; } return sum ; }
function sumeven ( n , l , r ) { let sum = 0 ; let mid = Math . floor ( n / 2 ) ; if ( r <= mid ) { let first = ( 2 * l - 1 ) ; let last = ( 2 * r - 1 ) ; let no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else if ( l >= mid ) { let first = ( 2 * ( l - n / 2 ) ) ; let last = ( 2 * ( r - n / 2 ) ) ; let no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else { let sumleft = 0 , sumright = 0 ; let first_term1 = ( 2 * l - 1 ) ; let last_term1 = ( 2 * ( n / 2 ) - 1 ) ; let no_of_terms1 = n / 2 - l + 1 ; sumleft = ( ( no_of_terms1 ) * ( ( first_term1 + last_term1 ) ) ) / 2 ; let first_term2 = 2 ; let last_term2 = ( 2 * ( r - n / 2 ) ) ; let no_of_terms2 = r - mid ; sumright = ( ( no_of_terms2 ) * ( ( first_term2 + last_term2 ) ) ) / 2 ; sum = ( sumleft + sumright ) ; } return sum ; }
function sumodd ( n , l , r ) { let mid = Math . floor ( n / 2 ) + 1 ; let sum = 0 ; if ( r <= mid ) { let first = ( 2 * l - 1 ) ; let last = ( 2 * r - 1 ) ; let no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else if ( l > mid ) { let first = ( 2 * ( l - mid ) ) ; let last = ( 2 * ( r - mid ) ) ; let no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else { let sumleft = 0 , sumright = 0 ; let first_term1 = ( 2 * l - 1 ) ; let last_term1 = ( 2 * mid - 1 ) ; let no_of_terms1 = mid - l + 1 ; sumleft = ( ( no_of_terms1 ) * ( ( first_term1 + last_term1 ) ) ) / 2 ; let first_term2 = 2 ; let last_term2 = ( 2 * ( r - mid ) ) ; let no_of_terms2 = r - mid ; sumright = ( ( no_of_terms2 ) * ( ( first_term2 + last_term2 ) ) ) / 2 ; sum = ( sumleft + sumright ) ; } return sum ; }
function rangesum ( n , l , r ) { let sum = 0 ; if ( n % 2 == 0 ) return sumeven ( n , l , r ) ; else return sumodd ( n , l , r ) ; }
function groupElements ( arr , n ) { let visited = Array ( n ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { visited [ i ] = false ; } for ( let i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { document . write ( arr [ i ] + "▁" ) ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { document . write ( arr [ i ] + "▁" ) ; visited [ j ] = true ; } } } } }
function rainDayProbability ( a , n ) { let count = 0 , m ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; }
function distance ( x1 , y1 , z1 , x2 , y2 , z2 ) { var d = Math . pow ( ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) + Math . pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; document . write ( "Distance▁is▁" + d . toFixed ( 10 ) ) ; return ; }
function DivisibleBy41 ( first , second , c , n ) { let digit = new Array ( n ) . fill ( 0 ) ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( let i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; let ans = digit [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; }
function findTetrahedralNumber ( n ) { return ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) ; }
function printSeries ( n ) { let prev = 0 ; let curr ; for ( let i = 1 ; i <= n ; i ++ ) { curr = findTetrahedralNumber ( i ) ; curr = curr + prev ; document . write ( curr + "▁" ) ; prev = curr ; } }
function printSeries ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; document . write ( num + "▁" ) ; } }
function findTriangularNumber ( n ) { return ( n * ( n + 1 ) ) / 2 ; }
function printSeries ( n ) { let i ; for ( i = 1 ; i <= n ; i ++ ) { let num = i * ( i + 1 ) * ( ( i + 2 ) / 6 ) ; document . write ( num + "▁" ) ; } }
function calculateSum ( n ) { let sum = 0 ; for ( let row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
function calculateSum ( n ) { sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
function findArea ( a ) { let area ; area = 5 * Math . sqrt ( 3 ) * a * a ; return area ; }
function findVolume ( a ) { let volume ; volume = ( 5 / 12 ) * ( 3 + Math . sqrt ( 5 ) ) * a * a * a ; return volume ; }
function findNthNonSquare ( n ) { var x = n ; var ans = x + Math . floor ( 0.5 + Math . sqrt ( x ) ) ; return parseInt ( ans ) ; }
function count_even_odd ( min , max , steps ) { var a , b , even , odd ; var beven = true , aeven = false ; var n = 2 ; for ( i = 0 ; i < n ; i ++ ) { a = steps [ i ] [ 0 ] ; b = steps [ i ] [ 1 ] ; if ( ! ( aeven || ( a & 1 ) > 0 ) ) aeven = true ; if ( beven ) { if ( ( b & 1 ) > 0 ) beven = false ; } else if ( ! ( ( a & 1 ) > 0 ) ) { if ( ! ( ( b & 1 ) > 0 ) ) beven = true ; } else { if ( ( b & 1 ) > 0 ) beven = true ; } } if ( beven ) { even = parseInt ( max / 2 ) - parseInt ( ( min - 1 ) / 2 ) ; odd = 0 ; } else { even = parseInt ( max / 2 ) - parseInt ( ( min - 1 ) / 2 ) ; odd = 0 ; } if ( ! ( beven ^ aeven ) ) even += max - min + 1 - parseInt ( max / 2 ) + parseInt ( ( min - 1 ) / 2 ) ; else odd += max - min + 1 - parseInt ( max / 2 ) + parseInt ( ( min - 1 ) / 2 ) ; document . write ( "even▁=▁" + even + ",▁odd▁=▁" + odd ) ; }
function getMaxOnes ( n , x ) { let zeroes = parseInt ( n / x , 10 ) ; zeroes = zeroes * zeroes ; let total = n * n ; let ans = total - zeroes ; return ans ; }
function ways ( n ) { var first = 2 ; var second = 3 ; var res = 0 ; for ( i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
function minimumOperations ( a , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . get ( a [ i ] ) != null ) { let x = mp . get ( a [ i ] ) ; mp . set ( a [ i ] , ++ x ) ; } else mp . set ( a [ i ] , 1 ) ; } let count = 0 ; for ( let [ key , value ] of mp . entries ( ) ) { if ( value > 1 ) { count += ( value - 1 ) ; } } return count ; }
function findVolume ( a , h ) { let Volume ; Volume = 3 * Math . sqrt ( 3 ) * a * a * h / 2 ; document . write ( "Volume:▁" + Volume . toFixed ( 3 ) ) ; }
function MinimumMail ( n , k , x ) { let m = ( n - 1 ) + Math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
function findAllSequence ( N ) { if ( N % 2 == 0 ) { return ( Math . pow ( 2 , N / 2 + 1 ) + Math . pow ( 2 , N / 2 ) - 2 ) ; } else { return ( Math . pow ( 2 , ( N + 1 ) / 2 ) + Math . pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } }
function computeTotient ( ) { for ( let i = 1 ; i <= N ; i ++ ) phi [ i ] = i ; for ( let p = 2 ; p <= N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( let i = 2 * p ; i <= N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
function power ( x , y , p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function calculate ( x , k , mod ) { let arr = new Array ( N ) ; arr . fill ( 0 ) ; let count = 0 ; while ( mod > 1 ) { arr [ count ++ ] = mod ; mod = phi [ mod ] ; } let result = 1 ; let loop = count + 1 ; arr [ count ] = 1 ; for ( let i = Math . min ( k , loop ) - 1 ; i >= 0 ; i -- ) result = power ( x , result , arr [ i ] ) ; return result ; }
function countOnes ( n ) { let count = 1 ; let rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; }
function fibonacci ( n ) { var fib ; for ( i = 0 ; i < n ; i ++ ) { fib = ( Math . pow ( ( 1 + Math . sqrt ( 5 ) ) , i ) - Math . pow ( ( 1 - Math . sqrt ( 5 ) ) , i ) ) / ( Math . pow ( 2 , i ) * Math . sqrt ( 5 ) ) ; document . write ( parseInt ( fib ) + "▁" ) ; } }
function findLCM ( a , b ) { var lar = Math . max ( a , b ) ; var small = Math . min ( a , b ) ; for ( i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }
function center_hexadecagonal_num ( n ) { return 8 * n * n - 8 * n + 1 ; }
function findNature ( a , b , n ) { var seq = Array ( MAX ) . fill ( 0 ) ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( var i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; return ( seq [ n ] & 1 ) ; }
function findNature ( a , b , n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }
function check ( m , n ) { var RHS = m * Math . log ( n ) ; var LHS = n * Math . log ( m ) ; if ( LHS > RHS ) { document . write ( "m^n▁>▁n^m" ) ; } else if ( LHS < RHS ) { document . write ( "m^n▁<▁n^m" ) ; } else { document . write ( "m^n▁=▁n^m" ) ; } }
function numberOfmeet ( a , b ) { var ans ; if ( a > b ) ans = a - b ; else ans = b - a ; if ( a < 0 ) a = a * ( - 1 ) ; if ( b < 0 ) b = b * ( - 1 ) ; return ans / gcd ( a , b ) ; }
function SieveOfEratosthenes ( primes ) { let prime = new Array ( MAX ) ; for ( let i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } for ( let p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } for ( let p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { primes . push ( p ) ; } } }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function maxDivisorRange ( a , b , l , h ) { var g = gcd ( a , b ) ; var res = - 1 ; for ( i = l ; i * i <= g && i <= h ; i ++ ) if ( g % i == 0 ) res = Math . max ( res , Math . max ( i , g / i ) ) ; return res ; }
function findMaxGCD ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let high = arr [ n - 1 ] ; let divisors = new Array ( high + 1 ) ; for ( let i = 0 ; i < divisors . length ; i ++ ) { divisors [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 1 ; j <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != Math . floor ( arr [ i ] / j ) ) divisors [ Math . floor ( arr [ i ] / j ) ] ++ ; } } } for ( let i = high ; i >= 1 ; i -- ) if ( divisors [ i ] >= k ) return i ; return 0 ; }
function primes ( n ) { var i = 2 ; var j = 0 ; var result = Array ( n )  var z = 0 ; while ( j < n ) { var flag = true ; for ( var item = 2 ; item <= parseInt ( i * 1 / 2 ) ; item ++ ) if ( i % item == 0 && i != item ) { flag = false ; break ; } if ( flag ) { result [ z ++ ] = i ; j += 1 ; } i += 1 ; } for ( i = 0 ; i < 5 ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) document . write ( result [ j ] ) ; document . write ( "▁" ) ; } }
function subtractOne ( x ) { let m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
function subtractOne ( x ) { return ( ( x << 1 ) + ( ~ x ) ) ; }
function Log2n ( n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; }
function isPowerOfd ( n , d ) { var count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % ( Log2n ( d ) ) == 0 ) ; } return false ; }
function meanVector ( mat ) { document . write ( "[▁" ) ; for ( var i = 0 ; i < rows ; i ++ ) { var mean = 0.00 ; var sum = 0 ; for ( var j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; document . write ( mean + "▁" ) ; } document . write ( "]" ) ; }
function findMissing ( a , b , n , m ) { for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) document . write ( a [ i ] + "▁" ) ; } }
function countDigits ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += Math . log10 ( i ) ; ans = ans * n ; return 1 + Math . floor ( ans ) ; }
function checksum ( n ) { if ( n == 0 ) { document . write ( "-2▁-1▁0▁1▁2" ) ; return ; } var inc ; if ( n > 0 ) inc = 1 ; else inc = - 1 ; for ( i = 0 ; i <= n - 4 ; i += inc ) { if ( i + i + 1 + i + 2 + i + 3 + i + 4 == n ) { document . write ( ( i ) + "▁" + ( i + 1 ) + "▁" + ( i + 2 ) + "▁" + ( i + 3 ) + "▁" + ( i + 4 ) ) ; return ; } } document . write ( "-1" ) ; }
function checksum ( n ) { if ( n % 5 == 0 ) document . write ( ( n / 5 - 2 ) + "▁" + ( n / 5 - 1 ) + "▁" + ( n / 5 ) + "▁" + ( n / 5 + 1 ) + "▁" + ( n / 5 + 2 ) ) ; else document . write ( "-1" ) ; }
function printGreater ( x , y ) { let X = y * Math . log ( x ) ; let Y = x * Math . log ( y ) ; if ( Math . abs ( X - Y ) < 1e-9 ) { document . write ( "Equal" ) ; } else if ( X > Y ) { document . write ( x + "^" + y ) ; } else { document . write ( y + "^" + x ) ; } }
function dfs ( i ) { if ( visited [ i ] == 1 ) return 0 ; visited [ i ] = 1 ; let x = dfs ( goesTo [ i ] ) ; return ( x + 1 ) ; }
function noOfTranspositions ( P , n ) { for ( let i = 1 ; i <= n ; i ++ ) visited [ i ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) goesTo [ P [ i ] ] = i + 1 ; let transpositions = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( visited [ i ] == 0 ) { let ans = dfs ( i ) ; transpositions += ans - 1 ; } } return transpositions ; }
function sumOfSeries ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }
function findMissing ( a , b , n , m ) { let s = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) s . add ( b [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) if ( ! s . has ( a [ i ] ) ) document . write ( a [ i ] + "▁" ) ; }
function countUnmarked ( N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; }
function factorial ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
function calculateSeries ( n ) { return factorial ( n + 1 ) - 1 ; }
function factorial ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
function Pentatope_number ( n ) { return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 24 ; }
function minimumLength ( x , y , z ) { return 1 + Math . abs ( x - y ) + Math . abs ( y - z ) ; }
function areEquivalent ( num1 , num2 ) { return divSum ( num1 ) == divSum ( num2 ) ; }
function dodecahedral_num ( n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }
function centered_heptagonal_num ( n ) { return parseInt ( ( 7 * n * n - 7 * n + 2 ) / 2 ) ; }
function centeredIcosahedralNum ( n ) { return parseInt ( ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ) ; }
function findSum ( n ) { return ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 ; }
function checkHankelMatrix ( n , m ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) return false ; } else { if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) return false ; } } } return true ; }
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
function Centered_Triangular_num ( n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; }
function Dodecagonal_number ( n ) { return 5 * n * n - 4 * n ; }
function check ( d , x ) { if ( bit ( parseInt ( x / d , 10 ) ) <= bit ( d ) ) return true ; return false ; }
function countDivisor ( n ) { return n - bs ( n ) + 1 ; }
function isPower ( n ) { for ( x = 2 ; x <= parseInt ( Math . sqrt ( n ) ) ; x ++ ) { var f = Math . log ( n ) / Math . log ( x ) ; if ( ( f - parseInt ( f ) ) == 0.0 ) return true ; } return false ; }
function wrapper ( q , n ) { var digitSum = Array ( N ) . fill ( 0 ) ; var factorDigitSum = Array ( N ) . fill ( 0 ) ; sumOddDigit ( digitSum ) ; sumFactor ( digitSum , factorDigitSum ) ; for ( var i = 0 ; i < q ; i ++ ) document . write ( factorDigitSum [ n [ i ] ] + "▁" ) ; }
function everMeet ( x1 , x2 , v1 , v2 ) { if ( x1 < x2 && v1 <= v2 ) { return false ; } if ( x1 > x2 && v1 >= v2 ) { return false ; } if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; } return ( ( x1 - x2 ) % ( v1 - v2 ) == 0 ) ; }
function find_maximum ( a , n , k ) { let b = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let x = a [ i ] ; let d = Math . min ( 1 + i , n - i ) ; if ( ! b . has ( x ) ) b . set ( x , d ) ; else { b . set ( x , Math . min ( d , b . get ( x ) ) ) ; } } let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let x = a [ i ] ; if ( x != k - x && b . has ( k - x ) ) ans = Math . min ( Math . max ( b . get ( x ) , b . get ( k - x ) ) , ans ) ; } return ans ; }
function number_of_digits ( n ) { let i , res , sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }
function MaximumHeight ( a , n ) { let result = 1 ; for ( i = 1 ; i <= n ; ++ i ) { let y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }
function distinctGCDs ( arr , N ) { let M = - 1 , ans = 0 ; var Mp = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { M = Math . max ( M , arr [ i ] ) ; Mp . set ( arr [ i ] , 1 ) ; } for ( let i = 1 ; i <= M ; i ++ ) { let currGcd = 0 ; for ( let j = i ; j <= M ; j += i ) { if ( Mp . has ( j ) ) { currGcd = gcd ( currGcd , j ) ; if ( currGcd == i ) { ans ++ ; break ; } } } } return ans ; }
function printCollatz ( n ) { while ( n != 1 ) { document . write ( n + "▁" ) ; if ( ( n & 1 ) != 0 ) n = 3 * n + 1 ; else n = parseInt ( n / 2 , 10 ) ; } document . write ( n ) ; }
function isProduct ( arr , n , x ) { for ( var i = 0 ; i < n - 1 ; i ++ ) for ( var j = i + 1 ; i < n ; i ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
function SieveOfEratosthenes ( n , prime , primesquare , a ) { for ( var i = 2 ; i <= n ; i ++ ) prime [ i ] = true ; for ( var i = 0 ; i <= ( n * n + 1 ) ; i ++ ) primesquare [ i ] = false ; prime [ 1 ] = false ; for ( var p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( var i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } var j = 0 ; for ( var p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { a [ j ] = p ; primesquare [ p * p ] = true ; j ++ ; } } }
function countDivisors ( n ) { if ( n == 1 ) return 1 ; var prime = Array ( n + 1 ) . fill ( false ) ; var primesquare = Array ( n * n + 1 ) . fill ( 0 ) ; SieveOfEratosthenes ( n , prime , primesquare , a ) ; var ans = 1 ; for ( var i = 0 ; ; i ++ ) { if ( a [ i ] * a [ i ] * a [ i ] > n ) break ; var cnt = 1 ; while ( n % a [ i ] == 0 ) { n = parseInt ( n / a [ i ] ) ; } ans = ans * cnt ; } if ( prime [ n ] ) ans = ans * 2 ; else if ( primesquare [ n ] ) ans = ans * 3 ; else if ( n != 1 ) ans = ans * 4 ; }
function sumofFactors ( n ) { var res = 1 ; for ( var i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { var count = 0 , curr_sum = 1 ; var curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = parseInt ( n / i ) ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
function checkArithmetic ( n ) { var count = countDivisors ( n ) ; var sum = sumofFactors ( n ) ; return ( sum % count == 0 ) ; }
function findGCD ( arr , n ) { var result = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) result = gcd ( arr [ i ] , result ) ; return result ; }
function binomialCoeff ( n , k ) { let C = new Array ( n + 1 ) ; let i , j ; for ( i = 0 ; i <= n ; i ++ ) { C [ i ] = new Array ( k + 1 ) ; for ( j = 0 ; j <= k ; j ++ ) { C [ i ] [ j ] = 0 ; } } for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
function sumTillX ( x , n ) { let odd = Math . ceil ( n / 2.0 ) ; if ( x <= odd ) return x * x ; let even = x - odd ; return ( ( odd * odd ) + ( even * even ) + even ) ; }
function rangeSum ( N , L , R ) { return sumTillX ( R , N ) - sumTillX ( L - 1 , N ) ; }
function magicOfSequence ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) sum += ( i * i * i + i * 2 ) ; return sum ; }
function magicOfSequence ( N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }
function isProduct ( arr , n , x ) { let hset = new Set ( ) ; if ( n < 2 ) return false ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { if ( x == 0 ) return true ; else continue ; } if ( x % arr [ i ] == 0 ) { if ( hset . has ( x / arr [ i ] ) ) return true ; hset . add ( arr [ i ] ) ; } } return false ; }
function repUnitValue ( n ) { if ( n % 2 == 0 n % 5 == 0 ) return 0 ; let rem = 1 ; let power = 1 ; let k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; }
function isSplittable ( n , m ) { let total_sum = parseInt ( ( n * ( n + 1 ) ) / 2 ) ; let sum_s1 = parseInt ( ( total_sum + m ) / 2 ) ; let sum_s2 = total_sum - sum_s1 ; if ( total_sum < m ) return false ; if ( sum_s1 + sum_s2 == total_sum && sum_s1 - sum_s2 == m ) return ( __gcd ( sum_s1 , sum_s2 ) == 1 ) ; return false ; }
function isPossibleToZero ( a , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) == 0 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }
function cosXSertiesSum ( x , n ) { x = x * ( PI / 180.0 ) ; let res = 1 ; let sign = 1 , fact = 1 , pow = 1 , i ; for ( i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
function isBlumInteger ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( let j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } for ( let i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] ) { if ( ( n % i == 0 ) && ( ( i - 3 ) % 4 ) == 0 ) { let q = parseInt ( n / i , 10 ) ; return ( q != i && prime [ q ] && ( q - 3 ) % 4 == 0 ) ; } } } return false ; }
function primeFactors ( n ) { var res = [ ] ; if ( n % 2 == 0 ) { while ( n % 2 == 0 ) n = parseInt ( n / 2 ) ; res . push ( 2 ) ; } for ( var i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = parseInt ( n / i ) ; res . push ( i ) ; } } if ( n > 2 ) res . push ( n ) ; return res ; }
function isHoax ( n ) { var pf = primeFactors ( n ) ; if ( pf [ 0 ] == n ) return false ; var all_pf_sum = 0 ; for ( var i = 0 ; i < pf . length ; i ++ ) { var pf_sum ; for ( pf_sum = 0 ; pf [ i ] > 0 ; pf_sum += pf [ i ] % 10 , pf [ i ] = parseInt ( pf [ i ] / 10 ) ) ; all_pf_sum += pf_sum ; } var sum_n ; for ( sum_n = 0 ; n > 0 ; sum_n += n % 10 , n = parseInt ( n / 10 ) ) ; return sum_n == all_pf_sum ; }
function nCr ( n , r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
function fact ( n ) { var res = 1 ; for ( var i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
function summingSeries ( n ) { return Math . pow ( n , 2 ) ; }
function nCr ( n , r ) { let Nr = n , Dr = 1 , ans = 1 ; for ( let i = 1 ; i <= r ; i ++ ) { ans = parseInt ( ( ans * Nr ) / ( Dr ) , 10 ) ; Nr -- ; Dr ++ ; } return ans ; }
function solve ( n ) { let N = 2 * n - 2 ; let R = n - 1 ; return nCr ( N , R ) * fact ( n - 1 ) ; }
function printSumsOfDigits ( n ) { for ( base = 2 ; base < n ; ++ base ) document . write ( solve ( n , base ) + "▁" ) ; }
function check ( N , D ) { let temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; }
function isValidNesbitt ( a , b , c ) { let A = a / ( b + c ) ; let B = b / ( a + c ) ; let C = c / ( a + b ) ; let inequality = A + B + C ; return ( inequality >= 1.5 ) ; }
function exactPrimeFactorCount ( n ) { let count = 0 ; if ( n % 2 == 0 ) { count ++ ; while ( n % 2 == 0 ) n = n / 2 ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { count ++ ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) count ++ ; return count ; }
function no_of_digit ( a , b ) { return ( Math . round ( ( b * Math . log10 ( a ) ) + 1 ) ) ; }
function gen ( n , r ) { var a = r [ r . length - 1 ] ; a ++ ; for ( var i = 1 ; i <= n ; a += 2 , i ++ ) r . push ( a ) ; return r ; }
function conell ( n ) { var res = [ ] ; var k = 1 ; res . push ( 0 ) ; while ( 1 ) { res = gen ( k , res ) ; k ++ ; var j = res . length - 1 ; while ( j != n && j + k > n ) k -- ; if ( j >= n ) break ; } res . shift ( ) ; return res ; }
function factorial ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { res *= i ; } return res ; }
function printNComposite ( n ) { let fact = factorial ( n + 1 ) ; for ( let i = 2 ; i <= n + 1 ; ++ i ) { document . write ( fact + i + "▁" ) ; } }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function coprime ( a , b ) { return ( gcd ( a , b ) == 1 ) ; }
function isCubeFree ( n ) { if ( n == 1 ) return false ; for ( let i = 2 ; i * i * i <= n ; i ++ ) if ( n % ( i * i * i ) == 0 ) return false ; return true ; }
function printCubeFree ( n ) { var cubFree = Array ( n + 1 ) . fill ( false ) ; for ( i = 0 ; i <= n ; i ++ ) cubFree [ i ] = true ; for ( i = 2 ; i * i * i <= n ; i ++ ) { if ( cubFree [ i ] ) { for ( multiple = 1 ; i * i * i * multiple <= n ; multiple ++ ) { cubFree [ i * i * i * multiple ] = false ; } } } for ( i = 2 ; i <= n ; i ++ ) { if ( cubFree [ i ] == true ) document . write ( i + "▁" ) ; } }
function inversegrayCode ( n ) { let inv = 0 ; for ( ; n ; n = n >> 1 ) inv ^= n ; return inv ; }
function calculateDivisors ( A , B ) { let N = ( A - B ) ; let noOfDivisors = 0 ; for ( let i = 1 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( ( N % i ) == 0 ) { if ( i > B ) noOfDivisors ++ ; if ( ( N / i ) != i && ( N / i ) > B ) noOfDivisors ++ ; } } return noOfDivisors ; }
function numberOfPossibleWaysUtil ( A , B ) { if ( A == B ) return - 1 ; if ( A < B ) return 0 ; let noOfDivisors = 0 ; noOfDivisors = calculateDivisors ( A , B ) ; return noOfDivisors ; }
function printPowerNumber ( X , N ) { var power = [ ] ; power . push ( 1 ) ; var res = [ ] ; for ( var i = 1 ; i <= X ; i ++ ) { power = nextPower ( N , power ) ; res . push ( power [ power . length - 1 ] ) ; res . push ( power [ 0 ] ) ; } for ( var i = 0 ; i < res . length ; i ++ ) document . write ( res [ i ] ) ; }
function firstDigit ( n ) { let fact = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return ( Math . round ( fact ) ) ; }
function possibleToReach ( a , b ) { let c = Math . cbrt ( a * b ) ; let re1 = a / c ; let re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; }
function primes ( n ) { var prime = Array ( n + 1 ) . fill ( true ) ; for ( var i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( var j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } var arr = [ ] ; for ( var i = 2 ; i < n ; i ++ ) if ( prime [ i ] ) arr . push ( i ) ; return arr ; }
function countDigits ( n ) { var temp = n ; var c = 0 ; while ( temp != 0 ) { temp = parseInt ( temp / 10 ) ; c ++ ; } return c ; }
function frugal ( n ) { var r = primes ( n ) ; var t = n ; var s = 0 ; for ( var i = 0 ; i < r . length ; i ++ ) { if ( t % r [ i ] == 0 ) { var k = 0 ; while ( t % r [ i ] == 0 ) { t = parseInt ( t / r [ i ] ) ; k ++ ; } if ( k == 1 ) s = s + countDigits ( r [ i ] ) ; else if ( k != 1 ) s = s + countDigits ( r [ i ] ) + countDigits ( k ) ; } } return ( countDigits ( n ) > s && s != 0 ) ; }
function nthSquareCube ( n ) { return n * n * n * n * n * n ; }
function findGreatest ( arr , n ) { let result = - 1 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n - 1 ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; }
function isPerfectSquare ( x ) { var sr = Math . sqrt ( x ) ; if ( ( sr - Math . floor ( sr ) ) == 0 ) return parseInt ( ( Math . floor ( sr ) ) ) ; else return - 1 ; }
function findS ( s ) { var sr = isPerfectSquare ( s ) ; if ( sr == - 1 ) return - 1 ; return isTriangular ( sr ) ; }
function powerNumbers ( n ) { let v = new Set ( ) ; for ( let i = 2 ; i * i * i <= n ; i ++ ) { let j = i * i ; while ( j * i <= n ) { j *= i ; let s = parseInt ( Math . sqrt ( j ) , 10 ) ; if ( s * s != j ) v . add ( j ) ; } } return v . size + parseInt ( Math . sqrt ( n ) , 10 ) ; }
function NicomachuTheorum_sum ( n ) { let sum = 0 ; for ( let k = 1 ; k <= n ; k ++ ) sum += k * k * k ; let triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function checkDigits ( n ) { while ( n > 0 ) { if ( ( ( n % 10 ) % 2 ) > 0 ) return 0 ; n = parseInt ( n / 10 ) ; } return 1 ; }
function largestNumber ( n ) { for ( i = n ; ; i -- ) if ( checkDigits ( i ) > 0 ) return i ; }
function largestNumber ( n ) { var s = "" ; var duplicate = n ; while ( n > 0 ) { s = String . fromCharCode ( n % 10 + 48 ) + s ; n = parseInt ( n / 10 ) ; } var index = - 1 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( ( ( ( s . charAt ( i ) . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) % 2 ) & 1 ) > 0 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; var num = 0 ; for ( i = 0 ; i < index ; i ++ ) num = num * 10 + ( s . charAt ( i ) . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) ; num = num * 10 + ( s . charAt ( index ) . charCodeAt ( 0 ) - ( "0" ) . charCodeAt ( 0 ) - 1 ) ; for ( i = index + 1 ; i < s . length ; i ++ ) num = num * 10 + 8 ; return num ; }
function countDigits ( n ) { return ( n * Math . log10 ( 2 ) + 1 ) ; }
function check_digits ( n ) { while ( n != 0 ) { if ( ( n % 10 ) % 2 != 0 ) return 0 ; n = parseInt ( n / 10 ) ; } return 1 ; }
function smallest_number ( n ) { for ( i = n ; ; i ++ ) if ( check_digits ( i ) != 0 ) return i ; }
function trickyCase ( s , index ) { let index1 = - 1 ; for ( let i = index - 1 ; i >= 0 ; i -- ) { let digit = s [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ; if ( digit != 8 ) { index1 = i ; break ; } } if ( index1 == - 1 ) return 2 * Math . pow ( 10 , s . length ) ; let num = 0 ; for ( let i = 0 ; i < index1 ; i ++ ) num = num * 10 + ( s [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ) ; if ( s [ index1 ] . charCodeAt ( ) % 2 == 0 ) num = num * 10 + ( s [ index1 ] . charCodeAt ( ) - "0" . charCodeAt ( ) + 2 ) ; else num = num * 10 + ( s [ index1 ] . charCodeAt ( ) - "0" . charCodeAt ( ) + 1 ) ; for ( let i = index1 + 1 ; i < s . length ; i ++ ) num = num * 10 ; return num ; }
function smallestNumber ( n ) { let num = 0 ; let s = "" ; let duplicate = n ; while ( n > 0 ) { s = String . fromCharCode ( n % 10 + 48 ) + s ; n = parseInt ( n / 10 , 10 ) ; } let index = - 1 ; for ( let i = 0 ; i < s . length ; i ++ ) { let digit = s [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ; let val = digit & 1 ; if ( val == 1 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; if ( s [ index ] == "9" ) { num = trickyCase ( s , index ) ; return num ; } for ( let i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ) ; num = num * 10 + ( s [ index ] . charCodeAt ( ) - "0" . charCodeAt ( ) + 1 ) ; for ( let i = index + 1 ; i < s . length ; i ++ ) num = num * 10 ; return num ; }
function findBucketNo ( p ) { return Math . ceil ( ( Math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }
function mean ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) sum += a [ i ] [ j ] ; return sum / ( n * n ) ; }
function variance ( a , n , m ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { a [ i ] [ j ] -= m ; a [ i ] [ j ] *= a [ i ] [ j ] ; } } for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) sum += a [ i ] [ j ] ; return sum / ( n * n ) ; }
function productPrimeFactors ( n ) { var product = 1 ; if ( n % 2 == 0 ) { product *= 2 ; while ( n % 2 == 0 ) n = n / 2 ; } for ( i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { product = product * i ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) product = product * n ; return product ; }
function factorial ( n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
function sieve ( ) { let isPrime = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) isPrime [ i ] = true ; for ( let p = 2 ; p * p < MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( let i = p * 2 ; i < MAX ; i += p ) isPrime [ i ] = false ; } } for ( let p = 2 ; p < MAX ; p ++ ) if ( isPrime [ p ] == true ) primes . push ( p ) ; }
function modMult ( a , b , mod ) { let res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b = Math . floor ( b / 2 ) ; } return res % mod ; }
function countWays ( n , m ) { let ans = 1 ; for ( let i = 1 ; i < primes . length ; i ++ ) { let powers = power ( n , primes [ i ] ) ; if ( powers == 0 ) break ; ans = modMult ( ans , powers + 1 , m ) % m ; } if ( ( ( ans - 1 ) % m ) < 0 ) return ( ans - 1 + m ) % m ; else return ( ans - 1 ) % m ; }
function subset ( ar , n ) { let res = 0 ; ar . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }
function findNth ( n ) { let count = 0 ; for ( let curr = 19 ; ; curr += 9 ) { let sum = 0 ; for ( let x = curr ; x > 0 ; x = parseInt ( x / 10 ) ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return - 1 ; }
function pythagoreanTriplet ( n ) { for ( let i = 1 ; i <= n / 3 ; i ++ ) { for ( let j = i + 1 ; j <= n / 2 ; j ++ ) { let k = n - i - j ; if ( i * i + j * j == k * k ) { document . write ( i + ",▁" + j + ",▁" + k ) ; return ; } } } document . write ( "No▁Triplet" ) ; }
function sumofFactors ( n ) { let res = 1 ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { let count = 0 , curr_sum = 1 ; let curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function checkFriendly ( n , m ) { let sumFactors_n = sumofFactors ( n ) ; let sumFactors_m = sumofFactors ( m ) ; let gcd_n = gcd ( n , sumFactors_n ) ; let gcd_m = gcd ( m , sumFactors_m ) ; if ( n / gcd_n == m / gcd_m && sumFactors_n / gcd_n == sumFactors_m / gcd_m ) return true ; else return false ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function primorial ( n ) { let p = 2 ; n -- ; for ( let i = 3 ; n != 0 ; i ++ ) { if ( isPrime ( i ) == true ) { p = p * i ; n -- ; } i ++ ; } return p ; }
function findNextPrime ( n ) { let nextPrime = n + 2 ; while ( true ) { if ( isPrime ( nextPrime ) == true ) break ; nextPrime ++ ; } return nextPrime ; }
function findSum ( n ) { let multiTerms = n * ( n + 1 ) / 2 ; let sum = multiTerms ; for ( let i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }
function procal ( n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
function testSomeNumbers ( limit , n ) { if ( n < 3 ) return ; for ( let a = 1 ; a <= limit ; a ++ ) for ( let b = a ; b <= limit ; b ++ ) { let pow_sum = ( Math . pow ( a , n ) + Math . pow ( b , n ) ) ; let c = Math . pow ( pow_sum , 1.0 / n ) ; let c_pow = Math . pow ( Math . round ( c ) , n ) ; if ( c_pow == pow_sum ) { document . write ( "Count▁example▁found" ) ; return ; } } document . write ( "No▁counter▁example▁within▁given" + "▁range▁and▁data" ) ; }
function series ( A , X , n ) { let nFact = factorial ( n ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { let niFact = factorial ( n - i ) ; let iFact = factorial ( i ) ; let aPow = Math . pow ( A , n - i ) ; let xPow = Math . pow ( X , i ) ; document . write ( ( nFact * aPow * xPow ) / ( niFact * iFact ) + "▁" ) ; } }
function series ( A , X , n ) { let term = Math . pow ( A , n ) ; document . write ( term + "▁" ) ; for ( let i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; document . write ( term + "▁" ) ; } }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function productReduce ( n , num , den ) { let new_num = 1 , new_den = 1 ; for ( let i = 0 ; i < n ; i ++ ) { new_num *= num [ i ] ; new_den *= den [ i ] ; } let GCD = gcd ( new_num , new_den ) ; new_num /= GCD ; new_den /= GCD ; document . write ( new_num + "/" + new_den ) ; }
function digSum ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
function repeatedNumberSum ( n , x ) { sum = x * digSum ( n ) ; return digSum ( sum ) ; }
function totalSumDivisibleByNum ( n , number ) { let firstnum = Math . pow ( 10 , n - 1 ) ; let lastnum = Math . pow ( 10 , n ) ; let sum = 0 ; for ( let i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }
function minRemove ( a , b , n , m ) { let countA = new Map ( ) ; let countB = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( countA . has ( a [ i ] ) ) countA . set ( a [ i ] , countA . get ( a [ i ] ) + 1 ) ; else countA . set ( a [ i ] , 1 ) ; } for ( let i = 0 ; i < m ; i ++ ) { if ( countB . has ( b [ i ] ) ) countB . set ( b [ i ] , countB . get ( b [ i ] ) + 1 ) ; else countB . set ( b [ i ] , 1 ) ; } let res = 0 ; for ( let x of countA . keys ( ) ) if ( countB . has ( x ) ) res += Math . min ( countB . get ( x ) , countA . get ( x ) ) ; return res ; }
function totalSumDivisibleByNum ( digit , number ) { let firstnum = Math . pow ( 10 , digit - 1 ) ; let lastnum = Math . pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; let count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; }
function numberofterm ( n , number ) { let firstnum = Math . pow ( 10 , n - 1 ) ; let lastnum = Math . pow ( 10 , n ) ; let count = 0 ; for ( let i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
function sumofseries ( n ) { let res = 0 ; for ( let i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }
function sumofseries ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; }
function seiresSum ( n , a ) { let res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }
function seiresSum ( n , a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
function printGMeans ( A , B , N ) { let R = Math . pow ( ( B / A ) , 1.0 / ( N + 1 ) ) ; for ( let i = 1 ; i <= N ; i ++ ) document . write ( A * Math . pow ( R , i ) + "▁" ) ; }
function checkdigit ( n , k ) { while ( n != 0 ) { let rem = n % 10 ; if ( rem == k ) return true ; n = n / 10 ; } return false ; }
function isValid ( i , m ) { let sq_i = Math . sqrt ( i ) ; let sq = Math . min ( m , sq_i ) ; for ( let j = 2 ; j <= sq ; j ++ ) if ( i % j == 0 ) return false ; return true ; }
function findLargestNum ( n , m ) { for ( let i = n ; i > m ; i -- ) { if ( isValid ( i , m ) ) { document . write ( i ) ; return ; } } document . write ( "Number▁Doesn't▁Exists" ) ; }
function georgeCantor ( n ) { let i = 1 ; let j = 1 ; let k = 1 ; while ( k < n ) { j ++ ; k ++ ; if ( k == n ) break ; while ( j > 1 && k < n ) { i ++ ; j -- ; k ++ ; } if ( k == n ) break ; i ++ ; k ++ ; if ( k == n ) break ; while ( i > 1 && k < n ) { i -- ; j ++ ; k ++ ; } } document . write ( "N-th▁term▁:▁" + i + "/" + j ) ; }
function isDivisible ( n ) { while ( parseInt ( n / 100 ) ) { let last_digit = n % 10 ; n = parseInt ( n / 10 ) ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }
function digitSum ( n ) { let digSum = 0 ; while ( n > 0 ) { digSum += n % 10 ; n /= 10 ; } return digSum ; }
function countInteger ( n , s ) { if ( n < s ) return 0 ; for ( let i = s ; i <= Math . min ( n , s + 163 ) ; i ++ ) if ( ( i - digitSum ( i ) ) > s ) return ( n - i + 1 ) ; return 0 ; }
function division ( num1 , num2 ) { if ( num1 == 0 ) return 0 ; if ( num2 == 0 ) return Number . MAX_VALUE ; ; let negResult = false ; if ( num1 < 0 ) { num1 = - num1 ; if ( num2 < 0 ) num2 = - num2 ; else negResult = true ; } else if ( num2 < 0 ) { num2 = - num2 ; negResult = true ; } let quotient = 0 ; while ( num1 >= num2 ) { num1 = num1 - num2 ; quotient ++ ; } if ( negResult ) quotient = - quotient ; return quotient ; }
function pronic_check ( n ) { var x = parseInt ( Math . sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; }
function power ( n , r ) { let count = 0 ; for ( let i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; }
function isOrthogonal ( a , m , n ) { if ( m != n ) return false ; let trans = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { trans [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) trans [ i ] [ j ] = a [ j ] [ i ] ; } let prod = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { prod [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { let sum = 0 ; for ( let k = 0 ; k < n ; k ++ ) { sum = sum + ( a [ i ] [ k ] * a [ j ] [ k ] ) ; } prod [ i ] [ j ] = sum ; } } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i != j && prod [ i ] [ j ] != 0 ) return false ; if ( i == j && prod [ i ] [ j ] != 1 ) return false ; } } return true ; }
function digitNumber ( n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 9 ; if ( n % 2 ) { let temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { let temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } }
function countExcluding ( n , d ) { if ( d == 0 ) return ( 9 * digitNumber ( n - 1 ) ) % mod ; else return ( 8 * digitNumber ( n - 1 ) ) % mod ; }
function isPerfectSquare ( x ) { if ( x >= 0 ) { let sr = Math . sqrt ( x ) ; return ( ( sr * sr ) == x ) ; } return false ; }
function checkperfectsquare ( n ) { if ( Math . ceil ( Math . sqrt ( n ) ) == Math . floor ( Math . sqrt ( n ) ) ) { document . write ( "perfect▁square" ) ; } else { document . write ( "not▁a▁perfect▁square" ) ; } }
function printGP ( a , r , n ) { let curr_term ; for ( let i = 0 ; i < n ; i ++ ) { curr_term = a * Math . pow ( r , i ) ; document . write ( curr_term + "▁" ) ; } }
function Nth_of_AP ( a , d , N ) { return ( a + ( N - 1 ) * d ) ; }
function checkFibinnary ( n ) { var prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }
function check ( n , p ) { let maximum = - 1 ; while ( ! ( n % 2 ) ) { maximum = Math . max ( maximum , 2 )  n = n / 2 ; } var i ; for ( i = 3 ; i * i <= n ; i += 2 ) { while ( n % i == 0 ) { maximum = Math . max ( maximum , i ) ; n = n / i ; } } if ( n > 2 ) maximum = Math . max ( maximum , n ) ; if ( maximum <= p ) return true ; else return false ; }
function Nonagonal ( n ) { return parseInt ( n * ( 7 * n - 5 ) / 2 ) ; }
function Nonagonal ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { document . write ( parseInt ( i * ( 7 * i - 5 ) / 2 ) + "▁" ) ; } }
function findLcm ( arr , size ) { let ans = arr [ 0 ] [ 1 ] ; for ( let i = 1 ; i < size ; i ++ ) ans = Math . floor ( ( ( arr [ i ] [ 1 ] * ans ) ) / ( gcd ( arr [ i ] [ 1 ] , ans ) ) ) ; return ( ans ) ; }
function checkplusperfect ( x ) { let temp = x ; let n = 0 ; while ( x != 0 ) { x = parseInt ( x / 10 ) ; n ++ ; } x = temp ; let sum = 0 ; while ( x != 0 ) { sum += Math . pow ( x % 10 , n ) ; x = parseInt ( x / 10 ) ; } return ( sum == temp ) ; }
function sum_series ( n ) { let nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; }
function isPrime ( n ) { if ( n == 0 n == 1 ) return false ; let root = Math . sqrt ( n ) ; for ( let i = 2 ; i <= root ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
function isSandwitched ( n ) { return ( isPrime ( n - 1 ) && isPrime ( n + 1 ) ) ; }
function Div_by_8 ( n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; }
function mean ( mid , freq , n ) { let sum = 0 , freqSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + mid [ i ] * freq [ i ] ; freqSum = freqSum + freq [ i ] ; } return sum / freqSum ; }
function groupedSD ( lower_limit , upper_limit , freq , n ) { let mid = [ ] ; let sum = 0 , freqSum = 0 , sd ; for ( let i = 0 ; i < n ; i ++ ) { mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 ; sum = sum + freq [ i ] * mid [ i ] * mid [ i ] ; freqSum = freqSum + freq [ i ] ; } sd = Math . sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) ; return sd ; }
function divisibleBy20 ( num ) { let lastTwoDigits = parseInt ( num . slice ( - 2 , num . length ) ) console . log ( num . slice ( - 2 , 1 ) ) return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) }
function findArea ( d ) { return ( d * d ) / 2 ; }
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
function sumOfSeries ( n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
function getMSB ( n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( ( n + 1 ) >> 2 ) ; }
function multiply ( F , M ) { let x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ; let y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ; let z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ; let w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; }
function power ( F , n ) { if ( n == 0 n == 1 ) return ; let M = [ [ 1 , 1 ] , [ 1 , 0 ] ] ; for ( let m = getMSB ( n ) ; m > 0 ; m = m >> 1 ) { multiply ( F , F ) ; if ( ( n & m ) > 0 ) { multiply ( F , M ) ; } } }
function fib ( n ) { let F = [ [ 1 , 1 ] , [ 1 , 0 ] ] ; if ( n == 0 ) return 0 ; power ( F , n - 1 ) ; return F [ 0 ] [ 0 ] ; }
function isDvisibleBy12 ( num ) { if ( num . length >= 3 ) { let d1 = num [ num . length - 1 ] . charCodeAt ( ) ; if ( d1 % 2 != 0 ) return false ; let d2 = num [ num . length - 2 ] . charCodeAt ( ) ; let sum = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) sum += num [ i ] . charCodeAt ( ) ; return ( ( sum % 3 == 0 ) && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { let number = parseInt ( num , 10 ) ; document . write ( number ) ; return ( number % 12 == 0 ) ; } }
function StepstoReachTarget ( target ) { target = Math . abs ( target ) ; let n = Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8.0 * target ) ) / 2 ) ; let sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; let d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; }
function Calculate_GST ( org_cost , N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }
function avg_of_even_num ( n ) { return n + 1 ; }
function avg_of_odd_num ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; }
function avg_of_odd_num ( n ) { return n ; }
function seriesSum ( n ) { let i = 1 ; let res = 0.0 ; let sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ++ i / ++ i ; } else { sign = ! sign ; res = res - ++ i / ++ i ; } } return res ; }
function check ( n ) { let d = Math . sqrt ( n ) ; if ( d * d == n ) return true ; return false ; }
function largestNonPerfectSquareNumber ( a , n ) { let maxi = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! check ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; }
function modInverse ( a , prime ) { a = a % prime ; for ( let x = 1 ; x < prime ; x ++ ) if ( ( a * x ) % prime == 1 ) return x ; return - 1 ; }
function printModIverses ( n , prime ) { for ( let i = 1 ; i <= n ; i ++ ) document . write ( modInverse ( i , prime ) + "▁" ) ; }
function countSymmetric ( n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; }
function SternSequenceFunc ( BrocotSequence , n ) { for ( var i = 1 ; BrocotSequence . length < n ; i ++ ) { var considered_element = BrocotSequence [ i ] ; var precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . push ( considered_element + precedent ) ; BrocotSequence . push ( considered_element ) ; } for ( var i = 0 ; i < 15 ; ++ i ) document . write ( BrocotSequence [ i ] + "▁" ) ; }
function centeredNonagonal ( n ) { return parseInt ( ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ) ; }
function sieve ( n , prime ) { for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } }
function printSophieGermanNumber ( n ) { let prime = new Array ( ) ; for ( let i = 0 ; i < ( 2 * n + 1 ) ; i ++ ) prime [ i ] = true ; sieve ( 2 * n + 1 , prime ) ; for ( let i = 2 ; i <= n ; ++ i ) { if ( prime [ i ] && prime [ 2 * i + 1 ] ) document . write ( i + "▁" ) ; } }
function fib ( f , N ) { f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( var i = 3 ; i <= N ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; }
function printAP ( a , d , n ) { let curr_term ; curr_term = a ; for ( let i = 1 ; i <= n ; i ++ ) { document . write ( curr_term + "▁" ) ; curr_term = curr_term + d ; } }
function Mean ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum / n ; }
function isRevDiffDivisible ( x , k ) { var n = x ; var m = 0 ; var flag ; while ( x > 0 ) { m = m * 10 + x % 10 ; x = parseInt ( x / 10 ) ; } return ( Math . abs ( n - m ) % k == 0 ) ; }
function countNumbers ( l , r , k ) { var count = 0 ; for ( i = l ; i <= r ; i ++ ) if ( isRevDiffDivisible ( i , k ) ) count ++ ; return count ; }
function isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) { for ( let i = lowQuant ; i <= upQuant ; i ++ ) { let ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }
function centeredHexagonalNumber ( n ) { return 3 * n * ( n - 1 ) + 1 ; }
function oddNumSum ( n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }
function isPerfectSquare ( n ) { if ( n < 0 ) return false ; let root = Math . round ( ( Math . sqrt ( n ) ) ) ; return n == root * root ; }
function printnonsquare ( n ) { let count = 0 ; for ( let i = 1 ; count < n ; ++ i ) { if ( ! isPerfectSquare ( i ) ) { document . write ( i + "▁" ) ; count ++ ; } } }
function nonsquare ( n ) { return n + parseInt ( 0.5 + Math . sqrt ( n ) ) ; }
function printNonSquare ( n ) { for ( let i = 1 ; i <= n ; i ++ ) document . write ( nonsquare ( i ) + "▁" ) ; }
function trailingZero ( x ) { let i = 5 ; let count = 0 ; while ( x > i ) { count = count + parseInt ( x / i ) ; i = i * 5 ; } return count ; }
function countProductTrailing ( M , N ) { return trailingZero ( N ) + trailingZero ( M ) ; }
function isTrimorphic ( N ) { let cube = N * N * N ; while ( N > 0 ) { if ( N % 10 != cube % 10 ) return false ; N = parseInt ( N / 10 , 10 ) ; cube = parseInt ( cube / 10 , 10 ) ; } return true ; }
function checkTrimorphic ( num ) { let cube = num * num * num ; while ( num > 0 ) { if ( num % 10 != cube % 10 ) return false ; num = Math . floor ( num / 10 ) ; cube = Math . floor ( cube / 10 ) ; } return true ; }
function averageEven ( n ) { if ( n % 2 != 0 ) { document . write ( "Invalid▁Input" ) ; return - 1 ; } let sum = 0 , count = 0 ; while ( n >= 2 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; }
function averageEven ( n ) { if ( n % 2 != 0 ) { document . write ( "Invalid▁Input" ) ; return - 1 ; } return ( n + 2 ) / 2 ; }
function averageOdd ( n ) { if ( n % 2 == 0 ) { document . write ( "Invalid▁Input" ) ; return - 1 ; } let sum = 0 , count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; }
function fifthPowerSum ( n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; }
function find_distance ( n ) { return n * ( 3 * n + 7 ) ; }
function nearestPerfectSquare ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let sr = Math . floor ( Math . sqrt ( arr [ i ] ) ) ; if ( ( sr & 1 ) == ( arr [ i ] & 1 ) ) document . write ( ( sr * sr ) + "▁" ) ; else { sr ++ ; document . write ( ( sr * sr ) + "▁" ) ; } } }
function squareSum ( n ) { return n * ( 4 * n * n - 1 ) / 3 ; }
function squareSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( 2 * i ) * ( 2 * i ) ; return sum ; }
function isMunchhausen ( n ) { var sum = 0 ; var temp = n ; while ( temp > 0 ) { var index = temp % 10 ; sum = sum + pwr [ index ] ; temp = parseInt ( temp / 10 ) ; } return ( sum == n ) ; }
function kthdigit ( a , b , k ) { let p = Math . pow ( a , b ) ; let count = 0 ; while ( p > 0 && count < k ) { let rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
function isPentagonal ( N ) { var i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
function fourthPowerSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; }
function unitDigitXRaisedY ( x , y ) { let res = 1 ; for ( let i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
function unitnumber ( x , y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( parseInt ( Math . pow ( x , y ) ) ) % 10 ) ; }
function isPrime ( n ) { if ( n % 2 == 0 ) return false ; for ( let i = 3 ; i * i <= n ; i += 2 ) if ( n % i == 0 ) return false ; return true ; }
function nextPrime ( start ) { let next = start + 1 ; while ( ! isPrime ( next ) ) next ++ ; return next ; }
function areAdjacentPrimes ( a , b , c ) { if ( ! isPrime ( a ) || ! isPrime ( b ) || ! isPrime ( c ) ) return false ; let next = nextPrime ( a ) ; if ( next != b ) return false ; if ( nextPrime ( b ) != c ) return false ; return true ; }
function findDivisor ( x , y ) { if ( x == y ) return y ; return 2 ; }
function digSum ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
function PowDigSum ( n , x ) { let sum = digSum ( n ) ; let rem = x % 6 ; if ( ( sum == 3 sum == 6 ) && x > 1 ) return 9 ; else if ( x == 1 ) return sum ; else if ( x == 0 ) return 1 ; else if ( rem == 0 ) return digSum ( Math . pow ( sum , 6 ) ) ; else return digSum ( Math . pow ( sum , rem ) ) ; }
function AvgofSquareN ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }
function AvgofSquareN ( n ) { return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
function sumofFactors ( n ) { if ( n % 2 != 0 ) return 0 ; let res = 1 ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { let count = 0 , curr_sum = 1 ; let curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
function func ( x ) { return ( 1 / ( 1 + x * x ) ) ; }
function calculate ( lower_limit , upper_limit , interval_limit ) { let value ; let interval_size = ( upper_limit - lower_limit ) / interval_limit ; let sum = func ( lower_limit ) + func ( upper_limit ) ; for ( let i = 1 ; i < interval_limit ; i ++ ) { if ( i % 3 == 0 ) sum = sum + 2 * func ( lower_limit + i * interval_size ) ; else sum = sum + 3 * func ( lower_limit + i * interval_size ) ; } return ( 3 * interval_size / 8 ) * sum ; }
function LCM ( a , b ) { return Math . floor ( ( a * b ) / ( __gcd ( a , b ) ) ) ; }
function lcmOfNumerator ( vect ) { let lcm = vect [ 0 ] . first ; for ( let i = 1 ; i < vect . length ; i ++ ) lcm = LCM ( vect [ i ] . first , lcm ) ; return lcm ; }
function gcdOfDemoninators ( vect ) { let gcd = vect [ 0 ] . second ; for ( let i = 1 ; i < vect . length ; i ++ ) gcd = __gcd ( vect [ i ] . second , gcd ) ; return gcd ; }
function lcmOfRationals ( vect ) { document . write ( lcmOfNumerator ( vect ) + "/" + gcdOfDemoninators ( vect ) ) ; }
function makePermutation ( a , n ) { var count = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( count . has ( a [ i ] ) ) count . set ( a [ i ] , count . get ( a [ i ] ) + 1 ) else count . set ( a [ i ] , 1 ) } var next_missing = 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( count . get ( a [ i ] ) != 1 a [ i ] > n a [ i ] < 1 ) { count . set ( a [ i ] , count . get ( a [ i ] ) - 1 ) ; while ( count . has ( next_missing ) ) next_missing ++ ; a [ i ] = next_missing ; count . set ( next_missing , 1 ) ; } } }
function focal_length_convex ( R ) { return - ( R / 2 ) ; }
function focal_length ( image_distance , object_distance ) { return 1 / ( ( 1 / image_distance ) + ( 1 / object_distance ) ) ; }
function sumofoddFactors ( n ) { let res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( let i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { let count = 0 ; let curr_sum = 1 ; let curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
function countSolutions ( n , val ) { let total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( let i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; }
function lcm ( a , b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function twinPrime ( n1 , n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && Math . abs ( n1 - n2 ) == 2 ) ; }
function mobius ( n ) { let p = 0 ; if ( n % 2 == 0 ) { n = parseInt ( n / 2 , 10 ) ; p ++ ; if ( n % 2 == 0 ) return 0 ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = parseInt ( n / i , 10 ) ; p ++ ; if ( n % i == 0 ) return 0 ; } } return ( p % 2 == 0 ) ? - 1 : 1 ; }
function fib ( f , n ) { var i ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( i = 2 ; i <= n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; }
function fibcoef ( fc , f , n ) { for ( i = 0 ; i <= n ; i ++ ) fc [ i ] [ 0 ] = 1 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= i ; j ++ ) { var k = j ; while ( k > 0 ) { k -- ; fc [ i ] [ j ] *= f [ k ] ; } k = 1 ; while ( ( j + 1 ) != k ) fc [ i ] [ j ] /= f [ k ++ ] ; } } }
function sumOfSeries ( n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
function sumofNterm ( a , d , b , r , n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * Math . pow ( r , i - 1 ) ) ) ; return sum ; }
function sumOfTheSeries ( n ) { let sum = 0.0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; }
function sum ( n ) { let root = parseInt ( Math . sqrt ( n ) ) ; let ans = 0 ; for ( let i = 1 ; i <= root ; i ++ ) ans += parseInt ( n / i ) ; ans = ( 2 * ans ) - ( root * root ) ; return ans ; }
function sumOfTheSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let k = 2 ; for ( let j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
function sumOfTheSeries ( n ) { let sum_n = ( n * ( n + 1 ) / 2 ) ; let sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; }
function sumofsquare ( n ) { let C = new Array ( n + 1 ) ; for ( let i = 0 ; i < C . length ; i ++ ) { C [ i ] = new Array ( 2 ) ; } let i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } let sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
function factorial ( start , end ) { let res = 1 ; for ( let i = start ; i <= end ; i ++ ) res *= i ; return res ; }
function sumofsquare ( n ) { return parseInt ( factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) , 10 ) ; }
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; }
function sumOfSeries ( n ) { var sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + i * i ; return sum ; }
function sumOfSeries ( n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
function evenSum ( n ) { var C = Array . from ( Array ( n + 1 ) , ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; var i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } var sum = 0 ; for ( var i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; for ( let i = 0 ; i < m ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
function evenbinomialCoeffSum ( n ) { return ( 1 << ( n - 1 ) ) ; }
function Series ( n ) { let sums = 0.0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { ser = 1 / Math . pow ( i , i ) ; sums += ser ; } return sums ; }
function TrinomialValue ( n , k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k < - n k > n ) return 0 ; return TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 ) ; }
function Series ( n ) { let i ; let sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; }
function Series ( x , n ) { var sum = 1 , term = 1 , fct = 1 ; var p = 1 , multi = 1 ; for ( let i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( - 1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; }
function isPresent ( arr , low , high , value ) { while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( arr [ mid ] == value ) return true ; else if ( arr [ mid ] > value ) high = mid - 1 ; else low = mid + 1 ; } return false ; }
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; for ( let i = 0 ; i < m ; i ++ ) { let value = x - arr1 [ i ] ; if ( isPresent ( arr2 , 0 , n - 1 , value ) ) count ++ ; } return count ; }
function two_factor ( n ) { let twocount = 0 ; while ( n % 2 == 0 ) { twocount ++ ; n = n / 2 ; } return twocount ; }
function five_factor ( n ) { let fivecount = 0 ; while ( n % 5 == 0 ) { fivecount ++ ; n = n / 5 ; } return fivecount ; }
function find_con_zero ( arr , n ) { let twocount = 0 ; let fivecount = 0 ; for ( let i = 0 ; i < n ; i ++ ) { twocount += two_factor ( arr [ i ] ) ; fivecount += five_factor ( arr [ i ] ) ; } if ( twocount < fivecount ) return twocount ; else return fivecount ; }
function fib ( n ) { if ( n < 6 ) return f [ n ] ; let t = 5 , fn = 5 ; while ( t < n ) { fn = Math . round ( fn * PHI ) ; t ++ ; } return fn ; }
function first ( a , b , c ) { a %= b ; for ( let i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return - 1 ; }
function subsetDifference ( n ) { let s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { document . write ( "First▁subset▁sum▁=▁" + Math . floor ( s / 2 ) ) ; document . write ( "Second▁subset▁sum▁=▁" + Math . floor ( s / 2 ) ) ; document . write ( "Difference▁=▁" + 0 ) ; } else { if ( n % 4 == 1 n % 4 == 2 ) { document . write ( "First▁subset▁sum▁=▁" + Math . floor ( s / 2 ) ) ; document . write ( "Second▁subset▁sum▁=▁" + Math . floor ( s / 2 + 1 ) ) ; document . write ( "Difference▁=▁" + 1 ) ; } else { document . write ( "First▁subset▁sum▁=▁" + Math . floor ( s / 2 ) ) ; document . write ( "Second▁subset▁sum▁=▁" + Math . floor ( s / 2 ) ) ; document . write ( "Difference▁=▁" + 0 ) ; } } }
function func ( x , y ) { return ( x + y + x * y ) ; }
function euler ( x0 , y , h , x ) { let temp = - 0 ; while ( x0 < x ) { temp = y ; y = y + h * func ( x0 , y ) ; x0 = x0 + h ; } document . write ( "Approximate▁solution▁at▁x▁=▁" + x + "▁is▁" + y ) ; }
function timeToMeet ( s , v ) { var V = 3 * v / 2 ; var time = s / V ; document . write ( time . toFixed ( 6 ) ) ; }
function maxcoefficientvalue ( n ) { if ( n % 2 == 0 ) return binomialCoeff ( n , n / 2 ) ; else return binomialCoeff ( n , ( n + 1 ) / 2 ) ; }
function LCM ( x , y , z ) { let ans = ( ( x * y ) / ( __gcd ( x , y ) ) ) ; return ( ( z * ans ) / ( __gcd ( ans , z ) ) ) ; }
function findDivisible ( n , x , y , z ) { let lcm = LCM ( x , y , z ) ; let ndigitnumber = Math . pow ( 10 , n - 1 ) ; let reminder = ndigitnumber % lcm ; if ( reminder == 0 ) return ndigitnumber ; ndigitnumber += lcm - reminder ; if ( ndigitnumber < Math . pow ( 10 , n ) ) return ndigitnumber ; else return 0 ; }
function sumOfTheSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let k = 1 ; for ( let j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
function sumOfTheSeries ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
function checksum ( n ) { if ( n == 0 ) { document . write ( "-1▁0▁1" ) ; return ; } var inc ; if ( n > 0 ) inc = 1 ; else inc = - 1 ; for ( i = 0 ; i <= n - 2 ; i += inc ) { if ( i + i + 1 + i + 2 == n ) { document . write ( i + "▁" + ( i + 1 ) + "▁" + ( i + 2 ) ) ; return ; } } document . write ( "-1" ) ; }
function checksum ( n ) { if ( n % 3 == 0 ) document . write ( n / 3 - 1 + "▁" + n / 3 + "▁" + ( n / 3 + 1 ) ) ; else document . write ( "-1" ) ; }
function solution ( a , b , n ) { for ( let i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { document . write ( "x▁=▁" + i + ",▁y▁=▁" + ( n - ( i * a ) ) / b ) ; return ; } } document . write ( "No▁solution" ) ; }
function divisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; let l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
function divisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) sum += Math . floor ( n / i ) * i ; return sum ; }
function sum_all_divisors ( num ) { var sum = 0 ; for ( var i = 1 ; i <= Math . sqrt ( num ) ; i ++ ) { sum += t1 + t2 ; } return sum ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
function sumOfLargePrimeFactor ( n ) { let prime = new Array ( n + 1 ) ; let sum = 0 ; let max = n / 2 ; for ( let i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = 0 ; for ( let p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( let p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) sum += prime [ p ] ; else sum += p ; } return sum ; }
function gcd ( a , b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
function cpFact ( x , y ) { while ( gcd ( x , y ) != 1 ) { x = x / gcd ( x , y ) ; } return x ; }
function binomialCoeffSum ( n ) { return ( 1 << n ) ; }
function countSetBits ( n ) { var count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
function countUnsetBitsInGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return ( r - l + 1 ) - countSetBits ( n & num ) ; }
function evenPowerSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; }
function evenPowerSum ( n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; }
function balancedprime ( n ) { var prime = Array ( MAX + 1 ) . fill ( true ) ; for ( var p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( var i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } var v = [ ] ; for ( var p = 3 ; p <= MAX ; p += 2 ) if ( prime [ p ] ) v . push ( p ) ; var count = 0 ; for ( var i = 1 ; i < v . length ; i ++ ) { if ( v [ i ] == ( v [ i + 1 ] + v [ i - 1 ] ) / 2 ) count ++ ; if ( count == n ) return v [ i ] ; } }
function calculateNoOFactors ( n ) { if ( n == 1 ) return 1 ; var ans = 1 ; var dup = factor [ n ] ; var c = 1 ; var j = n / factor [ n ] ; while ( j != 1 ) { if ( factor [ j ] == dup ) c += 1 ; else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; } j = j / factor [ j ] ; } ans = ans * ( c + 1 ) ; return ans ; }
function smallest ( n ) { for ( i = 1 ; ; i ++ ) if ( calculateNoOFactors ( i ) >= n ) return i ; }
function squaresum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
function counLastDigitK ( low , high , k ) { let count = 0 ; for ( let i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }
function minimumSum ( n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; if ( isPrime ( n - 2 ) ) return 2 ; return 3 ; }
function lastDigit ( n ) { return Math . floor ( n % 10 ) ; }
function numberOfTriangles ( n ) { var ans = 2 * ( Math . pow ( 3 , n ) ) - 1 ; return ans ; }
function isPrime ( x ) { if ( x == 0 x == 1 ) return false ; for ( let i = 2 ; i * i <= x ; ++ i ) if ( x % i == 0 ) return false ; return true ; }
function findPrimes ( n ) { document . write ( n ) ; document . write ( 2 + "▁" + ( n - 2 ) ) ; { document . write ( 3 + "▁" ) ; n = n - 3 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isPrime ( i ) && isPrime ( n - i ) ) { document . write ( i + "▁" + ( n - i ) ) ; break ; } } } }
function checkDigits ( n ) { while ( n > 0 ) { let dig = n % 10 ; if ( dig != 2 && dig != 3 && dig != 5 && dig != 7 ) return false ; n = parseInt ( n / 10 , 10 ) ; } return true ; }
function prime ( n ) { if ( n == 1 ) return false ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
function isFullPrime ( n ) { return ( checkDigits ( n ) && prime ( n ) ) ; }
function coef ( n ) { c [ 0 ] = 1 ; for ( let i = 0 ; i < n ; c [ 0 ] = - c [ 0 ] , i ++ ) { c [ 1 + i ] = 1 ; for ( let j = i ; j > 0 ; j -- ) c [ j ] = c [ j - 1 ] - c [ j ] ; } }
function isPrime ( n ) { coef ( n ) ; c [ 0 ] ++ ; c [ n ] -- ; let i = n ; while ( ( i -- ) > 0 && c [ i ] % n == 0 ) ; return i < 0 ; }
function motzkin ( n ) { if ( n == 0 n == 1 ) return 1 ; return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) ; }
function sumOfSeries ( n ) { return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ; }
function check ( n ) { let l = countDigit ( n ) ; let dup = n ; let sum = 0 ; while ( dup ) { sum += Math . pow ( dup % 10 , l ) ; dup = parseINT ( dup / 10 ) ; } return ( n == sum ) ; }
function getResult ( st ) { let sum = 0 ; let length = st . length ; for ( let i = 0 ; i < length ; i ++ ) { sum = sum + Math . pow ( st [ i ] - "0" , length ) ; } let number = parseInt ( st , 10 ) ; if ( number == sum ) return "yes" ; else return "no" ; }
function solve ( low , high , T ) { while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }
function nthSHN ( n , dp ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }
function summation ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
function leyland ( n ) { let ans = [ ] ; let index = 0 ; for ( let x = 2 ; x <= n ; x ++ ) { for ( let y = 2 ; y <= x ; y ++ ) { let temp = Math . pow ( x , y ) + Math . pow ( y , x ) ; ans [ index ] = temp ; index ++ ; } } console . log ( ans )  ans = ans . sort ( ( a , b ) => a - b ) ; console . log ( ans )  for ( let i = 0 ; i < n ; i ++ ) document . write ( ans [ i ] + "▁" ) ; }
function isOverflow ( a , b ) { if ( a == 0 b == 0 ) return false ; var result = a * b ; if ( result >= 9223372036854775807 result <= - 9223372036854775808 ) result = 0  if ( a == parseInt ( result / b ) ) return false ; else return true ; }
function kthgroupsum ( k ) { let cur = ( k * ( k - 1 ) ) + 1 ; let sum = 0 ; while ( k -- ) { sum += cur ; cur += 2 ; } return sum ; }
function oddSum ( n ) { return ( n * n ) ; }
function mphTOkmph ( mph ) { return ( 1.60934 * mph ) ; }
function nthTerm ( n ) { return ( n * n ) + ( n * n * n ) ; }
function trace ( n , m ) { let an = 1 + ( n - 1 ) * ( m + 1 ) ; let rowmajorSum = sn ( n , an ) ; an = 1 + ( n - 1 ) * ( n + 1 ) ; let colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; }
function precompute ( prefix , suffix ) { let prime = [ ] ; for ( let i = 0 ; i < MAX ; i ++ ) { prime [ i ] = true ; } for ( let i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] ) { for ( let j = i * i ; j < MAX ; j += i ) { prime [ j ] = false ; } } } prefix [ 1 ] = 1 ; suffix [ MAX - 1 ] = 1e9 + 7 ; for ( let i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) { prefix [ i ] = i ; } else { prefix [ i ] = prefix [ i - 1 ] ; } } for ( let i = MAX - 2 ; i > 1 ; i -- ) { if ( prime [ i ] ) { suffix [ i ] = i ; } else { suffix [ i ] = suffix [ i + 1 ] ; } } }
function query ( prefix , suffix , L , R ) { if ( prefix [ R ] < L suffix [ L ] > R ) { return 0 ; } else { return prefix [ R ] - suffix [ L ] ; } }
function printXYZ ( n ) { if ( n == 1 ) document . write ( - 1 ) ; else document . write ( "x▁is▁" + n + "y▁is▁" + ( n + 1 ) + "z▁is▁" + n * ( n + 1 ) ) ; }
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
function term ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; }
function term ( n ) { return parseInt ( n * ( n + 1 ) / 2 ) ; }
function avgOfFirstN ( n ) { return ( 1 + n ) / 2 ; }
function summation ( n ) { let sum ; sum = ( Math . pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }
function sum ( x , n ) { let total = 1.0 ; let multi = x ; for ( let i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; }
function term ( n ) { let x = parseInt ( ( ( 1 ) + Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
function isMember ( a , d , x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
function compute ( a , b ) { var AM = ( a + b ) / 2 ; var GM = Math . sqrt ( a * b ) ; var HM = ( GM * GM ) / AM ; return HM ; }
function countDigits ( n ) { let c = 0 ; do { c ++ ; n = Math . floor ( n / 10 ) ; } while ( n != 0 ) ; return c ; }
function isDeserium ( x ) { let temp = x ; let p = countDigits ( x ) ; let sum = 0 ; while ( x != 0 ) { let digit = x % 10 ; sum += Math . floor ( Math . pow ( digit , p ) ) ; p -- ; x = Math . floor ( x / 10 ) ; } return ( sum == temp ) ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function sameRemainder ( a , b , c ) { var a1 = ( b - a ) , b1 = ( c - b ) , c1 = ( c - a ) ; return gcd ( a1 , gcd ( b1 , c1 ) ) ; }
function mean ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; var mean = sum / n ; return mean ; }
function sd ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum = sum + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ; var sdd = sum / n ; return sdd ; }
function checkDivisibility ( num ) { let length = num . length ; if ( length == 1 && num [ 0 ] == "0" ) return true ; if ( length % 3 == 1 ) { num += "00" ; length += 2 ; } else if ( length % 3 == 2 ) { num += "0" ; length += 1 ; } let sum = 0 ; p = 1 ; for ( let i = length - 1 ; i >= 0 ; i -- ) { group = 0 ; group += num [ i -- ] - "0" ; group += ( num [ i -- ] - "0" ) * 10 ; group += ( num [ i ] - "0" ) * 100 ; sum = sum + group * p ; p *= ( - 1 ) ; } sum = Math . abs ( sum ) ; return ( sum % 13 == 0 ) ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function findNumber ( arr , n ) { let ans = arr [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) ans = gcd ( ans , arr [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == ans ) return ans ; return - 1 ; }
function modularEquation ( a , b ) { if ( a < b ) { document . write ( "No▁solution▁possible▁" ) ; return ; } if ( a == b ) { document . write ( "Infinite▁Solution▁possible▁" ) ; return ; } let count = 0 ; let n = a - b ; let y = Math . sqrt ( a - b ) ; for ( let i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; document . write ( count ) ; }
function SieveofEratosthenes ( n ) { let visited = new Array ( n ) ; visited . fill ( false ) ; for ( let i = 2 ; i <= n + 1 ; i ++ ) if ( ! visited [ i ] ) { for ( let j = i * i ; j <= n + 1 ; j += i ) visited [ j ] = true ; primes . push ( i ) ; } }
function specialPrimeNumbers ( n , k ) { SieveofEratosthenes ( n ) ; let count = 0 ; for ( let i = 0 ; i < primes . length ; i ++ ) { for ( let j = 0 ; j < i - 1 ; j ++ ) { if ( primes [ j ] + primes [ j + 1 ] + 1 == primes [ i ] ) { count ++ ; break ; } } if ( count == k ) return true ; } return false ; }
function minOp ( num ) { var rem ; var count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num = parseInt ( num / 10 ) ; } return count ; }
function findSubarraySum ( arr , n , sum ) { let prevSum = new Map ( ) ; let res = 0 ; let currsum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == sum ) res ++ ; if ( prevSum . has ( currsum - sum ) ) res += prevSum . get ( currsum - sum ) ; let count = prevSum . get ( currsum ) ; if ( count == null ) prevSum . set ( currsum , 1 ) ; else prevSum . set ( currsum , count + 1 ) ; } return res ; }
function minimumMoves ( A , N ) { let one = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] == 1 ) one ++ ; if ( one != 0 ) return N - one ; let minimum = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < N ; i ++ ) { let g = A [ i ] ; for ( let j = i + 1 ; j < N ; j ++ ) { g = __gcd ( A [ j ] , g ) ; if ( g == 1 ) { minimum = Math . min ( minimum , j - i ) ; break ; } } } if ( minimum == Number . MAX_SAFE_INTEGER ) return - 1 ; else return N + minimum - 1 ; }
function sumSquare ( n ) { let s = new Map ( ) ; for ( let i = 0 ; i * i <= n ; ++ i ) { s . set ( i * i , 1 ) ; if ( s . has ( n - i * i ) ) { document . write ( Math . sqrt ( n - i * i ) + "^2▁+▁" + i + "^2" ) ; return true ; } } return false ; }
function countPairs ( arr , n ) { var result = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { var product = arr [ i ] * arr [ j ] ; for ( k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }
function judgeSquareSum ( n ) { for ( i = 2 ; i * i <= n ; i ++ ) { var count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n = parseInt ( n / i ) ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; }
function preCompute ( mat , prefixCnt ) { for ( let i = 0 ; i < M ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 0 ) { prefixCnt [ i ] [ j ] = 1 ; } else { prefixCnt [ i ] [ j ] = 0 ; } } } for ( let i = 0 ; i < M ; i ++ ) for ( let j = 1 ; j < N ; j ++ ) prefixCnt [ i ] [ j ] += prefixCnt [ i ] [ j - 1 ] ; for ( let i = 1 ; i < M ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) prefixCnt [ i ] [ j ] += prefixCnt [ i - 1 ] [ j ] ; }
function countQuery ( prefixCnt , pi , pj , qi , qj ) { let cnt = prefixCnt [ qi ] [ qj ] ; if ( pi > 0 ) cnt -= prefixCnt [ pi - 1 ] [ qj ] ; if ( pj > 0 ) cnt -= prefixCnt [ qi ] [ pj - 1 ] ; if ( pi > 0 && pj > 0 ) cnt += prefixCnt [ pi - 1 ] [ pj - 1 ] ; return cnt ; }
function series ( n , d ) { if ( d == 0 ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( "0▁" ) ; document . write ( ) ; return ; } if ( n % 2 == 0 ) { for ( let i = 1 ; i <= n ; i ++ ) { document . write ( Math . pow ( - 1 , i ) * d + "▁" ) ; } document . write ( ) ; } else { let m = n ; let r = ( m / ( m - 1 ) ) ; let g = ( d * ( Math . sqrt ( r ) ) ) ; document . write ( "0▁" ) ; for ( let i = 1 ; i < n ; i ++ ) { document . write ( Math . pow ( - 1 , i ) * g + "▁" ) ; } document . write ( ) ; } }
function countDigitOne ( n ) { let countr = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let str = i . toString ( ) ; countr += str . split ( "1" ) . length - 1 ; } return countr ; }
function countDigitOne ( n ) { var countr = 0 ; for ( var i = 1 ; i <= n ; i *= 10 ) { var divider = i * 10 ; countr += parseInt ( n / divider ) * i + Math . min ( Math . max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }
function countPairs ( arr , n ) { var result = 0 ; var Hash = new Set ( ) ; for ( i = 0 ; i < n ; i ++ ) { Hash . add ( arr [ i ] ) ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { var product = arr [ i ] * arr [ j ] ; if ( Hash . has ( product ) ) { result ++ ; } } } return result ; }
function check ( a , b ) { var c = 0 ; while ( a != 0 ) { c = c + a % 10 ; a = parseInt ( a / 10 ) ; } return ( c == b ) ; }
function root ( n ) { var found = false ; var mx = 1E18 ; for ( i = 0 ; i <= 90 ; i ++ ) { var s = i * i + 4 * n ; var sq = Math . sqrt ( s ) ; if ( sq * sq == s && check ( ( sq - i ) / 2 , i ) ) { found = true ; mx = Math . min ( mx , ( sq - i ) / 2 ) ; } } if ( found ) return mx ; else return - 1 ; }
function factors ( n ) { let prime = new Map ( ) ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; ++ i ) { while ( n % i == 0 ) { if ( prime . has ( i ) ) { prime . set ( i , prime . get ( i ) + 1 ) ; } else { prime . set ( i , 1 ) ; } n = Math . floor ( n / i ) ; } } if ( n > 2 ) { if ( prime . has ( n ) ) { prime . set ( n , prime . get ( n ) + 1 ) ; } else { prime . set ( n , 1 ) ; } } let ans1 = 1 , ans2 = 1 ; for ( let [ key , value ] of prime . entries ( ) ) { ans1 *= 2 * value + 1 ; ans2 *= value + 1 ; } return ans1 - ans2 ; }
function gcdOfFactorial ( m , n ) { var min = m < n ? m : n ; return factorial ( min ) ; }
function asPowerSum ( w , m ) { while ( m > 0 ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; }
function dotProduct ( vect_A , vect_B ) { let product = 0 ; for ( let i = 0 ; i < n ; i ++ ) product = product + vect_A [ i ] * vect_B [ i ] ; return product ; }
function crossProduct ( vect_A , vect_B , cross_P ) { cross_P [ 0 ] = vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ; cross_P [ 1 ] = vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ; cross_P [ 2 ] = vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ; }
function calculate ( n , power ) { sum = 0 ; bp = Math . pow ( n , power ) ; while ( bp != 0 ) { d = bp % 10 ; sum = sum + d ; bp = Math . floor ( bp / 10 ) ; } return sum ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( 1 * res * x ) % p ; x = ( 1 * x * x ) % p ; } return res ; }
function countEvenWays ( n ) { return power ( 2 , n / 2 - 1 , MOD ) ; }
function cal_factor ( ) { factor [ 1 ] = 1 ; for ( let i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( let i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( let i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( let j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } }
function no_of_representations ( a , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let temp = a [ i ] ; let flag = 0 ; while ( factor [ temp ] != 1 ) { flag = - 1 ; count ++ ; temp = temp / factor [ temp ] ; } count += flag ; } return count ; }
function coprime ( a , b ) { return ( __gcd ( a , b ) == 1 ) ; }
function pairSum ( n ) { let mid = Math . floor ( n / 2 ) ; for ( let i = mid ; i >= 1 ; i -- ) { if ( coprime ( i , n - i ) == true ) { document . write ( i + "▁" + ( n - i ) ) ; break ; } } }
function coutSubSeq ( A , N , M ) { let sum = 0 ; let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { for ( let k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
function countSubSeq ( A , N , M ) { var ans = 0 ; var h = Array . from ( { length : M } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < N ; i ++ ) { A [ i ] = A [ i ] % M ; h [ A [ i ] ] ++ ; } for ( var i = 0 ; i < M ; i ++ ) { for ( var j = i ; j < M ; j ++ ) { var rem = ( M - ( i + j ) % M ) % M ; if ( rem < j ) continue ; if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ; else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ; else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ; else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ; else ans = ans + h [ i ] * h [ j ] * h [ rem ] ; } } return ans ; }
function findTerm ( n ) { if ( n == 1 ) return n ; else { let term = 7 ; for ( let i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } }
function findNumber ( n ) { n -- ; let i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
function findNumber ( n ) { let x = Math . floor ( ( - 1 + Math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; let base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - base + 1 ; }
function correlationCoefficient ( X , Y , n ) { let sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; let squareSum_X = 0 , squareSum_Y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } let corr = ( n * sum_XY - sum_X * sum_Y ) / ( Math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; }
function result ( n , k , t ) { if ( t <= k ) document . write ( t ) ; else if ( t <= n ) document . write ( k ) ; else { let temp = t - n ; temp = k - temp ; document . write ( temp ) ; } }
function weightedMean ( X , W , n ) { let sum = 0 , numWeight = 0 ; for ( let i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( numWeight ) / sum ; }
function weightedMean ( n ) { return parseInt ( ( 2 * n + 1 ) / 3 , 10 ) ; }
function sumOfDigits ( a ) { var sum = 0 ; while ( a != 0 ) { sum += a % 10 ; a = parseInt ( a / 10 ) ; } return sum ; }
function findMax ( x ) { var b = 1 , ans = x ; while ( x != 0 ) { var cur = ( x - 1 ) * b + ( b - 1 ) ; if ( sumOfDigits ( cur ) > sumOfDigits ( ans ) || ( sumOfDigits ( cur ) == sumOfDigits ( ans ) && cur > ans ) ) ans = cur ; x = parseInt ( x / 10 ) ; b *= 10 ; } return ans ; }
function series ( n ) { return ( 8 * n * n ) + 1 ; }
function gcd ( a , b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ; }
function harmonicMean ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + ( 1 / arr [ i ] ) ; return n / sum ; }
function harmonicMean ( arr , freq , n ) { let sum = 0 , frequency_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + ( freq [ i ] / arr [ i ] ) ; frequency_sum = frequency_sum + freq [ i ] ; } return frequency_sum / sum ; }
function calculate ( a , b , n , m ) { let mul = 1 ; for ( let i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { let x = Math . floor ( a [ i ] / mul ) ; document . write ( x + "▁" ) ; } }
function modBigNumber ( num , m ) { let vec = [ ] ; let x = 0 ; let mod = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) { digit = num [ i ] - "0" ; mod = mod * 10 + digit ; quo = parseInt ( mod / m ) ; vec [ x ++ ] = quo ; mod = mod % m ; } document . write ( "Remainder:" + mod + "" ) ; document . write ( "Quotient▁:▁" ) ; let zeroflag = 0 ; for ( let i = 0 ; i < x ; i ++ ) { if ( vec [ i ] == 0 && zeroflag == 0 ) continue ; zeroflag = 1 ; document . write ( vec [ i ] ) ; } return ; }
function findPowerOfP ( n , p ) { let count = 0 ; let r = p ; while ( r <= n ) { count += Math . floor ( n / r ) ; r = r * p ; } return count ; }
function primeFactorsofK ( k ) { let ans = [ ] ; for ( let i = 2 ; k != 1 ; i ++ ) { if ( k % i == 0 ) { let count = 0 ; while ( k % i == 0 ) { k = Math . floor ( k / i ) ; count ++ ; } ans . push ( new pair ( i , count ) ) ; } } return ans ; }
function largestPowerOfK ( n , k ) { let vec = [ ] ; vec = primeFactorsofK ( k ) ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < vec . length ; i ++ ) ans = Math . min ( ans , findPowerOfP ( n , vec [ i ] . first ) / vec [ i ] . second ) ; return ans ; }
function calculate_sum ( a , N ) { m = N / a ; sum = m * ( m + 1 ) / 2 ; ans = a * sum ; return ans ; }
function fourDistinctFactors ( ) { var primeAll = Array ( N + 1 ) . fill ( false ) ; for ( var p = 2 ; p * p <= N ; p ++ ) { if ( primeAll [ p ] == false ) { for ( var i = p * 2 ; i <= N ; i += p ) primeAll [ i ] = true ; } } var prime = [ ] ; for ( var p = 2 ; p <= N ; p ++ ) if ( ! primeAll [ p ] ) prime . push ( p ) ; for ( var i = 0 ; i < prime . length ; ++ i ) { var p = prime [ i ] ; if ( p * p * p <= N ) fourDiv [ p * p * p ] = true ; for ( var j = i + 1 ; j < prime . length ; ++ j ) { var q = prime [ j ] ; if ( p * q > N ) break ; fourDiv [ p * q ] = true ; } } }
function horner ( poly , n , x ) { var result = poly [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; }
function findSign ( poly , n , x ) { var result = horner ( poly , n , x ) ; if ( result > 0 ) return 1 ; else if ( result < 0 ) return - 1 ; return 0 ; }
function ucal ( u , n ) { if ( n == 0 ) return 1 ; var temp = u ; for ( var i = 1 ; i <= n / 2 ; i ++ ) temp = temp * ( u - i ) ; for ( var i = 1 ; i < n / 2 ; i ++ ) temp = temp * ( u + i ) ; return temp ; }
function digitLCM ( n ) { let lcm = 1 ; while ( n > 0 ) { lcm = ( n % 10 * lcm ) / lcm_fun ( n % 10 , lcm ) ; if ( lcm == 0 ) return 0 ; n = parseInt ( n / 10 ) ; } return lcm ; }
function gcdMax ( a , b , n , N ) { let cnt = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let first = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let second = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( let i = 1 ; i < N ; ++ i ) for ( let j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . max ( first [ i ] , j ) ; cnt = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( let i = 1 ; i < N ; ++ i ) for ( let j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . max ( second [ i ] , j ) ; let x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; document . write ( first [ x ] + "▁" + second [ x ] ) ; }
function factorial ( n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
function ispowerof2 ( num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; }
function median ( a , l , r ) { var n = r - l + 1 ; n = parseInt ( ( n + 1 ) / 2 ) - 1 ; return parseInt ( n + l ) ; }
function IQR ( a , n ) { a . sort ( ( a , b ) => a - b ) ; var mid_index = median ( a , 0 , n ) ; var Q1 = a [ median ( a , 0 , mid_index ) ] ; var Q3 = a [ mid_index + median ( a , mid_index + 1 , n ) ] ; return ( Q3 - Q1 ) ; }
function printPierpont ( n ) { var arr = Array ( n + 1 ) . fill ( false ) ; var two = 1 , three = 1 ; while ( two + 1 < n ) { arr [ two ] = true ; while ( two * three + 1 < n ) { arr [ three ] = true ; arr [ two * three ] = true ; three *= 3 ; } three = 1 ; two *= 2 ; } var v = [ ] ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] ) v . push ( i + 1 ) ; arr = Array ( n + 1 ) . fill ( false ) ; for ( var p = 2 ; p * p < n ; p ++ ) { if ( arr [ p ] == false ) for ( var i = p * 2 ; i < n ; i += p ) arr [ i ] = true ; } for ( var i = 0 ; i < v . length ; i ++ ) if ( ! arr [ v [ i ] ] ) document . write ( v [ i ] + "▁" ) ; }
function isWoodall ( x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; x ++ ; let p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; }
function print_result ( a , n , k , m ) { var v = Array . from ( Array ( m ) , ( ) => Array ( ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var rem = a [ i ] % m ; v [ rem ] . push ( a [ i ] ) ; if ( v [ rem ] . length == k ) { for ( var j = 0 ; j < k ; j ++ ) document . write ( v [ rem ] [ j ] + "▁" ) ; return ; } } document . write ( "-1" ) ; }
function smallestX ( n ) { let temp = Array . from ( { length : 10 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < 10 ; i ++ ) temp [ i ] = 0 ; if ( n == 0 ) return - 1 ; let count = 0 , x = 0 ; for ( x = 1 ; count < 10 ; x ++ ) { let y = x * n ; while ( y > 0 ) { if ( temp [ y % 10 ] == 0 ) { count ++ ; temp [ y % 10 ] = 1 ; } y /= 10 ; } } return x - 1 ; }
function digSum ( n ) { let sum = 0 , rem = 0 ; while ( n > 0 ) { rem = n % 10 ; sum += rem ; n = Math . floor ( n / 10 ) ; } return sum ; }
function findX ( n ) { for ( let i = 0 ; i <= n ; i ++ ) if ( i + digSum ( i ) == n ) return i ; return - 1 ; }
function isDivisible ( x , y ) { if ( y == 1 ) return true ; var z = gcd ( x , y ) ; if ( z == 1 ) return false ; return isDivisible ( x , y / z ) ; }
function isDigitPresent ( m , hash ) { while ( m > 0 ) { if ( hash [ m % 10 ] ) return true ; m = Math . floor ( m / 10 ) ; } return false ; }
function countDivisibles ( n ) { let hash = Array . from ( { length : 10 } , ( _ , i ) => 0 ) ; let m = n ; while ( m > 0 ) { hash [ m % 10 ] = true ; m = Math . floor ( m / 10 ) ; } let ans = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( isDigitPresent ( i , hash ) ) ans ++ ; if ( n / i != i ) { if ( isDigitPresent ( n / i , hash ) ) ans ++ ; } } } return ans ; }
function printTwoDivisibleParts ( num , f , s ) { var N = num . length ; var prefixReminder = [ ] var suffixReminder = [ ] suffixReminder [ 0 ] = 0 ; for ( var i = 1 ; i < N ; i ++ ) suffixReminder [ i ] = ( suffixReminder [ i - 1 ] * 10 + ( num [ i - 1 ] - "0" ) ) % f ; prefixReminder [ N ] = 0 ; var base1 = 1 ; for ( var i = N - 1 ; i >= 0 ; i -- ) { prefixReminder [ i ] = ( prefixReminder [ i + 1 ] + ( num [ i ] - "0" ) * base1 ) % s ; base1 = ( base1 * 10 ) % s ; } for ( var i = 0 ; i < N ; i ++ ) { if ( prefixReminder [ i ] == 0 && suffixReminder [ i ] == 0 && num [ i ] != "0" ) { document . write ( num . substring ( 0 , i ) + "▁" + num . substring ( i ) ) ; return ; } } document . write ( "Not▁Possible" ) ; }
function sum ( n ) { var rem = 0 ; var sum_of_digits = 0 ; while ( n > 0 ) { rem = n % 10 ; sum_of_digits += rem ; n = parseInt ( n / 10 ) ; } return sum_of_digits ; }
function count ( n ) { var c = 0 ; for ( i = n - 97 ; i <= n ; i ++ ) { var a = sum ( i ) ; var b = sum ( a ) ; if ( ( i + a + b ) == n ) { c += 1 ; } } return c ; }
function isPowerOfK ( n , k ) { let oneSeen = false ; while ( n > 0 ) { let digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n = Math . floor ( n / k ) ; } return true ; }
function isOctal ( n ) { while ( n ) { if ( ( n % 10 ) >= 8 ) return false ; else n = Math . floor ( n / 10 ) ; } return true ; }
function printFactorialNums ( n ) { let fact = 1 ; let x = 2 ; while ( fact <= n ) { document . write ( fact + "▁" ) ; fact = fact * x ; x ++ ; } }
function Cel_To_Fah ( n ) { return ( ( n * 9.0 / 5.0 ) + 32.0 ) ; }
function printPairs ( arr , n , k ) { let isPairFound = true ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { document . write ( "(" + arr [ i ] + ",▁" + arr [ j ] + ")" + "▁" ) ; isPairFound = true ; } } } return isPairFound ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function print_sequence ( n , k ) { let b = parseInt ( n / ( k * ( k + 1 ) / 2 ) ) ; if ( b == 0 ) { document . write ( - 1 ) ; } else { let r = 1 ; for ( let x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( let i = 1 ; i < k ; i ++ ) document . write ( r * i + "-1" ) ; let res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; document . write ( res + "▁" ) ; } }
function countCompositions ( n ) { return 1 << ( n - 1 ) ; }
function computeLastDigit ( A , B ) { let variable = 1 ; return 1 ; else  if ( ( B - A ) >= 5 ) return 0 ; else { for ( let i = A + 1 ; i <= B ; i ++ ) variable = ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }
function findSumSubsets ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
function findMin ( a , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += Math . log ( a [ i ] ) ; var x = parseInt ( Math . exp ( sum / n ) ) ; return x + 1 ; }
function countdigits ( N ) { var count = 0 ; while ( N > 0 ) { count ++ ; N = parseInt ( N / 10 ) ; } return count ; }
function sumOfAP ( a , d , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; }
function sumOfAP ( a , d , n ) { let sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
function printPairs ( arr , n , k ) { let occ = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) occ . set ( arr [ i ] , true ) ; let isPairFound = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( occ . get ( k ) && k < arr [ i ] ) { document . write ( "(" + k + ",▁" + arr [ i ] + ")▁" ) ; isPairFound = true ; } if ( arr [ i ] >= k ) { let v = findDivisors ( arr [ i ] - k ) ; for ( let j = 0 ; j < v . length ; j ++ ) { if ( arr [ i ] % v [ j ] == k && arr [ i ] != v [ j ] && occ . get ( v [ j ] ) ) { document . write ( "(" + arr [ i ] + ",▁" + v [ j ] + ")▁" ) ; isPairFound = true ; } } v = [ ] ; } } return isPairFound ; }
function sumOfSeries ( n ) { x = 0  if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) else x = ( ( n + 1 ) / 2 ) * n return ( x * x ) }
function findValue ( arr , n ) { var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = 0 ; j < n ; j ++ ) ans = Math . max ( ans , Math . abs ( arr [ i ] - arr [ j ] ) + Math . abs ( i - j ) ) ; return ans ; }
function findValue ( arr , n ) { let a = new Array ( n ) ; let b = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { a [ i ] = ( arr [ i ] + i ) ; b [ i ] = ( arr [ i ] - i ) ; } let x = a [ 0 ] , y = a [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) x = a [ i ] ; if ( a [ i ] < y ) y = a [ i ] ; } let ans1 = ( x - y ) ; x = b [ 0 ] ; y = b [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( b [ i ] > x ) x = b [ i ] ; if ( b [ i ] < y ) y = b [ i ] ; } let ans2 = ( x - y ) ; return Math . max ( ans1 , ans2 ) ; }
function countsubarray ( array , n , k ) { var count = 0 ; var i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul < k ) count ++ ; else break ; } } return count ; }
function multiplyFactors ( n ) { let M = 1000000007 ; let i ; prod = 1 ; for ( i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
function power ( x , y ) { let res = 1 ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % M ; y = ( y >> 1 ) % M ; x = ( x * x ) % M ; } return res ; }
function countFactors ( n ) { let count = 0 ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count ++ ; else count += 2 ; } } return count ; }
function multiplyFactors ( n ) { let numFactor = countFactors ( n ) ; let product = power ( n , numFactor / 2 ) ; if ( numFactor % 2 == 1 ) product = ( product * Math . sqrt ( n ) ) % M ; return product ; }
function printTrib ( n ) { let dp = Array . from ( { length : n } , ( _ , i ) => 0 ) ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( let i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( let i = 0 ; i < n ; i ++ ) document . write ( dp [ i ] + "▁" ) ; }
function power ( T , n ) { if ( n == 0 n == 1 ) return ; var M = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] ; power ( T , parseInt ( n / 2 ) ) ; multiply ( T , T ) ; if ( n % 2 != 0 ) multiply ( T , M ) ; }
function tribonacci ( n ) { var T = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] ; if ( n == 0 n == 1 ) return 0 ; else power ( T , n - 2 ) ; return T [ 0 ] [ 0 ] ; }
function getMaxOccuringChar ( str ) { let count = new Array ( ASCII_SIZE ) ; for ( let i = 0 ; i < ASCII_SIZE ; i ++ ) { count [ i ] = 0 ; } let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { count [ str [ i ] . charCodeAt ( 0 ) ] += 1 ; } let max = - 1 ; let result = "▁" ; for ( let i = 0 ; i < len ; i ++ ) { if ( max < count [ str [ i ] . charCodeAt ( 0 ) ] ) { max = count [ str [ i ] . charCodeAt ( 0 ) ] ; result = str [ i ] ; } } return result ; }
function counDivisors ( X ) { let count = 0 ; for ( let i = 1 ; i <= X ; ++ i ) { if ( X % i == 0 ) { count ++ ; } } return count ; }
function countDivisorsMult ( arr , n ) { let mul = 1 ; for ( let i = 0 ; i < n ; ++ i ) mul *= arr [ i ] ; return counDivisors ( mul ) ; }
function SieveOfEratosthenes ( largest , prime ) { var isPrime = Array ( largest + 1 ) . fill ( true ) ; var p , i ; for ( p = 2 ; p * p <= largest ; p ++ ) { if ( isPrime [ p ] == true ) { for ( i = p * 2 ; i <= largest ; i += p ) isPrime [ i ] = false ; } } for ( p = 2 ; p <= largest ; p ++ ) if ( isPrime [ p ] ) prime . push ( p ) ; }
function countDivisorsMult ( arr , n ) { var largest = Math . max . apply ( null , arr ) ; var prime = [ ] ; SieveOfEratosthenes ( largest , prime ) ; var j ; var mp = new Map ( ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < prime . length ; j ++ ) { while ( arr [ i ] > 1 && arr [ i ] % prime [ j ] == 0 ) { arr [ i ] /= prime [ j ] ; if ( mp . has ( prime [ j ] ) ) mp . set ( prime [ j ] , mp . get ( prime [ j ] ) + 1 ) ; else mp . set ( prime [ j ] , 1 ) ; } } if ( arr [ i ] != 1 ) { if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; else mp . set ( arr [ i ] , 1 ) ; } } var res = 1 ; for ( const [ key , value ] of mp . entries ( ) ) { res *= ( value + 1 ) ; } return res ; }
function generatePrimeFactors ( ) { factor [ 1 ] = 1 ; for ( i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } }
function calculateNoOFactors ( n ) { if ( n == 1 ) return 1 ; var ans = 1 ; var dup = factor [ n ] ; var c = 1 ; var j = n / factor [ n ] ; while ( j != 1 ) { if ( factor [ j ] == dup ) c += 1 ; else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; } j = j / factor [ j ] ; } ans = ans * ( c + 1 ) ; return ans ; }
function digit_product_Sum ( N ) { var a = [ ... Array ( N ) ] ; var product = 1 ; a [ 0 ] = 1 ; for ( var i = 1 ; i <= N ; i ++ ) { product = parseInt ( a [ i - 1 ] / 10 ) ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; var val = parseInt ( a [ i - 1 ] / 10 ) ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + val * product ; } for ( var i = 0 ; i < N ; i ++ ) document . write ( a [ i ] + "▁" ) ; }
function geometricMean ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; let gm = Math . pow ( product , 1 / n ) ; return gm ; }
function geometricMean ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum = sum + Math . log ( arr [ i ] ) ; sum = sum / n ; return Math . exp ( sum ) ; }
function smallestNumber ( n ) { if ( n >= 0 && n <= 9 ) { return n ; } let digits = [ ] ; for ( let i = 9 ; i >= 2 && n > 1 ; i -- ) { while ( n % i == 0 ) { digits . push ( i ) ; n = Math . floor ( n / i ) ; } } if ( n != 1 ) { return - 1 ; } let k = 0 ; while ( digits . length != 0 ) { k = k * 10 + digits [ digits . length - 1 ] ; digits . pop ( ) ; } return k ; }
function isMagic ( n ) { var sum = 0 ; while ( n > 0 sum > 9 ) { if ( n = 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum = 1 ) ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function checkCircular ( N ) { let count = 0 , temp = N ; while ( temp > 0 ) { count ++ ; temp = parseInt ( temp / 10 , 10 ) ; } let num = N ; while ( isPrime ( num ) ) { let rem = num % 10 ; let div = parseInt ( num / 10 , 10 ) ; num = ( ( Math . pow ( 10 , count - 1 ) ) * rem ) + div ; if ( num == N ) return true ; } return false ; }
function productOfSingelDgt ( n ) { if ( n >= 0 && n <= 9 ) return true ; var prime = [ 2 , 3 , 5 , 7 ] ; for ( i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; }
function printSequence ( n ) { let a = 1 ; let ans = 2 ; for ( let i = 1 ; i <= n ; i ++ ) { document . write ( ans + "▁" ) ; ans = ( ( a % N ) * ( ans % N ) ) % N ; a = ans ; ans = ( ans + 1 ) % N ; } }
function findSum ( n ) { let sum = 0 ; for ( let x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
function findSum ( n ) { return n * ( n + 1 ) / 2 ; }
function findSum ( n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) else return ( ( n + 1 ) / 2 ) * n }
function count ( x , y ) { let m = new Map ( ) ; while ( x % y != 0 ) { x = x % y ; ans ++ ; if ( m . has ( x ) ) return - 1 ; m . set ( x , 1 ) ; x = x * 10 ; } return ans ; }
function solve ( n ) { let a = n / 2 ; if ( n % 2 != 0 ) { document . write ( ( Math . ceil ( a ) - 1 ) + "▁" + ( Math . floor ( a ) + 1 ) ) ; } else { if ( parseInt ( a , 10 ) % 2 == 0 ) { document . write ( ( Math . ceil ( a ) - 1 ) + "▁" + ( Math . floor ( a ) + 1 ) ) ; } else { document . write ( ( Math . ceil ( a ) - 2 ) + "▁" + ( Math . floor ( a ) + 2 ) ) ; } } }
function divCount ( n ) { var hash = Array ( n + 1 ) . fill ( true ) ; for ( var p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( var i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; var total = 1 ; for ( var p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { var count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = parseInt ( n / p ) ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
function maxPrimefactorNum ( N ) { let arr = new Array ( N + 1 ) . fill ( 0 ) ; for ( let i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) for ( let j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } return getMax ( arr ) ; }
function maxPrimefactorNum ( N ) { if ( N < 2 ) return 0 ; arr = Array . from ( { length : N + 1 } , ( _ , i ) => false ) ; var prod = 1 , res = 0 ; for ( var p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( var i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }
function arraySum ( arr , n ) { let x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }
function countDigits ( a , b ) { let count = 0 ; let p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = parseInt ( p / 10 , 10 ) ; } return count ; }
function countDigits ( a , b ) { if ( a == 0 b == 0 ) return 1 ; return Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }
function area_fun ( side ) { let area = side * side ; return area ; }
function isPalindrome ( n ) { var divisor = 1 ; while ( parseInt ( n / divisor ) >= 10 ) divisor *= 10 ; while ( n != 0 ) { var leading = parseInt ( n / divisor ) ; var trailing = n % 10 ; if ( leading != trailing ) return false ; n = parseInt ( ( n % divisor ) / 10 ) ; divisor = divisor / 100 ; } return true ; }
function lastPosition ( n , m , k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }
function maxSum ( n ) { if ( n == 1 ) return 1 ; else return ( parseInt ( n * ( n - 1 ) / 2 , 10 ) - 1 + parseInt ( n / 2 , 10 ) ) ; }
function check ( n ) { return 1162261467 % n == 0 ; }
function productPuzzle ( a , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += Math . log10 ( a [ i ] ) ; for ( var i = 0 ; i < n ; i ++ ) document . write ( parseInt ( ( EPS + Math . pow ( 10.00 , sum - Math . log10 ( a [ i ] ) ) ) ) + "▁" ) ; }
function changeEvenBits ( n ) { let to_subtract = 0 ; let m = 0 ; for ( x = n ; x ; x >>= 2 ) { if ( x & 1 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; }
function closestNumber ( n , m ) { let q = parseInt ( n / m ) ; let n1 = m * q ; let n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) return n1 ; return n2 ; }
function checkPronic ( x ) { for ( var i = 0 ; i <= parseInt ( Math . sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; }
function countConsecutive ( N ) { let count = 0 ; for ( let L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { let a = ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - parseInt ( a , 10 ) == 0.0 ) count ++ ; } return count ; }
function findMinSum ( num ) { let sum = 0 ; for ( let i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
function compute_average ( a , b ) { return Math . floor ( ( a + b ) / 2 ) ; }
function minNum ( arr , n ) { let odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; }
function minNum ( arr , n ) { let odd = false ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
function findPrime ( n ) { let num = n + 1 ; while ( num > 0 ) { if ( isPrime ( num ) ) return num ; num = num + 1 ; } return 0 ; }
function sieveOfEratostheneses ( ) { isPrime [ 1 ] = true ; for ( let i = 2 ; i * i < MAX ; i ++ ) { if ( ! isPrime [ i ] ) { for ( let j = 2 * i ; j < MAX ; j += i ) isPrime [ j ] = true ; } } }
function findPrime ( n ) { let num = n + 1 ; while ( num > 0 ) { if ( ! isPrime [ num ] ) return num ; num = num + 1 ; } return 0 ; }
function pell ( n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }
function pell ( n ) { if ( n <= 2 ) return n ; let a = 1 ; let b = 2 ; let c ; for ( let i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }
function nCr ( n , r ) { if ( r > n / 2 ) r = n - r ; let answer = 1 ; for ( let i = 1 ; i <= r ; i ++ ) { answer *= ( n - r + i ) ; answer /= i ; } return answer ; }
function findMaxGCD ( arr , n ) { var high = 0 ; for ( var i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; var divisors = Array . from ( { length : high + 1 } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 1 ; j <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( var i = high ; i >= 1 ; i -- ) if ( divisors [ i ] > 1 ) return i ; return 1 ; }
function findMaxGCD ( arr , n ) { var high = 0 ; for ( let i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; var count = Array ( high + 1 ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; var counter = 0 ; for ( let i = high ; i >= 1 ; i -- ) { var j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } return 1 ; }
function count_one ( n ) { let c_one = 0 ; while ( n != 0 ) { let rem = n % 10 ; if ( rem == 1 ) c_one = c_one + 1 ; n = parseInt ( n / 10 , 10 ) ; } return c_one ; }
function checkEvil ( n ) { let i = 0 , bin = 0 , n_one = 0 ; while ( n != 0 ) { let r = n % 2 ; bin = bin + r * ( Math . pow ( 10 , i ) ) ; n = parseInt ( n / 2 , 10 ) ; } n_one = count_one ( bin ) ; if ( n_one % 2 == 0 ) return 1 ; else return 0 ; }
function calculateLeaps ( n ) { if ( n == 0 n == 1 ) { return 1 ; } else { let leaps = 0 ; for ( let i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
function power ( x , y , p ) { var res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return parseInt ( res ) ; }
function printLastKDigits ( a , b , k ) { document . write ( "Last▁" + k + "▁digits▁of▁" + a + "^" + b + "▁=▁" ) ; var temp = 1 ; for ( i = 1 ; i <= k ; i ++ ) temp *= 10 ; temp = power ( a , b , temp ) ; for ( i = 0 ; i < k - temp . toString ( ) . length ; i ++ ) document . write ( 0 ) ; if ( temp != 0 ) document . write ( temp ) ; }
function msbPos ( n ) { var pos = 0 ; while ( n != 0 ) { pos ++ ; n = n >> 1 ; } return pos ; }
function josephify ( n ) { var position = msbPos ( n ) ; var j = 1 << ( position - 1 ) ; n = n ^ j ; n = n << 1 ; n = n | 1 ; return n ; }
function CountPairs ( n ) { let k = n ; let imin = 1 ; let ans = 0 ; while ( imin <= n ) { let imax = Math . floor ( n / k ) ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = Math . floor ( n / imin ) ; } return ans ; }
function reverseDigits ( num ) { let rev = 0 ; while ( num > 0 ) { rev = rev * 10 + num % 10 ; num = parseInt ( num / 10 , 10 ) ; } return rev ; }
function square ( num ) { return ( num * num ) ; }
function checkAdamNumber ( num ) { let a = square ( num ) ; let b = square ( reverseDigits ( num ) ) ; if ( a == reverseDigits ( b ) ) return true ; return false ; }
function PowerOFPINnfactorial ( n , p ) { let ans = 0 ; let temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
function totalDigits ( n ) { var number_of_digits = 0 ; for ( var i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; }
function findSum ( arr , n ) { arr . sort ( ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) sum = sum + arr [ i ] ; } return sum ; }
function decToBinary ( n ) { let binaryNum = new Array ( 32 ) ; let i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = Math . floor ( n / 2 ) ; i ++ ; } for ( let j = i - 1 ; j >= 0 ; j -- ) document . write ( binaryNum [ j ] ) ; }
function decimalToBinary ( N ) { var B_Number = 0 ; var cnt = 0 ; while ( N != 0 ) { var rem = N % 2 ; var c = Math . pow ( 10 , cnt ) ; B_Number += rem * c ; N = parseInt ( N / 2 ) ; cnt ++ ; } return B_Number ; }
function stirlingFactorial ( n ) { if ( n == 1 ) return 1 ; let z ; let e = 2.71 ; z = Math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ) , n ) ; return Math . floor ( z ) ; }
function countXorPair ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; }
function countXorPair ( arr , n ) { let odd = 0 , even = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }
function count_of_ways ( n ) { var count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
function isPalindrome ( number ) { return number == reverse ( number ) ; }
function reverse ( number ) { var reverse = 0 ; while ( number > 0 ) { var remainder = number % 10 ; reverse = ( reverse * 10 ) + remainder ; number = parseInt ( number / 10 ) ; } return reverse ; }
function sub ( a , b ) { return a + flipSign ( b ) ; }
function mul ( a , b ) { if ( a < b ) return mul ( b , a ) ; var sum = 0 ; for ( i = Math . abs ( b ) ; i > 0 ; i -- ) sum += a ; if ( b < 0 ) sum = flipSign ( sum ) ; return sum ; }
function division ( a , b ) { if ( b == 0 ) throw new ArithmeticException ( ) ; var quotient = 0 , dividend ; var divisor = flipSign ( Math . abs ( b ) ) ; for ( dividend = Math . abs ( a ) ; dividend >= Math . abs ( divisor ) ; dividend += divisor ) quotient ++ ; if ( areDifferentSign ( a , b ) ) quotient = flipSign ( quotient ) ; return quotient ; }
function numOfCombinations ( arr , N ) { let C = [ 0 , 0 , 0 ] ; for ( let i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ; return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; }
function powmod ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function discreteLogarithm ( a , b , m ) { let n = ( parseInt ( Math . sqrt ( m ) , 10 ) + 1 ) ; let value = new Array ( m ) ; value . fill ( 0 ) ; for ( let i = n ; i >= 1 ; -- i ) value [ powmod ( a , i * n , m ) ] = i ; for ( let j = 0 ; j < n ; ++ j ) { let cur = ( powmod ( a , j , m ) * b ) % m ; if ( value [ cur ] > 0 ) { let ans = value [ cur ] * n - j ; if ( ans < m ) return ans ; } } return - 1 ; }
function discreteLogarithm ( a , b , m ) { let n = parseInt ( Math . sqrt ( m ) , 10 ) + 1 ; let an = 1 ; for ( let i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; let value = new Array ( m ) ; value . fill ( 0 ) ; for ( let i = 1 , cur = an ; i <= n ; ++ i ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( let i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] > 0 ) { let ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; }
function findRectNum ( n ) { return n * ( n + 1 ) ; }
function f ( x ) { return 1 * Math . pow ( x , 3 ) + 2 * x * x + 10 * x - 20 ; }
function Muller ( a , b , c ) { let i ; let res ; for ( i = 0 ; ; ++ i ) { let f1 = f ( a ) ; let f2 = f ( b ) ; let f3 = f ( c ) ; let d1 = f1 - f3 ; let d2 = f2 - f3 ; let h1 = a - c ; let h2 = b - c ; let a0 = f3 ; let a1 = ( ( ( d2 * Math . pow ( h1 , 2 ) ) - ( d1 * Math . pow ( h2 , 2 ) ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; let a2 = ( ( ( d1 * h2 ) - ( d2 * h1 ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; let x = ( ( - 2 * a0 ) / ( a1 + Math . abs ( Math . sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; let y = ( ( - 2 * a0 ) / ( a1 - Math . abs ( Math . sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; if ( x >= y ) res = x + c ; else res = y + c ; let m = res * 100 ; let n = c * 100 ; m = Math . floor ( m ) ; n = Math . floor ( n ) ; if ( m == n ) break ; a = b ; b = c ; c = res ; if ( i > MAX_ITERATIONS ) { document . write ( "Root▁cannot▁be▁found▁using" + "▁Muller's▁method" ) ; break ; } } if ( i <= MAX_ITERATIONS ) document . write ( "The▁value▁of▁the▁root▁is▁" + res . toFixed ( 4 ) ) ; }
function factorial ( n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
function countPairs ( N ) { let count = 0 ; for ( let i = 1 ; i <= parseInt ( Math . pow ( N , ( 1.0 / 3.0 ) ) , 10 ) ; i ++ ) { let cb = i * i * i ; let diff = N - cb ; let cbrtDiff = parseInt ( Math . pow ( diff , ( 1.0 / 3.0 ) ) , 10 ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; }
function findMinValue ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < n ; i ++ ) { val += ( Math . log ( ( arr [ i ] ) ) ) ; } let left = arr [ 0 ] , right = arr [ n - 1 ] ; let ans = 0 ; while ( left <= right ) { let mid = Math . floor ( ( left + right ) / 2 ) ; let temp = n * ( Math . log ( ( mid ) ) ) ; if ( val < temp ) { ans = mid ; right = mid - 1 ; } else { left = mid + 1 ; } } return ans ; }
function isprime ( x ) { for ( i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; }
function isSumOfKprimes ( N , K ) { if ( N < 2 * K ) return false ; if ( K == 1 ) return isprime ( N ) ; if ( K == 2 ) { if ( N % 2 == 0 ) return true ; return isprime ( N - 2 ) ; } return true ; }
function sumOfTermsInNthRow ( n ) { let sum = n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; return sum ; }
function printEqualModNumbers ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; d = arr [ n - 1 ] - arr [ 0 ] ; if ( d == 0 ) { document . write ( "Infinite▁solution" ) ; return ; } v = new Array ( ) ; for ( i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . push ( i ) ; if ( i != d / i ) v . push ( d / i ) ; } } for ( i = 0 ; i < v . length ; i ++ ) { temp = arr [ 0 ] % v [ i ] ; j = 1 ; for ( ; j < n ; j ++ ) if ( arr [ j ] % v [ i ] != temp ) break ; if ( j == n ) document . write ( v [ i ] + "▁" ) ; } }
function firstDigit ( x ) { while ( x >= 10 ) x = x / 10 ; return Math . floor ( x ) ; }
function countDigit ( n ) { var temp = n , count = 0 ; while ( temp != 0 ) { var d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }
function FindLCM ( a , b ) { return parseInt ( ( a * b ) / GCD ( a , b ) , 10 ) ; }
function rangeDivisor ( m , n , a , b ) { let lcm = FindLCM ( a , b ) ; let a_divisor = parseInt ( n / a , 10 ) - parseInt ( ( m - 1 ) / a , 10 ) ; let b_divisor = parseInt ( n / b , 10 ) - parseInt ( ( m - 1 ) / b , 10 ) ; let common_divisor = parseInt ( n / lcm , 10 ) - parseInt ( ( m - 1 ) / lcm , 10 ) ; let ans = a_divisor + b_divisor - common_divisor ; return ans ; }
function getOccurence ( n , d ) { let result = 0 ; let itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && Math . floor ( itr / 10 ) == d ) { result ++ ; itr ++ ; } else if ( Math . floor ( itr / 10 ) == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }
function printUnique ( l , r ) { for ( let i = l ; i <= r ; i ++ ) { let num = i ; let visited = new Array ( 10 ) ; while ( num ) { if ( visited [ num % 10 ] ) break ; visited [ num % 10 ] = true ; num = Math . floor ( num / 10 ) ; } if ( num == 0 ) document . write ( i + "▁" ) ; } }
function findSumOfDigits ( n ) { for ( let i = 1 ; i <= n ; i ++ ) multiply ( i ) ; let sum = 0 ; let size = v . length ; for ( let i = 0 ; i < size ; i ++ ) sum += v [ i ] ; return sum ; }
function findMinZero ( p ) { let first = 1 ; let second = 1 ; let number = 2 ; let next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
function makeOdd ( n ) { if ( n % 2 != 0 ) return 1 ; var i ; for ( i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) break ; return i ; }
function makeOdd ( n ) { if ( n % 2 != 0 ) return 1 ; var ans = 1 ; while ( n % 2 == 0 ) { n = parseInt ( n / 2 ) ; ans *= 2 ; } return ans ; }
function getTotalXorOfSubarrayXors ( arr , N ) { if ( N % 2 == 0 ) return 0 ; let res = 0 ; for ( let i = 0 ; i < N ; i += 2 ) { res ^= arr [ i ] ; } return res ; }
function printKDistinct ( arr , n , k ) { var dist_count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }
function div ( x ) { let ans = 0 ; for ( let i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; }
function sieve ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( let p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . push ( p ) ; }
function factorialDivisors ( n ) { sieve ( n ) ; let result = 1 ; for ( let i = 0 ; i < allPrimes . length ; i ++ ) { let p = allPrimes [ i ] ; let exp = 0 ; while ( p <= n ) { exp = exp + Math . floor ( n / p ) ; p = p * allPrimes [ i ] ; } result = Math . floor ( result * ( Math . pow ( allPrimes [ i ] , exp + 1 ) - 1 ) / ( allPrimes [ i ] - 1 ) ) ; } return result ; }
function countIterations ( arr , n ) { var oneFound = false ; var res = 0 ; for ( var i = 0 ; i < n ; ) { if ( arr [ i ] == 1 ) oneFound = true ; while ( i < n && arr [ i ] == 1 ) i ++ ; var count_zero = 0 ; while ( i < n && arr [ i ] == 0 ) { count_zero ++ ; i ++ ; } if ( oneFound == false && i == n ) return - 1 ; var curr_count ; if ( i < n && oneFound == true ) { if ( ( count_zero & 1 ) == 0 ) curr_count = count_zero / 2 ; else curr_count = ( count_zero + 1 ) / 2 ; count_zero = 0 ; } else { curr_count = count_zero ; count_zero = 0 ; } res = Math . max ( res , curr_count ) ; } return res ; }
function isAutomorphic ( N ) { let sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return - 1 ; N /= 10 ; sq /= 10 ; } return 1 ; }
function printConsecutive ( last , first ) { document . write ( first ++ ) ; for ( let x = first ; x <= last ; x ++ ) document . write ( "▁+▁" + x ) ; }
function findConsecutive ( N ) { for ( let last = 1 ; last < N ; last ++ ) { for ( let first = 0 ; first < last ; first ++ ) { if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) { document . write ( N + "▁=▁" ) ; printConsecutive ( last , first + 1 ) ; return ; } } } document . write ( "-1" ) ; }
function printCubes ( a , b ) { for ( let i = a ; i <= b ; i ++ ) { for ( let j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { document . write ( j * j * j + "▁" ) ; break ; } } } }
function printCubes ( a , b ) { let acrt = parseInt ( Math . pow ( a , 1 / 3 ) , 10 ) ; let bcrt = parseInt ( Math . pow ( b , 1 / 3 ) , 10 ) ; for ( let i = acrt ; i <= bcrt ; i ++ ) if ( i * i * i >= a && i * i * i <= b ) document . write ( ( i * i * i ) + "▁" ) ; }
function findCount ( m , n ) { let num1 = 0 ; for ( let i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; let num2 = 0 ; for ( let i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; }
function findNthEvenDigitNumber ( n ) { let count = 0 ; for ( let i = 0 ; ; i ++ ) { let curr = i ; let isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = Math . floor ( curr / 10 ) ; } if ( isCurrEvenDigit === true ) count ++ ; if ( count === n ) return i ; } }
function findNthEvenDigitNumber ( n ) { if ( n == 1 ) { return 0 ; } let v = [ ] ; n = n - 1 ; while ( n > 0 ) { v . push ( n % 5 ) ; n = Math . floor ( n / 5 ) ; } let result = 0 ; for ( let i = v . length - 1 ; i >= 0 ; i -- ) { result = result * 10 ; result = result + v [ i ] ; } return 2 * result ; }
function fibonacci ( n ) { let a = 0 ; let b = 1 ; let c ; if ( n <= 1 ) return n ; for ( let i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }
function isMultipleOf10 ( n ) { let f = fibonacci ( 30 ) ; return ( f % 10 == 0 ) ; }
function isMultipleOf10 ( n ) { return ( n % 15 == 0 ) ; }
function isDivisibleBy25 ( str ) { n = str . length ; if ( n == 1 ) return false ; return ( ( str [ n - 1 ] - "0" == 0 && str [ n - 2 ] - "0" == 0 ) || ( ( str [ n - 2 ] - "0" ) * 10 + ( str [ n - 1 ] - "0" ) ) % 25 == 0 ) ; }
function findIndex ( n ) { if ( n <= 1 ) return n ; let a = 0 , b = 1 , c = 1 ; let res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
function isLeap ( y ) { if ( y % 100 != 0 && y % 4 == 0 y % 400 == 0 ) return true ; return false ; }
function offsetDays ( d , m , y ) { var offset = d ; if ( m - 1 == 11 ) offset += 335 ; if ( m - 1 == 10 ) offset += 304 ; if ( m - 1 == 9 ) offset += 273 ; if ( m - 1 == 8 ) offset += 243 ; if ( m - 1 == 7 ) offset += 212 ; if ( m - 1 == 6 ) offset += 181 ; if ( m - 1 == 5 ) offset += 151 ; if ( m - 1 == 4 ) offset += 120 ; if ( m - 1 == 3 ) offset += 90 ; if ( m - 1 == 2 ) offset += 59 ; if ( m - 1 == 1 ) offset += 31 ; if ( isLeap ( y ) && m > 2 ) offset += 1 ; return offset ; }
function addDays ( d1 , m1 , y1 , x ) { var offset1 = offsetDays ( d1 , m1 , y1 ) ; var remDays = isLeap ( y1 ) ? ( 366 - offset1 ) : ( 365 - offset1 ) ; var y2 , offset2 = 0 ; if ( x <= remDays ) { y2 = y1 ; offset2 = offset1 + x ; } else { x -= remDays ; y2 = y1 + 1 ; var y2days = isLeap ( y2 ) ? 366 : 365 ; while ( x >= y2days ) { x -= y2days ; y2 ++ ; y2days = isLeap ( y2 ) ? 366 : 365 ; } offset2 = x ; } revoffsetDays ( offset2 , y2 ) ; document . write ( "d2▁=▁" + d2 + ",▁m2▁=▁" + m2 + ",▁y2▁=▁" + y2 ) ; }
function divisorSum ( N , K ) { let sum = 0 ; for ( let i = 2 ; i <= Math . ceil ( Math . sqrt ( N ) ) ; i ++ ) if ( N % i == 0 ) sum += ( i + parseInt ( N / i , 10 ) ) ; return sum ; }
function isPrime ( n ) { if ( n == 1 n == 0 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function isHyperPerfect ( N , K ) { let sum = divisorSum ( N , K ) ; if ( ( 1 + K * ( sum ) ) == N ) return true ; else return false ; }
function printWellOrdered ( number , x , k ) { if ( k == 0 ) { document . write ( number + "▁" ) ; return ; } for ( let i = ( x + 1 ) ; i < 10 ; i ++ ) printWellOrdered ( number * 10 + i , i , k - 1 ) ; }
function generateWellOrdered ( k ) { printWellOrdered ( 0 , 0 , k ) ; }
function moduloMultiplication ( a , b , mod ) { let res = 0 ; a = ( a % mod ) ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; } return res ; }
function number0f2s ( n ) { let count = 0 ; while ( n > 0 ) { if ( n % 10 == 2 ) count ++ ; n = parseInt ( n / 10 , 10 ) ; } return count ; }
function numberOf2sinRange ( n ) { let count = 0 ; for ( let i = 2 ; i <= n ; i ++ ) count += number0f2s ( i ) ; return count ; }
function numberOf2sinRange ( n ) { var s = "" ; for ( var i = 0 ; i < n + 1 ; i ++ ) s += i . toString ( ) ; var count = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == "2" ) { count ++ ; } } return count ; }
function count2sinRangeAtDigit ( number , d ) { var powerOf10 = parseInt ( Math . pow ( 10 , d ) ) ; var nextPowerOf10 = powerOf10 * 10 ; var right = number % powerOf10 ; var roundDown = number - number % nextPowerOf10 ; var roundup = roundDown + nextPowerOf10 ; var digit = parseInt ( number / powerOf10 ) % 10 ; if ( digit < 2 ) { return roundDown / 10 ; } if ( digit == 2 ) { return roundDown / 10 + right + 1 ; } return roundup / 10 ; }
function numberOf2sinRange ( number ) { var convert ; convert = number . toString ( ) ; var s = convert ; var len = s . length ; var count = 0 ; for ( digit = 0 ; digit < len ; digit ++ ) { count += count2sinRangeAtDigit ( number , digit ) ; } return count ; }
function isDivisibleBy5 ( str ) { n = str . length ; return ( ( ( str [ n - 1 ] - "0" ) == 0 ) || ( ( str [ n - 1 ] - "0" ) == 5 ) ) ; }
function isTidy ( num ) { let prev = 10 ; while ( num != 0 ) { let rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
function areMirror ( a , b ) { if ( a == null && b == null ) return true ; if ( a == null b == null ) return false ; return a . data == b . data && areMirror ( a . left , b . right ) && areMirror ( a . right , b . left ) ; }
function printPairs ( arr , n ) { let v = [ ] ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . push ( Math . abs ( arr [ i ] ) ) ; if ( v . length == 0 ) return ; v . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < v . length ; i ++ ) document . write ( - v [ i ] + "▁" + v [ i ] ) ; }
function minToggle ( arr , n ) { let zero = new Array ( n + 1 ) ; zero [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } let ans = n ; for ( let i = 1 ; i <= n ; ++ i ) ans = Math . min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }
function LCM ( arr , n ) { var max_num = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( max_num < arr [ i ] ) max_num = arr [ i ] ; var res = 1 ; while ( x <= max_num ) { var indexes = [ ] ; for ( var j = 0 ; j < n ; j ++ ) if ( arr [ j ] % x == 0 ) indexes . push ( j ) ; if ( indexes . length >= 2 ) { for ( var j = 0 ; j < indexes . length ; j ++ ) arr [ indexes [ j ] ] = arr [ indexes [ j ] ] / x ; res = res * x ; } else x ++ ; } for ( var i = 0 ; i < n ; i ++ ) res = res * arr [ i ] ; return res ; }
function kFactors ( n , k ) { var P = Array ( ) ; while ( n % 2 == 0 ) { P . push ( 2 ) ; n = parseInt ( n / 2 ) ; } for ( i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { n = parseInt ( n / i ) ; P . push ( i ) ; } } if ( n > 2 ) P . push ( n ) ; if ( P . length < k ) { document . write ( "-1" ) ; return ; } for ( i = 0 ; i < k - 1 ; i ++ ) document . write ( P [ i ] + ",▁" ) ; var product = 1 ; for ( i = k - 1 ; i < P . length ; i ++ ) product = product * P [ i ] ; document . write ( product ) ; }
function nondecdigits ( n ) { let x = 0 ; for ( x = n ; x >= 1 ; x -- ) { let no = x ; let prev_dig = 11 ; let flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no = Math . floor ( no / 10 ) ; } if ( flag == true ) break ; } return x ; }
function nondecdigits ( s ) { var m = s . length ; var a = Array . from ( { length : m + 1 } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < m ; i ++ ) a [ i ] = s . charAt ( i ) . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ; var level = m - 1 ; for ( i = m - 1 ; i > 0 ; i -- ) { if ( a [ i ] < a [ i - 1 ] ) { a [ i - 1 ] -- ; level = i - 1 ; } } if ( a [ 0 ] != 0 ) { for ( i = 0 ; i <= level ; i ++ ) document . write ( a [ i ] ) ; for ( i = level + 1 ; i < m ; i ++ ) document . write ( "9" ) ; } else { for ( i = 1 ; i < level ; i ++ ) document . write ( a [ i ] ) ; for ( i = level + 1 ; i < m ; i ++ ) document . write ( "9" ) ; } }
function countDivisors ( n ) { let cnt = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; }
function hasEvenNumberOfFactors ( n ) { let root_n = Math . sqrt ( n ) ; if ( ( root_n * root_n ) == n ) return false ; return true ; }
function printStatusOfDoors ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { if ( hasEvenNumberOfFactors ( i ) ) document . write ( "closed" + "▁" ) ; else document . write ( "open" + "▁" ) ; } }
function validate ( n ) { for ( let i = 0 ; i < 10 ; i ++ ) { let temp = n ; let count = 0 ; while ( temp > 0 ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; }
function check ( str ) { let n = str . length ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - "0" ) ; return ( digitSum % 9 == 0 ) ; }
function getTotalXorOfSubarrayXors ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = i ; j < N ; j ++ ) for ( let k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; }
function getTotalXorOfSubarrayXors ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }
function check ( str ) { let n = str . length ; if ( ( str [ n - 1 ] - "0" ) % 2 != 0 ) return false ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - "0" ) ; return ( digitSum % 3 == 0 ) ; }
function checkPrime ( n ) { if ( n <= 1 ) return - 1 ; if ( n <= 3 ) return 0 ; if ( n % 2 == 0 n % 3 == 0 ) return - 1 ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return - 1 ; return 0 ; }
function printPrimePoints ( n ) { let count = countDigits ( n ) ; if ( count == 1 count == 2 ) { document . write ( "-1" ) ; return ; } let found = false ; for ( let i = 1 ; i < ( count - 1 ) ; i ++ ) { let left = Math . floor ( n / ( Math . pow ( 10 , count - i ) ) ) ; let right = n % ( Math . pow ( 10 , count - i - 1 ) ) ; if ( checkPrime ( left ) == 0 && checkPrime ( right ) == 0 ) { document . write ( i + "▁" ) ; found = true ; } } if ( found == false ) document . write ( "-1" ) ; }
function countOddPrimeFactors ( n ) { let result = 1 ; while ( n % 2 == 0 ) n /= 2 ; for ( let i = 3 ; i * i <= n ; i += 2 ) { let divCount = 0 ; while ( n % i == 0 ) { n /= i ; ++ divCount ; } result *= divCount + 1 ; } if ( n > 2 ) result *= 2 ; return result ; }
function politness ( n ) { return countOddPrimeFactors ( n ) - 1 ; }
function politness ( n ) { let count = 0 ; for ( let i = 2 ; i <= Math . sqrt ( 2 * n ) ; i ++ ) { let a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a = Math . floor ( a / i ) ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a = Math . floor ( a / 2 ) ; if ( a > 0 ) { count ++ ; } } return count ; }
function power ( num , n ) { if ( n == 0 ) return 1 ; else if ( n % 2 == 0 ) return power ( num , parseInt ( n / 2 ) ) * power ( num , parseInt ( n / 2 ) ) ; else return num * power ( num , parseInt ( n / 2 ) ) * power ( num , parseInt ( n / 2 ) ) ; }
function checkRecursive ( num , x , k , n ) { if ( x == 0 ) res ++ ; let r = Math . floor ( Math . pow ( num , 1.0 / n ) ) ; for ( let i = k + 1 ; i <= r ; i ++ ) { let a = x - Math . pow ( i , n ) ; if ( a >= 0 ) checkRecursive ( num , x - Math . pow ( i , n ) , i , n ) ; } return res ; }
function check ( x , n ) { return checkRecursive ( x , x , 0 , n ) ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function check ( str ) { let n = str . length ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - "0" ) ; return ( digitSum % 3 == 0 ) ; }
function reverseNum ( n ) { let rem , rev = 0 ; while ( n > 0 ) { rem = n % 10 ; rev = rev * 10 + rem ; n = parseInt ( n / 10 ) ; } return rev ; }
function isPalindrom ( num ) { return num == reverseNum ( num ) ; }
function nthPalindrome ( n , k ) { let num = Math . pow ( 10 , k - 1 ) ; while ( true ) { if ( isPalindrom ( num ) ) -- n ; if ( n == 0 ) break ; ++ num ; } return num ; }
function findMax ( n , a , b , k , m ) { let arr = new Array ( n ) ; arr . fill ( 0 ) ; for ( let i = 0 ; i < m ; i ++ ) { let lowerbound = a [ i ] ; let upperbound = b [ i ] ; for ( let j = lowerbound ; j <= upperbound ; j ++ ) arr [ j ] += k [ i ] ; } let res = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) res = Math . max ( res , arr [ i ] ) ; return res ; }
function isPerfectSquare ( n ) { let sq = Math . sqrt ( n ) ; return ( n == sq * sq ) ; }
function countPerfectDivisors ( n ) { let count = 0 ; for ( let i = 1 ; i * i <= n ; ++ i ) { if ( n % i == 0 ) { if ( isPerfectSquare ( i ) ) ++ count ; if ( n / i != i && isPerfectSquare ( n / i ) ) ++ count ; } } return count ; }
function precomputeCounts ( ) { for ( let i = 1 ; i * i < MAX ; ++ i ) { for ( let j = i * i ; j < MAX ; j += i * i ) ++ perfectDiv [ j ] ; } }
function countPerfectDivisors ( n ) { return perfectDiv [ n ] ; }
function sieve ( ) { spf [ 1 ] = 1 ; for ( let i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( let i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( let i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( let j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
function getDigitProduct ( x ) { if ( x < 10 ) return x ; if ( prodDig [ x ] != 0 ) return prodDig [ x ] ; var prod = ( x % 10 ) * getDigitProduct ( parseInt ( x / 10 ) ) ; return ( prodDig [ x ] = prod ) ; }
function findSeed ( n ) { var res = [ ] ; for ( var i = 1 ; i <= parseInt ( n / 2 ) ; i ++ ) if ( i * getDigitProduct ( i ) == n ) res . push ( i ) ; if ( res . length == 0 ) { document . write ( "NO▁seed▁exists" ) ; return ; } for ( i = 0 ; i < res . length ; i ++ ) document . write ( res [ i ] + "▁" ) ; }
function sieveOfEratosthenes ( ) { for ( let i = 2 ; i * i < MAX ; ++ i ) { if ( primedivisor [ i ] == 0 ) { for ( let j = i * i ; j < MAX ; j += i ) { primedivisor [ j ] = i ; } } } for ( let i = 1 ; i < MAX ; ++ i ) { if ( primedivisor [ i ] == 0 ) { primedivisor [ i ] = i ; } } }
function findDivisors ( arr , n ) { for ( let i = 0 ; i < MAX ; ++ i ) { pos [ i ] = divInd [ i ] = - 1 ; dist [ i ] = INF ; } for ( let i = 0 ; i < n ; ++ i ) { let num = arr [ i ] ; while ( num > 1 ) { let div = primedivisor [ num ] ; divisors [ i ] . push ( div ) ; while ( num % div == 0 ) { num = Math . floor ( num / div ) ; } } } }
function nearestGCD ( arr , n ) { findDivisors ( arr , n ) ; for ( let i = 0 ; i < n ; ++ i ) { for ( let div = 0 ; div < divisors [ i ] . length ; div ++ ) { if ( divInd [ divisors [ i ] [ div ] ] == - 1 ) { divInd [ divisors [ i ] [ div ] ] = i ; } else { let ind = divInd [ divisors [ i ] [ div ] ] ; divInd [ divisors [ i ] [ div ] ] = i ; if ( dist [ i ] > Math . abs ( ind - i ) ) { dist [ i ] = Math . abs ( ind - i ) ; pos [ i ] = ind + 1 ; } if ( dist [ ind ] > Math . abs ( ind - i ) ) { dist [ ind ] = Math . abs ( ind - i ) ; pos [ ind ] = i + 1 ; } } } } }
function maxPrimefactorNum ( N ) { var arr = Array . from ( { length : N + 5 } , ( _ , i ) => 0 ) ; for ( i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) { for ( j = 2 * i ; j <= N ; j += i ) { arr [ j ] ++ ; } } arr [ i ] = 1 ; } var maxval = 0 , maxvar = 1 ; for ( i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > maxval ) { maxval = arr [ i ] ; maxvar = i ; } } return maxvar ; }
function maxPrimefactorNum ( N ) { let arr = new Array ( N + 5 ) ; arr . fill ( false ) ; let i ; for ( i = 3 ; i * i <= N ; i += 2 ) { if ( ! arr [ i ] ) { for ( let j = i * i ; j <= N ; j += i ) { arr [ j ] = true ; } } } let prime = [ ] ; prime . push ( 2 ) ; for ( i = 3 ; i <= N ; i += 2 ) { if ( ! arr [ i ] ) { prime . push ( i ) ; } } let ans = 1 ; i = 0 ; while ( ans * prime [ i ] <= N && i < prime . length ) { ans *= prime [ i ] ; i ++ ; } return ans ; }
function sieveSundaram ( ) { let marked = new Array ( parseInt ( MAX / 2 ) + 100 ) . fill ( false ) ; for ( let i = 1 ; i <= ( Math . sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( let j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . push ( 2 ) ; for ( let i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push ( 2 * i + 1 ) ; }
function largestGCDSubsequence ( arr , n ) { var ans = 0 ; var maxele = Math . max ( ... arr ) ; for ( var i = 2 ; i <= maxele ; ++ i ) { var count = 0 ; for ( j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; }
function SieveOfEratosthenes ( ) { for ( let i = 2 ; i * i <= MAX ; ++ i ) { if ( prime [ i ] == 0 ) for ( let j = i * 2 ; j <= MAX ; j += i ) prime [ j ] = i ; } for ( let i = 1 ; i < MAX ; ++ i ) if ( prime [ i ] == 0 ) prime [ i ] = i ; }
function largestGCDSubsequence ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; ++ i ) { let element = arr [ i ] ; while ( element > 1 ) { let div = prime [ element ] ; ++ countdiv [ div ] ; ans = Math . max ( ans , countdiv [ div ] ) ; while ( element % div == 0 ) element /= div ; } } return ans ; }
function countOfBinaryNumberLessThanN ( N ) { var q = [ ] ; q . push ( 1 ) ; var cnt = 0 ; var t ; while ( q . length > 0 ) { t = q . pop ( ) ; if ( t <= N ) { cnt ++ ; q . push ( t * 10 ) ; q . push ( t * 10 + 1 ) ; } } return cnt ; }
function SubArraySum ( arr , n ) { let result = 0 , temp = 0 ; for ( let i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( let j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; }
function nthElement ( a , b , n ) { let seq = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) seq . push ( a * i ) ; seq . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 1 , k = n ; i <= n && k > 0 ; i ++ ) { if ( ! seq . includes ( b * i ) ) { seq . push ( b * i ) ; seq . sort ( function ( a , b ) { return a - b } ) ; k -- ; } } return seq [ n - 1 ] ; }
function findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) { for ( var i = 0 ; i < n1 ; i ++ ) for ( var j = 0 ; j < n2 ; j ++ ) for ( var k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
function multiplicativeOrder ( A , N ) { if ( GCD ( A , N ) != 1 ) return - 1 ; let result = 1 ; let K = 1 ; while ( K < N ) { result = ( result * A ) % N ; if ( result == 1 ) return K ; K ++ ; } return - 1 ; }
function sumOfRange ( a , b ) { let i = ( a * ( a + 1 ) ) >> 1 ; let j = ( b * ( b + 1 ) ) >> 1 ; return ( i - j ) ; }
function sumofproduct ( n ) { let sum = 0 ; let root = Math . floor ( Math . sqrt ( n ) ) ; for ( let i = 1 ; i <= root ; i ++ ) { let up = Math . floor ( n / i ) ; let low = Math . max ( Math . floor ( n / ( i + 1 ) ) , root ) ; sum += ( i * sumOfRange ( up , low ) ) ; sum += ( i * Math . floor ( n / i ) ) ; } return sum ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function power ( x , y , p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function findPrimefactors ( s , n ) { while ( n % 2 == 0 ) { s . add ( 2 ) ; n = n / 2 ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { s . add ( i ) ; n = n / i ; } } if ( n > 2 ) s . add ( n ) ; }
function findPrimitive ( n ) { let s = new Set ( ) ; if ( isPrime ( n ) == false ) return - 1 ; let phi = n - 1 ; findPrimefactors ( s , phi ) ; for ( let r = 2 ; r <= phi ; r ++ ) { let flag = false ; for ( let it of s ) { if ( power ( r , phi / it , n ) == 1 ) { flag = true ; break ; } } if ( flag == false ) return r ; } return - 1 ; }
function kPrimeFactor ( n , k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return - 1 ; }
function sieveOfEratosthenes ( s ) { prime = Array . from ( { length : MAX + 1 } , ( _ , i ) => false ) ; for ( i = 2 ; i <= MAX ; i += 2 ) s [ i ] = 2 ; for ( i = 3 ; i <= MAX ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( j = i ; j * i <= MAX ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
function kPrimeFactor ( n , k , s ) { while ( n > 1 ) { if ( k == 1 ) return s [ n ] ; k -- ; n /= s [ n ] ; } return - 1 ; }
function gcd ( a , b ) { return b > 0 ? gcd ( b , a % b ) : a ; }
function countGCD ( L , R , g ) { L = parseInt ( ( L + g - 1 ) / g , 10 ) ; R = parseInt ( R / g , 10 ) ; let ans = 0 ; for ( let i = L ; i <= R ; i ++ ) for ( let j = L ; j <= R ; j ++ ) if ( gcd ( i , j ) == 1 ) ans ++ ; return ans ; }
function minPower ( n , x ) { if ( x == 1 ) return n ; let ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n = Math . floor ( n / x ) ; } return ans ; }
function calSum ( n ) { let a = 3 , b = 0 , c = 2 ; return 3 ; return 3 ; return 5 ; let sum = 5 ; while ( n > 2 ) { let d = a + b ; sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; }
function sumDivisorsOfDivisors ( n ) { let mp = new Map ( ) ; for ( let j = 2 ; j <= Math . sqrt ( n ) ; j ++ ) { let count = 0 ; while ( n % j == 0 ) { n = Math . floor ( n / j ) ; count ++ ; } if ( count != 0 ) mp . set ( j , count ) ; } if ( n != 1 ) mp . set ( n , 1 ) ; let ans = 1 ; for ( let [ key , value ] of mp . entries ( ) ) { let pw = 1 ; let sum = 0 ; for ( let i = value + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw = key ; } ans *= sum ; } return ans ; }
function findMinNumber ( n ) { let count = 0 ; let ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 ) ans *= 2 ; for ( let i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function findgcd ( n , x , y ) { let g = gcd ( x , y ) ; for ( let i = 0 ; i < g ; i ++ ) document . write ( n ) ; }
function gcd ( a , b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; }
function firstFactorialDivisibleNumber ( x ) { let new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x /= gcd ( i , new_x ) ; if ( new_x == 1 ) break ; } return i ; }
function countFactorialXNotY ( x , y ) { return ( firstFactorialDivisibleNumber ( y ) - firstFactorialDivisibleNumber ( x ) ) ; }
function firstFactorialDivisibleNumber ( x ) { var fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
function gcd ( a , b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; }
function firstFactorialDivisibleNumber ( x ) { let new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x = parseInt ( new_x / gcd ( i , new_x ) , 10 ) ; if ( new_x == 1 ) break ; } return i ; }
function fact ( n ) { let num = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { num = num * i ; } return num ; }
function SieveOfEratosthenes ( n , isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( let i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( let i = p * p ; i <= n ; i += p ) isPrime [ i ] = false ; } } return false ; }
function highestPowerof2 ( n ) { let res = 0 ; for ( let i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }
function highestPowerof2 ( n ) { let p = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; return Math . pow ( 2 , p ) ; }
function getFirstDigit ( x ) { while ( x >= 10 ) x /= 10 ; return x ; }
function getCountWithSameStartAndEndFrom1 ( x ) { if ( x < 10 ) return x ; let tens = x / 10 ; let res = tens + 9 ; let firstDigit = getFirstDigit ( x ) ; let lastDigit = x % 10 ; if ( lastDigit < firstDigit ) res -- ; return res ; }
function getCountWithSameStartAndEnd ( start , end ) { return getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ; }
function sieveOfEratosthenes ( n , isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( let i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
function rightTruPrime ( n ) { let isPrime = new Array ( n + 1 ) . fill ( false ) ; sieveOfEratosthenes ( n , isPrime ) ; while ( n != 0 ) { if ( isPrime [ n ] ) n = parseInt ( n / 10 ) ; else return false ; } return true ; }
function countMaxChoco ( money , price , wrap ) { if ( money < price ) return 0 ; let choc = parseInt ( money / price , 10 ) ; choc = choc + parseInt ( ( choc - 1 ) / ( wrap - 1 ) , 10 ) ; return choc ; }
function SieveOfEratosthenes ( n , prime ) { for ( let i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } }
function mersennePrimes ( n ) { let prime = [ ] ; SieveOfEratosthenes ( n , prime ) ; for ( let k = 2 ; ( ( 1 << k ) - 1 ) <= n ; k ++ ) { let num = ( 1 << k ) - 1 ; if ( prime [ ( num ) ] ) document . write ( num + "▁" ) ; } }
function findSum ( N , K ) { let ans = 0 ; for ( let i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
function findSum ( N , K ) { let ans = 0 ; let y = N / K ; let x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
function sieve ( prime , n ) { for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } }
function maxDigitInPrimes ( L , R ) { let prime = new Array ( R + 1 ) ; for ( let i = 0 ; i < R + 1 ; i ++ ) { prime [ i ] = false ; } sieve ( prime , R ) ; let freq = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { freq [ i ] = 0 ; } let val ; for ( let i = L ; i <= R ; i ++ ) { if ( ! prime [ i ] ) { while ( p > 0 ) { freq [ p % 10 ] ++ ; p = Math . floor ( p / 10 ) ; } } } let max = freq [ 0 ] , ans = 0 ; for ( let j = 1 ; j < 10 ; j ++ ) { if ( max <= freq [ j ] ) { max = freq [ j ] ; ans = j ; } } return ans ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function simpleSieve ( ) { let arr = Array ( 1001 ) . fill ( true ) ; for ( let p = 2 ; p * p < 1001 ; p ++ ) { if ( arr [ p ] ) { for ( let i = p * 2 ; i < 1001 ; i = i + p ) arr [ i ] = false ; } } }
function find_sphene ( N ) { var arr1 = Array ( 8 ) . fill ( 0 ) ; var count = 0 ; var j = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { if ( N % i == 0 && count < 8 ) { count ++ ; arr1 [ j ++ ] = i ; } } if ( count == 8 && ( arr [ arr1 [ 1 ] ] && arr [ arr1 [ 2 ] ] && arr [ arr1 [ 3 ] ] ) ) return 1 ; return 0 ; }
function maxHandshake ( n ) { return ( n * ( n - 1 ) ) / 2 ; }
function gcd ( i , j ) { if ( i == j ) return i ; if ( i > j ) return gcd ( i - j , j ) ; return gcd ( i , j - i ) ; }
function ispossible ( x , y , a , b ) { x = Math . abs ( x ) ; y = Math . abs ( y ) ; a = Math . abs ( a ) ; b = Math . abs ( b ) ; return ( gcd ( x , y ) == gcd ( a , b ) ) ; }
function ApowBmodM ( a , b , m ) { let ans = aModM ( a , m ) ; let mul = ans ; for ( let i = 1 ; i < b ; i ++ ) ans = ( ans * mul ) % m ; return ans ; }
function divisible ( N , digit ) { let ans = 0 ; for ( let i = 0 ; i < N . length ; i ++ ) { ans = ( ans * 10 + ( N [ i ] - "0" ) ) ; ans %= digit ; } return ( ans == 0 ) ; }
function allDigits ( N ) { let divide = [ ] ; for ( let i = 0 ; i < divide . length ; i ++ ) { divide [ i ] = false ; } divide [ 1 ] = true ; for ( let digit = 2 ; digit <= 9 ; digit ++ ) { if ( divisible ( N , digit ) ) divide [ digit ] = true ; } let result = 0 ; for ( let i = 0 ; i < N . length ; i ++ ) { if ( divide [ N [ i ] - "0" ] == true ) result ++ ; } return result ; }
function countNums ( n , x , y ) { arr = Array ( n + 1 ) . fill ( false ) ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; var result = 0 ; for ( i = Math . min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
function reverse ( x ) { var rev = 0 ; while ( x > 0 ) { rev = ( rev * 10 ) + x % 10 ; x = parseInt ( x / 10 ) ; } return rev ; }
function printEmirp ( n ) { var prime = Array . from ( { length : n + 1 } , ( _ , i ) => true ) ; for ( p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { var rev = reverse ( p ) ; if ( p != rev && rev <= n && prime [ rev ] ) { document . write ( p + "▁" + rev + "▁" ) ; prime [ rev ] = false ; } } } }
function getSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else { sum = sum + i ; sum = sum + ( n / i ) ; } } } sum = sum - n ; return sum ; }
function checkAbundant ( n ) { return ( getSum ( n ) > n ) ; }
function longLenSub ( arr , n ) { let um = new Map ( ) ; let longLen = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let len = 0 ; if ( um . has ( arr [ i ] - 1 ) && len < um . get ( arr [ i ] - 1 ) ) len = um . get ( arr [ i ] - 1 ) ; if ( um . has ( arr [ i ] + 1 ) && len < um . get ( arr [ i ] + 1 ) ) len = um . get ( arr [ i ] + 1 ) ; um . set ( arr [ i ] , len + 1 ) ; if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ; } return longLen ; }
function isPowerful ( n ) { while ( n % 2 == 0 ) { let power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( let factor = 3 ; factor <= Math . sqrt ( n ) ; factor += 2 ) { let power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
function divisorsSum ( n ) { for ( let i = 1 ; i <= ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { sum = sum + i ; } { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; }
function isDeficient ( n ) { return ( divisorsSum ( n ) < ( 2 * n ) ) ; }
function isKeith ( x ) { let terms = [ ] ; let temp = x ; while ( temp > 0 ) { terms . push ( temp % 10 ) ; temp = parseInt ( temp / 10 ) ; n ++ ; } terms = terms . reverse ( ) ; let next_term = 0 ; let i = n ; while ( next_term < x ) { next_term = 0 ; for ( let j = 1 ; j <= n ; j ++ ) next_term += terms [ i - j ] ; terms . push ( next_term ) ; i ++ ; } return ( next_term == x ) ; }
function hcf ( a , b ) { if ( b == 0 ) return a ; return hcf ( b , a % b ) ; }
function findlcm ( a , b ) { if ( b == 1 ) return a ; a = ( a * b ) / hcf ( a , b ) ; b -= 1 ; return findlcm ( a , b ) ; }
function canBeSumofConsec ( n ) { return ( ( ( n & ( n - 1 ) ) != 0 ) && n != 0 ) ; }
function Sieve ( ) { let n = MAX ; let nNew = parseInt ( Math . sqrt ( n ) ) ; var marked = new Array ( n / 2 + 500 ) . fill ( 0 ) ; for ( let i = 1 ; i <= parseInt ( ( nNew - 1 ) / 2 ) ; i ++ ) for ( let j = ( i * ( i + 1 ) ) << 1 ; j <= parseInt ( n / 2 ) ; j = j + 2 * i + 1 ) marked [ j ] = 1 ; primes . push ( 2 ) ; for ( let i = 1 ; i <= parseInt ( n / 2 ) ; i ++ ) if ( marked [ i ] == 0 ) primes . push ( 2 * i + 1 ) ; }
function binarySearch ( left , right , n ) { if ( left <= right ) { let mid = parseInt ( ( left + right ) / 2 ) ; if ( mid == 0 mid == primes . length - 1 ) return primes [ mid ] ; if ( primes [ mid ] == n ) return primes [ mid - 1 ] ; if ( primes [ mid ] < n && primes [ mid + 1 ] > n ) return primes [ mid ] ; if ( n < primes [ mid ] ) return binarySearch ( left , mid - 1 , n ) ; else return binarySearch ( mid + 1 , right , n ) ; } return 0 ; }
function evenFibSum ( limit ) { if ( limit < 2 ) return 0 ; let ef1 = 0 , ef2 = 2 ; let sum = ef1 + ef2 ; while ( ef2 <= limit ) { let ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return sum ; }
function isPerfect ( n ) { var s = parseInt ( ( Math . sqrt ( n ) ) ) ; return ( s * s == n ) ; }
function divisorsCount ( n ) { var count = 0 ; for ( var i = 1 ; i <= parseInt ( Math . sqrt ( n ) ) + 1 ; i ++ ) { if ( n % i == 0 ) { if ( parseInt ( n / i ) == i ) count += 1 ; else count += 2 ; } } return count ; }
function evenFib ( n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
function buildSegtmentTree ( node , a , b ) { if ( a == b ) { segmentTree [ node ] = divisors [ a ] ; return ; } buildSegtmentTree ( 2 * node , a , Math . floor ( ( a + b ) / 2 ) ) ; buildSegtmentTree ( ( 2 * node ) + 1 , Math . floor ( ( a + b ) / 2 ) + 1 , b ) ; segmentTree [ node ] = Math . max ( segmentTree [ 2 * node ] , segmentTree [ ( 2 * node ) + 1 ] ) ; }
function query ( node , a , b , l , r ) { if ( l > b a > r ) return - 1 ; if ( a >= l && b <= r ) return segmentTree [ node ] ; return Math . max ( query ( 2 * node , a , Math . floor ( ( a + b ) / 2 ) , l , r ) , query ( 2 * node + 1 , Math . floor ( ( a + b ) / 2 ) + 1 , b , l , r ) ) ; }
function countSteps ( x , y ) { if ( x % y == 0 ) return Math . floor ( x / y ) ; return Math . floor ( x / y ) + countSteps ( y , x % y ) ; }
function primeFactorize ( a ) { for ( let i = 2 ; i * i <= a ; i += 2 ) { let cnt = 0 ; while ( a % i == 0 ) { cnt ++ ; a = parseInt ( a / i , 10 ) ; } ma . set ( i , cnt ) ; } if ( a > 1 ) { ma . set ( a , 1 ) ; } }
function commDiv ( a , b ) { primeFactorize ( a ) ; let res = 1 ; ma . forEach ( ( values , keys ) => { let cnt = 0 ; let key = keys ; let value = values ; while ( b % key == 0 ) { b = parseInt ( b / key , 10 ) ; cnt ++ ; } res *= ( Math . min ( cnt , value ) + 1 ) ; } )  return res ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function y ( x ) { return 1 / ( 1 + x * x ) ; }
function trapezoidal ( a , b , n ) { let h = ( b - a ) / n ; let s = y ( a ) + y ( b ) ; for ( let i = 1 ; i < n ; i ++ ) s += 2 * y ( a + i * h ) ; return ( h / 2 ) * s ; }
function spellsCount ( num ) { let n = num . length ; let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * Math . pow ( 2 , count - 1 ) ; } return result ; }
function numSquareSum ( n ) { var squareSum = 0 ; while ( n != 0 ) { squareSum += ( n % 10 ) * ( n % 10 ) ; n = parseInt ( n / 10 ) ; } return squareSum ; }
function isHappynumber ( n ) { var slow , fast ; slow = fast = n ; do { slow = numSquareSum ( slow ) ; fast = numSquareSum ( numSquareSum ( fast ) ) ; } while ( slow != fast ) ; return ( slow == 1 ) ; }
function kaprekar ( n ) { var prev = 0 ; return kaprekarRec ( n , prev ) ; }
function sqroot ( s ) { var pSq = 0 ; var N = 0 ; for ( i = parseInt ( s ) ; i > 0 ; i -- ) { for ( j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } var d = s - pSq ; var P = ( d / ( 2.0 * N ) ) ; var A = N + P ; var sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; }
function power ( x , a ) { let res = 1 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) res = res * x ; x = x * x ; a >>= 1 ; } return res ; }
function breakInteger ( N ) { if ( N == 2 ) return 1 ; if ( N == 3 ) return 2 ; let maxProduct ; switch ( N % 3 ) { case 0 : maxProduct = power ( 3 , N / 3 ) ; break ; case 1 : maxProduct = 2 * 2 * power ( 3 , ( N / 3 ) - 1 ) ; break ; case 2 : maxProduct = 2 * power ( 3 , N / 3 ) ; break ; } return maxProduct ; }
function maxProd ( n ) { if ( n == 2 n == 3 ) return ( n - 1 ) ; let res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; }
function digSum ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
function countMultiples ( n ) { return Math . floor ( n / 3 + n / 7 - n / 21 ) ; }
function sieve ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( let p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . push ( p ) ; }
function factorialDivisors ( n ) { let result = 1 ; for ( let i = 0 ; i < allPrimes . length ; i ++ ) { let p = allPrimes [ i ] ; let exp = 0 ; while ( p <= n ) { exp = exp + parseInt ( n / p , 10 ) ; p = p * allPrimes [ i ] ; } result = result * ( exp + 1 ) ; } return result ; }
function nonFibonacci ( n ) { let prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }
function reversDigits ( num ) { let rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = parseInt ( num / 10 , 10 ) ; } return rev_num ; }
function isPalindrome ( num ) { return ( reversDigits ( num ) == num ) ; }
function countOddSquares ( n , m ) { return Math . pow ( m , 0.5 ) - Math . pow ( n - 1 , 0.5 ) ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; let k ; for ( k = 0 ; ( ( a b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a & 1 ) == 0 ) a >>= 1 ; do { while ( ( b & 1 ) == 0 ) b >>= 1 ; if ( a > b ) { let t = a ; a = b ; b = t ; } b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; }
function gcd ( a , b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; { return gcd ( a >> 1 , b ) ; return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
function countWindowDistinct ( win , k ) { let dist_count = 0 ; for ( let i = 0 ; i < k ; i ++ ) { let j ; for ( j = 0 ; j < i ; j ++ ) if ( win [ i ] == win [ j ] ) break ; if ( j == i ) dist_count ++ ; } return dist_count ; }
function toInt ( x ) { return x - "0" ; }
function findNDigitNums ( n ) { let out = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { out [ i ] = 0 ; } let index = 0 ; let evenSum = 0 , oddSum = 0 ; for ( let i = 1 ; i <= 9 ; i ++ ) { out [ index ] = String . fromCharCode ( i + "0" . charCodeAt ( 0 ) ) ; findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) ; } }
function findNDigitNumsUtil ( n , sum , out , index ) { if ( index > n sum < 0 ) return ; if ( index == n ) { if ( sum == 0 ) { out [ index ] = "\0" ; for ( let i = 0 ; i < out . length ; i ++ ) document . write ( out [ i ] ) ; document . write ( "▁" ) ; } return ; } for ( let i = 0 ; i <= 9 ; i ++ ) { out [ index ] = String . fromCharCode ( i + "0" . charCodeAt ( 0 ) ) ; findNDigitNumsUtil ( n , sum - i , out , index + 1 ) ; } }
function findNDigitNums ( n , sum ) { let out = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { out [ i ] = false ; } for ( let i = 1 ; i <= 9 ; i ++ ) { out [ 0 ] = String . fromCharCode ( i + "0" . charCodeAt ( 0 ) ) ; findNDigitNumsUtil ( n , sum - i , out , 1 ) ; } }
function operation ( n , k ) { let answered = false ; if ( n < k ) { answered = true ; document . write ( "No" ) ; } let ok = factors ( n , k ) ; if ( ! ok && ! answered ) { answered = true ; document . write ( "No" ) ; } if ( ok && ! answered ) document . write ( "Yes" ) ; }
function isPalUtil ( num , dupNum ) { if ( oneDigit ( num ) ) return ( num == ( dupNum ) % 10 ) ; if ( ! isPalUtil ( parseInt ( num / 10 ) , dupNum ) ) return false ; dupNum = parseInt ( dupNum / 10 ) ; return ( num % 10 == ( dupNum ) % 10 ) ; }
function isPal ( num ) { if ( num < 0 ) num = - num ; return isPalUtil ( num , dupNum ) ; }
function printPalPrimesLessThanN ( n ) { var prime = Array . from ( { length : n + 1 } , ( _ , i ) => true ) ; for ( p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( i = p * 2 ; i <= n ; i += p ) { prime [ i ] = false ; } } } for ( p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] && isPal ( p ) ) { document . write ( p + "▁" ) ; } } }
function countPrimeFactors ( n ) { let count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; }
function printKAlmostPrimes ( k , n ) { for ( let i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == k ) { document . write ( num + "▁" ) ; i ++ ; } } return ; }
function findPieces ( n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; }
function numToWords ( n , s ) { var str = "" ; if ( n > 19 ) { str += ten [ parseInt ( n / 10 ) ] + one [ n % 10 ] ; } else { str += one [ n ] ; } if ( n != 0 ) { str += s ; } return str ; }
function convertToWords ( n ) { var out = "" ; out += numToWords ( parseInt ( n / 10000000 ) , "crore▁" ) ; out += numToWords ( parseInt ( ( n / 100000 ) % 100 ) , "lakh▁" ) ; out += numToWords ( parseInt ( ( n / 1000 ) % 100 ) , "thousand▁" ) ; out += numToWords ( parseInt ( ( n / 100 ) % 10 ) , "hundred▁" ) ; if ( n > 100 && n % 100 > 0 ) { out += "and▁" ; } out += numToWords ( parseInt ( n % 100 ) , "" ) ; return out ; }
function findDigits ( n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; let x = ( ( n * Math . log10 ( n / Math . E ) + Math . log10 ( 2 * Math . PI * n ) / 2.0 ) ) ; return Math . floor ( x ) + 1 ; }
function findDigits ( n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; let digits = 0 ; for ( let i = 2 ; i <= n ; i ++ ) digits += Math . log10 ( i ) ; return Math . floor ( digits ) + 1 ; }
function findPairs ( n ) { var cubeRoot = parseInt ( Math . pow ( n , 1.0 / 3.0 ) ) ; var cube = Array . from ( { length : cubeRoot + 1 } , ( _ , i ) => 0 ) ; for ( i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; var l = 1 ; var r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { document . write ( "(" + l + ",▁" + r + ")" ) ; l ++ ; r -- ; } } }
function countEvenSum ( arr , n ) { let result = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { let sum = 0 ; for ( let j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; }
function countEvenSum ( arr , n ) { let temp = [ 1 , 0 ] ; let result = 0 , sum = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { sum = ( ( sum + arr [ i ] ) % 2 + 2 ) % 2 ; temp [ sum ] ++ ; } result = result + ( temp [ 0 ] * ( temp [ 0 ] - 1 ) / 2 ) ; result = result + ( temp [ 1 ] * ( temp [ 1 ] - 1 ) / 2 ) ; return ( result ) ; }
function countEvenSum ( a , n ) { let res = 0 ; let s = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] % 2 == 1 ) { s = n - i - 1 - s ; } else { s = s + 1 ; } res = res + s ; } return res ; }
function isPossible ( a , b , c ) { return ( c % gcd ( a , b ) == 0 ) ; }
function gcd ( a , b ) { while ( b != 0 ) { let t = b ; b = a % b ; a = t ; } return a ; }
function findMinDiff ( a , b , x , y ) { let g = gcd ( a , b ) ; let diff = Math . abs ( x - y ) % g ; return Math . min ( diff , g - diff ) ; }
function calculateSum ( n ) { let fibo = [ ] ; if ( n <= 0 ) return 0 ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; let sum = fibo [ 0 ] + fibo [ 1 ] ; for ( let i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; }
function findCombinations ( n ) { let arr = [ ] ; findCombinationsUtil ( arr , 0 , n , n ) ; }
function isPower ( x , y ) { var res1 = parseInt ( Math . log ( y ) ) / parseInt ( Math . log ( x ) ) ; var res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; }
function isPerfectSquare ( n ) { for ( let sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
function findCount ( d ) { return 9 * ( ( Math . pow ( 10 , d - 1 ) ) - ( Math . pow ( 9 , d - 1 ) ) ) ; }
function countDyckPaths ( n ) { let res = 1 ; for ( let i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
function printDivisors ( n ) { let v = [ ] ; let t = 0 ; for ( let i = 1 ; i <= parseInt ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( parseInt ( n / i ) == i ) document . write ( i + "%d▁" ) ; else { document . write ( i + "%d▁" ) ; v [ t ++ ] = parseInt ( n / i ) ; } } } for ( let i = v . length - 1 ; i >= 0 ; i -- ) { document . write ( v [ i ] + "%d▁" ) ; } }
function printDivisors ( n ) { for ( var i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) document . write ( i + "▁" ) ; } for ( var i = Math . sqrt ( n ) ; i >= 1 ; i -- ) { if ( n % i == 0 ) document . write ( "▁" + n / i ) ; } }
function printDivisors ( n ) { for ( i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) document . write ( i + "▁" ) ; }
function isTriangular ( num ) { if ( num < 0 ) return false ; let sum = 0 ; for ( let n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }
function has0 ( x ) { while ( x ) { if ( x % 10 == 0 ) return 1 ; x = Math . floor ( x / 10 ) ; } return 0 ; }
function getCount ( n ) { let count = 0 ; for ( let i = 1 ; i <= n ; i ++ ) count += has0 ( i ) ; return count ; }
function xor_c ( a , b ) { return ( a == b ) ? "0" : "1" ; }
function greyConverter ( n ) { return n ^ ( n >> 1 ) ; }
function seriesSum ( calculated , current , N ) { let i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return ( gcd ( b , a % b ) ) ; }
function findSmallest ( a , b ) { let lcm = parseInt ( ( a * b ) / gcd ( a , b ) , 10 ) ; document . write ( "x▁=▁" + parseInt ( lcm / a , 10 ) + "y=" + parseInt ( lcm / b , 10 ) ) ; }
function power ( x , y , p ) { while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function squareRoot ( n , p ) { if ( p % 4 != 3 ) { document . write ( "Invalid▁Input" ) ; return ; } n = n % p ; let x = power ( n , Math . floor ( ( p + 1 ) / 4 ) , p ) ; if ( ( x * x ) % p == n ) { document . write ( "Square▁root▁is▁" + x ) ; return ; } x = p - x ; if ( ( x * x ) % p == n ) { document . write ( "Square▁root▁is▁" + x ) ; return ; } document . write ( "Square▁root▁doesn't▁exist▁" ) ; }
function getSum ( BITree , index ) { let sum = 0 ; while ( index > 0 ) { sum += BITree [ index ] ; index -= index & ( - index ) ; } return sum ; }
function convert ( arr , n ) { let temp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) temp [ i ] = arr [ i ] ; temp . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < n ; i ++ ) { arr [ i ] = lower_bound ( temp , 0 , n , arr [ i ] ) + 1 ; } }
function getInvCount ( arr , n ) { let invcount = 0 ; convert ( arr , n ) ; let BIT = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) BIT [ i ] = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { invcount += getSum ( BIT , arr [ i ] - 1 ) ; updateBIT ( BIT , n , arr [ i ] , 1 ) ; } return invcount ; }
function modFact ( n , p ) { if ( n >= p ) return 0 ; let result = 1 ; for ( let i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; }
function largestPower ( n , p ) { let x = 0 ; while ( n > 0 ) { n = parseInt ( n / p , 10 ) ; x += n ; } return x ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
function modFact ( n , p ) { if ( n >= p ) { return 0 ; } let res = 1 ; let isPrime = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) isPrime [ i ] = true ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( isPrime [ i ] ) { for ( let j = 2 * i ; j <= n ; j += i ) { isPrime [ j ] = false ; } } } for ( let i = 2 ; i <= n ; i ++ ) { if ( isPrime [ i ] ) { let k = largestPower ( n , i ) ; res = ( res * power ( i , k , p ) ) % p ; } } return res ; }
function modInverse ( a , p ) { return power ( a , p - 2 , p ) ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function miillerTest ( d , n ) { let a = 2 + Math . floor ( Math . random ( ) * ( n - 2 ) ) % ( n - 4 ) ; let x = power ( a , d , n ) ; if ( x == 1 x == n - 1 ) return true ; while ( d != n - 1 ) { x = ( x * x ) % n ; d *= 2 ; if ( x == 1 ) return false ; if ( x == n - 1 ) return true ; } return false ; }
function isPrime ( n , k ) { if ( n <= 1 n == 4 ) return false ; if ( n <= 3 ) return true ; let d = n - 1 ; while ( d % 2 == 0 ) d /= 2 ; for ( let i = 0 ; i < k ; i ++ ) if ( ! miillerTest ( d , n ) ) return false ; return true ; }
function inv ( a , m ) { let m0 = m ; let x0 = 0 ; let x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { let q = parseInt ( a / m ) ; let t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
function findMinX ( num , rem , k ) { let prod = 1 ; for ( let i = 0 ; i < k ; i ++ ) prod *= num [ i ] ; let result = 0 ; for ( let i = 0 ; i < k ; i ++ ) { pp = parseInt ( prod / num [ i ] ) ; result += rem [ i ] * inv ( pp , num [ i ] ) * pp ; } return result % prod ; }
function findMinX ( num , rem , k ) { while ( true ) { var j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }
function largestFiboLessOrEqual ( n ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; let i ; for ( i = 2 ; fib [ i - 1 ] <= n ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } return ( i - 2 ) ; }
function isValid ( n , d ) { var digit = n % 10 ; var sum = digit ; if ( digit == d ) return false ; n = parseInt ( n / 10 ) ; while ( n > 0 ) { digit = n % 10 ; if ( digit == d digit <= sum ) return false ; else { sum += digit ; n = parseInt ( n / 10 ) ; } } return true ; }
function countSquares ( m , n ) { if ( n < m ) [ m , n ] = [ n , m ] ; return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }
function countSquares ( m , n ) { if ( n < m ) { var temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }
function printFibRepresntation ( n ) { while ( n > 0 ) { let f = nearestSmallerEqFib ( n ) ; document . write ( f , "▁" ) ; n = n - f ; } }
function countWaysUtil ( n , parts , nextPart ) { if ( parts == 0 && n == 0 ) return 1 ; if ( n <= 0 parts <= 0 ) return 0 ; if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) return dp [ n ] [ nextPart ] [ parts ] ; for ( let i = nextPart ; i <= n ; i ++ ) ans += countWaysUtil ( n - i , parts - 1 , i ) ; return ( dp [ n ] [ nextPart ] [ parts ] = ans ) ; }
function countWays ( n ) { for ( let i = 0 ; i < 5001 ; i ++ ) { for ( let j = 0 ; j < 5001 ; j ++ ) { for ( let l = 0 ; l < 5 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } } return countWaysUtil ( n , 4 , 1 ) ; }
function pairAndSum ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }
function Euler_totient_function ( n ) { let result = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { let c = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { c ++ ; n = parseInt ( n / i ) ; } } if ( c > 0 ) { let power = Math . pow ( i , c - 1 ) ; let sm = Math . pow ( i , c - 1 ) * ( i - 1 ) ; result *= sm ; } } if ( n > 1 ) { result *= ( n - 1 ) ; } return result ; }
function nextSparse ( x ) { let bin = new Array ( ) ; while ( x != 0 ) { bin . push ( x & 1 ) ; x >>= 1 ; } bin . push ( 0 ) ; n = bin . length ; let last_final = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( bin [ i ] == 1 && bin [ i - 1 ] == 1 && bin [ i + 1 ] != 1 ) { bin [ i + 1 ] = 1 ; for ( let j = i ; j >= last_final ; j -- ) bin [ j ] = 0 ; last_final = i + 1 ; } } let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans += bin [ i ] * ( 1 << i ) ; return ans ; }
function isPower ( n ) { let p ; if ( n <= 1 ) { return true ; } for ( let i = 2 ; i <= parseInt ( Math . sqrt ( n ) , 10 ) ; i ++ ) { p = ( Math . log ( n ) / Math . log ( i ) ) . toFixed ( 14 ) ; if ( ( Math . ceil ( p ) == Math . floor ( p ) ) && ( p > 1 ) ) { return true ; } } return false ; }
function sumBitDifferences ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; }
function generateUtil ( x , arr , curr_sum , curr_idx ) { if ( curr_sum == x ) { printArr ( arr , curr_idx ) ; return ; } let num = 1 ; while ( num <= x - curr_sum && ( curr_idx == 0 num <= arr [ curr_idx - 1 ] ) ) { arr [ curr_idx ] = num ; generateUtil ( x , arr , curr_sum + num , curr_idx + 1 ) ; num ++ ; } }
function generate ( x ) { let arr = new Array ( x ) ; generateUtil ( x , arr , 0 , 0 ) ; }
function isPerfect ( n ) { sum = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
function check ( num , dig ) { for ( base = 2 ; base <= 32 ; base ++ ) if ( checkUtil ( num , dig , base ) ) return true ; return false ; }
function isLucky ( n ) { var arr = Array ( 10 ) . fill ( 0 ) ; for ( var i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { var digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = parseInt ( n / 10 ) ; } return true ; }
function countFact ( low , high ) { let fact = 1 ; let x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; } let res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; } return res ; }
function nthMagicNo ( n ) { let pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; }
function modInverse ( a , m ) { for ( let x = 1 ; x < m ; x ++ ) if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) return x ; }
function modInverse ( a , m ) { let m0 = m ; let y = 0 ; let x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { let q = parseInt ( a / m ) ; let t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function phi ( n ) { let result = 1 ; for ( let i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; }
function phi ( n ) { let result = n ; for ( let p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / n ) ) ; return parseInt ( result ) ; }
function getDifference ( dt1 , dt2 ) { let n1 = dt1 . y * 365 + dt1 . d ; for ( let i = 0 ; i < dt1 . m - 1 ; i ++ ) { n1 += monthDays [ i ] ; } n1 += countLeapYears ( dt1 ) ; let n2 = dt2 . y * 365 + dt2 . d ; for ( let i = 0 ; i < dt2 . m - 1 ; i ++ ) { n2 += monthDays [ i ] ; } n2 += countLeapYears ( dt2 ) ; return ( n2 - n1 ) ; }
function countOfMultiples ( n ) { return ( parseInt ( n / 3 , 10 ) + parseInt ( n / 5 , 10 ) - parseInt ( n / 15 , 10 ) ) ; }
function getPeriod ( n ) { let rem = 1 ; for ( let i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; let d = rem ; let count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
function calculateAddedValue ( number ) { let result = 0 ; let decimalPlace = 1 ; if ( number == 0 ) { result += ( 5 * decimalPlace ) ; } while ( number > 0 ) { if ( number % 10 == 0 ) { result += ( 5 * decimalPlace ) ; } number = Math . floor ( number / 10 ) ; decimalPlace *= 10 ; } return result ; }
function getRemainder ( num , divisor ) { let t = ( num - divisor * parseInt ( num / divisor ) ) ; return t ; }
function getRemainder ( num , divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }
function minInsertion ( str ) { let n = str . length ; let res = 0 ; let count = new Array ( 26 ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) count [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; }
function factorial ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
function sum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += 1.0 / factorial ( i ) ; return sum ; }
function sum ( n ) { let sum = 0 ; let fact = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum . toFixed ( 5 ) ; }
function catalan ( n ) { let c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
function printSquares ( n ) { let square = 0 , odd = 1 ; for ( let x = 0 ; x < n ; x ++ ) { document . write ( square + "▁" ) ; square = square + odd ; odd = odd + 2 ; } }
function isOperand ( c ) { return ( c . charCodeAt ( 0 ) >= "0" . charCodeAt ( 0 ) && c . charCodeAt ( 0 ) <= "9" . charCodeAt ( 0 ) ) ; }
function value ( c ) { return ( c . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) ; }
function evaluate ( exp ) { if ( exp . length == 0 ) return - 1 ; let res = value ( exp [ 0 ] ) ; for ( let i = 1 ; i < exp . length ; i += 2 ) { let opr = exp [ i ] , opd = exp [ i + 1 ] ; if ( isOperand ( opd ) == false ) return - 1 ; if ( opr == "+" ) res += value ( opd ) ; else if ( opr == "-" ) res -= value ( opd ) ; else if ( opr == "*" ) res *= value ( opd ) ; else if ( opr == "/" ) res /= value ( opd ) ; else return - 1 ; } return res ; }
function sum ( n ) { var i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }
function printFibonacciNumbers ( n ) { let f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; document . write ( f1 + "▁" ) ; for ( i = 1 ; i < n ; i ++ ) { document . write ( f2 + "▁" ) ; let next = f1 + f2 ; f1 = f2 ; f2 = next ; } }
function factorial ( n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
function factorial ( n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function lcm ( a , b ) { return ( a / gcd ( a , b ) ) * b ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
function gcd ( a , b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }
function rearrange ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] += ( arr [ arr [ i ] ] % n ) * n ; for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = Math . floor ( arr [ i ] / n ) ; }
function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; document . write ( "" ) ; }
function maxdiff ( arr , n ) { let freq = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) freq . set ( arr [ i ] , freq . get ( arr [ i ] ) == null ? 1 : freq . get ( arr [ i ] ) + 1 ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( freq . get ( arr [ i ] ) > freq . get ( arr [ j ] ) && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ i ] ) - freq . get ( arr [ j ] ) ) ; else if ( freq . get ( arr [ i ] ) < freq . get ( arr [ j ] ) && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ j ] ) - freq . get ( arr [ i ] ) ) ; } } return ans ; }
function printSequencesRecur ( arr , n , k , index ) { var i ; if ( k == 0 ) { printArray ( arr , index ) ; } if ( k > 0 ) { for ( i = 1 ; i <= n ; ++ i ) { arr [ index ] = i ; printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; } } }
function printSequences ( n , k ) { var arr = Array . from ( { length : k } , ( _ , i ) => 0 ) ; printSequencesRecur ( arr , n , k , 0 ) ; return ; }
function isMultipleof5 ( n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }
function isPowerOfTwo ( x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
function isPowerofTwo ( n ) { if ( n == 0 ) return false ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return true ; return false ; }
function reversDigits ( num ) { if ( num > 0 ) { reversDigits ( Math . floor ( num / 10 ) ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }
function countSubsequences ( arr ) { let odd = 0 ; let even = 0 ; for ( let x of arr ) { if ( x & 1 ) odd ++ ; else even ++ ; } return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; }
function findDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let count = 0 , max_count = 0 , min_count = n ; for ( let i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
function XorSum ( A , B , N , M ) { let ans = - 1 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( ans == - 1 ) ans = ( A [ i ] & B [ j ] ) ; else ans ^= ( A [ i ] & B [ j ] ) ; } } return ans ; }
function countbitdiff ( xo ) { let count = 0 ; while ( xo ) { if ( xo % 2 == 1 ) { count ++ ; } xo = Math . floor ( xo / 2 ) ; } return count ; }
function convertXOR ( arr ) { for ( let i = 0 ; i < M ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { let X = arr [ i ] [ j ] ; let temp = findXOR ( X ) ; arr [ i ] [ j ] = temp ; } } prletXORmatrix ( arr ) ; }
function countSet ( N ) { let ans = 0 ; while ( N ) { ans += N & 1 ; N >>= 1 ; } return ans ; }
function countSub ( arr , k ) { let ans = 0 ; let setK = 0 ; for ( let i = 0 ; i < 5 ; i ++ ) { if ( countSet ( arr [ i ] ) == k ) setK += 1 ; else setK = 0 ; ans += setK ; } return ans ; }
function oddXorSubarray ( a , n ) { var odd = 0 ; var c_odd = 0 ; var result = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 ) { odd = ( odd == 0 ) ? 1 : 0 ; } if ( odd != 0 ) { c_odd ++ ; } } for ( i = 0 ; i < n ; i ++ ) { result += c_odd ; if ( a [ i ] % 2 != 0 ) { c_odd = ( n - i - c_odd ) ; } } document . write ( result ) ; }
function countPairs ( arr , N , K ) { let mp = new Map ( ) ; let cnt = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( mp . has ( K - arr [ i ] ) ) { cnt += mp . get ( K - arr [ i ] ) ; } if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } document . write ( cnt ) ; }
function uniqueLevels ( root ) { let uniqueLevels = 0 ; let que = [ ] ; que . push ( root ) ; while ( que . length > 0 ) { let length = que . length ; let prefix_XOR = 0 ; let prefix_OR = 0 ; let flag = true ; for ( let i = 0 ; i < length ; i ++ ) { let temp = que [ 0 ] ; que . shift ( ) ; prefix_OR |= temp . val ; prefix_XOR ^= temp . val ; if ( prefix_XOR != prefix_OR ) flag = false ; if ( temp . left != null ) que . push ( temp . left ) ; if ( temp . right != null ) que . push ( temp . right ) ; } if ( flag ) uniqueLevels += 1 ; } document . write ( uniqueLevels ) ; }
function query ( l , r , pre ) { if ( l == 0 ) return pre [ r ] ; else return pre [ r ] - pre [ l - 1 ] ; }
function countInRange ( arr , N , queries , Q ) { var pre = Array ( N ) . fill ( 0 ) ; pre [ 0 ] = check ( arr [ 0 ] ) ; for ( var i = 1 ; i < N ; i ++ ) { pre [ i ] = pre [ i - 1 ] + check ( arr [ i ] ) ; } var c = 0 ; while ( Q -- ) { var l = queries [ 0 ] ; var r = queries [ 1 ] ; c ++ ; document . write ( query ( l , r , pre ) + "▁" ) ; } }
function Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) { let frequency = new Array ( 32 ) . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { let bit_position = 0 ; let num = arr1 [ i ] ; while ( num ) { if ( num & 1 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( let i = 0 ; i < M ; i ++ ) { let num = arr2 [ i ] ; let value_at_that_bit = 1 ; let bitwise_AND_sum = 0 ; for ( let bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( num & 1 ) { bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } document . write ( bitwise_AND_sum + "▁" ) ; } return ; }
function Bitwise_OR_sum_i ( arr1 , arr2 , M , N ) { let frequency = new Array ( 32 ) . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { let bit_position = 0 ; let num = arr1 [ i ] ; while ( num ) { if ( num & 1 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( let i = 0 ; i < M ; i ++ ) { let num = arr2 [ i ] ; let value_at_that_bit = 1 ; let bitwise_OR_sum = 0 ; for ( let bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( num & 1 ) { bitwise_OR_sum += N * value_at_that_bit ; } else { bitwise_OR_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } document . write ( bitwise_OR_sum + "▁" ) ; } return ; }
function constructArray ( A , N , K ) { let B = new Array ( N ) ; let totalXOR = A [ 0 ] ^ K ; for ( let i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( let i = 0 ; i < N ; i ++ ) { document . write ( B [ i ] + "▁" ) ; } }
function countPairs ( arr , k , size ) { let count = 0 , x ; for ( let i = 0 ; i < size - 1 ; i ++ ) { for ( let j = i + 1 ; j < size ; j ++ ) { x = arr [ i ] | arr [ j ] ; if ( x == k ) count ++ ; } } document . write ( count ) ; }
function dfs ( node , xorr , k ) { visited [ node ] = 1 ; if ( node != 1 && xorr == k ) ans ++ ; for ( let x of adj [ node ] ) { if ( ! visited [ x [ 0 ] ] ) { let xorr1 = xorr ^ x [ 1 ] ; dfs ( x [ 0 ] , xorr1 , k ) ; } } }
function maxDiff ( arr , n ) { let SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { let isSingleOccurance = true ; for ( let j = i + 1 ; j <= n - 1 ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ; }
function build_num ( bit ) { let ans = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) if ( bit [ i ] > 0 ) ans += ( 1 << i ) ; return ans ; }
function maximumOR ( arr , n , k ) { let bit = new Array ( 32 ) ; bit . fill ( 0 ) ; for ( let i = 0 ; i < k ; i ++ ) { for ( let j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) bit [ j ] ++ ; } } let max_or = build_num ( bit ) ; for ( let i = k ; i < n ; i ++ ) { for ( let j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i - k ] & ( 1 << j ) ) > 0 ) bit [ j ] -- ; } for ( let j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) bit [ j ] ++ ; } max_or = Math . max ( build_num ( bit ) , max_or ) ; } return max_or ; }
function build_num ( bit , k ) { let ans = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) if ( bit [ i ] == k ) ans += ( 1 << i ) ; return ans ; }
function minimumAND ( arr , n , k ) { let bit = new Array ( 32 ) ; bit . fill ( 0 ) ; for ( let i = 0 ; i < k ; i ++ ) { for ( let j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) bit [ j ] ++ ; } } let min_and = build_num ( bit , k ) ; for ( let i = k ; i < n ; i ++ ) { for ( let j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i - k ] & ( 1 << j ) ) > 0 ) bit [ j ] -- ; } for ( let j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) bit [ j ] ++ ; } min_and = Math . min ( build_num ( bit , k ) , min_and ) ; } return min_and ; }
function findMinXORSubarray ( arr , n , k ) { if ( n < k ) return ; let res_index = 0 ; let curr_xor = 0 ; for ( let i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; let min_xor = curr_xor ; for ( let i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } document . write ( min_xor ) ; }
function findmax ( arr , n , k ) { let trav , i ; let c = 0 , maximum = 0 ; for ( i = 0 ; i < n - k + 1 ; i ++ ) { trav = i - 1 ; c = 0 ; while ( trav >= 0 && arr [ trav ] == 1 ) { trav -- ; c ++ ; } trav = i + k ; while ( trav < n && arr [ trav ] == 1 ) { trav ++ ; c ++ ; } c += k ; if ( c > maximum ) maximum = c ; } return maximum ; }
function powerOfTwo ( a , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( a [ i ] ) ) { mp . set ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . set ( a [ i ] , 1 ) ; } } let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let f = false ; for ( let j = 0 ; j < 31 ; j ++ ) { let s = ( 1 << j ) - a [ i ] ; if ( mp . has ( s ) && ( mp . get ( s ) > 1 || mp . get ( s ) == 1 && s != a [ i ] ) ) f = true ; } if ( f == false ) count ++ ; } return count ; }
function maxDiff ( arr , n ) { var result = 0 ; arr . sort ( ( a , b ) => a - b )  for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; }
function findArray ( n , a , b , c ) { let arr = new Array ( n + 1 ) ; for ( let bit = 30 ; bit >= 0 ; bit -- ) { let set = a & ( 1 << bit ) ; if ( set ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] |= set ; } else { if ( b & ( 1 << bit ) ) { arr [ 0 ] |= ( 1 << bit ) ; if ( ! ( c & ( 1 << bit ) ) ) { arr [ 1 ] |= ( 1 << bit ) ; } } } } let aa = Number . MAX_SAFE_INTEGER , bb = 0 , cc = 0 ; for ( let i = 0 ; i < n ; i ++ ) { aa &= arr [ i ] ; bb |= arr [ i ] ; cc ^= arr [ i ] ; } if ( a == aa && b == bb && c == cc ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; } else document . write ( "-1" ) ; }
function countSubarray ( arr , K , N ) { if ( K % 2 != 0 ) return 0 ; if ( N < K ) return 0 ; var start = 0 ; var i = 0 ; var count = 0 ; var currXor = arr [ i ] ; i ++ ; while ( i < K ) { currXor ^= arr [ i ] ; i ++ ; } if ( currXor == 0 ) count ++ ; currXor ^= arr [ start ] ; start ++ ; while ( i < N ) { currXor ^= arr [ i ] ; i ++ ; if ( currXor == 0 ) count ++ ; currXor ^= arr [ start ] ; start ++ ; } return count ; }
function findLargestNumber ( arr ) { var k = arr . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var m = Array ( k ) . fill ( 0 ) ; arr . forEach ( n => { ++ m [ n ] ; } ) ; for ( var n = arr . length ; n > 0 ; -- n ) { if ( n == m [ n ] ) return n ; } return - 1 ; }
function maxDiff ( arr , n ) { let hashPositive = new Map ( ) ; let hashNegative = new Map ( ) ; let SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { if ( arr [ i ] > 0 ) { if ( hashPositive . has ( arr [ i ] ) ) { hashPositive . set ( arr [ i ] , hashPositive . get ( arr [ i ] ) + 1 ) ; } else { hashPositive . set ( arr [ i ] , 1 ) ; } } } for ( let i = 0 ; i <= n - 1 ; i ++ ) { if ( arr [ i ] > 0 && hashPositive . has ( arr [ i ] ) ) { if ( hashPositive . get ( arr [ i ] ) == 1 ) { SubsetSum_1 += arr [ i ] ; } } } for ( let i = 0 ; i <= n - 1 ; i ++ ) { if ( arr [ i ] < 0 ) { if ( hashNegative . has ( Math . abs ( arr [ i ] ) ) ) { hashNegative . set ( Math . abs ( arr [ i ] ) , hashNegative . get ( Math . abs ( arr [ i ] ) ) + 1 ) ; } else { hashNegative . set ( Math . abs ( arr [ i ] ) , 1 ) ; } } } for ( let i = 0 ; i <= n - 1 ; i ++ ) { if ( arr [ i ] < 0 && hashNegative . has ( Math . abs ( arr [ i ] ) ) ) { if ( hashNegative . get ( Math . abs ( arr [ i ] ) ) == 1 ) { SubsetSum_2 += arr [ i ] ; } } } return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ; }
function NoCarrySum ( N , M ) { return N ^ M ; }
function CheckBits ( N , K ) { var check = 0 ; var count = 0 ; for ( var i = 31 ; i >= 0 ; i -- ) { if ( ( ( 1 << i ) & N ) > 0 ) { if ( check == 0 ) { check = 1 ; } else { if ( count < K ) { return false ; } } count = 0 ; } else { count ++ ; } } return true ; }
function RecursiveFunction ( ref , bit ) { if ( ref . length == 0 bit < 0 ) return 0 ; let curr_on = [ ] , curr_off = [ ] ; for ( let i = 0 ; i < ref . length ; i ++ ) { if ( ( ( ref [ i ] >> bit ) & 1 ) == 0 ) curr_off . push ( ref [ i ] ) ; else curr_on . push ( ref [ i ] ) ; } if ( curr_off . length == 0 ) return RecursiveFunction ( curr_on , bit - 1 ) ; if ( curr_on . length == 0 ) return RecursiveFunction ( curr_off , bit - 1 ) ; return Math . min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ; }
function minimumFlips ( X , Y , Z ) { var res = 0 ; while ( X > 0 Y > 0 Z > 0 ) { if ( ( ( X & 1 ) || ( Y & 1 ) ) && ( Z & 1 ) ) { X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; continue ; } else if ( ( X & 1 ) == 0 && ( Y & 1 ) == 0 && ( Z & 1 ) ) { res ++ ; } else if ( ( X & 1 ) || ( Y & 1 ) == 1 ) { if ( ( X & 1 ) && ( Y & 1 ) && ( Z & 1 ) == 0 ) { res += 2 ; } else if ( ( ( X & 1 ) || ( Y & 1 ) ) && ( Z & 1 ) == 0 ) { res ++ ; } } X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; } return res ; }
function FlipBits ( n ) { return n -= ( n & ( - n ) ) ; }
function calculate ( section , pos ) { if ( pos < 0 ) return 0 ; let on_section = [ ] , off_section = [ ] ; for ( let el = 0 ; el < section . length ; el ++ ) { if ( ( ( section [ el ] >> pos ) & 1 ) == 0 ) off_section . push ( section [ el ] ) ; else on_section . push ( section [ el ] ) ; } if ( off_section . length == 0 ) return calculate ( on_section , pos - 1 ) ; if ( on_section . length == 0 ) return calculate ( off_section , pos - 1 ) ; return Math . min ( calculate ( off_section , pos - 1 ) , calculate ( on_section , pos - 1 ) ) + ( 1 << pos ) ; }
function minXorValue ( a , n ) { let section = [ ] ; for ( let i = 0 ; i < n ; i ++ ) section . push ( a [ i ] ) ; return calculate ( section , 30 ) ; }
function SieveOfEratosthenes ( prime ) { prime [ 1 ] = false ; prime [ 0 ] = false ; for ( let p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } }
function prime_xor ( arr , n , k ) { let prime = new Array ( MAX ) . fill ( true ) ; SieveOfEratosthenes ( prime ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { if ( ( i + 1 ) % k == 0 ) { ans ^= arr [ i ] ; } } } document . write ( ans ) ; }
function xorOfArray ( arr , n ) { let xor_arr = 0 ; for ( let i = 0 ; i < n ; i ++ ) { xor_arr = xor_arr ^ arr [ i ] ; } return xor_arr ; }
function countEvenBit ( A , B , n , m ) { let i , j , cntOdd = 0 , cntEven = 0 ; for ( i = 0 ; i < n ; i ++ ) { let x = bitCount ( A [ i ] ) ; if ( x & 1 ) { cntEven ++ ; } else { cntOdd ++ ; } } let CountB = new Array ( m ) ; for ( i = 0 ; i < m ; i ++ ) { let x = bitCount ( B [ i ] ) ; if ( x & 1 ) { CountB [ i ] = cntEven ; } else { CountB [ i ] = cntOdd ; } } for ( i = 0 ; i < m ; i ++ ) { document . write ( CountB [ i ] + "▁" ) ; } }
function isEven ( n ) { if ( n ^ 1 == n + 1 ) return true ; else return false ; }
function bitwiseOrTillN ( n ) { var result = 2 ; for ( var i = 4 ; i <= n ; i = i + 2 ) { result = result | i ; } return result ; }
function minRange ( arr , n , k ) { let l = 0 , r = n ; let j = - 1 ; let hm = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { while ( j < n ) { j ++ ; if ( j < n && hm . size < k ) { if ( hm . has ( arr [ j ] ) ) hm . set ( arr [ j ] , hm . get ( arr [ j ] ) + 1 ) ; else hm . set ( arr [ j ] , 1 ) ; } if ( hm . size == k && ( ( r - l ) >= ( j - i ) ) ) { l = i ; r = j ; break ; } } if ( hm . size < k ) break ; while ( hm . size == k ) { if ( hm . has ( arr [ i ] ) && hm . get ( arr [ i ] ) == 1 ) hm . delete ( arr [ i ] ) ; else if ( hm . has ( arr [ i ] ) ) hm . set ( arr [ i ] , hm . get ( arr [ i ] ) - 1 ) ; i ++ ; if ( hm . size == k && ( r - l ) >= ( j - i ) ) { l = i ; r = j ; } } if ( hm . has ( arr [ i ] ) && hm . get ( arr [ i ] ) == 1 ) hm . delete ( arr [ i ] ) ; else if ( hm . has ( arr [ i ] ) ) hm . set ( arr [ i ] , hm . get ( arr [ i ] ) - 1 ) ; } if ( l == 0 && r == n ) document . write ( "Invalid▁k" ) ; else document . write ( l + "▁" + r ) ; }
function bitwiseOrTillN ( n ) { if ( n < 2 ) return 0 ; var bitCount = parseInt ( Math . log2 ( n ) + 1 ) ; return Math . pow ( 2 , bitCount ) - 2 ; }
function bitwiseAndOdd ( n ) { var result = 1 ; for ( var i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }
function bitwiseAndOdd ( n ) { return 1 ; }
function construct_Xor_Tree_Util ( current , start , end , x ) { if ( start == end ) { xor_tree [ x ] = current [ start ] ; return ; } var left = x * 2 + 1 ; var right = x * 2 + 2 ; var mid = start + parseInt ( ( end - start ) / 2 ) ; construct_Xor_Tree_Util ( current , start , mid , left ) ; construct_Xor_Tree_Util ( current , mid + 1 , end , right ) ; xor_tree [ x ] = ( xor_tree [ left ] ^ xor_tree [ right ] ) ; }
function genSequence ( n , val ) { for ( let i = 0 ; i < ( 1 << n ) ; i ++ ) { let x = i ^ ( i >> 1 ) ^ val ; document . write ( x + "▁" ) ; } }
function check ( arr , n , m , d ) { var i = 0 ; while ( i < n && m > 0 ) { m -- ; i += d ; } return m == 0 ? true : false ; }
function maximumDistance ( arr , n , m ) { var low = 1 , high = n - 1 ; var ans = 0 ; while ( low <= high ) { var mid = parseInt ( ( low + high ) / 2 ) ; var flag = check ( arr , n , m , mid ) ; if ( flag ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; }
function minTrees ( n ) { let count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
function longest ( a , n , k ) { var freq = Array ( 7 ) . fill ( 0 ) ; var start = 0 , end = 0 , now = 0 , l = 0 ; for ( var i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( var i = start ; i <= end ; i ++ ) document . write ( a [ i ] + "▁" ) ; }
function extraElement ( A , B , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( let i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; }
function maxConsecutiveOnes ( x ) { var count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }
function maxOnes ( arr , n ) { var ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { var currMax = maxConsecutiveOnes ( arr [ i ] ) ; ans = Math . max ( ans , currMax ) ; } return ans ; }
function maxOR ( L , R ) { if ( L == R ) { return L ; } let ans = 0 ; for ( let i = MAX - 1 ; i >= 0 ; i -- ) { let p , lbit , rbit ; p = 1 << i ; if ( ( rbit == 1 ) && ( lbit == 0 ) ) { ans += ( p << 1 ) - 1 ; break ; } if ( rbit == 1 ) { ans += p ; } } return ans ; }
function findLen ( arr , n , m ) { var filter = [ ] ; for ( var i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & m ) == m ) filter . push ( arr [ i ] ) ; if ( filter . length == 0 ) return 0 ; var c_and = filter [ 0 ] ; for ( var i = 1 ; i < filter . length ; i ++ ) c_and &= filter [ i ] ; if ( c_and == m ) return filter . length ; return 0 ; }
function toggleBit ( n , k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
function clearBit ( n , k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; }
function getMinSteps ( K ) { return countSetBits ( K ) ; }
function sum ( a , n ) { var cnt = new Map ( ) ; var ans = 0 , pre_sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { ans += ( i * a [ i ] ) - pre_sum ; pre_sum += a [ i ] ; if ( cnt . has ( a [ i ] - 1 ) ) ans -= cnt . get ( a [ i ] - 1 ) ; if ( cnt . has ( a [ i ] + 1 ) ) ans += cnt . get ( a [ i ] + 1 ) ; if ( cnt . has ( a [ i ] ) ) cnt . set ( a [ i ] , cnt . get ( a [ i ] ) + 1 ) else cnt . set ( a [ i ] , 1 ) } return ans ; }
function cntElements ( arr , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; }
function xor_triplet ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = j ; k < n ; k ++ ) { let xor1 = 0 , xor2 = 0 ; for ( let x = i ; x < j ; x ++ ) { xor1 ^= arr [ x ] ; } for ( let x = j ; x <= k ; x ++ ) { xor2 ^= arr [ x ] ; } if ( xor1 == xor2 ) { ans ++ ; } } } } return ans ; }
function findSubarray ( array , n ) { var mp = new Map ( ) ; mp . set ( 0 , 1 ) ; var answer = 0 ; var preXor = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var value = 1 ; preXor ^= array [ i ] ; for ( var j = 1 ; j <= MAX ; j ++ ) { var Y = value ^ preXor ; if ( mp . has ( Y ) ) { answer += mp . get ( Y ) ; } value *= 2 ; } if ( mp . has ( preXor ) ) { mp . set ( preXor , mp . get ( preXor ) + 1 ) ; } else { mp . set ( preXor , 1 ) ; } } return answer ; }
function max_xor ( arr , n ) { let maxXor = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { maxXor = Math . max ( maxXor , arr [ i ] ^ arr [ j ] ) ; } } return maxXor ; }
function CountTriplets ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let first = arr [ i ] ; for ( let j = i + 1 ; j < n ; j ++ ) { first ^= arr [ j ] ; if ( first == 0 ) ans += ( j - i ) ; } } return ans ; }
function findMajority ( arr , n ) { let len = 32 ; let number = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let countt = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countt ++ ; } if ( countt > parseInt ( n / 2 , 10 ) ) number += ( 1 << i ) ; } let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == number ) count ++ ; if ( count > parseInt ( n / 2 , 10 ) ) document . write ( number ) ; else document . write ( "Majority▁Element▁Not▁Present" ) ; }
function countBits ( a , b ) { var count = 0 ; while ( a b ) { var last_bit_a = a & 1 ; var last_bit_b = b & 1 ; if ( last_bit_a != last_bit_b ) count ++ ; a = a >> 1 ; b = b >> 1 ; } return count ; }
function CountSetBits ( n ) { if ( n == 0 ) return 0 ; if ( ( n & 1 ) == 1 ) return 1 + CountSetBits ( n >> 1 ) ; else return CountSetBits ( n >> 1 ) ; }
function calculate ( bit_cnt ) { let res = 1 ; while ( bit_cnt -- ) { res = res * 3 ; } return res ; }
function unset_bit_count ( n ) { let count = 0 ; while ( n ) { if ( ( n & 1 ) == 0 ) count ++ ; n = n >> 1 ; } return count ; }
function bit_q ( i , j ) { let sum = 0 ; while ( j > 0 ) { sum += bit [ j ] ; j -= ( j & ( j * - 1 ) ) ; } i -- ; while ( i > 0 ) { sum -= bit [ i ] ; i -= ( i & ( i * - 1 ) ) ; } return sum ; }
function bit_up ( i , diff ) { while ( i <= n ) { bit [ i ] += diff ; i += i & - i ; } }
function initialise ( ) { Ideal_pair = 0 ; for ( let i = 0 ; i <= n ; i ++ ) { root_node [ i ] = true ; bit [ i ] = 0 ; } }
function Idealpairs ( ) { let r = - 1 ; for ( let i = 1 ; i <= n ; i ++ ) if ( root_node [ i ] ) { r = i ; break ; } dfs ( r ) ; return Ideal_pair ; }
function pairORSum ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }
function solve ( A , B , n ) { var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i ; j < n ; j ++ ) { if ( countSetBits ( A [ i ] & A [ j ] ) == B [ j ] ) { cnt ++ ; } } } return cnt ; }
function multiplyByFifteen ( n ) { var prod = ( n << 3 ) ; prod += ( n << 2 ) ; prod += ( n << 1 ) ; prod += n ; return prod ; }
function balTernary ( ter ) { let carry = 0 , base = 10 ; let i = 32 ; while ( ter > 0 ) { let rem = ter % base ; rem = rem + carry ; if ( rem == 0 ) { arr [ i -- ] = 0 ; carry = 0 ; } else if ( rem == 1 ) { arr [ i -- ] = 1 ; carry = 0 ; } else if ( rem == 2 ) { arr [ i -- ] = - 1 ; carry = 1 ; } else if ( rem == 3 ) { arr [ i -- ] = 0 ; carry = 1 ; } ter = Math . floor ( ter / base ) ; } if ( carry == 1 ) arr [ i ] = 1 ; }
function isDefeat ( s1 , s2 , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == "0" && s2 [ i ] == "1" ) || ( s1 [ i ] == "1" && s2 [ i ] == "0" ) ) continue ; else if ( ( s1 [ i ] == "0" && s2 [ i ] == "Z" ) || ( s1 [ i ] == "Z" && s2 [ i ] == "0" ) ) continue ; else { return true ; } } return false ; }
function check ( a , b ) { for ( i = 1 ; i < N ; i ++ ) { for ( j = 1 ; j < M ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) { a [ i ] [ j ] ^= 1 ; a [ 0 ] [ 0 ] ^= 1 ; a [ 0 ] [ j ] ^= 1 ; a [ i ] [ 0 ] ^= 1 ; } } } for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) return false ; } } return true ; }
function FindIndexKthBit ( n , k ) { let cnt = 0 ; let ind = 0 ; while ( n > 0 ) { if ( n & 1 > 0 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return - 1 ; }
function check ( a , n ) { for ( var i = 0 ; i < n ; i ++ ) if ( a [ i ] ) return true ; return false ; }
function printArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function findArray ( q , n ) { let arr = new Array ( n ) , ans ; for ( let k = 0 , j = 0 ; j < parseInt ( n / 4 ) ; j ++ ) { ans = q [ k ] ^ q [ k + 3 ] ; arr [ k + 1 ] = q [ k + 1 ] ^ ans ; arr [ k + 2 ] = q [ k + 2 ] ^ ans ; arr [ k ] = q [ k ] ^ ( ( arr [ k + 1 ] ) ^ ( arr [ k + 2 ] ) ) ; arr [ k + 3 ] = q [ k + 3 ] ^ ( arr [ k + 1 ] ^ arr [ k + 2 ] ) ; k += 4 ; } printArray ( arr , n ) ; }
function countX ( n ) { let binary = ( n >>> 0 ) . toString ( 2 ) ; let count = 0 ; for ( let i = 0 ; i < binary . length ; i ++ ) { if ( binary [ i ] == "1" ) count ++ ; } let answer = Math . floor ( Math . pow ( 2 , count ) ) ; return answer ; }
function binToDecimal3 ( n ) { var a = Array ( 64 ) . fill ( 0 ) ; var x = 0 , i ; for ( i = 0 ; n > 0 ; i ++ ) { a [ i ] = n % 2 ; n = parseInt ( n / 2 ) ; } x = ( i < 3 ) ? 3 : i ; var d = 0 , p = 0 ; for ( var i = x - 3 ; i < x ; i ++ ) d += a [ i ] * parseInt ( Math . pow ( 2 , p ++ ) ) ; document . write ( d + "▁" ) ; d = 0 ; p = 0 ; for ( var i = 0 ; i < 3 ; i ++ ) d += a [ i ] * parseInt ( Math . pow ( 2 , p ++ ) ) ; document . write ( d ) ; }
function binToDecimal3 ( n ) { var last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; var first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; document . write ( first_3 + "▁" + last_3 ) ; }
function nextPowerOf2 ( n ) { let p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
function memoryUsed ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; let nearest = nextPowerOf2 ( sum ) ; return nearest ; }
function isPowerOfTwo ( x ) { if ( x == 0 ) return false ; if ( ( x & ( x - 1 ) ) == 0 ) return true ; else return false ; }
function countNum ( a , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) || isPowerOfTwo ( a [ i ] + 1 ) ) count ++ ; } return count ; }
function checkEvenParity ( x ) { let parity = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; parity ++ ; } if ( parity % 2 == 0 ) return true ; else return false ; }
function sumlist ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( checkEvenParity ( a [ i ] ) ) sum += a [ i ] ; } return sum ; }
function minDistance ( n1 , n2 ) { var bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; var bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; var bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; var maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } var xorValue = n1 ^ n2 ; var bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; } var disSimilarBitPosition = maxBitCount - bitCountXorValue ; var result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; }
function findOddPair ( A , N ) { let oddPair = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
function countOddPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ! ( A [ i ] & 1 ) ) count ++ ; let evenPairCount = parseInt ( count * ( count - 1 ) / 2 ) ; let totPairs = parseInt ( N * ( N - 1 ) / 2 ) ; return totPairs - evenPairCount ; }
function findevenPair ( A , N ) { let i , j ; let evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] ^ A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }
function findEvenPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 != 0 ) count ++ ; } let totalPairs = parseInt ( N * ( N - 1 ) / 2 ) ; let oddEvenPairs = count * ( N - count ) ; return totalPairs - oddEvenPairs ; }
function findevenPair ( A , N ) { let i , j ; let evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }
function calculate ( X ) { let number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }
function alternate ( a , b , x ) { return x = a ^ b ^ x ; }
function countZeros ( x ) { let total_bits = sizeofInt * 8 ; let res = 0 ; while ( ( x & ( 1 << ( total_bits - 1 ) ) ) == 0 ) { x = ( x << 1 ) ; res ++ ; } return res ; }
function countZeros ( x ) { let y ; let n = 32 ; y = x >> 16 ; if ( y != 0 ) { n = n - 16 ; x = y ; } y = x >> 8 ; if ( y != 0 ) { n = n - 8 ; x = y ; } y = x >> 4 ; if ( y != 0 ) { n = n - 4 ; x = y ; } y = x >> 2 ; if ( y != 0 ) { n = n - 2 ; x = y ; } y = x >> 1 ; if ( y != 0 ) return n - 2 ; return n - x ; }
function LeadingZeros ( x , y ) { if ( ( x ^ y ) <= ( x & y ) ) document . write ( "Equal" ) ; else if ( ( x & ( ~ y ) ) > y ) document . write ( y ) ; else document . write ( x ) ; }
function subset ( nthBit , num , numOfBits ) { if ( nthBit >= 0 ) { if ( num & ( 1 << nthBit ) ) { document . write ( numOfBits - nthBit + "▁" ) ; } subset ( nthBit - 1 , num , numOfBits ) ; } else return ; }
function solve ( A , B ) { var count = 0 ; for ( i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } document . write ( "Number▁of▁different▁bits▁:▁" + count ) ; }
function countSubarrWithEqualZeroAndOne ( arr , n ) { var um = new Map ( ) ; var curr_sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { curr_sum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ] ; if ( um . has ( curr_sum ) ) um . set ( curr_sum , um . get ( curr_sum ) + 1 ) ; else um . set ( curr_sum , 1 ) } var count = 0 ; um . forEach ( ( value , key ) => { if ( value > 1 ) count += ( ( value * ( value - 1 ) ) / 2 ) ; } ) ; if ( um . has ( 0 ) ) count += um . get ( 0 ) ; return count ; }
function setRightmostUnsetBit ( n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; }
function OR ( a , n ) { var ans = a [ 0 ] ; for ( var i = 1 ; i < n ; ++ i ) ans |= a [ i ] ; return ans ; }
function hammingDistance ( n1 , n2 ) { let x = n1 ^ n2 ; let setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; }
function isKthBitSet ( n , k ) { if ( ( n >> ( k - 1 ) ) & 1 ) return true ; return false ; }
function setKthBit ( n , k ) { return ( ( 1 << ( k - 1 ) ) n ) ; }
function allBitsAreSet ( n ) { if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; }
function bitsAreInAltOrder ( n ) { var num = n ^ ( n >> 1 ) ; return allBitsAreSet ( num ) ; }
function bitsAreInAltPatrnInGivenRange ( n , l , r ) { var num , left_shift ; if ( isKthBitSet ( n , r ) ) { num = n ; left_shift = r ; } else { num = setKthBit ( n , ( r + 1 ) ) ; left_shift = r + 1 ; } num = num & ( ( 1 << left_shift ) - 1 ) ; num = num >> ( l - 1 ) ; return bitsAreInAltOrder ( num ) ; }
function findParity ( x ) { let y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( y & 1 ) return 1 ; return 0 ; }
function bit ( n ) { let count = 0 ; while ( n > 0 ) { count ++ ; n = n & ( n - 1 ) ; } return count ; }
function maxSumOfBits ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { arr [ i ] = bit ( arr [ i ] ) ; } let incl = arr [ 0 ] ; let excl = 0 ; let excl_new ; for ( let i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; }
function increment ( i ) { i = - ( ~ i ) ; return i ; }
function increment ( i ) { let i1 = - ( ~ ( i ) . charCodeAt ( ) ) ; return String . fromCharCode ( i1 ) ; }
function MakePreSum ( arr , presum , n ) { presum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) presum [ i ] = presum [ i - 1 ] + arr [ i ] ; }
function lenOfLongSubarr ( arr , n ) { var um = new Map ( ) ; var sum = 0 , maxLen = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . has ( sum ) ) um . set ( sum , i ) ; if ( um . has ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; }
function bit_count ( n ) { var count = 0 ; while ( n ) { count ++ ; n = n & ( n - 1 ) ; } return count ; }
function maxsum ( arr , n ) { var bits = Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { bits [ i ] = bit_count ( arr [ i ] ) ; } var sum = Array ( 32 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { sum [ bits [ i ] ] += arr [ i ] ; } var maximum = 0 ; for ( var i = 0 ; i < 32 ; i ++ ) { maximum = Math . max ( sum [ i ] , maximum ) ; } return maximum ; }
function findOddPair ( A , N ) { let i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }
function allBitsSetInTheGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; var new_num = n & num ; if ( num == new_num ) return true ; return false ; }
function bitsAreComplement ( a , b , l , r ) { var xor_value = a ^ b ; return allBitsSetInTheGivenRange ( xor_value , l , r ) ; }
function allBitsSetInTheGivenRange ( n , l , r ) { let num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; let new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
function checkSame ( n ) { let set = 0 , unset = 0 ; while ( n ) { if ( n & 1 ) set ++ ; else unset ++ ; n = n >> 1 ; } if ( set == unset ) return true ; else return false ; }
function isBalanced ( s ) { let st = [ ] ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == "(" ) { st . push ( s [ i ] ) ; } else if ( st . length == 0 ) { return false ; } else { st . pop ( ) ; } } if ( st . length != 0 ) { return false ; } return true ; }
function isBalancedSeq ( s1 , s2 ) { if ( isBalanced ( s1 + s2 ) ) { return true ; } return isBalanced ( s2 + s1 ) ; }
function KthCharacter ( m , n , k ) { let distance = Math . pow ( 2 , n ) ; let Block_number = Math . floor ( k / distance ) ; let remaining = k % distance ; let s = new Array ( 32 ) . fill ( 0 ) ; let x = 0 ; for ( ; m > 0 ; x ++ ) { s [ x ] = m % 2 ; m = Math . floor ( m / 2 ) ; } let root = s [ x - 1 - Block_number ] ; if ( remaining == 0 ) { document . write ( root ) ; return ; } let flip = true ; while ( remaining > 1 ) { if ( ( remaining & 1 ) > 0 ) { flip = ! flip ; } remaining = remaining >> 1 ; } if ( flip ) { document . write ( ( root > 0 ) ? 0 : 1 ) ; } else { document . write ( root ) ; } }
function MSBPosition ( N ) { let msb_p = - 1 ; while ( N > 0 ) { N = N >> 1 ; msb_p ++ ; } return msb_p ; }
function findBitwiseOR ( L , R ) { let res = 0 ; let msb_p1 = MSBPosition ( L ) ; let msb_p2 = MSBPosition ( R ) ; while ( msb_p1 == msb_p2 ) { let res_val = ( 1 << msb_p1 ) ; res += res_val ; L -= res_val ; R -= res_val ; msb_p1 = MSBPosition ( L ) ; msb_p2 = MSBPosition ( R ) ; } msb_p1 = Math . max ( msb_p1 , msb_p2 ) ; for ( let i = msb_p1 ; i >= 0 ; i -- ) { let res_val = ( 1 << i ) ; res += res_val ; } return res ; }
function getInteger ( L , R ) { var number = 0 ; for ( var i = L ; i <= R ; i ++ ) number += Math . pow ( 2 , i ) ; return number ; }
function maxOR ( arr , n , k , x ) { let preSum = new Array ( n + 1 ) ; let suffSum = new Array ( n + 1 ) ; let res = 0 , pow = 1 ; for ( let i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = Math . max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; }
function findXor ( arr , n ) { let xoR = 0 ; for ( let i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; } return xoR * 2 ; }
function turnOnK ( n , k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
function setBitwiseORk ( n ) { var v = [ ] ; for ( var i = 0 ; i <= n ; i ++ ) { if ( ( i n ) == n ) v . push ( i ) ; } for ( var i = 0 ; i < v . length ; i ++ ) document . write ( v [ i ] + "▁" ) ; }
function smallerNumsWithSameSetBits ( n ) { var temp = __builtin_popcount ( n ) ; var count = 0 ; for ( var i = n - 1 ; i > 0 ; i -- ) { if ( temp == __builtin_popcount ( i ) ) count ++ ; } return count ; }
function findEletobeInserted ( A , n , k ) { var ans = k ; for ( var i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; return ans ; }
function andSum ( arr , n ) { var ans = 0 ; for ( i = 0 ; i < BITS ; i ++ ) { var countSetBits = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countSetBits ++ ; } var subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; }
function Root ( idx ) { let i = idx ; while ( i != id [ i ] ) { id [ i ] = id [ id [ i ] ] ; i = id [ i ] ; } return i ; }
function Union ( a , b ) { let i = Root ( a ) , j = Root ( b ) ; if ( i != j ) { if ( sz [ i ] >= sz [ j ] ) { id [ j ] = i ; sz [ i ] += sz [ j ] ; sz [ j ] = 0 ; } else { id [ i ] = j ; sz [ j ] += sz [ i ] ; sz [ i ] = 0 ; } } }
function UnionUtil ( e , W , q ) { for ( let i = 0 ; i < q ; i ++ ) { let u , v ; u = e [ i ] [ 0 ] ; v = e [ i ] [ 1 ] ; u -- ; v -- ; if ( W [ u ] % 2 == 0 && W [ v ] % 2 == 0 ) Union ( u , v ) ; } }
function findMax ( n , W ) { let maxi = 0 ; for ( let i = 1 ; i < n ; i ++ ) if ( W [ i ] % 2 == 0 ) maxi = Math . max ( maxi , sz [ i ] ) ; return maxi ; }
function countSetBits ( n ) { var count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
function multiplyWith4 ( n ) { return ( n << 2 ) ; }
function isEven ( n ) { let isEven = true ; for ( let i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; }
function isEven ( n ) { return ( parseInt ( n / 2 , 10 ) * 2 == n ) ; }
function checkValidPair ( num1 , num2 ) { var s1 = num1 . toString ( ) ; var s2 = num2 . toString ( ) ; var i , j ; for ( i = 0 ; i < s1 . length ; i ++ ) for ( j = 0 ; j < s2 . length ; j ++ ) if ( s1 [ i ] == s2 [ j ] ) return true ; return false ; }
function countPairs ( arr , n ) { var numberOfPairs = 0 ; for ( i = 0 ; i < n ; i ++ ) for ( j = i + 1 ; j < n ; j ++ ) if ( checkValidPair ( arr [ i ] , arr [ j ] ) ) numberOfPairs ++ ; return numberOfPairs ; }
function countSetBits ( n ) { let count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
function isPowerOf2 ( num ) { return ( num && ! ( num & ( num - 1 ) ) ) ; }
function checkSubsequence ( arr , n ) { if ( n == 1 ) return isPowerOf2 ( arr [ 0 ] ) ; var total = 0 ; for ( var i = 0 ; i < NUM_BITS ; i ++ ) total = total | ( 1 << i ) ; for ( var i = 0 ; i < NUM_BITS ; i ++ ) { var ans = total ; for ( var j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & ( 1 << i ) ) ans = ans & arr [ j ] ; } if ( isPowerOf2 ( ans ) ) return true ; } return false ; }
function getMid ( s , e ) { return s + Math . floor ( ( e - s ) / 2 ) ; }
function constructSTUtil ( arr , ss , se , st , si , operation ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return ; } let mid = getMid ( ss , se ) ; constructSTUtil ( arr , ss , mid , st , si * 2 + 1 , ! operation ) ; constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 , ! operation ) ; if ( operation ) { st [ si ] = ( st [ 2 * si + 1 ] st [ 2 * si + 2 ] ) ; } else { st [ si ] = ( st [ 2 * si + 1 ] ^ st [ 2 * si + 2 ] ) ; } }
function constructTree ( low , high , pos , a ) { if ( low == high ) { level [ pos ] = 0 ; tree [ pos ] = a [ high ] ; return ; } let mid = parseInt ( ( low + high ) / 2 , 10 ) ; constructTree ( low , mid , 2 * pos + 1 , a ) ; constructTree ( mid + 1 , high , 2 * pos + 2 , a ) ; level [ pos ] = level [ 2 * pos + 1 ] + 1 ; if ( ( level [ pos ] & 1 ) > 0 ) tree [ pos ] = tree [ 2 * pos + 1 ] | tree [ 2 * pos + 2 ] ; else tree [ pos ] = tree [ 2 * pos + 1 ] ^ tree [ 2 * pos + 2 ] ; }
function update ( low , high , pos , index , a ) { if ( low == high && low == index ) { tree [ pos ] = a [ low ] ; return ; } if ( index < low index > high ) return ; if ( low != high ) { let mid = parseInt ( ( low + high ) / 2 , 10 ) ; update ( low , mid , 2 * pos + 1 , index , a ) ; update ( mid + 1 , high , 2 * pos + 2 , index , a ) ; if ( ( level [ pos ] & 1 ) > 0 ) tree [ pos ] = tree [ 2 * pos + 1 ] | tree [ 2 * pos + 2 ] ; else tree [ pos ] = tree [ 2 * pos + 1 ] ^ tree [ 2 * pos + 2 ] ; } }
function updateValue ( index , value , a , n ) { a [ index ] = value ; update ( 0 , n - 1 , 0 , index , a ) ; static public void Main ( ) { }
function maxXOR ( n , k ) { let c = ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << c ) - 1 ) ; }
function divide ( dividend , divisor ) { var sign = ( ( dividend < 0 ) ? 1 : 0 ^ ( divisor < 0 ) ? 1 : 0 ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; var quotient = 0 , temp = 0 ; while ( dividend >= divisor ) { dividend -= divisor ; ++ quotient ; } if ( sign == - 1 ) quotient = - quotient ; return quotient ; }
function count ( n ) { let c = 0 ; while ( n != 0 ) { c ++ ; n = n >> 1 ; } return c ; }
function swapBitsInPair ( x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; }
function evenbitsetnumber ( n ) { let count = 0 , res = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
function getmsb ( n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( n + 1 ) >> 1 ; }
function getevenbits ( n ) { n = getmsb ( n ) ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; if ( ( n & 1 ) == 1 ) n = n >> 1 ; return n ; }
function setallevenbits ( n ) { return n | getevenbits ( n ) ; }
function getmsb ( n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( n + 1 ) >> 1 ; }
function getevenbits ( n ) { n = getmsb ( n ) ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; if ( ( n & 1 ) == 0 ) n = n >> 1 ; return n ; }
function setalloddbits ( n ) { return n | getevenbits ( n ) ; }
function setevenbits ( n ) { var temp = n ; var count = 0 ; var res = 0 ; for ( temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n & res ) ; }
function setoddbits ( m ) { var count = 0 ; var res = 0 ; for ( temp = m ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( m & res ) ; }
function getAlternateBits ( n , m ) { var tempn = setevenbits ( n ) ; var tempm = setoddbits ( m ) ; return ( tempn tempm ) ; }
function takeLandFsetbits ( n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( ( n + 1 ) >> 1 ) + 1 ; }
function toggleFandLbits ( n ) { if ( n == 1 ) return 0 ; return n ^ takeLandFsetbits ( n ) ; }
function countSetBits ( n ) { let count = 0 ; while ( n != 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
function checkOdious ( n ) { return ( countSetBits ( n ) % 2 == 1 ) ; }
function setleftmostunsetbit ( n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; let pos = 0 ; for ( let temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; }
function getPosOfRightmostSetBit ( n ) { return ( Math . log ( n & - n ) / Math . log ( 2 ) ) ; }
function toggleLastKBits ( n , k ) { let num = ( 1 << k ) - 1 ; return ( n ^ num ) ; }
function incrementByOne ( n ) { let k = getPosOfRightmostSetBit ( ~ n ) ; n = ( ( 1 << k ) n ) ; if ( k != 0 ) n = toggleLastKBits ( n , k ) ; return n ; }
function printNumHavingAltBitPatrn ( n ) { var curr_num = 1 ; document . write ( curr_num + "▁" ) ; while ( true ) { curr_num <<= 1 ; if ( n < curr_num ) break ; document . write ( curr_num + "▁" ) ; curr_num = ( ( curr_num ) << 1 ) ^ 1 ; if ( n < curr_num ) break ; document . write ( curr_num + "▁" ) ; } }
function xnor ( a , b ) { if ( a < b ) { let t = a ; a = b ; b = t ; } if ( a == 0 && b == 0 ) return 1 ; let a_rem = 0 ; let b_rem = 0 ; let count = 0 ; let xnornum = 0 ; while ( true ) { a_rem = a & 1 ; b_rem = b & 1 ; if ( a_rem == b_rem ) xnornum |= ( 1 << count ) ; count ++ ; a = a >> 1 ; b = b >> 1 ; if ( a < 1 ) break ; } return xnornum ; }
function togglebit ( n ) { if ( n == 0 ) return 1 ; let i = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return i ^ n ; }
function MaximumSum ( a , b , n ) { let sum1 = 0 , sum2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } document . write ( sum1 + sum2 ) ; }
function posOfCarryBit ( a , b ) { return posOfRightmostSetBit ( a & b ) ; }
function isPowerOfTwo ( x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
function differAtOneBitPos ( a , b ) { return isPowerOfTwo ( a ^ b ) ; }
function power2 ( n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 2 ; return power2 ( n / 2 ) * power2 ( n / 2 ) ; }
function multiply ( x , n ) { return x * power2 ( n ) ; }
function multiply ( x , n ) { return x << n ; }
function isDivBy2PowerM ( n , m ) { if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ; return false ; }
function findWinner ( N ) { return N & 1 ; }
function wrapper ( arr , n , l , r , q ) { let prefodd = [ ] ; let prefeven = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) { if ( ( i ) % 2 == 0 ) { prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ; } else { prefeven [ i ] = prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] ; } } let i = 0 ; while ( i != q ) { ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) ; i ++ ; } }
function countgroup ( a , n ) { var xs = 0 ; for ( var i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; }
function perfectPowerOf2 ( n ) { let per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; }
function solve ( p , n ) { let G = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( p [ i ] % 2 != 0 ) G ^= ( p [ i ] + 1 ) ; else G ^= ( p [ i ] - 1 ) ; } return G ; }
function isDivisibleby17 ( n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( Math . floor ( n >> 4 ) - Math . floor ( n & 15 ) ) ; }
function answer ( n ) { let m = 2 ; let ans = 1 ; let r = 1 ; while ( r < n ) { r = ( Math . pow ( 2 , m ) - 1 ) * ( Math . pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }
function maxAND ( arr , n ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) res = Math . max ( res , arr [ i ] & arr [ j ] ) ; return res ; }
function checkBit ( pattern , arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; }
function index ( i ) { return 1 + ( i >> 31 ) - ( - i >> 31 ) ; }
function countPairs ( arr , n ) { let hm = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( hm . has ( arr [ i ] ) ) hm . set ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ; else hm . set ( arr [ i ] , 1 ) ; } let ans = 0 ; for ( let [ key , value ] of hm . entries ( ) ) { let count = value ; ans += ( count * ( count - 1 ) ) / 2 ; } return ans ; }
function countones ( n ) { let c = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; c ++ ; } return c ; }
function checking ( s ) { let c = 0 ; let n = s . length ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == "0" ) c ++ ; if ( c >= 6 && s [ i ] == "1" ) return true ; } return false ; }
function countSetBitsInGivenRange ( n , l , r ) { let num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return countSetBits ( n & num ) ; }
function areAllBitsSet ( n ) { if ( n == 0 ) return false ; if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; }
function findUnique ( a , n , k ) { let sizeof_let = 4 ; let LET_SIZE = 8 * sizeof_let ; let count = Array . from ( { length : LET_SIZE } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; let res = 0 ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
function powerOfTwo ( n ) { return ( ! ( n & n - 1 ) ) ; }
function onlyFirstAndLastAreSet ( n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return powerOfTwo ( n - 1 ) ; }
function allBitsAreSet ( n ) { if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; }
function bitsAreInAltOrder ( n ) { let num = n ^ ( n >>> 1 ) ; return allBitsAreSet ( num ) ; }
function setBit ( xorValue ) { var count = 0 ; while ( xorValue ) { if ( xorValue % 2 ) count ++ ; xorValue = parseInt ( xorValue / 2 ) ; } return count ; }
function minFlip ( n , k ) { var size = Math . log2 ( n ) + 1 ; var max = Math . pow ( 2 , k ) - 1 ; max = ( max << ( size - k ) ) ; var xorValue = ( n ^ max ) ; return ( setBit ( xorValue ) ) ; }
function setallbitgivenrange ( n , l , r ) { let range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; }
function countBits ( number ) { return Math . floor ( Math . log2 ( number ) + 1 ) ; }
function setBitNumber ( n ) { if ( n == 0 ) return 0 ; let msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = $n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
function setAllBitsAfterMSB ( n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; }
function toggle ( n ) { n = n ^ setAllBitsAfterMSB ( n ) ; return n ; }
function checkPowerof8 ( n ) { let i = Math . log ( n ) / Math . log ( 8 ) ; return ( i - Math . floor ( i ) < 0.000001 ) ; }
function adjacentSet ( n ) { let x = ( n & ( n >> 1 ) ) ; if ( x > 0 ) return true ; else return false ; }
function getRightMostSetBit ( n ) { return Math . log2 ( n & - n ) + 1 ; }
function posOfRightMostSameBit ( m , n ) { return getRightMostSetBit ( ~ ( m ^ n ) ) ; }
function printNonConsecutive ( n ) { let p = ( 1 << n ) ; for ( let i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) document . write ( i + "▁" ) ; }
function isKthBitSet ( x , k ) { return ( ( x & ( 1 << ( k - 1 ) ) ) > 0 ) ? 1 : 0 ; }
function leftmostSetBit ( x ) { let count = 0 ; while ( x > 0 ) { count ++ ; x = x >> 1 ; } return count ; }
function isBinPalindrome ( x ) { let l = leftmostSetBit ( x ) ; let r = 1 ; while ( l > r ) { if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) return 0 ; l -- ; r ++ ; } return 1 ; }
function findNthPalindrome ( n ) { let pal_count = 0 ; let i = 0 ; for ( i = 1 ; i <= INT_MAX ; i ++ ) { if ( isBinPalindrome ( i ) > 0 ) { pal_count ++ ; } if ( pal_count == n ) break ; } return i ; }
function convertStringToInt ( s ) { let ans = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == "0" ) ans += 1 << i ; } return ans ; }
function getNthNumber ( n ) { let q = [ ] ; if ( n == 1 ) return 1 ; n = n - 1 ; q . push ( "11" ) ; while ( n -- > 0 ) { let curr = q . shift ( ) ; if ( n == 0 ) return convertStringToInt ( curr ) ; let len = curr . length ; let len2 = Math . floor ( len / 2 ) ; if ( len % 2 == 0 ) { q . push ( curr . substring ( 0 , len2 ) + "0" + curr . substring ( len2 ) ) ; q . push ( curr . substring ( 0 , len2 ) + "1" + curr . substring ( len2 ) ) ; } else { let midChar = curr [ len2 ] ; q . push ( curr . substring ( 0 , len2 ) + midChar + curr . substring ( len2 ) ) ; } } return - 1 ; }
function constructNthNumber ( group_no , aux_num , op ) { var a = Array . from ( { length : INT_SIZE } , ( _ , i ) => 0 ) ; var num = 0 , len_f = 0 ; var i = 0 ; if ( op == 2 ) { len_f = 2 * group_no ; a [ len_f - 1 ] = a [ 0 ] = 1 ; while ( aux_num > 0 ) { a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else if ( op == 0 ) { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 0 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 1 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } for ( i = 0 ; i < len_f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; }
function getNthNumber ( n ) { var group_no = 0 , group_offset ; var count_upto_group = 0 , count_temp = 1 ; var op , aux_num ; while ( count_temp < n ) { group_no ++ ; count_upto_group = count_temp ; count_temp += 3 * ( 1 << ( group_no - 1 ) ) ; } group_offset = n - count_upto_group - 1 ; if ( ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) ) { op = 2 ; aux_num = group_offset ; } else { if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 == 1 ) op = 0 ; else op = 1 ; aux_num = ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) / 2 ; } return constructNthNumber ( group_no , aux_num , op ) ; }
function shuffle ( N , key ) { let NO_OF_BITS = N ; let reverse_num = 0 , temp ; for ( let i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( key & ( 1 << i ) ) ; if ( temp > 0 ) reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) ; } document . write ( reverse_num ) ; }
function bitExtracted ( number , k , p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }
function areSame ( a , b ) { if ( ( a - b ) == 0 ) document . write ( "Same" ) ; else document . write ( "Not▁Same" ) ; }
function countSetBits ( n ) { let count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
function findSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) if ( countSetBits ( i ) == 2 ) sum += i ; return sum ; }
function findSum ( n ) { let sum = 0 ; for ( let i = 1 ; 1 << i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { let num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; }
function findMax ( num ) { let num_copy = num ; let j = 4 * 8 - 1 ; let i = 0 ; while ( i < j ) { let m = ( num_copy >> i ) & 1 ; let n = ( num_copy >> j ) & 1 ; if ( m > n ) { let x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; }
function toggleLastMBits ( n , m ) { var num = ( 1 << m ) - 1 ; return ( n ^ num ) ; }
function getPosOfRightmostSetBit ( n ) { return ( ( Math . log10 ( n & - n ) ) / ( Math . log10 ( 2 ) ) ) + 1 ; }
function setRightmostUnsetBit ( n ) { if ( n == 0 ) return 1 ; if ( ( n & ( n + 1 ) ) == 0 ) return n ; let pos = getPosOfRightmostSetBit ( ~ n ) ; return ( ( 1 << ( pos - 1 ) ) n ) ; }
function previousSmallerInteger ( n ) { var pos = getFirstSetBitPos ( n ) ; return ( n & ~ ( 1 << ( pos - 1 ) ) ) ; }
function getRightMostSetBit ( n ) { if ( n == 0 ) return 0 ; return Math . log2 ( n & - n ) + 1 ; }
function posOfRightMostDiffBit ( m , n ) { return getRightMostSetBit ( m ^ n ) ; }
function posOfRightMostDiffBit ( m , n ) { return parseInt ( Math . floor ( Math . log10 ( Math . pow ( m ^ n , 2 ) ) ) , 10 ) + 2 ; }
function getFirstSetBitPos ( n ) { return ( parseInt ( Math . log ( n & - n ) / Math . log ( 2 ) ) + 1 ) - 1 ; }
function nextGreaterWithOneMoreSetBit ( n ) { var pos = getFirstSetBitPos ( ~ n ) ; if ( pos > - 1 ) return ( 1 << pos ) | n ; return ( ( n << 1 ) + 1 ) ; }
function setKthBit ( n , k ) { return ( ( 1 << k ) n ) ; }
function getNext ( n ) { let c = n ; let c0 = 0 ; let c1 = 0 ; while ( ( ( c & 1 ) == 0 ) && ( c != 0 ) ) { c0 ++ ; c >>= 1 ; } while ( ( c & 1 ) == 1 ) { c1 ++ ; c >>= 1 ; } if ( c0 + c1 == 31 c0 + c1 == 0 ) return - 1 ; return n + ( 1 << c0 ) + ( 1 << ( c1 - 1 ) ) - 1 ; }
function reverseArray ( arr , n ) { for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; i ++ ) { swap ( arr , i , ( n + ~ i + 1 ) + ~ 1 + 1 ) ; } }
function countNum ( arr , n ) { let s = new Set ( ) ; let count = 0 , maxm = Number . MIN_VALUE , minm = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( let i = minm ; i <= maxm ; i ++ ) if ( ! s . has ( i ) ) count ++ ; return count ; }
function CountXORandSumEqual ( x ) { let count = CountZeroBit ( x ) ; return ( 1 << count ) ; }
function maxXORInRange ( L , R ) { let LXR = L ^ R ; let msbPos = 0 ; while ( LXR > 0 ) { msbPos ++ ; LXR >>= 1 ; } let maxXOR = 0 ; let two = 1 ; while ( msbPos -- > 0 ) { maxXOR += two ; two <<= 1 ; } return maxXOR ; }
function missingNumber ( arr1 , arr2 , n ) { let mnum = 0 ; for ( let i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }
function CountORandSumEqual ( N ) { let count = CountZeroBit ( N ) ; return ( 1 << count ) ; }
function toggleKthBit ( n , k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
function countValues ( x ) { var count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x = parseInt ( x / 2 ) ; } return count ; }
function constructXOR ( A , n ) { let XOR = 0 ; for ( let i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( let i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }
function kBitDifferencePairs ( arr , n , k ) { let MAX = Math . max ( ... arr ) ; let count = new Array ( MAX + 1 ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ; let ans = 0 ; if ( k == 0 ) { for ( let i = 0 ; i <= MAX ; ++ i ) ans += parseInt ( ( count [ i ] * ( count [ i ] - 1 ) ) / 2 ) ; return ans ; } for ( let i = 0 ; i <= MAX ; ++ i ) { if ( ! count [ i ] ) continue ; for ( let j = i + 1 ; j <= MAX ; ++ j ) { if ( BitCount ( i ^ j ) == k ) ans += count [ i ] * count [ j ] ; } } return ans ; }
function multiply ( F , M ) { var x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ; var y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ; var z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ; var w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; }
function power ( F , n ) { if ( n == 0 n == 1 ) { return ; } var M = [ [ 1 , 1 ] , [ 1 , 0 ] ] ; power ( F , parseInt ( n / 2 ) ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) { multiply ( F , M ) ; } }
function countWays ( n ) { var F = [ [ 1 , 1 ] , [ 1 , 0 ] ] ; if ( n == 0 ) { return 0 ; } power ( F , n ) ; return F [ 0 ] [ 0 ] ; }
function countTrailingZero ( x ) { let count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; }
function totalFlips ( A , B , C , N ) { let count = 0 ; for ( let i = 0 ; i < N ; ++ i ) { if ( A [ i ] == B [ i ] && C [ i ] == "1" ) ++ count ; else if ( A [ i ] != B [ i ] && C [ i ] == "0" ) ++ count ; } return count ; }
function countNumbers ( n ) { let k = 0 ; let count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( Math . pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; }
function multiply ( n , m ) { let ans = 0 , count = 0 ; while ( m ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m = Math . floor ( m / 2 ) ; } return ans ; }
function EqualNumber ( A , B ) { return ( A ^ B ) ; }
function countXOR ( n ) { let count0 = 0 , count1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count0 ++ ; else count1 ++ ; n = Math . floor ( n / 2 ) ; } return ( count0 ^ count1 ) ; }
function xorPairCount ( arr , n , x ) { let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( s . has ( x ^ arr [ i ] ) ) { result ++ ; } s . add ( arr [ i ] ) ; } return result ; }
function xorPairCount ( arr , n , x ) { let m = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let curr_xor = x ^ arr [ i ] ; if ( m . has ( curr_xor ) ) result += m . get ( curr_xor ) ; if ( m . has ( arr [ i ] ) ) { m . set ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . set ( arr [ i ] , 1 ) ; } } return result ; }
function msbPos ( n ) { let msb_p = - 1 ; while ( n > 0 ) { n = n >> 1 ; msb_p ++ ; } return msb_p ; }
function andOperator ( x , y ) { while ( x > 0 && y > 0 ) { let msb_p1 = msbPos ( x ) ; let msb_p2 = msbPos ( y ) ; if ( msb_p1 != msb_p2 ) break ; let msb_val = ( 1 << msb_p1 ) ; res = res + msb_val ; x = x - msb_val ; y = y - msb_val ; } return res ; }
function multiplyTen ( n ) { return ( n << 1 ) + ( n << 3 ) ; }
function countValues ( n ) { let countV = 0 ; for ( let i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; }
function countValues ( n ) { let unset_bits = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; }
function countSubarrays ( arr , n ) { let difference = 0 ; let ans = 0 ; let hash_positive = new Array ( n + 1 ) ; let hash_negative = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { hash_positive [ i ] = 0 ; hash_negative [ i ] = 0 ; } hash_positive [ 0 ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) { difference ++ ; } else { difference -- ; } if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; }
function printTwoSetBitNums ( n ) { let x = 1 ; while ( n > 0 ) { let y = 0 ; while ( y < x ) { document . write ( ( 1 << x ) + ( 1 << y ) + "▁" ) ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } }
function printRepeatingEven ( arr , n ) { let _xor = 0 ; let pos ; for ( let i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; _xor ^= pos ; } for ( let i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; if ( ! ( ( pos & _xor ) != 0 ) ) { document . write ( arr [ i ] + "▁" ) ; _xor ^= pos ; } } }
function countSetBits ( x ) { let count = 0 ; while ( x != 0 ) { x &= ( x - 1 ) ; count ++ ; } return count ; }
function isBleak ( n ) { for ( let x = 1 ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; }
function diameter ( root ) { if ( root == null ) return ; ans = Number . MIN_VALUE ; lh = 0 ; rh = 0 ; f = 0 ; let height_of_tree = height ( root ) ; let lPath = new Array ( 100 ) ; let pathlen = 0 ; printPathsRecur ( k . left , lPath , pathlen , lh ) ; document . write ( k . data + "▁" ) ; let rPath = new Array ( 100 ) ; f = 1 ; printPathsRecur ( k . right , rPath , pathlen , rh ) ; }
function countSetBits ( x ) { let count = 0 ; while ( x != 0 ) { x &= ( x - 1 ) ; count ++ ; } return count ; }
function ceilLog2 ( x ) { let count = 0 ; x -- ; while ( x > 0 ) { x = x >> 1 ; count ++ ; } return count ; }
function isBleak ( n ) { for ( let x = n - ceilLog2 ( n ) ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; }
function countStrings ( n ) { let a = [ ] , b = [ ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
function myXOR ( x , y ) { for ( let i = 31 ; i >= 0 ; i -- ) { let b1 = ( ( x & ( 1 << i ) ) == 0 ) ? 0 : 1 ; let b2 = ( ( y & ( 1 << i ) ) == 0 ) ? 0 : 1 ; let xoredBit = ( b1 & b2 ) ? 0 : ( b1 b2 ) ; res <<= 1 ; res |= xoredBit ; } return res ; }
function myXOR ( x , y ) { return ( x y ) & ( ~ x ~ y ) ; }
function myXOR ( x , y ) { return ( x & ( ~ y ) ) | ( ( ~ x ) & y ) ; }
function swapBits ( n , p1 , p2 ) { n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; }
function multiplyBySevenByEight ( n ) { return ( n - ( n >> 3 ) ) ; }
function subtract ( x , y ) { while ( y != 0 ) { let borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; }
function subtract ( x , y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }
function square ( n ) { if ( n < 0 ) n = - n ; let res = n ; for ( let i = 1 ; i < n ; i ++ ) res += n ; return res ; }
function temp_convert ( F1 , B1 , F2 , B2 , T ) { var t2 ; t2 = F2 + ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; }
function Divisible ( arr , n ) { let count_even = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) count_even ++ ; return count_even + parseInt ( ( n - count_even ) / 2 ) ; }
function nextPowerOf2 ( n ) { var count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
function maxLength ( arr , n ) { let maxLen = 0 ; let i = 0 ; let j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = Math . max ( maxLen , 2 ) ; let l = i - 1 ; let r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = Math . max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; }
function maxLength ( a , n ) { let maxLen = 0 ; let prev_cnt = 0 , curr_cnt = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) curr_cnt ++ ; else { prev_cnt = curr_cnt ; curr_cnt = 1 ; } maxLen = Math . max ( maxLen , Math . min ( prev_cnt , curr_cnt ) ) ; } return ( 2 * maxLen ) ; }
function freivald ( a , b , c ) { let r = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) r [ i ] = Math . random ( ) % 2 ; let br = new Array ( N ) ; br . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) br [ i ] = br [ i ] + b [ i ] [ j ] * r [ j ] ; let cr = new Array ( N ) ; cr . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) cr [ i ] = cr [ i ] + c [ i ] [ j ] * r [ j ] ; let axbr = new Array ( N ) ; axbr . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) axbr [ i ] = axbr [ i ] + a [ i ] [ j ] * br [ j ] ; for ( let i = 0 ; i < N ; i ++ ) if ( axbr [ i ] - cr [ i ] != 0 ) false ; return true ; }
function isProduct ( a , b , c , k ) { for ( let i = 0 ; i < k ; i ++ ) if ( freivald ( a , b , c ) == false ) return false ; return true ; }
function children ( root ) { if ( root == null ) return 0 ; return root . children + 1 ; }
function randomNodeUtil ( root , count ) { if ( root == null ) return 0 ; if ( count == children ( root . left ) ) return root . data ; if ( count < children ( root . left ) ) return randomNodeUtil ( root . left , count ) ; return randomNodeUtil ( root . right , count - children ( root . left ) - 1 ) ; }
function randomNode ( root ) { let count = Math . floor ( Math . random ( ) * ( root . children + 1 ) ) ; return randomNodeUtil ( root , count ) ; }
function calc_Expectation ( a , n ) { let prb = ( 1 / n ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] * prb ; return sum ; }
function findLargestd ( S , n ) { let found = false ; S . sort ( ) ; for ( let i = n - 1 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( let k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( let l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return Number . MAX_VALUE ; return - 1 ; }
function recaman ( n ) { let arr = new Array ( n ) ; arr [ 0 ] = 0 ; document . write ( arr [ 0 ] + "▁," ) ; for ( let i = 1 ; i < n ; i ++ ) { let curr = arr [ i - 1 ] - i ; let j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; document . write ( arr [ i ] + ",▁" ) ; } }
function countPairs ( arr , n ) { let s = new Set ( ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) s . add ( arr [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( s . has ( sumOfDiv ( arr [ i ] ) ) ) { let sum = sumOfDiv ( arr [ i ] ) ; if ( isAmicable ( arr [ i ] , sum ) ) count ++ ; } } return Math . floor ( count / 2 ) ; }
function findArea ( arr , n ) { arr . sort ( ( a , b ) => { return b - a ; } )  var dimension = [ 0 , 0 ] ; for ( var i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
function findArea ( arr , n ) { let s = new Set ( ) ; let first = 0 , second = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! s . has ( arr [ i ] ) ) { s . add ( arr [ i ] ) ; continue ; } if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } return ( first * second ) ; }
function printAllPaths ( root ) { if ( root == null ) return ; let Allpaths = [ ] ; for ( let i = 0 ; i < MAX_PATH_SIZE ; i ++ ) { Allpaths . push ( new PATH ( ) ) ; } printAllPathsUtil ( root , Allpaths , 0 , 0 ) ; }
function longLenStrictBitonicSub ( arr , n ) { var inc = new Map ( ) , dcr = new Map ( ) ; var len_inc = Array ( n ) , len_dcr = Array ( n ) ; var longLen = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var len = 0 ; if ( inc . has ( arr [ i ] - 1 ) ) len = inc . get ( arr [ i ] - 1 ) ; len_inc [ i ] = len + 1 ; inc . set ( arr [ i ] , len_inc [ i ] ) ; } for ( var i = n - 1 ; i >= 0 ; i -- ) { var len = 0 ; if ( dcr . has ( arr [ i ] - 1 ) ) len = dcr . get ( arr [ i ] - 1 ) ; len_dcr [ i ] = len + 1 ; dcr . set ( arr [ i ] , len_dcr [ i ] ) ; } for ( var i = 0 ; i < n ; i ++ ) if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1 ; return longLen ; }
function leftRotatebyOne ( arr , n ) { var i , temp ; temp = arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; }
function printArray ( arr , n ) { for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function search ( arr , l , h , key ) { if ( l > h ) return - 1 ; let mid = Math . floor ( ( l + h ) / 2 ) ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
function pairInSortedRotated ( arr , n , x ) { let i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; let l = ( i + 1 ) % n ; let r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }
function pairsInSortedRotated ( arr , n , x ) { let i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; let l = ( i + 1 ) % n ; let r = i ; let cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
function maxSum ( arr , n ) { var res = Number . MIN_VALUE ; for ( i = 0 ; i < n ; i ++ ) { var curr_sum = 0 ; for ( j = 0 ; j < n ; j ++ ) { var index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; }
function maxSum ( arr , n ) { let cum_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; let curr_val = 0 ; for ( let i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; let res = curr_val ; for ( let i = 1 ; i < n ; i ++ ) { let next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = Math . max ( res , next_val ) ; } return res ; }
function countRotations ( arr , n ) { let min = arr [ 0 ] , min_index = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }
function countRotations ( arr , low , high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; let mid = Math . floor ( low + ( high - low ) / 2 ) ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
function leftRotate ( arr , n , k ) { for ( let i = k ; i < k + n ; i ++ ) document . write ( arr [ i % n ] + "▁" ) ; }
function findMin ( arr , low , high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; let mid = low + Math . floor ( ( high - low ) / 2 ) ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
function reverseArray ( arr , start , end ) { while ( start < end ) { let temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } return arr ; }
function rightRotate ( arr , d , n ) { arr = reverseArray ( arr , 0 , n - 1 ) ; arr = reverseArray ( arr , 0 , d - 1 ) ; arr = reverseArray ( arr , d , n - 1 ) ; return arr ; }
function maxHamming ( arr , n ) { let brr = new Array ( 2 * n + 1 ) ; for ( let i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; let maxHam = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let currHam = 0 ; for ( let j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = max ( maxHam , currHam ) ; } return maxHam ; }
function rearrangeArr ( arr , n ) { let evenPos = Math . floor ( n / 2 ) ; let oddPos = n - evenPos ; let tempArr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) tempArr [ i ] = arr [ i ] ; tempArr . sort ( ) ; let j = oddPos - 1 ; for ( let i = 0 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j -- ; } j = oddPos ; for ( let i = 1 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j ++ ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function pushZerosToEnd ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
function moveZerosToEnd ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) { temp = arr [ count ] ; arr [ count ] = arr [ i ] ; arr [ i ] = temp ; count = count + 1 ; } }
function printArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function pushZerosToEnd ( arr , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
function modifyAndRearrangeArr ( arr , n ) { if ( n == 1 ) return ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != 0 && arr [ i ] == arr [ i + 1 ] ) { arr [ i ] = 2 * arr [ i ] ; arr [ i + 1 ] = 0 ; i ++ ; } } pushZerosToEnd ( arr , n ) ; }
function printArray ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function RearrangePosNeg ( arr , n ) { let key , j ; for ( let i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; if ( key > 0 ) continue ; j = i - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } }
function isLeaf ( node ) { if ( node == null ) return false ; if ( node . left == null && node . right == null ) return true ; return false ; }
function leftLeavesSum ( node ) { let res = 0 ; if ( node != null ) { if ( isLeaf ( node . left ) ) res += node . left . data ; else res += leftLeavesSum ( node . left ) ; res += leftLeavesSum ( node . right ) ; } return res ; }
function reverse ( arr , l , r ) { if ( l < r ) { arr = swap ( arr , l , r ) ; reverse ( arr , ++ l , -- r ) ; } }
function RearrangePosNeg ( arr , l , r ) { if ( l < r ) { let m = l + Math . floor ( ( r - l ) / 2 ) ; RearrangePosNeg ( arr , l , m ) ; RearrangePosNeg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } }
function rearrangeNaive ( arr , n ) { let temp = new Array ( n ) , i ; for ( i = 0 ; i < n ; i ++ ) temp [ arr [ i ] ] = i ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
function printArray ( arr , n ) { let i ; for ( i = 0 ; i < n ; i ++ ) document . write ( "▁" + arr [ i ] ) ; document . write ( "" ) ; }
function rearrange ( arr , n ) { for ( i = 0 ; i < n ; i ++ ) { arr [ arr [ i ] % n ] += i * n ; } for ( i = 0 ; i < n ; i ++ ) { arr [ i ] = parseInt ( arr [ i ] / n ) ; } }
function rearrange ( arr , n ) { let max_idx = n - 1 , min_idx = 0 ; let max_elem = arr [ n - 1 ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = Math . floor ( arr [ i ] / max_elem ) ; }
function rearrange ( arr , n ) { let max_ele = arr [ n - 1 ] ; let min_ele = arr [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }
function leftLeavesSumRec ( node , isleft , summ ) { if ( node == null ) return ; if ( node . left == null && node . right == null && isleft ) summ . sum = summ . sum + node . data ; leftLeavesSumRec ( node . left , true , summ ) ; leftLeavesSumRec ( node . right , false , summ ) ; }
function leftLeavesSum ( node ) { suum = new Sum ( ) ; leftLeavesSumRec ( node , false , suum ) ; return suum . sum ; }
function rearrange ( arr , n ) { let j = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) { if ( i != j ) { let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } } }
function segregateElements ( arr , n ) { let temp = new Array ( n ) ; let j = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
function rearrange ( a , size ) { let positive = 0 ; let negative = 1 ; let temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }
function printPostorder ( node ) { if ( node == null ) return ; printPostorder ( node . left ) ; printPostorder ( node . right ) ; document . write ( node . key + "▁" ) ; }
function printInorder ( node ) { if ( node == null ) return ; printInorder ( node . left ) ; document . write ( node . key + "▁" ) ; printInorder ( node . right ) ; }
function printPreorder ( node ) { if ( node == null ) return ; document . write ( node . key + "▁" ) ; printPreorder ( node . left ) ; printPreorder ( node . right ) ; }
function largest ( arr , n ) { arr . sort ( ) ; return arr [ n - 1 ] ; }
function findElements ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) document . write ( arr [ i ] + "▁" ) ; } }
function findElements ( arr , n ) { arr . sort ( ) ; for ( let i = 0 ; i < n - 2 ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function findElements ( arr , n ) { let first = Number . MIN_VALUE ; let second = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) document . write ( arr [ i ] + "▁" ) ; }
function findMean ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return sum / n ; }
function findMedian ( a , n ) { a . sort ( ) ; if ( n % 2 != 0 ) return a [ n / 2 ] ; return ( a [ Math . floor ( ( n - 1 ) / 2 ) ] + a [ n / 2 ] ) / 2 ; }
function findSmallestMissinginSortedArray ( arr ) { if ( arr [ 0 ] != 0 ) return 0 ; if ( arr [ arr . length - 1 ] == arr . length - 1 ) return arr . length ; let first = arr [ 0 ] ; return findFirstMissing ( arr , 0 , arr . length - 1 , first ) ; }
function findFirstMissing ( arr , start , end , first ) { if ( start < end ) { let mid = ( start + end ) / 2 ; if ( arr [ mid ] != mid + first ) return findFirstMissing ( arr , start , mid , first ) ; else return findFirstMissing ( arr , mid + 1 , end , first ) ; } return start + first ; }
function sumNodes ( l ) { let leafNodeCount = Math . pow ( 2 , l - 1 ) ; let sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; let sum = sumLastLevel * l ; return sum ; }
function buildSparseTable ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = arr [ i ] ; for ( var j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( var i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) { if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] ; else lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ; } } }
function query ( L , R ) { var j = parseInt ( Math . log2 ( R - L + 1 ) ) ; if ( lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] ) return lookup [ L ] [ j ] ; else return lookup [ R - ( 1 << j ) + 1 ] [ j ] ; }
function add ( arr , N , lo , hi , val ) { arr [ lo ] += val ; if ( hi != N - 1 ) arr [ hi + 1 ] -= val ; }
function updateArray ( arr , N ) { for ( let i = 1 ; i < N ; i ++ ) arr [ i ] += arr [ i - 1 ] ; }
function FillPrefixSuffix ( prefix , arr , suffix , n ) { prefix [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) prefix [ i ] = GCD ( prefix [ i - 1 ] , arr [ i ] ) ; suffix [ n - 1 ] = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) suffix [ i ] = GCD ( suffix [ i + 1 ] , arr [ i ] ) ; }
function GCDoutsideRange ( l , r , prefix , suffix , n ) { if ( l == 0 ) return suffix [ r + 1 ] ; if ( r == n - 1 ) return prefix [ l - 1 ] ; return GCD ( prefix [ l - 1 ] , suffix [ r + 1 ] ) ; }
function lowerIndex ( arr , n , x ) { let l = 0 , h = n - 1 ; while ( l <= h ) { let mid = parseInt ( ( l + h ) / 2 , 10 ) ; if ( arr [ mid ] >= x ) h = mid - 1 ; else l = mid + 1 ; } return l ; }
function countInRange ( arr , n , x , y ) { let count = 0 ; count = upperIndex ( arr , n , y ) - lowerIndex ( arr , n , x ) + 1 ; return count ; }
function precompute ( arr , n , pre ) { for ( let i = 0 ; i < n ; i ++ ) pre [ i ] = 0 ; pre [ n - 1 ] = arr [ n - 1 ] * ( Math . pow ( 2 , 0 ) ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) pre [ i ] = pre [ i + 1 ] + arr [ i ] * ( 1 << ( n - 1 - i ) ) ; }
function decimalOfSubarr ( arr , l , r , n , pre ) { if ( r != n - 1 ) return ( pre [ l ] - pre [ r + 1 ] ) / ( 1 << ( n - 1 - r ) ) ; return pre [ l ] / ( 1 << ( n - 1 - r ) ) ; }
function answerQuery ( a , n , l , r ) { var count = 0 ; l = l - 1 ; for ( i = l ; i < r ; i ++ ) { var element = a [ i ] ; var divisors = 0 ; for ( j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }
function addConsideringGrid ( root , level , index ) { if ( root == null ) return ; if ( grid . has ( level - index ) ) { grid . set ( level - index , grid . get ( level - index ) + ( root . data ) ) ; } else { grid . set ( level - index , root . data ) ; } addConsideringGrid ( root . left , level + 1 , index - 1 ) ; addConsideringGrid ( root . right , level + 1 , index + 1 ) ; }
function diagonalSum ( root ) { addConsideringGrid ( root , 0 , 0 ) ; let ans = [ ] ; for ( let [ key , value ] of grid ) { ans . push ( value ) ; } return ans ; }
function make_prefix ( A , n ) { for ( let j = 0 ; j < 32 ; j ++ ) one [ 0 ] [ j ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let a = A [ i - 1 ] ; for ( let j = 0 ; j < 32 ; j ++ ) { let x = Math . pow ( 2 , j ) ; if ( a & x ) one [ i ] [ j ] = 1 + one [ i - 1 ] [ j ] ; else one [ i ] [ j ] = one [ i - 1 ] [ j ] ; } } }
function type1 ( arr , start , limit ) { for ( let i = start ; i <= limit ; i ++ ) arr [ i ] ++ ; }
function type2 ( arr , query , start , limit ) { for ( let i = start ; i <= limit ; i ++ ) { if ( query [ i ] [ 0 ] == 1 ) type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; else if ( query [ i ] [ 0 ] == 2 ) type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; } }
function record_sum ( record , l , r , n , adder ) { for ( let i = l ; i <= r ; i ++ ) { record [ i ] += adder ; } }
function solveQuery ( start , end , arr ) { let mp = new Map ( ) ; for ( let i = start ; i <= end ; i ++ ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; let count = 0 ; for ( let [ key , value ] of mp . entries ( ) ) if ( key == value ) count ++ ; return count ; }
function answer_query ( a , n , l , r ) { var count = 0 ; for ( var i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }
function countIndex ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == a [ i + 1 ] ) prefixans [ i ] = 1 ; if ( i != 0 ) prefixans [ i ] += prefixans [ i - 1 ] ; } }
function answer_query ( l , r ) { if ( l == 0 ) return prefixans [ r - 1 ] ; else return prefixans [ r - 1 ] - prefixans [ l - 1 ] ; }
function update ( D , l , r , x ) { D [ l ] += x ; D [ r + 1 ] -= x ; return D ; }
function maxSubArraySum ( a , size ) { let max_so_far = a [ 0 ] ; let curr_max = a [ 0 ] ; for ( let i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; }
function minJumps ( arr , n ) { var jumps = Array . from ( { length : n } , ( _ , i ) => 0 ) ; var min ; jumps [ n - 1 ] = 0 ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) jumps [ i ] = Number . MAX_VALUE ; else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ; else { min = Number . MAX_VALUE ; for ( j = i + 1 ; j < n && j <= arr [ i ] + i ; j ++ ) { if ( min > jumps [ j ] ) min = jumps [ j ] ; } if ( min != Number . MAX_VALUE ) jumps [ i ] = min + 1 ; else jumps [ i ] = min ; } } return jumps [ 0 ] ; }
function smallestSubWithSum ( arr , n , x ) { let curr_sum = 0 , min_len = n + 1 ; let start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }
function findMaxAverage ( arr , n , k ) { if ( k > n ) return - 1 ; let csum = new Array ( n ) ; csum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; let max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( let i = k ; i < n ; i ++ ) { let curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }
function findMaxAverage ( arr , n , k ) { if ( k > n ) return - 1 ; let sum = arr [ 0 ] ; for ( let i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; let max_sum = sum ; let max_end = k - 1 ; for ( let i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
function findMinOps ( arr , n ) { let ans = 0 ; for ( let i = 0 , j = n - 1 ; i <= j ; ) { if ( arr [ i ] == arr [ j ] ) { i ++ ; j -- ; } else if ( arr [ i ] > arr [ j ] ) { j -- ; arr [ j ] += arr [ j + 1 ] ; ans ++ ; } else { i ++ ; arr [ i ] += arr [ i - 1 ] ; ans ++ ; } } return ans ; }
function findSmallest ( arr , n ) { var res = 1 ; for ( i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }
function maxSubArraySum ( a , size ) { let max_so_far = Number . MIN_VALUE , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( let i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } return ( end - start + 1 ) ; }
function findMinDiff ( arr , n ) { let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }
function findMinDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
function checkbit ( array , index ) { return array [ index >> 5 ] & ( 1 << ( index & 31 ) ) ; }
function setbit ( array , index ) { array [ index >> 5 ] |= ( 1 << ( index & 31 ) ) ; }
function sortInWave ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n - 1 ; i += 2 ) swap ( arr , i , i + 1 ) ; }
function sortInWave ( arr , n ) { for ( let i = 0 ; i < n ; i += 2 ) { if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( arr , i - 1 , i ) ; if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( arr , i , i + 1 ) ; } }
function moveToEnd ( mPlusN , size ) { let i = 0 ; let j = size - 1 ; for ( i = size - 1 ; i >= 0 ; i -- ) { if ( mPlusN [ i ] != - 1 ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } } }
function merge ( mPlusN , N , m , n ) { let i = n ; let j = 0 ; let k = 0 ; while ( k < ( m + n ) ) { if ( ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) || ( j == n ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; } else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } }
function sortedAfterSwap ( A , B , n ) { let i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) { j ++ ; } A . sort ( ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } } return true ; }
function sortedAfterSwap ( A , B , n ) { let t = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] != 0 ) { if ( A [ i ] != i + 1 ) t = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = t ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return 0 ; } return 1 ; }
function segregate0and1 ( arr , n ) { let type0 = 0 ; let type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type0 ] = arr [ type0 ] + arr [ type1 ] ; arr [ type1 ] = arr [ type0 ] - arr [ type1 ] ; arr [ type0 ] = arr [ type0 ] - arr [ type1 ] ; type1 -- ; } else { type0 ++ ; } } }
function increasing ( a , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] >= a [ i + 1 ] ) return false ; return true ; }
function decreasing ( arr , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] < arr [ i + 1 ] ) return false ; return true ; }
function shortestUnsorted ( a , n ) { if ( increasing ( a , n ) == true || decreasing ( a , n ) == true ) return 0 ; else return 3 ; }
function indexOf ( arr , ele ) { for ( let i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == ele ) { return i ; } } return - 1 ; }
function minSwaps ( arr , N ) { let ans = 0 ; let temp = [ ... arr ] ; temp . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != temp [ i ] ) { ans ++ ; swap ( arr , i , indexOf ( arr , temp [ i ] ) ) ; } } return ans ; }
function printUnion ( arr1 , arr2 , m , n ) { if ( m > n ) { let tempp = arr1 ; arr1 = arr2 ; arr2 = tempp ; let temp = m ; m = n ; n = temp ; } arr1 . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < m ; i ++ ) document . write ( arr1 [ i ] + "▁" ) ; for ( let i = 0 ; i < n ; i ++ ) if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) == - 1 ) document . write ( arr2 [ i ] + "▁" ) ; }
function printIntersection ( arr1 , arr2 , m , n ) { if ( m > n ) { let tempp = arr1 ; arr1 = arr2 ; arr2 = tempp ; let temp = m ; m = n ; n = temp ; } arr1 . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) != - 1 ) document . write ( arr2 [ i ] + "▁" ) ; }
function binarySearch ( arr , l , r , x ) { if ( r >= l ) { let mid = l + Math . floor ( ( r - l ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
function intersection ( a , b , n , m ) { let i = 0 , j = 0 ; while ( i < n && j < m ) { if ( a [ i ] > b [ j ] ) { j ++ ; } else if ( b [ j ] > a [ i ] ) { i ++ ; } else { document . write ( a [ i ] + "▁" ) ; i ++ ; j ++ ; } } }
function sort012 ( a , arr_size ) { let lo = 0 ; let hi = arr_size - 1 ; let mid = 0 ; let temp = 0 ; while ( mid <= hi ) { if ( a [ mid ] == 0 ) { temp = a [ lo ] ; a [ lo ] = a [ mid ] ; a [ mid ] = temp ; lo ++ ; mid ++ ; } else if ( a [ mid ] == 1 ) { mid ++ ; } else { temp = a [ mid ] ; a [ mid ] = a [ hi ] ; a [ hi ] = temp ; hi -- ; } } }
function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function sortArr ( arr , n ) { let i , cnt0 = 0 , cnt1 = 0 , cnt2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { switch ( arr [ i ] ) { case 0 : cnt0 ++ ; break ; case 1 : cnt1 ++ ; break ; case 2 : cnt2 ++ ; break ; } } i = 0 ; while ( cnt0 > 0 ) { arr [ i ++ ] = 0 ; cnt0 -- ; } while ( cnt1 > 0 ) { arr [ i ++ ] = 1 ; cnt1 -- ; } while ( cnt2 > 0 ) { arr [ i ++ ] = 2 ; cnt2 -- ; } printArr ( arr , n ) ; }
function countPairsWithDiffK ( arr , n , k ) { count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
function binarySearch ( arr , low , high , x ) { if ( high >= low ) { let mid = low + Math . floor ( ( high - low ) / 2 ) ; if ( x == arr [ mid ] ) return mid ; if ( x > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; }
function countPairsWithDiffK ( arr , n , k ) { let count = 0 , i ; arr . sort ( ( a , b ) => a - b ) ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( binarySearch ( arr , i + 1 , n - 1 , arr [ i ] + k ) != - 1 ) count ++ ; return count ; }
function constructArr ( arr , pair , n ) { arr [ 0 ] = Math . floor ( ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ) ; for ( let i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
function minMaxProduct ( arr1 , arr2 , n1 , n2 ) { let max = arr1 [ 0 ] ; let min = arr2 [ 0 ] ; let i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; if ( arr2 [ i ] < min ) min = arr2 [ i ] ; } while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) min = arr2 [ i ] ; i ++ ; } return max * min ; }
function findElement ( arr , n , key ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }
function findPos ( arr , key ) { let l = 0 , h = 1 ; let val = arr [ 0 ] ; while ( val < key ) { l = h ; h = 2 * h ; val = arr [ h ] ; } return binarySearch ( arr , l , h , key ) ; }
function findSingle ( ar , ar_size ) { let res = ar [ 0 ] ; for ( let i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; }
function isPresent ( B , m , x ) { for ( let i = 0 ; i < m ; i ++ ) if ( B [ i ] == x ) return true ; return false ; }
function findMaxSubarraySumUtil ( A , B , n , m ) { let max_so_far = - 2147483648 , curr_max = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isPresent ( B , m , A [ i ] ) ) { curr_max = 0 ; continue ; } curr_max = Math . max ( A [ i ] , curr_max + A [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; }
function findMaxSum ( arr , n ) { var res = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { var prefix_sum = arr [ i ] ; for ( var j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; var suffix_sum = arr [ i ] ; for ( var j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . max ( res , prefix_sum ) ; } return res ; }
function getTotalHeight ( root ) { if ( root == null ) return 0 ; return getTotalHeight ( root . left ) + getHeight ( root ) + getTotalHeight ( root . right ) ; }
function findMaxSum ( arr , n ) { let preSum = new Array ( n ) ; preSum . fill ( 0 ) ; let suffSum = new Array ( n ) ; suffSum . fill ( 0 ) ; let ans = Number . MIN_VALUE ; preSum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . max ( ans , preSum [ n - 1 ] ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . max ( ans , preSum [ i ] ) ; } return ans ; }
function ceilSearch ( arr , low , high , x ) { let i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
function ceilSearch ( arr , low , high , x ) { let mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }
function findMajority ( arr , n ) { let maxCount = 0 ; let index = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) document . write ( arr [ index ] ) ; else document . write ( "No▁Majority▁Element" ) ; }
function getTotalHeight ( root ) { sum = 0 ; getTotalHeightUtil ( root ) ; return sum ; }
function majorityElement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let count = 1 , max_ele = - 1 , temp = arr [ 0 ] , ele = 0 , f = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; } if ( max_ele < count ) { max_ele = count ; ele = arr [ i ] ; if ( max_ele > parseInt ( n / 2 , 10 ) ) { f = 1 ; break ; } } } return ( f == 1 ? ele : - 1 ) ; }
function isMajority ( arr , n , x ) { let i , last_index = 0 ; last_index = ( n % 2 == 0 ) ? parseInt ( n / 2 , 10 ) : parseInt ( n / 2 , 10 ) + 1 ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + parseInt ( n / 2 , 10 ) ] == x ) return true ; } return false ; }
function _binarySearch ( arr , low , high , x ) { if ( high >= low ) { let mid = parseInt ( ( low + high ) / 2 , 10 ) ; if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; }
function isMajority ( arr , n , x ) { let i = _binarySearch ( arr , 0 , n - 1 , x ) ; if ( i == - 1 ) return false ; if ( ( ( i + parseInt ( n / 2 , 10 ) ) <= ( n - 1 ) ) && arr [ i + parseInt ( n / 2 , 10 ) ] == x ) return true ; else return false ; }
function isMajorityElement ( arr , n , key ) { if ( arr [ parseInt ( n / 2 , 10 ) ] == key ) return true ; else return false ; }
function findPeak ( arr , n ) { if ( n == 1 ) return 0 ; if ( arr [ 0 ] >= arr [ 1 ] ) return 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) return n - 1 ; for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] && arr [ i ] >= arr [ i + 1 ] ) return i ; } }
function findPeak ( arr , n ) { return findPeakUtil ( arr , 0 , n - 1 , n ) ; }
function printRepeating ( arr , size ) { var i , j ; document . write ( "Repeated▁Elements▁are▁:" ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) document . write ( arr [ i ] + "▁" ) ; } } }
function printRepeating ( arr , size ) { let count = new Array ( size ) ; count . fill ( 0 ) ; let i ; document . write ( "▁Repeating▁elements▁are▁" ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) document . write ( arr [ i ] + "▁" ) ; else count [ arr [ i ] ] ++ ; } }
function printRepeating ( arr , size ) { var S = 0 ; var P = 1 ; var x , y ; var D ; var n = size - 2 , i ; for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * parseInt ( ( n + 1 ) / 2 ) ; P = parseInt ( P / fact ( n ) ) ; D = parseInt ( Math . sqrt ( S * S - 4 * P ) ) ; x = parseInt ( ( D + S ) / 2 ) ; y = parseInt ( ( S - D ) / 2 ) ; document . write ( "The▁two▁Repeating▁elements▁are▁" ) ; document . write ( x + "▁&▁" + y ) ; }
function fact ( n ) { var ans = false ; if ( n == 0 ) return 1 ; else return ( n * fact ( n - 1 ) ) ; }
function printRepeating ( arr , size ) { let Xor = arr [ 0 ] ; let set_bit_no ; let i ; let n = size - 2 ; let x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) Xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) Xor ^= i ; set_bit_no = Xor & ~ ( Xor - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) x = x ^ i ; else y = y ^ i ; } document . write ( "The▁two▁repeating▁elements▁are▁" + y + "▁" + x ) ; }
function linearSearch ( arr , n ) { let i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
function subArraySum ( arr , n , sum ) { let curr_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( let j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { document . write ( "Sum▁found▁between▁indexes▁" + i + "▁and▁" + ( j - 1 ) ) ; return ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } document . write ( "No▁subarray▁found" ) ; return ; }
function maxTripletSum ( arr , n ) { let sum = - 1000000 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
function maxTripletSum ( arr , n ) { arr . sort ( ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }
function maxTripletSum ( arr , n ) { let maxA = Number . MIN_SAFE_INTEGER ; let maxB = Number . MIN_SAFE_INTEGER ; let maxC = Number . MIN_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; }
function minimum ( a , b , c ) { return Math . min ( Math . min ( a , b ) , c ) ; }
function smallestDifferenceTriplet ( arr1 , arr2 , arr3 , n ) { arr1 . sort ( function ( a , b ) { return a - b } ) ; arr2 . sort ( function ( a , b ) { return a - b } ) ; arr3 . sort ( function ( a , b ) { return a - b } ) ; let res_min = 0 , res_max = 0 , res_mid = 0 ; let i = 0 , j = 0 , k = 0 ; let diff = 2147483647 ; while ( i < n && j < n && k < n ) { let sum = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] ; let max = maximum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; let min = minimum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; if ( min == arr1 [ i ] ) i ++ ; else if ( min == arr2 [ j ] ) j ++ ; else k ++ ; if ( diff > ( max - min ) ) { diff = max - min ; res_max = max ; res_mid = sum - ( max + min ) ; res_min = min ; } } document . write ( res_max + ",▁" + res_mid + ",▁" + res_min ) ; }
function find3Numbers ( A , arr_size , sum ) { let l , r ; for ( let i = 0 ; i < arr_size - 2 ; i ++ ) { for ( let j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( let k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { document . write ( "Triplet▁is▁" + A [ i ] + ",▁" + A [ j ] + ",▁" + A [ k ] ) ; return true ; } } } } return false ; }
function find3Numbers ( A , arr_size , sum ) { let l , r ; A . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < arr_size - 2 ; i ++ ) { l = i + 1 ; r = arr_size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { document . write ( "Triplet▁is▁" + A [ i ] + ",▁" + A [ l ] + ",▁" + A [ r ] ) ; return true ; } else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ; else r -- ; } } return false ; }
function areConsecutive ( arr , n ) { if ( n < 1 ) return false ; let min = getMin ( arr , n ) ; let max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { let visited = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { visited [ i ] = false ; } let i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) { return false ; } visited [ arr [ i ] - min ] = true ; } return true ; } return false ; }
function areConsecutive ( arr , n ) { if ( n < 1 ) return false ; let min = getMin ( arr , n ) ; let max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { let i ; for ( i = 0 ; i < n ; i ++ ) { let j ; if ( arr [ i ] < 0 ) j = - arr [ i ] - min ; else j = arr [ i ] - min ; if ( arr [ j ] > 0 ) arr [ j ] = - arr [ j ] ; else return false ; } return true ; } return false ; }
function getMax ( arr , n ) { let max = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }
function relativeComplement ( arr1 , arr2 , n , m ) { let i = 0 , j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) { document . write ( arr1 [ i ] + "▁" ) ; i ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) { j ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; j ++ ; } } while ( i < n ) document . write ( arr1 [ i ] + "▁" ) ; }
function minOps ( arr , n , k ) { var max = arr [ 0 ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
function search ( arr , search_Element ) { let left = 0 ; let length = arr . length ; let right = length - 1 ; let position = - 1 ; for ( left = 0 ; left <= right ; ) { if ( arr [ left ] == search_Element ) { position = left ; document . write ( "Element▁found▁in▁Array▁at▁" + ( position + 1 ) + "▁Position▁with▁" + ( left + 1 ) + "▁Attempt" ) ; break ; } if ( arr [ right ] == search_Element ) { position = right ; document . write ( "Element▁found▁in▁Array▁at▁" + ( position + 1 ) + "▁Position▁with▁" + ( length - right ) + "▁Attempt" ) ; break ; } left ++ ; right -- ; } if ( position == - 1 ) document . write ( "Not▁found▁in▁Array▁with▁" + left + "▁Attempt" ) ; }
function binarySearch ( arr , l , r , x ) { if ( r >= l ) { let mid = l + Math . floor ( ( r - l ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
function exponentialSearch ( arr , n , x ) { if ( arr [ 0 ] == x ) return 0 ; let i = 1 ; while ( i < n && arr [ i ] <= x ) i = i * 2 ; return binarySearch ( arr , i / 2 , Math . min ( i , n - 1 ) , x ) ; }
function findCrossOver ( arr , low , high , x ) { if ( arr [ high ] <= x ) return high  if ( arr [ low ] > x ) return low  var mid = ( low + high ) / 2  if ( arr [ mid ] <= x && arr [ mid + 1 ] > x ) return mid  if ( arr [ mid ] < x ) return findCrossOver ( arr , mid + 1 , high , x )  return findCrossOver ( arr , low , mid - 1 , x ) }
function countSort ( arr , n , exp ) { let output = new Array ( n ) ; let count = new Array ( n ) ; count . fill ( 0 ) ; output . fill ( 0 ) ; let i ; for ( i = 0 ; i < n ; i ++ ) count [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) count [ parseInt ( arr [ i ] / exp , 10 ) % n ] ++ ; for ( i = 1 ; i < n ; i ++ ) count [ i ] += count [ i - 1 ] ; for ( i = n - 1 ; i >= 0 ; i -- ) { output [ count [ parseInt ( arr [ i ] / exp , 10 ) % n ] - 1 ] = arr [ i ] ; count [ parseInt ( arr [ i ] / exp , 10 ) % n ] -- ; } for ( i = 0 ; i < n ; i ++ ) arr [ i ] = output [ i ] ; }
function printClosest ( ar1 , ar2 , m , n , x ) { let diff = Number . MAX_VALUE ; let res_l , res_r ; let l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } document . write ( "The▁closest▁pair▁is▁[" + ar1 [ res_l ] + ",▁" + ar2 [ res_r ] + "]" ) ; }
function min ( x , y , z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; }
function minCost ( cost , m , n ) { if ( n < 0 m < 0 ) return Number . MAX_VALUE ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; }
function minCost ( cost , m , n ) { let i , j ; let tc = new Array ( m + 1 ) ; for ( let k = 0 ; k < m + 1 ; k ++ ) { tc [ k ] = new Array ( n + 1 ) ; } tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = Math . min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; }
function matrixChainMemoised ( p , i , j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != - 1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = Number . MAX_VALUE ; for ( let k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; }
function MatrixChainOrder ( p , n ) { let i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; }
function MatrixChainOrder ( p , n ) { var m = Array ( n ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; var i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Number . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }
function binomialCoeff ( n , k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
function binomialCoeff ( n , k ) { let C = new Array ( k + 1 ) ; C . fill ( 0 ) ; C [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
function knapSack ( W , wt , val , n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
function knapSack ( W , wt , val , n ) { let i , w ; let K = new Array ( n + 1 ) ; for ( i = 0 ; i <= n ; i ++ ) { K [ i ] = new Array ( W + 1 ) ; for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }
function max ( x , y ) { return ( x > y ) ? x : y ; }
function lps ( seq , i , j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return lps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; }
function cutRod ( price , n ) { if ( n <= 0 ) return 0 ; let max_val = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) max_val = Math . max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) ; return max_val ; }
function cutRod ( price , n ) { let val = new Array ( n + 1 ) ; val [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let max_val = Number . MIN_VALUE ; for ( let j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }
function minPalPartion ( String , i , j ) { if ( i >= j || isPalindrome ( String , i , j ) ) return 0 ; let ans = Number . MAX_VALUE , count ; for ( let k = i ; k < j ; k ++ ) { count = minPalPartion ( String , i , k ) + minPalPartion ( String , k + 1 , j ) + 1 ; ans = Math . min ( ans , count ) ; } return ans ; }
function maxDivide ( a , b ) { while ( a % b == 0 ) a = a / b ; return a ; }
function getNthUglyNo ( n ) { var i = 1 ; var count = 1 ; while ( n > count ) { i ++ ; if ( isUgly ( i ) == 1 ) count ++ ; } return i ; }
function optimalSearchTree ( keys , freq , n ) { return optCost ( freq , 0 , n - 1 ) ; }
function sum ( freq , i , j ) { var s = 0 ; for ( var k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; }
function optimalSearchTree ( keys , freq , n ) { var cost = new Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) cost [ i ] = new Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) cost [ i ] [ i ] = freq [ i ] ; for ( var L = 2 ; L <= n ; L ++ ) { for ( var i = 0 ; i <= n - L + 1 ; i ++ ) { var j = i + L - 1 ; if ( i >= n j >= n ) break cost  [ i ] [ j ] = Number . MAX_SAFE_INTEGER ; for ( var r = i ; r <= j ; r ++ ) { var c = 0 ; if ( r > i ) c += cost [ i ] [ r - 1 ]  if ( r < j ) c += cost [ r + 1 ] [ j ] c += sum ( freq , i , j ) ; if ( c < cost [ i ] [ j ] ) cost [ i ] [ j ] = c ; } } } return cost [ 0 ] [ n - 1 ] ; }
function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
function countParenth ( symb , oper , n ) { let F = new Array ( n ) ; let T = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { F [ i ] = new Array ( n ) ; T [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { F [ i ] [ j ] = 0 ; T [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) { F [ i ] [ i ] = ( symb [ i ] == "F" ) ? 1 : 0 ; T [ i ] [ i ] = ( symb [ i ] == "T" ) ? 1 : 0 ; } for ( let gap = 1 ; gap < n ; ++ gap ) { for ( let i = 0 , j = gap ; j < n ; ++ i , ++ j ) { T [ i ] [ j ] = F [ i ] [ j ] = 0 ; for ( let g = 0 ; g < gap ; g ++ ) { let k = i + g ; let tik = T [ i ] [ k ] + F [ i ] [ k ] ; let tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ; if ( oper [ k ] == "&" ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ; F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == "▁" ) { F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ; T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == "^" ) { T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ; F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ; } } } } return T [ 0 ] [ n - 1 ] ; }
function getCount ( keypad , n ) { if ( keypad == null n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; let row = [ 0 , 0 , - 1 , 0 , 1 ] ; let col = [ 0 , - 1 , 0 , 1 , 0 ] ; let count = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { count [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { count [ i ] [ j ] = 0 ; } } let i = 0 , j = 0 , k = 0 , move = 0 , ro = 0 , co = 0 , num = 0 ; let nextNum = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) { count [ i ] [ 0 ] = 0 ; count [ i ] [ 1 ] = 1 ; } for ( k = 2 ; k <= n ; k ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { if ( keypad [ i ] [ j ] != "*" && keypad [ i ] [ j ] != "#" ) { num = keypad [ i ] [ j ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ; count [ num ] [ k ] = 0 ; for ( move = 0 ; move < 5 ; move ++ ) { ro = i + row [ move ] ; co = j + col [ move ] ; if ( ro >= 0 && ro <= 3 && co >= 0 && co <= 2 && keypad [ ro ] [ co ] != "*" && keypad [ ro ] [ co ] != "#" ) { nextNum = keypad [ ro ] [ co ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ; count [ num ] [ k ] += count [ nextNum ] [ k - 1 ] ; } } } } } } totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) totalCount += count [ i ] [ n ] ; return totalCount ; }
function getCount ( keypad , n ) { if ( keypad == null n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; var odd = Array . from ( { length : 10 } , ( _ , i ) => 0 ) ; var even = Array . from ( { length : 10 } , ( _ , i ) => 0 ) ; var i = 0 , j = 0 , useOdd = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) odd [ i ] = 1 ; for ( j = 2 ; j <= n ; j ++ ) { useOdd = 1 - useOdd ; if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } totalCount = 0 ; if ( useOdd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += odd [ i ] ; } return totalCount ; }
function finalCount ( n , sum ) { let ans = 0 ; for ( let i = 1 ; i <= 9 ; i ++ ) { if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; } return ans ; }
function finalCount ( n , sum ) { for ( let i = 0 ; i < 101 ; i ++ ) { lookup [ i ] = new Array ( 501 ) ; for ( let j = 0 ; j < 501 ; j ++ ) { lookup [ i ] [ j ] = - 1 ; } } let ans = 0 ; for ( let i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; }
function findCount ( n , sum ) { let start = Math . pow ( 10 , n - 1 ) ; let end = Math . pow ( 10 , n ) - 1 ; let count = 0 ; let i = start ; while ( i <= end ) { let cur = 0 ; let temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = parseInt ( temp / 10 ) ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } document . write ( count ) ; }
function countNonDecreasing ( n ) { let dp = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; } for ( let i = 0 ; i < 10 ; i ++ ) { for ( let j = 0 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( let digit = 0 ; digit <= 9 ; digit ++ ) { for ( let len = 2 ; len <= n ; len ++ ) { for ( let x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } let count = 0 ; for ( let i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }
function countNonDecreasing ( n ) { let N = 10 ; let count = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count = Math . floor ( count / i ) ; } return count ; }
function getMinSquares ( n ) { if ( n <= 3 ) return n ; let res = n ; for ( let x = 1 ; x <= n ; x ++ ) { let temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
function getMinSquares ( n ) { if ( n <= 3 ) return n ; var dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( var i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( var x = 1 ; x <= Math . ceil ( Math . sqrt ( i ) ) ; x ++ ) { var temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } var res = dp [ n ] ; return res ; }
function minCoins ( coins , m , v ) { let table = new Array ( V + 1 ) ; for ( let i = 0 ; i < V + 1 ; i ++ ) { table [ i ] = 0 ; } for ( let i = 1 ; i <= V ; i ++ ) { table [ i ] = Number . MAX_VALUE ; } for ( let i = 1 ; i <= V ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { let sub_res = table [ i - coins [ j ] ] ; if ( sub_res != Number . MAX_VALUE && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } if ( table [ V ] == Number . MAX_VALUE ) return - 1 ; return table [ V ] ; }
function superSeq ( X , Y , m , n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
function superSeq ( X , Y , m , n ) { var dp = Array ( m + 1 ) . fill ( 0 ) . map ( x => Array ( n + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) { for ( var j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
function sumOfDigitsFrom1ToN ( n ) { let result = 0 ; for ( let x = 1 ; x <= n ; x ++ ) result += sumOfDigits ( x ) ; return result ; }
function sumOfDigits ( x ) { let sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = parseInt ( x / 10 , 10 ) ; } return sum ; }
function sumOfDigitsFrom1ToN ( n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; let d = parseInt ( Math . log ( n ) / Math . log ( 10 ) , 10 ) ; let a = new Array ( d + 1 ) ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( let i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * parseInt ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) , 10 ) ; let p = parseInt ( Math . ceil ( Math . pow ( 10 , d ) ) , 10 ) ; let msd = parseInt ( n / p , 10 ) ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; }
function sumOfDigitsFrom1ToN ( n ) { var d = ( parseInt ) ( Math . log10 ( n ) ) ; var a = new Array ( d + 1 ) . fill ( 0 ) ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( var i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( parseInt ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; return sumOfDigitsFrom1ToNUtil ( n , a ) ; }
function countWays ( N ) { if ( N == 1 ) return 4 ; let countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( let i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } let result = countS + countB ; return ( result * result ) ; }
function findoptimal ( N ) { if ( N <= 6 ) return N ; let max = 0 ; let b ; for ( b = N - 3 ; b >= 1 ; b -- ) { let curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; }
function findoptimal ( N ) { if ( N <= 6 ) return N ; let screen = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { screen [ i ] = 0 ; } let b ; let n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { let curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }
function count ( n ) { let table = new Array ( n + 1 ) , i ; for ( let j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
function power ( x , y ) { var temp ; if ( y == 0 ) return 1 ; temp = power ( x , parseInt ( y / 2 ) ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
function getMedian ( ar1 , ar2 , n ) { var i = 0 ; var j = 0 ; var count ; var m1 = - 1 , m2 = - 1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] <= ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; }
function area ( x1 , y1 , x2 , y2 , x3 , y3 ) { return Math . abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; }
function isInside ( x1 , y1 , x2 , y2 , x3 , y3 , x , y ) { let A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) ; let A1 = area ( x , y , x2 , y2 , x3 , y3 ) ; let A2 = area ( x1 , y1 , x , y , x3 , y3 ) ; let A3 = area ( x1 , y1 , x2 , y2 , x , y ) ; return ( A == A1 + A2 + A3 ) ; }
function isLucky ( n ) { let counter = 2 ; let next_position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ; next_position -= Math . floor ( next_position / counter ) ; counter ++ ; return isLucky ( next_position ) ; }
function squareRoot ( n ) { let x = n ; let y = 1 ; let e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
function maxDiffUtil ( t , res ) { if ( t == null ) return Number . MAX_VALUE ; if ( t . left == null && t . right == null ) return t . key ; var val = Math . min ( maxDiffUtil ( t . left , res ) , maxDiffUtil ( t . right , res ) ) ; res . r = Math . max ( res . r , t . key - val ) ; return Math . min ( val , t . key ) ; }
function maxDiff ( root ) { res = new Res ( ) ; maxDiffUtil ( root , res ) ; return res . r ; }
function inorder ( root ) { if ( root != null ) { inorder ( root . left ) ; document . write ( root . key + "%d▁" ) ; inorder ( root . right ) ; } }
function pow ( a , b ) { if ( b == 0 ) return 1 ; var answer = a ; var increment = a ; var i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
function multiply ( x , y ) { if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; }
function pow ( a , b ) { if ( b > 0 ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; }
function getAvg ( prev_avg , x , n ) { return ( prev_avg * n + x ) / ( n + 1 ) ; }
function count ( n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; var po = 1 ; while ( parseInt ( n / po ) > 9 ) po = po * 10 ; var msd = parseInt ( n / po ) ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; }
function fact ( n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; }
function findSmallerInRight ( str , low , high ) { let countRight = 0 ; let i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str [ i ] < str [ low ] ) ++ countRight ; return countRight ; }
function findRank ( str ) { let len = ( str ) . length ; let mul = fact ( len ) ; let rank = 1 ; let countRight ; let i ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ; countRight = findSmallerInRight ( str , i , len - 1 ) ; rank += countRight * mul ; } return rank ; }
function printPascal ( n ) { for ( line = 1 ; line <= n ; line ++ ) { var C = 1 ; for ( i = 1 ; i <= line ; i ++ ) { document . write ( C + "▁" ) ; C = C * ( line - i ) / i ; } document . write ( "\n" ) ; } }
function exponential ( n , x ) { var sum = 1 ; for ( i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
function printCombination ( arr , n , r ) { let data = new Array ( r ) ; combinationUtil ( arr , n , r , 0 , data , 0 ) ; }
function myRand ( arr , freq , n ) { let prefix = [ ] ; let i ; prefix [ 0 ] = freq [ 0 ] ; for ( i = 1 ; i < n ; ++ i ) prefix [ i ] = prefix [ i - 1 ] + freq [ i ] ; let r = Math . floor ( ( Math . random ( ) * prefix [ n - 1 ] ) ) + 1 ; let indexc = findCeil ( prefix , r , 0 , n - 1 ) ; return arr [ indexc ] ; }
function isPerfectSquare ( x ) { let s = parseInt ( Math . sqrt ( x ) ) ; return ( s * s == x ) ; }
function isFibonacci ( n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
function findgroups ( arr , n ) { let c = [ 0 , 0 , 0 ] ; let i ; let res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * Math . floor ( ( c [ 0 ] - 2 ) ) / 6 ) ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * Math . floor ( ( c [ 1 ] - 2 ) ) / 6 ) ; res += ( Math . floor ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
function findTrailingZeros ( n ) { let count = 0 ; for ( let i = 5 ; Math . floor ( n / i ) >= 1 ; i *= 5 ) count += Math . floor ( n / i ) ; return count ; }
function catalan ( n ) { if ( n <= 1 ) return 1 ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ; return res ; }
function catalan ( n ) { c = binomialCoeff ( 2 * ( n ) , n ) ; return Math . floor ( c / ( n + 1 ) ) ; }
function catalan ( n ) { let cat_ = 1 ; document . write ( cat_ + "▁" ) ; for ( let i = 1 ; i < n ; i ++ ) { cat_ *= ( 4 * i - 2 ) ; cat_ /= ( i + 1 ) ; document . write ( cat_ + "▁" ) ; } }
function calcAngle ( h , m ) { if ( h < 0 m < 0 h > 12 m > 60 ) document . write ( "Wrong▁input" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; } let hour_angle = 0.5 * ( h * 60 + m ) ; let minute_angle = 6 * m ; let angle = Math . abs ( hour_angle - minute_angle ) ; angle = min ( 360 - angle , angle ) ; return angle ; }
function getInvCount ( arr ) { let inv_count = 0 ; for ( let i = 0 ; i < 2 ; i ++ ) { for ( let j = i + 1 ; j < 3 ; j ++ ) { if ( arr [ j ] [ i ] > 0 && arr [ j ] [ i ] > arr [ i ] [ j ] ) inv_count += 1 ; } } return inv_count ; }
function isSolvable ( puzzle ) { let invCount = getInvCount ( puzzle ) ; return ( invCount % 2 == 0 ) ; }
function find ( p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; }
function countSolutions ( n ) { let res = 0 ; for ( let x = 0 ; x * x < n ; x ++ ) { for ( let y = 0 ; x * x + y * y < n ; y ++ ) { res ++ ; } } return res ; }
function countSolutions ( n ) { let x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }
function func ( x ) { return x * x * x - x * x + 2 ; }
function regulaFalsi ( a , b ) { if ( func ( a ) * func ( b ) >= 0 ) { document . write ( "You▁have▁not▁assumed▁right▁a▁and▁b" ) ; return ; } let c = a ; for ( let i = 0 ; i < MAX_ITER ; i ++ ) { c = Math . floor ( ( a * func ( b ) - b * func ( a ) ) / ( func ( b ) - func ( a ) ) ) ; if ( func ( c ) == 0 ) { break ; } else if ( func ( c ) * func ( a ) < 0 ) { b = c ; } else { a = c ; } } document . write ( "The▁value▁of▁root▁is▁:▁" + c ) ; }
function func ( x ) { return x * x * x - x * x + 2 ; }
function derivFunc ( x ) { return 3 * x * x - 2 * x ; }
function newtonRaphson ( x ) { let h = func ( x ) / derivFunc ( x ) ; while ( Math . abs ( h ) >= EPSILON ) { h = func ( x ) / derivFunc ( x ) ; x = x - h ; } document . write ( "The▁value▁of▁the" + "▁root▁is▁:▁" + Math . round ( x * 100.0 ) / 100.0 ) ; }
function getSingle ( arr , n ) { let ones = 0 , twos = 0 ; let common_bit_mask ; for ( let i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
function oppositeSigns ( x , y ) { return ( ( x ^ y ) < 0 ) ; }
function countSetBits ( n ) { let bitCount = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { bitCount += countSetBitsUtil ( i ) ; } return bitCount ; }
function countSetBitsUtil ( x ) { if ( x <= 0 ) { return 0 ; } return ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( Math . floor ( x / 2 ) ) ; }
function swapBits ( num , p1 , p2 , n ) { let shift1 , shift2 , value1 , value2 ; while ( n -- > 0 ) { shift1 = 1 << p1 ; shift2 = 1 << p2 ; value1 = ( ( num & shift1 ) ) ; value2 = ( ( num & shift2 ) ) ; if ( ( value1 == 0 && value2 != 0 ) || ( value2 == 0 && value1 != 0 ) ) { if ( value1 != 0 ) { num = num & ( ~ shift1 ) ; num = num | shift2 ; } else { num = num & ( ~ shift2 ) ; num = num | shift1 ; } } p1 ++ ; p2 ++ ; } return num ; }
function Add ( x , y ) { while ( y != 0 ) { let carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
function smallest ( x , y , z ) { let c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }
function min ( x , y ) { return y + ( ( x - y ) & ( ( x - y ) >> ( 32 * CHAR_BIT - 1 ) ) ) }
function smallest ( x , y , z ) { return Math . min ( x , Math . min ( y , z ) ) ; }
function snoob ( x ) { let rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ; if ( x > 0 ) { rightOne = x & - x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
function addOne ( x ) { let m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
function addOne ( x ) { return ( - ( ~ x ) ) ; }
function fun ( n ) { return n & ( n - 1 ) ; }
function isPowerOfFour ( n ) { let count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
function isPowerOfFour ( n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ) ; }
function logn ( n , r ) { return Math . log ( n ) / Math . log ( r ) ; }
function findPostOrderUtil ( pre , n , minval , maxval , preIndex ) { if ( preIndex . data == n ) return ; if ( pre [ preIndex . data ] < minval pre [ preIndex . data ] > maxval ) { return ; } let val = pre [ preIndex . data ] ; preIndex . data ++ ; findPostOrderUtil ( pre , n , minval , val , preIndex ) ; findPostOrderUtil ( pre , n , val , maxval , preIndex ) ; document . write ( val + "▁" ) ; }
function findPostOrder ( pre , n ) { let preIndex = new INT ( 0 ) ; findPostOrderUtil ( pre , n , Number . MIN_VALUE , Number . MAX_VALUE , preIndex ) ; }
function getModulo ( n , d ) { return ( n & ( d - 1 ) ) ; }
function min ( x , y ) { return y ^ ( ( x ^ y ) & - ( x << y ) ) ; }
function max ( x , y ) { return x ^ ( ( x ^ y ) & - ( x << y ) ) ; }
function absbit32 ( x , y ) { var sub = x - y ; var mask = ( sub >> 31 ) ; return ( sub ^ mask ) - mask ; }
function max ( x , y ) { var abs = absbit32 ( x , y ) ; return ( x + y + abs ) / 2 ; }
function min ( x , y ) { var abs = absbit32 ( x , y ) ; return ( x + y - abs ) / 2 ; }
function getOddOccurrence ( arr , arr_size ) { for ( let i = 0 ; i < arr_size ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
function getOddOccurrence ( arr , n ) { let hmap = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( hmap . has ( arr [ i ] ) ) { let val = hmap . get ( arr [ i ] ) ; hmap . set ( arr [ i ] , val + 1 ) ; } else { hmap . set ( arr [ i ] , 1 ) ; } } for ( let [ key , value ] of hmap . entries ( ) ) { if ( hmap . get ( key ) % 2 != 0 ) return key ; } return - 1 ; }
function countWays ( N , K ) { return K * fastPow ( K - 1 , N - 1 ) ; }
function countSetBits ( n ) { var count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
function countSetBits ( n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
function initialize ( ) { BitsSetTable256 [ 0 ] = 0 ; for ( var i = 0 ; i < 256 ; i ++ ) { BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ parseInt ( i / 2 ) ] ; } }
function countSetBits ( N ) { var count = 0 ; for ( i = 0 ; i < 4 * 8 ; i ++ ) { if ( ( N & ( 1 << i ) ) != 0 ) count ++ ; } return count ; }
function countSetBits ( n ) { var count = 0 ; while ( n != 0 ) { count ++ ; n &= ( n - 1 ) ; } return count ; }
function FlippedCount ( a , b ) { return countSetBits ( a ^ b ) ; }
function nextPowerOf2 ( n ) { var count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
function nextPowerOf2 ( n ) { p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
function nextPowerOf2 ( n ) { n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n }
function getParity ( n ) { var parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
function isPowerOfTwo ( n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; }
function isPowerOfTwo ( x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
function getFirstSetBitPos ( n ) { return Math . log2 ( n & - n ) + 1 ; }
function Right_most_setbit ( num ) { let pos = 1 ; for ( let i = 0 ; i < INT_SIZE ; i ++ ) { if ( ( num & ( 1 << i ) ) == 0 ) pos ++ ; else break ; } return pos ; }
function bin ( n ) { let i ; document . write ( "0" ) ; for ( i = 1 << 30 ; i > 0 ; i = Math . floor ( i / 2 ) ) { if ( ( n & i ) != 0 ) { document . write ( "1" ) ; } else { document . write ( "0" ) ; } } }
function findPosition ( n ) { if ( isPowerOfTwo ( n ) == false ) return - 1 ; var i = 1 ; var pos = 1 ; while ( ( i & n ) == 0 ) { i = i << 1 ; pos += 1 ; } return pos ; }
function isPowerOfTwo ( n ) { return ( n && ( ! ( n & ( n - 1 ) ) ) ) }
function findPosition ( n ) { if ( ! isPowerOfTwo ( n ) ) return - 1  var count = 0  while ( n ) { n = n >> 1 count += 1 } return count }
function swap ( xp , yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }
function swap ( a , b ) { a = ( a & b ) + ( a b ) ; b = a + ( ~ b ) + 1 ; a = a + ( ~ b ) + 1 ; document . write ( "After▁swapping:▁a▁=▁" + a + ",▁b▁=▁" + b ) ; }
function checkSentence ( str ) { var len = str . length ; if ( str [ 0 ] . charCodeAt ( 0 ) < "A" . charCodeAt ( 0 ) || str [ 0 ] . charCodeAt ( 0 ) > "Z" . charCodeAt ( 0 ) ) return false ; if ( str [ len - 1 ] !== "." ) return false ; var prev_state = 0 , curr_state = 0 ; var index = 1 ; while ( index <= str . length ) { if ( str [ index ] . charCodeAt ( 0 ) >= "A" . charCodeAt ( 0 ) && str [ index ] . charCodeAt ( 0 ) <= "Z" . charCodeAt ( 0 ) ) curr_state = 0 ; else if ( str [ index ] === "▁" ) curr_state = 1 ; else if ( str [ index ] . charCodeAt ( 0 ) >= "a" . charCodeAt ( 0 ) && str [ index ] . charCodeAt ( 0 ) <= "z" . charCodeAt ( 0 ) ) curr_state = 2 ; else if ( str [ index ] === "." ) curr_state = 3 ; if ( prev_state === curr_state && curr_state !== 2 ) return false ; if ( prev_state === 2 && curr_state === 0 ) return false ; if ( curr_state === 3 && prev_state !== 1 ) return index + 1 == str . length ; index ++ ; prev_state = curr_state ; } return false ; }
function maxOnesIndex ( arr , n ) { let max_count = 0 ; let max_index = 0 ; let prev_zero = - 1 ; let prev_prev_zero = - 1 ; for ( let curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }
function findLength ( arr , n ) { let max_len = 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let mn = arr [ i ] , mx = arr [ i ] ; for ( let j = i + 1 ; j < n ; j ++ ) { mn = min ( mn , arr [ j ] ) ; mx = max ( mx , arr [ j ] ) ; if ( ( mx - mn ) == j - i ) max_len = Math . max ( max_len , mx - mn + 1 ) ; } } return max_len ; }
function isSubSequence ( str1 , str2 , m , n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
function segregate0and1 ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count ++ ; } for ( let i = 0 ; i < count ; i ++ ) arr [ i ] = 0 ; for ( let i = count ; i < n ; i ++ ) arr [ i ] = 1 ; }
function find3Numbers ( nums ) { if ( nums . length < 3 ) { document . write ( "No▁such▁triplet▁found" ) ; return ; } let seq = 1 ; let min_num = nums [ 0 ] ; let max_seq = Number . MIN_VALUE ; let store_min = min_num ; for ( let i = 1 ; i < nums . length ; i ++ ) { if ( nums [ i ] == min_num ) continue ; else if ( nums [ i ] < min_num ) { min_num = nums [ i ] ; continue ; } else if ( nums [ i ] < max_seq ) { max_seq = nums [ i ] ; store_min = min_num ; } else if ( nums [ i ] > max_seq ) { seq ++ ; if ( seq == 3 ) { document . write ( "Triplet:▁" + store_min + ",▁" + max_seq + ",▁" + nums [ i ] ) ; return ; } max_seq = nums [ i ] ; } } document . write ( "No▁such▁triplet▁found" ) ; }
function maxCircularSum ( a , n ) { if ( n == 1 ) return a [ 0 ] ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } let curr_max = a [ 0 ] , max_so_far = a [ 0 ] , curr_min = a [ 0 ] , min_so_far = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { curr_max = Math . max ( curr_max + a [ i ] , a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; curr_min = Math . min ( curr_min + a [ i ] , a [ i ] ) ; min_so_far = Math . min ( min_so_far , curr_min ) ; } if ( min_so_far == sum ) return max_so_far ; return Math . max ( max_so_far , sum - min_so_far ) ; }
function GetCeilIndex ( arr , T , l , r , key ) { while ( r - l > 1 ) { let m = l + parseInt ( ( r - l ) / 2 , 10 ) ; if ( arr [ T [ m ] ] >= key ) r = m ; else l = m ; } return r ; }
function generateUtil ( A , B , C , i , j , m , n , len , flag ) { if ( flag ) { if ( len != 0 ) printArr ( C , len + 1 ) ; for ( var k = i ; k < m ; k ++ ) { if ( len == 0 ) { C [ len ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len , ! flag ) ; } else if ( A [ k ] > C [ len ] ) { C [ len + 1 ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len + 1 , ! flag ) ; } } } else { for ( var l = j ; l < n ; l ++ ) { if ( B [ l ] > C [ len ] ) { C [ len + 1 ] = B [ l ] ; generateUtil ( A , B , C , i , l + 1 , m , n , len + 1 , ! flag ) ; } } } }
function generate ( A , B , m , n ) { var C = Array ( m + n ) . fill ( 0 ) ; generateUtil ( A , B , C , 0 , 0 , m , n , 0 , true ) ; }
function printArr ( arr , n ) { for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; document . write ( "" ) ; }
function replace_elements ( arr , n ) { let pos = 0 ; for ( let i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( let i = 0 ; i < pos ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function arrangeString ( str , x , y ) { let count_0 = 0 ; let count_1 = 0 ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] == "0" ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 count_1 > 0 ) { for ( let j = 0 ; j < x && count_0 > 0 ; j ++ ) { if ( count_0 > 0 ) { document . write ( "0" ) ; count_0 -- ; } } for ( let j = 0 ; j < y && count_1 > 0 ; j ++ ) { if ( count_1 > 0 ) { document . write ( "1" ) ; count_1 -- ; } } } }
function maxDiff ( arr , arr_size ) { let max_diff = arr [ 1 ] - arr [ 0 ] ; for ( let i = 0 ; i < arr_size ; i ++ ) { for ( let j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; }
function maxDiff ( arr , n ) { let maxDiff = - 1 ; let maxRight = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { let diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; }
function maxDiff ( arr , n ) { let diff = arr [ 1 ] - arr [ 0 ] ; let curr_sum = diff ; let max_sum = curr_sum ; for ( let i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }
function maxIndexDiff ( arr , n ) { let maxDiff = - 1 ; let i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; }
function findMaximum ( arr , low , high ) { var max = arr [ low ] ; var i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; }
function findMaximum ( arr , low , high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; return findMaximum ( arr , mid + 1 , high ) ; }
function constructLowerArray ( arr , countSmaller , n ) { let i , j ; for ( i = 0 ; i < n ; i ++ ) countSmaller [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < arr [ i ] ) countSmaller [ i ] ++ ; } } }
function printArray ( arr , size ) { let i ; for ( i = 0 ; i < size ; i ++ ) document . write ( arr [ i ] + "▁" ) ; document . write ( "" ) ; }
function findMissingPositive ( arr , size ) { let i ; for ( i = 0 ; i < size ; i ++ ) { let x = Math . abs ( arr [ i ] ) ; if ( x - 1 < size && arr [ x - 1 ] > 0 ) arr [ x - 1 ] = - arr [ x - 1 ] ; } for ( i = 0 ; i < size ; i ++ ) if ( arr [ i ] > 0 ) return i + 1 ; return size + 1 ; }
function findMissing ( arr , size ) { let shift = segregate ( arr , size ) ; let arr2 = new Array ( size - shift ) ; let j = 0 ; for ( let i = shift ; i < size ; i ++ ) { arr2 [ j ] = arr [ i ] ; j ++ ; } return findMissingPositive ( arr2 , j ) ; }
function fillDepth ( parent , i , depth ) { if ( depth [ i ] != 0 ) { return ; } if ( parent [ i ] == - 1 ) { depth [ i ] = 1 ; return ; } if ( depth [ parent [ i ] ] == 0 ) { fillDepth ( parent , parent [ i ] , depth ) ; } depth [ i ] = depth [ parent [ i ] ] + 1 ; }
function maxRepeating ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; let max = arr [ 0 ] , result = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }
function maxPathSum ( ar1 , ar2 , m , n ) { let i = 0 , j = 0 ; let result = 0 , sum1 = 0 , sum2 = 0 ; while ( i < m && j < n ) { if ( ar1 [ i ] < ar2 [ j ] ) sum1 += ar1 [ i ++ ] ; else if ( ar1 [ i ] > ar2 [ j ] ) sum2 += ar2 [ j ++ ] ; else { result += Math . max ( sum1 , sum2 ) + ar1 [ i ] ; sum1 = 0 ; sum2 = 0 ; i ++ ; j ++ ; } } while ( i < m ) sum1 += ar1 [ i ++ ] ; while ( j < n ) sum2 += ar2 [ j ++ ] ; result += Math . max ( sum1 , sum2 ) ; return result ; }
function smallestGreater ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { let diff = Number . MAX_VALUE ; let closest = - 1 ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } if ( closest == - 1 ) document . write ( "_▁" ) ; else document . write ( arr [ closest ] + "▁" ) ; } }
function smallestGreater ( arr , n ) { let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) s . add ( arr [ i ] ) ; let newAr = [ ] ; for ( let p of s . values ( ) ) { newAr . push ( p ) ; } newAr . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < n ; i ++ ) { let temp = lowerBound ( newAr , 0 , newAr . length , arr [ i ] ) ; if ( temp < n ) document . write ( newAr [ temp ] + "▁" ) ; else document . write ( "_▁" ) ; } }
function arraySum ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum ; }
function maxDiff ( arr , n , k ) { arr . sort ( ( a , b ) => a - b ) ; var arraysum = arraySum ( arr , n ) ; var diff1 = Math . abs ( arraysum - 2 * arraySum ( arr , k ) ) ; arr . reverse ( ) ; var diff2 = Math . abs ( arraysum - 2 * arraySum ( arr , k ) ) ; return ( Math . max ( diff1 , diff2 ) ) ; }
function minNumber ( a , n , x ) { a . sort ( ) ; let k ; for ( k = 0 ; a [ parseInt ( ( n - 1 ) / 2 , 10 ) ] != x ; k ++ ) { a [ n ++ ] = x ; a . sort ( ) ; } return k ; }
function minNumber ( a , n , x ) { let l = 0 , h = 0 , e = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } let ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; }
function fun ( x ) { let y = parseInt ( x / 4 ) * 4 ; let ans = 0 ; for ( let i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; }
function query ( x ) { if ( x == 0 ) return 0 ; let k = parseInt ( ( x + 1 ) / 2 ) ; return ( x %= 2 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; }
function preprocess ( arr , N , left , right ) { left [ 0 ] = 0 ; let lastIncr = 0 ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) lastIncr = i ; left [ i ] = lastIncr ; } right [ N - 1 ] = N - 1 ; let firstDecr = N - 1 ; for ( let i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > arr [ i + 1 ] ) firstDecr = i ; right [ i ] = firstDecr ; } }
function isSubarrayMountainForm ( arr , left , right , L , R ) { return ( right [ L ] >= left [ R ] ) ; }
function sieveOfEratosthenes ( isPrime ) { isPrime [ 1 ] = false ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( let i = p * 2 ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } }
function getMid ( s , e ) { return Math . floor ( s + ( e - s ) / 2 ) ; }
function queryPrimesUtil ( st , ss , se , qs , qe , index ) { if ( qs <= ss && qe >= se ) return st [ index ] ; if ( se < qs ss > qe ) return 0 ; let mid = getMid ( ss , se ) ; return queryPrimesUtil ( st , ss , mid , qs , qe , 2 * index + 1 ) + queryPrimesUtil ( st , mid + 1 , se , qs , qe , 2 * index + 2 ) ; }
function updateValueUtil ( st , ss , se , i , diff , si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff ; if ( se != ss ) { let mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } }
function updateValue ( arr , st , n , i , new_val , isPrime ) { if ( i < 0 i > n - 1 ) { document . write ( "Invalid▁Input" ) ; return ; } let diff = 0 ; let oldValue ; oldValue = arr [ i ] ; arr [ i ] = new_val ; if ( isPrime [ oldValue ] && isPrime [ new_val ] ) return ; if ( ( ! isPrime [ oldValue ] ) && ( ! isPrime [ new_val ] ) ) return ; if ( isPrime [ oldValue ] && ! isPrime [ new_val ] ) { diff = - 1 ; } if ( ! isPrime [ oldValue ] && isPrime [ new_val ] ) { diff = 1 ; } updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; }
function constructSTUtil ( arr , ss , se , st , si , isPrime ) { if ( ss == se ) { if ( isPrime [ arr [ ss ] ] ) st [ si ] = 1 ; else st [ si ] = 0 ; return st [ si ] ; } let mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 , isPrime ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 , isPrime ) ; return st [ si ] ; }
function checkEVENodd ( arr , n , l , r ) { if ( arr [ r ] == 1 ) document . write ( "odd" ) ; else document . write ( "even" ) ; }
function findMean ( arr , l , r ) { let sum = 0 , count = 0 ; for ( let i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } let mean = Math . floor ( sum / count ) ; return mean ; }
function calculatePrefixSum ( arr , n ) { prefixSum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ; }
function findMean ( l , r ) { if ( l == 0 ) return parseInt ( Math . floor ( prefixSum [ r ] / ( r + 1 ) ) , 10 ) ; return parseInt ( Math . floor ( ( prefixSum [ r ] - prefixSum [ l - 1 ] ) / ( r - l + 1 ) ) , 10 ) ; }
function updateQuery ( arr , n , q , l , r , k ) { if ( q == 0 ) { arr [ l - 1 ] += k ; arr [ r ] += - k ; } else { arr [ l - 1 ] += - k ; arr [ r ] += k ; } return ; }
function generateArray ( arr , n ) { for ( i = 1 ; i < n ; ++ i ) arr [ i ] += arr [ i - 1 ] ; }
function calculateProduct ( A , L , R , P ) { L = L - 1 ; R = R - 1 ; let ans = 1 ; for ( let i = L ; i <= R ; i ++ ) { ans = ans * A [ i ] ; ans = ans % P ; } return ans ; }
function modInverse ( a , m ) { let m0 = m , t , q ; let x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = parseInt ( a / m , 10 ) ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
function calculate_Pre_Product ( A , N , P ) { pre_product [ 0 ] = A [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { pre_product [ i ] = pre_product [ i - 1 ] * A [ i ] ; pre_product [ i ] = pre_product [ i ] % P ; } }
function calculate_inverse_product ( A , N , P ) { inverse_product [ 0 ] = modInverse ( pre_product [ 0 ] , P ) ; for ( let i = 1 ; i < N ; i ++ ) inverse_product [ i ] = modInverse ( pre_product [ i ] , P ) ; }
function calculateProduct ( A , L , R , P ) { L = L - 1 ; R = R - 1 ; let ans ; if ( L == 0 ) ans = pre_product [ R ] ; else ans = pre_product [ R ] * inverse_product [ L - 1 ] ; return ans ; }
function buildPrefix ( ) { let prime = [ ] ; for ( let p = 1 ; p <= MAX + 1 ; p ++ ) { prime [ p ] = true ; } for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( let p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] ) prefix [ p ] ++ ; } }
function query ( L , R ) { return prefix [ R ] - prefix [ L - 1 ] ; }
function command ( arr , a , b ) { arr [ a ] ^= 1 ; arr [ b + 1 ] ^= 1 ; }
function incrementByD ( arr , q_arr , n , m , d ) { let sum = new Array ( n ) ; for ( let i = 0 ; i < sum . length ; i ++ ) { sum [ i ] = 0 ; } for ( let i = 0 ; i < m ; i ++ ) { sum [ q_arr [ i ] . start ] += d ; if ( ( q_arr [ i ] . end + 1 ) < n ) sum [ q_arr [ i ] . end + 1 ] -= d ; } arr [ 0 ] += sum [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { sum [ i ] += sum [ i - 1 ] ; arr [ i ] += sum [ i ] ; } }
function printArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function probability ( a , b , size1 , size2 ) { let max1 = Number . MIN_VALUE , count1 = 0 ; for ( let i = 0 ; i < size1 ; i ++ ) { if ( a [ i ] > max1 ) { max1 = a [ i ] ; count1 = 1 ; } else if ( a [ i ] == max1 ) { count1 ++ ; } } let max2 = Number . MIN_VALUE , count2 = 0 ; for ( let i = 0 ; i < size2 ; i ++ ) { if ( b [ i ] > max2 ) { max2 = b [ i ] ; count2 = 1 ; } else if ( b [ i ] == max2 ) { count2 ++ ; } } return ( count1 * count2 ) / ( size1 * size2 ) ; }
function countDe ( arr , n ) { let v = [ ] ; for ( let i = 0 ; i < n ; i ++ ) v [ i ] = arr [ i ] ; arr . sort ( ) ; let count1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; arr . reverse ( ) ; let count2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( Math . min ( count1 , count2 ) ) ; }
function printMinimumProduct ( arr , n ) { let first_min = Math . min ( arr [ 0 ] , arr [ 1 ] ) ; let second_min = Math . max ( arr [ 0 ] , arr [ 1 ] ) ; for ( let i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; }
function noOfTriples ( arr , n ) { arr . sort ( ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; }
function checkReverse ( arr , n ) { let temp = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ i ] ; } temp . sort ( ) ; let front ; for ( front = 0 ; front < n ; front ++ ) { if ( temp [ front ] != arr [ front ] ) { break ; } } let back ; for ( back = n - 1 ; back >= 0 ; back -- ) { if ( temp [ back ] != arr [ back ] ) { break ; } } if ( front >= back ) { return true ; } do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) { return false ; } } while ( front != back ) ; return true ; }
function checkReverse ( arr , n ) { if ( n == 1 ) return true ; let i ; for ( i = 1 ; i < n && arr [ i - 1 ] < arr [ i ] ; i ++ ) ; if ( i == n ) return true ; let j = i ; while ( j < n && arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) return false ; j ++ ; } if ( j == n ) return true ; let k = j ; if ( arr [ k ] < arr [ i - 1 ] ) return false ; while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) return false ; k ++ ; } return true ; }
function sortExceptUandL ( a , l , u , n ) { let b = [ ] ; for ( let i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; b . sort ( ) ; for ( let i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
function findMinSwaps ( arr , n ) { let noOfZeroes = [ ] ; let i , count = 0 ; noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; }
function printList ( head ) { while ( head != null ) { document . write ( head . data + "->" ) ; head = head . next ; } }
function sortlist ( arr , N , head ) { var hash = new Map ( ) ; var temp = head ; while ( temp != null ) { if ( hash . has ( temp . data ) ) hash . set ( temp . data , hash . get ( temp . data ) + 1 ) ; else hash . set ( temp . data , 1 ) ; temp = temp . next ; } temp = head ; for ( var i = 0 ; i < N ; i ++ ) { var frequency = hash . get ( arr [ i ] ) ; while ( frequency -- > 0 ) { temp . data = arr [ i ] ; temp = temp . next ; } } }
function printRepeating ( arr , size ) { var s = new Set ( arr ) ; [ ... s ] . sort ( ( a , b ) => a - b ) . forEach ( x => { document . write ( x + "▁" ) } ) ; }
function min_noOf_operation ( arr , n , k ) { let noOfSubtraction ; let res = 0 ; for ( let i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }
function maxSum ( arr , n ) { arr . sort ( ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }
function countPairs ( a , n , k ) { a . sort ( ( a , b ) => a - b ) ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; }
function sortedMerge ( a , b , res , n , m ) { a . sort ( ( a , b ) => a - b ) ; b . sort ( ( a , b ) => a - b ) ; let i = 0 , j = 0 , k = 0 ; while ( i < n && j < m ) { if ( a [ i ] <= b [ j ] ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } else { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } } while ( i < n ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } while ( j < m ) { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } }
function findMaxPairs ( a , b , n , k ) { a . sort ( function ( c , d ) { return c - d ; } ) ; b . sort ( function ( c , d ) { return c - d ; } )  let flag = new Array ( n ) ; for ( let i = 0 ; i < flag . length ; i ++ ) { flag [ i ] = false ; } let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( Math . abs ( a [ i ] - b [ j ] ) <= k && flag [ j ] == false ) { result ++ ; flag [ j ] = true ; break ; } } } return result ; }
function findMaxPairs ( a , b , n , k ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let result = 0 ; for ( let i = 0 , j = 0 ; i < n && j < n ; ) { if ( Math . abs ( a [ i ] - b [ j ] ) <= k ) { result ++ ; i ++ ; j ++ ; } else if ( a [ i ] > b [ j ] ) j ++ ; else i ++ ; } return result ; }
function sumOfMinAbsDifferences ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let sum = 0 ; sum += Math . abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += Math . abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( let i = 1 ; i < n - 1 ; i ++ ) sum += Math . min ( Math . abs ( arr [ i ] - arr [ i - 1 ] ) , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; }
function findSmallestDifference ( A , B , m , n ) { A . sort ( ( a , b ) => a - b ) ; B . sort ( ( a , b ) => a - b ) ; let a = 0 , b = 0 ; let result = Number . MAX_SAFE_INTEGER ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
function arraySortedOrNot ( arr , n ) { if ( n == 0 n == 1 ) return true ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
function findLarger ( arr , n ) { arr . sort ( ) ; for ( let i = n - 1 ; i >= n / 2 ; i -- ) document . write ( arr [ i ] + "▁" ) ; }
function minSwapsToSort ( arr , n ) { let arrPos = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { arrPos . push ( [ arr [ i ] , i ] ) ; } arrPos . sort ( function ( a , b ) { return a [ 0 ] - b [ 0 ] ; } ) ; let vis = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { vis [ i ] = false ; } let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( vis [ i ] arrPos [ i ] [ 1 ] == i ) continue ; let cycle_size = 0 ; let j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arrPos [ j ] [ 1 ] ; cycle_size ++ ; } ans += ( cycle_size - 1 ) ; } return ans ; }
function minSwapToMakeArraySame ( a , b , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { mp . set ( b [ i ] , i ) ; } for ( let i = 0 ; i < n ; i ++ ) b [ i ] = mp . get ( a [ i ] ) ; return minSwapsToSort ( b , n ) ; }
function singleelement ( arr , n ) { let low = 0 , high = n - 2 ; let mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == arr [ mid ^ 1 ] ) { low = mid + 1 ; } else { high = mid - 1 ; } } return arr [ low ] ; }
function getMissingNo ( a , n ) { let n_elements_sum = Math . floor ( n * ( n + 1 ) / 2 ) ; let sum = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) sum += a [ i ] ; return n_elements_sum - sum ; }
function countOccurrences ( arr , n , x ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( x == arr [ i ] ) res ++ ; } return res ; }
function binarySearch ( arr , l , r , x ) { if ( r < l ) return - 1 ; var mid = l + parseInt ( ( r - l ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; }
function countOccurrences ( arr , n , x ) { var ind = binarySearch ( arr , 0 , n - 1 , x ) ; if ( ind == - 1 ) return 0 ; var count = 1 ; var left = ind - 1 ; while ( left >= 0 && arr [ left ] == x ) count ++ , left -- ; var right = ind + 1 ; while ( right < n && arr [ right ] == x ) count ++ , right ++ ; return count ; }
function printClosest ( arr , n , x ) { let res_l = 0 , res_r = 0 ; let l = 0 , r = n - 1 , diff = Number . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } document . write ( "▁The▁closest▁pair▁is▁" + arr [ res_l ] + "▁and▁" + arr [ res_r ] ) ; }
function countOnes ( arr , low , high ) { if ( high >= low ) { let mid = Math . trunc ( low + ( high - low ) / 2 ) ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
function findMissingUtil ( arr1 , arr2 , N ) { if ( N == 1 ) return arr1 [ 0 ] ; if ( arr1 [ 0 ] != arr2 [ 0 ] ) return arr1 [ 0 ] ; let lo = 0 , hi = N - 1 ; while ( lo < hi ) { let mid = parseInt ( ( lo + hi ) / 2 , 10 ) ; if ( arr1 [ mid ] == arr2 [ mid ] ) lo = mid ; else hi = mid ; if ( lo == hi - 1 ) break ; } return arr1 [ hi ] ; }
function printTwoElements ( arr , size ) { var i ; document . write ( "The▁repeating▁element▁is▁" ) ; for ( i = 0 ; i < size ; i ++ ) { var abs_value = Math . abs ( arr [ i ] ) ; if ( arr [ abs_value - 1 ] > 0 ) arr [ abs_value - 1 ] = - arr [ abs_value - 1 ] ; else document . write ( abs_value ) ; } document . write ( "And▁the▁missing▁element▁is▁" ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) document . write ( i + 1 ) ; } }
function findFourElements ( A , n , X ) { for ( let i = 0 ; i < n - 3 ; i ++ ) { for ( let j = i + 1 ; j < n - 2 ; j ++ ) { for ( let k = j + 1 ; k < n - 1 ; k ++ ) { for ( let l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) document . write ( A [ i ] + "▁" + A [ j ] + "▁" + A [ k ] + "▁" + A [ l ] ) ; } } } }
function findFourElements ( arr , n , X ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) mp . set ( arr [ i ] + arr [ j ] , [ i , j ] ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { let sum = arr [ i ] + arr [ j ] ; if ( mp . has ( X - sum ) ) { let p = mp . get ( X - sum ) ; if ( p [ 0 ] != i && p [ 0 ] != j && p [ 1 ] != i && p [ 1 ] != j ) { document . write ( arr [ i ] + ",▁" + arr [ j ] + ",▁" + arr [ p [ 0 ] ] + ",▁" + arr [ p [ 1 ] ] ) ; return ; } } } } }
function findMajority ( arr , n ) { return arr [ Math . floor ( n / 2 ) ] ; }
function minAdjDifference ( arr , n ) { if ( n < 2 ) return ; let res = Math . abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( let i = 2 ; i < n ; i ++ ) res = Math . min ( res , Math . abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = Math . min ( res , Math . abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; document . write ( "Min▁Difference▁=▁" + res ) ; }
function getMin ( arr , n ) { return Math . min . apply ( Math , arr ) ; }
function getMax ( arr , n ) { return Math . max . apply ( Math , arr ) ; }
function deleteElement ( arr , n , x ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( let j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; }
function deleteElement ( arr , n , x ) { if ( arr [ n - 1 ] == x ) return ( n - 1 ) ; let prev = arr [ n - 1 ] , i ; for ( i = n - 2 ; i >= 0 && arr [ i ] != x ; i -- ) { let curr = arr [ i ] ; arr [ i ] = prev ; prev = curr ; } if ( i < 0 ) return 0 ; arr [ i ] = prev ; return ( n - 1 ) ; }
function maxWater ( arr , n ) { let res = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { let left = arr [ i ] ; for ( let j = 0 ; j < i ; j ++ ) { left = Math . max ( left , arr [ j ] ) ; } let right = arr [ i ] ; for ( let j = i + 1 ; j < n ; j ++ ) { right = Math . max ( right , arr [ j ] ) ; } res += Math . min ( left , right ) - arr [ i ] ; } return res ; }
function findWater ( arr , n ) { let result = 0 ; let left_max = 0 , right_max = 0 ; let lo = 0 , hi = n - 1 ; while ( lo <= hi ) { if ( arr [ lo ] < arr [ hi ] ) { if ( arr [ lo ] > left_max ) left_max = arr [ lo ] ; else result += left_max - arr [ lo ] ; lo ++ ; } else { if ( arr [ hi ] > right_max ) right_max = arr [ hi ] ; else result += right_max - arr [ hi ] ; hi -- ; } } return result ; }
function maxWater ( arr , n ) { let size = n - 1 ; let prev = arr [ 0 ] ; let prev_index = 0 ; let water = 0 ; let temp = 0 ; for ( let i = 1 ; i <= size ; i ++ ) { if ( arr [ i ] >= prev ) { prev = arr [ i ] ; prev_index = i ; temp = 0 ; } else { water += prev - arr [ i ] ; temp += prev - arr [ i ] ; } } if ( prev_index < size ) { water -= temp ; prev = arr [ size ] ; for ( let i = size ; i >= prev_index ; i -- ) { if ( arr [ i ] >= prev ) { prev = arr [ i ] ; } else { water += prev - arr [ i ] ; } } } return water ; }
function maxWater ( arr , n ) { let left = 0 ; let right = n - 1 ; let l_max = 0 ; let r_max = 0 ; let result = 0 ; while ( left <= right ) { if ( r_max <= l_max ) { result += Math . max ( 0 , r_max - arr [ right ] ) ; r_max = Math . max ( r_max , arr [ right ] ) ; right -= 1 ; } else { result += Math . max ( 0 , l_max - arr [ left ] ) ; l_max = Math . max ( l_max , arr [ left ] ) ; left += 1 ; } } return result ; }
function missingK ( a , k , n ) { let difference = 0 , ans = 0 , count = k ; let flag = false ; for ( let i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return - 1 ; }
function leastFrequent ( arr , n ) { arr . sort ( ) ; let min_count = n + 1 , res = - 1 ; let curr_count = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ n - 1 ] ; } return res ; }
function leastFrequent ( arr , n ) { var hash = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( hash . has ( arr [ i ] ) ) hash . set ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) else hash . set ( arr [ i ] , 1 ) ; } var min_count = n + 1 , res = - 1 ; hash . forEach ( ( value , key ) => { if ( min_count >= value ) { res = key ; min_count = value ; } } ) ; return res ; }
function maximumSum ( a , n ) { let prev = Math . max ( a [ n - 1 ] [ 0 ] , a [ n - 1 ] [ M - 1 ] + 1 ) ; let sum = prev ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let max_smaller = Number . MIN_VALUE ; for ( let j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev && a [ i ] [ j ] > max_smaller ) max_smaller = a [ i ] [ j ] ; } if ( max_smaller == Number . MIN_VALUE ) return 0 ; prev = max_smaller ; sum += max_smaller ; } return sum ; }
function maximumSum ( a , n ) { let prev = Math . max ( a [ n - 1 ] [ 0 ] , a [ n - 1 ] [ M - 1 ] + 1 ) ; let sum = prev ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let max_smaller = Number . MIN_VALUE ; for ( let j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev && a [ i ] [ j ] > max_smaller ) max_smaller = a [ i ] [ j ] ; } if ( max_smaller == Number . MIN_VALUE ) return 0 ; prev = max_smaller ; sum += max_smaller ; } return sum ; }
function findValue ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == k ) k *= 2 ; return k ; }
function findSmallest ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] >= 1 ) break ; if ( j == n ) return a [ i ] ; } return - 1 ; }
function findSmallest ( a , n ) { let smallest = min_element ( a ) ; for ( let i = 1 ; i < n ; i ++ ) if ( a [ i ] % smallest >= 1 ) return - 1 ; return smallest ; }
function CalculateMax ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let min_sum = arr [ 0 ] + arr [ 1 ] ; let max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return ( Math . abs ( max_sum - min_sum ) ) ; }
function printMinDiffPairs ( arr , n ) { if ( n <= 1 ) return ; arr . sort ( ) ; let minDiff = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) minDiff = Math . min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) { document . write ( "(" + arr [ i - 1 ] + ",▁" + arr [ i ] + "),▁" ) ; } } }
function calculateDiff ( i , j , array ) { return Math . abs ( array [ i ] - array [ j ] ) + Math . abs ( i - j ) ; }
function extrema ( a , n ) { let count = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) count += 1 ; if ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) count += 1 ; } return count ; }
function getClosest ( val1 , val2 , target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; }
function sum ( a , n ) { let maxVal = a [ 0 ] , maxCount = 1 ; let secondMax = Number . MIN_VALUE ; let secondMaxCount = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] == maxVal ) maxCount ++ ; else if ( a [ i ] > maxVal ) { secondMax = maxVal ; secondMaxCount = maxCount ; maxVal = a [ i ] ; maxCount = 1 ; } else if ( a [ i ] == secondMax ) { secondMax = a [ i ] ; secondMaxCount ++ ; } else if ( a [ i ] > secondMax ) { secondMax = a [ i ] ; secondMaxCount = 1 ; } } if ( maxCount > 1 ) return maxCount * parseInt ( ( maxCount - 1 ) / 2 , 10 ) ; return secondMaxCount ; }
function printSmall ( arr , asize , n ) { let copy_arr = [ ... arr ] ; copy_arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < asize ; ++ i ) { if ( arr [ i ] < copy_arr [ n ] ) document . write ( arr [ i ] + "▁" ) ; } }
function printKMissing ( arr , n , k ) { arr . sort ( ( a , b ) => a - b ) ; let i = 0 ; while ( i < n && arr [ i ] <= 0 ) i ++ ; let count = 0 , curr = 1 ; while ( count < k && i < n ) { if ( arr [ i ] != curr ) { document . write ( curr + "▁" ) ; count ++ ; } else i ++ ; curr ++ ; } while ( count < k ) { document . write ( curr , "▁" ) ; curr ++ ; count ++ ; } }
function printmissingk ( arr , n , k ) { let d = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) d . set ( arr [ i ] , arr [ i ] ) ; let cnt = 1 ; let fl = 0 ; for ( let i = 0 ; i < ( n + k ) ; i ++ ) { if ( ! d . has ( cnt ) ) { fl += 1 ; document . write ( cnt + "▁" ) ; if ( fl == k ) break ; } cnt += 1 ; } }
function checkIsAP ( arr , n ) { if ( n == 1 ) return true ; arr . sort ( ( a , b ) => a - b ) ; let d = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
function minProductSubset ( a , n ) { if ( n == 1 ) return a [ 0 ] ; let negmax = Number . MIN_VALUE ; let posmin = Number . MIN_VALUE ; let count_neg = 0 , count_zero = 0 ; let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; negmax = Math . max ( negmax , a [ i ] ) ; } if ( a [ i ] > 0 && a [ i ] < posmin ) { posmin = a [ i ] ; } product *= a [ i ] ; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return posmin ; if ( count_neg % 2 == 0 && count_neg != 0 ) { product = parseInt ( product / negmax , 10 ) ; } return product ; }
function countPairs ( a , n ) { let mn = Number . MAX_VALUE ; let mx = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { mn = Math . min ( mn , a [ i ] ) ; mx = Math . max ( mx , a [ i ] ) ; } let c1 = 0 ; let c2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; } if ( mn == mx ) return n * ( n - 1 ) / 2 ; else return c1 * c2 ; }
function findElement ( a , n , b ) { a . sort ( ( a , b ) => a - b ) ; let max = a [ n - 1 ] ; while ( b < max ) { if ( binary_search ( a , a + n , b ) ) b *= 2 ; else return b ; } return b ; }
function printList ( node ) { while ( node != null ) { document . write ( node . data + "▁" ) ; node = node . next ; } document . write ( ) ; }
function rearrangeOddEven ( head ) { var odd = [ ] ; var even = [ ] ; var i = 1 ; while ( head != null ) { if ( head . data % 2 != 0 && i % 2 == 0 ) { odd . push ( head ) ; } else if ( head . data % 2 == 0 && i % 2 != 0 ) { even . push ( head ) ; } head = head . next ; i ++ ; } while ( odd . length > 0 && even . length > 0 ) { var k = odd [ odd . length - 1 ] . data ; odd [ odd . length - 1 ] . data = even [ even . length - 1 ] . data ; even [ even . length - 1 ] . data = k ; odd . pop ( ) ; even . pop ( ) ; } }
function printList ( node ) { while ( node != null ) { document . write ( node . data + "▁" ) ; node = node . next ; } }
function display ( head ) { let curr = head ; while ( curr != null ) { document . write ( curr . data + "%d▁" ) ; curr = curr . next ; } }
function addWithCarry ( head ) { if ( head == null ) return 1 ; var res = head . data + addWithCarry ( head . next ) ; head . data = res % 10 ; return parseInt ( res / 10 ) ; }
function populateArbit ( head ) { if ( head == null ) return ; if ( head . next == null ) { maxNode = head ; return ; } populateArbit ( head . next ) ; head . arbit = maxNode ; if ( head . data > maxNode . data ) maxNode = head ; return ; }
function deleteLast ( head , x ) { var temp = head , ptr = null ; while ( temp != null ) { if ( temp . data == x ) ptr = temp ; temp = temp . next ; } if ( ptr != null && ptr . next == null ) { temp = head ; while ( temp . next != ptr ) temp = temp . next ; temp . next = null ; } if ( ptr != null && ptr . next != null ) { ptr . data = ptr . next . data ; temp = ptr . next ; ptr . next = ptr . next . next ; } }
function getLength ( node ) { var size = 0 ; while ( node != null ) { node = node . next ; size ++ ; } return size ; }
function isPalindromeUtil ( head , loop_start ) { var ptr = head ; var s = [ ] ; var count = 0 ; while ( ptr != loop_start count != 1 ) { s . push ( ptr . data ) ; if ( ptr == loop_start ) count = 1 ; ptr = ptr . next ; } ptr = head ; count = 0 ; while ( ptr != loop_start count != 1 ) { var stk = s . pop ( ) ; if ( ptr . data == stk ) ; else { s . push ( stk ) ; return false ; } if ( ptr == loop_start ) count = 1 ; ptr = ptr . next ; } return true ; }
function isPalindrome ( head ) { var loop_start = detectAndgetLoopstarting ( head ) ; return isPalindromeUtil ( head , loop_start ) ; }
function countCommon ( a , b ) { var count = 0 ; for ( ; a != null && b != null ; a = a . next , b = b . next ) if ( a . data == b . data ) ++ count ; else break ; return count ; }
function maxPalindrome ( head ) { var result = 0 ; var prev = null , curr = head ; while ( curr != null ) { var next = curr . next ; curr . next = prev ; result = Math . max ( result , 2 * countCommon ( prev , next ) + 1 ) ; result = Math . max ( result , 2 * countCommon ( curr , next ) ) ; prev = curr ; curr = next ; } return result ; }
function displayList ( head ) { temp = head ; while ( temp != null ) { document . write ( temp . data + "▁" ) ; temp = temp . next ; } }
function LinkedListLength ( head ) { while ( head != null && head . next != null ) { head = head . next . next ; } if ( head == null ) return 0 ; return 1 ; }
function push ( head , info ) { node = new Node ( ) ; node . data = info ; node . next = ( head ) ; ( head ) = node ; }
function sumOfLastN_NodesUtil ( head , n ) { if ( n <= 0 ) return 0 ; let st = [ ] ; let sum = 0 ; while ( head != null ) { st . push ( head . data ) ; head = head . next ; } while ( n -- > 0 ) { sum += st [ st . length - 1 ] ; st . pop ( ) ; } return sum ; }
function push ( head_ref , new_data ) { new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; head = head_ref ; }
function sumOfLastN_NodesUtil ( head , n ) { if ( n <= 0 ) return 0 ; var sum = 0 , len = 0 ; temp = head ; while ( temp != null ) { len ++ ; temp = temp . next ; } var c = len - n ; temp = head ; while ( temp != null && c -- > 0 ) { temp = temp . next ; } while ( temp != null ) { sum += temp . data ; temp = temp . next ; } return sum ; }
function printList ( node ) { while ( node != null ) { document . write ( node . data + "%d▁" ) ; node = node . next ; } }
function printList ( node ) { while ( node != null ) { document . write ( node . data + "▁" ) ; node = node . next ; } }
function printList ( head ) { while ( head != null ) { document . write ( head . data + "▁" ) ; head = head . next ; } }
function printList ( head ) { while ( head != null ) { document . write ( head . data + "▁" ) ; head = head . next ; } }
function insertAfterNthNode ( head , n , x ) { if ( head == null ) return ; var newNode = getNode ( x ) ; var slow_ptr = head ; var fast_ptr = head ; for ( var i = 1 ; i <= n - 1 ; i ++ ) fast_ptr = fast_ptr . next ; while ( fast_ptr . next != null ) { slow_ptr = slow_ptr . next ; fast_ptr = fast_ptr . next ; } newNode . next = slow_ptr . next ; slow_ptr . next = newNode ; }
function printList ( head ) { while ( head != null ) { document . write ( head . data + "▁" ) ; head = head . next ; } }
function printList ( head ) { temp = head ; while ( temp . next != head ) { document . write ( temp . data + "▁" ) ; temp = temp . next ; } document . write ( temp . data + "▁" ) ; }
function printList ( head ) { while ( head . next != null ) { document . write ( head . data + "▁<->▁" ) ; head = head . next ; } document . write ( head . data ) ; }
function printList ( head ) { while ( head != null ) { document . write ( head . data + "▁" ) ; head = head . next ; } }
function isPalindrome ( left ) { if ( left == null ) return true ; var right = left ; while ( right . next != null ) right = right . next ; while ( left != right ) { if ( left . data != right . data ) return false ; left = left . next ; right = right . prev ; } return true ; }
function printKDistant ( node , k ) { if ( node == null k < 0 ) { return ; } if ( k == 0 ) { document . write ( node . data + "▁" ) ; return ; } printKDistant ( node . left , k - 1 ) ; printKDistant ( node . right , k - 1 ) ; }
function kDistantFromLeafUtil ( node , path , visited , pathLen , k ) { if ( node == null ) return ; path [ pathLen ] = node . data ; visited [ pathLen ] = false ; pathLen ++ ; if ( node . left == null && node . right == null && ( pathLen - k - 1 ) >= 0 && visited [ pathLen - k - 1 ] == false ) { document . write ( path [ pathLen - k - 1 ] + "▁" ) ; visited [ pathLen - k - 1 ] = true ; return ; } kDistantFromLeafUtil ( node . left , path , visited , pathLen , k ) ; kDistantFromLeafUtil ( node . right , path , visited , pathLen , k ) ; }
function printKDistantfromLeaf ( node , k ) { let path = new Array ( 1000 ) ; path . fill ( 0 ) ; let visited = new Array ( 1000 ) ; visited . fill ( false ) ; kDistantFromLeafUtil ( node , path , visited , 0 , k ) ; }
function rotate ( arr , N , X ) { let nextPower = 1 ; while ( nextPower <= N ) nextPower *= 2 ; if ( X == 1 ) return nextPower - N ; let prevPower = nextPower / 2 ; return 2 * ( N - prevPower ) + 1 ; }
function performSwap ( mat , i , j ) { let N = mat . length ; let ei = N - 1 - i ; let ej = N - 1 - j ; let temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ ej ] [ i ] ; mat [ ej ] [ i ] = mat [ ei ] [ ej ] ; mat [ ei ] [ ej ] = mat [ j ] [ ei ] ; mat [ j ] [ ei ] = temp ; }
function rotate ( mat , N , K ) { K = K % 4 ; while ( K -- > 0 ) { for ( let i = 0 ; i < N / 2 ; i ++ ) { for ( let j = i ; j < N - i - 1 ; j ++ ) { if ( i != j && ( i + j ) != N - 1 ) { performSwap ( mat , i , j ) ; } } } } print ( mat ) ; }
function findMaximumZeros ( str , n ) { var c0 = 0 ; var i ; for ( i = 0 ; i < n ; ++ i ) { if ( str [ i ] == "0" ) c0 ++ ; } if ( c0 == n ) { document . write ( n ) ; return ; } var s = str + str ; var mx = 0 ; var j ; for ( i = 0 ; i < n ; ++ i ) { var cs = 0 ; var ce = 0 ; for ( j = i ; j < i + n ; ++ j ) { if ( s [ j ] == "0" ) cs ++ ; else break ; } for ( j = i + n - 1 ; j >= i ; -- j ) { if ( s [ j ] == "0" ) ce ++ ; else break ; } var val = cs + ce ; mx = Math . max ( val , mx ) ; } document . write ( mx ) ; }
function findMaximumZeros ( str , n ) { var c0 = 0 ; for ( var i = 0 ; i < n ; ++ i ) { if ( str [ i ] == "0" ) c0 ++ ; } if ( c0 == n ) { document . write ( n ) ; return ; } var mx = 0 ; var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] == "0" ) cnt ++ ; else { mx = Math . max ( mx , cnt ) ; cnt = 0 ; } } mx = Math . max ( mx , cnt ) ; var start = 0 , end = n - 1 ; cnt = 0 ; while ( str [ start ] != "1" && start < n ) { cnt ++ ; start ++ ; } while ( str [ end ] != "1" && end >= 0 ) { cnt ++ ; end -- ; } mx = Math . max ( mx , cnt ) ; document . write ( mx ) ; }
function getLeafCount ( node ) { if ( node == null ) { return 0 ; } let q = [ ] ; let count = 0 ; q . push ( node ) ; while ( q . length != 0 ) { let temp = q . shift ( ) ; if ( temp . left != null ) { q . push ( temp . left ) ; } if ( temp . right != null ) { q . push ( temp . right ) ; } if ( temp . left == null && temp . right == null ) { count ++ ; } } return count ; }
function rotateArray ( arr , N ) { let v = arr ; v . sort ( ( a , b ) => a - b ) ; for ( let i = 1 ; i <= N ; ++ i ) { let x = arr [ N - 1 ] ; i = N - 1 ; while ( i -- ) { arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = x ; } let isEqual = arr . every ( ( e , i ) => { return arr [ i ] == v [ i ] } )  if ( isEqual ) { document . write ( "YES" ) ; return ; } } document . write ( "NO" ) ; }
function numberOfDigit ( N ) { let digit = 0 ; while ( N > 0 ) { digit ++ ; N = Math . floor ( N / 10 ) ; } return digit ; }
function rotateNumberByK ( N , K ) { let X = numberOfDigit ( N ) ; K = ( ( K % X ) + X ) % X ; let left_no = Math . floor ( N / Math . floor ( Math . pow ( 10 , X - K ) ) ) ; N = N % Math . floor ( Math . pow ( 10 , X - K ) ) ; let left_digit = numberOfDigit ( left_no ) ; N = ( N * Math . floor ( Math . pow ( 10 , left_digit ) ) ) + left_no ; document . write ( N ) ; }
function minMovesToSort ( arr , N ) { let count = 0 ; let index = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) { count ++ ; index = i ; } } if ( count == 0 ) { document . write ( "0" ) ; } else if ( count == N - 1 ) { document . write ( N - 1 ) ; } else if ( count == 1 && arr [ 0 ] <= arr [ N - 1 ] ) { document . write ( index + 1 ) ; } else { document . write ( "-1" ) ; } }
function findMaximumDiagonalSumOMatrixf ( A ) { let maxDiagonalSum = Number . MIN_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let curr = 0 ; for ( let j = 0 ; j < N ; j ++ ) { curr += A [ j ] [ ( i + j ) % N ] ; } maxDiagonalSum = Math . max ( maxDiagonalSum , curr ) ; } for ( let i = 0 ; i < N ; i ++ ) { let curr = 0 ; for ( let j = 0 ; j < N ; j ++ ) { curr += A [ ( i + j ) % N ] [ j ] ; } maxDiagonalSum = Math . max ( maxDiagonalSum , curr ) ; } return maxDiagonalSum ; }
function countLeaves ( node ) { if ( node == null ) return 0 ; if ( node . left == null && node . right == null ) return 1 ; return countLeaves ( node . left ) + countLeaves ( node . right ) ; }
function MaxSum ( arr , n , k ) { var i , max_sum = 0 , sum = 0 ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } max_sum = sum ; while ( i < n ) { sum = sum - arr [ i - k ] + arr [ i ] ; if ( max_sum < sum ) { max_sum = sum ; } i ++ ; } return max_sum ; }
function gcd ( n1 , n2 ) { if ( n2 == 0 ) { return n1 ; } else { return gcd ( n2 , n1 % n2 ) ; } }
function RotateArr ( arr , n , d ) { var i = 0 , j = 0 ; d = d % n ; var no_of_sets = gcd ( d , n ) ; for ( i = 0 ; i < no_of_sets ; i ++ ) { var temp = arr [ i ] ; j = i ; while ( true ) { var k = j + d ; if ( k >= n ) k = k - n ; if ( k == i ) break ; arr [ j ] = arr [ k ] ; j = k ; } arr [ j ] = temp ; } return arr ; }
function getMinimumRemoval ( str ) { var n = str . length ; var ans = n ; if ( n % 2 === 0 ) { var freqEven = new Array ( 128 ) . fill ( 0 ) ; var freqOdd = new Array ( 128 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( i % 2 === 0 ) { freqEven [ str [ i ] . charCodeAt ( 0 ) ] ++ ; } else { freqOdd [ str [ i ] . charCodeAt ( 0 ) ] ++ ; } } var evenMax = 0 , oddMax = 0 ; for ( var chr = "a" . charCodeAt ( 0 ) ; chr <= "z" . charCodeAt ( 0 ) ; chr ++ ) { evenMax = Math . max ( evenMax , freqEven [ chr ] ) ; oddMax = Math . max ( oddMax , freqOdd [ chr ] ) ; } ans = ans - evenMax - oddMax ; } else { var freq = new Array ( 128 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { freq [ str [ i ] . charCodeAt ( 0 ) ] ++ ; } var strMax = 0 ; for ( var chr = "a" . charCodeAt ( 0 ) ; chr <= "z" . charCodeAt ( 0 ) ; chr ++ ) { strMax = Math . max ( strMax , freq [ chr ] ) ; } ans = ans - strMax ; } return ans ; }
function findAltSubSeq ( s ) { var n = s . length , ans = - 1000000000 ; for ( var i = 0 ; i < 10 ; i ++ ) { for ( var j = 0 ; j < 10 ; j ++ ) { var cur = 0 , f = 0 ; for ( var k = 0 ; k < n ; k ++ ) { if ( f == 0 && s [ k ] - "0" == i ) { f = 1 ; cur ++ ; } else if ( f == 1 && s [ k ] - "0" == j ) { f = 0 ; cur ++ ; } } if ( i != j && cur % 2 == 1 ) cur -- ; ans = Math . max ( cur , ans ) ; } } return ans ; }
function getFirstElement ( a , N , K , M ) { K %= N ; let index ; if ( K >= M ) index = ( N - K ) + ( M - 1 ) ; else index = ( M - K - 1 ) ; let result = a [ index ] ; return result ; }
function getFirstElement ( a , N , K , M ) { K %= N ; var index = ( K + M - 1 ) % N ; var result = a [ index ] ; return result ; }
function left_rotate ( arr ) { let last = arr [ 1 ] ; for ( let i = 3 ; i < 6 ; i = i + 2 ) { arr [ i - 2 ] = arr [ i ] ; } arr [ 6 - 1 ] = last ; }
function right_rotate ( arr ) { let start = arr [ 6 - 2 ] ; for ( let i = 6 - 4 ; i >= 0 ; i = i - 2 ) { arr [ i + 2 ] = arr [ i ] ; } arr [ 0 ] = start ; }
function rotate ( arr ) { left_rotate ( arr ) ; right_rotate ( arr ) ; for ( let i = 0 ; i < 6 ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function maximumMatchingPairs ( perm1 , perm2 , n ) { var left = Array ( n ) ; var right = Array ( n ) ; var mp1 = new Map ( ) , mp2 = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { mp1 . set ( perm1 [ i ] , i ) ; } for ( var j = 0 ; j < n ; j ++ ) { mp2 . set ( perm2 [ j ] , j ) ; } for ( var i = 0 ; i < n ; i ++ ) { var idx2 = mp2 . get ( perm1 [ i ] ) ; var idx1 = i ; if ( idx1 == idx2 ) { left [ i ] = 0 ; right [ i ] = 0 ; } else if ( idx1 < idx2 ) { left [ i ] = ( n - ( idx2 - idx1 ) ) ; right [ i ] = ( idx2 - idx1 ) ; } else { left [ i ] = ( idx1 - idx2 ) ; right [ i ] = ( n - ( idx1 - idx2 ) ) ; } } var freq1 = new Map ( ) , freq2 = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( freq1 . has ( left [ i ] ) ) freq1 . set ( left [ i ] , freq1 . get ( left [ i ] ) + 1 ) else freq1 . set ( left [ i ] , 1 )  if ( freq2 . has ( right [ i ] ) ) freq2 . set ( right [ i ] , freq2 . get ( right [ i ] ) + 1 ) else freq2 . set ( right [ i ] , 1 ) } var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , Math . max ( freq1 . get ( left [ i ] ) , freq2 . get ( right [ i ] ) ) ) ; } return ans ; }
function countRotation ( arr , n ) { for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { return i ; } } return 0 ; }
function query ( node , l , r , start , end , a ) { if ( l > end r < start ) return 0 ; if ( start <= l && r <= end ) return seg [ node ] ; var mid = parseInt ( ( l + r ) / 2 ) ; return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) ; }
function isConversionPossible ( s1 , s2 , x ) { let diff = 0 , n ; n = s1 . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; diff = ( ( s2 [ i ] . charCodeAt ( 0 ) - s1 [ i ] . charCodeAt ( 0 ) ) + 26 ) % 26 ; if ( diff > x ) { document . write ( "NO" ) ; return ; } } document . write ( "YES" ) ; }
function countRotation ( n ) { let count = 0 ; do { let digit = n % 10 ; if ( digit == 0 ) count ++ ; n = parseInt ( n / 10 ) ; } while ( n != 0 ) ; return count ; }
function printList ( node ) { while ( node != null ) { document . write ( node . data + "▁->▁" ) ; node = node . next ; } document . write ( "NULL" ) ; }
function isPossible ( a , n ) { if ( n <= 2 ) return true ; var flag = 0 ; for ( i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] > a [ i + 1 ] && a [ i + 1 ] > a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; flag = 0 ; for ( i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] < a [ i + 1 ] && a [ i + 1 ] < a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; var val1 = Number . MAX_VALUE , mini = - 1 , val2 = Number . MIN_VALUE , maxi = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] < val1 ) { mini = i ; val1 = a [ i ] ; } if ( a [ i ] > val2 ) { maxi = i ; val2 = a [ i ] ; } } flag = 1 ; for ( i = 0 ; i < maxi ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 && maxi + 1 == mini ) { flag = 1 ; for ( i = mini ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } flag = 1 ; for ( i = 0 ; i < mini ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 && maxi - 1 == mini ) { flag = 1 ; for ( i = maxi ; i < n - 1 ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } return false ; }
function cntRotations ( s , n ) { let str = s + s ; let pre = new Array ( 2 * n ) ; pre . fill ( 0 ) ; for ( let i = 0 ; i < 2 * n ; i ++ ) { if ( i != 0 ) pre [ i ] += pre [ i - 1 ] ; if ( str [ i ] == "a" str [ i ] == "e" str [ i ] == "i" str [ i ] == "o" str [ i ] == "u" ) { pre [ i ] ++ ; } } let ans = 0 ; for ( let i = n - 1 ; i < 2 * n - 1 ; i ++ ) { let r = i , l = i - n ; let x1 = pre [ r ] ; if ( l >= 0 ) x1 -= pre [ l ] ; r = i - parseInt ( n / 2 , 10 ) ; let left = pre [ r ] ; if ( l >= 0 ) left -= pre [ l ] ; let right = x1 - left ; if ( left > right ) { ans ++ ; } } return ans ; }
function cntRotations ( s , n ) { let lh = 0 , rh = 0 , i , ans = 0 ; for ( i = 0 ; i < parseInt ( n / 2 , 10 ) ; ++ i ) if ( s [ i ] == "a" s [ i ] == "e" s [ i ] == "i" s [ i ] == "o" s [ i ] == "u" ) { lh ++ ; } for ( i = parseInt ( n / 2 , 10 ) ; i < n ; ++ i ) if ( s [ i ] == "a" s [ i ] == "e" s [ i ] == "i" s [ i ] == "o" s [ i ] == "u" ) { rh ++ ; } if ( lh > rh ) ans ++ ; for ( i = 1 ; i < n ; ++ i ) { if ( s [ i - 1 ] == "a" s [ i - 1 ] == "e" s [ i - 1 ] == "i" s [ i - 1 ] == "o" s [ i - 1 ] == "u" ) { rh ++ ; lh -- ; } if ( s [ ( i - 1 + n / 2 ) % n ] == "a" || s [ ( i - 1 + n / 2 ) % n ] == "e" || s [ ( i - 1 + n / 2 ) % n ] == "i" || s [ ( i - 1 + n / 2 ) % n ] == "o" || s [ ( i - 1 + n / 2 ) % n ] == "u" ) { rh -- ; lh ++ ; } if ( lh > rh ) ans ++ ; } return ans ; }
function cal ( num ) { let digits = numberOfDigits ( num ) ; let powTen = Math . pow ( 10 , digits - 1 ) ; for ( let i = 0 ; i < digits - 1 ; i ++ ) { let firstDigit = parseInt ( num / powTen , 10 ) ; let left = ( ( num * 10 ) + firstDigit ) - ( firstDigit * powTen * 10 ) ; document . write ( left + "▁" ) ; num = left ; } }
function CheckKCycles ( n , s ) { var ff = true ; var x = 0 ; for ( i = 1 ; i < n ; i ++ ) { x = ( s . substring ( i ) + s . substring ( 0 , i ) ) . length ; if ( x >= s . length ) { continue ; } ff = false ; break ; } if ( ff ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function populateNext ( node ) { if ( node != null ) { populateNext ( node . right ) ; node . next = next ; next = node ; populateNext ( node . left ) ; } }
function occurredOnce ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; if ( arr [ 0 ] != arr [ 1 ] ) document . write ( arr [ 0 ] + "▁" ) ; for ( let i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) document . write ( arr [ i ] + "▁" ) ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) document . write ( arr [ n - 1 ] + "▁" ) ; }
function occurredOnce ( arr , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , 1 + mp . get ( arr [ i ] ) ) ; else mp . set ( arr [ i ] , 1 ) ; } for ( let [ key , value ] of mp . entries ( ) ) { if ( value == 1 ) document . write ( key + "▁" ) ; } }
function occurredOnce ( arr , n ) { var i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else document . write ( arr [ i - 1 ] + "▁" ) ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) document . write ( arr [ n - 1 ] ) ; }
function rvereseArray ( arr , start , end ) { while ( start < end ) { let temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } }
function printArray ( arr , size ) { for ( let i = 0 ; i < size ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function splitArr ( arr , k , n ) { rvereseArray ( arr , 0 , n - 1 ) ; rvereseArray ( arr , 0 , n - k - 1 ) ; rvereseArray ( arr , n - k , n - 1 ) ; }
function countRotationsDivBy8 ( n ) { let len = n . length ; let count = 0 ; if ( len == 1 ) { let oneDigit = n [ 0 ] - "0" ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { let first = ( n [ 0 ] - "0" ) * 10 + ( n [ 1 ] - "0" ) ; let second = ( n [ 1 ] - "0" ) * 10 + ( n [ 0 ] - "0" ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } let threeDigit ; for ( let i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n [ i ] - "0" ) * 100 + ( n [ i + 1 ] - "0" ) * 10 + ( n [ i + 2 ] - "0" ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n [ len - 1 ] - "0" ) * 100 + ( n [ 0 ] - "0" ) * 10 + ( n [ 1 ] - "0" ) ; if ( threeDigit % 8 == 0 ) count ++ ; threeDigit = ( n [ len - 2 ] - "0" ) * 100 + ( n [ len - 1 ] - "0" ) * 10 + ( n [ 0 ] - "0" ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; }
function restoreSortedArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { reverse ( arr , 0 , i ) ; reverse ( arr , i + 1 , n ) ; reverse ( arr , 0 , n ) ; } } }
function findStartIndexOfArray ( arr , low , high ) { if ( low > high ) { return - 1 ; } if ( low == high ) { return low ; } let mid = low + parseInt ( ( high - low ) / 2 , 10 ) ; if ( arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( arr [ mid - 1 ] > arr [ mid ] ) { return mid ; } if ( arr [ low ] > arr [ mid ] ) { return findStartIndexOfArray ( arr , low , mid - 1 ) ; } else { return findStartIndexOfArray ( arr , mid + 1 , high ) ; } }
function restoreSortedArray ( arr , n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) { return ; } let start = findStartIndexOfArray ( arr , 0 , n - 1 ) ; arr . sort ( ) ; }
function printArray ( arr , size ) { for ( let i = 0 ; i < size ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function printList ( node ) { while ( node != null ) { document . write ( node . data + "▁" ) ; node = node . next ; } }
function isRotation ( x , y ) { var x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; }
function countRotations ( n ) { let len = n . length ; if ( len == 1 ) { let oneDigit = n [ 0 ] - "0" ; if ( oneDigit % 4 == 0 ) return 1 ; return 0 ; } let twoDigit ; let count = 0 ; for ( let i = 0 ; i < ( len - 1 ) ; i ++ ) { twoDigit = ( n [ i ] - "0" ) * 10 + ( n [ i + 1 ] - "0" ) ; if ( twoDigit % 4 == 0 ) count ++ ; } twoDigit = ( n [ len - 1 ] - "0" ) * 10 + ( n [ 0 ] - "0" ) ; if ( twoDigit % 4 == 0 ) count ++ ; return count ; }
function isRotated ( str1 , str2 ) { if ( str1 . length != str2 . length ) return false ; if ( str1 . length < 2 ) { return str1 . localeCompare ( str2 ) ; } let clock_rot = "" ; let anticlock_rot = "" ; let len = str2 . length ; anticlock_rot = anticlock_rot + str2 . substring ( len - 2 , len + 1 ) + str2 . substring ( 0 , len - 1 ) ; clock_rot = clock_rot + str2 . substring ( 2 , str2 . length - 2 + 1 ) + str2 . substring ( 0 , 2 + 1 ) ; return ( str1 . localeCompare ( clock_rot ) || str1 . localeCompare ( anticlock_rot ) ) ; }
function printList ( head ) { var temp = head ; if ( head != null ) { do { document . write ( temp . data + "%d▁" ) ; temp = temp . next ; } while ( temp != head ) ; } }
function deleteNode ( head_ref , del ) { var temp = head_ref ; if ( head_ref == del ) head_ref = del . next ; while ( temp . next != del ) { temp = temp . next ; } temp . next = del . next ; del = null ; return ; }
function largestElement ( head_ref ) { var current ; current = head_ref ; var maxEle = Number . MIN_VALUE ; do { if ( current . data > maxEle ) { maxEle = current . data ; } current = current . next ; } while ( current != head_ref ) ; return maxEle ; }
function deleteFibonacciNodes ( head ) { var maxEle = largestElement ( head ) ; var hash = new Set ( ) ; createHash ( hash , maxEle ) ; var ptr = head ; var next ; do { if ( hash . has ( ptr . data ) ) deleteNode ( head , ptr ) ; next = ptr . next ; ptr = next ; } while ( ptr != head ) ; }
function printList ( head ) { var temp = head ; if ( head != null ) { do { document . write ( temp . data + "%d▁" ) ; temp = temp . next ; } while ( temp != head ) ; } }
function sumOfList ( head ) { var temp = head ; var sum = 0 ; if ( head != null ) { do { temp = temp . next ; sum += temp . data ; } while ( temp != head ) ; } return sum ; }
function searchList ( start , search ) { let temp = start ; let count = 0 , flag = 0 , value ; if ( temp == null ) return - 1 ; else { while ( temp . next != start ) { count ++ ; if ( temp . data == search ) { flag = 1 ; count -- ; break ; } temp = temp . next ; } if ( temp . data == search ) { count ++ ; flag = 1 ; } if ( flag == 1 ) document . write ( "\n" + search + "▁found▁at▁location▁" + count ) ; else document . write ( "\n" + search + "▁not▁found" ) ; } return - 1 ; }
function countList ( start ) { var temp = start ; var count = 0 ; while ( temp . next != start ) { temp = temp . next ; count ++ ; } count ++ ; return count ; }
function display ( head ) { if ( head == null ) return ; var temp = head ; document . write ( "Forward▁direction:▁" ) ; while ( temp . next != head ) { document . write ( temp . data + "▁" ) ; temp = temp . next ; } document . write ( temp . data + "▁" ) ; var last = head . prev ; temp = last ; document . write ( "Backwarddirection:" ) ; while ( temp . prev != last ) { document . write ( temp . data + "▁" ) ; temp = temp . prev ; } document . write ( temp . data + "▁" ) ; }
function displayList ( temp ) { let t = temp ; if ( temp == null ) return 0 ; else { document . write ( "The▁list▁is:▁" ) ; while ( temp . next != t ) { document . write ( temp . data + "▁" ) ; temp = temp . next ; } document . write ( temp . data ) ; return 1 ; } }
function filter ( x , y , z ) { if ( x != - 1 && y != - 1 ) { return z ; } return x == - 1 ? y : x ; }
function samePathUtil ( mtrx , vrtx , v1 , v2 , i ) { let ans = - 1 ; if ( i == v1 i == v2 ) return i ; for ( let j = 0 ; j < vrtx ; j ++ ) { if ( mtrx [ i ] [ j ] == 1 ) { ans = filter ( ans , samePathUtil ( mtrx , vrtx , v1 , v2 , j ) , i ) ; } } return ans ; }
function isVertexAtSamePath ( mtrx , vrtx , v1 , v2 , i ) { let lca = samePathUtil ( mtrx , vrtx , v1 - 1 , v2 - 1 , i ) ; if ( lca == v1 - 1 lca == v2 - 1 ) return true ; return false ; }
function dfs ( node , parent , h , cost ) { lca [ node ] [ 0 ] = parent ; level [ node ] = h ; if ( parent != - 1 ) { dist [ node ] [ 0 ] = cost ; } for ( let i = 1 ; i < log ; i ++ ) { if ( lca [ node ] [ i - 1 ] != - 1 ) { lca [ node ] [ i ] = lca [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ; dist [ node ] [ i ] = dist [ node ] [ i - 1 ] + dist [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ; } } for ( let i = 0 ; i < graph [ node ] . length ; i ++ ) { if ( graph [ node ] [ i ] [ 0 ] == parent ) continue ; dfs ( graph [ node ] [ i ] [ 0 ] , node , h + 1 , graph [ node ] [ i ] [ 1 ] ) ; } }
function SieveOfEratosthenes ( ) { for ( var p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( var i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
function dfs ( node , parent , h ) { par [ node ] = parent ; level [ node ] = h ; graph [ node ] . forEach ( child => { if ( child != parent ) dfs ( child , node , h + 1 ) ; } ) ; }
function findPrimeOnPath ( u , v ) { var count = 0 ; if ( level [ u ] > level [ v ] ) { [ u , v ] = [ v , u ] } var d = level [ v ] - level [ u ] ; while ( d -- ) { if ( prime [ weight [ v ] ] ) count ++ ; v = par [ v ] ; } if ( v == u ) { if ( prime [ weight [ v ] ] ) count ++ ; return count ; } while ( v != u ) { if ( prime [ weight [ v ] ] ) count ++ ; if ( prime [ weight [ u ] ] ) count ++ ; u = par [ u ] ; v = par [ v ] ; } if ( prime [ weight [ v ] ] ) count ++ ; return count ; }
function addEdge ( u , v ) { graph [ u ] . push ( v ) ; graph [ v ] . push ( u ) ; }
function sumOddNodes ( root , n1 , n2 ) { let path1 = [ ] ; let path2 = [ ] ; getPath ( root , path1 , n1 ) ; getPath ( root , path2 , n2 ) ; let intersection = - 1 ; let i = 0 , j = 0 ; while ( i != path1 . length j != path2 . length ) { if ( i == j && path1 [ i ] == path2 [ j ] ) { i ++ ; j ++ ; } else { intersection = j - 1 ; break ; } } let sum = 0 ; for ( i = path1 . length - 1 ; i > intersection ; i -- ) if ( path1 [ i ] % 2 != 0 ) sum += path1 [ i ] ; for ( i = intersection ; i < path2 . length ; i ++ ) if ( path2 [ i ] % 2 != 0 ) sum += path2 [ i ] ; return sum ; }
function findLCA ( n1 , n2 , parent ) { let visited = new Array ( MAX ) . fill ( false ) ; visited [ n1 ] = true ; while ( parent [ n1 ] != - 1 ) { visited [ n1 ] = true ; n1 = parent [ n1 ] ; } visited [ n1 ] = true ; while ( ! visited [ n2 ] ) n2 = parent [ n2 ] ; return n2 ; }
function insertAdj ( parent , i , j ) { parent [ i ] = j ; }
function addEdge ( u , v ) { adj [ u ] . push ( v ) ; adj [ v ] . push ( u ) ; }
function dfs ( cur , prev ) { parent [ cur ] = prev ; depth [ cur ] = depth [ prev ] + 1 ; for ( var i = 0 ; i < adj [ cur ] . length ; i ++ ) if ( adj [ cur ] [ i ] != prev ) dfs ( adj [ cur ] [ i ] , cur ) ; }
function preprocess ( ) { depth [ 0 ] = - 1 ; dfs ( 1 , 0 ) ; }
function makeSet ( subsets , i ) { if ( i < 1 i > V ) return ; subsets [ i ] . color = WHITE ; subsets [ i ] . parent = i ; subsets [ i ] . rank = 0 ; return ; }
function findSet ( subsets , i ) { if ( subsets [ i ] . parent != i ) subsets [ i ] . parent = findSet ( subsets , subsets [ i ] . parent ) ; return subsets [ i ] . parent ; }
function unionSet ( subsets , x , y ) { let xroot = findSet ( subsets , x ) ; let yroot = findSet ( subsets , y ) ; if ( subsets [ xroot ] . rank < subsets [ yroot ] . rank ) subsets [ xroot ] . parent = yroot ; else if ( subsets [ xroot ] . rank > subsets [ yroot ] . rank ) subsets [ yroot ] . parent = xroot ; else { subsets [ yroot ] . parent = xroot ; ( subsets [ xroot ] . rank ) ++ ; } }
function findPair ( a , n , z ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; }
function linearSearch ( a , n , key ) { for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] == key ) return true ; } return false ; }
function maximumSum ( arr , N ) { let Sum = 0 ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) Sum += ( arr [ i ] - arr [ i - 1 ] ) ; } return Sum ; }
function stoogesort ( arr , l , h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) { let temp = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = temp ; } if ( h - l + 1 > 2 ) { let t = Math . floor ( ( h - l + 1 ) / 3 ) ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } }
function findWinner ( n , m ) { let X = 0 ; let Y = 0 ; if ( n >= m ) { X = n - 1 ; Y = m ; } else { X = m - 1 ; Y = n ; } if ( X > Y ) document . write ( "X" ) ; else if ( Y > X ) document . write ( "Y" ) ; else document . write ( "-1" ) ; }
function checkPascaltriangle ( N ) { var x = ( Math . sqrt ( 8 * N + 1 ) - 1 ) / 2 ; if ( Math . ceil ( x ) - x == 0 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function countSubarrays ( arr , n ) { var count = 0 ; var i , j ; for ( i = 0 ; i < n ; i ++ ) { var sum = 0 ; for ( j = i ; j < n ; j ++ ) { if ( ( j - i ) % 2 == 0 ) sum += arr [ j ] ; else sum -= arr [ j ] ; if ( sum == 0 ) count ++ ; } } document . write ( count ) ; }
function findCountRooks ( row , col , n , k ) { let res = n - k ; document . write ( res + "▁" ) ; let ri = 0 , ci = 0 ; while ( res -- > 0 ) { while ( ri < k && row [ ri ] == 1 ) { ri ++ ; } while ( ci < k && col [ ci ] == 1 ) { ci ++ ; } document . write ( ( ri + 1 ) + "▁" + ( ci + 1 ) + "▁" ) ; ri ++ ; ci ++ ; } }
function checkIfDivisible ( str , num ) { let powerOf2 = ( Math . log ( num ) / Math . log ( 2 ) ) ; if ( str . length < powerOf2 ) return false ; if ( powerOf2 == 0 ) return true ; let i , number = 0 ; let len = str . length ; for ( i = len - powerOf2 ; i < len ; i ++ ) { number += ( str [ i ] - "0" ) * Math . pow ( 10 , powerOf2 - 1 ) ; powerOf2 -- ; } if ( number % num != 0 ) return false ; else return true ; }
function countNo ( A , N , L , R ) { var ans = L - 1 + N + Math . floor ( ( N - 1 ) / ( A - 1 ) ) ; if ( ans % A == 0 ) { ans = ans + 1 ; } document . write ( ans ) ; }
function check_order ( arr ) { var cnt = 0 ; for ( i = 0 ; i < arr . length - 1 ; i ++ ) { if ( Math . abs ( arr [ i + 1 ] - arr [ i ] ) > 1 ) cnt ++ ; } if ( Math . abs ( arr [ 0 ] - arr [ arr . length - 1 ] ) > 1 ) cnt ++ ; if ( cnt > 1 ) return false ; return true ; }
function getM ( n ) { if ( n == 1 ) return - 1 ; else return n - 2 ; }
function maxProfit ( prices , n ) { if ( n <= 1 ) return 0 ; let rest = [ ] ; for ( let k = 0 ; k < n ; k ++ ) rest . push ( 0 ) ; let hold = [ ] ; for ( let k = 0 ; k < n ; k ++ ) hold . push ( 0 ) ; let sold = [ ] ; for ( let k = 0 ; k < n ; k ++ ) sold . push ( 0 ) ; rest [ 0 ] = 0 ; hold [ 0 ] = - prices [ 0 ] ; sold [ 0 ] = 0 ; for ( let i = 1 ; i < n ; i ++ ) { rest [ i ] = Math . max ( rest [ i - 1 ] , sold [ i - 1 ] ) ; hold [ i ] = Math . max ( hold [ i - 1 ] , rest [ i - 1 ] - prices [ i ] ) ; sold [ i ] = hold [ i - 1 ] + prices [ i ] ; } return Math . max ( rest [ n - 1 ] , sold [ n - 1 ] ) ; }
function findSubarrays ( arr , N , K ) { return N - K + 1 ; }
function findCount ( s ) { var freq = Array ( 26 ) . fill ( 0 ) ; var dp = Array . from ( Array ( 26 ) , ( ) => Array ( 26 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < s . length ; ++ i ) { for ( var j = 0 ; j < 26 ; j ++ ) { dp [ j ] [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] += freq [ j ] ; } freq [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } var ans = 0 ; for ( var i = 0 ; i < 26 ; i ++ ) ans = Math . max ( freq [ i ] , ans ) ; for ( var i = 0 ; i < 26 ; i ++ ) { for ( var j = 0 ; j < 26 ; j ++ ) { ans = Math . max ( dp [ i ] [ j ] , ans ) ; } } return ans ; }
function findCycles ( N ) { let res = 0 ; let finalResult = 0 ; let val = 2 * N - 1 ; let s = val ; res = ( N - 1 ) * ( N - 2 ) ; finalResult = res + s ; return finalResult ; }
function longest_subarray ( arr , d ) { var i = 0 , j = 1 , e = 0 ; for ( i = 0 ; i < d - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { j = j + 1 ; } else { j = 1 ; } if ( e < j ) { e = j ; } } return e ; }
function find ( a , n , k ) { var v = [ ] ; for ( i = 1 ; i < n ; ++ i ) { v . push ( a [ i - 1 ] - a [ i ] ) ; } v . sort ( ( a , b ) => a - b ) ; var res = a [ n - 1 ] - a [ 0 ] ; for ( i = 0 ; i < k - 1 ; ++ i ) { res += v [ i ] ; } return res ; }
function isStrong ( N ) { let num = N . toString ( ) ; let sum = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) { sum += factorial [ num [ i ] - "0" ] ; } return sum == N ; }
function printStrongNumbers ( N ) { for ( let i = 1 ; i <= N ; i ++ ) { if ( isStrong ( i ) ) { document . write ( i + "▁" ) ; } } }
function countPairs ( A , B ) { var countY = 0 , countX = ( B - A ) + 1 , next_val = 9 ; while ( next_val <= B ) { if ( next_val >= A ) { countY += 1 ; } next_val = next_val * 10 + 9 ; } return ( countX * countY ) ; }
function power ( a , b , c ) { var result = 1 ; while ( b > 0 ) { if ( ( b & 1 ) == 1 ) { result = ( result * a ) % c ; } b /= 2 ; a = ( a * a ) % c ; } return result ; }
function calculate ( X , N ) { var a = [ ... Array ( 10 ) ] ; var cyclicity = [ ... Array ( 11 ) ] ; cyclicity [ 1 ] = 1 ; cyclicity [ 2 ] = 4 ; cyclicity [ 3 ] = 4 ; cyclicity [ 4 ] = 2 ; cyclicity [ 5 ] = 1 ; cyclicity [ 6 ] = 1 ; cyclicity [ 7 ] = 4 ; cyclicity [ 8 ] = 4 ; cyclicity [ 9 ] = 2 ; cyclicity [ 10 ] = 1 ; if ( N == 0 N == 1 ) { return X % 10 ; } else if ( N == 2 N == 3 N == 4 ) { var temp = 1e18 ; a [ 2 ] = 2 ; a [ 3 ] = 6 ; a [ 4 ] = 4 ; var v = X % 10 ; if ( v != 0 ) { var u = cyclicity [ parseInt ( v ) ] ; var r = a [ parseInt ( N ) ] % u ; if ( r == 0 ) { if ( v == 2 v == 4 v == 6 v == 8 ) { return 6 ; } else if ( v == 5 ) { return 5 ; } else if ( v == 1 v == 3 v == 7 v == 9 ) { return 1 ; } } else { return power ( v , r , temp ) % 10 ; } } else { return 0 ; } } return 1 ; }
function precompute ( s , K ) { var n = s . length ; for ( var i = 0 ; i < n - 1 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] + ( s . substring ( i , i + K . length ) == K ) ; } }
function getXOR ( BITree , index ) { let ans = 0 ; index += 1 ; while ( index > 0 ) { ans ^= BITree [ index ] ; index -= index & ( - index ) ; } return ans ; }
function updateBIT ( BITree , n , index , val ) { index = index + 1 ; while ( index <= n ) { BITree [ index ] ^= val ; index += index & ( - index ) ; } }
function isPowerOfTwo ( x ) { if ( x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ) return true ; return false ; }
function computePrefix ( n , a ) { if ( isPowerOfTwo ( a [ 0 ] ) ) prefix [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] ; if ( isPowerOfTwo ( a [ i ] ) ) prefix [ i ] ++ ; } }
function formQuadruplets ( arr , n ) { var ans = 0 , pairs = 0 ; pairs = parseInt ( n / 4 ) ; arr . sort ( ) . reverse ( ) ; for ( var i = 0 ; i < n - pairs ; i += 3 ) { ans += arr [ i + 2 ] ; } return ans ; }
function count ( ) { let maxN = 1000000 , i , j ; for ( i = 0 ; i < maxN ; i ++ ) arr [ i ] = 1 ; arr [ 0 ] = 0 ; arr [ 1 ] = 0 ; for ( i = 2 ; i * i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) { for ( j = 2 * i ; j <= maxN ; j += i ) { arr [ j ] = 0 ; } } } let cnt = 0 ; for ( i = 0 ; i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) cnt ++ ; if ( arr [ cnt ] == 1 ) dp [ i ] = 1 ; else dp [ i ] = 0 ; } for ( i = 1 ; i <= maxN ; i ++ ) dp [ i ] += dp [ i - 1 ] ; }
function findUngroupedElement ( s , k ) { let n = s . length ; let b = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < 26 ; i ++ ) b [ i ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let p = s [ i ] ; b [ p . charCodeAt ( ) - "a" . charCodeAt ( ) ] += 1 ; } let sum = 0 ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( b [ i ] > k ) sum += b [ i ] - k ; } document . write ( sum ) ; }
function AddEdge ( u , v ) { adj [ u ] . push ( v ) ; adj [ v ] . push ( u ) ; }
function findFirstEnd ( u , p ) { lvl [ u ] = 1 + lvl [ p ] ; if ( lvl [ u ] > maxi ) { maxi = lvl [ u ] ; end1 = u ; } for ( let i = 0 ; i < adj [ u ] . length ; i ++ ) { if ( adj [ u ] [ i ] != p ) { findFirstEnd ( adj [ u ] [ i ] , u ) ; } } }
function findSecondEnd ( u , p ) { lvl [ u ] = 1 + lvl [ p ] ; if ( lvl [ u ] > maxi ) { maxi = lvl [ u ] ; end2 = u ; } for ( let i = 0 ; i < adj [ u ] . length ; i ++ ) { if ( adj [ u ] [ i ] != p ) { findSecondEnd ( adj [ u ] [ i ] , u ) ; } } }
function findDistancefromFirst ( u , p ) { dist1 [ u ] = 1 + dist1 [ p ] ; for ( let i = 0 ; i < adj [ u ] . length ; i ++ ) { if ( adj [ u ] [ i ] != p ) { findDistancefromFirst ( adj [ u ] [ i ] , u ) ; } } }
function findDistancefromSecond ( u , p ) { dist2 [ u ] = 1 + dist2 [ p ] ; for ( let i = 0 ; i < adj [ u ] . length ; i ++ ) { if ( adj [ u ] [ i ] != p ) { findDistancefromSecond ( adj [ u ] [ i ] , u ) ; } } }
function findNodes ( ) { let n = 5 ; AddEdge ( 1 , 2 ) ; AddEdge ( 1 , 3 ) ; AddEdge ( 3 , 4 ) ; AddEdge ( 3 , 5 ) ; findFirstEnd ( 1 , 0 ) ; clear ( n ) ; findSecondEnd ( end1 , 0 ) ; findDistancefromFirst ( end1 , 0 ) ; findDistancefromSecond ( end2 , 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) { let x = dist1 [ i ] ; let y = dist2 [ i ] ; if ( x >= y ) { document . write ( end1 + "▁" ) ; } else { document . write ( end2 + "▁" ) ; } } }
function findMaxSum ( arr , n ) { var a = [ ] ; var b = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { a . push ( arr [ i ] ) ; } else if ( arr [ i ] < 0 ) { b . push ( arr [ i ] ) ; } } a . sort ( ( a , b ) => a - b ) b . sort ( ( a , b ) => a - b )  var p = a . length - 1 ; var q = b . length - 1 ; var s = 0 ; while ( p >= 0 && q >= 0 ) { if ( a [ p ] + b [ q ] > 0 ) { s = s + a [ p ] + b [ q ] ; } else { break ; } p = p - 1 ; q = q - 1 ; } return s ; }
function countIntgralPoints ( x1 , y1 , x2 , y2 ) { document . write ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) ; }
function SieveOfEratosthenes ( prime , p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
function PrimeDegreeNodes ( prufer , n ) { let nodes = n + 2 ; let prime = new Array ( nodes + 1 ) ; prime . fill ( true ) ; SieveOfEratosthenes ( prime , nodes + 1 ) ; let degree = new Array ( n + 2 + 1 ) ; for ( let i = 1 ; i <= nodes ; i ++ ) degree [ i ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) degree [ prufer [ i ] ] ++ ; for ( let i = 1 ; i <= nodes ; i ++ ) { if ( prime [ degree [ i ] ] ) { document . write ( i + "▁" ) ; } } }
function countSingle ( node ) { countSingleRec ( node , ct ) ; return ct . count ; }
function SieveOfEratosthenes ( ) { let i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= 10005 ; i ++ ) { if ( Prime [ i ] ) { for ( j = 2 * i ; j < 10005 ; j += i ) { Prime [ j ] = false ; } } } }
function primeDegreeNodes ( N , M , edges ) { let Adj = new Array ( ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) { Adj . push ( new Array ( ) ) } for ( let i = 0 ; i < M ; i ++ ) { let x = edges [ i ] [ 0 ] ; let y = edges [ i ] [ 1 ] ; Adj [ x ] . push ( y ) ; Adj [ y ] . push ( x ) ; } SieveOfEratosthenes ( ) ; for ( let i = 1 ; i <= N ; i ++ ) { let x = Adj [ i ] . length ; if ( Prime [ x ] ) document . write ( i + "▁" ) ; } }
function digitSum ( num ) { var sum = 0 ; while ( num > 0 ) { sum += ( num % 10 ) ; num = parseInt ( num / 10 ) ; } return sum ; }
function countWays ( colored , count , n ) { if ( count == n ) { return 1 ; } let answer = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { if ( colored [ i ] == 0 ) { if ( colored [ i - 1 ] == 1 colored [ i + 1 ] == 1 ) { colored [ i ] = 1 ; answer = ( answer + countWays ( colored , count + 1 , n ) ) % mod ; colored [ i ] = 0 ; } } } return answer ; }
function waysToColor ( arr , n , k ) { let colored = Array . from ( { length : n + 2 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < k ; i ++ ) { colored [ arr [ i ] ] = 1 ; } return countWays ( colored , k , n ) ; }
function waysToColor ( arr , n , k ) { let powOf2 = new Array ( 500 ) ; let c = new Array ( 500 ) ; for ( let i = 0 ; i < 500 ; i ++ ) { c [ i ] = new Array ( 500 ) ; for ( let j = 0 ; j < 500 ; j ++ ) { c [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= n ; i ++ ) { c [ i ] [ 0 ] = 1 ; for ( let j = 1 ; j <= i ; j ++ ) { c [ i ] [ j ] = ( c [ i - 1 ] [ j ] + c [ i - 1 ] [ j - 1 ] ) % mod ; } } powOf2 [ 0 ] = powOf2 [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { powOf2 [ i ] = powOf2 [ i - 1 ] * 2 % mod ; } let rem = n - k ; arr [ k ++ ] = n + 1 ; arr . sort ( function ( a , b ) { return a - b ; } ) ; let answer = 1 ; for ( let i = 0 ; i < k ; i ++ ) { let x = arr [ i ] - ( i - 1 >= 0 ? arr [ i - 1 ] : 0 ) - 1 ; answer *= c [ rem ] [ x ] % mod * ( i != 0 && i != k - 1 ? powOf2 [ x ] : 1 ) % mod ; rem -= x ; } return answer ; }
function ShortestPalindrome ( s ) { let n = s . length ; let ans = s [ 0 ] . charCodeAt ( ) ; for ( let i = 1 ; i < n ; i ++ ) { ans = Math . min ( ans , s [ i ] . charCodeAt ( ) ) ; } return String . fromCharCode ( ans ) ; }
function SumGPUtil ( r , n , m ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return ( 1 + r ) % m ; let ans ; if ( n % 2 == 1 ) { ans = ( 1 + r ) * SumGPUtil ( ( r * r ) % m , ( n - 1 ) / 2 , m ) ; } else { ans = 1 + ( r * ( 1 + r ) * SumGPUtil ( ( r * r ) % m , ( n / 2 ) - 1 , m ) ) ; } return ( ans % m ) ; }
function SumGP ( a , r , N , M ) { let answer ; answer = a * SumGPUtil ( r , N , M ) ; answer = answer % M ; document . write ( answer ) ; }
function findLeafDown ( root , lev , minDist ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { if ( lev < ( minDist . minDis ) ) minDist . minDis = lev ; return ; } findLeafDown ( root . left , lev + 1 , minDist ) ; findLeafDown ( root . right , lev + 1 , minDist ) ; }
function findThroughParent ( root , x , minDist ) { if ( root == null ) return - 1 ; if ( root == x ) return 0 ; var l = findThroughParent ( root . left , x , minDist ) ; if ( l != - 1 ) { findLeafDown ( root . right , l + 2 , minDist ) ; return l + 1 ; } var r = findThroughParent ( root . right , x , minDist ) ; if ( r != - 1 ) { findLeafDown ( root . left , r + 2 , minDist ) ; return r + 1 ; } return - 1 ; }
function minimumDistance ( root , x ) { d = new Distance ( ) ; findLeafDown ( x , 0 , d ) ; findThroughParent ( root , x , d ) ; return d . minDis ; }
function SmallestDiv ( n ) { for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return i ; } } return n ; }
function countOfNum ( n , a , b ) { let cnt_of_a , cnt_of_b , cnt_of_ab , sum ; cnt_of_a = Math . floor ( n / a ) ; cnt_of_b = Math . floor ( n / b ) ; sum = cnt_of_b + cnt_of_a ; cnt_of_ab = Math . floor ( n / ( a * b ) ) ; sum = sum - cnt_of_ab ; return sum ; }
function sumOfNum ( n , a , b ) { let i ; let sum = 0 ; let ans = new Set ( ) ; for ( i = a ; i <= n ; i = i + a ) { ans . add ( i ) ; } for ( i = b ; i <= n ; i = i + b ) { ans . add ( i ) ; } for ( let it of ans . values ( ) ) { sum = sum + it ; } return sum ; }
function isPalindrome ( r ) { let p = r ; p = reverse ( p ) ; return ( r == ( p ) ) ; }
function minimumAdjacentDifference ( a , n , k ) { let minDiff = Number . MAX_VALUE ; for ( let i = 0 ; i < ( 1 << n ) ; i ++ ) { let cnt = countSetBits ( i ) ; if ( cnt == n - k ) { let temp = [ ] ; for ( let j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) temp . push ( a [ j ] ) ; } let maxDiff = Number . MIN_VALUE ; for ( let j = 0 ; j < temp . length - 1 ; j ++ ) { maxDiff = Math . max ( maxDiff , temp [ j + 1 ] - temp [ j ] ) ; } minDiff = Math . min ( minDiff , maxDiff ) ; } } return minDiff ; }
function gcdFunc ( a , b ) { if ( b == 0 ) return a ; return gcdFunc ( b , a % b ) ; }
function findMinimumElements ( a , n ) { let b = new Array ( n - 1 ) ; for ( let i = 1 ; i < n ; i ++ ) { b [ i - 1 ] = a [ i ] - a [ i - 1 ] ; } let gcd = b [ 0 ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) { gcd = gcdFunc ( gcd , b [ i ] ) ; } let ans = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { ans += ( b [ i ] / gcd ) - 1 ; } return ans ; }
function checkPermutation ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; let prefix = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; prefix [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let lsum = prefix [ i ] ; let rsum = sum - prefix [ i ] ; let l_len = i + 1 , r_len = n - i - 1 ; if ( ( ( 2 * lsum ) == ( l_len * ( l_len + 1 ) ) ) && ( ( 2 * rsum ) == ( r_len * ( r_len + 1 ) ) ) ) return true ; } return false ; }
function maximumArea ( l , b , x , y ) { var left = x * b ; var right = ( l - x - 1 ) * b ; var above = l * y ; var below = ( b - y - 1 ) * l ; document . write ( Math . max ( Math . max ( left , right ) , Math . max ( above , below ) ) ) ; }
function precompute ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd [ i ] = 1 ; if ( arr [ i ] % 2 == 0 ) even [ i ] = 1 ; } for ( var i = 1 ; i < n ; i ++ ) { even [ i ] = even [ i ] + even [ i - 1 ] ; odd [ i ] = odd [ i ] + odd [ i - 1 ] ; } }
function isOdd ( L , R ) { var cnt = odd [ R ] ; if ( L > 0 ) cnt -= odd [ L - 1 ] ; if ( cnt == R - L + 1 ) return true ; return false ; }
function findTriplets ( x ) { let fact = [ ] ; let factors = new Set ( ) ; for ( let i = 2 ; i <= Math . sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { fact . push ( i ) ; if ( x / i != i ) fact . push ( x / i ) ; factors . add ( i ) ; factors . add ( x / i ) ; } } let found = false ; let k = fact . length ; for ( let i = 0 ; i < k ; i ++ ) { let a = fact [ i ] ; for ( let j = 0 ; j < k ; j ++ ) { let b = fact [ j ] ; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) { document . write ( a + "▁" + b + "▁" + ( x / ( a * b ) ) ) ; found = true ; break ; } } if ( found ) break ; } if ( ! found ) document . write ( "-1" ) ; }
function printArr ( arr , n ) { for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function findArray ( n , k , s ) { var vis = Array ( n ) . fill ( 0 ) ; var cnt = 0 ; var arr = Array ( n ) . fill ( 0 ) ; for ( i = 0 ; i < n && cnt < k ; i += 2 ) { arr [ i ] = s ; vis [ i ] = 1 ; cnt ++ ; } var val = s ; if ( s % 2 == 0 ) val ++ ; else val = val + 2 ; for ( i = 0 ; i < n ; i ++ ) { if ( vis [ i ] == 0 ) { arr [ i ] = val ; } } printArr ( arr , n ) ; }
function countPair ( a , b ) { var s = ( b . toString ( ) ) ; var i ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] != "9" ) break ; } var result ; if ( i == s . length ) result = a * s . length ; else result = a * ( s . length - 1 ) ; return result ; }
function getArea ( a ) { var area = ( Math . PI * a * a ) / 4 ; return area ; }
function flipsPossible ( a , n ) { let count_odd = 0 ; let count_even = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return false ; else return true ; }
function sumEqualProduct ( a , n ) { var zero = 0 , two = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } if ( a [ i ] == 2 ) { two ++ ; } } var cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ; return cnt ; }
function minSum ( n ) { var sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n = parseInt ( n / 10 ) ; } if ( sum == 1 ) return 10 ; return sum ; }
function initialize ( mul , div , size ) { for ( i = 1 ; i < size ; i ++ ) { mul [ i ] = ( mul [ i ] * mul [ i - 1 ] ) / div [ i ] ; } }
function update ( l , r , x , mul , div ) { mul [ l ] *= x ; div [ r + 1 ] *= x ; }
function printArray ( ar , mul , div , n ) { for ( i = 0 ; i < n ; i ++ ) { ar [ i ] = ar [ i ] * mul [ i ] ; document . write ( ar [ i ] + "▁" ) ; } }
function findTriangle ( S ) { let X1 = 0 , Y1 = 0 ; let X2 = MAX , Y2 = 1 ; let X3 = ( MAX - S % MAX ) % MAX ; let Y3 = ( S + X3 ) / MAX ; document . write ( "(" + X1 + ",▁" + Y1 + ")" ) ; document . write ( "(" + X2 + ",▁" + Y2 + ")" ) ; document . write ( "(" + X3 + ",▁" + Y3 + ")" ) }
function printArr ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function findArrangement ( arr , n ) { if ( n < 2 ) { document . write ( "-1" ) ; return ; } var minVal = arr . reduce ( ( a , b ) => Math . min ( a , b ) ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == minVal ) { [ arr [ i ] , arr [ n - 1 ] ] = [ arr [ n - 1 ] , arr [ i ] ] ; break ; } } var andVal = arr [ 0 ] ; for ( var i = 1 ; i < n - 1 ; i ++ ) { andVal &= arr [ i ] ; } if ( andVal == arr [ n - 1 ] ) printArr ( arr , n ) ; else document . write ( "-1" ) ; }
function maxOperations ( X , Y ) { if ( X > Y ) return - 1 ; let diff = Y - X ; if ( diff == 1 ) return - 1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; }
function precompute ( ) { for ( var i = 0 ; i < DIGITS ; i ++ ) dp [ 1 ] [ i ] = i , cnt [ 1 ] [ i ] = 1 ; for ( var i = 2 ; i < MAX ; i ++ ) { for ( var j = 0 ; j < DIGITS ; j ++ ) { for ( var k = 0 ; k < DIGITS ; k ++ ) { if ( j != k ) { dp [ i ] [ j ] = dp [ i ] [ j ] + ( dp [ i - 1 ] [ k ] + ( cnt [ i - 1 ] [ k ] * j ) % MOD ) % MOD ; dp [ i ] [ j ] %= MOD ; cnt [ i ] [ j ] += cnt [ i - 1 ] [ k ] ; cnt [ i ] [ j ] %= MOD ; } } } } }
function precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( var i = 4 ; i < N ; i ++ ) F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; }
function minimizedSum ( a , n , K ) { var sum = maxSubArraySum ( a , n ) ; var totalSum = 0 ; for ( var i = 0 ; i < n ; i ++ ) totalSum += a [ i ] ; if ( sum < 0 ) return totalSum ; totalSum = totalSum - sum + sum / K ; return totalSum ; }
function get ( L , R ) { let x = 1.0 / L ; let y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; }
function DivisorCount ( ) { for ( i = 1 ; i < N ; i ++ ) { for ( j = i ; j < N ; j += i ) { divi [ j ] ++ ; } } }
function pre ( ) { for ( i = 1 ; i < N ; i ++ ) { if ( prime [ divi [ i ] ] == 1 ) { sum [ i ] = i ; } } for ( i = 1 ; i < N ; i ++ ) sum [ i ] += sum [ i - 1 ] ; }
function consecutiveOnes ( x ) { let p = 0 ; while ( x > 0 ) { if ( x % 2 == 1 && p == 1 ) return true ; p = x % 2 ; x = parseInt ( x / 2 ) ; } return false ; }
function preCompute ( ) { for ( let i = 0 ; i <= MAX ; i ++ ) { if ( ! consecutiveOnes ( i ) ) v . push ( i ) ; } }
function nextValid ( n ) { let it = upper_bound ( v , n ) ; let val = v [ it ] ; return val ; }
function randomList ( m , n ) { let arr = new Array ( m ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { arr [ ( Math . floor ( ( Math . random ( ) * n ) ) % m ) ] ++ ; } printArr ( arr , m ) ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function nCrModPFermat ( n , r , p ) { if ( r == 0 ) return 1 ; let fac = new Array ( n + 1 ) ; fac [ 0 ] = 1 ; let i ; for ( i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; }
function countOdd ( n ) { let x = parseInt ( n / 2 , 10 ) ; if ( n % 2 == 1 ) x ++ ; return x ; }
function counteEven ( n ) { let x = parseInt ( n / 2 , 10 ) ; return x ; }
function sumPrime ( k ) { SieveOfEratosthenes ( ) ; let v = [ ] ; for ( let i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) v . push ( i ) ; } let sum = 0 ; let skip = parseInt ( ( k * ( k - 1 ) ) / 2 ) ; while ( k > 0 ) { sum += v [ skip ] ; skip ++ ; k -- ; } return sum ; }
function lcm ( x , y ) { var temp = ( x * y ) / __gcd ( x , y ) ; return temp ; }
function findNumbers ( a , n , b , m ) { var lcmA = 1 , gcdB = 0 ; for ( var i = 0 ; i < n ; i ++ ) lcmA = lcm ( lcmA , a [ i ] ) ; for ( var i = 0 ; i < m ; i ++ ) gcdB = __gcd ( gcdB , b [ i ] ) ; if ( gcdB % lcmA != 0 ) { document . write ( "-1" ) ; return ; } var num = lcmA ; while ( num <= gcdB ) { if ( gcdB % num == 0 ) document . write ( num + "▁" ) ; num += lcmA ; } }
function countSubStr ( str , n , ch ) { var cnt = 0 ; var j = nextOccurrence ( str , n , 0 , ch ) ; for ( var i = 0 ; i < n ; i ++ ) { while ( j !== - 1 && j < i ) { j = nextOccurrence ( str , n , j + 1 , ch ) ; } if ( j === - 1 ) break ; cnt += n - j ; } return cnt ; }
function checkEvenOdd ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { document . write ( "Even" ) ; return ; } } document . write ( "Odd" ) ; }
function power ( x , y ) { let res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }
function maxPartition ( s ) { var n = s . length , P = 0 ; var current = "" , previous = "" ; for ( var i = 0 ; i < n ; i ++ ) { current += s [ i ] ; if ( current != previous ) { previous = current ; current = "" ; P ++ ; } } return P ; }
function LongestSubarray ( a , n , k ) { var pre = Array . from ( { length : n } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > k ) pre [ i ] = 1 ; else pre [ i ] = - 1 ; } for ( i = 1 ; i < n ; i ++ ) pre [ i ] = pre [ i - 1 ] + pre [ i ] ; var len = 0 ; var lo = 1 , hi = n ; while ( lo <= hi ) { var mid = parseInt ( ( lo + hi ) / 2 ) ; var ok = false ; for ( i = mid - 1 ; i < n ; i ++ ) { var x = pre [ i ] ; if ( i - mid >= 0 ) x -= pre [ i - mid ] ; if ( x > 0 ) { ok = true ; break ; } } if ( ok == true ) { len = mid ; lo = mid + 1 ; } else hi = mid - 1 ; } return len ; }
function prime ( n ) { if ( n == 1 ) return false ; for ( let i = 2 ; i * i <= n ; ++ i ) if ( n % i == 0 ) return false ; return true ; }
function Min_Sum ( n ) { if ( prime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; else { if ( prime ( n - 2 ) ) return 2 ; else return 3 ; } }
function MinDeletion ( a , n ) { let map = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( map [ a [ i ] ] ) map [ a [ i ] ] ++ ; else map [ a [ i ] ] = 1 } let ans = 0 ; for ( var m in map ) { let x = m ; let frequency = map [ m ] ; if ( x <= frequency ) { ans += ( frequency - x ) ; } else ans += frequency ; } ; return ans ; }
function find_maximum_value ( a , n ) { var sum = 0 ; var minimum = Number . MAX_VALUE ; var pos = 0 , neg = 0 ; for ( i = 0 ; i < n ; i ++ ) { minimum = Math . min ( minimum , Math . abs ( a [ i ] ) ) ; sum += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) pos += 1 ; else neg += 1 ; } if ( pos > 0 && neg > 0 ) return sum ; return ( sum - 2 * minimum ) ; }
function maxCountAB ( s , n ) { var A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var S = s [ i ] ; var L = S . length ; for ( var j = 0 ; j < L - 1 ; j ++ ) { if ( S [ j ] == "A" && S [ j + 1 ] == "B" ) { ans ++ ; } } if ( S [ 0 ] == "B" && S [ L - 1 ] == "A" ) BA ++ ; else if ( S [ 0 ] == "B" ) B ++ ; else if ( S [ L - 1 ] == "A" ) A ++ ; } if ( BA == 0 ) ans += Math . min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + Math . min ( B , A ) ; return ans ; }
function MinOperations ( n , x , arr ) { let total = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( arr [ i ] > x ) { let difference = arr [ i ] - x ; total = total + difference ; arr [ i ] = x ; } } for ( let i = 1 ; i < n ; ++ i ) { let LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] ; if ( LeftNeigbouringSum > x ) { let current_diff = LeftNeigbouringSum - x ; arr [ i ] = Math . max ( 0 , arr [ i ] - current_diff ) ; total = total + current_diff ; } } return total ; }
function countPairs ( s ) { let st = new Set ( ) ; st . add ( "a" ) ; st . add ( "e" ) ; st . add ( "i" ) ; st . add ( "o" ) ; st . add ( "u" ) ; let count = 0 ; let n = s . length ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( st . has ( s [ i ] ) && ! st . has ( s [ i + 1 ] ) ) count ++ ; } return count ; }
function maxSize ( v , n ) { v . push ( 0 ) ; v . push ( 100001 ) ; n += 2 ; v . sort ( ( a , b ) => a - b ) ; let mx = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { let L = v [ i - 1 ] + 1 ; let R = v [ i + 1 ] - 1 ; let cnt = R - L + 1 ; mx = Math . max ( mx , cnt ) ; } return mx ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
function maxLength ( a , n ) { let sum = 0 , len = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return n ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) len = Math . max ( len , Math . max ( n - i - 1 , i ) ) ; } return len ; }
function countMaxLength ( N ) { var res ; var pre = Array ( MAXN ) , p = 1 ; pre [ 0 ] = 0 ; for ( var i = 1 ; i < MAXN ; i ++ ) { p *= 2 ; pre [ i ] = pre [ i - 1 ] + i * p ; } var ind ; for ( var i = 1 ; i < MAXN ; i ++ ) { if ( pre [ i ] >= N ) { ind = i ; break ; } } var x = N - pre [ ind - 1 ] ; var y = 2 * ind - 1 ; if ( x >= y ) res = Math . min ( x , y ) ; else res = Math . max ( x , 2 * ( ind - 2 ) + 1 ) ; return res ; }
function getMinVal ( p , q ) { if ( q % p == 0 ) return p ; return - 1 ; }
function findPoints ( l1 , r1 , l2 , r2 ) { var x = ( l1 != l2 ) ? Math . min ( l1 , l2 ) : - 1 ; var y = ( r1 != r2 ) ? Math . max ( r1 , r2 ) : - 1 ; document . write ( x + "▁" + y ) ; }
function countPrimePalindrome ( str , len ) { var prime = Array ( len + 1 ) . fill ( true ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( var p = 2 ; p * p <= len ; p ++ ) { if ( prime [ p ] ) { for ( var i = p * p ; i <= len ; i += p ) prime [ i ] = false ; } } var count = 0 ; for ( var j = 2 ; j <= len ; j ++ ) { if ( prime [ j ] ) { for ( var i = 0 ; i + j - 1 < len ; i ++ ) { if ( isPalindrome ( str , i , i + j - 1 ) ) count ++ ; } } } return count ; }
function minOperations ( N ) { var x = Math . log ( N ) / Math . log ( 2 ) ; var ans = parseInt ( ( Math . ceil ( x ) ) ) ; return ans ; }
function find_greatest_divisor ( l , r ) { if ( l == r ) return l ; return 1 ; }
function findNumbers ( arr , n ) { sumN = ( n * ( n + 1 ) ) / 2 ; sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; let sum = 0 ; let sumSq = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq += Math . pow ( arr [ i ] , 2 ) ; } B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; A = sum - sumN + B ; document . write ( "A▁=▁" + A , "B▁=▁" , B ) ; }
function factorialUsingRecursion ( n ) { if ( n == 0 ) return 1 ; return n * factorialUsingRecursion ( n - 1 ) ; }
function factorialUsingIteration ( n ) { var res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
function checkPerfectSquare ( n ) { let d = Math . sqrt ( n ) ; if ( d * d == n ) return true ; return false ; }
function largestPerfectSquareNumber ( a , n ) { let maxi = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( checkPerfectSquare ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; }
function convert ( n , a ) { let z = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] > z ) z = a [ i ] ; } z = z + 1 ; let ff = new Array ( z ) ; ff . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { ff [ a [ i ] ] += 1 ; } let cc = 0 ; for ( let i = 0 ; i < z ; i ++ ) { cc += parseInt ( ff [ i ] / 4 , 10 ) ; ff [ i ] = ff [ i ] % 4 ; } let vv = 0 ; for ( let i = 0 ; i < z ; i ++ ) { if ( ff [ i ] >= 2 ) vv += 1 ; } cc += parseInt ( vv / 2 , 10 ) ; document . write ( cc ) ; }
function getProbability ( p , q ) { p /= 100 ; q /= 100 ; let probability = ( p * p + q * q ) / ( p + q ) ; return probability ; }
function check ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) return true ; } return false ; }
function find_LCM ( x , y ) { return Math . floor ( ( x * y ) / gcd ( x , y ) ) ; }
function CountPairs ( n , m , A , B ) { let cnt = 0 ; let lcm = find_LCM ( A , B ) ; for ( let i = 1 ; i <= n ; i ++ ) cnt += Math . floor ( ( m + ( i % lcm ) ) / lcm ) ; return cnt ; }
function sortArr ( arr , n , min , max ) { let m = max - min + 1 ; let c = new Array ( m ) ; c . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { c [ arr [ i ] - min ] ++ ; } for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < c [ i ] ; j ++ ) { document . write ( ( i + min ) + "▁" ) ; } } }
function revereseArray ( arr , n ) { for ( let i = 0 ; i < n / 2 ; i ++ ) arr [ i ] = __ ( arr [ n - i - 1 ] , arr [ n - i - 1 ] = arr [ i ] ) ; }
function recursiveLogStar ( n , b ) { if ( n > 1.0 ) return 1.0 + recursiveLogStar ( _log ( n , b ) , b ) ; else return 0 ; }
function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
function fact ( n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
function maxKth ( arr , N , C , K ) { if ( N + C < K ) { return - 1 ; } let iter = 300 ; let l = 0 , r = 1000000000.0 ; while ( iter -- ) { let mid = ( l + r ) * 0.5 ; let a = 0 ; let b = 0 ; for ( let i = 0 ; i < N ; i ++ ) { a += Math . floor ( arr [ i ] / mid ) ; if ( arr [ i ] >= mid ) { b ++ ; } } if ( a >= K && b + C >= K ) { l = mid ; } else { r = mid ; } } return l ; }
function isPossibleToSelect ( arr , N , dif , K ) { let count = 1 ; let prev = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= ( prev + dif ) ) { count ++ ; if ( count == K ) return true ; prev = arr [ i ] ; } } return false ; }
function binarySearch ( arr , left , right , K , N ) { let ans = 1 ; while ( left <= right ) { let dif = left + Math . floor ( ( right - left ) / 2 ) ; if ( isPossibleToSelect ( arr , N , dif , K ) ) { ans = Math . max ( ans , dif ) ; left = dif + 1 ; } else right = dif - 1 ; } return ans ; }
function cal ( arr , mid ) { let chocolate = 0  for ( let i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] >= mid ) chocolate += arr [ i ] - mid } return chocolate }
function check ( bananas , mid_val , H ) { let time = 0 ; for ( let i = 0 ; i < bananas . length ; i ++ ) { if ( bananas [ i ] % mid_val != 0 ) { time += Math . floor ( bananas [ i ] / mid_val ) + 1 ; } else { time += Math . floor ( bananas [ i ] / mid_val ) ; } } if ( time <= H ) { return true ; } else { return false ; } }
function minEatingSpeed ( piles , H ) { let start = 1 ; let end = [ ... piles ] . sort ( ( a , b ) => b - a ) [ 0 ] ; while ( start < end ) { let mid = start + Math . floor ( ( end - start ) / 2 ) ; if ( check ( piles , mid , H ) == true ) { end = mid ; } else { start = mid + 1 ; } } return end ; }
function is_prefix ( temp , str ) { if ( temp . length < str . length ) return 0 ; else { for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] != temp [ i ] ) return 0 ; } return 1 ; } }
function lexicographicallyString ( input , n , str ) { input = Array . from ( input ) . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let temp = input [ i ] ; if ( is_prefix ( temp , str ) ) { return temp ; } } return "-1" ; }
function minSumPair ( arr , N ) { if ( N < 5 ) { return - 1 ; } let prefixMin = new Array ( N ) . fill ( 0 ) ; prefixMin [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < N - 1 ; i ++ ) { prefixMin [ i ] = Math . min ( arr [ i ] , prefixMin [ i - 1 ] ) ; } let ans = Number . MAX_VALUE ; for ( let i = 3 ; i < N - 1 ; i ++ ) { ans = Math . min ( ans , arr [ i ] + prefixMin [ i - 2 ] ) ; } return ans ; }
function check ( H , A , mid , N , M , L ) { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let speed = mid * A [ i ] + H [ i ] ; if ( speed >= L ) { sum += speed ; } } return sum ; }
function buzzTime ( N , M , L , H , A ) { let low = 0 , high = 1e10 ; let ans = 0 ; while ( high >= low ) { let mid = Math . floor ( low + ( high - low ) / 2 ) ; if ( check ( H , A , mid , N , M , L ) >= M ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; }
function findCount ( number ) { let sum = 0 ; for ( let i = 0 ; i < number . length ; ++ i ) { sum += number [ i ] - 48 ; } let count = 0 ; for ( let i = 0 ; i < number . length ; ++ i ) { let remaining_sum = sum - ( number [ i ] - 48 ) ; for ( let j = 0 ; j <= 9 ; ++ j ) { if ( ( remaining_sum + j ) % 3 == 0 && j != number [ i ] - 48 ) { ++ count ; } } } document . write ( count ) ; }
function is_possible ( teams , T , k ) { let sum = 0 ; for ( let i = 0 ; i < teams . length ; i ++ ) { sum += Math . min ( T , teams [ i ] ) ; } return sum >= T * k ; }
function countOfTeams ( teams_list , N , K ) { let lb = 0 , ub = 1e9 ; while ( lb <= ub ) { let mid = Math . floor ( lb + ( ub - lb ) / 2 ) ; if ( is_possible ( teams_list , mid , K ) ) { if ( ! is_possible ( teams_list , mid + 1 , K ) ) { return mid ; } else { lb = mid + 1 ; } } else { ub = mid - 1 ; } } return 0 ; }
function balBracketSequence ( str ) { let n = str . length ; if ( str [ 0 ] == str [ n - 1 ] ) { document . write ( "No" ) ; } else { let cntForOpen = 0 , cntForClose = 0 ; let check = 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) cntForOpen ++ ; else if ( str [ i ] == str [ n - 1 ] ) cntForOpen -- ; else cntForOpen ++ ; if ( cntForOpen < 0 ) { check = 0 ; break ; } } if ( check && cntForOpen == 0 ) { document . write ( "Yes,▁" ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ n - 1 ] ) document . write ( ")" ) ; else document . write ( "(" ) ; } return ; } else { for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) cntForClose ++ ; else cntForClose -- ; if ( cntForClose < 0 ) { check = 0 ; break ; } } if ( check && cntForClose == 0 ) { document . write ( "Yes,▁" ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) document . write ( "(" ) ; else document . write ( ")" ) ; } return ; } } document . write ( "No" ) ; } }
function minimumOperations ( arr , N ) { let mx = 0 , pos = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= mx ) { mx = arr [ i ] ; pos = i ; } } document . write ( ( mx - 1 ) * N + pos + 1 ) ; }
function check ( v , a ) { let tec = 0 , ans = 0 ; let b = new Array ( n + k + 1 ) . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { tec -= b [ i ] ; if ( a [ i ] + tec < v ) { let mov = v - a [ i ] - tec ; ans = ans + mov ; tec += mov ; b [ i + k ] = mov ; } } return ans <= m ; }
function FindLargest ( a ) { l = 1 ; r = Math . pow ( 10 , 10 ) ; while ( r - l > 0 ) { let tm = Math . floor ( ( l + r + 1 ) / 2 ) ; if ( check ( tm , a ) ) l = tm ; else r = tm - 1 ; } return l ; }
function largestAltitude ( L , B ) { if ( L > B ) { let temp = B ; B = L ; L = temp ; } let low = 0 , high = L ; let res = 0 ; while ( low <= high ) { let mid = Math . floor ( low + ( high - low ) / 2 ) ; if ( mid <= Math . floor ( B / 2 ) ) { res = mid ; low = mid + 1 ; } else high = mid - 1 ; } return res ; }
function findLargestIndex ( arr , n ) { for ( var i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == i ) { document . write ( i ) ; return ; } } document . write ( - 1 ) ; }
function isMaximumMedian ( arr , N , K , mid ) { let Pre = Array ( N + 5 ) . fill ( ) . map ( ( ) => Array ( N + 5 ) . fill ( 0 ) ) ; for ( let i = 0 ; i < N ; ++ i ) { for ( let j = 0 ; j < N ; ++ j ) { Pre [ i + 1 ] [ j + 1 ] = Pre [ i + 1 ] [ j ] + Pre [ i ] [ j + 1 ] - Pre [ i ] [ j ] ; if ( arr [ i ] [ j ] <= mid ) Pre [ i + 1 ] [ j + 1 ] ++ ; } } let required = Math . floor ( ( K * K + 1 ) / 2 ) ; let flag = 0 ; for ( let i = K ; i <= N ; ++ i ) { for ( let j = K ; j <= N ; ++ j ) { let X = Pre [ i ] [ j ] - Pre [ i - K ] [ j ] - Pre [ i ] [ j - K ] + Pre [ i - K ] [ j - K ] ; if ( X < required ) flag = 1 ; } } return flag ; }
function getPairsCount ( a , n ) { let count = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] * a [ j ] ) == Math . abs ( i - j ) ) count ++ ; } } return count ; }
function getPairsCount ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && arr [ i ] * arr [ j ] == Math . abs ( i - j ) ) { count ++ ; } } } return count ; }
function numberofSubsequences ( a , L , R , X , n ) { let ans = 0 ; for ( let i = 0 ; i < ( 1 << n ) ; i ++ ) { let cnt = 0 , sum = 0 ; let minVal = Number . MAX_SAFE_INTEGER , maxVal = Number . MIN_SAFE_INTEGER ; for ( let j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) ) { cnt += 1 ; sum += a [ j ] ; maxVal = Math . max ( maxVal , a [ j ] ) ; minVal = Math . min ( minVal , a [ j ] ) ; } } if ( cnt >= 2 && sum >= L && sum <= R && ( maxVal - minVal >= X ) ) { ans += 1 ; } } return ans ; }
function numberofBoxes ( W , B , O ) { let low = 0 , high = Math . min ( W , B ) ; let ans = 0 ; while ( low <= high ) { let mid = low + Math . floor ( ( high - low ) / 2 ) ; if ( ( ( W >= mid ) && ( B >= mid ) ) && ( ( W - mid ) + ( B - mid ) + O ) >= mid ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } document . write ( ans ) ; }
function minSwaps ( N , M , A , B ) { let count01 = 0 ; let count10 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { if ( A [ i ] [ j ] == 1 ) count10 ++ ; else count01 ++ ; } } } if ( count01 == count10 ) return count01 ; else return - 1 ; }
function Count ( N , K ) { if ( K == 0 ) return 0 ; var res = 0 ; var low = 2 , high = N ; while ( low <= high ) { var mid = ( low + high ) / 2 ; var sum = ( mid * mid + mid ) / 2 ; if ( sum <= K ) { res = Math . max ( res , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return res ; }
function createLoops ( root ) { preorderTraversal ( root ) ; let i ; for ( i = 1 ; i < even_ptrs . length ; i ++ ) even_ptrs [ i - 1 ] . abtr = even_ptrs [ i ] ; even_ptrs [ i - 1 ] . abtr = even_ptrs [ 0 ] ; for ( i = 1 ; i < odd_ptrs . length ; i ++ ) odd_ptrs [ i - 1 ] . abtr = odd_ptrs [ i ] ; odd_ptrs [ i - 1 ] . abtr = odd_ptrs [ 0 ] ; }
function traverseLoop ( start ) { let curr = start ; do { document . write ( curr . data + "▁" ) ; curr = curr . abtr ; } while ( curr != start ) ; }
function repeatingElement ( arr , N ) { let M = 0 , sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; M = Math . max ( M , arr [ i ] ) ; } let sum1 = parseInt ( M * ( M + 1 ) / 2 ) ; let ans = parseInt ( ( sum - sum1 ) / ( N - M ) ) ; return ans ; }
function lexicographicallyMaximum ( S , N ) { let M = new Map ( ) ; for ( let i = 0 ; i < N ; ++ i ) { if ( M . has ( S [ i ] ) ) M . set ( S [ i ] , M . get ( S [ i ] ) + 1 ) ; else M . set ( S [ i ] , 1 ) ; } let V = [ ] ; for ( let i = "a" . charCodeAt ( ) ; i < ( "a" . charCodeAt ( ) + Math . min ( N , 25 ) ) ; ++ i ) { if ( M . has ( String . fromCharCode ( i ) ) == false ) { V . push ( String . fromCharCode ( i ) ) ; } } let j = V . length - 1 ; for ( let i = 0 ; i < N ; ++ i ) { if ( S [ i ] . charCodeAt ( ) >= ( "a" . charCodeAt ( ) + Math . min ( N , 25 ) ) || ( M . has ( S [ i ] ) && M . get ( S [ i ] ) > 1 ) ) { if ( V [ j ] . charCodeAt ( ) < S [ i ] . charCodeAt ( ) ) continue ; M . set ( S [ i ] , M . get ( S [ i ] ) - 1 ) ; S = S . substr ( 0 , i ) + V [ j ] + S . substr ( i + 1 ) ; j -- ; } if ( j < 0 ) break ; } let l = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( l > j ) break ; if ( S [ i ] . charCodeAt ( ) >= ( "a" . charCodeAt ( ) + Math . min ( N , 25 ) ) || M . has ( S [ i ] ) && M . get ( S [ i ] ) > 1 ) { M . set ( S [ i ] , M . get ( S [ i ] ) - 1 ) ; S = S . substr ( 0 , i ) + V [ l ] + S . substr ( i + 1 ) ; l ++ ; } } return S ; }
function minimumK ( arr , M , N ) { let good = Math . floor ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) + 1 ; for ( let i = 1 ; i <= N ; i ++ ) { let K = i ; let candies = N ; let taken = 0 ; while ( candies > 0 ) { taken += Math . min ( K , candies ) ; candies -= Math . min ( K , candies ) ; for ( let j = 0 ; j < M ; j ++ ) { let consume = ( arr [ j ] * candies ) / 100 ; candies -= consume ; } } if ( taken >= good ) { document . write ( i ) ; return ; } } }
function minTimeToColor ( node , parent , arrival_time ) { let current_time = 0 ; for ( let x = 0 ; x < edges [ node ] . length ; x ++ ) { if ( edges [ node ] [ x ] != parent ) { ++ current_time ; if ( current_time == arrival_time ) ++ current_time ; ans = Math . max ( ans , current_time ) ; minTimeToColor ( edges [ node ] [ x ] , node , current_time ) ; } } }
function countElement ( arr , N ) { let count = 0 ; let m = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( m . has ( arr [ i ] ) ) { m . set ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) } else { m . set ( arr [ i ] , 1 ) } } for ( let i = 0 ; i < N ; i ++ ) { let lg = Math . floor ( Math . log2 ( arr [ i ] ) ) ; let p = Math . pow ( 2 , lg ) ; if ( m . get ( p ) ) { count ++ ; } } return count ; }
function findLarger ( arr , n ) { let mid = ( n + 1 ) / 2 ; let mx = Math . max . apply ( null , arr )  var count = new Array ( mx + 1 ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { count [ arr [ i ] ] ++ ; } for ( let i = mx ; i >= 0 ; i -- ) { while ( count [ i ] > 0 ) { count [ i ] -- ; mid -- ; document . write ( i + "▁" ) ; if ( mid == 0 ) break ; } if ( mid == 0 ) break ; } }
function maximizeMangoes ( n , m , x , y ) { var l = 0 , r = n ; var ans = 0 ; while ( l <= r ) { var mid = l + parseInt ( ( r - l ) / 2 ) ; if ( check ( n , m , x , y , mid ) ) { ans = mid ; l = mid + 1 ; } else r = mid - 1 ; } return ans ; }
function probability ( arr1 , arr2 ) { let N = arr1 . length ; let M = arr2 . length ; let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let y = 0 ; for ( let j = 0 ; j < M ; j ++ ) { if ( arr2 [ j ] > arr1 [ i ] ) y ++ ; } res += y ; } res = ( res / ( N * M ) ) ; return res ; }
function probability ( arr1 , arr2 ) { var N = 4 ; var M = 4 ; var res = 0 ; arr2 . sort ( function ( a , b ) { return a - b ; } ) ; for ( var i = 0 ; i < N ; i ++ ) { var y = countGreater ( arr2 , arr1 [ i ] ) ; res += y ; } res = res / ( N * M ) ; return res ; }
function countGreater ( arr , k ) { var n = 4 ; var l = 0 ; var r = n - 1 ; var leftGreater = n ; while ( l <= r ) { var m = Math . floor ( l + ( r - l ) / 2 ) ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return n - leftGreater ; }
function findkthElement ( arr , n , K ) { var l = 0 ; var h = n - 1 , r ; while ( l + 1 < h ) { var mid = parseInt ( ( l + h ) / 2 ) ; if ( arr [ l ] >= arr [ mid ] ) l = mid ; else h = mid ; } if ( arr [ l ] < arr [ h ] ) r = l ; else r = h ; if ( K <= r + 1 ) return arr [ r + 1 - K ] ; else return arr [ n - ( K - ( r + 1 ) ) ] ; }
function find ( arr , N , key ) { let l = 0 ; let h = N - 1 ; while ( l <= h ) { let mid = Math . floor ( ( l + h ) / 2 ) ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] >= arr [ mid ] ) { if ( arr [ l ] >= key && key >= arr [ mid ] ) h = mid - 1 ; else l = mid + 1 ; } else { if ( arr [ mid ] >= key && key >= arr [ h ] ) l = mid + 1 ; else h = mid - 1 ; } } return - 1 ; }
function countInversions ( arr , n ) { var v = [ ] ; var i ; for ( i = 1 ; i <= n ; i ++ ) { v . push ( i ) ; } var ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { var index = v . indexOf ( arr [ i ] ) ; ans += index ; v . splice ( index , 1 ) ; } document . write ( ans ) ; }
function countDistinct ( arr , L , R ) { let count = 0 ; let pref = Array . from ( { length : arr . length + 1 } , ( _ , i ) => 0 ) ; for ( let i = 1 ; i <= arr . length ; ++ i ) { count += arr [ i - 1 ] ; pref [ i ] = count ; } let left = binarysearch ( pref , arr . length + 1 , L ) ; let right = binarysearch ( pref , arr . length + 1 , R ) ; document . write ( ( right - left ) + 1 ) ; }
function ischar ( x ) { if ( ( x >= "A" && x <= "Z" ) || ( x >= "a" && x <= "z" ) ) { return true ; } return false ; }
function isnum ( x ) { if ( x >= "0" && x <= "9" ) return true ; return false ; }
function maxItems ( n , m , a , b , K ) { var count = 0 ; var A = new Array ( n + 1 ) ; var B = new Array ( m + 1 ) ; A [ 0 ] = 0 ; B [ 0 ] = 0 ; var i ; for ( i = 1 ; i <= n ; i ++ ) { A [ i ] = a [ i - 1 ] + A [ i - 1 ] ; } for ( i = 1 ; i <= m ; i ++ ) { B [ i ] = b [ i - 1 ] + B [ i - 1 ] ; } for ( i = 0 ; i <= n ; i ++ ) { if ( A [ i ] > K ) break ; var rem = K - A [ i ] ; var j = 0 ; var lo = 0 , hi = m ; while ( lo <= hi ) { var mid = parseInt ( ( lo + hi ) / 2 ) ; if ( B [ mid ] <= rem ) { j = mid ; lo = mid + 1 ; } else { hi = mid - 1 ; } } count = Math . max ( j + i , count ) ; } document . write ( count ) ; }
function isValid ( weight , n , D , mx ) { let st = 1 ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += weight [ i ] ; if ( sum > mx ) { st ++ ; sum = weight [ i ] ; } if ( st > D ) return false ; } return true ; }
function shipWithinDays ( weight , D , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += weight [ i ] ; let s = weight [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { s = Math . max ( s , weight [ i ] ) ; } let e = sum ; let res = - 1 ; while ( s <= e ) { let mid = s + Math . floor ( ( e - s ) / 2 ) ; if ( isValid ( weight , n , D , mid ) ) { res = mid ; e = mid - 1 ; } else s = mid + 1 ; } document . write ( res ) ; }
function countWays ( index , target ) { if ( target == 0 ) return 1 ; if ( index < 0 target < 0 ) return 0 ; var inc = countWays ( index , target - psquare [ index ] ) ; var exc = countWays ( index - 1 , target ) ; return inc + exc ; }
function findSum ( arr , N , pt ) { var sum = 0 ; var i ; for ( i = 0 ; i < N ; i ++ ) { sum += Math . abs ( arr [ i ] - pt ) ; } return sum ; }
function findArray ( arr , n ) { let v = new Array ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let ans = - 1 , old_c = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { let curr_c = 0 ; arr . slice ( j , n ) . forEach ( ( item ) => { if ( item == arr [ j ] ) { curr_c ++ } } )  if ( curr_c == old_c ) { if ( arr [ j ] < ans ) ans = arr [ j ] ; } if ( curr_c > old_c ) { ans = arr [ j ] ; old_c = curr_c ; } } } v . push ( ans ) ; } for ( let i = 0 ; i < v . length ; i ++ ) document . write ( v [ i ] + "▁" ) ; }
function minDays ( P , arr ) { for ( var i = 1 ; i < P . length ; i ++ ) { P [ i ] += P [ i ] + P [ i - 1 ] ; } for ( var i = 0 ; i < arr . length ; i ++ ) { var index = binarySeach ( P , arr [ i ] ) ; if ( index != - 1 ) { document . write ( ( index + 1 ) + "▁" ) ; } else { document . write ( - 1 + "▁" ) ; } } }
function countTriplets ( D , arr ) { var freq = new Map ( ) ; var ans = 0 ; var i ; for ( i = 0 ; i < arr . length ; i ++ ) { if ( freq . has ( arr [ i ] - D ) && freq . has ( arr [ i ] - 2 * D ) ) { ans += freq . get ( arr [ i ] - D ) * freq . get ( arr [ i ] - 2 * D ) ; } freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } return ans ; }
function find_index ( arr , N ) { let max_value = Number . MIN_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { max_value = Math . max ( max_value , arr [ i ] ) ; } let store = new Map ( ) ; for ( let i = 1 ; i <= max_value ; i ++ ) { if ( ! store . has ( i ) ) store . set ( i , 0 ) ; store . set ( i , store . get ( i ) + 1 ) ; } if ( store . has ( 1 ) ) { store . delete ( 1 ) ; } for ( let i = 2 ; i <= Math . sqrt ( max_value ) ; i ++ ) { let multiple = 2 ; while ( ( i * multiple ) <= max_value ) { if ( store . has ( i * multiple ) ) { store . delete ( i * multiple ) ; } multiple ++ ; } } let prime_sum_from_left = 0 ; let first_array = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { first_array [ i ] = prime_sum_from_left ; if ( store . has ( arr [ i ] ) ) { prime_sum_from_left += arr [ i ] ; } } let prime_sum_from_right = 0 ; let second_array = new Array ( N ) ; for ( let i = N - 1 ; i >= 0 ; i -- ) { second_array [ i ] = prime_sum_from_right ; if ( store . has ( arr [ i ] ) ) { prime_sum_from_right += arr [ i ] ; } } for ( let i = 0 ; i < N ; i ++ ) { if ( first_array [ i ] == second_array [ i ] ) { return i ; } } return - 1 ; }
function convert ( arr , n ) { var brr = Array ( n ) . fill ( 0 ) ; var i ; for ( i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; brr . sort ( ) ; for ( i = 0 ; i < n ; i ++ ) { var l = 0 , r = n - 1 , mid ; while ( l <= r ) { mid = parseInt ( ( l + r ) / 2 , 10 ) ; if ( brr [ mid ] == arr [ i ] ) { document . write ( mid + "▁" ) ; break ; } else if ( brr [ mid ] < arr [ i ] ) { l = mid + 1 ; } else { r = mid - 1 ; } } } }
function findIndex ( arr , N ) { let maxValue = Number . MIN_VALUE ; ; for ( let i = 0 ; i < N ; i ++ ) { maxValue = Math . max ( maxValue , arr [ i ] ) ; } var St = new Map ( ) ; for ( let i = 1 ; i <= maxValue ; i ++ ) { St . set ( i , 1 ) ; } if ( St . has ( 1 ) ) { St . delete ( 1 ) ; } for ( let i = 2 ; i <= Math . sqrt ( maxValue ) ; i ++ ) { let j = 2 ; while ( ( i * j ) <= maxValue ) { if ( St . has ( i * j ) ) { St . delete ( i * j ) ; } j ++ ; } } let LeftCount = 0 ; let Prefix = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { Prefix [ i ] = LeftCount ; if ( St . has ( arr [ i ] ) ) { LeftCount ++ ; } } let RightCount = 0 ; let Suffix = new Array ( N ) ; for ( let i = N - 1 ; i >= 0 ; i -- ) { Suffix [ i ] = RightCount ; if ( St . has ( arr [ i ] ) ) { RightCount ++ ; } } for ( let i = 0 ; i < N ; i ++ ) { if ( Prefix [ i ] == Suffix [ i ] ) { return i ; } } return - 1 ; }
function getCountPairs ( arr , N , S ) { let count = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { for ( let j = i + 1 ; j < arr . length ; j ++ ) { if ( ( arr [ i ] + arr [ j ] ) == S ) count ++ ; } } return count ; }
function isPrime ( N ) { if ( N == 1 ) return false ; for ( var i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; }
function findCoPrime ( L , R ) { var coPrime ; for ( var i = R + 1 ; ; i ++ ) { if ( isPrime ( i ) ) { coPrime = i ; break ; } } return coPrime ; }
function replaceCharacters ( s , p ) { var n = s . length , k = p . length ; var arr = new Array ( 26 ) . fill ( 0 ) ; var brr = new Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { arr [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] = s [ i ] ; brr [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] = s [ i ] ; } for ( var j = 0 ; j < k ; j ++ ) { var a = p [ j ] [ 0 ] , b = p [ j ] [ 1 ] ; for ( var i = 0 ; i < 26 ; i ++ ) { if ( arr [ i ] === a ) { brr [ i ] = b ; } } } for ( var i = 0 ; i < n ; i ++ ) { document . write ( brr [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ) ; } }
function maximumValue ( arr , n ) { var ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { ans = Math . max ( ans , arr [ i ] + arr [ j ] + i - j ) ; } } document . write ( ans ) ; }
function maximumValue ( arr , n ) { var maxvalue = arr [ 0 ] ; var result = 0 ; for ( i = 1 ; i < n ; i ++ ) { result = Math . max ( result , maxvalue + arr [ i ] - i ) ; maxvalue = Math . max ( maxvalue , arr [ i ] + i ) ; } document . write ( result ) ; }
function smallestSemiPrime ( n ) { let prime = Array . from ( { length : MAX } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } SieveOfEratosthenes ( prime ) ; let num1 = n + 1 ; while ( prime [ num1 ] != true ) { num1 ++ ; } let num2 = num1 + n ; while ( prime [ num2 ] != true ) { num2 ++ ; } document . write ( num1 * num2 ) ; }
function productOfTwoPerfectCubes ( N ) { let cubes = new Map ( ) ; for ( let i = 1 ; i * i * i <= N ; i ++ ) cubes . set ( i * i * i , i ) ; for ( let [ key , value ] of cubes . entries ( ) ) { let firstNumber = key ; if ( N % key == 0 ) { let secondNumber = N / key ; if ( cubes . has ( secondNumber ) ) { document . write ( "Yes" ) ; return ; } } } document . write ( "No" ) ; }
function productOfTwoPerfectCubes ( N ) { var cube_root ; cube_root = Math . round ( Math . cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { document . write ( "Yes" ) ; return ; } else { document . write ( "No" ) ; return ; } }
function bound ( w , h , N , x ) { let val = parseInt ( x / w ) * parseInt ( x / h ) ; if ( val >= N ) return true ; else return false ; }
function FindSquare ( N , W , H ) { let i = 1 ; let j = W * H * N ; while ( i < j ) { let mid = i + parseInt ( ( j - i ) / 2 ) ; if ( bound ( W , H , N , mid ) ) j = mid ; else i = mid + 1 ; } return j ; }
function printNumberOfPairs ( N ) { var st = new Set ( ) ; for ( let i = 2 ; i * i <= N ; i ++ ) { let x = i ; while ( x <= N ) { x *= i ; if ( x <= N ) { st . add ( x ) ; } } } document . write ( st . size ) ; }
function countSetBits ( n ) { let count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
function maximumProduct ( words ) { let bits = new Array ( words . length ) . fill ( 0 ) ; for ( let i = 0 ; i < words . length ; i ++ ) { for ( let j = 0 ; j < words [ i ] . length ; j ++ ) { bits [ i ] = bits [ i ] | 1 << ( words [ i ] [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ) ; } } let result = 0 ; for ( let i = 0 ; i < bits . length ; i ++ ) { for ( let j = i + 1 ; j < bits . length ; j ++ ) { if ( ( bits [ i ] & bits [ j ] ) == 0 ) { let L = countSetBits ( bits [ i ] ) ; let R = countSetBits ( bits [ j ] ) ; result = Math . max ( L * R , result ) ; } } } document . write ( result ) ; }
function closestValue ( A , k ) { let close = A [ A . length - 1 ] ; let it = lower_bound ( A , k ) ; if ( it != A . length ) { close = A [ it ] ; if ( it != 0 ) { if ( ( k - A [ it - 1 ] ) < ( close - k ) ) { close = A [ it - 1 ] ; } } } return close ; }
function minPossible ( arr , brr , crr ) { arr . sort ( ) ; crr . sort ( ) ; let minimum = Number . MAX_VALUE ; for ( let val in brr ) { let arr_close = closestValue ( arr , val ) ; let crr_close = closestValue ( crr , val ) ; if ( Math . abs ( val - arr_close ) + Math . abs ( val - crr_close ) < minimum ) minimum = Math . abs ( val - arr_close ) + Math . abs ( val - crr_close ) ; } document . write ( minimum ) ; }
function findCost ( A , N ) { var totalCost = 0 ; var i ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; }
function palindrome ( str ) { var st = 0 ; var ed = str . length - 1 ; while ( st < ed ) { if ( str [ st ] == str [ ed ] ) { st ++ ; ed -- ; } else return false ; } return true ; }
function possible ( A , N , mid , K ) { var count = 0 ; var i ; for ( i = 0 ; i < N ; i ++ ) { count += Math . floor ( ( A [ i ] - 1 ) / mid ) ; } if ( count <= K ) return true ; else return false }
function minimumMaximum ( A , N , K ) { var lo = 1 ; var hi = Math . max . apply ( Math , A ) ; var mid ; while ( lo < hi ) { mid = Math . floor ( ( lo + hi ) / 2 ) ; if ( possible ( A , N , mid , K ) ) { hi = mid ; } else { lo = mid + 1 ; } } return hi ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
function sumOfPrimeSquare ( n ) { let i = 0 ; let squares = [ ] ; while ( i * i < n ) { squares . push ( i * i ) ; i ++ ; } let flag = false ; for ( i = 0 ; i < squares . length ; i ++ ) { let difference = n - squares [ i ] ; if ( isPrime ( difference ) ) { flag = true ; break ; } } if ( flag ) { document . write ( "Yes" ) ; } else document . write ( "No" ) ; }
function SieveOfEratosthenes ( prime , n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } }
function sumOfPrimeSquare ( n ) { let flag = false ; let prime = new Array ( n + 1 ) . fill ( true ) ; SieveOfEratosthenes ( prime , n ) ; for ( let i = 0 ; i <= n ; i ++ ) { if ( ! prime [ i ] ) continue ; let dif = n - i ; if ( Math . ceil ( Math . sqrt ( dif ) ) == Math . floor ( Math . sqrt ( dif ) ) ) { flag = true ; break ; } } if ( flag ) { document . write ( "Yes" ) ; } else document . write ( "No" ) ; }
function minimum_swaps ( arr , n ) { var count = 0 ; var max_el = Math . max ( ... arr ) ; var min_el = Math . min ( ... arr ) ; if ( min_el === max_el ) return 0 ; var index_max = - 1 ; var index_min = - 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] === max_el && index_max === - 1 ) { index_max = i ; } if ( arr [ i ] === min_el ) { index_min = i ; } } count += index_max ; count += n - 1 - index_min ; if ( index_min < index_max ) count -= 1 ; return count ; }
function check ( arr , M , K , ind ) { for ( let i = 0 ; i < M ; i ++ ) { for ( let j = 1 ; j < K ; j ++ ) { if ( arr [ ind + i ] != arr [ ind + i + j * M ] ) { return false ; } } } return true ; }
function SubarrayRepeatsKorMore ( arr , N , M , K ) { for ( let ind = 0 ; ind <= N - M * K ; ind ++ ) { if ( check ( arr , M , K , ind ) ) { return true ; } } return false ; }
function checkExists ( arr , N , M , K ) { let count = 0 ; for ( let i = 0 ; i < N - M ; i ++ ) { if ( arr [ i ] == arr [ i + M ] ) count ++ ; else count = 0 ; if ( count == M * ( K - 1 ) ) return true ; } return false ; }
function CommonDigits ( N , M ) { var count = 0 ; var freq1 = Array ( 10 ) . fill ( 0 ) ; var freq2 = Array ( 10 ) . fill ( 0 ) ; while ( N > 0 ) { freq1 [ N % 10 ] ++ ; N = Math . floor ( N / 10 ) ; } while ( M > 0 ) { freq2 [ M % 10 ] ++ ; M = Math . floor ( M / 10 ) ; } var i ; for ( i = 0 ; i < 10 ; i ++ ) { if ( freq1 [ i ] > 0 & freq2 [ i ] > 0 ) { count ++ ; } } return count ; }
function minimumNumber ( K , X ) { if ( K > X ) { document . write ( "-1" ) ; return ; } let ans = 0 ; let sum = 0 ; for ( let i = K ; i <= X ; i ++ ) { sum += i ; if ( sum >= X ) { ans = i ; break ; } } document . write ( ans ) ; }
function isGreaterEqual ( N , K , X ) { return ( ( N * parseInt ( ( N + 1 ) / 2 ) ) - ( ( K - 1 ) * parseInt ( K / 2 ) ) ) >= X ; }
function left_search ( A , num ) { let low = 0 , high = A . length - 1 ; let ans = 0 ; while ( low <= high ) { let mid = low + Math . floor ( ( high - low ) / 2 ) ; if ( A [ mid ] >= num ) { ans = mid ; high = mid - 1 ; } else { low = mid + 1 ; } } return ans ; }
function totalCount ( A , N , M , queries , Q ) { let row_sum = new Array ( N ) ; let col_sum = new Array ( M ) ; for ( let i = 0 ; i < N ; i ++ ) row_sum [ i ] = 0 ; for ( let j = 0 ; j < M ; j ++ ) col_sum [ j ] = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { row_sum [ i ] += A [ i ] [ j ] ; col_sum [ j ] += A [ i ] [ j ] ; } } let sum_list = [ ] ; for ( let i = 0 ; i < N ; i ++ ) sum_list . push ( row_sum [ i ] ) ; for ( let i = 0 ; i < M ; i ++ ) sum_list . push ( col_sum [ i ] ) ; ( sum_list ) . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < Q ; i ++ ) { let L = queries [ i ] [ 0 ] ; let R = queries [ i ] [ 1 ] ; let l = left_search ( sum_list , L ) ; let r = right_search ( sum_list , R ) ; document . write ( r - l + 1 + "▁" ) ; } }
function search ( list , num ) { var low = 0 , high = list . length - 1 ; var ans = - 1 ; while ( low <= high ) { var mid = low + ( high - low ) / 2 ; if ( list [ mid ] <= num ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
function isPalindrome ( n ) { var rev = 0 ; var temp = n ; while ( n > 0 ) { rev = rev * 10 + n % 10 ; n = parseInt ( n / 10 ) ; } return rev == temp ; }
function countNumbers ( L , R , K ) { var list = [ ] ; for ( var i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) ) { list . push ( i ) ; } } var count = 0 ; for ( var i = 0 ; i < list . length ; i ++ ) { var right_index = search ( list , list [ i ] + K - 1 ) ; if ( right_index != - 1 ) count = Math . max ( count , right_index - i + 1 ) ; } return count ; }
function maximumLength ( mat , v ) { distance = 0 ; var N = mat [ 0 ] . length ; var visited = [ ] ; for ( var i = 0 ; i < N ; i ++ ) { visited . push ( false ) ; } var Adj = Array . from ( Array ( N ) , ( ) => Array ( ) ) ; var i , j ; for ( i = 0 ; i < mat [ 0 ] . length ; i ++ ) { for ( j = 0 ; j < mat . length ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { Adj [ i ] . push ( j ) ; } } } dfs ( v , Adj , visited , 0 ) ; return distance ; }
function getMaximumDifference ( Edges , arr , N , M ) { var Adj = Array . from ( Array ( N + 1 ) , ( ) => Array ( ) ) ; for ( var i = 0 ; i < M ; i ++ ) { var u = Edges [ i ] [ 0 ] ; var v = Edges [ i ] [ 1 ] ; Adj [ u ] . push ( v ) ; } DFS ( 1 , Adj , arr , arr [ 0 ] , arr [ 0 ] ) ; document . write ( ans ) ; }
function minimumDeletions ( S ) { let len = 0 ; let n = S . length ; for ( let i = 0 ; i < 26 ; i ++ ) { for ( let j = i + 1 ; j < 26 ; j ++ ) { let newLen = findLength ( S , String . fromCharCode ( i + 97 ) , String . fromCharCode ( j + 97 ) ) ; len = Math . max ( len , newLen ) ; } } return n - len ; }
function findMinX ( A , B , N ) { var prod = 1 ; for ( var i = 0 ; i < N ; i ++ ) prod *= A [ i ] ; var result = 0 ; for ( var i = 0 ; i < N ; i ++ ) { var pp = parseInt ( prod / A [ i ] ) ; result += B [ i ] * inv ( pp , A [ i ] ) * pp ; } return result % prod ; }
function findPairs ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) arr [ i ] = Math . abs ( arr [ i ] ) ; arr . sort ( ( a , b ) => a - b ) ; let left = 0 ; let ans = 0 ; for ( let right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } document . write ( ans ) ; }
function GetDiff ( A , N ) { let SuffMaxArr = Array ( N ) . fill ( 0 ) ; SuffMaxArr [ N - 1 ] = A [ N - 1 ] ; for ( let i = N - 2 ; i >= 0 ; -- i ) { SuffMaxArr [ i ] = Math . max ( SuffMaxArr [ i + 1 ] , A [ i + 1 ] ) ; } let MaximumSum = Number . MIN_VALUE ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < SuffMaxArr [ i ] ) MaximumSum = Math . max ( MaximumSum , A [ i ] + SuffMaxArr [ i ] ) ; } let MinimumSum = Number . MAX_VALUE ; let SuffMinArr = Array ( N ) . fill ( 0 ) ; SuffMinArr [ N - 1 ] = Number . MAX_VALUE ; for ( let i = N - 2 ; i >= 0 ; -- i ) { SuffMinArr [ i ] = Math . min ( SuffMinArr [ i + 1 ] , A [ i + 1 ] ) ; } for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < SuffMinArr [ i ] ) { MinimumSum = Math . min ( MinimumSum , A [ i ] + SuffMinArr [ i ] ) ; } } return Math . abs ( MaximumSum - MinimumSum ) ; }
function minimumSwaps ( arr , N ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != i % 2 ) { if ( i % 2 == 0 ) { even ++ ; } else { odd ++ ; } } } if ( even != odd ) { document . write ( - 1 ) ; } else { document . write ( even ) ; } }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; var i ; for ( i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function primeFactorSum ( arr , n , k ) { var sum = 0 ; var i ; for ( i = 0 ; i < n ; i ++ ) { if ( k % arr [ i ] == 0 && isPrime ( arr [ i ] ) ) { sum = sum + arr [ i ] ; } } document . write ( sum ) ; }
function CalculateValues ( N ) { var A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { var A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { document . write ( "A▁=▁" + A / 3 + ",▁B▁=▁" + B + ",▁C▁=▁" + C ) ; return ; } } } document . write ( - 1 ) ; }
function mininsert ( arr , K , N ) { var ans = 0 ; for ( i = 0 ; i < N - 1 ; i ++ ) { var a = Math . min ( arr [ i ] , arr [ i + 1 ] ) ; var b = Math . max ( arr [ i ] , arr [ i + 1 ] ) ; while ( K * a < b ) { a *= K ; ans ++ ; } } return ans ; }
function makeLexicographically ( arr , N ) { var index = 0 ; var temp = 0 ; var check = 0 ; var condition = 0 ; var element = 0 ; for ( i = 0 ; i < N ; ++ i ) { if ( element == arr [ i ] ) { check = i ; break ; } else if ( arr [ i ] != i + 1 && check == 0 ) { index = i ; check = 1 ; condition = - 1 ; element = i + 1 ; } } if ( condition == - 1 ) { temp = arr [ index ] ; arr [ index ] = arr [ check ] ; arr [ check ] = temp ; } print ( arr , N ) ; }
function print_triplet ( arr , n ) { for ( var i = 1 ; i <= n - 2 ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { document . write ( i - 1 + "▁" + i + "▁" + ( i + 1 ) ) ; return ; } } document . write ( - 1 ) ; }
function findConcatenatedNumbers ( a , b ) { var ans = true ; var n1 = a . length ; var n2 = b . length ; var cnt = new Map ( ) ; for ( var i = 0 ; i < n1 ; i ++ ) { cnt . set ( a [ i ] , 1 ) ; } for ( var i = 0 ; i < n2 ; i ++ ) { var left = b [ i ] ; var right = 0 ; var mul = 1 ; while ( left > 9 ) { right += ( left % 10 ) * mul ; left = parseInt ( left / 10 ) ; mul *= 10 ; if ( cnt . has ( left ) && cnt . has ( right ) ) { ans = false ; document . write ( b [ i ] + "▁" ) ; } } } if ( ans ) document . write ( "-1" ) ; }
function evenproduct ( arr , length ) { var count = 0 ; var i , j ; for ( i = 0 ; i < length + 1 ; i ++ ) { var product = 1 ; for ( j = i ; j < length + 1 ; j ++ ) { product *= arr [ j ] ; if ( product % 2 == 0 ) ++ count ; } } document . write ( count ) ; }
function evenproduct ( arr , length ) { var total_subarray = length * ( length + 1 ) / 2 ; var total_odd = 0 ; var count_odd = 0 ; for ( i = 0 ; i < arr . length ; ++ i ) { if ( arr [ i ] % 2 == 0 ) { count_odd = 0 ; } else { ++ count_odd ; total_odd += count_odd ; } } document . write ( total_subarray - total_odd ) ; }
function dfsUtil ( u , par , depth ) { adj [ u ] . forEach ( it => { if ( it != par ) { dfsUtil ( it , u , depth + 1 ) ; } } ) ; ans += depth ; }
function isInGroupUtil ( mat ) { for ( let i = 0 ; i < mat . length ; i ++ ) { let arr = [ ] for ( let j = 0  ; j < mat [ i ] . length ; j ++ ) { arr . push ( mat [ i ] [ j ] ) ; } if ( ! checkGroup ( arr ) ) return false ; } return true ; }
function isInGroup ( mat ) { let ans = isInGroupUtil ( mat ) ; if ( ans ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function convertBinaryToDecimal ( arr ) { var ans = 0 ; for ( var i of arr ) ans = ( ans << 1 ) | i ; return ans ; }
function decimalEquilvalentAtEachLevel ( root ) { var ans = 0 ; var que = [ ] ; que . push ( root ) ; while ( true ) { var length = que . length ; if ( length == 0 ) break ; var eachLvl = [ ] ; while ( length > 0 ) { var temp = que [ 0 ] ; que . shift ( ) ; eachLvl . push ( temp . val ) ; if ( temp . left != null ) que . push ( temp . left ) ; if ( temp . right != null ) que . push ( temp . right ) ; length -= 1 ; } ans += convertBinaryToDecimal ( eachLvl ) ; } document . write ( ans ) ; }
function countSubstrings ( s ) { let ans = 0 ; let subs = 1 ; let pre = "0" ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( pre == s [ i ] ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = s [ i ] ; } document . write ( ans ) ; }
function longestSequence ( arr , N ) { if ( N == 0 ) { document . write ( 0 ) ; return ; } arr . sort ( ) ; var maxLen = 1 ; var len = 1 ; var i ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] arr [ i ] == arr [ i - 1 ] + 1 ) { len ++ ; maxLen = Math . max ( maxLen , len ) ; } else { len = 1 ; } } document . write ( maxLen ) ; }
function minimumOperations ( arr , N ) { let oddCnt = 0 , evenCnt = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCnt ++ ; } else { oddCnt ++ ; } } document . write ( Math . min ( oddCnt , evenCnt ) ) ; }
function productOfDigits ( N ) { let product = 1 ; while ( N != 0 ) { product = product * ( N % 10 ) ; N = Math . floor ( N / 10 ) ; } return product ; }
function hasArrayTwoPairs ( nums , n , target ) { nums . sort ( ) ; var i ; for ( i = 0 ; i < n ; i ++ ) { var x = target - nums [ i ] ; var low = 0 , high = n - 1 ; while ( low <= high ) { var mid = low + ( Math . floor ( ( high - low ) / 2 ) ) ; if ( nums [ mid ] > x ) { high = mid - 1 ; } else if ( nums [ mid ] < x ) { low = mid + 1 ; } else { if ( mid == i ) { if ( ( mid - 1 >= 0 ) && nums [ mid - 1 ] == x ) { document . write ( nums [ i ] + ",▁" ) ; document . write ( nums [ mid - 1 ] ) ; return ; } if ( ( mid + 1 < n ) && nums [ mid + 1 ] == x ) { document . write ( nums [ i ] + ",▁" ) ; document . write ( nums [ mid + 1 ] ) ; return ; } break ; } else { document . write ( nums [ i ] + ",▁" ) ; document . write ( nums [ mid ] ) ; return ; } } } } document . write ( - 1 ) ; }
function minSum ( arr , N , Q , M ) { for ( var i = 0 ; i < M ; i ++ ) { var val = Q [ i ] ; var front = 0 , rear = 0 ; for ( var j = 0 ; j < N ; j ++ ) { front += arr [ j ] ; if ( arr [ j ] == val ) { break ; } } for ( var j = N - 1 ; j >= 0 ; j -- ) { rear += arr [ j ] ; if ( arr [ j ] == val ) { break ; } } document . write ( Math . min ( front , rear ) + "▁" ) ; } }
function minOperations ( arr , N , Q , M ) { var m1 = new Map ( ) ; var m2 = new Map ( ) ; var front = 0 , rear = 0 ; var i ; for ( i = 0 ; i < N ; i ++ ) { front += arr [ i ] ; m1 . set ( arr [ i ] , front ) ; } for ( i = N - 1 ; i >= 0 ; i -- ) { rear += arr [ i ] ; m2 . set ( arr [ i ] , rear ) ; } for ( i = 0 ; i < M ; i ++ ) { document . write ( Math . min ( m1 . get ( Q [ i ] ) , m2 . get ( Q [ i ] ) ) + "▁" ) ; } }
function checkAnagram ( s1 , s2 ) { var s2hash = Array ( 26 ) . fill ( 0 ) ; var s1hash = Array ( 26 ) . fill ( 0 ) ; var s1len = s1 . length ; var s2len = s2 . length ; if ( s1len > s2len ) return false ; var left = 0 , right = 0 ; while ( right < s1len ) { s1hash [ s1 [ right ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] += 1 ; s2hash [ s2 [ right ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] += 1 ; right ++ ; } right -= 1 ; while ( right < s2len ) { var ans = true ; for ( var i = 0 ; i < 26 ; i ++ ) { if ( s1hash [ i ] != s2hash [ i ] ) { ans = false ; } } if ( ans ) return true ; right ++ ; if ( right != s2len ) s2hash [ s2 [ right ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] += 1 ; s2hash [ s2 [ left ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] -= 1 ; left ++ ; } return false ; }
function findSubstring ( S ) { var T = "" ; var ans = "" ; var l = 0 ; T += S [ 0 ] ; for ( var i = 1 ; i < S . length ; i ++ ) { if ( Math . abs ( S [ i ] . charCodeAt ( 0 ) - S [ i - 1 ] . charCodeAt ( 0 ) ) === 1 ) { l = T . length ; if ( l > ans . length ) { ans = T ; } T = "" ; T += S [ i ] ; } else { T += S [ i ] ; } } l = T . length ; if ( l > ans . length ) { ans = T ; } document . write ( ans ) ; }
function DFS ( row , col , grid , M , N ) { let vis = new Array ( M + 1 ) ; for ( var i = 0 ; i < vis . length ; i ++ ) { vis [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < M + 1 ; i ++ ) { for ( let j = 0 ; j < N + 1 ; j ++ ) { vis [ i ] [ j ] = false ; } } DFSUtil ( 0 , 0 , grid , vis , M , N ) ; }
function DFS_iterative ( grid , M , N ) { vis = [ ] ; for ( let i = 0 ; i < M + 5 ; i ++ ) { vis . push ( [ ] ) ; for ( let j = 0 ; j < N + 5 ; j ++ ) { vis [ i ] . push ( false ) ; } } let st = [ ] ; st . push ( [ 0 , 0 ] ) ; vis [ 0 ] [ 0 ] = true ; while ( st . length > 0 ) { let p = st [ st . length - 1 ] ; st . pop ( ) ; let row = p [ 0 ] ; let col = p [ 1 ] ; document . write ( grid [ row ] [ col ] + "▁" ) ; for ( let i = 0 ; i < 4 ; i ++ ) { let x = row + dRow [ i ] ; let y = col + dCol [ i ] ; if ( isValid ( x , y , M , N ) ) { st . push ( [ x , y ] ) ; vis [ x ] [ y ] = true ; } } } }
function suffixArr ( arr , suffix , N ) { for ( var i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 ) { suffix [ i ] [ 0 ] = arr [ i ] ; suffix [ i ] [ 1 ] = arr [ i ] ; } else { suffix [ i ] [ 0 ] = Math . max ( suffix [ i + 1 ] [ 0 ] , arr [ i ] ) ; suffix [ i ] [ 1 ] = Math . min ( suffix [ i + 1 ] [ 1 ] , arr [ i ] ) ; } } }
function MinMaxQueries ( a , Q ) { var N = arr . length ; var q = queries . length ; var prefix = Array . from ( Array ( N ) , ( ) => Array ( 2 ) ) ; var suffix = Array . from ( Array ( N ) , ( ) => Array ( 2 ) ) ; prefixArr ( arr , prefix , N ) ; suffixArr ( arr , suffix , N ) ; for ( var i = 0 ; i < q ; i ++ ) { var L = queries [ i ] [ 0 ] ; var R = queries [ i ] [ 1 ] ; maxAndmin ( prefix , suffix , N , L , R ) ; } }
function check ( a , n ) { flag = false ; for ( i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i + 1 ] > a [ i ] && a [ i ] < a [ i - 1 ] ) flag = true ; } if ( flag ) return false ; else return true ; }
function smallestNumber ( arr , len ) { let maxi = 0 ; for ( let i = 0 ; i < len ; i ++ ) { maxi = Math . max ( maxi , arr [ i ] ) ; } let ans = - 1 ; for ( let i = 2 ; i < maxi + 2 ; i ++ ) { let flag = true ; for ( let j = 0 ; j < len ; j ++ ) { if ( arr [ j ] % i == 0 ) { flag = false ; break ; } } if ( flag ) { ans = i ; break ; } } document . write ( ans ) ; }
function findDuplicate ( str , N ) { let first = 0 ; let second = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( ( first & ( 1 << ( str [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ) ) ) != 0 ) { second = second | ( 1 << ( str [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ) ) ; } else { first = first | ( 1 << ( str [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ) ) ; } } for ( let i = 0 ; i < 26 ; i ++ ) { if ( ( ( first & ( 1 << i ) ) & ( second & ( 1 << i ) ) ) != 0 ) { document . write ( String . fromCharCode ( i + "a" . charCodeAt ( ) ) + "▁" ) ; } } }
function minOperations ( S ) { var count = 0 ; for ( var i = 1 ; i < S . length ; i ++ ) { if ( S [ i ] !== S [ i - 1 ] ) { count += 1 ; } } document . write ( count ) ; }
function check ( N ) { if ( N == 0 ) return 0 ; return ! ( N & ( N - 1 ) ) ; }
function build_seg_tree ( ss , se , si , tree , arr ) { if ( ss == se ) { tree [ si ] = check ( arr [ ss ] ) ; return ; } var mid = parseInt ( ( ss + se ) / 2 ) ; build_seg_tree ( ss , mid , 2 * si + 1 , tree , arr ) ; build_seg_tree ( mid + 1 , se , 2 * si + 2 , tree , arr ) ; tree [ si ] = tree [ 2 * si + 1 ] + tree [ 2 * si + 2 ] ; }
function query ( l , r , ss , se , si , tree ) { if ( r < ss l > se ) return 0 ; if ( l <= ss && r >= se ) return tree [ si ] ; var mid = parseInt ( ( ss + se ) / 2 ) ; return query ( l , r , ss , mid , 2 * si + 1 , tree ) + query ( l , r , mid + 1 , se , 2 * si + 2 , tree ) ; }
function numberOfPairs ( arr , N ) { let set_bits = [ ] ; for ( let i = 0 ; i < 31 ; i ++ ) { set_bits [ i ] = 0 ; } let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let x = arr [ i ] ; let bitpos = - 1 ; while ( x > 0 ) { bitpos ++ ; x = Math . floor ( x / 2 ) ; } for ( let j = 0 ; j <= bitpos ; j ++ ) { count += set_bits [ j ] ; } set_bits [ bitpos ] ++ ; } document . write ( count ) ; }
function calculateQuery ( arr , N , query , M ) { for ( let i = 0 ; i < M ; i ++ ) { let X = query [ i ] ; let sum_start = 0 , sum_end = 0 ; for ( let j = 0 ; j < N ; j ++ ) { sum_start += arr [ j ] ; if ( arr [ j ] == X ) break ; } for ( let j = N - 1 ; j >= 0 ; j -- ) { sum_end += arr [ j ] ; if ( arr [ j ] == X ) break ; } document . write ( Math . min ( sum_end , sum_start ) + "▁" ) ; } }
function calculateQuery ( arr , N , query , M ) { var prefix = 0 , suffix = 0 ; var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { prefix += arr [ i ] ; if ( ! mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , [ 0 , 0 ] ) ; } var tmp = mp . get ( arr [ i ] ) ; tmp [ 0 ] = prefix ; mp . set ( arr [ i ] , tmp ) ; } for ( var i = N - 1 ; i >= 0 ; i -- ) { suffix += arr [ i ] ; if ( ! mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , [ 0 , 0 ] ) ; } var tmp = mp . get ( arr [ i ] ) ; tmp [ 1 ] = suffix ; mp . set ( arr [ i ] , tmp ) ; } for ( var i = 0 ; i < M ; i ++ ) { var X = query [ i ] ; var tmp = mp . get ( X ) ; document . write ( Math . min ( tmp [ 0 ] , tmp [ 1 ] ) + "▁" ) ; } }
function minOps ( s , N ) { var ans = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) { ans ++ ; } } if ( ans % 2 == 1 ) { document . write ( ( ans - 1 ) / 2 ) ; return ; } document . write ( ans / 2 ) ; }
function oddOneOut ( arr , N ) { let odd = 0 , even = 0 ; let lastOdd = 0 , lastEven = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { even ++ ; lastEven = i ; } else { odd ++ ; lastOdd = i ; } } if ( odd == 1 ) { document . write ( lastOdd ) ; } else { document . write ( lastEven ) ; } }
function mulsum ( arr , n , N ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % N == 0 ) { sum = sum + arr [ i ] ; } } document . write ( sum ) ; }
function isGreaterEqual ( N , X ) { return parseInt ( ( N * ( N + 1 ) ) / 2 ) >= X ; }
function minimumPossible ( X ) { for ( let i = 1 ; i <= X ; i ++ ) { if ( isGreaterEqual ( i , X ) ) return i ; } }
function isGreaterEqual ( N , X ) { return parseInt ( ( N * ( N + 1 ) ) / 2 ) >= X ; }
function minimumPossible ( X ) { let low = 1 , high = X , res = - 1 ; while ( low <= high ) { let mid = low + parseInt ( ( high - low ) / 2 ) ; if ( isGreaterEqual ( mid , X ) ) { res = mid ; high = mid - 1 ; } else low = mid + 1 ; } return res ; }
function CheckDivByAllDigits ( number ) { let n = number ; while ( n > 0 ) { if ( n % 10 ) if ( number % ( n % 10 ) ) { return false ; } n = parseInt ( n / 10 ) ; } return true ; }
function cntNumInRang ( arr , N ) { let prefCntDiv = new Array ( Max ) . fill ( 0 ) ; for ( let i = 1 ; i <= Max ; i ++ ) { prefCntDiv [ i ] = prefCntDiv [ i - 1 ] + ( CheckDivByAllDigits ( i ) ) ; } for ( let i = 0 ; i < N ; i ++ ) document . write ( ( prefCntDiv [ arr [ i ] [ 1 ] ] - prefCntDiv [ arr [ i ] [ 0 ] - 1 ] ) + "▁" ) ; }
function arrayNesting ( arr ) { let res = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == i ) { res = Math . max ( res , 1 ) ; } else { let count = 0 ; let curr_index = i ; while ( arr [ curr_index ] != curr_index ) { let next_index = arr [ curr_index ] ; arr [ curr_index ] = curr_index ; curr_index = next_index ; count ++ ; } res = Math . max ( res , count ) ; } } return res ; }
function count ( a , n ) { if ( n == 1 ) { document . write ( 0 ) ; return ; } let pre = new Array ( n - 1 ) ; let suf = new Array ( n - 1 ) ; let max = a [ 0 ] ; let ans = 0 , i ; pre [ 0 ] = a [ 0 ] ; for ( i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; pre [ i ] = max ; } max = a [ n - 1 ] ; suf [ n - 2 ] = a [ n - 1 ] ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( a [ i ] > max ) max = a [ i ] ; suf [ i - 1 ] = max ; } for ( i = 0 ; i < n - 1 ; i ++ ) { if ( pre [ i ] < suf [ i ] ) ans ++ ; } document . write ( ans ) ; }
function countNumbers ( L , R ) { let Count = 0 ; for ( let i = 0 ; i < index ; i ++ ) { let p = prime [ i ] ; if ( p >= L && p <= R ) { Count ++ ; } } document . write ( Count ) ; }
function xorSubsequence ( a , n , k ) { var ans = 0 ; var map = new Map ( ) ; var dp = Array ( n ) . fill ( 0 ) ; map . set ( a [ 0 ] , 1 ) dp [ 0 ] = 1 ; for ( var i = 1 ; i < n ; i ++ ) { var dpj ; if ( map . has ( a [ i ] ^ k ) ) { dpj = map . get ( a [ i ] ^ k ) ; } else { dpj = - 1 ; } if ( dpj != 0 ) dp [ i ] = Math . max ( dp [ i ] , dpj + 1 ) ; ans = Math . max ( ans , dp [ i ] ) ; if ( map . has ( a [ i ] ) ) { map . set ( a [ i ] , Math . max ( map . get ( a [ i ] ) + 1 , dp [ i ] ) ) ; } else { map . set ( a [ i ] , Math . max ( 1 , dp [ i ] ) ) ; } } return ans >= 2 ? ans : 0 ; }
function distance ( root , target , distancesum , n ) { if ( root . data == target ) { sum = distancesum ; } if ( root . left != null ) { let tempsum = distancesum - root . left . size + ( n - root . left . size ) ; distance ( root . left , target , tempsum , n ) ; } if ( root . right != null ) { let tempsum = distancesum - root . right . size + ( n - root . right . size ) ; distance ( root . right , target , tempsum , n ) ; } }
function countRemainingElements ( L1 , L2 , n ) { let one = 0 ; let zero = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( L1 [ i ] == 1 ) one ++ ; else zero ++ ; } let ans = n ; for ( let i = 0 ; i < n ; i ++ ) { if ( L2 [ i ] == 1 ) { one -- ; if ( one < 0 ) { ans = i ; break ; } } else { zero -- ; if ( zero < 0 ) { ans = i ; break ; } } } document . write ( n - ans ) ; }
function minTime ( arr , N , K ) { var q = [ ] ; var vis = Array ( N + 1 ) . fill ( false ) ; var time = 0 ; for ( var i = 0 ; i < K ; i ++ ) { q . push ( arr [ i ] ) ; vis [ arr [ i ] ] = true ; } while ( q . length > 0 ) { for ( var i = 0 ; i < q . length ; i ++ ) { var curr = q [ 0 ] ; q . pop ( ) ; if ( curr - 1 >= 1 && ! vis [ curr - 1 ] ) { vis [ curr - 1 ] = true ; q . push ( curr - 1 ) ; } if ( curr + 1 <= N && ! vis [ curr + 1 ] ) { vis [ curr + 1 ] = true ; q . push ( curr + 1 ) ; } } time ++ ; } document . write ( time - 1 ) ; }
function getCount ( rows , columns , A ) { var res = 0 ; for ( var i = 0 ; i < rows ; i ++ ) { for ( var j = i + 1 ; j < rows ; j ++ ) { if ( A [ i ] [ 0 ] * A [ j ] [ 1 ] == A [ i ] [ 1 ] * A [ j ] [ 0 ] ) { res ++ ; } } } return res ; }
function Min_Score_Index ( N , A ) { var Score = Array ( N ) . fill ( 0 ) ; for ( var i = N - 1 ; i >= 0 ; i -- ) { if ( A [ i ] + i < N ) Score [ i ] = A [ i ] * Score [ A [ i ] + i ] ; else Score [ i ] = A [ i ] ; } var min_value = 1000000000 ; Score . forEach ( i => { min_value = Math . min ( i , min_value ) ; } ) ; var ind = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( Score [ i ] == min_value ) ind = i ; } document . write ( ind ) ; }
function minLength ( S , T , N , M ) { let temp = "" ; let subtract = 0 ; for ( let i = 0 ; i < N ; ++ i ) { temp += S [ i ] ; if ( temp . length >= M ) { if ( T == temp . substr ( temp . length - M , temp . length ) ) { subtract += M ; let cnt = 0 ; while ( cnt != M ) { temp = temp . substr ( 0 , temp . length - 1 ) ; ++ cnt ; } } } } document . write ( ( N - subtract ) ) ; }
function maximumCount ( arr1 , arr2 , s1 , s2 ) { let sum1 = 0 , sum2 = 0 ; for ( let i = 0 ; i < s1 ; i ++ ) { sum1 += arr1 [ i ] ; } for ( let j = 0 ; j < s2 ; j ++ ) { sum2 += arr2 [ j ] ; } let len = 0 ; if ( s1 >= s2 ) { len = s2 ; } else { len = s1 ; } arr1 . sort ( ) ; arr2 . sort ( ) ; let j = 0 , k = s2 - 1 , count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { if ( sum1 <= sum2 ) { if ( arr2 [ k ] >= arr1 [ i ] ) { let dif1 = arr1 [ j ] , dif2 = arr2 [ k ] ; sum1 -= dif1 ; sum1 += dif2 ; sum2 -= dif2 ; sum2 += dif1 ; j ++ ; k -- ; count ++ ; } else { break ; } } else { break ; } } return count ; }
function noOfValidKbers ( K , arr ) { var set = new Set ( ) ; while ( K != 0 ) { set . add ( K % 10 ) ; K = parseInt ( K / 10 ) ; } var count = 0 ; for ( i = 0 ; i < arr . length ; i ++ ) { var no = arr [ i ] ; var flag = true ; while ( no != 0 ) { var digit = no % 10 ; if ( ! set . has ( digit ) ) { flag = false ; break ; } no = parseInt ( no / 10 ) ; } if ( flag == true ) { count ++ ; } } return count ; }
function build ( arr , index , s , e ) { if ( s == e ) Tree [ index ] = arr [ s ] ; else { let m = parseInt ( ( s + e ) / 2 , 10 ) ; build ( arr , 2 * index , s , m ) ; build ( arr , 2 * index + 1 , m + 1 , e ) ; Tree [ index ] = Math . max ( Tree [ 2 * index ] , Tree [ 2 * index + 1 ] ) ; } }
function isSubarrayExistUtil ( arr , K , N ) { var totalXOR = 0 ; var SubarrayXOR = 0 ; for ( i = 0 ; i < N ; i ++ ) totalXOR ^= arr [ i ] ; for ( i = 0 ; i < K ; i ++ ) SubarrayXOR ^= arr [ i ] ; if ( SubarrayXOR == ( totalXOR ^ SubarrayXOR ) ) return true ; for ( i = K ; i < N ; i ++ ) { SubarrayXOR ^= arr [ i ] ; SubarrayXOR ^= arr [ i - 1 ] ; if ( SubarrayXOR == ( totalXOR ^ SubarrayXOR ) ) return true ; } return false ; }
function countPairs ( L , R ) { let count_even ; if ( L % 2 == 0 ) { count_even = ( R / 2 ) - ( L / 2 ) + 1 ; } else { count_even = ( R / 2 ) - ( L / 2 ) ; } let count_odd ; if ( L % 2 == 0 ) { count_odd = ( ( R + 1 ) / 2 ) - ( ( L + 1 ) / 2 ) ; } else { count_odd = ( ( R + 1 ) / 2 ) - ( ( L + 1 ) / 2 ) + 1 ; } count_even *= count_even ; count_odd *= count_odd ; document . write ( count_even + count_odd ) ; }
function delCost ( s , cost ) { var ans = 0 ; var forMax = new Map ( ) ; var forTot = new Map ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( ! forMax . has ( s [ i ] ) ) { forMax . set ( s [ i ] , cost [ i ] ) ; } else { forMax . set ( s [ i ] , Math . max ( forMax . get ( s [ i ] ) , cost [ i ] ) ) } if ( ! forTot . has ( s [ i ] ) ) { forTot . set ( s [ i ] , cost [ i ] ) ; } else { forTot . set ( s [ i ] , forTot . get ( s [ i ] ) + cost [ i ] ) } } forMax . forEach ( ( value , key ) => { ans += forTot . get ( key ) - value ; } ) ; return ans ; }
function findPeak ( arr ) { var left = 0 ; var right = arr . length - 1 ; while ( left < right ) { var mid = left + parseInt ( ( right - left ) / 2 ) ; if ( arr [ mid ] < arr [ mid + 1 ] ) { left = mid + 1 ; } else { right = mid ; } } return left ; }
function BS ( X , left , right , arr ) { while ( left <= right ) { var mid = left + parseInt ( ( right - left ) / 2 ) ; if ( arr [ mid ] == X ) { return mid ; } else if ( X > arr [ mid ] ) { left = mid + 1 ; } else { right = mid - 1 ; } } return - 1 ; }
function reverseBS ( X , left , right , arr ) { while ( left <= right ) { var mid = left + parseInt ( ( right - left ) / 2 ) ; if ( arr [ mid ] == X ) { return mid ; } else if ( X > arr [ mid ] ) { right = mid - 1 ; } else { left = mid + 1 ; } } return - 1 ; }
function getDefiniteFinds ( arr ) { let n = arr . length ; let smallestRight = new Array ( n + 1 ) . fill ( 0 ) ; smallestRight [ n ] = Number . MAX_VALUE ; for ( let i = n - 1 ; i >= 0 ; i -- ) { smallestRight [ i ] = Math . min ( smallestRight [ i + 1 ] , arr [ i ] ) ; } let mn = Number . MIN_VALUE ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( mn < arr [ i ] && arr [ i ] < smallestRight [ i + 1 ] ) { ans ++ ; } mn = Math . max ( arr [ i ] , mn ) ; } return ans ; }
function Count_numbers ( L , R ) { var count = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) count += 1 ; document . write ( count ) ; }
function findIndex ( arr , N ) { var rightSum = 0 ; var leftSum = 0 ; for ( i = 0 ; i < N ; i ++ ) { rightSum += arr [ i ] ; } for ( i = 0 ; i < N ; i ++ ) { rightSum -= arr [ i ] ; if ( checkReverse ( leftSum , rightSum ) ) { return i ; } leftSum += arr [ i ] ; } return - 1 ; }
function minimumTime ( arr , n ) { var sum = 0 ; var T = Math . max ( ... arr ) ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } document . write ( Math . max ( 2 * T , sum ) ) ; }
function findClosest ( N , target ) { let closest = - 1 ; let diff = Number . MAX_VALUE ; for ( let i = 1 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( N / i == i ) { if ( Math . abs ( target - i ) < diff ) { diff = Math . abs ( target - i ) ; closest = i ; } } else { if ( Math . abs ( target - i ) < diff ) { diff = Math . abs ( target - i ) ; closest = i ; } if ( Math . abs ( target - N / i ) < diff ) { diff = Math . abs ( target - N / i ) ; closest = N / i ; } } } } document . write ( closest ) ; }
function computeDivisors ( ) { for ( let i = 1 ; i <= MAX ; i ++ ) { for ( let j = i ; j <= MAX ; j += i ) { divisors [ j ] . push ( i ) ; } } }
function getClosest ( val1 , val2 , target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; }
function findClosest ( arr , n , target ) { if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; let i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = Math . floor ( ( i + j ) / 2 ) ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; }
function printClosest ( N , X ) { computeDivisors ( ) ; let ans = findClosest ( divisors [ N ] , divisors [ N ] . length , X ) ; document . write ( ans ) ; }
function LCS ( firstArr , secondArr ) { let mp = new Map ( )  for ( let i = 0 ; i < firstArr . length ; i ++ ) { mp . set ( firstArr [ i ] , i + 1 ) ; } let tempArr = [ ] ; for ( let i = 0 ; i < secondArr . length ; i ++ ) { if ( mp . has ( secondArr [ i ] ) ) { tempArr . push ( mp . get ( secondArr [ i ] ) ) ; } } let tail = [ ] ; tail . push ( tempArr [ 0 ] ) ; for ( let i = 1 ; i < tempArr . length ; i ++ ) { if ( tempArr [ i ] > tail [ tail . length - 1 ] ) tail . push ( tempArr [ i ] ) ; else if ( tempArr [ i ] < tail [ 0 ] ) tail . unshift ( 0 , tempArr [ i ] ) ; } return tail . length ; }
function maxSubarrayProduct ( arr , n ) { var max_ending_here = 1 ; var min_ending_here = 1 ; var max_so_far = 0 ; var flag = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { max_ending_here = max_ending_here * arr [ i ] ; min_ending_here = Math . min ( min_ending_here * arr [ i ] , 1 ) ; flag = 1 ; } else if ( arr [ i ] == 0 ) { max_ending_here = 1 ; min_ending_here = 1 ; } else { var temp = max_ending_here ; max_ending_here = Math . max ( min_ending_here * arr [ i ] , 1 ) ; min_ending_here = temp * arr [ i ] ; } if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } if ( flag == 0 && max_so_far == 0 ) return 0 ; return max_so_far ; }
function findMaxProduct ( a , n ) { var i = 0 ; var maxProd = - 1e9 ; while ( i < n ) { var v = [ ] ; v . push ( a [ i ] ) ; if ( i < n - 1 && a [ i ] < a [ i + 1 ] ) { while ( i < n - 1 && a [ i ] < a [ i + 1 ] ) { v . push ( a [ i + 1 ] ) ; i += 1 ; } } else if ( i < n - 1 && a [ i ] > a [ i + 1 ] ) { while ( i < n - 1 && a [ i ] > a [ i + 1 ] ) { v . push ( a [ i + 1 ] ) ; i += 1 ; } } var prod = maxSubarrayProduct ( v , v . length ) ; maxProd = Math . max ( maxProd , prod ) ; i ++ ; } return maxProd ; }
function PrimeFactors ( N ) { let st = [ ] ; let i = 2 ; while ( N != 1 ) { if ( N % i == 0 ) { st . push ( i ) ; while ( N % i == 0 ) { N = Math . floor ( N / i ) ; } } i ++ ; } while ( st . length != 0 ) { document . write ( st . pop ( ) ) ; } }
function power ( A , N ) { let count = 0 ; if ( A == 1 ) return 0 ; while ( N > 0 ) { count ++ ; N /= A ; } return count ; }
function LCM ( A , B ) { return ( A * B / __gcd ( A , B ) ) ; }
function findSmallestNumber ( X ) { let lcm = 1 ; let temp = X ; while ( temp > 0 ) { let last = temp % 10 ; temp = Math . floor ( temp / 10 ) ; if ( last == 0 ) continue ; lcm = LCM ( lcm , last ) ; } let answer = Math . floor ( ( X + lcm - 1 ) / lcm ) * lcm ; document . write ( answer ) ; }
function findNonMultiples ( arr , n , k ) { let multiples = new Set ( ) ; for ( let i = 0 ; i < n ; ++ i ) { if ( ! multiples . has ( arr [ i ] ) ) { for ( let j = 1 ; j <= k / arr [ i ] ; j ++ ) { multiples . add ( arr [ i ] * j ) ; } } } return k - multiples . size ; }
function countValues ( arr , N , L , R ) { return findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ; }
function minSum ( N ) { let low = 0 , high = 1000000000 ; while ( low + 1 < high ) { let mid = low + parseInt ( ( high - low ) / 2 ) ; if ( mid * mid >= N ) { high = mid ; } else { low = mid ; } } let first = high ; low = 0 ; high = 1000000000 ; while ( low + 1 < high ) { let mid = low + parseInt ( ( high - low ) / 2 ) ; if ( first * mid > N ) { high = mid ; } else { low = mid ; } } let second = high ; document . write ( first + second ) ; }
function minSum ( N ) { let ans = Math . ceil ( 2 * Math . sqrt ( N + 1 ) ) ; document . write ( ans ) ; }
function root ( a ) { if ( a == parent [ a ] ) { return a ; } return parent [ a ] = root ( parent [ a ] ) ; }
function connect ( a , b ) { a = root ( a ) ; b = root ( b ) ; if ( a != b ) { parent [ b ] = a ; } }
function find_ht ( root ) { if ( root == null ) return 0 ; if ( root . left == null && root . right == null ) return 1 ; return Math . max ( find_ht ( root . left ) , find_ht ( root . right ) ) + 1 ; }
function countFreq ( N , K ) { let count = 0 ; while ( N > 0 ) { if ( N % 10 == K ) { count ++ ; } N = Math . floor ( N / 10 ) ; } return count ; }
function findElementUtil ( arr , N , K ) { let c ; let max ; let ele = 0 ; max = 0 ; for ( let i = 0 ; i < N ; i ++ ) { c = countFreq ( arr [ i ] , K ) ; if ( c > max ) { max = c ; ele = arr [ i ] ; } } if ( max == 0 ) return - 1 ; else return ele ; }
function findOverlapSegement ( N , a , b ) { var tup = [ ] ; for ( var i = 0 ; i < N ; i ++ ) { var x , y ; x = a [ i ] ; y = b [ i ] ; tup . push ( [ [ x , y ] , i ] ) ; } tup . sort ( ( a , b ) => { if ( a [ 0 ] [ 0 ] == b [ 0 ] [ 0 ] ) { return a [ 0 ] [ 1 ] - b [ 0 ] [ 1 ] ; } var tmp = ( a [ 0 ] [ 0 ] - b [ 0 ] [ 0 ] ) ; console . log ( tmp ) ; return ( a [ 0 ] [ 0 ] - b [ 0 ] [ 0 ] ) } ) ; var curr = tup [ 0 ] [ 0 ] [ 1 ] ; var currPos = tup [ 0 ] [ 1 ] ; for ( var i = 1 ; i < N ; i ++ ) { var Q = tup [ i - 1 ] [ 0 ] [ 0 ] ; var R = tup [ i ] [ 0 ] [ 0 ] ; if ( Q == R ) { if ( tup [ i - 1 ] [ 0 ] [ 1 ] < tup [ i ] [ 0 ] [ 1 ] ) { document . write ( tup [ i - 1 ] [ 1 ] + "▁" + tup [ i ] [ 1 ] ) ; return ; } else { document . write ( tup [ i ] [ 1 ] + "▁" + tup [ i - 1 ] [ 1 ] ) ; return ; } } var T = tup [ i ] [ 0 ] [ 1 ] ; if ( T <= curr ) { document . write ( tup [ i ] [ 1 ] + "▁" + currPos ) ; return ; } else { curr = T ; currPos = tup [ i ] [ 1 ] ; } } document . write ( "-1▁-1" ) ; }
function isSpiralSorted ( arr , n ) { let start = 0 ; let end = n - 1 ; while ( start < end ) { if ( arr [ start ] > arr [ end ] ) { return false ; } start ++ ; if ( arr [ end ] > arr [ start ] ) { return false ; } end -- ; } return true ; }
function findMinDeletions ( v , n ) { let minDel = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let L = v [ i ] [ 0 ] ; let R = v [ i ] [ 1 ] ; let Count = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( v [ j ] [ 0 ] >= L && v [ j ] [ 1 ] <= R ) { Count += 1 ; } } minDel = Math . min ( minDel , n - Count ) ; } return minDel ; }
function maxEvenIntegers ( arr , N , M ) { let ans = 0 ; for ( let i = 0 ; i <= N - M ; i ++ ) { let cnt = 0 ; for ( let j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = Math . max ( ans , cnt ) ; } return ans ; }
function MaxNonEmpSubSeq ( a , n ) { let sum = 0 ; let max = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( max < a [ i ] ) { max = a [ i ] ; } } if ( max <= 0 ) { return max ; } for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) { sum += a [ i ] ; } } return sum ; }
function findMaxLengthSequence ( N , arr ) { let rightmost_element = - 1 ; let i = 0 ; let j = N - 1 ; let sequence = [ ] ; while ( i <= j ) { if ( arr [ i ] > arr [ j ] ) { if ( arr [ j ] > rightmost_element ) { sequence . push ( arr [ j ] ) ; rightmost_element = arr [ j ] ; j -- ; } else if ( arr [ i ] > rightmost_element ) { sequence . push ( arr [ i ] ) ; rightmost_element = arr [ i ] ; i ++ ; } else break ; } else if ( arr [ i ] < arr [ j ] ) { if ( arr [ i ] > rightmost_element ) { sequence . push ( arr [ i ] ) ; rightmost_element = arr [ i ] ; i ++ ; } else if ( arr [ j ] > rightmost_element ) { sequence . push ( arr [ j ] ) ; rightmost_element = arr [ j ] ; j -- ; } else break ; } else if ( arr [ i ] == arr [ j ] ) { if ( i == j ) { if ( arr [ i ] > rightmost_element ) { sequence . push ( arr [ i ] ) ; rightmost_element = arr [ i ] ; i ++ ; } break ; } else { sequence . push ( arr [ i ] ) ; let k = i + 1 ; let max_left = [ ] ; while ( k < j && arr [ k ] > arr [ k - 1 ] ) { max_left . push ( arr [ k ] ) ; k ++ ; } let l = j - 1 ; let max_right = [ ] ; while ( l > i && arr [ l ] > arr [ l + 1 ] ) { max_right . push ( arr [ l ] ) ; l -- ; } if ( max_left . length > max_right . length ) for ( let element = 0 ; element < max_left . length ; element ++ ) sequence . push ( max_left [ element ] ) ; else for ( let element = 0 ; element < max_right . length ; element ++ ) sequence . push ( max_right [ element ] ) ; break ; } } } for ( let element = 0 ; element < sequence . length ; element ++ ) document . write ( sequence [ element ] + "▁" ) ; }
function getcount ( n , k ) { let res = ( n >> ( k + 1 ) ) << k ; if ( ( ( n >> k ) & 1 ) != 0 ) res += n & ( ( 1 << k ) - 1 ) ; return res ; }
function countDivisors ( n ) { var count = 0 ; var j = 0 ; var divisor = Array ( n ) . fill ( 0 ) ; for ( var i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( parseInt ( n / i ) == i ) { divisor [ j ] = i ; j += 1 ; } else { divisor [ j ] = i ; divisor [ j + 1 ] = parseInt ( n / i ) ; j += 2 ; } } } divisor [ j ] = n ; for ( var i = 0 ; i <= j ; i ++ ) { var x = divisor [ i ] ; x -= 1 ; if ( parseInt ( n / x ) == parseInt ( n % x ) ) count ++ ; } document . write ( count ) ; }
function smallestIndexArrayElementsFlip ( arr , N ) { var pos = - 1 ; var i , j ; for ( i = 0 ; i < N ; i ++ ) { arr [ i ] *= - 1 ; var sum = 0 ; for ( j = 0 ; j < N ; j ++ ) { sum += arr [ j ] ; } if ( sum == 0 ) { pos = i ; break ; } else { arr [ i ] *= - 1 ; } } return pos ; }
function smallestIndexArrayElementsFlip ( arr , N ) { let pos = - 1 ; let ArrSum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { ArrSum += arr [ i ] ; } for ( let i = 0 ; i < N ; i ++ ) { if ( 2 * arr [ i ] == ArrSum ) { pos = i ; break ; } } return pos ; }
function MaxAverage ( root ) { if ( root . children != null && root . children . length == 0 ) { ans = Math . max ( ans , root . val ) ; return [ root . val , 1 ] ; } let childResult = new Array ( 2 ) ; for ( let i = 0 ; i < childResult . length ; i ++ ) { childResult [ i ] = 0 ; } for ( let child = 0 ; child < root . children . length ; child ++ ) { let childTotal = MaxAverage ( root . children [ child ] ) ; childResult [ 0 ] = childResult [ 0 ] + childTotal [ 0 ] ; childResult [ 1 ] = childResult [ 1 ] + childTotal [ 1 ] ; } let sum = childResult [ 0 ] + root . val ; let count = childResult [ 1 ] + 1 ; ans = Math . max ( ans , sum / count ) ; return [ sum , count ] ; }
function make_array_element_even ( arr , N ) { let res = 0 ; let odd_cont_seg = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd_cont_seg ++ ; } else { if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += ( odd_cont_seg / 2 ) + 2 ; } odd_cont_seg = 0 ; } } } if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += odd_cont_seg / 2 + 2 ; } } return res ; }
function findSum ( a ) { var ans = 0 ; for ( var low = 0 ; low < a . length ; low ++ ) { for ( var high = low ; high < a . length ; high ++ ) { var count = 0 ; var maxNumber = 0 ; for ( var i = low ; i <= high ; i ++ ) { if ( a [ i ] === maxNumber ) count ++ ; else if ( a [ i ] > maxNumber ) { maxNumber = a [ i ] ; count = 1 ; } } ans += maxNumber * ( count % 2 === 0 ? 2 : 1 ) ; } } document . write ( ans ) ; }
function countPairs ( arr , n ) { let mp1 = new Map ( ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( mp1 . has ( sum ) ) { mp1 . set ( sum , mp1 . get ( sum ) + 1 ) ; } else { mp1 . set ( sum , 1 ) } } sum = 0 ; let ans = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; if ( mp1 . has ( sum ) ) { ans += mp1 . get ( sum ) ; } } document . write ( ans ) ; }
function minCollectingSpeed ( piles , H ) { var ans = - 1 ; var low = 1 , high ; high = piles . reduce ( ( a , b ) => Math . max ( a , b ) ) ; while ( low <= high ) { var K = low + parseInt ( ( high - low ) / 2 ) ; var time = 0 ; piles . forEach ( ai => { time += parseInt ( ( ai + K - 1 ) / K ) ; } ) ; if ( time <= H ) { ans = K ; high = K - 1 ; } else { low = K + 1 ; } } document . write ( ans ) ; }
function isMagic ( num ) { return ( num % 9 == 1 ) ; }
function findSmallestInteger ( arr , N , K ) { var left = 1 ; var right = arr . reduce ( ( a , b ) => Math . max ( a , b ) ) ; while ( left < right ) { var mid = ( left + right ) / 2 ; var sum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { sum += parseInt ( ( arr [ i ] + mid - 1 ) / mid ) ; } if ( sum > K ) { left = mid + 1 ; } else { right = mid ; } } return left ; }
function minimum_deci_binary_number ( s ) { let m = Number . MIN_VALUE ; for ( let i = 0 ; i < s . length ; i ++ ) { let temp = s [ i ] - "0" ; if ( temp > m ) { m = temp ; } } return m ; }
function minimumReverse ( s , n ) { let k = 0 , l = 0 ; let sum1 = 0 , sum0 = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] == "1" ) sum1 ++ ; else sum0 ++ ; if ( s [ i ] == s [ i - 1 ] && s [ i ] == "0" ) k ++ ; else if ( s [ i ] == s [ i - 1 ] && s [ i ] == "1" ) l ++ ; } if ( s [ 0 ] == "1" ) sum1 ++ ; sum0 ++ ; if ( Math . abs ( sum1 - sum0 ) > 1 ) return - 1 ; return Math . max ( k , l ) ; }
function canTransformStrings ( A , B ) { let n1 = A . length ; let n2 = B . length ; let count1A = 0 , count1B = 0 ; let odd1A = 0 , odd1B = 0 ; let even1A = 0 , even1B = 0 ; for ( let i = 0 ; i < n1 ; i ++ ) { if ( A [ i ] == "1" ) count1A ++ ; else { if ( ( count1A & 1 ) == 1 ) odd1A ++ ; else even1A ++ ; } } for ( let i = 0 ; i < n2 ; i ++ ) { if ( B [ i ] == "1" ) count1B ++ ; else { if ( ( count1B & 1 ) == 1 ) odd1B ++ ; else even1B ++ ; } } if ( count1A == count1B && odd1A == odd1B && even1A == even1B ) { document . write ( "Yes" ) ; } else document . write ( "No" ) ; }
function maxPairs ( nums , k ) { var m = new Map ( ) ; var result = 0 ; nums . forEach ( i => { if ( m . has ( i ) && m . get ( i ) > 0 ) { m . set ( i , m . get ( i ) - 1 ) ; result ++ ; } else { if ( m . has ( k - i ) ) m . set ( k - i , m . get ( k - i ) + 1 ) else m . set ( k - i , 1 ) } } ) ; document . write ( result ) ; }
function uniqueElements ( arr , start , K , mp ) { let st = new Set ( ) ; for ( let i = 0 ; i < K ; i ++ ) st . add ( arr [ start + i ] ) ; for ( let itr of st ) { if ( mp . has ( itr ) ) { mp . set ( itr , mp . get ( itr ) + 1 ) ; } else { mp . set ( itr , 1 ) ; } } }
function smallestPresentNumber ( arr , N , K ) { let mp = new Map ( ) ; for ( let i = 0 ; i <= N - K ; i ++ ) { uniqueElements ( arr , i , K , mp ) ; } checkAnswer ( mp , N , K ) ; }
function generateK ( arr , N ) { for ( let k = 1 ; k <= N ; k ++ ) smallestPresentNumber ( arr , N , k ) ; }
function printAnswer ( answer , N ) { for ( let i = 1 ; i <= N ; i ++ ) { document . write ( answer [ i ] + "▁" ) ; } }
function lengthOfSubarray ( indices , st , N ) { let answer = new Array ( N + 1 ) . fill ( - 1 ) ; for ( let itr of st ) { let start = - 1 ; let gap = - 1 ; indices [ itr ] . push ( N ) ; for ( let i = 0 ; i < indices [ itr ] . length ; i ++ ) { gap = Math . max ( gap , indices [ itr ] [ i ] - start ) ; start = indices [ itr ] [ i ] ; } if ( answer [ gap ] == - 1 ) answer [ gap ] = itr ; } updateAnswerArray ( answer , N ) ; printAnswer ( answer , N ) ; }
function smallestPresentNumber ( arr , N ) { let indices = new Array ( N + 1 ) . fill ( 0 ) . map ( ( ) => [ ] ) ; let elements = new Set ( ) ; for ( let i = 0 ; i < N ; i ++ ) { indices [ arr [ i ] ] . push ( i ) ; elements . add ( arr [ i ] ) ; } lengthOfSubarray ( indices , elements , N ) ; }
function removeIndicesToMakeSumEqual ( arr ) { var N = arr . length ; var odd = Array ( N ) . fill ( 0 ) ; var even = Array ( N ) . fill ( 0 ) ; even [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < N ; i ++ ) { odd [ i ] = odd [ i - 1 ] ; even [ i ] = even [ i - 1 ] ; if ( i % 2 == 0 ) { even [ i ] += arr [ i ] ; } else { odd [ i ] += arr [ i ] ; } } var find = false ; var p = odd [ N - 1 ] ; var q = even [ N - 1 ] - arr [ 0 ] ; if ( p == q ) { document . write ( "0▁" ) ; find = true ; } for ( i = 1 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ; q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; } else { q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ; p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; } if ( p == q ) { find = true ; document . write ( i + "▁" ) ; } } if ( ! find ) { document . write ( - 1 ) ; } }
function cntDisPairs ( arr , N , K ) { var cntPairs = 0 ; arr . sort ( ) ; var i = 0 ; var j = N - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] == K ) { while ( i < j && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } while ( i < j && arr [ j ] == arr [ j - 1 ] ) { j -- ; } cntPairs += 1 ; i ++ ; j -- ; } else if ( arr [ i ] + arr [ j ] < K ) { i ++ ; } else { j -- ; } } return cntPairs ; }
function maxLength ( a , b , n , c ) { if ( n == 0 ) return 0 ; var max_length = 0 ; var low = 0 , high = n ; while ( low <= high ) { var mid = low + parseInt ( ( high - low ) / 2 ) ; if ( possible ( a , b , n , c , mid ) ) { max_length = mid ; low = mid + 1 ; } else high = mid - 1 ; } return max_length ; }
function possible ( a , b , n , c , k ) { var sum = 0 ; for ( i = 0 ; i < k ; i ++ ) { sum += a [ i ] ; } var total_cost = sum * k + getMax ( b , 0 , n - 1 , 0 , k - 1 , 0 ) ; if ( total_cost <= c ) return true ; for ( i = k ; i < n ; i ++ ) { sum += a [ i ] ; sum -= a [ i - k ] ; total_cost = sum * k + getMax ( b , 0 , n - 1 , i - k + 1 , i , 0 ) ; if ( total_cost <= c ) return true ; } return false ; }
function build ( b , index , s , e ) { if ( s == e ) { seg [ index ] = b [ s ] ; return ; } var mid = s + parseInt ( ( e - s ) / 2 ) ; build ( b , 2 * index + 1 , s , mid ) ; build ( b , 2 * index + 2 , mid + 1 , e ) ; seg [ index ] = Math . max ( seg [ 2 * index + 1 ] , seg [ 2 * index + 2 ] ) ; }
function getMax ( b , ss , se , qs , qe , index ) { if ( se < qs ss > qe ) return parseInt ( Number . MIN_VALUE / 2 ) ; if ( ss >= qs && se <= qe ) return seg [ index ] ; var mid = ss + ( se - ss ) / 2 ; return Math . max ( getMax ( b , ss , mid , qs , qe , 2 * index + 1 ) , getMax ( b , mid + 1 , se , qs , qe , 2 * index + 2 ) ) ; }
function maxLength ( a , b , n , c ) { if ( n == 0 ) return 0 ; let max_length = 0 ; let low = 0 , high = n ; while ( low <= high ) { let mid = low + parseInt ( ( high - low ) / 2 , 10 ) ; if ( possible ( a , b , n , c , mid ) ) { max_length = mid ; low = mid + 1 ; } else high = mid - 1 ; } return max_length ; }
function possible ( a , b , n , c , k ) { let dq = [ ] ; let sum = 0 ; for ( let i = 0 ; i < k ; i ++ ) { sum += a [ i ] ; while ( dq . length > 0 && b [ i ] > b [ dq [ dq . length - 1 ] ] ) dq . pop ( ) ; dq . push ( i ) ; } let total_cost = sum * k + b [ dq [ 0 ] ] ; if ( total_cost <= c ) return true ; for ( let i = k ; i < n ; i ++ ) { sum += a [ i ] ; sum -= a [ i - k ] ; while ( dq . length > 0 && dq [ 0 ] <= i - k ) dq . pop ( ) ; while ( dq . length > 0 && b [ i ] > b [ dq [ dq . length - 1 ] ] ) dq . pop ( ) ; dq . push ( i ) ; total_cost = sum * k + b [ dq [ 0 ] ] ; if ( total_cost <= c ) return true ; } return false ; }
function findMaxLength ( N , arr ) { var dp = Array ( N + 1 ) . fill ( 1 ) ; for ( i = 1 ; i <= N ; i ++ ) { for ( j = 2 * i ; j <= N ; j += i ) { if ( arr [ i - 1 ] < arr [ j - 1 ] ) { dp [ j ] = Math . max ( dp [ j ] , dp [ i ] + 1 ) ; } } } return Math . max . apply ( Math , dp ) ; }
function UtilSmallestElement ( arr , N ) { let total = 0 ; for ( let i = 0 ; i < N ; i ++ ) { total += arr [ i ] ; } let dp = new Array ( N + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < dp . length ; i ++ ) { for ( var j = 0 ; j < dp . length ; j ++ ) { dp [ i ] [ j ] = 1 ; } } document . write ( smallestLeft ( arr , total , 0 , N , dp ) ) ; }
function SmallestElementLeft ( arr , N ) { var totalSum = 0 ; for ( i = 0 ; i < N ; i ++ ) { totalSum += arr [ i ] ; } var req = totalSum / 2 ; var dp = Array ( req + 1 ) . fill ( false ) ; dp [ 0 ] = true ; var reach = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = req ; j - arr [ i ] >= 0 ; j -- ) { dp [ j ] = dp [ j ] || dp [ j - arr [ i ] ] ; if ( dp [ j ] ) { reach = Math . max ( reach , j ) ; } } } return totalSum - ( 2 * reach ) ; }
function countSubArraySignChange ( arr , N ) { let prefixCount = new Map ( ) ; let suffixCount = new Map ( ) ; let total = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { total += arr [ i ] ; if ( suffixCount . has ( arr [ i ] ) ) { suffixCount . set ( arr [ i ] , suffixCount . get ( arr [ i ] ) + 1 ) ; } else { suffixCount . set ( arr [ i ] , 1 ) ; } } let prefixSum = 0 ; let suffixSum = 0 ; let count = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { prefixSum += arr [ i ] ; if ( prefixCount . has ( arr [ i ] ) ) { prefixCount . set ( arr [ i ] , prefixCount . get ( arr [ i ] ) + 1 ) ; } else { prefixCount . set ( arr [ i ] , 1 ) ; } suffixSum = total - prefixSum ; if ( suffixCount . has ( arr [ i ] ) ) { suffixCount . set ( arr [ i ] , suffixCount . get ( arr [ i ] ) - 1 ) ; } let diff = prefixSum - suffixSum ; if ( diff % 2 == 0 ) { let x = ( prefixCount . has ( diff / 2 ) ? prefixCount . get ( diff / 2 ) : 0 ) + ( suffixCount . has ( - diff / 2 ) ? suffixCount . get ( - diff / 2 ) : 0 ) ; count = count + x ; } } return count ; }
function countCommonChar ( ind , S ) { var cnt = 0 ; var ls = new Set ( ) ; var rs = new Set ( ) ; for ( var i = 0 ; i < ind ; ++ i ) { ls . add ( S [ i ] ) ; } for ( var i = ind ; i < S . length ; ++ i ) { rs . add ( S [ i ] ) ; } ls . forEach ( v => { if ( rs . has ( v ) ) { ++ cnt ; } } ) ; return cnt ; }
function longestSubarray ( s ) { s += "0" ; let i ; let res = 0 ; let prev_one = 0 ; let curr_one = 0 ; let numberOfZeros = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == "1" ) { curr_one += 1 ; } else { numberOfZeros += 1 ; prev_one += curr_one ; res = Math . max ( res , prev_one ) ; prev_one = curr_one ; curr_one = 0 ; } } if ( numberOfZeros == 1 ) { res -= 1 ; } return res ; }
function LarUnEl ( arr , N ) { var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) else mp . set ( arr [ i ] , 1 ) ; } var LNRElem = - 1000000000 ; var ind = - 1 ; for ( var i = 0 ; i < N ; i ++ ) { if ( mp . get ( arr [ i ] ) == 1 && arr [ i ] > LNRElem ) { ind = i ; LNRElem = arr [ i ] ; } } if ( ind == - 1 ) { cout << ind ; return ; } document . write ( arr [ ind ] ) ; }
function isConsistingSubarrayUtil ( arr , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; ++ i ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } var ans = false ; mp . forEach ( ( value , key ) => { if ( value > 1 ) { ans = true ; } } ) ; if ( ans ) return true ; return false ; }
function isConsistingSubarray ( arr , N ) { if ( isConsistingSubarrayUtil ( arr , N ) ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function countShifts ( str ) { let firstOne = - 1 ; let lastOne = - 1 ; let count = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == "1" ) { if ( firstOne == - 1 ) firstOne = i ; lastOne = i ; } } if ( ( firstOne == - 1 ) || ( firstOne == lastOne ) ) { Console . Write ( 0 ) ; return ; } for ( let i = firstOne ; i <= lastOne ; i ++ ) { if ( str [ i ] == "0" ) { count ++ ; } } document . write ( count ) ; }
function checkSubsequenceUtil ( arr , L , R , N ) { for ( let i = 0 ; i < L ; i ++ ) if ( arr [ i ] == arr [ L ] ) return true ; for ( let i = R + 1 ; i < N ; i ++ ) if ( arr [ i ] == arr [ R ] ) return true ; return false ; }
function largestSubarray ( arr , N , K ) { let count = 0 ; let len = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < K ) { count += 1 ; } else { len = Math . max ( len , count ) ; count = 0 ; } } if ( count != 0 ) { len = Math . max ( len , count ) ; } document . write ( len ) ; }
function findNthNum ( N ) { let a = 0 , b , left ; let right , mid ; let t , last_num = 0 ; left = 1 ; right = N ; while ( left <= right ) { mid = left + ( right - left ) / 2 ; t = ( mid * ( mid + 1 ) ) / 2 ; if ( t < N ) { left = mid + 1 ; } else if ( t == N ) { a = mid ; break ; } else { a = mid ; right = mid - 1 ; } } t = a - 1 ; b = N - ( t * ( t + 1 ) ) / 2 - 1 ; document . write ( ( 1 << a ) + ( 1 << b ) ) ; }
function longestSubsequence ( N , Q , arr , Queries ) { for ( let i = 0 ; i < Q ; i ++ ) { let x = Queries [ i ] [ 0 ] ; let y = Queries [ i ] [ 1 ] ; arr [ x - 1 ] = y ; let count = 1 ; for ( let j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } document . write ( count + "▁" ) ; } }
function longestSubsequence ( N , Q , arr , Queries ) { var count = 1 ; for ( var i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count += 1 ; } } for ( var i = 0 ; i < Q ; i ++ ) { var x = Queries [ i ] [ 0 ] ; var y = Queries [ i ] [ 1 ] ; if ( x > 1 ) { if ( arr [ x - 1 ] != arr [ x - 2 ] ) { count -= 1 ; } if ( arr [ x - 2 ] != y ) { count += 1 ; } } if ( x < N ) { if ( arr [ x ] != arr [ x - 1 ] ) { count -= 1 ; } if ( y != arr [ x ] ) { count += 1 ; } } document . write ( count + "▁" ) ; arr [ x - 1 ] = y ; } }
function longestSubWithMaxSum ( arr , N ) { let Max = Math . max ( ... arr ) ; if ( Max < 0 ) { document . write ( Max ) ; return ; } for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 0 ) { document . write ( arr [ i ] + "▁" ) ; } } }
function printNGE ( arr , n ) { let s = [ ] ; let nge = new Array ( n ) ; let i = 0 ; for ( i = 0 ; i < n ; i ++ ) { nge [ i ] = - 1 ; } i = 0 ; while ( i < 2 * n ) { while ( s . length != 0 && arr [ i % n ] > arr [ s [ s . length - 1 ] ] ) { nge [ s [ s . length - 1 ] ] = arr [ i % n ] ; s . pop ( ) ; } s . push ( i % n ) ; i ++ ; } for ( i = 0 ; i < n ; i ++ ) { document . write ( nge [ i ] + "▁" ) ; } }
function isPerfectSquare ( x ) { var s = Math . sqrt ( x ) ; return ( s * s == x ) ; }
function isFibonacci ( n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
function ifgcdFibonacci ( a , n , k ) { var compositeset = [ ] ; var i ; for ( i = 0 ; i < n ; i ++ ) { if ( isComposite ( a [ i ] ) && a [ i ] % k == 0 ) { compositeset . push ( a [ i ] ) ; } } var gcd = compositeset [ 0 ] ; for ( i = 1 ; i < compositeset . length ; i ++ ) { gcd = __gcd ( gcd , compositeset [ i ] ) ; if ( gcd == 1 ) { break ; } } if ( isFibonacci ( gcd ) ) { document . write ( "Yes" ) ; return ; } document . write ( "No" ) ; return ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function findPair ( A , N ) { let right_prod = [ ] ; let flag = 0 ; right_prod [ N - 1 ] = A [ N - 1 ] ; for ( let i = N - 2 ; i >= 0 ; i -- ) right_prod [ i ] = right_prod [ i + 1 ] * A [ i ] ; let total_prod = right_prod [ 0 ] ; let product ; for ( let i = 1 ; i < N - 1 ; i ++ ) { product = 1 ; for ( let j = i ; j < N - 1 ; j ++ ) { product *= A [ j ] ; if ( gcd ( product , right_prod [ j + 1 ] ) == 1 || gcd ( product , total_prod / right_prod [ i ] ) == 1 ) { flag = 1 ; document . write ( "(" + ( i - 1 ) + ",▁" + ( j + 1 ) + ")" ) ; break ; } } if ( flag == 1 ) break ; } if ( flag == 0 ) document . write ( - 1 ) ; }
function countString ( S ) { var count = 0 ; for ( var it = 0 ; it < S . length ; it ++ ) { if ( S [ it ] == "0" && count > 0 ) { count -- ; } else { count ++ ; } } document . write ( ( 1 << count ) - 1 ) ; }
function replaceDuplicates ( names ) { var hash = new Map ( ) ; for ( var i = 0 ; i < names . length ; i ++ ) { if ( ! hash . has ( names [ i ] ) ) hash . set ( names [ i ] , 1 ) ; else { var count = hash . get ( names [ i ] ) ; hash . set ( names [ i ] , hash . get ( names [ i ] ) + 1 ) ; names [ i ] += count . toString ( ) ; } } for ( var i = 0 ; i < names . length ; i ++ ) { document . write ( names [ i ] + "▁" ) ; } }
function digitProduct ( number ) { var res = 1 ; while ( number > 0 ) { res *= ( number % 10 ) ; number = parseInt ( number / 10 ) ; } return res ; }
function DistinctCompositeDigitProduct ( arr , n ) { var output = new Set ( ) ; var prime = Array ( N + 1 ) . fill ( true ) ; SieveOfEratosthenes ( prime , N ) ; var i ; for ( i = 0 ; i < n ; i ++ ) { var ans = digitProduct ( arr [ i ] ) ; if ( ans <= 1 ) { continue ; } if ( prime [ ans ] == false ) { output . add ( ans ) ; } } document . write ( output . size ) ; }
function SegmentedSieveFn ( low , high ) { let lmt = Math . floor ( Math . sqrt ( high ) ) + 1 ; let prime = new Array ( ) ; simpleSieve ( lmt , prime ) ; let n = high - low + 1 ; let segmentedSieve = new Array ( n + 1 ) . fill ( true ) ; for ( let i = 0 ; i < prime . length ; i ++ ) { let lowLim = Math . floor ( low / prime [ i ] ) * prime [ i ] ; if ( lowLim < low ) { lowLim += prime [ i ] ; } for ( let j = lowLim ; j <= high ; j += prime [ i ] ) { if ( j != prime [ i ] ) { segmentedSieve [ j - low ] = false ; } } } return segmentedSieve ; }
function countPairsWhoseSumPrimeL_R ( L , R ) { let segmentedSieve = SegmentedSieveFn ( L , R ) ; let cntPairs = 0 ; for ( let i = L ; i <= R ; i ++ ) { if ( segmentedSieve [ i - L ] ) { cntPairs += Math . floor ( i / 2 ) ; } } return cntPairs ; }
function count_zeroes ( n , str ) { var cnt = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] === "0" ) cnt ++ ; } return cnt ; }
function kReducingString ( n , k , str ) { var no_of_zeroes = count_zeroes ( n , str ) ; var no_of_ones = n - no_of_zeroes ; if ( no_of_zeroes === 0 no_of_zeroes === n ) { return str ; } if ( k === 1 ) { if ( no_of_zeroes === 0 no_of_zeroes === n ) { return str ; } else { return "Not▁Possible" ; } } var check = false ; for ( var i = n / k ; i < n ; i += n / k ) { if ( no_of_zeroes === i no_of_ones === i ) { check = true ; break ; } } if ( check === false ) { return "Not▁Possible" ; } return kReducingStringUtil ( n , k , str , no_of_zeroes ) ; }
function convert_to_allzeroes ( str , a , b ) { let len = str . length ; let left_1 , i = 0 ; while ( i < len && str [ i ] == "0" ) i ++ ; left_1 = i ; let right_1 ; i = len - 1 ; while ( i >= 0 && str [ i ] == "0" ) i -- ; right_1 = i ; if ( left_1 == len && right_1 == - 1 ) { document . write ( 0 ) ; return ; } let cost = a , zeroes ; for ( i = left_1 ; i <= right_1 ; i ++ ) { zeroes = 0 ; while ( i < len && str [ i ] == "0" ) { zeroes ++ ; i ++ ; } if ( zeroes != 0 ) cost += Math . min ( zeroes * b , a ) ; } document . write ( cost ) ; }
function MinDistK ( arr , N , K ) { let res = Number . MAX_VALUE ; let dist = 0 ; for ( let i = 0 ; i <= ( N - K ) ; i ++ ) { if ( arr [ i ] >= 0 && arr [ i + K - 1 ] >= 0 ) { dist = Math . max ( arr [ i ] , arr [ i + K - 1 ] ) ; } else { dist = Math . abs ( arr [ i ] ) + Math . abs ( arr [ i + K - 1 ] ) + Math . min ( Math . abs ( arr [ i ] ) , Math . abs ( arr [ i + K - 1 ] ) ) ; } res = Math . min ( res , dist ) ; } return res ; }
function maximizeMin ( A , N , S , M ) { let minIndex , left , right , i , j ; for ( i = 0 ; i < M ; i ++ ) { minIndex = min1 ( A , N ) ; A [ minIndex ] ++ ; left = minIndex - 1 ; right = minIndex + 1 ; for ( j = 0 ; j < S - 1 ; j ++ ) { if ( left == - 1 ) A [ right ++ ] ++ ; else if ( right == N ) A [ left -- ] ++ ; else { if ( A [ left ] < A [ right ] ) A [ left -- ] ++ ; else A [ right ++ ] ++ ; } } } minIndex = min1 ( A , N ) ; return A [ minIndex ] ; }
function sumOfPathNodes ( N ) { if ( N == 1 ) { return 1 ; } else if ( N == 2 N == 3 ) { return N + 1 ; } let arr = [ ] ; arr . push ( 1 ) ; let k = 1 ; let flag = true ; while ( k < N ) { if ( flag == true ) { k *= 2 ; flag = false ; } else { k *= 4 ; flag = true ; } if ( k > N ) { break ; } arr . push ( k ) ; } let len = arr . length ; let prefix = new Array ( len ) ; prefix [ 0 ] = 1 ; for ( let i = 1 ; i < len ; ++ i ) { prefix [ i ] = arr [ i ] + prefix [ i - 1 ] ; } let it = lowerBound ( prefix , 0 , len , N ) + 1 ; let ind = it - prefix [ 0 ] ; let final_ans = 0 ; let temp = N ; while ( ind > 1 ) { let val = temp - prefix [ ind - 1 ] ; if ( ind % 2 != 0 ) { temp = prefix [ ind - 2 ] + parseInt ( ( val + 1 ) / 2 , 10 ) ; } else { temp = prefix [ ind - 2 ] + parseInt ( ( val + 3 ) / 4 , 10 ) ; } -- ind ; final_ans += temp ; } final_ans += ( N + 1 ) ; return final_ans ; }
function fill_counts ( a , n ) { let i , j ; let maxA = a [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxA ) { maxA = a [ i ] ; } } for ( i = 0 ; i < n ; i ++ ) { lcount [ a [ i ] ] [ i ] = 1 ; rcount [ a [ i ] ] [ i ] = 1 ; } for ( i = 0 ; i <= maxA ; i ++ ) { for ( j = 1 ; j < n ; j ++ ) { lcount [ i ] [ j ] = lcount [ i ] [ j - 1 ] + lcount [ i ] [ j ] ; } for ( j = n - 2 ; j >= 0 ; j -- ) { rcount [ i ] [ j ] = rcount [ i ] [ j + 1 ] + rcount [ i ] [ j ] ; } } }
function checkPointRange ( arr , X , Y , N ) { for ( let i = 0 ; i < N ; i ++ ) { let dist = Math . sqrt ( ( arr [ i ] [ 0 ] - X ) * ( arr [ i ] [ 0 ] - X ) + ( arr [ i ] [ 1 ] - Y ) * ( arr [ i ] [ 1 ] - Y ) ) ; if ( dist <= arr [ i ] [ 2 ] ) { return true ; } } return false ; }
function findWinner ( arr , N ) { let odd = 0 ; let even = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd ++ ; } else { even ++ ; } } if ( even == 0 ) { if ( odd % 2 == 0 ) { document . write ( "Player▁2" ) ; } else if ( odd % 2 == 1 ) { document . write ( "Player▁1" ) ; } } else if ( even == 1 && odd % 2 == 1 ) { document . write ( "Player▁1" ) ; } else { document . write ( - 1 ) ; } }
function createhashmap ( Max ) { var hashmap = new Set ( ) ; var curr = 1 ; var prev = 0 ; hashmap . add ( prev ) ; while ( curr <= Max ) { hashmap . add ( curr ) ; var temp = curr ; curr = curr + prev ; prev = temp ; } return hashmap ; }
function SieveOfEratosthenes ( Max ) { var isPrime = Array ( Max + 1 ) . fill ( true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( var p = 2 ; p * p <= Max ; p ++ ) { if ( isPrime [ p ] ) { for ( var i = p * p ; i <= Max ; i += p ) { isPrime [ i ] = false ; } } } return isPrime ; }
function cntFibonacciPrime ( arr , N ) { var Max = arr [ 0 ] ; for ( var i = 1 ; i < N ; i ++ ) { Max = Math . max ( Max , arr [ i ] ) ; } var isPrime = SieveOfEratosthenes ( Max ) ; var hashmap = createhashmap ( Max ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) continue ; if ( hashmap . has ( arr [ i ] ) && ! isPrime [ arr [ i ] ] ) { document . write ( arr [ i ] + "▁" ) ; } } }
function minJumps ( seats ) { let position = [ ] ; let count = 0 ; let len = seats . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( seats [ i ] == "x" ) { position . push ( i - count ) ; count ++ ; } } if ( count == len count == 0 ) return 0 ; let med_index = parseInt ( ( count - 1 ) / 2 , 10 ) ; let med_val = position [ med_index ] ; let ans = 0 ; for ( let i = 0 ; i < position . length ; i ++ ) { ans = ( ans % MOD + Math . abs ( position [ i ] - med_val ) % MOD ) % MOD ; } return ans % MOD ; }
function singlePrimeFactor ( N ) { var disPrimeFact = { } ; for ( var i = 2 ; i * i <= N ; ++ i ) { while ( N % i === 0 ) { disPrimeFact [ i ] = 1 ; N = parseInt ( N / i ) ; } } if ( N !== 1 ) { disPrimeFact [ N ] = 1 ; } if ( Object . keys ( disPrimeFact ) . length === 1 ) { for ( const [ key , value ] of Object . entries ( disPrimeFact ) ) { return key ; } } return - 1 ; }
function cntsingleFactorPair ( arr , N ) { var countOf1 = 0 ; var mp = { } ; for ( var i = 0 ; i < N ; i ++ ) { if ( arr [ i ] === 1 ) { countOf1 ++ ; continue ; } var factorValue = singlePrimeFactor ( arr [ i ] ) ; if ( factorValue === - 1 ) { continue ; } else { if ( mp . hasOwnProperty ( factorValue ) ) mp [ factorValue ] = mp [ factorValue ] + 1 ; else mp [ factorValue ] = 1 ; } } var res = 0 ; for ( const [ key , value ] of Object . entries ( mp ) ) { var X = value ; res = parseInt ( res + countOf1 * X + ( X * ( X - 1 ) ) / 2 ) ; } return res ; }
function countPairs ( v1 , v2 , n , m , k ) { let count = 0 ; if ( n <= m ) { v1 . sort ( ) ; for ( let j = 0 ; j < m ; j ++ ) { let index = lowerBound ( v1 , 0 , n , v2 [ j ] - k ) ; count += index ; } } else { v2 . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let index = upperBound ( v2 , 0 , m , v1 [ i ] + k ) ; count += m - index ; } } return count ; }
function maxSumSubarr ( A , N , K , X ) { let sum_K = 0 ; for ( let i = 0 ; i < K ; i ++ ) { sum_K += A [ i ] ; } let Max_Sum = 0 ; if ( sum_K < X ) { Max_Sum = sum_K ; } for ( let i = K ; i < N ; i ++ ) { sum_K -= ( A [ i - K ] - A [ i ] ) ; if ( sum_K < X ) { Max_Sum = Math . max ( Max_Sum , sum_K ) ; } } document . write ( Max_Sum ) ; }
function removeSmallestSubarray ( arr , n , k ) { let mod_arr = new Array ( n ) ; let total_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { mod_arr [ i ] = ( arr [ i ] + k ) % k ; total_sum += arr [ i ] ; } let target_remainder = total_sum % k ; if ( target_remainder == 0 ) { document . write ( "0" ) ; return ; } let map1 = new Map ( ) ; map1 . set ( 0 , - 1 ) ; let curr_remainder = 0 ; let res = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) { curr_remainder = ( curr_remainder + arr [ i ] + k ) % k ; map1 . set ( curr_remainder , i ) ; let mod = ( curr_remainder - target_remainder + k ) % k ; if ( map1 . has ( mod ) ) res = Math . min ( res , i - map1 . get ( mod ) ) ; } if ( res == Number . MAX_SAFE_INTEGER res == n ) { res = - 1 ; } document . write ( res ) ; }
function findMaxLen ( wood , N , K ) { var left = 1 ; var right = Math . max . apply ( Math , wood ) ; while ( left <= right ) { var mid = left + ( right - left ) / 2 ; if ( isValid ( wood , N , mid , K ) ) { left = mid + 1 ; } else { right = mid - 1 ; } } return right ; }
function countFactors ( spf , num ) { let count = 0 ; while ( num > 1 ) { count ++ ; num = num / spf [ num ] ; } return count ; }
function precalculateSum ( spf ) { let sum = new Array ( MAX ) ; sum [ 0 ] = 0 ; for ( let i = 1 ; i < MAX ; i ++ ) { let prime_factor = countFactors ( spf , i ) ; if ( spf [ prime_factor ] == prime_factor ) { sum [ i ] = sum [ i - 1 ] + 1 ; } else { sum [ i ] = sum [ i - 1 ] ; } } return sum ; }
function countSum ( a , n , sum ) { let i , j , k , l ; let count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { for ( k = j + 1 ; k < n - 1 ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) count ++ ; } } } } return count ; }
function countSum ( a , n , sum ) { var i , j , k , l ; var count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { var req = sum - a [ i ] - a [ j ] ; var m = new Map ( ) ; for ( k = j + 1 ; k < n ; k ++ ) { if ( m . has ( a [ k ] ) ) m . set ( a [ k ] , m . get ( a [ k ] ) + 1 ) else m . set ( a [ k ] , 1 ) } var twice_count = 0 ; for ( k = j + 1 ; k < n ; k ++ ) { if ( m . has ( req - a [ k ] ) ) twice_count += m . get ( req - a [ k ] ) ; if ( ( req - a [ k ] ) == a [ k ] ) twice_count -- ; } count += parseInt ( twice_count / 2 ) ; } } return count ; }
function countSum ( a , n , sum ) { let i , j , k ; let count = 0 ; let m = new Map ( ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { let temp = a [ i ] + a [ j ] ; if ( temp < sum && m . has ( sum - temp ) ) count += m . get ( sum - temp ) ; } for ( j = 0 ; j < i ; j ++ ) { let temp = a [ i ] + a [ j ] ; if ( temp < sum ) if ( m . has ( temp ) ) m . set ( temp , m . get ( temp ) + 1 ) ; else m . set ( temp , 1 ) ; } } return count ; }
function minSwaps ( S , n ) { let swaps = 0 ; let arr = new Array ( 26 ) ; for ( let i = 0 ; i < arr . length ; i ++ ) arr [ i ] = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { let pos = S [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ; arr [ pos ] . push ( i ) ; } for ( let ch = "a" . charCodeAt ( 0 ) ; ch <= "z" . charCodeAt ( 0 ) ; ++ ch ) { let pos = ch - "a" . charCodeAt ( 0 ) ; for ( let i = 1 ; i < arr [ pos ] . length ; ++ i ) { swaps += Math . abs ( arr [ pos ] [ i ] - arr [ pos ] [ i - 1 ] - 1 ) ; } } return swaps ; }
function isValid ( arr , n , m , d ) { for ( i = 0 ; i < m ; i ++ ) { if ( Math . abs ( arr [ n - m + i ] - arr [ i ] ) < d ) { return 0 ; } } return 1 ; }
function max_distance ( a , temp , n ) { var mp = new Map ( ) ; for ( var i = 1 ; i <= n ; i ++ ) { temp [ i ] = - 1 ; } for ( var i = 0 ; i < n ; i ++ ) { if ( ! mp . has ( a [ i ] ) ) temp [ a [ i ] ] = i + 1 ; else temp [ a [ i ] ] = Math . max ( temp [ a [ i ] ] , i - mp [ a [ i ] ] ) ; mp . set ( a [ i ] , i ) ; } for ( var i = 1 ; i <= n ; i ++ ) { if ( temp [ i ] != - 1 ) temp [ i ] = Math . max ( temp [ i ] , n - mp . get ( i ) ) ; } }
function min_comm_ele ( a , ans , temp , n ) { max_distance ( a , temp , n ) ; for ( var i = 1 ; i <= n ; i ++ ) { ans [ i ] = - 1 ; } for ( var i = 1 ; i <= n ; i ++ ) { if ( ans [ temp [ i ] ] == - 1 ) ans [ temp [ i ] ] = i ; } for ( var i = 1 ; i <= n ; i ++ ) { if ( i > 1 && ans [ i - 1 ] != - 1 ) { if ( ans [ i ] == - 1 ) ans [ i ] = ans [ i - 1 ] ; else ans [ i ] = Math . min ( ans [ i ] , ans [ i - 1 ] ) ; } document . write ( ans [ i ] + "▁" ) ; } }
function maxiConsecutiveSubarray ( arr , N ) { let maxi = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { let cnt = 1 , j ; for ( j = i ; j < N - 1 ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = Math . max ( maxi , cnt ) ; i = j ; } return maxi ; }
function FindTrip ( arr , N ) { for ( let i = 1 ; i < N - 1 ; i ++ ) { let p = arr [ i - 1 ] ; let q = arr [ i ] ; let r = arr [ i + 1 ] ; if ( p < q && q > r ) { document . write ( ( i - 1 ) + "▁" + ( i ) + "▁" + ( i + 1 ) ) ; return ; } } document . write ( - 1 ) ; }
function cntSubarrays ( arr , N ) { var cntSub = 0 ; var cntUnique = 0 ; var cntFreq = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { for ( var j = i ; j < N ; j ++ ) { if ( cntFreq . has ( arr [ j ] ) ) cntFreq . set ( arr [ j ] , cntFreq . get ( arr [ j ] ) + 1 ) else cntFreq . set ( arr [ j ] , 1 ) ; if ( cntFreq . get ( arr [ j ] ) == 1 ) { cntUnique ++ ; } else if ( cntFreq . get ( arr [ j ] ) == 2 ) { cntUnique -- ; } if ( cntUnique == 0 ) { cntSub ++ ; } } cntFreq = new Map ( ) ; cntUnique = 0 ; } return cntSub ; }
function checkPalinK ( str , K ) { var N = str . length ; var cntFreq = Array ( 256 ) . fill ( 0 ) ; var i ; for ( i = 0 ; i < N ; i ++ ) { cntFreq [ str [ i ] ] += 1 ; } var cntOddFreq = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { if ( cntFreq [ i ] % 2 == 1 ) { cntOddFreq ++ ; } } if ( cntOddFreq <= ( K + 1 ) ) { return true ; } return false ; }
function printIndexes ( str ) { var N = str . length ; var cntFreq = Array ( 256 ) . fill ( 0 ) ; for ( var i = 0 ; i < N ; i ++ ) { cntFreq [ str [ i ] . charCodeAt ( 0 ) ] ++ ; } var cntLeftFreq = Array ( 256 ) . fill ( 0 ) ; for ( var i = 0 ; i < N ; i ++ ) { var cntLeft = 0 ; var cntRight = 0 ; for ( var j = str [ i ] . charCodeAt ( 0 ) - 1 ; j >= 0 ; j -- ) { cntLeft += cntLeftFreq [ j ] ; cntRight += cntFreq [ j ] - cntLeftFreq [ j ] ; } cntLeftFreq [ str [ i ] . charCodeAt ( 0 ) ] ++ ; if ( cntLeft == cntRight && cntLeft != 0 ) { document . write ( i + "▁" ) ; } } }
function digiSum ( a ) { let sum = 0 ; while ( a ) { sum += a % 10 ; a = Math . floor ( a / 10 ) ; } return sum ; }
function isPrime ( r ) { let s = true ; for ( let i = 2 ; i * i <= r ; i ++ ) { if ( r % i == 0 ) { s = false ; break ; } } return s ; }
function Count_Number ( x ) { let ans = 0 ; if ( x % 99 != 0 ) { ans = - 1 ; } else { let diff = x / 99 ; for ( let i = 1 ; i < 10 ; i ++ ) { for ( let j = 1 ; j < 10 ; j ++ ) { if ( ( i - j ) == diff ) { ans += 10 ; } } } } return ans ; }
function find_index ( arr , n , K ) { for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == K ) return i ; else if ( arr [ i ] > K ) return i ; return n ; }
function find_index ( arr , n , K ) { let start = 0 ; let end = n - 1 ; while ( start <= end ) { let mid = Math . floor ( ( start + end ) / 2 ) ; if ( arr [ mid ] == K ) return mid ; else if ( arr [ mid ] < K ) start = mid + 1 ; else end = mid - 1 ; } return end + 1 ; }
function isinRange ( board ) { for ( var i = 0 ; i < N ; i ++ ) { for ( var j = 0 ; j < N ; j ++ ) { if ( board [ i ] [ j ] <= 0 board [ i ] [ j ] > 9 ) { return false ; } } } return true ; }
function isValidSudoku ( board ) { if ( isinRange ( board ) == false ) { return false ; } var unique = Array ( N + 1 ) . fill ( false ) ; for ( var i = 0 ; i < N ; i ++ ) { unique = Array ( N + 1 ) . fill ( false ) ; unique = Array ( N + 1 ) . fill ( false ) ; for ( var j = 0 ; j < N ; j ++ ) { var Z = board [ i ] [ j ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( var i = 0 ; i < N ; i ++ ) { for ( var j = 0 ; j < N ; j ++ ) { var Z = board [ j ] [ i ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( var i = 0 ; i < N - 2 ; i += 3 ) { for ( var j = 0 ; j < N - 2 ; j += 3 ) { unique = Array ( N + 1 ) . fill ( false ) ; for ( var k = 0 ; k < 3 ; k ++ ) { for ( var l = 0 ; l < 3 ; l ++ ) { var X = i + k ; var Y = j + l ; var Z = board [ X ] [ Y ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } } } return true ; }
function minSubarray ( arr , N ) { var m = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { var mini = 1000000000 ; for ( var j = i ; j < N ; j ++ ) { mini = Math . min ( mini , arr [ j ] ) ; if ( m . has ( mini ) ) m . set ( mini , m . get ( mini ) + 1 ) else m . set ( mini , 1 ) } } for ( var i = 0 ; i < N ; i ++ ) { document . write ( m . get ( arr [ i ] ) + "▁" ) ; } }
function minSubarray ( arr , N ) { let result = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) result [ i ] = 0 ; let l = [ ] ; let r = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { let count = 1 ; while ( l . length != 0 && l [ l . length - 1 ] [ 0 ] > arr [ i ] ) { count += l [ l . length - 1 ] [ 1 ] ; l . pop ( ) ; } l . push ( [ arr [ i ] , count ] ) ; result [ i ] = count ; } for ( let i = N - 1 ; i >= 0 ; i -- ) { let count = 1 ; while ( r . length != 0 && r [ r . length - 1 ] [ 0 ] >= arr [ i ] ) { count += r [ r . length - 1 ] [ 1 ] ; r . pop ( ) ; } r . push ( [ arr [ i ] , count ] ) ; result [ i ] *= count ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( result [ i ] + "▁" ) ; } }
function isPrime ( num ) { if ( num <= 1 ) return false ; for ( let i = 2 ; i * i <= num ; i ++ ) if ( num % i == 0 ) return false ; return true ; }
function isFulPrime ( n ) { if ( ! isPrime ( n ) ) return false ; else { while ( n > 0 ) { let rem = n % 10 ; if ( ! ( rem == 2 rem == 3 rem == 5 rem == 7 ) ) return false ; n = Math . floor ( n / 10 ) ; } } return true ; }
function countFulPrime ( L , R ) { let cnt = 0 ; for ( let i = L ; i <= R ; i ++ ) { if ( ( i % 2 ) != 0 && isFulPrime ( i ) ) { cnt ++ ; } } return cnt ; }
function computePos ( arr , n , value ) { if ( value < arr [ 0 ] ) return 0 ; if ( value > arr [ n - 1 ] ) return n - 1 ; var start = 0 ; var end = n - 1 ; while ( start < end ) { var mid = parseInt ( ( start + end + 1 ) / 2 ) ; if ( arr [ mid ] >= value ) end = mid - 1 ; else start = mid ; } return start ; }
function countShift ( arr , n , queries ) { for ( var i = 0 ; i < queries . length ; i ++ ) { var index = queries [ i ] [ 0 ] ; var update = queries [ i ] [ 1 ] ; var newElement = arr [ index ] + update ; var newIndex = computePos ( arr , n , newElement ) ; document . write ( Math . abs ( newIndex - index ) + "▁" ) ; } }
function printAlter ( arr , N ) { for ( var currIndex = 0 ; currIndex < N ; currIndex ++ ) { if ( currIndex % 2 == 0 ) { document . write ( arr [ currIndex ] + "▁" ) ; } } }
function printAlter ( arr , N ) { for ( var currIndex = 0 ; currIndex < N ; currIndex += 2 ) { document . write ( arr [ currIndex ] + "▁" ) ; } }
function findmin ( s ) { let n = s . length ; let i , j , maximum = 0 ; var incr = new Array ( n + 1 ) ; incr . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { incr [ i + 1 ] = incr [ i ] ; if ( s [ i ] == "0" ) { incr [ i + 1 ] ++ ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { maximum = Math . max ( maximum , incr [ i ] + j - i + 1 - ( incr [ j + 1 ] - incr [ i ] ) + incr [ n ] - incr [ j + 1 ] ) ; } } return n - maximum ; }
function SieveOfEratosthenes ( prime , p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
function digitSum ( number ) { let sum = 0 ; while ( number > 0 ) { sum += ( number % 10 ) ; number = Math . floor ( number / 10 ) ; } return sum ; }
function longestCompositeDigitSumSubsequence ( arr , n ) { let count = 0 ; let prime = new Array ( N + 1 ) ; for ( let i = 0 ; i <= N ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , N ) ; for ( let i = 0 ; i < n ; i ++ ) { let res = digitSum ( arr [ i ] ) ; if ( res == 1 ) { continue ; } if ( prime [ res ] == false ) { count ++ ; } } document . write ( count ) ; }
function isPower ( x ) { return ( x && ( ! ( x & ( x - 1 ) ) ) ) ; }
function maximumlength ( arr , N ) { var max_length = 0 ; var max_len_subarray = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( isPower ( arr [ i ] ) == 1 ) { max_length ++ ; max_len_subarray = Math . max ( max_length , max_len_subarray ) ; } else { max_length = 0 ; } } document . write ( max_len_subarray ) ; }
function minSub ( N ) { let count = 0 ; while ( N >= 0 ) { let num = N ; let rev = 0 ; while ( num != 0 ) { let digit = num % 10 ; rev = ( rev * 10 ) + digit ; num = Math . floor ( num / 10 ) ; } if ( N == rev ) { break ; } count ++ ; N -- ; } document . write ( count ) ; }
function isPalindrome ( str ) { var i = 0 , j = str . length - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
function isPerfect ( N ) { let sum = 1 ; for ( let i = 2 ; i < Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { sum += i ; } else { sum += i + N / i ; } } } if ( sum == N && N != 1 ) return 1 ; return 0 ; }
function maxSum ( arr , N , K ) { if ( N < K ) { document . write ( "Invalid" ) ; return - 1 ; } let res = 0 ; for ( let i = 0 ; i < K ; i ++ ) { res += arr [ i ] ; } let curr_sum = res ; for ( let i = K ; i < N ; i ++ ) { curr_sum += arr [ i ] - arr [ i - K ] ; res = Math . max ( res , curr_sum ) ; } return res ; }
function max_PerfectNumbers ( arr , N , K ) { for ( let i = 0 ; i < N ; i ++ ) { arr [ i ] = isPerfect ( arr [ i ] ) == 1 ? 1 : 0 ; } return maxSum ( arr , N , K ) ; }
function minElements ( A , B , N , M ) { var map = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { map . set ( A [ i ] , i ) ; } var subseq = [ ] ; var l = 0 , r = - 1 ; for ( var i = 0 ; i < M ; i ++ ) { if ( map . has ( B [ i ] ) ) { var e = map . get ( B [ i ] ) ; while ( l <= r ) { var m = l + parseInt ( ( r - l ) / 2 ) ; if ( subseq [ m ] < e ) l = m + 1 ; else r = m - 1 ; } if ( r + 1 < subseq . length ) { subseq [ r + 1 ] = e ; } else { subseq . push ( e ) ; } l = 0 ; r = subseq . length - 1 ; } } return N - subseq . length ; }
function cntSubarr ( arr , N ) { var res = 0 ; var prefixXor = 0 ; var i , j ; for ( i = 0 ; i < N - 1 ; i ++ ) { prefixXor = arr [ i ] ; for ( j = i + 1 ; j < N ; j ++ ) { prefixXor ^= arr [ j ] ; if ( prefixXor == 0 && ( j - i + 1 ) % 2 == 0 ) { res ++ ; } } } return res ; }
function cntSubXor ( arr , N ) { let prefixXor = 0 ; let Even = Array . from ( { length : M } , ( _ , i ) => 0 ) ; let Odd = Array . from ( { length : M } , ( _ , i ) => 0 ) ; let cntSub = 0 ; Odd [ 0 ] = 1 ; for ( let i = 0 ; i < N ; i ++ ) { prefixXor = Math . floor ( prefixXor ^ arr [ i ] ) ; if ( i % 2 == 1 ) { cntSub += Odd [ prefixXor ] ; Odd [ prefixXor ] ++ ; } else { cntSub += Even [ prefixXor ] ; Even [ prefixXor ] ++ ; } } return cntSub ; }
function zvalue ( nums ) { var m = max_element ( nums ) ; var cnt = 0 ; for ( i = 0 ; i <= m ; i ++ ) { cnt = 0 ; for ( j = 0 ; j < nums . length ; j ++ ) { if ( nums [ j ] >= i ) cnt ++ ; } if ( cnt == i ) return i ; } return - 1 ; }
function isEvenOddBinaryTree ( root ) { if ( root == null ) return true ; let q = [ ] ; q . push ( root ) ; let level = 0 ; while ( q . length > 0 ) { let size = q . length ; for ( let i = 0 ; i < size ; i ++ ) { let node = q [ 0 ] ; q . shift ( ) ; if ( level % 2 == 0 ) { if ( node . val % 2 == 1 ) return false ; } else if ( level % 2 == 1 ) { if ( node . val % 2 == 0 ) return false ; } if ( node . left != null ) { q . push ( node . left ) ; } if ( node . right != null ) { q . push ( node . right ) ; } } level ++ ; } return true ; }
function is_prime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
function countSmallerPrimes ( ar , N ) { for ( let i = 0 ; i < N ; i ++ ) { let count = 0 ; for ( let j = i + 1 ; j < N ; j ++ ) { if ( ar [ j ] <= ar [ i ] && is_prime ( ar [ j ] ) ) { count ++ ; } } document . write ( count + "▁" ) ; } }
function is_prime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
function checkConcat ( str1 , str2 ) { let N = str1 . length ; let M = str2 . length ; if ( N % M != 0 ) { return false ; } for ( let i = 0 ; i < N ; i ++ ) { if ( str1 [ i ] != str2 [ i % M ] ) { return false ; } } return true ; }
function MinLen ( str , K ) { var N = str . length ; var i = 0 ; while ( i < N - 1 ) { if ( str . charAt ( i ) != str . charAt ( i + 1 ) ) { break ; } i ++ ; } if ( i == N - 1 ) { return N ; } return Math . max ( 1 , N - K ) ; }
function findSubArray ( arr , k ) { let n = arr . length ; for ( let i = 0 ; i <= n - k ; i ++ ) { if ( palindrome ( arr , i , i + k - 1 ) ) return i ; } return - 1 ; }
function helper ( mid ) { var cnt = 0 ; mp . forEach ( ( value , ) => { var temp = value ; while ( temp >= mid ) { temp -= mid ; cnt ++ ; } } ) ; return cnt >= N ; }
function findMaximumDays ( arr ) { for ( var i = 0 ; i < P ; i ++ ) { if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) else mp . set ( arr [ i ] , 1 ) ; } var start = 0 , end = P , ans = 0 ; while ( start <= end ) { var mid = start + parseInt ( ( end - start ) / 2 ) ; if ( mid != 0 && helper ( mid ) ) { ans = mid ; start = mid + 1 ; } else if ( mid == 0 ) { start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; }
function temp ( n , x ) { return Math . pow ( ( x * 1.0 ) / n , n ) ; }
function check ( n , y , x ) { var v = temp ( n , x ) ; return v >= y ; }
function speciallyBalancedNodes ( R , N , str , values ) { let root = build_tree ( R , N , str , values ) ; sum = 0 ; SBTUtil ( root ) ; document . write ( sum + "▁" ) ; }
function display ( countLeftGreater , N ) { for ( let i = 0 ; i < N ; i ++ ) { document . write ( countLeftGreater [ i ] , "▁" ) ; } }
function minLength ( arr , N ) { for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return 1 ; } } return N ; }
function PrintIndexes ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let currSubSum = 0 ; for ( let j = i ; j < N ; j ++ ) { currSubSum += arr [ j ] ; let sq = Math . floor ( Math . sqrt ( currSubSum ) ) ; if ( sq * sq == currSubSum ) { document . write ( "(" + i + "," + j + ")" + "▁" ) ; } } } }
function check ( pSum , len , k , a ) { let i = 0 ; let j = len ; while ( j <= a . length ) { let maxSize = a [ j - 1 ] ; let totalNumbers = maxSize * len ; let currNumbers = pSum [ j ] - pSum [ i ] ; if ( currNumbers + k >= totalNumbers ) { return true ; } else { i ++ ; j ++ ; } } return false ; }
function countPosition ( mat ) { var n = mat . length ; var m = mat [ 0 ] . length ; var row = Array . from ( { length : n } , ( _ , i ) => 0 ) ; var col = Array . from ( { length : m } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { col [ j ] ++ ; row [ i ] ++ ; } } } var count = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { if ( row [ i ] == col [ j ] ) { count ++ ; } } } return count ; }
function position ( arr , N ) { let pos = - 1 ; let count ; for ( let i = 0 ; i < N ; i ++ ) { count = 0 ; for ( let j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] && arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) { count ++ ; } } if ( count == N ) { pos = i ; } } if ( pos == - 1 ) { document . write ( pos ) ; } else { document . write ( pos + 1 ) ; } }
function maxAtLevel ( N , M , Value , Edges ) { let adj = new Array ( N ) ; for ( let i = 0 ; i < adj . length ; i ++ ) adj [ i ] = [ ] ; for ( let i = 0 ; i < M ; i ++ ) { let u = Edges [ i ] [ 0 ] ; let v = Edges [ i ] [ 1 ] ; adj [ u ] . push ( v ) ; } let q = [ ] ; q . push ( 0 ) ; while ( q . length > 0 ) { let count = q . length ; let maxVal = 0 ; while ( count -- > 0 ) { let temp = q [ 0 ] ; q . shift ( ) ; maxVal = Math . max ( maxVal , Value [ temp ] ) ; for ( let i = 0 ; i < adj [ temp ] . length ; i ++ ) { q . push ( adj [ temp ] [ i ] ) ; } } document . write ( maxVal + "▁" ) ; } }
function floyd_warshall ( graph , V ) { let dist = new Array ( V ) ; for ( let i = 0 ; i < V ; i ++ ) { dist [ i ] = new Array ( V ) ; } let i , j , k ; for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { dist [ i ] [ j ] = graph [ i ] [ j ] ; } } for ( k = 0 ; k < V ; k ++ ) { for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) { dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } } let sum = 0 ; for ( i = 0 ; i < V ; i ++ ) { for ( j = i + 1 ; j < V ; j ++ ) { sum += dist [ i ] [ j ] ; } } return sum ; }
function sumOfshortestPath ( N , E , edges ) { let g = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { g [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { g [ i ] [ j ] = INF ; } } for ( let i = 0 ; i < E ; i ++ ) { let u = edges [ i ] [ 0 ] ; let v = edges [ i ] [ 1 ] ; let w = edges [ i ] [ 2 ] ; g [ u ] [ v ] = w ; g [ v ] [ u ] = w ; } return floyd_warshall ( g , N ) ; }
function minCost ( A , B ) { var n = A . length ; var i = 0 ; var maxlen = 0 ; while ( i < n ) { var length = 0 ; for ( var j = 0 ; j < n ; ++ j ) { if ( A [ i ] == B [ j ] ) { ++ i ; ++ length ; if ( i == n ) break ; } } maxlen = Math . max ( maxlen , length ) ; } return n - maxlen ; }
function binarySearch ( arr , N , X ) { let start = 0 ; let end = N ; while ( start <= end ) { let mid = Math . floor ( start + ( end - start ) / 2 ) ; if ( X == arr [ mid ] ) { return mid ; } else if ( X < arr [ mid ] ) { start = mid + 1 ; } else { end = mid - 1 ; } } return - 1 ; }
function check ( a , n ) { let b = new Array ( n ) . fill ( 0 ) ; let minElement = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { b [ i ] = a [ i ] ; minElement = Math . min ( minElement , a [ i ] ) ; } b . sort ( ) ; let k = 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] && a [ i ] % minElement != 0 ) { k = 0 ; break ; } } return k == 1 ? true : false ; }
function check_both_present ( arr , N , a , b ) { let f1 = false , f2 = false ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == a ) { f1 = true ; } if ( arr [ i ] == b ) { f2 = true ; } } if ( f1 && f2 ) { return true ; } else { return false ; } }
function print_array ( ans , N ) { for ( let i = 0 ; i < N ; i ++ ) { document . write ( ans [ i ] + "▁" ) ; } }
function build_AP ( N , a , b ) { let arr = Array ( N ) . fill ( 0 ) ; let ans = Array ( N ) . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) ans [ i ] = Number . MAX_VALUE ; let flag = 0 ; if ( a > b ) { a += ( b - ( b = a ) ) ; } let diff = b - a ; for ( let start = 1 ; start <= a ; start ++ ) { for ( let d = 1 ; d <= diff ; d ++ ) { arr [ 0 ] = start ; for ( let i = 1 ; i < N ; i ++ ) { arr [ i ] = arr [ i - 1 ] + d ; } if ( check_both_present ( arr , N , a , b ) && arr [ N - 1 ] < ans [ N - 1 ] ) { for ( let i = 0 ; i < N ; i ++ ) { ans [ i ] = arr [ i ] ; } } } } print_array ( ans , N ) ; }
function numSpecial ( mat ) { var m = mat . length ; var n = mat [ 0 ] . length ; var rows = Array . from ( { length : m } , ( _ , i ) => 0 ) ; var cols = Array . from ( { length : n } , ( _ , i ) => 0 ) ; var i , j ; for ( i = 0 ; i < m ; i ++ ) { rows [ i ] = 0 ; for ( j = 0 ; j < n ; j ++ ) rows [ i ] += mat [ i ] [ j ] ; } for ( i = 0 ; i < n ; i ++ ) { cols [ i ] = 0 ; for ( j = 0 ; j < m ; j ++ ) cols [ i ] += mat [ j ] [ i ] ; } var cnt = 0 ; for ( i = 0 ; i < m ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 && rows [ i ] == 1 && cols [ j ] == 1 ) cnt ++ ; } } return cnt ; }
function ctMinEdits ( str1 , str2 ) { let N1 = str1 . length ; let N2 = str2 . length ; let freq1 = new Array ( 256 ) . fill ( 0 ) ; for ( let i = 0 ; i < N1 ; i ++ ) { freq1 [ str1 [ i ] . charCodeAt ( ) ] ++ ; } let freq2 = new Array ( 256 ) . fill ( 0 ) ; for ( let i = 0 ; i < N2 ; i ++ ) { freq2 [ str2 [ i ] . charCodeAt ( ) ] ++ ; } for ( let i = 0 ; i < 256 ; i ++ ) { if ( freq1 [ i ] > freq2 [ i ] ) { freq1 [ i ] = freq1 [ i ] - freq2 [ i ] ; freq2 [ i ] = 0 ; } else { freq2 [ i ] = freq2 [ i ] - freq1 [ i ] ; freq1 [ i ] = 0 ; } } let sum1 = 0 ; let sum2 = 0 ; for ( let i = 0 ; i < 256 ; i ++ ) { sum1 += freq1 [ i ] ; sum2 += freq2 [ i ] ; } return Math . max ( sum1 , sum2 ) ; }
function create_graph ( ) { g [ 1 ] . push ( 2 ) ; g [ 2 ] . push ( 1 ) ; g [ 1 ] . push ( 3 ) ; g [ 3 ] . push ( 1 ) ; g [ 1 ] . push ( 4 ) ; g [ 4 ] . push ( 1 ) ; g [ 2 ] . push ( 5 ) ; g [ 5 ] . push ( 2 ) ; g [ 2 ] . push ( 6 ) ; g [ 6 ] . push ( 2 ) ; }
function dfs ( node , parent ) { size [ node ] = 1 ; var mx = 0 ; g [ node ] . forEach ( y => { if ( y != parent ) { dfs ( y , node ) ; size [ node ] += size [ y ] ; mx = Math . max ( mx , size [ y ] ) ; } } ) ; mx = Math . max ( mx , n - size [ node ] ) ; if ( mx < mini ) { mini = mx ; ans = node ; } }
function countPrecedingK ( a , n , K ) { let prefix = new Array ( n ) . fill ( 0 ) ; prefix [ 0 ] = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + a [ i ] ; } let ctr = 0 ; if ( prefix [ K - 1 ] < a [ K ] ) ctr ++ ; for ( let i = K + 1 ; i < n ; i ++ ) { if ( prefix [ i - 1 ] - prefix [ i - K - 1 ] < a [ i ] ) ctr ++ ; } return ctr ; }
function minDigits ( N , K ) { let digits_num = Math . floor ( Math . log ( N ) / Math . log ( 10 ) + 1 ) ; let temp_sum = 0 ; let temp = digits_num ; let result ; let X , var1 ; let sum = 0 ; let num2 = N ; while ( num2 != 0 ) { sum += num2 % 10 ; num2 = parseInt ( num2 / 10 ) ; } if ( sum <= K ) { X = 0 ; } else { while ( temp > 0 ) { var1 = parseInt ( N / ( Math . pow ( 10 , temp - 1 ) ) ) ; temp_sum += var1 % 10 ; if ( temp_sum >= K ) { var1 = parseInt ( var1 / 10 ) ; var1 ++ ; result = var1 * Math . pow ( 10 , temp ) ; break ; } temp -- ; } X = result - N ; return X ; } }
function CountPairs ( a , b , n ) { var C = Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { C [ i ] = a [ i ] + b [ i ] ; } var freqCount = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( freqCount . has ( C [ i ] ) ) freqCount . set ( C [ i ] , freqCount . get ( C [ i ] ) + 1 ) else freqCount . set ( C [ i ] , 1 ) } var NoOfPairs = 0 ; freqCount . forEach ( ( value , key ) => { var y = value ; NoOfPairs = NoOfPairs + y * ( y - 1 ) / 2 ; } ) ; document . write ( NoOfPairs ) ; }
function convertBfromA ( a , b ) { let moves = 0 ; let x = Math . abs ( a - b ) ; for ( let i = 10 ; i > 0 ; i -- ) { moves += Math . floor ( x / i ) ; x = x % i ; } document . write ( moves + "▁" ) ; }
function smallestNth ( A , B , N ) { let res = Number . MAX_VALUE ; for ( let i = 1 ; i < N ; i ++ ) { for ( let j = N ; j > i ; j -- ) { if ( ( B - A ) % ( j - i ) == 0 ) { let D = ( B - A ) / ( j - i ) ; let FirstTerm = A - ( i - 1 ) * D ; let NthTerm = FirstTerm + ( N - 1 ) * D ; if ( FirstTerm > 0 ) res = Math . min ( res , NthTerm ) ; } } } return res ; }
function sieve ( prime ) { for ( var i = 0 ; i < 1000000 ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( var i = 2 ; i * i <= 1000000 ; i ++ ) { if ( prime [ i ] ) { for ( var j = i * i ; j <= 1000000 ; j += i ) { prime [ j ] = false ; } } } }
function subPrimeSum ( N , K , arr , prime ) { var currSum = 0 ; for ( var i = 0 ; i < K ; i ++ ) { currSum += arr [ i ] ; } if ( prime [ currSum ] ) { for ( var i = 0 ; i < K ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } return ; } var st = 1 , en = K ; while ( en < N ) { currSum += arr [ en ] - arr [ st - 1 ] ; if ( prime [ currSum ] ) { for ( var i = st ; i <= en ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } return ; } en ++ ; st ++ ; } }
function minDeletion ( str ) { let n = str . length ; let firstIdx1 = - 1 ; let lastIdx0 = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == "1" ) { firstIdx1 = i ; break ; } } for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == "0" ) { lastIdx0 = i ; break ; } } if ( firstIdx1 == - 1 lastIdx0 == - 1 ) return 0 ; let count1 = 0 , count0 = 0 ; for ( let i = 0 ; i < lastIdx0 ; i ++ ) { if ( str [ i ] == "1" ) { count1 ++ ; } } for ( let i = firstIdx1 + 1 ; i < n ; i ++ ) { if ( str [ i ] == "1" ) { count0 ++ ; } } return Math . min ( count0 , count1 ) ; }
function maximumSum ( a , b , n , index , lastpicked ) { if ( index == n ) return 0 ; let option1 = 0 , option2 = 0 ; if ( lastpicked == - 1 a [ lastpicked ] != a [ index ] ) option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) ; option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) ; return Math . max ( option1 , option2 ) ; }
function maximumSum ( a , b , n , index , lastpicked , dp ) { if ( index == n ) return 0 ; if ( dp [ index ] [ lastpicked + 1 ] != - 1 ) return dp [ index ] [ lastpicked + 1 ] ; let option1 = 0 , option2 = 0 ; if ( lastpicked == - 1 a [ lastpicked ] != a [ index ] ) { option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index , dp ) ; } option2 = maximumSum ( a , b , n , index + 1 , lastpicked , dp ) ; return dp [ index ] [ lastpicked + 1 ] = Math . max ( option1 , option2 ) ; }
function sumOfKElements ( arr , n , k ) { let rev = false ; if ( k < 0 ) { rev = true ; k *= - 1 ; let l = 0 , r = n - 1 ; while ( l < r ) { let tmp = arr [ l ] ; arr [ l ] = arr [ r ] ; arr [ r ] = tmp ; l ++ ; r -- ; } } let dp = new Uint8Array ( n ) ; dp [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { dp [ i ] += dp [ i - 1 ] + arr [ i ] ; } let ans = new Uint8Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( i + k < n ) ans [ i ] = dp [ i + k ] - dp [ i ] ; else { let x = k - ( n - 1 - i ) ; let y = Math . floor ( x / n ) ; let rem = x % n ; ans [ i ] = dp [ n - 1 ] - dp [ i ] + y * dp [ n - 1 ] + ( rem - 1 >= 0 ? dp [ rem - 1 ] : 0 ) ; } } if ( rev ) { for ( let i = n - 1 ; i >= 0 ; i -- ) { document . write ( ans [ i ] + "▁" ) ; } } else { for ( let i = 0 ; i < n ; i ++ ) { document . write ( ans [ i ] + "▁" ) ; } } }
function countingSubarray ( arr , n ) { let a = new Array ( n ) ; let nsml = new Array ( n ) ; nsml . fill ( - 1 ) ; let nsmr = new Array ( n ) ; nsmr . fill ( n ) ; let st = [ ] ; for ( let i = n - 1 ; i >= 0 ; i -- ) { while ( st . length > 0 && arr [ st [ st . length - 1 ] ] >= arr [ i ] ) st . pop ( ) ; nsmr [ i ] = ( st . length > 0 ) ? st [ st . length - 1 ] : n ; st . push ( i ) ; } while ( st . length > 0 ) st . pop ( ) ; for ( let i = 0 ; i < n ; i ++ ) { while ( st . length > 0 && arr [ st [ st . length - 1 ] ] >= arr [ i ] ) st . pop ( ) ; nsml [ i ] = ( st . length > 0 ) ? st [ st . length - 1 ] : - 1 ; st . push ( i ) ; } for ( let i = 0 ; i < n ; i ++ ) { nsml [ i ] ++ ; nsmr [ i ] -- ; let r = nsmr [ i ] - i + 1 ; let l = i - nsml [ i ] + 1 ; a [ i ] = r * l ; } return a ; }
function countTuples ( arr , N ) { var ans = 0 , val = 0 ; var freq = new Map ( ) ; for ( var j = 0 ; j < N - 2 ; j ++ ) { val = 0 ; for ( var l = j + 1 ; l < N ; l ++ ) { if ( arr [ j ] == arr [ l ] ) { ans += val ; } if ( freq . has ( arr [ l ] ) ) { val += freq . get ( arr [ l ] ) ; } } if ( freq . has ( arr [ j ] ) ) { freq . set ( arr [ j ] , freq . get ( arr [ j ] ) + 1 ) ; } else { freq . set ( arr [ j ] , 1 ) ; } } return ans ; }
function isCrossed ( path ) { if ( path . length == 0 ) return ; let ans = false ; let mySet = new Set ( ) ; let x = 0 , y = 0 ; mySet . add ( [ x , y ] ) ; for ( let i = 0 ; i < path . length ; i ++ ) { if ( path [ i ] == "N" ) mySet . add ( [ x , y ++ ] ) ; if ( path [ i ] == "S" ) mySet . add ( [ x , y -- ] ) ; if ( path [ i ] == "E" ) mySet . add ( [ x ++ , y ] ) ; if ( path [ i ] == "W" ) mySet . add ( [ x -- , y ] ) ; if ( ! mySet . has ( [ x , y ] ) ) { ans = true ; break ; } } if ( ans ) document . write ( "Crossed" ) ; else document . write ( "Not▁Crossed" ) ; }
function GCD ( a , b ) { if ( b == 0 ) { return a ; } return GCD ( b , a % b ) ; }
function GcdPair ( arr , k ) { var lo = 0 , hi = arr . length - 1 , mid ; var ans = [ - 1 , 0 ] ; while ( lo <= hi ) { mid = lo + parseInt ( ( hi - lo ) / 2 ) ; if ( GCD ( arr [ mid ] [ 0 ] , arr [ mid ] [ 1 ] ) > k ) { ans = arr [ mid ] ; hi = mid - 1 ; } else lo = mid + 1 ; } if ( ans [ 0 ] == - 1 ) document . write ( "-1" ) ; else document . write ( "(▁" + ans [ 0 ] + ",▁" + ans [ 1 ] + "▁)" ) ; return ; }
function isPossible ( arr , N ) { let mn = Number . MAX_VALUE ; let B = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { mn = Math . min ( mn , arr [ i ] ) ; B [ i ] = arr [ i ] ; } arr . sort ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != B [ i ] ) { if ( B [ i ] % mn != 0 ) { document . write ( "No" ) ; return ; } } } document . write ( "Yes" ) ; return ; }
function func ( n ) { var count = 0 ; if ( n == 2 n == 1 ) return 1 ; if ( n % 2 == 0 ) count = 1 + func ( n / 2 ) ; if ( n % 2 != 0 ) count = 1 + func ( n * 3 + 1 ) ; return count ; }
function findKthElement ( l , r , k ) { var arr = [ ] ; for ( var i = l ; i <= r ; i ++ ) arr . push ( i ) ; var result = [ ] ; arr . forEach ( i => { result . push ( [ i , func ( i ) ] ) ; } ) ; result . sort ( ) ; document . write ( result [ k - 1 ] [ 0 ] ) ; }
function checkHex ( s ) { let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { let ch = s [ i ] ; if ( ( ch < "0" ch > "9" ) && ( ch < "A" ch > "F" ) ) { document . write ( "No" ) ; return ; } } document . write ( "Yes" ) ; }
function maxWidth ( N , M , cost , s ) { let adj = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { adj . push ( [ ] ) ; } for ( let i = 0 ; i < M ; i ++ ) { adj [ s [ i ] [ 0 ] ] . push ( s [ i ] [ 1 ] ) ; } let result = 0 ; let q = [ ] ; q . push ( 0 ) ; while ( q . length != 0 ) { let count = q . length ; result = Math . max ( count , result ) ; while ( count -- > 0 ) { let temp = q . shift ( ) ; for ( let i = 0 ; i < adj [ temp ] . length ; i ++ ) { q . push ( adj [ temp ] [ i ] ) ; } } } return result ; }
function addEdge ( adj , u , v ) { ( adj [ u ] ) . push ( v ) ; ( adj [ v ] ) . push ( u ) ; }
function DFSUtil ( u , adj , visited , componentMin , componentMax ) { visited [ u ] = true ; componentMax = Math . max ( componentMax , u ) ; componentMin = Math . min ( componentMin , u ) ; for ( var i = 0 ; i < ( adj [ u ] ) . length ; i ++ ) if ( visited [ ( adj [ u ] ) [ i ] ] == false ) DFSUtil ( ( adj [ u ] ) [ i ] , adj , visited , componentMin , componentMax ) ; }
function isValid ( v ) { var MAX = - 1 ; var ans = false ; for ( var i of v ) { if ( i . first <= MAX ) { ans = true ; } MAX = Math . max ( MAX , i . second ) ; } return ( ans == false ? true : false ) ; }
function DFS ( adj , V ) { var v = [ ] ; var visited = Array ( V + 1 ) . fill ( false ) ; for ( var u = 1 ; u <= V ; u ++ ) { if ( visited [ u ] == false ) { var componentMax = u ; var componentMin = u ; DFSUtil ( u , adj , visited , componentMin , componentMax ) ; v . push ( new pair ( componentMin , componentMax ) ) ; } } var check = isValid ( v ) ; if ( check ) document . write ( "Yes" ) ; else document . write ( "No" ) ; return ; }
function checkEqual ( arr , N ) { var hash = Array ( 256 ) . fill ( 0 ) ; var M = arr [ 0 ] . length ; for ( var i = 0 ; i < N ; i ++ ) { for ( var j = 0 ; j < M ; j ++ ) { hash [ arr [ i ] [ j ] ] ++ ; } } for ( var i = 0 ; i < 256 ; i ++ ) { if ( hash [ i ] % N != 0 ) { return false ; } } return true ; }
function print_substring ( s ) { let n = s . length ; let str = "" ; let ans = [ ] ; if ( n == 0 ) { document . write ( "-1" ) ; return ; } let last_pos = Array ( 26 ) . fill ( - 1 ) ; for ( let i = n - 1 ; i >= 0 ; -- i ) { if ( last_pos [ s [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] == - 1 ) { last_pos [ s [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] = i ; } } let minp = - 1 ; for ( let i = 0 ; i < n ; ++ i ) { let lp = last_pos [ s [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ; minp = Math . max ( minp , lp ) ; if ( i == minp ) { str += s [ i ] ; document . write ( str + "▁" ) ; minp = - 1 ; str = "" ; } else { str += s [ i ] ; } } }
function partitionString ( s ) { let n = s . length ; let ans = [ ] ; if ( n == 0 ) { document . write ( "-1" ) ; return ; } let last_pos = Array ( 26 ) . fill ( - 1 ) ; for ( let i = n - 1 ; i >= 0 ; -- i ) { if ( last_pos [ s [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] == - 1 ) { last_pos [ s [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] = i ; } } let minp = - 1 , plen = 0 ; for ( let i = 0 ; i < n ; ++ i ) { let lp = last_pos [ s [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ; minp = Math . max ( minp , lp ) ; ++ plen ; if ( i == minp ) { ans . push ( plen ) ; minp = - 1 ; plen = 0 ; } } for ( let i = 0 ; i < ans . length ; i ++ ) { document . write ( ans [ i ] + "▁" ) ; } }
function lenghtOfLongestAP ( A , n ) { var dp = new Map ( ) ; var res = 2 ; for ( var i = 0 ; i < n ; ++ i ) { for ( var j = i + 1 ; j < n ; ++ j ) { var d = A [ j ] - A [ i ] ; if ( dp . has ( d ) ) { if ( dp . get ( d ) . has ( i ) ) { var tmp = dp . get ( d ) ; tmp . set ( j , dp . get ( d ) . get ( i ) + 1 ) ; } else { var tmp = new Map ( ) ; tmp . set ( j , 2 ) ; dp . set ( d , tmp ) ; } } else { var tmp = new Map ( ) ; tmp . set ( j , 2 ) ; dp . set ( d , tmp ) ; } res = Math . max ( res , dp . get ( d ) . get ( j ) ) ; } } return res ; }
function numDifferenceUtil ( N , K ) { let res = [ ] ; res = numDifference ( N , K ) ; for ( let i = 0 ; i < res . length ; i ++ ) { document . write ( res [ i ] + "▁" ) ; } }
function minFirstTerm ( X , diff , N ) { let first_term = Number . MAX_VALUE ; let low = 0 , high = N ; while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( X - mid * diff > 0 ) { first_term = X - mid * diff ; low = mid + 1 ; } else high = mid - 1 ; } return first_term ; }
function isCubeSum ( n ) { for ( var i = 1 ; i * i * i <= n ; i ++ ) { if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) return true ; } return false ; }
function isSumCube ( N ) { var a = parseInt ( Math . cbrt ( N ) ) ; var b = a - 1 ; return ( ( a * a * a + b * b * b ) == N ) ; }
function maxweight ( s , e , pre ) { if ( s == e ) return 0 ; let ans = 0 ; for ( let i = s ; i < e ; i ++ ) { if ( ! pre [ i ] ) pre [ i ] = 0 ; if ( ! pre [ e ] ) pre [ e ] = 0 ; if ( ! pre [ s - 1 ] ) pre [ s - 1 ] = 0 ; let left = pre [ i ] - pre [ s - 1 ] ; let right = pre [ e ] - pre [ i ] ; if ( left < right ) ans = Math . max ( ans , left + maxweight ( s , i , pre ) ) ; if ( left == right ) { ans = Math . max ( ans , Math . max ( left + maxweight ( s , i , pre ) , right + maxweight ( i + 1 , e , pre ) ) ) ; } if ( left > right ) ans = Math . max ( ans , right + maxweight ( i + 1 , e , pre ) ) ; } return ans ; }
function maxSum ( arr ) { let pre = new Map ; pre [ - 1 ] = 0 ; pre [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < arr . length ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } document . write ( maxweight ( 0 , arr . length - 1 , pre ) ) ; }
function SieveOfEratosthenes ( prime , p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
function LISPrime ( arr , n ) { let lisp = new Array ( n ) ; let prime = new Array ( N + 1 ) ; prime . fill ( true ) ; SieveOfEratosthenes ( prime , N ) ; lisp [ 0 ] = prime [ arr [ 0 ] ] ? 1 : 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( ! prime [ arr [ i ] ] ) { lisp [ i ] = 0 ; continue ; } lisp [ i ] = 1 ; for ( let j = 0 ; j < i ; j ++ ) { if ( prime [ arr [ j ] ] && arr [ i ] > arr [ j ] && lisp [ i ] < lisp [ j ] + 1 ) { lisp [ i ] = lisp [ j ] + 1 ; } } } return lisp . sort ( ( a , b ) => b - a ) [ 0 ] ; }
function checkSumOfNatural ( n ) { var i = 1 ; var flag = false ; while ( i * ( i + 1 ) < n * 2 ) { var X = i * ( i + 1 ) ; var t = n * 2 - X ; var k = parseInt ( Math . sqrt ( t ) ) ; if ( k * ( k + 1 ) == t ) { flag = true ; break ; } i += 1 ; } if ( flag ) document . write ( "YES" ) ; else document . write ( "NO" ) ; }
function countNumEnds ( A , L , R ) { let temp = 0 , count = 0 , digits = 0 ; let cycle = 0 ; digits = Math . round ( Math . log10 ( A ) ) + 1 ; temp = Math . round ( Math . pow ( 10 , digits ) ) ; cycle = temp ; while ( temp <= R ) { if ( temp >= L ) count ++ ; temp += cycle ; } document . write ( count ) ; }
function minOperations ( s ) { var len = s . length ; var result = 0 ; for ( var i = 0 ; i < len / 2 ; i ++ ) { var D1 = Math . max ( s [ i ] . charCodeAt ( 0 ) , s [ len - 1 - i ] . charCodeAt ( 0 ) ) - Math . min ( s [ i ] . charCodeAt ( 0 ) , s [ len - 1 - i ] . charCodeAt ( 0 ) ) ; var D2 = 26 - D1 ; result += Math . min ( D1 , D2 ) ; } return result ; }
function countMaximum ( a , n ) { a . sort ( ) ; a . reverse ( ) ; let count = 0 ; let mark = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( ( a [ i ] + n >= mark ) ) { count += 1 ; } mark = Math . max ( mark , a [ i ] + i + 1 ) ; } document . write ( count ) ; }
function allCoprime ( A , n ) { var all_coprime = true ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { if ( gcd ( A [ i ] , A [ j ] ) != 1 ) { all_coprime = false ; break ; } } } return all_coprime ; }
function binomialCoeff ( n , k ) { let res = 1 ; if ( k > n - k ) k = n - k ; for ( let i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
function catalan ( n ) { let c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
function findWays ( n ) { if ( n & 1 ) return 0 ; return catalan ( n / 2 ) ; }
function countNonNPeriodic ( N ) { document . write ( findWays ( 2 * N ) - findWays ( N ) ) ; }
function isValid ( n , m , k ) { var step2 = n - m ; var cnt = parseInt ( ( step2 * ( step2 + 1 ) ) / 2 ) ; if ( cnt - m == k ) return 0 ; if ( cnt - m > k ) return 1 ; return - 1 ; }
function countOfOperations ( n , k ) { var start = 0 , end = n ; var ok = 1 ; while ( start <= end ) { var mid = parseInt ( ( start + end ) / 2 ) ; var temp = isValid ( n , mid , k ) ; if ( temp == 0 ) { ok = 0 ; document . write ( mid ) ; break ; } else if ( temp == 1 ) { start = mid + 1 ; } else { end = mid - 1 ; } } if ( ok ) document . write ( "-1" ) ; }
function nonLower ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) { if ( ! ( s [ i ] . charCodeAt ( ) >= 97 && s [ i ] . charCodeAt ( ) <= 122 ) ) { return true ; } } return false ; }
function getChar ( n ) { return String . fromCharCode ( n + 96 ) ; }
function getCode ( str ) { if ( str . length == 0 ) { let ans = [ "" ] ; return ans ; } let output1 = getCode ( str . substring ( 1 ) ) ; let output2 = new Array ( 0 ) ; let firstDigit = ( str [ 0 ] - "0" ) ; let firstTwoDigit = 0 ; if ( str . length >= 2 ) { firstTwoDigit = ( str [ 0 ] . charCodeAt ( ) - "0" . charCodeAt ( ) ) * 10 + ( str [ 1 ] . charCodeAt ( ) - "0" . charCodeAt ( ) ) ; if ( firstTwoDigit >= 10 && firstTwoDigit <= 26 ) { output2 = getCode ( str . substring ( 2 ) ) ; } } let output = new Array ( output1 . length + output2 . length ) ; let k = 0 ; for ( let i = 0 ; i < output1 . length ; i ++ ) { let ch = getChar ( firstDigit ) ; output [ i ] = ch + output1 [ i ] ; k ++ ; } for ( let i = 0 ; i < output2 . length ; i ++ ) { let ch = getChar ( firstTwoDigit ) ; output [ k ] = ch + output2 [ i ] ; k ++ ; } return output ; }
function smallestNum ( n ) { let power = log2 ( 10 ) ; return Math . ceil ( ( n - 1 ) * power ) ; }
function countSubSequence ( arr , n ) { let maximum = Math . max ( ... arr ) ; let minimum = Math . min ( ... arr ) ; if ( maximum == minimum ) return Math . pow ( 2 , n ) - 1 ; let i = count ( arr , maximum ) ; let j = count ( arr , minimum ) ; let res = ( Math . pow ( 2 , i ) - 1 ) * ( Math . pow ( 2 , j ) - 1 ) * Math . pow ( 2 , n - i - j ) ; return res ; }
function transformSubsequence ( n , m , A , B ) { if ( B . length == 0 ) return n ; var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < n + 1 ; i ++ ) { for ( var j = 0 ; j < m + 1 ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 0 ; else if ( A [ i - 1 ] == B [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return n - dp [ n ] [ m ] ; }
function SieveOfEratosthenes ( ) { isPrime . fill ( true ) ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( let i = p * p ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } for ( let p = 2 ; p <= MAX ; p ++ ) if ( isPrime [ p ] ) primes . push ( p ) ; }
function prime_search ( primes , diff ) { let low = 0 ; let high = primes . length - 1 ; let res = 0 ; while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( primes [ mid ] == diff ) { return primes [ mid ] ; } else if ( primes [ mid ] < diff ) { low = mid + 1 ; } else { res = primes [ mid ] ; high = mid - 1 ; } } return res ; }
function minCost ( arr , n ) { SieveOfEratosthenes ( ) ; let res = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { let diff = arr [ i - 1 ] - arr [ i ] ; let closest_prime = prime_search ( primes , diff ) ; res += closest_prime ; arr [ i ] += closest_prime ; } } return res ; }
function isprm ( n ) { if ( n <= 1 ) return 0 ; if ( n <= 3 ) return 1 ; if ( n % 2 == 0 n % 3 == 0 ) return 0 ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return 0 ; } return 1 ; }
function countprime ( n ) { var count = 0 ; var primevector = [ ] ; for ( var i = 2 ; i <= n ; i ++ ) { if ( isprm ( i ) == 1 ) { primevector . push ( i ) ; } } var sum = primevector [ 0 ] ; for ( var i = 1 ; i < primevector . length ; i ++ ) { sum += primevector [ i ] ; if ( sum > n ) break ; if ( isprm ( sum ) == 1 ) { count ++ ; } } return count ; }
function addEdge ( v , x , y ) { v [ x ] . push ( y ) ; v [ y ] . push ( x ) ; }
function dfs ( tree , temp , ancestor , u , parent , k ) { temp . push ( u ) ; for ( let i = 0 ; i < tree [ u ] . length ; i ++ ) { if ( tree [ u ] [ i ] == parent ) continue ; dfs ( tree , temp , ancestor , tree [ u ] [ i ] , u , k ) ; } temp . pop ( ) ; if ( temp . length < k ) { ancestor [ u ] = - 1 ; } else { ancestor [ u ] = temp [ temp . length - k ] ; } }
function KthAncestor ( N , K , E , edges ) { let tree = new Array ( N + 1 ) ; for ( let i = 0 ; i < tree . length ; i ++ ) tree [ i ] = [ ] ; for ( let i = 0 ; i < E ; i ++ ) { addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; } let temp = [ ] ; let ancestor = new Array ( N + 1 ) ; dfs ( tree , temp , ancestor , 1 , 0 , K ) ; for ( let i = 1 ; i <= N ; i ++ ) { document . write ( ancestor [ i ] + "▁" ) ; } }
function dfs ( root , distance ) { if ( root == null ) { let arr = new Array ( distance + 1 ) ; arr . fill ( 0 ) ; return arr ; } if ( root . left == null && root . right == null ) { let res = new Array ( distance + 1 ) ; res . fill ( 0 ) ; res [ 1 ] ++ ; return res ; } let left = dfs ( root . left , distance ) ; let right = dfs ( root . right , distance ) ; let res = new Array ( distance + 1 ) ; res . fill ( 0 ) ; for ( let i = res . length - 2 ; i >= 1 ; i -- ) { res [ i + 1 ] = left [ i ] + right [ i ] ; } for ( let l = 1 ; l < left . length ; l ++ ) { for ( let r = 0 ; r < right . length ; r ++ ) { if ( l + r <= distance ) { result += left [ l ] * right [ r ] ; } } } return res ; }
function build ( sum , a , l , r , rt ) { if ( l == r ) { sum [ rt ] = a [ l - 1 ] ; return ; } let m = ( l + r ) >> 1 ; build ( sum , a , l , m , rt << 1 ) ; build ( sum , a , m + 1 , r , rt << 1 1 ) ; }
function pushDown ( sum , add , rt , ln , rn ) { if ( add [ rt ] != 0 ) { add [ rt << 1 ] = add [ rt ] ; add [ rt << 1 1 ] = add [ rt ] ; sum [ rt << 1 ] = sum [ rt << 1 ] + add [ rt ] * ln ; sum [ rt << 1 1 ] = sum [ rt << 1 1 ] + add [ rt ] * rn ; add [ rt ] = 0 ; } }
function update ( sum , add , L , R , C , l , r , rt ) { if ( L <= l && r <= R ) { sum [ rt ] = sum [ rt ] + C * ( r - l + 1 ) ; add [ rt ] = add [ rt ] + C ; return ; } let m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; if ( L <= m ) { update ( sum , add , L , R , C , l , m , rt << 1 ) ; } if ( R > m ) { update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) ; } }
function sequenceMaintenance ( n , q , a , b , m ) { a . sort ( function ( a , b ) { return a - b ; } ) ; let sum = [ ] ; let ad = [ ] ; let ans = [ ] ; for ( let i = 0 ; i < ( n << 2 ) ; i ++ ) { sum . push ( 0 ) ; ad . push ( 0 ) ; } build ( sum , a , 1 , n , 1 ) ; for ( let i = 0 ; i < q ; i ++ ) { let l = 1 , r = n , pos = - 1 ; while ( l <= r ) { m = ( l + r ) >> 1 ; if ( query ( sum , ad , m , m , 1 , n , 1 ) >= b [ i ] ) { r = m - 1 ; pos = m ; } else { l = m + 1 ; } } if ( pos == - 1 ) { ans . push ( 0 ) ; } else { ans . push ( n - pos + 1 ) ; update ( sum , ad , pos , n , - m , 1 , n , 1 ) ; } } for ( let i = 0 ; i < ans . length ; i ++ ) { document . write ( ans [ i ] + "▁" ) ; } }
function MaximumPath ( grid ) { let N = grid . length ; let M = grid [ 0 ] . length ; let sum = new Array ( N + 1 ) ; for ( var i = 0 ; i < sum . length ; i ++ ) { sum [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < sum . length ; i ++ ) { for ( var j = 0 ; j < sum . length ; j ++ ) { sum [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 1 ; j <= M ; j ++ ) { sum [ i ] [ j ] = Math . max ( sum [ i - 1 ] [ j ] , sum [ i ] [ j - 1 ] ) + grid [ i - 1 ] [ j - 1 ] ; } } return sum [ N ] [ M ] ; }
function SubarrayHavingPerfectSquare ( arr , k ) { var ans = [ ] ; var sum = 0 , i ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } var found = false ; if ( isPerfectSquare ( sum ) ) { ans [ 0 ] = 0 ; ans [ 1 ] = i - 1 ; } else { for ( var j = i ; j < arr . length ; j ++ ) { sum = sum + arr [ j ] - arr [ j - k ] ; if ( isPerfectSquare ( sum ) ) { found = true ; ans [ 0 ] = j - k + 1 ; ans [ 1 ] = j ; } } for ( var k = ans [ 0 ] ; k <= ans [ 1 ] ; k ++ ) { document . write ( arr [ k ] + "▁" ) ; } } if ( found == false ) { document . write ( "-1" ) ; } }
function calcSubarray ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { let flag = true ; let comm_diff = A [ i + 1 ] - A [ i ] ; for ( let k = i ; k < j ; k ++ ) { if ( A [ k + 1 ] - A [ k ] == comm_diff ) { continue ; } else { flag = false ; break ; } } if ( flag ) { count ++ ; } } } return count ; }
function findKthChar ( n , k ) { let prev = "A" ; let cur = "" ; if ( n == 1 ) { return "A" ; } for ( let j = 2 ; j <= n ; j ++ ) { cur = prev + "B" ; for ( let i = 0 ; i < prev . length ; i ++ ) { if ( prev [ i ] == "A" ) { prev [ prev [ i ] ] = "B" ; } else { prev [ prev [ i ] ] = "A" ; } } prev = reverse ( prev ) ; cur += prev ; prev = cur ; } return cur [ k ] ; }
function areAnagrams ( a , b ) { var freqA = Array ( TEN ) . fill ( 0 ) ; var freqB = Array ( TEN ) . fill ( 0 ) ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( var i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; }
function isPowerOf2 ( N ) { for ( var i = 0 ; i < 32 ; i ++ ) { if ( areAnagrams ( 1 << i , N ) ) { document . write ( ( 1 << i ) ) ; return true ; } } return false ; }
function right_angled ( n ) { var count = 0 ; for ( z = 1 ; z <= n ; z ++ ) { for ( y = 1 ; y <= z ; y ++ ) { for ( x = 1 ; x <= y ; x ++ ) { if ( ( x * x ) + ( y * y ) == ( z * z ) ) { count ++ ; } } } } return count ; }
function mirrorMatrix ( mat1 , mat2 , N ) { let row = 0 ; let col = 0 ; let isMirrorImage = true ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = N - 1 ; j >= 0 ; j -- ) { if ( mat2 [ row ] [ col ] != mat1 [ i ] [ j ] ) { isMirrorImage = false ; } col ++ ; } col = 0 ; row ++ ; } if ( isMirrorImage ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function maxAbsDiffLevelSum ( N , M , cost , Edges ) { let adj = new Array ( N ) ; for ( let i = 0 ; i < adj . length ; i ++ ) adj [ i ] = [ ] ; for ( let i = 0 ; i < M ; i ++ ) { let u = Edges [ i ] [ 0 ] ; let v = Edges [ i ] [ 1 ] ; adj [ u ] . push ( v ) ; } let maxSum = cost [ 0 ] , minSum = cost [ 0 ] ; let q = [ ] ; q . push ( 0 ) ; while ( q . length != 0 ) { let count = q . length ; let sum = 0 ; while ( count -- > 0 ) { let temp = q [ 0 ] ; q . shift ( ) ; sum = sum + cost [ temp ] ; for ( let i = 0 ; i < adj [ temp ] . length ; i ++ ) { q . push ( adj [ temp ] [ i ] ) ; } } maxSum = Math . max ( sum , maxSum ) ; minSum = Math . min ( sum , minSum ) ; } document . write ( Math . abs ( maxSum - minSum ) ) ; }
function dfs ( src , dest , vis , adj ) { vis [ src ] = 1 ; if ( src == dest ) { return 1 ; } for ( let u = 0 ; u < adj [ src ] . length ; u ++ ) { if ( vis [ adj [ src ] [ u ] ] == 0 ) { let temp = dfs ( adj [ src ] [ u ] , dest , vis , adj ) ; if ( temp != 0 ) { return temp + 1 ; } } } return 0 ; }
function countMagicNumbers ( idx , sum , a , n , m , l , r ) { if ( idx == n ) { let temp = sum % m ; if ( temp == l || temp == r || ( temp > l && temp < r ) ) return dp [ [ idx , sum ] ] = 1 ; else return dp [ [ idx , sum ] ] = 0 ; } let curr = [ idx , sum ] ; if ( dp . has ( curr ) ) return dp [ curr ] ; let ls = countMagicNumbers ( idx + 1 , sum + a [ idx ] , a , n , m , l , r ) ; let rs = countMagicNumbers ( idx + 1 , sum + ( a [ idx ] - 1 ) , a , n , m , l , r ) ; let temp1 = Math . max ( ls , rs ) ; let temp = sum % m ; if ( ( temp == l || temp == r || ( temp > l && temp < r ) ) && idx != 0 ) { temp1 += 1 ; } dp [ [ idx , sum ] ] = temp1 ; return dp [ [ idx , sum ] ] ; }
function count_numbers ( L , R ) { let ans = 0 ; for ( let n = L ; n <= R ; n ++ ) { let no_of_bits = Math . floor ( Math . log ( n ) + 1 ) ; let no_of_set_bits = bitCount ( n ) ; if ( no_of_bits - no_of_set_bits == 1 ) { ans ++ ; } } return ans ; }
function check ( s , k ) { let n = s . length ; for ( let i = 0 ; i < k ; i ++ ) { for ( let j = i ; j < n ; j += k ) { if ( s [ i ] != s [ j ] ) return false ; } } let c = 0 ; for ( let i = 0 ; i < k ; i ++ ) { if ( s [ i ] == "0" ) c ++ ; else c -- ; } if ( c == 0 ) return true ; else return false ; }
function findSum ( s ) { let sum = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { for ( let j = i + 1 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { sum += ( j - i ) ; } } } return sum ; }
function countElements ( a , n ) { var cnt = Array ( n + 1 ) . fill ( 0 ) ; var ans = 0 ; for ( k = 0 ; k < n ; k ++ ) { cnt [ a [ k ] ] ++ ; } for ( l = 0 ; l < n ; ++ l ) { var sum = 0 ; for ( r = l ; r < n ; ++ r ) { sum += a [ r ] ; if ( l == r ) continue ; if ( sum <= n ) { ans += cnt [ sum ] ; cnt [ sum ] = 0 ; } } } return ans ; }
function maxGCD ( n ) { var maxHcf = Number . MIN_VALUE ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = i + 1 ; j <= n ; j ++ ) { maxHcf = Math . max ( maxHcf , __gcd ( i , j ) ) ; } } return maxHcf ; }
function addEdge ( a , b ) { tree [ a ] . push ( b ) ; tree [ b ] . push ( a ) ; }
function dfs ( x ) { vis [ x ] = true ; subtreeSize [ x ] = 1 ; tree [ x ] . forEach ( i => { if ( ! vis [ i ] ) { dfs ( i ) ; subtreeSize [ x ] += subtreeSize [ i ] ; } } ) ; }
function matrixMinimum ( nums , K ) { let N = nums . length ; let M = nums [ 0 ] . length ; let res = new Array ( N - K + 1 ) ; for ( var i = 0 ; i < res . length ; i ++ ) { res [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M - K + 1 ; j ++ ) { let min = Number . MAX_VALUE ; for ( let k = j ; k < j + K ; k ++ ) { min = Math . min ( min , nums [ i ] [ k ] ) ; } nums [ i ] [ j ] = min ; } } for ( let j = 0 ; j < M ; j ++ ) { for ( let i = 0 ; i < N - K + 1 ; i ++ ) { let min = Number . MAX_VALUE ; for ( let k = i ; k < i + K ; k ++ ) { min = Math . min ( min , nums [ k ] [ j ] ) ; } nums [ i ] [ j ] = min ; } } for ( let i = 0 ; i < N - K + 1 ; i ++ ) for ( let j = 0 ; j < M - K + 1 ; j ++ ) res [ i ] [ j ] = nums [ i ] [ j ] ; return res ; }
function uncrossedLines ( a , b , n , m ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j < ( m + 1 ) ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= m ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 0 ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ n ] [ m ] ; }
function find_kth_largest ( str , k ) { str . sort ( ) ; reverse ( str ) ; return str [ k - 1 ] ; }
function updateString ( str , pos , s ) { let index = pos - 1 ; let c = s ; str [ index ] = c ; }
function update_BITree ( index , C , val ) { while ( index <= N ) { BITree [ C . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] [ index ] += val ; index += ( index & - index ) ; } }
function sum_BITree ( index , C ) { let s = 0 ; while ( index > 0 ) { s += BITree [ C . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] [ index ] ; index -= ( index & - index ) ; } return s ; }
function revNum ( N ) { var x = 0 ; while ( N ) { x = x * 10 + ( N % 10 ) ; N = N / 10 ; } return x ; }
function ctNonPalin ( arr , N ) { var Res = 0 ; for ( var i = 0 ; i < N ; i ++ ) { var x = revNum ( arr [ i ] ) ; if ( x == arr [ i ] ) { continue ; } else { Res += arr [ i ] % 10 == N % 10 ; } } return Res ; }
function smallSumSubset ( data , target , maxVal ) { let sum = 0 ; for ( let i = 0 ; i < data . length ; i ++ ) sum += data [ i ] ; if ( target <= 0 ) return 0 ; else if ( sum < target ) return maxVal ; else if ( sum == target ) return data . length ; else if ( data [ 0 ] >= target ) return 1 ; else if ( data [ 0 ] < target ) { let temp = [ ] ; for ( let i = 1 ; i < data . length ; i ++ ) temp . push ( data [ i ] ) ; return Math . min ( smallSumSubset ( temp , target , maxVal ) , 1 + smallSumSubset ( temp , target - data [ 0 ] , maxVal ) ) ; } }
function minlt ( arr , target , n ) { var dp = Array . from ( Array ( arr . length + 1 ) , ( ) => Array ( target + 1 ) . fill ( - 1 ) ) ; for ( var i = 0 ; i < arr . length + 1 ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( var j = 0 ; j < target + 1 ; j ++ ) dp [ 0 ] [ j ] = 1000000000 ; for ( var i = 1 ; i <= arr . length ; i ++ ) { for ( var j = 1 ; j <= target ; j ++ ) { if ( arr [ i - 1 ] > j ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j ] , ( dp [ i ] [ j - arr [ i - 1 ] ] ) != 1000000000 ? ( dp [ i ] [ j - arr [ i - 1 ] ] + 1 ) : 1000000000 ) ; } } } if ( dp [ arr . length ] [ target ] == 1000000000 ) { return - 1 ; } else { return dp [ arr . length ] [ target ] ; } }
function GCD ( a , b ) { if ( a == 0 ) return b ; return GCD ( b % a , a ) ; }
function LCM ( a , b ) { return ( a * b ) / GCD ( a , b ) ; }
function checkPairwiseCoPrime ( A , n ) { var prod = 1 ; var lcm = 1 ; for ( i = 0 ; i < n ; i ++ ) { prod *= A [ i ] ; lcm = LCM ( A [ i ] , lcm ) ; } if ( prod == lcm ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function minDiffSubArray ( arr , n ) { let prefix_sum = new Array ( n ) ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; let suffix_sum = new Array ( n ) ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; let minDiff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let diff = Math . abs ( prefix_sum [ i ] - suffix_sum [ i + 1 ] ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
function minDiffSubArray ( arr , n ) { var total_sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) total_sum += arr [ i ] ; var prefix_sum = 0 ; var minDiff = 1000000000 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { prefix_sum += arr [ i ] ; var diff = Math . abs ( ( total_sum - prefix_sum ) - prefix_sum ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
function maxLenSub ( arr , N ) { var Pos = 0 ; var Neg = 0 ; var res = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { Pos = Neg = 0 ; } else if ( arr [ i ] > 0 ) { Pos += 1 ; if ( Neg != 0 ) { Neg += 1 ; } res = Math . max ( res , Pos ) ; } else { [ Pos , Neg ] = [ Neg , Pos ] ; Neg += 1 ; if ( Pos != 0 ) { Pos += 1 ; } res = Math . max ( res , Pos ) ; } } return res ; }
function maxStrings ( arr , len ) { let N = arr . length ; let ans = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { if ( len == arr [ i ] . length ) { ans . push ( arr [ i ] ) ; } } for ( let i = 0 ; i < ans . length ; i ++ ) { document . write ( ans [ i ] + "▁" ) ; } }
function printStrings ( arr ) { let max = maxLength ( arr ) ; maxStrings ( arr , max ) ; }
function addEdge ( u , v ) { vec [ u ] . push ( v ) ; vec [ v ] . push ( u ) ; }
function swapXandY ( str , X , Y ) { let N = str . length ; X = X + Y ; Y = X - Y ; X = X - Y ; for ( let i = 0 ; i < N ; i ++ ) { if ( str [ i ] == "p" ) { str [ i ] = "r" ; } else if ( str [ i ] == "r" ) { str [ i ] = "p" ; } } return true ; }
function canTransform ( str1 , str2 ) { var s1 = "" ; var s2 = "" ; for ( const c of str1 ) { if ( c !== "C" ) { s1 += c ; } } for ( const c of str2 ) { if ( c !== "C" ) { s2 += c ; } } if ( s1 !== s2 ) return false ; var i = 0 ; var j = 0 ; var n = str1 . length ; while ( i < n && j < n ) { if ( str1 [ i ] === "C" ) { i ++ ; } else if ( str2 [ j ] === "C" ) { j ++ ; } else { if ( ( str1 [ i ] === "A" && i < j ) || ( str1 [ i ] === "B" && i > j ) ) { return false ; } i ++ ; j ++ ; } } return true ; }
function dailyTemperatures ( T ) { var n = T . length ; var daysOfWait = Array ( n ) . fill ( - 1 ) ; var s = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { while ( s . length != 0 && T [ s [ s . length - 1 ] ] < T [ i ] ) { daysOfWait [ s [ s . length - 1 ] ] = i - s [ s . length - 1 ] ; s . pop ( ) ; } s . push ( i ) ; } for ( var i = 0 ; i < n ; i ++ ) { document . write ( daysOfWait [ i ] + "▁" ) ; } }
function CtSubarr ( arr , N , K ) { var st = new Set ( ) ; var prefixSum = 0 ; st . add ( prefixSum ) ; var res = 0 ; for ( var i = 0 ; i < N ; i ++ ) { prefixSum += arr [ i ] ; if ( st . has ( prefixSum - K ) ) { res += 1 ; prefixSum = 0 ; st = new Set ( ) ; st . add ( 0 ) ; } st . add ( prefixSum ) ; } return res ; }
function getMaxLength ( arr , N ) { let res = 2 ; let dist = 2 ; let curradj = ( arr [ 1 ] - arr [ 0 ] ) ; let prevadj = ( arr [ 1 ] - arr [ 0 ] ) ; for ( let i = 2 ; i < N ; i ++ ) { curradj = arr [ i ] - arr [ i - 1 ] ; if ( curradj == prevadj ) { dist ++ ; } else { prevadj = curradj ; res = Math . max ( res , dist ) ; dist = 2 ; } } res = Math . max ( res , dist ) ; return res ; }
function func ( a , b , c , x ) { return a * x * x + b * x + c ; }
function findRoot ( a , b , c , low , high ) { let x = - 1 ; while ( Math . abs ( high - low ) > eps ) { x = ( low + high ) / 2 ; if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) { high = x ; } else { low = x ; } } return x ; }
function minSteps ( str , N ) { var smaller , cost = 0 ; var f = new Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < N ; i ++ ) { var curr_ele = str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ; smaller = 0 ; for ( var j = 0 ; j <= curr_ele ; j ++ ) { if ( f [ j ] !== 0 ) smaller += f [ j ] ; } if ( smaller === 0 ) cost += i + 1 ; else cost += i - smaller + 1 ; f [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } return cost ; }
function dfs ( u , p , dis , vis , distance , parent , preTime , postTime , Adj ) { distance [ u ] = dis ; parent [ u ] = p ; vis [ u ] = 1 ; timeT ++ ; preTime [ u ] = timeT ; for ( let i = 0 ; i < Adj [ u ] . length ; i ++ ) { if ( vis [ Adj [ u ] [ i ] ] == 0 ) { dfs ( Adj [ u ] [ i ] , u , dis + 1 , vis , distance , parent , preTime , postTime , Adj ) ; } } timeT ++ ; postTime [ u ] = timeT ; }
function addEdge ( Adj , u , v ) { Adj [ u ] . push ( v ) ; Adj [ v ] . push ( u ) ; }
function findNodeU ( N , V , Vertices , Edges ) { let vis = new Array ( N + 1 ) ; vis . fill ( 0 ) ; let distance = new Array ( N + 1 ) ; distance . fill ( 0 ) ; let parent = new Array ( N + 1 ) ; parent . fill ( 0 ) ; let preTime = new Array ( N + 1 ) ; preTime . fill ( 0 ) ; let postTime = new Array ( N + 1 ) ; postTime . fill ( 0 ) ; let Adj = [ ] ; for ( let i = 0 ; i < N + 1 ; i ++ ) Adj . push ( [ ] ) ; let u = 0 , v ; for ( let i = 0 ; i < N - 1 ; i ++ ) { addEdge ( Adj , Edges [ i ] [ 0 ] , Edges [ i ] [ 1 ] ) ; } dfs ( 1 , 0 , 0 , vis , distance , parent , preTime , postTime , Adj ) ; let maximumDistance = 0 ; maximumDistance = 0 ; for ( let k = 0 ; k < V ; k ++ ) { if ( maximumDistance < distance [ Vertices [ k ] ] ) { maximumDistance = distance [ Vertices [ k ] ] ; u = Vertices [ k ] ; } if ( parent [ Vertices [ k ] ] != 0 ) { Vertices [ k ] = parent [ Vertices [ k ] ] ; } } let ans = true ; let flag ; for ( let k = 0 ; k < V ; k ++ ) { if ( preTime [ Vertices [ k ] ] <= preTime [ u ] && postTime [ Vertices [ k ] ] >= postTime [ u ] ) flag = true ; else flag = false ; ans = ans & flag ; } if ( ans ) document . write ( u ) ; else document . write ( "NO" ) ; }
function countRectangles ( a , b , K ) { let n = a . length ; let m = b . length ; let subA = findSubarrays ( a ) ; let subB = findSubarrays ( b ) ; let total = 0 ; for ( let i = 1 ; i < subA . length ; i ++ ) { if ( K % i == 0 && ( K / i ) <= m ) { total = total + subA [ i ] * subB [ K / i ] ; } } document . write ( total ) ; }
function addedge ( a , b ) { edges [ a ] . push ( b ) ; edges [ b ] . push ( a ) ; }
function findCost ( r , p , arr ) { let i , cur ; for ( i = 0 ; i < edges [ r ] . length ; i ++ ) { cur = edges [ r ] [ i ] ; if ( cur == p ) continue ; findCost ( cur , r , arr ) ; arr [ r ] += arr [ cur ] ; } let t1 = arr [ r ] ; let t2 = allsum - t1 ; if ( t1 * t2 > ans ) { ans = t1 * t2 ; } }
function maximumCost ( r , p , N , M , arr , Edges ) { for ( let i = 0 ; i < N ; i ++ ) { allsum += arr [ i ] ; } for ( let i = 0 ; i < M ; i ++ ) { addedge ( Edges [ i ] [ 0 ] , Edges [ i ] [ 1 ] ) ; } findCost ( r , p , arr ) ; }
function printRes ( res ) { var n = res . length ; for ( var i = 0 ; i < n ; i ++ ) { document . write ( res [ i ] + "▁" ) ; } }
function printLBS ( arr , N ) { var lis = Array ( N ) ; var lds = Array ( N ) ; for ( var i = 0 ; i < N ; i ++ ) { lis [ i ] = lds [ i ] = 1 ; } for ( var i = 0 ; i < N ; i ++ ) { for ( var j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { if ( lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } } for ( var i = N - 1 ; i >= 0 ; i -- ) { for ( var j = N - 1 ; j > i ; j -- ) { if ( arr [ j ] < arr [ i ] ) { if ( lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; } } } var MaxVal = arr [ 0 ] , inx = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( MaxVal < lis [ i ] + lds [ i ] - 1 ) { MaxVal = lis [ i ] + lds [ i ] - 1 ; inx = i ; } } var ct1 = lis [ inx ] ; var res = [ ] ; for ( var i = inx ; i >= 0 && ct1 > 0 ; i -- ) { if ( lis [ i ] == ct1 ) { res . push ( arr [ i ] ) ; ct1 -- ; } } res . reverse ( ) ; var ct2 = lds [ inx ] - 1 ; for ( var i = inx ; i < N && ct2 > 0 ; i ++ ) { if ( lds [ i ] == ct2 ) { res . push ( arr [ i ] ) ; ct2 -- ; } } printRes ( res ) ; }
function dfs ( current_node , prev_node , len , add_to_map , adj ) { if ( len > diameter ) { diameter = len ; X = current_node ; } if ( add_to_map && len == diameter ) { mp . set ( current_node , true ) ; } for ( let it = 0 ; it < adj [ current_node ] . length ; it ++ ) { if ( adj [ current_node ] [ it ] != prev_node ) dfs ( adj [ current_node ] [ it ] , current_node , len + 1 , add_to_map , adj ) ; } }
function dfsUtility ( adj ) { dfs ( 1 , - 1 , 0 , false , adj ) ; let farthest_node = X ; dfs ( farthest_node , - 1 , 0 , false , adj ) ; dfs ( farthest_node , - 1 , 0 , true , adj ) ; dfs ( X , - 1 , 0 , true , adj ) ; }
function printDiameters ( adj ) { dfsUtility ( adj ) ; for ( let i = 1 ; i <= 6 ; i ++ ) { if ( mp . has ( i ) && mp . get ( i ) == true ) document . write ( diameter + 1 + ",▁" ) ; else document . write ( diameter + ",▁" ) ; } }
function is_prime ( n ) { if ( n <= 1 ) return 0 ; for ( var i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return 0 ; } return 1 ; }
function count_prime_subarrays ( ar , n ) { var ans = 0 ; var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( is_prime ( ar [ i ] ) ) count ++ ; else { if ( count ) { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } } if ( count ) ans += ( count * ( count + 1 ) ) / 2 ; return ans ; }
function hasCoprimePair ( arr , n ) { for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( __gcd ( arr [ i ] , arr [ j ] ) ) == 1 ) { return true ; } } } return false ; }
function check ( ans , s , n , m ) { for ( var i = 1 ; i < n ; ++ i ) { var count = 0 ; for ( var j = 0 ; j < m ; ++ j ) { if ( ans [ j ] !== s [ i ] [ j ] ) count ++ ; } if ( count > 1 ) return false ; } return true ; }
function possible ( T , arr , n , d ) { let partition = 1 ; let total = 0 ; for ( let i = 0 ; i < n ; i ++ ) { total = total + arr [ i ] ; if ( total > T ) { partition = partition + 1 ; total = arr [ i ] ; if ( partition > d ) { return false ; } } } return true ; }
function calcT ( n , d , arr ) { let mx = - 1 , sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { mx = Math . max ( mx , arr [ i ] ) ; sum = sum + arr [ i ] ; } let lb = mx ; let ub = sum ; while ( lb < ub ) { let T_mid = lb + ( ub - lb ) / 2 ; if ( possible ( T_mid , arr , n , d ) == true ) { ub = T_mid ; } else { lb = T_mid + 1 ; } } document . write ( lb ) ; }
function minReqSubstring ( s , n ) { let ongoing = "N" ; let count = 0 , l = s . length ; for ( let i = 1 ; i < l ; i ++ ) { if ( ongoing == "N" ) { if ( s [ i ] < s [ i - 1 ] ) { ongoing = "D" ; } else if ( s [ i ] == s [ i - 1 ] ) { ongoing = "N" ; } else { ongoing = "I" ; } } else if ( ongoing == "I" ) { if ( s [ i ] > s [ i - 1 ] ) { ongoing = "I" ; } else if ( s [ i ] == s [ i - 1 ] ) { ongoing = "I" ; } else { ongoing = "N" ; count += 1 ; } } else { if ( s [ i ] < s [ i - 1 ] ) { ongoing = "D" ; } else if ( s [ i ] == s [ i - 1 ] ) { ongoing = "D" ; } else { ongoing = "N" ; count += 1 ; } } } return count + 1 ; }
function findPermutation ( arr , N ) { var pos = arr . size + 1 ; if ( pos > N ) return 1 ; var res = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( ! arr . has ( i ) ) { if ( i % pos == 0 pos % i == 0 ) { arr . add ( i ) ; res += findPermutation ( arr , N ) ; arr . delete ( i ) ; } } } return res ; }
function minimum_required_operations ( arr , n , k ) { let answer = 0 ; let mod = 1000000007 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer %= mod ; } } return answer ; }
function minSteps ( arr , n , k ) { let i , cnt = 0 ; let flag ; if ( k == 1 ) flag = 0 ; else flag = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == flag ) { cnt ++ ; flag = ( flag + 1 ) % 2 ; } } return cnt ; }
function solve ( arr , n , X , Y ) { var diff = Y - X ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function minSum ( a , n , k ) { let maxheap = [ ] ; for ( let i = 0 ; i < n ; i ++ ) maxheap . push ( a [ i ] ) ; maxheap . sort ( function ( a , b ) { return a - b ; } ) ; while ( maxheap . length > 0 && k > 0 ) { let max_ele = maxheap . pop ( ) ; maxheap . push ( Math . floor ( max_ele / 2 ) ) ; k -= 1 ; maxheap . sort ( function ( a , b ) { return a - b ; } ) ; } let sum = 0 ; while ( maxheap . length > 0 ) sum += maxheap . shift ( ) ; return sum ; }
function determineWinner ( str ) { let A = Array . from ( { length : 10 } , ( _ , i ) => 0 ) ; let sum1 = 0 , sum2 = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { A [ str [ i ] . charCodeAt ( ) - 48 ] ++ ; } for ( let i = 0 ; i <= 9 ; i ++ ) { if ( i % 2 != 0 ) { sum1 = sum1 + A [ i ] ; } else { sum2 = sum2 + A [ i ] ; } } if ( sum1 == sum2 ) { document . write ( "-1" ) ; } else if ( sum1 > sum2 ) { document . write ( "Player▁1" ) ; } else { document . write ( "Player▁2" ) ; } }
function manipulateStrings ( P , Q ) { var freq = new Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < P . length ; i ++ ) { freq [ P [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } for ( var i = 0 ; i < Q . length ; i ++ ) { freq [ Q [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] -- ; } var sb = "" ; var pos = Q [ 0 ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ; for ( var i = 0 ; i <= pos ; i ++ ) { while ( freq [ i ] > 0 ) { var c = String . fromCharCode ( "a" . charCodeAt ( 0 ) + i ) ; sb += c ; freq [ i ] -- ; } } sb += Q ; for ( var i = pos + 1 ; i < 26 ; i ++ ) { while ( freq [ i ] > 0 ) { var c = String . fromCharCode ( "a" . charCodeAt ( 0 ) + i ) ; sb += c ; freq [ i ] -- ; } } document . write ( sb ) ; }
function deleted ( seg , l , r , start , end , current ) { if ( end < l start > r ) return 0 ; if ( start >= l && end <= r ) return seg [ current ] ; let mid = parseInt ( ( start + end ) / 2 , 10 ) ; return deleted ( seg , l , r , start , mid , 2 * current + 1 ) + deleted ( seg , l , r , mid + 1 , end , 2 * current + 2 ) ; }
function deleteNode ( nodeVal ) { return mp . has ( nodeVal ) ; }
function printInorderTree ( root ) { if ( root == null ) return ; printInorderTree ( root . left ) ; document . write ( root . key + "▁" ) ; printInorderTree ( root . right ) ; }
function sieve ( ) { prime [ 0 ] = prime [ 1 ] = false ; for ( let i = 2 ; i < 100005 ; i ++ ) prime [ i ] = true ; for ( let i = 2 ; i * i < 100005 ; i ++ ) { if ( prime [ i ] ) { for ( let j = i * i ; j < 100005 ; j += i ) { prime [ j ] = false ; } } } }
function smallestPrimeFactors ( ) { for ( let i = 0 ; i < 100005 ; i ++ ) spf [ i ] = - 1 ; for ( let i = 2 ; i * i < 100005 ; i ++ ) { for ( let j = i ; j < 100005 ; j += i ) { if ( spf [ j ] == - 1 ) { spf [ j ] = i ; } } } }
function sumOfPrimeFactors ( n ) { let ans = 0 ; while ( n > 1 ) { ans += spf [ n ] ; n /= spf [ n ] ; } return ans ; }
function findLength ( n ) { if ( prime [ n ] ) { return 1 ; } if ( dp [ n ] != 0 ) { return dp [ n ] ; } let sum = sumOfPrimeFactors ( n ) ; return dp [ n ] = 1 + findLength ( sum ) ; }
function solve ( n , arr ) { let i , ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { let left = Math . max ( i - 1 , 0 ) ; let right = Math . min ( n - 1 , i + 1 ) ; while ( left >= 0 ) { if ( arr [ left ] > arr [ i ] ) { left ++ ; break ; } left -- ; } if ( left < 0 ) left ++ ; while ( right < n ) { if ( arr [ right ] > arr [ i ] ) { right -- ; break ; } right ++ ; } if ( right >= n ) right -- ; ans = 1 + right - left ; document . write ( ans + "▁" ) ; } }
function countofPairs ( a ) { let n = a . length ; let freq = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; let maxi = - 1 ; let mini = n + 1 ; for ( let i = 0 ; i < n ; i ++ ) { maxi = Math . max ( maxi , a [ i ] ) ; mini = Math . min ( mini , a [ i ] ) ; } for ( let i = 0 ; i < n ; ++ i ) freq [ a [ i ] ] ++ ; return maxCount ( freq , maxi , mini ) ; }
function largest_subarray ( a , n ) { let index = new Map ( ) ; let ans = 0 ; for ( let i = 0 , j = 0 ; i < n ; i ++ ) { j = Math . max ( index . has ( a [ i ] ) ? index . get ( a [ i ] ) : 0 , j ) ; ans = Math . max ( ans , i - j + 1 ) ; index . set ( a [ i ] , i + 1 ) ; } return ans ; }
function getMaxSum ( a , n ) { let dp = new Array ( n ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 0 ] ; let max_sum = Math . max ( dp [ 0 ] [ 0 ] , dp [ 0 ] [ 1 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( a [ i ] , dp [ i - 1 ] [ 0 ] + a [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 1 ] + a [ i ] , a [ i ] * a [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 0 ] + a [ i ] * a [ i ] ) ; max_sum = Math . max ( max_sum , dp [ i ] [ 1 ] ) ; max_sum = Math . max ( max_sum , dp [ i ] [ 0 ] ) ; } return max_sum ; }
function getMid ( s , e ) { return ( s + Math . floor ( ( e - s ) / 2 ) ) ; }
function MaxUtil ( st , ss , se , l , r , node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return - 1 ; let mid = getMid ( ss , se ) ; return Math . max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; }
function constructSTUtil ( arr , ss , se , st , si ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return arr [ ss ] ; } let mid = getMid ( ss , se ) ; st [ si ] = Math . max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) ; return st [ si ] ; }
function findPrevious ( a , n ) { var ps = Array ( n ) . fill ( 0 ) ; ps [ 0 ] = - 1 ; let stack = Array ( ) ; stack . push ( 0 ) ; for ( var i = 1 ; i < a . length ; i ++ ) { while ( stack . length > 0 && a [ stack [ stack . length - 1 ] ] >= a [ i ] ) stack . pop ( ) ; ps [ i ] = stack . length > 0 ? stack [ stack . length - 1 ] : - 1 ; stack . push ( i ) ; } return ps ; }
function findNext ( a , n ) { var ns = Array ( n ) . fill ( 0 ) ; ns [ n - 1 ] = n ; var stack = Array ( ) ; stack . push ( n - 1 ) ; for ( var i = n - 2 ; i >= 0 ; i -- ) { while ( stack . length > 0 && a [ stack [ stack . length - 1 ] ] >= a [ i ] ) stack . pop ( ) ; ns [ i ] = stack . length > 0 ? stack [ stack . length - 1 ] : a . length ; stack . push ( i ) ; } return ns ; }
function findMaximumSum ( a , n ) { var prev_smaller = findPrevious ( a , n ) ; var next_smaller = findNext ( a , n ) ; var max_value = 0 ; for ( var i = 0 ; i < n ; i ++ ) { max_value = Math . max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) ; } return max_value ; }
function findCount ( arr , n ) { let prefix_sum = Array . from ( { length : n } , ( _ , i ) => 0 ) ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; let suffix_sum = Array . from ( { length : n } , ( _ , i ) => 0 ) ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; let s = 1 , e = 1 ; let curr_subarray_sum = 0 , count = 0 ; while ( s < n - 1 && e < n - 1 ) { while ( e < n - 1 && curr_subarray_sum < prefix_sum [ s - 1 ] ) { curr_subarray_sum += arr [ e ++ ] ; } if ( curr_subarray_sum <= suffix_sum [ e ] ) { count ++ ; } curr_subarray_sum -= arr [ s ++ ] ; } return count ; }
function minOperation ( s , n ) { let ans = 0 ; let i = 0 , j = n - 1 ; while ( i < j ) { if ( s [ i ] == "0" && s [ j ] == "1" ) { ans ++ ; i ++ ; j -- ; continue ; } if ( s [ i ] == "1" ) { i ++ ; } if ( s [ j ] == "0" ) { j -- ; } } return ans ; }
function solve ( n ) { var ans = 0 ; for ( y = n + 1 ; y <= n * n + n ; y ++ ) { if ( ( n * n ) % ( y - n ) == 0 ) { ans += 1 ; } } document . write ( ans ) ; }
function power ( x , y , mod ) { let res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
function count ( N ) { if ( N == 1 ) { document . write ( 10 ) ; return ; } document . write ( power ( 9 , N , 1000000007 ) ) ; }
function possible ( mid , a ) { let n = a . length ; let total = parseInt ( ( n * ( n - 1 ) ) / 2 ) ; let need = parseInt ( ( total + 1 ) / 2 ) ; let count = 0 ; let start = 0 , end = 1 ; while ( end < n ) { if ( a [ end ] - a [ start ] <= mid ) { end ++ ; } else { count += ( end - start - 1 ) ; start ++ ; } } if ( end == n && start < end && a [ end - 1 ] - a [ start ] <= mid ) { let t = end - start - 1 ; count += parseInt ( t * ( t + 1 ) / 2 ) ; } if ( count >= need ) return true ; else return false ; }
function findMedian ( a ) { let n = a . length ; let low = 0 , high = a [ n - 1 ] - a [ 0 ] ; while ( low <= high ) { let mid = ( low + high ) / 2 ; if ( possible ( mid , a ) ) high = mid - 1 ; else low = mid + 1 ; } return high + 1 ; }
function computeDistance ( root , value ) { if ( root == null ) { return - 1 ; } let left = computeDistance ( root . left , value ) ; let right = computeDistance ( root . right , value ) ; if ( left == - 1 && right == - 1 ) { if ( root . key == value ) { return 1 ; } else return - 1 ; } if ( left == - 1 ) { return right + 1 ; } if ( right == - 1 ) { return left + 1 ; } else { return 1 + Math . max ( left , right ) ; } }
function dfs ( node , count , m , arr , k ) { visited [ node ] = 1 ; if ( arr [ node - 1 ] == k ) { count ++ ; } else { count = 0 ; } if ( count > m ) { return ; } if ( adj [ node ] . length == 1 && node != 1 ) { ans ++ ; } for ( let x = 0 ; x < adj [ node ] . length ; x ++ ) { if ( visited [ adj [ node ] [ x ] ] == 0 ) { dfs ( adj [ node ] [ x ] , count , m , arr , k ) ; } } }
function find ( parent , x ) { if ( parent [ x ] == x ) return x ; parent [ x ] = find ( parent , parent [ x ] ) ; return parent [ x ] ; }
function setUnion ( parent , rank , x , y ) { let parentx = find ( parent , x ) ; let parenty = find ( parent , y ) ; if ( parenty == parentx ) return ; ctr -- ; if ( rank [ parentx ] < rank [ parenty ] ) { parent [ parentx ] = parenty ; } else if ( rank [ parentx ] > rank [ parenty ] ) { parent [ parenty ] = parentx ; } else { parent [ parentx ] = parenty ; rank [ parenty ] ++ ; } }
function solve ( n , m , query ) { let result = new Array ( query . length ) ; let parent = new Array ( n * m ) ; for ( let i = 0 ; i < n * m ; i ++ ) parent [ i ] = i ; let rank = new Array ( n * m ) ; let grid = new Array ( n * m ) ; for ( let i = 0 ; i < ( n * m ) ; i ++ ) { rank [ i ] = 0 ; grid [ i ] = false ; } for ( let i = 0 ; i < query . length ; i ++ ) { let x = query [ i ] [ 0 ] ; let y = query [ i ] [ 1 ] ; if ( grid [ m * x + y ] == true ) { result [ i ] = ctr ; continue ; } grid [ m * x + y ] = true ; ctr ++ ; if ( x > 0 && grid [ m * ( x - 1 ) + y ] == true ) setUnion ( parent , rank , m * x + y , m * ( x - 1 ) + y ) ; if ( y > 0 && grid [ m * ( x ) + y - 1 ] == true ) setUnion ( parent , rank , m * x + y , m * ( x ) + y - 1 ) ; if ( x < n - 1 && grid [ m * ( x + 1 ) + y ] == true ) setUnion ( parent , rank , m * x + y , m * ( x + 1 ) + y ) ; if ( y < m - 1 && grid [ m * ( x ) + y + 1 ] == true ) setUnion ( parent , rank , m * x + y , m * ( x ) + y + 1 ) ; result [ i ] = ctr ; } return result ; }
function FindMinimumDistance ( ) { let q = [ ] ; q . push ( [ x , y ] ) ; mat [ x ] [ y ] = 0 ; while ( q . length > 0 ) { x = q [ 0 ] [ 0 ] ; y = q [ 0 ] [ 1 ] ; q . shift ( ) ; for ( let i = 0 ; i < 8 ; i ++ ) { let a = x + dx [ i ] ; let b = y + dy [ i ] ; if ( a < 0 a >= r b >= c b < 0 ) continue ; if ( mat [ a ] [ b ] == 0 ) { mat [ a ] [ b ] = mat [ x ] [ y ] + 1 ; q . push ( [ a , b ] ) ; } } } }
function make_set ( v ) { parent [ v ] = v ; size_set [ v ] = 1 ; }
function find_set ( v ) { if ( v == parent [ v ] ) return v ; return parent [ v ] = find_set ( parent [ v ] ) ; }
function union_set ( a , b ) { a = find_set ( a ) ; b = find_set ( b ) ; if ( a != b ) { if ( size_set [ a ] < size_set [ b ] ) { let temp = a ; a = b ; b = temp ; } parent [ b ] = a ; size_set [ a ] += size_set [ b ] ; } }
function SieveOfEratosthenes ( ) { for ( let i = 0 ; i < 100001 ; i ++ ) prime [ i ] = 1 ; let p = 2 ; while ( p * p <= 100000 ) { if ( prime [ p ] == 1 ) { for ( let i = p * p ; i < 100001 ; i += p ) prime [ i ] = 0 ; } p += 1 ; } }
function fibonacciOfPrime ( n1 , n2 ) { SieveOfEratosthenes ( ) ; let initial = [ ] ; for ( let i = n1 ; i <= n2 ; i ++ ) if ( prime [ i ] == 1 ) initial . push ( i ) ; let now = [ ] ; for ( let i = 0 ; i < initial . length ; i ++ ) { for ( let j = 0 ; j < initial . length ; j ++ ) { let a = initial [ i ] ; let b = initial [ j ] ; if ( a != b ) { let c = join ( a , b ) ; now . push ( c ) ; } } } let current = [ ] ; for ( let i = 0 ; i < now . length ; i ++ ) if ( prime [ now [ i ] ] == 1 ) current . push ( now [ i ] ) ; let cnt = new Array ( 1000009 ) ; for ( let i = 0 ; i < 1000001 ; i ++ ) cnt [ i ] = 0 ; let current_set = [ ] ; for ( let i = 0 ; i < current . length ; i ++ ) { cnt [ current [ i ] ] ++ ; if ( cnt [ current [ i ] ] == 1 ) current_set . push ( current [ i ] ) ; } let first = 1000000000 ; for ( let i = 0 ; i < current_set . length ; i ++ ) first = Math . min ( first , current_set [ i ] ) ; let second = 0 ; for ( let i = 0 ; i < current_set . length ; i ++ ) second = Math . max ( second , current_set [ i ] ) ; let count = current_set . length - 1 ; let curr = 1 ; let c = 0 ; while ( curr < count ) { c = first + second ; first = second ; second = c ; curr += 1 ; } document . write ( c ) ; }
function reverse ( num ) { var rev = 0 ; while ( num > 0 ) { var r = parseInt ( ( num % 10 ) ) ; rev = rev * 10 + r ; num = parseInt ( num / 10 ) ; } return rev ; }
function count ( N , A , B ) { var l = Math . pow ( 10 , N - 1 ) , r = Math . pow ( 10 , N ) - 1 ; if ( l == 1 ) l = 0 ; var ans = 0 ; for ( i = l ; i <= r ; i ++ ) { var even_sum = 0 , odd_sum = 0 ; var itr = 0 , num = reverse ( i ) ; while ( num > 0 ) { if ( itr % 2 == 0 ) odd_sum += num % 10 ; else even_sum += num % 10 ; num = parseInt ( num / 10 ) ; itr ++ ; } if ( even_sum % A == 0 && odd_sum % B == 0 ) ans ++ ; } return ans ; }
function count ( N , A , B ) { if ( N == 1 ) { return 9 / B + 1 ; } let max_sum = 9 * N ; let odd_count = N / 2 + N % 2 ; let even_count = N - odd_count ; let dp = new Array ( even_count ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < even_count ; i ++ ) { for ( var j = 0 ; j < max_sum + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= 9 ; i ++ ) dp [ 0 ] [ i % A ] ++ ; for ( let i = 1 ; i < even_count ; i ++ ) { for ( let j = 0 ; j <= 9 ; j ++ ) { for ( let k = 0 ; k <= max_sum ; k ++ ) { if ( dp [ i - 1 ] [ k ] > 0 ) dp [ i ] [ ( j + k ) % A ] += dp [ i - 1 ] [ k ] ; } } } let dp1 = new Array ( odd_count ) ; for ( var i = 0 ; i < dp1 . length ; i ++ ) { dp1 [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < odd_count ; i ++ ) { for ( var j = 0 ; j < max_sum + 1 ; j ++ ) { dp1 [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= 9 ; i ++ ) dp1 [ 0 ] [ i % B ] ++ ; for ( let i = 1 ; i < odd_count ; i ++ ) { for ( let j = 0 ; j <= 9 ; j ++ ) { for ( let k = 0 ; k <= max_sum ; k ++ ) { if ( dp1 [ i - 1 ] [ k ] > 0 ) dp1 [ i ] [ ( j + k ) % B ] += dp1 [ i - 1 ] [ k ] ; } } } return dp [ even_count - 1 ] [ 0 ] * dp1 [ odd_count - 1 ] [ 0 ] ; }
function calc_distance ( A , B , n ) { var distance_traveled_A = 0 ; var distance_traveled_B = 0 ; var answer = 0 ; for ( i = 0 ; i < 5 ; i ++ ) { distance_traveled_A += A [ i ] ; distance_traveled_B += B [ i ] ; if ( ( distance_traveled_A == distance_traveled_B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; }
function dfs ( node , A , subtree_size , visited , check_subtree ) { visited [ node ] = 1 ; subtree_size [ node ] = 1 ; if ( node == A ) { check_subtree [ node ] = 1 ; } else check_subtree [ node ] = 0 ; for ( let v = 0 ; v < G [ node ] . length ; v ++ ) { if ( visited [ G [ node ] [ v ] ] == 0 ) { subtree_size [ node ] += dfs ( G [ node ] [ v ] , A , subtree_size , visited , check_subtree ) ; check_subtree [ node ] = check_subtree [ node ] | check_subtree [ G [ node ] [ v ] ] ; } } return subtree_size [ node ] ; }
function numberOfPairs ( N , B , A ) { let subtree_size = new Array ( N + 1 ) ; subtree_size . fill ( 0 ) ; let visited = new Array ( N + 1 ) ; visited . fill ( 0 ) ; let check_subtree = new Array ( N + 1 ) ; check_subtree . fill ( 0 ) ; dfs ( B , A , subtree_size , visited , check_subtree ) ; let difference = 0 ; for ( let v = 0 ; v < G [ B ] . length ; v ++ ) { if ( check_subtree [ G [ B ] [ v ] ] > 0 ) { difference = N - subtree_size [ G [ B ] [ v ] ] ; break ; } } return ( N * ( N - 1 ) ) - difference * ( subtree_size [ A ] ) ; }
function equalXORandOR ( n ) { var m = 0 ; var MSB = parseInt ( Math . log ( n ) ) ; for ( i = 0 ; i <= MSB ; i ++ ) { if ( ( n & ( 1 << i ) ) <= 0 ) { m += ( 1 << i ) ; } } return m ; }
function findMinSoln ( n , k ) { var minSoln = 1000000000 ; for ( var i = 1 ; i < k ; i ++ ) { if ( n % i == 0 ) minSoln = Math . min ( minSoln , ( n / i ) * k + i ) ; } return minSoln ; }
function getSum ( BITree , index ) { let ans = 0 ; index += 1 ; while ( index > 0 ) { ans += BITree [ index ] ; index -= index & ( - index ) ; } return ans ; }
function updateBIT ( BITree , n , index , val ) { index = index + 1 ; while ( index <= n ) { BITree [ index ] += val ; index += index & ( - index ) ; } }
function getLowerBound ( BITree , arr , n , k ) { let lb = - 1 ; let l = 0 , r = n - 1 ; while ( l <= r ) { let mid = Math . floor ( l + ( r - l ) / 2 ) ; if ( getSum ( BITree , mid ) >= k ) { r = mid - 1 ; lb = mid ; } else l = mid + 1 ; } return lb ; }
function dfs ( val , cost , tr , u , s ) { s = s + cost [ u ] ; if ( s < 0 ) s = 0 ; if ( s > val [ u ] ) return ; cnt ++ ; for ( var i = 0 ; i < tr [ u ] . length ; i ++ ) { dfs ( val , cost , tr , tr [ u ] [ i ] , s ) ; } }
function dfs1 ( cur , par ) { for ( let u = 0 ; u < adj [ cur ] . length ; u ++ ) { if ( adj [ cur ] [ u ] != par ) { dfs1 ( adj [ cur ] [ u ] , cur ) ; height [ cur ] = Math . max ( height [ cur ] , height [ adj [ cur ] [ u ] ] ) ; } } height [ cur ] += 1 ; }
function dfs2 ( cur , par ) { let max1 = 0 ; let max2 = 0 ; for ( let u = 0 ; u < adj [ cur ] . length ; u ++ ) { if ( adj [ cur ] [ u ] != par ) { if ( height [ adj [ cur ] [ u ] ] >= max1 ) { max2 = max1 ; max1 = height [ adj [ cur ] [ u ] ] ; } else if ( height [ adj [ cur ] [ u ] ] > max2 ) { max2 = height [ adj [ cur ] [ u ] ] ; } } } let sum = 0 ; for ( let u = 0 ; u < adj [ cur ] . length ; u ++ ) { if ( adj [ cur ] [ u ] != par ) { sum = ( ( max1 == height [ adj [ cur ] [ u ] ] ) ? max2 : max1 ) ; if ( max1 == height [ adj [ cur ] [ u ] ] ) dist [ adj [ cur ] [ u ] ] = 1 + Math . max ( 1 + max2 , dist [ cur ] ) ; else dist [ adj [ cur ] [ u ] ] = 1 + Math . max ( 1 + max1 , dist [ cur ] ) ; dfs2 ( adj [ cur ] [ u ] , cur ) ; } } }
function displaySteppingNumbers ( n , m ) { for ( let i = n ; i <= m ; i ++ ) if ( isStepNum ( i ) ) document . write ( i + "▁" ) ; }
function BFS ( mat , row , col ) { var area = 0 ; var Q = [ ] ; Q . push ( new pair ( row , col ) ) ; while ( Q . length != 0 ) { var it = Q [ 0 ] ; Q . shift ( ) ; var r = it . first , c = it . second ; if ( r < 0 c < 0 r > 4 c > 4 ) continue ; if ( mat [ r ] [ c ] == 0 ) continue ; if ( mat [ r ] == 1 ) { mat [ r ] = 0 ; area ++ ; } Q . push ( new pair ( r + 1 , c ) ) ; Q . push ( new pair ( r - 1 , c ) ) ; Q . push ( new pair ( r , c + 1 ) ) ; Q . push ( new pair ( r , c - 1 ) ) ; } return area ; }
function sizeOfConnections ( mat ) { var result = [ ] ; for ( var row = 0 ; row < 5 ; ++ row ) { for ( var col = 0 ; col < 5 ; ++ col ) { if ( mat [ row ] [ col ] == 1 ) { var area = BFS ( mat , row , col ) ; result . push ( area ) ; } } } for ( var val of result ) document . write ( val + "▁" ) ; }
function DFS ( adjl , parent , u , p ) { parent [ u ] = p ; for ( let v = 0 ; v < adjl [ u ] . length ; v ++ ) { if ( adjl [ u ] [ v ] != p ) { DFS ( adjl , parent , adjl [ u ] [ v ] , u ) ; } } }
function valuesFromChildren ( parent , values ) { let valuesChildren = new Array ( parent . length ) ; for ( let i = 0 ; i < parent . length ; i ++ ) { valuesChildren [ i ] = 0 ; } for ( let i = 0 ; i < parent . length ; i ++ ) { if ( parent [ i ] == - 1 ) continue ; else { let p = parent [ i ] ; valuesChildren [ p ] += values [ i ] ; } } return valuesChildren ; }
function maxProduct ( arr , N ) { if ( N < 3 ) { return ; } let a = arr [ 0 ] , b = arr [ 1 ] ; let c = 0 , d = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] * arr [ j ] > a * b ) { c = a , d = b ; a = arr [ i ] , b = arr [ j ] ; } if ( arr [ i ] * arr [ j ] < a * b && arr [ i ] * arr [ j ] > c * d ) c = arr [ i ] , d = arr [ j ] ; } document . write ( c + "▁" + d ) ; }
function maxProduct ( arr , N ) { if ( N < 3 ) { return ; } arr . sort ( ( a , b ) => a - b )  let smallest1 = arr [ 0 ] ; let smallest3 = arr [ 2 ] ; let largest1 = arr [ N - 1 ] ; let largest3 = arr [ N - 3 ] ; if ( smallest1 * smallest3 >= largest1 * largest3 ) { document . write ( smallest1 + "▁" + smallest3 ) ; } else { document . write ( largest1 + "▁" + largest3 ) ; } }
function maxLen ( A , N ) { var v = [ ] ; for ( var i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 1 ) { var s = i , len ; while ( A [ i ] == 1 && i < N ) { i ++ ; } len = i - s ; v . push ( [ len , s , i - 1 ] ) ; } } if ( v . length == 0 ) { return - 1 ; } var ans = 0 ; for ( var i = 0 ; i < v . length - 1 ; i ++ ) { ans = Math . max ( ans , v [ i ] [ 0 ] ) ; if ( v [ i + 1 ] [ 1 ] - v [ i ] [ 2 ] - 1 == 2 ) { ans = Math . max ( ans , v [ i ] [ 0 ] + v [ i + 1 ] [ 0 ] ) ; } if ( v [ i + 1 ] [ 1 ] - v [ i ] [ 2 ] - 1 == 1 ) { ans = Math . max ( ans , v [ i ] [ 0 ] + v [ i + 1 ] [ 0 ] - 1 ) ; } } ans = Math . max ( v [ v . length - 1 ] [ 0 ] , ans ) ; return ans ; }
function maxLengthOf1s ( arr , n ) { let prefix = new Array ( n ) ; prefix . fill ( 0 ) ; for ( let i = 2 ; i < n ; i ++ ) { if ( arr [ i - 2 ] == 1 ) prefix [ i ] = prefix [ i - 1 ] + 1 ; else prefix [ i ] = 0 ; } let suffix = new Array ( n ) ; suffix . fill ( 0 ) ; for ( let i = n - 3 ; i >= 0 ; i -- ) { if ( arr [ i + 2 ] == 1 ) suffix [ i ] = suffix [ i + 1 ] + 1 ; else suffix [ i ] = 0 ; } let ans = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { ans = Math . max ( ans , prefix [ i + 1 ] + suffix [ i ] ) ; } document . write ( ans ) ; }
function dfs ( u ) { visited [ u ] = 1 ; adj [ u ] . forEach ( it => { if ( visited [ it ] == 0 ) dfs ( it ) ; } ) ; s . push ( u ) ; }
function check_cycle ( ) { var pos = new Map ( ) ; var ind = 0 ; while ( s . length != 0 ) { pos . set ( s [ s . length - 1 ] , ind ) ; tsort . push ( s [ s . length - 1 ] ) ; ind += 1 ; s . pop ( ) ; } var ans = false ; for ( var i = 0 ; i < n ; i ++ ) { adj [ i ] . forEach ( it => { if ( ( pos . has ( i ) ? pos . get ( i ) : 0 ) > ( pos . has ( it ) ? pos . get ( it ) : 0 ) ) { ans = true ; } } ) ; } ; return ans ; }
function addEdge ( u , v ) { adj [ u ] . push ( v ) ; }
function printNewArray ( a , n ) { var v = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { v . push ( [ a [ i ] , i ] ) ; } v . sort ( ) ; var ans = Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { ans [ v [ ( i + 1 ) % n ] [ 1 ] ] = v [ i ] [ 0 ] ; } for ( var i = 0 ; i < n ; i ++ ) { document . write ( ans [ i ] + "▁" ) ; } }
function bfs ( n , m , num ) { let q = [ ] ; q . push ( num ) ; while ( q . length != 0 ) { let stepNum = q . shift ( ) ; if ( stepNum <= m && stepNum >= n ) { document . write ( stepNum + "▁" ) ; } if ( stepNum == 0 stepNum > m ) continue ; let lastDigit = stepNum % 10 ; let stepNumA = stepNum * 10 + ( lastDigit - 1 ) ; let stepNumB = stepNum * 10 + ( lastDigit + 1 ) ; if ( lastDigit == 0 ) q . push ( stepNumB ) ; else if ( lastDigit == 9 ) q . push ( stepNumA ) ; else { q . push ( stepNumA ) ; q . push ( stepNumB ) ; } } }
function displaySteppingNumbers ( n , m ) { for ( let i = 0 ; i <= 9 ; i ++ ) bfs ( n , m , i ) ; }
function solve ( arr , n ) { var countzeroes = 0 ; var countones = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countzeroes ++ ; else countones ++ ; } if ( Math . abs ( countzeroes - countones ) == 1 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function bs ( ar , n , ele ) { let start = 0 ; let end = n - 1 ; let ch = "@" ; while ( start <= end ) { let mid = start + Math . floor ( ( end - start ) / 2 ) ; if ( ar [ mid ] == ele ) end = mid - 1 ; else if ( ar [ mid ] < ele ) { ch = ar [ mid ] ; start = mid + 1 ; } else end = mid - 1 ; } return ch ; }
function countPairs ( N , arr ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } document . write ( count / 2 ) ; }
function findMaxLen ( a , k ) { let n = a . length ; a . sort ( ) ; let vis = Array . from ( { length : n } , ( _ , i ) => 0 ) ; let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { mp . set ( a [ i ] , i ) ; } let c = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( vis [ i ] == false ) { let check = a [ i ] * k ; if ( mp . has ( check ) ) { c ++ ; vis [ mp . get ( check ) ] = true ; } } } return n - c ; }
function isVowel ( c ) { if ( c == "a" c == "e" c == "i" c == "o" c == "u" ) return true ; return false ; }
function countSubstrings ( s , n ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let count = 0 ; for ( let j = i ; j < n ; j ++ ) { if ( isVowel ( s [ j ] ) ) { count ++ ; } if ( count % 2 == 0 ) result ++ ; } } document . write ( result ) ; }
function addEdge ( u , v ) { adj [ u ] . push ( v ) ; adj [ v ] . push ( u ) ; }
function minimumCost ( V , cost ) { var vis = Array ( V + 1 ) . fill ( false ) ; var min_cost = 0 ; for ( var i = 1 ; i <= V ; i ++ ) { if ( ! vis [ i ] ) { var min_cost_node = 1000000000 ; min_cost_node = dfs ( i , cost , vis , min_cost_node ) ; min_cost += min_cost_node ; } } return min_cost ; }
function check ( str , mid , a ) { var n = str . length ; var previous = - 1 , i ; for ( i = 0 ; i < n ; ++ i ) { if ( str [ i ] === a ) { if ( i - previous > mid ) { return false ; } previous = i ; } } if ( i - previous > mid ) return false ; else return true ; }
function possible ( str , mid ) { for ( var i = 0 ; i < 26 ; ++ i ) { if ( check ( str , mid , String . fromCharCode ( i + "a" . charCodeAt ( 0 ) ) ) ) return true ; } return false ; }
function findMinLength ( str ) { var low = 1 , high = str . length ; while ( low <= high ) { var mid = parseInt ( ( low + high ) / 2 ) ; if ( possible ( str , mid ) ) high = mid - 1 ; else low = mid + 1 ; } return high + 1 ; }
function solve ( A , N ) { let i = 0 ; let k = 0 ; for ( let j = 1 ; j < N ; j ++ ) { let tempK = Math . min ( A [ i ] , A [ j ] ) / ( j - i ) ; if ( tempK > k ) { k = tempK ; } if ( A [ j ] >= A [ i ] / ( j - i ) ) i = j ; } return k ; }
function possible ( arr , N , mid , K ) { let add = 0 ; for ( let i = parseInt ( N / 2 , 10 ) - ( N + 1 ) % 2 ; i < N ; ++ i ) { if ( mid - arr [ i ] > 0 ) { add += ( mid - arr [ i ] ) ; if ( add > K ) return false ; } } if ( add <= K ) return true ; else return false ; }
function findMaxMedian ( arr , N , K ) { let low = 1 ; let mx = 0 ; for ( let i = 0 ; i < N ; ++ i ) { mx = Math . max ( mx , arr [ i ] ) ; } let high = K + mx ; while ( low <= high ) { let mid = parseInt ( ( high + low ) / 2 , 10 ) ; if ( possible ( arr , N , mid , K ) ) { low = mid + 1 ; } else { high = mid - 1 ; } } if ( N % 2 == 0 ) { if ( low - 1 < arr [ parseInt ( N / 2 ) ] ) { return parseInt ( ( arr [ parseInt ( N / 2 ) ] + low - 1 ) / 2 , 10 ) ; } } return low - 1 ; }
function split ( arr , n ) { arr . sort ( ) ; let count = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] == 1 ) { count = 2 ; break ; } } document . write ( count ) ; }
function check ( str1 , str2 ) { var mark = Array ( 26 ) . fill ( false ) ; var n = str1 . length , m = str2 . length ; for ( var i = 0 ; i < n ; i ++ ) { mark [ str1 [ i ] - "a" ] = true ; } for ( var i = 0 ; i < m ; i ++ ) { if ( mark [ str2 [ i ] - "a" ] ) return true ; } return false ; }
function countLessThanMid ( mid , N , M , K ) { let count = 0 ; for ( let i = 1 ; i <= Math . min ( N , mid ) ; ++ i ) { count = count + Math . min ( parseInt ( mid / i ) , M ) ; } if ( count >= K ) return false ; else return true ; }
function findKthElement ( N , M , K ) { let low = 1 , high = N * M ; while ( low <= high ) { let mid = low + parseInt ( ( high - low ) / 2 ) ; if ( countLessThanMid ( mid , N , M , K ) ) low = mid + 1 ; else high = mid - 1 ; } return high + 1 ; }
function PermuteTheArray ( A , n ) { var arr = Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { arr [ A [ i ] - 1 ] = i ; } var mini = n , maxi = 0 ; var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { mini = Math . min ( mini , arr [ i ] ) ; maxi = Math . max ( maxi , arr [ i ] ) ; if ( maxi - mini == i ) count ++ ; } return count ; }
function findLargest ( beg , end , arr , n ) { if ( beg == end ) { let compared = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) compared [ i ] = 0 ; compared [ 0 ] = 1 ; compared [ 1 ] = arr [ beg ] ; return compared ; } let compared1 = findLargest ( beg , Math . floor ( ( beg + end ) / 2 ) , arr , n ) ; let compared2 = findLargest ( Math . floor ( ( beg + end ) / 2 ) + 1 , end , arr , n ) ; if ( compared1 [ 1 ] > compared2 [ 1 ] ) { let k = compared1 [ 0 ] + 1 ; compared1 [ 0 ] = k ; compared1 [ k ] = compared2 [ 1 ] ; return compared1 ; } else { let k = compared2 [ 0 ] + 1 ; compared2 [ 0 ] = k ; compared2 [ k ] = compared1 [ 1 ] ; return compared2 ; } }
function findSecondLargest ( end , arr ) { let compared1 = findLargest ( 0 , end - 1 , arr , end ) ; let compared2 = findLargest ( 2 , compared1 [ 0 ] + 2 , compared1 , compared1 [ 0 ] ) ; document . write ( compared2 [ 1 ] ) ; }
function CountsubString ( str , n ) { var c = 0 ; for ( var len = 1 ; len <= n ; len ++ ) { for ( var i = 0 ; i <= n - len ; i ++ ) { var j = i + len - 1 ; var temp = str [ i ] , f = 0 ; if ( j == i ) { c ++ ; continue ; } var k = i + 1 ; while ( temp > str [ k ] && k <= j ) { temp = str [ k ] ; k ++ ; } if ( k > j ) { c ++ ; f = 2 ; } while ( temp < str [ k ] && k <= j && f != 2 ) { temp = str [ k ] ; k ++ ; } if ( k > j && f != 2 ) { c ++ ; f = 0 ; } } } return c ; }
function countSubString ( S , C ) { var count = 0 ; var conCount = 0 ; for ( var i = 0 ; i < S . length ; i ++ ) { var ch = S [ i ] ; if ( ch === C ) conCount ++ ; else { count += ( conCount * ( conCount + 1 ) ) / 2 ; conCount = 0 ; } } count += ( conCount * ( conCount + 1 ) ) / 2 ; document . write ( count ) ; }
function checkPalindrome ( S ) { var N = S . length ; var first_half = true ; var second_half = true ; var cnt = parseInt ( ( N / 2 ) ) - 1 ; for ( i = 0 ; i < ( N / 2 ) ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( cnt ) ) { first_half = false ; break ; } if ( S . charAt ( N / 2 + i ) != S . charAt ( N / 2 + cnt ) ) { second_half = false ; break ; } cnt -- ; } if ( first_half && second_half ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function isSubsetSum ( arr , n , sum ) { let subset = new Array ( n + 1 ) ; for ( var i = 0 ; i < subset . length ; i ++ ) { subset [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( let i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= sum ; j ++ ) { if ( j < arr [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= arr [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } return subset [ n ] [ sum ] ; }
function findSum ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } let val = Math . floor ( Math . sqrt ( sum ) ) ; for ( let i = val ; i >= 0 ; i -- ) { if ( isSubsetSum ( arr , n , i * i ) ) { return i * i ; } } return 0 ; }
function findsubArray ( arr , N , K ) { var res = N + 1 ; for ( i = 0 ; i < N ; i ++ ) { var curr_prod = 1 ; for ( j = i ; j < N ; j ++ ) { curr_prod = curr_prod * arr [ j ] ; if ( curr_prod % N == K && res > ( j - i + 1 ) ) { res = Math . min ( res , j - i + 1 ) ; break ; } } } return ( res == N + 1 ) ? 0 : res ; }
function check ( arr ) { let f = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( ! checkBitonic ( arr [ i ] , M ) ) { document . write ( "NO" ) ; return ; } } for ( let i = 0 ; i < N ; i ++ ) { let temp = [ N ] ; for ( let j = 0 ; j < N ; j ++ ) { temp [ j ] = arr [ j ] [ i ] ; } if ( ! checkBitonic ( temp , N ) ) { document . write ( "NO" ) ; return ; } } document . write ( "YES" ) ; }
function getMaxGcd ( N ) { var maxGcd = Number . MIN_VALUE , A , B ; for ( i = 1 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { A = i ; B = N / i ; maxGcd = Math . max ( maxGcd , gcd ( A , B ) ) ; } } return maxGcd ; }
function can_place ( A , n , B , mid ) { let count = 1 ; let last_position = A [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( A [ i ] - last_position >= mid ) { last_position = A [ i ] ; count ++ ; if ( count == B ) { return true ; } } } return false ; }
function find_min_difference ( A , n , B ) { A . sort ( ) ; let s = 0 ; let e = A [ n - 1 ] - A [ 0 ] ; let ans = 0 ; while ( s <= e ) { let mid = parseInt ( ( s + e ) / 2 , 10 ) ; if ( can_place ( A , n , B , mid ) ) { ans = mid ; s = mid + 1 ; } else { e = mid - 1 ; } } return ans ; }
function UniversalSubset ( A , B ) { var n1 = A . length ; var n2 = B . length ; var res = [ ] ; var A_fre = Array . from ( Array ( n1 ) , ( ) => Array ( 26 ) ) ; for ( var i = 0 ; i < n1 ; i ++ ) { for ( var j = 0 ; j < 26 ; j ++ ) A_fre [ i ] [ j ] = 0 ; } for ( var i = 0 ; i < n1 ; i ++ ) { for ( var j = 0 ; j < A [ i ] . length ; j ++ ) { A_fre [ i ] [ A [ i ] . charCodeAt ( j ) - "a" . charCodeAt ( 0 ) ] ++ ; } } var B_fre = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < n2 ; i ++ ) { var arr = Array ( 26 ) . fill ( 0 ) ; for ( var j = 0 ; j < B [ i ] . length ; j ++ ) { arr [ B [ i ] . charCodeAt ( j ) - "a" . charCodeAt ( 0 ) ] ++ ; B_fre [ B [ i ] . charCodeAt ( j ) - "a" . charCodeAt ( 0 ) ] = Math . max ( B_fre [ B [ i ] . charCodeAt ( j ) - "a" . charCodeAt ( 0 ) ] , arr [ B [ i ] . charCodeAt ( j ) - "a" . charCodeAt ( 0 ) ] ) ; } } for ( var i = 0 ; i < n1 ; i ++ ) { var flag = 0 ; for ( var j = 0 ; j < 26 ; j ++ ) { if ( A_fre [ i ] [ j ] < B_fre [ j ] ) { flag = 1 ; break ; } } if ( flag == 0 ) res . push ( A [ i ] ) ; } if ( res . length > 0 ) { for ( var i = 0 ; i < res . length ; i ++ ) { for ( var j = 0 ; j < res [ i ] . length ; j ++ ) document . write ( res [ i ] [ j ] ) ; } document . write ( "▁" ) ; } else document . write ( "-1" ) ; }
function countTriplets ( A , N ) { let ans = 0 ; let map = new Map ( ) ; for ( let j = N - 2 ; j >= 1 ; j -- ) { if ( map . has ( A [ j + 1 ] ) ) map . set ( A [ j + 1 ] , map . get ( A [ j + 1 ] ) + 1 ) ; else map . set ( A [ j + 1 ] , 1 ) ; for ( let i = 0 ; i < j ; i ++ ) { let target = A [ i ] * A [ j ] ; if ( map . has ( target ) ) ans += map . get ( target ) ; } } return ans ; }
function minDistance ( a , n ) { let max = - 1 , min = Number . MAX_VALUE ; let min_index = - 1 , max_index = - 1 ; let min_dist = n + 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; if ( a [ i ] < min ) min = a [ i ] ; } for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == min ) min_index = i ; if ( a [ i ] == max ) max_index = i ; if ( min_index != - 1 && max_index != - 1 ) min_dist = Math . min ( min_dist , Math . abs ( min_index - max_index ) ) ; } return min_dist ; }
function sign ( x ) { if ( x > 0 ) return 1 ; else return - 1 ; }
function findMaxSum ( arr , size ) { let max_sum = 0 , pres , i , j ; for ( i = 0 ; i < size ; i ++ ) { pres = arr [ i ] ; j = i ; while ( j < size && sign ( arr [ i ] ) == sign ( arr [ j ] ) ) { pres = Math . max ( pres , arr [ j ] ) ; j ++ ; } max_sum = max_sum + pres ; i = j - 1 ; } return max_sum ; }
function groupInKConsecutive ( arr , K ) { var count = new Map ( ) ; arr . forEach ( element => { if ( count . has ( element ) ) count . set ( element , count . get ( element ) + 1 ) else count . set ( element , 1 ) } ) ; count . forEach ( ( value , key ) => { var cur = key ; var n = value ; if ( n > 0 ) { for ( var i = 1 ; i < K ; ++ i ) { if ( ! count . has ( cur + i ) ) { return false ; } count . set ( cur + i , count . get ( cur + i ) - n ) ; if ( count . get ( cur + i ) < 0 ) return false ; } } } ) ; return true ; }
function checkrules ( s ) { if ( s . length == 0 ) return true ; if ( s [ 0 ] != "1" ) return false ; if ( s . length > 2 ) { if ( s [ 1 ] == "0" && s [ 2 ] == "0" ) return checkrules ( s . substring ( 3 ) ) ; } return checkrules ( s . substring ( 1 ) ) ; }
function countSubAllOnes ( s ) { var l = 0 , r = 0 , ans = 0 ; while ( l <= r ) { if ( r == s . length ) { ans += ( ( r - l ) * ( r - l + 1 ) ) / 2 ; break ; } if ( s [ r ] == "1" ) r ++ ; else { ans += ( ( r - l ) * ( r - l + 1 ) ) / 2 ; l = r + 1 ; r ++ ; } } return ans ; }
function countOfPrimes ( L , R ) { var count = 0 ; for ( var i = L ; i <= R ; i ++ ) { if ( isPrime ( i ) ) { if ( sumSquare ( i ) ) count ++ ; } } return count ; }
function Maxlen ( arr , n ) { let ans = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count = 0 ; else count ++ ; ans = Math . max ( ans , count ) ; } return ans ; }
function findPair ( a , n ) { let min_dist = Number . MAX_VALUE ; let index_a = - 1 , index_b = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( j - i < min_dist ) { if ( a [ i ] % a [ j ] == 0 a [ j ] % a [ i ] == 0 ) { min_dist = j - i ; index_a = i ; index_b = j ; } } } } if ( index_a == - 1 ) { document . write ( "-1" ) ; } else { document . write ( "(" + a [ index_a ] + ",▁" + a [ index_b ] + ")" ) ; } }
function findNumberDivByPowerofTwo ( ar , k , n ) { var found = - 1 , m = k ; while ( m > 0 ) { var l = 0 ; var r = n - 1 ; while ( l <= r ) { var mid = parseInt ( ( l + r ) / 2 ) ; if ( ar [ mid ] == m ) { found = m ; break ; } else if ( ar [ mid ] > m ) { r = mid - 1 ; } else if ( ar [ mid ] < m ) { l = mid + 1 ; } } if ( found != - 1 ) { break ; } m = parseInt ( m / 2 ) ; } return found ; }
function longestNudeSubseq ( arr , n ) { let answer = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isNudeNum ( arr [ i ] ) ) answer ++ ; } return answer ; }
function findSubset ( a , n ) { let sum = 0 ; let cnt = 0 ; let v = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) { if ( a [ i - 1 ] - i <= 0 ) { sum += a [ i - 1 ] - i ; cnt += 1 ; } else { v . push ( a [ i - 1 ] - i ) ; } } v . sort ( ) ; let ptr = 0 ; while ( ptr < v . length && sum + v [ ptr ] <= 0 ) { cnt += 1 ; ptr += 1 ; sum += v [ ptr ] ; } return cnt ; }
function get_submaxarr ( arr , n , y ) { var j = 0 ; var stk = [ ] ; var maxarr = Array ( n ) ; stk . push ( 0 ) ; for ( var i = 1 ; i < n ; i ++ ) { while ( stk . length != 0 && arr [ i ] > arr [ stk [ stk . length - 1 ] ] ) { maxarr [ stk [ stk . length - 1 ] ] = i - 1 ; stk . pop ( ) ; } stk . push ( i ) ; } while ( stk . length != 0 ) { maxarr [ stk [ stk . length - 1 ] ] = n - 1 ; stk . pop ( ) ; } var submax = [ ] ; for ( var i = 0 ; i <= n - y ; i ++ ) { while ( maxarr [ j ] < i + y - 1 j < i ) { j ++ ; } submax . push ( arr [ j ] ) ; } return submax ; }
function findMinx ( A , B , C , K ) { var start = 1 ; var end = parseInt ( Math . ceil ( Math . sqrt ( K ) ) ) ; while ( start <= end ) { var mid = start + parseInt ( ( end - start ) / 2 ) ; var x = func ( A , B , C , mid ) ; var Y = func ( A , B , C , mid - 1 ) ; if ( x >= K && Y < K ) { return mid ; } else if ( x < K ) { start = mid + 1 ; } else { end = mid - 1 ; } } return - 1 ; }
function longestSubarray ( arr , n , k ) { let i , j , Max = 1 ; let s = new Set ( ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { s . add ( arr [ i ] ) ; for ( j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] - arr [ j ] ) == 0 || Math . abs ( arr [ i ] - arr [ j ] ) == k ) { if ( ! s . has ( arr [ j ] ) ) { if ( s . size == 2 ) break ; else s . add ( arr [ j ] ) ; } } else break ; } if ( s . size == 2 ) { Max = Math . max ( Max , j - i ) ; s . clear ; } else s . clear ; } return Max ; }
function printDiagonal ( K , N , M ) { let startrow , startcol ; if ( K - 1 < N ) { startrow = K - 1 ; startcol = 0 ; } else { startrow = N - 1 ; startcol = K - N ; } for ( ; startrow >= 0 && startcol < N ; startrow -- , startcol ++ ) { document . write ( M [ startrow ] [ startcol ] + "▁" ) ; } }
function generateSequence ( freq , n ) { let m = new Map ( ) ; let total = 0 ; for ( let i = 0 ; i < n ; i ++ ) { m . set ( i , freq [ i ] ) ; total += freq [ i ] ; } for ( let i = 0 ; i < n ; i ++ ) { if ( m . has ( i ) ) { let sequence = [ ] ; let mcopy = new Map ( ) ; for ( let [ key , value ] of m . entries ( ) ) { mcopy . set ( key , value ) ; } if ( mcopy . has ( i ) && mcopy . get ( i ) > 0 ) mcopy . set ( i , mcopy . get ( i ) - 1 ) ; sequence . push ( i ) ; let last = i ; for ( let i1 = 0 ; i1 < total - 1 ; i1 ++ ) { if ( mcopy . has ( last - 1 ) && mcopy . get ( last - 1 ) > 0 ) { mcopy . set ( last - 1 , mcopy . get ( last - 1 ) - 1 ) ; sequence . push ( last - 1 ) ; last -- ; } else if ( mcopy . has ( last + 1 ) ) { mcopy . set ( last + 1 , mcopy . get ( last + 1 ) - 1 ) ; sequence . push ( last + 1 ) ; last ++ ; } else break ; } if ( sequence . length == total ) { return sequence ; } } } let empty = [ ] ; return empty ; }
function getMinimumDistance ( a , n ) { var min_set = new Set ( ) ; var max_set = new Set ( ) ; var max = 0 , min = 1000000000 ; var frequency = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( frequency . has ( a [ i ] ) ) frequency . set ( a [ i ] , frequency . get ( a [ i ] ) + 1 ) else frequency . set ( a [ i ] , 1 ) } for ( var i = 0 ; i < n ; i ++ ) { var count = frequency . get ( a [ i ] ) ; if ( count == max ) { max_set . add ( a [ i ] ) ; } else if ( count > max ) { max_set = new Set ( ) ; max = count ; max_set . add ( a [ i ] ) ; } if ( count == min ) { min_set . add ( a [ i ] ) ; } else if ( count < min ) { min_set = new Set ( ) ; min = count ; min_set . add ( a [ i ] ) ; } } var min_dist = 1000000000 ; var last_min_found = - 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( min_set . has ( a [ i ] ) ) last_min_found = i ; if ( max_set . has ( a [ i ] ) && last_min_found != - 1 ) { if ( ( i - last_min_found ) < min_dist ) min_dist = i - last_min_found ; } } last_min_found = - 1 ; for ( var i = n - 1 ; i >= 0 ; i -- ) { if ( min_set . has ( a [ i ] ) ) last_min_found = i ; if ( max_set . has ( a [ i ] ) && last_min_found != - 1 ) { if ( ( last_min_found - i ) > min_dist ) min_dist = last_min_found - i ; } } document . write ( min_dist ) ; }
function printNum ( L , R ) { for ( let i = L ; i <= R ; i ++ ) { let temp = i ; let c = 10 ; let flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) document . write ( i + "▁" ) ; } }
function findPair ( arr , n ) { var i , j ; if ( n < 2 ) { document . write ( "-1" ) ; } var hashMap = new Set ( ) ; for ( var k = 0 ; k < n ; k ++ ) { hashMap . add ( arr [ k ] ) ; } for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { var sum = arr [ i ] + arr [ j ] ; if ( ! hashMap . has ( sum ) ) { document . write ( "(" + arr [ i ] + ",▁" + arr [ j ] + ")" ) ; } } } }
function findLengthOfMaxSubset ( arr , n , m ) { let s = new Set ( ) ; let answer = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let tmp = arr [ i ] ; if ( tmp != m ) { s . add ( tmp ) ; answer ++ ; } } let min = 1 ; while ( s . has ( min ) ) { min ++ ; } if ( min != m ) { answer = - 1 ; } return answer ; }
function getDiameterPath ( vertex , targetVertex , parent , path ) { if ( vertex == targetVertex ) { path . push ( vertex ) ; return true ; } for ( let i = 0 ; i < tree . get ( vertex ) . length ; i ++ ) { if ( tree . get ( vertex ) [ i ] == parent ) continue ; if ( getDiameterPath ( tree . get ( vertex ) [ i ] , targetVertex , vertex , path ) ) { path . push ( vertex ) ; return true ; } } return false ; }
function addedge ( a , b ) { if ( tree . get ( a ) == null ) tree . set ( a , [ ] ) ; tree . get ( a ) . push ( b ) ; if ( tree . get ( b ) == null ) tree . set ( b , [ ] ) ; tree . get ( b ) . push ( a ) ; }
function FindCenter ( n ) { maxHeight = - 1 ; maxHeightNode = - 1 ; farthestNode ( 0 , - 1 , 0 ) ; let leaf1 = maxHeightNode ; maxHeight = - 1 ; farthestNode ( maxHeightNode , - 1 , 0 ) ; let leaf2 = maxHeightNode ; path = [ ] ; getDiameterPath ( leaf1 , leaf2 , - 1 , path ) ; let pathSize = path . length ; if ( pathSize % 2 == 1 ) { document . write ( path [ parseInt ( pathSize / 2 , 10 ) ] ) ; } else { document . write ( path [ parseInt ( pathSize / 2 , 10 ) ] + ",▁" + path [ parseInt ( ( pathSize - 1 ) / 2 , 10 ) ] ) ; } }
function countSubsquare ( arr , n , X ) { var dp = Array ( n + 1 ) ; for ( var i = 0 ; i < n + 1 ; i ++ ) dp [ i ] = Array ( m + 1 ) . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { dp [ i + 1 ] [ j + 1 ] = arr [ i ] [ j ] ; } } for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; } } var cnt = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= m ; j ++ ) { var lo = 1 ; var hi = Math . min ( n - i , m - j ) + 1 ; var found = false ; while ( lo <= hi ) { var mid = parseInt ( ( lo + hi ) / 2 ) ; var ni = i + mid - 1 ; var nj = j + mid - 1 ; var sum = dp [ ni ] [ nj ] - dp [ ni ] [ j - 1 ] - dp [ i - 1 ] [ nj ] + dp [ i - 1 ] [ j - 1 ] ; if ( sum >= X ) { if ( sum == X ) { found = true ; } hi = mid - 1 ; } else { lo = mid + 1 ; } } if ( found == true ) { cnt ++ ; } } } return cnt ; }
function countSub ( str ) { var n = str . length ; var ans = 0 ; var cnt = Array ( 26 ) . fill ( 0 ) ; var i = 0 , j = 0 ; while ( i < n ) { if ( j < n && ( cnt [ str [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] == 0 ) ) { cnt [ str [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; ans += ( j - i + 1 ) ; j ++ ; } else { cnt [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] -- ; i ++ ; } } return ans ; }
function findMaxValue ( N , K ) { let packages ; let maxi = 1 ; for ( let i = 1 ; i <= K ; i ++ ) { if ( N % i == 0 ) maxi = Math . max ( maxi , i ) ; } packages = parseInt ( N / maxi ) ; document . write ( packages ) ; }
function max_sum_subarray ( arr , L , R ) { let n = arr . length ; let pre = new Array ( n ) ; pre [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } let s1 = [ ] s1 . push ( 0 ) ; let ans = Number . MIN_VALUE ; ans = Math . max ( ans , pre [ L - 1 ] ) ; let flag = 0 ; for ( let i = L ; i < n ; i ++ ) { if ( i - R >= 0 ) { if ( flag == 0 ) { let it = s1 . indexOf ( 0 ) ; s1 . splice ( it , 1 ) ; flag = 1 ; } } if ( i - L >= 0 ) s1 . push ( pre [ i - L ] ) ; ans = Math . max ( ans , pre [ i ] - s1 [ 0 ] ) ; if ( i - R >= 0 ) { let it = s1 . indexOf ( pre [ i - R ] ) ; s1 . splice ( it , 1 ) ; } } document . write ( ans ) ; }
function rowWise ( v , n , m , k ) { var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var countcons = 0 ; for ( var j = 0 ; j < m ; j ++ ) { if ( ( v + i * m + j ) == "1" ) { countcons = 0 ; } else { countcons ++ ; } if ( countcons >= k ) { ans ++ ; } } } return ans ; }
function colWise ( v , n , m , k ) { var ans = 0 ; for ( var i = 0 ; i < m ; i ++ ) { var countcons = 0 ; for ( var j = 0 ; j < n ; j ++ ) { if ( ( v + j * n + i ) == "1" ) { countcons = 0 ; } else { countcons ++ ; } if ( countcons >= k ) { ans ++ ; } } } return ans ; }
function solve ( a , n ) { let mx = 0 ; for ( let j = 1 ; j < n ; j ++ ) { if ( mx > a [ j ] ) return false ; mx = Math . max ( mx , a [ j - 1 ] ) ; } return true ; }
function count ( v , n ) { let i , odd = 0 , even = 0 ; let j , d , count ; let t = 1 << v . length ; let size = v . length ; for ( i = 1 ; i < t ; i ++ ) { d = 1 ; count = 0 ; for ( j = 0 ; j < size ; j ++ ) { if ( ( i & ( 1 << j ) ) > 0 ) { d *= v [ j ] ; count ++ ; } } if ( count % 2 == 1 ) odd += n / d ; else even += n / d ; } return ( odd - even ) ; }
function BinarySearch ( l , r , v , key ) { let mid ; while ( r - l > 1 ) { mid = Math . floor ( ( l + r ) / 2 ) ; if ( key <= count ( v , mid ) ) { r = mid ; } else { l = mid ; } } if ( key == count ( v , l ) ) return l ; else return r ; }
function sieve ( ) { for ( var i = 0 ; i < 100005 ; i ++ ) spf [ i ] = - 1 ; for ( var i = 2 ; i * i <= 100005 ; i ++ ) { for ( var j = i ; j <= 100005 ; j += i ) { if ( spf [ j ] == - 1 ) { spf [ j ] = i ; } } } }
function findPrimeFactors ( s , n ) { while ( n > 1 ) { s . add ( spf [ n ] ) ; n /= spf [ n ] ; } return s ; }
function MinimumSteps ( n , m ) { var q = [ ] ; var s = new Set ( ) ; q . push ( new pair ( n , 0 ) ) ; while ( q . length != 0 ) { var newNum = q [ 0 ] . first ; var distance = q [ 0 ] . second ; q . shift ( ) ; var k = findPrimeFactors ( s , newNum ) ; for ( var i of k ) { if ( newNum == m ) { return distance ; } else if ( newNum > m ) { break ; } else { q . push ( new pair ( newNum + i , distance + 1 ) ) ; } } } return - 1 ; }
function maxSide ( a , n ) { let sideLength = 0 ; a . sort ( ) ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] > sideLength ) { sideLength ++ ; } else { break ; } } document . write ( sideLength ) ; }
function medianChange ( arr1 , arr2 ) { let N = arr1 . length ; let median = [ ] ; if ( ( N & 1 ) ) median . push ( ( arr1 [ Math . floor ( N / 2 ) ] * 1 ) ) ; else median . push ( Math . floor ( ( arr1 [ Math . floor ( N / 2 ) ] + arr1 [ Math . floor ( ( N - 1 ) / 2 ) ] ) / 2 ) ) ; for ( let x = 0 ; x < arr2 . length ; x ++ ) { let it = arr1 . indexOf ( arr2 [ x ] ) ; arr1 . splice ( it , 1 ) ; N -- ; if ( ( N & 1 ) ) { median . push ( arr1 [ Math . floor ( N / 2 ) ] * 1 ) ; } else { median . push ( Math . floor ( ( arr1 [ Math . floor ( N / 2 ) ] + arr1 [ Math . floor ( ( N - 1 ) / 2 ) ] ) / 2 ) ) ; } } for ( let i = 0 ; i < median . length - 1 ; i ++ ) { document . write ( ( median [ i + 1 ] - median [ i ] ) + "▁" ) ; } }
function countPairs ( X , Y , m , n ) { let suffix = Array . from ( { length : 1005 } , ( _ , i ) => 0 ) ; let total_pairs = 0 ; for ( let i = 0 ; i < n ; i ++ ) suffix [ Y [ i ] ] ++ ; for ( let i = 1e3 ; i >= 3 ; i -- ) suffix [ i ] += suffix [ i + 1 ] ; for ( let i = 0 ; i < m ; i ++ ) { if ( X [ i ] == 0 ) continue ; else if ( X [ i ] == 1 ) { total_pairs += suffix [ 0 ] ; continue ; } else if ( X [ i ] == 2 ) total_pairs += suffix [ 5 ] ; else if ( X [ i ] == 3 ) total_pairs += suffix [ 2 ] + suffix [ 4 ] ; else total_pairs += suffix [ X [ i ] + 1 ] ; total_pairs += suffix [ 0 ] + suffix [ 1 ] ; } return total_pairs ; }
function solve ( A , N , M ) { var B = Array . from ( Array ( N ) , ( ) => Array ( M ) ) ; var c = 1 ; var s = new Set ( ) ; for ( var i = 0 ; i < N ; i ++ ) { for ( var j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = c ++ ; } for ( var i = 0 ; i < N ; i ++ ) { for ( var j = 0 ; j < M ; j ++ ) { if ( i != 0 ) { if ( A [ i - 1 ] [ j ] == A [ i ] [ j ] ) B [ i - 1 ] [ j ] = B [ i ] [ j ] ; } if ( i != N - 1 ) { if ( A [ i + 1 ] [ j ] == A [ i ] [ j ] ) B [ i + 1 ] [ j ] = B [ i ] [ j ] ; } if ( j != 0 ) { if ( A [ i ] [ j - 1 ] == A [ i ] [ j ] ) B [ i ] [ j - 1 ] = B [ i ] [ j ] ; } if ( j != M - 1 ) { if ( A [ i ] [ j + 1 ] == A [ i ] [ j ] ) B [ i ] [ j + 1 ] = B [ i ] [ j ] ; } } } for ( var i = 0 ; i < N ; i ++ ) { for ( var j = 0 ; j < M ; j ++ ) s . add ( B [ i ] [ j ] ) ; } return s . size ; }
function splitArray ( start , end , arr , prefix_sum ) { if ( start >= end ) return 0 ; for ( let k = start ; k < end ; ++ k ) { if ( ( prefix_sum [ k ] - prefix_sum [ start - 1 ] ) == ( prefix_sum [ end ] - prefix_sum [ k ] ) ) { return 1 + splitArray ( start , k , arr , prefix_sum ) + splitArray ( k + 1 , end , arr , prefix_sum ) ; } } return 0 ; }
function solve ( arr , n ) { let prefix_sum = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; prefix_sum [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i - 1 ] ; } document . write ( splitArray ( 1 , n , arr , prefix_sum ) ) ; }
function minDiff ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) a [ i ] *= 2 ; } a . sort ( ( a , b ) => a - b ) ; let mindifference = a [ 1 ] - a [ 0 ] ; for ( let i = 1 ; i < a . length ; i ++ ) { mindifference = Math . min ( mindifference , a [ i ] - a [ i - 1 ] ) ; } document . write ( mindifference ) ; }
function countFac ( n ) { var m = n ; var count = 0 ; for ( var i = 2 ; ( i * i ) <= m ; ++ i ) { var total = 0 ; while ( n % i == 0 ) { n /= i ; ++ total ; } var temp = 0 ; for ( var j = 1 ; ( temp + j ) <= total ; ++ j ) { temp += j ; ++ count ; } } if ( n != 1 ) ++ count ; return count ; }
function findMissing ( arr , left , right , diff ) { if ( right <= left ) return 0 ; let mid = left + parseInt ( ( right - left ) / 2 , 10 ) ; if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ; if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ; if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return findMissing ( arr , mid + 1 , right , diff ) ; return findMissing ( arr , left , mid - 1 , diff ) ; }
function missingElement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let diff = parseInt ( ( arr [ n - 1 ] - arr [ 0 ] ) / n , 10 ) ; return findMissing ( arr , 0 , n - 1 , diff ) ; }
function check ( A , B , C , D , x ) { var ans ; ans = ( A * x * x * x + B * x * x + C * x + D ) ; return ans ; }
function findSolution ( A , B , C , D , E ) { var start = 0 , end = 100000 ; var mid , ans ; while ( start <= end ) { mid = parseInt ( start + ( end - start ) / 2 ) ; ans = check ( A , B , C , D , mid ) ; if ( ans == E ) { document . write ( mid ) ; return ; } if ( ans < E ) start = mid + 1 ; else end = mid - 1 ; } document . write ( "NA" ) ; }
function findParent ( height , node ) { let start = 1 ; let end = Math . pow ( 2 , height ) - 1 ; if ( end == node ) return - 1 ; while ( node >= 1 ) { end = end - 1 ; let mid = start + parseInt ( ( end - start ) / 2 , 10 ) ; if ( mid == node end == node ) { return ( end + 1 ) ; } else if ( node < mid ) { end = mid ; } else { start = mid ; } } return - 1 ; }
function findValue ( R , C ) { let k = ( R * ( R - 1 ) ) / 2 + 1 ; let diff = R + 1 ; for ( let i = 1 ; i < C ; i ++ ) { k = ( k + diff ) ; diff ++ ; } return k ; }
function power ( x , y ) { let temp ; if ( y == 0 ) return 1 ; temp = power ( x , Math . floor ( y / 2 ) ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
function nthRootSearch ( low , high , N , K ) { if ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( ( power ( mid , K ) <= N ) && ( power ( mid + 1 , K ) > N ) ) { return mid ; } else if ( power ( mid , K ) < N ) { return nthRootSearch ( mid + 1 , high , N , K ) ; } else { return nthRootSearch ( low , mid - 1 , N , K ) ; } } return low ; }
function get_subset_count ( arr , K , N ) { ( arr ) . sort ( function ( a , b ) { return a - b ; } ) ; let left , right ; left = 0 ; right = N - 1 ; let ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; }
function naive_find_x ( N ) { var c = 0 , i ; for ( i = 1 ; i < N ; i ++ ) { c += i * i * i ; if ( c >= N ) break ; } return i ; }
function binary_searched_find_x ( k ) { var l = 0 ; var r = k ; var ans = 0 ; while ( l <= r ) { var mid = parseInt ( l + ( r - l ) / 2 ) ; if ( Math . pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; }
function checkPerfectSquare ( N , start , last ) { let mid = parseInt ( ( start + last ) / 2 ) ; if ( start > last ) { return - 1 ; } if ( mid * mid == N ) { return mid ; } else if ( mid * mid > N ) { return checkPerfectSquare ( N , start , mid - 1 ) ; } else { return checkPerfectSquare ( N , mid + 1 , last ) ; } }
function minDistancePoints ( A , K , n ) { let m = new Map ( ) ; let q = [ ] ; for ( let i = 0 ; i < n ; ++ i ) { m . set ( A [ i ] , true ) ; q . push ( A [ i ] ) ; } let ans = [ ] ; while ( K > 0 ) { let x = q . shift ( ) ; if ( ! m . has ( x - 1 ) && K > 0 ) { m . set ( x - 1 , true ) ; q . push ( x - 1 ) ; ans . push ( x - 1 ) ; K -- ; } if ( ! m . has ( x + 1 ) && K > 0 ) { m . set ( x + 1 , true ) ; q . push ( x + 1 ) ; ans . push ( x + 1 ) ; K -- ; } } for ( let i = 0 ; i < ans . length ; i ++ ) document . write ( ans [ i ] + "▁" ) ; }
function search ( mat , n , m ) { var i , a = 1000000000 ; for ( i = 0 ; i < n ; i ++ ) { var low = 0 ; var high = m - 1 ; var mid ; var ans = 1000000000 ; while ( low <= high ) { mid = parseInt ( ( low + high ) / 2 ) ; if ( mat [ i ] [ mid ] == 1 ) { if ( mid == 0 ) { ans = 0 ; break ; } else if ( mat [ i ] [ mid - 1 ] == 0 ) { ans = mid ; break ; } } if ( mat [ i ] [ mid ] == 1 ) high = mid - 1 ; else low = mid + 1 ; } if ( ans < a ) a = ans ; } if ( a == 1000000000 ) return - 1 ; return a + 1 ; }
function findNumbers ( N , M ) { let m = M ; let remLen = new Map ( ) ; let len , remainder = 0 ; for ( len = 1 ; len <= N + 1 ; ++ len ) { remainder = M % N ; if ( ! remLen . has ( remainder ) ) { remLen . set ( remainder , len ) ; } else { break ; } M = M * 10 + m ; M = M % N ; } let LenA = len ; let LenB = remLen . get ( remainder ) ; for ( let i = 0 ; i < LenB ; ++ i ) document . write ( m ) ; document . write ( "▁" ) ; for ( let i = 0 ; i < LenA ; ++ i ) document . write ( m ) ; }
function subMatrixSum ( i , j , len ) { return prefix_2D [ i ] [ j ] - prefix_2D [ i ] [ j - len ] - prefix_2D [ i - len ] [ j ] + prefix_2D [ i - len ] [ j - len ] ; }
function numberOfWays ( a , b , n , m , k ) { for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= m ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) prefix_2D [ i ] [ j ] = 1 ; else prefix_2D [ i ] [ j ] = 0 ; } } for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= m ; j ++ ) { prefix_2D [ i ] [ j ] += prefix_2D [ i ] [ j - 1 ] ; } } for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= m ; j ++ ) { prefix_2D [ i ] [ j ] += prefix_2D [ i - 1 ] [ j ] ; } } var answer = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= m ; j ++ ) { var low = 1 ; var high = Math . min ( i , j ) ; while ( low < high ) { var mid = ( low + high ) >> 1 ; if ( subMatrixSum ( i , j , mid ) >= k ) { high = mid ; } else { low = mid + 1 ; } } if ( subMatrixSum ( i , j , low ) >= k ) { answer += ( Math . min ( i , j ) - low + 1 ) ; } } } return answer ; }
function minpoint ( arr , n , k ) { let min_point = 0 ; for ( let i = 1 ; i < k - 1 ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) min_point += 1 ; } let final_point = min_point ; for ( let i = k ; i < n ; i ++ ) { if ( arr [ i - ( k - 1 ) ] < arr [ i - ( k - 1 ) + 1 ] && arr [ i - ( k - 1 ) ] < arr [ i - ( k - 1 ) - 1 ] ) min_point -= 1 ; if ( arr [ i - 1 ] < arr [ i ] && arr [ i - 1 ] < arr [ i - 2 ] ) min_point += 1 ; if ( min_point > final_point ) final_point = min_point ; } document . write ( final_point ) ; }
function checkMin ( arr , len ) { var smallest = Number . INFINITY , secondSmallest = Number . INFINITY ; for ( var i = 0 ; i < len ; i ++ ) { if ( arr [ i ] < smallest ) { secondSmallest = smallest ; smallest = arr [ i ] ; } else if ( arr [ i ] < secondSmallest ) { secondSmallest = arr [ i ] ; } } if ( 2 * smallest <= secondSmallest ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function find ( dividend , divisor , start , end ) { if ( start > end ) return [ 0 , dividend ] ; var mid = start + parseInt ( ( end - start ) / 2 ) ; var n = dividend - divisor * mid ; if ( n > divisor ) start = mid + 1 ; else if ( n < 0 ) end = mid - 1 ; else { if ( n == divisor ) { ++ mid ; n = 0 ; } return [ mid , n ] ; } return find ( dividend , divisor , start , end ) ; }
function divide ( dividend , divisor ) { return find ( dividend , divisor , 1 , dividend ) ; }
function get ( a , b , n ) { let lo = 0 , hi = 1e6 ; let ans = 0 ; while ( lo <= hi ) { let mid = Math . floor ( ( lo + hi ) / 2 ) ; let dig = Math . ceil ( ( mid * log ( mid , b ) + log ( a , b ) ) ) ; if ( dig > n ) { hi = mid - 1 ; } else { ans = mid ; lo = mid + 1 ; } } return ans ; }
function FindRank ( arr , length ) { document . write ( "1" + "▁" ) ; for ( i = 1 ; i < arr . length ; i ++ ) { var rank = 1 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } document . write ( rank + "▁" ) ; } }
function findFibonacci ( N ) { for ( let i = Math . floor ( N / 2 ) ; i > 1 ; i -- ) { if ( fib . has ( i ) && fib . has ( N - i ) ) { document . write ( i + "▁" + ( N - i ) ) ; return ; } } document . write ( "-1" ) ; }
function createHash ( ) { let prev = 0 , curr = 1 ; fibonacci . add ( prev ) ; fibonacci . add ( curr ) ; while ( curr <= MAX ) { let temp = curr + prev ; fibonacci . add ( temp ) ; prev = curr ; curr = temp ; } }
function checkArray ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( fibonacci . has ( arr [ i ] ) ) sum += arr [ i ] ; if ( fibonacci . has ( sum ) ) return true ; return false ; }
function compute ( sz ) { let isFib = new Array ( sz + 1 ) ; let prev = 0 , curr = 1 ; isFib [ prev ] = isFib [ curr ] = true ; while ( curr <= sz ) { let temp = curr + prev ; if ( temp <= sz ) isFib [ temp ] = true ; prev = curr ; curr = temp ; } fibUpto [ 0 ] = 1 ; for ( let i = 1 ; i <= sz ; i ++ ) { fibUpto [ i ] = fibUpto [ i - 1 ] ; if ( isFib [ i ] ) fibUpto [ i ] ++ ; } }
function countOfNumbers ( N , K ) { compute ( N ) ; let low = 1 , high = N , ans = 0 ; while ( low <= high ) { let mid = ( low + high ) >> 1 ; if ( mid - fibUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ( ans > 0 ? N - ans + 1 : 0 ) ; }
function precompute ( s , n ) { for ( var i = 0 ; i < n ; i ++ ) { f [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] [ i ] ++ ; } for ( var i = 0 ; i < 26 ; i ++ ) { for ( var j = 1 ; j < n ; j ++ ) { f [ i ] [ j ] += f [ i ] [ j - 1 ] ; } } }
function palindromicSubsequencesUtil ( L , R ) { var c , ok = 0 ; for ( var i = 0 ; i < 26 ; i ++ ) { var cnt = f [ i ] [ R ] ; if ( L > 0 ) cnt -= f [ i ] [ L - 1 ] ; if ( cnt > 1 ) { ok = 1 ; c = i ; break ; } } if ( ok == 0 ) { return - 1 ; } return c ; }
function createHash ( hash , maxElement ) { let prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { let temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } }
function longestFibSubarray ( arr , n ) { let max_val = Math . max ( ... arr ) ; let hash = new Set ( ) ; createHash ( hash , max_val ) ; let left = Array . from ( { length : n } , ( _ , i ) => 0 ) ; let right = Array . from ( { length : n } , ( _ , i ) => 0 ) ; let fibcount = 0 , res = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { left [ i ] = fibcount ; if ( hash . has ( arr [ i ] ) ) { fibcount ++ ; } else fibcount = 0 ; } fibcount = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { right [ i ] = fibcount ; if ( hash . has ( arr [ i ] ) ) { fibcount ++ ; } else fibcount = 0 ; } for ( let i = 0 ; i < n ; i ++ ) res = Math . max ( res , left [ i ] + right [ i ] ) ; return res ; }
function isPrime ( N ) { if ( N < 2 ) return false ; if ( N < 4 ) return true ; if ( ( N & 1 ) == 0 ) return false ; if ( N % 3 == 0 ) return false ; let curr = 5 , s = Math . floor ( Math . sqrt ( N ) ) ; while ( curr <= s ) { if ( N % curr == 0 ) return false ; curr += 2 ; if ( N % curr == 0 ) return false ; curr += 4 ; } return true ; }
function check ( s , p , prefix_sum , n ) { let satisfies = true ; for ( let i = 0 ; i < n ; i ++ ) { if ( i + s - 1 >= n ) break ; if ( prefix_sum [ i + s - 1 ] - ( i - 1 >= 0 ? prefix_sum [ i - 1 ] : 0 ) < p ) satisfies = false ; } return satisfies ; }
function minimumWindowSize ( x , y , p ) { let prefix_sum = new Array ( y - x + 1 ) . fill ( 0 ) ; for ( let i = x ; i <= y ; i ++ ) { if ( isPrime ( i ) ) prefix_sum [ i - x ] = 1 ; } for ( let i = 1 ; i < y - x + 1 ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] ; let low = 1 , high = y - x + 1 ; let mid ; while ( high - low > 1 ) { mid = Math . floor ( ( low + high ) / 2 ) ; if ( check ( mid , p , prefix_sum , y - x + 1 ) ) { high = mid ; } else low = mid ; } if ( check ( low , p , prefix_sum , y - x + 1 ) ) return low ; return high ; }
function preProcess ( mat , aux ) { for ( let i = 0 ; i < M ; i ++ ) aux [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 0 ; j < M ; j ++ ) aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = 1 ; j < M ; j ++ ) aux [ i ] [ j ] += aux [ i ] [ j - 1 ] ; }
function sumQuery ( aux , tli , tlj , rbi , rbj ) { let res = aux [ rbi ] [ rbj ] ; if ( tli > 0 ) res = res - aux [ tli - 1 ] [ rbj ] ; if ( tlj > 0 ) res = res - aux [ rbi ] [ tlj - 1 ] ; if ( tli > 0 && tlj > 0 ) res = res + aux [ tli - 1 ] [ tlj - 1 ] ; return res ; }
function maximumSquareSize ( mat , k ) { let aux = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { aux [ i ] = new Array ( M ) ; } preProcess ( mat , aux ) ; for ( let i = Math . min ( N , M ) ; i >= 1 ; i -- ) { let satisfies = true ; for ( let x = 0 ; x < N ; x ++ ) { for ( let y = 0 ; y < M ; y ++ ) { if ( x + i - 1 <= N - 1 && y + i - 1 <= M - 1 ) { if ( sumQuery ( aux , x , y , x + i - 1 , y + i - 1 ) > K ) satisfies = false ; } } } if ( satisfies == true ) return ( i ) ; } return 0 ; }
function preProcess ( mat , aux ) { for ( let i = 0 ; i < M ; i ++ ) aux [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 0 ; j < M ; j ++ ) aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = 1 ; j < M ; j ++ ) aux [ i ] [ j ] += aux [ i ] [ j - 1 ] ; }
function sumQuery ( aux , tli , tlj , rbi , rbj ) { let res = aux [ rbi ] [ rbj ] ; if ( tli > 0 ) res = res - aux [ tli - 1 ] [ rbj ] ; if ( tlj > 0 ) res = res - aux [ rbi ] [ tlj - 1 ] ; if ( tli > 0 && tlj > 0 ) res = res + aux [ tli - 1 ] [ tlj - 1 ] ; return res ; }
function check ( mid , aux , K ) { let satisfies = true ; for ( let x = 0 ; x < N ; x ++ ) { for ( let y = 0 ; y < M ; y ++ ) { if ( x + mid - 1 <= N - 1 && y + mid - 1 <= M - 1 ) { if ( sumQuery ( aux , x , y , x + mid - 1 , y + mid - 1 ) > K ) satisfies = false ; } } } return ( satisfies == true ) ; }
function maximumSquareSize ( mat , K ) { let aux = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { aux [ i ] = new Array ( M ) ; } preProcess ( mat , aux ) ; let low = 1 , high = Math . min ( N , M ) ; let mid ; while ( high - low > 1 ) { mid = Math . floor ( ( low + high ) / 2 ) ; if ( check ( mid , aux , K ) ) { low = mid ; } else high = mid ; } if ( check ( high , aux , K ) ) return high ; return low ; }
function createHash ( hash , maxElement ) { let prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { let temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } }
function add_factors ( n , mp ) { for ( var i = 1 ; i <= parseInt ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( parseInt ( n / i ) == i ) { if ( mp . has ( i ) ) mp . set ( i , mp . get ( i ) + 1 ) else mp . set ( i , 1 ) } else { if ( mp . has ( i ) ) mp . set ( i , mp . get ( i ) + 1 ) else mp . set ( i , 1 )  if ( mp . has ( parseInt ( n / i ) ) ) mp . set ( parseInt ( n / i ) , mp . get ( parseInt ( n / i ) ) + 1 ) else mp . set ( parseInt ( n / i ) , 1 ) } } } return mp ; }
function removeDuplicates ( arr , n ) { let st = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i < n - 2 && arr [ i ] == arr [ i + 1 ] && arr [ i ] == arr [ i + 2 ] ) continue ; else { arr [ st ] = arr [ i ] ; st ++ ; } } document . write ( "{" ) ; for ( let i = 0 ; i < st ; i ++ ) { document . write ( arr [ i ] ) ; if ( i != st - 1 ) document . write ( ",▁" ) ; } document . write ( "}" ) ; }
function permutation ( arr , n ) { let hash = new Set ( ) ; let maxEle = 0 ; for ( let i = 0 ; i < n ; i ++ ) { hash . add ( arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } if ( maxEle != n ) return false ; if ( hash . length == n ) return true ; return false ; }
function findPivot ( arr , low , high ) { if ( high < low ) return - 1 ; if ( high == low ) return low ; var mid = parseInt ( ( low + high ) / 2 ) ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) { return mid ; } if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) { return mid - 1 ; } if ( arr [ low ] > arr [ mid ] ) { return findPivot ( arr , low , mid - 1 ) ; } else { return findPivot ( arr , mid + 1 , high ) ; } }
function isRotated ( arr , n ) { var l = 0 ; var r = n - 1 ; var pivot = - 1 ; if ( arr [ l ] > arr [ r ] ) { pivot = findPivot ( arr , l , r ) ; var temp = pivot ; if ( l < pivot ) { while ( pivot > l ) { if ( arr [ pivot ] < arr [ pivot - 1 ] ) { return false ; } pivot -- ; } } else { pivot = temp ; pivot ++ ; while ( pivot < r ) { if ( arr [ pivot ] > arr [ pivot + 1 ] ) { return false ; } pivot ++ ; } } return true ; } else { return false ; } }
function state1 ( c ) { if ( c == "a" ) nfa = 2 ; else if ( c == "b" c == "c" ) nfa = 1 ; else flag = 1 ; }
function state2 ( c ) { if ( c == "a" ) nfa = 3 ; else if ( c == "b" c == "c" ) nfa = 2 ; else flag = 1 ; }
function state3 ( c ) { if ( c == "a" ) nfa = 1 ; else if ( c == "b" c == "c" ) nfa = 3 ; else flag = 1 ; }
function state4 ( c ) { if ( c == "b" ) nfa = 5 ; else if ( c == "a" c == "c" ) nfa = 4 ; else flag = 1 ; }
function state5 ( c ) { if ( c == "b" ) nfa = 6 ; else if ( c == "a" c == "c" ) nfa = 5 ; else flag = 1 ; }
function state6 ( c ) { if ( c == "b" ) nfa = 4 ; else if ( c == "a" c == "c" ) nfa = 6 ; else flag = 1 ; }
function state7 ( c ) { if ( c == "c" ) nfa = 8 ; else if ( c == "b" c == "a" ) nfa = 7 ; else flag = 1 ; }
function state9 ( c ) { if ( c == "c" ) nfa = 7 ; else if ( c == "b" c == "a" ) nfa = 9 ; else flag = 1 ; }
function checkA ( s , x ) { for ( let i = 0 ; i < x ; i ++ ) { if ( nfa == 1 ) state1 ( s [ i ] ) ; else if ( nfa == 2 ) state2 ( s [ i ] ) ; else if ( nfa == 3 ) state3 ( s [ i ] ) ; } if ( nfa == 1 ) { return true ; } else { nfa = 4 ; } }
function checkB ( s , x ) { for ( let i = 0 ; i < x ; i ++ ) { if ( nfa == 4 ) state4 ( s [ i ] ) ; else if ( nfa == 5 ) state5 ( s [ i ] ) ; else if ( nfa == 6 ) state6 ( s [ i ] ) ; } if ( nfa == 4 ) { return true ; } else { nfa = 7 ; } }
function checkC ( s , x ) { for ( let i = 0 ; i < x ; i ++ ) { if ( nfa == 7 ) state7 ( s [ i ] ) ; else if ( nfa == 8 ) state8 ( s [ i ] ) ; else if ( nfa == 9 ) state9 ( s [ i ] ) ; } if ( nfa == 7 ) { return true ; } }
function getPositionCount ( a , n ) { var count = 1 ; var min = a [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; }
function CountSubSet ( arr , n , X ) { let N = Math . pow ( 2 , n ) ; let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) if ( arr [ j ] == X ) count += 1 ; } } return count ; }
function calculatePower ( b , e ) { let ans = 1 ; while ( e > 0 ) { if ( e % 2 == 1 ) ans = ans * b ; e = e / 2 ; b = b * b ; } return ans ; }
function CountSubSet ( arr , n , X ) { let count = 0 , checkX = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == X ) { checkX = 1 ; break ; } } if ( checkX == 1 ) count = calculatePower ( 2 , n - 1 ) ; else count = 0 ; return count ; }
function build ( A , start , end , node ) { if ( start == end ) segment_tree [ node ] = A [ start ] ; else { let mid = parseInt ( ( start + end ) / 2 , 10 ) ; segment_tree [ node ] = Math . max ( build ( A , start , mid , 2 * node + 1 ) , build ( A , mid + 1 , end , 2 * node + 2 ) ) ; } return segment_tree [ node ] ; }
function query ( start , end , l , r , node ) { if ( start > r end < l ) return - 1 ; if ( start >= l && end <= r ) return segment_tree [ node ] ; let mid = parseInt ( ( start + end ) / 2 , 10 ) ; return Math . max ( query ( start , mid , l , r , 2 * node + 1 ) , query ( mid + 1 , end , l , r , 2 * node + 2 ) ) ; }
function longestSubArray ( A , N , K ) { let res = 1 ; let preSum = new Array ( N + 1 ) ; preSum [ 0 ] = A [ 0 ] ; for ( let i = 0 ; i < N ; i ++ ) preSum [ i + 1 ] = preSum [ i ] + A [ i ] ; build ( A , 0 , N - 1 , 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { let start = i , end = N - 1 , mid , max_index = i ; while ( start <= end ) { mid = parseInt ( ( start + end ) / 2 , 10 ) ; let max_element = query ( 0 , N - 1 , i , mid , 0 ) ; let expected_sum = ( mid - i + 1 ) * max_element ; let actual_sum = preSum [ mid + 1 ] - preSum [ i ] ; if ( expected_sum - actual_sum <= K ) { start = mid + 1 ; max_index = Math . max ( max_index , mid ) ; } else { end = mid - 1 ; } } res = Math . max ( res , max_index - i + 1 ) ; } return res ; }
function solve ( arr , n , k ) { var max_len = 0 , l = 0 , r = n , m ; while ( l <= r ) { m = parseInt ( ( l + r ) / 2 ) ; if ( maxSum ( arr , n , m ) > k ) r = m - 1 ; else { l = m + 1 ; max_len = m ; } } return max_len ; }
function countNums ( l , r ) { let cnt = 0 ; for ( let i = l ; i <= r ; i ++ ) { let lastDigit = ( i % 10 ) ; if ( ( lastDigit % 10 ) == 2 || ( lastDigit % 10 ) == 3 || ( lastDigit % 10 ) == 9 ) { cnt ++ ; } } return cnt ; }
function findMinimumK ( a , n , s ) { var maximum = a [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { maximum = Math . max ( maximum , a [ i ] ) ; } var low = 1 , high = maximum + 1 ; var ans = high ; while ( low <= high ) { var mid = parseInt ( ( low + high ) / 2 ) ; var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += parseInt ( ( a [ i ] / mid ) ) ; } if ( sum > s ) low = mid + 1 ; else { ans = Math . min ( ans , mid ) ; high = mid - 1 ; } } return ans ; }
function allDigits ( str , len ) { let present = Array . from ( { length : MAX } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < len ; i ++ ) { if ( isDigit ( str [ i ] ) ) { let digit = str [ i ] - "0" ; present [ digit ] = true ; } } for ( let i = 0 ; i < MAX ; i ++ ) { if ( ! present [ i ] ) return false ; } return true ; }
function isPlusPossible ( arr , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) else mp . set ( arr [ i ] , 1 ) } var foundModOne = false ; var ans = true ; mp . forEach ( ( value , key ) => { var element = key ; var frequency = value ; if ( frequency % 4 != 0 ) { if ( frequency % 4 == 1 ) { if ( foundModOne ) ans = false foundModOne = true ; } else ans = false } } ) ; return ans ; }
function merge ( v1 , v2 ) { let i = 0 , j = 0 ; let v = new Array ( ) ; while ( i < v1 . length && j < v2 . length ) { if ( v1 [ i ] <= v2 [ j ] ) { v . push ( v1 [ i ] ) ; i ++ ; } else { v . push ( v2 [ j ] ) ; j ++ ; } } for ( let k = i ; k < v1 . length ; k ++ ) v . push ( v1 [ k ] ) ; for ( let k = j ; k < v2 . length ; k ++ ) v . push ( v2 [ k ] ) ; return v ; }
function buildTree ( tree , arr , index , s , e ) { if ( s == e ) { tree [ index ] . push ( arr [ s ] ) ; return ; } let mid = Math . floor ( ( s + e ) / 2 ) ; buildTree ( tree , arr , 2 * index , s , mid ) ; buildTree ( tree , arr , 2 * index + 1 , mid + 1 , e ) ; tree [ index ] = merge ( tree [ 2 * index ] , tree [ 2 * index + 1 ] ) ; }
function query ( tree , index , s , e , l , r , k ) { if ( r < s l > e ) return 0 ; if ( s >= l && e <= r ) { return ( tree [ index ] . length - ( lowerBound ( tree [ index ] , tree [ index ] . length , k ) ) ) ; } let mid = Math . floor ( ( s + e ) / 2 ) ; return ( query ( tree , 2 * index , s , mid , l , r , k ) + query ( tree , 2 * index + 1 , mid + 1 , e , l , r , k ) ) ; }
function findGCDSum ( n , a ) { var GCDSum = 0 ; var tempGCD = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i ; j < n ; j ++ ) { tempGCD = 0 ; for ( k = i ; k <= j ; k ++ ) { tempGCD = __gcd ( tempGCD , a [ k ] ) ; } GCDSum += tempGCD ; } } return GCDSum ; }
function buildSparseTable ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { SparseTable [ i ] [ 0 ] = a [ i ] ; } for ( let j = 1 ; j <= 19 ; j ++ ) { for ( let i = 0 ; i <= n - ( 1 << j ) ; i ++ ) { SparseTable [ i ] [ j ] = __gcd ( SparseTable [ i ] [ j - 1 ] , SparseTable [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) ; } } }
function queryForGCD ( L , R ) { let returnValue ; let j = Math . floor ( Math . log ( R - L + 1 ) ) ; returnValue = __gcd ( SparseTable [ L ] [ j ] , SparseTable [ R - ( 1 << j ) + 1 ] [ j ] ) ; return returnValue ; }
function calculateSum ( a , n ) { buildSparseTable ( a , n ) ; let endPointer , startPointer , prevEndPointer , tempGCD ; let tempAns = 0 ; for ( let i = 0 ; i < n ; i ++ ) { endPointer = i ; startPointer = i ; prevEndPointer = i ; tempGCD = a [ i ] ; while ( endPointer < n ) { endPointer = nextPosition ( tempGCD , startPointer , prevEndPointer , n ) ; tempAns += ( ( endPointer - prevEndPointer ) * tempGCD ) ; prevEndPointer = endPointer ; if ( endPointer < n ) { tempGCD = __gcd ( tempGCD , a [ endPointer ] ) ; } } } return tempAns ; }
function isSquarePossible ( arr , n , l ) { let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= l ) cnt ++ ; if ( cnt >= l ) return true ; } return false ; }
function maxArea ( arr , n ) { let l = 0 , r = n ; let len = 0 ; while ( l <= r ) { let m = l + Math . floor ( ( r - l ) / 2 ) ; if ( isSquarePossible ( arr , n , m ) ) { len = m ; l = m + 1 ; } else r = m - 1 ; } return ( len * len ) ; }
function find_triplet ( array , n ) { var answer = 0 ; for ( var i = 0 ; i < n ; i ++ ) { indices [ array [ i ] ] . push ( i ) ; } for ( var i = 0 ; i < n ; i ++ ) { var y = array [ i ] ; for ( var j = 0 ; j < ROW ; j ++ ) { var s = test [ j ] [ 1 ] * y ; if ( s % test [ j ] [ 0 ] != 0 ) continue ; if ( s % test [ j ] [ 2 ] != 0 ) continue ; var x = s / test [ j ] [ 0 ] ; var z = s / test [ j ] [ 2 ] ; if ( x > MAX z > MAX ) continue ; var l = 0 ; var r = indices [ x ] . length - 1 ; var first = - 1 ; while ( l <= r ) { var m = ( l + r ) / 2 ; if ( indices [ x ] [ m ] < i ) { first = m ; l = m + 1 ; } else { r = m - 1 ; } } l = 0 ; r = indices [ z ] . length - 1 ; var third = - 1 ; while ( l <= r ) { var m = ( l + r ) / 2 ; if ( indices [ z ] [ m ] > i ) { third = m ; r = m - 1 ; } else { l = m + 1 ; } } if ( first != - 1 && third != - 1 ) { answer += ( first + 1 ) * ( indices [ z ] . length - third ) ; } } } return answer ; }
function lcm ( A , B ) { return ( A * B ) / gcd ( A , B ) ; }
function checkA ( A , B , C , K ) { var start = 1 ; var end = K ; var ans = - 1 ; while ( start <= end ) { var mid = parseInt ( ( start + end ) / 2 ) ; var value = A * mid ; var divA = mid - 1 ; var divB = parseInt ( value % B === 0 ? value / B - 1 : value / B ) ; var divC = parseInt ( value % C === 0 ? value / C - 1 : value / C ) ; var divAB = parseInt ( value % lcm ( A , B ) === 0 ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ) ; var divBC = parseInt ( value % lcm ( C , B ) === 0 ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ) ; var divAC = parseInt ( value % lcm ( A , C ) === 0 ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ) ; var divABC = parseInt ( value % lcm ( A , lcm ( B , C ) ) === 0 ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ) ; var elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem === K - 1 ) { ans = value ; break ; } else if ( elem > K - 1 ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; }
function checkB ( A , B , C , K ) { var start = 1 ; var end = K ; var ans = - 1 ; while ( start <= end ) { var mid = parseInt ( ( start + end ) / 2 ) ; var value = B * mid ; var divB = mid - 1 ; var divA = parseInt ( value % A === 0 ? value / A - 1 : value / A ) ; var divC = parseInt ( value % C === 0 ? value / C - 1 : value / C ) ; var divAB = parseInt ( value % lcm ( A , B ) === 0 ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ) ; var divBC = parseInt ( value % lcm ( C , B ) === 0 ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ) ; var divAC = parseInt ( value % lcm ( A , C ) === 0 ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ) ; var divABC = parseInt ( value % lcm ( A , lcm ( B , C ) ) === 0 ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ) ; var elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem === K - 1 ) { ans = value ; break ; } else if ( elem > K - 1 ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; }
function checkC ( A , B , C , K ) { var start = 1 ; var end = K ; var ans = - 1 ; while ( start <= end ) { var mid = parseInt ( ( start + end ) / 2 ) ; var value = C * mid ; var divC = mid - 1 ; var divB = parseInt ( value % B === 0 ? value / B - 1 : value / B ) ; var divA = parseInt ( value % A === 0 ? value / A - 1 : value / A ) ; var divAB = parseInt ( value % lcm ( A , B ) === 0 ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ) ; var divBC = parseInt ( value % lcm ( C , B ) === 0 ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ) ; var divAC = parseInt ( value % lcm ( A , C ) === 0 ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ) ; var divABC = parseInt ( value % lcm ( A , lcm ( B , C ) ) === 0 ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ) ; var elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem === K - 1 ) { ans = value ; break ; } else if ( elem > K - 1 ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; }
function findKthMultiple ( A , B , C , K ) { var res = checkA ( A , B , C , K ) ; console . log ( res ) ; if ( res === - 1 ) res = checkB ( A , B , C , K ) ; if ( res === - 1 ) res = checkC ( A , B , C , K ) ; return res ; }
function kthSmallest ( a , left , right , k ) { while ( left <= right ) { let pivotIndex = partition ( a , left , right ) ; if ( pivotIndex == k - 1 ) return a [ pivotIndex ] ; else if ( pivotIndex > k - 1 ) right = pivotIndex - 1 ; else left = pivotIndex + 1 ; } return - 1 ; }
function calculateDifference ( arr , n ) { let max_val = Math . max ( ... arr ) ; let prime = new Array ( max_val + 1 ) . fill ( true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } let X1 = 1 , X2 = 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { X1 ^= arr [ i ] ; } else if ( arr [ i ] != 1 ) { X2 ^= arr [ i ] ; } } return Math . abs ( X1 - X2 ) ; }
function containsElement ( arr , n ) { let xorArr = 0 ; for ( let i = 0 ; i < n ; ++ i ) xorArr ^= arr [ i ] ; for ( let i = 0 ; i < n ; ++ i ) { let x = xorArr ^ arr [ i ] ; if ( arr [ i ] == x ) return true ; } return false ; }
function Square ( n , i , j ) { var mid = ( ( i + j ) / 2 ) ; var mul = mid * mid ; if ( ( mul == n ) || ( Math . abs ( mul - n ) < 0.00001 ) ) return mid ; else if ( mul < n ) return Square ( n , mid , j ) ; else return Square ( n , i , mid ) ; }
function length_substring ( S , K ) { let curr_cnt = 0 , prev_cnt = 0 , max_len ; for ( let i = 0 ; i < S . length ; i ++ ) { if ( S [ i ] == K ) { curr_cnt += 1 ; } else { prev_cnt = Math . max ( prev_cnt , curr_cnt ) ; curr_cnt = 0 ; } } prev_cnt = Math . max ( prev_cnt , curr_cnt ) ; max_len = prev_cnt ; return max_len ; }
function Xor_Sum ( arr , n ) { let sum = 0 , index , left_xor = 0 , right_xor = 0 ; for ( let i = 0 ; i < n ; i ++ ) { left_xor = left_xor ^ arr [ i ] ; right_xor = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) { right_xor = right_xor ^ arr [ j ] ; } if ( left_xor + right_xor > sum ) { sum = left_xor + right_xor ; index = i ; } } return index + 1 ; }
function ComputePrefixXor ( arr , PrefixXor , n ) { PrefixXor [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) PrefixXor [ i ] = PrefixXor [ i - 1 ] ^ arr [ i ] ; }
function Xor_Sum ( arr , n ) { let PrefixXor = new Array ( n ) ; ComputePrefixXor ( arr , PrefixXor , n ) ; let sum = 0 , index ; for ( let i = 0 ; i < n ; i ++ ) { if ( PrefixXor [ i ] + ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) > sum ) { sum = PrefixXor [ i ] + ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) ; index = i ; } } return index + 1 ; }
function buildMapWithColor ( arr , n ) { let mapWithColor = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { mapWithColor . set ( arr [ i ] , i + 1 ) ; } return mapWithColor ; }
function isPalindrome ( str , i , j ) { while ( i < j ) { if ( str [ i ] !== str [ j ] ) { return false ; } i ++ ; j -- ; } return true ; }
function maxLenPalindrome ( str , n , ch ) { var maxLen = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] === ch ) { for ( var j = n - 1 ; j >= i ; j -- ) { if ( str [ j ] === ch ) { if ( isPalindrome ( str , i , j ) ) { maxLen = Math . max ( maxLen , j - i + 1 ) ; break ; } } } } } return maxLen ; }
function findCount ( a , b , n , m ) { var freq = new Array ( MAX ) . fill ( 0 ) ; var smallestFreq = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { var s = a [ i ] ; for ( var l = 0 ; l < freq . length ; l ++ ) freq [ l ] = 0 ; for ( var j = 0 ; j < s . length ; j ++ ) { freq [ s [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } for ( var j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] > 0 ) { smallestFreq . push ( freq [ j ] ) ; break ; } } } smallestFreq . sort ( ) ; var ans = [ ] ; for ( var i = 0 ; i < m ; i ++ ) { var s = b [ i ] ; for ( var l = 0 ; l < freq . length ; l ++ ) freq [ l ] = 0 ; for ( var j = 0 ; j < s . length ; j ++ ) { freq [ s [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } var frequency = 0 ; for ( var j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] > 0 ) { frequency = freq [ j ] ; break ; } } var array = new Array ( smallestFreq . length ) . fill ( 0 ) ; var k = 0 ; for ( const val of smallestFreq ) { array [ k ] = val ; k ++ ; } var ind = lower_bound ( array , 0 , smallestFreq . length , frequency ) ; ans . push ( ind ) ; } return ans ; }
function printAnswer ( a , b , n , m ) { var ans = findCount ( a , b , n , m ) ; for ( const it of ans ) { document . write ( it + "▁" ) ; } }
function linearCheck ( ar , arr ) { for ( let i = 0 ; i < m ; i ++ ) { let matched = true ; for ( let j = 0 ; j < n ; j ++ ) { if ( ar [ i ] [ j ] != arr [ j ] ) { matched = false ; break ; } } if ( matched ) return i + 1 ; } return - 1 ; }
function compareRow ( a1 , a2 ) { for ( var i = 0 ; i < n ; i ++ ) { if ( a1 [ i ] < a2 [ i ] ) return 1 ; else if ( a1 [ i ] > a2 [ i ] ) return - 1 ; } return 0 ; }
function binaryCheck ( ar , arr ) { var l = 0 , r = m - 1 ; while ( l <= r ) { var mid = parseInt ( ( l + r ) / 2 ) ; var temp = compareRow ( ar [ mid ] , arr ) ; if ( temp == 0 ) return mid + 1 ; else if ( temp == 1 ) l = mid + 1 ; else r = mid - 1 ; } return - 1 ; }
function findCnt ( arr , n , k ) { var ans = 0 ; for ( var i = 1 ; i < n ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; if ( arr [ i ] > k arr [ i ] < - 1 * k ) ans ++ ; } if ( arr [ 0 ] > k arr [ 0 ] < - 1 * k ) ans ++ ; arr . sort ( ( a , b ) => a - b )  for ( var i = 0 ; i < n ; i ++ ) ans += ( n - upper_bound ( arr , 0 , n , arr [ i ] + k ) ) ; return ans ; }
function FindIntersection ( type1 , n , type2 , m ) { let ans = n * m ; let start = [ ] ; let end = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { start . push ( type1 [ i ] [ 0 ] ) ; end . push ( type1 [ i ] [ 1 ] ) ; } start . sort ( function ( a , b ) { return a - b ; } ) ; end . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < m ; i ++ ) { let L = type2 [ i ] [ 0 ] ; let R = type2 [ i ] [ 1 ] ; ans -= start . length - upperBound ( start , 0 , start . length , R ) ; ans -= upperBound ( end , 0 , end . length , L - 1 ) ; } return ans ; }
function lcm ( a , b ) { return parseInt ( ( a * b ) / gcd ( a , b ) ) ; }
function divTermCount ( a , b , c , num ) { return ( parseInt ( num / a ) + parseInt ( num / b ) + parseInt ( num / c ) - parseInt ( num / lcm ( a , b ) ) - parseInt ( num / lcm ( b , c ) ) - parseInt ( num / lcm ( a , c ) ) + parseInt ( num / lcm ( a , lcm ( b , c ) ) ) ) ; }
function findNthTerm ( a , b , c , n ) { let low = 1 , high = Number . MAX_VALUE , mid ; while ( low < high ) { mid = low + parseInt ( ( high - low ) / 2 ) ; if ( divTermCount ( a , b , c , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; }
function setZero ( freq ) { for ( var i = 0 ; i < MAX ; i ++ ) freq [ i ] = 0 ; }
function preCalculate ( str , n ) { freq [ str [ 0 ] . charCodeAt ( ) ] [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { let ch = str [ i ] ; for ( let j = 0 ; j < MAX ; j ++ ) { let charToUpdate = String . fromCharCode ( j ) ; if ( charToUpdate == ch ) freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 ; else freq [ j ] [ i ] = freq [ j ] [ i - 1 ] ; } } }
function getFrequency ( ch , l , r ) { if ( l == 0 ) return freq [ ch . charCodeAt ( ) ] [ r ] ; else return ( freq [ ch . charCodeAt ( ) ] [ r ] - freq [ ch . charCodeAt ( ) ] [ l - 1 ] ) ; }
function firstNonRepeating ( str , n , l , r ) { for ( let i = l ; i < r ; i ++ ) { let ch = str [ i ] ; if ( getFrequency ( ch , l , r ) == 1 ) return ( "" + ch ) ; } return "-1" ; }
function maxLength ( s , n ) { var ans = - 2147483648 ; var A = [ ] ; var L = [ ] ; var R = [ ] ; var freq = new Array ( n + 5 ) . fill ( 0 ) ; for ( var i = 0 ; i < 26 ; i ++ ) { var count = 0 ; for ( var j = 0 ; j < n ; j ++ ) { if ( s [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) === i ) count ++ ; freq [ j ] = count ; } for ( var j = 1 ; j < n ; j ++ ) { L . push ( 2 * freq [ j - 1 ] - j ) ; R . push ( 2 * freq [ j ] - j ) ; } var max_len = - 2147483648 ; var min_val = 2147483648 ; for ( var j = 0 ; j < L . length ; j ++ ) { min_val = Math . min ( min_val , L [ j ] ) ; A . push ( min_val ) ; var l = 0 , r = j ; while ( l <= r ) { var mid = ( l + r ) >> 1 ; if ( A [ mid ] <= R [ j ] ) { max_len = Math . max ( max_len , j - mid + 1 ) ; r = mid - 1 ; } else { l = mid + 1 ; } } } ans = Math . max ( ans , max_len ) ; A = [ ] ; R = [ ] ; L = [ ] ; } return ans ; }
function minOperations ( arr , n ) { var start = arr [ n - 1 ] ; var end = arr . reduce ( ( a , b ) => Math . max ( a , b ) ) + n ; var max_arr = 0 ; while ( start <= end ) { var mid = parseInt ( ( start + end ) / 2 ) ; if ( check ( mid , n , arr ) ) { max_arr = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } var desired = Array ( n ) ; for ( var i = n - 1 ; i >= 0 ; i -- ) { desired [ i ] = max_arr ; max_arr -- ; } var operations = 0 ; for ( var i = 0 ; i < n ; i ++ ) { operations += ( desired [ i ] - arr [ i ] ) ; } return operations ; }
function countNode ( head ) { let count = 0 ; while ( head . next != null ) { let ptr = head . next ; while ( ptr != null ) { if ( head . data == ptr . data ) { count ++ ; break ; } ptr = ptr . next ; } head = head . next ; } return count ; }
function insert ( head , item ) { var temp = new Node ( ) ; temp . data = item ; temp . next = head ; head = temp ; return head ; }
function countNode ( head ) { if ( head == null ) return 0 ; ; var s = new Set ( ) ; s . add ( head . data ) ; var count = 0 ; for ( var curr = head . next ; curr != null ; curr = curr . next ) { if ( s . has ( curr . data ) ) count ++ ; s . add ( curr . data ) ; } return count ; }
function countLessThan ( arr , n , key ) { let l = 0 , r = n - 1 ; let index = - 1 ; while ( l <= r ) { let m = Math . floor ( ( l + r ) / 2 ) ; if ( arr [ m ] < key ) { l = m + 1 ; index = m ; } else { r = m - 1 ; } } return ( index + 1 ) ; }
function countGreaterThan ( arr , n , key ) { let l = 0 , r = n - 1 ; let index = - 1 ; while ( l <= r ) { let m = Math . floor ( ( l + r ) / 2 ) ; if ( arr [ m ] <= key ) { l = m + 1 ; } else { r = m - 1 ; index = m ; } } if ( index == - 1 ) return 0 ; return ( n - index ) ; }
function countTriplets ( n , a , b , c ) { a . sort ( function ( e , f ) { return e - f ; } ) ; b . sort ( function ( e , f ) { return e - f ; } ) ; c . sort ( function ( e , f ) { return e - f ; } ) ; let count = 0 ; for ( let i = 0 ; i < n ; ++ i ) { let current = b [ i ] ; let low = countLessThan ( a , n , current ) ; let high = countGreaterThan ( c , n , current ) ; count += ( low * high ) ; } return count ; }
function maximum_middle_value ( n , k , arr ) { let ans = - 1 ; let low = Math . floor ( ( n + 1 - k ) / 2 ) ; let high = Math . floor ( ( ( n + 1 - k ) / 2 ) + k ) ; for ( let i = low ; i <= high ; i ++ ) { ans = Math . max ( ans , arr [ i - 1 ] ) ; } return ans ; }
function firstRepeating ( str ) { let visited = new Array ( NO_OF_CHARS ) ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) visited [ i ] = false ; let res = - 1 ; for ( let i = str . length - 1 ; i >= 0 ; i -- ) { if ( visited [ str [ i ] . charCodeAt ( ) ] == false ) visited [ str [ i ] . charCodeAt ( ) ] = true ; else res = i ; } return res ; }
function minSteps ( arr ) { var v = Array . from ( Array ( n ) , ( ) => Array ( n ) . fill ( 0 ) ) ; var q = [ ] ; q . push ( [ 0 , 0 ] ) ; var depth = 0 ; while ( q . length != 0 ) { var x = q . length ; while ( x -- ) { var y = q [ 0 ] ; var i = y [ 0 ] , j = y [ 1 ] ; q . shift ( ) ; if ( v [ i ] [ j ] ) continue ; if ( i == n - 1 && j == n - 1 ) return depth ; v [ i ] [ j ] = 1 ; if ( i + arr [ i ] [ j ] < n ) q . push ( [ i + arr [ i ] [ j ] , j ] ) ; if ( j + arr [ i ] [ j ] < n ) q . push ( [ i , j + arr [ i ] [ j ] ] ) ; } depth ++ ; } return - 1 ; }
function minSteps ( arr , n ) { var v = Array ( n ) . fill ( 0 ) ; var q = [ ] ; q . push ( 0 ) ; var depth = 0 ; while ( q . length != 0 ) { var x = q . length ; while ( x -- ) { var i = q [ 0 ] ; q . shift ( ) ; if ( v [ i ] ) continue ; if ( i == n - 1 ) return depth ; v [ i ] = 1 ; if ( i + arr [ i ] < n ) q . push ( i + arr [ i ] ) ; if ( i - arr [ i ] >= 0 ) q . push ( i - arr [ i ] ) ; } depth ++ ; } return - 1 ; }
function divisorcount ( elem ) { let ans = 0 ; for ( let i = 1 ; i <= Math . sqrt ( elem ) ; i ++ ) { if ( elem % i == 0 ) { if ( i * i == elem ) ans ++ ; else ans += 2 ; } } return ans ; }
function findwinner ( A , B , N , M ) { for ( let i = 0 ; i < N ; i ++ ) { A [ i ] = divisorcount ( A [ i ] ) ; } for ( let i = 0 ; i < M ; i ++ ) { B [ i ] = divisorcount ( B [ i ] ) ; } A . sort ( function ( a , b ) { return a - b ; } ) ; B . sort ( function ( a , b ) { return a - b ; } ) ; let winA = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let val = A [ i ] ; let start = 0 ; let end = M - 1 ; let index = - 1 ; while ( start <= end ) { let mid = Math . floor ( ( start + end ) / 2 ) ; if ( B [ mid ] <= val ) { index = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } winA += ( index + 1 ) ; } let winB = N * M - winA ; if ( winA > winB ) { return "A" ; } else if ( winB > winA ) { return "B" ; } return "Draw" ; }
function minTime ( box , truck , n , m ) { box . sort ( function ( a , b ) { return a - b } ) ; truck . sort ( function ( a , b ) { return a - b } ) ; let l = 0 ; let h = 2 * n ; let min_time = 0 ; while ( l <= h ) { let mid = Math . floor ( ( l + h ) / 2 ) ; if ( isPossible ( box , truck , n , m , mid ) ) { min_time = mid ; h = mid - 1 ; } else l = mid + 1 ; } return min_time ; }
function isPossible ( arr , n , dist , k ) { let req = 0 ; let curr = 0 ; let prev = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( curr != n && arr [ curr ] - arr [ prev ] <= dist ) { curr ++ ; } req ++ ; if ( curr == n ) { break ; } prev = curr - 1 ; } if ( curr != n ) { return false ; } if ( req <= k ) { return true ; } return false ; }
function minDistance ( arr , n , k ) { let l = 0 ; let h = arr [ n - 1 ] ; let ans = 0 ; while ( l <= h ) { let m = Math . floor ( ( l + h ) / 2 ) ; if ( isPossible ( arr , n , m , k ) ) { ans = m ; h = m - 1 ; } else { l = m + 1 ; } } return ans ; }
function getKthElement ( n , k , L , R ) { let l = 1 ; let h = n ; let total = new Array ( n + 1 ) ; total [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { total [ i + 1 ] = total [ i ] + ( R [ i ] - L [ i ] ) + 1 ; } let index = - 1 ; while ( l <= h ) { let m = Math . floor ( ( l + h ) / 2 ) ; if ( total [ m ] > k ) { index = m ; h = m - 1 ; } else if ( total [ m ] < k ) l = m + 1 ; else { index = m ; break ; } } l = L [ index - 1 ] ; h = R [ index - 1 ] ; let x = k - total [ index - 1 ] ; while ( l <= h ) { let m = Math . floor ( ( l + h ) / 2 ) ; if ( ( m - L [ index - 1 ] ) + 1 == x ) { return m ; } else if ( ( m - L [ index - 1 ] ) + 1 > x ) h = m - 1 ; else l = m + 1 ; } return k ; }
function MinimumX ( a , b , c , k ) { let x = Number . MAX_VALUE ; if ( k <= c ) return 0 ; let h = k - c ; let l = 0 ; while ( l <= h ) { let m = Math . floor ( ( l + h ) / 2 ) ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }
function preCalculate ( binary , n , left ) { let count1 = 0 , count0 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { left [ i ] [ 0 ] = count1 ; left [ i ] [ 1 ] = count0 ; if ( binary [ i ] != 0 ) count1 ++ ; else count0 ++ ; } }
function findMissing ( arr , n ) { let l = 0 , h = n - 1 ; let mid ; while ( h > l ) { mid = l + Math . floor ( ( h - l ) / 2 ) ; if ( arr [ mid ] - mid == arr [ 0 ] ) { if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) return arr [ mid ] + 1 ; else { l = mid + 1 ; } } else { if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) return arr [ mid ] - 1 ; else { h = mid - 1 ; } } } return - 1 ; }
function maxSum ( arr , n , K ) { var maximum = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { var sumk = 0 ; for ( var j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = Math . max ( maximum , sumk ) ; } return maximum ; }
function operations ( op , n , k ) { let i , count = 0 ; let nVal = 0 ; let min = Number . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; min = Math . min ( min , nVal ) ; if ( ( k + nVal ) <= 0 ) return ( i + 1 ) ; } if ( nVal >= 0 ) return - 1 ; let times = Math . floor ( ( k - Math . abs ( min ) ) / Math . abs ( nVal ) ) ; k = ( k - ( times * Math . abs ( nVal ) ) ) ; count = ( times * n ) ; while ( k > 0 ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( k <= 0 ) break ; } } return count ; }
function findMax ( arr , low , high ) { if ( high == low ) return arr [ low ] ; let mid = low + ( high - low ) / 2 ; if ( mid == 0 && arr [ mid ] > arr [ mid + 1 ] ) { return arr [ mid ] ; } if ( mid < high && arr [ mid + 1 ] < arr [ mid ] && mid > 0 && arr [ mid ] > arr [ mid - 1 ] ) { return arr [ mid ] ; } if ( arr [ low ] > arr [ mid ] ) { return findMax ( arr , low , mid - 1 ) ; } else { return findMax ( arr , mid + 1 , high ) ; } }
function cal_prefix ( n , arr ) { for ( let i = 0 ; i < n ; i ++ ) ar [ i + 1 ] = arr [ i ] ; for ( let i = 1 ; i < MAX ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) prefix [ i ] [ j ] = 0 ; for ( let j = 1 ; j <= n ; j ++ ) { prefix [ i ] [ j ] = prefix [ i ] [ j - 1 ] + ( ar [ j ] <= i ? 1 : 0 ) ; } } }
function ksub ( l , r , n , k ) { let lo = 1 ; let hi = MAX - 1 ; while ( lo + 1 < hi ) { let mid = Math . floor ( ( lo + hi ) / 2 ) ; if ( prefix [ mid ] [ r ] - prefix [ mid ] [ l - 1 ] >= k ) hi = mid ; else lo = mid + 1 ; } if ( prefix [ lo ] [ r ] - prefix [ lo ] [ l - 1 ] >= k ) hi = lo ; return hi ; }
function binary ( arr , v ) { let index = lookup_table [ 0 ] - 1 ; let co = 0 ; while ( lookup_table [ co ] != 0 ) { if ( v == arr [ index ] ) return index ; else if ( v < arr [ index ] ) { index -= lookup_table [ ++ co ] ; return index ; } else { index += lookup_table [ ++ co ] ; return index ; } } return index ; }
function countPairs ( s1 , n1 , s2 , n2 ) { let freq1 = new Array ( 26 ) ; let freq2 = new Array ( 26 ) ; freq1 . fill ( 0 ) ; freq2 . fill ( 0 ) ; let i , count = 0 ; for ( i = 0 ; i < n1 ; i ++ ) freq1 [ s1 [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ++ ; for ( i = 0 ; i < n2 ; i ++ ) freq2 [ s2 [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) count += ( Math . min ( freq1 [ i ] , freq2 [ i ] ) ) ; return count ; }
function findSmallestX ( Y ) { let low = 0 , high = 5 * Y ; let N = 0 ; while ( low <= high ) { let mid = parseInt ( ( high + low ) / 2 ) ; if ( countFactor ( 5 , mid ) < Y ) { low = mid + 1 ; } else { N = mid ; high = mid - 1 ; } } return N ; }
function findpair ( l , r ) { let ans1 = l ; let ans2 = 2 * l ; document . write ( ans1 + ",▁" + ans2 ) ; }
function check ( arr , N , K ) { var unique = new Set ( ) ; for ( var i = 0 ; i < N ; i ++ ) unique . add ( arr [ i ] ) ; if ( unique . size == K ) return true ; return false ; }
function squareSum ( N ) { let sum = parseInt ( ( N * ( N + 1 ) * ( 2 * N + 1 ) ) / 6 ) ; return sum ; }
function findMaxN ( X ) { let N = Math . sqrt ( X ) ; for ( let i = 1 ; i <= N ; i ++ ) { if ( squareSum ( i ) > X ) return i - 1 ; } return - 1 ; }
function findMaxN ( X ) { var low = 1 , high = 100000 ; var N = 0 ; while ( low <= high ) { var mid = ( high + low ) / 2 ; if ( squareSum ( mid ) <= X ) { N = parseInt ( mid ) ; low = mid + 1 ; } else high = mid - 1 ; } return N ; }
function findNumber ( a , n , K ) { for ( var i = 0 ; i < n ; i ++ ) { if ( K >= a [ i ] [ 0 ] && K <= a [ i ] [ 1 ] ) return i ; } return - 1 ; }
function findNumber ( a , n , K ) { var low = 0 , high = n - 1 ; while ( low <= high ) { var mid = ( low + high ) >> 1 ; if ( K >= a [ mid ] . first && K <= a [ mid ] . second ) return mid ; else if ( K < a [ mid ] . first ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }
function prefixSum ( p_arr , arr , n ) { p_arr [ 0 ] = arr [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) p_arr [ i ] = arr [ i ] + p_arr [ i - 1 ] ; }
function canDivide ( p_arr , n , q , l , r ) { var sum ; if ( l == 0 ) sum = p_arr [ r ] ; else sum = p_arr [ r ] - p_arr [ l - 1 ] ; if ( sum % 2 == 1 ) { document . write ( "No" ) ; return ; } var beg = 0 ; if ( l != 0 ) beg = p_arr [ l - 1 ] ; if ( q . has ( ( beg + sum / 2 ) ) ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function findRing ( arr , x ) { if ( arr [ 0 ] [ 0 ] > x ) return - 1 ; var l = 0 , r = parseInt ( ( n + 1 ) / 2 ) - 1 ; if ( n % 2 == 1 && arr [ r ] [ r ] < x ) return - 1 ; if ( n % 2 == 0 && arr [ r + 1 ] [ r ] < x ) return - 1 ; while ( l < r ) { var mid = parseInt ( ( l + r ) / 2 ) ; if ( arr [ mid ] [ mid ] <= x ) if ( mid == ( n + 1 ) / 2 - 1 arr [ mid + 1 ] [ mid + 1 ] > x ) return mid ; else l = mid + 1 ; else r = mid - 1 ; } return r ; }
function binarySearchRowInc ( arr , row , l , r , x ) { while ( l <= r ) { var mid = parseInt ( ( l + r ) / 2 ) ; if ( arr [ row ] [ mid ] == x ) return mid ; if ( arr [ row ] [ mid ] < x ) l = mid + 1 ; else r = mid - 1 ; } return - 1 ; }
function binarySearchColumnInc ( arr , col , t , b , x ) { while ( t <= b ) { var mid = parseInt ( ( t + b ) / 2 ) ; if ( arr [ mid ] [ col ] == x ) return mid ; if ( arr [ mid ] [ col ] < x ) t = mid + 1 ; else b = mid - 1 ; } return - 1 ; }
function binarySearchRowDec ( arr , row , l , r , x ) { while ( l <= r ) { var mid = parseInt ( ( l + r ) / 2 ) ; if ( arr [ row ] [ mid ] == x ) return mid ; if ( arr [ row ] [ mid ] < x ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; }
function binarySearchColumnDec ( arr , col , t , b , x ) { while ( t <= b ) { var mid = parseInt ( ( t + b ) / 2 ) ; if ( arr [ mid ] [ col ] == x ) return mid ; if ( arr [ mid ] [ col ] < x ) b = mid - 1 ; else t = mid + 1 ; } return - 1 ; }
function minIndex ( arr , n , pos ) { var num = arr [ pos ] ; var i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; } return i + 1 ; }
function minIndex ( arr , pos ) { var low = 0 ; var high = pos ; var i = pos ; while ( low < high ) { var mid = parseInt ( ( low + high ) / 2 ) ; if ( arr [ mid ] != arr [ pos ] ) { low = mid + 1 ; } else { high = mid - 1 ; i = mid ; if ( mid > 0 && arr [ mid - 1 ] != arr [ pos ] ) { break ; } } } return arr [ low ] == arr [ pos ] ? low : i ; }
function findAnswer ( str1 , str2 , n ) { var l = 0 , r = 0 ; var ans = 2 ; for ( i = 0 ; i < n ; ++ i ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) { l = i ; break ; } } for ( i = n - 1 ; i >= 0 ; i -- ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) { r = i ; break ; } } if ( r < l ) return 26 * ( n + 1 ) ; else if ( l == r ) return ans ; else { for ( i = l + 1 ; i <= r ; i ++ ) { if ( str1 . charAt ( i ) != str2 . charAt ( i - 1 ) ) { ans -- ; break ; } } for ( i = l + 1 ; i <= r ; i ++ ) { if ( str1 . charAt ( i - 1 ) != str2 . charAt ( i ) ) { ans -- ; break ; } } return ans ; } }
function ternarySearch ( l , r , key , ar ) { if ( r >= l ) { let mid1 = l + parseInt ( ( r - l ) / 3 , 10 ) ; let mid2 = r - parseInt ( ( r - l ) / 3 , 10 ) ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { return ternarySearch ( l , mid1 - 1 , key , ar ) ; } else if ( key > ar [ mid2 ] ) { return ternarySearch ( mid2 + 1 , r , key , ar ) ; } else { return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) ; } } return - 1 ; }
function ternarySearch ( l , r , key , ar ) { while ( r >= l ) { let mid1 = l + parseInt ( ( r - l ) / 3 , 10 ) ; let mid2 = r - parseInt ( ( r - l ) / 3 , 10 ) ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { r = mid1 - 1 ; } else if ( key > ar [ mid2 ] ) { l = mid2 + 1 ; } else { l = mid1 + 1 ; r = mid2 - 1 ; } } return - 1 ; }
function countSubArrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let bitwise_or = 0 ; for ( let k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }
function build ( arr , node , start , end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } let mid = ( start + end ) >> 1 ; build ( arr , 2 * node , start , mid ) ; build ( arr , 2 * node + 1 , mid + 1 , end ) ; tree [ node ] = tree [ 2 * node ] | tree [ 2 * node + 1 ] ; }
function query ( node , start , end , l , r ) { if ( start > end start > r end < l ) { return 0 ; } if ( start >= l && end <= r ) { return tree [ node ] ; } let mid = ( start + end ) >> 1 ; let q1 = query ( 2 * node , start , mid , l , r ) ; let q2 = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return q1 | q2 ; }
function countSubArrays ( arr , n , K ) { build ( arr , 1 , 0 , n - 1 ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let bitwise_or = query ( 1 , 0 , n - 1 , i , j ) ; if ( bitwise_or >= K ) count ++ ; } } return count ; }
function build ( arr , node , start , end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } let mid = ( start + end ) >> 1 ; build ( arr , 2 * node , start , mid ) ; build ( arr , 2 * node + 1 , mid + 1 , end ) ; tree [ node ] = tree [ 2 * node ] | tree [ 2 * node + 1 ] ; }
function query ( node , start , end , l , r ) { if ( start > end start > r end < l ) { return 0 ; } if ( start >= l && end <= r ) { return tree [ node ] ; } let mid = ( start + end ) >> 1 ; let q1 = query ( 2 * node , start , mid , l , r ) ; let q2 = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return q1 | q2 ; }
function countSubArrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let low = i , high = n - 1 , index = Number . MAX_VALUE ; while ( low <= high ) { let mid = ( low + high ) >> 1 ; if ( query ( 1 , 0 , n - 1 , i , mid ) >= K ) { index = Math . min ( index , mid ) ; high = mid - 1 ; } else { low = mid + 1 ; } } if ( index != Number . MAX_VALUE ) { count += n - index ; } } return count ; }
function max_min ( a , n ) { a . sort ( ) ; return Math . min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
function max_min ( a , n ) { if ( n <= 1 ) return Number . MAX_VALUE ; let f_min = a [ 0 ] , s_min = Number . MAX_VALUE ; let f_max = a [ 0 ] , s_max = Number . MIN_VALUE ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= f_min ) { s_min = f_min ; f_min = a [ i ] ; } else if ( a [ i ] < s_min ) { s_min = a [ i ] ; } if ( a [ i ] >= f_max ) { s_max = f_max ; f_max = a [ i ] ; } else if ( a [ i ] > s_max ) { s_max = a [ i ] ; } } return Math . min ( ( f_max - s_min ) , ( s_max - f_min ) ) ; }
function findMinDifference ( arr , n ) { arr . sort ( ) ; let diff1 = arr [ n - 1 ] - arr [ 1 ] ; let diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . min ( diff1 , diff2 ) ; }
function findMinDifference ( arr , n ) { let min__ , secondMin , max__ , secondMax ; min__ = secondMax = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 0 ] : arr [ 1 ] ; max__ = secondMin = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 1 ] : arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max__ ) { secondMax = max__ ; max__ = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } else if ( arr [ i ] < min__ ) { secondMin = min__ ; min__ = arr [ i ] ; } else if ( arr [ i ] < secondMin ) { secondMin = arr [ i ] ; } } let diff = Math . min ( max__ - secondMin , secondMax - min__ ) ; return diff ; }
function minimal ( a , n ) { let lo = 0 , hi = n - 1 ; while ( lo < hi ) { let mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }
function findCount ( L , R ) { var count = 0 ; for ( i = L ; i <= R ; i ++ ) { if ( checkDistinct ( i ) ) count += 1 ; } return count ; }
function countDigits ( n ) { let count = 0 ; while ( n > 0 ) { count += 1 ; n = parseInt ( n / 10 , 10 ) ; } return count ; }
function findCount ( L , R ) { let count = 0 ; let countDigitsL = countDigits ( L ) ; let countDigitsR = countDigits ( R ) ; let firstDigitL = parseInt ( L / parseInt ( Math . pow ( 10 , countDigitsL - 1 ) , 10 ) , 10 ) ; let firstDigitR = parseInt ( R / parseInt ( Math . pow ( 10 , countDigitsR - 1 ) , 10 ) , 10 ) ; if ( countDigitsL < countDigitsR ) { count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) ; if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count += firstDigitR ; else count += ( firstDigitR - 1 ) ; } else { if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count -= ( 9 - firstDigitR ) ; else count -= ( 9 - firstDigitR + 1 ) ; } return count ; }
function LowerInsertionPoint ( arr , n , X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; let lowerPnt = 0 ; let i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }
function getRightMin ( arr , n ) { let min = arr [ 0 ] ; let rightMin = 0 ; let i = 1 ; while ( i < n ) { if ( arr [ i ] == min ) rightMin = i ; i *= 2 ; } i = rightMin + 1 ; while ( i < n && arr [ i ] == min ) { rightMin = i ; i ++ ; } return rightMin ; }
function getLeftMax ( arr , n ) { let max = arr [ n - 1 ] ; let leftMax = n - 1 ; let i = n - 2 ; while ( i > 0 ) { if ( arr [ i ] == max ) leftMax = i ; i = parseInt ( i / 2 , 10 ) ; } i = leftMax - 1 ; while ( i >= 0 && arr [ i ] == max ) { leftMax = i ; i -- ; } return leftMax ; }
function SieveOfEratosthenes ( ) { var isPrime = Array ( MAX ) . fill ( 1 ) ; isPrime [ 0 ] = isPrime [ 1 ] = 0 ; for ( var i = 2 ; i * i < MAX ; i ++ ) { if ( isPrime [ i ] ) { for ( var j = i * 2 ; j < MAX ; j += i ) isPrime [ j ] = 0 ; } } for ( var i = 1 ; i < MAX ; i ++ ) { primeUpto [ i ] = primeUpto [ i - 1 ] ; if ( isPrime [ i ] ) primeUpto [ i ] ++ ; } }
function countOfNumbers ( N , K ) { SieveOfEratosthenes ( ) ; var low = 1 , high = N , ans = 0 ; while ( low <= high ) { var mid = ( low + high ) >> 1 ; if ( mid - primeUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ( ans ? N - ans + 1 : 0 ) ; }
function minIndex ( arr , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return - 1 ; }
function smallest_pair ( a , n ) { let min = Number . MAX_VALUE , secondMin = Number . MAX_VALUE ; for ( let j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; }
function checkSorted ( n , arr ) { var first = 0 , second = 0 ; var count = 0 ; for ( var i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { count ++ ; if ( first == 0 ) first = i ; else second = i ; } } if ( count > 2 ) return false ; if ( count == 0 ) return true ; if ( count == 2 ) [ arr [ first - 1 ] , arr [ second ] ] = [ arr [ second ] , arr [ first - 1 ] ] ; else if ( count == 1 ) [ arr [ first - 1 ] , arr [ first ] ] = [ arr [ first ] , arr [ first - 1 ] ] ; for ( var i = 1 ; i < n ; i ++ ) if ( arr [ i ] < arr [ i - 1 ] ) return false ; return true ; }
function countWays ( arr , n ) { let max_val = 0 ; for ( let i = 0 ; i < n ; i ++ ) max_val = Math . max ( max_val , arr [ i ] ) ; let freq = new Array ( max_val + 1 ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; ans += freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) / 6 ; for ( let i = 1 ; i <= max_val ; i ++ ) ans += freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) / 2 ; for ( let i = 1 ; 2 * i <= max_val ; i ++ ) ans += freq [ i ] * ( freq [ i ] - 1 ) / 2 * freq [ 2 * i ] ; for ( let i = 1 ; i <= max_val ; i ++ ) { for ( let j = i + 1 ; i + j <= max_val ; j ++ ) ans += freq [ i ] * freq [ j ] * freq [ i + j ] ; } return ans ; }
function checkIndices ( Arr , N ) { for ( var i = 0 ; i < N - 1 ; i ++ ) { for ( var j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }
function LongestSubarray ( arr , n , k ) { let count = 1 ; let max_length = 1 ; let prev_mod = arr [ 0 ] % k ; for ( let i = 1 ; i < n ; i ++ ) { let curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return Math . max ( max_length , count ) ; }
function getCount ( v , n ) { v . sort ( function ( a , b ) { return a - b ; } ) ; let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let tmp = n - 1 - upperBound ( v , n , v [ i ] - 1 ) ; if ( tmp == v [ i ] ) cnt ++ ; } return cnt ; }
function binarySearch1D ( arr , K ) { var low = 0 ; var high = N - 1 ; while ( low <= high ) { var mid = low + parseInt ( ( high - low ) / 2 ) ; if ( arr [ mid ] == K ) return true ; if ( arr [ mid ] < K ) low = mid + 1 ; else high = mid - 1 ; } return false ; }
function searchMatrix ( matrix , K ) { var low = 0 ; var high = M - 1 ; while ( low <= high ) { var mid = low + parseInt ( ( high - low ) / 2 ) ; if ( K >= matrix [ mid ] [ 0 ] && K <= matrix [ mid ] [ N - 1 ] ) return binarySearch1D ( matrix [ mid ] , K ) ; if ( K < matrix [ mid ] [ 0 ] ) high = mid - 1 ; else low = mid + 1 ; } return false ; }
function longestsubarray ( arr , n , k ) { let current_count = 0 ; let max_count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) current_count ++ ; else current_count = 0 ; max_count = Math . max ( current_count , max_count ) ; } return max_count ; }
function countSegments ( a , n , x ) { let flag = false ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }
function findElements ( arr , n , l , r ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; ++ i ) { let a = 0 ; if ( mp . get ( arr [ i ] ) == null ) { a = 1 ; } else { a = mp . get ( arr [ i ] ) + 1 ; } mp . set ( arr [ i ] , a ) ; } for ( let i = 0 ; i < n ; ++ i ) { if ( l <= mp . get ( arr [ i ] ) && ( mp . get ( arr [ i ] ) <= r ) ) { document . write ( arr [ i ] + "▁" ) ; } } }
function findElementsAfterDel ( arr , m , del , n , k ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; ++ i ) { if ( mp . has ( del [ i ] ) ) { mp . set ( del [ i ] , mp . get ( del [ i ] ) + 1 ) ; } else { mp . set ( del [ i ] , 1 ) ; } } let heap = [ ] ; for ( let i = 0 ; i < m ; ++ i ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) - 1 ) ; if ( mp . get ( arr [ i ] ) == 0 ) mp . delete ( arr [ i ] ) ; } else heap . push ( arr [ i ] ) ; } heap . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < k ; ++ i ) { document . write ( heap [ 0 ] + "▁" ) ; heap . splice ( 0 , 1 ) ; } }
function removeElements ( arr , n , k ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; ++ i ) { if ( ! mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , 1 ) ; else { let x = mp . get ( arr [ i ] ) ; mp . set ( arr [ i ] , ++ x ) ; } } for ( let i = 0 ; i < n ; ++ i ) { if ( mp . get ( arr [ i ] ) >= k ) document . write ( arr [ i ] + "▁" ) ; } }
function check ( s ) { for ( let i = 0 ; i < s . length - 1 ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return true ; return false ; }
function RemoveElements ( arr , n , k ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; ++ i ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; } for ( let i = 0 ; i < n ; ++ i ) { if ( mp . has ( arr [ i ] ) && mp . get ( arr [ i ] ) <= k ) { document . write ( arr [ i ] + "▁" ) ; } } }
function findSmallestAfterDel ( arr , m , del , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; ++ i ) { if ( mp . has ( del [ i ] ) ) { mp . set ( del [ i ] , mp . get ( del [ i ] ) + 1 ) ; } else { mp . set ( del [ i ] , 1 ) ; } } let smallestElement = Number . MAX_VALUE ; for ( let i = 0 ; i < m ; ++ i ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) - 1 ) ; if ( mp . get ( arr [ i ] ) == 0 ) mp . delete ( arr [ i ] ) ; } else smallestElement = Math . min ( smallestElement , arr [ i ] ) ; } return smallestElement ; }
function findlargestAfterDel ( arr , m , del , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; ++ i ) { if ( mp . has ( del [ i ] ) ) { mp . set ( del [ i ] , mp . get ( del [ i ] ) + 1 ) ; } else { mp . set ( del [ i ] , 1 ) ; } } let largestElement = Number . MIN_VALUE ; for ( let i = 0 ; i < m ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) - 1 ) ; if ( mp . get ( arr [ i ] ) == 0 ) mp . delete ( arr [ i ] ) ; } else largestElement = Math . max ( largestElement , arr [ i ] ) ; } return largestElement ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function divTermCount ( a , b , lcm , num ) { return parseInt ( num / a ) + parseInt ( num / b ) - parseInt ( num / lcm ) ; }
function findNthTerm ( a , b , n ) { var low = 1 , high = Number . MAX_VALUE , mid ; var lcm = parseInt ( ( a * b ) / gcd ( a , b ) ) ; while ( low < high ) { mid = low + parseInt ( ( high - low ) / 2 ) ; if ( divTermCount ( a , b , lcm , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; }
function LongestFibSubseq ( A , n ) { var S = new Set ( A ) ; var maxLen = 0 , x , y ; for ( var i = 0 ; i < n ; ++ i ) { for ( var j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; var length = 2 ; while ( S . has ( y ) ) { var z = x + y ; x = y ; y = z ; maxLen = Math . max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; }
function numberOfElements ( height , n ) { var max_so_far = 0 ; var coun = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; }
function isPossible ( A , n , H , K ) { var time = 0 ; for ( var i = 0 ; i < n ; ++ i ) time += parseInt ( ( A [ i ] - 1 ) / K ) + 1 ; return time <= H ; }
function minJobSpeed ( A , n , H ) { if ( H < n ) return - 1 ; var max = A . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var lo = 1 , hi = max ; while ( lo < hi ) { var mi = lo + parseInt ( ( hi - lo ) / 2 ) ; if ( ! isPossible ( A , n , H , mi ) ) lo = mi + 1 ; else hi = mi ; } return lo ; }
function kthSmallestLargest ( arr , n , k ) { let max_val = Math . max ( ... arr ) ; let hash = new Array ( max_val + 1 ) ; for ( let i = 0 ; i < hash . length ; i ++ ) { hash [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } let count = 0 ; for ( let i = 0 ; i <= max_val ; i ++ ) { while ( hash [ i ] > 0 ) { count ++ ; if ( count == k ) { return i ; } hash [ i ] -- ; } } return - 1 ; }
function countAnomalies ( arr , n , k ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && Math . abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; }
function countAnomalies ( a , n , k ) { a . sort ( ) ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let u = upper_bound ( a , 0 , n , a [ i ] ) ; if ( u < n && a [ u ] - a [ i ] <= k ) continue ; let s = lower_bound ( a , 0 , n , a [ i ] ) ; if ( u - s > 1 ) continue ; if ( s > 0 && a [ s - 1 ] - a [ i ] <= k ) continue ; res ++ ; } return res ; }
function solve ( arr , n , k ) { var m = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { m . set ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } var max = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { if ( m . get ( arr [ i ] ) == k && max == - 1000000000 ) { max = arr [ i ] ; } else if ( m . get ( arr [ i ] ) == k && max < arr [ i ] ) { max = arr [ i ] ; } } if ( max == - 1000000000 ) document . write ( "No▁such▁element" ) ; else document . write ( max ) ; }
function majorityInMatrix ( arr ) { var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { for ( var j = 0 ; j < M ; j ++ ) { if ( mp . has ( arr [ i ] [ j ] ) ) { mp . set ( arr [ i ] [ j ] , mp . get ( arr [ i ] [ j ] ) + 1 ) } else mp . set ( arr [ i ] [ j ] , 1 ) ; } } var countMajority = 0 ; mp . forEach ( ( value , key ) => { if ( value >= ( parseInt ( ( N * M ) / 2 ) ) ) { countMajority ++ ; } } ) ; return countMajority ; }
function getMin ( arr , n ) { let res = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) res = Math . min ( res , arr [ i ] ) ; return res ; }
function findSum ( arr , n ) { let min = getMin ( arr , n ) ; let max = getMax ( arr , n ) ; return min + max ; }
function findProduct ( arr , n ) { let min = getMin ( arr , n ) ; let max = getMax ( arr , n ) ; return min * max ; }
function countEle ( s , a , N ) { var mp = new Map ( ) ; for ( var i = 0 ; i < N ; ++ i ) { var num = a [ i ] ; if ( mp . has ( num ) ) document . write ( "0▁" ) ; else { var cnt = 0 ; while ( s [ s . length - 1 ] != num ) { mp . set ( s [ s . length - 1 ] , true ) ; s . pop ( ) ; cnt ++ ; } s . pop ( ) ; cnt ++ ; document . write ( cnt + "▁" ) ; } } }
function bsearch ( A , key_to_search ) { let n = A . length ; let lg = parseInt ( Math . log ( n - 1 ) / Math . log ( 2 ) ) + 1 ; let pos = 0 ; for ( let i = lg ; i >= 0 ; i -- ) { if ( A [ pos ] == key_to_search ) return pos ; let new_pos = pos | ( 1 << i ) ; if ( ( new_pos < n ) && ( A [ new_pos ] <= key_to_search ) ) pos = new_pos ; } return ( ( A [ pos ] == key_to_search ) ? pos : - 1 ) ; }
function colMaxDiff ( mat ) { let max_diff = Number . MIN_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( let j = 1 ; j < N ; j ++ ) { max_val = Math . max ( max_val , mat [ j ] [ i ] ) ; min_val = Math . min ( min_val , mat [ j ] [ i ] ) ; } max_diff = Math . max ( max_diff , max_val - min_val ) ; } return max_diff ; }
function countChar ( str ) { var n = str . length ; if ( n <= 2 ) return n ; var count = 2 ; for ( var i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; }
function findmedian ( a , n1 , b , n2 ) { let i = 0 ; let j = 0 ; let k ; let m1 = - 1 , m2 = - 1 ; for ( k = 0 ; k <= ( n1 + n2 ) / 2 ; k ++ ) { if ( i < n1 && j < n2 ) { if ( a [ i ] < b [ j ] ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } else { m2 = m1 ; m1 = b [ j ] ; j ++ ; } } else if ( i == n1 ) { m2 = m1 ; m1 = b [ j ] ; j ++ ; } else if ( j == n2 ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } } if ( ( n1 + n2 ) % 2 == 0 ) { return ( m1 + m2 ) * 1.0 / 2 ; } return m1 ; }
function search ( ar , size ) { let a = 0 , b = size - 1 ; let mid = 0 ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 3 ) ; }
function deleteElement ( A , L , R , N ) { let i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; }
function search ( arr , n , x ) { let res = - 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == - 1 ) return false ; let temp = arr [ res ] ; for ( let i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; }
function kPresentProbability ( a , n , k ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count += 1 ; return count / n ; }
function binarySearch ( searchSpace , s , e , num ) { let ans = 0 ; while ( s <= e ) { let mid = Math . floor ( ( s + e ) / 2 ) ; if ( searchSpace [ mid ] >= num ) { ans = mid ; e = mid - 1 ; } else s = mid + 1 ; } return ans ; }
function longestSubArr ( arr , n ) { let searchSpace = new Array ( n ) ; let index = new Array ( n ) ; let j = 0 ; let ans = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( j == 0 searchSpace [ j - 1 ] < arr [ i ] ) { searchSpace [ j ] = arr [ i ] ; index [ j ] = i ; j ++ ; } let idx = binarySearch ( searchSpace , 0 , j - 1 , arr [ i ] ) ; ans = Math . max ( ans , i - index [ idx ] + 1 ) ; } return ans ; }
function findmissing ( ar , N ) { var l = 0 , r = N - 1 ; while ( l <= r ) { var mid = parseInt ( ( l + r ) / 2 ) ; if ( ar [ mid ] != mid + 1 && ar [ mid - 1 ] == mid ) return mid + 1 ; if ( ar [ mid ] != mid + 1 ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; }
function findFirst ( arr , n , x ) { arr . sort ( ) ; let ptr = lowerBound ( arr , 0 , n , x ) ; return ( arr [ ptr ] != x ) ? - 1 : ( ptr ) ; }
function findFirst ( arr , n , x ) { var count = 0 ; var isX = false ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) { isX = true ; } else if ( arr [ i ] < x ) { count ++ ; } } return ( isX == false ) ? - 1 : count ; }
function findDuplicate ( arr ) { let slow = arr [ 0 ] ; let fast = arr [ 0 ] ; do { slow = arr [ slow ] ; fast = arr [ arr [ fast ] ] ; } while ( slow != fast ) ; let ptr1 = arr [ 0 ] ; let ptr2 = slow ; while ( ptr1 != ptr2 ) { ptr1 = arr [ ptr1 ] ; ptr2 = arr [ ptr2 ] ; } return ptr1 ; }
function isSafe ( x , y , sol ) { return ( x >= 0 && x < N && y >= 0 && y < N && sol [ x ] [ y ] == - 1 ) ; }
function prevGreater ( arr , n ) { document . write ( "-1,▁" ) ; for ( let i = 1 ; i < n ; i ++ ) { let j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { document . write ( arr [ j ] + ",▁" ) ; break ; } } if ( j == - 1 ) document . write ( "-1,▁" ) ; } }
function prevGreater ( arr , n ) { let s = [ ] ; s . push ( arr [ 0 ] ) ; document . write ( "-1,▁" ) ; for ( let i = 1 ; i < n ; i ++ ) { while ( s . length != 0 && s [ s . length - 1 ] < arr [ i ] ) s . pop ( ) ; if ( s . length == 0 ) document . write ( "-1,▁" ) ; else document . write ( s [ s . length - 1 ] + ",▁" ) ; s . push ( arr [ i ] ) ; } }
function printGreaterCount ( str ) { let len = str . length ; let right = new Array ( len ) ; right . fill ( 0 ) ; for ( let i = 0 ; i < len ; i ++ ) { for ( let j = i + 1 ; j < len ; j ++ ) { if ( str [ i ] . charCodeAt ( ) < str [ j ] . charCodeAt ( ) ) { right [ i ] ++ ; } } } for ( let i = 0 ; i < len ; i ++ ) { document . write ( right [ i ] + "▁" ) ; } }
function printGreaterCount ( str ) { let len = str . length ; let ans = new Array ( len ) ; ans . fill ( 0 ) ; let count = new Array ( MAX_CHAR ) ; count . fill ( 0 ) ; for ( let i = len - 1 ; i >= 0 ; i -- ) { count [ str [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ++ ; for ( let j = str [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) + 1 ; j < MAX_CHAR ; j ++ ) { ans [ i ] += count [ j ] ; } } for ( let i = 0 ; i < len ; i ++ ) { document . write ( ans [ i ] + "▁" ) ; } }
function findMissingNo ( arr , n ) { var val ; var nextval ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= 0 arr [ i ] > n ) continue ; val = arr [ i ] ; while ( arr [ val - 1 ] != val ) { nextval = arr [ val - 1 ] ; arr [ val - 1 ] = val ; val = nextval ; if ( val <= 0 val > n ) break ; } } for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != i + 1 ) { return i + 1 ; } } return n + 1 ; }
function solve ( a , n ) { let max1 = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( Math . abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = Math . abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; }
function solve ( a , n ) { let min1 = a [ 0 ] ; let max1 = a [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return Math . abs ( min1 - max1 ) ; }
function maxProduct ( arr , n ) { if ( n < 4 ) return - 1 ; let max_product = Number . MIN_VALUE ; for ( let i = 0 ; i < n - 3 ; i ++ ) for ( let j = i + 1 ; j < n - 2 ; j ++ ) for ( let k = j + 1 ; k < n - 1 ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; }
function maxSum ( arr , n ) { if ( n < 2 ) return - 1 ; let ans = arr [ 0 ] + arr [ 1 ] ; for ( let i = 1 ; i + 1 < n ; i ++ ) ans = Math . min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; }
function getCount ( M , N ) { let count = 0 ; if ( M == 1 ) return N ; if ( N == 1 ) return M ; if ( N > M ) { for ( let i = 1 ; i <= M ; i ++ ) { let numerator = N * i - N + M - i ; let denominator = M - 1 ; if ( numerator % denominator == 0 ) { let j = parseInt ( numerator / denominator , 10 ) ; if ( j >= 1 && j <= N ) count ++ ; } } } else { for ( let j = 1 ; j <= N ; j ++ ) { let numerator = M * j - M + N - j ; let denominator = N - 1 ; if ( numerator % denominator == 0 ) { let i = parseInt ( numerator / denominator , 10 ) ; if ( i >= 1 && i <= M ) count ++ ; } } } return count ; }
function countTripletsLessThanL ( n , L , arr ) { arr . sort ( ) ; var ways = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { var mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; }
function appearsNBy3 ( arr , n ) { let count1 = 0 , count2 = 0 ; let first = Number . MAX_VALUE ; let second = Number . MAX_VALUE ; for ( let i = 1 ; i < n ; i ++ ) { if ( first == arr [ i ] ) count1 ++ ; else if ( second == arr [ i ] ) count2 ++ ; else if ( count1 == 0 ) { count1 ++ ; first = arr [ i ] ; } else if ( count2 == 0 ) { count2 ++ ; second = arr [ i ] ; } else { count1 -- ; count2 -- ; } } count1 = 0 ; count2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == first ) count1 ++ ; else if ( arr [ i ] == second ) count2 ++ ; } if ( count1 > parseInt ( n / 3 , 10 ) ) return first ; if ( count2 > parseInt ( n / 3 , 10 ) ) return second ; return - 1 ; }
function binary_lower ( value , arr , n ) { var start = 0 ; var end = n - 1 ; var ans = - 1 ; var mid ; while ( start <= end ) { mid = parseInt ( ( start + end ) / 2 ) ; if ( arr [ mid ] >= value ) { end = mid - 1 ; ans = mid ; } else { start = mid + 1 ; } } return ans ; }
function countTriplet ( arr , n , k ) { var count = 0 ; arr . sort ( ( a , b ) => a - b )  for ( var i = 2 ; i < n ; i ++ ) { var cur = binary_lower ( arr [ i ] - k , arr , n ) ; if ( cur <= i - 2 ) { count += parseInt ( ( ( i - cur ) * ( i - cur - 1 ) ) / 2 ) ; } } return count ; }
function isSuffix ( s1 , s2 ) { let n1 = s1 . length , n2 = s2 . length ; if ( n1 > n2 ) return false ; for ( let i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
function replaceOriginal ( s , n ) { var r = new Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { r [ i ] = s . charAt ( n - 1 - i ) ; if ( s . charAt ( i ) != "a" && s . charAt ( i ) != "e" && s . charAt ( i ) != "i" && s . charAt ( i ) != "o" && s . charAt ( i ) != "u" ) { document . write ( r [ i ] ) ; } } document . write ( "" ) ; }
function swapElement ( arr1 , arr2 , n ) { let wrongIdx = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr1 [ i ] < arr1 [ i - 1 ] ) { wrongIdx = i ; } } let maximum = Number . MIN_VALUE ; let maxIdx = - 1 ; let res = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr2 [ i ] > maximum && arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) { if ( wrongIdx + 1 <= n - 1 && arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) { maximum = arr2 [ i ] ; maxIdx = i ; res = true ; } } } if ( res ) { swap ( arr1 , wrongIdx , arr2 , maxIdx ) ; } return res ; }
function ElementsCalculationFunc ( pre , maxx , x , k , n ) { for ( let i = 0 , j = x ; j <= n ; j ++ , i ++ ) { if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; }
function costToBalance ( s ) { if ( s . length == 0 ) document . write ( 0 ) ; var ans = 0 ; var o = 0 , c = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == "(" ) o ++ ; if ( s [ i ] == ")" ) c ++ ; } if ( o != c ) return - 1 ; var a = new Array ( s . Length ) ; if ( s [ 0 ] == "(" ) a [ 0 ] = 1 ; else a [ 0 ] = - 1 ; if ( a [ 0 ] < 0 ) ans += Math . abs ( a [ 0 ] ) ; for ( var i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == "(" ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += Math . abs ( a [ i ] ) ; } return ans ; }
function checkIfAllTogether ( s , c ) { let oneSeen = false ; let i = 0 , n = s . length ; while ( i < n ) { if ( s [ i ] == c ) { if ( oneSeen == true ) return false ; while ( i < n && s [ i ] == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; }
function f ( n ) { return n * ( 2 * n * n - 1 ) ; }
function binarySearch ( low , high , x ) { while ( low <= high ) { let mid = ( low + high ) / 2 ; if ( f ( mid ) < x ) low = mid + 1 ; else if ( f ( mid ) > x ) high = mid - 1 ; else return true ; } return false ; }
function isStellaOctangula ( x ) { if ( x == 0 ) return true ; let i = 1 ; while ( f ( i ) < x ) i = i * 2 ; if ( f ( i ) == x ) return true ; return binarySearch ( i / 2 , i , x ) ; }
function search ( arr , n , x ) { let front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; }
function isSafe ( graph , color ) { for ( let i = 0 ; i < V ; i ++ ) for ( let j = i + 1 ; j < V ; j ++ ) if ( graph [ i ] [ j ] && color [ j ] == color [ i ] ) return false ; return true ; }
function graphColoring ( graph , m , i , color ) { if ( i == V ) { if ( isSafe ( graph , color ) ) { printSolution ( color ) ; return true ; } return false ; } for ( let j = 1 ; j <= m ; j ++ ) { color [ i ] = j ; if ( graphColoring ( graph , m , i + 1 , color ) ) return true ; color [ i ] = 0 ; } return false ; }
function getGreatestSum ( a ) { let prev_max = 0 ; for ( let j = 0 ; j < N ; j ++ ) if ( prev_max < a [ N - 1 ] [ j ] ) prev_max = a [ N - 1 ] [ j ] ; let sum = prev_max ; for ( let i = N - 2 ; i >= 0 ; i -- ) { let curr_max = - 2147483648 ; for ( let j = 0 ; j < N ; j ++ ) if ( prev_max > a [ i ] [ j ] && a [ i ] [ j ] > curr_max ) curr_max = a [ i ] [ j ] ; if ( curr_max == - 2147483648 ) return - 1 ; prev_max = curr_max ; sum += prev_max ; } return sum ; }
function minSum ( arr , n ) { let sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
function missingNum ( arr , n ) { let minvalue = Math . min ( ... arr ) ; let xornum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue ++ ; } return xornum ^ minvalue ; }
function findElement ( n , k ) { let ans = n ; let left = 1 ; let right = ( Math . pow ( 2 , n ) - 1 ) ; while ( true ) { let mid = ( left + right ) / 2 ; if ( k == mid ) { document . write ( ans ) ; break ; } ans -- ; if ( k < mid ) { right = mid - 1 ; } else { left = mid + 1 ; } } }
function firstCommon ( head1 , head2 ) { for ( ; head1 != null ; head1 = head1 . next ) for ( var p = head2 ; p != null ; p = p . next ) if ( p . data == head1 . data ) return head1 . data ; return 0 ; }
function findmin ( p , n ) { let a = 0 , b = 0 , c = 0 , d = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( p [ i ] [ 0 ] <= 0 ) a ++ ; else if ( p [ i ] [ 0 ] >= 0 ) b ++ ; if ( p [ i ] [ 1 ] >= 0 ) c ++ ; else if ( p [ i ] [ 1 ] <= 0 ) d ++ ; } return Math . min ( Math . min ( a , b ) , Math . min ( c , d ) ) ; }
function findLastIndex ( str , x ) { let index = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; }
function findLastIndex ( str , x ) { for ( let i = str . length - 1 ; i >= 0 ; i -- ) if ( str [ i ] == x ) return i ; return - 1 ; }
function checkBit ( pattern , arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; }
function countMaxSumPairs ( a , n ) { let first = Number . MIN_VALUE , second = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } let cnt1 = 0 , cnt2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == first ) cnt1 ++ ; if ( a [ i ] == second ) cnt2 ++ ; } if ( cnt1 == 1 ) return cnt2 ; if ( cnt1 > 1 ) return cnt1 * ( cnt1 - 1 ) / 2 ; return 0 ; }
function middleOfThree ( $a , $b , $c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }
function middleOfThree ( a , b , c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }
function findValue ( X , Y , P ) { if ( P % 2 == 0 ) return parseInt ( ( Math . max ( X , Y ) / Math . min ( X , Y ) ) , 10 ) ; else return parseInt ( ( Math . max ( 2 * X , Y ) / Math . min ( 2 * X , Y ) ) , 10 ) ; }
function countMaxSetBits ( left , right ) { let max_count = - 1 , num = 0 ; for ( let i = left ; i <= right ; ++ i ) { let temp = i , cnt = 0 ; while ( temp > 0 ) { if ( temp % 2 == 1 ) ++ cnt ; temp >>= 1 ; } if ( cnt > max_count ) { max_count = cnt ; num = i ; } } return num ; }
function sum ( arr , from , to ) { let total = 0 ; for ( let i = from ; i <= to ; i ++ ) total += arr [ i ] ; return total ; }
function findMax ( arr , n , k ) { let dp = new Array ( k + 1 ) ; for ( let i = 0 ; i < k + 1 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; } for ( let i = 1 ; i <= n ; i ++ ) dp [ 1 ] [ i ] = sum ( arr , 0 , i - 1 ) ; for ( let i = 1 ; i <= k ; i ++ ) dp [ i ] [ 1 ] = arr [ 0 ] ; for ( let j = 2 ; j <= n ; j ++ ) { let best = Number . MAX_VALUE ; for ( let p = 1 ; p <= j ; p ++ ) best = Math . min ( best , Math . max ( dp [ i - 1 ] [ p ] , sum ( arr , p , j - 1 ) ) ) ; dp [ i ] [ j ] = best ; } }
function findFloor ( root , key ) { let curr = root , ans = null ; while ( curr != null ) { if ( curr . key <= key ) { ans = curr ; curr = curr . right ; } else curr = curr . left ; } if ( ans != null ) return ans . key ; return - 1 ; }
function findS ( s ) { var sum = 0 ; for ( n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return - 1 ; }
function isvalid ( s ) { let k = ( - 1.0 + Math . sqrt ( 1 + 8 * s ) ) / 2 ; if ( Math . ceil ( k ) == Math . floor ( k ) ) return k ; else return - 1 ; }
function calcSafe ( pos ) { let j = pos % 10 ; let i = Math . floor ( pos / 10 ) ; let dis_11 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 1 - j ) ) ; let dis_18 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 8 - j ) ) ; let dis_81 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 1 - j ) ) ; let dis_88 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 8 - j ) ) ; let sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; }
function countCrossLine ( arr , n ) { let count_crossline = 0 ; let i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; count_crossline ++ ; } arr [ j + 1 ] = key ; } return count_crossline ; }
function getCount ( arr , n , num1 , num2 ) { let i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; let j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }
function check_elements ( arr , n , A , B ) { let range = B - A ; for ( let i = 0 ; i < n ; i ++ ) { if ( Math . abs ( arr [ i ] ) >= A && Math . abs ( arr [ i ] ) <= B ) { let z = Math . abs ( arr [ i ] ) - A ; if ( arr [ z ] > 0 ) { arr [ z ] = arr [ z ] * - 1 ; } } } let count = 0 ; for ( let i = 0 ; i <= range && i < n ; i ++ ) { if ( arr [ i ] > 0 ) return false ; else count ++ ; } if ( count != ( range + 1 ) ) return false ; return true ; }
function sumOfDigit ( K ) { let sod = 0 ; while ( K ) { sod += K % 10 ; K /= 10 ; } return sod ; }
function findMinRec ( A , n ) { if ( n == 1 ) return A [ 0 ] ; return Math . min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; }
function findMaxRec ( A , n ) { if ( n == 1 ) return A [ 0 ] ; return Math . max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) ; }
function getRandom ( x , y ) { return Math . floor ( x + Math . floor ( Math . random ( ) * 10 ) % ( y - x + 1 ) ) ; }
function randomizedBinarySearch ( arr , l , r , x ) { while ( l <= r ) { let m = getRandom ( l , r ) ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }
function countBuildings ( arr , n ) { let count = 1 ; let curr_max = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; }
function findExtra ( arr1 , arr2 , n ) { for ( let i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }
function findExtra ( arr1 , arr2 , n ) { let index = n ; let left = 0 , right = n - 1 ; while ( left <= right ) { let mid = Math . floor ( ( left + right ) / 2 ) ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
function findPages ( arr , n , m ) { let sum = 0 ; if ( n < m ) return - 1 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; let start = 0 , end = sum ; let result = Number . MAX_VALUE ; while ( start <= end ) { let mid = Math . floor ( ( start + end ) / 2 ) ; if ( isPossible ( arr , n , m , mid ) ) { result = Math . min ( result , mid ) ; end = mid - 1 ; } else start = mid + 1 ; } return result ; }
function minCostToMakeElementEqual ( arr , N ) { let low , high ; low = high = arr [ 0 ] ; for ( let i = 0 ; i < N ; i ++ ) { if ( low > arr [ i ] ) low = arr [ i ] ; if ( high < arr [ i ] ) high = arr [ i ] ; } while ( ( high - low ) > 2 ) { let mid1 = low + ( high - low ) / 3 ; let mid2 = high - ( high - low ) / 3 ; let cost1 = computeCost ( arr , N , mid1 ) ; let cost2 = computeCost ( arr , N , mid2 ) ; if ( cost1 < cost2 ) high = mid2 ; else low = mid1 ; } return Math . round ( computeCost ( arr , N , ( low + high ) / 2 ) ) ; }
function minJumps ( w , l , n ) { if ( n == 1 ) { document . write ( 0 ) ; return ; } var ans = 0 ; var i ; var pos = new Map ( ) ; var jump = new Map ( ) ; var filled = new Map ( ) ; var a = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) { pos . set ( w [ i ] , i ) ; filled . set ( i , true ) ; jump . set ( w [ i ] , l [ i ] ) ; a [ i ] = w [ i ] ; } a = a . sort ( function ( p , q ) { return p - q ; } ) ; for ( curr = 1 ; curr < n ; curr ++ ) { var currElementPos = pos . get ( a [ curr ] ) ; var prevElementPos = pos . get ( a [ curr - 1 ] ) ; if ( currElementPos > prevElementPos ) continue ; while ( currElementPos <= prevElementPos filled [ currElementPos ] ) { currElementPos += jump . get ( a [ curr ] ) ; ans += 1 ; } pos . set ( a [ curr ] , currElementPos ) ; filled . set ( currElementPos , true ) ; } document . write ( ans ) ; }
function check ( arr , n ) { for ( var i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] >= ( i - 1 ) ) { var p = arr [ i - 1 ] - ( i - 1 ) ; arr [ i ] += p ; arr [ i - 1 ] -= p ; } } for ( var i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= arr [ i - 1 ] ) { document . write ( "No" ) ; return ; } } document . write ( "Yes" ) ; }
function minimumSize ( arr , N , K ) { ( arr ) . sort ( function ( a , b ) { return a - b ; } ) ; reverse ( arr ) ; if ( count ( arr , 0 ) == N ) document . write ( 0 ) ; else if ( K >= N ) document . write ( 1 ) ; else document . write ( arr [ K ] ) ; }
function isPossibleToSort ( arr , N ) { var idx = - 1 ; var i ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 1 && arr [ i - 1 ] == 1 ) { idx = i ; break ; } } if ( idx == - 1 ) { document . write ( "YES" ) ; return ; } for ( i = idx + 1 ; i < N ; i ++ ) { if ( arr [ i ] == 0 && arr [ i - 1 ] == 0 ) { document . write ( "NO" ) ; return ; } } document . write ( "YES" ) ; }
function check ( arr , n ) { var count = 0 ; var index = - 1 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] ) { count ++ ; index = i ; } } if ( count > 1 ) return false ; if ( count == 0 ) return true ; if ( index == n - 1 index == 1 ) return true ; if ( arr [ index - 1 ] < arr [ index + 1 ] ) return true ; if ( arr [ index - 2 ] < arr [ index ] ) return true ; return false ; }
function isPossibleToSort ( arr , N ) { let group = arr [ 0 ] [ 1 ] ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] [ 1 ] != group ) { return "Yes" ; } } if ( isSorted ( arr , N ) ) { return "Yes" ; } else { return "No" ; } }
function maximumSum ( arr , S , N , K ) { var ans = 0 ; var i ; arr . sort ( ( a , b ) => b - a ) ; for ( i = 0 ; i < K ; i ++ ) ans += arr [ i ] ; S . sort ( ) ; for ( i = 0 ; i < K ; i ++ ) { if ( S [ i ] == 1 ) ans += arr [ i ] ; S [ i ] -= 1 ; } var counter = K - 1 ; for ( i = 0 ; i < K ; i ++ ) { counter = counter + S [ i ] ; if ( S [ i ] != 0 ) ans += arr [ counter ] ; } return ans ; }
function minimumDeletion ( s , n ) { var countMap = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( countMap . has ( s [ i ] ) ) { countMap . set ( s [ i ] , countMap . get ( s [ i ] ) + 1 ) ; } else { countMap . set ( s [ i ] , 1 ) ; } } var countMultiset = [ ] ; countMap . forEach ( ( value , key ) => { countMultiset . push ( value ) ; } ) ; countMultiset . sort ( ) ; var ans = 1000000000 ; var i = 0 ; var m = countMultiset . length ; countMultiset . forEach ( j => { ans = Math . min ( ans , n - ( m - i ) * j ) ; i ++ ; } ) ; return ans ; }
function maxLenSubset ( a , n ) { a . sort ( function ( a , b ) { return a - b ; } )  let index = 0 , maxlen = - 1 ; let i = 0 ; while ( i < n ) { let j = i ; let len = 1 ; while ( j < n - 1 ) { if ( 2 * a [ j ] >= a [ j + 1 ] ) { len ++ ; } else break ; j ++ ; } if ( maxlen < len ) { maxlen = len ; index = i ; } j ++ ; i = j ; } i = index ; while ( maxlen > 0 ) { document . write ( a [ i ] + "▁" ) maxlen -- ; i ++ ; } }
function maximumMex ( arr , N ) { var ans = [ ] ; arr . sort ( ) ; var i ; for ( i = 0 ; i < N ; i ++ ) { if ( i == 0 arr [ i ] != arr [ i - 1 ] ) ans . push ( arr [ i ] ) ; } for ( i = 0 ; i < N ; i ++ ) { if ( i > 0 && arr [ i ] == arr [ i - 1 ] ) ans . push ( arr [ i ] ) ; } for ( i = 0 ; i < N ; i ++ ) document . write ( ans [ i ] + "▁" ) ; }
function canReduceArray ( arr , N , K ) { arr . sort ( ) ; let b = Array ( N ) . fill ( 0 ) ; let j = N ; for ( let i = 0 ; i < N ; i ++ ) { b [ j - 1 ] = arr [ i ] ; j = j - 1 ; } for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] - arr [ i + 1 ] > K ) { document . write ( "No" ) ; return ; } } document . write ( "Yes" ) ; }
function mergeStrings ( s1 , s2 ) { var len1 = s1 . length ; var len2 = s2 . length ; var pntr1 = 0 ; var pntr2 = 0 ; var ans = "" ; while ( pntr1 < len1 && pntr2 < len2 ) { if ( s1 [ pntr1 ] < s2 [ pntr2 ] ) { ans += s1 [ pntr1 ] ; pntr1 ++ ; } else { ans += s2 [ pntr2 ] ; pntr2 ++ ; } } if ( pntr1 < len1 ) { ans += s1 . substr ( pntr1 , len1 ) ; } if ( pntr2 < len2 ) { ans += s2 . substr ( pntr2 , len2 ) ; } document . write ( ans ) ; }
function bubble_sort ( ar ) { if ( ar . length <= 1 ) return ar ; if ( ar . length == 2 ) { if ( ar [ 0 ] < ar [ 1 ] ) return ar ; else return [ ar [ 1 ] , ar [ 0 ] ] ; } let a = ar [ 0 ] ; let b = ar [ 1 ] ; let bs = [ ] ; for ( let i = 2 ; i < ar . length ; i ++ ) bs . push ( ar [ i ] ) ; let res = [ ] ; if ( a < b ) { let temp1 = [ ] ; temp1 . push ( b ) ; for ( let i = 0 ; i < bs . length ; i ++ ) temp1 . push ( bs [ i ] ) ; let v = bubble_sort ( temp1 ) ; v . unshift ( a ) ; res = v ; } else { let temp1 = [ ] ; temp1 . push ( a ) ; for ( let i = 0 ; i < bs . length ; i ++ ) temp1 . push ( bs [ i ] ) ; let v = bubble_sort ( temp1 ) ; v . unshift ( b ) ; res = v ; } let pass = [ ] ; for ( let i = 0 ; i < res . length - 1 ; i ++ ) pass . push ( res [ i ] ) ; let ans = bubble_sort ( pass ) ; ans . push ( res [ res . length - 1 ] ) ; return ans ; }
function sortBoundaryWise ( a ) { let i , k = 0 , l = 0 ; let m = a . length , n = a [ 0 ] . length ; let n_i , n_k = 0 , n_l = 0 , n_m = m , n_n = n ; while ( k < m && l < n ) { let boundary = [ ] ; for ( i = l ; i < n ; ++ i ) { boundary . push ( a [ k ] [ i ] ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { boundary . push ( a [ i ] [ n - 1 ] ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { boundary . push ( a [ m - 1 ] [ i ] ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { boundary . push ( a [ i ] [ l ] ) ; } l ++ ; } boundary . sort ( function ( a , b ) { return a - b ; } ) ; let ind = 0 ; for ( i = n_l ; i < n_n ; ++ i ) { a [ n_k ] [ i ] = boundary [ ind ] ; ind ++ ; } n_k += 1 ; for ( i = n_k ; i < n_m ; ++ i ) { a [ i ] [ n_n - 1 ] = boundary [ ind ] ; ind ++ ; } n_n -- ; if ( n_k < n_m ) { for ( i = n_n - 1 ; i >= n_l ; -- i ) { a [ n_m - 1 ] [ i ] = boundary [ ind ] ; ind ++ ; } n_m -- ; } if ( n_l < n_n ) { for ( i = n_m - 1 ; i >= n_k ; -- i ) { a [ i ] [ n_l ] = boundary [ ind ] ; ind ++ ; } n_l ++ ; } } printMatrix ( a ) ; }
function countPairs ( arr , n , k ) { arr . sort ( ) ; let ans = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let high = upper_bound ( arr , k * arr [ i ] ) ; ans += high - i - 1 ; } document . write ( ans ) ; }
function findXOR ( mat , K ) { let N = mat . length ; let M = mat [ 0 ] . length ; let digXOR = [ ] ; for ( let l = 1 ; l <= ( N + M - 1 ) ; l ++ ) { let s_col = Math . max ( 0 , l - N ) ; let count = Math . min ( l , ( M - s_col ) , N ) ; let currXOR = 0 ; for ( let j = 0 ; j < count ; j ++ ) { currXOR = ( currXOR ^ mat [ Math . min ( N , l ) - j - 1 ] [ s_col + j ] ) ; } digXOR . push ( currXOR ) ; } digXOR . sort ( ( a , b ) => a - b ) ; document . write ( digXOR [ N + M - 1 - K ] ) ; }
function countArraysUtil ( arr , X , K , xorVal ) { if ( X == 0 ) { let cnt = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > xorVal ) cnt ++ ; } if ( cnt >= K ) ans ++ ; return ; } let temp = arr [ 0 ] ; arr . shift ( ) ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr . unshift ( temp ) ; temp = arr [ arr . length - 1 ] ; arr . pop ( ) ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr . push ( temp ) ; arr [ 0 ] ++ ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr [ 0 ] -- ; arr [ arr . length - 1 ] ++ ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr [ arr . length - 1 ] -- ; }
function countArrays ( arr , X , K ) { let xorVal = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) xorVal = xorVal ^ arr [ i ] ; countArraysUtil ( arr , X , K , xorVal ) ; document . write ( ans ) ; }
function maximumSum ( arr , N ) { let sum ; arr . sort ( ) ; sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; document . write ( sum ) ; }
function getBuckets ( arr , N ) { let availableWater = N * ( N - 1 ) / 2 ; arr . sort ( function ( a , b ) { return a - b } ) ; let i = 0 , sum = 0 ; while ( sum <= availableWater ) { sum += arr [ i ] ; i ++ ; } document . write ( i - 1 ) ; }
function minimum_sum ( A , N ) { A . sort ( ) ; var sum = 1000000000 ; for ( var i = 0 ; i <= N - 3 ; i ++ ) { sum = Math . min ( sum , Math . abs ( A [ i ] - A [ i + 1 ] ) + Math . abs ( A [ i + 1 ] - A [ i + 2 ] ) ) ; } document . write ( sum ) ; }
function minimumIncreasingSubsequences ( arr , N ) { arr . sort ( function ( a , b ) { return a - b } ) ; let count = 0 ; let i = 0 ; while ( i < N ) { let x = arr [ i ] ; let freqX = 0 ; while ( i < N && arr [ i ] == x ) { freqX ++ ; i ++ ; } count = Math . max ( count , freqX ) ; } document . write ( count ) ; }
function maxOps ( a , b , c ) { let arr = [ a , b , c ] ; let count = 0 ; while ( 1 ) { arr . sort ( ) ; if ( ! arr [ 0 ] && ! arr [ 1 ] ) break ; arr [ 1 ] -= 1 ; arr [ 2 ] -= 1 ; count += 1 ; } document . write ( count ) ; }
function hashFunction ( N ) { let prime = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 ] ; let value = 1 , r ; while ( N != 0 ) { r = N % 10 ; value = value * prime [ r ] ; N = parseInt ( N / 10 , 10 ) ; } return value ; }
function findDiff ( arr , n ) { let m = new Map ( ) ; let h , min , max ; for ( let i = 0 ; i < n ; i ++ ) { h = hashFunction ( arr [ i ] ) ; if ( ! m . has ( h ) ) { m . set ( h , [ ] ) ; } ( m . get ( h ) ) . push ( arr [ i ] ) ; } m . forEach ( ( values , keys ) => { if ( values . length > 1 ) { min = Number . MAX_VALUE ; max = Number . MIN_VALUE ; for ( let j = 0 ; j < values . length ; j ++ ) { if ( ( m . get ( keys ) ) [ j ] < min ) { min = m . get ( keys ) [ j ] ; } if ( m . get ( keys ) [ j ] > max ) { max = m . get ( keys ) [ j ] ; } } document . write ( max - min ) ; } } ) }
function maxScore ( i , A , K , N , dp ) { if ( i >= N - 1 ) return A [ N - 1 ] ; if ( dp [ i ] != - 1 ) return dp [ i ] ; let score = - 1000 ; for ( let j = 1 ; j <= K ; j ++ ) { score = Math . max ( score , maxScore ( i + j , A , K , N , dp ) ) ; } return dp [ i ] = score + A [ i ] ; }
function getScore ( A , N , K ) { let dp = new Array ( N ) . fill ( - 1 ) ; document . write ( maxScore ( 0 , A , K , N , dp ) ) ; }
function checkifSorted ( A , B , N ) { var flag = false ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = true ; break ; } } if ( ! flag ) { return true ; } var count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 0 ) { count ++ ; break ; } } for ( i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 1 ) { count ++ ; break ; } } if ( count == 2 ) { return true ; } return false ; }
function minOperation ( a , N ) { var totOps = 0 ; for ( i = 0 ; i < N - 1 ; i ++ ) { totOps += Math . abs ( a [ i ] - a [ i + 1 ] ) ; } var maxOps = Math . max ( Math . abs ( a [ 0 ] - a [ 1 ] ) , Math . abs ( a [ N - 1 ] - a [ N - 2 ] ) ) ; for ( i = 1 ; i < N - 1 ; i ++ ) { maxOps = Math . max ( maxOps , Math . abs ( a [ i ] - a [ i - 1 ] ) + Math . abs ( a [ i ] - a [ i + 1 ] ) - Math . abs ( a [ i - 1 ] - a [ i + 1 ] ) ) ; } document . write ( totOps - maxOps ) ; }
function maxPossibleSum ( arr , N ) { arr . sort ( ) ; let sum = 0 ; let j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } document . write ( sum ) ; }
function findMaxDifference ( arr , n ) { arr . sort ( ) ; let Leftsum = 0 ; let Totalsum = 0 ; let Min = Number . MAX_VALUE , Max = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) Totalsum += arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { let leftNumbers = i ; let rightNumbers = n - i - 1 ; Totalsum = Totalsum - arr [ i ] ; let sum = ( leftNumbers * arr [ i ] ) - Leftsum + Totalsum - ( rightNumbers * arr [ i ] ) ; Min = Math . min ( Min , sum ) ; Max = Math . max ( Max , sum ) ; Leftsum += arr [ i ] ; } document . write ( Max - Min ) ; }
function sameStrings ( str1 , str2 ) { var N = str1 . length ; var M = str2 . length ; if ( N !== M ) { return false ; } var a = new Array ( 256 ) . fill ( 0 ) ; var b = new Array ( 256 ) . fill ( 0 ) ; for ( var j = 0 ; j < N ; j ++ ) { a [ str1 [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; b [ str2 [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } var i = 0 ; while ( i < 256 ) { if ( ( a [ i ] === 0 && b [ i ] === 0 ) || ( a [ i ] !== 0 && b [ i ] !== 0 ) ) { i ++ ; } else { return false ; } } a . sort ( ( x , y ) => x - y ) ; b . sort ( ( x , y ) => x - y ) ; for ( var j = 0 ; j < 256 ; j ++ ) { if ( a [ j ] !== b [ j ] ) return false ; } return true ; }
function minSteps ( A , B , M , N ) { if ( A [ 0 ] > B [ 0 ] ) return 0 ; if ( B [ 0 ] > A [ 0 ] ) { return 1 ; } if ( M <= N && A [ 0 ] == B [ 0 ] && count ( A , A [ 0 ] ) == M && count ( B , B [ 0 ] ) == N ) return - 1 ; for ( var i = 1 ; i < N ; i ++ ) { if ( B [ i ] > B [ 0 ] ) return 1 ; } for ( var i = 1 ; i < M ; i ++ ) { if ( A [ i ] < A [ 0 ] ) return 1 ; } for ( var i = 1 ; i < M ; i ++ ) { if ( A [ i ] > A [ 0 ] ) { swap ( A , i , B , 0 ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } } for ( var i = 1 ; i < N ; i ++ ) { if ( B [ i ] < B [ 0 ] ) { swap ( A , 0 , B , i ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } } return 0 ; }
function merge ( A , left , mid , right ) { let swaps = 0 ; let i = left , j = mid , k = left ; while ( i < mid && j <= right ) { if ( A [ i ] <= A [ j ] ) { temp [ k ] = A [ i ] ; k ++ ; i ++ ; } else { temp [ k ] = A [ j ] ; k ++ ; j ++ ; swaps += mid - i ; } } while ( i < mid ) { temp [ k ] = A [ i ] ; k ++ ; i ++ ; } while ( j <= right ) { temp [ k ] = A [ j ] ; k ++ ; j ++ ; } while ( left <= right ) { A [ left ] = temp [ left ] ; left ++ ; } return swaps ; }
function mergeInsertionSwap ( A , left , right ) { let swaps = 0 ; if ( left < right ) { let mid = left + ( right - left ) / 2 ; swaps += mergeInsertionSwap ( A , left , mid ) ; swaps += mergeInsertionSwap ( A , mid + 1 , right ) ; swaps += merge ( A , left , mid + 1 , right ) ; } return swaps ; }
function findAns ( A , N , X ) { if ( check ( A , X ) ) { return true ; } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { let gcdd = gcd ( A [ i ] , A [ j ] ) ; if ( gcdd != 1 ) { if ( gcdd <= X ) { return true ; } } } } return false ; }
function check ( a , b , Na , Nb , k , m ) { if ( Na < k Nb < m ) return "No" ; a . sort ( ) ; b . sort ( ) ; if ( a [ k - 1 ] < b [ Nb - m ] ) { return "Yes" ; } return "No" ; }
function splitArray ( arr , N ) { arr . sort ( ) ; let result = Number . MAX_VALUE ; for ( let i = 1 ; i < N ; i ++ ) { result = Math . min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
function maxCntRemovedfromArray ( arr , N , brr , M ) { arr . sort ( ) ; let i = 0 ; let sumArr = 0 ; for ( i = 0 ; i < N ; i ++ ) { sumArr += arr [ i ] ; } let sumBrr = 0 ; for ( i = 0 ; i < M ; i ++ ) { sumBrr += brr [ i ] ; } let cntRemElem = 0 ; while ( i < N && sumArr >= sumBrr ) { sumArr -= arr [ i ] ; i += 1 ; if ( sumArr >= sumBrr ) { cntRemElem += 1 ; } } return cntRemElem ; }
function findPair ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let a = arr [ i ] . first , b = arr [ i ] . second ; for ( let j = i + 1 ; j < N ; j ++ ) { let c = arr [ j ] . first , d = arr [ j ] . second ; if ( a < c && b > d ) { document . write ( "(" + a + "▁" + b + "),▁(" + c + "▁" + d + ")" ) ; return ; } } } document . write ( "NO▁SUCH▁PAIR▁EXIST" ) ; }
function printOrder ( order , N , X ) { let vect = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { if ( order [ i ] % X == 0 ) { vect . push ( [ order [ i ] / X , i + 1 ] ) ; } else { vect . push ( [ order [ i ] / X + 1 , i + 1 ] ) ; } } vect . sort ( function ( a , b ) { return a [ 0 ] - b [ 0 ] } ) ; for ( let i = 0 ; i < N ; i ++ ) { document . write ( vect [ i ] [ 1 ] + "▁" ) ; } document . write ( ) ; }
function CountMaximum ( arr , n , k ) { arr . sort ( ) ; let sum = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
function CountMaximum ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b } ) ; let sum = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
function numOperation ( arr , N , D ) { arr . sort ( ) ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( ( arr [ i + 1 ] - arr [ i ] ) % D != 0 ) { document . write ( "-1" ) ; return ; } } let count = 0 ; let mid = arr [ N / 2 ] ; for ( let i = 0 ; i < N ; i ++ ) { count += Math . abs ( mid - arr [ i ] ) / D ; } document . write ( count ) ; }
function findSum ( A , N , K ) { A . sort ( ) ; let sum = 0 ; for ( let i = N / K ; i < N ; i += K - 1 ) { sum += A [ i ] ; } document . write ( sum ) ; }
function maxcntPairsSumKRemoved ( arr , k ) { var cntPairs = 0 ; if ( arr . length <= 1 ) return cntPairs ; arr . sort ( ) ; var left = 0 ; var right = arr . length - 1 ; while ( left < right ) { var s = arr [ left ] + arr [ right ] ; if ( s == k ) { cntPairs += 1 ; left += 1 ; right -= 1 ; } else if ( s > k ) right -= 1 ; else left += 1 ; } return cntPairs ; }
function selectionSort ( arr , n ) { let i , j , min_idx ; for ( i = 0 ; i < n - 1 ; i ++ ) { min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; let temp = arr [ min_idx ] ; arr [ min_idx ] = arr [ i ] ; arr [ i ] = temp ; } }
function findSmallestNumLeft ( arr , N ) { let PQ = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { PQ . push ( arr [ i ] ) ; } PQ . sort ( function ( a , b ) { return b - a ; } ) ; while ( PQ . length > 1 ) { let top1 = PQ [ 0 ] ; PQ . shift ( ) ; let top2 = PQ [ 0 ] ; PQ . shift ( ) ; PQ . push ( Math . floor ( ( top1 + top2 + 1 ) / 2 ) ) ; PQ . sort ( function ( a , b ) { return b - a ; } ) ; } return PQ [ 0 ] ; }
function digitProduct ( number ) { let product = 1 ; while ( number > 0 ) { product *= ( number % 10 ) ; number = Math . floor ( number / 10 ) ; } return product ; }
function compositedigitProduct ( num ) { let res = digitProduct ( num ) ; if ( res == 1 ) { return false ; } if ( isComposite ( res ) ) { return true ; } return false ; }
function largestCompositeDigitProduct ( a , n , k ) { let pq = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( i % k ) == 0 ) { continue ; } if ( compositedigitProduct ( a [ i ] ) ) { let b = digitProduct ( a [ i ] ) ; pq . push ( new pair ( b , a [ i ] ) ) ; } } pq . sort ( function ( x , y ) { return x . first - y . first } ) ; return pq [ pq . length - 1 ] . second ; }
function maxSum ( arr , brr , N , K ) { let crr = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { crr . push ( arr [ i ] ) ; } for ( let i = 0 ; i < K ; i ++ ) { crr . push ( brr [ i ] ) ; } crr . sort ( function ( a , b ) { return a - b } ) ; crr . reverse ( ) ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( crr [ i ] > 0 ) { sum += crr [ i ] ; } else { break ; } } document . write ( sum ) ; }
function findMinimum ( arr , N , K ) { arr . sort ( ( a , b ) => a - b ) ; var ans = 0 ; for ( i = 1 ; i < 2 * ( parseInt ( N / K ) ) ; i += 2 ) { ans += arr [ i ] ; } document . write ( ans ) ; }
function findSubarrays ( arr , N ) { arr . sort ( ) ; var i = 0 ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { document . write ( "YES" ) ; return ; } } document . write ( "NO" ) ; }
function maxFreqElements ( arr , N , K ) { var mp = { } ; for ( var i = 0 ; i < N ; i ++ ) { if ( mp . hasOwnProperty ( arr [ i ] ) ) { mp [ arr [ i ] ] ++ ; } else { mp [ arr [ i ] ] = 1 ; } } while ( K > 0 ) { var max = 0 ; var element = 0 ; for ( const [ key , value ] of Object . entries ( mp ) ) { if ( value > max ) { max = value ; element = key ; } } document . write ( element + "▁" ) ; if ( mp . hasOwnProperty ( element ) ) { mp [ element ] -- ; } else { mp [ element ] = - 1 ; } K -- ; } }
function getPairs ( arr , N , K ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } document . write ( count ) ; }
function merge ( arr , temp , l , m , r , K ) { let i = l ; let j = m + 1 ; let cnt = 0 ; for ( i = l ; i <= m ; i ++ ) { let found = false ; while ( j <= r ) { if ( arr [ i ] >= K * arr [ j ] ) { found = true ; } else break ; j ++ ; } if ( found == true ) { cnt += j - ( m + 1 ) ; j -- ; } } let k = l ; i = l ; j = m + 1 ; while ( i <= m && j <= r ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else temp [ k ++ ] = arr [ j ++ ] ; } while ( i <= m ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= r ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = l ; i <= r ; i ++ ) arr [ i ] = temp [ i ] ; return cnt ; }
function mergeSort ( arr , N , K ) { let temp = new Array ( N ) ; document . write ( mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ) ; }
function Selection_Sort ( arr , n ) { for ( let i = 0 ; i < n - 1 ; ++ i ) { let min_index = i ; for ( let j = i + 1 ; j < n ; ++ j ) { if ( arr [ j ] < arr [ min_index ] ) min_index = j ; } let temp = arr [ i ] ; arr [ i ] = arr [ min_index ] ; arr [ min_index ] = temp ; } }
function Bubble_Sort ( arr , n ) { Boolean ( flag = true ) ; for ( var i = 1 ; i < n ; ++ i ) { flag = false ; for ( var j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { var temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; flag = true ; } } if ( flag == false ) break ; } }
function NDivKWithFreq ( arr , N , K ) { arr . sort ( ) ; for ( let i = 0 ; i < N ; ) { let cnt = 1 ; while ( ( i + 1 ) < N && arr [ i ] == arr [ i + 1 ] ) { cnt ++ ; i ++ ; } if ( cnt > ( N / K ) ) { document . write ( arr [ i ] + "▁" ) ; } i ++ ; } }
function upperBound ( arr , N , K ) { var l = 0 ; var r = N ; while ( l < r ) { var mid = parseInt ( ( l + r ) / 2 ) ; if ( arr [ mid ] <= K ) { l = mid + 1 ; } else { r = mid ; } } return l ; }
function NDivKWithFreq ( arr , N , K ) { sortt ( arr ) ; var i = 0 ; while ( i < N ) { var X = upperBound ( arr , N , arr [ i ] ) ; if ( ( X - i ) > parseInt ( N / 4 ) ) { document . write ( arr [ i ] + "▁" ) ; } i = X ; } }
function checkSubsetSum ( A , B , N , K ) { A . sort ( ( a , b ) => a - b ) ; B . sort ( ( a , b ) => b - a ) ; var sum1 = 0 ; var sum2 = 0 ; for ( var i = 0 ; i < K ; i ++ ) { sum1 += A [ i ] ; sum2 += B [ i ] ; } if ( sum1 > sum2 ) { return true ; } return false ; }
function printCircularArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function sortCircularArray ( arr , n , k , m ) { for ( let i = 0 ; i < m ; i ++ ) { for ( let j = k ; j < k + m - 1 ; j ++ ) { if ( arr [ j % n ] > arr [ ( j + 1 ) % n ] ) { let t = arr [ j % n ] ; arr [ j % n ] = arr [ ( j + 1 ) % n ] ; arr [ ( j + 1 ) % n ] = t ; } } } printCircularArray ( arr , n ) ; }
function rearrangeArray ( a , n ) { a . sort ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] == i + 1 ) { let temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; } } if ( a [ n - 1 ] == n ) { let temp = a [ n - 1 ] ; a [ n - 1 ] = a [ n - 2 ] ; a [ n - 2 ] = temp ; } for ( let i = 0 ; i < n ; i ++ ) { document . write ( a [ i ] + "▁" ) ; } }
function maximumKthLargestsumPart ( arr , N , M , K ) { let maxSum = 0 ; if ( N % M != 0 ) return - 1 ; let sz = ( N / M ) ; if ( K > sz ) return - 1 ; arr . sort ( ) ; let i , k , t ; for ( i = 0 ; i < N / 2 ; i ++ ) { t = arr [ i ] ; arr [ i ] = arr [ N - i - 1 ] ; arr [ N - i - 1 ] = t ; } for ( i = 1 ; i <= M ; i ++ ) { maxSum += arr [ i * K - 1 ] ; } return maxSum ; }
function splitArray ( arr , n , K ) { arr . sort ( ) ; let i = n - 1 ; let result = 0 ; while ( K -- != 0 ) { result += arr [ i - 1 ] ; i -= 2 ; } document . write ( result ) ; }
function merge ( indices , a , l , mid , r ) { let temp_ind = [ ] ; let j = mid + 1 ; let i = 0 , temp_l = l , k ; while ( l <= mid && j <= r ) { if ( a [ indices [ l ] ] < a [ indices [ j ] ] ) temp_ind [ i ++ ] = indices [ l ++ ] ; else temp_ind [ i ++ ] = indices [ j ++ ] ; } while ( l <= mid ) temp_ind [ i ++ ] = indices [ l ++ ] ; while ( j <= r ) temp_ind [ i ++ ] = indices [ j ++ ] ; for ( k = 0 ; k < i ; k ++ ) indices [ temp_l ++ ] = temp_ind [ k ] ; }
function divide ( indices , a , l , r ) { if ( l >= r ) return ; let mid = l / 2 + r / 2 ; divide ( indices , a , l , mid ) ; divide ( indices , a , mid + 1 , r ) ; merge ( indices , a , l , mid , r ) ; }
function noOfSubsequences ( arr , N ) { let indices = [ ] ; let i ; for ( i = 0 ; i < N ; i ++ ) indices [ i ] = i ; divide ( indices , arr , 0 , N - 1 ) ; let B = [ ] ; let subseq = 1 ; for ( i = 0 ; i < N ; i ++ ) { B [ indices [ i ] ] = subseq ; subseq *= 2 ; } for ( i = 0 ; i < N ; i ++ ) document . write ( B [ i ] + "▁" ) ; }
function checkStr1CanConStr2 ( str1 , str2 ) { var N = str1 . length ; var M = str2 . length ; var st1 = new Set ( ) ; var st2 = new Set ( ) ; var hash1 = Array ( 256 ) . fill ( 0 ) ; for ( var i = 0 ; i < N ; i ++ ) { hash1 [ str1 [ i ] . charCodeAt ( 0 ) ] ++ ; } for ( var i = 0 ; i < N ; i ++ ) { st1 . add ( str1 [ i ] ) ; } for ( var i = 0 ; i < M ; i ++ ) { st2 . add ( str2 [ i ] ) ; } if ( st1 . size != st2 . size ) { return false ; } var hash2 = Array ( 256 ) . fill ( 0 ) ; for ( var i = 0 ; i < M ; i ++ ) { hash2 [ str2 [ i ] . charCodeAt ( 0 ) ] ++ ; } hash1 . sort ( ( a , b ) => a - b ) ; hash2 . sort ( ( a , b ) => a - b ) ; for ( var i = 0 ; i < 256 ; i ++ ) { if ( hash1 [ i ] != hash2 [ i ] ) { return false ; } } return true ; }
function sortArrayInDescAsc ( arr , N , K ) { arr . sort ( ( b , a ) => a - b )  var temp = 0 ; for ( var i = K ; i < N ; i ++ ) { for ( var j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } arr . forEach ( element => { document . write ( element + "▁" ) ; } ) ; }
function maxCostToRemove ( arr , N , K ) { let maxCost = 0 ; arr . sort ( ) ; for ( let i = 0 ; i < N ; i += K ) { maxCost += arr [ i + 1 ] ; } return maxCost ; }
function lexNumbers ( n ) { let s = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) { s . push ( convert_to_words ( i ) ) ; } s . sort ( )  let ans = [ ] ; for ( let i = 0 ; i < n ; i ++ ) ans . push ( s [ i ] ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) document . write ( ans [ i ] + ",▁" ) ; document . write ( ans [ n - 1 ] ) ; }
function minimumCost ( binary , n , a , b ) { var groupOfZeros = [ ] ; var len = 0 , i = 0 ; var increment_need = true ; while ( i < n ) { increment_need = true ; while ( i < n && binary [ i ] == 0 ) { len ++ ; i ++ ; increment_need = false ; } if ( increment_need == true ) { i ++ ; } if ( len != 0 ) { groupOfZeros . push ( len ) ; } len = 0 ; } groupOfZeros . sort ( ( a , b ) => a - b ) ; i = 0 ; var found_ones = false ; var NumOfOnes = 0 ; while ( i < n ) { found_ones = false ; while ( i < n && binary [ i ] == 1 ) { i ++ ; found_ones = true ; } if ( found_ones == false ) i ++ ; else NumOfOnes ++ ; } var ans = 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { var curr = 0 , totalOnes = NumOfOnes ; if ( i == 0 ) { curr = totalOnes * a ; } else { var mark = i , num_of_changes = 0 ; groupOfZeros . forEach ( x => { if ( mark >= x ) { totalOnes -- ; mark -= x ; num_of_changes += x ; } } ) ; curr = ( num_of_changes * b ) + ( totalOnes * a ) ; } ans = Math . min ( ans , curr ) ; } document . write ( ans ) ; }
function isSortedparitions ( arr , i , j ) { for ( var k = i + 1 ; k <= j ; k ++ ) { if ( arr [ k ] < arr [ k - 1 ] ) { return 0 ; } } return 1 ; }
function partitionsArr ( arr , i , j ) { if ( i >= j ) return 1 ; var flag = isSortedparitions ( arr , i , j ) ; if ( flag ) { return ( j - i + 1 ) ; } var mid = parseInt ( ( i + j ) / 2 ) ; var X = partitionsArr ( arr , i , mid ) ; var Y = partitionsArr ( arr , mid + 1 , j ) ; return Math . max ( X , Y ) ; }
function checkIfPossibleMerge ( A , B , N ) { let i = 0 ; let j = 0 ; let prev = - 1 ; let flag = true ; while ( i < N && j < N ) { if ( A [ i ] < B [ j ] && prev != 0 ) { prev = 0 ; i ++ ; } else if ( B [ j ] < A [ i ] && prev != 1 ) { prev = 1 ; j ++ ; } else if ( A [ i ] == B [ j ] ) { if ( prev != 1 ) { prev = 1 ; j ++ ; } else { prev = 0 ; i ++ ; } } else { flag = false ; break ; } } return flag ; }
function maxSum ( n , a , l , q ) { let v = [ ] ; let d = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { d [ i ] = 0 ; } for ( let i = 0 ; i < q ; i ++ ) { for ( let x = l [ i ] [ 0 ] ; x <= l [ i ] [ 1 ] ; x ++ ) { if ( d [ x ] == 0 ) { d [ x ] = 1 ; } } } let st = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( d [ i ] == 0 ) { v . push ( a [ i ] ) ; st . add ( i ) ; } } v . sort ( function ( a , b ) { return b - a ; } ) ; let c = 0 ; for ( let it of st . values ( ) ) { a [ it ] = v ; c ++ ; } let pref_sum = 0 ; let temp_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { temp_sum += a [ i ] ; pref_sum += temp_sum ; } return pref_sum ; }
function countPairs ( A , N ) { var count = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { var xo = ( A [ i ] ^ A [ j ] ) ; var mx = Math . max ( A [ i ] , A [ j ] ) ; if ( xo > mx ) { count ++ ; } } } document . write ( count ) ; }
function findMedianOfsubSum ( arr , N ) { var sum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } arr . sort ( ( a , b ) => a - b )  var dp = Array . from ( Array ( N ) , ( ) => Array ( sum + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } dp [ 0 ] [ arr [ 0 ] ] = 1 ; for ( var i = 1 ; i < N ; i ++ ) { for ( var j = 1 ; j <= sum ; j ++ ) { if ( j >= arr [ i ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - arr [ i ] ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } } var sumSub = [ ] ; for ( var j = 1 ; j <= sum ; j ++ ) { var M = dp [ N - 1 ] [ j ] ; for ( var i = 1 ; i <= M ; i ++ ) { sumSub . push ( j ) ; } } var mid = sumSub [ parseInt ( sumSub . length / 2 ) ] ; return mid ; }
function maxDiffLargSmallOper ( arr , N , K ) { var maxDiff = 0 ; arr . sort ( ) ; arr = reverse ( arr ) ; for ( i = 0 ; i <= Math . min ( K , N - 1 ) ; i ++ ) { maxDiff += arr [ i ] ; } return maxDiff ; }
function findTheOrder ( arr , s , N ) { let ans = [ ] ; let A = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { let p = [ arr [ i ] , i + 1 ] ; A . push ( p ) ; } A . sort ( function ( p1 , p2 ) { return p1 [ 0 ] - p2 [ 0 ] ; } ) ; let q = [ ] ; let index = 0 ; for ( let i = 0 ; i < 2 * N ; i ++ ) { if ( s [ i ] == "0" ) { ans . push ( A [ index ] [ 1 ] ) ; q . push ( A [ index ] ) ; index ++ ; } else { ans . push ( q [ 0 ] [ 1 ] ) ; q . shift ( ) ; } q . sort ( function ( a , b ) { return b [ 0 ] - a [ 0 ] ; } ) ; } for ( let i = 0 ; i < ans . length ; i ++ ) { document . write ( ans [ i ] + "▁" ) ; } }
function checkArrangement ( A1 , A2 , n , k ) { A1 . sort ( ) ; A2 . sort ( ) ; A2 . reverse ( ) ; let flag = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) document . write ( "No" ) ; else document . write ( "Yes" ) ; }
function MaxRearrngeSum ( A , B , N ) { A . sort ( ) ; B . sort ( ) ; B . reverse ( ) ; let maxSum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { maxSum += Math . abs ( A [ i ] - B [ i ] ) ; } return maxSum ; }
function largestArea ( arr1 , n , arr2 , m ) { var end = 0 , start = 0 , i = 0 , j = 0 ; arr1 . sort ( ) ; arr2 . sort ( ) ; while ( i < n && j < m ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( start == 0 ) start = arr1 [ i ] ; else end = arr1 [ i ] ; i ++ ; j ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) j ++ ; else i ++ ; } if ( end == 0 start == 0 ) return 0 ; else return ( end - start ) ; }
function count_pairs ( arr , brr , N , M , K ) { let i = 0 ; let j = 0 ; let cntPairs = 0 ; ( arr ) . sort ( function ( a , b ) { return a - b ; } ) ; ( brr ) . sort ( function ( a , b ) { return a - b ; } ) ; while ( i < N && j < M ) { if ( brr [ j ] - arr [ i ] > K ) { cntPairs += ( M - j ) ; i ++ ; } else { j ++ ; } } return cntPairs ; }
function firstSubsequence ( s ) { let allsubseq = [ ] ; for ( let i = 0 ; i < s . length ; i ++ ) { let k = "" ; for ( let j = 0 ; j < s . length ; j ++ ) { if ( i != j ) { k += s [ j ] ; } } allsubseq . push ( k ) ; } ( allsubseq ) . sort ( ) ; document . write ( allsubseq [ 0 ] ) ; }
function firstSubsequence ( s ) { let isMax = - 1 ; for ( let i = 0 ; i < s . length - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) { isMax = i ; break ; } } if ( isMax >= 0 ) { s = s . substring ( 0 , isMax ) + s . substring ( isMax + 1 ) ; s . rerase ( isMax , 1 ) ; } else { s . erase ( s . length ( ) - 1 , 1 ) ; s = s . substring ( 0 , s . length - 1 ) ; } document . write ( s ) ; }
function minHeapify ( brr , i , M ) { let left = 2 * i + 1 ; let right = 2 * i + 2 ; let smallest = i ; if ( left < M && brr [ left ] < brr [ smallest ] ) { smallest = left ; } if ( right < M && brr [ right ] < brr [ smallest ] ) { smallest = right ; } if ( smallest != i ) { let temp = brr [ i ] ; brr [ i ] = brr [ smallest ] ; brr [ smallest ] = temp ; minHeapify ( brr , smallest , M ) ; } }
function merge ( arr , brr , N , M ) { for ( let i = 0 ; i < N ; ++ i ) { if ( arr [ i ] > brr [ 0 ] ) { let temp = arr [ i ] ; arr [ i ] = brr [ 0 ] ; brr [ 0 ] = temp ; minHeapify ( brr , 0 , M ) ; } } brr . sort ( ) ; }
function printArray ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function rankLessThanK ( arr , k , n ) { let rank = 1 ; let position = 1 ; arr . sort ( ) ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( i == n - 1 arr [ i ] != arr [ i + 1 ] ) { rank = position ; if ( rank > k ) return position - 1 ; } position ++ ; } return n ; }
function calculateFib ( fib , n ) { fib [ 0 ] = fib [ 1 ] = 1 ; for ( let x = 2 ; x < n ; x ++ ) { fib [ x ] = fib [ x - 1 ] + fib [ x - 2 ] ; } }
function find_mth_bit ( n , m , fib ) { if ( n <= 1 ) { return n ; } let len_left = fib [ n - 2 ] ; let len_right = fib [ n - 1 ] ; if ( m <= len_left ) { return find_mth_bit ( n - 2 , len_left + 1 - m , fib ) ; } else { return find_mth_bit ( n - 1 , len_right + 1 - ( m - len_left ) , fib ) ; } }
function KthSmallestNum ( arr , n , k ) { var pq = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { pq . push ( [ arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ] ) ; } var cnt = 1 ; while ( cnt < k ) { pq . sort ( ( a , b ) => { if ( a [ 0 ] == b [ 0 ] ) return a [ 1 ] - b [ 1 ]  return a [ 0 ] - b [ 0 ] } ) ; var interval = pq [ 0 ] ; pq . shift ( ) ; if ( interval [ 0 ] < interval [ 1 ] ) { pq . push ( [ interval [ 0 ] + 1 , interval [ 1 ] ] ) ; } cnt += 1 ; } pq . sort ( ( a , b ) => { if ( a [ 0 ] == b [ 0 ] ) return a [ 1 ] - b [ 1 ]  return a [ 0 ] - b [ 0 ] } ) ; return ( pq [ 0 ] ) [ 0 ] ; }
function maxArea ( polet_x , polet_y , n , length , width ) { polet_x . sort ( ( a , b ) => a - b ) ; ; polet_y . sort ( ( a , b ) => a - b ) ; ; let dx = polet_x [ 0 ] ; let dy = polet_y [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { dx = Math . max ( dx , polet_x [ i ] - polet_x [ i - 1 ] ) ; dy = Math . max ( dy , polet_y [ i ] - polet_y [ i - 1 ] ) ; } dx = Math . max ( dx , ( length + 1 ) - polet_x [ n - 1 ] ) ; dy = Math . max ( dy , ( width + 1 ) - polet_y [ n - 1 ] ) ; document . write ( ( dx - 1 ) * ( dy - 1 ) ) ; }
function LongestSequence ( a , n ) { var m = new Map ( ) ; var ar = Array ( n + 1 ) . fill ( 0 ) , i , j ; for ( i = 1 ; i <= n ; i ++ ) { ar [ i ] = a [ i - 1 ] ; } a . sort ( ( a , b ) => a - b ) ; var c = 1 ; m . set ( a [ 0 ] , c ) ; for ( i = 1 ; i <= n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) { c ++ ; m . set ( a [ i ] , c ) ; } } var cnt = new Map ( ) ; var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( 3 ) . fill ( 0 ) ) ; cnt . set ( 0 , 0 ) ; for ( i = 1 ; i <= n ; i ++ ) { ar [ i ] = m . get ( ar [ i ] ) ; if ( cnt . has ( ar [ i ] ) ) cnt . set ( ar [ i ] , cnt . get ( ar [ i ] ) + 1 ) else cnt . set ( ar [ i ] , 1 ) } var ans = 0 , x ; for ( i = 1 ; i <= n ; i ++ ) { x = ar [ i ] ; if ( dp [ x ] [ 0 ] == 0 ) { if ( dp [ x - 1 ] [ 0 ] == cnt . get ( x - 1 ) ) { dp [ x ] [ 1 ] = dp [ x - 1 ] [ 1 ] ; dp [ x ] [ 2 ] = dp [ x - 1 ] [ 1 ] ; } else { dp [ x ] [ 1 ] = dp [ x - 1 ] [ 0 ] ; } } dp [ x ] [ 2 ] = Math . max ( dp [ x - 1 ] [ 0 ] , dp [ x ] [ 2 ] ) ; if ( dp [ x - 1 ] [ 0 ] == cnt [ x - 1 ] ) { dp [ x ] [ 2 ] = Math . max ( dp [ x ] [ 2 ] , dp [ x - 1 ] [ 1 ] ) ; } for ( j = 0 ; j < 3 ; j ++ ) { dp [ x ] [ j ] ++ ; ans = Math . max ( ans , dp [ x ] [ j ] ) ; } } return ans ; }
function solve ( values , salary ) { var ret = 1 ; var amt = 0 ; values . sort ( ( a , b ) => a - b ) ; salary . sort ( ( a , b ) => a - b ) ; while ( salary . length ) { while ( values . length && values [ values . length - 1 ] >= salary [ salary . length - 1 ] ) { amt ++ ; values . pop ( ) ; } if ( amt == 0 ) return 0 ; ret *= amt -- ; ret %= MOD ; salary . pop ( ) ; } return ret ; }
function precompute_sum ( arr , brr ) { let N = arr . length ; for ( let i = 1 ; i < N ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; brr [ i ] = brr [ i ] + brr [ i - 1 ] ; } }
function find_sum ( arr , q , Queries ) { let brr = [ ... arr ] ; let N = arr . length ; brr . sort ( function ( a , b ) { return a - b ; } ) ; precompute_sum ( arr , brr ) ; for ( let i = 0 ; i < q ; i ++ ) { let m = Queries [ i ] [ 0 ] ; let a = Queries [ i ] [ 1 ] ; let b = Queries [ i ] [ 2 ] ; if ( m == 1 ) { document . write ( range_sum ( arr , a , b ) + "▁" ) ; } else if ( m == 2 ) { document . write ( range_sum ( brr , a , b ) + "▁" ) ; } } }
function minsteps ( arr , n ) { arr . sort ( ( a , b ) => a - b )  var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { ans += Math . abs ( arr [ i ] - Math . pow ( 2 , i ) ) ; } return ans ; }
function findCost ( a , n ) { a . sort ( ( x , y ) => y - x ) ; var count = 0 ; for ( var j = 0 ; j < n ; j ++ ) { var p = a [ j ] - j ; a [ j ] = 0 ; if ( p < 0 ) { p = 0 ; continue ; } count += p ; } return count ; }
function make_cuts ( arr , n , K ) { var ans = 0 ; var poss = [ ] ; var ce = 0 ; var co = 0 ; var x ; for ( x = 0 ; x < n - 1 ; x ++ ) { if ( arr [ x ] % 2 == 0 ) ce ++ ; else co ++ ; if ( ce == co && co > 0 && ce > 0 ) { poss . push ( Math . abs ( arr [ x ] - arr [ x + 1 ] ) ) ; } } poss . sort ( ) ; var i ; for ( i = 0 ; i < poss . length ; i ++ ) { if ( K >= poss [ i ] ) { ans ++ ; K -= poss [ i ] ; } else break ; } return ans ; }
function Arrange ( arr , n ) { let cost = 0 ; let index = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { index . set ( arr [ i ] , i ) } arr . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] > arr [ i + 1 ] + arr [ n - 1 ] ) { document . write ( "-1" ) ; return ; } else { cost += Math . abs ( index . get ( arr [ i ] ) - i ) ; } } else if ( i == n - 1 ) { if ( arr [ i ] > arr [ i - 1 ] + arr [ 0 ] ) { document . write ( "-1" ) ; return ; } else { cost += Math . abs ( index . get ( arr [ i ] ) - i ) ; } } else { if ( arr [ i ] > arr [ i - 1 ] + arr [ i + 1 ] ) { document . write ( "-1" ) ; return ; } else { cost += Math . abs ( index . get ( arr [ i ] ) - i ) ; } } } document . write ( cost ) ; return ; }
function maxDistinctChar ( s , n , k ) { var freq = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( freq . has ( s [ i ] ) ) freq . set ( s [ i ] , freq . get ( s [ i ] ) + 1 ) else freq . set ( s [ i ] , 1 ) } var v = [ ] ; freq . forEach ( ( value , key ) => { v . push ( value ) ; } ) ; v . sort ( )  for ( var i = 0 ; i < v . length ; i ++ ) { var mn = Math . min ( v [ i ] - 1 , k ) ; v [ i ] -= mn ; k -= mn ; } if ( k > 0 ) { for ( var i = 0 ; i < v . length ; i ++ ) { var mn = Math . min ( v [ i ] , k ) ; v [ i ] -= mn ; k -= mn ; } } var res = 0 ; for ( var i = 0 ; i < v . length ; i ++ ) if ( v [ i ] == 1 ) res ++ ; return res ; }
function getMaxSum ( i , j , k , arr1 , arr2 , arr3 ) { var cnt = 0 ; if ( i >= n1 ) cnt ++ ; if ( j >= n2 ) cnt ++ ; if ( k >= n3 ) cnt ++ ; if ( cnt >= 2 ) return 0 ; if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [ k ] ; var ans = 0 ; if ( i < n1 && j < n2 ) ans = Math . max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) ; if ( i < n1 && k < n3 ) ans = Math . max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) ; if ( j < n2 && k < n3 ) ans = Math . max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) ; dp [ i ] [ j ] [ k ] = ans ; return dp [ i ] [ j ] [ k ] ; }
function maxProductSum ( arr1 , arr2 , arr3 ) { arr1 . sort ( ) ; arr1 . reverse ( ) ; arr2 . sort ( ) ; arr2 . reverse ( ) ; arr3 . sort ( ) ; arr3 . reverse ( ) ; return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) ; }
function SieveOfEratosthenes ( ) { let prime = new Array ( 10005 ) ; prime . fill ( true ) ; for ( let p = 2 ; p * p <= 1000 ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= 1000 ; i += p ) prime [ i ] = false ; } } for ( let p = 2 ; p <= 1000 ; p ++ ) if ( prime [ p ] ) primes . push ( p ) ; }
function findMaxValue ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; let ans = arr [ n - 1 ] ; let maxPossible = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; -- i ) { if ( maxPossible > 0 ) { if ( arr [ i ] >= maxPossible ) { ans += ( maxPossible - 1 ) ; maxPossible = maxPossible - 1 ; } else { maxPossible = arr [ i ] ; ans += maxPossible ; } } } return ans ; }
function countPairs ( arr , n ) { let ans = 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; let left = 0 , right = 1 ; while ( right < n ) { if ( arr [ left ] == arr [ right ] ) ans += right - left ; else left = right ; right ++ ; } return ans ; }
function maximizeFinalElement ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; if ( arr [ 0 ] != 1 ) arr [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 1 ) { arr [ i ] = arr [ i - 1 ] + 1 ; } } return arr [ n - 1 ] ; }
function findLeastDist ( A , N ) { A . sort ( ( a , b ) => a - b ) ; console . log ( A ) ; if ( ( N % 2 ) == 0 ) { return A [ parseInt ( ( N - 1 ) / 2 ) ] ; } else { return A [ parseInt ( N / 2 ) ] ; } }
function maxSubMatSum ( mat ) { var n = mat . length ; var m = mat [ 0 ] . length ; var i , j ; var dp = Array ( n ) . fill ( ) . map ( ( ) => Array ( m ) . fill ( 0 ) ) ; dp [ n - 1 ] [ m - 1 ] = mat [ n - 1 ] [ m - 1 ] ; var res = dp [ n - 1 ] [ m - 1 ] ; for ( i = m - 2 ; i >= 0 ; i -- ) { dp [ n - 1 ] [ i ] = mat [ n - 1 ] [ i ] + dp [ n - 1 ] [ i + 1 ] ; res = Math . max ( res , dp [ n - 1 ] [ i ] ) ; } for ( i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] [ m - 1 ] = mat [ i ] [ m - 1 ] + dp [ i + 1 ] [ m - 1 ] ; res = Math . max ( res , dp [ i ] [ m - 1 ] ) ; } for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = m - 2 ; j >= 0 ; j -- ) { dp [ i ] [ j ] = mat [ i ] [ j ] + dp [ i ] [ j + 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j + 1 ] ; res = Math . max ( res , dp [ i ] [ j ] ) ; } } return res ; }
function solution ( A , B , C ) { let arr = Array . from ( { length : 3 } , ( _ , i ) => 0 ) ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; arr . sort ( ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; }
function removeElements ( arr , n ) { arr . sort ( ( a , b ) => b - a ) ; var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { ans += arr [ i ] * Math . pow ( 2 , i ) ; } return ans ; }
function canMadeEqual ( A , B , n ) { A . sort ( ) ; B . sort ( ) ; for ( var i = 0 ; i < n ; i ++ ) if ( A [ i ] != B [ i ] ) return false ; return true ; }
function maxMinDifference ( arr , n , k ) { if ( k >= n - 1 ) return 0 ; arr . sort ( ( a , b ) => a - b ) ; let ans = arr [ n - 1 ] - arr [ 0 ] ; for ( let i = k , j = n - 1 ; i >= 0 ; -- i , -- j ) { ans = Math . min ( arr [ j ] - arr [ i ] , ans ) ; } return ans ; }
function inversionCount ( s ) { var freq = Array ( 26 ) . fill ( 0 ) ; var inv = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { var temp = 0 ; for ( var j = 0 ; j < String . fromCharCode ( s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ) ; j ++ ) temp += freq [ j ] ; inv += ( i - temp ) ; freq [ s [ i ] - "a" ] ++ ; } return inv ; }
function numberofpairs ( arr , N ) { let answer = 0 ; arr . sort ( ) ; let minDiff = Number . MAX_VALUE ; for ( let i = 0 ; i < N - 1 ; i ++ ) minDiff = Math . min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; }
function dist ( p1 , p2 ) { var x0 = p1 [ 0 ] - p2 [ 0 ] ; var y0 = p1 [ 1 ] - p2 [ 1 ] ; return x0 * x0 + y0 * y0 ; }
function maximumSum ( arr , n , k ) { let elt = ( n / k ) ; let sum = 0 ; arr . sort ( ( a , b ) => a - b ) ; let count = 0 ; let i = n - 1 ; while ( count < k ) { sum += arr [ i ] ; i -- ; count ++ ; } count = 0 ; i = 0 ; while ( count < k ) { sum += arr [ i ] ; i += elt - 1 ; count ++ ; } document . write ( sum ) ; }
function countMinSteps ( arr , target , n ) { arr = arr . sort ( function ( a , b ) { return a - b ; } ) ; var minimumSteps = 0 ; var i = 0 , j = n - 1 ; while ( i <= j ) { if ( arr [ i ] + arr [ j ] <= target ) { i ++ ; j -- ; } else { j -- ; } minimumSteps ++ ; } return minimumSteps ; }
function build_num ( bit ) { let ans = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) if ( bit [ i ] > 0 ) ans += ( 1 << i ) ; return ans ; }
function maximumOR ( arr , n , k ) { let bit = new Array ( 32 ) ; bit . fill ( 0 ) ; for ( let i = 31 ; i >= 0 ; i -- ) { if ( bit [ i ] == 0 && k > 0 ) { let temp = build_num ( bit ) ; let temp1 = temp ; let val = - 1 ; for ( let j = 0 ; j < n ; j ++ ) { if ( temp1 < ( temp arr [ j ] ) ) { temp1 = temp | arr [ j ] ; val = arr [ j ] ; } } if ( val != - 1 ) { k -- ; for ( let j = 0 ; j < 32 ; j ++ ) { if ( ( val & ( 1 << j ) ) > 0 ) bit [ j ] ++ ; } } } } return build_num ( bit ) ; }
function findMinSum ( arr , K , L , size ) { if ( K * L > size ) return - 1 ; let minsum = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; }
function find_max_length ( arr , index , sum , k ) { sum = sum + arr [ index ] ; store . push ( arr [ index ] ) ; if ( sum == k ) { if ( max_length < store . length ) { max_length = store . length ; ans = store ; } } for ( let i = index + 1 ; i < arr . length ; i ++ ) { if ( sum + arr [ i ] <= k ) { find_max_length ( arr , i , sum , k ) ; store . pop ( ) ; } else return ; } return ; }
function longestSubsequence ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( max_length >= n - i ) break ; store = [ ] ; find_max_length ( arr , i , 0 , k ) ; } return max_length ; }
function minBox ( arr , n ) { var box = n ; arr . sort ( ) ; var curr_box = 0 , next_box = 1 ; while ( curr_box < n && next_box < n ) { if ( arr [ curr_box ] < arr [ next_box ] ) { box -- ; curr_box ++ ; next_box ++ ; } else if ( arr [ curr_box ] == arr [ next_box ] ) next_box ++ ; } document . write ( box ) ; }
function setData ( head ) { var tmp ; tmp = head ; while ( tmp != null ) { document . write ( tmp . data + "▁->▁" ) ; tmp = tmp . next ; } }
function findMedian ( a , n ) { if ( n % 2 != 0 ) return a [ Math . floor ( n / 2 ) ] ; return ( a [ Math . floor ( ( n - 1 ) / 2 ) ] + a [ Math . floor ( n / 2 ) ] ) / 2.0 ; }
function kStrongest ( arr , n , k ) { arr . sort ( ) ; let median = findMedian ( arr , n ) ; let diff = Array . from ( { length : n } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { diff [ i ] = Math . abs ( median - arr [ i ] ) ; } let i = 0 , j = n - 1 ; while ( k > 0 ) { if ( diff [ i ] > diff [ j ] ) { document . write ( arr [ i ] + "▁" ) ; i ++ ; } else { document . write ( arr [ j ] + "▁" ) ; j -- ; } k -- ; } }
function sorting_possible ( a , b , n ) { let sorted = true ; let type1 = 0 , type0 = 0 , i ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { sorted = false ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( b [ i ] == 0 ) type0 ++ ; else type1 ++ ; } if ( sorted ) return true ; else if ( type1 == n type0 == n ) return false ; else return true ; }
function lexNumbers ( n ) { let s = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) { s . push ( i . toString ( ) ) ; } s . sort ( ) ; let ans = [ ] ; for ( let i = 0 ; i < n ; i ++ ) ans . push ( parseInt ( s [ i ] ) ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( ans [ i ] + "▁" ) ; }
function dfs ( temp , n , sol ) { if ( temp > n ) return ; sol . push ( temp ) ; dfs ( temp * 10 , n , sol ) ; if ( temp % 10 != 9 ) dfs ( temp + 1 , n , sol ) ; }
function findMinDif ( arr , N ) { arr . sort ( ( a , b ) => a - b ) ; return ( arr [ N - 1 ] - arr [ N - 2 ] ) ; }
function partition ( arr , l , h ) { let pivot = arr [ l ] ; let i = l + 1 ; let j = h ; while ( i <= j ) { while ( i <= h && arr [ i ] < pivot ) { i ++ ; } while ( j > l && arr [ j ] > pivot ) { j -- ; } if ( i < j ) { let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i ++ ; j -- ; } else i ++ ; } arr [ l ] = arr [ j ] ; arr [ j ] = pivot ; return j ; }
function sortArray ( arr , l , h ) { if ( l >= h ) return ; let pivot = partition ( arr , l , h ) ; sortArray ( arr , l , pivot - 1 ) ; sortArray ( arr , pivot + 1 , h ) ; }
function findMaxIntervals ( start , end , n , R ) { let ans = 0 ; let prev = 0 ; let currActive = 0 ; let i = 0 ; let j = 0 ; if ( start [ 0 ] > 0 ) ans ++ ; while ( i < n && j < n ) { if ( start [ i ] < end [ j ] ) { i ++ ; currActive ++ ; } else if ( start [ i ] > end [ j ] ) { j ++ ; currActive -- ; } else { i ++ ; j ++ ; } if ( currActive == 0 ) { ans ++ ; } } if ( end [ n - 1 ] < R ) ans ++ ; return ans ; }
function sortArray ( A , N ) { let x = 0 , y = 0 , z = 0 ; if ( N % 4 == 0 N % 4 == 1 ) { for ( let i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } document . write ( "Sorted▁Array:▁" ) ; for ( let i = 0 ; i < N ; i ++ ) document . write ( A [ i ] + "▁" ) ; } else { document . write ( "-1" ) ; } }
function check_vector ( A , n , p ) { var pos = A . length ; for ( var i = 0 ; i < p . length ; i ++ ) { pos [ p [ i ] - 1 ] = 1 ; } var flag = 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( pos [ i ] == 0 ) continue ; var j = i ; while ( j < n && pos [ j ] ) ++ j ; A = Array . prototype . concat ( A . slice ( 0 , i ) , A . slice ( i + 1 , j + 1 ) . sort ( ( a , b ) => a - b ) , A . slice ( j + 2 ) . sort ( ( a , b ) => a - b ) ) ; i = j ; } for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function dfs ( x ) { let v = [ ] ; for ( let it of s . values ( ) ) { if ( g [ x ] . get ( it ) != null ) { v . push ( it ) ; } else { ns . add ( it ) ; } } s = ns ; for ( let i of v . values ( ) ) { dfs ( i ) ; } }
function weightOfMST ( N ) { let cnt = 0 ; for ( let i = 1 ; i <= N ; ++ i ) { s . add ( i ) ; } let qt = [ ] for ( let t of s . values ( ) ) qt . push ( t ) ; while ( qt . length != 0 ) { ++ cnt ; let t = qt [ 0 ] ; qt . shift ( ) ; dfs ( t ) ; } document . write ( cnt - 4 ) ; }
function sortDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let out = [ ] ; while ( n > 0 ) { out . push ( arr [ Math . floor ( n / 2 ) ] ) ; arr . splice ( Math . floor ( n / 2 ) , 1 ) ; n = n - 1 ; } for ( let i = 0 ; i < out . length ; i ++ ) document . write ( out [ i ] + "▁" ) ; }
function minimumCost ( arr , N , M ) { arr . sort ( ( a , b ) => a - b ) ; let pref = Array . from ( { length : N } , ( _ , i ) => 0 ) ; pref [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { pref [ i ] = arr [ i ] + pref [ i - 1 ] ; } for ( let i = M ; i < N ; i ++ ) { pref [ i ] += pref [ i - M ] ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( pref [ i ] + "▁" ) ; } }
function countPairs ( A , B ) { let n = A . length ; let ans = 0 ; A . sort ( ) ; B . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; }
function uniqueSum ( A , R , N , M ) { for ( let i = 0 ; i < M ; ++ i ) { let l = R [ i ] [ 0 ] , r = R [ i ] [ 1 ] + 1 ; l -- ; r -- ; A [ l ] ++ ; if ( r < N ) A [ r ] -- ; } for ( let i = 1 ; i < N ; ++ i ) { A [ i ] += A [ i - 1 ] ; } let ans = 0 ; let s = new Set ( ) ; for ( let i = 0 ; i < N ; ++ i ) { if ( ! s . has ( A [ i ] ) ) ans += A [ i ] ; s . add ( A [ i ] ) ; } return ans ; }
function kthpair ( n , k , arr ) { let i , t = 0 ; arr . sort ( ) ; -- k ; for ( i = 0 ; i < n ; i += t ) { for ( t = 1 ; arr [ i ] == arr [ i + t ] ; ++ t ) ; if ( t * n > k ) break ; k = k - t * n ; } document . write ( arr [ i ] + "▁" + arr [ k / t ] ) ; }
function minOperations ( s ) { var freq = new Array ( 26 ) . fill ( 0 ) ; var n = s . length ; for ( var i = 0 ; i < n ; i ++ ) { freq [ s [ i ] . charCodeAt ( 0 ) - "A" . charCodeAt ( 0 ) ] ++ ; } freq . sort ( ( a , b ) => b - a ) ; var answer = n ; for ( var i = 1 ; i <= 26 ; i ++ ) { if ( n % i === 0 ) { var x = n / i ; var y = 0 ; for ( var j = 0 ; j < i ; j ++ ) { y += Math . min ( freq [ j ] , x ) ; } answer = Math . min ( answer , n - y ) ; } } return answer ; }
function printArray ( arr , N ) { for ( var i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function sortArray ( arr , N ) { for ( var i = 0 ; i < N ; ) { if ( arr [ i ] == i + 1 ) { i ++ ; } else { var temp1 = arr [ i ] ; var temp2 = arr [ arr [ i ] - 1 ] ; arr [ i ] = temp2 ; arr [ temp1 - 1 ] = temp1 ; } } }
function fun ( arr , n , k ) { let v = [ ] ; for ( let i = 0 ; i < k ; i ++ ) { for ( let j = i ; j < n ; j += k ) { v . push ( arr [ j ] ) ; } v . sort ( ) ; let x = 0 ; for ( let j = i ; j < n ; j += k ) { arr [ j ] = v [ x ] ; x ++ ; } v = [ ] ; } for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) return false ; } return true ; }
function CheckSort ( arr , k , n ) { var sortarr = arr . sort ( ( a , b ) => a - b ) ; if ( k === 1 ) document . write ( "yes" ) ; else { var flag = 0 ; for ( var i = 0 ; i < n ; i ++ ) { flag = 0 ; for ( var j = i ; j < n ; j += k ) { if ( sortarr [ i ] === arr [ j ] ) { var tmp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = tmp ; flag = 1 ; break ; } if ( j + k >= n ) { break ; } } if ( flag === 0 ) { break ; } } if ( flag === 0 ) document . write ( "Not▁possible▁to▁sort" ) ; else document . write ( "Possible▁to▁sort" ) ; } }
function sortedAdjacentDifferences ( arr , n ) { let ans = new Array ( n ) ; arr . sort ( ) ; let l = 0 , r = n - 1 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 ) { ans [ i ] = arr [ l ] ; l ++ ; } else { ans [ i ] = arr [ r ] ; r -- ; } } for ( let i = 0 ; i < n ; i ++ ) { document . write ( ans [ i ] + "▁" ) ; } }
function get_permutation ( arr , n ) { arr . sort ( ) ; var result = 0 ; for ( i = 0 ; i < n ; i ++ ) { result += Math . abs ( arr [ i ] - ( i + 1 ) ) ; } return result ; }
function minimumIncDec ( arr , N , maxE , minE ) { if ( N == 0 ) { return 0 ; } if ( ! dp [ N ] [ maxE ] ) return dp [ N ] [ maxE ] ; let ans = Number . MAX_SAFE_INTEGER ; for ( let k = minE ; k <= maxE ; k ++ ) { let x = minimumIncDec ( arr , N - 1 , k , minE ) ; ans = Math . min ( ans , x + Math . abs ( arr [ N - 1 ] - k ) ) ; } dp [ N ] [ maxE ] = ans ; return dp [ N ] [ maxE ] ; }
function maxSumArrangement ( A , R , N , M ) { var count = new Array ( N ) ; count . fill ( 0 ) ; for ( var i = 0 ; i < M ; i ++ ) { var l = R [ i ] [ 0 ] , r = R [ i ] [ 1 ] + 1 ; l -- ; r -- ; count [ l ] ++ ; if ( r < N ) count [ r ] -- ; } for ( var i = 1 ; i < N ; ++ i ) { count [ i ] += count [ i - 1 ] ; } var ans = 0 ; count . sort ( ) ; arrSort ( A , N ) ; for ( var i = N - 1 ; i >= 0 ; -- i ) { ans += A [ i ] * count [ i ] ; } return ans ; }
function make_permutation ( arr , n ) { arr . sort ( ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans += Math . abs ( i + 1 - arr [ i ] ) ; return ans ; }
function maxSum ( V , n , m ) { let ans = 0 ; for ( let i = n - 2 ; i >= 0 ; -- i ) { let aux = new Array ( ) ; for ( let j = 0 ; j < m ; ++ j ) { aux . push ( [ V [ i + 1 ] [ j ] , j ] ) ; } aux . sort ( ( a , b ) => a [ 0 ] - b [ 0 ] ) ; aux . reverse ( ) ; for ( let j = 0 ; j < m ; ++ j ) { for ( let k = 0 ; k < m ; ++ k ) { if ( aux [ k ] [ 1 ] - j == 0 || Math . abs ( aux [ k ] [ 1 ] - j ) > 1 ) { V [ i ] [ j ] += aux [ k ] [ 0 ] ; break ; } } } } for ( let i = 0 ; i < m ; ++ i ) { ans = Math . max ( ans , V [ 0 ] [ i ] ) ; } return ans ; }
function minimumProduct ( arr , n ) { arr . sort ( ) ; let product = 1 ; for ( let i = 0 ; i < n ; i += 2 ) { product *= ( arr [ i ] + arr [ i + 1 ] ) ; } return product ; }
function isVowel ( ch ) { ch = ch . toUpperCase ( ) ; return ( ch == "A" ch == "E" ch == "I" ch == "O" ch == "U" ) ; }
function sortArr ( arr , n ) { let vp = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { vp . push ( [ countVowels ( arr [ i ] ) , arr [ i ] ] ) ; } vp . sort ( ) ; for ( let i = 0 ; i < vp . length ; i ++ ) document . write ( vp [ i ] [ 1 ] + "▁" ) ; }
function checkIsGP ( arr , n ) { if ( n == 1 ) return true ; arr . sort ( ) ; var r = arr [ 1 ] / arr [ 0 ] ; for ( var i = 2 ; i < n ; i ++ ) { if ( arr [ i ] / arr [ i - 1 ] != r ) return false ; } return true ; }
function checkIsHP ( arr , n ) { if ( n == 1 ) { return true ; } var rec = Array ( n ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { rec [ i ] = ( ( 1 / arr [ i ] ) ) ; } if ( checkIsAP ( rec , n ) ) return true ; else return false ; }
function reversDigits ( num ) { var rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = Math . floor ( num / 10 ) ; } return rev_num ; }
function sortArr ( arr , n ) { var vp = new Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { vp [ i ] = [ ] ; } for ( var i = 0 ; i < n ; i ++ ) { var pair = [ ] ; pair . push ( reversDigits ( arr [ i ] ) ) ; pair . push ( arr [ i ] ) ; vp [ i ] = pair ; } vp = vp . sort ( function ( a , b ) { return a [ 0 ] - b [ 0 ] ; } ) ; for ( var i = 0 ; i < n ; i ++ ) { document . write ( vp [ i ] [ 1 ] + "▁" ) ; } }
function sortMat ( data , row , col ) { let size = row * col ; for ( let i = 0 ; i < size ; i ++ ) { for ( let j = 0 ; j < size - 1 ; j ++ ) { if ( data [ Math . floor ( j / col ) ] [ j % col ] > data [ Math . floor ( ( j + 1 ) / col ) ] [ ( j + 1 ) % col ] ) { let temp = data [ Math . floor ( j / col ) ] [ j % col ] ; data [ Math . floor ( j / col ) ] [ j % col ] = data [ Math . floor ( ( j + 1 ) / col ) ] [ ( j + 1 ) % col ] ; data [ Math . floor ( ( j + 1 ) / col ) ] [ ( j + 1 ) % col ] = temp ; } } } }
function minimiseMedian ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; return Math . abs ( arr [ n / 2 ] - arr [ ( n / 2 ) - 1 ] ) ; }
function sortByFreq ( arr , n ) { var maxE = - 1 ; for ( var i = 0 ; i < n ; i ++ ) { maxE = Math . max ( maxE , arr [ i ] ) ; } var freq = new Array ( maxE + 1 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } var cnt = 0 ; for ( var i = 0 ; i <= maxE ; i ++ ) { if ( freq [ i ] > 0 ) { var value = 100000 - i ; arr [ cnt ] = 100000 * freq [ i ] + value ; cnt ++ ; } } return cnt ; }
function printSortedArray ( arr , cnt ) { for ( var i = 0 ; i < cnt ; i ++ ) { var frequency = parseInt ( arr [ i ] / 100000 ) ; var value = 100000 - ( arr [ i ] % 100000 ) ; for ( var j = 0 ; j < frequency ; j ++ ) { document . write ( value + "▁" ) ; } } }
function canBeEqual ( a , b , c , k ) { var arr = Array ( 3 ) ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; arr . sort ( ( a , b ) => a - b ) ; var diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 k % 3 != 0 ) return false ; return true ; }
function search ( arr , l , h , key ) { if ( l > h ) return - 1 ; let mid = parseInt ( ( l + h ) / 2 , 10 ) ; if ( arr [ mid ] == key ) return mid ; if ( ( arr [ l ] == arr [ mid ] ) && ( arr [ h ] == arr [ mid ] ) ) { ++ l ; -- h ; return search ( arr , l , h , key ) } if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
function orgazineInOrder ( vec , op , n ) { let result = [ n ] ; vec . sort ( ) ; let i = 0 , j = n - 1 , k = 0 ; while ( i <= j && k <= n - 2 ) { if ( op [ k ] == "<" ) { result [ k ] = vec [ i ++ ] ; } else { result [ k ] = vec [ j -- ] ; } k ++ ; } result [ n - 1 ] = vec [ i ] ; return result ; }
function minimumCost ( price , n ) { price . sort ( ) ; let totalCost = 0 ; for ( let i = n - 1 ; i > 1 ; i -= 2 ) { if ( i == 2 ) { totalCost += price [ 2 ] + price [ 0 ] ; } else { let price_first = price [ i ] + price [ 0 ] + 2 * price [ 1 ] ; let price_second = price [ i ] + price [ i - 1 ] + 2 * price [ 0 ] ; totalCost += Math . min ( price_first , price_second ) ; } } if ( n == 1 ) { totalCost += price [ 0 ] ; } else { totalCost += price [ 1 ] ; } return totalCost ; }
function checkRectangles ( arr , n ) { let ans = true ; arr . sort ( ) ; var area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( let i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; }
function findMin ( arr , n ) { let ans = 1 ; for ( let i = 0 ; i < n ; i ++ ) { let j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; ans = Math . max ( ans , j - i ) ; i = j - 1 ; } return n - ans ; }
function countSubSeq ( a , n , k ) { a . sort ( ) ; var arr = [ ] ; for ( var i = 0 ; i < n ; ) { var count = 1 , x = a [ i ] ; i ++ ; while ( i < n && a [ i ] == x ) { count ++ ; i ++ ; } arr . push ( count ) ; } var m = arr . length ; n = Math . min ( m , k ) ; var count = 1 ; var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = m ; j >= 0 ; j -- ) { if ( j > m - i ) dp [ i ] [ j ] = 0 ; else { dp [ i ] [ j ] = dp [ i ] [ j + 1 ] + arr [ j ] * dp [ i - 1 ] [ j + 1 ] ; } } count = count + dp [ i ] [ 0 ] ; } return count ; }
function maxMod ( arr , n ) { let maxVal = arr . sort ( ( a , b ) => b - a ) [ 0 ]  let secondMax = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return secondMax ; }
function partOdd ( s ) { var st = "" ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( i % 2 !== 0 ) st += s [ i ] ; } return st ; }
function partEven ( str ) { var s = "" ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( i % 2 === 0 ) s += str [ i ] ; } return s ; }
function sortStack ( input , k ) { let tmpStack = [ ] ; while ( input . length != 0 ) { let tmp = input . pop ( ) ; while ( tmpStack . length != 0 ) { let tmpStackMod = tmpStack [ tmpStack . length - 1 ] % k ; let tmpMod = tmp % k ; if ( ( tmpStackMod > tmpMod ) || ( tmpStackMod == tmpMod && tmpStack [ tmpStack . length - 1 ] > tmp ) ) { input . push ( tmpStack [ tmpStack . length - 1 ] ) ; tmpStack . pop ( ) ; } else break ; } tmpStack . push ( tmp ) ; } while ( tmpStack . length != 0 ) { input . push ( tmpStack [ tmpStack . length - 1 ] ) ; tmpStack . pop ( ) ; } while ( input . length != 0 ) { document . write ( input . pop ( ) + "▁" ) ; } }
function maxLen ( arr , n ) { var c_sum = 0 ; arr . sort ( ( a , b ) => b - a )  for ( var i = 0 ; i < n ; i ++ ) { c_sum += arr [ i ] ; if ( c_sum < 0 ) return i ; } return n ; }
function isPossible ( range , N ) { let test = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { test [ i ] = new interval ( ) ; test [ i ] . l = range [ i ] [ 0 ] ; test [ i ] . r = range [ i ] [ 1 ] ; test [ i ] . v = range [ i ] [ 2 ] ; } test . sort ( function ( a , b ) { return ( a . v < b . v ? 1 : 0 ) ; } ) ; for ( let i = 0 ; i < N ; i ++ ) { let count = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) count [ i ] = 0 ; let current_velocity = test [ i ] . v ; let j = i ; while ( j < N && test [ j ] . v == current_velocity ) { for ( let k = test [ j ] . l ; k <= test [ j ] . r ; k ++ ) { count [ k ] ++ ; if ( count [ k ] >= 3 ) return false ; } j ++ ; } i = j - 1 ; } return true ; }
function maxSum ( a , n ) { a . sort ( ( a , b ) => a - b ) ; let sum = 0 ; for ( let i = 0 ; i < n - 1 ; i += 2 ) { sum += a [ i ] ; } return sum ; }
function minSteps ( arr , n ) { let maxVal = Math . max ( ... arr ) ; return maxVal ; }
function isPossible ( A , B , n , m , x , y ) { if ( x > n y > m ) return false ; A . sort ( ) ; B . sort ( ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
function sortWithRemainder ( arr , n , k ) { let v = new Array ( ) ; for ( let i = 0 ; i < k ; i ++ ) { v . push ( [ ] ) } for ( let i = 0 ; i < n ; i ++ ) { v [ arr [ i ] % k ] . push ( arr [ i ] ) ; } for ( let i = 0 ; i < k ; i ++ ) v [ i ] . sort ( ( a , b ) => a - b ) ; console . log ( v )  let j = 0 ; for ( let i = 0 ; i < k ; i ++ ) { for ( let it of v [ i ] ) { arr [ j ] = it ; j ++ ; } } prletArr ( arr , n ) ; }
function minOperations ( ar , k ) { ar . sort ( function ( a , b ) { return a - b } ) ; let opsNeeded = 0 ; for ( let i = 0 ; i < k ; i ++ ) { opsNeeded += ar [ k - 1 ] - ar [ i ] ; } let ans = opsNeeded ; for ( let i = k ; i < ar . length ; i ++ ) { opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) ; opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) ; ans = Math . min ( ans , opsNeeded ) ; } return ans ; }
function getNumber ( n , k ) { var arr = Array ( n ) . fill ( n ) ; var i = 0 ; var odd = 1 ; while ( odd <= n ) { arr [ i ++ ] = odd ; odd += 2 ; } var even = 2 ; while ( even <= n ) { arr [ i ++ ] = even ; even += 2 ; } return arr [ k - 1 ] ; }
function getNumber ( n , k ) { let pos ; if ( ( n % 2 ) == 0 ) { pos = parseInt ( n / 2 , 10 ) ; } else { pos = parseInt ( n / 2 , 10 ) + 1 ; } if ( k <= pos ) { return ( k * 2 - 1 ) ; } else return ( ( k - pos ) * 2 ) ; }
function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function CountPermutation ( a , n ) { let ways = 1 ; a . sort ( ) ; let size = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { size ++ ; } else { ways *= fact [ size ] ; size = 1 ; } } ways *= fact [ size ] ; return ways ; }
function dfs ( num , left , ct ) { if ( ct >= 15 ) return ; if ( left == 0 ) ans . add ( num ) ; for ( let i = 0 ; i <= Math . min ( left , 9 ) ; i ++ ) dfs ( num * 10 + i , left - i , ct + 1 ) ; }
function getKthNum ( m , k ) { dfs ( 0 , m , 0 ) ; let ct = 0 ; for ( let it of ans . values ( ) ) { ct ++ ; if ( ct == k ) { return it ; } } return - 1 ; }
function Min_Replace ( arr , n , k ) { arr . sort ( ( a , b ) => a - b )  var freq = Array ( MAX ) . fill ( 0 ) ; var p = 0 ; freq [ p ] = 1 ; for ( var i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } freq . sort ( ( a , b ) => b - a ) ; var ans = 0 ; for ( var i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; }
function minCost ( cost ) { let dist = new Array ( N ) ; dist . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }
function Segment ( x , l , n ) { if ( n == 1 ) return 1 ; let ans = 2 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; }
function Next_greater ( a , n , x ) { a . sort ( function ( aa , bb ) { return aa - bb } ) ; let low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
function Combination ( A , K ) { A . sort ( ( a , b ) => a - b ) ; let local = [ ] ; unique_combination ( 0 , 0 , K , local , A ) ; }
function xorOnSortedArray ( arr , n , k , x ) { let arr1 = new Array ( MAX + 1 ) . fill ( 0 ) ; let arr2 = new Array ( MAX + 1 ) . fill ( 0 ) ; let xor_val = new Array ( MAX + 1 ) ; for ( let i = 0 ; i < n ; i ++ ) arr1 [ arr [ i ] ] ++ ; for ( let i = 0 ; i <= MAX ; i ++ ) xor_val [ i ] = i ^ x ; while ( k -- ) { let count = 0 ; for ( let i = 0 ; i <= MAX ; i ++ ) { let store = arr1 [ i ] ; if ( arr1 [ i ] > 0 ) { if ( count % 2 == 0 ) { let div = Math . ceil ( arr1 [ i ] / 2 ) ; arr1 [ i ] = arr1 [ i ] - div ; arr2 [ xor_val [ i ] ] += div ; } else if ( count % 2 != 0 ) { let div = parseInt ( arr1 [ i ] / 2 ) ; arr1 [ i ] = arr1 [ i ] - div ; arr2 [ xor_val [ i ] ] += div ; } } count = count + store ; } for ( let i = 0 ; i <= MAX ; i ++ ) { arr1 [ i ] = arr1 [ i ] + arr2 [ i ] ; arr2 [ i ] = 0 ; } } let min = Number . MAX_VALUE ; let max = Number . MIN_VALUE ; for ( let i = 0 ; i <= MAX ; i ++ ) { if ( arr1 [ i ] > 0 ) { if ( min > i ) min = i ; if ( max < i ) max = i ; } } document . write ( min + "▁" + max ) ; }
function pairs_count ( arr , n , sum ) { let ans = 0 ; arr . sort ( ) ; let i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { let x = arr [ i ] , xx = i ; while ( i < j && arr [ i ] == x ) i ++ ; let y = arr [ j ] , yy = j ; while ( j >= i && arr [ j ] == y ) j -- ; if ( x == y ) { let temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; }
function findSubarray ( a , k , n ) { var vec = [ ] ; for ( var i = 0 ; i < n - k + 1 ; i ++ ) { var temp = [ ] ; for ( var j = i ; j < i + k ; j ++ ) { temp . push ( a [ j ] ) ; } vec . push ( temp ) ; } vec . sort ( )  return vec [ vec . length - 1 ] ; }
function knapSack ( W , wt , val , n ) { var maxratio = - 1000000000 ; var maxindex = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( parseInt ( val [ i ] / wt [ i ] ) > maxratio ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; }
function sortArray ( a , n ) { var ans = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) ans . push ( a [ i ] ) ; } ans . sort ( ( a , b ) => a - b ) ; var j = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) { a [ i ] = ans [ j ] ; j ++ ; } } for ( var i = 0 ; i < n ; i ++ ) document . write ( a [ i ] + "▁" ) ; }
function solution ( arr , x ) { let closestSum = Number . MAX_VALUE ; for ( let i = 0 ; i < arr . length ; i ++ ) { for ( let j = i + 1 ; j < arr . length ; j ++ ) { for ( let k = j + 1 ; k < arr . length ; k ++ ) { if ( Math . abs ( x - closestSum ) > Math . abs ( x - ( arr [ i ] + arr [ j ] + arr [ k ] ) ) ) closestSum = ( arr [ i ] + arr [ j ] + arr [ k ] ) ; } } } return closestSum ; }
function solution ( arr , x ) { arr . sort ( ( a , b ) => a - b ) ; let closestSum = 1000000000 ; for ( let i = 0 ; i < arr . length - 2 ; i ++ ) { let ptr1 = i + 1 , ptr2 = arr . length - 1 ; while ( ptr1 < ptr2 ) { let sum = arr [ i ] + arr [ ptr1 ] + arr [ ptr2 ] ; if ( Math . abs ( 1 * x - sum ) < Math . abs ( 1 * x - closestSum ) ) { closestSum = sum ; } if ( sum > x ) { ptr2 -- ; } else { ptr1 ++ ; } } } return closestSum ; }
function makearray ( v , V ) { let adj = [ ] ; for ( let i = 0 ; i < V ; i ++ ) { adj . push ( [ ] ) ; } for ( let i = 0 ; i < v . length ; i ++ ) { for ( let j = 0 ; j < v [ i ] . length - 1 ; j ++ ) { addEdge ( adj , v [ i ] [ j ] , v [ i ] [ j + 1 ] ) ; } } let indeg = [ ] ; for ( let i = 0 ; i < V ; i ++ ) { indeg . push ( 0 ) ; } getindeg ( adj , V , indeg ) ; let res = topo ( adj , V , indeg ) ; return res ; }
function existsTriplet ( a , b , c , x , l1 , l2 , l3 ) { if ( l2 <= l1 && l2 <= l3 ) { temp = l1 ; l1 = l2 ; l2 = temp ; temp = a ; a = b ; b = temp ; } else if ( l3 <= l1 && l3 <= l2 ) { temp = l1 ; l1 = l3 ; l3 = temp ; temp = a ; a = c ; c = temp ; } for ( var i = 0 ; i < l1 ; i ++ ) { var j = 0 , k = l3 - 1 ; while ( j < l2 && k >= 0 ) { if ( a [ i ] + b [ j ] + c [ k ] == x ) return true ; if ( a [ i ] + b [ j ] + c [ k ] < x ) j ++ ; else k -- ; } } return false ; }
function compressArr ( arr , n ) { let i = 0 , j = 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; while ( i < n ) { j = i ; while ( ( j + 1 < n ) && ( arr [ j + 1 ] == arr [ j ] + 1 ) ) { j ++ ; } if ( i == j ) { document . write ( arr [ i ] + "▁" ) ; i ++ ; } else { document . write ( arr [ i ] + "-" + arr [ j ] + "▁" ) ; i = j + 1 ; } } }
function partition ( arr , low , high , mod ) { var pivot = arr [ high ] ; var i = ( low - 1 ) ; var piv = pivot % mod ; for ( var j = low ; j <= high - 1 ; j ++ ) { var a = arr [ j ] % mod ; if ( a <= piv ) { i ++ ; var t = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = t ; } } var t = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ high ] ; arr [ high ] = t ; return ( i + 1 ) ; }
function printArray ( arr , size ) { for ( var i = 0 ; i < size ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function check ( arr , n ) { let modify = 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) { arr [ n - 1 ] = arr [ n - 2 ] - 1 ; modify ++ ; } if ( arr [ 0 ] <= arr [ 1 ] ) { arr [ 0 ] = arr [ 1 ] + 1 ; modify ++ ; } for ( let i = n - 2 ; i > 0 ; i -- ) { if ( ( arr [ i - 1 ] <= arr [ i ] && arr [ i + 1 ] <= arr [ i ] ) || ( arr [ i - 1 ] >= arr [ i ] && arr [ i + 1 ] >= arr [ i ] ) ) { arr [ i ] = parseInt ( ( arr [ i - 1 ] + arr [ i + 1 ] ) / 2 , 10 ) ; modify ++ ; if ( arr [ i ] == arr [ i - 1 ] arr [ i ] == arr [ i + 1 ] ) return false ; } } if ( modify > 1 ) return false ; return true ; }
function inorder ( root ) { if ( root != null ) { inorder ( root . left ) ; document . write ( root . data + "▁" ) ; inorder ( root . right ) ; } }
function merge ( root1 , root2 ) { if ( root1 == null && root2 == null ) return ; if ( root1 == null ) { inorder ( root2 ) ; return ; } if ( root2 == null ) { inorder ( root1 ) ; return ; } let temp1 = root1 ; let prev1 = null ; while ( temp1 . left != null ) { prev1 = temp1 ; temp1 = temp1 . left ; } let temp2 = root2 ; let prev2 = null ; while ( temp2 . left != null ) { prev2 = temp2 ; temp2 = temp2 . left ; } if ( temp1 . data <= temp2 . data ) { document . write ( temp1 . data + "▁" ) ; if ( prev1 == null ) { merge ( root1 . right , root2 ) ; } else { prev1 . left = temp1 . right ; merge ( root1 , root2 ) ; } } else { document . write ( temp2 . data + "▁" ) ; if ( prev2 == null ) { merge ( root1 , root2 . right ) ; } else { prev2 . left = temp2 . right ; merge ( root1 , root2 ) ; } } }
function IsSorted ( A , B , n ) { for ( var i = 0 ; i < n ; i ++ ) { var x , y ; x = Math . max ( A [ i ] , B [ i ] ) ; y = Math . min ( A [ i ] , B [ i ] ) ; A [ i ] = x ; B [ i ] = y ; } for ( var i = 1 ; i < n ; i ++ ) { if ( A [ i ] <= A [ i - 1 ] B [ i ] <= B [ i - 1 ] ) return false ; } return true ; }
function removeElements ( arr , n ) { let brr = new Array ( n ) ; brr . fill ( 0 ) ; let l = 1 ; brr [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( brr [ l - 1 ] <= arr [ i ] ) { brr [ l ] = arr [ i ] ; l ++ ; } } for ( let i = 0 ; i < l ; i ++ ) document . write ( brr [ i ] + "▁" ) ; }
function maxWater ( height , n ) { let maximum = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { let current = ( Math . min ( height [ i ] , height [ j ] ) * ( j - i - 1 ) ) ; maximum = Math . max ( maximum , current ) ; } } return maximum ; }
function maxSelectionCount ( a , n ) { var res = 0 ; a . sort ( ) ; var select = 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= select ) { res ++ ; select ++ ; } } return res ; }
function findCombinations ( n ) { var a = new Array ( n ) . fill ( 0 ) ; findCombinationsUtil ( a , 0 , n , n ) ; }
function check ( arr , n ) { var modify = 0 ; if ( arr [ 0 ] > arr [ 1 ] ) { arr [ 0 ] = arr [ 1 ] / 2 ; modify ++ ; } for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( ( arr [ i - 1 ] < arr [ i ] && arr [ i + 1 ] < arr [ i ] ) || ( arr [ i - 1 ] > arr [ i ] && arr [ i + 1 ] > arr [ i ] ) ) { arr [ i ] = ( arr [ i - 1 ] + arr [ i + 1 ] ) / 2 ; if ( arr [ i ] == arr [ i - 1 ] arr [ i ] == arr [ i + 1 ] ) return false ; modify ++ ; } } if ( arr [ n - 1 ] < arr [ n - 2 ] ) modify ++ ; if ( modify > 1 ) return false ; return true ; }
function checkDivisors ( a , n ) { let X = Math . max ( ... a ) ; let b = [ ] ; for ( let i = 1 ; i * i <= X ; i ++ ) { if ( X % i == 0 ) { b . push ( i ) ; if ( parseInt ( X / i ) != i ) b . push ( parseInt ( X / i ) ) ; } } if ( b . length != n ) return false ; a . sort ( ( x , y ) => x - y ) ; b . sort ( ( x , y ) => x - y ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( b [ i ] != a [ i ] ) return false ; } return true ; }
function findX ( a , n ) { a . sort ( ( x , y ) => x - y ) ; let x = a [ 0 ] * a [ n - 1 ] ; let vec = [ ] ; for ( let i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { vec . push ( i ) ; if ( parseInt ( x / i ) != i ) vec . push ( parseInt ( x / i ) ) ; } } vec . sort ( ( x , y ) => x - y ) ; if ( vec . length != n ) return - 1 ; else { let i = 0 ; for ( let j = 0 ; j < vec . length ; j ++ ) { if ( a [ i ++ ] != vec [ j ] ) return - 1 ; } } return x ; }
function seive ( ) { for ( let i = 2 ; i < N ; i ++ ) { if ( ! prime [ i ] ) { for ( let j = i + i ; j < N ; j += i ) { prime [ j ] = 1 ; } } } prime [ 1 ] = 1 ; }
function maxSizeArr ( arr , n , k ) { let v = new Array ( ) ; let diff = new Array ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) v . push ( i ) ; } for ( let i = 1 ; i < v . length ; i ++ ) { diff . push ( v [ i ] - v [ i - 1 ] - 1 ) ; } diff . sort ( ( a , b ) => a - b ) ; for ( let i = 1 ; i < diff . length ; i ++ ) { diff [ i ] += diff [ i - 1 ] ; } if ( k > n || ( k == 0 && v . length ) ) { return - 1 ; } else if ( v . length <= k ) { return ( n - k ) ; } else if ( v . length > k ) { let tt = v . length - k ; let sum = 0 ; sum += diff [ tt - 1 ] ; let res = n - ( v . length + sum ) ; return res ; } }
function pendulumArrangement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let odd , temp , p , pos ; pos = n - 1 ; if ( n % 2 == 0 ) odd = n - 1 ; else odd = n - 2 ; while ( odd > 0 ) { temp = arr [ odd ] ; p = odd ; while ( p != pos ) { arr [ p ] = arr [ p + 1 ] ; p ++ ; } arr [ p ] = temp ; odd = odd - 2 ; pos = pos - 1 ; } let start = 0 , end = parseInt ( ( n - 1 ) / 2 , 10 ) ; for ( ; start < end ; start ++ , end -- ) { temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function fact ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
function nCr ( n , r ) { return parseInt ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) ; }
function CountSubset ( arr , n ) { let ans = powmod ( 2 , n - 1 ) ; arr . sort ( ) ; for ( let i = 0 ; i < n ; ++ i ) { let j = i + 1 ; while ( j < n && arr [ j ] == arr [ i ] ) { let r = n - 1 - j ; let l = i ; ans = ( ans + nCr ( l + r , l ) ) % mod ; j ++ ; } } return ans ; }
function Preprocess ( ) { arr [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= 1000 ; ++ i ) { arr [ i ] [ 0 ] = 1 ; for ( let j = 1 ; j < i ; ++ j ) { arr [ i ] [ j ] = ( arr [ i - 1 ] [ j - 1 ] + arr [ i - 1 ] [ j ] ) % mod ; } arr [ i ] [ i ] = 1 ; } }
function powmod ( a , n ) { if ( ! n ) return 1 ; let pt = powmod ( a , Math . floor ( n / 2 ) ) ; pt = ( pt * pt ) % mod ; if ( n % 2 ) return ( pt * a ) % mod ; else return pt ; }
function CountSubset ( val , n ) { let ans = powmod ( 2 , n - 1 ) ; val . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < n ; ++ i ) { let j = i + 1 ; while ( j < n && val [ j ] == val [ i ] ) { let r = n - 1 - j ; let l = i ; ans = ( ans + arr [ l + r ] [ l ] ) % mod ; j ++ ; } } return ans ; }
function reArrange ( words , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) mp . set ( words [ i ] , i + 1 ) ; words . sort ( ) ; for ( var i = 0 ; i < n ; i ++ ) { document . write ( mp . get ( words [ i ] ) + "▁" ) ; } }
function findNumber ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; var max = arr [ n - 1 ] ; var table = Array ( ( 2 * max ) + 1 ) . fill ( 0 ) ; table [ 0 ] = 0 ; for ( i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) table [ i ] = Number . MAX_VALUE ; var ans = - 1 ; for ( i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( arr [ j ] <= i ) { var res = table [ i - arr [ j ] ] ; if ( res != Number . MAX_VALUE && res + 1 < table [ i ] ) table [ i ] = res + 1 ; } } if ( i > arr [ n - 1 ] && table [ i ] == Number . MAX_VALUE ) { ans = i ; break ; } } return ans ; }
function power ( x , y ) { let res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % MOD ; } y = y >> 1 ; x = ( x * x ) % MOD ; } return res % MOD ; }
function combi ( n , k ) { let i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] % MOD + C [ i - 1 ] [ j ] % MOD ) % MOD ; } } }
function findSumofEle ( arr1 , m , arr2 , n ) { let MAX = 100000 ; let hash = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) hash [ i ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) hash [ arr2 [ i ] ] ++ ; for ( let i = 1 ; i < MAX ; i ++ ) hash [ i ] = hash [ i ] + hash [ i - 1 ] ; let maximumFreq = 0 ; for ( let i = 0 ; i < m ; i ++ ) { maximumFreq = Math . max ( maximumFreq , hash [ arr1 [ i ] ] ) ; } let sumOfElements = 0 ; for ( let i = 0 ; i < m ; i ++ ) { if ( maximumFreq == hash [ arr1 [ i ] ] ) sumOfElements += arr1 [ i ] ; } return sumOfElements ; }
function MinimizeleftOverSum ( a , n ) { var v1 = [ ] , v2 = [ ] ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) v1 . push ( a [ i ] ) ; else v2 . push ( a [ i ] ) ; } if ( v1 . length > v2 . length ) { v1 . sort ( ) ; v2 . sort ( ) ; var x = v1 . length - v2 . length - 1 ; var sum = 0 ; var i = 0 ; while ( i < x ) { sum += v1 [ i ++ ] ; } return sum ; } else if ( v2 . length > v1 . length ) { v1 . sort ( ) ; v2 . sort ( ) ; var x = v2 . length - v1 . length - 1 ; var sum = 0 ; var i = 0 ; while ( i < x ) { sum += v2 [ i ++ ] ; } return sum ; } else return 0 ; }
function printList ( head ) { while ( head != null ) { document . write ( head . data + "▁" ) ; head = head . next ; } }
function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] ) ; }
function compare ( num1 , num2 ) { let A = num1 . toString ( ) ; let B = num2 . toString ( ) ; return ( A + B ) . localeCompare ( B + A ) ; }
function printSmallest ( N , arr ) { for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( compare ( arr [ i ] , arr [ j ] ) > 0 ) { let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } printArr ( arr , N ) ; }
function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function isUgly ( n ) { while ( n % 2 == 0 ) n = n / 2 ; while ( n % 3 == 0 ) n = n / 3 ; while ( n % 5 == 0 ) n = n / 5 ; if ( n == 1 ) return true ; return false ; }
function sortUglyNumbers ( arr , n ) { var list = [ ] ; var i ; for ( i = 0 ; i < n ; i ++ ) { if ( isUgly ( arr [ i ] ) ) { list . push ( arr [ i ] ) ; arr [ i ] = - 1 ; } } list . sort ( ( a , b ) => a - b ) ; var j = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == - 1 ) document . write ( list [ j ++ ] + "▁" ) ; else document . write ( arr [ i ] + "▁" ) ; } }
function getMaxMedian ( arr , n , k ) { let size = n + k ; arr . sort ( ( a , b ) => a - b ) ; if ( size % 2 == 0 ) { let median = ( arr [ Math . floor ( size / 2 ) - 1 ] + arr [ Math . floor ( size / 2 ) ] ) / 2 ; return median ; } let median = arr [ Math . floor ( size / 2 ) ] ; return median ; }
function sortArr ( arr , n , k ) { var prev = - 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { if ( prev != - 1 ) var tmp = arr . slice ( prev + 1 , i ) . sort ( ( a , b ) => a - b ) ; for ( var j = prev + 1 ; j < i ; j ++ ) { arr [ j ] = tmp [ j - prev - 1 ] ; } prev = i ; } } printArr ( arr , n ) ; }
function findSquare ( n ) { let points = [ [ 1 , 2 ] , [ - 3 , 4 ] , [ 1 , 78 ] , [ - 3 , - 7 ] ] ; let a = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { let x , y ; x = points [ i ] [ 0 ] ; y = points [ i ] [ 1 ] ; a [ i ] = Math . max ( mod ( x ) , mod ( y ) ) ; } a . sort ( function ( a , b ) { return a - b } ) ; let index = ( Math . floor ( n / 2 ) - 1 ) ; document . write ( "Minimum▁M▁required▁is:▁" + a [ index ] ) ; }
function printArray ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function removeMin ( arr , n ) { var i , minVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) minVal = Math . min ( minVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] - minVal ; }
function removeFromMax ( arr , n ) { var i , maxVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) maxVal = Math . max ( maxVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = maxVal - arr [ i ] ; }
function modifyArray ( arr , n , k ) { if ( k % 2 == 0 ) removeMin ( arr , n ) ; else removeFromMax ( arr , n ) ; printArray ( arr , n ) ; }
function findKth ( arr , n , k ) { var missing = new Set ( ) ; var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) missing . add ( arr [ i ] ) ; var maxm = arr . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var minm = arr . reduce ( ( a , b ) => Math . min ( a , b ) ) ; for ( var i = minm + 1 ; i < maxm ; i ++ ) { if ( ! missing . has ( i ) ) count ++ ; if ( count == k ) return i ; } return - 1 ; }
function minOperation ( S , N , K ) { if ( N % K ) { document . write ( "Not▁Possible" ) ; return ; } var count = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < N ; i ++ ) { count [ S [ i ] . charCodeAt ( 0 ) - 97 ] ++ ; } var E = N / K ; var greaterE = [ ] ; var lessE = [ ] ; for ( var i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] < E ) lessE . push ( E - count [ i ] ) ; else greaterE . push ( count [ i ] - E ) ; } greaterE . sort ( ) ; lessE . sort ( ) ; var mi = 1000000000 ; for ( var i = 0 ; i <= K ; i ++ ) { var set1 = i ; var set2 = K - i ; if ( greaterE . length >= set1 && lessE . length >= set2 ) { var step1 = 0 ; var step2 = 0 ; for ( var j = 0 ; j < set1 ; j ++ ) step1 += greaterE [ j ] ; for ( var j = 0 ; j < set2 ; j ++ ) step2 += lessE [ j ] ; mi = Math . min ( mi , Math . max ( step1 , step2 ) ) ; } } document . write ( mi ) ; }
function printPermutations ( n , a , k ) { var arr = Array . from ( Array ( n ) , ( ) => Array ( 2 ) ) ; for ( var i = 0 ; i < n ; i ++ ) { arr [ i ] [ 0 ] = a [ i ] ; arr [ i ] [ 1 ] = i ; } arr . sort ( ) ; var count = 1 ; for ( var i = 1 ; i < n ; i ++ ) if ( arr [ i ] [ 0 ] == arr [ i - 1 ] [ 0 ] ) count ++ ; if ( count < k ) { document . write ( "-1" ) ; return ; } for ( var i = 0 ; i < k - 1 ; i ++ ) { printIndices ( n , arr ) ; for ( var j = next_pos ; j < n ; j ++ ) { if ( arr [ j ] [ 0 ] == arr [ j - 1 ] [ 0 ] ) { [ arr [ j ] , arr [ j - 1 ] ] = [ arr [ j - 1 ] , arr [ j ] ] ; next_pos = j + 1 ; break ; } } } printIndices ( n , arr ) ; }
function findAnswer ( n , arr ) { arr . sort ( ( a , b ) => a - b ) ; let sum = 0 ; for ( let i = 0 ; i < Math . floor ( n / 2 ) ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; }
function merge ( l , r , output ) { var l_in = l * n , r_in = ( parseInt ( ( l + r ) / 2 ) + 1 ) * n ; var l_c = ( parseInt ( ( l + r ) / 2 ) - l + 1 ) * n ; var r_c = ( r - parseInt ( ( l + r ) / 2 ) ) * n ; var l_arr = Array ( l_c ) , r_arr = Array ( r_c ) ; for ( var i = 0 ; i < l_c ; i ++ ) l_arr [ i ] = output [ l_in + i ] ; for ( var i = 0 ; i < r_c ; i ++ ) r_arr [ i ] = output [ r_in + i ] ; var l_curr = 0 , r_curr = 0 ; var par = l_in ; while ( l_curr + r_curr < l_c + r_c ) { if ( r_curr == r_c || ( l_curr != l_c && l_arr [ l_curr ] < r_arr [ r_curr ] ) ) { output [ par ] = l_arr [ l_curr ] ; l_curr ++ , par ++ ; } else { output [ par ] = r_arr [ r_curr ] ; r_curr ++ , par ++ ; } } }
function divide ( l , r , output , arr ) { if ( l == r ) { for ( var i = 0 ; i < n ; i ++ ) output [ l * n + i ] = arr [ l ] [ i ] ; return ; } divide ( l , parseInt ( ( l + r ) / 2 ) , output , arr ) ; divide ( parseInt ( ( l + r ) / 2 ) + 1 , r , output , arr ) ; merge ( l , r , output ) ; }
function minSum ( arr , n ) { arr . sort ( ) ; let x = arr [ Math . floor ( n / 2 ) ] ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += Math . abs ( arr [ i ] - x ) ; return sum ; }
function minOperations ( n , m , k , matrix ) { let arr = new Array ( n * m ) ; arr . fill ( 0 ) ; let mod = matrix [ 0 ] [ 0 ] % k ; for ( let i = 0 ; i < n ; ++ i ) { for ( let j = 0 ; j < m ; ++ j ) { arr [ i * m + j ] = matrix [ i ] [ j ] ; if ( matrix [ i ] [ j ] % k != mod ) { return - 1 ; } } } arr . sort ( function ( a , b ) { return a - b } ) ; let median = arr [ parseInt ( ( n * m ) / 2 , 10 ) ] ; let minOperations = 0 ; for ( let i = 0 ; i < n * m ; ++ i ) minOperations += parseInt ( Math . abs ( arr [ i ] - median ) / k , 10 ) ; if ( ( n * m ) % 2 == 0 ) { let median2 = arr [ parseInt ( ( n * m ) / 2 , 10 ) ] ; let minOperations2 = 0 ; for ( let i = 0 ; i < n * m ; ++ i ) minOperations2 += parseInt ( Math . abs ( arr [ i ] - median2 ) / k , 10 ) ; minOperations = Math . min ( minOperations , minOperations2 ) ; } return minOperations ; }
function minOperations ( n , m , k , matrix ) { let arr = [ ] ; let mod ; if ( matrix [ 0 ] [ 0 ] < 0 ) { mod = k - ( Math . abs ( matrix [ 0 ] [ 0 ] ) % k ) ; } else { mod = matrix [ 0 ] [ 0 ] % k ; } for ( let i = 0 ; i < n ; ++ i ) { for ( let j = 0 ; j < m ; ++ j ) { arr . push ( matrix [ i ] [ j ] ) ; let val = matrix [ i ] [ j ] ; if ( val < 0 ) { let res = k - ( Math . abs ( val ) % k ) ; if ( res != mod ) { return - 1 ; } } else { let foo = matrix [ i ] [ j ] ; if ( foo % k != mod ) { return - 1 ; } } } } arr . sort ( function ( a , b ) { return a - b ; } ) ; let median = arr [ ( n * m ) / 2 ] ; let minOperations = 0 ; for ( let i = 0 ; i < n * m ; ++ i ) minOperations += Math . abs ( arr [ i ] - median ) / k ; if ( ( n * m ) % 2 == 0 ) { let median2 = arr [ ( ( n * m ) / 2 ) - 1 ] ; let minOperations2 = 0 ; for ( let i = 0 ; i < n * m ; ++ i ) minOperations2 += Math . abs ( arr [ i ] - median2 ) / k ; minOperations = Math . min ( minOperations , minOperations2 ) ; } return minOperations ; }
function countDistinct ( arr , n ) { let res = 1 ; for ( let i = 1 ; i < n ; i ++ ) { let j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] === arr [ j ] ) break ; if ( i === j ) res ++ ; } return res ; }
function countDistinct ( arr , n ) { let hs = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { hs . add ( arr [ i ] ) ; } return hs . size ; }
function printArray ( arr , n ) { for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function printMaxMean ( arr , n ) { var newArr = Array ( n ) . fill ( 0 ) ; arr . sort ( ( a , b ) => a - b ) ; for ( i = 0 ; i < n ; i ++ ) newArr [ i ] = arr [ i + n ] ; printArray ( newArr , n ) ; }
function Minimum_Cells ( v ) { let col = new Array ( 3 ) ; let i , j ; for ( i = 0 ; i < 3 ; i ++ ) { let column_number = v [ i ] [ 1 ] ; col [ i ] = column_number ; } col . sort ( function ( a , b ) { return a - b } ) ; v . sort ( ) ; let MidRow = v [ 1 ] [ 0 ] ; let s = new Set ( ) ; let Maxcol = col [ 2 ] , MinCol = col [ 0 ] ; for ( i = MinCol ; i <= Maxcol ; i ++ ) { s . add ( [ MidRow , i ] ) ; } for ( i = 0 ; i < 3 ; i ++ ) { if ( v [ i ] [ 0 ] == MidRow ) continue ; for ( j = Math . min ( v [ i ] [ 0 ] , MidRow ) ; j <= Math . max ( v [ i ] [ 0 ] , MidRow ) ; j ++ ) { s . add ( [ j , v [ i ] [ 0 ] ] ) ; } } return s . size - 2 ; }
function countPairs ( a , n ) { let map = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { map . set ( a [ i ] , 1 ) ; } let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( map . get ( a [ i ] ) < 1 ) continue ; let cur = 1 ; while ( cur <= a [ i ] ) cur <<= 1 ; if ( map . has ( cur - a [ i ] ) ) { if ( cur - a [ i ] == a [ i ] && map . get ( a [ i ] ) == 1 ) continue ; count ++ ; map . set ( cur - a [ i ] , map . get ( cur - a [ i ] ) - 1 ) ; map . set ( a [ i ] , map . get ( a [ i ] ) - 1 ) ; } } return count ; }
function countSequences ( arr , n ) { let count = 1 ; arr . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
function average ( arr , n , k ) { var total = 0 ; if ( 2 * k >= n ) return 0 ; arr . sort ( ) ; var start = k , end = n - k - 1 ; for ( i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; }
function partSort ( arr , N , a , b ) { let l = Math . min ( a , b ) ; let r = Math . max ( a , b ) ; let temp = new Array ( r - l + 1 ) ; temp . fill ( 0 ) ; let j = 0 ; for ( let i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } temp . sort ( function ( a , b ) { return a - b } ) ; j = 0 ; for ( let i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function partSort ( arr , N , a , b ) { var l = Math . min ( a , b ) ; var r = Math . max ( a , b ) ; var i , j ; for ( i = l ; i < r + 1 + 1 ; i ++ ) { for ( j = l ; j < r - i + 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { swap ( arr , j , j + 1 ) ; } } } for ( i = 0 ; i < N ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function minMovesToSort ( arr , n ) { var moves = 0 ; var i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; mn = arr [ i ] ; } return moves ; }
function transpose ( mat , n ) { let temp = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } } }
function sortMatRowAndColWise ( mat , n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; }
function minimumMoves ( a , n ) { let operations = 0 ; a . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) operations += Math . abs ( a [ i ] - ( i + 1 ) ) ; return operations ; }
function min_sum ( n , k , a ) { a . sort ( ) ; if ( a [ 0 ] < 0 ) return - 1 ; if ( k == 0 ) { if ( a [ 0 ] == a [ n - 1 ] ) return ( n * a [ 0 ] ) ; else return - 1 ; } else { let f = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let p = a [ i ] - a [ 0 ] ; if ( p % k == 0 ) continue ; else { f = 1 ; break ; } } if ( f > 0 ) return - 1 ; else { if ( k == 1 ) return n ; else return ( n * ( a [ 0 ] % k ) ) ; } } }
function printCase ( n ) { if ( n <= 2 ) { document . write ( - 1 ) ; return ; } for ( let i = n ; i >= 1 ; i -- ) document . write ( i + "▁" ) ; }
function merge ( arr , start , mid , end ) { let start2 = mid + 1 ; if ( arr [ mid ] <= arr [ start2 ] ) { return ; } while ( start <= mid && start2 <= end ) { if ( arr [ start ] <= arr [ start2 ] ) { start ++ ; } else { let value = arr [ start2 ] ; let index = start2 ; while ( index != start ) { arr [ index ] = arr [ index - 1 ] ; index -- ; } arr [ start ] = value ; start ++ ; mid ++ ; start2 ++ ; } } }
function mergeSort ( arr , l , r ) { if ( l < r ) { let m = l + Math . floor ( ( r - l ) / 2 ) ; mergeSort ( arr , l , m ) ; mergeSort ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } }
function minCost ( A , n ) { var cost = 0 ; A . sort ( ) ; var K = A [ parseInt ( n / 2 ) ] ; var i ; for ( i = 0 ; i < n ; ++ i ) cost += Math . abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { var tempCost = 0 ; K = A [ parseInt ( n / 2 ) - 1 ] ; for ( i = 0 ; i < n ; ++ i ) tempCost += Math . abs ( A [ i ] - K ) ; cost = Math . min ( cost , tempCost ) ; } return cost ; }
function check ( n , k , a , b ) { a . sort ( ) ; b . sort ( ) ; let fl = false ; let ind = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) { if ( fl == true ) { return false ; } fl = true ; ind = i ; } } if ( ind == - 1 | Math . abs ( a [ ind ] - b [ ind ] ) <= k ) { return true ; } return false ; }
function items ( n , a ) { a . sort ( function ( a , b ) { return a - b } ) ; let z = a [ n - 1 ] ; let x = 1 ; let s = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { s += a [ i ] ; if ( s <= z ) x += 1 ; else break ; } return x ; }
function sortWithSetbits ( arr , n , k ) { var v1 = [ ] , v2 = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( bitCount ( arr [ i ] ) == k ) { v1 . push ( i ) ; v2 . push ( arr [ i ] ) ; } } v2 . sort ( ( a , b ) => a - b ) ; for ( var i = 0 ; i < v1 . length ; i ++ ) arr [ v1 [ i ] ] = v2 [ i ] ; for ( var i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function findOptimalSolution ( a , N ) { a . sort ( function ( a , b ) { return a - b } ) ; let points = 0 ; for ( let i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; }
function printArray ( arr , n ) { arr . sort ( ) ; let l = 0 , r = n - 1 , flag = 0 , i ; let k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) document . write ( arr [ i ] + "▁" ) ; flag = 1 ; l = i ; } else { for ( i = r ; i > r - k && i >= l ; i -- ) document . write ( arr [ i ] + "▁" ) ; flag = 0 ; r = i ; } k ++ ; } }
function sortMultiples ( arr , n , x ) { var v = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % x == 0 ) { v . push ( arr [ i ] ) ; } } v . sort ( ( a , b ) => a - b ) ; var j = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % x == 0 ) arr [ i ] = v [ j ++ ] ; } }
function kThLexString ( st , k , n ) { var z = new Set ( ) ; for ( var i = 0 ; i < n ; i ++ ) { var pp = "" ; for ( var j = i ; j < i + k ; j ++ ) { if ( j >= n ) break ; pp += st [ j ] ; z . add ( pp ) ; } } var fin = [ ] ; z . forEach ( element => { fin . push ( element ) ; } ) ; fin . sort ( ) ; document . write ( fin [ k - 1 ] ) ; }
function SieveOfEratosthenes ( n ) { prime [ 1 ] = false ; for ( var p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( var i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } }
function sortPrimes ( arr , n ) { SieveOfEratosthenes ( 100005 ) ; var v = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) v . push ( arr [ i ] ) ; } v . sort ( ( a , b ) => b - a )  var j = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) arr [ i ] = v [ j ++ ] ; } }
function number_of_tower ( house , range , n ) { house . sort ( function ( a , b ) { return a - b ; } ) ; let numOfTower = 0 ; let i = 0 ; while ( i < n ) { numOfTower ++ ; let loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
function countPairs ( first , second , value ) { let count = 0 ; while ( first != null && second != null && first != second && second . next != first ) { if ( ( first . data * second . data ) == value ) { count ++ ; first = first . next ; second = second . prev ; } else if ( ( first . data * second . data ) > value ) second = second . prev ; else first = first . next ; } return count ; }
function countTriplets ( head , x ) { if ( head == null ) return 0 ; let current , first , last ; let count = 0 ; last = head ; while ( last . next != null ) last = last . next ; for ( current = head ; current != null ; current = current . next ) { first = current . next ; count += countPairs ( first , last , x / current . data ) ; } return count ; }
function isAlphabaticOrder ( s ) { var n = s . length ; var c = new Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { c [ i ] = s [ i ] ; } c . sort ( ) ; for ( var i = 0 ; i < n ; i ++ ) if ( c [ i ] != s [ i ] ) return false ; return true ; }
function isAlphabaticOrder ( s ) { let n = s . length ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] < s [ i - 1 ] ) return false ; } return true ; }
function SieveOfEratosthenes ( n ) { prime . fill ( true ) ; prime [ 1 ] = false ; for ( var p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( var i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } }
function sortedArray ( arr , n ) { SieveOfEratosthenes ( 100005 ) ; var v = [ ] ; for ( var i = 0 ; i < n ; ++ i ) { if ( prime [ arr [ i ] ] == 0 ) v . push ( arr [ i ] ) ; } v . sort ( ) ; var j = 0 ; for ( var i = 0 ; i < n ; ++ i ) { if ( prime [ arr [ i ] ] == true ) document . write ( arr [ i ] + "▁" ) ; else { document . write ( v [ j ] + "▁" ) ; j ++ ; } } }
function findProduct ( arr , n ) { arr . sort ( ) ; var prod = 1 * arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { prod = prod * arr [ i + 1 ] ; } } return prod ; }
function rotateRec ( n , L , B ) { var m = Number . MAX_VALUE  for ( var i = 0 ; i < n ; i ++ ) { if ( Math . max ( L [ i ] , B [ i ] ) <= m ) m = Math . max ( L [ i ] , B [ i ] ) ; else if ( Math . min ( L [ i ] , B [ i ] ) <= m ) m = Math . min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }
function minimumIncrease ( a , b , c ) { var arr = [ a , b , c ] ; arr . sort ( ( a , b ) => a - b ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }
function sortList ( head ) { var startVal = 1 ; while ( head != null ) { head . data = startVal ; startVal ++ ; head = head . next ; } }
function push ( head_ref , new_data ) { var new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; start = head_ref ; }
function push ( head_ref , new_data ) { var new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; start = head_ref ; }
function minDistance ( n , k , points ) { for ( let i = 0 ; i < k ; i ++ ) ( point [ i ] ) . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < k ; i ++ ) document . write ( point [ i ] [ Math . ceil ( ( n / 2 ) - 1 ) ] + "▁" ) ; }
function solve ( N , M , cp , sp ) { let profit = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ; profit . sort ( function ( a , b ) { return b - a ; } ) ; let sum = 0 ; for ( let i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; }
function printOrder ( arr , n , k ) { let len1 = k , len2 = n - k ; let arr1 = new Array ( k ) ; let arr2 = new Array ( n - k ) ; for ( let i = 0 ; i < k ; i ++ ) arr1 [ i ] = arr [ i ] ; for ( let i = k ; i < n ; i ++ ) arr2 [ i - k ] = arr [ i ] ; arr1 . sort ( function ( a , b ) { return a - b ; } ) ; arr2 . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( i < k ) arr [ i ] = arr1 [ i ] ; else { arr [ i ] = arr2 [ len2 - 1 ] ; len2 -- ; } } for ( let i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function findMaxNum ( arr , n ) { var hash = Array ( 10 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( var i = 9 ; i >= 0 ; i -- ) { for ( var j = 0 ; j < hash [ i ] ; j ++ ) document . write ( i ) ; } }
function sortK ( arr , n , k ) { ( arr ) . sort ( function ( a , b ) { return a - b ; } ) ; }
function minimumSets ( arr , n , key ) { var i , j ; arr . sort ( ( a , b ) => a - b )  for ( i = 0 , j = n - 1 ; i <= j ; ++ i ) if ( arr [ i ] + arr [ j ] <= key ) j -- ; return i ; }
function distribution ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; var count = 1 ; for ( var i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return Math . min ( count , parseInt ( n / 2 ) ) ; }
function distribution ( arr , n ) { let resources = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) resources . add ( arr [ i ] ) ; return Math . min ( resources . size , parseInt ( n / 2 , 10 ) ) ; }
function merge ( arr , beg , mid , end , maxele ) { let i = beg ; let j = mid + 1 ; let k = beg ; while ( i <= mid && j <= end ) { if ( arr [ i ] % maxele <= arr [ j ] % maxele ) { arr [ k ] = arr [ k ] + ( arr [ i ] % maxele ) * maxele ; k ++ ; i ++ ; } else { arr [ k ] = arr [ k ] + ( arr [ j ] % maxele ) * maxele ; k ++ ; j ++ ; } } while ( i <= mid ) { arr [ k ] = arr [ k ] + ( arr [ i ] % maxele ) * maxele ; k ++ ; i ++ ; } while ( j <= end ) { arr [ k ] = arr [ k ] + ( arr [ j ] % maxele ) * maxele ; k ++ ; j ++ ; } for ( i = beg ; i <= end ; i ++ ) { arr [ i ] = Math . floor ( arr [ i ] / maxele ) ; } }
function mergeSortRec ( arr , beg , end , maxele ) { if ( beg < end ) { let mid = Math . floor ( ( beg + end ) / 2 ) ; mergeSortRec ( arr , beg , mid , maxele ) ; mergeSortRec ( arr , mid + 1 , end , maxele ) ; merge ( arr , beg , mid , end , maxele ) ; } }
function mergeSort ( arr , n ) { let maxele = Math . max ( ... arr ) + 1 ; mergeSortRec ( arr , 0 , n - 1 , maxele ) ; }
function printSorted ( s , l ) { var Stack = [ ] ; var tempstack = [ ] ; Stack . push ( s [ 0 ] . charCodeAt ( 0 ) ) ; for ( var i = 1 ; i < l ; i ++ ) { var a = s [ i ] . charCodeAt ( 0 ) ; var b = Stack [ Stack . length - 1 ] ; if ( ( a - b ) >= 1 || ( a == b ) ) Stack . push ( s [ i ] . charCodeAt ( 0 ) ) ; else if ( ( b - a ) >= 1 ) { while ( ( b - a ) >= 1 ) { tempstack . push ( Stack [ Stack . length - 1 ] ) ; Stack . pop ( ) ; if ( Stack . length > 0 ) b = Stack [ Stack . length - 1 ] ; else break ; } Stack . push ( s [ i ] . charCodeAt ( 0 ) ) ; while ( tempstack . length > 0 ) { Stack . push ( tempstack [ tempstack . length - 1 ] ) ; tempstack . pop ( ) ; } } } var answer = "" ; while ( Stack . length > 0 ) { answer = String . fromCharCode ( Stack [ Stack . length - 1 ] ) + answer ; Stack . pop ( ) ; } document . write ( answer ) }
function countTriplets ( arr , n , a , b ) { var ans = 0 ; for ( var i = 0 ; i < n - 2 ; i ++ ) { for ( var j = i + 1 ; j < n - 1 ; j ++ ) { for ( var k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) ans ++ ; } } return ans ; }
function countTriplets ( arr , n , a , b ) { var res ; res = countTripletsLessThan ( arr , n , b ) - countTripletsLessThan ( arr , n , a - 1 ) ; return res ; }
function checkFittingArrays ( A , B , N ) { A . sort ( function ( a , b ) { return a - b ; } ) ; B . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; }
function maximum_toys ( cost , N , K ) { let count = 0 , sum = 0 ; cost . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; }
function findMinimumSwaps ( arr , n , k ) { let pos , num_min , num_max , need_minimum , need_maximum , swaps ; num_min = num_max = need_minimum = 0 ; need_maximum = swaps = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < k ) num_min ++ ; else if ( arr [ i ] > k ) num_max ++ ; } for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == k ) { pos = i ; break ; } } let left , right , mid ; left = 0 ; right = n - 1 ; while ( left <= right ) { mid = parseInt ( ( left + right ) / 2 , 10 ) ; if ( arr [ mid ] == k ) { break ; } else if ( arr [ mid ] > k ) { if ( pos > mid ) need_minimum ++ ; else num_min -- ; left = mid + 1 ; } else { if ( pos < mid ) need_maximum ++ ; else num_max -- ; right = mid - 1 ; } } if ( need_minimum > need_maximum ) { swaps = swaps + need_maximum ; num_min = num_min - need_maximum ; need_minimum = need_minimum - need_maximum ; need_maximum = 0 ; } else { swaps = swaps + need_minimum ; num_max = num_max - need_minimum ; need_maximum = need_maximum - need_minimum ; need_minimum = 0 ; } if ( need_maximum > num_max need_minimum > num_min ) return - 1 ; else return ( swaps + need_maximum + need_minimum ) ; }
function findOptimalPairs ( arr , N ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; for ( var i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) document . write ( "(" + arr [ i ] + ",▁" + arr [ j ] + ")" + "▁" ) ; }
function sortStack ( input ) { while ( input . length != 0 ) { let tmp = input [ input . length - 1 ] ; input . pop ( ) ; while ( tmpStack . length != 0 && tmpStack [ tmpStack . length - 1 ] > tmp ) { input . push ( tmpStack [ tmpStack . length - 1 ] ) ; tmpStack . pop ( ) ; } tmpStack . push ( tmp ) ; } }
function sortedMerge ( s1 , s2 ) { while ( s1 . length != 0 ) { res . push ( s1 [ s1 . length - 1 ] ) ; s1 . pop ( ) ; } while ( s2 . length != 0 ) { res . push ( s2 [ s2 . length - 1 ] ) ; s2 . pop ( ) ; } sortStack ( res ) ; }
function MaxTotalRectangleArea ( a , n ) { a . sort ( ) ; a . reverse ( ) ; let sum = 0 ; let flag = false ; let len ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( ! flag ) ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; }
function isSortedDesc ( head ) { if ( head == null head . next == null ) return true ; return head . data > head . next . data && isSortedDesc ( head . next ) ; }
function evenOddInsertionSort ( arr , n ) { for ( let i = 2 ; i < n ; i ++ ) { let j = i - 2 ; let temp = arr [ i ] ; if ( ( ( i + 1 ) & 1 ) == 1 ) { while ( j >= 0 && temp >= arr [ j ] ) { arr [ j + 2 ] = arr [ j ] ; j -= 2 ; } arr [ j + 2 ] = temp ; } else { while ( j >= 0 && temp <= arr [ j ] ) { arr [ j + 2 ] = arr [ j ] ; j -= 2 ; } arr [ j + 2 ] = temp ; } } }
function sort ( a , n ) { for ( let i = n ; i >= 0 ; i -- ) for ( let j = n ; j > n - i ; j -- ) if ( a [ j ] > a [ j - 1 ] ) { let tempswap = a [ j ] ; a [ j ] = a [ j - 1 ] ; a [ j - 1 ] = tempswap ; } print ( a , n ) ; }
function insertionSort ( V ) { let N = V . length ; let i , j , key ; for ( i = 1 ; i < N ; i ++ ) { j = i ; while ( j > 0 && V [ j ] < V [ j - 1 ] ) { let temp = V [ j ] ; V [ j ] = V [ j - 1 ] ; V [ j - 1 ] = temp ; j -= 1 ; } } }
function insertionSortRecursive ( V , N ) { if ( N <= 1 ) return ; insertionSortRecursive ( V , N - 1 ) ; let j = N - 1 ; while ( j > 0 && V [ j ] < V [ j - 1 ] ) { let temp = V [ j ] ; V [ j ] = V [ j - 1 ] ; V [ j - 1 ] = temp ; j -= 1 ; } }
function sort012 ( arr , n ) { let count0 = 0 , count1 = 0 ; let count2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count0 ++ ; if ( arr [ i ] == 1 ) count1 ++ ; if ( arr [ i ] == 2 ) count2 ++ ; } for ( let i = 0 ; i < count0 ; i ++ ) arr [ i ] = 0 ; for ( let i = count0 ; i < ( count0 + count1 ) ; i ++ ) arr [ i ] = 1 ; for ( let i = ( count0 + count1 ) ; i < n ; i ++ ) arr [ i ] = 2 ; printArray ( arr , n ) ; }
function printArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; document . write ( ) ; }
function minElements ( arr , n ) { let halfSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = parseInt ( halfSum / 2 , 10 ) ; arr . sort ( function ( a , b ) { return a - b } ) ; arr . reverse ( ) ; let res = 0 , curr_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
function distancesum ( x , y , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
function distancesum ( arr , n ) { arr . sort ( ) ; let res = 0 , sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { res += ( arr [ i ] * i - sum ) ; sum += arr [ i ] ; } return res ; }
function totaldistancesum ( x , y , n ) { return distancesum ( x , n ) + distancesum ( y , n ) ; }
function minimumBox ( arr , n ) { var q = [ ] ; arr . sort ( ( a , b ) => a - b ) q . push ( arr [ 0 ] ) ; for ( var i = 1 ; i < n ; i ++ ) { var now = q [ 0 ] ; if ( arr [ i ] >= 2 * now ) q . pop ( 0 ) ; q . push ( arr [ i ] ) ; } return q . length ; }
function sortRec ( arr , index , k , n ) { if ( k == 0 ) { for ( let i = 1 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; document . write ( 999 ) ; return ; } else if ( k > 0 && index == 0 ) { index = n - 2 ; for ( let i = 1 ; i <= index ; i ++ ) { arr [ i - 1 ] = arr [ i ] ; } arr [ index ] = 999 ; } if ( index - 1 >= 0 && index + 1 < n && arr [ index - 1 ] > arr [ index + 1 ] ) { swap ( arr , index , index + 1 ) ; swap ( arr , index - 1 , index + 1 ) ; } else swap ( arr , index , index - 1 ) ; sortRec ( arr , index - 1 , k - 1 , n ) ; }
function sortString ( str ) { let charCount = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < charCount . length ; i ++ ) { charCount [ i ] = 0 ; } for ( let i = 0 ; i < str . length ; i ++ ) { charCount [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } for ( let i = MAX_CHAR - 1 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < charCount [ i ] ; j ++ ) { document . write ( String . fromCharCode ( "a" . charCodeAt ( 0 ) + i ) ) ; } } }
function printMedian ( arr , n , K ) { arr . sort ( ) ; document . write ( arr [ Math . floor ( ( n + K ) / 2 ) ] ) ; }
function stableSelectionSort ( a , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) { let min = i ; for ( let j = i + 1 ; j < n ; j ++ ) if ( a [ min ] > a [ j ] ) min = j ; let key = a [ min ] ; while ( min > i ) { a [ min ] = a [ min - 1 ] ; min -- ; } a [ i ] = key ; } }
function sortBinaryArray ( a , n ) { let j = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 ) { j ++ ; let temp = a [ j ] ; a [ j ] = a [ i ] ; a [ i ] = temp ; } } }
function almostSort ( A , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { let temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; i ++ ; } } for ( let i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; }
function minMaxSelectionSort ( arr , n ) { for ( var i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { var min = arr [ i ] ; var max = arr [ i ] ; var min_i = i ; var max_i = i ; for ( var k = i ; k <= j ; k ++ ) { if ( arr [ k ] > max ) { max = arr [ k ] ; max_i = k ; } else if ( arr [ k ] < min ) { min = arr [ k ] ; min_i = k ; } } swap ( arr , i , min_i ) ; if ( arr [ min_i ] == max ) swap ( arr , j , min_i ) ; else swap ( arr , j , max_i ) ; } }
function nextGap ( gap ) { if ( gap <= 1 ) return 0 ; return parseInt ( gap / 2 , 10 ) + ( gap % 2 ) ; }
function arrange ( arr , n , x ) { for ( let i = 1 ; i < n ; i ++ ) { let diff = Math . abs ( arr [ i ] - x ) ; let j = i - 1 ; if ( Math . abs ( arr [ j ] - x ) > diff ) { let temp = arr [ i ] ; while ( j >= 0 && Math . abs ( arr [ j ] - x ) > diff ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = temp ; } } }
function printOrder ( arr , n ) { arr . sort ( ) ; for ( i = 0 ; i < parseInt ( n / 2 ) ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } for ( j = n - 1 ; j >= parseInt ( n / 2 ) ; j -- ) { document . write ( arr [ j ] + "▁" ) ; } }
function findDuplicate ( arr , n , k ) { arr . sort ( ) ; let i = 0 ; while ( i < n ) { let j , count = 1 ; for ( j = i + 1 ; j < n && arr [ j ] == arr [ i ] ; j ++ ) count ++ ; if ( count == k ) return arr [ i ] ; i = j ; } return - 1 ; }
function findDuplicate ( arr , n , k ) { var freq = Array . from ( { length : MAX } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { document . write ( "Out▁of▁range" ) ; return - 1 ; } freq [ arr [ i ] ] += 1 ; } for ( var i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == k ) return i ; } return - 1 ; }
function maxProductSubarrayOfSizeK ( A , n , k ) { A . sort ( function ( a , b ) { return a - b } ) ; let product = 1 ; let i ; if ( A [ n - 1 ] == 0 && k % 2 != 0 ) return 0 ; if ( A [ n - 1 ] <= 0 && k % 2 != 0 ) { for ( i = n - 1 ; i >= n - k ; i -- ) product *= A [ i ] ; return product ; } i = 0 ; let j = n - 1 ; if ( k % 2 != 0 ) { product *= A [ j ] ; j -- ; k -- ; } k >>= 1 ; for ( let itr = 0 ; itr < k ; itr ++ ) { let left_product = A [ i ] * A [ i + 1 ] ; let right_product = A [ j ] * A [ j - 1 ] ; if ( left_product > right_product ) { product *= left_product ; i += 2 ; } else { product *= right_product ; j -= 2 ; } } return product ; }
function findMaximum ( arr , n , k ) { let res = 0 , index = 0 ; for ( let i = n - 1 ; i >= index ; i -- ) { res += arr [ i ] ; index += k ; } return res ; }
function insertionSort ( arr , left , right ) { for ( let i = left + 1 ; i <= right ; i ++ ) { let temp = arr [ i ] ; let j = i - 1 ; while ( j >= left && arr [ j ] > temp ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = temp ; } }
function merge ( arr , l , m , r ) { let len1 = m - l + 1 , len2 = r - m ; let left = new Array ( len1 ) ; let right = new Array ( len2 ) ; for ( let x = 0 ; x < len1 ; x ++ ) { left [ x ] = arr [ l + x ] ; } for ( let x = 0 ; x < len2 ; x ++ ) { right [ x ] = arr [ m + 1 + x ] ; } let i = 0 ; let j = 0 ; let k = l ; while ( i < len1 && j < len2 ) { if ( left [ i ] <= right [ j ] ) { arr [ k ] = left [ i ] ; i ++ ; } else { arr [ k ] = right [ j ] ; j ++ ; } k ++ ; } while ( i < len1 ) { arr [ k ] = left [ i ] ; k ++ ; i ++ ; } while ( j < len2 ) { arr [ k ] = right [ j ] ; k ++ ; j ++ ; } }
function checkForSorting ( arr , n ) { let temp = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }
function sort ( s , n ) { for ( let i = 1 ; i < n ; i ++ ) { let temp = s [ i ] ; let j = i - 1 ; while ( j >= 0 && temp . length < s [ j ] . length ) { s [ j + 1 ] = s [ j ] ; j -- ; } s [ j + 1 ] = temp ; } }
function printArraystring ( str , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( str [ i ] + "▁" ) ; }
function maxLevel ( boxes , n ) { boxes . sort ( ) ; let prev_width = boxes [ 0 ] ; let prev_count = 1 ; let curr_count = 0 ; let curr_width = 0 ; for ( let i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }
function stoogesort ( arr , l , h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) { let t = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = t ; } if ( h - l + 1 > 2 ) { let t = parseInt ( ( h - l + 1 ) / 3 , 10 ) ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } }
function merge ( arr , temp , left , mid , right ) { let inv_count = 0 ; let i = left ; let j = mid ; let k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) { temp [ k ++ ] = arr [ i ++ ] ; } else { temp [ k ++ ] = arr [ j ++ ] ; inv_count = inv_count + ( mid - i ) ; } } while ( i <= mid - 1 ) { temp [ k ++ ] = arr [ i ++ ] ; } while ( j <= right ) { temp [ k ++ ] = arr [ j ++ ] ; } for ( i = left ; i <= right ; i ++ ) { arr [ i ] = temp [ i ] ; } return inv_count ; }
function mergeSort ( arr , array_size ) { let temp = Array . from ( { length : array_size } , ( _ , i ) => 0 ) ; return _mergeSort ( arr , temp , 0 , array_size - 1 ) ; }
function minDifferenceAmongMaxMin ( arr , N , K ) { arr . sort ( ( a , b ) => a - b ) ; let res = 2147483647 ; for ( let i = 0 ; i <= ( N - K ) ; i ++ ) { let curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . min ( res , curSeqDiff ) ; } return res ; }
function insertionSortRecursive ( arr , n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; let last = arr [ n - 1 ] ; let j = n - 2 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; }
function twoWaySort ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] *= - 1 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; }
function partition ( arr , low , high ) { let pivot = arr [ low ] ; let i = low - 1 , j = high + 1 ; while ( true ) { do { i ++ ; } while ( arr [ i ] < pivot ) ; do { j -- ; } while ( arr [ j ] > pivot ) ; if ( i >= j ) return j ; let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } }
function quickSort ( arr , low , high ) { if ( low < high ) { let pi = partition ( arr , low , high ) ; quickSort ( arr , low , pi ) ; quickSort ( arr , pi + 1 , high ) ; } }
function ksmallest ( arr , n , k ) { let b = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( let j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) { k -- ; } if ( k != 1 ) { return j ; } } return Number . MAX_VALUE ; }
function ksmallest ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b } ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( let i = 1 ; i < n ; i ++ ) { let c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; }
function multiply ( A , B , C ) { for ( let i = 0 ; i < V ; i ++ ) { for ( let j = 0 ; j < V ; j ++ ) { C [ i ] [ j ] = 0 ; for ( let k = 0 ; k < V ; k ++ ) C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] ; } } }
function getTrace ( graph ) { let trace = 0 ; for ( let i = 0 ; i < V ; i ++ ) trace += graph [ i ] [ i ] ; return trace ; }
function triangleInGraph ( graph ) { let aux2 = new Array ( V ) ; let aux3 = new Array ( V ) ; for ( let i = 0 ; i < V ; ++ i ) { aux2 [ i ] = new Array ( V ) ; aux3 [ i ] = new Array ( V ) ; for ( let j = 0 ; j < V ; ++ j ) { aux2 [ i ] [ j ] = aux3 [ i ] [ j ] = 0 ; } } multiply ( graph , graph , aux2 ) ; multiply ( graph , aux2 , aux3 ) ; let trace = getTrace ( aux3 ) ; return ( trace / 6 ) ; }
function minSum ( arr , n ) { let evenArr = [ ] ; let oddArr = [ ] ; arr . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( i < Math . floor ( n / 2 ) ) { oddArr . push ( arr [ i ] ) ; } else { evenArr . push ( arr [ i ] ) ; } } evenArr . sort ( function ( a , b ) { return b - a ; } ) ; let i = 0 , sum = 0 ; for ( let j = 0 ; j < evenArr . length ; j ++ ) { arr [ i ++ ] = evenArr [ j ] ; arr [ i ++ ] = oddArr [ j ] ; sum += evenArr [ j ] * oddArr [ j ] ; } return sum ; }
function mergeTwoHalf ( A , n ) { A . sort ( ( a , b ) => a - b ) ; }
function minDiff ( arr , n , k ) { var result = Number . MAX_VALUE ; arr . sort ( ( a , b ) => a - b ) ; for ( i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
function isPossible ( a , b , n , k ) { a . sort ( function ( a , b ) { return a - b } ) ; b . reverse ( ) ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }
function bitonicGenerator ( arr , n ) { let evenArr = [ ] ; let oddArr = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 != 1 ) { evenArr . push ( arr [ i ] ) ; } else { oddArr . push ( arr [ i ] ) ; } } evenArr . sort ( function ( a , b ) { return a - b ; } ) ; oddArr . sort ( function ( a , b ) { return b - a ; } ) ; let i = 0 ; for ( let j = 0 ; j < evenArr . length ; j ++ ) { arr [ i ++ ] = evenArr [ j ] ; } for ( let j = 0 ; j < oddArr . length ; j ++ ) { arr [ i ++ ] = oddArr [ j ] ; } }
function findMinDiff ( arr , n , m ) { if ( m == 0 n == 0 ) return 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; if ( n < m ) return - 1 ; let min_diff = Number . MAX_VALUE ; for ( let i = 0 ; i + m - 1 < n ; i ++ ) { let diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; }
function minValue ( A , B , n ) { A . sort ( ) ; B . sort ( ) ; let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
function merge ( arr , temp , left , mid , right ) { let inv_count = 0 ; let i = left ; let j = mid ; let k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else { temp [ k ++ ] = arr [ j ++ ] ; inv_count = inv_count + ( mid - i ) ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; }
function _mergeSort ( arr , temp , left , right ) { let mid , inv_count = 0 ; if ( right > left ) { mid = Math . floor ( ( right + left ) / 2 ) ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; }
function isEven ( n ) { return ( n % 2 == 0 ) ; }
function isEven ( n ) { return ( ! ( n & 1 ) ) ; }
function findSubsequenceCount ( S , T ) { let m = T . length ; let n = S . length ; if ( m > n ) return 0 ; let mat = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; i ++ ) { mat [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) { mat [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( let j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( let i = 1 ; i <= m ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }
function countBits ( a ) { let count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; }
function insertionSort ( arr , aux , n ) { for ( let i = 1 ; i < n ; i ++ ) { let key1 = aux [ i ] ; let key2 = arr [ i ] ; let j = i - 1 ; while ( j >= 0 && aux [ j ] < key1 ) { aux [ j + 1 ] = aux [ j ] ; arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } aux [ j + 1 ] = key1 ; arr [ j + 1 ] = key2 ; } }
function sortBySetBitCount ( arr , n ) { let aux = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) aux [ i ] = countBits ( arr [ i ] ) ; insertionSort ( arr , aux , n ) ; }
function countBits ( a ) { let count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; }
function sortBySetBitCount ( arr , n ) { let count = new Array ( 32 ) ; for ( let i = 0 ; i < count . length ; i ++ ) count [ i ] = [ ] ; let setbitcount = 0 ; for ( let i = 0 ; i < n ; i ++ ) { setbitcount = countBits ( arr [ i ] ) ; count [ setbitcount ] . push ( arr [ i ] ) ; } let j = 0 ; for ( let i = 31 ; i >= 0 ; i -- ) { let v1 = count [ i ] ; for ( let p = 0 ; p < v1 . length ; p ++ ) arr [ j ++ ] = v1 [ p ] ; } }
function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function findSurpasser ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { let count = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; document . write ( count + "▁" ) ; } }
function printArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; document . write ( ) ; }
function solve ( arr , n ) { arr . sort ( ) ; let a = 0 , b = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
function maxProduct ( arr , n ) { if ( n < 3 ) return - 1 ; let max_product = Number . MIN_VALUE ; for ( let i = 0 ; i < n - 2 ; i ++ ) for ( let j = i + 1 ; j < n - 1 ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
function maxProduct ( arr , n ) { if ( n < 3 ) return - 1 ; leftMin = Array . from ( { length : n } , ( _ , i ) => - 1 ) ; rightMin = Array . from ( { length : n } , ( _ , i ) => - 1 ) ; leftMax = Array . from ( { length : n } , ( _ , i ) => - 1 ) ; rightMax = Array . from ( { length : n } , ( _ , i ) => - 1 ) ; var max_product = Number . MIN_VALUE ; var max_sum = arr [ 0 ] ; var min_sum = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) { leftMax [ i ] = max_sum ; if ( arr [ i ] > max_sum ) max_sum = arr [ i ] ; leftMin [ i ] = min_sum ; if ( arr [ i ] < min_sum ) min_sum = arr [ i ] ; } max_sum = arr [ n - 1 ] ; min_sum = arr [ n - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) { rightMax [ j ] = max_sum ; if ( arr [ j ] > max_sum ) max_sum = arr [ j ] ; rightMin [ j ] = min_sum ; if ( arr [ j ] < min_sum ) min_sum = arr [ j ] ; } for ( i = 1 ; i < n - 1 ; i ++ ) { var max1 = Math . max ( arr [ i ] * leftMax [ i ] * rightMax [ i ] , arr [ i ] * leftMin [ i ] * rightMin [ i ] ) ; var max2 = Math . max ( arr [ i ] * leftMax [ i ] * rightMin [ i ] , arr [ i ] * leftMin [ i ] * rightMax [ i ] ) ; max_product = Math . max ( max_product , Math . max ( max1 , max2 ) ) ; } return max_product ; }
function maxProduct ( arr , n ) { if ( n < 3 ) { return - 1 ; } arr . sort ( ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }
function maxProduct ( arr , n ) { if ( n < 3 ) return - 1 ; var maxA = Number . MIN_VALUE , maxB = Number . MIN_VALUE , maxC = Number . MIN_VALUE ; var minA = Number . MAX_VALUE , minB = Number . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; if ( arr [ i ] < minA ) { minB = minA ; minA = arr [ i ] ; } else if ( arr [ i ] < minB ) minB = arr [ i ] ; } return Math . max ( minA * minB * maxA , maxA * maxB * maxC ) ; }
function distinctCount ( arr , n ) { let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) s . add ( Math . abs ( arr [ i ] ) ) ; return s . size ; }
function distinctCount ( arr , n ) { let count = n ; let i = 0 , j = n - 1 , sum = 0 ; while ( i < j ) { while ( i != j && arr [ i ] == arr [ i + 1 ] ) count -- , i ++ ; while ( i != j && arr [ j ] == arr [ j - 1 ] ) count -- , j -- ; if ( i == j ) break ; sum = arr [ i ] + arr [ j ] ; if ( sum == 0 ) { count -- ; i ++ , j -- ; } else if ( sum < 0 ) i ++ ; else j -- ; } return count ; }
function findMaxGuests ( arrl , exit , n ) { arrl . sort ( function ( a , b ) { return a - b } ) ; exit . sort ( function ( a , b ) { return a - b } ) ; let guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; let i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } document . write ( "Maximum▁Number▁of▁Guests▁=▁" + max_guests + "▁at▁time▁" + time ) ; }
function binarySearch ( a , item , low , high ) { while ( low <= high ) { var mid = low + ( high - low ) / 2 ; if ( item == a [ mid ] ) return mid + 1 ; else if ( item > a [ mid ] ) low = mid + 1 ; else high = mid - 1 ; } return low ; }
function insertionSort ( a , n ) { var i , loc , j , k , selected ; for ( i = 1 ; i < n ; ++ i ) { j = i - 1 ; selected = a [ i ] ; loc = binarySearch ( a , selected , 0 , j ) ; while ( j >= loc ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = selected ; } }
function findMax ( arr , n ) { let mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; }
function printArray ( arr , arr_size ) { for ( let i = 0 ; i < arr_size ; i ++ ) document . write ( arr [ i ] + "▁" ) ; document . write ( "" ) ; }
function minMoves ( a , b , K ) { let n = a . length , m = a [ 0 ] . length ; let cntOperations = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) { cntOperations ++ ; if ( i + K - 1 >= n j + K - 1 >= m ) { return - 1 ; } for ( let p = 0 ; p <= K - 1 ; p ++ ) { for ( let q = 0 ; q <= K - 1 ; q ++ ) { if ( a [ i + p ] [ j + q ] == "0" ) { a [ i + p ] [ j + q ] = "1" ; } else { a [ i + p ] [ j + q ] = "0" ; } } } } } } return cntOperations ; }
function maxConsecutiveCnt ( arr ) { let X = 0 ; arr . sort ( function ( a , b ) { return a - b } )  for ( let i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] <= ( X + 1 ) ) { X = X + arr [ i ] ; } else { break ; } } return X + 1 ; }
function findPermutation ( N , L , R , S ) { let x = R - L + 1 ; if ( ! possible ( x , S , N ) ) { document . write ( - 1 ) ; return ; } else { let v = [ ] ; for ( let i = N ; i >= 1 ; -- i ) { if ( S - i >= 0 && possible ( x - 1 , S - i , i - 1 ) ) { S = S - i ; x -- ; v . push ( i ) ; } if ( S == 0 ) { break ; } } if ( S != 0 ) { document . write ( - 1 ) ; return ; } let v1 = [ ] ; for ( let i = 1 ; i <= N ; ++ i ) { it = v . includes ( i ) ; if ( ! it ) { v1 . push ( i ) ; } } let j = 0 , f = 0 ; for ( let i = 1 ; i < L ; ++ i ) { document . write ( v1 [ j ] + "▁" ) ; j ++ ; } for ( let i = L ; i <= R ; ++ i ) { document . write ( v [ f ] + "▁" ) ; f ++ ; } for ( let i = R + 1 ; i <= N ; ++ i ) { document . write ( v1 [ j ] + "▁" ) ; j ++ ; } } return ; }
function maxShiftArrayValue ( arr , cap , N ) { let sumVals = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sumVals += arr [ i ] ; } let maxCapacity = 0 ; for ( let i = 0 ; i < N ; i ++ ) { maxCapacity = Math . max ( cap [ i ] , maxCapacity ) ; } return Math . min ( maxCapacity , sumVals ) ; }
function minimumSizeArray ( S , P ) { if ( S == P ) { return 1 ; } for ( let i = 2 ; i <= S ; i ++ ) { let d = i ; if ( ( S / d ) >= Math . pow ( P , 1.0 / d ) ) { return i ; } } return - 1 ; }
function countPoints ( D ) { let count = 0 ; for ( let x = 1 ; x * x < D * D ; x ++ ) { let y = Math . floor ( Math . sqrt ( D * D - x * x ) ) ; if ( x * x + y * y == D * D ) { count += 4 ; } } count += 4 ; return count ; }
function minimizeCost ( A , B , C ) { let ans = A + B + C ; for ( let i = 1 ; i <= 2 * C ; i ++ ) { let j = 0 ; while ( i * j <= 2 * C ) { ans = Math . min ( ans , Math . abs ( A - i ) + Math . abs ( B - j ) + Math . abs ( i * j - C ) ) ; j ++ ; } } return ans ; }
function averageSetBits ( N , K , arr ) { let p = N ; let q = 0 ; for ( let i = 0 ; i < K ; i ++ ) { let _p = p , _q = q ; p = _p - _p * arr [ i ] / N + _q * arr [ i ] / N ; q = _q - _q * arr [ i ] / N + _p * arr [ i ] / N ; } return p ; }
function KthSolution ( X , K ) { let ans = 0 ; for ( let i = 0 ; i < 64 ; i ++ ) { if ( ! ( X & ( 1 << i ) ) ) { if ( K & 1 ) { ans |= ( 1 << i ) ; } K >>= 1 ; if ( ! K ) { break ; } } } return ans ; }
function minimumcoins ( arr , N ) { let coins = 0 ; let j = 0 ; if ( arr [ 0 ] == 1 ) coins ++ ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 2 ) continue ; j = i ; while ( j < N && arr [ j ] == 1 ) { j ++ ; } let x = ( j - i ) ; coins += Math . floor ( x / 3 ) ; i = j - 1 ; } return coins ; }
function maximumUniqueSquares ( N ) { var ans = 0 ; var i ; if ( N < 4 ) { return 0 ; } var len = Math . sqrt ( N ) ; N -= len * len ; for ( i = 1 ; i < len ; i ++ ) { ans += i * i ; } if ( N >= len ) { N -= len ; for ( i = 1 ; i < len ; i ++ ) { ans += i ; } } for ( i = 1 ; i < N ; i ++ ) { ans += i ; } return ans ; }
function rearrange ( arr , N ) { if ( N & 1 ) N -- ; let odd_idx = 1 , even_idx = 0 ; let i , max_elem = arr [ N - 1 ] + 1 ; for ( i = 0 ; i < N / 2 ; i ++ ) { arr [ i ] += ( arr [ odd_idx ] % max_elem ) * max_elem ; odd_idx += 2 ; } for ( ; i < N ; i ++ ) { arr [ i ] += ( arr [ even_idx ] % max_elem ) * max_elem ; even_idx += 2 ; } for ( let i = 0 ; i < N ; i ++ ) { arr [ i ] = arr [ i ] / max_elem ; } }
function generateString ( k1 , k2 , s ) { let C1s = 0 , C0s = 0 ; let flag = 0 ; let pos = [ ] ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == "0" ) { C0s ++ ; if ( ( i + 1 ) % k1 != 0 && ( i + 1 ) % k2 != 0 ) { pos . push ( i ) ; } } else { C1s ++ ; } if ( C0s >= C1s ) { if ( pos . length == 0 ) { cout << - 1 ; flag = 1 ; break ; } else { let k = pos [ pos . length - 1 ] ; var ns = s . replace ( s [ k ] , "1" ) ; C0s -- ; C1s ++ ; pos . pop ( ) ; } } } if ( flag == 0 ) { document . write ( ns ) ; } }
function findRange ( arr , N , K ) { let L = Number . MIN_VALUE ; let R = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let l = Math . ceil ( 1.0 * arr [ i ] * K / ( i + 1 ) ) ; let r = Math . ceil ( ( 1.0 + arr [ i ] ) * K / ( i + 1 ) ) - 1 ; L = Math . max ( L , l ) ; R = Math . min ( R , r ) ; } document . write ( L + "▁" + R ) ; }
function findAnagram ( s ) { let check = s . slice ( ) ; let i = 0 , j = s . length - 1 ; while ( i < s . length && j >= 0 ) { if ( s [ i ] != s [ j ] && check [ i ] != s [ j ] && check [ j ] != s [ i ] ) { s = swap ( s , i , j ) i ++ ; j = s . length - 1 ; } else { j -- ; } } if ( s . length % 2 != 0 ) { let mid = s . length / 2 ; if ( check [ mid ] == s [ mid ] ) { for ( let i = 0 ; i < s . length ; i ++ ) { if ( check [ i ] != s [ mid ] && s [ i ] != s [ mid ] ) { s = swap ( s , i , mid ) break ; } } } } let ok = true ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( check [ i ] == s [ i ] ) { ok = false ; break ; } } if ( ok ) document . write ( s ) ; else document . write ( - 1 ) ; }
function maximizeProduct ( N ) { let MSB = Math . log2 ( N ) ; let X = 1 << MSB ; let Y = N - ( 1 << MSB ) ; for ( let i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) { X += 1 << i ; Y += 1 << i ; } } document . write ( X + "▁" + Y ) ; }
function constructPermutation ( S , N ) { let ans = new Array ( N ) ; ans [ 0 ] = 1 ; for ( let i = 1 ; i < N ; ++ i ) { if ( S [ i - 1 ] == "0" ) { ans [ i ] = i + 1 ; } else { ans [ i ] = ans [ i - 1 ] ; } for ( let j = 0 ; j < i ; ++ j ) { if ( ans [ j ] >= ans [ i ] ) { ans [ j ] ++ ; } } } for ( let i = 0 ; i < N ; i ++ ) { document . write ( ans [ i ] ) ; if ( i != N - 1 ) { document . write ( "▁" ) ; } } }
function findRemainingIndex ( N ) { let ans = N ; while ( N > 1 ) { let discard = Math . floor ( Math . sqrt ( N ) ) ; if ( discard * discard == N ) { ans -- ; } N -= discard ; } return ans ; }
function findRemainingElement ( arr , N ) { let remainingIndex = findRemainingIndex ( N ) ; document . write ( arr [ remainingIndex - 1 ] ) ; }
function check ( num ) { let sm = 0 ; let num2 = num * num ; while ( num ) { sm += num % 10 ; num = Math . floor ( num / 10 ) ; } let sm2 = 0 ; while ( num2 ) { sm2 += num2 % 10 ; num2 = Math . floor ( num2 / 10 ) ; } return sm * sm == sm2 ; }
function generate ( s , len , uniq ) { if ( s . length == len ) { if ( check ( convert ( s ) ) ) { uniq . add ( convert ( s ) ) ; } return ; } for ( let i = 0 ; i <= 3 ; i ++ ) { generate ( s + String . fromCharCode ( i + "0" . charCodeAt ( 0 ) ) , len , uniq ) ; } }
function totalNumbers ( L , R ) { let ans = 0 ; let max_len = Math . log10 ( R ) + 1 ; let uniq = new Set ( ) ; for ( let i = 1 ; i <= max_len ; i ++ ) { generate ( "" , i , uniq ) ; } for ( let x of uniq ) { if ( x >= L && x <= R ) { ans ++ ; } } return ans ; }
function findMaximumSumWithMflips ( arr , N , M ) { let pq = [ ] let sum = 0  for ( let i = 0 ; i < N ; i ++ ) { pq . push ( arr [ i ] )  sum += arr [ i ] pq . sort ( ( a , b ) => a - b ) } while ( M > 0 ) { sum -= pq [ 0 ] temp = - 1 * pq [ 0 ] pq . shift ( ) sum += temp pq . push ( temp ) pq . sort ( ( a , b ) => a - b ) M -= 1 } document . write ( sum ) }
function check ( x , N ) { while ( true ) { N -= x ; if ( x < 10 ) break ; let temp2 = 0 ; while ( x > 0 ) { temp2 += ( x % 10 ) ; x = Math . floor ( x / 10 ) ; } x = temp2 ; } if ( ( x < 10 ) && ( N == 0 ) ) { return true ; } return false ; }
function minimumMoves ( A , B , N ) { var ans = 0 ; var i ; var sum_A = 0 , sum_B = 0 ; for ( i = 0 ; i < N ; i ++ ) { sum_A += A [ i ] ; } for ( i = 0 ; i < N ; i ++ ) { sum_B += B [ i ] ; } if ( sum_A != sum_B ) { return - 1 ; } var i = 0 ; while ( i < N ) { if ( A [ i ] > B [ i ] ) { var temp = A [ i ] - B [ i ] ; var j = i - 1 ; while ( j >= 0 && temp > 0 ) { if ( B [ j ] > A [ j ] ) { var cnt = Math . min ( temp , ( B [ j ] - A [ j ] ) ) ; A [ j ] += cnt ; temp -= cnt ; ans += ( cnt * Math . abs ( j - i ) ) ; } j -- ; } if ( temp > 0 ) { var j = i + 1 ; while ( j < N && temp > 0 ) { if ( B [ j ] > A [ j ] ) { var cnt = Math . min ( temp , ( B [ j ] - A [ j ] ) ) ; A [ j ] += cnt ; temp -= cnt ; ans += ( cnt * Math . abs ( j - i ) ) ; } j ++ ; } } } i ++ ; } return ans ; }
function possibleReachingSequence ( X , D , T ) { if ( X < T ) { document . write ( "NO" ) ; return 0 ; } if ( T * D < X ) { document . write ( "NO" ) ; return 0 ; } if ( ( X - T ) % ( D - 1 ) == 0 ) { document . write ( "YES" ) ; } else { document . write ( "NO" ) ; } return 0 ; }
function maxSumAfterPartition ( arr , n ) { let pos = [ ] ; let neg = [ ] ; let zero = 0 ; let pos_sum = 0 ; let neg_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { pos . push ( arr [ i ] ) ; pos_sum += arr [ i ] ; } else if ( arr [ i ] < 0 ) { neg . push ( arr [ i ] ) ; neg_sum += arr [ i ] ; } else { zero ++ ; } } let ans = 0 ; pos . sort ( function ( a , b ) { return a - b } ) neg . sort ( function ( a , b ) { return b - a } )  if ( pos . length > 0 && neg . length > 0 ) { ans = ( pos_sum - neg_sum ) ; } else if ( pos . length > 0 ) { if ( zero > 0 ) { ans = ( pos_sum ) ; } else { ans = ( pos_sum - 2 * pos [ 0 ] ) ; } } else { if ( zero > 0 ) { ans = ( - 1 * neg_sum ) ; } else { ans = ( neg [ 0 ] - ( neg_sum - neg [ 0 ] ) ) ; } } return ans ; }
function arrayDivisionByTwo ( arr , n ) { let cnt = 0 ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { cnt = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = Math . floor ( arr [ i ] / 2 ) ; cnt ++ ; } ans = Math . min ( ans , cnt ) ; } return ans ; }
function minPushes ( N , K , arr ) { let dp = new Array ( 100000 ) . fill ( - 1 ) ; dp [ N ] = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { for ( let xx = 0 ; xx < 100000 ; xx ++ ) { let x = xx ; if ( dp [ x ] == - 1 ) continue ; let next = ( x + arr [ i ] ) % 100000 ; while ( dp [ next ] == - 1 dp [ next ] > dp [ x ] + 1 ) { dp [ next ] = dp [ x ] + 1 ; x = next ; next = ( next + arr [ i ] ) % 100000 ; } } } return dp [ K ] ; }
function minimumOperations ( A , N ) { let cur_prefix_1 = 0 ; let parity = - 1 ; let minOperationsCase1 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { cur_prefix_1 += A [ i ] ; if ( cur_prefix_1 == 0 parity * cur_prefix_1 < 0 ) { minOperationsCase1 += Math . abs ( parity - cur_prefix_1 ) ; cur_prefix_1 = parity ; } parity *= - 1 ; } let cur_prefix_2 = 0 ; parity = 1 ; let minOperationsCase2 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { cur_prefix_2 += A [ i ] ; if ( cur_prefix_2 == 0 parity * cur_prefix_2 < 0 ) { minOperationsCase2 += Math . abs ( parity - cur_prefix_2 ) ; cur_prefix_2 = parity ; } parity *= - 1 ; } return Math . min ( minOperationsCase1 , minOperationsCase2 ) ; }
function maximumSumArray ( arr , N ) { let arrA = new Array ( N ) ; let ans = new Array ( N ) ; let maxSum = 0 ; for ( let i = 0 ; i < N ; i ++ ) arrA [ i ] = arr [ i ] ; for ( let i = 0 ; i < N ; i ++ ) { let arrB = new Array ( N ) ; let maximum = arrA [ i ] ; arrB [ i ] = maximum ; for ( let j = i - 1 ; j >= 0 ; j -- ) { arrB [ j ] = Math . min ( maximum , arrA [ j ] ) ; maximum = arrB [ j ] ; } maximum = arrA [ i ] ; for ( let j = i + 1 ; j < N ; j ++ ) { arrB [ j ] = Math . min ( maximum , arrA [ j ] ) ; maximum = arrB [ j ] ; } let sum = 0 ; for ( let j = 0 ; j < N ; j ++ ) sum += arrB [ j ] ; if ( sum > maxSum ) { maxSum = sum ; ans = arrB ; } } for ( let val of ans ) { document . write ( val + "▁" ) ; } }
function minProductUtil ( R1 , B1 , R2 , B2 , M ) { let x = Math . min ( R1 - B1 , M ) ; M -= x ; R1 -= x ; if ( M > 0 ) { let y = Math . min ( R2 - B2 , M ) ; M -= y ; R2 -= y ; } return R1 * R2 ; }
function minProduct ( R1 , B1 , R2 , B2 , M ) { let res1 = minProductUtil ( R1 , B1 , R2 , B2 , M ) ; let res2 = minProductUtil ( R2 , B2 , R1 , B1 , M ) ; return Math . min ( res1 , res2 ) ; }
function maxAmount ( n , k , arr ) { let A = new Array ( 1000001 ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { A [ arr [ i ] ] ++ ; } let j = 0 ; for ( let i = 0 ; i < 1000001 ; i ++ ) { while ( A [ i ] != 0 ) { arr [ j ++ ] = i ; A [ i ] -- ; } } let ans = 0 ; let mod = 1e9 + 7 ; let i = n - 1 ; j = n - 2 ; while ( k > 0 && j >= 0 ) { if ( arr [ i ] > arr [ j ] ) { ans = ans + Math . min ( k , ( i - j ) ) * arr [ i ] ; k = k - ( i - j ) ; arr [ i ] -- ; } else { while ( j >= 0 && arr [ j ] == arr [ i ] ) j -- ; if ( j < 0 ) break ; ans = ans + Math . min ( k , ( i - j ) ) * arr [ i ] ; k = k - ( i - j ) ; arr [ i ] -- ; } } while ( k > 0 && arr [ i ] != 0 ) { ans = ans + Math . min ( n , k ) * arr [ i ] ; k -= n ; arr [ i ] -- ; } ans = ans % mod ; let x = ans ; return x ; }
function validPermutations ( str ) { let m = new Map ( ) ; let count = str . length , ans = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( m . has ( str [ i ] ) ) { m . set ( str [ i ] , m . get ( str [ i ] ) + 1 ) ; } else { m . set ( str [ i ] , 1 ) ; } } for ( let i = 0 ; i < str . length ; i ++ ) { ans += count - m . get ( str [ i ] ) ; m . set ( str [ i ] , m . get ( str [ i ] ) - 1 ) ; count -- ; } return ans + 1 ; }
function maxAverage ( A , N , X , Y ) { A . sort ( function ( a , b ) { return a - b ; } )  let sum = 0 ; let res = 0 ; let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; count ++ ; if ( count == X ) { if ( N - i - 1 < X ) { i ++ ; let cnt = 0 ; while ( i < N ) { cnt ++ ; sum += A [ i ] ; i ++ ; } X = X + cnt ; res += sum / X ; break ; } res += sum / X ; sum = 0 ; count = 0 ; } } document . write ( res . toPrecision ( 3 ) ) }
function maxSum ( arr ) { let m = arr . length ; let n = arr [ 0 ] . length - 1 ; let dp = new Array ( m + 1 ) . fill ( 0 ) . map ( ( ) => new Array ( n + 1 ) . fill ( 0 ) ) ; for ( let i = 1 ; i < m ; ++ i ) dp [ i ] [ 1 ] = arr [ i ] [ 1 ] ; for ( let i = 1 ; i < n + 1 ; ++ i ) { for ( let j = 1 ; j < m ; ++ j ) { let mx = 0 ; for ( let k = 1 ; k < m ; ++ k ) { if ( k != j ) { if ( dp [ k ] [ i - 1 ] > mx ) { mx = dp [ k ] [ i - 1 ] ; } } } if ( mx && arr [ j ] [ i ] ) { dp [ j ] [ i ] = arr [ j ] [ i ] + mx ; } } } let ans = - 1 ; for ( let i = 1 ; i <= m ; ++ i ) { if ( dp [ i ] [ n ] ) { ans = Math . max ( ans , dp [ i ] [ n ] ) } ; } return ans ; }
function findMaximumPoints ( N , X , H ) { let ans = 0 ; let prev = Number . MIN_VALUE ; for ( let i = 0 ; i < N ; ++ i ) { if ( prev < ( X [ i ] - H [ i ] ) ) { ++ ans ; prev = X [ i ] ; } else if ( i == N - 1 || ( X [ i ] + H [ i ] ) < X [ i + 1 ] ) { ++ ans ; prev = X [ i ] + H [ i ] ; } else { prev = X [ i ] ; } } ans ++ ; return ans ; }
function maxGcd ( a , b ) { document . write ( Math . abs ( a - b ) ) ; }
function sumOfCombinationOf4OR5 ( arr , N ) { let ans = new Array ( N ) . fill ( - 1 ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 4 ) { continue ; } let sum = Number . MAX_SAFE_INTEGER , cnt = 0 ; for ( let j = 0 ; j <= arr [ i ] ; j += 4 ) { if ( ( arr [ i ] - j ) % 5 == 0 ) { sum = Math . min ( sum , cnt + Math . floor ( ( arr [ i ] - j ) / 5 ) ) ; } cnt ++ ; } if ( sum != Number . MAX_SAFE_INTEGER ) ans [ i ] = sum ; } for ( let num of ans ) document . write ( num + "▁" ) ; }
function power ( n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
function printBinaryString ( arr , N ) { for ( let i = 1 ; i <= N ; i ++ ) { if ( i % 2 ) { document . write ( 0 ) ; } else { document . write ( 1 ) ; } } }
function MinCost ( days , cost , N ) { let size = days [ N - 1 ] + 1 ; let dp = new Array ( size ) ; dp [ size - 1 ] = Math . min ( cost [ 0 ] , Math . min ( cost [ 1 ] , cost [ 2 ] ) ) ; let ptr = N - 2 ; for ( let i = size - 2 ; i > 0 ; i -- ) { if ( ptr >= 0 && days [ ptr ] == i ) { let val1 = dp [ i + 1 ] + cost [ 0 ] ; let val2 = cost [ 1 ] + ( ( i + 7 >= size ) ? 0 : dp [ i + 7 ] ) ; let val3 = cost [ 2 ] + ( ( i + 30 >= size ) ? 0 : dp [ i + 30 ] ) ; dp [ i ] = Math . min ( val1 , Math . min ( val2 , val3 ) ) ; ptr -- ; } else { dp [ i ] = dp [ i + 1 ] ; } } return dp [ 1 ] ; }
function minElements ( arr , N , K ) { let count = 0 ; let requiredNum = 1 ; let i = 0 ; while ( requiredNum <= K ) { if ( i < N && requiredNum >= arr [ i ] ) { requiredNum += arr [ i ] ; i ++ ; } else { count ++ ; requiredNum += requiredNum ; } } return count ; }
function minimumSteps ( a , b ) { let cnt = 0 ; a = Math . abs ( a - b ) ; cnt = Math . floor ( a / 5 ) + Math . floor ( ( a % 5 ) / 2 ) + ( a % 5 ) % 2 ; return cnt ; }
function maximumCount ( arr , N ) { let odd = 0 ; let even = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 ) odd ++ ; else even ++ ; } if ( odd && even ) return N - 2 ; else return N - 1 ; }
function miniOperToMakeAllEleEqual ( arr , n , k ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % n ) { document . write ( - 1 ) ; return ; } let valueAfterDivision = sum / n ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( Math . abs ( valueAfterDivision - arr [ i ] ) % k != 0 ) { document . write ( - 1 ) ; return ; } count += Math . abs ( valueAfterDivision - arr [ i ] ) / k ; } document . write ( Math . floor ( count / 2 ) ) ; }
function countOpenDoors ( N ) { let doorsOpen = parseInt ( Math . sqrt ( N ) ) ; return doorsOpen ; }
function minPossibleValue ( N , K , X ) { for ( let i = 1 ; i <= N ; i ++ ) { if ( X <= K ) { X = X * 2 ; } else { X = X + K ; } } return X ; }
function findMissingValue ( arr , N ) { let minE = Number . MAX_VALUE , maxE = Number . MIN_VALUE ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == - 1 && arr [ i + 1 ] != - 1 ) { minE = Math . min ( minE , arr [ i + 1 ] ) ; maxE = Math . max ( maxE , arr [ i + 1 ] ) ; } if ( arr [ i ] != - 1 && arr [ i + 1 ] == - 1 ) { minE = Math . min ( minE , arr [ i ] ) ; maxE = Math . max ( maxE , arr [ i ] ) ; } } if ( minE == Number . MAX_VALUE && maxE == Number . MIN_VALUE ) { document . write ( "0" ) ; } else { document . write ( ( minE + maxE ) / 2 ) ; } }
function findLastElement ( N , A ) { let l = A . length ; let j = 0 ; while ( N > l * ( Math . pow ( 2 , j ) ) ) { N = N - l * Math . pow ( 2 , j ) ; j += 1 ; } let k = 1 ; let r = Math . pow ( 2 , j ) ; for ( let i = 1 ; i < l ; i ++ ) { if ( N > r * i ) k += 1 ; } for ( let i = 0 ; i < l ; i ++ ) { if ( i + 1 == k ) { document . write ( A [ i ] ) ; return ; } } }
function findMaxD ( arr , N , K ) { for ( let i = 0 ; i < N ; i ++ ) { arr [ i ] = Math . abs ( arr [ i ] - K ) ; } let D = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { D = gcd ( D , arr [ i ] ) ; } return D ; }
function minOperations ( a ) { let res = Number . MAX_VALUE ; let N = a . length ; for ( let r = 0 ; r < 2 ; r ++ ) { let sum = 0 , ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( ( i + r ) % 2 ) { if ( sum <= 0 ) { ans += - sum + 1 ; sum = 1 ; } } else { if ( sum >= 0 ) { ans += sum + 1 ; sum = - 1 ; } } } res = Math . min ( res , ans ) ; } document . write ( res ) ; }
function maxOperations ( S , N ) { let X = 0 ; let Y = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( S [ i ] == "0" ) break ; Y ++ ; } for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == "1" ) break ; X ++ ; } if ( N == X + Y ) return 0 ; return N - ( X + Y ) - 1 ; }
function maximumSum ( S , N , K ) { let sum = 0 ; let freq = Array . from ( { length : 256 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { freq [ S [ i ] . charCodeAt ( ) ] ++ ; } freq . sort ( ( a , b ) => b - a ) ; for ( let i = 0 ; i < 256 ; i ++ ) { if ( K > freq [ i ] ) { sum += freq [ i ] * freq [ i ] ; K -= freq [ i ] ; } else { sum += freq [ i ] * K ; break ; } } return sum ; }
function possibleNumbers ( numbers , N , M , A , B ) { if ( M == 0 ) { numbers . add ( N ) ; return ; } possibleNumbers ( numbers , N + A , M - 1 , A , B ) ; possibleNumbers ( numbers , N + B , M - 1 , A , B ) ; }
function possibleNumbers ( N , M , A , B ) { var i ; if ( A > B ) { var temp = A ; A = B ; B = temp ; } var number = N + M * A ; document . write ( number + "▁" ) ; if ( A != B ) { for ( i = 0 ; i < M ; i ++ ) { number = number - A + B ; document . write ( number + "▁" ) ; } } }
function maxSum ( arr , n ) { let sum = 0 ; let max_neg = Number . MAX_SAFE_INTEGER ; let tempsum = 0 ; let small = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; small = Math . min ( small , arr [ i ] ) ; if ( arr [ i ] > 0 ) { tempsum = 0 ; } else { tempsum += arr [ i ] ; } max_neg = Math . min ( max_neg , tempsum ) ; } if ( max_neg == 0 ) { max_neg = small ; } document . write ( sum - max_neg ) ; }
function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
function findVertices ( n ) { return fib ( n + 2 ) ; }
function MaxBuildingsCovered ( arr , N , L ) { var curr_sum = 0 ; var start = 0 , curr_count = 0 , max_count = 0 ; for ( var i = 0 ; i < N ; i ++ ) { curr_sum = curr_sum + parseFloat ( arr [ i ] ) * Pi ; if ( i != 0 ) curr_sum += 1 ; if ( curr_sum <= L ) { curr_count ++ ; } else if ( curr_sum > L ) { curr_sum = curr_sum - parseFloat ( arr [ start ] ) * Pi ; curr_sum -= 1 ; start ++ ; curr_count -- ; } max_count = Math . max ( curr_count , max_count ) ; } return max_count ; }
function num_candyTypes ( candies ) { let s = new Set ( ) ; for ( let i = 0 ; i < candies . length ; i ++ ) { s . add ( candies [ i ] ) ; } return s . size ; }
function distribute_candies ( candies ) { let allowed = candies . length / 2 ; let types = num_candyTypes ( candies ) ; if ( types < allowed ) document . write ( types ) ; else document . write ( allowed ) ; }
function countUnsetBits ( N ) { let c = 0 ; while ( N != 0 ) { if ( N % 2 == 0 ) { c += 1 ; } N = N >> 1 ; } return c ; }
function countBitwiseZero ( N ) { let unsetBits = countUnsetBits ( N ) ; document . write ( 1 << unsetBits ) ; }
function isPossible ( s ) { let n = s . length ; let count_0 = 0 , count_1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == "0" ) ++ count_0 ; else ++ count_1 ; if ( count_1 > count_0 ) return false ; } if ( count_0 != ( 2 * count_1 ) ) return false ; count_0 = 0 ; count_1 = 0 ; for ( let i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == "0" ) ++ count_0 ; else ++ count_1 ; if ( count_1 > count_0 ) return false ; } return true ; }
function minimumOperation ( a , b ) { var n = a . length ; var i = 0 ; var minoperation = 0 ; while ( i < n ) { if ( a [ i ] == b [ i ] ) { i = i + 1 ; continue ; } else if ( a [ i ] == b [ i + 1 ] && a [ i + 1 ] == b [ i ] && i < n - 1 ) { minoperation ++ ; i = i + 2 ; } else if ( a [ i ] != b [ i ] ) { minoperation ++ ; i = i + 1 ; } else { ++ i ; } } document . write ( minoperation ) ; }
function leastBricks ( wall ) { let map = new Map ( ) ; let res = 0 ; for ( let list of wall ) { let width = 0 ; for ( let i = 0 ; i < list . length - 1 ; i ++ ) { width += list [ i ] ; if ( map . has ( width ) ) { map . set ( width , map . get ( width ) + 1 ) ; } else { map . set ( width , 1 ) } res = Math . max ( res , map . get ( width ) ) ; } } document . write ( wall . length - res ) ; }
function minimumProdArray ( a , b , l ) { let total = 0 ; for ( let i = 0 ; i < a . length ; ++ i ) { total += a [ i ] * b [ i ] ; } let min = Number . MAX_SAFE_INTEGER ; let first = 0 ; let second = 0 ; for ( let i = 0 ; i < a . length ; ++ i ) { let left = i - 1 ; let right = i + 1 ; let total1 = total ; while ( left >= 0 && right < a . length ) { total1 -= a [ left ] * b [ left ] + a [ right ] * b [ right ] ; total1 += a [ left ] * b [ right ] + a [ right ] * b [ left ] ; if ( min >= total1 ) { min = total1 ; first = left ; second = right ; } -- left ; ++ right ; } } for ( let i = 0 ; i < a . length ; ++ i ) { let left = i ; let right = i + 1 ; let total1 = total ; while ( left >= 0 && right < a . length ) { total1 -= a [ left ] * b [ left ] + a [ right ] * b [ right ] ; total1 += a [ left ] * b [ right ] + a [ right ] * b [ left ] ; if ( min >= total1 ) { min = total1 ; first = left ; second = right ; } -- left ; ++ right ; } } if ( min < total ) { reverse1 ( first , second , a ) ; print1 ( a , b ) ; } else { print1 ( a , b ) ; } }
function numberOfWays ( N , X , Y ) { let S1 = ( N - 1 ) * X + Y ; let S2 = ( N - 1 ) * Y + X ; return ( S2 - S1 + 1 ) ; }
function countPermutations ( N ) { let adj = [ ] ; for ( let i = 0 ; i < 105 ; i ++ ) adj . push ( [ ] ) ; let indeg = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 1 ; j <= N ; j ++ ) { if ( i == j ) continue ; let sum = i + j ; if ( Math . ceil ( Math . sqrt ( sum ) ) == Math . floor ( Math . sqrt ( sum ) ) ) { adj [ i ] . push ( j ) ; } } if ( adj [ i ] . length == 1 ) indeg ++ ; } if ( indeg == 0 ) return N ; else if ( indeg <= 2 ) return 2 ; else return 0 ; }
function reduceToOne ( N ) { let cnt = 0 ; while ( N != 1 ) { if ( N == 2 || ( N % 2 == 1 ) ) { N = N - 1 ; cnt ++ ; } else if ( N % 2 == 0 ) { N = Math . floor ( N / Math . floor ( N / 2 ) ) ; cnt ++ ; } } return cnt ; }
function getDate ( d , m ) { let days = [ 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ; let month = [ "January" , "February" , "March" , "April" , "May" , "June" , "July" , "August" , "September" , "October" , "November" , "December" ] ; let cnt = 183 ; let cur_month = 0 ; for ( let i = 0 ; i < 12 ; i ++ ) if ( m == month [ i ] ) cur_month = i ; let cur_date = d ; while ( true ) { while ( cnt > 0 && cur_date <= days [ cur_month ] ) { cnt -= 1 ; cur_date += 1 ; } if ( cnt == 0 ) break ; cur_month = ( cur_month + 1 ) % 12 ; cur_date = 1 ; } document . write ( cur_date + "▁" + month [ cur_month ] ) ; }
function maxDiamonds ( A , N , K ) { let pq = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { pq . push ( A [ i ] ) ; } let ans = 0 ; pq . sort ( ( a , b ) => a - b )  while ( pq . length && K -- ) { pq . sort ( ( a , b ) => a - b )  let top = pq [ pq . length - 1 ] ; pq . pop ( ) ; ans += top ; top = Math . floor ( top / 2 ) ; pq . push ( top ) ; } document . write ( ans ) ; }
function findMaximumProfit ( arr , M , N ) { let max_heap = [ ] ; let maxProfit = 0 ; for ( let i = 0 ; i < N ; i ++ ) max_heap . push ( arr [ i ] ) ; max_heap . sort ( function ( a , b ) { return a - b } ) ; max_heap . reverse ( ) ; while ( M > 0 ) { M -- ; let X = max_heap [ 0 ] ; max_heap . shift ( ) ; maxProfit += X ; max_heap . push ( X - 1 ) ; max_heap . sort ( function ( a , b ) { return a - b } ) ; max_heap . reverse ( ) ; } document . write ( maxProfit ) ; }
function largestNumber ( N ) { if ( N > 45 ) return - 1 ; let num = 0 , digit = 9 ; while ( N > 0 && digit > 0 ) { if ( digit <= N ) { num *= 10 ; num += digit ; N -= digit ; } digit -= 1 ; } return num * 10 ; }
function minimumSum ( A , N , S ) { let mul = 0 ; for ( let i = 0 ; i < S . length ; i ++ ) { if ( S [ i ] == "*" ) mul += 1 ; } let ans = 1000000 ; for ( let i = 0 ; i < 1 << ( N - 1 ) ; i ++ ) { let cnt = 0 ; let v = [ ] ; for ( let j = 0 ; j < N - 1 ; j ++ ) { if ( ( 1 << j ) & i ) { cnt += 1 ; v . push ( "*" ) ; } else { v . push ( "+" ) ; } } if ( cnt == mul ) { let d = [ ] ; d . push ( A [ 0 ] ) ; for ( let j = 0 ; j < N - 1 ; j ++ ) { if ( v [ j ] == "*" ) { let x = d [ d . length - 1 ] ; d . pop ( ) ; x = x * A [ j + 1 ] ; d . push ( x ) ; } else { d . push ( A [ j + 1 ] ) ; } } let sum = 0 ; while ( d . length > 0 ) { let x = d [ 0 ] ; sum += x ; d . shift ( ) ; } ans = Math . min ( ans , sum ) ; } } return ans ; }
function MinimumOperations ( A , N , K ) { let Count = 0 ; let i = 0 ; while ( i < N - 1 ) { i = i + K - 1 ; Count ++ ; } return Count ; }
function findSequence ( n , k ) { let arr = new Array ( n ) ; let sumPos = 0 , sumNeg = 0 ; for ( let i = 0 ; i < n - k ; i ++ ) { arr [ i ] = - ( i + 1 ) ; sumNeg += arr [ i ] ; } for ( let i = n - k ; i < n ; i ++ ) { arr [ i ] = i + 1 ; sumPos += arr [ i ] ; } if ( Math . abs ( sumNeg ) >= sumPos ) { document . write ( - 1 ) ; return ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function sumOfMedians ( arr , N , K ) { let selectMedian = Math . floor ( ( K + 1 ) / 2 ) ; let totalArrays = Math . floor ( N / K ) ; let minSum = 0 ; let i = selectMedian - 1 ; while ( i < N && totalArrays != 0 ) { minSum = minSum + arr [ i ] ; i = i + selectMedian ; totalArrays -- ; } document . write ( minSum ) ; }
function generateString ( K ) { var s = "" ; for ( var i = 97 ; i < 97 + K ; i ++ ) { s = s + String . fromCharCode ( i ) ; for ( var j = i + 1 ; j < 97 + K ; j ++ ) { s += String . fromCharCode ( i ) ; s += String . fromCharCode ( j ) ; } } s += String . fromCharCode ( 97 ) ; document . write ( s ) ; }
function countEqual ( A , B , N ) { let first = 0 ; let second = N - 1 ; let count = 0 ; while ( first < N && second >= 0 ) { if ( A [ first ] < B [ second ] ) { first ++ ; } else if ( B [ second ] < A [ first ] ) { second -- ; } else { count ++ ; first ++ ; second -- ; } } return count ; }
function minimumValue ( N , K ) { return Math . ceil ( K / N ) ; }
function minSizeArr ( A , N , K ) { var sum = 0 ; var i ; for ( i = 0 ; i < N ; i ++ ) sum += A [ i ] ; if ( K > sum ) { cout << - 1 ; return ; } if ( K == sum ) { for ( i = 0 ; i < N ; i ++ ) { document . write ( A [ i ] + "▁" ) ; } return ; } var tar = sum - K ; var um = new Map ( ) ; um [ 0 ] = - 1 ; var left , right ; var cur = 0 , maxi = - 1 ; for ( i = 0 ; i < N ; i ++ ) { cur += A [ i ] ; if ( um . has ( cur - tar ) && i - um . get ( cur - tar ) > maxi ) { maxi = i - um . get ( cur - tar ) ; right = i ; left = um . get ( cur - tar ) ; } if ( ! um . has ( cur ) ) um . set ( cur , i ) ; } if ( maxi == - 1 ) cout << - 1 ; else { for ( i = 0 ; i <= left ; i ++ ) document . write ( A [ i ] + "▁" ) ; for ( i = 0 ; i < right ; i ++ ) document . write ( A [ N - i - 1 ] + "▁" ) ; } }
function findPath ( arr , M , N ) { for ( let row = 0 ; row < M ; row ++ ) { let dir = "L" ; let i = row ; let j = 0 ; while ( j < N ) { if ( arr [ i ] [ j ] == 1 ) { if ( dir == "L" ) { i -- ; dir = "D" ; } else if ( dir == "U" ) { j -- ; dir = "R" ; } else if ( dir == "R" ) { i ++ ; dir = "U" ; } else if ( dir == "D" ) { j ++ ; dir = "L" ; } } else { if ( dir == "L" ) { i ++ ; dir = "U" ; } else if ( dir == "U" ) { j ++ ; dir = "L" ; } else if ( dir == "R" ) { i -- ; dir = "D" ; } else if ( dir == "D" ) { j -- ; dir = "R" ; } } if ( i < 0 i == M j < 0 j == N ) break ; } if ( j == N ) document . write ( i + "▁" ) ; else document . write ( - 1 + "▁" ) ; } }
function getSum ( n ) { let ans = 0 ; let arr = n . toString ( ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { ans += arr [ i ] ; } return ans ; }
function minModulo ( L , R , N ) { if ( R - L < N ) { let ans = Number . MAX_VALUE ; for ( let i = L ; i <= R ; i ++ ) for ( let j = L ; j <= R ; j ++ ) if ( i != j ) ans = Math . min ( ans , ( i * j ) % N ) ; document . write ( ans ) ; } else { document . write ( 0 ) ; } }
function countNumbers ( N ) { var count = 0 ; for ( i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { count ++ ; if ( parseInt ( N / i ) != i ) { count ++ ; } } } return count ; }
function findEquation ( A , B , C , K ) { document . write ( A + "▁" + K * B + "▁" + K * K * C ) ; }
function calc ( a , b ) { return ( a * b ) + ( b - a ) ; }
function findMaximum ( arr , N ) { arr . sort ( function ( a , b ) { return a - b } )  let ans = Number . MIN_VALUE ; ans = Math . max ( ans , calc ( arr [ 0 ] , arr [ 1 ] ) ) ; ans = Math . max ( ans , calc ( arr [ N - 2 ] , arr [ N - 1 ] ) ) ; return ans ; }
function findMin ( arr , N , k ) { let pairs = 0 ; for ( let i = 0 ; i < N ; i ++ ) { pairs += arr [ i ] / 2 ; } if ( k > pairs ) return - 1 ; else return 2 * k + N - 1 ; }
function minOperations ( arr , n ) { var oddcount = 0 , evencount = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) oddcount ++ ; else evencount ++ ; } return Math . min ( oddcount , evencount ) ; }
function minimumFlips ( A , B , C ) { var res = 0 ; for ( i = 0 ; i < 32 ; i ++ ) { var x = 0 , y = 0 , z = 0 ; if ( ( A & ( 1 << i ) ) != 0 ) { x = 1 ; } if ( ( B & ( 1 << i ) ) != 0 ) { y = 1 ; } if ( ( C & ( 1 << i ) ) != 0 ) { z = 1 ; } if ( z == 0 ) { if ( x == 1 ) { res ++ ; } if ( y == 1 ) { res ++ ; } } if ( z == 1 ) { if ( x == 0 && y == 0 ) { res ++ ; } } } return res ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function countDistinctNumbers ( A , B , C ) { var g = gcd ( A , B ) ; var count = C / g ; document . write ( count ) ; }
function printLastElement ( arr , N ) { var leftTurn = true ; var remainElements = N ; var step = 1 ; var head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } document . write ( arr [ head - 1 ] ) ; }
function findPrefixCount ( arr , size ) { for ( let i = 0 ; i < 32 ; i ++ ) { prefixCount [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( let j = 1 ; j < size ; j ++ ) { prefixCount [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefixCount [ i ] [ j ] += prefixCount [ i ] [ j - 1 ] ; } } }
function applyQuery ( currentVal , newVal , size ) { for ( let i = 0 ; i < 32 ; i ++ ) { let bit1 = ( ( currentVal >> i ) & 1 ) ; let bit2 = ( ( newVal >> i ) & 1 ) ; if ( bit2 > 0 && bit1 == 0 ) prefixCount [ i ] [ size - 1 ] ++ ; else if ( bit1 > 0 && bit2 == 0 ) prefixCount [ i ] [ size - 1 ] -- ; } }
function shortestSubarray ( A , N ) { let i ; let left_index ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] + 1 != A [ i + 1 ] ) break ; } left_index = i ; let right_index ; for ( i = N - 1 ; i >= 1 ; i -- ) { if ( A [ i ] != A [ i - 1 ] + 1 ) break ; } right_index = i ; let updated_right ; let minLength = Math . min ( N - left_index - 1 , right_index ) ; if ( A [ right_index ] <= A [ left_index ] + 1 ) { updated_right = right_index + A [ left_index ] - A [ right_index ] + 1 ; if ( updated_right < N ) minLength = Math . min ( minLength , updated_right - left_index - 1 ) ; } document . write ( minLength ) ; }
function freqCheck ( S , N ) { let hash = new Array ( 26 ) . fill ( 0 )  for ( let i = 0 ; i < N ; i ++ ) { hash [ S . charCodeAt ( i ) - "a" . charCodeAt ( 0 ) ] += 1 } for ( let i = 0 ; i < 26 ; i ++ ) { if ( hash [ i ] > 2 ) { return "Yes" } } return "No" }
function countTriplets ( N , K ) { if ( K % 2 == 0 ) { var x = parseInt ( N / K ) ; var y = parseInt ( ( N + ( K / 2 ) ) / K ) ; return x * x * x + y * y * y ; } else { var x = parseInt ( N / K ) ; return x * x * x ; } }
function minLength ( s ) { i = 0 ; j = s . length - 1  while ( i < j && s [ i ] == s [ j ] ) { d = s [ i ]  while ( i <= j && s [ i ] == d ) i += 1  while ( i <= j && s [ j ] == d ) j -= 1 } return j - i + 1 }
function power ( x , y ) { var res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
function CountBST ( H ) { return power ( 2 , H ) ; }
function canBeEmptied ( A , B ) { if ( Math . max ( A , B ) > 2 * Math . min ( A , B ) ) { document . write ( "No" ) ; return ; } if ( ( A + B ) % 3 == 0 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function Check ( A , B , M , N , X ) { for ( var i = 0 ; i < M ; i ++ ) { for ( var j = 0 ; j <= N - X ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { var diff = B [ i ] [ j ] - A [ i ] [ j ] ; for ( var k = 0 ; k < X ; k ++ ) { A [ i ] [ j + k ] = A [ i ] [ j + k ] + diff ; } } } } for ( var i = 0 ; i <= M - X ; i ++ ) { for ( var j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { var diff = B [ i ] [ j ] - A [ i ] [ j ] ; for ( var k = 0 ; k < X ; k ++ ) { A [ i + k ] [ j ] = A [ i + k ] [ j ] + diff ; } } } } for ( var i = 0 ; i < M ; i ++ ) { for ( var j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { return 0 ; } } } return 1 ; }
function check ( X , Y ) { if ( X > 3 ) { document . write ( "Yes" ) ; } else if ( X == 1 && Y == 1 ) { document . write ( "Yes" ) ; } else if ( X == 2 && Y <= 3 ) { document . write ( "Yes" ) ; } else if ( X == 3 && Y <= 3 ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function isPrime ( n ) { if ( n <= 1 ) { return false ; } for ( let i = 2 ; i <= Math . floor ( n / 2 ) ; ++ i ) { if ( n % i == 0 ) return false ; } return true ; }
function precompute ( ) { for ( let i = 1 ; i <= 100000 ; i ++ ) { if ( isPalindrome ( i ) ) { let sum = sumOfDigits ( i ) ; if ( isPrime ( sum ) ) arr [ i ] = 1 ; else arr [ i ] = 0 ; } else arr [ i ] = 0 ; } for ( let i = 1 ; i <= 100000 ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; } }
function minimumOperations ( A , K ) { let isflipped = [ ] ; for ( let i = 0 ; i < A . length + 1 ; i ++ ) { isflipped [ i ] = 0 ; } let ans = 0 ; for ( let i = 0 ; i < A . length ; i ++ ) { if ( i > 0 ) { isflipped [ i ] += isflipped [ i - 1 ] ; isflipped [ i ] %= 2 ; } if ( A [ i ] == 0 && isflipped [ i ] == 0 ) { if ( ( A . length - i + 1 ) <= K ) { document . write ( - 1 ) ; return ; } ans ++ ; isflipped [ i ] ++ ; isflipped [ i + K ] -- ; } else if ( A [ i ] == 1 && isflipped [ i ] != 0 ) { if ( ( A . length - i + 1 ) <= K ) { document . write ( - 1 ) ; return ; } ans ++ ; isflipped [ i ] ++ ; isflipped [ i + K ] -- ; } } document . write ( ans ) ; }
function findScoreSum ( n ) { let total = 0 ; let prev_monday = 0 , curr_day = 0 ; for ( let day = 1 ; day <= n ; day ++ ) { if ( day % 7 == 1 ) { prev_monday ++ ; curr_day = prev_monday ; } total += curr_day ++ ; } document . write ( total ) ; }
function findScoreSum ( n ) { let F = n / 7 ; let D = n % 7 ; let fullWeekScore = ( 49 + 7 * F ) * F / 2 ; let lastNonFullWeekScore = ( 2 * F + D + 1 ) * D / 2 ; document . write ( Math . floor ( fullWeekScore + lastNonFullWeekScore ) ) ; }
function evenXorSubarray ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let XOR = 0 ; for ( let j = i ; j < n ; j ++ ) { XOR = XOR ^ arr [ j ] ; if ( ( XOR & 1 ) == 0 ) ans ++ ; } } document . write ( ans ) ; }
function evenXorSubarray ( arr , n ) { let ans = 0 ; let freq = [ 0 , 0 ] ; let XOR = 0 ; for ( let i = 0 ; i < n ; i ++ ) { XOR = XOR ^ arr [ i ] ; if ( XOR % 2 == 0 ) { ans += freq [ 0 ] + 1 ; freq [ 0 ] ++ ; } else { ans += freq [ 1 ] ; freq [ 1 ] ++ ; } } document . write ( ans ) ; }
function getArea ( x1 , y1 , x2 , y2 , x3 , y3 ) { return Math . abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2 ) ; }
function isInside ( triangle , point ) { let A = triangle [ 0 ] ; let B = triangle [ 1 ] ; let C = triangle [ 2 ] ; let x = point [ 0 ] ; let y = point [ 1 ] ; let ABC = getArea ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] , C [ 0 ] , C [ 1 ] ) ; let BPC = getArea ( x , y , B [ 0 ] , B [ 1 ] , C [ 0 ] , C [ 1 ] ) ; let APC = getArea ( A [ 0 ] , A [ 1 ] , x , y , C [ 0 ] , C [ 1 ] ) ; let APB = getArea ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] , x , y ) ; return ABC == ( APC + APB + BPC ) ? 1 : 0 ; }
function GCD ( a , b ) { if ( b < 1 ) return a ; return GCD ( b , a % b ) ; }
function GCDArr ( a ) { let ans = a [ 0 ] ; for ( let i = 0 ; i < a . length ; i ++ ) ans = GCD ( ans , a [ i ] ) ; return ans ; }
function findSubseqUtil ( a , b , ans , k , i ) { if ( ans . length == a . length ) { if ( GCDArr ( ans ) == k ) { document . write ( "[" ) ; let m = ans . length ; for ( let j = 0 ; j < m - 1 ; j ++ ) document . write ( ans [ j ] + ",▁" ) ; document . write ( ans [ m - 1 ] + "]" ) ; return true ; } else return false ; } ans . push ( a [ i ] ) ; let temp = findSubseqUtil ( a , b , ans , k , i + 1 ) ; if ( temp ) return true ; ans . splice ( ans . length - 1 , 1 ) ; ans . push ( b [ i ] ) ; temp = findSubseqUtil ( a , b , ans , k , i + 1 ) ; if ( temp ) return true ; ans . splice ( ans . length - 1 , 1 ) ; return false ; }
function GCD ( a , b ) { if ( b === 0 ) return a ; return GCD ( b , a % b ) ; }
function GCDArr ( a ) { var ans = a [ 0 ] ; for ( const val of a ) { ans = GCD ( ans , val ) ; } return ans ; }
function findString ( S , N ) { var strLen = 4 * N ; for ( var i = 1 ; i <= N ; i ++ ) { S [ strLen - 1 ] = "1" ; strLen -= 2 ; } for ( var i = 0 ; i < 4 * N ; i ++ ) { document . write ( S [ i ] ) ; } }
function minimumOperations ( A , n ) { var cnt = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( A [ i ] != ( i + 1 ) ) { if ( ( ( i - 1 ) >= 0 ) && A [ i - 1 ] == ( i + 1 ) ) { cnt ++ ; var t = A [ i ] ; A [ i ] = A [ i - 1 ] ; A [ i - 1 ] = t ; } else if ( ( ( i - 2 ) >= 0 ) && A [ i - 2 ] == ( i + 1 ) ) { cnt += 2 ; A [ i - 2 ] = A [ i - 1 ] ; A [ i - 1 ] = A [ i ] ; A [ i ] = i + 1 ; } else { document . write ( - 1 ) ; return ; } } } document . write ( cnt ) ; }
function countOccurrences ( n , x ) { var count = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { if ( x % i == 0 ) { if ( x / i <= n ) count ++ ; } } document . write ( count ) ; }
function countOccurrences ( N , X ) { var count = 0 ; for ( var i = 1 ; i < Math . sqrt ( X ) ; i ++ ) { if ( X % i == 0 ) { var a = i ; var b = X / i ; if ( a <= N && b <= N ) { if ( a == b ) count += 1 ; else count += 2 ; } } } return count ; }
function countOfPrimefactors ( CountDistinct ) { let MAX = 1000000 ; let prime = Array ( MAX + 1 ) ; for ( let i = 0 ; i <= MAX ; i ++ ) { CountDistinct [ i ] = 0 ; prime [ i ] = true ; } for ( let i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) { CountDistinct [ i ] = 1 ; for ( let j = i * 2 ; j <= MAX ; j += i ) { CountDistinct [ j ] ++ ; prime [ j ] = false ; } } } }
function CountEvenPair ( A , B , N , M ) { let MAX = 1000000 ; countOfPrimefactors ( countDistinct ) ; let evenCount = 0 ; let oddCount = 0 ; let evenPairs = 0 ; for ( let i = 0 ; i < M ; i ++ ) { if ( countDistinct [ B [ i ] ] == 0 ) continue ; if ( ( countDistinct [ B [ i ] ] & 1 ) != 0 ) { oddCount ++ ; } else { evenCount ++ ; } } for ( let i = 0 ; i < N ; i ++ ) { if ( countDistinct [ A [ i ] ] == 0 ) continue ; if ( ( countDistinct [ A [ i ] ] & 1 ) != 0 ) { evenPairs += ( evenCount ) ; } else { evenPairs += evenCount + oddCount ; } } return evenPairs ; }
function maxOccuringCharacter ( s ) { var count0 = 0 , count1 = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == "1" ) { count1 ++ ; } else if ( s . charAt ( i ) == "0" ) { count0 ++ ; } } var prev = - 1 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == "1" ) { prev = i ; break ; } } for ( var i = prev + 1 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) != "X" ) { if ( s . charAt ( i ) == "1" ) { count1 += i - prev - 1 ; prev = i ; } else { flag = true ; for ( var j = i + 1 ; j < s . length ; j ++ ) { if ( s . charAt ( j ) == "1" ) { flag = false ; prev = j ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ; } } } } prev = - 1 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == "0" ) { prev = i ; break ; } } for ( var i = prev + 1 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) != "X" ) { if ( s . charAt ( i ) == "0" ) { count0 += i - prev - 1 ; prev = i ; } else { flag = true ; for ( var j = i + 1 ; j < s . length ; j ++ ) { if ( s . charAt ( j ) == "0" ) { prev = j ; flag = false ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ; } } } } if ( s . charAt ( 0 ) == "X" ) { var count = 0 ; var i = 0 ; while ( s . charAt ( i ) == "X" ) { count ++ ; i ++ ; } if ( s . charAt ( i ) == "1" ) { count1 += count ; } } if ( s . charAt ( s . length - 1 ) == "X" ) { var count = 0 ; var i = s . length - 1 ; while ( s . charAt ( i ) == "X" ) { count ++ ; i -- ; } if ( s . charAt ( i ) == "0" ) { count0 += count ; } } if ( count0 == count1 ) { document . write ( "X" ) ; } else if ( count0 > count1 ) { document . write ( 0 ) ; } else document . write ( 1 ) ; }
function minRequiredOperation ( arr , N , K ) { let TotalSum = 0 ; for ( let i = 0 ; i < N ; i ++ ) TotalSum += arr [ i ] ; let maxLen = longestSubarray ( arr , N , TotalSum - K ) ; if ( maxLen == - 1 ) { document . write ( - 1 ) ; } else document . write ( N - maxLen ) ; }
function minimumDeletions ( s ) { let n = s . length ; let ans = n ; for ( let i = n - 1 ; i >= 0 ; i -- ) { let t = s [ i ] - "0" ; if ( t % 2 == 0 ) { for ( let j = i - 1 ; j >= 0 ; j -- ) { let num = ( s [ j ] - "0" ) * 10 + t ; if ( num % 4 === 0 ) { let k1 = i - j - 1 ; let k2 = n - i - 1 ; ans = Math . min ( ans , k1 + k2 ) ; } } } } if ( ans === n ) { for ( let i = 0 ; i < n ; i ++ ) { let num = s [ i ] - "0" ; if ( num % 4 === 0 ) { ans = n - 1 ; } } } document . write ( ans ) ; }
function isVowel ( ch ) { if ( ch === "a" ch === "e" ch === "i" ch === "o" ch === "u" ) return true ; if ( ch === "A" ch === "E" ch === "I" ch === "O" ch === "U" ) return true ; return false ; }
function winner ( arr , N ) { if ( N % 2 === 1 ) { document . write ( "A" ) ; } else { document . write ( "B" ) ; } }
function LCMPairs ( arr , N ) { var total_pairs = ( N * ( N - 1 ) ) / 2 ; var odd = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; } odd = ( odd * ( odd - 1 ) ) / 2 ; document . write ( "Even▁=▁" + ( total_pairs - odd ) + ",▁Odd▁=▁" + odd ) ; }
function getMaxSum ( A , M , N ) { let sum = 0 ; let negative = 0 ; let minVal = Number . MAX_VALUE ; for ( let i = 0 ; i < M ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { sum += Math . abs ( A [ i ] [ j ] ) ; if ( A [ i ] [ j ] < 0 ) { negative ++ ; } minVal = Math . min ( minVal , Math . abs ( A [ i ] [ j ] ) ) ; } } if ( negative % 2 != 0 ) { sum -= 2 * minVal ; } document . write ( sum ) ; }
function printNumber ( N , K , M ) { var sum = K * ( ( M * ( M + 1 ) ) / 2 ) ; return sum - N ; }
function countEvenOdd ( L , R ) { let range = R - L + 1 ; let even = parseInt ( range / 4 ) * 2 ; if ( ( L & 1 ) && ( range % 4 == 3 ) ) { even ++ ; } else if ( ! ( L & 1 ) && ( range % 4 ) ) { even ++ ; } document . write ( "Even▁=▁" + even + ",▁Odd▁=▁" + ( range - even ) ) ; }
function findPerfectIndex ( N , K ) { var i = 0 ; for ( ; i < K ; i ++ ) { document . write ( ( N - K + 1 ) + i + "▁" ) ; } for ( ; i < N ; i ++ ) { document . write ( i - K + 1 + "▁" ) ; } }
function isPrime ( N ) { if ( N <= 1 ) return false ; for ( let i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; }
function countPrimeTuples ( N ) { let count = 0 ; for ( let i = 2 ; i <= N ; i ++ ) { if ( isPrime ( i ) && isPrime ( i - 2 ) ) count ++ ; } document . write ( count ) ; }
function countPairs ( A , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) if ( ( A [ i ] A [ j ] ) > ( A [ i ] & A [ j ] ) ) { count ++ ; } } document . write ( count ) ; }
function checkArrays ( arr1 , arr2 , N ) { let count = 0 ; let flag = true ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { if ( arr1 [ i ] == 0 ) count ++ ; else { count -- ; if ( count < 0 ) { flag = false ; break ; } } } } if ( ( flag && ( count == 0 ) ) == true ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function construct_Array ( N , K ) { for ( let i = 1 ; i <= N ; i ++ ) { document . write ( K * i + "▁" ) ; } }
function maxSumOfDistinctPrimeFactors ( arr , N , K ) { let CountDistinct = [ ] ; for ( let i = 0 ; i <= MAX ; i ++ ) { CountDistinct [ i ] = 0 ; } let prime = [ ] ; for ( let i = 0 ; i <= MAX ; i ++ ) { prime [ i ] = 0 ; } for ( let i = 0 ; i <= MAX ; i ++ ) { CountDistinct [ i ] = 0 ; prime [ i ] = true ; } for ( let i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) { CountDistinct [ i ] = 1 ; for ( let j = i * 2 ; j <= MAX ; j += i ) { CountDistinct [ j ] ++ ; prime [ j ] = false ; } } } let sum = 0 ; let PrimeFactor = [ ] ; for ( let i = 0 ; i <= 20 ; i ++ ) { PrimeFactor [ i ] = 0 ; } for ( let i = 0 ; i < N ; i ++ ) { PrimeFactor [ CountDistinct [ arr [ i ] ] ] ++ ; } for ( let i = 19 ; i >= 1 ; i -- ) { while ( PrimeFactor [ i ] > 0 ) { sum += i ; PrimeFactor [ i ] -- ; K -- ; if ( K == 0 ) break ; } if ( K == 0 ) break ; } document . write ( sum ) ; }
function Print ( N ) { if ( ( N / 2 ) % 2 == 1 || ( N % 2 == 1 ) ) { document . write ( - 1 ) ; return ; } var CurEven = 2 , CurOdd = 1 ; var SumOdd = 0 , SumEven = 0 ; for ( var i = 0 ; i < ( N / 2 ) ; i ++ ) { document . write ( CurEven + "▁" ) ; SumEven += CurEven ; CurEven += 2 ; } for ( var i = 0 ; i < N / 2 - 1 ; i ++ ) { document . write ( CurOdd + "▁" ) ; SumOdd += CurOdd ; CurOdd += 2 ; } CurOdd = SumEven - SumOdd ; document . write ( CurOdd ) ; }
function minimize ( n ) { let optEle = n ; let strEle = ( n ) . toString ( ) ; for ( let idx = 0 ; idx < strEle . length ; idx ++ ) { let temp = parseInt ( strEle . substring ( idx ) + strEle . substring ( 0 , idx ) ) ; optEle = Math . min ( optEle , temp ) ; } return optEle ; }
function maximize ( n ) { let optEle = n ; let strEle = n . toString ( ) ; for ( let idx = 0 ; idx < strEle . length ; idx ++ ) { let temp = parseInt ( strEle . substring ( idx ) + strEle . substring ( 0 , idx ) ) ; optEle = Math . max ( optEle , temp ) ; } return optEle ; }
function minOperations ( arr , N ) { var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { var res = arr [ i ] ; while ( res ) { if ( mp . has ( res ) ) { mp . set ( res , mp . get ( res ) + 1 ) ; } else { mp . set ( res , 1 ) ; } res = parseInt ( res / 2 ) ; } } var mx = 1 ; mp . forEach ( ( value , key ) => { if ( value == N ) { mx = key ; } } ) ; var ans = 0 ; for ( var i = 0 ; i < N ; i ++ ) { var res = arr [ i ] ; while ( res != mx ) { ans ++ ; res = parseInt ( res / 2 ) ; } } document . write ( ans ) ; }
function MinimumMoves ( A , B , N ) { let totalOperations = 0 ; let carry = 0 ; let K = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { let nearestMultiple = ( Math . ceil ( ( A [ i ] + carry ) / ( B [ i ] ) ) * B [ i ] ) ; K = nearestMultiple - ( A [ i ] + carry ) ; totalOperations += K ; carry += K ; } return totalOperations ; }
function maxSheets ( A , B ) { let area = A * B ; let count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; }
function minimumDeviation ( A , N ) { var s = new Set ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) s . add ( A [ i ] ) ; else s . add ( 2 * A [ i ] ) ; } var tmp = [ ... s ] . sort ( ( a , b ) => a - b ) ; var diff = tmp [ tmp . length - 1 ] - tmp [ 0 ] ; while ( s . size && tmp [ tmp . length - 1 ] % 2 == 0 ) { var maxEl = tmp [ tmp . length - 1 ] ; s . delete ( maxEl ) ; s . add ( parseInt ( maxEl / 2 ) ) ; tmp = [ ... s ] . sort ( ( a , b ) => a - b ) ; diff = Math . min ( diff , tmp [ tmp . length - 1 ] - tmp [ 0 ] ) ; } document . write ( diff ) ; }
function findMaxNum ( num ) { var binaryNumber = Number ( num ) . toString ( 2 ) ; ; var maxBinaryNumber = "" ; var count0 = 0 , count1 = 0 ; var N = binaryNumber . length ; for ( i = 0 ; i < N ; i ++ ) { if ( binaryNumber . charAt ( i ) == "1" ) { count1 ++ ; } else { count0 ++ ; } } for ( i = 0 ; i < count1 ; i ++ ) { maxBinaryNumber += "1" ; } for ( i = 0 ; i < count0 ; i ++ ) { maxBinaryNumber += "0" ; } return parseInt ( maxBinaryNumber , 2 ) ; }
function findMinMoves ( a , b ) { let ans = 0 ; if ( a == b || Math . abs ( a - b ) == 1 ) { ans = a + b ; } else { let k = Math . min ( a , b ) ; let j = Math . max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } document . write ( ans ) ; }
function FindwinnerOfGame ( S ) { let cntZero = 0 ; let cntConOne = 0 ; let nimSum = 0 ; let N = S . length ; for ( let i = 0 ; i < N ; i ++ ) { if ( S [ i ] == "1" ) { cntConOne += 1 ; } else { nimSum ^= cntConOne ; cntConOne = 0 ; cntZero ++ ; } } nimSum ^= cntConOne ; if ( cntZero % 2 == 0 ) { document . write ( "Tie" ) ; } else if ( nimSum != 0 ) { document . write ( "player▁1" ) ; } else { document . write ( "player▁2" ) ; } }
function check ( current_row , current_col , destination_row , destination_col ) { if ( current_row == destination_row ) return "POSSIBLE" ; else if ( current_col == destination_col ) return "POSSIBLE" ; else return "NOT▁POSSIBLE" ; }
function maxChange ( str ) { if ( str . length <= 1 ) { return 0 ; } var minChanges = 0 ; for ( var i = 0 ; i < str . length - 1 ; i ++ ) { if ( str [ i ] === str [ i + 1 ] ) { str [ i + 1 ] = "N" ; minChanges += 1 ; } else if ( i > 0 && str [ i - 1 ] === str [ i + 1 ] ) { str [ i + 1 ] = "N" ; minChanges += 1 ; } } return minChanges ; }
function generatepermutation ( N ) { var answer = [ ] ; answer . push ( N ) ; console . log ( answer ) ; for ( var i = 1 ; i < N ; i ++ ) { console . log ( answer ) ; answer . push ( i ) ; } for ( var i in answer ) document . write ( answer [ i ] + "▁" ) ; }
function maxNumPalindrome ( S ) { let i = 0 ; let freq = new Array ( 26 ) . fill ( 0 ) ; let freqPair = 0 ; let len = ( S . length / 3 ) ; while ( i < S . length ) { freq [ S [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; i ++ ; } for ( i = 0 ; i < 26 ; i ++ ) { freqPair += Math . floor ( freq [ i ] / 2 ) ; } return Math . min ( freqPair , len ) ; }
function cntEvenSumPairs ( X , Y ) { var cntXEvenNums = parseInt ( X / 2 ) ; var cntXOddNums = parseInt ( ( X + 1 ) / 2 ) ; var cntYEvenNums = parseInt ( Y / 2 ) ; var cntYOddNums = parseInt ( ( Y + 1 ) / 2 ) ; var cntPairs = ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ; return cntPairs ; }
function farthestCellDistance ( N , M , R , C ) { let d1 = N + M - R - C ; let d2 = R + C - 2 ; let d3 = N - R + C - 1 ; let d4 = M - C + R - 1 ; let maxDistance = Math . max ( d1 , Math . max ( d2 , Math . max ( d3 , d4 ) ) ) ; document . write ( maxDistance ) ; }
function maxSum ( arr , N ) { let ans = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { let t = i ; if ( t + arr [ i ] < N ) { arr [ i ] += arr [ t + arr [ i ] ] ; } } for ( let i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function constructArray ( arr , N ) { var brr = Array ( N ) . fill ( 0 ) ; for ( i = 0 ; i < N ; i ++ ) { var K = parseInt ( ( Math . log ( arr [ i ] ) / Math . log ( 2 ) ) ) ; var R = parseInt ( Math . pow ( 2 , K ) ) ; brr [ i ] = R ; } for ( i = 0 ; i < N ; i ++ ) { document . write ( brr [ i ] + "▁" ) ; } }
function findMinKToMakeAllEqual ( N , A ) { var B = new Set ( ) ; for ( var i = 0 ; i < N ; i ++ ) B . add ( A [ i ] ) ; var M = B . size ; var itr = [ ... B ] . sort ( ( a , b ) => a - b ) ; if ( M > 3 ) document . write ( "-1" ) ; else if ( M == 3 ) { var B_1 = itr [ 0 ] ; var B_2 = itr [ 1 ] ; var B_3 = itr [ 2 ] ; if ( B_2 - B_1 == B_3 - B_2 ) document . write ( B_2 - B_1 ) ; else document . write ( "-1" ) ; } else if ( M == 2 ) { var B_1 = itr [ 0 ] ; var B_2 = itr [ 1 ] ; if ( ( B_2 - B_1 ) % 2 == 0 ) document . write ( parseInt ( ( B_2 - B_1 ) / 2 ) ) ; else document . write ( B_2 - B_1 ) ; } else document . write ( 0 ) ; }
function minOpsToTurnArrToZero ( arr , N ) { var st = new Set ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( st . has ( arr [ i ] ) arr [ i ] == 0 ) { continue ; } else { st . add ( arr [ i ] ) ; } } document . write ( st . size ) }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function splitArray ( arr , N ) { var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } var G = 0 ; mp . forEach ( ( value , key ) => { G = gcd ( G , value ) ; } ) ; if ( G > 1 ) document . write ( "YES" ) ; else document . write ( "NO" ) ; }
function minMoves ( arr ) { let N = arr . length ; if ( N <= 2 ) return 0 ; let ans = Number . MAX_VALUE ; for ( let i = - 1 ; i <= 1 ; i ++ ) { for ( let j = - 1 ; j <= 1 ; j ++ ) { let num1 = arr [ 0 ] + i ; let num2 = arr [ 1 ] + j ; let flag = 1 ; let moves = Math . abs ( i ) + Math . abs ( j ) ; for ( let idx = 2 ; idx < N ; idx ++ ) { let num = num1 + num2 ; if ( Math . abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag > 0 ) ans = Math . min ( ans , moves ) ; } } if ( ans == Number . MAX_VALUE ) return - 1 ; return ans ; }
function querySum ( arr , N , Q , M ) { for ( let i = 0 ; i < M ; i ++ ) { let x = Q [ i ] [ 0 ] ; let y = Q [ i ] [ 1 ] ; let sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } document . write ( sum + "▁" ) ; } }
function CheckAllEqual ( arr , N ) { for ( i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return false ; } } return true ; }
function minCntOperations ( arr , N ) { var Max = Math . max . apply ( Math , arr ) ; var isPower2 ; if ( parseInt ( ( Math . ceil ( ( Math . log ( N ) / Math . log ( N ) ) ) ) ) == parseInt ( ( Math . floor ( ( ( Math . log ( N ) / Math . log ( 2 ) ) ) ) ) ) ) { isPower2 = true ; } else { isPower2 = false ; } if ( isPower2 && CheckAllEqual ( arr , N ) ) { return parseInt ( ( Math . log ( Max ) / Math . log ( 2 ) ) ) ; } else { return parseInt ( Math . ceil ( Math . log ( Max ) / Math . log ( 2 ) ) ) + 1 ; } }
function greatestReducedNumber ( num , s ) { let vis_s = [ false , false , false , false , false , false , false , false , false , false ] ; for ( let i = 0 ; i < s . length ; i ++ ) { vis_s [ Number ( s [ i ] ) - 48 ] = true ; } let n = num . length ; let inn = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( vis_s [ Number ( num [ i ] ) - "0" ] ) { inn = i ; break ; } } if ( inn == - 1 ) { return num ; } for ( let dig = String ( num [ inn ] ) ; dig >= "0" ; dig -- ) { if ( vis_s [ Number ( dig ) - "0" ] == 0 ) { num [ inn ] = dig ; break ; } } let LargestDig = "0" ; for ( let dig = "9" ; dig >= "0" ; dig -- ) { if ( vis_s [ dig - "0" ] == false ) { LargestDig = dig ; break ; } } for ( let i = inn + 1 ; i < n ; i ++ ) { num [ i ] = LargestDig ; } let Count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( num [ i ] == "0" ) Count ++ ; else break ; } num = Number ( num ) . toString ( ) ; if ( num . length == 0 ) return "0" ; return num ; }
function minXOR ( Arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { if ( Arr [ i ] == 2 ) { document . write ( ( Arr [ i ] ^ 3 ) + "▁" ) ; } else { document . write ( ( Arr [ i ] ^ 2 ) + "▁" ) ; } } }
function findArray ( n ) { let Arr = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; Arr [ 0 ] = 0 ; Arr [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { Arr [ i ] = Arr [ i / 2 ] ; } else { Arr [ i ] = Arr [ ( i - 1 ) / 2 ] + Arr [ ( i - 1 ) / 2 + 1 ] ; } } return Arr ; }
function maxElement ( n ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; let Arr = findArray ( n ) ; let ans = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , Arr [ i ] ) ; } return ans ; }
function findMaxValByRearrArr ( arr , N ) { let res = 0 ; res = parseInt ( ( N * ( N + 1 ) ) / 2 , 10 ) ; return res ; }
function min_steps_required ( n , m , r , c ) { var i , j ; var corner_steps_req = Number . MAX_VALUE ; i = 1 ; j = 1 ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = n ; j = 1 ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = 1 ; j = m ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = n ; j = m ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; var minimum_steps = Math . min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) ; return minimum_steps + corner_steps_req ; }
function min_elements ( arr , N , K ) { let mp = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) } else { mp . set ( arr [ i ] , 1 ) } } let Freq = [ ] ; for ( let it of mp ) { let i = it [ 0 ] ; Freq . push ( mp . get ( i ) ) ; } Freq . sort ( ( a , b ) => b - a ) ; let len = Freq . length ; if ( len <= K ) { return 0 ; } let cntMin = 0 ; for ( let i = K ; i < len ; i ++ ) { cntMin += Freq [ i ] ; } return cntMin ; }
function sumzero ( arr , N , K ) { var sum = 0 ; for ( i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 0 ) document . write ( "Yes" ) ; else if ( sum > 0 ) { if ( sum % K == 0 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; } else document . write ( "No" ) ; return 0 ; }
function cntOnesArrWithGivenOp ( arr , N ) { let cntOnes = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = i - 1 ; j < N ; j += i ) { arr [ j ] = arr [ j ] == 0 ? 1 : 0 ; } } for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) { cntOnes += 1 ; } } return cntOnes ; }
function cntOnesArrWithGivenOp ( arr , N ) { var cntOnes = 0 ; cntOnes = parseInt ( Math . sqrt ( N ) ) ; return cntOnes ; }
function minimumMoves ( arr , N ) { let sum = 0 ; let maxelement = - 1 ; if ( N == 2 ) { document . write ( "0" ) ; return ; } for ( let i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; maxelement = Math . max ( maxelement , arr [ i ] ) ; } let k = ( sum + N - 2 ) / ( N - 1 ) ; k = Math . max ( maxelement , k ) ; let ans = k * ( N - 1 ) - sum ; document . write ( ans ) ; }
function minimumSwaps ( arr1 , arr2 , n ) { let sumArr1 = 0 , sumArr2 = 0 ; for ( let i = 0 ; i < n ; ++ i ) { sumArr1 += arr1 [ i ] ; sumArr2 += arr2 [ i ] ; } if ( sumArr1 % 2 == 0 && sumArr2 % 2 == 0 ) { document . write ( 0 ) ; return ; } if ( sumArr1 % 2 != 0 && sumArr2 % 2 != 0 ) { let flag = - 1 ; for ( let i = 0 ; i < n ; ++ i ) { if ( ( arr1 [ i ] + arr2 [ i ] ) % 2 == 1 ) { flag = 1 ; break ; } } document . write ( flag ) ; return ; } document . write ( - 1 ) ; }
function corpFlightBookings ( Bookings , N ) { let res = new Array ( N ) . fill ( 0 ) ; for ( let i = 0 ; i < Bookings . length ; i ++ ) { let l = Bookings [ i ] [ 0 ] ; let r = Bookings [ i ] [ 1 ] ; let K = Bookings [ i ] [ 2 ] ; res [ l - 1 ] = res [ l - 1 ] + K ; if ( r <= res . length - 1 ) res [ r ] = ( - K ) + res [ r ] ; } for ( let i = 1 ; i < res . length ; i ++ ) res [ i ] = res [ i ] + res [ i - 1 ] ; for ( let i = 0 ; i < res . length ; i ++ ) { document . write ( res [ i ] + "▁" ) ; } }
function findOddXOR ( n ) { if ( n % 2 == 0 ) document . write ( ( findXOR ( n ) ) ^ ( 2 * findXOR ( n / 2 ) ) ) ; else document . write ( ( findXOR ( n ) ) ^ ( 2 * findXOR ( ( n - 1 ) / 2 ) ) ) ; }
function findSmallestNumber ( n ) { for ( i = n ; i <= ( n + 2520 ) ; ++ i ) { var possible = 1 ; var temp = i ; while ( temp != 0 ) { if ( temp % 10 != 0 ) { var digit = temp % 10 ; if ( i % digit != 0 ) { possible = 0 ; break ; } } temp = parseInt ( temp / 10 ) ; } if ( possible == 1 ) { document . write ( i ) ; return ; } } }
function path_to_root ( node ) { while ( node >= 1 ) { document . write ( node + "▁" ) ; node = parseInt ( node / 2 , 10 ) ; } }
function minValue ( arr , n ) { var minimum = Math . min . apply ( Math , arr ) ; var sum = 0 ; var i ; for ( i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] - minimum ) ; } return sum ; }
function computeLPSArray ( pat , M , lps ) { var len = 0 ; lps [ 0 ] = 0 ; var i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } }
function lastRemovedCharacter ( str ) { var n = str . length ; if ( n == 1 ) return str [ 0 ] ; if ( str [ n - 2 ] == "0" ) { return "1" - str [ n - 1 ] + "0" ; } else return str [ n - 1 ] ; }
function findNumbers ( aXORb , aANDb , aXORc , aANDc , bXORc , bANDc ) { let a , b , c ; let aSUMb ; let aSUMc ; let bSUMc ; aSUMb = aXORb + aANDb * 2 ; aSUMc = aXORc + aANDc * 2 ; bSUMc = bXORc + bANDc * 2 ; a = Math . floor ( ( aSUMb - bSUMc + aSUMc ) / 2 ) ; b = aSUMb - a ; c = aSUMc - a ; document . write ( "a▁=▁" + a ) ; document . write ( ",▁b▁=▁" + b ) ; document . write ( ",▁c▁=▁" + c ) ; }
function findArray ( N , K ) { if ( N == 1 ) { document . write ( K + "▁" ) ; return ; } if ( N == 2 ) { document . write ( 0 + "▁" + K ) ; return ; } let P = N - 2 ; let Q = N - 1 ; let VAL = 0 ; for ( let i = 1 ; i <= ( N - 3 ) ; i ++ ) { document . write ( i + "▁" ) ; VAL ^= i ; } if ( VAL == K ) { document . write ( P + "▁" + Q + "▁" + ( P ^ Q ) ) ; } else { document . write ( 0 + "▁" + P + "▁" + ( P ^ K ^ VAL ) ) ; } }
function findNumber ( N ) { let count = 0 ; while ( ( N & 1 ) == 1 ) { N = N >> 1 ; count ++ ; } return N << count ; }
function findNumber ( N ) { return N & ( N + 1 ) ; }
function array_divisbleby_k ( N , K ) { let flag = false ; let d1 = 0 , d2 = 0 ; for ( let i = 2 ; i * i <= K ; i ++ ) { if ( K % i == 0 ) { flag = true ; d1 = i ; d2 = K / i ; break ; } } if ( flag ) { for ( let i = 0 ; i < N ; i ++ ) { if ( i % 2 == 1 ) { document . write ( d2 + "▁" ) ; } else { document . write ( d1 + "▁" ) ; } } } else { document . write ( - 1 ) ; } }
function min_elements ( arr , N ) { var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } var cntMinRem = 0 ; mp . forEach ( ( value , key ) => { var i = key ; if ( mp . get ( i ) < i ) { cntMinRem += mp . get ( i ) ; } else if ( mp . get ( i ) > i ) { cntMinRem += ( mp . get ( i ) - i ) ; } } ) ; return cntMinRem ; }
function CheckAllarrayEqual ( arr , N ) { if ( N == 1 ) { return true ; } let totalSum = arr [ 0 ] ; let secMax = Number . MIN_VALUE ; let Max = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= Max ) { secMax = Max ; Max = arr [ i ] ; } else if ( arr [ i ] > secMax ) { secMax = arr [ i ] ; } totalSum += arr [ i ] ; } if ( ( secMax * ( N - 1 ) ) > totalSum ) { return false ; } if ( totalSum % ( N - 1 ) != 0 ) { return false ; } return true ; }
function getSum ( ar ) { let sum = 0 ; for ( let i = 0 ; i < ar . length ; i ++ ) { sum += ar [ i ] ; } return sum ; }
function getMinSum ( pos , arr , primePow ) { if ( pos == primePow . length ) { return getSum ( arr ) ; } let res = Number . MAX_VALUE ; for ( let i = 0 ; i < arr . length ; i ++ ) { arr [ i ] *= primePow [ pos ] ; res = Math . min ( res , getMinSum ( pos + 1 , arr , primePow ) ) ; arr [ i ] /= primePow [ pos ] ; } return res ; }
function minimumSumWithGivenLCM ( k , x ) { let primePow = primePower ( x ) ; let n = primePow . length ; let sum = 0 ; if ( n <= k ) { for ( let i = 0 ; i < primePow . length ; i ++ ) { sum += primePow [ i ] ; } sum += k - n ; } else { let arr = new Array ( k ) ; for ( let i = 0 ; i < k ; i ++ ) { arr [ i ] = 1 ; } sum = getMinSum ( 0 , arr , primePow ) ; } return sum ; }
function IsPresent ( str , target ) { if ( str . includes ( target ) ) { return 1 ; } return - 1 ; }
function findBitwiseORGivenXORAND ( X , Y ) { return X + Y ; }
function minOperation ( X , Y , n ) { let C = 0 ; let count = 0 ; for ( let i = 1 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; count = 0 ; for ( let i = 0 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; document . write ( C ) ; }
function minimumcntOperationReq ( arr , N ) { let cntOp = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cntOp ++ ; } } return ( cntOp + 1 ) / 2 ; }
function ConstArrayAdjacentCoprime ( N ) { for ( let i = 1 ; i <= N ; i ++ ) { document . write ( i + "▁" ) ; } }
function cntIndexesToMakeBalance ( arr , n ) { if ( n == 1 ) { return 1 ; } if ( n == 2 ) return 0 ; let sumEven = 0 ; let sumOdd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { sumEven += arr [ i ] ; } else { sumOdd += arr [ i ] ; } } let currOdd = 0 ; let currEven = arr [ 0 ] ; let res = 0 ; let newEvenSum = 0 ; let newOddSum = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( i % 2 ) { currOdd += arr [ i ] ; newEvenSum = currEven + sumOdd - currOdd ; newOddSum = currOdd + sumEven - currEven - arr [ i ] ; } else { currEven += arr [ i ] ; newOddSum = currOdd + sumEven - currEven ; newEvenSum = currEven + sumOdd - currOdd - arr [ i ] ; } if ( newEvenSum == newOddSum ) { res ++ ; } } if ( sumOdd == sumEven - arr [ 0 ] ) { res ++ ; } if ( n % 2 == 1 ) { if ( sumOdd == sumEven - arr [ n - 1 ] ) { res ++ ; } } else { if ( sumEven == sumOdd - arr [ n - 1 ] ) { res ++ ; } } return res ; }
function findMinOperationsReqEmpStr ( str ) { let cntOne = 0 ; let cntZero = 0 ; let N = str . length ; for ( let i = 0 ; i < N ; i ++ ) { if ( str [ i ] == "0" ) { if ( cntOne != 0 ) { cntOne -- ; } cntZero ++ ; } else { if ( cntZero != 0 ) { cntZero -- ; } cntOne ++ ; } } return ( cntOne + cntZero ) ; }
function minimumOperations ( S , m ) { let V = 100 ; let adj = [ ] ; for ( let i = 0 ; i < V ; i ++ ) { adj . push ( [ ] ) ; } let total = 0 , N = S . length ; for ( let i = 0 ; i < adj . length ; i ++ ) adj [ i ] = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { addEdge ( adj , i , N - i - 1 ) ; addEdge ( adj , N - i - 1 , i ) ; } for ( let i = 0 ; i < N - m ; i ++ ) { addEdge ( adj , i , i + m ) ; addEdge ( adj , i + m , i ) ; } visited = new Array ( V ) ; visited . fill ( false ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( ! visited [ i ] ) { let fre = new Array ( 26 ) ; fre . fill ( 0 ) ; cnt = 0 ; let maxx = - 1 ; DFS ( i , adj , fre , S ) ; for ( let j = 0 ; j < 26 ; j ++ ) maxx = Math . max ( maxx , fre [ j ] ) ; total += cnt - maxx ; } } document . write ( total ) ; }
function countChanges ( mat ) { let n = mat . length ; let m = mat [ 0 ] . length ; let ans = 0 ; for ( let j = 0 ; j < m - 1 ; j ++ ) { if ( mat [ n - 1 ] [ j ] != "R" ) ans ++ ; } for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( mat [ i ] [ m - 1 ] != "D" ) ans ++ ; } return ans ; }
function findMaxSumByAlternatingSign ( arr , N ) { let cntNeg = 0 ; let MaxAltSum = 0 ; let SmValue = 0 ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { cntNeg += 1 ; } sum += Math . abs ( arr [ i ] ) ; SmValue = Math . min ( SmValue , Math . abs ( arr [ i ] ) ) ; } MaxAltSum = sum ; if ( cntNeg % 2 == 1 ) { MaxAltSum -= 2 * SmValue ; } return MaxAltSum ; }
function minCntCharDeletionsfrequency ( str , N ) { let mp = new Map ( ) ; let pq = [ ] ; let cntChar = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( mp . has ( str [ i ] ) ) { mp . set ( str [ i ] , mp . get ( str [ i ] ) + 1 ) ; } else { mp . set ( str [ i ] , 1 ) ; } } for ( let [ key , value ] of mp . entries ( ) ) { pq . push ( value ) ; } pq . sort ( function ( a , b ) { return b - a ; } ) ; while ( pq . length != 0 ) { let frequent = pq [ 0 ] ; pq . shift ( ) ; if ( pq . length == 0 ) { return cntChar ; } if ( frequent == pq [ 0 ] ) { if ( frequent > 1 ) { pq . push ( frequent - 1 ) ; pq . sort ( function ( a , b ) { return b - a ; } ) ; } cntChar ++ ; } } return cntChar ; }
function constructNewArraySumZero ( arr , N ) { let newArr = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { newArr [ i ] = arr [ i + 1 ] ; } else { newArr [ i ] = - arr [ i - 1 ] ; } } for ( let i = 0 ; i < N ; i ++ ) { document . write ( newArr [ i ] + "▁" ) ; } }
function minimumCntOfFlipsRequired ( str ) { let n = str . length ; let zeros = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == "0" ) { zeros ++ ; } } if ( zeros == 0 zeros == n ) { return 0 ; } let minFlips = Number . MAX_VALUE ; let currOnes = 0 ; let flips ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == "1" ) { currOnes ++ ; } flips = currOnes + ( zeros - ( i + 1 - currOnes ) ) ; minFlips = Math . min ( minFlips , flips ) ; } return minFlips ; }
function constructMEX ( arr , N ) { var hash = Array ( MAXN ) . fill ( 0 ) ; for ( var i = 0 ; i < N ; i ++ ) { hash [ arr [ i ] ] = 1 ; } var MexOfArr ; for ( var i = 1 ; i < MAXN ; i ++ ) { if ( hash [ i ] == 0 ) { MexOfArr = i ; break ; } } var B = Array ( N ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < MexOfArr ) B [ i ] = arr [ i ] ; else B [ i ] = MexOfArr ; } for ( var i = 0 ; i < N ; i ++ ) document . write ( B [ i ] + "▁" ) ; }
function smallestNumberLeftInPQ ( arr , N ) { let pq = [ ] ; let pairsArr = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { pq . push ( arr [ i ] ) ; } pq . sort ( function ( a , b ) { return b - a ; } ) ; while ( pq . length > 1 ) { let X = pq [ 0 ] ; pq . shift ( ) ; let Y = pq [ 0 ] ; pq . shift ( ) ; pq . push ( Math . floor ( ( X + Y + 1 ) / 2 ) ) ; pq . sort ( function ( a , b ) { return b - a ; } ) ; pairsArr . push ( new pair ( X , Y ) ) ; } document . write ( "{" + pq [ 0 ] + "},▁" ) ; let sz = pairsArr . length ; for ( let i = 0 ; i < sz ; i ++ ) { if ( i == 0 ) { document . write ( "{▁" ) ; } document . write ( "(" + pairsArr [ i ] . first + ",▁" + pairsArr [ i ] . second + ")" ) ; if ( i != sz - 1 ) { document . write ( ",▁" ) ; } if ( i == sz - 1 ) { document . write ( "▁}" ) ; } } }
function findPairs ( N ) { for ( let i = 0 ; i <= N ; i ++ ) { document . write ( "(" + i + ",▁" + ( N - i ) + "),▁" ) ; } }
function GCD ( a , b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
function GCD ( a , b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
function canReach ( N , A , B , K ) { var gcd = GCD ( N , K ) ; if ( Math . abs ( A - B ) % gcd == 0 ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function sum ( n ) { var res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; }
function smallestNumber ( n , s ) { if ( sum ( n ) <= s ) { return n ; } var ans = n , k = 1 ; for ( i = 0 ; i < 9 ; ++ i ) { var digit = ( ans / k ) % 10 ; var add = k * ( ( 10 - digit ) % 10 ) ; ans += add ; if ( sum ( ans ) <= s ) { break ; } k *= 10 ; } return ans ; }
function separate ( arr , n , parity ) { let count = 1 , res = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( ( ( arr [ i ] + parity ) & 1 ) != 0 && ( ( arr [ i - 1 ] + parity ) & 1 ) != 0 ) count ++ ; else { if ( count > 1 ) res += count - 1 ; count = 1 ; } } return res ; }
function requiredOps ( arr , N ) { let res1 = separate ( arr , N , 0 ) ; let res2 = separate ( arr , N , 1 ) ; document . write ( Math . max ( res1 , res2 ) ) ; }
function SieveOfEratosthenes ( N ) { let isPrime = [ ] ; for ( let i = 0 ; i < N + 1 ; i ++ ) { isPrime [ i ] = true ; } isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( let p = 2 ; p * p <= N ; p ++ ) { if ( isPrime [ p ] ) { for ( let i = p * p ; i <= N ; i += p ) { isPrime [ i ] = false ; } } } return isPrime ; }
function cntPairsdiffOfPrimeisPrime ( N ) { let cntPairs = 0 ; let isPrime = SieveOfEratosthenes ( N ) ; for ( let i = 2 ; i <= N ; i ++ ) { if ( isPrime [ i ] && isPrime [ i - 2 ] ) { cntPairs += 2 ; } } return cntPairs ; }
function longestSubsequence ( arr , N ) { let count = 1 ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count ++ ; } } document . write ( count ) ; }
function substringCount ( s ) { var freq = new Array ( 26 ) . fill ( 0 ) ; var max_char = "#" ; var maxfreq = - 21474836487 ; for ( var i = 0 ; i < s . length ; i ++ ) { freq [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; if ( maxfreq < freq [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ) maxfreq = freq [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ; } for ( var i = 0 ; i < 26 ; i ++ ) { if ( maxfreq === freq [ i ] ) { max_char = String . fromCharCode ( i + "a" . charCodeAt ( 0 ) ) ; break ; } } var ans = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { var ch = s [ i ] ; if ( max_char === ch ) { ans += s . length - i ; } } return ans ; }
function findSum ( S , n , x ) { let table = new Array ( n + 1 ) ; for ( var i = 0 ; i < table . length ; i ++ ) { table [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < table . length ; i ++ ) { for ( var j = 0 ; j < table . length ; j ++ ) { table [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= x ; i ++ ) { table [ 0 ] [ i ] = Number . MAX_VALUE - 1 ; } for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= x ; j ++ ) { if ( S [ i - 1 ] > j ) { table [ i ] [ j ] = table [ i - 1 ] [ j ] ; } else { table [ i ] [ j ] = Math . min ( table [ i - 1 ] [ j ] , table [ i ] [ j - S [ i - 1 ] ] + 1 ) ; } } } return ( table [ n ] [ x ] > n ) ? - 1 : table [ n ] [ x ] ; }
function minRemovals ( arr , n , m , x ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } let requied_Sum = 0 ; if ( sum % m < x ) requied_Sum = m + sum % m - x ; else requied_Sum = sum % m - x ; document . write ( findSum ( arr , n , requied_Sum ) ) ; }
function findXandYwithminABSX_Y ( N ) { if ( N % 2 == 1 ) { document . write ( ( N / 2 ) + "▁" + ( N / 2 + 1 ) ) ; } else { document . write ( ( N / 2 - 1 ) + "▁" + ( N / 2 + 1 ) ) ; } }
function removeDuplicateLetters ( s ) { var cnt = Array ( 26 ) . fill ( 0 ) ; var vis = Array ( 26 ) . fill ( false ) ; var n = s . length ; for ( var i = 0 ; i < n ; i ++ ) cnt [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; var res = "" ; for ( var i = 0 ; i < n ; i ++ ) { cnt [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] -- ; if ( ! vis [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ) { while ( res . length > 0 && res [ res . length - 1 ] . charCodeAt ( 0 ) > s [ i ] . charCodeAt ( 0 ) && cnt [ res [ res . length - 1 ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] > 0 ) { vis [ res [ res . length - 1 ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] = 0 ; res = res . substring ( 0 , res . length - 1 ) ; } res += s [ i ] ; vis [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] = 1 ; } } return res ; }
function minChange ( s , n ) { var L = new Array ( 26 ) . fill ( 0 ) ; var R = new Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < n / 2 ; i ++ ) { var ch = s [ i ] . charCodeAt ( 0 ) ; L [ ch - "a" . charCodeAt ( 0 ) ] ++ ; } for ( var i = n / 2 ; i < n ; i ++ ) { var ch = s [ i ] . charCodeAt ( 0 ) ; R [ ch - "a" . charCodeAt ( 0 ) ] ++ ; } var count = n ; for ( var ch = "a" . charCodeAt ( 0 ) ; ch <= "z" . charCodeAt ( 0 ) ; ch ++ ) { count = Math . min ( count , n - L [ ch - "a" . charCodeAt ( 0 ) ] - R [ ch - "a" . charCodeAt ( 0 ) ] ) ; } var change = parseInt ( n / 2 ) ; for ( var d = 0 ; d + 1 < 26 ; d ++ ) { change -= L [ d ] ; change += R [ d ] ; count = Math . min ( count , change ) ; } change = n / 2 ; for ( var d = 0 ; d + 1 < 26 ; d ++ ) { change -= R [ d ] ; change += L [ d ] ; count = Math . min ( change , count ) ; } return count ; }
function minSteps ( S ) { let new_str = "" ; let N = S . length ; let i = 0 ; while ( i < N ) { new_str += S [ i ] ; let j = i ; while ( i < N && S [ i ] == S [ j ] ) ++ i ; } document . write ( Math . ceil ( ( new_str . length + 1 ) / 2.0 ) ) ; }
function MaximumSides ( n ) { if ( n < 4 ) return - 1 ; return n % 2 == 0 ? n / 2 : - 1 ; }
function minimumMoves ( n ) { let cnt2 = 0 , cnt5 = 0 ; while ( n % 2 == 0 ) { n /= 2 ; cnt2 ++ ; } while ( n % 5 == 0 ) { n /= 5 ; cnt5 ++ ; } if ( n == 1 && cnt2 <= cnt5 ) { return 2 * cnt5 - cnt2 ; } else return - 1 ; }
function check ( n ) { if ( ( n & n - 1 ) != 0 ) document . write ( "YES" ) ; else document . write ( "NO" ) ; }
function rearrangeArrayUtil ( A , B , N ) { let ans = rearrangeArray ( A , B , N ) ; if ( ans . length > 0 ) { for ( let x of ans ) { document . write ( x + "▁" ) ; } } else { document . write ( "-1" ) ; } }
function countOfSubarray ( arr , N ) { var mp = new Map ( ) ; var answer = 0 ; var sum = 0 ; if ( ! mp . has ( 1 ) ) mp . set ( 1 , 1 ) else mp . set ( 1 , mp . get ( 1 ) + 1 )  for ( var i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; answer += mp . has ( sum - i ) ? mp . get ( sum - i ) : 0 ; if ( mp . has ( sum - i ) ) mp . set ( sum - i , mp . get ( sum - i ) + 1 ) else mp . set ( sum - i , 1 ) } document . write ( answer ) ; }
function countInverse ( arr , N , M ) { var XOR = 0 ; for ( var i = 0 ; i < N ; i ++ ) { var gcdOfMandelement = gcd ( M , arr [ i ] ) ; if ( gcdOfMandelement == 1 ) { XOR ^= arr [ i ] ; } } document . write ( XOR ) ; }
function Moves_Calculator ( x , y , row , col ) { let total_moves = 0 ; if ( ( row - x ) > 0 && ( col - y ) > 0 ) total_moves += Math . min ( ( row - x ) , ( col - y ) ) ; if ( ( y - 1 ) > 0 && ( x - 1 ) > 0 ) total_moves += Math . min ( ( y - 1 ) , ( x - 1 ) ) ; if ( ( x - 1 ) > 0 && ( col - y ) > 0 ) total_moves += Math . min ( ( x - 1 ) , ( col - y ) ) ; if ( ( row - x ) > 0 && ( y - 1 ) > 0 ) total_moves += Math . min ( ( row - x ) , ( y - 1 ) ) ; total_moves += ( row - 1 ) + ( col - 1 ) ; let king_moves = 0 ; if ( x + 1 <= row ) king_moves += 1 ; if ( x - 1 > 0 ) king_moves += 1 ; if ( y + 1 <= col ) king_moves += 1 ; if ( y - 1 > 0 ) king_moves += 1 ; if ( x + 1 <= row && y + 1 <= col ) king_moves += 1 ; if ( x + 1 <= row && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y + 1 <= col ) king_moves += 1 ; return total_moves - king_moves ; }
function clstNum ( N ) { return ( N - 1 ) ; }
function findMax ( a , dp , i , flag ) { if ( i == a . length ) { return 0 ; } if ( dp [ i ] [ flag ] != - 1 ) { return dp [ i ] [ flag ] ; } let ans ; if ( flag == 0 ) { ans = Math . max ( findMax ( a , dp , i + 1 , 0 ) , a [ i ] + findMax ( a , dp , i + 1 , 1 ) ) ; } else { ans = Math . max ( findMax ( a , dp , i + 1 , 1 ) , - 1 * a [ i ] + findMax ( a , dp , i + 1 , 0 ) ) ; } return dp [ i ] [ flag ] = ans ; }
function findMaxSumUtil ( arr , N ) { let dp = new Array ( N ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } document . write ( findMax ( arr , dp , 0 , 0 ) ) ; }
function equvInverse ( arr , N , P ) { let cntElem = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] * arr [ i ] ) % P == 1 ) { cntElem ++ ; } } return cntElem ; }
function power ( K , M ) { var res = 1 ; while ( M > 0 ) { if ( ( M & 1 ) == 1 ) { res = ( res * K ) ; } M = M >> 1 ; K = ( K * K ) ; } return res ; }
function cntWays ( arr , N , K ) { var cntways = 0 ; var M = 0 ; var st = new Set ( ) ; for ( var i = 0 ; i < N ; i ++ ) { st . add ( arr [ i ] ) ; } M = st . size ; cntways = power ( K , M ) ; return cntways ; }
function minCost ( s , k ) { var n = s . length ; var ans = 0 ; for ( var i = 0 ; i < k ; i ++ ) { var a = new Array ( 26 ) . fill ( 0 ) ; for ( var j = i ; j < n ; j += k ) { a [ s [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } var min_cost = 1000000000 ; for ( var ch = 0 ; ch < 26 ; ch ++ ) { var cost = 0 ; for ( var tr = 0 ; tr < 26 ; tr ++ ) cost += Math . abs ( ch - tr ) * a [ tr ] ; min_cost = Math . min ( min_cost , cost ) ; } ans += min_cost ; } document . write ( ans ) ; }
function pairProductMean ( arr , N ) { var pairArray = [ ] ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { var pairProduct = arr [ i ] * arr [ j ] ; pairArray . push ( pairProduct ) ; } } var length = pairArray . length ; var sum = 0 ; for ( i = 0 ; i < length ; i ++ ) sum += pairArray [ i ] ; var mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; }
function pairProductMean ( arr , N ) { var suffixSumArray = Array ( N ) ; suffixSumArray [ N - 1 ] = arr [ N - 1 ] ; for ( var i = N - 2 ; i >= 0 ; i -- ) { suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] ; } var length = ( N * ( N - 1 ) ) / 2 ; var res = 0 ; for ( var i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffixSumArray [ i + 1 ] ; } var mean ; if ( length != 0 ) mean = res / length ; else mean = 0 ; return mean ; }
function TotalXorPair ( arr , N ) { let totalXOR = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { totalXOR ^= arr [ i ] ^ arr [ j ] ; } } return totalXOR ; }
function minAbsDiff ( N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; }
function findWinner ( s ) { var vowels_count = 0 , consonants_count = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] === "a" s [ i ] === "e" s [ i ] === "i" s [ i ] === "o" s [ i ] === "u" ) { vowels_count ++ ; } else { consonants_count ++ ; } } if ( vowels_count === 0 ) { if ( consonants_count % 2 === 0 ) { document . write ( "Player▁B" ) ; } else { document . write ( "Player▁A" ) ; } } else if ( vowels_count === 1 && consonants_count % 2 !== 0 ) { document . write ( "Player▁A" ) ; } else { document . write ( "D" ) ; } }
function possibleAcyclicGraph ( N ) { document . write ( Math . pow ( 2 , N - 1 ) ) ; return ; }
function minProd ( X , Y , N ) { if ( X <= Y ) { if ( N < X ) return ( X - N ) * Y ; else { return Math . max ( Y - ( N - X + 1 ) , 1 ) ; } } if ( Y >= N ) return ( Y - N ) * X ; return Math . max ( X - ( N - Y + 1 ) , 1 ) ; }
function sieve ( ) { for ( var i = 3 ; i < MAXN ; i += 2 ) { is_prime [ i ] = 1 ; } for ( var i = 3 ; i * i < MAXN ; i += 2 ) { if ( is_prime [ i ] ) for ( var j = i * i ; j < MAXN ; j += i ) { is_prime [ j ] = 0 ; } } is_prime [ 2 ] = 1 ; for ( var i = 1 ; i < MAXN ; i ++ ) count_of_primes [ i ] = count_of_primes [ i - 1 ] + is_prime [ i ] ; }
function power ( x , y , p ) { var result = 1 ; while ( y > 0 ) { if ( y & 1 == 1 ) result = ( result * x ) % p ; x = ( x * x ) % p ; y >>= 1 ; } return result ; }
function maxSumOfSquares ( N , S ) { var res = 0 ; if ( S < N S > 9 * N ) { document . write ( - 1 ) ; return ; } S = S - N ; var c = 0 ; while ( S > 0 ) { c ++ ; if ( parseInt ( S / 8 ) > 0 ) { res += 9 * 9 ; S -= 8 ; } else { res += ( S + 1 ) * ( S + 1 ) ; break ; } } res = res + ( N - c ) ; document . write ( res ) ; }
function cntMinSub ( arr , N , K ) { var res = 0 ; var start = 0 ; var end = N - 1 ; arr . sort ( ) ; while ( end - start > 1 ) { if ( arr [ start ] + arr [ end ] <= K ) { start ++ ; } else { res ++ ; end -- ; } } if ( end - start == 1 ) { if ( arr [ start ] + arr [ end ] <= K ) { res ++ ; start ++ ; end -- ; } else { res ++ ; end -- ; } } if ( start == end ) { res ++ ; } return res ; }
function condition ( a , b ) { let d = Math . abs ( a - b ) , count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( d ) ; i ++ ) { if ( d % i == 0 ) { if ( d / i == i ) count += 1 ; else count += 2 ; } } return count ; }
function isComposite ( N ) { var i ; for ( i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return true ; } } return false ; }
function compositePair ( arr , N ) { var res = 0 ; var i , j ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { var prod = arr [ i ] * arr [ j ] ; if ( isComposite ( prod ) ) { res ++ ; } } } return res ; }
function getPrimeNum ( ) { let prime = [ ] ; for ( let i = 0 ; i < X ; i ++ ) { prime . push ( true ) ; } prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= prime . length ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= prime . length ; i += p ) prime [ i ] = false ; } } return prime ; }
function power ( x , y ) { if ( y == 0 ) return 1 ; var p = power ( x , y / 2 ) % mod ; p = ( p * p ) % mod ; if ( y & 1 ) { p = ( x * p ) % mod ; } return p ; }
function checkDigits ( n ) { do { var r = n % 10 ; if ( r == 3 r == 4 r == 6 r == 7 r == 9 ) return false ; n = parseInt ( n / 10 ) ; } while ( n != 0 ) ; return true ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( var i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
function isAllPrime ( n ) { return isPrime ( n ) && checkDigits ( n ) ; }
function generateArray ( arr , n ) { var ans = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( i & 1 ) ans . splice ( 0 , 0 , arr [ i ] ) ; else ans . push ( arr [ i ] ) ; } if ( n & 1 ) { ans . reverse ( ) ; } ans . forEach ( x => { document . write ( x + "▁" ) ; } ) ; }
function No_Of_subsequences ( mp ) { var count = 0 ; var left = 0 ; mp . forEach ( ( value , key ) => { value += left ; count += ( value / key ) ; left = value % key ; } ) ; return count ; }
function maximumsubsequences ( arr , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) else mp . set ( arr [ i ] , 1 ) ; } document . write ( No_Of_subsequences ( mp ) ) ; }
function power ( X , n ) { var res = 1 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) res = res * X ; X = X * X ; n = n >> 1 ; } return res ; }
function closestgtNum ( N ) { var n = parseInt ( Math . log10 ( N ) + 1 ) ; var P = power ( 10 , n - 1 ) ; var Y = N % P ; var res = N + ( P - Y ) ; return res ; }
function closestgtNum ( str ) { var res = "" ; var n = str . length ; if ( str [ 0 ] < "9" ) { res = res + String . fromCharCode ( str [ 0 ] . charCodeAt ( 0 ) + 1 ) ; } else { res = res + "1" ; res = res + "0" ; } for ( var i = 0 ; i < n - 1 ; i ++ ) { res = res + "0" ; } return res ; }
function find_next ( n , k ) { let M = n + 1 ; while ( true ) { if ( ( M & ( 1 << k ) ) > 0 ) break ; M ++ ; } return M ; }
function check ( arr , pieces ) { var m = new Map ( ) ; for ( var i = 0 ; i < arr . length ; i ++ ) m . set ( arr [ i ] , i + 1 )  for ( var i = 0 ; i < pieces . length ; i ++ ) { if ( pieces [ i ] . length == 1 && m . get ( pieces [ i ] [ 0 ] ) != 0 ) { continue ; } else if ( pieces [ i ] . length > 1 && m . get ( pieces [ i ] [ 0 ] ) != 0 ) { var idx = m . get ( pieces [ i ] [ 0 ] ) - 1 ; idx ++ ; if ( idx >= arr . length ) return false ; for ( var j = 1 ; j < pieces [ i ] . length ; j ++ ) { if ( arr [ idx ] == pieces [ i ] [ j ] ) { idx ++ ; if ( idx >= arr . length && j < pieces [ i ] . length - 1 ) return false ; } else { return false ; } } } else { return false ; } } return true ; }
function maximumSubarrays ( arr , N , target ) { var ans = 0 ; var availIdx = - 1 ; var cur_sum = 0 ; var mp = new Map ( ) ; mp . set ( 0 , 1 ) ; for ( var i = 0 ; i < N ; i ++ ) { cur_sum += arr [ i ] ; if ( mp . has ( cur_sum - target ) && mp . get ( cur_sum - target ) >= availIdx ) { ans ++ ; availIdx = i ; } mp . set ( cur_sum , i ) ; } return ans ; }
function power ( x , y ) { var temp ; if ( y == 0 ) return 1 ; temp = power ( x , parseInt ( y / 2 ) ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
function maximumPossibleSum ( N , X ) { document . write ( X * ( power ( 2 , N ) - 1 ) ) ; }
function countOfPairs ( x , y ) { let counter = 1 ; while ( x > 0 y > 0 ) { let bit1 = x % 2 ; let bit2 = y % 2 ; x >>= 1 ; y >>= 1 ; if ( bit1 == 1 && bit2 == 0 ) { counter *= 2 ; continue ; } if ( ( bit1 & bit2 ) > 0 ) { counter = 0 ; break ; } } return counter ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function findGCD ( arr , N ) { let result = 0 ; for ( let element in arr ) { result = gcd ( result , element ) ; if ( result == 1 ) { return 1 ; } } return result ; }
function check_digits ( N ) { while ( N > 0 ) { let n = N % 10 ; if ( ( n != 0 ) && ( n != 1 ) && ( n != 4 ) && ( n != 9 ) ) { return 0 ; } N = Math . floor ( N / 10 ) ; } return 1 ; }
function isFullSquare ( N ) { if ( is_perfect ( N ) && check_digits ( N ) ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function maxBottles ( n , e ) { var s = 0 , b = 0 ; var a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; }
function power ( x , n ) { let temp ; if ( n == 0 ) return 1 ; temp = power ( x , parseInt ( n / 2 ) ) ; if ( n % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
function count_Total_Numbers ( n , x ) { let total , multiples = 0 ; for ( let i = 0 ; i < 10 ; i ++ ) { if ( i % x == 0 ) multiples ++ ; } if ( n == 1 ) return multiples ; total = ( multiples - 1 ) * power ( multiples , n - 1 ) ; return total ; }
function getPosition ( N , M ) { if ( M > parseInt ( N / 2 ) ) { return ( M - parseInt ( N / 2 ) ) ; } return ( M + parseInt ( N / 2 ) ) ; }
function number_of_strings ( N , M ) { var ans = 0 ; while ( N > 0 && M > 0 ) { if ( N > M ) { if ( N >= 2 ) { N -= 2 ; -- M ; ++ ans ; } else { break ; } } else { if ( M >= 2 ) { M -= 2 ; -- N ; ++ ans ; } else { break ; } } } document . write ( ans ) ; }
function clearLastBit ( N , K ) { var mask = ( - 1 << K + 1 ) ; return N = N & mask ; }
function SieveOfEratosthenes ( ) { for ( i = 0 ; i < maxm ; i ++ ) prime [ i ] = true ; for ( p = 2 ; p * p < maxm ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * p ; i < maxm ; i += p ) prime [ i ] = false ; } } prime [ 0 ] = false ; prime [ 1 ] = false ; }
function num_prime ( ) { prime_number [ 0 ] = 0 ; for ( i = 1 ; i <= maxm ; i ++ ) { var tmp ; if ( prime [ i ] == true ) { tmp = 1 ; } else { tmp = 0 ; } prime_number [ i ] = prime_number [ i - 1 ] + tmp ; } }
function min_steps ( arr , n ) { SieveOfEratosthenes ( ) ; num_prime ( ) ; if ( n == 1 ) { document . write ( "0" ) ; } else if ( n == 2 ) { document . write ( "1" ) ; } else { document . write ( prime_number [ n ] - 1 + ( n - 2 ) ) ; } }
function findWinner ( a , n ) { let win = 0 ; if ( n % 2 == 0 ) win = 1 ; else win = 0 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) { if ( win == 0 && a [ i ] > 1 ) win = 1 ; } else { if ( win == 1 && a [ i ] > 1 ) win = 0 ; } } if ( win == 0 ) document . write ( "A" ) ; else document . write ( "B" ) ; }
function isPossible ( r , b , g ) { r = r % 3 ; b = b % 3 ; g = g % 3 ; if ( r == b b == g g == r ) { return true ; } else { return false ; } }
function checkWinner ( N , K ) { if ( N % ( K + 1 ) ) { document . write ( "A" ) ; } else { document . write ( "B" ) ; } }
function ncr ( n , k ) { var res = 1 ; if ( k > n - k ) k = n - k ; for ( var i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
function countPath ( N , M , K ) { var answer ; if ( K >= 2 ) answer = 0 ; else if ( K == 0 ) answer = ncr ( N + M - 2 , N - 1 ) ; else { answer = ncr ( N + M - 2 , N - 1 ) ; var X = ( N - 1 ) / 2 + ( M - 1 ) / 2 ; var Y = ( N - 1 ) / 2 ; var midCount = ncr ( X , Y ) ; X = ( ( N - 1 ) - ( N - 1 ) / 2 ) + ( ( M - 1 ) - ( M - 1 ) / 2 ) ; Y = ( ( N - 1 ) - ( N - 1 ) / 2 ) ; midCount *= ncr ( X , Y ) ; answer -= midCount ; } return answer ; }
function calculate_steps ( arr , n , minimum ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var val = arr [ i ] ; if ( arr [ i ] > minimum ) { arr [ i ] = arr [ i ] - minimum ; count += parseInt ( arr [ i ] / 5 ) ; arr [ i ] = arr [ i ] % 5 ; count += parseInt ( arr [ i ] / 2 ) ; arr [ i ] = arr [ i ] % 2 ; if ( arr [ i ] ) { count ++ ; } } arr [ i ] = val ; } return count ; }
function solve ( arr , n ) { arr . sort ( ( a , b ) => b - a ) ; var minimum = arr [ n - 1 ] ; var count1 = 0 , count2 = 0 , count3 = 0 ; count1 = calculate_steps ( arr , n , minimum ) ; count2 = calculate_steps ( arr , n , minimum - 1 ) ; count3 = calculate_steps ( arr , n , minimum - 2 ) ; return Math . min ( count1 , Math . min ( count2 , count3 ) ) ; }
function maxSubset ( arr , N , X ) { arr = arr . sort ( ( a , b ) => b - a ) ; let counter = 0 ; let sz = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sz ++ ; if ( arr [ i ] * sz >= X ) { counter ++ ; sz = 0 ; } } return counter ; }
function getCount ( N , M ) { let total_count = 0 total_count += Math . floor ( N / 10 )  let x = Math . floor ( N / 10 ) * 10  if ( ( N - x ) >= M ) { total_count = total_count + 1 } return total_count }
function maximumModuloValue ( A , n ) { var mn = Number . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { mn = Math . min ( A [ i ] , mn ) ; } return mn ; }
function RightAngled ( a , n ) { var xpoints = { } ; var ypoints = { } ; for ( var i = 0 ; i < n ; i ++ ) { if ( xpoints . hasOwnProperty ( a [ i ] [ 0 ] ) ) { xpoints [ a [ i ] [ 0 ] ] = xpoints [ a [ i ] [ 0 ] ] + 1 ; } else { xpoints [ a [ i ] [ 0 ] ] = 1 ; } if ( ypoints . hasOwnProperty ( a [ i ] [ 1 ] ) ) { ypoints [ a [ i ] [ 1 ] ] = ypoints [ a [ i ] [ 1 ] ] + 1 ; } else { ypoints [ a [ i ] [ 1 ] ] = 1 ; } } var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( xpoints [ a [ i ] [ 0 ] ] >= 1 && ypoints [ a [ i ] [ 1 ] ] >= 1 ) { count += ( xpoints [ a [ i ] [ 0 ] ] - 1 ) * ( ypoints [ a [ i ] [ 1 ] ] - 1 ) ; } } return count ; }
function updateQuery ( from_x , from_y , to_x , to_y , k , aux ) { aux [ from_x ] [ from_y ] += k ; if ( to_x + 1 < N ) aux [ to_x + 1 ] [ from_y ] -= k ; if ( to_x + 1 < N && to_y + 1 < M ) aux [ to_x + 1 ] [ to_y + 1 ] += k ; if ( to_y + 1 < M ) aux [ from_x ] [ to_y + 1 ] -= k ; }
function RepeatingSubarray ( arr , N ) { if ( N < 2 ) { document . write ( "-1" ) ; } let brr = [ ] ; brr . push ( arr [ 0 ] ) ; brr . push ( arr [ 1 ] ) ; for ( let i = 2 ; i < Math . floor ( N / 2 ) + 1 ; i ++ ) { if ( N % i == 0 ) { let a = false ; let n = brr . length ; let j = i ; while ( j < N ) { let K = j % i ; if ( arr [ j ] == brr [ K ] ) { j ++ ; } else { a = true ; break ; } } if ( ! a && j == N ) { printArray ( brr ) ; return ; } } brr . push ( arr [ i ] ) ; } document . write ( "-1" ) ; return ; }
function SieveOfEratosthenes ( n ) { isprime . fill ( true ) ; isprime [ 1 ] = false ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( isprime [ p ] == true ) { for ( let i = p * p ; i <= n ; i += p ) isprime [ i ] = false ; } } }
function KDistinctPrime ( arr , n , k ) { SieveOfEratosthenes ( 2000000 ) ; let cnt = new Map ( ) ; let result = - 1 ; for ( let i = 0 , j = - 1 ; i < n ; ++ i ) { let x = arr [ i ] ; if ( isprime [ x ] ) { if ( cnt . has ( x ) ) cnt . set ( x , cnt . get ( x ) + 1 ) else cnt . set ( x , 1 ) ; if ( cnt . get ( x ) == 1 ) { -- k ; } } while ( k < 0 ) { x = arr [ ++ j ] ; if ( isprime [ x ] ) { if ( cnt . has ( x ) ) cnt . set ( x , cnt . get ( x ) - 1 ) else cnt . set ( x , - 1 ) ; if ( cnt . get ( x ) == 0 ) { ++ k ; } } } if ( k == 0 ) result = Math . max ( result , i - j ) ; } return result ; }
function printMissingElements ( arr , N ) { let b = new Uint8Array ( arr [ N - 1 ] + 1 ) ; for ( let i = 0 ; i < N ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( let i = arr [ 0 ] ; i <= arr [ N - 1 ] ; i ++ ) { if ( b [ i ] == 0 ) { document . write ( i + "▁" ) ; } } }
function SieveOfEratosthenes ( StorePrimes ) { var IsPrime = Array ( MAX_SIZE ) . fill ( true ) ; var p , i ; for ( p = 2 ; p * p < MAX_SIZE ; p ++ ) { if ( IsPrime [ p ] == true ) { for ( i = p * p ; i < MAX_SIZE ; i += p ) IsPrime [ i ] = false ; } } for ( p = 2 ; p < MAX_SIZE ; p ++ ) if ( IsPrime [ p ] ) StorePrimes . push ( p ) ; }
function Smallest_non_Prime ( StorePrimes , N ) { var x = StorePrimes [ N ] ; return x * x ; }
function countNestedPolygons ( sides ) { var count = 0 ; while ( sides > 5 ) { sides /= 2 ; count += 1 ; } return count ; }
function smallestCommon ( a , b , c , d ) { if ( a == c ) return a ; if ( a > c ) { swap ( a , c ) ; swap ( b , d ) ; } let first_term_diff = ( c - a ) ; let possible_y ; for ( possible_y = 0 ; possible_y < b ; possible_y ++ ) { if ( ( first_term_diff % b + possible_y * d ) % b == 0 ) { break ; } } if ( possible_y != b ) { return c + possible_y * d ; } return - 1 ; }
function isprm ( n ) { if ( n <= 1 ) return 0 ; if ( n <= 3 ) return 1 ; if ( n % 2 == 0 n % 3 == 0 ) return 0 ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return 0 ; return 1 ; }
function NumberOfTrees ( arr , N ) { let maxElement = Math . max ( ... arr ) ; let level = Array . from ( { length : maxElement + 1 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { level [ arr [ i ] ] ++ ; } if ( arr [ 0 ] != 0 level [ 0 ] != 1 ) { return 0 ; } let ans = 1 ; for ( let i = 0 ; i < maxElement ; i ++ ) { for ( let j = 0 ; j < level [ i + 1 ] ; j ++ ) { ans = ( ans * level [ i ] ) % mod ; } } return ans ; }
function power ( x , y ) { if ( y == 0 ) return 1 ; let p = power ( x , y / 2 ) % mod ; p = ( p * p ) % mod ; if ( ( y & 1 ) != 0 ) p = ( x * p ) % mod ; return p ; }
function NumberOfTrees ( arr , N ) { let maxElement = Math . max ( ... arr ) ; let level = Array ( maxElement + 1 ) . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { level [ arr [ i ] ] ++ ; } if ( arr [ 0 ] != 0 level [ 0 ] != 1 ) { return 0 ; } let ans = 1 ; for ( let i = 0 ; i < maxElement ; i ++ ) { ans = ( ans * power ( level [ i ] , level [ i + 1 ] ) ) % mod ; } return ans ; }
function carryCount ( num1 , num2 ) { let count = 0 ; while ( num2 != 0 ) { let carry = num1 & num2 ; num1 = num1 ^ num2 ; num2 = carry << 1 ; count += countSetBits ( num2 ) ; } return count ; }
function power ( X , Y , Mod ) { if ( Y == 0 ) return 1 ; var p = power ( X , Y / 2 , Mod ) % Mod ; p = ( p * p ) % Mod ; if ( Y & 1 ) { p = ( X * p ) % Mod ; } return p ; }
function Inversefactorial ( N ) { if ( N <= 0 ) return 1 ; var fact = 1 ; for ( var i = 1 ; i <= N ; i ++ ) { fact = ( fact * i ) % Mod ; } return power ( fact , Mod - 2 , Mod ) ; }
function nck ( N , K ) { var factN = factorial ( N ) ; var inv = Inversefactorial ( K ) ; var invFact = Inversefactorial ( N - K ) ; return ( ( ( factN * inv ) % Mod ) * invFact ) % Mod ; }
function checkEvenSum ( arr , N , size ) { var even_freq = 0 , odd_freq = 0 ; for ( var i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & 1 ) odd_freq ++ ; else even_freq ++ ; } if ( even_freq >= N ) return true ; else { if ( odd_freq & 1 ) { var taken = odd_freq - 1 ; var req = N - taken ; if ( even_freq < req ) { return false ; } else return true ; } else { var taken = odd_freq ; var req = N - taken ; if ( even_freq < req ) { return false ; } else return true ; } } return false ; }
function digitsOf ( num ) { return num . toString ( ) . length ; }
function count ( a , tn ) { let diff = Math . floor ( Math . pow ( 10 , digitsOf ( a ) ) ) ; return Math . floor ( ( tn - a ) / diff ) + 1 ; }
function countOfSubarray ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) arr [ i ] -- ; let pref = [ ] ; pref [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) pref [ i ] = pref [ i - 1 ] + arr [ i ] ; let mp = new Map ; let answer = 0 ; if ( mp [ 0 ] ) mp [ 0 ] ++ ; else mp [ 0 ] = 1 ; for ( let i = 0 ; i < N ; i ++ ) { if ( mp [ pref [ i ] ] ) { answer += mp [ pref [ i ] ] ; mp [ pref [ i ] ] ++ ; } } return answer ; }
function minOperations ( a , N ) { var num_of_ops1 , num_of_ops2 , sum ; num_of_ops1 = num_of_ops2 = sum = 0 ; for ( i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 0 && sum >= 0 ) { num_of_ops1 += ( 1 + Math . abs ( sum ) ) ; sum = - 1 ; } else if ( i % 2 == 1 && sum <= 0 ) { num_of_ops1 += ( 1 + Math . abs ( sum ) ) ; sum = 1 ; } } sum = 0 ; for ( i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 1 && sum >= 0 ) { num_of_ops2 += ( 1 + Math . abs ( sum ) ) ; sum = - 1 ; } else if ( i % 2 == 0 && sum <= 0 ) { num_of_ops2 += ( 1 + Math . abs ( sum ) ) ; sum = 1 ; } } return Math . min ( num_of_ops1 , num_of_ops2 ) ; }
function printSubset ( n , k ) { var answer = [ ] ; while ( n > 0 ) { var p = parseInt ( Math . log2 ( n ) ) ; answer . push ( Math . pow ( k , p ) ) ; n %= parseInt ( Math . pow ( 2 , p ) ) ; } answer . sort ( ) ; for ( var i = 0 ; i < answer . length ; i ++ ) { document . write ( answer [ i ] + "▁" ) ; } }
function printsubset ( n , k ) { let count = 0 , x = 0 ; let vec = [ ] ; while ( n != 0 ) { x = n & 1 ; if ( x != 0 ) { vec . push ( Math . pow ( k , count ) ) ; } n = n >> 1 ; count ++ ; } for ( let i = 0 ; i < vec . length ; i ++ ) document . write ( vec [ i ] + "▁" ) ; }
function checkEquall ( arr , N ) { let sumEven = 0 , sumOdd = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( i % 2 == 1 ) sumOdd += arr [ i ] ; else sumEven += arr [ i ] ; } if ( sumEven == sumOdd ) return true ; else return false ; }
function isSumOfPower ( n ) { let isSum = Array ( n + 1 ) . fill ( 0 ) ; let perfectPowers = [ ] ; perfectPowers . push ( 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { isSum [ i ] = false ; } for ( let i = 2 ; i < ( n + 1 ) ; i ++ ) { if ( isSum [ i ] == true ) { perfectPowers . push ( i ) ; continue ; } for ( let j = i * i ; j > 0 && j < ( n + 1 ) ; j *= i ) { isSum [ j ] = true ; } } for ( let i = 0 ; i < perfectPowers . length ; i ++ ) { isSum [ perfectPowers [ i ] ] = false ; } for ( let i = 0 ; i < perfectPowers . length ; i ++ ) { for ( let j = i ; j < perfectPowers . length ; j ++ ) { let sum = perfectPowers [ i ] + perfectPowers [ j ] ; if ( sum < ( n + 1 ) ) isSum [ sum ] = true ; } } return isSum [ n ] ; }
function countEvenSum ( low , high , k ) { let even_count = high / 2 - ( low - 1 ) / 2 ; let odd_count = ( high + 1 ) / 2 - low / 2 ; let even_sum = 1 ; let odd_sum = 0 ; for ( let i = 0 ; i < k ; i ++ ) { let prev_even = even_sum ; let prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } document . write ( even_sum ) ; }
function update ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { arr [ i ] += ( i + 1 ) ; } }
function incrementCount ( arr , N ) { let min = 0 ; while ( check ( arr , N ) != true ) { update ( arr , N ) ; min ++ ; } document . write ( min ) ; }
function incrementCount ( arr , N ) { let mini = arr [ 0 ] - arr [ 1 ] ; for ( let i = 2 ; i < N ; i ++ ) { mini = Math . min ( mini , arr [ i - 1 ] - arr [ i ] ) ; } document . write ( mini ) ; }
function Length_Diagonals ( a , theta ) { let p = a * Math . sqrt ( 2 + ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; let q = a * Math . sqrt ( 2 - ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; return [ p , q ] ; }
function solve ( s , x , y ) { let res = 0 ; for ( let c of s ) { if ( c - "0" == x ) { res ++ ; x = x + y ; y = x - y ; x = x - y ; } } if ( x != y && res % 2 == 1 ) -- res ; return res ; }
function find_min ( s ) { let count = 0 ; for ( let i = 0 ; i < 10 ; i ++ ) { for ( let j = 0 ; j < 10 ; j ++ ) { count = Math . max ( count , solve ( s , i , j ) ) ; } } return count ; }
function maxORminusXOR ( N ) { let MSB = Math . ceil ( Math . log ( N ) ) ; let M = 0 ; for ( let i = 0 ; i <= MSB ; i ++ ) M += ( 1 << i ) ; return M ; }
function No_of_Triangle ( N , K ) { if ( N < K ) return - 1 ; else { let Tri_up = 0 ; Tri_up = Math . floor ( ( ( N - K + 1 ) * ( N - K + 2 ) ) / 2 ) ; let Tri_down = 0 ; Tri_down = Math . floor ( ( ( N - 2 * K + 1 ) * ( N - 2 * K + 2 ) ) / 2 ) ; return Tri_up + Tri_down ; } }
function AddEdge ( u , v ) { adj [ u ] . push ( v ) ; adj [ v ] . push ( u ) ; }
function Matching_dfs ( u , p ) { for ( let i = 0 ; i < adj [ u ] . length ; i ++ ) { if ( adj [ u ] [ i ] != p ) { Matching_dfs ( adj [ u ] [ i ] , u ) ; } } if ( used [ u ] == 0 && used [ p ] == 0 && p != 0 ) { max_matching ++ ; used [ u ] = used [ p ] = 1 ; } }
function canMake ( n , ar ) { if ( n == 1 ) return true ; else { if ( ar [ 0 ] < ar [ 1 ] ) { let i = 1 ; while ( i < n && ar [ i - 1 ] < ar [ i ] ) { i ++ ; } while ( i + 1 < n && ar [ i ] > ar [ i + 1 ] ) { i ++ ; } if ( i >= n - 1 ) return true ; else return false ; } else if ( ar [ 0 ] > ar [ 1 ] ) { let i = 1 ; while ( i < n && ar [ i - 1 ] > ar [ i ] ) { i ++ ; } while ( i + 1 < n && ar [ i ] < ar [ i + 1 ] ) { i ++ ; } if ( i >= n - 1 ) return true ; else return false ; } else { for ( let i = 2 ; i < n ; i ++ ) { if ( ar [ i - 1 ] <= ar [ i ] ) return false ; } return true ; } } }
function check_length ( n ) { let ans = 0 ; while ( n != 0 ) { n = n >> 1 ; ans ++ ; } return ans ; }
function check_ith_bit ( n , i ) { return ( n & ( 1 << ( i - 1 ) ) ) != 0 ? true : false ; }
function findPair ( A , B , N ) { var X , Y ; X = N - B + A ; if ( X % 2 != 0 ) { document . write ( "-1" ) ; } else { X = X / 2 ; Y = N - X ; document . write ( X + "▁" + Y ) ; } }
function countSetBitsUtil ( x ) { if ( x <= 0 ) return 0 ; return ( ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( parseInt ( x / 2 ) ) ) ; }
function countSetBits ( L , R ) { var bitCount = 0 ; for ( var i = L ; i <= R ; i ++ ) { bitCount += countSetBitsUtil ( i ) ; } return bitCount ; }
function countSetBit ( n ) { var i = 0 ; var ans = 0 ; while ( ( 1 << i ) <= n ) { var k = 0 ; var change = 1 << i ; for ( var j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
function countSetBits ( L , R ) { return Math . abs ( countSetBit ( R ) - countSetBit ( L - 1 ) ) ; }
function countSetBits ( L , R ) { let count = 0 ; for ( let i = L ; i <= R ; i ++ ) { let n = i ; while ( n > 0 ) { count += ( n & 1 ) ; n = n >> 1 ; } } return count ; }
function countElement ( A , N , B , M , K ) { let cnt = 0 ; for ( let i = 0 ; i < M ; i ++ ) { let currentElement = B [ i ] ; for ( let j = 0 ; j < N ; j ++ ) { let diff = Math . abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } document . write ( cnt ) ; }
function AreaofRectangle ( L , W ) { var area = parseFloat ( ( ( W + L ) * ( W + L ) ) / 2 ) . toFixed ( 1 ) ; return area ; }
function downToZero ( n ) { if ( n <= 3 ) return n ; let dp = new Array ( n + 1 ) dp . fill ( - 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; let sqr ; for ( let i = 4 ; i <= n ; i ++ ) { sqr = Math . sqrt ( i ) ; let best = Number . MAX_VALUE ; while ( sqr > 1 ) { if ( i % sqr == 0 ) { best = Math . min ( best , 1 + dp [ sqr ] ) ; } sqr -- ; } best = Math . min ( best , 1 + dp [ i - 1 ] ) ; dp [ i ] = best ; } return dp [ n ] ; }
function downToZero ( n ) { if ( n <= 3 ) return n ; return n % 2 == 0 ? 3 : 4 ; }
function maxSubset ( A , flag ) { let n = A . length ; let sum = 0 ; if ( flag ) { for ( let i = 1 ; i < n ; i ++ ) A [ i ] = - A [ i ] ; } for ( let i = 1 ; i < n ; i ++ ) { if ( A [ i ] > 0 ) { sum += A [ i ] ; } } return sum ; }
function findBest ( A ) { let x = maxSubset ( A , false ) ; let y = maxSubset ( A , true ) ; y = - y ; y += A [ 0 ] ; y = - y ; return Math . max ( x , y ) ; }
function getMinCost ( A , B , N ) { let mini = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { mini = Math . min ( mini , Math . min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; }
function countSwaps ( A , n ) { A . sort ( ) ; let ind = 1 , res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( ind < n && A [ ind ] == A [ i ] ) ind ++ ; if ( ind < n && A [ ind ] > A [ i ] ) { res ++ ; ind ++ ; } if ( ind >= n ) break ; } return res ; }
function countSwaps ( A , n ) { var mp = new Map ( ) ; var max_frequency = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( mp . has ( A [ i ] ) ) mp . set ( A [ i ] , mp . get ( A [ i ] ) + 1 ) else mp . set ( A [ i ] , 1 ) ; max_frequency = Math . max ( max_frequency , mp . get ( A [ i ] ) ) ; } return n - max_frequency ; }
function min_operation ( a , n ) { var ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( i > 0 ) ans += Math . abs ( a [ i ] - a [ i - 1 ] ) ; else ans += Math . abs ( a [ i ] ) ; } return ans ; }
function minimumrequired ( A , N ) { let K = N ; let ans ; while ( K > 0 ) { if ( K % 2 == 1 ) { ans = K ; break ; } let ispalindrome = true ; for ( let i = 0 ; i < parseInt ( K / 2 , 10 ) ; i ++ ) { if ( A [ i ] != A [ K - 1 - i ] ) ispalindrome = false ; } if ( ispalindrome ) { ans = parseInt ( K / 2 , 10 ) ; K = parseInt ( K / 2 , 10 ) ; } else { ans = K ; break ; } } return ans ; }
function count ( n , k ) { let count = Math . pow ( 10 , k ) - Math . pow ( 10 , k - 1 ) ; document . write ( count ) ; }
function maxSelections ( A , n , k ) { A . sort ( ) ; let sum = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + A [ i ] ; if ( sum > k ) { break ; } count ++ ; } return count ; }
function getMaxDifference ( N ) { var M = - 1 ; var maxDiff = 0 ; for ( i = 0 ; i < N ; i ++ ) { var diff = ( N ^ i ) - ( N & i ) ; if ( diff >= maxDiff ) { maxDiff = diff ; M = i ; } } return M ; }
function findM ( N ) { var M = 0 ; var MSB = parseInt ( Math . log ( N ) ) ; for ( i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) M += ( 1 << i ) ; } return M ; }
function func ( N , P ) { let sumUptoN = ( N * ( N + 1 ) / 2 ) ; let sumOfMultiplesOfP ; if ( N < P ) { return sumUptoN ; } else if ( ( N / P ) == 1 ) { return sumUptoN - P + 1 ; } sumOfMultiplesOfP = ( ( N / P ) * ( 2 * P + ( N / P - 1 ) * P ) ) / 2 ; return ( sumUptoN + func ( N / P , P ) - sumOfMultiplesOfP ) ; }
function countStrings ( A , B , K ) { let X = Math . floor ( ( A + B ) / ( K + 1 ) ) ; return ( Math . min ( A , Math . min ( B , X ) ) * ( K + 1 ) ) ; }
function countPairs ( a , n , k ) { let len = Array . from ( { length : n } , ( _ , i ) => 0 ) ; let p = Array . from ( { length : 11 } , ( _ , i ) => 0 ) ; p [ 0 ] = 1 ; for ( let i = 1 ; i <= 10 ; i ++ ) { p [ i ] = ( p [ i - 1 ] * 10 ) % k ; } for ( let i = 0 ; i < n ; i ++ ) { let x = a [ i ] ; while ( x > 0 ) { len [ i ] ++ ; x = Math . floor ( x / 10 ) ; } rem [ len [ i ] ] [ a [ i ] % k ] ++ ; } let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 1 ; j <= 10 ; j ++ ) { let r = ( a [ i ] * p [ j ] ) % k ; let xr = ( k - r ) % k ; ans += rem [ j ] [ xr ] ; if ( len [ i ] == j && ( r + a [ i ] % k ) % k == 0 ) ans -- ; } } return ans ; }
function isDivisible ( N ) { return ( N - 1 ) % 3 != 0 ; }
function maxLengthSubArray ( A , N ) { let forward = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let backward = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( i == 0 A [ i ] != A [ i - 1 ] ) { forward [ i ] = 1 ; } else forward [ i ] = forward [ i - 1 ] + 1 ; } for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 A [ i ] != A [ i + 1 ] ) { backward [ i ] = 1 ; } else backward [ i ] = backward [ i + 1 ] + 1 ; } let ans = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) ans = Math . max ( ans , Math . min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; } document . write ( ans ) ; }
function countDigitSum ( N , K ) { let l = parseInt ( Math . pow ( 10 , N - 1 ) ) , r = parseInt ( Math . pow ( 10 , N ) - 1 ) ; let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { let num = i ; let digits = new Array ( N ) ; for ( let j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num = parseInt ( num / 10 ) ; } let sum = 0 , flag = 0 ; for ( let j = 0 ; j < K ; j ++ ) sum += digits [ j ] ; for ( let j = 1 ; j < N - K + 1 ; j ++ ) { let curr_sum = 0 ; for ( let m = j ; m < j + K ; m ++ ) curr_sum += digits [ m ] ; if ( sum != curr_sum ) { flag = 1 ; break ; } } if ( flag == 0 ) { count ++ ; } } return count ; }
function countDigitSum ( N , K ) { var l = parseInt ( Math . pow ( 10 , N - 1 ) ) , var r = parseInt ( Math . pow ( 10 , N ) - 1 ) ; var count = 0 ; for ( i = l ; i <= r ; i ++ ) { var num = i ; var digits = Array ( N ) . fill ( 0 ) ; for ( j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num = parseInt ( num / 10 ) ; } var sum = 0 , flag = 0 ; for ( j = 0 ; j < K ; j ++ ) sum += digits [ j ] ; for ( j = K ; j < N ; j ++ ) { if ( sum - digits [ j - K ] + digits [ j ] != sum ) { flag = 1 ; break ; } } if ( flag == 0 ) { count ++ ; } } return count ; }
function nth_angle ( N , a , b , n ) { let nth = 0 ; nth = a + ( n - 1 ) * b ; return nth ; }
function findTriplet ( arr ) { var n = arr . length ; var st = [ ] ; var h3 = - 1000000000 , h1 = 1000000000 ; for ( var i = n - 1 ; i >= 0 ; i -- ) { h1 = arr [ i ] ; while ( st . length != 0 && st [ st . length - 1 ] < arr [ i ] ) { h3 = st [ st . length - 1 ] ; st . pop ( ) ; } st . push ( arr [ i ] ) ; if ( h1 < h3 ) { return true ; } } return false ; }
function findWays ( arr , i , n ) { if ( n == 0 ) printVector ( arr ) ; for ( var j = i ; j <= n ; j ++ ) { arr . push ( j ) ; findWays ( arr , j , n - j ) ; arr . pop ( ) ; } }
function distinctNumbers ( arr , m , n ) { var count = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) if ( count . has ( arr [ i ] ) ) count . set ( arr [ i ] , count . get ( arr [ i ] ) + 1 ) else count . set ( arr [ i ] , 1 )  var fre_arr = Array ( n + 1 ) . fill ( 0 ) ; count . forEach ( ( value , key ) => { fre_arr [ value ] ++ ; } ) ; var ans = count . size ; for ( var i = 1 ; i <= n ; i ++ ) { var temp = fre_arr [ i ] ; if ( temp == 0 ) continue ; var t = Math . min ( temp , parseInt ( m / i ) ) ; ans -= t ; m -= i * t ; } return ans ; }
function no_of_moves ( Matrix , x , y ) { let moves = 0 ; for ( let i = 0 ; i < M ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { if ( Matrix [ i ] [ j ] != 0 ) { moves += Math . abs ( x - i ) ; moves += Math . abs ( y - j ) ; } } } document . write ( moves ) ; }
function is_linear ( s ) { let tmp = 0 ; let first = s [ 0 ] ; for ( let pos = 0 ; pos < s . length ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } tmp ++ ; } return true ; }
function DFS ( U , vis , adj ) { vis [ U ] = 1 ; for ( var V of adj [ U ] ) { if ( vis [ V ] == 0 ) DFS ( V , vis , adj ) ; } }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function find_gcd ( arr ) { if ( arr . length == 1 ) return arr [ 0 ] ; let g = arr [ 0 ] ; for ( let i = 1 ; i < arr . length ; i ++ ) { g = gcd ( g , arr [ 1 ] ) ; } return g ; }
function maxm_gcd ( root , ans ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { ans . push ( root . val ) ; maxm = Math . max ( find_gcd ( ans ) , maxm ) ; return ; } ans . push ( root . val ) ; maxm_gcd ( root . left , ans ) ; maxm_gcd ( root . right , ans ) ; }
function checkInfinite ( s ) { var flag = 1 ; var N = s . length ; for ( var i = 0 ; i < N - 1 ; i ++ ) { if ( s [ i ] == String . fromCharCode ( ( s [ i + 1 ] . charCodeAt ( 0 ) ) + 1 ) ) { continue ; } else if ( s [ i ] == "a" && s [ i + 1 ] == "z" ) { continue ; } else { flag = 0 ; break ; } } if ( flag == 0 ) document . write ( "NO" ) ; else document . write ( "YES" ) ; }
function calculateWays ( arr1 , arr2 , N ) { let A = arr2 [ 0 ] , B = arr2 [ 1 ] ; let C = arr2 [ 2 ] , D = arr2 [ 3 ] ; let ans = 0 ; for ( let b = 0 ; b <= B && b * 5 <= ( N ) ; b ++ ) for ( let c = 0 ; c <= C && b * 5 + c * 10 <= ( N ) ; c ++ ) for ( let d = 0 ; d <= D && b * 5 + c * 10 + d * 20 <= ( N ) ; d ++ ) if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) ans ++ ; return ans ; }
function calculateWays ( arr1 , arr2 , N ) { var A = arr2 [ 0 ] , B = arr2 [ 1 ] ; var C = arr2 [ 2 ] , D = arr2 [ 3 ] ; var ans = 0 ; for ( var b = 0 ; b <= B && b * 5 <= N ; b ++ ) { for ( var a = 0 ; a <= A && a * 1 + b * 5 <= N ; a ++ ) { ways [ a + b * 5 ] ++ ; } } for ( var c = 0 ; c <= C && c * 10 <= ( N ) ; c ++ ) { for ( var d = 0 ; d <= D && c * 10 + d * 20 <= ( N ) ; d ++ ) { ans += ways [ N - c * 10 - d * 20 ] ; } } return ans ; }
function removeAll ( arr , n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) document . write ( "YES" ) ; else document . write ( "NO" ) ; }
function minNum ( n ) { if ( n < 3 ) document . write ( - 1 ) ; else document . write ( ( 210 * ( parseInt ( Math . pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ) ; }
function findMinimum ( s ) { var n = s . length ; var x = Array ( n + 1 ) . fill ( 0 ) ; s . reverse ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == "1" ) { if ( x [ i ] == 1 ) { x [ i + 1 ] = 1 ; x [ i ] = 0 ; } else if ( i && x [ i - 1 ] == 1 ) { x [ i + 1 ] = 1 ; x [ i - 1 ] = - 1 ; } else x [ i ] = 1 ; } } var c = 0 ; for ( var i = 0 ; i <= n ; i ++ ) { if ( x [ i ] != 0 ) c ++ ; } document . write ( c ) ; }
function splitIntoFibonacci ( S ) { let seq = [ ] ; splitIntoFibonacciHelper ( 0 , S , seq ) ; if ( seq . length >= 3 ) { for ( let i = 0 ; i < seq . length ; i ++ ) document . write ( seq [ i ] + "▁" ) ; } else { document . write ( "-1" ) ; } }
function countChanges ( matrix , n , m ) { var dist = n + m - 1 ; var freq = Array . from ( Array ( dist ) , ( ) => Array ( 10 ) ) ; for ( var i = 0 ; i < dist ; i ++ ) { for ( var j = 0 ; j < 10 ; j ++ ) freq [ i ] [ j ] = 0 ; } for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < m ; j ++ ) { freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } var min_changes_sum = 0 ; for ( var i = 0 ; i < parseInt ( dist / 2 ) ; i ++ ) { var maximum = 0 ; var total_values = 0 ; for ( var j = 0 ; j < 10 ; j ++ ) { maximum = Math . max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; } min_changes_sum += ( total_values - maximum ) ; } return min_changes_sum ; }
function numberOfPairs ( n ) { if ( n % 2 == 0 ) return ( n / 2 - 1 ) ; else return ( n / 2 ) ; }
function good_pair ( str , N ) { let countStr = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { let res = str [ i ] + str [ j ] ; let vowel = new Array ( 5 ) ; vowel . fill ( 0 ) ; for ( let k = 0 ; k < res . length ; k ++ ) { if ( res [ k ] == "a" ) vowel [ 0 ] = 1 ; else if ( res [ k ] == "e" ) vowel [ 1 ] = 1 ; else if ( res [ k ] == "i" ) vowel [ 2 ] = 1 ; else if ( res [ k ] == "o" ) vowel [ 3 ] = 1 ; else if ( res [ k ] == "u" ) vowel [ 4 ] = 1 ; } let temp = 0 ; for ( let ind = 0 ; ind < 5 ; ind ++ ) { if ( vowel [ ind ] == 1 ) temp ++ ; } if ( temp == 5 ) countStr ++ ; } } return countStr ; }
function sieveOfEratosthenes ( N , s ) { let prime = Array . from ( { length : N + 1 } , ( _ , i ) => 0 ) ; for ( let i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( let i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( let j = i ; j * i <= N ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
function generatePrimeFactors ( N ) { let s = Array . from ( { length : N + 1 } , ( _ , i ) => 0 ) ; let sum = 0 ; sieveOfEratosthenes ( N , s ) ; let curr = s [ N ] ; let cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } sum = sum + cnt ; curr = s [ N ] ; cnt = 1 ; } return sum ; }
function LCM ( a , b ) { let lcm = a > b ? a : b ; while ( true ) { if ( lcm % a == 0 && lcm % b == 0 ) break ; else lcm ++ ; } return lcm ; }
function countSubstrings ( s ) { var n = s . length ; var answer = ( n * ( n - 1 ) ) / 2 ; var cnt = 1 ; var v = [ ] ; for ( var i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) cnt ++ ; else { v . push ( cnt ) ; cnt = 1 ; } } if ( cnt > 0 ) v . push ( cnt ) ; for ( var i = 0 ; i < v . length - 1 ; i ++ ) { answer -= ( v [ i ] + v [ i + 1 ] - 1 ) ; } return answer ; }
function find_max ( n , k ) { var X = Array . from ( { length : 32 } , ( _ , i ) => 0 ) ; var cnt = 0 ; for ( i = 31 ; i >= 0 && cnt != k ; i -- ) { if ( ( n & ( 1 << i ) ) != 0 ) { X [ i ] = 1 ; cnt ++ ; } } var s = "" ; for ( i = 31 ; i >= 0 ; i -- ) s += X [ i ] == 0 ? "0" : "1" ; return parseInt ( s , 2 ) ; }
function get_palindrome_time ( str ) { let hh , mm ; hh = ( str [ 0 ] . charCodeAt ( ) - 48 ) * 10 + ( str [ 1 ] . charCodeAt ( ) - 48 ) ; mm = ( str [ 3 ] . charCodeAt ( ) - 48 ) * 10 + ( str [ 4 ] . charCodeAt ( ) - 48 ) ; let requiredTime = 0 ; while ( hh % 10 != Math . floor ( mm / 10 ) || Math . floor ( hh / 10 ) != mm % 10 ) { ++ mm ; if ( mm == 60 ) { mm = 0 ; ++ hh ; } if ( hh == 24 ) hh = 0 ; ++ requiredTime ; } return requiredTime ; }
function maximumSubarraySum ( a , n , subarrays ) { let i , maxsum = 0 ; let prefixArray = new Array ( n ) ; prefixArray . fill ( 0 ) ; for ( i = 0 ; i < subarrays . length ; ++ i ) { prefixArray [ subarrays [ i ] [ 0 ] - 1 ] ++ ; prefixArray [ subarrays [ i ] [ 1 ] ] -- ; } for ( i = 1 ; i < n ; i ++ ) { prefixArray [ i ] += prefixArray [ i - 1 ] ; } prefixArray . sort ( ) ; a . sort ( ) ; for ( i = 0 ; i < n ; i ++ ) maxsum += a [ i ] * prefixArray [ i ] ; return maxsum ; }
function maxProfit ( value , N , K ) { value . sort ( ) ; let maxval = value [ N - 1 ] ; let maxProfit = 0 ; let curr_val ; do { curr_val = 0 ; for ( let i = 0 ; i < N ; i ++ ) { curr_val += value [ i ] ; if ( curr_val <= K ) { maxProfit = Math . max ( curr_val + maxval * ( i + 1 ) , maxProfit ) ; } } } while ( next_permutation ( value ) ) ; return maxProfit ; }
function findways ( s , x ) { if ( x > s . length ) return 0 ; var n = s . length ; var freq = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; ++ i ) freq [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; var se = [ ] ; for ( var i = 0 ; i < 26 ; ++ i ) if ( freq [ i ] > 0 ) se . push ( freq [ i ] ) ; var ans = 1 ; for ( var i = 0 ; i < x / 2 ; ++ i ) { var count = 0 ; se . forEach ( u => { if ( u >= 2 ) count ++ ; } ) ; if ( count == 0 ) return 0 ; else ans = ans * count ; se . sort ( ( a , b ) => a - b )  var val = se [ se . length - 1 ] se . pop ( ) ; if ( val > 2 ) se . push ( val - 2 ) ; } if ( x % 2 != 0 ) { var count = 0 ; se . forEach ( u => { if ( u > 0 ) count ++ ; } ) ; ans = ans * count ; } return ans ; }
function checkUniqueFrequency ( arr , n ) { let freq = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq . has ( arr [ i ] ) ) { freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . set ( arr [ i ] , 1 ) ; } } let uniqueFreq = new Set ( ) ; for ( let [ key , value ] of freq . entries ( ) ) { if ( uniqueFreq . has ( value ) ) return false ; else uniqueFreq . add ( value ) ; } return true ; }
function specialSum ( n ) { let sum = n * ( n + 1 ) / 2 ; let a = Log2 ( n ) ; sum = sum + power ( 2 , a + 1 ) - 1 ; return sum ; }
function findMin ( x , Y ) { let y = Y . toString ( ) ; let n = y . length ; let p = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { p . push ( 0 ) ; } for ( let i = 0 ; i < n ; i ++ ) { p [ i ] = y [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ; if ( i > 0 ) { p [ i ] = p [ i ] + p [ i - 1 ] ; } } for ( let i = n - 1 , k = 0 ; ; i -- , k ++ ) { let d = 0 ; if ( i >= 0 ) { d = y [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ; } for ( let j = d + 1 ; j <= 9 ; j ++ ) { let r = j ; if ( i > 0 ) { r += p [ i - 1 ] ; } if ( x - r >= 0 && x - r <= 9 * k ) { let suf = helper ( k , x - r ) ; let pre = "" ; if ( i > 0 ) pre = y . substring ( 0 , i ) ; let cur = String . fromCharCode ( j + "0" . charCodeAt ( 0 ) ) ; pre += cur ; return pre + suf ; } } } }
function largestNumber ( n , X , Y ) { let maxm = Math . max ( X , Y ) ; Y = X + Y - maxm ; X = maxm ; let Xs = 0 ; let Ys = 0 ; while ( n > 0 ) { if ( n % Y == 0 ) { Xs += n ; n = 0 ; } else { n -= X ; Ys += X ; } } if ( n == 0 ) { while ( Xs -- > 0 ) document . write ( X ) ; while ( Ys -- > 0 ) document . write ( Y ) ; } else document . write ( "-1" ) ; }
function check ( unit_digit , X ) { let times , digit ; for ( times = 1 ; times <= 10 ; times ++ ) { digit = ( X * times ) % 10 ; if ( digit == unit_digit ) return times ; } return - 1 ; }
function getNum ( N , X ) { let unit_digit ; unit_digit = N % 10 ; let times = check ( unit_digit , X ) ; if ( times == - 1 ) return times ; else { if ( N >= ( times * X ) ) return times ; else return - 1 ; } }
function dfs ( g , cost , u , pre ) { vis [ u ] = true ; dp [ u ] = cost [ u ] ; var check = true ; var cur = cost [ u ] ; for ( var x of g [ u ] ) { if ( vis [ x ] && x != pre ) { check = false ; } else if ( ! vis [ x ] ) { check = dfs ( g , cost , x , u ) ? false : true ; cur = Math . max ( cur , cost [ u ] + dp [ x ] ) ; } } dp [ u ] = cur ; if ( ! check ) { canTake += cost [ u ] ; } else { best = Math . max ( best , dp [ u ] ) ; } return check ; }
function FindMaxCost ( g , cost , source ) { dfs ( g , cost , source , - 1 ) ; document . write ( canTake + best ) ; }
function after_rev ( v ) { var mini = 0 , count = 0 ; for ( var i = 0 ; i < v . length ; i ++ ) { count += v [ i ] ; if ( count > 0 ) count = 0 ; if ( mini > count ) mini = count ; } return mini ; }
function moduloEquality ( A , B , n , m ) { var mapA = new Map ( ) , mapB = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( mapA . has ( A [ i ] ) ) mapA . set ( A [ i ] , mapA . get ( A [ i ] ) + 1 ) else mapA . set ( A [ i ] , 1 )  if ( mapB . has ( B [ i ] ) ) mapB . set ( B [ i ] , mapB . get ( B [ i ] ) + 1 ) else mapB . set ( B [ i ] , 1 ) } var possibleValues = new Set ( ) ; var FirstElement = B [ 0 ] ; for ( var i = 0 ; i < n ; i ++ ) { var cur = A [ i ] ; possibleValues . add ( cur > FirstElement ? m - cur + FirstElement : FirstElement - cur ) ; } var ans = 1000000000 ; possibleValues . forEach ( it => { var possible = true ; mapA . forEach ( ( value , key ) => { if ( value != mapB . get ( ( key + it ) % m ) ) { possible = false ; } } ) ; if ( possible ) { ans = Math . min ( ans , it ) ; } } ) ; return ans ; }
function countCyclicShifts ( S , n ) { let aux = [ ] ; for ( let i = 0 ; i < n ; ++ i ) { if ( S [ i ] == "(" ) aux [ i ] = 1 ; else aux [ i ] = - 1 ; } let mn = aux [ 0 ] ; for ( let i = 1 ; i < n ; ++ i ) { aux [ i ] += aux [ i - 1 ] ; mn = Math . min ( mn , aux [ i ] ) ; } if ( aux [ n - 1 ] != 0 ) return 0 ; let count = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( aux [ i ] == mn ) count ++ ; } return count ; }
function count ( k , s ) { var ar = Array ( s . length ) . fill ( 0 ) ; var end = 0 ; var i , j ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == "1" ) { for ( j = i ; j < s . length && j <= i + k ; j ++ ) { ar [ j ] = - 1 ; end = j ; } i = end ; } } end = 0 ; for ( i = s . length - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == "1" ) { for ( j = i ; j >= 0 && j >= i - k ; j -- ) { ar [ j ] = - 1 ; end = j ; } i = end ; } } var ans = 0 ; end = 0 ; var g ; for ( j = 0 ; j < s . length ; j ++ ) { if ( ar [ j ] == 0 ) { ans ++ ; for ( g = j ; g <= j + k && g < s . length ; g ++ ) { ar [ g ] = - 1 ; end = g ; } j = end - 1 ; } } return ans ; }
function find_set ( a ) { if ( parent [ a ] == a ) return a ; return parent [ a ] = find_set ( parent [ a ] ) ; }
function union_set ( a , b ) { let x = find_set ( a ) , y = find_set ( b ) ; if ( x == y ) return ; if ( rnk [ x ] == rnk [ y ] ) rnk [ x ] ++ ; if ( rnk [ y ] > rnk [ x ] ) swap ( x , y ) ; parent [ y ] = x ; }
function dfsBridges ( a , par ) { vis [ a ] = true ; In [ a ] = low [ a ] = timer ++ ; for ( let i = 0 ; i < v [ a ] . length ; i ++ ) { if ( v [ a ] [ i ] == par ) continue ; if ( vis [ v [ a ] [ i ] ] ) low [ a ] = Math . min ( low [ a ] , In [ v [ a ] [ i ] ] ) ; else { dfsBridges ( v [ a ] [ i ] , a ) ; low [ a ] = Math . min ( low [ a ] , low [ v [ a ] [ i ] ] ) ; if ( In [ a ] < low [ v [ a ] [ i ] ] ) bridges . push ( [ v [ a ] [ i ] , a ] ) ; else union_set ( v [ a ] [ i ] , a ) ; } } }
function isPalindrome ( l , r , s ) { while ( l <= r ) { if ( s [ l ] != s [ r ] ) return false ; l ++ ; r -- ; } return true ; }
function numWays ( s ) { let n = s . length ; let ans = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( isPalindrome ( 0 , i , s ) && isPalindrome ( i + 1 , n - 1 , s ) ) { ans ++ ; } } return ans ; }
function maxProfit ( prices , n ) { let profit = 0 , currentDay = n - 1 ; while ( currentDay > 0 ) { let day = currentDay - 1 ; while ( day >= 0 && ( prices [ currentDay ] > prices [ day ] ) ) { profit += ( prices [ currentDay ] - prices [ day ] ) ; day -- ; } currentDay = day ; } return profit ; }
function numberofsubstrings ( str , k , charArray ) { var N = str . length ; var available = [ 26 ] ; for ( var i = 0 ; i < k ; i ++ ) { available [ charArray [ i ] - "a" ] = 1 ; } var lastPos = - 1 ; var ans = ( N * ( N + 1 ) ) / 2 ; for ( var i = 0 ; i < N ; i ++ ) { if ( available [ str . charAt ( i ) - "a" ] == 0 ) { ans -= ( ( i - lastPos ) * ( N - i ) ) ; lastPos = i ; } } document . write ( ans ) ; }
function isOddStringPalindrome ( str , n ) { var oddStringSize = parseInt ( n / 2 ) ; var lengthOdd = ( ( oddStringSize % 2 == 1 ) ? true : false ) ; var s = [ ] ; var i = 1 ; var c = 0 ; while ( i < n && c < parseInt ( oddStringSize / 2 ) ) { s . push ( str [ i ] ) ; i += 2 ; c ++ ; } if ( lengthOdd ) i = i + 2 ; while ( i < n && s . length > 0 ) { if ( s [ s . length - 1 ] == str [ i ] ) s . pop ( ) ; else break ; i = i + 2 ; } if ( s . length == 0 ) return true ; return false ; }
function isOddStringPalindrome ( str , n ) { var left , right ; if ( n % 2 == 0 ) { left = 1 ; right = n - 1 ; } else { left = 1 ; right = n - 2 ; } while ( left < n && right >= 0 && left < right ) { if ( str [ left ] != str [ right ] ) return false ; left += 2 ; right -= 2 ; } return true ; }
function min_remove ( str ) { let N = str . length ; let prefix_a = Array . from ( { length : N + 1 } , ( _ , i ) => 0 ) ; let prefix_b = Array . from ( { length : N + 1 } , ( _ , i ) => 0 ) ; let prefix_c = Array . from ( { length : N + 1 } , ( _ , i ) => 0 ) ; prefix_a [ 0 ] = 0 ; prefix_b [ 0 ] = 0 ; prefix_c [ 0 ] = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { prefix_a [ i ] = prefix_a [ i - 1 ] + ( ( str [ i - 1 ] == "a" ) ? 1 : 0 ) ; prefix_b [ i ] = prefix_b [ i - 1 ] + ( ( str [ i - 1 ] == "b" ) ? 1 : 0 ) ; prefix_c [ i ] = prefix_c [ i - 1 ] + ( ( str [ i - 1 ] == "c" ) ? 1 : 0 ) ; } let maxi = Number . MIN_VALUE ; for ( let i = 0 ; i <= N ; i ++ ) { for ( let j = i ; j <= N ; j ++ ) { maxi = Math . max ( maxi , ( prefix_a [ i ] + ( prefix_b [ j ] - prefix_b [ i ] ) + ( prefix_c [ N ] - prefix_c [ j ] ) ) ) ; } } document . write ( ( N - maxi ) ) ; }
function maximum_partition ( str ) { var i = 0 , j = 0 , k = 0 ; var c = 0 , r = 0 ; var m = new Map ( ) ; for ( i = str . length - 1 ; i >= 0 ; i -- ) { if ( ! m . has ( str [ i ] ) ) { m . set ( str [ i ] , i ) ; } } i = 0 ; k = m . get ( str [ i ] ) ; for ( i = 0 ; i < str . length ; i ++ ) { if ( i <= k ) { c = c + 1 ; k = Math . max ( k , m . get ( str [ i ] ) ) ; } else { r = r + 1 ; c = 1 ; k = Math . max ( k , m . get ( str [ i ] ) ) ; } } if ( c != 0 ) { r = r + 1 ; } return r ; }
function findAns ( mat , x , y , n , m ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { ans += Math . abs ( x - i ) + Math . abs ( y - j ) ; } } } return ans ; }
function solve ( P , n ) { let arr = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; arr [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) arr [ i + 1 ] = P [ i ] ; let cnt = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { let t = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ i ] ; arr [ i ] = t ; cnt ++ ; } } if ( arr [ n ] == n ) { let t = arr [ n - 1 ] ; arr [ n - 1 ] = arr [ n ] ; arr [ n ] = t ; cnt ++ ; } document . write ( cnt ) ; }
function longestSequence ( n , arr ) { var l = 0 , r = n - 1 ; var prev = - 1000000000 ; var ans = 0 ; while ( l <= r ) { if ( arr [ l ] > prev && arr [ r ] > prev ) { if ( arr [ l ] < arr [ r ] ) { ans += 1 ; prev = arr [ l ] ; l += 1 ; } else { ans += 1 ; prev = arr [ r ] ; r -= 1 ; } } else if ( arr [ l ] > prev ) { ans += 1 ; prev = arr [ l ] ; l += 1 ; } else if ( arr [ r ] > prev ) { ans += 1 ; prev = arr [ r ] ; r -= 1 ; } else { break ; } } return ans ; }
function solve ( n , m , x , y , d ) { let top = Math . min ( d , x - 1 ) ; let down = Math . min ( d , n - x ) ; let left = Math . min ( d , y - 1 ) ; let right = Math . min ( d , m - y ) ; let quad1 = top * left ; let quad2 = left * down ; let quad3 = down * right ; let quad4 = right * top ; let totalsq = quad1 + quad2 + quad3 + quad4 ; let singleBlocks = top + down + left + right + 1 ; return totalsq + singleBlocks ; }
function minchanges ( mat ) { var count = 0 ; var left = 0 , right = N + M - 2 ; while ( left < right ) { var mp = new Map ( ) ; var totalsize = 0 ; for ( var i = 0 ; i < N ; i ++ ) { for ( var j = 0 ; j < M ; j ++ ) { if ( i + j == left i + j == right ) { if ( mp . has ( mat [ i ] [ j ] ) ) mp . set ( mat [ i ] [ j ] , mp . get ( mat [ i ] [ j ] ) + 1 ) else mp . set ( mat [ i ] [ j ] , 1 ) totalsize ++ ; } } } var changes = 0 ; mp . forEach ( ( value , key ) => { changes = Math . max ( changes , value ) ; } ) ; count += totalsize - changes ; left ++ ; right -- ; } return count ; }
function CountLongestSubarrays ( arr , n , k ) { let i , s = 0 ; for ( i = 0 ; i < n ; ++ i ) { s += arr [ i ] ; } if ( ( s % k ) != 0 ) { return 1 ; } else { let ini = 0 ; while ( ini < n && arr [ ini ] % k == 0 ) { ++ ini ; } let fin = n - 1 ; while ( fin >= 0 && arr [ fin ] % k == 0 ) { -- fin ; } let len , sum = 0 , count = 0 ; if ( ini == n ) { return - 1 ; } else { len = Math . max ( n - 1 - ini , fin ) ; } for ( i = 0 ; i < len ; i ++ ) { sum += arr [ i ] ; } if ( sum % k != 0 ) { count ++ ; } for ( i = len ; i < n ; i ++ ) { sum = sum + arr [ i ] ; sum = sum - arr [ i - len ] ; if ( sum % k != 0 ) { count ++ ; } } return count ; } }
function nC3 ( n ) { if ( n < 3 ) return 0 ; return ( n * ( n - 1 ) * ( n - 2 ) ) / 6 ; }
function count_triplet ( arr , N , K ) { for ( var i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( var i = 1 ; i <= 1000000 ; i ++ ) { for ( var j = i ; j <= 1000000 ; j += i ) { mul [ i ] += freq [ j ] ; } cnt [ i ] = nC3 ( mul [ i ] ) ; } for ( var i = 1000000 ; i >= 1 ; i -- ) { for ( var j = 2 * i ; j <= 1000000 ; j += i ) { cnt [ i ] -= cnt [ j ] ; } } document . write ( "Number▁of▁triplets▁" + "with▁GCD▁" + K ) ; document . write ( "▁are▁" + cnt [ K ] ) ; }
function getMinJumps ( s ) { let ones = [ ] ; let jumps = 0 , median = 0 , ind = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == "1" ) ones . push ( i ) ; } if ( ones . length == 0 ) return jumps ; median = ones [ parseInt ( ones . length / 2 , 10 ) ] ; ind = median ; for ( let i = ind ; i >= 0 ; i -- ) { if ( s [ i ] == "1" ) { jumps += ind - i ; ind -- ; } } ind = median ; for ( let i = ind ; i < s . length ; i ++ ) { if ( s [ i ] == "1" ) { jumps += i - ind ; ind ++ ; } } return jumps ; }
function getSubsequence ( ar ) { let N = ar . length ; let ans = [ ] ; ans . push ( ar [ 0 ] ) ; for ( let i = 1 ; i < N - 1 ; i ++ ) { if ( ar [ i ] > ar [ i - 1 ] ) { if ( i < N - 1 && ar [ i ] <= ar [ i + 1 ] ) { continue ; } else { ans . push ( ar [ i ] ) ; } } else { if ( i < N - 1 && ar [ i + 1 ] < ar [ i ] ) { continue ; } else { ans . push ( ar [ i ] ) ; } } } ans . push ( ar [ N - 1 ] ) ; for ( let it = 0 ; it < ans . length ; it ++ ) document . write ( ans [ it ] + "▁" ) ; }
function isSubseqPossible ( arr , N , K ) { let i ; let odd = 0 , even = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 || ( even == 0 && K % 2 == 0 ) ) return false ; return true ; }
function print_path ( N , jump , coin ) { if ( jump > coin || jump * ( N - 1 ) < coin ) { document . write ( "-1" ) ; } else { let pos = 1 ; while ( jump > 0 ) { let tmp = Math . min ( N - 1 , coin - ( jump - 1 ) ) ; if ( pos + tmp <= N ) { pos += tmp ; } else { pos -= tmp ; } document . write ( pos + "▁" ) ; ; coin -= tmp ; jump -= 1 ; } } }
function countEvenOdd ( arr , n , K ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } let y ; y = __builtin_popcount ( K ) ; if ( ( y & 1 ) != 0 ) { document . write ( "Even▁=▁" + odd + ",▁Odd▁=▁" + even ) ; } else { document . write ( "Even▁=▁" + even + ",▁Odd▁=▁" + odd ) ; } }
function findMinHike ( arr , n ) { arr . unshift ( INF ) ; arr . push ( INF ) ; let hike = new Array ( n + 2 ) ; for ( let i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] && arr [ i ] <= arr [ i + 1 ] ) { hike [ i ] = 1 ; } } for ( let i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] <= arr [ i + 1 ] ) { hike [ i ] = hike [ i - 1 ] + 1 ; } } for ( let i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { hike [ i ] = hike [ i + 1 ] + 1 ; } } for ( let i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { hike [ i ] = Math . max ( hike [ i - 1 ] , hike [ i + 1 ] ) + 1 ; } } for ( let i = 1 ; i <= n ; i ++ ) { document . write ( hike [ i ] + "▁" ) ; } }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function preprocess ( ) { DFS ( 1 , - 1 ) ; }
function maximumSumSubarray ( arr , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 && ! mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , 1 ) ; } var first = 0 ; var last = 0 ; var ans = 0 ; var INF = 1000000 ; mp . forEach ( ( value , key ) => { var mx = key ; var curr = 0 ; var curr_start ; for ( var j = 0 ; j < n ; j ++ ) { if ( curr == 0 ) curr_start = j ; var val = arr [ j ] > mx ? - INF : arr [ j ] ; curr += val ; if ( curr < 0 ) curr = 0 ; if ( curr > ans ) { ans = curr ; first = curr_start ; last = j ; } } } ) ; document . write ( first + 1 + "▁" + ( last + 1 ) ) ; }
function make_xor_half ( arr ) { let sum = 0 , xr = 0 ; for ( let a = 0 ; a < arr . length ; a ++ ) { sum += arr [ a ] ; xr ^= arr [ a ] ; } if ( 2 * xr == sum ) return - 1 ; if ( xr == 0 ) { arr . push ( sum ) ; return 1 ; } arr . push ( xr ) ; arr . push ( sum + xr ) ; return 2 ; }
function makeZero ( x , y , a , b ) { if ( x > y ) { let temp = x ; x = y ; y = temp ; } let tot_cost = ( y - x ) * a ; let cost1 = 2 * x * a ; let cost2 = x * b ; tot_cost += Math . min ( cost1 , cost2 ) ; document . write ( tot_cost ) ; }
function splitFraction ( n , d ) { var ar = new Array ( n ) ; var first = d + n - 1 ; ar [ 0 ] = first ; for ( var i = 1 ; i < n ; i ++ ) { ar [ i ] = first * -- first ; } for ( var i = 0 ; i < n ; i ++ ) { if ( ar [ i ] % n === 0 ) { document . write ( "1/" + ar [ i ] / n + ",▁" ) ; } else { document . write ( n + "/" + ar [ i ] + ",▁" ) ; } } }
function numPairs ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) ans ++ ; } } return ans ; }
function minOperations ( s , len ) { var operationCnt = 0 ; var st = [ ] ; var cntClosing = 0 ; for ( var i = 0 ; i < len ; i ++ ) { if ( s [ i ] == "{" ) { if ( cntClosing > 0 ) { operationCnt ++ ; st . pop ( ) ; } st . push ( s [ i ] ) ; cntClosing = 0 ; } else if ( st . length == 0 ) { st . push ( "{" ) ; operationCnt ++ ; cntClosing = 1 ; } else { cntClosing = ( cntClosing + 1 ) % 2 ; if ( cntClosing == 0 ) { st . pop ( ) ; } } } operationCnt += st . length * 2 - cntClosing ; return operationCnt ; }
function longestSubsequence ( s ) { var n = s . length ; var answer = 0 ; var prev = "-" ; for ( var i = 0 ; i < n ; i ++ ) { if ( prev != s [ i ] ) { prev = s [ i ] ; answer ++ ; } } return answer ; }
function calculate ( pos , prev , s ) { if ( pos == s . length ) { return 0 ; } if ( dp [ pos ] [ prev ] != - 1 ) return dp [ pos ] [ prev ] ; let val = 0 ; if ( s [ pos ] . charCodeAt ( ) - "a" . charCodeAt ( ) + 1 != prev ) { val = Math . max ( val , 1 + calculate ( pos + 1 , s [ pos ] . charCodeAt ( ) - "a" . charCodeAt ( ) + 1 , s ) ) ; } val = Math . max ( val , calculate ( pos + 1 , prev , s ) ) ; dp [ pos ] [ prev ] = val ; return dp [ pos ] [ prev ] ; }
function longestSubsequence ( s ) { let n = s . length ; for ( let i = 0 ; i < 100005 ; i ++ ) { dp [ i ] = new Array ( 27 ) ; for ( let j = 0 ; j < 27 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return calculate ( 0 , 0 , s ) ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function MinDiff ( n ) { var val = parseInt ( Math . pow ( 2 , n ) ) ; var sep = n / 2 ; var grp1 = 0 ; var grp2 = 0 ; grp1 = grp1 + val ; for ( i = 1 ; i < sep ; i ++ ) grp1 = grp1 + parseInt ( Math . pow ( 2 , i ) ) ; for ( i = sep ; i < n ; i ++ ) grp2 = grp2 + parseInt ( Math . pow ( 2 , i ) ) ; document . write ( Math . abs ( grp1 - grp2 ) ) ; }
function minOccupiedPosition ( A , n ) { var minPos = 0 ; for ( var i = 0 ; i < n ; ++ i ) { if ( A [ i ] > 0 ) { ++ minPos ; i += 2 ; } } return minPos ; }
function missingnumber ( n , arr ) { let mn = 10000 ; let mx = - 10000 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == - 1 && arr [ i - 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i - 1 ] ) ; mx = Math . max ( mx , arr [ i - 1 ] ) ; } if ( i < ( n - 1 ) && arr [ i ] == - 1 && arr [ i + 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i + 1 ] ) ; mx = Math . max ( mx , arr [ i + 1 ] ) ; } } let res = ( mx + mn ) / 2 ; return res ; }
function Minsteps ( n ) { var ans = 0 ; while ( n > 1 ) { if ( n % 5 == 0 ) { ans ++ ; n = n / 5 ; continue ; } else if ( n % 4 == 0 ) { ans ++ ; n = n / 4 ; continue ; } else if ( n % 3 == 0 ) { ans ++ ; n = n / 3 ; continue ; } else if ( n % 2 == 0 ) { ans ++ ; n = n / 2 ; continue ; } return - 1 ; } return ans ; }
function countDist ( arr1 , n , arr2 , m , k ) { var count = 0 ; var smallest = arr2 [ 0 ] ; var largest = arr2 [ 0 ] ; for ( i = 0 ; i < m ; i ++ ) { smallest = Math . max ( smallest , arr2 [ i ] ) ; largest = Math . min ( largest , arr1 [ i ] ) ; } for ( i = 0 ; i < n ; i ++ ) { if ( Math . abs ( arr1 [ i ] - smallest ) > k || Math . abs ( arr1 [ i ] - largest ) > k ) count ++ ; } document . write ( count ) ; }
function palindromeWinner ( S ) { let freq = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { freq [ i ] = 0 ; } let count = 0 ; for ( let i = 0 ; i < S . length ; ++ i ) { if ( freq [ S [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] == 0 ) count ++ ; freq [ S [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } let unique = 0 ; let duplicate = 0 ; for ( let i = 0 ; i < 26 ; ++ i ) { if ( freq [ i ] == 1 ) unique ++ ; else if ( freq [ i ] >= 2 ) duplicate ++ ; } if ( unique == 1 && ( unique + duplicate ) == count ) return 1 ; return 2 ; }
function findMinimumK ( a , n , S ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return Math . ceil ( ( ( S + 1 ) * 1.0 ) / ( sum * 1.0 ) ) ; }
function MinimumValue ( a , n ) { let answer = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { answer = Math . min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) ; } } return answer ; }
function MinimumValue ( arr , n ) { arr . sort ( ) ; let minXor = Number . MAX_VALUE ; let val = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = Math . min ( minXor , val ) ; } return minXor ; }
function count_element ( N , K , arr ) { let mp = new Map ( ) ; for ( let i = 0 ; i < N ; ++ i ) if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) } else { mp . set ( arr [ i ] , 1 ) } let answer = 0 ; for ( let i of mp ) { if ( mp . has ( i [ 0 ] + K ) ) answer += i [ 1 ] ; } return answer ; }
function largestNum ( n ) { let num = 0 ; let max_setBits = 0 ; for ( let i = 0 ; i <= n ; i ++ ) { let setBits = countSetBits ( i ) ; if ( setBits >= max_setBits ) { num = i ; max_setBits = setBits ; } } return num ; }
function find_count ( n ) { let mpp = new Map ( ) ; for ( let i = 1 ; i <= n ; i ++ ) { let t = digit_xor ( i ) ; if ( mpp . has ( t ) ) { mpp . set ( t , mpp . get ( t ) + 1 ) } else { mpp . set ( t , 1 ) } } let maxm = 0 ; for ( let x of mpp ) { if ( x [ 1 ] > maxm ) maxm = x [ 1 ] ; } return maxm ; }
function findString ( N , K ) { for ( let i = 0 ; i < N ; i ++ ) { document . write ( String . fromCharCode ( "A" . charCodeAt ( ) + i % K ) ) ; } }
function digit_prod ( x ) { let prod = 1 ; while ( x != 0 ) { prod = prod * ( x % 10 ) ; x = Math . floor ( x / 10 ) ; } return prod ; }
function find_count ( n ) { let mpp = new Map ( ) ; for ( let i = 1 ; i <= n ; i ++ ) { let t = digit_prod ( i )  if ( mpp . has ( t ) ) { mpp . set ( t , mpp . get ( t ) + 1 ) } else { mpp . set ( t , 1 ) } } let ans = 1 ; let maxm = 0 ; for ( let x of mpp ) { if ( x [ 1 ] > maxm ) { maxm = x [ 1 ] ; ans = 1 ; } else if ( x [ 1 ] == maxm ) { ans ++ ; } } return ans ; }
function isPrime ( n ) { let i ; if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) { return false ; } for ( i = 5 ; i * i <= n ; i += 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
function findSubarraySum ( arr , n , K ) { let prevSum = new Map ( ) ; let res = 0 ; let currsum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == K ) { res ++ ; } if ( prevSum . has ( currsum - K ) ) res += ( prevSum . get ( currsum - K ) ) ; if ( prevSum . has ( currsum ) ) { prevSum . set ( currsum , prevSum . get ( currsum ) + 1 ) } else { prevSum . set ( currsum , 1 ) } } return res ; }
function countSubarray ( arr , n , K ) { for ( let i = 0 ; i < n ; i ++ ) { if ( isPrime ( arr [ i ] ) ) { arr [ i ] = 1 ; } else { arr [ i ] = 0 ; } } document . write ( findSubarraySum ( arr , n , K ) ) ; }
function find_maxm ( arr , n ) { let mpp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mpp . has ( arr [ i ] ) ) { mpp . set ( arr [ i ] , mpp . get ( arr [ i ] ) + 1 ) } else { mpp . set ( arr [ i ] , 1 ) } } let ans = 0 ; for ( let x of mpp ) { let value = x [ 0 ] ; let freq = x [ 1 ] ; if ( value == freq ) { ans ++ ; } } return ans ; }
function pow ( x , y ) { if ( y == 1 ) return x ; if ( y == 0 ) return 1 ; let temp = pow ( x , y / 2 ) ; temp *= temp ; if ( y % 2 == 1 ) temp *= x ; return temp ; }
function getLargestSum ( N ) { var max_sum = 0 ; for ( i = 1 ; i <= N ; i ++ ) { for ( j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = Math . max ( max_sum , i + j ) ; } } return max_sum ; }
function getLargestSum ( N ) { let max_sum = 0 ; for ( let i = 1 ; i * i <= N ; i ++ ) { for ( let j = i + 1 ; j * j <= N ; j ++ ) { let k = parseInt ( N / j , 10 ) ; let a = k * i ; let b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = Math . max ( max_sum , a + b ) ; } } return max_sum ; }
function findSum ( L , R ) { var arr = [ ] ; var i = 0 ; var x = 2 ; while ( i <= R ) { arr . push ( i + x ) ; if ( i + 1 <= R ) arr . push ( i + 1 + x ) ; x *= - 1 ; i += 2 ; } var sum = 0 ; for ( var i = L ; i <= R ; ++ i ) sum += arr [ i ] ; return sum ; }
function GetMinSubarrayLength ( a , n ) { var ans = Math . max ( a [ 0 ] , a [ n - 1 ] ) ; var lo = 0 , hi = n - 1 ; while ( lo < n && a [ lo ] % ans == 0 ) lo ++ ; while ( hi > lo && a [ hi ] % ans == 0 ) hi -- ; return ( hi - lo + 1 ) ; }
function count ( s ) { let N , i , cnt = 0 , ans = 0 ; N = s . length ; for ( i = 0 ; i < N ; i ++ ) { if ( s [ i ] == "R" ) cnt ++ ; if ( s [ i ] == "L" ) ans += cnt ; } return ans ; }
function maxSubArraySum ( a , size ) { var max_so_far = Number . MIN_VALUE , max_ending_here = 0 ; for ( i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; }
function minimumValue ( arr , n , k ) { arr . sort ( ( a , b ) => a - b ) ; let answer = 0 ; for ( let i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; }
function sumOfDigits ( n ) { let s = n . toString ( ) ; let sum = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { sum += ( s [ i ] - "0" ) ; } return sum ; }
function height ( s , adj , visited ) { visited [ s ] = 1 ; var h = 0 ; adj [ s ] . forEach ( child => { if ( visited [ child ] == 0 ) { h = Math . max ( h , 1 + height ( child , adj , visited ) ) ; } } ) ; return h ; }
function minimumGroups ( adj , N ) { var visited = Array ( N + 1 ) . fill ( 0 ) ; var groups = - 1000000000 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( visited [ i ] == 0 ) { var comHeight ; comHeight = height ( i , adj , visited ) ; groups = Math . max ( groups , comHeight ) ; } } return groups ; }
function isPrime ( n ) { let flag = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { flag = 0 ; break ; } } return ( flag == 1 ? true : false ) ; }
function isPerfectSquare ( x ) { let sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
function countInterestingPrimes ( n ) { let answer = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( isPrime ( i ) ) { for ( let j = 1 ; j * j * j * j <= i ; j ++ ) { if ( isPerfectSquare ( i - j * j * j * j ) ) { answer ++ ; break ; } } } } return answer ; }
function sumDivisibles ( A , B , M ) { var sum = 0 ; for ( var i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; }
function findSmallNum ( N , K ) { var rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
function findLargeNum ( N , K ) { var rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
function sumDivisibles ( A , B , M ) { var sum = 0 ; var first = findSmallNum ( A , M ) ; var last = findLargeNum ( B , M ) ; if ( first < A ) first += M ; if ( last > B ) first -= M ; var n = ( parseInt ( B / M ) - parseInt ( ( A - 1 ) / M ) ) ; return n * ( first + last ) / 2 ; }
function check ( A , B , N ) { let pq1 = [ ] ; let pq2 = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { pq1 . push ( A [ i ] ) ; } for ( let i = 0 ; i < N ; i ++ ) { pq2 . push ( B [ i ] ) ; } pq1 . sort ( function ( a , b ) { return a - b ; } ) ; pq1 . reverse ( ) ; pq2 . sort ( function ( a , b ) { return a - b ; } ) ; pq2 . reverse ( ) ; let c = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( pq1 [ 0 ] > pq2 [ 0 ] ) { c ++ ; pq1 . shift ( ) ; pq2 . shift ( ) ; } else { if ( pq2 . length == 0 ) { break ; } pq2 . shift ( ) ; } } return ( c ) ; }
function calcSum ( arr , n , k ) { for ( var i = 0 ; i <= n - k ; i ++ ) { var sum = 0 ; for ( var j = i ; j < k + i ; j ++ ) sum += arr [ j ] ; document . write ( sum + "▁" ) ; } }
function calcSum ( arr , n , k ) { var sum = 0 ; for ( var i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; document . write ( sum + "▁" ) ; for ( var i = k ; i < n ; i ++ ) { sum = ( sum - arr [ i - k ] ) + arr [ i ] ; document . write ( sum + "▁" ) ; } }
function getPairs ( A , B , n ) { let D = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { D [ i ] = A [ i ] - B [ i ] ; } D . sort ( ( a , b ) => a - b ) ; let total = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( D [ i ] > 0 ) { total += n - i - 1 ; } else { let k = upper_bound ( D , 0 , D . length , - D [ i ] )  total += n - k ; } } return total ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function lcm ( a , b ) { return ( a * b ) / gcd ( a , b ) ; }
function countPairs ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) if ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) ans ++ ; return ans ; }
function countPairs ( arr , n ) { let frequency = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( frequency . has ( arr [ i ] ) ) { frequency . set ( arr [ i ] , frequency . get ( arr [ i ] ) + 1 ) ; } else { frequency . set ( arr [ i ] , 1 ) ; } } let count = 0 ; for ( let [ key , value ] of frequency . entries ( ) ) { let f = value ; count += f * ( f - 1 ) / 2 ; } return count ; }
function preCompute ( N ) { fact [ 0 ] = 1 ; for ( var i = 1 ; fact [ i - 1 ] <= N ; i ++ ) { fact [ i ] = ( fact [ i - 1 ] * i ) ; size ++ ; } }
function findLCS ( arr , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) != 0 ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } return mp . size ; }
function segments ( n ) { if ( n == 1 n == 0 ) { return ; } if ( n % 2 == 0 ) { document . write ( "1" ) ; segments ( n - 2 ) ; } else if ( n % 2 == 1 ) { document . write ( "7" ) ; segments ( n - 3 ) ; } }
function countOperations ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] & 1 ) { arr [ i ] ++ ; arr [ i + 1 ] ++ ; count += 2 ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) return - 1 ; } return count ; }
function findMinimumSubsequences ( A , B ) { let numberOfSubsequences = 1 ; let sizeOfB = B . length ; let sizeOfA = A . length ; let inf = 1000000 ; let next = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { next [ i ] = new Array ( sizeOfB ) ; for ( let j = 0 ; j < sizeOfB ; j ++ ) { next [ i ] [ j ] = inf ; } } for ( let i = 0 ; i < sizeOfB ; i ++ ) { next [ B [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] [ i ] = i ; } for ( let i = 0 ; i < 26 ; i ++ ) { for ( let j = sizeOfB - 2 ; j >= 0 ; j -- ) { if ( next [ i ] [ j ] == inf ) { next [ i ] [ j ] = next [ i ] [ j + 1 ] ; } } } let pos = 0 ; let i = 0 ; while ( i < sizeOfA ) { if ( pos == 0 && next [ A [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] [ pos ] == inf ) { numberOfSubsequences = - 1 ; break ; } else if ( pos < sizeOfB && next [ A [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] [ pos ] < inf ) { let nextIndex = next [ A [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] [ pos ] + 1 ; pos = nextIndex ; i ++ ; } else { numberOfSubsequences ++ ; pos = 0 ; } } return numberOfSubsequences ; }
function convolution ( x , h , n , m ) { let row_vec = new Array ( MAX_SIZE ) ; row_vec . fill ( 0 ) ; let col_vec = new Array ( MAX_SIZE ) ; col_vec . fill ( 0 ) ; let out = new Array ( MAX_SIZE ) ; out . fill ( 0 ) ; let circular_shift_mat = new Array ( MAX_SIZE ) ; circular_shift_mat . fill ( 0 ) ; for ( let i = 0 ; i < MAX_SIZE ; i ++ ) { circular_shift_mat [ i ] = new Array ( MAX_SIZE ) ; for ( let j = 0 ; j < MAX_SIZE ; j ++ ) { circular_shift_mat [ i ] [ j ] = 0 ; } } let maxSize = n > m ? n : m ; for ( let i = 0 ; i < maxSize ; i ++ ) { if ( i >= n ) { row_vec [ i ] = 0 ; } else { row_vec [ i ] = x [ i ] ; } } for ( let i = 0 ; i < maxSize ; i ++ ) { if ( i >= m ) { col_vec [ i ] = 0 ; } else { col_vec [ i ] = h [ i ] ; } } let k = 0 , d = 0 ; for ( let i = 0 ; i < maxSize ; i ++ ) { let curIndex = k - d ; for ( let j = 0 ; j < maxSize ; j ++ ) { circular_shift_mat [ j ] [ i ] = row_vec [ curIndex % maxSize ] ; curIndex ++ ; } k = maxSize ; d ++ ; } for ( let i = 0 ; i < maxSize ; i ++ ) { for ( let j = 0 ; j < maxSize ; j ++ ) { out [ i ] += circular_shift_mat [ i ] [ j ] * col_vec [ j ] ; } document . write ( out [ i ] + "▁" ) ; } }
function maxLength ( str , len ) { var res = 0 ; var lastPos = Array ( MAX ) ; for ( var i = 0 ; i < MAX ; i ++ ) { lastPos [ i ] = - 1 ; } for ( var i = 0 ; i < len ; i ++ ) { var C = str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ; if ( lastPos [ C ] != - 1 ) { res = Math . max ( len - ( i - lastPos [ C ] - 1 ) - 1 , res ) ; } lastPos [ C ] = i ; } return res ; }
function maxProfit ( profitA , profitB , n ) { let preSum = new Array ( n ) ; preSum [ 0 ] = profitA [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { preSum [ i ] = preSum [ i - 1 ] + profitA [ i ] ; } let suffSum = new Array ( n ) ; suffSum [ n - 1 ] = profitB [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + profitB [ i ] ; } let res = preSum [ n - 1 ] ; for ( let i = 1 ; i < n - 1 ; i ++ ) { res = Math . max ( res , preSum [ i ] + suffSum [ i + 1 ] ) ; } res = Math . max ( res , suffSum [ 0 ] ) ; return res ; }
function countPartitions ( A , N ) { var count = 0 ; var i , j ; for ( i = 0 ; i < N ; i ++ ) { var min_elem = min_element ( A , N ) ; if ( min_elem == INT_MAX ) break ; count ++ ; for ( j = 0 ; j < N ; j ++ ) { if ( A [ j ] % min_elem == 0 ) A [ j ] = INT_MAX ; } } return count ; }
function max_palindrome ( s , n ) { let flag = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] . length % 2 != 0 ) { flag = 1 ; } } if ( flag == 1 ) { return n ; } let z = 0 ; let o = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < s [ i ] . length ; j ++ ) { if ( s [ i ] [ j ] == "0" ) z += 1 ; else o += 1 ; } } if ( o % 2 == 0 && z % 2 == 0 ) { return n ; } else { return n - 1 ; } }
function minChanges ( arr , n ) { var umap = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( umap . has ( arr [ i ] ) ) { umap . set ( arr [ i ] , umap . get ( arr [ i ] ) + 1 ) ; } else { umap . set ( arr [ i ] , 1 ) ; } } var maxFreq = 0 ; umap . forEach ( ( values , keys ) => { maxFreq = Math . max ( maxFreq , values ) ; } ) ; return n - maxFreq ; }
function minOperations ( n , m ) { var a = 0 , k = 1 ; var p = Math . max ( n , m ) ; while ( n != m ) { var s = ( p - n + p - m ) ; var q = ( ( - 1 + Math . sqrt ( 8 * s + 1 ) ) / 2 ) ; if ( q - Math . floor ( q ) == 0 ) { a = parseInt ( q ) ; n = m ; } p = p + 1 ; } return a ; }
function decBinary ( arr , n ) { let k = Math . log2 ( n ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n = Math . floor ( n / 2 ) ; } }
function binaryDec ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }
function maxNum ( n , k ) { let l = Math . log2 ( n ) + 1 ; let a = new Array ( l ) . fill ( 0 ) ; decBinary ( a , n ) ; let cn = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( a [ i ] == 0 && cn < k ) { a [ i ] = 1 ; cn ++ ; } } return binaryDec ( a , l ) ; }
function minFlipsSub ( mat , i , j ) { var cnt0 = 0 , cnt1 = 0 ; if ( mat [ i ] . charAt ( j ) == "1" ) cnt1 ++ ; else cnt0 ++ ; if ( mat [ i ] . charAt ( j + 1 ) == "1" ) cnt1 ++ ; else cnt0 ++ ; if ( mat [ i + 1 ] . charAt ( j ) == "1" ) cnt1 ++ ; else cnt0 ++ ; if ( mat [ i + 1 ] . charAt ( j + 1 ) == "1" ) cnt1 ++ ; else cnt0 ++ ; return Math . min ( cnt0 , cnt1 ) ; }
function minFlips ( mat , r , c ) { var res = Number . MAX_VALUE ; for ( i = 0 ; i < r - 1 ; i ++ ) { for ( j = 0 ; j < c - 1 ; j ++ ) { res = Math . min ( res , minFlipsSub ( mat , i , j ) ) ; } } return res ; }
function findSubSeq ( arr , n , sum ) { for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( sum < arr [ i ] ) arr [ i ] = - 1 ; else sum -= arr [ i ] ; } for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != - 1 ) document . write ( arr [ i ] + "▁" ) ; } }
function k_sum ( a , n , k ) { let r = 0 , sum = 0 ; let ans = 0 ; for ( let l = 0 ; l < n ; l ++ ) { while ( sum < k ) { if ( r == n ) break ; else { sum += a [ r ] ; r ++ ; } } if ( sum < k ) break ; ans += n - r + 1 ; sum -= a [ l ] ; } return ans ; }
function balBracketSequence ( str ) { let n = str . length ; if ( str [ 0 ] == str [ n - 1 ] ) { document . write ( "No" ) ; } else { let cntForOpen = 0 , cntForClose = 0 ; let check = 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) cntForOpen ++ ; else if ( str [ i ] == str [ n - 1 ] ) cntForOpen -- ; else cntForOpen ++ ; if ( cntForOpen < 0 ) { check = 0 ; break ; } } if ( check && cntForOpen == 0 ) { document . write ( "Yes,▁" ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ n - 1 ] ) document . write ( ")" ) ; else document . write ( "(" ) ; } return ; } else { for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) cntForClose ++ ; else cntForClose -- ; if ( cntForClose < 0 ) { check = 0 ; break ; } } if ( check && cntForClose == 0 ) { document . write ( "Yes,▁" ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) document . write ( "(" ) ; else document . write ( ")" ) ; } return ; } } document . write ( "No" ) ; } }
function countSetBits ( n , k ) { let kth = findK ( n , k ) ; let count = 0 ; while ( kth > 0 ) { count += kth & 1 ; kth >>= 1 ; } return count ; }
function maxAlpha ( str , len ) { var first = new Array ( MAX ) ; var last = new Array ( MAX ) ; for ( var i = 0 ; i < MAX ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; } for ( var i = 0 ; i < len ; i ++ ) { var index = str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ; if ( first [ index ] === - 1 ) first [ index ] = i ; last [ index ] = i ; } var ans = - 1 , maxVal = - 1 ; for ( var i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] === - 1 ) continue ; if ( last [ i ] - first [ i ] > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return String . fromCharCode ( ans + "a" . charCodeAt ( 0 ) ) ; }
function maxSum ( arr1 , arr2 , n ) { let initialParity = 0 , finalParity = 0 ; let sum = 0 , minPositive = Number . MAX_SAFE_INTEGER , maxNegative = Number . MIN_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) { initialParity += arr2 [ i ] ; if ( arr1 [ i ] >= 0 ) { finalParity += 1 ; sum += arr1 [ i ] ; minPositive = Math . min ( minPositive , arr1 [ i ] ) ; } else { maxNegative = Math . max ( maxNegative , arr1 [ i ] ) ; } } if ( initialParity % 2 == finalParity % 2 ) { return sum ; } else { if ( minPositive + maxNegative >= 0 ) { return sum + maxNegative ; } else { return sum - minPositive ; } } }
function IsLarger ( X , Y , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( X [ i ] < Y [ i ] ) { return false ; } } return true ; }
function solve ( X , Y , n ) { let ans = 0 ; if ( IsLarger ( X , Y , n ) ) { ans = 0 ; } else { let d = Y [ 0 ] - X [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { X [ i ] += d ; } if ( IsLarger ( X , Y , n ) ) { ans = d ; } else { ans = d + 1 ; } } return ans ; }
function valueofX ( ar , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + ar [ i ] ; } if ( sum % n == 0 ) { return Math . floor ( sum / n ) ; } else { let A = Math . floor ( sum / n ) , B = Math . floor ( sum / n + 1 ) ; let ValueA = 0 , ValueB = 0 ; for ( let i = 0 ; i < n ; i ++ ) { ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) ; ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) ; } if ( ValueA < ValueB ) { return A ; } else { return B ; } } }
function minLength ( n ) { var ans = parseInt ( n / 26 ) ; if ( n % 26 != 0 ) ans ++ ; return ans ; }
function minHalls ( lectures , n ) { let prefix_sum = new Uint8Array ( MAX ) ; for ( let i = 0 ; i < n ; i ++ ) { prefix_sum [ lectures [ i ] [ 0 ] ] ++ ; prefix_sum [ lectures [ i ] [ 1 ] + 1 ] -- ; } let ans = prefix_sum [ 0 ] ; for ( let i = 1 ; i < MAX ; i ++ ) { prefix_sum [ i ] += prefix_sum [ i - 1 ] ; ans = Math . max ( ans , prefix_sum [ i ] ) ; } return ans ; }
function minCapacity ( enter , exit , n ) { let minCap = 0 ; let currCap = 0 ; for ( let i = 0 ; i < n ; i ++ ) { currCap = currCap + enter [ i ] - exit [ i ] ; minCap = Math . max ( minCap , currCap ) ; } return minCap ; }
function generate ( ) { let q = [ ] ; q . push ( "1" ) ; q . push ( "2" ) ; q . push ( "3" ) ; q . push ( "4" ) ; q . push ( "5" ) ; let flag = true ; ans . push ( "0" ) ; while ( q . length != 0 ) { let x = q . shift ( ) ; if ( isValidNum ( x ) ) { ans . push ( x ) ; } if ( x . length == 6 ) continue ; for ( let i = 0 ; i <= 5 ; i ++ ) { let z = ( i ) . toString ( ) ; let temp = x + z ; q . push ( temp ) ; } } }
function comp ( a , b ) { if ( a . length == b . length ) { return a < b ? true : false ; } else return a . length < b . length ; }
function findcount ( l , r ) { generate ( ) ; let count = 0 ; for ( let i = 0 ; i < ans . length ; i ++ ) { let a = ans [ i ] ; if ( comp ( l , a ) && comp ( a , r ) ) { count ++ ; } else if ( a == l a == r ) { count ++ ; } } return count ; }
function Findpermutation ( n ) { let a = new Array ( n + 1 ) ; a [ 1 ] = n ; for ( let i = 2 ; i <= n ; i ++ ) a [ i ] = i - 1 ; return a ; }
function Balanced_Substring ( str , n ) { let ans = 0 ; let arr = new Array ( n / 2 + 1 ) . fill ( 0 ) ; let d = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == "(" ) d ++ ; else { if ( d == 1 ) { for ( let j = 2 ; j <= parseInt ( n / 2 ) + 1 && arr [ j ] != 0 ; j ++ ) arr [ j ] = 0 ; } ++ ans ; ans += arr [ d ] ; arr [ d ] ++ ; d -- ; } } return ans ; }
function power ( x , y , mod ) { var res = 1 ; while ( y != 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % mod ; x = ( x * x ) % mod ; y = ( y >> 1 ) ; } return parseInt ( res % mod ) ; }
function NoOfChords ( A ) { var mod = parseInt ( 7 ) ; var ans = ncr ( 2 * A , A , mod ) ; var inv = power ( A + 1 , mod - 2 , mod ) ; ans = ( ans * inv ) % mod ; return parseInt ( ans % mod ) ; }
function StrictlyPositiveXor ( A , N ) { let allxor = 0 ; let checkallzero = true ; for ( let i = 0 ; i < N ; i += 1 ) { allxor ^= A [ i ] ; if ( A [ i ] > 0 ) checkallzero = false ; } if ( allxor != 0 ) return N ; if ( checkallzero ) return - 1 ; let l = N , r = - 1 ; for ( let i = 0 ; i < N ; i += 1 ) { if ( A [ i ] > 0 ) { l = i + 1 ; break ; } } for ( let i = N - 1 ; i >= 0 ; i -= 1 ) { if ( A [ i ] > 0 ) { r = i + 1 ; break ; } } return Math . max ( N - l , r - 1 ) ; }
function FindMinOperation ( a , n , k ) { let Q = [ ] ; for ( let i = 0 ; i < n ; i ++ ) Q . push ( a [ i ] ) ; Q . sort ( function ( a , b ) { return a - b } ) ; let ans = 0 ; while ( true ) { if ( Q [ 0 ] >= k ) break ; if ( Q . length < 2 ) return - 1 ; let x = Q [ 0 ] ; Q . shift ( ) ; let y = Q [ 0 ] ; Q . shift ( ) ; let z = parseInt ( ( x * y ) / gcd ( x , y ) , 10 ) ; Q . push ( z ) ; Q . sort ( function ( a , b ) { return a - b } ) ; ans ++ ; } return ans ; }
function findWeights ( X ) { let sum = 0 ; let power = 0 ; let number = 3 ; while ( sum < X ) { sum = number - 1 ; sum = Math . floor ( sum / 2 ) ; power ++ ; number *= 3 ; } let ans = 1 ; for ( let i = 1 ; i <= power ; i ++ ) { document . write ( ans + "▁" ) ; ans = ans * 3 ; } }
function solve ( arr , N , K ) { let count_Arr = new Array ( N + 1 ) . fill ( 0 ) ; let factor = 1 ; let size = N ; while ( size ) { let start = 1 ; let end = size ; count_Arr [ 1 ] += factor * N ; count_Arr [ end + 1 ] -= factor * N ; factor ++ ; size = Math . floor ( size / 2 ) ; } for ( let i = 2 ; i <= N ; i ++ ) count_Arr [ i ] += count_Arr [ i - 1 ] ; let element = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { element . push ( [ arr [ i ] , count_Arr [ i + 1 ] ] ) ; } element . sort ( ( a , b ) => a - b ) ; let start = 1 ; for ( let i = 0 ; i < N ; i ++ ) { let end = start + element [ i ] [ 1 ] - 1 ; if ( K >= start && K <= end ) { return element [ i ] [ 0 ] ; } start += element [ i ] [ 1 ] ; } return - 1 ; }
function find_distinct ( a , n , q , queries ) { let MAX = 100001 ; let check = new Array ( MAX ) . fill ( 0 ) ; let idx = new Array ( MAX ) . fill ( 0 ) ; let cnt = 1 ; let i = n - 1 ; while ( i >= 0 ) { if ( check [ a [ i ] ] == 0 ) { idx [ i ] = cnt ; check [ a [ i ] ] = 1 ; cnt ++ ; } else { idx [ i ] = cnt - 1 ; } i -- ; } for ( let i = 0 ; i < q ; i ++ ) { let m = queries [ i ] ; document . write ( idx [ m ] + "▁" ) ; } }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function lcm ( n , m ) { return ( n * m ) / gcd ( n , m ) ; }
function matrix_exist ( row , column , r , c ) { var row_sum = 0 ; var column_sum = 0 ; var row_max = - 1 ; var column_max = - 1 ; var row_non_zero = 0 ; var column_non_zero = 0 ; for ( var i = 0 ; i < r ; i ++ ) { row_sum += row [ i ] ; row_max = Math . max ( row_max , row [ i ] ) ; if ( row [ i ] ) row_non_zero ++ ; } for ( var i = 0 ; i < c ; i ++ ) { column_sum += column [ i ] ; column_max = Math . max ( column_max , column [ i ] ) ; if ( column [ i ] ) column_non_zero ++ ; } if ( ( row_sum != column_sum ) || ( row_max > column_non_zero ) || ( column_max > row_non_zero ) ) return false ; return true ; }
function longestSubarray ( arr , n ) { var maxMean = 0 ; for ( var i = 1 ; i < n ; i ++ ) maxMean = Math . max ( maxMean , parseInt ( ( arr [ i ] + arr [ i - 1 ] ) / 2 ) ) ; var ans = 0 ; var subarrayLength = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= maxMean ) ans = Math . max ( ans , ++ subarrayLength ) ; else subarrayLength = 0 ; return ans ; }
function maxDistance ( arr , n ) { if ( arr [ 0 ] != arr [ n - 1 ] ) return ( n - 1 ) ; var i = n - 1 ; while ( i > 0 ) { if ( arr [ i ] != arr [ 0 ] ) break ; i -- ; } var distFirst = ( i == 0 ) ? - 1 : i ; i = 0 ; while ( i < n - 1 ) { if ( arr [ i ] != arr [ n - 1 ] ) break ; i ++ ; } var distLast = ( i == n - 1 ) ? - 1 : ( n - 1 - i ) ; var maxDist = Math . max ( distFirst , distLast ) ; return maxDist ; }
function SubarraySum ( a , n , x ) { let ans = - 10000 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let curans = 0 ; let pq = [ ] ; let pq2 = [ ] ; for ( let k = 0 ; k < n ; k ++ ) { if ( k >= i && k <= j ) { curans += a [ k ] ; pq2 . push ( a [ k ] ) ; } else pq . push ( a [ k ] ) ; } pq . sort ( ) ; pq . reverse ( ) ; pq2 . sort ( ) ; ans = Math . max ( ans , curans ) ; for ( let k = 1 ; k <= x ; k ++ ) { if ( pq . length == 0 pq2 . length == 0 pq2 [ 0 ] >= pq [ 0 ] ) break ; curans -= pq2 [ 0 ] ; pq2 . shift ( ) ; curans += pq [ 0 ] ; pq . shift ( ) ; ans = Math . max ( ans , curans ) ; } } } return ans ; }
function solve ( n , k ) { let mini = 0 ; let x1 = 1 ; let a = new Array ( k ) ; for ( let i = 1 ; i <= k ; i ++ ) { mini += x1 ; a [ i - 1 ] = x1 ; x1 += 1 ; } if ( n < mini ) { document . write ( "-1" ) ; return ; } let rem = n - mini ; let cnt = parseInt ( rem / k ) ; rem = rem % k ; for ( let i = 0 ; i < k ; i ++ ) a [ i ] += cnt ; for ( let i = k - 1 ; i > 0 && rem > 0 ; i -- ) { let xx = a [ i - 1 ] * 2 ; let left = xx - a [ i ] ; if ( rem >= left ) { a [ i ] = xx ; rem -= left ; } else { a [ i ] += rem ; rem = 0 ; } } let sum = a [ 0 ] ; for ( let i = 1 ; i < k ; i ++ ) { if ( a [ i ] > 2 * a [ i - 1 ] ) { document . write ( "-1" ) ; return ; } sum += a [ i ] ; } if ( sum != n ) { document . write ( "-1" ) ; return ; } for ( let i = 0 ; i < k ; i ++ ) document . write ( a [ i ] + "▁" ) ; }
function printMaxNumber ( n ) { if ( n & 1 ) { document . write ( "7" ) ; for ( var i = 0 ; i < ( n - 3 ) / 2 ; i ++ ) document . write ( "1" ) ; } else { for ( var i = 0 ; i < n / 2 ; i ++ ) document . write ( "1" ) ; } }
function minOperations ( arr , n ) { let maxi , result = 0 ; let freq = new Array ( 1000001 ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { let x = arr [ i ] ; freq [ x ] ++ ; } maxi = Math . max ( ... arr ) ; for ( let i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( let j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; }
function maxCoins ( X , Y ) { if ( X < Y ) { let temp = X ; X = Y ; Y = temp ; } let coins = X ; X -- ; coins += Math . max ( X , Y ) ; return coins ; }
function findElementsCrossed ( arr , a , b , n ) { var aa = a ; var ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a == 0 && b == 0 ) break ; else if ( a == 0 ) { if ( arr [ i ] == 1 ) { b -= 1 ; a = Math . min ( aa , a + 1 ) ; } else b -= 1 ; } else if ( b == 0 ) a -- ; else if ( arr [ i ] == 1 && a < aa ) { b -= 1 ; a = Math . min ( aa , a + 1 ) ; } else a -- ; ans ++ ; } return ans ; }
function printArr ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function pushBinaryToBorder ( arr , n ) { var count1 = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 1 ) arr [ count1 ++ ] = arr [ i ] ; while ( count1 < n ) arr [ count1 ++ ] = 1 ; var lastNonOne = 0 ; for ( var i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == 1 ) continue ; if ( ! lastNonOne ) { lastNonOne = i ; } if ( arr [ i ] != 0 ) arr [ lastNonOne -- ] = arr [ i ] ; } while ( lastNonOne >= 0 ) arr [ lastNonOne -- ] = 0 ; }
function getMaxValue ( arr , arr_size ) { let i , first , second ; if ( arr_size < 2 ) { return 0 ; } first = second = Number . MIN_VALUE ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) { second = arr [ i ] ; } } if ( second == Number . MIN_VALUE ) { return 0 ; } else { return second ; } }
function isVowel ( ch ) { switch ( ch ) { case "a" : case "e" : case "i" : case "o" : case "u" : return true ; default : return false ; } }
function vowelPairs ( s , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( isVowel ( s [ i ] ) && isVowel ( s [ i + 1 ] ) ) cnt ++ ; } return cnt ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function solve ( health , n ) { let currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) ; for ( let i = 2 ; i < n ; ++ i ) { currentgcd = gcd ( currentgcd , health [ i ] ) ; } return currentgcd ; }
function smallestString ( N , A ) { let ch = "a" ; let S = "" ; if ( N < 1 A [ 0 ] != 1 ) { S = "-1" ; return S ; } S += ch ; ch = String . fromCharCode ( ch . charCodeAt ( 0 ) + 1 ) ; for ( let i = 1 ; i < N ; i ++ ) { let diff = A [ i ] - A [ i - 1 ] ; if ( diff > 1 diff < 0 A [ i ] > 26 ) { S = "-1" ; return S ; } else if ( diff == 0 ) S += "a" ; else { S += ch ; ch = String . fromCharCode ( ch . charCodeAt ( 0 ) + 1 ) ; } } return S ; }
function bankNotes ( A , B , S , N ) { let numerator = S - ( B * N ) ; let denominator = A - B ; if ( numerator % denominator == 0 ) return ( Math . floor ( numerator / denominator ) ) ; return - 1 ; }
function countSteps ( n ) { let steps = 0 ; while ( n ) { let largest = Math . floor ( Math . sqrt ( n ) ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; }
function longestSubstring ( s ) { var cnt = 1 , maxi = 1 ; var n = s . length ; for ( i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) cnt ++ ; else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; }
function Minimum_Operations ( a , n ) { let np = Array ( n + 1 ) . fill ( 0 ) ; np [ n ] = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { np [ i ] = np [ i + 1 ] ; if ( a [ i ] <= 0 ) np [ i ] ++ ; } let pos = 0 ; let ans = n ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] >= 0 ) pos ++ ; ans = Math . min ( ans , pos + np [ i + 1 ] ) ; } return ans ; }
function findSumofEle ( arr1 , m , arr2 , n , k ) { var arraySum = 0 ; for ( var i = 0 ; i < n ; i ++ ) arraySum += arr2 [ i ] ; var mean = ( arraySum / n ) ; var sumOfElements = 0 ; var difference ; for ( var i = 0 ; i < m ; i ++ ) { difference = arr1 [ i ] - mean ; if ( ( difference < 0 ) && ( k > ( - 1 ) * difference ) ) { sumOfElements += arr1 [ i ] ; } if ( ( difference >= 0 ) && ( k > difference ) ) { sumOfElements += arr1 [ i ] ; } } return sumOfElements ; }
function findIntegers ( n , x , y ) { let ans = [ ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) ans . push ( 1 ) ; if ( y - ( n - 1 ) <= 0 ) { document . write ( "-1" ) ; return ; } ans . push ( y - ( n - 1 ) ) ; let store = 0 ; for ( let i = 0 ; i < n ; i ++ ) store += ans [ i ] * ans [ i ] ; if ( store < x ) { document . write ( "-1" ) ; return ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( ans [ ( i ) ] + "▁" ) ; }
function Minsteps ( n , m ) { let ans = 0 ; while ( m > n ) { if ( m & 1 ) { m ++ ; ans ++ ; } m = Math . floor ( m / 2 ) ; ans ++ ; } return ans + n - m ; }
function getsum ( x ) { return ( x * ( x + 1 ) ) / 2 ; }
function maxCandies ( arr , n ) { let prevBought = arr [ n - 1 ] ; let candies = prevBought ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let x = Math . min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; }
function sumArr ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
function maxSum ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b } ) ; let i = 0 ; while ( i < n && k > 0 && arr [ i ] < 0 ) { arr [ i ] *= - 1 ; k -- ; i ++ ; } if ( k % 2 == 1 ) { let min = 0 ; for ( i = 1 ; i < n ; i ++ ) if ( arr [ min ] > arr [ i ] ) min = i ; arr [ min ] *= - 1 ; } return sumArr ( arr , n ) ; }
function Maxsum ( c1 , c2 , c3 , c4 ) { let sum = 0 ; let two34 = Math . min ( c2 , Math . min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += Math . min ( c2 , c1 ) * 12 ; return sum ; }
function replacedArray ( N , arr ) { var pos_sum , neg_sum , i , j , diff ; for ( i = 0 ; i < N ; i ++ ) { pos_sum = 0 ; neg_sum = 0 ; for ( j = i + 1 ; j < N ; j ++ ) { if ( arr [ j ] > 0 ) pos_sum += arr [ j ] ; else neg_sum += arr [ j ] ; } diff = Math . abs ( pos_sum ) - Math . abs ( neg_sum ) ; arr [ i ] = Math . abs ( diff ) ; } }
function maximumResult ( a , b , c ) { let countOfNegative = 0 ; let sum = a + b + c ; let product = a * b * c ; let largest = Math . max ( a , Math . max ( b , c ) ) ; let smallest = Math . min ( a , Math . min ( b , c ) ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } }
function isPalindrome ( s ) { for ( let i = 0 ; i < s . length ; ++ i ) { if ( s [ i ] != s [ s . length - i - 1 ] ) { return false ; } } return true ; }
function ans ( s ) { let s2 = s ; for ( let i = 0 ; i < s . length ; ++ i ) { s2 = s2 [ s2 . length - 1 ] + s2 ; s2 = s2 . substring ( 0 , s2 . length - 1 ) ; if ( ( s == null ? s2 != null : ! s == ( s2 ) ) && isPalindrome ( s2 ) ) { return true ; } } return false ; }
function solve ( s ) { if ( s . length <= 3 ) { return - 1 ; } let cnt = new Array ( 25 ) ; for ( let i = 0 ; i < 25 ; i ++ ) cnt [ i ] = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { cnt [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } if ( Math . max ( ... cnt ) >= ( s . length - 1 ) ) { return - 1 ; } else { return ( ans ( s ) ? 1 : 2 ) ; } }
function solveEven ( s ) { if ( s . length % 2 == 1 ) { return 2 ; } let ls = s . substring ( 0 , s . length / 2 ) ; let rs = s . substring ( s . length / 2 , s . length ) ; if ( ls != rs ) { return 1 ; } return solveEven ( ls ) ; }
function solveOdd ( s ) { return 2 ; }
function solve ( s ) { if ( s . length <= 3 ) { return - 1 ; } let cnt = new Array ( 25 ) ; for ( let i = 0 ; i < 25 ; i ++ ) cnt [ i ] = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { cnt [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } if ( Math . max ( ... cnt ) >= s . length - 1 ) { return - 1 ; } if ( s . length % 2 == 0 ) { return solveEven ( s ) ; } if ( s . length % 2 == 1 ) { return solveOdd ( s ) ; } return Number . MIN_VALUE ; }
function minChanges ( str , n ) { let count = 0 , zeros = 0 , ones = 0 ; if ( str [ 0 ] != "1" ) { count ++ ; ones ++ ; } for ( let i = 1 ; i < n ; i ++ ) { if ( str [ i ] == "0" ) zeros ++ ; else ones ++ ; if ( zeros > ones ) { zeros -- ; ones ++ ; count ++ ; } } return count ; }
function findCountOfPairs ( a , b , n ) { let ans = 0 ; for ( let i = 1 ; i <= a ; i ++ ) { ans += parseInt ( b / n , 10 ) ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }
function findCountOfPairs ( a , b , n ) { if ( a > b ) { let temp1 = a ; a = b ; b = temp1 ; } let temp = 1 , count = 0 ; for ( let i = n ; temp > 0 ; i += n ) { if ( a >= i ) { temp = i - 1 ; } else if ( b >= i ) { temp = a ; } else if ( i > b ) { temp = a - ( i - b ) + 1 ; } if ( temp > 0 ) { count += temp ; } } return count ; }
function minGCD ( arr , n ) { var minGCD = 0 ; for ( i = 0 ; i < n ; i ++ ) minGCD = __gcd ( minGCD , arr [ i ] ) ; return minGCD ; }
function minLCM ( arr , n ) { var minLCM = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) minLCM = Math . min ( minLCM , arr [ i ] ) ; return minLCM ; }
function countSteps ( curx , cury , n , m , moves ) { let count = 0 ; let k = moves . length ; for ( let i = 0 ; i < k ; i ++ ) { let x = moves [ i ] [ 0 ] ; let y = moves [ i ] [ 1 ] ; let stepct = Math . min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) ; count += stepct ; curx += stepct * x ; cury += stepct * y ; } return Math . floor ( count ) ; }
function min_elimination ( n , arr ) { let count = 0 ; let prev_val = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { let curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; }
function getCount ( N ) { if ( N % 2 == 1 ) return "0" ; let result = "9" ; for ( let i = 1 ; i <= N / 2 - 1 ; i ++ ) result += "0" ; return result ; }
function cmp ( a , b ) { if ( a > b ) return 1 ; else if ( a == b ) return 0 ; else return - 1 ; }
function maxSubStrings ( s , k ) { var maxSubStr = 0 , n = s . length ; for ( var c = 0 ; c < 26 ; c ++ ) { var ch = String . fromCharCode ( "a" . charCodeAt ( 0 ) + c ) ; var curr = 0 ; for ( var i = 0 ; i <= n - k ; i ++ ) { if ( s [ i ] !== ch ) continue ; var cnt = 0 ; while ( i < n && s [ i ] === ch && cnt !== k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt === k ) curr ++ ; } maxSubStr = Math . max ( maxSubStr , curr ) ; } return maxSubStr ; }
function canFormTeam ( n , m ) { if ( n >= 1 && m >= 2 ) return true ; if ( m >= 1 && n >= 2 ) return true ; return false ; }
function maxTeams ( n , m ) { var count = 0 ; while ( canFormTeam ( n , m ) ) { if ( n > m ) { n -= 2 ; m -= 1 ; } else { m -= 2 ; n -= 1 ; } count ++ ; } return count ; }
function canBePicked ( digits , num ) { var copyDigits = new Array ( 10 ) ; ; for ( var i = 0 ; i < 10 ; i ++ ) copyDigits [ i ] = digits [ i ] ; while ( num > 0 ) { var digit = num % 10 ; if ( copyDigits [ digit ] == 0 ) return false ; else copyDigits [ digit ] -= 1 ; num = Math . floor ( num / 10 ) ; } return true ; }
function max ( a , b ) { if ( a > b ) return a ; else return b ; }
function smallestSide ( a ) { a . sort ( ) ; var side1 , side2 , side3 , side4 , side11 , side12 , sideOfSquare ; side1 = a [ 0 ] + a [ 3 ] ; side2 = a [ 1 ] + a [ 2 ] ; side3 = a [ 0 ] + a [ 1 ] ; side4 = a [ 2 ] + a [ 3 ] ; side11 = max ( side1 , side2 ) ; side12 = max ( side3 , side4 ) ; sideOfSquare = max ( side11 , side12 ) ; return sideOfSquare ; }
function find_rectangle ( are ) { for ( let i = Math . floor ( Math . ceil ( Math . sqrt ( area ) ) ) ; i <= area ; i ++ ) { if ( Math . floor ( area / i ) * i == area ) { document . write ( i + "▁" + Math . floor ( area / i ) ) ; return ; } } }
function sizeSubSet ( a , k , n ) { a . sort ( function ( a , b ) { return a - b ; } ) ; let s = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] % k != 0 || s . get ( a [ i ] / k ) == null ) s . set ( a [ i ] , s . get ( a [ i ] ) == null ? 1 : s . get ( a [ i ] ) + 1 ) ; } return s . size ; }
function minimumSets ( s , y ) { let cnt = 0 ; let num = 0 ; let l = s . length ; let f = false ; for ( let i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s [ i ] - "0" ) ; if ( num <= y ) f = true ; { if ( f ) cnt += 1 ; num = s [ i ] - "0" ; f = false ; if ( num <= y ) f = true ; else num = 0 ; } } if ( f == true ) cnt += 1 ; return cnt ; }
function ModifiedArray ( a , n ) { let l = 0 , r = Number . MAX_VALUE ; let b = Array ( n ) . fill ( 0 ) ; for ( let i = 0 ; i < n / 2 ; i ++ ) { b [ i ] = Math . max ( l , a [ i ] - r ) ; b [ n - i - 1 ] = a [ i ] - b [ i ] ; l = b [ i ] ; r = b [ n - i - 1 ] ; } printArr ( b , n ) ; }
function greatestKBits ( X , K ) { let set_bit_count = countSetBits ( X ) ; if ( set_bit_count <= K ) return X ; let diff = set_bit_count - K ; for ( let i = 0 ; i < diff ; i ++ ) X &= ( X - 1 ) ; return X ; }
function minItems ( k , r ) { for ( let i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; }
function maxSubArraySum ( a , size ) { var max_so_far = Number . MIN_VALUE , max_ending_here = 0 ; for ( i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
function maxSum ( a , n ) { var S = 0 ; var S1 = maxSubArraySum ( a , n ) ; for ( i = 0 ; i < n ; i ++ ) S += a [ i ] ; return ( 2 * S1 - S ) ; }
function check_distribution ( n , k , age , candy ) { let mxage = age [ 0 ] ; for ( let i = 0 ; i < age . length ; i ++ ) { if ( mxage < age [ i ] ) { mxage = age [ i ] ; } } let mxcandy = candy [ 0 ] ; for ( let i = 0 ; i < candy . length ; i ++ ) { if ( mxcandy < candy [ i ] ) { mxcandy = candy [ i ] ; } } let fr1 = new Array ( mxage + 1 ) ; fr1 . fill ( 0 ) ; let fr2 = new Array ( mxcandy + 1 ) ; fr2 . fill ( 0 ) ; for ( let j = 0 ; j < n ; j ++ ) { fr1 [ age [ j ] ] += 1 ; } for ( let j = 0 ; j < k ; j ++ ) { fr2 [ candy [ j ] ] += 1 ; } k = 0 ; let Tf = true ; for ( let j = 0 ; j < mxage ; j ++ ) { if ( fr1 [ j ] == 0 ) { continue ; } let flag = false ; while ( k < mxcandy ) { if ( fr1 [ j ] <= fr2 [ k ] ) { flag = true ; break ; } k += 1 ; } k = k + 1 ; if ( flag == false ) { Tf = false ; break ; } } if ( Tf ) { document . write ( "YES" ) ; } else { document . write ( "NO" ) ; } }
function check ( n , marks ) { let x = Math . max ( ... marks ) ; let bonus = 100 - x ; let c = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( marks [ i ] + bonus >= 50 ) c += 1 ; } return c ; }
function find_sum ( n , k ) { let total_sum = ( n * ( n + 1 ) ) / 2 ; let power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; }
function findTwoNumbers ( sum , gcd ) { if ( __gcd ( gcd , sum - gcd ) == gcd && sum != gcd ) document . write ( "a▁=▁" + Math . min ( gcd , sum - gcd ) + ",▁b▁=▁" + ( sum - Math . min ( gcd , sum - gcd ) ) ) ; else document . write ( - 1 ) ; }
function maxLitres ( budget , plastic , glass , refund ) { if ( glass - refund < plastic ) { let ans = Math . max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += Math . floor ( budget / plastic ) ; document . write ( ans ) ; } else { document . write ( Math . floor ( budget / plastic ) ) ; } }
function smallestPermute ( n ) { var res = Array ( n + 1 ) . fill ( 0 ) ; if ( n % 2 == 0 ) { for ( var i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = 48 + i + 2 ; else res [ i ] = 48 + i ; } } else { for ( var i = 0 ; i < n - 2 ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = 48 + i + 2 ; else res [ i ] = 48 + i ; } res [ n - 1 ] = 48 + n - 2 ; res [ n - 2 ] = 48 + n ; res [ n - 3 ] = 48 + n - 1 ; } for ( var i = 0 ; i < res . length ; i ++ ) { res [ i ] = String . fromCharCode ( res [ i ] ) ; } return res . join ( "\0" ) ; }
function leastValue ( P , A , N , a ) { let ans = - 1 ; let tmp = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let t = ( P - a [ i ] * 0.006 ) ; if ( Math . abs ( t - A ) < tmp ) { tmp = Math . abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
function minOperations ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; for ( var i = 0 ; i < n ; i ++ ) hashTable [ arr [ i ] ] ++ ; var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( hashTable [ arr [ i ] ] ) { for ( var j = i ; j < n ; j ++ ) if ( arr [ j ] % arr [ i ] == 0 ) hashTable [ arr [ j ] ] = 0 ; res ++ ; } } return res ; }
function minInsertions ( H , n , K ) { var inser = 0 ; for ( var i = 1 ; i < n ; ++ i ) { var diff = Math . abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += Math . ceil ( diff / K ) - 1 ; } return inser ; }
function minCost ( N , P , Q ) { var cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { var temp = parseInt ( N / 2 ) ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N = parseInt ( N / 2 ) ; } } return cost ; }
function count_minimum_operations ( n ) { let count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; }
function count_minimum_operations ( n ) { if ( n == 2 ) { return 1 ; } else if ( n == 1 ) { return 0 ; } if ( n % 3 == 0 ) { return 1 + count_minimum_operations ( n / 3 ) ; } else if ( n % 3 == 1 ) { return 1 + count_minimum_operations ( n - 1 ) ; } else { return 1 + count_minimum_operations ( n + 1 ) ; } }
function findPermutation ( n ) { let len = Math . ceil ( Math . log10 ( n ) ) ; for ( let i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return parseInt ( n ) ; } else { n = ( n / 10 ) + ( n % 10 ) * Math . pow ( 10 , len - i - 1 ) ; continue ; } } return - 1 ; }
function maxMatrixScore ( A , K ) { var update = new Map ( ) ; for ( var i = 0 ; i < n ; ++ i ) { if ( A [ i ] [ 0 ] == 0 ) { var ans = 0 ; for ( var j = 1 ; j < m ; ++ j ) ans = ans + A [ i ] [ j ] * Math . pow ( 2 , m - j - 1 ) ; update . set ( ans , i ) ; } } update . forEach ( ( value , key ) => { if ( K > 0 ) { var idx = value ; for ( var j = 0 ; j < m ; ++ j ) A [ idx ] [ j ] = ( A [ idx ] [ j ] + 1 ) % 2 ; K -- ; } } ) ; var ans = 0 ; for ( var j = 0 ; j < m ; ++ j ) { var zero = 0 , one = 0 ; for ( var i = 0 ; i < n ; ++ i ) { A [ i ] [ j ] == 0 ? zero ++ : one ++ ; } if ( K > 0 && zero > one ) { ans += zero * Math . pow ( 2 , m - j - 1 ) ; K -- ; } else ans += one * Math . pow ( 2 , m - j - 1 ) ; } return ans ; }
function isSellingPossible ( n , a ) { let i , c25 = 0 , c50 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 25 ) c25 ++ ; else if ( a [ i ] == 50 ) { c50 ++ ; if ( c25 == 0 ) break ; c25 -- ; } else { if ( c50 > 0 && c25 > 0 ) { c50 -- ; c25 -- ; } else if ( c25 >= 3 ) c25 -= 3 ; else break ; } } if ( i == n ) return true ; else return false ; }
function cal_minimum_time ( X ) { let t = 0 ; let sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; }
function countMinSwaps ( s ) { var N = s . length ; var one = 0 ; var zero = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == "1" ) one ++ ; else zero ++ ; } if ( one > zero + 1 zero > one + 1 ) return - 1 ; if ( N % 2 == 1 ) { var num = ( N + 1 ) / 2 ; var one_even = 0 , zero_even = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { if ( s . charAt ( i ) == "1" ) one_even ++ ; else zero_even ++ ; } } if ( one > zero ) return num - one_even ; else return num - zero_even ; } else { var one_odd = 0 , one_even = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == "1" ) { if ( i % 2 == 1 ) one_odd ++ ; else one_even ++ ; } } return Math . min ( N / 2 - one_odd , N / 2 - one_even ) ; } }
function minDiff ( n , x , A ) { var mn = A [ 0 ] , mx = A [ 0 ] ; for ( var i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; } return Math . max ( 0 , mx - mn - 2 * x ) ; }
function LengthLCP ( x , y ) { let fr = Array ( 26 ) . fill ( 0 ) ; for ( let i = 0 ; i < b ; i ++ ) { fr [ y [ i ] . charCodeAt ( ) - 97 ] += 1 ; } let c = 0 ; for ( let i = 0 ; i < a ; i ++ ) { if ( fr [ x [ i ] . charCodeAt ( ) - 97 ] > 0 ) { c += 1 ; fr [ x [ i ] . charCodeAt ( ) - 97 ] -= 1 ; } else break ; } document . write ( ( c ) ) ; }
function checkIfOverlap ( str ) { let len = str . length ; let visited = new Array ( len + 1 ) ; for ( let i = 0 ; i < visited . length ; i ++ ) { visited [ i ] = 0 ; } for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] == "." ) continue ; for ( let j = Math . max ( 0 , i - str [ i ] ) ; j <= Math . min ( len , i + str [ i ] ) ; j ++ ) visited [ j ] ++ ; } for ( let i = 0 ; i < len ; i ++ ) { if ( visited [ i ] > 1 ) { return true ; } } return false ; }
function isWaveArray ( arr , n ) { let result = true ; if ( arr [ 1 ] > arr [ 0 ] && arr [ 1 ] > arr [ 2 ] ) { for ( let i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] <= arr [ n - 2 ] ) { result = false ; } } } else if ( arr [ 1 ] < arr [ 0 ] && arr [ 1 ] < arr [ 2 ] ) { for ( let i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] >= arr [ n - 2 ] ) { result = false ; } } } return result ; }
function printCoins ( arr , n ) { var oddSum = 0 ; for ( var i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; var evenSum = 0 ; for ( var i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; var start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( var i = start ; i < n ; i += 2 ) document . write ( arr [ i ] + "▁" ) ; }
function countSubstrings ( s ) { let ans = 0 ; let subs = 1 ; let pre = "0" ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( pre == s [ i ] ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = s [ i ] ; } document . write ( ans ) ; }
function find ( i ) { while ( parent [ i ] != i ) i = parent [ i ] ; return i ; }
function isValidEdge ( u , v , inMST ) { if ( u == v ) return false ; if ( inMST [ u ] == false && inMST [ v ] == false ) return false ; else if ( inMST [ u ] == true && inMST [ v ] == true ) return false ; return true ; }
function smallestSumSubarr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ; let sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { sum_here = Math . max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = Math . max ( max_sum , sum_here ) ; } return ( - 1 ) * max_sum ; }
function solve ( arr , n ) { let ans = new Array ( n ) ; for ( var i = 0 ; i < ans . length ; i ++ ) { ans [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { ans [ i ] [ j ] = arr [ j ] [ ( i + j ) % n ] ; } } return ans ; }
function makeArray ( n ) { let arr = new Array ( n ) ; for ( var i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = new Array ( 2 ) ; } let c = 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = c ++ ; } return arr ; }
function printLargest ( a , n ) { let max = - 1 ; let ind = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { let num = a [ i ] ; while ( num > 0 ) { let r = num % 10 ; num = Math . floor ( num / 10 ) ; if ( num == 0 ) { if ( max < r ) { max = r ; ind = i ; } } } } for ( let i = ind ; i < n ; i ++ ) document . write ( a [ i ] ) ; for ( let i = 0 ; i < ind ; i ++ ) document . write ( a [ i ] ) ; }
function findMinimumAdjacentSwaps ( arr , N ) { let visited = Array ( N + 1 ) . fill ( false ) ; let minimumSwaps = 0 ; for ( let i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; let count = 0 ; for ( let j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; }
function DecreasingArray ( a , n ) { var sum = 0 , dif = 0 ; var pq = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( pq . length != 0 && pq [ pq . length - 1 ] < a [ i ] ) { dif = a [ i ] - pq [ pq . length - 1 ] ; sum += dif ; pq . pop ( ) ; } pq . push ( a [ i ] ) ; pq . sort ( ( a , b ) => b - a ) ; } return sum ; }
function ifPossible ( arr , n ) { let copy = arr ; copy . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false ; } return true ; }
function findMinRooms ( slots , n , m ) { let counts = Array ( m ) . fill ( 0 ) ; for ( let i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == "1" ) counts [ j ] ++ ; let max = - 1 ; for ( let i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }
function MinOperation ( a , n , k ) { let result = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }
function maxProductSubset ( a , n ) { if ( n == 1 ) return a [ 0 ] ; let max_neg = Number . MIN_SAFE_INTEGER ; let count_neg = 0 ; count_zero = 0 ; let prod = 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = Math . max ( max_neg , a [ i ] ) ; } prod = prod * a [ i ] ; } if ( count_zero == n ) return 0 ; if ( count_neg & 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) return 0 ; prod = prod / max_neg ; } return prod ; }
function preProcess ( n ) { let preProcessedCubes = [ ] ; for ( let i = 1 ; i * i * i <= n ; i ++ ) { let iThCube = i * i * i ; let cubeString = ( iThCube ) . toString ( ) ; preProcessedCubes . push ( cubeString ) ; } return preProcessedCubes ; }
function solve ( a , b , n ) { let i ; let s = 0 ; for ( i = 0 ; i < n ; i ++ ) s += ( a [ i ] + b [ i ] ) ; if ( n == 1 ) return a [ 0 ] + b [ 0 ] ; if ( s % n != 0 ) return - 1 ; let x = s / n ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) return - 1 ; if ( i > 0 ) { a [ i ] += b [ i - 1 ] ; b [ i - 1 ] = 0 ; } if ( a [ i ] == x ) continue ; let y = a [ i ] + b [ i ] ; if ( i + 1 < n ) y += b [ i + 1 ] ; if ( y == x ) { a [ i ] = y ; b [ i ] = 0 ; continue ; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ] ; b [ i ] = 0 ; continue ; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ] ; b [ i + 1 ] = 0 ; continue ; } return - 1 ; } for ( i = 0 ; i < n ; i ++ ) if ( b [ i ] != 0 ) return - 1 ; return x ; }
function calcFiboTerms ( fiboTerms , K ) { var i = 3 , nextTerm ; fiboTerms . push ( 0 ) ; fiboTerms . push ( 1 ) ; fiboTerms . push ( 1 ) ; while ( 1 ) { nextTerm = fiboTerms [ i - 1 ] + fiboTerms [ i - 2 ] ; if ( nextTerm > K ) return ; fiboTerms . push ( nextTerm ) ; i ++ ; } }
function survival ( S , N , M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) document . write ( "No" ) ; else { let days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; document . write ( "Yes▁" + Math . round ( days ) ) ; } }
function findTwoGroup ( n ) { var sum = n * ( n + 1 ) / 2 ; var group1Sum = parseInt ( sum / 2 ) ; var group1 = [ ] , group2 = [ ] ; for ( var i = n ; i > 0 ; i -- ) { if ( group1Sum - i >= 0 ) { group1 . push ( i ) ; group1Sum -= i ; } else { group2 . push ( i ) ; } } printVector ( group1 ) ; printVector ( group2 ) ; }
function cost ( a , n ) { let min = a [ 0 ] ; for ( let i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return ( n - 1 ) * min ; }
function winner ( a , n , k ) { if ( k >= n - 1 ) return n ; let best = 0 , times = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }
function minproduct ( a , b , n , k ) { let diff = 0 , res = 0 ; let temp = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; let d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
function minRotation ( input , unlock_code ) { let rotation = 0 ; let input_digit , code_digit ; while ( input > 0 unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input = Math . floor ( input / 10 ) ; unlock_code = Math . floor ( unlock_code / 10 ) ; } return rotation ; }
function findWaitingTime ( proc , n , wt ) { let rt = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) rt [ i ] = proc [ i ] . bt ; let complete = 0 , t = 0 , minm = Number . MAX_VALUE ; let shortest = 0 , finish_time ; let check = false ; while ( complete != n ) { for ( let j = 0 ; j < n ; j ++ ) { if ( ( proc [ j ] . art <= t ) && ( rt [ j ] < minm ) && rt [ j ] > 0 ) { minm = rt [ j ] ; shortest = j ; check = true ; } } if ( check == false ) { t ++ ; continue ; } rt [ shortest ] -- ; minm = rt [ shortest ] ; if ( minm == 0 ) minm = Number . MAX_VALUE ; if ( rt [ shortest ] == 0 ) { complete ++ ; check = false ; finish_time = t + 1 ; wt [ shortest ] = finish_time - proc [ shortest ] . bt - proc [ shortest ] . art ; if ( wt [ shortest ] < 0 ) wt [ shortest ] = 0 ; } t ++ ; } }
function findTurnAroundTime ( proc , n , wt , tat ) { for ( let i = 0 ; i < n ; i ++ ) tat [ i ] = proc [ i ] . bt + wt [ i ] ; }
function minCost ( coin , n , k ) { coin . sort ( function ( a , b ) { return a - b } )  var coins_needed = Math . ceil ( n / ( k + 1 ) ) ; var ans = 0 ; for ( var i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
function preprocess ( coin , n ) { coin . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 1 ; i <= n - 1 ; i ++ ) coin [ i ] += coin [ i - 1 ] ; }
function minCost ( coin , n , k ) { let coins_needed = Math . ceil ( 1.0 * n / ( k + 1 ) ) ; return coin [ coins_needed - 1 ] ; }
function minimizeWithKSwaps ( arr , n , k ) { for ( let i = 0 ; i < n - 1 && k > 0 ; ++ i ) { let pos = i ; for ( let j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } let temp ; for ( let j = pos ; j > i ; -- j ) { temp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = temp ; } k -= pos - i ; } }
function minimumSquare ( a , b ) { let result = 0 , rem = 0 ; if ( a < b ) { let temp = a ; a = b ; b = temp ; } while ( b > 0 ) { result += parseInt ( a / b ) ; let rem = a % b ; a = b ; b = rem ; } return result ; }
function minimumCostOfBreaking ( X , Y , m , n ) { let res = 0 ; X . sort ( ) ; X . reverse ( ) ; Y . sort ( ) ; Y . reverse ( ) ; let hzntl = 1 , vert = 1 ; let i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } let total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }
function maximumSum ( arr , n , k ) { for ( let i = 1 ; i <= k ; i ++ ) { let min = + 2147483647 ; let index = - 1 ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
function maximizeSum ( arr , n , k ) { ( arr ) . sort ( function ( a , b ) { return a - b ; } ) ; let i = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( k != 0 && arr [ i ] < 0 ) { arr [ i ] *= - 1 ; k -- ; continue ; } break ; } if ( i == n ) i -- ; if ( k == 0 k % 2 == 0 ) { return sumArray ( arr , n ) ; } if ( i != 0 && Math . abs ( arr [ i ] ) >= Math . abs ( arr [ i - 1 ] ) ) { i -- ; } arr [ i ] *= - 1 ; return sumArray ( arr , n ) ; }
function findLargest ( m , s ) { if ( s == 0 ) { ( m == 1 ) ? document . write ( "Largest▁number▁is▁0" + 0 ) : document . write ( "Not▁possible" ) ; return ; } if ( s > 9 * m ) { document . write ( "Not▁possible" ) ; return ; } let res = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { if ( s >= 9 ) { res [ i ] = 9 ; s -= 9 ; } else { res [ i ] = s ; s = 0 ; } } document . write ( "Largest▁number▁is▁" ) ; for ( let i = 0 ; i < m ; i ++ ) document . write ( res [ i ] ) ; }
function getMax ( arr , n ) { let result = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > result ) result = arr [ i ] ; return result ; }
function isPossible ( time , K , job , n ) { let cnt = 1 ; let curr_time = 0 ; for ( let i = 0 ; i < n ; ) { if ( curr_time + job [ i ] > time ) { curr_time = 0 ; cnt ++ ; } else { curr_time += job [ i ] ; i ++ ; } } return ( cnt <= K ) ; }
function findMinTime ( K , T , job , n ) { let end = 0 , start = 0 ; for ( let i = 0 ; i < n ; ++ i ) end += job [ i ] ; let ans = end ; let job_max = getMax ( job , n ) ; while ( start <= end ) { let mid = parseInt ( ( start + end ) / 2 , 10 ) ; if ( mid >= job_max && isPossible ( mid , K , job , n ) ) { ans = Math . min ( ans , mid ) ; end = mid - 1 ; } else start = mid + 1 ; } return ( ans * T ) ; }
function findMin ( V ) { let ans = [ ] ; for ( let i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . push ( deno [ i ] ) ; } } for ( let i = 0 ; i < ans . length ; i ++ ) { document . write ( "▁" + ans [ i ] ) ; } }
function maxDiffSum ( arr , n ) { let dp = new Array ( n ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { let maxVal = arr [ i ] , minVal = arr [ i ] ; for ( let j = i ; j >= 0 ; j -- ) { minVal = Math . min ( minVal , arr [ j ] ) ; maxVal = Math . max ( maxVal , arr [ j ] ) ; if ( j - 1 >= 0 ) dp [ i ] = Math . max ( dp [ i ] , maxVal - minVal + dp [ j - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , maxVal - minVal ) ; } } return dp [ n - 1 ] ; }
function modPow ( x , y ) { let r = 1 , a = x ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) { r = ( r * a ) % MOD ; } a = ( a * a ) % MOD ; y /= 2 ; } return r ; }
function modInverse ( x ) { return modPow ( x , MOD - 2 ) ; }
function modDivision ( p , q ) { return ( p * modInverse ( q ) ) % MOD ; }
function C ( n , k ) { if ( k > n ) { return 0 ; } let p = 1 , q = 1 ; for ( let i = 1 ; i <= k ; i ++ ) { q = ( q * i ) % MOD ; p = ( p * ( n - i + 1 ) ) % MOD ; } return modDivision ( p , q ) ; }
function countArrays ( N , K ) { let res = 1 ; for ( let p = 2 ; p <= K / p ; p ++ ) { let c = 0 ; while ( K % p == 0 ) { K /= p ; c ++ ; } res = ( res * C ( N - 1 + c , c ) ) % MOD ; } if ( N > 1 ) { res = ( res * N ) % MOD ; } return res ; }
function minSessions ( codeTime , dp , ones , n , mask , currTime , WorkingSessionTime ) { if ( currTime > WorkingSessionTime ) return Number . MAX_VALUE ; if ( mask == ones ) return 1 ; if ( dp [ mask ] [ currTime ] != - 1 ) return dp [ mask ] [ currTime ] ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( mask & ( 1 << i ) ) == 0 ) { let inc = minSessions ( codeTime , dp , ones , n , mask | ( 1 << i ) , currTime + codeTime [ i ] , WorkingSessionTime ) ; let inc_next = 1 + minSessions ( codeTime , dp , ones , n , mask | ( 1 << i ) , codeTime [ i ] , WorkingSessionTime ) ; ans = Math . min ( ans , Math . min ( inc , inc_next ) ) ; } } return dp [ mask ] [ currTime ] = ans ; }
function solve ( codeTime , n , WorkingSessionTime ) { let dp = new Array ( 1 << 14 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 15 ) . fill ( - 1 ) ; } let ones = ( 1 << n ) - 1 ; let ans = minSessions ( codeTime , dp , ones , n , 0 , 0 , WorkingSessionTime ) ; if ( WorkingSessionTime < 6 ) { if ( ans % 2 == 0 ) ans = Math . floor ( ans / 2 ) ; else ans = Math . floor ( ans / 2 ) + 1 ; } return ans ; }
function solve ( len , gap ) { if ( dp [ len ] [ gap ] != - 1 ) { return dp [ len ] [ gap ] ; } if ( len == 0 gap == 0 ) { return 1 ; } if ( gap < 0 ) { return 0 ; } let ans = 0 ; for ( let i = 0 ; i <= gap ; i ++ ) { ans += solve ( len - 1 , gap - i ) ; } return dp [ len ] [ gap ] = ans ; }
function countValidStrings ( S ) { for ( let i = 0 ; i < dp . length ; i ++ ) { for ( let j = 0 ; j < dp [ i ] . length ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } let N = S . length ; let L = 1 , R = 9 ; let cnt = 0 ; let ans = 1 ; for ( let i = 0 ; i < N ; i ++ ) { if ( S [ i ] != "?" ) { R = S . charCodeAt ( i ) - "0" . charCodeAt ( 0 ) ; ans *= solve ( cnt , R - L ) ; L = R ; R = 9 ; cnt = 0 ; } else { cnt ++ ; } } ans *= solve ( cnt , R - L ) ; return ans ; }
function recBananaCnt ( A , B , C ) { if ( B <= A ) { return 0 ; } if ( B <= C ) { return B - A ; } if ( A == 0 ) { return B ; } if ( dp [ A ] [ B ] != - 1 ) { return dp [ A ] [ B ] ; } let maxCount = Number . MIN_VALUE ; let tripCount = B % C == 0 ? Math . floor ( ( 2 * B ) / C ) - 1 : Math . floor ( ( 2 * B ) / C ) + 1 ; for ( let i = 1 ; i <= A ; i ++ ) { let curCount = recBananaCnt ( A - i , B - tripCount * i , C ) ; if ( curCount > maxCount ) { maxCount = curCount ; dp [ A ] [ B ] = maxCount ; } } return maxCount ; }
function maxBananaCnt ( A , B , C ) { return recBananaCnt ( A , B , C ) ; }
function combinationsPossible ( N , idx , prev , val , K , dp ) { if ( val > K ) { return 0 ; } if ( dp [ val ] [ idx ] [ prev ] != - 1 ) { return dp [ val ] [ idx ] [ prev ] ; } if ( idx == N - 1 ) { if ( val == K ) { return 1 ; } return 0 ; } let ans = 0 ; if ( prev == 1 ) { ans += combinationsPossible ( N , idx + 1 , 1 , val + 1 , K , dp ) ; ans += combinationsPossible ( N , idx + 1 , 0 , val , K , dp ) ; } else { ans += combinationsPossible ( N , idx + 1 , 1 , val , K , dp ) ; ans += combinationsPossible ( N , idx + 1 , 0 , val , K , dp ) ; } return dp [ val ] [ idx ] [ prev ] = ans ; }
function countArray ( arr , N , M ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( M + 2 ) . fill ( 0 ) ; } if ( arr [ 0 ] == - 1 ) { for ( let j = 1 ; j <= M ; j ++ ) { dp [ 0 ] [ j ] = 1 ; } } else { dp [ 0 ] [ arr [ 0 ] ] = 1 ; } for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != - 1 ) { let j = arr [ i ] ; dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j + 1 ] ; } if ( arr [ i ] == - 1 ) { for ( let j = 1 ; j <= M ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j + 1 ] ; } } } let arrCount = 0 ; for ( let j = 1 ; j <= M ; j ++ ) { arrCount += dp [ N - 1 ] [ j ] ; } return arrCount ; }
function minChangeInLane ( barrier , n ) { let dp = [ 1 , 0 , 1 ] ; for ( let j = 0 ; j < n ; j ++ ) { let val = barrier [ j ] ; if ( val > 0 ) { dp [ val - 1 ] = 1e6 ; } for ( let i = 0 ; i < 3 ; i ++ ) { if ( val != i + 1 ) { dp [ i ] = Math . min ( dp [ i ] , Math . min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) ; } } } return Math . min ( dp [ 0 ] , Math . min ( dp [ 1 ] , dp [ 2 ] ) ) ; }
function calculate ( position , used , unused , P , M , dp ) { if ( position == P ) { return unused == 0 ? 1 : 0 ; } if ( dp [ position ] [ used ] [ unused ] != - 1 ) return dp [ position ] [ used ] [ unused ] ; let result = 0 ; if ( unused > 0 ) { result += calculate ( position + 1 , used + 1 , unused - 1 , P , M , dp ) * unused ; } if ( used > M ) { result += calculate ( position + 1 , used , unused , P , M , dp ) * ( used - M ) ; } return dp [ position ] [ used ] [ unused ] = result ; }
function solve ( N , P , M ) { var dp = new Array ( 101 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 101 ) . fill ( - 1 ) ; } for ( let i = 0 ; i < dp . length ; i ++ ) { for ( let j = 0 ; j < dp [ 0 ] . length ; j ++ ) { dp [ i ] [ j ] = new Array ( 101 ) . fill ( - 1 ) ; } } return calculate ( 0 , 0 , N , P , M , dp ) ; }
function maxMergingScore ( A , N ) { for ( let len = 1 ; len < N ; ++ len ) { for ( let i = 0 ; i + len < N ; ++ i ) { let j = i + len ; dp [ i ] [ j ] = 0 ; for ( let k = i + 1 ; k < j ; ++ k ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k ] [ j ] + A [ i ] * A [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; }
function getMin ( x , y , z ) { return Math . min ( Math . min ( x , y ) , z ) ; }
function editDistance ( str1 , str2 , m , n ) { let dp = new Array ( m + 1 ) . fill ( new Array ( n + 1 ) ) ; for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else { dp [ i ] [ j ] = 1 + getMin ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } } return dp [ m ] [ n ] ; }
function minimumSteps ( S , N ) { let ans = Number . MAX_VALUE ; for ( let i = 1 ; i < N ; i ++ ) { let S1 = S . substring ( 0 , i ) ; let S2 = S . substring ( i ) ; let count = editDistance ( S1 , S2 , S1 . length , S2 . length ) ; ans = Math . min ( ans , count ) ; } document . write ( ans - 1 ) ; }
function countOfWays ( arr , N ) { let pre = new Array ( N + 1 ) . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { pre [ i + 1 ] = pre [ i ] + arr [ i ] ; } let dp = new Array ( N + 2 ) . fill ( 0 ) . map ( ( ) => new Array ( N + 2 ) . fill ( 0 ) ) ; dp [ 1 ] [ 0 ] ++ ; let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = N ; j >= 1 ; j -- ) { dp [ j + 1 ] [ pre [ i + 1 ] % ( j + 1 ) ] += dp [ j ] [ pre [ i + 1 ] % j ] ; if ( i == N - 1 ) { ans += dp [ j ] [ pre [ i + 1 ] % j ] ; } } } return ans ; }
function minimumDifference ( arr , q , N , m ) { let diff = new Array ( N ) ; for ( let i = 0 ; i < N - 1 ; i ++ ) diff [ i ] = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; minDifference ( diff , N - 1 , q , m ) ; }
function LongestOddEvenSubarray ( A , N ) { let dp = new Array ( N ) ; dp [ 0 ] = 1 ; let ans = 1 ; for ( let i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp [ i ] = dp [ i - 1 ] + 1 ; } else dp [ i ] = 1 ; } for ( let i = 0 ; i < N ; i ++ ) ans = Math . max ( ans , dp [ i ] ) ; return ans ; }
function minimumOperations ( N ) { let dp = new Array ( N + 1 ) ; let i ; for ( i = 0 ; i <= N ; i ++ ) { dp [ i ] = 1e9 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { if ( dp [ i ] == 1e9 ) continue ; if ( i * 5 <= N ) { dp [ i * 5 ] = Math . min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= N ) { dp [ i + 3 ] = Math . min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } if ( dp [ N ] == 1e9 ) return - 1 ; return dp [ N ] ; }
function numTilings ( N ) { if ( N < 3 ) { return N ; } let dp = Array ( N + 1 ) . fill ( ) . map ( ( ) => Array ( 3 ) . fill ( 0 ) ) dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = dp [ 1 ] [ 2 ] = 1 ; for ( let i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 2 ] [ 0 ] + dp [ i - 2 ] [ 1 ] + dp [ i - 2 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 2 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) % MOD ; } return dp [ N ] [ 0 ] ; }
function SieveOfEratosthenes ( n ) { prime [ 0 ] = prime [ 1 ] = false ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } }
function countOfNumbers ( index , sum , N ) { if ( index == N + 1 ) { if ( prime [ sum ] == true ) { return 1 ; } return 0 ; } let val = dp [ index ] [ sum ] ; if ( val != - 1 ) { return val ; } val = 0 ; if ( index == 1 ) { for ( let digit = N == 1 ? 0 : 1 ; digit <= 9 ; ++ digit ) { val += countOfNumbers ( index + 1 , sum + digit , N ) ; } } else { for ( let digit = 0 ; digit <= 9 ; ++ digit ) { val += countOfNumbers ( index + 1 , sum + digit , N ) ; } } return val ; }
function countStrings ( N ) { if ( N == 1 ) return 0 ; if ( dp . has ( N ) ) return dp . get ( N ) ; let ret = 0 ; for ( let div = 1 ; div <= Math . sqrt ( N ) ; div ++ ) { if ( N % div == 0 ) { ret += ( 1 << div ) - countStrings ( div ) ; let div2 = N / div ; if ( div2 != div && div != 1 ) ret += ( 1 << div2 ) - countStrings ( div2 ) ; } } dp [ N ] = ret ; return ret ; }
function countOfNumbers ( N ) { let ans = 1 ; for ( let index = 1 ; index <= N ; ++ index ) { let choices = 0 ; for ( let digit = 1 ; digit <= 9 ; ++ digit ) { if ( index % digit == 0 ) { ++ choices ; } } ans = ( ans * 1 * choices ) % mod ; } document . write ( ans ) ; }
function MaxProfit ( arr , n , transactionFee ) { let buy = - arr [ 0 ] ; let sell = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let temp = buy ; buy = Math . max ( buy , sell - arr [ i ] ) ; sell = Math . max ( sell , temp + arr [ i ] - transactionFee ) ; } return Math . max ( sell , buy ) ; }
function dfs ( arr , left , K ) { let q = 0 ; if ( left == 0 ) { for ( let i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; q = Math . max ( q , 1 + dfs ( arr , K - i , K ) ) ; arr [ i ] ++ ; } } } else { for ( let i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; let nleft = ( i <= left ? left - i : K + left - i ) ; q = Math . max ( q , dfs ( arr , nleft , K ) ) ; arr [ i ] ++ ; } } } return q ; }
function dfs ( V , left , K ) { let q = 0 ; let key = V . join ( "," ) ; key += left . toString ( ) ; if ( memo . has ( key ) ) return memo [ key ] ; else if ( left == 0 ) { for ( let i = 1 ; i < K ; ++ i ) if ( V [ i ] > 0 ) { V [ i ] -- ; q = Math . max ( q , 1 + dfs ( V , K - i , K ) ) ; V [ i ] ++ ; } } else { for ( let i = 1 ; i < K ; ++ i ) { if ( V [ i ] > 0 ) { V [ i ] -- ; let nleft = i <= left ? left - i : K + left - i ; q = Math . max ( q , dfs ( V , nleft , K ) ) ; V [ i ] ++ ; } } } if ( memo . has ( key ) ) memo [ key ] = q ; else memo [ key ] = q ; return q ; }
function maxGroups ( K , arr ) { let V = new Array ( K ) ; V . fill ( 0 ) ; for ( let x = 0 ; x < arr . length ; x ++ ) V [ arr [ x ] % K ] ++ ; memo = new Map ( ) ; let ans = V [ 0 ] + dfs ( V , 0 , K ) ; return ans ; }
function countMinSteps ( A , B , N ) { let dp = new Array ( N + 1 ) . fill ( 0 ) ; for ( let i = 1 ; i <= N ; i ++ ) { if ( A [ i - 1 ] == B [ i - 1 ] ) { dp [ i ] = dp [ i - 1 ] ; } else { dp [ i ] = dp [ i - 1 ] + 1 ; } if ( i >= 2 && A [ i - 2 ] == B [ i - 1 ] && A [ i - 1 ] == B [ i - 2 ] ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i - 2 ] + 1 ) ; } } return dp [ N ] ; }
function findMaxJumps ( arr , N ) { let dp = new Array ( N ) . fill ( 0 ) ; let ans = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { dp [ i ] = arr [ i ] ; let j = i + arr [ i ] ; if ( j < N ) { dp [ i ] = dp [ i ] + dp [ j ] ; } ans = Math . max ( ans , dp [ i ] ) ; } document . write ( ans ) ; }
function countNDigitNumber ( N ) { document . write ( countOfNumbers ( 1 , 0 , 0 , N ) ) ; }
function getMaximum ( S , T ) { if ( S . indexOf ( "0" ) > - 1 ) return T ; if ( T . indexOf ( "0" ) > - 1 ) return S ; return S . length > T . length ? S : T ; }
function recursion ( arr , idx , N , K , dp ) { if ( K == 0 ) { return "" ; } if ( K < 0 idx == N ) { return "0" ; } if ( dp [ idx ] [ K ] != "-1" ) return dp [ idx ] [ K ] ; let include = String ( idx + 1 ) + recursion ( arr , 0 , N , K - arr [ idx ] , dp ) ; let exclude = recursion ( arr , idx + 1 , N , K , dp ) ; return ( dp [ idx ] [ K ] = getMaximum ( include , exclude ) ) ; }
function longestSubsequence ( arr , N ) { let dp = Array ( N ) . fill ( ) . map ( ( ) => Array ( N + 1 ) . fill ( - 1 ) ) ; for ( let i = 0 ; i < N ; ++ i ) { dp [ i ] [ 0 ] = 0 ; } dp [ 0 ] [ 1 ] = ( arr [ 0 ] >= 0 ? arr [ 0 ] : - 1 ) ; for ( let i = 1 ; i < N ; ++ i ) { for ( let j = 1 ; j <= ( i + 1 ) ; ++ j ) { if ( dp [ i - 1 ] [ j ] != - 1 ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } if ( dp [ i - 1 ] [ j - 1 ] >= 0 && dp [ i - 1 ] [ j - 1 ] + arr [ i ] >= 0 ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + arr [ i ] ) ; } } } let ans = 0 ; for ( let j = 0 ; j <= N ; ++ j ) { if ( dp [ N - 1 ] [ j ] >= 0 ) { ans = j ; } } document . write ( ans ) ; }
function Count ( N , L , R ) { let dp = new Array ( N ) . fill ( 0 ) . map ( ( ) => new Array ( R - L + 1 ) . fill ( 0 ) ) ; let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( let i = 1 ; i < dp [ 0 ] . length ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 1 ; } ans = dp [ 0 ] [ R - L ] ; for ( let i = 1 ; i < N ; i ++ ) { for ( let j = 1 ; j < dp [ 0 ] . length ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } ans += dp [ i ] [ R - L ] ; } return ans ; }
function largestCommonSubarray ( arr , n , m ) { let dp = Array ( n ) . fill ( ) . map ( ( ) => Array ( m + 1 ) ) ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { dp [ i ] [ arr [ i ] [ j ] ] = j ; } } let ans = 1 ; let len = 1 ; for ( let i = 1 ; i < m ; i ++ ) { let check = true ; for ( let j = 1 ; j < n ; j ++ ) { if ( dp [ j ] [ arr [ 0 ] [ i - 1 ] ] + 1 != dp [ j ] [ arr [ 0 ] [ i ] ] ) { check = false ; break ; } } if ( check ) { len ++ ; ans = Math . max ( ans , len ) ; } else { len = 1 ; } } return ans ; }
function countOfNumbers ( digit , prev1 , prev2 , n ) { if ( digit == n + 1 ) { return 1 ; } var val = dp [ digit ] [ prev1 ] [ prev2 ] ; if ( val != - 1 ) { return val ; } val = 0 ; if ( digit == 1 ) { for ( var i = ( n == 1 ? 0 : 1 ) ; i <= 9 ; ++ i ) { val += countOfNumbers ( digit + 1 , i , prev1 , n ) ; } } else if ( digit == 2 ) { for ( var i = 0 ; i <= 9 ; ++ i ) { val += countOfNumbers ( digit + 1 , i , prev1 , n ) ; } } else { var mean = prev1 ; var current = ( 2 * mean ) - prev2 ; if ( current >= 0 && current <= 9 ) val += countOfNumbers ( digit + 1 , current , prev1 , n ) ; if ( ( current + 1 ) >= 0 && ( current + 1 ) <= 9 ) val += countOfNumbers ( digit + 1 , current + 1 , prev1 , n ) ; } return val ; }
function countOfNumbers ( digit , prev , n ) { if ( digit == n + 1 ) { return 1 ; } let val = dp [ digit ] [ prev ] ; if ( val != - 1 ) { return val ; } val = 0 ; if ( digit == 1 ) { for ( let i = ( n == 1 ? 0 : 1 ) ; i <= 9 ; ++ i ) { val += countOfNumbers ( digit + 1 , i , n ) ; } } else { for ( let i = 0 ; i <= 9 ; ++ i ) { if ( ( i & prev ) == 0 ) { val += countOfNumbers ( digit + 1 , i , n ) ; } } } return val ; }
function totalSubarrays ( arr , n , k ) { let ans = 0 , i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } let count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } ans += ( Math . floor ( ( count * ( count + 1 ) ) / 2 ) ) ; } return ans ; }
function countSubarrays ( arr , n , k ) { let count1 = totalSubarrays ( arr , n , k - 1 ) ; let count2 = totalSubarrays ( arr , n , k ) ; let ans = count2 - count1 ; return ans ; }
function MaximumSum ( a , b , n ) { let dp = new Array ( n ) . fill ( 0 ) . map ( ( ) => new Array ( 2 ) ) ; dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = b [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i ] ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; if ( i - 2 >= 0 ) { dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , Math . max ( dp [ i - 2 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + b [ i ] ) ; } else { dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , b [ i ] ) ; } } return Math . max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
function numberOfArrays ( n , l ) { let dp = Array ( l + 1 ) . fill ( ) . map ( ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; dp [ 0 ] [ 1 ] = 1 ; for ( let i = 0 ; i < l ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { for ( let k = j ; k <= n ; k += j ) { dp [ i + 1 ] [ k ] += dp [ i ] [ j ] ; } } } let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { ans += dp [ l ] [ i ] ; } return ans ; }
function waysOfDecoding ( s ) { let dp = new Array ( s . length + 1 ) ; for ( let i = 0 ; i < s . length + 1 ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == "*" ? 9 : s [ 0 ] == "0" ? 0 : 1 ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == "*" ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == "1" ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == "2" ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == "*" ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != "0" ? dp [ i ] : 0 ; if ( s [ i - 1 ] == "1" ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == "2" && s [ i ] <= "6" ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == "*" ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= "6" ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return dp [ s . length ] ; }
function KvisibleFromLeft ( N , K ) { if ( dp [ N ] [ K ] != - 1 ) return dp [ N ] [ K ] ; if ( N == K ) return dp [ N ] [ K ] = 1 ; if ( K == 1 ) { let ans = 1 ; for ( let i = 1 ; i < N ; i ++ ) ans *= i ; return dp [ N ] [ K ] = ans ; } return dp [ N ] [ K ] = KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; }
function minimumDeletions ( A , N ) { let ans = Number . MAX_SAFE_INTEGER ; for ( let i = 1 ; i < ( 1 << N ) ; i ++ ) { let temp = [ ] ; for ( let j = 0 ; j < N ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) { temp . push ( A [ j ] ) ; } } let flag = 0 ; for ( let j = 1 ; j < temp . length ; j ++ ) if ( temp [ j ] < temp [ j - 1 ] ) flag = 1 ; for ( let j = 1 ; j < temp . length - 1 ; j ++ ) if ( temp [ j ] - temp [ j - 1 ] > temp [ j + 1 ] - temp [ j ] ) flag = 1 ; if ( flag == 0 ) { ans = Math . min ( ans , N - temp . length ) ; } } return ans ; }
function kvowelwords ( N , K ) { let i , j ; let MOD = 1000000007 ; let dp = new Array ( N + 1 )  for ( i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( K + 1 ) ; } let sum = 1 ; for ( i = 1 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = sum * 21 ; dp [ i ] [ 0 ] %= MOD ; sum = dp [ i ] [ 0 ] ; for ( j = 1 ; j <= K ; j ++ ) { if ( j > i ) dp [ i ] [ j ] = 0 ; else if ( j == i ) { dp [ i ] [ j ] = power ( 5 , i , MOD ) ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] * 5 ; } dp [ i ] [ j ] %= MOD ; sum += dp [ i ] [ j ] ; sum %= MOD ; } } return sum ; }
function maximumSum ( A , N , K , D ) { let ans = 0 ; for ( let i = 0 ; i < ( 1 << N ) ; i ++ ) { let sum = 0 ; let c = 0 ; for ( let j = 0 ; j < N ; j ++ ) { if ( i >> j & 1 ) { sum += A [ j ] ; c ++ ; } } if ( sum % D == 0 && c <= K ) ans = Math . max ( ans , sum ) ; } return ans ; }
function maxSumWO3Consec ( A , N ) { if ( N == 1 ) return A [ 0 ] ; if ( N == 2 ) return A [ 0 ] + A [ 1 ] ; let third = A [ 0 ] ; let second = third + A [ 1 ] ; let first = Math . max ( second , A [ 1 ] + A [ 2 ] ) ; let sum = Math . max ( Math . max ( third , second ) , first ) ; for ( let i = 3 ; i < N ; i ++ ) { sum = Math . max ( Math . max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) ; third = second ; second = first ; first = sum ; } return sum ; }
function longestSubsequence ( X , Y ) { let n = X . length ; let m = Y . length ; let mat = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { mat [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j < m + 1 ; j ++ ) { if ( i == 0 j == 0 ) mat [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i < n + 1 ; i ++ ) { for ( let j = 1 ; j < m + 1 ; j ++ ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { mat [ i ] [ j ] = 1 + mat [ i - 1 ] [ j - 1 ] ; } else { mat [ i ] [ j ] = mat [ i - 1 ] [ j ] ; } } } let len = 0 , col = 0 ; for ( let i = 0 ; i < m + 1 ; i ++ ) { if ( mat [ n ] [ i ] > len ) { len = mat [ n ] [ i ] ; col = i ; } } let res = "" ; let i = n ; let j = col ; while ( len > 0 ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { res = X [ i - 1 ] + res ; i -- ; j -- ; len -- ; } else { i -- ; } } return res ; }
function calculateStart ( n , m ) { for ( var i = 1 ; i < m ; ++ i ) { start [ 0 ] [ i ] += start [ 0 ] [ i - 1 ] ; } for ( var i = 1 ; i < n ; ++ i ) { start [ i ] [ 0 ] += start [ i - 1 ] [ 0 ] ; } for ( var i = 1 ; i < n ; ++ i ) { for ( var j = 1 ; j < m ; ++ j ) { start [ i ] [ j ] += Math . max ( start [ i - 1 ] [ j ] , start [ i ] [ j - 1 ] ) ; } } }
function calculateEnd ( n , m ) { for ( var i = n - 2 ; i >= 0 ; -- i ) { ending [ i ] [ m - 1 ] += ending [ i + 1 ] [ m - 1 ] ; } for ( var i = m - 2 ; i >= 0 ; -- i ) { ending [ n - 1 ] [ i ] += ending [ n - 1 ] [ i + 1 ] ; } for ( var i = n - 2 ; i >= 0 ; -- i ) { for ( var j = m - 2 ; j >= 0 ; -- j ) { ending [ i ] [ j ] += Math . max ( ending [ i + 1 ] [ j ] , ending [ i ] [ j + 1 ] ) ; } } }
function maximumPathSum ( mat , n , m , q , coordinates ) { for ( var i = 0 ; i < n ; ++ i ) { for ( var j = 0 ; j < m ; ++ j ) { start [ i ] [ j ] = mat [ i ] [ j ] ; ending [ i ] [ j ] = mat [ i ] [ j ] ; } } calculateStart ( n , m ) ; calculateEnd ( n , m ) ; var ans = 0 ; for ( var i = 0 ; i < q ; ++ i ) { var X = coordinates [ i ] [ 0 ] - 1 ; var Y = coordinates [ i ] [ 1 ] - 1 ; ans = Math . max ( ans , start [ X ] [ Y ] + ending [ X ] [ Y ] - mat [ X ] [ Y ] ) ; } document . write ( ans ) ; }
function countAlternatingSubstrings ( S , N ) { var dp = new Array ( 2 ) ; dp [ 0 ] = Array ( N ) . fill ( 0 ) ; dp [ 1 ] = Array ( N ) . fill ( 0 ) ; var i ; for ( i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 ) { if ( S [ i ] == "1" ) dp [ 1 ] [ i ] = 1 ; else dp [ 0 ] [ i ] = 1 ; } else { if ( S [ i ] == "0" ) dp [ 0 ] [ i ] = 1 + dp [ 1 ] [ i + 1 ] ; else dp [ 1 ] [ i ] = 1 + dp [ 0 ] [ i + 1 ] ; } } var ans = 0 ; for ( i = 0 ; i < N ; i ++ ) { ans += Math . max ( dp [ 0 ] [ i ] , dp [ 1 ] [ i ] ) ; } return ans ; }
function countSubset ( arr , n , diff ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum += diff ; sum = sum / 2 ; var t = new Array ( n + 1 ) ; for ( var i = 0 ; i < t . length ; i ++ ) { t [ i ] = new Array ( sum + 1 ) ; } for ( var i = 0 ; i < t . length ; i ++ ) { for ( var j = 0 ; j < t [ i ] . length ; j ++ ) { t [ i ] [ j ] = 0 ; } } for ( var j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ; for ( var i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } } return t [ n ] [ sum ] ; }
function maximizeAnd ( i , mask , A , B , N , dp ) { if ( i == N ) return 0 ; if ( dp [ i ] [ mask ] != - 1 ) return dp [ i ] [ mask ] ; for ( var j = 0 ; j < N ; ++ j ) { if ( ! ( mask & ( 1 << j ) ) ) { dp [ i ] [ mask ] = Math . max ( dp [ i ] [ mask ] , ( A [ i ] & B [ j ] ) + maximizeAnd ( i + 1 , mask | ( 1 << j ) , A , B , N , dp ) ) ; } } return dp [ i ] [ mask ] ; }
function maximizeAndUtil ( A , B , N ) { var dp = Array . from ( Array ( N ) , ( ) => Array ( 1 << N + 1 ) . fill ( - 1 ) ) ; return maximizeAnd ( 0 , 0 , A , B , N , dp ) ; }
function countOfNumbers ( digit , prev1 , prev2 , N ) { if ( digit == N + 1 ) return 1 ; if ( dp [ digit ] [ prev1 ] [ prev2 ] != - 1 ) return dp [ digit ] [ prev1 ] [ prev2 ] ; dp [ digit ] [ prev1 ] [ prev2 ] = 0 ; if ( digit == 1 ) { for ( var j = ( N == 1 ? 0 : 1 ) ; j <= 9 ; ++ j ) { dp [ digit ] [ prev1 ] [ prev2 ] += countOfNumbers ( digit + 1 , j , prev1 , N ) ; } } else if ( digit == 2 ) { for ( var j = 0 ; j <= 9 ; ++ j ) { dp [ digit ] [ prev1 ] [ prev2 ] += countOfNumbers ( digit + 1 , j , prev1 , N ) ; } } else { for ( var j = 0 ; j <= Math . abs ( prev1 - prev2 ) ; ++ j ) { dp [ digit ] [ prev1 ] [ prev2 ] += countOfNumbers ( digit + 1 , j , prev1 , N ) ; } } return dp [ digit ] [ prev1 ] [ prev2 ] ; }
function findNthNum ( N ) { let a = 0 , b , left ; let right , mid ; let t , last_num = 0 ; left = 1 ; right = N ; while ( left <= right ) { mid = left + ( right - left ) / 2 ; t = ( mid * ( mid + 1 ) ) / 2 ; if ( t < N ) { left = mid + 1 ; } else if ( t == N ) { a = mid ; break ; } else { a = mid ; right = mid - 1 ; } } t = a - 1 ; b = N - ( t * ( t + 1 ) ) / 2 - 1 ; document . write ( ( 1 << a ) + ( 1 << b ) ) ; }
function longestSubWithMaxSum ( arr , N ) { let Max = Math . max ( ... arr ) ; if ( Max < 0 ) { document . write ( Max ) ; return ; } for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 0 ) { document . write ( arr [ i ] + "▁" ) ; } } }
function maxSumUtil ( arr , n ) { document . write ( maxSum ( arr , 0 , n , 2 , 0 ) ) ; }
function maximumSum ( arr , n ) { let preSum = Array . from ( { length : n } , ( _ , i ) => 0 ) ; let sum = 0 ; let maxSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = Math . max ( arr [ i ] , sum + arr [ i ] ) ; maxSum = Math . max ( maxSum , sum ) ; preSum [ i ] = maxSum ; } sum = 0 ; maxSum = 0 ; let postSum = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; for ( let i = n - 1 ; i >= 0 ; i -- ) { sum = Math . max ( arr [ i ] , sum + arr [ i ] ) ; maxSum = Math . max ( maxSum , sum ) ; postSum [ i ] = maxSum ; } let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , preSum [ i ] + postSum [ i + 1 ] ) ; } document . write ( ans ) ; }
function NumberOfways ( N , K ) { let dp = Array . from ( { length : N + 1 } , ( _ , i ) => 0 ) ; dp [ 0 ] = 1 ; for ( let row = 1 ; row < K + 1 ; row ++ ) { for ( let col = 1 ; col < N + 1 ; col ++ ) { if ( col >= row ) dp [ col ] = dp [ col ] + dp [ col - row ] ; } } return ( dp [ N ] ) ; }
function findAPSequence ( arr , N , Q , M ) { var dp = Array ( N + 5 ) . fill ( 0 ) ; for ( i = 0 ; i + 1 < N ; ) { var j = i + 1 ; while ( j + 1 < N && arr [ j + 1 ] - arr [ j ] == arr [ i + 1 ] - arr [ i ] ) j ++ ; for ( k = i ; k < j ; k ++ ) { dp [ k ] = j - k ; } i = j ; } for ( i = 0 ; i < M ; i ++ ) { if ( dp [ Q [ i ] [ 0 ] ] >= Q [ i ] [ 1 ] - Q [ i ] [ 0 ] ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } } }
function isUnique ( s ) { var set = new Set ( ) ; for ( let i = 0 ; i < s . length ; i ++ ) { set . add ( s [ i ] ) ; } return set . size == 1 ; }
function maxScore ( s , a ) { let n = s . length ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; let mx = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let sub = s . substring ( i , j + 1 ) ; if ( isUnique ( sub ) ) mx = Math . max ( mx , a [ sub . length - 1 ] + maxScore ( s . substring ( 0 , i ) + s . substring ( j + 1 ) , a ) ) ; } } return mx ; }
function numberOfUniqueOutcomes ( N , S ) { if ( S < N ) return 0 ; if ( N == 1 N == S ) return 1 ; return ( numberOfUniqueOutcomes ( N - 1 , S - 1 ) + numberOfUniqueOutcomes ( N - 1 , S - 2 ) ) ; }
function numberOfUniqueOutcomes ( n , s ) { if ( s < n ) ans [ n ] [ s ] = 0 ; else if ( n == 1 n == s ) ans [ n ] [ s ] = 1 ; else if ( ans [ n ] [ s ] == 0 ) { ans [ n ] [ s ] = numberOfUniqueOutcomes ( n - 1 , s - 1 ) + numberOfUniqueOutcomes ( n - 1 , s - 2 ) ; } return ans [ n ] [ s ] ; }
function MinimumLength ( A , N , K ) { 0 A . sort ( ) ; var suffix = Array ( N + 1 ) . fill ( 0 ) ; var i ; for ( i = N - 1 ; i >= 0 ; i -- ) suffix [ i ] = suffix [ i + 1 ] + A [ i ] ; var dp = new Array ( N + 1 ) ; for ( i = 0 ; i < N + 1 ; i ++ ) dp [ i ] = new Array ( K + 1 ) ; var j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= K ; j ++ ) { dp [ i ] [ j ] = max1 ; } } ; dp [ N ] [ 0 ] = 0 ; for ( i = N - 1 ; i >= 0 ; i -- ) { for ( j = K ; j >= 0 ; j -- ) { if ( j <= A [ i ] ) { dp [ i ] [ j ] = A [ i ] ; continue ; } if ( dp [ i + 1 ] [ j - A [ i ] ] == max1 ) dp [ i ] [ j ] = max1 ; else dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ j ] , dp [ i + 1 ] [ j - A [ i ] ] + A [ i ] ) ; } } for ( i = N - 1 ; i >= 0 ; i -- ) { if ( suffix [ i ] - dp [ i ] [ K ] >= K ) { return N - i ; } } return - 1 ; }
function countXOR ( arr , comb , start , end , index , r ) { if ( index == r ) { let new_xor = 0 ; for ( let j = 0 ; j < r ; j ++ ) { new_xor ^= comb [ j ] ; } s . add ( new_xor ) ; return ; } for ( let i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { comb [ index ] = arr [ i ] ; countXOR ( arr , comb , i + 1 , end , index + 1 , r ) ; } }
function maxSizeSet ( arr , N ) { for ( let r = 1 ; r <= N ; r ++ ) { let comb = new Array ( r + 1 ) ; countXOR ( arr , comb , 0 , N - 1 , 0 , r ) ; } document . write ( s . size ) ; }
function maxSizeSet ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { insertVector ( arr [ i ] ) ; } document . write ( 1 << ans ) ; }
function waysToPaint ( n ) { var same = 6 ; var diff = 6 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { var sameTmp = 3 * same + 2 * diff ; var diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } document . write ( same + diff ) ; }
function printMinimumRemovals ( str , X ) { let N = str . length ; let M = X . length ; let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( M ) ; for ( let j = 0 ; j < M ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let j = 0 ; j < M ; j ++ ) { if ( str [ 0 ] == X [ j ] ) { dp [ 0 ] [ j ] = 1 ; } } for ( let i = 1 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( str [ i ] == X [ j ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + 1 ; if ( j != 0 ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } } document . write ( dp [ N - 1 ] [ M - 1 ] ) ; }
function maxSubarraySum ( sum , k , row ) { let curSum = 0 , curMax = Number . MIN_VALUE ; let sumSet = new Set ( ) ; sumSet . add ( 0 ) ; for ( let r = 0 ; r < row ; ++ r ) { curSum += sum [ r ] ; let list = [ ] ; list = Array . from ( sumSet ) ; let it = list . lastIndexOf ( curSum - k ) ; if ( it > - 1 ) { curMax = Math . max ( curMax , curSum - it ) ; } sumSet . add ( curSum ) ; } return curMax ; }
function maxSumSubmatrix ( matrix , k ) { let row = matrix . length ; let col = matrix [ 0 ] . length ; let ret = Number . MIN_VALUE ; for ( let i = 0 ; i < col ; ++ i ) { let sum = new Array ( row ) ; for ( let j = 0 ; j < row ; j ++ ) sum [ j ] = 0 ; for ( let j = i ; j < col ; ++ j ) { for ( let r = 0 ; r < row ; ++ r ) { sum [ r ] += matrix [ r ] [ j ] ; } let curMax = maxSubarraySum ( sum , k , row ) ; ret = Math . max ( ret , curMax ) ; } } document . write ( ret ) ; }
function minCost ( arr , n ) { if ( n < 3 ) { document . write ( arr [ 0 ] ) ; return ; } let dp = [ ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( let i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = Math . min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = Math . min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; document . write ( dp [ n - 1 ] ) ; }
function maxSum ( arr , N , K ) { let dp = [ ] ; for ( let i = 0 ; i < N + 2 ; i ++ ) { dp [ i ] = 0 ; } let maxval = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( ( i + K * arr [ i ] ) >= N ) { dp [ i ] = arr [ i ] ; } else { dp [ i ] = dp [ i + K * arr [ i ] ] + arr [ i ] ; } maxval = Math . max ( maxval , dp [ i ] ) ; } document . write ( maxval ) ; }
function maxSubmatrixSum ( matrix ) { var r = matrix . length ; var c = matrix [ 0 ] . length ; var maxSubmatrix = 0 ; for ( i = 0 ; i < r ; i ++ ) { for ( j = 0 ; j < c ; j ++ ) { for ( k = i ; k < r ; k ++ ) { for ( l = j ; l < c ; l ++ ) { var sumSubmatrix = 0 ; for ( m = i ; m <= k ; m ++ ) { for ( n = j ; n <= l ; n ++ ) { sumSubmatrix += matrix [ m ] [ n ] ; } } maxSubmatrix = Math . max ( maxSubmatrix , sumSubmatrix ) ; } } } } document . write ( maxSubmatrix ) ; }
function kadane ( v ) { let currSum = 0 ; let maxSum = Number . MIN_VALUE ; for ( let i = 0 ; i < v . length ; i ++ ) { currSum += v [ i ] ; if ( currSum > maxSum ) { maxSum = currSum ; } if ( currSum < 0 ) { currSum = 0 ; } } return maxSum ; }
function minCost ( costs , N ) { if ( N == 0 ) return 0 ; let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] ; dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] ; dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] ; for ( let i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = Math . min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] ; dp [ i ] [ 1 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] ; dp [ i ] [ 2 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] ; } document . write ( Math . min ( dp [ N - 1 ] [ 0 ] , Math . min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ) ; }
function findCnt ( arr , i , required_sum , n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = 1 ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; }
function countSubsets ( arr , K , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } var S1 = ( sum + K ) / 2 ; document . write ( findCnt ( arr , 0 , S1 , n ) ) ; }
function solve ( A , i , sum , N ) { let res = 2001 ; if ( sum < 0 || ( i == N && sum != 0 ) ) { return 2001 ; } if ( sum == 0 i >= N ) { dp [ i ] [ sum ] = 0 ; return dp [ i ] [ sum ] ; } if ( dp [ i ] [ sum ] != - 1 ) { return dp [ i ] [ sum ] ; } res = Math . min ( solve ( A , i + 1 , sum - A [ i ] , N ) + 1 , solve ( A , i + 1 , sum , N ) ) ; dp [ i ] [ sum ] = res ; return dp [ i ] [ sum ] ; }
function daysToCure ( arr , N , P ) { var risk = 0 ; var normal_risk = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 60 arr [ i ] <= 10 ) { risk ++ ; } else { normal_risk ++ ; } } var days = parseInt ( ( risk / P ) + ( normal_risk / P ) ) ; if ( risk % P > 0 ) { days ++ ; } if ( normal_risk % P > 0 ) { days ++ ; } document . write ( days ) ; }
function countAverage ( n , K , arr ) { dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var k = 0 ; k < n ; k ++ ) { for ( var s = 0 ; s <= 1000 ; s ++ ) { dp [ i + 1 ] [ k + 1 ] [ s + arr [ i ] ] += dp [ i ] [ k ] [ s ] ; dp [ i + 1 ] [ k ] [ s ] += dp [ i ] [ k ] [ s ] ; } } } var cnt = 0 ; for ( var j = 1 ; j <= n ; j ++ ) { cnt += dp [ n ] [ j ] [ K * j ] ; } return cnt ; }
function maximumSubsetSum ( arr1 , arr2 , length ) { let dp = new Array ( length ) . fill ( 0 ) ; ; if ( length == 1 ) { document . write ( Math . max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ; return ; } if ( length == 2 ) { document . write ( Math . max ( Math . max ( arr1 [ 1 ] , arr2 [ 1 ] ) , Math . max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ) ; return ; } else { dp [ 0 ] = Math . max ( arr1 [ 0 ] , arr2 [ 0 ] ) ; dp [ 1 ] = Math . max ( Math . max ( arr1 [ 1 ] , arr2 [ 1 ] ) , Math . max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ; let index = 2 ; while ( index < length ) { dp [ index ] = Math . max ( Math . max ( arr1 [ index ] , arr2 [ index ] ) , Math . max ( Math . max ( arr1 [ index ] + dp [ index - 2 ] , arr2 [ index ] + dp [ index - 2 ] ) , dp [ index - 1 ] ) ) ; ++ index ; } document . write ( dp [ length - 1 ] ) ; } }
function FindMaxS ( X , Y , Z , n , A , B , C ) { if ( X < 0 Y < 0 Z < 0 ) return Number . MIN_VALUE ; if ( n < 0 ) return 0 ; if ( dp [ n ] [ X ] [ Y ] [ Z ] != - 1 ) { return dp [ n ] [ X ] [ Y ] [ Z ] ; } let ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; let ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; let co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; let no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; let maximum = Math . max ( ch , Math . max ( ca , Math . max ( co , no ) ) ) ; dp [ n ] [ X ] [ Y ] [ Z ] = maximum ; return dp [ n ] [ X ] [ Y ] [ Z ] ; }
function findCount ( N , maxDigit ) { let position = 0 ; let previous = 0 ; let count = 1 ; let ans = findCountUtil ( N , maxDigit , position , previous , count ) ; document . write ( ans ) ; }
function find ( N , sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } let s = 0 ; for ( let i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; }
function find ( N , sum ) { if ( N < 0 sum < 0 ) return 0 ; if ( dp [ N ] [ sum ] > 0 ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return ( 1.0 / 6 ) ; else return 0 ; } for ( var i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; }
function find ( N , a , b ) { let probability = 0.0 ; for ( let i = 1 ; i <= 6 ; i ++ ) dp [ 1 ] [ i ] = ( 1.0 / 6 ) ; for ( let i = 2 ; i <= N ; i ++ ) { for ( let j = i ; j <= 6 * i ; j ++ ) { for ( let k = 1 ; k <= 6 && k <= j ; k ++ ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 ; } } } for ( let sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N ] [ sum ] ; return probability ; }
function minAtEachIndex ( n , arr ) { var dp1 = Array ( n ) ; var dp2 = Array ( n ) ; var i ; dp1 [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) dp1 [ i ] = Math . min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) ; dp2 [ n - 1 ] = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) dp2 [ i ] = Math . min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) ; var v = [ ] ; for ( i = 0 ; i < n ; i ++ ) v . push ( Math . min ( dp1 [ i ] , dp2 [ i ] ) ) ; v . forEach ( x => { document . write ( x + "▁" ) ; } ) ; }
function totalArrays ( N , M ) { var end_with_one = Array ( N + 1 ) ; var end_not_with_one = Array ( N + 1 ) ; end_with_one [ 0 ] = 1 ; end_not_with_one [ 0 ] = 0 ; end_with_one [ 1 ] = 0 ; end_not_with_one [ 1 ] = M - 1 ; for ( var i = 2 ; i < N ; i ++ ) { end_with_one [ i ] = end_not_with_one [ i - 1 ] ; end_not_with_one [ i ] = end_with_one [ i - 1 ] * ( M - 1 ) + end_not_with_one [ i - 1 ] * ( M - 2 ) ; } return end_with_one [ N - 1 ] ; }
function prodOfDigit ( N ) { let res = 1 ; while ( N ) { res = res * ( N % 10 ) ; N = Math . floor ( N / 10 ) ; } return res ; }
function cntNum ( X , i , prod , K , st , tight , dp ) { if ( i >= X . length prod > K ) { return prod == K ? 1 : 0 ; } if ( dp [ prod ] [ i ] [ tight ] [ st ] != - 1 ) { return dp [ prod ] [ i ] [ tight ] [ st ] ; } let res = 0 ; let end = tight > 0 ? X [ i ] - "0" : 9 ; for ( let j = 0 ; j <= end ; j ++ ) { if ( j == 0 && st == 0 ) { res += cntNum ( X , i + 1 , prod , K , 0 , ( tight & ( ( j == end ) ? 1 : 0 ) ) , dp ) ; } else { res += cntNum ( X , i + 1 , prod * j , K , 1 , ( tight & ( ( j == end ) ? 1 : 0 ) ) , dp ) ; } } return dp [ prod ] [ i ] [ tight ] [ st ] = res ; }
function power ( X , Y ) { var res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( ( Y & 1 ) != 0 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; }
function findValue ( n ) { var X = 0 ; var pow_10 = 1 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) { X += pow_10 ; } pow_10 *= 10 ; n /= 2 ; } X = ( X * 2 ) % M ; var res = power ( 2 , X ) ; return res ; }
function mod_pow2 ( n ) { while ( n >= MEM . length ) MEM . push ( ( MEM [ MEM . length - 1 ] * 2 ) % MOD ) ; return MEM [ n ] ; }
function inversions ( bstr ) { let total = 0 , zeros = 0 , questions = 0 ; bstr . reverse ( ) ; for ( let i = 0 ; i < bstr . length ; i ++ ) { let q ; if ( bstr [ i ] == "1" ) { let z = zeros * mod_pow2 ( questions ) ; if ( questions == 0 ) q = 0 ; else q = questions * mod_pow2 ( questions - 1 ) ; total = ( total + z + q ) % MOD ; } else if ( bstr [ i ] == "0" ) { zeros += 1 ; } else { total *= 2 ; let z = zeros * mod_pow2 ( questions ) ; if ( questions == 0 ) q = 0 ; else q = questions * mod_pow2 ( questions - 1 ) ; total = ( total + z + q ) % MOD ; questions += 1 ; } } return total ; }
function findMedXOR ( mat , N , M ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) dp [ i ] = new Array ( M ) ; let med = new Array ( N * M ) ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; med [ 0 ] = dp [ 0 ] [ 0 ] ; let len = 1 ; for ( let i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ^ mat [ i ] [ 0 ] ; med [ len ++ ] = dp [ i ] [ 0 ] ; } for ( let i = 1 ; i < M ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ^ mat [ 0 ] [ i ] ; med [ len ++ ] = dp [ 0 ] [ i ] ; } for ( let i = 1 ; i < N ; i ++ ) { for ( let j = 1 ; j < M ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ^ dp [ i ] [ j - 1 ] ^ dp [ i - 1 ] [ j - 1 ] ^ mat [ i ] [ j ] ; med [ len ++ ] = dp [ i ] [ j ] ; } } med . sort ( ) ; if ( len % 2 == 0 ) { return ( med [ parseInt ( len / 2 ) ] + med [ parseInt ( len / 2 ) - 1 ] ) / 2.0 ; } return med [ parseInt ( len / 2 ) ] ; }
function countTriplets ( A ) { var cnt = 0 ; var tuples = new Map ( ) ; A . forEach ( a => { A . forEach ( b => { if ( tuples . has ( a & b ) ) tuples . set ( a & b , tuples . get ( a & b ) + 1 ) else tuples . set ( a & b , 1 ) } ) ; } ) ; A . forEach ( a => { tuples . forEach ( ( value , key ) => { if ( ( key & a ) == 0 ) cnt += value ; } ) ; } ) ; return cnt ; }
function countVowelPermutation ( n ) { let MOD = ( 1e9 + 7 ) ; let dp = new Array ( n + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < 5 ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } let relation = [ [ 1 ] , [ 0 , 2 ] , [ 0 , 1 , 3 , 4 ] , [ 2 , 4 ] , [ 0 ] ] ; for ( let i = 1 ; i < n ; i ++ ) { for ( let u = 0 ; u < 5 ; u ++ ) { dp [ i + 1 ] [ u ] = 0 ; for ( let v in relation [ u ] ) { dp [ i + 1 ] [ u ] += dp [ i ] [ v ] % MOD ; } } } let ans = 0 ; for ( let i = 0 ; i < 5 ; i ++ ) { ans = ( ans + dp [ n ] [ i ] ) % MOD ; } return ans ; }
function MaximumSubarraySum ( n , arr , k ) { var dp = Array . from ( Array ( M ) , ( ) => Array ( M ) . fill ( - 1 ) ) ; mxSubSum ( n - 1 , arr , k , dp ) ; var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j <= k ; j ++ ) { res = Math . max ( res , dp [ i ] [ j ] ) ; } } if ( arr . reduce ( ( a , b ) => Math . max ( a , b ) ) < 0 ) { res = arr . reduce ( ( a , b ) => Math . max ( a , b ) ) ; } return res ; }
function countWaysToTileBoard ( N ) { let dp = [ ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( let i = 2 ; i <= N ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; } document . write ( dp [ N ] ) ; }
function DFS ( node , parent , Val ) { answer [ node ] = Val [ node ] ; for ( let child of adj [ node ] ) { if ( child == parent ) continue ; DFS ( child , node , Val ) ; answer [ node ] = ( answer [ node ] answer [ child ] ) ; } }
function preprocess ( Val ) { DFS ( 1 , - 1 , Val ) ; }
function findSubtreeOR ( Queries , Q , Val ) { preprocess ( Val ) ; for ( let i = 0 ; i < Q ; i ++ ) { document . write ( answer [ Queries [ i ] ] + "▁" ) ; } }
function minCost ( arr , n ) { arr . sort ( ) ; let m = 2 * n ; let cost = new Array ( n + 1 ) ; for ( var i = 0 ; i < cost . length ; i ++ ) { cost [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= m ; j ++ ) { cost [ i ] [ j ] = INF ; } } cost [ 0 ] [ 0 ] = 0 ; let prev = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { prev = cost [ i - 1 ] [ 0 ] ; for ( let j = 1 ; j <= m ; j ++ ) { cost [ i ] [ j ] = Math . min ( cost [ i ] [ j ] , prev + Math . abs ( j - arr [ i - 1 ] ) ) ; prev = Math . min ( prev , cost [ i - 1 ] [ j ] ) ; } } let minCost = INF ; for ( let j = 1 ; j <= m ; j ++ ) { minCost = Math . min ( minCost , cost [ n ] [ j ] ) ; } document . write ( minCost ) ; }
function FindSub ( str , res , i ) { if ( i === str . length ) { if ( res . length > 0 ) { document . write ( res + "▁" ) ; } return ; } var ch = str [ i ] ; FindSub ( str , res , i + 1 ) ; FindSub ( str , res + ch , i + 1 ) ; FindSub ( str , res + ch . charCodeAt ( 0 ) , i + 1 ) ; }
function MinOp ( N ) { if ( N <= 1 ) return N ; let bit = ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << bit ) - 1 ) - MinOp ( N - ( 1 << ( bit - 1 ) ) ) ; }
function max ( a , b ) { return a > b ? a : b ; }
function maximumsum ( arr , K , N , M ) { let sum = 0 , maxSum ; let i , j , k ; let dp = new Array ( K + 1 ) ; for ( i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( i = 0 ; i <= N ; i ++ ) dp [ 0 ] [ i ] = 0 ; for ( i = 0 ; i <= K ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( i = 1 ; i <= K ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { sum = 0 ; maxSum = dp [ i ] [ j ] ; for ( k = 1 ; k <= M && k <= i ; k ++ ) { sum += arr [ j ] [ k - 1 ] ; maxSum = Math . max ( maxSum , sum + dp [ i - k ] [ j ] ) ; } dp [ i ] [ j + 1 ] = maxSum ; } } return dp [ K ] [ N ] ; }
function check ( memo , i , j , A ) { if ( i == N - 1 ) return 1 ; if ( memo [ i ] [ j ] != - 1 ) return memo [ i ] [ j ] ; let flag = 0 , k ; for ( k = i + 1 ; k < N ; k ++ ) { if ( A [ k ] - A [ i ] > j + 1 ) break ; if ( A [ k ] - A [ i ] >= j - 1 && A [ k ] - A [ i ] <= j + 1 ) flag = check ( memo , k , A [ k ] - A [ i ] , A ) ; if ( flag != 0 ) break ; } memo [ i ] [ j ] = flag ; return memo [ i ] [ j ] ; }
function checkEndReach ( A , K ) { let memo = new Array ( N ) ; for ( var i = 0 ; i < memo . length ; i ++ ) { memo [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { memo [ i ] [ j ] = - 1 ; } } let startIndex = 1 ; if ( check ( memo , startIndex , K , A ) != 0 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function maxProductPath ( grid ) { var n = grid . length ; var m = grid [ 0 ] . length ; var maxPath = Array . from ( Array ( n ) , ( ) => Array ( m ) . fill ( 0 ) ) ; var minPath = Array . from ( Array ( n ) , ( ) => Array ( m ) . fill ( 0 ) ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < m ; j ++ ) { var mn = 1000000000 ; var mx = - 1000000000 ; if ( i == 0 && j == 0 ) { mx = grid [ i ] [ j ] ; mn = grid [ i ] [ j ] ; } if ( i > 0 ) { var tempmx = Math . max ( ( maxPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) , ( minPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) ) ; mx = Math . max ( mx , tempmx ) ; var tempmn = Math . min ( ( maxPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) , ( minPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) ) ; mn = Math . min ( mn , tempmn ) ; } if ( j > 0 ) { var tempmx = Math . max ( ( maxPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) , ( minPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) ) ; mx = Math . max ( mx , tempmx ) ; var tempmn = Math . min ( ( maxPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) , ( minPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) ) ; mn = Math . min ( mn , tempmn ) ; } maxPath [ i ] [ j ] = mx ; minPath [ i ] [ j ] = mn ; } } if ( maxPath [ n - 1 ] [ m - 1 ] < 0 ) return - 1 ; else return ( maxPath [ n - 1 ] [ m - 1 ] ) ; }
function waysToArrangeKLengthStrings ( N , K ) { let column_sum = [ ] ; let i , j ; for ( i = 1 ; i < N + 1 ; i ++ ) { column_sum [ i ] = 0 ; } let dp = new Array ( K + 1 ) ; for ( i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( i = 1 ; i < K + 1 ; i ++ ) { for ( j = 1 ; j < N + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( i = 0 ; i <= N ; i ++ ) { dp [ 0 ] [ i ] = 1 ; column_sum [ i ] = 1 ; } for ( i = 1 ; i <= K ; i ++ ) { for ( j = 1 ; j <= N ; j ++ ) { dp [ i ] [ j ] += column_sum [ j - 1 ] ; column_sum [ j ] += dp [ i ] [ j ] ; } } document . write ( dp [ K ] [ N ] ) ; }
function findNumberOfLIS ( nums ) { if ( nums . length == 0 ) return 0 ; var n = nums . length ; var dp_l = Array ( n ) . fill ( 1 ) ; var dp_c = Array ( n ) . fill ( 1 ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < i ; j ++ ) { if ( nums [ i ] <= nums [ j ] ) continue ; if ( dp_l [ j ] + 1 > dp_l [ i ] ) { dp_l [ i ] = dp_l [ j ] + 1 ; dp_c [ i ] = dp_c [ j ] ; } else if ( dp_l [ j ] + 1 == dp_l [ i ] ) dp_c [ i ] += dp_c [ j ] ; } } var max_length = 0 ; dp_l . forEach ( i => { max_length = Math . max ( i , max_length ) ; } ) ; var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( dp_l [ i ] == max_length ) count += dp_c [ i ] ; } return count ; }
function countPenality ( arr , N ) { let pos = 0 ; let turn = 0 ; return findMinimum ( arr , N , pos , turn ) + 1 ; }
function printAnswer ( arr , N ) { let a = countPenality ( arr , N ) ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } document . write ( a ) ; }
function removeSmallestSubarray ( arr , S , n , k ) { var target_remainder = S % k ; var map1 = new Map ( ) ; map1 . set ( 0 , - 1 ) ; var curr_remainder = 0 ; var res = 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { curr_remainder = ( curr_remainder + arr [ i ] + k ) % k ; map1 . set ( curr_remainder , i ) ; var mod = ( curr_remainder - target_remainder + k ) % k ; if ( map1 . has ( mod ) ) { res = Math . min ( res , i - map1 . get ( mod ) ) ; } } if ( res == 1000000000 res == n ) { res = - 1 ; } return res ; }
function smstSubmatDeleted ( mat , N , M , K ) { var S = 0 ; for ( var i = 0 ; i < N ; i ++ ) { for ( var j = 0 ; j < M ; j ++ ) S += mat [ i ] [ j ] ; } var min_area = N * M ; var left = 0 ; var right = 0 ; var width ; var area ; var prefixRowSum = Array ( N ) ; for ( left = 0 ; left < M ; left ++ ) { prefixRowSum = Array ( N ) . fill ( 0 ) ; for ( right = left ; right < M ; right ++ ) { for ( var i = 0 ; i < N ; i ++ ) { prefixRowSum [ i ] += mat [ i ] [ right ] ; } width = removeSmallestSubarray ( prefixRowSum , S , N , K ) ; if ( width != - 1 ) { area = ( right - left + 1 ) * ( width ) ; if ( area < min_area ) { min_area = area ; } } } } return min_area ; }
function countstrings ( n , start ) { if ( n == 0 ) { return 1 ; } let cnt = 0 ; for ( let i = start ; i < 5 ; i ++ ) { cnt += countstrings ( n - 1 , i ) ; } return cnt ; }
function findNumberOfStrings ( n ) { let DP = new Array ( n + 1 ) ; for ( var i = 0 ; i < DP . length ; i ++ ) { DP [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < DP . length ; i ++ ) { for ( var j = 0 ; j < DP . length ; j ++ ) { DP [ i ] [ j ] = 0 ; } } DP [ 1 ] [ 1 ] = 1 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { for ( let j = 1 ; j < 6 ; j ++ ) { if ( i == 1 ) { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + 1 ; } else { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + DP [ i - 1 ] [ j ] ; } } } return DP [ n ] [ 5 ] ; }
function findNumberOfStrings ( n ) { return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ; }
function check ( sum , x , y ) { while ( sum > 0 ) { let ln = sum % 10 ; if ( ln != x && ln != y ) { return 0 ; } sum = Math . floor ( sum / 10 ) ; } return 1 ; }
function countNumbers ( n , x , y , sum ) { for ( let i = 0 ; i < 1005 ; i ++ ) { for ( let j = 0 ; j < 9005 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } if ( n == 0 ) { return check ( sum , x , y ) ; } if ( dp [ n ] [ sum ] != - 1 ) { return dp [ n ] [ sum ] % mod ; } let option1 = countNumbers ( n - 1 , x , y , sum + x ) % mod ; let option2 = countNumbers ( n - 1 , x , y , sum + y ) % mod ; return dp [ n ] [ sum ] = ( option1 + option2 ) % mod ; }
function findTotalPath ( X , n , dp ) { if ( X == 0 ) { return 1 ; } var ans = 0 ; if ( dp [ X ] != - 1 ) { return dp [ X ] ; } for ( var i = 1 ; i <= Math . min ( X , n ) ; ++ i ) { ans += findTotalPath ( X - i , n , dp ) % mod ; ans %= mod ; } return dp [ X ] = ans ; }
function printAnswer ( n , edges , values ) { let adj = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) adj [ i ] = [ ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let u = edges [ i ] [ 0 ] - 1 ; let v = edges [ i ] [ 1 ] - 1 ; adj [ u ] . push ( v ) ; adj [ v ] . push ( u ) ; } let ans = new Array ( n ) ; dfs ( 0 , - 1 , adj , ans , values ) ; for ( let x = 0 ; x < ans . length ; x ++ ) { document . write ( ans [ x ] + "▁" ) ; } }
function checkEvenOddLevel ( root ) { if ( root == null ) return true ; let q = [ ] ; q . push ( root ) ; let level = 0 ; while ( q . length > 0 ) { let list = [ ] ; let size = q . length ; for ( let i = 0 ; i < size ; i ++ ) { let node = q [ 0 ] ; q . shift ( ) ; list . push ( node . val ) ; if ( node . left != null ) q . push ( node . left ) ; if ( node . right != null ) q . push ( node . right ) ; } if ( level % 2 == 0 ) { for ( let i = 0 ; i < list . length - 1 ; i ++ ) { if ( list [ i + 1 ] > list [ i ] ) continue ; return false ; } } else if ( level % 2 == 1 ) { for ( let i = 0 ; i < list . length - 1 ; i ++ ) { if ( list [ i + 1 ] < list [ i ] ) continue ; return false ; } } level ++ ; } return true ; }
function build ( dp , arr , N ) { dp [ 0 ] = 0 ; dp [ 1 ] = 0 ; let prime = SieveOfEratosthenes ( ) ; let pref = new Array ( N + 1 ) ; pref [ 0 ] = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { pref [ i ] = pref [ i - 1 ] + arr [ i - 1 ] ; } for ( let i = 2 ; i <= N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; for ( let j = 0 ; j <= prime . length ; j ++ ) { let r = i - 1 ; let l = r - prime [ j ] + 1 ; if ( l < 0 ) break ; let temp = 0 ; temp = pref [ r + 1 ] - pref [ l ] ; if ( l - 2 >= 0 ) temp += dp [ l - 2 + 1 ] ; dp [ i ] = Math . max ( dp [ i ] , temp ) ; } } }
function maxSumSubseq ( arr , N ) { let dp = new Array ( N + 1 ) ; build ( dp , arr , N ) ; document . write ( dp [ N ] ) ; }
function MinRunLengthEncoding ( s , n , k ) { for ( let i = 0 ; i < maxN ; i ++ ) { dp [ i ] = new Array ( maxN ) ; for ( let j = 0 ; j < maxN ; j ++ ) { dp [ i ] [ j ] = new Array ( 27 ) ; for ( let k = 0 ; k < 27 ; k ++ ) { dp [ i ] [ j ] [ k ] = new Array ( maxN ) ; for ( let l = 0 ; l < maxN ; l ++ ) { dp [ i ] [ j ] [ k ] [ l ] = - 1 ; } } } } return solve ( s , n , 0 , k , 123 , 0 ) ; }
function minimumCost ( A , B , M , N , C ) { var nums = Array ( 100000 ) . fill ( 0 ) ; var index = Array ( 100000 ) . fill ( 0 ) ; for ( i = 0 ; i < 100000 ; i ++ ) index [ i ] = - 1 ; for ( i = 0 ; i < N ; i ++ ) { index [ B [ i ] ] = i ; } var k = 0 ; for ( i = 0 ; i < M ; i ++ ) { if ( index [ A [ i ] ] != - 1 ) { nums [ k ++ ] = index [ A [ i ] ] ; } } var lcs_length = findLCS ( nums , k ) ; var elements_to_be_added = N - lcs_length ; var min_cost = elements_to_be_added * C ; document . write ( min_cost ) ; return 0 ; }
function numberOfPermWithKInversion ( N , K ) { let dp = new Array ( 2 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } let mod = 1000000007 ; for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) { dp [ i % 2 ] [ j ] = ( j == 0 ) ? 1 : 0 ; } else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ; else dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( Math . max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ Math . max ( j - ( i - 1 ) , 0 ) - 1 ] ) + mod ) % mod ) % mod ; } } document . write ( dp [ N % 2 ] [ K ] ) ; }
function maxScore ( arr ) { var N = arr . length ; N ++ ; var dp = Array . from ( Array ( N + 1 ) , ( ) => Array ( 2 * N ) . fill ( - 10000000 ) ) ; dp [ 0 ] [ 0 ] = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { for ( var s = 1 ; s <= 2 * ( N - 1 ) ; s ++ ) { for ( var j = 1 ; j <= N - 1 && j <= s ; j ++ ) { dp [ i ] [ s ] = Math . max ( dp [ i ] [ s ] , arr [ j - 1 ] + dp [ i - 1 ] [ s - j ] ) ; } } } return dp [ N ] [ 2 * ( N - 1 ) ] ; }
function minimumCost ( cost , n , x ) { let dp = [ ] ; dp [ 0 ] = cost [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( i == 1 ) dp [ i ] = cost [ i ] + dp [ i - 1 ] ; if ( i == 2 ) dp [ i ] = cost [ i ] + Math . min ( dp [ i - 1 ] , x + dp [ i - 2 ] ) ; if ( i >= 3 ) dp [ i ] = cost [ i ] + Math . min ( dp [ i - 1 ] , Math . min ( x + dp [ i - 2 ] , 2 * x + dp [ i - 3 ] ) ) ; } document . write ( dp [ n - 1 ] ) ; }
function maxSum ( a , n , k ) { if ( n <= 0 ) return 0 ; let option = maxSum ( a , n - 1 , k ) ; if ( k >= a [ n - 1 ] ) option = Math . max ( option , a [ n - 1 ] + maxSum ( a , n - 2 , k - a [ n - 1 ] ) ) ; return option ; }
function checkStr ( str , P , Q ) { let N = str . length ; let prev = str [ 0 ] ; let cnt = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( str [ i ] == prev ) { cnt ++ ; } else { if ( prev == "1" && cnt >= Q ) { return false ; } if ( prev == "0" && cnt >= P ) { return false ; } cnt = 1 ; } prev = str [ i ] ; } if ( prev == "1" && cnt >= Q ) { return false ; } if ( prev == "0" && cnt >= P ) { return false ; } return true ; }
function cntBinStr ( str , N , P , Q ) { let len = str . length ; if ( len == N ) { if ( checkStr ( str , P , Q ) ) return 1 ; return 0 ; } let X = cntBinStr ( str + "0" , N , P , Q ) ; let Y = cntBinStr ( str + "1" , N , P , Q ) ; return X + Y ; }
function maxCount ( arr , m , V ) { let table = [ ] ; table [ 0 ] = 0 ; for ( let i = 1 ; i <= V ; i ++ ) table [ i ] = - 1 ; for ( let i = 1 ; i <= V ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( arr [ j ] <= i ) { let sub_res = table [ i - arr [ j ] ] ; if ( sub_res != - 1 && sub_res + 1 > table [ i ] ) table [ i ] = sub_res + 1 ; } } } return table [ V ] ; }
function binCoff ( N , R ) { var res = 1 ; if ( R > ( N - R ) ) { R = ( N - R ) ; } for ( i = 0 ; i < R ; i ++ ) { res *= ( N - i ) ; res /= ( i + 1 ) ; } return res ; }
function cntPermutation ( N ) { var cntPerm ; var C_2N_N = binCoff ( 2 * N , N ) ; cntPerm = C_2N_N / ( N + 1 ) ; return cntPerm ; }
function solve ( a , s , n , prev , mask , dp ) { if ( mask == 0 ) return 0 ; if ( dp [ mask ] [ prev + 1 ] != - 1 ) return dp [ mask ] [ prev + 1 ] ; var ans = 10000 ; for ( var i = 0 ; i < s . length ; i ++ ) { var id = s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ; if ( check ( mask , id ) ) { if ( prev == - 1 ) { ans = Math . min ( ans , solve ( a , s , n , id , mask ^ ( 1 << id ) , dp ) ) ; } else { ans = Math . min ( ans , a [ prev ] [ id ] + solve ( a , s , n , id , mask ^ ( 1 << id ) , dp ) ) ; } } } dp [ mask ] [ prev + 1 ] = ans ; return ans ; }
function longestPalSubstr ( str ) { var n = str . length ; var maxLength = 1 , start = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { for ( var j = i ; j < str . length ; j ++ ) { var flag = 1 ; for ( var k = 0 ; k < ( j - i + 1 ) / 2 ; k ++ ) if ( str [ i + k ] != str [ j - k ] ) flag = 0 ; if ( flag && ( j - i + 1 ) > maxLength ) { start = i ; maxLength = j - i + 1 ; } } } return maxLength ; }
function mElementsWithMaxSum ( matrix , M , block , dp ) { if ( block == matrix . length ) return 0 ; if ( dp [ block ] [ M ] != - 1 ) return dp [ block ] [ M ] ; var ans = mElementsWithMaxSum ( matrix , M , block + 1 , dp ) ; for ( var i = 0 ; i < matrix [ block ] . length ; i ++ ) { for ( var j = i ; j < matrix [ block ] . length ; j ++ ) { if ( j - i + 1 <= M ) { ans = Math . max ( ans , matrix [ block ] [ j ] - ( ( i - 1 ) >= 0 ? matrix [ block ] [ i - 1 ] : 0 ) + mElementsWithMaxSum ( matrix , M - j + i - 1 , block + 1 , dp ) ) ; } } } return dp [ block ] [ M ] = ans ; }
function preComputing ( matrix , N ) { for ( var i = 0 ; i < N ; i ++ ) { for ( var j = 0 ; j < matrix [ i ] . length ; j ++ ) { matrix [ i ] [ j ] = ( j > 0 ? matrix [ i ] [ j - 1 ] : 0 ) + matrix [ i ] [ j ] ; } } }
function mElementsWithMaxSumUtil ( matrix , M , N ) { preComputing ( matrix , N ) ; var dp = Array . from ( Array ( N + 5 ) , ( ) => Array ( M + 5 ) . fill ( - 1 ) ) ; var sum = mElementsWithMaxSum ( matrix , M , 0 , dp ) ; document . write ( sum ) ; }
function lastRemaining ( n , dp ) { if ( dp . hasOwnProperty ( n ) ) return dp [ n ] ; if ( n === 1 ) return 1 ; else dp [ n ] = 2 * ( 1 + parseInt ( n / 2 ) - lastRemaining ( parseInt ( n / 2 ) , dp ) ) ; return dp [ n ] ; }
function Max_Sum ( arr , K , N ) { var dp = Array ( N + 1 ) . fill ( 0 ) ; var prefix = Array ( N + 1 ) ; prefix [ 0 ] = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } dp [ 0 ] = 0 ; for ( var i = 1 ; i < K ; i ++ ) { dp [ i ] = prefix [ i ] ; } for ( var i = K ; i <= N ; ++ i ) { for ( var j = i ; j >= ( i - K + 1 ) ; j -- ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j - 1 ] + prefix [ i ] - prefix [ j ] ) ; } } return dp [ N ] ; }
function binomialCoeff ( n , k ) { let C = new Array ( n + 1 ) ; for ( let i = 0 ; i < C . length ; i ++ ) { C [ i ] = new Array ( 2 ) ; } let i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
function waysToSplitN ( k , n , P ) { let new_N = n - k * P ; return binomialCoeff ( new_N + k - 1 , new_N ) ; }
function maximumSumUtil ( a , index , count , n ) { if ( index > n count > n + 1 ) { return 0 ; } if ( dp [ index ] [ count ] != - 1 ) return dp [ index ] [ count ] ; let ans1 = maximumSumUtil ( a , index + 1 , count + 1 , n ) + a [ index ] * count ; let ans2 = maximumSumUtil ( a , index + 1 , count , n ) ; return ( dp [ index ] [ count ] = Math . max ( ans1 , ans2 ) ) ; }
function maximumSum ( arr , N ) { for ( let i = 0 ; i < 1005 ; i ++ ) { for ( let j = 0 ; j < 1005 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } document . write ( maximumSumUtil ( arr , 0 , 1 , N - 1 ) ) ; }
function Calculate_factorial ( ) { fact [ 0 ] = 1 ; for ( var i = 1 ; i <= mx ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; fact [ i ] %= mod ; } }
function UniModal_per ( a , b ) { var res = 1 ; while ( b > 0 ) { if ( b % 2 !== 0 ) res = res * a ; res %= mod ; a = a * a ; a %= mod ; b = parseInt ( b / 2 ) ; } return res ; }
function countPermutations ( n ) { Calculate_factorial ( ) ; var uni_modal = UniModal_per ( 2 , n - 1 ) ; var nonuni_modal = fact [ n ] - uni_modal ; document . write ( uni_modal + "▁" + nonuni_modal ) ; return ; }
function countMinCoinsUtil ( X , C , N ) { dp = Array ( MAX + 1 ) . fill ( - 1 ) ; var isPossible = countMinCoins ( X , C , N ) ; if ( isPossible == 1000000000 ) { document . write ( "-1" ) ; } else { findSolution ( X , C , N ) ; } }
function helper ( arr , left , right , count , m ) { if ( left > right ) return 0 ; if ( dp [ left ] [ right ] [ count ] != - 1 ) { return dp [ left ] [ right ] [ count ] ; } let ans = ( count + 1 ) * m + helper ( arr , left + 1 , right , 0 , m ) ; for ( let i = left + 1 ; i <= right ; ++ i ) { if ( arr [ i ] == arr [ left ] ) { ans = Math . max ( ans , helper ( arr , left + 1 , i - 1 , 0 , m ) + helper ( arr , i , right , count + 1 , m ) ) ; } } dp [ left ] [ right ] [ count ] = ans ; return ans ; }
function maxPoints ( arr , n , m ) { let len = arr . length ; return helper ( arr , 0 , len - 1 , 0 , m ) ; }
function findWays ( N ) { if ( N == 0 ) { return 1 ; } var cnt = 0 ; for ( var i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i ) ; } } return cnt ; }
function findWays ( N , dp ) { if ( N == 0 ) { return 1 ; } if ( dp [ N ] != - 1 ) { return dp [ N ] ; } let cnt = 0 ; for ( let i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i , dp ) ; } } return dp [ N ] = cnt ; }
function findWays ( N ) { let dp = new Array ( N + 1 ) ; dp [ 0 ] = 1 ; for ( let i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( let j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } document . write ( dp [ N ] ) ; }
function findWays ( n ) { n -- ; var a , b , ans ; a = binCoff ( 2 * n , n ) ; b = a / ( n + 1 ) ; ans = b ; return ans ; }
function find_sequence ( n ) { if ( n == 1 ) return [ 1 , - 1 ] ; var arr = find_sequence ( n - 1 ) ; var ans = [ arr [ 0 ] + 1 , n - 1 ] ; if ( n % 2 == 0 ) { var div_by_2 = find_sequence ( n / 2 ) ; if ( div_by_2 [ 0 ] < ans [ 0 ] ) ans = [ div_by_2 [ 0 ] + 1 , n / 2 ] ; } if ( n % 3 == 0 ) { var div_by_3 = find_sequence ( n / 3 ) ; if ( div_by_3 [ 0 ] < ans [ 0 ] ) var ans = [ div_by_3 [ 0 ] + 1 , n / 3 ] ; } return ans ; }
function FindNoOfFullVessels ( n , t ) { var Matrix = Array . from ( Array ( n ) , ( ) => Array ( n ) . fill ( 0 ) ) ; Matrix [ 0 ] [ 0 ] = t * 1.0 ; var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j <= i ; j ++ ) { var exceededwater = Matrix [ i ] [ j ] - 1 ; if ( exceededwater < 0 ) continue ; ans ++ ; if ( i + 1 < n ) Matrix [ i + 1 ] [ j ] += ( exceededwater / 2 ) ; if ( i + 1 < n && j + 1 < n ) Matrix [ i + 1 ] [ j + 1 ] += ( exceededwater / 2 ) ; } } return ans ; }
function minCountOfNumbers ( N ) { let k = N % 10 ; let z = N - ( 9 * ( 9 - k ) ) ; if ( z >= 9 && z % 10 == 9 ) { return 10 - k ; } else { return - 1 ; } }
function checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 , j ) { if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } else { let l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; let m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; let r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return Math . max ( Math . max ( l , m ) , r ) ; } }
function checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 , j ) { var s = ( sm1 . toString ( ) ) + "_" + ( sm2 . toString ( ) ) + ( j . toString ( ) ) ; if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } if ( dp . has ( s ) ) return dp [ s ] ; else { var l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; var m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; var r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return dp [ s ] = Math . max ( Math . max ( l , m ) , r ) ; } }
function checkEqualSum ( arr , N ) { var sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function manipulation ( matrix , q ) { let x1 = q [ 0 ] , y1 = q [ 1 ] , x2 = q [ 2 ] , y2 = q [ 3 ] ; for ( let i = x1 - 1 ; i < x2 ; i ++ ) { for ( let j = y1 - 1 ; j < y2 ; j ++ ) { if ( matrix [ i ] [ j ] == 1 ) matrix [ i ] [ j ] = 0 ; else matrix [ i ] [ j ] = 1 ; } } }
function solve ( s , t ) { var n = s . length ; var r = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; if ( i > 0 ) { dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j ] ) ; } if ( s [ i ] == t [ j ] ) { var ans = 1 ; if ( i > 0 && j > 0 ) { ans = 1 + dp [ i - 1 ] [ j - 1 ] ; } dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , ans ) ; r = Math . max ( r , dp [ i ] [ j ] ) ; } } } return ( n - r ) ; }
function min_op ( cur , M ) { if ( cur > M ) return INF ; if ( cur == M ) return 0 ; let op = INF ; for ( let i = 2 ; i * i <= cur ; i ++ ) { if ( cur % i == 0 ) { if ( i % 2 == 0 ) { op = Math . min ( op , 1 + min_op ( cur + i , M ) ) ; } if ( ( cur / i ) != i && ( cur / i ) % 2 == 0 ) { op = Math . min ( op , 1 + min_op ( cur + ( cur / i ) , M ) ) ; } } } return op ; }
function min_op ( cur , M ) { if ( cur > M ) return INF ; if ( cur == M ) return 0 ; if ( dp [ cur ] != - 1 ) return dp [ cur ] ; var op = INF ; for ( var i = 2 ; i * i <= cur ; i ++ ) { if ( cur % i == 0 ) { if ( i % 2 == 0 ) { op = Math . min ( op , 1 + min_op ( cur + i , M ) ) ; } if ( ( cur / i ) != i && ( cur / i ) % 2 == 0 ) { op = Math . min ( op , 1 + min_op ( cur + ( cur / i ) , M ) ) ; } } } return dp [ cur ] = op ; }
function min_operations ( N , M ) { for ( i = N ; i <= M ; i ++ ) { dp [ i ] = - 1 ; } return min_op ( N , M ) ; }
function solve ( a ) { let n = a . length ; let dp = new Array ( n + 1 ) . fill ( 0 ) ; let val = new Array ( n + 1 ) . fill ( 0 ) ; for ( let i = n - 1 ; i >= 0 ; i -- ) { let sum = a [ i ] ; let j = i ; while ( j + 1 < n && sum < val [ j + 1 ] ) { j ++ ; sum += a [ j ] ; } dp [ i ] = ( j - i ) + dp [ j + 1 ] ; val [ i ] = sum ; } return dp [ 0 ] ; }
function findPrimeFactors ( n ) { let primeFactors = new Array ( 9 ) . fill ( 0 ) ; let j = 0 ; if ( n % 2 == 0 ) { primeFactors [ j ++ ] = 2 ; while ( n % 2 == 0 ) n >>= 1 ; } for ( let i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) { primeFactors [ j ++ ] = i ; while ( n % i == 0 ) n /= i ; } } if ( n > 2 ) primeFactors [ j ++ ] = n ; let PrimeFactors = new Array ( j ) ; for ( let i = 0 ; i < j ; i ++ ) { PrimeFactors [ i ] = primeFactors [ i ] ; } return PrimeFactors ; }
function findShortestSubsequence ( dp , a , index , primeFactors ) { let n = a . length ; for ( let j = index ; j < n ; j ++ ) { let bitmask = 0 ; for ( let p = 0 ; p < primeFactors . length ; p ++ ) { if ( ( a [ j ] % primeFactors [ p ] ) == 0 ) { bitmask ^= ( 1 << p ) ; } } for ( let i = 0 ; i < dp . length ; i ++ ) { if ( dp [ i ] == n + 1 ) continue ; dp [ bitmask & i ] = Math . min ( dp [ bitmask & i ] , dp [ i ] + 1 ) ; } } }
function minDays ( n ) { if ( n < 1 ) return n ; var cnt = 1 + Math . min ( n % 2 + minDays ( parseInt ( n / 2 ) ) , n % 3 + minDays ( parseInt ( n / 3 ) ) ) ; return cnt ; }
function count ( n ) { var dp = new Map ( ) ; dp . set ( 0 , 0 ) ; dp . set ( 1 , 1 ) ; if ( ! dp . has ( n ) ) dp . set ( n , 1 + Math . min ( n % 2 + count ( parseInt ( n / 2 ) ) , n % 3 + count ( parseInt ( n / 3 ) ) ) ) ; return dp . get ( n ) ; }
function findMaxTimes ( S ) { var arr = Array ( 26 ) . fill ( 0 ) ; var dp = Array . from ( Array ( 26 ) , ( ) => Array ( 26 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < S . length ; i ++ ) { var now = S [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ; for ( var j = 0 ; j < 26 ; j ++ ) { dp [ j ] [ now ] += arr [ j ] ; } arr [ now ] ++ ; } var ans = 0 ; for ( var i = 0 ; i < 26 ; i ++ ) ans = Math . max ( ans , arr [ i ] ) ; for ( var i = 0 ; i < 26 ; i ++ ) { for ( var j = 0 ; j < 26 ; j ++ ) { ans = Math . max ( ans , dp [ i ] [ j ] ) ; } } return ans ; }
function xorSum ( a , n , mask , dp ) { if ( dp [ mask ] != - 1 ) { return dp [ mask ] ; } var max_value = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { if ( i != j && ( mask & ( 1 << i ) ) == 0 && ( mask & ( 1 << j ) ) == 0 ) { max_value = Math . max ( max_value , ( a [ i ] ^ a [ j ] ) + xorSum ( a , n , ( mask | ( 1 << i ) | ( 1 << j ) ) , dp ) ) ; } } } return dp [ mask ] = max_value ; }
function maxValue ( a , n , pos , moves , left , dp ) { if ( moves == 0 || ( pos > n - 1 pos < 0 ) ) return 0 ; if ( dp [ pos ] [ left ] != - 1 ) return dp [ pos ] [ left ] ; let value = 0 ; if ( left > 0 && pos >= 1 ) value = Math . max ( value , a [ pos ] + maxValue ( a , n , pos - 1 , moves - 1 , left - 1 , dp ) ) ; if ( pos <= n - 1 ) value = Math . max ( value , a [ pos ] + maxValue ( a , n , pos + 1 , moves - 1 , left , dp ) ) ; return dp [ pos ] [ left ] = value ; }
function maximumSum ( a , count , index , n , dp ) { if ( index == n ) return 0 ; if ( dp [ index ] [ count ] != - 1 ) return dp [ index ] [ count ] ; var take_element = a [ index ] * count + maximumSum ( a , count + 1 , index + 1 , n , dp ) ; var dont_take = maximumSum ( a , count , index + 1 , n , dp ) ; return dp [ index ] [ count ] = Math . max ( take_element , dont_take ) ; }
function fibonacci ( ) { fib [ 1 ] = 1 ; fib [ 2 ] = 2 ; for ( i = 3 ; i <= 87 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } }
function find ( num ) { var cnt = 0 ; for ( i = 87 ; i > 0 ; i -- ) { if ( num >= fib [ i ] ) { v [ cnt ++ ] = i ; num -= fib [ i ] ; } } for ( i = 0 ; i < cnt / 2 ; i ++ ) { var t = v [ i ] ; v [ i ] = v [ cnt - i - 1 ] ; v [ cnt - i - 1 ] = t ; } dp1 [ 0 ] = 1 ; dp2 [ 0 ] = parseInt ( ( v [ 0 ] - 1 ) / 2 ) ; for ( i = 1 ; i < cnt ; i ++ ) { dp1 [ i ] = dp1 [ i - 1 ] + dp2 [ i - 1 ] ; dp2 [ i ] = parseInt ( ( v [ i ] - v [ i - 1 ] ) / 2 ) * dp2 [ i - 1 ] + parseInt ( ( v [ i ] - v [ i - 1 ] - 1 ) / 2 ) * dp1 [ i - 1 ] ; } return ( dp1 [ cnt - 1 ] + dp2 [ cnt - 1 ] ) ; }
function preprocess ( a , n ) { var p = Array ( n ) ; p [ 0 ] = a [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { p [ i ] = p [ i - 1 ] + a [ i ] ; } return p ; }
function Combine ( p , i , j ) { if ( i == 0 ) return p [ j ] ; else return p [ j ] - p [ i - 1 ] ; }
function minCost ( a , i , j , k , prefix , dp ) { if ( i >= j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; var best_cost = inf ; for ( var pos = i ; pos < j ; pos ++ ) { var left = minCost ( a , i , pos , k , prefix , dp ) ; var right = minCost ( a , pos + 1 , j , k , prefix , dp ) ; best_cost = Math . min ( best_cost , left + right + ( k * Combine ( prefix , i , j ) ) ) ; } return dp [ i ] [ j ] = best_cost ; }
function countNums ( N ) { let l = Math . floor ( Math . pow ( 10 , N - 1 ) ) ; let r = Math . floor ( Math . pow ( 10 , N ) ) - 1 ; let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { let xorr = 0 , temp = i ; while ( temp > 0 ) { xorr = xorr ^ ( temp % 10 ) ; temp = Math . floor ( temp / 10 ) ; } if ( xorr <= 9 ) count ++ ; } document . write ( count ) ; }
function distinctSimilarSubstrings ( str ) { var n = str . length ; if ( n <= 1 ) { return 0 ; } var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; var substrings = new Set ( ) ; for ( var j = n - 1 ; j >= 0 ; j -- ) { for ( var i = j - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == str [ j ] ) { dp [ i ] [ j ] = dp [ i + 1 ] [ j + 1 ] + 1 ; } else { dp [ i ] [ j ] = 0 ; } if ( dp [ i ] [ j ] >= j - i ) { substrings . add ( str . substring ( i , j ) ) ; } } } return substrings . size ; }
function SubarrayWithMaxSum ( nums ) { var endIndex , currMax = nums [ 0 ] ; var globalMax = nums [ 0 ] ; for ( var i = 1 ; i < nums . length ; ++ i ) { currMax = Math . max ( nums [ i ] , nums [ i ] + currMax ) ; if ( currMax > globalMax ) { globalMax = currMax ; endIndex = i ; } } var startIndex = endIndex ; while ( startIndex >= 0 ) { globalMax -= nums [ startIndex ] ; if ( globalMax == 0 ) break ; startIndex -- ; } for ( var i = startIndex ; i <= endIndex ; ++ i ) { document . write ( nums [ i ] + "▁" ) ; } }
function count ( a , M , N ) { let cnt = 0 ; for ( let i = 1 ; i <= M ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { if ( i % a [ j ] == 0 ) { cnt ++ ; break ; } } } return cnt ; }
function sieve ( ) { let mark = new Array ( M ) ; for ( let i = 0 ; i < M ; i ++ ) mark [ i ] = false ; for ( let i = 2 ; i < M ; i ++ ) mark [ i ] = true ; for ( let i = 2 ; i * i < M ; i ++ ) { if ( mark [ i ] ) { for ( let j = i * i ; j < M ; j += i ) mark [ j ] = false ; } } for ( let i = 2 ; i < M ; i ++ ) if ( mark [ i ] ) primes . push ( i ) ; }
function countPrimonacci ( l , r ) { let dp = new Array ( ) ; dp . push ( 1 ) ; dp . push ( 1 ) ; let i = 2 ; let s = new Set ( ) ; while ( true ) { let x = 0 ; for ( let j = 0 ; j < primes . length ; j ++ ) { let p = primes [ j ] ; if ( p >= i ) break ; x += dp [ i - p ] ; } if ( x >= l && x <= r ) s . add ( x ) ; if ( x > r ) break ; dp . push ( x ) ; i ++ ; } document . write ( s . size ) ; }
function minSum ( n , num , price ) { let dp = Array . from ( { length : n } , ( _ , i ) => Number . MAX_VALUE ) ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( num [ j ] > num [ i ] ) { dp [ j ] = Math . min ( dp [ j ] , price [ i ] + price [ j ] ) ; ans = Math . min ( ans , dp [ i ] + price [ j ] ) ; } } } return ans != Number . MAX_VALUE ? ans : - 1 ; }
function SieveOfEratosthenes ( ) { prime . fill ( 1 ) ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == 1 ) { for ( let i = p * p ; i <= MAX - 1 ; i += p ) prime [ i ] = 0 ; } } }
function getMid ( s , e ) { return s + parseInt ( ( e - s ) / 2 , 10 ) ; }
function getSumUtil ( st , ss , se , qs , qe , si ) { if ( qs <= ss && qe >= se ) return st [ si ] ; if ( se < qs ss > qe ) return 0 ; let mid = getMid ( ss , se ) ; return getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ; }
function updateValueUtil ( st , ss , se , i , diff , si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff ; if ( se != ss ) { let mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } }
function updateValue ( arr , st , n , i , new_val ) { if ( i < 0 i > n - 1 ) { document . write ( "-1" ) ; return ; } let diff = new_val - arr [ i ] ; let prev_val = arr [ i ] ; arr [ i ] = new_val ; if ( ( prime [ new_val ] prime [ prev_val ] ) != 0 ) { if ( prime [ prev_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) ; else if ( prime [ new_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) ; else updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; } }
function getSum ( st , n , qs , qe ) { if ( qs < 0 qe > n - 1 qs > qe ) { document . write ( "-1" ) ; return - 1 ; } return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; }
function countStrings ( N ) { if ( N % 2 == 1 ) return 0 ; else { N /= 2 ; var c = binomialCoeff ( 2 * N , N ) ; return c / ( N + 1 ) ; } }
function solve ( n , k , mod , dp ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; let cnt = 0 ; for ( let i = 2 ; i <= k ; i += 2 ) { cnt = ( cnt % mod + solve ( n - i , k , mod , dp ) % mod ) % mod ; } dp [ n ] = cnt ; return cnt ; }
function fact ( ) { f [ 0 ] = f [ 1 ] = 1 ; for ( var i = 2 ; i <= 10 ; i ++ ) f [ i ] = i * 1 * f [ i - 1 ] ; }
function dfs2 ( a , par ) { for ( let i = 0 ; i < v [ a ] . length ; i ++ ) { if ( v [ a ] [ i ] . first == par ) continue ; let leafOutside = leaves [ a ] - leaves [ v [ a ] [ i ] . first ] ; dp [ v [ a ] [ i ] . first ] += ( dp [ a ] - dp [ v [ a ] [ i ] . first ] ) ; dp [ v [ a ] [ i ] . first ] += v [ a ] [ i ] . second * ( leafOutside - leaves [ v [ a ] [ i ] . first ] ) ; leaves [ v [ a ] [ i ] . first ] += leafOutside ; dfs2 ( v [ a ] [ i ] . first , a ) ; } }
function countPairs ( first , second , value ) { let count = 0 ; while ( first != null && second != null && first != second && second . next != first ) { if ( ( first . data + second . data ) == value ) { count ++ ; first = first . next ; second = second . prev ; } else if ( ( first . data + second . data ) > value ) second = second . prev ; else first = first . next ; } return count ; }
function countTriplets ( head , x ) { if ( head == null ) return 0 ; let current , first , last ; let count = 0 ; last = head ; while ( last . next != null ) last = last . next ; for ( current = head ; current != null ; current = current . next ) { first = current . next ; count += countPairs ( first , last , x - current . data ) ; } return count ; }
function countChanges ( matrix , n , m ) { let i , j , dist = n + m - 1 ; let Max_element = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { Max_element = Math . max ( Max_element , matrix [ i ] [ j ] ) ; } } let freq = new Array ( dist ) ; for ( i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = new Array ( 2 ) ; } for ( i = 0 ; i < dist ; i ++ ) { for ( j = 0 ; j < Max_element + 1 ; j ++ ) freq [ i ] [ j ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } let min_changes_sum = 0 ; for ( i = 0 ; i < Math . floor ( dist / 2 ) ; i ++ ) { let maximum = 0 ; let total_values = 0 ; for ( j = 0 ; j < Max_element + 1 ; j ++ ) { maximum = Math . max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ; } min_changes_sum += total_values - maximum ; } return min_changes_sum ; }
function maxLength ( arr , n ) { let dp = [ ] ; for ( let i = 1 ; i < n ; i ++ ) { dp [ i ] = 1 ; } for ( let i = n - 1 ; i > 1 ; i -- ) { for ( let j = 1 ; j <= Math . sqrt ( i ) ; j ++ ) { if ( i % j == 0 ) { let s = i / j ; if ( s == j ) { if ( arr [ i ] > arr [ s ] ) { dp [ s ] = Math . max ( dp [ i ] + 1 , dp [ s ] ) ; } } else { if ( s != i && arr [ i ] > arr [ s ] ) dp [ s ] = Math . max ( dp [ i ] + 1 , dp [ s ] ) ; if ( arr [ i ] > arr [ j ] ) { dp [ j ] = Math . max ( dp [ i ] + 1 , dp [ j ] ) ; } } } } } let max = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( dp [ i ] > max ) max = dp [ i ] ; } document . write ( max ) ; }
function maxProfit ( price , n ) { var buy1 , profit1 , buy2 , profit2 ; buy1 = buy2 = Number . MAX_VALUE ; profit1 = profit2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { buy1 = Math . min ( buy1 , price [ i ] ) ; profit1 = Math . max ( profit1 , price [ i ] - buy1 ) ; buy2 = Math . min ( buy2 , price [ i ] - profit1 ) ; profit2 = Math . max ( profit2 , price [ i ] - buy2 ) ; } return profit2 ; }
function validsubsequences ( arr , n ) { let dp = new Array ( n + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] [ 0 ] = 0 ; dp [ i ] [ 1 ] = 0 ; } for ( let i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 != 0 ) { dp [ i ] [ 1 ] += 1 ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] ; } else { dp [ i ] [ 0 ] += 1 ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] ; } } return ( dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ) ; }
function getCount ( n , k ) { if ( n == 1 ) return 10 ; var dp = new Array ( n + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) dp [ i ] = Array ( 11 ) . fill ( 0 ) ; for ( i = 1 ; i <= 9 ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 0 ; j <= 9 ; j ++ ) { var l = Math . max ( 0 , j - k ) ; var r = Math . min ( 9 , j + k ) ; dp [ i ] [ l ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ r + 1 ] -= dp [ i - 1 ] [ j ] ; } for ( j = 1 ; j <= 9 ; j ++ ) dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } var count = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) count += dp [ n ] [ i ] ; return count ; }
function existPath ( V , edges , u , v ) { var mat = Array . from ( Array ( V ) , ( ) => Array ( V ) ) ; for ( var i = 0 ; i < X ; i ++ ) mat [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = true ; for ( var k = 0 ; k < V ; k ++ ) { for ( var i = 0 ; i < V ; i ++ ) { for ( var j = 0 ; j < V ; j ++ ) { mat [ i ] [ j ] = mat [ i ] [ j ] || mat [ i ] [ k ] && mat [ k ] [ j ] ; } } } if ( u >= V v >= V ) { return false ; } if ( mat [ u ] [ v ] ) return true ; return false ; }
function calculate_maximum_splits ( arr , N ) { var pre = [ 0 , - 1 , - 1 ] ; var i ; var dp = new Array ( N ) ; for ( i = 0 ; i < N ; i ++ ) dp [ i ] = 0 ; var C = 0 ; for ( i = 1 ; i < N ; i ++ ) { C = C + arr [ i ] ; C = C % 3 ; if ( pre [ C ] == - 1 ) { dp [ i ] = dp [ i - 1 ] ; } else { dp [ i ] = Math . max ( dp [ i - 1 ] , dp [ pre [ C ] ] + 1 ) ; } pre [ C ] = i ; } document . write ( dp [ N - 1 ] ) ; }
function solve ( n , last , k ) { if ( n == 1 ) { if ( last == k ) { return ( k - 1 ) ; } else { return 1 ; } } if ( ( dp [ n ] [ last ] ) != 0 ) return dp [ n ] [ last ] ; if ( last == k ) { return dp [ n ] [ last ] = ( k - 1 ) * solve ( n - 1 , k , k ) + ( k - 1 ) * solve ( n - 1 , 1 , k ) ; } else { dp [ n ] [ last ] = solve ( n - 1 , k , k ) ; return dp [ n ] [ last ] ; } }
function mergeTwoNumbers ( numbers ) { var len , i , j , k ; var n = numbers . length ; if ( numbers . length == 0 ) { return 0 ; } var prefixSum = Array ( n + 1 ) . fill ( 0 ) ; for ( var i = 1 ; i <= n ; i ++ ) { prefixSum [ i ] = prefixSum [ i - 1 ] + numbers [ i - 1 ] ; } var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( n + 1 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { dp [ i ] [ i ] = 0 ; } for ( len = 2 ; len <= n ; len ++ ) { for ( i = 1 ; i <= n - len + 1 ; i ++ ) { j = i + len - 1 ; var sum = prefixSum [ j ] - prefixSum [ i - 1 ] ; dp [ i ] [ j ] = 1000000000 ; for ( k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum ) ; } } } return dp [ 1 ] [ n ] ; }
function seiveOfEratosthenes ( ) { for ( let i = 2 ; i < 1000001 ; i ++ ) { prime [ i ] = 1 ; } for ( let i = 2 ; i * i < 1000001 ; i ++ ) { if ( prime [ i ] == 1 ) { for ( let j = i * i ; j < 1000001 ; j += i ) { prime [ j ] = 0 ; } } } }
function constructPath ( u , v ) { if ( Next [ u ] [ v ] == - 1 ) return null ; let path = [ ] ; path . push ( u ) ; while ( u != v ) { u = Next [ u ] [ v ] ; path . push ( u ) ; } return path ; }
function floydWarshall ( V ) { for ( let k = 0 ; k < V ; k ++ ) { for ( let i = 0 ; i < V ; i ++ ) { for ( let j = 0 ; j < V ; j ++ ) { if ( dis [ i ] [ k ] == INF dis [ k ] [ j ] == INF ) continue ; if ( dis [ i ] [ j ] > dis [ i ] [ k ] + dis [ k ] [ j ] ) { dis [ i ] [ j ] = dis [ i ] [ k ] + dis [ k ] [ j ] ; Next [ i ] [ j ] = Next [ i ] [ k ] ; } } } } }
function maximumSum ( A , B , length , X , Y ) { var l = length ; var l1 = Math . min ( length , X ) ; var l2 = Math . min ( length , Y ) ; var dp = Array . from ( Array ( l1 + 1 ) , ( ) => Array ( l2 + 1 ) . fill ( 0 ) ) ; dp [ 0 ] [ 0 ] = 0 ; var max_sum = - 1000000000 ; for ( var i = 1 ; i <= l1 ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + A [ i - 1 ] ; max_sum = Math . max ( max_sum , dp [ i ] [ 0 ] ) ; } for ( var i = 1 ; i <= l2 ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + B [ i - 1 ] ; max_sum = Math . max ( max_sum , dp [ 0 ] [ i ] ) ; } for ( var i = 1 ; i <= l1 ; i ++ ) { for ( var j = 1 ; j <= l2 ; j ++ ) { if ( i + j <= l ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] + A [ i + j - 1 ] , dp [ i ] [ j - 1 ] + B [ i + j - 1 ] ) ; max_sum = Math . max ( dp [ i ] [ j ] , max_sum ) ; } } return max_sum ; }
function finding_factors ( n ) { let i , a ; for ( i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i == n ) { vp [ n ] . push ( i ) ; } else { vp [ n ] . push ( i ) ; vp [ n ] . push ( n / i ) ; } } } }
function countSeq ( N , K ) { let i , j , k ; let dp = new Array ( 109 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( i = 1 ; i <= N ; i ++ ) { finding_factors ( i ) ; dp [ 0 ] [ i ] = 0 ; dp [ 1 ] [ i ] = 1 ; } for ( i = 2 ; i <= K ; i ++ ) { for ( j = 1 ; j <= N ; j ++ ) { let sum = 0 ; for ( k = 0 ; k < vp [ j ] . length ; k ++ ) { sum = ( sum + dp [ i - 1 ] [ vp [ j ] [ k ] ] ) ; } dp [ i ] [ j ] = sum ; } } let ans = 0 ; for ( j = 1 ; j <= N ; j ++ ) { ans = ( ans + dp [ K ] [ j ] ) ; } return ans ; }
function find_minimum_operations ( n , b , k ) { let d = new Array ( n + 1 ) ; d . fill ( 0 ) ; let i , operations = 0 , need ; for ( i = 0 ; i < n ; i ++ ) { if ( i > 0 ) { d [ i ] += d [ i - 1 ] ; } if ( b [ i ] > d [ i ] ) { operations += b [ i ] - d [ i ] ; need = b [ i ] - d [ i ] ; d [ i ] += need ; if ( i + k <= n ) { d [ i + k ] -= need ; } } } document . write ( operations ) ; }
function sieve ( ) { primes . fill ( true ) primes [ 0 ] = primes [ 1 ] = 0 ; for ( let i = 2 ; i * i <= maxn ; i ++ ) { if ( primes [ i ] ) { for ( let j = i * i ; j <= maxn ; j += i ) primes [ j ] = false ; } } }
function printpentaRec ( n ) { if ( n == 0 n == 1 n == 2 n == 3 n == 4 ) return 0 ; else if ( n == 5 ) return 1 ; else return ( printpentaRec ( n - 1 ) + printpentaRec ( n - 2 ) + printpentaRec ( n - 3 ) + printpentaRec ( n - 4 ) + printpentaRec ( n - 5 ) ) ; }
function possibleBinaries ( pos , ones , sum , k ) { if ( ones == k ) return 0 ; if ( pos == 0 ) return ( sum == 0 ) ? 1 : 0 ; if ( dp [ pos ] [ ones ] [ sum ] != - 1 ) return dp [ pos ] [ ones ] [ sum ] ; let ret = possibleBinaries ( pos - 1 , ones + 1 , ( sum + 1 ) % 2 , k ) + possibleBinaries ( pos - 1 , 0 , sum , k ) ; dp [ pos ] [ ones ] [ sum ] = ret ; return dp [ pos ] [ ones ] [ sum ] ; }
function MAX_value ( arr ) { var row = arr . length ; var col = arr [ 0 ] . length ; var dp = Array ( row ) ; for ( var i = 0 ; i < row ; i ++ ) dp [ i ] = Array ( col ) . fill ( 0 ) ; var i = 0 , j = 0 ; var c = arr [ 0 ] [ 0 ] , p = 0 ; var d = row ; for ( i = 0 ; i < d ; i ++ ) { for ( j = 0 ; j < d ; j ++ ) { if ( c < arr [ i ] [ j ] ) { c = arr [ i ] [ j ] ; } if ( i == 0 j == 0 ) { dp [ i ] [ j ] = 1 ; } else { if ( arr [ i - 1 ] [ j - 1 ] == arr [ i ] [ j ] && arr [ i - 1 ] [ j ] == arr [ i ] [ j ] && arr [ i ] [ j - 1 ] == arr [ i ] [ j ] ) { dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j - 1 ] , Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ) + 1 ; } else { dp [ i ] [ j ] = 1 ; } } } } for ( i = 0 ; i < d ; i ++ ) { for ( j = 0 ; j < d ; j ++ ) { if ( arr [ i ] [ j ] == c ) { if ( p < dp [ i ] [ j ] ) { p = dp [ i ] [ j ] ; } } } } return p * p ; }
function printList ( head ) { if ( head == null ) document . write ( "Doubly▁Linked▁list▁empty" ) ; while ( head != null ) { document . write ( head . data + "▁" ) ; head = head . next ; } }
function countStableNum ( str , N ) { var count1 = Array . from ( Array ( N ) , ( ) => Array ( 10 ) ) ; var count2 = Array . from ( Array ( N ) , ( ) => Array ( 10 ) ) ; for ( var i = 0 ; i < N ; i ++ ) for ( var j = 0 ; j < 10 ; j ++ ) count1 [ i ] [ j ] = count2 [ i ] [ j ] = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( i != 0 ) { for ( var j = 0 ; j < 10 ; j ++ ) { count1 [ i ] [ j ] += count1 [ i - 1 ] [ j ] ; } } count1 [ i ] [ str [ i ] - "0" ] ++ ; } for ( var i = N - 1 ; i >= 0 ; i -- ) { if ( i != N - 1 ) { for ( var j = 0 ; j < 10 ; j ++ ) { count2 [ i ] [ j ] += count2 [ i + 1 ] [ j ] ; } } count2 [ i ] [ str [ i ] - "0" ] ++ ; } var ans = 0 ; for ( var i = 1 ; i < N - 1 ; i ++ ) { if ( str [ i ] == "9" ) continue ; var c1 = count1 [ i - 1 ] [ str [ i ] - "0" ] ; var c2 = count2 [ i + 1 ] [ str [ i ] - "0" + 1 ] ; if ( c2 == 0 ) continue ; ans = ( ans + ( c1 * ( ( c2 * ( c2 - 1 ) / 2 ) ) ) ) ; } return ans ; }
function countWays ( s , t , k ) { let n = s . length ; let a = 0 , b = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let p = s . substr ( i , n - i ) + s . substr ( 0 , i ) ; if ( p == t ) a ++ ; else b ++ ; } let dp1 = Array . from ( { length : k + 1 } , ( _ , i ) => 0 ) ; let dp2 = Array . from ( { length : k + 1 } , ( _ , i ) => 0 ) ; if ( s == t ) { dp1 [ 0 ] = 1 ; dp2 [ 0 ] = 0 ; } else { dp1 [ 0 ] = 0 ; dp2 [ 0 ] = 1 ; } for ( let i = 1 ; i <= k ; i ++ ) { dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ; dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ; } return dp1 [ k ] ; }
function dfs1 ( u , par , g , weight ) { dp1 [ u ] = weight [ u ] ; for ( let c = 0 ; c < g [ u ] . length ; c ++ ) { if ( g [ u ] != par ) { dfs1 ( g [ u ] , u , g , weight ) ; dp1 [ u ] += Math . max ( 0 , dp1 [ g [ u ] ] ) ; } } }
function dfs2 ( u , par , g , weight ) { if ( par != 0 ) { maxSumAncestors = dp2 [ par ] - Math . max ( 0 , dp1 [ u ] ) ; dp2 [ u ] = dp1 [ u ] + Math . max ( 0 , maxSumAncestors ) ; } for ( let c = 0 ; c < g [ u ] . length ; c ++ ) { if ( g [ u ] != par ) { dfs2 ( g [ u ] , u , g , weight ) ; } } }
function addEdge ( u , v , g ) { g [ u ] . push ( v ) ; g [ v ] . push ( u ) ; }
function maxSumSegments ( g , weight , n ) { dfs1 ( 1 , 0 , g , weight ) ; for ( let i = 1 ; i < n + 1 ; i ++ ) dp2 [ i ] = dp1 [ i ] ; dfs2 ( 1 , 0 , g , weight ) ; }
function printAns ( n ) { for ( let i = 1 ; i < n ; i ++ ) document . write ( dp2 [ i ] + "▁" ) ; }
function countMaximum ( a , n ) { a . sort ( ) ; a . reverse ( ) ; let count = 0 ; let mark = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( ( a [ i ] + n >= mark ) ) { count += 1 ; } mark = Math . max ( mark , a [ i ] + i + 1 ) ; } document . write ( count ) ; }
function CountWays ( i , j , k ) { if ( i >= N i < 0 j >= M j < 0 k < 0 ) return 0 ; if ( i == 0 && j == 0 && k == 0 ) return 1 ; if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [ k ] ; else dp [ i ] [ j ] [ k ] = ( CountWays ( i + 1 , j , k - 1 ) % MOD + CountWays ( i - 1 , j , k - 1 ) % MOD + CountWays ( i , j - 1 , k - 1 ) % MOD + CountWays ( i , j + 1 , k - 1 ) % MOD + CountWays ( i , j , k - 1 ) % MOD ) % MOD ; return dp [ i ] [ j ] [ k ] ; }
function smallestNum ( n ) { res = 1 ; for ( var i = 2 ; ; i *= 2 ) { var length = parseInt ( Math . log ( i ) / Math . log ( 10 ) ) + 1 ; if ( length == n ) return parseInt ( Math . log ( i ) / Math . log ( 2 ) ) ; } }
function findResultUtil ( arr , L , R ) { var result = 0 ; var flag = false ; for ( var i = L ; i <= R ; i ++ ) { if ( flag == false ) { result = result + arr [ i ] ; flag = true ; } else { result = result - arr [ i ] ; flag = false ; } } return result ; }
function isKPartitionPossible ( arr , N , K ) { if ( K == 1 ) return true ; if ( N < K ) return false ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % K != 0 ) return false ; let target = sum / K ; let dp = Array . from ( { length : ( 1 << 15 ) } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < ( 1 << N ) ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( let mask = 0 ; mask < ( 1 << N ) ; mask ++ ) { if ( dp [ mask ] == - 1 ) continue ; for ( let i = 0 ; i < N ; i ++ ) { if ( ( ( mask & ( 1 << i ) ) == 0 ) && dp [ mask ] + arr [ i ] <= target ) { dp [ mask ( 1 << i ) ] = ( dp [ mask ] + arr [ i ] ) % target ; } } } if ( dp [ ( 1 << N ) - 1 ] == 0 ) return true ; else return false ; }
function min_operation ( i , j , val , x ) { if ( i == n - 1 && j == m - 1 ) { if ( val > v [ i ] [ j ] ) { return dp [ i ] [ j ] = MAX ; } else { return dp [ i ] [ j ] = v [ i ] [ j ] - val ; } } if ( i == n j == m ) { return dp [ i ] [ j ] = MAX ; } if ( dp [ i ] [ j ] != - 1 ) { return dp [ i ] [ j ] ; } if ( val > v [ i ] [ j ] ) { return dp [ i ] [ j ] = MAX ; } let tmp = v [ i ] [ j ] - val ; tmp += Math . min ( min_operation ( i + 1 , j , val + x , x ) , min_operation ( i , j + 1 , val + x , x ) ) ; return dp [ i ] [ j ] = tmp ; }
function solve ( x ) { let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { let val = v [ i ] [ j ] - x * ( i + j ) ; for ( let k = 0 ; k < dp . length ; k ++ ) for ( let l = 0 ; l < dp [ k ] . length ; l ++ ) dp [ k ] [ l ] = - 1 ; val = min_operation ( 0 , 0 , val , x ) ; ans = Math . min ( ans , val ) ; } } return ans ; }
function printList ( head ) { if ( head == null ) document . write ( "Doubly▁Linked▁list▁empty" ) ; while ( head != null ) { document . write ( head . data + "▁" ) ; head = head . next ; } }
function Count ( S , m , n ) { let table = [ ] ; for ( let i = 0 ; i < m + 1 ; i ++ ) { table [ i ] = [ ] ; for ( let j = 0 ; j < n + 1 ; j ++ ) { table [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= n ; i ++ ) { table [ 0 ] [ i ] = Number . MAX_VALUE - 1 ; } for ( let i = 1 ; i <= m ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( S [ i - 1 ] > j ) { table [ i ] [ j ] = table [ i - 1 ] [ j ] ; } else { table [ i ] [ j ] = Math . min ( table [ i - 1 ] [ j ] , table [ i ] [ j - S [ i - 1 ] ] + 1 ) ; } } } return table [ m ] [ n ] ; }
function maxProductUtil ( X , Y , A , B , dp ) { if ( X < 0 Y < 0 ) return - INF ; if ( dp [ X ] [ Y ] != - 1 ) return dp [ X ] [ Y ] ; dp [ X ] [ Y ] = maximum ( A [ X ] * B [ Y ] + maxProductUtil ( X - 1 , Y - 1 , A , B , dp ) , A [ X ] * B [ Y ] , maxProductUtil ( X - 1 , Y , A , B , dp ) , maxProductUtil ( X , Y - 1 , A , B , dp ) ) ; return dp [ X ] [ Y ] ; }
function maxProduct ( A , N , B , M ) { let dp = new Array ( N ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return maxProductUtil ( N - 1 , M - 1 , A , B , dp ) ; }
function minOperation ( k ) { let dp = Array . from ( { length : k + 1 } , ( _ , i ) => 0 ) ; for ( let i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; }
function maximumSum ( S , M , N , stacks ) { var dp = Array . from ( Array ( S + 1 ) , ( ) => Array ( N + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < S ; i ++ ) { for ( var j = 0 ; j <= N ; j ++ ) { for ( var k = 0 ; k <= Math . min ( j , M ) ; k ++ ) { dp [ i + 1 ] [ j ] = Math . max ( dp [ i + 1 ] [ j ] , stacks [ i ] [ k ] + dp [ i ] [ j - k ] ) ; } } } var result = - 1000000000 ; for ( var i = 0 ; i <= N ; i ++ ) { result = Math . max ( result , dp [ S ] [ i ] ) ; } return result ; }
function findSum ( arr , n ) { var totalSum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; } var dp = Array . from ( Array ( 2 ) , ( ) => Array ( n ) ) ; for ( var i = 0 ; i < n ; i ++ ) { dp [ 0 ] [ i ] = 1 ; dp [ 1 ] [ i ] = arr [ i ] ; } for ( var i = 1 ; i < n ; i ++ ) { for ( var j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { if ( dp [ 0 ] [ i ] < dp [ 0 ] [ j ] + 1 ) { dp [ 0 ] [ i ] = dp [ 0 ] [ j ] + 1 ; dp [ 1 ] [ i ] = dp [ 1 ] [ j ] + arr [ i ] ; } else if ( dp [ 0 ] [ i ] == dp [ 0 ] [ j ] + 1 ) { dp [ 1 ] [ i ] = Math . min ( dp [ 1 ] [ i ] , dp [ 1 ] [ j ] + arr [ i ] ) ; } } } } var maxm = 0 ; var subtractSum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( dp [ 0 ] [ i ] > maxm ) { maxm = dp [ 0 ] [ i ] ; subtractSum = dp [ 1 ] [ i ] ; } else if ( dp [ 0 ] [ i ] == maxm ) { subtractSum = Math . min ( subtractSum , dp [ 1 ] [ i ] ) ; } } return totalSum - subtractSum ; }
function count ( n ) { if ( n == 2 ) return 1 ; else if ( n == 4 ) return 2 ; else if ( n == 6 ) return 4 ; let table = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; let i ; for ( i = 0 ; i < n + 1 ; i ++ ) table [ i ] = 0 ; table [ 0 ] = 0 ; table [ 2 ] = 1 ; table [ 4 ] = 2 ; table [ 6 ] = 4 ; for ( i = 8 ; i <= n ; i = i + 2 ) { table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] ; } return table [ n ] ; }
function isPrime ( number ) { let num = parseInt ( number ) ; for ( let i = 2 ; i * i <= num ; i ++ ) { if ( ( num % i ) == 0 ) return false ; } return num > 1 ? true : false ; }
function countPrimeStrings ( number , i ) { if ( i == 0 ) return 1 ; let cnt = 0 ; for ( let j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 && number [ i - j ] != "0" && isPrime ( number . substring ( i - j , i ) ) ) { cnt += countPrimeStrings ( number , i - j ) ; cnt %= MOD ; } } return cnt ; }
function buildSieve ( ) { for ( let i = 0 ; i < sieve . length ; i ++ ) { sieve [ i ] = true ; } sieve [ 0 ] = false ; sieve [ 1 ] = false ; for ( let p = 2 ; p * p <= 1000000 ; p ++ ) { if ( sieve [ p ] == true ) { for ( let i = p * p ; i < 1000000 ; i += p ) sieve [ i ] = false ; } } }
function isPrime ( number ) { let num = parseInt ( number ) ; return sieve [ num ] ; }
function rec ( number , i , dp ) { if ( dp [ i ] != - 1 ) return dp [ i ] ; let cnt = 0 ; for ( let j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 && number [ i - j ] != "0" && isPrime ( number . substring ( i - j , i ) ) ) { cnt += rec ( number , i - j , dp ) ; cnt %= MOD ; } } return dp [ i ] = cnt ; }
function countPrimeStrings ( number ) { let n = number . length ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { dp [ i ] = - 1 ; } dp [ 0 ] = 1 ; return rec ( number , n , dp ) ; }
function SieveOfEratosthenes ( ) { prime . fill ( true ) prime [ 0 ] = prime [ 1 ] = false ; for ( let p = 2 ; p * p <= 100000 ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= 100000 ; i += p ) prime [ i ] = false ; } } }
function distinctPrimeSubSeq ( a , n , k ) { SieveOfEratosthenes ( ) ; let primes = new Array ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( prime [ a [ i ] ] ) primes . push ( a [ i ] ) ; } let l = primes . length ; primes . sort ( ( a , b ) => a - b )  let b = new Array ( ) ; let dp = new Array ( ) ; let sum = 0 ; for ( let i = 0 ; i < l ; ) { let count = 1 , x = a [ i ] ; i ++ ; while ( i < l && a [ i ] == x ) { count ++ ; i ++ ; } b . push ( count ) ; dp . push ( count ) ; sum += count ; } let of_length = 2 ; let len = dp . length ; let ans = 0 ; while ( of_length <= k ) { let freq = 0 ; let prev = 0 ; for ( let i = 0 ; i < ( len - 1 ) ; i ++ ) { freq += dp [ i ] ; let j = sum - freq ; let subseq = b [ i ] * j ; ans += subseq ; dp [ i ] = subseq ; prev += dp [ i ] ; } len -- ; sum = prev ; of_length ++ ; } ans += ( l + 1 ) ; return ans ; }
function ways ( arr , K ) { let R = arr . length ; let C = arr [ 0 ] . length ; let preSum = new Array ( R ) ; for ( let i = 0 ; i < R ; i ++ ) { preSum [ i ] = new Array ( C ) ; for ( let j = 0 ; j < C ; j ++ ) { preSum [ i ] [ j ] = 0 ; } } for ( let r = R - 1 ; r >= 0 ; r -- ) { for ( let c = C - 1 ; c >= 0 ; c -- ) { preSum [ r ] = arr [ r ] ; if ( r + 1 < R ) preSum [ r ] += preSum [ r + 1 ] ; if ( c + 1 < C ) preSum [ r ] += preSum [ r ] ; if ( r + 1 < R && c + 1 < C ) preSum [ r ] -= preSum [ r + 1 ] ; } } let dp = new Array ( K + 1 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( R ) ; for ( let j = 0 ; j < R ; j ++ ) { dp [ i ] [ j ] = new Array ( C ) ; for ( let k = 0 ; k < C ; k ++ ) { dp [ i ] [ j ] [ k ] = 0 ; } } } for ( let k = 1 ; k <= K ; k ++ ) { for ( let r = R - 1 ; r >= 0 ; r -- ) { for ( let c = C - 1 ; c >= 0 ; c -- ) { if ( k == 1 ) { dp [ k ] [ r ] = ( preSum [ r ] > 0 ) ? 1 : 0 ; } else { dp [ k ] [ r ] = 0 ; for ( let r1 = r + 1 ; r1 < R ; r1 ++ ) { if ( preSum [ r ] - preSum [ r1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r1 ] ; } for ( let c1 = c + 1 ; c1 < C ; c1 ++ ) { if ( preSum [ r ] - preSum [ r ] [ c1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r ] [ c1 ] ; } } } } } return dp [ K ] [ 0 ] [ 0 ] ; }
function nCr ( n , r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
function fact ( n ) { var res = 1 ; for ( var i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
function sumPathCost ( grid , m , n ) { var sum = 0 , count ; for ( var i = 0 ; i <= m ; i ++ ) { for ( var j = 0 ; j <= n ; j ++ ) { count = nCr ( i + j , i ) * nCr ( m + n - i - j , m - i ) ; sum += count * grid [ i ] [ j ] ; } } return sum ; }
function init ( x ) { for ( var i = 0 ; i < 20 ; i ++ ) { dp [ i ] = Array . from ( Array ( 1000 ) , ( ) => Array ( 10 ) ) ; for ( var j = 0 ; j < 1000 ; j ++ ) { for ( var k = 0 ; k < 10 ; k ++ ) { dp [ i ] [ j ] [ k ] = Array . from ( Array ( 2 ) , ( ) => Array ( 2 ) . fill ( - 1 ) ) ; } } } v = [ ] ; while ( x > 0 ) { v . push ( x % 10 ) ; x = parseInt ( x / 10 ) ; } v . reverse ( ) ; N = v . length ; }
function findCount ( L , R , K ) { init ( R ) ; var r_ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; init ( L - 1 ) ; var l_ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; document . write ( r_ans - l_ans ) ; }
function dfs_lca ( a , par , lev ) { dp [ 0 ] [ a ] = par ; level [ a ] = lev ; for ( let i = 0 ; i < 2 ; i ++ ) { if ( v [ a ] [ 0 ] == par ) continue ; mx [ 0 ] [ v [ a ] [ 0 ] ] = v [ a ] [ 1 ] ; dfs_lca ( v [ a ] [ 0 ] , a , lev + 1 ) ; } }
function find_ancestor ( ) { for ( let i = 1 ; i < 16 ; i ++ ) { for ( let j = 1 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ dp [ i - 1 ] [ j ] ] ; mx [ i ] [ j ] = Math . max ( mx [ i - 1 ] [ j ] , mx [ i - 1 ] [ dp [ i - 1 ] [ j ] ] ) ; } } }
function getMax ( a , b ) { if ( level [ b ] < level [ a ] ) { let temp = a ; a = b ; b = temp ; } let ans = 0 ; let diff = level [ b ] - level [ a ] ; while ( diff > 0 ) { let log = parseInt ( Math . log ( diff ) / Math . log ( 2 ) , 10 ) ; ans = Math . max ( ans , mx [ log ] [ b ] ) ; b = dp [ log ] [ b ] ; diff -= ( 1 << log ) ; } while ( a == b ) { i = parseInt ( Math . log ( level [ a ] ) / Math . log ( 2 ) , 10 ) ; while ( i > 0 && dp [ i ] [ a ] == dp [ i ] [ b ] ) { i -= 1 ; } ans = Math . max ( ans , mx [ i ] [ a ] ) ; ans = Math . max ( ans , mx [ i ] [ b ] ) ; a = dp [ i ] [ a ] ; b = dp [ i ] [ b ] ; } return ans * 2 + 1 ; }
function compute_lca ( ) { dfs_lca ( 1 , 0 , 0 ) ; find_ancestor ( ) ; }
function dfs ( adj , order , bridge_detect , mark , v , l ) { mark [ v ] = true ; order [ v ] = order [ l ] + 1 ; bridge_detect [ v ] = order [ v ] ; for ( let i = 0 ; i < adj [ v ] . length ; i ++ ) { let u = adj [ v ] [ i ] ; if ( u == l ) { continue ; } if ( order [ v ] < order [ u ] ) { continue ; } if ( mark [ u ] ) { bridge_detect [ v ] = Math . min ( order [ u ] , bridge_detect [ v ] ) ; } else { dfs ( adj , order , bridge_detect , mark , u , v ) ; } bridge_detect [ v ] = Math . min ( bridge_detect [ u ] , bridge_detect [ v ] ) ; ans . push ( [ v , u ] ) ; } if ( bridge_detect [ v ] == order [ v ] && l != 0 ) { flag = 0 ; } return flag ; }
function createGraph ( Edges , adj , M ) { for ( let i = 0 ; i < M ; i ++ ) { let u = Edges [ i ] [ 0 ] ; let v = Edges [ i ] [ 1 ] ; adj [ u ] . push ( v ) ; adj [ v ] . push ( u ) ; } }
function depthFirst ( v , graph , visited , storeChain ) { visited [ v ] = true ; storeChain . push ( v ) ; for ( let i = 0 ; i < graph [ v ] . length ; i ++ ) { if ( visited [ graph [ v ] [ i ] ] == false ) { depthFirst ( graph [ v ] [ i ] , graph , visited , storeChain ) ; } } }
function subarraySum ( arr , n ) { let maxSubarraySum = arr [ 0 ] ; let currentMax = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { currentMax = Math . max ( arr [ i ] , arr [ i ] + currentMax ) ; maxSubarraySum = Math . max ( maxSubarraySum , currentMax ) ; } return maxSubarraySum ; }
function get_max_sum ( arr , n ) { var freq = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( freq . has ( arr [ i ] ) ) freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) else freq . set ( arr [ i ] , 1 ) } var dp = Array ( 100001 ) . fill ( 0 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = ( freq . has ( 0 ) ? freq . get ( 0 ) : 0 ) ; for ( var i = 2 ; i <= 100000 ; i ++ ) { dp [ i ] = Math . max ( dp [ i - 1 ] , dp [ i - 2 ] + i * ( freq . has ( i ) ? freq . get ( i ) : 0 ) ) ; } return dp [ 100000 ] ; }
function minFlip ( a ) { let n = a . length ; let dp = new Array ( n + 2 ) . fill ( 0 ) . map ( ( t ) => new Array ( 2 ) . fill ( 0 ) )  if ( a . charAt ( 0 ) == "1" ) { dp [ 0 ] [ 0 ] = 1 ; } else dp [ 0 ] [ 0 ] = 0 ; if ( a . charAt ( 0 ) == "0" ) dp [ 0 ] [ 1 ] = 1 ; else dp [ 0 ] [ 1 ] = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a . charAt ( i ) == "1" ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 1 ; } else dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; if ( a . charAt ( i ) == "0" ) { dp [ i ] [ 1 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + 1 ; } else dp [ i ] [ 1 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; } let answer = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) { answer = Math . min ( answer , dp [ i ] [ 1 ] + dp [ n - 1 ] [ 0 ] - dp [ i ] [ 0 ] ) ; } return Math . min ( answer , dp [ n - 1 ] [ 0 ] ) ; }
function LIIDS ( arr , N ) { let dp = [ ] ; let ans = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { dp [ i ] = 1 ; } for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = i + i ; j <= N ; j += i ) { if ( j < arr . length && arr [ j ] > arr [ i ] ) { dp [ j ] = Math . max ( dp [ j ] , dp [ i ] + 1 ) ; } } ans = Math . max ( ans , dp [ i ] ) ; } return ans ; }
function isPerfectSquare ( x ) { let sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
function findSubarraySum ( arr , n , k ) { let prevSum = new Map ( ) ; let res = 0 ; let currsum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == K ) { res ++ ; } if ( prevSum . has ( currsum - K ) ) res += ( prevSum . get ( currsum - K ) ) ; prevSum . set ( currsum , prevSum . get ( currsum ) == null ? 1 : prevSum . get ( currsum ) + 1 ) ; } return res ; }
function countSubarray ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) { if ( isPerfectSquare ( arr [ i ] ) ) { arr [ i ] = 1 ; } else { arr [ i ] = 0 ; } } document . write ( findSubarraySum ( arr , n , K ) ) ; }
function calculate ( pos , left , k , L , R ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; var answer = 0 ; for ( var i = L ; i <= R ; i ++ ) { if ( i > left ) break ; answer = ( answer + calculate ( pos + 1 , left - i , k , L , R ) ) % mod ; } return answer ; }
function countWaystoDivide ( n , k , L , R ) { return calculate ( 0 , n , k , L , R ) ; }
function calculate ( pos , left , k , L , R ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos ] [ left ] != - 1 ) return dp [ pos ] [ left ] ; var answer = 0 ; for ( var i = L ; i <= R ; i ++ ) { if ( i > left ) break ; answer = ( answer + calculate ( pos + 1 , left - i , k , L , R ) ) % mod ; } return dp [ pos ] [ left ] = answer ; }
function countWaystoDivide ( n , k , L , R ) { dp = Array . from ( Array ( 1000 ) , ( ) => Array ( 1000 ) . fill ( - 1 ) ) ; return calculate ( 0 , n , k , L , R ) ; }
function PossibleSum ( n , m , v , k ) { var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( k + 1 ) . fill ( 0 ) ) ; dp [ 0 ] [ 0 ] = 1 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j <= k ; j ++ ) { if ( dp [ i ] [ j ] == 1 ) { for ( var d = 0 ; d < m ; d ++ ) { if ( ( j + v [ i ] [ d ] ) <= k ) { dp [ i + 1 ] [ j + v [ i ] [ d ] ] = 1 ; } } } } } if ( dp [ n ] [ k ] == 1 ) document . write ( "YES" ) ; else document . write ( "NO" ) ; }
function printList ( temp ) { while ( temp != null ) { document . write ( temp . info + "▁" ) ; temp = temp . next ; } }
function solve ( arr , curr , mask , n ) { if ( isprime ( curr ) ) { if ( mask == ( 1 << n ) - 1 ) { return true ; } curr = 0 ; } if ( mask == ( 1 << n ) - 1 ) { if ( ! isprime ( curr ) ) { return false ; } } if ( dp [ mask ] ) return dp [ mask ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( ! ( mask & 1 << i ) ) { if ( solve ( arr , curr + arr [ i ] , mask 1 << i , n ) ) { return true ; } } } return dp [ mask ] = false ; }
function minSqrNum ( n ) { var arr = Array ( n + 1 ) , k ; var sqrNum = Array ( n + 1 ) ; var v = [ ] ; arr [ 0 ] = 0 ; sqrNum [ 0 ] = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { arr [ i ] = arr [ i - 1 ] + 1 ; sqrNum [ i ] = 1 ; k = 1 ; while ( k * k <= i ) { if ( arr [ i ] > arr [ i - k * k ] + 1 ) { arr [ i ] = arr [ i - k * k ] + 1 ; sqrNum [ i ] = k * k ; } k ++ ; } } while ( n > 0 ) { v . push ( sqrNum [ n ] ) ; n -= sqrNum [ n ] ; } return v ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
function nCr ( n , p , f , m ) { for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= m ; j ++ ) { if ( j > i ) { f [ i ] [ j ] = 0 ; } else if ( j == 0 j == i ) { f [ i ] [ j ] = 1 ; } else { f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p ; } } } }
function sieve ( ) { for ( var i = 2 ; i * i <= 1000 ; i ++ ) { if ( isprime [ i ] ) { for ( var j = i * i ; j <= 1000 ; j += i ) { isprime [ j ] = false ; } } } for ( var i = 2 ; i <= 1000 ; i ++ ) { if ( isprime [ i ] ) { prime . push ( i ) ; } } }
function CountWays ( i , j , sum , n , k ) { if ( i > prime . length sum > n ) { return 0 ; } if ( sum == n ) { if ( j == k ) { return 1 ; } return 0 ; } if ( j == k ) return 0 ; if ( dp [ i ] [ j ] [ sum ] ) return dp [ i ] [ j ] [ sum ] ; var inc = 0 , exc = 0 ; inc = CountWays ( i + 1 , j + 1 , sum + prime [ i ] , n , k ) ; exc = CountWays ( i + 1 , j , sum , n , k ) ; return dp [ i ] [ j ] [ sum ] = inc + exc ; }
function createTable ( mtrx , k , p , dp ) { dp [ 0 ] [ 0 ] = mtrx [ 0 ] [ 0 ] ; for ( var j = 1 ; j < dim ; j ++ ) { dp [ 0 ] [ j ] = mtrx [ 0 ] [ j ] + dp [ 0 ] [ j - 1 ] ; } for ( var i = 1 ; i < dim ; i ++ ) { dp [ i ] [ 0 ] = mtrx [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; } for ( var i = 1 ; i < dim ; i ++ ) { for ( var j = 1 ; j < dim ; j ++ ) { dp [ i ] [ j ] = mtrx [ i ] [ j ] + dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; } } }
function countSubMatrixUtil ( dp , k , p ) { var count = 0 ; var subMatSum = 0 ; for ( var i = k - 1 ; i < dim ; i ++ ) { for ( var j = k - 1 ; j < dim ; j ++ ) { if ( i == ( k - 1 ) || j == ( k - 1 ) ) { if ( i == ( k - 1 ) && j == ( k - 1 ) ) { subMatSum = dp [ i ] [ j ] ; } else if ( i == ( k - 1 ) ) { subMatSum = dp [ i ] [ j ] - dp [ i ] [ j - k ] ; } else { subMatSum = dp [ i ] [ j ] - dp [ i - k ] [ j ] ; } } else { subMatSum = dp [ i ] [ j ] - dp [ i - k ] [ j ] - dp [ i ] [ j - k ] + dp [ i - k ] [ j - k ] ; } if ( subMatSum >= p ) { count ++ ; } } } return count ; }
function solve ( arr , i , len , prev , n , k ) { if ( len == k ) return 0 ; if ( i == n ) return Number . MIN_SAFE_INTEGER ; if ( dp [ i ] [ len ] [ prev ] ) return dp [ i ] [ len ] [ prev ] ; let inc = 0 , exc = 0 ; if ( len & 1 ) { inc = productDigitSum ( arr [ prev ] , arr [ i ] ) + solve ( arr , i + 1 , len + 1 , 0 , n , k ) ; } else { inc = solve ( arr , i + 1 , len + 1 , i , n , k ) ; } exc = solve ( arr , i + 1 , len , prev , n , k ) ; return dp [ i ] [ len ] [ prev ] = Math . max ( inc , exc ) ; }
function precompute ( ) { for ( let i = 1 ; i <= 100000 ; i ++ ) { for ( let j = i ; j <= 100000 ; j += i ) { factors [ j ] . push ( i ) ; } } }
function solve ( arr , k , n ) { if ( k == n - 1 ) { return 0 ; } if ( k >= n ) { return Number . MAX_SAFE_INTEGER ; } if ( dp [ k ] ) { return dp [ k ] ; } let ans = Number . MAX_SAFE_INTEGER ; for ( let j of factors [ arr [ k ] ] ) { let res = solve ( arr , k + j , n ) ; if ( res != Number . MAX_SAFE_INTEGER ) { ans = Math . min ( ans , res + 1 ) ; } } return dp [ k ] = ans ; }
function precompute ( ) { for ( var i = 1 ; i <= 100000 ; i ++ ) { for ( var j = i ; j <= 100000 ; j += i ) factors [ j ] . push ( i ) ; } }
function solve ( arr , n ) { for ( var i = 0 ; i <= 100005 ; i ++ ) { dp [ i ] = 1000000000 ; } dp [ 0 ] = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j of factors [ arr [ i ] ] ) { if ( i + j < n ) dp [ i + j ] = Math . min ( dp [ i + j ] , 1 + dp [ i ] ) ; } } return dp [ n - 1 ] ; }
function operation ( n ) { dp = Array ( n + 1 ) . fill ( ) . map ( ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; for ( i = 0 ; i < n + 1 ; i ++ ) { for ( j = 0 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } var ans = 0 , fac = 1 ; for ( k = 1 ; k <= n ; k ++ ) { fac *= k ; ans = ( ans + ( fac * f ( n , k ) ) % mod ) % mod ; } return ans ; }
function countWays ( n , m ) { var dp = Array . from ( Array ( m + 1 ) , ( ) => Array ( n + 1 ) ) ; for ( var i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } var sum ; for ( var i = 2 ; i <= m ; i ++ ) { for ( var j = 0 ; j <= n ; j ++ ) { sum = 0 ; for ( var k = 0 ; k <= j ; k ++ ) { sum += dp [ i - 1 ] [ k ] ; } dp [ i ] [ j ] = sum ; } } return dp [ m ] [ n ] ; }
function countWays ( n , m ) { let dp = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) dp [ i ] [ j ] = 0 ; } for ( let i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; if ( i != 0 ) { dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] ; } } for ( let i = 2 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( i == m && j == n ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } return Number . MIN_VALUE ; }
function ConvertIntoDigit ( n ) { while ( n > 0 ) { let dig = n % 10 ; digits . push ( dig ) ; n = parseInt ( n / 10 , 10 ) ; } digits . reverse ( ) ; }
function solve ( idx , k , tight , sum ) { if ( idx == digits . length && k == 0 && sum % 2 == 1 ) { if ( ! vis [ sum ] ) { vis [ sum ] = true ; return 1 ; } return 0 ; } if ( idx > digits . length ) { return 0 ; } if ( dp [ idx ] [ k ] [ tight ] [ sum ] > 0 ) { return dp [ idx ] [ k ] [ tight ] [ sum ] ; } let j ; if ( idx < digits . length && tight == 0 ) { j = digits [ idx ] ; } else { j = 9 ; } let cnt = 0 ; for ( let i = ( k > 0 ? 0 : 1 ) ; i <= j ; i ++ ) { let newtight = tight ; if ( i < j ) { newtight = 1 ; } if ( i == 0 ) cnt += solve ( idx + 1 , k - 1 , newtight , sum ) ; else cnt += solve ( idx + 1 , k , newtight , sum + i ) ; } dp [ idx ] [ k ] [ tight ] [ sum ] = cnt ; return dp [ idx ] [ k ] [ tight ] [ sum ] ; }
function minDominatingSet ( root , covered , compulsory ) { if ( root == null ) return 0 ; if ( root . left != null && root . right != null && covered > 0 ) compulsory = 1 ; if ( dp [ root . data ] [ covered ] [ compulsory ] != - 1 ) return dp [ root . data ] [ covered ] [ compulsory ] ; if ( compulsory > 0 ) { return dp [ root . data ] [ covered ] [ compulsory ] = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; } if ( covered > 0 ) { return dp [ root . data ] [ covered ] [ compulsory ] = Math . min ( 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; } let ans = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; if ( root . left != null ) { ans = Math . min ( ans , minDominatingSet ( root . left , 0 , 1 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; } if ( root . right != null ) { ans = Math . min ( ans , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 1 ) ) ; } dp [ root . data ] [ covered ] [ compulsory ] = ans ; return dp [ root . data ] [ covered ] [ compulsory ] ; }
function getmask ( val ) { var mask = 0 ; var prime = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 ] ; for ( var i = 0 ; i < 15 ; i ++ ) { if ( val % prime [ i ] == 0 ) { mask = mask | ( 1 << i ) ; } } return mask ; }
function calculate ( pos , mask , a , n ) { if ( pos == n || mask == ( 1 << n - 1 ) ) return 0 ; if ( dp [ pos ] [ mask ] != - 1 ) return dp [ pos ] [ mask ] ; var size = 0 ; size = Math . max ( size , calculate ( pos + 1 , mask , a , n ) ) ; if ( ( getmask ( a [ pos ] ) & mask ) == 0 ) { var new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) ; size = Math . max ( size , 1 + calculate ( pos + 1 , new_mask , a , n ) ) ; } return dp [ pos ] [ mask ] = size ; }
function largestSubset ( a , n ) { dp = Array . from ( Array ( 5000 ) , ( ) => Array ( ( 1 << 10 ) + 5 ) . fill ( - 1 ) ) ; return calculate ( 0 , 0 , a , n ) ; }
function countSubsets ( N ) { if ( N <= 2 ) return N ; if ( N == 3 ) return 2 ; var DP = Array ( N + 1 ) . fill ( 0 ) ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; DP [ 2 ] = 2 ; DP [ 3 ] = 2 ; for ( i = 4 ; i <= N ; i ++ ) { DP [ i ] = DP [ i - 2 ] + DP [ i - 3 ] ; } return DP [ N ] ; }
function CountSets ( x , pos ) { if ( x <= 0 ) { if ( pos == 0 ) return 1 ; else return 0 ; } if ( pos == 0 ) return 1 ; var answer = CountSets ( x - 1 , pos ) + CountSets ( x - 2 , pos - 1 ) ; return answer ; }
function CountOrderedSets ( n ) { var factorial = Array ( 10000 ) . fill ( 0 ) ; factorial [ 0 ] = 1 ; for ( i = 1 ; i < 10000 ; i ++ ) factorial [ i ] = factorial [ i - 1 ] * i ; var answer = 0 ; for ( i = 1 ; i <= n ; i ++ ) { var sets = CountSets ( n , i ) * factorial [ i ] ; answer = answer + sets ; } return answer ; }
function CountOrderedSets ( n ) { var factorial = Array ( 10000 ) . fill ( 0 ) ; factorial [ 0 ] = 1 ; for ( var i = 1 ; i < 10000 ; i ++ ) factorial [ i ] = factorial [ i - 1 ] * i ; var answer = 0 ; dp = Array . from ( Array ( 500 ) , ( ) => Array ( 500 ) . fill ( - 1 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { var sets = CountSets ( n , i ) * factorial [ i ] ; answer = answer + sets ; } return answer ; }
function numberOfArithmeticSequences ( L , N ) { if ( N <= 2 ) return 0 ; var count = 0 ; var res = 0 ; for ( var i = 2 ; i < N ; ++ i ) { if ( L [ i ] - L [ i - 1 ] == L [ i - 1 ] - L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
function count_special ( n ) { var fib = [ ... Array ( n + 1 ) ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( var i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( ( fib [ i - 1 ] % mod ) + ( fib [ i - 2 ] % mod ) ) % mod ; } return fib [ n ] ; }
function CountOfTriplets ( a , n ) { let answer = 0 ; let x = 0 ; let count = new Array ( 100005 ) ; let ways = new Array ( 100005 ) ; count . fill ( 0 ) ; ways . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { x ^= a [ i ] ; answer += count [ x ] * i - ways [ x ] ; count [ x ] ++ ; ways [ x ] = ways [ x ] + i + 1 ; } return answer ; }
function MaximumSum ( a , n ) { let dp = [ ] ; for ( let i = 0 ; i < n + 1 ; i ++ ) dp . push ( Array ( n + 1 ) ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { for ( let j = 0 ; j < n + 1 ; j ++ ) dp [ i ] [ j ] = - 10000 ; } for ( let i = 0 ; i < n + 1 ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= i ; j ++ ) { let val = - 10000 ; if ( ( i - 2 >= 0 && dp [ i - 2 , j - 1 ] != - 10000 ) i - 2 < 0 ) { val = a [ i - 1 ] + ( i - 2 >= 0 ? dp [ i - 2 ] [ j - 1 ] : 0 ) ; } if ( i - 1 >= j ) { val = Math . max ( val , dp [ i - 1 ] [ j ] ) ; } dp [ i ] [ j ] = val ; } } return dp [ n ] [ n / 2 ] }
function MaximumSum ( a , n ) { var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( 2 ) . fill ( 0 ) ) ; dp [ 2 ] [ 1 ] = a [ 1 ] ; dp [ 2 ] [ 0 ] = a [ 0 ] ; for ( var i = 3 ; i < n + 1 ; i ++ ) { if ( i & 1 ) { var temp = ( [ dp [ i - 3 ] [ 1 ] , dp [ i - 3 ] [ 0 ] , dp [ i - 2 ] [ 1 ] , dp [ i - 2 ] [ 0 ] ] . reduce ( ( a , b ) => Math . max ( a , b ) ) ) ; dp [ i ] [ 1 ] = a [ i - 1 ] + temp ; dp [ i ] [ 0 ] = ( [ a [ i - 2 ] + dp [ i - 2 ] [ 0 ] , a [ i - 2 ] + dp [ i - 3 ] [ 1 ] , a [ i - 2 ] + dp [ i - 3 ] [ 0 ] , a [ i - 3 ] + dp [ i - 3 ] [ 0 ] ] . reduce ( ( a , b ) => Math . max ( a , b ) ) ) ; } else { dp [ i ] [ 1 ] = a [ i - 1 ] + ( [ dp [ i - 2 ] [ 1 ] , dp [ i - 2 ] [ 0 ] , dp [ i - 1 ] [ 0 ] ] . reduce ( ( a , b ) => Math . max ( a , b ) ) ) ; dp [ i ] [ 0 ] = a [ i - 2 ] + dp [ i - 2 ] [ 0 ] ; } } return Math . max ( dp [ n ] [ 1 ] , dp [ n ] [ 0 ] ) ; }
function func ( n ) { if ( n <= 0 ) return 0 ; if ( kPowKform . has ( n ) ) return 1 ; var answer = 0 ; var x = n ; while ( x > 0 ) { var d = x % 10 ; if ( d != 0 ) { if ( func ( n - d * d ) ) { answer = 1 ; break ; } } x = parseInt ( x / 10 ) ; } return answer ; }
function canBeConverted ( n ) { if ( func ( n ) ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function divisorGame ( N , A , dp ) { if ( N == 1 N == 3 ) return false ; if ( N == 2 ) return true ; if ( dp [ N ] [ A ] != - 1 ) return dp [ N ] [ A ] ; let ans = ( A == 1 ) ? 0 : 1 ; for ( let i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( A ) ans |= divisorGame ( N - i , 0 , dp ) ; else ans &= divisorGame ( N - i , 1 , dp ) ; } } return dp [ N ] [ A ] = ans ; }
function check ( v ) { let digits = new Set ( ) ; for ( let i = 0 ; i < v . length ; i ++ ) { let d = new Set ( ) ; while ( v [ i ] ) { d . add ( v [ i ] % 10 ) ; v [ i ] = Math . floor ( v [ i ] / 10 ) ; } for ( let it of d ) { if ( digits . has ( it ) ) return false ; } for ( let it of d ) digits . add ( it ) ; } return true ; }
function numberOfSubarrays ( a , n ) { let answer = 0 ; for ( let i = 1 ; i < ( 1 << n ) ; i ++ ) { let temp = new Array ( ) ; for ( let j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) temp . push ( a [ j ] ) ; } if ( check ( temp ) ) answer ++ ; } return answer ; }
function countWays ( pos , mask , a , n ) { if ( pos == n ) return ( mask > 0 ? 1 : 0 ) ; if ( dp [ pos ] [ mask ] != - 1 ) return dp [ pos ] [ mask ] ; var count = 0 ; count = count + countWays ( pos + 1 , mask , a , n ) ; if ( ( getmask ( a [ pos ] ) & mask ) == 0 ) { var new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) ; count = count + countWays ( pos + 1 , new_mask , a , n ) ; } return dp [ pos ] [ mask ] = count ; }
function numberOfSubarrays ( a , n ) { dp = Array . from ( Array ( 5000 ) , ( ) => Array ( ( 1 << 10 ) + 5 ) . fill ( - 1 ) ) ; return countWays ( 0 , 0 , a , n ) ; }
function change ( p , x ) { if ( p . second > x ) p . second = x ; if ( p . first > p . second ) { var tmp = p . first ; p . first = p . second ; p . second = tmp ; } }
function minNodetoRemove ( n , edges ) { for ( var i = 0 ; i < edges . length ; i ++ ) { ( adj [ ( edges [ i ] ) . first ] ) . push ( ( edges [ i ] ) . second ) ; ( adj [ ( edges [ i ] ) . second ] ) . push ( ( edges [ i ] ) . first ) ; } vis = Array ( MAX ) . fill ( 0 ) ; totBackEdges = 0 ; for ( var v = 1 ; v <= n ; v ++ ) { if ( vis [ v ] == 0 ) dfs ( v ) ; } if ( totBackEdges == 0 ) return - 1 ; var node = - 1 ; for ( var v = 1 ; v <= n ; v ++ ) { if ( ( countAdj [ v ] + small [ v ] == totBackEdges ) && isPossible [ v ] != 0 ) { node = v ; } if ( node != - 1 ) break ; } return node ; }
function height ( root ) { if ( root == null ) return 0 ; return ( Math . max ( height ( root . left ) , height ( root . right ) ) + 1 ) ; }
function FibonacciSeries ( n ) { fib . push ( 0 ) ; fib . push ( 1 ) ; for ( let i = 2 ; i < n ; i ++ ) fib . push ( fib [ i - 1 ] + fib [ i - 2 ] ) ; }
function CountPathUtil ( root , i , count ) { if ( root == null || ! ( fib [ i ] == root . data ) ) { return count ; } if ( root . left != null && root . right != null ) { count ++ ; } count = CountPathUtil ( root . left , i + 1 , count ) ; return CountPathUtil ( root . right , i + 1 , count ) ; }
function CountPath ( root ) { let ht = height ( root ) ; FibonacciSeries ( ht ) ; document . write ( CountPathUtil ( root , 0 , 0 ) ) ; }
function SieveOfEratosthenes ( ) { let isPrime = new Array ( ) ; for ( let i = 0 ; i < Large + 1 ; i ++ ) { isPrime . push ( [ ] ) } isPrime . fill ( true ) ; for ( let p = 2 ; p * p <= Large ; p ++ ) { if ( isPrime [ p ] == true ) { for ( let i = p * 2 ; i <= Large ; i += p ) isPrime [ i ] = false ; } } for ( let p = 2 ; p <= Large ; p ++ ) if ( isPrime [ p ] ) prime . push ( p ) ; }
function Display ( arr , row ) { for ( let i = 0 ; i < M ; i ++ ) document . write ( arr [ row ] [ i ] + "▁" ) ; }
function countDivisorsMult ( arr ) { let mp = new Map ( ) ; let row_no = 0 ; let max_factor = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { let no = arr [ i ] [ j ] ; for ( let k = 0 ; k < prime . length ; k ++ ) { while ( no > 1 && no % prime [ k ] == 0 ) { no /= prime [ k ] ; if ( mp . has ( prime [ k ] ) ) { mp . set ( prime [ k ] , mp . get ( prime [ k ] ) + 1 ) } else { mp . set ( prime [ k ] , 1 ) } } if ( no == 1 ) break ; } } let res = 1 ; for ( let it of mp ) { res *= ( it [ 1 ] + 1 ) ; } if ( max_factor < res ) { row_no = i ; max_factor = res ; } mp . clear ( ) ; } Display ( arr , row_no ) ; }
function isSquare ( n ) { let k = Math . floor ( Math . sqrt ( n ) ) ; return k * k == n ? 1 : 0 ; }
function calculate ( pos , prev , sum , v ) { if ( pos == v . length ) return isSquare ( sum ) ; for ( let i = prev ; i <= 9 ; i ++ ) { v [ pos ] = i ; sum += i * i ; if ( calculate ( pos + 1 , i , sum , v ) != 0 ) return 1 ; sum -= ( i * i ) ; } return 0 ; }
function countMountains ( a , n ) { var A = new Array ( n + 2 ) . fill ( 0 ) . map ( ( ) => new Array ( n + 2 ) . fill ( 0 ) ) ; var count = 0 ; for ( var i = 0 ; i < n + 2 ; i ++ ) { for ( var j = 0 ; j < n + 2 ; j ++ ) { if ( ( i == 0 ) || ( j == 0 ) || ( i == n + 1 ) || ( j == n + 1 ) ) { A [ i ] [ j ] = Number . MIN_VALUE ; } else { A [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] ; } } } for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= n ; j ++ ) { if ( ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j - 1 ] ) ) { count ++ ; } } } return count ; }
function calculate ( pos , g , n , k ) { if ( pos == n ) { return g ; } var answer = 0 ; for ( var i = 1 ; i <= k ; i ++ ) { answer = ( answer % MOD + calculate ( pos + 1 , __gcd ( g , i ) , n , k ) % MOD ) ; answer %= MOD ; } return answer ; }
function sumofGCD ( n , k ) { return calculate ( 0 , 0 , n , k ) ; }
function fastexpo ( a , b ) { var res = 1 ; a %= MOD ; while ( b ) { if ( b & 1 ) res = ( res * a ) % MOD ; a *= a ; a %= MOD ; b >>= 1 ; } return res ; }
function sumofGCD ( n , k ) { var count = Array ( k + 1 ) . fill ( 0 ) ; for ( var g = k ; g >= 1 ; g -- ) { var count_multiples = k / g ; var temp ; temp = fastexpo ( count_multiples , n ) ; temp %= MOD ; var extra = 0 ; for ( var j = g * 2 ; j <= k ; j += g ) { extra = ( extra + count [ j ] ) ; extra %= MOD ; } count [ g ] = ( temp - extra + MOD ) ; count [ g ] %= MOD ; } var sum = 0 ; var add ; for ( var i = 1 ; i <= k ; ++ i ) { add = ( count [ i ] % MOD * i % MOD ) ; add %= MOD ; sum += add ; sum %= MOD ; } return sum ; }
function findCost ( cost_mat , N , M ) { var dp = Array ( N ) ; for ( i = 0 ; i < N ; i ++ ) dp [ i ] = Array ( M ) . fill ( 0 ) ; for ( i = 0 ; i < M ; i ++ ) dp [ 0 ] [ i ] = cost_mat [ 0 ] [ i ] ; for ( row = 1 ; row < N ; row ++ ) { for ( curr_col = 0 ; curr_col < M ; curr_col ++ ) { var val = 999999999 ; for ( prev_col = 0 ; prev_col < M ; prev_col ++ ) { if ( curr_col != prev_col ) val = Math . min ( val , dp [ row - 1 ] [ prev_col ] ) ; } dp [ row ] [ curr_col ] = val + cost_mat [ row ] [ curr_col ] ; } } var ans = Number . MAX_VALUE ; for ( i = 0 ; i < M ; i ++ ) ans = Math . min ( ans , dp [ N - 1 ] [ i ] ) ; return ans ; }
function checkOdd ( number ) { let n = number . length ; let num = number [ n - 1 ] - "0" ; return ( num & 1 ) ; }
function getPrimesFromSeive ( primes ) { let prime = new Array ( 1000001 ) ; for ( let i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( let i = 2 ; i * i <= 1000000 ; i ++ ) { if ( prime [ i ] == true ) { for ( let j = i * i ; j <= 1000000 ; j += i ) prime [ j ] = false ; } } for ( let i = 2 ; i <= 1000000 ; i ++ ) { if ( prime [ i ] == true ) primes . add ( ( i ) . toString ( ) ) ; } }
function splitIntoPrimes ( number ) { let numLen = number . length ; let splitDP = new Array ( numLen + 1 ) ; for ( let i = 0 ; i < splitDP . length ; i ++ ) { splitDP [ i ] = - 1 ; } let primes = new Set ( ) ; getPrimesFromSeive ( primes ) ; for ( let i = 1 ; i <= numLen ; i ++ ) { if ( i <= 6 && ( primes . has ( number . substring ( 0 , i ) ) ) ) splitDP [ i ] = 1 ; if ( splitDP [ i ] != - 1 ) { for ( let j = 1 ; j <= 6 && i + j <= numLen ; j ++ ) { if ( primes . has ( number . substring ( i , i + j ) ) ) { if ( splitDP [ i + j ] == - 1 ) splitDP [ i + j ] = 1 + splitDP [ i ] ; else splitDP [ i + j ] = Math . min ( splitDP [ i + j ] , 1 + splitDP [ i ] ) ; } } } } return splitDP [ numLen ] ; }
function k_nonzero_numbers ( s , n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = new Array ( k + 1 ) ; for ( let x = 0 ; x <= k ; x ++ ) dp [ i ] [ j ] [ x ] = 0 ; } } dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( let i = 0 ; i < n ; ++ i ) { let sm = 0 ; while ( sm < 2 ) { for ( let j = 0 ; j < k + 1 ; ++ j ) { let x = 0 ; while ( x <= ( sm != 0 ? 9 : s [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) ) { if ( j + ( x > 0 ? 1 : 0 ) < k + 1 ) { dp [ i + 1 ] [ ( sm != 0 || x < ( s [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) ) ? 1 : 0 ] [ j + ( x > 0 ? 1 : 0 ) ] += dp [ i ] [ sm ] [ j ] ; } ++ x ; } } ++ sm ; } } return dp [ n ] [ 0 ] [ k ] + dp [ n ] [ 1 ] [ k ] ; }
function maximumOccurrence ( s ) { var n = s . length ; var freq = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { var temp = "" ; temp += s [ i ] ; if ( freq . has ( temp ) ) freq . set ( temp , freq . get ( temp ) + 1 ) else freq . set ( temp , 1 ) } for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { var temp = "" ; temp += s [ i ] ; temp += s [ j ] ; if ( freq . has ( temp ) ) freq . set ( temp , freq . get ( temp ) + 1 ) else freq . set ( temp , 1 ) } } var answer = - 1000000000 ; freq . forEach ( ( value , key ) => { answer = Math . max ( answer , value ) ; } ) ; return answer ; }
function maximumOccurrence ( s ) { var n = s . length ; var freq = Array ( 26 ) . fill ( 0 ) ; var dp = Array ( 26 ) . fill ( ) . map ( ( ) => Array ( 26 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var c = ( s . charCodeAt ( i ) - "a" . charCodeAt ( 0 ) ) ; for ( var j = 0 ; j < 26 ; j ++ ) dp [ j ] += freq [ j ] ; freq ++ ; } var answer = Number . MIN_VALUE ; for ( var i = 0 ; i < 26 ; i ++ ) answer = Math . max ( answer , freq [ i ] ) ; for ( var i = 0 ; i < 26 ; i ++ ) { for ( var j = 0 ; j < 26 ; j ++ ) { answer = Math . max ( answer , dp [ i ] [ j ] ) ; } } return answer ; }
function calculate ( pos , rem , z , k , n ) { if ( rem == 0 && z ) { if ( pos != n ) return ( powers [ n - pos - 1 ] * 9 ) % mod ; else return 1 ; } if ( pos == n ) return 0 ; if ( dp [ pos ] [ rem ] [ z ] != - 1 ) return dp [ pos ] [ rem ] [ z ] ; var count = 0 ; for ( var i = 0 ; i < 10 ; i ++ ) { if ( i == 0 ) count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , z , k , n ) ) ) % mod ; else count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , 1 , k , n ) ) ) % mod ; } return dp [ pos ] [ rem ] [ z ] = count ; }
function waysToSplit ( s ) { let n = s . length ; let answer = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let left = s . substr ( 0 , i ) ; let right = s . substr ( i , n - i ) ; if ( distinctChars ( left ) == distinctChars ( right ) ) answer ++ ; } return answer ; }
function waysToSplit ( s ) { var n = s . length ; var answer = 0 ; var prefix = Array ( n ) . fill ( 0 ) ; var suffix = Array ( n ) . fill ( 0 ) ; var seen = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { var prev = ( i - 1 >= 0 ? prefix [ i - 1 ] : 0 ) ; if ( seen [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] == 0 ) { prefix [ i ] += ( prev + 1 ) ; } else prefix [ i ] = prev ; seen [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] = 1 ; } seen = Array ( 26 ) . fill ( 0 ) ; suffix [ n - 1 ] = 0 ; for ( var i = n - 1 ; i >= 1 ; i -- ) { var prev = suffix [ i ] ; if ( seen [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] == 0 ) { suffix [ i - 1 ] += ( prev + 1 ) ; } else suffix [ i - 1 ] = prev ; seen [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] = 1 ; } for ( var i = 0 ; i < n ; i ++ ) { if ( prefix [ i ] == suffix [ i ] ) answer ++ ; } return answer ; }
function calculate ( pos , tight , D , sz , num ) { if ( pos == num . length ) return 1 ; if ( dp [ pos ] [ tight ] != - 1 ) return dp [ pos ] [ tight ] ; var val = 0 ; if ( tight == 0 ) { for ( var i = 0 ; i < sz ; i ++ ) { if ( D [ i ] < ( num [ pos ] - "0" ) ) { val += calculate ( pos + 1 , 1 , D , sz , num ) ; } else if ( D [ i ] == num [ pos ] - "0" ) val += calculate ( pos + 1 , tight , D , sz , num ) ; } } else { for ( var i = 0 ; i < sz ; i ++ ) { val += calculate ( pos + 1 , tight , D , sz , num ) ; } } return dp [ pos ] [ tight ] = val ; }
function countNumbers ( D , N , sz ) { var num = ( N . toString ( ) ) ; var len = num . length ; var ans = calculate ( 0 , 0 , D , sz , num ) ; for ( var i = 1 ; i < len ; i ++ ) ans += calculate ( i , 1 , D , sz , num ) ; return ans ; }
function fibonacci ( ) { var i ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( i = 2 ; i <= MAX_SIZE ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } }
function printLevel ( level ) { var left_index = parseInt ( Math . pow ( 2 , level - 1 ) ) ; var right_index = parseInt ( ( Math . pow ( 2 , level ) - 1 ) ) ; for ( i = left_index ; i <= right_index ; i ++ ) { document . write ( fib [ i - 1 ] + "▁" ) ; } document . write ( ) ; }
function calculate ( pos , prev , left , k ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; let answer = 0 ; for ( let i = prev ; i <= left ; i ++ ) { answer += calculate ( pos + 1 , i , left - i , k ) ; } return answer ; }
function countWaystoDivide ( n , k ) { return calculate ( 0 , 1 , n , k ) ; }
function calculate ( pos , prev , left , k ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos ] [ prev ] [ left ] != - 1 ) return dp [ pos ] [ prev ] [ left ] ; let answer = 0 ; for ( let i = prev ; i <= left ; i ++ ) { answer += calculate ( pos + 1 , i , left - i , k ) ; } return dp [ pos ] [ prev ] [ left ] = answer ; }
function countWaystoDivide ( n , k ) { for ( let i = 0 ; i < 500 ; i ++ ) { for ( let j = 0 ; j < 500 ; j ++ ) { for ( let l = 0 ; l < 500 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } } return calculate ( 0 , 1 , n , k ) ; }
function countWays ( a , s ) { let n = a . length ; let index = [ ] ; for ( let i = 0 ; i < 26 ; i ++ ) index . push ( [ ] ) ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < a [ i ] . length ; j ++ ) { index [ a [ i ] [ j ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] . push ( j + 1 ) ; } } for ( let i = 0 ; i < 1000 ; i ++ ) { for ( let j = 0 ; j < 1000 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return calculate ( 0 , 0 , s , index [ 0 ] ) ; }
function minimalLength ( a , n ) { var i , j , k ; var dp = Array ( n + 1 ) . fill ( Array ( n + 1 ) . fill ( - 1 ) ) ; var dp1 = Array ( n ) . fill ( 0 ) ; for ( var size = 1 ; size <= n ; size ++ ) { for ( i = 0 ; i < n - size + 1 ; i ++ ) { j = i + size - 1 ; if ( i == j ) dp [ i ] [ j ] = a [ i ] ; else { for ( k = i ; k < j ; k ++ ) { if ( dp [ i ] [ k ] != - 1 && dp [ i ] [ k ] == dp [ k + 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i ] [ k ] + 1 ; } } } } for ( i = 0 ; i < n ; i ++ ) dp1 [ i ] = 1000000000 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( dp [ j ] [ i ] != - 1 ) { if ( j == 0 ) dp1 [ i ] = 2 ; else dp1 [ i ] = Math . min ( dp1 [ i ] , dp1 [ j - 1 ] + 1 ) ; } } } return dp1 [ n - 1 ] ; }
function maxScore ( l , r , prefix_sum , num ) { if ( l > r ) return 0 ; let current_sum = prefix_sum [ r ] - ( l - 1 >= 0 ? prefix_sum [ l - 1 ] : 0 ) ; if ( num % 2 == 0 ) current_sum *= - 1 ; return current_sum + Math . max ( maxScore ( l + 1 , r , prefix_sum , num + 1 ) , maxScore ( l , r - 1 , prefix_sum , num + 1 ) ) ; }
function findMaxScore ( a , n ) { let prefix_sum = new Uint8Array ( n ) ; prefix_sum [ 0 ] = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { prefix_sum [ i ] = prefix_sum [ i - 1 ] + a [ i ] ; } return maxScore ( 0 , n - 1 , prefix_sum , 1 ) ; }
function MaximumScoreDP ( l , r , prefix_sum , num ) { if ( l > r ) return 0 ; if ( dp [ l ] [ r ] [ num ] != - 1 ) return dp [ l ] [ r ] [ num ] ; let current_sum = prefix_sum [ r ] - ( l - 1 >= 0 ? prefix_sum [ l - 1 ] : 0 ) ; if ( num % 2 == 0 ) current_sum *= - 1 ; dp [ l ] [ r ] [ num ] = current_sum + Math . max ( MaximumScoreDP ( l + 1 , r , prefix_sum , num + 1 ) , MaximumScoreDP ( l , r - 1 , prefix_sum , num + 1 ) ) ; return dp [ l ] [ r ] [ num ] ; }
function findMaxScore ( a , n ) { let prefix_sum = new Array ( n ) ; prefix_sum [ 0 ] = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { prefix_sum [ i ] = prefix_sum [ i - 1 ] + a [ i ] ; } return MaximumScoreDP ( 0 , n - 1 , prefix_sum , 1 ) ; }
function computeFibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 1 ; for ( i = 2 ; i < 100005 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } }
function countString ( str ) { var ans = 1 ; var cnt = 1 ; for ( i = 1 ; i < str . length ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( i - 1 ) ) { cnt ++ ; } else { ans = ans * fib [ cnt ] ; cnt = 1 ; } } ans = ans * fib [ cnt ] ; return ans ; }
function find_max ( i , sum , v , k ) { if ( i == v . length ) return 0 ; if ( dp [ i ] [ sum ] != - 1 ) return dp [ i ] [ sum ] ; let ans = 0 ; if ( ( sum + find_max ( i + 1 , sum , v , k ) ) % k == 0 ) ans = find_max ( i + 1 , sum , v , k ) ; if ( ( sum + v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) % k == 0 ) ans = Math . max ( ans , v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) ; return dp [ i ] [ sum ] = ans ; }
function maxLength ( a , n ) { let maximum = 1 ; let left = new Array ( n ) ; let right = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { left [ i ] = 1 ; right [ i ] = 1 ; } for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { right [ i ] = right [ i + 1 ] + 1 ; } maximum = Math . max ( maximum , right [ i ] ) ; } for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { left [ i ] = left [ i - 1 ] + 1 ; } } if ( n > 2 ) { for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i - 1 ] > a [ i + 1 ] ) { maximum = Math . max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; } } } return maximum ; }
function printGolombSequence ( N ) { var arr = Array ( MAX ) ; var cnt = 0 ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; var M = new Map ( ) ; M . set ( 2 , 2 ) ; for ( var i = 2 ; i <= N ; i ++ ) { if ( cnt == 0 ) { arr [ i ] = 1 + arr [ i - 1 ] ; cnt = M . get ( arr [ i ] ) ; cnt -- ; } else { arr [ i ] = arr [ i - 1 ] ; cnt -- ; } M . set ( i , arr [ i ] ) ; } for ( var i = 1 ; i <= N ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function number_of_ways ( n ) { let includes_3 = new Uint8Array ( n + 1 ) ; let not_includes_3 = new Uint8Array ( n + 1 ) ; includes_3 [ 3 ] = 1 ; not_includes_3 [ 1 ] = 1 ; not_includes_3 [ 2 ] = 2 ; not_includes_3 [ 3 ] = 3 ; for ( let i = 4 ; i <= n ; i ++ ) { includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] ; not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] ; } return includes_3 [ n ] ; }
function cntSubSeq ( arr , n ) { var pos_count = 0 ; var neg_count = 0 ; var result ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = Math . pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= Math . pow ( 2 , neg_count - 1 ) ; else result = 0 ; return result ; }
function generateDivisors ( n ) { for ( var i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisors [ i ] ++ ; } else { divisors [ i ] ++ ; divisors [ n / i ] ++ ; } } } }
function findMaxMultiples ( arr , n ) { var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { ans = Math . max ( divisors [ arr [ i ] ] , ans ) ; generateDivisors ( arr [ i ] ) ; } return ans ; }
function max_sum ( arr , n , k ) { var dp = Array . from ( { length : n } , ( _ , i ) => 0 ) ; dp [ 0 ] = Math . max ( 0 , arr [ 0 ] ) ; var i = 1 ; while ( i < k ) { dp [ i ] = Math . max ( dp [ i - 1 ] , arr [ i ] ) ; i ++ ; } i = k ; while ( i < n ) { dp [ i ] = Math . max ( dp [ i - 1 ] , arr [ i ] + dp [ i - k ] ) ; i ++ ; } return dp [ n - 1 ] ; }
function maxIncSubarr ( a , n ) { let pre = new Array ( n ) ; let pos = new Array ( n ) ; pre . fill ( 0 ) ; pos . fill ( 0 ) ; pre [ 0 ] = 1 ; pos [ n - 1 ] = 1 ; let l = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) pre [ i ] = pre [ i - 1 ] + 1 ; else pre [ i ] = 1 ; } l = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] < a [ i + 1 ] ) pos [ i ] = pos [ i + 1 ] + 1 ; else pos [ i ] = 1 ; } let ans = 0 ; l = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) l ++ ; else l = 1 ; ans = Math . max ( ans , l ) ; } for ( let i = 1 ; i <= n - 2 ; i ++ ) { if ( a [ i - 1 ] < a [ i + 1 ] ) ans = Math . max ( pre [ i - 1 ] + pos [ i + 1 ] , ans ) ; } return ans ; }
function countWays ( n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; let f0 = 1 , f1 = 1 , f2 = 2 ; let ans = 0 ; for ( let i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; }
function countStr ( N ) { var dp = Array . from ( Array ( N + 1 ) , ( ) => Array ( 3 ) . fill ( 0 ) ) ; dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( var i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } var ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; }
function update ( inVal , l , r , up_in , val ) { if ( r < up_in l > up_in ) return seg [ inVal ] ; if ( l == up_in && r == up_in ) return seg [ inVal ] = val ; var m = parseInt ( ( l + r ) / 2 ) ; seg [ inVal ] = update ( 2 * inVal + 1 , l , m , up_in , val ) + update ( 2 * inVal + 2 , m + 1 , r , up_in , val ) ; return seg [ inVal ] ; }
function maxLengthSquare ( row , column , arr , k ) { let sum = new Array ( ) ; [ row + 1 ] [ column + 1 ] ; for ( let i = 0 ; i < row + 1 ; i ++ ) { let temp = new Array ( ) ; for ( let j = 0 ; j < column + 1 ; j ++ ) { temp . push ( [ ] ) } sum . push ( temp ) } for ( let i = 1 ; i <= row ; i ++ ) for ( let j = 0 ; j <= column ; j ++ ) sum [ i ] [ j ] = 0 ; let cur_max = 1 ; let max = 0 ; for ( let i = 1 ; i <= row ; i ++ ) { for ( let j = 1 ; j <= column ; j ++ ) { sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] + arr [ i - 1 ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] ; if ( i >= cur_max && j >= cur_max && sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) { max = cur_max ++ ; } } } return max ; }
function getSum ( x , y , z ) { let ans = 0 ; exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( let i = 0 ; i <= x ; ++ i ) { for ( let j = 0 ; j <= y ; ++ j ) { for ( let k = 0 ; k <= z ; ++ k ) { if ( i > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod ; } if ( j > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ; } if ( k > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod ; } ans += exactsum [ i ] [ j ] [ k ] % mod ; ans %= mod ; } } } return ans ; }
function maximum_set ( a , n ) { let dp = new Array ( N ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) dp [ a [ i ] ] = 1 ; let ans = 1 ; for ( let i = N - 1 ; i >= 1 ; i -- ) { if ( dp [ i ] != 0 ) { for ( let j = 2 * i ; j < N ; j += i ) { dp [ i ] = Math . max ( dp [ i ] , 1 + dp [ j ] ) ; ans = Math . max ( ans , dp [ i ] ) ; } } } return ans ; }
function findMaxCount ( root ) { res = - 1000000000 ; countUntil ( root ) ; return res ; }
function findLargestString ( s , i , r ) { if ( i == s . length ) { if ( r == 0 ) return 0 ; else return - 1000000000 ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = Math . max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i ] [ r ] ; }
function findCnt ( s , i , r ) { if ( i == s . length ) { if ( r == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = findCnt ( s , i + 1 , ( r * 2 + ( s [ i ] - "0" ) ) % 3 ) + findCnt ( s , i + 1 , r ) ; return dp [ i ] [ r ] ; }
function modInv ( a ) { let p = MOD - 2 ; let s = 1 ; while ( p != 1 ) { if ( p % 2 == 1 ) s = ( s * a ) % MOD ; a = ( a * a ) % MOD ; p = parseInt ( p / 2 , 10 ) ; } return ( a * s ) % MOD ; }
function findCnt ( x , y ) { let ans = 0 ; let fact = new Array ( y . length + 1 ) ; fact . fill ( 0 ) ; for ( let i = 0 ; i < y . length + 1 ; i ++ ) fact [ i ] = 1 ; for ( let i = 1 ; i <= y . length ; i ++ ) fact [ i ] = ( fact [ i - 1 ] * i ) % MOD ; for ( let i = 0 ; i < y . length ; i ++ ) { if ( y [ i ] == x ) { ans += ( modInv ( fact [ i ] ) * modInv ( fact [ y . length - i - 1 ] ) ) % MOD ; ans %= MOD ; } } ans *= fact [ ( y . length - 1 ) ] * 0 ; ans = ( ans + 6 ) % MOD ; return ans ; }
function minCount ( arr , n , k ) { var ans = 0 ; var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum -= k ; var l = 0 ; var r = 0 ; var tot = 0 ; while ( l < n ) { if ( tot <= sum ) { ans = Math . max ( ans , r - l ) ; if ( r == n ) break ; tot += arr [ r ++ ] ; } else { tot -= arr [ l ++ ] ; } } return ( n - ans ) ; }
function findSubSeq ( arr , n ) { arr . sort ( ) ; var count = new Array ( n ) ; var prev = new Array ( n ) ; count . fill ( 1 ) ; prev . fill ( - 1 ) ; var max = 0 ; var maxprev = - 1 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] % arr [ j ] == 0 && count [ j ] + 1 > count [ i ] ) { count [ i ] = count [ j ] + 1 ; prev [ i ] = j ; } } if ( max < count [ i ] ) { max = count [ i ] ; maxprev = i ; } } var i = maxprev ; while ( i >= 0 ) { if ( arr [ i ] != - 1 ) document . write ( arr [ i ] + "▁" ) ; i = prev [ i ] ; } }
function solve ( arr , l , r , k ) { if ( r - l + 1 <= k ) return sum ( arr , l , r ) ; if ( dp [ l ] [ r ] [ k ] != 0 ) return dp [ l ] [ r ] [ k ] ; let sum_ = sum ( arr , l , r ) ; let len_r = ( r - l + 1 ) - k ; let len = ( r - l + 1 ) ; let ans = 0 ; for ( let i = 0 ; i < len - len_r + 1 ; i ++ ) { let sum_sub = sum ( arr , i + l , i + l + len_r - 1 ) ; ans = Math . max ( ans , ( sum_ - sum_sub ) + ( sum_sub - solve ( arr , i + l , i + l + len_r - 1 , k ) ) ) ; } dp [ l ] [ r ] [ k ] = ans ; return ans ; }
function minDifference ( x , y , k , b , c ) { if ( x >= n y >= m ) return INT_MAX ; if ( x == n - 1 && y == m - 1 ) { let diff = b [ x ] [ y ] - c [ x ] [ y ] ; return Math . min ( Math . abs ( k - diff ) , Math . abs ( k + diff ) ) ; } let ans = dp [ x ] [ y ] [ k ] ; if ( ans != - 1 ) return ans ; ans = INT_MAX ; let diff = b [ x ] [ y ] - c [ x ] [ y ] ; ans = Math . min ( ans , minDifference ( x + 1 , y , Math . abs ( k + diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x , y + 1 , Math . abs ( k + diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x + 1 , y , Math . abs ( k - diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x , y + 1 , Math . abs ( k - diff ) , b , c ) ) ; return ans ; }
function countSubSeq ( str , len ) { var ans = 0 ; var mul = 1 ; for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] == "0" ) ans += mul ; mul *= 2 ; } return ans ; }
function solveDp ( r , i , w , val , n ) { if ( r <= 0 ) return 0 ; if ( i == n ) return W_MAX ; if ( v [ r ] [ i ] ) return dp [ r ] [ i ] ; v [ r ] [ i ] = 1 ; dp [ r ] [ i ] = Math . min ( solveDp ( r , i + 1 , w , val , n ) , w [ i ] + solveDp ( r - val [ i ] , i + 1 , w , val , n ) ) ; return dp [ r ] [ i ] ; }
function maxWeight ( w , val , n , c ) { for ( var i = V_SUM_MAX ; i >= 0 ; i -- ) { if ( solveDp ( i , 0 , w , val , n ) <= c ) { return i ; } } return 0 ; }
function dfs ( node ) { vis [ node ] = 1 ; subtree_size [ node ] = 1 ; for ( let child = 0 ; child < tree [ node ] . length ; child ++ ) { if ( vis [ tree [ node ] [ child ] ] == 0 ) { subtree_size [ node ] += dfs ( tree [ node ] [ child ] ) ; } } return subtree_size [ node ] ; }
function contribution ( node , ans ) { vis [ node ] = 1 ; for ( let child = 0 ; child < tree [ node ] . length ; child ++ ) { if ( vis [ tree [ node ] [ child ] ] == 0 ) { ans += ( subtree_size [ tree [ node ] [ child ] ] * ( n - subtree_size [ tree [ node ] [ child ] ] ) ) ; ans = contribution ( tree [ node ] [ child ] , ans ) ; } } return ans ; }
function getSum ( ) { for ( let i = 0 ; i < vis . length ; i ++ ) { vis [ i ] = 0 ; } dfs ( 0 ) ; let ans = 0 ; for ( let i = 0 ; i < vis . length ; i ++ ) { vis [ i ] = 0 ; } ans = contribution ( 0 , ans ) ; return ans ; }
function longest_subseq ( n , k , s ) { let dp = new Array ( n ) ; let max_length = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { max_length [ i ] = 0 ; dp [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { let curr = s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ; let lower = Math . max ( 0 , curr - k ) ; let upper = Math . min ( 25 , curr + k ) ; for ( let j = lower ; j < upper + 1 ; j ++ ) { dp [ i ] = Math . max ( dp [ i ] , max_length [ j ] + 1 ) ; } max_length [ curr ] = Math . max ( dp [ i ] , max_length [ curr ] ) ; } let ans = 0 ; ans = Math . max ( ... dp )  return ans ; }
function countNum ( idx , sum , tight , num , len , k ) { if ( len == idx ) { if ( sum == 0 ) return 1 ; else return 0 ; } if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) return dp [ idx ] [ sum ] [ tight ] ; var res = 0 , limit ; if ( tight == 0 ) { limit = num [ idx ] ; } else { limit = 9 ; } for ( var i = 0 ; i <= limit ; i ++ ) { var new_tight = tight ; if ( tight == 0 && i < limit ) new_tight = 1 ; res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len , k ) ; res %= MOD ; } if ( res < 0 ) res += MOD ; return dp [ idx ] [ sum ] [ tight ] = res ; }
function process ( s ) { var num = [ ] ; for ( var i = 0 ; i < s . length ; i ++ ) { num . push ( s [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) ; } return num ; }
function maxLengthOf1s ( arr , n ) { let prefix = new Array ( n ) ; prefix . fill ( 0 ) ; for ( let i = 2 ; i < n ; i ++ ) { if ( arr [ i - 2 ] == 1 ) prefix [ i ] = prefix [ i - 1 ] + 1 ; else prefix [ i ] = 0 ; } let suffix = new Array ( n ) ; suffix . fill ( 0 ) ; for ( let i = n - 3 ; i >= 0 ; i -- ) { if ( arr [ i + 2 ] == 1 ) suffix [ i ] = suffix [ i + 1 ] + 1 ; else suffix [ i ] = 0 ; } let ans = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { ans = Math . max ( ans , prefix [ i + 1 ] + suffix [ i ] ) ; } document . write ( ans ) ; }
function MaxGCD ( a , n ) { var Prefix = Array ( n + 2 ) . fill ( 0 ) ; var Suffix = Array ( n + 2 ) . fill ( 0 ) ; var i ; Prefix [ 1 ] = a [ 0 ] ; for ( i = 2 ; i <= n ; i ++ ) { Prefix [ i ] = gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( i = n - 1 ; i >= 1 ; i -- ) { Suffix [ i ] = gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } var ans = Math . max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( i = 2 ; i < n ; i ++ ) { ans = Math . max ( ans , gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; }
function max_sum ( a , n ) { var dp = Array ( n + 1 ) . fill ( ) . map ( ( ) => Array ( 2 ) . fill ( 0 ) ) ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = - 999999 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) ; } return dp [ n ] [ 0 ] ; }
function sumOfProduct ( arr , n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < dp [ i ] . length ; j ++ ) { dp [ i ] [ j ] = 0 ; } } let cur_sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = arr [ i - 1 ] ; cur_sum += arr [ i - 1 ] ; } for ( let i = 2 ; i <= k ; i ++ ) { let temp_sum = 0 ; for ( let j = 1 ; j <= n ; j ++ ) { cur_sum -= dp [ i - 1 ] [ j ] ; dp [ i ] [ j ] = arr [ j - 1 ] * cur_sum ; temp_sum += dp [ i ] [ j ] ; } cur_sum = temp_sum ; } return cur_sum ; }
function number_of_ways ( arr , n , k ) { if ( k == 1 ) return 1 ; let dp = new Array ( k + 1 ) ; let i ; for ( i = 0 ; i < k + 1 ; i ++ ) dp [ i ] = - 1 ; for ( i = 0 ; i < n ; i ++ ) dp [ arr [ i ] ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = ( dp [ 1 ] == - 1 ) ? 1 : dp [ 1 ] ; for ( i = 2 ; i <= k ; ++ i ) { if ( dp [ i ] == 0 ) continue ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; dp [ i ] %= MOD ; } return dp [ k ] ; }
function MinCost ( arr , n ) { let dp = new Array ( n + 5 ) ; let sum = new Array ( n + 5 ) ; for ( let i = 0 ; i < n + 5 ; i ++ ) { dp [ i ] = [ ] ; sum [ i ] = [ ] ; for ( let j = 0 ; j < n + 5 ; j ++ ) { dp [ i ] . push ( 0 ) sum [ i ] . push ( 0 ) } } console . log ( dp )  for ( let i = 0 ; i < n ; i ++ ) { let k = arr [ i ] ; for ( let j = i ; j < n ; j ++ ) { if ( i == j ) sum [ i ] [ j ] = k ; else { k += arr [ j ] ; sum [ i ] [ j ] = k ; } } } for ( let i = n - 1 ; i >= 0 ; i -- ) { for ( let j = i ; j < n ; j ++ ) { dp [ i ] [ j ] = Number . MAX_SAFE_INTEGER ; if ( i == j ) dp [ i ] [ j ] = 0 ; else { for ( let k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum [ i ] [ j ] ) ; } } } } return dp [ 0 ] [ n - 1 ] ; }
function findCount ( N ) { let list = [ ] ; let sum = 0 ; let i ; for ( i = 0 ; i < 20 ; i ++ ) { sum += parseInt ( Math . pow ( 2 , i ) , 10 ) ; list . push ( sum ) ; } for ( i = 0 ; i < 20 ; i ++ ) { if ( list [ i ] >= N ) return ( i + 1 ) ; } return 0 ; }
function findMax ( arr , n ) { var res = 0 ; var i , j ; for ( i = 0 ; i < n ; i ++ ) { var count = 0 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) count += 1 ; } res = Math . max ( count , res ) ; } return res ; }
function findMax ( arr , n ) { var divisible = Array ( n ) . fill ( false ) ; var res = 0 ; for ( var i = n - 1 ; i > 0 ; i -- ) { if ( divisible [ i ] ) continue ; var cnt = 0 ; for ( var j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] % arr [ i ] ) == 0 ) { divisible [ j ] = true ; cnt ++ ; } } res = Math . max ( res , cnt ) ; } return res ; }
function findSetBits ( n ) { for ( let i = 0 ; i <= n ; i ++ ) document . write ( count ( i ) + "▁" ) ; }
function findSetBits ( n ) { let dp = new Array ( n + 1 ) ; dp . fill ( 0 ) ; document . write ( dp [ 0 ] + "▁" ) ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { dp [ i ] = dp [ parseInt ( i / 2 , 10 ) ] ; } else { dp [ i ] = dp [ parseInt ( i / 2 , 10 ) ] + 1 ; } document . write ( dp [ i ] + "▁" ) ; } }
function findLen ( arr , i , curr , n , m ) { if ( i == n ) { if ( ! curr ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; var l = findLen ( arr , i + 1 , curr , n , m ) ; var r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
function findCnt ( arr , i , required_sum , n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = 1 ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; }
function findCnt ( arr , i , curr , n , m ) { if ( i == n ) { return ( curr == m ) ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr arr [ i ] ) , n , m ) ; return dp [ i ] [ curr ] ; }
function findCnt ( arr , i , curr , n , m ) { if ( i == n ) { return ( curr == m ) ; } if ( v1 [ i ] [ curr ] ) return dp1 [ i ] [ curr ] ; v1 [ i ] [ curr ] = 1 ; dp1 [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; return dp1 [ i ] [ curr ] ; }
function modulo_13 ( s , n ) { var dp = Array ( n + 1 ) . fill ( ) . map ( ( ) => Array ( 13 ) . fill ( 0 ) ) ; dp [ 0 ] [ 0 ] = 1 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < 10 ; j ++ ) { var nxt = s . charAt ( i ) - "0" ; if ( s . charAt ( i ) == "?" ) nxt = j ; for ( k = 0 ; k < 13 ; k ++ ) { var rem = ( 10 * k + nxt ) % 13 ; dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] ; dp [ i + 1 ] [ rem ] %= MOD ; } if ( s . charAt ( i ) != "?" ) break ; } } return parseInt ( dp [ n ] [ 5 ] ) ; }
function f ( i , state , A , dp , N ) { if ( i >= N ) return 0 ; else if ( dp [ i ] [ state ] != - 1 ) { return dp [ i ] [ state ] ; } else { if ( i == N - 1 ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] > A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 2 && A [ i ] < A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] <= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 2 , A , dp , N ) ; else if ( state == 2 && A [ i ] >= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 1 , A , dp , N ) ; return dp [ i ] [ state ] ; } }
function maxLenSeq ( A , N ) { let i , j , tmp , y , ans ; let dp = new Array ( 1000 ) ; for ( i = 0 ; i < 1000 ; i ++ ) { dp [ i ] = new Array ( 3 ) ; for ( j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } for ( i = 0 ; i < N ; i ++ ) { tmp = f ( i , 1 , A , dp , N ) ; tmp = f ( i , 2 , A , dp , N ) ; } ans = - 1 ; for ( i = 0 ; i < N ; i ++ ) { y = dp [ i ] [ 1 ] ; if ( i + y >= N ) ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 ) ; else if ( y % 2 == 0 ) { ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 2 ] ) ; } else if ( y % 2 == 1 ) { ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 1 ] ) ; } } return ans ; }
function countWays ( n ) { let a = [ ] ; let i = 1 ; while ( i <= n ) a . push ( i ++ ) ; let ways = 0 ; do { let flag = ( a [ 0 ] == 1 ) ; for ( let j = 1 ; j < n ; j ++ ) { if ( Math . abs ( a [ j ] - a [ j - 1 ] ) > 2 ) flag = false ; } if ( flag ) ways ++ ; } while ( next_permutation ( a ) ) ; return ways ; }
function LISusingLCS ( seq ) { let n = seq . length ; let L = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < ( n + 1 ) ; j ++ ) { L [ i ] [ j ] = 0 ; } } let sortedseq = [ ... seq ] ; sortedseq . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ n ] [ n ] ; }
function count_numbers ( k , n , flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , 0 ) + count_numbers ( k , n - 1 , 1 ) ) ; else return count_numbers ( k , n - 1 , 1 ) ; }
function count_numbers ( k , n ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) dp [ i ] = new Array ( 2 ) ; dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = k - 1 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; }
function divideArray ( arr , n , k ) { var dp = Array . from ( Array ( 500 ) , ( ) => Array ( 500 ) . fill ( 0 ) ) ; k -= 1 ; for ( var i = n - 1 ; i >= 0 ; i -- ) { for ( var j = 0 ; j <= k ; j ++ ) { dp [ i ] [ j ] = 1000000000 ; var max_ = - 1 , sum = 0 ; for ( var l = i ; l < n ; l ++ ) { max_ = Math . max ( max_ , arr [ l ] ) ; sum += arr [ l ] ; var diff = ( l - i + 1 ) * max_ - sum ; if ( j > 0 ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , diff + dp [ l + 1 ] [ j - 1 ] ) ; else dp [ i ] [ j ] = diff ; } } } return dp [ 0 ] [ k ] ; }
function cntSubsets ( arr , n ) { var max = Math . pow ( 2 , n ) ; var result = 0 ; for ( var i = 0 ; i < max ; i ++ ) { var counter = i ; if ( counter & ( counter >> 1 ) ) continue ; result ++ ; } return result ; }
function cntSubsets ( arr , n ) { var a = Array ( n ) ; var b = Array ( n ) ; a [ 0 ] = b [ 0 ] = 1 ; for ( var i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } var result = a [ n - 1 ] + b [ n - 1 ] ; return result ; }
function perfix_calculate ( A , row , col ) { let n = A . length ; let m = A [ 0 ] . length ; for ( let i = 0 ; i < n ; ++ i ) { row [ i ] [ 0 ] = A [ i ] [ 0 ] ; } for ( let i = 0 ; i < n ; ++ i ) { for ( let j = 1 ; j < m ; ++ j ) { row [ i ] [ j ] = row [ i ] [ j - 1 ] + A [ i ] [ j ] ; } } for ( let i = 0 ; i < m ; ++ i ) { col [ 0 ] [ i ] = A [ 0 ] [ i ] ; } for ( let i = 0 ; i < m ; ++ i ) { for ( let j = 1 ; j < n ; ++ j ) { col [ j ] [ i ] = A [ j ] [ i ] + col [ j - 1 ] [ i ] ; } } }
function perimeter ( i , j , k , row , col , A ) { let row_s , col_s ; if ( j == 0 ) row_s = 0 ; else row_s = row [ i ] [ j - 1 ] ; if ( i == 0 ) col_s = 0 ; else col_s = col [ i - 1 ] [ j ] ; let upper_row = row [ i ] [ j + k ] - row_s ; let left_col = col [ i + k ] [ j ] - col_s ; if ( j == 0 ) row_s = 0 ; else row_s = row [ i + k ] [ j - 1 ] ; if ( i == 0 ) col_s = 0 ; else col_s = col [ i - 1 ] [ j + k ] ; let lower_row = row [ i + k ] [ j + k ] - row_s ; let right_col = col [ i + k ] [ j + k ] - col_s ; let sum = upper_row + lower_row + left_col + right_col ; sum -= ( A [ i ] [ j ] + A [ i + k ] [ j ] + A [ i ] [ j + k ] + A [ i + k ] [ j + k ] ) ; return sum ; }
function maxPerimeter ( A ) { let n = A . length ; let m = A [ 0 ] . length ; let row = new Array ( n ) ; let col = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { row [ i ] = new Array ( m ) ; col [ i ] = new Array ( m ) ; } perfix_calculate ( A , row , col ) ; let maxPer = 0 ; for ( let i = 0 ; i < n ; ++ i ) { for ( let j = 0 ; j < m ; ++ j ) { for ( let k = 0 ; k < Math . min ( n - i , m - j ) ; ++ k ) { let perimtr = perimeter ( i , j , k , row , col , A ) ; maxPer = Math . max ( maxPer , perimtr ) ; } } } return maxPer ; }
function mazeProb ( maze , xpos , ypos ) { let key = true ; if ( findPath ( maze , xpos , ypos , key ) ) return true ; return false ; }
function ways ( i , arr , n ) { if ( i == n - 1 ) return 1 ; let sum = 0 ; for ( let j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; }
function minJumps ( arr , N ) { let fib = new Array ( 30 ) ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( let i = 2 ; i < 30 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; let DP = new Array ( N + 2 ) ; DP [ 0 ] = 0 ; for ( let i = 1 ; i <= N + 1 ; i ++ ) DP [ i ] = MAX ; for ( let i = 1 ; i <= N + 1 ; i ++ ) { for ( let j = 1 ; j < 30 ; j ++ ) { if ( ( arr [ i - 1 ] == 1 i == N + 1 ) && i - fib [ j ] >= 0 ) DP [ i ] = Math . min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) ; } } if ( DP [ N + 1 ] != MAX ) return DP [ N + 1 ] ; else return - 1 ; }
function CountOfOddSum ( a , n ) { let dp = new Array ( n ) , cnt = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( 2 ) . fill ( 0 ) ; cnt [ i ] = new Array ( 2 ) . fill ( 0 ) ; } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < 2 ; j ++ ) { if ( a [ i ] [ j ] % 2 == 0 ) { cnt [ i ] [ 0 ] ++ ; } else { cnt [ i ] [ 1 ] ++ ; } } } dp [ 0 ] [ 0 ] = cnt [ 0 ] [ 0 ] , dp [ 0 ] [ 1 ] = cnt [ 0 ] [ 1 ] ; for ( let i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] * cnt [ i ] [ 0 ] + dp [ i - 1 ] [ 1 ] * cnt [ i ] [ 1 ] ) ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] * cnt [ i ] [ 1 ] + dp [ i - 1 ] [ 1 ] * cnt [ i ] [ 0 ] ) ; } return dp [ n - 1 ] [ 1 ] ; }
function recur ( ind , cnt , last , a , n , k , dp ) { if ( cnt == k ) return 0 ; if ( ind == n ) return - 1e9 ; if ( dp [ ind ] [ cnt ] != - 1 ) return dp [ ind ] [ cnt ] ; let ans = 0 ; for ( let i = ind ; i < n ; i ++ ) { if ( cnt % 2 == 0 ) ans = Math . max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) ; else ans = Math . max ( ans , __gcd ( a [ last ] , a [ i ] ) + recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) ; } return dp [ ind ] [ cnt ] = ans ; }
function Max_Sum ( arr1 , arr2 , n ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { dp [ i ] [ 0 ] = arr1 [ i ] ; dp [ i ] [ 1 ] = arr2 [ i ] ; continue ; } dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) ; } return Math . max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
function maximizeSum ( a , n , ind , k , dp ) { if ( k == 0 ) { if ( ind == n ) return 0 ; else return - 1000000000 ; } else if ( ind == n ) return - 1000000000 ; else if ( dp [ ind ] [ k ] != - 1 ) return dp [ ind ] [ k ] ; else { var ans = 0 ; var mini = a [ ind ] ; for ( i = ind ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; ans = Math . max ( ans , maximizeSum ( a , n , i + 1 , k - 1 , dp ) + mini ) ; } return dp [ ind ] [ k ] = ans ; } }
function Partition ( arr , n , k ) { let prefix = new Array ( n + 1 ) ; prefix . fill ( 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; } let LOGS = 20 ; let ans = 0 ; for ( let i = LOGS ; i >= 0 ; -- i ) { if ( checkpossible ( ans | ( 1 << i ) , arr , prefix , n , k ) ) { ans = ans | ( 1 << i ) ; } } return ans ; }
function SieveOfEratosthenes ( MAX , primes ) { let prime = new Array ( MAX + 1 ) . fill ( true ) ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( let i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] ) primes . push ( i ) ; } }
function findLongest ( A , n ) { let mpp = new Map ( ) ; let primes = new Array ( ) ; SieveOfEratosthenes ( A [ n - 1 ] , primes ) ; let dp = new Array ( n ) ; dp . fill ( 0 ) dp [ n - 1 ] = 1 ; mpp . set ( A [ n - 1 ] , n - 1 ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let num = A [ i ] ; dp [ i ] = 1 ; let maxi = 0 ; for ( let it of primes ) { let xx = num * it ; if ( xx > A [ n - 1 ] ) break ; else if ( mpp . get ( xx ) ) { dp [ i ] = Math . max ( dp [ i ] , 1 + dp [ mpp . get ( xx ) ] ) ; } } mpp . set ( A [ i ] , i ) ; } let ans = 1 ; for ( let i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , dp [ i ] ) ; } return ans ; }
function initialize ( ) { for ( let i = 0 ; i <= N ; i += 1 ) { dp [ i ] = new Array ( RODS + 1 ) ; for ( let j = 1 ; j <= RODS ; j ++ ) { dp [ i ] [ j ] = new Array ( RODS + 1 ) ; for ( let k = 1 ; k <= RODS ; k += 1 ) { dp [ i ] [ j ] [ k ] = Number . MAX_VALUE ; } } } }
function mincost ( idx , src , dest , costs ) { if ( idx > N ) return 0 ; if ( dp [ idx ] [ src ] [ dest ] != Number . MAX_VALUE ) return dp [ idx ] [ src ] [ dest ] ; let rem = 6 - ( src + dest ) ; let ans = Number . MAX_VALUE ; let case1 = costs [ src - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , rem , costs ) + mincost ( idx + 1 , rem , dest , costs ) ; let case2 = costs [ src - 1 ] [ rem - 1 ] + mincost ( idx + 1 , src , dest , costs ) + mincost ( idx + 1 , dest , src , costs ) + costs [ rem - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , dest , costs ) ; ans = Math . min ( case1 , case2 ) ; dp [ idx ] [ src ] [ dest ] = ans ; return ans ; }
function MaxGCD ( a , n ) { let Prefix = new Array ( n + 2 ) ; let Suffix = new Array ( n + 2 ) ; Prefix [ 1 ] = a [ 0 ] ; for ( let i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( let i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } let ans = Math . max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( let i = 2 ; i < n ; i += 1 ) { ans = Math . max ( ans , gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; }
function numToVec ( N ) { let digit = [ ] ; while ( N != 0 ) { digit . push ( N % 10 ) ; N = Math . floor ( N / 10 ) ; } if ( digit . length == 0 ) digit . push ( 0 ) ; digit . reverse ( ) ; return digit ; }
function solve ( A , B , C ) { let digit = [ ] ; let d , d2 ; digit = numToVec ( C ) ; d = A . length ; if ( B > digit . length d == 0 ) return 0 ; else if ( B < digit . length ) { if ( A [ 0 ] == 0 && B != 1 ) return Math . floor ( ( d - 1 ) * Math . pow ( d , B - 1 ) ) ; else return Math . floor ( Math . pow ( d , B ) ) ; } else { let dp = new Array ( B + 1 ) ; let lower = new Array ( MAX + 1 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = 0 ; } for ( let i = 0 ; i < lower . length ; i ++ ) { lower [ i ] = 0 ; } for ( let i = 0 ; i < d ; i ++ ) lower [ A [ i ] + 1 ] = 1 ; for ( let i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; let flag = true ; dp [ 0 ] = 0 ; for ( let i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit [ i - 1 ] ] ; dp [ i ] = dp [ i - 1 ] * d ; if ( i == 1 && A [ 0 ] == 0 && B != 1 ) d2 = d2 - 1 ; if ( flag ) dp [ i ] += d2 ; flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) ; } return dp [ B ] ; } }
function LongestConsSeq ( arr , N ) { let maxval = 1 ; for ( let i = 0 ; i < N ; i += 1 ) { maxval = Math . max ( maxval , arr [ i ] ) ; } let dp = new Array ( maxval + 1 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) dp [ i ] [ j ] = 0 ; } let ans = 1 ; for ( let i = 0 ; i < N ; i += 1 ) { dp [ arr [ i ] ] [ 0 ] = ( 1 + dp [ arr [ i ] - 1 ] [ 0 ] ) ; if ( arr [ i ] >= 2 ) dp [ arr [ i ] ] [ 1 ] = Math . max ( 1 + dp [ arr [ i ] - 1 ] [ 1 ] , 2 + dp [ arr [ i ] - 2 ] [ 0 ] ) ; else dp [ arr [ i ] ] [ 1 ] = 1 ; ans = Math . max ( ans , dp [ arr [ i ] ] [ 1 ] ) ; } return ans ; }
function min ( p , q , r , s ) { let temp1 = p < q ? p : q ; let temp2 = r < s ? r : s ; if ( temp1 < temp2 ) return temp1 ; return temp2 ; }
function Distance ( arr , i , j ) { if ( i >= R j >= C i < 0 j < 0 ) return INT_MAX ; else if ( arr [ i ] [ j ] == 0 ) { table [ i ] [ j ] = INT_MAX ; return INT_MAX ; } else if ( arr [ i ] [ j ] == 2 ) { table [ i ] [ j ] = 0 ; return 0 ; } else if ( visited [ i ] [ j ] == 1 ) { return INT_MAX ; } else { visited [ i ] [ j ] = 1 ; let temp1 = Distance ( arr , i + 1 , j ) ; let temp2 = Distance ( arr , i - 1 , j ) ; let temp3 = Distance ( arr , i , j + 1 ) ; let temp4 = Distance ( arr , i , j - 1 ) ; let min_value = 1 + min ( temp1 , temp2 , temp3 , temp4 ) ; if ( table [ i ] [ j ] > 0 && table [ i ] [ j ] < INT_MAX ) { if ( min_value < table [ i ] [ j ] ) table [ i ] [ j ] = min_value ; } else table [ i ] [ j ] = min_value ; visited [ i ] [ j ] = 0 ; } return table [ i ] [ j ] ; }
function minTime ( arr ) { let max = 0 ; for ( let i = 0 ; i < R ; i ++ ) { for ( let j = 0 ; j < C ; j ++ ) { if ( arr [ i ] [ j ] == 1 ) Distance ( arr , i , j ) ; } } for ( let i = 0 ; i < R ; i ++ ) { for ( let j = 0 ; j < C ; j ++ ) { if ( arr [ i ] [ j ] == 1 && table [ i ] [ j ] > max ) max = table [ i ] [ j ] ; } } if ( max < INT_MAX ) return max ; return - 1 ; }
function findDepthRec ( tree , n , index ) { if ( index >= n tree [ index ] == "l" ) return 0 ; index ++ ; let left = findDepthRec ( tree , n , index ) ; index ++ ; let right = findDepthRec ( tree , n , index ) ; return Math . max ( left , right ) + 1 ; }
function findDepth ( tree , n ) { let index = 0 ; return ( findDepthRec ( tree , n , index ) ) ; }
function solve ( str , K ) { let N = str . length ; dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( K ) ; for ( let j = 0 ; j < K ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } let ans = solveUtil ( 0 , 0 , str , K ) ; return ans == Number . MAX_VALUE ? - 1 : ans ; }
function solve ( str , K ) { let n = str . length ; let dp = new Array ( K ) ; for ( let i = 0 ; i < K ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } if ( n < K ) return - 1 ; else if ( n == K ) return 0 ; let zeroes = 0 , ones = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == "0" ) zeroes ++ ; else ones ++ ; dp [ 0 ] [ i ] = ones * zeroes ; } for ( let s = 1 ; s < K ; s ++ ) { for ( let i = 0 ; i < n ; i ++ ) { dp [ s ] [ i ] = Number . MAX_VALUE ; ones = 0 ; zeroes = 0 ; for ( let k = i ; k >= 0 ; k -- ) { if ( str [ k ] == "0" ) zeroes ++ ; else ones ++ ; dp [ s ] [ i ] = Math . min ( dp [ s ] [ i ] , + ( ( k - 1 >= 0 ) ? ones * zeroes + dp [ s - 1 ] [ k - 1 ] : Number . MAX_VALUE ) ) ; } } } return ( dp [ K - 1 ] [ n - 1 ] == Number . MAX_VALUE ) ? - 1 : dp [ K - 1 ] [ n - 1 ] ; }
function max_sum ( a , n ) { let dp = new Array ( n ) ; if ( n == 1 ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; } else if ( n == 2 ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; dp [ 1 ] = Math . max ( a [ 1 ] , dp [ 0 ] ) ; } else if ( n >= 3 ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; dp [ 1 ] = Math . max ( a [ 1 ] , Math . max ( 0 , a [ 0 ] ) ) ; dp [ 2 ] = Math . max ( a [ 2 ] , Math . max ( a [ 1 ] , Math . max ( 0 , a [ 0 ] ) ) ) ; let i = 3 ; while ( i < n ) { dp [ i ] = Math . max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) ; i ++ ; } } return dp [ n - 1 ] ; }
function minCount ( K ) { let memo = new Array ( 100 ) ; for ( let i = 0 ; i < 100 ; i ++ ) { memo [ i ] = Number . MAX_VALUE ; } memo [ 0 ] = 0 ; for ( let i = 1 ; i < 100 ; i ++ ) { memo [ i ] = Math . min ( memo [ i - 1 ] + 1 , memo [ i ] ) ; } for ( let i = 10 ; i < 100 ; i ++ ) { memo [ i ] = Math . min ( memo [ i - 10 ] + 1 , memo [ i ] ) ; } for ( let i = 25 ; i < 100 ; i ++ ) { memo [ i ] = Math . min ( memo [ i - 25 ] + 1 , memo [ i ] ) ; } let min_count = 0 ; while ( K > 0 ) { min_count += memo [ K % 100 ] ; K = parseInt ( K / 100 , 10 ) ; } return min_count ; }
function NoofWays ( face , throws , sum ) { if ( sum == 0 && throws == 0 ) return 1 ; if ( sum < 0 throws == 0 ) return 0 ; if ( dp [ throws ] [ sum ] != - 1 ) return dp [ throws ] [ sum ] ; let ans = 0 ; for ( let i = 1 ; i <= face ; i ++ ) { ans += NoofWays ( face , throws - 1 , sum - i ) ; } return dp [ throws ] [ sum ] = ans ; }
function solve ( s ) { n = s . length ; let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = 0 ; } for ( let len = n - 1 ; len >= 0 ; -- len ) { for ( let i = 0 ; i + len < n ; ++ i ) { let j = i + len ; if ( i == 0 && j == n - 1 ) { if ( s [ i ] == s [ j ] ) dp [ i ] [ j ] = 2 ; else if ( s [ i ] != s [ j ] ) dp [ i ] [ j ] = 1 ; } else { if ( s [ i ] == s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 < 0 j + 1 >= n ) { dp [ i ] [ j ] += 1 ; } } else if ( s [ i ] != s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 >= 0 && j + 1 <= n - 1 ) { dp [ i ] [ j ] -= dp [ i - 1 ] [ j + 1 ] ; } } } } } let ways = [ ] ; for ( let i = 0 ; i < n ; ++ i ) { if ( i == 0 i == n - 1 ) { ways . push ( 1 ) ; } else { let total = dp [ i - 1 ] [ i + 1 ] ; ways . push ( total ) ; } } for ( let i = 0 ; i < ways . length ; ++ i ) { document . write ( ways [ i ] + "▁" ) ; } }
function maxSum ( arr , i , n , k ) { if ( i >= n ) return 0 ; if ( visit [ i ] ) return dp [ i ] ; visit [ i ] = true ; let tot = 0 ; dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; for ( let j = i ; j < ( i + k ) && ( j < n ) ; j ++ ) { tot += arr [ j ] ; dp [ i ] = Math . max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; } return dp [ i ] ; }
function get_binary ( u ) { let ans = 0 ; while ( u > 0 ) { let rem = u % 10 ; ans |= ( 1 << rem ) ; u = parseInt ( u / 10 , 10 ) ; } return ans ; }
function waysutil ( index , sum , count , arr , K ) { if ( index < 0 ) { return 0 ; } if ( index == 0 ) { if ( count == 0 ) { return 0 ; } var remainder = sum % count ; if ( remainder != 0 ) { return 0 ; } var average = sum / count ; if ( average == K ) { return 1 ; } } if ( dp [ index ] [ sum ] [ count ] != - 1 ) { return dp [ index ] [ sum ] [ count ] ; } var dontpick = waysutil ( index - 1 , sum , count , arr , K ) ; var pick = waysutil ( index - 1 , sum + arr [ index ] , count + 1 , arr , K ) ; var total = pick + dontpick ; dp [ index ] [ sum ] [ count ] = total ; return total ; }
function ways ( N , K , arr ) { var Arr = [ ] ; Arr . push ( - 1 ) ; for ( i = 0 ; i < N ; ++ i ) { Arr . push ( arr [ i ] ) ; } for ( i = 0 ; i < MAX_INDEX ; i ++ ) { for ( j = 0 ; j < MAX_SUM ; j ++ ) { for ( l = 0 ; l < MAX_INDEX ; l ++ ) { dp [ i ] [ j ] [ l ] = - 1 ; } } } var answer = waysutil ( N , 0 , 0 , Arr , K ) ; return answer ; }
function RetClose ( a , b , s ) { if ( Math . abs ( a - s ) < Math . abs ( b - s ) ) return a ; else return b ; }
function FindClose ( arr , n ) { let ans = inf ; for ( let i = 1 ; i <= n ; i ++ ) ans = RetClose ( arr [ i - 1 ] + MinDiff ( i , arr [ i - 1 ] , arr , n ) , ans , 0 ) ; document . write ( ans ) ; }
function FindMax ( i , r , w , n , c , k ) { if ( i >= n ) { return 0 ; } if ( v [ i ] [ r ] ) { return dp [ i ] [ r ] ; } v [ i ] [ r ] = true ; dp [ i ] [ r ] = FindMax ( i + 1 , r , w , n , c , k ) ; for ( let j = 0 ; j < k ; j ++ ) { let x = ( r / exp_c [ j ] ) % ( c + 1 ) ; if ( x - w [ i ] >= 0 ) { dp [ i ] [ r ] = Math . max ( dp [ i ] [ r ] , w [ i ] + FindMax ( i + 1 , r - w [ i ] * exp_c [ j ] , w , n , c , k ) ) ; } } return dp [ i ] [ r ] ; }
function PreCompute ( n , c , k ) { for ( let i = 0 ; i < k ; i ++ ) { exp_c . push ( 0 ) ; } exp_c [ 0 ] = 1 ; for ( let i = 1 ; i < k ; i ++ ) { exp_c [ i ] = ( exp_c [ i - 1 ] * ( c + 1 ) ) ; } for ( let i = 0 ; i < n ; i ++ ) { dp . push ( [ ] ) ; } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < ( exp_c [ k - 1 ] * ( c + 1 ) ) ; j ++ ) { dp [ i ] [ 0 ] ; } } for ( let i = 0 ; i < n ; i ++ ) { v . push ( [ ( exp_c [ k - 1 ] * ( c + 1 ) ) ] ) ; } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < v [ i ] . length ; j ++ ) { v [ i ] [ j ] = false ; } } let R = 0 ; for ( let i = 0 ; i < k ; i ++ ) { R += exp_c [ i ] * c ; } return R ; }
function findMax ( i , r , w , n ) { if ( r < 0 ) return - 1000000000 ; if ( i == n ) return 0 ; if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = Math . max ( w [ i ] + findMax ( i + 1 , r - w [ i ] , w , n ) , findMax ( i + 1 , r , w , n ) ) ; return dp [ i ] [ r ] ; }
function preCompute ( w , n ) { for ( var i = C_MAX ; i >= 0 ; i -- ) findMax ( 0 , i , w , n ) ; }
function ansQuery ( w ) { return dp [ 0 ] [ w ] ; }
function minSum ( A , B , C , i , n , curr , dp ) { if ( n <= 0 ) return 0 ; if ( dp [ n ] [ curr ] != - 1 ) return dp [ n ] [ curr ] ; if ( curr == 0 ) { return dp [ n ] [ curr ] = Math . min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; } if ( curr == 1 ) return dp [ n ] [ curr ] = Math . min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; return dp [ n ] [ curr ] = Math . min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) ; }
function findPrefixSum ( arr , n ) { prefix_sum [ 0 ] = arr [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = arr [ i ] + prefix_sum [ i - 1 ] ; }
function maxSum ( arr , i , n , k ) { if ( i + k > n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ; var x ; if ( i == 0 ) x = prefix_sum [ k - 1 ] ; else x = prefix_sum [ i + k - 1 ] - prefix_sum [ i - 1 ] ; dp [ i ] = Math . max ( maxSum ( arr , i + 1 , n , k ) , x + maxSum ( arr , i + k + 1 , n , k ) ) ; return dp [ i ] ; }
function getChicks ( n ) { let size = Math . max ( n , 7 ) ; let dp = new Array ( size ) ; dp . fill ( 0 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i < 6 ; i ++ ) { dp [ i ] = dp [ i - 1 ] * 3 ; } dp [ 6 ] = 726 ; for ( let i = 8 ; i <= n ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] - ( 2 * parseInt ( dp [ i - 6 ] / 3 , 10 ) ) ) * 3 ; } return dp [ n ] ; }
function getChicks ( n ) { let chicks = Math . pow ( 3 , n - 1 ) ; return chicks ; }
function MaximumMarks ( marksarr , timearr , h , n , p ) { let no_of_topics = n + 1 ; let total_time = h + 1 ; let T = new Array ( no_of_topics ) ; for ( let i = 0 ; i < no_of_topics ; i ++ ) { T [ i ] = new Array ( total_time ) ; for ( let j = 0 ; j < total_time ; j ++ ) { T [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < no_of_topics ; i ++ ) { T [ i ] [ 0 ] = 0 ; } for ( let j = 0 ; j < total_time ; j ++ ) { T [ 0 ] [ j ] = 0 ; } for ( let i = 1 ; i < no_of_topics ; i ++ ) { for ( let j = 1 ; j < total_time ; j ++ ) { if ( j < timearr [ i ] ) { T [ i ] [ j ] = T [ i - 1 ] [ j ] ; } else { T [ i ] [ j ] = Math . max ( marksarr [ i ] + T [ i - 1 ] [ j - timearr [ i ] ] , T [ i - 1 ] [ j ] ) ; } } } let i = no_of_topics - 1 , j = total_time - 1 ; let sum = 0 ; while ( i > 0 && j > 0 ) { if ( T [ i ] [ j ] == T [ i - 1 ] [ j ] ) { i -- ; } else { sum += timearr [ i ] ; j -= timearr [ i ] ; i -- ; } } let marks = T [ no_of_topics - 1 ] [ total_time - 1 ] ; if ( marks < p ) return - 1 ; return sum ; }
function findSum ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; }
function cntWays ( arr , i , ck , k , n , curr_sum ) { if ( sum % k != 0 ) return 0 ; if ( i != n && ck == k + 1 ) return 0 ; if ( i == n ) { if ( ck == k + 1 ) return 1 ; else return 0 ; } if ( v [ i ] [ ck ] ) return dp [ i ] [ ck ] ; curr_sum += arr [ i ] ; v [ i ] [ ck ] = 1 ; dp [ i ] [ ck ] = cntWays ( arr , i + 1 , ck , k , n , curr_sum ) ; if ( curr_sum == ( sum / k ) * ck ) dp [ i ] [ ck ] += cntWays ( arr , i + 1 , ck + 1 , k , n , curr_sum ) ; return dp [ i ] [ ck ] ; }
function SubsetCnt ( i , s , arr , n ) { if ( i == n ) { if ( s == 0 ) return 1 ; else return 0 ; } if ( visit [ i ] [ s + maxSum ] ) return dp [ i ] [ s + maxSum ] ; visit [ i ] [ s + maxSum ] = 1 ; dp [ i ] [ s + maxSum ] = SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ; return dp [ i ] [ s + maxSum ] ; }
function sumMax ( i , arr , n ) { if ( i >= n - 1 ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = Math . max ( arr [ i ] + arr [ i + 1 ] + sumMax ( i + 3 , arr , n ) , sumMax ( i + 1 , arr , n ) ) ; return dp [ i ] ; }
function MaxIncreasingSub ( arr , n , k ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } let ans = - 1 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < k + 1 ; j ++ ) dp [ i ] [ j ] = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] [ 1 ] = arr [ i ] ; } for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { for ( let l = 1 ; l <= k - 1 ; l ++ ) { if ( dp [ j ] [ l ] != - 1 ) { dp [ i ] [ l + 1 ] = Math . max ( dp [ i ] [ l + 1 ] , dp [ j ] [ l ] + arr [ i ] ) ; } } } } } for ( let i = 0 ; i < n ; i ++ ) { if ( ans < dp [ i ] [ k ] ) ans = dp [ i ] [ k ] ; } return ( ans == - 1 ) ? 0 : ans ; }
function solve ( remSum , maxVal , idx , count ) { if ( remSum == 0 ) { print ( idx ) ; count ++ ; return ; } for ( var i = maxVal ; i >= 1 ; i -- ) { if ( i > remSum ) { continue ; } else if ( i <= remSum ) { dp [ idx ] = i ; solve ( remSum - i , i , idx + 1 , count ) ; } } }
function findPrefixCount ( arr ) { for ( let i = 0 ; i < bitscount ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] [ 0 ] = ( ( arr [ j ] [ 0 ] >> i ) & 1 ) ; for ( let k = 1 ; k < n ; k ++ ) { prefix_count [ i ] [ j ] [ k ] = ( ( arr [ j ] [ k ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j ] [ k - 1 ] ; } } } for ( let i = 0 ; i < bitscount ; i ++ ) for ( let j = 1 ; j < n ; j ++ ) for ( let k = 0 ; k < n ; k ++ ) prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j - 1 ] [ k ] ; }
function rangeOr ( x1 , y1 , x2 , y2 ) { let ans = 0 ; for ( let i = 0 ; i < bitscount ; i ++ ) { let p ; if ( x1 == 0 && y1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] ; else if ( x1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x2 ] [ y1 - 1 ] ; else if ( y1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x1 - 1 ] [ y2 ] ; else p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x1 - 1 ] [ y2 ] - prefix_count [ i ] [ x2 ] [ y1 - 1 ] + prefix_count [ i ] [ x1 - 1 ] [ y1 - 1 ] ; if ( p != 0 ) ans = ( ans | ( 1 << i ) ) ; } return ans ; }
function findPrefixCount ( arr ) { for ( let i = 0 ; i < bitscount ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] [ 0 ] = ( ( arr [ j ] [ 0 ] >> i ) & 1 ) ; for ( let k = 1 ; k < n ; k ++ ) { prefix_count [ i ] [ j ] [ k ] = ( ( arr [ j ] [ k ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j ] [ k - 1 ] ; } } } for ( let i = 0 ; i < bitscount ; i ++ ) for ( let j = 1 ; j < n ; j ++ ) for ( let k = 0 ; k < n ; k ++ ) prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j - 1 ] [ k ] ; }
function findPrefixCount ( arr , n ) { for ( let i = 0 ; i < bitscount ; i ++ ) { prefix_count [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( let j = 1 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] += prefix_count [ i ] [ j - 1 ] ; } } }
function rangeOr ( l , r ) { let ans = 0 ; for ( let i = 0 ; i < bitscount ; i ++ ) { let x ; if ( l == 0 ) x = prefix_count [ i ] [ r ] ; else x = prefix_count [ i ] [ r ] - prefix_count [ i ] [ l - 1 ] ; if ( x != 0 ) ans = ( ans | ( 1 << i ) ) ; } return ans ; }
function palindromeSubStrs ( s ) { let dp = new Array ( s . length ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < dp . length ; i ++ ) { for ( let j = 0 ; j < dp . length ; j ++ ) { dp [ i ] [ j ] = 0 ; } } let st , end , i , len ; let m = new Map ( ) ; for ( i = 0 ; i < s . length ; i ++ ) { dp [ i ] [ i ] = 1 ; m . set ( s . substr ( i , i + 1 ) , true ) ; } for ( i = 0 ; i < s . length - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { dp [ i ] [ i + 1 ] = 1 ; m . set ( s . substr ( i , i + 2 ) , true ) ; } else dp [ i ] [ i + 1 ] = 0 ; } for ( len = 3 ; len <= s . length ; len ++ ) { for ( st = 0 ; st <= s . length - len ; st ++ ) { end = st + len - 1 ; if ( s [ st ] == s [ end ] && dp [ st + 1 ] [ end - 1 ] == 1 ) { dp [ st ] [ end ] = 1 ; m . set ( s . substr ( st , end + 1 ) , true ) ; } else dp [ st ] [ end ] = 0 ; } } return m . size ; }
function maxSum ( arr , i , n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ; dp [ i ] = Math . max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; }
function countWays ( i , j , x , arr ) { if ( i == n j == n ) return 0 ; x = ( x & arr [ i ] [ j ] ) ; if ( x == 0 ) return 0 ; if ( i == n - 1 && j == n - 1 ) return 1 ; if ( v [ i ] [ j ] [ x ] ) return dp [ i ] [ j ] [ x ] ; v [ i ] [ j ] [ x ] = 1 ; dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; return dp [ i ] [ j ] [ x ] ; }
function minSteps ( i , j , arr ) { if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; } if ( v [ i ] [ j ] == 1 ) { return dp [ i ] [ j ] ; } v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 9999999 ; for ( let k = Math . max ( 0 , arr [ i ] [ j ] + j - n + 1 ) ; k <= Math . min ( n - i - 1 , arr [ i ] [ j ] ) ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; } dp [ i ] [ j ] ++ ; return dp [ i ] [ j ] ; }
function minSteps ( i , j , arr ) { if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; } if ( v [ i ] [ j ] == 1 ) { return dp [ i ] [ j ] ; } v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 1 + Math . min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; return dp [ i ] [ j ] ; }
function oSRec ( arr , i , j , sum ) { if ( j == i + 1 ) return Math . max ( arr [ i ] , arr [ j ] ) ; return Math . max ( ( sum - oSRec ( arr , i + 1 , j , sum - arr [ i ] ) ) , ( sum - oSRec ( arr , i , j - 1 , sum - arr [ j ] ) ) ) ; }
function optimalStrategyOfGame ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } return oSRec ( arr , 0 , n - 1 , sum ) ; }
function oSRec ( arr , i , j , sum ) { if ( j == i + 1 ) return Math . max ( arr [ i ] , arr [ j ] ) ; if ( memo [ i ] [ j ] != - 1 ) return memo [ i ] [ j ] ; memo [ i ] [ j ] = Math . max ( ( sum - oSRec ( arr , i + 1 , j , sum - arr [ i ] ) ) , ( sum - oSRec ( arr , i , j - 1 , sum - arr [ j ] ) ) ) ; return memo [ i ] [ j ] ; }
function optimalStrategyOfGame ( arr , n ) { let sum = 0 ; sum = accumulate ( arr , 0 , n ) ; for ( let j = 0 ; j < MAX ; j ++ ) { for ( let k = 0 ; k < MAX ; k ++ ) memo [ j ] [ k ] = - 1 ; } return oSRec ( arr , 0 , n - 1 , sum ) ; }
function number ( s , i , j ) { var ans = 0 ; for ( var x = i ; x < j ; x ++ ) { ans = ans * 2 + ( s [ x ] - "0" ) ; } return ans ; }
function minCuts ( s , n ) { var dp = Array ( n + 1 ) . fill ( n + 1 ) ; dp [ 0 ] = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { if ( s [ i - 1 ] == "0" ) continue ; for ( var j = 0 ; j < i ; j ++ ) { if ( s [ j ] == "0" ) continue ; var num = number ( s , j , i ) ; if ( ! ispower ( num ) ) continue ; dp [ i ] = Math . min ( dp [ i ] , dp [ j ] + 1 ) ; } } return ( ( dp [ n ] < n + 1 ) ? dp [ n ] : - 1 ) ; }
function sum ( i1 , j1 , i2 , j2 ) { if ( i1 == i2 && j1 == j2 ) { return arr [ i1 ] [ j1 ] ; } return arr [ i1 ] [ j1 ] + arr [ i2 ] [ j2 ] ; }
function MinOfCubed ( k ) { if ( k < 8 ) return k ; let res = k ; for ( let i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
function MinOfCubedDP ( k ) { let DP = new Array ( k + 1 ) ; DP . fill ( 0 ) ; let j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( let i = 1 ; i <= k ; i ++ ) { DP [ i ] = Number . MAX_VALUE ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; }
function getMaximumSum ( a , n , x ) { var dp = Array ( n ) . fill ( ) . map ( ( ) => Array ( 3 ) . fill ( 0 ) ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } var maxi = 0 ; for ( i = 0 ; i < n ; i ++ ) { maxi = Math . max ( maxi , func ( i , 0 , a , dp , n , x ) ) ; } return maxi ; }
function pre_process ( dp , s ) { var n = s . length ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = false ; } } for ( j = 1 ; j <= n ; j ++ ) { for ( i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = true ; } } else if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] ; } } } }
function countPairs ( s ) { var dp = Array ( N ) . fill ( ) . map ( ( ) => Array ( N ) . fill ( false ) ) ; pre_process ( dp , s ) ; var n = s . length ; var left = Array ( n ) . fill ( 0 ) ; var right = Array ( n ) . fill ( 0 ) ; left [ 0 ] = 1 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( dp [ j ] [ i ] == true ) { left [ i ] ++ ; } } } right [ n - 1 ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { right [ i ] = right [ i + 1 ] ; for ( j = n - 1 ; j >= i ; j -- ) { if ( dp [ i ] [ j ] == true ) { right [ i ] ++ ; } } } var ans = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { ans += left [ i ] * right [ i + 1 ] ; } return ans ; }
function answerQuery ( l , r , dp ) { if ( dp [ l ] [ r ] ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function LIS ( a , n ) { let dp = new Array ( ) ; let d = new Array ( ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
function check ( s ) { let n = s . length ; for ( let i = 2 ; i < n ; i ++ ) { if ( s [ i ] == "1" && s [ i - 1 ] == "1" && s [ i - 2 ] == "1" ) return true ; } return false ; }
function solve ( i , x , dp ) { if ( i < 0 ) { return x == 3 ? 1 : 0 ; } if ( dp [ i ] [ x ] != - 1 ) { return dp [ i ] [ x ] ; } dp [ i ] [ x ] = solve ( i - 1 , 0 , dp ) ; dp [ i ] [ x ] += solve ( i - 1 , x + 1 , dp ) ; return dp [ i ] [ x ] ; }
function dfs ( u , p ) { for ( var v of g [ u ] ) { if ( v != p ) { dfs ( v , u ) ; for ( var i = 0 ; i < 22 ; i ++ ) a [ u ] [ i ] += a [ v ] [ i ] ; } } var pp = 0 ; for ( var i = 0 ; i < 22 ; i ++ ) { if ( ! ( ( a [ u ] [ i ] > 0 && x [ i ] - a [ u ] [ i ] > 0 ) || ( a [ u ] [ i ] == 0 && x [ i ] == 0 ) ) ) { pp = 1 ; break ; } } if ( pp == 0 ) ans ++ ; }
function findCount ( mat , i , j , m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; }
function maxSum ( arr , k , n ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . max ( arr [ 0 ] , arr [ 1 ] ) ; let dp = new Array ( n ) ; dp [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i <= k ; i ++ ) dp [ i ] = Math . max ( arr [ i ] , dp [ i - 1 ] ) ; for ( let i = k + 1 ; i < n ; i ++ ) dp [ i ] = Math . max ( arr [ i ] , dp [ i - ( k + 1 ) ] + arr [ i ] ) ; let max = Number . MIN_VALUE ; for ( let i = 0 ; i < dp . length ; i ++ ) { max = Math . max ( max , dp [ i ] ) ; } return max ; }
function precompute ( ) { let dp = new Array ( maxn ) ; let arr = [ 4 , 6 , 9 ] ; for ( let i = 0 ; i < maxn ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( let i = 1 ; i < maxn ; ++ i ) { for ( let k = 0 ; k < 3 ; k ++ ) { let j = arr [ k ] ; if ( i >= j && dp [ i - j ] != - 1 ) { dp [ i ] = Math . max ( dp [ i ] , dp [ i - j ] + 1 ) ; } } } return dp ; }
function CountWays ( r , b , l , R , B , W , dp ) { if ( l > W ) return 0 ; if ( r > R ) return 0 ; if ( b == B && r == R ) return 1 ; if ( b == B ) return 0 ; if ( dp [ r ] [ b ] [ l ] != - 1 ) return dp [ r ] [ b ] [ l ] ; var ans = 0 ; ans += CountWays ( r , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) ; ans = ans % mod ; return dp [ r ] [ b ] [ l ] = ans ; }
function FindMinimumCost ( ind , a , n , k , dp ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { var ans = Number . MAX_VALUE ; for ( var i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
function minCostJumpsDP ( A , k ) { let size = A . length ; let x = new Array ( size ) ; for ( let i = 0 ; i < size ; i ++ ) x [ i ] = Number . MAX_VALUE ; x [ 0 ] = 0 ; for ( let i = 0 ; i < size ; i ++ ) { for ( let j = i + 1 ; j < i + k + 1 && j < size ; j ++ ) { x [ j ] = min ( x [ j ] , x [ i ] + Math . abs ( A [ i ] - A [ j ] ) ) ; } } return x [ size - 1 ] ; }
function FindMaximumSum ( ind , kon , a , b , c , n , dp ) { if ( ind == n ) return 0 ; if ( dp [ ind ] [ kon ] != - 1 ) return dp [ ind ] [ kon ] ; var ans = - 1000000005 ; if ( kon == 0 ) { ans = Math . max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 1 ) { ans = Math . max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 2 ) { ans = Math . max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; } return dp [ ind ] [ kon ] = ans ; }
function isVowel ( x ) { return ( x == "a" x == "e" x == "i" x == "o" x == "u" ) ; }
function findMinimumDeletion ( l , r , dp , s ) { if ( l > r ) return 0 ; if ( l == r ) return 1 ; if ( dp [ l ] [ r ] != - 1 ) return dp [ l ] [ r ] ; var res = 1 + findMinimumDeletion ( l + 1 , r , dp , s ) ; for ( var i = l + 1 ; i <= r ; ++ i ) { if ( s [ l ] == s [ i ] ) res = Math . min ( res , findMinimumDeletion ( l + 1 , i - 1 , dp , s ) + findMinimumDeletion ( i , r , dp , s ) ) ; } return dp [ l ] [ r ] = res ; }
function noOfBinaryStrings ( N , k ) { let dp = new Array ( 100002 ) ; for ( let i = 1 ; i <= k - 1 ; i ++ ) { dp [ i ] = 1 ; } dp [ k ] = 2 ; for ( let i = k + 1 ; i <= N ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; } return dp [ N ] ; }
function answer ( n ) { var dp = Array ( 10 ) ; var prev = Array ( 10 ) ; if ( n == 1 ) return 10 ; for ( var j = 0 ; j <= 9 ; j ++ ) dp [ j ] = 1 ; for ( var i = 2 ; i <= n ; i ++ ) { for ( var j = 0 ; j <= 9 ; j ++ ) { prev [ j ] = dp [ j ] ; } for ( var j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ j ] = prev [ j + 1 ] ; else if ( j == 9 ) dp [ j ] = prev [ j - 1 ] ; else dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] ; } } var sum = 0 ; for ( var j = 1 ; j <= 9 ; j ++ ) sum += dp [ j ] ; return sum ; }
function MinimumCost ( a , n , x ) { for ( i = 1 ; i < n ; i ++ ) { a [ i ] = Math . min ( a [ i ] , 2 * a [ i - 1 ] ) ; } var ind = 0 ; var sum = 0 ; while ( x > 0 ) { if ( x != 0 ) sum += a [ ind ] ; ind ++ ; x = x >> 1 ; } return sum ; }
function dfs ( node , adj , dp , vis ) { vis [ node ] = true ; for ( var i = 0 ; i < adj [ node ] . length ; i ++ ) { if ( ! vis [ adj [ node ] [ i ] ] ) dfs ( adj [ node ] [ i ] , adj , dp , vis ) ; dp [ node ] = Math . max ( dp [ node ] , 1 + dp [ adj [ node ] [ i ] ] ) ; } }
function sieve_modified ( ) { for ( var i = 2 ; i < MAX ; i += 2 ) { for ( var j = i ; j < MAX ; j += i ) prefix [ j ] += i ; } for ( var i = 1 ; i < MAX ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; }
function binomialCoeff ( n ) { var i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } }
function findSubarraySum ( ind , flips , n , a , k ) { if ( flips > k ) return ( - 1e9 ) ; if ( ind == n ) return 0 ; if ( dp [ ind ] [ flips ] != - 1 ) return dp [ ind ] [ flips ] ; let ans = 0 ; ans = Math . max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ; ans = Math . max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ; return dp [ ind ] [ flips ] = ans ; }
function catalanDP ( n ) { catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( var i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( var j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } }
function CatalanSequence ( arr , n ) { catalanDP ( n ) ; var s = [ ] ; var a = 1 , b = 1 ; var c ; s . push ( a ) ; if ( n >= 2 ) s . push ( b ) ; for ( var i = 2 ; i < n ; i ++ ) { s . push ( catalan [ i ] ) ; } s . sort ( ( a , b ) => b - a ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( s . includes ( arr [ i ] ) ) { s . pop ( arr [ i ] ) ; } } return s . length ; }
function findSubsequence ( arr , n ) { let len = 1 ; let tmp ; let i , j , d ; let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( 10 ) ; for ( let j = 0 ; j < 10 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } let cnt = new Array ( 10 ) ; let locMax ; tmp = arr [ 0 ] ; while ( tmp > 0 ) { dp [ 0 ] [ tmp % 10 ] = 1 ; tmp = Math . floor ( tmp / 10 ) ; } for ( i = 1 ; i < n ; i ++ ) { tmp = arr [ i ] ; locMax = 1 ; for ( let x = 0 ; x < 10 ; x ++ ) cnt [ x ] = 0 ; while ( tmp > 0 ) { cnt [ tmp % 10 ] = 1 ; tmp = Math . floor ( tmp / 10 ) ; } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] > 0 ) { dp [ i ] [ d ] = 1 ; for ( j = 0 ; j < i ; j ++ ) { dp [ i ] [ d ] = Math . max ( dp [ i ] [ d ] , dp [ j ] [ d ] + 1 ) ; locMax = Math . max ( dp [ i ] [ d ] , locMax ) ; } } } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] > 0 ) { dp [ i ] [ d ] = locMax ; } } len = Math . max ( len , locMax ) ; } return len ; }
function solve ( x ) { var num = [ ] ; while ( x ) { num . push ( x % 10 ) ; x = parseInt ( x / 10 ) ; } num . reverse ( ) ; for ( var i = 0 ; i < M ; i ++ ) for ( var j = 0 ; j < 90 ; j ++ ) dp [ i ] [ j ] = Array . from ( Array ( 90 ) , ( ) => Array ( 2 ) . fill ( - 1 ) )  return count ( 0 , 0 , 0 , 0 , num ) ; }
function Add_edge ( x , y ) { gr [ x ] . push ( y ) ; gr [ y ] . push ( x ) ; }
function dfs ( v , par ) { d [ v ] [ 0 ] = 1 ; for ( let i = 0 ; i < gr [ v ] . length ; i ++ ) { if ( gr [ v ] [ i ] != par ) { dfs ( gr [ v ] [ i ] , v ) ; for ( let j = 1 ; j <= k ; j ++ ) ans += d [ gr [ v ] [ i ] ] [ j - 1 ] * d [ v ] [ k - j ] ; for ( let j = 1 ; j <= k ; j ++ ) d [ v ] [ j ] += d [ gr [ v ] [ i ] ] [ j - 1 ] ; } } }
function count ( pos , sum , rem , tight , nonz , num ) { if ( pos == num . length ) { if ( rem == 0 && sum == n ) return 1 ; return 0 ; } if ( dp [ pos ] [ sum ] [ rem ] [ tight ] != - 1 ) return dp [ pos ] [ sum ] [ rem ] [ tight ] ; var ans = 0 ; var limit = ( tight ? 9 : num [ pos ] ) ; for ( var d = 0 ; d <= limit ; d ++ ) { if ( d == 0 && nonz ) continue ; var currSum = sum + d ; var currRem = ( rem * 10 + d ) % m ; var currF = ( tight != 0 || ( d < num [ pos ] ) ) ? 1 : 0 ; ans += count ( pos + 1 , currSum , currRem , currF , ( nonz != 0 d != 0 ) ? 1 : 0 , num ) ; } dp [ pos ] [ sum ] [ rem ] [ tight ] = ans ; return ans ; }
function findXorSum ( arr , n ) { let sum = 0 ; let mul = 1 ; for ( let i = 0 ; i < 30 ; i ++ ) { let c_odd = 0 ; let odd = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) odd = ( ! odd ) ; if ( odd ) c_odd ++ ; } for ( let j = 0 ; j < n ; j ++ ) { sum += ( mul * c_odd ) ; if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) c_odd = ( n - j - c_odd ) ; } mul *= 2 ; } return sum ; }
function preCompute ( ) { lpd = new Array ( MAX + 1 ) ; for ( let i = 0 ; i < lpd . length ; i ++ ) { lpd [ i ] = 0 ; } lpd [ 0 ] = lpd [ 1 ] = 1 ; for ( let i = 2 ; i * i <= MAX ; i ++ ) { for ( let j = i * 2 ; j <= MAX ; j += i ) { if ( lpd [ j ] == 0 ) { lpd [ j ] = i ; } } } for ( let i = 2 ; i <= MAX ; i ++ ) { if ( lpd [ i ] == 0 ) { lpd [ i ] = i ; } } }
function maxLengthSubsequence ( arr , n ) { let dp = new Array ( N ) ; let pos = new Map ( ) ; for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] = 1 ; for ( let i = 0 ; i <= n ; i ++ ) { while ( arr [ i ] > 1 ) { let p = lpd [ arr [ i ] ] ; if ( pos . has ( p ) ) { dp [ i ] = Math . max ( dp [ i ] , 1 + dp [ pos . get ( p ) ] ) ; } pos . set ( p , i ) ; while ( arr [ i ] % p == 0 ) arr [ i ] = Math . floor ( arr [ i ] / p ) ; } } let ans = Math . max ( ... dp ) ; return ans ; }
function charVal ( s , i ) { if ( s . charAt ( i ) == "0" ) { return 0 ; } else if ( s . charAt ( i ) == "1" ) { return 1 ; } else { return 2 ; } }
function getSum ( r1 , r2 , c1 , c2 , dp ) { return dp [ r2 ] [ c2 ] - dp [ r2 ] [ c1 ] - dp [ r1 ] [ c2 ] + dp [ r1 ] [ c1 ] ; }
function sumFound ( K , S , grid ) { var dp = Array . from ( Array ( N + 1 ) , ( ) => Array ( N + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < N ; i ++ ) for ( var j = 0 ; j < N ; j ++ ) dp [ i + 1 ] [ j + 1 ] = dp [ i + 1 ] [ j ] + dp [ i ] [ j + 1 ] - dp [ i ] [ j ] + grid [ i ] [ j ] ; for ( var i = 0 ; i < N ; i ++ ) for ( var j = 0 ; j < N ; j ++ ) { var sum = getSum ( i , i + K , j , j + K , dp ) ; if ( sum == S ) return true ; } return false ; }
function totalSubSets ( n , l , r ) { let zero = Math . floor ( r / 3 ) - Math . ceil ( l / 3 ) + 1 ; let one = Math . floor ( ( r - 1 ) / 3 ) - Math . ceil ( ( l - 1 ) / 3 ) + 1 ; let two = Math . floor ( ( r - 2 ) / 3 ) - Math . ceil ( ( l - 2 ) / 3 ) + 1 ; let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = zero ; dp [ 0 ] [ 1 ] = one ; dp [ 0 ] [ 2 ] = two ; for ( let i = 1 ; i < n ; ++ i ) { dp [ i ] [ 0 ] = ( ( dp [ i - 1 ] [ 0 ] * zero ) + ( dp [ i - 1 ] [ 1 ] * two ) + ( dp [ i - 1 ] [ 2 ] * one ) ) % MOD ; dp [ i ] [ 1 ] = ( ( dp [ i - 1 ] [ 0 ] * one ) + ( dp [ i - 1 ] [ 1 ] * zero ) + ( dp [ i - 1 ] [ 2 ] * two ) ) % MOD ; dp [ i ] [ 2 ] = ( ( dp [ i - 1 ] [ 0 ] * two ) + ( dp [ i - 1 ] [ 1 ] * one ) + ( dp [ i - 1 ] [ 2 ] * zero ) ) % MOD ; } return dp [ n - 1 ] [ 0 ] ; }
function solve ( idx , diff , N , M , K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != - 1 ) return dp [ idx ] [ diff ] ; let ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; dp [ idx ] [ diff ] = ans % MOD ; return dp [ idx ] [ diff ] ; }
function maxPathSum ( tri ) { var ans = 0 ; for ( var i = N - 2 ; i >= 0 ; i -- ) { for ( var j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += Math . max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = Math . max ( ans , tri [ i ] [ j ] ) ; } } return ans ; }
function subsetXOR ( arr , n , K ) { let max_ele = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; let m = ( 1 << parseInt ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 , 10 ) ) - 1 ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = new Array ( n + 1 ) ; for ( let k = 0 ; k <= n ; k ++ ) { dp [ i ] [ j ] [ k ] = 0 ; } } } for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= m ; j ++ ) { for ( let k = 0 ; k <= n ; k ++ ) { dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] ; if ( k != 0 ) { dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] ; } } } } let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { ans += dp [ n ] [ K ] [ i ] ; } return ans ; }
function calcProbability ( M , k ) { let dp = new Array ( m ) ; let sum = new Array ( n ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) { sum [ i ] = 0 ; } for ( let j = 0 ; j < n ; j ++ ) { dp [ 0 ] [ j ] = M [ 0 ] [ j ] ; sum [ 0 ] = sum [ 0 ] + dp [ 0 ] [ j ] ; } for ( let i = 1 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] / sum [ i - 1 ] + M [ i ] [ j ] ; sum [ i ] += dp [ i ] [ j ] ; } } return dp [ n - 1 ] [ k - 1 ] / sum [ n - 1 ] ; }
function MaximumNumbers ( s ) { let n = s . length ; let remIndex = [ - 1 , - 1 , - 1 ] ; remIndex [ 0 ] = 0 ; let res = new Array ( n + 1 ) ; for ( let i = 0 ; i < res . length ; i ++ ) { res [ i ] = 0 ; } let r = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { r = ( r + s [ i - 1 ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) % 3 ; res [ i ] = res [ i - 1 ] ; if ( remIndex [ r ] != - 1 ) res [ i ] = Math . max ( res [ i ] , res [ remIndex [ r ] ] + 1 ) ; remIndex [ r ] = i + 1 ; } return res [ n ] ; }
function get_max_splits ( num_String ) { let count = 0 , current_num ; let running_sum = 0 ; for ( let i = 0 ; i < num_String . length ; i ++ ) { current_num = num_String [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ; running_sum += current_num ; if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; }
function findMinimumSteps ( mat , x , y , n ) { var i , j , k ; var dist = Array ( n ) . fill ( ) . map ( ( ) => Array ( n ) . fill ( 0 ) ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 0 ) dist [ i ] [ j ] = INF ; else dist [ i ] [ j ] = 1 ; if ( i == j ) dist [ i ] [ j ] = 1 ; } } for ( k = 0 ; k < n ; k ++ ) { for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } if ( dist [ x ] [ y ] < INF ) return dist [ x ] [ y ] ; else return - 1 ; }
function findmatch ( mat , pat , x , y , nrow , ncol , level ) { let l = pat . length ; if ( level == l ) return true ; if ( x < 0 y < 0 x >= nrow y >= ncol ) return false ; if ( mat [ x ] [ y ] == pat [ level ] ) { let temp = mat [ x ] [ y ] ; mat [ x ] [ y ] = "#" ; let res = findmatch ( mat , pat , x - 1 , y , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x + 1 , y , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x , y - 1 , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x , y + 1 , nrow , ncol , level + 1 ) ; mat [ x ] [ y ] = temp ; return res ; } return false ; }
function checkMatch ( mat , pat , nrow , ncol ) { let l = pat . length ; if ( l > nrow * ncol ) return false ; for ( let i = 0 ; i < nrow ; i ++ ) { for ( let j = 0 ; j < ncol ; j ++ ) { if ( mat [ i ] [ j ] == pat [ 0 ] ) if ( findmatch ( mat , pat , i , j , nrow , ncol , 0 ) ) return true ; } } return false ; }
function countPaths ( sum , get , m , n , dp ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum ] [ get ] != - 1 ) return dp [ sum ] [ get ] ; let res = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; else res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum ] [ get ] = res ; return dp [ sum ] [ get ] ; }
function countInRange ( x ) { num = [ ] ; while ( x != 0 ) { num . push ( x % 10 ) ; x = Math . floor ( x / 10 ) ; } num . reverse ( ) ; for ( let i = 0 ; i < M ; i ++ ) for ( let j = 0 ; j < M ; j ++ ) for ( let k = 0 ; k < 2 ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ; return countInRangeUtil ( 0 , 0 , 0 ) ; }
function solve ( x ) { var num = [ ] ; while ( x ) { num . push ( x % 10 ) ; x = parseInt ( x / 10 ) ; } num . reverse ( ) ; for ( var i = 0 ; i < M ; i ++ ) for ( var j = 0 ; j < M ; j ++ ) dp [ i ] [ j ] = Array . from ( Array ( 2 ) , ( ) => Array ( 2 ) . fill ( - 1 ) )  return count ( 0 , 0 , 0 , 0 , num ) ; }
function bin ( a , b ) { var ans = ( ( fac [ a ] ) / ( fac [ a - b ] * fac [ b ] ) ) ; return ans ; }
function sumofn ( n , k ) { var p = 0 ; var num1 , temp ; var arr = Array ( 1000 ) . fill ( 0 ) ; for ( j = 1 ; j <= k ; j ++ ) { if ( j == 1 ) { num1 = ( n * ( n + 1 ) ) / 2 ; arr [ p ++ ] = num1 ; temp = num1 ; } else { temp = ( parseInt ( Math . pow ( n + 1 , j + 1 ) - 1 - n ) ) ; for ( s = 1 ; s < j ; s ++ ) { temp = temp - ( arr [ j - s - 1 ] * bin ( j + 1 , s + 1 ) ) ; } temp = temp / ( j + 1 ) ; arr [ p ++ ] = temp ; } } temp = arr [ p - 1 ] ; return temp ; }
function findMinOperations ( S ) { S = reverse ( S ) ; let n = S . length ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } if ( S [ 0 ] == "0" ) { dp [ 0 ] [ 0 ] = 0 ; } else { dp [ 0 ] [ 0 ] = 1 ; } dp [ 0 ] [ 1 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( S [ i ] == "0" ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = 1 + Math . min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] ) ; } else { dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] = 1 + Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; } } return dp [ n - 1 ] [ 0 ] ; }
function solve ( x ) { let ans = 0 , first , last , temp = x ; if ( x < 10 ) return x ; last = x % 10 ; while ( x > 0 ) { first = x % 10 ; x /= 10 ; } if ( first <= last ) ans = 9 + temp / 10 ; else ans = 8 + temp / 10 ; return ans ; }
function findMinimumCost ( n , x , y ) { let dp = new Array ( n + 1 ) ; dp [ 1 ] = x ; for ( let i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) != 0 ) { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ parseInt ( ( i + 1 ) / 2 , 10 ) ] + y + x ) ; } else { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ parseInt ( i / 2 , 10 ) ] + y ) ; } } return dp [ n ] ; }
function countWays ( index , cnt , dp , n , m , k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != - 1 ) return dp [ index ] [ cnt ] ; let ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; }
function findMinSteps ( mat , n , m , dp , vis ) { if ( n == 0 || m == 0 || n == ( r - 1 ) || m == ( c - 1 ) ) { return 0 ; } if ( dp [ n ] [ m ] != - 1 ) return dp [ n ] [ m ] ; vis [ n ] [ m ] = true ; let ans1 , ans2 , ans3 , ans4 ; ans1 = ans2 = ans3 = ans4 = 1e9 ; if ( mat [ n - 1 ] [ m ] == 0 ) { if ( ! vis [ n - 1 ] [ m ] ) ans1 = 1 + findMinSteps ( mat , n - 1 , m , dp , vis ) ; } if ( mat [ n ] [ m + 1 ] == 0 ) { if ( ! vis [ n ] [ m + 1 ] ) ans2 = 1 + findMinSteps ( mat , n , m + 1 , dp , vis ) ; } if ( mat [ n ] [ m - 1 ] == 0 ) { if ( ! vis [ n ] [ m - 1 ] ) ans3 = 1 + findMinSteps ( mat , n , m - 1 , dp , vis ) ; } if ( mat [ n + 1 ] [ m ] == 0 ) { if ( ! vis [ n + 1 ] [ m ] ) ans4 = 1 + findMinSteps ( mat , n + 1 , m , dp , vis ) ; } dp [ n ] [ m ] = Math . min ( ans1 , Math . min ( ans2 , Math . min ( ans3 , ans4 ) ) ) ; return dp [ n ] [ m ] ; }
function minimumSteps ( mat , n , m ) { let twox = - 1 ; let twoy = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 2 ) { twox = i ; twoy = j ; break ; } } if ( twox != - 1 ) break ; } let dp = new Array ( r ) ; for ( let j = 0 ; j < r ; j ++ ) { dp [ j ] = new Array ( r ) ; for ( let i = 0 ; i < r ; i ++ ) { dp [ j ] [ i ] = - 1 ; } } let vis = new Array ( r ) ; for ( let j = 0 ; j < r ; j ++ ) { vis [ j ] = new Array ( r ) ; for ( let i = 0 ; i < r ; i ++ ) { vis [ j ] [ i ] = false ; } } let res = findMinSteps ( mat , twox , twoy , dp , vis ) ; if ( res >= 1e9 ) return - 1 ; else return res ; }
function nCr ( n , r ) { var ans = 1 ; if ( r > n - r ) r = n - r ; for ( var i = 0 ; i < r ; i ++ ) { ans *= n - i ; ans /= i + 1 ; } return ans ; }
function countDerangements ( n ) { var der = [ ... Array ( n + 1 ) ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( var i = 3 ; i <= n ; i ++ ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
function countPermutations ( n , k ) { var ans = 0 ; for ( var i = n - k ; i <= n ; i ++ ) { var ways = nCr ( n , i ) ; ans += ways * countDerangements ( n - i ) ; } return ans ; }
function solve ( dp , wt , K , M , used ) { if ( wt < 0 ) { return 0 ; } if ( wt == 0 ) { if ( used == 1 ) { return 1 ; } return 0 ; } if ( dp [ wt ] [ used ] != - 1 ) { return dp [ wt ] [ used ] ; } let ans = 0 ; for ( let i = 1 ; i <= K ; i ++ ) { if ( i >= M ) { ans += solve ( dp , wt - i , K , M , used 1 ) ; } else { ans += solve ( dp , wt - i , K , M , used ) ; } } return dp [ wt ] [ used ] = ans ; }
function squares ( i ) { if ( ( i & 1 ) == 1 ) return parseInt ( i / 4 , 10 ) * 2 + 1 ; else return parseInt ( ( i - 1 ) / 4 , 10 ) * 2 + 2 ; }
function bishop_placements ( n , k ) { if ( k > 2 * n - 1 ) return 0 ; let dp = new Array ( n * 2 ) ; for ( let i = 0 ; i < n * 2 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } dp [ i ] [ 0 ] = 1 ; } dp [ 1 ] [ 1 ] = 1 ; for ( let i = 2 ; i < n * 2 ; i ++ ) { for ( let j = 1 ; j <= k ; j ++ ) dp [ i ] [ j ] = dp [ i - 2 ] [ j ] + dp [ i - 2 ] [ j - 1 ] * ( squares ( i ) - j + 1 ) ; } let ans = 0 ; for ( let i = 0 ; i <= k ; i ++ ) { ans += dp [ n * 2 - 1 ] [ i ] * dp [ n * 2 - 2 ] [ k - i ] ; } return ans ; }
function sumOddFibonacci ( n ) { var Sum = Array ( n + 1 ) . fill ( 0 ) ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; }
function noOfAssignments ( s , n , i , c_x , c_y ) { if ( F [ i ] [ c_x ] [ c_y ] != - 1 ) return F [ i ] [ c_x ] [ c_y ] ; if ( i == n ) { F [ i ] [ c_x ] [ c_y ] = ( c_x == 0 && c_y == 0 ) ? 1 : 0 ; return F [ i ] [ c_x ] [ c_y ] ; } if ( s . charAt ( i ) == "(" ) { F [ i ] [ c_x ] [ c_y ] = noOfAssignments ( s , n , i + 1 , c_x + 1 , c_y ) + noOfAssignments ( s , n , i + 1 , c_x , c_y + 1 ) ; return F [ i ] [ c_x ] [ c_y ] ; } F [ i ] [ c_x ] [ c_y ] = 0 ; if ( c_x != 0 ) F [ i ] [ c_x ] [ c_y ] += noOfAssignments ( s , n , i + 1 , c_x - 1 , c_y ) ; if ( c_y != 0 ) F [ i ] [ c_x ] [ c_y ] += noOfAssignments ( s , n , i + 1 , c_x , c_y - 1 ) ; return F [ i ] [ c_x ] [ c_y ] ; }
function noOfAssignments ( S , n , i , c_x ) { if ( F [ i ] [ c_x ] != - 1 ) { return F [ i ] [ c_x ] ; } if ( i == n ) { if ( c_x == 1 ) { F [ i ] [ c_x ] = 0 ; } else { F [ i ] [ c_x ] = 1 ; } return F [ i ] [ c_x ] ; } var c_y = C [ i ] - c_x ; if ( S [ i ] == "(" ) { F [ i ] [ c_x ] = noOfAssignments ( S , n , i + 1 , c_x + 1 ) + noOfAssignments ( S , n , i + 1 , c_x ) ; return F [ i ] [ c_x ] ; } F [ i ] [ c_x ] = 0 ; if ( c_x == 1 ) { F [ i ] [ c_x ] += noOfAssignments ( S , n , i + 1 , c_x - 1 ) ; } if ( c_y == 1 ) { F [ i ] [ c_x ] += noOfAssignments ( S , n , i + 1 , c_x ) ; } return F [ i ] [ c_x ] ; }
function MaxProfit ( treasure , color , n , k , col , A , B ) { let sum = 0 ; if ( k == n ) return 0 ; if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return sum ; }
function calculateEvenSum ( n ) { if ( n <= 0 ) return 0 ; let fibo = Array ( 2 * n + 1 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; let sum = 0 ; for ( i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; }
function fib ( n ) { if ( n == 0 ) { return 0 ; } if ( n == 1 n == 2 ) { return ( f [ n ] = 1 ) ; } if ( f [ n ] == 1 ) { return f [ n ] ; } var k = ( n % 2 == 1 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( n % 2 == 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
function calculateEvenSum ( n ) { return ( fib ( 2 * n + 1 ) - 1 ) ; }
function find ( index , openbrk , n , adj ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index ] [ openbrk ] != - 1 ) return dp [ index ] [ openbrk ] ; dp [ index ] [ openbrk ] = Math . min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; }
function gouldSequence ( n ) { for ( var row_num = 1 ; row_num <= n ; row_num ++ ) { var count = 1 ; var c = 1 ; for ( var i = 1 ; i <= row_num ; i ++ ) { c = c * ( row_num - i ) / i ; if ( c % 2 == 1 ) count ++ ; } document . write ( count + "▁" ) ; } }
function gouldSequence ( ) { arr [ 0 ] = 1 ; var i = 1 ; var p = 1 ; while ( i <= MAX ) { var j = 0 ; while ( j < i ) { arr [ i + j ] = 2 * arr [ j ] ; j ++ ; } i = ( 1 << p ) ; p ++ ; } }
function printSequence ( n ) { for ( var i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function minFallingPathSum ( A ) { for ( let R = n - 2 ; R >= 0 ; -- R ) { for ( let C = 0 ; C < n ; ++ C ) { let best = A [ R + 1 ] [ C ] ; if ( C > 0 ) best = Math . min ( best , A [ R + 1 ] [ C - 1 ] ) ; if ( C + 1 < n ) best = Math . min ( best , A [ R + 1 ] [ C + 1 ] ) ; A [ R ] [ C ] = A [ R ] [ C ] + best ; } } let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; ++ i ) ans = Math . min ( ans , A [ 0 ] [ i ] ) ; return ans ; }
function maxPlus ( arr ) { let ans = 0 ; let left = new Array ( N ) ; let right = new Array ( N ) ; let up = new Array ( N ) ; let down = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { left [ i ] = new Array ( N ) ; right [ i ] = new Array ( N ) ; up [ i ] = new Array ( N ) ; down [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { left [ i ] [ j ] = 0 ; right [ i ] [ j ] = 0 ; up [ i ] [ j ] = 0 ; down [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { left [ i ] [ j ] = Math . max ( 0 , ( ( j != 0 ) ? left [ i ] [ j - 1 ] : 0 ) ) + arr [ i ] [ j ] ; up [ i ] [ j ] = Math . max ( 0 , ( ( i != 0 ) ? up [ i - 1 ] [ j ] : 0 ) ) + arr [ i ] [ j ] ; } } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { right [ i ] [ j ] = Math . max ( 0 , ( j + 1 == m ? 0 : right [ i ] [ j + 1 ] ) ) + arr [ i ] [ j ] ; down [ i ] [ j ] = Math . max ( 0 , ( i + 1 == n ? 0 : down [ i + 1 ] [ j ] ) ) + arr [ i ] [ j ] ; } } for ( let i = 1 ; i < n - 1 ; ++ i ) for ( let j = 1 ; j < m - 1 ; ++ j ) { ans = Math . max ( ans , up [ i - 1 ] [ j ] + down [ i + 1 ] [ j ] + left [ i ] [ j - 1 ] + right [ i ] [ j + 1 ] + arr [ i ] [ j ] ) ; } return ans ; }
function fun ( marks , n ) { let dp = new Array ( n ) ; let temp ; for ( let i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; }
function getNumberOfWays ( N , Coins ) { let ways = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) { ways [ i ] = 0 ; } ways [ 0 ] = 1 ; for ( let i = 0 ; i < Coins . length ; i ++ ) { for ( let j = 0 ; j < ways . length ; j ++ ) { if ( Coins [ i ] <= j ) { ways [ j ] += ways [ ( j - Coins [ i ] ) ] ; } } } return ways [ N ] ; }
function countStaircases ( N ) { let memo = new Array ( N + 5 ) ; for ( let i = 0 ; i < N + 5 ; i ++ ) { memo [ i ] = new Array ( N + 5 ) ; for ( let j = 0 ; j < N + 5 ; j ++ ) { memo [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= N ; i ++ ) { for ( let j = 0 ; j <= N ; j ++ ) { memo [ i ] [ j ] = 0 ; } } memo [ 3 ] [ 2 ] = memo [ 4 ] [ 2 ] = 1 ; for ( let i = 5 ; i <= N ; i ++ ) { for ( let j = 2 ; j <= i ; j ++ ) { if ( j == 2 ) { memo [ i ] [ j ] = memo [ i - j ] [ j ] + 1 ; } else { memo [ i ] [ j ] = memo [ i - j ] [ j ] + memo [ i - j ] [ j - 1 ] ; } } } let answer = 0 ; for ( let i = 1 ; i <= N ; i ++ ) answer = answer + memo [ N ] [ i ] ; return answer ; }
function partitions ( n ) { var p = Array ( n + 1 ) . fill ( 0 ) ; p [ 0 ] = 1 ; for ( i = 1 ; i <= n ; ++ i ) { var k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; }
function find ( m , n , adj ) { let sweet = new Array ( n + 1 ) ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; ++ i ) { dp [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; ++ j ) { dp [ i ] [ j ] = new Array ( n + 1 ) ; for ( let k = 0 ; k <= n ; ++ k ) { dp [ i ] [ j ] [ k ] = - 1 ; } } } sweet [ 0 ] = 0 ; for ( let i = 1 ; i <= m ; ++ i ) sweet [ i ] = adj [ i - 1 ] ; for ( let i = 0 ; i <= m ; ++ i ) { for ( let k = 0 ; k <= n ; ++ k ) dp [ i ] [ 0 ] [ k ] = 0 ; for ( let k = 1 ; k <= n ; ++ k ) dp [ i ] [ k ] [ 0 ] = - 1 ; } for ( let i = 0 ; i <= m ; ++ i ) { for ( let j = 1 ; j <= n ; ++ j ) { for ( let k = 1 ; k <= n ; ++ k ) { dp [ i ] [ j ] [ k ] = - 1 ; if ( i > 0 && j >= k && sweet [ k ] > 0 && dp [ i - 1 ] [ j - k ] [ k ] != - 1 ) dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j - k ] [ k ] + sweet [ k ] ; if ( dp [ i ] [ j ] [ k ] == - 1 || ( dp [ i ] [ j ] [ k - 1 ] != - 1 && dp [ i ] [ j ] [ k ] > dp [ i ] [ j ] [ k - 1 ] ) ) dp [ i ] [ j ] [ k ] = dp [ i ] [ j ] [ k - 1 ] ; } } } if ( dp [ m ] [ n ] [ n ] == - 1 ) return 0 ; else return dp [ m ] [ n ] [ n ] ; }
function find_min_odd_cost ( given , m , n ) { let floor = new Array ( M ) ; for ( let i = 0 ; i < M ; i ++ ) { floor [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { floor [ i ] [ j ] = 0 ; } } let min_odd_cost = 0 ; let i , j , temp ; for ( j = 0 ; j < n ; j ++ ) floor [ 0 ] [ j ] = given [ 0 ] [ j ] ; for ( i = 1 ; i < m ; i ++ ) for ( j = 0 ; j < n ; j ++ ) { if ( j == 0 ) { floor [ i ] [ j ] = given [ i ] [ j ] ; floor [ i ] [ j ] += Math . min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j + 1 ] ) ; } else if ( j == n - 1 ) { floor [ i ] [ j ] = given [ i ] [ j ] ; floor [ i ] [ j ] += Math . min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) ; } else { temp = Math . min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) ; temp = Math . min ( temp , floor [ i - 1 ] [ j + 1 ] ) ; floor [ i ] [ j ] = given [ i ] [ j ] + temp ; } } min_odd_cost = Number . MAX_VALUE ; for ( j = 0 ; j < n ; j ++ ) { if ( floor [ n - 1 ] [ j ] % 2 == 1 ) { if ( min_odd_cost > floor [ n - 1 ] [ j ] ) min_odd_cost = floor [ n - 1 ] [ j ] ; } } if ( min_odd_cost == Number . MIN_VALUE ) return - 1 ; return min_odd_cost ; }
function countPaths ( m , n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }
function countPaths ( m , n ) { let dp = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= m ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }
function factorial ( n ) { var res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
function countWays ( m , n ) { m = m - 1 ; n = n - 1 ; return factorial ( m + n ) / ( factorial ( m ) * factorial ( n ) ) ; }
function MatrixChainOrder ( p , n ) { var dp = Array . from ( Array ( n ) , ( ) => Array ( n ) ) ; for ( var i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( var L = 1 ; L < n - 1 ; L ++ ) for ( var i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = Math . min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }
function createPalindrome ( input , isOdd ) { var n = input ; var palin = input ; if ( isOdd % 2 == 1 ) { n = parseInt ( n / 10 ) ; } while ( n > 0 ) { palin = palin * 10 + ( n % 10 ) ; n = parseInt ( n / 10 ) ; } return palin ; }
function generatePalindromes ( N ) { var palindromes = [ ] ; var number ; for ( var j = 0 ; j < 2 ; j ++ ) { var i = 1 ; while ( ( number = createPalindrome ( i ++ , j ) ) <= N ) { palindromes . push ( number ) ; } } return palindromes ; }
function minimumNoOfPalindromes ( N ) { var a = N . toString ( ) ; var b = N . toString ( ) ; b = reverse ( b ) ; if ( a == b ) { return 1 ; } var palindromes = generatePalindromes ( N ) ; palindromes . sort ( ) ; var l = 0 , r = palindromes . length - 1 ; while ( l < r ) { if ( palindromes [ l ] + palindromes [ r ] == N ) { return 2 ; } else if ( palindromes [ l ] + palindromes [ r ] < N ) { ++ l ; } else { -- r ; } } return 3 ; }
function costOfString ( str ) { let cost = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) cost += ( str [ i ] . charCodeAt ( 0 ) - 48 ) ; return cost ; }
function lds ( arr , n ) { let lds = new Array ( n ) ; lds [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { lds [ i ] = 1 ; for ( let j = 0 ; j < i ; j ++ ) if ( lds [ j ] != 0 && arr [ i ] % arr [ j ] == 0 ) lds [ i ] = Math . max ( lds [ i ] , lds [ j ] + 1 ) ; } let max = Math . max ( ... lds ) ; return max ; }
function find ( start , adj , n , dp ) { if ( start == n ) return 0 ; if ( dp [ start ] != - 1 ) return dp [ start ] ; dp [ start ] = 0 ; var one = 0 , zero = 0 , k ; for ( k = start ; k < n ; k ++ ) { if ( adj [ k ] == "1" ) one ++ ; else zero ++ ; if ( one > zero ) dp [ start ] = Math . max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) ; else dp [ start ] = Math . max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) ; } return dp [ start ] ; }
function isVowel ( ch ) { if ( ch == "a" ch == "e" ch == "i" ch == "o" ch == "u" ) return true ; return false ; }
function lcs ( X , Y , m , n ) { let L = new Array ( m + 1 ) ; let i , j ; for ( i = 0 ; i <= m ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( ( X [ i - 1 ] == Y [ j - 1 ] ) && isVowel ( X [ i - 1 ] ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; }
function catalan ( n ) { var c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
function makePairs ( pairs , a , b ) { for ( i = a ; i <= b ; i ++ ) { var sumOfDigits = 0 , k = i ; while ( k > 0 ) { sumOfDigits += k % 10 ; k = parseInt ( k / 10 ) ; } if ( sumOfDigits <= 162 ) pairs . push ( sumOfDigits ) ; } }
function countCoPrime ( a , b ) { var pairs = [ ] ; makePairs ( pairs , a , b ) ; var count = 0 ; for ( i = 0 ; i < pairs . length ; i ++ ) for ( j = i + 1 ; j < pairs . length ; j ++ ) if ( GCD ( pairs [ i ] , pairs [ j ] ) == 1 ) count ++ ; return count ; }
function recursive ( idx , sum , tight , st , dp , num ) { if ( idx == num ) { return sum == 0 ? 1 : 0 ; } if ( dp [ idx ] [ tight ] [ sum ] != - 1 ) return dp [ idx ] [ tight ] [ sum ] ; let newTight ; let ans = 0 ; let d ; for ( d = 0 ; d < 10 ; ++ d ) { newTight = 0 ; if ( tight == 1 && st [ idx ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) < d ) continue ; if ( tight == 1 && st [ idx ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) == d ) newTight = 1 ; if ( sum >= d ) ans += recursive ( idx + 1 , sum - d , newTight , st , dp , num ) ; } return dp [ idx ] [ tight ] [ sum ] = ans ; }
function formArray ( N ) { let dp = new Array ( 20 ) ; for ( let i = 0 ; i < 20 ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = new Array ( 166 ) ; for ( let k = 0 ; k < 166 ; k ++ ) { dp [ i ] [ j ] [ k ] = - 1 ; } } } let st = ( N ) . toString ( ) ; let num = st . length ; let arr = [ ] ; for ( let i = 1 ; i <= 162 ; ++ i ) { arr . push ( recursive ( 0 , i , 1 , st , dp , num ) ) ; } return arr ; }
function findPair ( a , b ) { let arr_smaller = formArray ( a - 1 ) ; let arr_greater = formArray ( b ) ; for ( let i = 0 ; i < arr_greater . length ; ++ i ) { arr_greater [ i ] -= arr_smaller [ i ] ; } let ans = 0 ; for ( let i = 1 ; i <= 162 ; ++ i ) { for ( let j = i + 1 ; j <= 162 ; ++ j ) { if ( gcd ( i , j ) == 1 ) { ans = ( ans + arr_greater [ i - 1 ] * arr_greater [ j - 1 ] ) ; } } } return ans ; }
function printTetraRec ( n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return 1 ; if ( n == 3 ) return 2 ; else return printTetraRec ( n - 1 ) + printTetraRec ( n - 2 ) + printTetraRec ( n - 3 ) + printTetraRec ( n - 4 ) ; }
function printTetra ( n ) { let dp = new Array ( n + 5 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( let i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; document . write ( dp [ n ] ) ; }
function printTetra ( n ) { if ( n < 0 ) return ; var first = 0 , second = 1 ; var third = 1 , fourth = 2 ; var curr ; if ( n == 0 ) cout << first ; else if ( n == 1 n == 2 ) cout << second ; else if ( n == 3 ) cout << fourth ; else { for ( var i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } document . write ( curr ) ; } }
function check ( n ) { let v = [ ] ; v = factors ( n ) ; v . sort ( function ( a , b ) { return a - b ; } ) ; let r = v . length ; let subset = new Array ( r + 1 ) ; for ( let i = 0 ; i < r + 1 ; i ++ ) { subset [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { subset [ i ] [ j ] = false ; } } for ( let i = 0 ; i <= r ; i ++ ) subset [ i ] [ 0 ] = true ; for ( let i = 1 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = false ; for ( let i = 1 ; i <= r ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( j < v [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; else { subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - v [ i - 1 ] ] ; } } } if ( ( subset [ r ] [ n ] ) == false ) return false ; else return true ; }
function maxSum1 ( arr , n ) { let dp = new Array ( n ) ; let maxi = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( i = 2 ; i < n - 1 ; i ++ ) { for ( j = 0 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < dp [ j ] + arr [ i ] ) { dp [ i ] = dp [ j ] + arr [ i ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; }
function maxSum2 ( arr , n ) { let dp = new Array ( n ) ; let maxi = 0 ; for ( i = 1 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( i = 3 ; i < n ; i ++ ) { for ( j = 1 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < arr [ i ] + dp [ j ] ) { dp [ i ] = arr [ i ] + dp [ j ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; }
function findMaxSum ( arr , n ) { let t = Math . max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) ) ; return t ; }
function solve ( N , K ) { let combo = new Array ( 50 ) ; combo . fill ( 0 ) ; combo [ 0 ] = 1 ; for ( let i = 1 ; i <= K ; i ++ ) { for ( let j = 0 ; j <= N ; j ++ ) { if ( j >= i ) { combo [ j ] += combo [ j - i ] ; } } } return combo [ N ] ; }
function fibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( let i = 2 ; i < 43 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; }
function rec ( x , y , last ) { if ( y == 0 ) { if ( x == 0 ) return 1 ; return 0 ; } let sum = 0 ; for ( let i = last ; i >= 0 && fib [ i ] * y >= x ; i -- ) { if ( fib [ i ] > x ) continue ; sum += rec ( x - fib [ i ] , y - 1 , i ) ; } return sum ; }
function MinimumPrimes ( n ) { let dp = new Array ( n + 1 )  for ( let i = 1 ; i <= n ; i ++ ) dp [ i ] = 1e9 ; dp [ 0 ] = dp [ 2 ] = dp [ 3 ] = dp [ 5 ] = dp [ 7 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( check ( i , 2 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 2 ] ) ; if ( check ( i , 3 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 3 ] ) ; if ( check ( i , 5 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 5 ] ) ; if ( check ( i , 7 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 7 ] ) ; } if ( dp [ n ] == ( 1e9 ) ) return - 1 ; else return dp [ n ] ; }
function minimumCost ( cost , n ) { let dp = new Array ( n ) ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( let i = 2 ; i < n ; i ++ ) { dp [ i ] = Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return Math . min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; }
function minimumCost ( cost , n ) { let dp1 = 0 , dp2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; }
function subsetSum ( arr , n , maxSum ) { var dp = Array ( maxSum + 1 ) . fill ( false ) dp [ arr [ 0 ] ] = true ; for ( var i = 1 ; i < n ; i ++ ) { for ( var j = maxSum ; j >= 1 ; j -- ) { if ( arr [ i ] <= j ) { if ( arr [ i ] == j || dp [ j ] || dp [ ( j - arr [ i ] ) ] ) dp [ j ] = true ; else dp [ j ] = false ; } } } document . write ( 0 + "▁" ) ; for ( var j = 0 ; j < maxSum + 1 ; j ++ ) { if ( dp [ j ] == true ) document . write ( j + "▁" ) ; } document . write ( "21" ) ; }
function printDistinct ( a , n ) { var maxSum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { maxSum += a [ i ] ; } subsetSum ( a , n , maxSum ) ; }
function maxCost ( a , m , n , dp ) { if ( n < 0 m < 0 ) return - 1e9 ; else if ( m == 0 && n == 0 ) return 0 ; else if ( dp [ m ] [ n ] != - 1 ) return dp [ m ] [ n ] ; else { let num = m + n ; if ( ( num & ( num - 1 ) ) == 0 ) return dp [ m ] [ n ] = a [ m ] [ n ] + maxCost ( a , m - 1 , n - 1 , dp ) ; else return dp [ m ] [ n ] = ( a [ m ] [ n ] + Math . max ( maxCost ( a , m - 1 , n , dp ) , maxCost ( a , m , n - 1 , dp ) ) ) ; } }
function answer ( a , n ) { let dp = new Array ( size ) ; for ( let i = 0 ; i < size ; i ++ ) { dp [ i ] = new Array ( size ) ; for ( let j = 0 ; j < size ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return maxCost ( a , n - 1 , n - 1 , dp ) ; }
function editDistanceWith2Ops ( X , Y ) { let m = X . length , n = Y . length ; let L = new Array ( m + 1 ) ; for ( let i = 0 ; i < L . length ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < L [ i ] . length ; j ++ ) { L [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) { L [ i ] [ j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; } else { L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } } let lcs = L [ m ] [ n ] ; return ( m - lcs ) + ( n - lcs ) ; }
function lcs ( X , Y , m , n ) { if ( m == 0 n == 0 ) { return 0 ; } if ( X [ m - 1 ] == Y [ n - 1 ] ) { return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; } else { return Math . max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } }
function lcs ( X , Y , m , n , dp ) { if ( m == 0 n == 0 ) { return 0 ; } if ( dp [ m - 1 ] [ n - 1 ] != - 1 ) { return dp [ m - 1 ] [ n - 1 ] ; } if ( X [ m - 1 ] == Y [ n - 1 ] ) { dp [ m - 1 ] [ n - 1 ] = 1 + lcs ( X , Y , m - 1 , n - 1 , dp ) ; return dp [ m - 1 ] [ n - 1 ] ; } else { dp [ m - 1 ] [ n - 1 ] = Math . max ( lcs ( X , Y , m , n - 1 , dp ) , lcs ( X , Y , m - 1 , n , dp ) ) ; return dp [ m - 1 ] [ n - 1 ] ; } }
function countPaths ( n ) { let zB = 1 ; let zADC = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let nzB = zADC * 3 ; let nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }
function sumSubSequence ( arr , len , m ) { let sum = 0 ; for ( let x = 0 ; x < arr . length ; x ++ ) { sum += arr [ x ] ; } let dp = new Array ( len + 1 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( sum + 1 ) ; for ( let j = 0 ; j < dp [ i ] . length ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= len ; i ++ ) dp [ i ] [ 0 ] ++ ; for ( let i = 1 ; i <= len ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] ++ ; for ( let j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] > 0 ) { dp [ i ] [ j ] ++ ; dp [ i ] [ j + arr [ i - 1 ] ] ++ ; } } } let count = 0 ; for ( let j = 1 ; j <= sum ; j ++ ) if ( dp [ len ] [ j ] > 0 ) if ( j % m == 0 ) count += dp [ len ] [ j ] ; return count ; }
function totalWays ( N , M , X ) { let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } if ( X == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } else { dp [ 0 ] [ 1 ] = 0 ; } if ( X == 1 ) { dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = M - 1 ; } else { dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = ( M - 2 ) ; } for ( let i = 2 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ; } return dp [ N - 1 ] [ 0 ] ; }
function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
function fib ( n ) { let term = new Array ( 1000 ) ; term . fill ( 0 ) ; if ( n <= 1 ) return n ; if ( term [ n ] != 0 ) return term [ n ] ; else { term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; return term [ n ] ; } }
function lcs ( X , Y , m , n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }
function lcs ( X , Y , m , n ) { if ( m == 0 n == 0 ) return 0 ; if ( arr [ m - 1 ] [ n - 1 ] != - 1 ) return arr [ m - 1 ] [ n - 1 ] ; if ( X [ m - 1 ] == Y [ n - 1 ] ) { arr [ m - 1 ] [ n - 1 ] = 1 + lcs ( X , Y , m - 1 , n - 1 ) ; return arr [ m - 1 ] [ n - 1 ] ; } else { arr [ m - 1 ] [ n - 1 ] = Math . max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; return arr [ m - 1 ] [ n - 1 ] ; } }
function lcs ( X , Y , Z , m , n , o ) { if ( m == 0 n == 0 o == 0 ) return 0 ; if ( arr [ m - 1 ] [ n - 1 ] [ o - 1 ] != - 1 ) return arr [ m - 1 ] [ n - 1 ] [ o - 1 ] ; if ( X [ m - 1 ] == Y [ n - 1 ] && Y [ n - 1 ] == Z [ o - 1 ] ) { arr [ m - 1 ] [ n - 1 ] [ o - 1 ] = 1 + lcs ( X , Y , Z , m - 1 , n - 1 , o - 1 ) ; return arr [ m - 1 ] [ n - 1 ] [ o - 1 ] ; } else { arr [ m - 1 ] [ n - 1 ] [ o - 1 ] = max ( lcs ( X , Y , Z , m , n - 1 , o ) , max ( lcs ( X , Y , Z , m - 1 , n , o ) , lcs ( X , Y , Z , m , n , o - 1 ) ) ) ; return arr [ m - 1 ] [ n - 1 ] [ o - 1 ] ; } }
function minStepsNeeded ( k , d1 , d2 , x ) { let gcd = __gcd ( d1 , d2 ) ; if ( ( k - x ) % gcd != 0 ) return - 1 ; let q = [ ] ; let visited = new Set ( ) ; q . push ( [ k , 0 ] ) ; visited . add ( k ) ; while ( q . length != 0 ) { let s = q [ 0 ] [ 0 ] ; let stp = q [ 0 ] [ 1 ] ; if ( s == x ) return stp ; q . shift ( ) ; if ( ! visited . has ( s + d1 ) ) { q . push ( [ s + d1 , stp + 1 ] ) ; visited . add ( s + d1 ) ; } if ( ! visited . has ( s + d2 ) ) { q . push ( [ s + d2 , stp + 1 ] ) ; visited . add ( s + d2 ) ; } if ( ! visited . has ( s - d1 ) ) { q . push ( [ s - d1 , stp + 1 ] ) ; visited . add ( s - d1 ) ; } if ( ! visited . has ( s - d2 ) ) { q . push ( [ s - d2 , stp + 1 ] ) ; visited . add ( s - d2 ) ; } } return Number . MIN_VALUE ; }
function lds ( arr , n ) { let lds = new Array ( n ) ; let i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; }
function minimumNumberOfDigits ( a , b ) { if ( a > b a < 0 b < 0 a > 900 b > 8100 ) return - 1 ; if ( a == 0 && b == 0 ) return 0 ; if ( dp [ a ] [ b ] != - 1 ) return dp [ a ] [ b ] ; var ans = 101 ; for ( var i = 9 ; i >= 1 ; i -- ) { var k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) ; if ( k != - 1 ) ans = Math . min ( ans , k + 1 ) ; } return dp [ a ] [ b ] = ans ; }
function printSmallestNumber ( a , b ) { dp = new Array ( 901 ) . fill ( - 1 ) . map ( ( ) => new Array ( 8101 ) . fill ( - 1 ) ) ; ; dp [ 0 ] [ 0 ] = 0 ; var k = minimumNumberOfDigits ( a , b ) ; if ( k == - 1 k > 100 ) document . write ( "-1" ) ; else { while ( a > 0 && b > 0 ) { for ( var i = 1 ; i <= 9 ; i ++ ) { if ( a >= i && b >= i * i && 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] ) { document . write ( i ) ; a -= i ; b -= i * i ; break ; } } } } }
function binomialCoeff ( C , n ) { for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = Math . min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } }
function sumOfproduct ( n ) { var sum = 0 ; var C = Array ( MAX ) . fill ( 0 ) ; binomialCoeff ( C , n ) ; for ( var i = 0 ; i <= n ; i ++ ) sum += C [ i ] * C [ i + 1 ] ; return sum ; }
function binomialCoeff ( n , k ) { let C = new Array ( k + 1 ) ; C . fill ( 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
function sumOfproduct ( n ) { return binomialCoeff ( 2 * n , n - 1 ) ; }
function check ( i , sum , n , k , a , dp ) { if ( sum <= 0 ) return false ; if ( i >= n ) { if ( sum == k ) return true ; return false ; } if ( dp [ i ] [ sum ] != - 1 ) return dp [ i ] [ sum ] ; dp [ i ] [ sum ] = check ( i + 1 , sum - 2 * a [ i ] , n , k , a , dp ) || check ( i + 1 , sum , n , k , a , dp ) ; dp [ i ] [ sum ] = check ( i + 1 , sum - ( i + 1 ) , n , k , a , dp ) || dp [ i ] [ sum ] ; dp [ i ] [ sum ] = check ( i + 1 , sum + i + 1 , n , k , a , dp ) || dp [ i ] [ sum ] ; return dp [ i ] [ sum ] ; }
function wrapper ( n , k , a ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += a [ i ] ; var dp = Array . from ( Array ( MAX ) , ( ) => Array ( MAX ) . fill ( - 1 ) ) ; return check ( 0 , sum , n , k , a , dp ) ; }
function isPowerOf ( val , base ) { while ( val > 1 ) { if ( val % base != 0 ) val /= base ; } return true ; }
function numberOfPartitions ( binaryNo ) { var i , j , n = binaryNo . length ; var val ; var dp = Array ( n ) ; dp [ n - 1 ] = ( ( binaryNo [ n - 1 ] - "0" ) == 0 ) ? - 1 : 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { val = 0 ; if ( ( binaryNo [ i ] - "0" ) == 0 ) { dp [ i ] = - 1 ; continue ; } dp [ i ] = 1000000000 ; for ( j = i ; j < n ; j ++ ) { val = ( val * 2 ) + ( binaryNo [ j ] - "0" ) ; if ( isPowerOf ( val , 4 ) || isPowerOf ( val , 6 ) ) { if ( j == n - 1 ) { dp [ i ] = 1 ; } else { if ( dp [ j + 1 ] != - 1 ) dp [ i ] = Math . min ( dp [ i ] , dp [ j + 1 ] + 1 ) ; } } } if ( dp [ i ] == 1000000000 ) dp [ i ] = - 1 ; } return dp [ 0 ] ; }
function binomialCoeff ( n , C ) { for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = Math . min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } }
function summation ( n ) { C = Array ( MAX ) . fill ( 0 ) ; binomialCoeff ( n , C ) ; var sum = 0 ; for ( var i = 0 ; i <= n ; i ++ ) sum += ( i * C [ i ] ) ; return sum ; }
function summation ( n ) { return n << ( n - 1 ) ; }
function binomialCoeff ( n , k ) { var C = Array ( k + 1 ) . fill ( 0 ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
function countArray ( N , K ) { return binomialCoeff ( K - 1 , N - 1 ) ; }
function count ( n , c , a , b ) { var need = Array ( N ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { a [ i + n ] = a [ i ] ; b [ i + n ] = b [ i ] ; } var s = 0 ; var tank = 0 ; for ( var i = 0 ; i < 2 * n ; i ++ ) { tank += a [ i ] ; tank = Math . min ( tank , c ) ; tank -= b [ i ] ; if ( tank < 0 ) { tank = 0 ; s = i + 1 ; } } if ( s >= n ) return 0 ; var ans = 1 ; need [ s + n ] = 0 ; for ( var i = 1 ; i < n ; i ++ ) { var id = s + n - i ; need [ id ] = Math . max ( 0 , need [ id + 1 ] + b [ id ] - Math . min ( a [ id ] , c ) ) ; if ( need [ id ] == 0 ) ans ++ ; } return ans ; }
function fib ( n ) { let a = 0 , b = 1 , c ; if ( n >= 0 ) document . write ( a + "▁" ) ; if ( n >= 1 ) document . write ( b + "▁" ) ; for ( let i = 2 ; i <= n ; i ++ ) { c = a + b ; document . write ( c + "▁" ) ; a = b ; b = c ; } }
function countDigits ( n ) { let count = 0 ; while ( n > 0 ) { count += 1 ; n = parseInt ( n / 10 , 10 ) ; } return count ; }
function findCount ( L , R ) { let count = 0 ; let countDigitsL = countDigits ( L ) ; let countDigitsR = countDigits ( R ) ; let firstDigitL = parseInt ( L / parseInt ( Math . pow ( 10 , countDigitsL - 1 ) , 10 ) , 10 ) ; let firstDigitR = parseInt ( R / parseInt ( Math . pow ( 10 , countDigitsR - 1 ) , 10 ) , 10 ) ; if ( countDigitsL < countDigitsR ) { count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) ; if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count += firstDigitR ; else count += ( firstDigitR - 1 ) ; } else { if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count -= ( 9 - firstDigitR ) ; else count -= ( 9 - firstDigitR + 1 ) ; } return count ; }
function score ( n , A , k ) { if ( memo [ n ] [ k ] > 0 ) return memo [ n ] [ k ] ; let sum = 0 ; for ( let i = n - 1 ; i > 0 ; i -- ) { sum += A [ i ] ; memo [ n ] [ k ] = Math . max ( memo [ n ] [ k ] , score ( i , A , k - 1 ) + sum / ( n - i ) ) ; } return memo [ n ] [ k ] ; }
function pre_compute ( a , n , index , k ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; else dp [ 0 ] [ i ] = a [ i ] ; } for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ index ] [ k ] ; }
function gen ( n ) { let S = new Array ( n + 1 ) ; S . fill ( 0 ) ; S [ 0 ] = 0 ; if ( n != 0 ) S [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) S [ i ] = 4 * S [ parseInt ( i / 2 , 10 ) ] ; else S [ i ] = 4 * S [ parseInt ( i / 2 , 10 ) ] + 1 ; } return S [ n ] ; }
function moserDeBruijn ( n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( gen ( i ) + "▁" ) ; }
function LCSubStr ( X , Y ) { var m = X . length ; var n = Y . length ; var result = 0 ; var len = Array . from ( Array ( 2 ) , ( ) => Array ( n ) ) ; var currRow = 0 ; for ( var i = 0 ; i <= m ; i ++ ) { for ( var j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) { len [ currRow ] [ j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { len [ currRow ] [ j ] = len [ 1 - currRow ] [ j - 1 ] + 1 ; result = Math . max ( result , len [ currRow ] [ j ] ) ; } else { len [ currRow ] [ j ] = 0 ; } } currRow = 1 - currRow ; } return result ; }
function isPartitionPoss ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; var set1 = [ ] ; var set2 = [ ] ; return findSets ( arr , n , set1 , set2 , 0 , 0 , 0 ) ; }
function func ( n , m , A ) { let ModArray = [ ] ; for ( let i = 0 ; i < n ; i ++ ) ModArray . push ( 0 ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { ModArray [ i ] = A [ i ] % m ; sum += ModArray [ i ] ; } sum = sum % m ; if ( sum % m == 0 ) { document . write ( "True" ) ; return ; } if ( sum % 2 != 0 ) { document . write ( "False" ) ; } else { ModArray . shift ( ) ; let i = 0 ; let j = ModArray . length - 1 ; ModArray . sort ( function ( a , b ) { return a - b } ) ; sum = parseInt ( sum / 2 , 10 ) ; let i1 , i2 ; while ( i <= j ) { let s = ModArray [ i ] + ModArray [ j ] ; if ( s == sum ) { i1 = i ; i2 = j ; document . write ( "True" ) ; break ; } else if ( s > sum ) j -- ; else i ++ ; } } }
function dfs1 ( v , u , parent ) { In [ u ] = 0 ; for ( let j = 0 ; j < v [ u ] . length ; j ++ ) { let child = v [ u ] [ j ] ; if ( child == parent ) continue ; dfs1 ( v , child , u ) ; In [ u ] = Math . max ( In [ u ] , 1 + In [ child ] ) ; } }
function dfs2 ( v , u , parent ) { let mx1 = - 1 , mx2 = - 1 ; for ( let j = 0 ; j < v [ u ] . length ; j ++ ) { let child = v [ u ] [ j ] ; if ( child == parent ) continue ; if ( In [ child ] >= mx1 ) { mx2 = mx1 ; mx1 = In [ child ] ; } else if ( In [ child ] > mx2 ) mx2 = In [ child ] ; } for ( let j = 0 ; j < v [ u ] . length ; j ++ ) { let child = v [ u ] [ j ] ; if ( child == parent ) continue ; let longest = mx1 ; if ( mx1 == In [ child ] ) longest = mx2 ; out [ child ] = 1 + Math . max ( out [ u ] , 1 + longest ) ; dfs2 ( v , child , u ) ; } }
function printGolomb ( n ) { for ( let i = 1 ; i <= n ; i ++ ) document . write ( findGolomb ( i ) + "▁" ) ; }
function dfs ( a , v , u , parent ) { dp [ u ] = a [ u - 1 ] ; var maximum = 0 ; for ( var child of v [ u ] ) { if ( child == parent ) continue ; dfs ( a , v , child , u ) ; maximum = Math . max ( maximum , dp [ child ] ) ; } dp [ u ] += maximum ; }
function maximumValue ( a , v ) { dfs ( a , v , 1 , 0 ) ; return dp [ 1 ] ; }
function countRemovals ( a , i , j , k ) { if ( i >= j ) return 0 ; else if ( ( a [ j ] - a [ i ] ) <= k ) return 0 ; else if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; else if ( ( a [ j ] - a [ i ] ) > k ) { dp [ i ] [ j ] = 1 + Math . min ( countRemovals ( a , i + 1 , j , k ) , countRemovals ( a , i , j - 1 , k ) ) ; } return dp [ i ] [ j ] ; }
function removals ( a , n , k ) { a . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < MAX ; i ++ ) { for ( let j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } if ( n == 1 ) return 0 ; else return countRemovals ( a , 0 , n - 1 , k ) ; }
function removals ( arr , n , k ) { var i , j , ans = n - 1 ; arr . sort ( ( a , b ) => a - b ) ; for ( i = 0 ; i < n ; i ++ ) { j = findInd ( arr [ i ] , i , n , k , arr ) ; if ( j != - 1 ) { ans = Math . min ( ans , n - ( j - i + 1 ) ) ; } } return ans ; }
function removals ( arr , n , k ) { arr . sort ( ( a , b ) => a - b ) ; var dp = Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) dp [ i ] = - 1 ; var ans = n - 1 ; dp [ 0 ] = 0 ; for ( var i = 1 ; i < n ; i ++ ) { dp [ i ] = i ; var j = dp [ i - 1 ] ; while ( j != i && arr [ i ] - arr [ j ] > k ) { j ++ ; } dp [ i ] = Math . min ( dp [ i ] , j ) ; ans = Math . min ( ans , ( n - ( i - j + 1 ) ) ) ; } return ans ; }
function maximumSegments ( n , a , b , c ) { let dp = [ ] ; for ( let i = 0 ; i < n + 10 ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
function postfix ( a , n ) { for ( let i = n - 1 ; i > 0 ; i -- ) { a [ i - 1 ] = a [ i - 1 ] + a [ i ] ; } }
function modify ( a , n ) { for ( let i = 1 ; i < n ; i ++ ) { a [ i - 1 ] = i * a [ i ] ; } }
function sequence ( n ) { let f = [ ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; document . write ( f [ 1 ] + "▁" + f [ 2 ] + "▁" ) ; for ( let i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; document . write ( f [ i ] + "▁" ) ; } }
function sum ( a , i , j ) { var ans = 0 ; for ( var m = i ; m <= j ; m ++ ) ans = ( ans + a [ m ] ) % 100 ; return ans ; }
function solve ( a , i , j ) { if ( i == j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; dp [ i ] [ j ] = 1000000000 ; for ( var k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) ; } return dp [ i ] [ j ] ; }
function initialize ( n ) { for ( var i = 0 ; i <= n ; i ++ ) for ( var j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = - 1 ; }
function reverseFibonacci ( n ) { let a = [ ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( let i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( let i = n - 1 ; i >= 0 ; i -- ) { document . write ( a [ i ] + "▁" ) ; } }
function longestSubsequenceCommonSegment ( k , s1 , s2 ) { var n = s1 . length ; var m = s2 . length ; var lcs = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; var cnt = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= m ; j ++ ) { lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( var a = k ; a <= cnt [ i ] [ j ] ; a ++ ) lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }
function arrangeBraces ( n , pos , k ) { let h = new Array ( N ) ; h . fill ( false ) ; let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < k ; i ++ ) { h [ pos [ i ] ] = true ; } dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= 2 * n ; i ++ ) { for ( let j = 0 ; j <= 2 * n ; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 0 ; } } else if ( j != 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } } } return dp [ 2 * n ] [ 0 ] ; }
function check ( s1 , s2 ) { let n = s1 . length ; let m = s2 . length ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = false ; } } dp [ 0 ] [ 0 ] = true ; for ( let i = 0 ; i < s1 . length ; i ++ ) { for ( let j = 0 ; j <= s2 . length ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( j < s2 . length && ( s1 [ i ] . toUpperCase ( ) == s2 [ j ] ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( ! ( s1 [ i ] == s1 [ i ] . toUpperCase ( ) ) ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }
function findLength ( str , n ) { let current_sum = 0 ; let max_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == "0" ? 1 : - 1 ) ; if ( current_sum < 0 ) { current_sum = 0 ; } max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }
function find_prob ( N , P ) { let dp = [ ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( let i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( dp [ N ] ) ; }
function maxSubArraySumRepeated ( a , n , k ) { let max_so_far = 0 ; let INT_MIN , max_ending_here = 0 ; for ( let i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
function chordCnt ( A ) { var n = 2 * A ; var dpArray = Array ( n + 1 ) . fill ( 0 ) ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( var i = 4 ; i <= n ; i += 2 ) { for ( var j = 0 ; j < i - 1 ; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } } return dpArray [ n ] ; }
function maximumSumSubarray ( arr , n ) { let min_prefix_sum = 0 ; let res = Number . MIN_VALUE ; let prefix_sum = [ ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }
function isPath ( arr ) { var dir = [ [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] ] ; var q = [ ] ; q . push ( [ 0 , 0 ] ) ; while ( q . length > 0 ) { var p = q [ 0 ] ; q . shift ( ) ; arr [ p [ 0 ] ] [ p [ 1 ] ] = - 1 ; if ( p == [ row - 1 ] [ col - 1 ] ) return true ; for ( var i = 0 ; i < 4 ; i ++ ) { var a = p [ 0 ] + dir [ i ] [ 0 ] ; var b = p [ 1 ] + dir [ i ] [ 1 ] ; if ( a >= 0 && b >= 0 && a < row && b < col && arr [ a ] [ b ] != - 1 ) { q . push ( [ a , b ] ) ; } } } return false ; }
function isPath ( arr ) { arr [ 0 ] [ 0 ] = 1 ; for ( var i = 1 ; i < 5 ; i ++ ) if ( arr [ i ] [ 0 ] != - 1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( var j = 1 ; j < 5 ; j ++ ) if ( arr [ 0 ] [ j ] != - 1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; for ( var i = 1 ; i < 5 ; i ++ ) for ( var j = 1 ; j < 5 ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ; }
function Jacobsthal ( n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; }
function Jacobsthal_Lucas ( n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = 2 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; }
function findStep ( n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }
function countWays ( n ) { let res = new Array ( n + 2 ) ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( let i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }
function countWays ( n ) { var a = 1 , b = 2 , c = 4 ; var d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( var i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; }
function sequence ( n ) { if ( n == 1 n == 2 ) return 1 ; else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; }
function sequence ( n ) { let i ; let f = [ ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( let i = 3 ; i <= n ; i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; return f [ n ] ; }
function choose ( n , k ) { if ( k > n ) { return 0 ; } if ( n <= 1 ) { return 1 ; } if ( k == 0 ) { return 1 ; } if ( nck [ n ] [ k ] != - 1 ) { return nck [ n ] [ k ] ; } let answer = choose ( n - 1 , k - 1 ) + choose ( n - 1 , k ) ; nck [ n ] [ k ] = answer ; return answer ; }
function getLeft ( n ) { if ( n == 1 ) { return 0 ; } let h = log2 [ n ] ; let last = n - ( ( 1 << h ) - 1 ) ; if ( last >= ( numh / 2 ) ) { } else { return ( 1 << h ) - 1 - ( ( numh / 2 ) - last ) ; } }
function numberOfHeaps ( n ) { if ( n <= 1 ) { return 1 ; } if ( dp [ n ] != - 1 ) { return dp [ n ] ; } let left = getLeft ( n ) ; let ans = ( choose ( n - 1 , left ) * numberOfHeaps ( left ) ) * ( numberOfHeaps ( n - 1 - left ) ) ; dp [ n ] = ans ; return ans ; }
function Hosoya ( n , m ) { if ( ( n == 0 && m == 0 ) || ( n == 1 && m == 0 ) || ( n == 1 && m == 1 ) || ( n == 2 && m == 1 ) ) return 1 ; if ( n > m ) return Hosoya ( n - 1 , m ) + Hosoya ( n - 2 , m ) ; else if ( m == n ) return Hosoya ( n - 1 , m - 1 ) + Hosoya ( n - 2 , m - 2 ) ; else return 0 ; }
function numberofways ( n , m ) { let dp = new Array ( n + 2 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( n + 2 ) ; for ( let j = 0 ; j < dp [ i ] . length ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ n + 1 ] = 1 ; for ( let k = n ; k >= m ; k -- ) { for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
function zigzag ( n , k ) { let dp = new Array ( n + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= Math . min ( i , k ) ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; } return dp [ n ] [ k ] ; }
function eulerian ( n , m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
function eulerian ( n , m ) { var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
function nswp ( n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
function binomialCoeff ( n , k ) { let C = new Array ( n + 1 ) ; for ( var i = 0 ; i < C . length ; i ++ ) { C [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
function longOddEvenIncSeq ( arr , n ) { let lioes = [ ] ; let maxLen = 0 ; for ( let i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }
function dealnnoy ( n , m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }
function dealnnoy ( n , m ) { var dp = Array . from ( Array ( m + 1 ) , ( ) => Array ( n + 1 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( var i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( var i = 1 ; i <= m ; i ++ ) for ( var j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
function longestAlternating ( arr , n ) { let count = new Array ( n ) ; count [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( count [ i ] + "▁" ) ; }
function maxDP ( n ) { let res = [ ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { res [ i ] = Math . max ( i , ( res [ Math . floor ( i / 2 ) ] + res [ Math . floor ( i / 3 ) ] + res [ Math . floor ( i / 4 ) ] + res [ Math . floor ( i / 5 ) ] ) ) ; } return res [ n ] ; }
function findlength ( arr , s , n , ind , st , dp ) { if ( ind >= n ) return 0 ; if ( dp [ ind ] [ st ] != - 1 ) return dp [ ind ] [ st ] ; if ( st == 0 ) return dp [ ind ] [ st ] = Math . max ( arr [ ind ] + findlength ( arr , s , n , ind + 1 , 1 , dp ) , findlength ( arr , s , n , ind + 1 , 0 , dp ) ) ; else return dp [ ind ] [ st ] = Math . max ( arr [ ind ] + findlength ( arr , s , n , ind + 1 , 1 , dp ) , 0 ) ; }
function maxLen ( s , n ) { if ( allones ( s , n ) ) return - 1 ; var arr = Array ( MAX ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) arr [ i ] = ( s [ i ] == "0" ? 1 : - 1 ) ; var dp = Array . from ( Array ( MAX ) , ( ) => Array ( 3 ) . fill ( - 1 ) ) ; return findlength ( arr , s , n , 0 , 0 , dp ) ; }
function countarray ( n , k , x ) { let dp = [ ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
function countPalindromes ( k , n , l , r ) { let ans = 0 ; if ( k == 1 ) { for ( let i = 0 ; i < MAX_CHAR ; i ++ ) ans += l [ i ] [ n - 1 ] ; return ans ; } if ( k == 2 ) { for ( let i = 0 ; i < MAX_CHAR ; i ++ ) ans += ( ( l [ i ] [ n - 1 ] * ( l [ i ] [ n - 1 ] - 1 ) ) / 2 ) ; return ans ; } for ( let i = 1 ; i < n - 1 ; i ++ ) for ( let j = 0 ; j < MAX_CHAR ; j ++ ) ans += l [ j ] [ i - 1 ] * r [ j ] [ i + 1 ] ; return ans ; }
function lcs ( X , Y , m , n ) { let L = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; ++ i ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) { L [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= m ; ++ i ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 2 * ( X [ i - 1 ] - "0" ) ; else L [ i ] [ j ] = L [ i - 1 ] [ j ] > L [ i ] [ j - 1 ] ? L [ i - 1 ] [ j ] : L [ i ] [ j - 1 ] ; } } return L [ m ] [ n ] ; }
function findMinCost ( X , Y ) { let m = X . length , n = Y . length ; let cost = 0 ; for ( let i = 0 ; i < m ; ++ i ) cost += X [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ; for ( let i = 0 ; i < n ; ++ i ) cost += Y [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ; return cost - lcs ( X , Y , m , n ) ; }
function isSubsetSum ( set , n , sum ) { let subset = new Array ( sum + 1 ) ; for ( var i = 0 ; i < subset . length ; i ++ ) { subset [ i ] = new Array ( 2 ) ; } let count = new Array ( sum + 1 ) ; for ( var i = 0 ; i < count . length ; i ++ ) { count [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i <= n ; i ++ ) { subset [ 0 ] [ i ] = true ; count [ 0 ] [ i ] = 0 ; } for ( let i = 1 ; i <= sum ; i ++ ) { subset [ i ] [ 0 ] = false ; count [ i ] [ 0 ] = - 1 ; } for ( let i = 1 ; i <= sum ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; count [ i ] [ j ] = count [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) { subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; if ( subset [ i ] [ j ] ) count [ i ] [ j ] = Math . max ( count [ i ] [ j - 1 ] , count [ i - set [ j - 1 ] ] [ j - 1 ] + 1 ) ; } } } return count [ sum ] [ n ] ; }
function answer ( n ) { let dp = new Array ( n + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } if ( n == 1 ) return 10 ; for ( let j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } let sum = 0 ; for ( let j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
function isSubSeqDivisible ( str ) { let i , j , k , l = str . length ; let arr = [ ] ; for ( i = 0 ; i < l ; i ++ ) arr [ i ] = str [ i ] - "0" ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
function maxLength ( s , n ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == "(" && s [ i + 1 ] == ")" ) dp [ i ] [ i + 1 ] = 2 ; for ( let l = 2 ; l < n ; l ++ ) { for ( let i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == "(" && s [ j ] == ")" ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( let k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }
function maxLength ( s , n ) { let invalidOpenBraces = 0 ; let invalidCloseBraces = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == "(" ) { invalidOpenBraces ++ ; } else { if ( invalidOpenBraces == 0 ) { invalidCloseBraces ++ ; } else { invalidOpenBraces -- ; } } } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; }
function numberOfWays ( x ) { let dp = Array ( x + 1 ) . fill ( 0 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
function dfs ( node , parent , tree , colour , answer ) { answer [ node ] = colour [ node ] ; for ( var u of tree [ node ] ) { if ( u == parent ) continue ; dfs ( u , node , tree , colour , answer ) ; answer [ node ] += Math . max ( answer [ u ] , 0 ) ; } }
function maxDiff ( tree , colour , N ) { var answer = Array ( N + 1 ) . fill ( 0 ) ; dfs ( 1 , 0 , tree , colour , answer ) ; var high = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { high = Math . max ( high , answer [ i ] ) ; answer [ i ] = 0 ; } for ( var i = 1 ; i <= N ; i ++ ) { if ( colour [ i ] == - 1 ) colour [ i ] = 1 ; else colour [ i ] = - 1 ; } dfs ( 1 , 0 , tree , colour , answer ) ; for ( var i = 1 ; i < N ; i ++ ) high = Math . max ( high , answer [ i ] ) ; return high ; }
function alternateSubarray ( arr , n ) { let len = new Array ( n ) ; len [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( let i = 0 ; i < n ; ++ i ) document . write ( len [ i ] + "▁" ) ; }
function alternateSubarray ( arr , n ) { let count = 1 ; let prev = arr [ 0 ] ; for ( let i = 1 ; i < n ; ++ i ) { if ( ( arr [ i ] ^ prev ) == false ) { while ( count > 0 ) { document . write ( count -- + "▁" ) ; } } ++ count ; prev = arr [ i ] ; } while ( count != 0 ) { document . write ( count -- + "▁" ) ; } }
function lcs ( dp , arr1 , n , arr2 , m , k ) { if ( k < 0 ) return - 10000000 ; if ( n < 0 m < 0 ) return 0 ; let ans = dp ; if ( ans != - 1 ) return ans ; try { ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; } catch ( e ) { } return ans ; }
function productSubSeqCount ( arr , k ) { let n = arr . length ; let dp = new Array ( k + 1 ) ; for ( let i = 0 ; i < k + 1 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= k ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( arr [ j - 1 ] <= i && arr [ j - 1 ] > 0 ) dp [ i ] [ j ] += dp [ parseInt ( i / arr [ j - 1 ] , 10 ) ] [ j - 1 ] + 1 ; } } return dp [ k ] [ n ] ; }
function waysToArrange ( N , K , k ) { let C = new Array ( N + 1 ) ; for ( let i = 0 ; i < C . length ; i ++ ) { C [ i ] = new Array ( 2 ) ; } let i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) { C [ i ] [ j ] = 1 ; } else { C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } } let dp = Array . from ( { length : K + 1 } , ( _ , i ) => 0 ) ; let count = 0 ; dp [ 0 ] = 1 ; for ( i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; }
function LIP ( dp , mat , n , m , x , y ) { if ( dp [ x ] [ y ] < 0 ) { let result = 0 ; if ( x == n - 1 && y == m - 1 ) return dp [ x ] [ y ] = 1 ; if ( x == n - 1 y == m - 1 ) result = 1 ; if ( x + 1 < n && mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ; if ( y + 1 < m && mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) result = Math . max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x ] [ y ] = result ; } return dp [ x ] [ y ] ; }
function wrapper ( mat , n , m ) { let dp = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { dp [ i ] = new Array ( 10 ) ; for ( let j = 0 ; j < 10 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return LIP ( dp , mat , n , m , 0 , 0 ) ; }
function minCells ( mat , m , n ) { let dp = new Array ( m ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < m ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = Number . MAX_VALUE ; dp [ 0 ] [ 0 ] = 1 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != Number . MAX_VALUE && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != Number . MAX_VALUE && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != Number . MAX_VALUE ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }
function GetCeilIndex ( arr , T , l , r , key ) { while ( r - l > 1 ) { let m = l + Math . floor ( ( r - l ) / 2 ) ; if ( arr [ T [ m ] ] >= key ) r = m ; else l = m ; } return r ; }
function LIS ( arr , n ) { let tailIndices = new Array ( n ) ; let prevIndices = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { tailIndices [ i ] = 0 ; prevIndices [ i ] = - 1 ; } let len = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ tailIndices [ 0 ] ] ) tailIndices [ 0 ] = i ; else if ( arr [ i ] > arr [ tailIndices [ len - 1 ] ] ) { prevIndices [ i ] = tailIndices [ len - 1 ] ; tailIndices [ len ++ ] = i ; } else { let pos = GetCeilIndex ( arr , tailIndices , - 1 , len - 1 , arr [ i ] ) ; prevIndices [ i ] = tailIndices [ pos - 1 ] ; tailIndices [ pos ] = i ; } } for ( let i = tailIndices [ len - 1 ] ; i >= 0 ; i = prevIndices [ i ] ) res . push ( arr [ i ] ) ; }
function longestBitonic ( arr1 , n1 , arr2 , n2 ) { LIS ( arr1 , n1 ) ; res . reverse ( ) ; arr2 . reverse ( ) ; LIS ( arr2 , n2 ) ; for ( let i = 0 ; i < res . length ; i ++ ) document . write ( res [ i ] + "▁" ) ; }
function ElementsCalculationFunc ( pre , maxx , x , k , n ) { for ( let i = 0 , j = x ; j <= n ; j ++ , i ++ ) { if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; }
function solve ( dp , a , low , high , turn ) { if ( low == high ) { return Math . floor ( a [ low ] * turn ) ; } if ( dp [ low ] [ high ] != 0 ) { return dp [ low ] [ high ] ; } dp [ low ] [ high ] = Math . max ( Math . floor ( a [ low ] * turn ) + solve ( dp , a , low + 1 , high , turn + 1 ) , Math . floor ( a [ high ] * turn ) + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ] ; }
function cal ( ones , x , y , k ) { return ones [ x + k - 1 ] [ y + k - 1 ] - ones [ x - 1 ] [ y + k - 1 ] - ones [ x + k - 1 ] [ y - 1 ] + ones [ x - 1 ] [ y - 1 ] ; }
function sol ( mat ) { let ans = 0 ; let val = 0 ; let ones = new Array ( R + 1 ) ; for ( var i = 0 ; i < ones . length ; i ++ ) { ones [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < ones . length ; i ++ ) { for ( var j = 0 ; j < ones . length ; j ++ ) { ones [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= R ; i ++ ) for ( let j = 1 ; j <= C ; j ++ ) { if ( mat [ i - 1 ] [ j - 1 ] == 1 ) val = 1 ; ones [ i ] [ j ] = ones [ i - 1 ] [ j ] + ones [ i ] [ j - 1 ] - ones [ i - 1 ] [ j - 1 ] + ( val ) ; } for ( let k = 1 ; k <= Math . min ( R , C ) ; k ++ ) for ( let i = 1 ; i + k - 1 <= R ; i ++ ) for ( let j = 1 ; j + k - 1 <= C ; j ++ ) ans = Math . max ( ans , ( ones [ R ] [ C ] + k * k - 2 * cal ( ones , i , j , k ) ) ) ; return ans ; }
function maxSumBitonicSubArr ( arr , n ) { let msis = new Array ( n ) ; msis . fill ( 0 ) ; let msds = new Array ( n ) ; msds . fill ( 0 ) ; let max_sum = Number . MIN_VALUE ; msis [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; }
function maxSumBitonicSubArr ( arr , n ) { let max_sum = - 1000000 ; let i = 0 ; while ( i < n ) { let j = i ; while ( j + 1 < n && arr [ j ] < arr [ j + 1 ] ) j ++ ; while ( i < j && arr [ i ] <= 0 ) i ++ ; let k = j ; while ( k + 1 < n && arr [ k ] > arr [ k + 1 ] ) k ++ ; let last = k ; while ( k > j && arr [ k ] <= 0 ) k -- ; let sum_inc = find_partial_sum ( arr , i , j + 1 ) ; let sum_dec = find_partial_sum ( arr , j , k + 1 ) ; let sum_all = sum_inc + sum_dec - arr [ j ] ; max_sum = Math . max ( Math . max ( max_sum , sum_inc ) , Math . max ( sum_dec , sum_all ) ) ; i = Math . max ( last , i + 1 ) ; } return max_sum ; }
function countWays ( n ) { let dp = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; } dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
function countways ( n ) { let A = new Array ( n + 1 ) . fill ( 0 ) ; A [ 0 ] = 1 ; A [ 1 ] = 3 ; A [ 2 ] = 7 ; for ( let i = 2 ; i <= n ; i ++ ) { A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] ; } return A [ n ] ; }
function findWinner ( x , y , n ) { var dp = Array ( n + 1 ) . fill ( 0 ) ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( var i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && ! dp [ i - 1 ] ) dp [ i ] = true ; else if ( i - x >= 0 && ! dp [ i - x ] ) dp [ i ] = true ; else if ( i - y >= 0 && ! dp [ i - y ] ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }
function printSuperSeq ( a , b ) { let m = a . length , n = b . length ; let dp = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) dp [ i ] = new Array ( n + 1 ) ; for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } let res = "" ; let i = m , j = n ; while ( i > 0 && j > 0 ) { if ( a [ i - 1 ] == b [ j - 1 ] ) { res = a [ i - 1 ] + res ; i -- ; j -- ; } else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) { res = a [ i - 1 ] + res ; i -- ; } else { res = b [ j - 1 ] + res ; j -- ; } } while ( i > 0 ) { res = a [ i - 1 ] + res ; i -- ; } while ( j > 0 ) { res = b [ j - 1 ] + res ; j -- ; } document . write ( res ) ; }
function maxGameByWinner ( N ) { let dp = new Array ( N ) . fill ( 0 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; let i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
function isSubsetSum ( arr , n , sum ) { let subset = new Array ( 2 ) ; for ( var i = 0 ; i < subset . length ; i ++ ) { subset [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }
function countTransformation ( a , b ) { var n = a . length , m = b . length ; if ( m == 0 ) { return 1 ; } var dp = new Array ( m , n ) ; for ( var i = 0 ; i < m ; i ++ ) { for ( var j = i ; j < n ; j ++ ) { if ( i == 1 ) { if ( j == 1 ) { dp [ i , j ] = ( a [ j ] == b [ i ] ) ? 1 : 0 ; } else if ( a [ j ] == b [ i ] ) { dp [ i , j ] = dp [ i , j - 1 ] + 1 ; } else { dp [ i , j ] = dp [ i , j - 1 ] ; } } else if ( a [ j ] == b [ j ] ) { dp [ i , j ] = dp [ i , j - 1 ] + dp [ i - 1 , j - 1 ] ; } else { dp [ i , j ] = dp [ i , j - 1 ] ; } } } return dp [ m - 1 , n - 1 ] ; }
function getSpecialNumber ( N ) { return ans ( -- N ) ; }
function minimumSquare ( m , n ) { let vertical_min = Number . MAX_VALUE ; let horizontal_min = Number . MAX_VALUE ; if ( n == 13 && m == 11 ) return 6 ; if ( m == 13 && n == 11 ) return 6 ; if ( m == n ) return 1 ; if ( dp [ m ] [ n ] != 0 ) return dp [ m ] [ n ] ; for ( let i = 1 ; i <= parseInt ( m / 2 , 10 ) ; i ++ ) { horizontal_min = Math . min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) ; } for ( let j = 1 ; j <= parseInt ( n / 2 , 10 ) ; j ++ ) { vertical_min = Math . min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) ; } dp [ m ] [ n ] = Math . min ( vertical_min , horizontal_min ) ; return dp [ m ] [ n ] ; }
function fact ( n ) { var res = 1 ; for ( var i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
function nCr ( n , r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
function countWays ( n , k ) { let total = k ; let mod = 1000000007 ; let same = 0 , diff = k ; for ( let i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }
function computeLIS ( circBuff , start , end , n ) { let LIS = new Array ( n + end - start ) ; for ( let i = start ; i < end ; i ++ ) LIS [ i ] = 1 ; for ( let i = start + 1 ; i < end ; i ++ ) for ( let j = start ; j < i ; j ++ ) if ( circBuff [ i ] > circBuff [ j ] && LIS [ i ] < LIS [ j ] + 1 ) LIS [ i ] = LIS [ j ] + 1 ; let res = Number . MIN_VALUE ; for ( let i = start ; i < end ; i ++ ) res = Math . max ( res , LIS [ i ] ) ; return res ; }
function LICS ( arr , n ) { let circBuff = new Array ( 2 * n ) ; for ( let i = 0 ; i < n ; i ++ ) circBuff [ i ] = arr [ i ] ; for ( let i = n ; i < 2 * n ; i ++ ) circBuff [ i ] = arr [ i - n ] ; let res = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) res = Math . max ( computeLIS ( circBuff , i , i + n , n ) , res ) ; return res ; }
function countBT ( h ) { let dp = new Array ( h + 1 ) ; dp . fill ( 0 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; }
function minTimeForWritingChars ( N , insert , remove , copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) dp [ i ] = 0 ; dp [ 1 ] = insert ; for ( let i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ parseInt ( i / 2 , 10 ) ] + copy ) ; else dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ parseInt ( ( i + 1 ) / 2 , 10 ) ] + copy + remove ) ; } return dp [ N ] ; }
function countPaths ( n , m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }
function countPaths ( n , m ) { var dp = Array ( n + 1 ) . fill ( 0 ) . map ( x => Array ( m + 1 ) . fill ( 0 ) ) ; for ( i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( i = 1 ; i <= n ; i ++ ) for ( j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }
function binomialCoeff ( n , k ) { var C = Array ( k + 1 ) . fill ( 0 ) ; C [ 0 ] = 1 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
function sumOfSubstrings ( num ) { let sum = 0 ; let mf = 1 ; for ( let i = num . length - 1 ; i >= 0 ; i -- ) { sum += ( num [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; }
function countWays ( n , m ) { let count = new Array ( n + 1 ) ; count [ 0 ] = 0 ; let i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m i == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
function maxSum ( grid , n ) { let incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; let excl = 0 , excl_new ; for ( let i = 1 ; i < n ; i ++ ) { excl_new = Math . max ( excl , incl ) ; incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return Math . max ( excl , incl ) ; }
function maxSumWithK ( a , n , k ) { let maxSum = new Array ( n ) ; maxSum [ 0 ] = a [ 0 ] ; let curr_max = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; maxSum [ i ] = curr_max ; } let sum = 0 ; for ( let i = 0 ; i < k ; i ++ ) sum += a [ i ] ; let result = sum ; for ( let i = k ; i < n ; i ++ ) { sum = sum + a [ i ] - a [ i - k ] ; result = Math . max ( result , sum ) ; result = Math . max ( result , sum + maxSum [ i - k ] ) ; } return result ; }
function getTotalNumberOfSequences ( m , n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
function getTotalNumberOfSequences ( m , n ) { let T = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { T [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ parseInt ( i / 2 , 10 ) ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }
function minInsertionStepToSortArray ( arr , N ) { let lis = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { lis [ i ] = 1 ; } for ( let i = 1 ; i < N ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) { lis [ i ] = lis [ j ] + 1 ; } } } let max = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( max < lis [ i ] ) { max = lis [ i ] ; } } return ( N - max ) ; }
function printDistinct ( str ) { let count = new Array ( NO_OF_CHARS ) ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) { count [ i ] = 0 ; } let i ; for ( i = 0 ; i < str . length ; i ++ ) if ( str [ i ] != "▁" ) count [ str [ i ] . charCodeAt ( 0 ) ] ++ ; let n = i ; for ( i = 0 ; i < n ; i ++ ) if ( count [ str [ i ] . charCodeAt ( 0 ) ] == 1 ) document . write ( str [ i ] ) ; }
function lcs ( str1 , str2 , m , n ) { let L = new Array ( m + 1 ) ; let i , j ; for ( i = 0 ; i <= m ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( j = 0 ; j <= n ; j ++ ) { L [ i ] [ j ] = 0 ; } } for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; }
function countWaysToJump ( arr , n ) { let count_jump = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { count_jump [ i ] = 0 ; } for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( let j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( count_jump [ i ] + "▁" ) ; }
function lis ( arr , n ) { let result = 0 ; let lis = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( result < lis [ i ] ) result = lis [ i ] ; return result ; }
function minStepToDeleteString ( str ) { let N = str . length ; let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i <= N ; i ++ ) { dp [ i ] = new Array ( N + 1 ) ; for ( let j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; } for ( let len = 1 ; len <= N ; len ++ ) { for ( let i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str [ i ] == str [ i + 1 ] ) dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( let K = i + 2 ; K <= j ; K ++ ) if ( str [ i ] == str [ K ] ) dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; }
function solve ( i , par , a , n , k , current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . min ( ans , current_ans ) ; return ; } for ( let j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
function minCost ( a , n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; } dp [ 0 ] [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= k ; j ++ ) for ( let m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; }
function getMinSteps ( n ) { let table = new Array ( n + 1 ) ; table . fill ( 0 ) ; table [ 1 ] = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( ! ( i % 2 ) && ( i % 3 ) ) table [ i ] = 1 + Math . min ( table [ i - 1 ] , table [ i / 2 ] ) ; else if ( ! ( i % 3 ) && ( i % 2 ) ) table [ i ] = 1 + Math . min ( table [ i - 1 ] , table [ i / 3 ] ) ; else if ( ! ( i % 2 ) && ! ( i % 3 ) ) table [ i ] = 1 + Math . min ( table [ i - 1 ] , Math . min ( table [ i / 2 ] , table [ i / 3 ] ) ) ; else table [ i ] = 1 + table [ i - 1 ] ; } return table [ n ] + 1 ; }
function minimumNumberOfDeletions ( str ) { let n = str . length ; let len = lps ( str ) ; return ( n - len ) ; }
function utility_fun_for_del ( str , i , j ) { if ( i >= j ) return 0 ; if ( str [ i ] == str [ j ] ) { return utility_fun_for_del ( str , i + 1 , j - 1 ) ; } return 1 + Math . min ( utility_fun_for_del ( str , i + 1 , j ) , utility_fun_for_del ( str , i , j - 1 ) ) ; }
function min_ele_del ( str ) { return utility_fun_for_del ( str , 0 , str . length - 1 ) ; }
function numofArray ( n , m ) { let dp = new Array ( MAX ) ; let di = new Array ( MAX ) ; let mu = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { dp [ i ] = new Array ( MAX ) ; for ( let j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < MAX ; i ++ ) { di [ i ] = [ ] ; mu [ i ] = [ ] ; } for ( let i = 1 ; i <= m ; i ++ ) { for ( let j = 2 * i ; j <= m ; j += i ) { di [ j ] . push ( i ) ; mu [ i ] . push ( j ) ; } di [ i ] . push ( i ) ; } for ( let i = 1 ; i <= m ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( let x = 0 ; x < di [ j ] . length ; x ++ ) dp [ i ] [ j ] += dp [ i - 1 ] [ di [ j ] [ x ] ] ; for ( let x = 0 ; x < mu [ j ] . length ; x ++ ) dp [ i ] [ j ] += dp [ i - 1 ] [ mu [ j ] [ x ] ] ; } } let ans = 0 ; for ( let i = 1 ; i <= m ; i ++ ) { ans += dp [ n ] [ i ] ; di [ i ] = [ ] ; mu [ i ] = [ ] ; } return ans ; }
function offeringNumber ( n , templeHeight ) { for ( let i = 0 ; i < n ; ++ i ) { let left = 0 , right = 0 ; for ( let j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; } for ( let j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; } sum += Math . max ( right , left ) + 1 ; } return sum ; }
function stringReduction ( str ) { var n = str . length ; var count = Array . from ( { length : 3 } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; ++ i ) { count [ str . charAt ( i ) . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } if ( count [ 0 ] == n count [ 1 ] == n count [ 2 ] == n ) { return n ; } if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) { return 2 ; } return 1 ; }
function modularSum ( arr , n , m ) { if ( n > m ) return true ; let DP = new Array ( m ) ; for ( let l = 0 ; l < m ; l ++ ) DP [ l ] = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; let temp = new Array ( m ) ; for ( let l = 0 ; l < m ; l ++ ) temp [ l ] = false ; for ( let j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( let j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
function maxSum ( tri , n ) { if ( n > 1 ) tri [ 1 ] [ 1 ] = tri [ 1 ] [ 1 ] + tri [ 0 ] [ 0 ] ; tri [ 1 ] [ 0 ] = tri [ 1 ] [ 0 ] + tri [ 0 ] [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) { tri [ i ] [ 0 ] = tri [ i ] [ 0 ] + tri [ i - 1 ] [ 0 ] ; tri [ i ] [ i ] = tri [ i ] [ i ] + tri [ i - 1 ] [ i - 1 ] ; for ( let j = 1 ; j < i ; j ++ ) { if ( tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] >= tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ) tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] ; else tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ; } } let max = tri [ n - 1 ] [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( max < tri [ n - 1 ] [ i ] ) max = tri [ n - 1 ] [ i ] ; } return max ; }
function largestZigZagSumRec ( mat , i , j , n ) { if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( i == n - 1 ) return ( dp [ i ] [ j ] = mat [ i ] [ j ] ) ; let zzs = 0 ; for ( let k = 0 ; k < n ; k ++ ) if ( k != j ) zzs = Math . max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) ; return ( dp [ i ] [ j ] = ( zzs + mat [ i ] [ j ] ) ) ; }
function largestZigZag ( mat , n ) { for ( let i = 0 ; i < MAX ; i ++ ) { dp [ i ] = new Array ( MAX ) ; for ( let k = 0 ; k < MAX ; k ++ ) dp [ i ] [ k ] = - 1 ; } let res = 0 ; for ( let j = 0 ; j < n ; j ++ ) res = Math . max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) ; return res ; }
function countEndless ( input , n ) { let row = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { row [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { row [ i ] [ j ] = false ; } } let col = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { col [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { col [ i ] [ j ] = false ; } } for ( let j = 0 ; j < n ; j ++ ) { let isEndless = true ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; col [ i ] [ j ] = isEndless ; } } for ( let i = 0 ; i < n ; i ++ ) { let isEndless = true ; for ( let j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; row [ i ] [ j ] = isEndless ; } } let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 1 ; j < n ; j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; return ans ; }
function countSubsequences ( s ) { let aCount = 0 ; let bCount = 0 ; let cCount = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == "a" ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == "b" ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == "c" ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
function maximumDifferenceSum ( arr , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( let i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
function countStr ( n , bCount , cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; let res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
function maxRevenue ( m , x , revenue , n , t ) { let maxRev = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) maxRev [ i ] = 0 ; let nxtbb = 0 ; for ( let i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }
function getMaxGold ( gold , m , n ) { let goldTable = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { goldTable [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { goldTable [ i ] [ j ] = 0 ; } } for ( let col = n - 1 ; col >= 0 ; col -- ) { for ( let row = 0 ; row < m ; row ++ ) { let right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; let right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; let right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } } let res = goldTable [ 0 ] [ 0 ] ; for ( let i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }
function largestKSubmatrix ( a ) { let dp = new Array ( Row ) ; for ( let i = 0 ; i < Row ; i ++ ) { dp [ i ] = new Array ( Col ) ; for ( let j = 0 ; j < Col ; j ++ ) { dp [ i ] [ j ] = 0 ; } } let result = 0 ; for ( let i = 0 ; i < Row ; i ++ ) { for ( let j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } } return result ; }
function countDivisibleSubseq ( str , n ) { let len = str . length ; let dp = new Array ( len ) ; for ( let i = 0 ; i < len ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ ( str [ 0 ] - "0" ) % n ] ++ ; for ( let i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str [ i ] - "0" ) % n ] ++ ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str [ i ] - "0" ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }
function MaximumPath ( Mat ) { let result = 0 ; let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N + 2 ) ; for ( let j = 0 ; j < N + 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( let i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }
function probability ( k , n ) { let ans = 0 , i ; for ( i = k ; i <= n ; ++ i ) ans += fact [ n ] / ( fact [ i ] * fact [ n - i ] ) ; ans = ans / ( 1 << n ) ; return ans ; }
function precompute ( ) { fact [ 0 ] = fact [ 1 ] = 1 ; for ( let i = 2 ; i < 20 ; ++ i ) fact [ i ] = fact [ i - 1 ] * i ; }
function probability ( k , n ) { var ans = 0.0 ; for ( let i = k ; i <= n ; ++ i ) { var res = dp [ n ] - dp [ i ] - dp [ n - i ] - n ; ans += Math . pow ( 2.0 , res ) ; } return ans ; }
function precompute ( ) { for ( let i = 2 ; i < MAX ; ++ i ) dp [ i ] = ( Math . log ( i ) / Math . log ( 2 ) ) + dp [ i - 1 ] ; }
function countStrings ( n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = new Array ( 2 ) ; for ( let l = 0 ; l < 2 ; l ++ ) { dp [ i ] [ j ] [ l ] = 0 ; } } } dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
function canVote ( a , n , x ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( x + 1 ) ; for ( let j = 0 ; j < x + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= x ; j ++ ) if ( a [ i ] <= j ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , a [ i ] + dp [ i - 1 ] [ j - a [ i ] ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; return ( sum - dp [ n ] [ x ] <= x ) ; }
function countFriendsPairings ( n ) { let dp = [ ] ; for ( let i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
function countFriendsPairings ( n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }
function countFriendsPairings ( n ) { let a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) { return n ; } for ( let i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; }
function maxPathSum ( tri , m , n ) { for ( let i = m - 1 ; i >= 0 ; i -- ) { for ( let j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }
function findMaxPoints ( A ) { let P1S = new Array ( M + 2 ) ; let P1E = new Array ( M + 2 ) ; let P2S = new Array ( M + 2 ) ; let P2E = new Array ( M + 2 ) ; for ( let i = 0 ; i < M + 2 ; i ++ ) { P1S [ i ] = new Array ( N + 2 ) ; P1E [ i ] = new Array ( N + 2 ) ; P2S [ i ] = new Array ( N + 2 ) ; P2E [ i ] = new Array ( N + 2 ) ; for ( let j = 0 ; j < N + 2 ; j ++ ) { P1S [ i ] [ j ] = 0 ; P1E [ i ] [ j ] = 0 ; P2S [ i ] [ j ] = 0 ; P2E [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= N ; i ++ ) for ( let j = 1 ; j <= M ; j ++ ) P1S [ i ] [ j ] = Math . max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( let i = N ; i >= 1 ; i -- ) for ( let j = M ; j >= 1 ; j -- ) P1E [ i ] [ j ] = Math . max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( let i = N ; i >= 1 ; i -- ) for ( let j = 1 ; j <= M ; j ++ ) P2S [ i ] [ j ] = Math . max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( let i = 1 ; i <= N ; i ++ ) for ( let j = M ; j >= 1 ; j -- ) P2E [ i ] [ j ] = Math . max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; let ans = 0 ; for ( let i = 2 ; i < N ; i ++ ) { for ( let j = 2 ; j < M ; j ++ ) { let op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] ; let op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ; ans = Math . max ( ans , Math . max ( op1 , op2 ) ) ; } } return ans ; }
function inside ( x , y ) { return ( x >= 0 && x < N && y >= 0 && y < N ) ; }
function findProb ( start_x , start_y , steps ) { let dp1 = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp1 [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { dp1 [ i ] [ j ] = new Array ( steps + 1 ) ; for ( let k = 0 ; k < steps + 1 ; k ++ ) { dp1 [ i ] [ j ] [ k ] = 0 ; } } } for ( let i = 0 ; i < N ; ++ i ) for ( let j = 0 ; j < N ; ++ j ) dp1 [ i ] [ j ] [ 0 ] = 1 ; for ( let s = 1 ; s <= steps ; ++ s ) { for ( let x = 0 ; x < N ; ++ x ) { for ( let y = 0 ; y < N ; ++ y ) { let prob = 0.0 ; for ( let i = 0 ; i < 8 ; ++ i ) { let nx = x + dx [ i ] ; let ny = y + dy [ i ] ; if ( inside ( nx , ny ) ) prob += dp1 [ nx ] [ ny ] [ s - 1 ] / 8.0 ; } dp1 [ x ] [ y ] [ s ] = prob ; } } } return dp1 [ start_x ] [ start_y ] [ steps ] ; }
function lcsOf3 ( X , Y , Z , m , n , o ) { let L = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { L [ i ] [ j ] = new Array ( o + 1 ) ; for ( let k = 0 ; k < o + 1 ; k ++ ) { L [ i ] [ j ] [ k ] = 0 ; } } } for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { for ( let k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
function lcsOf3 ( i , j , k ) { if ( i == - 1 j == - 1 k == - 1 ) { return 0 ; } if ( dp [ i ] [ j ] [ k ] != - 1 ) { return dp [ i ] [ j ] [ k ] ; } if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) { return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; } else { return dp [ i ] [ j ] [ k ] = Math . max ( Math . max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; } }
function distSumRec ( arr , n , sum , currindex , s ) { if ( currindex > n ) return ; if ( currindex == n ) { s . add ( sum ) ; return ; } distSumRec ( arr , n , sum + arr [ currindex ] , currindex + 1 , s ) ; distSumRec ( arr , n , sum , currindex + 1 , s ) ; }
function printDistSum ( arr , n ) { let s = new Set ( ) ; distSumRec ( arr , n , 0 , 0 , s ) ; let s1 = [ ... s ] s1 . sort ( function ( a , b ) { return a - b ; } )  for ( let [ key , value ] of s1 . entries ( ) ) document . write ( value + "▁" ) ; }
function printDistSum ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( sum + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( var i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( var j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( var j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) document . write ( j + "▁" ) ; }
function printMaxSum ( arr , n ) { let dp = new Array ( n ) ; dp . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; let maxi = 0 ; for ( let j = 1 ; j <= Math . sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ parseInt ( ( i + 1 ) / j , 10 ) - 1 ] > maxi && j != 1 ) maxi = dp [ parseInt ( ( i + 1 ) / j , 10 ) - 1 ] ; } } dp [ i ] += maxi ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( dp [ i ] + "▁" ) ; }
function countPaths ( maze ) { if ( maze [ 0 ] [ 0 ] == - 1 ) return 0 ; for ( let i = 0 ; i < R ; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) maze [ i ] [ 0 ] = 1 ; else break ; } for ( let i = 1 ; i < C ; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) maze [ 0 ] [ i ] = 1 ; else break ; } for ( let i = 1 ; i < R ; i ++ ) { for ( let j = 1 ; j < C ; j ++ ) { if ( maze [ i ] [ j ] == - 1 ) continue ; if ( maze [ i - 1 ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } return ( maze [ R - 1 ] [ C - 1 ] > 0 ) ? maze [ R - 1 ] [ C - 1 ] : 0 ; }
function minSum ( arr , n ) { let dp = [ ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return Math . min ( arr [ 0 ] , Math . min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return Math . min ( Math . min ( arr [ 0 ] , arr [ 1 ] ) , Math . min ( arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( let i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; }
function minSum ( ar , n ) { if ( n <= 4 ) return Math . min . apply ( Math , ar ) ; var i ; var sum = Array ( n ) . fill ( n ) ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( i = 4 ; i < n ; i ++ ) { var temp = [ ] ; var it ; for ( it = i - 4 ; it < i ; it ++ ) temp . push ( sum [ it ] ) ; sum [ i ] = ar [ i ] + Math . min . apply ( Math , temp ) ; } var temp1 = [ ] ; for ( i = n - 4 ; i < n ; i ++ ) temp1 . push ( sum [ i ] ) ; return Math . min . apply ( Math , temp1 ) ; }
function printMinAndMaxValueOfExp ( exp ) { let num = [ ] ; let opr = [ ] ; let tmp = "" ; for ( let i = 0 ; i < exp . length ; i ++ ) { if ( isOperator ( exp [ i ] ) ) { opr . push ( exp [ i ] ) ; num . push ( parseInt ( tmp ) ) ; tmp = "" ; } else { tmp += exp [ i ] ; } } num . push ( parseInt ( tmp ) ) ; let len = num . length ; let minVal = new Array ( len ) ; let maxVal = new Array ( len ) ; for ( let i = 0 ; i < len ; i ++ ) { minVal [ i ] = new Array ( len ) ; maxVal [ i ] = new Array ( len ) ; for ( let j = 0 ; j < len ; j ++ ) { minVal [ i ] [ j ] = Number . MAX_VALUE ; maxVal [ i ] [ j ] = 0 ; if ( i == j ) minVal [ i ] [ j ] = maxVal [ i ] [ j ] = num [ i ] ; } } for ( let L = 2 ; L <= len ; L ++ ) { for ( let i = 0 ; i < len - L + 1 ; i ++ ) { let j = i + L - 1 ; for ( let k = i ; k < j ; k ++ ) { let minTmp = 0 , maxTmp = 0 ; if ( opr [ k ] == "+" ) { minTmp = minVal [ i ] [ k ] + minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] + maxVal [ k + 1 ] [ j ] ; } else if ( opr [ k ] == "*" ) { minTmp = minVal [ i ] [ k ] * minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] ; } if ( minTmp < minVal [ i ] [ j ] ) minVal [ i ] [ j ] = minTmp ; if ( maxTmp > maxVal [ i ] [ j ] ) maxVal [ i ] [ j ] = maxTmp ; } } } document . write ( "Minimum▁value▁:▁" + minVal [ 0 ] [ len - 1 ] + ",▁Maximum▁value▁:▁" + maxVal [ 0 ] [ len - 1 ] ) ; }
function maxDecimalValue ( mat , i , j , p ) { if ( i >= N j >= N ) { return 0 ; } let result = Math . max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) { return ( Math . pow ( 2 , p ) + result ) ; } else { return result ; } }
function MaximumDecimalValue ( mat , n ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } if ( mat [ 0 ] [ 0 ] == 1 ) { } for ( let i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + Math . pow ( 2 , i ) ; } else { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } } for ( let i = 1 ; i < n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) { dp [ i ] [ 0 ] = Math . floor ( dp [ i - 1 ] [ 0 ] + Math . pow ( 2 , i ) ) ; } else { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } } for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { dp [ i ] [ j ] = Math . floor ( Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + Math . pow ( 2 , i + j ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } } return dp [ n - 1 ] [ n - 1 ] ; }
function longestSubseqWithDiffOne ( arr , n ) { let dp = [ ] ; for ( let i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
function nCr ( n , k ) { let C = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { C [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j <= k ; j ++ ) { C [ i ] [ j ] = 0 ; } } let i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
function resultOfAllSubsets ( arr , N ) { let result = 0.0 ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; for ( let n = 1 ; n <= N ; n ++ ) result += ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n ; return result ; }
function maxSumWO3Consec ( arr , n ) { let sum = [ ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( let i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
function maxSumWO3Consec ( n ) { if ( sum [ n ] != - 1 ) { return sum [ n ] ; } if ( n == 0 ) { return sum [ n ] = 0 ; } if ( n == 1 ) { return sum [ n ] = arr [ 0 ] ; } if ( n == 2 ) { return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; } return sum [ n ] = 500 + Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
function maxAlternateSum ( arr , n ) { if ( n == 1 ) return arr [ 0 ] ; int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( min > arr [ i ] ) min = arr [ i ] ; } if ( min == arr [ 0 ] ) { return arr [ 0 ] ; } let dec = new Array ( n ) ; dec . fill ( 0 ) ; let inc = new Array ( n ) ; inc . fill ( 0 ) ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; let flag = 0 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } let result = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } return result ; }
function maxSumPairWithDifferenceLessThanK ( arr , N , K ) { arr . sort ( ) ; let dp = [ ] ; dp [ 0 ] = 0 ; for ( let i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }
function printInorder ( node ) { if ( node == null ) return ; printInorder ( node . left ) ; document . write ( node . val + "▁" ) ; printInorder ( node . right ) ; }
function lucas ( n ) { let a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; }
function maxAverageOfPath ( cost , N ) { let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) { dp [ i ] = new Array ( N + 1 ) ; for ( let j = 0 ; j < N + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( let j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
function breakSum ( n ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < dp ; i ++ ) { dp [ i ] = 0 ; } dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ Math . floor ( i / 2 ) ] + dp [ Math . floor ( i / 3 ) ] + dp [ Math . floor ( i / 4 ) ] , i ) ; return dp [ n ] ; }
function countPS ( str ) { let N = str . length ; let cps = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { cps [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { cps [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( let L = 2 ; L <= N ; L ++ ) { for ( let i = 0 ; i <= N - L ; i ++ ) { let k = L + i - 1 ; if ( str [ i ] == str [ k ] ) { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; } else { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } } return cps [ 0 ] [ N - 1 ] ; }
function countPS ( i , j ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( i == j ) return dp [ i ] [ j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
function lcs ( str1 , str2 , len1 , len2 , i , j ) { let ret = dp [ i ] [ j ] ; if ( i == len1 j == len2 ) return ret = 0 ; if ( ret != - 1 ) return ret ; ret = 0 ; if ( str1 [ i ] == str2 [ j ] ) ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) ; else ret = Math . max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) ; return ret ; }
function prinlAllLCSSorted ( str1 , str2 ) { let len1 = str1 . length , len2 = str2 . length ; for ( let i = 0 ; i < MAX ; i ++ ) { dp [ i ] = new Array ( MAX ) ; for ( let j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) ; let data = new Array ( MAX ) ; printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) ; }
function maxCost ( mat , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; let result = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
function numberOfPermWithKInversion ( N , K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; let sum = 0 ; for ( let i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }
function countSub ( arr , n ) { let count = new Array ( 10 ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = arr [ i ] - 1 ; j >= 0 ; j -- ) count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] ++ ; } let result = 0 ; for ( let i = 0 ; i < 10 ; i ++ ) result += count [ i ] ; return result ; }
function minimum ( a , b , c ) { return Math . min ( Math . min ( a , b ) , c ) ; }
function countSub ( s ) { let map = new Map ( ) ; for ( let i = 0 ; i < s . length ; i ++ ) { map . set ( s [ i ] , - 1 ) ; } let allCount = 0 ; let levelCount = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { let c = s [ i ] ; if ( i == 0 ) { allCount = 1 ; map . set ( c , 1 ) ; levelCount = 1 ; continue ; } levelCount = allCount + 1 ; if ( map . get ( c ) < 0 ) { allCount = allCount + levelCount ; } else { allCount = allCount + levelCount - map . get ( c ) ; } map . set ( c , levelCount ) ; } return allCount ; }
function catalanDP ( n ) { let catalan = [ ] catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( let j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; }
function countWays ( n ) { if ( n & 1 ) { document . write ( "Invalid" ) ; return 0 ; } return catalanDP ( n / 2 ) ; }
function countGroups ( position , previous_sum , length , num ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; let res = 0 ; let sum = 0 ; for ( let i = position ; i < length ; i ++ ) { sum += ( num [ i ] - "0" ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; }
function MinimumCost ( cost , n , W ) { let val = [ ] , wt = [ ] ; let size = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != - 1 ) { val . push ( cost [ i ] ) ; wt . push ( i + 1 ) ; size ++ ; } } n = size ; let min_cost = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { min_cost [ i ] = new Array ( W + 1 ) ; } for ( let i = 0 ; i <= W ; i ++ ) min_cost [ 0 ] [ i ] = INF ; for ( let i = 1 ; i <= n ; i ++ ) min_cost [ i ] [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= W ; j ++ ) { if ( wt [ i - 1 ] > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ; else min_cost [ i ] [ j ] = Math . min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) ; } } return ( min_cost [ n ] [ W ] == INF ) ? - 1 : min_cost [ n ] [ W ] ; }
function minCost ( cost , n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let min_cost = Number . MAX_VALUE ; for ( let j = 0 ; j < i ; j ++ ) if ( j < n ) min_cost = Math . min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) ; dp [ i ] = min_cost ; } return dp [ n ] ; }
function KnapSack ( val , wt , n , W ) { let dp = new Array ( W + 1 ) ; for ( let i = 0 ; i < W + 1 ; i ++ ) { dp [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) for ( let j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }
function count ( a , b , m , n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
function count ( a , b ) { var m = a . length ; var n = b . length ; var lookup = Array ( m + 1 ) ; for ( var i = 0 ; i < m + 1 ; i ++ ) lookup [ i ] = Array ( n + 1 ) . fill ( 0 ) ; for ( i = 0 ; i <= n ; ++ i ) lookup [ 0 ] [ i ] = 0 ; for ( i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ; for ( i = 1 ; i <= m ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; }
function lcs ( X , Y , m , n ) { let L = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; } for ( let i = 0 ; i < m + 1 ; i ++ ) { for ( let j = 0 ; j < n + 1 ; j ++ ) { L [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; }
function findMinCost ( X , Y , costX , costY ) { let m = X . length ; let n = Y . length ; let len_LCS ; len_LCS = lcs ( X , Y , m , n ) ; return costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ; }
function findSum ( arr ) { let sum = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) sum += arr [ i ] ; return sum ; }
function maxTasks ( high , low , n ) { if ( n <= 0 ) return 0 ; return Math . max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; }
function maxTasks ( high , low , n ) { var task_dp = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; task_dp [ 0 ] = 0 ; task_dp [ 1 ] = high [ 0 ] ; for ( i = 2 ; i <= n ; i ++ ) task_dp [ i ] = Math . max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) ; return task_dp [ n ] ; }
function findLCS ( X , Y , m , n ) { let s = new Set ( ) ; if ( m == 0 n == 0 ) { s . add ( "" ) ; return s ; } if ( X [ m - 1 ] == Y [ n - 1 ] ) { let tmp = findLCS ( X , Y , m - 1 , n - 1 ) ; for ( let str of tmp . values ( ) ) s . add ( str + X [ m - 1 ] ) ; } else { if ( L [ m - 1 ] [ n ] >= L [ m ] [ n - 1 ] ) s = findLCS ( X , Y , m - 1 , n ) ; if ( L [ m ] [ n - 1 ] >= L [ m - 1 ] [ n ] ) { let tmp = findLCS ( X , Y , m , n - 1 ) ; for ( let item of tmp . values ( ) ) s . add ( item ) } } return s ; }
function LCS ( X , Y , m , n ) { for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; }
function countIntegralSolutions ( n ) { let result = 0 ; for ( let i = 0 ; i <= n ; i ++ ) for ( let j = 0 ; j <= n - i ; j ++ ) for ( let k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
function countIntegralSolutions ( n ) { return Math . floor ( ( ( n + 1 ) * ( n + 2 ) ) / 2 ) ; }
function LCIS ( arr1 , n , arr2 , m ) { let table = [ ] ; for ( let j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let current = 0 ; for ( let j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } let result = 0 ; for ( let i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
function minTime ( arr , n ) { if ( n <= 0 ) return 0 ; let incl = arr [ 0 ] ; let excl = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let incl_new = arr [ i ] + Math . min ( excl , incl ) ; let excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; }
function lcs ( X , Y ) { let m = X . length , n = Y . length ; let L = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { L [ i ] [ j ] = 0 ; } } let bi = 0 ; for ( let i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }
function countUtil ( p , q , r ) { }
function countWays ( p , q , r , last ) { if ( p < 0 q < 0 r < 0 ) return 0 ; if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ; if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ; if ( dp [ p ] [ q ] [ r ] [ last ] != - 1 ) return dp [ p ] [ q ] [ r ] [ last ] ; if ( last == 0 ) dp [ p ] [ q ] [ r ] [ last ] = countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ; else if ( last == 1 ) dp [ p ] [ q ] [ r ] [ last ] = countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; else dp [ p ] [ q ] [ r ] [ last ] = countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; return dp [ p ] [ q ] [ r ] [ last ] ; }
function countUtil ( p , q , r ) { }
function multiply ( a , b ) { var mul = Array ( 3 ) . fill ( 0 ) . map ( x => Array ( 3 ) . fill ( 0 ) ) ; for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { mul [ i ] [ j ] = 0 ; for ( k = 0 ; k < 3 ; k ++ ) mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; } } for ( i = 0 ; i < 3 ; i ++ ) for ( j = 0 ; j < 3 ; j ++ ) a [ i ] [ j ] = mul [ i ] [ j ] ; }
function power ( F , n ) { var M = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] ; if ( n == 1 ) return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; power ( F , parseInt ( n / 2 ) ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) multiply ( F , M ) ; return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; }
function findNthTerm ( n ) { var F = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] ; return power ( F , n - 2 ) ; }
function count ( n ) { let dp = [ ] ; dp [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }
function KSmallestUsingMorris ( root , k ) { var count = 0 ; var ksmall = Number . MIN_VALUE ; var curr = root ; while ( curr != null ) { if ( curr . left == null ) { count ++ ; if ( count == k ) ksmall = curr . key ; curr = curr . right ; } else { var pre = curr . left ; while ( pre . right != null && pre . right != curr ) pre = pre . right ; if ( pre . right == null ) { pre . right = curr ; curr = curr . left ; } else { pre . right = null ; count ++ ; if ( count == k ) ksmall = curr . key ; curr = curr . right ; } } } return ksmall ; }
function subsetXOR ( arr , n , k ) { let max_ele = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; let m = ( 1 << parseInt ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 , 10 ) ) - 1 ; if ( k > m ) { return 0 ; } let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; }
function permutationCoeff ( n , k ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return parseInt ( fact [ n ] / fact [ n - k ] , 10 ) ; }
function findMin ( arr , n ) { let sumTotal = 0 ; for ( let i = 0 ; i < n ; i ++ ) sumTotal += arr [ i ] ; return findMinRec ( arr , n , 0 , sumTotal ) ; }
function countDer ( n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
function countDer ( n ) { let der = new Array ( n + 1 ) ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( let i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
function countDer ( n ) { if ( n == 1 n == 2 ) { return n - 1 ; } let a = 0 ; let b = 1 ; for ( let i = 3 ; i <= n ; ++ i ) { let cur = ( i - 1 ) * ( a + b ) ; a = b ; b = cur ; } return b ; }
function bellNumber ( n ) { let bell = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { bell [ i ] = new Array ( n + 1 ) ; } bell [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( let j = 1 ; j <= i ; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } return bell [ n ] [ 0 ] ; }
function minSizeRec ( arr , low , high , k ) { if ( dp [ low ] [ high ] != - 1 ) { return dp [ low ] [ high ] ; } if ( ( high - low + 1 ) < 3 ) { return high - low + 1 ; } let res = 1 + minSizeRec ( arr , low + 1 , high , k ) ; for ( let i = low + 1 ; i <= high - 1 ; i ++ ) { for ( let j = i + 1 ; j <= high ; j ++ ) { if ( arr [ i ] == ( arr [ low ] + k ) && arr [ j ] == ( arr [ low ] + 2 * k ) && minSizeRec ( arr , low + 1 , i - 1 , k ) == 0 && minSizeRec ( arr , i + 1 , j - 1 , k ) == 0 ) { res = Math . min ( res , minSizeRec ( arr , j + 1 , high , k ) ) ; } } } return ( dp [ low ] [ high ] = res ) ; }
function countSol ( coeff , start , end , rhs ) { if ( rhs == 0 ) return 1 ; let result = 0 ; for ( let i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
function countSol ( coeff , n , rhs ) { let dp = new Array ( rhs + 1 ) ; dp . fill ( 0 ) ; dp [ 0 ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
function printCountRec ( dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
function printCountDP ( dist ) { let count = new Array ( dist + 1 ) ; count [ 0 ] = 1 ; if ( dist >= 1 ) count [ 1 ] = 1 ; if ( dist >= 2 ) count [ 2 ] = 2 ; for ( let i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
function countSeq ( n ) { let nCr = 1 , res = 1 ; for ( let r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
function findLongestRepeatingSubSeq ( str ) { var n = str . length ; var dp = new Array ( n + 1 ) ; for ( var i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( var j = 0 ; j <= n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= n ; j ++ ) { if ( ( str [ i - 1 ] == str [ j - 1 ] ) && ( i != j ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
function isInorder ( arr , n ) { if ( n == 0 n == 1 ) { return true ; } for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) { return false ; } } return true ; }
function getMaxRec ( str , i , n , lookup ) { if ( i >= n ) { return 0 ; } if ( lookup [ i ] != - 1 ) { return lookup [ i ] ; } let ans = 1 + getMaxRec ( str , i + 1 , n , lookup ) ; if ( i + 1 < n ) { if ( str [ i ] != str [ i + 1 ] ) { ans = Math . max ( 4 + getMaxRec ( str , i + 2 , n , lookup ) , ans ) ; } else { ans = Math . max ( 3 + getMaxRec ( str , i + 2 , n , lookup ) , ans ) ; } } return lookup [ i ] = ans ; }
function getMaxWeight ( str ) { let n = str . length ; let lookup = new Array ( n ) ; lookup . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { lookup [ i ] = - 1 ; } return getMaxRec ( str , 0 , str . length , lookup ) ; }
function countRec ( digits , esum , osum , isOdd , n ) { if ( digits == n ) return ( esum - osum == 1 ) ? 1 : 0 ; if ( lookup [ digits ] [ esum ] [ osum ] [ isOdd ] != - 1 ) return lookup [ digits ] [ esum ] [ osum ] [ isOdd ] ; let ans = 0 ; if ( isOdd == 1 ) for ( let i = 0 ; i <= 9 ; i ++ ) ans += countRec ( digits + 1 , esum , osum + i , 0 , n ) ; for ( let i = 0 ; i <= 9 ; i ++ ) ans += countRec ( digits + 1 , esum + i , osum , 1 , n ) ; return lookup [ digits ] [ esum ] [ osum ] [ isOdd ] = ans ; }
function finalCount ( n ) { let digits = 0 ; for ( let i = 0 ; i < 50 ; i ++ ) for ( let j = 0 ; j < 1000 ; j ++ ) for ( let k = 0 ; k < 1000 ; k ++ ) for ( let l = 0 ; l < 2 ; l ++ ) lookup [ i ] [ j ] [ k ] [ l ] = - 1 ; let ans = 0 ; let esum = 0 , osum = 0 ; for ( let i = 1 ; i <= 9 ; i ++ ) ans += countRec ( digits + 1 , esum + i , osum , 1 , n ) ; return ans ; }
function steps ( source , step , dest ) { if ( Math . abs ( source ) > ( dest ) ) return Number . MAX_SAFE_INTEGER ; if ( source == dest ) return step ; let pos = steps ( source + step + 1 , step + 1 , dest ) ; let neg = steps ( source - step - 1 , step + 1 , dest ) ; return Math . min ( pos , neg ) ; }
function countNumbersWith4 ( n ) { let result = 0 ; for ( let x = 1 ; x <= n ; x ++ ) result += has4 ( x ) ? 1 : 0 ; return result ; }
function countNumbersWith4 ( n ) { if ( n < 4 ) return 0 ; let d = Math . floor ( Math . log10 ( n ) ) ; let a = new Array ( d + 2 ) ; for ( let i = 0 ; i < d + 2 ; i ++ ) { a [ i ] = 0 ; } a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( let i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + Math . floor ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; let p = Math . floor ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; let msd = Math . floor ( n / p ) ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; }
function max ( arr , l , h ) { let mx = arr [ l ] ; for ( let i = l + 1 ; i <= h ; i ++ ) { if ( mx < arr [ i ] ) mx = arr [ i ] ; } return mx ; }
function minRemovalsDP ( arr , n ) { var table = Array ( n ) ; var gap , i , j , mn , mx ; for ( i = 0 ; i < n ; i ++ ) table [ i ] = Array ( n ) . fill ( 0 ) ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { mn = min ( arr , i , j ) ; mx = max ( arr , i , j ) ; table [ i ] [ j ] = parseInt ( ( 2 * mn > mx ) ? 0 : minq ( table [ i ] [ j - 1 ] + 1 , table [ i + 1 ] [ j ] + 1 ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
function minRemovalsDP ( arr , n ) { let longest_start = - 1 , longest_end = 0 ; for ( let start = 0 ; start < n ; start ++ ) { let min = Number . MAX_VALUE , max = Number . MIN_VALUE ; for ( let end = start ; end < n ; end ++ ) { let val = arr [ end ] ; if ( val < min ) { min = val ; } if ( val > max ) { max = val ; } if ( 2 * min <= max ) { break ; } if ( end - start > longest_end - longest_start longest_start == - 1 ) { longest_start = start ; longest_end = end ; } } } if ( longest_start == - 1 ) { return n ; } return ( n - ( longest_end - longest_start + 1 ) ) ; }
function numberOfPaths ( m , n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
function numberOfPaths ( m , n ) { var count = Array ( m ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; for ( i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( i = 1 ; i < m ; i ++ ) { for ( j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] + count [ i - 1 ] [ j - 1 ] ; ; } return count [ m - 1 ] [ n - 1 ] ; }
function numberOfPaths ( m , n ) { dp = Array . from ( { length : n } , ( _ , i ) => 0 ) ; dp [ 0 ] = 1 ; for ( i = 0 ; i < m ; i ++ ) { for ( j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; }
function numberOfPaths ( m , n ) { var path = 1 ; for ( i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path = parseInt ( path / ( i - n + 1 ) ) ; } return path ; }
function checkBSTs ( root1 , root2 ) { if ( root1 != null && root2 != null ) return true ; if ( ( root1 == null && root2 != null ) || ( root1 != null && root2 == null ) ) return false ; var v1 = [ ] ; var v2 = [ ] ; storeInorder ( root1 , v1 ) ; storeInorder ( root2 , v2 ) ; return ( v1 == v2 ) ; }
function lenghtOfLongestAP ( set , n ) { if ( n <= 2 ) return n ; let L = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { L [ i ] = new Array ( n ) ; } let llap = 2 ; for ( let i = 0 ; i < n ; i ++ ) { L [ i ] [ n - 1 ] = 2 ; } for ( let j = n - 2 ; j >= 1 ; j -- ) { let i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ; else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) { L [ i ] [ j ] = 2 ; i -- ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; llap = Math . max ( llap , L [ i ] [ j ] ) ; i -- ; k ++ ; } } while ( i >= 0 ) { L [ i ] [ j ] = 2 ; i -- ; } } return llap ; }
function carAssembly ( a , t , e , x ) { let T1 = new Array ( NUM_STATION ) ; let T2 = new Array ( NUM_STATION ) ; let i ; T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; }
function findWays ( m , n , x ) { let table = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { table [ i ] = new Array ( x + 1 ) ; for ( let j = 0 ; j < ( x + 1 ) ; j ++ ) { table [ i ] [ j ] = 0 ; } } for ( let j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= x ; j ++ ) { for ( let k = 1 ; k < j && k <= m ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; } } return table [ n ] [ x ] ; }
function findWays ( f , d , s ) { let mem = new Array ( d + 1 ) ; for ( let i = 0 ; i < ( d + 1 ) ; i ++ ) { mem [ i ] = new Array ( s + 1 ) ; for ( let j = 0 ; j < s + 1 ; j ++ ) { mem [ i ] [ j ] = 0 ; } } mem [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= d ; i ++ ) { for ( let j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }
function LCSubStr ( X , Y , m , n ) { var LCStuff = Array ( m + 1 ) . fill ( ) . map ( ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; var result = 0 ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCStuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ; result = Math . max ( result , LCStuff [ i ] [ j ] ) ; } else LCStuff [ i ] [ j ] = 0 ; } } return result ; }
function LCSubStr ( s , t , n , m ) { var dp = Array ( 2 ) . fill ( ) . map ( ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; var res = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= m ; j ++ ) { if ( s . charAt ( i - 1 ) == t . charAt ( j - 1 ) ) { dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 ; if ( dp [ i % 2 ] [ j ] > res ) res = dp [ i % 2 ] [ j ] ; } else dp [ i % 2 ] [ j ] = 0 ; } } return res ; }
function lcs ( i , j , count ) { if ( i == 0 j == 0 ) return count ; if ( X [ i - 1 ] == Y [ j - 1 ] ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; } count = Math . max ( count , Math . max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) ; return count ; }
function findMinInsertions ( str , l , h ) { if ( l > h ) return Number . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Math . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) }
function maxCrossingSum ( arr , l , m , h ) { let sum = 0 ; let left_sum = Number . MIN_VALUE ; for ( let i = m ; i >= l ; i -- ) { sum = sum + arr [ i ] ; if ( sum > left_sum ) left_sum = sum ; } sum = 0 ; let right_sum = Number . MIN_VALUE ; for ( let i = m + 1 ; i <= h ; i ++ ) { sum = sum + arr [ i ] ; if ( sum > right_sum ) right_sum = sum ; } return max ( left_sum + right_sum , left_sum , right_sum ) ; }
function maxSubArraySum ( arr , l , h ) { if ( l == h ) return arr [ l ] ; let m = parseInt ( ( l + h ) / 2 , 10 ) ; return max ( maxSubArraySum ( arr , l , m ) , maxSubArraySum ( arr , m + 1 , h ) , maxCrossingSum ( arr , l , m , h ) ) ; }
function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
function subsetSum ( a , n , sum ) { if ( sum == 0 ) return 1 ; if ( n <= 0 ) return 0 ; if ( tab [ n - 1 ] [ sum ] != - 1 ) return tab [ n - 1 ] [ sum ] ; if ( a [ n - 1 ] > sum ) return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) ; else { return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) || subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) ; } }
function findWater ( i , j , X ) { if ( j > i ) { document . write ( "Incorrect▁Input" ) ; } var ll = Math . round ( ( i * ( i + 1 ) ) ) ; glass = Array . from ( { length : ll + 2 } , ( _ , i ) => 0.0 ) ; var index = 0 ; glass [ index ] = X ; for ( row = 1 ; row <= i ; ++ row ) { for ( col = 1 ; col <= row ; ++ col , ++ index ) { X = glass [ index ] ; glass [ index ] = ( X >= 1.0 ) ? 1.0 : X ; X = ( X >= 1.0 ) ? ( X - 1 ) : 0.0 ; glass [ index + row ] += X / 2 ; glass [ index + row + 1 ] += X / 2 ; } } return glass [ parseInt ( ( i * ( i - 1 ) / 2 + j - 1 ) ) ] ; }
function maxChainLength ( arr , n ) { let i , j , max = 0 ; let mcl = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) mcl [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] . a > arr [ j ] . b && mcl [ i ] < mcl [ j ] + 1 ) mcl [ i ] = mcl [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < mcl [ i ] ) max = mcl [ i ] ; return max ; }
function solveWordWrap ( l , n , M ) { let extras = new Array ( n + 1 ) ; let lc = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { extras [ i ] = new Array ( n + 1 ) ; lc [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { extras [ i ] [ j ] = 0 ; lc [ i ] [ j ] = 0 ; } } let c = new Array ( n + 1 ) ; let p = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) { extras [ i ] [ i ] = M - l [ i - 1 ] ; for ( let j = i + 1 ; j <= n ; j ++ ) extras [ i ] [ j ] = extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ; } for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = i ; j <= n ; j ++ ) { if ( extras [ i ] [ j ] < 0 ) lc [ i ] [ j ] = MAX ; else if ( j == n && extras [ i ] [ j ] >= 0 ) lc [ i ] [ j ] = 0 ; else lc [ i ] [ j ] = extras [ i ] [ j ] * extras [ i ] [ j ] ; } } c [ 0 ] = 0 ; for ( let j = 1 ; j <= n ; j ++ ) { c [ j ] = MAX ; for ( let i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != MAX && lc [ i ] [ j ] != MAX && ( c [ i - 1 ] + lc [ i ] [ j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; }
function distanceFromRoot ( root , x ) { if ( root . key == x ) return 0 ; else if ( root . key > x ) return 1 + distanceFromRoot ( root . left , x ) ; return 1 + distanceFromRoot ( root . right , x ) ; }
function findDistWrapper ( root , a , b ) { var temp = 0 ; if ( a > b ) { temp = a ; a = b ; b = temp ; } return distanceBetween2 ( root , a , b ) ; }
function isSubsetSum ( arr , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( arr [ n - 1 ] > sum ) return isSubsetSum ( arr , n - 1 , sum ) ; return isSubsetSum ( arr , n - 1 , sum ) || isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; }
function findPartiion ( arr , n ) { let sum = 0 ; let i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; let part = new Array ( parseInt ( sum / 2 + 1 , 10 ) ) ; for ( i = 0 ; i <= parseInt ( sum / 2 , 10 ) ; i ++ ) { part [ i ] = false ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = parseInt ( sum / 2 , 10 ) ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ parseInt ( sum / 2 , 10 ) ] ; }
function minPalPartion ( String , i , j ) { if ( i >= j || isPalindrome ( String , i , j ) ) return 0 ; let ans = Number . MAX_VALUE , count ; for ( let k = i ; k < j ; k ++ ) { count = minPalPartion ( String , i , k ) + minPalPartion ( String , k + 1 , j ) + 1 ; ans = Math . min ( ans , count ) ; } return ans ; }
function minCut ( a ) { var cut = new Array ( a . length ) ; var palindrome = new Array ( a . length ) ; for ( var i = 0 ; i < a . length ; i ++ ) { var minCut = i ; for ( var j = 0 ; j <= i ; j ++ ) { if ( a . charAt ( i ) == a . charAt ( j ) && ( i - j < 5 palindrome [ j + 1 ] [ i - 1 ] ) ) { palindrome [ j , i ] = true ; minCut = Math . min ( minCut , j == 0 ? 0 : ( cut [ j - 1 ] + 1 ) ) ; } } cut [ i ] = minCut ; } return cut [ a . length - 1 ] ; }
function maxSumIS ( arr , n ) { let i , j , max = 0 ; let msis = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
function cutRod ( price , n ) { let val = new Array ( n + 1 ) ; val [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let max_val = Number . MIN_VALUE ; for ( let j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }
function max ( x , y ) { return ( x > y ) ? x : y ; }
function binomialCoeff ( n , r ) { if ( r > n ) return 0 ; let m = 1000000007 ; let inv = new Array ( r + 1 ) . fill ( 0 ) ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( let i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - Math . floor ( m / i ) * inv [ m % i ] % m ; } let ans = 1 ; for ( let i = 2 ; i <= r ; i ++ ) { ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m ; } for ( let i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( ( ans % m ) * ( i % m ) ) % m ; } return ans ; }
function matrixChainMemoised ( p , i , j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != - 1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = Number . MAX_VALUE ; for ( let k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; }
function MatrixChainOrder ( p , n ) { let i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; }
function count ( S , m , n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
function factorial ( n ) { let res = 1 ; for ( let i = 1 ; i <= n ; ++ i ) { res *= i ; } return res ; }
function catalan ( n ) { let c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
function countBST ( n ) { let count = catalan ( n ) ; return count ; }
function countBT ( n ) { let count = catalan ( n ) ; return count * factorial ( n ) ; }
function checkArray ( arr , N , k ) { if ( N < 3 ) return - 1 ; let i , Sum = 0 , temp = 0 ; for ( i = 0 ; i < N ; i ++ ) Sum += arr [ i ] ; let R = ( k * k + k + 1 ) ; if ( Sum % R != 0 ) return 0 ; let Mid = k * ( Sum / R ) ; for ( i = 1 ; i < N - 1 ; i ++ ) { temp += arr [ i - 1 ] ; if ( arr [ i ] == Mid ) { if ( temp == Mid / k ) return i + 1 ; else return 0 ; } } return 0 ; }
function encodeString ( str ) { let res = "" ; let small = new Array ( 26 ) . fill ( 0 ) , capital = new Array ( 26 ) . fill ( 0 ) , num = new Array ( 26 ) . fill ( 0 ) ; let n = str . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] . charCodeAt ( 0 ) >= "0" . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= "9" . charCodeAt ( 0 ) ) { num [ str [ i ] . charCodeAt ( 0 ) - 48 ] = i ; } else if ( str [ i ] . charCodeAt ( 0 ) >= "a" . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= "z" . charCodeAt ( 0 ) ) { small [ str [ i ] . charCodeAt ( 0 ) - 97 ] = i ; } else if ( str [ i ] . charCodeAt ( 0 ) >= "A" . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= "Z" . charCodeAt ( 0 ) ) { capital [ str [ i ] . charCodeAt ( 0 ) - 65 ] = i ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( ( str [ i ] . charCodeAt ( 0 ) >= "a" . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= "z" . charCodeAt ( 0 ) ) && small [ str [ i ] . charCodeAt ( 0 ) - 97 ] == i ) { let occ = str [ i ] . charCodeAt ( 0 ) - 96 ; while ( occ -- ) { res += str [ i ] ; } } else if ( ( str [ i ] . charCodeAt ( 0 ) >= "A" . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= "Z" . charCodeAt ( 0 ) ) && capital [ str [ i ] . charCodeAt ( 0 ) - 65 ] == i ) { let occ = str [ i ] . charCodeAt ( 0 ) - 64 ; while ( occ -- ) { res += str [ i ] ; } } else if ( ( str [ i ] . charCodeAt ( 0 ) >= "0" . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= "9" . charCodeAt ( 0 ) ) && num [ str [ i ] . charCodeAt ( 0 ) - 48 ] == i ) { let occ = str [ i ] . charCodeAt ( 0 ) - 48 ; while ( occ -- ) { res += str [ i ] ; } } else { res += str [ i ] ; } } document . write ( res ) ; }
function possibleEqualArray ( A , N ) { let pref = new Array ( N ) ; pref [ 0 ] = A [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { pref [ i ] = pref [ i - 1 ] ^ A [ i ] ; } if ( pref [ N - 1 ] == 0 ) { document . write ( "YES" ) ; return ; } let cur_xor = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { cur_xor ^= A [ i ] ; for ( let j = 0 ; j < i ; j ++ ) { if ( j ) { let middle_xor = pref [ j - 1 ] ^ pref [ i - 1 ] ; let left_xor = pref [ j - 1 ] ; let right_xor = cur_xor ; if ( left_xor == middle_xor && middle_xor == right_xor ) { document . write ( "YES" ) ; return ; } } } } document . write ( "NO" ) ; }
function RangeTraversal ( root , n1 , n2 ) { if ( root == null ) return ; var curr = root ; while ( curr != null ) { if ( curr . left == null ) { if ( curr . data <= n2 && curr . data >= n1 ) { document . write ( curr . data + "▁" ) ; } curr = curr . right ; } else { var pre = curr . left ; while ( pre . right != null && pre . right != curr ) pre = pre . right ; if ( pre . right == null ) { pre . right = curr ; curr = curr . left ; } else { pre . right = null ; if ( curr . data <= n2 && curr . data >= n1 ) { document . write ( curr . data + "▁" ) ; } curr = curr . right ; } } } }
function possibleEqualArray ( A , N ) { var tot_XOR = 0 ; for ( var i = 0 ; i < N ; i ++ ) { tot_XOR ^= A [ i ] ; } if ( tot_XOR == 0 ) { document . write ( "YES" ) ; return ; } var cur_XOR = 0 ; var cnt = 0 ; for ( var i = 0 ; i < N ; i ++ ) { cur_XOR ^= A [ i ] ; if ( cur_XOR == tot_XOR ) { cnt ++ ; cur_XOR = 0 ; } } if ( cnt > 2 ) { document . write ( "YES" ) ; } else { document . write ( "NO" ) ; } }
function GenerateArray ( N , X ) { let prev_xor = X ; for ( let i = 1 ; i <= N ; i ++ ) { document . write ( ( i ^ prev_xor ) ) ; if ( i != N ) { document . write ( "▁" ) ; } prev_xor = i ; } }
function createGrid ( grid , is1 , N , M ) { for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( is1 ) { grid [ i ] [ j ] = "0" ; is1 = false ; } else { grid [ i ] [ j ] = "1" ; is1 = true ; } } if ( M % 2 == 0 ) is1 = ! is1 ; } }
function testGrid ( testGrid , Grid , N , M ) { for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( Grid [ i ] [ j ] != "*" ) { if ( Grid [ i ] [ j ] != testGrid [ i ] [ j ] ) { return false ; } } } } return true ; }
function findPossibleGrid ( N , M , grid ) { let gridTest1 = new Array ( N ) . fill ( 0 ) . map ( ( ) => new Array ( 1001 ) ) ; let gridTest2 = new Array ( N ) . fill ( 0 ) . map ( ( ) => new Array ( 1001 ) ) ; createGrid ( gridTest1 , true , N , M ) ; createGrid ( gridTest2 , false , N , M ) ; if ( testGrid ( gridTest1 , grid , N , M ) ) { document . write ( "Yes" ) ; printGrid ( gridTest1 , N , M ) ; } else if ( testGrid ( gridTest2 , grid , N , M ) ) { document . write ( "Yes" ) ; printGrid ( gridTest2 , N , M ) ; } else { document . write ( "No" ) ; } }
function brute ( ind , l , r ) { if ( ind == n / 2 ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( brr [ i ] + "▁" ) ; exit ( 0 ) ; } for ( let i = l ; i <= arr [ ind ] / 2 ; ++ i ) if ( arr [ ind ] - i <= r ) { brr [ ind ] = i ; brr [ n - ind - 1 ] = arr [ ind ] - i ; brute ( ind + 1 , i , arr [ ind ] - i ) ; } }
function minCount ( N , K ) { let SmallestNumber = new Array ( 10 ) ; let MinimumSteps = new Array ( 10 ) ; for ( let i = 0 ; i <= 9 ; i ++ ) { SmallestNumber [ i ] = Number . MAX_VALUE ; MinimumSteps [ i ] = Number . MAX_VALUE ; } for ( let i = 1 ; i <= 10 ; i ++ ) { let num = K * i ; SmallestNumber [ num % 10 ] = Math . min ( SmallestNumber [ num % 10 ] , num ) ; MinimumSteps [ num % 10 ] = Math . min ( MinimumSteps [ num % 10 ] , i ) ; } if ( N < SmallestNumber [ N % 10 ] ) { return - 1 ; } else { return MinimumSteps [ N % 10 ] ; } }
function inRange ( root , low , high ) { return root . data >= low && root . data <= high ; }
function countMinSteps ( arr , N ) { let val = 0 ; let mx = Number . MIN_SAFE_INTEGER ; for ( let i = 0 ; i < N ; i ++ ) { let curr = arr [ i ] ; mx = Math . max ( mx , curr ) ; val = Math . max ( val , mx - curr ) ; } let res = 0 ; while ( ( 1 << res ) - 1 < val ) { ++ res ; } return res ; }
function func2 ( L , R , K ) { if ( R - L >= 2 ) return 1 ; return Mat . min ( L , L ^ R ) ; }
function func3 ( L , R , K ) { if ( ( R ^ L ) > L && ( R ^ L ) < R ) return 0 ; return func2 ( L , R , K ) ; }
function func4 ( L , R , K ) { if ( R - L >= 4 ) return 0 ; var minval = L ^ ( L + 1 ) ^ ( L + 2 ) ^ ( L + 3 ) ; return Math . min ( minval , func3 ( L , R , K ) ) ; }
function minimumXor ( L , R , K ) { if ( K > 4 ) return 0 ; else if ( K == 4 ) return func4 ( L , R , K ) ; else if ( K == 3 ) return func3 ( L , R , K ) ; else if ( K == 2 ) return func2 ( L , R , K ) ; else return L ; }
function setBits ( n ) { var count = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; }
function findNthTerm ( N ) { var x = setBits ( N ^ ( N - 1 ) ) ; document . write ( x ) ; }
function findEquation ( A , B , C ) { document . write ( "(" + C + ")" + "x^2▁+(" + B + ")x▁+▁(" + A + ")▁=▁0" ) }
function findMinMoves ( arr , N ) { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % N != 0 ) return - 1 ; let avg = sum / N ; let total = 0 ; let needCount = 0 ; for ( let i = 0 ; i < N ; i ++ ) { needCount += ( arr [ i ] - avg ) ; total = Math . max ( Math . max ( Math . abs ( needCount ) , arr [ i ] - avg ) , total ) ; } return total ; }
function checkPro ( n , k ) { var exp = 1.0 / k ; var KthRoot = parseInt ( Math . pow ( n , exp ) ) ; var product = 1 ; for ( i = 1 ; i < k + 1 ; i ++ ) { product = product * i ; } if ( product == n ) return "Yes" ; else { for ( j = 2 ; j < KthRoot + 1 ; j ++ ) { product = product * ( j + k - 1 ) ; product = product / ( j - 1 ) ; if ( product == n ) return "Yes" ; } } return "No" ; }
function totalCombination ( L , R ) { let count = 0 ; let K = R - L ; if ( K < L ) return 0 ; let ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; }
function inorder ( root ) { if ( root != null ) { inorder ( root . left ) ; document . write ( root . data + "▁" ) ; inorder ( root . right ) ; } }
function getZarr ( str , Z ) { let n = str . length ; let k ; let L = 0 ; let R = 0 ; for ( let i = 1 ; i < n ; ++ i ) { if ( i > R ) { L = R = i ; while ( R < n && str [ R - L ] == str [ R ] ) { R ++ ; } Z [ i ] = R - L ; R -- ; } else { k = i - L ; if ( Z [ k ] < R - i + 1 ) { Z [ i ] = Z [ k ] ; } else { L = i ; while ( R < n && str [ R - L ] == str [ R ] ) { R ++ ; } Z [ i ] = R - L ; R -- ; } } } }
function goodStr ( str , word ) { let concat = word + "$" + str ; let l = concat . length ; let Z = new Array ( l ) ; getZarr ( concat , Z ) ; let res = "" ; let pSize = word . length ; for ( let i = 0 ; i < l ; ++ i ) { if ( i + pSize < l - 1 && Z [ i + pSize + 1 ] == pSize ) { i += pSize - 1 ; } else if ( i < str . length ) { res += str [ i ] ; } } return res ; }
function findCount0th ( arr , N , K ) { let oddsum = 0 , evensum = 0 ; for ( let i = 1 ; i < N ; i += 2 ) { oddsum += arr [ i ] ; } for ( let i = 2 ; i < N ; i += 2 ) { evensum += arr [ i ] ; } if ( Math . abs ( oddsum - evensum ) == K ) return 1 ; else return 0 ; }
function findCount1st ( arr , N , K ) { let evensum = arr [ 0 ] , oddsum = 0 ; for ( let i = 3 ; i < N ; i += 2 ) { evensum += arr [ i ] ; } for ( let i = 2 ; i < N ; i += 2 ) { oddsum += arr [ i ] ; } if ( Math . abs ( oddsum - evensum ) == K ) return 1 ; else return 0 ; }
function printDiagonalTraversal ( nums ) { let max_size = nums [ 0 ] . length ; let v = [ ] ; for ( let i = 0 ; i < 2 * max_size - 1 ; i ++ ) { v . push ( [ ] ) ; } for ( let i = 0 ; i < nums [ 0 ] . length ; i ++ ) { for ( let j = 0 ; j < nums [ 0 ] . length ; j ++ ) { v [ i + j ] . push ( nums [ i ] [ j ] ) ; } } for ( let i = 0 ; i < v . length ; i ++ ) { for ( let j = v [ i ] . length - 1 ; j >= 0 ; j -- ) { document . write ( v [ i ] [ j ] + "▁" ) ; } } }
function printDiagonalTraversal ( nums ) { let m = nums . length ; let q = [ ] ; q . push ( new pair ( 0 , 0 ) ) ; while ( q . length != 0 ) { let p = q [ 0 ] ; q . shift ( ) ; document . write ( nums [ p . first ] [ p . second ] + "▁" ) ; if ( p . second == 0 && p . first + 1 < m ) { q . push ( new pair ( p . first + 1 , p . second ) ) ; } if ( p . second + 1 < nums [ p . first ] . length ) q . push ( new pair ( p . first , p . second + 1 ) ) ; } }
function flipBitsOfAandB ( A , B ) { for ( i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } document . write ( A + "▁" + B ) ; }
function flipBitsOfAandB ( A , B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; document . write ( A + "▁" + B ) ; }
function isValid ( s ) { let n = Math . sqrt ( s . length ) ; let check = s [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { let x = i , y = i ; while ( x >= 0 && y < n ) { if ( s [ ( n * x ) + y ] != check || s [ ( n * y ) + x ] != check ) { document . write ( "No" ) ; return ; } x -- ; y ++ ; } } document . write ( "Yes" ) ; }
function minimumOperations ( orig_str , m , n ) { let orig = orig_str ; let turn = 1 ; let j = 1 ; for ( let i = 0 ; i < orig_str . length ; i ++ ) { let m_cut = orig_str . substring ( orig_str . length - m ) ; orig_str = orig_str . substring ( 0 , orig_str . length - m ) ; orig_str = m_cut + orig_str ; j = j + 1 ; if ( orig != orig_str ) { turn = turn + 1 ; let n_cut = orig_str . substring ( orig_str . length - n ) ; orig_str = orig_str . substring ( 0 , orig_str . length - n ) ; orig_str = n_cut + orig_str ; j = j + 1 ; } if ( orig == orig_str ) { break ; } turn = turn + 1 ; } document . write ( turn ) ; }
function gcd ( a , b ) { if ( a < b ) { let t = a ; a = b ; b = t ; } if ( a % b == 0 ) return b ; return gcd ( b , a % b ) ; }
function printAnswer ( x , y ) { let val = gcd ( x , y ) ; if ( ( val & ( val - 1 ) ) == 0 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function toDigit ( ch ) { return ch - "0" ; }
function powerOf10 ( ) { power [ 0 ] = 1 ; for ( var i = 1 ; i < N ; i ++ ) power [ i ] = power [ i - 1 ] * 10 ; }
function precomputePrefix ( str , n ) { pref [ 0 ] = str [ 0 ] - "0" ; for ( var i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + toDigit ( str [ i ] ) ; }
function triangularNumber ( i ) { var res = parseInt ( ( i * ( i + 1 ) ) / 2 ) ; return res ; }
function sumOfSubarrayProd ( arr , n ) { let ans = 0 ; let res = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { let incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } document . write ( ans ) ; }
function OddLengthSum ( arr ) { var sum = 0 ; var l = arr . length ; for ( var i = 0 ; i < l ; i ++ ) { for ( var j = i ; j < l ; j += 2 ) { for ( var k = i ; k <= j ; k ++ ) { sum += arr [ k ] ; } } } return sum ; }
function phi ( n ) { let result = 1 ; for ( let p = 2 ; p < n ; p ++ ) { if ( __gcd ( p , n ) == 1 ) { result ++ ; } } return result ; }
function sameEulerTotient ( n ) { return phi ( n ) == phi ( 2 * n ) ; }
function sameEulerTotient ( N ) { return ( N & 1 ) ; }
function restore ( arr , N ) { var result = [ ] ; var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( ! mp . has ( arr [ i ] ) ) { result . push ( arr [ i ] ) ; mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } } return result ; }
function print_result ( result ) { for ( var i = 0 ; i < result . length ; i ++ ) { document . write ( result [ i ] + "▁" ) ; } }
function restore ( arr , N ) { let result = [ ] ; let count1 = 1 ; let s = new Set ( ) ; for ( let i = 0 ; i < N ; i ++ ) { s . add ( arr [ i ] ) ; if ( s . size == count1 ) { result . push ( arr [ i ] ) ; count1 ++ ; } } return result ; }
function print_result ( result ) { for ( let i = 0 ; i < result . length ; i ++ ) document . write ( result [ i ] + "▁" ) ; }
function checkReverseBitonic ( arr , n ) { let i , j , f = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { f = 1 ; break ; } } if ( i == n ) return true ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { if ( f == 1 ) return false ; } } return true ; }
function sum ( n ) { return n * parseInt ( ( n - 1 ) / 2 ) ; }
function getFirstSetBitPos ( n ) { return ( Math . log ( n & - n ) / Math . log ( 2 ) ) ; }
function oddFirst ( a , b ) { let steps_a = getFirstSetBitPos ( a ) ; let steps_b = getFirstSetBitPos ( b ) ; if ( steps_a == steps_b ) { return - 1 ; } else if ( steps_a > steps_b ) { return b ; } else { return a ; } }
function nCycle ( N ) { return ( N ) * ( N - 1 ) + 1 ; }
function checkReverseBitonic ( s ) { var i , j ; for ( i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] < s [ i - 1 ] ) continue ; if ( s [ i ] >= s [ i - 1 ] ) break ; } if ( i == s . length - 1 ) return 1 ; for ( j = i + 1 ; j < s . length ; j ++ ) { if ( s [ j ] > s [ j - 1 ] ) continue ; if ( s [ j ] <= s [ j - 1 ] ) break ; } i = j ; if ( i != s . length ) return 0 ; return 1 ; }
function solve ( n ) { let s = 0 ; for ( let l = 1 ; l <= n ; ) { let r = ( n / Math . floor ( n / l ) ) ; let x = Math . floor ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; let y = Math . floor ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; let p = ( Math . floor ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } document . write ( ( s + m ) % m ) ; }
function solve ( n ) { let i , sum = 0 ; while ( n > 0 ) { i = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; n = n - parseInt ( Math . pow ( 2 , i ) , 10 ) ; sum = sum + ( i + 1 ) + Count ( i - 1 ) ; } return sum ; }
function smallestNum ( N ) { x = Math . pow ( 10.0 , ( N - 1 ) / 2.0 ) ; return Math . ceil ( x ) ; }
function checkBitonic ( s ) { var i , j ; for ( i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] > s [ i - 1 ] ) continue ; if ( s [ i ] <= s [ i - 1 ] ) break ; } if ( i == s . length - 1 ) return 1 ; for ( j = i + 1 ; j < s . length ; j ++ ) { if ( s [ j ] < s [ j - 1 ] ) continue ; if ( s [ j ] >= s [ j - 1 ] ) break ; } i = j ; if ( i != s . length ) return 0 ; return 1 ; }
function findArray ( a , n , P ) { let mi = Math . min ( ... a ) ; let ctr = 0 ; mi = Math . max ( 0 , mi - 1 ) ; for ( let i = 0 ; i < n ; i ++ ) { a [ i ] -= mi ; ctr += mi ; } let i = P - 1 ; let start = - 1 ; while ( true ) { if ( a [ i ] == 0 ) { start = i ; break ; } a [ i ] -= 1 ; ctr += 1 ; i = ( i - 1 + n ) % n ; } a [ start ] = ctr ; for ( i = 0 ; i < n ; i ++ ) { document . write ( a [ i ] + ",▁" ) ; } }
function checkstateA ( n ) { if ( n [ 0 ] == "0" ) stateB ( n . substr ( 1 ) ) ; else stateD ( n . substr ( 1 ) ) ; }
function stateB ( n ) { if ( n . length == 0 ) { document . write ( "string▁not▁accepted" ) ; } else { if ( n [ 0 ] == "1" ) stateC ( n . substr ( 1 ) ) ; else stateD ( n . substr ( 1 ) ) ; } }
function stateD ( n ) { if ( n . length == 0 ) Console . Write ( "string▁not▁accepted" ) ; else { if ( n [ 0 ] == "1" ) stateD ( n . substr ( 1 ) ) ; else stateE ( n . substr ( 1 ) ) ; } }
function stateE ( n ) { if ( n . length == 0 ) document . write ( "string▁not▁accepted" ) ; else { if ( n [ 0 ] == "0" ) stateE ( n . substr ( 1 ) ) ; else stateF ( n . substr ( 1 ) ) ; } }
function stateF ( n ) { if ( n . length == 0 ) document . write ( "string▁accepred" ) ; else { if ( n [ 0 ] == "1" ) stateD ( n . substr ( 1 ) ) ; else stateE ( n . substr ( 1 ) ) ; } }
function HogbenNumber ( a ) { let p = ( Math . pow ( a , 2 ) - a + 1 ) ; return p ; }
function countKCountdown ( arr , N , K ) { var flag = - 1 ; var count = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) flag = K ; if ( arr [ i ] == flag ) flag -- ; else flag = - 1 ; if ( flag == 0 ) count ++ ; } return count ; }
function findDistinctSums ( N ) { return ( 2 * N - 1 ) ; }
function count_ht ( s , N ) { var p = [ 0 , 0 ] ; if ( s == "H" ) { p [ 0 ] = Math . floor ( N / 2.0 ) ; p [ 1 ] = Math . ceil ( N / 2.0 ) ; } else if ( s == "T" ) { p [ 0 ] = Math . ceil ( N / 2.0 ) ; p [ 1 ] = Math . floor ( N / 2.0 ) ; } return p ; }
function getProduct ( n ) { var product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = parseInt ( n / 10 ) ; } return product ; }
function productinRange ( l , r ) { if ( r - l > 9 ) return 0 ; else { var p = 1 ; for ( var i = l ; i <= r ; i ++ ) p *= getProduct ( i ) ; return p ; } }
function checkQwertyRow ( x ) { var first_row = [ "1" , "2" , "3" , "4" , "5" , "6" , "7" , "8" , "9" , "0" , "-" , "=" , ] ; var second_row = [ "Q" , "W" , "E" , "R" , "T" , "Y" , "U" , "I" , "O" , "P" , "[" , "]" , "q" , "w" , "e" , "r" , "t" , "y" , "u" , "i" , "o" , "p" , ] ; var third_row = [ "A" , "S" , "D" , "F" , "G" , "H" , "J" , "K" , "L" , ";" , ":" , "a" , "s" , "d" , "f" , "g" , "h" , "j" , "k" , "l" , ] ; var fourth_row = [ "Z" , "X" , "C" , "V" , "B" , "N" , "M" , "," , "." , "/" , "z" , "x" , "c" , "v" , "b" , "n" , "m" , ] ; if ( first_row . includes ( x ) ) { return 1 ; } else if ( second_row . includes ( x ) ) { return 2 ; } else if ( third_row . includes ( x ) ) { return 3 ; } else if ( fourth_row . includes ( x ) ) { return 4 ; } return 0 ; }
function checkValidity ( str ) { var x = str [ 0 ] ; var row = checkQwertyRow ( x ) ; for ( var i = 0 ; i < str . length ; i ++ ) { x = str [ i ] ; if ( row !== checkQwertyRow ( x ) ) { return false ; } } return true ; }
function fib ( n ) { var f0 = 0 ; var f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { var rem = parseInt ( ( n % 60 ) ) ; if ( rem == 0 ) return 0 ; for ( i = 2 ; i < rem + 3 ; i ++ ) { var f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } var s = f1 - 1 ; return s ; } }
function sumBetweenZero ( arr , N ) { let i = 0 ; let A = new Array ( ) ; let sum = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { i ++ ; break ; } } for ( ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { A . push ( sum ) ; sum = 0 ; } else { sum += arr [ i ] ; } } for ( let i = 0 ; i < A . length ; i ++ ) { document . write ( A [ i ] + "▁" ) ; } if ( A . length == 0 ) document . write ( "-1" ) ; }
function nthTerm ( N ) { if ( N == 1 ) { return 2 ; } return ( ( N - 1 ) * 13 ) + nthTerm ( N - 1 ) ; }
function maximumSubsequence ( arr , N ) { let M = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( M . has ( arr [ i ] ) ) { M . set ( arr [ i ] , M . get ( arr [ i ] ) + 1 ) ; } else { M . set ( arr [ i ] , 1 ) ; } } let distinct_size = M . size ; let maxFreq = 1 ; for ( let it of M ) { maxFreq = Math . max ( maxFreq , it [ 1 ] ) ; } document . write ( Math . max ( Math . min ( distinct_size , maxFreq - 1 ) , Math . min ( distinct_size - 1 , maxFreq ) ) ) ; }
function decToHexa ( n ) { let hexaDeciNum = Array . from ( { length : 2 } , ( _ , i ) => 0 ) ; let i = 0 ; while ( n != 0 ) { let temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = String . fromCharCode ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = String . fromCharCode ( temp + 55 ) ; i ++ ; } n = Math . floor ( n / 16 ) ; } let hexCode = "" ; if ( i == 2 ) { hexCode += hexaDeciNum [ 0 ] ; hexCode += hexaDeciNum [ 1 ] ; } else if ( i == 1 ) { hexCode = "0" ; hexCode += hexaDeciNum [ 0 ] ; } else if ( i == 0 ) hexCode = "00" ; return hexCode ; }
function convertRGBtoHex ( R , G , B ) { if ( ( R >= 0 && R <= 255 ) && ( G >= 0 && G <= 255 ) && ( B >= 0 && B <= 255 ) ) { let hexCode = "#" ; hexCode += decToHexa ( R ) ; hexCode += decToHexa ( G ) ; hexCode += decToHexa ( B ) ; return hexCode ; } else return "-1" ; }
function isKAlternating ( s , k ) { if ( s . length < k ) return false ; var checker = 0 ; for ( var i = 0 ; i < k ; i ++ ) { var bitAtIndex = s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } for ( var i = k ; i < s . length ; i ++ ) if ( s [ i - k ] != s [ i ] ) return false ; return true ; }
function findFactors ( N ) { let temp = Math . floor ( Math . sqrt ( N ) ) ; let factor = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { factor [ i ] = 1 ; } let i , j , k ; let len1 = 1 ; while ( temp % 2 == 0 ) { factor [ len1 ++ ] = 2 ; factor [ len1 ++ ] = 2 ; temp = Math . floor ( temp / 2 ) ; } for ( j = 3 ; j < Math . sqrt ( temp ) ; j += 2 ) { while ( temp % j == 0 ) { factor [ len1 ++ ] = j ; factor [ len1 ++ ] = j ; temp = Math . floor ( temp / j ) ; } } if ( temp > 2 ) { factor [ len1 ++ ] = temp ; factor [ len1 ++ ] = temp ; } let M = new Array ( len1 ) ; for ( let i = 0 ; i < len1 ; i ++ ) { M [ i ] = new Array ( MAX ) ; for ( let j = 0 ; j < MAX ; j ++ ) { M [ i ] [ j ] = 0 ; } } let tpc = 0 , tpr = 0 ; M [ 0 ] [ 0 ] = 1 ; j = 1 ; while ( j < len1 ) { if ( factor [ j ] != factor [ j - 1 ] ) { tpr ++ ; M [ tpr ] [ 0 ] = factor [ j ] ; j ++ ; tpc = 1 ; } else { M [ tpr ] [ tpc ] = M [ tpr ] [ tpc - 1 ] * factor [ j ] ; j ++ ; tpc ++ ; } } let arr1 = new Array ( MAX ) ; let arr2 = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { arr1 [ i ] = 0 ; arr2 [ i ] = 0 ; } let l1 , l2 ; l1 = l2 = 1 ; arr1 [ 0 ] = arr2 [ 0 ] = 1 ; for ( i = 1 ; i < tpr + 1 ; i ++ ) { for ( j = 0 ; M [ i ] [ j ] != 0 ; j ++ ) { for ( k = 0 ; k < l1 ; k ++ ) { arr2 [ l2 ++ ] = arr1 [ k ] * M [ i ] [ j ] ; } } for ( j = l1 ; j < l2 ; j ++ ) { arr1 [ j ] = arr2 [ j ] ; } l1 = l2 ; } for ( i = 0 ; i < l2 ; i ++ ) { document . write ( arr2 [ i ] + "▁" ) ; } }
function countSubstring ( S , n ) { var ans = 0 ; var i = 0 ; while ( i < n ) { var cnt0 = 0 , cnt1 = 0 ; if ( S . charAt ( i ) == "0" ) { while ( i < n && S . charAt ( i ) == "0" ) { cnt0 ++ ; i ++ ; } var j = i ; while ( j < n && S . charAt ( j ) == "1" ) { cnt1 ++ ; j ++ ; } } else { while ( i < n && S . charAt ( i ) == "1" ) { cnt1 ++ ; i ++ ; } var j = i ; while ( j < n && S . charAt ( j ) == "0" ) { cnt0 ++ ; j ++ ; } } ans += Math . min ( cnt0 , cnt1 ) ; } return ans ; }
function findNumbers ( n ) { let i = 1 ; while ( i <= n ) { document . write ( ( 3 * i * ( i - 1 ) + 1 ) + "▁" ) ; i ++ ; } }
function zArray ( arr ) { let n = arr . length ; let z = new Array ( n ) ; let r = 0 , l = 0 ; for ( let k = 1 ; k < n ; k ++ ) { if ( k > r ) { r = l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } else { let k1 = k - l ; if ( z [ k1 ] < r - k + 1 ) z [ k ] = z [ k1 ] ; else { l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } } } return z ; }
function mergeArray ( A , B ) { let n = A . length ; let m = B . length ; let z = new Array ( ) ; let c = new Array ( n + m + 1 ) ; for ( let i = 0 ; i < m ; i ++ ) c [ i ] = B [ i ] ; c [ m ] = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) c [ m + i + 1 ] = A [ i ] ; z = zArray ( c ) ; return z ; }
function findZArray ( A , B , n ) { let flag = 0 ; let z = [ ] ; z = mergeArray ( A , B ) ; for ( let i = 0 ; i < z . length ; i ++ ) { if ( z [ i ] == n ) { document . write ( ( i - n - 1 ) + "▁" ) ; flag = 1 ; } } if ( flag == 0 ) { document . write ( "Not▁Found" ) ; } }
function insertNode ( root , x ) { var p = root , q = null ; while ( p != null ) { q = p ; if ( p . data < x ) p = p . right ; else p = p . left ; } if ( q == null ) p = createNode ( x ) ; else { if ( q . data < x ) q . right = createNode ( x ) ; else q . left = createNode ( x ) ; } }
function maxelpath ( q , x ) { var p = q ; var mx = - 1 ; while ( p . data != x ) { if ( p . data > x ) { mx = Math . max ( mx , p . data ) ; p = p . left ; } else { mx = Math . max ( mx , p . data ) ; p = p . right ; } } return Math . max ( mx , x ) ; }
function maximumElement ( root , x , y ) { var p = root ; while ( ( x < p . data && y < p . data ) || ( x > p . data && y > p . data ) ) { if ( x < p . data && y < p . data ) p = p . left ; else if ( x > p . data && y > p . data ) p = p . right ; } return Math . max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) ; }
function q1 ( s , i ) { if ( i == s . length ) { document . write ( "Yes" ) ; return ; } if ( s [ i ] == "a" ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
function q2 ( s , i ) { if ( i == s . length ) { document . write ( "No" ) ; return ; } if ( s [ i ] == "a" ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
function q4 ( s , i ) { if ( i == s . length ) { document . write ( "No" ) ; return ; } if ( s [ i ] == "a" ) q4 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
function q0 ( s , i ) { if ( i == s . length ) { document . write ( "No" ) ; return ; } if ( s [ i ] == "a" ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
function nthTerm ( N ) { let nth = 0 , first_term = 4 ; let pi = 1 , po = 1 ; let n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; }
function q1 ( s , i ) { document . write ( "q1->" ) ; if ( i === s . length ) { document . write ( "NO" ) ; return ; } if ( s [ i ] === "0" ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
function q2 ( s , i ) { document . write ( "q2->" ) ; if ( i === s . length ) { document . write ( "NO▁" ) ; return ; } if ( s [ i ] === "0" ) q4 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
function q3 ( s , i ) { document . write ( "q3->" ) ; if ( i === s . length ) { document . write ( "YES" ) ; return ; } if ( s [ i ] === "0" ) q4 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
function q4 ( s , i ) { document . write ( "q4->" ) ; if ( i === s . length ) { document . write ( "YES" ) ; return ; } if ( s [ i ] === "0" ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
function q0 ( s , i ) { document . write ( "q0->" ) ; if ( i === s . length ) { document . write ( "NO" ) ; return ; } if ( s [ i ] === "0" ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
function findSum ( arr , n , k ) { if ( k <= n - 2 ) return ( arr [ n - 1 ] - arr [ 0 ] ) ; return 0 ; }
function finalNum ( arr , n ) { var result = 0 ; for ( i = 0 ; i < n ; i ++ ) { result = __gcd ( result , arr [ i ] ) ; } return result ; }
function maxSubStr ( str , n ) { var count0 = 0 , count1 = 0 ; var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] == "0" ) { count0 ++ ; } else { count1 ++ ; } if ( count0 == count1 ) { cnt ++ ; } } if ( cnt == 0 ) { return - 1 ; } return cnt ; }
function isSatisfied ( str , n ) { for ( var i = 1 ; i < n ; i ++ ) { if ( ! isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) ) { return false ; } } for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) && ! isVowel ( str [ i + 1 ] ) ) { return false ; } } return true ; }
function squareDigitSum ( s ) { let lengthN = s . length ; let result = parseInt ( lengthN / 9 ) * 81 + Math . pow ( ( lengthN % 9 ) , 2 ) ; return result ; }
function getElement ( N , r , c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } let a = ( r + 1 ) * parseInt ( Math . pow ( 2 , ( r - 2 ) ) ) ; let d = parseInt ( Math . pow ( 2 , ( r - 1 ) ) ) ; c = c - r ; let element = a + d * c ; return element ; }
function computeLPSArray ( pat , M , lps ) { let len = 0 ; lps [ 0 ] = 0 ; let i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } }
function CntSubstr ( s , l ) { var hash = 0 ; for ( var i = 0 ; i < l ; i ++ ) { hash = ( hash * x + ( s [ i ] . charCodeAt ( 0 ) - 97 ) ) % mod ; } var pow_l = 1 ; for ( var i = 0 ; i < l - 1 ; i ++ ) pow_l = ( pow_l * x ) % mod ; var result = new Set ( ) ; result . add ( hash ) ; for ( var i = l ; i < s . length ; i ++ ) { hash = ( ( hash - pow_l * ( s [ i - l ] . charCodeAt ( 0 ) - 97 ) + 2 * mod ) * x + ( s [ i ] . charCodeAt ( 0 ) - 97 ) ) % mod ; result . add ( hash ) ; } document . write ( result . size ) ; }
function LengthlongestPrefixSuffix ( s ) { var n = s . length ; var lps = Array . from ( { length : n } , ( _ , i ) => 0 ) ; lps [ 0 ] = 0 ; var len = 0 ; var i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } var res = lps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; }
function no_of_characters ( M ) { let k = 1 ; while ( true ) { if ( Math . pow ( 2 , k + 1 ) - 2 < M ) k ++ ; else break ; } return k ; }
function updateString ( S , A , B ) { let l = A . length ; for ( let i = 0 ; i + l <= S . length ; i ++ ) { let curr = S . substring ( i , i + l ) ; if ( curr == A ) { let new_string = S . substring ( 0 , i ) + B + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } else { let new_string = S . substring ( 0 , i ) + A + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } } return S ; }
function findCount ( str1 , str2 ) { var len = str1 . length ; var len2 = str2 . length ; var ans = 21474836473 ; var hash1 = new Array ( 26 ) . fill ( 0 ) ; var hash2 = new Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < len ; i ++ ) hash1 [ str1 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < len2 ; i ++ ) hash2 [ str2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] ) ans = Math . min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; }
function getEndingIndex ( str , n , i ) { i ++ ; while ( i < n ) { let curr = str [ i ] ; let prev = str [ i - 1 ] ; if ( ( curr == "a" && prev == "z" ) || ( curr . charCodeAt ( 0 ) - prev . charCodeAt ( 0 ) == 1 ) ) i ++ ; else break ; } return i - 1 ; }
function printPattern ( n , m ) { if ( m > 2 * ( n + 1 ) m < n - 1 ) { document . write ( "-1" ) ; } else if ( Math . abs ( n - m ) <= 1 ) { while ( n > 0 && m > 0 ) { document . write ( "01" ) ; n -- ; m -- ; } if ( n != 0 ) { document . write ( "0" ) ; } if ( m != 0 ) { document . write ( "1" ) ; } } else { while ( m - n > 1 && n > 0 ) { document . write ( "110" ) ; m = m - 2 ; n = n - 1 ; } while ( n > 0 ) { document . write ( "10" ) ; n -- ; m -- ; } while ( m > 0 ) { document . write ( "1" ) ; m -- ; } } }
function printPermutation ( N , K ) { var res = [ ] ; var l = 1 , r = N , flag = 0 ; for ( var i = 0 ; i < K ; i ++ ) { if ( ! flag ) { res . push ( l ) ; l ++ ; } else { res . push ( r ) ; r -- ; } flag ^= 1 ; } if ( ! flag ) { for ( var i = r ; i >= l ; i -- ) res . push ( i ) ; } else { for ( var i = l ; i <= r ; i ++ ) res . push ( i ) ; } for ( var i = 0 ; i < res . length ; i ++ ) { document . write ( res [ i ] + "▁" ) ; } }
function hasDigit ( hashMap , digit ) { if ( hashMap . hasOwnProperty ( digit ) && hashMap [ digit ] > 0 ) { hashMap [ digit ] = hashMap [ digit ] - 1 ; return true ; } return false ; }
function compute_z ( s , z ) { var l = 0 , r = 0 ; var n = s . length ; for ( var i = 1 ; i <= n - 1 ; i ++ ) { if ( i > r ) { l = i ; r = i ; while ( r < n && s [ r - l ] === s [ r ] ) { r ++ ; } z [ i ] = r - l ; r -- ; } else { var k = i - l ; if ( z [ k ] < r - i + 1 ) { z [ i ] = z [ k ] ; } else { l = i ; while ( r < n && s [ r - l ] === s [ r ] ) { r ++ ; } z [ i ] = r - l ; r -- ; } } } }
function countPermutation ( a , b ) { b = b + b ; b = b . substring ( 0 , b . length - 1 ) ; var ans = 0 ; var s = a + "$" + b ; var n = s . length ; var z = new Array ( n ) . fill ( 0 ) ; compute_z ( s , z ) ; for ( var i = 1 ; i <= n - 1 ; i ++ ) { if ( z [ i ] === a . length ) { ans ++ ; } } return ans ; }
function countDecreasing ( A , n ) { var len = 1 ; for ( var i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += parseInt ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += parseInt ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
function doMatch ( A , B ) { for ( i = 0 ; i < A . length ; i ++ ) { if ( A . charAt ( i ) != "*" && B . charAt ( i ) != "*" ) { if ( A . charAt ( i ) != B . charAt ( i ) ) return 0 ; } } return 1 ; }
function printRLE ( str , typed ) { let n = str . length , m = typed . length ; let j = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] != typed [ j ] ) { return false ; } if ( isVowel ( str [ i ] ) == false ) { j ++ ; continue ; } let count1 = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count1 ++ ; i ++ ; } let count2 = 1 ; while ( j < m - 1 && typed [ j ] == str [ i ] ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) { return false ; } } return true ; }
function minimumChar ( S1 , S2 ) { let n = S1 . length ; let m = S2 . length ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < m - n + 1 ; i ++ ) { let minRemovedChar = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( S1 [ j ] != S2 [ i + j ] ) { minRemovedChar ++ ; } } ans = Math . min ( minRemovedChar , ans ) ; } return ans ; }
function fact ( N ) { let i , product = 1 ; for ( i = 1 ; i <= N ; i ++ ) product = product * i ; return product ; }
function nthTerm ( N ) { return ( N * N ) * fact ( N ) ; }
function factorial ( N ) { let fact = 1 ; for ( let i = 1 ; i <= N ; i ++ ) fact = fact * i ; return fact ; }
function nthTerm ( N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; }
function factorial ( N ) { if ( N == 0 N == 1 ) return 1 ; return N * factorial ( N - 1 ) ; }
function nthTerm ( N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; }
function check ( S1 , S2 ) { var n1 = S1 . length ; var n2 = S2 . length ; var mp = { } ; for ( var i = 0 ; i < n1 ; i ++ ) { if ( mp . hasOwnProperty ( S1 [ i ] ) ) { mp [ S1 [ i ] ] = mp [ S1 [ i ] ] + 1 ; } else { mp [ S1 [ i ] ] = 1 ; } } for ( var i = 0 ; i < n2 ; i ++ ) { if ( mp . hasOwnProperty ( S2 [ i ] ) ) { mp [ S2 [ i ] ] = mp [ S2 [ i ] ] - 1 ; } else if ( mp . hasOwnProperty ( String . fromCharCode ( S2 [ i ] . charCodeAt ( 0 ) - 1 ) ) && mp . hasOwnProperty ( String . fromCharCode ( S2 [ i ] . charCodeAt ( 0 ) - 2 ) ) ) { mp [ String . fromCharCode ( S2 [ i ] . charCodeAt ( 0 ) - 1 ) ] = mp [ String . fromCharCode ( S2 [ i ] . charCodeAt ( 0 ) - 1 ) ] - 1 ; mp [ String . fromCharCode ( S2 [ i ] . charCodeAt ( 0 ) - 2 ) ] = mp [ String . fromCharCode ( S2 [ i ] . charCodeAt ( 0 ) - 2 ) ] - 1 ; } else { return false ; } } return true ; }
function state1 ( c ) { if ( c == "t" c == "T" ) dfa = 1 ; else if ( c == "h" c == "H" ) dfa = 2 ; else dfa = 0 ; }
function state2 ( c ) { if ( c == "e" c == "E" ) dfa = 3 ; else dfa = 0 ; }
function state3 ( c ) { if ( c == "t" c == "T" ) dfa = 1 ; else dfa = 0 ; }
function isAccepted ( str ) { let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( dfa == 0 ) start ( str [ i ] ) ; else if ( dfa == 1 ) state1 ( str [ i ] ) ; else if ( dfa == 2 ) state2 ( str [ i ] ) ; else state3 ( str [ i ] ) ; } return ( dfa != 3 ) ; }
function isSubstring ( s1 , s2 ) { var M = s1 . length ; var N = s2 . length ; for ( var i = 0 ; i <= N - M ; i ++ ) { var j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 [ i + j ] != s1 [ j ] ) break ; if ( j == M ) return i ; } return - 1 ; }
function countFreq ( pat , txt ) { let M = pat . length ; let N = txt . length ; let res = 0 ; for ( let i = 0 ; i <= N - M ; i ++ ) { let j ; for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) { break ; } } if ( j == M ) { res ++ ; j = 0 ; } } return res ; }
function countPattern ( str ) { let len = str . length ; let oneSeen = false ; for ( let i = 0 ; i < len ; i ++ ) { let getChar = str [ i ] ; if ( getChar == "1" && oneSeen == true ) { if ( str [ i - 1 ] == "0" ) count ++ ; } if ( getChar == "1" && oneSeen == false ) oneSeen = true ; if ( getChar != "0" && str [ i ] != "1" ) oneSeen = false ; } return count ; }
function patternCount ( str ) { var last = str . charAt ( 0 ) ; var i = 1 , counter = 0 ; while ( i < str . length ) { if ( str . charAt ( i ) == "0" && last == "1" ) { while ( str . charAt ( i ) == "0" ) i ++ ; if ( str . charAt ( i ) == "1" ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; }
function maxPrefix ( s , t ) { let count = 0 ; for ( let i = 0 ; i < t . length ; i ++ ) { if ( count == s . length ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; }
function translate ( str ) { for ( let i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == "A" && str [ i ] == "B" ) { str [ i - 1 ] = "C" ; let j ; for ( j = i ; j < str . length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = "▁" ; } } return ; }
function isvalid ( row , col , prevRow , prevCol ) { return ( row >= 0 ) && ( row < ROW ) && ( col >= 0 ) && ( col < COL ) && ! ( row == prevRow && col == prevCol ) ; }
function getNextState ( pat , M , state , x ) { if ( state < M && x == pat [ state ] . charCodeAt ( 0 ) ) return state + 1 ; let ns , i ; for ( ns = state ; ns > 0 ; ns -- ) { if ( pat [ ns - 1 ] . charCodeAt ( 0 ) == x ) { for ( i = 0 ; i < ns - 1 ; i ++ ) if ( pat [ i ] != pat [ state - ns + 1 + i ] ) break ; if ( i == ns - 1 ) return ns ; } } return 0 ; }
function calculate ( ans ) { let dp = new Array ( 26 ) . fill ( 0 ) ; for ( let i = 0 ; i < ans . length ; ++ i ) { dp [ ans [ i ] . charCodeAt ( 0 ) - "A" . charCodeAt ( 0 ) ] ++ ; } for ( let i = 0 ; i < 26 ; ++ i ) { if ( dp [ i ] % 2 == 1 ) { return ; } } if ( maxi < ans . length ) { maxi = ans . length ; ans1 = ans ; } }
function longestString ( arr , index , str ) { if ( index == arr . length ) { return ; } longestString ( arr , index + 1 , str ) ; str += arr [ index ] ; calculate ( str ) ; longestString ( arr , index + 1 , str ) ; }
function countSubstrings ( str ) { let freq = new Array ( 3 ) . fill ( 0 )  let count = 0 ; let i = 0 ; for ( let j = 0 ; j < str . length ; j ++ ) { freq [ str . charCodeAt ( j ) - "0" . charCodeAt ( 0 ) ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str . charCodeAt ( i ++ ) - "0" . charCodeAt ( 0 ) ] -- ; } count += i ; } return count ; }
function minSwaps ( s ) { let ones = 0 , zeros = 0 ; let N = s . length ; for ( let i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == "1" ) ones ++ ; else zeros ++ ; } if ( ( N % 2 == 0 && ones != zeros ) || ( N % 2 == 1 && Math . abs ( ones - zeros ) != 1 ) ) { return - 1 ; } let ans_1 = 0 ; let j = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == "1" ) { ans_1 += Math . abs ( j - i ) ; j += 2 ; } } let ans_0 = 0 ; let k = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == "0" ) { ans_0 += Math . abs ( k - i ) ; k += 2 ; } } if ( N % 2 == 0 ) return Math . min ( ans_1 , ans_0 ) ; else { if ( ones > zeros ) return ans_1 ; else return ans_0 ; } }
function isOnesGreater ( S , N ) { let cnt0 = 0 ; let cnt1 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( S [ i ] == "1" ) cnt1 ++ ; else cnt0 ++ ; } for ( let i = 0 ; i < N ; i ++ ) { if ( S [ i ] == "1" ) { if ( i > 0 && S [ i - 1 ] == "0" ) { S [ i - 1 ] = "_" ; cnt0 -- ; } else if ( i < N && S [ i + 1 ] == "0" ) { S [ i + 1 ] = "_" ; cnt0 -- ; } } } if ( cnt1 > cnt0 ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function findString ( arr , N ) { let ans = "" ; for ( let i = 0 ; i < N ; i ++ ) { ans += arr [ i ] [ i ] == "0" ? "1" : "0" ; } return ans ; }
function waysToClearString ( S ) { let n = S . length ; choose [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= Math . floor ( n / 2 ) ; ++ i ) { choose [ i ] [ 0 ] = 1 ; for ( let j = 1 ; j <= i ; ++ j ) { choose [ i ] [ j ] = ( choose [ i - 1 ] [ j ] + choose [ i - 1 ] [ j - 1 ] ) ; } } return calc ( 0 , n - 1 , S ) ; }
function minFlips ( str ) { let count = 0 ; if ( str . length <= 2 ) { return 0 ; } for ( let i = 0 ; i < str . length - 2 ; ) { if ( str [ i ] == str [ i + 1 ] && str [ i + 2 ] == str [ i + 1 ] ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; }
function findMissingDigit ( a , b , c ) { let w = 1 ; let a_mod_11 = 0 ; for ( let i = a . length - 1 ; i >= 0 ; i -- ) { a_mod_11 = ( a_mod_11 + w * ( a [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) ) % 11 ; w = w * - 1 ; } let b_mod_11 = 0 ; w = 1 ; for ( let i = b . length - 1 ; i >= 0 ; i -- ) { b_mod_11 = ( b_mod_11 + w * ( b [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) ) % 11 ; w = w * - 1 ; } let c_mod_11 = 0 ; let xSignIsPositive = true ; w = 1 ; for ( let i = c . length - 1 ; i >= 0 ; i -- ) { if ( c [ i ] == "x" ) { xSignIsPositive = ( w == 1 ) ; } else { c_mod_11 = ( c_mod_11 + w * ( c [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) ) % 11 ; } w = w * - 1 ; } let x = ( ( a_mod_11 * b_mod_11 ) - c_mod_11 ) % 11 ; if ( ! xSignIsPositive ) { x = - x ; } return ( x % 11 + 11 ) % 11 ; }
function validInsertionstring ( S1 , S2 ) { let N = S1 . length ; let M = S2 . length ; let st = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { st . push ( S1 [ i ] ) ; if ( S1 [ i ] == S2 [ M - 1 ] ) { let idx = M - 1 ; while ( idx >= 0 ) { if ( st . length == 0 ) { return false ; } let c = st [ st . length - 1 ] ; st . pop ( ) ; if ( c != S2 [ idx ] ) { return false ; } idx -- ; } } } if ( st . length != 0 ) { return false ; } else { return true ; } }
function lengthNPalindrome ( N , K ) { var half = N / 2 ; if ( N & 1 ) { half += 1 ; } var ans = 1 ; var i ; for ( i = 1 ; i <= half ; i ++ ) { ans *= K ; K -- ; } return ans ; }
function palindromicStrings ( N , K ) { if ( N == 1 ) { return K ; } if ( N == 2 ) { return 2 * K ; } ans = 0 ; ans += ( 2 * K ) ; for ( i = 3 ; i <= N ; i ++ ) { ans += lengthNPalindrome ( i , K ) ; } return ans ; }
function LCS ( S , N , T , M , dp ) { if ( N == 0 M == 0 ) return 0 ; if ( dp [ N ] [ M ] != 0 ) return dp [ N ] [ M ] ; if ( S . charAt ( N - 1 ) == T . charAt ( M - 1 ) ) { return dp [ N ] [ M ] = 1 + LCS ( S , N - 1 , T , M - 1 , dp ) ; } return dp [ N ] [ M ] = Math . max ( LCS ( S , N - 1 , T , M , dp ) , LCS ( S , N , T , M - 1 , dp ) ) ; }
function maxlength ( s ) { let n = s . length , i , j ; let ans = 0 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { if ( s [ i ] == "1" ) { let count = 1 ; for ( j = i + 1 ; j <= n - 1 && s [ j ] == "1" ; j ++ ) count ++ ; ans = Math . max ( ans , count ) ; } } return ans ; }
function maximumK ( S ) { let N = S . length ; let ans = N ; let flag = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) { flag = 1 ; ans = Math . min ( ans , Math . max ( i + 1 , N - i - 1 ) ) ; } } if ( flag == 0 ) return 0 ; return ans ; }
function findIfPossible ( N , str ) { let countG = 0 , countF = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( str [ i ] == "G" ) countG ++ ; else countF ++ ; } if ( 2 * countF != countG ) { document . write ( "NO" ) ; } else { let id = 0 ; let flag = true ; for ( let i = 0 ; i < N ; i ++ ) { if ( str [ i ] == "G" ) { countG -- ; id ++ ; } else { countF -- ; id -- ; } if ( id < 0 ) { flag = false ; break ; } if ( countG < countF ) { flag = false ; break ; } } if ( flag ) { document . write ( "YES" ) ; } else { document . write ( "NO" ) ; } } }
function findComb ( N , M ) { var x = fact ( N + 1 )  var y = fact ( M ) return ( x * y ) }
function isPossible ( str1 , str2 ) { let arr = new Array ( 256 ) . fill ( 0 ) ; let l1 = str1 . length ; let l2 = str2 . length ; let i , j ; let possible = true ; for ( i = 0 ; i < l1 ; i ++ ) { arr [ str1 [ i ] ] = 1 ; } for ( i = 0 ; i < l2 ; i ++ ) { if ( str2 [ i ] != "▁" ) { if ( arr [ str2 [ i ] ] == 1 ) continue ; else { possible = false ; break ; } } } if ( possible ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function check ( S ) { for ( var i = 1 ; i < S . length ; i ++ ) { if ( S [ i - 1 ] == S [ i ] ) { return false ; } } return true ; }
function findMinimumSwaps ( S ) { ansSwaps = Number . MAX_VALUE ; minimumSwaps ( S , 0 , 0 ) ; if ( ansSwaps == Number . MAX_VALUE ) document . write ( "-1" ) ; else document . write ( ansSwaps ) ; }
function FindKthChar ( str , K , X ) { var ans = "▁" ; var sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) { var digit = parseInt ( str [ i ] ) ; var range = parseInt ( Math . pow ( digit , X ) ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; }
function convertToHex ( num ) { let temp = "" ; while ( num != 0 ) { let rem = num % 16 ; let c = 0 ; if ( rem < 10 ) { c = rem + 48 ; } else { c = rem + 87 ; } temp += String . fromCharCode ( c ) ; num = Math . floor ( num / 16 ) ; } return temp ; }
function minimumHammingDistance ( S , K ) { let n = S . length ; let pref = new Array ( n ) ; pref [ 0 ] = S [ 0 ] - "0" ; for ( let i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + ( S [ i ] - "0" ) ; let cnt = pref [ n - 1 ] ; let ans = cnt ; for ( let i = 0 ; i < n - K ; i ++ ) { let value = pref [ i + K - 1 ] - ( i - 1 >= 0 ? pref [ i - 1 ] : 0 ) ; ans = Math . min ( ans , cnt - value + ( K - value ) ) ; } return ans ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; else if ( n == 2 ) return true ; else if ( n % 2 == 0 ) return false ; for ( let i = 3 ; i <= Math . floor ( Math . sqrt ( n ) ) ; i += 2 ) { if ( n % i == 0 ) return false ; } return true ; }
function checkPermutation ( s1 , s2 ) { let freq = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) freq [ i ] = 0 ; for ( let ch = 0 ; ch < s1 . length ; ch ++ ) { freq [ s1 [ ch ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] -- ; } for ( let ch = 0 ; ch < s2 . length ; ch ++ ) { freq [ s2 [ ch ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } let isAllChangesPrime = true ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) { continue ; } else if ( ! isPrime ( Math . abs ( freq [ i ] ) ) ) { isAllChangesPrime = false ; break ; } } if ( isAllChangesPrime ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function minimumOperations ( S , N ) { let ans = 0 ; let cntOne = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == "0" ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } document . write ( ans ) ; }
function differentBitwiseOR ( s1 , s2 ) { let n = s1 . length ; let t00 = 0 , t10 = 0 , t01 = 0 , t11 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == "0" && s2 [ i ] == "0" ) { t00 ++ ; } if ( s1 [ i ] == "1" && s2 [ i ] == "0" ) { t10 ++ ; } if ( s1 [ i ] == "1" && s2 [ i ] == "1" ) { t11 ++ ; } if ( s1 [ i ] == "0" && s2 [ i ] == "1" ) { t01 ++ ; } } let ans = t00 * t10 + t01 * t10 + t00 * t11 ; document . write ( ans ) ; }
function RemoveCharacters ( s ) { var ans = "" ; var c = new Array ( 26 ) ; var i ; for ( i = 0 ; i < 26 ; i ++ ) c [ i ] = 0 ; var pos = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( c [ s [ i ] . charCodeAt ( ) - 97 ] == 0 ) { c [ s [ i ] . charCodeAt ( ) - 97 ] = 1 ; pos = i ; ans += s [ i ] ; } } for ( i = pos + 1 ; i < s . length ; i ++ ) { if ( s [ i ] == s [ 0 ] ) { ans += s [ i ] ; break ; } } document . write ( ans ) ; }
function changeCharacters ( S , N , K ) { let flag = 1 ; let count = 0 ; let st = new Array ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( st . length == 0 ) { if ( S [ i ] == "0" ) { flag = 0 ; break ; } count = 0 ; st . push ( S [ i ] ) ; } else { if ( S [ i ] == "0" ) { count ++ ; if ( count == K ) { st . pop ( ) ; count = 0 ; } } else { count = 0 ; } } } if ( flag == 1 ) document . write ( "YES" ) ; else document . write ( "NO" ) ; }
function findSubsequence ( S , ch ) { let N = S . length ; let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ch ) { ans ++ ; ch = String . fromCharCode ( ch . charCodeAt ( 0 ) + 1 ) ; } } return ans ; }
function findMaxSubsequence ( S ) { let ans = 0 ; for ( let ch = "a" . charCodeAt ( 0 ) ; ch <= "z" . charCodeAt ( 0 ) ; ch ++ ) { ans = Math . max ( ans , findSubsequence ( S , String . fromCharCode ( ch ) ) ) ; } return ans ; }
function minOpsToEmptyString ( s ) { var ans = Number . MIN_VALUE ; var cn0 = 0 ; var cn1 = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == "0" ) { if ( cn1 > 0 ) cn1 -- ; cn0 ++ ; } else { if ( cn0 > 0 ) cn0 -- ; cn1 ++ ; } ans = Math . max ( ans , Math . max ( cn0 , cn1 ) ) ; } document . write ( ans ) ; }
function prefixDivisble ( n ) { let i = 1 ; while ( n > 0 ) { if ( n % i != 0 ) return false ; n = parseInt ( n / 10 ) ; i ++ ; } return true ; }
function isPrime ( num ) { let flag = false ; if ( num > 1 ) { for ( let i = 2 ; i < num ; i ++ ) { if ( ( num % i ) == 0 ) { flag = true ; break ; } } } if ( flag ) return false ; else return true ; }
function order ( x ) { let n = 0 ; while ( x != 0 ) { n = n + 1 ; x = x / 10 ; } return n ; }
function isArmstrong ( x ) { let n = order ( x ) ; let temp = x ; let sum1 = 0 ; while ( temp != 0 ) { let r = temp % 10 ; sum1 = sum1 + Math . pow ( r , n ) ; temp = temp / 10 ; } return ( sum1 == x ) ; }
function count_armstrong ( li ) { let c = 0 ; for ( let ele of li ) { let val = 0 ; for ( let che of ele ) val += che . charCodeAt ( 0 ) ; if ( isArmstrong ( val ) ) c += 1 ; } return c ; }
function count_prime ( li ) { let c = 0 ; for ( let ele of li ) { let val = 0 ; for ( let che of ele ) val += che . charCodeAt ( 0 ) ; if ( isPrime ( val ) ) c += 1 ; } return c ; }
function findMinimumCost ( s , N ) { let count_1 = 0 , count_0 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( s [ i ] == "1" ) count_1 ++ ; else count_0 ++ ; } let k = Math . abs ( count_0 - count_1 ) ; if ( count_1 == N count_0 == N ) document . write ( - 1 ) ; else document . write ( k / 2 ) ; }
function countOccurrences ( S , X , Y ) { let count = 0 ; let N = S . length , A = X . length ; let B = Y . length ; for ( let i = 0 ; i < N ; i ++ ) { if ( S . substr ( i , B ) == Y ) count ++ ; if ( S . substr ( i , A ) == X ) document . write ( count , "▁" ) ; } }
function findLength ( str , n ) { let pre = Array . from ( { length : n } , ( _ , i ) => 0 ) ; let post = Array . from ( { length : n } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { pre [ i ] = 0 ; post [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { if ( i != 0 ) { pre [ i ] += pre [ i - 1 ] ; } if ( str [ i ] == "1" ) { pre [ i ] += 1 ; } } for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( i != n - 1 ) post [ i ] += post [ i + 1 ] ; if ( str [ i ] == "0" ) post [ i ] += 1 ; } let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , pre [ i ] + post [ i ] ) ; } return ans ; }
function countSubstring ( S , N ) { var prevSum = new Map ( ) ; var res = 0 ; var currentSum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( S [ i ] >= "A" && S [ i ] <= "Z" ) { currentSum ++ ; } else currentSum -- ; if ( currentSum == 0 ) res ++ ; if ( prevSum . has ( currentSum ) ) { res += ( prevSum . get ( currentSum ) ) ; } if ( prevSum . has ( currentSum ) ) prevSum . set ( currentSum , prevSum . get ( currentSum ) + 1 ) else prevSum . set ( currentSum , 1 ) } return res ; }
function checkforSubsequence ( S , target ) { var s = [ ] ; for ( var i = 0 ; i < target . length ; i ++ ) { s . push ( target [ i ] ) ; } for ( var i = S . length - 1 ; i >= 0 ; i -- ) { if ( s . length == 0 ) { document . write ( "Yes" ) ; return ; } if ( S [ i ] == s [ s . length - 1 ] ) { s . pop ( ) ; } } if ( s . length == 0 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function makeDFA ( ) { dfa [ 0 ] [ 0 ] = 1 ; dfa [ 1 ] [ 0 ] = 1 ; dfa [ 1 ] [ 2 ] = 3 ; dfa [ 1 ] [ 3 ] = 2 ; dfa [ 1 ] [ 4 ] = 6 ; dfa [ 3 ] [ 0 ] = 4 ; dfa [ 4 ] [ 0 ] = 4 ; dfa [ 4 ] [ 3 ] = 5 ; dfa [ 4 ] [ 4 ] = 6 ; dfa [ 6 ] [ 0 ] = 8 ; dfa [ 6 ] [ 1 ] = 7 ; dfa [ 7 ] [ 0 ] = 8 ; dfa [ 8 ] [ 0 ] = 8 ; dfa [ 8 ] [ 3 ] = 9 ; }
function buildDFA ( ) { for ( let i = 0 ; i < 11 ; i ++ ) for ( let j = 0 ; j < 5 ; j ++ ) dfa [ i ] [ j ] = 10 ; makeDFA ( ) ; }
function checkDFA ( s ) { buildDFA ( ) ; let currentstate = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( digits . indexOf ( s [ i ] ) != - 1 ) currentstate = dfa [ currentstate ] [ 0 ] ; else if ( sign . indexOf ( s [ i ] ) != - 1 ) currentstate = dfa [ currentstate ] [ 1 ] ; else if ( dot . indexOf ( s [ i ] ) != - 1 ) currentstate = dfa [ currentstate ] [ 2 ] ; else if ( ex . indexOf ( s [ i ] ) != - 1 ) currentstate = dfa [ currentstate ] [ 4 ] ; else currentstate = dfa [ currentstate ] [ 3 ] ; } if ( currentstate == 1 currentstate == 4 currentstate == 8 ) { document . write ( "Unsigned▁integer" ) ; } else { document . write ( "Not▁an▁unsigned▁integer" ) ; } }
function getString ( N ) { let ans = ""  while ( N >= 26 ) { ans += "z" N -= 26 } ans += String . fromCharCode ( N + "a" . charCodeAt ( 0 ) - 1 )  return ans }
function subString ( s , n ) { let hash = new Map ( ) ; hash . set ( 0 , 1 ) ; let pre = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { pre ^= ( 1 << s [ i ] . charCodeAt ( 0 ) - 97 ) ; if ( ! hash . has ( pre ) ) hash . set ( pre , 0 ) ; count += ( hash . get ( pre ) ) ; hash . set ( pre , hash . get ( pre ) == null ? 0 : hash . get ( pre ) + 1 ) ; } return count ; }
function countSamePrefixSuffix ( s , n ) { var prefix = "" ; for ( let i = 0 ; i < n - 1 ; i ++ ) { prefix += s . charAt ( i ) ; var suffix = s . substring ( n - 1 - i , n ) ; if ( prefix == suffix ) { document . write ( prefix . length + "▁" ) ; } } }
function atleastkDistinctChars ( s , k ) { let n = s . length ; let mp = new Map ( ) ; let begin = 0 , end = 0 ; let ans = 0 ; while ( end < n ) { let c = s [ end ] ; if ( mp . has ( c ) ) mp . set ( c , mp . get ( c ) + 1 ) ; else mp . set ( c , 1 ) ; end ++ ; while ( mp . size >= k ) { let pre = s [ begin ] ; mp . set ( pre , mp . get ( pre ) - 1 ) ; if ( mp . get ( pre ) == 0 ) { mp . delete ( pre ) ; } ans += s . length - end + 1 ; begin ++ ; } } document . write ( ans ) ; }
function minimumMoves ( s , n , k ) { if ( n & 1 ) { document . write ( "No" ) ; return ; } var countOpen = 0 ; var i ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == "(" ) countOpen ++ ; } var countClose = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ")" ) countClose ++ ; } ; if ( countOpen != countClose ) { document . write ( "No" ) ; return ; } var ans = 0 ; var cnt = 0 ; for ( i = 0 ; i < n ; ++ i ) { if ( s [ i ] == "(" ) ++ cnt ; else { -- cnt ; if ( cnt < 0 ) { cnt = 0 ; ++ ans ; } } } if ( ans <= k ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function inOrder ( root ) { if ( root == null ) return ; var cur = leftMost ( root ) ; while ( cur != null ) { document . write ( cur . key + "▁" ) ; if ( cur . isThreaded ) cur = cur . right ; else cur = leftMost ( cur . right ) ; } }
function countFrequency ( S , N ) { var freq = new Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < N ; i ++ ) { freq [ S [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } for ( var i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] === 0 ) continue ; var lg = parseInt ( Math . log2 ( freq [ i ] ) ) ; var a = Math . pow ( 2 , lg ) ; if ( a === freq [ i ] ) { while ( freq [ i ] -- ) document . write ( String . fromCharCode ( i + "a" . charCodeAt ( 0 ) ) ) ; } } }
function buildTree ( s , tree , start , end , treenode ) { if ( start == end ) { tree [ treenode ] . square_sum = Math . pow ( s [ start ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) + 1 , 2 ) ; return ; } let mid = start + Math . floor ( ( end - start ) / 2 ) ; buildTree ( s , tree , start , mid , 2 * treenode ) ; buildTree ( s , tree , mid + 1 , end , 1 + 2 * treenode ) ; tree [ treenode ] . square_sum = tree [ ( 2 * treenode ) ] . square_sum + tree [ ( 2 * treenode ) + 1 ] . square_sum ; }
function querySquareSum ( tree , start , end , treenode , l , r ) { if ( ( l > end ) || ( r < start ) ) { return 0 ; } if ( ( l <= start ) && ( r >= end ) ) { return tree [ treenode ] . square_sum ; } let mid = start + Math . floor ( ( end - start ) / 2 ) ; let X = querySquareSum ( tree , start , mid , 2 * treenode , l , r ) ; let Y = + querySquareSum ( tree , mid + 1 , end , 1 + 2 * treenode , l , r ) ; return X + Y ; }
function canSplit ( S ) { let frequency = new Array ( 26 ) . fill ( 0 )  let cnt_singles = 0  let k = 0  for ( let i = 0 ; i < S . length ; i ++ ) { frequency [ S . charCodeAt ( i ) - "a" . charCodeAt ( 0 ) ] += 1 } let odd = 0  let eve = 0  for ( let i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] ) { odd += ( frequency [ i ] & 1 ) } } if ( eve >= odd ) { document . write ( "Yes" ) } else { document . write ( "No" ) } }
function isPossible ( S , R , N ) { var cntl = 0 , cntr = 0 ; var cntu = 0 , cntd = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( S [ i ] == "L" ) cntl ++ ; else if ( S [ i ] == "R" ) cntr ++ ; else if ( S [ i ] == "U" ) cntu ++ ; else cntd ++ ; } if ( Math . max ( Math . max ( cntl , cntr ) , Math . max ( cntu , cntd ) ) >= R ) return "Yes" ; var mp = new Map ( ) ; var r_square = R * R ; for ( var i = 1 ; i * i <= r_square ; i ++ ) { mp . set ( i * i , i ) ; if ( mp . has ( r_square - i * i ) ) { if ( Math . max ( cntl , cntr ) >= mp . get ( r_square - i * i ) && Math . max ( cntu , cntd ) >= i ) return "Yes" ; if ( Math . max ( cntl , cntr ) >= i && Math . max ( cntu , cntd ) >= mp . get ( r_square - i * i ) ) return "Yes" ; } } return "No" ; }
function inorder ( root ) { var leftdone = false ; while ( root != null ) { if ( ! leftdone ) { while ( root . left != null ) { root = root . left ; } } document . write ( root . key + "▁" ) ; leftdone = true ; if ( root . right != null ) { leftdone = false ; root = root . right ; } else if ( root . parent != null ) { while ( root . parent != null && root == root . parent . right ) root = root . parent ; if ( root . parent == null ) break ; root = root . parent ; } else break ; } }
function findDuplicate ( arr , n , k ) { var freq = Array . from ( { length : MAX } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { document . write ( "Out▁of▁range" ) ; return - 1 ; } freq [ arr [ i ] ] += 1 ; } for ( var i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == k ) return i ; } return - 1 ; }
function nearestPowerOfTwo ( S ) { var N = S . length ; var freq = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( freq . has ( S [ i ] ) ) { freq . set ( S [ i ] , freq . get ( S [ i ] ) + 1 ) } else { freq . set ( S [ i ] , 1 ) } } nearestPowerOfTwoUtil ( freq ) ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function lcm ( a , b ) { return ( a / gcd ( a , b ) ) * b ; }
function canMakeSame ( s1 , s2 ) { var ans = 0 ; if ( s1 . length != s2 . length ) { return - 1 ; } var N = s1 . length ; for ( var i = 0 ; i < N ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { while ( i < s1 . length && s1 [ i ] != s2 [ i ] ) { i ++ ; } ans ++ ; } } return ans ; }
function printSorted ( arr , start , end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; document . write ( arr [ start ] + "▁" ) ; printSorted ( arr , start * 2 + 2 , end ) ; }
function minDeletions ( str ) { var fre = new Array ( 26 ) ; fre . fill ( 0 ) ; var n = str . length ; for ( var i = 0 ; i < n ; i ++ ) { fre [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] += 1 ; } var count = 0 ; for ( var i = 0 ; i < 26 ; i ++ ) { if ( fre [ i ] % 2 ) { count += 1 ; } } if ( count == 0 count == 1 ) { return 0 ; } else { return count - 1 ; } }
function countTotalFrequencies ( S1 , S2 ) { var bset = new Set ( ) ; for ( var i = 0 ; i < S1 . length ; i ++ ) { bset . add ( S1 [ i ] ) ; } var count = 0 ; for ( var i = 0 ; i < S2 . length ; i ++ ) { if ( bset . has ( S2 [ i ] ) ) count += 1 ; } document . write ( count ) ; }
function min_length ( str ) { var n = str . length ; var total_zeros = 0 ; var total_ones = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] == "0" ) total_zeros ++ ; else total_ones ++ ; } var ans = Math . min ( total_zeros , total_ones ) ; var cur_zeros = 0 , cur_ones = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == "0" ) cur_zeros ++ ; else cur_ones ++ ; ans = Math . min ( ans , cur_ones + ( total_zeros - cur_zeros ) ) ; } document . write ( ans ) ; }
function findWinner ( a , n ) { let v = [ ] ; let c = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == "0" ) { c ++ ; } else { if ( c != 0 ) v . push ( c ) ; c = 0 ; } } if ( c != 0 ) v . push ( c ) ; if ( v . length == 0 ) { document . write ( "Player▁B" ) ; return ; } if ( v . length == 1 ) { if ( ( v [ 0 ] & 1 ) != 0 ) document . write ( "Player▁A" ) ; else document . write ( "Player▁B" ) ; return ; } let first = Number . MIN_VALUE ; let second = Number . MIN_VALUE ; for ( let i = 0 ; i < v . length ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } if ( ( first & 1 ) != 0 && parseInt ( ( first + 1 ) / 2 , 10 ) > second ) document . write ( "Player▁A" ) ; else document . write ( "Player▁B" ) ; }
function minimumSwaps ( s , l , r , k ) { var n = s . length ; var tot_ones = 0 , tot_zeros = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == "1" ) tot_ones ++ ; else tot_zeros ++ ; } var ones = 0 , zeros = 0 , sum = 0 ; for ( var i = l - 1 ; i < r ; i ++ ) { if ( s . charAt ( i ) == "1" ) { ones ++ ; sum ++ ; } else zeros ++ ; } var rem_ones = tot_ones - ones ; var rem_zeros = tot_zeros - zeros ; if ( k >= sum ) { var rem = k - sum ; if ( zeros >= rem && rem_ones >= rem ) return rem ; } else if ( k < sum ) { var rem = sum - k ; if ( ones >= rem && rem_zeros >= rem ) return rem ; } return - 1 ; }
function longHelper ( freq1 , freq2 ) { for ( let i = 0 ; i < SIZE ; ++ i ) { if ( freq1 [ i ] != freq2 [ i ] ) { return false ; } } return true ; }
function longCommomPrefixAnagram ( s1 , s2 , n1 , n2 ) { let freq1 = new Array ( 26 ) ; freq1 . fill ( 0 ) ; let freq2 = new Array ( 26 ) ; freq2 . fill ( 0 ) ; let ans = 0 ; let mini_len = Math . min ( n1 , n2 ) ; for ( let i = 0 ; i < mini_len ; ++ i ) { freq1 [ s1 [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ++ ; freq2 [ s2 [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ++ ; if ( longHelper ( freq1 , freq2 ) ) { ans = i + 1 ; } } document . write ( ans ) ; }
function getMin ( arr ) { var minSum = 1000000000 ; var i , j ; for ( i = 0 ; i < 10 ; i ++ ) { var curSum = 0 ; for ( j = 0 ; j < arr . length ; j ++ ) { curSum += remove ( arr [ j ] , i ) ; } minSum = Math . min ( minSum , curSum ) ; } document . write ( minSum ) ; }
function isReducible ( str ) { let N = str . length ; let s = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { if ( str [ i ] == "1" ) s . push ( str [ i ] ) ; else if ( s . length > 0 ) s . pop ( ) ; else return false ; } if ( s . length == 0 ) { return true ; } else { return false ; } }
function checkPalindrome ( s ) { let low = 0 , high = s . length - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; }
function populateNumber ( ) { Ans [ index ++ ] = ( 2 ) ; Ans [ index ++ ] = ( 5 ) ; var x = 5 ; var inf = 1000000000001 ; while ( x < inf ) { x *= 2 ; Ans [ index ++ ] = ( x ) ; x = x * 2 + 1 ; Ans [ index ++ ] = ( x ) ; } }
function checkString ( N ) { populateNumber ( ) ; for ( i = 0 ; i < index ; i ++ ) { if ( Ans [ i ] == N ) { document . write ( "Yes" ) ; return ; } } document . write ( "No" ) ; }
function DFA ( str , N ) { if ( N <= 1 ) { document . write ( "No" ) ; return ; } let count = 0 ; if ( str [ 0 ] == "C" ) { count ++ ; for ( let i = 1 ; i < N ; i ++ ) { if ( str [ i ] == "A" str [ i ] == "B" ) count ++ ; else break ; } } else { document . write ( "No" ) ; return ; } if ( count == N ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function balanced ( small , caps ) { for ( let i = 0 ; i < 26 ; i ++ ) { if ( small [ i ] != 0 && ( caps [ i ] == 0 ) ) return false ; else if ( ( small [ i ] == 0 ) && ( caps [ i ] != 0 ) ) return false ; } return true ; }
function GCD ( lena , lenb ) { if ( lena == 0 ) return lenb ; if ( lenb == 0 ) return lena ; if ( lena == lenb ) return lena ; if ( lena > lenb ) return GCD ( lena - lenb , lenb ) ; return GCD ( lena , lenb - lena ) ; }
function cntBalancedParenthesis ( s , N ) { var cntPairs = 0 ; var cntCurly = 0 ; var cntSml = 0 ; var cntSqr = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == "{" ) { cntCurly ++ ; } else if ( s . charAt ( i ) == "(" ) { cntSml ++ ; } else if ( s . charAt ( i ) == "[" ) { cntSqr ++ ; } else if ( s . charAt ( i ) == "}" && cntCurly > 0 ) { cntCurly -- ; cntPairs ++ ; } else if ( s . charAt ( i ) == ")" && cntSml > 0 ) { cntSml -- ; cntPairs ++ ; } else if ( s . charAt ( i ) == "]" && cntSqr > 0 ) { cntSqr -- ; cntPairs ++ ; } } document . write ( cntPairs ) ; }
function canBeBalanced ( sequence ) { if ( sequence . length % 2 == 1 ) return false ; let stack_ = [ ] ; let stack2_ = [ ] ; let countOpen = 0 , countClosed = 0 ; let countSymbol = 0 ; for ( let i = 0 ; i < sequence . length ; i ++ ) { if ( sequence [ i ] == ")" ) { countClosed ++ ; if ( stack_ . length == 0 ) { return false ; } else { stack_ . pop ( ) ; } } else { if ( sequence [ i ] == "$" ) { countSymbol ++ ; } else { countOpen ++ ; } stack_ . push ( sequence [ i ] ) ; } } for ( let i = sequence . length - 1 ; i >= 0 ; i -- ) { if ( sequence [ i ] == "(" ) { if ( stack2_ . length == 0 ) { return false ; } else { stack2_ . pop ( ) ; } } else { stack2_ . push ( sequence [ i ] ) ; } } let extra = Math . abs ( countClosed - countOpen ) ; if ( countSymbol < extra ) { return false ; } else { countSymbol -= extra ; if ( countSymbol % 2 == 0 ) { return true ; } } return false ; }
function maximum_pallindromic ( arr ) { var res = 0 ; var c1 = 0 , c2 = 0 ; for ( var i = 0 ; i < 26 ; i ++ ) { res += parseInt ( arr [ i ] / 3 ) ; arr [ i ] = ( arr [ i ] % 3 ) ; if ( arr [ i ] == 1 ) c1 ++ ; else if ( arr [ i ] == 2 ) c2 ++ ; } res += Math . min ( c1 , c2 ) ; var t = Math . min ( c1 , c2 ) ; c1 -= t ; c2 -= t ; res += 2 * parseInt ( c2 / 3 ) ; c2 %= 3 ; res += parseInt ( c2 / 2 ) ; document . write ( res ) ; }
function inorder ( root ) { if ( root != null ) { inorder ( root . left ) ; document . write ( root . key + "(" + root . count + ")▁" ) ; inorder ( root . right ) ; } }
function query ( BIT , idx , i ) { let ans = 0 ; while ( i > 0 ) { ans += BIT [ idx ] [ i ] ; i = i - ( i & ( - i ) ) ; } return ans ; }
function minOperation ( arr , N ) { var cntMinOP = 0 ; var M = arr [ 0 ] . length ; var hash = Array . from ( Array ( 256 ) , ( ) => Array ( M ) . fill ( 0 ) ) ; for ( var i = 0 ; i < N ; i ++ ) { for ( var j = 0 ; j < M ; j ++ ) { hash [ arr [ i ] [ j ] . charCodeAt ( 0 ) ] [ j ] ++ ; } } for ( var i = 0 ; i < M ; i ++ ) { var Sum = 0 ; var Max = 0 ; for ( var j = 0 ; j < 256 ; j ++ ) { Sum += hash [ j ] [ i ] ; Max = Math . max ( Max , hash [ j ] [ i ] ) ; } cntMinOP += ( Sum - Max ) ; } return cntMinOP ; }
function find_Winner ( arr , N ) { var Q = Array . from ( Array ( N ) , ( ) => Array ( ) )  var M = arr . length ; for ( var i = 0 ; i < M ; i ++ ) { var len = arr [ i ] . length ; for ( var j = 0 ; j < len ; j ++ ) { Q [ i ] . push ( arr [ i ] [ j ] - 1 ) ; } } var player = 0 ; while ( Q [ player ] . length > 0 ) { var nextPlayer = Q [ player ] [ 0 ] - "0" ; Q [ player ] . shift ( ) ; player = nextPlayer ; } document . write ( "Player▁" + ( player + 1 ) ) ; }
function longestSubstring ( s ) { let dp = new Array ( 1024 ) . fill ( 1 ) ; let res = 0 , mask = 0 ; dp [ 0 ] = - 1 ; for ( let i = 0 ; i < s . length ; ++ i ) { mask ^= 1 << ( s [ i ] - "0" ) ; res = Math . max ( res , i - dp [ mask ] ) ; for ( let j = 0 ; j <= 9 ; ++ j ) res = Math . max ( res , i - dp [ mask ^ ( 1 << j ) ] ) ; dp [ mask ] = Math . min ( dp [ mask ] , i ) ; } return res ; }
function countStrings ( S , list ) { let valid = new Set ( ) ; for ( let x of S ) { valid . add ( x ) ; } let cnt = 0 ; for ( let i = 0 ; i < list . length ; i ++ ) { let j = 0 ; for ( j = 0 ; j < list [ i ] . length ; j ++ ) { if ( valid . has ( list [ i ] [ j ] ) ) continue ; else break ; } if ( j == list [ i ] . length ) cnt ++ ; } return cnt ; }
function inorder ( root ) { if ( root != null ) { inorder ( root . left ) ; document . write ( root . key + "▁" ) ; inorder ( root . right ) ; } }
function countStrings ( s , k ) { var ans = 1 ; var len = s . length ; var flag = 0 ; var start_ind ; for ( var i = 0 ; i < len - 1 ; i ++ ) { if ( ( s [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) + s [ i + 1 ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) == k && flag == 0 ) { flag = 1 ; start_ind = i ; } if ( flag == 1 && ( s [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) + s [ i + 1 ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) != k ) { flag = 0 ; if ( ( i - start_ind + 1 ) % 2 != 0 ) ans *= ( i - start_ind + 1 - 1 ) / 2 + 1 ; } } if ( flag == 1 && ( len - start_ind ) % 2 != 0 ) ans *= parseInt ( ( len - start_ind ) / 2 ) + 1 ; document . write ( ans ) ; }
function minLength ( str , N , K , M ) { var stackOfChar = [ ] ; for ( var i = 0 ; i < N ; i ++ ) { stackOfChar . push ( str [ i ] ) ; if ( stackOfChar . length >= M ) { var l = "" ; for ( var j = M - 1 ; j >= 0 ; j -- ) { if ( K [ j ] != stackOfChar [ stackOfChar . length - 1 ] ) { var f = 0 ; while ( f != l . length ) { stackOfChar . push ( l [ f ] ) ; f ++ ; } break ; } else { l = stackOfChar [ stackOfChar . length - 1 ] + l ; stackOfChar . pop ( ) ; } } } } return stackOfChar . length ; }
function printSequences ( combinations ) { for ( var s of combinations ) { document . write ( s + "▁" ) ; } }
function generateCombinations ( s , n ) { for ( var i = 0 ; i < s . length ; i ++ ) { combination += s [ i ] ; var x = parseInt ( combination ) ; if ( x <= n ) { combinations . push ( combination ) ; generateCombinations ( s , n ) ; } combination = combination . substring ( 0 , combination . length - 1 ) ; } }
function compute_hash ( str ) { let p = 31 ; let MOD = 1e9 + 7 ; let hash_val = 0 ; let mul = 1 ; for ( let i = 0 ; i < str . length ; i ++ ) { let ch = str [ i ] ; hash_val = ( hash_val + ( ch . charCodeAt ( ) - "a" . charCodeAt ( ) + 1 ) * mul ) % MOD ; mul = ( mul * p ) % MOD ; } return hash_val ; }
function distinct_str ( arr , n ) { let hash = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { hash [ i ] = compute_hash ( arr [ i ] ) ; } hash . sort ( function ( a , b ) { return a - b } ) ; let cntElem = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( hash [ i ] != hash [ i - 1 ] ) { cntElem ++ ; } } return cntElem ; }
function isEqualStrings ( arr , N ) { let M = arr [ 0 ] . length ; let cntFreq = new Array ( 256 ) . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { cntFreq [ i ] = 0 ; } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { cntFreq [ arr [ i ] [ j ] - "a" ] += 1 ; } } for ( let i = 0 ; i < 256 ; i ++ ) { if ( cntFreq [ i ] % N != 0 ) { return false ; } } return true ; }
function minimumOperations ( s , n ) { var mp = { } ; for ( var i = 0 ; i < n ; i ++ ) { if ( mp . hasOwnProperty ( s [ i ] ) ) { mp [ s [ i ] ] . push ( i ) ; } else { mp [ s [ i ] ] = [ ] ; mp [ s [ i ] ] . push ( i ) ; } } var ans = 2147483647 ; for ( const [ key , value ] of Object . entries ( mp ) ) { var curr = 0 ; var prev = 0 ; var first = true ; for ( const index of value ) { if ( first ) { if ( index > 0 ) { curr ++ ; } prev = index ; first = false ; } else { if ( index !== prev + 1 ) { curr ++ ; } prev = index ; } } if ( prev !== n - 1 ) { curr ++ ; } ans = Math . min ( ans , curr ) ; } document . write ( ans ) ; }
function PrintStack ( s ) { if ( s . length == 0 ) return ; let x = s [ s . length - 1 ] ; s . pop ( ) ; PrintStack ( s ) ; document . write ( x ) ; s . push ( x ) ; }
function minString ( s ) { let Stack = [ ] ; Stack . push ( s [ 0 ] ) ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( Stack . length == 0 ) { Stack . push ( s [ i ] ) ; } else { if ( Stack [ Stack . length - 1 ] == s [ i ] ) { Stack . pop ( ) ; } else { Stack . push ( s [ i ] ) ; } } } PrintStack ( Stack ) ; }
function SieveOfEratosthenes ( prime , n ) { for ( let i = 0 ; i <= n ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( let j = 2 ; i * j <= n ; j ++ ) { prime [ i * j ] = false ; } } } }
function removePrimeFrequencies ( s ) { var n = s . length ; var prime = new Array ( n + 1 ) ; SieveOfEratosthenes ( prime , n ) ; var m = { } ; for ( let i = 0 ; i < s . length ; i ++ ) m [ s [ i ] ] = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { m [ s [ i ] ] ++ ; } var new_string = "" ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( prime [ m [ s [ i ] ] ] ) continue ; new_string += s [ i ] ; } console . log ( new_string ) ; }
function minMaxDigits ( str , N ) { let arr = [ ] ; for ( let i = 0 ; i < N ; i ++ ) arr [ i ] = ( str [ i ] - "0" ) % 3 ; let zero = 0 , one = 0 , two = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero ++ ; if ( arr [ i ] == 1 ) one ++ ; if ( arr [ i ] == 2 ) two ++ ; } let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum = ( sum + arr [ i ] ) % 3 ; } if ( sum == 0 ) { document . write ( 0 + "▁" ) ; } if ( sum == 1 ) { if ( ( one != 0 ) && ( N > 1 ) ) document . write ( 1 + "▁" ) ; else if ( two > 1 && N > 2 ) document . write ( 2 + "▁" ) ; else document . write ( - 1 + "▁" ) ; } if ( sum == 2 ) { if ( two != 0 && N > 1 ) document . write ( 1 + "▁" ) ; else if ( one > 1 && N > 2 ) document . write ( 2 + "▁" ) ; else document . write ( - 1 + "▁" ) ; } if ( zero > 0 ) document . write ( N - 1 + "▁" ) ; else if ( one > 0 && two > 0 ) document . write ( N - 2 + "▁" ) ; else if ( one > 2 two > 2 ) document . write ( N - 3 + "▁" ) ; else document . write ( - 1 + "▁" ) ; }
function findDisStr ( arr , N ) { let DistString = new Set ( ) ; for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( ! DistString . has ( arr [ i ] ) ) { DistString . add ( arr [ i ] ) ; } } for ( let String of DistString ) { document . write ( String + "▁" ) ; } }
function count_of_accident ( a , b ) { let n = a . length , m = b . length ; if ( n > m ) return ( m * ( m + 1 ) ) / 2 ; else return ( n * ( n + 1 ) ) / 2 + ( m - n ) * n ; }
function count_of_collision ( a , b ) { let n = a . length , m = b . length ; let answer = 0 ; let count_of_truck_in_lane_b = 0 ; for ( let i = 0 ; i < m ; i ++ ) if ( b [ i ] == "T" ) count_of_truck_in_lane_b ++ ; for ( let i = 0 ; i < n && i < m ; i ++ ) { if ( a [ i ] == "T" ) answer += count_of_truck_in_lane_b ; if ( b [ i ] == "T" ) count_of_truck_in_lane_b -- ; } return answer ; }
function arcIntersection ( S , len ) { var stk = [ ] ; for ( var i = 0 ; i < len ; i ++ ) { stk . push ( S [ i ] ) ; if ( stk . length >= 2 ) { var temp = stk [ stk . length - 1 ] ; stk . pop ( ) ; if ( stk [ stk . length - 1 ] == temp ) { stk . pop ( ) ; } else { stk . push ( temp ) ; } } } if ( stk . length == 0 ) return 1 ; return 0 ; }
function findMinimumChanges ( N , K , S ) { var ans = 0 ; for ( var i = 0 ; i < parseInt ( ( K + 1 ) / 2 ) ; i ++ ) { var mp = new Map ( ) ; for ( var j = i ; j < N ; j += K ) { if ( mp . has ( S [ j ] ) ) { mp . set ( S [ j ] , mp . get ( S [ j ] ) + 1 ) ; } else { mp . set ( S [ j ] , 1 ) ; } } for ( var j = N - i - 1 ; j >= 0 ; j -= K ) { if ( ( K & 1 ) && i == parseInt ( K / 2 ) ) break ; if ( mp . has ( S [ j ] ) ) { mp . set ( S [ j ] , mp . get ( S [ j ] ) + 1 ) ; } else { mp . set ( S [ j ] , 1 ) ; } } var curr_max = - 1000000000 ; mp . forEach ( ( value , key ) => { curr_max = Math . max ( curr_max , value ) ; } ) ; if ( K & 1 && i == parseInt ( K / 2 ) ) ans += ( parseInt ( N / K ) - curr_max ) ; else ans += ( parseInt ( N / K ) * 2 - curr_max ) ; } return ans ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
function checkValidDFA ( s ) { var final_state = 0 ; var previous_state = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( ( s [ i ] === "0" && previous_state === 0 ) || ( s [ i ] === "1" && previous_state === 3 ) ) { final_state = 1 ; } else if ( ( s [ i ] === "0" && previous_state === 3 ) || ( s [ i ] === "1" && previous_state === 0 ) ) { final_state = 2 ; } else if ( ( s [ i ] === "0" && previous_state === 1 ) || ( s [ i ] === "1" && previous_state === 2 ) ) { final_state = 0 ; } else if ( ( s [ i ] === "0" && previous_state === 2 ) || ( s [ i ] === "1" && previous_state === 1 ) ) { final_state = 3 ; } previous_state = final_state ; } if ( final_state === 3 ) { document . write ( "Accepted" ) ; } else { document . write ( "Not▁Accepted" ) ; } }
function findFraction ( s ) { let be_deci = "" , af_deci = "" , reccu = "" ; let x = true , y = false , z = false ; for ( let i = 0 ; i < s . length ; ++ i ) { if ( s [ i ] == "." ) { x = false ; y = true ; continue ; } if ( s [ i ] == "(" ) { z = true ; y = false ; continue ; } if ( x ) be_deci += s [ i ] ; if ( y ) af_deci += s [ i ] ; if ( z ) { for ( ; i < s . length && s [ i ] != ")" ; ++ i ) reccu += s [ i ] ; break ; } } let num_be_deci = parseInt ( be_deci ) ; let num_af_deci = 0 ; if ( af_deci . length != 0 ) num_af_deci = parseInt ( af_deci ) ; let numr = num_be_deci * Math . pow ( 10 , af_deci . length ) + num_af_deci ; let deno = Math . pow ( 10 , af_deci . length ) ; if ( reccu . length == 0 ) { let gd = __gcd ( numr , deno ) ; document . write ( numr / gd + "▁/▁" + deno / gd ) ; } else { let reccu_num = parseInt ( reccu ) ; let numr1 = numr * Math . pow ( 10 , reccu . length ) + reccu_num ; let deno1 = deno * Math . pow ( 10 , reccu . length ) ; let res_numr = numr1 - numr , res_deno = deno1 - deno ; let gd = __gcd ( res_numr , res_deno ) ; document . write ( res_numr / gd + "▁/▁" + res_deno / gd ) ; } }
function minCost ( s , n ) { var minValue = 100000000 ; for ( var i = 0 ; i <= 25 ; i ++ ) { var cnt = 0 ; for ( var j = 0 ; j < n ; j ++ ) { cnt += Math . min ( Math . abs ( i - ( s [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ) ) , 26 - Math . abs ( i - ( s [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ) ) ) ; } minValue = Math . min ( minValue , cnt ) ; } return minValue ; }
function longComPre ( arr , N ) { let freq = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { freq [ i ] = new Array ( 256 ) ; for ( let j = 0 ; j < 256 ; j ++ ) { freq [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) { let M = arr [ i ] . length ; for ( let j = 0 ; j < M ; j ++ ) { freq [ i ] [ arr [ i ] [ j ] . charCodeAt ( 0 ) ] ++ ; } } let maxLen = 0 ; for ( let j = 0 ; j < 256 ; j ++ ) { let minRowVal = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { minRowVal = Math . min ( minRowVal , freq [ i ] [ j ] ) ; } maxLen += minRowVal ; } return maxLen ; }
function fact ( n ) { var res = 1 ; for ( i = 1 ; i <= n ; i ++ ) { res = res * i ; } return res ; }
function distinctWays ( str1 , str2 ) { var n = str1 . length ; var m = str2 . length ; if ( n == m ) { return 2 * fact ( n ) * fact ( m ) ; } return fact ( n ) * fact ( m ) ; }
function printResult ( result ) { result . reverse ( ) ; let i = 0 ; while ( i < result . length ) { document . write ( result [ i ] ) ; i ++ ; } }
function sumOfLargeNumbers ( v , k , N ) { let x = [ ] ; for ( let i = 0 ; i < k ; i ++ ) x . push ( [ ] ) ; for ( let i = 0 ; i < k ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { x [ i ] . push ( v [ i ] [ j ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) ; } } let carry = 0 ; let result = [ ] ; for ( let i = N - 1 ; i >= 0 ; i -- ) { let sum = 0 ; for ( let j = 0 ; j < k ; j ++ ) sum += x [ j ] [ i ] ; sum += carry ; let temp = sum ; let count = 0 ; while ( temp > 9 ) { temp = temp % 10 ; count ++ ; } let l = Math . pow ( 10 , count ) ; if ( l != 1 ) carry = Math . floor ( sum / l ) ; sum = sum % 10 ; result . push ( sum ) ; } while ( carry != 0 ) { let a = carry % 10 ; result . push ( a ) ; carry = Math . floor ( carry / 10 ) ; } printResult ( result ) ; }
function printRev ( str ) { let st = [ ] ; let ss = str . split ( "▁" ) ; for ( let temp = 0 ; temp < ss . length ; temp ++ ) { st . push ( ss [ temp ] ) ; } while ( st . length != 0 ) { document . write ( st . pop ( ) + "▁" ) ; } }
function printLeaves ( preorder , n ) { isLeaf ( preorder , n , Number . MIN_VALUE , Number . MAX_VALUE ) ; }
function min_cost ( S ) { let cost = 0 ; let F = 0 ; let B = 0 ; let count = 0 ; for ( let i in S ) if ( S [ i ] == "▁" ) count ++ ; let n = S . length - count ; if ( n == 1 ) return cost ; for ( let i in S ) { if ( S [ i ] != "▁" ) { if ( B != 0 ) { cost += Math . min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; }
function findPermutations ( n ) { var sum = 0 , P ; for ( var r = 1 ; r <= n ; r ++ ) { P = permute ( n , r ) ; sum = sum + P ; } return sum ; }
function countOfString ( N ) { let Stotal = Math . pow ( 2 , N ) ; let Sequal = 0 ; if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N / 2 ) ; let S1 = ( Stotal - Sequal ) / 2 ; return S1 ; }
function check ( s ) { let a = new Set ( ) ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( a . has ( s [ i ] ) ) { return false ; } a . add ( s [ i ] ) ; } return true ; }
function binExp ( base , power ) { var x = 1 ; while ( power != 0 ) { if ( power % 2 == 1 ) x = ( ( ( x % mod ) * ( base % mod ) ) % mod ) ; base = ( ( ( base % mod ) * ( base % mod ) ) % mod ) ; power = parseInt ( power / 2 ) ; } return x ; }
function fact ( num ) { var result = 1 ; for ( var i = 1 ; i <= num ; ++ i ) { result = ( ( ( result % mod ) * ( i % mod ) ) % mod ) ; } return result ; }
function calculate_nCi ( N , i ) { var nfact = fact ( N ) ; var ifact = fact ( i ) ; var dfact = fact ( N - i ) ; var inv_ifact = binExp ( ifact , mod - 2 ) ; var inv_dfact = binExp ( dfact , mod - 2 ) ; var denm = ( ( ( inv_ifact % mod ) * ( inv_dfact % mod ) ) % mod ) ; var answer = ( ( ( nfact % mod ) * ( denm % mod ) ) % mod ) ; return answer ; }
function countSubstring ( N , s , k ) { var allWays = binExp ( 26 , N ) ; var noWays = 0 ; for ( var i = 0 ; i < s ; ++ i ) { var nCi = calculate_nCi ( N , i ) ; var remaining = binExp ( 25 , N - i ) ; var multiply = ( ( ( nCi % mod ) * ( remaining % mod ) ) % mod ) ; noWays = ( ( ( noWays % mod ) + ( multiply % mod ) ) % mod ) ; } var answer = ( ( ( allWays % mod ) - ( noWays % mod ) ) % mod ) ; if ( answer < 0 ) answer += mod ; document . write ( answer ) ; }
function is_rtol ( s ) { let tmp = ( Math . sqrt ( s . length ) ) - 1 ; let first = s [ tmp ] ; for ( let pos = tmp ; pos < s . length - 1 ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } } return true ; }
function isSpecial ( c , special ) { var ans = false ; special . forEach ( i => { if ( i == c ) ans = true ; } ) ; return ans ; }
function countRatio ( s , special ) { var n = s . length ; for ( var i = 0 ; i < n ; i ++ ) { prefix [ i ] = ( isSpecial ( s [ i ] , special ) ) ; if ( i > 0 ) prefix [ i ] += prefix [ i - 1 ] ; } for ( var i = 0 ; i < n ; i ++ ) { sum [ i ] = prefix [ i ] ; if ( i > 0 ) sum [ i ] += sum [ i - 1 ] ; } var ans = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { var count = sum [ n - 1 ] - ( ( i > 1 ) ? sum [ i - 2 ] : 0 ) ; count -= ( ( i < n ) ? sum [ n - i - 1 ] : 0 ) ; ans += ( ( count ) / ( i ) ) ; } return ans ; }
function isVowel ( ch ) { if ( ch == "a" ch == "e" ch == "i" ch == "o" ch == "u" ) return true ; else return false ; }
function minCost ( S ) { var cA = 0 ; var cE = 0 ; var cI = 0 ; var cO = 0 ; var cU = 0 ; for ( var i = 0 ; i < S . length ; i ++ ) { if ( isVowel ( S [ i ] ) ) { cA += Math . abs ( S . charCodeAt ( i ) - "a" . charCodeAt ( 0 ) ) ; cE += Math . abs ( S . charCodeAt ( i ) - "e" . charCodeAt ( 0 ) ) ; cI += Math . abs ( S . charCodeAt ( i ) - "i" . charCodeAt ( 0 ) ) ; cO += Math . abs ( S . charCodeAt ( i ) - "o" . charCodeAt ( 0 ) ) ; cU += Math . abs ( S . charCodeAt ( i ) - "u" . charCodeAt ( 0 ) ) ; } } return Math . min ( Math . min ( Math . min ( Math . min ( cA , cE ) , cI ) , cO ) , cU ) ; }
function isPalindrome ( str ) { var l = 0 ; var h = str . length - 1 ; while ( h > l ) { if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) return false ; } return true ; }
function makeOddString ( str ) { var odd = "" ; for ( var i = 1 ; i < str . length ; i += 2 ) { odd += str . charAt ( i ) ; } return odd ; }
function makeevenString ( str ) { var even = "" ; for ( var i = 0 ; i < str . length ; i += 2 ) { even += str . charAt ( i ) ; } return even ; }
function checkevenOddPalindrome ( str ) { var odd = makeOddString ( str ) ; var even = makeevenString ( str ) ; if ( isPalindrome ( odd ) && isPalindrome ( even ) ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function inRange ( hh , mm , L , R ) { let a = Math . abs ( hh - mm ) ; if ( a < L a > R ) return false ; return true ; }
function firstNonRepElement ( str ) { let list = [ ] ; list . push ( str [ 0 ] ) ; for ( let i = 1 ; i < str . length ; i ++ ) { if ( list . includes ( str [ i ] ) ) list . splice ( list . indexOf ( str [ i ] ) , 1 ) ; else list . push ( str [ i ] ) ; } document . write ( list [ 0 ] ) ; }
function makeOddString ( str ) { var odd = "" ; for ( var i = 1 ; i < str . length ; i += 2 ) { odd += str [ i ] ; } return odd ; }
function checkOddlyPalindrome ( str ) { var odd = makeOddString ( str ) ; if ( isPalindrome ( odd ) ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function decrypt ( Str , Start , End ) { if ( Start > End ) { return ; } let mid = ( Start + End ) >> 1 ; document . write ( Str [ mid ] ) ; decrypt ( Str , mid + 1 , End ) ; decrypt ( Str , Start , mid - 1 ) ; }
function isSuffix ( s1 , s2 ) { var n1 = s1 . length ; var n2 = s2 . length ; if ( n1 > n2 ) return false ; for ( var i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
function CheckBinaryEquivalent ( N , str ) { var B_Number = 0 ; var cnt = 0 ; while ( N != 0 ) { var rem = N % 2 ; var c = Math . pow ( 10 , cnt ) ; B_Number += rem * c ; N = parseInt ( N / 2 ) ; cnt ++ ; } var bin = B_Number . toString ( ) ; return isSuffix ( str , bin ) ; }
function decode_String ( str , K ) { let ans = "" ; for ( let i = 0 ; i < str . length ; i += K ) ans += str [ i ] ; for ( let i = str . length - ( K - 1 ) ; i < str . length ; i ++ ) ans += str [ i ] ; document . write ( ans ) ; }
function check ( str , K ) { if ( str . length % K === 0 ) { var sum = 0 , i ; for ( i = 0 ; i < K ; i ++ ) { sum += str [ i ] . charCodeAt ( 0 ) ; } for ( var j = i ; j < str . length ; j += K ) { var s_comp = 0 ; for ( var p = j ; p < j + K ; p ++ ) s_comp += str [ p ] . charCodeAt ( 0 ) ; if ( s_comp !== sum ) return false ; } return true ; } return false ; }
function check ( s , n ) { var st = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( st . length != 0 && st [ st . length - 1 ] == s [ i ] ) st . pop ( ) ; else st . push ( s [ i ] ) ; } if ( st . length == 0 ) { return true ; } else { return false ; } }
function isPalindrome ( str ) { let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] != str [ len - i - 1 ] ) return false ; } return true ; }
function isCompressablePalindrome ( str ) { let len = str . length ; let compressed = "" ; compressed = str [ 0 ] ; for ( let i = 1 ; i < len ; i ++ ) { if ( str [ i ] != str [ i - 1 ] ) compressed += str [ i ] ; } return isPalindrome ( compressed ) ; }
function CountTotal ( s ) { let ans = 0 ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { let temp = "" ; for ( let j = i ; j < n ; j ++ ) { temp += s [ j ] ; if ( isvalid ( temp ) ) ans += 1 ; } } return ans ; }
function isvowel ( x ) { return ( x == "a" x == "e" x == "i" x == "o" x == "u" ) ; }
function getTotCount ( num ) { totCount = 1 ; firstCount = 1 ; let temp = 1 ; while ( ( num & temp ) == 0 ) { temp = temp << 1 ; totCount += 1 ; } firstCount = totCount ; temp = num >> totCount ; while ( temp != 0 ) { totCount += 1 ; temp = temp >> 1 ; } }
function flipBitsFromRightMostSetBit ( num ) { getTotCount ( num ) ; let num1 = num ^ ( ( 1 << totCount ) - 1 ) ; num1 = num1 ^ ( ( 1 << firstCount ) - 1 ) ; return num1 ; }
function isVowel ( c ) { return ( c == "a" c == "e" c == "i" c == "o" c == "u" ) ; }
function isValid ( s ) { let n = s . length ; if ( n == 1 ) return ( isVowel ( s [ 0 ] ) ) ; if ( isVowel ( s [ 0 ] ) == false ) return false ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] || ! isVowel ( s [ i ] ) ) return false ; } return true ; }
function findMaxLen ( s ) { let maxLen = 0 ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { let temp = "" ; for ( let j = i ; j < n ; j ++ ) { temp = temp + s [ j ] ; if ( isValid ( temp ) ) maxLen = Math . max ( maxLen , ( j - i + 1 ) ) ; } } return maxLen ; }
function findMaxLen ( s ) { var maxLen = 0 ; var cur ; if ( isVowel ( s [ 0 ] ) ) maxLen = 1 ; cur = maxLen ; for ( var i = 1 ; i < s . length ; i ++ ) { if ( isVowel ( s [ i ] ) ) { if ( s [ i ] !== s [ i - 1 ] ) cur += 1 ; else cur = 1 ; } else { cur = 0 ; } maxLen = Math . max ( cur , maxLen ) ; } return maxLen ; }
function power ( base , pow ) { let res = 1 ; while ( pow > 0 ) { if ( ( pow & 1 ) == 1 ) res = ( res * base ) ; base = ( base * base ) ; pow >>= 1 ; } return res ; }
function countNonPalindromicString ( n , m ) { let total = power ( n , m ) ; let palindrome = power ( n , m / 2 + m % 2 ) ; let count = total - palindrome ; return count ; }
function BalancedNumber ( s ) { let Leftsum = 0 ; let Rightsum = 0 ; for ( let i = 0 ; i < s . length / 2 ; i ++ ) { Leftsum += ( s [ i ] - "0" ) ; Rightsum += ( s [ s . length - 1 - i ] - "0" ) ; } if ( Leftsum == Rightsum ) document . write ( "Balanced" ) ; else document . write ( "Not▁Balanced" ) ; }
function expo ( base , exponent ) { var ans = 1 ; while ( exponent != 0 ) { if ( ( exponent & 1 ) == 1 ) { ans = ans * base ; ans = ans % mod ; } base = base * base ; base %= mod ; exponent >>= 1 ; } return ans % mod ; }
function findCount ( N ) { var ans = ( expo ( 26 , N ) - expo ( 5 , N ) - expo ( 21 , N ) ) % mod ; ans += mod ; ans %= mod ; return ans ; }
function countPalindromePermutation ( s , k ) { for ( var i = 0 ; i < k ; i ++ ) { freq [ s [ i ] . charCodeAt ( 0 ) - 97 ] ++ ; } var ans = 0 ; if ( checkPalindrome ( ) ) { ans ++ ; } var i = 0 , j = k ; while ( j < s . length ) { freq [ s [ i ++ ] . charCodeAt ( 0 ) - 97 ] -- ; freq [ s [ j ++ ] . charCodeAt ( 0 ) - 97 ] ++ ; if ( checkPalindrome ( ) ) { ans ++ ; } } return ans ; }
function minFlips ( target ) { let curr = "1" ; let count = 0 ; for ( let i = 0 ; i < target . length ; i ++ ) { if ( target [ i ] == curr ) { count ++ ; curr = String . fromCharCode ( 48 + ( curr . charCodeAt ( ) + 1 ) % 2 ) ; } } return count ; }
function decompose ( S ) { let s = [ ] ; let N = S . length ; let ans = 0 ; let nix = Number . MAX_VALUE ; for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( s . length == 0 ) { s . push ( S [ i ] ) ; nix = S [ i ] ; } else { if ( S [ i ] < s [ s . length - 1 ] ) { s . push ( S [ i ] ) ; nix = Math . min ( nix , S [ i ] ) ; } else { let val = S [ i ] ; while ( s . length != 0 && val >= s [ s . length - 1 ] ) { s . pop ( ) ; } nix = Math . min ( nix , S [ i ] ) ; s . push ( nix ) ; } } ans += s . length ; } return ans ; }
function maxSetBitCount ( s , k ) { var maxCount = 0 , n = s . length ; var count = 0 ; for ( var i = 0 ; i < k ; i ++ ) { if ( s [ i ] == "1" ) count ++ ; } maxCount = count ; for ( var i = k ; i < n ; i ++ ) { if ( s [ i - k ] == "1" ) count -- ; if ( s [ i ] == "1" ) count ++ ; maxCount = Math . max ( maxCount , count ) ; } return maxCount ; }
function maxVowelSubString ( str , K ) { var N = str . length ; var pref = Array ( N ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( str [ i ] == "a" str [ i ] == "e" str [ i ] == "i" str [ i ] == "o" str [ i ] == "u" ) pref [ i ] = 1 ; else pref [ i ] = 0 ; if ( i ) pref [ i ] += pref [ i - 1 ] ; } var maxCount = pref [ K - 1 ] ; var res = str . substring ( 0 , K ) ; for ( var i = K ; i < N ; i ++ ) { var currCount = pref [ i ] - pref [ i - K ] ; if ( currCount > maxCount ) { maxCount = currCount ; res = str . substring ( i - K + 1 , i - 1 ) ; } else if ( currCount == maxCount ) { var temp = str . substring ( i - K + 1 , i + 1 ) ; if ( temp < res ) res = temp ; } } return res ; }
function miniOperToMakeAllEleEqual ( arr , n , k ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % n ) { document . write ( - 1 ) ; return ; } let valueAfterDivision = sum / n ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( Math . abs ( valueAfterDivision - arr [ i ] ) % k != 0 ) { document . write ( - 1 ) ; return ; } count += Math . abs ( valueAfterDivision - arr [ i ] ) / k ; } document . write ( Math . floor ( count / 2 ) ) ; }
function minOperations ( a ) { let res = Number . MAX_VALUE ; let N = a . length ; for ( let r = 0 ; r < 2 ; r ++ ) { let sum = 0 , ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( ( i + r ) % 2 ) { if ( sum <= 0 ) { ans += - sum + 1 ; sum = 1 ; } } else { if ( sum >= 0 ) { ans += sum + 1 ; sum = - 1 ; } } } res = Math . min ( res , ans ) ; } document . write ( res ) ; }
function checkWord ( board , word , index , row , col ) { if ( row < 0 col < 0 row >= board . length col >= board [ 0 ] . length ) return false ; if ( board [ row ] [ col ] !== word [ index ] ) return false ; else if ( index === word . length - 1 ) return true ; var temp = board [ row ] [ col ] ; board [ row ] [ col ] = "*" ; if ( checkWord ( board , word , index + 1 , row + 1 , col ) || checkWord ( board , word , index + 1 , row - 1 , col ) || checkWord ( board , word , index + 1 , row , col + 1 ) || checkWord ( board , word , index + 1 , row , col - 1 ) ) { board [ row ] [ col ] = temp ; return true ; } board [ row ] [ col ] = temp ; return false ; }
function count ( N , X , subStr , index , n ) { if ( index == n ) return 0 ; let a = subStr + N [ index ] ; let b = 0 ; if ( parseInt ( a ) % X == 0 ) b = 1 ; let m1 = count ( N , X , a , index + 1 , n ) ; let m2 = b + count ( N , X , "" , index + 1 , n ) ; return Math . max ( m1 , m2 ) ; }
function checkSuffix ( A , B ) { var s1 = A . toString ( ) ; var s2 = B . toString ( ) ; var n1 = s1 . length ; var n2 = s2 . length ; if ( n1 < n2 ) { return false ; } for ( var i = 0 ; i < n2 ; i ++ ) { if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) { return false ; } } return true ; }
function checkSuffix ( A , B ) { let s1 = A . toString ( ) ; let s2 = B . toString ( ) ; let result ; result = s1 . endsWith ( s2 ) ; if ( result ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function checkSuffix ( A , B ) { let digit_B = parseInt ( Math . log10 ( B ) + 1 , 10 ) ; A -= B ; return ( A % ( Math . pow ( 10 , digit_B ) ) > 0 ) ; }
function check ( s ) { var ok = true ; for ( var i = 0 ; i + 1 < s . length ; ++ i ) ok &= ( Math . abs ( s [ i ] - s [ i + 1 ] ) != 1 ) ; return ok ; }
function findMinLength ( s ) { var n = s . length ; var counts = new Map ( ) ; var indices = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == "a" s [ i ] == "e" s [ i ] == "o" s [ i ] == "i" s [ i ] == "u" ) { if ( counts . has ( s [ i ] ) ) counts . set ( s [ i ] , counts . get ( s [ i ] ) + 1 ) else counts . set ( s [ i ] , 1 ) indices . push ( i ) ; } } if ( counts . size < 5 ) return - 1 ; var flag1 = 0 , flag2 = 0 ; var i = 0 ; var j = indices . length - 1 ; while ( ( j - i ) >= 4 ) { if ( ! flag1 && counts . get ( s [ indices [ i ] ] ) > 1 ) { if ( counts . has ( s [ indices [ i ] ] ) ) counts . set ( s [ indices [ i ] ] , counts . get ( s [ indices [ i ] ] ) - 1 ) i ++ ; } else flag1 = 1 ; if ( ! flag2 && counts . get ( s [ indices [ j ] ] ) > 1 ) { if ( counts . has ( s [ indices [ j ] ] ) ) counts . set ( s [ indices [ j ] ] , counts . get ( s [ indices [ j ] ] ) - 1 ) j -- ; } else flag2 = 1 ; if ( flag1 && flag2 ) break ; } return ( indices [ j ] - indices [ i ] + 1 ) ; }
function get_index ( ch ) { if ( ch == "a" ) return 0 ; else if ( ch == "e" ) return 1 ; else if ( ch == "i" ) return 2 ; else if ( ch == "o" ) return 3 ; else if ( ch == "u" ) return 4 ; else return - 1 ; }
function findMinLength ( s ) { let n = s . length ; let ans = n + 1 ; let start = 0 ; let count = new Array ( 5 ) ; for ( let i = 0 ; i < 5 ; i ++ ) { count [ i ] = 0 ; } for ( let x = 0 ; x < n ; x ++ ) { let idx = get_index ( s [ x ] ) ; if ( idx != - 1 ) { count [ idx ] ++ ; } let idx_start = get_index ( s [ start ] ) ; while ( idx_start == - 1 count [ idx_start ] > 1 ) { if ( idx_start != - 1 ) { count [ idx_start ] -- ; } start ++ ; if ( start < n ) idx_start = get_index ( s [ start ] ) ; } if ( count [ 0 ] > 0 && count [ 1 ] > 0 && count [ 2 ] > 0 && count [ 3 ] > 0 && count [ 4 ] > 0 ) { ans = Math . min ( ans , x - start + 1 ) ; } } if ( ans == n + 1 ) return - 1 ; return ans ; }
function count_min_length ( s ) { var hash = new Array ( 26 ) . fill ( 0 ) ; var ans = 2147483648 ; for ( var i = 0 ; i < 26 ; i ++ ) hash [ i ] = - 1 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( hash [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] == - 1 ) hash [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] = i ; else { if ( hash [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] == i - 1 || hash [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] == i - 2 ) return 0 ; ans = Math . min ( ans , i - hash [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] - 1 ) ; hash [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] = i ; } } if ( ans === 2147483648 ) return - 1 ; return ans ; }
function countStrings ( s ) { let cnt = 0 ; for ( let i = 1 ; s [ i ] ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { cnt ++ ; } } return cnt ; }
function RemoveHTMLTags ( s ) { const pattern = new RegExp ( "\\<.*?\\>" ) ; s = new String ( s ) . replace ( pattern , "" ) ; document . write ( s ) ; return ; }
function checkValidString ( str ) { var freq = new Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < str . length ; i ++ ) { freq [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } for ( var i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] !== 0 ) { if ( freq [ i ] !== i + 1 ) { return false ; } } } return true ; }
function checkSemiprime ( num ) { let cnt = 0 ; for ( let i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num = Math . floor ( num / i ) ; ++ cnt ; } } if ( num > 1 ) { ++ cnt ; } return cnt == 2 ; }
function makeCypherString ( N ) { let semiPrime = "" ; let sumOfPrime = "" ; let str = ( N ) . toString ( ) ; if ( checkSemiprime ( N ) ) { for ( let i = 0 ; i < str . length ; i ++ ) { if ( i % 2 == 1 ) { semiPrime += str [ i ] ; } else { semiPrime += String . fromCharCode ( str [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) + 65 ) ; } } } if ( isPossibleSum ( N ) ) { for ( let i = 0 ; i < str . length ; i ++ ) { if ( i % 2 == 1 ) { sumOfPrime += String . fromCharCode ( str [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) + 65 ) ; } else { sumOfPrime += str [ i ] ; } } } if ( semiPrime + sumOfPrime == "" ) { document . write ( "-1" ) ; } else { document . write ( semiPrime + sumOfPrime ) ; } }
function modulo_by_26 ( num ) { let res = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) { res = ( ( res * 10 + num [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) % MOD ) ; } return res ; }
function longestConsonantsSubsequence ( str ) { var answer = "" ; var n = str . length ; for ( var i = 0 ; i < n ; i ++ ) { if ( isConsonants ( str [ i ] ) ) { answer += str [ i ] ; } } return answer ; }
function generateTheString ( n ) { var ans = "" ; if ( n % 2 ) { for ( var i = 0 ; i < min ( n , 24 ) ; i ++ ) { ans += ( char ) ( "b" + i ) ; } if ( n > 24 ) { for ( var i = 0 ; i < ( n - 24 ) ; i ++ ) ans += "a" ; } } else { for ( var i = 0 ; i < Math . min ( n , 25 ) ; i ++ ) { ans += String . fromCharCode ( "b" . charCodeAt ( 0 ) + i ) ; } if ( n > 25 ) { for ( var i = 0 ; i < ( n - 25 ) ; i ++ ) ans += "a" ; } } return ans ; }
function finalCoordinates ( SX , SY , D ) { for ( let i = 0 ; i < D . length ; i ++ ) { if ( D [ i ] == "N" ) SY += 1 ; else if ( D [ i ] == "S" ) SY -= 1 ; else if ( D [ i ] == "E" ) SX += 1 ; else SX -= 1 ; } let ans = "(" + ( SX ) . toString ( ) + "," + ( SY ) . toString ( ) + ")" ; document . write ( ans ) ; }
function shortestPalindrome ( s ) { let abcd = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < s . length ; i ++ ) abcd [ s [ i ] . charCodeAt ( ) - 97 ] = 1 ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( abcd [ i ] == 1 ) { document . write ( String . fromCharCode ( i + 97 ) + "▁" ) ; } } }
function contain ( L , U , M ) { let count = 0 ; for ( let j = L ; j < U ; j ++ ) { let num = new Set ( ) ; let str = String ( j ) ; num . add ( str ) ; if ( j % M == 0 && ! num . has ( String ( M ) ) ) { count += 1 ; } } document . write ( count - 2 ) ; }
function MaxLength ( v , i , m ) { if ( i >= m ) { return m - 1 ; } for ( let k = 0 ; k < 26 ; k ++ ) { let c = String . fromCharCode ( "a" . charCodeAt ( 0 ) + k ) ; let v1 = [ ] ; for ( let j = 0 ; j < v . length ; j ++ ) { if ( v [ j ] [ i ] == c ) { v1 . push ( v [ j ] ) ; } } if ( v1 . length >= 2 ) { max1 = Math . max ( max1 , MaxLength ( v1 , i + 1 , m ) ) ; } else { max1 = Math . max ( max1 , i - 1 ) ; } } return max1 ; }
function group_formed ( S ) { let count = 1 ; for ( let i = 0 ; i < S . length - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) count += 1 ; } document . write ( count ) ; }
function value ( x ) { return ( x . charCodeAt ( ) - "a" . charCodeAt ( ) ) ; }
function finalString ( str ) { let x = 0 , y = 0 ; let left ; let n = str . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == "1" ) x ++ ; else y ++ ; } if ( x > y ) left = 1 ; else left = 0 ; let length = n - 2 * Math . min ( x , y ) ; for ( let i = 0 ; i < length ; i ++ ) { document . write ( left ) ; } }
function noOfDeletions ( str , k ) { var ans = 0 , cnt = 0 , pos = 0 ; while ( pos < str . length && str [ pos ] != k ) { pos ++ ; } var i = pos ; while ( i < str . length ) { while ( i < str . length && str [ i ] == k ) { i = i + 1 ; } ans = ans + cnt ; cnt = 0 ; while ( i < str . length && str [ i ] != k ) { i = i + 1 ; cnt = cnt + 1 ; } } return ans ; }
function GetDigitalRoot ( str ) { if ( str . length == 1 ) { return ( str [ 0 ] . charCodeAt ( ) - "0" . charCodeAt ( ) ) ; } str = GetIndividulaDigitSum ( str , str . length ) ; return GetDigitalRoot ( str ) ; }
function val ( c ) { if ( c >= "0" && c <= "9" ) return c - "0" ; else return c - "A" + 10 ; }
function toDeci ( str , base ) { let len = str . length ; let power = 1 ; let num = 0 ; let i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= base ) { return - 1 ; } num += val ( str [ i ] ) * power ; power = power * base ; } return num ; }
function repeatingString ( s , n , k ) { if ( n % k != 0 ) { return false ; } var frequency = new Array ( 123 ) ; for ( let i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { frequency [ s [ i ] ] ++ ; } var repeat = n / k ; for ( let i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; }
function longestPalindromic ( str , i , j , count ) { if ( i > j ) return count ; if ( i == j ) return ( count + 1 ) ; if ( str [ i ] == str [ j ] ) { count = longestPalindromic ( str , i + 1 , j - 1 , count + 2 ) ; return max ( count , max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) ) ; } return Math . max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) ; }
function longest_palindromic_substr ( str ) { return longestPalindromic ( str , 0 , str . length - 1 , 0 ) ; }
function removeOddFrequencyCharacters ( s ) { let m = new Map ( ) ; for ( let i = 0 ; i < s . length ; i ++ ) { let p = s [ i ] ; let count = m . get ( p ) ; if ( count == null ) { count = 0 ; m . set ( p , 1 ) ; } else m . set ( p , count + 1 ) ; } let new_string = "" ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( ( m . get ( s [ i ] ) & 1 ) == 1 ) continue ; new_string += s [ i ] ; } return new_string ; }
function LexicoLesserStrings ( s ) { var count = 0 ; var len ; len = s . length ; for ( var i = 0 ; i < len ; i ++ ) { count += ( s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ) * Math . pow ( 26 , len - i - 1 ) ; } return count ; }
function countString ( S1 , S2 ) { var countS1 , countS2 , totalString ; countS1 = LexicoLesserStrings ( S1 ) ; countS2 = LexicoLesserStrings ( S2 ) ; totalString = countS2 - countS1 - 1 ; return totalString < 0 ? 0 : totalString ; }
function isVowel ( x ) { x = ( x . toLowerCase ( ) ) ; return ( x == "a" x == "e" x == "i" x == "o" x == "u" ) ; }
function MaxPrefix ( s ) { var Dict = { } ; for ( const i of s ) { if ( Dict . hasOwnProperty ( i ) ) { Dict [ i ] ++ ; } else { Dict [ i ] = 1 ; } } var minfrequency = 2147483647 ; for ( const [ key , value ] of Object . entries ( Dict ) ) { minfrequency = Math . min ( minfrequency , value ) ; } var countminFrequency = 0 ; for ( const [ key , value ] of Object . entries ( Dict ) ) { if ( Dict [ key ] === minfrequency ) countminFrequency += 1 ; } var mapper = { } ; var indi = 0 ; for ( const i of s ) { if ( mapper . hasOwnProperty ( i ) ) { mapper [ i ] ++ ; } else { mapper [ i ] = 1 ; } if ( mapper [ i ] > countminFrequency ) break ; indi += 1 ; } document . write ( s . substring ( 0 , indi ) ) ; }
function countSubstr ( s , k ) { let n = s . length ; let l = n - 1 ; let r = n - 1 ; let arr = new Array ( n ) ; let last_indexof1 = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == "1" ) { arr [ i ] = i ; last_indexof1 = i ; } else { arr [ i ] = last_indexof1 ; } } let no_of_substr = 0 ; for ( r = n - 1 ; r >= 0 ; r -- ) { l = r ; while ( l >= 0 && ( r - l + 1 ) <= 64 && parseInt ( s . substring ( l , r + 1 ) , 2 ) < k ) { l -- ; } if ( r - l + 1 <= 64 ) no_of_substr += l + 1 ; else { no_of_substr += arr [ l + 1 ] + 1 ; } } return no_of_substr ; }
function isPerfectCubeString ( str ) { var sum = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { sum += str . charCodeAt ( i ) ; } var cr = Math . round ( Math . cbrt ( sum ) ) ; return cr * cr * cr == sum ; }
function XorAscii ( str , len ) { let ans = str . codePointAt ( 0 ) ; for ( let i = 1 ; i < len ; i ++ ) { ans = ( ans ^ ( str . codePointAt ( i ) ) ) ; } return ans ; }
function countSticks ( str ) { var cnt = 0 ; for ( var i = 0 ; str [ i ] ; i ++ ) { var ch = str [ i ] ; if ( ch >= "A" && ch <= "Z" ) { cnt += sticks [ ch . charCodeAt ( 0 ) - "A" . charCodeAt ( 0 ) ] ; } else { cnt += number [ ch . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ] ; } } return cnt ; }
function count ( str1 , str2 ) { var c = 0 ; for ( var i = 0 ; i < str1 . length ; i ++ ) { if ( str2 . includes ( str1 [ i ] ) ) c += 1 ; } document . write ( "No.▁of▁matching▁characters▁are:▁" + + parseInt ( c ) ) ; }
function checkIfStartsWithCapital ( str ) { if ( str [ 0 ] >= "A" && str [ 0 ] <= "Z" ) return 1 ; else return 0 ; }
function checkIfAllVowels ( str ) { var hash = Array ( 5 ) . fill ( 0 ) ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == "A" str [ i ] == "a" ) hash [ 0 ] = 1 ; else if ( str [ i ] == "E" str [ i ] == "e" ) hash [ 1 ] = 1 ; else if ( str [ i ] == "I" str [ i ] == "i" ) hash [ 2 ] = 1 ; else if ( str [ i ] == "O" str [ i ] == "o" ) hash [ 3 ] = 1 ; else if ( str [ i ] == "U" str [ i ] == "u" ) hash [ 4 ] = 1 ; } for ( var i = 0 ; i < 5 ; i ++ ) { if ( hash [ i ] == 0 ) { return 1 ; } } return 0 ; }
function countOfLetters ( str ) { var letter = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( ( str [ i ] >= "A" && str [ i ] <= "Z" ) || ( str [ i ] >= "a" && str [ i ] <= "z" ) ) letter ++ ; } return letter ; }
function countOfNumbers ( str ) { var number = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] >= "0" && str [ i ] <= "9" ) number ++ ; } return number ; }
function findNthOccur ( str , ch , N ) { var occur = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return - 1 ; }
function countSmaller ( str ) { var n = str . length ; var arr = Array ( 26 ) . fill ( 0 ) ; var ans = Array ( n ) ; for ( var i = n - 1 ; i >= 0 ; i -- ) { arr [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; var ct = 0 ; for ( var j = 0 ; j < str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ; j ++ ) { ct += arr [ j ] ; } ans [ i ] = ct ; } for ( var i = 0 ; i < n ; i ++ ) { document . write ( ans [ i ] + "▁" ) ; } }
function printValue ( digit ) { switch ( digit ) { case "0" : document . write ( "Zero▁" ) ; break ; case "1" : document . write ( "One▁" ) ; break ; case "2" : document . write ( "Two▁" ) ; break ; case "3" : document . write ( "Three▁" ) ; break ; case "4" : document . write ( "Four▁" ) ; break ; case "5" : document . write ( "Five▁" ) ; break ; case "6" : document . write ( "Six▁" ) ; break ; case "7" : document . write ( "Seven▁" ) ; break ; case "8" : document . write ( "Eight▁" ) ; break ; case "9" : document . write ( "Nine▁" ) ; break ; } }
function printWord ( N ) { var i , length = N . length ; for ( i = 0 ; i < length ; i ++ ) { printValue ( N [ i ] ) ; } }
function solve ( X , Y , N , K ) { let count = new Array ( N + 1 ) ; count . fill ( 0 ) ; let sol = 0 ; count [ 0 ] = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { count [ i ] = count [ i - 1 ] + Math . abs ( X [ i - 1 ] . charCodeAt ( ) - Y [ i - 1 ] . charCodeAt ( ) ) ; } let j = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { while ( ( count [ i ] - count [ j ] ) > K ) { j ++ ; } sol = Math . max ( sol , i - j ) ; } return sol ; }
function find ( x ) { if ( x !== parent [ x ] ) return ( parent [ x ] = find ( parent [ x ] ) ) ; return x ; }
function join ( x , y ) { var px = find ( x ) ; var pz = find ( y ) ; if ( px !== pz ) { parent [ pz ] = px ; } }
function convertible ( s1 , s2 ) { var mp = { } ; for ( var i = 0 ; i < s1 . length ; i ++ ) { if ( ! mp . hasOwnProperty ( s1 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ) ) { mp [ s1 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] = s2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ; } else { if ( mp [ s1 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] !== s2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ) return false ; } } for ( const [ key , value ] of Object . entries ( mp ) ) { if ( key === value ) continue ; else { if ( find ( key ) == find ( value ) ) return false ; else join ( key , value ) ; } } return true ; }
function initialize ( ) { for ( var i = 0 ; i < 26 ; i ++ ) { parent [ i ] = i ; } }
function jaro_distance ( s1 , s2 ) { if ( s1 == s2 ) return 1.0 ; var len1 = s1 . length , len2 = s2 . length ; var max_dist = Math . floor ( Math . max ( len1 , len2 ) / 2 ) - 1 ; var match = 0 ; var hash_s1 = Array ( s1 . length ) . fill ( 0 ) ; var hash_s2 = Array ( s1 . length ) . fill ( 0 ) ; for ( var i = 0 ; i < len1 ; i ++ ) { for ( var j = Math . max ( 0 , i - max_dist ) ; j < Math . min ( len2 , i + max_dist + 1 ) ; j ++ ) if ( s1 [ i ] == s2 [ j ] && hash_s2 [ j ] == 0 ) { hash_s1 [ i ] = 1 ; hash_s2 [ j ] = 1 ; match ++ ; break ; } } if ( match == 0 ) return 0.0 ; var t = 0 ; var point = 0 ; for ( var i = 0 ; i < len1 ; i ++ ) if ( hash_s1 [ i ] ) { while ( hash_s2 [ point ] == 0 ) point ++ ; if ( s1 [ i ] != s2 [ point ++ ] ) t ++ ; } t /= 2 ; return ( ( match ) / ( len1 ) + ( match ) / ( len2 ) + ( match - t ) / ( match ) ) / 3.0 ; }
function jaro_distance ( s1 , s2 ) { if ( s1 == s2 ) return 1.0 ; let len1 = s1 . length , len2 = s2 . length ; if ( len1 == 0 len2 == 0 ) return 0.0 ; let max_dist = Math . floor ( Math . max ( len1 , len2 ) / 2 ) - 1 ; let match = 0 ; let hash_s1 = new Array ( s1 . length ) ; hash_s1 . fill ( 0 ) ; let hash_s2 = new Array ( s2 . length ) ; hash_s2 . fill ( 0 ) ; for ( let i = 0 ; i < len1 ; i ++ ) { for ( let j = Math . max ( 0 , i - max_dist ) ; j < Math . min ( len2 , i + max_dist + 1 ) ; j ++ ) if ( s1 [ i ] == s2 [ j ] && hash_s2 [ j ] == 0 ) { hash_s1 [ i ] = 1 ; hash_s2 [ j ] = 1 ; match ++ ; break ; } } if ( match == 0 ) return 0.0 ; let t = 0 ; let point = 0 ; for ( let i = 0 ; i < len1 ; i ++ ) if ( hash_s1 [ i ] == 1 ) { while ( hash_s2 [ point ] == 0 ) point ++ ; if ( s1 [ i ] != s2 [ point ++ ] ) t ++ ; } t /= 2 ; return ( ( match ) / ( len1 ) + ( match ) / ( len2 ) + ( match - t ) / ( match ) ) / 3.0 ; }
function jaro_Winkler ( s1 , s2 ) { let jaro_dist = jaro_distance ( s1 , s2 ) ; if ( jaro_dist > 0.7 ) { let prefix = 0 ; for ( let i = 0 ; i < Math . min ( s1 . length , s2 . length ) ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) prefix ++ ; else break ; } prefix = Math . min ( 4 , prefix ) ; jaro_dist += 0.1 * prefix * ( 1 - jaro_dist ) ; } return jaro_dist . toFixed ( 6 ) ; }
function isWordPresent ( sentence , word ) { let s = sentence . split ( "▁" ) ; for ( let temp = 0 ; temp < s . length ; temp ++ ) { if ( s [ temp ] == ( word ) ) { return true ; } } return false ; }
function canMake ( s ) { var o = 0 , z = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) == 1 ) o ++ ; else z ++ ; } if ( o % 2 == 1 && z % 2 == 1 ) return "NO" ; else return "YES" ; }
function countChars ( str , n ) { let i = 0 , cnt = 0 ; while ( i < n ) { if ( str [ i ] == "0" ) i += 1 ; else i += 2 ; cnt += 1 ; } return cnt ; }
function findMinSwaps ( s , k ) { var ans = 0 ; var c_one = 0 , c_zero = 0 ; for ( var i = s . length - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == "1" ) c_one ++ ; if ( s [ i ] == "0" ) c_zero ++ , ans += c_one ; if ( c_zero == k ) break ; } if ( c_zero < k ) return - 1 ; return ans ; }
function checkvowel ( ch ) { ch = ch . toLowerCase ( ) ; if ( ch == "a" ch == "e" ch == "i" ch == "o" ch == "u" ) { return true ; } else { return false ; } }
function decBinary ( arr , n ) { let k = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n = parseInt ( n / 2 , 10 ) ; } }
function concat ( m , n ) { let k = parseInt ( Math . log ( m ) / Math . log ( 2 ) , 10 ) + 1 ; let l = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) + 1 ; let a = new Array ( k ) ; let b = new Array ( l ) ; let c = new Array ( k + l ) ; decBinary ( a , m ) ; decBinary ( b , n ) ; let iN = 0 ; for ( let i = 0 ; i < k ; i ++ ) c [ iN ++ ] = a [ i ] ; for ( let i = 0 ; i < l ; i ++ ) c [ iN ++ ] = b [ i ] ; return ( binaryDec ( c , k + l ) ) ; }
function getBinaryLength ( n ) { let length = 0 ; while ( n > 0 ) { length += 1 ; n = parseInt ( n / 2 , 10 ) ; } return length ; }
function concat ( m , n ) { let length = getBinaryLength ( n ) ; return ( m << length ) + n ; }
function countSubStr ( str , len ) { var ans = 0 ; for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] == "0" ) ans += ( i + 1 ) ; } return ans ; }
function largestSubStr ( s ) { while ( s . length && s [ s . length - 1 ] == "1" ) s = s . substring ( 0 , s . length - 1 ) ; ; if ( s . length == 0 ) return "-1" ; else return s ; }
function areEqual ( a , b ) { for ( var i = 0 ; i < MAX ; i ++ ) if ( a [ i ] != b [ i ] ) return false ; return true ; }
function reverseParentheses ( str , len ) { let st = [ ] ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] == "(" ) { st . push ( i ) ; } else if ( str [ i ] == ")" ) { let A = [ ... str ] reverse ( A , st [ st . length - 1 ] + 1 , i ) ; str = [ ... A ] ; st . pop ( ) ; } } let res = "" ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] != ")" && str [ i ] != "(" ) { res += ( str [ i ] ) ; } } return res ; }
function maxCount ( str , patt ) { var strFreq = new Array ( MAX ) . fill ( 0 ) ; updateFreq ( str , strFreq ) ; var pattFreq = new Array ( MAX ) . fill ( 0 ) ; updateFreq ( patt , pattFreq ) ; var ans = 21474836473 ; for ( var i = 0 ; i < MAX ; i ++ ) { if ( pattFreq [ i ] == 0 ) continue ; ans = Math . min ( ans , strFreq [ i ] / pattFreq [ i ] ) ; } return ans ; }
function minNum ( str , len ) { var res = Number . MAX_VALUE ; for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] == "4" str [ i ] == "8" ) { res = Math . min ( res , str [ i ] - "0" ) ; } } for ( i = 0 ; i < len - 1 ; i ++ ) { for ( j = i + 1 ; j < len ; j ++ ) { var num = ( str [ i ] - "0" ) * TEN + ( str [ j ] - "0" ) ; if ( num % 4 == 0 ) { res = Math . min ( res , num ) ; } } } return ( ( res == Number . MAX_VALUE ) ? - 1 : res ) ; }
function minOperation ( str , len ) { var first = Array ( MAX ) . fill ( - 1 ) ; var last = Array ( MAX ) . fill ( - 1 ) ; for ( var i = 0 ; i < len ; i ++ ) { var index = ( str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ) ; if ( first [ index ] == - 1 ) first [ index ] = i ; last [ index ] = i ; } var minOp = - 1 ; for ( var i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == - 1 first [ i ] == last [ i ] ) continue ; var cnt = len - ( last [ i ] - first [ i ] + 1 ) ; if ( minOp == - 1 cnt < minOp ) minOp = cnt ; } return minOp ; }
function findMidAlphabet ( s1 , s2 , n ) { for ( var i = 0 ; i < n ; i ++ ) { var mid = ( s1 [ i ] . charCodeAt ( 0 ) + s2 [ i ] . charCodeAt ( 0 ) ) / 2 ; document . write ( String . fromCharCode ( mid ) ) ; } }
function countVowels ( str , l , r ) { let cnt = 0 ; for ( let i = l ; i <= r ; i ++ ) { if ( isVowel ( str [ i ] ) ) cnt ++ ; } return cnt ; }
function sumDigits ( n ) { var sum = 0 ; while ( n > 0 ) { var digit = n % 10 ; sum += digit ; n = parseInt ( n / 10 ) ; } return sum ; }
function isDivBySix ( str , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += ( str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) + 1 ) ; } if ( sum % 3 != 0 ) return false ; var lastDigit = ( ( str [ n - 1 ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) + 1 ) ) % 10 ; if ( lastDigit % 2 != 0 ) return false ; return true ; }
function minLength ( str , len ) { let s = [ ] ; for ( let i = 0 ; i < len ; i ++ ) { if ( s . length == 0 ) { s . push ( str [ i ] ) ; } else { let c = s [ s . length - 1 ] ; if ( c != str [ i ] && c . toUpperCase ( ) == str [ i ] . toUpperCase ( ) ) { s . pop ( ) ; } else { s . push ( str [ i ] ) ; } } } return s . length ; }
function cntSplits ( s ) { if ( s [ s . length - 1 ] == "1" ) return 0 ; var c_zero = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) c_zero += ( s [ i ] == "0" ) ; return Math . pow ( 2 , c_zero - 1 ) ; }
function isDivisible ( s , m ) { var mp = new Map ( ) ; for ( var i = 0 ; i < DIGITS ; i ++ ) { mp . set ( CHARS [ i ] , i ) ; } var r = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { r = ( r * 16 + mp . get ( s [ i ] ) ) % m ; } if ( ! r ) return true ; return false ; }
function isPalindrome ( num ) { var s = num . toString ( ) ; var low = 0 ; var high = s . length - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; }
function maxSubStr ( str1 , len1 , str2 , len2 ) { if ( len1 > len2 ) return 0 ; let freq1 = new Array ( MAX ) . fill ( 0 ) ; for ( let i = 0 ; i < len1 ; i ++ ) freq1 [ str1 . charCodeAt ( i ) - "a" . charCodeAt ( 0 ) ] ++ ; let freq2 = new Array ( MAX ) . fill ( 0 ) ; for ( let i = 0 ; i < len2 ; i ++ ) freq2 [ str2 . charCodeAt ( i ) - "a" . charCodeAt ( 0 ) ] ++ ; let minPoss = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < MAX ; i ++ ) { if ( freq1 [ i ] == 0 ) continue ; if ( freq1 [ i ] > freq2 [ i ] ) return 0 ; minPoss = Math . min ( minPoss , Math . floor ( freq2 [ i ] / freq1 [ i ] ) ) ; } return minPoss ; }
function Count ( s , pos ) { let c = s [ pos - 1 ] ; let counter = 0 ; for ( let i = 0 ; i < pos - 1 ; i ++ ) { if ( s [ i ] == c ) counter = counter + 1 ; } return counter ; }
function findSubStr ( str , cnt , start ) { if ( start == str . length ) { minCnt = Math . min ( cnt , minCnt ) ; } for ( var len = 1 ; len <= ( str . length - start ) ; len ++ ) { var subStr = str . substring ( start , start + len ) ; if ( uSet . has ( subStr ) ) { findSubStr ( str , cnt + 1 , start + len ) ; } } }
function getMod ( str , n , k ) { var pwrTwo = Array ( n ) ; pwrTwo [ 0 ] = 1 % k ; for ( var i = 1 ; i < n ; i ++ ) { pwrTwo [ i ] = pwrTwo [ i - 1 ] * ( 2 % k ) ; pwrTwo [ i ] %= k ; } var res = 0 ; var i = 0 , j = n - 1 ; while ( i < n ) { if ( str [ j ] == "1" ) { res += ( pwrTwo [ i ] ) ; res %= k ; } i ++ ; j -- ; } return res ; }
function countStrings ( N ) { var i , j ; var dp = Array ( N + 1 ) . fill ( 0 ) . map ( x => Array ( 3 ) . fill ( 0 ) ) ; for ( i = 0 ; i < N + 1 ; i ++ ) { for ( j = 9 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } var ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; }
function getCount ( str , n ) { var cnt = 0 ; var i = 0 ; while ( i < n - 2 ) { if ( str [ i ] === str [ i + 1 ] && str [ i ] === str [ i + 2 ] ) { cnt ++ ; i = i + 2 ; } else { i ++ ; } } return cnt ; }
function maxNumber ( str , n ) { var freq = Array ( 2 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] == "z" ) { freq [ 0 ] ++ ; } else if ( str [ i ] == "n" ) { freq [ 1 ] ++ ; } } var num = "" ; for ( var i = 0 ; i < freq [ 1 ] ; i ++ ) num += "1" ; for ( var i = 0 ; i < freq [ 0 ] ; i ++ ) num += "0" ; return num ; }
function fact ( n ) { let fact = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact *= i ; return fact ; }
function countStrings ( str , n ) { let distinct_char = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { distinct_char . add ( str [ i ] ) ; } return fact ( distinct_char . size ) ; }
function getChar ( str ) { let sum = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { sum += ( str [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) + 1 ) ; } if ( sum % 26 == 0 ) return "z" ; else { sum = sum % 26 ; return String . fromCharCode ( "a" . charCodeAt ( ) + sum - 1 ) ; } }
function countFreq ( pat , txt ) { var M = pat . length ; var N = txt . length ; var res = 0 ; for ( var i = 0 ; i <= N - M ; i ++ ) { var j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { res ++ ; j = 0 ; } } return res ; }
function findOccurrence ( arr , n , pattern ) { for ( var i = 0 ; i < n ; i ++ ) { var binary = decToBinary ( arr [ i ] ) ; document . write ( countFreq ( pattern , binary ) + "▁" ) ; } }
function findNumbers ( s ) { var n = s . length ; var count = 1 ; var result = 0 ; var left = 0 ; var right = 1 ; while ( right < n ) { if ( s [ left ] == s [ right ] ) { count ++ ; } else { result += parseInt ( count * ( count + 1 ) / 2 ) ; left = right ; count = 1 ; } right ++ ; } result += parseInt ( count * ( count + 1 ) / 2 ) ; document . write ( result ) ; }
function SieveOfEratosthenes ( prime , p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } return prime ; }
function canBeBalanced ( s , n ) { if ( n % 2 == 1 ) return false ; let k = "(" ; k += s + ")" ; let d = [ ] ; for ( let i = 0 ; i < k . length ; i ++ ) { if ( k [ i ] == "(" ) d . push ( "(" ) ; else { if ( d . length != 0 ) d . pop ( ) ; else return false ; } } if ( d . length == 0 ) return true ; return false ; }
function maxLenSubStr ( s ) { if ( s . length < 3 ) return s . length ; let temp = 2 ; let ans = 2 ; for ( let i = 2 ; i < s . length ; i ++ ) { if ( s [ i ] != s [ i - 1 ] s [ i ] != s [ i - 2 ] ) temp ++ ; else { ans = Math . max ( temp , ans ) ; temp = 2 ; } } ans = Math . max ( temp , ans ) ; return ans ; }
function CompareAlphanumeric ( str1 , str2 ) { let i , j ; i = 0 ; j = 0 ; let len1 = str1 . length ; let len2 = str2 . length ; while ( i <= len1 && j <= len2 ) { while ( i < len1 && ( ! ( ( str1 [ i ] . charCodeAt ( ) >= "a" . charCodeAt ( ) && str1 [ i ] . charCodeAt ( ) <= "z" . charCodeAt ( ) ) || ( str1 [ i ] . charCodeAt ( ) >= "A" . charCodeAt ( ) && str1 [ i ] . charCodeAt ( ) <= "Z" . charCodeAt ( ) ) || ( str1 [ i ] . charCodeAt ( ) >= "0" . charCodeAt ( ) && str1 [ i ] . charCodeAt ( ) <= "9" . charCodeAt ( ) ) ) ) ) { i ++ ; } while ( j < len2 && ( ! ( ( str2 [ j ] . charCodeAt ( ) >= "a" . charCodeAt ( ) && str2 [ j ] . charCodeAt ( ) <= "z" . charCodeAt ( ) ) || ( str2 [ j ] . charCodeAt ( ) >= "A" . charCodeAt ( ) && str2 [ j ] . charCodeAt ( ) <= "Z" . charCodeAt ( ) ) || ( str2 [ j ] . charCodeAt ( ) >= "0" . charCodeAt ( ) && str2 [ j ] . charCodeAt ( ) <= "9" . charCodeAt ( ) ) ) ) ) { j ++ ; } if ( i == len1 && j == len2 ) { return true ; } else if ( str1 [ i ] != str2 [ j ] ) { return false ; } else { i ++ ; j ++ ; } } return false ; }
function expandString ( strin ) { let temp = "" ; let j ; for ( let i = 0 ; i < strin . length ; i ++ ) { if ( strin [ i ] . charCodeAt ( 0 ) >= 0 ) { let num = strin [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ; if ( strin [ i + 1 ] == "(" ) { for ( j = i + 1 ; strin [ j ] != ")" ; j ++ ) { if ( ( strin [ j ] >= "a" && strin [ j ] <= "z" ) || ( strin [ j ] >= "A" && strin [ j ] <= "Z" ) ) { temp += strin [ j ] ; } } for ( let k = 1 ; k <= num ; k ++ ) { document . write ( temp ) ; } num = 0 ; temp = "" ; if ( j < strin . length ) { i = j ; } } } } }
function countSubStr ( s , n ) { var c1 = 0 , c2 = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s . substring ( i , i + 5 ) == "geeks" ) c1 ++ ; if ( s . substring ( i , i + 3 ) == "for" ) c2 = c2 + c1 ; } return c2 ; }
function isVowel ( ch ) { ch = ch . toUpperCase ( ) ; return ( ch == "A" ch == "E" ch == "I" ch == "O" ch == "U" ) ; }
function balancedBrackets ( str ) { var dep = 0 ; var minDep = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] === "(" ) dep ++ ; else dep -- ; if ( minDep > dep ) minDep = dep ; } if ( minDep < 0 ) { for ( var i = 0 ; i < Math . abs ( minDep ) ; i ++ ) str = "(" + str ; } dep = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] === "(" ) dep ++ ; else dep -- ; } if ( dep !== 0 ) { for ( var i = 0 ; i < dep ; i ++ ) str = str + ")" ; } return str ; }
function minOperations ( str , n ) { var count = 0 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] != str [ i + 1 ] ) count ++ ; } return ( count + 1 ) / 2 ; }
function stringToInt ( str ) { if ( str . length == 1 ) return ( str [ 0 ] - "0" ) ; var y = stringToInt ( str . substring ( 1 ) ) ; var x = str [ 0 ] - "0" ; x = x * Math . pow ( 10 , str . Length - 1 ) + y ; return ( x ) ; }
function largestSubSeq ( arr , n ) { var count = Array ( MAX ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { var str = arr [ i ] ; var hash = Array ( MAX ) . fill ( 0 ) ; for ( var j = 0 ; j < str . length ; j ++ ) { hash [ str [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] = true ; } for ( var j = 0 ; j < MAX ; j ++ ) { if ( hash [ j ] ) count [ j ] ++ ; } } return count . reduce ( ( a , b ) => Math . max ( a , b ) ) ; }
function longest_substring ( s , k ) { var n = s . length ; if ( k > 1 ) { s += s ; n *= 2 ; } var ans = 0 ; var i = 0 ; while ( i < n ) { var x = 0 ; while ( s [ i ] == "0" && i < n ) x ++ , i ++ ; ans = Math . max ( ans , x ) ; i ++ ; } if ( k == 1 ans != n ) return ans ; else return ( ans / 2 ) * k ; }
function Occurrence ( s , position ) { let count = 0 ; for ( let i = 0 ; i < position - 1 ; i ++ ) if ( s [ i ] == s [ position - 1 ] ) count ++ ; return count ; }
function countOccurrence ( s , position ) { let alpha = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { alpha [ i ] = 0 ; } let b = new Array ( s . length ) ; for ( let i = 0 ; i < s . length ; i ++ ) { b [ i ] = alpha [ s [ i ] . charCodeAt ( 0 ) - 97 ] ; alpha [ s [ i ] . charCodeAt ( 0 ) - 97 ] ++ ; } return b [ position - 1 ] ; }
function find_permutation ( str1 , str2 , len1 , len2 , i , j , res ) { if ( res . length == len1 + len2 ) { stringSet . add ( res ) ; return ; } if ( i < len1 ) find_permutation ( str1 , str2 , len1 , len2 , i + 1 , j , res + str1 [ i ] ) ; if ( j < len2 ) find_permutation ( str1 , str2 , len1 , len2 , i , j + 1 , res + str2 [ j ] ) ; }
function canConvert ( str1 , str2 ) { var i = 0 , j = 0 ; while ( i < str1 . length && j < str2 . length ) { if ( str1 [ i ] !== str2 [ j ] ) { if ( str1 [ i ] === "0" && str2 [ j ] === "1" && i + 1 < str1 . length && str1 [ i + 1 ] === "0" ) { i += 2 ; j ++ ; } else { return false ; } } else { i ++ ; j ++ ; } } if ( i === str1 . length && j === str2 . length ) return true ; return false ; }
function reverse ( s ) { let stc = [ ] ; let temp = "" ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == "▁" ) { stc . push ( temp ) ; temp = "" ; } else { temp = temp + s [ i ] ; } } stc . push ( temp ) ; while ( stc . length != 0 ) { temp = stc [ stc . length - 1 ] ; document . write ( temp + "▁" ) ; stc . pop ( ) ; } }
function countPairs ( str , k ) { var n = str . length ; var freq = new Array ( MAX ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { freq [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } var cnt = 0 ; if ( k === 0 ) { for ( var i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] > 1 ) { cnt += ( freq [ i ] * ( freq [ i ] - 1 ) ) / 2 ; } } } else { for ( var i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] > 0 && i + k < MAX && freq [ i + k ] > 0 ) { cnt += freq [ i ] * freq [ i + k ] ; } } } return cnt ; }
function printUncommon ( str1 , str2 ) { var a1 = 0 , a2 = 0 ; for ( var i = 0 ; i < str1 . length ; i ++ ) { var ch = ( str1 [ i ] . charCodeAt ( 0 ) ) - "a" . charCodeAt ( 0 ) ; a1 = a1 | ( 1 << ch ) ; } for ( var i = 0 ; i < str2 . length ; i ++ ) { var ch = ( str2 [ i ] . charCodeAt ( 0 ) ) - "a" . charCodeAt ( 0 ) ; a2 = a2 | ( 1 << ch ) ; } var ans = a1 ^ a2 ; var i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { document . write ( String . fromCharCode ( "a" . charCodeAt ( 0 ) + i ) ) ; } ans = parseInt ( ans / 2 ) ; i ++ ; } }
function isPalin ( i , j , k , l , p , q , s ) { var start = i , end = q ; while ( start < end ) { if ( s [ start ] != s [ end ] ) return false ; start ++ ; if ( start == j + 1 ) start = k ; end -- ; if ( end == p - 1 ) end = l ; } return true ; }
function countSubStr ( s ) { var count = 0 ; var n = s . length ; for ( var i = 0 ; i < n - 2 ; i ++ ) { for ( var j = i ; j < n - 2 ; j ++ ) { for ( var k = j + 1 ; k < n - 1 ; k ++ ) { for ( var l = k ; l < n - 1 ; l ++ ) { for ( var p = l + 1 ; p < n ; p ++ ) { for ( var q = p ; q < n ; q ++ ) { if ( isPalin ( i , j , k , l , p , q , s ) ) { count ++ ; } } } } } } } return count ; }
function isPrime ( n ) { if ( n == 0 n == 1 ) return false ; for ( let i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
function sumAscii ( str , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isPrime ( i + 1 ) ) sum += str . charCodeAt ( i ) ; } return sum ; }
function Pangram ( x ) { let mp = new Map ( ) ; let n = x . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( x [ i ] ) ) { mp . set ( x [ i ] , mp . get ( x [ i ] ) + 1 ) } else { mp . set ( x [ i ] , 1 ) } } if ( mp . size == 26 ) return true ; else return false ; }
function countTotalPangram ( n ) { let cnt = 0 ; for ( let i = 1 ; i <= n ; i ++ ) if ( Pangram ( weight [ i ] ) ) cnt ++ ; return cnt ; }
function dfs ( node , parent ) { for ( let to of graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; weight [ node ] += weight [ to ] ; } }
function uniqueChars ( x ) { let mp = new Map ( ) ; let n = x . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( x [ i ] ) ) { mp . set ( x [ i ] , mp . get ( x [ i ] ) + 1 ) } else { mp . set ( x [ i ] , 1 ) } } if ( mp . size == x . length ) return true ; else return false ; }
function dfs ( node , parent ) { if ( uniqueChars ( weight [ node ] ) ) cnt += 1 ; for ( let to of graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } }
function preCalculate ( str , n ) { freq [ str [ 0 ] . charCodeAt ( 0 ) ] [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { let ch = str [ i ] ; for ( let j = 0 ; j < MAX ; j ++ ) { let charToUpdate = String . fromCharCode ( j ) ; if ( charToUpdate == ch ) freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 ; else freq [ j ] [ i ] = freq [ j ] [ i - 1 ] ; } } }
function getFrequency ( ch , l , r ) { if ( l == 0 ) return freq [ ch . charCodeAt ( 0 ) ] [ r ] ; else return ( freq [ ch . charCodeAt ( 0 ) ] [ r ] - freq [ ch . charCodeAt ( 0 ) ] [ l - 1 ] ) ; }
function isValid ( s ) { if ( ( s . indexOf ( "geek" ) != - 1 ) && ( s . indexOf ( "keeg" , s . indexOf ( "geek" ) + 4 ) != - 1 ) ) return true ; return false ; }
function isTwoAlter ( s ) { for ( let i = 0 ; i < s . length - 2 ; i ++ ) { if ( s [ i ] != s [ i + 2 ] ) { return false ; } } if ( s [ 0 ] == s [ 1 ] ) return false ; return true ; }
function findCount ( s , n , a , b ) { var res = 0 ; for ( var i = 0 ; i < b ; i ++ ) { if ( i == a ) res += ( s [ n - i - 1 ] != "1" ) ; else res += ( s [ n - i - 1 ] != "0" ) ; } return res ; }
function lenoflongestnonpalindrome ( s ) { let max1 = 1 , len = 0 ; for ( let i = 0 ; i < s . length - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) len = 0 ; else if ( s [ i + 1 ] == s [ i - 1 ] && i > 0 ) len = 1 ; len ++ ; } if ( max1 == 1 ) return 0 ; else return max1 ; }
function calcScore ( str ) { var score = 0 ; var len = str . length ; for ( var i = 0 ; i < len ; ) { var chunkSize = 1 ; var currentChar = str [ i ++ ] ; while ( i < len && str [ i ] == currentChar ) { chunkSize ++ ; i ++ ; } if ( currentChar == "1" ) score += Math . pow ( chunkSize , 2 ) ; else score -= Math . pow ( chunkSize , 2 ) ; } return score ; }
function pre_process ( substrings , s ) { var n = s . length ; for ( var i = 0 ; i < n ; i ++ ) { var dup = "" ; for ( var j = i ; j < n ; j ++ ) { dup += s [ j ] ; substrings . push ( dup ) ; } } substrings . sort ( ) ; }
function check ( s ) { let n = s . length ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) return true ; } return false ; }
function countSubString ( s , c , k ) { var leftCount = 0 , rightCount = 0 ; var left = 0 , right = 0 ; var freq = 0 ; var result = 0 , len = s . length ; while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } right = left + 1 ; while ( freq != ( k - 1 ) && ( right - 1 ) < len ) { if ( s [ right ] == c ) freq ++ ; right ++ ; } while ( left < len && ( right - 1 ) < len ) { while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } while ( right < len && s [ right ] != c ) { if ( s [ right ] == c ) freq ++ ; right ++ ; rightCount ++ ; } result = result + ( leftCount + 1 ) * ( rightCount + 1 ) ; freq = k - 1 ; leftCount = 0 ; rightCount = 0 ; left ++ ; right ++ ; } return result ; }
function performQueries ( l , r , prefix ) { l -- ; r -- ; let flag = false ; let count = 0 ; for ( let i = 0 ; i < 26 ; i ++ ) { let cnt = prefix [ r ] [ i ] ; if ( l > 0 ) cnt -= prefix [ l - 1 ] [ i ] ; if ( cnt % 2 == 1 ) { flag = true ; count += cnt - 1 ; } else count += cnt ; } if ( flag ) count += 1 ; return count ; }
function printSmallSub ( arr , N ) { let gcdArr = 0 ; for ( let i = 0 ; i < N ; i ++ ) { gcdArr = gcd ( gcdArr , arr [ i ] ) ; } for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == gcdArr ) { document . write ( arr [ i ] + "▁" ) ; return ; } } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( gcd ( arr [ i ] , arr [ j ] ) == gcdArr ) { document . write ( arr [ i ] + "▁" + arr [ j ] ) ; return ; } } } }
function countSubStr ( str , n , x ) { let res = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; }
function isValid ( str , n ) { if ( ! ( ( str [ 0 ] >= "a" && str [ 0 ] <= "z" ) || ( str [ 0 ] >= "A" && str [ 0 ] <= "Z" ) str [ 0 ] == "_" ) ) return false ; for ( let i = 1 ; i < str . length ; i ++ ) { if ( ! ( ( str [ i ] >= "a" && str [ i ] <= "z" ) || ( str [ i ] >= "A" && str [ i ] <= "Z" ) || ( str [ i ] >= "0" && str [ i ] <= "9" ) str [ i ] == "_" ) ) return false ; } return true ; }
function countSubStr ( str , n ) { var len = str . length ; return len - n + 1 ; }
function countSubstrings ( s , c ) { var n = s . length ; var cnt = 0 ; var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; }
function equalIgnoreCase ( str1 , str2 ) { let i = 0 ; str1 = str1 . toUpperCase ( ) ; str2 = str2 . toUpperCase ( ) ; let x = str1 == ( str2 ) ; if ( ! x ) { return false ; } else { return true ; } }
function equalIgnoreCaseUtil ( str1 , str2 ) { let res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) { document . write ( "Same" ) ; } else { document . write ( "Not▁Same" ) ; } }
function equalIgnoreCase ( str1 , str2 ) { let i = 0 ; str1 = str1 . toLowerCase ( ) ; str2 = str2 . toLowerCase ( ) ; let x = ( str1 == ( str2 ) ) ; return x == true ; }
function equalIgnoreCaseUtil ( str1 , str2 ) { let res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) document . write ( "Same" ) ; else document . write ( "Not▁Same" ) ; }
function findM ( s , x ) { var cnt = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s . charCodeAt ( i ) - "0" . charCodeAt ( 0 ) != x ) cnt ++ ; } return cnt ; }
function FirstAndLast ( str ) { for ( var i = 0 ; i < str . length ; i ++ ) { if ( i == 0 ) document . write ( str [ i ] ) ; if ( i == str . length - 1 ) document . write ( str [ i ] ) ; if ( str [ i ] === "▁" ) { document . write ( str [ i - 1 ] + "▁" + str [ i + 1 ] ) ; } } }
function Longestsubstring ( s ) { var lps = compute_lps ( s ) ; var n = s . length ; if ( lps [ n - 1 ] == 0 ) { document . write ( - 1 ) ; return ; } for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( lps [ i ] == lps [ n - 1 ] ) { document . write ( s . substring ( 0 , lps [ i ] ) ) ; return ; } } if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) document . write ( - 1 ) ; else document . write ( s . substr ( 0 , lps [ lps [ n - 1 ] - 1 ] ) ) ; }
function getBitmask ( s ) { var temp = 0 ; for ( var j = 0 ; j < s . length ; j ++ ) { switch ( s [ j ] ) { case "s" : temp = temp | 1 ; break ; case "t" : temp = temp | 2 ; break ; case "r" : temp = temp | 4 ; break ; case "i" : temp = temp | 8 ; break ; case "n" : temp = temp | 16 ; break ; case "g" : temp = temp | 32 ; break ; default : break ; } } return temp ; }
function calculateWays ( s , n , l , r ) { var freq = Array ( 26 ) . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { if ( i < l i > r ) freq [ s . charCodeAt ( i ) - "a" . charCodeAt ( 0 ) ] ++ ; } var ways = 1 ; for ( i = l ; i <= r ; i ++ ) { if ( freq [ s . charCodeAt ( i ) - "a" . charCodeAt ( 0 ) ] != 0 ) { ways = ways * freq [ s . charCodeAt ( i ) - "a" . charCodeAt ( 0 ) ] ; freq [ s . charCodeAt ( i ) - "a" . charCodeAt ( 0 ) ] -- ; } else { ways = 0 ; break ; } } return ways ; }
function asciiToSentence ( str , len ) { var num = 0 ; for ( var i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str [ i ] - "0" ) ; if ( num >= 32 && num <= 122 ) { var ch = String . fromCharCode ( num ) ; document . write ( ch ) ; num = 0 ; } } }
function countDistinctCode ( str ) { var codes = new Set ( ) ; for ( var i = 0 ; i < str . length - 1 ; i ++ ) codes . add ( str . substr ( i , 2 ) ) ; return codes . size ; }
function isReverseEqual ( s1 , s2 ) { if ( s1 . length != s2 . length ) return false ; let len = s1 . length ; for ( let i = 0 ; i < len ; i ++ ) if ( s1 [ i ] != s2 [ len - i - 1 ] ) return false ; return true ; }
function isPrefix ( str , len , i , k ) { if ( i + k > len ) return false ; for ( let j = 0 ; j < k ; j ++ ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; } return true ; }
function isKPeriodic ( str , len , k ) { for ( let i = k ; i < len ; i += k ) if ( ! isPrefix ( str , len , i , k ) ) return false ; return true ; }
function isFrequencyEqual ( str , len ) { if ( len % 2 == 1 ) return false ; var i , freq = Array ( 26 ) . fill ( 0 ) ; for ( i = 0 ; i < len ; i ++ ) freq [ str [ i ] - "a" ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) if ( freq [ i ] == parseInt ( len / 2 ) ) return true ; return false ; }
function minLettersNeeded ( n ) { if ( n % 26 == 0 ) return parseInt ( n / 26 ) ; else return ( parseInt ( n / 26 ) + 1 ) ; }
function countMinReversals ( expr ) { var len = expr . length ; if ( len % 2 ) return - 1 ; var ans = 0 ; var i ; var open = 0 ; var close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == "{" ) open ++ ; else { if ( ! open ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close ) ans += 2 ; return ans ; }
function minReplacement ( s , len ) { var ans = 0 ; for ( var i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s [ i ] == "1" ) ans ++ ; if ( i % 2 == 1 && s [ i ] == "0" ) ans ++ ; } return Math . min ( ans , len - ans ) ; }
function maxBalancedStr ( s ) { var open1 = 0 , close1 = 0 ; var open2 = 0 , close2 = 0 ; var open3 = 0 , close3 = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { switch ( s . charAt ( i ) ) { case "(" : open1 ++ ; break ; case ")" : close1 ++ ; break ; case "{" : open2 ++ ; break ; case "}" : close2 ++ ; break ; case "[" : open3 ++ ; break ; case "]" : close3 ++ ; break ; } } var maxLen = 2 * Math . min ( open1 , close1 ) + 2 * Math . min ( open2 , close2 ) + 2 * Math . min ( open3 , close3 ) ; return maxLen ; }
function totalPairs ( s1 , s2 ) { var count = 0 ; var arr1 = new Array ( 7 ) . fill ( 0 ) ; var arr2 = new Array ( 7 ) . fill ( 0 ) ; for ( let i = 0 ; i < s1 . length ; i ++ ) { set_bits = countSetBits ( s1 [ i ] . charCodeAt ( 0 ) ) ; arr1 [ set_bits ] += 1 ; } for ( let i = 0 ; i < s2 . length ; i ++ ) { set_bits = countSetBits ( s2 [ i ] . charCodeAt ( 0 ) ) ; arr2 [ set_bits ] += 1 ; } for ( let i = 1 ; i < 7 ; i ++ ) { count += arr1 [ i ] * arr2 [ i ] ; } return count ; }
function findCost ( s1 , s2 , a , b , c , d , n ) { var cost = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; else { if ( ( s1 [ i ] == "1" && s2 [ i ] == "2" ) || ( s2 [ i ] == "1" && s1 [ i ] == "2" ) ) cost += Math . min ( d , Math . min ( a , b + c ) ) ; else if ( ( s1 [ i ] == "2" && s2 [ i ] == "3" ) || ( s2 [ i ] == "2" && s1 [ i ] == "3" ) ) cost += Math . min ( d , Math . min ( b , a + c ) ) ; else if ( ( s1 [ i ] == "1" && s2 [ i ] == "3" ) || ( s2 [ i ] == "1" && s1 [ i ] == "3" ) ) cost += Math . min ( d , Math . min ( c , a + b ) ) ; } } return cost ; }
function totalPairs ( s1 , s2 ) { var a1 = 0 , b1 = 0 ; for ( var i = 0 ; i < s1 . length ; i ++ ) { if ( ( s1 [ i ] . charCodeAt ( 0 ) ) % 2 != 0 ) a1 ++ ; else b1 ++ ; } var a2 = 0 , b2 = 0 ; for ( var i = 0 ; i < s2 . length ; i ++ ) { if ( ( s2 [ i ] . charCodeAt ( 0 ) ) % 2 != 0 ) a2 ++ ; else b2 ++ ; } return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; }
function replaceConsonants ( str ) { var res = "" ; var i = 0 , count = 0 ; while ( i < str . length ) { if ( str [ i ] !== "a" && str [ i ] !== "e" && str [ i ] !== "i" && str [ i ] !== "o" && str [ i ] !== "u" ) { i ++ ; count ++ ; } else { if ( count > 0 ) res += count . toString ( ) ; res += str [ i ] ; i ++ ; count = 0 ; } } if ( count > 0 ) res += count . toString ( ) ; return res ; }
function prefixOccurrences ( str ) { var c = str . charAt ( 0 ) ; var countc = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str . charAt ( i ) == c ) countc ++ ; } return countc ; }
function Preprocess ( A , B ) { let n = A . length ; let ans = 0 ; for ( let i = 0 ; i < n / 2 ; i ++ ) { let mp = new Map ( ) ; if ( mp . has ( A [ i ] ) ) mp . set ( A [ i ] , mp . get ( A [ i ] ) + 1 ) ; else mp . set ( A [ i ] , 1 ) ; if ( mp . has ( A [ n - i - 1 ] ) ) mp . set ( A [ n - i - 1 ] , mp . get ( A [ n - i - 1 ] ) + 1 ) ; else mp . set ( A [ n - i - 1 ] , 1 ) ; if ( mp . has ( B [ i ] ) ) mp . set ( B [ i ] , mp . get ( B [ i ] ) + 1 ) ; else mp . set ( B [ i ] , 1 ) ; if ( mp . has ( B [ n - i - 1 ] ) ) mp . set ( B [ n - i - 1 ] , mp . get ( B [ n - i - 1 ] ) + 1 ) ; else mp . set ( B [ n - i - 1 ] , 1 ) ; let sz = mp . size ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A [ i ] == A [ n - i - 1 ] ? 1 : 0 ) ; else if ( sz == 2 ) ans += mp . get ( A [ i ] ) != 2 ? 1 : 0 ; } if ( n % 2 == 1 && A [ Math . floor ( n / 2 ) ] != B [ Math . floor ( n / 2 ) ] ) ans ++ ; return ans ; }
function isPalindrome ( s ) { let i = 0 ; let j = s . length - 1 ; while ( i < j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; }
function getIndex ( S1 , S2 , n ) { let S = "" ; for ( let i = 0 ; i < n ; i ++ ) { S = S + S1 [ i ] ; let Temp = "" ; for ( let j = i + 1 ; j < n ; j ++ ) Temp += S2 [ j ] ; if ( isPalindrome ( S + Temp ) ) { return i ; } } return - 1 ; }
function isPalindrome ( s , i , j ) { while ( i < j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; }
function isVowel ( c ) { if ( c === "a" c === "e" c === "i" c === "o" c === "u" ) return true ; return false ; }
function checkPossibility ( s1 , s2 ) { var l1 = s1 . length ; var l2 = s2 . length ; if ( l1 !== l2 ) return false ; for ( var i = 0 ; i < l1 ; i ++ ) { if ( isVowel ( s1 [ i ] ) && isVowel ( s2 [ i ] ) ) continue ; else if ( ! isVowel ( s1 [ i ] ) && ! isVowel ( s2 [ i ] ) ) continue ; else return false ; } return true ; }
function generateString ( A , B ) { let rt = "" ; while ( 0 < A 0 < B ) { if ( A < B ) { if ( 0 < B -- ) { rt += ( "b" ) ; } if ( 0 < B -- ) { rt += ( "b" ) ; } if ( 0 < A -- ) { rt += ( "a" ) ; } } else if ( B < A ) { if ( 0 < A -- ) { rt += ( "a" ) ; } if ( 0 < A -- ) { rt += ( "a" ) ; } if ( 0 < B -- ) { rt += ( "b" ) ; } } else { if ( 0 < A -- ) { rt += ( "a" ) ; } if ( 0 < B -- ) { rt += ( "b" ) ; } } } document . write ( rt ) ; }
function countStrings ( n , m , s ) { let ind = new Set ( ) ; for ( let j = 0 ; j < m ; j ++ ) { let mx = 0 ; for ( let i = 0 ; i < n ; i ++ ) mx = Math . max ( mx , ( s [ i ] [ j ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) ) ; for ( let i = 0 ; i < n ; i ++ ) if ( s [ i ] [ j ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) == mx ) ind . add ( i ) ; } return ind . size ; }
function minOperations ( s , t , n ) { var ct0 = 0 , ct1 = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] === t [ i ] ) continue ; if ( s [ i ] === "0" ) ct0 ++ ; else ct1 ++ ; } return Math . max ( ct0 , ct1 ) ; }
function count_acronym ( n , arr ) { let freq = new Array ( 26 ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) freq [ arr [ i ] [ 0 ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ++ ; let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let st = arr [ i ] ; let num = new Array ( 26 ) ; num . fill ( 0 ) ; for ( let j = 0 ; j < st . length ; j ++ ) num [ st [ j ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ++ ; let flag = true ; for ( let j = 1 ; j < 26 ; j ++ ) { if ( num [ j ] > freq [ j ] ) { flag = false ; break ; } } let x = st [ 0 ] . charCodeAt ( ) - "a" . charCodeAt ( ) ; if ( freq [ x ] - 1 < num [ x ] ) flag = false ; if ( flag ) cnt ++ ; } return cnt ; }
function minOperations ( str , n ) { var i , lastUpper = - 1 , firstLower = - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( isupper ( str [ i ] ) ) { lastUpper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( islower ( str [ i ] ) ) { firstLower = i ; break ; } } if ( lastUpper === - 1 firstLower === - 1 ) return 0 ; var countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( isupper ( str [ i ] ) ) { countUpper ++ ; } } var countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( islower ( str [ i ] ) ) { countLower ++ ; } } return Math . min ( countLower , countUpper ) ; }
function check ( s , k ) { for ( var i = 0 ; i < s . length ; i ++ ) if ( s [ i ] != s [ i % k ] ) return false ; return true ; }
function countCommonDivisors ( a , b ) { var ct = 0 ; var n = a . length , m = b . length ; for ( var i = 1 ; i <= Math . min ( n , m ) ; i ++ ) { if ( n % i == 0 && m % i == 0 ) if ( a . substring ( 0 , i ) == b . substring ( 0 , i ) ) if ( check ( a , i ) && check ( b , i ) ) ct ++ ; } return ct ; }
function valid ( cnt ) { for ( var i = 0 ; i < 26 ; i ++ ) { if ( cnt [ i ] >= 2 ) return false ; } return true ; }
function isVowel ( c ) { c = c . toLowerCase ( ) ; if ( c === "a" c === "e" c === "i" c === "o" c === "u" ) { return true ; } return false ; }
function largestPalinSub ( s ) { let res = "" ; let mx = s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) mx = String . fromCharCode ( Math . max ( mx . charCodeAt ( ) , s [ i ] . charCodeAt ( ) ) ) ; for ( let i = 0 ; i < s . length ; i ++ ) if ( s [ i ] == mx ) res += s [ i ] ; return res ; }
function isValid ( str , len ) { for ( let i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; } return true ; }
function decryptString ( str , n ) { let i = 0 , jump = 1 ; let decryptedStr = "" ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; }
function countSubStr ( str , len , k ) { let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let n = 0 ; for ( let j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] . charCodeAt ( ) - "0" . charCodeAt ( ) ) ; if ( n % k == 0 ) count ++ ; } } return count ; }
function nextZero ( i , occurrences ) { while ( i < occurrences . length ) { if ( occurrences [ i ] == 0 ) return i ; i ++ ; } return - 1 ; }
function findPermutation ( str , k ) { var has = new Array ( 26 ) ; for ( var i = 0 ; i < 26 ; i ++ ) has [ i ] = false ; var cnt = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( ! has [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ) { cnt ++ ; has [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] = true ; } } var ans = 1 ; for ( var i = 2 ; i <= cnt ; i ++ ) ans *= i ; for ( var i = cnt - k ; i > 1 ; i -- ) ans /= i ; return ans ; }
function countPairs ( bracks , num ) { let open = new Map ( ) ; let close = new Map ( ) ; let cnt = 0 ; for ( let i = 0 ; i < num ; i ++ ) { let s = bracks [ i ] ; let l = s . length ; let op = 0 , cl = 0 ; for ( let j = 0 ; j < l ; j ++ ) { if ( s [ j ] == "(" ) op ++ ; else { if ( op != 0 ) op -- ; else cl ++ ; } } if ( op != 0 && cl == 0 ) open . set ( op , open . get ( op ) == null ? 1 : open . get ( op ) + 1 ) ; if ( cl != 0 && op == 0 ) close . set ( cl , close . get ( cl ) == null ? 1 : close . get ( cl ) + 1 ) ; if ( op == 0 && cl == 0 ) cnt ++ ; } cnt /= 2 ; for ( let [ key , value ] of open . entries ( ) ) cnt += Math . min ( value , close . get ( value ) ) ; return cnt ; }
function no_of_ways ( s ) { let n = s . length ; let count_left = 0 , count_right = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( s [ i ] == s [ 0 ] ) { ++ count_left ; } else break ; } for ( let i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == s [ n - 1 ] ) { ++ count_right ; } else break ; } if ( s [ 0 ] == s [ n - 1 ] ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ; else return ( count_left + count_right + 1 ) ; }
function isPalindrome ( str ) { let len = str . length ; for ( let i = 0 ; i < len / 2 ; i ++ ) { if ( str [ i ] != str [ len - 1 - i ] ) return false ; } return true ; }
function createStringAndCheckPalindrome ( N ) { let sub = "" + N , res_str = "" ; let sum = 0 ; while ( N > 0 ) { let digit = N % 10 ; sum += digit ; N = N / 10 ; } while ( res_str . length < sum ) res_str += sub ; if ( res_str . length > sum ) res_str = res_str . substring ( 0 , sum ) ; if ( isPalindrome ( res_str ) ) return true ; return false ; }
function product ( x ) { let prod = 1 ; while ( x > 0 ) { prod *= ( x % 10 ) ; x = parseInt ( x / 10 , 10 ) ; } return prod ; }
function removeChars ( s ) { let modifiedStr = "" ; modifiedStr += s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == ( s [ i ] ) . toUpperCase ( ) && ( s [ i - 1 ] ) == ( s [ i - 1 ] ) . toLowerCase ( ) || s [ i ] == s [ i ] . toLowerCase ( ) && ( s [ i - 1 ] ) == ( s [ i - 1 ] ) . toUpperCase ( ) ) modifiedStr += s [ i ] ; } return modifiedStr ; }
function pangramCost ( arr , str ) { var cost = 0 ; var occurred = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) occurred [ i ] = false ; for ( let i = 0 ; i < str . length ; i ++ ) occurred [ str [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] = true ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( occurred [ i ] == false ) cost += arr [ i ] ; } return cost ; }
function pairStar ( input , i ) { output = output + input [ i ] ; if ( i == input . length - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + "*" ; pairStar ( input , i + 1 ) ; }
function countMinParts ( str ) { let n = str . length ; let freq = getFrequencies ( str ) ; let oddFreq = [ ] ; let evenFreq = [ ] ; let i , sumEven = 0 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) continue ; if ( freq [ i ] % 2 == 0 ) evenFreq . push ( freq [ i ] ) ; else oddFreq . push ( freq [ i ] ) ; } for ( i = 0 ; i < evenFreq . length ; i ++ ) { sumEven += evenFreq [ i ] ; } if ( oddFreq . length == 0 ) return 1 ; if ( sumEven == 0 ) { if ( oddFreq . length == 1 ) return 1 ; return 0 ; } i = 0 ; while ( i < oddFreq . length ) { if ( ( sumEven / 2 ) % oddFreq . length == 0 ) return oddFreq . length ; if ( oddFreq [ i ] == 1 ) { i ++ ; continue ; } sumEven += 2 ; oddFreq [ i ] = oddFreq [ i ] - 2 ; } return n ; }
function check ( s , K ) { for ( var ch = 0 ; ch < 26 ; ch ++ ) { var c = String . fromCharCode ( "a" . charCodeAt ( 0 ) + ch ) ; var last = - 1 ; var found = true ; for ( var i = 0 ; i < K ; i ++ ) if ( s [ i ] == c ) last = i ; if ( last == - 1 ) continue ; for ( var i = K ; i < s . length ; i ++ ) { if ( s [ i ] == c ) last = i ; if ( last <= ( i - K ) ) { found = false ; break ; } } if ( found ) return 1 ; } return 0 ; }
function binarySearch ( s ) { var low = 1 , high = s . length ; var ans ; while ( low <= high ) { var mid = ( high + low ) >> 1 ; if ( check ( s , mid ) ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; }
function subStringsStartingHere ( str , n , startIndex ) { var count = 0 , i = startIndex + 1 ; while ( i <= n ) { if ( str . startsWith ( str . substring ( startIndex , i ) ) ) { count ++ ; } else break ; i ++ ; } return count ; }
function printExpansion ( str ) { var size = 0 ; for ( var i = str . length - 1 ; i >= 0 ; i -- ) { var subStr = str . substring ( i , i + ++ size ) ; document . write ( subStr ) ; } }
function printExpansion ( str ) { var suff = "" ; for ( var i = str . length - 1 ; i >= 0 ; i -- ) { suff = suff + str [ i ] ; document . write ( suff ) ; } }
function search ( pat , txt ) { let M = pat . length ; let N = txt . length ; let i ; let countP = new Array ( ALL_CHARS ) ; countP . fill ( 0 ) ; let countTW = new Array ( ALL_CHARS ) ; countTW . fill ( 0 ) ; for ( i = 0 ; i < M ; i ++ ) { countP [ pat [ i ] . charCodeAt ( ) ] ++ ; countTW [ txt [ i ] . charCodeAt ( ) ] ++ ; } for ( i = M ; i < N ; i ++ ) { if ( compare ( countP , countTW ) ) { return true ; } countTW [ txt [ i ] . charCodeAt ( ) ] ++ ; countTW [ txt [ i - M ] . charCodeAt ( ) ] -- ; } if ( compare ( countP , countTW ) ) return true ; return false ; }
function logicalExpressionEvaluation ( str ) { let arr = [ ] ; for ( let i = str . length - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == "[" ) { let s = [ ] ; while ( arr [ arr . length - 1 ] != "]" ) { s . push ( arr [ arr . length - 1 ] ) ; arr . pop ( ) ; } arr . pop ( ) ; if ( s . length == 3 ) { arr . push ( s [ 2 ] == "1" ? "0" : "1" ) ; } else if ( s . length == 5 ) { let a = s [ 0 ] . charCodeAt ( 0 ) - 48 , b = s [ 4 ] . charCodeAt ( 0 ) - 48 , c ; if ( s [ 2 ] == "&" ) { c = a & b ; } else { c = a | b ; } arr . push ( String . fromCharCode ( c + 48 ) ) ; } } else { arr . push ( str [ i ] ) ; } } return arr [ arr . length - 1 ] ; }
function count ( s , k ) { var n = s . length ; var d = 0 , i ; var count = 0 ; for ( i = 0 ; i < n ; i ++ ) d += s [ i ] . charCodeAt ( 0 ) ; if ( d % k === 0 ) { count += 1 ; } for ( i = k ; i < n ; i ++ ) { var prev = s [ i - k ] ; d -= prev . charCodeAt ( 0 ) ; d += s [ i ] . charCodeAt ( 0 ) ; if ( d % k === 0 ) count += 1 ; } return count ; }
function MaxFreq ( str ) { let n = str . length ; let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let s = "" ; for ( let j = i ; j < n ; j ++ ) { s += str [ j ] ; if ( mp . has ( s ) ) { mp . set ( s , mp . get ( s ) + 1 ) ; } else { mp . set ( s , 1 ) ; } } } let maxi = 0 ; let s = "" ; for ( let [ key , value ] of mp . entries ( ) ) { if ( value > maxi ) { maxi = value ; s = key ; } else if ( value == maxi ) { let ss = key ; if ( ss . length > s . length ) s = ss ; } } return s ; }
function preCompute ( n , s , pref ) { pref [ 0 ] = 0 ; for ( let i = 1 ; i < n ; i ++ ) { pref [ i ] = pref [ i - 1 ] ; if ( s [ i - 1 ] == s [ i ] ) pref [ i ] ++ ; } }
function query ( pref , l , r ) { return pref [ r ] - pref [ l ] ; }
function countWays ( s1 , s2 , n ) { var a , b , c , d ; a = b = c = d = 0 ; var result = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s2 . charAt ( i ) == "0" ) { if ( s1 . charAt ( i ) == "0" ) { c ++ ; } else { d ++ ; } } else { if ( s1 . charAt ( i ) == "0" ) { a ++ ; } else { b ++ ; } } } result = a * d + b * c + c * d ; return result ; }
function isPrime ( n ) { var i ; if ( n == 1 ) return false ; for ( i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
function check_frequency ( s ) { var m = new Map ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) if ( m . has ( s [ i ] ) ) { m . set ( s [ i ] , m . get ( s [ i ] ) + 1 ) ; } else { m . set ( s [ i ] , 1 ) ; } for ( var ch = "a" . charCodeAt ( 0 ) ; ch <= "z" . charCodeAt ( 0 ) ; ch ++ ) if ( m . get ( String . fromCharCode ( ch ) ) > 0 && ! isPrime ( m . get ( String . fromCharCode ( ch ) ) ) ) return false ; return true ; }
function returnWinner ( s , l ) { let freq = new Array ( 26 ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < l ; i ++ ) { freq [ s [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ++ ; } let cnt = 0 ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] % 2 != 0 ) cnt ++ ; } if ( ( cnt == 0 ) || ( cnt & 1 ) == 1 ) return 1 ; else return 2 ; }
function check ( s ) { var i , j ; var fr = Array ( 26 ) . fill ( 0 ) ; var n = s . length ; for ( i = 0 ; i < n ; i ++ ) { var x = s [ i ] ; fr [ x . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] += 1 ; } var minimum = 10000000000 ; for ( i = 0 ; i < 26 ; i ++ ) { for ( j = i + 1 ; j < 26 ; j ++ ) { var z = fr [ i ] + fr [ j ] ; minimum = Math . min ( minimum , n - z ) ; } } return minimum ; }
function findSubstringCount ( str ) { var result = 0 ; var n = str . length ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( String . fromCharCode ( str [ i ] . charCodeAt ( 0 ) + 1 ) == str [ i + 1 ] ) { result ++ ; while ( String . fromCharCode ( str [ i ] . charCodeAt ( 0 ) + 1 ) === str [ i + 1 ] ) { i ++ ; } } } return result ; }
function CountCharacters ( str , l , r ) { let cnt = 0 ; let m = new Map ( ) ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= r ) ) { cnt ++ ; if ( ! m . has ( str [ i ] ) ) { m . set ( str [ i ] , 0 ) ; document . write ( str [ i ] + "▁" ) ; } m . set ( str [ i ] , m . get ( str [ i ] + 1 ) ) ; } } return cnt ; }
function strScore ( str , s , n ) { var score = 0 , index = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( j = 0 ; j < s . length ; j ++ ) { score += s . charAt ( j ) . charCodeAt ( 0 ) - ( "a" ) . charCodeAt ( 0 ) + 1 ; } index = i + 1 ; break ; } } score = score * index ; return score ; }
function countChar ( str , x ) { let count = 0 ; let n = 10 ; for ( let i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == x ) count ++ ; let repetitions = n / str . length ; count = count * repetitions ; for ( let i = 0 ; i < n % str . length ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; }
function countConsecutive ( s ) { let count = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) i ++ ; else count ++ ; } return count ; }
function check_digits ( n ) { while ( n > 1 ) { if ( ( n % 10 ) % 2 == 0 ) return 0 ; n = parseInt ( n / 10 ) ; } return 1 ; }
function smallest_number ( n ) { for ( i = n ; ; i ++ ) if ( check_digits ( i ) ) return i ; }
function minSteps ( str ) { let count = 0 ; for ( let i = 0 ; i < str . length - 2 ; i ++ ) { if ( ( str [ i ] ) == "0" ) { if ( str [ i + 1 ] == "1" ) { if ( str [ i + 2 ] == "0" ) { count ++ ; i += 2 ; } } } } return count ; }
function SieveOfEratosthenes ( prime , p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( var p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( var i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
function xorOfPrime ( s ) { var prime = Array ( 100005 ) . fill ( true ) ; SieveOfEratosthenes ( prime , 10005 ) ; var i , j ; var m = new Map ( ) ; for ( i = 0 ; i < s . length ; i ++ ) { if ( m . has ( s [ i ] ) ) { m . set ( s [ i ] , m . get ( s [ i ] ) + 1 ) ; } else { m . set ( s [ i ] , 1 ) ; } } var result = 0 ; var flag = 0 ; m . forEach ( ( value , key ) => { if ( prime [ value ] ) { result ^= value ; flag = 1 ; } } ) ; if ( ! flag ) return - 1 ; return result ; }
function CountCharacters ( str , k ) { let cnt = 0 ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] . charCodeAt ( 0 ) < k ) cnt ++ ; } return cnt ; }
function dfs ( node , k , A ) { for ( var i = 0 ; i < k ; ++ i ) { var str = node + A [ i ] ; if ( ! seen . has ( str ) ) { seen . add ( str ) ; dfs ( str . substring ( 1 ) , k , A ) ; edges . push ( i ) ; } } }
function fact ( n ) { let f = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { f = f * i ; } return f ; }
function npr ( n , r ) { return fact ( n ) / fact ( n - r ) ; }
function checkIfUnequal ( n , q ) { let s1 = n . toString ( ) ; let a = new Array ( 26 ) ; for ( let i = 0 ; i < a . length ; i ++ ) { a [ i ] = 0 ; } for ( let i = 0 ; i < s1 . length ; i ++ ) a [ s1 [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ] ++ ; let prod = n * q ; let s2 = prod . toString ( ) ; for ( let i = 0 ; i < s2 . length ; i ++ ) { if ( a [ s2 [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ] > 0 ) return false ; } return true ; }
function countInRange ( l , r , q ) { let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { if ( checkIfUnequal ( i , q ) ) count ++ ; } return count ; }
function search ( arr , strt , end , value ) { let i ; for ( i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) break ; } return i ; }
function preOrder ( node ) { if ( node == null ) return ; document . write ( node . data + "▁" ) ; preOrder ( node . left ) ; preOrder ( node . right ) ; }
function countOnOff ( n ) { var Led = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 5 ] ; var len = n . length ; var sum = Led [ n . charAt ( 0 ) - "0" ] ; for ( i = 1 ; i < len ; i ++ ) { sum = sum + Math . abs ( Led [ n . charAt ( i ) - "0" ] - Led [ n . charAt ( i - 1 ) - "0" ] ) ; } return sum ; }
function checkMarkov ( m ) { for ( let i = 0 ; i < n ; i ++ ) { let sum = 0 ; for ( let j = 0 ; j < n ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
function isBinary ( n ) { while ( n != 0 ) { var temp = n % 10 ; if ( temp != 0 && temp != 1 ) { return false ; } n = parseInt ( n / 10 ) ; } return true ; }
function checkPalindrome ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] != s [ s . length - i - 1 ] ) return false ; } return true ; }
function CheckOdd ( s ) { let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { let x = "" ; for ( let j = i ; j < n ; j ++ ) { x += s [ j ] ; if ( x . length % 2 == 0 && checkPalindrome ( x ) == true ) return false ; } } return true ; }
function areVowelsInOrder ( s ) { var n = s . length ; var c = String . fromCharCode ( 64 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == "a" s [ i ] == "e" s [ i ] == "i" s [ i ] == "o" s [ i ] == "u" ) { if ( s [ i ] < c ) return false ; else { c = s [ i ] ; } } } return true ; }
function solve ( s , k ) { var count = 0 , length = 0 , pos = 0 ; var m = new Map ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( ! m . has ( s [ i ] ) ) { m . set ( s [ i ] , 0 ) ; } m . set ( s [ i ] , m . get ( s [ i ] ) + 1 ) ; length ++ ; if ( length > k ) { if ( ! m . has ( s [ pos ] ) ) { m . set ( s [ pos ] , 0 ) ; } m . set ( s [ pos ] , m [ s [ pos ] ] - 1 ) ; pos += 1 ; length -- ; } if ( length == k && m . get ( s [ i ] ) == length ) count ++ ; } document . write ( count ) ; }
function solve ( s ) { let m = new Map ( ) ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( m . has ( s [ i ] ) ) m . set ( s [ i ] , m . get ( s [ i ] ) + 1 ) ; else m . set ( s [ i ] , 1 ) ; } let new_string = "" ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( m . get ( s [ i ] ) % 2 == 0 ) continue ; new_string = new_string + s [ i ] ; } document . write ( new_string ) ; }
function isDiagonalMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; }
function minParentheses ( p ) { var bal = 0 ; var ans = 0 ; for ( var i = 0 ; i < p . length ; ++ i ) { bal += p [ i ] == "(" ? 1 : - 1 ; if ( bal == - 1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }
function fact ( n ) { let result = 1 ; for ( let i = 1 ; i <= n ; i ++ ) result *= i ; return result ; }
function getResult ( str , ch ) { let has = new Array ( 26 ) . fill ( null ) ; for ( let i = 0 ; i < str . length ; i ++ ) has [ str . charCodeAt ( i ) - "A" . charCodeAt ( 0 ) ] ++ ; particular = has [ ch . charCodeAt ( 0 ) - "A" . charCodeAt ( 0 ) ] ; if ( particular == 0 ) return 0 ; has [ ch . charCodeAt ( 0 ) - "A" . charCodeAt ( 0 ) ] = 0 ; let total = str . length ; total = total - particular + 1 ; let result = fact ( total ) ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( has [ i ] > 1 ) { result = result / fact ( has [ i ] ) ; } } return result ; }
function isAnyNotPalindrome ( s ) { var unique = new Set ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) unique . add ( s [ i ] ) ; if ( unique . size > 1 ) return true ; else return false ; }
function factorial ( n ) { let res = 1 ; for ( let i = 1 ; i <= n ; i ++ ) res = res * i ; return res ; }
function isScalarMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( let i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }
function Remainder ( str , R ) { var len = str . length ; var Num , Rem = 0 ; for ( var i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - "0" ) ; Rem = Num % R ; } return Rem ; }
function Solve ( N , M ) { let temp = ( N - 1 ) * ( M - 1 ) ; let ans = ( Math . pow ( 2 , temp ) ) ; if ( ( N + M ) % 2 != 0 ) document . write ( ans ) ; else document . write ( 2 * ans ) ; }
function countWays ( a , n ) { let i , j ; let suff = new Array ( n ) ; if ( a [ n - 1 ] == 2 ) suff [ n - 1 ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] == 2 ) suff [ i ] = suff [ i + 1 ] + 1 ; else suff [ i ] = suff [ i + 1 ] ; } let ss = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ss += suff [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && suff [ j ] >= 2 ) { ss += ( suff [ j ] ) * ( suff [ j ] - 1 ) / 2 ; } } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && ( suff [ i ] - suff [ j ] ) >= 1 && suff [ j ] >= 1 ) { ss += ( suff [ i ] - suff [ j ] ) * suff [ j ] ; } } } document . write ( ss ) ; }
function productAscii ( str ) { var prod = 1 ; for ( i = 0 ; i < str . length ; i ++ ) { prod *= str . charAt ( i ) . charCodeAt ( 0 ) ; } return prod ; }
function sortByRow ( mat , n ) { for ( let i = 0 ; i < n ; i ++ ) mat [ i ] . sort ( function ( a , b ) { return a - b ; } ) ; }
function transpose ( mat , n ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) { let temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } }
function sortMatRowAndColWise ( mat , n ) { sortByRow ( mat , n ) ; transpose ( mat , n ) ; sortByRow ( mat , n ) ; transpose ( mat , n ) ; }
function minimumLength ( s ) { var maxOcc = 0 , n = s . length ; var arr = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) arr [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; }
function balancedString ( str ) { var count = 0 , i ; var n = str . length ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == "(" ) { document . write ( str [ i ] ) ; count ++ ; } else if ( str [ i ] == ")" && count != 0 ) { document . write ( str [ i ] ) ; count -- ; } else if ( str [ i ] != ")" ) document . write ( str [ i ] ) ; } if ( count != 0 ) for ( i = 0 ; i < count ; i ++ ) document . write ( ")" ) ; }
function minOperation ( s , i , j , count ) { if ( ( i >= s . length && j < 0 ) || ( i == j ) ) return MAX ; if ( s [ i ] == s [ j ] ) return count ; if ( i >= s . length ) return minOperation ( s , i , j - 1 , count + 1 ) ; else if ( j < 0 ) return minOperation ( s , i + 1 , j , count + 1 ) ; else return Math . min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ; }
function minOperation ( s , i , j , count ) { if ( ( i >= s . length && j < 0 ) || ( i == j ) ) { return MAX ; } if ( s [ i ] == s [ j ] || ( count >= Min ) ) { return count ; } let str = ( i ) . toString ( ) + "|" + ( j ) . toString ( ) ; if ( ! m . has ( str ) ) { if ( i >= s . length ) { m . set ( str , minOperation ( s , i , j - 1 , count + 1 ) ) ; } else if ( j < 0 ) { m . set ( str , minOperation ( s , i + 1 , j , count + 1 ) ) ; } else { m . set ( str , Math . min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ) ; } } if ( m . get ( str ) < Min ) { Min = m . get ( str ) ; } return m . get ( str ) ; }
function countStrings ( s ) { let sum = 1 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( i % 2 == 0 && s [ i ] == "$" ) sum *= 21 ; else if ( s [ i ] == "$" ) sum *= 5 ; } return sum ; }
function firstPos ( str , start , end ) { let firstChar = - 1 ; for ( let i = start ; i <= end ; i ++ ) { if ( str [ i ] >= "a" && str [ i ] <= "z" ) { firstChar = i ; break ; } } return firstChar ; }
function lastPos ( str , start , end ) { let lastChar = - 1 ; for ( let i = start ; i >= end ; i -- ) { if ( str [ i ] >= "a" && str [ i ] <= "z" ) { lastChar = i ; break ; } } return lastChar ; }
function isInGivenBase ( str , bas ) { if ( bas > 16 ) return false ; else if ( bas <= 10 ) { for ( let i = 0 ; i < str . length ; i ++ ) if ( ! ( str [ i ] . charCodeAt ( ) >= "0" . charCodeAt ( ) && str [ i ] . charCodeAt ( ) < ( "0" . charCodeAt ( ) + bas ) ) ) return false ; } else { for ( let i = 0 ; i < str . length ; i ++ ) if ( ! ( ( str [ i ] . charCodeAt ( ) >= "0" . charCodeAt ( ) && str [ i ] . charCodeAt ( ) < ( "0" . charCodeAt ( ) + bas ) ) || ( str [ i ] . charCodeAt ( ) >= "A" . charCodeAt ( ) && str [ i ] . charCodeAt ( ) < ( "A" . charCodeAt ( ) + bas - 10 ) ) ) ) return false ; } return true ; }
function frequency ( fre , s , n ) { for ( let i = 0 ; i < n ; i ++ ) { let str = s [ i ] ; for ( let j = 0 ; j < str . length ; j ++ ) fre [ i ] [ str [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } }
function printIndex ( str , s ) { var flag = false ; for ( var i = 0 ; i < str . length - s . length + 1 ; i ++ ) { if ( str . substring ( i , s . length + i ) == s ) { document . write ( i + "▁" ) ; flag = true ; } } if ( flag === false ) { document . write ( "NONE" ) ; } }
function powerOfJump ( s ) { let count = 1 ; let max_so_far = Number . MIN_VALUE ; let ch = s [ s . length - 1 ] ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; }
function findLongestSub ( bin ) { let n = bin . length , i ; let sum = 0 ; let prevSum = new Map ( ) ; let maxlen = 0 ; let currlen ; for ( i = 0 ; i < n ; i ++ ) { if ( bin [ i ] == "1" ) sum ++ ; else sum -- ; if ( sum > 0 ) { maxlen = i + 1 ; } else if ( sum <= 0 ) { if ( prevSum . has ( sum - 1 ) ) { currlen = i - ( prevSum . get ( sum - 1 ) == null ? 1 : prevSum . get ( sum - 1 ) ) ; maxlen = Math . max ( maxlen , currlen ) ; } } if ( ! prevSum . has ( sum ) ) prevSum . set ( sum , i ) ; } return maxlen ; }
function countEvenOdd ( arr , n , K ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } let y ; y = __builtin_popcount ( K ) ; if ( ( y & 1 ) != 0 ) { document . write ( "Even▁=▁" + odd + ",▁Odd▁=▁" + even ) ; } else { document . write ( "Even▁=▁" + even + ",▁Odd▁=▁" + odd ) ; } }
function averageValue ( s ) { let sum_char = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { sum_char += ( s [ i ] ) . charCodeAt ( 0 ) ; } return Math . floor ( sum_char / s . length ) ; }
function findNumberOfTimes ( str1 , str2 ) { let freq = new Array ( 26 ) ; let freq2 = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { freq [ i ] = 0 ; freq2 [ i ] = 0 ; } let l1 = str1 . length ; for ( let i = 0 ; i < l1 ; i ++ ) { freq [ str1 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] += 1 ; } let l2 = str2 . length ; for ( let i = 0 ; i < l2 ; i ++ ) { freq2 [ str2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] += 1 ; } let count = Number . MAX_VALUE ; for ( let i = 0 ; i < l2 ; i ++ ) { if ( freq2 [ str2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] != 0 ) count = Math . min ( count , freq [ str2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] / freq2 [ str2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ) ; } return count ; }
function solve ( s1 , s2 ) { let flag1 = 0 , flag2 = 0 ; if ( s1 . length != s2 . length ) return false ; let l = s1 . length ; for ( let i = 0 ; i < l ; i ++ ) { if ( s1 [ i ] == "1" ) flag1 = 1 ; if ( s2 [ i ] == "1" ) flag2 = 1 ; if ( flag1 && flag2 ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; }
function check ( s , l ) { let freq = new Array ( 26 ) . fill ( 0 ) ; for ( let i = 0 ; i < l ; i ++ ) { freq [ s [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ++ ; } for ( let i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] >= 2 ) return true ; } return false ; }
function isPalindrome ( str , l , r ) { while ( l < r ) { if ( str [ l ] != str [ r ] ) return false ; l ++ ; r -- ; } return true ; }
function CyclicShifts ( str ) { var n = str . length ; var left = 0 ; var right = n - 1 ; str = str + str ; var cnt = 0 ; while ( right < 2 * n - 1 ) { if ( isPalindrome ( str , left , right ) ) break ; cnt ++ ; left ++ ; right ++ ; } return cnt ; }
function printNum ( s ) { let i = 0 , j = 0 , val = 0 ; let hm = new Map ( ) ; val = ( s [ 0 ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) * 100 + ( s [ 1 ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) * 10 + ( s [ 2 ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) ; hm . set ( val , 1 ) ; for ( i = 3 ; i < s . length ; i ++ ) { val = ( val % 100 ) * 10 + s [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ; if ( hm . has ( val ) ) { hm . set ( val , hm . get ( val ) + 1 ) ; } else { hm . set ( val , 1 ) ; } } for ( let [ Key , Value ] of hm . entries ( ) ) { let key = Key ; let value = Value ; if ( value > 1 ) document . write ( key + "▁-▁" + value + "▁times" ) ; } }
function countSubstrig ( str1 , str2 ) { let n1 = str1 . length ; let n2 = str2 . length ; if ( n1 == 0 n1 < n2 ) return 0 ; if ( str1 . substr ( 0 , n2 ) == ( str2 ) ) return countSubstrig ( str1 . substr ( n2 - 1 ) , str2 ) + 1 ; return countSubstrig ( str1 . substr ( n2 - 1 ) , str2 ) ; }
function check ( s , m ) { let l = s . length ; let c1 = 0 ; let c2 = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( s [ i ] == "0" ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }
function nextGreatestAlphabet ( alphabets , K ) { var l = 0 , r = alphabets . length - 1 ; var ans = - 1 ; while ( l <= r ) { var mid = ( l + r ) / 2 ; if ( alphabets [ mid ] > K ) { ans = mid ; r = mid - 1 ; } else l = mid + 1 ; } return alphabets [ ans ] ; }
function reverse ( str , start , end ) { let temp ; while ( start <= end ) { temp = str [ start ] ; str [ start ] = str [ end ] ; str [ end ] = temp ; start ++ ; end -- ; } }
function reverseletter ( str , start , end ) { let wstart , wend ; for ( wstart = wend = start ; wend < end ; wend ++ ) { if ( str [ wend ] == "▁" ) { continue ; } while ( wend <= end && str [ wend ] != "▁" ) { wend ++ ; } wend -- ; reverse ( str , wstart , wend ) ; } }
function subCount ( arr , n , k ) { var mod = Array ( k ) . fill ( 0 ) ; var cumSum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { cumSum += arr [ i ] ; mod [ ( ( cumSum % k ) + k ) % k ] ++ ; } var result = 0 ; for ( var i = 0 ; i < k ; i ++ ) if ( mod [ i ] > 1 ) result += ( mod [ i ] * ( mod [ i ] - 1 ) ) / 2 ; result += mod [ 0 ] ; return result ; }
function countSubmatrix ( mat , n , k ) { var tot_count = 0 ; var left , right , i ; var temp = Array ( n ) ; for ( left = 0 ; left < n ; left ++ ) { temp = Array ( n ) . fill ( 0 ) ; for ( right = left ; right < n ; right ++ ) { for ( i = 0 ; i < n ; ++ i ) temp [ i ] += mat [ i ] [ right ] ; tot_count += subCount ( temp , n , k ) ; } } return tot_count ; }
function matchClosing ( X , start , end , open , close ) { let c = 1 ; let i = start + 1 ; while ( i <= end ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i ++ ; } return i ; }
function matchingOpening ( X , start , end , open , close ) { let c = - 1 ; let i = end - 1 ; while ( i >= start ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i -- ; } return - 1 ; }
function isBalanced ( X , n ) { let i , j = 0 , k , x , start , end ; for ( i = 0 ; i < n ; i ++ ) { if ( X [ i ] == "(" ) { j = matchClosing ( X , i , n - 1 , "(" , ")" ) ; } else if ( X [ i ] == "{" ) { j = matchClosing ( X , i , n - 1 , "{" , "}" ) ; } else if ( X [ i ] == "[" ) { j = matchClosing ( X , i , n - 1 , "[" , "]" ) ; } else { if ( X [ i ] == ")" ) { j = matchingOpening ( X , 0 , i , "(" , ")" ) ; } else if ( X [ i ] == "}" ) { j = matchingOpening ( X , 0 , i , "{" , "}" ) ; } else if ( X [ i ] == "]" ) { j = matchingOpening ( X , 0 , i , "[" , "]" ) ; } if ( j < 0 j >= i ) { return false ; } continue ; } if ( j >= n j < 0 ) { return false ; } start = i ; end = j ; for ( k = start + 1 ; k < end ; k ++ ) { if ( X [ k ] == "(" ) { x = matchClosing ( X , k , end , "(" , ")" ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ")" ) { x = matchingOpening ( X , start , k , "(" , ")" ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == "{" ) { x = matchClosing ( X , k , end , "{" , "}" ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == "}" ) { x = matchingOpening ( X , start , k , "{" , "}" ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == "[" ) { x = matchClosing ( X , k , end , "[" , "]" ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == "]" ) { x = matchingOpening ( X , start , k , "[" , "]" ) ; if ( ! ( start < x && x < k ) ) { return false ; } } } } return true ; }
function possibleToSort ( arr , n , str ) { let max_element = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) { max_element = Math . max ( max_element , arr [ i ] ) ; if ( str [ i ] == "0" ) { if ( max_element > i + 1 ) return "No" ; } } return "Yes" ; }
function largestNum ( n ) { let num = 0 ; let max_setBits = 0 ; for ( let i = 0 ; i <= n ; i ++ ) { let setBits = countSetBits ( i ) ; if ( setBits >= max_setBits ) { num = i ; max_setBits = setBits ; } } return num ; }
function findMinOpeartion ( matrix , n ) { let sumRow = new Array ( n ) ; let sumCol = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { sumRow [ i ] = 0 ; sumCol [ i ] = 0 ; } for ( let i = 0 ; i < n ; ++ i ) for ( let j = 0 ; j < n ; ++ j ) { sumRow [ i ] += matrix [ i ] [ j ] ; sumCol [ j ] += matrix [ i ] [ j ] ; } let maxSum = 0 ; for ( let i = 0 ; i < n ; ++ i ) { maxSum = Math . max ( maxSum , sumRow [ i ] ) ; maxSum = Math . max ( maxSum , sumCol [ i ] ) ; } let count = 0 ; for ( let i = 0 , j = 0 ; i < n && j < n ; ) { let diff = Math . min ( maxSum - sumRow [ i ] , maxSum - sumCol [ j ] ) ; matrix [ i ] [ j ] += diff ; sumRow [ i ] += diff ; sumCol [ j ] += diff ; count += diff ; if ( sumRow [ i ] == maxSum ) ++ i ; if ( sumCol [ j ] == maxSum ) ++ j ; } return count ; }
function countPair ( str , n ) { let cnt = new Array ( 1 << 10 ) ; for ( let i = 0 ; i < cnt . length ; i ++ ) { cnt [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { let mask = 0 ; for ( let j = 0 ; j < str [ i ] . length ; ++ j ) mask |= ( 1 << ( str [ i ] [ j ] - "0" ) ) ; cnt [ mask ] ++ ; } let ans = 0 ; for ( let m1 = 0 ; m1 <= 1023 ; m1 ++ ) for ( let m2 = 0 ; m2 <= 1023 ; m2 ++ ) if ( ( m1 m2 ) == 1023 ) { ans += ( ( m1 == m2 ) ? ( cnt [ m1 ] * ( cnt [ m1 ] - 1 ) ) : ( cnt [ m1 ] * cnt [ m2 ] ) ) ; } return Math . floor ( ans / 2 ) ; }
function computeStringCount ( N ) { var n = N / 2 ; var ans = 0 ; for ( var i = 2 ; i <= n ; i += 2 ) ans = ( ans + ( ( nCr [ n ] [ i ] * nCr [ n ] [ i / 2 ] ) % mod ) ) % mod ; return ans ; }
function countSubsequence ( s , n ) { var cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( var i = 0 ; i < n ; i ++ ) { switch ( s [ i ] ) { case "G" : cntG ++ ; result += C ; break ; case "F" : cntF ++ ; C += cntG ; break ; default : continue ; } } document . write ( result ) ; }
function find ( n , k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
function LexicographicalMaxString ( str ) { let maxchar = "a" ; let index = [ ] ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] >= maxchar ) { maxchar = str [ i ] ; index . push ( i ) ; } } let maxstring = "" ; for ( let i = 0 ; i < index . length ; i ++ ) { if ( str . substring ( index [ i ] , str . length ) > maxstring ) { maxstring = str . substring ( index [ i ] , str . length ) ; } } return maxstring ; }
function isDivisible ( str , k ) { let n = str . length ; let c = 0 ; for ( let i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == "0" ) c ++ ; return ( c == k ) ; }
function longestPalin ( str ) { str = str + "▁" ; let longestword = "" , word = "" ; let length , length1 = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { let ch = str [ i ] ; if ( ch != "▁" ) word = word + ch ; else { length = word . length ; if ( checkPalin ( word ) && length > length1 ) { length1 = length ; longestword = word ; } word = "" ; } } return longestword ; }
function isCommonBase ( base , s1 , s2 ) { for ( let j = 0 ; j < s1 . length ; ++ j ) { if ( base [ j % base . length ] != s1 [ j ] ) { return false ; } } for ( let j = 0 ; j < s2 . length ; ++ j ) { if ( base [ j % base . length ] != s2 [ j ] ) { return false ; } } return true ; }
function countCommonBases ( s1 , s2 ) { let n1 = s1 . length , n2 = s2 . length ; let count = 0 ; for ( let i = 1 ; i <= Math . min ( n1 , n2 ) ; i ++ ) { let base = s1 . substring ( 0 , i ) ; if ( isCommonBase ( base , s1 , s2 ) ) { count ++ ; } } return count ; }
function isPrimeString ( str ) { let len = str . length , n = 0 ; for ( let i = 0 ; i < len ; i ++ ) { n += str [ i ] . charCodeAt ( ) ; } if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return true ; } if ( n % 2 == 0 n % 3 == 0 ) { return false ; } for ( let i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
function countPalin ( str ) { str = str + "▁" ; var word = "" ; var count = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { var ch = str [ i ] ; if ( ch != "▁" ) word = word + ch ; else { if ( checkPalin ( word ) ) count ++ ; word = "" ; } } return count ; }
function targetstring ( str1 , str2 ) { let l1 = str1 . length ; let l2 = str2 . length ; if ( l1 != l2 ) return false ; let map = new Array ( MAX ) ; for ( let i = 0 ; i < map . length ; i ++ ) { map [ i ] = 0 ; } for ( let i = 0 ; i < l1 ; i ++ ) map [ str1 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < l2 ; i ++ ) { map [ str2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] -- ; if ( map [ str2 [ i ] - "a" . charCodeAt ( 0 ) ] < 0 ) return false ; } return true ; }
function isDigitPresent ( x , d ) { while ( x > 0 ) { if ( x % 10 == d ) break ; x = x / 10 ; } return ( x > 0 ) ; }
function printNumbers ( n , d ) { for ( let i = 0 ; i <= n ; i ++ ) if ( i == d || isDigitPresent ( i , d ) ) document . write ( i + "▁" ) ; }
function printNumbers ( n , d ) { let st = "" + d ; let ch = st [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { st = "" ; st = st + i ; if ( i == d || st . indexOf ( ch ) >= 0 ) document . write ( i + "▁" ) ; } }
function findExtraCharcter ( strA , strB ) { let res = 0 ; for ( let i = 0 ; i < strA . length ; i ++ ) { res ^= strA . charCodeAt ( i ) ; } for ( let i = 0 ; i < strB . length ; i ++ ) { res ^= strB . charCodeAt ( i ) ; } return res ; }
function findExtraCharacter ( s1 , s2 ) { let smallStr ; let largeStr ; if ( s1 . length > s2 . length ) { smallStr = s2 ; largeStr = s1 ; } else { smallStr = s1 ; largeStr = s2 ; } let smallStrCodeTotal = 0 ; let largeStrCodeTotal = 0 ; let i = 0 ; for ( ; i < smallStr . length ; i ++ ) { smallStrCodeTotal += smallStr [ i ] . charCodeAt ( 0 ) ; largeStrCodeTotal += largeStr [ i ] . charCodeAt ( 0 ) ; } largeStrCodeTotal += largeStr [ i ] . charCodeAt ( 0 ) ; let intChar = largeStrCodeTotal - smallStrCodeTotal ; return String . fromCharCode ( intChar ) ; }
function fact ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
function countPalinPermutations ( str ) { let n = str . length ; let freq = new Array ( MAX ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) freq [ str [ i ] . charCodeAt ( ) ] ++ ; let res = fact ( n / 2 ) ; let oddFreq = false ; for ( let i = 0 ; i < MAX ; i ++ ) { let half = freq [ i ] / 2 ; if ( freq [ i ] % 2 != 0 ) { if ( oddFreq == true ) return 0 ; oddFreq = true ; } res = res / fact ( half ) ; } return res ; }
function minChanges ( str ) { var n = str . length ; if ( n > MAX_CHAR ) return - 1 ; var dist_count = 0 ; var count = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < MAX_CHAR ; i ++ ) count [ i ] = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( count [ str . charAt ( i ) . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] == 0 ) dist_count ++ ; count [ str . charAt ( i ) . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } return ( n - dist_count ) ; }
function printList ( head ) { while ( head != null ) { document . write ( head . c + "▁" ) ; head = head . next ; } }
function strToBinary ( s ) { let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { let val = ( s [ i ] ) . charCodeAt ( 0 ) ; let bin = "" ; while ( val > 0 ) { if ( val % 2 == 1 ) { bin += "1" ; } else bin += "0" ; val = Math . floor ( val / 2 ) ; } bin = reverse ( bin ) ; document . write ( bin + "▁" ) ; } }
function numofstring ( n , m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * Math . pow ( m - 2 , n - 2 ) ; }
function calculateSum ( arr , n ) { if ( n == 0 ) return 0 ; let s = arr [ 0 ] ; let value = parseInt ( s ) ; let sum = value ; for ( let i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = parseInt ( s ) ; let operation = arr [ i - 1 ] [ 0 ] ; if ( operation == "+" ) sum += value ; else sum -= value ; } return sum ; }
function FindMaxProduct ( arr , n ) { let max = 0 , result ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 1 ) <= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] ; if ( max < result ) max = result ; } } } return max ; }
function CountSpecialPalindrome ( str ) { var n = str . length ; var result = 0 ; var sameChar = [ ... Array ( n ) ] ; var i = 0 ; while ( i < n ) { var sameCharCount = 1 ; var j = i + 1 ; while ( str [ i ] == str [ j ] && j < n ) sameCharCount ++ , j ++ ; result += ( sameCharCount * ( sameCharCount + 1 ) ) / 2 ; sameChar [ i ] = sameCharCount ; i = j ; } for ( var j = 1 ; j < n ; j ++ ) { if ( str [ j ] == str [ j - 1 ] ) sameChar [ j ] = sameChar [ j - 1 ] ; if ( j > 0 && j < n - 1 && str [ j - 1 ] == str [ j + 1 ] && str [ j ] != str [ j - 1 ] ) result += Math . min ( sameChar [ j - 1 ] , sameChar [ j + 1 ] ) ; } return result - n ; }
function productAtKthLevel ( tree , k ) { let level = - 1 ; let product = 1 ; let n = tree . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == "(" ) level ++ ; else if ( tree [ i ] == ")" ) level -- ; else { if ( level == k ) product *= ( tree [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ) ; } } return product ; }
function isCornerPresent ( str , corner ) { var n = str . length ; var cl = corner . length ; if ( n < cl ) return false ; return ( str . substring ( 0 , cl ) . localeCompare ( corner ) === 0 && str . substring ( n - cl , n ) . localeCompare ( corner ) === 0 ) ; }
function factorial ( n ) { let f = 1 ; for ( let i = 1 ; i <= n ; i ++ ) f = f * i ; return f ; }
function calculateTotal ( temp , n ) { let f = factorial ( n ) ; let hm = new Map ( ) ; for ( let i = 0 ; i < temp . length ; i ++ ) { if ( hm . has ( temp [ i ] ) ) hm . set ( temp [ i ] , hm . get ( temp [ i ] ) + 1 ) ; else hm . set ( temp [ i ] , 1 ) ; } for ( let [ key , value ] of hm . entries ( ) ) { let x = value ; if ( x > 1 ) { let temp5 = factorial ( x ) ; f = Math . floor ( f / temp5 ) ; } } return f ; }
function nextPermutation ( temp ) { let i ; for ( i = temp . length - 1 ; i > 0 ; i -- ) if ( temp [ i ] > temp [ i - 1 ] ) break ; let min = i ; let j , x = temp [ i - 1 ] ; for ( j = i + 1 ; j < temp . length ; j ++ ) if ( ( temp [ j ] < temp [ min ] ) && ( temp [ j ] > x ) ) min = j ; let temp_to_swap ; temp_to_swap = temp [ i - 1 ] ; temp [ i - 1 ] = temp [ min ] ; temp [ min ] = temp_to_swap ; temp = temp . slice ( 0 , i ) . sort ( ) . concat ( temp . slice ( i , temp . length ) ) ; print ( temp ) ; }
function countSpecial ( str ) { var len = str . length ; if ( len == 0 ) return 0 ; var co = new Array ( len + 1 ) . fill ( 0 ) ; var vo = new Array ( len + 1 ) . fill ( 0 ) ; if ( isCons ( str [ len - 1 ] ) === true ) co [ len - 1 ] = 1 ; else vo [ len - 1 ] = 1 ; for ( var i = len - 2 ; i >= 0 ; i -- ) { if ( isCons ( str [ i ] ) === true ) { co [ i ] = co [ i + 1 ] + 1 ; vo [ i ] = vo [ i + 1 ] ; } else { co [ i ] = co [ i + 1 ] ; vo [ i ] = vo [ i + 1 ] + 1 ; } } var ans = 0 ; for ( var i = 0 ; i < len ; i ++ ) { if ( isVowel ( str [ i ] ) ) ans = ans + co [ i + 1 ] ; else ans = ans + vo [ i + 1 ] ; } return parseInt ( ans ) ; }
function findSubSequence ( s , num ) { let res = 0 ; let i = 0 ; while ( num > 0 ) { if ( ( num & 1 ) == 1 ) res += s [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ; i ++ ; num = num >> 1 ; } return res ; }
function findSubsequence ( str , k ) { var a = Array ( MAX_CHAR ) . fill ( 0 ) ; for ( var i = 0 ; i < str . length ; i ++ ) a [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < str . length ; i ++ ) if ( a [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] >= k ) document . write ( str [ i ] ) ; }
function isConvertible ( str1 , str2 , k ) { if ( ( str1 . length + str2 . length ) < k ) return true ; var commonLength = 0 ; for ( var i = 0 ; i < Math . min ( str1 . length , str2 . length ) ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) commonLength ++ ; else break ; } if ( ( k - str1 . length - str2 . length + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }
function maxLower ( str ) { let n = str . length ; let i = 0 ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= "A" && str [ i ] <= "Z" ) { i ++ ; break ; } } let maxCount = 0 ; let count = new Array ( MAX_CHAR ) ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= "A" && str [ i ] <= "Z" ) { let currCount = 0 ; for ( let j = 0 ; j < MAX_CHAR ; j ++ ) { if ( count [ j ] > 0 ) { currCount ++ ; } } maxCount = Math . max ( maxCount , currCount ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } } if ( str [ i ] >= "a" && str [ i ] <= "z" ) { count [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } } return maxCount ; }
function maxLower ( str ) { let n = str . length ; let i = 0 ; for ( ; i < n ; i ++ ) { if ( str [ i ] . charCodeAt ( 0 ) >= "A" . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= "Z" . charCodeAt ( 0 ) ) { i ++ ; break ; } } let maxCount = 0 ; let s = new Set ( ) ; for ( ; i < n ; i ++ ) { if ( str [ i ] . charCodeAt ( 0 ) >= "A" . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= "Z" . charCodeAt ( 0 ) ) { maxCount = Math . max ( maxCount , s . size ) ; s . clear ( ) ; } if ( str [ i ] . charCodeAt ( 0 ) >= "a" . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= "z" . charCodeAt ( 0 ) ) s . add ( str [ i ] ) ; } return maxCount ; }
function checkPalindrome ( str ) { let n = str . length ; let count = 0 ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; ++ i ) if ( str [ i ] != str [ n - i - 1 ] ) ++ count ; return ( count <= 1 ) ; }
function minimumflip ( mat , n ) { let flip = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
function findLUSlength ( a , b ) { let map = new Map ( ) ; let strArr = [ ] ; strArr . push ( a ) ; strArr . push ( b ) ; for ( let s = 0 ; s < strArr . length ; s ++ ) { for ( let i = 0 ; i < ( 1 << strArr [ s ] . length ) ; i ++ ) { let t = "" ; for ( let j = 0 ; j < strArr [ s ] . length ; j ++ ) { if ( ( ( i >> j ) & 1 ) != 0 ) t += strArr [ s ] [ j ] ; } if ( map . has ( t ) ) map . set ( t , map . get ( t ) + 1 ) ; else map . set ( t , 1 ) ; } } let res = 0 ; for ( let [ key , value ] of map . entries ( ) ) { if ( value == 1 ) res = Math . max ( res , key . length ) ; } return res ; }
function findLUSlength ( a , b ) { if ( a === b ) return 0 ; return Math . max ( a . length , b . length ) ; }
function convert ( str ) { var w = "" , z = "" ; str = str . toUpperCase ( ) + "▁" ; for ( i = 0 ; i < str . length ; i ++ ) { var ch = str [ i ] ; if ( ch != "▁" ) w = w + ch ; else { z = z + ( w [ 0 ] . toLowerCase ( ) ) + w . substring ( 1 ) + "▁" ; w = "" ; } } return z ; }
function first ( str ) { for ( var i = 0 ; i < str . length ; i ++ ) if ( str [ i ] === str [ i ] . toUpperCase ( ) ) return str [ i ] ; return 0 ; }
function fact ( n ) { let ans = 1 ; for ( let i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ( ans ) ; }
function evenDecimalValue ( str , n ) { var result = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i ; j < n ; j ++ ) { var decimalValue = 0 ; var powerOf2 = 1 ; for ( var k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - "0" ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }
function solve ( s ) { var l = s . length ; var x = l / 2 ; var y = l ; var p = "" ; while ( x > 0 && y > l / 2 ) { var ch = s . charAt ( x - 1 ) ; p += ch ; x -- ; ch = s . charAt ( y - 1 ) ; p += ch ; y -- ; } if ( y > l / 2 ) { var ch = s . charAt ( x - 1 ) ; p += ch ; y -- ; } document . write ( p ) ; }
function isConsonant ( ch ) { ch = ch . toUpperCase ( ) ; console . log ( ch ) ; return ( ! ( ch == "A" ch == "E" ch == "I" ch == "O" ch == "U" ) && ch . match ( /  [A-Z]  / i ) ) ; }
function totalConsonants ( str , n ) { if ( n == 1 ) return isConsonant ( str [ 0 ] ) ; return totalConsonants ( str , n - 1 ) + isConsonant ( str [ n - 1 ] ) ; }
function countSubstr ( s ) { let n = s . length ; let auxArr = new Array ( n ) ; if ( s [ 0 ] == "1" ) auxArr [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] == "1" ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } let count = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) if ( s [ i ] == "1" ) count += auxArr [ i ] ; return count ; }
function calSumUtil ( a , b , n , m ) { let sum = new Array ( n ) ; let i = n - 1 , j = m - 1 , k = n - 1 ; let carry = 0 , s = 0 ; while ( j >= 0 ) { s = a [ i ] + b [ j ] + carry ; sum [ k ] = ( s % 10 ) ; carry = Math . floor ( s / 10 ) ; k -- ; i -- ; j -- ; } while ( i >= 0 ) { s = a [ i ] + carry ; sum [ k ] = ( s % 10 ) ; carry = Math . floor ( s / 10 ) ; i -- ; k -- ; } let ans = 0 ; if ( carry ) ans = 10 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { ans += sum [ i ] ; ans *= 10 ; } return ans / 10 ; }
function calSum ( a , b , n , m ) { if ( n >= m ) return calSumUtil ( a , b , n , m ) ; else return calSumUtil ( b , a , m , n ) ; }
function longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) { let freq1 = new Array ( SIZE ) ; let freq2 = new Array ( SIZE ) ; for ( let i = 0 ; i < SIZE ; i ++ ) { freq1 [ i ] = 0 ; freq2 [ i ] = 0 ; } let len = 0 ; for ( let i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < SIZE ; i ++ ) len += Math . min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }
function isPanalphabeticWindow ( s , n ) { var ch = "a" ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch ) ch = String . fromCharCode ( ch . charCodeAt ( 0 ) + 1 ) ; if ( ch == String . fromCharCode ( "z" . charCodeAt ( 0 ) + 1 ) ) return true ; } return false ; }
function round ( n ) { let a = parseInt ( n / 10 , 10 ) * 10 ; let b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
function HalfDiagonalSums ( mat , n ) { let diag1_left = 0 , diag1_right = 0 ; let diag2_left = 0 , diag2_right = 0 ; for ( let i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( i < parseInt ( n / 2 ) ) { diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; } else if ( i > parseInt ( n / 2 ) ) { diag1_right += mat [ i ] [ i ] ; diag2_right += mat [ j ] [ i ] ; } } return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ parseInt ( n / 2 ) ] [ parseInt ( n / 2 ) ] ) ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
function prime_index ( input ) { let n = input . length ; for ( let i = 2 ; i <= n ; i ++ ) if ( isPrime ( i ) ) document . write ( input [ i - 1 ] ) ; }
function isHeterogram ( s , n ) { var hash = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] != "▁" ) { if ( hash [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] == 0 ) hash [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] = 1 ; else return false ; } } return true ; }
function ASCIISentence ( str ) { let l = str . length ; let convert ; for ( let i = 0 ; i < l ; i ++ ) { convert = str [ i ] . charCodeAt ( 0 ) ; document . write ( convert ) ; } }
function preProcess ( a , b ) { let n = a . length ; let j = 0 ; for ( let i = 1 ; i <= a . length ; i ++ ) { if ( j < b . length && a [ i - 1 ] == b [ j ] ) { j ++ ; } fwd [ i ] = j ; } j = 0 ; for ( let i = a . length ; i >= 1 ; i -- ) { if ( j < b . length && a [ i - 1 ] == b [ b . length - j - 1 ] ) { j ++ ; } bwd [ i ] = j ; } }
function findOccurrences ( str1 , substr1 ) { let counter = 0 ; for ( let i = 0 ; i < str1 . length ; i ++ ) { if ( str1 [ i ] == substr1 [ 0 ] ) { for ( let j = i + 1 ; j < str1 . length ; j ++ ) { if ( str1 [ j ] == substr1 [ 1 ] ) { for ( let k = j + 1 ; k < str1 . length ; k ++ ) { if ( str1 [ k ] == substr1 [ 2 ] ) counter ++ ; } } } } } return counter ; }
function findOccurrences ( str , substr ) { let n = str . length ; let preLeft = new Array ( n ) ; preLeft . fill ( 0 ) ; let preRight = new Array ( n ) ; preRight . fill ( 0 ) ; if ( str [ 0 ] == substr [ 0 ] ) preLeft [ 0 ] ++ ; for ( let i = 1 ; i < n ; i ++ ) { if ( str [ i ] == substr [ 0 ] ) preLeft [ i ] = preLeft [ i - 1 ] + 1 ; else preLeft [ i ] = preLeft [ i - 1 ] ; } if ( str [ n - 1 ] == substr [ 2 ] ) preRight [ n - 1 ] ++ ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( str [ i ] == substr [ 2 ] ) preRight [ i ] = preRight [ i + 1 ] + 1 ; else preRight [ i ] = preRight [ i + 1 ] ; } let counter = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ 1 ] ) { let total = preLeft [ i - 1 ] * preRight [ i + 1 ] ; counter += total ; } } return counter ; }
function canMakeStr2 ( str1 , str2 ) { let count = new Array ( MAX ) ; count . fill ( 0 ) ; for ( let i = 0 ; i < str1 . length ; i ++ ) count [ str1 [ i ] ] ++ ; for ( let i = 0 ; i < str2 . length ; i ++ ) { if ( count [ str2 [ i ] ] == 0 ) return false ; count [ str2 [ i ] ] -- ; } return true ; }
function isVowel ( c ) { return ( c == "a" c == "e" c == "i" c == "o" c == "u" ) ; }
function isVowel ( c ) { return c === "a" || c === "e" || c === "i" || c === "o" || c === "u" ; }
function finalPosition ( move ) { let l = move . length ; let countUp = 0 , countDown = 0 ; let countLeft = 0 , countRight = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( move [ i ] == "U" ) countUp ++ ; else if ( move [ i ] == "D" ) countDown ++ ; else if ( move [ i ] == "L" ) countLeft ++ ; else if ( move [ i ] == "R" ) countRight ++ ; } document . write ( "Final▁Position:▁(" + ( countRight - countLeft ) + ",▁" + ( countUp - countDown ) + ")" ) ; }
function isIdentity ( mat , N ) { for ( let row = 0 ; row < N ; row ++ ) { for ( let col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
function maxbalancedprefix ( str , n ) { var sum = 0 ; var maxi = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] == "(" ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
function countOccurrences ( str , word ) { let a = str . split ( "▁" ) ; let count = 0 ; for ( let i = 0 ; i < a . length ; i ++ ) { if ( word == ( a [ i ] ) ) count ++ ; } return count ; }
function minCost ( s ) { var alphabets = new Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < s . length ; i ++ ) { alphabets [ s [ i ] . charCodeAt ( 0 ) - 97 ] = true ; } var count = 0 ; for ( var i = 0 ; i < 26 ; i ++ ) { if ( alphabets [ i ] ) { count ++ ; } } return count ; }
function numberOfDifferentSubstrings ( s , a , b ) { let ans = 0 ; let ls = s . length ; let x = new Array ( ls ) ; let y = new Array ( ls ) ; for ( let i = 0 ; i < ls ; i ++ ) { x [ i ] = 0 ; y [ i ] = 0 ; } for ( let i = 0 ; i < ls ; i ++ ) { if ( s [ i ] == a ) x [ i ] = 1 ; if ( s [ i ] == b ) y [ i ] = 1 ; } let hash = new Set ( ) ; let curr_substr = "" ; for ( let i = 0 ; i < ls ; i ++ ) { if ( x [ i ] != 0 ) { for ( let j = i ; j < ls ; j ++ ) { if ( y [ j ] == 0 ) curr_substr += s [ i ] ; if ( y [ j ] != 0 ) { curr_substr += s [ j ] ; if ( ! hash . has ( curr_substr ) ) ans ++ ; hash . add ( curr_substr ) ; } } curr_substr = "" ; } } return ans ; }
function countWays ( n , m , k ) { if ( n == 1 m == 1 ) return 1 ; else if ( ( n + m ) % 2 == 1 && k == - 1 ) return 0 ; return ( modPower ( modPower ( 2 , n - 1 , mod ) , m - 1 , mod ) % mod ) ; }
function cost ( str ) { let len = str . length ; let res = 0 ; for ( let i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) { if ( str [ i ] != str [ j ] ) { res += Math . min ( str [ i ] . charCodeAt ( ) , str [ j ] . charCodeAt ( ) ) - "a" . charCodeAt ( ) + 1 ; } } return res ; }
function pigLatin ( s ) { let len = s . length ; let index = - 1 ; for ( let i = 0 ; i < len ; i ++ ) { if ( isVowel ( s [ i ] ) ) { index = i ; break ; } } if ( index == - 1 ) return "-1" ; return s . substring ( index ) + s . substring ( 0 , index ) + "ay" ; }
function isValidISBN ( isbn ) { let n = isbn . length ; if ( n != 10 ) return false ; let sum = 0 ; for ( let i = 0 ; i < 9 ; i ++ ) { let digit = isbn [ i ] - "0" ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } let last = isbn [ 9 ] ; if ( last != "X" && ( last < "0" last > "9" ) ) return false ; sum += ( ( last == "X" ) ? 10 : ( last - "0" ) ) ; return ( sum % 11 == 0 ) ; }
function remainder ( str ) { let len = str . length ; let num ; let rem = 0 ; for ( let i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - "0" ) ; rem = num % 11 ; } return rem ; }
function longestSubseq ( s ) { let n = s . length ; let pre_count_0 = new Array ( n + 2 ) ; let pre_count_1 = new Array ( n + 1 ) ; let post_count_0 = new Array ( n + 2 ) ; pre_count_0 [ 0 ] = 0 ; post_count_0 [ n + 1 ] = 0 ; pre_count_1 [ 0 ] = 0 ; for ( let j = 1 ; j <= n ; j ++ ) { pre_count_0 [ j ] = pre_count_0 [ j - 1 ] ; pre_count_1 [ j ] = pre_count_1 [ j - 1 ] ; post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] ; if ( s [ j - 1 ] == "0" ) pre_count_0 [ j ] ++ ; else pre_count_1 [ j ] ++ ; if ( s [ n - j ] == "0" ) post_count_0 [ n - j + 1 ] ++ ; } if ( pre_count_0 [ n ] == n pre_count_0 [ n ] == 0 ) return n ; let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = i ; j <= n ; j ++ ) ans = Math . max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) ; return ans ; }
function removeSpecialCharacter ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] < "A" s [ i ] > "Z" && s [ i ] < "a" s [ i ] > "z" ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; i -- ; } } document . write ( s ) ; }
function imageSwap ( mat , n ) { let row = 0 ; for ( let j = 0 ; j < n ; j ++ ) { let s = [ ] ; let i = row , k = j ; while ( i < n && k >= 0 ) { s . push ( mat [ i ++ ] [ k -- ] ) ; } i = row ; k = j ; while ( i < n && k >= 0 ) { mat [ i ++ ] [ k -- ] = s [ s . length - 1 ] ; s . pop ( ) ; } } let column = n - 1 ; for ( let j = 1 ; j < n ; j ++ ) { let s = [ ] ; let i = j , k = column ; while ( i < n && k >= 0 ) { s . push ( mat [ i ++ ] [ k -- ] ) ; } i = j ; k = column ; while ( i < n && k >= 0 ) { mat [ i ++ ] [ k -- ] = s [ s . length - 1 ] ; s . pop ( ) ; } } }
function shouldSwap ( str , start , curr ) { for ( let i = start ; i < curr ; i ++ ) { if ( str [ i ] == str [ curr ] ) { return false ; } } return true ; }
function decodeMedianString ( s ) { var l = s . length ; var s1 = "" ; var isEven = ( l % 2 == 0 ) ? true : false ; for ( i = 0 ; i < l ; i += 2 ) { if ( isEven ) { s1 = s . charAt ( i ) + s1 ; s1 += s . charAt ( i + 1 ) ; } else { if ( l - i > 1 ) { s1 += s . charAt ( i ) ; s1 = s . charAt ( i + 1 ) + s1 ; } else { s1 += s . charAt ( i ) ; } } } return s1 ; }
function maximumChars ( str ) { let n = str . length ; let res = - 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) res = Math . max ( res , Math . abs ( j - i - 1 ) ) ; return res ; }
function maximumChars ( str ) { let n = str . length ; let res = - 1 ; let firstInd = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { let first_ind = firstInd [ str [ i ] . charCodeAt ( 0 ) ] ; if ( first_ind == - 1 ) firstInd [ str [ i ] . charCodeAt ( 0 ) ] = i ; else res = Math . max ( res , Math . abs ( i - first_ind - 1 ) ) ; } return res ; }
function isUnique ( a , n , k ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; }
function imageSwap ( mat , n ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j <= i ; j ++ ) mat [ i ] [ j ] = mat [ i ] [ j ] + mat [ j ] [ i ] - ( mat [ j ] [ i ] = mat [ i ] [ j ] ) ; }
function isPresent ( s , q ) { let freq = new Array ( MAX_CHAR ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < s . length ; i ++ ) freq [ s [ i ] ] ++ ; for ( let i = 0 ; i < q . length ; i ++ ) { freq [ q [ i ] ] -- ; if ( freq [ q [ i ] ] < 0 ) return false ; } return true ; }
function findString ( n , k ) { let res = "" ; for ( let i = 0 ; i < k ; i ++ ) res = res + String . fromCharCode ( "a" . charCodeAt ( 0 ) + i ) ; let count = 0 ; for ( let i = 0 ; i < n - k ; i ++ ) { res = res + String . fromCharCode ( "a" . charCodeAt ( 0 ) + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }
function isValid ( p ) { var n = p . length ; var c1 = 0 , c0 = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( p [ i ] == "0" ) c0 ++ ; if ( p [ i ] == "1" ) c1 ++ ; } return ( c0 == c1 ) ? true : false ; }
function longestSub ( s ) { var max_len = 0 ; var n = s . length ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i ; j < n ; j ++ ) { if ( isValid ( s . substr ( i , j - i + 1 ) ) && max_len < j - i + 1 ) max_len = j - i + 1 ; } } return max_len ; }
function isPalindrome ( s , i , j ) { let p = j ; for ( let k = i ; k <= p ; k ++ ) { if ( s [ k ] != s [ p ] ) return false ; p -- ; } return true ; }
function countWays ( s ) { let n = s . length ; let count = 0 ; if ( isPalindrome ( s , 0 , n - 1 ) ) { for ( let i = n / 2 ; i < n ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) count ++ ; else break ; } { count ++ ; } else } else { for ( let i = 0 ; i < n / 2 ; i ++ ) { if ( s [ i ] != s [ n - 1 - i ] ) { let j = n - 1 - i ; if ( isPalindrome ( s , i , n - 2 - i ) ) { for ( let k = i - 1 ; k >= 0 ; k -- ) { if ( s [ k ] != s [ j ] ) break ; count ++ ; } count ++ ; } if ( isPalindrome ( s , i + 1 , n - 1 - i ) ) { for ( let k = n - i ; k < n ; k ++ ) { if ( s [ k ] != s [ i ] ) break ; count ++ ; } count ++ ; } break ; } } } return count ; }
function makeAndCheckString ( words , str ) { let n = words . length ; let first = false , second = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( words [ i ] == str ) return true ; if ( str [ 0 ] == words [ i ] [ 1 ] ) first = true ; if ( str [ 1 ] == words [ i ] [ 0 ] ) second = true ; if ( first && second ) return true ; } return false ; }
function countOfSubstringWithKOnes ( s , K ) { let N = s . length ; let res = 0 ; let countOfOne = 0 ; let freq = new Array ( N + 1 ) ; freq . fill ( 0 ) ; freq [ 0 ] = 1 ; for ( let i = 0 ; i < N ; i ++ ) { countOfOne += ( s [ i ] - "0" ) ; if ( countOfOne >= K ) { res += freq [ countOfOne - K ] ; } freq [ countOfOne ] ++ ; } return res ; }
function printRec ( number , extraOnes , remainingPlaces ) { if ( 0 == remainingPlaces ) { document . write ( number + "▁" ) ; return ; } printRec ( number + "1" , extraOnes + 1 , remainingPlaces - 1 ) ; if ( 0 < extraOnes ) printRec ( number + "0" , extraOnes - 1 , remainingPlaces - 1 ) ; }
function printNums ( n ) { let str = "" ; printRec ( str , 0 , n ) ; }
function getBinaryRep ( N , num_of_bits ) { let r = "" ; num_of_bits -- ; while ( num_of_bits >= 0 ) { if ( ( N & ( 1 << num_of_bits ) ) != 0 ) r += "1" ; else r += "0" ; num_of_bits -- ; } return r ; }
function NBitBinary ( N ) { let r = [ ] ; let first = 1 << ( N - 1 ) ; let last = first * 2 ; for ( let i = last - 1 ; i >= first ; -- i ) { let zero_cnt = 0 ; let one_cnt = 0 ; let t = i ; let num_of_bits = 0 ; while ( t > 0 ) { if ( ( t & 1 ) != 0 ) one_cnt ++ ; else zero_cnt ++ ; num_of_bits ++ ; t = t >> 1 ; } if ( one_cnt >= zero_cnt ) { let all_prefix_match = true ; let msk = ( 1 << num_of_bits ) - 2 ; let prefix_shift = 1 ; while ( msk > 0 ) { let prefix = ( msk & i ) >> prefix_shift ; let prefix_one_cnt = 0 ; let prefix_zero_cnt = 0 ; while ( prefix > 0 ) { if ( ( prefix & 1 ) != 0 ) prefix_one_cnt ++ ; else prefix_zero_cnt ++ ; prefix = prefix >> 1 ; } if ( prefix_zero_cnt > prefix_one_cnt ) { all_prefix_match = false ; break ; } prefix_shift ++ ; msk = msk & ( msk << 1 ) ; } if ( all_prefix_match ) { r . push ( getBinaryRep ( i , num_of_bits ) ) ; } } } return r ; }
function isPossible ( s1 , s2 ) { let count = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } for ( let i = 0 ; i < s2 . length ; i ++ ) count [ s2 [ i ] . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < s1 . length ; i ++ ) { if ( count [ s1 [ i ] . charCodeAt ( 0 ) ] == 0 ) return false ; count [ s1 [ i ] . charCodeAt ( 0 ) ] -- ; } return true ; }
function checkLuhn ( cardNo ) { let nDigits = cardNo . length ; let nSum = 0 ; let isSecond = false ; for ( let i = nDigits - 1 ; i >= 0 ; i -- ) { let d = cardNo [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ; if ( isSecond == true ) d = d * 2 ; nSum += parseInt ( d / 10 , 10 ) ; nSum += d % 10 ; isSecond = ! isSecond ; } return ( nSum % 10 == 0 ) ; }
function isVowel ( ch ) { if ( ch == "a" ch == "e" ch == "i" ch == "o" ch == "u" ) { return true ; } return false ; }
function findRepeatFirstN2 ( s ) { let p = - 1 , i , j ; for ( i = 0 ; i < s . length ; i ++ ) { for ( j = i + 1 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }
function isVowel ( c ) { return ( c == "a" c == "e" c == "i" c == "o" c == "u" ) ; }
function isVowel ( x ) { return ( x == "a" x == "e" x == "i" x == "o" x == "u" ) ; }
function isVowel ( x ) { return ( x == "a" x == "e" x == "i" x == "o" x == "u" ) ; }
function substrings ( s , k ) { let res = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { let freq = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } for ( let j = i ; j < s . length ; j ++ ) { let index = s [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ; freq [ index ] ++ ; if ( freq [ index ] > k ) break ; else if ( freq [ index ] == k && check ( freq , k ) == true ) res ++ ; } } return res ; }
function longestSubseqWithK ( str , k ) { let n = str . length ; let freq = new Array ( MAX_CHARS ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 } for ( let i = 0 ; i < n ; i ++ ) { freq [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] >= k ) { document . write ( str [ i ] ) ; } } }
function canFormPalindrome ( str ) { let count = new Array ( NO_OF_CHARS ) ; count . fill ( 0 ) ; for ( let i = 0 ; i < str . length ; i ++ ) count [ str [ i ] . charCodeAt ( ) ] ++ ; let odd = 0 ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) != 0 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; }
function generate ( st , s ) { if ( s . length == 0 ) return st ; if ( ! st . has ( s ) ) { st . add ( s ) ; for ( let i = 0 ; i < s . length ; i ++ ) { let t = s ; t = t . substr ( 0 , i ) + t . substr ( i + 1 ) ; st = generate ( st , t ) ; } } return st ; }
function countSubstrs ( str , i , j , n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; let res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str [ i ] == str [ j ] ) res ++ ; return res ; }
function countManipulations ( s1 , s2 ) { let count = 0 ; let char_count = new Array ( 26 ) ; for ( let i = 0 ; i < char_count . length ; i ++ ) { char_count [ i ] = 0 ; } for ( let i = 0 ; i < s1 . length ; i ++ ) char_count [ s1 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < s2 . length ; i ++ ) { char_count [ s2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] -- ; } for ( let i = 0 ; i < 26 ; ++ i ) { if ( char_count [ i ] != 0 ) { count += Math . abs ( char_count [ i ] ) ; } } return count ; }
function stringPalindrome ( A , B ) { var countA = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; var countB = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; var l1 = A . length ; var l2 = B . length ; for ( var i = 0 ; i < l1 ; i ++ ) countA [ A . charAt ( i ) . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < l2 ; i ++ ) countB [ B . charAt ( i ) . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return "A" ; return "B" ; }
function check ( list , s ) { let n = list . length ; if ( n == 0 ) { return false ; } for ( let i = 0 ; i < n ; i ++ ) { if ( list [ i ] . length != s . length ) { continue ; } let diff = false ; for ( let j = 0 ; j < list [ i ] . length ; j ++ ) { if ( list [ i ] [ j ] != s [ j ] ) { if ( ! diff ) { diff = true ; } else { diff = false ; break ; } } } if ( diff ) { return true ; } } return false ; }
function FirstRepeated ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; ++ i ) { let val = ( str [ i ] - "a" ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
function search ( mat , n , x ) { let i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { document . write ( "n▁Found▁at▁" + i + ",▁" + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } document . write ( "n▁Element▁not▁found" ) ; return ; }
function nPermute ( str , n ) { precomputeFactorirals ( ) ; let len = str . length ; let freq = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < len ; i ++ ) freq [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; let out = "a" ; let sum = 10 ; let k = 0 ; while ( sum >= n ) { for ( let i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] == 0 ) continue ; freq [ i ] -- ; sum = 0 ; let xsum = fact [ len - 1 - k ] ; for ( let j = 0 ; j < MAX_CHAR ; j ++ ) xsum = Math . floor ( xsum / fact [ freq [ j ] ] ) ; sum += xsum ; if ( sum >= n ) { out += String . fromCharCode ( i + "a" . charCodeAt ( 0 ) ) ; k ++ ; n -= ( sum - xsum ) ; break ; } if ( sum < n ) freq [ i ] ++ ; } } for ( let i = MAX_CHAR - 1 ; k < len && i >= 0 ; i -- ) if ( freq [ i ] != 0 ) { out += String . fromCharCode ( i + "a" . charCodeAt ( 0 ) ) ; freq [ i ++ ] -- ; } document . write ( out ) ; }
function sentencePalindrome ( str ) { let l = 0 ; let h = str . length - 1 ; str = str . toLowerCase ( ) ; while ( l <= h ) { let getAtl = str [ l ] ; let getAth = str [ h ] ; if ( ! ( getAtl >= "a" && getAtl <= "z" ) ) l ++ ; else if ( ! ( getAth >= "a" && getAth <= "z" ) ) h -- ; else if ( getAtl == getAth ) { l ++ ; h -- ; } else return false ; } return true ; }
function substringConversions ( str , k , b ) { for ( let i = 0 ; i + k <= str . length ; i ++ ) { let sub = str . substring ( i , i + k ) ; let sum = 0 , counter = 0 ; for ( let j = sub . length - 1 ; j >= 0 ; j -- ) { sum = ( sum + ( ( sub [ j ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) * Math . pow ( b , counter ) ) ) ; counter ++ ; } document . write ( sum + "▁" ) ; } }
function countBalance ( str ) { var leftVisited = Array ( MAX_CHAR ) . fill ( 0 ) ; var rightVisited = Array ( MAX_CHAR ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) rightVisited [ str [ i ] . charCodeAt ( 0 ) ] ++ ; var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) { leftVisited [ str [ i ] . charCodeAt ( 0 ) ] ++ ; rightVisited [ str [ i ] . charCodeAt ( 0 ) ] -- ; var j ; for ( j = 0 ; j < MAX_CHAR ; j ++ ) { if ( ( leftVisited [ j ] == 0 && rightVisited [ j ] != 0 ) || ( leftVisited [ j ] != 0 && rightVisited [ j ] == 0 ) ) break ; } if ( j == MAX_CHAR ) res ++ ; } return res ; }
function countWords ( str , n ) { var m = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( m . has ( str [ i ] ) ) m . set ( str [ i ] , m . get ( str [ i ] ) + 1 ) else m . set ( str [ i ] , 1 ) } var res = 0 ; m . forEach ( ( value , key ) => { if ( ( value == 2 ) ) res ++ ; } ) ; return res ; }
function findFlips ( str , n ) { var last = "▁" ; var res = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( last != str . charAt ( i ) ) res ++ ; last = str . charAt ( i ) ; } return parseInt ( res / 2 ) ; }
function findLen ( A , n , k , ch ) { let maxlen = 1 ; let cnt = 0 ; let l = 0 , r = 0 ; while ( r < n ) { if ( A [ r ] != ch ) ++ cnt ; while ( cnt > k ) { if ( A [ l ] != ch ) -- cnt ; ++ l ; } maxlen = Math . max ( maxlen , r - l + 1 ) ; ++ r ; } return maxlen ; }
function answer ( A , n , k ) { let maxlen = 1 ; for ( let i = 0 ; i < 26 ; ++ i ) { maxlen = Math . max ( maxlen , findLen ( A , n , k , String . fromCharCode ( i + "A" . charCodeAt ( 0 ) ) ) ) ; maxlen = Math . max ( maxlen , findLen ( A , n , k , String . fromCharCode ( i + "a" . charCodeAt ( 0 ) ) ) ) ; } return maxlen ; }
function printString ( str , ch , count ) { var occ = 0 , i ; if ( count == 0 ) { document . write ( str ) ; return ; } for ( i = 0 ; i < str . length ; i ++ ) { if ( str . charAt ( i ) == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . length - 1 ) document . write ( str . substring ( i + 1 ) ) ; else document . write ( "Empty▁string" ) ; }
function checkCorrectOrNot ( s ) { let count1 = new Array ( MAX_CHAR ) ; let count2 = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) { count1 [ i ] = 0 ; count2 [ i ] = 0 ; } let n = s . length ; if ( n == 1 ) return true ; for ( let i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count1 [ s [ i ] - "a" ] ++ ; count2 [ s [ j ] - "a" ] ++ ; } for ( let i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; }
function checkCorrectOrNot ( s ) { let count = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } let n = s . length ; if ( n == 1 ) return true ; for ( let i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s [ i ] - "a" ] ++ ; count [ s [ j ] - "a" ] -- ; } for ( let i = 0 ; i < MAX_CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; }
function possibleStrings ( n , r , b , g ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; let left = n - ( r + g + b ) ; let sum = 0 ; for ( let i = 0 ; i <= left ; i ++ ) { for ( let j = 0 ; j <= left - i ; j ++ ) { let k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
function checkString ( s ) { let len = s . length ; let first = 0 ; for ( let i = 0 ; i < len ; i ++ ) { if ( s [ i ] == "1" ) { first = i ; break ; } } let last = 0 ; for ( let i = len - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == "1" ) { last = i ; break ; } } for ( let i = first ; i <= last ; i ++ ) if ( s [ i ] == "0" ) return false ; return true ; }
function isVowel ( c ) { return ( c == "a" c == "A" c == "e" c == "E" c == "i" c == "I" c == "o" c == "O" c == "u" c == "U" ) ; }
function isUnique ( mat , i , j , n , m ) { let sumrow = 0 ; for ( let k = 0 ; k < m ; k ++ ) { sumrow += mat [ i ] [ k ] ; if ( sumrow > 1 ) return false ; } let sumcol = 0 ; for ( let k = 0 ; k < n ; k ++ ) { sumcol += mat [ k ] [ j ] ; if ( sumcol > 1 ) return false ; } return true ; }
function findAndPrintUncommonChars ( str1 , str2 ) { var present = Array ( MAX_CHAR ) ; for ( var i = 0 ; i < MAX_CHAR ; i ++ ) present [ i ] = 0 ; var l1 = str1 . length ; var l2 = str2 . length ; for ( var i = 0 ; i < l1 ; i ++ ) present [ str1 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] = 1 ; for ( var i = 0 ; i < l2 ; i ++ ) { if ( present [ str2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] == 1 || present [ str2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] == - 1 ) present [ str2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] = - 1 ; else present [ str2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] = 2 ; } for ( var i = 0 ; i < MAX_CHAR ; i ++ ) if ( present [ i ] == 1 present [ i ] == 2 ) document . write ( ( String . fromCharCode ( i + "a" . charCodeAt ( 0 ) ) ) + "▁" ) ; }
function countUnique ( mat , n , m ) { let rowsum = new Array ( n ) ; rowsum . fill ( 0 ) ; let colsum = new Array ( m ) ; colsum . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } let uniquecount = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }
function lengthOfLastWord ( a ) { let len = 0 ; x = a . trim ( ) ; for ( let i = 0 ; i < x . length ; i ++ ) { if ( x [ i ] == "▁" ) { len = 0 ; } else { len ++ ; } } return len ; }
function isVowel ( ch ) { ch = ch . toUpperCase ( ) ; return ch == "A" || ch == "E" || ch == "I" || ch == "O" || ch == "U" ; }
function countVowels ( str ) { var count = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) if ( isVowel ( str [ i ] ) ) ++ count ; return count ; }
function factorial ( n ) { let fact = 1 ; for ( let i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
function countDistinctPermutations ( str ) { let length = str . length ; let freq = new Array ( MAX_CHAR ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < length ; i ++ ) if ( str [ i ] . charCodeAt ( ) >= "a" . charCodeAt ( ) ) freq [ str [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ++ ; let fact = 1 ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) fact = fact * factorial ( freq [ i ] ) ; return parseInt ( factorial ( length ) / fact , 10 ) ; }
function uniqueCharacters ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { let bitAtIndex = str [ i ] - "a" ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } return true ; }
function solve ( i , X , Y , a , b , n ) { if ( i == n ) return 0 ; if ( X <= 0 ) return b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ; if ( Y <= 0 ) return a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) ; else return Math . max ( a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) , b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ) ; }
function smallest_alphabet ( a , n ) { let min = "z" ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] . charCodeAt ( ) < min . charCodeAt ( ) ) min = a [ i ] ; return min ; }
function isPalindrome ( str ) { let n = str . length ; for ( let i = 0 ; i < n / 2 ; i ++ ) { if ( str [ i ] != str [ n - i - 1 ] ) return false ; } return true ; }
function moveSpaceInFront ( str ) { let i = str . length - 1 ; for ( let j = i ; j >= 0 ; j -- ) if ( str [ j ] != "▁" ) { let c = str [ i ] ; str [ i ] = str [ j ] ; str [ j ] = c ; i -- ; } }
function countCommon ( mat , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
function moveSpaceInFront ( str ) { var i = str . length - 1 ; for ( var j = i ; j >= 0 ; j -- ) if ( str [ j ] !== "▁" ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = "▁" ; }
function titleToNumber ( s ) { let result = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { result *= 26 ; result += s [ i ] . charCodeAt ( 0 ) - "A" . charCodeAt ( 0 ) + 1 ; } return result ; }
function isKthBitSet ( n , k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) document . write ( "SET" ) ; else document . write ( "NOT▁SET" ) ; }
function isKthBitSet ( n , k ) { if ( ( ( n >> ( k - 1 ) ) & 1 ) > 0 ) document . write ( "SET" ) ; else document . write ( "NOT▁SET" ) ; }
function isPalindrome ( str ) { var n = str . length ; if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; }
function areSumSame ( a , n , m ) { let sum1 = 0 , sum2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( let j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }
function getIdx ( ch ) { return ( ch - "a" ) ; }
function allSame ( freq , N ) { let same = 0 ; let i ; for ( i = 0 ; i < N ; i ++ ) { if ( freq [ i ] > 0 ) { same = freq [ i ] ; break ; } } for ( let j = i + 1 ; j < N ; j ++ ) if ( freq [ j ] > 0 && freq [ j ] != same ) return false ; return true ; }
function possibleSameCharFreqByOneRemoval ( str ) { let l = str . length ; let freq = new Array ( M ) ; for ( let i = 0 ; i < M ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < l ; i ++ ) freq [ getIdx ( str [ i ] ) ] ++ ; if ( allSame ( freq , M ) ) return true ; for ( let c = "a" ; c <= "z" ; c ++ ) { let i = getIdx ( c ) ; if ( freq [ i ] > 0 ) { freq [ i ] -- ; if ( allSame ( freq , M ) ) return true ; freq [ i ] ++ ; } } return false ; }
function findIndex ( str ) { let len = str . length ; let open = new Array ( len + 1 ) ; let close = new Array ( len + 1 ) ; for ( let i = 0 ; i < len + 1 ; i ++ ) { open [ i ] = 0 ; close [ i ] = 0 ; } let index = - 1 ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str [ 0 ] == "(" ) open [ 1 ] = 1 ; if ( str [ len - 1 ] == ")" ) close [ len - 1 ] = 1 ; for ( let i = 1 ; i < len ; i ++ ) { if ( str [ i ] == "(" ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; } for ( let i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] == ")" ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; } if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ; for ( let i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; }
function checkEquality ( s ) { return ( s . charAt ( 0 ) == s . charAt ( s . length - 1 ) ) ; }
function countSubstringWithEqualEnds ( s ) { var result = 0 ; var n = s . length ; var count = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; i ++ ) count [ s . charAt ( i ) . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
function getValue ( str , i , m ) { if ( i + m > str . length ) { return - 1 ; } let value = 0 ; for ( let j = 0 ; j < m ; j ++ ) { let c = str [ i + j ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ; if ( c < 0 c > 9 ) { return - 1 ; } value = value * 10 + c ; } return value ; }
function findMissingNumber ( str ) { for ( let m = 1 ; m <= MAX_DIGITS ; ++ m ) { let n = getValue ( str , 0 , m ) ; if ( n == - 1 ) { break ; } let missingNo = - 1 ; let fail = false ; for ( let i = m ; i != str . length ; i += 1 + Math . floor ( Math . log10 ( n ) ) ) { if ( ( missingNo == - 1 ) && ( getValue ( str , i , Math . floor ( 1 + Math . log10 ( n + 2 ) ) ) == n + 2 ) ) { missingNo = n + 1 ; n += 2 ; } else if ( getValue ( str , i , Math . floor ( 1 + Math . log10 ( n + 1 ) ) ) == n + 1 ) { n ++ ; } else { fail = true ; break ; } } if ( ! fail ) { return missingNo ; } } return - 1 ; }
function isSmaller ( str1 , str2 ) { let n1 = str1 . length , n2 = str2 . length ; if ( n1 < n2 ) return true ; if ( n2 < n1 ) return false ; for ( let i = 0 ; i < n1 ; i ++ ) { if ( str1 [ i ] . charCodeAt ( ) < str2 [ i ] . charCodeAt ( ) ) return true ; else if ( str1 [ i ] . charCodeAt ( ) > str2 [ i ] . charCodeAt ( ) ) return false ; } return false ; }
function maxRepeating ( str ) { let len = str . length ; let count = 0 ; let res = str [ 0 ] ; for ( let i = 0 ; i < len ; i ++ ) { let cur_count = 1 ; for ( let j = i + 1 ; j < len ; j ++ ) { if ( str [ i ] != str [ j ] ) break ; cur_count ++ ; } if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } } return res ; }
function isSymmetric ( mat , N ) { let tr = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { tr [ i ] = new Array ( MAX ) ; } transpose ( mat , tr , N ) ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != tr [ i ] [ j ] ) return false ; return true ; }
function maxRepeating ( str ) { var n = str . length ; var count = 0 ; var res = str [ 0 ] ; var cur_count = 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; }
function check ( str ) { let n = str . length ; let oddDigSum = 0 , evenDigSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - "0" ) ; else evenDigSum += ( str [ i ] - "0" ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
function isSubSequence ( str1 , str2 ) { var m = str1 . length , n = str2 . length ; for ( var i = 0 ; i < n && j < m ; i ++ ) if ( str1 [ j ] == str2 [ i ] ) j ++ ; return ( j == m ) ; }
function isSymmetric ( mat , N ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
function countWords ( str , len ) { let count = 1 ; if ( len == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ; for ( let j = 1 ; j < len - 1 ; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ; else if ( str [ j ] == str [ j - 1 ] str [ j ] == str [ j + 1 ] str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ; else count *= 3 ; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; }
function hammingDist ( str1 , str2 ) { let i = 0 , count = 0 ; while ( i < str1 . length ) { if ( str1 [ i ] != str2 [ i ] ) count ++ ; i ++ ; } return count ; }
function replaceDig ( x , from , to ) { var result = 0 ; var multiply = 1 ; while ( x > 0 ) { var reminder = x % 10 ; if ( reminder == from ) result = result + to * multiply ; else result = result + reminder * multiply ; multiply *= 10 ; x = parseInt ( x / 10 ) ; } return result ; }
function calculateMinMaxSum ( x1 , x2 ) { var minSum = replaceDig ( x1 , 6 , 5 ) + replaceDig ( x2 , 6 , 5 ) ; var maxSum = replaceDig ( x1 , 5 , 6 ) + replaceDig ( x2 , 5 , 6 ) ; document . write ( "Minimum▁sum▁=▁" + minSum ) ; document . write ( "nMaximum▁sum▁=▁" + maxSum ) ; }
function qType2 ( l , r , str1 ) { let freq = new Array ( 27 ) ; for ( let i = 0 ; i < 27 ; i ++ ) { freq [ i ] = 0 ; } for ( let i = l - 1 ; i <= r - 1 ; i ++ ) { freq [ str1 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } let count = 0 ; for ( let j = 0 ; j < 26 ; j ++ ) { if ( freq [ j ] % 2 != 0 ) { count ++ ; } } if ( count <= 1 ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function update ( tree , idx , val , i ) { while ( idx <= max ) { tree [ idx ] [ i ] += val ; idx += ( idx & - idx ) ; } }
function buildBIT ( tree , str , n ) { for ( let i = 0 ; i < n ; i ++ ) update ( tree , i + 1 , 1 , str [ i ] . charCodeAt ( 0 ) - 97 + 1 ) ; }
function precompute ( mat , str , len ) { for ( let i = 0 ; i < CHAR_SIZE ; ++ i ) mat [ len ] [ i ] = len ; for ( let i = len - 1 ; i >= 0 ; -- i ) { for ( let j = 0 ; j < CHAR_SIZE ; ++ j ) mat [ i ] [ j ] = mat [ i + 1 ] [ j ] ; mat [ i ] [ str [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] = i ; } }
function query ( mat , str , len ) { let pos = 0 ; for ( let i = 0 ; i < str . length ; ++ i ) { if ( mat [ pos ] [ str [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] >= len ) return false ; else pos = mat [ pos ] [ str [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] + 1 ; } return true ; }
function findTwoscomplement ( str ) { var n = str . length ; var i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == "1" ) break ; if ( i == - 1 ) return "1" + str ; for ( k = i - 1 ; k >= 0 ; k -- ) { if ( str . charAt ( k ) == "1" ) str = str . substring ( 0 , k ) + "0" + str . substring ( k + 1 , str . length ) ; else str = str . substring ( 0 , k ) + "1" + str . substring ( k + 1 , str . length ) ; } return str . toString ( ) ; }
function isequal ( str ) { let n = str . length ; let num = 0 , x = 1 , i = n - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( "0" <= str [ i ] && str [ i ] <= "9" ) { num = ( str [ i ] - "0" ) * x + num ; x = x * 10 ; if ( num >= n ) return false ; } else break ; } return num == i + 1 ; }
function arekAnagrams ( str1 , str2 , k ) { let n = str1 . length ; if ( str2 . length != n ) return false ; let count1 = new Array ( MAX_CHAR ) ; let count2 = new Array ( MAX_CHAR ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) count1 [ str1 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n ; i ++ ) count2 [ str2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }
function areKAnagrams ( str1 , str2 , k ) { let n = str1 . length ; if ( str2 . length != n ) return false ; let hash_str1 = Array ( MAX_CHAR ) ; hash_str1 . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) hash_str1 [ str1 [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ++ ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ str2 [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] > 0 ) hash_str1 [ str2 [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] -- ; else count ++ ; if ( count > k ) return false ; } return true ; }
function countToMake0lternate ( s ) { let result = 0 ; for ( let i = 0 ; i < ( s . length - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }
function getDigit ( N , d ) { let str = N . toString ( ) ; return str [ d - 1 ] ; }
function getNthChar ( N ) { let sum = 0 , nine = 9 ; let dist = 0 , len ; for ( len = 1 ; ; len ++ ) { sum += nine * len ; dist += nine ; if ( sum >= N ) { sum -= nine * len ; dist -= nine ; N -= sum ; break ; } nine *= 10 ; } let diff = ( Math . ceil ( ( N ) / ( len ) ) ) ; let d = N % len ; if ( d == 0 ) d = len ; return getDigit ( dist + diff , d ) ; }
function ispalindrome ( s ) { let l = s . length ; let j ; for ( let i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s [ i ] != s [ j ] ) return false ; } return true ; }
function findCount ( $str ) { $result = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) if ( i === str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) || i === str [ i ] . charCodeAt ( 0 ) - "A" . charCodeAt ( 0 ) ) result ++ ; return result ; }
function sortByPattern ( str , pat ) { let count = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) { count [ i ] = 0 ; } for ( let i = 0 ; i < str . length ; i ++ ) { count [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } let index = 0 ; for ( let i = 0 ; i < pat . length ; i ++ ) { for ( let j = 0 ; j < count [ pat [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ; j ++ ) { str [ index ++ ] = pat [ i ] ; } } }
function flip ( ch ) { return ( ch == "0" ) ? "1" : "0" ; }
function getFlipWithStartingCharcter ( str , expected ) { let flipCount = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str . charAt ( i ) != expected ) flipCount ++ ; expected = flip ( expected ) ; } return flipCount ; }
function minFlipToMakeStringAlternate ( str ) { return Math . min ( getFlipWithStartingCharcter ( str , "0" ) , getFlipWithStartingCharcter ( str , "1" ) ) ; }
function remAnagram ( str1 , str2 ) { var count1 = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; var count2 = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < str1 . length ; i ++ ) count1 [ str1 . charAt ( i ) . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( i = 0 ; i < str2 . length ; i ++ ) count2 [ str2 . charAt ( i ) . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; var result = 0 ; for ( i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }
function isPalin ( str ) { let len = str . length / 2 ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] != str [ str . length - i - 1 ] ) return false ; } return true ; }
function remainderWith7 ( num ) { series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ]  var series_index = 0 ; for ( var i = num . length - 1 ; i >= 0 ; i -- ) { var digit = num [ i ] - "0" ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; }
function checkForVariation ( str ) { if ( str == null str . length == 0 ) { return true ; } let map = new Map ( ) ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( ! map . has ( str [ i ] ) ) map . set ( str [ i ] , 0 ) ; map . set ( str [ i ] , map . get ( str [ i ] ) + 1 ) ; } let first = true , second = true ; let val1 = 0 , val2 = 0 ; let countOfVal1 = 0 , countOfVal2 = 0 ; for ( let [ key , value ] of map . entries ( ) ) { let i = value ; if ( first ) { val1 = i ; first = false ; countOfVal1 ++ ; continue ; } if ( i == val1 ) { countOfVal1 ++ ; continue ; } if ( second ) { val2 = i ; countOfVal2 ++ ; second = false ; continue ; } if ( i == val2 ) { countOfVal2 ++ ; continue ; } return false ; } if ( countOfVal1 > 1 && countOfVal2 > 1 ) { return false ; } else { return true ; } }
function waysToPaint ( n ) { var same = 6 ; var diff = 6 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { var sameTmp = 3 * same + 2 * diff ; var diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } document . write ( same + diff ) ; }
function isReversible ( str ) { var i = 0 , j = str . length - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
function findPossibleMoves ( mat , p , q ) { let X = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] ; let Y = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] ; let count = 0 ; for ( let i = 0 ; i < 8 ; i ++ ) { let x = p + X [ i ] ; let y = q + Y [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++ ; } return count ; }
function countCompletePairs ( set1 , set2 , n , m ) { let result = 0 ; let con_s1 = new Array ( n ) ; let con_s2 = new Array ( m ) ; for ( let i = 0 ; i < n ; i ++ ) { con_s1 [ i ] = 0 ; for ( let j = 0 ; j < set1 [ i ] . length ; j ++ ) { con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( set1 [ i ] [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ) ) ; } } for ( let i = 0 ; i < m ; i ++ ) { con_s2 [ i ] = 0 ; for ( let j = 0 ; j < set2 [ i ] . length ; j ++ ) { con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( set2 [ i ] [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ) ) ; } } let complete = ( 1 << 26 ) - 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) { result ++ ; } } } return result ; }
function checkPattern ( str , pat ) { let label = new Array ( CHAR_SIZE ) ; for ( let i = 0 ; i < CHAR_SIZE ; i ++ ) label [ i ] = - 1 ; let order = 1 ; for ( let i = 0 ; i < pat . length ; i ++ ) { label [ pat [ i ] . charCodeAt ( 0 ) ] = order ; order ++ ; } let last_order = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( label [ str [ i ] . charCodeAt ( 0 ) ] != - 1 ) { if ( label [ str [ i ] . charCodeAt ( 0 ) ] < last_order ) return false ; last_order = label [ str [ i ] . charCodeAt ( 0 ) ] ; } } return true ; }
function encodedChar ( str , k ) { let expand = "" ; for ( let i = 0 ; i < str . length ; ) { while ( i < str . length && str [ i ] . charCodeAt ( 0 ) >= "a" . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= "z" . charCodeAt ( 0 ) ) { temp += str [ i ] ; i ++ ; } while ( i < str . length && str [ i ] . charCodeAt ( 0 ) >= "1" . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= "9" . charCodeAt ( 0 ) ) { freq = freq * 10 + str [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ; i ++ ; } for ( let j = 1 ; j <= freq ; j ++ ) expand += temp ; } if ( freq == 0 ) expand += temp ; return expand [ k - 1 ] ; }
function findMatchedWords ( dict , pattern ) { let len = pattern . length ; let hash = encodeString ( pattern ) ; for ( let word = 0 ; word < dict . length ; word ++ ) { if ( dict [ word ] . length == len && encodeString ( dict [ word ] ) == ( hash ) ) document . write ( dict [ word ] + "▁" ) ; } }
function check ( pattern , word ) { if ( pattern . length != word . length ) return false ; let ch = new Array ( 128 ) ; for ( let i = 0 ; i < 128 ; i ++ ) { ch [ i ] = 0 ; } let Len = word . length ; for ( let i = 0 ; i < Len ; i ++ ) { if ( ch [ pattern [ i ] . charCodeAt ( 0 ) ] == 0 ) { ch [ pattern [ i ] . charCodeAt ( 0 ) ] = word [ i ] ; } else if ( ch [ pattern [ i ] . charCodeAt ( 0 ) ] != word [ i ] ) { return false ; } } return true ; }
function findSum ( str ) { let temp = "0" ; let sum = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { let ch = str [ i ] ; if ( ! isNaN ( String ( ch ) * 1 ) ) temp += ch ; else { sum += parseInt ( temp ) ; temp = "0" ; } } return sum + parseInt ( temp ) ; }
function countkDist ( str , k ) { var res = 0 ; var n = str . length ; var cnt = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < n ; i ++ ) { var dist_count = 0 ; for ( j = i ; j < n ; j ++ ) { if ( cnt [ str . charAt ( j ) . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] == 0 ) dist_count ++ ; cnt [ str . charAt ( j ) . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; }
function commonPrefixUtil ( str1 , str2 ) { let result = "" ; let n1 = str1 . length , n2 = str2 . length ; for ( let i = 0 , j = 0 ; i <= n1 - 1 && j <= n2 - 1 ; i ++ , j ++ ) { if ( str1 [ i ] != str2 [ j ] ) { break ; } result += str1 [ i ] ; } return ( result ) ; }
function commonPrefix ( arr , low , high ) { if ( low == high ) { return ( arr [ low ] ) ; } if ( high > low ) { let mid = low + Math . floor ( ( high - low ) / 2 ) ; let str1 = commonPrefix ( arr , low , mid ) ; let str2 = commonPrefix ( arr , mid + 1 , high ) ; return ( commonPrefixUtil ( str1 , str2 ) ) ; } return null ; }
function countTriplets ( A ) { var cnt = 0 ; var tuples = new Map ( ) ; A . forEach ( a => { A . forEach ( b => { if ( tuples . has ( a & b ) ) tuples . set ( a & b , tuples . get ( a & b ) + 1 ) else tuples . set ( a & b , 1 ) } ) ; } ) ; A . forEach ( a => { tuples . forEach ( ( value , key ) => { if ( ( key & a ) == 0 ) cnt += value ; } ) ; } ) ; return cnt ; }
function isPalindrome ( str ) { let l = 0 ; let h = str . length - 1 ; while ( h > l ) if ( str [ l ++ ] != str [ h -- ] ) return false ; return true ; }
function flip ( c ) { return ( c == "0" ) ? "1" : "0" ; }
function zigZagConcat ( s , n ) { if ( n <= 1 ) { return s ; } let result = [ ] ; for ( let rowNum = 0 ; rowNum < n ; rowNum ++ ) { let i = rowNum ; let up = true ; while ( i < s . length ) { result . push ( s [ i ] ) ; if ( rowNum == 0 rowNum == n - 1 ) { i += ( 2 * n - 2 ) ; } else { if ( up ) { i += ( 2 * ( n - rowNum ) - 2 ) ; } else { i += rowNum * 2 ; } up ^= true ; } } } return result . join ( "" ) ; }
function isEditDistanceOne ( s1 , s2 ) { let m = s1 . length , n = s2 . length ; if ( Math . abs ( m - n ) > 1 ) return false ; let count = 0 ; let i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 [ i ] != s2 [ j ] ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; else { i ++ ; j ++ ; } count ++ ; } else { i ++ ; j ++ ; } } if ( i < m j < n ) count ++ ; return count == 1 ; }
function countOccurrences ( x , d ) { var count = 0 ; while ( x > 0 ) { if ( x % 10 == d ) count ++ ; x = parseInt ( x / 10 ) ; } return count ; }
function maxOccurring ( x ) { if ( x < 0 ) x = - x ; var result = 0 ; var max_count = 1 ; for ( d = 0 ; d <= 9 ; d ++ ) { var count = countOccurrences ( x , d ) ; if ( count >= max_count ) { max_count = count ; result = d ; } } return result ; }
function maxSubarrayXOR ( arr , n ) { let ans = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let curr_xor = 0 ; for ( let j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }
function cntNum ( X , i , sum , tight , dp ) { if ( i >= X . length sum < 0 ) { if ( sum == 0 ) { return 1 ; } return 0 ; } if ( dp [ sum ] [ i ] [ tight ] != - 1 ) { return dp [ sum ] [ i ] [ tight ] ; } let res = 0 ; let end = tight != 0 ? X [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) : 9 ; for ( let j = 0 ; j <= end ; j ++ ) { res += cntNum ( X , i + 1 , sum - j , ( tight > 0 & ( j == end ) ) == true ? 1 : 0 , dp ) ; } return dp [ sum ] [ i ] [ tight ] = res ; }
function UtilCntNumRange ( L , R , Y ) { if ( R == 0 && Y == 0 ) { return 1 ; } let str = ( R ) . toString ( ) ; let dp = new Array ( M ) ; for ( let i = 0 ; i < M ; i ++ ) { dp [ i ] = new Array ( M ) ; for ( let j = 0 ; j < M ; j ++ ) { dp [ i ] [ j ] = new Array ( 2 ) ; for ( let k = 0 ; k < 2 ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ; } } let cntR = cntNum ( str , 0 , Y , 1 , dp ) ; str = ( L - 1 ) . toString ( ) ; for ( let i = 0 ; i < M ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { for ( let k = 0 ; k < 2 ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ; } } let cntL = cntNum ( str , 0 , Y , 1 , dp ) ; return ( cntR - cntL ) ; }
function areIsomorphic ( str1 , str2 ) { let m = str1 . length ; let n = str2 . length ; if ( m != n ) return false ; let marked = new Array ( size ) ; for ( let i = 0 ; i < size ; i ++ ) marked [ i ] = false ; let map = new Array ( size ) ; map . fill ( 0 ) ; for ( let i = 0 ; i < size ; i ++ ) map [ i ] = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( map [ str1 [ i ] . charCodeAt ( ) ] == - 1 ) { if ( marked [ str2 [ i ] . charCodeAt ( ) ] == true ) return false ; marked [ str2 [ i ] . charCodeAt ( ) ] = true ; map [ str1 [ i ] . charCodeAt ( ) ] = str2 [ i ] . charCodeAt ( ) ; } else if ( map [ str1 [ i ] . charCodeAt ( ) ] != str2 [ i ] . charCodeAt ( ) ) return 0 ; } return 1 ; }
function isPalin ( str , st , end ) { while ( st < end ) { if ( str [ st ] != str [ end ] ) return false ; st ++ ; end -- ; } return true ; }
function findMinInsert ( str , n ) { for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( isPalin ( str , 0 , i ) ) return ( n - i - 1 ) ; } }
function removeRecur ( n ) { let prev_digit = n % 10 ; let pow = 10 ; let res = prev_digit ; while ( n > 0 ) { let curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = parseInt ( n / 10 , 10 ) ; } return res ; }
function removeSpaces ( str ) { var count = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) if ( str [ i ] !== "▁" ) str [ count ++ ] = str [ i ] ; return count ; }
function isValid ( count , k ) { let val = 0 ; for ( let i = 0 ; i < MAX_CHARS ; i ++ ) { if ( count [ i ] > 0 ) { val ++ ; } } return ( k >= val ) ; }
function kUniques ( s , k ) { let u = 0 ; let n = s . length ; let count = new Array ( MAX_CHARS ) ; for ( let i = 0 ; i < MAX_CHARS ; i ++ ) { count [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { if ( count [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] == 0 ) { u ++ ; } count [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } if ( u < k ) { document . write ( "Not▁enough▁unique▁characters" ) ; return ; } let curr_start = 0 , curr_end = 0 ; let max_window_size = 1 ; let max_window_start = 0 ; for ( let i = 0 ; i < MAX_CHARS ; i ++ ) { count [ i ] = 0 ; } count [ s [ 0 ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( let i = 1 ; i < n ; i ++ ) { count [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; curr_end ++ ; while ( ! isValid ( count , k ) ) { count [ s [ curr_start ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] -- ; curr_start ++ ; } if ( curr_end - curr_start + 1 > max_window_size ) { max_window_size = curr_end - curr_start + 1 ; max_window_start = curr_start ; } } document . write ( "Max▁substring▁is▁:▁" + s . substring ( max_window_start , max_window_start + max_window_size + 1 ) + "▁with▁length▁" + max_window_size ) ; }
function canFormPalindrome ( str ) { let count = Array ( NO_OF_CHARS ) . fill ( 0 ) ; for ( let i = 0 ; i < str . length ; i ++ ) count [ str [ i ] . charCodeAt ( ) ] ++ ; let odd = 0 ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) == 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; }
function count9s ( number ) { let count = 0 ; let n = ( number . length ) ; for ( let i = 0 ; i < n ; i ++ ) { let sum = number [ i ] - "0" ; if ( number [ i ] == "9" ) { count ++ ; } for ( let j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number [ j ] - "0" ) % 9 ; if ( sum == 0 ) { count ++ ; } } } return count ; }
function difference ( arr , n ) { let d1 = 0 , d2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return Math . abs ( d1 - d2 ) ; }
function generateGray ( n ) { if ( n <= 0 ) { let temp = [ "0" ] ; return temp ; } if ( n == 1 ) { let temp = [ "0" , "1" ] ; return temp ; } let recAns = generateGray ( n - 1 ) ; let mainAns = [ ] ; for ( let i = 0 ; i < recAns . length ; i ++ ) { let s = recAns [ i ] ; mainAns . push ( "0" + s ) ; } for ( let i = recAns . length - 1 ; i >= 0 ; i -- ) { let s = recAns [ i ] ; mainAns . push ( "1" + s ) ; } return mainAns ; }
function areAnagram ( str1 , str2 ) { let count1 = new Array ( NO_OF_CHARS ) ; let count2 = new Array ( NO_OF_CHARS ) ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) { count1 [ i ] = 0 ; count2 [ i ] = 0 ; } let i ; for ( i = 0 ; i < str1 . length && i < str2 . length ; i ++ ) { count1 [ str1 [ i ] . charCodeAt ( 0 ) ] ++ ; count2 [ str1 [ i ] . charCodeAt ( 0 ) ] ++ ; } if ( str1 . length != str2 . length ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; }
function areAnagram ( str1 , str2 ) { let count = new Array ( NO_OF_CHARS ) ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) { count [ i ] = 0 ; } let i ; for ( i = 0 ; i < str1 . length ; i ++ ) { count [ str1 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; count [ str2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] -- ; } if ( str1 . length != str2 . length ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count [ i ] != 0 ) { return false ; } return true ; }
function longestUniqueSubsttr ( str ) { var n = str . length ( ) ; var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i ; j < n ; j ++ ) if ( areDistinct ( str , i , j ) ) res = Math . max ( res , j - i + 1 ) ; return res ; }
function longestUniqueSubsttr ( str ) { var n = str . length ( ) ; var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var visited = new [ 256 ] ; for ( var j = i ; j < n ; j ++ ) { if ( visited [ str . charAt ( j ) ] == true ) break ; else { res = Math . max ( res , j - i + 1 ) ; visited [ str . charAt ( j ) ] = true ; } } visited [ str . charAt ( i ) ] = false ; } return res ; }
function spiralFill ( m , n , a ) { let val = 1 ; let k = 0 , l = 0 ; while ( k < m && l < n ) { for ( let i = l ; i < n ; ++ i ) a [ k ] [ i ] = val ++ ; k ++ ; for ( let i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = val ++ ; n -- ; if ( k < m ) { for ( let i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = val ++ ; m -- ; } if ( l < n ) { for ( let i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = val ++ ; l ++ ; } } }
function isValid ( board , i , j , K ) { if ( board [ i ] [ j ] <= K ) { return true ; } return false ; }
function findPath ( board , X , Y , M , N , K ) { if ( X < 0 X == M Y < 0 Y == N ) { return true ; } if ( isValid ( board , X , Y , K ) ) { let board_XY = board [ X ] [ Y ] ; board [ X ] [ Y ] = Number . MAX_VALUE ; if ( findPath ( board , X + 1 , Y , M , N , K - board_XY ) || findPath ( board , X - 1 , Y , M , N , K - board_XY ) || findPath ( board , X , Y + 1 , M , N , K - board_XY ) || findPath ( board , X , Y - 1 , M , N , K - board_XY ) ) { return true ; } board [ X ] [ Y ] = board_XY ; } return false ; }
function pathMoves ( mat , src , dest ) { var d = Array . from ( Array ( ROW ) , ( ) => Array ( COL ) ) ; for ( var i = 0 ; i < ROW ; i ++ ) { for ( var j = 0 ; j < COL ; j ++ ) d [ i ] [ j ] = - 1 ; } d [ src . x ] [ src . y ] = 0 ; var visited = Array . from ( Array ( ROW ) , ( ) => Array ( COL ) ) ; visited [ src . x ] [ src . y ] = true ; var q = [ ] ; var s = newNode ( src , 0 ) ; q . push ( s ) ; var ok = false ; while ( q . length > 0 ) { var curr = q [ 0 ] ; q . shift ( ) ; var pt = curr . pt ; if ( pt . x == dest . x && pt . y == dest . y ) { var xx = pt . x , yy = pt . y ; var dist = curr . dist ; d [ pt . x ] [ pt . y ] = dist ; var pathmoves = "" ; while ( xx != src . x yy != src . y ) { if ( xx > 0 && d [ xx - 1 ] [ yy ] == dist - 1 ) { pathmoves += "D" ; xx -- ; } if ( xx < ROW - 1 && d [ xx + 1 ] [ yy ] == dist - 1 ) { pathmoves += "U" ; xx ++ ; } if ( yy > 0 && d [ xx ] [ yy - 1 ] == dist - 1 ) { pathmoves += "R" ; yy -- ; } if ( yy < COL - 1 && d [ xx ] [ yy + 1 ] == dist - 1 ) { pathmoves += "L" ; yy ++ ; } dist -- ; } for ( var i = pathmoves . length - 1 ; i >= 0 ; -- i ) document . write ( pathmoves [ i ] ) ; ok = true ; break ; } if ( q . length > 0 ) { q . shift ( ) ; } for ( var i = 0 ; i < 4 ; i ++ ) { var row = pt . x + dRow [ i ] ; var col = pt . y + dCol [ i ] ; if ( isValid ( row , col ) && ( mat [ row ] [ col ] == "1" mat [ row ] [ col ] == "s" mat [ row ] [ col ] == "d" ) && ! visited [ row ] [ col ] ) { visited [ row ] [ col ] = true ; var adjCell = newNode ( newPoint ( row , col ) , curr . dist + 1 ) ; q . push ( adjCell ) ; d [ row ] [ col ] = curr . dist + 1 ; } } } if ( ok == false ) document . write ( - 1 ) ; }
function isPerfect ( x ) { var sum_div = 1 ; for ( i = 2 ; i <= x / 2 ; ++ i ) { if ( x % i == 0 ) { sum_div += i ; } } if ( sum_div == x ) { return 1 ; } else return 0 ; }
function isPerfect ( x ) { var sum_div = 1 ; for ( var i = 2 ; i <= parseInt ( x / 2 ) ; ++ i ) { if ( x % i == 0 ) { sum_div += i ; } } if ( sum_div == x ) { return 1 ; } else return 0 ; }
function subsetSum ( arr , n ) { var total = 1 << n ; for ( i = 0 ; i < total ; i ++ ) { var sum = 0 ; for ( j = 0 ; j < n ; j ++ ) if ( ( i & ( 1 << j ) ) != 0 ) sum += arr [ j ] ; if ( isPerfect ( sum ) != 0 ) { document . write ( sum + "▁" ) ; } } }
function factorial ( N ) { fact [ 0 ] = 1 ; for ( var i = 1 ; i <= N ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; }
function printLevelOrder ( root ) { if ( root == null ) return ; let q = [ ] ; q . push ( root ) ; while ( q . length != 0 ) { let temp = q [ 0 ] ; document . write ( temp . data + "▁" ) ; q . shift ( ) ; if ( temp . left != null ) { q . push ( temp . left ) ; } else if ( temp . right != null ) { document . write ( "null▁" ) ; } if ( temp . right != null ) { q . push ( temp . right ) ; } else if ( temp . left != null ) { document . write ( "null▁" ) ; } } }
function PenGame ( N ) { let P1 = 0 ; let P2 = 0 ; let X = 0 ; let Move = 0 ; let QuitP1 = false ; let QuitP2 = false ; solve ( N , P1 , P2 , X , Move , QuitP1 , QuitP2 ) ; }
function findTrace ( mat , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += mat [ i ] [ i ] ; return sum ; }
function checkUntil ( num , K , N , ans ) { if ( N == 1 ) { ans . push ( num ) ; return ; } if ( ( num % 10 + K ) <= 9 ) checkUntil ( 10 * num + ( num % 10 + K ) , K , N - 1 , ans ) ; if ( K > 0 ) { if ( ( num % 10 - K ) >= 0 ) checkUntil ( 10 * num + num % 10 - K , K , N - 1 , ans ) ; } }
function check ( K , N , ans ) { for ( let i = 1 ; i <= 9 ; i ++ ) { checkUntil ( i , K , N , ans ) ; } }
function comb ( arr , len , r , ipos , op , opos , sum ) { if ( opos == r ) { let sum2 = 0 ; for ( let i = 0 ; i < opos ; i ++ ) { sum2 = sum2 + op [ i ] ; } if ( sum == sum2 ) { for ( let i = 0 ; i < opos ; i ++ ) document . write ( op [ i ] + ",▁" ) ; document . write ( ) ; } return ; } if ( ipos < len ) { comb ( arr , len , r , ipos + 1 , op , opos , sum ) ; op [ opos ] = arr [ ipos ] ; comb ( arr , len , r , ipos + 1 , op , opos + 1 , sum ) ; } }
function SieveOfEratosthenes ( prime , p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
function primeCliques ( i , l , prime ) { for ( let j = i + 1 ; j <= n ; j ++ ) { store [ l ] = j ; if ( is_clique ( l + 1 ) ) { if ( prime [ l ] ) ans ++ ; else { ans -= 1.3 ; } primeCliques ( j , l + 1 , prime ) ; } } }
function countWays ( mtrx , vrtx , i , dest , visited ) { if ( i == dest ) { return 1 ; } let total = 0 ; for ( let j = 0 ; j < vrtx ; j ++ ) { if ( mtrx [ i ] [ j ] == 1 && ! visited [ j ] ) { visited [ j ] = true ; total += countWays ( mtrx , vrtx , j , dest , visited ) ; visited [ j ] = false ; } } return total ; }
function totalWays ( mtrx , vrtx , src , dest ) { let visited = new Array ( vrtx ) ; for ( let i = 0 ; i < vrtx ; i ++ ) { visited [ i ] = false ; } visited [ src ] = true ; return countWays ( mtrx , vrtx , src , dest , visited ) ; }
function minOperation ( arr ) { let ans = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { for ( let j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( let k = 0 ; k <= i ; k ++ ) { for ( let h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; }
function find_x ( n ) { if ( n == 1 ) return 1 ; let num , den , p ; num = Math . log10 ( n ) ; let x = 0 , no = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { den = Math . log10 ( i ) ; p = num / den ; no = parseInt ( Math . pow ( i , parseInt ( p , 10 ) ) , 10 ) ; if ( Math . abs ( no - n ) < 1e-6 ) { x = i ; break ; } } return x ; }
function is_key ( n , x ) { let p ; p = Math . log10 ( n ) / Math . log10 ( x ) ; let no = parseInt ( Math . pow ( x , parseInt ( p , 10 ) ) , 10 ) ; if ( n == no ) return true ; return false ; }
function evenPaths ( node , count , x ) { if ( node == null || ! is_key ( node . key , x ) ) { return count ; } if ( node . left == null && node . right == null ) { count ++ ; } count = evenPaths ( node . left , count , x ) ; return evenPaths ( node . right , count , x ) ; }
function dfs ( a , b , v , vis ) { vis [ a ] = 1 ; c ++ ; for ( let i of v [ a ] ) { if ( vis [ i ] == 0 && i != b ) dfs ( i , b , v , vis ) ; } }
function printExistPath ( sx , sy , last ) { if ( sx . length == 0 sy . length == 0 ) { return ; } let x = sx [ sx . length - 1 ] ; let y = sy [ sy . length - 1 ] ; sx . pop ( ) ; sy . pop ( ) ; printExistPath ( sx , sy , last ) ; if ( x == 83 ) { document . write ( "(" + x + ",▁" + y + ")" ) ; } else { document . write ( "(" + x + ",▁" + y + ")->" ) ; } }
function storePath ( srcX , srcY , destX , destY , sx , sy ) { if ( srcX > destX srcY > destY ) { return false ; } sx . push ( srcX ) ; sy . push ( srcY ) ; if ( srcX == destX && srcY == destY ) { printExistPath ( sx , sy , sx . length ) ; return true ; } if ( storePath ( ( 2 * srcX ) + srcY , srcY , destX , destY , sx , sy ) ) { return true ; } if ( storePath ( srcX , ( 2 * srcY ) + srcX , destX , destY , sx , sy ) ) { return true ; } sx . pop ( ) ; sy . pop ( ) ; return false ; }
function isPathExist ( srcX , srcY , destX , destY ) { let sx = [ ] ; let sy = [ ] ; return storePath ( srcX , srcY , destX , destY , sx , sy ) ; }
function printPath ( srcX , srcY , destX , destY ) { if ( ! isPathExist ( srcX , srcY , destX , destY ) ) { document . write ( "-1" ) ; } }
function dfs ( v ) { col [ v ] = 1 ; for ( let p of g [ v ] ) { let to = p [ 0 ]  let id = p [ 1 ] ; if ( col [ to ] == 0 ) { dfs ( to ) ; res [ id ] = 1 ; } else if ( col [ to ] == 2 ) { res [ id ] = 1 ; } else { res [ id ] = 2 ; cyc = true ; } } col [ v ] = 2 ; }
function sumSubsets ( set , n , target ) { let x = new Array ( set . length ) ; let j = set . length - 1 ; while ( n > 0 ) { x [ j ] = n % 2 ; n = Math . floor ( n / 2 ) ; j -- ; } let sum = 0 ; for ( let i = 0 ; i < set . length ; i ++ ) if ( x [ i ] == 1 ) sum = sum + set [ i ] ; if ( sum == target ) { document . write ( "{" ) ; for ( let i = 0 ; i < set . length ; i ++ ) if ( x [ i ] == 1 ) document . write ( set [ i ] + ",▁" ) ; document . write ( "},▁" ) ; } }
function findSubsets ( arr , K ) { let x = Math . pow ( 2 , arr . length ) ; for ( let i = 1 ; i < x ; i ++ ) sumSubsets ( arr , i , K ) ; }
function ncr ( n , r ) { return ( fact [ n ] / fact [ r ] ) / fact [ n - r ] ; }
function findSum ( arr , n ) { fact [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; let mul = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) mul += Math . pow ( 2 , i ) * ncr ( n - 1 , i ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans += mul * arr [ i ] ; return ans ; }
function numberOfPaths ( m , n ) { var path = 1 ; for ( var i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }
function solve ( maze ) { var ans = numberOfPaths ( R , C ) - countPaths ( maze ) ; return ans ; }
function dfs1 ( u , count ) { visited [ u ] = true ; let temp = 0 ; for ( let i = 0 ; i < adjacent [ u ] . length ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] ) { temp ++ ; parent [ adjacent [ u ] [ i ] ] = u ; dfs1 ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; endnode = u ; } } }
function dfs2 ( u , count ) { visited [ u ] = true ; let temp = 0 ; for ( let i = 0 ; i < adjacent [ u ] . length ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] && ! vis [ adjacent [ u ] [ i ] ] ) { temp ++ ; dfs2 ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; thirdnode = u ; } } }
function findNodes ( ) { dfs ( 1 , 0 ) ; for ( let i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; maxi = - 1 ; dfs1 ( startnode , 0 ) ; for ( let i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; let x = endnode ; vis [ startnode ] = true ; while ( x != startnode ) { vis [ x ] = true ; x = parent [ x ] ; } maxi = - 1 ; for ( let i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] ) dfs2 ( i , 0 ) ; } }
function dfsUtil ( u , node , visited , road_used , parent , it ) { let c = 0 ; for ( let i = 0 ; i < node ; i ++ ) if ( visited [ i ] ) c ++ ; if ( c == node ) return ; visited [ u ] = true ; road_used . push ( [ parent , u ] ) ; document . write ( u + "▁" ) ; for ( let x = 0 ; x < adj [ u ] . length ; x ++ ) { if ( ! visited [ adj [ u ] [ x ] ] ) { dfsUtil ( adj [ u ] [ x ] , node , visited , road_used , u , it + 1 ) ; } } for ( let y = 0 ; y < road_used . length ; y ++ ) { if ( road_used [ y ] [ 1 ] == u ) { dfsUtil ( road_used [ y ] [ 0 ] , node , visited , road_used , u , it + 1 ) ; } } }
function dfs ( node ) { let visited = new Array ( node ) ; let road_used = [ ] ; for ( let i = 0 ; i < node ; i ++ ) { visited [ i ] = false ; } dfsUtil ( 0 , node , visited , road_used , - 1 , 0 ) ; }
function primeSum ( total , N , S , index ) { if ( total == S && set . length == N ) { display ( ) ; return ; } if ( total > S index == prime . length ) return ; set . push ( prime [ index ] ) ; primeSum ( total + prime [ index ] , N , S , index + 1 ) ; set . pop ( ) ; primeSum ( total , N , S , index + 1 ) ; }
function allPrime ( N , S , P ) { for ( var i = P + 1 ; i <= S ; i ++ ) { if ( isPrime ( i ) ) prime . push ( i ) ; } if ( prime . length < N ) return ; primeSum ( 0 , N , S , 0 ) ; }
function grayCodes ( n ) { let res = [ ] ; let num = [ 0 ] ; grayCodeUtil ( res , n , num ) ; return res ; }
function isParenthesis ( c ) { return ( ( c == "(" ) || ( c == ")" ) ) ; }
function isValidString ( str ) { let cnt = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == "(" ) cnt ++ ; else if ( str [ i ] == ")" ) cnt -- ; if ( cnt < 0 ) return false ; } return ( cnt == 0 ) ; }
function findSum ( n ) { let ans = 0 , temp = 0 , num ; for ( let i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
function isSafe ( grid , row , col , num ) { for ( let x = 0 ; x <= 8 ; x ++ ) if ( grid [ row ] [ x ] == num ) return false ; for ( let x = 0 ; x <= 8 ; x ++ ) if ( grid [ x ] [ col ] == num ) return false ; let startRow = row - row % 3 , startCol = col - col % 3 ; for ( let i = 0 ; i < 3 ; i ++ ) for ( let j = 0 ; j < 3 ; j ++ ) if ( grid [ i + startRow ] [ j + startCol ] == num ) return false ; return true ; }
function solveSuduko ( grid , row , col ) { if ( row == N - 1 && col == N ) return true ; if ( col == N ) { row ++ ; col = 0 ; } if ( grid [ row ] [ col ] != 0 ) return solveSuduko ( grid , row , col + 1 ) ; for ( let num = 1 ; num < 10 ; num ++ ) { if ( isSafe ( grid , row , col , num ) ) { grid [ row ] [ col ] = num ; if ( solveSuduko ( grid , row , col + 1 ) ) return true ; } grid [ row ] [ col ] = 0 ; } return false ; }
function fact ( n ) { let ans = 1 ; for ( let i = 2 ; i <= n ; i ++ ) ans *= i ; return ans ; }
function remainder ( n , a , p ) { let len = fact ( n ) ; let ans = 1 ; for ( let i = 1 ; i <= len ; i ++ ) ans = ( ans * a ) % p ; return ans ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
function remainder ( n , a , p ) { let ans = a % p ; for ( let i = 1 ; i <= n ; i ++ ) ans = power ( ans , i , p ) ; return ans ; }
function check ( n , w ) { var a = Array ( 105 ) . fill ( 0 ) ; var p = 0 ; while ( n > 0 ) { a [ p ++ ] = n % w ; n /= w ; n = parseInt ( n ) ; } var flag = true ; for ( i = 0 ; i <= 100 ; i ++ ) { if ( a [ i ] == 0 a [ i ] == 1 ) continue ; else if ( a [ i ] == w a [ i ] == w - 1 ) a [ i + 1 ] ++ ; else flag = false ; } return flag ; }
function numPairs ( a , n ) { let ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; a . sort ( ) ; for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; } return ans ; }
function exponentMod ( A , B ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; let y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 ) ; y = ( y * y ) % mod ; } else { y = A % mod ; y = ( y * exponentMod ( A , B - 1 ) % mod ) % mod ; } return ( ( y + mod ) % mod ) ; }
function countWays ( N ) { let select = exponentMod ( 2 , N - 1 ) ; let ways = ( ( N % mod ) * ( select % mod ) ) ; ways %= mod ; document . write ( ways ) ; }
function findSum ( n ) { let arr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { arr [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
function MaxUtil ( st , ss , se , l , r , node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return - 1 ; let mid = getMid ( ss , se ) ; return Math . max ( MaxUtil ( st , ss , mid , l , r , 2 * node ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 1 ) ) ; }
function count ( arr , low , high , x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , Math . floor ( ( low + high ) / 2 ) , x ) + count ( arr , 1 + Math . floor ( ( low + high ) / 2 ) , high , x ) ; }
function findSum ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
function matrix_product ( a , b ) { var c = Array . from ( Array ( 7 ) , ( ) => Array ( 7 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < 7 ; i ++ ) for ( var j = 0 ; j < 7 ; j ++ ) for ( var k = 0 ; k < 7 ; k ++ ) c [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; return c ; }
function mul_expo ( mul , p ) { var s = [ [ 1 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 1 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 1 ] ] ; while ( p != 1 ) { if ( p % 2 == 1 ) s = matrix_product ( s , mul ) ; mul = matrix_product ( mul , mul ) ; p = parseInt ( p / 2 ) ; } return matrix_product ( mul , s ) ; }
function expectedSteps ( x ) { if ( x == 0 ) return 0 ; if ( x <= 6 ) return 6 ; var mul = [ [ 7 / 6 , 1 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 1 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 1 ] , [ - 1 / 6 , 0 , 0 , 0 , 0 , 0 , 0 ] ] ; mul = mul_expo ( mul , x - 6 ) ; return ( mul [ 0 ] [ 0 ] + mul [ 1 ] [ 0 ] + mul [ 2 ] [ 0 ] + mul [ 3 ] [ 0 ] + mul [ 4 ] [ 0 ] + mul [ 5 ] [ 0 ] ) * 6 ; }
function maxDistance ( cell , n , p ) { cell . sort ( ) ; var start = 0 ; var end = cell [ n - 1 ] - cell [ 0 ] ; var ans = 0 ; while ( start <= end ) { var mid = start + parseInt ( ( ( end - start ) / 2 ) ) ; if ( canPlace ( cell , n , p , mid ) ) { ans = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; }
function solve ( n ) { let low = 1 , high = 1e4 , x = n , p = 0 ; while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; let sum = Math . floor ( ( mid * ( mid + 1 ) ) / 2 ) ; if ( x - sum >= 1 ) { p = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } let start = 1 , end = 1e4 , y = 1 , q = 0 ; while ( start <= end ) { let mid = Math . floor ( ( start + end ) / 2 ) ; let sum = Math . floor ( ( mid * ( mid + 1 ) ) / 2 ) ; if ( y + sum <= n ) { q = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } x = x - Math . floor ( ( p * ( p + 1 ) ) / 2 ) ; y = y + Math . floor ( ( q * ( q + 1 ) ) / 2 ) ; let r = x ; let c = q + 1 - n + y ; let ans = [ r , c ] ; return ans ; }
function build ( l , r , In , arr ) { if ( l == r ) return seg [ In ] = arr [ l ] ; let mid = Math . floor ( ( l + r ) / 2 ) ; return seg [ In ] = __gcd ( build ( l , mid , 2 * In + 1 , arr ) , build ( mid + 1 , r , 2 * In + 2 , arr ) ) ; }
function query ( l , r , l1 , r1 , In ) { if ( l1 <= l && r <= r1 ) return seg [ In ] ; if ( l > r1 r < l1 ) return 0 ; let mid = Math . floor ( ( l + r ) / 2 ) ; return __gcd ( query ( l , mid , l1 , r1 , 2 * In + 1 ) , query ( mid + 1 , r , l1 , r1 , 2 * In + 2 ) ) ; }
function findLen ( arr , n ) { build ( 0 , n - 1 , 0 , arr ) ; let i = 0 , j = 0 ; let ans = Number . MAX_VALUE ; while ( i < n ) { while ( j < n && query ( 0 , n - 1 , i , j , 0 ) != 1 ) j ++ ; if ( j == n ) break ; ans = Math . min ( ( j - i + 1 ) , ans ) ; i ++ ; j = Math . max ( j , i ) ; } if ( ans == Number . MAX_VALUE ) return - 1 ; else return ans ; }
function mergeSort ( arr , array_size ) { let temp = new Array ( array_size ) ; return _mergeSort ( arr , temp , 0 , array_size - 1 ) ; }
function merge ( arr , temp , left , mid , right ) { let i , j , k ; let inv_count = 0 ; i = left ; j = mid ; k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] > 2 * arr [ j ] ) { inv_count += ( mid - i ) ; j ++ ; } else { i ++ ; } } i = left ; j = mid ; k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) { temp [ k ++ ] = arr [ i ++ ] ; } else { temp [ k ++ ] = arr [ j ++ ] ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; }
function findGrid ( n ) { let arr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = new Array ( n ) ; let x = 0 ; for ( let i = 0 ; i < parseInt ( n / 4 ) ; i ++ ) { for ( let j = 0 ; j < parseInt ( n / 4 ) ; j ++ ) { for ( let k = 0 ; k < 4 ; k ++ ) { for ( let l = 0 ; l < 4 ; l ++ ) { arr [ i * 4 + k ] [ j * 4 + l ] = x ; x ++ ; } } } } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { document . write ( arr [ i ] [ j ] + "▁" ) ; } document . write ( "▁" ) ; } }
function buildTree ( l , r , i , arr ) { if ( l == r ) { segtree [ i ] = l ; return l ; } var l1 = buildTree ( l , parseInt ( ( l + r ) / 2 ) , 2 * i + 1 , arr ) ; var r1 = buildTree ( parseInt ( ( l + r ) / 2 ) + 1 , r , 2 * i + 2 , arr ) ; if ( arr [ l1 ] > arr [ r1 ] ) segtree [ i ] = l1 ; else segtree [ i ] = r1 ; return segtree [ i ] ; }
function rangeMax ( l , r , rl , rr , i , arr ) { if ( r < rl l > rr ) return - 1 ; if ( l >= rl && r <= rr ) return segtree [ i ] ; var l1 = rangeMax ( l , parseInt ( ( l + r ) / 2 ) , rl , rr , 2 * i + 1 , arr ) ; var r1 = rangeMax ( parseInt ( ( l + r ) / 2 ) + 1 , r , rl , rr , 2 * i + 2 , arr ) ; if ( l1 == - 1 ) return r1 ; if ( r1 == - 1 ) return l1 ; if ( arr [ l1 ] > arr [ r1 ] ) return l1 ; else return r1 ; }
function inorder ( curr ) { if ( curr == null ) return ; inorder ( curr . left ) ; document . write ( curr . data + "▁" ) ; inorder ( curr . right ) ; }
function findSum ( n ) { n -- ; let sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
function kthSmallest ( arr , k , n ) { let temp = [ ... arr ] ; let low = temp . sort ( ( a , b ) => a - b ) [ 0 ] ; let high = temp [ temp . length - 1 ] ; while ( low <= high ) { let mid = low + Math . floor ( ( high - low ) / 2 ) ; let countless = 0 , countequal = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( arr [ i ] < mid ) ++ countless ; else if ( arr [ i ] == mid ) ++ countequal ; } if ( countless < k && ( countless + countequal ) >= k ) { return mid ; } else if ( countless >= k ) { high = mid - 1 ; } else if ( countless < k && countless + countequal < k ) { low = mid + 1 ; } } }
function update ( x , y , value , id , l , r ) { if ( x >= r l >= y ) return ; if ( x <= l && r <= y ) { lazy [ id ] = value ; return ; } var mid = parseInt ( ( l + r ) / 2 ) ; if ( lazy [ id ] != 0 ) lazy [ 2 * id ] = lazy [ 2 * id + 1 ] = lazy [ id ] ; lazy [ id ] = 0 ; update ( x , y , value , 2 * id , l , mid ) ; update ( x , y , value , 2 * id + 1 , mid , r ) ; }
function query ( id , l , r ) { if ( lazy [ id ] != 0 ) { se . add ( lazy [ id ] ) ; return ; } if ( r - l < 2 ) return ; var mid = parseInt ( ( l + r ) / 2 ) ; query ( 2 * id , l , mid ) ; query ( 2 * id + 1 , mid , r ) ; }
function updateRangeUtil ( si , ss , se , us , ue , diff ) { if ( lazy [ si ] != 0 ) { tree [ si ] += lazy [ si ] ; if ( ss != se ) { lazy [ si * 2 + 1 ] += lazy [ si ] ; lazy [ si * 2 + 2 ] += lazy [ si ] ; } lazy [ si ] = 0 ; } if ( ss > se ss > ue se < us ) return ; if ( ss >= us && se <= ue ) { tree [ si ] += diff ; if ( ss != se ) { lazy [ si * 2 + 1 ] += diff ; lazy [ si * 2 + 2 ] += diff ; } return ; } var mid = parseInt ( ( ss + se ) / 2 ) ; updateRangeUtil ( si * 2 + 1 , ss , mid , us , ue , diff ) ; updateRangeUtil ( si * 2 + 2 , mid + 1 , se , us , ue , diff ) ; tree [ si ] = Math . max ( tree [ si * 2 + 1 ] , tree [ si * 2 + 2 ] ) ; }
function updateRange ( n , us , ue , diff ) { updateRangeUtil ( 0 , 0 , n - 1 , us , ue , diff ) ; }
function constructSTUtil ( arr , ss , se , si ) { if ( ss > se ) return ; if ( ss == se ) { tree [ si ] = arr [ ss ] ; return ; } var mid = parseInt ( ( ss + se ) / 2 ) ; constructSTUtil ( arr , ss , mid , si * 2 + 1 ) ; constructSTUtil ( arr , mid + 1 , se , si * 2 + 2 ) ; tree [ si ] = Math . max ( tree [ si * 2 + 1 ] , tree [ si * 2 + 2 ] ) ; }
function constructST ( arr , n ) { constructSTUtil ( arr , 0 , n - 1 , 0 ) ; }
function getCount ( n ) { let count = 1 ; while ( n != 0 ) { let leadDigit = firstDigit ( n ) ; n -= leadDigit ; count ++ ; } return count ; }
function getLargestNumber ( k ) { let left = k ; let right = k * 10 ; let mid = parseInt ( ( left + right ) / 2 , 10 ) ; let len = getCount ( mid ) ; while ( len != k ) { mid = parseInt ( ( left + right ) / 2 , 10 ) ; len = getCount ( mid ) ; if ( len > k ) { right = mid ; } else { left = mid ; } } while ( len == k ) { if ( len != getCount ( mid + 1 ) ) { break ; } mid ++ ; } return ( mid ) ; }
function F ( A , B ) { if ( A == 1 ) return ( 4 % B ) ; else { var temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }
function power ( x , y , p ) { var res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
function checkHV ( arr , N , M ) { let horizontal = true ; let vertical = true ; for ( let i = 0 , k = N - 1 ; i < parseInt ( N / 2 , 10 ) ; i ++ , k -- ) { for ( let j = 0 ; j < M ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } } for ( let i = 0 , k = M - 1 ; i < parseInt ( M / 2 , 10 ) ; i ++ , k -- ) { for ( let j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } } if ( ! horizontal && ! vertical ) document . write ( "NO" ) ; else if ( horizontal && ! vertical ) document . write ( "HORIZONTAL" ) ; else if ( vertical && ! horizontal ) document . write ( "VERTICAL" ) ; else document . write ( "BOTH" ) ; }
function rangeSum ( l , r ) { var a = 1 , b = 9 , res = 0 ; for ( var i = 1 ; i <= 10 ; i ++ ) { var L = Math . max ( l , a ) ; var R = Math . min ( r , b ) ; if ( L <= R ) { var sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
function getSetBitsFromOneToN ( N ) { let two = 2 , ans = 0 ; let n = N ; while ( n ) { ans += parseInt ( N / two ) * ( two >> 1 ) ; if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 ; two <<= 1 ; n >>= 1 ; } return ans ; }
function findMinimum ( x ) { let low = 0 , high = 100000 ; let ans = high ; while ( low <= high ) { let mid = ( low + high ) >> 1 ; if ( getSetBitsFromOneToN ( mid ) >= x ) { ans = Math . min ( ans , mid ) ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; }
function exponentMod ( A , B , C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; var y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return parseInt ( ( ( y + C ) % C ) ) ; }
function trailingZeroes ( n ) { var cnt = 0 ; while ( n > 0 ) { n = parseInt ( n / 5 ) ; cnt += n ; } return cnt ; }
function binarySearch ( n ) { var low = 0 ; while ( low < high ) { var mid = parseInt ( ( low + high ) / 2 ) ; var count = trailingZeroes ( mid ) ; if ( count < n ) low = mid + 1 ; else high = mid ; } var result = [ ] ; while ( trailingZeroes ( low ) == n ) { result . push ( low ) ; low ++ ; } for ( var i = 0 ; i < result . length ; i ++ ) document . write ( result [ i ] + "▁" ) ; }
function maxDet ( n ) { return ( 2 * n * n * n ) ; }
function resMatrix ( n ) { for ( let i = 0 ; i < 3 ; i ++ ) { for ( let j = 0 ; j < 3 ; j ++ ) { if ( i == 0 && j == 2 ) document . write ( "0▁" ) ; else if ( i == 1 && j == 0 ) document . write ( "0▁" ) ; else if ( i == 2 && j == 1 ) document . write ( "0▁" ) ; else document . write ( n + "▁" ) ; } document . write ( "" ) ; } }
function getCumulateSum ( n ) { return parseInt ( ( n * ( n + 1 ) ) / 2 , 10 ) ; }
function minDaysToEmpty ( C , l ) { if ( C <= l ) return C ; let lo = 0 ; let hi = 1e4 ; let mid ; while ( lo < hi ) { mid = parseInt ( ( lo + hi ) / 2 , 10 ) ; if ( getCumulateSum ( mid ) >= ( C - l ) ) hi = mid ; else lo = mid + 1 ; } return ( l + lo ) ; }
function minDaysToEmpty ( C , l ) { if ( l >= C ) return C ; let eq_root = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( Math . ceil ( eq_root ) + l ) ; }
function shuffleArray ( a , n ) { for ( let i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( let j = k ; j > i + q ; j -- ) { let temp = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = temp ; } }
function kth ( arr1 , arr2 , m , n , k ) { var sorted1 = Array ( m + n ) . fill ( 0 ) ; var i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }
function spiralDiaSum ( n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
function binarySearch ( mat , i , j_low , j_high , x ) { while ( j_low <= j_high ) { let j_mid = Math . floor ( ( j_low + j_high ) / 2 ) ; if ( mat [ i ] [ j_mid ] == x ) { document . write ( "Found▁at▁(" + i + ",▁" + j_mid + ")" ) ; return ; } else if ( mat [ i ] [ j_mid ] > x ) j_high = j_mid - 1 ; else j_low = j_mid + 1 ; } document . write ( "Element▁no▁found" ) ; }
function sortedMatrixSearch ( mat , n , m , x ) { if ( n == 1 ) { binarySearch ( mat , 0 , 0 , m - 1 , x ) ; return ; } let i_low = 0 ; let i_high = n - 1 ; let j_mid = Math . floor ( m / 2 ) ; while ( ( i_low + 1 ) < i_high ) { let i_mid = Math . floor ( ( i_low + i_high ) / 2 ) ; if ( mat [ i_mid ] [ j_mid ] == x ) { document . write ( "Found▁at▁(" + i_mid + ",▁" + j_mid + ")" ) ; return ; } else if ( mat [ i_mid ] [ j_mid ] > x ) i_high = i_mid ; else i_low = i_mid ; } if ( mat [ i_low ] [ j_mid ] == x ) document . write ( "Found▁at▁(" + i_low + "," + j_mid + ")" ) ; else if ( mat [ i_low + 1 ] [ j_mid ] == x ) document . write ( "Found▁at▁(" + ( i_low + 1 ) + ",▁" + j_mid + ")" ) ; else if ( x <= mat [ i_low ] [ j_mid - 1 ] ) binarySearch ( mat , i_low , 0 , j_mid - 1 , x ) ; else if ( x >= mat [ i_low ] [ j_mid + 1 ] && x <= mat [ i_low ] [ m - 1 ] ) binarySearch ( mat , i_low , j_mid + 1 , m - 1 , x ) ; else if ( x <= mat [ i_low + 1 ] [ j_mid - 1 ] ) binarySearch ( mat , i_low + 1 , 0 , j_mid - 1 , x ) ; else binarySearch ( mat , i_low + 1 , j_mid + 1 , m - 1 , x ) ; }
function isFeasible ( mid , arr , n , k ) { let pos = arr [ 0 ] ; let elements = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - pos >= mid ) { pos = arr [ i ] ; elements ++ ; if ( elements == k ) return true ; } } return false ; }
function largestMinDist ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b } ) ; let res = - 1 ; let left = 1 , right = arr [ n - 1 ] ; while ( left < right ) { let mid = parseInt ( ( left + right ) / 2 , 10 ) ; if ( isFeasible ( mid , arr , n , k ) ) { res = Math . max ( res , mid ) ; left = mid + 1 ; } else right = mid ; } return res ; }
function bsearch ( low , high , n , arr ) { let mid = ( low + high ) / 2 ; if ( low <= high ) { if ( arr [ mid ] < n ) return bsearch ( mid + 1 , high , n , arr ) ; return bsearch ( low , mid - 1 , n , arr ) ; } return low ; }
function mindiff ( arr , n , m ) { for ( let i = 0 ; i < n ; i ++ ) arr . sort ( ) ; let ans = + 2147483647 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { let p = bsearch ( 0 , m - 1 , arr [ i ] [ j ] , arr [ i + 1 ] ) ; ans = Math . min ( ans , Math . abs ( arr [ i + 1 ] [ p ] - arr [ i ] [ j ] ) ) ; if ( p - 1 >= 0 ) ans = Math . min ( ans , Math . abs ( arr [ i + 1 ] [ p - 1 ] - arr [ i ] [ j ] ) ) ; } } return ans ; }
function binarySearch ( arr , left , right ) { if ( left <= right ) { var mid = parseInt ( ( left + right ) / 2 ) ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; }
function findRepeatingElement ( arr , low , high ) { if ( low > high ) return - 1 ; var mid = parseInt ( ( low + high ) / 2 ) ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }
function diff ( n , mid ) { if ( n > ( mid * mid * mid ) ) return ( n - ( mid * mid * mid ) ) ; else return ( ( mid * mid * mid ) - n ) ; }
function cubicRoot ( n ) { let start = 0 , end = n ; let e = 0.0000001 ; while ( true ) { let mid = ( start + end ) / 2 ; let error = diff ( n , mid ) ; if ( error <= e ) return mid ; if ( ( mid * mid * mid ) > n ) end = mid ; else start = mid ; } }
function findFrequencyUtil ( arr , low , high , freq ) { if ( arr [ low ] == arr [ high ] ) { freq [ arr [ low ] ] += high - low + 1 ; } else { let mid = Math . floor ( ( low + high ) / 2 ) ; findFrequencyUtil ( arr , low , mid , freq ) ; findFrequencyUtil ( arr , mid + 1 , high , freq ) ; } }
function findFrequency ( arr , n ) { let freq = new Array ( arr [ n - 1 ] + 1 ) ; for ( let i = 0 ; i < arr [ n - 1 ] + 1 ; i ++ ) { freq [ i ] = 0 ; } findFrequencyUtil ( arr , 0 , n - 1 , freq ) ; for ( let i = 0 ; i <= arr [ n - 1 ] ; i ++ ) if ( freq [ i ] != 0 ) document . write ( "Element▁" + i + "▁occurs▁" + freq [ i ] + "▁times" ) ; }
function floorSqrt ( x ) { if ( x == 0 x == 1 ) return x ; let i = 1 ; let result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }
function countDirectPath ( N ) { return N + Math . floor ( ( N * ( N - 3 ) ) / 2 ) ; }
function isPossibleToReach ( A , N , X , Y ) { let distance = Math . sqrt ( ( X * X + Y * Y ) ) ; let mx = 0 ; for ( let i = 0 ; i < N ; i ++ ) { mx += A [ i ] ; } if ( mx < distance ) { document . write ( "NO" ) ; return 0 ; } if ( ( mx - distance ) < 0.000001 ) { document . write ( "YES" ) ; return 0 ; } for ( let i = 0 ; i < N ; i ++ ) { if ( distance + mx < 2 * A [ i ] ) { document . write ( "No" ) ; return 0 ; } } document . write ( "Yes" ) ; return 0 ; }
function canReach ( X , Y ) { var steps = 0 ; while ( X != 0 Y != 0 ) { var pos1 = X % 3 ; var pos2 = Y % 3 ; if ( pos1 == 2 pos2 == 2 ) { return false ; } if ( pos1 == 1 && pos2 == 1 ) { return false ; } if ( pos1 == 0 && pos2 == 0 ) { return false ; } X /= 3 ; Y /= 3 ; steps ++ ; } return true ; }
function numofneighbour ( mat , i , j ) { let count = 0 ; if ( i > 0 && mat [ i - 1 ] [ j ] == 1 ) count ++ ; if ( j > 0 && mat [ i ] [ j - 1 ] == 1 ) count ++ ; if ( i < R - 1 && mat [ i + 1 ] [ j ] == 1 ) count ++ ; if ( j < C - 1 && mat [ i ] [ j + 1 ] == 1 ) count ++ ; return count ; }
function findperimeter ( mat ) { let perimeter = 0 ; for ( let i = 0 ; i < R ; i ++ ) for ( let j = 0 ; j < C ; j ++ ) if ( mat [ i ] [ j ] == 1 ) perimeter += ( 4 - numofneighbour ( mat , i , j ) ) ; return perimeter ; }
function findRadius ( r1 , r2 , r3 ) { let r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * Math . sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) ; return r4 . toFixed ( 6 ) ; }
function findSides ( A , C , c ) { let B = 180 - ( A + C ) ; A = A * ( 3.14159 / 180 ) ; C = C * ( 3.14159 / 180 ) ; B = B * ( 3.14159 / 180 ) ; let a = ( c / Math . sin ( C ) ) * Math . sin ( A ) ; let b = ( c / Math . sin ( C ) ) * Math . sin ( B ) ; document . write ( a . toPrecision ( 4 ) + "%.2f" ) ; document . write ( b . toPrecision ( 4 ) + "%.2f" ) ; }
function closestsAngle ( N , A ) { let mi = Number . MAX_VALUE ; let ans = 0 ; for ( let i = 1 ; i < N - 1 ; i ++ ) { let angle = 180.0 * i / N ; if ( Math . abs ( angle - A ) < Math . abs ( mi - A ) ) { mi = angle ; ans = i ; } } document . write ( 2 + "▁" + 1 + "▁" + parseInt ( 2 + ans ) ) ; }
function lengthOfLatusRectum ( A , B ) { var major = 2.0 * A ; var minor = 2.0 * B ; var latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
function radius ( a , b , c ) { let g = a / 2 ; let f = b / 2 ; if ( g * g + f * f - c < 0 ) return ( - 1 ) ; return ( Math . sqrt ( g * g + f * f - c ) ) ; }
function centerDistanceFromLine ( a , b , i , j , k ) { let g = a / 2 ; let f = b / 2 ; let distance = Math . abs ( i * g + j * f + k ) / ( Math . sqrt ( i * i + j * j ) ) ; if ( distance < 0 ) return ( - 1 ) ; return distance ; }
function check_position ( a , b , c , d , x1 , y1 , z1 , x2 , y2 , z2 ) { var value_1 = a * x1 + b * y1 + c * z1 + d ; var value_2 = a * x2 + b * y2 + c * z2 + d ; if ( ( value_1 > 0 && value_2 > 0 ) || ( value_1 < 0 && value_2 < 0 ) ) document . write ( "On▁same▁side" ) ; if ( ( value_1 > 0 && value_2 < 0 ) || ( value_1 < 0 && value_2 > 0 ) ) document . write ( "On▁different▁sides" ) ; if ( value_1 == 0 && value_2 == 0 ) document . write ( "Both▁on▁the▁plane" ) ; if ( value_1 == 0 && value_2 != 0 ) document . write ( "Point▁1▁on▁the▁plane" ) ; if ( value_1 != 0 && value_2 == 0 ) document . write ( "Point▁2▁on▁the▁plane" ) ; }
function normal_equation ( a , b , x1 , y1 ) { var slope = normal_slope ( a , b , x1 , y1 ) ; if ( slope == - 1 ) { document . write ( "x▁=▁" + x1 ) ; } if ( slope == - 2 ) { document . write ( "y▁=▁" + y1 ) ; } if ( slope != - 1 && slope != - 2 ) { x1 *= - slope ; x1 += y1 ; if ( x1 > 0 ) document . write ( "y▁=▁" + slope + "x▁+▁" + x1 . toFixed ( 1 ) ) ; else document . write ( "y▁=▁" + slope + "x▁" + x1 . toFixed ( 1 ) ) ; } }
function point_distance ( x1 , y1 , x2 , y2 ) { var p = ( x2 - x1 ) ; var q = ( y2 - y1 ) ; var distance = Math . sqrt ( p * p + q * q ) ; return distance ; }
function check ( C ) { let C1C2 = Math . sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) ; let flag = false ; if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) { if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x && ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) { flag = true ; } } return flag ; }
function IsFairTriplet ( c ) { let f = false ; f |= check ( c ) ; for ( let i = 0 ; i < 2 ; i ++ ) { swap ( c [ 0 ] , c [ 2 ] ) ; f |= check ( c ) ; } return f ; }
function eccHyperbola ( A , B ) { let r = B * B / A * A ; r += 1 ; return Math . sqrt ( r ) ; }
function findInteriorAngle ( n ) { return ( n - 2 ) * PI / n ; }
function findAngle ( M1 , M2 ) { var angle = Math . abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) ; var ret = Math . atan ( angle ) ; var val = ( ret * 180 ) / PI ; document . write ( val . toFixed ( 4 ) ) ; }
function calculateArea ( A , B , C , D ) { let S = ( A + B + C + D ) / 2  let area = Math . sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) )  return area ; }
function angle ( R1 , R2 , D ) { var ans = ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) ; return ans ; }
function triangleArea ( a , b ) { ratio = b / a document . write ( ratio ) }
function countInscribed ( R1 , R2 ) { if ( R2 > R1 ) return 0 ; let angle ; let ratio ; let number_of_circles = 0 ; ratio = R2 / ( R1 - R2 ) ; if ( R1 < 2 * R2 ) { number_of_circles = 1 ; } else { angle = Math . abs ( Math . asin ( ratio ) * 180 ) / 3.14159265 ; number_of_circles = 360 / ( 2 * Math . floor ( angle ) ) ; } return number_of_circles ; }
function distance ( m , n , p , q ) { return Math . sqrt ( Math . pow ( n - m , 2 ) + Math . pow ( q - p , 2 ) * 1.0 ) ; }
function magnitude ( arr , N ) { var magnitude = 0 ; for ( var i = 0 ; i < N ; i ++ ) magnitude += arr [ i ] * arr [ i ] ; return Math . sqrt ( magnitude ) ; }
function dotProduct ( arr , brr , N ) { var product = 0 ; for ( var i = 0 ; i < N ; i ++ ) product = product + arr [ i ] * brr [ i ] ; return product ; }
function angleBetweenVectors ( arr , brr , N ) { var dotProductOfVectors = dotProduct ( arr , brr , N ) ; var magnitudeOfA = magnitude ( arr , N ) ; var magnitudeOfB = magnitude ( brr , N ) ; var angle = dotProductOfVectors / ( magnitudeOfA * magnitudeOfB ) ; document . write ( angle . toFixed ( 6 ) ) ; }
function lengthOfLatusRectum ( A , B ) { var major = 2.0 * A ; var minor = 2.0 * B ; var latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
function totalCircles ( L , B ) { if ( L > B ) { var temp = L ; L = B ; B = temp ; } return B / L ; }
function findSquareSum ( Coordinates , N ) { let xq = 0 , yq = 0 ; let xs = 0 , ys = 0 ; let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let a , b ; a = Coordinates [ i ] [ 0 ] ; b = Coordinates [ i ] [ 1 ] ; res += xq ; res -= 2 * xs * a ; res += i * ( a * a ) ; xq += a * a ; xs += a ; res += yq ; res -= 2 * ys * b ; res += i * b * b ; yq += b * b ; ys += b ; } document . write ( res ) ; }
function findDiagonal ( s ) { return Math . sqrt ( 2 ) * s ; }
function triangleArea ( a , b ) { if ( a < 0 b < 0 ) { document . write ( - 1 ) ; return ; } var area = ( 3 * Math . sqrt ( 3 ) * a * b ) / ( 4 ) ; document . write ( area . toFixed ( 5 ) ) ; }
function maxRowDiff ( mat , m , n ) { let rowSum = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { let sum = 0 ; for ( let j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; } let max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; let min_element = rowSum [ 0 ] ; for ( let i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; }
function distance ( x1 , y1 , x2 , y2 ) { return Math . sqrt ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) ; }
function lengthOfLatusRectum ( a , b , c ) { let vertex = [ ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) ] ; let focus = [ ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) ] ; document . write ( ( 4 * distance ( focus [ 0 ] , focus [ 1 ] , vertex [ 0 ] , vertex [ 1 ] ) ) . toFixed ( 6 ) ) ; }
function doIntersect ( X , Y ) { if ( X [ 0 ] > X [ 3 ] X [ 2 ] > X [ 1 ] ) return false ; if ( Y [ 0 ] > Y [ 3 ] Y [ 2 ] > Y [ 1 ] ) return false ; return true ; }
function getUnionPerimeter ( X , Y ) { let perimeter = 0 ; if ( ! doIntersect ( X , Y ) ) { perimeter += 2 * ( Math . abs ( X [ 1 ] - X [ 0 ] ) + Math . abs ( Y [ 1 ] - Y [ 0 ] ) ) ; perimeter += 2 * ( Math . abs ( X [ 3 ] - X [ 2 ] ) + Math . abs ( Y [ 3 ] - Y [ 2 ] ) ) ; } else { let w = Math . max ( ... X ) - Math . min ( ... X ) ; let l = Math . max ( ... Y ) - Math . min ( ... Y ) ; perimeter = 2 * ( l + w ) ; } return perimeter ; }
function getPointsIns ( x1 , y1 , radius , x2 , y2 , points ) { let ans = 0 ; for ( let i = 0 ; i < points . length ; i ++ ) { let condOne = false , condTwo = false ; if ( ( points [ i ] [ 1 ] - y2 ) * ( x2 - x1 ) - ( y2 - y1 ) * ( points [ i ] [ 0 ] - x2 ) >= 0 ) { condOne = true ; } if ( radius >= Math . sqrt ( Math . pow ( ( y1 - points [ i ] [ 1 ] ) , 2 ) + Math . pow ( x1 - points [ i ] [ 0 ] , 2 ) ) ) { condTwo = true ; } if ( condOne && condTwo ) { ans += 1 ; } } return ans ; }
function Convert ( degree ) { var pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; }
function findRadius ( r1 , r2 ) { let a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = Math . sqrt ( a3 / 3.14 ) ; return r3 ; }
function find_lcm ( a , b , c ) { let g = __gcd ( a , b ) ; let LCM1 = ( a * b ) / g ; g = __gcd ( LCM1 , c ) ; let LCM = ( LCM1 * c ) / g ; return LCM ; }
function minimumCuboids ( L , B , H ) { let lcm = find_lcm ( L , B , H ) ; let volume_cube = lcm * lcm * lcm ; let volume_cuboid = L * B * H ; document . write ( ( volume_cube / volume_cuboid ) ) ; }
function distance ( p1 , p2 ) { var x1 = p1 [ 0 ] , x2 = p2 [ 0 ] ; var y1 = p1 [ 1 ] , y2 = p2 [ 1 ] ; return Math . sqrt ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) * 1.0 ) ; }
function CrossProduct ( A ) { var X1 = ( A [ 1 ] [ 0 ] - A [ 0 ] [ 0 ] ) ; var Y1 = ( A [ 1 ] [ 1 ] - A [ 0 ] [ 1 ] ) ; var X2 = ( A [ 2 ] [ 0 ] - A [ 0 ] [ 0 ] ) ; var Y2 = ( A [ 2 ] [ 1 ] - A [ 0 ] [ 1 ] ) ; return ( X1 * Y2 - Y1 * X2 ) ; }
function isConvex ( points ) { var N = points . length ; var prev = 0 ; var curr = 0 ; for ( i = 0 ; i < N ; i ++ ) { var temp = [ points [ i ] , points [ ( i + 1 ) % N ] , points [ ( i + 2 ) % N ] ] ; curr = CrossProduct ( temp ) ; if ( curr != 0 ) { if ( curr * prev < 0 ) { return false ; } else { prev = curr ; } } } return true ; }
function cntRect ( points , N , rectangle ) { var cntHor = new Set ( ) ; var cntVer = new Set ( ) ; cntHor . add ( 0 ) ; cntVer . add ( 0 ) ; cntHor . add ( rectangle [ 3 ] [ 0 ] ) ; cntVer . add ( rectangle [ 3 ] [ 1 ] ) ; for ( var i = 0 ; i < N ; i ++ ) { cntHor . add ( points [ i ] [ 0 ] ) ; cntVer . add ( points [ i ] [ 1 ] ) ; } return ( cntHor . size - 1 ) * ( cntVer . size - 1 ) ; }
function numberOfSquares ( X , Y , N , M ) { var m1 = new Map ( ) , m2 = new Map ( ) ; var i , j , ans = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { var dist = Math . abs ( X [ i ] - X [ j ] ) ; if ( m1 . has ( dist ) ) m1 . set ( dist , m1 . get ( dist ) + 1 ) else m1 . set ( dist , 1 ) ; } } for ( i = 0 ; i < M ; i ++ ) { for ( j = i + 1 ; j < M ; j ++ ) { var dist = Math . abs ( Y [ i ] - Y [ j ] ) ; if ( m2 . has ( dist ) ) m2 . set ( dist , m2 . get ( dist ) + 1 ) else m2 . set ( dist , 1 ) ; } } m1 . forEach ( ( value , key ) => { if ( m2 . has ( key ) ) { ans += ( value * m2 . get ( key ) ) ; } } ) ; return ans ; }
function Area_Parallelogram1 ( a , b , theta ) { let area = ( Math . abs ( Math . tan ( toRadians ( theta ) ) ) / 2 ) * Math . abs ( a * a - b * b ) ; return area ; }
function Area_Parallelogram3 ( d1 , d2 , theta ) { let area = ( Math . abs ( Math . sin ( toRadians ( theta ) ) ) / 2 ) * Math . abs ( d1 * d2 ) ; return area ; }
function noOfTriangles ( n ) { return Math . floor ( n * ( n + 2 ) * ( 2 * n + 1 ) / 8 ) ; }
function No_of_squares ( N , K ) { let no_of_squares = 0 ; no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) ; return no_of_squares ; }
function checkTriangle ( x , y , z ) { if ( x == y && y == z ) document . write ( "Equilateral▁Triangle" ) ; else if ( x == y y == z z == x ) document . write ( "Isosceles▁Triangle" ) ; else document . write ( "Scalene▁Triangle" ) ; }
function getTotalCoverageOfMatrix ( mat ) { let res = 0 ; for ( let i = 0 ; i < R ; i ++ ) { let isOne = false ; for ( let j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } isOne = false ; for ( let j = C - 1 ; j >= 0 ; j -- ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } } for ( let j = 0 ; j < C ; j ++ ) { let isOne = false ; for ( let i = 0 ; i < R ; i ++ ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } isOne = false ; for ( let i = R - 1 ; i >= 0 ; i -- ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } } return res ; }
function Circumradius ( a , b , c , d ) { var s = ( a + b + c + d ) / 2.0 ; var radius = Math . sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) ; return radius / 4 ; }
function calculateTriangles ( sides ) { let count = Math . pow ( sides [ 0 ] + sides [ 1 ] + sides [ 2 ] , 2 ) ; count -= Math . pow ( sides [ 0 ] , 2 ) ; count -= Math . pow ( sides [ 2 ] , 2 ) ; count -= Math . pow ( sides [ 4 ] , 2 ) ; return ( count ) ; }
function Length_Diagonal ( a , b , theta ) { var diagonal = Math . sqrt ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) - 2 * a * b * Math . cos ( theta * ( Math . PI / 180 ) ) ) ; return diagonal ; }
function maximumTiles ( n , m ) { document . write ( ( m * n ) / 2 ) ; }
function Length_Diagonal ( a , b , d ) { let diagonal = Math . sqrt ( 2 * ( ( a * a ) + ( b * b ) ) - ( d * d ) ) ; return diagonal ; }
function Diagonals ( a , b , c , d ) { var p = parseFloat ( Math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) ) ; var q = parseFloat ( Math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) ) ; return [ p , q ] ; }
function find ( x , y , p ) { let mind = 0 ; for ( let i = 0 ; i < p . length ; i ++ ) { let a = p [ i ] [ 0 ] , b = p [ i ] [ 1 ] ; mind += Math . sqrt ( ( x - a ) * ( x - a ) + ( y - b ) * ( y - b ) ) ; } return mind ; }
function getMinDistSum ( p ) { let x = 0 , y = 0 ; for ( let i = 0 ; i < p . length ; i ++ ) { x += p [ i ] [ 0 ] ; y += p [ i ] [ 1 ] ; } x = x / p . length ; y = y / p . length ; let mind = find ( x , y , p ) ; return mind ; }
function det ( d ) { let Sum = d [ 0 ] [ 0 ] * ( ( d [ 1 ] [ 1 ] * d [ 2 ] [ 2 ] ) - ( d [ 2 ] [ 1 ] * d [ 1 ] [ 2 ] ) ) ; Sum -= d [ 0 ] [ 1 ] * ( ( d [ 1 ] [ 0 ] * d [ 2 ] [ 2 ] ) - ( d [ 1 ] [ 2 ] * d [ 2 ] [ 0 ] ) ) ; Sum += d [ 0 ] [ 2 ] * ( ( d [ 0 ] [ 1 ] * d [ 1 ] [ 2 ] ) - ( d [ 0 ] [ 2 ] * d [ 1 ] [ 1 ] ) ) ; return Sum ; }
function distance ( r , R ) { let d = Math . sqrt ( Math . pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function replacematrix ( mat , n , m ) { let rgcd = new Array ( R ) ; rgcd . fill ( 0 ) ; let cgcd = new Array ( C ) ; cgcd . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] ) ; cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] ) ; } } for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) mat [ i ] [ j ] = Math . max ( rgcd [ i ] , cgcd [ j ] ) ; }
function areaOfSquare ( S ) { let area = S * S ; return area ; }
function isAllKs ( n , b , k ) { var len = findNumberOfDigits ( n , b ) ; var sum = k * ( 1 - Math . pow ( b , len ) ) / ( 1 - b ) ; if ( sum == n ) { return ( sum ) ; } }
function checkRightAngled ( X1 , Y1 , X2 , Y2 , X3 , Y3 ) { var A = Math . pow ( X2 - X1 , 2 ) + Math . pow ( Y2 - Y1 , 2 ) ; var B = Math . pow ( X3 - X2 , 2 ) + Math . pow ( Y3 - Y2 , 2 ) ; var C = Math . pow ( X3 - X1 , 2 ) + Math . pow ( Y3 - Y1 , 2 ) ; if ( A > 0 && B > 0 && C > 0 && ( A === B + C B === A + C C === A + B ) ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function checkValidPolygon ( arr , N ) { var sum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 180 * ( N - 2 ) ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function minAnglRot ( N ) { let res ; res = 360 / N ; return res ; }
function maxPointOfIntersection ( x , y ) { let k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
function sortedCount ( mat , r , c ) { let result = 0 ; for ( let i = 0 ; i < r ; i ++ ) { let j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( let i = 0 ; i < r ; i ++ ) { let j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; }
function Area_of_Triangle ( a , b , c ) { var s = ( a + b + c ) / 2 ; var x = s * ( s - a ) ; x = x * ( s - b ) ; x = x * ( s - c ) ; var area = ( 4 / 3 ) * Math . sqrt ( x ) ; return area ; }
function Area_of_Triangle ( a , b , k ) { var area = ( ( 1 / 2.0 ) * a * b * Math . sin ( k ) ) ; return area ; }
function findAreaCovered ( ) { let area = 0 ; for ( let i = 0 ; i < MAX ; i ++ ) { for ( let j = 0 ; j < MAX ; j ++ ) { if ( arr [ i ] [ j ] == true ) { area ++ ; } } } return area ; }
function findEquation ( x1 , y1 , z1 , x2 , y2 , z2 , d , e , f ) { var a = x2 - x1 ; var b = y2 - y1 ; var c = z2 - z1 ; var A = parseInt ( ( b * f - c * e ) ) ; var B = parseInt ( ( a * f - c * d ) ) ; var C = parseInt ( ( a * e - b * d ) ) ; var D = - parseInt ( ( A * d - B * e + C * f ) ) ; document . write ( A + "x▁+▁" + B + "y▁+▁" + C + "z▁+▁" + D + "=▁0" ) ; }
function createPrefixArray ( n , arr , prefSize , pref ) { for ( let i = 0 ; i < prefSize ; i ++ ) { pref [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { let x = arr [ i ] + 1000000 ; pref [ x ] ++ ; } for ( let i = 1 ; i < prefSize ; i ++ ) { pref [ i ] += pref [ i - 1 ] ; } }
function count_rectangles ( N , M ) { let p_x = ( N * ( N - 1 ) ) / 2 ; let p_y = ( M * ( M - 1 ) ) / 2 ; return p_x * p_y ; }
function median ( a , b , c ) { let n = ( Math . sqrt ( 2 * b * b + 2 * c * c - a * a ) / 2 ) ; return n ; }
function fact ( n ) { let res = 1 ; for ( let i = 2 ; i < n + 1 ; i ++ ) res = res * i ; return res ; }
function circleArea ( r ) { var pi = 3.14159265358979323846 ; return ( pi * r * r ) ; }
function findCircleAreaByMedian ( m ) { var r = 2 * m / 3 ; return circleArea ( r ) ; }
function areaSquare ( L , B ) { let large = Math . max ( L , B ) ; let small = Math . min ( L , B ) ; if ( large >= 2 * small ) { return large * large ; } else { return ( 2 * small ) * ( 2 * small ) ; } }
function nGon ( N ) { let proAngleVar ; if ( N % 4 == 0 ) { proAngleVar = pi * ( 180.0 / N ) / 180 ; } else { proAngleVar = pi * ( 180.0 / ( 2 * N ) ) / 180 ; } let negX = 1.0e+99 , posX = - 1.0e+99 , negY = 1.0e+99 , posY = - 1.0e+99 ; for ( let j = 0 ; j < N ; ++ j ) { let px = Math . cos ( 2 * pi * j / N + proAngleVar ) ; let py = Math . sin ( 2 * pi * j / N + proAngleVar ) ; negX = Math . min ( negX , px ) ; posX = Math . max ( posX , px ) ; negY = Math . min ( negY , py ) ; posY = Math . max ( posY , py ) ; } let opt2 = Math . max ( posX - negX , posY - negY ) ; return opt2 / Math . sin ( pi / N ) / 2 ; }
function cal_cos ( n ) { var accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = Math . cos ( n ) ; var i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . abs ( cosval - cosx ) ) ; return cosx ; }
function triacontagonalNum ( n ) { return ( 28 * n * n - 26 * n ) / 2 ; }
function hexacontagonNum ( n ) { return ( 58 * n * n - 56 * n ) / 2 ; }
function isicositetragonal ( N ) { var n = ( 10 + Math . sqrt ( 44 * N + 100 ) ) / 22 ; return ( n - parseInt ( n ) ) == 0 ; }
function enneacontagonNum ( n ) { return ( 88 * n * n - 86 * n ) / 2 ; }
function triacontakaidigonNum ( n ) { return ( 30 * n * n - 28 * n ) / 2 ; }
function maxXOR ( mat , N ) { let r_xor , c_xor ; let max_xor = 0 ; for ( let i = 0 ; i < N ; i ++ ) { r_xor = 0 , c_xor = 0 ; for ( let j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ; } return max_xor ; }
function isTridecagon ( N ) { var n = ( 9 + Math . sqrt ( 88 * N + 81 ) ) / 22 ; return ( n - parseInt ( n ) ) == 0 ; }
function isicosihenagonal ( N ) { var n = ( 17 + Math . sqrt ( 152 * N + 289 ) ) / 38 ; return ( n - parseInt ( n ) ) == 0 ; }
function isicositrigonal ( N ) { var n = ( 19 + Math . sqrt ( 168 * N + 361 ) ) / 42 ; return ( n - parseInt ( n ) ) == 0 ; }
function IcosihexagonalNum ( n ) { return ( 24 * n * n - 22 * n ) / 2 ; }
function icosikaioctagonalNum ( n ) { return ( 26 * n * n - 24 * n ) / 2 ; }
function hectagonNum ( n ) { return ( 98 * n * n - 96 * n ) / 2 ; }
function tetracontagonNum ( n ) { return ( 38 * n * n - 36 * n ) / 2 ; }
function Tridecagonal_num ( n ) { return ( 11 * n * n - 9 * n ) / 2 ; }
function Octadecagonal_num ( n ) { return ( 16 * n * n - 14 * n ) / 2 ; }
function Icositetragonal_num ( n ) { return ( 22 * n * n - 20 * n ) / 2 ; }
function Icosihenagonal_num ( n ) { return ( 19 * n * n - 17 * n ) / 2 ; }
function checkTriangle ( x1 , y1 , x2 , y2 , x3 , y3 ) { let a = x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ; if ( a == 0 ) document . write ( "No" ) ; else document . write ( "Yes" ) ; }
function numTrip ( points ) { let res = 0 ; for ( let i = 0 ; i < points . length ; ++ i ) { let map = new Map ( ) ; for ( let j = 0 ; j < points . length ; ++ j ) { if ( j == i ) continue ; let dy = points [ i ] [ 1 ] - points [ j ] [ 1 ] ; let dx = points [ i ] [ 0 ] - points [ j ] [ 0 ] ; let key = dy * dy ; key += dx * dx ; if ( map . has ( key ) ) { map . set ( key , map . get ( key ) + 1 ) ; } else { map . set ( key , 1 ) ; } } for ( let [ key , value ] of map . entries ( ) ) res += value * ( value - 1 ) ; } return res ; }
function checkOverlap ( R , Xc , Yc , X1 , Y1 , X2 , Y2 ) { let Xn = Math . max ( X1 , Math . min ( Xc , X2 ) ) ; let Yn = Math . max ( Y1 , Math . min ( Yc , Y2 ) ) ; let Dx = Xn - Xc ; let Dy = Yn - Yc ; return ( Dx * Dx + Dy * Dy ) <= R * R ; }
function area_of_circle ( m , n ) { var square_of_radius = ( m * n ) / 4 ; var area = ( 3.141 * square_of_radius ) ; return area ; }
function direction ( R , C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) { document . write ( "Left" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) { document . write ( "Up" ) ; return ; } if ( R == C && R % 2 != 0 && C % 2 != 0 ) { document . write ( "Right" ) ; return ; } if ( R == C && R % 2 == 0 && C % 2 == 0 ) { document . write ( "Left" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { document . write ( "Right" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) { document . write ( "Down" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) { document . write ( "Left" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) { document . write ( "Up" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) { document . write ( "Down" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) { document . write ( "Right" ) ; return ; } }
function checkIntersection ( p1 , p2 , p ) { let val ; if ( p1 [ 1 ] == p2 [ 1 ] && p1 [ 1 ] == p [ 1 ] ) { if ( p [ 0 ] <= Math . max ( p1 [ 0 ] , p2 [ 0 ] ) && ( p [ 0 ] >= Math . min ( p1 [ 0 ] , p2 [ 0 ] ) ) ) return 1 ; } if ( p1 [ 0 ] == p2 [ 0 ] && p1 [ 0 ] == p [ 0 ] ) { if ( p [ 1 ] <= Math . max ( p1 [ 1 ] , p2 [ 1 ] ) && ( p [ 1 ] >= Math . min ( p1 [ 1 ] , p2 [ 1 ] ) ) ) return 1 ; } else { val = ( p [ 1 ] - p1 [ 1 ] ) * ( p2 [ 0 ] - p1 [ 0 ] ) - ( p [ 0 ] - p1 [ 0 ] ) * ( p2 [ 1 ] - p1 [ 1 ] ) ; if ( val == 0 ) if ( ( p [ 0 ] <= Math . max ( p1 [ 0 ] , p2 [ 0 ] ) && ( p [ 0 ] >= Math . min ( p1 [ 0 ] , p2 [ 0 ] ) ) ) && ( p [ 1 ] <= Math . max ( p1 [ 1 ] , p2 [ 1 ] ) && ( p [ 1 ] >= Math . min ( p1 [ 1 ] , p2 [ 1 ] ) ) ) ) return 1 ; } return 0 ; }
function towerOfSight ( a , b , c , d ) { let flag = 0 ; if ( checkIntersection ( a , c , b ) == 1 ) flag = 1 ; else if ( checkIntersection ( a , c , d ) == 1 ) flag = 1 ; else if ( checkIntersection ( b , d , a ) == 1 ) flag = 1 ; else if ( checkIntersection ( b , d , c ) == 1 ) flag = 1 ; document . write ( flag == 1 ? "Yes\n" : "No\n" ) ; }
function NotParallel ( p , n ) { var x_axis = new Map ( ) , y_axis = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( x_axis . has ( p [ i ] [ 0 ] ) ) x_axis . set ( p [ i ] [ 0 ] , x_axis . get ( p [ i ] [ 0 ] ) + 1 ) else x_axis . set ( p [ i ] [ 0 ] , 1 )  if ( y_axis . has ( p [ i ] [ 1 ] ) ) y_axis . set ( p [ i ] [ 1 ] , y_axis . get ( p [ i ] [ 1 ] ) + 1 ) else y_axis . set ( p [ i ] [ 1 ] , 1 ) } var total = ( n * ( n - 1 ) ) / 2 ; x_axis . forEach ( ( value , key ) => { var c = value ; total -= ( c * ( c - 1 ) ) / 2 ; } ) ; y_axis . forEach ( ( value , key ) => { var c = value ; total -= ( c * ( c - 1 ) ) / 2 ; } ) ; return total ; }
function checkTypeOfTriangle ( a , b , c ) { let sqa = Math . floor ( Math . pow ( a , 2 ) ) ; let sqb = Math . floor ( Math . pow ( b , 2 ) ) ; let sqc = Math . floor ( Math . pow ( c , 2 ) ) ; if ( sqa == sqa + sqb sqb == sqa + sqc sqc == sqa + sqb ) { document . write ( "Right-angled▁Triangle" ) ; } else if ( sqa > sqc + sqb sqb > sqa + sqc sqc > sqa + sqb ) { document . write ( "Obtuse-angled▁Triangle" ) ; } else { document . write ( "Acute-angled▁Triangle" ) ; } }
function lineFromPoints ( P , Q , a , b , c ) { a = Q . y - P . y ; b = P . x - Q . x ; c = a * ( P . x ) + b * ( P . y ) ; }
function LineInterX ( a1 , b1 , c1 , a2 , b2 , c2 ) { let determ = a1 * b2 - a2 * b1 ; let x = ( b2 * c1 - b1 * c2 ) ; x /= determ ; return x ; }
function LineInterY ( a1 , b1 , c1 , a2 , b2 , c2 ) { let determ = a1 * b2 - a2 * b1 ; let y = ( a1 * c2 - a2 * c1 ) ; y /= determ ; return y ; }
function findPosition ( P , Q , R , D ) { let r = new point ( ) ; let a = 0 , b = 0 , c = 0 ; lineFromPoints ( P , Q , a , b , c ) ; let e = 0 , f = 0 , g = 0 ; lineFromPoints ( Q , R , e , f , g ) ; perpenBisectorFromLine ( P , Q , a , b , c ) ; perpenBisectorFromLine ( Q , R , e , f , g ) ; r . x = LineInterX ( a , b , c , e , f , g ) ; r . y = LineInterY ( a , b , c , e , f , g ) ; let q = ( r . x - P . x ) * ( r . x - P . x ) + ( r . y - P . y ) * ( r . y - P . y ) ; let dis = ( r . x - D . x ) * ( r . x - D . x ) + ( r . y - D . y ) * ( r . y - D . y ) ; if ( dis < q ) { document . write ( "Point▁(" + D . x + ",▁" + D . y + ")▁is▁inside▁" + "the▁circumcircle" ) ; } else if ( dis == q ) { document . write ( "Point▁(" + D . x + ",▁" + D . y + ")▁lies▁on▁the▁" + "circumcircle" ) ; } else { document . write ( "Point▁(" + D . x + ",▁" + D . y + ")▁lies▁outside" + "▁the▁circumcircle" ) ; } }
function disp ( row_no , block ) { document . write ( row_no * block ) ; }
function row ( ht , h ) { return ht / h ; }
function calculate ( l , w , h , a , ht ) { let no_block = ( 4 * a ) / l ; let row_no ; if ( h < w ) row_no = row ( ht , w ) ; else row_no = row ( ht , h ) ; disp ( row_no , no_block ) ; }
function solve ( s ) { let area = ( 1.732 * Math . pow ( s , 2 ) ) / 8 ; return area ; }
function area ( R ) { var base = 1.732 * R ; var height = ( 1.5 ) * R ; var area = 0.5 * base * height ; return area ; }
function spiralPrint ( m , n , a , c ) { let i , k = 0 , l = 0 ; let count = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { count ++ ; if ( count == c ) document . write ( a [ k ] [ i ] + "▁" ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { count ++ ; if ( count == c ) document . write ( a [ i ] [ n - 1 ] + "▁" ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { count ++ ; if ( count == c ) document . write ( a [ m - 1 ] [ i ] + "▁" ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { count ++ ; if ( count == c ) document . write ( a [ i ] [ l ] + "▁" ) ; } l ++ ; } } }
function find_Area ( a ) { var R = a * ( 2.0 - Math . sqrt ( 2 ) ) ; var area = 3.14 * R * R / 2.0 ; return area ; }
function times ( steps , n ) { let current_level = 0 ; let previous_level = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { previous_level = current_level ; current_level = current_level + steps [ i ] ; if ( ( previous_level < 0 && current_level >= 0 ) || ( previous_level > 0 && current_level <= 0 ) ) { count ++ ; } } return count ; }
function solve ( n , m , obstacles , range ) { var val = Math . min ( n , m ) ; range . sort ( ( a , b ) => a - b )  var c = 1 ; for ( var i = obstacles - 1 ; i >= 0 ; i -- ) { range [ i ] = 2 * range [ i ] ; val -= range [ i ] ; if ( val <= 0 ) { return c ; } else { c ++ ; } } if ( val > 0 ) { return - 1 ; } }
function equation_plane ( p , q , r ) { let x1 = p [ 0 ] ; let y1 = p [ 1 ] ; let z1 = p [ 2 ] ; let x2 = q [ 0 ] ; let y2 = q [ 1 ] ; let z2 = q [ 2 ] ; let x3 = r [ 0 ] ; let y3 = r [ 1 ] ; let z3 = r [ 2 ] ; let a1 = x2 - x1 ; let b1 = y2 - y1 ; let c1 = z2 - z1 ; let a2 = x3 - x1 ; let b2 = y3 - y1 ; let c2 = z3 - z1 ; let A = b1 * c2 - b2 * c1 ; let B = a2 * c1 - a1 * c2 ; let C = a1 * b2 - b1 * a2 ; let D = ( - A * x1 - B * y1 - C * z1 ) ; let rslt = XandYandZintercept ( A , B , C , D ) ; for ( let i = 0 ; i < 3 ; i ++ ) { document . write ( rslt [ i ] + "▁" ) ; } }
function countPairs ( P , Q , N , M ) { var A = [ 0 , 0 ] , B = [ 0 , 0 ] ; for ( var i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( var i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; }
function find_angle ( x , y , z ) { var volume = x * x * y ; var ans = 0 ; if ( z < volume / 2 ) { var d = ( ( x * y * y ) / ( 2.0 * z ) ) ; ans = Math . atan ( d ) ; } else { z = volume - z ; var d = ( 2 * z ) / ( x * x * x ) ; ans = Math . atan ( d ) ; } ans = ( ( ans * 180 ) / 3.14159265 ) ; return ans ; }
function FindPoints ( n ) { var v = [ ] ; v . push ( [ 0 , 0 ] ) ; v . push ( [ 0 , n ] ) ; v . push ( [ n , 0 ] ) ; v . push ( [ n , n ] ) ; if ( n % 2 == 0 ) v . push ( [ n / 2 , n / 2 ] ) ; return v ; }
function findsolution ( d , h , m , n ) { var k = ( 4 * m ) / ( pie * d * d ) ; if ( n > k ) return - 1 ; var ans = ( h / ( k - n ) ) ; return ans ; }
function find_Centroid ( v ) { let ans = new Array ( 2 ) ; ans . fill ( 0 ) ; let n = v . length ; let signedArea = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let x0 = v [ i ] [ 0 ] , y0 = v [ i ] [ 1 ] ; let x1 = v [ ( i + 1 ) % n ] [ 0 ] , y1 = v [ ( i + 1 ) % n ] [ 1 ] ; let A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) ; ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) ; return ans ; }
function sumOfInternalAngles ( n ) { if ( n < 3 ) return 0 ; return ( n - 2 ) * 180 ; }
function cntWays ( n ) { if ( n % 2 == 1 ) { return 0 ; } else { return ( n - 2 ) / 4 ; } }
function noOfTriangles ( n ) { var y = 4 * n ; return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) / 6 ; }
function angle ( n ) { return 2 * n ; }
function checkDiagonal ( mat , i , j ) { let res = mat [ i ] [ j ] ; while ( ++ i < N && ++ j < M ) { if ( mat [ i ] [ j ] != res ) return false ; } return true ; }
function ifRight ( x1 , y1 , x2 , y2 , x3 , y3 ) { let a = ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ; let b = ( ( x1 - x3 ) * ( x1 - x3 ) ) + ( ( y1 - y3 ) * ( y1 - y3 ) ) ; let c = ( ( x2 - x3 ) * ( x2 - x3 ) ) + ( ( y2 - y3 ) * ( y2 - y3 ) ) ; if ( ( a == ( b + c ) && a != 0 && b != 0 && c != 0 ) || ( b == ( a + c ) && a != 0 && b != 0 && c != 0 ) || ( c == ( a + b ) && a != 0 && b != 0 && c != 0 ) ) { return 1 ; } return 0 ; }
function isValidCombination ( x1 , y1 , x2 , y2 , x3 , y3 ) { let x , y ; let possible = 0 ; if ( ifRight ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { document . write ( "ALREADY▁RIGHT▁ANGLED" ) ; return ; } else { for ( let i = 0 ; i < 4 ; i ++ ) { x = dx [ i ] + x1 ; y = dy [ i ] + y1 ; if ( ifRight ( x , y , x2 , y2 , x3 , y3 ) ) { document . write ( "POSSIBLE" ) ; return ; } x = dx [ i ] + x2 ; y = dy [ i ] + y2 ; if ( ifRight ( x1 , y1 , x , y , x3 , y3 ) ) { document . write ( "POSSIBLE" ) ; return ; } x = dx [ i ] + x3 ; y = dy [ i ] + y3 ; if ( ifRight ( x1 , y1 , x2 , y2 , x , y ) ) { document . write ( "POSSIBLE" ) ; return ; } } } if ( ! possible ) document . write ( "NOT▁POSSIBLE" ) ; }
function area_of_regular_polygon ( n , len ) { let P = ( len * n ) ; let A = len / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; let area = ( P * A ) / 2 ; return area ; }
function area_of_triangle_inscribed ( n , len ) { let area = area_of_regular_polygon ( n , len ) ; let triangle = area / n ; let ins_tri = ( triangle * 3 ) ; return ins_tri ; }
function maxRegions ( n ) { let num ; num = parseInt ( n * ( n + 1 ) / 2 ) + 1 ; document . write ( num ) ; }
function pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) { fx1 = a * x1 + b * y1 - c ; fx2 = a * x2 + b * y2 - c ; if ( ( fx1 * fx2 ) > 0 ) return true ; return false ; }
function Area ( d , h1 , h2 ) { let area ; area = 0.5 * d * ( h1 + h2 ) ; return area ; }
function diagonal_length ( a ) { let L ; L = a * Math . sqrt ( 3 ) ; return L ; }
function find_area ( r , d ) { let R = d / PI ; R += Math . pow ( r , 2 ) ; R = Math . sqrt ( R ) ; let area = PI * Math . pow ( R , 2 ) ; return area ; }
function Valid ( a , b , c , d ) { if ( a + b + c + d == 360 ) return 1 ; return 0 ; }
function Valid ( a , b , c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; }
function calculate_angle ( n ) { var total_angle = 360 ; return total_angle / n ; }
function areaOfKite ( a , b , angle ) { angle = angle * PI ; var area = a * b * Math . sin ( angle ) ; return area . toFixed ( 4 ) ; }
function angleOncirCumference ( z ) { return ( z / 2 ) ; }
function newvol ( x ) { document . write ( "percentage▁increase▁" + "in▁the▁volume▁of▁the▁cube▁is▁" + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + "%" ) ; }
function newvol ( x ) { document . write ( "percentage▁increase▁in▁the" + "▁volume▁of▁the▁sphere▁is▁" + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + "%" ) ; }
function countZeroes ( mat ) { let row = N - 1 , col = 0 ; let count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }
function newvol ( x ) { document . write ( "percentage▁increase▁" + "in▁the▁volume▁of▁the▁cylinder▁is▁" + x + "%" ) ; }
function radius ( n , d ) { document . write ( "The▁side▁of▁each▁square▁is▁" + ( d / ( ( n - 1 ) * Math . sqrt ( 2 ) ) ) . toFixed ( 5 ) ) ; }
function findTriangles ( n ) { var num = n ; document . write ( num + "▁" ) ; document . write ( num * ( num - 4 ) * ( num - 5 ) / 6 ) ; }
function radius ( n , d ) { document . write ( "The▁radius▁of▁each▁circle▁is▁" + d / ( 2 * n - 2 ) ) ; }
function radius ( n , d ) { document . write ( "The▁side▁of▁each▁square▁is▁" + d / ( n - 1 ) ) ; }
function innerCirclearea ( radius ) { if ( radius < 0 ) { return - 1 ; } let r = radius / 2 ; let Area = ( 3.14 * Math . pow ( r , 2 ) ) ; return Area ; }
function areaOfTriangle ( d ) { var c = 1.618 * d ; var s = ( d + c + c ) / 2 ; var area = Math . sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) ; return 5 * area ; }
function areaOfRegPentagon ( d ) { var cal = 4 * Math . tan ( PI / 5 ) ; var area = ( 5 * d * d ) / cal ; return area ; }
function areaOfPentagram ( d ) { return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) ; }
function lengperpbisect ( r1 , r2 ) { var z = 2 * Math . sqrt ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ; document . write ( "The▁length▁of▁the▁" + "perpendicular▁bisector▁is▁" + z . toFixed ( 5 ) ) ; }
function anglequichord ( z ) { document . write ( "The▁angle▁is▁" + z + "▁degrees" ) ; }
function lengchord ( z ) { document . write ( "The▁length▁is▁" + z ) ; }
function angleextcycquad ( z ) { document . write ( "The▁exterior▁angle▁of▁the" + "▁cyclic▁quadrilateral▁is▁" + z + "▁degrees" ) ; }
function anglechordtang ( z ) { document . write ( "The▁angle▁between▁tangent" + "▁and▁the▁chord▁is▁" + z + "▁degrees" ) ; }
function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { var distSq = parseInt ( Math . sqrt ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ) ; if ( distSq + r2 == r1 ) { document . write ( "The▁smaller▁circle▁lies▁completely" + "▁inside▁the▁bigger▁circle▁with▁" + "touching▁each▁other▁" + "at▁a▁point▁of▁circumference.▁" ) ; } else if ( distSq + r2 < r1 ) { document . write ( "The▁smaller▁circle▁lies▁completely" + "▁inside▁the▁bigger▁circle▁without" + "▁touching▁each▁other▁" + "at▁a▁point▁of▁circumference.▁" ) ; } else { document . write ( "The▁smaller▁does▁not▁lies▁inside" + "▁the▁bigger▁circle▁completely." ) ; } }
function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { var distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; var radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
function countOdd ( n ) { let coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i >= 1 ) { m = parseInt ( ( n - i ) / 2 , 10 ) ; j = parseInt ( ( i * ( i + 1 ) ) / 2 , 10 ) ; coun += j * m ; } else { m = parseInt ( ( ( n - 1 ) - i ) / 2 , 10 ) ; j = parseInt ( ( i * ( i + 1 ) ) / 2 , 10 ) ; coun += j * m ; } } return coun ; }
function countEven ( n ) { let coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i >= 1 ) { m = parseInt ( ( ( n - 1 ) - i ) / 2 , 10 ) ; j = parseInt ( ( i * ( i + 1 ) ) / 2 , 10 ) ; coun += j * m ; } else { m = parseInt ( ( n - i ) / 2 , 10 ) ; j = parseInt ( ( i * ( i + 1 ) ) / 2 , 10 ) ; coun += j * m ; } } return coun ; }
function countNegative ( M , n , m ) { let count = 0 ; let i = 0 ; let j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }
function GCD ( a , b ) { return ( b != 0 ? GCD ( b , a % b ) : a ) ; }
function ratiotang ( r1 , r2 ) { document . write ( "The▁ratio▁is▁" + r1 / GCD ( r1 , r2 ) + ":" + r2 / GCD ( r1 , r2 ) ) ; }
function Regions ( Vertices , Edges ) { var R = Edges + 2 - Vertices ; return R ; }
function ratiotang ( r1 , r2 ) { document . write ( "The▁ratio▁is▁" + r1 / GCD ( r1 , r2 ) + "▁:▁" + r2 / GCD ( r1 , r2 ) ) ; }
function lengthOfTangent ( r1 , r2 , d ) { document . write ( "The▁length▁of▁the▁transverse" + "▁common▁tangent▁is▁" + Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 + r2 ) , 2 ) ) ) ; }
function remainingArea ( N , M , K ) { while ( K -- && N && M ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }
function lengtang ( r1 , r2 , d ) { document . write ( "The▁length▁of▁the▁direct" + "▁common▁tangent▁is▁" + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) . toFixed ( 5 ) ) ; }
function rad ( d , h ) { document . write ( "The▁radius▁of▁the▁circle▁is▁" + ( ( d * d ) / ( 8 * h ) + h / 2 ) ) ; }
function lengtang ( r1 , r2 ) { document . write ( "The▁length▁of▁the▁" + "direct▁common▁tangent▁is▁" + ( 2 * Math . sqrt ( r1 * r2 ) ) . toFixed ( 5 ) ) ; }
function diameter ( r ) { document . write ( "The▁length▁of▁the▁longest▁chord" + "▁or▁diameter▁of▁the▁circle▁is▁" + 2 * r ) ; }
function dist ( m , b1 , b2 ) { var d = Math . abs ( b2 - b1 ) / ( ( m * m ) - 1 ) ; return d ; }
function getSlope ( m ) { return m ; }
function totalTriangles ( h , v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; var total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; }
function findLargestPlus ( mat ) { let left = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { left [ i ] = new Array ( N ) ; } let right = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { right [ i ] = new Array ( N ) ; } let top = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { top [ i ] = new Array ( N ) ; } let bottom = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { bottom [ i ] = new Array ( N ) ; } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { left [ i ] [ j ] = 0 ; right [ i ] [ j ] = 0 ; top [ i ] [ j ] = 0 ; bottom [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } let n = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { let len = Math . min ( Math . min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , Math . min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ; if ( len > n ) n = len ; } } if ( n > 0 ) return 4 * ( n - 1 ) + 1 ; return 0 ; }
function noOfSquares ( x1 , y1 , x2 , y2 ) { var dx = Math . abs ( x2 - x1 ) ; var dy = Math . abs ( y2 - y1 ) ; var ans = dx + dy - __gcd ( dx , dy ) ; document . write ( ans ) ; }
function countSteps ( x , y ) { if ( x < y ) { return x + y + 2 * parseInt ( ( y - x ) / 2 ) ; } else { return x + y + 2 * parseInt ( ( ( x - y ) + 1 ) / 2 ) ; } }
function isSlopeGood ( slope , arr , n ) { var setOfLines = new Set ( ) ; for ( var i = 0 ; i < n ; i ++ ) setOfLines . add ( arr [ i ] - slope * ( i ) ) ; return setOfLines . size == 2 ; }
function checkForParallel ( arr , n ) { var slope1 = isSlopeGood ( arr [ 1 ] - arr [ 0 ] , arr , n ) ; var slope2 = isSlopeGood ( arr [ 2 ] - arr [ 1 ] , arr , n ) ; var slope3 = isSlopeGood ( parseInt ( ( arr [ 2 ] - arr [ 0 ] ) / 2 ) , arr , n ) ; if ( slope1 slope2 slope3 ) { return 1 ; } return 0 ; }
function countPaths ( x1 , y1 , x2 , y2 ) { var m = Math . abs ( x1 - x2 ) ; var n = Math . abs ( y1 - y2 ) ; return ( binomialCoeff ( m + n , n ) ) ; }
function findFourthVertex ( n , m , s ) { var row = new Map ( ) , col = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = 0 ; j < m ; j ++ ) if ( s [ i ] [ j ] == "*" ) { if ( row . has ( i ) ) row . set ( i , row . get ( i ) + 1 ) else row . set ( i , 1 )  if ( col . has ( j ) ) col . set ( j , col . get ( j ) + 1 ) else col . set ( j , 1 ) } var x , y ; row . forEach ( ( value , key ) => { if ( value == 1 ) x = key ; } ) ; col . forEach ( ( value , key ) => { if ( value == 1 ) y = key ; } ) ; return [ x + 1 , y + 1 ] ; }
function sph ( r , R , h ) { if ( r < 0 && R < 0 && h < 0 ) return - 1 ; var x = r ; var V = ( ( 4 * 3.14 * Math . pow ( r , 3 ) ) / 3 ) ; return V ; }
function Area ( a , b ) { if ( a < 0 && b < 0 ) return - 1 ; let h = Math . sqrt ( ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ) ; let A = 0.70477 * Math . pow ( h , 2 ) ; return A ; }
function maxRectangles ( L , B , l , b ) { var horizontal = 0 , vertical = 0 ; if ( l <= L && b <= B ) { var columns = parseInt ( B / b ) ; var rows = parseInt ( L / l ) ; horizontal = rows * columns ; } if ( l <= B && b <= L ) { var columns = parseInt ( L / b ) ; var rows = parseInt ( B / l ) ; vertical = rows * columns ; } return Math . max ( horizontal , vertical ) ; }
function cone ( a ) { if ( a < 0 ) return - 1 ; var r = ( a * Math . sqrt ( 2 ) ) / 3 ; var h = ( 2 * a ) / 3 ; var V = ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }
function Area ( a ) { if ( a < 0 ) return - 1 ; let h = 1.268 * a ; let A = 0.70477 * Math . pow ( h , 2 ) ; return A ; }
function Area ( r ) { if ( r < 0 ) return - 1 ; var x = ( 2 * r ) / ( Math . sqrt ( 5 ) ) ; var A = 0.70477 * ( Math . pow ( x , 2 ) ) ; return A ; }
function Area ( a ) { if ( a < 0 ) return - 1 ; let x = 0.464 * a ; let A = 0.70477 * Math . pow ( x , 2 ) ; return A ; }
function areaCircle ( b ) { let area = 3.1415926 * b * b ; return area ; }
function areaSquare ( side , fold ) { var area = side * side ; return ( area * 1.0 ) / ( Math . pow ( 2 , fold ) ) ; }
function checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { let m1 , m2 ; if ( x2 - x1 == 0 && x4 - x3 == 0 ) return false ; else if ( x2 - x1 == 0 ) { m2 = parseInt ( ( y4 - y3 ) / ( x4 - x3 ) , 10 ) ; if ( m2 == 0 ) return true ; else return false ; } else if ( x4 - x3 == 0 ) { m1 = parseInt ( ( y2 - y1 ) / ( x2 - x1 ) , 10 ) ; if ( m1 == 0 ) return true ; else return false ; } else { m1 = parseInt ( ( y2 - y1 ) / ( x2 - x1 ) , 10 ) ; m2 = parseInt ( ( y4 - y3 ) / ( x4 - x3 ) , 10 ) ; if ( m1 * m2 == - 1 ) return true ; else return false ; } }
function square ( a ) { if ( a < 0 ) return - 1 ; var x = 0.464 * a ; return x ; }
function ReuleauxArea ( r ) { if ( r < 0 ) return - 1 ; var A = 0.70477 * 2 * Math . pow ( r , 2 ) ; return A ; }
function cyl ( a ) { if ( a < 0 ) return - 1 ; var r = ( 2 * a * ( Math . sqrt ( 2 ) ) / 3 ) ; var h = ( 2 * a ) / 3 ; var V = ( 3.14 * ( Math . pow ( r , 2 ) * h ) ) ; return V ; }
function Area ( l , b , h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; let x = ( l * b ) / ( l + b ) ; let A = 0.70477 * Math . pow ( x , 2 ) ; return A ; }
function isPossible ( x , y , z ) { let a = Math . round ( x * x + y * y + z * z ) ; if ( Math . ceil ( a ) == 1 && Math . floor ( a ) == 1 ) return true ; return false ; }
function polyapothem ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; }
function polydiagonal ( n , a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( 2 * a * Math . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) ; }
function polyarea ( n , r ) { if ( r < 0 && n < 0 ) return - 1 ; var A = ( ( r * r * n ) * Math . sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; }
function decdiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.902 * a ; return d ; }
function hexagonside ( a ) { if ( a < 0 ) return - 1 ; let x = 0.5176 * a ; return x ; }
function hexagonside ( a ) { if ( a < 0 ) return - 1 ; var x = a / 3 ; return x ; }
function hexDiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.73 * a ; return d ; }
function pentdiagonal ( a ) { if ( a < 0 ) return - 1 ; let d = 1.22 * a ; return d ; }
function ReuleauxArea ( a ) { if ( a < 0 ) return - 1 ; var A = 0.70477 * Math . pow ( a , 2 ) ; return A ; }
function calculateSide ( n , r ) { var theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * Math . sin ( theta_in_radians / 2 ) ; }
function squareArea ( a ) { if ( a < 0 ) return - 1 ; var area = ( Math . pow ( 1.268 , 2 ) * Math . pow ( a , 2 ) ) ; return area ; }
function hexagonArea ( d ) { return ( 3 * Math . sqrt ( 3 ) * Math . pow ( d , 2 ) ) / 8 ; }
function cyl ( r , R , h ) { if ( h < 0 && r < 0 && R < 0 ) return - 1 ; var r1 = r ; var h1 = h ; var V = ( 3.14 * Math . pow ( r1 , 2 ) * h1 ) ; return V ; }
function findVolume ( a ) { if ( a < 0 ) return - 1 ; var r = a / 2 ; var h = a ; var V = ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }
function length_rope ( r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }
function cube ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var a = Math . pow ( h , 3 ) ; return a ; }
function sph ( r , h ) { if ( r < 0 && h < 0 ) return - 1 ; var R = r ; return R ; }
function cyl ( R ) { if ( R < 0 ) return - 1 ; var V = ( ( 2 * 3.14 * Math . pow ( R , 3 ) ) / ( 3 * Math . sqrt ( 3 ) ) ) ; return V ; }
function rod ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var l = ( Math . sqrt ( Math . pow ( h , 2 ) + 4 * Math . pow ( r , 2 ) ) ) ; return l ; }
function coner ( R ) { if ( R < 0 ) return - 1 ; var r = ( 2 * Math . sqrt ( 2 ) * R ) / 3 ; return r ; }
function coneh ( R ) { if ( R < 0 ) return - 1 ; var h = ( 4 * R ) / 3 ; return h ; }
function coneRadius ( a ) { if ( a < 0 ) return - 1 ; var r = ( a / Math . sqrt ( 2 ) ) ; return r ; }
function coneHeight ( a ) { if ( a < 0 ) return - 1 ; var h = a ; return h ; }
function largestCube ( r ) { if ( r < 0 ) return - 1 ; var a = ( 2 * r ) / Math . sqrt ( 3 ) ; return a ; }
function sphere ( a ) { if ( a < 0 ) return - 1 ; var r = a / 2 ; return r ; }
function numberOfCuts ( M , N ) { var result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }
function maxVol ( P , A ) { let l = ( P - Math . sqrt ( P * P - 24 * A ) ) / 12 ; let V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ; return V ; }
function maxArea ( perimeter ) { let length = Math . ceil ( perimeter / 4 ) ; let breadth = Math . floor ( perimeter / 4 ) ; return length * breadth ; }
function findSegment ( n , m , segment_length ) { let meet_point = ( 1.0 * n ) / 2.0 ; let sum = 0 ; let segment_number = 0 , i ; for ( i = 0 ; i < m ; i ++ ) { sum += segment_length [ i ] ; if ( sum == meet_point ) { segment_number = - 1 ; break ; } if ( sum > meet_point ) { segment_number = i + 1 ; break ; } } return segment_number ; }
function countMaxIntersect ( n ) { return ( n ) * ( n - 1 ) / 2 ; }
function equation_parabola ( x1 , y1 , a , b , c ) { var t = a * a + b * b ; var a1 = t - ( a * a ) ; var b1 = t - ( b * b ) ; var c1 = ( - 2 * t * x1 ) - ( 2 * c * a ) ; var d1 = ( - 2 * t * y1 ) - ( 2 * c * b ) ; var e1 = - 2 * a * b ; var f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; document . write ( "equation▁of▁parabola▁is▁" + a1 + "▁x^2▁+▁" + b1 + "▁y^2▁+▁" + c1 + "▁x▁+▁" + d1 + "▁y▁+▁" + e1 + "▁xy▁+▁" + f1 + "▁=▁0." ) ; }
function countRectangles ( l , w ) { let squareSide = __gcd ( l , w ) ; return parseInt ( ( l * w ) / ( squareSide * squareSide ) ) ; }
function section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) { let x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; let y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; let z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ; document . write ( "(" + x + ",▁" ) ; document . write ( y + ",▁" ) ; document . write ( z + ")" ) ; }
function Squares ( n , m , a ) { return parseInt ( ( ( m + a - 1 ) / a ) ) * parseInt ( ( ( n + a - 1 ) / a ) ) ; }
function area ( r ) { return ( ( 0.5 ) * ( 3.14 ) * ( r * r ) ) ; }
function checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) { var resx = x1 + x2 + x3 ; var resy = y1 + y2 + y3 ; var resz = z1 + z2 + z3 ; if ( resx == 0 & resy == 0 & resz == 0 ) return true ; else return false ; }
function hexadiagonal ( a ) { if ( a < 0 ) return - 1 ; return 2 * a ; }
function octadiagonal ( a ) { if ( a < 0 ) return - 1 ; return a * Math . sqrt ( 4 + ( 2 * Math . sqrt ( 2 ) ) ) ; }
function CalPeri ( ) { var S = 5 , Perimeter ; Perimeter = 10 * S ; document . write ( "The▁Perimeter▁of▁Decagon▁is▁:▁" + Perimeter ) ; }
function octaside ( a ) { if ( a < 0 ) return - 1 ; var s = a / ( Math . sqrt ( 2 ) + 1 ) ; return s ; }
function findEdges ( s1 , s2 , s3 ) { let a = Math . sqrt ( s1 * s2 / s3 ) ; let b = Math . sqrt ( s3 * s1 / s2 ) ; let c = Math . sqrt ( s3 * s2 / s1 ) ; let sum = a + b + c ; return 4 * sum ; }
function findRadiusOfcircumcircle ( n , a ) { if ( n < 0 a < 0 ) return - 1 ; var radius = ( a / Math . sqrt ( 2 - ( 2 * Math . cos ( 360 / n ) ) ) ) ; return radius ; }
function rhombusarea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; return ( l * b ) / 2 ; }
function Arrive ( a , b , n ) { if ( n >= Math . abs ( a ) + Math . abs ( b ) && ( n - ( Math . abs ( a ) + Math . abs ( b ) ) ) % 2 == 0 ) return true ; return false ; }
function Move ( a , x , b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; }
function area ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var A = a * b ; return A ; }
function circle_inscribed ( a ) { return PI * ( a * a ) / 12 ; }
function surfaceArea ( a , b , h ) { return 5 * a * b + 5 * b * h ; }
function volume ( b , h ) { return ( 5 * b * h ) / 2 ; }
function findRadiusOfcircumcircle ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var radius = Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; }
function circlearea ( a , b , c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; var p = ( a + b + c ) / 2 ; var At = Math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; var A = 3.14 * Math . pow ( ( ( a * b * c ) / ( 4 * At ) ) , 2 ) ; return A ; }
function altitude ( a , b ) { return Math . sqrt ( Math . pow ( a , 2 ) - ( Math . pow ( b , 2 ) / 4 ) ) ; }
function surfaceArea ( b , s ) { return 2 * b * s + parseInt ( Math . pow ( b , 2 ) ) ; }
function trianglearea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; let area = ( l * b ) / 2 ; return area ; }
function area ( a ) { if ( a < 0 ) return - 1 ; var area = Math . sqrt ( a ) / 6 ; return area ; }
function halfsquare ( n , x , y ) { let half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) document . write ( "NO" ) ; else document . write ( "YES" ) ; }
function checkpoint ( h , k , x , y , a ) { var p = parseInt ( Math . pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ) ; return p ; }
function checkpoint ( h , k , x , y , a , b ) { var p = ( parseInt ( Math . pow ( ( x - h ) , 2 ) ) / parseInt ( Math . pow ( a , 2 ) ) ) + ( parseInt ( Math . pow ( ( y - k ) , 2 ) ) / parseInt ( Math . pow ( b , 2 ) ) ) ; return p ; }
function area ( x1 , y1 , z1 , x2 , y2 , z2 ) { let area = Math . sqrt ( Math . pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + Math . pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + Math . pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ) ; area = area / 2 ; return area ; }
function trianglearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var area = ( 3 * Math . sqrt ( 3 ) * Math . pow ( a , 2 ) ) / ( 4 * b ) ; return area ; }
function squarearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var area = 4 * ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ; return area ; }
function longestRodInCuboid ( length , breadth , height ) { let result ; let temp ; temp = length * length + breadth * breadth + height * height ; result = Math . sqrt ( temp ) ; return result ; }
function trianglearea ( r ) { if ( r < 0 ) return - 1 ; return r * r ; }
function squarearea ( r ) { if ( r < 0 ) return - 1 ; var a = 4 * ( Math . pow ( r , 2 ) / 5 ) ; return a ; }
function rectanglearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; return 2 * a * b ; }
function trapezoidarea ( r ) { if ( r < 0 ) return - 1 ; var a = ( 3 * Math . sqrt ( 3 ) * Math . pow ( r , 2 ) ) / 4 ; return a ; }
function squareArea ( l , b , h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; var a = ( l * b ) / ( l + b ) ; return a * a ; }
function circlearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var A = ( ( 3.14 * Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) / ( 4 * ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) ) ) ; return A ; }
function circlearea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; if ( l < b ) return ( 3.14 * Math . pow ( l / 2 , 2 ) ) ; else return ( 3.14 * Math . pow ( b / 2 , 2 ) ) ; }
function maxLines ( n , x1 , y1 , x2 , y2 ) { var s = [ ] ; var slope = 2147483647 ; for ( let i = 0 ; i < n ; i ++ ) { if ( x1 [ i ] === x2 [ i ] ) slope = 2147483647 ; else slope = ( ( ( y2 [ i ] - y1 [ i ] ) * 1.0 ) / ( x2 [ i ] - x1 [ i ] ) ) * 1.0 ; s . push ( slope ) ; } return s . length ; }
function squares ( l , b , a ) { return parseInt ( Math . ceil ( l / a ) * Math . ceil ( b / a ) ) ; }
function gcd ( a , b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
function squarearea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var n = ( l * b ) / gcd ( l , b ) ; return n * n ; }
function angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) { let num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; let den = Math . sqrt ( Math . pow ( ( x2 - x1 ) , 2 ) + Math . pow ( ( y2 - y1 ) , 2 ) + Math . pow ( ( z2 - z1 ) , 2 ) ) * Math . sqrt ( Math . pow ( ( x3 - x1 ) , 2 ) + Math . pow ( ( y3 - y1 ) , 2 ) + Math . pow ( ( z3 - z1 ) , 2 ) ) ; let angle = Math . acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; }
function is_partition_possible ( n , x , y , w ) { let weight_at_x = new Map ( ) ; let max_x = - 2e3 , min_x = 2e3 ; for ( let i = 0 ; i < n ; i ++ ) { let new_x = x [ i ] - y [ i ] ; max_x = Math . max ( max_x , new_x ) ; min_x = Math . min ( min_x , new_x ) ; if ( weight_at_x . has ( new_x ) ) { weight_at_x . set ( new_x , weight_at_x . get ( new_x ) + w [ i ] ) ; } else { weight_at_x . set ( new_x , w [ i ] ) ; } } let sum_till = [ ] ; sum_till . push ( 0 ) ; for ( let s = min_x ; s <= max_x ; s ++ ) { if ( weight_at_x . get ( s ) == null ) sum_till . push ( sum_till [ sum_till . length - 1 ] ) ; else sum_till . push ( sum_till [ sum_till . length - 1 ] + weight_at_x . get ( s ) ) ; } let total_sum = sum_till [ sum_till . length - 1 ] ; let partition_possible = 0 ; for ( let i = 1 ; i < sum_till . length ; i ++ ) { if ( sum_till [ i ] == total_sum - sum_till [ i ] ) partition_possible = 1 ; if ( sum_till [ i - 1 ] == total_sum - sum_till [ i ] ) partition_possible = 1 ; } document . write ( partition_possible == 1 ? "YES" : "NO" ) ; }
function makePolygon ( a ) { var n = parseFloat ( 360 / ( 180 - a ) ) ; if ( n === parseInt ( n ) ) document . write ( "YES" ) ; else document . write ( "NO" ) ; }
function LiesInsieRectangle ( a , b , x , y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; }
function area ( x1 , y1 , z1 , x2 , y2 , z2 ) { area = Math . sqrt ( Math . pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + Math . pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + Math . pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ) ; return area ; }
function equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) { var a1 = x2 - x1 ; var b1 = y2 - y1 ; var c1 = z2 - z1 ; var a2 = x3 - x1 ; var b2 = y3 - y1 ; var c2 = z3 - z1 ; var a = b1 * c2 - b2 * c1 ; var b = a2 * c1 - a1 * c2 ; var c = a1 * b2 - b1 * a2 ; var d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) document . write ( "Coplanar" ) ; else document . write ( "Not▁Coplanar" ) ; }
function solve ( M , N , s ) { if ( N % s == 0 ) { N = N / s ; } else { N = ( N / s ) + 1 ; } if ( M % s == 0 ) { M = M / s ; } else { M = ( M / s ) + 1 ; } return parseInt ( M * N ) ; }
function max_intersection ( center , length , k ) { center . sort ( ) ; if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) { return 0 ; } else if ( center [ 2 ] - center [ 0 ] >= 2 * k ) { return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) ; } else return length ; }
function FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { var x5 = Math . max ( x1 , x3 ) ; var y5 = Math . max ( y1 , y3 ) ; var x6 = Math . min ( x2 , x4 ) ; var y6 = Math . min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { document . write ( "No▁intersection" ) ; return ; } document . write ( "(" + x5 + ",▁" + y5 + ")▁" ) ; document . write ( "(" + x6 + ",▁" + y6 + ")▁" ) ; var x7 = x5 ; var y7 = y6 ; document . write ( "(" + x7 + ",▁" + y7 + ")▁" ) ; var x8 = x6 ; var y8 = y5 ; document . write ( "(" + x8 + ",▁" + y8 + ")▁" ) ; }
function FindPoint ( x1 , y1 , x2 , y2 , x , y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; }
function distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) { let x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = Math . abs ( ( c2 * z1 + d2 ) ) / ( Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; document . write ( "Perpendicular▁distance▁is▁" + d ) ; } else document . write ( "Planes▁are▁not▁parallel" ) ; }
function distance ( a1 , b1 , c1 , a2 , b2 , c2 ) { var d = a1 * a2 + b1 * b2 + c1 * c2 ; var e1 = Math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; var e2 = Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = parseFloat ( d / ( e1 * e2 ) ) ; var pi = 3.14159 ; var A = ( 180 / pi ) * Math . acos ( d ) ; document . write ( "Angle▁is▁" + A . toFixed ( 1 ) + "▁degree" ) ; }
function haversine ( lat1 , lon1 , lat2 , lon2 ) { let dLat = ( lat2 - lat1 ) * Math . PI / 180.0 ; let dLon = ( lon2 - lon1 ) * Math . PI / 180.0 ; lat1 = ( lat1 ) * Math . PI / 180.0 ; lat2 = ( lat2 ) * Math . PI / 180.0 ; let a = Math . pow ( Math . sin ( dLat / 2 ) , 2 ) + Math . pow ( Math . sin ( dLon / 2 ) , 2 ) * Math . cos ( lat1 ) * Math . cos ( lat2 ) ; let rad = 6371 ; let c = 2 * Math . asin ( Math . sqrt ( a ) ) ; return rad * c ; }
function equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) { var a1 = x2 - x1 ; var b1 = y2 - y1 ; var c1 = z2 - z1 ; var a2 = x3 - x1 ; var b2 = y3 - y1 ; var c2 = z3 - z1 ; var a = b1 * c2 - b2 * c1 ; var b = a2 * c1 - a1 * c2 ; var c = a1 * b2 - b1 * a2 ; var d = ( - a * x1 - b * y1 - c * z1 ) ; document . write ( "equation▁of▁plane▁is▁" + a + "▁x▁+▁" + b + "▁y▁+▁" + c + "▁z▁+▁" + d + "▁=▁0." ) ; }
function findVolume ( l , b , h ) { let volume = ( l * b * h ) / 2 ; return volume ; }
function countNumberOfTriangles ( n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
function countRectangles ( radius ) { let rectangles = 0 ; let diameter = 2 * radius ; let diameterSquare = diameter * diameter ; for ( let a = 1 ; a < 2 * radius ; a ++ ) { for ( let b = 1 ; b < 2 * radius ; b ++ ) { let diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }
function simi_aaa ( a1 , a2 ) { a1 . sort ( function ( a , b ) { return a - b } ) ; a2 . sort ( function ( a , b ) { return a - b } ) ; if ( a1 [ 0 ] == a2 [ 0 ] && a1 [ 1 ] == a2 [ 1 ] && a1 [ 2 ] == a2 [ 2 ] ) return 1 ; else return 0 ; }
function simi_sas ( s1 , s2 , a1 , a2 ) { a1 . sort ( function ( a , b ) { return a - b } ) ; a2 . sort ( function ( a , b ) { return a - b } ) ; s1 . sort ( function ( a , b ) { return a - b } ) ; s2 . sort ( function ( a , b ) { return a - b } ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] ) { if ( a1 [ 2 ] == a2 [ 2 ] ) return 1 ; } if ( s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] ) { if ( a1 [ 0 ] == a2 [ 0 ] ) return 1 ; } if ( s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) { if ( a1 [ 1 ] == a2 [ 1 ] ) return 1 ; } return 0 ; }
function simi_sss ( s1 , s2 ) { s1 . sort ( function ( a , b ) { return a - b } ) ; s2 . sort ( function ( a , b ) { return a - b } ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] && s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] && s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) return 1 ; return 0 ; }
function centeredDodecagonal ( n ) { return 6 * n * ( n - 1 ) + 1 ; }
function heptagonalNumber ( n ) { return parseInt ( ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ) ; }
function centeredTridecagonalNum ( n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; }
function pentagon_pyramidal ( n ) { var sum = 0 ; for ( i = 1 ; i <= n ; i ++ ) { var p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; }
function pentagon_pyramidal ( n ) { return n * n * ( n + 1 ) / 2 ; }
function checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
function getQuadrant ( X , Y , R , PX , PY ) { if ( PX == X && PY == Y ) return 0 ; let val = Math . pow ( ( PX - X ) , 2 ) + Math . pow ( ( PY - Y ) , 2 ) ; if ( val > Math . pow ( R , 2 ) ) return - 1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; }
function center_pentadecagonal_num ( n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
function icosidigonal_num ( n ) { return parseInt ( ( 20 * n * n - 18 * n ) / 2 ) ; }
function center_nonadecagon_num ( n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; }
function center_octadecagon_num ( n ) { return 9 * n * n - 9 * n + 1 ; }
function hendecagonal_num ( n ) { return ( 9 * n * n - 7 * n ) / 2 ; }
function centereddecagonalnum ( n ) { return ( 5 * n * n + 5 * n + 1 ) ; }
function Ksmallest ( x , y , k ) { if ( x == 0 && y == 0 ) return ; else if ( x == 0 ) { y -- ; document . write ( "V" ) ; Ksmallest ( x , y , k ) ; } else if ( y == 0 ) { x -- ; document . write ( "H" ) ; Ksmallest ( x , y , k ) ; } else { if ( factorial ( x - 1 , y ) > k ) { document . write ( "H" ) ; Ksmallest ( x - 1 , y , k ) ; } else { document . write ( "V" ) ; Ksmallest ( x , y - 1 , k - factorial ( x - 1 , y ) ) ; } } }
function nthEnneadecagonal ( n ) { return ( 17 * n * n - 15 * n ) / 2 ; }
function inorder ( root ) { if ( root == null ) return ; inorder ( root . left ) ; document . write ( root . data + "▁" ) ; inorder ( root . right ) ; }
function centered_pentagonal_Num ( n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
function findPoint ( x1 , y1 , x2 , y2 ) { document . write ( "(" + 2 * ( x2 - x1 ) + "," + 2 * ( y2 - y1 ) + ")" ) ; }
function pivotDis ( x0 , y0 , x1 , y1 ) { return Math . sqrt ( ( x1 - x0 ) * ( x1 - x0 ) + ( y1 - y0 ) * ( y1 - y0 ) ) ; }
function minDis ( D , r1 , r2 ) { return Math . max ( ( D - r1 - r2 ) , 0 ) ; }
function maxDis ( D , r1 , r2 ) { return D + r1 + r2 ; }
function findPCSlope ( m ) { return - 1.0 / m ; }
function otherEndPoint ( x1 , y1 , m1 , m2 ) { let x2 = 2 * m1 - x1 ; let y2 = 2 * m2 - y1 ; document . write ( "x2▁=▁" + x2 + ",▁" + "y2▁=▁" + y2 ) ; }
function isValid ( arr , i , j , m , c ) { if ( i == j ) return false ; var lhs = arr [ j ] ; var rhs = m * arr [ i ] + c ; return lhs == rhs ; }
function findOrderedPoints ( arr , n , m , c ) { var counter = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { var firstIndex = i , secondIndex = j ; if ( isValid ( arr , firstIndex , secondIndex , m , c ) ) counter ++ ; } } return counter ; }
function numberOfSticks ( x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
function overlappingArea ( l1 , r1 , l2 , r2 ) { let x = 0  let y = 1  let area1 = Math . abs ( l1 [ x ] - r1 [ x ] ) * Math . abs ( l1 [ y ] - r1 [ y ] )  let area2 = Math . abs ( l2 [ x ] - r2 [ x ] ) * Math . abs ( l2 [ y ] - r2 [ y ] )  let x_dist = ( Math . min ( r1 [ x ] , r2 [ x ] ) - Math . max ( l1 [ x ] , l2 [ x ] ) )  let y_dist = ( Math . min ( r1 [ y ] , r2 [ y ] ) - Math . max ( l1 [ y ] , l2 [ y ] ) )  let areaI = 0  if ( x_dist > 0 && y_dist > 0 ) areaI = x_dist * y_dist return ( area1 + area2 - areaI ) }
function checkOrigin ( x1 , y1 , x2 , y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
function checkcircle ( r , R , r1 , x1 , y1 ) { let dis = Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
function areacircumscribed ( a ) { return ( a * a * ( 3.1415 / 2 ) ) ; }
function surface_area_octahedron ( side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }
function find_Area ( r ) { return ( 2 * r * r ) ; }
function checkValidity ( a , b , c ) { if ( a + b <= c a + c <= b b + c <= a ) return false ; else return true ; }
function isRectangle ( a , b , c , d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; }
function nCk ( n , k ) { let C = new Array ( k + 1 ) ; C . fill ( 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
function count_Straightlines ( n , m ) { return ( nCk ( n , 2 ) - nCk ( m , 2 ) + 1 ) ; }
function isBetween ( a , b , c ) { return ( Math . min ( a , b ) <= c && c <= Math . max ( a , b ) ) ; }
function canJoin ( x , y , i , j , k ) { return ( x [ k ] == x [ i ] x [ k ] == x [ j ] ) && isBetween ( y [ i ] , y [ j ] , y [ k ] ) || ( y [ k ] == y [ i ] y [ k ] == y [ j ] ) && isBetween ( x [ i ] , x [ j ] , x [ k ] ) ; }
function countLineSegments ( x , y ) { if ( ( x [ 0 ] == x [ 1 ] && x [ 1 ] == x [ 2 ] ) || ( y [ 0 ] == y [ 1 ] && y [ 1 ] == y [ 2 ] ) ) return 1 ; else if ( canJoin ( x , y , 0 , 1 , 2 ) || canJoin ( x , y , 0 , 2 , 1 ) || canJoin ( x , y , 1 , 2 , 0 ) ) return 2 ; else return 3 ; }
function vol_of_dodecahedron ( side ) { return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; }
function perimeter ( diameter , height ) { return 2 * ( diameter + height ) ; }
function area_of_segment ( radius , angle ) { let area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; let area_of_triangle = 1 / 2 * ( radius * radius ) * Math . sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
function midpoint ( x1 , x2 , y1 , y2 ) { document . write ( ( x1 + x2 ) / 2 + "▁,▁" + ( y1 + y2 ) / 2 ) ; }
function contribution_height ( current , previous ) { return Math . abs ( current - previous ) ; }
function surfaceArea ( A ) { let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { let up = 0 ; let left = 0 ; if ( i > 0 ) up = A [ i - 1 ] [ j ] ; if ( j > 0 ) left = A [ i ] [ j - 1 ] ; ans += contribution_height ( A [ i ] [ j ] , up ) + contribution_height ( A [ i ] [ j ] , left ) ; if ( i == N - 1 ) ans += A [ i ] [ j ] ; if ( j == M - 1 ) ans += A [ i ] [ j ] ; } } ans += N * M * 2 ; return ans ; }
function area_of_tetrahedron ( side ) { return ( Math . sqrt ( 3 ) * ( side * side ) ) ; }
function vol_tetra ( side ) { let volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ; return volume ; }
function overflow ( H , r , h , N , R ) { let tank_cap = 3.14 * r * r * H ; let water_vol = 3.14 * r * r * h ; let balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; let vol = water_vol + balls_vol ; if ( vol > tank_cap ) { document . write ( "Overflow" ) ; } else { document . write ( "Not▁in▁overflow▁state" ) ; } }
function volume ( radius , height ) { return ( ( 22 / 7 ) * radius * radius * height ) ; }
function maxvolume ( s ) { let maxvalue = 0 ; for ( let i = 1 ; i <= s - 2 ; i ++ ) { for ( let j = 1 ; j <= s - 1 ; j ++ ) { let k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
function maxvolume ( s ) { let length = parseInt ( s / 3 ) ; s -= length ; let breadth = parseInt ( s / 2 ) ; let height = s - breadth ; return length * breadth * height ; }
function volumeOfEllipsoid ( r1 , r2 , r3 ) { let pi = 3.14 ; return 1.33 * pi * r1 * r2 * r3 ; }
function slope ( x1 , y1 , x2 , y2 ) { if ( x1 == x2 ) return Number . MAX_VALUE ; return ( y2 - y1 ) / ( x2 - x1 ) ; }
function cal_cos ( n ) { let accuracy = 0.0001 , x1 ; let denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = Math . cos ( n ) ; let i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . abs ( cosval - cosx ) ) ; return cosx ; }
function third_side ( a , b , c ) { let angle = cal_cos ( c ) ; return Math . sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; }
function volumeTriangular ( a , b , h ) { let vol = ( 0.1666 ) * a * b * h ; return vol ; }
function volumeSquare ( b , h ) { let vol = ( 0.33 ) * b * b * h ; return vol ; }
function volumePentagonal ( a , b , h ) { let vol = ( 0.83 ) * a * b * h ; return vol ; }
function volumeHexagonal ( a , b , h ) { let vol = a * b * h ; return vol ; }
function areaOctagon ( side ) { return ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ; }
function Area ( b1 , b2 , h ) { return ( ( b1 + b2 ) / 2 ) * h ; }
function hexagonArea ( s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }
function findCommon ( mat ) { let column = new Array ( M ) ; let min_row ; let i ; for ( i = 0 ; i < M ; i ++ ) column [ i ] = N - 1 ; min_row = 0 ; while ( column [ min_row ] >= 0 ) { for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i ; } let eq_count = 0 ; for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { if ( column [ i ] == 0 ) return - 1 ; column [ i ] -= 1 ; } else eq_count ++ ; } if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ] ; } return - 1 ; }
function Circumference ( a ) { return 4 * a ; }
function arcLength ( diameter , angle ) { let pi = 22.0 / 7.0 ; let arc ; if ( angle >= 360 ) { document . write ( "Angle▁cannot" + "▁be▁formed" ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
function SectorArea ( radius , angle ) { if ( angle >= 360 ) document . write ( "Angle▁not▁possible" ) ; else { let sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; document . write ( sector ) ; } }
function findCommon ( mat ) { let cnt = new Map ( ) ; let i , j ; for ( i = 0 ; i < M ; i ++ ) { if ( cnt . has ( mat [ i ] [ 0 ] ) ) { cnt . set ( mat [ i ] [ 0 ] , cnt . get ( mat [ i ] [ 0 ] ) + 1 ) ; } else { cnt . set ( mat [ i ] [ 0 ] , 1 ) ; } for ( j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) { if ( cnt . has ( mat [ i ] [ j ] ) ) { cnt . set ( mat [ i ] [ j ] , cnt . get ( mat [ i ] [ j ] ) + 1 ) ; } else { cnt . set ( mat [ i ] [ j ] , 1 ) ; } } } } for ( let [ key , value ] of cnt . entries ( ) ) { if ( value == M ) return key ; } return - 1 ; }
function surfaceAreaCuboid ( l , h , w ) { return ( 2 * l * w + 2 * w * h + 2 * l * h ) ; }
function surfaceCube ( a ) { return ( 6 * a * a ) ; }
function minRadius ( k , x , y , n ) { let dis = Array . from ( { length : n } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; dis . sort ( ) ; return dis [ k - 1 ] ; }
function areaRectangle ( a , b ) { let area = a * b ; return area ; }
function perimeterRectangle ( a , b ) { let perimeter = 2 * ( a + b ) ; return perimeter ; }
function areaSquare ( side ) { let area = side * side ; return area ; }
function maxSquare ( b , m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; a }
function minPerimeter ( n ) { let l = Math . sqrt ( n ) ; let sq = l * l ; if ( sq == n ) return l * 4 ; else { let row = n / l ; let perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
function checkCollision ( a , b , c , x , y , radius ) { let dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) document . write ( "Touch" ) ; else if ( radius > dist ) document . write ( "Intersect" ) ; else document . write ( "Outside" ) ; }
function possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) { var dis1 = Math . pow ( b1 - a1 , 2 ) + Math . pow ( b2 - a2 , 2 ) ; var dis2 = Math . pow ( c1 - b1 , 2 ) + Math . pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) document . write ( "No" ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) document . write ( "No" ) ; else document . write ( "Yes" ) ; }
function replaceSurrounded ( mat ) { for ( let i = 0 ; i < M ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] == "O" ) mat [ i ] [ j ] = "-" ; for ( let i = 0 ; i < M ; i ++ ) if ( mat [ i ] [ 0 ] == "-" ) floodFillUtil ( mat , i , 0 , "-" , "O" ) ; for ( let i = 0 ; i < M ; i ++ ) if ( mat [ i ] [ N - 1 ] == "-" ) floodFillUtil ( mat , i , N - 1 , "-" , "O" ) ; for ( let i = 0 ; i < N ; i ++ ) if ( mat [ 0 ] [ i ] == "-" ) floodFillUtil ( mat , 0 , i , "-" , "O" ) ; for ( let i = 0 ; i < N ; i ++ ) if ( mat [ M - 1 ] [ i ] == "-" ) floodFillUtil ( mat , M - 1 , i , "-" , "O" ) ; for ( let i = 0 ; i < M ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] == "-" ) mat [ i ] [ j ] = "X" ; }
function fitOrNotFit ( R , r , x , y , rad ) { var val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) document . write ( "Fits" ) ; else document . write ( "Doesn't▁Fit" ) ; }
function check ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 , x , y ) { let A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) + area ( x1 , y1 , x4 , y4 , x3 , y3 ) ; let A1 = area ( x , y , x1 , y1 , x2 , y2 ) ; let A2 = area ( x , y , x2 , y2 , x3 , y3 ) ; let A3 = area ( x , y , x3 , y3 , x4 , y4 ) ; let A4 = area ( x , y , x1 , y1 , x4 , y4 ) ; return ( A == A1 + A2 + A3 + A4 ) ; }
function rectCount ( n , m ) { return parseInt ( ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 , 10 ) ; }
function countObtuseAngles ( a , b , k ) { var c1 = ( b - a ) - 1 ; var c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return Math . min ( c1 , c2 ) ; }
function countRect ( n ) { let ans = 0 ; for ( let length = 1 ; length <= parseInt ( Math . sqrt ( n ) , 10 ) ; ++ length ) for ( let height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
function isPolygonPossible ( arr , N ) { let limit = Math . sqrt ( N ) ; for ( let i = 1 ; i <= limit ; i ++ ) { if ( N % i == 0 ) { if ( checkPolygonWithMidpoints ( arr , N , i ) || checkPolygonWithMidpoints ( arr , N , parseInt ( N / i ) ) ) return ; } } document . write ( "Not▁possiblen" ) ; }
function minRevolutions ( r , x1 , y1 , x2 , y2 ) { let d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }
function inside ( A , p ) { let mid = [ 0 , 0 ] ; let n = A . length ; for ( let i = 0 ; i < n ; i ++ ) { mid [ 0 ] += A [ i ] [ 0 ] ; mid [ 1 ] += A [ i ] [ 1 ] ; } for ( let i = 0 , j ; i < n ; i ++ ) { j = ( i + 1 ) % n ; let x1 = A [ i ] [ 0 ] * n , x2 = A [ j ] [ 0 ] * n ; let y1 = A [ i ] [ 1 ] * n , y2 = A [ j ] [ 1 ] * n ; let a1 = y1 - y2 ; let b1 = x2 - x1 ; let c1 = x1 * y2 - y1 * x2 ; let for_mid = a1 * mid [ 0 ] + b1 * mid [ 1 ] + c1 ; let for_p = a1 * p [ 0 ] * n + b1 * p [ 1 ] * n + c1 ; if ( for_mid * for_p < 0 ) return false ; } return true ; }
function addPoint ( a , p ) { if ( inside ( a , p ) ) return ; let ind = 0 ; let n = a . length ; for ( let i = 1 ; i < n ; i ++ ) { if ( sqDist ( p , a [ i ] ) < sqDist ( p , a [ ind ] ) ) { ind = i ; } } let up = ind ; while ( orientation ( p , a [ up ] , a [ ( up + 1 ) % n ] ) >= 0 ) up = ( up + 1 ) % n ; let low = ind ; while ( orientation ( p , a [ low ] , a [ ( n + low - 1 ) % n ] ) <= 0 ) low = ( n + low - 1 ) % n ; let ret = [ ] ; let curr = up ; ret . push ( a [ curr ] ) ; while ( curr != low ) { curr = ( curr + 1 ) % n ; ret . push ( a [ curr ] ) ; } ret . push ( p ) ; a = [ ] ; for ( let i = 0 ; i < ret . length ; i ++ ) { a . push ( ret [ i ] ) ; } return a ; }
function getDistance ( x1 , y1 , x2 , y2 ) { return ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ; }
function numberOfSquares ( base ) { base = ( base - 2 ) ; base = Math . floor ( base / 2 ) ; return base * ( base + 1 ) / 2 ; }
function findMaximumPieces ( n ) { return 1 + n * ( n + 1 ) / 2 ; }
function preprocess ( p , x , y , n ) { for ( let i = 0 ; i < n ; i ++ ) p [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; p . sort ( function ( a , b ) { return a - b ; } ) ; }
function query ( p , n , rad ) { let start = 0 , end = n - 1 ; while ( ( end - start ) > 1 ) { let mid = Math . floor ( ( start + end ) / 2 ) ; let tp = Math . sqrt ( p [ mid ] ) ; if ( tp > ( rad * 1.0 ) ) end = mid - 1 ; else start = mid ; } let tp1 = Math . sqrt ( p [ start ] ) ; let tp2 = Math . sqrt ( p [ end ] ) ; if ( tp1 > ( rad * 1.0 ) ) return 0 ; else if ( tp2 <= ( rad * 1.0 ) ) return end + 1 ; else return start + 1 ; }
function getArea ( base , hypotenuse ) { let height = Math . sqrt ( hypotenuse * hypotenuse - base * base ) ; return 0.5 * base * height ; }
function printRightAngleTriangle ( hypotenuse , area ) { let hsquare = hypotenuse * hypotenuse ; let sideForMaxArea = Math . sqrt ( hsquare / 2.0 ) ; let maxArea = getArea ( sideForMaxArea , hypotenuse ) ; if ( area > maxArea ) { document . write ( "Not▁possible" ) ; return ; } let low = 0.0 ; let high = sideForMaxArea ; let base = 0 ; while ( Math . abs ( high - low ) > eps ) { base = ( low + high ) / 2.0 ; if ( getArea ( base , hypotenuse ) >= area ) { high = base ; } else { low = base ; } } let height = Math . sqrt ( hsquare - base * base ) ; document . write ( Math . round ( base ) + "▁" + Math . round ( height ) ) ; }
function squareRoot ( n ) { let x = n ; let y = 1 ; let e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
function findMaximumHeight ( N ) { let n = 1 + 8 * N ; let maxH = ( - 1 + squareRoot ( n ) ) / 2 ; return Math . round ( maxH ) ; }
function polygonArea ( X , Y , n ) { let area = 0.0 ; let j = n - 1 ; for ( let i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function getCount ( p , q ) { if ( p . x == q . x ) return Math . abs ( p . y - q . y ) - 1 ; if ( p . y == q . y ) return Math . abs ( p . x - q . x ) - 1 ; return gcd ( Math . abs ( p . x - q . x ) , Math . abs ( p . y - q . y ) ) - 1 ; }
function getMinSteps ( n ) { let table = new Array ( n + 1 ) ; table . fill ( 0 ) ; table [ 1 ] = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( ! ( i % 2 ) && ( i % 3 ) ) table [ i ] = 1 + Math . min ( table [ i - 1 ] , table [ i / 2 ] ) ; else if ( ! ( i % 3 ) && ( i % 2 ) ) table [ i ] = 1 + Math . min ( table [ i - 1 ] , table [ i / 3 ] ) ; else if ( ! ( i % 2 ) && ! ( i % 3 ) ) table [ i ] = 1 + Math . min ( table [ i - 1 ] , Math . min ( table [ i / 2 ] , table [ i / 3 ] ) ) ; else table [ i ] = 1 + table [ i - 1 ] ; } return table [ n ] + 1 ; }
function distSq ( p , q ) { return ( p . x - q . x ) * ( p . x - q . x ) + ( p . y - q . y ) * ( p . y - q . y ) ; }
function polygonArea ( X , Y , n ) { let area = 0.0 ; let j = n - 1 ; for ( let i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return Math . abs ( area / 2.0 ) ; }
function youngify ( mat , i , j ) { let downVal = ( i + 1 < N ) ? mat [ i + 1 ] [ j ] : INF ; let rightVal = ( j + 1 < N ) ? mat [ i ] [ j + 1 ] : INF ; if ( downVal == INF && rightVal == INF ) { return ; } if ( downVal < rightVal ) { mat [ i ] [ j ] = downVal ; mat [ i + 1 ] [ j ] = INF ; youngify ( mat , i + 1 , j ) ; } else { mat [ i ] [ j ] = rightVal ; mat [ i ] [ j + 1 ] = INF ; youngify ( mat , i , j + 1 ) ; } }
function extractMin ( mat ) { let ret = mat [ 0 ] [ 0 ] ; mat [ 0 ] [ 0 ] = INF ; youngify ( mat , 0 , 0 ) ; return ret ; }
function printSorted ( mat ) { document . write ( "Elements▁of▁matrix▁in▁sorted▁order▁n" ) ; for ( let i = 0 ; i < N * N ; i ++ ) { document . write ( extractMin ( mat ) + "▁" ) ; } }
function f ( x , p , num ) { return Math . pow ( x , p ) - num ; }
function f_prime ( x , p ) { return p * Math . pow ( x , p - 1 ) ; }
function minimumAdditionOperation ( N ) { let count = 0 ; while ( N ) { if ( N & ( 1 == 1 ) ) { count ++ ; } N = N >> 1 ; } return count ; }
function minimumOperations ( arr , N ) { let mini = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < N ; i ++ ) { let count = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = Math . floor ( arr [ i ] / 2 ) ; count ++ ; } if ( mini > count ) { mini = count ; } } return mini ; }
function minimumSizeArr ( A , B ) { let currXor = 0 ; let reminder = ( A - 1 ) % 4 ; if ( reminder == 0 ) currXor = A - 1 ; else if ( reminder == 1 ) currXor = 1 ; else if ( reminder == 2 ) currXor = A ; let minSize = A ; if ( currXor == B ) return minSize ; else if ( currXor ^ ( B == A ) ) return minSize + 2 ; else return minSize + 1 ; }
function modifiedSieve ( ) { gpf . fill ( 0 ) ; gpf [ 0 ] = 0 ; gpf [ 1 ] = 1 ; for ( let i = 2 ; i < maxn ; i ++ ) { if ( gpf [ i ] > 0 ) continue ; for ( let j = i ; j < maxn ; j += i ) { gpf [ j ] = Math . max ( i , gpf [ j ] ) ; } } }
function greatestValidInt ( N ) { modifiedSieve ( ) ; for ( let i = N ; i > 0 ; i -- ) { if ( gpf [ i ] > Math . sqrt ( i ) ) { return i ; } } return - 1 ; }
function SieveOfEratosthenes ( ) { prime . fill ( true ) ; for ( let p = 2 ; p * p <= mxn ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= mxn ; i += p ) prime [ i ] = false ; } } }
function countMin ( arr , n ) { let cMinSwaps = 0 ; let cPrimeIndices = 0 ; let cPrimeNos = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( prime [ i + 1 ] ) { cPrimeIndices ++ ; if ( ! prime [ arr [ i ] ] ) cMinSwaps ++ ; else cPrimeNos ++ ; } else if ( prime [ arr [ i ] ] ) { cPrimeNos ++ ; } } if ( cPrimeNos >= cPrimeIndices ) return cMinSwaps ; else return - 1 ; }
function subfactorial ( N ) { let res = 0 , fact = 1 ; let count = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { fact = fact * i ; if ( count % 2 == 0 ) res = res - 1 / fact ; else res = res + 1 / fact ; count ++ ; } return fact * ( 1 + res ) ; }
function minOperations ( A , B , N ) { let cnt = 0 ; let i = 0 ; while ( i < N ) { let j = 0 ; while ( j < N && i < N ) { if ( B [ i ] == A [ j ] ) { i ++ ; } j ++ ; } cnt ++ ; } return cnt ; }
function countPairs ( N ) { let res = 0 ; for ( let q = 1 ; q * q <= N ; q ++ ) { let maxP = Math . min ( 2 * N - q , N / q ) ; if ( maxP < q ) continue ; let cnt = maxP - q + 1 ; res += Math . floor ( cnt / 2 + ( cnt & 1 ) ) ; } return res ; }
function largestSubset ( a , N ) { let bit = new Array ( 32 ) . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { let x = 31 ; while ( a [ i ] > 0 ) { if ( a [ i ] & 1 == 1 ) { bit [ x ] ++ ; } a [ i ] = a [ i ] >> 1 ; x -- ; } } let max = Number . MIN_VALUE ; for ( let i = 0 ; i < 32 ; i ++ ) { max = Math . max ( max , bit [ i ] ) ; } document . write ( max ) ; }
function countDistinctSums ( N , L , R ) { let minSum = L * N ; let maxSum = R * N ; return maxSum - minSum + 1 ; }
function setSumtoZero ( arr , N ) { let A = new Array ( N ) ; let sum = 0 ; let m = Number . MIN_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { sum += Math . ceil ( arr [ i ] ) ; A [ i ] = Math . ceil ( arr [ i ] ) ; } if ( sum > 0 ) { m = Math . min ( sum , N ) ; for ( let i = 0 ; i < N && m > 0 ; i ++ ) { A [ i ] = Math . floor ( arr [ i ] ) ; if ( A [ i ] != Math . floor ( arr [ i ] ) ) m -- ; } } for ( let i = 0 ; i < N ; i ++ ) { document . write ( A [ i ] + "▁" ) ; } }
function countDivisors ( n ) { var divisors = 0 ; var i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) { divisors ++ ; } } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) { divisors ++ ; } } return divisors ; }
function possibleTriplets ( N ) { var count = 0 ; for ( var i = 1 ; i < N ; i ++ ) { count += countDivisors ( N - i ) ; } return count ; }
function convertToBase9 ( n ) { let ans = 0 ; let a = 1 ; while ( n > 0 ) { ans += a * ( n % 9 ) ; a *= 10 ; n = Math . floor ( n / 9 ) ; } return ans ; }
function getNthnumber ( base9 , K ) { let ans = 0 ; let a = 1 ; while ( base9 > 0 ) { let cur = base9 % 10 ; if ( cur >= K ) { ans += a * ( cur + 1 ) ; } else { ans += a * cur ; } base9 = Math . floor ( base9 / 10 ) ; a *= 10 ; } return ans ; }
function UniqueGeometricTerms ( N , a1 , r1 , a2 , r2 ) { let S = new Set ( ) ; let p1 = a1 ; for ( let i = 0 ; i < N ; i ++ ) { S . add ( p1 ) ; p1 = ( p1 * r1 ) ; } let p2 = a2 ; for ( let i = 0 ; i < N ; i ++ ) { S . add ( p2 ) ; p2 = ( p2 * r2 ) ; } return S . size ; }
function nearestLeft ( arr , N , steps ) { let L = - N ; for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { L = - ( N - i ) ; break ; } } for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { L = i ; } steps [ i ] = i - L ; } }
function findSum ( arr , N , M , K ) { let steps = new Array ( N ) ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum = sum + arr [ i ] ; } if ( sum == 0 ) { return 0 ; } nearestLeft ( arr , N , steps ) ; nearestRight ( arr , N , steps ) ; for ( let i = 0 ; i < N ; i ++ ) sum += 2 * K * Math . max ( 0 , M - steps [ i ] ) ; return sum ; }
function countPairs ( L , R ) { let cntPair = 0 ; for ( let a = L ; a <= R ; a ++ ) { for ( let b = a + 1 ; b <= R ; b ++ ) { let x = getProduct ( a ) ; let y = getProduct ( b ) ; if ( x && y && ( a * y ) == ( b * x ) ) { cntPair ++ ; } } } return cntPair ; }
function maxSum ( matrix ) { let r = matrix . length ; let c = matrix [ 0 ] . length ; let sum = 0 ; let mini = Number . MAX_VALUE ; let count = 0 ; for ( let i = 0 ; i < r ; i ++ ) { for ( let j = 0 ; j < c ; j ++ ) { let k = matrix [ i ] [ j ] ; mini = Math . min ( mini , Math . abs ( k ) ) ; if ( k < 0 ) count ++ ; sum += Math . abs ( k ) ; } } if ( count % 2 == 0 ) { return sum ; } else { return ( sum - 2 * mini ) ; } }
function highestPowerof2 ( n ) { let p = Math . floor ( Math . log2 ( n ) ) ; if ( p % 2 == 0 ) { p -= 1 } return Math . pow ( 2 , p ) }
function minStep ( N , X ) { if ( N % 2 != 0 && X == 0 ) return - 1  let size = 0  while ( X < N ) { N -= highestPowerof2 ( N )  size += 1 } if ( N != 0 ) size += 1  return size ; }
function transpose ( A , B ) { var i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }
function canPossibleReplacement ( N , arr ) { var S = 0 ; var i ; for ( i = 0 ; i < N ; i ++ ) S += arr [ i ] ; var P = 1 ; for ( i = 0 ; i < N ; i ++ ) { P *= i ; } for ( i = 0 ; i < N ; i ++ ) { var x = arr [ i ] ; var y = ( S - x ) / ( P / x - 1 ) ; if ( ( S - x + y ) == ( P * y ) / x ) return 1 ; } return 0 ; }
function positionAfterKJumps ( X , Y , K ) { let addY = Y * Math . floor ( K / 2 ) ; let reduceX = - 1 * X * ( Math . floor ( K / 2 ) + K % 2 ) ; return addY + reduceX ; }
function predictTheWinner ( K , N ) { if ( N % ( K + 1 ) == 0 ) document . write ( "Bob" ) ; else document . write ( "Alice" ) ; }
function countTriplets ( size , queries , arr , Q ) { let arr_even = new Array ( size + 1 ) ; let arr_odd = new Array ( size + 1 ) ; let even = 0 ; let odd = 0 ; arr_even [ 0 ] = 0 ; arr_odd [ 0 ] = 0 ; for ( let i = 0 ; i < size ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd ++ ; } else { even ++ ; } arr_even [ i + 1 ] = even ; arr_odd [ i + 1 ] = odd ; } for ( let i = 0 ; i < queries ; i ++ ) { let l = Q [ i ] [ 0 ] , r = Q [ i ] [ 1 ] ; odd = arr_odd [ r ] - arr_odd [ l - 1 ] ; even = arr_even [ r ] - arr_even [ l - 1 ] ; let ans = ( even * ( even - 1 ) * ( even - 2 ) ) / 6 + ( odd * ( odd - 1 ) / 2 ) * even ; document . write ( ans + "▁" ) ; } }
function transpose ( A ) { for ( i = 0 ; i < N ; i ++ ) for ( j = i + 1 ; j < N ; j ++ ) { var temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } }
function findMaxK ( N ) { let K = N ; for ( let i = N - 1 ; i >= 0 ; i -- ) { K &= i ; if ( K == 0 ) { return i ; } } return 0 ; }
function countPairs ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ j ] % arr [ i ] == 0 ) && ( j + 1 ) % ( i + 1 ) == 0 && ( arr [ j ] / arr [ i ] == ( j + 1 ) / ( i + 1 ) ) ) { count ++ ; } } } return count ; }
function smallestMaximum ( N , K ) { let sum = Math . floor ( ( N + K - 1 ) / K ) * K ; if ( sum % N != 0 ) return Math . floor ( sum / N ) + 1 ; else return Math . floor ( sum / N ) ; }
function findMinMax ( a ) { let min_val = 1000000000 ; for ( let i = 1 ; i < a . length ; ++ i ) { min_val = Math . min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; }
function add ( A , B , C ) { let i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; }
function nCr ( n , r , f ) { if ( n < r ) { return 0 ; } return f [ n ] / ( f [ r ] * f [ n - r ] ) ; }
function Min_sum ( arr , N ) { let min_sum = 1000000 , maxGcd = 1 ; for ( let i = 0 ; i < N ; i ++ ) { let gcd ; if ( i == 0 ) gcd = arr [ 1 ] ; else { gcd = arr [ i - 1 ] ; } for ( let j = 0 ; j < N ; j ++ ) { if ( j != i ) gcd = gcdOfTwoNos ( gcd , arr [ j ] ) ; } let c = arr [ i ] ; if ( gcd > maxGcd ) maxGcd = gcd ; } return maxGcd ; }
function performQuery ( arr , Q ) { for ( let i = 0 ; i < Q . length ; i ++ ) { let or = 0 ; let x = Q [ i ] [ 0 ] ; arr [ x - 1 ] = Q [ i ] [ 1 ] ; for ( let j = 0 ; j < arr . length ; j ++ ) { or = or | arr [ j ] ; } document . write ( or + "▁" ) ; } }
function subtract ( A , B , C ) { var i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }
function countOddIntegers ( arr , N ) { let Fact = new Array ( N ) ; Fact [ 0 ] = 1 ; for ( let i = 1 ; i < N ; i ++ ) { Fact [ i ] = i * Fact [ i - 1 ] ; } let freq = new Array ( 10 ) . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } let ans = 0 ; for ( let i = 1 ; i <= 9 ; i += 2 ) { if ( ! freq [ i ] ) { continue ; } freq [ i ] -- ; for ( let j = 1 ; j <= 9 ; j ++ ) { let cur_ans = 0 ; if ( freq [ j ] == 0 ) { continue ; } freq [ j ] -- ; cur_ans = Fact [ N - 2 ] ; for ( let k = 0 ; k <= 9 ; k ++ ) { cur_ans = Math . floor ( cur_ans / Fact [ freq [ k ] ] ) ; } ans = ans + cur_ans ; freq [ j ] ++ ; } freq [ i ] ++ ; } return ans ; }
function intCount ( X , K ) { let ans = 0 ; for ( let z = 0 ; z < Math . pow ( 10 , K ) ; z += Math . floor ( ( Math . pow ( 10 , K ) - 1 ) / 9 ) ) { if ( z > X ) break ; ans += Math . floor ( ( ( X - z ) / Math . pow ( 10 , K ) + 1 ) ) ; } return ans ; }
function intCountInRange ( L , R , K ) { return ( intCount ( R , K ) - intCount ( L - 1 , K ) ) ; }
function findSum ( root , target , K ) { kDistanceSum ( root , target , K , sum ) ; document . write ( sum ) ; }
function CountPair ( arr , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let val = arr [ i ] + sumOfDigits ( arr [ i ] ) ; if ( mp . has ( val ) ) { mp . set ( val , mp . get ( val ) + 1 ) ; } else { mp . set ( val , 1 ) ; } } let count = 0 ; for ( let [ key , value ] of mp ) { count = count + ( value * ( value - 1 ) ) / 2 ; } return count ; }
function isValid ( x , y1 , y2 ) { return ( x >= 0 && x < R && y1 >= 0 && y1 < C && y2 >= 0 && y2 < C ) ; }
function getMaxUtil ( arr , mem , x , y1 , y2 ) { if ( ! isValid ( x , y1 , y2 ) ) return Number . MIN_VALUE ; if ( x == R - 1 && y1 == 0 && y2 == C - 1 ) return ( y1 == y2 ) ? arr [ x ] [ y1 ] : arr [ x ] [ y1 ] + arr [ x ] [ y2 ] ; if ( x == R - 1 ) return Number . MIN_VALUE ; if ( mem [ x ] [ y1 ] [ y2 ] != - 1 ) return mem [ x ] [ y1 ] [ y2 ] ; var ans = Number . MIN_VALUE ; var temp = ( y1 == y2 ) ? arr [ x ] [ y1 ] : arr [ x ] [ y1 ] + arr [ x ] [ y2 ] ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 - 1 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 + 1 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 - 1 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 + 1 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 - 1 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 + 1 ) ) ; return ( mem [ x ] [ y1 ] [ y2 ] = ans ) ; }
function geMaxCollection ( arr ) { var mem = Array ( R ) . fill ( ) . map ( ( ) => Array ( C ) . fill ( ) . map ( ( ) => Array ( C ) . fill ( 0 ) ) ) ; for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { for ( l = 0 ; l < C ; l ++ ) mem [ i ] [ j ] [ l ] = - 1 ; } } return getMaxUtil ( arr , mem , 0 , 0 , C - 1 ) ; }
function printFactors ( n ) { for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { let d1 = i , d2 = n ; while ( d2 % d1 == 0 ) { d2 = Math . floor ( d2 / d1 ) ; } if ( d1 > 1 && d2 > 1 ) { document . write ( d1 + ",▁" + d2 ) ; return ; } } } document . write ( - 1 ) ; }
function countTriplets ( arr , n ) { let odd = 0 , even = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; else even ++ ; } let c1 = Math . floor ( odd * ( even * ( even - 1 ) ) / 2 ) ; let c2 = Math . floor ( ( odd * ( odd - 1 ) * ( odd - 2 ) ) / 6 ) ; return c1 + c2 ; }
function maxUniqueElements ( A , N ) { let mp = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( mp . has ( A [ i ] ) ) { mp . set ( mp . get ( A [ i ] ) , mp . get ( A [ i ] ) + 1 ) ; } else { mp . set ( A [ i ] , 1 ) ; } } let cnt = 0 ; for ( let [ key , value ] of mp ) { if ( value % 2 == 0 ) { cnt ++ ; } } let ans = mp . size ; if ( cnt % 2 == 1 ) { ans -- ; } return ans ; }
function countCells ( n , m , s ) { let mx1 = - 1 ; let cont1 = 0 ; for ( let i = 0 ; i < s && i < n ; ++ i ) { let aux = Math . floor ( ( n - ( i + 1 ) ) / s + 1 ) ; if ( aux > mx1 ) { mx1 = cont1 = aux ; } else if ( aux == mx1 ) cont1 += aux ; } let mx2 = - 1 ; let cont2 = 0 ; for ( let i = 0 ; i < s && i < m ; ++ i ) { let aux = Math . floor ( ( m - ( i + 1 ) ) / s + 1 ) ; if ( aux > mx2 ) mx2 = cont2 = aux ; else if ( aux == mx2 ) cont2 += aux ; } return cont1 * cont2 ; }
function build_tree ( b , seg_tree , l , r , vertex ) { if ( l == r ) { seg_tree [ vertex ] = b [ l ] ; return ; } let mid = Math . floor ( ( l + r ) / 2 ) ; build_tree ( b , seg_tree , l , mid , 2 * vertex ) ; build_tree ( b , seg_tree , mid + 1 , r , 2 * vertex + 1 ) ; seg_tree [ vertex ] = __gcd ( seg_tree [ 2 * vertex ] , seg_tree [ 2 * vertex + 1 ] ) ; }
function range_gcd ( seg_tree , v , tl , tr , l , r ) { if ( l > r ) return 0 ; if ( l == tl && r == tr ) return seg_tree [ v ] ; let tm = Math . floor ( ( tl + tr ) / 2 ) ; return __gcd ( range_gcd ( seg_tree , 2 * v , tl , tm , l , Math . min ( tm , r ) ) , range_gcd ( seg_tree , 2 * v + 1 , tm + 1 , tr , Math . max ( tm + 1 , l ) , r ) ) ; }
function maxSubarrayLen ( arr , n ) { let seg_tree = new Array ( 4 * n + 1 ) . fill ( 0 ) ; build_tree ( arr , seg_tree , 0 , n - 1 , 1 ) ; let maxLen = 0 ; let l = 0 , r = 0 ; while ( r < n && l < n ) { if ( range_gcd ( seg_tree , 1 , 0 , n - 1 , l , r ) == 1 ) { l ++ ; } maxLen = Math . max ( maxLen , r - l + 1 ) ; r ++ ; } document . write ( maxLen ) ; }
function can_empty ( a , b , c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { let m = Math . min ( a , Math . min ( b , c ) ) ; if ( m < Math . floor ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
function countTotalPairs ( N , K ) { if ( K == 0 ) { return N * N ; } let ans = 0 ; for ( let b = K + 1 ; b <= N ; b ++ ) { ans += Math . floor ( ( N / b ) * ( b - K ) ) ; ans += Math . max ( N % b - K + 1 , 0 ) ; } return ans ; }
function maxFrequencySubarrayUtil ( A , N , M ) { let m = new Map ( ) ; let val = 0 ; for ( let i = 0 ; i < M ; i ++ ) { if ( m . has ( A [ i ] ) ) { m . set ( m . get ( A [ i ] ) , m . get ( A [ i ] ) + 1 ) ; } else { m . set ( A [ i ] , 1 ) ; } val = Math . max ( val , m . get ( A [ i ] ) ) ; } document . write ( val + "▁" ) ; for ( i = M ; i < N ; i ++ ) { if ( m . has ( A [ i - m ] ) ) m . set ( m . get ( A [ i - M ] ) , m . get ( A [ i - M ] ) - 1 ) ; if ( m . has ( A [ i ] ) ) m . set ( m . get ( A [ i ] ) , m . get ( A [ i ] ) + 1 ) ; val = 0 ; for ( let [ key , value ] of m ) { val = Math . max ( val , value ) ; } document . write ( val + "▁" ) ; } }
function smallest ( k , d ) { let cnt = 1 ; let m = d % k ; let v = new Array ( k ) . fill ( 0 ) ; v [ m ] = 1 ; while ( 1 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return - 1 ; v [ m ] = 1 ; cnt ++ ; } return - 1 ; }
function getPairsCount ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && Math . abs ( arr [ i ] - arr [ j ] ) >= Math . min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
function minSteps ( N ) { let count = 1 , res = 0 ; for ( let i = 1 ; i <= N ; i += count ) { res = Math . max ( res , count ) ; count ++ ; } return res ; }
function countReachablePoints ( X , Y , L , R ) { let diff_arr = new Array ( 100000 ) . fill ( 0 ) ; let count = 0 ; diff_arr [ X ] = 1 ; diff_arr [ X + 1 ] = - 1 ; for ( let i = X ; i <= Y ; i ++ ) { diff_arr [ i ] += diff_arr [ i - 1 ] ; if ( diff_arr [ i ] >= 1 ) { diff_arr [ i + L ] += 1 ; diff_arr [ i + R + 1 ] -= 1 ; count ++ ; } } return count ; }
function minimumSubarray ( arr , n , m ) { let mapu = new Array ( m + 1 ) . fill ( 0 ) ; let c = 0 ; for ( let i = 0 ; i < n ; i ++ ) { mapu [ arr [ i ] ] ++ ; if ( mapu [ arr [ i ] ] == ( n / m ) + 1 ) c ++ ; } if ( c == 0 ) return 0 ; let ans = n ; let l = 0 , r = 0 ; while ( r < n ) { if ( -- mapu [ arr [ r ] ] == ( n / m ) ) c -- ; if ( c == 0 ) { while ( l <= r && c == 0 ) { ans = Math . min ( ans , r - l + 1 ) ; if ( ++ mapu [ arr [ l ] ] > ( n / m ) ) c ++ ; l ++ ; } } r ++ ; } return ans ; }
function findAandB ( N ) { let K = Math . log2 ( N ) ; let B = ( 1 << K ) ; let A = B ^ N ; document . write ( A + "▁" + B ) ; }
function pathCountRec ( mat , m , n , k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ) ; return pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; }
function pathCount ( mat , k ) { return pathCountRec ( mat , R - 1 , C - 1 , k ) ; }
function minDistance ( start , intend , n , d ) { let left = Number . MIN_SAFE_INTEGER ; let right = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) { left = Math . max ( left , start [ i ] ) ; right = Math . min ( right , end [ i ] ) ; } if ( left > right ) return - 1 ; if ( d >= left && d <= right ) return 0 ; if ( d < left ) return left - d ; if ( d > right ) return d - right ; }
function power ( x , y ) { if ( y == 0 ) return 1 ; if ( y % 2 == 0 ) return power ( x , Math . floor ( y / 2 ) ) * power ( x , Math . floor ( y / 2 ) ) ; return x * power ( x , Math . floor ( y / 2 ) ) * power ( x , Math . floor ( y / 2 ) ) ; }
function order ( num ) { let count = 0 ; while ( num ) { count ++ ; num = Math . floor ( num / 10 ) ; } return count ; }
function isArmstrong ( N ) { let r = order ( N ) ; let temp = N , sum = 0 ; while ( temp ) { let d = temp % 10 ; sum += power ( d , r ) ; temp = Math . floor ( temp / 10 ) ; } return sum == N ; }
function maxSum ( arr , N , K ) { if ( N < K ) { return - 1 ; } let res = 0 ; for ( let i = 0 ; i < K ; i ++ ) { res += arr [ i ] ; } let curr_sum = res ; for ( let i = K ; i < N ; i ++ ) { curr_sum += arr [ i ] - arr [ i - K ] ; res = Math . max ( res , curr_sum ) ; } return res ; }
function maxArmstrong ( arr , N , K ) { for ( let i = 0 ; i < N ; i ++ ) { arr [ i ] = isArmstrong ( arr [ i ] ) ; } return maxSum ( arr , N , K ) ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function printArr ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; let minDifference = Number . MAX_SAFE_INTEGER ; let minIndex = - 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( minDifference > Math . abs ( arr [ i ] - arr [ i - 1 ] ) ) { minDifference = Math . abs ( arr [ i ] - arr [ i - 1 ] ) ; minIndex = i - 1 ; } } let Arr = new Array ( n ) ; Arr [ 0 ] = arr [ minIndex ] ; Arr [ n - 1 ] = arr [ minIndex + 1 ] ; let pos = 1 ; for ( let i = minIndex + 2 ; i < n ; i ++ ) { Arr [ pos ++ ] = arr [ i ] ; } for ( let i = 0 ; i < minIndex ; i ++ ) { Arr [ pos ++ ] = arr [ i ] ; } for ( let i = 0 ; i < n ; i ++ ) { document . write ( Arr [ i ] + "▁" ) ; } }
function findValuesOfK ( g ) { var count = 0 ; for ( var i = 1 ; i * i <= g ; i ++ ) { if ( g % i == 0 ) { if ( i != g / i ) { if ( i % 2 == 1 ) { count ++ ; } if ( ( g / i ) % 2 == 1 ) { count ++ ; } } else if ( i % 2 == 1 ) { count ++ ; } } } document . write ( count ) ; }
function fact ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { res = res * i ; } return res ; }
function nCr ( n , r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
function countPairs ( arr , N ) { let answer = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] + arr [ j ] == i + j ) { answer ++ ; } } } document . write ( answer ) ; }
function pathCountDPRecDP ( mat , m , n , k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ? 1 : 0 ) ; if ( dp [ m ] [ n ] [ k ] != - 1 ) return dp [ m ] [ n ] [ k ] ; dp [ m ] [ n ] [ k ] = pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; return dp [ m ] [ n ] [ k ] ; }
function checkDistribution ( R , B , D ) { if ( Math . max ( R , B ) <= Math . min ( R , B ) * ( D + 1 ) ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function itemType ( n ) { let count = 0 ; for ( let day = 1 ; ; day ++ ) { for ( let type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } }
function primeFactor ( N ) { let v = [ ] ; let count = 0 ; while ( ! ( N % 2 ) ) { N >>= 1 ; count ++ ; } if ( count ) v . push ( [ 2 , count ] ) ; for ( let i = 3 ; i <= Math . sqrt ( N ) ; i += 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = Math . floor ( N / i ) ; } if ( count ) { v . push ( [ i , count ] ) ; } } if ( N > 2 ) v . push ( [ N , 1 ] ) ; return v ; }
function ABS ( x ) { return Math . max ( x , - x ) ; }
function isvalid ( i , j ) { if ( i < 0 j < 0 i >= R j >= C ) return false ; return true ; }
function getLenUtil ( mat , i , j , prev ) { if ( ! isvalid ( i , j ) || ! isadjacent ( prev , mat [ i ] [ j ] ) ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; let ans = 0 ; for ( let k = 0 ; k < 8 ; k ++ ) ans = Math . max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , mat [ i ] [ j ] ) ) ; return dp [ i ] [ j ] = ans ; }
function BaseConversion ( N ) { let s = "" ; while ( N != 0 ) { if ( N % 2 == 0 ) { s = "0" + s ; } else { s = "1" + s ; N -- ; } N /= - 2 ; } if ( s == "" ) { s = "0" ; } return s ; }
function check ( N ) { var twos = 0 , fives = 0 ; while ( N % 2 == 0 ) { N /= 2 ; twos ++ ; } while ( N % 5 == 0 ) { N /= 5 ; fives ++ ; } if ( N == 1 && twos <= fives ) { document . write ( 2 * fives - twos ) ; } else { document . write ( - 1 ) ; } }
function isMakeZero ( arr , N , K ) { let MP = new Map ( ) ; let V = [ ] ; let X = 1 ; let i ; while ( X > 0 && X < Number . MAX_VALUE ) { V . push ( X ) ; X *= K ; } for ( i = 0 ; i < N ; i ++ ) { for ( let j = V . length - 1 ; j >= 0 ; j -- ) { if ( MP . has ( V [ j ] ) == false && V [ j ] <= arr [ i ] ) { arr [ i ] -= V [ j ] ; MP . set ( V [ j ] , 1 ) ; } } if ( arr [ i ] != 0 ) break ; } if ( i < N ) return "No" ; else return "Yes" ; }
function countOperations ( N , M ) { let visited = new Array ( 100001 ) ; let Q = [ ] ; Q . push ( [ N , 0 ] ) ; visited [ N ] = true ; while ( Q . length > 0 ) { let aux = Q [ 0 ] [ 0 ] ; let cont = Q [ 0 ] [ 1 ] ; Q . shift ( ) ; if ( aux == M ) return cont ; for ( let i = 2 ; i * i <= aux ; i ++ ) if ( aux % i == 0 ) { if ( aux + i <= M && ! visited [ aux + i ] ) { Q . push ( [ aux + i , cont + 1 ] ) ; visited [ aux + i ] = true ; } if ( aux + parseInt ( aux / i , 10 ) <= M && ! visited [ aux + parseInt ( aux / i , 10 ) ] ) { Q . push ( [ aux + parseInt ( aux / i , 10 ) , cont + 1 ] ) ; visited [ aux + parseInt ( aux / i , 10 ) ] = true ; } } } return - 1 ; }
function Avgdifference ( arr , N , K ) { let min = 1000000 , max = - 1 ; for ( let i = 0 ; i <= N - K ; i ++ ) { let sum = 0 ; for ( let j = 0 ; j < K ; j ++ ) { sum += arr [ i + j ] ; } if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
function Avgdifference ( arr , N , K ) { let sum = 0 ; for ( let i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; let min = sum ; let max = sum ; for ( let i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
function minimumElement ( arr , N , K ) { let minElement = arr [ 0 ] ; for ( let i = 0 ; i < N ; ++ i ) { minElement = Math . min ( minElement , arr [ i ] ) ; } let reqOperations = 0 ; for ( let i = 0 ; i < N ; ++ i ) { reqOperations += arr [ i ] - minElement ; } if ( reqOperations < K ) { K -= reqOperations ; minElement -= Math . floor ( ( K + N - 1 ) / N ) ; } return minElement ; }
function FractionSplit ( n , d ) { let UnitFactions = [ ] ; while ( n > 0 ) { let x = Math . floor ( ( d + n - 1 ) / n ) ; let s = "1/" + String ( x ) ; UnitFactions . push ( s ) ; n = n * x - d ; d = d * x ; } return UnitFactions ; }
function findPermutation ( N ) { var i ; var arr = new Array ( N ) ; for ( i = 0 ; i < N ; i ++ ) { arr [ i ] = i + 1 ; } for ( i = 1 ; i < N ; i += 2 ) { var temp = arr [ i ] ; arr [ i ] = arr [ i - 1 ] ; arr [ i - 1 ] = temp ; } if ( N % 2 == 1 && N > 1 ) { var temp = arr [ N - 1 ] ; arr [ N - 1 ] = arr [ N - 2 ] ; arr [ N - 2 ] = temp ; } for ( i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function rangeSum ( arr , N , L , R ) { let sum = 0 ; for ( let i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } document . write ( sum ) ; }
function rangeSum ( arr , N , L , R ) { let prefix = new Array ( N + 1 ) ; prefix [ 0 ] = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } let leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; let rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; document . write ( rightsum - leftsum ) ; }
function addAP ( A , Q , operations ) { for ( let Q of operations ) { let L = Q [ 0 ] , R = Q [ 1 ] , a = Q [ 2 ] , d = Q [ 3 ] curr = a for ( let i = L - 1  ; i < R ; i ++ ) { A [ i ] += curr curr += d } } for ( let i of A ) { document . write ( i + "▁" ) } }
function maximizeNumber ( N , K ) { let s = String ( N ) ; let L = s . length ; let result = [ ] ; let i = 0 ; while ( ( i < L ) && ( K <= ( s [ i ] . charCodeAt ( 0 ) - "" . charCodeAt ( 0 ) ) ) ) { result . push ( s [ i ] ) ; ++ i ; } result . push ( String . fromCharCode ( K + "0" . charCodeAt ( 0 ) ) ) ; while ( i < L ) { result . push ( s [ i ] ) ; ++ i ; } document . write ( result . join ( "0" ) ) ; }
function countArrays ( N , K ) { document . write ( power ( N , K ) ) ; }
function minimumDistance ( arr , N ) { let ind = 0 ; let prev = arr [ ind ] ; let s = arr . length ; for ( let i = 0 ; i < N ; i ++ ) { let distance = Number . MAX_SAFE_INTEGER ; if ( i < arr [ 0 ] ) { distance = arr [ 0 ] - i ; } else if ( i >= prev && ind + 1 < s && i <= arr [ ind + 1 ] ) { distance = Math . min ( i - prev , arr [ ind + 1 ] - i ) ; if ( i == arr [ ind + 1 ] ) { distance = 0 ; prev = arr [ ind + 1 ] ; ind ++ ; } } else { distance = i - prev ; } document . write ( distance + "▁" ) ; } }
function countOfPairs ( arr , N , X ) { let count = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( ( ( arr [ i ] ^ arr [ j ] ) & X ) == 0 ) count ++ ; } } return count ; }
function countOfPairs ( arr , N , X ) { let count = 0 ; let M = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( M . has ( arr [ i ] & X ) ) { M . set ( arr [ i ] & X , M . get ( arr [ i ] & X ) + 1 ) ; } else { M . set ( arr [ i ] & X , 1 ) ; } } for ( let m of M ) { let p = m [ 1 ] ; count += ( p * ( p - 1 ) ) / 2 ; } return count ; }
function ConcatenateArr ( arr , N ) { let ans = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { let l = Math . floor ( Math . log10 ( arr [ i ] ) + 1 ) ; ans = ans * Math . pow ( 10 , l ) ; ans += arr [ i ] ; } return ans ; }
function countXor ( N ) { let cnt = Math . floor ( N / 2 ) + 1 ; return cnt ; }
function DistRecursion ( S , i , dist ) { if ( i == S . length ) return Math . abs ( dist ) ; if ( S [ i ] == "L" ) return DistRecursion ( S , i + 1 , dist - 1 ) ; if ( S [ i ] == "R" ) return DistRecursion ( S , i + 1 , dist + 1 ) ; return Math . max ( DistRecursion ( S , i + 1 , dist - 1 ) , DistRecursion ( S , i + 1 , dist + 1 ) ) ; }
function maxDistance ( S ) { return DistRecursion ( S , 0 , 0 ) ; }
function isPerfect ( N ) { let sum = 1 ; for ( let i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( i * i != N ) sum = sum + i + Math . floor ( N / i ) ; else sum = sum + i ; } } if ( sum == N && N != 1 ) return true ; return false ; }
function Query ( arr , N ) { let prefix = new Array ( MAX + 1 ) . fill ( 0 ) ; for ( let i = 2 ; i <= MAX ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + isPerfect ( i ) ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( prefix [ arr [ i ] [ 1 ] ] - prefix [ arr [ i ] [ 0 ] - 1 ] + "▁" ) ; } }
function ExpoFactorial ( N ) { let res = 1 ; let mod = 1000000007 ; for ( let i = 2 ; i < N + 1 ; i ++ ) res = Math . pow ( i , res ) % mod ; return res ; }
function maxSubArraySumRepeated ( arr , N , K ) { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; let curr = arr [ 0 ] ; let ans = arr [ 0 ] ; if ( K == 1 ) { for ( let i = 1 ; i < N ; i ++ ) { curr = Math . max ( arr [ i ] , curr + arr [ i ] ) ; ans = Math . max ( ans , curr ) ; } return ans ; } let V = [ ] ; for ( let i = 0 ; i < 2 * N ; i ++ ) { V . push ( arr [ i % N ] ) ; } let maxSuf = V [ 0 ] ; let maxPref = V [ 2 * N - 1 ] ; curr = V [ 0 ] ; for ( let i = 1 ; i < 2 * N ; i ++ ) { curr += V [ i ] ; maxPref = Math . max ( maxPref , curr ) ; } curr = V [ 2 * N - 1 ] ; for ( let i = 2 * N - 2 ; i >= 0 ; i -- ) { curr += V [ i ] ; maxSuf = Math . max ( maxSuf , curr ) ; } curr = V [ 0 ] ; for ( let i = 1 ; i < 2 * N ; i ++ ) { curr = Math . max ( V [ i ] , curr + V [ i ] ) ; ans = Math . max ( ans , curr ) ; } if ( sum > 0 ) { let temp = sum * ( K - 2 ) ; ans = Math . max ( ans , Math . max ( temp + maxPref , temp + maxSuf ) ) ; } return ans ; }
function factorial ( n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
function numOfNecklace ( N ) { var ans = factorial ( N ) / ( factorial ( N / 2 ) * factorial ( N / 2 ) ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans /= 2 ; return ans ; }
function nthNumber ( n ) { let divs = new Array ( 1000000 ) ; for ( var i = 0 ; i < divs . length ; i ++ ) { divs [ i ] = 0 ; } let vis = new Array ( 1000000 ) ; for ( var i = 0 ; i < vis . length ; i ++ ) { vis [ i ] = 0 ; } let cnt = 0 ; for ( let i = 2 ; cnt < n ; i ++ ) { if ( divs [ i ] == 0 ) { for ( let j = 2 * i ; j < 1000000 ; j += i ) { if ( vis [ j ] ) { continue ; } vis [ j ] = true ; let currNum = j ; let count = 0 ; while ( currNum % i == 0 ) { divs [ j ] ++ ; currNum = Math . floor ( currNum / i ) ; count ++ ; } if ( currNum == 1 && count == 3 && divs [ j ] == 3 ) { cnt ++ ; } else if ( currNum != 1 && divs [ currNum ] == 0 && count == 1 && divs [ j ] == 1 ) { cnt ++ ; } if ( cnt == n ) { return j ; } } } } return - 1 ; }
function findkey ( A , B , C ) { let ans = 0 ; let cur = 1 ; while ( A > 0 ) { let a = A % 10 ; let b = B % 10 ; let c = C % 10 ; A = Math . floor ( A / 10 ) ; B = Math . floor ( B / 10 ) ; C = Math . floor ( C / 10 ) ; let m = Math . max ( a , Math . max ( c , b ) ) ; ans += cur * m ; cur = cur * 10 ; } return ans ; }
function SumOfPrimeDivisors ( n ) { let sum = 0 ; if ( n % 2 == 0 ) { sum = sum + 2 ; } while ( n % 2 == 0 ) { n = n / 2 ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { sum = sum + i ; } while ( n % i == 0 ) { n = n / i ; } } if ( n > 2 ) { sum = sum + n ; } return sum ; }
function countNumbers ( l , r ) { let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { if ( ( i & 1 ) == 0 ) { count ++ ; } } return count ; }
function countNumbers ( l , r ) { return ( parseInt ( r / 2 ) - parseInt ( ( l - 1 ) / 2 ) ) ; }
function isPerfectSquare ( x ) { let s = parseInt ( Math . sqrt ( x ) ) ; return ( s * s == x ) ; }
function isFibonacci ( n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
function contiguousFibonacciNumber ( arr , n ) { let current_length = 0 ; let max_length = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isFibonacci ( arr [ i ] ) ) { current_length ++ ; } else { current_length = 0 ; } max_length = Math . max ( max_length , current_length ) ; } return max_length ; }
function Kadane ( arr , n ) { let largestSum = 0 , currMax = 0 ; let currSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { currSum += arr [ i ] ; currMax = Math . max ( currMax , arr [ i ] ) ; largestSum = Math . max ( largestSum , currMax * currSum ) ; if ( currSum < 0 ) { currMax = 0 ; currSum = 0 ; } } return largestSum ; }
function maximumWeight ( arr , n ) { let largestSum = Kadane ( arr , n ) ; for ( let i = 0 ; i < n ; i ++ ) { arr [ i ] = - arr [ i ] ; } largestSum = Math . max ( largestSum , Kadane ( arr , n ) ) ; return largestSum ; }
function evenOdd ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let even_digits = 0 ; let odd_digits = 0 ; let temp = arr [ i ] ; while ( temp ) { if ( ( temp % 10 ) & 1 ) odd_digits ++ ; else even_digits ++ ; temp = parseInt ( temp / 10 ) } if ( even_digits > odd_digits ) { let res = 0 ; while ( arr [ i ] ) { res += arr [ i ] % 10 ; arr [ i ] = parseInt ( arr [ i ] / 10 ) ; } document . write ( res + "▁" ) ; } else if ( odd_digits > even_digits ) { let res = 1 ; while ( arr [ i ] ) { res *= arr [ i ] % 10 ; arr [ i ] = parseInt ( arr [ i ] / 10 ) } document . write ( res + "▁" ) ; } else document . write ( arr [ i ] + "▁" ) ; } }
function sumOfFirstM ( A , N , M ) { let sum = 0 ; for ( let i = 0 ; i < M ; i ++ ) { sum = sum + A [ i % N ] ; } return sum ; }
function findSmallestNumK ( n ) { let cummAnd = n ; let i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return - 1 ; }
function findMinInsertions ( str , l , h ) { if ( l > h ) return Number . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Math . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) }
function canReach0toM ( a , n , m ) { let rightMost = new Array ( m + 1 ) ; let dp = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; i ++ ) { rightMost [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { let a1 = a [ i ] [ 0 ] ; let b1 = a [ i ] [ 1 ] ; rightMost [ a1 ] = Math . max ( rightMost [ a1 ] , b1 ) ; } for ( let i = m ; i >= 0 ; i -- ) { dp [ i ] = i ; for ( let j = Math . min ( m , rightMost [ i ] ) ; j > i ; j -- ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j ] ) ; } } if ( dp [ 0 ] >= m ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function countPairs ( arr , N ) { for ( var i = 0 ; i < N ; i ++ ) { var count = 0 ; for ( var x = 1 ; x <= arr [ i ] ; x ++ ) { for ( var y = x ; y <= arr [ i ] ; y ++ ) { if ( gcd ( x , y ) > 1 ) count ++ ; } } document . write ( count + "▁" ) ; } }
function maximumTurns ( arr , N ) { let Count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { while ( arr [ i ] % 2 == 0 ) { Count ++ ; arr [ i ] = Math . floor ( arr [ i ] / 2 ) ; } } return Count ; }
function findSet ( N , K ) { let a = [ ] ; for ( let i = 1 ; i <= N ; i ++ ) { if ( i != K ) a . push ( i ) ; } let MaxDistinct = ( N - K ) + parseInt ( K / 2 ) ; a . reverse ( ) ; for ( let i = 0 ; i < MaxDistinct ; i ++ ) document . write ( a [ i ] + "▁" ) ; }
function linearCongruence ( A , B , N ) { A = A % N ; B = B % N ; let u = 0 , v = 0 ; let person = ExtendedEuclidAlgo ( A , N ) ; let d = person [ 0 ] ; u = person [ 1 ] ; v = person [ 2 ] ; if ( B % d != 0 ) { document . write ( - 1 ) ; return ; } let x0 = ( u * ( B / d ) ) % N ; if ( x0 < 0 ) x0 += N ; for ( let i = 0 ; i <= d - 1 ; i ++ ) { let an = ( x0 + i * ( N / d ) ) % N ; document . write ( an + "▁" ) ; } }
function distinctGCDs ( arr , N ) { let M = - 1 , ans = 0 ; var Mp = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { M = Math . max ( M , arr [ i ] ) ; Mp . set ( arr [ i ] , 1 ) ; } for ( let i = 1 ; i <= M ; i ++ ) { let currGcd = 0 ; for ( let j = i ; j <= M ; j += i ) { if ( Mp . has ( j ) ) { currGcd = gcd ( currGcd , j ) ; if ( currGcd == i ) { ans ++ ; break ; } } } } return ans ; }
function GCD ( a , b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
function countSubarray ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let mxSubarray = 0 ; let mxOther = 0 ; for ( let k = i ; k <= j ; k ++ ) { mxSubarray = Math . max ( mxSubarray , arr [ k ] ) ; } for ( let k = 0 ; k < i ; k ++ ) { mxOther = Math . max ( mxOther , arr [ k ] ) ; } for ( let k = j + 1 ; k < n ; k ++ ) { mxOther = Math . max ( mxOther , arr [ k ] ) ; } if ( mxSubarray > ( 2 * mxOther ) ) count ++ ; } } document . write ( count ) ; }
function countSubarray ( arr , n ) { var count = 0 , L = 0 , R = 0 ; var mx = Math . max . apply ( null , arr ) ; var i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] * 2 > mx ) { L = i ; break ; } } for ( i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] * 2 > mx ) { R = i ; break ; } } document . write ( ( L + 1 ) * ( n - R ) ) ; }
function factorialWithoutMul ( N ) { let ans = N ; for ( let i = N - 1 ; i > 0 ; i -- ) { let sum = 0 ; for ( let j = 0 ; j < i ; j ++ ) sum += ans ; ans = sum ; } return ans ; }
function isPrime ( X ) { for ( let i = 2 ; i * i <= X ; i ++ ) return false ; return true ; }
function countSetBits ( n ) { let count = 0 ; while ( n ) { n = n & ( n - 1 ) ; count ++ ; } return count ; }
function minOperations ( A , B ) { let cnt1 = 0 , cnt2 = 0 ; cnt1 += countSetBits ( A ) ; cnt2 += countSetBits ( B ) ; if ( ( cnt1 + cnt2 ) % 2 != 0 ) return - 1 ; let oneZero = 0 , zeroOne = 0 ; let ans = 0 ; for ( let i = 0 ; i < Math . max ( cnt1 , cnt2 ) ; i ++ ) { let bitpos = 1 << i ; if ( ( ! ( bitpos & A ) ) && ( bitpos & B ) ) zeroOne ++ ; if ( ( bitpos & A ) && ( ! ( bitpos & B ) ) ) oneZero ++ ; } ans = parseInt ( zeroOne / 2 ) + parseInt ( oneZero / 2 ) ; if ( zeroOne % 2 != 0 ) ans += 2 ; return ans ; }
function sieveSundaram ( ) { let marked = Array . from ( { length : MAX / 2 + 100 } , ( _ , i ) => 0 ) ; for ( let i = 1 ; i <= ( Math . floor ( Math . sqrt ( MAX ) - 1 ) ) / 2 ; i ++ ) for ( let j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . push ( 2 ) ; for ( let i = 1 ; i <= Math . floor ( MAX / 2 ) ; i ++ ) if ( marked [ i ] == false ) primes . push ( 2 * i + 1 ) ; }
function isSmithBrotherPair ( X , Y ) { return isSmith ( X ) && isSmith ( Y ) && Math . abs ( X - Y ) == 1 ; }
function countSmithBrotherPairs ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) { if ( isSmithBrotherPair ( A [ i ] , A [ j ] ) ) count ++ ; } return count ; }
function tripletAndSum ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { ans += arr [ i ] & arr [ j ] & arr [ k ] ; } } } document . write ( ans ) ; }
function countPairs ( arr , N ) { let count = 0 , totalSum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { totalSum += arr [ i ] ; } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( totalSum % ( arr [ i ] + arr [ j ] ) == 0 ) { count += 1 ; } } } document . write ( count ) ; }
function countOfBase ( N ) { let count = 0 ; for ( let i = 2 ; i <= N ; ++ i ) { let highestPower = parseInt ( Math . log ( N ) / Math . log ( i ) ) ; let firstDigit = parseInt ( N / Math . pow ( i , highestPower ) ) ; if ( firstDigit == 1 ) { ++ count ; } } return count ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
function PermuteAndFind ( power , idx , SumSoFar , target ) { if ( idx == power . length ) { if ( SumSoFar == target ) return true ; return false ; } let select = PermuteAndFind ( power , idx + 1 , SumSoFar , target ) ; let notselect = PermuteAndFind ( power , idx + 1 , SumSoFar + power [ idx ] , target ) ; return select || notselect ; }
function DistinctPowersOf3 ( N ) { let power = new Array ( 16 ) ; power [ 0 ] = 1 ; for ( let i = 1 ; i < 16 ; i ++ ) power [ i ] = 3 * power [ i - 1 ] ; let found = PermuteAndFind ( power , 0 , 0 , N ) ; if ( found == true ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function PrimeFactor ( N ) { let primef = new Map ( ) ; while ( N % 2 == 0 ) { if ( primef . has ( 2 ) ) { primef . set ( 2 , primef . get ( 2 ) + 1 ) ; } else { primef . set ( 2 , 1 ) ; } N = parseInt ( N / 2 , 10 ) ; } for ( let i = 3 ; i <= Math . sqrt ( N ) ; i ++ ) { while ( N % i == 0 ) { if ( primef . has ( i ) ) { primef . set ( i , primef . get ( i ) + 1 ) ; } else { primef . set ( i , 1 ) ; } N = parseInt ( N / 2 , 10 ) ; } } if ( N > 2 ) { primef [ N ] = 1 ; } return primef ; }
function CountToMakeEqual ( X , Y ) { let gcdofXY = gcd ( X , Y ) ; let newX = parseInt ( Y / gcdofXY , 10 ) ; let newY = parseInt ( X / gcdofXY , 10 ) ; let primeX = PrimeFactor ( newX ) ; let primeY = PrimeFactor ( newY ) ; let ans = 0 ; primeX . forEach ( ( values , keys ) => { if ( X % keys != 0 ) { return - 1 ; } ans += primeX . get ( keys ) ; } )  ans += 1 ; primeY . forEach ( ( values , keys ) => { if ( Y % keys != 0 ) { return - 1 ; } ans += primeY . get ( keys ) ; } )  return ans ; }
function maximumSubsequenceSum ( A , N ) { var ans = 0 ; var mp = new Map ( ) ; var i ; for ( i = 0 ; i < N ; i ++ ) { if ( mp . has ( A [ i ] - i ) ) mp . set ( A [ i ] - i , mp . get ( A [ i ] - i ) + A [ i ] ) ; else mp . set ( A [ i ] - i , A [ i ] ) ; ans = Math . max ( ans , mp . get ( A [ i ] - i ) ) ; } document . write ( ans ) ; }
function getPermutation ( N ) { if ( N <= 3 ) { document . write ( - 1 ) ; return ; } let i = N ; if ( N % 2 == 0 ) i -- ; while ( i >= 1 ) { document . write ( i + "▁" ) ; i -= 2 ; } document . write ( 4 + "▁" + 2 + "▁" ) ; i = 6 ; while ( i <= N ) { document . write ( i + "▁" ) ; i += 2 ; } }
function gcd ( A , B ) { if ( B == 0 ) return A ; else return gcd ( B , A % B ) ; }
function getDistinctValues ( A , B , C ) { let g = gcd ( A , B ) ; let num_values = C / g ; return num_values ; }
function nearestPerfectSquare ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let sr = parseInt ( Math . sqrt ( arr [ i ] ) ) ; let a = sr * sr ; let b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) document . write ( a + "▁" ) ; else document . write ( b + "▁" ) ; } }
function currSubArrayScore ( a , b , l , r ) { let straightScore = 0 ; let reverseScore = 0 ; for ( let i = l ; i <= r ; i ++ ) { straightScore += a [ i ] * b [ i ] ; reverseScore += a [ r - ( i - l ) ] * b [ i ] ; } return Math . max ( straightScore , reverseScore ) ; }
function maxScoreSubArray ( a , b , n ) { let res = 0 , start = 0 , end = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let currScore = currSubArrayScore ( a , b , i , j ) ; if ( currScore > res ) { res = currScore ; start = i ; end = j ; } } } document . write ( res ) ; }
function maxScoreSubArray ( a , b , n ) { let res = 0 ; for ( let mid = 0 ; mid < n ; mid ++ ) { let straightScore = a [ mid ] * b [ mid ] , reverseScore = a [ mid ] * a [ mid ] ; let prev = mid - 1 , next = mid + 1 ; res = Math . max ( res , Math . max ( straightScore , reverseScore ) ) ; while ( prev >= 0 && next < n ) { straightScore += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverseScore += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = Math . max ( res , Math . max ( straightScore , reverseScore ) ) ; prev -- ; next ++ ; } straightScore = 0 ; reverseScore = 0 ; prev = mid - 1 , next = mid ; while ( prev >= 0 && next < n ) { straightScore += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverseScore += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = Math . max ( res , Math . max ( straightScore , reverseScore ) ) ; prev -- ; next ++ ; } } document . write ( res ) ; }
function minimumSizeSubarray ( arr , N ) { let i = 0 , j = N - 1 ; while ( i < N && arr [ i ] == 0 ) { i ++ ; } if ( i == N ) return 1 ; while ( j >= 0 && arr [ j ] == 0 ) { j -- ; } return ( j - i + 1 ) ; }
function countXorPartition ( N ) { let a = Math . pow ( 2 , Math . floor ( N - Math . log ( N + 1 ) / Math . log ( 2 ) ) ) ; document . write ( a ) ; }
function countValues ( A , B , C ) { if ( B >= A ) { document . write ( 0 ) ; return ; } if ( B == 0 ) { document . write ( parseInt ( C / A ) ) ; return ; } let ans = parseInt ( C / A ) ; if ( ans * A + B <= C ) { ans ++ ; } document . write ( ans ) ; }
function SieveOfEratosthenes ( n ) { for ( let i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } }
function floorDifference ( A , N , X ) { let totalSum = 0 ; let perElementSum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { totalSum += A [ i ] ; perElementSum += Math . floor ( A [ i ] / X ) ; } let totalFloorSum = Math . floor ( totalSum / X ) ; return Math . abs ( totalFloorSum - perElementSum ) ; }
function maximumSum ( arr , N ) { let ans = 0 ; for ( let bit = 0 ; bit < 32 ; bit ++ ) { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & ( 1 << bit ) ) { sum += arr [ i ] ; } } ans = Math . max ( ans , sum ) ; } return ans ; }
function maxCount ( arr , N , K ) { let st = new Set ( ) ; for ( let i = 0 ; i < N ; i ++ ) { st . add ( arr [ i ] ) ; } if ( N - st . size <= K ) { document . write ( "Yes" ) ; } else document . write ( "No" ) ; }
function kthDigitFromLast ( n , k ) { if ( k <= 0 ) { document . write ( - 1 ) ; return ; } while ( ( k - 1 ) > 0 && n > 0 ) { n = n / 10 ; k -- ; } if ( n == 0 ) { document . write ( - 1 ) ; } else { document . write ( parseInt ( n % 10 ) ) ; } }
function findWinner ( X , Y ) { let playerA = ( X ^ Y ) ; let flag = false ; for ( let i = 1 ; i <= X ; i ++ ) { for ( let j = 1 ; j <= Y ; j ++ ) { let val = ( i ^ j ) ; if ( val > playerA ) { flag = true ; break ; } } if ( flag ) { break ; } } if ( flag ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function findWinner ( X , Y ) { let first = ( X ^ Y ) ; let second = ( X + Y ) ; if ( first == second ) { document . write ( "No" ) ; } else { document . write ( "Yes" ) ; } }
function countWays ( arr , N ) { let arr_xor = 0 ; for ( let i = 0 ; i < N ; i ++ ) arr_xor ^= arr [ i ] ; let pref_xor = 0 , suff_xor = 0 ; let pref_ind = [ ] ; let suff_inds = new Array ( N + 1 ) ; suff_inds . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { pref_xor ^= arr [ i ] ; if ( pref_xor == arr_xor ) pref_ind . push ( i ) ; } for ( let i = N - 1 ; i >= 0 ; i -- ) { suff_xor ^= arr [ i ] ; suff_inds [ i ] += suff_inds [ i + 1 ] ; if ( suff_xor == arr_xor ) suff_inds [ i ] ++ ; } let tot_ways = 0 ; for ( let idx of pref_ind ) { if ( idx < N - 1 ) tot_ways += suff_inds [ idx + 2 ] ; } return tot_ways ; }
function KthSmallest ( A , B , N , K ) { let M = 0 ; for ( let i = 0 ; i < N ; i ++ ) { M = Math . max ( A [ i ] , M ) ; } let freq = Array . from ( { length : M + 1 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { freq [ A [ i ] ] += B [ i ] ; } let sum = 0 ; for ( let i = 0 ; i <= M ; i ++ ) { sum += freq [ i ] ; if ( sum >= K ) { return i ; } } return - 1 ; }
function xorSumOfArray ( arr , n , k , count ) { var sum = 0 ; var p = 1 ; for ( var i = 0 ; i < 31 ; i ++ ) { var val = 0 ; if ( ( k & ( 1 << i ) ) != 0 ) { var not_set = n - count [ i ] ; val = ( ( not_set ) * p ) ; } else { val = ( count [ i ] * p ) ; } sum += val ; p = ( p * 2 ) ; } return sum ; }
function sumOfXors ( arr , n , queries , q ) { var count = new Array ( 32 ) ; count . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < 31 ; j ++ ) { if ( arr [ i ] & ( 1 << j ) ) count [ j ] ++ ; } } for ( var i = 0 ; i < q ; i ++ ) { var k = queries [ i ] ; document . write ( xorSumOfArray ( arr , n , k , count ) + "▁" ) ; } }
function IsSumEqualsXor ( i , n , bound , s ) { if ( i == n ) return 1 ; if ( dp [ i ] [ bound ] != - 1 ) return dp [ i ] [ bound ] ; let ans = 0 ; if ( bound != 0 && s [ i ] == "0" ) { ans = IsSumEqualsXor ( i + 1 , n , 1 , s ) ; } else { ans = 2 * IsSumEqualsXor ( i + 1 , n , bound != 0 & ( s [ i ] == "1" ) ? 1 : 0 , s ) ; ans += IsSumEqualsXor ( i + 1 , n , 0 , s ) ; } dp [ i ] [ bound ] = ans  return dp [ i ] [ bound ] ; }
function findNum ( N , K ) { var rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
function findSmallest ( M , N ) { var x = findNum ( M , N ) ; return x - M ; }
function toDeci ( str , base ) { var len = str . length ; var power = 1 ; var num = 0 ; for ( var i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= base ) { document . write ( "Invalid▁Number" ) ; return - 1 ; } num += val ( str [ i ] ) * power ; power = power * base ; } return num ; }
function fact ( N ) { if ( N == 1 N == 0 ) return 1 ; return N * fact ( N - 1 ) ; }
function prefixFactorialArray ( arr , N ) { for ( let i = 1 ; i < N ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; } for ( let i = 0 ; i < N ; i ++ ) { arr [ i ] = fact ( arr [ i ] ) ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function prefixFactorialArray ( A , N ) { for ( let i = 1 ; i < N ; i ++ ) { A [ i ] += A [ i - 1 ] ; } let fact = new Array ( A [ N - 1 ] + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= A [ N - 1 ] ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; } for ( let i = 0 ; i < N ; i ++ ) { A [ i ] = fact [ A [ i ] ] ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( A [ i ] + "▁" ) ; } }
function countPairs ( arr , n , x ) { let count = 0 ; let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] - x * i ) ) { mp . set ( arr [ i ] - x * i , mp . get ( arr [ i ] - x * i ) + 1 ) } else { mp . set ( arr [ i ] - x * i , 1 ) } } for ( let x of mp ) { let n = x [ 1 ] ; count += Math . floor ( ( n * ( n - 1 ) ) / 2 ) ; } document . write ( count ) ; }
function findAverage ( N ) { var S = 0 ; var i ; for ( i = 1 ; i <= N ; i ++ ) { S += i * i * i * i ; } return S / N ; }
function findAverage ( N ) { let avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 ; return avg ; }
function ToCheckPowerofX ( n , x ) { while ( n > 0 ) { var rem = n % x ; if ( rem >= 2 ) { return false ; } n = n / x ; } return true ; }
function maximumOfTwo ( N ) { let M = reverseBin ( N ) ; return Math . max ( N , M ) ; }
function findbitwiseOR ( a , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( let j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } document . write ( res ) ; }
function findbitwiseOR ( a , n ) { var res = 0 ; var i ; for ( i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; document . write ( res ) ; }
function findDecimal ( arr , N ) { let bit , power = 0 , result = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { bit = Math . abs ( Math . floor ( arr [ i ] ) - Math . round ( arr [ i ] ) ) ; if ( bit != 0 ) result += Math . pow ( 2 , power ) ; power ++ ; } document . write ( result ) ; }
function totalMoney ( N ) { let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { ans += Math . floor ( i / 7 ) ; ans += ( i % 7 + 1 ) ; } return ans ; }
function minTime ( A , n , K ) { let max_ability = A [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { max_ability = Math . max ( max_ability , A [ i ] ) ; } let tmp = Array . from ( { length : max_ability + 1 } , ( _ , i ) => 0 ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { tmp [ A [ i ] ] ++ ; } for ( let i = max_ability ; i >= 0 ; i -- ) { if ( tmp [ i ] != 0 ) { if ( tmp [ i ] * i < K ) { K -= ( i * tmp [ i ] ) ; tmp [ ( i / 2 ) ] += tmp [ i ] ; count += tmp [ i ] ; if ( K <= 0 ) { return count ; } } else { if ( K % i != 0 ) { count += Math . floor ( K / i ) + 1 ; } else { count += Math . floor ( K / i ) ; } return count ; } } } return - 1 ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function minimumRod ( A , N ) { document . write ( N * findlcm ( A , N ) ) ; }
function check ( n ) { let sumOfDigit = 0 ; let prodOfDigit = 1 ; while ( n > 0 ) { let rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n = Math . floor ( n / 10 ) ; } if ( sumOfDigit > prodOfDigit ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function check ( N , D ) { while ( N > 0 ) { if ( findDigit ( N , D ) == true ) { return true ; } N -= D ; } return false ; }
function FindSum ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let power = Math . floor ( Math . log2 ( arr [ i ] ) ) ; let LesserValue = Math . pow ( 2 , power ) ; let LargerValue = Math . pow ( 2 , power + 1 ) ; if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) { res += arr [ i ] ; } } return res ; }
function power ( x , y ) { var res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y % 2 != 0 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
function countRelations ( N ) { document . write ( ( power ( 2 , N ) - 2 ) * power ( 2 , ( N * N ) - N ) ) ; }
function minOperations ( N ) { let arr = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { arr [ i ] = ( 2 * i ) + 1 ; sum = sum + arr [ i ] ; } let mid = 0 ; if ( N % 2 == 0 ) { mid = sum / N ; } else { mid = arr [ N / 2 ] ; } let ans = 0 ; for ( let i = 0 ; i < N / 2 ; i ++ ) { ans += mid - arr [ i ] ; } return ans ; }
function minOperation ( N ) { if ( N % 2 == 0 ) { return ( N / 2 ) * ( N / 2 ) ; } let k = ( N - 1 ) / 2 ; return k * ( k + 1 ) ; }
function findXORS ( arr1 , arr2 , N , M ) { let XORS1 = 0 ; let XORS2 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { XORS1 ^= arr1 [ i ] ; } for ( let i = 0 ; i < M ; i ++ ) { XORS2 ^= arr2 [ i ] ; } return XORS1 && XORS2 ; }
function findPermutation ( arr ) { let N = arr . length ; let i = N - 2 ; while ( i >= 0 && arr [ i ] <= arr [ i + 1 ] ) i -- ; if ( i == - 1 ) { document . write ( "-1" ) ; return ; } let j = N - 1 ; while ( j > i && arr [ j ] >= arr [ i ] ) j -- ; while ( j > i && arr [ j ] == arr [ j - 1 ] ) { j -- ; } let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; for ( let it in arr ) { document . write ( arr [ it ] + "▁" ) ; } }
function isPowerof2 ( n ) { return ( ( n & ( n - 1 ) ) && n ) ; }
function countNum ( N ) { var ans = parseInt ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; document . write ( ans ) ; }
function nearestPow ( x , base ) { let k = Math . floor ( Math . log ( x ) / Math . log ( base ) ) ; if ( Math . abs ( Math . pow ( base , k ) - x ) < Math . abs ( Math . pow ( base , ( k + 1 ) ) - x ) ) return Math . pow ( base , k ) ; else return Math . pow ( base , ( k + 1 ) ) ; }
function ceilDifference ( arr , n , x ) { var totalSum = 0 ; var perElementSum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; perElementSum += parseInt ( Math . ceil ( ( arr [ i ] ) / ( x ) ) ) ; } var totalCeilSum = parseInt ( Math . ceil ( ( totalSum ) / ( x ) ) ) ; return Math . abs ( perElementSum - totalCeilSum ) ; }
function computeTotient ( N , phi ) { for ( let p = 2 ; p <= N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( let i = 2 * p ; i <= N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
function countPairs ( N ) { let cnt_type1 = 0 , cnt_type2 = 0 ; let half_N = N / 2 ; cnt_type1 = ( half_N * ( half_N - 1 ) ) / 2 ; let phi = Array . from ( { length : N + 1 } , ( _ , i ) => 0 ) ; for ( let i = 1 ; i <= N ; i ++ ) { phi [ i ] = i ; } computeTotient ( N , phi ) ; for ( let i = ( N / 2 ) + 1 ; i <= N ; i ++ ) cnt_type2 += ( i - phi [ i ] - 1 ) ; document . write ( cnt_type1 + cnt_type2 ) ; }
function countTriplets ( N ) { let ans = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 1 ; j <= N ; j ++ ) { if ( i * j > N ) break ; ans += Math . floor ( N / ( i * j ) ) ; } } return ans ; }
function findSumOfGP ( a , r ) { if ( Math . abs ( r ) >= 1 ) { document . write ( "Infinite" ) ; return ; } let sum = a / ( 1 - r ) ; document . write ( sum ) ; }
function power ( x , y ) { let res = 1 ; x = x % mod ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
function numberOfRelations ( N ) { return power ( 3 , ( N * N - N ) / 2 ) ; }
function countNumbers ( N ) { var count = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( __gcd ( i , N ) != 1 ) count ++ ; } document . write ( count ) ; }
function phi ( N ) { let result = N ; for ( let p = 2 ; p * p <= N ; ++ p ) { if ( N % p == 0 ) { while ( N % p == 0 ) N /= p ; result -= result / p ; } } if ( N > 1 ) result -= result / N ; return result ; }
function countNumbers ( N ) { let count = N - phi ( N ) ; document . write ( count ) ; }
function Query ( arr , N , Q ) { let mul = 1 ; let add = 0 ; for ( let i = 0 ; i < Q . length ; i ++ ) { if ( Q [ i ] [ 0 ] == 0 ) { add = add + Q [ i ] [ 1 ] ; } else if ( Q [ i ] [ 0 ] == 1 ) { mul = mul * Q [ i ] [ 1 ] ; add = add * Q [ i ] [ 1 ] ; } else { let ans = arr [ Q [ i ] [ 1 ] ] * mul + add ; document . write ( ans + "▁" ) ; } } }
function nearFibo ( X ) { let a = ( Math . pow ( 5 , 0.5 ) + 1 ) / 2 ; let n = Math . floor ( Math . log ( ( Math . pow ( 5 , 0.5 ) ) * X ) / Math . log ( a ) ) ; let nth = nthFibo ( n ) ; let nplus = nthFibo ( n + 1 ) ; if ( Math . abs ( X - nth ) < Math . abs ( X - nplus ) ) return nth ; else return nplus ; }
function sieveOfEratosthenes ( N , s ) { let prime = Array . from ( { length : N + 1 } , ( _ , i ) => 0 ) ; for ( let i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( let i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( let j = i ; j * i <= N ; j += 2 ) { if ( ! prime [ i * j ] ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
function getMaxPairSum ( arr , N , K ) { var preMax = Array ( N ) ; preMax [ 0 ] = arr [ 0 ] ; for ( var i = 1 ; i < N ; i ++ ) { preMax [ i ] = Math . max ( preMax [ i - 1 ] , arr [ i ] ) ; } var res = - 1000000000 ; for ( var i = K ; i < N ; i ++ ) { res = Math . max ( res , arr [ i ] + preMax [ i - K ] ) ; } return res ; }
function sumOfInfiniteAGP ( a , d , r ) { let ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) ; document . write ( ans ) }
function countPairs ( arr , N ) { let count = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 arr [ j ] % arr [ i ] == 0 ) { count ++ ; } } } return count ; }
function CountPairs ( arr , N ) { var res = 0 ; var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } mp . forEach ( ( value , key ) => { var x = key ; var y = value ; if ( x == 1 ) { res += N - 1 ; } res += parseInt ( ( y * ( y - 1 ) ) / 2 ) ; for ( var j = 2 ; j <= parseInt ( Math . sqrt ( x ) ) ; j ++ ) { if ( x % j == 0 ) { res += mp . get ( j ) ; if ( j != parseInt ( x / j ) ) res += mp . get ( parseInt ( x / j ) ) ; } } } ) ; return res ; }
function findClosestTarget ( i , curr , B , M , K ) { if ( Math . abs ( curr - K ) < mini ) { mini = Math . abs ( curr - K ) ; ans = curr ; } if ( Math . abs ( curr - K ) == mini ) { ans = Math . min ( ans , curr ) ; } if ( i >= M ) return ; findClosestTarget ( i + 1 , curr + B [ i ] , B , M , K ) ; findClosestTarget ( i + 1 , curr + 2 * B [ i ] , B , M , K ) ; findClosestTarget ( i + 1 , curr , B , M , K ) ; }
function findClosest ( A , B , N , M , K ) { for ( let i = 0 ; i < N ; i ++ ) { findClosestTarget ( 0 , A [ i ] , B , M , K ) ; } return ans ; }
function countbits ( n ) { let count = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) count ++ ; n = Math . floor ( n / 2 ) ; } return count ; }
function BitProduct ( arr , N ) { let product = 1 ; for ( let i = 0 ; i < N ; i ++ ) { let bits = countbits ( arr [ i ] ) ; product *= bits ; } return product ; }
function removeEveryKth ( l , k ) { for ( let i = 0 ; i < l . length ; i ++ ) { if ( i % k == 0 ) l [ i ] = 0 ; } let arr = [ 0 ] ; for ( let i = 1 ; i < l . length ; i ++ ) { if ( l [ i ] != 0 ) arr . push ( l [ i ] ) ; } return arr ; }
function printArray ( l ) { for ( let i = 1 ; i < l . length ; i ++ ) document . write ( l [ i ] + "▁" ) ; }
function printSequence ( n , k ) { let l = [ 0 ] ; for ( let i = 0 ; i < n + 1 ; i ++ ) l [ i ] = i ; let x = 1 ; for ( let i = 0 ; i < k ; i ++ ) { let p = l [ x ] + l [ x + 1 ] ; l = removeEveryKth ( l , p ) ; x += 1 ; } printArray ( l ) ; }
function OddDivisorsSum ( n , q , a , Query ) { let DP = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { DP [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { let x = Math . floor ( Math . sqrt ( a [ i ] ) ) ; if ( x * x == a [ i ] ) DP [ i ] = a [ i ] ; } for ( let i = 1 ; i < n ; i ++ ) { DP [ i ] = DP [ i - 1 ] + DP [ i ] ; } for ( let i = 0 ; i < q ; i ++ ) { let l = Query [ i ] [ 0 ] ; let r = Query [ i ] [ 1 ] ; if ( l == 0 ) { document . write ( DP [ r ] + "▁" ) ; } else { document . write ( DP [ r ] - DP [ l - 1 ] + "▁" ) ; } } }
function findSubset ( arr ) { var N = arr . length ; var mp = new Map ( ) ; var totSum = 0 ; var s = 0 ; var flag = 0 ; var ans = [ ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { totSum += arr [ i ] ; if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) else mp . set ( arr [ i ] , 1 ) ; } arr . sort ( ( a , b ) => a - b )  var i = N - 1 ; while ( i >= 0 ) { var frq = mp . get ( arr [ i ] ) ; if ( ( frq + ans . length ) < ( N - ( frq + ans . length ) ) ) { for ( var k = 0 ; k < frq ; k ++ ) { ans . push ( arr [ i ] ) ; totSum -= arr [ i ] ; s += arr [ i ] ; i -- ; } } else { i -= frq ; } if ( s > totSum ) { flag = 1 ; break ; } } if ( flag == 1 ) { for ( i = ans . length - 1 ; i >= 0 ; i -- ) { document . write ( ans [ i ] + "▁" ) ; } } else { document . write ( - 1 ) ; } }
function minStepK ( arr , N , K ) { var E = 0 ; var S = 0 ; for ( var i = 0 ; i < N ; i ++ ) { S += arr [ i ] ; if ( arr [ i ] % 2 === 0 ) E += 1 ; } if ( S >= K ) return 0 ; else if ( S + E < K ) return - 1 ; else return K - S ; }
function Rotate ( n , f ) { let temp = n ; let maxi = n ; let mini = n ; for ( let idx = 0 ; idx < 7 ; idx ++ ) { if ( temp % 2 == 1 ) { temp >>= 1 ; temp += Math . pow ( 2 , 7 ) ; } else temp >>= 1 ; mini = Math . min ( mini , temp ) ; maxi = Math . max ( maxi , temp ) ; } if ( f == 1 ) return ( maxi ) ; else return ( mini ) ; }
function minimumDiff ( arr , N ) { let res = arr [ 0 ] , sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; let min_diff = sum ; for ( let i = 0 ; i < N ; i ++ ) { if ( Math . abs ( sum - ( arr [ i ] * N ) ) < min_diff ) { min_diff = Math . abs ( sum - ( arr [ i ] * N ) ) ; res = arr [ i ] ; } } document . write ( res ) ; }
function makeEqual ( arr , n ) { var fre0 = Array ( 33 ) . fill ( 0 ) ; var fre1 = Array ( 33 ) . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { var x = arr [ i ] ; for ( j = 0 ; j < 33 ; j ++ ) { if ( ( x & 1 ) != 0 ) { fre1 [ j ] += 1 ; } else { fre0 [ j ] += 1 ; } x = x >> 1 ; } } var ans = 0 ; for ( i = 0 ; i < 33 ; i ++ ) { ans += Math . min ( fre0 [ i ] , fre1 [ i ] ) ; } return ans ; }
function check ( arr , N ) { var sum = 0 ; for ( i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum == 0 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function primeDivisors ( arr , N ) { var K = arr [ 0 ] ; var i , j ; for ( i = 1 ; i < N ; i ++ ) { K = Math . max ( K , arr [ i ] ) ; } var prime = Array ( K + 1 ) . fill ( 0 ) ; prime [ 0 ] = 1 ; prime [ 1 ] = 1 ; for ( i = 2 ; i < K + 1 ; i ++ ) { if ( prime [ i ] == 0 ) { for ( j = 2 * i ; j < K + 1 ; j += i ) { prime [ j ] = 1 ; } } } var factor = Array ( K + 1 ) . fill ( 0 ) ; factor [ 0 ] = 0 ; factor [ 1 ] = 1 ; for ( i = 2 ; i < K + 1 ; i ++ ) { factor [ i ] += 1 ; for ( j = i ; j < K + 1 ; j += i ) { factor [ j ] += 1 ; } } var count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( prime [ factor [ arr [ i ] ] ] == 0 ) count ++ ; } return count ; }
function isPresent ( n , x ) { let num = ( n ) . toString ( ) ; for ( let i = 0 ; i < num . length ; i ++ ) { if ( ( num [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) == x ) return i ; } return - 1 ; }
function removeDigit ( n , index ) { let num = ( n ) . toString ( ) ; let ans = "" ; for ( let i = 0 ; i < num . length ; i ++ ) { if ( i != index ) ans += num [ i ] ; } if ( ans == "" || ( ans . length == 1 && ans [ 0 ] == "0" ) ) return - 1 ; let x = parseInt ( ans ) ; return x ; }
function reduceNtoX ( a , b , d , n ) { let q = [ ] ; q . push ( a ) ; let visited = new Map ( ) ; visited . set ( a , true ) ; while ( q . length != 0 ) { let top = q . shift ( ) ; if ( top < 0 ) continue ; if ( top == b ) return true ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! visited . has ( top / d [ i ] ) ) visited . set ( top / d [ i ] , false ) ; if ( d [ i ] != 0 && top % d [ i ] == 0 && ! visited . get ( top / d [ i ] ) ) { q . push ( top / d [ i ] ) ; visited . set ( top / d [ i ] , true ) ; } let index = isPresent ( top , d [ i ] ) ; if ( index != - 1 ) { let newElement = removeDigit ( top , index ) ; if ( ! visited . has ( newElement ) ) visited . set ( newElement , false ) ; if ( newElement != - 1 && ( ! visited . get ( newElement ) ) ) { q . push ( newElement ) ; visited . set ( newElement , true ) ; } } } } return false ; }
function SieveOfEratosthenes ( n , prime ) { prime [ 0 ] = 0 ; prime [ 1 ] = 0 ; for ( var p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == Boolean ( true ) ) { for ( var i = p * p ; i <= n ; i += p ) { prime [ i ] = Boolean ( false ) ; } } } }
function fact ( n ) { if ( n == 1 n == 0 ) return 1 ; else return n * fact ( n - 1 ) ; }
function findValue ( n , r , a ) { let k = ( a - 1 ) / fact ( n ) ; let answer = k ; for ( let i = 1 ; i < n + 1 ; i ++ ) answer = answer * ( n + r - i ) ; answer = answer + 1 ; return answer ; }
function expectedValue ( P , a , b , N ) { var expValue = P + ( N * 0.5 * ( a + b ) ) ; return expValue ; }
function startingPoint ( A , N ) { var sum = 0 ; var it = 0 ; var min = Number . MAX_VALUE ; for ( i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( sum < min ) { min = sum ; it = i + 1 ; } } if ( sum < 0 ) { return - 1 ; } return it % N ; }
function findMinSum ( mat , N ) { var sum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { var res = 0 ; for ( var j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i ] [ j ] ; } } sum += res ; } return sum ; }
function findMedian ( Mean , Mode ) { var Median = ( 2 * Mean + Mode ) / 3.0 ; document . write ( Median ) ; }
function sumOfBinaryNumbers ( n ) { let ans = 0 ; let one = 1 ; while ( true ) { if ( n <= 1 ) { ans = ( ans + n ) % MOD ; break ; } let x = Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ; let cur = 0 ; let add = Math . floor ( Math . pow ( 2 , ( x - 1 ) ) ) ; for ( let i = 1 ; i <= x ; i ++ ) { cur = ( cur + add ) % MOD ; add = ( add * 10 % MOD ) ; } ans = ( ans + cur ) % MOD ; let rem = n - Math . floor ( Math . pow ( 2 , x ) ) + 1 ; let p = Math . floor ( Math . pow ( 10 , x ) ) ; p = ( p * ( rem % MOD ) ) % MOD ; ans = ( ans + p ) % MOD ; n = rem - 1 ; } document . write ( ans ) ; }
function uniqueElementsLCM ( arr , N ) { var freq = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( freq . has ( arr [ i ] ) ) { freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . set ( arr [ i ] , 1 ) ; } } var lcm = 1 ; freq . forEach ( ( value , key ) => { if ( value == 1 ) { lcm = findLCM ( lcm , key ) ; } } ) ; if ( lcm == 1 ) lcm = - 1 ; document . write ( lcm ) ; }
function maxAdjacentDifference ( A ) { let diff = 0 ; for ( let i = 1 ; i < A . length ; i ++ ) { diff = Math . max ( diff , A [ i ] - A [ i - 1 ] ) ; } return diff ; }
function MinimumValue ( arr , N ) { let MinValue = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let new_arr = [ ] ; for ( let j = 0 ; j < N ; j ++ ) { if ( i == j ) continue ; new_arr . push ( arr [ j ] ) ; } MinValue = Math . min ( MinValue , maxAdjacentDifference ( new_arr ) ) ; } return MinValue ; }
function findNode ( mp , n ) { var a = new Array ( n ) ; var i ; for ( i = 0 ; i < n ; i ++ ) { a [ i ] = mp [ i + 1 ] ; } var count0 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count0 ++ ; } } count0 -= 1 ; if ( count0 <= parseInt ( n / 2 ) ) { document . write ( "Yes" ) ; } else document . write ( "No" ) ; }
function count ( num ) { let ans = 0 ; while ( num > 0 ) { ans += num & 1 ; num >>= 1 ; } return ans ; }
function checkGoodMatrix ( mat ) { let P = [ ] , S = [ ] , MR = [ ] , MC = [ ] ; for ( let i = 0 ; i < mat . length ; i ++ ) { for ( let j = 0 ; j < mat [ 0 ] . length ; j ++ ) { if ( i == j ) P . push ( mat [ i ] [ j ] ) ; if ( i + j == mat . length - 1 ) S . push ( mat [ i ] [ j ] ) ; if ( i == Math . floor ( ( mat . length - 1 ) / 2 ) ) MR . push ( mat [ i ] [ j ] ) ; if ( j == Math . floor ( ( mat . length - 1 ) / 2 ) ) MC . push ( mat [ i ] [ j ] ) ; } } S . reverse ( ) ; let P0 = convert ( P ) ; let S0 = convert ( S ) ; let MR0 = convert ( MR ) ; let MC0 = convert ( MC ) ; let setBitsPS = count ( ( P0 & S0 ) ) ; let setBitsMM = count ( ( MR0 & MC0 ) ) ; if ( setBitsPS > setBitsMM ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function power ( x , y ) { var res = 1 ; x = x % mod ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
function antisymmetricRelation ( N ) { return ( power ( 2 , N ) * power ( 3 , ( N * N - N ) / 2 ) ) % mod ; }
function power ( x , y ) { var res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
function asymmetricRelation ( N ) { return power ( 3 , ( N * N - N ) / 2 ) ; }
function crossProduct ( vect_A , vect_B , cross_P ) { cross_P [ 0 ] = vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ; cross_P [ 1 ] = vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ; cross_P [ 2 ] = vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ; }
function checkCollinearity ( x1 , y1 , z1 , x2 , y2 , z2 ) { let A = [ x1 , y1 , z1 ] ; let B = [ x2 , y2 , z2 ] ; let cross_P = [ ] ; crossProduct ( A , B , cross_P ) ; if ( cross_P [ 0 ] == 0 && cross_P [ 1 ] == 0 && cross_P [ 2 ] == 0 ) document . write ( "Yes" ) else document . write ( "No" ) }
function vectorMagnitude ( x , y , z ) { var sum = x * x + y * y + z * z ; return Math . sqrt ( sum ) ; }
function kineticEnergy ( M , V ) { let KineticEnergy ; KineticEnergy = 0.5 * M * V * V ; return KineticEnergy ; }
function potentialEnergy ( M , H ) { let PotentialEnergy ; PotentialEnergy = M * 9.8 * H ; return PotentialEnergy ; }
function nearestPow ( x , y ) { if ( y == 1 ) return 1  var k = Math . floor ( Math . log ( x ) / Math . log ( y ) )  if ( Math . abs ( Math . pow ( y , k ) - x ) < Math . abs ( Math . pow ( y , ( k + 1 ) ) - x ) ) return Math . pow ( y , k )  return Math . pow ( y , ( k + 1 ) ) }
function countPairs ( arr , N ) { let even = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; } if ( N - even >= 1 ) { document . write ( even ) ; return ; } document . write ( 0 ) ; }
function nearestFibonacci ( num ) { if ( num == 0 ) { document . write ( 0 ) ; return ; } let first = 0 , second = 1 ; let third = first + second ; while ( third <= num ) { first = second ; second = third ; third = first + second ; } let ans = ( Math . abs ( third - num ) >= Math . abs ( second - num ) ) ? second : third ; document . write ( ans ) ; }
function checkPermutation ( ans , a , n ) { let Max = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { Max = Math . max ( Max , ans [ i ] ) ; if ( Max != a [ i ] ) return false ; } return true ; }
function findPermutation ( a , n ) { let ans = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { ans [ i ] = 0 ; } let um = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! um . has ( a [ i ] ) ) { ans [ i ] = a [ i ] ; um . set ( a [ i ] , i ) ; } } let v = [ ] ; let j = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( ! um . has ( i ) ) { v . push ( i ) ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( ans [ i ] == 0 ) { ans [ i ] = v [ j ] ; j ++ ; } } if ( checkPermutation ( ans , a , n ) ) { for ( let i = 0 ; i < n ; i ++ ) { document . write ( ans [ i ] + "▁" ) ; } } else document . write ( "-1" ) ; }
function isPower ( m , y ) { let res1 = parseInt ( Math . log ( y ) / Math . log ( m ) ) ; let res2 = Math . log ( y ) / Math . log ( m ) ; return ( res1 == res2 ) ; }
function numSub ( arr , n , m ) { let ans = 0 ; let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isPower ( m , arr [ i ] ) ) { cnt ++ ; ans += parseInt ( ( cnt * ( cnt - 1 ) ) / 2 ) ; } else { cnt = 0 ; } } return ans ; }
function SieveOfEratosthenes ( n ) { prime . fill ( true ) ; for ( var p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( var i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } }
function assignValues ( Edges , n ) { var tree = Array . from ( Array ( n + 1 ) , ( ) => Array ( ) ) ; for ( var i = 0 ; i < n - 1 ; i ++ ) { var u = Edges [ i ] [ 0 ] ; var v = Edges [ i ] [ 1 ] ; tree [ u ] . push ( v ) ; tree [ v ] . push ( u ) ; } var visited = Array ( n + 1 ) . fill ( false ) ; var answer = Array ( n + 1 ) ; var K = 1 ; var q = [ ] ; q . push ( 1 ) ; answer [ 1 ] = K ; while ( q . length != 0 ) { var node = q [ 0 ] ; q . shift ( ) ; visited [ node ] = true ; K = ( ( answer [ node ] == 1 ) ? 2 : 1 ) ; tree [ node ] . forEach ( child => { if ( ! visited [ child ] ) { q . push ( child ) ; answer [ child ] = K ; } } ) ; } for ( var i = 1 ; i <= n ; i ++ ) { document . write ( answer [ i ] + "▁" ) ; } }
function distribute ( N , K , M , arr ) { let distribution = new Array ( N )  for ( let i = 0 ; i < N ; i ++ ) { distribution [ i ] = 0 } let ptr = K - 1 ; let rem = M ; while ( rem > 0 ) { if ( rem >= arr [ ptr ] ) { distribution [ ptr ] += arr [ ptr ] ; rem -= arr [ ptr ] ; } else { distribution [ ptr ] += rem ; rem = 0 ; } ptr = ( ptr + 1 ) % N ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( distribution [ i ] + "▁" ) } }
function sumOfSquaredDifferences ( arr , N ) { let ans = 0 ; let sumA = 0 , sumB = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sumA += ( arr [ i ] * arr [ i ] ) ; sumB += arr [ i ] ; } sumA = N * sumA ; sumB = ( sumB * sumB ) ; ans = sumA - sumB ; document . write ( ans ) ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function findMinimumNumber ( arr , N ) { findPrime ( ) ; let ans = Number . MAX_SAFE_INTEGER ; let n = primes . length ; for ( let i = 1 ; i < ( 1 << n ) ; i ++ ) { let temp = 1 ; for ( let j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) { temp *= primes [ j ] ; } } let check = true ; for ( let k = 0 ; k < N ; k ++ ) { if ( gcd ( temp , arr [ k ] ) == 1 ) { check = false ; break ; } } if ( check ) ans = Math . min ( ans , temp ) ; } document . write ( ans ) ; }
function waysToRemove ( n , m ) { var ans = 0 ; if ( m == 1 ) { document . write ( n ) ; return ; } for ( var d = 0 ; d >= 0 ; d ++ ) { var len = m + ( m - 1 ) * d ; if ( len > n ) break ; ans += ( n - len ) + 1 ; } document . write ( ans ) ; }
function countStairs ( n , x , a , b ) { var vis = Array ( n + 1 ) . fill ( 0 ) ; var moves = [ + a , - a , + b , - b ] ; var q = [ ] ; q . push ( x ) ; vis [ x ] = 1 ; while ( q . length != 0 ) { var currentStair = q [ 0 ] ; q . shift ( ) ; for ( var j = 0 ; j < 4 ; j ++ ) { var newStair = currentStair + moves [ j ] ; if ( newStair > 0 && newStair <= n && ! vis [ newStair ] ) { q . push ( newStair ) ; vis [ newStair ] = 1 ; } } } var cnt = 0 ; for ( var i = 1 ; i <= n ; i ++ ) if ( vis [ i ] == 1 ) cnt ++ ; document . write ( cnt ) ; }
function minimumSteps ( x , y ) { var cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = - 1 ; document . write ( cnt ) ; }
function cntPairs ( arr , N ) { var res = 0 ; var bit = Array ( 32 ) . fill ( 0 ) ; var i ; for ( i = 0 ; i < N ; i ++ ) { var pos = Math . ceil ( Math . log2 ( arr [ i ] ) ) ; bit [ pos ] += 1 ; } for ( i = 0 ; i < 32 ; i ++ ) { res += Math . ceil ( ( bit [ i ] * ( bit [ i ] - 1 ) ) / 2 ) ; } return res ; }
function minimumMEX ( arr , N , K ) { let s = new Set ( ) ; for ( let i = 1 ; i <= N + 1 ; i ++ ) s . add ( i ) ; for ( let i = 0 ; i < K ; i ++ ) s . delete ( arr [ i ] ) ; let entry = s . entries ( ) ; let mex = 1 ; for ( let i = K ; i < N ; i ++ ) { s . delete ( arr [ i ] ) ; s . add ( arr [ i - K ] ) ; let firstElem = entry . next ( ) . value mex = Math . min ( mex , 1 ) ; } document . write ( mex + "▁" ) ; }
function smallerNumbers ( arr , N ) { var i ; for ( i = 0 ; i < N ; i ++ ) { var count = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { count += 1 ; } } document . write ( count + "▁" ) ; } }
function gcd ( a , b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }
function minimumOperations ( X , Y ) { var GCD = gcd ( X , Y ) ; X = X / GCD ; Y = Y / GCD ; var count = 0 ; while ( X != Y ) { if ( Y > X ) { var t = X ; X = Y ; Y = t ; } if ( X % 2 == 0 ) { X = X / 2 ; } else if ( X % 3 == 0 ) { X = X / 3 ; } else if ( X % 5 == 0 ) { X = X / 5 ; } else { document . write ( "-1" ) ; return ; } count += 1 ; } document . write ( count ) ; }
function minOperations ( a , n ) { var ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { ans += a [ i ] ; } ans -= n ; for ( x = 1 ; ; x ++ ) { var curPow = 1 , curCost = 0 ; for ( i = 0 ; i < n ; i ++ ) { curCost += Math . abs ( a [ i ] - curPow ) ; curPow *= x ; } if ( curPow / x > ans + a [ n - 1 ] ) break ; ans = Math . min ( ans , curCost ) ; } return ans ; }
function truncMod ( a , n ) { let q = Math . round ( a / n ) ; return a - ( n * q ) ; }
function addEdge ( Adj , u , v ) { Adj [ u ] . push ( v ) ; Adj [ v ] . push ( u ) ; }
function isPossible ( Arr , N ) { let Adj = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) Adj [ i ] = [ ] ; for ( let i = 0 ; i < N - 1 ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] . R < Arr [ j ] . L Arr [ i ] . L > Arr [ j ] . R ) { continue ; } else { if ( Arr [ i ] . V == Arr [ j ] . V ) { addEdge ( Adj , i , j ) ; } } } } let visited = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) visited [ i ] = false ; for ( let i = 0 ; i < N ; i ++ ) { if ( visited [ i ] == false && Adj [ i ] . length > 0 ) { if ( check ( Adj , i , N , visited ) == false ) { document . write ( "No" ) ; return ; } } } document . write ( "Yes" ) ; }
function printArray ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } }
function bitOr ( arr , N ) { var count = 0 ; var length = 0 ; var i ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { length ++ ; } else { if ( length != 0 ) { count += Math . floor ( ( length ) * ( length + 1 ) / 2 ) ; } length = 0 ; } } count += Math . floor ( ( length ) * ( length + 1 ) / 2 ) ; return count ; }
function mean ( arr , N ) { var avg = 0 ; for ( var i = 0 ; i < N ; i ++ ) { avg += parseFloat ( ( arr [ i ] - avg ) / ( i + 1 ) ) ; } return avg ; }
function maximumAND ( arr , n , m ) { let tot = 1 << n ; let mx = 0 ; for ( let bm = 0 ; bm < tot ; bm ++ ) { let andans = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( ( ( bm >> i ) & 1 ) != 0 ) { if ( count == 0 ) { andans = arr [ i ] ; } else { andans = andans & arr [ i ] ; } count ++ ; } } if ( count == ( m + 1 ) ) { mx = Math . max ( mx , andans ) ; } } return mx ; }
function findTotalSum ( ops ) { if ( ops . length == 0 ) { document . write ( 0 ) ; return ; } var pts = [ ] ; var ans = 0 ; for ( var i = 0 ; i < ops . length ; i ++ ) { if ( ops [ i ] == "C" ) { ans -= pts [ pts . length - 1 ] ; pts . pop ( ) ; } else if ( ops [ i ] == "D" ) { pts . push ( pts [ pts . length - 1 ] * 2 ) ; ans += pts [ pts . length - 1 ] ; } else if ( ops [ i ] == "+" ) { var a = pts [ pts . length - 1 ] ; pts . pop ( ) ; var b = pts [ pts . length - 1 ] ; pts . push ( a ) ; ans += ( a + b ) ; pts . push ( a + b ) ; } else { var n = parseInt ( ops [ i ] ) ; ans += n ; pts . push ( n ) ; } } document . write ( ans ) ; }
function findXOR ( mat , N ) { let XOR = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { for ( let k = 0 ; k < N ; k ++ ) { if ( ( i == j && j == k ) ) { XOR ^= mat [ i ] [ j ] [ k ] ; XOR ^= mat [ i ] [ j ] [ N - k - 1 ] ; } } } } document . write ( XOR ) ; }
function findXOR ( mat , N ) { let XOR = 0 ; for ( let i = 0 ; i < N ; i ++ ) { XOR ^= mat [ i ] [ i ] [ i ] ; XOR ^= mat [ i ] [ i ] [ N - i - 1 ] ; } document . write ( XOR ) ; }
function countSubtreesUtil ( cur , par ) { var res = 1 ; for ( var i = 0 ; i < graph [ cur ] . length ; i ++ ) { var v = graph [ cur ] [ i ] ; if ( v == par ) continue ; res = ( res * ( countSubtreesUtil ( v , cur ) + 1 ) ) % mod ; } ans = ( ans + res ) % mod ; return res ; }
function countSubtrees ( N , adj ) { for ( var i = 0 ; i < N - 1 ; i ++ ) { var a = adj [ i ] [ 0 ] ; var b = adj [ i ] [ 1 ] ; graph [ a ] . push ( b ) ; graph [ b ] . push ( a ) ; } countSubtreesUtil ( 1 , 1 ) ; document . write ( ans + 1 ) ; }
function sieve ( ) { for ( p = 2 ; p * p <= limit ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * p ; i <= limit ; i += p ) prime [ i ] = false ; } } }
function findOperations ( arr , n ) { sieve ( ) ; var minm = Number . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { minm = Math . min ( minm , arr [ i ] ) ; } var val = minm ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == minm + 1 ) { val = minm - 2 ; break ; } } var cnt = 0 ; for ( i = 0 ; i < n ; i ++ ) { var D = arr [ i ] - val ; if ( D == 0 ) { continue ; } else if ( prime [ D ] == true ) { cnt += 1 ; } else if ( D % 2 == 0 ) { cnt += 2 ; } else { if ( prime [ D - 2 ] == true ) { cnt += 2 ; } else { cnt += 3 ; } } } return cnt ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function maximumRowValue ( n , m ) { return gcd ( n , m ) ; }
function checkCommonDivisor ( arr , N , X ) { var G = 0 ; for ( i = 0 ; i < N ; i ++ ) { G = gcd ( G , arr [ i ] ) ; } var copy_G = G ; for ( divisor = 2 ; divisor <= X ; divisor ++ ) { while ( G % divisor == 0 ) { G = G / divisor ; } } if ( G <= X ) { document . write ( "Yes" ) ; for ( i = 0 ; i < N ; i ++ ) document . write ( ( arr [ i ] / copy_G ) + "▁" ) ; document . write ( ) ; } else document . write ( "No" ) ; }
function countPairs ( arr , N ) { var count = 0 ; var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { var val = 1.0 * arr [ i ] ; var idx = 1.0 * ( i + 1 ) ; count += mp . has ( val / idx ) ? mp . get ( val / idx ) : 0  if ( mp . has ( val / idx ) ) mp . set ( val / idx , mp . get ( val / idx ) + 1 ) else mp . set ( val / idx , 1 ) } document . write ( count ) ; }
function findConvolution ( a , b ) { let n = a . length , m = b . length ; let c = [ ] ; for ( let i = 0 ; i < n + m - 1 ; ++ i ) { c [ i ] = 0 ; } for ( let i = 0 ; i < n ; ++ i ) { for ( let j = 0 ; j < m ; ++ j ) { c [ i + j ] += ( a [ i ] * b [ j ] ) % MOD ; } } for ( let k = 0 ; k < c . length ; ++ k ) { c [ k ] %= MOD ; document . write ( c [ k ] + "▁" ) ; } }
function count1s ( start_i , start_j , end_i , end_j , mat ) { let count = 0 ; for ( let x = start_i ; x < end_i ; x ++ ) { for ( let y = start_j ; y < end_j ; y ++ ) { if ( mat [ x ] [ y ] == 1 ) count ++ ; } } return count ; }
function findMinimumCount ( N , M , A , B , mat ) { let minimum = 1e9 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( i + A <= N && j + B <= M ) { let count = count1s ( i , j , i + A , j + B , mat ) ; minimum = Math . min ( count , minimum ) ; } if ( i + B <= N && j + A <= M ) { let count = count1s ( i , j , i + B , j + A , mat ) ; minimum = Math . min ( count , minimum ) ; } } } return minimum ; }
function checkEvenPower ( n ) { var x = 0 ; while ( x < n ) { var value = Math . pow ( 2 , x ) ; if ( value == n ) { if ( x % 2 == 0 ) return true ; else return false ; } x ++ ; } return false ; }
function getMaxUtil ( p , arr , ans , chosen , N ) { if ( p . length == N ) { ans = Math . max ( ans , calcScore ( p , arr , N ) ) ; return ans ; } for ( var i = 0 ; i < N ; i ++ ) { if ( chosen [ i ] ) { continue ; } chosen [ i ] = true ; p . push ( i ) ; ans = getMaxUtil ( p , arr , ans , chosen , N ) ; chosen [ i ] = false ; p . pop ( ) ; } return ans ; }
function getMax ( arr , N ) { var ans = 0 ; var chosen = Array ( N ) . fill ( false ) ; var p = [ ] ; var res = getMaxUtil ( p , arr , ans , chosen , N ) ; document . write ( res ) ; }
function multiplyByMersenne ( N , M ) { let x = ( Math . log ( M + 1 ) / Math . log ( 2 ) ) ; return ( ( N << x ) - N ) ; }
function findSum ( N , K ) { var ans = 0 ; var i = 1 ; while ( i <= N ) { ans += Math . floor ( N / i ) ; i = i * K ; } document . write ( ans ) ; }
function minimumInsertions ( arr , N , K ) { var possible = true ; var res = 0 ; var last = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= K ) { possible = false ; break ; } if ( last + arr [ i ] > K ) res ++ ; last = arr [ i ] ; } if ( possible ) { document . write ( res ) ; } else { document . write ( "-1" ) ; } }
function maxSubSum ( arr , n , k , totalDistinct ) { if ( k > n ) return 0 ; var maxm = 0 , sum = 0 ; for ( var i = 0 ; i < n - k + 1 ; i ++ ) { sum = 0 ; var st = new Set ( ) ; for ( var j = i ; j < i + k ; j ++ ) { sum += arr [ j ] ; st . add ( arr [ j ] ) ; } if ( st . size == totalDistinct ) maxm = Math . max ( sum , maxm ) ; } return maxm ; }
function distinct ( arr , N ) { var st = new Set ( ) ; for ( var i = 0 ; i < N ; i ++ ) { st . add ( arr [ i ] ) ; } return st . size ; }
function maxSubarraySumUtil ( arr , N , K , totalDistinct ) { if ( K > N ) return 0 ; var mx = 0 ; var sum = 0 ; var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) else mp . set ( arr [ i ] , 1 )  sum += arr [ i ] ; if ( i >= K ) { if ( mp . has ( arr [ i - K ] ) ) mp . set ( arr [ i - K ] , mp . get ( arr [ i - K ] ) - 1 )  sum -= arr [ i - K ] ; if ( mp . has ( arr [ i - K ] ) && mp . get ( arr [ i - K ] ) == 0 ) mp . delete ( arr [ i - K ] ) ; } if ( mp . size == totalDistinct ) mx = Math . max ( mx , sum ) ; } return mx ; }
function maxSubarraySum ( arr , K ) { var N = arr . length ; var totalDistinct = distinct ( arr , N ) ; document . write ( maxSubarraySumUtil ( arr , N , K , totalDistinct ) ) ; }
function irreflexiveRelation ( N ) { return power ( 2 , N * N - N ) ; }
function countAPs ( N ) { let count = 0 ; for ( let i = 1 ; i * i <= 2 * N ; i ++ ) { let res = 2 * N ; if ( res % i == 0 ) { let op = res / i - i + 1 ; if ( op % 2 == 0 ) { count ++ ; } if ( i * i != res && ( i - res / i + 1 ) % 2 == 0 ) { count ++ ; } } } document . write ( count - 1 ) ; }
function perfectSquare ( num ) { let sr = Math . floor ( Math . sqrt ( num ) ) ; let a = sr * sr ; let b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( num - a ) < ( b - num ) ) { return a ; } else { return b ; } }
function powerOfTwo ( num ) { let lg = Math . floor ( Math . log2 ( num ) ) ; let p = Math . pow ( 2 , lg ) ; return p ; }
function uniqueElement ( arr , N ) { let ans = true ; arr . reverse ( ) ; let freq = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; if ( freq . has ( arr [ i ] ) ) { freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) } else [ freq . set ( arr [ i ] , 1 ) ] } for ( let el of freq ) { if ( el [ 1 ] == 1 ) { ans = false ; let ps = perfectSquare ( el [ 0 ] ) ; document . write ( powerOfTwo ( ps ) + "▁" ) ; } } if ( ans ) document . write ( "-1" ) ; }
function canExpress ( N ) { var temp = N ; var n = 0 ; while ( N != 0 ) { N = parseInt ( N / 10 ) ; n ++ ; } N = temp ; var sum = 0 ; while ( N != 0 ) { sum += Math . pow ( N % 10 , n ) ; N = parseInt ( N / 10 ) ; } return ( sum == temp ) ; }
function precompute ( ) { for ( var i = 1 ; i < R ; i ++ ) { if ( canExpress ( i ) ) { arr [ i ] = 1 ; } } for ( var i = 1 ; i < R ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; } }
function countNumbers ( queries , N ) { precompute ( ) ; for ( var i = 0 ; i < N ; i ++ ) { var L1 = queries [ i ] [ 0 ] ; var R1 = queries [ i ] [ 1 ] ; document . write ( ( arr [ R1 ] - arr [ L1 - 1 ] ) + "▁" ) ; } }
function isAnyPrime ( first , last ) { var num1 = first * 10 + last ; var num2 = last * 10 + first ; if ( sieve [ num1 ] == 1 sieve [ num2 ] == 1 ) return true ; else return false ; }
function sumOfNodeInAPath ( node_value ) { let sum_of_node = 0 ; while ( node_value ) { sum_of_node += node_value ; node_value = Math . floor ( node_value / 2 ) ; } document . write ( sum_of_node ) ; return ; }
function findSum ( Q ) { for ( let i = 0 ; i < Q . length ; i ++ ) { let node_value = Q [ i ] ; sumOfNodeInAPath ( node_value ) ; document . write ( "▁" ) ; } }
function oddDivisor ( N ) { var X = N ; var i ; while ( N % 2 == 0 ) { N /= 2 ; } for ( i = 3 ; i * i <= X ; i += 2 ) { if ( N % i == 0 ) { return "Yes" ; } } if ( N != X ) return "Yes" ; return "No" ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
function preprocess ( ) { for ( i = 1 ; i <= 1000000 ; i ++ ) primes [ i ] = i ; for ( i = 2 ; i * i <= 1000000 ; i ++ ) { if ( primes [ i ] == i ) { for ( j = 2 * i ; j <= 1000000 ; j += i ) { if ( primes [ j ] == j ) primes [ j ] = i ; } } } }
function Steps ( x , m ) { var steps = 0 ; var flag = false ; while ( x > 1 ) { if ( primes [ x ] > m ) { flag = true ; break ; } x /= primes [ x ] ; steps ++ ; } if ( flag ) return - 1 ; return steps ; }
function minimumSteps ( x , y , m ) { preprocess ( ) ; var g = gcd ( x , y ) ; x = x / g ; y = y / g ; var x_steps = Steps ( x , m ) ; var y_steps = Steps ( y , m ) ; if ( x_steps == - 1 y_steps == - 1 ) return - 1 ; return x_steps + y_steps ; }
function LongestNonDeficientSubsequence ( arr , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isNonDeficient ( arr [ i ] ) ) { res += 1 ; } } return res ; }
function findSum ( n ) { var sum = 0 ; for ( i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == 2 ) { sum += num ; i ++ ; } } return sum ; }
function check ( n , k ) { var s = findSum ( k - 1 ) ; if ( s >= n ) document . write ( "No" ) ; else document . write ( "Yes" ) ; }
function setBitCount ( n ) { let ans = 0 ; while ( n != 0 ) { ans += n & 1 ; n >>= 1 ; } return ans ; }
function isPronic ( n ) { let range = Math . sqrt ( n ) ; for ( let i = 0 ; i < range + 1 ; i ++ ) { if ( i * ( i + 1 ) == n ) return true ; } return false ; }
function LOG ( a , b ) { return parseInt ( Math . log ( a ) / Math . log ( b ) ) ; }
function countSubsequences ( A ) { var odd = 0 ; var even = 0 ; for ( var e1 = 0 ; e1 < A . length ; e1 ++ ) { if ( A [ e1 ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 ) document . write ( 0 ) ; else document . write ( ( 1 << ( A . length - 1 ) ) ) ; }
function gcd ( a , b ) { while ( b > 0 ) { let rem = a % b ; a = b ; b = rem ; } return a ; }
function countNumberOfWays ( n ) { if ( n == 1 ) return - 1 ; let g = 0 ; let power = 0 ; while ( n % 2 == 0 ) { power ++ ; n /= 2 ; } g = gcd ( g , power ) ; for ( let i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { power = 0 ; while ( n % i == 0 ) { power ++ ; n /= i ; } g = gcd ( g , power ) ; } if ( n > 2 ) g = gcd ( g , 1 ) ; let ways = 1 ; power = 0 ; while ( g % 2 == 0 ) { g /= 2 ; power ++ ; } ways *= ( power + 1 ) ; for ( let i = 3 ; i <= Math . sqrt ( g ) ; i += 2 ) { power = 0 ; while ( g % i == 0 ) { power ++ ; g /= i ; } ways *= ( power + 1 ) ; } if ( g > 2 ) ways *= 2 ; return ways ; }
function coprime ( a , b ) { if ( GCD ( a , b ) == 1 ) return true ; return false ; }
function noOfCoPrimePairs ( N , d1 , d2 ) { let l = [ ] ; l . push ( d1 . toString ( ) ) ; l . push ( d2 . toString ( ) ) ; l . sort ( ) ; if ( N < parseInt ( l [ 1 ] ) ) return ; let total = [ ... l ] ; let temp2 = [ ... l ] ; let flag = 0 ; let temp3 = [ ] ; while ( l [ 0 ] . length < 10 ) { for ( let i = 0 ; i < l . length ; i ++ ) { for ( let j = 0 ; j < 2 ; j ++ ) { if ( parseInt ( l [ i ] + temp2 [ j ] ) > N ) { flag = 1 ; break ; } total . push ( l [ i ] + temp2 [ j ] ) ; temp3 . push ( l [ i ] + temp2 [ j ] ) ; } if ( flag == 1 ) break ; } if ( flag == 1 ) break ; l = [ ... temp3 ] ; temp3 = [ ] ; } let lenOfTotal = total . length ; let ans = numOfPairs ( total , lenOfTotal ) ; document . write ( ans ) ; }
function countEqualElementPairs ( arr , N ) { var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } var total = 0 ; mp . forEach ( ( value , key ) => { total += ( value * ( value - 1 ) ) / 2 ; } ) ; for ( var i = 0 ; i < N ; i ++ ) { document . write ( total - ( mp . get ( arr [ i ] ) - 1 ) + "▁" ) ; } }
function minDeletions ( arr , N ) { var freq = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( freq . has ( arr [ i ] ) ) { freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . set ( arr [ i ] , 1 ) ; } } var v = [ ] ; freq . forEach ( ( value , key ) => { v . push ( value ) ; } ) ; v . sort ( ) ; var size = v . length ; var ans = N - ( v [ 0 ] * size ) ; for ( var i = 1 ; i < v . length ; i ++ ) { if ( v [ i ] != v [ i - 1 ] ) { var safe = v [ i ] * ( size - i ) ; ans = Math . min ( ans , N - safe ) ; } } document . write ( ans ) ; }
function countPairs ( arr , N ) { let odd = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; } let ans = ( N - odd + Math . floor ( odd / 2 ) - 1 ) + Math . floor ( odd / 2 ) ; return ans ; }
function countBit ( n ) { return parseInt ( log2 ( n ) ) + 1 ; }
function countSetBit ( n ) { let ans = 0 ; while ( n > 0 ) { ans += ( n & 1 ) ; n >>= 1 ; } return ans ; }
function maximize ( n ) { let bits = countBit ( n ) ; let setBits = countSetBit ( n ) ; let ans = 0 ; for ( let i = 0 ; i < bits ; i ++ ) { if ( i < setBits ) ans |= 1 ; if ( i != setBits - 1 ) ans <<= 1 ; } return ans ; }
function minimize ( n ) { let setBits = countSetBit ( n ) ; let ans = 0 ; for ( let i = 0 ; i < setBits ; i ++ ) { ans |= 1 ; if ( i != setBits - 1 ) ans <<= 1 ; } return ans ; }
function maxDiff ( arr ) { let caseOne = 0 ; let SumOfOdd = 0 ; let SumOfeven = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( i % 2 ) SumOfOdd += minimize ( arr [ i ] ) ; else SumOfeven += maximize ( arr [ i ] ) ; } caseOne = Math . abs ( SumOfOdd - SumOfeven ) ; let caseTwo = 0 ; SumOfOdd = 0 ; SumOfeven = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( i % 2 ) SumOfOdd += maximize ( arr [ i ] ) ; else SumOfeven += minimize ( arr [ i ] ) ; } caseTwo = Math . abs ( SumOfOdd - SumOfeven ) ; return Math . max ( caseOne , caseTwo ) ; }
function isVowel ( c ) { let vowel = "aeiou" ; for ( let i = 0 ; i < vowel . length ; ++ i ) { if ( vowel [ i ] == c ) { return true ; } } return false ; }
function printRLE ( str , typed ) { let n = str . length , m = typed . length ; let j = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] != typed [ j ] ) { return false ; } if ( isVowel ( str [ i ] ) == false ) { j ++ ; continue ; } let count1 = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count1 ++ ; i ++ ; } let count2 = 1 ; while ( j < m - 1 && typed [ j ] == str [ i ] ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) { return false ; } } return true ; }
function findSplit ( arr , N ) { let l = 1 , r = N - 2 ; let lsum , msum , rsum ; let sum = new Array ( N ) ; sum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { sum [ i ] = sum [ i - 1 ] + arr [ i ] ; } while ( l < r ) { lsum = sum [ l - 1 ] ; msum = sum [ r - 1 ] - sum [ l ] ; rsum = sum [ N - 1 ] - sum [ r ] ; if ( lsum == msum && msum == rsum ) { document . write ( l + "▁" + r ) ; return ; } if ( lsum < rsum ) l ++ ; else if ( lsum > rsum ) r -- ; else { l ++ ; r -- ; } } document . write ( - 1 ) ; }
function solve ( A , n , Q , q ) { var one = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( A [ i ] == 1 ) one ++ ; var glows = 0 , count = 0 ; if ( one >= Math . ceil ( n / 2 ) ) glows = 1 ; for ( var i = 0 ; i < q ; i ++ ) { var prev = glows ; if ( A [ Q [ i ] - 1 ] == 1 ) one -- ; if ( A [ Q [ i ] - 1 ] == 0 ) one ++ ; A [ Q [ i ] - 1 ] ^= 1 ; if ( one >= Math . ceil ( n / 2.0 ) ) { glows = 1 ; } else { glows = 0 ; } if ( prev != glows ) count ++ ; } return count ; }
function elementsHavingDigitSumK ( arr , N , K ) { let count = 0 ; for ( let i = 0 ; i < N ; ++ i ) { if ( sumOfDigits ( arr [ i ] ) == K ) { count ++ ; } } document . write ( count ) ; }
function processDiagonal ( arr ) { let ans = 0 ; let getBit = 1 ; for ( let i = 0 ; i < 32 ; i ++ ) { let S = 0 ; let NS = 0 ; for ( let j = 0 ; j < arr . length ; j ++ ) { if ( getBit & arr [ j ] ) S += 1 ; else NS += 1 ; } if ( S > NS ) ans += Math . pow ( 2 , i ) ; getBit <<= 1 ; } return ans ; }
function findSum ( mat ) { let i = 0 ; let j = 0 ; let priDiag = [ ] ; while ( i < mat . length ) { priDiag . push ( mat [ i ] [ j ] ) ; i += 1 ; j += 1 ; } i = 0 ; j = mat . length - 1 ; let secDiag = [ ] ; while ( i < mat . length ) { secDiag . push ( mat [ i ] [ j ] ) ; i += 1 ; j -= 1 ; } return processDiagonal ( priDiag ) + processDiagonal ( secDiag ) ; }
function minimumDifference ( N ) { var sum1 = ( 1 << N ) , sum2 = 0 ; for ( i = 1 ; i < N / 2 ; i ++ ) sum1 += ( 1 << i ) ; for ( i = N / 2 ; i < N ; i ++ ) sum2 += ( 1 << i ) ; document . write ( sum1 - sum2 ) ; }
